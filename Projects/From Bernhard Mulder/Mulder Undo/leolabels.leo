<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="296" clone_windows="0"/>
<globals body_outline_ratio="0.400278940028">
	<global_window_position top="40" left="176" height="948" width="1280"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="bwmulder.20040531110909" tnodeList="bwmulder.20040531110909,bwmulder.20040531110909.1,bwmulder.20040531110909.2,bwmulder.20040531211637,bwmulder.20040531110909.3,bwmulder.20040531110909.4,bwmulder.20040531110909.5,bwmulder.20040531110909.6,bwmulder.20040531110909.7,bwmulder.20040531110909.8,bwmulder.20040531110909.9,bwmulder.20040531110909.10,bwmulder.20040531110909.11,bwmulder.20040531110909.12,bwmulder.20040531110909.13,bwmulder.20040531110909.14,bwmulder.20040531110909.15,bwmulder.20040531110909.16,bwmulder.20040531110909.17,bwmulder.20040531110909.18,bwmulder.20040531110909.19,bwmulder.20040531110909.20,bwmulder.20040531110909.21,bwmulder.20040531110909.22,bwmulder.20040531110909.23,bwmulder.20040531110909.24,bwmulder.20040531110909.25,bwmulder.20040531110909.26,bwmulder.20040531110909.27,bwmulder.20040531110909.28,bwmulder.20040531110909.29,bwmulder.20040531110909.30,bwmulder.20040531110909.31,bwmulder.20040531110909.32,bwmulder.20040531110909.33,bwmulder.20040531110909.34,bwmulder.20040531110909.35,bwmulder.20040531110909.36,bwmulder.20040531110909.37,bwmulder.20040531110909.38,bwmulder.20040531110909.39,bwmulder.20040531110909.40,bwmulder.20040531110909.41,bwmulder.20040531110909.42,bwmulder.20040531110909.43,bwmulder.20040531110909.44,bwmulder.20040531110909.45,bwmulder.20040531110909.46,bwmulder.20040531110909.47,bwmulder.20040531110909.48,bwmulder.20040531110909.49,bwmulder.20040531110909.50,bwmulder.20040531110909.51,bwmulder.20040531110909.52,bwmulder.20040531110909.53,bwmulder.20040531110909.54,bwmulder.20040531110909.55,bwmulder.20040531110909.56,bwmulder.20040531110909.57,bwmulder.20040531110909.58,bwmulder.20040531110909.59,bwmulder.20040531110909.60,bwmulder.20040531110909.61,bwmulder.20040531110909.62,bwmulder.20040531110909.63,bwmulder.20040531110909.64,bwmulder.20040531110909.65,bwmulder.20040531110909.66,bwmulder.20040531110909.67,bwmulder.20040531110909.68,bwmulder.20040531110909.69,bwmulder.20040531110909.70,bwmulder.20040531110909.71,bwmulder.20040531110909.72,bwmulder.20040531110909.73,bwmulder.20040531110909.74,bwmulder.20040531110909.75,bwmulder.20040531110909.76,bwmulder.20040531110909.77,bwmulder.20040531110909.78,bwmulder.20040531110909.79,bwmulder.20040531110909.80,bwmulder.20040531110909.81,bwmulder.20040531110909.82,bwmulder.20040531110909.83,bwmulder.20040531110909.84,bwmulder.20040531110909.85,bwmulder.20040531110909.86,bwmulder.20040531110909.87,bwmulder.20040531110909.88,bwmulder.20040531110909.89,bwmulder.20040531110909.90,bwmulder.20040531110909.91,bwmulder.20040531110909.92,bwmulder.20040531110909.93,bwmulder.20040531110909.94,bwmulder.20040531110909.95,bwmulder.20040531110909.96,bwmulder.20040531110909.97,bwmulder.20040531110909.98,bwmulder.20040531110909.99,bwmulder.20040531110909.100,bwmulder.20040531110909.101,bwmulder.20040531110909.102,bwmulder.20040531110909.103,bwmulder.20040531110909.104,bwmulder.20040531110909.105,bwmulder.20040531110909.106,bwmulder.20040531110909.107,bwmulder.20040531110909.108,bwmulder.20040531110909.109,bwmulder.20040531110909.110,bwmulder.20040531110909.111"><vh>@file ../plugins/mod_labels.py</vh>
<v t="bwmulder.20040531110909.1"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.2"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="bwmulder.20040531211637"><vh>&lt;&lt;test switches&gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.3"><vh>menunames</vh></v>
<v t="bwmulder.20040531110909.4"><vh>Pmw</vh>
<v t="bwmulder.20040531110909.5"><vh>class Pmw_combobox</vh></v>
<v t="bwmulder.20040531110909.6"><vh>class Pmw_MessageDialog</vh></v>
</v>
<v t="bwmulder.20040531110909.7"><vh>overwrites in Leo</vh>
<v t="bwmulder.20040531110909.8"><vh>overwriteLeo</vh></v>
<v t="bwmulder.20040531110909.9"><vh>copyAllTempBodyStringsToTnodes</vh></v>
</v>
<v t="bwmulder.20040531110909.10"><vh>different Command classes</vh>
<v t="bwmulder.20040531110909.11"><vh>Base Command for all Commands</vh>
<v t="bwmulder.20040531110909.12"><vh>Base_Label_Command</vh>
<v t="bwmulder.20040531110909.13" a="M"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.14"><vh>remove_label</vh></v>
<v t="bwmulder.20040531110909.15"><vh>set_dirty</vh></v>
</v>
<v t="bwmulder.20040531110909.16"><vh>Base_Label_Node_Command</vh>
<v t="bwmulder.20040531110909.17"><vh>__init__</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.18"><vh>Creating Labels</vh>
<v t="bwmulder.20040531110909.19"><vh>menu_add_label_node_command</vh>
<v t="bwmulder.20040531110909.20"><vh>do</vh></v>
<v t="bwmulder.20040531110909.21"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.22"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.23"><vh>marks_to_label_command</vh>
<v t="bwmulder.20040531110909.24"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.25"><vh>do</vh></v>
<v t="bwmulder.20040531110909.26"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.27"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.28"><vh>label_to_marks_command</vh>
<v t="bwmulder.20040531110909.29"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.30"><vh>do</vh></v>
<v t="bwmulder.20040531110909.31"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.32"><vh>redo</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.33"><vh>Deleting Labels</vh>
<v t="bwmulder.20040531110909.34"><vh>delete_node_label_command</vh>
<v t="bwmulder.20040531110909.35"><vh>do</vh></v>
<v t="bwmulder.20040531110909.36"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.37"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.38"><vh>delete_label_command</vh>
<v t="bwmulder.20040531110909.39"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.40"><vh>do</vh></v>
<v t="bwmulder.20040531110909.41"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.42"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.43"><vh>delete_labels_command</vh>
<v t="bwmulder.20040531110909.44"><vh>do</vh></v>
<v t="bwmulder.20040531110909.45"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.46"><vh>redo</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.47"><vh>creating subnodes</vh>
<v t="bwmulder.20040531110909.48"><vh>base_command_label_to_subnode</vh>
<v t="bwmulder.20040531110909.49"><vh>create_subnodes_for_labels</vh></v>
</v>
<v t="bwmulder.20040531110909.50"><vh>command_label_to_subnode</vh>
<v t="bwmulder.20040531110909.51"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.52"><vh>do</vh></v>
<v t="bwmulder.20040531110909.53"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.54"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.55"><vh>command_label_to_subnodes</vh>
<v t="bwmulder.20040531110909.56"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.57"><vh>do</vh></v>
<v t="bwmulder.20040531110909.58"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.59"><vh>redo</vh></v>
</v>
<v t="bwmulder.20040531110909.60"><vh>command_labels_to_subnodes</vh>
<v t="bwmulder.20040531110909.61"><vh>do</vh></v>
<v t="bwmulder.20040531110909.62"><vh>undo</vh></v>
<v t="bwmulder.20040531110909.63"><vh>redo</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040531110909.64"><vh>class handle_mark_labels</vh>
<v t="bwmulder.20040531110909.65"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.66"><vh>subroutines</vh>
<v t="bwmulder.20040531110909.67"><vh>iterators</vh>
<v t="bwmulder.20040531110909.68"><vh>iterator</vh></v>
<v t="bwmulder.20040531110909.69"><vh>iterator_node</vh></v>
</v>
<v t="bwmulder.20040531110909.70"><vh>getters and setters</vh>
<v t="bwmulder.20040531110909.71"><vh>get_labels_dict</vh></v>
<v t="bwmulder.20040531110909.72"><vh>set_labels_dict</vh></v>
<v t="bwmulder.20040531110909.73"><vh>add_label</vh></v>
</v>
<v t="bwmulder.20040531110909.74"><vh>collect_labels</vh></v>
<v t="bwmulder.20040531110909.75"><vh>insert_node_for_label_as_child</vh></v>
<v t="bwmulder.20040531110909.76"><vh>unconditionally_insert_node_for_label_as_child</vh></v>
<v t="bwmulder.20040531110909.77"><vh>check_if_Child_with_labelname_exists</vh></v>
<v t="bwmulder.20040531110909.78"><vh>insert_nodes_for_labels_as_children</vh></v>
<v t="bwmulder.20040531110909.79"><vh>select_label</vh></v>
<v t="bwmulder.20040531110909.80"><vh>select_node_label</vh></v>
<v t="bwmulder.20040531110909.81"><vh>current_node_and_labels</vh></v>
<v t="bwmulder.20040531110909.82"><vh>get_labellist_for_node</vh></v>
<v t="bwmulder.20040531110909.83"><vh>show_label_list_box</vh></v>
<v t="bwmulder.20040531110909.84"><vh>create_subnodes_for_labelname</vh></v>
<v t="bwmulder.20040531110909.85"><vh>find_nodes_with_labelname</vh></v>
<v t="bwmulder.20040531110909.86"><vh>find_all_labels_in_all_nodes</vh></v>
<v t="bwmulder.20040531110909.87"><vh>clone</vh></v>
<v t="bwmulder.20040531110909.88"><vh>move_to_child_positions</vh></v>
</v>
<v t="bwmulder.20040531110909.89"><vh>showing labels</vh>
<v t="bwmulder.20040531110909.90"><vh>show_labels</vh></v>
<v t="bwmulder.20040531110909.91"><vh>show_labels_for_node</vh></v>
</v>
<v t="bwmulder.20040531110909.92"><vh>Creating labels and marking nodes</vh>
<v t="bwmulder.20040531110909.93"><vh>menu_add_label_node</vh></v>
<v t="bwmulder.20040531110909.94"><vh>marks_to_label</vh></v>
<v t="bwmulder.20040531110909.95"><vh>label_to_marks</vh></v>
</v>
<v t="bwmulder.20040531110909.96"><vh>deleting labels.</vh>
<v t="bwmulder.20040531110909.97"><vh>delete_node_label</vh></v>
<v t="bwmulder.20040531110909.98"><vh>delete_label</vh></v>
<v t="bwmulder.20040531110909.99"><vh>delete_labels</vh></v>
</v>
<v t="bwmulder.20040531110909.100"><vh>Converting labels to subnodes and back.</vh>
<v t="bwmulder.20040531110909.101"><vh>creating subnodes</vh>
<v t="bwmulder.20040531110909.102"><vh>label_to_subnode</vh></v>
<v t="bwmulder.20040531110909.103"><vh>label_to_subnodes</vh></v>
<v t="bwmulder.20040531110909.104"><vh>labels_to_subnodes</vh></v>
</v>
<v t="bwmulder.20040531110909.105"><vh>updating labels from subnodes</vh>
<v t="bwmulder.20040531110909.106"><vh>subnode_to_label</vh></v>
<v t="bwmulder.20040531110909.107"><vh>subnodes_to_label</vh></v>
<v t="bwmulder.20040531110909.108"><vh>subnodes_to_labels</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.109"><vh>cloning</vh>
<v t="bwmulder.20040531110909.110"><vh>clone_label_subnodes</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.111"><vh>create_mark_extensions</vh></v>
</v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.new.py</vh></v>
<v t="bwmulder.20040601212737" a="E"><vh>@thin basic_undo.py</vh></v>
<v t="bwmulder.20040602221559"><vh>@thin basic_undo_test.py</vh></v>
<v t="bwmulder.20040605111113"><vh>@thin basic_undo_profile.py</vh></v>
<v t="bwmulder.20040605120821" tnodeList="bwmulder.20040605120821"><vh>@file basic_undo_report.bat</vh></v>
<v t="ekr.20031218072017.2620"><vh>@thin leoAtFile.new.py</vh></v>
<v t="bwmulder.20040531110909.112" labels="7d7100550e6265666f7265206368616e67653a7101586b060000406c616e677561676520707974686f6e0a3c3c646f63737472696e673e3e0a3c3c696d706f7274733e3e0a5f5f76657273696f6e5f5f203d2022302e32220a0a406f74686572730a200a646566206372656174655f6d61726b5f657874656e73696f6e73287461672c206b6579776f726473293a0a202020676c6f62616c20686d6c0a20202063203d206b6579776f7264732e67657428226322290a202020686d6c203d2068616e646c655f6d61726b5f6c6162656c732863290a2020207461626c65203d20280a202020282253686f77206c6162656c7320666f72204e6f6465222c204e6f6e652c20686d6c2e73686f775f6c6162656c735f666f725f6e6f6465292c0a202020282253686f77206c6162656c73222c204e6f6e652c20686d6c2e73686f775f6c6162656c73292c0a20202028222d222c204e6f6e652c204e6f6e65292c0a202020282244656c657465206e6f6465206c6162656c222c204e6f6e652c20686d6c2e64656c6574655f6e6f64655f6c6162656c292c0a202020282244656c657465206c6162656c222c204e6f6e652c20686d6c2e64656c6574655f6c6162656c292c0a202020282244656c657465206c6162656c73222c204e6f6e652c20686d6c2e64656c6574655f616c6c5f6c6162656c73292c0a20202028222d222c204e6f6e652c204e6f6e65292c0a20202028224d61726b7320746f206c6162656c222c204e6f6e652c20686d6c2e6d61726b735f746f5f6c6162656c292c0a20202028224c6162656c20746f204d61726b73222c204e6f6e652c20686d6c2e6c6162656c5f746f5f6d61726b73292c0a2020202028222d222c204e6f6e652c204e6f6e65292c0a2020202822416464206c6162656c20746f2063757272656e74206e6f6465222c204e6f6e652c20686d6c2e6d656e755f6164645f6c6162656c292c0a20202028222d222c204e6f6e652c204e6f6e65292c0a20202028224c6162656c20746f207375626e6f6465222c204e6f6e652c20686d6c2e6c6162656c5f746f5f7375626e6f6465292c0a20202028226c6162656c20746f207375626e6f646573222c204e6f6e652c20686d6c2e6c6162656c5f746f5f7375626e6f646573292c0a20202028226c6162656c7320746f207375626e6f646573222c204e6f6e652c20686d6c2e6c6162656c735f746f5f7375626e6f646573292c0a20202028222d222c204e6f6e652c204e6f6e65292c0a20202028227375626e6f646520746f206c6162656c222c204e6f6e652c20686d6c2e7375626e6f64655f746f5f6c6162656c292c0a20202028227375626e6f64657320746f206c6162656c222c204e6f6e652c20686d6c2e7375626e6f6465735f746f5f6c6162656c73292c0a20202028227375626e6f64657320746f206c6162656c73222c204e6f6e652c20686d6c2e7375626e6f6465735f746f5f6c6162656c73292c0a20202028222d222c204e6f6e652c204e6f6e65292c0a2020202822436c6f6e65206c6162656c207375626e6f646573222c204e6f6e652c20686d6c2e636c6f6e655f6c6162656c5f7375626e6f646573292c0a2020200a202020290a2020206672616d65203d20632e6672616d652e6d656e750a2020206672616d652e6372656174654e65774d656e7528224c6162656c7322290a2020206672616d652e6372656174654d656e754974656d7346726f6d5461626c6528224c6162656c73222c207461626c65290a2020200a646566206f76657277726974654c656f28293a0a20202073657461747472286c656f417446696c652e617446696c652c202272656164222c2072656164290a202020232074686973206f766572777269746520636f6d657320746f6f206c61746520666f7220746865206d61696e2066696c6520746f20776f726b210a20202073657461747472286c656f436f6d6d616e64732e436f6d6d616e64732c2022696e73657274486561646c696e65222c20696e73657274486561646c696e65290a20202073657461747472286c656f436f6d6d616e64732e436f6d6d616e64732c2022636c6f6e65222c20636c6f6e65290a2020200a696620313a0a2020206f76657277726974654c656f28290a2020200a2020206c656f506c7567696e732e726567697374657248616e646c657228226372656174652d6f7074696f6e616c2d6d656e7573222c20206372656174655f6d61726b5f657874656e73696f6e73290a202020672e657328222e2e2e6d61726b20657874656e73696f6e7322290a0a7102732e"><vh>4.1 code</vh>
<v t="bwmulder.20040531110909.113"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.114"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.115"><vh>class Pmw_combobox</vh></v>
<v t="bwmulder.20040531110909.116"><vh>class Pmw_MessageDialog</vh></v>
<v t="bwmulder.20040531110909.117"><vh>overwrites in Leo</vh>
<v t="bwmulder.20040531110909.118"><vh>comments</vh>
<v t="bwmulder.20040531110909.119"><vh>top_df.read</vh>
<v t="bwmulder.20040531110909.120"><vh>&lt;&lt; set fileName from root and importFileName &gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.121"><vh>&lt;&lt; open file or return false &gt;&gt;</vh>
<v t="bwmulder.20040531110909.122"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="bwmulder.20040531110909.123"><vh>&lt;&lt; copy ivars to df &gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.124"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.125"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="bwmulder.20040531110909.126"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040531110909.127"><vh>class handle_mark_labels</vh>
<v t="bwmulder.20040531110909.128"><vh>__init__</vh></v>
<v t="bwmulder.20040531110909.129"><vh>subroutines</vh>
<v t="bwmulder.20040531110909.130"><vh>iterator</vh></v>
<v t="bwmulder.20040531110909.131"><vh>getters and setters</vh>
<v t="bwmulder.20040531110909.132"><vh>get_labels_dict</vh></v>
<v t="bwmulder.20040531110909.133"><vh>set_labels_dict</vh></v>
<v t="bwmulder.20040531110909.134"><vh>add_label</vh></v>
</v>
<v t="bwmulder.20040531110909.135"><vh>collect_labels</vh></v>
<v t="bwmulder.20040531110909.136"><vh>insert_node_for_label_as_child</vh></v>
<v t="bwmulder.20040531110909.137"><vh>insert_nodes_for_labels_as_children</vh></v>
<v t="bwmulder.20040531110909.138"><vh>select_label</vh></v>
<v t="bwmulder.20040531110909.139"><vh>select_node_label</vh></v>
<v t="bwmulder.20040531110909.140"><vh>current_node_and_labels</vh></v>
<v t="bwmulder.20040531110909.141"><vh>get_labellist_for_node</vh></v>
<v t="bwmulder.20040531110909.142"><vh>show_label_list_box</vh></v>
<v t="bwmulder.20040531110909.143"><vh>create_subnodes_for_labelname</vh></v>
<v t="bwmulder.20040531110909.144"><vh>find_nodes_with_labelname</vh></v>
<v t="bwmulder.20040531110909.145"><vh>clone</vh></v>
<v t="bwmulder.20040531110909.146"><vh>move_to_child_positions</vh></v>
</v>
<v t="bwmulder.20040531110909.147"><vh>showing labels</vh>
<v t="bwmulder.20040531110909.148"><vh>show_labels</vh></v>
<v t="bwmulder.20040531110909.149"><vh>show_labels_for_node</vh></v>
</v>
<v t="bwmulder.20040531110909.150"><vh>Creating labels and marking nodes</vh>
<v t="bwmulder.20040531110909.151"><vh>menu_add_label</vh></v>
<v t="bwmulder.20040531110909.152"><vh>marks_to_label</vh></v>
<v t="bwmulder.20040531110909.153"><vh>label_to_marks</vh></v>
</v>
<v t="bwmulder.20040531110909.154"><vh>deleting labels.</vh>
<v t="bwmulder.20040531110909.155"><vh>delete_labels</vh></v>
<v t="bwmulder.20040531110909.156"><vh>delete_label</vh></v>
<v t="bwmulder.20040531110909.157"><vh>delete_node_label</vh></v>
</v>
<v t="bwmulder.20040531110909.158"><vh>Converting labels to subnodes and back.</vh>
<v t="bwmulder.20040531110909.159"><vh>creating subnodes</vh>
<v t="bwmulder.20040531110909.160"><vh>label_to_subnode</vh></v>
<v t="bwmulder.20040531110909.161"><vh>label_to_subnodes</vh></v>
<v t="bwmulder.20040531110909.162"><vh>labels_to_subnodes</vh></v>
</v>
<v t="bwmulder.20040531110909.163"><vh>updating labels from subnodes</vh>
<v t="bwmulder.20040531110909.164"><vh>subnode_to_label</vh></v>
<v t="bwmulder.20040531110909.165"><vh>subnodes_to_label</vh></v>
<v t="bwmulder.20040531110909.166"><vh>subnodes_to_labels</vh></v>
</v>
</v>
<v t="bwmulder.20040531110909.167"><vh>cloning</vh>
<v t="bwmulder.20040531110909.168"><vh>clone_label_subnodes</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040601075953"><vh>notes</vh>
<v t="bwmulder.20040603171035" a="E"><vh>How to implement undo for a plugin</vh>
<v t="bwmulder.20040603171115"><vh>Should your plugin support undo</vh></v>
<v t="bwmulder.20040603171502"><vh>The simplest case.</vh></v>
<v t="bwmulder.20040603172129"><vh>Undoing variable settings: scalars</vh></v>
<v t="bwmulder.20040603173718" a="E"><vh>Shared data</vh>
<v t="bwmulder.20040603174249"><vh>Simple lists and dictionaries</vh></v>
<v t="bwmulder.20040603174310"><vh>Nested lists and dictionaries</vh></v>
</v>
<v t="bwmulder.20040603213015"><vh>recovering from exceptions</vh></v>
<v t="bwmulder.20040603174758"><vh>Future work</vh></v>
<v t="bwmulder.20040603174656"><vh>A word about the undo mechanism of Leo</vh></v>
</v>
<v t="bwmulder.20040601075953.1"><vh>deleteOutline</vh></v>
<v t="bwmulder.20040601075953.2" a="M"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="bwmulder.20040601075953.3" a="M"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="bwmulder.20040601075953.4"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="bwmulder.20040601075953.5"><vh>testcode 1</vh></v>
<v t="bwmulder.20040601075953.6"><vh>testcode 2</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="bwmulder.20040531110909">@language python
&lt;&lt;docstring&gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;test switches&gt;&gt;
__version__ = "0.2.2"

@others
 
# test switches
trace_menu = True
   
if Pmw and Tk:
   overwriteLeo()
   
   leoPlugins.registerHandler("create-optional-menus",  create_mark_extensions)
   g.es("...labels extensions " + __version__)
else:
   g.es("The labels extensions need Pmw and Tkinter. For Pmw see http://pmw.sourceforge.net")


</t>
<t tx="bwmulder.20040531110909.1">"""
This plugin allows you to associate information with nodes.

This information is organized around "labels", which is are just strings and freely chosen by the user.

The plugin allows you to create such a label quickly for each marked node, and to mark all nodes with have a certain label.

"labels" can be converted to subnodes, and vice versa. This facility allows you to add additional information for each label.

Finally, you can create clones for each node which has a label. These clones are created as children of the current node.

This last facility can be used to create clones for each node which has been found or changed by the standard search / replace dialog:
   - delete all marks.
   - do a "find all" / "change all".
   - convert the marks to a label.
   - Run the "Clone label subnodes" command.

Finally, if you read a derived file, and the content of a node changes, the previous content is availab le under the label "before change:"


"""

</t>
<t tx="bwmulder.20040531110909.2">import leoPlugins, leoGlobals as g, leoCommands, leoAtFile
from leoTkinterDialog import tkinterListBoxDialog, leoTkinterDialog
from leoUndo import Command, undoer

try:
   import Pmw
except ImportError:
   Pmw = None
else:
   Pmw.initialise()
try:
	import Tkinter
except ImportError:
	Tkinter = None
Tk = Tkinter

import os, pickle, binascii
</t>
<t tx="bwmulder.20040531110909.3">Show_labels_for_Node_str = "Show Labels for Current Node"
Show_labels_str = "Show Labels"

Add_label_to_current_node_str = "Add label to current node"

Marks_to_label_str            = "Marks to label"
Label_to_Marks_str            = "Label to Marks"

Delete_node_label_str         = "Delete Node Label"
Delete_label_str              = "Delete Label"
Delete_labels_str             = "Delete Labels"

Label_to_subnode_str          = "Label to Subnode"
Label_to_subnodes_str         = "Label to Subnodes"
Labels_to_subnodes_str        = "Labels to Subnodes"

Subnode_to_label_str          = "Subnode to Label"
Subnodes_to_label_str         = "Subnodes to Label"
Subnodes_to_labels_str        = "Subnodes to Labels"

Clone_label_subnodes_str      = "Create Clones for Label"</t>
<t tx="bwmulder.20040531110909.4"></t>
<t tx="bwmulder.20040531110909.5">class Pmw_combobox:
   def __init__(self, parent, title, label_text, scrolledlist_items):
      self.dialog = Pmw.ComboBoxDialog(parent,
                                       title = title,
                                       buttons = ('OK', 'Cancel'),
                                       defaultbutton = 'OK',
                                       combobox_labelpos = 'n',
                                       label_text = label_text,
                                       scrolledlist_items = scrolledlist_items)
      self.dialog.withdraw()

   def doit(self):
      return self.dialog.activate()
</t>
<t tx="bwmulder.20040531110909.6">class Pmw_MessageDialog:
   def __init__(self, parent, title, message_text):
      "Create the dialog"
      self.dialog = Pmw.MessageDialog(parent,
            title = title,
            message_text = message_text,
            defaultbutton = 0,
            buttons = ('OK', 'Cancel'))
      self.dialog.withdraw()

   def doit(self):
      return self.dialog.activate()
</t>
<t tx="bwmulder.20040531110909.7">@doc
Added the lines:
import mod_labels; mod_labels.hml.add_label(v, "before change:", v.bodyString())
@code</t>
<t tx="bwmulder.20040531110909.8">def overwriteLeo():
   setattr(leoAtFile.atFile, "copyAllTempBodyStringsToTnodes", copyAllTempBodyStringsToTnodes)
   # this overwrite comes too late for the main file to work!
   # setattr(leoCommands.Commands, "insertHeadline", insertHeadline)
   # setattr(leoCommands.Commands, "clone", clone)
</t>
<t tx="bwmulder.20040531110909.9">def copyAllTempBodyStringsToTnodes(at, root, thinFile):
	for p in root.self_and_subtree_iter():
		try: s = p.v.t.tempBodyString
		except: s = ""
		if s != p.bodyString():
			if thinFile:
				p.v.setTnodeText(s)
			else:
				import mod_labels; mod_labels.hml.add_label(v, "before change:", v.bodyString())
				g.es("changed: " + p.headString(),color="blue")
				p.setMarked()
				p.setBodyStringOrPane(s) # Sets v and v.c dirty.	
	</t>
<t tx="bwmulder.20040531110909.10"></t>
<t tx="bwmulder.20040531110909.11"></t>
<t tx="bwmulder.20040531110909.12">class Base_Label_Command(Command):
	"""
	Base command for all label menu commands.
	"""
	@others
	
</t>
<t tx="bwmulder.20040531110909.13">def __init__(self, menu_name, hml):
	Command.__init__(self, menu_name)
	self.hml = hml
	
	# Not sure if this is a good place to put it.
	hml.c.undoer.add_command(self)</t>
<t tx="bwmulder.20040531110909.14">def remove_label(self, labelname, v):
	d = self.hml.get_labels_dict(v)
	del d[labelname]
	self.hml.set_labels_dict(v, d)
</t>
<t tx="bwmulder.20040531110909.15">def set_dirty(self, v):
	was_dirty = v.isDirty()
	if not was_dirty:
		v.setDirty()
		return was_dirty</t>
<t tx="bwmulder.20040531110909.16">class Base_Label_Node_Command(Base_Label_Command):
	"""
	Commmand which deals with a label and one vnode.
	"""
	@others</t>
<t tx="bwmulder.20040531110909.17">def __init__(self, menuName, hml, labelname, v):
	Base_Label_Command.__init__(self, menuName, hml)
	self.labelname = labelname
	self.v = v
</t>
<t tx="bwmulder.20040531110909.18"></t>
<t tx="bwmulder.20040531110909.19">class menu_add_label_node_command(Base_Label_Node_Command):
	"""
	This command adds a label to the current node.
	If the node already contains the label, the command does nothing.
	"""
	@others</t>
<t tx="bwmulder.20040531110909.20">def do(self):
	self.was_not_there = self.hml.add_label(self.v, self.labelname, '')
</t>
<t tx="bwmulder.20040531110909.21">def undo(self):
	if self.was_not_there:
		self.remove_label(self.labelname, self.v)
		
</t>
<t tx="bwmulder.20040531110909.22">def redo(self):
	if self.was_not_there:
		self.do()
		
</t>
<t tx="bwmulder.20040531110909.23">class marks_to_label_command(Base_Label_Command):
	"""
	Create a Label for each marked node.
	Since marking nodes is not part of the undo mechanism, the Command remembers the state of the nodes at the first 'do'.
	"""
	@others</t>
<t tx="bwmulder.20040531110909.24">def __init__(self, menuName, hml):
	Base_Label_Command.__init(menuName, hml)
</t>
<t tx="bwmulder.20040531110909.25">def do(self):
	g.es("Convert the existing marks to label %s" % self.labelname)
	changed_nodes = []
	add_label = self.hml.add_label
	labelname = self.labelname
	for v in self.hml.iterator():
		if v.isMarked():
			was_dirty = v.isDirty()
			was_not_there = add_label(v, labelname, '')
			if was_not_there:
				changed_nodes.append((v, was_dirty))
				if not was_dirty:
					v.setDirty()

</t>
<t tx="bwmulder.20040531110909.26">def undo(self):
	self.changed_nodes = []
	for v, was_dirty in self.changed_nodes:
		self.remove_label(self.labelname, v)
		if not was_dirty:
			v.clearDirty()
			</t>
<t tx="bwmulder.20040531110909.27">def redo(self):
	g.es("Redoing: Convert marks to label %s" % self.labelname)
	self.changed_nodes = []
	for v, was_dirty in self.changed_nodes:
		self.hml.add_label(v, self.labelname, '')
		if not was_dirty:
			v.setDirty()

</t>
<t tx="bwmulder.20040531110909.28">def label_to_marks_command(Handle_mark_labels_Command):
	"""
	Mark all nodes which have a certain label.
	"""
	@others
	</t>
<t tx="bwmulder.20040531110909.29">def __init__(self, MenuName, hml, labelname):
	Base_Label_Command.__init(menuName, hml)
	self.labelname = labelname
</t>
<t tx="bwmulder.20040531110909.30">def do(self):
	changed_nodes = []
	get_labels_dict = self.hml.get_labels_dict
	labelname = self.labelname
	count = 0
	for v in self.hml.iterator():
		d = get_labels_dict(v)
		if d.has_key(labelname):
			if not v.isMarked():
				count += 1
				changed_nodes.append(v)
				v.setMarked(v)
	self.changed_nodes = changed_nodes
	if count != 0:
         g.es("Marked %s nodes with label %s" % (count, labelname))
	self.hml.c.redraw()	
</t>
<t tx="bwmulder.20040531110909.31">def undo(self):
	for v in self.changed_nodes:
		v.clearMarked()</t>
<t tx="bwmulder.20040531110909.32">def redo(self):
	for v in self.changed_nodes:
		v.setMarked()</t>
<t tx="bwmulder.20040531110909.33"></t>
<t tx="bwmulder.20040531110909.34">class delete_node_label_command(Base_Label_Node_Command):
	@others</t>
<t tx="bwmulder.20040531110909.35">def do(self):
	d = self.hml.get_labels_dict
	if d.has_key(self.labelname):
		del d[self.labelname]
		self.hml.set_labels_dict(v)
		self.changed = True
		self.was_dirty = self.set_dirty(v)
	else:
		self.changed = False</t>
<t tx="bwmulder.20040531110909.36">def undo(self):
	if self.changed:
		self.remove_label()
		if not self.was_dirty:
			self.v.clearDirty()</t>
<t tx="bwmulder.20040531110909.37">redo = do
</t>
<t tx="bwmulder.20040531110909.38">class delete_label_command(Base_Label_Command):
	@others</t>
<t tx="bwmulder.20040531110909.39">def __init__(self, MenuName, hml, labelname):
	Base_Label_Command.__init__(self, MenuName, hml)
	self.labelname = labelname</t>
<t tx="bwmulder.20040531110909.40">def do(self):
	changed_nodes = []
	set_labels_dict = self.hml.set_labels_dict
	get_labels_dict = self.hml.get_labels_dict
	set_dirty = self.set_dirty
	for v in self.iterator():
		labels_dict = get_labels_dict(v)
		if labels_dict:
			if labels_dict.has_key(labelname):
				was_dirty = set_dirty(v)
				old_content = labels_dict[labelname]
				del labels_dict[labelname]
				set_labels_dict(v, labels_dict)
				changed_nodes.append((node, old_content, was_dirty))
	self.changed_nodes = changed_nodes
</t>
<t tx="bwmulder.20040531110909.41">def undo(self):
	get_labels_dict = self.hml.get_labels_dict
	set_labels_dict = self.hml.set_labels_dict
	labelname = self.labelname
	for v, old_content, was_dirty in self.changed_nodes:
		d = get_labels_dict(v)
		d[labelname] = old_content
		set_labels_dict(v)
		if not was_dirty:
			v.clearDirty()
</t>
<t tx="bwmulder.20040531110909.42">def redo(self):
	get_labels_dict = self.hml.get_labels_dict
	set_labels_dict = self.hml.set_labels_dict
	labelname = self.labelname
	for v, old_content, was_dirty in self.changed_nodes:
		d = get_labels_dict(v)
		del d[labelname]
		set_lables_dict(v)
</t>
<t tx="bwmulder.20040531110909.43">class delete_labels_command(Base_Label_Command):
	@others</t>
<t tx="bwmulder.20040531110909.44">def do(self):
	g.es("Deleting ALL labels", color='red')
	changed_nodes = []
	for v in self.iterator():
		labels_dict = self.get_labels_dict(v)
		if labels_dict != {}:
			was_dirty = self.set_dirty(v)
			changed_nodes.append((v, labels_dict, was_dirty))
			self.set_labels_dict(v, {})
	self.changed_nodes  = changed_nodes

</t>
<t tx="bwmulder.20040531110909.45">def undo(self):
	set_labels_dict = self.hml.set_labels_dict
	for v, labels_dict, was_dirty in self.changed_nodes:
		set_labels_dict(v, labels_dict)
		if not was_dirty:
			v.clearDirty()</t>
<t tx="bwmulder.20040531110909.46">redo = do</t>
<t tx="bwmulder.20040531110909.47"></t>
<t tx="bwmulder.20040531110909.48">class base_command_label_to_subnode(Base_Label_Command):
	@others</t>
<t tx="bwmulder.20040531110909.49">def create_subnodes_for_labels(self, l):
	"""
	Given a list with elements v, labelname, labelcontent, where
		- v is a vnode
		- labelname is the name of a label
		- labelcontent is the content of the label
	
	create a subnode for each such element, if no child c of v has 'labelname' as its headline.
	
	Return:
		- the number of nodes created.
		- the number of nodes NOT created because a child with the condition above already existed.
		- the names of the labels for which no node has been created.
	
	self.inserted_nodes will contain a list:
		- inserted vnode
		- labelname
		- labelcontent
		
	for each inserted node.
	"""
	inserted_nodes = []
	inserted_count = not_inserted_count = 0
	inserted_labels = {}
	for v, labelname, labelContents in l:
		inserted, child = sinsert_node_for_label_as_child(v, labelname, labelcontent)
		if inserted:
			inserted_nodes.append(child, labelname, labelContent)
			insert_count += 1
		else:
			not_inserted_count += 1
			not_inserted_labels[labelname]=1
	self.inserted_nodes = inserted_nodes
	labelnames = not_inserted_labels.keys(); labelnames.sort()
	return  inserted_count, not_inserted_count, labelnames




</t>
<t tx="bwmulder.20040531110909.50">class command_label_to_subnode(base_command_label_to_subnode):
	@others</t>
<t tx="bwmulder.20040531110909.51">def __init__(self, menuName, hml, labelname, v):
	Base_Label_Node_Command.__init__(self, menuName, hml, labelname, v)
	self.labelContent = self.hml.get_labels_dict(v)
</t>
<t tx="bwmulder.20040531110909.52">def do(self):
	inserted_count, not_inserted_count, labelnames = self.create_subnodes_for_labels((self.v, self.labelname, self.labelcontent))
	if inserted_count == 0:
		g.es("Could not insert node for label %s, because a subnode already existed" % self.labelname, "red")</t>
<t tx="bwmulder.20040531110909.53">def undo(self):
	if self.inserted:
		raise notYetImplemented</t>
<t tx="bwmulder.20040531110909.54">redo = undo</t>
<t tx="bwmulder.20040531110909.55">class command_label_to_subnode(base_command_label_to_subnode):
	@others</t>
<t tx="bwmulder.20040531110909.56">def __init__(self, menuName, hml, labelname):
	Base_Label_Command.__init__(self, MenuName, hml)
	self.labelname = labelname
</t>
<t tx="bwmulder.20040531110909.57">def do(self):
	inserted_count, not_inserted_count, labelnames = self.create_subnodes_for_labels(self.hml.find_nodes_with_labelname(self.labelname))
	if not_inserted_count != 0:
		g.es("Nodes created: %s NODES NOT CREATED: %s for labels: %s" % (inserted_count, not_inserted_count,  not_inserted_labels.keys()))
	else:
		g.es("Nodes created: %s" % inserted_count)

</t>
<t tx="bwmulder.20040531110909.58">def undo(self):
	raise notYetImplemented</t>
<t tx="bwmulder.20040531110909.59">redo = undo</t>
<t tx="bwmulder.20040531110909.60">class command_labels_to_subnodes(base_command_label_to_subnode):
	"""
	Convert all labels in all nodes to subnodes.
	"""
	@others
</t>
<t tx="bwmulder.20040531110909.61">def do(self):
	inserted_count, not_inserted_count, labelnames = self.create_subnodes_for_labels(self.hml.find_all_labels_in_all_nodes())
	if not_inserted_count != 0:
		g.es("Nodes created: %s NODES NOT CREATED: %s for labels: %s" % (inserted_count, not_inserted_count,  not_inserted_labels.keys()))
	else:
		g.es("Nodes created: %s" % inserted_count)

</t>
<t tx="bwmulder.20040531110909.62">def undo(self):
	raise notYetImplemented</t>
<t tx="bwmulder.20040531110909.63">redo = do</t>
<t tx="bwmulder.20040531110909.64">class handle_mark_labels(object):
	"""
	Handles all aspects of 'labels'.
	"""
	__slots__ = ('labels', 'md', 'c')
	@others

</t>
<t tx="bwmulder.20040531110909.65">def __init__(self, c):
   self.c = c</t>
<t tx="bwmulder.20040531110909.66"></t>
<t tx="bwmulder.20040531110909.67"></t>
<t tx="bwmulder.20040531110909.68">def iterator(self):
	"""
	It seems that the core Leo code does not have an iterator which 
	iterates over all v nodes, where each vnode is visited exactly once, and the order is irrelevant.
	"""
	for v1 in self.iterator_node(g.top().rootVnode().v, {}):
		yield v1

</t>
<t tx="bwmulder.20040531110909.69">def iterator_node(self, v, map):
	if v and v not in map:
		map[v] = None
		yield v
		for v1 in self.iterator_node(v.t._firstChild, map):
			yield v1
		while v:
			v = v._next
			for v in self.iterator_node(v, map):
				yield v
</t>
<t tx="bwmulder.20040531110909.70">@doc
The current unknownAttributes implementation of Leo has restrictions as to what you can put into unknownAttributes.

Creating an attribute called "labels" and giving it a hexadecimal string seems to be safe.</t>
<t tx="bwmulder.20040531110909.71">def get_labels_dict(self, vnode):
	"""
   Get the labels dictionary for a node.
   Return an empty dictionary, if such an attribute does not exist.
	"""
	try:
		dict = vnode.unknownAttributes
	except AttributeError:
		vlabels = {}
	else:
		try:
			vlabels = dict['labels']
		except AttributeError:
			vlabels = {}
	if trace_get_set_dict:
		print "bwm: get_labels_dict:", vnode, vlabels
	return vlabels


</t>
<t tx="bwmulder.20040531110909.72">def set_labels_dict(self, vnode, vlabels):
	"""
	Create a labels dictionary for the vnode.
	
	Create unknownAttributes if necessary.
	
	Has special code to delete empty dictionaries (to reduce overhead).
	"""
	print "bwm: set_labels_dict:", vnode, vlabels
	if vlabels == None or vlabels == {}:
		try:
			unknownAttributes = vnode.unknownAttributes
		except AttributeError:
			return
		else:
			if unknownAttributes.has_key('labels'):
				del unknownAttributes['labels']
				if unknownAttributes == {}:
					del vnode.unknownAttributes
			else:
				return
	else:
		try:
			unknownAttributes = vnode.unknownAttributes
		except AttributeError:
			vnode.unknownAttributes = unknownAttributes ={}
		unknownAttributes['labels'] = vlabels
			
 

</t>
<t tx="bwmulder.20040531110909.73">def add_label(self, v, labelname,  labelContent = ""):
	"""
	Add a label to a node.
	Return True if the label has been added, False if it
	was there already.
	"""
	result = False
	labels_dict = self.get_labels_dict(v)
	if labels_dict is None:
		labels_dict = {}
	if not labels_dict.has_key(labelname):
		labels_dict[labelname] = labelContent
		self.set_labels_dict(v, labels_dict)
		result = True
	return result



</t>
<t tx="bwmulder.20040531110909.74">def collect_labels(self):
	"""
	Walk the whole tree and collect the name of all labels.
	Returns a sorted list.
	"""
	labels = {}
	count = 0
	for v in self.iterator():
		count += 1
		vlabels = self.get_labels_dict(v)
		for key in vlabels.keys():
			labels[key] = ''
	print "vnodes:", count
	labellist = labels.keys()
	labellist.sort()
	return labellist</t>
<t tx="bwmulder.20040531110909.75">def insert_node_for_label_as_child(self, v, labelname, labelcontent):
	"""
	Insert a subnode with the header "labelname".
	Set the content of the node to "labelcontent".
	
	Do not do the insertion if such a node already exists.
	
	The insertion is done without selecting the node.
	
	Returns a tuple:
		The first value is an indication if an insertion happened.
		The second value is the inserted node, or None if no new node was created.
	"""
	# Before inserting, check if we have a child with the
	# same name
	child = self.check_if_Child_with_labelname_exists(v, labelname)
	if child:
		return False, child
	child = self.unconditionally_insert_node_for_label_as_child(v, labelname, labelContent)
	return True, child

</t>
<t tx="bwmulder.20040531110909.76">def unconditionally_insert_node_for_label_as_child(self, v, labelname, labelcontent):
	"""
	At the moment, I do not know how to insert a vnode, and make sure that everything
	is set up properly. Using self.c.insertHeadline should do all the proper things,
	at the cost of generating an extra undo node.
	"""
	# Not clear what the parameters are??
	# child, skip = self.c.createVnode(v, parent=v,back=None,tref=-1,headline=labelname,attrDict=None)
	# child.setBodyStringOrPane(labelcontent)
	# return skip
	self.c.selectVnode(v)
	child = self.c.insertHeadline(op_name="Insert Node")
	if v.firstChild() == child:
		pass
	else:
		self.c.moveOutlineRight()
	child.setHeadStringOrHeadline(labelname)
	child.setBodyStringOrPane(labelcontent)
	return child



</t>
<t tx="bwmulder.20040531110909.77">def check_if_Child_with_labelname_exists(self, v, labelname):	
	child = v.firstChild()
	while child:
		if child.headString() == labelname:
			return child
		child = child.next()
	return None
</t>
<t tx="bwmulder.20040531110909.78">def insert_nodes_for_labels_as_children(self, nodes_to_expand):
	"""
	Works like insert_node_for_label_as_child for a list.
	Returns the list of inserted children.
	"""
	return [self.insert_node_for_label_as_child(v, label, labelcontents)
			  for v, label, labelcontents in nodes_to_expand]

</t>
<t tx="bwmulder.20040531110909.79">def select_label(self, title):
	"""
	Present a dialog to select one of all the global labels.
	"""
	label_text = "Existing labels"

	labellist = self.collect_labels()
	if len(labellist) == 0:
		return None

	root = g.top().frame.outerFrame
	widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
	result = widget.doit()
	if result == 'Cancel':
		return None
	if result == 'OK':
		labelname = widget.dialog.get()
		return labelname
	 

</t>
<t tx="bwmulder.20040531110909.80">def select_node_label(self, title):
	"""
	Present a dialog to select a label defined for this node.
	"""
	
	
	labellist = self.get_labellist_for_node()
	root = g.top().frame.outerFrame
	label_text = "Existing labels for this node"
	widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
	result = widget.doit()
	if result == 'Cancel':
		return None
	if result == 'OK':
		labelname = widget.dialog.get()
		return labelname
	 


</t>
<t tx="bwmulder.20040531110909.81">def current_node_and_labels(self):
	"""
	Returns the current node and it's labels, if any.
	"""
	v = g.top().currentVnode().v
	label_dict = self.get_labels_dict(v)
	return v, label_dict

</t>
<t tx="bwmulder.20040531110909.82">def get_labellist_for_node(self):
	"""
	Get the sorted list of labels for the current node.
	"""

	v, label_dict = self.current_node_and_labels()
	labellist = label_dict.keys()
	labellist.sort()
	return labellist
	

</t>
<t tx="bwmulder.20040531110909.83">def show_label_list_box(self, title, label_text, labellist):
	root = g.top().frame.outerFrame
	widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
	result = widget.doit()
	return result, widget, labellist
</t>
<t tx="bwmulder.20040531110909.84">def create_subnodes_for_labelname(self, labelname):
	"""
	Create subnodes for 'labelname'.
	Return a list of such subnodes.
	"""
	return self.insert_nodes_for_labels_as_children(self.find_nodes_with_labelname(labelname))
 
</t>
<t tx="bwmulder.20040531110909.85">def find_nodes_with_labelname(self, labelname):
	"""
	Return a list of nodes which have the label 'labelname'.
	Actually, each list element contains:
		- the node.
		- the labelname
		- the content of that label at that node.
	"""
	nodes_with_label = []
	for v in self.iterator():
		labels = self.get_labels_dict(v)
		if labels.has_key(labelname):
			nodes_with_label.append ((v, labelname, labels[labelname]))
	return nodes_with_label

</t>
<t tx="bwmulder.20040531110909.86">def find_all_labels_in_all_nodes(self):
	"""
	Find all labels in all nodes.
	Return them as a list with elements:
		- v              the node
		- labelname      the name of the label
		- labelcontent   the content of the label
	"""
	result = []
	get_labels_dict = self.get_labels_dict
	for v in self.iterator():
		d = get_labels_dict(v)
		for key in d.keys():
			result.append((v, key, d[key]))
	return result
</t>
<t tx="bwmulder.20040531110909.87">def clone(self, v):
	return self

</t>
<t tx="bwmulder.20040531110909.88">def move_to_child_positions(self, clones, currentNode):
	for clone in clones:
		clone.moveToNthChildOf(currentNode, 0)

</t>
<t tx="bwmulder.20040531110909.89"></t>
<t tx="bwmulder.20040531110909.90">def show_labels(self, title="show labels"):
   """
   Present a combobox with all the labels defined in the current Leo file.
   Returns result, widget, labellist
      where result in ("Cancel", "OK").
   """
   labellist = self.collect_labels()
   return self.show_label_list_box(title = title, label_text = "Existing labels", labellist = labellist)

   </t>
<t tx="bwmulder.20040531110909.91">def show_labels_for_node(self):
   """
   Show the labels for the current node.
   """
   labellist = self.get_labellist_for_node()
   self.show_label_list_box(title = "Show labels for node", 
   							label_text = "Existing labels for node", 
							labellist = labellist)
   

</t>
<t tx="bwmulder.20040531110909.92"></t>
<t tx="bwmulder.20040531110909.93">def menu_add_label_node(self):
	"""
	Add a (new) label to the current node.
	 """
	result, widget, labellist = self.show_labels(title="Mark nodes with label")
	if result != 'OK':
 		return
	labelname = widget.dialog.get()
	v = g.top().currentVnode().v
	menu_add_label_node_command(Add_label_to_current_node_str, self, labelname, v).do()
	
</t>
<t tx="bwmulder.20040531110909.94">def marks_to_label(self):
   """
   Convert the existing marks to a label.
   """
   title = "show labels"

   labellist = self.collect_labels()

   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = 'Existing labels', scrolledlist_items = labellist)
   result = widget.doit()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()
   
   marks_to_label_command(Marks_to_label_str, labelname).do()
</t>
<t tx="bwmulder.20040531110909.95">def label_to_marks(self):
   """
   Mark nodes with label:
      Ask for the name of an existing label.
      Set the mark bit for each vnode which has the selected label.
   """
   result, widget, labellist = self.show_labels(title="Mark nodes with label")
   if result != 'OK':
      return
   labelname = widget.dialog.get()
   label_to_marks_command(Label_to_Marks_str, self, labelname).do()
</t>
<t tx="bwmulder.20040531110909.96"></t>
<t tx="bwmulder.20040531110909.97">def delete_node_label(self):
	"""
	Delete a label for the current node only.
	"""
	labelname = self.select_node_label("Select label to delete")
	if labelname:
		delete_node_label_command(Delete_node_label_str, self, labelname, g.top().currentVnode())

</t>
<t tx="bwmulder.20040531110909.98">def delete_label(self):
	"""
	Delete one label in the whole outline.
	"""
	labelname = self.select_label("Select label to delete")
	if labelname:
		delete_label_commands(Delete_label_str, self, labelname)


</t>
<t tx="bwmulder.20040531110909.99">def delete_all_labels(self):
	"""
   Delete all labels in the outline.
   Ask for confirmation before doing so!
	"""
	title = 'Do you really want to delete ALL labels?'
	message_text = 'Do you really want to delete ALL labels?'

	root = g.top().frame.outerFrame
	dialog = Pmw_MessageDialog(root, title = title, message_text = message_text)
	result = dialog.doit()

	if result == 'Cancel':
		return
	if result == 'OK':
		delete_labels_command(delete_labels_str, self)




</t>
<t tx="bwmulder.20040531110909.100"></t>
<t tx="bwmulder.20040531110909.101"></t>
<t tx="bwmulder.20040531110909.102">def label_to_subnode(self):
   """
   Convert a label of the current node to a subnode.
   """
   title = "Creating subnode"
   label_text = "Existing labels (on this node)"
   
   v = g.top().currentVnode()
   labels = self.get_labels_dict(v)
   
   if labels is None:
      g.es("No labels defined for this node")
      return
   
   labelnames = labels.keys()
   labelnames.sort()
   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labelnames)
   result = widget.doit()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()
   g.es("Create subnode for label %s" % labelname)
   
   self.insert_node_for_label_as_child(v = v, labelname = labelname, labelcontent = labels[labelname])
   
</t>
<t tx="bwmulder.20040531110909.103">def label_to_subnodes(self):   
   # Find out which labels exist.
   labelname = self.select_label("Select label to expand")
   return self.create_subnodes_for_labelname(labelname)

</t>
<t tx="bwmulder.20040531110909.104">def labels_to_subnodes(self):
   """
   Convert all labels to subnodes.
   """
   labels = self.collect_labels()
   to_process = []
   for v in self.iterator():
      labels_dict = self.get_labels_dict(v)
      if labels_dict:
         for key, value in labels_dict.items():
            to_process.append((v, key, value))
   self.insert_nodes_for_labels_as_children(to_process)
   



</t>
<t tx="bwmulder.20040531110909.105"></t>
<t tx="bwmulder.20040531110909.106">def subnode_to_label(self):
   """
   Update a label from a subnode.
   Delete the subnode.
   """
   # Retrieve the list of labels defined for this node.
   labelnames = self.get_labellist_for_node()
   if labelnames is None:
      g.es("No labels defined for this node")
      return
   
   # Now look through children to see which subnodes match a label name.
   # Construct the intersection of the headStrings of the children
   # and the labellist.
   child = v.firstChild()
   labelnames_dict = {}
   while child:
      headline = child.headString()
      if headline in labelnames:
         labelnames_dict[headline] = child
      child = child.next()
   
   labelnames_found = labelnames_dict.keys()
   if not labelnames_found:
      g.es("No suitable subnode found")
      return
   labelnames_found.sort()
      
   # Now let the user select a labelname
   title = "Select subnode to delete"
   label_text = "Subnodes to fold"
   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labelnames_found)
   result = widget.doit()
   if result == 'Cancel':
      return
      
   labelname = widget.dialog.get()
   if labelname in labelnames:
      child = labelnames_dict[labelname]
      labels[labelname] = child.bodyString()
      self.set_labels_dict(v, labels)
      
      # now delete the subnode
      self.c.selectVnode(child)
      self.c.cutOutline()
      self.c.selectVnode(v)

   



</t>
<t tx="bwmulder.20040531110909.107">def subnodes_to_label(self):
   """
   Update the label from subnodes, as far as they exist.
   Delete those subnodes.
   """
   labelname = self.select_label()
   if labelname:
      nodes_to_delete = []
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            if labels_dict.has_key(labelname):
               child = v.firstChild()
               while child and child.headString() != labelname:
                  child = child.next()
               if child:
                  nodes_to_delete.append(child)
      for v in nodes_to_delete:
         parent = v.parent()
         parent_dict = self.get_labels_dict(parent)
         parent_dict[v.headString()] = v.bodyString()
         self.set_labels_dict(v, parent_dict)
         
         # now delete the child
         self.c.selectVnode(child)
         self.c.cutOutline()
         self.c.selectVnode(parent)
                  
   
   





</t>
<t tx="bwmulder.20040531110909.108">def subnodes_to_labels(self):
   """
   Update all labels from subnodes, if those subnodes exist.
   
   Delete all those subnodes.
   """
   labelnames = self.collect_labels()
   if labelnames:
      nodes_to_delete = []
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            for labelname in labels_dict.keys():
               child = v.firstChild()
               while child and child.headString() != labelname:
                  child = child.next()
               if child:
                  nodes_to_delete.append(child)
      for v in nodes_to_delete:
         parent = v.parent()
         parent_dict = self.get_labels_dict(parent)
         parent_dict[v.headString()] = v.bodyString()
         self.set_labels_dict(parent, parent_dict)
         
         # now delete the child
         self.c.selectVnode(v)
         self.c.cutOutline()
         self.c.selectVnode(parent)
   




</t>
<t tx="bwmulder.20040531110909.109">	</t>
<t tx="bwmulder.20040531110909.110">def clone_label_subnodes(self):
   """
   Collect clones of all nodes with a label and move them to a child position of the current node.
   """
   def clonefilter(node):
      result = node.t not in tnodes
      tnodes[node.t] = None
      return result
      
   currentNode = self.c.currentVnode()
   
   # 1. Get the name of a label.
   result, widget, labellist = self.show_labels()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()

   # 2. Find all the nodes with the label.
   nodes = [v for v, labelname, labelcontent in self.find_nodes_with_labelname(labelname)]
   
   # 3. Filter out multiple instances of the same clones
   tnodes = {}; nodes = [node for node in nodes if clonefilter(node)]
   
   # 4. Clone those nodes.
   clones = [node.clone(node) for node in nodes]
   
   # 5. Now move all clones so that they are a child of the current node.
   self.move_to_child_positions(clones, currentNode)
   
   # 6. Redraw the screen
   self.c.redraw()</t>
<t tx="bwmulder.20040531110909.111">def create_mark_extensions(tag, keywords):
	global hml
	c = keywords.get("c")
	hml = handle_mark_labels(c)
	table = (
		(Show_labels_for_Node_str, None, hml.show_labels_for_node),
		(Show_labels_str, None, hml.show_labels),
		("-", None, None),
		(Add_label_to_current_node_str, None, hml.menu_add_label_node),
		("-", None, None),
		(Marks_to_label_str, None, hml.marks_to_label),
		(Label_to_Marks_str, None, hml.label_to_marks),
		("-", None, None),
		(Delete_node_label_str, None, hml.delete_node_label),
		(Delete_label_str, None, hml.delete_label),
		(Delete_labels_str, None, hml.delete_all_labels),
		("-", None, None),
		(Label_to_subnode_str, None, hml.label_to_subnode),
		(Label_to_subnodes_str, None, hml.label_to_subnodes),
		(Labels_to_subnodes_str, None, hml.labels_to_subnodes),
		("-", None, None),
		(Subnode_to_label_str, None, hml.subnode_to_label),
		(Subnodes_to_label_str, None, hml.subnodes_to_labels),
		(Subnodes_to_labels_str, None, hml.subnodes_to_labels),
		("-", None, None),
		(Clone_label_subnodes_str, None, hml.clone_label_subnodes),
	  
	)
	frame = c.frame.menu
	frame.createNewMenu("Labels")
	frame.createMenuItemsFromTable("Labels", table)

</t>
<t tx="bwmulder.20040531110909.112">@language python
&lt;&lt;docstring&gt;&gt;
&lt;&lt;imports&gt;&gt;
__version__ = "0.2"

@others
 
def create_mark_extensions(tag, keywords):
   global hml
   c = keywords.get("c")
   hml = handle_mark_labels(c)
   table = (
   ("Show labels for Node", None, hml.show_labels_for_node),
   ("Show labels", None, hml.show_labels),
   ("-", None, None),
   ("Delete node label", None, hml.delete_node_label),
   ("Delete label", None, hml.delete_label),
   ("Delete labels", None, hml.delete_all_labels),
   ("-", None, None),
   ("Marks to label", None, hml.marks_to_label),
   ("Label to Marks", None, hml.label_to_marks),
    ("-", None, None),
   ("Add label to current node", None, hml.menu_add_label),
   ("-", None, None),
   ("Label to subnode", None, hml.label_to_subnode),
   ("label to subnodes", None, hml.label_to_subnodes),
   ("labels to subnodes", None, hml.labels_to_subnodes),
   ("-", None, None),
   ("subnode to label", None, hml.subnode_to_label),
   ("subnodes to label", None, hml.subnodes_to_labels),
   ("subnodes to labels", None, hml.subnodes_to_labels),
   ("-", None, None),
   ("Clone label subnodes", None, hml.clone_label_subnodes),
   
   )
   frame = c.frame.menu
   frame.createNewMenu("Labels")
   frame.createMenuItemsFromTable("Labels", table)
   
def overwriteLeo():
   setattr(leoAtFile.atFile, "read", read)
   # this overwrite comes too late for the main file to work!
   setattr(leoCommands.Commands, "insertHeadline", insertHeadline)
   setattr(leoCommands.Commands, "clone", clone)
   try:
      import mod_leosubfolderplugin
   except:
      pass
   else:
      import mod_labels
      mod_labels.__dict__['open'] = mod_leosubfolderplugin.LeoSubfolderPluginOpen
   
if Pmw and Tk:
   overwriteLeo()
   
   leoPlugins.registerHandler("create-optional-menus",  create_mark_extensions)
   g.es("...labels extensions")
else:
   g.es("The labels extensions need Pmw and Tkinter. For Pmw see http://pmw.sourceforge.net")

</t>
<t tx="bwmulder.20040531110909.113">"""
This plugin allows you to associate information with nodes.

This information is organized around "labels", which is are just strings and freely chosen by the user.

The plugin allows you to create such a label quickly for each marked node, and to mark all nodes with have a certain label.

"labels" can be converted to subnodes, and vice versa. This facility allows you to add additional information for each label.

Finally, you can create clones for each node which has a label. These clones are created as children of the current node.

This last facility can be used to create clones for each node which has been found or changed by the standard search / replace dialog:
   - delete all marks.
   - do a "find all" / "change all".
   - convert the marks to a label.
   - Run the "Clone label subnodes" command.

Finally, if you read a derived file, and the content of a node changes, the previous content is availab le under the label "before change:"


"""

</t>
<t tx="bwmulder.20040531110909.114">import leoPlugins, leoGlobals as g, leoCommands, leoAtFile
from leoTkinterDialog import tkinterListBoxDialog, leoTkinterDialog

try:
   import Pmw
except ImportError:
   Pmw = None
else:
   Pmw.initialise()
try:
	import Tkinter
except ImportError:
	Tkinter = None
Tk = Tkinter

from leoGlobals import *
# required by read :-(.
   


import os, pickle, binascii
</t>
<t tx="bwmulder.20040531110909.115">class Pmw_combobox:
   def __init__(self, parent, title, label_text, scrolledlist_items):
      self.dialog = Pmw.ComboBoxDialog(parent,
                                       title = title,
                                       buttons = ('OK', 'Cancel'),
                                       defaultbutton = 'OK',
                                       combobox_labelpos = 'n',
                                       label_text = label_text,
                                       scrolledlist_items = scrolledlist_items)
      self.dialog.withdraw()

   def doit(self):
      return self.dialog.activate()
</t>
<t tx="bwmulder.20040531110909.116">class Pmw_MessageDialog:
   def __init__(self, parent, title, message_text):
      "Create the dialog"
      self.dialog = Pmw.MessageDialog(parent,
            title = title,
            message_text = message_text,
            defaultbutton = 0,
            buttons = ('OK', 'Cancel'))
      self.dialog.withdraw()

   def doit(self):
      return self.dialog.activate()
</t>
<t tx="bwmulder.20040531110909.117"></t>
<t tx="bwmulder.20040531110909.118">@doc

The only change I made in insertHeadline and clone is that both now return the created node.

This makes the code a little bit easier.

top_df.read has one line added:
   import mod_labels; mod_labels.hml.add_label("before change:", v.bodyString())

</t>
<t tx="bwmulder.20040531110909.119"># The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None):
   
   """Common read logic for any derived file."""
   
   at = self ; c = at.c
   at.errors = 0
   at.scanDefaultDirectory(root)
   if at.errors: return
   &lt;&lt; set fileName from root and importFileName &gt;&gt;
   &lt;&lt; open file or return false &gt;&gt;
   es("reading: " + root.headString())
   firstLines,read_new = at.scanHeader(file,fileName)
   df = choose(read_new,at.new_df,at.old_df)
   # trace(choose(df==at.new_df,"new","old"))
   # import traceback ; traceback.print_stack()
   &lt;&lt; copy ivars to df &gt;&gt;
   root.clearVisitedInTree()
   try:
      # 1/28/04: Don't set comment delims when importing.
      # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
      importing = importFileName is not None
      df.scanAllDirectives(root,importing=importing)
      df.readOpenFile(root,file,firstLines)
   except:
      at.error("Unexpected exception while reading derived file")
      es_exception()
   file.close()
   root.clearDirty() # May be set dirty below.
   after = root.nodeAfterTree()
   &lt;&lt; warn about non-empty unvisited nodes &gt;&gt;
   if df.errors == 0:
      if not df.importing:
         &lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;
   &lt;&lt; delete all tempBodyStrings &gt;&gt;
   return df.errors == 0
</t>
<t tx="bwmulder.20040531110909.120">if importFileName:
   fileName = importFileName
elif root.isAtFileNode():
   fileName = root.atFileNodeName()
else:
   fileName = root.atRawFileNodeName()
   
if not fileName:
   at.error("Missing file name.  Restoring @file tree from .leo file.")
   return false</t>
<t tx="bwmulder.20040531110909.121">fn = os_path_join(at.default_directory,fileName)
fn = os_path_normpath(fn)

try:
   # 11/4/03: open the file in binary mode to allow 0x1a in bodies &amp; headlines.
   file = open(fn,'rb')
   if file:
      &lt;&lt; warn on read-only file &gt;&gt;
   else: return false
except:
   at.error("Can not open: " + '"@file ' + fn + '"')
   root.setDirty()
   return false</t>
<t tx="bwmulder.20040531110909.122">try:
   read_only = not os.access(fn,os.W_OK)
   if read_only:
      es("read only: " + fn,color="red")
except:
   pass # os.access() may not exist on all platforms.</t>
<t tx="bwmulder.20040531110909.123">df.importing = importFileName != None
df.importRootSeen = false

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.targetFileName = fileName
df.indent = 0
df.raw = false
df.root = root
df.root_seen = false
</t>
<t tx="bwmulder.20040531110909.124">v = root
while v and v != after:
   try: s = v.t.tempBodyString
   except: s = ""
   if s and not v.t.isVisited():
      at.error("Not in derived file:" + v.headString())
      v.t.setVisited() # One message is enough.
   v = v.threadNext()</t>
<t tx="bwmulder.20040531110909.125">v = root
while v and v != after:
   try: s = v.t.tempBodyString
   except: s = ""
   if s != v.bodyString():
      es('change: %s, see label "before change:"' % v.headString())
      import mod_labels; mod_labels.hml.add_label(v, "before change:", v.bodyString())
      v.setBodyStringOrPane(s) # Sets v and v.c dirty.
      v.setMarked()
   v = v.threadNext()</t>
<t tx="bwmulder.20040531110909.126">v = root
while v and v != after:
   if hasattr(v.t,"tempBodyString"):
      delattr(v.t,"tempBodyString")
   v = v.threadNext()</t>
<t tx="bwmulder.20040531110909.127">class handle_mark_labels(object):
   __slots__ = ('labels', 'md', 'c')
   @others
   
      
      
</t>
<t tx="bwmulder.20040531110909.128">def __init__(self, c):
   self.c = c</t>
<t tx="bwmulder.20040531110909.129"></t>
<t tx="bwmulder.20040531110909.130">def iterator(self):
   v = g.top().rootVnode()
   for node in self.iterator_node(v):
      yield node
      child = node.mFirstChild
      if child:
         for node1 in self.iterator_node(child):
            yield node1
   
def iterator_node(self, node):
   while node:
      yield node
      node = node.mNext

def iterator(self):
   v = g.top().rootVnode()
   while v:
      yield v
      v = v.threadNext()</t>
<t tx="bwmulder.20040531110909.131">@doc
The current unknownAttributes implementation of Leo has restrictions as to what you can put into unknownAttributes.

Creating an attribute called "labels" and giving it a hexadecimal string seems to be safe.</t>
<t tx="bwmulder.20040531110909.132">def get_labels_dict(self, vnode):
   """
   Get the labels dictionary for a node.
   Return None if such a dictionary does not exist.
   """
   try:
      dict = vnode.unknownAttributes
   except AttributeError:
      return {}
   else:
      try:
         labels_dict_hexstring = dict['labels']
         labels_dict_string = binascii.unhexlify(labels_dict_hexstring)
      except AttributeError:
         return {}
      else:
         vlabels = pickle.loads(labels_dict_string)
   return vlabels
      
         </t>
<t tx="bwmulder.20040531110909.133">def set_labels_dict(self, vnode, vlabels):
   """
   Create a labels dictionary for the vnode.
   
   Create unknownAttributes if necessary.
   
   Has special code to delete empty dictionaries (to reduce overhead).
   """
   if vlabels == None or vlabels == {}:
      try:
         unknownAttributes = vnode.unknownAttributes
      except:
         return
      else:
         if unknownAttributes.has_key('labels'):
            del unknownAttributes['labels']
            if unknownAttributes == {}:
               del vnode.unknownAttributes
         else:
            return
   else:
      pickle_string = pickle.dumps(vlabels)
      hexstring = binascii.hexlify(pickle_string)
      try:
         unknownAttributes = vnode.unknownAttributes
      except:
         vnode.unknownAttributes = unknownAttributes ={}
      unknownAttributes['labels'] = hexstring
         
 
</t>
<t tx="bwmulder.20040531110909.134">def add_label(self, v, labelname,  labelContent = ""):
   labels_dict = self.get_labels_dict(v)
   if labels_dict is None:
      labels_dict = {}
   if not labels_dict.has_key(labelname):
      labels_dict[labelname] = labelContent
      self.set_labels_dict(v, labels_dict)

</t>
<t tx="bwmulder.20040531110909.135">def collect_labels(self):
   """
   Walk the whole tree and collect the name of all labels.
   Returns a sorted list.
   """
   labels = {}
   for v in self.iterator():
      vlabels = self.get_labels_dict(v)
      for key in vlabels.keys():
         labels[key] = ''
   labellist = labels.keys()
   labellist.sort()
   return labellist</t>
<t tx="bwmulder.20040531110909.136">def insert_node_for_label_as_child(self, v, labelname, labelcontent):
   """
   Insert a subnode with the header "labelname".
   Set the content of the node to "labelcontent".
   
   Do not do the insertion if such a node already exists.
   
   Returns the inserted child or existing child.
   """
   self.c.selectVnode(v)
   # Before inserting, check if we have a child with the
   # same name
   child = v.firstChild()
   while child:
      if child.headString() == labelname:
         return child
      child = child.next()
   child = self.c.insertHeadline(op_name="Insert Node")
   if v.firstChild() == child:
      pass
   else:
      self.c.moveOutlineRight()
   child.setHeadStringOrHeadline(labelname)
   child.setBodyStringOrPane(labelcontent)
   return child
   
</t>
<t tx="bwmulder.20040531110909.137">def insert_nodes_for_labels_as_children(self, nodes_to_expand):
   """
   Works like insert_node_for_label_as_child for a list.
   Returns the list of inserted children.
   """
   return [self.insert_node_for_label_as_child(v, label, labelcontents)
           for v, label, labelcontents in nodes_to_expand]
</t>
<t tx="bwmulder.20040531110909.138">def select_label(self, title):
   """
   Present a dialog to select one of all the global labels.
   """
   label_text = "Existing labels"

   labellist = self.collect_labels()
   if len(labellist) == 0:
      return None

   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
   result = widget.doit()
   if result == 'Cancel':
      return None
   if result == 'OK':
      labelname = widget.dialog.get()
      return labelname
    
</t>
<t tx="bwmulder.20040531110909.139">def select_node_label(self, title):
   """
   Present a dialog to select a label defined for this node.
   """
   
   
   labellist = self.get_labellist_for_node()
   root = g.top().frame.outerFrame
   label_text = "Existing labels for this node"
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
   result = widget.doit()
   if result == 'Cancel':
      return None
   if result == 'OK':
      labelname = widget.dialog.get()
      return labelname
    

</t>
<t tx="bwmulder.20040531110909.140">def current_node_and_labels(self):
   """
   Returns the current node and it's labels, if any.
   """
   v = g.top().currentVnode()
   label_dict = self.get_labels_dict(v)
   return v, label_dict
</t>
<t tx="bwmulder.20040531110909.141">def get_labellist_for_node(self):
   """
   Get the sorted list of labels for the current node.
   """

   v, label_dict = self.current_node_and_labels()
   labellist = label_dict.keys()
   labellist.sort()
   return labellist
   
</t>
<t tx="bwmulder.20040531110909.142">def show_label_list_box(self, title, label_text, labellist):
   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labellist)
   result = widget.doit()
   return result, widget, labellist</t>
<t tx="bwmulder.20040531110909.143">def create_subnodes_for_labelname(self, labelname):
   """
   Create subnodes for 'labelname'.
   Return a list of such subnodes.
   """
   return self.insert_nodes_for_labels_as_children(self.find_nodes_with_labelname(labelname))
 </t>
<t tx="bwmulder.20040531110909.144">def find_nodes_with_labelname(self, labelname):
	"""
	Return a list of nodes which have the label 'labelname'.
	Actually, each list element contains:
		- the node.
		- the labelname
		- the content of that label at that node.
		
	The labelname is redundant in this case, but I do this for consistency
	with the other commands which work with *all* labels.
	"""
	nodes_with_label = []
	for v in self.iterator():
		labels = self.get_labels_dict(v)
		if labels.has_key(labelname):
			nodes_with_label.append ((v, labelname, labels[labelname]))
	return nodes_with_label
</t>
<t tx="bwmulder.20040531110909.145">def clone(self, v):
   return self
</t>
<t tx="bwmulder.20040531110909.146">def move_to_child_positions(self, clones, currentNode):
   for clone in clones:
      clone.moveToNthChildOf(currentNode, 0)
</t>
<t tx="bwmulder.20040531110909.147"></t>
<t tx="bwmulder.20040531110909.148">def show_labels(self, title="show labels"):
   """
   Present a combobox with all the labels defined in the current Leo file.
   Returns result, widget, labellist
      where result in ("Cancel", "OK").
   """
   labellist = self.collect_labels()
   return self.show_label_list_box(title = title, label_text = "Existing labels", labellist = labellist)

   </t>
<t tx="bwmulder.20040531110909.149">def show_labels_for_node(self):
   """
   Show the labels for the current node.
   """
   labellist = self.get_labellist_for_node()
   self.show_label_list_box(title = "Show labels for node", label_text = "Existing labels for node", labellist = labellist)
   

</t>
<t tx="bwmulder.20040531110909.150"></t>
<t tx="bwmulder.20040531110909.151">def menu_add_label(self):
	"""
	Add a (new) label to the current node.
	"""
	result, widget, labellist = self.show_labels(title="Mark nodes with label")
	if result != 'OK':
		return
	labelname = widget.dialog.get()
	
	v = g.top().currentVnode()
	self.add_label(v, labelname, '')


</t>
<t tx="bwmulder.20040531110909.152">def marks_to_label(self):
   """
   Convert the existing marks to a label.
   """
   title = "show labels"

   labellist = self.collect_labels()

   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = 'Existing labels', scrolledlist_items = labellist)
   result = widget.doit()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()
   g.es("Convert the existing marks to label %s" % labelname)
   #  markedBit = g.top().rootVnode().__class__.markedBit
   for v in self.iterator():
      if v.isMarked():
         # if (v.statusBits &amp; markedBit ) != 0:
         labels_dict = self.get_labels_dict(v)
         if labels_dict is None:
            labels_dict = {}
         # do nothing if the node already has such a label.
         if not labels_dict.has_key(labelname):
            labels_dict[labelname] = ''
            self.set_labels_dict(v, labels_dict)
            v.setDirty()
            print v
         
               
      </t>
<t tx="bwmulder.20040531110909.153">def label_to_marks(self):
   """
   Mark nodes with label:
      Ask for the name of an existing label.
      Set the mark bit for each vnode which has the selected label.
   """
   result, widget, labellist = self.show_labels(title="Mark nodes with label")
   if result != 'OK':
      return
   labelname = widget.dialog.get()
   if labelname in labellist:
      count = 0
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            if labels_dict.has_key(labelname):
               if not v.isMarked():
                  v.setMarked()
                  count += 1
      if count != 0:
         g.es("Marked %s nodes with label %s" % (count, labelname))
   self.c.redraw()</t>
<t tx="bwmulder.20040531110909.154"></t>
<t tx="bwmulder.20040531110909.155">def delete_all_labels(self):
   """
   Delete all labels in the outline.
   Ask for confirmation before doing so!
   """
   title = 'Do you really want to delete ALL labels?'
   message_text = 'Do you really want to delete ALL labels?'

   root = g.top().frame.outerFrame
   dialog = Pmw_MessageDialog(root, title = title, message_text = message_text)
   result = dialog.doit()

   if result == 'Cancel':
      return
   if result == 'OK':
      g.es("Deleting ALL labels", color='red')
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            self.set_labels_dict(v, None)
   




</t>
<t tx="bwmulder.20040531110909.156">def delete_label(self):
   """
   Delete one label in the whole outline.
   """
   labelname = self.select_label("Select label to delete")
   if labelname:
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            if labels_dict.has_key(labelname):
               del labels_dict[labelname]
               self.set_labels_dict(v, labels_dict)

</t>
<t tx="bwmulder.20040531110909.157">def delete_node_label(self):
   """
   Delete a label for the current node only.
   """
   labelname = self.select_node_label("Select label to delete")
   if labelname:
      v, labels_dict = self.current_node_and_labels()
      del labels_dict[labelname]
      self.set_labels_dict(v, labels_dict)
</t>
<t tx="bwmulder.20040531110909.158"></t>
<t tx="bwmulder.20040531110909.159"></t>
<t tx="bwmulder.20040531110909.160">def label_to_subnode(self):
   """
   Convert a label of the current node to a subnode.
   """
   title = "Creating subnode"
   label_text = "Existing labels (on this node)"
   
   v = g.top().currentVnode()
   labels = self.get_labels_dict(v)
   
   if labels is None:
      g.es("No labels defined for this node")
      return
   
   labelnames = labels.keys()
   labelnames.sort()
   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labelnames)
   result = widget.doit()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()
   g.es("Create subnode for label %s" % labelname)
   
   self.insert_node_for_label_as_child(v = v, labelname = labelname, labelcontent = labels[labelname])
   
</t>
<t tx="bwmulder.20040531110909.161">def label_to_subnodes(self):   
   # Find out which labels exist.
   labelname = self.select_label("Select label to expand")
   return self.create_subnodes_for_labelname(labelname)

</t>
<t tx="bwmulder.20040531110909.162">def labels_to_subnodes(self):
   """
   Convert all labels to subnodes.
   """
   labels = self.collect_labels()
   to_process = []
   for v in self.iterator():
      labels_dict = self.get_labels_dict(v)
      if labels_dict:
         for key, value in labels_dict.items():
            to_process.append((v, key, value))
   self.insert_nodes_for_labels_as_children(to_process)
   



</t>
<t tx="bwmulder.20040531110909.163"></t>
<t tx="bwmulder.20040531110909.164">def subnode_to_label(self):
   """
   Update a label from a subnode.
   Delete the subnode.
   """
   # Retrieve the list of labels defined for this node.
   labelnames = self.get_labellist_for_node()
   if labelnames is None:
      g.es("No labels defined for this node")
      return
   
   # Now look through children to see which subnodes match a label name.
   # Construct the intersection of the headStrings of the children
   # and the labellist.
   child = v.firstChild()
   labelnames_dict = {}
   while child:
      headline = child.headString()
      if headline in labelnames:
         labelnames_dict[headline] = child
      child = child.next()
   
   labelnames_found = labelnames_dict.keys()
   if not labelnames_found:
      g.es("No suitable subnode found")
      return
   labelnames_found.sort()
      
   # Now let the user select a labelname
   title = "Select subnode to delete"
   label_text = "Subnodes to fold"
   root = g.top().frame.outerFrame
   widget = Pmw_combobox(root, title = title, label_text = label_text, scrolledlist_items = labelnames_found)
   result = widget.doit()
   if result == 'Cancel':
      return
      
   labelname = widget.dialog.get()
   if labelname in labelnames:
      child = labelnames_dict[labelname]
      labels[labelname] = child.bodyString()
      self.set_labels_dict(v, labels)
      
      # now delete the subnode
      self.c.selectVnode(child)
      self.c.cutOutline()
      self.c.selectVnode(v)

   



</t>
<t tx="bwmulder.20040531110909.165">def subnodes_to_label(self):
   """
   Update the label from subnodes, as far as they exist.
   Delete those subnodes.
   """
   labelname = self.select_label()
   if labelname:
      nodes_to_delete = []
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            if labels_dict.has_key(labelname):
               child = v.firstChild()
               while child and child.headString() != labelname:
                  child = child.next()
               if child:
                  nodes_to_delete.append(child)
      for v in nodes_to_delete:
         parent = v.parent()
         parent_dict = self.get_labels_dict(parent)
         parent_dict[v.headString()] = v.bodyString()
         self.set_labels_dict(v, parent_dict)
         
         # now delete the child
         self.c.selectVnode(child)
         self.c.cutOutline()
         self.c.selectVnode(parent)
                  
   
   





</t>
<t tx="bwmulder.20040531110909.166">def subnodes_to_labels(self):
   """
   Update all labels from subnodes, if those subnodes exist.
   
   Delete all those subnodes.
   """
   labelnames = self.collect_labels()
   if labelnames:
      nodes_to_delete = []
      for v in self.iterator():
         labels_dict = self.get_labels_dict(v)
         if labels_dict:
            for labelname in labels_dict.keys():
               child = v.firstChild()
               while child and child.headString() != labelname:
                  child = child.next()
               if child:
                  nodes_to_delete.append(child)
      for v in nodes_to_delete:
         parent = v.parent()
         parent_dict = self.get_labels_dict(parent)
         parent_dict[v.headString()] = v.bodyString()
         self.set_labels_dict(parent, parent_dict)
         
         # now delete the child
         self.c.selectVnode(v)
         self.c.cutOutline()
         self.c.selectVnode(parent)
   




</t>
<t tx="bwmulder.20040531110909.167"></t>
<t tx="bwmulder.20040531110909.168">def clone_label_subnodes(self):
   """
   Collect clones of all nodes with a label and move them to a child position of the current node.
   """
   def clonefilter(node):
      result = node.t not in tnodes
      tnodes[node.t] = None
      return result
      
   currentNode = self.c.currentVnode()
   
   # 1. Get the name of a label.
   result, widget, labellist = self.show_labels()
   if result == 'Cancel':
      return
   labelname = widget.dialog.get()

   # 2. Find all the nodes with the label.
   nodes = [v for v, labelname, labelcontent in self.find_nodes_with_labelname(labelname)]
   
   # 3. Filter out multiple instances of the same clones
   tnodes = {}; nodes = [node for node in nodes if clonefilter(node)]
   
   # 4. Clone those nodes.
   clones = [node.clone(node) for node in nodes]
   
   # 5. Now move all clones so that they are a child of the current node.
   self.move_to_child_positions(clones, currentNode)
   
   # 6. Redraw the screen
   self.c.redraw()</t>
<t tx="bwmulder.20040531211637">trace_get_set_dict = True
</t>
<t tx="bwmulder.20040601075953"></t>
<t tx="bwmulder.20040601075953.1">
deleteOutline:

It seems what I have to do:
	- store away the current position.
	- create a position for the node.
	- call p.doDelete(newNode)
	- Call a rewritten setAllAncestorAtFileNodesDirty for *all* changed nodes.
p.setAllAncestorAtFileNodesDirty()
p.doDelete(newNode)
</t>
<t tx="bwmulder.20040601075953.2">def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = []
	newNodes = p.v.t.vnodeList[:]

	# Add nodes until no more are added.
	while newNodes:
		# g.trace(len(newNodes))
		addedNodes = []
		nodes.extend(newNodes)
		for v in newNodes:
			for v2 in v.t.vnodeList:
				if v2 not in nodes and v2 not in addedNodes:
					addedNodes.append(v2)
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes and v3 not in addedNodes:
						addedNodes.append(v3)
		newNodes = addedNodes[:]

	# g.trace(nodes)
	return nodes</t>
<t tx="bwmulder.20040601075953.3">def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = {}
	newNodes = dict([(v, None) for v in p.v.t.vnodeList])

	# Add nodes until no more are added.
	while newNodes != {}:
		# g.trace(len(newNodes))
		addedNodes = {}
		nodes.update(newNodes)
		for v in newNodes.keys():
			for v2 in v.t.vnodeList:
				if v2 not in nodes:
					addedNodes[v2] = None
				# instead of 
				# if v2 not in nodes and v2 not in addedNodes:
				# 	addedNodes.append(v2)
				# one 'in' test less, and the test is (approximately) independent
				# of number of nodes in 'nodes'.
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes:
						addedNodes[v3] = None
		newNodes = addedNodes

	# g.trace(nodes)
	return nodes</t>
<t tx="bwmulder.20040601075953.4">def findAllPotentiallyDirtyNodes(vlist):
	
	# accept a list of vnodes, or just a single vnode
	try:
		for v in vlist:
			break
	except TypeError:
		vlist = [vlist]
	
	# Start with all nodes in the vnodeList.
	nodes = {}
	newNodes = dict([(v, None) for v in v1.t.vnodeList for v1 in vlist])

	# Add nodes until no more are added.
	while newNodes != {}:
		# g.trace(len(newNodes))
		addedNodes = {}
		nodes.update(newNodes)
		for v in newNodes.keys():
			for v2 in v.t.vnodeList:
				if v2 not in nodes:
					addedNodes[v2] = None
				# instead of 
				# if v2 not in nodes and v2 not in addedNodes:
				# 	addedNodes.append(v2)
				# one 'in' test less, and the remaining test is (approximately) independent
				# of number of nodes in 'nodes'.
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes:
						addedNodes[v3] = None
		newNodes = addedNodes

	# g.trace(nodes)
	return nodes

</t>
<t tx="bwmulder.20040601075953.5">import leoNodes
import leoGlobals as g

count = 0
for v in g.top().allNodes_iter():
	count += 1
print count

def iterator_node(v):
	if v:
		yield v
		for v1 in iterator_node(v.t._firstChild):
			yield v1
		while v:
			v = v._next
			for v in iterator_node(v):
				yield v

count = 0
for v in iterator_node(g.top().rootVnode().v):
	count += 1
print count


	</t>
<t tx="bwmulder.20040601075953.6">import leoNodes
import leoGlobals as g

count = 0
for v in g.top().all_vnodes_iter():
	count += 1
print count

def iterator_node(v, map):
	if v and v not in map:
		map[v] = None
		yield v
		for v1 in iterator_node(v.t._firstChild, map):
			yield v1
		while v:
			v = v._next
			for v in iterator_node(v, map):
				yield v

count = 0
for v in iterator_node(g.top().rootVnode().v, {}):
	count += 1
print count


	
</t>
<t tx="bwmulder.20040603171035">@doc
@nocolor</t>
<t tx="bwmulder.20040603171115">The first question you should ask yourself is: should my plugin support undo?

Sometimes there is really nothing to undo. Displaying the list of recently visited notes, for example, is no need to worry about undoing anything. If you change the structure of the outline in any way, however, then you you actually must support undo.</t>
<t tx="bwmulder.20040603171502">Lets assume that your plugin changes the structure of the outline, for example it creates a set of subnodes for the current node. What do you need to do to support undoing?

First, you have to decide how to call your command for the purpose of displaying in on the Edit menu. Let's say you call your command "Create Subnode For Files". In order to make the change undoable, you have to call:

c.undoer.setMenu("Create Subnode For Files").

Congratulations! Your plugin supports undo and redo!
</t>
<t tx="bwmulder.20040603172129">If you have your own variables which might have to revert to a previous state, you have to do a little bit more. Assume you have a counter called "counter" which need to be reset if a command is to be undone. In order to get the counter reset automatically, you need to do two things:

1. Put this counter into an instance of a new style class:

class demo_class(object):
   def __init__(self):
      self.counter = 0

demo = demo_class()


2. Tell the undoer about your class component.

c.undoer.monitor_scalar(demo_class, "counter")
c.undoer.enable()

You have just added demo.counter to the undo mechanism!


Since you specified the class as a parameter to monitor_scalar, the undo mechanism keeps track of all changes to the attribute counter in all instances of demo_class. In other words, you can write:

d1, d2 = demo_class(), demo_class()
d1.counter = 3
d2.counter = 5

and both attributes d1.counter and d2.counter will be included in undo mechanism.

c.undoer.monitor_scalar can be used for attributes which are integers, references to other objects, and, to some extend strings.

For example, you can define:

 class linked_list:
    def __init__(self, data=None, next=None):
       self.next = next
       self.data = data

c.undoer.monitor_scalar("linked_list", "next")
c.undoer.monitor_scalar("linked_list", "data")
c.undoer.enable()

and then:

root = linked_list()

root.next = linked_list("a", root)
root.next = linked_list("b", root)

and the undoer keep track of all the data in this linked list for you!
</t>
<t tx="bwmulder.20040603173718"></t>
<t tx="bwmulder.20040603174249">Things get only slightly more complicated when you want to make operations on lists and mappings undoable.

Lets assume that you have data to store in a list or mapping which is not shared, or should be included in the undo mechanism.

All you have to do in this case is to use

c.undoer.monitor_list_attribute_in_class(&lt;classname&gt;, &lt;attributename&gt;)

and

c.undoer.monitor_dict_attribute_in_class(&lt;classname&gt;, &lt;attributename&gt;)

The undoer will monitor the attributes and replace the basic list and dictionary types with derived types which inform the undoer about any changes!</t>
<t tx="bwmulder.20040603174310">The final case covered by the undo mechanism is when the lists and dictionaries contain other lists and dictionaries which should be undoable.

In this case, you must instantiate leoUndo.dict_monitor and leoUndo.list_monitor. For example:

x = c.undoer.list_monitor(1, 2, 3)
x.monitor_object = c.undoer
c.undoer.enable()

Now x will be tracked by the undoer, and put back to a previous state if the user undos a commando!
</t>
<t tx="bwmulder.20040603174656">The undo mechanism of Leo uses the very same mechanism. See ...</t>
<t tx="bwmulder.20040603174758">Treating strings as "scalar" might waste a lot of memory. Future versions of the interface might offer a specialised interface for strings (tbd), or automatically compress the undo information.
</t>
<t tx="bwmulder.20040603213015">You can use this mechanism to recover from exceptions. You can write something like:

try:
  &lt;&lt;your code&gt;&gt;
except &lt;&lt;your exception&gt;&gt;:
	c.undoer.rollback()

This call to c.undoer.rollback() will undo the changes to all "monitored" attributes since
the last c.undoer.mark() call.

The rollback itself is not redoable.</t>
<t tx="bwmulder.20040605120821">c:\Python23\Lib\trace.py -c  basic_undo_test.py
</t>
</tnodes>
</leo_file>
