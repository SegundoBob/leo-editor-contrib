<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="1375" clone_windows="0"/>
<globals body_outline_ratio="0.53312788906">
	<global_window_position top="26" left="10" height="649" width="1014"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="zorcanda!.20050615155621"><vh>What is JyLeo?</vh></v>
<v t="zorcanda!.20050609174820"><vh>Bugs and weird things sited...</vh></v>
<v t="zorcanda!.20050615161138"><vh>plans</vh></v>
<v t="mork.20050127125058.31" a="TV"
expanded="orkman.20050202102136,orkman.20050212183815,orkman.20050212183628,orkman.20050210120520,zorcanda!.20050407101020,orkman.20050210114856,zorcanda!.20051102145654,zorcanda!.20051102181044,zorcanda!.20050225092920,orkman.20050213132705,orkman.20050213133238,orkman.20050213133206,zorcanda!.20050224092411,orkman.20050202110639,mork.20050127125058.57,mork.20050127125058.60,mork.20050127130815,zorcanda!.20051206140225,zorcanda!.20051206140337,zorcanda!.20050530212448,zorcanda!.20051129194856,zorcanda!.20051205162524,"><vh>@thin leoSwingFrame.py</vh></v>
<v t="mork.20050127121143"
expanded="mork.20050127121143.2,zorcanda!.20050404121856,"><vh>@thin leoSwingFind.py</vh></v>
<v t="mork.20050127125058.146"
expanded="mork.20050127125058.147,mork.20050127125058.148,mork.20050127125058.162,zorcanda!.20050530115036,zorcanda!.20050331121405,"><vh>@thin leoSwingGui.py</vh></v>
<v t="mork.20050127175441.1"
expanded="mork.20050127175441.2,zorcanda!.20050328114741,zorcanda!.20050413144058,"><vh>@thin leoSwingMenu.py</vh></v>
<v t="zorcanda!.20050409134025"
expanded="zorcanda!.20050409134025.1,zorcanda!.20050409134025.5,zorcanda!.20050410084633,"><vh>@thin leoSwingComparePanel.py</vh></v>
<v t="zorcanda!.20050830145654"><vh>@thin LeoSwingColorizer.java</vh></v>
<v t="zorcanda!.20050913164543"><vh>__jeditColorizer</vh></v>
<v t="orkman.20050203100526"
expanded="orkman.20050203101946,orkman.20050210162339,"><vh>@thin leoEditorKit.java</vh></v>
<v t="zorcanda!.20050911194625" a="E"><vh>@thin LeoScriptExecutor.py</vh></v>
<v t="zorcanda!.20050909105436" tnodeList="zorcanda!.20050909105436"><vh>@file-nosent ShowWPProblem.java</vh></v>
<v t="zorcanda!.20050625135002"><vh>@thin LeoObservable.java</vh></v>
<v t="zorcanda!.20050907152321"><vh>utilities</vh>
<v t="zorcanda!.20050907152331"><vh>@thin DefCallable.py</vh></v>
<v t="zorcanda!.20050907152504"><vh>@thin CutCopyPaste.py</vh></v>
<v t="zorcanda!.20050920161520"><vh>@thin TabManager.py</vh></v>
<v t="zorcanda!.20050922112746"><vh>@thin DoNothingEntityResolver.py</vh></v>
<v t="zorcanda!.20051102201318"><vh>@thin JPanelScrollableDelegator.py</vh></v>
<v t="zorcanda!.20051214203351"><vh>@thin WeakMethod.py</vh></v>
<v t="zorcanda!.20051208141646"><vh>@thin Phaser.py</vh></v>
<v t="zorcanda!.20051208165033"><vh>@thin Slider.py</vh></v>
</v>
<v t="zorcanda!.20051108223332"><vh>org.leo</vh>
<v t="zorcanda!.20051108223332.1"><vh>@thin ImageJPanel.java</vh></v>
<v t="zorcanda!.20051203121856"><vh>@thin JTextComponentOutputStream.java</vh></v>
<v t="zorcanda!.20051114092424"><vh>shell</vh>
<v t="zorcanda!.20051210115447" tnodeList="zorcanda!.20051210115447"><vh>@file-nosent build.xml</vh></v>
<v t="zorcanda!.20051117160341"><vh>@thin ComboBoxTest.py</vh></v>
<v t="zorcanda!.20051117192717"><vh>@thin SplitMenuTest.py</vh></v>
<v t="zorcanda!.20051120132459"><vh>@thin JTableTst.py</vh></v>
<v t="zorcanda!.20051114092424.105"><vh>@thin IsolatedJythonClassLoader.java</vh></v>
<v t="zorcanda!.20051122223726"><vh>@thin DorkClassLoader.java</vh></v>
<v t="zorcanda!.20051115104433"
marks="zorcanda!.20051115105044.1,"><vh>@thin Autocompleter.java</vh></v>
<v t="zorcanda!.20051115114601"
expanded="zorcanda!.20051115114727,"><vh>@thin Calltip.java</vh></v>
<v t="zorcanda!.20051119001951"><vh>@thin Autoquoter.java</vh></v>
<v t="zorcanda!.20051122091833"><vh>@thin LineOutputSupresser.java</vh></v>
<v t="zorcanda!.20051203212414"><vh>@thin ObjectWildCard.java</vh></v>
<v t="zorcanda!.20051204131250"><vh>@thin SystemCommand.java</vh></v>
<v t="zorcanda!.20051204164445"><vh>@thin UnifiedHelp.java</vh></v>
<v t="zorcanda!.20051114092424.2"
expanded="zorcanda!.20051117150934,zorcanda!.20051114092424.6,zorcanda!.20051114092424.16,zorcanda!.20051114092424.19,zorcanda!.20051114092424.57,"><vh>@thin JythonShell.java</vh></v>
<v t="zorcanda!.20051114092815"><vh>@thin MagicCommand.java</vh></v>
<v t="zorcanda!.20051114133620"><vh>@thin LineListener.java</vh></v>
<v t="zorcanda!.20051207144726"><vh>@thin LineListenerException.java</vh></v>
<v t="zorcanda!.20051128185119"><vh>@thin UtilityBoxListener.java</vh></v>
<v t="zorcanda!.20051128185119.1"><vh>@thin UtilityBoxEvent.java</vh></v>
<v t="zorcanda!.20051116113941"><vh>@thin PromptFormatter.java</vh></v>
<v t="zorcanda!.20051117224809"><vh>@thin Documentation.java</vh></v>
</v>
<v t="zorcanda!.20051114093736"><vh>magic commands</vh>
<v t="zorcanda!.20051114093736.1"><vh>@thin Macro.java</vh></v>
<v t="zorcanda!.20051114094832"><vh>@thin History.java</vh></v>
<v t="zorcanda!.20051114101117"><vh>@thin Debugger.java</vh></v>
<v t="zorcanda!.20051114103416"><vh>@thin Prun.java</vh></v>
<v t="zorcanda!.20051114104215"><vh>@thin Threads.java</vh></v>
<v t="zorcanda!.20051114104943"><vh>@thin XSLT.java</vh></v>
<v t="zorcanda!.20051114105618"><vh>@thin Serialize.java</vh></v>
<v t="zorcanda!.20051114111331"><vh>@thin Deserialize.java</vh></v>
<v t="zorcanda!.20051114111812"><vh>@thin Clean.java</vh></v>
<v t="zorcanda!.20051114112036"><vh>@thin Swing.java</vh></v>
<v t="zorcanda!.20051114112536"><vh>@thin Pwd.java</vh></v>
<v t="zorcanda!.20051203161750"><vh>@thin Jpidcore.java</vh></v>
<v t="zorcanda!.20051203161122"><vh>@thin Bgprocess.java</vh></v>
<v t="zorcanda!.20051114114456"><vh>@thin See.java</vh></v>
<v t="zorcanda!.20051114115012"><vh>@thin Cd.java</vh></v>
<v t="zorcanda!.20051201220428"><vh>@thin Dhist.java</vh></v>
<v t="zorcanda!.20051114115227"><vh>@thin Ps.java</vh></v>
<v t="zorcanda!.20051114115810"><vh>@thin Ls.java</vh></v>
<v t="zorcanda!.20051114125454"><vh>@thin Send.java</vh></v>
<v t="zorcanda!.20051114125834"><vh>@thin Wait.java</vh></v>
<v t="zorcanda!.20051114130124"><vh>@thin Kill.java</vh></v>
<v t="zorcanda!.20051114133204"><vh>@thin Clear.java</vh></v>
<v t="zorcanda!.20051114174617"><vh>@thin Lsmagic.java</vh></v>
<v t="zorcanda!.20051114182223"><vh>@thin Magic.java</vh></v>
<v t="zorcanda!.20051201133733"><vh>@thin Keystrokes.java</vh></v>
<v t="zorcanda!.20051204152126"><vh>@thin Iuse.java</vh></v>
<v t="zorcanda!.20051114230839"><vh>@thin Url.java</vh></v>
<v t="zorcanda!.20051116115841"><vh>@thin Bg.java</vh></v>
<v t="zorcanda!.20051116154614"><vh>@thin Pfile.java</vh></v>
<v t="zorcanda!.20051116191026"><vh>@thin Pdoc.java</vh></v>
<v t="zorcanda!.20051117115313"><vh>@thin Pinfo.java</vh></v>
<v t="zorcanda!.20051117120412"><vh>@thin P.java</vh></v>
<v t="zorcanda!.20051117145613"><vh>@thin R.java</vh></v>
<v t="zorcanda!.20051117152006"><vh>@thin Env.java</vh></v>
<v t="zorcanda!.20051117170814"><vh>@thin Save.java</vh></v>
<v t="zorcanda!.20051118222818"><vh>@thin Who.java</vh></v>
<v t="zorcanda!.20051118223213"><vh>@thin Whos.java</vh></v>
<v t="zorcanda!.20051119110400"><vh>@thin Who_ls.java</vh></v>
<v t="zorcanda!.20051118235735"><vh>@thin Autocall.java</vh></v>
<v t="zorcanda!.20051119000118"><vh>@thin Autoindent.java</vh></v>
<v t="zorcanda!.20051119101703"><vh>@thin Sc.java</vh></v>
<v t="zorcanda!.20051119102720"><vh>@thin Sx.java</vh></v>
<v t="zorcanda!.20051119115311"><vh>@thin Ed.java</vh></v>
<v t="zorcanda!.20051120223225"><vh>@thin Reset.java</vh></v>
<v t="zorcanda!.20051121190424"><vh>@thin Alias.java</vh></v>
<v t="zorcanda!.20051121194231"><vh>@thin Unalias.java</vh></v>
<v t="zorcanda!.20051121192619"><vh>@thin Rehash.java</vh></v>
<v t="zorcanda!.20051121192758"><vh>@thin Rehashx.java</vh></v>
<v t="zorcanda!.20051122094602"><vh>@thin Run.java</vh></v>
<v t="zorcanda!.20051201145516"><vh>@thin Bookmark.java</vh></v>
<v t="zorcanda!.20051202092511"><vh>@thin Dirs.java</vh></v>
<v t="zorcanda!.20051202115349"><vh>@thin Popd.java</vh></v>
<v t="zorcanda!.20051202120242"><vh>@thin Pushd.java</vh></v>
<v t="zorcanda!.20051203115652" a="E"><vh>@thin Automagic.java</vh></v>
<v t="zorcanda!.20051203131459"><vh>@thin Logcore.java</vh></v>
<v t="zorcanda!.20051203130354"><vh>@thin Logstart.java</vh></v>
<v t="zorcanda!.20051203132240"><vh>@thin Logoff.java</vh></v>
<v t="zorcanda!.20051203132240.2"><vh>@thin Logon.java</vh></v>
<v t="zorcanda!.20051203134428"><vh>@thin Logstate.java</vh></v>
<v t="zorcanda!.20051203174953"><vh>@thin Runlog.java</vh></v>
</v>
<v t="zorcanda!.20051121130625"><vh>magic editor</vh>
<v t="zorcanda!.20051121130625.1"><vh>@thin StartOfLine.java</vh></v>
<v t="zorcanda!.20051121130748"><vh>@thin EndOfLine.java</vh></v>
</v>
<v t="zorcanda!.20051115154911"><vh>actions</vh>
<v t="zorcanda!.20051115154911.1"><vh>@thin DeleteToEndOfLine.java</vh></v>
<v t="zorcanda!.20051115172817"><vh>@thin RemoveLine.java</vh></v>
<v t="zorcanda!.20051115174341"><vh>@thin StartOfLine.java</vh></v>
<v t="zorcanda!.20051115174418"><vh>@thin EndOfLine.java</vh></v>
<v t="zorcanda!.20051115175216"><vh>@thin DynamicAbbreviation.java</vh></v>
<v t="zorcanda!.20051115181444"><vh>@thin UpDownArrows.java</vh></v>
<v t="zorcanda!.20051207104043" a="E"><vh>@thin TabCompletion.java</vh></v>
<v t="zorcanda!.20051117180849"><vh>@thin SearchInputHistory.java</vh></v>
<v t="zorcanda!.20051117224330"><vh>@thin ReverseIncrementalSearch.java</vh></v>
<v t="zorcanda!.20051120231840"><vh>@thin SupressOutput.java</vh></v>
<v t="zorcanda!.20051121124855"><vh>@thin TripleQuotes.java</vh></v>
<v t="zorcanda!.20051128184238"><vh>@thin CloseUtilityBoxes.java</vh></v>
<v t="zorcanda!.20051204172344"><vh>@thin PasteAsScript.java</vh></v>
<v t="zorcanda!.20051204173522"><vh>@thin Paste.java</vh></v>
<v t="zorcanda!.20051204173611"><vh>@thin Copy.java</vh></v>
</v>
<v t="zorcanda!.20051115192359"><vh>util</vh>
<v t="zorcanda!.20051115192531"><vh>@thin StringInserter.java</vh></v>
<v t="zorcanda!.20051115193957"><vh>@thin InsertPrompt.java</vh></v>
<v t="zorcanda!.20051115194127"><vh>@thin AddLine.java</vh></v>
<v t="zorcanda!.20051121103634"><vh>@thin ScriptExecutor.java</vh></v>
<v t="zorcanda!.20051210112735" a="E"><vh>@thin JSUtilities.java</vh></v>
<v t="zorcanda!.20051122113356"><vh>@thin CommandLineParser.java</vh></v>
<v t="zorcanda!.20051129115446"><vh>@thin CommandFinder.java</vh></v>
<v t="zorcanda!.20051128193806"><vh>@thin ProcessExecutor.java</vh></v>
<v t="zorcanda!.20051207114114"><vh>@thin Abbreviation.java</vh></v>
</v>
<v t="zorcanda!.20051115195219"><vh>widget</vh>
<v t="zorcanda!.20051115195219.1"><vh>@thin CopyPaste.java</vh></v>
<v t="zorcanda!.20051117153808"><vh>@thin CutCopyPaste.java</vh></v>
<v t="zorcanda!.20051204160958"><vh>@thin Pager.java</vh></v>
<v t="zorcanda!.20051117134127"><vh>@thin ZoneViewEditorKit.java</vh></v>
<v t="zorcanda!.20051115195557"><vh>@thin UneditableTableModel.java</vh></v>
<v t="zorcanda!.20051117114653"><vh>@thin ImageJViewport.java</vh></v>
<v t="zorcanda!.20051128145737"><vh>@thin MessageBorder.java</vh></v>
<v t="zorcanda!.20051117114153"><vh>@thin ObjectViewer.java</vh></v>
</v>
<v t="zorcanda!.20051115191914"><vh>io</vh>
<v t="zorcanda!.20051115192051"><vh>@thin JSOutputStream.java</vh></v>
<v t="zorcanda!.20051115192210"><vh>@thin PyFile2.java</vh></v>
</v>
<v t="zorcanda!.20051120222558"><vh>color</vh>
<v t="zorcanda!.20051119155132" a="E"
expanded="zorcanda!.20051119155214,"><vh>@thin JythonColorizer.java</vh></v>
<v t="zorcanda!.20051120201022.1"><vh>@thin ColorConfigurationListener.java</vh></v>
<v t="zorcanda!.20051120201216"><vh>@thin ColorEvent.java</vh></v>
<v t="zorcanda!.20051120183113" a="E"><vh>@thin ColorConfiguration.java</vh></v>
</v>
<v t="zorcanda!.20051121155957"><vh>alias</vh>
<v t="zorcanda!.20051121155957.1"><vh>@thin Alias.java</vh></v>
<v t="zorcanda!.20051121164532"><vh>@thin AliasConverter.java</vh></v>
</v>
</v>
<v t="zorcanda!.20051006111637"><vh>jconstants</vh>
<v t="zorcanda!.20051006111655"><vh>@thin AtFileConstants.java</vh></v>
</v>
<v t="zorcanda!.20050831165127"
expanded="zorcanda!.20050906183457,"><vh>@thin NodeUndoer.py</vh></v>
<v t="zorcanda!.20050831213508"><vh>@thin NodeUndoerBase.java</vh></v>
<v t="zorcanda!.20050906165511"><vh>@thin LeoCompoundEdit.java</vh></v>
<v t="zorcanda!.20050609085552"><vh>@thin TnodeBodyText.java</vh></v>
<v t="zorcanda!.20050529141420"><vh>@thin leoManagement.py</vh></v>
<v t="zorcanda!.20050529161650.1"><vh>@thin leoManagedConfigurationMBean.java</vh></v>
<v t="zorcanda!.20050529180331"><vh>@thin leoManagedConfiguration.java</vh></v>
<v t="zorcanda!.20050518163508"><vh>@thin leoCompositeView.py</vh></v>
<v t="zorcanda!.20050523094436"><vh>@thin leoGraphView.py</vh></v>
<v t="zorcanda!.20050922115413"><vh>Views</vh>
<v t="zorcanda!.20050617104319"><vh>@thin leoFlashCardView.py</vh></v>
<v t="zorcanda!.20050729130103"><vh>@thin leoEditAttributeView.py</vh></v>
</v>
<v t="zorcanda!.20050609201329.1"
expanded="zorcanda!.20050609222056,zorcanda!.20050923114946,zorcanda!.20050923114946.10,"><vh>@thin leoSwingUndo.py</vh></v>
<v t="zorcanda!.20050303094610"
expanded="zorcanda!.20050303094610.2,zorcanda!.20050303094610.38,zorcanda!.20050303094610.39,zorcanda!.20050303094610.74,zorcanda!.20050303094610.76,zorcanda!.20050303094610.79,zorcanda!.20050303094610.80,zorcanda!.20050303094610.88,zorcanda!.20050303094610.125,"><vh>@thin leoSwingConfig.py</vh></v>
<v t="zorcanda!.20051107154721"><vh>@thin ClassLoaderBase.java</vh></v>
<v t="zorcanda!.20050325114421"
expanded="zorcanda!.20050419193324,"><vh>@thin leoSwingPrint.py</vh></v>
<v t="zorcanda!.20050401111120"><vh>@thin leoSwingHTMLView.py</vh></v>
<v t="zorcanda!.20050917120209"><vh>@thin leoSwingLeoTutorial.py</vh></v>
<v t="zorcanda!.20050325163410"
expanded="zorcanda!.20050325163410.50,"><vh>@thin leoSwingPluginManager2.py</vh></v>
<v t="pap.20041006184225"
expanded="pap.20050317185409.1,pap.20041009140132,pap.20041009140132.1,pap.20041006184225.6,pap.20041009225149,"><vh>@thin leoSwingPluginManager.py</vh></v>
<v t="EKR.20040517080555.2"
expanded="pap.20050305152751,EKR.20040517080555.3,EKR.20040517080555.4,EKR.20040517080555.10,EKR.20040517080555.11,EKR.20040517080555.13,EKR.20040517080555.19,EKR.20040517080555.20,EKR.20040517080555.23,EKR.20040517080555.24,"><vh>@thin plugins_menu.py</vh></v>
<v t="zorcanda!.20050516103136"><vh>@thin CommanderSupplemental.py</vh></v>
<v t="zorcanda!.20050924193446"
expanded="zorcanda!.20051212103009,"><vh>@thin Chapters.py</vh></v>
<v t="orkman.20050218182202" a="E"><vh>@thin leoIconTreeRenderer.java</vh></v>
<v t="zorcanda!.20050411083353"><vh>@thin leoHeadlineTreeCellEditor.java</vh></v>
<v t="zorcanda!.20050924111205"><vh>@thin leoLanguageManager.py</vh></v>
<v t="zorcanda!.20051127091922"><vh>@thin RepaintManager2.java</vh></v>
<v t="zorcanda!.20051113153110"><vh>@thin RotatableJLabel.py</vh></v>
<v t="orkman.20050217124828"><vh>@thin PositionSpecification.java</vh></v>
<v t="zorcanda!.20051007100531"><vh>@thin PositionJTree.java</vh></v>
<v t="zorcanda!.20051007210141"><vh>@thin PositionJTree2.java</vh></v>
<v t="zorcanda!.20051007112951"><vh>@thin JTree2.py</vh></v>
<v t="zorcanda!.20051007114938"><vh>@thin TestAbstract.java</vh></v>
<v t="zorcanda!.20051007220907"><vh>@thin TestAb.py</vh></v>
<v t="orkman.20050219185401" a="E"><vh>@thin CommanderSpecification.java</vh></v>
<v t="zorcanda!.20050515163457"><vh>@thin IteratorDecorator.java</vh></v>
<v t="zorcanda!.20050515164849"><vh>@thin PositionIterator.java</vh></v>
<v t="zorcanda!.20050309184057"><vh>@thin EditorBackground.java</vh></v>
<v t="zorcanda!.20050314160546" a="E"><vh>@thin EditorBackgroundMovie.java</vh></v>
<v t="zorcanda!.20050824102107" tnodeList="zorcanda!.20050824102107"><vh>@file-nosent jyleo.py</vh></v>
<v t="zorcanda!.20050322160447"
expanded="zorcanda!.20050323114117,"><vh>@thin leoRadialMenu.java</vh></v>
<v t="zorcanda!.20050301154640"><vh>@thin AutoPanel.java</vh></v>
<v t="orkman.20050211155354" a="E"><vh>@thin BarDrawer.java</vh></v>
<v t="orkman.20050216144756"><vh>@thin leoTreeReloader.java</vh></v>
<v t="zorcanda!.20051006102904"><vh>@thin TnodeOperations.java</vh></v>
<v t="zorcanda!.20051003150005"
expanded="zorcanda!.20051003153333,zorcanda!.20051003162351,zorcanda!.20051004133343,zorcanda!.20051004133343.1,zorcanda!.20051006121609,zorcanda!.20051006121951,zorcanda!.20051006105232,zorcanda!.20051006100445,zorcanda!.20051004134925,"><vh>@thin LeoFileReader.java</vh></v>
<v t="orkman.20050215122424"
marks="orkman.20050218162606.2,orkman.20050215185022.2,orkman.20050217115715,orkman.20050220130419,"
expanded="orkman.20050215143101,orkman.20050215170438,orkman.20050218142615,orkman.20050218162606,orkman.20050219195121,orkman.20050215185022,orkman.20050218122434,orkman.20050217115715,orkman.20050220130419,orkman.20050220130419.3,orkman.20050220171955,orkman.20050220174612,"><vh>@thin leoBaseAtFile.java</vh></v>
<v t="orkman.20050209094014"><vh>@thin leoLNEditorKit.java</vh></v>
<v t="orkman.20050208103155"><vh>@thin leoLayoutManager.java</vh></v>
<v t="zorcanda!.20051115102332" tnodeList="zorcanda!.20051115102332"><vh>@file-nosent JListProblem.java</vh></v>
<v t="orkman.20050207150858" a="E"
expanded="zorcanda!.20050604091242,orkman.20050213110511,orkman.20050213105021,orkman.20050213105021.4,zorcanda!.20050907102256,orkman.20050210110555,zorcanda!.20050704092406.1,"><vh>@thin SwingMacs.py</vh></v>
<v t="zorcanda!.20060110141749"><vh>@thin KTableMaker.py</vh></v>
<v t="ekr.20041003172238"
expanded="zorcanda!.20050313120424,ekr.20041003172238.4,"><vh>@thin JLibrary.py</vh></v>
<v t="zorcanda!.20051101111231"><vh>colorization code and editor kit code</vh>
<v t="zorcanda!.20051024202308"><vh>@thin JyLeoColorizer.py</vh></v>
<v t="zorcanda!.20051031112704"
expanded="zorcanda!.20051031113003,zorcanda!.20051031114936,zorcanda!.20051031121109,"><vh>@thin JyLeoTokenizer.java</vh></v>
<v t="zorcanda!.20051031155350"
expanded="zorcanda!.20051201121336,zorcanda!.20051031155350.1,zorcanda!.20051031155350.6,zorcanda!.20051031180404,zorcanda!.20051031181357,zorcanda!.20051031181536.1,"><vh>@thin ColorizerRunnable.java</vh></v>
<v t="zorcanda!.20051031194657"><vh>@thin PositionCarrier.java</vh></v>
<v t="zorcanda!.20051025184052"
expanded="zorcanda!.20051102105133,"><vh>@thin leoEditorKit2.java</vh></v>
<v t="zorcanda!.20051103202851"
expanded="zorcanda!.20051103202851.2,"><vh>@thin leoTableViewEditorKit.java</vh></v>
</v>
<v t="zorcanda!.20050609162345"><vh>@thin LeoUtilities.java</vh></v>
<v t="zorcanda!.20051106192717"><vh>@thin JyLeoClassloader.java</vh></v>
<v t="zorcanda!.20051107094913"><vh>@thin JyLeoResourceClassLoader.java</vh></v>
<v t="zorcanda!.20051107100553"><vh>@thin FakeClass.java</vh></v>
<v t="zorcanda!.20050914114543" tnodeList="zorcanda!.20050914114543"><vh>@file-nosent OpaqueProblem.py</vh></v>
<v t="zorcanda!.20050908210137"><vh>@thin DOMLeoFileReader.py</vh></v>
<v t="zorcanda!.20051129101251" tnodeList="zorcanda!.20051129101251"><vh>@file-nosent TestListRenderer.py</vh></v>
<v t="zorcanda!.20050224165207" tnodeList="zorcanda!.20050224165207"><vh>@file-nosent leosynth.xml</vh></v>
<v t="zorcanda!.20050313102647" tnodeList="zorcanda!.20050313102647"><vh>@file-nosent FieryLeo.xml</vh></v>
<v t="zorcanda!.20050307192009"><vh>file-nosent leosynth2.xml</vh></v>
<v t="zorcanda!.20050312100815" a="E" tnodeList="zorcanda!.20050312100815"><vh>@file-nosent ASynthTest.java</vh></v>
<v t="zorcanda!.20050228132221" a="E"><vh>file-nosent asynth.xml</vh></v>
<v t="zorcanda!.20050228131451"><vh>NewHeadline</vh></v>
<v t="zorcanda!.20050518102918" tnodeList="zorcanda!.20050518102918"><vh>@file-nosent de64files.py</vh></v>
<v t="zorcanda!.20050810101232" tnodeList="zorcanda!.20050810101232"><vh>@file-nosent testimport.py</vh></v>
<v t="zorcanda!.20050810110842" tnodeList="zorcanda!.20050810110842"><vh>@file-nosent testimport2.py</vh></v>
<v t="zorcanda!.20051004113423" tnodeList="zorcanda!.20051004113423"><vh>@file-nosent ExpandTreeExample.java</vh></v>
<v t="zorcanda!.20051101193213" tnodeList="zorcanda!.20051101193213"><vh>@file-nosent BlockExample.py</vh></v>
<v t="orkman.20050222185810"><vh>raw material</vh>
<v t="ekr.20041017043622" a="E"><vh>autocompleter.py</vh>
<v t="ekr.20041017043622.26"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041017102904"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="mork.20041030091443"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="mork.20041020122041"><vh>&lt;&lt;load notes&gt;&gt;</vh></v>
<v t="mork.20041027154248"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="mork.20041029162412"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20041017100522"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="mork.20041020141804"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20041017043622.2"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20041017043622.3"><vh>watcher</vh></v>
<v t="ekr.20041017043622.4"><vh>scanText</vh></v>
<v t="ekr.20041017043622.5"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20041017043622.6"><vh>scanForCallTip</vh></v>
<v t="ekr.20041017043622.7"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20041017043622.8"><vh>_getCleanString</vh></v>
<v t="ekr.20041017043622.9"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20041017043622.10"><vh>initialScan</vh></v>
<v t="mork.20041105115626"><vh>has read config file meths</vh></v>
<v t="ekr.20041017043622.11"><vh>readConfigFile</vh></v>
<v t="mork.20041029160807"><vh>createConfigFile</vh></v>
<v t="ekr.20041017043622.12"><vh>readLanguageFiles</vh></v>
<v t="ekr.20041017043622.13"><vh>readOutline</vh></v>
<v t="ekr.20041017043622.14"><vh>reducer</vh></v>
<v t="ekr.20041017043622.15"><vh>unbind</vh></v>
<v t="mork.20041027103154"><vh>moveSelItem</vh></v>
<v t="mork.20041027103154.1"><vh>processKeyStroke</vh></v>
<v t="mork.20041023153836"><vh>testForUnbind</vh></v>
<v t="ekr.20041017043622.18"><vh>processAutoBox</vh></v>
<v t="mork.20041027103154.2"><vh>add_item</vh></v>
<v t="mork.20041020110810"><vh>add_bindings</vh></v>
<v t="ekr.20041017043622.21"><vh>configureAutoBox</vh></v>
<v t="ekr.20041017043622.23"><vh>calculatePlace</vh></v>
<v t="ekr.20041017043622.24"><vh>setLanguage</vh></v>
<v t="ekr.20041017043622.25" a="E"><vh>newCreateControl</vh></v>
<v t="mork.20041027100425"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20041017105122.2"><vh>onOpenWindow</vh></v>
</v>
<v t="mork.20041022155742.1" a="E"><vh>nodebar.py</vh>
<v t="mork.20041022160850"><vh>&lt;&lt;images&gt;&gt;</vh></v>
<v t="mork.20041023210407"><vh>&lt;&lt;images2&gt;&gt;</vh></v>
<v t="mork.20041023091529"><vh>&lt;&lt;version&gt;&gt;</vh></v>
<v t="mork.20041026092203"><vh>&lt;&lt;How To Configure&gt;&gt;</vh></v>
<v t="mork.20041026090227"><vh>determineFrame</vh></v>
<v t="mork.20041022160305" a="E"><vh>addNodeBar</vh>
<v t="mork.20041026100755"><vh>&lt;&lt; Create the help button &gt;&gt;</vh></v>
</v>
<v t="mork.20041022172156"><vh>add</vh></v>
<v t="mork.20041026083725"><vh>addBalloon</vh></v>
<v t="mork.20041022175619"><vh>view_help</vh></v>
<v t="mork.20041026084314"><vh>configureNodebar</vh></v>
<v t="mork.20041026084509"><vh>readConfigFile</vh></v>
<v t="mork.20041022160305.1"><vh>if load_ok:</vh></v>
</v>
<v t="orkman.20050213172714" a="E"><vh>leoNodes2.py</vh>
<v t="orkman.20050213172714.1"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="orkman.20050213172714.2"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="orkman.20050213172714.3" a="E"><vh>class tnode</vh>
<v t="orkman.20050213172714.4"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="orkman.20050213172714.5"><vh>t.__init__</vh></v>
<v t="orkman.20050213172714.6"><vh>t.__repr__ &amp; t.__str__</vh></v>
<v t="orkman.20050213172714.7"><vh>For undo</vh>
<v t="orkman.20050213172714.8"><vh>t.createUndoInfo</vh></v>
<v t="orkman.20050213172714.9"><vh>t.restoreUndoInfo</vh></v>
</v>
<v t="orkman.20050213172714.10" a="E"><vh>Getters</vh>
<v t="orkman.20050213172714.11"><vh>getBody</vh></v>
<v t="orkman.20050213172714.12"><vh>hasBody</vh></v>
<v t="orkman.20050213172714.13" a="E"><vh>Status bits</vh>
<v t="orkman.20050213172714.14"><vh>isDirty</vh></v>
<v t="orkman.20050213172714.15"><vh>isRichTextBit</vh></v>
<v t="orkman.20050213172714.16"><vh>isVisited</vh></v>
<v t="orkman.20050213172714.17"><vh>isWriteBit</vh></v>
</v>
</v>
<v t="orkman.20050213172714.18" a="E"><vh>Setters</vh>
<v t="orkman.20050213172714.19" a="E"><vh>Setting body text</vh>
<v t="orkman.20050213172714.20"><vh>setTnodeText</vh></v>
<v t="orkman.20050213172714.21"><vh>setSelection</vh></v>
</v>
<v t="orkman.20050213172714.22"><vh>Status bits</vh>
<v t="orkman.20050213172714.23"><vh>clearDirty</vh></v>
<v t="orkman.20050213172714.24"><vh>clearRichTextBit</vh></v>
<v t="orkman.20050213172714.25"><vh>clearVisited</vh></v>
<v t="orkman.20050213172714.26"><vh>clearWriteBit</vh></v>
<v t="orkman.20050213172714.27"><vh>setDirty</vh></v>
<v t="orkman.20050213172714.28"><vh>setRichTextBit</vh></v>
<v t="orkman.20050213172714.29"><vh>setVisited</vh></v>
<v t="orkman.20050213172714.30"><vh>setWriteBit</vh></v>
</v>
<v t="orkman.20050213172714.31"><vh>setCloneIndex (used in 3.x)</vh></v>
<v t="orkman.20050213172714.32"><vh>setFileIndex</vh></v>
</v>
</v>
<v t="orkman.20050213172714.33" a="E"><vh>class vnode</vh>
<v t="orkman.20050213172714.34"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="orkman.20050213172714.35" a="E"><vh>Birth &amp; death</vh>
<v t="orkman.20050213172714.36"><vh>v.__cmp__ (not used)</vh></v>
<v t="orkman.20050213172714.37" a="E"><vh>v.__init__</vh>
<v t="orkman.20050213172714.38"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="orkman.20050213172714.39"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="orkman.20050213172714.40"><vh>v.dump</vh></v>
</v>
<v t="orkman.20050213172714.41" a="E"><vh>v.Comparisons</vh>
<v t="orkman.20050213172714.42"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="orkman.20050213172714.43"><vh>anyAtFileNodeName</vh></v>
<v t="orkman.20050213172714.44"><vh>at...FileNodeName</vh></v>
<v t="orkman.20050213172714.45"><vh>isAtAllNode</vh></v>
<v t="orkman.20050213172714.46"><vh>isAnyAtFileNode good</vh></v>
<v t="orkman.20050213172714.47"><vh>isAt...FileNode</vh></v>
<v t="orkman.20050213172714.48"><vh>isAtIgnoreNode</vh></v>
<v t="orkman.20050213172714.49"><vh>isAtOthersNode</vh></v>
<v t="orkman.20050213172714.50"><vh>matchHeadline</vh></v>
</v>
<v t="orkman.20050213172714.51" a="E"><vh>Getters (vnode)</vh>
<v t="orkman.20050213172714.52" a="E"><vh>Tree Traversal getters</vh>
<v t="orkman.20050213172714.53"><vh>v.back</vh></v>
<v t="orkman.20050213172714.54"><vh>v.next</vh></v>
</v>
<v t="orkman.20050213172714.55"><vh>Children</vh>
<v t="orkman.20050213172714.56"><vh>v.childIndex</vh></v>
<v t="orkman.20050213172714.57"><vh>v.firstChild (changed for 4.2)</vh></v>
<v t="orkman.20050213172714.58"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="orkman.20050213172714.59"><vh>v.lastChild</vh></v>
<v t="orkman.20050213172714.60"><vh>v.nthChild</vh></v>
<v t="orkman.20050213172714.61"><vh>v.numberOfChildren (n)</vh></v>
</v>
<v t="orkman.20050213172714.62"><vh>Status Bits</vh>
<v t="orkman.20050213172714.63"><vh>v.isCloned (4.2)</vh></v>
<v t="orkman.20050213172714.64"><vh>isDirty</vh></v>
<v t="orkman.20050213172714.65"><vh>isExpanded</vh></v>
<v t="orkman.20050213172714.66"><vh>isMarked</vh></v>
<v t="orkman.20050213172714.67"><vh>isOrphan</vh></v>
<v t="orkman.20050213172714.68"><vh>isSelected</vh></v>
<v t="orkman.20050213172714.69"><vh>isTopBitSet</vh></v>
<v t="orkman.20050213172714.70"><vh>isVisited</vh></v>
<v t="orkman.20050213172714.71"><vh>status</vh></v>
</v>
<v t="orkman.20050213172714.72"><vh>v.bodyString</vh></v>
<v t="orkman.20050213172714.73"><vh>v.currentVnode (and c.currentPosition 4.2)</vh></v>
<v t="orkman.20050213172714.74"><vh>v.findRoot (4.2)</vh></v>
<v t="orkman.20050213172714.75"><vh>v.headString &amp; v.cleanHeadString</vh></v>
<v t="orkman.20050213172714.76"><vh>v.directParents (new method in 4.2)</vh></v>
</v>
<v t="orkman.20050213172714.77"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="orkman.20050213172714.78"><vh>v.insertAfter</vh></v>
<v t="orkman.20050213172714.79"><vh>v.insertAsNthChild</vh></v>
<v t="orkman.20050213172714.80"><vh>v.linkAfter</vh></v>
<v t="orkman.20050213172714.81"><vh>v.linkAsNthChild</vh></v>
<v t="orkman.20050213172714.82"><vh>v.linkAsRoot</vh></v>
<v t="orkman.20050213172714.83"><vh>v.moveToRoot</vh></v>
<v t="orkman.20050213172714.84"><vh>v.unlink</vh></v>
</v>
<v t="orkman.20050213172714.85" a="E"><vh>Setters</vh>
<v t="orkman.20050213172714.86"><vh> v.Status bits</vh>
<v t="orkman.20050213172714.87"><vh>clearClonedBit</vh></v>
<v t="orkman.20050213172714.88"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="orkman.20050213172714.89"><vh>clearMarked</vh></v>
<v t="orkman.20050213172714.90"><vh>clearOrphan</vh></v>
<v t="orkman.20050213172714.91"><vh>clearVisited</vh></v>
<v t="orkman.20050213172714.92"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="orkman.20050213172714.93"><vh>initStatus</vh></v>
<v t="orkman.20050213172714.94"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="orkman.20050213172714.95"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="orkman.20050213172714.96"><vh>setOrphan</vh></v>
<v t="orkman.20050213172714.97"><vh>setSelected (vnode)</vh></v>
<v t="orkman.20050213172714.98"><vh>t.setVisited</vh></v>
</v>
<v t="orkman.20050213172714.99"><vh>v.computeIcon &amp; setIcon</vh></v>
<v t="orkman.20050213172714.100"><vh>v.initHeadString</vh></v>
<v t="orkman.20050213172714.101"><vh>v.setSelection</vh></v>
<v t="orkman.20050213172714.102"><vh>v.setTnodeText</vh></v>
<v t="orkman.20050213172714.103"><vh>v.trimTrailingLines</vh></v>
</v>
<v t="orkman.20050213172714.104"><vh>For undo</vh>
<v t="orkman.20050213172714.105"><vh>v.createUndoInfo</vh></v>
<v t="orkman.20050213172714.106"><vh>v.restoreUndoInfo</vh></v>
</v>
<v t="orkman.20050213172714.107" a="E"><vh>v.Iterators</vh>
<v t="orkman.20050213172714.108"><vh>self_subtree_iter</vh></v>
<v t="orkman.20050213172714.109"><vh>unique_subtree_iter</vh></v>
</v>
</v>
<v t="orkman.20050213172714.110"><vh>class nodeIndices</vh>
<v t="orkman.20050213172714.111"><vh>nodeIndices.__init__</vh></v>
<v t="orkman.20050213172714.112"><vh>areEqual</vh></v>
<v t="orkman.20050213172714.113"><vh>get/setDefaultId</vh></v>
<v t="orkman.20050213172714.114"><vh>getNewIndex</vh></v>
<v t="orkman.20050213172714.115"><vh>isGnx</vh></v>
<v t="orkman.20050213172714.116"><vh>scanGnx</vh></v>
<v t="orkman.20050213172714.117"><vh>setTimeStamp</vh></v>
<v t="orkman.20050213172714.118"><vh>toString</vh></v>
</v>
<v t="orkman.20050213172714.119" a="E"><vh>class position</vh>
<v t="orkman.20050213172714.120"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="orkman.20050213172714.121" a="E"><vh> ctor &amp; other special methods...</vh>
<v t="orkman.20050213172714.122"><vh>p.__cmp__</vh></v>
<v t="orkman.20050213172714.123"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="orkman.20050213172714.124"><vh>p.__init__</vh></v>
<v t="orkman.20050213172714.125"><vh>p.__nonzero__</vh></v>
<v t="orkman.20050213172714.126"><vh>p.__str__ and p.__repr__</vh></v>
<v t="orkman.20050213172714.127"><vh>p.copy</vh></v>
<v t="orkman.20050213172714.128"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="orkman.20050213172714.129"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="orkman.20050213172714.130" a="E"><vh>TreeNode</vh>
<v t="orkman.20050213172714.131"><vh>children</vh></v>
<v t="orkman.20050213172714.132"><vh>getAllowsChildren</vh></v>
<v t="orkman.20050213172714.133"><vh>getChildAt</vh></v>
<v t="orkman.20050213172714.134"><vh>getChildCount</vh></v>
<v t="orkman.20050213172714.135"><vh>getIndex</vh></v>
<v t="orkman.20050213172714.136"><vh>getParent</vh></v>
<v t="orkman.20050213172714.137"><vh>isLeaf</vh></v>
</v>
<v t="orkman.20050213172714.138" a="E"><vh>Getters</vh>
<v t="orkman.20050213172714.139" a="E"><vh> vnode proxies</vh>
<v t="orkman.20050213172714.140"><vh>p.Comparisons</vh></v>
<v t="orkman.20050213172714.141"><vh>p.Extra Attributes</vh></v>
<v t="orkman.20050213172714.142"><vh>p.Headline &amp; body strings</vh></v>
<v t="orkman.20050213172714.143"><vh>p.Status bits</vh></v>
<v t="orkman.20050213172714.144"><vh>p.edit_text</vh></v>
<v t="orkman.20050213172714.145"><vh>p.directParents</vh></v>
<v t="orkman.20050213172714.146"><vh>p.childIndex</vh></v>
</v>
<v t="orkman.20050213172714.147" a="E"><vh>children</vh>
<v t="orkman.20050213172714.148"><vh>p.hasChildren</vh></v>
<v t="orkman.20050213172714.149"><vh>p.numberOfChildren</vh></v>
</v>
<v t="orkman.20050213172714.150"><vh>p.exists</vh></v>
<v t="orkman.20050213172714.151"><vh>p.findRoot</vh></v>
<v t="orkman.20050213172714.152"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="orkman.20050213172714.153"><vh>p.hasX</vh>
<v t="orkman.20050213172714.154"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="orkman.20050213172714.155"><vh>p.isAncestorOf</vh></v>
<v t="orkman.20050213172714.156"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="orkman.20050213172714.157"><vh>isCurrentPosition</vh></v>
<v t="orkman.20050213172714.158"><vh>isRootPosition</vh></v>
</v>
<v t="orkman.20050213172714.159"><vh>p.isCloned</vh></v>
<v t="orkman.20050213172714.160"><vh>p.isRoot</vh></v>
<v t="orkman.20050213172714.161"><vh>p.isVisible</vh></v>
<v t="orkman.20050213172714.162"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="orkman.20050213172714.163"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="orkman.20050213172714.164" a="E"><vh>Setters</vh>
<v t="orkman.20050213172714.165" a="E"><vh>vnode proxies</vh>
<v t="orkman.20050213172714.166"><vh> Status bits</vh></v>
<v t="orkman.20050213172714.167"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="orkman.20050213172714.168"><vh>p.setSelection</vh></v>
<v t="orkman.20050213172714.169"><vh>p.trimTrailingLines</vh></v>
<v t="orkman.20050213172714.170"><vh>p.setTnodeText</vh></v>
</v>
<v t="orkman.20050213172714.171" a="E"><vh>Head &amp; body text (position)</vh>
<v t="orkman.20050213172714.172"><vh>p.appendStringToBody</vh></v>
<v t="orkman.20050213172714.173"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="orkman.20050213172714.174"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="orkman.20050213172714.175"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="orkman.20050213172714.176"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="orkman.20050213172714.177" a="E"><vh>Visited bits</vh>
<v t="orkman.20050213172714.178"><vh>p.clearAllVisited</vh></v>
<v t="orkman.20050213172714.179"><vh>p.clearVisitedInTree</vh></v>
<v t="orkman.20050213172714.180"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="orkman.20050213172714.181" a="E"><vh>p.Dirty bits</vh>
<v t="orkman.20050213172714.182"><vh>p.clearDirty</vh></v>
<v t="orkman.20050213172714.183"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="orkman.20050213172714.184"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="orkman.20050213172714.185"><vh>p.setDirty</vh></v>
<v t="orkman.20050213172714.186"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="orkman.20050213172714.187"><vh>File Conversion</vh>
<v t="orkman.20050213172714.188"><vh>convertTreeToString</vh></v>
<v t="orkman.20050213172714.189"><vh>moreHead</vh></v>
<v t="orkman.20050213172714.190"><vh>moreBody</vh></v>
</v>
<v t="orkman.20050213172714.191" a="E"><vh>p.Iterators</vh>
<v t="orkman.20050213172714.192"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="orkman.20050213172714.193"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="orkman.20050213172714.194" a="E"><vh>p.allNodes_iter</vh>
<v t="orkman.20050213172714.195"><vh>__init__ &amp; __iter__</vh></v>
<v t="orkman.20050213172714.196"><vh>next</vh></v>
</v>
<v t="orkman.20050213172714.197"><vh>p.subtree_iter</vh>
<v t="orkman.20050213172714.198"><vh>__init__ &amp; __iter__</vh></v>
<v t="orkman.20050213172714.199"><vh>next</vh></v>
</v>
<v t="orkman.20050213172714.200" a="E"><vh>p.children_iter</vh>
<v t="orkman.20050213172714.201"><vh>__init__ &amp; __iter__</vh></v>
<v t="orkman.20050213172714.202"><vh>next</vh></v>
</v>
<v t="orkman.20050213172714.203" a="E"><vh>p.parents_iter</vh>
<v t="orkman.20050213172714.204"><vh>__init__ &amp; __iter__</vh></v>
<v t="orkman.20050213172714.205"><vh>next</vh></v>
</v>
<v t="orkman.20050213172714.206" a="E"><vh>p.siblings_iter</vh>
<v t="orkman.20050213172714.207"><vh>__init__ &amp; __iter__</vh></v>
<v t="orkman.20050213172714.208"><vh>next</vh></v>
</v>
</v>
<v t="orkman.20050213172714.209"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="orkman.20050213172714.210"><vh>p.doDelete</vh></v>
<v t="orkman.20050213172714.211"><vh>p.insertAfter</vh></v>
<v t="orkman.20050213172714.212"><vh>p.insertAsLastChild</vh></v>
<v t="orkman.20050213172714.213"><vh>p.insertAsNthChild</vh></v>
<v t="orkman.20050213172714.214"><vh>p.moveToRoot</vh></v>
<v t="orkman.20050213172714.215"><vh>p.clone</vh></v>
<v t="orkman.20050213172714.216"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="orkman.20050213172714.217"><vh>p.moveAfter</vh></v>
<v t="orkman.20050213172714.218"><vh>p.moveToLastChildOf</vh></v>
<v t="orkman.20050213172714.219"><vh>p.moveToNthChildOf</vh></v>
<v t="orkman.20050213172714.220"><vh>p.sortChildren</vh></v>
<v t="orkman.20050213172714.221"><vh>p.validateOutlineWithParent</vh>
<v t="orkman.20050213172714.222"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="orkman.20050213172714.223"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="orkman.20050213172714.224"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="orkman.20050213172714.225"><vh>p.invalidOutline</vh></v>
</v>
<v t="orkman.20050213172714.226" a="E"><vh>p.moveToX</vh>
<v t="orkman.20050213172714.227"><vh>p.moveToBack</vh></v>
<v t="orkman.20050213172714.228"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="orkman.20050213172714.229"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="orkman.20050213172714.230"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="orkman.20050213172714.231"><vh>p.moveToNext</vh></v>
<v t="orkman.20050213172714.232"><vh>p.moveToNodeAfterTree</vh></v>
<v t="orkman.20050213172714.233"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="orkman.20050213172714.234"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="orkman.20050213172714.235"><vh>p.moveToThreadBack</vh></v>
<v t="orkman.20050213172714.236"><vh>p.moveToThreadNext</vh></v>
<v t="orkman.20050213172714.237"><vh>p.moveToVisBack</vh></v>
<v t="orkman.20050213172714.238"><vh>p.moveToVisNext</vh></v>
</v>
<v t="orkman.20050213172714.239" a="E"><vh>p.utils...</vh>
<v t="orkman.20050213172714.240"><vh>p.vParentWithStack</vh>
<v t="orkman.20050213172714.241"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="orkman.20050213172714.242"><vh>p.restoreLinksInTree</vh></v>
<v t="orkman.20050213172714.243"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="orkman.20050213172714.244"><vh>p.deleteLinksInSubtree</vh></v>
<v t="orkman.20050213172714.245"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="orkman.20050213172714.246"><vh>p.Link/Unlink methods</vh>
<v t="orkman.20050213172714.247"><vh>p.linkAfter</vh></v>
<v t="orkman.20050213172714.248"><vh>p.linkAsNthChild</vh></v>
<v t="orkman.20050213172714.249"><vh>p.linkAsRoot</vh></v>
<v t="orkman.20050213172714.250"><vh>p.unlink</vh></v>
</v>
</v>
</v>
<v t="orkman.20050213172746" a="E"><vh>leo2.py </vh>
<v t="orkman.20050213172746.1"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="orkman.20050213172746.2" a="E"><vh>run &amp; allies</vh>
<v t="orkman.20050213172746.3"><vh>&lt;&lt; print encoding info &gt;&gt;</vh></v>
<v t="orkman.20050213172746.4"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="orkman.20050213172746.5"><vh>isValidPython</vh></v>
<v t="orkman.20050213172746.6"><vh>computeLoadDir</vh></v>
<v t="orkman.20050213172746.7"><vh>createFrame (leo.py)</vh></v>
<v t="orkman.20050213172746.8"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="orkman.20050213172746.9"><vh>getBatchScript</vh></v>
</v>
<v t="orkman.20050213172746.10"><vh>profile</vh></v>
</v>
<v t="mork.20041018091414.1"><vh>fastGotoNode.py</vh>
<v t="mork.20041018091414.2"><vh>&lt;&lt; fastGotoNode declarations &gt;&gt;</vh></v>
<v t="mork.20041018091414.3"><vh>disappear</vh></v>
<v t="mork.20041018091414.4"><vh>pop</vh></v>
<v t="mork.20041018091414.5"><vh>getSectionReferenceMenu</vh></v>
<v t="mork.20041018091414.6"><vh>getWindowMenu</vh></v>
<v t="mork.20041018091414.7"><vh>getChildrenMenu</vh></v>
<v t="mork.20041018091414.8"><vh>getSiblingsMenu</vh></v>
<v t="mork.20041018113134"><vh>getSiblingList</vh></v>
<v t="mork.20041018091414.9"><vh>getAncestorsMenu</vh></v>
<v t="mork.20041018114908"><vh>getAncestorList</vh></v>
<v t="mork.20041018091414.10"><vh>addLanguageMenu</vh></v>
<v t="mork.20041018120620"><vh>getMoveAMenu</vh></v>
<v t="mork.20041018120620.1"><vh>getMoveSMenu</vh></v>
<v t="mork.20041018091414.11"><vh>needsSeparator</vh></v>
<v t="mork.20041018091414.12"><vh>shouldBreak</vh></v>
<v t="mork.20041018091414.13"><vh>getDirectiveInsert</vh></v>
<v t="mork.20041018092814"><vh>getHeadlineMenu</vh></v>
<v t="mork.20041018095448"><vh>setFileDirective</vh></v>
<v t="mork.20041018100044"><vh>removeFileDirective</vh></v>
<v t="mork.20041018100044.1"><vh>getCleanHeadString</vh></v>
<v t="mork.20041018091414.14"><vh>addGL</vh></v>
<v t="mork.20041018091414.15"><vh>insertHeadline</vh></v>
<v t="mork.20041018091414.16"><vh>paster</vh></v>
<v t="mork.20041018091414.17"><vh>clear</vh></v>
<v t="mork.20041018091414.18"><vh>jumpto</vh></v>
<v t="mork.20041018091414.19"><vh>registerPopupMenu</vh></v>
<v t="mork.20041018091414.20"><vh>calculateMenuSize</vh></v>
<v t="mork.20041018091414.21"><vh>loadLanguages</vh></v>
</v>
<v t="orkman.20050216114307"><vh>testport.py</vh></v>
<v t="zorcanda!.20050325115459.1" a="E"><vh>chapters.py</vh>
<v t="zorcanda!.20050325115459.2"><vh>&lt;&lt; chapters declarations &gt;&gt;</vh></v>
<v t="zorcanda!.20050325115459.3"><vh>class Chapter</vh>
<v t="zorcanda!.20050325115459.4"><vh>&lt;&lt; class Chapter declarations &gt;&gt;</vh></v>
<v t="zorcanda!.20050325115459.5"><vh>__init__</vh></v>
<v t="zorcanda!.20050325115459.6"><vh>_saveInfo</vh></v>
<v t="zorcanda!.20050325115459.7"><vh>setVariables</vh></v>
<v t="zorcanda!.20050325115459.8"><vh>makeCurrent</vh></v>
</v>
<v t="zorcanda!.20050325115459.9"><vh>newCreateControl</vh></v>
<v t="zorcanda!.20050325115459.10"><vh>createPanedWidget</vh></v>
<v t="zorcanda!.20050325115459.11"><vh>newEditorPane</vh></v>
<v t="zorcanda!.20050325115459.12"><vh>newCreateCanvas</vh></v>
<v t="zorcanda!.20050325115459.13"><vh>createBalloon</vh></v>
<v t="zorcanda!.20050325115459.14"><vh>createNoteBook</vh></v>
<v t="zorcanda!.20050325115459.15"><vh>getNameMaker</vh></v>
<v t="zorcanda!.20050325115459.16"><vh>newTreeinit</vh></v>
<v t="zorcanda!.20050325115459.17"><vh>constructTree</vh></v>
<v t="zorcanda!.20050325115459.18"><vh>addPage</vh></v>
<v t="zorcanda!.20050325115459.19"><vh>newEditor</vh></v>
<v t="zorcanda!.20050325115459.20"><vh>makeTabMenu</vh></v>
<v t="zorcanda!.20050325115459.21"><vh>getAddChapter</vh></v>
<v t="zorcanda!.20050325115459.22"><vh>getRemove</vh></v>
<v t="zorcanda!.20050325115459.23"><vh>getRename</vh></v>
<v t="zorcanda!.20050325115459.24"><vh>getMakeTrash</vh></v>
<v t="zorcanda!.20050325115459.25"><vh>getSetupMenu</vh></v>
<v t="zorcanda!.20050325115459.26"><vh>selectNodeForEditor</vh></v>
<v t="zorcanda!.20050325115459.27"><vh>activateEditor</vh></v>
<v t="zorcanda!.20050325115459.28"><vh>removeEditor</vh></v>
<v t="zorcanda!.20050325115459.29"><vh>addHeading</vh></v>
<v t="zorcanda!.20050325115459.30"><vh>viewIndex</vh></v>
<v t="zorcanda!.20050325115459.31"><vh>buildIndex</vh></v>
<v t="zorcanda!.20050325115459.32"><vh>regexViewIndex</vh></v>
<v t="zorcanda!.20050325115459.33"><vh>renumber</vh></v>
<v t="zorcanda!.20050325115459.34"><vh>getGoodPage</vh></v>
<v t="zorcanda!.20050325115459.35"><vh>checkChapterValidity</vh></v>
<v t="zorcanda!.20050325115459.36"><vh>getSV</vh></v>
<v t="zorcanda!.20050325115459.37"><vh>setTree</vh></v>
<v t="zorcanda!.20050325115459.38"><vh>lowerPage</vh></v>
<v t="zorcanda!.20050325115459.39"><vh>walkChapters</vh></v>
<v t="zorcanda!.20050325115459.40"><vh>newGetLeoFile</vh></v>
<v t="zorcanda!.20050325115459.41"><vh>newOpen</vh></v>
<v t="zorcanda!.20050325115459.42"><vh>openChaptersFile</vh></v>
<v t="zorcanda!.20050325115459.43"><vh>insertChapters</vh></v>
<v t="zorcanda!.20050325115459.44"><vh>newWrite_LEO_file</vh></v>
<v t="zorcanda!.20050325115459.45"><vh>getMakeStringIO</vh></v>
<v t="zorcanda!.20050325115459.46"><vh>writeChapters</vh></v>
<v t="zorcanda!.20050325115459.47"><vh>zipChapters</vh></v>
<v t="zorcanda!.20050325115459.48"><vh>newos_path_dirname</vh></v>
<v t="zorcanda!.20050325115459.49"><vh>newendEditLabel</vh></v>
<v t="zorcanda!.20050325115459.50"><vh>newselect</vh></v>
<v t="zorcanda!.20050325115459.51"><vh>newTrashDelete</vh></v>
<v t="zorcanda!.20050325115459.52"><vh>cloneToChapter</vh></v>
<v t="zorcanda!.20050325115459.53"><vh>moveToChapter</vh></v>
<v t="zorcanda!.20050325115459.54"><vh>copyToChapter</vh></v>
<v t="zorcanda!.20050325115459.55"><vh>makeNodeIntoChapter</vh></v>
<v t="zorcanda!.20050325115459.56"><vh>conversionToSimple</vh></v>
<v t="zorcanda!.20050325115459.57"><vh>conversionToChapters</vh></v>
<v t="zorcanda!.20050325115459.58"><vh>importLeoFile</vh></v>
<v t="zorcanda!.20050325115459.59"><vh>exportLeoFile</vh></v>
<v t="zorcanda!.20050325115459.60"><vh>swapChapters</vh></v>
<v t="zorcanda!.20050325115459.61"><vh>emptyTrash</vh></v>
<v t="zorcanda!.20050325115459.62"><vh>regexClone</vh></v>
<v t="zorcanda!.20050325115459.63"><vh>doPDFConversion</vh></v>
<v t="zorcanda!.20050325115459.64"><vh>_changeTreeToPDF</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20041017043622"> 
 """
autocompletion and calltips plugin.  Special characters:

. summons the autocompletion.  
( summons the calltips
Escape closes either box.
Ctrl selects an item.
alt-up_arrow, alt-down_arrow moves up or down in the list.  The mouse will work for this as well.
This plugin scans the complete outline at startup..

You many enable or disable features in autocomplete.ini( see configuration section ).
"""

@language python 
@tabwidth-4

&lt;&lt;imports&gt;&gt;
__version__ = ".72"
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;load notes&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;
useauto = 1 #These two global determine if the autocompleter and calltip systems are used.  Default is on.
usecall = 1
&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others

if Pmw and Tk and weakref:

    leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
    leoPlugins.registerHandler(('start2','open2'),initialScan)   
    g.plugin_signon(__name__)
    

</t>
<t tx="ekr.20041017043622.2">#This section defines patterns for calltip recognition.  The autocompleter does not use regexes.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats['python'] = re.compile(r'def\s+%s' % end)

pats['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % ( space, space, end ) )
    
pats['perl'] = re.compile(r'sub\s+%s' % end)

pats['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' %( space, end ))

pats['c'] = re.compile(r'\w+%s%s' % ( space ,end ))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits+string.letters+r 

ripout = string.punctuation+string.whitespace+'\n'
ripout = ripout.replace('_','')

okchars ={}
for z in string.ascii_letters:
    okchars[z] = z 
okchars['_'] = '_'</t>
<t tx="ekr.20041017043622.3">watchitems = ( '.',')' )
txt_template = '%s%s%s'
def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    global lang 
    if event.char.isspace() or event.char in watchitems:
        bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        if event.char.isspace():
            if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
            if bCtrl.get( 'insert -1c wordstart -1c') != '.': return
            
        c = bCtrl.commander
        lang = c.frame.body.getColorizer().language 
        txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
                             event.char, 
                             bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet

        scanText(txt)
    
</t>
<t tx="ekr.20041017043622.4">def scanText (txt):
    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)
</t>
<t tx="ekr.20041017043622.5">def scanForAutoCompleter (txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!</t>
<t tx="ekr.20041017043622.6">def scanForCallTip (txt):
    '''this function scans text for calltip info'''
    pat2 = pats['python']
    if lang!=None:
        if pats.has_key(lang):
            pat2 = pats[lang]
    g2 = pat2.findall(txt)
    if g2:
        for z in g2:
            if isinstance(z,tuple):
                z = z[0]
            pieces2 = z.split('(')
            pieces2[0] = pieces2[0].split()[-1]
            a, b = pieces2[0], pieces2[1]
            calltips[ lang ][ a ].add( z ) #we are using the experimental DictSet here, usage removed all of the commented code. notice we have cut all this down to one line of code!
            #if calltips.has_key(lang):
            #    if calltips[lang].has_key(a):
            #        calltips[lang][a].add(z)
            #    else:
            #        calltips[lang][a] = sets.Set([z]) 
            #else:
            #    calltips[lang] ={}
            #    calltips[lang][a] = sets.Set([z])        </t>
<t tx="ekr.20041017043622.7">def makeAutocompletionList (a,b,glist):
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 
</t>
<t tx="ekr.20041017043622.8">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20041017043622.9">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20041017043622.10">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")or keywords.get("new_c")
    if haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()


</t>
<t tx="ekr.20041017043622.11">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20041017043622.12">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20041017043622.13">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20041017043622.14">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20041017043622.15">def unbind ( context ):
    '''This method turns everything off and removes the calltip and autobox from the canvas.'''
    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map( context.unbind, ( "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;" , "&lt;Alt_R&gt;" ) )
        context.unbind_all( '&lt;Button&gt;' )
        context.update_idletasks()</t>
<t tx="ekr.20041017043622.18">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20041017043622.21">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20041017043622.23">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20041017043622.24">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20041017043622.25">def newCreateControl (self,frame,parentFrame):
    '''This def is a decoration of the createControl def.  We set up the ancestory of the control so we can draw
       Widgets over the Text editor without disturbing the text.'''
    #creating background
    #We have moved to using the placer, this is simpler to use and more efficient.  We have to decorate the Tk.Text
    #widget with a constructor that creates an intermediate Frame for the Text to be placed instead of packed.  Had no
    #idea that the placer could do this so nicely.  With a couple changes in 3 places, we are using the placer!
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init( self, master, *args, **kwords ):
        
        context = Tk.Frame( master ) #This is what we need to put in before the text to make place work.
        orig_init( self, context, *args, **kwords )
    
    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame, parentFrame )#orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init
    
    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack( expand = 1, fill = 'both', after = frame.bodyBar )  #We have to add it to the environment, since we pass on it in the __init__   
    body.place( relwidth = 1.0, relheight = 1.0 )
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets( context )
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler( event, context= context, body = body ): 
        processKeyStroke( event, context, body )
    def addItemHandler( event, context = context, body = body, colorizer = frame.body ): 
        add_item( event, context, body, colorizer.getColorizer() )
                
    for z in ( watcher, processKeyStrokeHandler, addItemHandler ):
        context.bind( "&lt;Key&gt;", z, '+' )
    
    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr( context, 'autobox' ):
        ignore.append(  context.autobox.component( 'listbox' ) )
        ignore.append( context.autobox.component( 'vertscrollbar' ) )
    def do_unbind( event ):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''            
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind( context )

    context.do_unbind = do_unbind
    
    #This part protects this plugin from others that use Alt-Up, Alt-Down, an example being temacs.py
    #The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt( event ):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ( '&lt;Alt-Up&gt;', '&lt;Alt-Down&gt;' ): context.block_alt.bind( z, block_alt ) 
    
    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append( context.bindtags()[ 0 ] )
    ctags.append( context.block_alt.bindtags()[ 0 ] )
    ctags.extend( body.bindtags() ) 
    body.bindtags( tuple( ctags ))
    
    return body  







</t>
<t tx="ekr.20041017043622.26">import leoGlobals as g 
import leoPlugins 
import leoTkinterFrame 

import leoColor 
import ConfigParser 
import os
import os.path  

import re 
import sets 
import string 
import threading 

try:
    import Pmw 
except ImportError:
    Pmw = g.cantImport("Pmw",__name__)

try:
    import Tkinter as Tk 
except ImportError:
    Tk = g.cantImport("Tk",__name__)
    
try:
    import weakref 
except ImportError:
    weakref = g.cantImport("weakref",__name__)</t>
<t tx="ekr.20041017100522">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20041017102904">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
 .71
    investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
    1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
    2. There is a global flag indicating whether the config file needs to be read again.
    3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
    4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
    5. Moved createConfig part out of thread.
    problems seems centered on Windows/IO/Threading.
 .72
    The thesis and experiments to confirm the problem identified in .71 appear completely wrong.  I could not recreate
    threading+writeIO staling on XP at all.  Windows 98 didnt even work.  But after commenting out g.es calls it did work.
    My new target for the problem is now focused on keeping g.es calls out of the initialScan thread.  This will just entail
    moving all the reading and writing of the config and language files out of the thread.</t>
<t tx="ekr.20041017105122.2">def onOpenWindow ():
    #what does this do?
    c = keywords.get("c")or keywords.get("new_c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="mork.20041018091414.1">
@language python
&lt;&lt; fastGotoNode declarations &gt;&gt;
@others
            
   


if 1:
    calculateMenuSize()
    registerHandler( ('start2' , 'open2', 'new') , registerPopupMenu )
    __version__ = ".99"
    plugin_signon(__name__)
    pth = os.path.split( app.loadDir )
    lkpm = pth[ 0 ] + r"/plugins/fgn.fgn" 
    if os.path.exists( lkpm ):
        loadLanguages( lkpm )


















</t>
<t tx="mork.20041018091414.2">''' A Leo plugin that adds quick Utility commands through a pop-up menu.  To summon Menu,
Control - Space must be typed. To Unsummon, Right Click.  It offers 3 main feature sets:
1. Movement.  If a node has ancestors,siblings or children a menu option will appear offering the
user the ability to jump to the node from the current node.  This is an improvement over moving one node at a time with the keyboard commands. 2. Inserting text.  These menus offer the current language keywords, the directives the body recognizes and any @file type headline directives.  It offers the new user easy access to the different directives and ways to write a file. 3. Moving Nodes( experimental feature ).  You can quickly move a node to its parent's parent or after a sibling, if they exist.'''
from leoPlugins import *
from leoGlobals import *  
from leoNodes import *  
import Tkinter
import tkFileDialog
import os 


</t>
<t tx="mork.20041018091414.3">smenu = Tkinter.Menu( tearoff = 0, activeforeground = 'blue' , activebackground = 'white')   
maxmenu = 0
menus = []



def disappear( event , c):
    smenu.unpost()
    smenu.unbind_all("&lt;Button-3&gt;") 
    c.frame.body.bodyCtrl.focus_set()
</t>
<t tx="mork.20041018091414.4">lastwidg = None
def pop( event , c ):
    clear()    
    needs_sep = needsSeparator( smenu )
    
    def addMenu( label , menu ):
        menus.append( menu )
        needs_sep.next()
        smenu.add_cascade( label = label, menu = menu )
        menu.configure( activeforeground = 'blue', activebackground = 'white' )
        def em( event ): 
            smenu.focus_set()
        menu.bind( '&lt;Expose&gt;', em ) 

    smenu.bind('&lt;Left&gt;', lambda event, c = c: disappear( event, c ) )
 
              
    ancmenu = getAncestorsMenu( smenu, c )
    if ancmenu:
        addMenu( 'Ancestors', ancmenu )
        
    sibmenu = getSiblingsMenu( smenu, c )
    if sibmenu:
        addMenu( 'Siblings', sibmenu )
        
    chimenu = getChildrenMenu( smenu, c )
    if chimenu:
        addMenu( 'Children', chimenu )
         
    winmenu = getWindowMenu( smenu, c )
    if winmenu:
        addMenu( 'Windows', winmenu )
                
    srmenu = getSectionReferenceMenu( smenu, c ) 
    if srmenu:
        addMenu( 'Insert '+ '&lt;' +'&lt; '+'&gt;'+'&gt;' , srmenu ) 
    
    menu , language = addLanguageMenu( smenu , c )
    if menu:
        addMenu( language, menu )
         
    dimenu = getDirectiveInsert( smenu, c )
    addMenu( 'Directives', dimenu ) 
    
    hmenu = getHeadlineMenu( smenu, c )
    addMenu( 'Headline', hmenu )
    
    mvamenu = getMoveAMenu( smenu, c )
    if mvamenu: addMenu( "Mv_Ancestor", mvamenu )
    
    mvsmenu = getMoveSMenu( smenu, c )
    if mvsmenu: addMenu( "Mv_Sibling", mvsmenu )
    

    smenu.bind_all("&lt;Button-3&gt;", lambda event, c = c :disappear( event, c )  ) 
    smenu.post( event.x_root , event.y_root)
    smenu.focus_set()
     
</t>
<t tx="mork.20041018091414.5">def getSectionReferenceMenu( pmenu, c ):
    pos = c.currentPosition()
    nc = pos.numberOfChildren()
    import re
    reg = re.compile( "^&lt;"+"&lt;.+?&gt;"+"&gt;$")
    srefs = []
    for z in xrange( nc ):
        chi = pos.nthChild( z )
        hl = chi.headString()
        if reg.match( hl ):
            srefs.append( hl )
    
    srmenu = None       
    if len( srefs ):
        srefs.sort() 
        srmenu = Tkinter.Menu( pmenu, tearoff= 0 )
        sb = shouldBreak()
        for z in srefs:
            srmenu.add_command( 
                label = z , 
                command = lambda label = z ,c = c :
                paster( label , c , ''), columnbreak = sb.next() )
                
    return srmenu
</t>
<t tx="mork.20041018091414.6">def getWindowMenu( pmenu , c ):
    import copy
    wl = copy.copy( windows() )
    wl.remove( c.frame )
    winmenu = None
    if len( wl ) != 0:
        winmenu = Tkinter.Menu( pmenu, tearoff = 0 )
        def bTF( frame ):
            frame.bringToFront()
            app.setLog( frame.log )
            frame.bodyCtrl.focus_set()
            clear()
        sb = shouldBreak()
        for z in wl:
            winmenu.add_command( 
                label = z.getTitle(), 
                command = lambda frame = z: bTF( frame ) , 
                columnbreak = sb.next() )
    return winmenu
</t>
<t tx="mork.20041018091414.7">def getChildrenMenu( pmenu, c ):
    pos = c.currentPosition()
    nchildren = pos.numberOfChildren()
    chimenu = None
    if nchildren &gt; 0 :
        chimenu = Tkinter.Menu( pmenu, tearoff = 0 ) 
        sb = shouldBreak() 
        childnames = []
        children = {}
        for z in xrange( pos.numberOfChildren() ):
            child = pos.nthChild( z )
            hs = child.headString()
            childnames.append( hs )
            children[ hs ] = child
        childnames.sort()
        def adder( a ):
            hs = a
            child = children[ hs ]
            chimenu.add_command( 
                label = hs , 
                command = lambda pos = child, c = c:
                jumpto(pos , c ) , 
                columnbreak = sb.next() )
        map( adder, childnames )        
    return chimenu
</t>
<t tx="mork.20041018091414.8">def getSiblingsMenu( pmenu, c ):
    siblings = []
    pos = c.currentPosition()
    siblings = getSiblingList( pos)
    sibmenu = None
    def sorSibs( a, b ):
        if a.headString() &gt; b.headString() : return 1
        elif a.headString() &lt; b.headString() : return -1
        return 0
    siblings.sort( sorSibs )
    if len( siblings ) != 0:        
        sibmenu = Tkinter.Menu(pmenu, tearoff = 0)  
        sb = shouldBreak()
        for z in siblings:
            hs = z.headString()
            sibmenu.add_command( 
                label = hs , 
                command = lambda pos = z, c = c:
                jumpto( pos, c ) , 
                columnbreak = sb.next() )
                
    return sibmenu    
</t>
<t tx="mork.20041018091414.9">def getAncestorsMenu( pmenu, c ):
        ancmenu = None
        alist = getAncestorList( c.currentPosition() )
        if alist:
            ancmenu = Tkinter.Menu( pmenu, tearoff = 0 )
            sb = shouldBreak()
            for z in alist:
                hs = z.headString()
                ancmenu.add_command( 
                    label = hs , 
                    command = lambda  parent = z, c = c: 
                    jumpto( parent , c ), 
                    columnbreak = sb.next() )

        return ancmenu
</t>
<t tx="mork.20041018091414.10">def addLanguageMenu( pmenu , c , haveseen = {}):
    colorizer = c.frame.body.getColorizer()
    if colorizer.language:
        if not haveseen.has_key( colorizer.language ): 
            lk = colorizer.language + '_keywords'
            kwords = list( getattr( colorizer , lk ) )
            if langdict.has_key( colorizer.language ):
                l = langdict[ colorizer.language ]
                for z in l:
                    kwords.append( z )
                kwords.sort()
        else:
            kwords = haveseen[ colorizer.language ] 
        lmenu = Tkinter.Menu( pmenu, tearoff = 0 ) 
        sb = shouldBreak()
        for z in kwords:
            lmenu.add_command( 
                label = z , 
                command = lambda keyword = z , c = c : 
                paster( keyword , c ) ,
                columnbreak = sb.next() )
                
        return lmenu , colorizer.language
    else: return None , None
</t>
<t tx="mork.20041018091414.11">def needsSeparator( menu ):
    yield None
    while 1:
        menu.add_separator()
        yield None
</t>
<t tx="mork.20041018091414.12">def shouldBreak():
    i = 0
    while 1:
        i += 1
        if i == maxmenu:
            i = 0
            yield True
        else: yield False
</t>
<t tx="mork.20041018091414.13">def getDirectiveInsert( pm, c , directives = [], directives2= []):
    m = Tkinter.Menu( pm, tearoff = 0 )
    sb = shouldBreak()
    if len( directives ) == 0:
        import leoColor 
        for z in leoColor.leoKeywords:
            directives.append( z )
        directives.sort()                                      
    for z in directives:
       m.add_command( 
          label = z , 
          columnbreak = sb.next(),  
          command = lambda label = z, c = c: 
          paster( label , c ) )

    return m
</t>
<t tx="mork.20041018091414.14">def addGL( c ):
    vnode = c.currentVnode()
    hs = vnode.headString()
    nhs = "&lt;"+"&lt;" + hs + "&gt;"+"&gt;"
    c.beginUpdate()
    vnode.setHeadString( nhs )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()

</t>
<t tx="mork.20041018091414.15">def insertHeadline( directive , c ):
    vnode = c.currentVnode()
    hs = vnode.headString()
    nhs = directive + " " + hs
    c.beginUpdate()
    vnode.setHeadString( nhs )
    c.endUpdate()
</t>
<t tx="mork.20041018091414.16">def paster( directive , c ,  end = ' ' ):
    bdy = c.frame.body
    c.beginUpdate()
    bdy.insertAtInsertPoint( directive + end)
    bdy.onBodyChanged( c.currentVnode() , None ) 
    bdy.bodyCtrl.focus_set()  
    bdy.bodyCtrl.update_idletasks() 
    c.endUpdate()                        
    bdy.bodyCtrl.focus_set()</t>
<t tx="mork.20041018091414.17">def clear():
    global menus
    smenu.delete( 0 , Tkinter.END )
    for z in menus:
        z.destroy()
    menus = []
</t>
<t tx="mork.20041018091414.18">def jumpto( vnode, c):    
    smenu.unpost()
    c.beginUpdate()
    c.frame.tree.expandAllAncestors( vnode )
    c.selectVnode( vnode )
    c.endUpdate()
</t>
<t tx="mork.20041018091414.19">def registerPopupMenu( tag, keywords):
    c = top()
    def popper( event , c = c ):
        pop( event, c )
    c.frame.top.bind( binder , popper)
</t>
<t tx="mork.20041018091414.20">def calculateMenuSize():
    global maxmenu
    x = Tkinter.Menu()
    h = ( x.winfo_screenheight() *.90 ) / 25
    maxmenu = int( h )
    x.destroy()
</t>
<t tx="mork.20041018091414.21">langdict = {}  
binder = '&lt;Control-space&gt;' 
def loadLanguages( lkpm):
    global binder
    import ConfigParser
    cp = ConfigParser.ConfigParser()
    cp.read( lkpm )
    which = ''
    sec = cp.sections()
    for z in sec:
        if z.strip() == 'language':
            which = z
            break
    if cp.has_section( which ):
        op = cp.options( which )
        for z in op:
            z2 = cp.get( which, z ).split(',')
            z2 = [ x.strip() for x in z2 ]
            langdict[ z ] = z2
    for z in sec:
        if z.strip() == 'fgnconfig':
            which2 = z
            break
    if cp.has_section( which2 ):
        op2 = cp.options( which2 )
        for z2 in op2:
            if z2.strip() == 'binder':
                binder = cp.get( which2, z2 )
                break
</t>
<t tx="mork.20041018092814">def getHeadlineMenu( pmenu, c ):
    
    pos = c.currentPosition()
    v = pos.v
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    names.sort()
    hmenu = Tkinter.Menu( pmenu , tearoff = 0)
    hmenu.add_command( 
        label = 'add &lt;'+'&lt;'+'&gt;'+'&gt;', 
        command = lambda c = c: addGL( c ) )
    hmenu.add_separator()
    for z in names:
        hmenu.add_command( label = z, 
                            command = lambda c = c, d = z , nm = names:
                                setFileDirective( c, d, nm ) )
    hmenu.add_separator()
    hmenu.add_command( label = 'remove @', command = lambda c = c, nm = names:
                                            removeFileDirective( c, nm ) )
    return hmenu

</t>
<t tx="mork.20041018095448">def setFileDirective( c , directive, names ):
    
    pos = c.currentPosition()
    hS = pos.headString()
    hS = getCleanHeadString( hS, names )
    hS = directive + " " + hS
    c.beginUpdate()
    pos.setHeadString( hS )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()
    
   

</t>
<t tx="mork.20041018100044">def removeFileDirective( c , names ):

    pos = c.currentPosition()
    hS = pos.headString()
    hS = getCleanHeadString( hS , names )
    c.beginUpdate()
    pos.setHeadString( hS )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()
</t>
<t tx="mork.20041018100044.1">def getCleanHeadString( hS, names ):

    def sT( a, b ):
        if len( a ) &gt; len( b ): return -1
        if len( a ) &lt; len( b ): return 1
        return 0
    names = list( names )
    names.sort( sT )
    for z in names:
        hS2 = hS.lstrip()
        if hS2.startswith( z ):
            hS = hS2.lstrip( z )
            hS = hS.lstrip()
            return hS
    return hS</t>
<t tx="mork.20041018113134">def getSiblingList( pos ):
    
    siblings = []
    pnod = pos.back()
    while pnod:
        siblings.append( pnod )
        pnod = pnod.back()
    siblings.reverse()
    nnod = pos.next()
    while nnod:
        siblings.append( nnod )
        nnod = nnod.next()
    return siblings</t>
<t tx="mork.20041018114908">def getAncestorList( p ):
    
    alist = []
    parent = p.parent()
    while parent:
        alist.append( parent )        
        parent = parent.parent()
    return alist</t>
<t tx="mork.20041018120620">def getMoveAMenu( pmenu, c ):
    
    mvmenu = None

    def mvchild( p, p2 , c = c ):
        c.beginUpdate()
        p.moveToNthChildOf( p2, 0 )
        c.endUpdate()
        
    pos = c.currentPosition()
    alist = getAncestorList( pos )
    if alist: alist.pop( 0 )
    if alist:
        mvmenu = Tkinter.Menu( pmenu, tearoff = 0 )
        sb = shouldBreak()
        for z in alist:    
            hs = z.headString()
            mvmenu.add_command( 
                label = hs , 
                command = lambda p = pos, p2 = z: 
                mvchild( p, p2 ),
                columnbreak = sb.next() )
    return mvmenu
</t>
<t tx="mork.20041018120620.1">def getMoveSMenu( pmenu , c):
    
    smenu = None
    pos = c.currentPosition()
    sibs = getSiblingList( pos )
    bk = pos.back()
    if bk: sibs.remove( bk )
    def mafter( p, p2, c = c ):
        c.beginUpdate()
        p.moveAfter( p2 )
        c.endUpdate()
    if sibs:
        smenu = Tkinter.Menu( pmenu, tearoff = 0 )
        sb = shouldBreak()
        for z in sibs:
            smenu.add_command( label = z.headString(), 
                            command = lambda p = pos, p2 = z: mafter( p, p2 ),
                            columnbreak = sb.next() ) 

    return smenu</t>
<t tx="mork.20041020110810">def add_bindings( context, body ):
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )

</t>
<t tx="mork.20041020122041">@ 

switching to the placer appears to have gotten rid of this dependency

--no longer true---
Autocompleter needs to be loaded before Chapters/chapters or the autobox and the calltip label do
not appear in the correct place.
--no longer true---


@c 
</t>
<t tx="mork.20041020141804">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory= set ):# factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
   
</t>
<t tx="mork.20041022155742.1">'''nodebar adds buttons at the bottom of the tree canvas.
The buttons correspond to commands found in the Outline commands.
It is intended to speed up a new users ability to use the outline.  
Experienced users may find value in being able to quickly execute commands they do not use very often'''
import leoGlobals as g
import leoPlugins
     
load_ok=True
try:
    import Pmw
    import weakref
    import Tkinter as Tk
    import ConfigParser
    import os.path
except Exception, x:
    g.es( 'Could not load because of %s' % x )
    load_ok = False
    
&lt;&lt;images&gt;&gt;
&lt;&lt;images2&gt;&gt;

&lt;&lt;version&gt;&gt;

&lt;&lt;How To Configure&gt;&gt;

@others</t>
<t tx="mork.20041022160305">haveseen = weakref.WeakKeyDictionary()
def addNodeBar( tag, keywords ):
    '''Add nodebar to new frame'''
    c = keywords.get( 'c' ) or keywords.get( 'new_c' )
    if not c:
        return
    if haveseen.has_key( c ):
        return
    haveseen[ c ] = None
    
    frame = determineFrame( c )
    mbox = Tk.Frame( frame )
    mbox.pack( side = 'bottom' , fill = 'x' )
    for z in frame.children.values():
        mbox.pack_configure( before = z )
        
    def goToChild( c = c ):
        
        pos = c.currentPosition()
        if pos.hasChildren():
            c.selectPosition( pos.nthChild( 0 ) )
            
    bcommands = ( 
                  ( c.moveOutlineUp, nodeupPI, 'Move Node Up' ),
                  ( c.moveOutlineDown, nodedownPI , 'Move Node Down' ),
                  ( c.moveOutlineLeft, nodeleftPI , 'Move Node Left' ),
                  ( c.moveOutlineRight, noderightPI, 'Move Node Right' ),
                  ( c.clone, clonePI , 'Clone Node' ),
                  ( c.copyOutline, copyPI, 'Copy Node' ),
                  ( c.cutOutline, cutPI, 'Cut Node' ),
                  ( c.deleteOutline, deletePI, 'Delete Node' ),
                  ( c.pasteOutline, pastePI , 'Paste Node' ),
                  ( c.pasteOutlineRetainingClones, pasteclonePI, 'Paste Retaining Clones' ),
                  ( c.insertHeadline, insertPI, 'Insert Node' ),
                  ( c.demote, demotePI, 'Demote' ),
                  ( c.promote, promotePI , 'Promote' ) ,
                  ( c.hoist, hoistPI, 'Hoist'),
                  ( c.dehoist, dehoistPI, 'De-Hoist' ),
                  ( c.sortChildren, sortchildrenPI, 'Sort Children' ),
                  ( c.sortSiblings, sortsiblingsPI, 'Sort Siblings' ),
                  ( c.goToPrevSibling, moveupPI, 'Goto Previous Sibling' ),
                  ( c.goToNextSibling, movedownPI, 'Goto Next Sibling' ),
                  ( c.goToParent, moveleftPI, 'Goto Parent' ),
                  ( goToChild, moverightPI, 'Goto Child' ),
                  )
    for i, z in enumerate( bcommands ):
        add( c, mbox ,i, *z )       
    
    if config[ qhelp ] != '0': 
        &lt;&lt; Create the help button &gt;&gt;












</t>
<t tx="mork.20041022160305.1">if load_ok:
    
    configureNodebar()
    if g.app.gui is None: 
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        leoPlugins.registerHandler( ('start2' , 'open2', "new") , addNodeBar )
        __version__ = '.5'
        g.plugin_signon( __name__ )
 
    
</t>
<t tx="mork.20041022160850">
nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''

nodeupPI = Tk.PhotoImage( data = nodeup )

nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''

nodedownPI = Tk.PhotoImage( data = nodedown )

nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''

nodeleftPI = Tk.PhotoImage( data = nodeleft )

noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''

noderightPI = Tk.PhotoImage( data = noderight )

clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''

clonePI = Tk.PhotoImage( data = clone )


copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''

copyPI = Tk.PhotoImage( data = copy )

cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''

cutPI = Tk.PhotoImage( data = cut )


paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''

pastePI = Tk.PhotoImage( data = paste )


insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''

insertPI = Tk.PhotoImage( data = insert )

demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''

demotePI = Tk.PhotoImage( data = demote )

promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''

promotePI = Tk.PhotoImage( data = promote )

pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''

pasteclonePI = Tk.PhotoImage( data = pasteclone )

hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''

hoistPI = Tk.PhotoImage( data = hoist )

dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''

dehoistPI = Tk.PhotoImage( data = dehoist )

question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''

sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''

sortchildrenPI = Tk.PhotoImage( data = sortchildren )

sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''

sortsiblingsPI = Tk.PhotoImage( data = sortsiblings )

questionPI = Tk.PhotoImage( data = question )

delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''

deletePI = Tk.PhotoImage( data = delete )

</t>
<t tx="mork.20041022172156">def add( c, frame, column, command, image, text ):
    '''Add a button to the nodebar'''
    b = Tk.Button( frame, command = command , image = image )
    b[ 'width' ] = image[ 'width' ]
    b[ 'height' ] = image[ 'height' ]
    b[ 'padx' ] = 0
    b[ 'pady' ] = 0
    b.grid( column = column , row = 1)
    if int( config[ help ] ):
        addBalloon( frame, b, text )
    
    def callback(event,c=c,s=text):
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s)
    
    b.bind("&lt;Enter&gt;",callback, '+' )</t>
<t tx="mork.20041022175619">def view_help( c, items ):
    '''Opens the Help dialog up for the user to view'''
    dialog = Pmw.Dialog( c.frame.top, title = 'Button Help' )
    sf = Pmw.ScrolledFrame( dialog.interior() )
    
    sf.pack()
    sfi = sf.interior()
    
    for z in items:
        lw = Pmw.LabeledWidget( sfi , labelpos = 'e', label_text = z[ 2 ] )
        l = Tk.Button( lw.interior() , image = z[ 1 ] )
        lw.pack()
        l.pack()
        
    dialog.activate()

</t>
<t tx="mork.20041023091529">@


.1 made initial icons

.15 eliminated most of the letter icons, made them node based icons.

.2 EKR:
    - Fixed hang when help dialog selected.
    - Write help string to status area on mouse over.
    - Added test for if g.app.gui.guiName() == "tkinter"

.25 added movement arrows.  These contrast with the move node arrows by being empty and on the other side of the nodebar.  A user may be able to do all the manipulations he needs of the outline at this point.  Note:  the bar is of such a size we may need to add some kind of scrolling mechanism.  Not sure if I like the hoist and dehoist icons yet. ????

--tried out scrollbar idea, what a terrible idea.  The user is just going to have to have a big enough screen to use it. :D

.3 Added balloon help.  Should help new users.  Added .config file machinery</t>
<t tx="mork.20041023153836">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="mork.20041023210407">moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''

moveupPI = Tk.PhotoImage( data = moveup )

movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''

movedownPI = Tk.PhotoImage( data = movedown )

moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''

moveleftPI = Tk.PhotoImage( data = moveleft )

moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''

moverightPI = Tk.PhotoImage( data = moveright )</t>
<t tx="mork.20041026083725">balloons = {}
def addBalloon( frame, widget, text ):
    '''Help ballon is added to a frame and text is bound to a specific widget'''
    if not balloons.has_key( frame ):
        balloons[ frame ] = Pmw.Balloon( frame )
    
    
    balloon = balloons[ frame ]
    balloon.bind( widget, text )</t>
<t tx="mork.20041026084314">config = {}
pos = 'position'
help = 'usehelp'
qhelp = 'qhelp'
config[ pos ] = '1' #The default is to put the bar in the icon area
config[ help ] = '1' #The default is to see the help buttons
def configureNodebar():
    '''nodebar reads what the config file has in it and sets global state'''
    nbar = 'nodebar'
    cparser = readConfigFile()
    if not cparser: return None
    for z in cparser.sections():
        if z.strip() == nbar:
            nbar = z
            break
    if cparser.has_section( nbar ):
        if cparser.has_option( nbar, pos ):
            p = cparser.get( nbar, pos )
            if p.isdigit():
                config[ pos ] = p
            else:
                g.es( "Bad value in nodebar.ini: %s" % p, color= 'red' )
                g.es( "Was expecting a digit", color = 'red' )
        for z in ( help, qhelp ):
            if cparser.has_option( nbar, z ):
                p = cparser.get( nbar, z )
                if p.isdigit():
                    config[ z ] = p
                else:
                    g.es( "Bad value in nodebar.ini: %s" % p, color= 'red' )
                    g.es( "Was expecting a digit", color = 'red' )
            
                





</t>
<t tx="mork.20041026084509">def readConfigFile ():

    #reads the nodebar config file in.
    pth = os.path.split(g.app.loadDir)   
    aini = pth[0]+r"/plugins/nodebar.ini"
    if not os.path.exists(aini):
        try:
            cf = file( aini, 'w' )#creates config file for user, how nice.
            data='''
[ nodebar ]
position=1
usehelp=1
qhelp=1
            '''
            cf.write( data )
            cf.close()
            g.es( "Added nodebar.ini to plugin directory", color='blue' )
        except Exception, x:
            g.es( "Could not create nodebar.init because of : %s" % x, color='red' )
            return None
    try:
        cp = ConfigParser.ConfigParser()
        cp.read(aini)
        return cp
    except Exception, x:
        g.es( "Could not read nodebar.ini because of : %s "%x, color='red' )
        return None
    

</t>
<t tx="mork.20041026090227">def determineFrame( c ):
    '''Returns the area in Leo where the user wants the nodebar.  Default to are 1'''
    cpos = config[ pos ]
    
    if cpos == '2':
        frame = c.frame.split2Pane1
    elif cpos == '3':
        frame = c.frame.split1Pane2
    elif cpos == '4':
        frame = Tk.Toplevel()
        frame.title( 'nodebar' )
    else: #Should be area 1.  If its something else we use area 1.
        frame = c.frame.iconFrame 

    return frame</t>
<t tx="mork.20041026092203">@

1rst there needs to be a config file in the plugins directory called nodebar.ini

in this file there needs to be a section with this headline:
[ nodebar ]


under this headline there needs to be these two options
position
usehelp


----
position should be set to 1 of 3 values:
position=1
position=2
position=3

1, means add the nodebar to the icon area of Leo( this is the default )
2, means add the nodebar underneath the tree area
3, means add the nodebar underneath the editor area

-----
usehelp should be set to either 0 or 1:
usehelp=0
usehelp=1

0, means do not use balloon help when the arrow goes over the nodebar( this is the default )
1, means use the balloon help when the arrow goes over the nodebar

------

qhelp should be set to either 0 or 1

0, means that there will not be a question mark help button in the nodebar
1, means that there will be a question mark help button in the nodebar
------

nodebar will create a .ini file for the user if there isn't one already.

If there are problems in the .ini file, nodebar should sail on using the default values.</t>
<t tx="mork.20041026100755">ques = Tk.Button( mbox, image = questionPI, 
    command = lambda c = c, items = bcommands: view_help(c,items) )    
ques.grid( column = i + 1, row = 1 ) 

if int( config[ help ] ):
    addBalloon( mbox, ques, "Help" )

def callback(event,c=c ):
    c.frame.clearStatusLine()
    c.frame.putStatusLine("Open Help Dialog")

ques.bind("&lt;Enter&gt;",callback, '+' )</t>
<t tx="mork.20041027100425">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []
    
    if useauto:
        context.autobox = Pmw.ScrolledListBox( context ,hscrollmode='none',
                                         listbox_selectbackground='#FFE7C6',
                                         listbox_selectforeground='blue',
                                         listbox_background='white',
                                         listbox_foreground='blue',
                                         vertscrollbar_background='#FFE7C6',
                                         vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',
                         foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):#This def makes removing the autobox or calltip label easy.  No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()
    context.clean_editor = clean_editor

</t>
<t tx="mork.20041027103154">def moveSelItem (event, context ):
    '''This def moves the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:

        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="mork.20041027103154.1">def processKeyStroke (event,context ,body):
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return
    if not context.on or event.keysym in ( "??", "Shift_L","Shift_R" ):
        return None 
    #if event.keysym=='Escape':
    #    #turn everything off
    #    unbind( c )
    #    return None 
    #if c.which and event.keysym in('parenright','Control_L','Control_R'):
    #    unbind( c )
    #    c.on = False 
    elif testForUnbind( event, context ): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        unbind( context )
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    elif context.which==1:
        #no need to add text if its calltip time.
        return None 
    ind = body.index('insert-1c wordstart')
    pat = body.get(ind,'insert')+event.char 
    pat = pat.lstrip('.')

    autobox = context.autobox
    ww = list( autobox.get( 0, 'end' ) )
    lis = reducer(ww,pat)
    if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    i = ww.index(lis[0])

    autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    autobox.select_set( i )
    autobox.see( i )
    return 'break'</t>
<t tx="mork.20041027103154.2">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="mork.20041027154248">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the
new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information


context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode


</t>
<t tx="mork.20041029160807">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="mork.20041029162412">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.

</t>
<t tx="mork.20041030091443">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="mork.20041105115626">#These functions determine if the config and language files have been read or not.  No need to read it more than once.
def hasReadConfig():
    return configfilesread
    

def setReadConfig():
    global configfilesread
    configfilesread = True
</t>
<t tx="orkman.20050213172714">@language python
@tabwidth -4     

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from __future__ import generators # To make the code work in Python 2.2.

import leoGlobals as g

if g.app.config.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import string
import time
import java.util.Iterator as Iterator
import javax.swing.tree as stree
True = 1
False = 0

@others</t>
<t tx="orkman.20050213172714.1">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="orkman.20050213172714.2">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
    + a' (1)
    + a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
    + a'
        + b
    + a'
        + b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
    + a'
        + b' (1)
        + b' (2)
    + a'
        + b' (1)
        + b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then converts each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="orkman.20050213172714.3">class baseTnode:
    """The base class of the tnode class."""
    &lt;&lt; tnode constants &gt;&gt;
    @others
    
class tnode (baseTnode):
    """A class that implements tnodes."""
    pass</t>
<t tx="orkman.20050213172714.4">dirtyBit    =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  =	0x04
writeBit    = 0x08 # Set: write the tnode.</t>
<t tx="orkman.20050213172714.5"># All params have defaults, so t = tnode() is valid.

def __init__ (self,bodyString=None,headString=None):

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self.headString = g.toUnicode(headString,g.app.tkEncoding)
    self.bodyString = g.toUnicode(bodyString,g.app.tkEncoding)
    
    self.vnodeList = [] # List of all vnodes pointing to this tnode.
    self._firstChild = None</t>
<t tx="orkman.20050213172714.6">def __repr__ (self):
    
    return "&lt;tnode %d&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="orkman.20050213172714.7"></t>
<t tx="orkman.20050213172714.8">def createUndoInfo (self,copyLinks=True):
    
    """Create a dict containing all info needed to recreate a vnode."""
    
    t = self ; d = {}
    
    # Essential fields.
    d ["t"] = t
    d ["headString"] = t.headString
    d ["bodyString"] = t.bodyString
    d ["vnodeList"]  = t.vnodeList[:]
    d ["statusBits"] = t.statusBits
    d ["firstChild"] = t._firstChild

    try: d ["unknownAttributes"] = t.unknownAttributes
    except: pass
    
    if 0: # These neve change, so no need to save/restore them.
        # In fact, it would be wrong to undo changes made to them!
        d ["cloneIndex"]  = t.cloneIndex
        d ["fileIndex"]  = t.fileIndex

    if 0: # probably not needed for undo.
        d ["insertSpot"]      = t.insertSpot
        d ["scrollBarSpot"]   = t.scrollBarSpot
        d ["selectionLength"] = t.selectionLength
        d ["selectionStart"]  = t.selectionStart

    return d
</t>
<t tx="orkman.20050213172714.9">def restoreUndoInfo (self,d):
    
    t = d ["t"] ; assert(t == self)

    t.headString  = d ["headString"]
    t.bodyString  = d ["bodyString"]
    t.vnodeList   = d ["vnodeList"]
    t.statusBits  = d ["statusBits"]
    t._firstChild = d ["firstChild"]

    try:
        t.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="orkman.20050213172714.10"></t>
<t tx="orkman.20050213172714.11">def getBody (self):

    return self.bodyString</t>
<t tx="orkman.20050213172714.12">def hasBody (self):

    return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="orkman.20050213172714.13"></t>
<t tx="orkman.20050213172714.14">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="orkman.20050213172714.15">def isRichTextBit (self):

    return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="orkman.20050213172714.16">def isVisited (self):

    return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="orkman.20050213172714.17">def isWriteBit (self):

    return (self.statusBits &amp; self.writeBit) != 0</t>
<t tx="orkman.20050213172714.18"></t>
<t tx="orkman.20050213172714.19"></t>
<t tx="orkman.20050213172714.20"># This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    """Set the body text of a tnode to the given string."""
    
    s = g.toUnicode(s,encoding,reportErrors=True)
    
    if 0: # DANGEROUS:  This automatically converts everything when reading files.

        option = g.app.config.trailing_body_newlines
        
        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()

    self.bodyString = s</t>
<t tx="orkman.20050213172714.21">def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length</t>
<t tx="orkman.20050213172714.22"></t>
<t tx="orkman.20050213172714.23">def clearDirty (self):

    self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="orkman.20050213172714.24">def clearRichTextBit (self):

    self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="orkman.20050213172714.25">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="orkman.20050213172714.26">def clearWriteBit (self):

    self.statusBits &amp;= ~ self.writeBit</t>
<t tx="orkman.20050213172714.27">def setDirty (self):

    self.statusBits |= self.dirtyBit</t>
<t tx="orkman.20050213172714.28">def setRichTextBit (self):

    self.statusBits |= self.richTextBit</t>
<t tx="orkman.20050213172714.29">def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="orkman.20050213172714.30">def setWriteBit (self):

    self.statusBits |= self.writeBit</t>
<t tx="orkman.20050213172714.31">def setCloneIndex (self, index):

    self.cloneIndex = index</t>
<t tx="orkman.20050213172714.32">def setFileIndex (self, index):

    self.fileIndex = index</t>
<t tx="orkman.20050213172714.33">class baseVnode:
    """The base class of the vnode class."""
    &lt;&lt; vnode constants &gt;&gt;
    @others
    
class vnode (baseVnode):
    """A class that implements vnodes."""
    pass</t>
<t tx="orkman.20050213172714.34"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # True: vnode has clone mark.

# not used	 = 0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit	  = 0x08 # True: vnode is marked
orphanBit	  = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
topBit		    = 0x40 # True: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit	 = 0x100
</t>
<t tx="orkman.20050213172714.35"></t>
<t tx="orkman.20050213172714.36">if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1</t>
<t tx="orkman.20050213172714.37">def __init__ (self,c,t):

    assert(t)
    &lt;&lt; initialize vnode data members &gt;&gt;</t>
<t tx="orkman.20050213172714.38">self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None</t>
<t tx="orkman.20050213172714.39">def __repr__ (self):
    
    if self.t:
        return "&lt;vnode %d:'%s'&gt;" % (id(self),self.cleanHeadString())
    else:
        return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="orkman.20050213172714.40">def dumpLink (self,link):
    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v</t>
<t tx="orkman.20050213172714.41"></t>
<t tx="orkman.20050213172714.42">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="orkman.20050213172714.43">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="orkman.20050213172714.44"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="orkman.20050213172714.45">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="orkman.20050213172714.46">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="orkman.20050213172714.47">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="orkman.20050213172714.48">def isAtIgnoreNode (self):  

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="orkman.20050213172714.49">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="orkman.20050213172714.50">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="orkman.20050213172714.51"></t>
<t tx="orkman.20050213172714.52"></t>
<t tx="orkman.20050213172714.53"># Compatibility routine for scripts

def back (self):

    return self._back</t>
<t tx="orkman.20050213172714.54"># Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next</t>
<t tx="orkman.20050213172714.55"></t>
<t tx="orkman.20050213172714.56">def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n</t>
<t tx="orkman.20050213172714.57">def firstChild (self):
    
    return self.t._firstChild</t>
<t tx="orkman.20050213172714.58">def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren</t>
<t tx="orkman.20050213172714.59">def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child</t>
<t tx="orkman.20050213172714.60"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n &gt; 0 and child:
        n -= 1
        child = child.next()
    return child</t>
<t tx="orkman.20050213172714.61">def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n</t>
<t tx="orkman.20050213172714.62"></t>
<t tx="orkman.20050213172714.63">def isCloned (self):
    
    return len(self.t.vnodeList) &gt; 1</t>
<t tx="orkman.20050213172714.64">def isDirty (self):

    return self.t.isDirty()</t>
<t tx="orkman.20050213172714.65">def isExpanded (self):

    return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="orkman.20050213172714.66">def isMarked (self):

    return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="orkman.20050213172714.67">def isOrphan (self):

    return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="orkman.20050213172714.68">def isSelected (self):

    return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="orkman.20050213172714.69">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="orkman.20050213172714.70">def isVisited (self):

    return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="orkman.20050213172714.71">def status (self):

    return self.statusBits</t>
<t tx="orkman.20050213172714.72"># Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "Leo internal error: not unicode:" + repr(self.t.bodyString)
        print s ; g.es(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
</t>
<t tx="orkman.20050213172714.73">def currentPosition (self):
    return self.c.currentPosition()
        
def currentVnode (self):
    return self.c.currentVnode()</t>
<t tx="orkman.20050213172714.74">def findRoot (self):
    
    return self.c.rootPosition()</t>
<t tx="orkman.20050213172714.75">def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        print s ; g.es(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'</t>
<t tx="orkman.20050213172714.76">def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []</t>
<t tx="orkman.20050213172714.77"># These remain in 4.2: the file read logic calls these before creating positions.</t>
<t tx="orkman.20050213172714.78">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAfter(self)

    return v</t>
<t tx="orkman.20050213172714.79">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAsNthChild(self,n)

    return v</t>
<t tx="orkman.20050213172714.80">def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
</t>
<t tx="orkman.20050213172714.81">def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v</t>
<t tx="orkman.20050213172714.82">def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self ; c = v.c

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v

    newRoot = position(v,[])
    c.setRootPosition(newRoot)</t>
<t tx="orkman.20050213172714.83">def moveToRoot (self,oldRoot=None):

    """Moves the receiver to the root position"""

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v</t>
<t tx="orkman.20050213172714.84">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self ; c = v.c

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
    
    # Special case the root.
    if v == c.rootPosition().v: # 3/11/04
        assert(v._next)
        newRoot = position(v._next,[])
        c.setRootPosition(newRoot)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="orkman.20050213172714.85"></t>
<t tx="orkman.20050213172714.86"></t>
<t tx="orkman.20050213172714.87">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="orkman.20050213172714.88">def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    g.trace()
    v = self ; c = v.c
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons</t>
<t tx="orkman.20050213172714.89">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="orkman.20050213172714.90">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="orkman.20050213172714.91">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="orkman.20050213172714.92">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

def expand(self):

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="orkman.20050213172714.93">def initStatus (self, status):

    self.statusBits = status</t>
<t tx="orkman.20050213172714.94">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="orkman.20050213172714.95">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="orkman.20050213172714.96">def setOrphan (self):

    self.statusBits |= self.orphanBit</t>
<t tx="orkman.20050213172714.97"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit</t>
<t tx="orkman.20050213172714.98"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="orkman.20050213172714.99">def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="orkman.20050213172714.100">def initHeadString (self,s,encoding="utf-8"):
    
    v = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s</t>
<t tx="orkman.20050213172714.101">def setSelection (self, start, length):

    self.t.setSelection ( start, length )</t>
<t tx="orkman.20050213172714.102">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)</t>
<t tx="orkman.20050213172714.103">def trimTrailingLines (self):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    v = self
    body = v.bodyString()
    # g.trace(body)
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        v.setBodyStringOrPane(body)
        # Don't set the dirty bit: it would just be annoying.
</t>
<t tx="orkman.20050213172714.104"></t>
<t tx="orkman.20050213172714.105">def createUndoInfo (self):
    
    """Create a dict containing all info needed to recreate a vnode for undo."""
    
    v = self ; d = {}
    
    # Copy all ivars.
    d ["v"] = v
    d ["statusBits"] = v.statusBits
    d ["parent"] = v._parent
    d ["next"] = v._next
    d ["back"] = v._back
    # The tnode never changes so there is no need to save it here.
    
    try: d ["unknownAttributes"] = v.unknownAttributes
    except: pass

    return d</t>
<t tx="orkman.20050213172714.106">def restoreUndoInfo (self,d):
    
    """Restore all ivars saved in dict d."""
    
    v = d ["v"] ; assert(v == self)

    v.statusBits = d ["statusBits"]
    v._parent    = d ["parent"] 
    v._next      = d ["next"] 
    v._back      = d ["back"]
    
    try:
        v.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="orkman.20050213172714.107"></t>
<t tx="orkman.20050213172714.108">def subtree_iter(self):

    """Return all nodes of self's tree in outline order."""
    
    v = self
         
    if v:
        yield v
        child = v.t._firstChild
        while child:
            for v1 in child.subtree_iter():
                yield v1
            child = child.next()
            
self_and_subtree_iter = subtree_iter</t>
<t tx="orkman.20050213172714.109">def unique_subtree_iter(self,marks=None):

    """Return all vnodes in self's tree, discarding duplicates """
    
    v = self
    if marks == None: marks = {}
    
    
    if v and v not in marks:
        marks[v] = v
        yield v
        if v.t._firstChild:
            for v1 in v.t._firstChild.unique_subtree_iter(marks):
                yield v1
        v = v._next
        while v:
            for v in v.unique_subtree_iter(marks):
                yield v
            v = v._next
            
self_and_unique_subtree_iter = unique_subtree_iter</t>
<t tx="orkman.20050213172714.110"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices:
    
    """A class to implement global node indices (gnx's)."""
    
    @others
</t>
<t tx="orkman.20050213172714.111">def __init__ (self):
    
    """ctor for nodeIndices class"""

    self.userId = g.app.leoID # 5/1/03: This never changes.
    self.defaultId = g.app.leoID # This probably will change.
    self.lastIndex = None
    self.timeString = None</t>
<t tx="orkman.20050213172714.112">def areEqual (self,gnx1,gnx2):
    
    """Return True if all fields of gnx1 and gnx2 are equal"""

    # works whatever the format of gnx1 and gnx2.
    # This should never throw an exception.
    return gnx1 == gnx2
    
    id1,time1,n1 = gnx1
    id2,time2,n2 = gnx2
    # g.trace(id1==id2 and time1==time2 and n1==n2,gnx1,gnx2)
    return id1==id2 and time1==time2 and n1==n2</t>
<t tx="orkman.20050213172714.113"># These are used by the fileCommands read/write code.

def getDefaultId (self):
    
    """Return the id to be used by default in all gnx's"""
    return self.defaultId
    
def setDefaultId (self,id):
    
    """Set the id to be used by default in all gnx's"""
    self.defaultId = id
</t>
<t tx="orkman.20050213172714.114">def getNewIndex (self):
    
    """Create a new gnx using self.timeString and self.lastIndex"""
    
    id = self.userId # Bug fix 5/1/03: always use the user's id for new ids!
    t = self.timeString
    assert(t)
    n = None

    # Set n if id and time match the previous index.
    last = self.lastIndex
    if last:
        lastId,lastTime,lastN = last
        if id==lastId and t==lastTime:
            if lastN == None: n = 1
            else: n = lastN + 1

    d = (id,t,n)
    self.lastIndex = d
    # g.trace(d)
    return d</t>
<t tx="orkman.20050213172714.115">def isGnx (self,gnx):
    try:
        id,t,n = gnx
        return t != None
    except:
        return False</t>
<t tx="orkman.20050213172714.116">def scanGnx (self,s,i):
    
    """Create a gnx from its string representation"""
    
    if type(s) not in (type(""),type(u"")):
        g.es("scanGnx: unexpected index type:",type(s),s,color="red")
        return None,None,None
        
    s = s.strip()

    id,t,n = None,None,None
    i,id = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if id == None or len(id) == 0:
        id = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except: pass

    return id,t,n</t>
<t tx="orkman.20050213172714.117">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())</t>
<t tx="orkman.20050213172714.118">def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    id,t,n = index

    if removeDefaultId and id == self.defaultId:
        id = ""

    if not n: # None or ""
        return "%s.%s" % (id,t)
    else:
        return "%s.%s.%d" % (id,t,n)</t>
<t tx="orkman.20050213172714.119"># Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position( stree.TreeNode ):
    
    """A class representing a position in a traversal of a tree containing shared tnodes."""

    &lt;&lt; about the position class &gt;&gt;
    
    @others
</t>
<t tx="orkman.20050213172714.120">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="orkman.20050213172714.121"></t>
<t tx="orkman.20050213172714.122">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="orkman.20050213172714.123">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        elif attr=="__del__":
            # This works around a Python 2.2 wierdness.
            return AttributeError # Silently ignore this.
        else:
            # Only called when normal lookup fails.
            print "unknown position attribute:",attr
            import traceback ; traceback.print_stack()
            raise AttributeError</t>
<t tx="orkman.20050213172714.124">def __init__ (self,v,stack,trace=True):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="orkman.20050213172714.125">@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None</t>
<t tx="orkman.20050213172714.126">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="orkman.20050213172714.127"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    #if g.app.tracePositions:
    #    g.trace("%-25s %-25s %s" % (
    #        g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)</t>
<t tx="orkman.20050213172714.128">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="orkman.20050213172714.129">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition() ; root = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert p.equal(p.copy()) is True
    &gt;&gt;&gt; assert p.equal(root) is False
    &gt;&gt;&gt; assert g.app.positions == n + 1
    &gt;&gt;&gt; 
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
__eq__ = equal
#def __hash__( self ):
#    print "HASHING"
#    return self.hashCode()

def __ne__( self, x ): #wont work without
    if self is x: return False
    else: return True
    
#def __ne__( self, x ):
#    print 'NE executing for %s' % self
#    return True
    
def toString( self ):

    try:
        return self.headString()
    except:
        return ""
        
    




</t>
<t tx="orkman.20050213172714.130">@others</t>
<t tx="orkman.20050213172714.131">def children( self ):
    
    class _en( util.Enumeration ):
        
        def __init__( self, iter ):
            self.iter = iter
            try:
                self.next = iter.next()
            except:
                pass
        
        def hasMoreElements( self ):
            if self.next: return True
            else:
                return False
            
        def nextElement( self ):
            
            try:
                print "CHILD:"
                print self.next
                nx = self.next
                self.next = self.iter.next()
            finally:
                return nx
                   
    return _en( self.children_iter() )</t>
<t tx="orkman.20050213172714.132">def getAllowsChildren( self ):
    return True
    
</t>
<t tx="orkman.20050213172714.133">def getChildAt( self, n ):
    print 'getChildAt'
    return self.getNthChild( n )
    
</t>
<t tx="orkman.20050213172714.134">def getChildCount( self ):
    print 'getChildCount'
    try:
        return self.numberOfChildren()
    except:
        return 0
    
</t>
<t tx="orkman.20050213172714.135">def getIndex( self, item ):
    print 'getIndex'
    i = 0
    for z in self.children_iter():
        if z == item:
            return i
        i = i + 1
    return -1    </t>
<t tx="orkman.20050213172714.136">#def getParent( self ): 'already defined later'
#    print 'PARENT'
#    return self._parent
    

</t>
<t tx="orkman.20050213172714.137">def isLeaf( self ):
    print 'isLeaf'
    try:
        if self.numberOfChildren() &gt; 0: return True
        else:
            return False
    except:
        return True
    
    
        
</t>
<t tx="orkman.20050213172714.138"></t>
<t tx="orkman.20050213172714.139"></t>
<t tx="orkman.20050213172714.140">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="orkman.20050213172714.141">def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)</t>
<t tx="orkman.20050213172714.142">def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
</t>
<t tx="orkman.20050213172714.143">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()</t>
<t tx="orkman.20050213172714.144">def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)</t>
<t tx="orkman.20050213172714.145">def directParents (self):
    
    return self.v.directParents()
</t>
<t tx="orkman.20050213172714.146">def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n</t>
<t tx="orkman.20050213172714.147"></t>
<t tx="orkman.20050213172714.148">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="orkman.20050213172714.149">def numberOfChildren (self):
    
    return self.v.numberOfChildren()
</t>
<t tx="orkman.20050213172714.150">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()
    
    # This code must be fast.
    root = c.rootPosition()
    while p:
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False</t>
<t tx="orkman.20050213172714.151">def findRoot (self):
    
    return self.c.frame.rootPosition()</t>
<t tx="orkman.20050213172714.152"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self):
    #try:
    rt = self.copy().moveToParent() 
	#    return rt
    #except:
    #return self.c.frame.tree.posTM._root
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="orkman.20050213172714.153">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="orkman.20050213172714.154">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="orkman.20050213172714.155">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="orkman.20050213172714.156"></t>
<t tx="orkman.20050213172714.157">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="orkman.20050213172714.158">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="orkman.20050213172714.159">def isCloned (self):
    
    return len(self.v.t.vnodeList) &gt; 1</t>
<t tx="orkman.20050213172714.160">def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()</t>
<t tx="orkman.20050213172714.161">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="orkman.20050213172714.162">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="orkman.20050213172714.163">def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level += 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level</t>
<t tx="orkman.20050213172714.164"></t>
<t tx="orkman.20050213172714.165"></t>
<t tx="orkman.20050213172714.166"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    g.doHook("clear-mark",c=self.c,p=self)
    return self.v.clearMarked()

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
    
def setMarked (self):
    g.doHook("set-mark",c=self.c,p=self)
    return self.v.setMarked()

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="orkman.20050213172714.167">def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="orkman.20050213172714.168">def setSelection (self,start,length):

    return self.v.setSelection(start,length)</t>
<t tx="orkman.20050213172714.169">def trimTrailingLines (self):

    return self.v.trimTrailingLines()</t>
<t tx="orkman.20050213172714.170">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)</t>
<t tx="orkman.20050213172714.171"></t>
<t tx="orkman.20050213172714.172">def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)</t>
<t tx="orkman.20050213172714.173">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="orkman.20050213172714.174">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="orkman.20050213172714.175">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="orkman.20050213172714.176">def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)</t>
<t tx="orkman.20050213172714.177"></t>
<t tx="orkman.20050213172714.178"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="orkman.20050213172714.179"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="orkman.20050213172714.180">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="orkman.20050213172714.181"></t>
<t tx="orkman.20050213172714.182">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="orkman.20050213172714.183">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="orkman.20050213172714.184">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count += 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed</t>
<t tx="orkman.20050213172714.185"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="orkman.20050213172714.186">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="orkman.20050213172714.187">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="orkman.20050213172714.188">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="orkman.20050213172714.189">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="orkman.20050213172714.190">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="orkman.20050213172714.191">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="orkman.20050213172714.192">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="orkman.20050213172714.193">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="orkman.20050213172714.194">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="orkman.20050213172714.195">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="orkman.20050213172714.196">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="orkman.20050213172714.197">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="orkman.20050213172714.198">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="orkman.20050213172714.199">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="orkman.20050213172714.200">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="orkman.20050213172714.201">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="orkman.20050213172714.202">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="orkman.20050213172714.203">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="orkman.20050213172714.204">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="orkman.20050213172714.205">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="orkman.20050213172714.206">class siblings_iter_class:

    """Returns a list of siblings of a position."""  

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="orkman.20050213172714.207">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="orkman.20050213172714.208">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="orkman.20050213172714.209"></t>
<t tx="orkman.20050213172714.210">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="orkman.20050213172714.211">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="orkman.20050213172714.212">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="orkman.20050213172714.213">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="orkman.20050213172714.214">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="orkman.20050213172714.215">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="orkman.20050213172714.216"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="orkman.20050213172714.217">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="orkman.20050213172714.218">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="orkman.20050213172714.219">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="orkman.20050213172714.220">def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index += 1</t>
<t tx="orkman.20050213172714.221"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="orkman.20050213172714.222">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="orkman.20050213172714.223">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="orkman.20050213172714.224">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="orkman.20050213172714.225">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="orkman.20050213172714.226">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="orkman.20050213172714.227">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="orkman.20050213172714.228">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="orkman.20050213172714.229">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="orkman.20050213172714.230">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="orkman.20050213172714.231">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="orkman.20050213172714.232">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="orkman.20050213172714.233">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="orkman.20050213172714.234">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    # if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)
            
    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p

</t>
<t tx="orkman.20050213172714.235">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="orkman.20050213172714.236">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="orkman.20050213172714.237">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="orkman.20050213172714.238">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="orkman.20050213172714.239"></t>
<t tx="orkman.20050213172714.240"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="orkman.20050213172714.241">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="orkman.20050213172714.242">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="orkman.20050213172714.243">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="orkman.20050213172714.244">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="orkman.20050213172714.245">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="orkman.20050213172714.246"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="orkman.20050213172714.247">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="orkman.20050213172714.248">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="orkman.20050213172714.249">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="orkman.20050213172714.250">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
</t>
<t tx="orkman.20050213172746">@first #! /usr/bin/env python

"""Entry point for Leo in Python."""   

@language python     
@tabwidth -4

&lt;&lt; Import pychecker &gt;&gt;

# Suppress import errors.
# This module must do strange things with imports.
__pychecker__ = '--no-import --no-reimportself --no-reimport '

# Warning: do not import any Leo modules here!
# Doing so would make g.app invalid in the imported files.
import os
import string
import sys
True = 1
False = 0

@others

if __name__ == "__main__":
    if len(sys.argv) &gt; 1:
        if sys.platform=="win32": # Windows
            fileName = string.join(sys.argv[1:],' ')
        else:
            fileName = sys.argv[1]
        run(fileName)
    else:
        run()



</t>
<t tx="orkman.20050213172746.1">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass</t>
<t tx="orkman.20050213172746.2">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    if not isValidPython(): return
    # Import leoGlobals, but do NOT set g.
    import leoGlobals
    # Create the application object.
    import leoApp ; leoGlobals.app = leoApp.LeoApp()
    g = leoGlobals ; assert(g.app) # NOW we can set g.
    g.app.loadDir = computeLoadDir() # Depends on g.app.tkEncoding: uses utf-8 for now.
    import leoConfig
    g.app.config = leoConfig.config()
    g.app.setEncoding() # 10/20/03: do this earlier
    script = getBatchScript()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    else:
        &lt;&lt; print encoding info &gt;&gt;
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    #if g.app.gui == "swing" :
    #    g.app.createSwingGui()
    if g.app.gui == None:
        #g.app.createTkGui()
        g.app.createSwingGui()
    if g.app.use_gnx:
        if not g.app.leoID: g.app.setLeoID() # Forces the user to set g.app.leoID.
        import leoNodes
        g.app.nodeIndices = leoNodes.nodeIndices()
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    &lt;&lt; start psycho &gt;&gt;
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    v = c.currentVnode()
    #g.doHook("start2",c=c,v=v,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
    

</t>
<t tx="orkman.20050213172746.3">g.es("leoConfig.txt encoding: " + g.app.config.config_encoding, color="blue")

if 0: # This is just confusing for users.
    g.es("Text encoding: " + g.app.tkEncoding, color="blue")</t>
<t tx="orkman.20050213172746.4">if g.app.config.use_psyco:
    try:
        import psyco
        if 0:
            file = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",file,color="blue")
            psyco.log(file)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="orkman.20050213172746.5">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except Exception, x:
        print message
        return 0
    try:
        ok = True
        return ok
    except:
        print "exception getting Python version"
        import traceback ; traceback.print_exc()
        return False</t>
<t tx="orkman.20050213172746.6">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding)
    
    try:
        import leo
        path = g.os_path_abspath(leo.__file__)

        if sys.platform=="win32": # "mbcs" exists only on Windows.
            path = g.toUnicode(path,"mbcs")
        elif sys.platform=="dawwin":
            path = g.toUnicode(path,"utf-8")
        else:
            path = g.toUnicode(path,g.app.tkEncoding)

        if path:
            loadDir = g.os_path_dirname(path)
        else:
            loadDir = None
        if not loadDir:
            loadDir = g.os_path_abspath(os.getcwd())
            print "Using emergency loadDir:",repr(loadDir)

        encoding = g.choose(sys.platform=="dawwin","utf-8",g.app.tkEncoding) # 11/18/03
        loadDir = g.toUnicode(loadDir,encoding) # 10/20/03
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None</t>
<t tx="orkman.20050213172746.7">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)
    
    # Try to create a frame for the file.
    if fileName:
        fileName = g.os_path_join(os.getcwd(),fileName)
        fileName = g.os_path_normpath(fileName)
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame &amp; indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="orkman.20050213172746.8">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="orkman.20050213172746.9">def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name: return None	
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script</t>
<t tx="orkman.20050213172746.10">@ To gather statistics, do the following in a Python window, not idle:

    import leo
    leo.profile()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile ():
    
    """Gather and print statistics about Leo"""

    import profile, pstats
    
    name = "c:/prog/test/leoProfile.txt"
    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('cum','file','name')
    p.print_stats()</t>
<t tx="orkman.20050216114307">import org.jgraph.graph as gr
import javax.swing as sw
import org.jgraph as jg
import java.util as util
import org.jgraph.graph.GraphConstants as GraphConstants
import java.awt as awt


class z( gr.DefaultGraphCell ):
    
    i = 0
    def __init__( self ):
        gr.DefaultGraphCell.__init__( self, "CATAMANGA" )
        self.i2 = self.i
        z.i = z.i + 1
        
    def toString( self ):
        return "ZZZZZ%s!" % self.i2 


def getGraph():
    
    import jarray
    fl = jarray.zeros( 2, 'f' )
    fl[ 0 ] = 3
    fl[ 1 ] = 3
    roots = util.ArrayList()
    cs = gr.ConnectionSet()
    amap = util.HashMap()
    implementStyle = gr.AttributeMap();
    GraphConstants.setLineBegin(implementStyle, GraphConstants.ARROW_TECHNICAL)
    GraphConstants.setBeginSize(implementStyle, 10)
    GraphConstants.setDashPattern(implementStyle, fl )
    GraphConstants.setFont(implementStyle, GraphConstants.DEFAULTFONT.deriveFont(10))
    #e = gr.DefaultEdge( "YEAH" )
    #amap.put( e, implementStyle )
    rt = z()
    roots.add( rt )
    for x in xrange( 10 ):
        #e = gr.DefaultEdge()
        #rt.addEdge( e )
        #rt.add( e )
        z2 = z()
        as1 = gr.AttributeMap()
        gr.GraphConstants.setBounds( as1, awt.Rectangle( x * 50, 50 * x, 50, 50 ) )
        e = gr.DefaultEdge( "YEAH" )
        cs.connect( e, rt, z2 )
        amap.put( e, implementStyle )
        amap.put( z2, as1 )
        roots.add( z2 )
        #rt.add( z2 )
        #e.setTarget( z2 )
        #e.add( z2 )
        #z2.setAnchor( rt )
        
    return roots.toArray() , cs, amap
    
    
def mkGraph():
    tl = sw.JFrame()
    grp = getGraph()
    #rts = util.ArrayList()
    #rts.add( grp )
    dmod = gr.DefaultGraphModel()
    dmod.insert( grp[ 0 ], grp[ 2 ] , grp[ 1 ], None , None  )
    #dmod = gr.DefaultGraphModel( rts, gr.AttributeMap() )
    j = jg.JGraph( dmod )
    tl.getContentPane().add( j )
    tl.visible = 1
    
    

mkGraph()
    
    </t>
<t tx="orkman.20050222185810"></t>
<t tx="zorcanda!.20050224165207">&lt;synth&gt;

&lt;style id='tiger_background' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' key='TEXT_FOREGROUND' /&gt; 
        &lt;color value='WHITE' key='TEXT_BACKGROUND' /&gt;
        
        &lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;  
        &lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='desktopPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        imagePainter path='/oranger.gif' method='rootPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;

    &lt;opaque value='false' /&gt;
&lt;/style&gt;


&lt;style id ="font_base" &gt;
    &lt;font name="Arial" size='16' /&gt;
&lt;/style&gt;

&lt;style id="base" clone='font_base' &gt;
    &lt;state&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="WHITE" type='BACKGROUND' /&gt;
        &lt;color value="RED" type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='tb' clone='base' &gt;
    &lt;state&gt;
    &lt;imageIcon id='handle' path='/Leoapp2.GIF' /&gt;
    &lt;!-- I had to look at the source for SynthToolBarUI to figure this one out, handleIcon is mentioned in the property table --&gt;
    &lt;property key='ToolBar.handleIcon' value='handle' /&gt;
    &lt;property key='ToolBar.separatorSize' type='dimension' value='0 0 0 0' /&gt;

    &lt;/state&gt;
    &lt;imagePainter path='/yellow.gif' method='toolBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='splitpane' &gt;
    &lt;state&gt;
    &lt;!-- imagePainter path='/rednoise.gif' method='splitPaneDividerBackground' sourceInsets='5 5 5 5'  paintCenter='true'  stretch='false' --&gt;
    &lt;property key='SplitPane.size' type='integer' value='20' /&gt;
    &lt;property key='SplitPane.oneTouchButtonSize' type='integer' value='16' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iftb' &gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='RED' type='TEXT_BACKGROUND' /&gt;
         &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED' &gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    
    &lt;opaque value='true' /&gt;
    &lt;imageIcon id='collapses' path='/orangerbar.gif' /&gt;
    &lt;imageIcon id='co2' path='/orange.gif' /&gt;
    &lt;imageIcon id='system' path='/Leoapp2.GIF' /&gt;
    &lt;imageIcon id='minimize' path='/minimize.gif' /&gt;
    &lt;imageIcon id='maximize' path='/maximize.gif' /&gt;
    &lt;imageIcon id='close' path='/close.gif' /&gt;
    &lt;imageIcon id='shrink' path='/shrink.gif' /&gt;
    &lt;property key='InternalFrameTitlePane.iconifyIcon' value='minimize' /&gt;
    &lt;property key='InternalFrameTitlePane.maximizeIcon' value='maximize' /&gt;
    &lt;property key='InternalFrameTitlePane.minimizeIcon' value='shrink' /&gt;
    &lt;property key='InternalFrameTitlePane.closeIcon' value='close' /&gt;
    &lt;property key='InternalFrame.icon' value='system' /&gt; 
    &lt;insets top='1' bottom='1' right='1' left='1' /&gt;

&lt;/style&gt;

&lt;style id='dticon' &gt;
    &lt;opaque value='true' /&gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='desktopIconBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='texts' clone='font_base' &gt;
    &lt;opaque value='true' /&gt;
    &lt;state&gt;
    &lt;/state&gt;
    
    
&lt;/style&gt;

&lt;style id='menus' clone='base' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' type="TEXT_FOREGROUND" /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;imageIcon id='mI' path='/Leoapp2.GIF' /&gt;
        &lt;property key='Menu.arrowIcon' value='mI' /&gt;
        &lt;opaque value='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='popupMenuBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/yellow.gif' method='menuBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
        &lt;state value='FOCUSED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='button'&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;insets top='5' left='5' right='5' bottom='5' /&gt;
        &lt;imagePainter path='/yellow.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;imagePainter path='/Weirdness.gif' method='buttonBorder' sourceInsets='3 3 3 3' paintCenter='false' destinationInsets='1 1 1 1' /&gt;
        &lt;property key='Button.contentAreaFilled' type='boolean' value='true' /&gt;
        &lt;object id='ins' class='java.awt.Insets' &gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
        &lt;/object&gt;
    &lt;property key='Button.margin' value='ins' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;imagePainter path='/Weirdness.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='ab'&gt;
    &lt;object class='java.lang.Integer' id='size'&gt;
        &lt;int&gt;30&lt;/int&gt;
    &lt;/object&gt;
    &lt;property key='ArrowButton.size' value='size'/&gt;
&lt;/style&gt;

&lt;style id='jlist' clone='base'&gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='ORANGE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/oranger.gif' method='listBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
    &lt;opaque value='true' /&gt;
    &lt;property key='List.rendererUseListColors' type='boolean' value='true' /&gt;
&lt;/style&gt;

&lt;style id='mbbackground' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sbar' &gt;
    

    &lt;imagePainter path='/uparrow.gif' method='arrowButtonForeground' direction='north' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/downarrow.gif' method='arrowButtonForeground' direction='south' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/rightarrow.gif' method='arrowButtonForeground' direction='east' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/leftarrow.gif' method='arrowButtonForeground' direction='west' sourceInsets='1 1 1 1' paintCenter='true' /&gt;

&lt;/style&gt;

&lt;style id='sbar2' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type="FOREGROUND" /&gt;
        &lt;color value='BLUE' type="BACKGROUND" /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/yellow.gif' method='scrollBarThumbBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarTrackBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='jtf' clone='base' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/orangerbar.gif' method='textFieldBorder' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;color value="WHITE" type="BACKGROUND" /&gt;
        &lt;color value="RED" type="FOREGROUND" /&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value="WHITE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="RED" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="RED" type='BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;insets top='3' bottom='3' right='3' left='3' /&gt;
&lt;/style&gt;

&lt;style id='tree'&gt;
    &lt;state&gt;
        
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED'&gt;
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;object id='reds' class='java.awt.Color' &gt;
        &lt;int&gt;255&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
    &lt;/object&gt;
    &lt;!-- its important to set this default property or the current node will not be colored --&gt;
    &lt;defaultsProperty key='Tree.selectionBackground' value='reds' /&gt;
    &lt;imageIcon id='collapse' path='/plusnode.gif' /&gt;
    &lt;imageIcon id='expand' path='/minusnode.gif' /&gt;
    
    &lt;object class='java.lang.Integer' id='rci'&gt;
        &lt;int&gt;7&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Integer' id='lci'&gt;
        &lt;int&gt;15&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Boolean' id='scrolls' &gt;
        &lt;boolean&gt;true&lt;/boolean&gt;
    &lt;/object&gt;
    &lt;property key='Tree.collapsedIcon' value='collapse' /&gt;
    &lt;property key='Tree.expandedIcon' value='expand' /&gt;
    &lt;property key='Tree.rightChildIndent' value='lci' /&gt;
    &lt;property key='Tree.leftChildIndent' value='rci' /&gt;
    &lt;property key='Tree.scrollsHorizontallyAndVertically' value='scrolls' /&gt;
&lt;/style&gt;

&lt;style id='treecell'&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND'/&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iconrenderer' &gt;
    &lt;state value='SELECTED' &gt;
        &lt;imagePainter path='/orangerbar.gif' method='labelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='jlabel' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;opaque value='false' /&gt;
&lt;/style&gt;

&lt;style id='tabbedpanetab' &gt;
    &lt;insets top='2' bottom='2' right='2' left='2' /&gt;
    &lt;imagePainter method='tabbedPaneTabBorder' path='/yellow.gif' sourceInsets='1 1 0 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='radios' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='unsel' path='/unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='MOUSE_OVER and SELECTED' &gt;
        &lt;imageIcon id='sel2' path='/focused_sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='sel' path='/sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='unsel2' path='/focused_unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;


&lt;style id='ckboxes' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='cunsel' path='/unsel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='SELECTED and MOUSE_OVER' &gt;
        &lt;imageIcon id='csel2' path='/sel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='csel' path='/unsel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='cunsel2' path='/sel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='leodialog' &gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
&lt;/style&gt;

&lt;style id='comboboxes' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='filechoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='fileChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='colorchoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='colorChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='optionpanes' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='optionPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sliders' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/yellow.gif' method='sliderThumbBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/yellow.gif' method='sliderTrackBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/orangerbar.gif' method='sliderThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'colorchooser_dialog'&gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id = 'settingsview' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method = 'panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;bind style='font_base' type='region' key='.*' /&gt;
&lt;bind style='tiger_background' type='region' key='MenuBar' /&gt;
&lt;bind style='tiger_background' type='region' key='ToolBar' /&gt;
&lt;bind style='tiger_background' type='region' key='SplitPane' /&gt;
&lt;bind style='tiger_background' type='region' key='DesktopPane' /&gt;
&lt;bind style='tiger_background' type='region' key='RootPane' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrame' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrameTitlePane' /&gt;
&lt;bind style='dticon' type='region' key='DesktopIcon' /&gt;
&lt;bind style="base" type="region" key="PANEL" /&gt;
&lt;!-- Note: colorchoosers dialogs contentPane are given the name cc_dialog --&gt;
&lt;bind style="colorchooser_dialog" type='name' key='cc_dialog' /&gt;
&lt;bind style='menus' type='region' key='Menu' /&gt;
&lt;bind style='menus' type='region' key='MenuItem' /&gt;
&lt;bind style='menus' type='region' key='MenuBar'  /&gt;
&lt;bind style='menus' type='region' key='MenuItemAccelerator' /&gt;
&lt;bind style='menus' type='region' key='PopupMenu' /&gt;
&lt;bind style='comboboxes' type='region' key='ComboBox' /&gt;
&lt;bind style='comboboxes' type='region' key='List' /&gt;
&lt;bind style='jtf' type='region' key='TextField' /&gt;
&lt;bind style='sbar' type='region' key='ArrowButton' /&gt;
&lt;bind style='button' type='region' key='BUTTON' /&gt;
&lt;!-- bind style="texts" type="region" key="TEXTPANE" --&gt;
&lt;bind style='texts' type='name' key='Log' /&gt;
&lt;bind style='texts' type='name' key='Editor'/&gt;
&lt;bind style="texts" type="region" key="TEXTAREA" /&gt;
&lt;bind style='tree' type='region' key='TREE' /&gt;
&lt;bind style='treecell' type='region' key='TREECELL' /&gt;
&lt;bind style='treecell' type='name' key='Tree.cellEditor' /&gt;
&lt;bind style='jlabel' type='region' key='Label' /&gt;
&lt;bind style='tb' type='region' key='TOOLBAR' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpanedivider' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpane' /&gt;
&lt;!-- note: the autocompleter list has been given the name Autolist --&gt;
&lt;bind style='jlist' type='name' key='Autolist'/&gt;
&lt;!-- note: the minibuffers background panel has been given the name Minibufferbackgrond --&gt;
&lt;bind style='mbbackground' type='name' key='Minibufferbackground' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBAR' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTRACK' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTHUMB' /&gt;
&lt;bind style='tabbedpanetab' type='region' key='TabbedPaneTab' /&gt;
&lt;bind style='radios' type='region' key='RadioButton' /&gt;
&lt;bind style='ckboxes' type='region' key='CheckBox' /&gt;
&lt;bind style='leodialog' type='name' key='Leodialog' /&gt;
&lt;bind style='iconrenderer' type='name' key='IconTreeRenderer' /&gt;
&lt;bind style='filechoosers' type='region' key='FileChooser' /&gt;
&lt;bind style='colorchoosers' type='region' key='ColorChooser' /&gt;
&lt;bind style='optionpanes' type='region' key='OptionPane' /&gt;
&lt;bind style='sliders' type='region' key='SliderThumb' /&gt;
&lt;bind style='sliders' type='region' key='SliderTrack' /&gt;
&lt;!-- the settingsview is for the view pane in the settings frame --&gt;
&lt;bind style='settingsview' type='name' key='SettingsView' /&gt;

&lt;/synth&gt;</t>
<t tx="zorcanda!.20050228131451">&lt;imagePainter path='/oranger.gif' method='buttonBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;   
&lt;imagePainter path='/oranger.gif' method='internalFrameBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/oranger.gif' method='internalFrameTitlePaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;




    &lt;defaultProperty key='InternalFrameTitlePane.closeButton' value='buba' /&gt; 
    &lt;property key='InternalFrameTitlePane.iconifyButton' value='co2' /&gt; 
    &lt;property key='InternalFrameTitlePane.maximizeButton' value='collapses' /&gt; 
    &lt;property key='InternalFrameTitlePane.minimizeButton' value='collapses' /&gt;    
       &lt;property key='InternalFrame.icon' value='collapses' /&gt;
       
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet ekr_stylesheet?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="1" max_tnode_index="1"/&gt;
&lt;vnodes&gt;
&lt;v t="zorcanda!.20050419181658" a="TV"&gt;&lt;vh&gt;printOutlineAsMore&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="zorcanda!.20050419181658"&gt;def printOutlineAsMore( self, *args ):

    p = self.c.rootPosition()
    nodes = []
    for v in p.allNodes_iter( copy = True): 
        head = v.moreHead( 0 )
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        s += body
        nodes.append( s )
        
    
    wholestring = '\n'.join( nodes )
    #self.sendStringToPrinter( wholestring )
    self.sendStringToJFreeReport( "", wholestring )
    
    &lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="zorcanda!.20050228132221">&lt;synth&gt;

&lt;style id='all'&gt;
    &lt;state&gt;
        &lt;opaque value='false' /&gt;
    &lt;/state&gt;
    
&lt;/style&gt;


&lt;style id='jp'&gt;
    &lt;state&gt;
    &lt;opaque value='true' /&gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
       
    &lt;/state&gt;
    
&lt;/style&gt;

&lt;bind style='all' type='region' key='.*' /&gt;
&lt;bind style='jp' type='region' key='panel' /&gt;

&lt;/synth&gt;</t>
<t tx="zorcanda!.20050307192009">&lt;synth&gt;


&lt;style id='burt'&gt;

    &lt;state&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;

    &lt;/state&gt;

&lt;/style&gt;


&lt;bind style='burt' type='region' key='TextPane' /&gt;


&lt;/synth&gt;</t>
<t tx="zorcanda!.20050312100815">@language java
import javax.swing.*;
import javax.swing.text.*;
import javax.swing.plaf.synth.*;
import java.awt.*; 
import java.io.*;




public class ASynthTest{


/*
How To use Notes:
ASynthTest is invoked like so:
java ASynthTest

You can pass a filename as the first argument and it will use that as the synth file.  It uses
the Class.getResourceAsStream method to open the file, so make sure the file is on the Classpath.
By default the class looks for a file called 'testsynth.xml'.  If it cant find it, the file will
be created in the current working directory and populated with synth data.

To specify which type of JTextComponent you wish to use, pass a number following the file name( if
there is no special file to use, type 'pass' as the first argument.  A numeric argument determines the
type of JTextComponent to use( default is a JTextPane ):
0 - JTextPane
1 - JTextArea
2 - JTextField

Experiences on Linux:
1. When the background is set by Synth, overiding that value appears to have no effect.  The new
background color only shows through if a window is placed over the top of the frame and then moved
away.
2. Foreground color does seem to be changed.



*/
    public static void main( String[] args ){
    
        
        File test = new File( "testsynth.xml" );
        if( !test.exists() )
            createTestsynthFile();
            
        final String synthfile;
        if( args.length &gt; 0 &amp;&amp; !args[ 0 ].equals( "pass" ) )
            synthfile = '/' + args[ 0 ];
        else
            synthfile = "/testsynth.xml";
            
            
        final SynthLookAndFeel slaf = new SynthLookAndFeel();
        try{
            Class clzz = slaf.getClass();
            InputStream is = clzz.getResourceAsStream( synthfile );

            if( is == null ){
            
                String message = String.format( "Synth File: %s , could not be loaded", synthfile );
                throw new IllegalArgumentException( message );
         
         
            }
            slaf.load( is, clzz );
            UIManager.setLookAndFeel( slaf );
            
         }
         catch( Exception x ){
         
            x.printStackTrace();
            System.exit( 0 );
         
         
         }
    
        
        JFrame top = new JFrame();
        top.setTitle( "Synth and JTextComponent Test" );
        top.setDefaultCloseOperation( top.EXIT_ON_CLOSE );
        top.setSize( 400, 400 );
        
        //Set JTextComponent
        JTextComponent jtc;
        if( args.length &gt; 1 ){
            
            String arg2 = args[ 1 ];
            int which = 0;
            try{
            
                which = Integer.valueOf( arg2 );
            
            
            }
            catch( NumberFormatException nfe ){
            
                nfe.printStackTrace();
                
            
            
            }
            switch( which ){
            
                case 0:
                  jtc = new JTextPane();
                  break;
                case 1:
                  jtc = new JTextArea();
                  break;
                case 2:
                  jtc = new JTextField();
                  break; 
                case 4:
                    jtc = new JTextPane2();
                    break;
                 
                default:
                  jtc = new JTextPane();
            
            
            
            }
        
        
        
        }
        else  jtc = new JTextPane();
        
        top.add( jtc );
        top.setVisible( true );
        
        System.out.println( "-----Outputing Synth set values-----" );
        String foreground = String.format( "Foreground color is %s", jtc.getForeground() );
        String background = String.format( "Background color is %s", jtc.getBackground() );
        String opaque = String.format( "Opaque value is %s", jtc.isOpaque() );
        for( String s: new String[]{ foreground, background, opaque } )
            System.out.println( s );
            
            
        jtc.setBackground( Color.BLUE );
        jtc.setForeground( Color.GREEN );
        jtc.setOpaque( true );
        
        System.out.println( "-----Outputing reset values-------" );
        foreground = String.format( "Foreground color is %s", jtc.getForeground() );
        background = String.format( "Background color is %s", jtc.getBackground() );
        opaque = String.format( "Opaque value is %s", jtc.isOpaque() );
        for( String s: new String[]{ foreground, background, opaque } )
            System.out.println( s );
        
    
    
    
    }


    private static void createTestsynthFile(){
    
        try{
            File tsf = new File( "testsynth.xml" );
            FileOutputStream fos = new FileOutputStream( tsf );
            PrintWriter pw  = new PrintWriter( fos );
            pw.println( getTestsynthData() );
            pw.close();
            System.out.println( String.format( "Created textsynth.xml in %s", tsf.getCanonicalPath() ) );
        }
        catch( Exception x ){
        
            x.printStackTrace();
            System.out.println( "Could not create testsynth.xml, moving on..." );
        
        
        }
    
    
    
    }
    
    private static String getTestsynthData(){
    
        String data ="&lt;synth&gt;\n"
        +"&lt;style id='test'&gt;\n"
        +"&lt;state&gt;\n"
        +"   &lt;color value='RED' type='BACKGROUND' /&gt;\n"
        +"   &lt;color value='BLUE' type='FOREGROUND' /&gt;\n"
        +"&lt;/state&gt;\n"
        +"&lt;/style&gt;\n"
        +"&lt;bind style='test' type='region' key='TextPane' /&gt;\n"
        +"&lt;bind style='test' type='region' key='TextArea' /&gt;\n"
        +"&lt;bind style='test' type='region' key='TextField' /&gt;\n"
        +"&lt;/synth&gt;";
    
        return data;
    
    
    
    }


    public static class JTextPane2 extends JTextPane{
    
        volatile int _background_changes = 1;
    
        public JTextPane2(){
        
            super();
           // _background_changes = 0;
        
        
        
        }
    
        public void setBackground( Color c ){
            
            System.out.println( "Color passed in is " + c );
            System.out.println( "-----Current BG Color Value is " + getBackground() );
        
            System.out.println( "----------This is Stack Trace-----------" );
            Thread.dumpStack(); 
            System.out.println( "----------This is End of Stack Trace---------" );
            super.setBackground( c );
            System.out.println( "-----Changed BG Color Value is " + getBackground() );
  
        
        }
    
    
    }



}</t>
<t tx="zorcanda!.20050313102647">&lt;synth&gt;

&lt;style id='tiger_background' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' key='TEXT_FOREGROUND' /&gt; 
        &lt;color value='WHITE' key='TEXT_BACKGROUND' /&gt;
        
        &lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;  
        &lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='desktopPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='rootPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='tableBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;

    &lt;opaque value='false' /&gt;
&lt;/style&gt;


&lt;style id ="font_base" &gt;
    &lt;font name="Arial" size='16' /&gt;
&lt;/style&gt;

&lt;style id="base" clone='font_base' &gt;
    &lt;state&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="WHITE" type='BACKGROUND' /&gt;
        &lt;color value="RED" type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='tb' clone='base' &gt;
    &lt;state&gt;
    &lt;imageIcon id='handle' path='/Leoapp2.GIF' /&gt;
    &lt;!-- I had to look at the source for SynthToolBarUI to figure this one out, handleIcon is mentioned in the property table --&gt;
    &lt;property key='ToolBar.handleIcon' value='handle' /&gt;
    &lt;property key='ToolBar.separatorSize' type='dimension' value='0 0 0 0' /&gt;

    &lt;/state&gt;
    &lt;imagePainter path='/black.gif' method='toolBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='splitpane' &gt;
    &lt;state&gt;

    &lt;property key='SplitPane.size' type='integer' value='20' /&gt;
    &lt;property key='SplitPane.oneTouchButtonSize' type='integer' value='16' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iftb' &gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='RED' type='TEXT_BACKGROUND' /&gt;
         &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED' &gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    
    &lt;opaque value='true' /&gt;
    &lt;imageIcon id='collapses' path='/orangerbar.gif' /&gt;
    &lt;imageIcon id='co2' path='/orange.gif' /&gt;
    &lt;imageIcon id='system' path='/Leoapp2.GIF' /&gt;
    &lt;imageIcon id='minimize' path='/minimize.gif' /&gt;
    &lt;imageIcon id='maximize' path='/maximize.gif' /&gt;
    &lt;imageIcon id='close' path='/close.gif' /&gt;
    &lt;imageIcon id='shrink' path='/shrink.gif' /&gt;
    &lt;property key='InternalFrameTitlePane.iconifyIcon' value='minimize' /&gt;
    &lt;property key='InternalFrameTitlePane.maximizeIcon' value='maximize' /&gt;
    &lt;property key='InternalFrameTitlePane.minimizeIcon' value='shrink' /&gt;
    &lt;property key='InternalFrameTitlePane.closeIcon' value='close' /&gt;
    &lt;property key='InternalFrame.icon' value='system' /&gt; 
    &lt;insets top='1' bottom='1' right='1' left='1' /&gt;

&lt;/style&gt;

&lt;style id='dticon' &gt;
    &lt;opaque value='true' /&gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='desktopIconBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='texts' clone='font_base' &gt;
    &lt;opaque value='true' /&gt;
    &lt;state&gt;
    &lt;/state&gt;
    
    
&lt;/style&gt;

&lt;style id='menus' clone='base' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' type="TEXT_FOREGROUND" /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;imageIcon id='mI' path='/Leoapp2.GIF' /&gt;
        &lt;property key='Menu.arrowIcon' value='mI' /&gt;
        &lt;opaque value='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='popupMenuBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/black.gif' method='menuBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
        &lt;state value='FOCUSED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='button'&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;insets top='5' left='5' right='5' bottom='5' /&gt;
        &lt;imagePainter path='/black.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;imagePainter path='/black.gif' method='buttonBorder' sourceInsets='3 3 3 3' paintCenter='false' destinationInsets='1 1 1 1' /&gt;
        &lt;property key='Button.contentAreaFilled' type='boolean' value='true' /&gt;
        &lt;object id='ins' class='java.awt.Insets' &gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
        &lt;/object&gt;
    &lt;property key='Button.margin' value='ins' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;imagePainter path='/white.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='ab'&gt;
    &lt;object class='java.lang.Integer' id='size'&gt;
        &lt;int&gt;30&lt;/int&gt;
    &lt;/object&gt;
    &lt;property key='ArrowButton.size' value='size'/&gt;
&lt;/style&gt;

&lt;style id='jlist' clone='base'&gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='ORANGE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/oranger.gif' method='listBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
    &lt;opaque value='true' /&gt;
    &lt;property key='List.rendererUseListColors' type='boolean' value='true' /&gt;
&lt;/style&gt;

&lt;style id='mbbackground' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sbar' &gt;
    

    &lt;imagePainter path='/uparrow.gif' method='arrowButtonForeground' direction='north' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/downarrow.gif' method='arrowButtonForeground' direction='south' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/rightarrow.gif' method='arrowButtonForeground' direction='east' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/leftarrow.gif' method='arrowButtonForeground' direction='west' sourceInsets='1 1 1 1' paintCenter='true' /&gt;

&lt;/style&gt;

&lt;style id='sbar2' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type="FOREGROUND" /&gt;
        &lt;color value='BLUE' type="BACKGROUND" /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/black.gif' method='scrollBarThumbBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarTrackBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='jtf' clone='base' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/orangerbar.gif' method='textFieldBorder' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;color value="WHITE" type="BACKGROUND" /&gt;
        &lt;color value="RED" type="FOREGROUND" /&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value="WHITE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="RED" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="RED" type='BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;insets top='3' bottom='3' right='3' left='3' /&gt;
&lt;/style&gt;

&lt;style id='tree'&gt;
    &lt;state&gt;
        
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED'&gt;
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;object id='reds' class='java.awt.Color' &gt;
        &lt;int&gt;255&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
    &lt;/object&gt;
    &lt;!-- its important to set this default property or the current node will not be colored --&gt;
    &lt;defaultsProperty key='Tree.selectionBackground' value='reds' /&gt;
    &lt;imageIcon id='collapse' path='/plusnode.gif' /&gt;
    &lt;imageIcon id='expand' path='/minusnode.gif' /&gt;
    
    &lt;object class='java.lang.Integer' id='rci'&gt;
        &lt;int&gt;7&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Integer' id='lci'&gt;
        &lt;int&gt;15&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Boolean' id='scrolls' &gt;
        &lt;boolean&gt;true&lt;/boolean&gt;
    &lt;/object&gt;
    &lt;property key='Tree.collapsedIcon' value='collapse' /&gt;
    &lt;property key='Tree.expandedIcon' value='expand' /&gt;
    &lt;property key='Tree.rightChildIndent' value='lci' /&gt;
    &lt;property key='Tree.leftChildIndent' value='rci' /&gt;
    &lt;property key='Tree.scrollsHorizontallyAndVertically' value='scrolls' /&gt;
&lt;/style&gt;

&lt;style id='treecell'&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND'/&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iconrenderer' &gt;
    &lt;state value='SELECTED' &gt;
        &lt;imagePainter path='/orangerbar.gif' method='labelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='jlabel' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;opaque value='false' /&gt;
&lt;/style&gt;

&lt;style id='tabbedpanetab' &gt;
    &lt;insets top='2' bottom='2' right='2' left='2' /&gt;
    &lt;imagePainter method='tabbedPaneTabBorder' path='/black.gif' sourceInsets='1 1 0 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='radios' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='unsel' path='/unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='MOUSE_OVER and SELECTED' &gt;
        &lt;imageIcon id='sel2' path='/focused_sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='sel' path='/sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='unsel2' path='/focused_unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;


&lt;style id='ckboxes' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='cunsel' path='/unsel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='SELECTED and MOUSE_OVER' &gt;
        &lt;imageIcon id='csel2' path='/sel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='csel' path='/unsel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='cunsel2' path='/sel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='leodialog' &gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
&lt;/style&gt;

&lt;style id='comboboxes' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='filechoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='fileChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='colorchoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='colorChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='optionpanes' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='optionPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sliders' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/black.gif' method='sliderThumbBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/black.gif' method='sliderTrackBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/orangerbar.gif' method='sliderThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'colorchooser_dialog'&gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id = 'settingsview' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method = 'panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'table' &gt;
    &lt;state&gt;
    
    &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    
    &lt;/state&gt;
&lt;/style&gt;

&lt;bind style='font_base' type='region' key='.*' /&gt;
&lt;bind style='tiger_background' type='region' key='MenuBar' /&gt;
&lt;bind style='tiger_background' type='region' key='ToolBar' /&gt;
&lt;bind style='tiger_background' type='region' key='SplitPane' /&gt;
&lt;bind style='tiger_background' type='region' key='DesktopPane' /&gt;
&lt;bind style='tiger_background' type='region' key='RootPane' /&gt;
&lt;bind style='table' type='region' key='Table'/&gt;
&lt;bind style='iftb' type='region' key='InternalFrame' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrameTitlePane' /&gt;
&lt;bind style='dticon' type='region' key='DesktopIcon' /&gt;
&lt;bind style="base" type="region" key="PANEL" /&gt;
&lt;!-- Note: colorchoosers dialogs contentPane are given the name cc_dialog --&gt;
&lt;bind style="colorchooser_dialog" type='name' key='cc_dialog' /&gt;
&lt;bind style='menus' type='region' key='Menu' /&gt;
&lt;bind style='menus' type='region' key='MenuItem' /&gt;
&lt;bind style='menus' type='region' key='MenuBar'  /&gt;
&lt;bind style='menus' type='region' key='MenuItemAccelerator' /&gt;
&lt;bind style='menus' type='region' key='PopupMenu' /&gt;
&lt;bind style='comboboxes' type='region' key='ComboBox' /&gt;
&lt;bind style='comboboxes' type='region' key='List' /&gt;
&lt;bind style='jtf' type='region' key='TextField' /&gt;
&lt;bind style='sbar' type='region' key='ArrowButton' /&gt;
&lt;bind style='button' type='region' key='BUTTON' /&gt;
&lt;!-- bind style="texts" type="region" key="TEXTPANE" --&gt;
&lt;bind style='texts' type='name' key='Log' /&gt;
&lt;bind style='texts' type='name' key='Editor'/&gt;
&lt;bind style="texts" type="region" key="TEXTAREA" /&gt;
&lt;bind style='tree' type='region' key='TREE' /&gt;
&lt;bind style='treecell' type='region' key='TREECELL' /&gt;
&lt;bind style='treecell' type='name' key='Tree.cellEditor' /&gt;
&lt;bind style='jlabel' type='region' key='Label' /&gt;
&lt;bind style='tb' type='region' key='TOOLBAR' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpanedivider' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpane' /&gt;
&lt;!-- note: the autocompleter list has been given the name Autolist --&gt;
&lt;bind style='jlist' type='name' key='Autolist'/&gt;
&lt;!-- note: the minibuffers background panel has been given the name Minibufferbackgrond --&gt;
&lt;bind style='mbbackground' type='name' key='Minibufferbackground' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBAR' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTRACK' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTHUMB' /&gt;
&lt;bind style='tabbedpanetab' type='region' key='TabbedPaneTab' /&gt;
&lt;bind style='radios' type='region' key='RadioButton' /&gt;
&lt;bind style='ckboxes' type='region' key='CheckBox' /&gt;
&lt;bind style='leodialog' type='name' key='Leodialog' /&gt;
&lt;bind style='iconrenderer' type='name' key='IconTreeRenderer' /&gt;
&lt;bind style='filechoosers' type='region' key='FileChooser' /&gt;
&lt;bind style='colorchoosers' type='region' key='ColorChooser' /&gt;
&lt;bind style='optionpanes' type='region' key='OptionPane' /&gt;
&lt;bind style='sliders' type='region' key='SliderThumb' /&gt;
&lt;bind style='sliders' type='region' key='SliderTrack' /&gt;
&lt;!-- the settingsview is for the view pane in the settings frame --&gt;
&lt;bind style='settingsview' type='name' key='SettingsView' /&gt;

&lt;/synth&gt;</t>
<t tx="zorcanda!.20050325115459.1">@language python
&lt;&lt; chapters declarations &gt;&gt;
@others
#@nonl
#@-node:mork.20040926105355.43:_changeTreeToPDF
#@-others
#@nonl
#@-node:mork.20040930091624.1:PDF
#@-others
    
ol_select = leoTkinterTree.leoTkinterTree.select

if Pmw and not g.app.unitTesting: # Not for unit testing:  modifies core classes.
    if g.app.gui is None: 
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        #@        &lt;&lt; override various methods &gt;&gt;
        #@+node:ekr.20041103054545:&lt;&lt; override various methods &gt;&gt;
        leoTkinterFrame.leoTkinterFrame.createCanvas = newCreateCanvas
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl
        
        leoTkinterTree.leoTkinterTree.select = newselect
        leoTkinterTree.leoTkinterTree.endEditLabel = newendEditLabel
        leoTkinterTree.leoTkinterTree.__init__ = newTreeinit
        
        g.os_path_dirname = newos_path_dirname
        
        leoFileCommands.fileCommands.write_LEO_file = newWrite_LEO_file
        leoFileCommands.fileCommands.write_Leo_file = newWrite_LEO_file
        leoFileCommands.fileCommands.getLeoFile = newGetLeoFile
        leoFileCommands.fileCommands.open = newOpen
        
        if hasattr( leoNodes.vnode, 'doDelete' ):
            leoNodes.vnode.doDelete = newTrashDelete
        else:
            leoNodes.position.doDelete = newTrashDelete
        #@nonl
        #@-node:ekr.20041103054545:&lt;&lt; override various methods &gt;&gt;
        #@nl
        g.plugin_signon( __name__ )
#@nonl
#@-node:mork.20040926105355.1:@thin chapters.py
#@-leo
</t>
<t tx="zorcanda!.20050325115459.2">#@+leo-ver=4-thin
#@+node:mork.20040926105355.1:@thin chapters.py
#@&lt;&lt;docstring&gt;&gt;
#@+node:ekr.20041109123143:&lt;&lt;docstring&gt;&gt;
'''This plugin creates separate outlines called "chapters" within a single .leo file.  Clones work between Chapters.

Requires Python Mega Widgets and Leo 4.2 or above.

Numbered tabs at the top of the body pane represent each chapter.  Right clicking the tab will show a popup menu containing commands.  These commands allow you to:
    
- insert and delete chapters.
- add names to chapters.
- split the body pane to create multiple "editors".
- create a "trash barrel that hold all deleted nodes.
- import and export outlines and chapters.
- create a pdf file from your chapters (requires reportlab toolkit at http://www.reportlab.org).
- and more...
 
Warnings:
    
- This plugin makes substantial changes to Leo's core.
- Outlines containing multiple chapters are stored as a zipped file that can only be read when this plugin has been enabled.
'''
#@nonl
#@-node:ekr.20041109123143:&lt;&lt;docstring&gt;&gt;
#@nl

# To do:  Find/Change does not appear to work.

#@@language python
#@@tabwidth -4

__version__ = "0.66"
#@&lt;&lt; version history &gt;&gt;
#@+node:ekr.20041103051117:&lt;&lt; version history &gt;&gt;
#@@killcolor
#@+at
# 
# v .2
# 
# 1. Trash. If there is a Chapter in the Leo project called 'Trash' all 
# deleted nodes are deposited there. Then when deleted in the 'Trash' chapter 
# it is finally removed. There is an option to quickly add a Trash barrel in 
# the menu.
# 2. Menu moved from Outline to being summoned by right clicking on a chapter 
# tab or in the area of the tabs.
# 3. Swapping Chapters. Swap one Chapter for another one.
# 4. Conversion ops. Take one Outline and turn each node into a Chapter. The 
# convers operation is also there, take each top level node in each Chapter 
# and add it to one Chapter.
# 5. Import/Export. You are now able to load leo files as Chapters. This 
# means, for example, that if you have 5 Outlines that you would like to bind 
# together as one Leo file but keep their separateness you can now import 
# those 5 Outlines into there own Chapters. You can also Export a single 
# Chapter into it's own separate Leo file.
# 6. Search and Clone. This functionality is very similar to the Filtered 
# Hoist concept. You decide which Chapter you want your search results to 
# appear in and a dialog will pop up. You can enter simple text or a more 
# complex regular expression and the function will search all the outlines and 
# create a node with the results as children.
# 7. Editors now have headlines indicating what Chapters and what node are 
# being worked on.
# 
# v .6 EKR: Based on version .5 by Leo User.
# 
# - Added g. before all functions in leoGlobals.py.
# - Right clicking on Chapter tab crashes.
# 
# .61 fixed up a couple of spots.
# 
# .62 EKR: Restored conditional call to g.app.createTkGui(__file__) in startup 
# code.
# 
# .63 EKR: Added long docstring.
# 
# .64 fixed cloneWalk and PDF Convertor.
# 
# .65 EKR: added new keyword args to newGetLeoFile and newOpen.
#     - This is needed because of changes to the corresponding method's in 
# Leo's core.
# 
# .66 EKR: use notebooks.get(c) throughout.
#     - c may not exist during unit testing.  Not a complete fix, not tested!
#@-at
#@nonl
#@-node:ekr.20041103051117:&lt;&lt; version history &gt;&gt;
#@nl
#@&lt;&lt; imports &gt;&gt;
#@+node:ekr.20041103050629:&lt;&lt; imports &gt;&gt;
import leoGlobals as g

import leoColor
import leoCommands
import leoFileCommands
import leoFrame
import leoNodes
import leoPlugins
import leoTkinterFrame
import leoTkinterMenu
import leoTkinterTree

Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
   
from leoTkinterFrame import leoTkinterLog
from leoTkinterFrame import leoTkinterBody

import os
import string
import sys
import time
import zipfile
#@nonl
#@-node:ekr.20041103050629:&lt;&lt; imports &gt;&gt;
#@nl
#@&lt;&lt; globals &gt;&gt;
#@+node:mork.20040926105355.2:&lt;&lt; globals &gt;&gt;
chapters = {}
notebooks = {}
frames = {}
iscStringIO = False
twidgets = {}
pbodies = {}

#@-node:mork.20040926105355.2:&lt;&lt; globals &gt;&gt;
#@nl

# Solve problems with string.atoi...
import string
string.atoi = int

#@+others
#@+node:mork.20040927092626:class Chapter
</t>
<t tx="zorcanda!.20050325115459.3">class Chapter:
    '''The fundamental abstraction in the Chapters plugin.
       It enables the tracking of Chapters tree information.'''
	&lt;&lt; class Chapter declarations &gt;&gt;
	@others
</t>
<t tx="zorcanda!.20050325115459.4">    #@    @+others
    #@+node:ekr.20041103051228:__init__
</t>
<t tx="zorcanda!.20050325115459.5">def __init__( self, c, tree, frame, canvas ):
        
    self.c = c
    self.tree = tree
    self.frame = frame
    self.canvas = canvas
    self.treeBar = frame.treeBar

    if hasattr( c, 'cChapter' ):
        tn = leoNodes.tnode( '', 'New Headline' )
        vn = leoNodes.vnode( c, tn )
        pos = leoNodes.position( vn, [] )
        self.cp = pos
        self.rp = pos
        self.tp = pos
    else:
        c.cChapter = self
        self.cp = c._currentPosition
        self.tp = c._topPosition
        self.rp = c._rootPosition
</t>
<t tx="zorcanda!.20050325115459.6">#@nonl
#@-node:ekr.20041103051228:__init__
#@+node:ekr.20041103051228.1:_saveInfo
def _saveInfo( self ):
    
    self.cp = self.c._currentPosition.copy()
    self.rp = self.c._rootPosition.copy()
    self.tp = self.c._topPosition.copy()
</t>
<t tx="zorcanda!.20050325115459.7">#@nonl
#@-node:ekr.20041103051228.1:_saveInfo
#@+node:ekr.20041103051228.2:setVariables
def setVariables( self ):
    
    c = self.c
    frame = self.frame
    frame.tree = self.tree
    frame.canvas = self.canvas
    frame.treeBar = self.treeBar
    c._currentPosition = self.cp
    c._rootPosition = self.rp
    c._topPosition = self.tp
</t>
<t tx="zorcanda!.20050325115459.8">#@-node:ekr.20041103051228.2:setVariables
#@+node:ekr.20041103051228.3:makeCurrent
def makeCurrent( self ):
    
    c = self.c
    c.cChapter._saveInfo()
    c.cChapter = self
    self.setVariables()
    c.redraw()
    self.canvas.update_idletasks()
</t>
<t tx="zorcanda!.20050325115459.9">    #@nonl
    #@-node:ekr.20041103051228.3:makeCurrent
    #@-others
#@nonl
#@-node:mork.20040927092626:class Chapter
#@+node:mork.20040930090735:Creating widgets...
#@+at
# This category deals with creating widgets and any support functions for 
# doing so.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.21:newCreateControl
cControl = leoTkinterFrame.leoTkinterBody.createControl

def newCreateControl( self, frame, parentFrame  ):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if c not in pbodies:
        parentFrame = createPanedWidget( parentFrame, c )
    pbody = pbodies[ c ]
    l, r =addHeading( parentFrame )
    ctrl = cControl( self, frame , parentFrame ) 
    ctrl.bind( "&lt;FocusIn&gt;", lambda event, body = frame.body : getGoodPage( event, body ), '+' )
    i = 1.0 / len( pbody.panes() )
    for z in pbody.panes():
        pbody.configurepane( z , size = i )
    pbody.updatelayout()
    frame.body.l =l
    frame.body.r =r 
    frame.body.editorName = editorNames[ parentFrame ]
    if frame not in twidgets:
        twidgets[ frame ] = []
    twidgets[ frame ].append( frame.body )
    l.configure( textvariable = getSV( notebook.getcurselection(), c ) )
    return ctrl
</t>
<t tx="zorcanda!.20050325115459.10">#@-node:mork.20040926105355.21:newCreateControl
#@+node:mork.20040929110556:createPanedWidget
def createPanedWidget( parentFrame, c ):
    #constructs a new panedwidget for a frame
    pbody = Pmw.PanedWidget( parentFrame , orient = 'horizontal' )
    pbody.pack( expand = 1 , fill = 'both')
    pbodies[ c ] = pbody
    parentFrame = newEditorPane( c )
    return parentFrame
</t>
<t tx="zorcanda!.20050325115459.11">#@nonl
#@-node:mork.20040929110556:createPanedWidget
#@+node:mork.20040926105355.22:newEditorPane
editorNames = {}

def newEditorPane( c ):
    names = pbodies[ c ].panes()
    if names:
        name  = str( int(names[ -1 ]) + 1 )
    else:
        name = '1'
    zpane = pbodies[ c ].add( name )
    editorNames[ zpane ] = name
    return zpane
</t>
<t tx="zorcanda!.20050325115459.12">#@-node:mork.20040926105355.22:newEditorPane
#@+node:mork.20040926105355.23:newCreateCanvas
def newCreateCanvas( self, parentFrame, createCanvas = leoTkinterFrame.leoTkinterFrame.createCanvas ):
    c = self.c
    
    if c not in frames:
        frames[ c ] = self
        notebook = createNoteBook( c, parentFrame )
    else:
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        
    pname = notebook.nameMaker.next()
    page = notebook.add( pname )
    indx = notebook.index( pname )
    tab = notebook.tab( indx )
    if indx == 0:
        tab.configure( background = 'grey', foreground = 'white' )
    canvas = createCanvas( self, page )
    
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event : hull.tmenu.post( event.x_root , event.y_root ) )
    sv = Tk.StringVar()
    page.sv = sv
    createBalloon( tab, sv )
    canvas.name = pname
    
    g.trace(repr(canvas.name),canvas)

    return canvas
</t>
<t tx="zorcanda!.20050325115459.13">#@nonl
#@-node:mork.20040926105355.23:newCreateCanvas
#@+node:mork.20040929120442:createBalloon
def createBalloon( tab, sv ):
    #creates a balloon for a widget
    balloon = Pmw.Balloon( tab , initwait = 100 )
    balloon.bind( tab , '' )
    hull = balloon.component( 'hull' )
    def blockExpose( event ):
        if sv.get() == '':
             hull.withdraw()
    hull.bind( '&lt;Expose&gt;', blockExpose, '+' )
    balloon._label.configure( textvariable = sv )
</t>
<t tx="zorcanda!.20050325115459.14">#@nonl
#@-node:mork.20040929120442:createBalloon
#@+node:mork.20040929102107:createNoteBook
def createNoteBook( c, parentFrame ):
    #constructs a NoteBook widget for a frame
    notebooks[ c ] = notebook = Pmw.NoteBook( parentFrame, borderwidth = 1, pagemargin = 0)
    hull = notebook.component( 'hull' ) 
    makeTabMenu( hull, notebook, c )
    notebook.configure( raisecommand = lambda name, notebook = notebook : setTree( name , notebook ) )
    notebook.configure( lowercommand = lambda name, notebook = notebook: lowerPage( name, notebook ) )
    notebook.pack( fill = 'both' , expand = 1)
    notebook.nameMaker = getNameMaker( notebook )
    return notebook
</t>
<t tx="zorcanda!.20050325115459.15">#@nonl
#@-node:mork.20040929102107:createNoteBook
#@+node:mork.20040929093051:getNameMaker
def getNameMaker( notebook ):
    #creates a numbering mechanism for tabs
    def nameMaker():
        i = 0
        while 1:
            if len( notebook.pagenames() ) == 0: i = 0
            i += 1
            yield str( i )
            
    return nameMaker()
</t>
<t tx="zorcanda!.20050325115459.16">#@nonl
#@-node:mork.20040929093051:getNameMaker
#@+node:mork.20040926105355.24:newTreeinit
def newTreeinit( self, c,frame,canvas, oinit = leoTkinterTree.leoTkinterTree.__init__ ):
    
    g.trace(canvas)

    sv = getSV( canvas.name, c )
    oinit( self, c, frame, canvas )
    self.chapter = chapters[ sv ] = Chapter( c, self , frame, canvas )
</t>
<t tx="zorcanda!.20050325115459.17">#@-node:mork.20040926105355.24:newTreeinit
#@+node:mork.20040926105355.25:constructTree
def constructTree( frame , notebook, name ):
    
    canvas = treeBar = tree = None
    if frame.canvas:
        canvas = frame.canvas
        treeBar = frame.treeBar
        tree = frame.tree
    sv = Tk.StringVar()
    sv.set( name )
    canvas = frame.createCanvas( None )
    frame.canvas =  canvas
    frame.tree = leoTkinterTree.leoTkinterTree( frame.c ,frame, frame.canvas)
    frame.tree.setColorFromConfig()
    indx = notebook.index( notebook.pagenames()[ -1 ] )
    tab = notebook.tab( indx )
    tnum = str( len( notebook.pagenames() ) ) 
    tab.configure( text = tnum )
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event ,hull = hull: hull.tmenu.post( event.x_root , event.y_root ) )
    return tree , notebook.page( notebook.pagenames()[ - 1 ] )
</t>
<t tx="zorcanda!.20050325115459.18">#@-node:mork.20040926105355.25:constructTree
#@+node:mork.20040926105355.26:addPage
def addPage( c , name = None ):

    frame = frames[ c ]
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if name == None : name = str( len( notebook.pagenames() ) + 1 )
    o_chapter = c.cChapter
    otree, page  = constructTree( frame, notebook, name )
    c.cChapter.makeCurrent()
    o_chapter.makeCurrent()
    return page
</t>
<t tx="zorcanda!.20050325115459.19">#@-node:mork.20040926105355.26:addPage
#@+node:mork.20040926105355.35:newEditor
def newEditor( c ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    frame = frames[ c ]
    pbody = pbodies[ c ]
    zpane = newEditorPane( c )
    af = leoTkinterBody( frame, zpane )
    c.frame.bodyCtrl = af.bodyCtrl
    af.setFontFromConfig()
    af.createBindings( frame )
    af.bodyCtrl.focus_set()
    cname = notebook.getcurselection()
    af.l.configure( textvariable = getSV(cname , c ) )
    af.r.configure( text = c.currentVnode().headString() )
</t>
<t tx="zorcanda!.20050325115459.20">#@-node:mork.20040926105355.35:newEditor
#@-others
#@nonl
#@-node:mork.20040930090735:Creating widgets...
#@+node:mork.20040930091319:tab menu stuff
#@+at
# Tab menu and factory functions for the tab menu creation process.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.41:makeTabMenu
def makeTabMenu( widget, notebook, c ):
    #creates the Menu that appears
    tmenu = Tk.Menu( widget, tearoff = 0 )
    widget.bind( '&lt;Button-3&gt;' , lambda event : tmenu.post( event.x_root , event.y_root ) )
    widget.tmenu = tmenu
    tmenu.add_command( command = tmenu.unpost )
    tmenu.add_separator()
    ac = getAddChapter( c, notebook )
    tmenu.add_command( label = 'Add Chapter', command = ac )
    rmenu = Tk.Menu( tmenu , tearoff = 0 )    
    remove = getRemove( notebook, c, rmenu )
    rmenu.configure( postcommand = remove )        
    tmenu.add_cascade( menu = rmenu, label = "Remove Chapter" )
    rename = getRename( notebook )
    tmenu.add_command( label = "Add/Change Title" , command = rename )
    opmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = opmenu , label = 'Node-Chapter Ops' )
    cmenu = Tk.Menu( opmenu, tearoff = 0 )
    movmenu = Tk.Menu( opmenu, tearoff = 0 )
    copymenu = Tk.Menu( opmenu, tearoff = 0 )
    swapmenu = Tk.Menu( opmenu, tearoff = 0 )
    searchmenu = Tk.Menu( opmenu, tearoff = 0 )
    opmenu.add_cascade( menu = cmenu, label = 'Clone To Chapter' )
    opmenu.add_cascade( menu = movmenu, label = 'Move To Chapter' )
    opmenu.add_cascade( menu = copymenu, label = 'Copy To Chapter' )
    opmenu.add_cascade( menu = swapmenu, label = 'Swap With Chapter' )
    opmenu.add_cascade( menu = searchmenu, label = 'Search and Clone To' )
    opmenu.add_command( label ="Make Node Into Chapter", command = lambda c=c:  makeNodeIntoChapter( c ) )
    mkTrash = getMakeTrash( notebook )
    opmenu.add_command( label = "Add Trash Barrel", command =
    lambda c = c : mkTrash( c ))
    opmenu.add_command( label = 'Empty Trash Barrel', command =
    lambda notebook = notebooks.get(c), c = c: emptyTrash( notebook, c ) )
    setupMenu = getSetupMenu( c, notebook )
    cmenu.configure(
        postcommand = lambda menu = cmenu, command = cloneToChapter : setupMenu( menu, command ) )
    movmenu.configure(
        postcommand = lambda menu = movmenu, command = moveToChapter : setupMenu( menu, command ) )
    copymenu.configure(
        postcommand = lambda menu = copymenu, command = copyToChapter : setupMenu( menu, command ) ) 
    swapmenu.configure( postcommand = 
    lambda menu = swapmenu, command = swapChapters : setupMenu( menu, command ) )
    searchmenu.configure( postcommand = lambda menu = searchmenu,
    command = regexClone: setupMenu( menu, command, all = True ) )
    edmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = "Editor", menu = edmenu )
    edmenu.add_command( label = "Add Editor" , command = lambda c =c : newEditor( c ) ) 
    edmenu.add_command( label = "Remove Editor", command = lambda c = c : removeEditor( c ) )
    conmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = conmenu, label = 'Conversion' )
    conmenu.add_command(
        label = "Convert To Simple Outline",
        command = lambda c =c : conversionToSimple( c ) )
    conmenu.add_command(
        label = "Convert Simple Outline into Chapters",
        command = lambda c= c : conversionToChapters( c ) )
    iemenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade(label = 'Import/Export', menu = iemenu )
    iemenu.add_command( label = "Import Leo File ", command = lambda c = c: importLeoFile(c ) )
    iemenu.add_command( label = "Export Chapter To Leo File", command = lambda c =c : exportLeoFile( c ) )
    indmen = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = 'Index', menu = indmen )
    indmen.add_command( label = 'Make Index', command = lambda c =c : viewIndex( c ) )
    indmen.add_command( label = 'Make Regex Index', command = lambda c =c : regexViewIndex( c ) ) 
    try:
        import reportlab
        tmenu.add_command( label = 'Convert To PDF', command = lambda c = c: doPDFConversion( c ) )
    except Exception: 
        g.es( "no reportlab" )
</t>
<t tx="zorcanda!.20050325115459.21">#@nonl
#@-node:mork.20040926105355.41:makeTabMenu
#@+node:mork.20040930091319.1:function factories
#@+others
#@+node:mork.20040928224349:getAddChapter
def getAddChapter( c , notebook ):
    #a function that makes a function to add chapters  
    def ac( c = c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        cname = notebook.getcurselection()
        addPage( c )        
        renumber( notebook)
    
    return ac
</t>
<t tx="zorcanda!.20050325115459.22">#@nonl
#@-node:mork.20040928224349:getAddChapter
#@+node:mork.20040928223221:getRemove
def getRemove( notebook, c , rmenu ):
    #a function that makes a function to remove chapters
    def remove():
        rmenu.delete( 0 , Tk.END )
        pn = notebook.pagenames()
        for i, z in enumerate( pn ):
            i = i + 1
            def rmz( name = z):
                if len( notebook.pagenames() ) == 1: return
                sv = getSV( name )
                chapter = chapters[ sv ]
                tree = chapter.tree
                vnd = chapter.rp
                cvnd = c.cChapter.cp
                c.beginUpdate()
                otree = c.cChapter.tree
                c.frame.tree = tree
                if vnd:
                    v = vnd                    
                    nnd = vnd.next()
                    if nnd == None:
                        nnd = vnd.insertAfter()
                        vnd = None
                    v.doDelete( nnd )
                c.frame.tree = otree
                c.endUpdate()
                notebook.delete( name )
                if tree != otree:
                    c.selectPosition( cvnd )
                if tree == otree:
                    pnames = notebook.pagenames()
                    notebook.selectpage( pnames[ 0 ] )
                    c.selectPosition( c.currentPosition() )
                    c.beginUpdate()
                    c.endUpdate()
                renumber( notebook )
            rmenu.add_command( label = str( i ) , command = rmz )  
              
    return remove
</t>
<t tx="zorcanda!.20050325115459.23">#@-node:mork.20040928223221:getRemove
#@+node:mork.20040928223738:getRename
def getRename( notebook ):
    #a function that makes a function to rename chapters
    def rename( rnframes = {} ):
        name = notebook.getcurselection()
        frame = notebook.page( notebook.index( name ) )
        fr = frames[ g.top() ]
        if not rnframes.has_key( frame ):
            f = rnframes[ frame ] = Tk.Frame( frame )
            e = Tk.Entry( f , background = 'white', textvariable = frame.sv )
            b = Tk.Button( f , text = "Close" ) 
            e.pack( side = 'left' )
            b.pack( side = 'right' )
            def change():
                f.pack_forget()
            b.configure( command = change )
        else:
            f = rnframes[ frame ]
            if f.winfo_viewable() : return None
        fr.canvas.pack_forget()
        f.pack( side = 'bottom' )
        fr.canvas.pack( fill = 'both', expand = 1 )

    return rename
</t>
<t tx="zorcanda!.20050325115459.24">#@nonl
#@-node:mork.20040928223738:getRename
#@+node:mork.20040928224049:getMakeTrash
def getMakeTrash( notebook ):
    #a function that makes a function to add a trash chapters
    def mkTrash( c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        addPage( c, 'Trash' )
        pnames = notebook.pagenames()
        sv = getSV( pnames[ - 1 ], c )
        sv.set( 'Trash' )
        renumber( notebook )
    
    return mkTrash    
</t>
<t tx="zorcanda!.20050325115459.25">#@-node:mork.20040928224049:getMakeTrash
#@+node:mork.20040928224621:getSetupMenu
def getSetupMenu( c, notebook ):
    #a function that makes a function to populate a menu
    def setupMenu( menu , command , all = False):
        menu.delete( 0 , Tk.END )
        current = notebook.getcurselection()
        for i, z in  enumerate( notebook.pagenames() ):
            i = i + 1
            if z == current and not all: continue
            menu.add_command( label = str( i ) , command = lambda c = c , name = z : command( c, name ) )
            
    return setupMenu
</t>
<t tx="zorcanda!.20050325115459.26">#@nonl
#@-node:mork.20040928224621:getSetupMenu
#@-others
#@nonl
#@-node:mork.20040930091319.1:function factories
#@-others
#@nonl
#@-node:mork.20040930091319:tab menu stuff
#@+node:mork.20040930092346:Multi-Editor stuff
#@+others
#@+node:mork.20040929104527:selectNodeForEditor
def selectNodeForEditor( c, body ):
    #sets the node for the new editor
    if not hasattr( body, 'lastNode' ):
        body.lastNode = c.currentPosition()

    if body.lastNode == c.currentPosition(): return    
    elif body.lastNode.exists( c ):
        c.selectPosition( body.lastNode )
    else:
        c.selectPosition( c.rootPosition() )

    body.lastNode = c.currentPosition()    
</t>
<t tx="zorcanda!.20050325115459.27">#@nonl
#@-node:mork.20040929104527:selectNodeForEditor
#@+node:mork.20040929105638:activateEditor
def activateEditor( body ):
    #performs functions that brings editor on line
    body.r.configure( text = body.lastNode.headString() )
    ip = body.lastNode.t.insertSpot
    txt = body.lastNode.bodyString()
    body.deleteAllText()
    body.insertAtEnd( txt )
    if ip : body.setInsertionPoint( ip )
    body.colorizer.colorize( body.lastNode )
    body.bodyCtrl.update_idletasks()
</t>
<t tx="zorcanda!.20050325115459.28">#@nonl
#@-node:mork.20040929105638:activateEditor
#@+node:mork.20040926105355.36:removeEditor
def removeEditor( c ):
    pbody = pbodies[ c ]
    if len( pbody.panes() ) == 1: return None
    body = c.frame.body
    pbody.delete( body.editorName )
    pbody.updatelayout()
    panes = pbody.panes()
    twidgets[ c.frame ].remove( body )
    nBody = twidgets[ c.frame ][ 0 ] 
    nBody.bodyCtrl.focus_set()
    nBody.bodyCtrl.update_idletasks()
</t>
<t tx="zorcanda!.20050325115459.29">#@-node:mork.20040926105355.36:removeEditor
#@+node:mork.20040926105355.44:addHeading
def addHeading( pane ):
    f = Tk.Frame( pane )
    f.pack( side = 'top' )
    l = Tk.Label( f )
    l.pack( side = 'left' )
    r = Tk.Label( f )
    r.pack( side = 'right' )
    return l , r
</t>
<t tx="zorcanda!.20050325115459.30">#@-node:mork.20040926105355.44:addHeading
#@-others
#@nonl
#@-node:mork.20040930092346:Multi-Editor stuff
#@+node:mork.20040930090547:Indexing
#@+at
# Indexing is complementary to find, it provides a gui Index of nodes.  In 
# comparison to regular find which bounces you around the tree, you can 
# preview the node before you go to it.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.3:viewIndex
def viewIndex( c , nodes = None, tle = '' ):
    if nodes == None:
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
    def aN( a ):
        n = a[ 0 ].headString()
        return n, a[ 0 ], a[ 1 ]
    nodes = map( aN, nodes )
    nodes.sort()
    tl = Tk.Toplevel()
    import time    
    title = "%s Index of %s created at %s" % ( tle, c.frame.shortFileName(), time.ctime())
    tl.title( title )
    f = Tk.Frame( tl )
    f.pack( side = 'bottom' )
    l = Tk.Label( f, text = 'ScrollTo:' )
    e = Tk.Entry( f , bg = 'white', fg = 'blue')
    l.pack( side = 'left' )
    e.pack( side ='left' )
    b = Tk.Button( f, text = 'Close' )
    b.pack( side = 'left' )
    def rm( tl = tl ):
        tl.withdraw()
        tl.destroy()
    b.configure( command = rm )
    sve = Tk.StringVar()
    e.configure( textvariable = sve )
    ms = tl.maxsize()
    tl.geometry( '%sx%s+0+0' % (ms[ 0 ], (ms[ 1 ]/4 )*3 ))
    sc = Pmw.ScrolledCanvas( tl , vscrollmode = 'static', hscrollmode = 'static', 
    usehullsize = 1, borderframe = 1, hull_width = ms[ 0 ], hull_height = (ms[ 1 ]/4 )*3 )
    sc.pack()
    can = sc.interior()
    can.configure( background = 'white' )
    bal = Pmw.Balloon( can )
    
    tags = {}
    #ltag = None
    buildIndex( nodes , c, can, tl, bal, tags)            
    sc.resizescrollregion()
    def scTo( event , nodes = nodes, sve = sve , can = can , tags = tags):
        t = sve.get()
        if event.keysym == 'BackSpace':
            t = t[ : -1 ]
        else:
            t = t + event.char
        if t == '': return
        for z in nodes:
            if z[ 0 ].startswith( t ) and tags.has_key( z[ 1 ] ):
                tg = tags[ z[ 1 ] ]
                eh = can.bbox( ltag )[ 1 ]
                eh = (eh *1.0)/100
                bh = can.bbox( tg )[ 1 ]
                ncor = (bh/ eh) * .01 
                can.yview( 'moveto' , ncor)
                return

    e.bind( '&lt;Key&gt;', scTo )
    e.focus_set()
</t>
<t tx="zorcanda!.20050325115459.31">#@-node:mork.20040926105355.3:viewIndex
#@+node:mork.20040929121409:buildIndex
def buildIndex( nodes , c , can, tl, bal, tags):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import tkFont
    f = tkFont.Font()
    f.configure( size = -20 )
    ltag = None
    for i,z in enumerate(nodes):
        tg = 'abc' + str( i ) 
        parent = z[ 1 ].parent()
        if parent: parent = parent.headString()
        else:
            parent = 'No Parent'
        sv = getSV( z[ 2 ] )
        if sv.get(): sv = ' - ' + sv.get()
        else: sv = ''
        
        tab = notebook.tab( z[ 2 ] )
        tv = tab.cget( 'text' )
        isClone = z[ 1 ].isCloned()
        if isClone:
            clone = ' (Clone) '
        else:
            clone =''
        txt = '%s  , parent: %s , chapter: %s%s%s' %( z[ 0 ], parent, tv, sv, clone)
        ltag = tags[ z[1] ] = can.create_text( 20, i * 20 + 20, text = txt, fill = 'blue', font = f , anchor = Tk.W, tag = tg )
        bs = z[ 1 ].bodyString()
        if bs.strip() != '':
            bal.tagbind( can, tg, bs)
        def goto( event, z = z , c = c, tl = tl):
            notebook = notebooks.get(c)
            if not notebook: return # For unit testing
            notebook.selectpage( z[ 2 ] )
            c.selectVnode( z[ 1 ] )
            c.frame.outerFrame.update_idletasks()
            c.frame.outerFrame.event_generate( '&lt;Button-1&gt;' )
            c.frame.bringToFront()
            return 'break'
        def colorRd( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'red' )
        def colorBl( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'blue' )
        can.tag_bind( tg, '&lt;Button-1&gt;', goto )
        can.tag_bind( tg, '&lt;Enter&gt;', colorRd, '+' )
        can.tag_bind( tg, '&lt;Leave&gt;', colorBl, '+' )    
</t>
<t tx="zorcanda!.20050325115459.32">#@-node:mork.20040929121409:buildIndex
#@+node:mork.20040926105355.4:regexViewIndex
def regexViewIndex( c ):
    
    def regexWalk( result, entry, widget ):
        txt = entry.get()
        widget.deactivate()        
        widget.destroy()
        if result == 'Cancel': return None
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
        import re
        regex = re.compile( txt )
        def search( nd, regex = regex ):
            return regex.search( nd[ 0 ].bodyString() )
        nodes = filter( search , nodes )
        viewIndex( c, nodes , 'Regex( %s )'%txt )
        return

    sd = Pmw.PromptDialog( c.frame.top,
    title = 'Regex Index',
    buttons = ( 'Search', 'Cancel' ),
    command =regexWalk )
    entry = sd.component( 'entry' )
    sd.configure( command = 
        lambda result, entry = entry, widget = sd:
            regexWalk( result, entry, widget ) )      
    sd.activate(  geometry = 'centerscreenalways' )   
</t>
<t tx="zorcanda!.20050325115459.33">#@-node:mork.20040926105355.4:regexViewIndex
#@-others
#@-node:mork.20040930090547:Indexing
#@+node:mork.20040930094729:Chapter-Notebook ops
#@+others
#@+node:mork.20040926105355.5:renumber
def renumber( notebook ):
    pagenames = notebook.pagenames()
    for i , z in enumerate(pagenames):
        i = i +1
        tab = notebook.tab( z )
        tab.configure( text = str( i ) )
</t>
<t tx="zorcanda!.20050325115459.34">#@-node:mork.20040926105355.5:renumber
#@+node:mork.20040926105355.6:getGoodPage
def getGoodPage( event , body ):
    global focusing
    c = body.c 
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    body.frame.body = body
    body.frame.bodyCtrl = body.bodyCtrl
    if not hasattr( body, 'lastChapter' ):
        body.lastChapter = notebook.getcurselection()
    page = checkChapterValidity( body.lastChapter, c )
    if page != notebook.getcurselection():
        body.lastChapter = page
        notebook.selectpage( page )
    selectNodeForEditor( c, body )         
    activateEditor( body )
</t>
<t tx="zorcanda!.20050325115459.35">#@nonl
#@-node:mork.20040926105355.6:getGoodPage
#@+node:mork.20040926105355.7:checkChapterValidity
def checkChapterValidity( name , c):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    try:
        notebook.index( name )
    except:
        return notebook.getcurselection()            
    return name
</t>
<t tx="zorcanda!.20050325115459.36">#@-node:mork.20040926105355.7:checkChapterValidity
#@+node:mork.20040926105355.20:getSV
def getSV( name, c = None ):
    #returns a Tk StrinVar that is a primary identifier
    if not c : c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    index = notebook.index( name )
    page = notebook.page( index )
    return page.sv
</t>
<t tx="zorcanda!.20050325115459.37">#@-node:mork.20040926105355.20:getSV
#@+node:mork.20040926105355.27:setTree
def setTree( name , notebook , c = None ):

    if not c: 
        c = g.top()
        if not c: return None
    pindex = notebook.index( name )
    page = notebook.page( pindex )
    if not hasattr( page, 'sv' ) : return None
    sv = page.sv
    chapter = chapters[ sv ]
    chapter.makeCurrent()
    frame = c.frame
    frame.body.lastChapter = name
    frame.body.lastNode = chapter.cp
    frame.body.l.configure( textvariable = sv )
    tab = notebook.tab( pindex )
    tab.configure( background = 'grey', foreground = 'white' )
    activateEditor( frame.body )
</t>
<t tx="zorcanda!.20050325115459.38">#@-node:mork.20040926105355.27:setTree
#@+node:mork.20040929084846:lowerPage
def lowerPage( name, notebook):
    # a function that sets a lowered tabs color
    pindex = notebook.index( name )
    tab = notebook.tab( pindex )
    tab.configure( background = 'lightgrey', foreground = 'black' )
</t>
<t tx="zorcanda!.20050325115459.39">#@nonl
#@-node:mork.20040929084846:lowerPage
#@+node:mork.20040926105355.40:walkChapters
def walkChapters( c = None, ignorelist = [], chapname = False):
    # a generator that allows one to walk the chapters as one big tree
    if c == None : c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    for z in pagenames:
        sv = getSV( z , c)
        chapter = chapters[ sv ]
        v = chapter.rp
        while v:
            if chapname:
                if v not in ignorelist: yield v, z
            else:
                if v not in ignorelist:  yield v
            v = v.threadNext()
</t>
<t tx="zorcanda!.20050325115459.40">#@-node:mork.20040926105355.40:walkChapters
#@-others
#@nonl
#@-node:mork.20040930094729:Chapter-Notebook ops
#@+node:mork.20040930091035:opening and closing
#@+at
# This category is for opening and closing of Leo files.  We need to decorate 
# and be tricky here, since a Chapters leo file is a zip file.  These 
# functions are easy to break in my experience. :)
#@-at
#@@c
#@+others
#@+node:mork.20040930091035.1:opening
#@+others
#@+node:mork.20040926105355.28:newGetLeoFile
oldGetLeoFile =  leoFileCommands.fileCommands.getLeoFile

def newGetLeoFile(self, fileName,readAtFileNodesFlag=True ):
    if iscStringIO:
        def dontSetReadOnly( self, name, value ):
            if name == 'read_only': return
            elif name == 'tnodesDict': return
            else:
                self.__dict__[ name ] = value
        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly
    rt = oldGetLeoFile(self,fileName,readAtFileNodesFlag)
    if iscStringIO:
        del self.__class__.__setattr__       
    return rt
</t>
<t tx="zorcanda!.20050325115459.41">#@nonl
#@-node:mork.20040926105355.28:newGetLeoFile
#@+node:mork.20040926105355.29:newOpen
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag)
</t>
<t tx="zorcanda!.20050325115459.42">#@nonl
#@-node:mork.20040926105355.29:newOpen
#@+node:mork.20040926105355.9:openChaptersFile
def openChaptersFile( fileName ):
    zf = zipfile.ZipFile( fileName )
    import cStringIO
    file = cStringIO.StringIO()
    name = zf.namelist()
    csfiles = [ [], [] ]
    for x in name :
        zi = zf.getinfo( x )
        csfiles[ 0 ].append( zi.comment )
        cs = cStringIO.StringIO()
        csfiles[ 1 ].append( cs )           
        cs.write( zf.read( x ) )
        cs.seek( 0 )          
    zf.close()
    csfiles = zip( csfiles[ 0 ], csfiles[ 1 ] )
    return csfiles
</t>
<t tx="zorcanda!.20050325115459.43">#@-node:mork.20040926105355.9:openChaptersFile
#@+node:mork.20040926105355.8:insertChapters
def insertChapters( chapters, frame, c ):
     notebook = notebooks.get(c)
     if not notebook: return # For unit testing
     pagenames = notebook.pagenames()
     for num, tup  in enumerate( chapters ):
            x, y = tup
            if num &gt; 0:
                sv = addPage( c, x ).sv
                notebook.nextpage()
                cselection = notebook.getcurselection()
            else:
                cselection = notebook.getcurselection()
                sv = getSV( cselection , c )
            sv.set( x )
            next = cselection
            setTree( next , notebook, c )
            frame.c.fileCommands.open( y, sv.get() )
            if num == 0:
                flipto = cselection
     setTree( flipto, notebook, c )
     c.frame.canvas.update_idletasks()
</t>
<t tx="zorcanda!.20050325115459.44">#@nonl
#@-node:mork.20040926105355.8:insertChapters
#@-others
#@nonl
#@-node:mork.20040930091035.1:opening
#@+node:mork.20040930091035.2:closing
#@+others
#@+node:mork.20040926105355.30:newWrite_LEO_file
def newWrite_LEO_file( self,fileName,outlineOnlyFlag, singleChapter = False):
    
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    at = c.atFileCommands
    if len( pagenames ) &gt; 1 and not singleChapter:        
        chapList = []
        self.__class__.__setattr__ =  getMakeStringIO( chapList )
        rv = writeChapters( self, fileName, pagenames, c , outlineOnlyFlag )
        if rv:
            zipChapters( fileName, pagenames, c, chapList )
        del self.__class__.__setattr__         
    else:
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )

    return rv
</t>
<t tx="zorcanda!.20050325115459.45">#@-node:mork.20040926105355.30:newWrite_LEO_file
#@+node:mork.20040929092231:getMakeStringIO
def getMakeStringIO( chapList ):
    #insures data is put in a StringIO instance
    def makeStringIO( self, name, value , cList = chapList):
        if name == 'outputFile' and value != None:
            import StringIO
            cS = StringIO.StringIO()
            cS.close = lambda : None
            self.__dict__[ name ] = cS
            cList.append( cS )
        elif name == 'outputFile' and value == None:
            self.__dict__[ name ] = None
        else:
            self.__dict__[ name ] = value 
            
    return makeStringIO
</t>
<t tx="zorcanda!.20050325115459.46">#@nonl
#@-node:mork.20040929092231:getMakeStringIO
#@+node:mork.20040929090525:writeChapters
def writeChapters( self, fileName, pagenames, c , outlineOnlyFlag):
    #goes over Chapters and puts info in StringIO instances
    for z in pagenames:
        sv = getSV( z, c )
        chapter = chapters[ sv ]
        chapter.setVariables()
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )    
    c.cChapter.setVariables()
    return rv
</t>
<t tx="zorcanda!.20050325115459.47">#@nonl
#@-node:mork.20040929090525:writeChapters
#@+node:mork.20040929090525.1:zipChapters
def zipChapters( fileName, pagenames, c, chapList ):
    #takes list of StringIO instances and zips them to a file
    zf = zipfile.ZipFile( fileName, 'w',  zipfile.ZIP_DEFLATED )
    for x ,fname in enumerate( pagenames ):
        sv = getSV( fname, c )
        zif = zipfile.ZipInfo( str( x ) )
        zif.comment = sv.get()
        zif.compress_type = zipfile.ZIP_DEFLATED
        chapList[ x ].seek( 0 )
        zf.writestr( zif ,chapList[ x ].read() )
    zf.close()
</t>
<t tx="zorcanda!.20050325115459.48">#@nonl
#@-node:mork.20040929090525.1:zipChapters
#@-others
#@nonl
#@-node:mork.20040930091035.2:closing
#@-others
#@nonl
#@-node:mork.20040930091035:opening and closing
#@+node:mork.20040930091624:decorated Leo functions
#@+at
# I prefer decorating Leo functions as opposed to patching them.  Patching 
# them leads to long term incompatibilites with Leo and the plugin.  Though 
# this happens anyway with code evolution/changes, this makes it worse.  Thats 
# my experience with it. :)
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.34:newos_path_dirname
olos_pat_dirname  = g.os_path_dirname
def newos_path_dirname( path, encoding = None ):
    if iscStringIO:
        c = g.top()
        return os.path.dirname( c.mFileName )
    else:
        return olos_pat_dirname( path, encoding )
</t>
<t tx="zorcanda!.20050325115459.49">#@-node:mork.20040926105355.34:newos_path_dirname
#@+node:mork.20040926105355.45:newendEditLabel
olEditLabel = leoTkinterTree.leoTkinterTree.endEditLabel
def newendEditLabel( self ):
    
    c = self.c
    rv = olEditLabel( self )
    v = c.currentPosition()
    if v and hasattr( c.frame.body, 'r'): 
        hS = v.headString()
        if hS:
            c.frame.body.r.configure( text = v.headString() )
    return rv
</t>
<t tx="zorcanda!.20050325115459.50">#@-node:mork.20040926105355.45:newendEditLabel
#@+node:mork.20040926105355.52:newselect
def newselect (self, v , updateBeadList = True):
    
    self.frame.body.lastNode = v
    notebook = notebooks.get(v.c)
    if not notebook: return # For unit testing
    self.frame.body.lastChapter = notebook.getcurselection()
    rv = ol_select( self , v, updateBeadList )
    if hasattr( v.c.frame.body, 'r' ):
        v.c.frame.body.r.configure( text = v.headString() )
    return rv
</t>
<t tx="zorcanda!.20050325115459.51">#@nonl
#@-node:mork.20040926105355.52:newselect
#@+node:mork.20040926105355.49:newTrashDelete
if hasattr( leoNodes.vnode, 'doDelete' ):
    olDelete = leoNodes.vnode.doDelete
else:
    olDelete = leoNodes.position.doDelete
def newTrashDelete(  self, newVnode):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    pagenames = [ getSV( x, c ).get().upper() for x in pagenames ]
    nbnam = notebook.getcurselection()
    if nbnam != None:
        name = getSV( notebook.getcurselection() , c ).get().upper()
    else: name = 'TRASH'
    tsh = 'TRASH'
    if name != tsh and tsh in pagenames:
        index = pagenames.index( tsh )
        trchapter = chapters[ getSV( index, c ) ]
        trashnode = trchapter.rp
        trchapter.setVariables()
        self.moveAfter( trashnode )
        c.cChapter.setVariables()
        c.selectVnode( newVnode )        
        return self
    olDelete( self, newVnode )
</t>
<t tx="zorcanda!.20050325115459.52">#@-node:mork.20040926105355.49:newTrashDelete
#@-others
#@nonl
#@-node:mork.20040930091624:decorated Leo functions
#@+node:mork.20040930091759:operation( node ) to Chapter
#@+others
#@+node:mork.20040926105355.31:cloneToChapter
if hasattr( leoFileCommands.fileCommands, 'write_LEO_file' ):
    olWrite_LEO_file = leoFileCommands.fileCommands.write_LEO_file
else:
    olWrite_LEO_file = leoFileCommands.fileCommands.write_Leo_file
    

def cloneToChapter( c , name ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    c.beginUpdate()
    vnd = c.currentPosition()
    clo = vnd.clone( vnd )
    clChapter = chapters[ page.sv ]
    vndm = clChapter.cp
    clo.unlink()
    clo.linkAfter(vndm)
    c.endUpdate()
</t>
<t tx="zorcanda!.20050325115459.53">#@-node:mork.20040926105355.31:cloneToChapter
#@+node:mork.20040926105355.32:moveToChapter
def moveToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    mvChapter = chapters[ page.sv ]
    c.beginUpdate()
    vnd = c.currentVnode()
    if  not vnd.parent() and not vnd.back() :
        c.endUpdate()
        return None
    vndm = mvChapter.cp
    vnd.unlink()
    vnd.linkAfter(vndm)
    c.endUpdate()
    c.selectVnode( c.rootVnode() )
</t>
<t tx="zorcanda!.20050325115459.54">#@-node:mork.20040926105355.32:moveToChapter
#@+node:mork.20040926105355.33:copyToChapter
def copyToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    cpChapter = chapters[ page.sv ]
    c.beginUpdate()
    s = c.fileCommands.putLeoOutline()
    v = c.fileCommands.getLeoOutline( s )
    cpChapter.setVariables()
    mvnd = cpChapter.cp
    v.moveAfter( mvnd )
    c.cChapter.setVariables()
    c.endUpdate()
</t>
<t tx="zorcanda!.20050325115459.55">#@-node:mork.20040926105355.33:copyToChapter
#@+node:mork.20040926105355.39:makeNodeIntoChapter
def makeNodeIntoChapter( c, vnd = None ):
    renum = vnd
    if vnd == None:
        vnd = c.currentPosition()
    if vnd == c.rootPosition() and vnd.next() == None:
        return
    nxt = vnd.next()
    if nxt:
        vnd.doDelete( nxt )
        
    page = addPage( c )
    mnChapter = chapters[ page.sv ]
    c.beginUpdate()
    oChapter = c.cChapter
    mnChapter.makeCurrent()
    root = mnChapter.rp
    vnd.moveAfter( root )
    c.setRootPosition( vnd )
    oChapter.makeCurrent()
    c.endUpdate()
    if not renum:
        notebook = notebooks.get(c)
        if notebook: # For unit testing
            renumber(notebook)
    c.selectPosition( oChapter.rp )
</t>
<t tx="zorcanda!.20050325115459.56">#@-node:mork.20040926105355.39:makeNodeIntoChapter
#@-others
#@nonl
#@-node:mork.20040930091759:operation( node ) to Chapter
#@+node:mork.20040930092027:conversions
#@+others
#@+node:mork.20040926105355.37:conversionToSimple
def conversionToSimple( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        n = vnd.next()
        if n == None:
            break
        else:
            vnd = n
    pagenames = notebook.pagenames()
    current = notebook.getcurselection()
    pagenames.remove( current )
    c.beginUpdate()
    for z in pagenames:
        index = notebook.index( z )
        page = notebook.page( index )
        chapter = chapters[ page.sv ]
        rvNode = chapter.rp
        while 1:
            nxt = rvNode.next()
            rvNode.moveAfter( vnd )
            if nxt: rvNode = nxt
            else:
                vnd = rvNode 
                break
        notebook.delete( z )
    c.endUpdate()
    renumber( notebook )       
</t>
<t tx="zorcanda!.20050325115459.57">#@-node:mork.20040926105355.37:conversionToSimple
#@+node:mork.20040926105355.38:conversionToChapters
def conversionToChapters( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        nxt = vnd.next()
        if nxt:
            makeNodeIntoChapter(c , nxt )
        else:
            break
    setTree( notebook.pagenames()[ 0 ], notebook , c )     
</t>
<t tx="zorcanda!.20050325115459.58">#@-node:mork.20040926105355.38:conversionToChapters
#@-others
#@nonl
#@-node:mork.20040930092027:conversions
#@+node:mork.20040930092027.1:import/export
#@+at
# Import a Leo file as a Chapter(s).  Export a Chapter as a single Leo file.  
# Kinda handy.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.47:importLeoFile
def importLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.askopenfilename()
    if name:
        page = addPage( c , name )
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing       
        notebook.selectpage( notebook.pagenames()[ - 1 ] )
        c.fileCommands.open( file( name, 'r' ), name )
        c.cChapter.makeCurrent()
        renumber( notebook )
</t>
<t tx="zorcanda!.20050325115459.59">#@-node:mork.20040926105355.47:importLeoFile
#@+node:mork.20040926105355.48:exportLeoFile
def exportLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.asksaveasfilename()
    if name:
        if not name.endswith('.leo' ):
            name += '.leo'
        c.fileCommands.write_LEO_file( name, False, singleChapter = True )
</t>
<t tx="zorcanda!.20050325115459.60">#@-node:mork.20040926105355.48:exportLeoFile
#@-others
#@nonl
#@-node:mork.20040930092027.1:import/export
#@+node:mork.20040930092207:functions without classification
#@+at
# couldn't think of any parent node to group these under.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.46:swapChapters
def swapChapters( c, name ):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    cselection = notebook.getcurselection()
    tab1 = notebook.tab( cselection )
    tab2 = notebook.tab( name )
    tval1 = tab1.cget( 'text' )
    tval2 = tab2.cget( 'text' )
    tv1 = getSV( cselection, c )
    tv2 = getSV( name, c )
    chap1 = c.cChapter
    chap2 = chapters[ tv2 ]
    rp, tp, cp = chap2.rp, chap2.tp, chap2.cp
    chap2.rp, chap2.tp, chap2.cp = chap1.rp, chap1.tp, chap1.cp
    chap1.rp, chap1.tp, chap1.cp = rp, tp, cp
    chap1.setVariables()
    c.redraw()
    chap1.canvas.update_idletasks()
  
    val1 = tv1.get()
    val2 = tv2.get()
    if  val2.isdigit() :
        tv1.set( notebook.index( cselection ) + 1 ) 
    else: tv1.set( val2 )
    if val1.isdigit() :
        tv2.set( notebook.index( name ) + 1 )
    else: tv2.set( val1 )
</t>
<t tx="zorcanda!.20050325115459.61">#@-node:mork.20040926105355.46:swapChapters
#@+node:mork.20040926105355.50:emptyTrash
def emptyTrash( notebook  , c):
    pagenames = notebook.pagenames()
    pagenames = [ getSV( x, c ) for x in pagenames ]
    for z in pagenames:
        if z.get().upper() == 'TRASH':
            trChapter = chapters[ z ]
            rvND = trChapter.rp
            c.beginUpdate()
            trChapter.setVariables()
            nRt = rvND.insertAfter()
            nRt.moveToRoot()
            trChapter.rp = c.rootPosition()
            trChapter.cp = c.currentPosition()
            trChapter.tp = c.topPosition()
            c.cChapter.setVariables()
            c.endUpdate( False )
            if c.cChapter == trChapter:
                c.selectPosition( nRt )
                c.redraw()
                trChapter.canvas.update_idletasks()
            return
</t>
<t tx="zorcanda!.20050325115459.62">#@-node:mork.20040926105355.50:emptyTrash
#@+node:mork.20040926105355.51:regexClone
def regexClone( c , name ):
    if c == None: c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    sv = getSV( name, c )
    chapter = chapters[ sv ]
    
    def cloneWalk( result , entry, widget, c = c):
        txt = entry.get()
        widget.deactivate()        
        widget.destroy()
        if result == 'Cancel': return None
        import re
        regex = re.compile( txt )
        rt = chapter.cp
        chapter.setVariables()
        stnode = leoNodes.tnode( '', txt )
        snode = leoNodes.vnode( c, stnode)
        snode = leoNodes.position( snode, [] )
        snode.moveAfter( rt )
        ignorelist = [ snode ]
        it = walkChapters( c , ignorelist = ignorelist)
        for z in it:
            f = regex.search( z.bodyString() )
            if f:
                clone = z.clone( z )
                i = snode.numberOfChildren()
                clone.moveToNthChildOf( snode, i)
                ignorelist.append( clone )
                
        c.cChapter.setVariables()
        notebook.selectpage( name )
        c.selectVnode( snode )
        snode.expand()
        c.beginUpdate()
        c.endUpdate()
                
    sd = Pmw.PromptDialog( c.frame.top,
    title = 'Search and Clone',
    buttons = ( 'Search', 'Cancel' ),
    command =cloneWalk )
    entry = sd.component( 'entry' )
    sd.configure( command = 
        lambda result, entry = entry, widget = sd:
            cloneWalk( result, entry, widget ) )      
    sd.activate(  geometry = 'centerscreenalways' ) 
</t>
<t tx="zorcanda!.20050325115459.63">#@-node:mork.20040926105355.51:regexClone
#@-others
#@nonl
#@-node:mork.20040930092207:functions without classification
#@+node:mork.20040930091624.1:PDF
# Requires reportlab toolkit at http://www.reportlab.org

#@+others
#@+node:mork.20040926105355.42:doPDFConversion
def doPDFConversion( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import cStringIO
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer 
    from reportlab.lib.styles import getSampleStyleSheet 
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    PAGE_HEIGHT = defaultPageSize[ 1 ]
    PAGE_WIDTH = defaultPageSize[ 0 ]
    maxlen = 100
    styles = getSampleStyleSheet()
    pinfo = c.frame.shortFileName()
    pinfo1 = pinfo.rstrip( '.leo' )
    cs = cStringIO.StringIO()
    doc = SimpleDocTemplate( cs , showBoundary = 1)
    Story = [Spacer(1,2*inch)] 
    pagenames = notebook.pagenames()   
    cChapter = c.cChapter
    for n,z in enumerate( pagenames ):
        
        n = n + 1
        sv = getSV( z , c)
        chapter = chapters[ sv ]
        chapter.setVariables()
        p = chapter.rp
        if p:
            _changeTreeToPDF( sv.get(), n, p , c, Story, styles, maxlen)
    
    def otherPages( canvas, doc , pageinfo = pinfo):
    
        canvas.saveState()
        canvas.setFont('Times-Roman',9) 
        canvas.drawString(inch, 0.75 * inch, "Page %d %s" % (doc.page, pageinfo)) 
        canvas.restoreState()
    
    cChapter.setVariables()# This sets the nodes back to the cChapter, if we didnt the makeCurrent would point to the wrong positions
    cChapter.makeCurrent()
    doc.build(Story,  onLaterPages = otherPages)
    f = open( '%s.pdf' % pinfo1, 'w' )
    cs.seek( 0 )
    f.write( cs.read() )
    f.close()
    cs.close()
</t>
<t tx="zorcanda!.20050325115459.64">#@nonl
#@-node:mork.20040926105355.42:doPDFConversion
#@+node:mork.20040926105355.43:_changeTreeToPDF
def _changeTreeToPDF( name, num, p, c, Story, styles , maxlen):
    
    import copy
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer, PageBreak, XPreformatted
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    enc = c.importCommands.encoding
    hstyle = styles[ 'title' ]
    Story.append( Paragraph( 'Chapter %s: %s' % ( num, name), hstyle ) )
    style = styles[ 'Normal' ]
    g.trace(p)
    for v in p.allNodes_iter(): #self_and_subtree_iter doesn't seem to work here????  Switched to allNodes_iter
    # while v:
        head = v.moreHead( 0 )
        head = g.toEncodedString(head,enc,reportErrors=True) 
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            body = g.toEncodedString(body,enc, reportErrors=True)
            s = s + body
            s = s.split( '\n' )
            s2 = []
            for z in s:
                if len( z ) &lt; maxlen:
                    s2.append( z )
                else:
                    while 1:
                        s2.append( z[ : maxlen ] )
                        if len( z[ maxlen: ] ) &gt; maxlen:
                            z = z[ maxlen: ]
                        else:
                            s2.append( z[ maxlen: ] )
                            break
            s = '\n'.join( s2 )
            s = s.replace( '&amp;' ,'&amp;amp;' )
            s = s.replace( '&lt;', '&amp;lt;' )
            s = s.replace( '&gt;', '&amp;gt;' )
            s = s.replace( '"', '&amp;quot;' )
            s = s.replace( "`", '&amp;apos;' )
            Story.append( XPreformatted( s, style ) )
            Story.append( Spacer( 1, 0.2 * inch ) )
        #v = v.threadNext() 
    Story.append( PageBreak() )
</t>
<t tx="zorcanda!.20050518102918">import base64



nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''
nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''
nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''
noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''
clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''
copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''
cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''
paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''
insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''
demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''
promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''
pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''
hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''
dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''
question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''
sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''
sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''
delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''
moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''
movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''
moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''
moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''

fd = { "nodeup.gif":nodeup, "nodedown.gif": nodedown, "nodeleft.gif":nodeleft, 
       "noderight.gif": noderight, "clone.gif": clone, "copy.gif": copy, "paste.gif": paste,
       "insert.gif": insert, "demote.gif": demote, "promote.gif": promote, "pasteclone.gif": pasteclone,
       "hoist.gif": hoist, "dehoist.gif": dehoist, 
       "question.gif": question, "sortchildren.gif": sortchildren, 
       "sortsiblings.gif": sortsiblings, "delete.gif": delete, "moveup.gif": moveup, 
        "movedown.gif": movedown, "moveleft.gif": moveleft, "moveright.gif": moveright }

for z in fd.keys():
    f = open( z, "w" )
    data = fd[ z ]
    bin = base64.decodestring( data )
    f.write( bin )
    f.close()
     

</t>
<t tx="zorcanda!.20050609174820">@
This node is for notes on weirdness and bugs seen.


Bug Jun 9, 2005: First node displayed does not have proper colorizarion -- introduced with change to the mechanism by which colorization  is determined

Report Jun 12, 2005:
--problems with startjleo python script noted, cant recreate at this point. Will note that the startjyleo
needs to be executed in the parent directory of the src directory, or its not going to work too well.
--report of accented characters not appearing correctly, showing up as a 'box'

Noticed Jun 10, 2005:
    On Linux and with Java 1.5_3 I have seen a memory leak of these two classes:
        sun.awt.X11.WindowPropertyGetter
        sun.awt.X11.XQueryTree
        
    These two gradually increase over time and eventually will overtake the char[] on the heap if there is little
    editing taking place.  These are not classes that are referenced directly by any JyLeo code, so it is something that is happening internally.  I have asked Sun about this and they believe it has to do with the finalize methods of
    these 2 classes. They have requested a link to this application so they can see if they can reproduce the problem.
    Will notify them when this "release"/snapshot is sent out.  I have not seen this behavior reproduced with NetBeans.  It remains to be seen if there is a bad practice being done in JyLeo or its a bug in the Java implementation.  I look forward to being able to profile JyLeo with NetBeans profiler... Java 1.5_4 is supposed to open this up.
    

        
        


</t>
<t tx="zorcanda!.20050615155621">@
A leo user asked this question on the leo forums so Ill just reiterate here:
    JyLeo is the Jython/Java port of Leo.  Its intention is to extend Leo's reach
    with the power of the Java platform.
    
    It requires at this time:
        a Java 1.5( Java 5 ) release.  The "Tiger"
        a Jython 2.2a1 release.
        
</t>
<t tx="zorcanda!.20050615161138">@
1. Integrate with 4.3 final, awaiting next Jython 2.2a release.  Hopefully this will allow the code to be de-forked in certain places.
2. Update PluginManager.  Untie the download from the Gui, maybe have a separate progress bar pop up when the download is commencing.
3. Integrate with Leo's new Colorizer code when it is 'perfected'.  Not sure but, I may have to enhance the leoEditorKit class to deal with the new stuff.
4. Profile with NetBeans profiler when Java 1.5_4 is released.  JStack and jmap have been good but their not *good* enough.  I have cut memory leakage down drasticly... but there still is a need to do more cutting.  Unsure if Jython PyString is fundamentally an eater of memory, noticed that it seems to be intern friendly in its implementation.
5. Chapters integration.  Unsure where the status of this is at with Leo at this point, have heard rumblings of adding better support for writing the Leo file out, Chapter enabled.
6. Does SwingMacs need some UndoableEdits to plug into the Undo Manager?
7. Write more documentation for this thing.  
8. Allow other Java built interpreters to execute scripts, like Rhino for example.
9. Work on the core plugins that I have going so far.  It would be nice to have the time to devote all JyLeo time to say SVNIntegrator.  Maybe after this release/snapshot...?
10. Work on Printing.  Much to my dismay the windows driver for javax.print does not seem to offer text file printing.  I need to do two things:
    a. Investigate further if there is a good way to do this on windows.
    b. If no, need to write some printing code ala old java.print package.


----------
Its been a heck of a ride so far with this thing.  I never thought that Id be writing a Jython/Java application, always thought that
Jython would be relegated to scripting but it has proven otherwise.
</t>
<t tx="zorcanda!.20050810101232">import testimport2

class testimporta:
    pass
    
class testimporta2( testimporta ):
    pass
    
class testimporta3( testimporta2 ):
    pass
    
print "2 %s" % dir( testimport2 )</t>
<t tx="zorcanda!.20050810110842">import testimport


class testimporta:
    pass
    
class testimport2a( testimporta ):
    pass
    
class testimport3a( testimport2a ):
    pass
    
    
print dir( testimport )</t>
<t tx="zorcanda!.20050824102107">@encoding utf-8 

'''This jython script is supposed to build the environment up for
JyLeos execution.  It needs to be run in the parent directory of the
src, Icons, skins, skinimages directories.  Otherwise its useless.
For example:
jython ~ahome/jyleo/jyleo.py aleofile.leo
On linux I have this thing wrapped as a simple shell script so I can
just
type "jyleo" and it will execute this script and open the file passed
in.  On XP I have a simple shortcut that executes jython with this
file as an argument.
IMPORTANT NOTE:
jython2.2a1 compiles the __file__ attribute into the class file generated.
Hence any execution of jyleo.py will use that static data.  If this distribution
is taken to another system it is imperative that the jyleo.py and leo.py class files
are removed--&gt; do not remove the .py files, just the class files which should be 2.'''

import java.lang.System as System
import java.lang.String as String
import java.lang.ProcessBuilder as ProcessBuilder
import java.io as io 
import os
import __calculate_fs_location
import java.util.HashMap as hmap 

pathsep = os.pathsep

if __name__ == '__main__':

   cp = System.getProperty( "java.class.path" )
   phome = System.getProperty( "python.home" )
   if phome:
      print "python.home is defined at %s" % phome
   else:
      print "python.home not found, aborting startup..."
      print "check that jython is being started correctly..."
      System.exit( 0 )
   
   op_system = System.getProperty( "os.name" )
   print "OS detected is %s" % op_system
   op_system = op_system.lower()
   if op_system.startswith( "win" ):
      jy_command = "jython.bat"
   else:
      jy_command = "jython"
   
   print "jython execution command is defined as %s" % jy_command
   cmdfile = io.File( phome, jy_command )
   if not cmdfile.exists():
      print "can't find jython command, exiting..."
      System.exit( 0 )
      
   cmdpath = cmdfile.getAbsolutePath()           
   f = io.File( __calculate_fs_location.__file__ ).getParentFile()


   files = f.listFiles()

   directories = []
   for z in files:
       if z.isDirectory():
           directories.append( z )

   addons = ( 'Icons', 'src', 'skins', 'skinimages' )
   paths = []
   pathtoleo = None
   for z in directories:
       if z.getName() in addons:
	  paths.append( z.getAbsolutePath() )
	  if z.getName() ==  "src" :
	     sfiles = z.listFiles()
	     for src in sfiles:
		    if src.getName() ==  "leo.py" :
		        pathtoleo= src.getAbsolutePath()
		    
   if pathtoleo == None:
      print "leo.py not found. Exiting"
      System.exit( 0 )
		    		    
   npaths = pathsep.join( paths )
   cp2 = '%s%s%s' % ( cp, pathsep, npaths )
   def visit( args, directory, files, cp = cp ):
      global cp2
      fdirectory = io.File( directory )
      dname = fdirectory.getName()
      if dname.startswith( "freemind" ) or dname.startswith( ".freemind" ):
         print "freemind appears to be installed in opt directory at %s" % directory
      elif dname.startswith( "jfreereport" ):
         print "jfreereport appears to be installed in opt directory at %s" % directory
      for z in files:
         if z.endswith( ".jar" ):
            f = io.File( directory, z )
            cp2 = "%s%s%s" % ( cp2, pathsep, f.getAbsolutePath() )
            f = None
       
   print "Setting up environment..."
   optfile = io.File( f, "opt" )
   if optfile.exists():
      print '-' * 20
      print "Looking in opt directory..."
      os.path.walk(  optfile.getAbsolutePath(), visit, None )
      print '-' * 20
   else:
      print "opt directory does not exists, printing and mindmap systems will not function..."
   
  
  
   command = [ String( cmdpath ), pathtoleo ]
   import sys
   if len( sys.argv ) &gt; 1:
      command.extend( sys.argv[ 1: ] )
   leobuilder = ProcessBuilder( command )
   env = leobuilder.environment()
   
  
   h2 = hmap()
   h2.put( "CLASSPATH", cp2 )
   env.putAll( h2 )
   print "CLASSPATH is pointing at these entities:"
   paths = cp2.split( pathsep )
   for z in paths:
       print z
       
   p = None
   try:
      p = leobuilder.start()
      ev = p.exitValue()
   except:
      print "Starting jyleo..."
      System.exit( 1 )
   print "jyleo did not startup..."
   System.exit( 0 )
</t>
<t tx="zorcanda!.20050907152321">@path utilities</t>
<t tx="zorcanda!.20050909105436">@language java
import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;



public class ShowWPProblem{


    static class SimpleEditorKitSubclass extends StyledEditorKit{
    
    
        public ViewFactory getViewFactory(){
        
            ViewFactory vf = new ViewFactory(){
            
                public View create( Element e ){
                
                    return new WrappedPlainView( e );
                
                }
            
            
            };
            
            return vf;
        
        
        
        }
    
    
    
    }


    public static void main( String[] args ){
    
    
        EditorKit ek = new SimpleEditorKitSubclass();
        final JTextPane jtp = new JTextPane();
        jtp.setEditorKit( ek );
        JFrame jf = new JFrame();
        JScrollPane jsp = new JScrollPane( jtp );
        jf.add( jsp );
        jf.pack();
        final DefaultStyledDocument doc = (DefaultStyledDocument)jtp.getDocument();
        final String data = "asdasdasdasdasxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        try{
            doc.insertString( 0, data, null );
        }
        catch( BadLocationException ble ){}
        jf.setVisible( true );
        JMenuBar jmb = new JMenuBar();
        jf.setJMenuBar( jmb );
        JMenu jm = new JMenu( "Cut Copy Paste" );
        jmb.add( jm );
        JMenuItem cut = new JMenuItem( new AbstractAction( "Cut" ){
        
            public void actionPerformed( ActionEvent ae ){
            
                jtp.cut();
            
            }
        
        
        } );
        
        jm.add( cut );
        JMenuItem copy = new JMenuItem( new AbstractAction( "Copy" ){
        
            public void actionPerformed( ActionEvent ae ){
            
                jtp.copy();
            
            }
        
        
        } );
        
        jm.add( copy );
        JMenuItem paste = new JMenuItem( new AbstractAction( "Show Problem" ){
        
            public void actionPerformed( ActionEvent ae ){
            
                try{
                    /*sparagraph = stext.Utilities.getParagraphElement( self.emacs.editor, start )
                    eparagraph = stext.Utilities.getParagraphElement( self.emacs.editor, end )
                    self.emacs.startCompounding( "Block Move" )
                    if sparagraph.getStartOffset() == start and eparagraph.getEndOffset() -1 == end:
                    #doc.replace( next[ 0 ], len( next[ 1 ] ), stxt, None )
                    #self.emacs.editor.replaceSelection( next[ 1 ] )
                    nwtxt = '%s\n%s' % ( next[ 1 ], stxt )
                    doc.replace( start, len( nwtxt ), nwtxt, None ) */
                    int start = jtp.getSelectionStart();
                    int end = jtp.getSelectionEnd();
                    int nlineend = Utilities.getParagraphElement( jtp, end ).getEndOffset();
                    String text = doc.getText( start , end - start );
                    doc.replace( start, text.length(), text + text, null );
                    //doc.insertString( jtp.getCaretPosition() ,data, null );
                }
                catch( BadLocationException ble ){}
            
            }
        
        
        } );
        
        jm.add( paste );
    
    
    
    
    }






}
</t>
<t tx="zorcanda!.20050913164543">#@+leo-ver=4-thin
#@+node:ekr.20050529142847:@thin __jEdit_colorizer__.py
'''Replace colorizer with colorizer using jEdit language description files'''

#@@language python
#@@tabwidth -4
#@@pagewidth 80

__version__ = '0.13'
#@&lt;&lt; version history &gt;&gt;
#@+node:ekr.20050529142916.2:&lt;&lt; version history &gt;&gt;
#@@killcolor
#@+others
#@+node:ekr.20050607075752:0.1 through 0.5
#@+at
# 
# 0.1 EKR: Initial version:
#     - Split large methods into smaller methods.
# 0.2 EKR:
#     - Moved contentHandler and modeClass into the plugin.
#     - colorizer.__init__ reads python.xml, but does nothing with it.
# 0.3 EKR:
#     - Wrote and tested createRuleMatchers.
# 0.4 EKR:
#     - Basic syntax coloring now works.
# 0.5 EKR:
#     - Giant step forward 1: colorOneChunk and interrupt allow very fast 
# keyboard response.
#     - Giant step forward 2: no need for incremental coloring!
#     - Giant step forward 3: eliminated flashing &amp; eliminated most calls to 
# removeAllTags.
#@-at
#@nonl
#@-node:ekr.20050607075752:0.1 through 0.5
#@+node:ekr.20050607080236:0.6 through 0.10
#@+at
# 
# 0.6 EKR:
#     - Removed unused code and ivars.
#     - Added support for keywords, including Leo keywords and expanded 
# word_chars.
#     - Added special rules for doc parts and section references.
#     - Most (all?) Python now is colored properly.
#     - Discovered a performance bug: it can take a long time on big text for 
# the cursor to appear.
# 0.7 EKR:
#     - Colorized start of @doc sections properly.
#     - Fixed bug involving at_line_start: must test i == 0 OR s[i-1] == '\n'.
#     - Added rules for @color and @nocolor.
#     - Added more entries to to-do list for Leo special cases.
# 0.8 EKR:
#     - Use a single dict for all keywords--an important speedup.
#     - Call init_keywords exactly once per mode.
#     - Defined tags for jEdit types.
#     - Fixed bug in exception handling in parse_jEdit_file: exceptions now 
# reported properly.
#     - Turned off inclusion of external general entities so dtd line gets 
# ignored.
# 0.9 EKR:
#     - Added colored_ranges dict, colorRangeWithTag &amp; removeTagsFromRange.
#         - This keeps track of tags much more effectively than Tk does.
#     - A compromise looks best for eliminating flash with good performance:
#         - Don't interrupt colorOneChunk for non-incremental redraws.
#             - Doesn't really hurt performance: the cursor didn't blink in 
# the old way.
#         - Do interrupt colorOneChunk for incremental redraws.
#             - Key performance is optimal.
#             - There is no flash because no tags get needlessly destroyed.
#         - recolor_range calls invalidate_range so undo works properly.
# 0.10 EKR:
#     - use self.c.frame.top.after(50,self.colorOneChunk) to queue 
# non-incremental coloring.
#     - This causes instant display and prompt coloring, even for large text.
#     - Must call removeAllTags and removeAllImages when clearing the 
# colored_ranges dict.
#@-at
#@nonl
#@-node:ekr.20050607080236:0.6 through 0.10
#@+node:ekr.20050607075752.1:0.11 up
#@+at
# 
# 0.11 EKR:
#     - Supported no_line_break in match_span.
#     - Fixed bug in doAttribute so that "TRUE" is recognized correctly.
#     - Added span_eol rules to python.xml to handle non-terminated ' and " 
# strings.
#     - Added was_non_incremental state var and related logic.
#         - Never clear tags in colorizeAnyLanguage: it cause flash after 
# colorOneChunk exits.
#         - Instead, clear by hand was_non_incremental is True.
# 0.12 EKR:
#     - Only look up the rules which appear in 
# self.rulesDict.get(s[i],self.defaultRulesList)
#     - This should typically reduce the number of rules examined by a factor 
# of about 10.
# 0.13 EKR:
#     - Duplicated nullColorizer in this file so it derives from proper base 
# class.
#       This fixes the crash in the settings panel.
#     - colorRangeWithTag now always sets colored_ranges when doing any real 
# coloring.
#       This fixes a bug in which old tags weren't always cleared.
#     - Colorized hyperlinks and undefined sections correctly.
#     - Changed contentHandler so and parse_jEdit_file so parse_jEdit_file 
# returns a single mode.
#         - It is now an error for more than one mode to appear in an xml 
# file.
#     - Many changes to handle multiple rulesets properly:
#         - Added logic to initMode and initKeywords to handle multiple 
# rulesets.
#         - created rulesetClass.
#         - created following mode ivars:
#             - modeProperties, 
# rulesetProperties,presentProperty,rulesetAttributes.
# 0.14 EKR:
#     - Added support for delegated rulesets in modeClass, etc.
#     - Handled delegated rulesets in colorByDelegate.
#@-at
#@nonl
#@-node:ekr.20050607075752.1:0.11 up
#@-others
#@nonl
#@-node:ekr.20050529142916.2:&lt;&lt; version history &gt;&gt;
#@nl
#@&lt;&lt; to do &gt;&gt;
#@+node:ekr.20050601081132:&lt;&lt; to do &gt;&gt;
#@@nocolor
#@+at
# 
# - Handle c.xml:
#     - Make sure &lt;markup&gt; element in &lt;keywords&gt; element work in delegate.
# - Support NO_WORD_SEP, IGNORE_CASE and DEFAULT attributes in rules element.
#     - Later: support DIGIT_RE and HIGHLIGHT_DIGITS attributes in rules 
# element.
# 
# - Finish all rules:
#     - mark_previous and mark_following.
#     - match_regexp_helper.
# - Test colorizing of hyperlinks.
# 
#@-at
#@@c
#@@color

#@&lt;&lt; later &gt;&gt;
#@+node:ekr.20050603121815:&lt;&lt; later &gt;&gt;
#@@killcolor
#@+at
# - Support comment properties and self.comment_string:
#     - Conditionally add rules for comment ivars: 
# single_comment_start,block_comment_start,block_comment_end
#     - commentEnd - the comment end string, used by the Range Comment 
# command.
#     - commentStart - the comment start string, used by the Range Comment 
# command.
#     - lineComment - the line comm
# 
# - Support Show Invisibles.
#     Conditionally add rule for whitespace.
# 
# - Handle cweb section references correctly.
# 
# - Handle logic of setFirstLineState.
#     - Change match_doc_part: Start in doc mode for some @root's.
# 
# - Make sure pictures get drawn properly.
# 
# - Create forth.xml
# 
# - php.xml does not parse correctly.
#@-at
#@nonl
#@-node:ekr.20050603121815:&lt;&lt; later &gt;&gt;
#@nl
#@-node:ekr.20050601081132:&lt;&lt; to do &gt;&gt;
#@nl
#@&lt;&lt; imports &gt;&gt;
#@+node:ekr.20050529142916.3:&lt;&lt; imports &gt;&gt;
import leoGlobals as g
import leoPlugins

import os
import re
import string
import threading
import xml.sax
import xml.sax.saxutils

# php_re = re.compile("&lt;?(\s|=|[pP][hH][pP])")
php_re = re.compile("&lt;?(\s[pP][hH][pP])")
#@nonl
#@-node:ekr.20050529142916.3:&lt;&lt; imports &gt;&gt;
#@nl
#@&lt;&lt; define leoKeywords &gt;&gt;
#@+node:ekr.20050529143413:&lt;&lt; define leoKeywords &gt;&gt;
# leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap", ]
#@nonl
#@-node:ekr.20050529143413:&lt;&lt; define leoKeywords &gt;&gt;
#@nl
#@&lt;&lt; define default_colors_dict &gt;&gt;
#@+node:ekr.20050529143413.1:&lt;&lt; define default_colors_dict &gt;&gt;
# These defaults are sure to exist.

default_colors_dict = {
    # tag name       :(     option name,           default color),
    'comment'        :('comment_color',               'red'),
    'cwebName'       :('cweb_section_name_color',     'red'),
    'pp'             :('directive_color',             'blue'),
    'docPart'        :('doc_part_color',              'red'),
    'keyword'        :('keyword_color',               'blue'),
    'leoKeyword'     :('leo_keyword_color',           'blue'),
    'link'           :('section_name_color',          'red'),
    'nameBrackets'   :('section_name_brackets_color', 'blue'),
    'string'         :('string_color',                '#00aa00'), # Used by IDLE.
    'name'           :('undefined_section_name_color','red'),
    'latexBackground':('latex_background_color','white'),
    
    # jEdit tags.
    'comment1'  :('comment1_color', 'red'),
    'comment2'  :('comment2_color', 'red'),
    'comment3'  :('comment3_color', 'red'),
    'comment4'  :('comment4_color', 'red'),
    'function'  :('function_color', 'black'),
    'keyword1'  :('keyword1_color', 'blue'),
    'keyword2'  :('keyword2_color', 'blue'),
    'keyword3'  :('keyword3_color', 'blue'),
    'keyword4'  :('keyword4_color', 'blue'),
    'label'     :('label_color',    'black'),
    'literal1'  :('keyword1_color', 'black'),
    'literal2'  :('keyword2_color', 'black'),
    'literal3'  :('keyword3_color', 'black'),
    'literal4'  :('keyword4_color', 'black'),
    'markup'    :('markup_color',   'orange'), # What is the reasonable default?
    'operator'  :('operator_color', 'black'),
    }
#@nonl
#@-node:ekr.20050529143413.1:&lt;&lt; define default_colors_dict &gt;&gt;
#@nl

#@+others
#@+node:ekr.20050529142916.4:init
def init ():

    leoPlugins.registerHandler('start1',onStart1)
    g.plugin_signon(__name__)

    return True
#@nonl
#@-node:ekr.20050529142916.4:init
#@+node:ekr.20050529142916.5:onStart1
def onStart1 (tag, keywords):
    
    import leoColor
    
    leoColor.colorizer = baseColorizer
    
    leoColor.colorizer = colorizer
    
    leoColor.nullColorizer = nullColorizer
#@nonl
#@-node:ekr.20050529142916.5:onStart1
#@+node:ekr.20050530065723.58:class contentHandler (xml.sax.saxutils.XMLGenerator)
class contentHandler (xml.sax.saxutils.XMLGenerator):
    
    '''A sax content handler class that handles jEdit language-description files.
    
    Creates mode that can be retrieved using getMode method.'''

    #@    @+others
    #@+node:ekr.20050530065723.59: __init__ &amp; helpers
    def __init__ (self,c,fileName,trace=False,verbose=False):
    
        self.c = c
        self.fileName = fileName
        self.trace = trace
        self.verbose = verbose
        
        # Init the base class.
        xml.sax.saxutils.XMLGenerator.__init__(self)
        
        # Non-mode statistics.
        self.numberOfAttributes = 0
        self.numberOfElements = 0
        
        # Options...
        self.ignoreWs = True # True: don't print contents with only ws.
        self.newLineAfterStartElement = [
            'keywords','mode','props','property','rules','span','eol_span',
            # 'seq',
        ]
        
        # Printing options
        if verbose:
            self.printAllElements = True
            self.printCharacters = False or self.printAllElements
            self.printAttributes = False and not self.printAllElements
            self.printElements = [
                #'begin','end',
                #'eol_span',
                #'keyword1','keyword2','keyword3','keyword4',
                #'mark_previous',
                #'mode',
                #'props',
                #'property',
                #'rules',
                #'span',
                #'seq',
            ]
            
            if self.printAllElements:
                self.suppressContent = []
            else:
                self.suppressContent = ['keyword1','keyword2','keyword3','keyword4']
        else:
            self.printAllElements = False
            self.printCharacters = False
            self.printAttributes = False
            self.printElements = []
      
        # Semantics: most of these should be mode ivars.
        self.elementStack = []
        self.mode = None # The present mode, or None if outside all modes.
        self.modes = [] # All modes defined here or by imports.
    #@nonl
    #@-node:ekr.20050530065723.59: __init__ &amp; helpers
    #@+node:ekr.20050530065723.60:helpers
    #@+node:ekr.20050530065723.61:attrsToList
    def attrsToList (self,attrs):
        
        '''Convert the attributes to a list of g.Bunches.
        
        attrs: an Attributes item passed to startElement.
        
        sep: the separator charater between attributes.'''
        
        return [
            g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()
        ]
    #@nonl
    #@-node:ekr.20050530065723.61:attrsToList
    #@+node:ekr.20050530065723.62:attrsToString
    def attrsToString (self,attrs,sep='\n'):
        
        '''Convert the attributes to a string.
        
        attrs: an Attributes item passed to startElement.
        
        sep: the separator charater between attributes.'''
    
        result = [
            '%s="%s"' % (bunch.name,bunch.val)
            for bunch in self.attrsToList(attrs)
        ]
    
        return sep.join(result)
    #@nonl
    #@-node:ekr.20050530065723.62:attrsToString
    #@+node:ekr.20050530065723.63:clean
    def clean(self,s):
    
        return g.toEncodedString(s,"ascii")
    #@nonl
    #@-node:ekr.20050530065723.63:clean
    #@+node:ekr.20050530065723.64:error
    def error (self, message):
        
        print
        print
        print 'XML error: %s' % (message)
        print
    #@nonl
    #@-node:ekr.20050530065723.64:error
    #@+node:ekr.20050530065723.65:printStartElement
    def printStartElement(self,name,attrs):
    
        if attrs.getLength() &gt; 0:
            print '&lt;%s %s&gt;' % (
                self.clean(name).strip(),
                self.attrsToString(attrs,sep=' ')),
        else:
            print '&lt;%s&gt;' % (self.clean(name).strip()),
    
        if name.lower() in self.newLineAfterStartElement:
            print
    #@nonl
    #@-node:ekr.20050530065723.65:printStartElement
    #@+node:ekr.20050530065723.66:printSummary
    def printSummary (self):
        
        print '-' * 10, 'non- mode statistics'
        print 'modes',len(self.modes)
        print 'elements', self.numberOfElements
    #@nonl
    #@-node:ekr.20050530065723.66:printSummary
    #@-node:ekr.20050530065723.60:helpers
    #@+node:ekr.20050530065723.67:sax over-rides
    #@+node:ekr.20050530065723.68: Do nothing...
    #@+node:ekr.20050530065723.69:other methods
    def ignorableWhitespace(self):
        g.trace()
    
    def processingInstruction (self,target,data):
        g.trace()
    
    def skippedEntity(self,name):
        g.trace(name)
    
    def startElementNS(self,name,qname,attrs):
        g.trace(name)
    
    def endElementNS(self,name,qname):
        g.trace(name)
    #@nonl
    #@-node:ekr.20050530065723.69:other methods
    #@+node:ekr.20050530065723.70:endDocument
    def endDocument(self):
    
        pass
    
    
    #@-node:ekr.20050530065723.70:endDocument
    #@+node:ekr.20050530065723.71:startDocument
    def startDocument(self):
        
        pass
    #@nonl
    #@-node:ekr.20050530065723.71:startDocument
    #@-node:ekr.20050530065723.68: Do nothing...
    #@+node:ekr.20050530065723.72:characters
    def characters(self,content):
        
        content = content.replace('\r','').strip()
        content = self.clean(content)
    
        elementName = self.elementStack and self.elementStack[-1]
        elementName = elementName.lower()
        
        if 1: # new code
            if self.printAllElements:
                print content,
            elif self.printCharacters and content and elementName not in self.suppressContent:
                print 'content:',elementName,repr(content)
        else:
            if self.printCharacters and content and elementName not in self.suppressContent:
                if self.printAllElements:
                    print content,
                else:
                    print 'content:',elementName,repr(content)
                
        if self.mode:
            self.mode.doContent(elementName,content)
        else:
            self.error('characters outside of mode')
    #@nonl
    #@-node:ekr.20050530065723.72:characters
    #@+node:ekr.20050530065723.73:endElement
    def endElement(self,name):
    
        self.doEndElement(name)
    
        name2 = self.elementStack.pop()
        assert name == name2
    #@nonl
    #@-node:ekr.20050530065723.73:endElement
    #@+node:ekr.20050530065723.74:startElement
    def startElement(self,name,attrs):
        
        if self.mode:
            self.mode.numberOfElements += 1
        else:
            self.numberOfElements += 1
            
        self.elementStack.append(name)
        self.doStartElement(name,attrs)
    #@nonl
    #@-node:ekr.20050530065723.74:startElement
    #@-node:ekr.20050530065723.67:sax over-rides
    #@+node:ekr.20050530065723.75:doStartElement
    def doStartElement (self,elementName,attrs):
        
        if self.printAllElements or elementName.lower() in self.printElements:
            self.printStartElement(elementName,attrs)
    
        elementName = elementName.lower()
        
        if elementName == 'mode':
            if self.mode:
                self.error('Multiple modes')
            else:
                self.mode = modeClass(self,self.fileName)
        elif self.mode:
            self.mode.startElement(elementName)
            for bunch in self.attrsToList(attrs):
                if self.printAttributes:
                    print 'attr:',elementName,bunch.name,'=',bunch.val
                self.mode.doAttribute(bunch.name,bunch.val)
        else:
            self.error('Start element appears outside of Mode:%s' % elementName)
            for bunch in self.attrsToList(attrs):
                self.error('Attribute appears outside of Mode:%s' % bunch.name)
    #@nonl
    #@-node:ekr.20050530065723.75:doStartElement
    #@+node:ekr.20050530065723.76:doEndElement
    def doEndElement (self,elementName):
        
        if self.printAllElements or elementName.lower() in self.printElements:
            print '&lt;/' + self.clean(elementName).strip() + '&gt;'
            
        if elementName.lower() == 'mode':
            if self.verbose:
                self.mode.printSummary()
        elif self.mode:
            self.mode.endElement(elementName)
        else:
            self.error('End element appears outside of Mode:%s' % elementName)
            for bunch in self.attrsToList(attrs):
                self.error('Attribute appears outside of Mode:%s' %bunch.name)
    #@nonl
    #@-node:ekr.20050530065723.76:doEndElement
    #@+node:ekr.20050530071955:getMode
    def getMode (self):
        
        return self.mode
    #@nonl
    #@-node:ekr.20050530071955:getMode
    #@-others
#@nonl
#@-node:ekr.20050530065723.58:class contentHandler (xml.sax.saxutils.XMLGenerator)
#@+node:ekr.20050530065723.49:class modeClass
class modeClass:
    
    '''A class representing one jEdit language-description mode.
    
    Use getters to access the attributes, properties and rules of this mode.'''
    
    #@    @+others
    #@+node:ekr.20050530065723.50: mode.__init__
    def __init__ (self,contentHandler,fileName):
    
        self.contentHandler = contentHandler
        self.fileName = fileName # The file from which the mode was imported.
        self.verbose = self.contentHandler.verbose
    
        # Mode statistics...
        self.numberOfAttributes = 0
        self.numberOfElements = 0
        self.numberOfErrors = 0
        self.numberOfPropertyAttributes = 0
        self.numberOfRuleAttributes = 0
        
        # List of boolean attributes.
        self.boolAttrs = [
            'at_line_start','at_whitespace_end','at_word_start',
            'exclude_match','highlight_digits','ignore_case',
            'no_escape','no_line_break','no_word_break','no_word_sep',]
    
        # List of elements that start a rule.
        self.ruleElements = [
            'eol_span','eol_span_regexp','import','keywords',
            'mark_following','mark_previous','seq','seq_regexp',
            'span','span_regexp','terminate',]
    
        if 0: # Not used at present.
            self.seqSpanElements = [
                'eol_span','eol_span_regexp','seq','seq_regexp',
                'span','span_regexp',]
    
        # Mode semantics.
        self.attributes = {}
        self.inProps = False
        self.inRules = False
        self.keywords = None
        self.modeProperties = []
        self.presentProperty = None # A bunch to be assigned to modeProperties or rulesetProperties.
        self.rule = None
        self.rulesets = []
        self.rules = [] # The rules of the present rules element.
        self.rulesetProperties = []
        self.rulesetAttributes = {} # The attributes of the present rules element.
    #@nonl
    #@-node:ekr.20050530065723.50: mode.__init__
    #@+node:ekr.20050530073825: mode.__str__ &amp; __repr__
    def __str__ (self):
        
        return '&lt;modeClass for %s&gt;' % self.fileName
        
    __repr__ = __str__
    #@nonl
    #@-node:ekr.20050530073825: mode.__str__ &amp; __repr__
    #@+node:ekr.20050530081700: Printing...
    #@+node:ekr.20050530075602:printModeAttributes, printRulesetAttributes &amp; printAttributesHelper
    def printModeAttributes (self):
        
        self.printAttributesHelper('mode attributes',self.attributes)
        
    def printRulesetAttributes (self,ruleset,tag=None):
    
        if not tag: tag = 'main ruleset'
        
        self.printAttributesHelper(tag,ruleset.attributes)
        
    def printAttributesHelper (self,kind,attrs):
        
        print '%-20s' % (kind),'attrs:',attrs
    #@nonl
    #@-node:ekr.20050530075602:printModeAttributes, printRulesetAttributes &amp; printAttributesHelper
    #@+node:ekr.20050530080452:printProperty
    def printProperty (self,theProperty):
        
        # A property is a bunch.
        d = theProperty.attributes
        if d:
            self.printAttributesHelper('property',d)
    #@nonl
    #@-node:ekr.20050530080452:printProperty
    #@+node:ekr.20050530075602.1:printRule
    def printRule (self,rule):
        
        # A rule is a g.Bunch.
        if rule.name == 'keywords':
            print '%-20s' % ('rule:keywords'),
            for key in ('keyword1','keyword2','keyword3','keyword4','markup',):
                theList = rule.get(key,[])
                print key,len(theList),
            print
        else:
            d = rule.attributes
            d2 = rule.get('contents')
            if d or d2:
                print '%-20s' % ('rule:'+rule.name),
                if d and d2: print 'attrs:',d,'chars:',d2
                elif d:  print 'attrs:',d
                else:    print 'chars:',d2
    #@nonl
    #@-node:ekr.20050530075602.1:printRule
    #@+node:ekr.20050607221915:printRuleset
    def printRuleset (self,ruleset,tag):
        
        self.printRulesetAttributes(ruleset,tag)
    
        for rule in self.rulesets[0].rules:
            self.printRule(rule)
    #@nonl
    #@-node:ekr.20050607221915:printRuleset
    #@+node:ekr.20050530065723.56:printSummary
    def printSummary (self,printStats=True):
    
        if printStats:
            print '-' * 10, 'mode statistics'
            print 'elements',self.numberOfElements
            print 'errors',self.numberOfErrors
            print 'mode attributes',self.numberOfAttributes
            print 'property attributes',self.numberOfPropertyAttributes
            print 'rule attributes',self.numberOfRuleAttributes
    
        self.printModeAttributes()
        
        for bunch in self.modeProperties:
            self.printProperty(bunch)
    
        self.printRuleset(self.rulesets[0],tag='main ruleset')
    #@nonl
    #@-node:ekr.20050530065723.56:printSummary
    #@-node:ekr.20050530081700: Printing...
    #@+node:ekr.20050530065723.51:doAttribute
    def doAttribute (self,name,val):
        
        name = str(name.lower())
        
        if name in self.boolAttrs:
            val = g.choose(val.lower()=='true',True,False)
        else:
            val = str(val) # Do NOT lower this value!
    
        if self.rule:
            d = self.rule.get('attributes')
            d [name] = val
            self.numberOfRuleAttributes += 1
        elif self.presentProperty:
            d = self.presentProperty.get('attributes')
            d [name] = val
            self.numberOfPropertyAttributes += 1
        elif self.inRules:
            self.rulesetAttributes[name] = val
            self.numberOfAttributes += 1
        else:
            self.attributes[name] = val
            self.numberOfAttributes += 1
    #@nonl
    #@-node:ekr.20050530065723.51:doAttribute
    #@+node:ekr.20050530065723.52:doContent
    def doContent (self,elementName,content):
        
        if not content:
            return
        
        name = str(elementName.lower())
    
        if name in ('keyword1','keyword2','keyword3','keyword4','markup',):
            if self.inRule('keywords'):
                theList = self.rule.get(name,[])
                theList.append(content)
                self.rule[name] = theList
            elif name != 'markup':
                self.error('%d not in keywords' % name)
    
        elif self.rule:
            d = self.rule.get('contents',{})
            s = d.get(name,'')
            d [name] = s + content
            self.rule['contents'] = d
    #@nonl
    #@-node:ekr.20050530065723.52:doContent
    #@+node:ekr.20050530065723.53:endElement
    def endElement (self,elementName):
    
        name = elementName.lower()
        
        if name == 'props':
            self.inProps = True
        if name == 'rules':
            self.inRules = False
            ruleset = rulesetClass(self.rulesetAttributes,self.keywords,self.rulesetProperties,self.rules)
            self.rulesets.append(ruleset)
            #g.trace('rules...\n',g.listToString(self.rules))
            #g.trace('ruleset attributes...\n',g.dictToString(self.rulesetAttributes))
        if name == 'property':
            bunch = self.presentProperty
            if bunch:
                if self.inRules:
                    self.rulesetProperties.append(bunch)
                else:
                    self.modeProperties.append(bunch)
            else:
                self.error('end %s not matched by start %s' % (name,name))
            self.presentProperty = None
        if name in self.ruleElements:
            if self.inRule(name):
                self.rules.append(self.rule)
                self.rule = None
            else:
                self.error('end %s not matched by start %s' % (name,name))
    #@nonl
    #@-node:ekr.20050530065723.53:endElement
    #@+node:ekr.20050530065723.54:error
    def error (self,message):
        
        self.numberOfErrors += 1
    
        self.contentHandler.error(message)
    #@nonl
    #@-node:ekr.20050530065723.54:error
    #@+node:ekr.20050530074431:getters
    def getAttributes (self):
        return self.attributes
        
    def getAttributesForRuleset (self,ruleset):
        bunch = ruleset
        return bunch.attributes
        
    def getFileName (self):
        return self.fileName
        
    def getKeywords (self,n,ruleset):
        bunch = ruleset
        keywords = bunch.keywords
        if keywords:
            return keywords.get('keyword%d'%(n),[])
        return []
    
    def getLanguage (self):
        path,name = g.os_path_split(self.fileName)
        language,ext = g.os_path_splitext(name)
        return language
    
    def getPropertiesForMode (self):
        return self.props
        
    def getPropertiesForRuleset (self,name=''):
        bunch = self.getRuleset(name)
        if bunch:
            return bunch.properties
        else:
            return []
        
    def getRuleset(self,name=''):
        if not name:
            return self.rulesets[0] # Return the main ruleset.
        for ruleset in self.rulesets:
            if ruleset.name.lower()==name.lower():
                return ruleset
        else: return None
    
    def getRulesets(self):
        return self.rulesets
        
    def getRulesForRuleset (self,name=''):
        bunch = self.getRuleset(name)
        if bunch:
            return bunch.rules
        else:
            return []
    #@nonl
    #@-node:ekr.20050530074431:getters
    #@+node:ekr.20050530065723.55:inRule
    def inRule (self,elementName):
    
        return self.rule and self.rule.get('name') == elementName
    #@nonl
    #@-node:ekr.20050530065723.55:inRule
    #@+node:ekr.20050530065723.57:startElement
    def startElement (self,elementName):
    
        name = elementName.lower()
        
        if name == 'props':
            self.inProps = True
        if name == 'rules':
            self.inRules = True
            self.attributes=[]
            self.keywords=[]
            self.rulesetProperties=[]
            self.rules=[]
        if name == 'property':
            if self.inProps:
                self.presentProperty = g.bunch(name=name,attributes={})
            else:
                self.error('property not in props element')
        if name in self.ruleElements:
            if self.inRules:
                self.rule = g.bunch(name=name,attributes={})
                if name == 'keywords':
                    self.keywords = self.rule
            else:
                self.error('%s not in rules element' % name)
    #@nonl
    #@-node:ekr.20050530065723.57:startElement
    #@-others
#@nonl
#@-node:ekr.20050530065723.49:class modeClass
#@+node:ekr.20050607073917.1:class rulesetClass
class rulesetClass:
    
    #@    @+others
    #@+node:ekr.20050607073917.2:ctor
    def __init__ (self,attributes,keywords,properties,rules):
            
        self.name=attributes.get('set','')
        self.attributes=attributes.copy() # A dict.
        self.properties=properties[:] # A list.
        self.keywords=keywords # A bunch.
        self.rules=rules[:] # A list.
        
        if self.name:
            g.trace('ruleset',self.name)
            
        self.defaultColor = self.attributes.get('default')
    #@nonl
    #@-node:ekr.20050607073917.2:ctor
    #@-others
#@nonl
#@-node:ekr.20050607073917.1:class rulesetClass
#@+node:ekr.20050606214036:class colorizer (baseColorizer)
class baseColorizer:

    '''New colorizer using jEdit language description files'''
    #@    @+others
    #@+node:ekr.20050529143413.24:Birth and init
    #@+node:ekr.20050602150957:__init__
    def __init__(self,c):
        # Copies of ivars.
        self.c = c
        self.frame = c.frame
        self.body = c.frame.body
        self.p = None
        # Config settings.
        self.comment_string = None # Set by scanColorDirectives on @comment
        self.showInvisibles = False # True: show "invisible" characters.
        self.underline_undefined = c.config.getBool("underline_undefined_section_names")
        self.use_hyperlinks = c.config.getBool("use_hyperlinks")
        # State ivars...
        self.colored_ranges = {}
            # Keys are indices, values are tags.
        self.chunk_count = 0
        self.color_pass = 0
        self.comment_string = None # Can be set by @comment directive.
        self.defaultRulesList = []
        self.enabled = True # Set to False by unit tests.
        self.flag = True # True unless in range of @nocolor
        self.keywordNumber = 0 # The kind of keyword for keywordsColorHelper.
        self.kill_chunk = False
        self.language = 'python' # set by scanColorDirectives.
        self.ranges = 0
        self.redoColoring = False # May be set by plugins.
        self.redoingColoring = False
        self.was_non_incremental = False # True: we are coloring as the result of a non-incremental call.
        # Data...
        self.keywords = {} # Keys are keywords, values are 0..5.
        self.modes = {} # Keys are languages, values are bunches describing the mode.
        self.mode = None # The mode object for the present language.
        self.prev_mode = None
        self.present_ruleset = None
        self.rulesDict = {}
        self.tags = [
            "blank","comment","cwebName","docPart","keyword","leoKeyword",
            "latexModeBackground","latexModeKeyword",
            "latexBackground","latexKeyword",
            "link","name","nameBrackets","pp","string","tab",
            "elide","bold","bolditalic","italic", # new for wiki styling.
            # Leo jEdit tags...
            '@color', '@nocolor', 'doc_part', 'section_ref',
            # jEdit tags.
            'comment1','comment2','comment3','comment4',
            'function',
            'keyword1','keyword2','keyword3','keyword4',
            'label',
            'literal1','literal2','literal3','literal4',
            'markup',
            'operator',
        ]
        self.word_chars = {} # Inited by init_keywords().
        self.setFontFromConfig()
        self.defineAndExtendForthWords()
    #@nonl
    #@-node:ekr.20050602150957:__init__
    #@+node:ekr.20050529143413.33:configure_tags
    def configure_tags (self):
    
        c = self.c
    
        for name in default_colors_dict.keys(): # Python 2.1 support.
            option_name,default_color = default_colors_dict[name]
            option_color = c.config.getColor(option_name)
            color = g.choose(option_color,option_color,default_color)
            # Must use foreground, not fg.
            try:
                self.body.tag_configure(name, foreground=color)
            except: # Recover after a user error.
                self.body.tag_configure(name, foreground=default_color)
        
        # underline=var doesn't seem to work.
        if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
            self.body.tag_configure("link",underline=1) # defined
            self.body.tag_configure("name",underline=0) # undefined
        else:
            self.body.tag_configure("link",underline=0)
            if self.underline_undefined:
                self.body.tag_configure("name",underline=1)
            else:
                self.body.tag_configure("name",underline=0)
                
        # Only create tags for whitespace when showing invisibles.
        if self.showInvisibles:
            for name,option_name,default_color in (
                ("blank","show_invisibles_space_background_color","Gray90"),
                ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
                option_color = c.config.getColor(option_name)
                color = g.choose(option_color,option_color,default_color)
                try:
                    self.body.tag_configure(name,background=color)
                except: # Recover after a user error.
                    self.body.tag_configure(name,background=default_color)
            
        # Colors for latex characters.  Should be user options...
        
        if 1: # Alas, the selection doesn't show if a background color is specified.
            self.body.tag_configure("latexModeBackground",foreground="black")
            self.body.tag_configure("latexModeKeyword",foreground="blue")
            self.body.tag_configure("latexBackground",foreground="black")
            self.body.tag_configure("latexKeyword",foreground="blue")
        else: # Looks cool, and good for debugging.
            self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
            self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
            self.body.tag_configure("latexBackground",foreground="black",background="white")
            self.body.tag_configure("latexKeyword",foreground="blue",background="white")
            
        # Tags for wiki coloring.
        if self.showInvisibles:
            self.body.tag_configure("elide",background="yellow")
        else:
            self.body.tag_configure("elide",elide="1")
        self.body.tag_configure("bold",font=self.bold_font)
        self.body.tag_configure("italic",font=self.italic_font)
        self.body.tag_configure("bolditalic",font=self.bolditalic_font)
        for name in self.color_tags_list:
            self.body.tag_configure(name,foreground=name)
    #@nonl
    #@-node:ekr.20050529143413.33:configure_tags
    #@+node:ekr.20050529143413.27:defineAndExtendForthWords
    def defineAndExtendForthWords(self):
        
        # Default forth keywords: extended by leo-forthwords.txt.
        self.forth_keywords = [
            "variable", "constant", "code", "end-code",
            "dup", "2dup", "swap", "2swap", "drop", "2drop",
            "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
            "if", "else", "then",
            "begin", "again", "until", "while", "repeat",
            "v-for", "v-next", "exit",
            "meta", "host", "target", "picasm", "macro",
            "needs", "include",
            "'", "[']",":", ";","@", "!", ",", "1+", "+", "-",
            "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
            "invert", "and", "or",
        ]
        
        # Forth words which define other words: extended by leo-forthdefwords.txt.
        self.forth_definingwords = [":", "variable", "constant", "code",]
        
        # Forth words which start strings: extended by leo-forthstringwords.txt.
        self.forth_stringwords = ['s"', '."', '"', '."','abort"',]
        
        # Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
        self.forth_boldwords = []
        
        # Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
        self.forth_italicwords = []
        
        # Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
        # Note: on some boxen, bold italics may show in plain bold.
        self.forth_bolditalicwords = []
        
        # Associate files with lists: probably no need to edit this.
        forth_items = (
            (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
            (self.forth_keywords, "leo-forthwords.txt", "words"),
            (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
            (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
            (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
            (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
        )
        
        # Add entries from files (if they exist) and to the corresponding wordlists.
        for (lst, path, typ) in forth_items:
            try:
                extras = []
                path = g.os_path_join(g.app.loadDir,"..","plugins",path)
                for line in file(path).read().strip().split("\n"):
                    line = line.strip()
                    if line and line[0] != '\\':
                        extras.append(line)
                if extras:
                    if 0: # I find this annoying.  YMMV.
                        if not g.app.unitTesting and not g.app.batchMode:
                            print "Found extra forth %s" % typ + ": " + " ".join(extras)
                    lst.extend(extras)
            except IOError:
                # print "Not found",path
                pass
    #@nonl
    #@-node:ekr.20050529143413.27:defineAndExtendForthWords
    #@+node:ekr.20050602152743:init_keywords
    def init_keywords (self,mode,ruleset):
        
        '''Initialize the keywords for the present language.
        
         Set word_chars to all non-alpha characters appearing in any keyword'''
    
        # Add any new user keywords to leoKeywords.
        for d in g.globalDirectiveList:
            name = '@' + d
            if name not in leoKeywords:
                leoKeywords.append(name)
        # Create a single keywords dict.
        keywords = {}
        for key in leoKeywords:
            keywords[key] = 0
    
        for i in (1,2,3,4):
            keys = mode.getKeywords(i,ruleset)
            for key in keys:
                if keywords.get(key):
                    print 'keyword %s defined in multiple places' % key
                keywords[key] = i
        # g.trace(len(keywords.keys()))
        # Create the word_chars list. 
        word_chars = {}
        for ch in string.letters:
            word_chars[ch] = None
        for keys in keywords.keys():
            for word in keys:
                for ch in word:
                    word_chars[ch] = None
        if 0: # Testing.
            #@        &lt;&lt; compute extra_word_chars &gt;&gt;
            #@+node:ekr.20050607073917:&lt;&lt; compute extra_word_chars &gt;&gt;
            extra_word_chars = {}
            for ch in word_chars:
                if ch not in string.letters and ch not in extra_word_chars:
                    extra_word_chars[ch] = None
            #@nonl
            #@-node:ekr.20050607073917:&lt;&lt; compute extra_word_chars &gt;&gt;
            #@nl
                
        return keywords,word_chars
    #@nonl
    #@-node:ekr.20050602152743:init_keywords
    #@+node:ekr.20050602150619:init_mode
    def init_mode (self,language):
        
        # bunch = self.modes.get(language)
        bunch = self.modes.get(language)
        if bunch:
            self.mode = bunch.mode
            self.defaultRulesList=bunch.defaultRulesList
            self.keywords = bunch.keywords
            self.rulesDict=bunch.rulesDict
            self.word_chars = bunch.word_chars
        else:
            self.mode = mode = self.parse_jEdit_file(language)
            if mode:
                g.trace(language)
                # Handle only the main rulese here.
                rulesets = mode.getRulesets()
                self.present_ruleset = ruleset = rulesets[0]
                # mode.printSummary (printStats=False)
                self.keywords,self.word_chars = self.init_keywords(mode,ruleset)
                    # Sets self.word_chars: must be called before createRuleMatchers.
                self.createRuleMatchers(ruleset.rules)
                    # Sets self.defaultRulesList &amp; self.rulesDict.
                bunch = g.bunch(mode=mode,
                    defaultRulesList=self.defaultRulesList,
                    keywords=self.keywords,
                    rulesDict=self.rulesDict,
                    word_chars=self.word_chars)
                self.modes[language] = bunch
            elif language:
                g.trace('No language description for %s' % language)
    #@nonl
    #@-node:ekr.20050602150619:init_mode
    #@+node:ekr.20050530065723.47:parse_jEdit_file
    def parse_jEdit_file(self,fileName,verbose=False):
        
        if not fileName:
            return None
        
        if not fileName.endswith('.xml'):
            fileName = fileName + '.xml'
    
        path = os.path.join(g.app.loadDir,'../','modes',fileName)
        path = os.path.normpath(path)
        
        try: f = open(path)
        except IOError:
            g.trace('can not open %s'%path)
            return None
    
        try:
            try:
                mode = None
                parser = xml.sax.make_parser()
                # Do not include external general entities.
                # The actual feature name is "http://xml.org/sax/features/external-general-entities"
                parser.setFeature(xml.sax.handler.feature_external_ges,0)
                handler = contentHandler(self.c,fileName,verbose=verbose)
                parser.setContentHandler(handler)
                parser.parse(f)
                # if verbose: handler.printSummary()
                mode = handler.getMode()
            except:
                g.es('unexpected exception parsing %s' % (fileName),color='red')
                g.es_exception()
        finally:
            f.close()
            return mode
    #@nonl
    #@-node:ekr.20050530065723.47:parse_jEdit_file
    #@+node:ekr.20050529143413.81:scanColorDirectives
    def scanColorDirectives(self,p):
        
        """Scan position p and p's ancestors looking for @comment, @language and @root directives,
        setting corresponding colorizer ivars.
        """
    
        p = p.copy() ; c = self.c
        if c == None: return # self.c may be None for testing.
    
        self.language = language = c.target_language
        self.comment_string = None
        self.rootMode = None # None, "code" or "doc"
        
        for p in p.self_and_parents_iter():
            # g.trace(p)
            s = p.v.t.bodyString
            theDict = g.get_directives_dict(s)
            #@        &lt;&lt; Test for @comment or @language &gt;&gt;
            #@+node:ekr.20050529143413.82:&lt;&lt; Test for @comment or @language &gt;&gt;
            # @comment and @language may coexist in the same node.
            
            if theDict.has_key("comment"):
                k = theDict["comment"]
                self.comment_string = s[k:]
            
            if theDict.has_key("language"):
                i = theDict["language"]
                language,junk,junk,junk = g.set_language(s,i)
                self.language = language
            
            if theDict.has_key("comment") or theDict.has_key("language"):
                break
            #@nonl
            #@-node:ekr.20050529143413.82:&lt;&lt; Test for @comment or @language &gt;&gt;
            #@nl
            #@        &lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
            #@+node:ekr.20050529143413.83:&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
            if theDict.has_key("root") and not self.rootMode:
            
                k = theDict["root"]
                if g.match_word(s,k,"@root-code"):
                    self.rootMode = "code"
                elif g.match_word(s,k,"@root-doc"):
                    self.rootMode = "doc"
                else:
                    doc = c.config.at_root_bodies_start_in_doc_mode
                    self.rootMode = g.choose(doc,"doc","code")
            #@nonl
            #@-node:ekr.20050529143413.83:&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
            #@nl
    
        return self.language # For use by external routines.
    #@nonl
    #@-node:ekr.20050529143413.81:scanColorDirectives
    #@+node:ekr.20050529143413.29:setFontFromConfig
    def setFontFromConfig (self):
        
        c = self.c
        
        self.bold_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize, tag = "colorer bold")
        
        if self.bold_font:
            self.bold_font.configure(weight="bold")
        
        self.italic_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize, tag = "colorer italic")
            
        if self.italic_font:
            self.italic_font.configure(slant="italic",weight="normal")
        
        self.bolditalic_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize, tag = "colorer bold italic")
            
        if self.bolditalic_font:
            self.bolditalic_font.configure(weight="bold",slant="italic")
            
        self.color_tags_list = []
        self.image_references = []
    #@nonl
    #@-node:ekr.20050529143413.29:setFontFromConfig
    #@+node:ekr.20050529143413.87:updateSyntaxColorer
    def updateSyntaxColorer (self,p):
    
        p = p.copy()
        # self.flag is True unless an unambiguous @nocolor is seen.
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p)
    #@nonl
    #@-node:ekr.20050529143413.87:updateSyntaxColorer
    #@+node:ekr.20050529143413.88:useSyntaxColoring
    def useSyntaxColoring (self,p):
        
        """Return True unless p is unambiguously under the control of @nocolor."""
        
        p = p.copy() ; first = p.copy()
        val = True ; self.killcolorFlag = False
        for p in p.self_and_parents_iter():
            # g.trace(p)
            s = p.v.t.bodyString
            theDict = g.get_directives_dict(s)
            no_color = theDict.has_key("nocolor")
            color = theDict.has_key("color")
            kill_color = theDict.has_key("killcolor")
            # A killcolor anywhere disables coloring.
            if kill_color:
                val = False ; self.killcolorFlag = True ; break
            # A color anywhere in the target enables coloring.
            if color and p == first:
                val = True ; break
            # Otherwise, the @nocolor specification must be unambiguous.
            elif no_color and not color:
                val = False ; break
            elif color and not no_color:
                val = True ; break
    
        return val
    #@-node:ekr.20050529143413.88:useSyntaxColoring
    #@-node:ekr.20050529143413.24:Birth and init
    #@+node:ekr.20050529145203:Entry points
    #@+node:ekr.20050529143413.30:colorize (Main entry point)
    def colorize(self,p,incremental=False):
        
        '''The main colorizer entry point.'''
        
        # g.trace(incremental)
    
        if self.enabled:
            self.incremental=incremental 
            self.updateSyntaxColorer(p)
            return self.colorizeAnyLanguage(p)
        else:
            return "ok" # For unit testing.
    #@nonl
    #@-node:ekr.20050529143413.30:colorize (Main entry point)
    #@+node:ekr.20050529143413.28:disable
    def disable (self):
    
        print "disabling all syntax coloring"
        self.enabled=False
        
    def enable (self):
        self.enabled=True
    #@nonl
    #@-node:ekr.20050529143413.28:disable
    #@+node:ekr.20050529145203.1:recolor_range
    def recolor_range(self,p,leading,trailing):
        
        '''An entry point for the colorer called from incremental undo code.
        Colorizes the lines between the leading and trailing lines.'''
        
        # g.trace(leading,trailing)
        
        if self.enabled:
            self.incremental=True
            self.invalidate_range(leading,trailing)
            self.updateSyntaxColorer(p)
            return self.colorizeAnyLanguage(p,leading=leading,trailing=trailing)
        else:
            return "ok" # For unit testing.
    #@nonl
    #@-node:ekr.20050529145203.1:recolor_range
    #@+node:ekr.20050529143413.84:schedule &amp; idle_colorize
    def schedule(self,p,incremental=0):
        
        __pychecker__ = '--no-argsused'
        # p not used, but it is difficult to remove.
    
        if self.enabled:
            self.incremental=incremental
            g.app.gui.setIdleTimeHook(self.idle_colorize)
            
    def idle_colorize(self):
    
        # New in 4.3b1: make sure the colorizer still exists!
        if hasattr(self,'enabled') and self.enabled:
            p = self.c.currentPosition()
            if p:
                self.incremental=False
                self.colorize(p)
    #@nonl
    #@-node:ekr.20050529143413.84:schedule &amp; idle_colorize
    #@-node:ekr.20050529145203:Entry points
    #@+node:ekr.20050529150436:Colorizer code
    #@+node:ekr.20050601042620:colorAll
    def colorAll(self,s):
        
        '''Colorize all of s.'''
    
        # Init ivars used by colorOneChunk.
        self.chunk_s = s
        self.chunk_i = 0
        self.chunk_last_i = 0
        self.kill_chunk = False
    
        self.colorOneChunk()
    #@-node:ekr.20050601042620:colorAll
    #@+node:ekr.20050529143413.31:colorizeAnyLanguage
    def colorizeAnyLanguage (self,p,leading=None,trailing=None):
        
        '''Color the body pane.  All coloring starts here.'''
        
        self.init_mode(self.language)
        if self.killcolorFlag or not self.mode:
            self.removeAllTags() ; return
        try:
            c = self.c
            self.p = p
            self.redoColoring = False
            self.redoingColoring = False
            self.was_non_incremental = not self.incremental
            # g.trace('was_non_incremental',self.was_non_incremental)
            if not self.incremental:
                # g.trace('removing tags')
                if 0: # removing tags causes flash at idle time.
                    self.removeAllTags()
                    self.removeAllImages()
                self.colored_ranges = {}
            self.configure_tags()
            g.doHook("init-color-markup",colorer=self,p=self.p,v=self.p)
            s = self.body.getAllText()
            self.colorAll(s)
            if self.redoColoring: # Set only from plugins.
                self.recolor_all()
            return "ok" # for unit testing.
        except Exception:
            g.es_exception()
            return "error" # for unit testing.
    #@nonl
    #@-node:ekr.20050529143413.31:colorizeAnyLanguage
    #@+node:ekr.20050601105358:colorOneChunk
    def colorOneChunk(self,allowBreak=True):
        '''Colorize a fixed number of tokens.
        If not done, queue this method again to continue coloring later.'''
        s,i = self.chunk_s,self.chunk_i
        count = 0 ; self.chunk_count += 1
        # g.trace('%3d'%(self.chunk_count),self.incremental)
        if not self.incremental:
            self.incremental = True
            #@        &lt;&lt; queue up this method the first time &gt;&gt;
            #@+node:ekr.20050605130806:&lt;&lt; queue up this method the first time &gt;&gt;
            self.chunk_s,self.chunk_i = s,i
            self.c.frame.top.after(50,self.colorOneChunk)
            #@nonl
            #@-node:ekr.20050605130806:&lt;&lt; queue up this method the first time &gt;&gt;
            #@nl
            return
        while i &lt; len(s):
            count += 1
            # Exit only after finishing the row.  This reduces flash.
            if i == 0 or s[i-1] == '\n':
                if self.kill_chunk: return
                if self.incremental and allowBreak:
                    if count &gt;= 50:
                        #@                    &lt;&lt; queue up this method &gt;&gt;
                        #@+node:ekr.20050601162452.1:&lt;&lt; queue up this method &gt;&gt;
                        self.chunk_s,self.chunk_i = s,i
                        self.c.frame.top.after_idle(self.colorOneChunk)
                        #@nonl
                        #@-node:ekr.20050601162452.1:&lt;&lt; queue up this method &gt;&gt;
                        #@nl
                        return
            for f,kind,token_type,delegate in self.rulesDict.get(s[i],self.defaultRulesList):
                n = f(self,s,i)
                if n &gt; 0:
                    self.doRule(s,i,i+n,kind,token_type,delegate)
                    i += n
                    break
            else:
                if self.present_ruleset.defaultColor:
                    self.colorRangeWithTag(s,i,i+1,self.present_ruleset.defaultColor.lower())
                # g.trace('no match')
                i += 1
    
        self.removeTagsFromRange(s,self.chunk_last_i,len(s))
    #@nonl
    #@-node:ekr.20050601105358:colorOneChunk
    #@+node:ekr.20050601065451:doColor &amp; helpers
    def doColor(self,s,i,j,token_type):
    
        helpers = {
            'doc_part':self.docPartColorHelper,
            'section_ref':self.sectionRefColorHelper,
            'keywords':self.keywordsColorHelper,
            '@color':self.atColorColorHelper,
            '@nocolor':self.atNocolorColorHelper,
        }
        
        # not in range of @nocolor.
        if self.flag:
            # g.trace(i,j,token_type)
            helper = helpers.get(token_type,self.defaultColorHelper)
            helper(token_type,s,i,j)
    #@nonl
    #@+node:ekr.20050603051440:atColorColorHelper &amp; atNocolorColorHelper
    def atColorColorHelper (self,token_type,s,i,j):
        
        # Enable coloring.
        self.flag = True
    
        # Color the Leo keyword.
        self.keywordNumber = 0
        self.keywordsColorHelper(token_type,s,i,j)
        
    def atNocolorColorHelper (self,token_type,s,i,j):
        
        if self.flag:
            # Color the Leo keyword.
            self.keywordNumber = 0
            self.keywordsColorHelper(token_type,s,i,j)
        
        # Disable coloring until next @color
        self.flag = False
    #@nonl
    #@-node:ekr.20050603051440:atColorColorHelper &amp; atNocolorColorHelper
    #@+node:ekr.20050602205810.4:colorRangeWithTag
    def colorRangeWithTag (self,s,i,j,tag):
    
        if self.was_non_incremental:
            must_color = True
            self.removeOldTagsFromRange(s,self.chunk_last_i,j)
        elif self.rangeColoredWithTag(i,j,tag):
            must_color = False
            # Remove the old tags to i.
            self.removeTagsFromRange(s,self.chunk_last_i,i)
        else:
            must_color = True
            # Remove the old tags to j.
            self.removeTagsFromRange(s,self.chunk_last_i,j)
    
        if must_color:
            # Remember the new tags.
            for k in xrange(i,j):
                self.colored_ranges[k] = tag
    
            # Do the real coloring.
            row,col = g.convertPythonIndexToRowCol(s,i)
            x1 = '%d.%d' % (row+1,col)
            row,col = g.convertPythonIndexToRowCol(s,j)
            x2 = '%d.%d' % (row+1,col)
            self.body.tag_add(tag,x1,x2)
    
        self.chunk_last_i = j
    #@nonl
    #@-node:ekr.20050602205810.4:colorRangeWithTag
    #@+node:ekr.20050602205810.3:defaultColorHelper
    def defaultColorHelper(self,token_type,s,i,j):
    
        d = {
            'seq': None,
            'literal1': 'string',
            'literal2': 'string',
            # 'keywords': 'keywords',
            'comment1': 'comment',
            'comment2': 'comment',
            'comment3': 'comment',
            'comment4': 'comment',
            'operator': None,
            # 'function': 'comment', # just for testing.
        }
        
        tag = d.get(token_type)
        if tag:
            self.colorRangeWithTag(s,i,j,tag)
    #@nonl
    #@-node:ekr.20050602205810.3:defaultColorHelper
    #@+node:ekr.20050602205810:docPartColorHelper
    def docPartColorHelper (self,token_type,s,i,j):
        
        i2 = g.choose(s[i:i+4] == '@doc',i+4,i+1)
        if   s[j-5:j] == '@code': j2 = j-5
        elif s[j-2:j] == '@c': j2 = j-2
        else: j2 = j
        
        # g.trace(i,i2,j2,j)
    
        self.colorRangeWithTag(s,i,i2,'leoKeyword')
        self.colorRangeWithTag(s,i2,j2,'docPart')
        self.colorRangeWithTag(s,j2,j,'leoKeyword')
    #@nonl
    #@-node:ekr.20050602205810:docPartColorHelper
    #@+node:ekr.20050603202319:invalidate_range
    def invalidate_range (self,i,j):
        
        for k in xrange(i,j):
            self.colored_ranges[k] = None
    #@nonl
    #@-node:ekr.20050603202319:invalidate_range
    #@+node:ekr.20050602205810.2:keywordsColorHelper
    def keywordsColorHelper (self,token_type,s,i,j):
        
        theList = ('leoKeyword','keyword1','keyword2','keyword3','keyword4',)
    
        tag = theList[self.keywordNumber]
    
        if tag:
            self.colorRangeWithTag(s,i,j,tag)
    #@nonl
    #@-node:ekr.20050602205810.2:keywordsColorHelper
    #@+node:ekr.20050603190206:rangeColoredWithTag
    def rangeColoredWithTag(self,i,j,tag):
        
        for k in xrange(i,j):
            if tag != self.colored_ranges.get(k):
                return False
        return True
    #@nonl
    #@-node:ekr.20050603190206:rangeColoredWithTag
    #@+node:ekr.20050605185452:removeOldTagsFromLine (not used)
    #@+at 
    #@nonl
    # Line-by line processing does not work because some tokens span multiple 
    # lines.
    #@-at
    #@@c
    
    def removeOldTagsFromLine(self,s,i):
    
        row,col = g.convertPythonIndexToRowCol(s,i)
        x1 = '%d.0' % (row+1)
        x2 = '%d.0' % (row+2)
        
        # g.trace('remove',x1,x2)
        
        for tag in self.tags:
            self.body.tag_remove(tag,x1,x2)
        
        for tag in self.color_tags_list:
            self.body.tag_remove(tag,x1,x2)
    #@nonl
    #@-node:ekr.20050605185452:removeOldTagsFromLine (not used)
    #@+node:ekr.20050605183244:removeOldTagsFromRange
    def removeOldTagsFromRange(self,s,i,j):
        
        '''Remove all tags from range without using the colored_ranges dict.
        
        This is executed when a non-incremental redraw clears the colored_ranges dict.'''
    
        row,col = g.convertPythonIndexToRowCol(s,i)
        x1 = '%d.%d' % (row+1,col)
        row,col = g.convertPythonIndexToRowCol(s,j)
        x2 = '%d.%d' % (row+1,col)
                
        for tag in self.tags:
            self.body.tag_remove(tag,x1,x2)
        
        for tag in self.color_tags_list:
            self.body.tag_remove(tag,x1,x2)
    #@nonl
    #@-node:ekr.20050605183244:removeOldTagsFromRange
    #@+node:ekr.20050603174749:removeTagsFromRange
    def removeTagsFromRange (self,s,i,j):
        
        tags = {}
        for k in xrange(i,j):
            tag = self.colored_ranges.get(k)
            if tag: # Must remove the tag, even if it will be reapplied (to a possibly different range).
                tags[tag] = None
                self.colored_ranges[k] = None
    
        row,col = g.convertPythonIndexToRowCol(s,i)
        x1 = '%d.%d' % (row+1,col)
        row,col = g.convertPythonIndexToRowCol(s,j)
        x2 = '%d.%d' % (row+1,col)
        
        # g.trace('row',row+1)
    
        for tag in tags.keys():
            # g.trace(tag,x1,x2)
            self.body.tag_remove(tag,x1,x2)
    #@nonl
    #@-node:ekr.20050603174749:removeTagsFromRange
    #@+node:ekr.20050602205810.1:sectionRefColorHelper
    ## To do: this assumes the 2-character brackets.
    
    def sectionRefColorHelper (self,token_type,s,i,j):
        
        # g.trace(i,j,s[i:j])
        
        self.colorRangeWithTag(s,i,i+2,'nameBrackets')
    
        ref = g.findReference(s[i:j],self.p)
        if ref:
            if self.use_hyperlinks:
                #@            &lt;&lt; set the hyperlink &gt;&gt;
                #@+node:ekr.20050607065634:&lt;&lt; set the hyperlink &gt;&gt;
                # Set the bindings to vnode callbacks.
                # Create the tag.
                # Create the tag name.
                tagName = "hyper" + str(self.hyperCount)
                self.hyperCount += 1
                self.body.tag_delete(tagName)
                self.tag(tagName,i+2,j)
                
                ref.tagName = tagName
                self.body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
                self.body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
                self.body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)
                #@nonl
                #@-node:ekr.20050607065634:&lt;&lt; set the hyperlink &gt;&gt;
                #@nl
            else:
                self.colorRangeWithTag(s,i+2,j-2,'link')
        else:
            self.colorRangeWithTag(s,i+2,j-2,'name')
    
        self.colorRangeWithTag(s,j-2,j,'nameBrackets')
    #@nonl
    #@-node:ekr.20050602205810.1:sectionRefColorHelper
    #@-node:ekr.20050601065451:doColor &amp; helpers
    #@+node:ekr.20050601162452.3:doRule &amp; colorByDelegate
    def doRule (self,s,i,j,kind,token_type,delegate):
        
        if kind == 'mark_following':
            pass
        
        elif kind == 'mark_previous':
            if 0: # This make no sense at all.
                if prev:
                    i2,j2,token_type2 = self.prev
                    g.trace('mark_previous',i2,j2,token_type2)
                    self.doColor(s,i2,j2,token_type) # Use the type specified in the mark_previous.
                    self.prev = None
        elif delegate:
            self.colorByDelegate(delegate,s,i,j,token_type)
            self.prev = (i,j,token_type)
        else:
            # g.trace('%3d %2d'%(i,j),state,repr(s[i:i+n]))
            self.doColor(s,i,j,token_type)
            self.prev = (i,j,token_type)
    #@nonl
    #@+node:ekr.20050607212958:colorByDelegate
    def colorByDelegate(self,delegate,s,i,j,token_type):
        
        # g.trace(delegate,repr(s[i:j]))
        
        if -1 == delegate.find('::'):
            # Use the ruleset in the present mode.
            rulesetName = delegate
        else:
            # file::ruleset
            file,rulesetName = delegate.split('::')
            self.init_mode(file)
            
        ruleset = self.mode.getRuleset(name=rulesetName)
        if ruleset:
            # self.mode.printRuleset(ruleset,tag=delegate)
            # Save ivars
            ### Bug: this doesn't handle nested delegates.
            ### Fix: don't save here:  move the ivars to the ruleset class and keep a stack of rulesets.
            self.save_present_ruleset = self.present_ruleset
            self.save_keywords = self.keywords # A bunch.
            self.save_word_chars = self.word_chars.copy()
            self.save_defaultRulesList = self.defaultRulesList[:]
            self.save_rulesDict = self.rulesDict.copy()
            # Set ivars for the delegated string only.
            # Sart at the real zero so row/column numbers are computed properly.
            self.chunk_s = s[0:j+1]
            self.chunk_i = i # Required.
            self.present_ruleset = ruleset
            self.keywords,self.word_chars = self.init_keywords(self.mode,ruleset)
            self.createRuleMatchers(ruleset.rules) # Sets self.defaultRulesList &amp; self.rulesDict.
            # Do the coloring with no break.
            self.colorOneChunk(allowBreak=False) 
            # Restore ivars.
            self.chunk_s = s
            self.chunk_i = j+1
            self.present_ruleset = self.save_present_ruleset
            self.keywords = self.save_keywords
            self.word_chars = self.save_word_chars
            self.defaultRulesList = self.save_defaultRulesList
            self.rulesDict = self.save_rulesDict
    #@nonl
    #@-node:ekr.20050607212958:colorByDelegate
    #@-node:ekr.20050601162452.3:doRule &amp; colorByDelegate
    #@+node:ekr.20050602144940:interrupt
    # This is needed, even without threads.
    def interrupt(self):
        '''Interrupt colorOneChunk'''
        self.kill_chunk = True
    #@nonl
    #@-node:ekr.20050602144940:interrupt
    #@+node:ekr.20050529143413.42:recolor_all
    def recolor_all (self):
    
        # This code is executed only if graphics characters will be inserted by user markup code.
        
        # Pass 1:  Insert all graphics characters.
        self.removeAllImages()
        s = self.body.getAllText()
        lines = s.split('\n')
        
        self.color_pass = 1
        self.line_index = 1
        state = self.setFirstLineState()
        for s in lines:
            state = self.colorizeLine(s,state)
            self.line_index += 1
        
        # Pass 2: Insert one blank for each previously inserted graphic.
        self.color_pass = 2
        self.line_index = 1
        state = self.setFirstLineState()
        for s in lines:
            #@        &lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;
            #@+node:ekr.20050529143413.43:&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;
            #@+at 
            #@nonl
            # A spectacular kludge.
            # 
            # Images take up a real index, yet the get routine does not return 
            # any character for them!
            # In order to keep the colorer in synch, we must insert dummy 
            # blanks in s at the positions corresponding to each image.
            #@-at
            #@@c
            
            inserted = 0
            
            for photo,image,line_index,i in self.image_references:
                if self.line_index == line_index:
                    n = i+inserted ; 	inserted += 1
                    s = s[:n] + ' ' + s[n:]
            #@-node:ekr.20050529143413.43:&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;
            #@nl
            state = self.colorizeLine(s,state)
            self.line_index += 1
    #@nonl
    #@-node:ekr.20050529143413.42:recolor_all
    #@-node:ekr.20050529150436:Colorizer code
    #@+node:ekr.20050529143413.89:Utils
    #@+at 
    #@nonl
    # These methods are like the corresponding functions in leoGlobals.py 
    # except they issue no error messages.
    #@-at
    #@+node:ekr.20050601044345:get_word (not used)
    def get_word(self,s,i):
    
        j = i
        while j &lt; len(s) and s[j] in self.word_chars:
            j += 1
    
        return s[i:j]
    #@nonl
    #@-node:ekr.20050601044345:get_word (not used)
    #@+node:ekr.20050529143413.90:index &amp; tag
    def index (self,i):
        
        return self.body.convertRowColumnToIndex(self.line_index,i)
            
    def tag (self,name,i,j):
    
        self.body.tag_add(name,self.index(i),self.index(j))
    #@nonl
    #@-node:ekr.20050529143413.90:index &amp; tag
    #@+node:ekr.20050529143413.86:removeAllImages
    def removeAllImages (self):
        
        for photo,image,line_index,i in self.image_references:
            try:
                self.body.deleteCharacter(image) # 10/27/03
            except:
                pass # The image may have been deleted earlier.
        
        self.image_references = []
    #@nonl
    #@-node:ekr.20050529143413.86:removeAllImages
    #@+node:ekr.20050529143413.80:removeAllTags &amp; removeTagsFromLines
    def removeAllTags (self):
        
        # Warning: the following DOES NOT WORK: self.body.tag_delete(self.tags)
        for tag in self.tags:
            self.body.tag_delete(tag)
    
        for tag in self.color_tags_list:
            self.body.tag_delete(tag)
        
    def removeTagsFromLine (self):
        
        # print "removeTagsFromLine",self.line_index
        for tag in self.tags:
            self.body.tag_remove(tag,self.index(0),self.index("end"))
            
        for tag in self.color_tags_list:
            self.body.tag_remove(tag,self.index(0),self.index("end"))
    #@nonl
    #@-node:ekr.20050529143413.80:removeAllTags &amp; removeTagsFromLines
    #@-node:ekr.20050529143413.89:Utils
    #@+node:ekr.20050529180421.47:Rule matching methods
    #@+node:ekr.20050530112849:createRuleMatchers
    def createRuleMatchers (self,rules):
        
        self.defaultRulesList = []
        self.rulesDict = {}
    
        # Put the Leo rules first on each list.
        for key,createMatcher in (
            ('@',self.createAtColorMatcher),
            ('@',self.createAtNocolorMatcher),
            ('@',self.createDocPartMatcher),
            ('&lt;',self.createSectionRefMatcher),
        ):
            f,name,token_type,delegate = createMatcher()
            rulesList = self.rulesDict.get(key,[])
            rulesList.append((f,name,token_type,delegate),)
            self.rulesDict[key] = rulesList
            
        for rule in rules:
            self.createRuleMatcher(rule)
            
        if 0:
            total = 0 ; n = len(self.rulesDict.keys())
            for key in self.rulesDict.keys():
                theList = self.rulesDict.get(key,[])
                total += len(theList)
            total += len(self.defaultRulesList)
            print 'mean length of rules list: %0.3f' % (float(total)/float(n+1))
    #@nonl
    #@-node:ekr.20050530112849:createRuleMatchers
    #@+node:ekr.20050530112849.1:createRuleMatcher
    def createRuleMatcher (self,rule):
        
        name = rule.name ; d = rule.attributes or {}
        token_type    = d.get('type','&lt;no type&gt;').lower()
        at_line_start = d.get('at_line_start',False)
        at_ws_end     = d.get('at_ws_end',False)
        at_word_start = d.get('at_word_start',False)
        delegate      = d.get('delegate','')
        no_line_break = d.get('no_line_break',False)
        d2 = rule.get('contents',{})
        seq     = d2.get(name,'')
        begin   = d2.get('begin','')
        end     = d2.get('end','')
        
        if name == 'eol_span':
            keys = [seq[0]]
            def f(self,s,i,seq=seq,
                at_line_start=at_line_start,at_ws_end=at_ws_end,at_word_start=at_word_start
            ):
                return self.match_eol_span(s,i,seq,at_line_start,at_ws_end,at_word_start)
        elif name == 'eol_span_regexp':
            keys = [seq[0]]
            def f(self,s,i,seq=seq,
                at_line_start=at_line_start,at_ws_end=at_ws_end,at_word_start=at_word_start
            ):
                return self.match_eol_span_regexp(s,i,seq,
                    at_line_start,at_ws_end,at_word_start)
        elif name == 'keywords':
            keys = self.word_chars
            def f(self,s,i):
                return self.match_keywords(s,i)
            token_type = 'keywords'
        elif name in ('mark_following','mark_previous','seq'):
            keys = [seq[0]]
            def f(self,s,i,seq=seq,
                at_line_start=at_line_start,at_ws_end=at_ws_end,at_word_start=at_word_start
            ):
                return self.match_seq(s,i,seq,at_line_start,at_ws_end,at_word_start)
        elif name == 'seq_regexp':
            keys = [hash_char]
            def f(self,s,i,seq=seq,hash_char=hash_char,
                at_line_start=at_line_start,at_ws_end=at_ws_end,at_word_start=at_word_start
            ):
                return self.match_seq_regexp(s,i,seq,hash_char,
                    at_line_start,at_ws_end,at_word_start)
        elif name == 'span':
            keys = [begin[0]]
            def f(self,s,i,begin=begin,end=end,
                at_line_start=at_line_start,at_ws_end=at_ws_end,
                at_word_start=at_word_start,no_line_break=no_line_break
            ):
                return self.match_span(s,i,begin,end,
                    at_line_start,at_ws_end,at_word_start,no_line_break)
        elif name == 'span_regexp':
            keys = [hash_char]
            def f(self,s,i,begin=begin,end=end,hash_char=hash_char,
                at_line_start=at_line_start,at_ws_end=at_ws_end,
                at_word_start=at_word_start,no_line_break=no_line_break
            ):
                return self.match_span_regexp(s,i,begin,end,hash_char,
                    at_line_start,at_ws_end,at_word_start,no_line_break)
        else:
            keys = []
            g.trace('no function for %s' % name)
            def f(self,s,i):
                return 0
    
        # Put f,name,token_type,delegate in the rulesDict or defaultRulesList.
        for key in keys:
            if key in string.printable:
                rulesList = self.rulesDict.get(key,[])
                rulesList.append((f,name,token_type,delegate),)
                self.rulesDict[key] = rulesList
            else:
                self.defaultRulesList.append((f,name,token_type,delegate),)
    
        # g.trace('%-25s'%(name+':'+token_type),at_line_start,at_ws_end,at_word_start,repr(seq),repr(begin),repr(end))
    #@nonl
    #@-node:ekr.20050530112849.1:createRuleMatcher
    #@+node:ekr.20050602204708:createDocPartMatcher &amp; createSectionRefMatcher
    def createDocPartMatcher (self):
        
        def f(self,s,i):
            return self.match_doc_part(s,i)
    
        name = token_type = 'doc_part'
        delegate = ''
        return f,name,token_type,delegate
    
    def createSectionRefMatcher (self):
        
        def f(self,s,i):
            return self.match_section_ref(s,i)
    
        name = token_type = 'section_ref'
        delegate = ''
        return f,name,token_type,delegate
    #@nonl
    #@-node:ekr.20050602204708:createDocPartMatcher &amp; createSectionRefMatcher
    #@+node:ekr.20050603043840:createAtColorMatcher &amp; createAtNocolorMatcher
    def createAtColorMatcher (self):
        
        def f(self,s,i):
            return self.match_at_color(s,i)
    
        name = token_type = '@color'
        delegate = ''
        return f,name,token_type,delegate
    
    def createAtNocolorMatcher (self):
        
        def f(self,s,i):
            return self.match_at_nocolor(s,i)
    
        name = token_type = '@nocolor'
        delegate = ''
        return f,name,token_type,delegate
    #@nonl
    #@-node:ekr.20050603043840:createAtColorMatcher &amp; createAtNocolorMatcher
    #@+node:ekr.20050603043840.1:match_at_color
    def match_at_color (self,s,i):
    
        seq = '@color'
        
        if i != 0 and s[i-1] != '\n': return 0
    
        if g.match_word(s,i,seq):
            # g.trace(i)
            self.flag = True # Enable coloring now so @color itself gets colored.
            return len(seq)
        else:
            return 0
    #@-node:ekr.20050603043840.1:match_at_color
    #@+node:ekr.20050603043840.2:match_at_nocolor
    def match_at_nocolor (self,s,i):
        
        seq = '@nocolor'
        
        if i != 0 and s[i-1] != '\n':
            return 0
    
        if g.match_word(s,i,seq):
            self.keywordNumber = 0
            return len(seq)
        else:
            return 0
    #@nonl
    #@-node:ekr.20050603043840.2:match_at_nocolor
    #@+node:ekr.20050529190857:match_keywords
    # This is a time-critical method.
    def match_keywords (self,s,i):
        
        '''Return the length of the keyword if present position matches any keyword.
        Otherwise, return 0.'''
        
        # We must be at the start of a word.
        if i &gt; 0 and s[i-1] in self.word_chars:
            return 0
            
        # Get the word as quickly as possible.
        j = i ; n = len(s) ; w = self.word_chars
        while j &lt; n and s[j] in w:
            j += 1
       
        k = self.keywords.get(s[i:j],-1)
        if k &gt; -1:
            self.keywordNumber = k
            # g.trace(i,s[i:j])
            return j-i
        else:
            return 0
    #@nonl
    #@-node:ekr.20050529190857:match_keywords
    #@+node:ekr.20050529182335:match_regexp_helper (TO DO)
    def match_regexp_helper (self,s,i,seq):
        
        '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
        
        ### We may want to return a match object too.
        
        return 0 ### Not ready yet.
    #@nonl
    #@-node:ekr.20050529182335:match_regexp_helper (TO DO)
    #@+node:ekr.20050601045930:match_eol_span
    def match_eol_span (self,s,i,seq,at_line_start,at_ws_end,at_word_start):
        
        '''Return the length of the rest of line if SEQ matches s[i:]
        Return 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.'''
    
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
        
        # g.trace(i,repr(s[i]),repr(seq))
    
        if g.match(s,i,seq):
            j = g.skip_to_end_of_line(s,i)
            return j - i 
        else:
            return 0
    #@-node:ekr.20050601045930:match_eol_span
    #@+node:ekr.20050601063317:match_eol_span_regexp
    def match_eol_span_regexp (self,s,i,seq,at_line_start,at_ws_end,at_word_start,hash_char):
        
        '''Return the length of rest if the line if seq (a regx) matches s[i:]
        Return 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.
        'hash_char':        The first character of the regexp (for speed).'''
    
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
        
        # Test hash_char first to increase speed.
        if i &lt; len(s) and s[i] == hash_char:
            n = self.match_regexp_helper(s,i,seq)
            if n &gt; 0:
                j = g.skip_to_end_of_line(s,i)
                return j - i
            else:
                return 0
        else:
            return 0
    #@nonl
    #@-node:ekr.20050601063317:match_eol_span_regexp
    #@+node:ekr.20050529182335.1:match_seq, match_mark_following/previous
    def match_seq (self,s,i,seq,at_line_start,at_ws_end,at_word_start):
        
        '''Return the length of a matched SEQ or 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.'''
    
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
    
        if g.match(s,i,seq): return len(seq)
        else: return 0
    
    # For spans &amp; marks, seq comes from the contents.
    match_mark_following  = match_seq
    match_mark_previous   = match_seq
    #@nonl
    #@-node:ekr.20050529182335.1:match_seq, match_mark_following/previous
    #@+node:ekr.20050602211219:match_section_ref
    def match_section_ref (self,s,i):
        
        if not g.match(s,i,'&lt;&lt;'):
            return 0
            
        val = g.find_on_line(s,i+2,'&gt;&gt;')
        if val is not None:
            return val + 2 - i
        else:
            return 0
    #@nonl
    #@-node:ekr.20050602211219:match_section_ref
    #@+node:ekr.20050602211253:match_doc_part
    def match_doc_part (self,s,i):
        
        if i &gt;= len(s) or s[i] != '@':
            return 0
    
        if i + 1 &gt;= len(s):
            return 1
            
        if not g.match_word(s,i,'@doc') and not s[i+1] in (' ','\t','\n'):
            return 0
    
        j = i
        while 1:
            k = s.find('@c',j)
            if k == -1:
                return len(s) - i
            if s[k-1] != '\n' or (not g.match_word(s,k,'@c') and not g.match_word(s,k,'@code')):
                j = j + k + 1
                continue
            elif g.match_word(s,k,'@c'):
                return k + 2 - i
            else:
                return k + 5 - i
    #@nonl
    #@-node:ekr.20050602211253:match_doc_part
    #@+node:ekr.20050529215620:match_seq_regexp
    def match_seq_regexp (self,s,i,seq,hash_char,
        at_line_start,at_ws_end,at_word_start):
        
        '''Return the length of a matched SEQ_REGEXP or 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.
        'hash_char':        The first character of the regexp (for speed).'''
    
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
        
        # Test hash_char first to increase speed.
        if i &lt; len(s) and s[i] == hash_char:
            return self.match_regexp_helper(s,i,seq)
        else:
            return 0
    #@nonl
    #@-node:ekr.20050529215620:match_seq_regexp
    #@+node:ekr.20050529185208.2:match_span
    def match_span (self,s,i,begin,end,
        at_line_start,at_ws_end,at_word_start,no_line_break):
        
        '''Return the length of a matched SPAN or 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.
        'no_line_break':    True: sequence must not cross a line.'''
        
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
    
        if g.match(s,i,begin):
            j = s.find(end,i+len(begin))
            if j &gt; -1:
                # g.trace(no_line_break,i,j,repr(s[i:j]))
                if no_line_break and '\n' in s[i:j]:
                    return 0
                else:
                    return j + len(end) - i
            else:
                return 0
        else:
            return 0
    #@-node:ekr.20050529185208.2:match_span
    #@+node:ekr.20050529215732:match_span_regexp
    def match_span_regexp (self,s,i,begin,end,hash_char,
        at_line_start,at_ws_end,at_word_start,no_line_break):
        
        '''Return the length of a matched SPAN_REGEXP or 0 if no match.
    
        'at_line_start':    True: sequence must start the line.
        'at_ws_end':        True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.
        'at_word_start':    True: sequence must start a word.
        'hash_char':        The first character of the regexp (for speed).'''
        
        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_ws_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] not in self.word_chars: return 0
        
        # Test hash_char first to increase speed.
        if i &lt; len(s) and s[i] == hash_char:
            n = self.match_regexp_helper(s,i,begin)
            # We may have to allow $n here, in which case we must use a regex object?
            if n &gt; 0 and g.match(s,i+n,end):
                return n + len(end)
        else:
            return 0
    #@nonl
    #@-node:ekr.20050529215732:match_span_regexp
    #@-node:ekr.20050529180421.47:Rule matching methods
    #@-others

class colorizer (baseColorizer):
    pass
#@nonl
#@-node:ekr.20050606214036:class colorizer (baseColorizer)
#@+node:ekr.20050606213440:class nullColorizer (colorizer)
class nullColorizer (colorizer):
    
    """A do-nothing colorer class"""
    
    #@    @+others
    #@+node:ekr.20050606213440.1:__init__
    def __init__ (self,c):
        
        colorizer.__init__(self,c) # init the base class.
    
        self.c = c
        self.enabled = False
    #@-node:ekr.20050606213440.1:__init__
    #@+node:ekr.20050606213440.2:entry points
    def colorize(self,p,incremental=False): pass
    
    def disable(self): pass
        
    def enable(self): pass
        
    def idle_colorize(self): pass
            
    def recolor_range(self,p,leading,trailing): pass
    
    def scanColorDirectives(self,p): pass
        
    def schedule(self,p,incremental=0): pass
    
    def updateSyntaxColorer (self,p): pass
    #@nonl
    #@-node:ekr.20050606213440.2:entry points
    #@-others
#@nonl
#@-node:ekr.20050606213440:class nullColorizer (colorizer)
#@-others
#@nonl
#@-node:ekr.20050529142847:@thin __jEdit_colorizer__.py
#@-leo
</t>
<t tx="zorcanda!.20050914114543">import javax.swing as swing
import java.awt as awt
import sys


if __name__ == "__main__": 
    
    if len( sys.argv ) &gt; 1:
        uim = swing.UIManager
        nlf = uim.getSystemLookAndFeelClassName()
        uim.setLookAndFeel( nlf )
    else:
        pass
        
        
    jf = swing.JFrame()
    cp1 = jf.contentPane
    cp1.setBackground( awt.Color.RED )
    cp = swing.JPanel( awt.GridLayout( 2, 2 ))
    cp.setOpaque( 0) 
    cp1.add( cp )
    jt = swing.JTree()
    jt.setOpaque( 0 )
    cp.add( jt )
    jta = swing.JTextArea()
    jta.setText( "JTextArea" )
    jta.setOpaque( 0 )
    cp.add( jta )
    jtp = swing.JTextPane()
    jtp.setText( "JTextPane" )
    jtp.setOpaque( 0 )
    cp.add( jtp )
    jb = swing.JButton( "See Me" )
    jb.setOpaque( 0 )
    cp.add( jb )
    jf.pack()
    jf.visible = 1
    </t>
<t tx="zorcanda!.20050922115413">@others
</t>
<t tx="zorcanda!.20051004113423">@language java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import java.util.*;

public class ExpandTreeExample extends JTree{

    public boolean use_normal_expansion_methods;
    static Vector&lt;TreePath&gt; tps = new Vector&lt;TreePath&gt;();

    public ExpandTreeExample( TreeModel tm ){
    
        super( tm );
        use_normal_expansion_methods = false;
    }


    public void setUseNormalExpansionMethods( boolean use ){
    
        use_normal_expansion_methods = use;
    
    
    }

    //These 2 methods seem to only return information that is tracked internally, 
    //they don't affect whether a tree node is expanded or not on reload,
    //but they affect whether or not a node is expanded when clicked on.
    @Override
    public boolean isExpanded( TreePath tp ){
    
        //if( use_normal_expansion_methods )
            return super.isExpanded( tp );
    
        //System.out.println( "isExpanded " + tp );
        //uncomment to see how they expand the tree but also give a nasty flicker/flash when doing so
        //setExpandedState( tp, true );
        
        //In my application it would be nifty if I could query the data passed in and see if it was expanded.
        //This I can do, but it doesn't do what I expect if I just return the 'true' or 'false'.
        //return true; //just returning true all the time seems to interfere with Mouse click expansion/collapse
    
    }

    @Override
    public boolean hasBeenExpanded( TreePath tp ){ 
        
        //if( use_normal_expansion_methods )
        return super.hasBeenExpanded( tp );
        //System.out.println( "hasBeenExpanded " + tp );
        //uncomment to see how they expand the tree but also give a nasty flicker/flash when doing so
        //setExpandedState( tp, true );
        //return true; //just returning true all the time seems to interfere with Mouse click expansion/collapse
    
    }


    @Override
    public Enumeration&lt; TreePath &gt; getExpandedDescendants( TreePath tp ){
        
        //java.lang.Thread.currentThread().dumpStack();
        System.out.println( tp );
        return tps.elements();
        //return super.getExpandedDescendants( tp );
    
    
    }
    /* Since the previous 2 methods, don't quite do what I want I have to have a component that imposes the expanded state
       after each reload.  Ideally for my app, it would be great to not have to impose it.  Maybe a simple scheme where the
       model could implement a "NodeExpansionModel" that has a method:
       public boolean pathExpanded( TreePath tp )  --&gt; this return true if the path is expanded, false otherwise
       or/and
       public boolean nodeExpanded( Object node ) --&gt; this returns true if the node identified by 'node' is expanded or not.
       
       then the JTree could just query the "NodeExpansionModel" when reloaded to determine which nodes are expanded or not.
       For my app this would be great in that the nodes contain information about their expansion state:
       p.isExpanded() #--&gt; p is a Position in my app, it is the front end class for the 'node'
       
       when the JTree is reloaded, I currently have to iterate over my structure and then build a TreePath for each expanded node.
       This TreePath, in turn is passed to 'fireTreeExpanded' of the JTree instance.
       
       My simple thesis, again, is that it would be a nice improvement if the JTree did the work of deciding if a node is expanded
       or not, via querying some model.  Maybe the method to add the model would be:
       setNodeExpansionModel( NodeExpansionModel model )
       if the NodeExpansionModel isn't set, then you could just use the current behavior when reloading--&gt; which is not to
       expand anything */
       
       
    
    
    public static void main( String[] args ){
    
        JFrame jf = new JFrame();
        jf.getContentPane().setLayout( new BorderLayout() );
        final DefaultMutableTreeNode dmtn = new DefaultMutableTreeNode( "Using Overrides" );
        for( int i = 0; i &lt; 5; i++ ){
            DefaultMutableTreeNode dmtn2 = new DefaultMutableTreeNode( i );
            dmtn.add( dmtn2 );
            for( int i2 = 0; i2 &lt; 5; i2++ ){
             DefaultMutableTreeNode dmtn3 = new DefaultMutableTreeNode( i + "" + i2 );  
             dmtn2.add( dmtn3 );
             DefaultMutableTreeNode[] path = new DefaultMutableTreeNode[]{ dmtn, dmtn2, dmtn3 };
             tps.add( new TreePath( path ) );
             
             }
        
        }
        
        final DefaultTreeModel dtm = new DefaultTreeModel( dmtn );
        final ExpandTreeExample jt = new ExpandTreeExample( dtm );
        JScrollPane jsp = new JScrollPane( jt );
        jf.add( jsp );
        JButton jb = new JButton( new AbstractAction( "Reload" ){
        
        
            public void actionPerformed( ActionEvent ae ){
                
                System.out.println( "PRE RELOAD" );
                dtm.reload();
                TreePath tp = new TreePath( dmtn );
                //jt.fireTreeExpanded( tp );
                //jt.firePropertyChange( jt.TREE_MODEL_PROPERTY, dtm, dtm );
                //jt.expandPath( tp );
                //jt.setModel( null );
                //jt.setModel( dtm );
                //jt.updateUI();
                System.out.println( "POST RELOAD" );
            
            }
        
        
        
        });
        jb.setToolTipText( "Press Me To Reload The TreeModel" );
        JButton jb2 = new JButton( new AbstractAction( "Toggle Normal Expansion Methods" ){
        
            public void actionPerformed( ActionEvent ae ){
            
                if( jt.use_normal_expansion_methods ){
                    dmtn.setUserObject( "Using Overrides" );
                    System.out.println( "Setting Overrides to False" );
                    jt.setUseNormalExpansionMethods( false );
                }
                else{
                    
                    dmtn.setUserObject( "Not Using Overrides" );
                    System.out.println( "Setting Use Normal Methods" );
                    jt.setUseNormalExpansionMethods( true );
                    
                }
            dtm.reload();
            
            
            }
        
        
        
        });
        jb2.setToolTipText( "Press Me to Toggle Back to Normal JTree Expansion Methods" );
        JPanel jp = new JPanel();
        jp.add( jb );
        jp.add( jb2 );
        jf.add( jp, BorderLayout.SOUTH );
        jf.pack();
        jf.setVisible( true );
    
    
    
    
    
    }


}</t>
<t tx="zorcanda!.20051006111637">@path jconstants

</t>
<t tx="zorcanda!.20051101111231">@others</t>
<t tx="zorcanda!.20051101193213">import javax.swing as swing
import javax.swing.text as stext
import javax.swing.event as sevent
import java.awt.event as aevent

jf = swing.JFrame()
jtp = swing.JTextPane()
jsp = swing.JScrollPane( jtp )
jf.add( jsp )

class doc1( sevent.DocumentListener ):
    
    
    def removeUpdate( self, event ):
        
        print stext.Utilities.getRowStart( jtp, event.getOffset() )
        
    def changeUpdate( self, event ):
        #print event
        pass
        
    def insertUpdate( self, event ):
        #print event
        pass
        
class kp( aevent.KeyAdapter ):
    
    def __init__( self ):
        aevent.KeyAdapter.__init__( self )
            
    def keyPressed( self, event ):
        
        #event.consume()
        kc = event.getKeyChar()
        print kc
        if kc == 'x':
            event.consume()
            cp = jtp.getCaretPosition()
            rs = stext.Utilities.getRowStart( jtp, cp )
            re = stext.Utilities.getRowEnd( jtp, cp )
            rs1 = stext.Utilities.getRowStart( jtp, re + 1 )
            re1 = stext.Utilities.getRowEnd( jtp, re + 1 )
            doc = jtp.getDocument()
            line1 = doc.getText( rs, re - rs )
            line2 = doc.getText( rs1, re1- rs1 )
            doc.replace( rs1, re1 - rs1, line1, None )
            doc.replace( rs, re - rs, line2, None )
            
            
        
jtp.getDocument().addDocumentListener( doc1() )
jtp.addKeyListener( kp() )
jf.size = ( 400, 400 )
jf.visible = 1
</t>
<t tx="zorcanda!.20051108223332">@path org/leo</t>
<t tx="zorcanda!.20051114092424">@path org/leo/shell
</t>
<t tx="zorcanda!.20051114093736">@path org/leo/shell/magic</t>
<t tx="zorcanda!.20051115102332">@language java
import javax.swing.*;
import java.awt.*;


public class JListProblem{



    public static void main( String[] args ){
    
        PopupFactory pf = PopupFactory.getSharedInstance();
        Object[] data1 =  new Object[]{ " ", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data2 = new Object[]{ "Im not blank", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data3 =  new Object[]{ "", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data4 =  new Object[]{ "OOOOoo", "", "Greeeniesss", "vooodooo", "", "#%&amp;*1!", "Milk", "moles", "" };
        JList jl1 = new JList( data1 );
        jl1.setVisibleRowCount( 5 );
        JScrollPane jsp1 = new JScrollPane( jl1 );
        Popup pu = pf.getPopup( null, jsp1, 10, 10);
        pu.show();
        
        JList jl2 = new JList( data2 );
        jl2.setVisibleRowCount( 5 );
        JScrollPane jsp2 = new JScrollPane( jl2 );
        Point ss = jsp1.getLocation();
        SwingUtilities.convertPointToScreen( ss, jsp1 );
        Popup pu2 = pf.getPopup( null, jsp2, ss.x + jsp1.getSize().width + 10, 10 ); 
        pu2.show();
    
        JList jl3 = new JList( data3 );
        jl3.setVisibleRowCount( 5 );
        JScrollPane jsp3 = new JScrollPane( jl3 );
        Point ss2 = jsp2.getLocation();
        SwingUtilities.convertPointToScreen( ss2, jsp2 );
        Popup pu3 = pf.getPopup( null, jsp3, ss2.x + jsp2.getSize().width + 10, 10 );
        pu3.show();

        JList jl4 = new JList( data4 );
        jl4.setVisibleRowCount( 5 );
        JScrollPane jsp4 = new JScrollPane( jl4 );
        Point ss3 = jsp3.getLocation();
        SwingUtilities.convertPointToScreen( ss2, jsp3 );
        Popup pu4 = pf.getPopup( null, jsp4, ss2.x + jsp3.getSize().width + 10, 10 );
        pu4.show();
    
    
    }




}</t>
<t tx="zorcanda!.20051115154911">@path org/leo/shell/actions</t>
<t tx="zorcanda!.20051115191914">@path org/leo/shell/io
</t>
<t tx="zorcanda!.20051115192359">@path org/leo/shell/util
</t>
<t tx="zorcanda!.20051115195219">@path org/leo/shell/widget</t>
<t tx="zorcanda!.20051120222558">@path org/leo/shell/color
</t>
<t tx="zorcanda!.20051121130625">@path org/leo/shell/magic/editor
</t>
<t tx="zorcanda!.20051121155957">@path org/leo/shell/alias
</t>
<t tx="zorcanda!.20051129101251">import javax.swing as swing
import java

class LR2( swing.ListCellRenderer ):
    def __init__( self ):
        self.component = swing.JLabel()
        self.component.setText( "&lt;html&gt;" )
        
    def getListCellRendererComponent( self, list, value, index, isSelected, cellHasFocus):
        
        self.component.setText( value )
        return self.component
        
        
jl = swing.JList()
jl.setCellRenderer( LR2() )
rs = java.lang.ClassLoader.getSystemClassLoader().findResource( "back.gif" )
data = [ "&lt;html&gt;&lt;img src='%s'&gt;Hi!" % rs, "&lt;html&gt;&lt;img src='%s'&gt;MEOW" % rs ]

jl.setListData( data )
jsp = swing.JScrollPane( jl )
jl2 = swing.JLabel()
jl2.setText( data[ 0 ] )
jf = swing.JFrame()
jf.add( jsp )
jf.add( jl2, java.awt.BorderLayout.SOUTH )
jf.pack()
jf.visible = 1



</t>
<t tx="zorcanda!.20051210115447">&lt;?xml version="1.0" ?&gt;
&lt;project default="main"&gt;
    &lt;target name="main" depends="compile" &gt;
        &lt;echo&gt;JythonShell built&lt;/echo&gt;
    &lt;/target&gt;
    
    &lt;target name="compile"&gt;
        &lt;echo&gt;Building shell package&lt;/echo&gt;
        &lt;javac srcdir="." listfiles="true" /&gt;
        &lt;echo&gt;Building util package&lt;/echo&gt;
        &lt;javac srcdir="./util" listfiles="true"/&gt;
        &lt;echo&gt;Building io package&lt;/echo&gt;
        &lt;javac srcdir="./io" listfiles="true" /&gt;
        &lt;echo&gt;Building magic package&lt;/echo&gt;
        &lt;javac srcdir="./magic" listfiles="true" /&gt;
        &lt;echo&gt;Building actions package&lt;/echo&gt;
        &lt;javac srcdir="./actions" listfiles="true" /&gt;
        &lt;echo&gt;Building alias package&lt;/echo&gt;
        &lt;javac srcdir="./alias" listfiles="true" /&gt;
        &lt;echo&gt;Building widget pacakge&lt;/echo&gt;
        &lt;javac srcdir="./widget" listfiles="true" /&gt;
        &lt;echo&gt;Building color package&lt;/echo&gt;
        &lt;javac srcdir="./color" listfiles="true" /&gt;
    &lt;/target&gt;

&lt;/project&gt;</t>
</tnodes>
</leo_file>
