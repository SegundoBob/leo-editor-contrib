<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>../doc/ListManagerDocs.html</title>
<meta name="author" content="Steven Zatz, Modified by EKR." />
<meta name="date" content="2005-08-17" />
<meta name="copyright" content="Application and documentation use the Python license which is compatible with the GPL." />
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/07/09 14:03:05 $
:version: $Revision: 1.1 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}
  
@import url(leo_rst.css);
@import url(silver_city.css);


</style>
</head>
<body>
<div class="document" id="doc-listmanagerdocs-html">
<h1 class="title">../doc/ListManagerDocs.html</h1>
<h2 class="subtitle" id="listmanager-documentation">ListManager Documentation</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Steven Zatz, Modified by EKR.</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:slzatz&#64;hotmail.com">slzatz&#64;hotmail.com</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2005-08-17</td></tr>
<tr><th class="docinfo-name">Status:</th>
<td>This is a &quot;work in progress&quot;</td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>1.426</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Application and documentation use the Python license which is compatible with the GPL.</td></tr>
</tbody>
</table>
<!-- rst3: filename: ../doc/ListManagerDocs.html -->
<p>This is experimental documentation of a program called ListManager, written in
Python and wxPython using Leo to create both the application code and the
associated reST documentation.</p>
<p>ListManager is an application that allows a group of people working on a joint
project to maintain a common list of todos and related items that have owners,
due dates and associated notes. The application uses mysql as its database for
group use and also uses sqlite for locally resident databases for personal
lists. It works in conjunction with Outlook to allow email messages to be sent
to ListManager for inclusion in lists and uses Outlook to mail messages to
users.</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#wxlistmanager-py" id="id15" name="id15">wxListManager.py</a><ul>
<li><a class="reference" href="#initial-stuff" id="id16" name="id16">Initial stuff</a><ul>
<li><a class="reference" href="#module-imports" id="id17" name="id17">Module Imports</a></li>
<li><a class="reference" href="#constants" id="id18" name="id18">Constants</a></li>
<li><a class="reference" href="#menu-ids" id="id19" name="id19">Menu IDs</a></li>
<li><a class="reference" href="#read-config-file" id="id20" name="id20">Read Config File</a></li>
</ul>
</li>
<li><a class="reference" href="#class-listmanager" id="id21" name="id21">class ListManager</a><ul>
<li><a class="reference" href="#instantiation" id="id22" name="id22">Instantiation</a><ul>
<li><a class="reference" href="#def-init" id="id23" name="id23">def __init__</a><ul>
<li><a class="reference" href="#list-manager-attributes" id="id24" name="id24">&lt;&lt; List Manager Attributes &gt;&gt;</a></li>
<li><a class="reference" href="#menu-setup" id="id25" name="id25">&lt;&lt; Menu Setup &gt;&gt;</a></li>
<li><a class="reference" href="#toolbar-setup" id="id26" name="id26">&lt;&lt; Toolbar Setup &gt;&gt;</a></li>
<li><a class="reference" href="#menu-toolbar-events" id="id27" name="id27">&lt;&lt; Menu/Toolbar Events &gt;&gt;</a></li>
<li><a class="reference" href="#create-controls" id="id28" name="id28">&lt;&lt; Create Controls&gt;&gt;</a></li>
<li><a class="reference" href="#other-events" id="id29" name="id29">&lt;&lt; Other Events &gt;&gt;</a></li>
<li><a class="reference" href="#layout-stuff" id="id30" name="id30">&lt;&lt; Layout Stuff &gt;&gt;</a></li>
<li><a class="reference" href="#gui-instance-objects" id="id31" name="id31">&lt;&lt; GUI Instance Objects &gt;&gt;</a></li>
<li><a class="reference" href="#create-socket" id="id32" name="id32">&lt;&lt; Create Socket &gt;&gt;</a></li>
<li><a class="reference" href="#load-recent-files" id="id33" name="id33">&lt;&lt; Load Recent Files &gt;&gt;</a></li>
<li><a class="reference" href="#idle-timer" id="id34" name="id34">&lt;&lt; Idle Timer &gt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#ownerlist-creation-methods-used-by-thread" id="id35" name="id35">Ownerlist creation methods (used by thread)</a><ul>
<li><a class="reference" href="#def-createownerlist" id="id36" name="id36">def createownerlist</a></li>
<li><a class="reference" href="#def-createownerdialog" id="id37" name="id37">def createownerdialog</a></li>
</ul>
</li>
<li><a class="reference" href="#notebook-methods" id="id38" name="id38">Notebook methods</a><ul>
<li><a class="reference" href="#def-createnewnotebookpage" id="id39" name="id39">def CreateNewNotebookPage</a><ul>
<li><a class="reference" href="#fill-ownerlistbox" id="id40" name="id40">&lt;&lt; Fill OwnerListBox &gt;&gt;</a></li>
<li><a class="reference" href="#listcontrol-events" id="id41" name="id41">&lt;&lt; ListControl Events &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#def-onpagechange" id="id42" name="id42">def OnPageChange</a><ul>
<li><a class="reference" href="#find-highlighted-row" id="id43" name="id43">&lt;&lt; Find Highlighted Row &gt;&gt;</a></li>
<li><a class="reference" href="#update-title" id="id44" name="id44">&lt;&lt; Update Title &gt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#tickler-methods" id="id45" name="id45">Tickler methods</a><ul>
<li><a class="reference" href="#def-onshowtickler" id="id46" name="id46">def OnShowTickler</a></li>
<li><a class="reference" href="#def-onactivatetickler" id="id47" name="id47">def OnActivateTickler</a></li>
</ul>
</li>
<li><a class="reference" href="#email-methods" id="id48" name="id48">Email methods</a><ul>
<li><a class="reference" href="#onmailitem" id="id49" name="id49">OnMailItem</a></li>
<li><a class="reference" href="#onmailview" id="id50" name="id50">OnMailView</a></li>
</ul>
</li>
<li><a class="reference" href="#cut-copy-paste-methods" id="id51" name="id51">Cut/Copy/Paste methods</a><ul>
<li><a class="reference" href="#oncopyitems" id="id52" name="id52">OnCopyItems</a><ul>
<li><a class="reference" href="#find-highlighted-items" id="id53" name="id53">&lt;&lt; Find Highlighted Items &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#onpasteitems" id="id54" name="id54">OnPasteItems</a></li>
<li><a class="reference" href="#ondeleteitems" id="id55" name="id55">OnDeleteItems</a></li>
</ul>
</li>
<li><a class="reference" href="#mousedown-methods" id="id56" name="id56">MouseDown methods</a><ul>
<li><a class="reference" href="#onleftdown-action-depends-on-x-coordinate" id="id57" name="id57">OnLeftDown (Action depends on x coordinate)</a></li>
<li><a class="reference" href="#onrightdown-display-popup-sendto-menu" id="id58" name="id58">OnRightDown (Display popup sendto menu)</a></li>
</ul>
</li>
<li><a class="reference" href="#move-combine-items-methods" id="id59" name="id59">Move/Combine items methods</a><ul>
<li><a class="reference" href="#oncombineitems" id="id60" name="id60">OnCombineItems</a></li>
<li><a class="reference" href="#onmovetolist" id="id61" name="id61">OnMoveToList</a></li>
<li><a class="reference" href="#onmovetospecificlist" id="id62" name="id62">OnMoveToSpecificList</a></li>
</ul>
</li>
<li><a class="reference" href="#change-update-items-methods" id="id63" name="id63">Change/update items methods</a><ul>
<li><a class="reference" href="#ontogglefinished" id="id64" name="id64">OnToggleFinished</a><ul>
<li><a class="reference" href="#draw-item" id="id65" name="id65">&lt;&lt; draw item &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#onpriority" id="id66" name="id66">OnPriority</a><ul>
<li><a class="reference" href="#id1" id="id67" name="id67">&lt;&lt; draw item &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#inplace-edit-methods" id="id68" name="id68">Inplace Edit Methods</a><ul>
<li><a class="reference" href="#ondisplayinplaceeditor" id="id69" name="id69">OnDisplayInPlaceEditor</a></li>
<li><a class="reference" href="#oncloseinplaceeditor" id="id70" name="id70">OnCloseInPlaceEditor</a></li>
</ul>
</li>
<li><a class="reference" href="#onduedate" id="id71" name="id71">OnDueDate</a></li>
<li><a class="reference" href="#oneditowner" id="id72" name="id72">OnEditOwner</a><ul>
<li><a class="reference" href="#common-owner-code" id="id73" name="id73">&lt;&lt; Common Owner Code &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#onupdate" id="id74" name="id74">OnUpdate</a><ul>
<li><a class="reference" href="#id2" id="id75" name="id75">&lt;&lt; Common Owner Code &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#onnewitem" id="id76" name="id76">OnNewItem</a><ul>
<li><a class="reference" href="#clear-data-fields" id="id77" name="id77">&lt;&lt; Clear data fields &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#conflict-not-in-use" id="id78" name="id78">Conflict (not in use)</a></li>
<li><a class="reference" href="#oneditnote" id="id79" name="id79">OnEditNote</a></li>
</ul>
</li>
<li><a class="reference" href="#file-menu-methods" id="id80" name="id80">File menu methods</a><ul>
<li><a class="reference" href="#onnewlist" id="id81" name="id81">OnNewList</a></li>
<li><a class="reference" href="#onfilelist" id="id82" name="id82">OnFileList</a></li>
<li><a class="reference" href="#onopenlist" id="id83" name="id83">OnOpenList</a></li>
<li><a class="reference" href="#ondeletelist" id="id84" name="id84">OnDeleteList</a></li>
<li><a class="reference" href="#oncloselist" id="id85" name="id85">OnCloseList</a></li>
<li><a class="reference" href="#oncloseall" id="id86" name="id86">OnCloseAll</a></li>
<li><a class="reference" href="#onsaveastext" id="id87" name="id87">OnSaveAsText</a></li>
<li><a class="reference" href="#onarchive" id="id88" name="id88">OnArchive</a></li>
<li><a class="reference" href="#onworkoffline" id="id89" name="id89">OnWorkOffline</a></li>
</ul>
</li>
<li><a class="reference" href="#display-methods" id="id90" name="id90">Display methods</a><ul>
<li><a class="reference" href="#onitemselected" id="id91" name="id91">OnItemSelected</a></li>
<li><a class="reference" href="#onitemactivated" id="id92" name="id92">OnItemActivated</a></li>
<li><a class="reference" href="#onshowall" id="id93" name="id93">OnShowAll</a></li>
<li><a class="reference" href="#onrefresh" id="id94" name="id94">OnRefresh</a></li>
<li><a class="reference" href="#onfilterowners" id="id95" name="id95">OnFilterOwners</a></li>
<li><a class="reference" href="#oncolumnclick-to-sort-columns" id="id96" name="id96">OnColumnClick (to sort columns)</a></li>
<li><a class="reference" href="#onshowfinished" id="id97" name="id97">OnShowFinished</a></li>
<li><a class="reference" href="#oncolumnrightclick-popup-to-change-date-displayed" id="id98" name="id98">OnColumnRightClick (popup to change date displayed)</a></li>
<li><a class="reference" href="#ondisplaydatecategory" id="id99" name="id99">OnDisplayDateCategory</a></li>
<li><a class="reference" href="#changedatedisplayed" id="id100" name="id100">ChangeDateDisplayed</a></li>
<li><a class="reference" href="#displaylist" id="id101" name="id101">DisplayList</a><ul>
<li><a class="reference" href="#id3" id="id102" name="id102">&lt;&lt; draw item &gt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#printing-methods" id="id103" name="id103">Printing methods</a><ul>
<li><a class="reference" href="#onpagesetup" id="id104" name="id104">OnPageSetup</a></li>
<li><a class="reference" href="#onprint" id="id105" name="id105">OnPrint</a></li>
</ul>
</li>
<li><a class="reference" href="#exiting-methods" id="id106" name="id106">Exiting methods</a><ul>
<li><a class="reference" href="#onwindowexit" id="id107" name="id107">OnWindowExit</a></li>
<li><a class="reference" href="#onexit" id="id108" name="id108">OnExit</a><ul>
<li><a class="reference" href="#save-configuration-file" id="id109" name="id109">&lt;&lt;save configuration file&gt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#find-methods" id="id110" name="id110">Find methods</a><ul>
<li><a class="reference" href="#onfind" id="id111" name="id111">OnFind</a></li>
<li><a class="reference" href="#findstring" id="id112" name="id112">FindString</a></li>
<li><a class="reference" href="#findnode" id="id113" name="id113">FindNode</a></li>
</ul>
</li>
<li><a class="reference" href="#database-related-methods" id="id114" name="id114">Database-related methods</a><ul>
<li><a class="reference" href="#getcursor" id="id115" name="id115">GetCursor</a></li>
<li><a class="reference" href="#getnote" id="id116" name="id116">GetNote</a></li>
<li><a class="reference" href="#createtable" id="id117" name="id117">CreateTable</a></li>
<li><a class="reference" href="#readfromdb-returns-db-results" id="id118" name="id118">ReadFromDB (returns db results)</a></li>
<li><a class="reference" href="#createanddisplaylist-returns-item-list" id="id119" name="id119">CreateAndDisplayList (returns Item List)</a><ul>
<li><a class="reference" href="#assign-item-attributes" id="id120" name="id120">&lt;&lt; assign item attributes &gt;&gt;</a></li>
<li><a class="reference" href="#id4" id="id121" name="id121">&lt;&lt; draw item &gt;&gt;</a></li>
</ul>
</li>
<li><a class="reference" href="#onsync" id="id122" name="id122">OnSync</a></li>
<li><a class="reference" href="#timestamper" id="id123" name="id123">TimeStamper</a></li>
</ul>
</li>
<li><a class="reference" href="#evaluate-methods" id="id124" name="id124">Evaluate methods</a><ul>
<li><a class="reference" href="#onshowevaluate" id="id125" name="id125">OnShowEvaluate</a></li>
<li><a class="reference" href="#onevaluate" id="id126" name="id126">OnEvaluate</a></li>
</ul>
</li>
<li><a class="reference" href="#help-menu-methods" id="id127" name="id127">Help menu methods</a><ul>
<li><a class="reference" href="#onshowabout" id="id128" name="id128">OnShowAbout</a></li>
<li><a class="reference" href="#onshowhelp" id="id129" name="id129">OnShowHelp</a></li>
</ul>
</li>
<li><a class="reference" href="#getuid" id="id130" name="id130">GetUID</a></li>
<li><a class="reference" href="#onidle" id="id131" name="id131">OnIdle</a><ul>
<li><a class="reference" href="#check-for-transfers-from-outlook" id="id132" name="id132">&lt;&lt; Check for Transfers From Outlook &gt;&gt;</a></li>
<li><a class="reference" href="#check-if-edited-file-has-changed" id="id133" name="id133">&lt;&lt; Check if Edited File has Changed &gt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#class-listctrl" id="id134" name="id134">class ListCtrl</a><ul>
<li><a class="reference" href="#init" id="id135" name="id135">__init__</a></li>
<li><a class="reference" href="#setupcolumns" id="id136" name="id136">SetUpColumns</a></li>
<li><a class="reference" href="#oncolbegindrag" id="id137" name="id137">OnColBeginDrag</a></li>
</ul>
</li>
<li><a class="reference" href="#class-myapp" id="id138" name="id138">class MyApp</a><ul>
<li><a class="reference" href="#oninit" id="id139" name="id139">OnInit</a></li>
</ul>
</li>
<li><a class="reference" href="#class-logger" id="id140" name="id140">class Logger</a></li>
<li><a class="reference" href="#run" id="id141" name="id141">run</a></li>
</ul>
</li>
<li><a class="reference" href="#lmdialogs-py" id="id142" name="id142">LMDialogs.py</a><ul>
<li><a class="reference" href="#class-popdialog" id="id143" name="id143">class PopDialog</a><ul>
<li><a class="reference" href="#id5" id="id144" name="id144">__init__</a></li>
<li><a class="reference" href="#onleftdown" id="id145" name="id145">OnLeftDown</a></li>
<li><a class="reference" href="#onforward" id="id146" name="id146">OnForward</a></li>
<li><a class="reference" href="#onmail" id="id147" name="id147">OnMail</a></li>
</ul>
</li>
<li><a class="reference" href="#class-startupdialog" id="id148" name="id148">class StartupDialog</a><ul>
<li><a class="reference" href="#id6" id="id149" name="id149">__init__</a></li>
<li><a class="reference" href="#onselection" id="id150" name="id150">OnSelection</a></li>
</ul>
</li>
<li><a class="reference" href="#class-modifierdialog" id="id151" name="id151">class ModifierDialog</a><ul>
<li><a class="reference" href="#id7" id="id152" name="id152">__init__</a></li>
<li><a class="reference" href="#getuserinput" id="id153" name="id153">GetUserInput</a></li>
<li><a class="reference" href="#selectcurrent" id="id154" name="id154">SelectCurrent</a></li>
<li><a class="reference" href="#clearselections" id="id155" name="id155">ClearSelections</a></li>
</ul>
</li>
<li><a class="reference" href="#class-maildialog" id="id156" name="id156">class MailDialog</a><ul>
<li><a class="reference" href="#id8" id="id157" name="id157">__init__</a></li>
</ul>
</li>
<li><a class="reference" href="#class-calendardialog" id="id158" name="id158">class CalendarDialog</a><ul>
<li><a class="reference" href="#id9" id="id159" name="id159">__init__</a></li>
<li><a class="reference" href="#oncalselected" id="id160" name="id160">OnCalSelected</a></li>
<li><a class="reference" href="#onchangemonth" id="id161" name="id161">OnChangeMonth</a></li>
<li><a class="reference" href="#onclosewindow" id="id162" name="id162">OnCloseWindow</a></li>
<li><a class="reference" href="#getdate" id="id163" name="id163">GetDate</a></li>
</ul>
</li>
<li><a class="reference" href="#class-finddialog" id="id164" name="id164">class FindDialog</a><ul>
<li><a class="reference" href="#id10" id="id165" name="id165">__init__</a></li>
</ul>
</li>
<li><a class="reference" href="#class-evaldialog" id="id166" name="id166">class EvalDialog</a><ul>
<li><a class="reference" href="#id11" id="id167" name="id167">__init__</a></li>
<li><a class="reference" href="#postokevent" id="id168" name="id168">PostOKEvent</a></li>
</ul>
</li>
<li><a class="reference" href="#class-loggerdialog" id="id169" name="id169">class LoggerDialog</a><ul>
<li><a class="reference" href="#id12" id="id170" name="id170">__init__</a></li>
<li><a class="reference" href="#onsave" id="id171" name="id171">OnSave</a></li>
</ul>
</li>
<li><a class="reference" href="#class-finisheddialog" id="id172" name="id172">class FinishedDialog</a><ul>
<li><a class="reference" href="#id13" id="id173" name="id173">__init__</a></li>
<li><a class="reference" href="#onspin" id="id174" name="id174">OnSpin</a></li>
<li><a class="reference" href="#oncheck" id="id175" name="id175">OnCheck</a></li>
</ul>
</li>
<li><a class="reference" href="#class-treedialog" id="id176" name="id176">class TreeDialog</a><ul>
<li><a class="reference" href="#id14" id="id177" name="id177">__init__</a></li>
<li><a class="reference" href="#onleftdclick" id="id178" name="id178">OnLeftDClick:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#outlookaddin-py" id="id179" name="id179">outlookAddin.py</a><ul>
<li><a class="reference" href="#outlookaddin-declarations" id="id180" name="id180">&lt;&lt; outlookAddin declarations &gt;&gt;</a></li>
<li><a class="reference" href="#class-buttonevent" id="id181" name="id181">class ButtonEvent</a><ul>
<li><a class="reference" href="#onclick" id="id182" name="id182">OnClick</a></li>
</ul>
</li>
<li><a class="reference" href="#class-folderevent" id="id183" name="id183">class FolderEvent</a><ul>
<li><a class="reference" href="#onitemadd" id="id184" name="id184">OnItemAdd</a></li>
</ul>
</li>
<li><a class="reference" href="#class-outlookaddin" id="id185" name="id185">class OutlookAddin</a><ul>
<li><a class="reference" href="#class-outlookaddin-declarations" id="id186" name="id186">&lt;&lt; class OutlookAddin declarations &gt;&gt;</a></li>
<li><a class="reference" href="#onconnection" id="id187" name="id187">OnConnection</a></li>
<li><a class="reference" href="#ondisconnection" id="id188" name="id188">OnDisconnection</a></li>
<li><a class="reference" href="#onaddinsupdate" id="id189" name="id189">OnAddInsUpdate</a></li>
<li><a class="reference" href="#onstartupcomplete" id="id190" name="id190">OnStartupComplete</a></li>
<li><a class="reference" href="#onbeginshutdown" id="id191" name="id191">OnBeginShutdown</a></li>
</ul>
</li>
<li><a class="reference" href="#registeraddin" id="id192" name="id192">RegisterAddin</a></li>
<li><a class="reference" href="#unregisteraddin" id="id193" name="id193">UnregisterAddin</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="wxlistmanager-py">
<h1><a class="toc-backref" href="#id15" name="wxlistmanager-py">wxListManager.py</a></h1>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
&#64;language python
&#64;color
&#64;others
</pre>
<div class="section" id="initial-stuff">
<h2><a class="toc-backref" href="#id16" name="initial-stuff">Initial stuff</a></h2>
<div class="section" id="module-imports">
<h3><a class="toc-backref" href="#id17" name="module-imports">Module Imports</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
from wxPython.wx import *
from wxPython.lib.mixins.listctrl import wxListCtrlAutoWidthMixin

import os
import time
import pickle
import socket
import select
import random
import ConfigParser
import threading
import re
import sys

from pywintypes import CreateGuid
from win32com.client import Dispatch
#import win32pdh
import win32api
#from win32com.client import constants #--&gt; just needed two constants...

import MySQLdb
import sqlite
import mx.DateTime

from LMDialogs import CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
#from wxTreeCtrl import TreeDialog

from printout import PrintTable
</pre>
<dl class="docutils">
<dt>os</dt>
<dd>uses <tt class="docutils literal"><span class="pre">os.getcwd</span></tt>, <tt class="docutils literal"><span class="pre">os.path.split</span></tt>, <tt class="docutils literal"><span class="pre">os.chdir</span></tt>, <tt class="docutils literal"><span class="pre">os.path.join</span></tt>, <tt class="docutils literal"><span class="pre">os.path.getmtime</span></tt>, <tt class="docutils literal"><span class="pre">os.startfile</span></tt>, <tt class="docutils literal"><span class="pre">os.environ</span></tt></dd>
<dt>time</dt>
<dd>uses <tt class="docutils literal"><span class="pre">time.sleep</span></tt>, <tt class="docutils literal"><span class="pre">time.asctime</span></tt></dd>
<dt>pickle</dt>
<dd>used to serialize data that is moved from Outlook to ListManager via sockets.</dd>
<dt>socket</dt>
<dd>as noted above, a socket is opened between Outlook and ListManager to move messages back and forth</dd>
<dt>select</dt>
<dd>ListManager selects on the socket to see if there is a message that has been queued by Outlook</dd>
<dt>random</dt>
<dd>used by the reminder popup to select messages</dd>
<dt>ConfigParser</dt>
<dd>not surprisingly, using ConfiParser to parse the ListManager.ini file.</dd>
<dt>threading</dt>
<dd>more for fun than absolute necessity, a thread is opened on starting the program that constructs the list of owners for items.  In theory, if the datasize and number of Lists were large enough it could delay the appearance of the GUI and its initial responsiveness if we didn't construct the ownerlist in a thread.  On the other hand, it really let me play with threads and with creating a custom event that signalled the construction of the owner list to the main thread by posting a custom event.</dd>
<dt>re</dt>
<dd>mainly using <tt class="docutils literal"><span class="pre">re.sub('[\\/:*&quot;&lt;&gt;|\?]','-',f)</span></tt> to make sure that files are constructed only with legal characters.  Also searching the body text of nodes using re because it allows case insensitive searches through <tt class="docutils literal"><span class="pre">re.compile(pat,</span> <span class="pre">re.I)</span></tt>.</dd>
<dt>pywintypes.CreateGuid</dt>
<dd>probably should use pure python GUID that is in ASPN cookbook but it was easiest to just use the Windows GUID function.  Thank you Mark Hammond for win32all.</dd>
<dt>win32com.client.Dispatch</dt>
<dd>used when launching Outlook to send email messages</dd>
<dt>win32api</dt>
<dd>using win32api.GetUserName() in case there is no user name in the ini file or no ini file</dd>
<dt>MySQLdb</dt>
<dd>using Andy Dustman's python extension module to connect to mysql back-end.</dd>
<dt>sqlite</dt>
<dd>using  D. Richard Hipp's python extension to connect to local sqlite databases</dd>
<dt>import mx.DateTime</dt>
<dd>using Marc-André Lemburg's mx.DateTime for dealing with datetime stuff in the databases</dd>
<dt>CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog</dt>
<dd>should just import LMDialogs and then access each dialog class by LM.WhateverDialog</dd>
<dt>printout.PrintTable</dt>
<dd>There was an existing wxPython print module for printing from tables that I have modified to print Lists.</dd>
<dt><em>#from win32com.client import constants</em></dt>
<dd>probably not wise but since the app only needs two constants from this module, just set the directly.  If MSFT decides to change the api, this is not good.</dd>
</dl>
</div>
<div class="section" id="constants">
<h3><a class="toc-backref" href="#id18" name="constants">Constants</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
cwd = os.getcwd()
DIRECTORY = os.path.split(cwd)[0]
os.chdir(DIRECTORY)
del cwd

#Outlook Constants
olMailItem = 0x0
olFlagMarked = 0x2

OFFLINE_ONLY = False #False-&gt; Online only  ; True-&gt; Online and Offline possible; REMOTE_HOST = None -&gt; Offline only

VERSION = '1.02'
</pre>
</div>
<div class="section" id="menu-ids">
<h3><a class="toc-backref" href="#id19" name="menu-ids">Menu IDs</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
#File Menu-----------------#
idNEWLIST = 1000
idOPENLIST = 1010
idCLOSELIST = 1015
idCLOSEALL = 1017
idSAVEAS = 1020
idDELETELIST = 1025
idPAGESETUP = 1030
idPRINT = 1035
idPRINTPREV = 1040
idMAILLIST = 1045
idOFFLINE = 1048
idEXIT = 1050

#Edit Menu-----------------
idCUT = 1055
idCOPY = 1060
idPASTE = 1065
idDELETEITEMS = 1070
idCOMBINEITEMS = 1075
idFIND = 1080

#Item Menu-------------------
idNEWITEM = 1085
idTOGGLEFINISHED = 1090
idEDITOWNER = 1095
idDUEDATE = 1100
idEDITNOTE = 1105
idMAILITEM =1110

#Diplay Menu---------------------
idSHOWFINISHED = 1115
idSHOWALL = 1120
idREFRESH = 1125
idDISPLAYDATE = 1130

#Tool Menu------------------------
idTICKLERACTIVE = 1135
idSHOWNEXT = 1140
idSYNC = 1145
idARCHIVE = 1150
idEVALUATE = 1155
idTOOLPRINT = 1165
idSENDTO = 1170

#Help Menu-------------------------
idABOUT = 1175
idHELP = 1180
</pre>
</div>
<div class="section" id="read-config-file">
<h3><a class="toc-backref" href="#id20" name="read-config-file">Read Config File</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
config_file = os.path.join(DIRECTORY, &quot;List Manager.ini&quot;)
defaults = dict(pw='python', db='listmanager', ext='txt', local='wxLMDB:sqlite', x='700', y='400')
cp = ConfigParser.ConfigParser(defaults=defaults)
cp.read(config_file) #ConfigParser closes the file

USER = cp.has_option('User','user') and cp.get('User','user') or win32api.GetUserName()

# the following all have default values provided in the constructor
PW = cp.get('User','pw')
DB = cp.get('Database','db')
NOTE_EXT = cp.get('Note','ext')
LOCAL_HOST = cp.get('Hosts','local')
X = cp.getint('Configuration','x')
Y = cp.getint('Configuration','y')

# the folloowing default to None
MAIL_LIST_PATH = cp.has_option('Mail','path') and cp.get('Mail','path') or None
QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None

# the following default to False
STARTUP_DIALOG = cp.has_option('User','startup_dialog') and cp.getboolean('User','startup_dialog')
DELETE_LIST = cp.has_option('User','delete_list') and cp.getboolean('User','delete_list')
OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail','outlook')

if cp.has_option('Hosts','remote'):
    REMOTE_HOST = cp.get('Hosts','remote')
else:
    REMOTE_HOST = None
    OFFLINE_ONLY = True

# reading it again because of the way defaults are handled
cp = ConfigParser.ConfigParser()
cp.read(config_file) #ConfigParser closes the file

if cp.has_section('Synchronization'):
    SYNC_TABLES = [t[1] for t in cp.items('Synchronization')]
else:
    SYNC_TABLES = ['follow_ups']
</pre>
<div class="sidebar">
<p class="first sidebar-title">A typical <em>List Manager.ini</em> file:</p>
<pre class="last literal-block">
[Files]
path0 = wxLMDB:sqlite:mine
path1 = nycpsszatzsql:mysql:follow_ups

[Database]
db = listmanager

[Note]
ext = txt

[Synchronization]
sync2 = follow_ups
sync1 = test

[Hosts]
remote = nycpsszatzsql:mysql
local = wxLMDB:sqlite

[User]
startup_dialog = true
user = szatz
pw = python

[Mail]
outlook = true
path = wxLMDB:sqlite:mail_transfer

[Configuration]
y = 642
x = 975
</pre>
</div>
<p>Application uses the <tt class="docutils literal"><span class="pre">ConfigParser</span></tt> module ito parse the ini file.  Unfortunately, <tt class="docutils literal"><span class="pre">ConfigParser</span></tt> doesn't work exactly like I think it should although it has been improved in 2.3.  My main issue is in the handling of default options.  The default options specified through the constructor show up in every section.  For example, if you use the items(<em>section</em>) method
then in addition to returning a list of tuples with whatever option/value pairs exist in the section, the list will include all the default option/value pairs, which does not make a whole lot of sense to me.  At the least, there should be a 'nodefaults' argument whose default was <em>False</em> but which could be set to <em>True</em>.  The following methods should have this option:</p>
<ul class="simple">
<li>items</li>
<li>options</li>
<li>has_option</li>
</ul>
<p>In any event, because a nodefaults option does not exist, I create the ConfigParser object twice -- once with default options and once without them.</p>
<p>The application will work fine if there is no ini file. In an effort to save some typing but not be too obscure, many of the options are read such that they default to the correct value either through explicit defaults in the constructor or statements that evaluate to <em>None</em> or <em>False</em>.</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">QUICK_LIST</span> <span class="pre">=</span> <span class="pre">cp.has_option('User','quicklist')</span> <span class="pre">and</span> <span class="pre">cp.get('User','quicklist')</span> <span class="pre">or</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">OUTLOOK</span> <span class="pre">=</span> <span class="pre">cp.has_option('Mail','outlook')</span> <span class="pre">and</span> <span class="pre">cp.getboolean('Mail,'outlook')</span></tt></p>
</blockquote>
</div>
</div>
<div class="section" id="class-listmanager">
<h2><a class="toc-backref" href="#id21" name="class-listmanager">class ListManager</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class ListManager(wxFrame):
    &#64;others
</pre>
<div class="section" id="instantiation">
<h3><a class="toc-backref" href="#id22" name="instantiation">Instantiation</a></h3>
<div class="section" id="def-init">
<h4><a class="toc-backref" href="#id23" name="def-init">def __init__</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, id, title, size):
    wxFrame.__init__(self, parent, id, title, size = size)

    self.SetIcon(wxIcon('bitmaps//wxpdemo.ico', wxBITMAP_TYPE_ICO))
    self.CreateStatusBar()

    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;
    &lt;&lt; Idle Timer &gt;&gt;

    ownerthread = threading.Thread(target=self.createownerlist)
    ownerthread.start()
    self.ModifierDialog = None
</pre>
<p>The ListManager <tt class="docutils literal"><span class="pre">__init__</span></tt> method is pretty straightforward.  The <tt class="docutils literal"><span class="pre">__init__</span></tt> arguments are the ones that need to be passed to <tt class="docutils literal"><span class="pre">wxFrame</span> <span class="pre">__init__</span></tt> method. The wxFrame class has the following form:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">wxFrame(parent,</span> <span class="pre">id,</span> <span class="pre">title,</span> <span class="pre">pos=wxDefaultPosition,</span> <span class="pre">size=wxDefaultSize,</span> <span class="pre">style=wxDEFAULT_FRAME_STYLE,</span> <span class="pre">name=&quot;frame&quot;)</span></tt></blockquote>
<p>The default style (<tt class="docutils literal"><span class="pre">wxDEFAULT_FRAME_STYLE</span></tt>) includes <tt class="docutils literal"><span class="pre">wxMINIMIZE_BOX</span></tt>, <tt class="docutils literal"><span class="pre">wxMAXIMIZE_BOX</span></tt>, <tt class="docutils literal"><span class="pre">wxRESIZE_BORDER</span></tt>, <tt class="docutils literal"><span class="pre">wxSYSTEM_MENU</span></tt>, <tt class="docutils literal"><span class="pre">wxCAPTION</span></tt> (the latter is the text that appears in the title bar).</p>
<p><tt class="docutils literal"><span class="pre">SetIcon</span></tt> is a method of <tt class="docutils literal"><span class="pre">wxFrame</span></tt> that sets the icon in the upper left of the title bar of the frame.  The wxIcon class has the following form:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">wxIcon(filename,</span> <span class="pre">type,</span> <span class="pre">desiredWidth=-1,</span> <span class="pre">desiredHeight=-1)</span></tt></blockquote>
<p><tt class="docutils literal"><span class="pre">CreateStatusBar</span></tt> is a method of <tt class="docutils literal"><span class="pre">wxFrame</span></tt>. The wxPython form is:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">CreateStatusBar(number=1,</span> <span class="pre">style=0,</span> <span class="pre">id=-1)</span></tt></blockquote>
<dl class="docutils">
<dt><em>number</em> --&gt;</dt>
<dd>number of fields to create. Specify a value greater than 1 to create a multi-field status bar.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">CreateStatusBar</span></tt> needs to be called before &lt;&lt; Load Recent Files &gt;&gt;.</p>
<p>The various sections of <tt class="docutils literal"><span class="pre">__init__</span></tt> are explained in their corresponding section:</p>
<pre class="literal-block">
&lt;&lt; ListManager Attributes &gt;&gt;
&lt;&lt; Menu Setup &gt;&gt;
&lt;&lt; Toolbar Setup &gt;&gt;
&lt;&lt; Menu/Toolbar Events &gt;&gt;
&lt;&lt; Create Controls&gt;&gt;
&lt;&lt; Layout Stuff &gt;&gt;
&lt;&lt; Other Events &gt;&gt;
&lt;&lt; GUI Instance Objects &gt;&gt;
&lt;&lt; Create Socket &gt;&gt;
&lt;&lt; Load Recent Files &gt;&gt;
</pre>
<div class="section" id="list-manager-attributes">
<h5><a class="toc-backref" href="#id24" name="list-manager-attributes">&lt;&lt; List Manager Attributes &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
self.PropertyDicts = []
self.ItemLists = []
self.ListCtrls = []
self.OwnerLBoxes = []

self.L = -1
self.curIdx = -1

self.printdata = wxPrintData()
self.printdata.SetPaperId(wxPAPER_LETTER)
self.printdata.SetOrientation(wxPORTRAIT)

#self._options = {} #would be used in loadconfig

self.copyitems = []    
self.modified = {}
self.tickler_active = False

#there is a wxPanel in the AddListControl method so each wxListCtrl has a different panel as parent
#there is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference

self.editor = []

self.Cursors = {}
self.sqlite_connections = []
self.popupvisible = False
self.in_place_editor = None
self.showrecentcompleted = 0

self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)

self.date_titles = {'createdate':&quot;Create Date&quot;,'duedate':&quot;Due Date&quot;,'timestamp':&quot;Last Modified&quot;,'finisheddate':&quot;Completion Date&quot;}
self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}

self.FindDialog = FindDialog(self, &quot;Find...&quot;, &quot;&quot;)
self.EvalDialog = EvalDialog(self, &quot;Evaluate...&quot;, &quot;&quot;)
</pre>
<dl class="docutils">
<dt>self.PropertyDicts</dt>
<dd>list of dictionaries that describe properties of each ListManager List (note that when referring to a collection of ListManager items a capital <em>L</em> List and table are used interchangeably).</dd>
<dt>self.ItemLists</dt>
<dd>list of lists that consist of instance objects of class <tt class="docutils literal"><span class="pre">Item</span></tt>.  Each of the lists contained in self.ItemLists correspond to the items that are being displayed in the ListCtrl.  So <tt class="docutils literal"><span class="pre">self.Itemlist[2]</span></tt> corresponds to the 2nd tab of the notebook and to the items in self.ListCtrls[2].</dd>
</dl>
<p>The class <tt class="docutils literal"><span class="pre">Item</span></tt> is just an empty class being used as a convenience to hold item attributes:</p>
<pre class="literal-block">
class Item:
    pass
</pre>
<p>The purpose of the class is just to create an object that can have various attributes as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr><td>item.id</td>
<td>GUID</td>
</tr>
<tr><td>item.name</td>
<td>string that describes the item</td>
</tr>
<tr><td>item.priority</td>
<td>integer ranging from 1 (high) to 3 (low)</td>
</tr>
<tr><td>item.owners</td>
<td>list of the form [&quot;Zatz, Steve&quot;, &quot;Hoffman, Steve&quot;]</td>
</tr>
<tr><td>item.note</td>
<td>string that provides additional info on item</td>
</tr>
<tr><td>item.timestamp</td>
<td>timestamp indicating when an item was last modified</td>
</tr>
<tr><td>item.duedate</td>
<td>default is None; mx.DateTime date</td>
</tr>
<tr><td>item.createdate</td>
<td>mx.DateTime.now() mx.DateTime timestamp</td>
</tr>
<tr><td>item.finisheddate</td>
<td>efaut is None; mx.DateTime date</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>self.ListCtrls</dt>
<dd>list of of instance objects of class ListCtrls, which are a subclass of wxPython class wxListCtrl.</dd>
<dt>self.OwnerLBoxes</dt>
<dd>list of of instance objects of wxPython class wxListBox, which is a simple one column List Control.</dd>
</dl>
<p>The wxPython constructor for a wxListBox is:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">wxListBox(parent,</span> <span class="pre">id,</span> <span class="pre">pos=wxDefaultPosition,</span> <span class="pre">size=wxDefaultSize,</span> <span class="pre">choices=[],</span> <span class="pre">style=0)</span></tt></blockquote>
<dl class="docutils">
<dt>self.L</dt>
<dd>index of the currently active notebook tab.  If there are any tabs in the notebook then one of them is always selected.  If there are no tabs then this is indicated by setting <tt class="docutils literal"><span class="pre">self.L</span> <span class="pre">=</span> <span class="pre">-1</span></tt>.</dd>
<dt>self.curIdx</dt>
<dd>currently selected row in the active <tt class="docutils literal"><span class="pre">ListCtrl</span></tt>.  There are times like after a row is deleted in which there may be rows visible but no row is selected.</dd>
</dl>
<p>The following lines set the default printer data:</p>
<pre class="literal-block">
self.printdata = wxPrintData()
self.printdata.SetPaperId(wxPAPER_LETTER)
self.printdata.SetOrientation(wxPORTRAIT)
</pre>
<p>The wxPython class <tt class="docutils literal"><span class="pre">wxPrintData</span></tt> holds a variety of information related to printers and printer device contexts. This class is used to create a wxPrinterDC and a wxPostScriptDC. It is also used as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the mechanism for transferring data between the print dialogs and the application.</p>
<dl class="docutils">
<dt>self.copyitems</dt>
<dd>list that contains item instance objects that have been copied from one list to be moved to another list.</dd>
<dt>self.modified</dt>
<dd><p class="first">dictionary that contains the information concerning whether any of several elements have been changed.  Chose a dictionary more to test the idea that I could create a simple method that would update the dictionary and here is an example:</p>
<p class="last"><tt class="docutils literal"><span class="pre">EVT_TEXT(self,</span> <span class="pre">self.name.GetId(),</span> <span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.modified.update({'name':1}))</span></tt></p>
</dd>
</dl>
<p>So this lambda function means that if an <tt class="docutils literal"><span class="pre">EVT_TEXT</span></tt> event occurs then update the dictionary by adding the key to the dictionary (the value is not used and arbitrarily set to 1).  The wxPython form for the macro <tt class="docutils literal"><span class="pre">EVT_TEXT</span></tt> is:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">EVT_TEXT(window,</span> <span class="pre">id,</span> <span class="pre">func)</span></tt></blockquote>
<p>A <tt class="docutils literal"><span class="pre">wxEVT_COMMAND_TEXT_UPDATED</span></tt> event is generated when the text in a <tt class="docutils literal"><span class="pre">wxTextCtrl</span></tt> changes and that is what <tt class="docutils literal"><span class="pre">EVT_TEXT</span></tt> catches. Note that this event will always be sent when the text control’s content changes - whether this is due to user input or comes programmatically (for example, if <tt class="docutils literal"><span class="pre">SetValue()</span></tt> is called)</p>
<dl class="docutils">
<dt>self.Cursors</dt>
<dd>dictionary that holds the database cursor objects.  For example, it will look like:  <tt class="docutils literal"><span class="pre">{'sqlite':&lt;sqlite</span> <span class="pre">cursor</span> <span class="pre">object&gt;,'nycpsltszatz':&lt;mysql</span> <span class="pre">cursor</span> <span class="pre">object&gt;}</span></tt></dd>
<dt>self.tickler_active</dt>
<dd>booean determines whether the tickler capabililty is active; can be shut off by unchecking Tickler menu item</dd>
<dt>self.editor</dt>
<dd><p class="first">list that holds the dictionaries that describe the notes that are edited by the external text editor:</p>
<pre class="last literal-block">
[
{
'table': 'mine',
'host': 'wxLMDB:sqlite',
'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\Journal Scan schedule.txt',
'id': '1AB34FB9-9EE6-4AFC-8AF0-FFCA50103BF3',
'time': 1070850894
}, 
{
'table': 'factoids',
'host': 'wxLMDB:sqlite',
'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\How many cme programs are sponsored- - 91%.txt', 
'id': '9CAC4D18-DE1C-4535-B9A5-4CDB1AD3F304', 
'time': 1070850908
}
]
</pre>
</dd>
</dl>
<p>The method that uses self.editor is <a class="reference" href="#check-if-edited-file-has-changed">&lt;&lt; Check if Edited File has Changed &gt;&gt;</a>.</p>
<p>There is a <tt class="docutils literal"><span class="pre">wxPanel</span></tt> in the <tt class="docutils literal"><span class="pre">AddListControl</span></tt> method so each <tt class="docutils literal"><span class="pre">wxListCtrl</span></tt> has a different panel as parent.</p>
<p>There is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference.</p>
<dl class="docutils">
<dt>self.sqlite_connections</dt>
<dd>Here because the sqlite connection has a weakreference that deletes it when you want it around</dd>
<dt>self.popupvisible</dt>
<dd>boolean that is used to ensure that two reminder popups aren't visible at the same time.</dd>
<dt>self.in_place_editor </dt>
<dd>boolean that indicates whether the inplace item name text editor is active or not.</dd>
<dt>self.showrecentcompleted</dt>
<dd>integer that determines the number of days in the past to retain completed items in the display.</dd>
<dt>self.LC_font</dt>
<dd>default font for all of the <tt class="docutils literal"><span class="pre">ListCtrls</span></tt>:  <tt class="docutils literal"><span class="pre">self.LC_font</span> <span class="pre">=</span> <span class="pre">wxFont(9,</span> <span class="pre">wxSWISS,</span> <span class="pre">wxNORMAL,</span> <span class="pre">wxNORMAL)</span></tt></dd>
</dl>
<p>The wxPython <tt class="docutils literal"><span class="pre">wxFont</span></tt> constructor is:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">wxFont(pointSize,</span> <span class="pre">family,</span> <span class="pre">style,</span> <span class="pre">weight,</span> <span class="pre">underline=False,</span> <span class="pre">faceName=&quot;&quot;,</span> <span class="pre">wencoding=wxFONTENCODING_DEFAULT)</span></tt></blockquote>
<dl class="docutils">
<dt>self.date_titles</dt>
<dd>dictionary that holds the various dates that are associated with each item and which can be displayed in the date column.  The dictionary is not modified.  We use one column of each <tt class="docutils literal"><span class="pre">ListCtrl</span></tt> to display any one of the four dates that that the application tracks. This dictionary associates the item attribute with the text that will be displayed in both the column header for the date and in the dropdown that allows you to change the date:  <tt class="docutils literal"><span class="pre">self.date_titles</span> <span class="pre">=</span> <span class="pre">{'createdate':&quot;Create</span> <span class="pre">Date&quot;,'duedate':&quot;Due</span> <span class="pre">Date&quot;,'timestamp':&quot;Last</span> <span class="pre">Modified&quot;,'finisheddate':&quot;Completion</span> <span class="pre">Date&quot;}</span></tt></dd>
<dt>self.attr2col_num</dt>
<dd>dictionary that associates the item attribute with the column that attribute is displayed in in the <tt class="docutils literal"><span class="pre">ListCtrl</span></tt>:  <tt class="docutils literal"><span class="pre">self.attr2col_num</span> <span class="pre">=</span> <span class="pre">{'priority':0,</span> <span class="pre">'name':1,'owners':2,</span> <span class="pre">'date':3}</span></tt></dd>
</dl>
<p>The following lines construct the Find Dialog and the Dialog that catches errors and shows expressions for debugging:</p>
<pre class="literal-block">
self.FindDialog = FindDialog(self, &quot;Find...&quot;, &quot;&quot;)
self.EvalDialog = EvalDialog(self, &quot;Evaluate...&quot;, &quot;&quot;)
</pre>
</div>
<div class="section" id="menu-setup">
<h5><a class="toc-backref" href="#id25" name="menu-setup">&lt;&lt; Menu Setup &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
filemenu = wxMenu()
filemenu.Append(idNEWLIST, &quot;New List...&quot;, &quot;Create a new List&quot;)
filemenu.Append(idOPENLIST, &quot;Open List...&quot;, &quot;Open a List&quot;)
filemenu.Append(idCLOSELIST, &quot;Close&quot;, &quot;Close the current List&quot;)
filemenu.Append(idCLOSEALL, &quot;Close All&quot;, &quot;Close all open Lists&quot;)
filemenu.Append(idSAVEAS, &quot;Save As Text File...&quot;, &quot;Save the current List&quot;)
filemenu.AppendSeparator()
filemenu.Append(idDELETELIST, &quot;Delete List...&quot;, &quot;Select a list to delete&quot;)
filemenu.AppendSeparator()
filemenu.Append(idPAGESETUP, &quot;Page Setup...&quot;)
filemenu.Append(idPRINT, &quot;Print...&quot;, &quot;Print the current view&quot;)
filemenu.Append(idPRINTPREV, &quot;Print Preview&quot;)
filemenu.AppendSeparator()
filemenu.Append(idMAILLIST, &quot;Mail...&quot;, &quot;Mail the current view&quot;)
filemenu.AppendSeparator()
filemenu.AppendCheckItem(idOFFLINE, &quot;Work Offline&quot;)
filemenu.AppendSeparator()
filemenu.Append(idEXIT, &quot;Exit&quot;, &quot;Exit the program&quot;)

editmenu = wxMenu()
editmenu.Append(idCUT, &quot;Cut\tCtrl+X&quot;)
editmenu.Append(idCOPY, &quot;Copy\tCtrl+C&quot;)
editmenu.Append(idPASTE, &quot;Paste\tCtrl+V&quot;)
editmenu.AppendSeparator()
editmenu.Append(idDELETEITEMS, &quot;Delete&quot;)
editmenu.AppendSeparator()
editmenu.Append(idCOMBINEITEMS, &quot;Combine Items...&quot;)
editmenu.AppendSeparator()
editmenu.Append(idFIND, &quot;Find...&quot;)

itemmenu = wxMenu()
itemmenu.Append(idNEWITEM, &quot;New Item&quot;)
itemmenu.AppendSeparator()
itemmenu.Append(idTOGGLEFINISHED, &quot;Toggle Finished&quot;)
itemmenu.Append(idEDITOWNER, &quot;Owner...&quot;)
itemmenu.Append(idDUEDATE, &quot;Due Date...&quot;)
itemmenu.Append(idEDITNOTE, &quot;Note...&quot;)
itemmenu.AppendSeparator()
itemmenu.Append(idMAILITEM, &quot;Mail...&quot;)

displaymenu = wxMenu()
displaymenu.Append(idSHOWFINISHED, &quot;Show/Hide Finished...&quot;)
displaymenu.AppendSeparator()
displaymenu.Append(idSHOWALL, &quot;Show All&quot;, &quot;Show all items in the current list&quot;)
displaymenu.AppendSeparator()
displaymenu.Append(idREFRESH, &quot;Refresh Display&quot;, &quot;Refresh the Display&quot;)
displaymenu.Append(idDISPLAYDATE, &quot;Select Date to Display&quot;)

toolmenu = wxMenu()
toolmenu.AppendCheckItem(idTICKLERACTIVE, &quot;Tickler Active&quot;)
toolmenu.Check(idTICKLERACTIVE,False)
toolmenu.Append(idSHOWNEXT, &quot;Show Next Reminder&quot;)
toolmenu.Append(idSYNC, &quot;Synchronize local and remote DBs&quot;)
toolmenu.Append(idARCHIVE, &quot;Archive completed items in list...&quot;)
toolmenu.Append(idEVALUATE, &quot;Evaluate an expression...&quot;)

helpmenu = wxMenu()
helpmenu.Append(idABOUT, &quot;About ListManager&quot;)
helpmenu.Append(idHELP, &quot;Help&quot;)

menubar = wxMenuBar()
menubar.Append(filemenu, '&amp;File')
menubar.Append(editmenu, 'Edit')
menubar.Append(itemmenu, 'Item')
menubar.Append(displaymenu, 'Display')
menubar.Append(toolmenu, 'Tools')
menubar.Append(helpmenu, 'Help')
self.SetMenuBar(menubar)
toolmenu.Enable(idSHOWNEXT,self.tickler_active)
filemenu.Enable(idDELETELIST,DELETE_LIST)
filemenu.Check(idOFFLINE,OFFLINE_ONLY)

#file history
self.filehistory = wxFileHistory()
self.filehistory.UseMenu(filemenu)
</pre>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<tbody valign="top">
<tr><td><strong>File Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;New List... &quot;</td>
<td><img alt="nl" src="images\newlist.gif" /> <tt class="docutils literal"><span class="pre">self.OnNewList</span></tt></td>
</tr>
<tr><td>&quot;Open List...&quot;</td>
<td><img alt="ol" src="images\openlist.gif" /> <tt class="docutils literal"><span class="pre">self.OnOpenList</span></tt></td>
</tr>
<tr><td>&quot;Close&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnCloseList</span></tt></td>
</tr>
<tr><td>&quot;Close All&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnCloseAll</span></tt></td>
</tr>
<tr><td>&quot;Save As Text File...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnSaveAsText</span></tt></td>
</tr>
<tr><td>&quot;Delete List...&quot;</td>
<td><img alt="de" src="images\delete.gif" /> <tt class="docutils literal"><span class="pre">self.OnDeleteList</span></tt></td>
</tr>
<tr><td>&quot;Page Setup...&quot;</td>
<td><img alt="ps" src="images\page_setup.gif" /> <tt class="docutils literal"><span class="pre">self.OnPageSetup</span></tt></td>
</tr>
<tr><td>&quot;Print...&quot;</td>
<td><img alt="pt" src="images\print.gif" /> <tt class="docutils literal"><span class="pre">self.OnPrint</span></tt></td>
</tr>
<tr><td>&quot;Print Preview&quot;</td>
<td><img alt="pp" src="images\printprev.gif" /> <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.OnPrint(e,</span> <span class="pre">prev=True)</span></tt></td>
</tr>
<tr><td>&quot;Mail...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnMailView</span></tt></td>
</tr>
<tr><td>&quot;Work Offline&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnWorkOffline</span></tt></td>
</tr>
<tr><td>&quot;Exit&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnExit</span></tt></td>
</tr>
<tr><td><strong>Edit Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;Cut&quot; [Ctrl+X ]</td>
<td><img alt="ec" src="images\editcut.gif" /> <tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.OnCopyItems(e,</span> <span class="pre">cut=True)</span></tt></td>
</tr>
<tr><td>&quot;Copy&quot; [Ctrl+C]</td>
<td><img alt="ey" src="images\editcopy.gif" /> <tt class="docutils literal"><span class="pre">self.OnCopyItems</span></tt></td>
</tr>
<tr><td>&quot;Paste&quot; [Ctrl+V]</td>
<td><img alt="ep" src="images\editpaste.gif" /> <tt class="docutils literal"><span class="pre">self.OnPasteItems</span></tt></td>
</tr>
<tr><td>&quot;Delete&quot;</td>
<td><img alt="de" src="images\delete.gif" /> <tt class="docutils literal"><span class="pre">self.OnDeleteItems</span></tt></td>
</tr>
<tr><td>&quot;Combine Items...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnCombineItems</span></tt></td>
</tr>
<tr><td>&quot;Find...&quot;</td>
<td><img alt="fi" src="images\find.gif" /> <tt class="docutils literal"><span class="pre">self.OnFind</span></tt></td>
</tr>
<tr><td><strong>Item Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;New Item&quot;</td>
<td><img alt="ni" src="images\new_item.gif" /> <tt class="docutils literal"><span class="pre">self.OnNewItem</span></tt></td>
</tr>
<tr><td>&quot;Toggle Finished&quot;</td>
<td><img alt="co" src="images\complete.gif" /> <tt class="docutils literal"><span class="pre">self.OnToggleFinished</span></tt></td>
</tr>
<tr><td>&quot;Owner...&quot;</td>
<td><img alt="ow" src="images\owners.gif" /> <tt class="docutils literal"><span class="pre">self.OnEditOwner</span></tt></td>
</tr>
<tr><td>&quot;Due Date...&quot;</td>
<td><img alt="dd" src="images\duedate.gif" /> <tt class="docutils literal"><span class="pre">self.OnDueDate</span></tt></td>
</tr>
<tr><td>&quot;Note...&quot;</td>
<td><img alt="en" src="images\edit_note.gif" /> <tt class="docutils literal"><span class="pre">self.OnEditNote</span></tt></td>
</tr>
<tr><td>&quot;Mail...&quot;</td>
<td><img alt="mi" src="images\mail_item.gif" /> <tt class="docutils literal"><span class="pre">self.OnMailItem</span></tt></td>
</tr>
<tr><td><strong>Display Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;Show/Hide Finished...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowFinished</span></tt></td>
</tr>
<tr><td>&quot;Show All&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowAll</span></tt></td>
</tr>
<tr><td>&quot;Refresh Display&quot;</td>
<td><img alt="re" src="images\refresh.gif" /> <tt class="docutils literal"><span class="pre">self.OnRefresh</span></tt></td>
</tr>
<tr><td>&quot;Select Date to Display&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnDisplayDateCategory</span></tt></td>
</tr>
<tr><td><strong>Tool Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;Tickler Active&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnActivateTickler</span></tt></td>
</tr>
<tr><td>&quot;Show Next Reminder&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowTickler</span></tt></td>
</tr>
<tr><td>&quot;Synchronize ...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnSync</span></tt></td>
</tr>
<tr><td>&quot;Archive completed...&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnArchive</span></tt></td>
</tr>
<tr><td>&quot;Evaluate expression&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowEvaluate</span></tt></td>
</tr>
<tr><td><strong>Help Menu</strong></td>
<td>&nbsp;</td>
</tr>
<tr><td>&quot;About ListManager&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowAbout</span></tt></td>
</tr>
<tr><td>&quot;Help&quot;</td>
<td><tt class="docutils literal"><span class="pre">self.OnShowHelp</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="toolbar-setup">
<h5><a class="toc-backref" href="#id26" name="toolbar-setup">&lt;&lt; Toolbar Setup &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
tb = self.CreateToolBar(wxTB_HORIZONTAL|wxTB_FLAT)

tb.AddLabelTool(idNEWLIST, &quot;New (local) List&quot;, wxBitmap('bitmaps\\new.bmp'), shortHelp=&quot;Create New List&quot;)
tb.AddLabelTool(idOPENLIST, &quot;Open&quot;, wxBitmap('bitmaps\\open.bmp'), shortHelp=&quot;Open List&quot;)
tb.AddSeparator()
tb.AddLabelTool(idTOOLPRINT, &quot;Print&quot;, wxBitmap('bitmaps\\print.bmp'), shortHelp=&quot;Print List&quot;)
tb.AddLabelTool(idPRINTPREV, &quot;Preview&quot;, wxBitmap('bitmaps\\preview.bmp'), shortHelp=&quot;Print Preview&quot;)
tb.AddLabelTool(idPAGESETUP, &quot;Setup&quot;, wxBitmap('bitmaps\\setup.bmp'), shortHelp=&quot;Page Setup&quot;)
tb.AddSeparator()
tb.AddLabelTool(idNEWITEM, &quot;New Item&quot;, wxBitmap('bitmaps\\new_item.bmp'), shortHelp=&quot;Create New Item&quot;)
tb.AddSeparator()
tb.AddLabelTool(idREFRESH, &quot;Refresh&quot;, wxBitmap('bitmaps\\refresh.bmp'), shortHelp=&quot;Refresh Display&quot;)     
tb.AddSeparator()
tb.AddLabelTool(idEDITNOTE, &quot;Edit Note&quot;, wxBitmap('bitmaps\\edit_doc.bmp'), shortHelp=&quot;Edit Note&quot;)
tb.AddSeparator()
tb.AddLabelTool(idFIND, &quot;Find&quot;, wxBitmap('bitmaps\\find.bmp'), shortHelp = &quot;Find Item&quot;)        
tb.AddSeparator()
tb.AddLabelTool(idCUT, &quot;Cut&quot;, wxBitmap('bitmaps\\editcut.bmp'), shortHelp =&quot;Cut Item&quot;)        
tb.AddLabelTool(idCOPY, &quot;Copy&quot;, wxBitmap('bitmaps\\copy.bmp'), shortHelp =&quot;Copy Item&quot;)
tb.AddLabelTool(idPASTE, &quot;Paste&quot;, wxBitmap('bitmaps\\paste.bmp'), shortHelp=&quot;Paste Item&quot;)
tb.AddSeparator()
tb.AddLabelTool(idTOGGLEFINISHED, &quot;Toggle Date&quot;, wxBitmap('bitmaps\\filledbox.bmp'), shortHelp=&quot;Toggle Finished Date&quot;)
tb.AddLabelTool(idDELETEITEMS, &quot;Delete&quot;, wxBitmap('bitmaps\\delete.bmp'), shortHelp=&quot;Delete Item&quot;)
tb.AddLabelTool(idDUEDATE, &quot;Due Date&quot;, wxBitmap('bitmaps\\calendar.bmp'), shortHelp=&quot;Enter Due Date&quot;)
tb.AddLabelTool(idEDITOWNER,&quot;Owner&quot;, wxBitmap('bitmaps\\owners.bmp'), shortHelp=&quot;Select Owner(s)&quot;)
tb.AddSeparator()
tb.AddLabelTool(idMAILITEM, &quot;Mail&quot;, wxBitmap('bitmaps\\mail.bmp'), shortHelp=&quot;Mail Item&quot;)

if QUICK_LIST:
    tb.AddSeparator()
    tb.AddLabelTool(idSENDTO, &quot;Send to&quot;, wxBitmap('bitmaps\\sendto.bmp'), shortHelp=&quot;Send to %s&quot;%QUICK_LIST)

tb.Realize()
</pre>
<img alt="images\toolbar.gif" src="images\toolbar.gif" />
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="30%" />
<col width="62%" />
</colgroup>
<tbody valign="top">
<tr><td><img alt="nl" src="images\newlist.gif" /></td>
<td>Creates a new List</td>
<td><tt class="docutils literal"><span class="pre">self.OnNewList</span></tt></td>
</tr>
<tr><td><img alt="ol" src="images\openlist.gif" /></td>
<td>Open an existing List</td>
<td><tt class="docutils literal"><span class="pre">self.OnOpenList</span></tt></td>
</tr>
<tr><td><img alt="pt" src="images\print.gif" /></td>
<td>Print</td>
<td><tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.OnPrint(e,showprtdlg=False))</span></tt></td>
</tr>
<tr><td><img alt="pp" src="images\printprev.gif" /></td>
<td>Print Preview</td>
<td><tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.OnPrint(e,</span> <span class="pre">prev=True))</span></tt></td>
</tr>
<tr><td><img alt="ps" src="images\page_setup.gif" /></td>
<td>Page Setup</td>
<td><tt class="docutils literal"><span class="pre">self.OnPageSetup</span></tt></td>
</tr>
<tr><td><img alt="ni" src="images\new_item.gif" /></td>
<td>New Item</td>
<td><tt class="docutils literal"><span class="pre">self.OnNewItem</span></tt></td>
</tr>
<tr><td><img alt="re" src="images\refresh.gif" /></td>
<td>Refresh</td>
<td><tt class="docutils literal"><span class="pre">self.OnRefresh</span></tt></td>
</tr>
<tr><td><img alt="en" src="images\edit_note.gif" /></td>
<td>Edit Note</td>
<td><tt class="docutils literal"><span class="pre">self.OnEditNote</span></tt></td>
</tr>
<tr><td><img alt="fi" src="images\find.gif" /></td>
<td>Find</td>
<td><tt class="docutils literal"><span class="pre">self.OnFind</span></tt></td>
</tr>
<tr><td><img alt="ec" src="images\editcut.gif" /></td>
<td>Cut</td>
<td><tt class="docutils literal"><span class="pre">lambda</span> <span class="pre">e:</span> <span class="pre">self.OnCopyItems(e,</span> <span class="pre">cut=True))</span></tt></td>
</tr>
<tr><td><img alt="ey" src="images\editcopy.gif" /></td>
<td>Copy</td>
<td><tt class="docutils literal"><span class="pre">self.OnCopyItems</span></tt></td>
</tr>
<tr><td><img alt="ep" src="images\editpaste.gif" /></td>
<td>Paste</td>
<td><tt class="docutils literal"><span class="pre">self.OnPasteItems</span></tt></td>
</tr>
<tr><td><img alt="co" src="images\complete.gif" /></td>
<td>Toggle Finished</td>
<td><tt class="docutils literal"><span class="pre">self.OnToggleFinished</span></tt></td>
</tr>
<tr><td><img alt="de" src="images\delete.gif" /></td>
<td>Delete Item</td>
<td><tt class="docutils literal"><span class="pre">self.OnDeleteItems</span></tt></td>
</tr>
<tr><td><img alt="dd" src="images\duedate.gif" /></td>
<td>Set Item Due Date</td>
<td><tt class="docutils literal"><span class="pre">self.OnDueDate</span></tt></td>
</tr>
<tr><td><img alt="ow" src="images\owners.gif" /></td>
<td>Set Item Owners</td>
<td><tt class="docutils literal"><span class="pre">self.OnEditOwner</span></tt></td>
</tr>
<tr><td><img alt="mi" src="images\mail_item.gif" /></td>
<td>Mail Item</td>
<td><tt class="docutils literal"><span class="pre">self.OnMailItem</span></tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="menu-toolbar-events">
<h5><a class="toc-backref" href="#id27" name="menu-toolbar-events">&lt;&lt; Menu/Toolbar Events &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
#File Menu ------------------------------------
EVT_MENU(self, idNEWLIST, self.OnNewList)
EVT_MENU(self, idOPENLIST, self.OnOpenList)
EVT_MENU(self, idCLOSELIST, self.OnCloseList)
EVT_MENU(self, idCLOSEALL, self.OnCloseAll)
EVT_MENU(self, idSAVEAS, self.OnSaveAsText)
EVT_MENU(self, idDELETELIST, self.OnDeleteList)
EVT_MENU(self, idPAGESETUP, self.OnPageSetup)
EVT_MENU(self, idPRINT, self.OnPrint)
EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))
EVT_MENU(self, idOFFLINE, self.OnWorkOffline)
EVT_MENU(self, idMAILLIST, self.OnMailView)      
EVT_MENU_RANGE(self, wxID_FILE1, wxID_FILE9, self.OnFileList)
EVT_MENU(self, idEXIT, self.OnExit)
#Edit Menu ------------------------------------
EVT_MENU(self, idCUT, lambda e: self.OnCopyItems(e, cut=True))        
EVT_MENU(self, idCOPY, self.OnCopyItems)
EVT_MENU(self, idPASTE, self.OnPasteItems)
EVT_MENU(self, idDELETEITEMS, self.OnDeleteItems)
EVT_MENU(self, idCOMBINEITEMS, self.OnCombineItems)
EVT_MENU(self, idFIND, self.OnFind)
#item Menu ------------------------------------
EVT_MENU(self, idNEWITEM, self.OnNewItem)
EVT_MENU(self, idTOGGLEFINISHED, self.OnToggleFinished)             
EVT_MENU(self, idDUEDATE, self.OnDueDate)
EVT_MENU(self, idEDITOWNER, self.OnEditOwner)
EVT_MENU(self, idEDITNOTE, self.OnEditNote)
EVT_MENU(self, idMAILITEM, self.OnMailItem)
#Dips Menu ------------------------------------
EVT_MENU(self, idSHOWFINISHED, self.OnShowFinished)
EVT_MENU(self, idSHOWALL, self.OnShowAll)
EVT_MENU(self, idREFRESH, self.OnRefresh)
EVT_MENU(self, idDISPLAYDATE, self.OnDisplayDateCategory)
#Tool Menu ---------------------------------------
EVT_MENU(self, idTICKLERACTIVE, self.OnActivateTickler)
EVT_MENU(self, idSHOWNEXT, self.OnShowTickler)
EVT_MENU(self, idSYNC, self.OnSync)
EVT_MENU(self, idARCHIVE, self.OnArchive)
EVT_MENU(self, idEVALUATE, self.OnShowEvaluate)
#Help Menu -----------------------------------------
EVT_MENU(self, idABOUT, self.OnShowAbout)
EVT_MENU(self, idHELP, self.OnShowHelp)

EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))

if QUICK_LIST:
    EVT_TOOL(self, idSENDTO, lambda e: self.OnMoveToSpecificList(e,QUICK_LIST))
</pre>
<p>(see toolbar table above)</p>
<p>Note about the use of lambda functions in <tt class="docutils literal"><span class="pre">EVT</span></tt> macros:</p>
<blockquote>
<p>When an event occurs, it sends an event object to the method that the event is connected to through the <tt class="docutils literal"><span class="pre">EVT</span></tt> macro.  If we want to have several <tt class="docutils literal"><span class="pre">EVT</span></tt> macros connect to the same method with different arguments then one way to accomplish that is to use a lambda function.  Instead of calling the a method directly with the event object as an argument, the lambda function will be called (with the event object argument) and the action of the lambda function will be to call the method in question with whatever additional arguments are specified.  For example:</p>
<pre class="literal-block">
EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))
</pre>
<p>The method <tt class="docutils literal"><span class="pre">OnPrint</span></tt> is the callback for both the Print event and the Print Preview event and by using a lambda function, we can pass an additional argument to the method (in this case setting the additional argument <em>prev</em> to True).</p>
</blockquote>
<p>Printing by clicking the print icon in the Toolbar <img alt="pt" src="images\print.gif" /> doesn't bring up a dialog it just prints to the default printer and that is why there is a separate <tt class="docutils literal"><span class="pre">EVT_TOOL</span></tt> macro with an <tt class="docutils literal"><span class="pre">idTOOLPRINT</span></tt> id:</p>
<pre class="literal-block">
EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))
</pre>
</div>
<div class="section" id="create-controls">
<h5><a class="toc-backref" href="#id28" name="create-controls">&lt;&lt; Create Controls&gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
upper_panel = wxPanel(self, -1)   #size = (900,400)
bottom_panel = wxPanel(self, -1, size = (900,150)) #900 note that 000 seems to work???

nb = wxNotebook(upper_panel, -1, size=(900,500), style=wxNB_BOTTOM)

f = wxFont(10, wxSWISS, wxNORMAL, wxNORMAL)
self.name = wxTextCtrl(bottom_panel, -1, size = (285,42), style = wxTE_MULTILINE|wxTE_RICH2)#34 #wxTE_PROCESS_ENTER
self.name.SetDefaultStyle(wxTextAttr(&quot;BLACK&quot;, font = f))

self.owners = wxTextCtrl(bottom_panel, -1, size = (250,42),style = wxTE_MULTILINE|wxTE_RICH2)
self.owners.SetDefaultStyle(wxTextAttr(&quot;BLACK&quot;, font = f))

self.note = wxTextCtrl(bottom_panel, -1, size = (400,50), style=wxTE_MULTILINE)
</pre>
<p>The <tt class="docutils literal"><span class="pre">wxFrame</span></tt> has two <tt class="docutils literal"><span class="pre">wxPanels</span></tt>:  <em>upper_panel</em> will contain the notebook.  The <em>bottom_panel</em> will contain the various item textctrls including name, owners and note.</p>
</div>
<div class="section" id="other-events">
<h5><a class="toc-backref" href="#id29" name="other-events">&lt;&lt; Other Events &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))
EVT_TEXT(self, self.note.GetId(), lambda e: self.modified.update({'note':1}))
EVT_TEXT(self, self.owners.GetId(), lambda e: self.modified.update({'owners':1}))

EVT_CLOSE(self, self.OnWindowExit)

EVT_IDLE(self, self.OnIdle)
</pre>
<p>The <tt class="docutils literal"><span class="pre">EVT_TEXT</span></tt> event macros indicate whether a particular textctrl has changed.</p>
<p><tt class="docutils literal"><span class="pre">EVT_CLOSE(self,</span> <span class="pre">self.OnWindowExit)</span></tt> is used to record settings and cleanup on exiting</p>
<p><tt class="docutils literal"><span class="pre">EVT_IDLE(self,</span> <span class="pre">self.OnIdle)</span></tt> --&gt; Idle events used for checking text files and transfers from Outlook</p>
<p>There are also a number of events related to the individual ListCtrls that are placed on Notebook pages <a class="reference" href="#listcontrol-events">&lt;&lt; ListControl Events &gt;&gt;</a>.</p>
</div>
<div class="section" id="layout-stuff">
<h5><a class="toc-backref" href="#id30" name="layout-stuff">&lt;&lt; Layout Stuff &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
#Appears necessary to really get the listcontrol to size with the overall window  
#upper_panel sizer
sizer = wxBoxSizer(wxHORIZONTAL)
sizer.Add(nb,1,wxALIGN_LEFT|wxEXPAND)
upper_panel.SetSizer(sizer)        

#sizer for the row of data items
box = wxBoxSizer(wxHORIZONTAL)
box.Add(self.name,1,wxEXPAND)
box.Add(self.owners,0)

#bottom_panel sizer  
sizer = wxBoxSizer(wxVERTICAL)        
sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
sizer.Add(self.note,1,wxALIGN_LEFT|wxEXPAND)
bottom_panel.SetSizer(sizer)

sizer = wxBoxSizer(wxVERTICAL)
sizer.Add(upper_panel,1,wxALIGN_TOP|wxEXPAND)
sizer.Add(bottom_panel,0,wxALIGN_TOP|wxEXPAND)

self.SetAutoLayout(1)
self.SetSizer(sizer)
#sizer.Fit(self) #actively does bad things to the dimensions on startup
</pre>
<!-- Not sure I have the strength but will discuss sizers here.  The basis use of sizers is pretty straightforward in my opinion, however, what is wildly hard to remember are the meaning of the parameters in the sizer Add method. -->
<p>The parent of the <tt class="docutils literal"><span class="pre">wxPanel</span></tt> object <em>upper_panel</em> is the <em>ListManager</em>, which is a subclass of <tt class="docutils literal"><span class="pre">wxFrame</span></tt>.  The parent of <tt class="docutils literal"><span class="pre">wxNotebook</span></tt> object <em>nb</em> is <em>upper_panel</em>.  Since the only child of <em>upper_panel</em> is the <em>nb</em> it wasn't obvious to me that a sizer was needed but apparently without it the <tt class="docutils literal"><span class="pre">wxListCtrl</span></tt> that will be a child of the wxPanel of <em>nb</em> won't size right if we don't do it this was.</p>
<pre class="literal-block">
Frame ---&gt; upper_panel ---&gt; notebook ---&gt; panel (for each page) ---&gt; listctrl
  |                                                             |            } one on each page
  ---&gt; lower_panel ---&gt; variety of textctrls                    ---&gt; listbox
</pre>
</div>
<div class="section" id="gui-instance-objects">
<h5><a class="toc-backref" href="#id31" name="gui-instance-objects">&lt;&lt; GUI Instance Objects &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
self.toolmenu = toolmenu
self.filemenu = filemenu
self.nb = nb
self.tb = tb
</pre>
<p>No comments yet.</p>
</div>
<div class="section" id="create-socket">
<h5><a class="toc-backref" href="#id32" name="create-socket">&lt;&lt; Create Socket &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
if OUTLOOK:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP socket
    s.bind(('localhost',8888)) # Bind to port 8888
    s.listen(5) # Listen, but allow no more than
    self.sock = s
</pre>
<p>No comment</p>
</div>
<div class="section" id="load-recent-files">
<h5><a class="toc-backref" href="#id33" name="load-recent-files">&lt;&lt; Load Recent Files &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
try:
    pathlist = [f[1] for f in cp.items('Files')]
except:
    pathlist = []

if pathlist:
    pathlist.sort()
    pathlist.reverse()
    for path in pathlist[1:]:
        self.OnFileList(path=path)

    #don't want to trigger the page change event until n-1 of n files are loaded
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)

    self.OnFileList(path=pathlist[0])
else:
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)
</pre>
<p><tt class="docutils literal"><span class="pre">pathlist</span> <span class="pre">=</span> <span class="pre">[f[1]</span> <span class="pre">for</span> <span class="pre">f</span> <span class="pre">in</span> <span class="pre">cp.items('Files')]</span></tt></p>
<p>This uses the new in 2.3 <tt class="docutils literal"><span class="pre">ConfigParser</span></tt> method <tt class="docutils literal"><span class="pre">items</span></tt>.  This will not work unless ConfigParser has been constructed without any defaults and so a ConfigParser object is created twice.</p>
<p>The only remotely subtle thing here is that we don't want to execute the <tt class="docutils literal"><span class="pre">EVT_NOTEBOOK_PAGE_CHANGED</span></tt> statement while we're doing the initial loading of files since it does unnecessary processing.  The statement is executed before the last file is loaded.</p>
</div>
<div class="section" id="idle-timer">
<h5><a class="toc-backref" href="#id34" name="idle-timer">&lt;&lt; Idle Timer &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
ID_TIMER = wxNewId()
self.timer = wxTimer(self, ID_TIMER) 
EVT_TIMER(self,  ID_TIMER, self.OnIdle)
self.timer.Start(3000)
</pre>
<p>Need to figure out exactly what this timer is doing.</p>
</div>
</div>
</div>
<div class="section" id="ownerlist-creation-methods-used-by-thread">
<h3><a class="toc-backref" href="#id35" name="ownerlist-creation-methods-used-by-thread">Ownerlist creation methods (used by thread)</a></h3>
<p>No comment.</p>
<div class="section" id="def-createownerlist">
<h4><a class="toc-backref" href="#id36" name="def-createownerlist">def createownerlist</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def createownerlist(self):

    if REMOTE_HOST and OFFLINE_ONLY is False:
        cursor = self.GetCursor(REMOTE_HOST)
        sql = &quot;SHOW TABLES&quot; #sorted
    else:
        cursor = self.GetCursor(LOCAL_HOST)
        sql = &quot;SELECT name FROM sqlite_master WHERE type='table' ORDER BY name&quot;

    cursor.execute(sql)
    results = cursor.fetchall()

    #excluding 'system' tables and archive tables
    excluded_tables = ['user_sync','sync','owners']
    tables = [t for (t,) in results if t.find('_archive')== -1 and t not in excluded_tables]

    sql_list = []
    for table in tables:
        sql_list.append(&quot;&quot;&quot;SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s&quot;&quot;&quot;%((table,)*3))

    sql = &quot; UNION &quot;.join(sql_list)
    cursor.execute(sql)
    results = cursor.fetchall()

    _list = [x[0] for x in results]
    if '' in _list:
        _list.remove('')
    if None in _list:
        _list.remove(None)

    self._list = _list

    #posting custom event to signal that this thread is done
    evt = wxPyEvent()
    evt_id = wxNewEventType()
    evt.SetEventType(evt_id)
    self.Connect(-1, -1, evt_id, self.createownerdialog)
    wxPostEvent(self, evt)
</pre>
<p>This method grabs the owners from many of the tables to create a list of possile owners for each item.  The alternative is actually to create a separate owner table but it seemed to make sense to just construct the owners on the fly from the various List databases.  This is done in a thread so no matter how long it takes to construct the owners it doesn't slow the appearance of the GUI.  The result of this method is the contruction of the instance variable <em>self._list</em>.</p>
<p>The most interesting thing here is creating a custom event (without needing to create an event macro) to signal that this thread is done:</p>
<pre class="literal-block">
evt = wxPyEvent()
evt_id = wxNewEventType()
evt.SetEventType(evt_id)
self.Connect(-1, -1, evt_id, self.createownerdialog)
wxPostEvent(self, evt)
</pre>
<p>The code above is adapted from the more general <tt class="docutils literal"><span class="pre">wxCallAfter</span></tt>, which I could have used but just wanted to explicitly show the steps involved in creating a custom event, associating it with a callback and posting it.</p>
<p>The general point is that if you want to notify the main GUI thread of something going on in a non-GUI thread, posting events is an easy way to do it whether you use the code above, the more complete wxCallAfter (see below) from which it was derived or actually create your own custom event macro (farther below).</p>
<p>The code for <tt class="docutils literal"><span class="pre">wxCallAfter</span></tt> is:</p>
<pre class="literal-block">
def wxCallAfter(callable, *args, **kw):
     &quot;&quot;&quot;
     Call the specified function after the current and pending event
     handlers have been completed.  This is also good for making GUI
     method calls from non-GUI threads.
     &quot;&quot;&quot;
     app = wxGetApp()
     assert app, 'No wxApp created yet'

     global _wxCallAfterId
     if _wxCallAfterId is None:
         _wxCallAfterId = wxNewEventType()
         app.Connect(-1, -1, _wxCallAfterId,
               lambda event: event.callable(*event.args, **event.kw) )
     evt = wxPyEvent()
     evt.SetEventType(_wxCallAfterId)
     evt.callable = callable
     evt.args = args
     evt.kw = kw
     wxPostEvent(app, evt)
</pre>
<p>Unless you want multiple handlers to be able to respond to a custom event (by using evt.Skip()) or just want custom event macros that are like native event macros there doesn't seem to be much need to create full-blown custom events.  If you do need to, here is how it is done:</p>
<pre class="literal-block">
wxEVT_THREAD_DONE = wxNewEventType()

def EVT_THREAD_DONE(win, func):
    win.Connect(-1, -1, wxEVT_THREAD_DONE, func)
    
class ThreadDoneEvent(wxPyEvent):
    def __init__(self):
        wxPyEvent.__init__(self)
        self.SetEventType(wxEVT_THREAD_DONE)
</pre>
<p>When you want to post the custom event, you do the following:</p>
<pre class="literal-block">
evt = ThreadDoneEvent() 
wxPostEvent(win, evt)
</pre>
</div>
<div class="section" id="def-createownerdialog">
<h4><a class="toc-backref" href="#id37" name="def-createownerdialog">def createownerdialog</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def createownerdialog(self, evt=None):
    self.ModifierDialog = ModifierDialog(parent=self, title=&quot;Select owner(s)&quot;, size=(180,300), style=wxCAPTION, modifierlist = self._list)
    del self._list
</pre>
<p>When the thread is done that creates the owner list it posts an event whose callback is this method.  This method uses <em>self._list</em> that was generated by the <tt class="docutils literal"><span class="pre">createownerlist</span></tt> method.  As an alternative, we could probably pass the list as an attribute of the event that is generated in the thread.</p>
</div>
</div>
<div class="section" id="notebook-methods">
<h3><a class="toc-backref" href="#id38" name="notebook-methods">Notebook methods</a></h3>
<p>The main method here is the one that constructs a new Notebook page by creating a new ListCtrl and new OwnerListBox and populating them.  The second method does what is needed when an existing notebook page is selected.</p>
<div class="section" id="def-createnewnotebookpage">
<h4><a class="toc-backref" href="#id39" name="def-createnewnotebookpage">def CreateNewNotebookPage</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def CreateNewNotebookPage(self, host, table):

    Properties = {'owner':'*ALL',
                'LCdate':'duedate',
                'sort':{'attribute':'priority','direction':0}, #these could be set in Config
                'showfinished':0} #-1 show them all; 0 show none; integer show for that many days

    Properties['table'] = table
    Properties['host'] = host

    self.PropertyDicts.append(Properties)

    self.L = len(self.ItemLists)#could use self.ListCtrls, self.OwnerLBoxes, etc. with a -1

    results = self.ReadFromDB()
    if results is None:
        self.PropertyDicts = self.PropertyDicts[:-1]
        self.L = self.L - 1
        return

    panel = wxPanel(self.nb, -1, size = (900,400))
    LCtrl = ListCtrl(panel, -1, style=wxLC_REPORT|wxSUNKEN_BORDER|wxLC_VRULES|wxLC_HRULES)
    LCtrl.SetFont(self.LC_font)
    self.ListCtrls.append(LCtrl)

    OLBox = wxListBox(panel, -1, size = (126,550), choices = [&quot;&quot;], style=wxLB_SORT|wxSUNKEN_BORDER)
    self.OwnerLBoxes.append(OLBox)

    sizer = wxBoxSizer(wxHORIZONTAL)
    sizer.Add(OLBox,0,wxALIGN_LEFT|wxEXPAND)
    sizer.Add(LCtrl,1,wxALIGN_LEFT|wxEXPAND)
    panel.SetSizer(sizer)

    self.ItemLists.append(self.CreateAndDisplayList(results)) 

    &lt;&lt; Fill OwnerListBox &gt;&gt;
    &lt;&lt; ListControl Events &gt;&gt;

    #img_num = LCtrl.arrows[Properties['sort']['direction']]
    #LCtrl.SetColumnImage(self.attr2col_num[Properties['sort']['attribute']], img_num)

    rdbms = host.split(':')[1]
    if rdbms == 'mysql':
        tab_title = '%s (remote)'%table
    else:
        tab_title = table

    if table in SYNC_TABLES:
        tab_title = '*'+tab_title

    self.nb.AddPage(panel,tab_title)
    self.nb.SetSelection(self.L)

    self.filehistory.AddFileToHistory('%s:%s'%(host,table))

    self.SetStatusText(&quot;Successfully loaded %s&quot;%tab_title)
</pre>
<p>This method creates the ListCtrl and ListBox that appears on every notebook page.</p>
<p>Each list has a properties dictionary associated with it.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr><td>'owner'</td>
<td>The owner that is filtering the display or '*ALL'</td>
</tr>
<tr><td>'LCdate'</td>
<td>Date that is displayed by the ListCtrl; values: 'duedate', 'createdate', 'timestamp', 'finisheddate'</td>
</tr>
<tr><td>'sort'</td>
<td>Value is a dictionary of the form {'attribute':'priority','direction':0}</td>
</tr>
<tr><td>'showfinished'</td>
<td>Values: -1 show them all; 0 show none; integer show for that many days</td>
</tr>
<tr><td>'table'</td>
<td>The table that holds the List</td>
</tr>
<tr><td>'host'</td>
<td>The form for this is 'nycpsszatzsql:mysql' or 'wxLMDB:sqlite'</td>
</tr>
</tbody>
</table>
<div class="section" id="fill-ownerlistbox">
<h5><a class="toc-backref" href="#id40" name="fill-ownerlistbox">&lt;&lt; Fill OwnerListBox &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
cursor = self.GetCursor(host)
if cursor is None:
    print &quot;Couldn't get cursor to fill OwnerListBox&quot;
    return

cursor.execute(&quot;SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s&quot;%((table,)*3))

owners = [x for (x,) in cursor.fetchall()]

if None in owners:
    owners.remove(None)
if '' in owners:
    owners.remove('')

OLBox.Clear()
for name in owners: 
    OLBox.Append(name)
OLBox.Append('*ALL')
OLBox.SetSelection(0)
</pre>
<p>The list is sorted by the ListBox control.</p>
<p>mysql doesn't like '%s' while sqlite is fine with '%s' for table names.</p>
<p>If you don't do <tt class="docutils literal"><span class="pre">OLBox.Clear()</span></tt> then you get a blank line in the list that must be from initiating it with &quot;&quot;.</p>
<p>Relying on the fact that '*All' should be first alphabetically, which is dumb so should change it.</p>
</div>
<div class="section" id="listcontrol-events">
<h5><a class="toc-backref" href="#id41" name="listcontrol-events">&lt;&lt; ListControl Events &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
LCId = LCtrl.GetId()
EVT_LIST_ITEM_SELECTED(self, LCId, self.OnItemSelected)
EVT_LIST_ITEM_ACTIVATED(self, LCId, self.OnDisplayInPlaceEditor)
EVT_LEFT_DOWN(LCtrl, self.OnLeftDown) 
EVT_LEFT_DCLICK(LCtrl, self.OnLeftDown)
EVT_RIGHT_DOWN(LCtrl, self.OnRightDown)
EVT_LIST_COL_CLICK(self, LCId, self.OnColumnClick)
EVT_LIST_COL_RIGHT_CLICK(self, LCId, self.OnColumnRightClick)

# the following is a ListBox event
EVT_LISTBOX(self, OLBox.GetId(), self.OnFilterOwners)
</pre>
<p>It would seem that the two mouse events:  <tt class="docutils literal"><span class="pre">EVT_LEFT_DOWN(LCtrl,</span> <span class="pre">self.OnLeftDown)</span></tt> and <tt class="docutils literal"><span class="pre">EVT_LEFT_DCLICK(LCtrl,</span> <span class="pre">self.OnLeftDown)</span></tt> could be owned by the ListManager object and not each ListCtrl object, but when I tried this, the mouse events were not detected. I did not investigate this for long so maybe I was just screwing things up or perhaps a <tt class="docutils literal"><span class="pre">wxFrame</span></tt> cannot detect a mousedown event (does that make sense?).  In any event (no pun intended), it is certainly not a big deal to create these mousedown events for each ListCtrl.</p>
<p>Each ListBox object has one event associated with it that occurs, not surprisingly, when a name in the control is selected.  The callback, <em>self.OnFilterOwners</em>, causes the ListCtrl to display only the items of the selected owner.</p>
</div>
</div>
<div class="section" id="def-onpagechange">
<h4><a class="toc-backref" href="#id42" name="def-onpagechange">def OnPageChange</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnPageChange(self, evt=None):
    if self.modified:
        self.OnUpdate()

    self.L = L = self.nb.GetSelection()

    &lt;&lt; Find Highlighted Row &gt;&gt;
    &lt;&lt; Update Title &gt;&gt;

    evt.Skip() #051403
</pre>
<p>Call-back for the <tt class="docutils literal"><span class="pre">EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)</span></tt> event.</p>
<p>self.modified is the dictionary that indicates which textctrls have data that has changed.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Not sure whether event.Skip() is needed or not.</p>
</div>
<div class="section" id="find-highlighted-row">
<h5><a class="toc-backref" href="#id43" name="find-highlighted-row">&lt;&lt; Find Highlighted Row &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
idx = self.ListCtrls[L].GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
if idx != -1:
    self.curIdx = idx
    #LCtrl.EnsureVisible(idx)
    self.OnItemSelected()
elif self.ItemLists[L]:
    self.curIdx = 0
    self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    #the line above triggers an OnItemSelected EVT so don't need self.OnItemSelected() 092803
else:
    self.curIdx = -1
</pre>
</div>
<div class="section" id="update-title">
<h5><a class="toc-backref" href="#id44" name="update-title">&lt;&lt; Update Title &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
location,rdbms = self.PropertyDicts[L]['host'].split(':')
table = self.PropertyDicts[L]['table']
self.SetTitle(&quot;List Manager:  %s:  %s:  %s&quot;%(location,rdbms,table))
</pre>
</div>
</div>
</div>
<div class="section" id="tickler-methods">
<h3><a class="toc-backref" href="#id45" name="tickler-methods">Tickler methods</a></h3>
<div class="section" id="def-onshowtickler">
<h4><a class="toc-backref" href="#id46" name="def-onshowtickler">def OnShowTickler</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowTickler(self, evt=None):
    if self.popupvisible:
        return

    self.popupvisible = True

    host = 'wxLMDB:sqlite'
    cursor = self.Cursors[host]
    table = 'follow_ups'

    sql = &quot;SELECT COUNT() FROM &quot;+table+&quot; WHERE finisheddate IS NULL AND priority &gt; 1&quot;
    cursor.execute(sql)
    results = cursor.fetchone()

    num_items = int(results[0])

    if not num_items:
        return

    if self.modified: #Should decide if this should be put back or not
        self.OnUpdate()

    n = random.randint(0,num_items-1)

    sql = &quot;SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM &quot;+table+&quot; WHERE finisheddate IS NULL AND priority &gt; 1 LIMIT 1 OFFSET %d&quot;%n

    try:
        cursor.execute(sql)
    except:
        print &quot;In OnShowTickler and attempt to Select an item failed&quot;
        return

    row = cursor.fetchone()

    class Item: pass
    item = Item()

    item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
    item.name = row[1]
    item.createdate = row[2]
    item.finisheddate = row[3]
    item.duedate = row[4]
    item.owners = [z for z in row[5:7] if z is not None] #if you carry around ['tom',None,None] you have an issue when you go write it
    item.id = row[8]
    item.timestamp = row[9]
    item.note = row[10]

    dlg = TicklerDialog(self, &quot;&quot;, &quot;Do something about this!!!&quot;, size=(550,350))
    TC = dlg.TC

    f = wxFont(14, wxSWISS, wxITALIC, wxBOLD, False)
    TC.SetDefaultStyle(wxTextAttr(&quot;BLUE&quot;,wxNullColour, f))
    TC.AppendText(&quot;%s...&quot;%item.name)

    if item.priority == 3:
        TC.SetDefaultStyle(wxTextAttr(&quot;RED&quot;,&quot;YELLOW&quot;,f))
    TC.AppendText(&quot;%d\n\n&quot;%item.priority)

    f = wxFont(8, wxSWISS, wxNORMAL, wxNORMAL)
    TC.SetDefaultStyle(wxTextAttr(&quot;BLACK&quot;,&quot;WHITE&quot;, f))
    TC.AppendText(&quot;owners: %s\n&quot;%&quot;, &quot;.join(item.owners))
    TC.AppendText(&quot;created on: %s\n&quot;%item.createdate.Format('%m/%d/%y'))
    if item.duedate:
        ddate = item.duedate.Format('%m/%d/%y')
    else:
        ddate = &quot;&lt;no due date&gt;&quot;
    TC.AppendText(&quot;due on: %s\n\n&quot;%ddate)

    note = item.note
    if not note:
        note = &quot;&lt;no note&gt;&quot;
    TC.AppendText(&quot;%s\n\n&quot;%note)
    f = wxFont(10, wxSWISS, wxITALIC, wxBOLD)
    TC.SetDefaultStyle(wxTextAttr(&quot;BLACK&quot;,wxNullColour, f))
    TC.AppendText('follow_ups')
    TC.ShowPosition(0)   #did not do anything
    TC.SetInsertionPoint(0)
    result = dlg.ShowModal()
    dlg.Destroy()
    self.popupvisible = False     

    if result in (wxID_OK, wxID_APPLY):

        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table:
                break
        else:
            print &quot;Can't find %s&quot;%table
            return

        self.nb.SetSelection(L) #if the page changes it sends a EVT_NOTEBOOK_PAGE_CHANGED, which calls OnPageChange
        self.L = L
        self.FindNode(item)
        if result==wxID_APPLY:
            self.OnMailItem(item)

    elif result==wxID_FORWARD:
        self.OnShowTickler()
</pre>
</div>
<div class="section" id="def-onactivatetickler">
<h4><a class="toc-backref" href="#id47" name="def-onactivatetickler">def OnActivateTickler</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnActivateTickler(self, evt):
    self.tickler_active = not self.tickler_active
    self.toolmenu.Enable(idSHOWNEXT,self.tickler_active)
</pre>
</div>
</div>
<div class="section" id="email-methods">
<h3><a class="toc-backref" href="#id48" name="email-methods">Email methods</a></h3>
<div class="section" id="onmailitem">
<h4><a class="toc-backref" href="#id49" name="onmailitem">OnMailItem</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnMailItem(self, evt=None, item=None):
    if item is None:
        if self.curIdx == -1:
            return
        else:
            item = self.ItemLists[self.L][self.curIdx]

    dlg = MailDialog(self,&quot;Mail a reminder&quot;, size=(450,500),
               recipients=item.owners,    
               subject=item.name,
               body=self.GetNote())          
    result = dlg.ShowModal()
    if result==wxID_OK:
        outlook= Dispatch(&quot;Outlook.Application&quot;)
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = to = dlg.RTC.GetValue()
        newMsg.Subject = subject = dlg.STC.GetValue()
        newMsg.Body = body = dlg.BTC.GetValue()

        #newMsg.FlagStatus = constants.olFlagMarked

        newMsg.Display()

        dlg.Destroy()            
        #del outlook

        self.note.SetSelection(0,0)
        self.note.WriteText(&quot;**************************************************\n&quot;)
        self.note.WriteText(&quot;Email sent on %s\n&quot;%mx.DateTime.today().Format(&quot;%m/%d/%y&quot;))
        self.note.WriteText(&quot;To: %s\n&quot;%to)
        self.note.WriteText(&quot;Subject: %s\n&quot;%subject)
        self.note.WriteText(&quot;%s\n&quot;%body)
        self.note.WriteText(&quot;**************************************************\n&quot;)
</pre>
</div>
<div class="section" id="onmailview">
<h4><a class="toc-backref" href="#id50" name="onmailview">OnMailView</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnMailView(self, evt=None):
    recipients = [self.PropertyDicts[self.L]['owner']]

    body = &quot;&quot;
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+&quot;%d. %s (%d)\n&quot;%(i+1, item.name, item.priority)

    subject = &quot;Follow-ups &quot; + mx.DateTime.today().Format(&quot;%m/%d/%y&quot;)

    dlg = MailDialog(self,&quot;Follow-up List&quot;, size=(450,500),
               recipients=recipients,
               subject=subject,
               body=body)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val==wxID_OK:
        outlook= Dispatch(&quot;Outlook.Application&quot;)
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = dlg.RTC.GetValue()
        newMsg.Subject = dlg.STC.GetValue()
        newMsg.Body = dlg.BTC.GetValue()

        newMsg.FlagStatus = olFlagMarked #constants.olFlagMarked
        newMsg.Categories = &quot;Follow-up&quot;

        newMsg.Display()

        #del outlook
</pre>
</div>
</div>
<div class="section" id="cut-copy-paste-methods">
<h3><a class="toc-backref" href="#id51" name="cut-copy-paste-methods">Cut/Copy/Paste methods</a></h3>
<div class="section" id="oncopyitems">
<h4><a class="toc-backref" href="#id52" name="oncopyitems">OnCopyItems</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCopyItems(self, event=None, cut=False):
    if self.curIdx == -1:
        return

    L = self.L
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]

    &lt;&lt; Find Highlighted Items &gt;&gt;

    self.SetStatusText(&quot;%d items copied&quot;%len(copyitems))
    if cut:
        self.OnDeleteItems()
</pre>
<div class="section" id="find-highlighted-items">
<h5><a class="toc-backref" href="#id53" name="find-highlighted-items">&lt;&lt; Find Highlighted Items &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
copyitems = []
i = -1
while 1:
    i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
    if i==-1:
        break
    item = IList[i]
    item.notes = self.GetNote(L,item) #handles the database situation
    copyitems.append(item)

self.copyitems = copyitems
</pre>
</div>
</div>
<div class="section" id="onpasteitems">
<h4><a class="toc-backref" href="#id54" name="onpasteitems">OnPasteItems</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnPasteItems(self, evt=None, L=None): #noselect 051603
    #used by OnMoveToList, OnMoveToSpecificList and called directly
    if not self.copyitems:
        print &quot;Nothing was selected to be copied&quot;
        return

    if L is None: #this is not needed by OnMoveTo or OnDragToTab but is for a straight call
        L = self.L

    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]

    items = self.copyitems
    numitems = len(items)

    for item in items:

        z = item.owners+[None,None,None]

        id = self.GetUID() #we do give it a new id
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        createdate = mx.DateTime.now() #need this or else it won't be seen as a new item when synching; would be seen as updated
        command = &quot;INSERT INTO &quot;+table+&quot; (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;
        cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))

        timestamp = self.TimeStamper(host, cursor, table, id)

        #creating a new item breaks the connection between item.x and new_item.x
        class Item: pass
        new_item = Item()
        new_item.id = id
        new_item.priority = item.priority
        new_item.owners = item.owners
        new_item.name = item.name
        new_item.timestamp = timestamp
        new_item.duedate =item.duedate
        new_item.finisheddate = item.finisheddate
        new_item.createdate = createdate
        IList.insert(0,new_item)

    self.DisplayList(IList,L)

    #If we didn't come from OnMoveToList or OnMoveToSpecificList where L != self.L
    if L==self.L:
        for i in range(numitems):
            LCtrl.SetItemState(i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = numitems-1
</pre>
</div>
<div class="section" id="ondeleteitems">
<h4><a class="toc-backref" href="#id55" name="ondeleteitems">OnDeleteItems</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDeleteItems(self, event=None):
    &quot;&quot;&quot;Called directly and by OnCopyItems (cut = true)
    &quot;&quot;&quot;
    if self.curIdx == -1: #not absolutely necessary but gets you out quickly
        return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]

    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        item = IList.pop(i)
        LCtrl.DeleteItem(i)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute(&quot;DELETE from &quot;+table+&quot; WHERE id = %s&quot;, (item.id,))

        #Track Deletes for Syncing ############################################
        if table in SYNC_TABLES:
            if host.split(':')[1] == 'sqlite':
                timestamp = mx.DateTime.now()
                cursor.execute(&quot;INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)&quot;,(item.id,'d',table,item.name,timestamp))
            else:
                cursor.execute(&quot;INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)&quot;,(item.id,'d',table,USER,item.name))
        #########################################################################
        i-=1

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does cause self.modified --&gt;{'name':1}
    self.modified = {}
    self.curIdx = -1
</pre>
</div>
</div>
<div class="section" id="mousedown-methods">
<h3><a class="toc-backref" href="#id56" name="mousedown-methods">MouseDown methods</a></h3>
<div class="section" id="onleftdown-action-depends-on-x-coordinate">
<h4><a class="toc-backref" href="#id57" name="onleftdown-action-depends-on-x-coordinate">OnLeftDown (Action depends on x coordinate)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnLeftDown(self, evt):
    print &quot;Here&quot;
    if self.modified:
        #if inplace editor is open and you click anywhere (same or different row from current row) but in the editor itself then just to close editor
        flag = self.modified.has_key('inplace')
        self.OnUpdate()
        if flag:
            evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row
            return

    x,y = evt.GetPosition()
    LCtrl = self.ListCtrls[self.L]

    #Using HitTest to obtain row clicked on because there was a noticable delay in the generation of an
    #EVT_LIST_ITEM_SELECTED event when you click on the already selected row
    idx,flags = LCtrl.HitTest((x,y))

    #if you are below rows of items then idx = -1 which could match self.curIdx = -1
    if idx == -1:
        return

    # only if you click on the currently selected row do the following events occur
    if idx == self.curIdx:
        if x &lt; 18:
            self.OnToggleFinished()
        elif x &lt; 33:
            self.OnPriority()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1):
            self.OnDisplayInPlaceEditor()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1) + LCtrl.GetColumnWidth(2): 
            self.OnEditOwner()
        else:
            self.OnDueDate
    else:
        evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row
</pre>
</div>
<div class="section" id="onrightdown-display-popup-sendto-menu">
<h4><a class="toc-backref" href="#id58" name="onrightdown-display-popup-sendto-menu">OnRightDown (Display popup sendto menu)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnRightDown(self, evt):
    x,y = evt.GetPosition()

    sendtomenu = wxMenu()

    open_tables = []
    for page,Properties in enumerate(self.PropertyDicts):
        host,table = Properties['host'],Properties['table']
        open_tables.append((host,table))
        sendtomenu.Append(1+page,&quot;%s (%s)&quot;%(table,host))
        EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))

    sendtomenu.Delete(self.L+1) # don't send it to the page you're already on
    sendtomenu.AppendSeparator()

    self.closed_tables = []
    for host,cursor in self.Cursors.items():

        location, rdbms = host.split(':')

        if rdbms == 'sqlite':
            cursor.execute(&quot;SELECT name FROM sqlite_master WHERE type='table' ORDER BY name&quot;)
        elif rdbms == 'mysql':
            cursor.execute(&quot;SHOW tables&quot;)

        results = cursor.fetchall()

        page+=1
        for (table,) in results:
            if not ((host,table) in open_tables or table in ['user_sync','owners','sync']):
                self.closed_tables.append((host,table))
                sendtomenu.Append(1+page,&quot;%s (%s)&quot;%('*'+table,host))
                EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
                page+=1

    self.PopupMenu(sendtomenu,(x+125,y+40))
    sendtomenu.Destroy()
</pre>
</div>
</div>
<div class="section" id="move-combine-items-methods">
<h3><a class="toc-backref" href="#id59" name="move-combine-items-methods">Move/Combine items methods</a></h3>
<div class="section" id="oncombineitems">
<h4><a class="toc-backref" href="#id60" name="oncombineitems">OnCombineItems</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCombineItems(self, evt):
    L = self.L
    idx = self.curIdx
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]

    combine_list = []
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        combine_list.append((IList[i].createdate,IList[i]))


    if len(combine_list) &lt; 2:
        print &quot;Fewer than two items highlighted&quot;
        return

    combine_list.sort()
    combine_list.reverse()

    dlg = wxMessageDialog(self,
                        &quot;Combine the %d selected items?&quot;%len(combine_list),
                        &quot;Combine Items?&quot;,
                        wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        Properties = self.PropertyDicts[L]
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        t_item = combine_list[0][1]
        merge_list = combine_list[1:]
        new_note = &quot;&quot;

        for date,item in merge_list:
            note = self.GetNote(item=item)
            date = date.Format(&quot;%m/%d/%y&quot;)
            new_note = &quot;%s\n%s %s\n\n%s&quot;%(new_note, date, item.name, note)

            cursor.execute(&quot;DELETE from &quot;+table+&quot; WHERE id = %s&quot;, (item.id,))
            #Track Deletes for Syncing ############################################
            if table in SYNC_TABLES:
                if host.split(':')[1] == 'sqlite':
                    timestamp = mx.DateTime.now()
                    cursor.execute(&quot;INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)&quot;,(item.id,'d',table,item.name,timestamp))
                else:
                    cursor.execute(&quot;INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)&quot;,(item.id,'d',table,USER,item.name))
            #########################################################################

        t_note = self.GetNote(item=t_item)
        t_note = &quot;%s\n%s&quot;%(t_note,new_note)

        #What about combining owners?######################################

        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET name = %s, note = %s WHERE id = %s&quot;, (t_item.name+&quot;*&quot;,t_note,t_item.id))
        t_item.timestamp = self.TimeStamper(host, cursor, table, t_item.id)

        self.OnRefresh()
        LCtrl.SetItemState(0, 0, wxLIST_STATE_SELECTED)
        IList = self.ItemLists[L]
        id = t_item.id
        idx = -1
        for item in IList:
            idx+=1
            if id == item.id:
                break
        else:
            idx = -1 

        #should never be -1
        if idx != -1:   
            LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
            LCtrl.EnsureVisible(idx)
        self.curIdx = idx

    dlg.Destroy()
</pre>
</div>
<div class="section" id="onmovetolist">
<h4><a class="toc-backref" href="#id61" name="onmovetolist">OnMoveToList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnMoveToList(self, evt=None, page=0):
    self.OnCopyItems(cut=True)
    pc = self.nb.GetPageCount()
    if page &lt; pc:               
        self.OnPasteItems(L=page)
    else:
        host,table = self.closed_tables[page-pc]
        cursor = self.Cursors[host]# in ini self.Cursors[host]

        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id

            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = &quot;INSERT INTO &quot;+table+&quot; (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)

    self.copyitems = []
</pre>
</div>
<div class="section" id="onmovetospecificlist">
<h4><a class="toc-backref" href="#id62" name="onmovetospecificlist">OnMoveToSpecificList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnMoveToSpecificList(self, evt=None, table='follow_ups'):
    matches = {}
    for page,Properties in enumerate(self.PropertyDicts):
        host,tble = Properties['host'],Properties['table']
        if tble == table:
            rdbms = host.split(':')[1]
            matches[rdbms] = page

    self.OnCopyItems(cut=True)

    if matches:
        if matches.get('mysql'):        
            self.OnPasteItems(L=matches['mysql'])
        else:
            self.OnPasteItems(L=matches['sqlite'])
    else:
        cursor = self.Cursors[LOCAL_HOST]

        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id

            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = &quot;INSERT INTO &quot;+table+&quot; (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)

    self.copyitems = []
</pre>
</div>
</div>
<div class="section" id="change-update-items-methods">
<h3><a class="toc-backref" href="#id63" name="change-update-items-methods">Change/update items methods</a></h3>
<div class="section" id="ontogglefinished">
<h4><a class="toc-backref" href="#id64" name="ontogglefinished">OnToggleFinished</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnToggleFinished(self, evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx

    item = self.ItemLists[L][idx]
    LC_Item = LCtrl.GetItem(idx)

    if not item.finisheddate:
        item.finisheddate = mx.DateTime.today()
        LC_Item.SetImage(LCtrl.idx0)
    else:
        item.finisheddate = None
        LC_Item.SetImage(LCtrl.idx1)

    &lt;&lt; draw item &gt;&gt;

    self.tb.EnableTool(30, True)

    host = Properties['host']   
    cursor = self.Cursors[host]
    table = Properties['table']

    cursor.execute(&quot;UPDATE &quot;+table+&quot; SET finisheddate = %s WHERE id = %s&quot;, (item.finisheddate, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))
    elif Properties['LCdate'] == 'finisheddate':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.finisheddate.Format('%m/%d/%y'))
</pre>
<div class="section" id="draw-item">
<h5><a class="toc-backref" href="#id65" name="draw-item">&lt;&lt; draw item &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)

elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)

elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

LCtrl.SetItem(LC_Item)
</pre>
</div>
</div>
<div class="section" id="onpriority">
<h4><a class="toc-backref" href="#id66" name="onpriority">OnPriority</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnPriority(self, event=None, input=None):
    L = self.L
    idx = self.curIdx
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]

    if input:
        item.priority=input

    else:
        if item.priority &lt; 3:
            item.priority+= 1
        else:
            item.priority=1

    LC_Item = LCtrl.GetItem(idx)

    &lt;&lt; draw item &gt;&gt;

    text = str(item.priority)        
    LCtrl.SetStringItem(idx, 0, text)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    cursor.execute(&quot;UPDATE &quot;+table+&quot; SET priority = %s WHERE id = %s&quot;, (item.priority,item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    wxCallAfter(LCtrl.SetFocus)
</pre>
<div class="section" id="id1">
<h5><a class="toc-backref" href="#id67" name="id1">&lt;&lt; draw item &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)

elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)

elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

LCtrl.SetItem(LC_Item)
</pre>
</div>
</div>
<div class="section" id="inplace-edit-methods">
<h4><a class="toc-backref" href="#id68" name="inplace-edit-methods">Inplace Edit Methods</a></h4>
<div class="section" id="ondisplayinplaceeditor">
<h5><a class="toc-backref" href="#id69" name="ondisplayinplaceeditor">OnDisplayInPlaceEditor</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDisplayInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    #if self.Conflict(host, cursor, table, item): return #works -- may be overkill so i've commented it out

    TCid = wxNewId()
    y = LCtrl.GetItemPosition(idx)[1] 
    length = LCtrl.GetColumnWidth(1)

    editor = wxTextCtrl(self, TCid, pos = (167,y+28), size = (length,23), style=wxTE_PROCESS_ENTER)
    editor.SetFont(wxFont(9, wxSWISS, wxNORMAL, wxNORMAL))
    editor.SetBackgroundColour(wxColour(red=255,green=255,blue=175)) #Yellow
    editor.AppendText(item.name)
    editor.Show(True)
    editor.Raise()
    editor.SetSelection(-1,-1)
    editor.SetFocus()   

    EVT_TEXT_ENTER(self, TCid, self.OnCloseInPlaceEditor)               

    self.in_place_editor = editor
    self.modified['inplace'] = 1
</pre>
</div>
<div class="section" id="oncloseinplaceeditor">
<h5><a class="toc-backref" href="#id70" name="oncloseinplaceeditor">OnCloseInPlaceEditor</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCloseInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    LCdate = Properties['LCdate']

    #if self.Conflict(host, cursor, table, item)...

    text = self.in_place_editor.GetValue().strip()[:150]
    item.name = text
    LCtrl.SetStringItem(idx, self.attr2col_num['name'], text)
    self.in_place_editor.Destroy()

    cursor.execute(&quot;UPDATE &quot;+table+&quot; SET name = %s WHERE id = %s&quot;, (text, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    self.name.Clear()
    self.name.AppendText(text) #this will cause self.modified['name'] = 1, which is dealt with below

    #using default in case for some reason self.modified does not have the keys
    self.modified.pop('inplace', None)
    self.modified.pop('name', None)

    wxCallAfter(LCtrl.SetFocus) #sets focus on LCtrl and current selection to be highlighted
</pre>
</div>
</div>
<div class="section" id="onduedate">
<h4><a class="toc-backref" href="#id71" name="onduedate">OnDueDate</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDueDate(self, evt=None):
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    LCtrl = self.ListCtrls[L]

    if item.duedate:
        date = wxDateTime()
        date.SetTimeT(item.duedate) #I am surprised it takes a mx.DateTime object; supposed to need ticks
    else:
        date = 0
    dlg = CalendarDialog(parent=self,
                 title=&quot;Select a date&quot;,
                 size=(400,400),
                 style=wxCAPTION,
                 date = date)
    if dlg.ShowModal()==wxID_OK:
        date = dlg.cal.GetDate() # this is some date object
        #date = date.GetTicks()
        item.duedate = mx.DateTime.DateFromTicks(date.GetTicks())

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET duedate = %s WHERE id = %s&quot;, (item.duedate,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))
        elif Properties['LCdate'] == 'duedate':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.duedate.Format('%m/%d/%y'))
    dlg.cal.Destroy()
    dlg.Destroy()
</pre>
</div>
<div class="section" id="oneditowner">
<h4><a class="toc-backref" href="#id72" name="oneditowner">OnEditOwner</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnEditOwner(self, evt=None): #, new=False) removed Aug. 31 for simplicity
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    item = self.ItemLists[L][idx]
    if not self.ModifierDialog:
        print &quot;self.ModifierDialog is still being constructed&quot;
        return
    #need to clear the current selections or you'll just be making more and more selections
    self.ModifierDialog.SelectCurrent(item.owners)
    self.ModifierDialog.tc.Clear()
    self.ModifierDialog.CenterOnParent()

    val = self.ModifierDialog.ShowModal()

    if val == wxID_OK:
        item.owners, new_names = self.ModifierDialog.GetUserInput()

        &lt;&lt; Common Owner Code &gt;&gt;

        for owner in item.owners:
            if self.OwnerLBoxes[L].FindString(owner) == -1:
                self.OwnerLBoxes[L].Append(owner)

        for owner in new_names:
            self.ModifierDialog.lb.Append(owner)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s&quot;, (z[0],z[1],z[2],item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))

        if 'owners' in self.modified:
            del self.modified['owners']

    wxCallAfter(LCtrl.SetFocus)
</pre>
<div class="section" id="common-owner-code">
<h5><a class="toc-backref" href="#id73" name="common-owner-code">&lt;&lt; Common Owner Code &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)

z = item.owners+[None,None,None] #note that + creates a new list
</pre>
</div>
</div>
<div class="section" id="onupdate">
<h4><a class="toc-backref" href="#id74" name="onupdate">OnUpdate</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnUpdate(self, evt=None):
    if 'inplace' in self.modified:
        self.OnCloseInPlaceEditor()
        if not self.modified:
            return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    OLBox = self.OwnerLBoxes[L]
    idx = self.curIdx

    # there is some chance that it is never true that idx == -1 and then this could be eliminated
    if idx != -1:
        item = IList[idx]
    else:
        msg = wxMessageDialog(self, &quot;There is no selected item to update&quot;, &quot;&quot;, wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        self.modified = {}
        return

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    if 'name' in self.modified:
        item.name = self.name.GetValue().strip()[:150]
        LCtrl.SetStringItem(idx, self.attr2col_num['name'], item.name)
        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET name =%s WHERE id = %s&quot;,(item.name,item.id))

    if 'note' in self.modified:
        note = self.note.GetValue() #a blank note starts out as None but after this it becomes '' -- ??
        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET note =%s WHERE id = %s&quot;,(note,item.id))

    if 'owners' in self.modified:
        owner_str = self.owners.GetValue().strip()
        item.owners = []
        if owner_str:
            owner_list = [x.strip() for x in owner_str.split(';')]
            for owner in owner_list:
                owner = &quot;, &quot;.join([x.strip().title() for x in owner.split(',')])
                item.owners.append(owner)

        &lt;&lt; Common Owner Code &gt;&gt;

        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s&quot;, (z[0],z[1],z[2],item.id))

        for owner in item.owners:
            if self.ModifierDialog.lb.FindString(owner) == -1:
                self.ModifierDialog.lb.Append(owner)
                OLBox.Append(owner)
            elif OLBox.FindString(owner) == -1:
                OLBox.Append(owner)             

    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, 3, item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))

    self.modified = {}
</pre>
<div class="section" id="id2">
<h5><a class="toc-backref" href="#id75" name="id2">&lt;&lt; Common Owner Code &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)

z = item.owners+[None,None,None] #note that + creates a new list
</pre>
</div>
</div>
<div class="section" id="onnewitem">
<h4><a class="toc-backref" href="#id76" name="onnewitem">OnNewItem</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnNewItem(self, evt=None):
    L=self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    if self.curIdx != -1:
        LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)

    &lt;&lt; Clear data fields &gt;&gt;

    class Item: pass
    item = Item()
    item.name = '&lt;New Item&gt;'
    item.priority = 1
    item.owners = []
    item.createdate = mx.DateTime.now() #need this to be a timestamp and not just date for syncing
    item.duedate = item.finisheddate = None

    self.ItemLists[L].insert(0,item)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    item.id = self.GetUID()

    cursor.execute(&quot;INSERT INTO &quot;+table+&quot; (priority,name,createdate,finisheddate,duedate,id) VALUES (%s,%s,%s,%s,%s,%s)&quot;,
                (item.priority,item.name,item.createdate,None,None,item.id))

    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    #tracking new item for syncing will happen in Edit Name

    LCtrl.InsertImageStringItem(0,&quot;1&quot;, LCtrl.idx1)
    LCtrl.SetStringItem(0,1,item.name)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))
    elif Properties['LCdate'] == 'createdate':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

    self.curIdx = 0

    #if Display is being filtered we assume that is the owner of the new node
    owner = Properties['owner'] 
    if owner and owner!='*ALL':
        self.ListCtrls[L].SetStringItem(0, self.attr2col_num['owners'], owner)
        item.owners = [owner]

        self.owners.Clear()
        self.owners.AppendText(owner)

        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET owner1 = %s WHERE id = %s&quot;, (owner,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)  #not really necessary since just got a timestamp

    # decided that it was actually better not to ask for the owner on a new node        
    #else:
        #self.OnEditOwner()

    LCtrl.SetFocus() #needed for the in place editor to look right
    LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)

    self.OnDisplayInPlaceEditor() #(new=True)
</pre>
<div class="section" id="clear-data-fields">
<h5><a class="toc-backref" href="#id77" name="clear-data-fields">&lt;&lt; Clear data fields &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
self.name.Clear()
self.owners.Clear()
self.note.Clear()
</pre>
</div>
</div>
<div class="section" id="conflict-not-in-use">
<h4><a class="toc-backref" href="#id78" name="conflict-not-in-use">Conflict (not in use)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
&#64; Need to decide if we are going to have timestamp checking to be sure something hasn't changed
Note that there would not need to be timestamp checking on a new node
Also  there is no need to timestamp check on a local DB
The following code seems to work fine, however, I have just commented out the calls to it in NameEditor methods
&#64;c
def Conflict(self, host, cursor, table, item):
    if host is 'sqlite':
        return False
    cursor.execute(&quot;Select timestamp from &quot;+table+&quot; WHERE id = %s&quot;, (item.id,))
    db_timestamp = cursor.fetchone()[0]
    if db_timestamp != item.timestamp:
        print &quot;There is a conflict and you should refresh display&quot;
        return True
    else:
        return False
</pre>
</div>
<div class="section" id="oneditnote">
<h4><a class="toc-backref" href="#id79" name="oneditnote">OnEditNote</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnEditNote(self, evt=None):
    if self.modified:
        self.OnUpdate()

    idx = self.curIdx

    if idx == -1:
        return

    L = self.L

    #if self.editor:
        #machine = None
        #win32pdh.EnumObjects(None, machine, 0, 1) # resets Enum otherwise it seems to hold onto old data
        #object = &quot;Process&quot;
        #items, instances = win32pdh.EnumObjectItems(None,None,&quot;Process&quot;, -1)
        #if 'TextPad' in instances:
            #print &quot;TextPad is running&quot;
        #else:
            #self.editor = {}

    item = self.ItemLists[L][idx]
    file_name = re.sub('[\\/:*&quot;&lt;&gt;|\?]','-',item.name) #make sure all chars are legal file name characters

    path = os.path.join(os.environ['TMP'],file_name[:50])+'.%s'%NOTE_EXT

    f = file(path,'w')
    f.write(self.GetNote())
    f.close()

    os.startfile(path)

    id = item.id
    for d in self.editor:
        if d['id'] == id:
            return

    ed = {}
    ed['time'] = os.path.getmtime(path)
    ed['host'] = self.PropertyDicts[L]['host']
    ed['table'] = self.PropertyDicts[L]['table']
    ed['path'] = path
    ed['id'] = item.id

    self.editor.append(ed)

    time.sleep(.1)
</pre>
</div>
</div>
<div class="section" id="file-menu-methods">
<h3><a class="toc-backref" href="#id80" name="file-menu-methods">File menu methods</a></h3>
<div class="section" id="onnewlist">
<h4><a class="toc-backref" href="#id81" name="onnewlist">OnNewList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnNewList(self, event=None):
    if self.modified:
        self.OnUpdate()

    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]

    dlg = wxSingleChoiceDialog(self, 'Databases', 'Choose a database:', hosts, wxCHOICEDLG_STYLE)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        host = dlg.GetStringSelection()
    else:
        return

    cursor = self.GetCursor(host)
    if cursor is None:
        return

    dlg = wxTextEntryDialog(self, 'What is the name of the new table?', 'Create Table')
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        table = dlg.GetValue()
    else:
        return

    if not table:
        return

    location, rdbms = host.split(':')

    if rdbms == 'sqlite':
        cursor.execute(&quot;SELECT name FROM sqlite_master WHERE type='table' ORDER BY name&quot;)
    else:
        cursor.execute(&quot;SHOW tables&quot;)

    if (table,) in cursor.fetchall():
        msg = wxMessageDialog(self,
                              &quot;Table '%s' already exists&quot;%table,
                              &quot;Duplicate Table&quot;,
                              wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        return

    dlg = wxMessageDialog(self,
          &quot;Are you sure you want to create Table '%s'?&quot;%table,
          &quot;Create Table?&quot;,
          wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        self.CreateTable(host,table)
        self.CreateNewNotebookPage(host,table)

        #self.AddListControl(tab_title) #add listcontrol displays the list

        #self.OnNewItem()

    dlg.Destroy()
</pre>
</div>
<div class="section" id="onfilelist">
<h4><a class="toc-backref" href="#id82" name="onfilelist">OnFileList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnFileList(self, evt=None, path=None):
    if self.modified:
        self.OnUpdate()

    #if there is no event, we got here through the start up loading of lists
    if evt:
        fileNum = evt.GetId() - wxID_FILE1                      
        path = self.filehistory.GetHistoryFile(fileNum)
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
        # only need to check if table is open if this is not at startup
        if table in [p['table'] for p in self.PropertyDicts if p['host'] == host]:
            dlg = wxMessageDialog(self,&quot;%s (%s) is already open!&quot;%(table,host),&quot;List Open&quot;,wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            return

    else:
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)

    cursor = self.GetCursor(host)
    if cursor is None:
        return

    if rdbms == 'sqlite':
        sql = &quot;SELECT name FROM sqlite_master WHERE name = '%s'&quot;%table
    else:
        sql = &quot;SHOW TABLES LIKE '%s'&quot;%table

    cursor.execute(sql)
    if not cursor.fetchall():
        dlg = wxMessageDialog(self,
                    &quot;Table '%s' at host '%s' does not appear to exist!&quot;%(table,host),
                    &quot;Table does not exist&quot;,
                    wxICON_ERROR|wxOK)
        dlg.ShowModal()
        dlg.Destroy()
        return

    self.CreateNewNotebookPage(host,table)
</pre>
</div>
<div class="section" id="onopenlist">
<h4><a class="toc-backref" href="#id83" name="onopenlist">OnOpenList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnOpenList(self, evt=None):
    if self.modified:
        self.OnUpdate()

    tree = {}

    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]

    for host in hosts:
        cursor = self.GetCursor(host)
        if cursor:
            if host.split(':')[1] == 'sqlite':
                sql = &quot;SELECT name FROM sqlite_master WHERE type='table' ORDER BY name&quot;
            else:
                sql = &quot;SHOW TABLES&quot; #sorted

            cursor.execute(sql)
            results = cursor.fetchall()

            #excluding already open tables + 'system' tables
            excluded_tables = [p['table'] for p in self.PropertyDicts if p['host'] == host]
            excluded_tables.extend(['user_sync','sync','owners'])

            tables = [t for (t,) in results if t not in excluded_tables]

            tree[host] = tables

    dlg = TreeDialog(self, &quot;Open List&quot;, tree=tree)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        sel = dlg.TreeCtrl.GetSelection()
        table = dlg.TreeCtrl.GetItemText(sel)
        sel = dlg.TreeCtrl.GetItemParent(sel)
        host = dlg.TreeCtrl.GetItemText(sel)

        if host in hosts: #takes care of highlighting root or hosts
            self.CreateNewNotebookPage(host,table)
</pre>
</div>
<div class="section" id="ondeletelist">
<h4><a class="toc-backref" href="#id84" name="ondeletelist">OnDeleteList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDeleteList(self, evt=None):
    #ini controls whether the menu item is enabled
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    table = Properties['table']

    #if table is in SYNC_TABLES, should we make a point of that?
    dlg = wxMessageDialog(self,
                        &quot;Are you sure that you want to delete table %s (%s)?\n(Please note that you cannot recover it once it is deleted!)&quot;%(table,host),
                        &quot;Delete Table...&quot;,
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    rdbms = host.split(':')[1]

    if rdbms == 'mysql':
        dlg = wxMessageDialog(self,
                        &quot;Are you sure really really sure you want to delete table %s (%s)?\n(You really really cannot recover it once it is deleted)&quot;%(table,host),
                        &quot;Delete Table...&quot;,
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)

        val = dlg.ShowModal()
        dlg.Destroy()
        if val == wxID_NO:
            return

    cursor = self.Cursors[host]
    cursor.execute(&quot;DROP TABLE %s&quot;%table)

    self.OnCloseList()
</pre>
</div>
<div class="section" id="oncloselist">
<h4><a class="toc-backref" href="#id85" name="oncloselist">OnCloseList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCloseList(self, evt=None):
    if self.modified:
        self.OnUpdate()

    L = self.L

    del self.ItemLists[L]
    del self.PropertyDicts[L]
    del self.ListCtrls[L]
    del self.OwnerLBoxes[L]

    self.nb.DeletePage(L)        

    ln = len(self.PropertyDicts)
    if ln:
        self.nb.SetSelection(0)
        self.L = 0
    else:
        self.L = -1
</pre>
</div>
<div class="section" id="oncloseall">
<h4><a class="toc-backref" href="#id86" name="oncloseall">OnCloseAll</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCloseAll(self, evt=None):
    if self.modified:
        self.OnUpdate()

    while self.L != -1:
        self.OnCloseList()

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does set self.modified (eg {'name':1})
    self.modified = {}
</pre>
</div>
<div class="section" id="onsaveastext">
<h4><a class="toc-backref" href="#id87" name="onsaveastext">OnSaveAsText</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnSaveAsText(self, evt=None):
    if self.modified:
        self.OnUpdate()

    Properties = self.PropertyDicts[self.L]
    wildcard = &quot;txt files (*.txt)|*.txt|All files (*.*)|*.*&quot;
    #dlg = wxFileDialog(self, &quot;Save file&quot;, &quot;&quot;, Properties['table'], wildcard, wxSAVE|wxOVERWRITE_PROMPT|wxCHANGE_DIR)

    body = &quot;&quot;
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+&quot;%d. %s (%d)\n&quot;%(i+1, item.name, item.priority)

    table = Properties['table']
    location, rdbms = Properties['host'].split(':')
    filename = re.sub('[\\/:*&quot;&lt;&gt;|\?]','-','%s-%s-%s'%(location,rdbms,table)) 
    filename = filename[:50]+'.txt'

    path = os.path.join(DIRECTORY,filename)

    f = file(path,'w')
    f.write(body)
    f.close()

    os.startfile(path)

    self.SetStatusText(&quot;Saved file %s&quot;%path)
</pre>
</div>
<div class="section" id="onarchive">
<h4><a class="toc-backref" href="#id88" name="onarchive">OnArchive</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnArchive(self, evt=None):
    if self.modified:
        self.OnUpdate()

    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    rdbms = host.split(':')[1]

    table_archive = table+'_archive'

    #need to test for existence of table_archive
    if rdbms == 'sqlite':
        cursor.execute(&quot;SELECT name FROM sqlite_master WHERE type='table' ORDER BY name&quot;)
    else:
        cursor.execute(&quot;SHOW tables&quot;)

    results = cursor.fetchall()

    if (table_archive,) not in results:
        dlg = wxMessageDialog(self,
                    &quot;Do you want to create an archive for table %s (%s)&quot;%(table,rdbms),
                    &quot;Create an archive...&quot;,
                    wxICON_QUESTION|wxYES_NO)
        val = dlg.ShowModal()
        dlg.Destroy()
        if val==wxID_YES:
            self.CreateTable(host,table_archive)
        else:
            return

    label1 = &quot;In table %s (%s) \narchive all finished items older than:&quot;%(table,rdbms)
    label2 = &quot;Archive all finished items&quot;
    dlg = FinishedDialog(self, &quot;Archive completed items&quot;, days=7, spin_label=label1, check_label=label2)

    val = dlg.ShowModal()
    dlg.Destroy() #dialogs and frames not destroyed right away to allow processing events, methods
    if val==wxID_CANCEL:
        return

    if dlg.check.GetValue():
        cursor.execute(&quot;SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM &quot;+table+&quot; WHERE finisheddate IS NOT NULL&quot;)
    else:
        days = dlg.text.GetValue()
        date = mx.DateTime.today() - int(days)
        cursor.execute(&quot;SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM &quot;+table+&quot; WHERE finisheddate &lt; %s&quot;,(date,))

    results = cursor.fetchall()
    dlg = wxMessageDialog(self,
                        &quot;Archiving will remove %d records from %s.\nDo you want to proceed?&quot;%(len(results),table),
                        &quot;Proceed to archive...&quot;,
                        wxICON_QUESTION|wxYES_NO)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if table in SYNC_TABLES:
        if rdbms == 'sqlite':
            def track_deletes():
                timestamp = mx.DateTime.now()
                cursor.execute(&quot;INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)&quot;,(id,'d',table,name,timestamp))
        else:
            def track_deletes():
                cursor.execute(&quot;INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)&quot;,(id,'d',table,USER,name))
    else:
        def track_deletes():
            pass        

    for row in results:
        # the next line is necessary because pysqlite returns a tuple-like object that is not a tuple
        r = tuple(row)
        id = r[0]
        name = r[2]
        cursor.execute(&quot;INSERT INTO &quot;+table_archive+&quot;  (id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;,r)
        timestamp = self.TimeStamper(host, cursor, table_archive, id)
        cursor.execute(&quot;DELETE from &quot;+table+&quot; WHERE id = %s&quot;, (id,))
        track_deletes()

    self.OnRefresh()
    dlg = wxMessageDialog(self,
                        &quot;Table %s had items older than %s days successfully archived&quot;%(table,days),
                        &quot;Archiving successful...&quot;,
                        wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
</pre>
</div>
<div class="section" id="onworkoffline">
<h4><a class="toc-backref" href="#id89" name="onworkoffline">OnWorkOffline</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnWorkOffline(self, evt=None):
    global OFFLINE_ONLY
    OFFLINE_ONLY = not OFFLINE_ONLY
    if OFFLINE_ONLY:
        del self.Cursors[REMOTE_HOST]
    else:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, &quot;Cannot connect to remote server! Will set to work offline.&quot;, &quot;ListManager&quot;, style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    self.filemenu.Check(idOFFLINE,OFFLINE_ONLY)
</pre>
<p>This method toggles whether we are working offline only or both on and offline.</p>
</div>
</div>
<div class="section" id="display-methods">
<h3><a class="toc-backref" href="#id90" name="display-methods">Display methods</a></h3>
<div class="section" id="onitemselected">
<h4><a class="toc-backref" href="#id91" name="onitemselected">OnItemSelected</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnItemSelected(self, evt=None):
    if self.modified:
        self.OnUpdate()

    if evt:
        idx = evt.GetIndex()
    elif self.curIdx != -1:
        idx = self.curIdx
    else: # really to catch self.curIdx = -1 (see OnDelete and OnRefresh)
        self.name.Clear() # could be moved out of if
        self.owners.Clear() # could be moved out of if
        self.note.Clear()
        #note that Clearing does set self.modified (eg {'name':1})
        self.modified = {}
        return

    L = self.L
    item = self.ItemLists[L][idx]

    self.name.Clear()
    self.name.AppendText(item.name) #SetValue(item.name) - if you use setvalue you don't get the font

    self.owners.Clear()
    self.owners.AppendText('; '.join(item.owners))

    note = self.GetNote(L,item)
    if note.find(&quot;&lt;leo_file&gt;&quot;) != -1:
        self.note.SetValue(&quot;Leo Outline&quot;)
        self.note.SetEditable(False)
    else:
        self.note.SetValue(note)
        self.note.SetEditable(True)

    self.ListCtrls[L].EnsureVisible(idx)
    self.curIdx = idx

    #writing to text widgets caused wxEVT_COMMAND_TEXT_UPDATED which is caught by EVT_TEXT, which updates self.modified
    self.modified={}
</pre>
</div>
<div class="section" id="onitemactivated">
<h4><a class="toc-backref" href="#id92" name="onitemactivated">OnItemActivated</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnItemActivated(self,evt):
    print &quot;On Activated&quot;
</pre>
</div>
<div class="section" id="onshowall">
<h4><a class="toc-backref" href="#id93" name="onshowall">OnShowAll</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowAll(self, evt=None):
    L = self.L
    OLBox = self.OwnerLBoxes[L]

    Properties = self.PropertyDicts[L]
    Properties['showfinished'] = -1
    Properties['owner'] = '*ALL'

    OLBox.SetStringSelection('*ALL')

    self.OnRefresh()
</pre>
</div>
<div class="section" id="onrefresh">
<h4><a class="toc-backref" href="#id94" name="onrefresh">OnRefresh</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnRefresh(self, evt=None):
    #OnItemSelected should be able to handle no items so this could be very short
    L = self.L

    results = self.ReadFromDB()
    self.ItemLists[L] = self.CreateAndDisplayList(results)

    if self.ItemLists[L]:
        self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0
    else:
        self.curIdx = -1                

    self.OnItemSelected()
</pre>
</div>
<div class="section" id="onfilterowners">
<h4><a class="toc-backref" href="#id95" name="onfilterowners">OnFilterOwners</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnFilterOwners(self, evt=None):
    if self.modified:
        self.OnUpdate()
    sel = self.OwnerLBoxes[self.L].GetStringSelection()

    if sel:
        self.PropertyDicts[self.L]['owner'] = sel
        self.OnRefresh()
</pre>
</div>
<div class="section" id="oncolumnclick-to-sort-columns">
<h4><a class="toc-backref" href="#id96" name="oncolumnclick-to-sort-columns">OnColumnClick (to sort columns)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnColumnClick(self, evt):
    col_num = evt.GetColumn()
    L = self.L
    LCtrl = self.ListCtrls[L]
    Sort = self.PropertyDicts[L]['sort']
    attr2col = self.attr2col_num

    prev_sort_attr = Sort.get('attribute') #if this is the first sort Properties['sort'] is {}

    #following is a little bit ugly but gets the key from the value, which is col_num
    Sort['attribute'] = attr2col.keys()[attr2col.values().index(col_num)]

    if prev_sort_attr == Sort['attribute']:
        Sort['direction'] = not Sort['direction']
    else:
        Sort['direction'] = 0

    self.OnRefresh()

    LCtrl.ClearColumnImage(attr2col['priority'])
    LCtrl.ClearColumnImage(attr2col['date'])
    img_num = LCtrl.arrows[Sort['direction']]
    LCtrl.SetColumnImage(col_num, img_num)
</pre>
</div>
<div class="section" id="onshowfinished">
<h4><a class="toc-backref" href="#id97" name="onshowfinished">OnShowFinished</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowFinished(self,evt):
    Properties = self.PropertyDicts[self.L]
    label1 = &quot;Enter the number of days to retain\ncompleted tasks in the display:&quot;
    label2 = &quot;Show all finished items&quot;
    dlg = FinishedDialog(self, &quot;Display of completed items&quot;, days=Properties['showfinished'], spin_label=label1, check_label=label2)
    if dlg.ShowModal()==wxID_OK:
        if dlg.check.GetValue():
            Properties['showfinished'] = -1
        else:
            days = dlg.text.GetValue()
            Properties['showfinished'] = int(days)                      
        self.OnRefresh()
    dlg.Destroy()
</pre>
</div>
<div class="section" id="oncolumnrightclick-popup-to-change-date-displayed">
<h4><a class="toc-backref" href="#id98" name="oncolumnrightclick-popup-to-change-date-displayed">OnColumnRightClick (popup to change date displayed)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnColumnRightClick(self, evt=None):
    col = evt.GetColumn()
    if col != self.attr2col_num['date']:
        return

    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    #x,y = evt.GetPosition()
    datemenu = wxMenu()

    for i,date in enumerate(['Create Date','Last Modified','Due Date','Completion Date']):
        datemenu.Append(200+i, date)
        EVT_MENU(self, 200+i, lambda e, i=i: self.ChangeDateDisplayed(e,i))

    x = LCtrl.GetColumnWidth(1)+ LCtrl.GetColumnWidth(2) + LCtrl.GetColumnWidth(3)
    self.PopupMenu(datemenu,(x,40))
    datemenu.Destroy()
</pre>
</div>
<div class="section" id="ondisplaydatecategory">
<h4><a class="toc-backref" href="#id99" name="ondisplaydatecategory">OnDisplayDateCategory</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDisplayDateCategory(self, evt=None):
    dlg = wxSingleChoiceDialog(self, 'Date Display', 'Choose a date to display:',
                    ['Create Date','Last Modified','Due Date','Completion Date']
                    , wxOK|wxCANCEL)
    val = dlg.ShowModal()
    dlg.Destroy()

    if val == wxID_OK:
        idx = dlg.GetSelection()
        self.ChangeDateDisplayed(i=idx)
</pre>
</div>
<div class="section" id="changedatedisplayed">
<h4><a class="toc-backref" href="#id100" name="changedatedisplayed">ChangeDateDisplayed</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def ChangeDateDisplayed(self, evt=None, i=0):
    L = self.L
    LCtrl = self.ListCtrls[L]
    self.PropertyDicts[L]['LCdate'] = displaydate = ('createdate','timestamp','duedate','finisheddate')[i]      
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles[displaydate])
    LCtrl.SetColumn(col_num,col_info)
    self.DisplayList(self.ItemLists[L])
    #self.OnRefresh() #have gone back and forth but think that it should be self.DisplayList
</pre>
</div>
<div class="section" id="displaylist">
<h4><a class="toc-backref" href="#id101" name="displaylist">DisplayList</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def DisplayList(self, List, L=None):
    #OnPasteItems needs to be able to have an L that is not self.L
    if L is None:
        L = self.L
    LCtrl = self.ListCtrls[L]
    LCdate = self.PropertyDicts[L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    LCtrl.DeleteAllItems()

    for x,item in enumerate(List):
        &lt;&lt; draw item &gt;&gt;
</pre>
<div class="section" id="id3">
<h5><a class="toc-backref" href="#id102" name="id3">&lt;&lt; draw item &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or &quot;&quot;)

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)

elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)
</pre>
</div>
</div>
</div>
<div class="section" id="printing-methods">
<h3><a class="toc-backref" href="#id103" name="printing-methods">Printing methods</a></h3>
<div class="section" id="onpagesetup">
<h4><a class="toc-backref" href="#id104" name="onpagesetup">OnPageSetup</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnPageSetup(self, evt):
    #need to pass printdata to tableprint

    psdata = wxPageSetupDialogData()

    # if want to vary margins will need to save them as ivars and then set
    #psdata.SetMarginTopLeft((self.Left,self.Top))
    psdata.EnableMargins(False)
    psdata.SetPrintData(self.printdata) #gets Paper Orientation and PaperId info from printdata

    dlg = wxPageSetupDialog(self, psdata)
    if dlg.ShowModal() == wxID_OK:
        self.printdata = dlg.GetPageSetupData().GetPrintData()
        dlg.Destroy()
</pre>
</div>
<div class="section" id="onprint">
<h4><a class="toc-backref" href="#id105" name="onprint">OnPrint</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnPrint(self, evt=None, prev=False, showprtdlg=True):               #???self.psdata = psdata
    IList = self.ItemLists[self.L]
    Properties = self.PropertyDicts[self.L]

    prt = PrintTable(self.printdata) #self.printdata is the wxPrintData object with Orientation Info

    font_name = prt.default_font_name
    prt.text_font = {'Name':font_name, 'Size':11, 'Colour':[0, 0, 0], 'Attr':[0, 0, 0]}
    prt.label_font = {'Name':font_name, 'Size':12, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    prt.header_font = {'Name':font_name, 'Size':14, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}

    prt.row_def_line_colour = wxLIGHT_GREY
    prt.column_def_line_colour = wxLIGHT_GREY

    prt.left_margin = 0.5

    data = []
    for row,item in enumerate(IList):   
        data.append([str(item.priority),
                    item.name,
                    item.duedate and item.duedate.Format('%m/%d/%y') or '',
                    '; '.join([x.split(',')[0] for x in item.owners])]) #just last names

        if item.finisheddate:
            prt.SetCellText(row, 0, wxLIGHT_GREY)
            prt.SetCellText(row, 1, wxLIGHT_GREY)
            prt.SetCellText(row, 2, wxLIGHT_GREY)
            prt.SetCellText(row, 3, wxLIGHT_GREY)

    prt.data = data
    prt.label = ['P','Item','Due','Owner']

    if self.printdata.GetOrientation() == wxPORTRAIT:
        prt.set_column = [.2, 5, .65, 1]
    else:
        prt.set_column = [.2, 7, .65, 1.5]

    title = &quot;Table: %s   Owner: %s    &quot;%(Properties['table'],Properties['owner'])
    prt.SetHeader(title, type='Date &amp; Time', align=wxALIGN_LEFT, indent = 1.5)
    prt.SetFooter(&quot;Page No &quot;, type =&quot;Num&quot;)

    if prev:
        prt.Preview()
    else:
        prt.Print(prompt=showprtdlg)
</pre>
</div>
</div>
<div class="section" id="exiting-methods">
<h3><a class="toc-backref" href="#id106" name="exiting-methods">Exiting methods</a></h3>
<div class="section" id="onwindowexit">
<h4><a class="toc-backref" href="#id107" name="onwindowexit">OnWindowExit</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnWindowExit(self, evt):
    #this is called if you close the ListManager Window with the X
    if evt.CanVeto():
        self.OnExit()
    else:
        evt.Skip()
</pre>
</div>
<div class="section" id="onexit">
<h4><a class="toc-backref" href="#id108" name="onexit">OnExit</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnExit(self, event=None):   
    &lt;&lt; save configuration file &gt;&gt;
    sys.stderr.dlg.Destroy() #destroys the error dialog; need to do this to shut down correctly
    if self.ModifierDialog: #only reason to check is if closed before ModifierDialog is constructed
        self.ModifierDialog.Destroy()
    self.Close(1)
</pre>
<div class="section" id="save-configuration-file">
<h5><a class="toc-backref" href="#id109" name="save-configuration-file">&lt;&lt;save configuration file&gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
cp.remove_section('Files')
cp.add_section(&quot;Files&quot;)

x,y = self.GetSizeTuple()

cp.set('Configuration','x', str(x))
cp.set('Configuration','y', str(y))

numfiles = self.filehistory.GetNoHistoryFiles()

for n in range(numfiles):
    cp.set(&quot;Files&quot;, &quot;path%d&quot;%n, self.filehistory.GetHistoryFile(n))

try:
    #you have to give ConfigParser a writable object
    cfile = file(config_file, 'w')
    cp.write(cfile)
    cfile.close()
except IOError:
    print &quot;The configuration file can't be written!&quot;
    time.sleep(10) #so you can see that there was a problem
</pre>
</div>
</div>
</div>
<div class="section" id="find-methods">
<h3><a class="toc-backref" href="#id110" name="find-methods">Find methods</a></h3>
<div class="section" id="onfind">
<h4><a class="toc-backref" href="#id111" name="onfind">OnFind</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnFind(self, evt=None):
    self.FindDialog.Show(True)
    self.FindDialog.FindText.SetSelection(-1,-1)
    self.FindDialog.FindText.SetFocus()
</pre>
</div>
<div class="section" id="findstring">
<h4><a class="toc-backref" href="#id112" name="findstring">FindString</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def FindString(self, evt=None):
    L = self.L
    Properties = self.PropertyDicts[L]
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']

    pat = self.FindDialog.FindText.GetValue()
    likepat = r&quot;'%&quot;+pat+r&quot;%'&quot;
    finished = self.FindDialog.SearchFinished.GetValue()
    notes = self.FindDialog.SearchNotes.GetValue()

    if finished:
        WHERE = &quot;WHERE &quot;
    else:
        WHERE = &quot;WHERE finisheddate IS NULL AND &quot;

    if notes:
        SELECT = &quot;SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM %s &quot;%table
        WHERE = WHERE + &quot;(name LIKE %s OR note LIKE %s) ORDER BY timestamp DESC&quot;%(likepat,likepat)
    else:
        SELECT = &quot;SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s &quot;%table
        WHERE = WHERE + &quot;name LIKE %s ORDER BY timestamp DESC&quot;%likepat

    sql = SELECT + WHERE                        
    try:
        cursor.execute(sql)
    except:
        print &quot;Cannot read %s: %s&quot;%(Properties['host'],table)
        return
    else:
        results = cursor.fetchall()

    case = self.FindDialog.MatchCase.GetValue()
    whole = self.FindDialog.MatchWhole.GetValue()

    if whole:
        pat = '\\b%s\\b'%pat

    if case:
        z = re.compile(pat)
    else:
        z =re.compile(pat, re.I)

    if notes:
        results = [x for x in results if re.search(z,x[1]) or re.search(z,x[10])]
    else:
        results = [x for x in results if re.search(z,x[1])]

    Properties['LCdate'] = 'timestamp'
    self.ItemLists[L]= IList = self.CreateAndDisplayList(results)

    LCtrl = self.ListCtrls[L]
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles['timestamp'])
    LCtrl.SetColumn(col_num,col_info)

    if IList:
        self.curIdx = 0
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    else:               
        self.curIdx = -1

    self.OnItemSelected()

    Properties['sort'] = {'direction':0,'attribute':'date'}
    Properties['owner'] = '*ALL'

    owner_idx = self.OwnerLBoxes[L].GetSelection()
    if owner_idx != -1:
        self.OwnerLBoxes[L].SetSelection(owner_idx, 0) #get exception if index = -1

    self.SetStatusText(&quot;Found %d items&quot;%len(IList))
</pre>
</div>
<div class="section" id="findnode">
<h4><a class="toc-backref" href="#id113" name="findnode">FindNode</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def FindNode(self, item, showfinished=True):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    Properties['owner'] = '*ALL'
    Properties['showfinished'] = showfinished

    self.ItemLists[L] = IList = self.CreateAndDisplayList(self.ReadFromDB())

    id = item.id
    idx = -1
    for item in IList:
        idx+=1
        if id == item.id:
            break
    else:
        idx = -1

    if idx != -1:       
        LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        LCtrl.EnsureVisible(idx)
    self.curIdx = idx
</pre>
</div>
</div>
<div class="section" id="database-related-methods">
<h3><a class="toc-backref" href="#id114" name="database-related-methods">Database-related methods</a></h3>
<div class="section" id="getcursor">
<h4><a class="toc-backref" href="#id115" name="getcursor">GetCursor</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def GetCursor(self, host):
    cursor = self.Cursors.get(host)
    if cursor:
        return cursor

    location, rdbms = host.split(':')

    if rdbms == 'sqlite':
        db = os.path.join(DIRECTORY,location,DB)
        try:
            Con = sqlite.connect(db=db, autocommit=1)
            cursor = Con.cursor()
            self.sqlite_connections.append(Con)  #getting a weak reference error from PySQLite and this makes it go away
        except:
            dlg = wxMessageDialog(self,
                    &quot;Could not connect to SQLite database at %s&quot;%location,
                    &quot;Connection problem!&quot;,
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None

    elif not OFFLINE_ONLY:
        try:
            Con = MySQLdb.connect(host=location, user=USER, passwd=PW, db=DB)
            cursor = Con.cursor()
        except:
            dlg = wxMessageDialog(self,
                    &quot;host = %s | user = %s | password = %s**** | db = %s - could not connect!&quot;%(host,USER,PW[:3],DB),
                    &quot;Connection problem&quot;,
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None

    if cursor:
        self.Cursors[host] = cursor

    return cursor
</pre>
</div>
<div class="section" id="getnote">
<h4><a class="toc-backref" href="#id116" name="getnote">GetNote</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def GetNote(self, L=None, item=None):
    if L is None:
        L = self.L

    if item is None:
        if self.curIdx != -1:
            item = self.ItemLists[L][self.curIdx]
        else:
            return ''

    Properties = self.PropertyDicts[L]

    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    cursor.execute(&quot;SELECT note from &quot;+table+&quot; WHERE id = %s&quot;, (item.id,))

    ###### Debug -- this does happen where note brings back None 053003
    z = cursor.fetchone()
    if z is None:
        print &quot;In GetNote -&gt; SELECT should not bring back None&quot;
        print &quot;           -&gt; item.id=&quot;,item.id
        z = (None,)
    note = z[0]
    if note is None:
        note = ''
    return note
</pre>
</div>
<div class="section" id="createtable">
<h4><a class="toc-backref" href="#id117" name="createtable">CreateTable</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def CreateTable(self, host, table):
    cursor = self.Cursors[host]
    rdbms = host.split(':')[1]
    if rdbms == 'sqlite':
        sql = &quot;&quot;&quot;CREATE TABLE '%s' ('id' varchar(36) PRIMARY KEY,
'priority' int(1),
'name' varchar(150),
'createdate' datetime,
'finisheddate' date,
'duedate' date,
'owner1' varchar(25),
'owner2' varchar(25),
'owner3' varchar(25),
'note' text,
'timestamp' timestamp(14))&quot;&quot;&quot;%table
    else:
        sql = &quot;&quot;&quot;CREATE TABLE `%s` (`id` varchar(36) NOT NULL default '',
`priority` int(1) NOT NULL default '1',
`name` varchar(150) NOT NULL default '',
`createdate` datetime NOT NULL default '0000-00-00 00:00:00',
`finisheddate` date default '0000-00-00',
`duedate` date default '0000-00-00',
`owner1` varchar(25) default '',
`owner2` varchar(25) default '',
`owner3` varchar(25) default '',
`note` text,
`timestamp` timestamp(14) NOT NULL,PRIMARY KEY  (`id`)) TYPE=MyISAM&quot;&quot;&quot;%table

    cursor.execute(sql)
</pre>
</div>
<div class="section" id="readfromdb-returns-db-results">
<h4><a class="toc-backref" href="#id118" name="readfromdb-returns-db-results">ReadFromDB (returns db results)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def ReadFromDB(self):
    L = self.L
    Properties = self.PropertyDicts[L]

    host = Properties['host']
    cursor = self.GetCursor(host)
    if cursor is None:
        return None

    table = Properties['table']

    owner = Properties['owner']
    if owner == '*ALL':
        WHERE = &quot;&quot;
    else:
        WHERE = 'WHERE (owner1 = &quot;%s&quot; OR owner2 = &quot;%s&quot; OR owner3 = &quot;%s&quot;)'%(owner,owner,owner)

    #-1 show them all; 0 show none; integer show for that many days
    days = Properties['showfinished']   
    if days != -1:
        if days:
            date = mx.DateTime.now() - days
            t = &quot;(finisheddate IS NULL OR finisheddate &gt; '%s')&quot;%date
        else:
            t = &quot;finisheddate IS NULL&quot;

        if WHERE:
            WHERE = &quot;%s AND %s&quot;%(WHERE,t)
        else:
            WHERE = &quot; WHERE %s&quot;%t

    Sort = Properties['sort']
    if Sort:
        sort_attr = Sort['attribute']
        if sort_attr == 'date':
            sort_attr = Properties['LCdate']
        elif sort_attr == 'owners':
            sort_attr = 'owner1'

        WHERE = WHERE + &quot; ORDER BY &quot; + sort_attr
        #if not direction: WHERE = WHERE + &quot; DESC&quot;   works because ASC is the default
        if not Sort['direction']:
            WHERE = WHERE + &quot; DESC&quot; 

    sql = &quot;SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s %s&quot;%(table,WHERE)

    try:
        cursor.execute(sql)
    except:
        print &quot;Cannot read %s: %s&quot;%(Properties['host'],table)
        return None #[]
    else:
        return cursor.fetchall()
</pre>
</div>
<div class="section" id="createanddisplaylist-returns-item-list">
<h4><a class="toc-backref" href="#id119" name="createanddisplaylist-returns-item-list">CreateAndDisplayList (returns Item List)</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def CreateAndDisplayList(self, results):
    LCtrl = self.ListCtrls[self.L]
    LCdate = self.PropertyDicts[self.L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    itemlist = []

    LCtrl.DeleteAllItems()
    class Item: pass

    for x,row in enumerate(results):

        item = Item()
        &lt;&lt; assign item attributes &gt;&gt;
        itemlist.append(item)

        &lt;&lt; draw item &gt;&gt;

    return itemlist
</pre>
<div class="section" id="assign-item-attributes">
<h5><a class="toc-backref" href="#id120" name="assign-item-attributes">&lt;&lt; assign item attributes &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
item.name = row[1]
item.createdate = row[2]
item.finisheddate = row[3]
item.duedate = row[4]
item.owners = [y for y in row[5:8] if y] #if you carry around ['tom',None,None] Note this is 5:8 not 5:7
item.id = row[8]
item.timestamp = row[9]
</pre>
</div>
<div class="section" id="id4">
<h5><a class="toc-backref" href="#id121" name="id4">&lt;&lt; draw item &gt;&gt;</a></h5>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or &quot;&quot;)

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)

elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)
</pre>
</div>
</div>
<div class="section" id="onsync">
<h4><a class="toc-backref" href="#id122" name="onsync">OnSync</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnSync(self, evt=None):
    if self.modified:
        self.OnUpdate()
    #Note that the results of an sqlite query are an instance that you need to turn into a tuple or MySQL gets unhappy

    if OFFLINE_ONLY:
        dlg = wxMessageDialog(self, &quot;You need to be online to synchronize!&quot;, style = wxOK|wxICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return

    dlg = wxMessageDialog(self,&quot;Synchronize Table(s): &quot;+&quot; and &quot;.join(SYNC_TABLES),&quot;Synchronize...&quot;,wxICON_QUESTION|wxYES_NO)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if REMOTE_HOST is None:
        print &quot;There doesn't appear to be a Remote Server&quot;
        return

    if LOCAL_HOST is None:
        print &quot;There doesn't appear to be a Local Server&quot;
        return

    print &quot;LOCAL_HOST=&quot;,LOCAL_HOST
    print &quot;REMOTE_HOST=&quot;,REMOTE_HOST

    r_cursor = self.GetCursor(REMOTE_HOST)
    if r_cursor is None:
        print &quot;Couldn't get a cursor for %s&quot;%REMOTE_HOST
        return

    l_cursor = self.GetCursor(LOCAL_HOST)
    if l_cursor is None:
        print &quot;Couldn't get a cursor for %s&quot;%LOCAL_HOST
        return

    # moving the sync time back a second to make sure that we don't lose track of any nodes
    #that are being updated or inserted at the same time as we are syncing
    r_cursor.execute(&quot;SELECT NOW()&quot;)
    l_now = mx.DateTime.now()-mx.DateTime.oneSecond
    r_now = r_cursor.fetchone()[0]-mx.DateTime.oneSecond
    #because of some inconsistent rounding appears necessary to make sure the sqlite timestamp is less than l_now
    #having seen same issue for mysql but for consistency (and because sqlite could also be &quot;server&quot; rdbms
    l_ts = l_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    r_ts = r_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    print &quot;l_now=&quot;,l_now, &quot;l_ts =&quot;,l_ts
    print &quot;r_now=&quot;,r_now, &quot;r_ts=&quot;,r_ts

    r_cursor.execute(&quot;SELECT MAX(last_sync) FROM user_sync WHERE user = %s&quot;, (USER,))
    r_last_sync = r_cursor.fetchone()[0]
    print &quot;last sync (remote time) =&quot;,r_last_sync

    l_cursor.execute(&quot;SELECT MAX(last_sync) FROM user_sync&quot;)
    l_last_sync = l_cursor.fetchone()[0] #note MAX returns a string with sqlite so we turn it make into DateTime
    l_last_sync = mx.DateTime.DateTimeFrom(l_last_sync)
    print &quot;last sync (local time) =&quot;,l_last_sync

    for table in SYNC_TABLES:
        # Need to pick up changes for both so syncing one doesn't add new things and screw up the second sync
        print &quot;Checking &quot;+table+&quot; on the Remote Server; changes (excluding deletes) are:&quot;
        r_cursor.execute(&quot;SELECT id,createdate from &quot;+table+&quot; WHERE timestamp &gt; %s AND timestamp &lt;= %s&quot;,(r_last_sync,r_now)) 
        r_results = r_cursor.fetchall()
        print &quot;Server changes (excluding deletes)&quot;
        print r_results

        print &quot;Checking &quot;+table+&quot; on Local; changes (excluding deletes) are:&quot;
        l_cursor.execute(&quot;SELECT id,createdate from &quot;+table+&quot; WHERE timestamp &gt; %s AND timestamp &lt;= %s&quot;,(l_last_sync,l_now))
        l_results = l_cursor.fetchall()
        print &quot;Local changes (excluding deletes)&quot;
        print l_results

        for id, createdate in r_results:
            r_cursor.execute(&quot;SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM &quot;+table+&quot; WHERE ID = %s&quot;,(id,))
            row = r_cursor.fetchone()
            if row:
                if createdate &gt; r_last_sync:
                    l_cursor.execute(&quot;INSERT INTO &quot;+table+&quot; (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;, row) #*row also works
                    print &quot;Created %s in %s on Local&quot;%(id,table)
                else:
                    l_cursor.execute(&quot;UPDATE &quot;+table+&quot; SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s&quot;, row)
                    print &quot;Updated %s in %s on Local&quot;%(id,table)
                # for reasons I don't understand l_now here is a 1/100 ahead of l_now when inserted into user_sync
                l_cursor.execute(&quot;UPDATE &quot;+table+&quot; SET timestamp = %s WHERE id = %s&quot;, (l_ts,id))

        for id, createdate in l_results:
            l_cursor.execute(&quot;SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM &quot;+table+&quot; WHERE ID = %s&quot;,(id,))
            row = l_cursor.fetchone()
            if row:
                row = tuple(row)
                #above needed because sqlite returns an enhanced tuple-like object that is not a tuple
                if createdate &gt; l_last_sync:
                    r_cursor.execute(&quot;INSERT INTO &quot;+table+&quot; (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&quot;, row)
                    print &quot;Created %s in %s on Server&quot;%(id,table)
                else:
                    r_cursor.execute(&quot;UPDATE &quot;+table+&quot; SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s&quot;, row)
                    print &quot;Updated %s in %s on Server&quot;%(id,table)
                r_cursor.execute(&quot;UPDATE &quot;+table+&quot; SET timestamp = %s WHERE id = %s&quot;, (r_ts,id))

    #Handle the deletes; Note if at some point only 'd's are being written won't have to check for 'd'
    r_cursor.execute(&quot;SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'&quot;,(r_last_sync,r_now))
    r_results = r_cursor.fetchall()

    l_cursor.execute(&quot;SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'&quot;,(l_last_sync,l_now))
    l_results = l_cursor.fetchall()

    for id,table in l_results:
        r_cursor.execute(&quot;DELETE from &quot;+table+&quot; WHERE id = %s&quot;, (id,))
        print &quot;Deleted %s from %s on Server (if it existed there)&quot;%(id,table)

    for id,table in r_results:
        l_cursor.execute(&quot;DELETE from &quot;+table+&quot; WHERE id = %s&quot;, (id,))
        print &quot;Deleted %s from %s on Local (if it existed there)&quot;%(id,table)    
    #End of deletes code

    #update the user_sync database with the latest sync times
    l_cursor.execute(&quot;INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)&quot;, (USER,l_now)) #don't really need USER for local
    r_cursor.execute(&quot;INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)&quot;, (USER,r_now)) 

    print &quot;Synchronization completed&quot;
</pre>
</div>
<div class="section" id="timestamper">
<h4><a class="toc-backref" href="#id123" name="timestamper">TimeStamper</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def TimeStamper(self, host, cursor, table, id):
    #note that you can insert a timestamp value into an mysql timestamp field
    if host.split(':')[1] == 'sqlite': #host -&gt; location:rdbms
        timestamp = mx.DateTime.now()
        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET timestamp = %s WHERE id = %s&quot;, (timestamp,id))
    else:
        cursor.execute(&quot;Select timestamp from &quot;+table+&quot; WHERE id = %s&quot;, (id,))
        timestamp = cursor.fetchone()[0]

    return timestamp
</pre>
</div>
</div>
<div class="section" id="evaluate-methods">
<h3><a class="toc-backref" href="#id124" name="evaluate-methods">Evaluate methods</a></h3>
<div class="section" id="onshowevaluate">
<h4><a class="toc-backref" href="#id125" name="onshowevaluate">OnShowEvaluate</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowEvaluate(self, evt=None):

    self.EvalDialog.Show(True)
    self.EvalDialog.EvalText.SetSelection(-1,-1)
    self.EvalDialog.EvalText.SetFocus()
</pre>
</div>
<div class="section" id="onevaluate">
<h4><a class="toc-backref" href="#id126" name="onevaluate">OnEvaluate</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnEvaluate(self, evt=None):
    expr = self.EvalDialog.EvalText.GetValue()
    print &quot;%s =&gt; &quot;%expr,
    print eval(expr)
</pre>
</div>
</div>
<div class="section" id="help-menu-methods">
<h3><a class="toc-backref" href="#id127" name="help-menu-methods">Help menu methods</a></h3>
<div class="section" id="onshowabout">
<h4><a class="toc-backref" href="#id128" name="onshowabout">OnShowAbout</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowAbout(self, evt=None):
    from about import AboutBox
    dlg = AboutBox(self, app_version = VERSION)
    dlg.ShowModal()
    dlg.Destroy()
</pre>
</div>
<div class="section" id="onshowhelp">
<h4><a class="toc-backref" href="#id129" name="onshowhelp">OnShowHelp</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnShowHelp(self, evt=None):
    os.startfile('ListManager.chm')
</pre>
</div>
</div>
<div class="section" id="getuid">
<h3><a class="toc-backref" href="#id130" name="getuid">GetUID</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def GetUID(self):
    pyiid = CreateGuid()
    # the str(pyiid) looks like {....} and doing [1:-1] strips that off
    return str(pyiid)[1:-1]
</pre>
</div>
<div class="section" id="onidle">
<h3><a class="toc-backref" href="#id131" name="onidle">OnIdle</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnIdle(self, evt):  
    &lt;&lt; Check for Transfers From Outlook &gt;&gt;
    &lt;&lt; Check if Edited File has Changed &gt;&gt;
</pre>
<p>First thing, when are idle events triggered? --&gt; in wxPython they occur after there are no more events to process in the event queue.  So when things are happening rapidly (such as mouse movement) you actually see more idle events and when nothing at all is happening, you don't see any.  This is pretty counterintuitive initially since you would think that idle events should happen when things are truly idle.</p>
<div class="section" id="check-for-transfers-from-outlook">
<h4><a class="toc-backref" href="#id132" name="check-for-transfers-from-outlook">&lt;&lt; Check for Transfers From Outlook &gt;&gt;</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
if OUTLOOK:
    input,output,exc = select.select([self.sock],[],[],0)
    if input:
        client,addr = self.sock.accept() # Get a connection
        rec = client.recv(8192)
        d = pickle.loads(rec)

        class Item: pass

        item = Item()
        item.id = self.GetUID()
        item.priority = 1
        item.createdate = mx.DateTime.now()
        item.duedate = item.finisheddate = None

        #outlook strings are unicode; ascii encode makes sure no chars above 127
        name = d['Subject'].encode('ascii','replace') 
        item.name = name[:150]

        owner = d['SenderName'].encode('ascii','replace') #encode takes unicode to standard strings
        owner = owner[:25]
        item.owners = [owner]

        note = d['CreationTime'] + '\n' + d['Body'].encode('ascii','replace')
        #foldername = d['Parent.Name']

        #location, rdbms, table = MAIL_LIST_PATH.split(':')
        #host = '%s:%s'%(location,rdbms)
        host, table = re.split('(.*?:.*?):', MAIL_LIST_PATH)[1:3] #really just for fun

        cursor = self.Cursors[host]

        cursor.execute(&quot;INSERT INTO &quot;+table+&quot; (priority,name,createdate,finisheddate,duedate,owner1,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)&quot;,
            (item.priority, name, item.createdate, item.finisheddate, item.duedate, owner, note, item.id))

        item.timestamp = self.TimeStamper(host, cursor, table, item.id)

        #check to see if table is open
        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table and Properties['host'] == host:
                break
        else:
            print &quot;Table not open but wrote to database anyway&quot; #Needs to be a dialog box
            return

        # could have started to edit something and never finished it
        if self.modified:
            self.OnUpdate()

        if self.L != L:
            self.nb.SetSelection(L) # Note that this does not call OnPageChange if the page doesn't change

        LCtrl = self.ListCtrls[L]

        if self.curIdx != -1:
            LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)

        self.ItemLists[L].insert(0,item)    
        LCtrl.InsertImageStringItem(0,&quot;1&quot;, LCtrl.idx1)
        LCtrl.SetStringItem(0,self.attr2col_num['name'],name)
        LCtrl.SetStringItem(0, self.attr2col_num['owners'], owner)

        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))
        elif Properties['LCdate'] == 'createdate':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0
</pre>
<p>The select statement always confused me a bit so I'll come back to this to provide some more documentation of what is going on here.</p>
<p>The emails identified in Outlook are moved to ListManager through a socket connection.  There is a separate Outlook addin that allows the user to highlight an Outlook email message and click on a button in the Outlook toolbar to move the message into ListManager.  I find that many tasks originate or are documented in an email and this makes it very convenient to move those items from Outlook into ListManager without any retyping.</p>
</div>
<div class="section" id="check-if-edited-file-has-changed">
<h4><a class="toc-backref" href="#id133" name="check-if-edited-file-has-changed">&lt;&lt; Check if Edited File has Changed &gt;&gt;</a></h4>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
for ed in self.editor:
    path = ed['path']
    t = os.path.getmtime(path)
    if t != ed['time']:
        f = file(path,'r')
        note = f.read()
        f.close()
        ed['time'] = t

        host = ed['host']
        cursor = self.Cursors[host]
        table = ed['table']
        id = ed['id']
        cursor.execute(&quot;UPDATE &quot;+table+&quot; SET note = %s WHERE id = %s&quot;, (note,id)) 
        # see &#64;rst documentation note
        ts = self.TimeStamper(host, cursor, table, id)

        idx = self.curIdx
        L = self.L
        if idx != -1:
            item = self.ItemLists[L][idx]
            if item.id == id:
                self.note.SetValue(note)
                item.timestamp = ts

                if self.PropertyDicts[L]['LCdate'] == 'timestamp':
                    self.ListCtrls[L].SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format(&quot;%m/%d %H:%M:%S&quot;))

                if 'note' in self.modified: #if necessary only if somehow note text didn't change
                    del self.modified['note']
</pre>
<p>This section in the OnIdle method checks to see if there are any open editors that have had a change in data in a manner that is similar to the code in Leo that works with the Leo Open With menu item.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>After the line:</p>
<pre class="literal-block">
cursor.execute(&quot;UPDATE &quot;+table+&quot; SET note = %s WHERE id = %s&quot;, (note,id))
</pre>
<p>normally the next line would be:</p>
<pre class="literal-block">
item.timestamp = self.TimeStamper(host, cursor, table, id)
</pre>
<p class="last">however, this is actually a bit tricky since by the time the editor is closed the user may be on a different notebook page and you'd have to go from id --&gt; self.ItemLists[L][idx] to update the display so it didn't seem like it was worth the effort.  This means that the display timestamp doesn't automatically update when the external editor is closed but will update if the display is refreshed.</p>
</div>
</div>
</div>
</div>
<div class="section" id="class-listctrl">
<h2><a class="toc-backref" href="#id134" name="class-listctrl">class ListCtrl</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class ListCtrl(wxListCtrl, wxListCtrlAutoWidthMixin):
    &#64;others
</pre>
<div class="section" id="init">
<h3><a class="toc-backref" href="#id135" name="init">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, ID, pos=wxDefaultPosition, size=wxDefaultSize, style=0):
    wxListCtrl.__init__(self, parent, ID, pos, size, style)
    wxListCtrlAutoWidthMixin.__init__(self)

    self.il = wxImageList(16,16)

    sm_up = self.il.Add(wxBitmap('bitmaps\\up_arrow.bmp')) #(images.getSmallUpArrowBitmap())
    sm_dn = self.il.Add(wxBitmap('bitmaps\\down_arrow.bmp'))
    self.arrows = (sm_up,sm_dn)

    self.idx1 = self.il.Add(wxBitmap('bitmaps\\box.bmp'))
    self.idx0 = self.il.Add(wxBitmap('bitmaps\\filledwhitebox.bmp'))    

    self.SetImageList(self.il, wxIMAGE_LIST_SMALL)

    EVT_LIST_COL_BEGIN_DRAG(self, self.GetId(), self.OnColBeginDrag)    

    self.SetUpColumns()
</pre>
</div>
<div class="section" id="setupcolumns">
<h3><a class="toc-backref" href="#id136" name="setupcolumns">SetUpColumns</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def SetUpColumns(self):
    #Need to to construct column heads for columns with sorting by hand to get sorting images on columns
    info = wxListItem()
    info.m_mask = wxLIST_MASK_TEXT | wxLIST_MASK_IMAGE | wxLIST_MASK_FORMAT
    info.m_image = -1

    #Oth column is priority which is sortable
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = &quot;P&quot;
    self.InsertColumnInfo(0, info)
    self.SetColumnWidth(0, 35)

    self.InsertColumn(1, &quot;Name&quot;)
    self.SetColumnWidth(1, 590)

    self.InsertColumn(2, &quot;Owner&quot;)
    self.SetColumnWidth(2, 100)

    #3th column is create ate and same as with priority - needs to constructed by hand
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = &quot;Due Date&quot;
    self.InsertColumnInfo(3, info)
    self.SetColumnWidth(3, 75)
</pre>
</div>
<div class="section" id="oncolbegindrag">
<h3><a class="toc-backref" href="#id137" name="oncolbegindrag">OnColBeginDrag</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnColBeginDrag(self, evt):
    #if inplace editor then change its dimensions
    if evt.GetColumn() == 0:
        evt.Veto()
</pre>
</div>
</div>
<div class="section" id="class-myapp">
<h2><a class="toc-backref" href="#id138" name="class-myapp">class MyApp</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class MyApp(wxApp):
    &#64;others
</pre>
<div class="section" id="oninit">
<h3><a class="toc-backref" href="#id139" name="oninit">OnInit</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnInit(self):
    global OFFLINE_ONLY, CANCEL
    wxInitAllImageHandlers()

    if STARTUP_DIALOG:
        startup = StartupDialog(None, 'List Manager')
        val = startup.ShowModal()
        startup.Destroy()
        if val == wxID_YES:
            OFFLINE_ONLY = True
        elif val == wxID_NO:
            OFFLINE_ONLY = False
        elif val == wxID_CANCEL:
            CANCEL = True
            return True

    if OFFLINE_ONLY is False:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, &quot;Cannot connect to remote server! Only offline access is possible.&quot;, &quot;ListManager&quot;, style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    frame = ListManager(None, -1, &quot;List Manager&quot;, size = (X,Y))
    frame.Show(True)
    self.SetTopWindow(frame)
    CANCEL = False
    return True
</pre>
</div>
</div>
<div class="section" id="class-logger">
<h2><a class="toc-backref" href="#id140" name="class-logger">class Logger</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class Logger:
    def __init__(self):
        self.dlg = LoggerDialog(None, &quot;&quot;, &quot;Alerts and Exceptions&quot;, dir=DIRECTORY)
    def write(self, error_msg):
        if not self.dlg.IsShown():
            self.dlg.text.AppendText(&quot;\n%s\n&quot;%time.asctime())
            self.dlg.Show(True)

        self.dlg.text.AppendText(error_msg)
</pre>
</div>
<div class="section" id="run">
<h2><a class="toc-backref" href="#id141" name="run">run</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def run():
    app = MyApp(0)
    if not CANCEL:
        sys.stderr = sys.stdout = Logger()
        app.MainLoop()

if __name__ == '__main__':
    run()
</pre>
</div>
</div>
<div class="section" id="lmdialogs-py">
<h1><a class="toc-backref" href="#id142" name="lmdialogs-py">LMDialogs.py</a></h1>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
&#64;language python
from wxPython.wx import *
# the following two are needed for the calendar
from wxPython.calendar import *
from wxPython.utils import *
import os
&#64;others
</pre>
<div class="section" id="class-popdialog">
<h2><a class="toc-backref" href="#id143" name="class-popdialog">class PopDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class TicklerDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id144" name="id5">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, msg, caption, pos = wxDefaultPosition, size = wxDefaultSize):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP | wxTHICK_FRAME | wxCAPTION)

    TC = wxTextCtrl(self, -1, msg, wxDefaultPosition,
                    (450,250),
                    wxTE_MULTILINE | wxTE_READONLY | wxTE_RICH2)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        

    sizer.Add(TC, 1, wxALIGN_CENTRE|wxALL, 5)
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)

    sizer.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    btn = wxButton(self, wxID_OK, &quot;GO TO ITEM&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_FORWARD, &quot;SHOW NEXT&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_APPLY, &quot;MAIL&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    EVT_LEFT_DOWN(TC, self.OnLeftDown)
    EVT_BUTTON(self, wxID_FORWARD, self.OnForward)
    EVT_BUTTON(self, wxID_APPLY, self.OnMail)

    TC.SetCursor(wxStockCursor(wxCURSOR_ARROW))        

    self.TC = TC
</pre>
</div>
<div class="section" id="onleftdown">
<h3><a class="toc-backref" href="#id145" name="onleftdown">OnLeftDown</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnLeftDown(self, evt):
    self.EndModal(wxID_OK)
</pre>
</div>
<div class="section" id="onforward">
<h3><a class="toc-backref" href="#id146" name="onforward">OnForward</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnForward(self, evt):
    self.EndModal(wxID_FORWARD)
</pre>
</div>
<div class="section" id="onmail">
<h3><a class="toc-backref" href="#id147" name="onmail">OnMail</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnMail(self, evt):
    self.EndModal(wxID_APPLY)
</pre>
</div>
</div>
<div class="section" id="class-startupdialog">
<h2><a class="toc-backref" href="#id148" name="class-startupdialog">class StartupDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class StartupDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id149" name="id6">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,115)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    msg = &quot;You can connect to the server using the network,\nor work offline, or cancel this logon.&quot;

    image = wxStaticBitmap(self, -1, wxBitmap('bitmaps\\wxpdemo.bmp'), (-1,-1), size=(32,32)) #sizer determines position
    text = wxStaticText(self, -1, msg, (-1,-1), size=(250,32)) #sizer determines position

    rect = wxBoxSizer(wxHORIZONTAL)
    rect.Add(image, 0, wxALIGN_LEFT|wxALL, 4)
    rect.Add(text, 1, wxALIGN_CENTER|wxTOP, 7)
    sizer = wxBoxSizer(wxVERTICAL)


    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_NO, 'Connect')
    box.Add(btn, 0, wxALL, 10)
    btn.SetDefault()

    btn = wxButton(self, wxID_YES, 'Work Offline')
    box.Add(btn, 0, wxALL, 10)

    btn = wxButton(self, wxID_CANCEL, 'Cancel')
    box.Add(btn, 0, wxALL, 10)

    sizer.AddSizer(rect)
    sizer.AddSizer(box)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_NO, self.OnSelection)
    EVT_BUTTON(self, wxID_YES, self.OnSelection)
    EVT_BUTTON(self, wxID_CANCEL, self.OnSelection)
</pre>
</div>
<div class="section" id="onselection">
<h3><a class="toc-backref" href="#id150" name="onselection">OnSelection</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnSelection(self,evt):
    val = evt.GetId()
    self.EndModal(val)
</pre>
</div>
</div>
<div class="section" id="class-modifierdialog">
<h2><a class="toc-backref" href="#id151" name="class-modifierdialog">class ModifierDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class ModifierDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id152" name="id7">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             modifierlist=None,
             curselections = ''):
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)

    tc = wxTextCtrl(self, -1, &quot;&quot;, size = (150,-1))
    sizer1.Add(tc, 0, wxALIGN_CENTRE|wxALL, 5)
    self.tc = tc

    if not modifierlist:
        modifierlist = []
    lb = wxListBox(self, -1,  wxDefaultPosition, (150,300), #wxPoint(90, 80)
                    modifierlist, wxLB_MULTIPLE|wxLB_SORT)

    sizer1.Add(lb, 1, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)


    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)

    for sel in curselections:
        index = lb.FindString(sel)
        if index !=-1:
            lb.SetSelection(index)

    self.lb = lb

    EVT_BUTTON(self, wxID_CANCEL, self.ClearSelections)
</pre>
</div>
<div class="section" id="getuserinput">
<h3><a class="toc-backref" href="#id153" name="getuserinput">GetUserInput</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def GetUserInput(self):
    idx_list = self.lb.GetSelections()
    mod_list =[]
    for i in idx_list:
        mod_list.append(self.lb.GetString(i))
        self.lb.Deselect(i) #071203

    new_list = []
    manual_string = self.tc.GetValue() #text entry box

    if manual_string:
        manual_list = [x.strip() for x in manual_string.split(';')]
        for name in manual_list:
            clean_name = &quot;, &quot;.join([x.strip().title() for x in name.split(',')])
            if clean_name not in mod_list:
                mod_list.append(clean_name)
                new_list.append(clean_name)


    return (mod_list, new_list)
</pre>
</div>
<div class="section" id="selectcurrent">
<h3><a class="toc-backref" href="#id154" name="selectcurrent">SelectCurrent</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def SelectCurrent(self, cur_sel):
    for sel in cur_sel:
        index = self.lb.FindString(sel)
        if index !=-1:
            self.lb.SetSelection(index)
</pre>
</div>
<div class="section" id="clearselections">
<h3><a class="toc-backref" href="#id155" name="clearselections">ClearSelections</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def ClearSelections(self, evt=None):
    idx_list = self.lb.GetSelections() #note you can't just use the indexes of the SelectCurrent since they may have clicked before cancelling
    for i in idx_list:
        self.lb.Deselect(i)

    evt.Skip()
</pre>
</div>
</div>
<div class="section" id="class-maildialog">
<h2><a class="toc-backref" href="#id156" name="class-maildialog">class MailDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class MailDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id157" name="id8">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxSTAY_ON_TOP| wxTHICK_FRAME|wxCAPTION|wxSYSTEM_MENU,
             recipients='',
             subject = '',
             body = ''):

    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)

    recipients = &quot;; &quot;.join(recipients)
    label = wxStaticText(self, -1, &quot;To:&quot;,wxDefaultPosition, size=(40,-1), style=wxALIGN_LEFT)
    RTC = wxTextCtrl(self, -1, recipients, size = (480,-1))
    box.Add(label)
    box.Add(RTC)

    #sizer.Add(10,10,0)      

    sizer.AddSizer(box)        

    box = wxBoxSizer(wxHORIZONTAL)       
    label = wxStaticText(self, -1, &quot;Subject:&quot;,wxDefaultPosition, size=(40,-1),style=wxALIGN_LEFT)
    STC = wxTextCtrl(self, -1, subject, size = (480,-1)) 
    box.Add(label)
    box.Add(STC)

    sizer.AddSizer(box)
    sizer.Add(1, 5, 0)

    BTC = wxTextCtrl(self, -1, body, wxDefaultPosition, size = (500,400), style=wxTE_MULTILINE|wxTE_RICH2)

    sizer.Add(BTC)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, &quot;SEND MAIL&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.RTC = RTC
    self.STC = STC
    self.BTC = BTC
</pre>
</div>
</div>
<div class="section" id="class-calendardialog">
<h2><a class="toc-backref" href="#id158" name="class-calendardialog">class CalendarDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class CalendarDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id159" name="id9">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             date=0):

    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    if not date:
        date = wxDateTime_Now()

    cal = wxCalendarCtrl(self, -1, date, #pos = (25,50),
                         style = wxCAL_SHOW_HOLIDAYS | wxCAL_SUNDAY_FIRST)

    EVT_CALENDAR(self, cal.GetId(), self.OnCalSelected)

    #EVT_CLOSE(self, self.OnCloseWindow)          

    self.cal = cal

    # Set up control to display a set of holidays:
    EVT_CALENDAR_MONTH(self, cal.GetId(), self.OnChangeMonth)

    self.holidays = [(1,1), (10,31), (12,25) ]    # (these don't move around)

    self.OnChangeMonth()        

#-------------------------------------------------------------------------        
    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)

    sizer1.Add(cal, 0, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxRIGHT|wxTOP, 5)


    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    #btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)
</pre>
</div>
<div class="section" id="oncalselected">
<h3><a class="toc-backref" href="#id160" name="oncalselected">OnCalSelected</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCalSelected(self, evt):
    self.result = evt.GetDate()
    self.EndModal(wxID_OK)
</pre>
</div>
<div class="section" id="onchangemonth">
<h3><a class="toc-backref" href="#id161" name="onchangemonth">OnChangeMonth</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnChangeMonth(self, evt=None):
    cur_month = self.cal.GetDate().GetMonth() + 1   # convert wxDateTime 0-11 =&gt; 1-12
    for month, day in self.holidays:
        if month == cur_month:
            self.cal.SetHoliday(day)
</pre>
</div>
<div class="section" id="onclosewindow">
<h3><a class="toc-backref" href="#id162" name="onclosewindow">OnCloseWindow</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCloseWindow(self, event):
    #self.cal.Destroy
    #self.Destroy()
    print &quot;I got to close window&quot;
</pre>
</div>
<div class="section" id="getdate">
<h3><a class="toc-backref" href="#id163" name="getdate">GetDate</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def GetDate(self):
    return self.result
</pre>
</div>
</div>
<div class="section" id="class-finddialog">
<h2><a class="toc-backref" href="#id164" name="class-finddialog">class FindDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class FindDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id165" name="id10">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,120)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    self.FindText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))

    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(self.FindText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.MatchCase = wxCheckBox(self, -1, &quot;Match Case&quot;)
    self.MatchWhole = wxCheckBox(self, -1, &quot;Match Whole Word&quot;)
    box_c = wxBoxSizer(wxVERTICAL)
    box_c.Add(self.MatchCase, 0, wxLEFT|wxBOTTOM, 5)
    box_c.Add(self.MatchWhole, 0, wxLEFT, 5)

    self.SearchNotes = wxCheckBox(self, -1, &quot;Search Notes&quot;)
    self.SearchFinished = wxCheckBox(self, -1, &quot;Search Finished&quot;)
    box_d = wxBoxSizer(wxVERTICAL)
    box_d.Add(self.SearchNotes, 0, wxLEFT|wxBOTTOM, 5)
    box_d.Add(self.SearchFinished, 0, wxLEFT, 5)

    box_e = wxBoxSizer(wxHORIZONTAL)
    box_e.AddSizer(box_c)
    box_e.AddSizer(box_d)

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.AddSizer(box_a)
    sizer.AddSizer(box_e)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_OK, parent.FindString)
</pre>
</div>
</div>
<div class="section" id="class-evaldialog">
<h2><a class="toc-backref" href="#id166" name="class-evaldialog">class EvalDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class EvalDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id167" name="id11">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,80)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    EvalText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))


    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(EvalText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.SetSizer(box_a)

    self.EvalText = EvalText
    self.parent = parent

    #EVT_BUTTON(self, wxID_OK, self.PostOKEvent)
    EVT_BUTTON(self, wxID_OK, parent.OnEvaluate)
</pre>
</div>
<div class="section" id="postokevent">
<h3><a class="toc-backref" href="#id168" name="postokevent">PostOKEvent</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def PostOKEvent(self, evt=None):
    wxPostEvent(self.parent, evt)
</pre>
</div>
</div>
<div class="section" id="class-loggerdialog">
<h2><a class="toc-backref" href="#id169" name="class-loggerdialog">class LoggerDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class LoggerDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id170" name="id12">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, msg, caption, pos=(-1,-1), size=(500,300), dir=None):
    wxDialog.__init__(self, parent, -1, caption, pos, size)
    #if pos == (-1,-1):
        #self.CenterOnScreen(wxBOTH)

    if dir:
        self.dir = dir
    else:
        self.dir = os.getcwd()

    text = wxTextCtrl(self, -1, msg, (-1,-1), (450,250), wxTE_MULTILINE | wxTE_READONLY)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        

    sizer.Add(text, 1, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_OK, &quot;Close&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    ID_SAVE = wxNewId()

    btn = wxButton(self, ID_SAVE, &quot;Save to File&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.text = text

    EVT_BUTTON(self, ID_SAVE, self.OnSave)
</pre>
</div>
<div class="section" id="onsave">
<h3><a class="toc-backref" href="#id171" name="onsave">OnSave</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnSave(self, evt):

    path = os.path.join(self.dir, 'logfile.txt')

    f = file(path,'a')
    f.write(self.text.GetValue())
    f.close()

    dlg = wxMessageDialog(self,&quot;Appended text to logfile.text&quot;, &quot;Notice&quot;, wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
    dlg.Destroy()

    self.text.Clear()
</pre>
</div>
</div>
<div class="section" id="class-finisheddialog">
<h2><a class="toc-backref" href="#id172" name="class-finisheddialog">class FinishedDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class FinishedDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id173" name="id13">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, title,
            pos=wxDefaultPosition,
            size=wxDefaultSize,
            style=wxCAPTION,
            days=0,
            spin_label=&quot;&quot;,
            check_label=&quot;&quot;):

    wxDialog.__init__(self, parent, -1, title, pos, size)
    self.Centre()

    self.check = wxCheckBox(self, -1, check_label)

    if days == -1:
        self.check.SetValue(True)
        days = 0

    panel = wxPanel(self, -1, (-1,-1),(225,75))
    wxStaticText(panel, -1, spin_label,(15, 15))
    self.text = wxTextCtrl(panel, -1, str(days), (30, 50), (30, -1))
    h = self.text.GetSize().height
    self.spin = wxSpinButton(panel, -1, (56, 50), (h, h), wxSP_VERTICAL)
    wxStaticText(panel, -1, 'days',(76, 53))
    self.spin.SetRange(0, 14)
    self.spin.SetValue(days)

    H_sizer = wxBoxSizer(wxHORIZONTAL)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)

    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    V_sizer = wxBoxSizer(wxVERTICAL)
    V_sizer.Add(panel,1,wxALIGN_CENTER|wxEXPAND)
    V_sizer.Add(-1,5)
    V_sizer.Add(self.check,0,wxALIGN_LEFT|wxALL,5)
    V_sizer.Add(line,0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    V_sizer.AddSizer(H_sizer, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)

    self.SetSizer(V_sizer)
    self.SetAutoLayout(True)
    V_sizer.Fit(self)

    EVT_SPIN(self, self.spin.GetId(), self.OnSpin)
    EVT_CHECKBOX(self, self.check.GetId(), self.OnCheck)

    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)

    self.Layout() #doesn't appear necessary
</pre>
</div>
<div class="section" id="onspin">
<h3><a class="toc-backref" href="#id174" name="onspin">OnSpin</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnSpin(self, evt):
    self.text.SetValue(str(evt.GetPosition()))
</pre>
</div>
<div class="section" id="oncheck">
<h3><a class="toc-backref" href="#id175" name="oncheck">OnCheck</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnCheck(self, evt=None):
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
    else:
        self.spin.Enable(True)
        self.text.Enable(True)
</pre>
</div>
</div>
<div class="section" id="class-treedialog">
<h2><a class="toc-backref" href="#id176" name="class-treedialog">class TreeDialog</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class TreeDialog(wxDialog):
    &#64;others
</pre>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id177" name="id14">__init__</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,400), tree={}):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    TreeCtrl = wxTreeCtrl(self, -1, wxDefaultPosition, (300,400), wxTR_HAS_BUTTONS)    #|wxTR_HIDE_ROOT)#wxDefaultSize,

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.Add(TreeCtrl, 1, wxALIGN_CENTER|wxALL, 5)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, &quot;OK&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, &quot;CANCEL&quot;)
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetAutoLayout(1)
    self.SetSizer(sizer)

    il = wxImageList(16,16)

    fldridx = il.Add(wxBitmap('bitmaps\\folder.bmp'))
    fldropenidx = il.Add(wxBitmap('bitmaps\\folder_open.bmp'))
    listidx =  il.Add(wxBitmap('bitmaps\\list.bmp'))

    TreeCtrl.SetImageList(il)

    root = TreeCtrl.AddRoot(&quot;List Manager&quot;)
    TreeCtrl.SetItemImage(root, fldridx, wxTreeItemIcon_Normal)
    TreeCtrl.SetItemImage(root, fldropenidx, wxTreeItemIcon_Expanded)

    for host in tree:
        child = TreeCtrl.AppendItem(root, host)
        TreeCtrl.SetItemImage(child, fldridx, wxTreeItemIcon_Normal)
        TreeCtrl.SetItemImage(child, fldropenidx, wxTreeItemIcon_Expanded)
        for listname in tree[host]:
            last = TreeCtrl.AppendItem(child, listname)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Normal)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Selected)

    TreeCtrl.Expand(root)

    self.TreeCtrl= TreeCtrl
    self.il = il #? prevents GC

    EVT_LEFT_DCLICK(TreeCtrl, self.OnLeftDClick)
</pre>
</div>
<div class="section" id="onleftdclick">
<h3><a class="toc-backref" href="#id178" name="onleftdclick">OnLeftDClick:</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnLeftDClick(self, event=None):
    self.EndModal(wxID_OK)
</pre>
</div>
</div>
</div>
<div class="section" id="outlookaddin-py">
<h1><a class="toc-backref" href="#id179" name="outlookaddin-py">outlookAddin.py</a></h1>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
&#64;language python
&lt;&lt; outlookAddin declarations &gt;&gt;
&#64;others

if __name__ == '__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(OutlookAddin)
    if &quot;--unregister&quot; in sys.argv:
        UnregisterAddin(OutlookAddin)
    else:
        RegisterAddin(OutlookAddin)
</pre>
<div class="section" id="outlookaddin-declarations">
<h2><a class="toc-backref" href="#id180" name="outlookaddin-declarations">&lt;&lt; outlookAddin declarations &gt;&gt;</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
# This is mainly stolen from Mark Hammond's demo plugin for win32com.client
# A demo plugin for Microsoft Outlook (NOT Outlook Express)

from win32com import universal
from win32com.server.exception import COMException
from win32com.client import gencache, DispatchWithEvents
from win32com.client import Dispatch
import winerror
import pythoncom
from win32com.client import constants
import win32ui ##
import sys
from socket import *
import pickle

# Support for COM objects we use.
#sz comment gencache.EnsureModule makes sure you are using makepy if the makepy-derived
#file doesn't already exist
#but as long as you did run makepy then you should just be alble to do a normal dispatch

mod = gencache.EnsureModule('{00062FFF-0000-0000-C000-000000000046}', 0, 9, 0, bForDemand=True) # Outlook 9
gencache.EnsureModule('{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}', 0, 2, 1, bForDemand=True) # Office 9

# The TLB defining the interfaces we implement
universal.RegisterInterfaces('{AC0714F2-3D04-11D1-AE7D-00A0C90F26F4}', 0, 1, 0, [&quot;_IDTExtensibility2&quot;])

Target = 'mail_transfer'
</pre>
</div>
<div class="section" id="class-buttonevent">
<h2><a class="toc-backref" href="#id181" name="class-buttonevent">class ButtonEvent</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class ButtonEvent:
    &#64;others
</pre>
<div class="section" id="onclick">
<h3><a class="toc-backref" href="#id182" name="onclick">OnClick</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnClick(self, button, cancel):
    #activeExplorer and MailTransferFolder are globals defined in OnConnection
    sel = activeExplorer.Selection

    for i in range(1,sel.Count+1):
        item = sel.Item(i)
        item.Move(MailTransferFolder)

    return cancel
</pre>
</div>
</div>
<div class="section" id="class-folderevent">
<h2><a class="toc-backref" href="#id183" name="class-folderevent">class FolderEvent</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class FolderEvent:
    &#64;others
</pre>
<div class="section" id="onitemadd">
<h3><a class="toc-backref" href="#id184" name="onitemadd">OnItemAdd</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnItemAdd(self, item):
    try:
        s = socket(AF_INET,SOCK_STREAM)
        s.connect(('localhost', 8888))
        d = {}
        d['Parent.Name'] = item.Parent.Name
        d['SenderName'] = item.SenderName
        d['Subject'] = item.Subject
        d['Body'] = item.Body[:5000]
        d['CreationTime'] = item.CreationTime.Format()
        str = pickle.dumps(d)
        s.send(str) # ?Receive no more than 1024 bytes
        s.close()
        win32ui.MessageBox(&quot;Sent %s to ListManager&quot;%item.Subject)
    except:
        pass
</pre>
</div>
</div>
<div class="section" id="class-outlookaddin">
<h2><a class="toc-backref" href="#id185" name="class-outlookaddin">class OutlookAddin</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
class OutlookAddin:
    &lt;&lt; class OutlookAddin declarations &gt;&gt;
    &#64;others
</pre>
<div class="section" id="class-outlookaddin-declarations">
<h3><a class="toc-backref" href="#id186" name="class-outlookaddin-declarations">&lt;&lt; class OutlookAddin declarations &gt;&gt;</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
_com_interfaces_ = ['_IDTExtensibility2']
_public_methods_ = []
_reg_clsctx_ = pythoncom.CLSCTX_INPROC_SERVER
_reg_clsid_ = &quot;{0F47D9F3-598B-4d24-B7E3-92AC15ED27E2}&quot;
_reg_progid_ = &quot;Python.Test.OutlookAddin&quot;
_reg_policy_spec_ = &quot;win32com.server.policy.EventHandlerPolicy&quot;
</pre>
</div>
<div class="section" id="onconnection">
<h3><a class="toc-backref" href="#id187" name="onconnection">OnConnection</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnConnection(self, application, connectMode, addin, custom):
    global MailTransferFolder
    global activeExplorer
    # ActiveExplorer may be none when started without a UI (eg, WinCE synchronisation)
    activeExplorer = application.ActiveExplorer()
    if activeExplorer:
        bars = activeExplorer.CommandBars
        toolbar = bars.Item(&quot;Standard&quot;)
        item = toolbar.Controls.Add(Type=constants.msoControlButton, Temporary=True)
        item = self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #? just need this to be an ivar
        item.Caption=&quot;List Manager&quot;
        item.TooltipText = &quot;Click to move&quot;
        item.Enabled = True
        #self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #need something that won't get GC'd. Note Dispatch returns item

    ns = application.GetNamespace(&quot;MAPI&quot;)
    Folders = ns.Folders

    for i in range(1,len(Folders)+1):
        if Folders[i].Name.find(&quot;Mailbox&quot;) != -1:
            folders = Folders[i].Folders
            break
    else:
        win32ui.MessageBox(&quot;Can't find Mailbox!&quot;)
        return  

    for i in range(1,len(folders)+1):
        if folders[i].Name == Target:
            MailTransferFolder = folders[i]
            self.targetMailbox = DispatchWithEvents(folders[i].Items, FolderEvent) #? just need this to be an ivar
            win32ui.MessageBox(&quot;Enabled: %s\nOutlookAddin3&quot;%Target)
            break
    else:
        win32ui.MessageBox(&quot;Could not find mail folder: %s\nOutlookAddin3&quot;%Target)
</pre>
</div>
<div class="section" id="ondisconnection">
<h3><a class="toc-backref" href="#id188" name="ondisconnection">OnDisconnection</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnDisconnection(self, mode, custom):
    print &quot;OnDisconnection&quot;
</pre>
</div>
<div class="section" id="onaddinsupdate">
<h3><a class="toc-backref" href="#id189" name="onaddinsupdate">OnAddInsUpdate</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnAddInsUpdate(self, custom):
    print &quot;OnAddInsUpdate&quot;, custom
</pre>
</div>
<div class="section" id="onstartupcomplete">
<h3><a class="toc-backref" href="#id190" name="onstartupcomplete">OnStartupComplete</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnStartupComplete(self, custom):
    print &quot;OnStartupComplete&quot;, custom
</pre>
</div>
<div class="section" id="onbeginshutdown">
<h3><a class="toc-backref" href="#id191" name="onbeginshutdown">OnBeginShutdown</a></h3>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def OnBeginShutdown(self, custom):
    print &quot;OnBeginShutdown&quot;, custom
</pre>
</div>
</div>
<div class="section" id="registeraddin">
<h2><a class="toc-backref" href="#id192" name="registeraddin">RegisterAddin</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def RegisterAddin(klass):
    import _winreg
    key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER, &quot;Software\\Microsoft\\Office\\Outlook\\Addins&quot;)
    subkey = _winreg.CreateKey(key, klass._reg_progid_)
    _winreg.SetValueEx(subkey, &quot;CommandLineSafe&quot;, 0, _winreg.REG_DWORD, 0)
    _winreg.SetValueEx(subkey, &quot;LoadBehavior&quot;, 0, _winreg.REG_DWORD, 3)
    _winreg.SetValueEx(subkey, &quot;Description&quot;, 0, _winreg.REG_SZ, klass._reg_progid_)
    _winreg.SetValueEx(subkey, &quot;FriendlyName&quot;, 0, _winreg.REG_SZ, klass._reg_progid_)
</pre>
</div>
<div class="section" id="unregisteraddin">
<h2><a class="toc-backref" href="#id193" name="unregisteraddin">UnregisterAddin</a></h2>
<p><strong>code</strong>:</p>
<!--  -->
<pre class="code literal-block">
def UnregisterAddin(klass):
    import _winreg
    try:
        _winreg.DeleteKey(_winreg.HKEY_CURRENT_USER, &quot;Software\\Microsoft\\Office\\Outlook\\Addins\\&quot; + klass._reg_progid_)
    except WindowsError:
        pass
</pre>
</div>
</div>
</div>
</body>
</html>
