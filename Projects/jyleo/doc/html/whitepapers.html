<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/07/09 14:03:05 $
:version: $Revision: 1.1 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}
  
@import url(leo_rst.css);
@import url(silver_city.css);


</style>
</head>
<body>
<div class="document">
<!-- rst3: filename: html\whitepapers.html -->
<!-- August 30, 2005 -->
<p><a class="reference" href="theory.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="plugins.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-11-white-papers">
<h1><a class="toc-backref" href="#id1" name="chapter-11-white-papers">Chapter 11: White Papers</a></h1>
<p>The following are some papers I wrote just after discovering Python.
The conclusions in these papers have remained largely unchanged.</p>
<div class="contents topic" id="contents">
<p class="topic-title first"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#chapter-11-white-papers" id="id1" name="id1">Chapter 11: White Papers</a><ul>
<li><a class="reference" href="#tk-is-the-future-of-leo" id="id2" name="id2">Tk is the future of Leo</a></li>
<li><a class="reference" href="#why-i-like-python" id="id3" name="id3">Why I like Python</a><ul>
<li><a class="reference" href="#clarity" id="id4" name="id4">Clarity</a></li>
<li><a class="reference" href="#power" id="id5" name="id5">Power</a></li>
<li><a class="reference" href="#safety" id="id6" name="id6">Safety</a></li>
<li><a class="reference" href="#speed" id="id7" name="id7">Speed</a></li>
<li><a class="reference" href="#conclusions" id="id8" name="id8">Conclusions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="tk-is-the-future-of-leo">
<h2><a class="toc-backref" href="#id2" name="tk-is-the-future-of-leo">Tk is the future of Leo</a></h2>
<p>The more I look at Tk, the more convinced I am that Python + Tk (aka Tkinter)
is, by far, the best way to go with Leo. I now have Open Source code for tree
widgets and splitter windows, and have intensely studied how to modify that code
for use in Leo. It is clear, even at this early date, that this code will
provide a very pleasant base on which to build Leo.</p>
<p>The tree code is based on code in <tt class="docutils literal"><span class="pre">IDLE</span></tt>, the Python IDE. This code is simple,
good and plenty fast enough. The tree code draws directly to a Tk canvas object.
The look and feel matches Windows exactly. It would be trivial to use Mac
triangle icons instead of the Windows plus and minus icons. It would also be
trivial to modify the look and feel for Linux.</p>
<p>The tree widget code solves several intractable problems with <tt class="docutils literal"><span class="pre">wxTreeCtrl</span></tt>.
Moving nodes becomes trivial. Bugs in <tt class="docutils literal"><span class="pre">wxTreeCtrl</span></tt> involving editing and
redrawing disappear. Using Python/Tk code simplifies the vnode class, and having
access to the vnode class simplifies and speeds up the tree widget code. It will
now be possible to bind keystrokes properly; this simply can not be done in
<tt class="docutils literal"><span class="pre">wxWindows</span></tt>. The tree widget code shows just how trivial the Windows native
tree control is. The Tk canvas is a splendid example of higher-level code being
superior, in every way, to lower level code.</p>
<p>Another big win comes from using the Tk text widget. This widget is
extraordinarily powerful. The only text control that rivals it is the
<tt class="docutils literal"><span class="pre">MacOS/Yellow</span> <span class="pre">Box</span></tt> text control. Indeed, the Tk text widget does everything that
Leo could possibly want. One can even embed images in text.</p>
<p>In short, using Tk for Leo will be fast enough and will greatly increase what is
possible in Leo while at the same time greatly simplifying Leo's code. I am
about to convert Leo from wxPython to Python + Tk.
Edward K. Ream, November 4, 2001</p>
</div>
<div class="section" id="why-i-like-python">
<h2><a class="toc-backref" href="#id3" name="why-i-like-python">Why I like Python</a></h2>
<p>I've known for a while that Python was interesting; I attended a Python
conference last year and added Python support to Leo. But last week I got that
Python is something truly remarkable. I wanted to convert Leo from wxWindows to
wxPython, so I began work on c2py, a Python script that would help convert from
C++ syntax to Python. While doing so, I had an Aha experience. Python is more
than an incremental improvement over Smalltalk or C++ or objective-C; it is
&quot;something completely different&quot;. The rest of this post tries to explain this
difference.</p>
<div class="section" id="clarity">
<h3><a class="toc-backref" href="#id4" name="clarity">Clarity</a></h3>
<p>What struck me first as I converted C++ code to Python is how much less blah,
blah, blah there is in Python. No braces, no stupid semicolons and most
importantly, <em>no declarations</em>. No more pointless distinctions between
<tt class="docutils literal"><span class="pre">const</span></tt>, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">wxString</span></tt>.
No more wondering whether a variable should be <tt class="docutils literal"><span class="pre">signed</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> or <tt class="docutils literal"><span class="pre">long</span></tt>.</p>
<p>Declarations add clutter, declarations are never obviously right and
declarations don't prevent memory allocation tragedies. Declarations also hinder
prototyping. In C++, if I change the type of something I must change all related
declarations; this can be a huge and dangerous task. With Python, I can change
the type of an object without changing the code at all! It's no accident that
Leo's new log pane was created first in Python.</p>
<p>Functions returning tuples are a &quot;minor&quot; feature with a huge impact on code
clarity. No more passing pointers to data, no more defining (and allocating and
deallocating) temporary structs to hold multiple values.</p>
<p>Python can't check declarations because there aren't any. However, there is a
really nifty tool called Pychecker that does many of the checks typically done
by compilers. See <a class="reference" href="http://pychecker.sourceforge.net/">pychecker</a> for details.</p>
</div>
<div class="section" id="power">
<h3><a class="toc-backref" href="#id5" name="power">Power</a></h3>
<p>Python is much more powerful than C++, not because Python has more features, but
because Python needs <em>less</em> features. Some examples:</p>
<ul class="simple">
<li>Python does everything that the C++ Standard Template Library (STL) does,
without any of the blah, blah, blah needed by STL.
No fuss, no muss, no code bloat.</li>
<li>Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).
Python's string library does more with far less functions because slices replace many functions
typically found in other string libraries.</li>
<li>Writing dict = {} creates a dictionary (hash table).
Hash tables can contain anything, including lists and other hash tables.</li>
<li>Python's special functions,  <tt class="docutils literal"><span class="pre">__init__</span></tt>, <tt class="docutils literal"><span class="pre">__del__</span></tt>, <tt class="docutils literal"><span class="pre">__repr__</span></tt>, <tt class="docutils literal"><span class="pre">__cmp__</span></tt>, etc.
are an elegant way to handle any special need that might arise.</li>
</ul>
</div>
<div class="section" id="safety">
<h3><a class="toc-backref" href="#id6" name="safety">Safety</a></h3>
<p>Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.
Try doing:</p>
<pre class="literal-block">
aList[i:j] = list(aString)
</pre>
<p>in C.  You will write about 20 lines of C code.
Any error in this code will create a memory allocation crash or leak.</p>
<p>Python is fundamentally safe. C++ is fundamentally unsafe. When I am using
Python I am free from worry and anxiety. When I am using C++ I must be
constantly &quot;on guard.&quot; A momentary lapse can create a hard-to-find pointer bug.
With Python, almost nothing serious can ever go wrong, so I can work late at
night, or after a beer. The Python debugger is always available. If an exception
occurs, the debugger/interpreter tells me just what went wrong. I don't have to
plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can
keep right on going even after a crash!</p>
</div>
<div class="section" id="speed">
<h3><a class="toc-backref" href="#id7" name="speed">Speed</a></h3>
<p>Python has almost all the speed of C. Other interpretive environments such as
icon and Smalltalk have clarity, power and safety similar to Python. What makes
Python unique is its seamless way of making C code look like Python code.
Python executes at essentially the speed of C code because most Python modules
are written in C. The overhead in calling such modules is negligible. Moreover,
if code is too slow, one can always create a C module to do the job.</p>
<p>In fact, Python encourages optimization by moving to higher levels of
expression. For example, Leo's Open command reads an XML file. If this command
is too slow I can use Python's XML parser module. This will speed up Leo while
at the same time raising the level of the code.</p>
</div>
<div class="section" id="conclusions">
<h3><a class="toc-backref" href="#id8" name="conclusions">Conclusions</a></h3>
<p>Little of Python is completely new. What stands out is the superb engineering
judgment evident in Python's design. Python is extremely powerful, yet small,
simple and elegant. Python allows me to express my intentions clearly and at the
highest possible level.</p>
<p>The only hope of making Leo all it can be is to use the best possible tools. I
believe Python (possibly with Tkinter) will allow me to add, at long last, the
new features that Leo should have.</p>
<p>Edward K. Ream, October 25, 2001.  P.S., September, 2005:</p>
<p>Four years of experience have only added to my admiration for Python. Leo could
not possible be what it is today without Python.</p>
<hr class="docutils" />
<p><a class="reference reference" href="theory.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference reference" href="plugins.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</div>
</body>
</html>
