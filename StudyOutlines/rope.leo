<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="362" height="938" width="875"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20080516155317.1" str_leo_pos="2,0"><vh>Startup</vh>
<v t="ekr.20080516150804.1"><vh>@chapters</vh></v>
</v>
<v t="ekr.20080516150804.2232"><vh>rope-0.8.2\ropetest</vh>
<v t="ekr.20080516150804.2233"><vh>ropetest\advanced_oi_test.py</vh>
<v t="ekr.20080516150804.2234"><vh>advanced_oi_test declarations</vh></v>
<v t="ekr.20080516150804.2235"><vh>class DynamicOITest</vh>
<v t="ekr.20080516150804.2236"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2237"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2238"><vh>test_simple_dti</vh></v>
<v t="ekr.20080516150804.2239"><vh>test_module_dti</vh></v>
<v t="ekr.20080516150804.2240"><vh>test_class_from_another_module_dti</vh></v>
<v t="ekr.20080516150804.2241"><vh>test_class_dti</vh></v>
<v t="ekr.20080516150804.2242"><vh>test_instance_dti</vh></v>
<v t="ekr.20080516150804.2243"><vh>test_method_dti</vh></v>
<v t="ekr.20080516150804.2244"><vh>test_function_argument_dti</vh></v>
<v t="ekr.20080516150804.2245"><vh>test_classes_with_the_same_name</vh></v>
<v t="ekr.20080516150804.2246"><vh>test_nested_classes</vh></v>
<v t="ekr.20080516150804.2247"><vh>test_function_argument_dti2</vh></v>
<v t="ekr.20080516150804.2248"><vh>test_dti_and_concluded_data_invalidation</vh></v>
<v t="ekr.20080516150804.2249"><vh>test_list_objects_and_dynamicoi</vh></v>
<v t="ekr.20080516150804.2250"><vh>test_for_loops_and_dynamicoi</vh></v>
<v t="ekr.20080516150804.2251"><vh>test_dict_objects_and_dynamicoi</vh></v>
<v t="ekr.20080516150804.2252"><vh>test_dict_keys_and_dynamicoi</vh></v>
<v t="ekr.20080516150804.2253"><vh>test_dict_keys_and_dynamicoi2</vh></v>
<v t="ekr.20080516150804.2254"><vh>test_strs_and_dynamicoi</vh></v>
<v t="ekr.20080516150804.2255"><vh>test_textual_transformations</vh></v>
<v t="ekr.20080516150804.2256"><vh>test_arguments_with_keywords</vh></v>
<v t="ekr.20080516150804.2257"><vh>test_a_function_with_different_returns</vh></v>
<v t="ekr.20080516150804.2258"><vh>test_a_function_with_different_returns2</vh></v>
<v t="ekr.20080516150804.2259"><vh>test_ignoring_star_args</vh></v>
<v t="ekr.20080516150804.2260"><vh>test_ignoring_double_star_args</vh></v>
<v t="ekr.20080516150804.2261"><vh>test_invalidating_data_after_changing</vh></v>
<v t="ekr.20080516150804.2262"><vh>test_invalidating_data_after_moving</vh></v>
</v>
<v t="ekr.20080516150804.2263"><vh>class NewStaticOITest</vh>
<v t="ekr.20080516150804.2264"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2265"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2266"><vh>test_static_oi_for_simple_function_calls</vh></v>
<v t="ekr.20080516150804.2267"><vh>test_static_oi_not_failing_when_callin_callables</vh></v>
<v t="ekr.20080516150804.2268"><vh>test_static_oi_for_nested_calls</vh></v>
<v t="ekr.20080516150804.2269"><vh>test_static_oi_class_methods</vh></v>
<v t="ekr.20080516150804.2270"><vh>test_static_oi_preventing_soi_maximum_recursion_exceptions</vh></v>
<v t="ekr.20080516150804.2271"><vh>test_static_oi_for_infering_returned_types_from_functions_based_on_parameters</vh></v>
<v t="ekr.20080516150804.2272"><vh>test_a_function_with_different_returns</vh></v>
<v t="ekr.20080516150804.2273"><vh>test_not_reporting_out_of_date_information</vh></v>
<v t="ekr.20080516150804.2274"><vh>test_invalidating_concluded_data_in_a_function</vh></v>
<v t="ekr.20080516150804.2275"><vh>test_handling_generator_functions_for_strs</vh></v>
<v t="ekr.20080516150804.2276"><vh>xxx_test_handling_generator_functions_when_unknown_type_is_yielded</vh></v>
<v t="ekr.20080516150804.2277"><vh>test_static_oi_for_lists_depending_on_append_function</vh></v>
<v t="ekr.20080516150804.2278"><vh>test_static_oi_for_lists_per_object_for_get_item</vh></v>
<v t="ekr.20080516150804.2279"><vh>test_static_oi_for_lists_per_object_for_fields</vh></v>
<v t="ekr.20080516150804.2280"><vh>test_static_oi_for_lists_per_object_for_set_item</vh></v>
<v t="ekr.20080516150804.2281"><vh>test_static_oi_for_lists_per_object_for_extending_lists</vh></v>
<v t="ekr.20080516150804.2282"><vh>test_static_oi_for_lists_per_object_for_iters</vh></v>
<v t="ekr.20080516150804.2283"><vh>test_static_oi_for_dicts_depending_on_append_function</vh></v>
<v t="ekr.20080516150804.2284"><vh>test_static_oi_for_dicts_depending_on_for_loops</vh></v>
<v t="ekr.20080516150804.2285"><vh>test_static_oi_for_dicts_depending_on_update</vh></v>
<v t="ekr.20080516150804.2286"><vh>test_static_oi_for_dicts_depending_on_update_on_seqs</vh></v>
<v t="ekr.20080516150804.2287"><vh>test_static_oi_for_sets_per_object_for_set_item</vh></v>
<v t="ekr.20080516150804.2288"><vh>test_properties_and_calling_get_property</vh></v>
<v t="ekr.20080516150804.2289"><vh>test_soi_on_constructors</vh></v>
<v t="ekr.20080516150804.2290"><vh>test_not_saving_unknown_function_returns</vh></v>
<v t="ekr.20080516150804.2291"><vh>test_using_the_best_callinfo</vh></v>
<v t="ekr.20080516150804.2292"><vh>test_call_function_and_parameters</vh></v>
<v t="ekr.20080516150804.2293"><vh>test_report_change_in_libutils</vh></v>
<v t="ekr.20080516150804.2294"><vh>test_report_libutils_and_analyze_all_modules</vh></v>
<v t="ekr.20080516150804.2295"><vh>test_validation_problems_for_objectdb_retrievals</vh></v>
<v t="ekr.20080516150804.2296"><vh>test_validation_problems_for_changing_builtin_types</vh></v>
<v t="ekr.20080516150804.2297"><vh>test_always_returning_containing_class_for_selfs</vh></v>
<v t="ekr.20080516150804.2298"><vh>test_following_function_calls_when_asked_to</vh></v>
</v>
<v t="ekr.20080516150804.2299"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2300"><vh>ropetest\builtinstest.py</vh>
<v t="ekr.20080516150804.2301"><vh>builtinstest declarations</vh></v>
<v t="ekr.20080516150804.2302"><vh>class BuiltinTypesTest</vh>
<v t="ekr.20080516150804.2303"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2304"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2305"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.2306"><vh>test_holding_type_information</vh></v>
<v t="ekr.20080516150804.2307"><vh>test_get_items</vh></v>
<v t="ekr.20080516150804.2308"><vh>test_get_items_for_lists</vh></v>
<v t="ekr.20080516150804.2309"><vh>test_get_items_from_slices</vh></v>
<v t="ekr.20080516150804.2310"><vh>test_simple_for_loops</vh></v>
<v t="ekr.20080516150804.2311"><vh>test_definition_location_for_loop_variables</vh></v>
<v t="ekr.20080516150804.2312"><vh>test_simple_case_for_dicts</vh></v>
<v t="ekr.20080516150804.2313"><vh>test_get_item_for_dicts</vh></v>
<v t="ekr.20080516150804.2314"><vh>test_popping_dicts</vh></v>
<v t="ekr.20080516150804.2315"><vh>test_getting_keys_from_dicts</vh></v>
<v t="ekr.20080516150804.2316"><vh>test_getting_values_from_dicts</vh></v>
<v t="ekr.20080516150804.2317"><vh>test_getting_iterkeys_from_dicts</vh></v>
<v t="ekr.20080516150804.2318"><vh>test_getting_itervalues_from_dicts</vh></v>
<v t="ekr.20080516150804.2319"><vh>test_using_copy_for_dicts</vh></v>
<v t="ekr.20080516150804.2320"><vh>test_tuple_assignments_for_items</vh></v>
<v t="ekr.20080516150804.2321"><vh>test_tuple_assignment_for_lists</vh></v>
<v t="ekr.20080516150804.2322"><vh>test_tuple_assignments_for_iteritems_in_fors</vh></v>
<v t="ekr.20080516150804.2323"><vh>test_simple_tuple_assignments</vh></v>
<v t="ekr.20080516150804.2324"><vh>test_overriding_builtin_names</vh></v>
<v t="ekr.20080516150804.2325"><vh>test_simple_builtin_scope_test</vh></v>
<v t="ekr.20080516150804.2326"><vh>test_simple_sets</vh></v>
<v t="ekr.20080516150804.2327"><vh>test_making_lists_using_the_passed_argument_to_init</vh></v>
<v t="ekr.20080516150804.2328"><vh>test_making_tuples_using_the_passed_argument_to_init</vh></v>
<v t="ekr.20080516150804.2329"><vh>test_making_sets_using_the_passed_argument_to_init</vh></v>
<v t="ekr.20080516150804.2330"><vh>test_making_dicts_using_the_passed_argument_to_init</vh></v>
<v t="ekr.20080516150804.2331"><vh>test_range_builtin_function</vh></v>
<v t="ekr.20080516150804.2332"><vh>test_reversed_builtin_function</vh></v>
<v t="ekr.20080516150804.2333"><vh>test_sorted_builtin_function</vh></v>
<v t="ekr.20080516150804.2334"><vh>test_super_builtin_function</vh></v>
<v t="ekr.20080516150804.2335"><vh>test_file_builtin_type</vh></v>
<v t="ekr.20080516150804.2336"><vh>test_property_builtin_type</vh></v>
<v t="ekr.20080516150804.2337"><vh>test_lambda_functions</vh></v>
<v t="ekr.20080516150804.2338"><vh>test_lambdas_that_return_unknown</vh></v>
<v t="ekr.20080516150804.2339"><vh>test_builtin_zip_function</vh></v>
<v t="ekr.20080516150804.2340"><vh>test_builtin_zip_function_with_more_than_two_args</vh></v>
<v t="ekr.20080516150804.2341"><vh>test_wrong_arguments_to_zip_function</vh></v>
<v t="ekr.20080516150804.2342"><vh>test_enumerate_builtin_function</vh></v>
<v t="ekr.20080516150804.2343"><vh>test_builtin_class_get_name</vh></v>
<v t="ekr.20080516150804.2344"><vh>test_star_args_and_double_star_args</vh></v>
<v t="ekr.20080516150804.2345"><vh>test_simple_list_comprehension_test</vh></v>
<v t="ekr.20080516150804.2346"><vh>test_simple_list_generator_expression</vh></v>
<v t="ekr.20080516150804.2347"><vh>test_iter_builtin_function</vh></v>
<v t="ekr.20080516150804.2348"><vh>test_simple_int_type</vh></v>
<v t="ekr.20080516150804.2349"><vh>test_simple_float_type</vh></v>
<v t="ekr.20080516150804.2350"><vh>test_simple_float_type2</vh></v>
<v t="ekr.20080516150804.2351"><vh>test_simple_complex_type</vh></v>
<v t="ekr.20080516150804.2352"><vh>test_handling_unaryop_on_ints</vh></v>
<v t="ekr.20080516150804.2353"><vh>test_handling_binop_on_ints</vh></v>
<v t="ekr.20080516150804.2354"><vh>test_handling_compares</vh></v>
<v t="ekr.20080516150804.2355"><vh>test_handling_boolops</vh></v>
</v>
<v t="ekr.20080516150804.2356"><vh>class BuiltinModulesTest</vh>
<v t="ekr.20080516150804.2357"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2358"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2359"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.2360"><vh>test_ignored_extensions</vh></v>
<v t="ekr.20080516150804.2361"><vh>test_ignored_extensions</vh></v>
<v t="ekr.20080516150804.2362"><vh>test_nonexistent_modules</vh></v>
</v>
<v t="ekr.20080516150804.2363"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2364"><vh>ropetest\codeanalyzetest.py</vh>
<v t="ekr.20080516150804.2365"><vh>codeanalyzetest declarations</vh></v>
<v t="ekr.20080516150804.2366"><vh>class SourceLinesAdapterTest</vh>
<v t="ekr.20080516150804.2367"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2368"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2369"><vh>test_source_lines_simple</vh></v>
<v t="ekr.20080516150804.2370"><vh>test_source_lines_get_line_number</vh></v>
<v t="ekr.20080516150804.2371"><vh>test_source_lines_get_line_start</vh></v>
<v t="ekr.20080516150804.2372"><vh>test_source_lines_get_line_end</vh></v>
<v t="ekr.20080516150804.2373"><vh>test_source_lines_last_line_with_no_new_line</vh></v>
</v>
<v t="ekr.20080516150804.2374"><vh>class WordRangeFinderTest</vh>
<v t="ekr.20080516150804.2375"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2376"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2377"><vh>_find_primary</vh></v>
<v t="ekr.20080516150804.2378"><vh>test_inside_parans</vh></v>
<v t="ekr.20080516150804.2379"><vh>test_simple_names</vh></v>
<v t="ekr.20080516150804.2380"><vh>test_function_calls</vh></v>
<v t="ekr.20080516150804.2381"><vh>test_attribute_accesses</vh></v>
<v t="ekr.20080516150804.2382"><vh>test_word_finder_on_word_beginning</vh></v>
<v t="ekr.20080516150804.2383"><vh>test_word_finder_on_primary_beginning</vh></v>
<v t="ekr.20080516150804.2384"><vh>test_word_finder_on_word_ending</vh></v>
<v t="ekr.20080516150804.2385"><vh>test_word_finder_on_primary_ending</vh></v>
<v t="ekr.20080516150804.2386"><vh>test_word_finder_on_primaries_with_dots_inside_parens</vh></v>
<v t="ekr.20080516150804.2387"><vh>test_strings</vh></v>
<v t="ekr.20080516150804.2388"><vh>test_function_calls2</vh></v>
<v t="ekr.20080516150804.2389"><vh>test_parens</vh></v>
<v t="ekr.20080516150804.2390"><vh>test_function_with_no_param</vh></v>
<v t="ekr.20080516150804.2391"><vh>test_function_with_multiple_param</vh></v>
<v t="ekr.20080516150804.2392"><vh>test_param_expressions</vh></v>
<v t="ekr.20080516150804.2393"><vh>test_string_parens</vh></v>
<v t="ekr.20080516150804.2394"><vh>test_extra_spaces</vh></v>
<v t="ekr.20080516150804.2395"><vh>test_functions_on_ending_parens</vh></v>
<v t="ekr.20080516150804.2396"><vh>test_splitted_statement</vh></v>
<v t="ekr.20080516150804.2397"><vh>test_empty_splitted_statement</vh></v>
<v t="ekr.20080516150804.2398"><vh>test_empty_splitted_statement2</vh></v>
<v t="ekr.20080516150804.2399"><vh>test_empty_splitted_statement3</vh></v>
<v t="ekr.20080516150804.2400"><vh>test_empty_splitted_statement4</vh></v>
<v t="ekr.20080516150804.2401"><vh>test_empty_splitted_statement5</vh></v>
<v t="ekr.20080516150804.2402"><vh>test_operators_inside_parens</vh></v>
<v t="ekr.20080516150804.2403"><vh>test_dictionaries</vh></v>
<v t="ekr.20080516150804.2404"><vh>test_following_parens</vh></v>
<v t="ekr.20080516150804.2405"><vh>test_comments_for_finding_statements</vh></v>
<v t="ekr.20080516150804.2406"><vh>test_str_in_comments_for_finding_statements</vh></v>
<v t="ekr.20080516150804.2407"><vh>test_comments_for_finding_statements2</vh></v>
<v t="ekr.20080516150804.2408"><vh>test_comments_for_finding_statements3</vh></v>
<v t="ekr.20080516150804.2409"><vh>test_import_statement_finding</vh></v>
<v t="ekr.20080516150804.2410"><vh>test_import_statement_finding2</vh></v>
<v t="ekr.20080516150804.2411"><vh>test_word_parens_range</vh></v>
<v t="ekr.20080516150804.2412"><vh>test_getting_primary_before_get_index</vh></v>
<v t="ekr.20080516150804.2413"><vh>test_getting_primary_and_strings_at_the_end_of_line</vh></v>
<v t="ekr.20080516150804.2414"><vh>test_getting_primary_and_not_crossing_newlines</vh></v>
<v t="ekr.20080516150804.2415"><vh>xxx_test_getting_primary_cancatenating_strs</vh></v>
<v t="ekr.20080516150804.2416"><vh>test_is_a_function_being_called_with_parens_on_next_line</vh></v>
<v t="ekr.20080516150804.2417"><vh>xxx_test_triple_quotes</vh></v>
<v t="ekr.20080516150804.2418"><vh>test_triple_quotes_spanning_multiple_lines</vh></v>
<v t="ekr.20080516150804.2419"><vh>test_get_word_parens_range_and_string_literals</vh></v>
<v t="ekr.20080516150804.2420"><vh>test_is_assigned_here_for_equality_test</vh></v>
<v t="ekr.20080516150804.2421"><vh>xxx_test_is_assigned_here_for_tuple_assignment</vh></v>
<v t="ekr.20080516150804.2422"><vh>test_is_from_with_from_import_and_multiline_parens</vh></v>
<v t="ekr.20080516150804.2423"><vh>test_is_from_with_from_import_and_line_breaks_in_the_middle</vh></v>
<v t="ekr.20080516150804.2424"><vh>test_one_letter_function_keyword_arguments</vh></v>
<v t="ekr.20080516150804.2425"><vh>test_find_parens_start</vh></v>
<v t="ekr.20080516150804.2426"><vh>test_find_parens_start_with_multiple_entries</vh></v>
<v t="ekr.20080516150804.2427"><vh>test_find_parens_start_with_nested_parens</vh></v>
<v t="ekr.20080516150804.2428"><vh>test_find_parens_start_with_parens_in_strs</vh></v>
<v t="ekr.20080516150804.2429"><vh>test_find_parens_start_with_parens_in_strs_in_multiple_lines</vh></v>
<v t="ekr.20080516150804.2430"><vh>test_is_on_function_keyword</vh></v>
</v>
<v t="ekr.20080516150804.2431"><vh>class ScopeNameFinderTest</vh>
<v t="ekr.20080516150804.2432"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2433"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2434"><vh>xxx_test_global_name_in_class_body</vh></v>
<v t="ekr.20080516150804.2435"><vh>test_class_variable_attribute_in_class_body</vh></v>
<v t="ekr.20080516150804.2436"><vh>test_class_variable_attribute_in_class_body2</vh></v>
<v t="ekr.20080516150804.2437"><vh>test_class_method_attribute_in_class_body</vh></v>
<v t="ekr.20080516150804.2438"><vh>test_inner_class_attribute_in_class_body</vh></v>
<v t="ekr.20080516150804.2439"><vh>test_class_method_in_class_body_but_not_indexed</vh></v>
<v t="ekr.20080516150804.2440"><vh>test_function_but_not_indexed</vh></v>
<v t="ekr.20080516150804.2441"><vh>test_modules_after_from_statements</vh></v>
<v t="ekr.20080516150804.2442"><vh>test_renaming_functions_with_from_import_and_parens</vh></v>
<v t="ekr.20080516150804.2443"><vh>test_relative_modules_after_from_statements</vh></v>
<v t="ekr.20080516150804.2444"><vh>test_relative_modules_after_from_statements2</vh></v>
<v t="ekr.20080516150804.2445"><vh>test_get_pyname_at_on_language_keywords</vh></v>
<v t="ekr.20080516150804.2446"><vh>test_one_liners</vh></v>
<v t="ekr.20080516150804.2447"><vh>test_one_liners_with_line_breaks</vh></v>
<v t="ekr.20080516150804.2448"><vh>test_one_liners_with_line_breaks2</vh></v>
</v>
<v t="ekr.20080516150804.2449"><vh>class LogicalLineFinderTest</vh>
<v t="ekr.20080516150804.2450"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2451"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2452"><vh>_logical_finder</vh></v>
<v t="ekr.20080516150804.2453"><vh>test_normal_lines</vh></v>
<v t="ekr.20080516150804.2454"><vh>test_normal_lines2</vh></v>
<v t="ekr.20080516150804.2455"><vh>test_implicit_continuation</vh></v>
<v t="ekr.20080516150804.2456"><vh>test_explicit_continuation</vh></v>
<v t="ekr.20080516150804.2457"><vh>test_explicit_continuation_comments</vh></v>
<v t="ekr.20080516150804.2458"><vh>test_multiple_indented_ifs</vh></v>
<v t="ekr.20080516150804.2459"><vh>test_list_comprehensions_and_fors</vh></v>
<v t="ekr.20080516150804.2460"><vh>test_generator_expressions_and_fors</vh></v>
<v t="ekr.20080516150804.2461"><vh>test_fors_and_block_start</vh></v>
<v t="ekr.20080516150804.2462"><vh>test_problems_with_inner_indentations</vh></v>
<v t="ekr.20080516150804.2463"><vh>test_problems_with_inner_indentations2</vh></v>
<v t="ekr.20080516150804.2464"><vh>test_logical_lines_for_else</vh></v>
<v t="ekr.20080516150804.2465"><vh>test_logical_lines_for_lines_with_wrong_continues</vh></v>
<v t="ekr.20080516150804.2466"><vh>test_generating_line_starts</vh></v>
<v t="ekr.20080516150804.2467"><vh>test_generating_line_starts2</vh></v>
<v t="ekr.20080516150804.2468"><vh>test_generating_line_starts3</vh></v>
<v t="ekr.20080516150804.2469"><vh>test_generating_line_starts_for_multi_line_statements</vh></v>
<v t="ekr.20080516150804.2470"><vh>test_generating_line_starts_and_unmatched_deindents</vh></v>
</v>
<v t="ekr.20080516150804.2471"><vh>class TokenizerLogicalLineFinderTest</vh>
<v t="ekr.20080516150804.2472"><vh>_logical_finder</vh></v>
</v>
<v t="ekr.20080516150804.2473"><vh>class CustomLogicalLineFinderTest</vh>
<v t="ekr.20080516150804.2474"><vh>_logical_finder</vh></v>
</v>
<v t="ekr.20080516150804.2475"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2476"><vh>ropetest\historytest.py</vh>
<v t="ekr.20080516150804.2477"><vh>historytest declarations</vh></v>
<v t="ekr.20080516150804.2478"><vh>class HistoryTest</vh>
<v t="ekr.20080516150804.2479"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2480"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2481"><vh>test_undoing_writes</vh></v>
<v t="ekr.20080516150804.2482"><vh>test_moving_files</vh></v>
<v t="ekr.20080516150804.2483"><vh>test_moving_files_to_folders</vh></v>
<v t="ekr.20080516150804.2484"><vh>test_writing_files_that_does_not_change_contents</vh></v>
</v>
<v t="ekr.20080516150804.2485"><vh>class IsolatedHistoryTest</vh>
<v t="ekr.20080516150804.2486"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2487"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2488"><vh>test_simple_undo</vh></v>
<v t="ekr.20080516150804.2489"><vh>test_tobe_undone</vh></v>
<v t="ekr.20080516150804.2490"><vh>test_tobe_redone</vh></v>
<v t="ekr.20080516150804.2491"><vh>test_undo_limit</vh></v>
<v t="ekr.20080516150804.2492"><vh>test_simple_redo</vh></v>
<v t="ekr.20080516150804.2493"><vh>test_simple_re_undo</vh></v>
<v t="ekr.20080516150804.2494"><vh>test_multiple_undos</vh></v>
<v t="ekr.20080516150804.2495"><vh>test_undo_list_underflow</vh></v>
<v t="ekr.20080516150804.2496"><vh>test_redo_list_underflow</vh></v>
<v t="ekr.20080516150804.2497"><vh>test_undoing_choosen_changes</vh></v>
<v t="ekr.20080516150804.2498"><vh>test_undoing_choosen_changes2</vh></v>
<v t="ekr.20080516150804.2499"><vh>test_undoing_choosen_changes_not_undoing_others</vh></v>
<v t="ekr.20080516150804.2500"><vh>test_undoing_writing_after_moving</vh></v>
<v t="ekr.20080516150804.2501"><vh>test_undoing_folder_movements_for_undoing_writes_inside_it</vh></v>
<v t="ekr.20080516150804.2502"><vh>test_undoing_changes_that_depend_on_a_dependant_change</vh></v>
<v t="ekr.20080516150804.2503"><vh>test_undoing_writes_for_undoing_folder_movements_containing_it</vh></v>
<v t="ekr.20080516150804.2504"><vh>test_undoing_not_available_change</vh></v>
<v t="ekr.20080516150804.2505"><vh>test_ignoring_ignored_resources</vh></v>
<v t="ekr.20080516150804.2506"><vh>test_get_file_undo_list_simple</vh></v>
<v t="ekr.20080516150804.2507"><vh>test_get_file_undo_list_for_moves</vh></v>
<v t="ekr.20080516150804.2508"><vh>xxx_test_get_file_undo_list_and_moving_its_contining_folder</vh></v>
<v t="ekr.20080516150804.2509"><vh>test_clearing_redo_list_after_do</vh></v>
<v t="ekr.20080516150804.2510"><vh>test_undoing_a_not_yet_performed_change</vh></v>
<v t="ekr.20080516150804.2511"><vh>test_clearing_up_the_history</vh></v>
<v t="ekr.20080516150804.2512"><vh>test_redoing_choosen_changes_not_undoing_others</vh></v>
</v>
<v t="ekr.20080516150804.2513"><vh>class SavingHistoryTest</vh>
<v t="ekr.20080516150804.2514"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2515"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2516"><vh>test_simple_set_saving</vh></v>
<v t="ekr.20080516150804.2517"><vh>test_simple_change_content_saving</vh></v>
<v t="ekr.20080516150804.2518"><vh>test_move_resource_saving</vh></v>
<v t="ekr.20080516150804.2519"><vh>test_move_resource_saving_for_folders</vh></v>
<v t="ekr.20080516150804.2520"><vh>test_create_file_saving</vh></v>
<v t="ekr.20080516150804.2521"><vh>test_create_folder_saving</vh></v>
<v t="ekr.20080516150804.2522"><vh>test_create_resource_saving</vh></v>
<v t="ekr.20080516150804.2523"><vh>test_remove_resource_saving</vh></v>
<v t="ekr.20080516150804.2524"><vh>test_change_set_saving</vh></v>
<v t="ekr.20080516150804.2525"><vh>test_writing_and_reading_history</vh></v>
<v t="ekr.20080516150804.2526"><vh>test_writing_and_reading_history2</vh></v>
</v>
<v t="ekr.20080516150804.2527"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2528"><vh>ropetest\objectdbtest.py</vh>
<v t="ekr.20080516150804.2529"><vh>objectdbtest declarations</vh></v>
<v t="ekr.20080516150804.2530"><vh>_do_for_all_dbs</vh></v>
<v t="ekr.20080516150804.2531"><vh>class _MockValidation</vh>
<v t="ekr.20080516150804.2532"><vh>is_value_valid</vh></v>
<v t="ekr.20080516150804.2533"><vh>is_more_valid</vh></v>
<v t="ekr.20080516150804.2534"><vh>is_file_valid</vh></v>
<v t="ekr.20080516150804.2535"><vh>is_scope_valid</vh></v>
</v>
<v t="ekr.20080516150804.2536"><vh>class _MockFileListObserver</vh>
<v t="ekr.20080516150804.2537"><vh>added</vh></v>
<v t="ekr.20080516150804.2538"><vh>removed</vh></v>
</v>
<v t="ekr.20080516150804.2539"><vh>class ObjectDBTest</vh>
<v t="ekr.20080516150804.2540"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2541"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2542"><vh>test_simple_per_name</vh></v>
<v t="ekr.20080516150804.2543"><vh>test_simple_per_name_does_not_exist</vh></v>
<v t="ekr.20080516150804.2544"><vh>test_simple_per_name_after_syncing</vh></v>
<v t="ekr.20080516150804.2545"><vh>test_getting_returned</vh></v>
<v t="ekr.20080516150804.2546"><vh>test_getting_returned_when_does_not_match</vh></v>
<v t="ekr.20080516150804.2547"><vh>test_getting_call_info</vh></v>
<v t="ekr.20080516150804.2548"><vh>test_invalid_per_name</vh></v>
<v t="ekr.20080516150804.2549"><vh>test_overwriting_per_name</vh></v>
<v t="ekr.20080516150804.2550"><vh>test_not_overwriting_with_invalid_per_name</vh></v>
<v t="ekr.20080516150804.2551"><vh>test_getting_invalid_returned</vh></v>
<v t="ekr.20080516150804.2552"><vh>test_not_overwriting_with_invalid_returned</vh></v>
<v t="ekr.20080516150804.2553"><vh>test_get_files</vh></v>
<v t="ekr.20080516150804.2554"><vh>test_validating_files</vh></v>
<v t="ekr.20080516150804.2555"><vh>test_validating_file_for_scopes</vh></v>
<v t="ekr.20080516150804.2556"><vh>test_validating_file_moved</vh></v>
<v t="ekr.20080516150804.2557"><vh>test_using_file_list_observer</vh></v>
</v>
<v t="ekr.20080516150804.2558"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2559"><vh>ropetest\objectinfertest.py</vh>
<v t="ekr.20080516150804.2560"><vh>objectinfertest declarations</vh></v>
<v t="ekr.20080516150804.2561"><vh>class ObjectInferTest</vh>
<v t="ekr.20080516150804.2562"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2563"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2564"><vh>test_simple_type_inferencing</vh></v>
<v t="ekr.20080516150804.2565"><vh>test_simple_type_inferencing_classes_defined_in_holding_scope</vh></v>
<v t="ekr.20080516150804.2566"><vh>test_simple_type_inferencing_classes_in_class_methods</vh></v>
<v t="ekr.20080516150804.2567"><vh>test_simple_type_inferencing_class_attributes</vh></v>
<v t="ekr.20080516150804.2568"><vh>test_simple_type_inferencing_for_in_class_assignments</vh></v>
<v t="ekr.20080516150804.2569"><vh>test_simple_type_inferencing_for_chained_assignments</vh></v>
<v t="ekr.20080516150804.2570"><vh>test_following_chained_assignments_avoiding_circles</vh></v>
<v t="ekr.20080516150804.2571"><vh>test_function_returned_object_static_type_inference1</vh></v>
<v t="ekr.20080516150804.2572"><vh>test_function_returned_object_static_type_inference2</vh></v>
<v t="ekr.20080516150804.2573"><vh>test_recursive_function_returned_object_static_type_inference</vh></v>
<v t="ekr.20080516150804.2574"><vh>test_function_returned_object_using_call_special_function_static_type_inference</vh></v>
<v t="ekr.20080516150804.2575"><vh>test_list_type_inferencing</vh></v>
<v t="ekr.20080516150804.2576"><vh>test_attributed_object_inference</vh></v>
<v t="ekr.20080516150804.2577"><vh>test_getting_property_attributes</vh></v>
<v t="ekr.20080516150804.2578"><vh>test_getting_property_attributes_with_method_getters</vh></v>
<v t="ekr.20080516150804.2579"><vh>test_lambda_functions</vh></v>
<v t="ekr.20080516150804.2580"><vh>test_mixing_subscript_with_tuple_assigns</vh></v>
<v t="ekr.20080516150804.2581"><vh>test_mixing_ass_attr_with_tuple_assignment</vh></v>
<v t="ekr.20080516150804.2582"><vh>test_mixing_slice_with_tuple_assigns</vh></v>
<v t="ekr.20080516150804.2583"><vh>test_nested_tuple_assignments</vh></v>
<v t="ekr.20080516150804.2584"><vh>test_empty_tuples</vh></v>
<v t="ekr.20080516150804.2585"><vh>test_handling_generator_functions</vh></v>
<v t="ekr.20080516150804.2586"><vh>test_handling_generator_functions_for_strs</vh></v>
<v t="ekr.20080516150804.2587"><vh>test_considering_nones_to_be_unknowns</vh></v>
<v t="ekr.20080516150804.2588"><vh>test_basic_list_comprehensions</vh></v>
<v t="ekr.20080516150804.2589"><vh>test_basic_generator_expressions</vh></v>
<v t="ekr.20080516150804.2590"><vh>test_list_comprehensions_and_loop_var</vh></v>
<v t="ekr.20080516150804.2591"><vh>test_list_comprehensions_and_multiple_loop_var</vh></v>
<v t="ekr.20080516150804.2592"><vh>test_list_comprehensions_and_multiple_iters</vh></v>
<v t="ekr.20080516150804.2593"><vh>test_we_know_the_type_of_catched_exceptions</vh></v>
<v t="ekr.20080516150804.2594"><vh>test_we_know_the_type_of_catched_multiple_excepts</vh></v>
<v t="ekr.20080516150804.2595"><vh>test_using_property_as_decorators</vh></v>
<v t="ekr.20080516150804.2596"><vh>test_using_property_as_decorators_and_passing_parameter</vh></v>
</v>
<v t="ekr.20080516150804.2597"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2598"><vh>ropetest\projecttest.py</vh>
<v t="ekr.20080516150804.2599"><vh>projecttest declarations</vh></v>
<v t="ekr.20080516150804.2600"><vh>class ProjectTest</vh>
<v t="ekr.20080516150804.2601"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2602"><vh>_make_sample_project</vh></v>
<v t="ekr.20080516150804.2603"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2604"><vh>test_project_creation</vh></v>
<v t="ekr.20080516150804.2605"><vh>test_getting_project_file</vh></v>
<v t="ekr.20080516150804.2606"><vh>test_project_file_reading</vh></v>
<v t="ekr.20080516150804.2607"><vh>test_getting_not_existing_project_file</vh></v>
<v t="ekr.20080516150804.2608"><vh>test_writing_in_project_files</vh></v>
<v t="ekr.20080516150804.2609"><vh>test_creating_files</vh></v>
<v t="ekr.20080516150804.2610"><vh>test_creating_files_that_already_exist</vh></v>
<v t="ekr.20080516150804.2611"><vh>test_making_root_folder_if_it_does_not_exist</vh></v>
<v t="ekr.20080516150804.2612"><vh>test_failure_when_project_root_exists_and_is_a_file</vh></v>
<v t="ekr.20080516150804.2613"><vh>test_creating_folders</vh></v>
<v t="ekr.20080516150804.2614"><vh>test_making_folder_that_already_exists</vh></v>
<v t="ekr.20080516150804.2615"><vh>test_failing_if_creating_folder_while_file_already_exists</vh></v>
<v t="ekr.20080516150804.2616"><vh>test_creating_file_inside_folder</vh></v>
<v t="ekr.20080516150804.2617"><vh>test_failing_when_creating_file_inside_non_existent_folder</vh></v>
<v t="ekr.20080516150804.2618"><vh>test_nested_directories</vh></v>
<v t="ekr.20080516150804.2619"><vh>test_removing_files</vh></v>
<v t="ekr.20080516150804.2620"><vh>test_removing_files_invalidating_in_project_resource_pool</vh></v>
<v t="ekr.20080516150804.2621"><vh>test_removing_directories</vh></v>
<v t="ekr.20080516150804.2622"><vh>test_removing_non_existent_files</vh></v>
<v t="ekr.20080516150804.2623"><vh>test_removing_nested_files</vh></v>
<v t="ekr.20080516150804.2624"><vh>test_file_get_name</vh></v>
<v t="ekr.20080516150804.2625"><vh>test_folder_get_name</vh></v>
<v t="ekr.20080516150804.2626"><vh>test_file_get_path</vh></v>
<v t="ekr.20080516150804.2627"><vh>test_folder_get_path</vh></v>
<v t="ekr.20080516150804.2628"><vh>test_is_folder</vh></v>
<v t="ekr.20080516150804.2629"><vh>testget_children</vh></v>
<v t="ekr.20080516150804.2630"><vh>test_nonempty_get_children</vh></v>
<v t="ekr.20080516150804.2631"><vh>test_nonempty_get_children2</vh></v>
<v t="ekr.20080516150804.2632"><vh>test_getting_files</vh></v>
<v t="ekr.20080516150804.2633"><vh>test_getting_folders</vh></v>
<v t="ekr.20080516150804.2634"><vh>test_nested_folder_get_files</vh></v>
<v t="ekr.20080516150804.2635"><vh>test_nested_folder_get_folders</vh></v>
<v t="ekr.20080516150804.2636"><vh>test_root_folder</vh></v>
<v t="ekr.20080516150804.2637"><vh>test_get_all_files</vh></v>
<v t="ekr.20080516150804.2638"><vh>test_get_all_files_after_changing</vh></v>
<v t="ekr.20080516150804.2639"><vh>test_multifile_get_all_files</vh></v>
<v t="ekr.20080516150804.2640"><vh>test_ignoring_dot_pyc_files_in_get_files</vh></v>
<v t="ekr.20080516150804.2641"><vh>test_folder_creating_files</vh></v>
<v t="ekr.20080516150804.2642"><vh>test_folder_creating_nested_files</vh></v>
<v t="ekr.20080516150804.2643"><vh>test_folder_creating_files2</vh></v>
<v t="ekr.20080516150804.2644"><vh>test_folder_creating_nested_files2</vh></v>
<v t="ekr.20080516150804.2645"><vh>test_folder_get_child</vh></v>
<v t="ekr.20080516150804.2646"><vh>test_folder_get_child_nested</vh></v>
<v t="ekr.20080516150804.2647"><vh>test_project_root_is_root_folder</vh></v>
<v t="ekr.20080516150804.2648"><vh>test_moving_files</vh></v>
<v t="ekr.20080516150804.2649"><vh>test_moving_folders</vh></v>
<v t="ekr.20080516150804.2650"><vh>test_moving_destination_folders</vh></v>
<v t="ekr.20080516150804.2651"><vh>test_moving_files_and_resource_objects</vh></v>
<v t="ekr.20080516150804.2652"><vh>test_file_encoding_reading</vh></v>
<v t="ekr.20080516150804.2653"><vh>test_file_encoding_writing</vh></v>
<v t="ekr.20080516150804.2654"><vh>test_using_utf8_when_writing_in_case_of_errors</vh></v>
<v t="ekr.20080516150804.2655"><vh>test_encoding_declaration_in_the_second_line</vh></v>
<v t="ekr.20080516150804.2656"><vh>test_read_bytes</vh></v>
<v t="ekr.20080516150804.2657"><vh>xxx_test_using_utf16</vh></v>
<v t="ekr.20080516150804.2658"><vh>xxx_test_file_encoding_reading_for_notepad_styles</vh></v>
<v t="ekr.20080516150804.2659"><vh>test_using_project_get_file</vh></v>
<v t="ekr.20080516150804.2660"><vh>test_using_file_create</vh></v>
<v t="ekr.20080516150804.2661"><vh>test_using_folder_create</vh></v>
<v t="ekr.20080516150804.2662"><vh>test_exception_when_creating_twice</vh></v>
<v t="ekr.20080516150804.2663"><vh>test_exception_when_parent_does_not_exist</vh></v>
<v t="ekr.20080516150804.2664"><vh>test_simple_path_to_resource</vh></v>
<v t="ekr.20080516150804.2665"><vh>test_ignoring_symlinks_inside_project</vh></v>
</v>
<v t="ekr.20080516150804.2666"><vh>class ResourceObserverTest</vh>
<v t="ekr.20080516150804.2667"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2668"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2669"><vh>test_resource_change_observer</vh></v>
<v t="ekr.20080516150804.2670"><vh>test_resource_change_observer_after_removal</vh></v>
<v t="ekr.20080516150804.2671"><vh>test_resource_change_observer2</vh></v>
<v t="ekr.20080516150804.2672"><vh>test_resource_change_observer_for_folders</vh></v>
<v t="ekr.20080516150804.2673"><vh>test_resource_change_observer_after_moving</vh></v>
<v t="ekr.20080516150804.2674"><vh>test_revalidating_files</vh></v>
<v t="ekr.20080516150804.2675"><vh>test_revalidating_files_and_no_changes2</vh></v>
<v t="ekr.20080516150804.2676"><vh>test_revalidating_folders</vh></v>
<v t="ekr.20080516150804.2677"><vh>test_removing_and_adding_resources_to_filtered_observer</vh></v>
<v t="ekr.20080516150804.2678"><vh>test_validation_and_changing_files</vh></v>
<v t="ekr.20080516150804.2679"><vh>test_validation_and_changing_files2</vh></v>
<v t="ekr.20080516150804.2680"><vh>test_not_reporting_multiple_changes_to_folders</vh></v>
<v t="ekr.20080516150804.2681"><vh>_write_file</vh></v>
<v t="ekr.20080516150804.2682"><vh>test_moving_and_being_interested_about_a_folder_and_a_child</vh></v>
<v t="ekr.20080516150804.2683"><vh>test_contains_for_folders</vh></v>
<v t="ekr.20080516150804.2684"><vh>test_validating_when_created</vh></v>
<v t="ekr.20080516150804.2685"><vh>test_validating_twice_when_created</vh></v>
<v t="ekr.20080516150804.2686"><vh>test_changes_and_adding_resources</vh></v>
<v t="ekr.20080516150804.2687"><vh>test_validating_get_files_list</vh></v>
<v t="ekr.20080516150804.2688"><vh>test_clear_observered_resources_for_filtered_observers</vh></v>
</v>
<v t="ekr.20080516150804.2689"><vh>class _MockChangeIndicator</vh>
<v t="ekr.20080516150804.2690"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2691"><vh>set_indicator</vh></v>
<v t="ekr.20080516150804.2692"><vh>get_indicator</vh></v>
</v>
<v t="ekr.20080516150804.2693"><vh>class _SampleObserver</vh>
<v t="ekr.20080516150804.2694"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2695"><vh>resource_changed</vh></v>
<v t="ekr.20080516150804.2696"><vh>resource_moved</vh></v>
<v t="ekr.20080516150804.2697"><vh>resource_created</vh></v>
<v t="ekr.20080516150804.2698"><vh>resource_removed</vh></v>
</v>
<v t="ekr.20080516150804.2699"><vh>class OutOfProjectTest</vh>
<v t="ekr.20080516150804.2700"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2701"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2702"><vh>test_simple_out_of_project_file</vh></v>
<v t="ekr.20080516150804.2703"><vh>test_simple_out_of_project_folder</vh></v>
<v t="ekr.20080516150804.2704"><vh>test_using_absolute_path</vh></v>
<v t="ekr.20080516150804.2705"><vh>test_folder_get_child</vh></v>
<v t="ekr.20080516150804.2706"><vh>test_out_of_project_files_and_path_to_resource</vh></v>
</v>
<v t="ekr.20080516150804.2707"><vh>class _MockFSCommands</vh>
<v t="ekr.20080516150804.2708"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2709"><vh>create_file</vh></v>
<v t="ekr.20080516150804.2710"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.2711"><vh>move</vh></v>
<v t="ekr.20080516150804.2712"><vh>remove</vh></v>
</v>
<v t="ekr.20080516150804.2713"><vh>class RopeFolderTest</vh>
<v t="ekr.20080516150804.2714"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2715"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2716"><vh>test_none_project_rope_folder</vh></v>
<v t="ekr.20080516150804.2717"><vh>test_getting_project_rope_folder</vh></v>
<v t="ekr.20080516150804.2718"><vh>test_setting_ignored_resources</vh></v>
<v t="ekr.20080516150804.2719"><vh>test_ignored_folders</vh></v>
<v t="ekr.20080516150804.2720"><vh>test_ignored_resources_and_get_files</vh></v>
<v t="ekr.20080516150804.2721"><vh>test_ignored_resources_and_get_files2</vh></v>
<v t="ekr.20080516150804.2722"><vh>test_setting_ignored_resources_patterns</vh></v>
<v t="ekr.20080516150804.2723"><vh>test_star_should_not_include_slashes</vh></v>
<v t="ekr.20080516150804.2724"><vh>test_normal_fscommands</vh></v>
<v t="ekr.20080516150804.2725"><vh>test_fscommands_and_ignored_resources</vh></v>
<v t="ekr.20080516150804.2726"><vh>test_ignored_resources_and_prefixes</vh></v>
<v t="ekr.20080516150804.2727"><vh>test_loading_config_dot_py</vh></v>
<v t="ekr.20080516150804.2728"><vh>test_ignoring_syntax_errors</vh></v>
<v t="ekr.20080516150804.2729"><vh>test_compressed_history</vh></v>
<v t="ekr.20080516150804.2730"><vh>test_compressed_objectdb</vh></v>
</v>
<v t="ekr.20080516150804.2731"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2732"><vh>ropetest\pycoretest.py</vh>
<v t="ekr.20080516150804.2733"><vh>pycoretest declarations</vh></v>
<v t="ekr.20080516150804.2734"><vh>class PyCoreTest</vh>
<v t="ekr.20080516150804.2735"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2736"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2737"><vh>test_simple_module</vh></v>
<v t="ekr.20080516150804.2738"><vh>test_nested_modules</vh></v>
<v t="ekr.20080516150804.2739"><vh>test_package</vh></v>
<v t="ekr.20080516150804.2740"><vh>test_simple_class</vh></v>
<v t="ekr.20080516150804.2741"><vh>test_simple_function</vh></v>
<v t="ekr.20080516150804.2742"><vh>test_class_methods</vh></v>
<v t="ekr.20080516150804.2743"><vh>test_global_variables</vh></v>
<v t="ekr.20080516150804.2744"><vh>test_class_variables</vh></v>
<v t="ekr.20080516150804.2745"><vh>test_class_attributes_set_in_init</vh></v>
<v t="ekr.20080516150804.2746"><vh>test_class_attributes_set_in_init_overwriting_a_defined</vh></v>
<v t="ekr.20080516150804.2747"><vh>test_classes_inside_other_classes</vh></v>
<v t="ekr.20080516150804.2748"><vh>test_non_existent_module</vh></v>
<v t="ekr.20080516150804.2749"><vh>test_imported_names</vh></v>
<v t="ekr.20080516150804.2750"><vh>test_imported_as_names</vh></v>
<v t="ekr.20080516150804.2751"><vh>test_get_string_module</vh></v>
<v t="ekr.20080516150804.2752"><vh>test_get_string_module_with_extra_spaces</vh></v>
<v t="ekr.20080516150804.2753"><vh>test_parameter_info_for_functions</vh></v>
<v t="ekr.20080516150804.2754"><vh>xxx_test_not_found_module_is_module</vh></v>
<v t="ekr.20080516150804.2755"><vh>test_mixing_scopes_and_objects_hierarchy</vh></v>
<v t="ekr.20080516150804.2756"><vh>test_inheriting_base_class_attributes</vh></v>
<v t="ekr.20080516150804.2757"><vh>test_inheriting_multiple_base_class_attributes</vh></v>
<v t="ekr.20080516150804.2758"><vh>test_inheriting_multiple_base_class_attributes_with_the_same_name</vh></v>
<v t="ekr.20080516150804.2759"><vh>test_inheriting_unknown_base_class</vh></v>
<v t="ekr.20080516150804.2760"><vh>test_module_creation</vh></v>
<v t="ekr.20080516150804.2761"><vh>test_packaged_module_creation</vh></v>
<v t="ekr.20080516150804.2762"><vh>test_packaged_module_creation_with_nested_src</vh></v>
<v t="ekr.20080516150804.2763"><vh>test_package_creation</vh></v>
<v t="ekr.20080516150804.2764"><vh>test_nested_package_creation</vh></v>
<v t="ekr.20080516150804.2765"><vh>test_packaged_package_creation_with_nested_src</vh></v>
<v t="ekr.20080516150804.2766"><vh>test_find_module</vh></v>
<v t="ekr.20080516150804.2767"><vh>test_find_nested_module</vh></v>
<v t="ekr.20080516150804.2768"><vh>test_find_multiple_module</vh></v>
<v t="ekr.20080516150804.2769"><vh>test_find_module_packages</vh></v>
<v t="ekr.20080516150804.2770"><vh>test_find_module_when_module_and_package_with_the_same_name</vh></v>
<v t="ekr.20080516150804.2771"><vh>test_getting_empty_source_folders</vh></v>
<v t="ekr.20080516150804.2772"><vh>test_root_source_folder</vh></v>
<v t="ekr.20080516150804.2773"><vh>test_root_source_folder2</vh></v>
<v t="ekr.20080516150804.2774"><vh>test_src_source_folder</vh></v>
<v t="ekr.20080516150804.2775"><vh>test_packages</vh></v>
<v t="ekr.20080516150804.2776"><vh>test_multi_source_folders</vh></v>
<v t="ekr.20080516150804.2777"><vh>test_multi_source_folders2</vh></v>
<v t="ekr.20080516150804.2778"><vh>test_get_pyname_definition_location</vh></v>
<v t="ekr.20080516150804.2779"><vh>test_get_pyname_definition_location_functions</vh></v>
<v t="ekr.20080516150804.2780"><vh>test_get_pyname_definition_location_class</vh></v>
<v t="ekr.20080516150804.2781"><vh>test_get_pyname_definition_location_local_variables</vh></v>
<v t="ekr.20080516150804.2782"><vh>test_get_pyname_definition_location_reassigning</vh></v>
<v t="ekr.20080516150804.2783"><vh>test_get_pyname_definition_location_importes</vh></v>
<v t="ekr.20080516150804.2784"><vh>test_get_pyname_definition_location_imports</vh></v>
<v t="ekr.20080516150804.2785"><vh>test_get_pyname_definition_location_parameters</vh></v>
<v t="ekr.20080516150804.2786"><vh>test_module_get_resource</vh></v>
<v t="ekr.20080516150804.2787"><vh>test_get_pyname_definition_location_class2</vh></v>
<v t="ekr.20080516150804.2788"><vh>test_import_not_found_module_get_definition_location</vh></v>
<v t="ekr.20080516150804.2789"><vh>test_from_not_found_module_get_definition_location</vh></v>
<v t="ekr.20080516150804.2790"><vh>test_from_package_import_module_get_definition_location</vh></v>
<v t="ekr.20080516150804.2791"><vh>test_get_module_for_defined_pyobjects</vh></v>
<v t="ekr.20080516150804.2792"><vh>test_get_definition_location_for_packages</vh></v>
<v t="ekr.20080516150804.2793"><vh>test_get_definition_location_for_filtered_packages</vh></v>
<v t="ekr.20080516150804.2794"><vh>test_out_of_project_modules</vh></v>
<v t="ekr.20080516150804.2795"><vh>test_file_encoding_reading</vh></v>
<v t="ekr.20080516150804.2796"><vh>test_global_keyword</vh></v>
<v t="ekr.20080516150804.2797"><vh>test_not_leaking_for_vars_inside_parent_scope</vh></v>
<v t="ekr.20080516150804.2798"><vh>test_not_leaking_for_vars_inside_parent_scope2</vh></v>
<v t="ekr.20080516150804.2799"><vh>test_variables_defined_in_excepts</vh></v>
<v t="ekr.20080516150804.2800"><vh>test_not_leaking_tuple_assigned_names_inside_parent_scope</vh></v>
<v t="ekr.20080516150804.2801"><vh>test_with_statement_variables</vh></v>
<v t="ekr.20080516150804.2802"><vh>test_with_statement_variables_and_tuple_assignment</vh></v>
<v t="ekr.20080516150804.2803"><vh>test_with_statement_variable_type</vh></v>
<v t="ekr.20080516150804.2804"><vh>test_with_statement_with_no_vars</vh></v>
<v t="ekr.20080516150804.2805"><vh>test_check_for_else_block</vh></v>
<v t="ekr.20080516150804.2806"><vh>test_check_names_defined_in_whiles</vh></v>
<v t="ekr.20080516150804.2807"><vh>test_get_definition_location_in_tuple_assnames</vh></v>
<v t="ekr.20080516150804.2808"><vh>test_syntax_errors_in_code</vh></v>
<v t="ekr.20080516150804.2809"><vh>test_holding_error_location_information</vh></v>
<v t="ekr.20080516150804.2810"><vh>test_not_syntax_errors_when_cannot_decode_file</vh></v>
<v t="ekr.20080516150804.2811"><vh>test_syntax_errors_when_cannot_decode_file2</vh></v>
<v t="ekr.20080516150804.2812"><vh>test_syntax_errors_when_null_bytes</vh></v>
<v t="ekr.20080516150804.2813"><vh>test_syntax_errors_when_bad_strs</vh></v>
<v t="ekr.20080516150804.2814"><vh>test_not_reaching_maximum_recursions_with_from_star_imports</vh></v>
<v t="ekr.20080516150804.2815"><vh>test_not_reaching_maximum_recursions_when_importing_variables</vh></v>
<v t="ekr.20080516150804.2816"><vh>test_not_reaching_maximum_recursions_when_importing_variables2</vh></v>
<v t="ekr.20080516150804.2817"><vh>test_pyobject_equality_should_compare_types</vh></v>
</v>
<v t="ekr.20080516150804.2818"><vh>class PyCoreInProjectsTest</vh>
<v t="ekr.20080516150804.2819"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2820"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2821"><vh>test_simple_import</vh></v>
<v t="ekr.20080516150804.2822"><vh>test_from_import_class</vh></v>
<v t="ekr.20080516150804.2823"><vh>test_from_import_star</vh></v>
<v t="ekr.20080516150804.2824"><vh>test_from_import_star_overwriting</vh></v>
<v t="ekr.20080516150804.2825"><vh>test_from_import_star_not_imporing_underlined</vh></v>
<v t="ekr.20080516150804.2826"><vh>test_from_import_star_imports_in_functions</vh></v>
<v t="ekr.20080516150804.2827"><vh>test_from_package_import_mod</vh></v>
<v t="ekr.20080516150804.2828"><vh>xxx_test_from_package_import_star</vh></v>
<v t="ekr.20080516150804.2829"><vh>test_unknown_when_module_cannot_be_found</vh></v>
<v t="ekr.20080516150804.2830"><vh>test_from_import_function</vh></v>
<v t="ekr.20080516150804.2831"><vh>test_circular_imports</vh></v>
<v t="ekr.20080516150804.2832"><vh>test_circular_imports2</vh></v>
<v t="ekr.20080516150804.2833"><vh>test_multi_dot_imports</vh></v>
<v t="ekr.20080516150804.2834"><vh>test_multi_dot_imports2</vh></v>
<v t="ekr.20080516150804.2835"><vh>test_multi_dot_imports3</vh></v>
<v t="ekr.20080516150804.2836"><vh>test_multi_dot_imports_as</vh></v>
<v t="ekr.20080516150804.2837"><vh>xxx_test_from_package_import_package</vh></v>
<v t="ekr.20080516150804.2838"><vh>test_invalidating_cache_after_resource_change</vh></v>
<v t="ekr.20080516150804.2839"><vh>test_invalidating_cache_after_resource_change_for_init_dot_pys</vh></v>
<v t="ekr.20080516150804.2840"><vh>test_invalidating_cache_after_resource_change_for_nested_init_dot_pys</vh></v>
<v t="ekr.20080516150804.2841"><vh>test_from_import_nonexistent_module</vh></v>
<v t="ekr.20080516150804.2842"><vh>test_from_import_nonexistent_name</vh></v>
<v t="ekr.20080516150804.2843"><vh>test_not_considering_imported_names_as_sub_scopes</vh></v>
<v t="ekr.20080516150804.2844"><vh>test_not_considering_imported_modules_as_sub_scopes</vh></v>
<v t="ekr.20080516150804.2845"><vh>test_inheriting_dotted_base_class</vh></v>
<v t="ekr.20080516150804.2846"><vh>test_self_in_methods</vh></v>
<v t="ekr.20080516150804.2847"><vh>test_none_assignments_in_classes</vh></v>
<v t="ekr.20080516150804.2848"><vh>test_self_in_methods_with_decorators</vh></v>
<v t="ekr.20080516150804.2849"><vh>test_location_of_imports_when_importing</vh></v>
<v t="ekr.20080516150804.2850"><vh>test_nested_modules</vh></v>
<v t="ekr.20080516150804.2851"><vh>test_reading_init_dot_py</vh></v>
<v t="ekr.20080516150804.2852"><vh>test_relative_imports</vh></v>
<v t="ekr.20080516150804.2853"><vh>test_relative_froms</vh></v>
<v t="ekr.20080516150804.2854"><vh>test_relative_imports_for_string_modules</vh></v>
<v t="ekr.20080516150804.2855"><vh>test_relative_imports_for_string_scopes</vh></v>
<v t="ekr.20080516150804.2856"><vh>test_new_style_relative_imports</vh></v>
<v t="ekr.20080516150804.2857"><vh>test_new_style_relative_imports2</vh></v>
<v t="ekr.20080516150804.2858"><vh>test_invalidating_cache_for_from_imports_after_resource_change</vh></v>
<v t="ekr.20080516150804.2859"><vh>test_invalidating_superclasses_after_change</vh></v>
</v>
<v t="ekr.20080516150804.2860"><vh>class TextChangeDetectorTest</vh>
<v t="ekr.20080516150804.2861"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.2862"><vh>test_one_line_change</vh></v>
<v t="ekr.20080516150804.2863"><vh>test_line_expansion</vh></v>
<v t="ekr.20080516150804.2864"><vh>test_line_removals</vh></v>
<v t="ekr.20080516150804.2865"><vh>test_multi_line_checks</vh></v>
<v t="ekr.20080516150804.2866"><vh>test_consume_change</vh></v>
</v>
<v t="ekr.20080516150804.2867"><vh>class PyCoreProjectConfigsTest</vh>
<v t="ekr.20080516150804.2868"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2869"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2870"><vh>test_python_files_config</vh></v>
<v t="ekr.20080516150804.2871"><vh>test_ignore_bad_imports</vh></v>
<v t="ekr.20080516150804.2872"><vh>test_ignore_bad_imports_for_froms</vh></v>
<v t="ekr.20080516150804.2873"><vh>test_reporting_syntax_errors_with_force_errors</vh></v>
<v t="ekr.20080516150804.2874"><vh>test_reporting_syntax_errors_in_strings_with_force_errors</vh></v>
<v t="ekr.20080516150804.2875"><vh>test_not_raising_errors_for_strings_with_ignore_errors</vh></v>
<v t="ekr.20080516150804.2876"><vh>test_reporting_syntax_errors_with_force_errors_for_packages</vh></v>
</v>
<v t="ekr.20080516150804.2877"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2878"><vh>ropetest\pyscopestest.py</vh>
<v t="ekr.20080516150804.2879"><vh>pyscopestest declarations</vh></v>
<v t="ekr.20080516150804.2880"><vh>class PyCoreScopesTest</vh>
<v t="ekr.20080516150804.2881"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2882"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2883"><vh>test_simple_scope</vh></v>
<v t="ekr.20080516150804.2884"><vh>test_simple_function_scope</vh></v>
<v t="ekr.20080516150804.2885"><vh>test_classes_inside_function_scopes</vh></v>
<v t="ekr.20080516150804.2886"><vh>test_simple_class_scope</vh></v>
<v t="ekr.20080516150804.2887"><vh>test_get_lineno</vh></v>
<v t="ekr.20080516150804.2888"><vh>test_scope_kind</vh></v>
<v t="ekr.20080516150804.2889"><vh>test_function_parameters_in_scope_names</vh></v>
<v t="ekr.20080516150804.2890"><vh>test_get_names_contains_only_names_defined_in_a_scope</vh></v>
<v t="ekr.20080516150804.2891"><vh>test_scope_lookup</vh></v>
<v t="ekr.20080516150804.2892"><vh>test_function_scopes</vh></v>
<v t="ekr.20080516150804.2893"><vh>test_function_scopes_classes</vh></v>
<v t="ekr.20080516150804.2894"><vh>test_function_getting_scope</vh></v>
<v t="ekr.20080516150804.2895"><vh>test_scopes_in_function_scopes</vh></v>
<v t="ekr.20080516150804.2896"><vh>test_for_variables_in_scopes</vh></v>
<v t="ekr.20080516150804.2897"><vh>test_assists_inside_fors</vh></v>
<v t="ekr.20080516150804.2898"><vh>test_first_parameter_of_a_method</vh></v>
<v t="ekr.20080516150804.2899"><vh>test_first_parameter_of_static_methods</vh></v>
<v t="ekr.20080516150804.2900"><vh>test_first_parameter_of_class_methods</vh></v>
<v t="ekr.20080516150804.2901"><vh>test_first_parameter_with_self_as_name_and_unknown_decorator</vh></v>
<v t="ekr.20080516150804.2902"><vh>test_inside_class_scope_attribute_lookup</vh></v>
<v t="ekr.20080516150804.2903"><vh>test_inside_class_scope_attribute_lookup2</vh></v>
<v t="ekr.20080516150804.2904"><vh>test_get_inner_scope_for_staticmethods</vh></v>
<v t="ekr.20080516150804.2905"><vh>test_getting_overwritten_scopes</vh></v>
<v t="ekr.20080516150804.2906"><vh>test_assigning_builtin_names</vh></v>
<v t="ekr.20080516150804.2907"><vh>test_get_inner_scope_and_logical_lines</vh></v>
<v t="ekr.20080516150804.2908"><vh>test_getting_defined_names_for_classes</vh></v>
<v t="ekr.20080516150804.2909"><vh>test_getting_defined_names_for_modules</vh></v>
</v>
<v t="ekr.20080516150804.2910"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2911"><vh>ropetest\runmodtest.py</vh>
<v t="ekr.20080516150804.2912"><vh>runmodtest declarations</vh></v>
<v t="ekr.20080516150804.2913"><vh>class PythonFileRunnerTest</vh>
<v t="ekr.20080516150804.2914"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2915"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2916"><vh>make_sample_python_file</vh></v>
<v t="ekr.20080516150804.2917"><vh>get_output_file_content</vh></v>
<v t="ekr.20080516150804.2918"><vh>test_making_runner</vh></v>
<v t="ekr.20080516150804.2919"><vh>test_passing_arguments</vh></v>
<v t="ekr.20080516150804.2920"><vh>test_passing_arguments_with_spaces</vh></v>
<v t="ekr.20080516150804.2921"><vh>test_killing_runner</vh></v>
<v t="ekr.20080516150804.2922"><vh>test_running_nested_files</vh></v>
<v t="ekr.20080516150804.2923"><vh>test_setting_process_input</vh></v>
<v t="ekr.20080516150804.2924"><vh>test_setting_process_output</vh></v>
<v t="ekr.20080516150804.2925"><vh>test_setting_pythonpath</vh></v>
<v t="ekr.20080516150804.2926"><vh>test_making_runner_when_doi_is_disabled</vh></v>
</v>
<v t="ekr.20080516150804.2927"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2928"><vh>ropetest\simplifytest.py</vh>
<v t="ekr.20080516150804.2929"><vh>simplifytest declarations</vh></v>
<v t="ekr.20080516150804.2930"><vh>class SimplifyTest</vh>
<v t="ekr.20080516150804.2931"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2932"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2933"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.2934"><vh>test_empty_strs</vh></v>
<v t="ekr.20080516150804.2935"><vh>test_blanking_strs</vh></v>
<v t="ekr.20080516150804.2936"><vh>test_changing_to_double_quotes</vh></v>
<v t="ekr.20080516150804.2937"><vh>test_changing_to_double_quotes2</vh></v>
<v t="ekr.20080516150804.2938"><vh>test_removing_comments</vh></v>
<v t="ekr.20080516150804.2939"><vh>test_removing_comments_that_contain_strings</vh></v>
<v t="ekr.20080516150804.2940"><vh>test_removing_strings_containing_comments</vh></v>
<v t="ekr.20080516150804.2941"><vh>test_joining_implicit_continuations</vh></v>
<v t="ekr.20080516150804.2942"><vh>test_joining_explicit_continuations</vh></v>
<v t="ekr.20080516150804.2943"><vh>test_replacing_tabs</vh></v>
<v t="ekr.20080516150804.2944"><vh>test_replacing_semicolons</vh></v>
</v>
<v t="ekr.20080516150804.2945"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2946"><vh>ropetest\testutils.py</vh>
<v t="ekr.20080516150804.2947"><vh>testutils declarations</vh></v>
<v t="ekr.20080516150804.2948"><vh>sample_project</vh></v>
<v t="ekr.20080516150804.2949"><vh>remove_project</vh></v>
<v t="ekr.20080516150804.2950"><vh>remove_recursively</vh></v>
<v t="ekr.20080516150804.2951"><vh>_remove_recursively</vh></v>
<v t="ekr.20080516150804.2952"><vh>run_only_for_25</vh></v>
<v t="ekr.20080516150804.2953"><vh>only_for</vh></v>
<v t="ekr.20080516150804.2954"><vh>run_only_for_unix</vh></v>
<v t="ekr.20080516150804.2955"><vh>assert_raises</vh></v>
</v>
<v t="ekr.20080516150804.2956"><vh>ropetest\__init__.py</vh>
<v t="ekr.20080516150804.2957"><vh>__init__ declarations</vh></v>
<v t="ekr.20080516150804.2958"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2959"><vh>rope-0.8.2\ropetest\contrib</vh>
<v t="ekr.20080516150804.2960"><vh>ropetest\contrib\autoimporttest.py</vh>
<v t="ekr.20080516150804.2961"><vh>autoimporttest declarations</vh></v>
<v t="ekr.20080516150804.2962"><vh>class AutoImportTest</vh>
<v t="ekr.20080516150804.2963"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2964"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2965"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.2966"><vh>test_update_resource</vh></v>
<v t="ekr.20080516150804.2967"><vh>test_update_module</vh></v>
<v t="ekr.20080516150804.2968"><vh>test_update_non_existent_module</vh></v>
<v t="ekr.20080516150804.2969"><vh>test_module_with_syntax_errors</vh></v>
<v t="ekr.20080516150804.2970"><vh>test_excluding_imported_names</vh></v>
<v t="ekr.20080516150804.2971"><vh>test_get_modules</vh></v>
<v t="ekr.20080516150804.2972"><vh>test_get_modules_inside_packages</vh></v>
<v t="ekr.20080516150804.2973"><vh>test_trivial_insertion_line</vh></v>
<v t="ekr.20080516150804.2974"><vh>test_insertion_line</vh></v>
<v t="ekr.20080516150804.2975"><vh>test_insertion_line_with_pydocs</vh></v>
<v t="ekr.20080516150804.2976"><vh>test_insertion_line_with_multiple_imports</vh></v>
<v t="ekr.20080516150804.2977"><vh>test_insertion_line_with_blank_lines</vh></v>
<v t="ekr.20080516150804.2978"><vh>test_empty_cache</vh></v>
<v t="ekr.20080516150804.2979"><vh>test_not_caching_underlined_names</vh></v>
<v t="ekr.20080516150804.2980"><vh>test_caching_underlined_names_passing_to_the_constructor</vh></v>
<v t="ekr.20080516150804.2981"><vh>test_name_locations</vh></v>
<v t="ekr.20080516150804.2982"><vh>test_name_locations_with_multiple_occurrences</vh></v>
</v>
<v t="ekr.20080516150804.2983"><vh>class AutoImportObservingTest</vh>
<v t="ekr.20080516150804.2984"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2985"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2986"><vh>test_writing_files</vh></v>
<v t="ekr.20080516150804.2987"><vh>test_moving_files</vh></v>
<v t="ekr.20080516150804.2988"><vh>test_removing_files</vh></v>
</v>
<v t="ekr.20080516150804.2989"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.2990"><vh>ropetest\contrib\codeassisttest.py</vh>
<v t="ekr.20080516150804.2991"><vh>codeassisttest declarations</vh></v>
<v t="ekr.20080516150804.2992"><vh>class CodeAssistTest</vh>
<v t="ekr.20080516150804.2993"><vh>setUp</vh></v>
<v t="ekr.20080516150804.2994"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.2995"><vh>_assist</vh></v>
<v t="ekr.20080516150804.2996"><vh>test_simple_assist</vh></v>
<v t="ekr.20080516150804.2997"><vh>assert_completion_in_result</vh></v>
<v t="ekr.20080516150804.2998"><vh>assert_completion_not_in_result</vh></v>
<v t="ekr.20080516150804.2999"><vh>test_completing_global_variables</vh></v>
<v t="ekr.20080516150804.3000"><vh>test_not_proposing_unmatched_vars</vh></v>
<v t="ekr.20080516150804.3001"><vh>test_not_proposing_unmatched_vars_with_underlined_starting</vh></v>
<v t="ekr.20080516150804.3002"><vh>test_not_proposing_local_assigns_as_global_completions</vh></v>
<v t="ekr.20080516150804.3003"><vh>test_proposing_functions</vh></v>
<v t="ekr.20080516150804.3004"><vh>test_proposing_classes</vh></v>
<v t="ekr.20080516150804.3005"><vh>test_proposing_each_name_at_most_once</vh></v>
<v t="ekr.20080516150804.3006"><vh>test_throwing_exception_in_case_of_syntax_errors</vh></v>
<v t="ekr.20080516150804.3007"><vh>test_fixing_errors_with_maxfixes</vh></v>
<v t="ekr.20080516150804.3008"><vh>test_ignoring_errors_in_current_line</vh></v>
<v t="ekr.20080516150804.3009"><vh>test_not_reporting_variables_in_current_line</vh></v>
<v t="ekr.20080516150804.3010"><vh>test_completion_result</vh></v>
<v t="ekr.20080516150804.3011"><vh>test_completing_imported_names</vh></v>
<v t="ekr.20080516150804.3012"><vh>test_completing_imported_names_with_as</vh></v>
<v t="ekr.20080516150804.3013"><vh>test_not_completing_imported_names_with_as</vh></v>
<v t="ekr.20080516150804.3014"><vh>test_including_matching_builtins_types</vh></v>
<v t="ekr.20080516150804.3015"><vh>test_including_matching_builtins_functions</vh></v>
<v t="ekr.20080516150804.3016"><vh>test_including_keywords</vh></v>
<v t="ekr.20080516150804.3017"><vh>test_not_reporting_proposals_after_dot</vh></v>
<v t="ekr.20080516150804.3018"><vh>test_proposing_local_variables_in_functions</vh></v>
<v t="ekr.20080516150804.3019"><vh>test_local_variables_override_global_ones</vh></v>
<v t="ekr.20080516150804.3020"><vh>test_not_including_class_body_variables</vh></v>
<v t="ekr.20080516150804.3021"><vh>test_nested_functions</vh></v>
<v t="ekr.20080516150804.3022"><vh>test_scope_endpoint_selection</vh></v>
<v t="ekr.20080516150804.3023"><vh>test_scope_better_endpoint_selection</vh></v>
<v t="ekr.20080516150804.3024"><vh>test_imports_inside_function</vh></v>
<v t="ekr.20080516150804.3025"><vh>test_imports_inside_function_dont_mix_with_globals</vh></v>
<v t="ekr.20080516150804.3026"><vh>test_nested_classes_local_names</vh></v>
<v t="ekr.20080516150804.3027"><vh>test_nested_classes_global</vh></v>
<v t="ekr.20080516150804.3028"><vh>test_nested_classes_global_function</vh></v>
<v t="ekr.20080516150804.3029"><vh>test_proposing_function_parameters_in_functions</vh></v>
<v t="ekr.20080516150804.3030"><vh>test_proposing_function_keyword_parameters_in_functions</vh></v>
<v t="ekr.20080516150804.3031"><vh>test_not_proposing_unmatching_function_parameters_in_functions</vh></v>
<v t="ekr.20080516150804.3032"><vh>test_ignoring_current_statement</vh></v>
<v t="ekr.20080516150804.3033"><vh>test_ignoring_current_statement_brackets_continuation</vh></v>
<v t="ekr.20080516150804.3034"><vh>test_ignoring_current_statement_explicit_continuation</vh></v>
<v t="ekr.20080516150804.3035"><vh>test_ignoring_current_statement_while_the_first_statement_of_the_block</vh></v>
<v t="ekr.20080516150804.3036"><vh>test_ignoring_current_statement_while_current_line_ends_with_a_colon</vh></v>
<v t="ekr.20080516150804.3037"><vh>test_ignoring_string_contents</vh></v>
<v t="ekr.20080516150804.3038"><vh>test_ignoring_comment_contents</vh></v>
<v t="ekr.20080516150804.3039"><vh>test_ignoring_string_contents_backslash_plus_quotes</vh></v>
<v t="ekr.20080516150804.3040"><vh>test_ignoring_string_contents_backslash_plus_backslash</vh></v>
<v t="ekr.20080516150804.3041"><vh>test_not_proposing_later_defined_variables_in_current_block</vh></v>
<v t="ekr.20080516150804.3042"><vh>test_not_proposing_later_defined_variables_in_current_function</vh></v>
<v t="ekr.20080516150804.3043"><vh>test_ignoring_string_contents_with_triple_quotes</vh></v>
<v t="ekr.20080516150804.3044"><vh>test_ignoring_string_contents_with_triple_quotes_and_backslash</vh></v>
<v t="ekr.20080516150804.3045"><vh>test_ignoring_string_contents_with_triple_quotes_and_double_backslash</vh></v>
<v t="ekr.20080516150804.3046"><vh>test_reporting_params_when_in_the_first_line_of_a_function</vh></v>
<v t="ekr.20080516150804.3047"><vh>test_code_assist_when_having_a_two_line_function_header</vh></v>
<v t="ekr.20080516150804.3048"><vh>test_code_assist_with_function_with_two_line_return</vh></v>
<v t="ekr.20080516150804.3049"><vh>test_get_definition_location</vh></v>
<v t="ekr.20080516150804.3050"><vh>test_get_definition_location_underlined_names</vh></v>
<v t="ekr.20080516150804.3051"><vh>test_get_definition_location_dotted_names</vh></v>
<v t="ekr.20080516150804.3052"><vh>test_get_definition_location_dotted_module_names</vh></v>
<v t="ekr.20080516150804.3053"><vh>test_get_definition_location_for_nested_packages</vh></v>
<v t="ekr.20080516150804.3054"><vh>test_get_definition_location_unknown</vh></v>
<v t="ekr.20080516150804.3055"><vh>test_get_definition_location_dot_spaces</vh></v>
<v t="ekr.20080516150804.3056"><vh>test_get_definition_location_dot_line_break_inside_parens</vh></v>
<v t="ekr.20080516150804.3057"><vh>test_if_scopes_in_other_scopes_for_get_definition_location</vh></v>
<v t="ekr.20080516150804.3058"><vh>test_code_assists_in_parens</vh></v>
<v t="ekr.20080516150804.3059"><vh>test_simple_type_inferencing</vh></v>
<v t="ekr.20080516150804.3060"><vh>test_proposals_sorter</vh></v>
<v t="ekr.20080516150804.3061"><vh>test_proposals_sorter_for_methods_and_attributes</vh></v>
<v t="ekr.20080516150804.3062"><vh>test_proposals_sorter_for_global_methods_and_funcs</vh></v>
<v t="ekr.20080516150804.3063"><vh>test_proposals_sorter_underlined_methods</vh></v>
<v t="ekr.20080516150804.3064"><vh>test_proposals_sorter_and_kind_prefs</vh></v>
<v t="ekr.20080516150804.3065"><vh>test_proposals_sorter_and_type_prefs</vh></v>
<v t="ekr.20080516150804.3066"><vh>test_proposals_sorter_and_missing_type_in_typepref</vh></v>
<v t="ekr.20080516150804.3067"><vh>test_get_pydoc_for_functions</vh></v>
<v t="ekr.20080516150804.3068"><vh>test_get_pydoc_for_classes</vh></v>
<v t="ekr.20080516150804.3069"><vh>test_get_pydoc_for_classes_with_init</vh></v>
<v t="ekr.20080516150804.3070"><vh>test_get_pydoc_for_modules</vh></v>
<v t="ekr.20080516150804.3071"><vh>test_get_pydoc_for_builtins</vh></v>
<v t="ekr.20080516150804.3072"><vh>test_get_pydoc_for_methods_should_include_class_name</vh></v>
<v t="ekr.20080516150804.3073"><vh>test_get_pydoc_for_methods_should_include_methods_from_super_classes</vh></v>
<v t="ekr.20080516150804.3074"><vh>test_get_pydoc_for_classes_should_name_super_classes</vh></v>
<v t="ekr.20080516150804.3075"><vh>test_get_pydoc_for_builtin_functions</vh></v>
<v t="ekr.20080516150804.3076"><vh>test_commenting_errors_before_offset</vh></v>
<v t="ekr.20080516150804.3077"><vh>test_proposing_variables_defined_till_the_end_of_scope</vh></v>
<v t="ekr.20080516150804.3078"><vh>test_completing_in_uncomplete_try_blocks</vh></v>
<v t="ekr.20080516150804.3079"><vh>test_completing_in_uncomplete_try_blocks_in_functions</vh></v>
<v t="ekr.20080516150804.3080"><vh>test_already_complete_try_blocks_with_finally</vh></v>
<v t="ekr.20080516150804.3081"><vh>test_already_complete_try_blocks_with_finally2</vh></v>
<v t="ekr.20080516150804.3082"><vh>test_already_complete_try_blocks_with_except</vh></v>
<v t="ekr.20080516150804.3083"><vh>test_already_complete_try_blocks_with_except2</vh></v>
<v t="ekr.20080516150804.3084"><vh>test_completing_ifs_in_uncomplete_try_blocks</vh></v>
<v t="ekr.20080516150804.3085"><vh>test_completing_ifs_in_uncomplete_try_blocks2</vh></v>
<v t="ekr.20080516150804.3086"><vh>test_completing_excepts_in_uncomplete_try_blocks</vh></v>
<v t="ekr.20080516150804.3087"><vh>test_and_normal_complete_blocks_and_single_fixing</vh></v>
<v t="ekr.20080516150804.3088"><vh>test_nested_blocks</vh></v>
<v t="ekr.20080516150804.3089"><vh>test_proposing_function_keywords_when_calling</vh></v>
<v t="ekr.20080516150804.3090"><vh>test_proposing_function_keywords_when_calling_for_non_functions</vh></v>
<v t="ekr.20080516150804.3091"><vh>test_proposing_function_keywords_when_calling_extra_spaces</vh></v>
<v t="ekr.20080516150804.3092"><vh>test_proposing_function_keywords_when_calling_on_second_argument</vh></v>
<v t="ekr.20080516150804.3093"><vh>test_proposing_function_keywords_when_calling_not_proposing_args</vh></v>
<v t="ekr.20080516150804.3094"><vh>test_proposing_function_keywords_when_calling_with_no_nothing_after_parens</vh></v>
<v t="ekr.20080516150804.3095"><vh>test_proposing_function_keywords_when_calling_with_no_nothing_after_parens2</vh></v>
<v t="ekr.20080516150804.3096"><vh>test_codeassists_before_opening_of_parens</vh></v>
<v t="ekr.20080516150804.3097"><vh>test_codeassist_before_single_line_indents</vh></v>
<v t="ekr.20080516150804.3098"><vh>test_codeassist_before_line_indents_in_a_blank_line</vh></v>
<v t="ekr.20080516150804.3099"><vh>test_simple_get_calltips</vh></v>
<v t="ekr.20080516150804.3100"><vh>test_get_calltips_for_classes</vh></v>
<v t="ekr.20080516150804.3101"><vh>test_get_calltips_for_objects_with_call</vh></v>
<v t="ekr.20080516150804.3102"><vh>test_get_calltips_and_including_module_name</vh></v>
<v t="ekr.20080516150804.3103"><vh>test_get_calltips_and_including_module_name</vh></v>
</v>
<v t="ekr.20080516150804.3104"><vh>class CodeAssistInProjectsTest</vh>
<v t="ekr.20080516150804.3105"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3106"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3107"><vh>_assist</vh></v>
<v t="ekr.20080516150804.3108"><vh>assert_completion_in_result</vh></v>
<v t="ekr.20080516150804.3109"><vh>assert_completion_not_in_result</vh></v>
<v t="ekr.20080516150804.3110"><vh>test_simple_import</vh></v>
<v t="ekr.20080516150804.3111"><vh>test_from_import_class</vh></v>
<v t="ekr.20080516150804.3112"><vh>test_from_import_function</vh></v>
<v t="ekr.20080516150804.3113"><vh>test_from_import_variable</vh></v>
<v t="ekr.20080516150804.3114"><vh>test_from_imports_inside_functions</vh></v>
<v t="ekr.20080516150804.3115"><vh>test_from_import_only_imports_imported</vh></v>
<v t="ekr.20080516150804.3116"><vh>test_from_import_star</vh></v>
<v t="ekr.20080516150804.3117"><vh>test_from_import_star2</vh></v>
<v t="ekr.20080516150804.3118"><vh>test_from_import_star_not_imporing_underlined</vh></v>
<v t="ekr.20080516150804.3119"><vh>test_from_package_import_mod</vh></v>
<v t="ekr.20080516150804.3120"><vh>test_completing_after_dot</vh></v>
<v t="ekr.20080516150804.3121"><vh>test_completing_after_multiple_dots</vh></v>
<v t="ekr.20080516150804.3122"><vh>test_completing_after_self_dot</vh></v>
<v t="ekr.20080516150804.3123"><vh>test_result_start_offset_for_dotted_completions</vh></v>
<v t="ekr.20080516150804.3124"><vh>test_backslash_after_dots</vh></v>
<v t="ekr.20080516150804.3125"><vh>test_not_proposing_global_names_after_dot</vh></v>
<v t="ekr.20080516150804.3126"><vh>test_assist_on_relative_imports</vh></v>
<v t="ekr.20080516150804.3127"><vh>test_get_location_on_relative_imports</vh></v>
<v t="ekr.20080516150804.3128"><vh>test_get_definition_location_for_builtins</vh></v>
<v t="ekr.20080516150804.3129"><vh>test_get_doc_on_relative_imports</vh></v>
<v t="ekr.20080516150804.3130"><vh>test_get_doc_on_from_import_module</vh></v>
<v t="ekr.20080516150804.3131"><vh>test_fixing_errors_with_maxfixes_in_resources</vh></v>
<v t="ekr.20080516150804.3132"><vh>test_completing_names_after_from_import</vh></v>
<v t="ekr.20080516150804.3133"><vh>test_completing_names_after_from_import_and_sorted_proposals</vh></v>
<v t="ekr.20080516150804.3134"><vh>test_completing_names_after_from_import2</vh></v>
<v t="ekr.20080516150804.3135"><vh>test_starting_expression</vh></v>
</v>
<v t="ekr.20080516150804.3136"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3137"><vh>ropetest\contrib\findittest.py</vh>
<v t="ekr.20080516150804.3138"><vh>findittest declarations</vh></v>
<v t="ekr.20080516150804.3139"><vh>class FindItTest</vh>
<v t="ekr.20080516150804.3140"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3141"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3142"><vh>test_finding_occurrences</vh></v>
<v t="ekr.20080516150804.3143"><vh>test_finding_occurrences_in_more_than_one_module</vh></v>
<v t="ekr.20080516150804.3144"><vh>test_finding_occurrences_matching_when_unsure</vh></v>
<v t="ekr.20080516150804.3145"><vh>test_find_occurrences_resources_parameter</vh></v>
<v t="ekr.20080516150804.3146"><vh>test_find_occurrences_and_class_hierarchies</vh></v>
<v t="ekr.20080516150804.3147"><vh>test_trivial_find_implementations</vh></v>
<v t="ekr.20080516150804.3148"><vh>test_find_implementations_and_not_returning_parents</vh></v>
<v t="ekr.20080516150804.3149"><vh>test_find_implementations_real_implementation</vh></v>
<v t="ekr.20080516150804.3150"><vh>test_find_implementations_real_implementation</vh></v>
</v>
<v t="ekr.20080516150804.3151"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3152"><vh>ropetest\contrib\generatetest.py</vh>
<v t="ekr.20080516150804.3153"><vh>generatetest declarations</vh></v>
<v t="ekr.20080516150804.3154"><vh>class GenerateTest</vh>
<v t="ekr.20080516150804.3155"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3156"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3157"><vh>_get_generate</vh></v>
<v t="ekr.20080516150804.3158"><vh>_get_generate_class</vh></v>
<v t="ekr.20080516150804.3159"><vh>_get_generate_module</vh></v>
<v t="ekr.20080516150804.3160"><vh>_get_generate_package</vh></v>
<v t="ekr.20080516150804.3161"><vh>_get_generate_function</vh></v>
<v t="ekr.20080516150804.3162"><vh>test_getting_location</vh></v>
<v t="ekr.20080516150804.3163"><vh>test_generating_variable</vh></v>
<v t="ekr.20080516150804.3164"><vh>test_generating_variable_inserting_before_statement</vh></v>
<v t="ekr.20080516150804.3165"><vh>test_generating_variable_in_local_scopes</vh></v>
<v t="ekr.20080516150804.3166"><vh>test_generating_variable_in_other_modules</vh></v>
<v t="ekr.20080516150804.3167"><vh>test_generating_variable_in_classes</vh></v>
<v t="ekr.20080516150804.3168"><vh>test_generating_variable_in_classes_removing_pass</vh></v>
<v t="ekr.20080516150804.3169"><vh>test_generating_variable_in_packages</vh></v>
<v t="ekr.20080516150804.3170"><vh>test_generating_classes</vh></v>
<v t="ekr.20080516150804.3171"><vh>test_generating_modules</vh></v>
<v t="ekr.20080516150804.3172"><vh>test_generating_packages</vh></v>
<v t="ekr.20080516150804.3173"><vh>test_generating_function</vh></v>
<v t="ekr.20080516150804.3174"><vh>test_generating_modules_with_empty_primary</vh></v>
<v t="ekr.20080516150804.3175"><vh>test_generating_variable_already_exists</vh></v>
<v t="ekr.20080516150804.3176"><vh>test_generating_variable_primary_cannot_be_determined</vh></v>
<v t="ekr.20080516150804.3177"><vh>test_generating_modules_when_already_exists</vh></v>
<v t="ekr.20080516150804.3178"><vh>test_generating_static_methods</vh></v>
<v t="ekr.20080516150804.3179"><vh>test_generating_methods</vh></v>
<v t="ekr.20080516150804.3180"><vh>test_generating_constructors</vh></v>
<v t="ekr.20080516150804.3181"><vh>test_generating_calls</vh></v>
<v t="ekr.20080516150804.3182"><vh>test_generating_calls_in_other_modules</vh></v>
<v t="ekr.20080516150804.3183"><vh>test_generating_function_handling_arguments</vh></v>
<v t="ekr.20080516150804.3184"><vh>test_generating_function_handling_keyword_xarguments</vh></v>
<v t="ekr.20080516150804.3185"><vh>test_generating_function_handling_arguments_better_naming</vh></v>
<v t="ekr.20080516150804.3186"><vh>test_generating_variable_in_other_modules2</vh></v>
<v t="ekr.20080516150804.3187"><vh>test_generating_function_in_a_suite</vh></v>
<v t="ekr.20080516150804.3188"><vh>test_generating_function_in_a_suite_in_a_function</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3189"><vh>ropetest\contrib\__init__.py</vh>
<v t="ekr.20080516150804.3190"><vh>__init__ declarations</vh></v>
<v t="ekr.20080516150804.3191"><vh>suite</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3192"><vh>rope-0.8.2\ropetest\refactor</vh>
<v t="ekr.20080516150804.3193"><vh>ropetest\refactor\change_signature_test.py</vh>
<v t="ekr.20080516150804.3194"><vh>change_signature_test declarations</vh></v>
<v t="ekr.20080516150804.3195"><vh>class ChangeSignatureTest</vh>
<v t="ekr.20080516150804.3196"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3197"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3198"><vh>test_normalizing_parameters_for_trivial_case</vh></v>
<v t="ekr.20080516150804.3199"><vh>test_normalizing_parameters_for_trivial_case2</vh></v>
<v t="ekr.20080516150804.3200"><vh>test_normalizing_parameters_for_unneeded_keyword</vh></v>
<v t="ekr.20080516150804.3201"><vh>test_normalizing_parameters_for_unneeded_keyword_for_methods</vh></v>
<v t="ekr.20080516150804.3202"><vh>test_normalizing_parameters_for_unsorted_keyword</vh></v>
<v t="ekr.20080516150804.3203"><vh>test_raising_exceptions_for_non_functions</vh></v>
<v t="ekr.20080516150804.3204"><vh>test_normalizing_parameters_for_args_parameter</vh></v>
<v t="ekr.20080516150804.3205"><vh>test_normalizing_parameters_for_args_parameter_and_keywords</vh></v>
<v t="ekr.20080516150804.3206"><vh>test_normalizing_functions_from_other_modules</vh></v>
<v t="ekr.20080516150804.3207"><vh>test_normalizing_parameters_for_keyword_parameters</vh></v>
<v t="ekr.20080516150804.3208"><vh>test_removing_arguments</vh></v>
<v t="ekr.20080516150804.3209"><vh>test_removing_arguments_with_multiple_args</vh></v>
<v t="ekr.20080516150804.3210"><vh>test_removing_arguments_passed_as_keywords</vh></v>
<v t="ekr.20080516150804.3211"><vh>test_removing_arguments_with_defaults</vh></v>
<v t="ekr.20080516150804.3212"><vh>test_removing_arguments_star_args</vh></v>
<v t="ekr.20080516150804.3213"><vh>test_removing_keyword_arg</vh></v>
<v t="ekr.20080516150804.3214"><vh>test_removing_keyword_arg2</vh></v>
<v t="ekr.20080516150804.3215"><vh>xxx_test_removing_arguments_star_args2</vh></v>
<v t="ekr.20080516150804.3216"><vh>xxx_test_removing_arguments_star_args3</vh></v>
<v t="ekr.20080516150804.3217"><vh>test_adding_arguments_for_normal_args_changing_definition</vh></v>
<v t="ekr.20080516150804.3218"><vh>test_adding_arguments_for_normal_args_with_defaults</vh></v>
<v t="ekr.20080516150804.3219"><vh>test_adding_arguments_for_normal_args_changing_calls</vh></v>
<v t="ekr.20080516150804.3220"><vh>test_adding_arguments_for_normal_args_changing_calls_with_keywords</vh></v>
<v t="ekr.20080516150804.3221"><vh>test_adding_arguments_for_normal_args_changing_calls_with_no_value</vh></v>
<v t="ekr.20080516150804.3222"><vh>test_adding_duplicate_parameter_and_raising_exceptions</vh></v>
<v t="ekr.20080516150804.3223"><vh>test_inlining_default_arguments</vh></v>
<v t="ekr.20080516150804.3224"><vh>test_inlining_default_arguments2</vh></v>
<v t="ekr.20080516150804.3225"><vh>test_preserving_args_and_keywords_order</vh></v>
<v t="ekr.20080516150804.3226"><vh>test_change_order_for_only_one_parameter</vh></v>
<v t="ekr.20080516150804.3227"><vh>test_change_order_for_two_parameter</vh></v>
<v t="ekr.20080516150804.3228"><vh>test_reordering_multi_line_function_headers</vh></v>
<v t="ekr.20080516150804.3229"><vh>test_changing_order_with_static_params</vh></v>
<v t="ekr.20080516150804.3230"><vh>test_doing_multiple_changes</vh></v>
<v t="ekr.20080516150804.3231"><vh>test_doing_multiple_changes2</vh></v>
<v t="ekr.20080516150804.3232"><vh>test_changing_signature_in_subclasses</vh></v>
<v t="ekr.20080516150804.3233"><vh>test_differentiating_class_accesses_from_instance_accesses</vh></v>
<v t="ekr.20080516150804.3234"><vh>test_changing_signature_for_constructors</vh></v>
<v t="ekr.20080516150804.3235"><vh>test_changing_signature_for_constructors2</vh></v>
<v t="ekr.20080516150804.3236"><vh>test_changing_signature_for_constructors_when_using_super</vh></v>
<v t="ekr.20080516150804.3237"><vh>test_redordering_arguments_reported_by_mft</vh></v>
<v t="ekr.20080516150804.3238"><vh>test_resources_parameter</vh></v>
<v t="ekr.20080516150804.3239"><vh>test_reordering_and_automatic_defaults</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3240"><vh>ropetest\refactor\extracttest.py</vh>
<v t="ekr.20080516150804.3241"><vh>extracttest declarations</vh></v>
<v t="ekr.20080516150804.3242"><vh>class ExtractMethodTest</vh>
<v t="ekr.20080516150804.3243"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3244"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3245"><vh>do_extract_method</vh></v>
<v t="ekr.20080516150804.3246"><vh>do_extract_variable</vh></v>
<v t="ekr.20080516150804.3247"><vh>_convert_line_range_to_offset</vh></v>
<v t="ekr.20080516150804.3248"><vh>test_simple_extract_function</vh></v>
<v t="ekr.20080516150804.3249"><vh>test_extract_function_at_the_end_of_file</vh></v>
<v t="ekr.20080516150804.3250"><vh>test_extract_function_after_scope</vh></v>
<v t="ekr.20080516150804.3251"><vh>test_simple_extract_function_with_parameter</vh></v>
<v t="ekr.20080516150804.3252"><vh>test_not_unread_variables_as_parameter</vh></v>
<v t="ekr.20080516150804.3253"><vh>test_simple_extract_function_with_two_parameter</vh></v>
<v t="ekr.20080516150804.3254"><vh>test_simple_extract_function_with_return_value</vh></v>
<v t="ekr.20080516150804.3255"><vh>test_extract_function_with_multiple_return_values</vh></v>
<v t="ekr.20080516150804.3256"><vh>test_simple_extract_method</vh></v>
<v t="ekr.20080516150804.3257"><vh>test_extract_method_with_args_and_returns</vh></v>
<v t="ekr.20080516150804.3258"><vh>test_extract_method_with_self_as_argument</vh></v>
<v t="ekr.20080516150804.3259"><vh>test_extract_method_with_multiple_methods</vh></v>
<v t="ekr.20080516150804.3260"><vh>test_extract_function_with_function_returns</vh></v>
<v t="ekr.20080516150804.3261"><vh>test_simple_extract_global_function</vh></v>
<v t="ekr.20080516150804.3262"><vh>test_extract_global_function_inside_ifs</vh></v>
<v t="ekr.20080516150804.3263"><vh>test_extract_function_while_inner_function_reads</vh></v>
<v t="ekr.20080516150804.3264"><vh>test_extract_method_bad_range</vh></v>
<v t="ekr.20080516150804.3265"><vh>test_extract_method_bad_range2</vh></v>
<v t="ekr.20080516150804.3266"><vh>test_extract_method_containing_return</vh></v>
<v t="ekr.20080516150804.3267"><vh>test_extract_method_containing_yield</vh></v>
<v t="ekr.20080516150804.3268"><vh>test_extract_method_containing_uncomplete_lines</vh></v>
<v t="ekr.20080516150804.3269"><vh>test_extract_method_containing_uncomplete_lines2</vh></v>
<v t="ekr.20080516150804.3270"><vh>test_extract_function_and_argument_as_paramenter</vh></v>
<v t="ekr.20080516150804.3271"><vh>test_extract_function_and_end_as_the_start_of_a_line</vh></v>
<v t="ekr.20080516150804.3272"><vh>test_extract_function_and_indented_blocks</vh></v>
<v t="ekr.20080516150804.3273"><vh>test_extract_method_and_multi_line_headers</vh></v>
<v t="ekr.20080516150804.3274"><vh>test_single_line_extract_function</vh></v>
<v t="ekr.20080516150804.3275"><vh>test_single_line_extract_function2</vh></v>
<v t="ekr.20080516150804.3276"><vh>test_single_line_extract_method_and_logical_lines</vh></v>
<v t="ekr.20080516150804.3277"><vh>test_single_line_extract_method_and_logical_lines2</vh></v>
<v t="ekr.20080516150804.3278"><vh>test_single_line_extract_method</vh></v>
<v t="ekr.20080516150804.3279"><vh>test_single_line_extract_function_if_condition</vh></v>
<v t="ekr.20080516150804.3280"><vh>test_unneeded_params</vh></v>
<v t="ekr.20080516150804.3281"><vh>test_breaks_and_continues_inside_loops</vh></v>
<v t="ekr.20080516150804.3282"><vh>test_breaks_and_continues_outside_loops</vh></v>
<v t="ekr.20080516150804.3283"><vh>test_variable_writes_followed_by_variable_reads_after_extraction</vh></v>
<v t="ekr.20080516150804.3284"><vh>test_variable_writes_followed_by_variable_reads_inside_extraction</vh></v>
<v t="ekr.20080516150804.3285"><vh>test_extract_variable</vh></v>
<v t="ekr.20080516150804.3286"><vh>test_extract_variable_multiple_lines</vh></v>
<v t="ekr.20080516150804.3287"><vh>test_extract_variable_in_the_middle_of_statements</vh></v>
<v t="ekr.20080516150804.3288"><vh>test_extract_variable_for_a_tuple</vh></v>
<v t="ekr.20080516150804.3289"><vh>test_extract_variable_for_a_string</vh></v>
<v t="ekr.20080516150804.3290"><vh>test_extract_variable_inside_ifs</vh></v>
<v t="ekr.20080516150804.3291"><vh>test_extract_variable_inside_ifs_and_logical_lines</vh></v>
<v t="ekr.20080516150804.3292"><vh>xxx_test_extract_variable_for_a_subexpression</vh></v>
<v t="ekr.20080516150804.3293"><vh>test_extract_variable_starting_from_the_start_of_the_line</vh></v>
<v t="ekr.20080516150804.3294"><vh>test_extract_variable_on_the_last_line_of_a_function</vh></v>
<v t="ekr.20080516150804.3295"><vh>test_extract_variable_on_the_indented_function_statement</vh></v>
<v t="ekr.20080516150804.3296"><vh>test_extract_method_on_the_last_line_of_a_function</vh></v>
<v t="ekr.20080516150804.3297"><vh>test_raising_exception_when_on_incomplete_variables</vh></v>
<v t="ekr.20080516150804.3298"><vh>test_raising_exception_when_on_incomplete_variables_on_end</vh></v>
<v t="ekr.20080516150804.3299"><vh>test_raising_exception_on_bad_parens</vh></v>
<v t="ekr.20080516150804.3300"><vh>test_raising_exception_on_bad_operators</vh></v>
<v t="ekr.20080516150804.3301"><vh>xxx_test_raising_exception_on_function_parens</vh></v>
<v t="ekr.20080516150804.3302"><vh>test_extract_method_and_extra_blank_lines</vh></v>
<v t="ekr.20080516150804.3303"><vh>test_variable_writes_in_the_same_line_as_variable_read</vh></v>
<v t="ekr.20080516150804.3304"><vh>test_variable_writes_in_the_same_line_as_variable_read2</vh></v>
<v t="ekr.20080516150804.3305"><vh>test_variable_and_similar_expressions</vh></v>
<v t="ekr.20080516150804.3306"><vh>test_definition_should_appear_before_the_first_use</vh></v>
<v t="ekr.20080516150804.3307"><vh>test_extract_method_and_similar_expressions</vh></v>
<v t="ekr.20080516150804.3308"><vh>test_simple_extract_method_and_similar_statements</vh></v>
<v t="ekr.20080516150804.3309"><vh>test_extract_method_and_similar_statements2</vh></v>
<v t="ekr.20080516150804.3310"><vh>test_extract_method_and_similar_statements_where_return_is_different</vh></v>
<v t="ekr.20080516150804.3311"><vh>test_definition_should_appear_where_it_is_visible</vh></v>
<v t="ekr.20080516150804.3312"><vh>test_extract_variable_and_similar_statements_in_classes</vh></v>
<v t="ekr.20080516150804.3313"><vh>test_extract_method_in_staticmethods</vh></v>
<v t="ekr.20080516150804.3314"><vh>test_extract_normal_method_with_staticmethods</vh></v>
<v t="ekr.20080516150804.3315"><vh>test_extract_variable_with_no_new_lines_at_the_end</vh></v>
<v t="ekr.20080516150804.3316"><vh>test_extract_method_containing_return_in_functions</vh></v>
<v t="ekr.20080516150804.3317"><vh>test_extract_method_and_varying_first_parameter</vh></v>
<v t="ekr.20080516150804.3318"><vh>test_extract_method_when_an_attribute_exists_in_function_scope</vh></v>
<v t="ekr.20080516150804.3319"><vh>test_global_option_for_extract_method</vh></v>
<v t="ekr.20080516150804.3320"><vh>test_global_extract_method</vh></v>
<v t="ekr.20080516150804.3321"><vh>test_extract_method_with_multiple_methods</vh></v>
<v t="ekr.20080516150804.3322"><vh>test_where_to_seach_when_extracting_global_names</vh></v>
<v t="ekr.20080516150804.3323"><vh>test_extracting_pieces_with_distinct_temp_names</vh></v>
<v t="ekr.20080516150804.3324"><vh>test_extracting_methods_in_global_functions_should_be_global</vh></v>
<v t="ekr.20080516150804.3325"><vh>test_extracting_methods_in_global_functions_should_be_global</vh></v>
<v t="ekr.20080516150804.3326"><vh>test_extract_method_and_try_blocks</vh></v>
<v t="ekr.20080516150804.3327"><vh>test_extract_and_not_passing_global_functions</vh></v>
<v t="ekr.20080516150804.3328"><vh>test_extracting_with_only_one_return</vh></v>
<v t="ekr.20080516150804.3329"><vh>test_extracting_variable_and_implicit_continuations</vh></v>
<v t="ekr.20080516150804.3330"><vh>test_extracting_method_and_implicit_continuations</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3331"><vh>ropetest\refactor\importutilstest.py</vh>
<v t="ekr.20080516150804.3332"><vh>importutilstest declarations</vh></v>
<v t="ekr.20080516150804.3333"><vh>class ImportUtilsTest</vh>
<v t="ekr.20080516150804.3334"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3335"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3336"><vh>test_get_import_for_module</vh></v>
<v t="ekr.20080516150804.3337"><vh>test_get_import_for_module_in_nested_modules</vh></v>
<v t="ekr.20080516150804.3338"><vh>test_get_import_for_module_in_init_dot_py</vh></v>
<v t="ekr.20080516150804.3339"><vh>test_get_from_import_for_module</vh></v>
<v t="ekr.20080516150804.3340"><vh>test_get_from_import_for_module_in_nested_modules</vh></v>
<v t="ekr.20080516150804.3341"><vh>test_get_from_import_for_module_in_init_dot_py</vh></v>
<v t="ekr.20080516150804.3342"><vh>test_get_import_statements</vh></v>
<v t="ekr.20080516150804.3343"><vh>test_get_import_statements_with_alias</vh></v>
<v t="ekr.20080516150804.3344"><vh>test_get_import_statements_for_froms</vh></v>
<v t="ekr.20080516150804.3345"><vh>test_get_multi_line_import_statements_for_froms</vh></v>
<v t="ekr.20080516150804.3346"><vh>test_get_import_statements_for_from_star</vh></v>
<v t="ekr.20080516150804.3347"><vh>test_get_import_statements_for_new_relatives</vh></v>
<v t="ekr.20080516150804.3348"><vh>test_ignoring_indented_imports</vh></v>
<v t="ekr.20080516150804.3349"><vh>test_import_get_names</vh></v>
<v t="ekr.20080516150804.3350"><vh>test_import_get_names_with_alias</vh></v>
<v t="ekr.20080516150804.3351"><vh>test_import_get_names_with_alias2</vh></v>
<v t="ekr.20080516150804.3352"><vh>test_empty_getting_used_imports</vh></v>
<v t="ekr.20080516150804.3353"><vh>test_empty_getting_used_imports2</vh></v>
<v t="ekr.20080516150804.3354"><vh>test_simple_getting_used_imports</vh></v>
<v t="ekr.20080516150804.3355"><vh>test_simple_getting_used_imports2</vh></v>
<v t="ekr.20080516150804.3356"><vh>test_getting_used_imports_for_nested_scopes</vh></v>
<v t="ekr.20080516150804.3357"><vh>test_getting_used_imports_for_nested_scopes2</vh></v>
<v t="ekr.20080516150804.3358"><vh>test_empty_removing_unused_imports</vh></v>
<v t="ekr.20080516150804.3359"><vh>test_simple_removing_unused_imports</vh></v>
<v t="ekr.20080516150804.3360"><vh>test_simple_removing_unused_imports_for_froms</vh></v>
<v t="ekr.20080516150804.3361"><vh>test_simple_removing_unused_imports_for_from_stars</vh></v>
<v t="ekr.20080516150804.3362"><vh>test_simple_removing_unused_imports_for_nested_modules</vh></v>
<v t="ekr.20080516150804.3363"><vh>test_removing_unused_imports_and_functions_of_the_same_name</vh></v>
<v t="ekr.20080516150804.3364"><vh>test_removing_unused_imports_for_from_import_with_as</vh></v>
<v t="ekr.20080516150804.3365"><vh>test_not_removing_imports_that_conflict_with_class_names</vh></v>
<v t="ekr.20080516150804.3366"><vh>test_adding_imports</vh></v>
<v t="ekr.20080516150804.3367"><vh>test_adding_from_imports</vh></v>
<v t="ekr.20080516150804.3368"><vh>test_adding_to_star_imports</vh></v>
<v t="ekr.20080516150804.3369"><vh>test_adding_star_imports</vh></v>
<v t="ekr.20080516150804.3370"><vh>test_adding_imports_and_preserving_spaces_after_imports</vh></v>
<v t="ekr.20080516150804.3371"><vh>test_not_changing_the_format_of_unchanged_imports</vh></v>
<v t="ekr.20080516150804.3372"><vh>test_not_changing_the_format_of_unchanged_imports2</vh></v>
<v t="ekr.20080516150804.3373"><vh>test_removing_unused_imports_and_reoccuring_names</vh></v>
<v t="ekr.20080516150804.3374"><vh>test_removing_unused_imports_and_reoccuring_names2</vh></v>
<v t="ekr.20080516150804.3375"><vh>test_removing_unused_imports_and_common_packages</vh></v>
<v t="ekr.20080516150804.3376"><vh>test_removing_unused_imports_and_common_packages_reversed</vh></v>
<v t="ekr.20080516150804.3377"><vh>test_removing_unused_imports_and_common_packages2</vh></v>
<v t="ekr.20080516150804.3378"><vh>test_removing_unused_imports_and_froms</vh></v>
<v t="ekr.20080516150804.3379"><vh>test_removing_unused_imports_and_froms2</vh></v>
<v t="ekr.20080516150804.3380"><vh>test_removing_unused_imports_and_froms3</vh></v>
<v t="ekr.20080516150804.3381"><vh>test_removing_unused_imports_and_froms4</vh></v>
<v t="ekr.20080516150804.3382"><vh>test_removing_unused_imports_and_getting_attributes</vh></v>
<v t="ekr.20080516150804.3383"><vh>test_removing_unused_imports_function_parameters</vh></v>
<v t="ekr.20080516150804.3384"><vh>test_trivial_expanding_star_imports</vh></v>
<v t="ekr.20080516150804.3385"><vh>test_expanding_star_imports</vh></v>
<v t="ekr.20080516150804.3386"><vh>test_removing_duplicate_imports</vh></v>
<v t="ekr.20080516150804.3387"><vh>test_removing_duplicates_and_reoccuring_names</vh></v>
<v t="ekr.20080516150804.3388"><vh>test_removing_duplicate_imports_for_froms</vh></v>
<v t="ekr.20080516150804.3389"><vh>test_transforming_froms_to_normal_changing_imports</vh></v>
<v t="ekr.20080516150804.3390"><vh>test_transforming_froms_to_normal_changing_occurances</vh></v>
<v t="ekr.20080516150804.3391"><vh>test_transforming_froms_to_normal_for_multi_imports</vh></v>
<v t="ekr.20080516150804.3392"><vh>test_transforming_froms_to_normal_for_multi_imports_inside_parens</vh></v>
<v t="ekr.20080516150804.3393"><vh>test_transforming_froms_to_normal_from_stars</vh></v>
<v t="ekr.20080516150804.3394"><vh>test_transforming_froms_to_normal_from_stars2</vh></v>
<v t="ekr.20080516150804.3395"><vh>test_transforming_froms_to_normal_from_with_alias</vh></v>
<v t="ekr.20080516150804.3396"><vh>test_transforming_froms_to_normal_for_relatives</vh></v>
<v t="ekr.20080516150804.3397"><vh>test_transforming_froms_to_normal_for_os_path</vh></v>
<v t="ekr.20080516150804.3398"><vh>test_transform_relatives_imports_to_absolute_imports_doing_nothing</vh></v>
<v t="ekr.20080516150804.3399"><vh>test_transform_relatives_to_absolute_imports_for_normal_imports</vh></v>
<v t="ekr.20080516150804.3400"><vh>test_transform_relatives_imports_to_absolute_imports_for_froms</vh></v>
<v t="ekr.20080516150804.3401"><vh>test_transform_relatives_imports_to_absolute_imports_for_new_relatives</vh></v>
<v t="ekr.20080516150804.3402"><vh>test_transform_relatives_to_absolute_imports_for_normal_imports2</vh></v>
<v t="ekr.20080516150804.3403"><vh>test_transform_relatives_to_absolute_imports_for_aliases</vh></v>
<v t="ekr.20080516150804.3404"><vh>test_organizing_imports</vh></v>
<v t="ekr.20080516150804.3405"><vh>test_removing_self_imports</vh></v>
<v t="ekr.20080516150804.3406"><vh>test_removing_self_imports2</vh></v>
<v t="ekr.20080516150804.3407"><vh>test_removing_self_imports_with_as</vh></v>
<v t="ekr.20080516150804.3408"><vh>test_removing_self_imports_for_froms</vh></v>
<v t="ekr.20080516150804.3409"><vh>test_removing_self_imports_for_froms_with_as</vh></v>
<v t="ekr.20080516150804.3410"><vh>test_removing_self_imports_for_froms2</vh></v>
<v t="ekr.20080516150804.3411"><vh>test_removing_self_imports_for_froms3</vh></v>
<v t="ekr.20080516150804.3412"><vh>test_removing_self_imports_for_froms4</vh></v>
<v t="ekr.20080516150804.3413"><vh>test_removing_self_imports_with_no_dot_after_mod</vh></v>
<v t="ekr.20080516150804.3414"><vh>test_removing_self_imports_with_no_dot_after_mod2</vh></v>
<v t="ekr.20080516150804.3415"><vh>test_removing_self_imports_for_from_import_star</vh></v>
<v t="ekr.20080516150804.3416"><vh>test_not_removing_future_imports</vh></v>
<v t="ekr.20080516150804.3417"><vh>test_sorting_empty_imports</vh></v>
<v t="ekr.20080516150804.3418"><vh>test_sorting_one_import</vh></v>
<v t="ekr.20080516150804.3419"><vh>test_sorting_imports_alphabetically</vh></v>
<v t="ekr.20080516150804.3420"><vh>test_sorting_imports_and_froms</vh></v>
<v t="ekr.20080516150804.3421"><vh>test_sorting_imports_and_standard_modules</vh></v>
<v t="ekr.20080516150804.3422"><vh>test_sorting_imports_and_standard_modules2</vh></v>
<v t="ekr.20080516150804.3423"><vh>test_sorting_only_standard_modules</vh></v>
<v t="ekr.20080516150804.3424"><vh>test_sorting_third_party</vh></v>
<v t="ekr.20080516150804.3425"><vh>test_sorting_only_third_parties</vh></v>
<v t="ekr.20080516150804.3426"><vh>test_simple_handling_long_imports</vh></v>
<v t="ekr.20080516150804.3427"><vh>test_handling_long_imports_for_many_dots</vh></v>
<v t="ekr.20080516150804.3428"><vh>test_handling_long_imports_for_their_length</vh></v>
<v t="ekr.20080516150804.3429"><vh>test_handling_long_imports_for_many_dots2</vh></v>
<v t="ekr.20080516150804.3430"><vh>test_handling_long_imports_with_one_letter_last</vh></v>
<v t="ekr.20080516150804.3431"><vh>test_empty_removing_unused_imports_and_eating_blank_lines</vh></v>
<v t="ekr.20080516150804.3432"><vh>test_sorting_imports_moving_to_top</vh></v>
<v t="ekr.20080516150804.3433"><vh>test_sorting_imports_moving_to_top2</vh></v>
<v t="ekr.20080516150804.3434"><vh>test_sorting_imports_moving_to_top_and_module_docs</vh></v>
<v t="ekr.20080516150804.3435"><vh>test_sorting_future_imports</vh></v>
<v t="ekr.20080516150804.3436"><vh>test_customized_import_organization</vh></v>
<v t="ekr.20080516150804.3437"><vh>test_customized_import_organization2</vh></v>
<v t="ekr.20080516150804.3438"><vh>test_customized_import_organization3</vh></v>
<v t="ekr.20080516150804.3439"><vh>test_trivial_filtered_expand_stars</vh></v>
<v t="ekr.20080516150804.3440"><vh>_line_filter</vh></v>
<v t="ekr.20080516150804.3441"><vh>test_filtered_expand_stars</vh></v>
<v t="ekr.20080516150804.3442"><vh>test_filtered_relative_to_absolute</vh></v>
<v t="ekr.20080516150804.3443"><vh>test_filtered_froms_to_normals</vh></v>
<v t="ekr.20080516150804.3444"><vh>test_filtered_froms_to_normals2</vh></v>
<v t="ekr.20080516150804.3445"><vh>test_filtered_handle_long_imports</vh></v>
<v t="ekr.20080516150804.3446"><vh>test_filtering_and_import_actions_with_more_than_one_phase</vh></v>
<v t="ekr.20080516150804.3447"><vh>test_non_existent_module_and_used_imports</vh></v>
</v>
<v t="ekr.20080516150804.3448"><vh>class AddImportTest</vh>
<v t="ekr.20080516150804.3449"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3450"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3451"><vh>test_normal_imports</vh></v>
<v t="ekr.20080516150804.3452"><vh>test_not_reimporting_a_name</vh></v>
<v t="ekr.20080516150804.3453"><vh>test_adding_import_when_siblings_are_imported</vh></v>
<v t="ekr.20080516150804.3454"><vh>test_adding_import_when_the_package_is_imported</vh></v>
<v t="ekr.20080516150804.3455"><vh>test_adding_import_for_modules_instead_of_names</vh></v>
<v t="ekr.20080516150804.3456"><vh>test_adding_import_for_modules_with_normal_duplicate_imports</vh></v>
</v>
<v t="ekr.20080516150804.3457"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3458"><vh>ropetest\refactor\inlinetest.py</vh>
<v t="ekr.20080516150804.3459"><vh>inlinetest declarations</vh></v>
<v t="ekr.20080516150804.3460"><vh>class InlineTest</vh>
<v t="ekr.20080516150804.3461"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3462"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3463"><vh>_inline</vh></v>
<v t="ekr.20080516150804.3464"><vh>_inline2</vh></v>
<v t="ekr.20080516150804.3465"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.3466"><vh>test_empty_case</vh></v>
<v t="ekr.20080516150804.3467"><vh>test_long_definition</vh></v>
<v t="ekr.20080516150804.3468"><vh>test_explicit_continuation</vh></v>
<v t="ekr.20080516150804.3469"><vh>test_implicit_continuation</vh></v>
<v t="ekr.20080516150804.3470"><vh>test_inlining_at_the_end_of_input</vh></v>
<v t="ekr.20080516150804.3471"><vh>test_on_classes</vh></v>
<v t="ekr.20080516150804.3472"><vh>test_multiple_assignments</vh></v>
<v t="ekr.20080516150804.3473"><vh>test_tuple_assignments</vh></v>
<v t="ekr.20080516150804.3474"><vh>test_on_unknown_vars</vh></v>
<v t="ekr.20080516150804.3475"><vh>test_attribute_inlining</vh></v>
<v t="ekr.20080516150804.3476"><vh>test_attribute_inlining2</vh></v>
<v t="ekr.20080516150804.3477"><vh>test_a_function_with_no_occurance</vh></v>
<v t="ekr.20080516150804.3478"><vh>test_a_function_with_no_occurance2</vh></v>
<v t="ekr.20080516150804.3479"><vh>test_replacing_calls_with_function_definition_in_other_modules</vh></v>
<v t="ekr.20080516150804.3480"><vh>test_replacing_calls_with_function_definition_in_other_modules2</vh></v>
<v t="ekr.20080516150804.3481"><vh>test_replacing_calls_with_method_definition_in_other_modules</vh></v>
<v t="ekr.20080516150804.3482"><vh>test_replacing_calls_with_function_definition_in_defining_module</vh></v>
<v t="ekr.20080516150804.3483"><vh>test_replacing_calls_with_function_definition_in_defining_module2</vh></v>
<v t="ekr.20080516150804.3484"><vh>test_replacing_calls_with_method_definition_in_defining_modules</vh></v>
<v t="ekr.20080516150804.3485"><vh>test_parameters_with_the_same_name_as_passed</vh></v>
<v t="ekr.20080516150804.3486"><vh>test_parameters_with_the_same_name_as_passed2</vh></v>
<v t="ekr.20080516150804.3487"><vh>test_simple_parameters_renaming</vh></v>
<v t="ekr.20080516150804.3488"><vh>test_simple_parameters_renaming_for_multiple_params</vh></v>
<v t="ekr.20080516150804.3489"><vh>test_parameters_renaming_for_passed_constants</vh></v>
<v t="ekr.20080516150804.3490"><vh>test_parameters_renaming_for_passed_statements</vh></v>
<v t="ekr.20080516150804.3491"><vh>test_simple_parameters_renaming_for_multiple_params_using_keywords</vh></v>
<v t="ekr.20080516150804.3492"><vh>test_simple_parameters_renaming_for_multiple_params_using_mixed_keywords</vh></v>
<v t="ekr.20080516150804.3493"><vh>test_simple_putting_in_default_arguments</vh></v>
<v t="ekr.20080516150804.3494"><vh>test_overriding_default_arguments</vh></v>
<v t="ekr.20080516150804.3495"><vh>test_badly_formatted_text</vh></v>
<v t="ekr.20080516150804.3496"><vh>test_passing_first_arguments_for_methods</vh></v>
<v t="ekr.20080516150804.3497"><vh>test_passing_first_arguments_for_methods2</vh></v>
<v t="ekr.20080516150804.3498"><vh>test_passing_first_arguments_for_methods3</vh></v>
<v t="ekr.20080516150804.3499"><vh>test_inlining_staticmethods</vh></v>
<v t="ekr.20080516150804.3500"><vh>test_static_methods2</vh></v>
<v t="ekr.20080516150804.3501"><vh>test_inlining_classmethods</vh></v>
<v t="ekr.20080516150804.3502"><vh>test_inlining_classmethods2</vh></v>
<v t="ekr.20080516150804.3503"><vh>test_simple_return_values_and_inlining_functions</vh></v>
<v t="ekr.20080516150804.3504"><vh>test_simple_return_values_and_inlining_lonely_functions</vh></v>
<v t="ekr.20080516150804.3505"><vh>test_empty_returns_and_inlining_lonely_functions</vh></v>
<v t="ekr.20080516150804.3506"><vh>test_multiple_returns</vh></v>
<v t="ekr.20080516150804.3507"><vh>test_multiple_returns_and_not_using_the_value</vh></v>
<v t="ekr.20080516150804.3508"><vh>test_raising_exception_for_list_arguments</vh></v>
<v t="ekr.20080516150804.3509"><vh>test_raising_exception_for_list_keywods</vh></v>
<v t="ekr.20080516150804.3510"><vh>test_function_parameters_and_returns_in_other_functions</vh></v>
<v t="ekr.20080516150804.3511"><vh>test_function_references_other_than_call</vh></v>
<v t="ekr.20080516150804.3512"><vh>test_function_referencing_itself</vh></v>
<v t="ekr.20080516150804.3513"><vh>test_recursive_functions</vh></v>
<v t="ekr.20080516150804.3514"><vh>xxx_test_inlining_function_default_parameters</vh></v>
<v t="ekr.20080516150804.3515"><vh>test_simple_inlining_after_extra_indented_lines</vh></v>
<v t="ekr.20080516150804.3516"><vh>test_inlining_a_function_with_pydoc</vh></v>
<v t="ekr.20080516150804.3517"><vh>test_inlining_methods</vh></v>
<v t="ekr.20080516150804.3518"><vh>test_simple_returns_with_backslashes</vh></v>
<v t="ekr.20080516150804.3519"><vh>test_a_function_with_pass_body</vh></v>
<v t="ekr.20080516150804.3520"><vh>test_inlining_the_last_method_of_a_class</vh></v>
<v t="ekr.20080516150804.3521"><vh>test_adding_needed_imports_in_the_dest_module</vh></v>
<v t="ekr.20080516150804.3522"><vh>test_adding_needed_imports_in_the_dest_module_removing_selfs</vh></v>
<v t="ekr.20080516150804.3523"><vh>test_handling_relative_imports_when_inlining</vh></v>
<v t="ekr.20080516150804.3524"><vh>test_adding_needed_imports_for_elements_in_source</vh></v>
<v t="ekr.20080516150804.3525"><vh>test_relative_imports_and_changing_inlining_body</vh></v>
<v t="ekr.20080516150804.3526"><vh>test_inlining_with_different_returns</vh></v>
<v t="ekr.20080516150804.3527"><vh>test_not_removing_definition_for_variables</vh></v>
<v t="ekr.20080516150804.3528"><vh>test_not_removing_definition_for_methods</vh></v>
<v t="ekr.20080516150804.3529"><vh>test_only_current_for_methods</vh></v>
<v t="ekr.20080516150804.3530"><vh>test_only_current_for_variables</vh></v>
<v t="ekr.20080516150804.3531"><vh>test_inlining_one_line_functions</vh></v>
<v t="ekr.20080516150804.3532"><vh>test_inlining_one_line_functions_with_breaks</vh></v>
<v t="ekr.20080516150804.3533"><vh>test_inlining_one_line_functions_with_breaks2</vh></v>
<v t="ekr.20080516150804.3534"><vh>test_resources_parameter</vh></v>
<v t="ekr.20080516150804.3535"><vh>test_inlining_parameters</vh></v>
</v>
<v t="ekr.20080516150804.3536"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3537"><vh>ropetest\refactor\movetest.py</vh>
<v t="ekr.20080516150804.3538"><vh>movetest declarations</vh></v>
<v t="ekr.20080516150804.3539"><vh>class MoveRefactoringTest</vh>
<v t="ekr.20080516150804.3540"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3541"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3542"><vh>_move</vh></v>
<v t="ekr.20080516150804.3543"><vh>test_simple_moving</vh></v>
<v t="ekr.20080516150804.3544"><vh>test_changing_other_modules_adding_normal_imports</vh></v>
<v t="ekr.20080516150804.3545"><vh>test_changing_other_modules_removing_from_imports</vh></v>
<v t="ekr.20080516150804.3546"><vh>test_changing_source_module</vh></v>
<v t="ekr.20080516150804.3547"><vh>test_changing_destination_module</vh></v>
<v t="ekr.20080516150804.3548"><vh>test_folder_destination</vh></v>
<v t="ekr.20080516150804.3549"><vh>test_raising_exception_for_moving_non_global_elements</vh></v>
<v t="ekr.20080516150804.3550"><vh>test_raising_exception_for_moving_global_elements_to_the_same_module</vh></v>
<v t="ekr.20080516150804.3551"><vh>test_moving_used_imports_to_destination_module</vh></v>
<v t="ekr.20080516150804.3552"><vh>test_moving_used_names_to_destination_module2</vh></v>
<v t="ekr.20080516150804.3553"><vh>test_moving_used_underlined_names_to_destination_module</vh></v>
<v t="ekr.20080516150804.3554"><vh>test_moving_and_used_relative_imports</vh></v>
<v t="ekr.20080516150804.3555"><vh>test_moving_modules</vh></v>
<v t="ekr.20080516150804.3556"><vh>test_moving_modules_and_removing_out_of_date_imports</vh></v>
<v t="ekr.20080516150804.3557"><vh>test_moving_modules_and_removing_out_of_date_froms</vh></v>
<v t="ekr.20080516150804.3558"><vh>test_moving_modules_and_removing_out_of_date_froms2</vh></v>
<v t="ekr.20080516150804.3559"><vh>test_moving_modules_and_relative_import</vh></v>
<v t="ekr.20080516150804.3560"><vh>test_moving_packages</vh></v>
<v t="ekr.20080516150804.3561"><vh>test_moving_modules_with_self_imports</vh></v>
<v t="ekr.20080516150804.3562"><vh>test_moving_funtions_to_imported_module</vh></v>
<v t="ekr.20080516150804.3563"><vh>test_moving_resources_using_move_module_refactoring</vh></v>
<v t="ekr.20080516150804.3564"><vh>test_moving_resources_using_move_module_for_packages</vh></v>
<v t="ekr.20080516150804.3565"><vh>test_moving_resources_using_move_module_for_init_dot_py</vh></v>
<v t="ekr.20080516150804.3566"><vh>test_moving_module_and_star_imports</vh></v>
<v t="ekr.20080516150804.3567"><vh>test_moving_module_and_not_removing_blanks_after_imports</vh></v>
<v t="ekr.20080516150804.3568"><vh>test_moving_module_refactoring_and_nonexistent_destinations</vh></v>
<v t="ekr.20080516150804.3569"><vh>test_moving_methods_choosing_the_correct_class</vh></v>
<v t="ekr.20080516150804.3570"><vh>test_moving_methods_getting_new_method_for_empty_methods</vh></v>
<v t="ekr.20080516150804.3571"><vh>test_moving_methods_getting_new_method_for_constant_methods</vh></v>
<v t="ekr.20080516150804.3572"><vh>test_moving_methods_getting_new_method_passing_simple_paremters</vh></v>
<v t="ekr.20080516150804.3573"><vh>test_moving_methods_getting_new_method_using_main_object</vh></v>
<v t="ekr.20080516150804.3574"><vh>test_moving_methods_getting_new_method_renaming_main_object</vh></v>
<v t="ekr.20080516150804.3575"><vh>test_moving_methods_gettin_new_method_with_keyword_arguments</vh></v>
<v t="ekr.20080516150804.3576"><vh>test_moving_methods_gettin_new_method_with_many_kinds_arguments</vh></v>
<v t="ekr.20080516150804.3577"><vh>test_moving_methods_getting_new_method_for_multi_line_methods</vh></v>
<v t="ekr.20080516150804.3578"><vh>test_moving_methods_getting_old_method_for_constant_methods</vh></v>
<v t="ekr.20080516150804.3579"><vh>test_moving_methods_getting_getting_changes_for_goal_class</vh></v>
<v t="ekr.20080516150804.3580"><vh>test_moving_methods_getting_getting_changes_for_goal_class2</vh></v>
<v t="ekr.20080516150804.3581"><vh>test_moving_methods_and_nonexistent_attributes</vh></v>
<v t="ekr.20080516150804.3582"><vh>test_unknown_attribute_type</vh></v>
<v t="ekr.20080516150804.3583"><vh>test_moving_methods_and_moving_used_imports</vh></v>
<v t="ekr.20080516150804.3584"><vh>test_moving_methods_getting_getting_changes_for_goal_class3</vh></v>
<v t="ekr.20080516150804.3585"><vh>test_moving_methods_and_source_class_with_parameters</vh></v>
<v t="ekr.20080516150804.3586"><vh>test_moving_globals_to_a_module_with_only_docstrings</vh></v>
<v t="ekr.20080516150804.3587"><vh>test_moving_globals_to_a_module_with_only_docstrings2</vh></v>
<v t="ekr.20080516150804.3588"><vh>test_moving_a_global_when_it_is_used_after_a_multiline_str</vh></v>
<v t="ekr.20080516150804.3589"><vh>test_raising_an_exception_when_moving_non_package_folders</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3590"><vh>ropetest\refactor\multiprojecttest.py</vh>
<v t="ekr.20080516150804.3591"><vh>multiprojecttest declarations</vh></v>
<v t="ekr.20080516150804.3592"><vh>class MultiProjectRefactoringTest</vh>
<v t="ekr.20080516150804.3593"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3594"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3595"><vh>test_trivial_rename</vh></v>
<v t="ekr.20080516150804.3596"><vh>test_rename</vh></v>
<v t="ekr.20080516150804.3597"><vh>test_move</vh></v>
<v t="ekr.20080516150804.3598"><vh>test_rename_from_the_project_not_containing_the_change</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3599"><vh>ropetest\refactor\patchedasttest.py</vh>
<v t="ekr.20080516150804.3600"><vh>patchedasttest declarations</vh></v>
<v t="ekr.20080516150804.3601"><vh>class PatchedASTTest</vh>
<v t="ekr.20080516150804.3602"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3603"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3604"><vh>test_integer_literals_and_region</vh></v>
<v t="ekr.20080516150804.3605"><vh>test_integer_literals_and_sorted_children</vh></v>
<v t="ekr.20080516150804.3606"><vh>test_ass_name_node</vh></v>
<v t="ekr.20080516150804.3607"><vh>test_assign_node</vh></v>
<v t="ekr.20080516150804.3608"><vh>test_add_node</vh></v>
<v t="ekr.20080516150804.3609"><vh>test_lshift_node</vh></v>
<v t="ekr.20080516150804.3610"><vh>test_and_node</vh></v>
<v t="ekr.20080516150804.3611"><vh>test_basic_closing_parens</vh></v>
<v t="ekr.20080516150804.3612"><vh>test_basic_opening_parens</vh></v>
<v t="ekr.20080516150804.3613"><vh>test_basic_opening_biway</vh></v>
<v t="ekr.20080516150804.3614"><vh>test_basic_opening_double</vh></v>
<v t="ekr.20080516150804.3615"><vh>test_handling_comments</vh></v>
<v t="ekr.20080516150804.3616"><vh>test_handling_parens_with_spaces</vh></v>
<v t="ekr.20080516150804.3617"><vh>test_handling_strings</vh></v>
<v t="ekr.20080516150804.3618"><vh>test_handling_implicit_string_concatenation</vh></v>
<v t="ekr.20080516150804.3619"><vh>test_handling_implicit_string_concatenation_line_breaks</vh></v>
<v t="ekr.20080516150804.3620"><vh>test_handling_explicit_string_concatenation_line_breaks</vh></v>
<v t="ekr.20080516150804.3621"><vh>test_not_concatenating_strings_on_separate_lines</vh></v>
<v t="ekr.20080516150804.3622"><vh>test_long_integer_literals</vh></v>
<v t="ekr.20080516150804.3623"><vh>test_complex_number_literals</vh></v>
<v t="ekr.20080516150804.3624"><vh>test_ass_attr_node</vh></v>
<v t="ekr.20080516150804.3625"><vh>test_ass_list_node</vh></v>
<v t="ekr.20080516150804.3626"><vh>test_ass_tuple</vh></v>
<v t="ekr.20080516150804.3627"><vh>test_ass_tuple2</vh></v>
<v t="ekr.20080516150804.3628"><vh>test_assert</vh></v>
<v t="ekr.20080516150804.3629"><vh>test_assert2</vh></v>
<v t="ekr.20080516150804.3630"><vh>test_aug_assign_node</vh></v>
<v t="ekr.20080516150804.3631"><vh>test_back_quotenode</vh></v>
<v t="ekr.20080516150804.3632"><vh>test_bitand</vh></v>
<v t="ekr.20080516150804.3633"><vh>test_bitor</vh></v>
<v t="ekr.20080516150804.3634"><vh>test_call_func</vh></v>
<v t="ekr.20080516150804.3635"><vh>test_call_func_and_keywords</vh></v>
<v t="ekr.20080516150804.3636"><vh>test_call_func_and_start_args</vh></v>
<v t="ekr.20080516150804.3637"><vh>test_call_func_and_only_dstart_args</vh></v>
<v t="ekr.20080516150804.3638"><vh>test_call_func_and_both_varargs_and_kwargs</vh></v>
<v t="ekr.20080516150804.3639"><vh>test_class_node</vh></v>
<v t="ekr.20080516150804.3640"><vh>test_class_with_no_bases</vh></v>
<v t="ekr.20080516150804.3641"><vh>test_simple_compare</vh></v>
<v t="ekr.20080516150804.3642"><vh>test_multiple_compare</vh></v>
<v t="ekr.20080516150804.3643"><vh>test_decorators_node</vh></v>
<v t="ekr.20080516150804.3644"><vh>test_decorators_for_classes</vh></v>
<v t="ekr.20080516150804.3645"><vh>test_both_varargs_and_kwargs</vh></v>
<v t="ekr.20080516150804.3646"><vh>test_function_node</vh></v>
<v t="ekr.20080516150804.3647"><vh>test_function_node2</vh></v>
<v t="ekr.20080516150804.3648"><vh>test_function_node_and_tuple_parameters</vh></v>
<v t="ekr.20080516150804.3649"><vh>test_dict_node</vh></v>
<v t="ekr.20080516150804.3650"><vh>test_div_node</vh></v>
<v t="ekr.20080516150804.3651"><vh>test_simple_exec_node</vh></v>
<v t="ekr.20080516150804.3652"><vh>test_exec_node</vh></v>
<v t="ekr.20080516150804.3653"><vh>test_for_node</vh></v>
<v t="ekr.20080516150804.3654"><vh>test_normal_from_node</vh></v>
<v t="ekr.20080516150804.3655"><vh>test_from_node</vh></v>
<v t="ekr.20080516150804.3656"><vh>test_simple_gen_expr_node</vh></v>
<v t="ekr.20080516150804.3657"><vh>test_gen_expr_node_handling_surrounding_parens</vh></v>
<v t="ekr.20080516150804.3658"><vh>test_gen_expr_node2</vh></v>
<v t="ekr.20080516150804.3659"><vh>test_get_attr_node</vh></v>
<v t="ekr.20080516150804.3660"><vh>test_global_node</vh></v>
<v t="ekr.20080516150804.3661"><vh>test_if_node</vh></v>
<v t="ekr.20080516150804.3662"><vh>test_if_node2</vh></v>
<v t="ekr.20080516150804.3663"><vh>test_if_node3</vh></v>
<v t="ekr.20080516150804.3664"><vh>test_import_node</vh></v>
<v t="ekr.20080516150804.3665"><vh>test_lambda_node</vh></v>
<v t="ekr.20080516150804.3666"><vh>test_list_node</vh></v>
<v t="ekr.20080516150804.3667"><vh>test_list_comp_node</vh></v>
<v t="ekr.20080516150804.3668"><vh>test_list_comp_node_with_multiple_comprehensions</vh></v>
<v t="ekr.20080516150804.3669"><vh>test_simple_module_node</vh></v>
<v t="ekr.20080516150804.3670"><vh>test_module_node</vh></v>
<v t="ekr.20080516150804.3671"><vh>test_not_and_or_nodes</vh></v>
<v t="ekr.20080516150804.3672"><vh>test_print_node</vh></v>
<v t="ekr.20080516150804.3673"><vh>test_printnl_node</vh></v>
<v t="ekr.20080516150804.3674"><vh>test_raise_node</vh></v>
<v t="ekr.20080516150804.3675"><vh>test_return_node</vh></v>
<v t="ekr.20080516150804.3676"><vh>test_empty_return_node</vh></v>
<v t="ekr.20080516150804.3677"><vh>test_simple_slice_node</vh></v>
<v t="ekr.20080516150804.3678"><vh>test_slice_node2</vh></v>
<v t="ekr.20080516150804.3679"><vh>test_simple_subscript</vh></v>
<v t="ekr.20080516150804.3680"><vh>test_tuple_node</vh></v>
<v t="ekr.20080516150804.3681"><vh>test_tuple_node2</vh></v>
<v t="ekr.20080516150804.3682"><vh>test_one_item_tuple_node</vh></v>
<v t="ekr.20080516150804.3683"><vh>test_empty_tuple_node</vh></v>
<v t="ekr.20080516150804.3684"><vh>test_yield_node</vh></v>
<v t="ekr.20080516150804.3685"><vh>test_while_node</vh></v>
<v t="ekr.20080516150804.3686"><vh>test_with_node</vh></v>
<v t="ekr.20080516150804.3687"><vh>test_try_finally_node</vh></v>
<v t="ekr.20080516150804.3688"><vh>test_try_except_node</vh></v>
<v t="ekr.20080516150804.3689"><vh>test_try_except_and_finally_node</vh></v>
<v t="ekr.20080516150804.3690"><vh>test_ignoring_comments</vh></v>
<v t="ekr.20080516150804.3691"><vh>test_simple_sliceobj</vh></v>
<v t="ekr.20080516150804.3692"><vh>test_ignoring_strings_that_start_with_a_char</vh></v>
<v t="ekr.20080516150804.3693"><vh>test_how_to_handle_old_not_equals</vh></v>
<v t="ekr.20080516150804.3694"><vh>test_semicolon</vh></v>
<v t="ekr.20080516150804.3695"><vh>test_if_exp_node</vh></v>
<v t="ekr.20080516150804.3696"><vh>test_delete_node</vh></v>
</v>
<v t="ekr.20080516150804.3697"><vh>class _ResultChecker</vh>
<v t="ekr.20080516150804.3698"><vh>__init__</vh></v>
<v t="ekr.20080516150804.3699"><vh>check_region</vh></v>
<v t="ekr.20080516150804.3700"><vh>_find_node</vh></v>
<v t="ekr.20080516150804.3701"><vh>check_children</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3702"><vh>ropetest\refactor\renametest.py</vh>
<v t="ekr.20080516150804.3703"><vh>renametest declarations</vh></v>
<v t="ekr.20080516150804.3704"><vh>class RenameRefactoringTest</vh>
<v t="ekr.20080516150804.3705"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3706"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3707"><vh>_local_rename</vh></v>
<v t="ekr.20080516150804.3708"><vh>_rename</vh></v>
<v t="ekr.20080516150804.3709"><vh>test_simple_global_variable_renaming</vh></v>
<v t="ekr.20080516150804.3710"><vh>test_variable_renaming_only_in_its_scope</vh></v>
<v t="ekr.20080516150804.3711"><vh>test_not_renaming_dot_name</vh></v>
<v t="ekr.20080516150804.3712"><vh>test_renaming_multiple_names_in_the_same_line</vh></v>
<v t="ekr.20080516150804.3713"><vh>test_renaming_names_when_getting_some_attribute</vh></v>
<v t="ekr.20080516150804.3714"><vh>test_renaming_names_when_getting_some_attribute2</vh></v>
<v t="ekr.20080516150804.3715"><vh>test_renaming_function_parameters1</vh></v>
<v t="ekr.20080516150804.3716"><vh>test_renaming_function_parameters2</vh></v>
<v t="ekr.20080516150804.3717"><vh>test_renaming_occurrences_inside_functions</vh></v>
<v t="ekr.20080516150804.3718"><vh>test_renaming_arguments_for_normal_args_changing_calls</vh></v>
<v t="ekr.20080516150804.3719"><vh>test_renaming_function_parameters_of_class_init</vh></v>
<v t="ekr.20080516150804.3720"><vh>test_renaming_functions_parameters_and_occurances_in_other_modules</vh></v>
<v t="ekr.20080516150804.3721"><vh>test_renaming_with_backslash_continued_names</vh></v>
<v t="ekr.20080516150804.3722"><vh>test_not_renaming_string_contents</vh></v>
<v t="ekr.20080516150804.3723"><vh>test_not_renaming_comment_contents</vh></v>
<v t="ekr.20080516150804.3724"><vh>test_renaming_all_occurances_in_containing_scope</vh></v>
<v t="ekr.20080516150804.3725"><vh>test_renaming_a_variable_with_arguement_name</vh></v>
<v t="ekr.20080516150804.3726"><vh>test_renaming_an_arguement_with_variable_name</vh></v>
<v t="ekr.20080516150804.3727"><vh>test_renaming_function_with_local_variable_name</vh></v>
<v t="ekr.20080516150804.3728"><vh>test_renaming_functions</vh></v>
<v t="ekr.20080516150804.3729"><vh>test_renaming_functions_across_modules</vh></v>
<v t="ekr.20080516150804.3730"><vh>test_renaming_functions_across_modules_from_import</vh></v>
<v t="ekr.20080516150804.3731"><vh>test_renaming_functions_from_another_module</vh></v>
<v t="ekr.20080516150804.3732"><vh>test_applying_all_changes_together</vh></v>
<v t="ekr.20080516150804.3733"><vh>test_renaming_modules</vh></v>
<v t="ekr.20080516150804.3734"><vh>test_renaming_packages</vh></v>
<v t="ekr.20080516150804.3735"><vh>test_module_dependencies</vh></v>
<v t="ekr.20080516150804.3736"><vh>test_renaming_class_attributes</vh></v>
<v t="ekr.20080516150804.3737"><vh>test_renaming_class_attributes2</vh></v>
<v t="ekr.20080516150804.3738"><vh>test_renaming_methods_in_subclasses</vh></v>
<v t="ekr.20080516150804.3739"><vh>test_renaming_methods_in_sibling_classes</vh></v>
<v t="ekr.20080516150804.3740"><vh>test_not_renaming_methods_in_hierarchies</vh></v>
<v t="ekr.20080516150804.3741"><vh>test_undoing_refactorings</vh></v>
<v t="ekr.20080516150804.3742"><vh>test_undoing_renaming_modules</vh></v>
<v t="ekr.20080516150804.3743"><vh>test_rename_in_module_renaming_one_letter_names_for_expressions</vh></v>
<v t="ekr.20080516150804.3744"><vh>test_renaming_for_loop_variable</vh></v>
<v t="ekr.20080516150804.3745"><vh>test_renaming_parameters</vh></v>
<v t="ekr.20080516150804.3746"><vh>test_renaming_assigned_parameters</vh></v>
<v t="ekr.20080516150804.3747"><vh>test_renaming_parameters_not_renaming_others</vh></v>
<v t="ekr.20080516150804.3748"><vh>test_renaming_parameters_not_renaming_others2</vh></v>
<v t="ekr.20080516150804.3749"><vh>test_renaming_parameters_with_multiple_params</vh></v>
<v t="ekr.20080516150804.3750"><vh>test_renaming_parameters_with_multiple_params2</vh></v>
<v t="ekr.20080516150804.3751"><vh>test_renaming_parameters_on_calls</vh></v>
<v t="ekr.20080516150804.3752"><vh>test_renaming_parameters_spaces_before_call</vh></v>
<v t="ekr.20080516150804.3753"><vh>test_renaming_parameter_like_objects_after_keywords</vh></v>
<v t="ekr.20080516150804.3754"><vh>test_renaming_variables_in_init_dot_pys</vh></v>
<v t="ekr.20080516150804.3755"><vh>test_renaming_variables_in_init_dot_pys2</vh></v>
<v t="ekr.20080516150804.3756"><vh>test_renaming_variables_in_init_dot_pys3</vh></v>
<v t="ekr.20080516150804.3757"><vh>test_renaming_resources_using_rename_module_refactoring</vh></v>
<v t="ekr.20080516150804.3758"><vh>test_renaming_resources_using_rename_module_refactoring_for_packages</vh></v>
<v t="ekr.20080516150804.3759"><vh>test_renaming_resources_using_rename_module_refactoring_for_init_dot_py</vh></v>
<v t="ekr.20080516150804.3760"><vh>test_renaming_global_variables</vh></v>
<v t="ekr.20080516150804.3761"><vh>test_renaming_global_variables2</vh></v>
<v t="ekr.20080516150804.3762"><vh>test_renaming_when_unsure</vh></v>
<v t="ekr.20080516150804.3763"><vh>_true</vh></v>
<v t="ekr.20080516150804.3764"><vh>test_renaming_when_unsure_with_confirmation</vh></v>
<v t="ekr.20080516150804.3765"><vh>test_renaming_when_unsure_not_renaming_knowns</vh></v>
<v t="ekr.20080516150804.3766"><vh>test_renaming_in_strings_and_comments</vh></v>
<v t="ekr.20080516150804.3767"><vh>test_not_renaming_in_strings_and_comments_where_not_visible</vh></v>
<v t="ekr.20080516150804.3768"><vh>test_not_renaming_all_text_occurrences_in_strings_and_comments</vh></v>
<v t="ekr.20080516150804.3769"><vh>test_renaming_occurrences_in_overwritten_scopes</vh></v>
<v t="ekr.20080516150804.3770"><vh>test_renaming_occurrences_in_overwritten_scopes2</vh></v>
<v t="ekr.20080516150804.3771"><vh>test_dos_line_ending_and_renaming</vh></v>
<v t="ekr.20080516150804.3772"><vh>test_multi_byte_strs_and_renaming</vh></v>
<v t="ekr.20080516150804.3773"><vh>test_resources_parameter</vh></v>
<v t="ekr.20080516150804.3774"><vh>test_resources_parameter_not_changing_defining_module</vh></v>
<v t="ekr.20080516150804.3775"><vh>xxx_test_with_statement_variables_should_not_leak</vh></v>
</v>
<v t="ekr.20080516150804.3776"><vh>class ChangeOccurrencesTest</vh>
<v t="ekr.20080516150804.3777"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3778"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3779"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.3780"><vh>test_only_performing_inside_scopes</vh></v>
<v t="ekr.20080516150804.3781"><vh>test_only_performing_on_calls</vh></v>
<v t="ekr.20080516150804.3782"><vh>test_only_performing_on_reads</vh></v>
</v>
<v t="ekr.20080516150804.3783"><vh>class ImplicitInterfacesTest</vh>
<v t="ekr.20080516150804.3784"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3785"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3786"><vh>_rename</vh></v>
<v t="ekr.20080516150804.3787"><vh>test_performing_rename_on_parameters</vh></v>
</v>
<v t="ekr.20080516150804.3788"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3789"><vh>ropetest\refactor\restructuretest.py</vh>
<v t="ekr.20080516150804.3790"><vh>restructuretest declarations</vh></v>
<v t="ekr.20080516150804.3791"><vh>class RestructureTest</vh>
<v t="ekr.20080516150804.3792"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3793"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3794"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.3795"><vh>test_replacing_simple_patterns</vh></v>
<v t="ekr.20080516150804.3796"><vh>test_replacing_patterns_with_normal_names</vh></v>
<v t="ekr.20080516150804.3797"><vh>test_replacing_patterns_with_any_names</vh></v>
<v t="ekr.20080516150804.3798"><vh>test_replacing_patterns_with_any_names2</vh></v>
<v t="ekr.20080516150804.3799"><vh>test_replacing_patterns_with_checks</vh></v>
<v t="ekr.20080516150804.3800"><vh>test_replacing_assignments_with_sets</vh></v>
<v t="ekr.20080516150804.3801"><vh>test_replacing_sets_with_assignments</vh></v>
<v t="ekr.20080516150804.3802"><vh>test_using_make_checks</vh></v>
<v t="ekr.20080516150804.3803"><vh>test_using_make_checking_builtin_types</vh></v>
<v t="ekr.20080516150804.3804"><vh>test_auto_indentation_when_no_indentation</vh></v>
<v t="ekr.20080516150804.3805"><vh>test_auto_indentation</vh></v>
<v t="ekr.20080516150804.3806"><vh>test_auto_indentation_and_not_indenting_blanks</vh></v>
<v t="ekr.20080516150804.3807"><vh>test_importing_names</vh></v>
<v t="ekr.20080516150804.3808"><vh>test_not_importing_names_when_there_are_no_changes</vh></v>
<v t="ekr.20080516150804.3809"><vh>test_handling_containing_matches</vh></v>
<v t="ekr.20080516150804.3810"><vh>test_handling_overlapping_matches</vh></v>
<v t="ekr.20080516150804.3811"><vh>test_preventing_stack_overflow_when_matching</vh></v>
<v t="ekr.20080516150804.3812"><vh>test_performing_a_restructuring_to_all_modules</vh></v>
<v t="ekr.20080516150804.3813"><vh>test_performing_a_restructuring_to_selected_modules</vh></v>
<v t="ekr.20080516150804.3814"><vh>test_unsure_argument_of_default_wildcard</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3815"><vh>ropetest\refactor\similarfindertest.py</vh>
<v t="ekr.20080516150804.3816"><vh>similarfindertest declarations</vh></v>
<v t="ekr.20080516150804.3817"><vh>class SimilarFinderTest</vh>
<v t="ekr.20080516150804.3818"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3819"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3820"><vh>_create_finder</vh></v>
<v t="ekr.20080516150804.3821"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.3822"><vh>test_constant_integer</vh></v>
<v t="ekr.20080516150804.3823"><vh>test_simple_addition</vh></v>
<v t="ekr.20080516150804.3824"><vh>test_simple_addition2</vh></v>
<v t="ekr.20080516150804.3825"><vh>test_simple_assign_statements</vh></v>
<v t="ekr.20080516150804.3826"><vh>test_simple_multiline_statements</vh></v>
<v t="ekr.20080516150804.3827"><vh>test_multiple_matches</vh></v>
<v t="ekr.20080516150804.3828"><vh>test_multiple_matches2</vh></v>
<v t="ekr.20080516150804.3829"><vh>test_restricting_the_region_to_search</vh></v>
<v t="ekr.20080516150804.3830"><vh>test_matching_basic_patterns</vh></v>
<v t="ekr.20080516150804.3831"><vh>test_match_get_ast</vh></v>
<v t="ekr.20080516150804.3832"><vh>test_match_get_ast_for_statements</vh></v>
<v t="ekr.20080516150804.3833"><vh>test_matching_multiple_patterns</vh></v>
<v t="ekr.20080516150804.3834"><vh>test_matching_any_patterns</vh></v>
<v t="ekr.20080516150804.3835"><vh>test_matching_any_patterns_repeating</vh></v>
<v t="ekr.20080516150804.3836"><vh>test_matching_any_patterns_not_matching_different_nodes</vh></v>
<v t="ekr.20080516150804.3837"><vh>test_matching_normal_names_and_assname</vh></v>
<v t="ekr.20080516150804.3838"><vh>test_matching_normal_names_and_assname2</vh></v>
<v t="ekr.20080516150804.3839"><vh>test_matching_normal_names_and_attributes</vh></v>
<v t="ekr.20080516150804.3840"><vh>test_functions_not_matching_when_only_first_parameters</vh></v>
<v t="ekr.20080516150804.3841"><vh>test_matching_nested_try_finally</vh></v>
<v t="ekr.20080516150804.3842"><vh>test_matching_dicts_inside_functions</vh></v>
</v>
<v t="ekr.20080516150804.3843"><vh>class CheckingFinderTest</vh>
<v t="ekr.20080516150804.3844"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3845"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3846"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.3847"><vh>test_simple_finding</vh></v>
<v t="ekr.20080516150804.3848"><vh>test_not_matching_when_the_name_does_not_match</vh></v>
<v t="ekr.20080516150804.3849"><vh>test_not_matching_unknowns_finding</vh></v>
<v t="ekr.20080516150804.3850"><vh>test_finding_and_matching_pyobjects</vh></v>
<v t="ekr.20080516150804.3851"><vh>test_finding_and_matching_types</vh></v>
<v t="ekr.20080516150804.3852"><vh>test_checking_the_type_of_an_ass_name_node</vh></v>
<v t="ekr.20080516150804.3853"><vh>test_checking_instance_of_an_ass_name_node</vh></v>
<v t="ekr.20080516150804.3854"><vh>test_checking_equality_of_imported_pynames</vh></v>
</v>
<v t="ekr.20080516150804.3855"><vh>class TemplateTest</vh>
<v t="ekr.20080516150804.3856"><vh>test_simple_templates</vh></v>
<v t="ekr.20080516150804.3857"><vh>test_ignoring_matches_in_comments</vh></v>
<v t="ekr.20080516150804.3858"><vh>test_ignoring_matches_in_strings</vh></v>
<v t="ekr.20080516150804.3859"><vh>test_simple_substitution</vh></v>
<v t="ekr.20080516150804.3860"><vh>test_substituting_multiple_names</vh></v>
</v>
<v t="ekr.20080516150804.3861"><vh>suite</vh></v>
</v>
<v t="ekr.20080516150804.3862"><vh>ropetest\refactor\suitestest.py</vh>
<v t="ekr.20080516150804.3863"><vh>suitestest declarations</vh></v>
<v t="ekr.20080516150804.3864"><vh>class SuiteTest</vh>
<v t="ekr.20080516150804.3865"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3866"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3867"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.3868"><vh>test_simple_ifs</vh></v>
<v t="ekr.20080516150804.3869"><vh>test_simple_else</vh></v>
<v t="ekr.20080516150804.3870"><vh>test_for</vh></v>
<v t="ekr.20080516150804.3871"><vh>test_while</vh></v>
<v t="ekr.20080516150804.3872"><vh>test_with</vh></v>
<v t="ekr.20080516150804.3873"><vh>test_try_finally</vh></v>
<v t="ekr.20080516150804.3874"><vh>test_try_except</vh></v>
<v t="ekr.20080516150804.3875"><vh>test_try_except_finally</vh></v>
<v t="ekr.20080516150804.3876"><vh>test_local_start_and_end</vh></v>
<v t="ekr.20080516150804.3877"><vh>test_find_suite</vh></v>
<v t="ekr.20080516150804.3878"><vh>test_find_suite_for_ifs</vh></v>
<v t="ekr.20080516150804.3879"><vh>test_find_suite_for_between_suites</vh></v>
<v t="ekr.20080516150804.3880"><vh>test_simple_find_visible</vh></v>
<v t="ekr.20080516150804.3881"><vh>test_simple_find_visible_ifs</vh></v>
<v t="ekr.20080516150804.3882"><vh>test_simple_find_visible_for_else</vh></v>
<v t="ekr.20080516150804.3883"><vh>test_simple_find_visible_for_different_suites</vh></v>
<v t="ekr.20080516150804.3884"><vh>test_not_always_selecting_scope_start</vh></v>
<v t="ekr.20080516150804.3885"><vh>test_ignoring_functions</vh></v>
<v t="ekr.20080516150804.3886"><vh>test_ignoring_classes</vh></v>
</v>
<v t="ekr.20080516150804.3887"><vh>source_suite_tree</vh></v>
</v>
<v t="ekr.20080516150804.3888"><vh>ropetest\refactor\usefunctiontest.py</vh>
<v t="ekr.20080516150804.3889"><vh>usefunctiontest declarations</vh></v>
<v t="ekr.20080516150804.3890"><vh>class UseFunctionTest</vh>
<v t="ekr.20080516150804.3891"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3892"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3893"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.3894"><vh>test_simple_function</vh></v>
<v t="ekr.20080516150804.3895"><vh>test_simple_function2</vh></v>
<v t="ekr.20080516150804.3896"><vh>test_functions_with_multiple_statements</vh></v>
<v t="ekr.20080516150804.3897"><vh>test_returning</vh></v>
<v t="ekr.20080516150804.3898"><vh>test_returning_a_single_expression</vh></v>
<v t="ekr.20080516150804.3899"><vh>test_occurrences_in_other_modules</vh></v>
<v t="ekr.20080516150804.3900"><vh>test_when_performing_on_non_functions</vh></v>
<v t="ekr.20080516150804.3901"><vh>test_differing_in_the_inner_temp_names</vh></v>
<v t="ekr.20080516150804.3902"><vh>xxx_test_being_a_bit_more_intelligent_when_returning_assigneds</vh></v>
<v t="ekr.20080516150804.3903"><vh>test_exception_when_performing_a_function_with_yield</vh></v>
<v t="ekr.20080516150804.3904"><vh>test_exception_when_performing_a_function_two_returns</vh></v>
<v t="ekr.20080516150804.3905"><vh>test_exception_when_returns_is_not_the_last_statement</vh></v>
</v>
</v>
<v t="ekr.20080516150804.3906"><vh>ropetest\refactor\__init__.py</vh>
<v t="ekr.20080516150804.3907"><vh>__init__ declarations</vh></v>
<v t="ekr.20080516150804.3908"><vh>class MethodObjectTest</vh>
<v t="ekr.20080516150804.3909"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3910"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3911"><vh>test_empty_method</vh></v>
<v t="ekr.20080516150804.3912"><vh>test_trivial_return</vh></v>
<v t="ekr.20080516150804.3913"><vh>test_multi_line_header</vh></v>
<v t="ekr.20080516150804.3914"><vh>test_a_single_parameter</vh></v>
<v t="ekr.20080516150804.3915"><vh>test_self_parameter</vh></v>
<v t="ekr.20080516150804.3916"><vh>test_simple_using_passed_parameters</vh></v>
<v t="ekr.20080516150804.3917"><vh>test_self_keywords_and_args_parameters</vh></v>
<v t="ekr.20080516150804.3918"><vh>test_performing_on_not_a_function</vh></v>
<v t="ekr.20080516150804.3919"><vh>test_changing_the_module</vh></v>
<v t="ekr.20080516150804.3920"><vh>test_changing_the_module_and_class_methods</vh></v>
</v>
<v t="ekr.20080516150804.3921"><vh>class IntroduceFactoryTest</vh>
<v t="ekr.20080516150804.3922"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3923"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3924"><vh>_introduce_factory</vh></v>
<v t="ekr.20080516150804.3925"><vh>test_adding_the_method</vh></v>
<v t="ekr.20080516150804.3926"><vh>test_changing_occurances_in_the_main_module</vh></v>
<v t="ekr.20080516150804.3927"><vh>test_changing_occurances_with_arguments</vh></v>
<v t="ekr.20080516150804.3928"><vh>test_changing_occurances_in_other_modules</vh></v>
<v t="ekr.20080516150804.3929"><vh>test_raising_exception_for_non_classes</vh></v>
<v t="ekr.20080516150804.3930"><vh>test_undoing_introduce_factory</vh></v>
<v t="ekr.20080516150804.3931"><vh>test_using_on_an_occurance_outside_the_main_module</vh></v>
<v t="ekr.20080516150804.3932"><vh>test_introduce_factory_in_nested_scopes</vh></v>
<v t="ekr.20080516150804.3933"><vh>test_adding_factory_for_global_factories</vh></v>
<v t="ekr.20080516150804.3934"><vh>test_get_name_for_factories</vh></v>
<v t="ekr.20080516150804.3935"><vh>test_raising_exception_for_global_factory_for_nested_classes</vh></v>
<v t="ekr.20080516150804.3936"><vh>test_changing_occurances_in_the_main_module_for_global_factories</vh></v>
<v t="ekr.20080516150804.3937"><vh>test_changing_occurances_in_other_modules_for_global_factories</vh></v>
<v t="ekr.20080516150804.3938"><vh>test_importing_if_necessary_in_other_modules_for_global_factories</vh></v>
<v t="ekr.20080516150804.3939"><vh>test_changing_occurances_for_renamed_classes</vh></v>
<v t="ekr.20080516150804.3940"><vh>test_changing_occurrences_in_the_same_module_with_conflicting_ranges</vh></v>
<v t="ekr.20080516150804.3941"><vh>_transform_module_to_package</vh></v>
<v t="ekr.20080516150804.3942"><vh>test_transform_module_to_package</vh></v>
<v t="ekr.20080516150804.3943"><vh>test_transform_module_to_package_undoing</vh></v>
<v t="ekr.20080516150804.3944"><vh>test_transform_module_to_package_with_relative_imports</vh></v>
<v t="ekr.20080516150804.3945"><vh>test_resources_parameter</vh></v>
</v>
<v t="ekr.20080516150804.3946"><vh>class EncapsulateFieldTest</vh>
<v t="ekr.20080516150804.3947"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3948"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3949"><vh>_encapsulate</vh></v>
<v t="ekr.20080516150804.3950"><vh>test_adding_getters_and_setters</vh></v>
<v t="ekr.20080516150804.3951"><vh>test_changing_getters_in_other_modules</vh></v>
<v t="ekr.20080516150804.3952"><vh>test_changing_setters_in_other_modules</vh></v>
<v t="ekr.20080516150804.3953"><vh>test_changing_getters_in_setters</vh></v>
<v t="ekr.20080516150804.3954"><vh>test_appending_to_class_end</vh></v>
<v t="ekr.20080516150804.3955"><vh>test_performing_in_other_modules</vh></v>
<v t="ekr.20080516150804.3956"><vh>test_changing_main_module_occurances</vh></v>
<v t="ekr.20080516150804.3957"><vh>test_raising_exception_when_performed_on_non_attributes</vh></v>
<v t="ekr.20080516150804.3958"><vh>test_raising_exception_on_tuple_assignments</vh></v>
<v t="ekr.20080516150804.3959"><vh>test_raising_exception_on_tuple_assignments2</vh></v>
<v t="ekr.20080516150804.3960"><vh>test_tuple_assignments_and_function_calls</vh></v>
<v t="ekr.20080516150804.3961"><vh>test_tuple_assignments</vh></v>
<v t="ekr.20080516150804.3962"><vh>test_changing_augmented_assignments</vh></v>
<v t="ekr.20080516150804.3963"><vh>test_changing_augmented_assignments2</vh></v>
<v t="ekr.20080516150804.3964"><vh>test_changing_occurrences_inside_the_class</vh></v>
<v t="ekr.20080516150804.3965"><vh>test_getter_and_setter_parameters</vh></v>
<v t="ekr.20080516150804.3966"><vh>test_using_resources_parameter</vh></v>
</v>
<v t="ekr.20080516150804.3967"><vh>class LocalToFieldTest</vh>
<v t="ekr.20080516150804.3968"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3969"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3970"><vh>_perform_convert_local_variable_to_field</vh></v>
<v t="ekr.20080516150804.3971"><vh>test_simple_local_to_field</vh></v>
<v t="ekr.20080516150804.3972"><vh>test_raising_exception_when_performed_on_a_global_var</vh></v>
<v t="ekr.20080516150804.3973"><vh>test_raising_exception_when_performed_on_field</vh></v>
<v t="ekr.20080516150804.3974"><vh>test_raising_exception_when_performed_on_a_parameter</vh></v>
<v t="ekr.20080516150804.3975"><vh>test_not_raising_exception_when_there_is_a_field_with_the_same_name</vh></v>
<v t="ekr.20080516150804.3976"><vh>test_local_to_field_with_self_renamed</vh></v>
</v>
<v t="ekr.20080516150804.3977"><vh>class IntroduceParameterTest</vh>
<v t="ekr.20080516150804.3978"><vh>setUp</vh></v>
<v t="ekr.20080516150804.3979"><vh>tearDown</vh></v>
<v t="ekr.20080516150804.3980"><vh>_introduce_parameter</vh></v>
<v t="ekr.20080516150804.3981"><vh>test_simple_case</vh></v>
<v t="ekr.20080516150804.3982"><vh>test_changing_function_body</vh></v>
<v t="ekr.20080516150804.3983"><vh>test_unknown_variables</vh></v>
<v t="ekr.20080516150804.3984"><vh>test_failing_when_not_inside</vh></v>
<v t="ekr.20080516150804.3985"><vh>test_attribute_accesses</vh></v>
<v t="ekr.20080516150804.3986"><vh>test_introducing_parameters_for_methods</vh></v>
</v>
<v t="ekr.20080516150804.3987"><vh>class _MockTaskObserver</vh>
<v t="ekr.20080516150804.3988"><vh>__init__</vh></v>
<v t="ekr.20080516150804.3989"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.3990"><vh>class TaskHandleTest</vh>
<v t="ekr.20080516150804.3991"><vh>test_trivial_case</vh></v>
<v t="ekr.20080516150804.3992"><vh>test_stopping</vh></v>
<v t="ekr.20080516150804.3993"><vh>test_job_sets</vh></v>
<v t="ekr.20080516150804.3994"><vh>test_starting_and_finishing_jobs</vh></v>
<v t="ekr.20080516150804.3995"><vh>test_test_checking_status</vh></v>
<v t="ekr.20080516150804.3996"><vh>test_test_checking_status_when_starting</vh></v>
<v t="ekr.20080516150804.3997"><vh>test_calling_the_observer_after_stopping</vh></v>
<v t="ekr.20080516150804.3998"><vh>test_calling_the_observer_after_creating_job_sets</vh></v>
<v t="ekr.20080516150804.3999"><vh>test_calling_the_observer_when_starting_and_finishing_jobs</vh></v>
<v t="ekr.20080516150804.4000"><vh>test_job_set_get_percent_done</vh></v>
<v t="ekr.20080516150804.4001"><vh>test_getting_job_name</vh></v>
</v>
<v t="ekr.20080516150804.4002"><vh>suite</vh></v>
</v>
</v>
</v>
<v t="ekr.20080516150804.10" a="E"><vh>rope-0.8.2\rope</vh>
<v t="ekr.20080516150804.11"><vh>rope-0.8.2\rope\__init__.py</vh>
<v t="ekr.20080516150804.12"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20080516150804.1219"><vh>rope-0.8.2\rope\contrib</vh>
<v t="ekr.20080516150804.1366"><vh>contrib\__init__.py</vh>
<v t="ekr.20080516150804.1367"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20080516150804.1220"><vh>contrib\autoimport.py</vh>
<v t="ekr.20080516150804.1221"><vh>autoimport declarations</vh></v>
<v t="ekr.20080516150804.1222"><vh>class AutoImport</vh>
<v t="ekr.20080516150804.1223"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1224"><vh>import_assist</vh></v>
<v t="ekr.20080516150804.1225"><vh>get_modules</vh></v>
<v t="ekr.20080516150804.1226"><vh>get_all_names</vh></v>
<v t="ekr.20080516150804.1227"><vh>get_name_locations</vh></v>
<v t="ekr.20080516150804.1228"><vh>generate_cache</vh></v>
<v t="ekr.20080516150804.1229"><vh>generate_modules_cache</vh></v>
<v t="ekr.20080516150804.1230"><vh>clear_cache</vh></v>
<v t="ekr.20080516150804.1231"><vh>find_insertion_line</vh></v>
<v t="ekr.20080516150804.1232"><vh>update_resource</vh></v>
<v t="ekr.20080516150804.1233"><vh>update_module</vh></v>
<v t="ekr.20080516150804.1234"><vh>_module_name</vh></v>
<v t="ekr.20080516150804.1235"><vh>_add_names</vh></v>
<v t="ekr.20080516150804.1236"><vh>_write</vh></v>
<v t="ekr.20080516150804.1237"><vh>_changed</vh></v>
<v t="ekr.20080516150804.1238"><vh>_moved</vh></v>
<v t="ekr.20080516150804.1239"><vh>_removed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1240"><vh>contrib\codeassist.py</vh>
<v t="ekr.20080516150804.1241"><vh>codeassist declarations</vh></v>
<v t="ekr.20080516150804.1242"><vh>code_assist</vh></v>
<v t="ekr.20080516150804.1243"><vh>starting_offset</vh></v>
<v t="ekr.20080516150804.1244"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.1245"><vh>get_calltip</vh></v>
<v t="ekr.20080516150804.1246"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.1247"><vh>find_occurrences</vh></v>
<v t="ekr.20080516150804.1248"><vh>class CodeAssistProposal</vh>
<v t="ekr.20080516150804.1249"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1250"><vh>class CompletionProposal</vh>
<v t="ekr.20080516150804.1251"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1252"><vh>__str__</vh></v>
<v t="ekr.20080516150804.1253"><vh>__repr__</vh></v>
</v>
<v t="ekr.20080516150804.1254"><vh>sorted_proposals</vh></v>
<v t="ekr.20080516150804.1255"><vh>starting_expression</vh></v>
<v t="ekr.20080516150804.1256"><vh>default_templates</vh></v>
<v t="ekr.20080516150804.1257"><vh>class _PythonCodeAssist</vh>
<v t="ekr.20080516150804.1258"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1259"><vh>_find_starting_offset</vh></v>
<v t="ekr.20080516150804.1260"><vh>_matching_keywords</vh></v>
<v t="ekr.20080516150804.1261"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1262"><vh>_dotted_completions</vh></v>
<v t="ekr.20080516150804.1263"><vh>_undotted_completions</vh></v>
<v t="ekr.20080516150804.1264"><vh>_from_import_completions</vh></v>
<v t="ekr.20080516150804.1265"><vh>_find_module</vh></v>
<v t="ekr.20080516150804.1266"><vh>_is_defined_after</vh></v>
<v t="ekr.20080516150804.1267"><vh>_get_pyname_type</vh></v>
<v t="ekr.20080516150804.1268"><vh>_code_completions</vh></v>
<v t="ekr.20080516150804.1269"><vh>_keyword_parameters</vh></v>
</v>
<v t="ekr.20080516150804.1270"><vh>class _ProposalSorter</vh>
<v t="ekr.20080516150804.1271"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1272"><vh>get_sorted_proposal_list</vh></v>
<v t="ekr.20080516150804.1273"><vh>_proposal_cmp</vh></v>
<v t="ekr.20080516150804.1274"><vh>_compare_underlined_names</vh></v>
</v>
<v t="ekr.20080516150804.1275"><vh>class _Commenter</vh>
<v t="ekr.20080516150804.1276"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1277"><vh>comment</vh></v>
<v t="ekr.20080516150804.1278"><vh>_last_non_blank</vh></v>
<v t="ekr.20080516150804.1279"><vh>_get_block_end</vh></v>
<v t="ekr.20080516150804.1280"><vh>_fix_incomplete_try_blocks</vh></v>
<v t="ekr.20080516150804.1281"><vh>_find_matching_deindent</vh></v>
</v>
<v t="ekr.20080516150804.1282"><vh>_find_pyname_at</vh></v>
<v t="ekr.20080516150804.1283"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1284"><vh>_get_line_indents</vh></v>
<v t="ekr.20080516150804.1285"><vh>_logical_start</vh></v>
<v t="ekr.20080516150804.1286"><vh>class PyDocExtractor</vh>
<v t="ekr.20080516150804.1287"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.1288"><vh>get_calltip</vh></v>
<v t="ekr.20080516150804.1289"><vh>_get_class_docstring</vh></v>
<v t="ekr.20080516150804.1290"><vh>_get_function_docstring</vh></v>
<v t="ekr.20080516150804.1291"><vh>_is_method</vh></v>
<v t="ekr.20080516150804.1292"><vh>_get_single_function_docstring</vh></v>
<v t="ekr.20080516150804.1293"><vh>_get_super_methods</vh></v>
<v t="ekr.20080516150804.1294"><vh>_get_function_signature</vh></v>
<v t="ekr.20080516150804.1295"><vh>_location</vh></v>
<v t="ekr.20080516150804.1296"><vh>_get_module</vh></v>
<v t="ekr.20080516150804.1297"><vh>_trim_docstring</vh></v>
</v>
<v t="ekr.20080516150804.1298"><vh>class TemplateProposal</vh>
<v t="ekr.20080516150804.1299"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1300"><vh>class Template</vh>
<v t="ekr.20080516150804.1301"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1302"><vh>variables</vh></v>
<v t="ekr.20080516150804.1303"><vh>substitute</vh></v>
<v t="ekr.20080516150804.1304"><vh>get_cursor_location</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1305"><vh>contrib\findit.py</vh>
<v t="ekr.20080516150804.1306"><vh>findit declarations</vh></v>
<v t="ekr.20080516150804.1307"><vh>find_occurrences</vh></v>
<v t="ekr.20080516150804.1308"><vh>find_implementations</vh></v>
<v t="ekr.20080516150804.1309"><vh>class Location</vh></v>
<v t="ekr.20080516150804.1310"><vh>_find_locations</vh></v>
</v>
<v t="ekr.20080516150804.1311"><vh>contrib\generate.py</vh>
<v t="ekr.20080516150804.1312"><vh>generate declarations</vh></v>
<v t="ekr.20080516150804.1313"><vh>create_generate</vh></v>
<v t="ekr.20080516150804.1314"><vh>create_module</vh></v>
<v t="ekr.20080516150804.1315"><vh>create_package</vh></v>
<v t="ekr.20080516150804.1316"><vh>class _Generate</vh>
<v t="ekr.20080516150804.1317"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1318"><vh>_generate_info</vh></v>
<v t="ekr.20080516150804.1319"><vh>_check_exceptional_conditions</vh></v>
<v t="ekr.20080516150804.1320"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1321"><vh>get_location</vh></v>
<v t="ekr.20080516150804.1322"><vh>_get_element_kind</vh></v>
<v t="ekr.20080516150804.1323"><vh>_get_element</vh></v>
</v>
<v t="ekr.20080516150804.1324"><vh>class GenerateFunction</vh>
<v t="ekr.20080516150804.1325"><vh>_generate_info</vh></v>
<v t="ekr.20080516150804.1326"><vh>_get_element</vh></v>
<v t="ekr.20080516150804.1327"><vh>_get_element_kind</vh></v>
</v>
<v t="ekr.20080516150804.1328"><vh>class GenerateVariable</vh>
<v t="ekr.20080516150804.1329"><vh>_get_element</vh></v>
<v t="ekr.20080516150804.1330"><vh>_get_element_kind</vh></v>
</v>
<v t="ekr.20080516150804.1331"><vh>class GenerateClass</vh>
<v t="ekr.20080516150804.1332"><vh>_get_element</vh></v>
<v t="ekr.20080516150804.1333"><vh>_get_element_kind</vh></v>
</v>
<v t="ekr.20080516150804.1334"><vh>class GenerateModule</vh>
<v t="ekr.20080516150804.1335"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1336"><vh>get_location</vh></v>
</v>
<v t="ekr.20080516150804.1337"><vh>class GeneratePackage</vh>
<v t="ekr.20080516150804.1338"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1339"><vh>get_location</vh></v>
</v>
<v t="ekr.20080516150804.1340"><vh>_add_import_to_module</vh></v>
<v t="ekr.20080516150804.1341"><vh>class _GenerationInfo</vh>
<v t="ekr.20080516150804.1342"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1343"><vh>_init_fields</vh></v>
<v t="ekr.20080516150804.1344"><vh>_get_goal_scope</vh></v>
<v t="ekr.20080516150804.1345"><vh>_get_goal_module</vh></v>
<v t="ekr.20080516150804.1346"><vh>_get_source_scope</vh></v>
<v t="ekr.20080516150804.1347"><vh>get_insertion_lineno</vh></v>
<v t="ekr.20080516150804.1348"><vh>get_insertion_resource</vh></v>
<v t="ekr.20080516150804.1349"><vh>get_insertion_offsets</vh></v>
<v t="ekr.20080516150804.1350"><vh>get_scope_indents</vh></v>
<v t="ekr.20080516150804.1351"><vh>get_blank_lines</vh></v>
<v t="ekr.20080516150804.1352"><vh>get_package</vh></v>
<v t="ekr.20080516150804.1353"><vh>primary_is_found</vh></v>
<v t="ekr.20080516150804.1354"><vh>element_already_exists</vh></v>
<v t="ekr.20080516150804.1355"><vh>get_name</vh></v>
</v>
<v t="ekr.20080516150804.1356"><vh>class _FunctionGenerationInfo</vh>
<v t="ekr.20080516150804.1357"><vh>_get_goal_scope</vh></v>
<v t="ekr.20080516150804.1358"><vh>element_already_exists</vh></v>
<v t="ekr.20080516150804.1359"><vh>is_static_method</vh></v>
<v t="ekr.20080516150804.1360"><vh>is_method</vh></v>
<v t="ekr.20080516150804.1361"><vh>is_constructor</vh></v>
<v t="ekr.20080516150804.1362"><vh>is_instance</vh></v>
<v t="ekr.20080516150804.1363"><vh>get_name</vh></v>
<v t="ekr.20080516150804.1364"><vh>get_passed_args</vh></v>
<v t="ekr.20080516150804.1365"><vh>_is_id</vh></v>
</v>
</v>
</v>
<v t="ekr.20080516150804.1368"><vh>rope-0.8.2\rope\refactor</vh>
<v t="ekr.20080516150804.1369"><vh>refactor\change_signature.py</vh>
<v t="ekr.20080516150804.1370"><vh>change_signature declarations</vh></v>
<v t="ekr.20080516150804.1371"><vh>class ChangeSignature</vh>
<v t="ekr.20080516150804.1372"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1373"><vh>_set_name_and_pyname</vh></v>
<v t="ekr.20080516150804.1374"><vh>_change_calls</vh></v>
<v t="ekr.20080516150804.1375"><vh>is_method</vh></v>
<v t="ekr.20080516150804.1376"><vh>get_definition_info</vh></v>
<v t="ekr.20080516150804.1377"><vh>normalize</vh></v>
<v t="ekr.20080516150804.1378"><vh>remove</vh></v>
<v t="ekr.20080516150804.1379"><vh>add</vh></v>
<v t="ekr.20080516150804.1380"><vh>inline_default</vh></v>
<v t="ekr.20080516150804.1381"><vh>reorder</vh></v>
<v t="ekr.20080516150804.1382"><vh>get_changes</vh></v>
</v>
<v t="ekr.20080516150804.1383"><vh>class _FunctionChangers</vh>
<v t="ekr.20080516150804.1384"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1385"><vh>_get_changed_definition_infos</vh></v>
<v t="ekr.20080516150804.1386"><vh>change_definition</vh></v>
<v t="ekr.20080516150804.1387"><vh>change_call</vh></v>
</v>
<v t="ekr.20080516150804.1388"><vh>class _ArgumentChanger</vh>
<v t="ekr.20080516150804.1389"><vh>change_definition_info</vh></v>
<v t="ekr.20080516150804.1390"><vh>change_argument_mapping</vh></v>
</v>
<v t="ekr.20080516150804.1391"><vh>class ArgumentNormalizer</vh></v>
<v t="ekr.20080516150804.1392"><vh>class ArgumentRemover</vh>
<v t="ekr.20080516150804.1393"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1394"><vh>change_definition_info</vh></v>
<v t="ekr.20080516150804.1395"><vh>change_argument_mapping</vh></v>
</v>
<v t="ekr.20080516150804.1396"><vh>class ArgumentAdder</vh>
<v t="ekr.20080516150804.1397"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1398"><vh>change_definition_info</vh></v>
<v t="ekr.20080516150804.1399"><vh>change_argument_mapping</vh></v>
</v>
<v t="ekr.20080516150804.1400"><vh>class ArgumentDefaultInliner</vh>
<v t="ekr.20080516150804.1401"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1402"><vh>change_definition_info</vh></v>
<v t="ekr.20080516150804.1403"><vh>change_argument_mapping</vh></v>
</v>
<v t="ekr.20080516150804.1404"><vh>class ArgumentReorderer</vh>
<v t="ekr.20080516150804.1405"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1406"><vh>change_definition_info</vh></v>
</v>
<v t="ekr.20080516150804.1407"><vh>class _ChangeCallsInModule</vh>
<v t="ekr.20080516150804.1408"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1409"><vh>get_changed_module</vh></v>
<v t="ekr.20080516150804.1410"><vh>pymodule</vh></v>
<v t="ekr.20080516150804.1411"><vh>source</vh></v>
<v t="ekr.20080516150804.1412"><vh>lines</vh></v>
</v>
<v t="ekr.20080516150804.1413"><vh>class _MultipleFinders</vh>
<v t="ekr.20080516150804.1414"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1415"><vh>find_occurrences</vh></v>
<v t="ekr.20080516150804.1416"><vh>_cmp_occurrences</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1417"><vh>refactor\encapsulate_field.py</vh>
<v t="ekr.20080516150804.1418"><vh>encapsulate_field declarations</vh></v>
<v t="ekr.20080516150804.1419"><vh>class EncapsulateField</vh>
<v t="ekr.20080516150804.1420"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1421"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1422"><vh>get_field_name</vh></v>
<v t="ekr.20080516150804.1423"><vh>_is_an_attribute</vh></v>
<v t="ekr.20080516150804.1424"><vh>_get_defining_class_scope</vh></v>
<v t="ekr.20080516150804.1425"><vh>_get_defining_scope</vh></v>
<v t="ekr.20080516150804.1426"><vh>_change_holding_module</vh></v>
</v>
<v t="ekr.20080516150804.1427"><vh>class GetterSetterRenameInModule</vh>
<v t="ekr.20080516150804.1428"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1429"><vh>get_changed_module</vh></v>
</v>
<v t="ekr.20080516150804.1430"><vh>class _FindChangesForModule</vh>
<v t="ekr.20080516150804.1431"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1432"><vh>get_changed_module</vh></v>
<v t="ekr.20080516150804.1433"><vh>_manage_writes</vh></v>
<v t="ekr.20080516150804.1434"><vh>_is_assigned_in_a_tuple_assignment</vh></v>
<v t="ekr.20080516150804.1435"><vh>source</vh></v>
<v t="ekr.20080516150804.1436"><vh>lines</vh></v>
<v t="ekr.20080516150804.1437"><vh>worder</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1438"><vh>refactor\extract.py</vh>
<v t="ekr.20080516150804.1439"><vh>extract declarations</vh></v>
<v t="ekr.20080516150804.1440"><vh>class _ExtractRefactoring</vh>
<v t="ekr.20080516150804.1441"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1442"><vh>_fix_start</vh></v>
<v t="ekr.20080516150804.1443"><vh>_fix_end</vh></v>
<v t="ekr.20080516150804.1444"><vh>get_changes</vh></v>
</v>
<v t="ekr.20080516150804.1445"><vh>class ExtractMethod</vh>
<v t="ekr.20080516150804.1446"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1447"><vh>class ExtractVariable</vh>
<v t="ekr.20080516150804.1448"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1449"><vh>class _ExtractInfo</vh>
<v t="ekr.20080516150804.1450"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1451"><vh>_init_parts</vh></v>
<v t="ekr.20080516150804.1452"><vh>logical_lines</vh></v>
<v t="ekr.20080516150804.1453"><vh>_init_scope</vh></v>
<v t="ekr.20080516150804.1454"><vh>_get_scope_region</vh></v>
<v t="ekr.20080516150804.1455"><vh>_choose_closest_line_end</vh></v>
<v t="ekr.20080516150804.1456"><vh>one_line</vh></v>
<v t="ekr.20080516150804.1457"><vh>global_</vh></v>
<v t="ekr.20080516150804.1458"><vh>method</vh></v>
<v t="ekr.20080516150804.1459"><vh>indents</vh></v>
<v t="ekr.20080516150804.1460"><vh>scope_indents</vh></v>
<v t="ekr.20080516150804.1461"><vh>extracted</vh></v>
<v t="ekr.20080516150804.1462"><vh>returned</vh></v>
</v>
<v t="ekr.20080516150804.1463"><vh>class _ExtractCollector</vh>
<v t="ekr.20080516150804.1464"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1465"><vh>class _ExtractPerformer</vh>
<v t="ekr.20080516150804.1466"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1467"><vh>extract</vh></v>
<v t="ekr.20080516150804.1468"><vh>_replace_occurrences</vh></v>
<v t="ekr.20080516150804.1469"><vh>_collect_info</vh></v>
<v t="ekr.20080516150804.1470"><vh>_find_matches</vh></v>
<v t="ekr.20080516150804.1471"><vh>_where_to_search</vh></v>
<v t="ekr.20080516150804.1472"><vh>_find_definition_location</vh></v>
<v t="ekr.20080516150804.1473"><vh>_find_definition</vh></v>
</v>
<v t="ekr.20080516150804.1474"><vh>class _DefinitionLocationFinder</vh>
<v t="ekr.20080516150804.1475"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1476"><vh>find_lineno</vh></v>
<v t="ekr.20080516150804.1477"><vh>_find_toplevel</vh></v>
<v t="ekr.20080516150804.1478"><vh>find_indents</vh></v>
<v t="ekr.20080516150804.1479"><vh>_get_before_line</vh></v>
<v t="ekr.20080516150804.1480"><vh>_get_after_scope</vh></v>
</v>
<v t="ekr.20080516150804.1481"><vh>class _ExceptionalConditionChecker</vh>
<v t="ekr.20080516150804.1482"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1483"><vh>base_conditions</vh></v>
<v t="ekr.20080516150804.1484"><vh>one_line_conditions</vh></v>
<v t="ekr.20080516150804.1485"><vh>multi_line_conditions</vh></v>
<v t="ekr.20080516150804.1486"><vh>_is_region_on_a_word</vh></v>
<v t="ekr.20080516150804.1487"><vh>_is_on_a_word</vh></v>
</v>
<v t="ekr.20080516150804.1488"><vh>class _ExtractMethodParts</vh>
<v t="ekr.20080516150804.1489"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1490"><vh>get_definition</vh></v>
<v t="ekr.20080516150804.1491"><vh>get_replacement_pattern</vh></v>
<v t="ekr.20080516150804.1492"><vh>get_body_pattern</vh></v>
<v t="ekr.20080516150804.1493"><vh>_get_body</vh></v>
<v t="ekr.20080516150804.1494"><vh>_find_temps</vh></v>
<v t="ekr.20080516150804.1495"><vh>get_checks</vh></v>
<v t="ekr.20080516150804.1496"><vh>_create_info_collector</vh></v>
<v t="ekr.20080516150804.1497"><vh>_get_function_definition</vh></v>
<v t="ekr.20080516150804.1498"><vh>_get_function_signature</vh></v>
<v t="ekr.20080516150804.1499"><vh>_get_self_name</vh></v>
<v t="ekr.20080516150804.1500"><vh>_get_function_call</vh></v>
<v t="ekr.20080516150804.1501"><vh>_get_comma_form</vh></v>
<v t="ekr.20080516150804.1502"><vh>_get_call</vh></v>
<v t="ekr.20080516150804.1503"><vh>_find_function_arguments</vh></v>
<v t="ekr.20080516150804.1504"><vh>_find_function_returns</vh></v>
<v t="ekr.20080516150804.1505"><vh>_get_unindented_function_body</vh></v>
</v>
<v t="ekr.20080516150804.1506"><vh>class _ExtractVariableParts</vh>
<v t="ekr.20080516150804.1507"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1508"><vh>get_definition</vh></v>
<v t="ekr.20080516150804.1509"><vh>get_body_pattern</vh></v>
<v t="ekr.20080516150804.1510"><vh>get_replacement_pattern</vh></v>
<v t="ekr.20080516150804.1511"><vh>get_checks</vh></v>
</v>
<v t="ekr.20080516150804.1512"><vh>class _FunctionInformationCollector</vh>
<v t="ekr.20080516150804.1513"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1514"><vh>_read_variable</vh></v>
<v t="ekr.20080516150804.1515"><vh>_written_variable</vh></v>
<v t="ekr.20080516150804.1516"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1517"><vh>_Name</vh></v>
<v t="ekr.20080516150804.1518"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.1519"><vh>_ClassDef</vh></v>
</v>
<v t="ekr.20080516150804.1520"><vh>_get_argnames</vh></v>
<v t="ekr.20080516150804.1521"><vh>class _VariableReadsAndWritesFinder</vh>
<v t="ekr.20080516150804.1522"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1523"><vh>_Name</vh></v>
<v t="ekr.20080516150804.1524"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1525"><vh>_Class</vh></v>
<v t="ekr.20080516150804.1526"><vh>find_reads_and_writes</vh></v>
<v t="ekr.20080516150804.1527"><vh>find_reads_for_one_liners</vh></v>
</v>
<v t="ekr.20080516150804.1528"><vh>class _UnmatchedBreakOrContinueFinder</vh>
<v t="ekr.20080516150804.1529"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1530"><vh>_For</vh></v>
<v t="ekr.20080516150804.1531"><vh>_While</vh></v>
<v t="ekr.20080516150804.1532"><vh>loop_encountered</vh></v>
<v t="ekr.20080516150804.1533"><vh>_Break</vh></v>
<v t="ekr.20080516150804.1534"><vh>_Continue</vh></v>
<v t="ekr.20080516150804.1535"><vh>check_loop</vh></v>
<v t="ekr.20080516150804.1536"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1537"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.1538"><vh>has_errors</vh></v>
</v>
<v t="ekr.20080516150804.1539"><vh>_get_function_kind</vh></v>
<v t="ekr.20080516150804.1540"><vh>_parse_text</vh></v>
<v t="ekr.20080516150804.1541"><vh>_join_lines</vh></v>
</v>
<v t="ekr.20080516150804.1542"><vh>refactor\functionutils.py</vh>
<v t="ekr.20080516150804.1543"><vh>functionutils declarations</vh></v>
<v t="ekr.20080516150804.1544"><vh>class DefinitionInfo</vh>
<v t="ekr.20080516150804.1545"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1546"><vh>to_string</vh></v>
<v t="ekr.20080516150804.1547"><vh>arguments_to_string</vh></v>
<v t="ekr.20080516150804.1548"><vh>_read</vh></v>
<v t="ekr.20080516150804.1549"><vh>read</vh></v>
</v>
<v t="ekr.20080516150804.1550"><vh>class CallInfo</vh>
<v t="ekr.20080516150804.1551"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1552"><vh>to_string</vh></v>
<v t="ekr.20080516150804.1553"><vh>read</vh></v>
<v t="ekr.20080516150804.1554"><vh>_is_method_call</vh></v>
<v t="ekr.20080516150804.1555"><vh>_is_class</vh></v>
<v t="ekr.20080516150804.1556"><vh>_is_method</vh></v>
<v t="ekr.20080516150804.1557"><vh>_is_classmethod</vh></v>
</v>
<v t="ekr.20080516150804.1558"><vh>class ArgumentMapping</vh>
<v t="ekr.20080516150804.1559"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1560"><vh>to_call_info</vh></v>
</v>
<v t="ekr.20080516150804.1561"><vh>class _FunctionParser</vh>
<v t="ekr.20080516150804.1562"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1563"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1564"><vh>get_instance</vh></v>
<v t="ekr.20080516150804.1565"><vh>get_function_name</vh></v>
<v t="ekr.20080516150804.1566"><vh>is_called_as_a_method</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1567"><vh>refactor\inline.py</vh>
<v t="ekr.20080516150804.1568"><vh>inline declarations</vh></v>
<v t="ekr.20080516150804.1569"><vh>create_inline</vh></v>
<v t="ekr.20080516150804.1570"><vh>class _Inliner</vh>
<v t="ekr.20080516150804.1571"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1572"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1573"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.1574"><vh>class InlineMethod</vh>
<v t="ekr.20080516150804.1575"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1576"><vh>_init_imports</vh></v>
<v t="ekr.20080516150804.1577"><vh>_get_scope_range</vh></v>
<v t="ekr.20080516150804.1578"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1579"><vh>_get_removed_range</vh></v>
<v t="ekr.20080516150804.1580"><vh>_defining_file_changes</vh></v>
<v t="ekr.20080516150804.1581"><vh>_get_method_replacement</vh></v>
<v t="ekr.20080516150804.1582"><vh>_is_the_last_method_of_a_class</vh></v>
<v t="ekr.20080516150804.1583"><vh>_add_imports</vh></v>
<v t="ekr.20080516150804.1584"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.1585"><vh>class InlineVariable</vh>
<v t="ekr.20080516150804.1586"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1587"><vh>_check_exceptional_conditions</vh></v>
<v t="ekr.20080516150804.1588"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1589"><vh>_get_changed_module</vh></v>
<v t="ekr.20080516150804.1590"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.1591"><vh>class InlineParameter</vh>
<v t="ekr.20080516150804.1592"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1593"><vh>_function_location</vh></v>
<v t="ekr.20080516150804.1594"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1595"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.1596"><vh>_join_lines</vh></v>
<v t="ekr.20080516150804.1597"><vh>class _DefinitionGenerator</vh>
<v t="ekr.20080516150804.1598"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1599"><vh>_get_definition_info</vh></v>
<v t="ekr.20080516150804.1600"><vh>_get_definition_params</vh></v>
<v t="ekr.20080516150804.1601"><vh>get_function_name</vh></v>
<v t="ekr.20080516150804.1602"><vh>get_definition</vh></v>
<v t="ekr.20080516150804.1603"><vh>_calculate_definition</vh></v>
<v t="ekr.20080516150804.1604"><vh>_replace_returns_with</vh></v>
<v t="ekr.20080516150804.1605"><vh>_check_nothing_after_return</vh></v>
<v t="ekr.20080516150804.1606"><vh>_get_return_pattern</vh></v>
</v>
<v t="ekr.20080516150804.1607"><vh>class _InlineFunctionCallsForModuleHandle</vh>
<v t="ekr.20080516150804.1608"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1609"><vh>occurred_inside_skip</vh></v>
<v t="ekr.20080516150804.1610"><vh>occurred_outside_skip</vh></v>
<v t="ekr.20080516150804.1611"><vh>_find_end_parens</vh></v>
<v t="ekr.20080516150804.1612"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1613"><vh>_get_source</vh></v>
<v t="ekr.20080516150804.1614"><vh>_get_lines</vh></v>
</v>
<v t="ekr.20080516150804.1615"><vh>_inline_variable</vh></v>
</v>
<v t="ekr.20080516150804.1616"><vh>refactor\introduce_factory.py</vh>
<v t="ekr.20080516150804.1617"><vh>introduce_factory declarations</vh></v>
<v t="ekr.20080516150804.1618"><vh>class IntroduceFactory</vh>
<v t="ekr.20080516150804.1619"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1620"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1621"><vh>get_name</vh></v>
<v t="ekr.20080516150804.1622"><vh>_change_module</vh></v>
<v t="ekr.20080516150804.1623"><vh>_change_resource</vh></v>
<v t="ekr.20080516150804.1624"><vh>_get_insertion_offset</vh></v>
<v t="ekr.20080516150804.1625"><vh>_get_factory_method</vh></v>
<v t="ekr.20080516150804.1626"><vh>_get_scope_indents</vh></v>
<v t="ekr.20080516150804.1627"><vh>_new_function_name</vh></v>
<v t="ekr.20080516150804.1628"><vh>_rename_occurrences</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1629"><vh>refactor\introduce_parameter.py</vh>
<v t="ekr.20080516150804.1630"><vh>introduce_parameter declarations</vh></v>
<v t="ekr.20080516150804.1631"><vh>class IntroduceParameter</vh>
<v t="ekr.20080516150804.1632"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1633"><vh>_get_primary</vh></v>
<v t="ekr.20080516150804.1634"><vh>_get_name_and_pyname</vh></v>
<v t="ekr.20080516150804.1635"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1636"><vh>_get_header_offsets</vh></v>
<v t="ekr.20080516150804.1637"><vh>_change_function_occurances</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1638"><vh>refactor\localtofield.py</vh>
<v t="ekr.20080516150804.1639"><vh>localtofield declarations</vh></v>
<v t="ekr.20080516150804.1640"><vh>class LocalToField</vh>
<v t="ekr.20080516150804.1641"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1642"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1643"><vh>_check_redefinition</vh></v>
<v t="ekr.20080516150804.1644"><vh>_get_field_name</vh></v>
<v t="ekr.20080516150804.1645"><vh>_is_a_method_local</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1646"><vh>refactor\method_object.py</vh>
<v t="ekr.20080516150804.1647"><vh>method_object declarations</vh></v>
<v t="ekr.20080516150804.1648"><vh>class MethodObject</vh>
<v t="ekr.20080516150804.1649"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1650"><vh>get_new_class</vh></v>
<v t="ekr.20080516150804.1651"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1652"><vh>_get_class_insertion_point</vh></v>
<v t="ekr.20080516150804.1653"><vh>_get_body</vh></v>
<v t="ekr.20080516150804.1654"><vh>_get_init</vh></v>
<v t="ekr.20080516150804.1655"><vh>_get_parameter_names</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1656"><vh>refactor\move.py</vh>
<v t="ekr.20080516150804.1657"><vh>move declarations</vh></v>
<v t="ekr.20080516150804.1658"><vh>create_move</vh></v>
<v t="ekr.20080516150804.1659"><vh>class MoveMethod</vh>
<v t="ekr.20080516150804.1660"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1661"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1662"><vh>get_method_name</vh></v>
<v t="ekr.20080516150804.1663"><vh>_get_used_imports</vh></v>
<v t="ekr.20080516150804.1664"><vh>_get_changes_made_by_old_class</vh></v>
<v t="ekr.20080516150804.1665"><vh>_get_scope_indents</vh></v>
<v t="ekr.20080516150804.1666"><vh>_get_changes_made_by_new_class</vh></v>
<v t="ekr.20080516150804.1667"><vh>get_new_method</vh></v>
<v t="ekr.20080516150804.1668"><vh>_get_unchanged_body</vh></v>
<v t="ekr.20080516150804.1669"><vh>_get_body</vh></v>
<v t="ekr.20080516150804.1670"><vh>_get_self_name</vh></v>
<v t="ekr.20080516150804.1671"><vh>_get_new_header</vh></v>
<v t="ekr.20080516150804.1672"><vh>_get_passed_arguments_string</vh></v>
<v t="ekr.20080516150804.1673"><vh>_is_host_used</vh></v>
</v>
<v t="ekr.20080516150804.1674"><vh>class MoveGlobal</vh>
<v t="ekr.20080516150804.1675"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1676"><vh>_check_exceptional_conditions</vh></v>
<v t="ekr.20080516150804.1677"><vh>_is_global</vh></v>
<v t="ekr.20080516150804.1678"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1679"><vh>_calculate_changes</vh></v>
<v t="ekr.20080516150804.1680"><vh>_source_module_changes</vh></v>
<v t="ekr.20080516150804.1681"><vh>_new_modname</vh></v>
<v t="ekr.20080516150804.1682"><vh>_dest_module_changes</vh></v>
<v t="ekr.20080516150804.1683"><vh>_get_moving_element_with_imports</vh></v>
<v t="ekr.20080516150804.1684"><vh>_get_module_with_imports</vh></v>
<v t="ekr.20080516150804.1685"><vh>_get_moving_element</vh></v>
<v t="ekr.20080516150804.1686"><vh>_get_moving_region</vh></v>
<v t="ekr.20080516150804.1687"><vh>_add_imports2</vh></v>
</v>
<v t="ekr.20080516150804.1688"><vh>class MoveModule</vh>
<v t="ekr.20080516150804.1689"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1690"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1691"><vh>_calculate_changes</vh></v>
<v t="ekr.20080516150804.1692"><vh>_new_modname</vh></v>
<v t="ekr.20080516150804.1693"><vh>_new_import</vh></v>
<v t="ekr.20080516150804.1694"><vh>_change_moving_module</vh></v>
<v t="ekr.20080516150804.1695"><vh>_change_occurrences_in_module</vh></v>
</v>
<v t="ekr.20080516150804.1696"><vh>class _ChangeMoveOccurrencesHandle</vh>
<v t="ekr.20080516150804.1697"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1698"><vh>occurred_inside_skip</vh></v>
<v t="ekr.20080516150804.1699"><vh>occurred_outside_skip</vh></v>
</v>
<v t="ekr.20080516150804.1700"><vh>class _MoveTools</vh>
<v t="ekr.20080516150804.1701"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1702"><vh>remove_old_imports</vh></v>
<v t="ekr.20080516150804.1703"><vh>rename_in_module</vh></v>
<v t="ekr.20080516150804.1704"><vh>occurs_in_module</vh></v>
<v t="ekr.20080516150804.1705"><vh>_create_finder</vh></v>
<v t="ekr.20080516150804.1706"><vh>new_pymodule</vh></v>
<v t="ekr.20080516150804.1707"><vh>new_source</vh></v>
<v t="ekr.20080516150804.1708"><vh>add_imports</vh></v>
</v>
<v t="ekr.20080516150804.1709"><vh>_add_imports_to_module</vh></v>
<v t="ekr.20080516150804.1710"><vh>moving_code_with_imports</vh></v>
<v t="ekr.20080516150804.1711"><vh>class ModuleSkipRenamerHandle</vh>
<v t="ekr.20080516150804.1712"><vh>occurred_outside_skip</vh></v>
<v t="ekr.20080516150804.1713"><vh>occurred_inside_skip</vh></v>
</v>
<v t="ekr.20080516150804.1714"><vh>class ModuleSkipRenamer</vh>
<v t="ekr.20080516150804.1715"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1716"><vh>get_changed_module</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1717"><vh>refactor\multiproject.py</vh>
<v t="ekr.20080516150804.1718"><vh>multiproject declarations</vh></v>
<v t="ekr.20080516150804.1719"><vh>class MultiProjectRefactoring</vh>
<v t="ekr.20080516150804.1720"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1721"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.1722"><vh>class _MultiRefactoring</vh>
<v t="ekr.20080516150804.1723"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1724"><vh>get_all_changes</vh></v>
<v t="ekr.20080516150804.1725"><vh>__getattr__</vh></v>
<v t="ekr.20080516150804.1726"><vh>_resources_for_args</vh></v>
<v t="ekr.20080516150804.1727"><vh>_change_project_resource</vh></v>
<v t="ekr.20080516150804.1728"><vh>project</vh></v>
<v t="ekr.20080516150804.1729"><vh>main_refactoring</vh></v>
</v>
<v t="ekr.20080516150804.1730"><vh>perform</vh></v>
</v>
<v t="ekr.20080516150804.1731"><vh>refactor\occurrences.py</vh>
<v t="ekr.20080516150804.1732"><vh>occurrences declarations</vh></v>
<v t="ekr.20080516150804.1733"><vh>class Finder</vh>
<v t="ekr.20080516150804.1734"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1735"><vh>find_occurrences</vh></v>
</v>
<v t="ekr.20080516150804.1736"><vh>create_finder</vh></v>
<v t="ekr.20080516150804.1737"><vh>class Occurrence</vh>
<v t="ekr.20080516150804.1738"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1739"><vh>get_word_range</vh></v>
<v t="ekr.20080516150804.1740"><vh>get_primary_range</vh></v>
<v t="ekr.20080516150804.1741"><vh>get_pyname</vh></v>
<v t="ekr.20080516150804.1742"><vh>get_primary_and_pyname</vh></v>
<v t="ekr.20080516150804.1743"><vh>is_in_import_statement</vh></v>
<v t="ekr.20080516150804.1744"><vh>is_called</vh></v>
<v t="ekr.20080516150804.1745"><vh>is_defined</vh></v>
<v t="ekr.20080516150804.1746"><vh>is_a_fixed_primary</vh></v>
<v t="ekr.20080516150804.1747"><vh>is_written</vh></v>
<v t="ekr.20080516150804.1748"><vh>is_unsure</vh></v>
</v>
<v t="ekr.20080516150804.1749"><vh>same_pyname</vh></v>
<v t="ekr.20080516150804.1750"><vh>unsure_pyname</vh></v>
<v t="ekr.20080516150804.1751"><vh>class PyNameFilter</vh>
<v t="ekr.20080516150804.1752"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1753"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.1754"><vh>class InHierarchyFilter</vh>
<v t="ekr.20080516150804.1755"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1756"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1757"><vh>_get_containing_class</vh></v>
<v t="ekr.20080516150804.1758"><vh>_get_root_classes</vh></v>
</v>
<v t="ekr.20080516150804.1759"><vh>class UnsureFilter</vh>
<v t="ekr.20080516150804.1760"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1761"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.1762"><vh>class NoImportsFilter</vh>
<v t="ekr.20080516150804.1763"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.1764"><vh>class CallsFilter</vh>
<v t="ekr.20080516150804.1765"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.1766"><vh>class _TextualFinder</vh>
<v t="ekr.20080516150804.1767"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1768"><vh>find_offsets</vh></v>
<v t="ekr.20080516150804.1769"><vh>_re_search</vh></v>
<v t="ekr.20080516150804.1770"><vh>_normal_search</vh></v>
<v t="ekr.20080516150804.1771"><vh>_is_id_char</vh></v>
<v t="ekr.20080516150804.1772"><vh>_fast_file_query</vh></v>
<v t="ekr.20080516150804.1773"><vh>_get_source</vh></v>
<v t="ekr.20080516150804.1774"><vh>_get_occurrence_pattern</vh></v>
<v t="ekr.20080516150804.1775"><vh>any</vh></v>
</v>
<v t="ekr.20080516150804.1776"><vh>class _OccurrenceToolsCreator</vh>
<v t="ekr.20080516150804.1777"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1778"><vh>name_finder</vh></v>
<v t="ekr.20080516150804.1779"><vh>source_code</vh></v>
<v t="ekr.20080516150804.1780"><vh>word_finder</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1781"><vh>refactor\patchedast.py</vh>
<v t="ekr.20080516150804.1782"><vh>patchedast declarations</vh></v>
<v t="ekr.20080516150804.1783"><vh>get_patched_ast</vh></v>
<v t="ekr.20080516150804.1784"><vh>patch_ast</vh></v>
<v t="ekr.20080516150804.1785"><vh>node_region</vh></v>
<v t="ekr.20080516150804.1786"><vh>write_ast</vh></v>
<v t="ekr.20080516150804.1787"><vh>class MismatchedTokenError</vh></v>
<v t="ekr.20080516150804.1788"><vh>class _PatchingASTWalker</vh>
<v t="ekr.20080516150804.1789"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1790"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1791"><vh>_handle</vh></v>
<v t="ekr.20080516150804.1792"><vh>_handle_parens</vh></v>
<v t="ekr.20080516150804.1793"><vh>_eat_surrounding_parens</vh></v>
<v t="ekr.20080516150804.1794"><vh>_count_needed_parens</vh></v>
<v t="ekr.20080516150804.1795"><vh>_find_next_statement_start</vh></v>
<v t="ekr.20080516150804.1796"><vh>_get_op</vh></v>
<v t="ekr.20080516150804.1797"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.1798"><vh>_Assert</vh></v>
<v t="ekr.20080516150804.1799"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.1800"><vh>_AugAssign</vh></v>
<v t="ekr.20080516150804.1801"><vh>_Repr</vh></v>
<v t="ekr.20080516150804.1802"><vh>_BinOp</vh></v>
<v t="ekr.20080516150804.1803"><vh>_BoolOp</vh></v>
<v t="ekr.20080516150804.1804"><vh>_Break</vh></v>
<v t="ekr.20080516150804.1805"><vh>_Call</vh></v>
<v t="ekr.20080516150804.1806"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.1807"><vh>_Compare</vh></v>
<v t="ekr.20080516150804.1808"><vh>_Delete</vh></v>
<v t="ekr.20080516150804.1809"><vh>_Num</vh></v>
<v t="ekr.20080516150804.1810"><vh>_Str</vh></v>
<v t="ekr.20080516150804.1811"><vh>_Continue</vh></v>
<v t="ekr.20080516150804.1812"><vh>_Dict</vh></v>
<v t="ekr.20080516150804.1813"><vh>_Ellipsis</vh></v>
<v t="ekr.20080516150804.1814"><vh>_Expr</vh></v>
<v t="ekr.20080516150804.1815"><vh>_Exec</vh></v>
<v t="ekr.20080516150804.1816"><vh>_For</vh></v>
<v t="ekr.20080516150804.1817"><vh>_ImportFrom</vh></v>
<v t="ekr.20080516150804.1818"><vh>_alias</vh></v>
<v t="ekr.20080516150804.1819"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1820"><vh>_arguments</vh></v>
<v t="ekr.20080516150804.1821"><vh>_add_args_to_children</vh></v>
<v t="ekr.20080516150804.1822"><vh>_add_tuple_parameter</vh></v>
<v t="ekr.20080516150804.1823"><vh>_GeneratorExp</vh></v>
<v t="ekr.20080516150804.1824"><vh>_comprehension</vh></v>
<v t="ekr.20080516150804.1825"><vh>_Global</vh></v>
<v t="ekr.20080516150804.1826"><vh>_If</vh></v>
<v t="ekr.20080516150804.1827"><vh>_is_elif</vh></v>
<v t="ekr.20080516150804.1828"><vh>_IfExp</vh></v>
<v t="ekr.20080516150804.1829"><vh>_Import</vh></v>
<v t="ekr.20080516150804.1830"><vh>_keyword</vh></v>
<v t="ekr.20080516150804.1831"><vh>_Lambda</vh></v>
<v t="ekr.20080516150804.1832"><vh>_List</vh></v>
<v t="ekr.20080516150804.1833"><vh>_ListComp</vh></v>
<v t="ekr.20080516150804.1834"><vh>_Module</vh></v>
<v t="ekr.20080516150804.1835"><vh>_Name</vh></v>
<v t="ekr.20080516150804.1836"><vh>_Pass</vh></v>
<v t="ekr.20080516150804.1837"><vh>_Print</vh></v>
<v t="ekr.20080516150804.1838"><vh>_Raise</vh></v>
<v t="ekr.20080516150804.1839"><vh>_Return</vh></v>
<v t="ekr.20080516150804.1840"><vh>_Sliceobj</vh></v>
<v t="ekr.20080516150804.1841"><vh>_Index</vh></v>
<v t="ekr.20080516150804.1842"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.1843"><vh>_Slice</vh></v>
<v t="ekr.20080516150804.1844"><vh>_TryFinally</vh></v>
<v t="ekr.20080516150804.1845"><vh>_TryExcept</vh></v>
<v t="ekr.20080516150804.1846"><vh>_ExceptHandler</vh></v>
<v t="ekr.20080516150804.1847"><vh>_excepthandler</vh></v>
<v t="ekr.20080516150804.1848"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.1849"><vh>_UnaryOp</vh></v>
<v t="ekr.20080516150804.1850"><vh>_Yield</vh></v>
<v t="ekr.20080516150804.1851"><vh>_While</vh></v>
<v t="ekr.20080516150804.1852"><vh>_With</vh></v>
<v t="ekr.20080516150804.1853"><vh>_child_nodes</vh></v>
</v>
<v t="ekr.20080516150804.1854"><vh>class _Source</vh>
<v t="ekr.20080516150804.1855"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1856"><vh>consume</vh></v>
<v t="ekr.20080516150804.1857"><vh>consume_string</vh></v>
<v t="ekr.20080516150804.1858"><vh>consume_number</vh></v>
<v t="ekr.20080516150804.1859"><vh>consume_not_equal</vh></v>
<v t="ekr.20080516150804.1860"><vh>_good_token</vh></v>
<v t="ekr.20080516150804.1861"><vh>_skip_comment</vh></v>
<v t="ekr.20080516150804.1862"><vh>_get_location</vh></v>
<v t="ekr.20080516150804.1863"><vh>_consume_pattern</vh></v>
<v t="ekr.20080516150804.1864"><vh>till_token</vh></v>
<v t="ekr.20080516150804.1865"><vh>get</vh></v>
<v t="ekr.20080516150804.1866"><vh>rfind_token</vh></v>
<v t="ekr.20080516150804.1867"><vh>from_offset</vh></v>
<v t="ekr.20080516150804.1868"><vh>find_backwards</vh></v>
<v t="ekr.20080516150804.1869"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1870"><vh>__getslice__</vh></v>
<v t="ekr.20080516150804.1871"><vh>_get_number_pattern</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1872"><vh>refactor\rename.py</vh>
<v t="ekr.20080516150804.1873"><vh>rename declarations</vh></v>
<v t="ekr.20080516150804.1874"><vh>class Rename</vh>
<v t="ekr.20080516150804.1875"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1876"><vh>get_old_name</vh></v>
<v t="ekr.20080516150804.1877"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1878"><vh>_is_allowed_to_move</vh></v>
<v t="ekr.20080516150804.1879"><vh>_is_renaming_a_function_local_name</vh></v>
<v t="ekr.20080516150804.1880"><vh>_is_renaming_a_module</vh></v>
<v t="ekr.20080516150804.1881"><vh>is_method</vh></v>
<v t="ekr.20080516150804.1882"><vh>_rename_module</vh></v>
</v>
<v t="ekr.20080516150804.1883"><vh>class ChangeOccurrences</vh>
<v t="ekr.20080516150804.1884"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1885"><vh>get_old_name</vh></v>
<v t="ekr.20080516150804.1886"><vh>_get_scope_offset</vh></v>
<v t="ekr.20080516150804.1887"><vh>get_changes</vh></v>
</v>
<v t="ekr.20080516150804.1888"><vh>rename_in_module</vh></v>
</v>
<v t="ekr.20080516150804.1889"><vh>refactor\restructure.py</vh>
<v t="ekr.20080516150804.1890"><vh>restructure declarations</vh></v>
<v t="ekr.20080516150804.1891"><vh>class Restructure</vh>
<v t="ekr.20080516150804.1892"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1893"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.1894"><vh>_compute_changes</vh></v>
<v t="ekr.20080516150804.1895"><vh>_add_imports</vh></v>
<v t="ekr.20080516150804.1896"><vh>_get_import_infos</vh></v>
<v t="ekr.20080516150804.1897"><vh>make_checks</vh></v>
<v t="ekr.20080516150804.1898"><vh>_evaluate</vh></v>
</v>
<v t="ekr.20080516150804.1899"><vh>replace</vh></v>
<v t="ekr.20080516150804.1900"><vh>class _ChangeComputer</vh>
<v t="ekr.20080516150804.1901"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1902"><vh>get_changed</vh></v>
<v t="ekr.20080516150804.1903"><vh>_is_expression</vh></v>
<v t="ekr.20080516150804.1904"><vh>_get_matched_text</vh></v>
<v t="ekr.20080516150804.1905"><vh>_get_node_text</vh></v>
<v t="ekr.20080516150804.1906"><vh>_auto_indent</vh></v>
<v t="ekr.20080516150804.1907"><vh>_get_nearest_roots</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1908"><vh>refactor\similarfinder.py</vh>
<v t="ekr.20080516150804.1909"><vh>similarfinder declarations</vh></v>
<v t="ekr.20080516150804.1910"><vh>class BadNameInCheckError</vh></v>
<v t="ekr.20080516150804.1911"><vh>class SimilarFinder</vh>
<v t="ekr.20080516150804.1912"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1913"><vh>get_matches</vh></v>
<v t="ekr.20080516150804.1914"><vh>get_match_regions</vh></v>
<v t="ekr.20080516150804.1915"><vh>_does_match</vh></v>
</v>
<v t="ekr.20080516150804.1916"><vh>class RawSimilarFinder</vh>
<v t="ekr.20080516150804.1917"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1918"><vh>_simple_does_match</vh></v>
<v t="ekr.20080516150804.1919"><vh>_init_using_ast</vh></v>
<v t="ekr.20080516150804.1920"><vh>get_matches</vh></v>
<v t="ekr.20080516150804.1921"><vh>_get_matched_asts</vh></v>
<v t="ekr.20080516150804.1922"><vh>_create_pattern</vh></v>
<v t="ekr.20080516150804.1923"><vh>_replace_wildcards</vh></v>
</v>
<v t="ekr.20080516150804.1924"><vh>class _ASTMatcher</vh>
<v t="ekr.20080516150804.1925"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1926"><vh>find_matches</vh></v>
<v t="ekr.20080516150804.1927"><vh>_check_node</vh></v>
<v t="ekr.20080516150804.1928"><vh>_check_expression</vh></v>
<v t="ekr.20080516150804.1929"><vh>_check_statements</vh></v>
<v t="ekr.20080516150804.1930"><vh>__check_stmt_list</vh></v>
<v t="ekr.20080516150804.1931"><vh>_match_nodes</vh></v>
<v t="ekr.20080516150804.1932"><vh>_get_children</vh></v>
<v t="ekr.20080516150804.1933"><vh>_match_stmts</vh></v>
<v t="ekr.20080516150804.1934"><vh>_match_wildcard</vh></v>
</v>
<v t="ekr.20080516150804.1935"><vh>class Match</vh>
<v t="ekr.20080516150804.1936"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1937"><vh>get_region</vh></v>
<v t="ekr.20080516150804.1938"><vh>get_ast</vh></v>
</v>
<v t="ekr.20080516150804.1939"><vh>class ExpressionMatch</vh>
<v t="ekr.20080516150804.1940"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1941"><vh>get_region</vh></v>
</v>
<v t="ekr.20080516150804.1942"><vh>class StatementMatch</vh>
<v t="ekr.20080516150804.1943"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1944"><vh>get_region</vh></v>
</v>
<v t="ekr.20080516150804.1945"><vh>class CodeTemplate</vh>
<v t="ekr.20080516150804.1946"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1947"><vh>_find_names</vh></v>
<v t="ekr.20080516150804.1948"><vh>get_names</vh></v>
<v t="ekr.20080516150804.1949"><vh>substitute</vh></v>
<v t="ekr.20080516150804.1950"><vh>_get_pattern</vh></v>
</v>
<v t="ekr.20080516150804.1951"><vh>class _RopeVariable</vh>
<v t="ekr.20080516150804.1952"><vh>get_var</vh></v>
<v t="ekr.20080516150804.1953"><vh>is_var</vh></v>
<v t="ekr.20080516150804.1954"><vh>get_base</vh></v>
<v t="ekr.20080516150804.1955"><vh>_get_normal</vh></v>
<v t="ekr.20080516150804.1956"><vh>_get_any</vh></v>
<v t="ekr.20080516150804.1957"><vh>_is_normal</vh></v>
<v t="ekr.20080516150804.1958"><vh>_is_var</vh></v>
</v>
<v t="ekr.20080516150804.1959"><vh>make_pattern</vh></v>
<v t="ekr.20080516150804.1960"><vh>_pydefined_to_str</vh></v>
</v>
<v t="ekr.20080516150804.1961"><vh>refactor\sourceutils.py</vh>
<v t="ekr.20080516150804.1962"><vh>sourceutils declarations</vh></v>
<v t="ekr.20080516150804.1963"><vh>get_indents</vh></v>
<v t="ekr.20080516150804.1964"><vh>find_minimum_indents</vh></v>
<v t="ekr.20080516150804.1965"><vh>indent_lines</vh></v>
<v t="ekr.20080516150804.1966"><vh>fix_indentation</vh></v>
<v t="ekr.20080516150804.1967"><vh>add_methods</vh></v>
<v t="ekr.20080516150804.1968"><vh>get_body</vh></v>
<v t="ekr.20080516150804.1969"><vh>get_body_region</vh></v>
<v t="ekr.20080516150804.1970"><vh>get_indent</vh></v>
</v>
<v t="ekr.20080516150804.1971"><vh>refactor\suites.py</vh>
<v t="ekr.20080516150804.1972"><vh>suites declarations</vh></v>
<v t="ekr.20080516150804.1973"><vh>find_visible</vh></v>
<v t="ekr.20080516150804.1974"><vh>find_visible_for_suite</vh></v>
<v t="ekr.20080516150804.1975"><vh>ast_suite_tree</vh></v>
<v t="ekr.20080516150804.1976"><vh>class Suite</vh>
<v t="ekr.20080516150804.1977"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1978"><vh>get_start</vh></v>
<v t="ekr.20080516150804.1979"><vh>get_children</vh></v>
<v t="ekr.20080516150804.1980"><vh>local_start</vh></v>
<v t="ekr.20080516150804.1981"><vh>local_end</vh></v>
<v t="ekr.20080516150804.1982"><vh>find_suite</vh></v>
<v t="ekr.20080516150804.1983"><vh>_get_level</vh></v>
</v>
<v t="ekr.20080516150804.1984"><vh>class _SuiteWalker</vh>
<v t="ekr.20080516150804.1985"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1986"><vh>_If</vh></v>
<v t="ekr.20080516150804.1987"><vh>_For</vh></v>
<v t="ekr.20080516150804.1988"><vh>_While</vh></v>
<v t="ekr.20080516150804.1989"><vh>_With</vh></v>
<v t="ekr.20080516150804.1990"><vh>_TryFinally</vh></v>
<v t="ekr.20080516150804.1991"><vh>_TryExcept</vh></v>
<v t="ekr.20080516150804.1992"><vh>_add_if_like_node</vh></v>
<v t="ekr.20080516150804.1993"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1994"><vh>_ClassDef</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1995"><vh>refactor\topackage.py</vh>
<v t="ekr.20080516150804.1996"><vh>topackage declarations</vh></v>
<v t="ekr.20080516150804.1997"><vh>class ModuleToPackage</vh>
<v t="ekr.20080516150804.1998"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1999"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.2000"><vh>_transform_relatives_to_absolute</vh></v>
</v>
</v>
<v t="ekr.20080516150804.2001"><vh>refactor\usefunction.py</vh>
<v t="ekr.20080516150804.2002"><vh>usefunction declarations</vh></v>
<v t="ekr.20080516150804.2003"><vh>class UseFunction</vh>
<v t="ekr.20080516150804.2004"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2005"><vh>_check_returns</vh></v>
<v t="ekr.20080516150804.2006"><vh>get_changes</vh></v>
<v t="ekr.20080516150804.2007"><vh>get_function_name</vh></v>
<v t="ekr.20080516150804.2008"><vh>_restructure</vh></v>
<v t="ekr.20080516150804.2009"><vh>_find_temps</vh></v>
<v t="ekr.20080516150804.2010"><vh>_module_name</vh></v>
<v t="ekr.20080516150804.2011"><vh>_make_pattern</vh></v>
<v t="ekr.20080516150804.2012"><vh>_get_body</vh></v>
<v t="ekr.20080516150804.2013"><vh>_make_goal</vh></v>
<v t="ekr.20080516150804.2014"><vh>_does_return</vh></v>
<v t="ekr.20080516150804.2015"><vh>_is_expression</vh></v>
</v>
<v t="ekr.20080516150804.2016"><vh>find_temps</vh></v>
<v t="ekr.20080516150804.2017"><vh>_returns_last</vh></v>
<v t="ekr.20080516150804.2018"><vh>_yield_count</vh></v>
<v t="ekr.20080516150804.2019"><vh>_return_count</vh></v>
<v t="ekr.20080516150804.2020"><vh>class _ReturnOrYieldFinder</vh>
<v t="ekr.20080516150804.2021"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2022"><vh>_Return</vh></v>
<v t="ekr.20080516150804.2023"><vh>_Yield</vh></v>
<v t="ekr.20080516150804.2024"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.2025"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.2026"><vh>start_walking</vh></v>
</v>
</v>
<v t="ekr.20080516150804.2027"><vh>refactor\wildcards.py</vh>
<v t="ekr.20080516150804.2028"><vh>wildcards declarations</vh></v>
<v t="ekr.20080516150804.2029"><vh>class Wildcard</vh>
<v t="ekr.20080516150804.2030"><vh>get_name</vh></v>
<v t="ekr.20080516150804.2031"><vh>matches</vh></v>
</v>
<v t="ekr.20080516150804.2032"><vh>class Suspect</vh>
<v t="ekr.20080516150804.2033"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.2034"><vh>class DefaultWildcard</vh>
<v t="ekr.20080516150804.2035"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2036"><vh>get_name</vh></v>
<v t="ekr.20080516150804.2037"><vh>matches</vh></v>
<v t="ekr.20080516150804.2038"><vh>_check_object</vh></v>
<v t="ekr.20080516150804.2039"><vh>_check_exact</vh></v>
</v>
<v t="ekr.20080516150804.2040"><vh>parse_arg</vh></v>
<v t="ekr.20080516150804.2041"><vh>class _CheckObject</vh>
<v t="ekr.20080516150804.2042"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2043"><vh>__call__</vh></v>
<v t="ekr.20080516150804.2044"><vh>_get_super_classes</vh></v>
<v t="ekr.20080516150804.2045"><vh>_same_pyobject</vh></v>
<v t="ekr.20080516150804.2046"><vh>_same_pyname</vh></v>
<v t="ekr.20080516150804.2047"><vh>_unsure_pyname</vh></v>
<v t="ekr.20080516150804.2048"><vh>_split_name</vh></v>
<v t="ekr.20080516150804.2049"><vh>_evaluate_node</vh></v>
<v t="ekr.20080516150804.2050"><vh>_evaluate</vh></v>
</v>
</v>
<v t="ekr.20080516150804.2051"><vh>refactor\__init__.py</vh>
<v t="ekr.20080516150804.2052"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20080516150804.2053"><vh>rope-0.8.2\rope\refactor\importutils</vh>
<v t="ekr.20080516150804.2054"><vh>refactor\importutils\actions.py</vh>
<v t="ekr.20080516150804.2055"><vh>actions declarations</vh></v>
<v t="ekr.20080516150804.2056"><vh>class ImportInfoVisitor</vh>
<v t="ekr.20080516150804.2057"><vh>dispatch</vh></v>
<v t="ekr.20080516150804.2058"><vh>visitEmptyImport</vh></v>
<v t="ekr.20080516150804.2059"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2060"><vh>visitFromImport</vh></v>
</v>
<v t="ekr.20080516150804.2061"><vh>class RelativeToAbsoluteVisitor</vh>
<v t="ekr.20080516150804.2062"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2063"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2064"><vh>_get_relative_to_absolute_list</vh></v>
<v t="ekr.20080516150804.2065"><vh>visitFromImport</vh></v>
</v>
<v t="ekr.20080516150804.2066"><vh>class FilteringVisitor</vh>
<v t="ekr.20080516150804.2067"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2068"><vh>_transform_can_select</vh></v>
<v t="ekr.20080516150804.2069"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2070"><vh>visitFromImport</vh></v>
</v>
<v t="ekr.20080516150804.2071"><vh>class RemovingVisitor</vh>
<v t="ekr.20080516150804.2072"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2073"><vh>dispatch</vh></v>
</v>
<v t="ekr.20080516150804.2074"><vh>class AddingVisitor</vh>
<v t="ekr.20080516150804.2075"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2076"><vh>dispatch</vh></v>
<v t="ekr.20080516150804.2077"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2078"><vh>visitFromImport</vh></v>
</v>
<v t="ekr.20080516150804.2079"><vh>class ExpandStarsVisitor</vh>
<v t="ekr.20080516150804.2080"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2081"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2082"><vh>visitFromImport</vh></v>
</v>
<v t="ekr.20080516150804.2083"><vh>class SelfImportVisitor</vh>
<v t="ekr.20080516150804.2084"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2085"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2086"><vh>visitFromImport</vh></v>
<v t="ekr.20080516150804.2087"><vh>_importing_names_from_self</vh></v>
</v>
<v t="ekr.20080516150804.2088"><vh>class SortingVisitor</vh>
<v t="ekr.20080516150804.2089"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2090"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2091"><vh>visitFromImport</vh></v>
<v t="ekr.20080516150804.2092"><vh>_check_imported_resource</vh></v>
<v t="ekr.20080516150804.2093"><vh>standard_modules</vh></v>
</v>
<v t="ekr.20080516150804.2094"><vh>class LongImportVisitor</vh>
<v t="ekr.20080516150804.2095"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2096"><vh>visitNormalImport</vh></v>
<v t="ekr.20080516150804.2097"><vh>_is_long</vh></v>
</v>
<v t="ekr.20080516150804.2098"><vh>_is_future</vh></v>
</v>
<v t="ekr.20080516150804.2099"><vh>refactor\importutils\importinfo.py</vh>
<v t="ekr.20080516150804.2100"><vh>class ImportStatement</vh>
<v t="ekr.20080516150804.2101"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2102"><vh>_get_import_info</vh></v>
<v t="ekr.20080516150804.2103"><vh>_set_import_info</vh></v>
<v t="ekr.20080516150804.2104"><vh>get_import_statement</vh></v>
<v t="ekr.20080516150804.2105"><vh>empty_import</vh></v>
<v t="ekr.20080516150804.2106"><vh>move</vh></v>
<v t="ekr.20080516150804.2107"><vh>get_old_location</vh></v>
<v t="ekr.20080516150804.2108"><vh>get_new_start</vh></v>
<v t="ekr.20080516150804.2109"><vh>is_changed</vh></v>
<v t="ekr.20080516150804.2110"><vh>accept</vh></v>
</v>
<v t="ekr.20080516150804.2111"><vh>class ImportInfo</vh>
<v t="ekr.20080516150804.2112"><vh>get_imported_primaries</vh></v>
<v t="ekr.20080516150804.2113"><vh>get_imported_names</vh></v>
<v t="ekr.20080516150804.2114"><vh>get_import_statement</vh></v>
<v t="ekr.20080516150804.2115"><vh>is_empty</vh></v>
<v t="ekr.20080516150804.2116"><vh>__hash__</vh></v>
<v t="ekr.20080516150804.2117"><vh>_are_name_and_alias_lists_equal</vh></v>
<v t="ekr.20080516150804.2118"><vh>__eq__</vh></v>
<v t="ekr.20080516150804.2119"><vh>get_empty_import</vh></v>
</v>
<v t="ekr.20080516150804.2120"><vh>class NormalImport</vh>
<v t="ekr.20080516150804.2121"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2122"><vh>get_imported_primaries</vh></v>
<v t="ekr.20080516150804.2123"><vh>get_import_statement</vh></v>
<v t="ekr.20080516150804.2124"><vh>is_empty</vh></v>
</v>
<v t="ekr.20080516150804.2125"><vh>class FromImport</vh>
<v t="ekr.20080516150804.2126"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2127"><vh>get_imported_primaries</vh></v>
<v t="ekr.20080516150804.2128"><vh>get_imported_resource</vh></v>
<v t="ekr.20080516150804.2129"><vh>get_imported_module</vh></v>
<v t="ekr.20080516150804.2130"><vh>get_import_statement</vh></v>
<v t="ekr.20080516150804.2131"><vh>is_empty</vh></v>
<v t="ekr.20080516150804.2132"><vh>is_star_import</vh></v>
</v>
<v t="ekr.20080516150804.2133"><vh>class EmptyImport</vh>
<v t="ekr.20080516150804.2134"><vh>is_empty</vh></v>
<v t="ekr.20080516150804.2135"><vh>get_imported_primaries</vh></v>
</v>
<v t="ekr.20080516150804.2136"><vh>get_module_name</vh></v>
<v t="ekr.20080516150804.2137"><vh>class ImportContext</vh>
<v t="ekr.20080516150804.2138"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.2139"><vh>refactor\importutils\module_imports.py</vh>
<v t="ekr.20080516150804.2140"><vh>module_imports declarations</vh></v>
<v t="ekr.20080516150804.2141"><vh>class ModuleImports</vh>
<v t="ekr.20080516150804.2142"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2143"><vh>imports</vh></v>
<v t="ekr.20080516150804.2144"><vh>_get_unbound_names</vh></v>
<v t="ekr.20080516150804.2145"><vh>remove_unused_imports</vh></v>
<v t="ekr.20080516150804.2146"><vh>get_used_imports</vh></v>
<v t="ekr.20080516150804.2147"><vh>get_changed_source</vh></v>
<v t="ekr.20080516150804.2148"><vh>_get_import_location</vh></v>
<v t="ekr.20080516150804.2149"><vh>_compare_import_locations</vh></v>
<v t="ekr.20080516150804.2150"><vh>_remove_imports</vh></v>
<v t="ekr.20080516150804.2151"><vh>_first_non_blank_line</vh></v>
<v t="ekr.20080516150804.2152"><vh>add_import</vh></v>
<v t="ekr.20080516150804.2153"><vh>_get_new_import_blanks</vh></v>
<v t="ekr.20080516150804.2154"><vh>_get_new_import_lineno</vh></v>
<v t="ekr.20080516150804.2155"><vh>filter_names</vh></v>
<v t="ekr.20080516150804.2156"><vh>expand_stars</vh></v>
<v t="ekr.20080516150804.2157"><vh>remove_duplicates</vh></v>
<v t="ekr.20080516150804.2158"><vh>get_relative_to_absolute_list</vh></v>
<v t="ekr.20080516150804.2159"><vh>get_self_import_fix_and_rename_list</vh></v>
<v t="ekr.20080516150804.2160"><vh>_current_folder</vh></v>
<v t="ekr.20080516150804.2161"><vh>sort_imports</vh></v>
<v t="ekr.20080516150804.2162"><vh>_first_import_line</vh></v>
<v t="ekr.20080516150804.2163"><vh>_compare_imports</vh></v>
<v t="ekr.20080516150804.2164"><vh>_move_imports</vh></v>
<v t="ekr.20080516150804.2165"><vh>handle_long_imports</vh></v>
</v>
<v t="ekr.20080516150804.2166"><vh>class _OneTimeSelector</vh>
<v t="ekr.20080516150804.2167"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2168"><vh>__call__</vh></v>
<v t="ekr.20080516150804.2169"><vh>_get_dotted_tokens</vh></v>
<v t="ekr.20080516150804.2170"><vh>_can_name_be_added</vh></v>
</v>
<v t="ekr.20080516150804.2171"><vh>class _UnboundNameFinder</vh>
<v t="ekr.20080516150804.2172"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2173"><vh>_visit_child_scope</vh></v>
<v t="ekr.20080516150804.2174"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.2175"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.2176"><vh>_Name</vh></v>
<v t="ekr.20080516150804.2177"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.2178"><vh>_get_root</vh></v>
<v t="ekr.20080516150804.2179"><vh>is_bound</vh></v>
<v t="ekr.20080516150804.2180"><vh>add_unbound</vh></v>
</v>
<v t="ekr.20080516150804.2181"><vh>class _GlobalUnboundNameFinder</vh>
<v t="ekr.20080516150804.2182"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2183"><vh>_get_root</vh></v>
<v t="ekr.20080516150804.2184"><vh>is_bound</vh></v>
<v t="ekr.20080516150804.2185"><vh>add_unbound</vh></v>
<v t="ekr.20080516150804.2186"><vh>_is_node_interesting</vh></v>
</v>
<v t="ekr.20080516150804.2187"><vh>class _LocalUnboundNameFinder</vh>
<v t="ekr.20080516150804.2188"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2189"><vh>_get_root</vh></v>
<v t="ekr.20080516150804.2190"><vh>is_bound</vh></v>
<v t="ekr.20080516150804.2191"><vh>add_unbound</vh></v>
</v>
<v t="ekr.20080516150804.2192"><vh>class _GlobalImportFinder</vh>
<v t="ekr.20080516150804.2193"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2194"><vh>visit_import</vh></v>
<v t="ekr.20080516150804.2195"><vh>_count_empty_lines_before</vh></v>
<v t="ekr.20080516150804.2196"><vh>_count_empty_lines_after</vh></v>
<v t="ekr.20080516150804.2197"><vh>get_separating_line_count</vh></v>
<v t="ekr.20080516150804.2198"><vh>_get_text</vh></v>
<v t="ekr.20080516150804.2199"><vh>visit_from</vh></v>
<v t="ekr.20080516150804.2200"><vh>_get_names</vh></v>
<v t="ekr.20080516150804.2201"><vh>find_import_statements</vh></v>
</v>
</v>
<v t="ekr.20080516150804.2202"><vh>refactor\importutils\__init__.py</vh>
<v t="ekr.20080516150804.2203"><vh>__init__ declarations</vh></v>
<v t="ekr.20080516150804.2204"><vh>class ImportOrganizer</vh>
<v t="ekr.20080516150804.2205"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2206"><vh>organize_imports</vh></v>
<v t="ekr.20080516150804.2207"><vh>expand_star_imports</vh></v>
<v t="ekr.20080516150804.2208"><vh>froms_to_imports</vh></v>
<v t="ekr.20080516150804.2209"><vh>relatives_to_absolutes</vh></v>
<v t="ekr.20080516150804.2210"><vh>handle_long_imports</vh></v>
<v t="ekr.20080516150804.2211"><vh>_perform_command_on_import_tools</vh></v>
<v t="ekr.20080516150804.2212"><vh>_line_filter</vh></v>
</v>
<v t="ekr.20080516150804.2213"><vh>class ImportTools</vh>
<v t="ekr.20080516150804.2214"><vh>__init__</vh></v>
<v t="ekr.20080516150804.2215"><vh>get_import</vh></v>
<v t="ekr.20080516150804.2216"><vh>get_from_import</vh></v>
<v t="ekr.20080516150804.2217"><vh>module_imports</vh></v>
<v t="ekr.20080516150804.2218"><vh>froms_to_imports</vh></v>
<v t="ekr.20080516150804.2219"><vh>expand_stars</vh></v>
<v t="ekr.20080516150804.2220"><vh>_from_to_normal</vh></v>
<v t="ekr.20080516150804.2221"><vh>_clean_up_imports</vh></v>
<v t="ekr.20080516150804.2222"><vh>relatives_to_absolutes</vh></v>
<v t="ekr.20080516150804.2223"><vh>_is_transformable_to_normal</vh></v>
<v t="ekr.20080516150804.2224"><vh>organize_imports</vh></v>
<v t="ekr.20080516150804.2225"><vh>_remove_self_imports</vh></v>
<v t="ekr.20080516150804.2226"><vh>_rename_in_module</vh></v>
<v t="ekr.20080516150804.2227"><vh>sort_imports</vh></v>
<v t="ekr.20080516150804.2228"><vh>handle_long_imports</vh></v>
</v>
<v t="ekr.20080516150804.2229"><vh>get_imports</vh></v>
<v t="ekr.20080516150804.2230"><vh>get_module_imports</vh></v>
<v t="ekr.20080516150804.2231"><vh>add_import</vh></v>
</v>
</v>
</v>
<v t="ekr.20080516150804.13"><vh>rope-0.8.2\rope\base</vh>
<v t="ekr.20080516150804.1003"><vh>base\__init__.py</vh>
<v t="ekr.20080516150804.1004"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20080516150804.14"><vh>base\arguments.py</vh>
<v t="ekr.20080516150804.15"><vh>arguments declarations</vh></v>
<v t="ekr.20080516150804.16"><vh>class Arguments</vh>
<v t="ekr.20080516150804.17"><vh>__init__</vh></v>
<v t="ekr.20080516150804.18"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.19"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.20"><vh>get_instance_pyname</vh></v>
<v t="ekr.20080516150804.21"><vh>_evaluate</vh></v>
</v>
<v t="ekr.20080516150804.22"><vh>create_arguments</vh></v>
<v t="ekr.20080516150804.23"><vh>class ObjectArguments</vh>
<v t="ekr.20080516150804.24"><vh>__init__</vh></v>
<v t="ekr.20080516150804.25"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.26"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.27"><vh>get_instance_pyname</vh></v>
</v>
<v t="ekr.20080516150804.28"><vh>class MixedArguments</vh>
<v t="ekr.20080516150804.29"><vh>__init__</vh></v>
<v t="ekr.20080516150804.30"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.31"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.32"><vh>get_instance_pyname</vh></v>
</v>
<v t="ekr.20080516150804.33"><vh>_is_method_call</vh></v>
</v>
<v t="ekr.20080516150804.34"><vh>base\ast.py</vh>
<v t="ekr.20080516150804.35"><vh>ast declarations</vh></v>
<v t="ekr.20080516150804.36"><vh>parse</vh></v>
<v t="ekr.20080516150804.37"><vh>walk</vh></v>
<v t="ekr.20080516150804.38"><vh>get_child_nodes</vh></v>
<v t="ekr.20080516150804.39"><vh>call_for_nodes</vh></v>
<v t="ekr.20080516150804.40"><vh>get_children</vh></v>
</v>
<v t="ekr.20080516150804.41"><vh>base\astutils.py</vh>
<v t="ekr.20080516150804.42"><vh>astutils declarations</vh></v>
<v t="ekr.20080516150804.43"><vh>get_name_levels</vh></v>
<v t="ekr.20080516150804.44"><vh>class _NodeNameCollector</vh>
<v t="ekr.20080516150804.45"><vh>__init__</vh></v>
<v t="ekr.20080516150804.46"><vh>_add_node</vh></v>
<v t="ekr.20080516150804.47"><vh>_added</vh></v>
<v t="ekr.20080516150804.48"><vh>_Name</vh></v>
<v t="ekr.20080516150804.49"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.50"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.51"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.52"><vh>_Slice</vh></v>
</v>
</v>
<v t="ekr.20080516150804.53"><vh>base\builtins.py</vh>
<v t="ekr.20080516150804.54"><vh>builtins declarations</vh></v>
<v t="ekr.20080516150804.55"><vh>class BuiltinModule</vh>
<v t="ekr.20080516150804.56"><vh>__init__</vh></v>
<v t="ekr.20080516150804.57"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.58"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.59"><vh>get_name</vh></v>
<v t="ekr.20080516150804.60"><vh>_calculate_attributes</vh></v>
<v t="ekr.20080516150804.61"><vh>module</vh></v>
</v>
<v t="ekr.20080516150804.62"><vh>class _BuiltinElement</vh>
<v t="ekr.20080516150804.63"><vh>__init__</vh></v>
<v t="ekr.20080516150804.64"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.65"><vh>get_name</vh></v>
<v t="ekr.20080516150804.66"><vh>parent</vh></v>
</v>
<v t="ekr.20080516150804.67"><vh>class BuiltinClass</vh>
<v t="ekr.20080516150804.68"><vh>__init__</vh></v>
<v t="ekr.20080516150804.69"><vh>get_attributes</vh></v>
</v>
<v t="ekr.20080516150804.70"><vh>class BuiltinFunction</vh>
<v t="ekr.20080516150804.71"><vh>__init__</vh></v>
<v t="ekr.20080516150804.72"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.73"><vh>get_param_names</vh></v>
</v>
<v t="ekr.20080516150804.74"><vh>_object_attributes</vh></v>
<v t="ekr.20080516150804.75"><vh>_create_builtin_type_getter</vh></v>
<v t="ekr.20080516150804.76"><vh>_create_builtin_getter</vh></v>
<v t="ekr.20080516150804.77"><vh>class _CallContext</vh>
<v t="ekr.20080516150804.78"><vh>__init__</vh></v>
<v t="ekr.20080516150804.79"><vh>_get_scope_and_pyname</vh></v>
<v t="ekr.20080516150804.80"><vh>get_argument</vh></v>
<v t="ekr.20080516150804.81"><vh>get_pyname</vh></v>
<v t="ekr.20080516150804.82"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.83"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.84"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.85"><vh>save_per_name</vh></v>
</v>
<v t="ekr.20080516150804.86"><vh>class _AttributeCollector</vh>
<v t="ekr.20080516150804.87"><vh>__init__</vh></v>
<v t="ekr.20080516150804.88"><vh>__call__</vh></v>
<v t="ekr.20080516150804.89"><vh>__setitem__</vh></v>
</v>
<v t="ekr.20080516150804.90"><vh>class List</vh>
<v t="ekr.20080516150804.91"><vh>__init__</vh></v>
<v t="ekr.20080516150804.92"><vh>_new_list</vh></v>
<v t="ekr.20080516150804.93"><vh>_list_add</vh></v>
<v t="ekr.20080516150804.94"><vh>_self_set</vh></v>
<v t="ekr.20080516150804.95"><vh>_list_get</vh></v>
<v t="ekr.20080516150804.96"><vh>_iterator_get</vh></v>
<v t="ekr.20080516150804.97"><vh>_self_get</vh></v>
</v>
<v t="ekr.20080516150804.98"><vh>class Dict</vh>
<v t="ekr.20080516150804.99"><vh>__init__</vh></v>
<v t="ekr.20080516150804.100"><vh>_new_dict</vh></v>
<v t="ekr.20080516150804.101"><vh>_dict_add</vh></v>
<v t="ekr.20080516150804.102"><vh>_item_get</vh></v>
<v t="ekr.20080516150804.103"><vh>_value_get</vh></v>
<v t="ekr.20080516150804.104"><vh>_key_get</vh></v>
<v t="ekr.20080516150804.105"><vh>_value_list</vh></v>
<v t="ekr.20080516150804.106"><vh>_key_list</vh></v>
<v t="ekr.20080516150804.107"><vh>_item_list</vh></v>
<v t="ekr.20080516150804.108"><vh>_value_iter</vh></v>
<v t="ekr.20080516150804.109"><vh>_key_iter</vh></v>
<v t="ekr.20080516150804.110"><vh>_item_iter</vh></v>
<v t="ekr.20080516150804.111"><vh>_self_get</vh></v>
<v t="ekr.20080516150804.112"><vh>_self_set</vh></v>
</v>
<v t="ekr.20080516150804.113"><vh>class Tuple</vh>
<v t="ekr.20080516150804.114"><vh>__init__</vh></v>
<v t="ekr.20080516150804.115"><vh>get_holding_objects</vh></v>
<v t="ekr.20080516150804.116"><vh>_new_tuple</vh></v>
</v>
<v t="ekr.20080516150804.117"><vh>class Set</vh>
<v t="ekr.20080516150804.118"><vh>__init__</vh></v>
<v t="ekr.20080516150804.119"><vh>_new_set</vh></v>
<v t="ekr.20080516150804.120"><vh>_set_add</vh></v>
<v t="ekr.20080516150804.121"><vh>_self_set</vh></v>
<v t="ekr.20080516150804.122"><vh>_set_get</vh></v>
<v t="ekr.20080516150804.123"><vh>_iterator_get</vh></v>
<v t="ekr.20080516150804.124"><vh>_self_get</vh></v>
</v>
<v t="ekr.20080516150804.125"><vh>class Str</vh>
<v t="ekr.20080516150804.126"><vh>__init__</vh></v>
<v t="ekr.20080516150804.127"><vh>get_doc</vh></v>
</v>
<v t="ekr.20080516150804.128"><vh>class BuiltinName</vh>
<v t="ekr.20080516150804.129"><vh>__init__</vh></v>
<v t="ekr.20080516150804.130"><vh>get_object</vh></v>
<v t="ekr.20080516150804.131"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.132"><vh>class Iterator</vh>
<v t="ekr.20080516150804.133"><vh>__init__</vh></v>
<v t="ekr.20080516150804.134"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.135"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.136"><vh>class Generator</vh>
<v t="ekr.20080516150804.137"><vh>__init__</vh></v>
<v t="ekr.20080516150804.138"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.139"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.140"><vh>class File</vh>
<v t="ekr.20080516150804.141"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.142"><vh>class Property</vh>
<v t="ekr.20080516150804.143"><vh>__init__</vh></v>
<v t="ekr.20080516150804.144"><vh>get_property_object</vh></v>
</v>
<v t="ekr.20080516150804.145"><vh>_property_function</vh></v>
<v t="ekr.20080516150804.146"><vh>class Lambda</vh>
<v t="ekr.20080516150804.147"><vh>__init__</vh></v>
<v t="ekr.20080516150804.148"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.149"><vh>get_pattributes</vh></v>
</v>
<v t="ekr.20080516150804.150"><vh>class BuiltinObject</vh>
<v t="ekr.20080516150804.151"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.152"><vh>class BuiltinType</vh>
<v t="ekr.20080516150804.153"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.154"><vh>_infer_sequence_for_pyname</vh></v>
<v t="ekr.20080516150804.155"><vh>_create_builtin</vh></v>
<v t="ekr.20080516150804.156"><vh>_range_function</vh></v>
<v t="ekr.20080516150804.157"><vh>_reversed_function</vh></v>
<v t="ekr.20080516150804.158"><vh>_sorted_function</vh></v>
<v t="ekr.20080516150804.159"><vh>_super_function</vh></v>
<v t="ekr.20080516150804.160"><vh>_zip_function</vh></v>
<v t="ekr.20080516150804.161"><vh>_enumerate_function</vh></v>
<v t="ekr.20080516150804.162"><vh>_iter_function</vh></v>
<v t="ekr.20080516150804.163"><vh>_input_function</vh></v>
</v>
<v t="ekr.20080516150804.164"><vh>base\change.py</vh>
<v t="ekr.20080516150804.165"><vh>change declarations</vh></v>
<v t="ekr.20080516150804.166"><vh>class Change</vh>
<v t="ekr.20080516150804.167"><vh>do</vh></v>
<v t="ekr.20080516150804.168"><vh>undo</vh></v>
<v t="ekr.20080516150804.169"><vh>get_description</vh></v>
<v t="ekr.20080516150804.170"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.171"><vh>class ChangeSet</vh>
<v t="ekr.20080516150804.172"><vh>__init__</vh></v>
<v t="ekr.20080516150804.173"><vh>do</vh></v>
<v t="ekr.20080516150804.174"><vh>undo</vh></v>
<v t="ekr.20080516150804.175"><vh>add_change</vh></v>
<v t="ekr.20080516150804.176"><vh>get_description</vh></v>
<v t="ekr.20080516150804.177"><vh>__str__</vh></v>
<v t="ekr.20080516150804.178"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.179"><vh>_handle_job_set</vh></v>
<v t="ekr.20080516150804.180"><vh>class ChangeContents</vh>
<v t="ekr.20080516150804.181"><vh>__init__</vh></v>
<v t="ekr.20080516150804.182"><vh>do</vh></v>
<v t="ekr.20080516150804.183"><vh>undo</vh></v>
<v t="ekr.20080516150804.184"><vh>__str__</vh></v>
<v t="ekr.20080516150804.185"><vh>get_description</vh></v>
<v t="ekr.20080516150804.186"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.187"><vh>class MoveResource</vh>
<v t="ekr.20080516150804.188"><vh>__init__</vh></v>
<v t="ekr.20080516150804.189"><vh>do</vh></v>
<v t="ekr.20080516150804.190"><vh>undo</vh></v>
<v t="ekr.20080516150804.191"><vh>__str__</vh></v>
<v t="ekr.20080516150804.192"><vh>get_description</vh></v>
<v t="ekr.20080516150804.193"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.194"><vh>class CreateResource</vh>
<v t="ekr.20080516150804.195"><vh>__init__</vh></v>
<v t="ekr.20080516150804.196"><vh>do</vh></v>
<v t="ekr.20080516150804.197"><vh>undo</vh></v>
<v t="ekr.20080516150804.198"><vh>__str__</vh></v>
<v t="ekr.20080516150804.199"><vh>get_description</vh></v>
<v t="ekr.20080516150804.200"><vh>get_changed_resources</vh></v>
<v t="ekr.20080516150804.201"><vh>_get_child_path</vh></v>
</v>
<v t="ekr.20080516150804.202"><vh>class CreateFolder</vh>
<v t="ekr.20080516150804.203"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.204"><vh>class CreateFile</vh>
<v t="ekr.20080516150804.205"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.206"><vh>class RemoveResource</vh>
<v t="ekr.20080516150804.207"><vh>__init__</vh></v>
<v t="ekr.20080516150804.208"><vh>do</vh></v>
<v t="ekr.20080516150804.209"><vh>undo</vh></v>
<v t="ekr.20080516150804.210"><vh>__str__</vh></v>
<v t="ekr.20080516150804.211"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.212"><vh>count_changes</vh></v>
<v t="ekr.20080516150804.213"><vh>create_job_set</vh></v>
<v t="ekr.20080516150804.214"><vh>class _ResourceOperations</vh>
<v t="ekr.20080516150804.215"><vh>__init__</vh></v>
<v t="ekr.20080516150804.216"><vh>_get_fscommands</vh></v>
<v t="ekr.20080516150804.217"><vh>write_file</vh></v>
<v t="ekr.20080516150804.218"><vh>move</vh></v>
<v t="ekr.20080516150804.219"><vh>create</vh></v>
<v t="ekr.20080516150804.220"><vh>remove</vh></v>
<v t="ekr.20080516150804.221"><vh>_create_resource</vh></v>
</v>
<v t="ekr.20080516150804.222"><vh>_get_destination_for_move</vh></v>
<v t="ekr.20080516150804.223"><vh>class ChangeToData</vh>
<v t="ekr.20080516150804.224"><vh>convertChangeSet</vh></v>
<v t="ekr.20080516150804.225"><vh>convertChangeContents</vh></v>
<v t="ekr.20080516150804.226"><vh>convertMoveResource</vh></v>
<v t="ekr.20080516150804.227"><vh>convertCreateResource</vh></v>
<v t="ekr.20080516150804.228"><vh>convertRemoveResource</vh></v>
<v t="ekr.20080516150804.229"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.230"><vh>class DataToChange</vh>
<v t="ekr.20080516150804.231"><vh>__init__</vh></v>
<v t="ekr.20080516150804.232"><vh>makeChangeSet</vh></v>
<v t="ekr.20080516150804.233"><vh>makeChangeContents</vh></v>
<v t="ekr.20080516150804.234"><vh>makeMoveResource</vh></v>
<v t="ekr.20080516150804.235"><vh>makeCreateResource</vh></v>
<v t="ekr.20080516150804.236"><vh>makeRemoveResource</vh></v>
<v t="ekr.20080516150804.237"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.238"><vh>base\codeanalyze.py</vh>
<v t="ekr.20080516150804.239"><vh>codeanalyze declarations</vh></v>
<v t="ekr.20080516150804.240"><vh>class ChangeCollector</vh>
<v t="ekr.20080516150804.241"><vh>__init__</vh></v>
<v t="ekr.20080516150804.242"><vh>add_change</vh></v>
<v t="ekr.20080516150804.243"><vh>get_changed</vh></v>
</v>
<v t="ekr.20080516150804.244"><vh>class Lines</vh>
<v t="ekr.20080516150804.245"><vh>get_line</vh></v>
<v t="ekr.20080516150804.246"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.247"><vh>class SourceLinesAdapter</vh>
<v t="ekr.20080516150804.248"><vh>__init__</vh></v>
<v t="ekr.20080516150804.249"><vh>_initialize_line_starts</vh></v>
<v t="ekr.20080516150804.250"><vh>get_line</vh></v>
<v t="ekr.20080516150804.251"><vh>length</vh></v>
<v t="ekr.20080516150804.252"><vh>get_line_number</vh></v>
<v t="ekr.20080516150804.253"><vh>get_line_start</vh></v>
<v t="ekr.20080516150804.254"><vh>get_line_end</vh></v>
</v>
<v t="ekr.20080516150804.255"><vh>class ArrayLinesAdapter</vh>
<v t="ekr.20080516150804.256"><vh>__init__</vh></v>
<v t="ekr.20080516150804.257"><vh>get_line</vh></v>
<v t="ekr.20080516150804.258"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.259"><vh>class LinesToReadline</vh>
<v t="ekr.20080516150804.260"><vh>__init__</vh></v>
<v t="ekr.20080516150804.261"><vh>readline</vh></v>
<v t="ekr.20080516150804.262"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.263"><vh>class _CustomGenerator</vh>
<v t="ekr.20080516150804.264"><vh>__init__</vh></v>
<v t="ekr.20080516150804.265"><vh>__call__</vh></v>
<v t="ekr.20080516150804.266"><vh>_analyze_line</vh></v>
</v>
<v t="ekr.20080516150804.267"><vh>custom_generator</vh></v>
<v t="ekr.20080516150804.268"><vh>class LogicalLineFinder</vh>
<v t="ekr.20080516150804.269"><vh>__init__</vh></v>
<v t="ekr.20080516150804.270"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.271"><vh>generate_starts</vh></v>
<v t="ekr.20080516150804.272"><vh>generate_regions</vh></v>
<v t="ekr.20080516150804.273"><vh>_block_logical_line</vh></v>
<v t="ekr.20080516150804.274"><vh>_calculate_logical</vh></v>
<v t="ekr.20080516150804.275"><vh>_logical_lines</vh></v>
<v t="ekr.20080516150804.276"><vh>_first_non_blank</vh></v>
</v>
<v t="ekr.20080516150804.277"><vh>tokenizer_generator</vh></v>
<v t="ekr.20080516150804.278"><vh>class CachingLogicalLineFinder</vh>
<v t="ekr.20080516150804.279"><vh>__init__</vh></v>
<v t="ekr.20080516150804.280"><vh>starts</vh></v>
<v t="ekr.20080516150804.281"><vh>ends</vh></v>
<v t="ekr.20080516150804.282"><vh>_init_logicals</vh></v>
<v t="ekr.20080516150804.283"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.284"><vh>generate_starts</vh></v>
</v>
<v t="ekr.20080516150804.285"><vh>get_block_start</vh></v>
<v t="ekr.20080516150804.286"><vh>get_block_start_patterns</vh></v>
<v t="ekr.20080516150804.287"><vh>count_line_indents</vh></v>
<v t="ekr.20080516150804.288"><vh>get_string_pattern</vh></v>
<v t="ekr.20080516150804.289"><vh>get_comment_pattern</vh></v>
</v>
<v t="ekr.20080516150804.290"><vh>base\default_config.py</vh>
<v t="ekr.20080516150804.291"><vh>set_prefs</vh></v>
<v t="ekr.20080516150804.292"><vh>project_opened</vh></v>
</v>
<v t="ekr.20080516150804.293"><vh>base\evaluate.py</vh>
<v t="ekr.20080516150804.294"><vh>evaluate declarations</vh></v>
<v t="ekr.20080516150804.295"><vh>get_primary_and_pyname_at</vh></v>
<v t="ekr.20080516150804.296"><vh>get_pyname_at</vh></v>
<v t="ekr.20080516150804.297"><vh>get_statement_result</vh></v>
<v t="ekr.20080516150804.298"><vh>get_primary_and_result</vh></v>
<v t="ekr.20080516150804.299"><vh>get_pyname_in_scope</vh></v>
<v t="ekr.20080516150804.300"><vh>get_primary_and_pyname_in_scope</vh></v>
<v t="ekr.20080516150804.301"><vh>get_string_result</vh></v>
<v t="ekr.20080516150804.302"><vh>class ScopeNameFinder</vh>
<v t="ekr.20080516150804.303"><vh>__init__</vh></v>
<v t="ekr.20080516150804.304"><vh>_is_defined_in_class_body</vh></v>
<v t="ekr.20080516150804.305"><vh>_is_function_name_in_function_header</vh></v>
<v t="ekr.20080516150804.306"><vh>get_pyname_at</vh></v>
<v t="ekr.20080516150804.307"><vh>get_primary_and_pyname_at</vh></v>
<v t="ekr.20080516150804.308"><vh>get_enclosing_function</vh></v>
<v t="ekr.20080516150804.309"><vh>_find_module</vh></v>
</v>
<v t="ekr.20080516150804.310"><vh>class StatementEvaluator</vh>
<v t="ekr.20080516150804.311"><vh>__init__</vh></v>
<v t="ekr.20080516150804.312"><vh>_Name</vh></v>
<v t="ekr.20080516150804.313"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.314"><vh>_Call</vh></v>
<v t="ekr.20080516150804.315"><vh>_Str</vh></v>
<v t="ekr.20080516150804.316"><vh>_Num</vh></v>
<v t="ekr.20080516150804.317"><vh>_get_builtin_name</vh></v>
<v t="ekr.20080516150804.318"><vh>_BinOp</vh></v>
<v t="ekr.20080516150804.319"><vh>_BoolOp</vh></v>
<v t="ekr.20080516150804.320"><vh>_Repr</vh></v>
<v t="ekr.20080516150804.321"><vh>_UnaryOp</vh></v>
<v t="ekr.20080516150804.322"><vh>_Compare</vh></v>
<v t="ekr.20080516150804.323"><vh>_Dict</vh></v>
<v t="ekr.20080516150804.324"><vh>_List</vh></v>
<v t="ekr.20080516150804.325"><vh>_ListComp</vh></v>
<v t="ekr.20080516150804.326"><vh>_GeneratorExp</vh></v>
<v t="ekr.20080516150804.327"><vh>_what_does_comprehension_hold</vh></v>
<v t="ekr.20080516150804.328"><vh>_make_comprehension_scope</vh></v>
<v t="ekr.20080516150804.329"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.330"><vh>_get_object_for_node</vh></v>
<v t="ekr.20080516150804.331"><vh>_get_primary_and_object_for_node</vh></v>
<v t="ekr.20080516150804.332"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.333"><vh>_call_function</vh></v>
<v t="ekr.20080516150804.334"><vh>_Lambda</vh></v>
</v>
<v t="ekr.20080516150804.335"><vh>_get_evaluated_names</vh></v>
</v>
<v t="ekr.20080516150804.336"><vh>base\exceptions.py</vh>
<v t="ekr.20080516150804.337"><vh>class RopeError</vh></v>
<v t="ekr.20080516150804.338"><vh>class ResourceNotFoundError</vh></v>
<v t="ekr.20080516150804.339"><vh>class RefactoringError</vh></v>
<v t="ekr.20080516150804.340"><vh>class InterruptedTaskError</vh></v>
<v t="ekr.20080516150804.341"><vh>class HistoryError</vh></v>
<v t="ekr.20080516150804.342"><vh>class ModuleNotFoundError</vh></v>
<v t="ekr.20080516150804.343"><vh>class AttributeNotFoundError</vh></v>
<v t="ekr.20080516150804.344"><vh>class NameNotFoundError</vh></v>
<v t="ekr.20080516150804.345"><vh>class BadIdentifierError</vh></v>
<v t="ekr.20080516150804.346"><vh>class ModuleSyntaxError</vh>
<v t="ekr.20080516150804.347"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.348"><vh>class ModuleDecodeError</vh>
<v t="ekr.20080516150804.349"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.350"><vh>base\fscommands.py</vh>
<v t="ekr.20080516150804.351"><vh>fscommands declarations</vh></v>
<v t="ekr.20080516150804.352"><vh>create_fscommands</vh></v>
<v t="ekr.20080516150804.353"><vh>class FileSystemCommands</vh>
<v t="ekr.20080516150804.354"><vh>create_file</vh></v>
<v t="ekr.20080516150804.355"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.356"><vh>move</vh></v>
<v t="ekr.20080516150804.357"><vh>remove</vh></v>
<v t="ekr.20080516150804.358"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.359"><vh>class SubversionCommands</vh>
<v t="ekr.20080516150804.360"><vh>__init__</vh></v>
<v t="ekr.20080516150804.361"><vh>create_file</vh></v>
<v t="ekr.20080516150804.362"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.363"><vh>move</vh></v>
<v t="ekr.20080516150804.364"><vh>remove</vh></v>
<v t="ekr.20080516150804.365"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.366"><vh>class MercurialCommands</vh>
<v t="ekr.20080516150804.367"><vh>__init__</vh></v>
<v t="ekr.20080516150804.368"><vh>_import_mercurial</vh></v>
<v t="ekr.20080516150804.369"><vh>create_file</vh></v>
<v t="ekr.20080516150804.370"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.371"><vh>move</vh></v>
<v t="ekr.20080516150804.372"><vh>remove</vh></v>
<v t="ekr.20080516150804.373"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.374"><vh>class GITCommands</vh>
<v t="ekr.20080516150804.375"><vh>__init__</vh></v>
<v t="ekr.20080516150804.376"><vh>create_file</vh></v>
<v t="ekr.20080516150804.377"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.378"><vh>move</vh></v>
<v t="ekr.20080516150804.379"><vh>remove</vh></v>
<v t="ekr.20080516150804.380"><vh>write</vh></v>
<v t="ekr.20080516150804.381"><vh>_do</vh></v>
<v t="ekr.20080516150804.382"><vh>_in_dir</vh></v>
</v>
<v t="ekr.20080516150804.383"><vh>_execute</vh></v>
<v t="ekr.20080516150804.384"><vh>unicode_to_file_data</vh></v>
<v t="ekr.20080516150804.385"><vh>file_data_to_unicode</vh></v>
<v t="ekr.20080516150804.386"><vh>_decode_data</vh></v>
<v t="ekr.20080516150804.387"><vh>read_file_coding</vh></v>
<v t="ekr.20080516150804.388"><vh>read_str_coding</vh></v>
<v t="ekr.20080516150804.389"><vh>_find_coding</vh></v>
</v>
<v t="ekr.20080516150804.390"><vh>base\history.py</vh>
<v t="ekr.20080516150804.391"><vh>history declarations</vh></v>
<v t="ekr.20080516150804.392"><vh>class History</vh>
<v t="ekr.20080516150804.393"><vh>__init__</vh></v>
<v t="ekr.20080516150804.394"><vh>_load_history</vh></v>
<v t="ekr.20080516150804.395"><vh>do</vh></v>
<v t="ekr.20080516150804.396"><vh>_remove_extra_items</vh></v>
<v t="ekr.20080516150804.397"><vh>_is_change_interesting</vh></v>
<v t="ekr.20080516150804.398"><vh>undo</vh></v>
<v t="ekr.20080516150804.399"><vh>redo</vh></v>
<v t="ekr.20080516150804.400"><vh>_move_front</vh></v>
<v t="ekr.20080516150804.401"><vh>_find_dependencies</vh></v>
<v t="ekr.20080516150804.402"><vh>_perform_undos</vh></v>
<v t="ekr.20080516150804.403"><vh>_perform_redos</vh></v>
<v t="ekr.20080516150804.404"><vh>contents_before_current_change</vh></v>
<v t="ekr.20080516150804.405"><vh>_search_for_change_contents</vh></v>
<v t="ekr.20080516150804.406"><vh>write</vh></v>
<v t="ekr.20080516150804.407"><vh>get_file_undo_list</vh></v>
<v t="ekr.20080516150804.408"><vh>__str__</vh></v>
<v t="ekr.20080516150804.409"><vh>tobe_undone</vh></v>
<v t="ekr.20080516150804.410"><vh>tobe_redone</vh></v>
<v t="ekr.20080516150804.411"><vh>max_undos</vh></v>
<v t="ekr.20080516150804.412"><vh>save</vh></v>
<v t="ekr.20080516150804.413"><vh>compress</vh></v>
<v t="ekr.20080516150804.414"><vh>clear</vh></v>
</v>
<v t="ekr.20080516150804.415"><vh>class _FindChangeDependencies</vh>
<v t="ekr.20080516150804.416"><vh>__init__</vh></v>
<v t="ekr.20080516150804.417"><vh>find_dependencies</vh></v>
<v t="ekr.20080516150804.418"><vh>_depends_on</vh></v>
</v>
</v>
<v t="ekr.20080516150804.419"><vh>base\libutils.py</vh>
<v t="ekr.20080516150804.420"><vh>libutils declarations</vh></v>
<v t="ekr.20080516150804.421"><vh>path_to_resource</vh></v>
<v t="ekr.20080516150804.422"><vh>report_change</vh></v>
<v t="ekr.20080516150804.423"><vh>analyze_modules</vh></v>
</v>
<v t="ekr.20080516150804.424"><vh>base\prefs.py</vh>
<v t="ekr.20080516150804.425"><vh>class Prefs</vh>
<v t="ekr.20080516150804.426"><vh>__init__</vh></v>
<v t="ekr.20080516150804.427"><vh>set</vh></v>
<v t="ekr.20080516150804.428"><vh>add</vh></v>
<v t="ekr.20080516150804.429"><vh>get</vh></v>
<v t="ekr.20080516150804.430"><vh>add_callback</vh></v>
<v t="ekr.20080516150804.431"><vh>__setitem__</vh></v>
<v t="ekr.20080516150804.432"><vh>__getitem__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.433"><vh>base\project.py</vh>
<v t="ekr.20080516150804.434"><vh>project declarations</vh></v>
<v t="ekr.20080516150804.435"><vh>class _Project</vh>
<v t="ekr.20080516150804.436"><vh>__init__</vh></v>
<v t="ekr.20080516150804.437"><vh>get_resource</vh></v>
<v t="ekr.20080516150804.438"><vh>validate</vh></v>
<v t="ekr.20080516150804.439"><vh>add_observer</vh></v>
<v t="ekr.20080516150804.440"><vh>remove_observer</vh></v>
<v t="ekr.20080516150804.441"><vh>do</vh></v>
<v t="ekr.20080516150804.442"><vh>get_pycore</vh></v>
<v t="ekr.20080516150804.443"><vh>get_file</vh></v>
<v t="ekr.20080516150804.444"><vh>get_folder</vh></v>
<v t="ekr.20080516150804.445"><vh>is_ignored</vh></v>
<v t="ekr.20080516150804.446"><vh>get_prefs</vh></v>
<v t="ekr.20080516150804.447"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.448"><vh>_get_history</vh></v>
<v t="ekr.20080516150804.449"><vh>close</vh></v>
</v>
<v t="ekr.20080516150804.450"><vh>class Project</vh>
<v t="ekr.20080516150804.451"><vh>__init__</vh></v>
<v t="ekr.20080516150804.452"><vh>get_files</vh></v>
<v t="ekr.20080516150804.453"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.454"><vh>_init_ropefolder</vh></v>
<v t="ekr.20080516150804.455"><vh>_init_prefs</vh></v>
<v t="ekr.20080516150804.456"><vh>_default_config</vh></v>
<v t="ekr.20080516150804.457"><vh>_init_other_parts</vh></v>
<v t="ekr.20080516150804.458"><vh>is_ignored</vh></v>
<v t="ekr.20080516150804.459"><vh>sync</vh></v>
<v t="ekr.20080516150804.460"><vh>close</vh></v>
<v t="ekr.20080516150804.461"><vh>set</vh></v>
<v t="ekr.20080516150804.462"><vh>ropefolder</vh></v>
<v t="ekr.20080516150804.463"><vh>validate</vh></v>
</v>
<v t="ekr.20080516150804.464"><vh>class NoProject</vh>
<v t="ekr.20080516150804.465"><vh>__init__</vh></v>
<v t="ekr.20080516150804.466"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.467"><vh>get_resource</vh></v>
<v t="ekr.20080516150804.468"><vh>get_files</vh></v>
</v>
<v t="ekr.20080516150804.469"><vh>get_no_project</vh></v>
<v t="ekr.20080516150804.470"><vh>class _FileListCacher</vh>
<v t="ekr.20080516150804.471"><vh>__init__</vh></v>
<v t="ekr.20080516150804.472"><vh>get_files</vh></v>
<v t="ekr.20080516150804.473"><vh>observer</vh></v>
<v t="ekr.20080516150804.474"><vh>_updated_resources</vh></v>
<v t="ekr.20080516150804.475"><vh>_update_folder</vh></v>
<v t="ekr.20080516150804.476"><vh>_init_observer</vh></v>
<v t="ekr.20080516150804.477"><vh>_changed</vh></v>
<v t="ekr.20080516150804.478"><vh>_moved</vh></v>
<v t="ekr.20080516150804.479"><vh>_created</vh></v>
<v t="ekr.20080516150804.480"><vh>_removed</vh></v>
<v t="ekr.20080516150804.481"><vh>_validate</vh></v>
</v>
<v t="ekr.20080516150804.482"><vh>class _DataFiles</vh>
<v t="ekr.20080516150804.483"><vh>__init__</vh></v>
<v t="ekr.20080516150804.484"><vh>read_data</vh></v>
<v t="ekr.20080516150804.485"><vh>write_data</vh></v>
<v t="ekr.20080516150804.486"><vh>add_write_hook</vh></v>
<v t="ekr.20080516150804.487"><vh>write</vh></v>
<v t="ekr.20080516150804.488"><vh>_can_compress</vh></v>
<v t="ekr.20080516150804.489"><vh>_import_old_files</vh></v>
<v t="ekr.20080516150804.490"><vh>_get_opener</vh></v>
<v t="ekr.20080516150804.491"><vh>_get_file</vh></v>
</v>
<v t="ekr.20080516150804.492"><vh>_realpath</vh></v>
</v>
<v t="ekr.20080516150804.493"><vh>base\pycore.py</vh>
<v t="ekr.20080516150804.494"><vh>pycore declarations</vh></v>
<v t="ekr.20080516150804.495"><vh>class PyCore</vh>
<v t="ekr.20080516150804.496"><vh>__init__</vh></v>
<v t="ekr.20080516150804.497"><vh>_init_python_files</vh></v>
<v t="ekr.20080516150804.498"><vh>_init_resource_observer</vh></v>
<v t="ekr.20080516150804.499"><vh>_init_source_folders</vh></v>
<v t="ekr.20080516150804.500"><vh>_init_automatic_soa</vh></v>
<v t="ekr.20080516150804.501"><vh>automatic_soa</vh></v>
<v t="ekr.20080516150804.502"><vh>_file_changed_for_soa</vh></v>
<v t="ekr.20080516150804.503"><vh>is_python_file</vh></v>
<v t="ekr.20080516150804.504"><vh>get_module</vh></v>
<v t="ekr.20080516150804.505"><vh>_builtin_module</vh></v>
<v t="ekr.20080516150804.506"><vh>get_relative_module</vh></v>
<v t="ekr.20080516150804.507"><vh>get_string_module</vh></v>
<v t="ekr.20080516150804.508"><vh>get_string_scope</vh></v>
<v t="ekr.20080516150804.509"><vh>_invalidate_resource_cache</vh></v>
<v t="ekr.20080516150804.510"><vh>_find_module_in_source_folder</vh></v>
<v t="ekr.20080516150804.511"><vh>get_python_path_folders</vh></v>
<v t="ekr.20080516150804.512"><vh>find_module</vh></v>
<v t="ekr.20080516150804.513"><vh>find_relative_module</vh></v>
<v t="ekr.20080516150804.514"><vh>_find_module_resource_list</vh></v>
<v t="ekr.20080516150804.515"><vh>get_source_folders</vh></v>
<v t="ekr.20080516150804.516"><vh>resource_to_pyobject</vh></v>
<v t="ekr.20080516150804.517"><vh>get_python_files</vh></v>
<v t="ekr.20080516150804.518"><vh>_is_package</vh></v>
<v t="ekr.20080516150804.519"><vh>_find_source_folders</vh></v>
<v t="ekr.20080516150804.520"><vh>run_module</vh></v>
<v t="ekr.20080516150804.521"><vh>analyze_module (pyCore)</vh></v>
<v t="ekr.20080516150804.522"><vh>get_classes</vh></v>
<v t="ekr.20080516150804.523"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.524"><vh>class _ModuleCache</vh>
<v t="ekr.20080516150804.525"><vh>__init__</vh></v>
<v t="ekr.20080516150804.526"><vh>_invalidate_resource</vh></v>
<v t="ekr.20080516150804.527"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.528"><vh>forget_all_data</vh></v>
<v t="ekr.20080516150804.529"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.530"><vh>class _ExtensionCache</vh>
<v t="ekr.20080516150804.531"><vh>__init__</vh></v>
<v t="ekr.20080516150804.532"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.533"><vh>allowed</vh></v>
</v>
<v t="ekr.20080516150804.534"><vh>perform_soa_on_changed_scopes</vh></v>
<v t="ekr.20080516150804.535"><vh>class _TextChangeDetector</vh>
<v t="ekr.20080516150804.536"><vh>__init__</vh></v>
<v t="ekr.20080516150804.537"><vh>_set_diffs</vh></v>
<v t="ekr.20080516150804.538"><vh>is_changed</vh></v>
<v t="ekr.20080516150804.539"><vh>consume_changes</vh></v>
<v t="ekr.20080516150804.540"><vh>_get_changed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.541"><vh>base\pynames.py</vh>
<v t="ekr.20080516150804.542"><vh>pynames declarations</vh></v>
<v t="ekr.20080516150804.543"><vh>class PyName</vh>
<v t="ekr.20080516150804.544"><vh>get_object</vh></v>
<v t="ekr.20080516150804.545"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.546"><vh>class DefinedName</vh>
<v t="ekr.20080516150804.547"><vh>__init__</vh></v>
<v t="ekr.20080516150804.548"><vh>get_object</vh></v>
<v t="ekr.20080516150804.549"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.550"><vh>class AssignedName</vh></v>
<v t="ekr.20080516150804.551"><vh>class UnboundName</vh>
<v t="ekr.20080516150804.552"><vh>__init__</vh></v>
<v t="ekr.20080516150804.553"><vh>get_object</vh></v>
<v t="ekr.20080516150804.554"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.555"><vh>class AssignmentValue</vh>
<v t="ekr.20080516150804.556"><vh>__init__</vh></v>
<v t="ekr.20080516150804.557"><vh>get_lineno</vh></v>
</v>
<v t="ekr.20080516150804.558"><vh>class EvaluatedName</vh>
<v t="ekr.20080516150804.559"><vh>__init__</vh></v>
<v t="ekr.20080516150804.560"><vh>get_object</vh></v>
<v t="ekr.20080516150804.561"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.562"><vh>invalidate</vh></v>
</v>
<v t="ekr.20080516150804.563"><vh>class ParameterName</vh></v>
<v t="ekr.20080516150804.564"><vh>class ImportedModule</vh>
<v t="ekr.20080516150804.565"><vh>__init__</vh></v>
<v t="ekr.20080516150804.566"><vh>_current_folder</vh></v>
<v t="ekr.20080516150804.567"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.568"><vh>get_object</vh></v>
<v t="ekr.20080516150804.569"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.570"><vh>class ImportedName</vh>
<v t="ekr.20080516150804.571"><vh>__init__</vh></v>
<v t="ekr.20080516150804.572"><vh>_get_imported_pyname</vh></v>
<v t="ekr.20080516150804.573"><vh>get_object</vh></v>
<v t="ekr.20080516150804.574"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.575"><vh>_get_concluded_data</vh></v>
<v t="ekr.20080516150804.576"><vh>_circular_inference</vh></v>
<v t="ekr.20080516150804.577"><vh>class _Inferred</vh>
<v t="ekr.20080516150804.578"><vh>__init__</vh></v>
<v t="ekr.20080516150804.579"><vh>get</vh></v>
<v t="ekr.20080516150804.580"><vh>set</vh></v>
<v t="ekr.20080516150804.581"><vh>_get</vh></v>
</v>
</v>
<v t="ekr.20080516150804.582"><vh>base\pynamesdef.py</vh>
<v t="ekr.20080516150804.583"><vh>pynamesdef declarations</vh></v>
<v t="ekr.20080516150804.584"><vh>class AssignedName</vh>
<v t="ekr.20080516150804.585"><vh>__init__</vh></v>
<v t="ekr.20080516150804.586"><vh>_get_inferred</vh></v>
<v t="ekr.20080516150804.587"><vh>get_object</vh></v>
<v t="ekr.20080516150804.588"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.589"><vh>invalidate</vh></v>
</v>
<v t="ekr.20080516150804.590"><vh>class ParameterName</vh>
<v t="ekr.20080516150804.591"><vh>__init__</vh></v>
<v t="ekr.20080516150804.592"><vh>get_object</vh></v>
<v t="ekr.20080516150804.593"><vh>get_objects</vh></v>
<v t="ekr.20080516150804.594"><vh>get_definition_location</vh></v>
</v>
</v>
<v t="ekr.20080516150804.595"><vh>base\pyobjects.py</vh>
<v t="ekr.20080516150804.596"><vh>pyobjects declarations</vh></v>
<v t="ekr.20080516150804.597"><vh>class PyObject</vh>
<v t="ekr.20080516150804.598"><vh>__init__</vh></v>
<v t="ekr.20080516150804.599"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.600"><vh>get_attribute</vh></v>
<v t="ekr.20080516150804.601"><vh>get_type</vh></v>
<v t="ekr.20080516150804.602"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.603"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.604"><vh>__eq__</vh></v>
<v t="ekr.20080516150804.605"><vh>__hash__</vh></v>
<v t="ekr.20080516150804.606"><vh>__iter__</vh></v>
<v t="ekr.20080516150804.607"><vh>_get_base_type</vh></v>
</v>
<v t="ekr.20080516150804.608"><vh>get_base_type</vh></v>
<v t="ekr.20080516150804.609"><vh>get_unknown</vh></v>
<v t="ekr.20080516150804.610"><vh>class AbstractClass</vh>
<v t="ekr.20080516150804.611"><vh>__init__</vh></v>
<v t="ekr.20080516150804.612"><vh>get_name</vh></v>
<v t="ekr.20080516150804.613"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.614"><vh>get_superclasses</vh></v>
</v>
<v t="ekr.20080516150804.615"><vh>class AbstractFunction</vh>
<v t="ekr.20080516150804.616"><vh>__init__</vh></v>
<v t="ekr.20080516150804.617"><vh>get_name</vh></v>
<v t="ekr.20080516150804.618"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.619"><vh>get_param_names</vh></v>
<v t="ekr.20080516150804.620"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.621"><vh>class AbstractModule</vh>
<v t="ekr.20080516150804.622"><vh>__init__</vh></v>
<v t="ekr.20080516150804.623"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.624"><vh>get_resource</vh></v>
</v>
<v t="ekr.20080516150804.625"><vh>class PyDefinedObject</vh>
<v t="ekr.20080516150804.626"><vh>__init__</vh></v>
<v t="ekr.20080516150804.627"><vh>_get_structural_attributes</vh></v>
<v t="ekr.20080516150804.628"><vh>_get_concluded_attributes</vh></v>
<v t="ekr.20080516150804.629"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.630"><vh>get_attribute</vh></v>
<v t="ekr.20080516150804.631"><vh>get_scope</vh></v>
<v t="ekr.20080516150804.632"><vh>get_module</vh></v>
<v t="ekr.20080516150804.633"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.634"><vh>_get_defined_objects</vh></v>
<v t="ekr.20080516150804.635"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.636"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.637"><vh>get_ast</vh></v>
<v t="ekr.20080516150804.638"><vh>_create_scope</vh></v>
</v>
<v t="ekr.20080516150804.639"><vh>class PyFunction</vh></v>
<v t="ekr.20080516150804.640"><vh>class PyClass</vh></v>
<v t="ekr.20080516150804.641"><vh>class _ConcludedData</vh>
<v t="ekr.20080516150804.642"><vh>__init__</vh></v>
<v t="ekr.20080516150804.643"><vh>set</vh></v>
<v t="ekr.20080516150804.644"><vh>get</vh></v>
<v t="ekr.20080516150804.645"><vh>_invalidate</vh></v>
<v t="ekr.20080516150804.646"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.647"><vh>class _PyModule</vh>
<v t="ekr.20080516150804.648"><vh>__init__</vh></v>
<v t="ekr.20080516150804.649"><vh>_get_concluded_data</vh></v>
<v t="ekr.20080516150804.650"><vh>_forget_concluded_data</vh></v>
<v t="ekr.20080516150804.651"><vh>get_resource</vh></v>
</v>
<v t="ekr.20080516150804.652"><vh>class PyModule</vh></v>
<v t="ekr.20080516150804.653"><vh>class PyPackage</vh></v>
<v t="ekr.20080516150804.654"><vh>class IsBeingInferredError</vh></v>
</v>
<v t="ekr.20080516150804.655"><vh>base\pyobjectsdef.py</vh>
<v t="ekr.20080516150804.656"><vh>pyobjectsdef declarations</vh></v>
<v t="ekr.20080516150804.657"><vh>class PyFunction</vh>
<v t="ekr.20080516150804.658"><vh>__init__</vh></v>
<v t="ekr.20080516150804.659"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.660"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.661"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.662"><vh>_infer_parameters</vh></v>
<v t="ekr.20080516150804.663"><vh>_infer_returned</vh></v>
<v t="ekr.20080516150804.664"><vh>_handle_special_args</vh></v>
<v t="ekr.20080516150804.665"><vh>_set_parameter_pyobjects</vh></v>
<v t="ekr.20080516150804.666"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.667"><vh>get_parameter</vh></v>
<v t="ekr.20080516150804.668"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.669"><vh>get_name</vh></v>
<v t="ekr.20080516150804.670"><vh>get_param_names</vh></v>
<v t="ekr.20080516150804.671"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.672"><vh>decorators</vh></v>
</v>
<v t="ekr.20080516150804.673"><vh>class PyClass</vh>
<v t="ekr.20080516150804.674"><vh>__init__</vh></v>
<v t="ekr.20080516150804.675"><vh>get_superclasses</vh></v>
<v t="ekr.20080516150804.676"><vh>get_name</vh></v>
<v t="ekr.20080516150804.677"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.678"><vh>_get_bases</vh></v>
<v t="ekr.20080516150804.679"><vh>_create_scope</vh></v>
</v>
<v t="ekr.20080516150804.680"><vh>class PyModule</vh>
<v t="ekr.20080516150804.681"><vh>__init__</vh></v>
<v t="ekr.20080516150804.682"><vh>_init_source</vh></v>
<v t="ekr.20080516150804.683"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.684"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.685"><vh>lines</vh></v>
<v t="ekr.20080516150804.686"><vh>logical_lines</vh></v>
</v>
<v t="ekr.20080516150804.687"><vh>class PyPackage</vh>
<v t="ekr.20080516150804.688"><vh>__init__</vh></v>
<v t="ekr.20080516150804.689"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.690"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.691"><vh>_get_child_resources</vh></v>
<v t="ekr.20080516150804.692"><vh>_get_init_dot_py</vh></v>
<v t="ekr.20080516150804.693"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.694"><vh>get_module</vh></v>
</v>
<v t="ekr.20080516150804.695"><vh>class _AssignVisitor</vh>
<v t="ekr.20080516150804.696"><vh>__init__</vh></v>
<v t="ekr.20080516150804.697"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.698"><vh>_assigned</vh></v>
<v t="ekr.20080516150804.699"><vh>_Name</vh></v>
<v t="ekr.20080516150804.700"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.701"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.702"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.703"><vh>_Slice</vh></v>
</v>
<v t="ekr.20080516150804.704"><vh>class _ScopeVisitor</vh>
<v t="ekr.20080516150804.705"><vh>__init__</vh></v>
<v t="ekr.20080516150804.706"><vh>get_module</vh></v>
<v t="ekr.20080516150804.707"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.708"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.709"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.710"><vh>_AugAssign</vh></v>
<v t="ekr.20080516150804.711"><vh>_For</vh></v>
<v t="ekr.20080516150804.712"><vh>_assigned</vh></v>
<v t="ekr.20080516150804.713"><vh>_update_evaluated</vh></v>
<v t="ekr.20080516150804.714"><vh>_With</vh></v>
<v t="ekr.20080516150804.715"><vh>_excepthandler</vh></v>
<v t="ekr.20080516150804.716"><vh>_ExceptHandler</vh></v>
<v t="ekr.20080516150804.717"><vh>_Import</vh></v>
<v t="ekr.20080516150804.718"><vh>_ImportFrom</vh></v>
<v t="ekr.20080516150804.719"><vh>_is_ignored_import</vh></v>
<v t="ekr.20080516150804.720"><vh>_Global</vh></v>
</v>
<v t="ekr.20080516150804.721"><vh>class _GlobalVisitor</vh>
<v t="ekr.20080516150804.722"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.723"><vh>class _ClassVisitor</vh>
<v t="ekr.20080516150804.724"><vh>__init__</vh></v>
<v t="ekr.20080516150804.725"><vh>_FunctionDef</vh></v>
</v>
<v t="ekr.20080516150804.726"><vh>class _FunctionVisitor</vh>
<v t="ekr.20080516150804.727"><vh>__init__</vh></v>
<v t="ekr.20080516150804.728"><vh>_Return</vh></v>
<v t="ekr.20080516150804.729"><vh>_Yield</vh></v>
</v>
<v t="ekr.20080516150804.730"><vh>class _ClassInitVisitor</vh>
<v t="ekr.20080516150804.731"><vh>__init__</vh></v>
<v t="ekr.20080516150804.732"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.733"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.734"><vh>_Name</vh></v>
<v t="ekr.20080516150804.735"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.736"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.737"><vh>_For</vh></v>
<v t="ekr.20080516150804.738"><vh>_With</vh></v>
</v>
<v t="ekr.20080516150804.739"><vh>class StarImport</vh>
<v t="ekr.20080516150804.740"><vh>__init__</vh></v>
<v t="ekr.20080516150804.741"><vh>get_names</vh></v>
</v>
</v>
<v t="ekr.20080516150804.742"><vh>base\pyscopes.py</vh>
<v t="ekr.20080516150804.743"><vh>pyscopes declarations</vh></v>
<v t="ekr.20080516150804.744"><vh>class Scope</vh>
<v t="ekr.20080516150804.745"><vh>__init__</vh></v>
<v t="ekr.20080516150804.746"><vh>get_names</vh></v>
<v t="ekr.20080516150804.747"><vh>get_defined_names</vh></v>
<v t="ekr.20080516150804.748"><vh>get_name</vh></v>
<v t="ekr.20080516150804.749"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.750"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.751"><vh>get_scopes</vh></v>
<v t="ekr.20080516150804.752"><vh>lookup</vh></v>
<v t="ekr.20080516150804.753"><vh>get_propagated_names</vh></v>
<v t="ekr.20080516150804.754"><vh>_propagated_lookup</vh></v>
<v t="ekr.20080516150804.755"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.756"><vh>_get_global_scope</vh></v>
<v t="ekr.20080516150804.757"><vh>get_start</vh></v>
<v t="ekr.20080516150804.758"><vh>get_body_start</vh></v>
<v t="ekr.20080516150804.759"><vh>get_end</vh></v>
<v t="ekr.20080516150804.760"><vh>get_logical_end</vh></v>
<v t="ekr.20080516150804.761"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.762"><vh>class GlobalScope</vh>
<v t="ekr.20080516150804.763"><vh>__init__</vh></v>
<v t="ekr.20080516150804.764"><vh>get_start</vh></v>
<v t="ekr.20080516150804.765"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.766"><vh>get_name</vh></v>
<v t="ekr.20080516150804.767"><vh>get_names</vh></v>
<v t="ekr.20080516150804.768"><vh>get_inner_scope_for_line</vh></v>
<v t="ekr.20080516150804.769"><vh>get_inner_scope_for_offset</vh></v>
<v t="ekr.20080516150804.770"><vh>_get_scope_finder</vh></v>
<v t="ekr.20080516150804.771"><vh>builtin_names</vh></v>
</v>
<v t="ekr.20080516150804.772"><vh>class FunctionScope</vh>
<v t="ekr.20080516150804.773"><vh>__init__</vh></v>
<v t="ekr.20080516150804.774"><vh>_get_names</vh></v>
<v t="ekr.20080516150804.775"><vh>_visit_function</vh></v>
<v t="ekr.20080516150804.776"><vh>_get_returned_asts</vh></v>
<v t="ekr.20080516150804.777"><vh>_is_generator</vh></v>
<v t="ekr.20080516150804.778"><vh>get_names</vh></v>
<v t="ekr.20080516150804.779"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.780"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.781"><vh>invalidate_data</vh></v>
</v>
<v t="ekr.20080516150804.782"><vh>class ClassScope</vh>
<v t="ekr.20080516150804.783"><vh>__init__</vh></v>
<v t="ekr.20080516150804.784"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.785"><vh>get_propagated_names</vh></v>
</v>
<v t="ekr.20080516150804.786"><vh>class _HoldingScopeFinder</vh>
<v t="ekr.20080516150804.787"><vh>__init__</vh></v>
<v t="ekr.20080516150804.788"><vh>get_indents</vh></v>
<v t="ekr.20080516150804.789"><vh>get_location</vh></v>
<v t="ekr.20080516150804.790"><vh>_get_scope_indents</vh></v>
<v t="ekr.20080516150804.791"><vh>get_holding_scope</vh></v>
<v t="ekr.20080516150804.792"><vh>_is_empty_line</vh></v>
<v t="ekr.20080516150804.793"><vh>_get_body_indents</vh></v>
<v t="ekr.20080516150804.794"><vh>get_holding_scope_for_offset</vh></v>
<v t="ekr.20080516150804.795"><vh>find_scope_end</vh></v>
<v t="ekr.20080516150804.796"><vh>lines</vh></v>
<v t="ekr.20080516150804.797"><vh>code</vh></v>
<v t="ekr.20080516150804.798"><vh>logical_lines</vh></v>
</v>
<v t="ekr.20080516150804.799"><vh>class TemporaryScope</vh>
<v t="ekr.20080516150804.800"><vh>__init__</vh></v>
<v t="ekr.20080516150804.801"><vh>get_names</vh></v>
<v t="ekr.20080516150804.802"><vh>get_defined_names</vh></v>
<v t="ekr.20080516150804.803"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.804"><vh>get_kind</vh></v>
</v>
</v>
<v t="ekr.20080516150804.805"><vh>base\resourceobserver.py</vh>
<v t="ekr.20080516150804.806"><vh>resourceobserver declarations</vh></v>
<v t="ekr.20080516150804.807"><vh>class ResourceObserver</vh>
<v t="ekr.20080516150804.808"><vh>__init__</vh></v>
<v t="ekr.20080516150804.809"><vh>resource_changed</vh></v>
<v t="ekr.20080516150804.810"><vh>resource_moved</vh></v>
<v t="ekr.20080516150804.811"><vh>resource_created</vh></v>
<v t="ekr.20080516150804.812"><vh>resource_removed</vh></v>
<v t="ekr.20080516150804.813"><vh>validate</vh></v>
</v>
<v t="ekr.20080516150804.814"><vh>class FilteredResourceObserver</vh>
<v t="ekr.20080516150804.815"><vh>__init__</vh></v>
<v t="ekr.20080516150804.816"><vh>add_resource</vh></v>
<v t="ekr.20080516150804.817"><vh>remove_resource</vh></v>
<v t="ekr.20080516150804.818"><vh>clear_resources</vh></v>
<v t="ekr.20080516150804.819"><vh>resource_changed</vh></v>
<v t="ekr.20080516150804.820"><vh>_update_changes_caused_by_changed</vh></v>
<v t="ekr.20080516150804.821"><vh>_update_changes_caused_by_moved</vh></v>
<v t="ekr.20080516150804.822"><vh>_is_parent_changed</vh></v>
<v t="ekr.20080516150804.823"><vh>resource_moved</vh></v>
<v t="ekr.20080516150804.824"><vh>resource_created</vh></v>
<v t="ekr.20080516150804.825"><vh>_update_changes_caused_by_created</vh></v>
<v t="ekr.20080516150804.826"><vh>resource_removed</vh></v>
<v t="ekr.20080516150804.827"><vh>_perform_changes</vh></v>
<v t="ekr.20080516150804.828"><vh>validate</vh></v>
<v t="ekr.20080516150804.829"><vh>_search_resource_creations</vh></v>
<v t="ekr.20080516150804.830"><vh>_search_resource_moves</vh></v>
<v t="ekr.20080516150804.831"><vh>_search_resource_changes</vh></v>
<v t="ekr.20080516150804.832"><vh>_is_changed</vh></v>
<v t="ekr.20080516150804.833"><vh>_calculate_new_resource</vh></v>
</v>
<v t="ekr.20080516150804.834"><vh>class ChangeIndicator</vh>
<v t="ekr.20080516150804.835"><vh>get_indicator</vh></v>
</v>
<v t="ekr.20080516150804.836"><vh>class _Changes</vh>
<v t="ekr.20080516150804.837"><vh>__init__</vh></v>
<v t="ekr.20080516150804.838"><vh>add_changed</vh></v>
<v t="ekr.20080516150804.839"><vh>add_removed</vh></v>
<v t="ekr.20080516150804.840"><vh>add_created</vh></v>
</v>
</v>
<v t="ekr.20080516150804.841"><vh>base\resources.py</vh>
<v t="ekr.20080516150804.842"><vh>resources declarations</vh></v>
<v t="ekr.20080516150804.843"><vh>class Resource</vh>
<v t="ekr.20080516150804.844"><vh>__init__</vh></v>
<v t="ekr.20080516150804.845"><vh>move</vh></v>
<v t="ekr.20080516150804.846"><vh>remove</vh></v>
<v t="ekr.20080516150804.847"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.848"><vh>create</vh></v>
<v t="ekr.20080516150804.849"><vh>exists</vh></v>
<v t="ekr.20080516150804.850"><vh>parent</vh></v>
<v t="ekr.20080516150804.851"><vh>path</vh></v>
<v t="ekr.20080516150804.852"><vh>name</vh></v>
<v t="ekr.20080516150804.853"><vh>real_path</vh></v>
<v t="ekr.20080516150804.854"><vh>_get_destination_for_move</vh></v>
<v t="ekr.20080516150804.855"><vh>__eq__</vh></v>
<v t="ekr.20080516150804.856"><vh>__hash__</vh></v>
<v t="ekr.20080516150804.857"><vh>_perform_change</vh></v>
</v>
<v t="ekr.20080516150804.858"><vh>class File</vh>
<v t="ekr.20080516150804.859"><vh>__init__</vh></v>
<v t="ekr.20080516150804.860"><vh>read</vh></v>
<v t="ekr.20080516150804.861"><vh>read_bytes</vh></v>
<v t="ekr.20080516150804.862"><vh>write</vh></v>
<v t="ekr.20080516150804.863"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.864"><vh>create</vh></v>
</v>
<v t="ekr.20080516150804.865"><vh>class Folder</vh>
<v t="ekr.20080516150804.866"><vh>__init__</vh></v>
<v t="ekr.20080516150804.867"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.868"><vh>get_children</vh></v>
<v t="ekr.20080516150804.869"><vh>create_file</vh></v>
<v t="ekr.20080516150804.870"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.871"><vh>_get_child_path</vh></v>
<v t="ekr.20080516150804.872"><vh>get_child</vh></v>
<v t="ekr.20080516150804.873"><vh>has_child</vh></v>
<v t="ekr.20080516150804.874"><vh>get_files</vh></v>
<v t="ekr.20080516150804.875"><vh>get_folders</vh></v>
<v t="ekr.20080516150804.876"><vh>contains</vh></v>
<v t="ekr.20080516150804.877"><vh>create</vh></v>
</v>
<v t="ekr.20080516150804.878"><vh>class _ResourceMatcher</vh>
<v t="ekr.20080516150804.879"><vh>__init__</vh></v>
<v t="ekr.20080516150804.880"><vh>set_patterns</vh></v>
<v t="ekr.20080516150804.881"><vh>_add_pattern</vh></v>
<v t="ekr.20080516150804.882"><vh>does_match</vh></v>
<v t="ekr.20080516150804.883"><vh>compiled_patterns</vh></v>
</v>
</v>
<v t="ekr.20080516150804.884"><vh>base\simplify.py</vh>
<v t="ekr.20080516150804.885"><vh>simplify declarations</vh></v>
<v t="ekr.20080516150804.886"><vh>real_code</vh></v>
<v t="ekr.20080516150804.887"><vh>ignored_regions</vh></v>
</v>
<v t="ekr.20080516150804.888"><vh>base\taskhandle.py</vh>
<v t="ekr.20080516150804.889"><vh>taskhandle declarations</vh></v>
<v t="ekr.20080516150804.890"><vh>class TaskHandle</vh>
<v t="ekr.20080516150804.891"><vh>__init__</vh></v>
<v t="ekr.20080516150804.892"><vh>stop</vh></v>
<v t="ekr.20080516150804.893"><vh>current_jobset</vh></v>
<v t="ekr.20080516150804.894"><vh>add_observer</vh></v>
<v t="ekr.20080516150804.895"><vh>is_stopped</vh></v>
<v t="ekr.20080516150804.896"><vh>get_jobsets</vh></v>
<v t="ekr.20080516150804.897"><vh>create_jobset</vh></v>
<v t="ekr.20080516150804.898"><vh>_inform_observers</vh></v>
</v>
<v t="ekr.20080516150804.899"><vh>class JobSet</vh>
<v t="ekr.20080516150804.900"><vh>__init__</vh></v>
<v t="ekr.20080516150804.901"><vh>started_job</vh></v>
<v t="ekr.20080516150804.902"><vh>finished_job</vh></v>
<v t="ekr.20080516150804.903"><vh>check_status</vh></v>
<v t="ekr.20080516150804.904"><vh>get_active_job_name</vh></v>
<v t="ekr.20080516150804.905"><vh>get_percent_done</vh></v>
<v t="ekr.20080516150804.906"><vh>get_name</vh></v>
</v>
<v t="ekr.20080516150804.907"><vh>class NullTaskHandle</vh>
<v t="ekr.20080516150804.908"><vh>__init__</vh></v>
<v t="ekr.20080516150804.909"><vh>is_stopped</vh></v>
<v t="ekr.20080516150804.910"><vh>stop</vh></v>
<v t="ekr.20080516150804.911"><vh>create_jobset</vh></v>
<v t="ekr.20080516150804.912"><vh>get_jobsets</vh></v>
<v t="ekr.20080516150804.913"><vh>add_observer</vh></v>
</v>
<v t="ekr.20080516150804.914"><vh>class NullJobSet</vh>
<v t="ekr.20080516150804.915"><vh>started_job</vh></v>
<v t="ekr.20080516150804.916"><vh>finished_job</vh></v>
<v t="ekr.20080516150804.917"><vh>check_status</vh></v>
<v t="ekr.20080516150804.918"><vh>get_active_job_name</vh></v>
<v t="ekr.20080516150804.919"><vh>get_percent_done</vh></v>
<v t="ekr.20080516150804.920"><vh>get_name</vh></v>
</v>
</v>
<v t="ekr.20080516150804.921"><vh>base\utils.py</vh>
<v t="ekr.20080516150804.922"><vh>cacheit</vh></v>
<v t="ekr.20080516150804.923"><vh>prevent_recursion</vh></v>
<v t="ekr.20080516150804.924"><vh>ignore_exception</vh></v>
<v t="ekr.20080516150804.925"><vh>cached</vh></v>
<v t="ekr.20080516150804.926"><vh>class _Cached</vh>
<v t="ekr.20080516150804.927"><vh>__init__</vh></v>
<v t="ekr.20080516150804.928"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.929"><vh>base\worder.py</vh>
<v t="ekr.20080516150804.930"><vh>worder declarations</vh></v>
<v t="ekr.20080516150804.931"><vh>get_name_at</vh></v>
<v t="ekr.20080516150804.932"><vh>class Worder</vh>
<v t="ekr.20080516150804.933"><vh>__init__</vh></v>
<v t="ekr.20080516150804.934"><vh>_init_ignores</vh></v>
<v t="ekr.20080516150804.935"><vh>_context_call</vh></v>
<v t="ekr.20080516150804.936"><vh>get_primary_at</vh></v>
<v t="ekr.20080516150804.937"><vh>get_word_at</vh></v>
<v t="ekr.20080516150804.938"><vh>get_primary_range</vh></v>
<v t="ekr.20080516150804.939"><vh>get_splitted_primary_before</vh></v>
<v t="ekr.20080516150804.940"><vh>get_word_range</vh></v>
<v t="ekr.20080516150804.941"><vh>is_function_keyword_parameter</vh></v>
<v t="ekr.20080516150804.942"><vh>is_a_class_or_function_name_in_header</vh></v>
<v t="ekr.20080516150804.943"><vh>is_from_statement_module</vh></v>
<v t="ekr.20080516150804.944"><vh>is_from_aliased</vh></v>
<v t="ekr.20080516150804.945"><vh>find_parens_start_from_inside</vh></v>
<v t="ekr.20080516150804.946"><vh>is_a_name_after_from_import</vh></v>
<v t="ekr.20080516150804.947"><vh>is_from_statement</vh></v>
<v t="ekr.20080516150804.948"><vh>get_from_aliased</vh></v>
<v t="ekr.20080516150804.949"><vh>is_import_statement</vh></v>
<v t="ekr.20080516150804.950"><vh>is_assigned_here</vh></v>
<v t="ekr.20080516150804.951"><vh>is_a_function_being_called</vh></v>
<v t="ekr.20080516150804.952"><vh>get_word_parens_range</vh></v>
<v t="ekr.20080516150804.953"><vh>is_name_assigned_in_class_body</vh></v>
<v t="ekr.20080516150804.954"><vh>is_on_function_call_keyword</vh></v>
<v t="ekr.20080516150804.955"><vh>_find_parens_start</vh></v>
<v t="ekr.20080516150804.956"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.957"><vh>get_from_module</vh></v>
<v t="ekr.20080516150804.958"><vh>is_assigned_in_a_tuple_assignment</vh></v>
<v t="ekr.20080516150804.959"><vh>get_assignment_type</vh></v>
<v t="ekr.20080516150804.960"><vh>get_function_and_args_in_header</vh></v>
<v t="ekr.20080516150804.961"><vh>find_function_offset</vh></v>
</v>
<v t="ekr.20080516150804.962"><vh>class _RealFinder</vh>
<v t="ekr.20080516150804.963"><vh>__init__</vh></v>
<v t="ekr.20080516150804.964"><vh>_find_word_start</vh></v>
<v t="ekr.20080516150804.965"><vh>_find_word_end</vh></v>
<v t="ekr.20080516150804.966"><vh>_find_last_non_space_char</vh></v>
<v t="ekr.20080516150804.967"><vh>get_word_at</vh></v>
<v t="ekr.20080516150804.968"><vh>_get_fixed_offset</vh></v>
<v t="ekr.20080516150804.969"><vh>_is_id_char</vh></v>
<v t="ekr.20080516150804.970"><vh>_find_string_start</vh></v>
<v t="ekr.20080516150804.971"><vh>_find_parens_start</vh></v>
<v t="ekr.20080516150804.972"><vh>_find_atom_start</vh></v>
<v t="ekr.20080516150804.973"><vh>_find_primary_without_dot_start</vh></v>
<v t="ekr.20080516150804.974"><vh>_find_primary_start</vh></v>
<v t="ekr.20080516150804.975"><vh>get_primary_at</vh></v>
<v t="ekr.20080516150804.976"><vh>get_splitted_primary_before</vh></v>
<v t="ekr.20080516150804.977"><vh>_get_line_start</vh></v>
<v t="ekr.20080516150804.978"><vh>_get_line_end</vh></v>
<v t="ekr.20080516150804.979"><vh>is_name_assigned_in_class_body</vh></v>
<v t="ekr.20080516150804.980"><vh>is_a_class_or_function_name_in_header</vh></v>
<v t="ekr.20080516150804.981"><vh>_find_first_non_space_char</vh></v>
<v t="ekr.20080516150804.982"><vh>is_a_function_being_called</vh></v>
<v t="ekr.20080516150804.983"><vh>_find_import_end</vh></v>
<v t="ekr.20080516150804.984"><vh>is_import_statement</vh></v>
<v t="ekr.20080516150804.985"><vh>is_from_statement</vh></v>
<v t="ekr.20080516150804.986"><vh>is_from_statement_module</vh></v>
<v t="ekr.20080516150804.987"><vh>is_a_name_after_from_import</vh></v>
<v t="ekr.20080516150804.988"><vh>get_from_module</vh></v>
<v t="ekr.20080516150804.989"><vh>is_from_aliased</vh></v>
<v t="ekr.20080516150804.990"><vh>get_from_aliased</vh></v>
<v t="ekr.20080516150804.991"><vh>is_function_keyword_parameter</vh></v>
<v t="ekr.20080516150804.992"><vh>is_on_function_call_keyword</vh></v>
<v t="ekr.20080516150804.993"><vh>find_parens_start_from_inside</vh></v>
<v t="ekr.20080516150804.994"><vh>is_assigned_here</vh></v>
<v t="ekr.20080516150804.995"><vh>get_assignment_type</vh></v>
<v t="ekr.20080516150804.996"><vh>get_primary_range</vh></v>
<v t="ekr.20080516150804.997"><vh>get_word_range</vh></v>
<v t="ekr.20080516150804.998"><vh>get_word_parens_range</vh></v>
<v t="ekr.20080516150804.999"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1000"><vh>is_assigned_in_a_tuple_assignment</vh></v>
<v t="ekr.20080516150804.1001"><vh>get_function_and_args_in_header</vh></v>
<v t="ekr.20080516150804.1002"><vh>find_function_offset</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1005"><vh>base\oi (**object analysis and inference)</vh>
<v t="ekr.20080516150804.1217"><vh>base\oi\__init__.py</vh>
<v t="ekr.20080516150804.1218"><vh>__init__ declarations (base.oi.ctor)</vh></v>
</v>
<v t="ekr.20080516150804.1006"><vh>base\oi\doa.py</vh>
<v t="ekr.20080516150804.1007"><vh>doa declarations</vh></v>
<v t="ekr.20080516150804.1008"><vh>class PythonFileRunner</vh>
<v t="ekr.20080516150804.1009"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1010"><vh>run</vh></v>
<v t="ekr.20080516150804.1011"><vh>_init_data_receiving</vh></v>
<v t="ekr.20080516150804.1012"><vh>_receive_information</vh></v>
<v t="ekr.20080516150804.1013"><vh>wait_process</vh></v>
<v t="ekr.20080516150804.1014"><vh>kill_process</vh></v>
<v t="ekr.20080516150804.1015"><vh>add_finishing_observer</vh></v>
</v>
<v t="ekr.20080516150804.1016"><vh>class _MessageReceiver</vh>
<v t="ekr.20080516150804.1017"><vh>receive_data</vh></v>
<v t="ekr.20080516150804.1018"><vh>get_send_info</vh></v>
</v>
<v t="ekr.20080516150804.1019"><vh>class _SocketReceiver</vh>
<v t="ekr.20080516150804.1020"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1021"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1022"><vh>receive_data</vh></v>
</v>
<v t="ekr.20080516150804.1023"><vh>class _FIFOReceiver</vh>
<v t="ekr.20080516150804.1024"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1025"><vh>_get_file_name</vh></v>
<v t="ekr.20080516150804.1026"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1027"><vh>receive_data</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1028"><vh>base\oi\memorydb.py</vh>
<v t="ekr.20080516150804.1029"><vh>memorydb declarations</vh></v>
<v t="ekr.20080516150804.1030"><vh>class MemoryDB</vh>
<v t="ekr.20080516150804.1031"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1032"><vh>_load_files</vh></v>
<v t="ekr.20080516150804.1033"><vh>keys</vh></v>
<v t="ekr.20080516150804.1034"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1035"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1036"><vh>create</vh></v>
<v t="ekr.20080516150804.1037"><vh>rename</vh></v>
<v t="ekr.20080516150804.1038"><vh>__delitem__</vh></v>
<v t="ekr.20080516150804.1039"><vh>write</vh></v>
<v t="ekr.20080516150804.1040"><vh>compress</vh></v>
<v t="ekr.20080516150804.1041"><vh>persist</vh></v>
</v>
<v t="ekr.20080516150804.1042"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1043"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1044"><vh>create_scope</vh></v>
<v t="ekr.20080516150804.1045"><vh>keys</vh></v>
<v t="ekr.20080516150804.1046"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1047"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1048"><vh>__delitem__</vh></v>
</v>
<v t="ekr.20080516150804.1049"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1050"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1051"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1052"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1053"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1054"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1055"><vh>add_call</vh></v>
<v t="ekr.20080516150804.1056"><vh>__getstate__</vh></v>
<v t="ekr.20080516150804.1057"><vh>__setstate__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1058"><vh>base\oi\objectdb.py</vh>
<v t="ekr.20080516150804.1059"><vh>objectdb declarations</vh></v>
<v t="ekr.20080516150804.1060"><vh>class ObjectDB</vh>
<v t="ekr.20080516150804.1061"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1062"><vh>validate_files</vh></v>
<v t="ekr.20080516150804.1063"><vh>validate_file</vh></v>
<v t="ekr.20080516150804.1064"><vh>file_moved</vh></v>
<v t="ekr.20080516150804.1065"><vh>get_files</vh></v>
<v t="ekr.20080516150804.1066"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1067"><vh>get_pername</vh></v>
<v t="ekr.20080516150804.1068"><vh>get_callinfos</vh></v>
<v t="ekr.20080516150804.1069"><vh>add_callinfo</vh></v>
<v t="ekr.20080516150804.1070"><vh>add_pername</vh></v>
<v t="ekr.20080516150804.1071"><vh>add_file_list_observer</vh></v>
<v t="ekr.20080516150804.1072"><vh>write</vh></v>
<v t="ekr.20080516150804.1073"><vh>_get_scope_info</vh></v>
<v t="ekr.20080516150804.1074"><vh>_file_removed</vh></v>
<v t="ekr.20080516150804.1075"><vh>_file_added</vh></v>
<v t="ekr.20080516150804.1076"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1077"><vh>class _NullScopeInfo</vh>
<v t="ekr.20080516150804.1078"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1079"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1080"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1081"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1082"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1083"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1084"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1085"><vh>create_scope</vh></v>
</v>
<v t="ekr.20080516150804.1086"><vh>class FileDict</vh>
<v t="ekr.20080516150804.1087"><vh>create</vh></v>
<v t="ekr.20080516150804.1088"><vh>rename</vh></v>
</v>
<v t="ekr.20080516150804.1089"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1090"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1091"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1092"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1093"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1094"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1095"><vh>class CallInfo</vh>
<v t="ekr.20080516150804.1096"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1097"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1098"><vh>get_returned</vh></v>
</v>
<v t="ekr.20080516150804.1099"><vh>class FileListObserver</vh>
<v t="ekr.20080516150804.1100"><vh>added</vh></v>
<v t="ekr.20080516150804.1101"><vh>removed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1102"><vh>base\oi\objectinfo.py</vh>
<v t="ekr.20080516150804.1103"><vh>objectinfo declarations</vh></v>
<v t="ekr.20080516150804.1104"><vh>class ObjectInfoManager</vh>
<v t="ekr.20080516150804.1105"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1106"><vh>_init_objectdb</vh></v>
<v t="ekr.20080516150804.1107"><vh>_init_validation</vh></v>
<v t="ekr.20080516150804.1108"><vh>_resource_changed</vh></v>
<v t="ekr.20080516150804.1109"><vh>_resource_moved</vh></v>
<v t="ekr.20080516150804.1110"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1111"><vh>get_exact_returned</vh></v>
<v t="ekr.20080516150804.1112"><vh>_args_to_textual</vh></v>
<v t="ekr.20080516150804.1113"><vh>get_parameter_objects</vh></v>
<v t="ekr.20080516150804.1114"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1115"><vh>doa_data_received</vh></v>
<v t="ekr.20080516150804.1116"><vh>function_called</vh></v>
<v t="ekr.20080516150804.1117"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1118"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1119"><vh>_save_data</vh></v>
<v t="ekr.20080516150804.1120"><vh>_get_scope</vh></v>
<v t="ekr.20080516150804.1121"><vh>sync</vh></v>
<v t="ekr.20080516150804.1122"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1123"><vh>class TextualValidation</vh>
<v t="ekr.20080516150804.1124"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1125"><vh>is_value_valid</vh></v>
<v t="ekr.20080516150804.1126"><vh>is_more_valid</vh></v>
<v t="ekr.20080516150804.1127"><vh>is_file_valid</vh></v>
<v t="ekr.20080516150804.1128"><vh>is_scope_valid</vh></v>
</v>
<v t="ekr.20080516150804.1129"><vh>class _FileListObserver</vh>
<v t="ekr.20080516150804.1130"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1131"><vh>removed</vh></v>
<v t="ekr.20080516150804.1132"><vh>added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1133"><vh>base\oi\runmod.py</vh>
<v t="ekr.20080516150804.1134"><vh>__rope_start_everything</vh></v>
</v>
<v t="ekr.20080516150804.1135"><vh>base\oi\soa.py</vh>
<v t="ekr.20080516150804.1136"><vh>soa declarations</vh></v>
<v t="ekr.20080516150804.1137" a="E"><vh>analyze_module &amp; helper</vh>
<v t="ekr.20080516150804.1138"><vh>_analyze_node</vh></v>
</v>
<v t="ekr.20080516150804.1139"><vh>class SOIVisitor</vh>
<v t="ekr.20080516150804.1140"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1141"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1142"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.1143"><vh>_Call</vh></v>
<v t="ekr.20080516150804.1144"><vh>_args_with_self</vh></v>
<v t="ekr.20080516150804.1145"><vh>_call</vh></v>
<v t="ekr.20080516150804.1146"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1147"><vh>_Assign</vh></v>
</v>
<v t="ekr.20080516150804.1148"><vh>class _SOIAssignVisitor</vh>
<v t="ekr.20080516150804.1149"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1150"><vh>_added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1151" a="E"><vh>base\oi\soi.py</vh>
<v t="ekr.20080516150804.1152"><vh>soi declarations</vh></v>
<v t="ekr.20080516150804.1153"><vh>infer_returned_object</vh></v>
<v t="ekr.20080516150804.1154"><vh>infer_parameter_objects</vh></v>
<v t="ekr.20080516150804.1155"><vh>_handle_first_parameter</vh></v>
<v t="ekr.20080516150804.1156"><vh>infer_assigned_object</vh></v>
<v t="ekr.20080516150804.1157"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1158"><vh>_infer_returned</vh></v>
<v t="ekr.20080516150804.1159"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1160"><vh>_infer_assignment</vh></v>
<v t="ekr.20080516150804.1161"><vh>_follow_levels</vh></v>
<v t="ekr.20080516150804.1162"><vh>_follow_pyname</vh></v>
<v t="ekr.20080516150804.1163"><vh>_follow_evaluations</vh></v>
<v t="ekr.20080516150804.1164"><vh>_get_lineno_for_node</vh></v>
<v t="ekr.20080516150804.1165"><vh>_get_attribute</vh></v>
</v>
<v t="ekr.20080516150804.1166"><vh>base\oi\transform.py</vh>
<v t="ekr.20080516150804.1167"><vh>transform declarations</vh></v>
<v t="ekr.20080516150804.1168"><vh>class PyObjectToTextual</vh>
<v t="ekr.20080516150804.1169"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1170"><vh>transform</vh></v>
<v t="ekr.20080516150804.1171"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1172"><vh>PyObject_to_textual</vh></v>
<v t="ekr.20080516150804.1173"><vh>PyFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1174"><vh>PyClass_to_textual</vh></v>
<v t="ekr.20080516150804.1175"><vh>_defined_to_textual</vh></v>
<v t="ekr.20080516150804.1176"><vh>PyModule_to_textual</vh></v>
<v t="ekr.20080516150804.1177"><vh>PyPackage_to_textual</vh></v>
<v t="ekr.20080516150804.1178"><vh>List_to_textual</vh></v>
<v t="ekr.20080516150804.1179"><vh>Dict_to_textual</vh></v>
<v t="ekr.20080516150804.1180"><vh>Tuple_to_textual</vh></v>
<v t="ekr.20080516150804.1181"><vh>Set_to_textual</vh></v>
<v t="ekr.20080516150804.1182"><vh>Iterator_to_textual</vh></v>
<v t="ekr.20080516150804.1183"><vh>Generator_to_textual</vh></v>
<v t="ekr.20080516150804.1184"><vh>Str_to_textual</vh></v>
<v t="ekr.20080516150804.1185"><vh>File_to_textual</vh></v>
<v t="ekr.20080516150804.1186"><vh>BuiltinFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1187"><vh>_get_pymodule_path</vh></v>
<v t="ekr.20080516150804.1188"><vh>resource_to_path</vh></v>
</v>
<v t="ekr.20080516150804.1189"><vh>class TextualToPyObject</vh>
<v t="ekr.20080516150804.1190"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1191"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1192"><vh>transform</vh></v>
<v t="ekr.20080516150804.1193"><vh>builtin_to_pyobject</vh></v>
<v t="ekr.20080516150804.1194"><vh>builtin_str_to_pyobject</vh></v>
<v t="ekr.20080516150804.1195"><vh>builtin_list_to_pyobject</vh></v>
<v t="ekr.20080516150804.1196"><vh>builtin_dict_to_pyobject</vh></v>
<v t="ekr.20080516150804.1197"><vh>builtin_tuple_to_pyobject</vh></v>
<v t="ekr.20080516150804.1198"><vh>builtin_set_to_pyobject</vh></v>
<v t="ekr.20080516150804.1199"><vh>builtin_iter_to_pyobject</vh></v>
<v t="ekr.20080516150804.1200"><vh>builtin_generator_to_pyobject</vh></v>
<v t="ekr.20080516150804.1201"><vh>builtin_file_to_pyobject</vh></v>
<v t="ekr.20080516150804.1202"><vh>builtin_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1203"><vh>unknown_to_pyobject</vh></v>
<v t="ekr.20080516150804.1204"><vh>none_to_pyobject</vh></v>
<v t="ekr.20080516150804.1205"><vh>_module_to_pyobject</vh></v>
<v t="ekr.20080516150804.1206"><vh>_hierarchical_defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1207"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1208"><vh>instance_to_pyobject</vh></v>
<v t="ekr.20080516150804.1209"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1210"><vh>path_to_resource</vh></v>
</v>
<v t="ekr.20080516150804.1211"><vh>class DOITextualToPyObject</vh>
<v t="ekr.20080516150804.1212"><vh>_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1213"><vh>_class_to_pyobject</vh></v>
<v t="ekr.20080516150804.1214"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1215"><vh>_find_occurrence</vh></v>
<v t="ekr.20080516150804.1216"><vh>path_to_resource</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20080603141637.1"><vh>Autocompleter stuff</vh>
<v t="ekr.20080516150804.13"><vh>rope-0.8.2\rope\base</vh>
<v t="ekr.20080516150804.1003"><vh>base\__init__.py</vh>
<v t="ekr.20080516150804.1004"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20080516150804.14"><vh>base\arguments.py</vh>
<v t="ekr.20080516150804.15"><vh>arguments declarations</vh></v>
<v t="ekr.20080516150804.16"><vh>class Arguments</vh>
<v t="ekr.20080516150804.17"><vh>__init__</vh></v>
<v t="ekr.20080516150804.18"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.19"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.20"><vh>get_instance_pyname</vh></v>
<v t="ekr.20080516150804.21"><vh>_evaluate</vh></v>
</v>
<v t="ekr.20080516150804.22"><vh>create_arguments</vh></v>
<v t="ekr.20080516150804.23"><vh>class ObjectArguments</vh>
<v t="ekr.20080516150804.24"><vh>__init__</vh></v>
<v t="ekr.20080516150804.25"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.26"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.27"><vh>get_instance_pyname</vh></v>
</v>
<v t="ekr.20080516150804.28"><vh>class MixedArguments</vh>
<v t="ekr.20080516150804.29"><vh>__init__</vh></v>
<v t="ekr.20080516150804.30"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.31"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.32"><vh>get_instance_pyname</vh></v>
</v>
<v t="ekr.20080516150804.33"><vh>_is_method_call</vh></v>
</v>
<v t="ekr.20080516150804.34"><vh>base\ast.py</vh>
<v t="ekr.20080516150804.35"><vh>ast declarations</vh></v>
<v t="ekr.20080516150804.36"><vh>parse</vh></v>
<v t="ekr.20080516150804.37"><vh>walk</vh></v>
<v t="ekr.20080516150804.38"><vh>get_child_nodes</vh></v>
<v t="ekr.20080516150804.39"><vh>call_for_nodes</vh></v>
<v t="ekr.20080516150804.40"><vh>get_children</vh></v>
</v>
<v t="ekr.20080516150804.41"><vh>base\astutils.py</vh>
<v t="ekr.20080516150804.42"><vh>astutils declarations</vh></v>
<v t="ekr.20080516150804.43"><vh>get_name_levels</vh></v>
<v t="ekr.20080516150804.44"><vh>class _NodeNameCollector</vh>
<v t="ekr.20080516150804.45"><vh>__init__</vh></v>
<v t="ekr.20080516150804.46"><vh>_add_node</vh></v>
<v t="ekr.20080516150804.47"><vh>_added</vh></v>
<v t="ekr.20080516150804.48"><vh>_Name</vh></v>
<v t="ekr.20080516150804.49"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.50"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.51"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.52"><vh>_Slice</vh></v>
</v>
</v>
<v t="ekr.20080516150804.53"><vh>base\builtins.py</vh>
<v t="ekr.20080516150804.54"><vh>builtins declarations</vh></v>
<v t="ekr.20080516150804.55"><vh>class BuiltinModule</vh>
<v t="ekr.20080516150804.56"><vh>__init__</vh></v>
<v t="ekr.20080516150804.57"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.58"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.59"><vh>get_name</vh></v>
<v t="ekr.20080516150804.60"><vh>_calculate_attributes</vh></v>
<v t="ekr.20080516150804.61"><vh>module</vh></v>
</v>
<v t="ekr.20080516150804.62"><vh>class _BuiltinElement</vh>
<v t="ekr.20080516150804.63"><vh>__init__</vh></v>
<v t="ekr.20080516150804.64"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.65"><vh>get_name</vh></v>
<v t="ekr.20080516150804.66"><vh>parent</vh></v>
</v>
<v t="ekr.20080516150804.67"><vh>class BuiltinClass</vh>
<v t="ekr.20080516150804.68"><vh>__init__</vh></v>
<v t="ekr.20080516150804.69"><vh>get_attributes</vh></v>
</v>
<v t="ekr.20080516150804.70"><vh>class BuiltinFunction</vh>
<v t="ekr.20080516150804.71"><vh>__init__</vh></v>
<v t="ekr.20080516150804.72"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.73"><vh>get_param_names</vh></v>
</v>
<v t="ekr.20080516150804.74"><vh>_object_attributes</vh></v>
<v t="ekr.20080516150804.75"><vh>_create_builtin_type_getter</vh></v>
<v t="ekr.20080516150804.76"><vh>_create_builtin_getter</vh></v>
<v t="ekr.20080516150804.77"><vh>class _CallContext</vh>
<v t="ekr.20080516150804.78"><vh>__init__</vh></v>
<v t="ekr.20080516150804.79"><vh>_get_scope_and_pyname</vh></v>
<v t="ekr.20080516150804.80"><vh>get_argument</vh></v>
<v t="ekr.20080516150804.81"><vh>get_pyname</vh></v>
<v t="ekr.20080516150804.82"><vh>get_arguments</vh></v>
<v t="ekr.20080516150804.83"><vh>get_pynames</vh></v>
<v t="ekr.20080516150804.84"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.85"><vh>save_per_name</vh></v>
</v>
<v t="ekr.20080516150804.86"><vh>class _AttributeCollector</vh>
<v t="ekr.20080516150804.87"><vh>__init__</vh></v>
<v t="ekr.20080516150804.88"><vh>__call__</vh></v>
<v t="ekr.20080516150804.89"><vh>__setitem__</vh></v>
</v>
<v t="ekr.20080516150804.90"><vh>class List</vh>
<v t="ekr.20080516150804.91"><vh>__init__</vh></v>
<v t="ekr.20080516150804.92"><vh>_new_list</vh></v>
<v t="ekr.20080516150804.93"><vh>_list_add</vh></v>
<v t="ekr.20080516150804.94"><vh>_self_set</vh></v>
<v t="ekr.20080516150804.95"><vh>_list_get</vh></v>
<v t="ekr.20080516150804.96"><vh>_iterator_get</vh></v>
<v t="ekr.20080516150804.97"><vh>_self_get</vh></v>
</v>
<v t="ekr.20080516150804.98"><vh>class Dict</vh>
<v t="ekr.20080516150804.99"><vh>__init__</vh></v>
<v t="ekr.20080516150804.100"><vh>_new_dict</vh></v>
<v t="ekr.20080516150804.101"><vh>_dict_add</vh></v>
<v t="ekr.20080516150804.102"><vh>_item_get</vh></v>
<v t="ekr.20080516150804.103"><vh>_value_get</vh></v>
<v t="ekr.20080516150804.104"><vh>_key_get</vh></v>
<v t="ekr.20080516150804.105"><vh>_value_list</vh></v>
<v t="ekr.20080516150804.106"><vh>_key_list</vh></v>
<v t="ekr.20080516150804.107"><vh>_item_list</vh></v>
<v t="ekr.20080516150804.108"><vh>_value_iter</vh></v>
<v t="ekr.20080516150804.109"><vh>_key_iter</vh></v>
<v t="ekr.20080516150804.110"><vh>_item_iter</vh></v>
<v t="ekr.20080516150804.111"><vh>_self_get</vh></v>
<v t="ekr.20080516150804.112"><vh>_self_set</vh></v>
</v>
<v t="ekr.20080516150804.113"><vh>class Tuple</vh>
<v t="ekr.20080516150804.114"><vh>__init__</vh></v>
<v t="ekr.20080516150804.115"><vh>get_holding_objects</vh></v>
<v t="ekr.20080516150804.116"><vh>_new_tuple</vh></v>
</v>
<v t="ekr.20080516150804.117"><vh>class Set</vh>
<v t="ekr.20080516150804.118"><vh>__init__</vh></v>
<v t="ekr.20080516150804.119"><vh>_new_set</vh></v>
<v t="ekr.20080516150804.120"><vh>_set_add</vh></v>
<v t="ekr.20080516150804.121"><vh>_self_set</vh></v>
<v t="ekr.20080516150804.122"><vh>_set_get</vh></v>
<v t="ekr.20080516150804.123"><vh>_iterator_get</vh></v>
<v t="ekr.20080516150804.124"><vh>_self_get</vh></v>
</v>
<v t="ekr.20080516150804.125"><vh>class Str</vh>
<v t="ekr.20080516150804.126"><vh>__init__</vh></v>
<v t="ekr.20080516150804.127"><vh>get_doc</vh></v>
</v>
<v t="ekr.20080516150804.128"><vh>class BuiltinName</vh>
<v t="ekr.20080516150804.129"><vh>__init__</vh></v>
<v t="ekr.20080516150804.130"><vh>get_object</vh></v>
<v t="ekr.20080516150804.131"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.132"><vh>class Iterator</vh>
<v t="ekr.20080516150804.133"><vh>__init__</vh></v>
<v t="ekr.20080516150804.134"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.135"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.136"><vh>class Generator</vh>
<v t="ekr.20080516150804.137"><vh>__init__</vh></v>
<v t="ekr.20080516150804.138"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.139"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.140"><vh>class File</vh>
<v t="ekr.20080516150804.141"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.142"><vh>class Property</vh>
<v t="ekr.20080516150804.143"><vh>__init__</vh></v>
<v t="ekr.20080516150804.144"><vh>get_property_object</vh></v>
</v>
<v t="ekr.20080516150804.145"><vh>_property_function</vh></v>
<v t="ekr.20080516150804.146"><vh>class Lambda</vh>
<v t="ekr.20080516150804.147"><vh>__init__</vh></v>
<v t="ekr.20080516150804.148"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.149"><vh>get_pattributes</vh></v>
</v>
<v t="ekr.20080516150804.150"><vh>class BuiltinObject</vh>
<v t="ekr.20080516150804.151"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.152"><vh>class BuiltinType</vh>
<v t="ekr.20080516150804.153"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.154"><vh>_infer_sequence_for_pyname</vh></v>
<v t="ekr.20080516150804.155"><vh>_create_builtin</vh></v>
<v t="ekr.20080516150804.156"><vh>_range_function</vh></v>
<v t="ekr.20080516150804.157"><vh>_reversed_function</vh></v>
<v t="ekr.20080516150804.158"><vh>_sorted_function</vh></v>
<v t="ekr.20080516150804.159"><vh>_super_function</vh></v>
<v t="ekr.20080516150804.160"><vh>_zip_function</vh></v>
<v t="ekr.20080516150804.161"><vh>_enumerate_function</vh></v>
<v t="ekr.20080516150804.162"><vh>_iter_function</vh></v>
<v t="ekr.20080516150804.163"><vh>_input_function</vh></v>
</v>
<v t="ekr.20080516150804.164"><vh>base\change.py</vh>
<v t="ekr.20080516150804.165"><vh>change declarations</vh></v>
<v t="ekr.20080516150804.166"><vh>class Change</vh>
<v t="ekr.20080516150804.167"><vh>do</vh></v>
<v t="ekr.20080516150804.168"><vh>undo</vh></v>
<v t="ekr.20080516150804.169"><vh>get_description</vh></v>
<v t="ekr.20080516150804.170"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.171"><vh>class ChangeSet</vh>
<v t="ekr.20080516150804.172"><vh>__init__</vh></v>
<v t="ekr.20080516150804.173"><vh>do</vh></v>
<v t="ekr.20080516150804.174"><vh>undo</vh></v>
<v t="ekr.20080516150804.175"><vh>add_change</vh></v>
<v t="ekr.20080516150804.176"><vh>get_description</vh></v>
<v t="ekr.20080516150804.177"><vh>__str__</vh></v>
<v t="ekr.20080516150804.178"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.179"><vh>_handle_job_set</vh></v>
<v t="ekr.20080516150804.180"><vh>class ChangeContents</vh>
<v t="ekr.20080516150804.181"><vh>__init__</vh></v>
<v t="ekr.20080516150804.182"><vh>do</vh></v>
<v t="ekr.20080516150804.183"><vh>undo</vh></v>
<v t="ekr.20080516150804.184"><vh>__str__</vh></v>
<v t="ekr.20080516150804.185"><vh>get_description</vh></v>
<v t="ekr.20080516150804.186"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.187"><vh>class MoveResource</vh>
<v t="ekr.20080516150804.188"><vh>__init__</vh></v>
<v t="ekr.20080516150804.189"><vh>do</vh></v>
<v t="ekr.20080516150804.190"><vh>undo</vh></v>
<v t="ekr.20080516150804.191"><vh>__str__</vh></v>
<v t="ekr.20080516150804.192"><vh>get_description</vh></v>
<v t="ekr.20080516150804.193"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.194"><vh>class CreateResource</vh>
<v t="ekr.20080516150804.195"><vh>__init__</vh></v>
<v t="ekr.20080516150804.196"><vh>do</vh></v>
<v t="ekr.20080516150804.197"><vh>undo</vh></v>
<v t="ekr.20080516150804.198"><vh>__str__</vh></v>
<v t="ekr.20080516150804.199"><vh>get_description</vh></v>
<v t="ekr.20080516150804.200"><vh>get_changed_resources</vh></v>
<v t="ekr.20080516150804.201"><vh>_get_child_path</vh></v>
</v>
<v t="ekr.20080516150804.202"><vh>class CreateFolder</vh>
<v t="ekr.20080516150804.203"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.204"><vh>class CreateFile</vh>
<v t="ekr.20080516150804.205"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.206"><vh>class RemoveResource</vh>
<v t="ekr.20080516150804.207"><vh>__init__</vh></v>
<v t="ekr.20080516150804.208"><vh>do</vh></v>
<v t="ekr.20080516150804.209"><vh>undo</vh></v>
<v t="ekr.20080516150804.210"><vh>__str__</vh></v>
<v t="ekr.20080516150804.211"><vh>get_changed_resources</vh></v>
</v>
<v t="ekr.20080516150804.212"><vh>count_changes</vh></v>
<v t="ekr.20080516150804.213"><vh>create_job_set</vh></v>
<v t="ekr.20080516150804.214"><vh>class _ResourceOperations</vh>
<v t="ekr.20080516150804.215"><vh>__init__</vh></v>
<v t="ekr.20080516150804.216"><vh>_get_fscommands</vh></v>
<v t="ekr.20080516150804.217"><vh>write_file</vh></v>
<v t="ekr.20080516150804.218"><vh>move</vh></v>
<v t="ekr.20080516150804.219"><vh>create</vh></v>
<v t="ekr.20080516150804.220"><vh>remove</vh></v>
<v t="ekr.20080516150804.221"><vh>_create_resource</vh></v>
</v>
<v t="ekr.20080516150804.222"><vh>_get_destination_for_move</vh></v>
<v t="ekr.20080516150804.223"><vh>class ChangeToData</vh>
<v t="ekr.20080516150804.224"><vh>convertChangeSet</vh></v>
<v t="ekr.20080516150804.225"><vh>convertChangeContents</vh></v>
<v t="ekr.20080516150804.226"><vh>convertMoveResource</vh></v>
<v t="ekr.20080516150804.227"><vh>convertCreateResource</vh></v>
<v t="ekr.20080516150804.228"><vh>convertRemoveResource</vh></v>
<v t="ekr.20080516150804.229"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.230"><vh>class DataToChange</vh>
<v t="ekr.20080516150804.231"><vh>__init__</vh></v>
<v t="ekr.20080516150804.232"><vh>makeChangeSet</vh></v>
<v t="ekr.20080516150804.233"><vh>makeChangeContents</vh></v>
<v t="ekr.20080516150804.234"><vh>makeMoveResource</vh></v>
<v t="ekr.20080516150804.235"><vh>makeCreateResource</vh></v>
<v t="ekr.20080516150804.236"><vh>makeRemoveResource</vh></v>
<v t="ekr.20080516150804.237"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.238"><vh>base\codeanalyze.py</vh>
<v t="ekr.20080516150804.239"><vh>codeanalyze declarations</vh></v>
<v t="ekr.20080516150804.240"><vh>class ChangeCollector</vh>
<v t="ekr.20080516150804.241"><vh>__init__</vh></v>
<v t="ekr.20080516150804.242"><vh>add_change</vh></v>
<v t="ekr.20080516150804.243"><vh>get_changed</vh></v>
</v>
<v t="ekr.20080516150804.244"><vh>class Lines</vh>
<v t="ekr.20080516150804.245"><vh>get_line</vh></v>
<v t="ekr.20080516150804.246"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.247"><vh>class SourceLinesAdapter</vh>
<v t="ekr.20080516150804.248"><vh>__init__</vh></v>
<v t="ekr.20080516150804.249"><vh>_initialize_line_starts</vh></v>
<v t="ekr.20080516150804.250"><vh>get_line</vh></v>
<v t="ekr.20080516150804.251"><vh>length</vh></v>
<v t="ekr.20080516150804.252"><vh>get_line_number</vh></v>
<v t="ekr.20080516150804.253"><vh>get_line_start</vh></v>
<v t="ekr.20080516150804.254"><vh>get_line_end</vh></v>
</v>
<v t="ekr.20080516150804.255"><vh>class ArrayLinesAdapter</vh>
<v t="ekr.20080516150804.256"><vh>__init__</vh></v>
<v t="ekr.20080516150804.257"><vh>get_line</vh></v>
<v t="ekr.20080516150804.258"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.259"><vh>class LinesToReadline</vh>
<v t="ekr.20080516150804.260"><vh>__init__</vh></v>
<v t="ekr.20080516150804.261"><vh>readline</vh></v>
<v t="ekr.20080516150804.262"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.263"><vh>class _CustomGenerator</vh>
<v t="ekr.20080516150804.264"><vh>__init__</vh></v>
<v t="ekr.20080516150804.265"><vh>__call__</vh></v>
<v t="ekr.20080516150804.266"><vh>_analyze_line</vh></v>
</v>
<v t="ekr.20080516150804.267"><vh>custom_generator</vh></v>
<v t="ekr.20080516150804.268"><vh>class LogicalLineFinder</vh>
<v t="ekr.20080516150804.269"><vh>__init__</vh></v>
<v t="ekr.20080516150804.270"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.271"><vh>generate_starts</vh></v>
<v t="ekr.20080516150804.272"><vh>generate_regions</vh></v>
<v t="ekr.20080516150804.273"><vh>_block_logical_line</vh></v>
<v t="ekr.20080516150804.274"><vh>_calculate_logical</vh></v>
<v t="ekr.20080516150804.275"><vh>_logical_lines</vh></v>
<v t="ekr.20080516150804.276"><vh>_first_non_blank</vh></v>
</v>
<v t="ekr.20080516150804.277"><vh>tokenizer_generator</vh></v>
<v t="ekr.20080516150804.278"><vh>class CachingLogicalLineFinder</vh>
<v t="ekr.20080516150804.279"><vh>__init__</vh></v>
<v t="ekr.20080516150804.280"><vh>starts</vh></v>
<v t="ekr.20080516150804.281"><vh>ends</vh></v>
<v t="ekr.20080516150804.282"><vh>_init_logicals</vh></v>
<v t="ekr.20080516150804.283"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.284"><vh>generate_starts</vh></v>
</v>
<v t="ekr.20080516150804.285"><vh>get_block_start</vh></v>
<v t="ekr.20080516150804.286"><vh>get_block_start_patterns</vh></v>
<v t="ekr.20080516150804.287"><vh>count_line_indents</vh></v>
<v t="ekr.20080516150804.288"><vh>get_string_pattern</vh></v>
<v t="ekr.20080516150804.289"><vh>get_comment_pattern</vh></v>
</v>
<v t="ekr.20080516150804.290"><vh>base\default_config.py</vh>
<v t="ekr.20080516150804.291"><vh>set_prefs</vh></v>
<v t="ekr.20080516150804.292"><vh>project_opened</vh></v>
</v>
<v t="ekr.20080516150804.293"><vh>base\evaluate.py</vh>
<v t="ekr.20080516150804.294"><vh>evaluate declarations</vh></v>
<v t="ekr.20080516150804.295"><vh>get_primary_and_pyname_at</vh></v>
<v t="ekr.20080516150804.296"><vh>get_pyname_at</vh></v>
<v t="ekr.20080516150804.297"><vh>get_statement_result</vh></v>
<v t="ekr.20080516150804.298"><vh>get_primary_and_result</vh></v>
<v t="ekr.20080516150804.299"><vh>get_pyname_in_scope</vh></v>
<v t="ekr.20080516150804.300"><vh>get_primary_and_pyname_in_scope</vh></v>
<v t="ekr.20080516150804.301"><vh>get_string_result</vh></v>
<v t="ekr.20080516150804.302"><vh>class ScopeNameFinder</vh>
<v t="ekr.20080516150804.303"><vh>__init__</vh></v>
<v t="ekr.20080516150804.304"><vh>_is_defined_in_class_body</vh></v>
<v t="ekr.20080516150804.305"><vh>_is_function_name_in_function_header</vh></v>
<v t="ekr.20080516150804.306"><vh>get_pyname_at</vh></v>
<v t="ekr.20080516150804.307"><vh>get_primary_and_pyname_at</vh></v>
<v t="ekr.20080516150804.308"><vh>get_enclosing_function</vh></v>
<v t="ekr.20080516150804.309"><vh>_find_module</vh></v>
</v>
<v t="ekr.20080516150804.310"><vh>class StatementEvaluator</vh>
<v t="ekr.20080516150804.311"><vh>__init__</vh></v>
<v t="ekr.20080516150804.312"><vh>_Name</vh></v>
<v t="ekr.20080516150804.313"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.314"><vh>_Call</vh></v>
<v t="ekr.20080516150804.315"><vh>_Str</vh></v>
<v t="ekr.20080516150804.316"><vh>_Num</vh></v>
<v t="ekr.20080516150804.317"><vh>_get_builtin_name</vh></v>
<v t="ekr.20080516150804.318"><vh>_BinOp</vh></v>
<v t="ekr.20080516150804.319"><vh>_BoolOp</vh></v>
<v t="ekr.20080516150804.320"><vh>_Repr</vh></v>
<v t="ekr.20080516150804.321"><vh>_UnaryOp</vh></v>
<v t="ekr.20080516150804.322"><vh>_Compare</vh></v>
<v t="ekr.20080516150804.323"><vh>_Dict</vh></v>
<v t="ekr.20080516150804.324"><vh>_List</vh></v>
<v t="ekr.20080516150804.325"><vh>_ListComp</vh></v>
<v t="ekr.20080516150804.326"><vh>_GeneratorExp</vh></v>
<v t="ekr.20080516150804.327"><vh>_what_does_comprehension_hold</vh></v>
<v t="ekr.20080516150804.328"><vh>_make_comprehension_scope</vh></v>
<v t="ekr.20080516150804.329"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.330"><vh>_get_object_for_node</vh></v>
<v t="ekr.20080516150804.331"><vh>_get_primary_and_object_for_node</vh></v>
<v t="ekr.20080516150804.332"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.333"><vh>_call_function</vh></v>
<v t="ekr.20080516150804.334"><vh>_Lambda</vh></v>
</v>
<v t="ekr.20080516150804.335"><vh>_get_evaluated_names</vh></v>
</v>
<v t="ekr.20080516150804.336"><vh>base\exceptions.py</vh>
<v t="ekr.20080516150804.337"><vh>class RopeError</vh></v>
<v t="ekr.20080516150804.338"><vh>class ResourceNotFoundError</vh></v>
<v t="ekr.20080516150804.339"><vh>class RefactoringError</vh></v>
<v t="ekr.20080516150804.340"><vh>class InterruptedTaskError</vh></v>
<v t="ekr.20080516150804.341"><vh>class HistoryError</vh></v>
<v t="ekr.20080516150804.342"><vh>class ModuleNotFoundError</vh></v>
<v t="ekr.20080516150804.343"><vh>class AttributeNotFoundError</vh></v>
<v t="ekr.20080516150804.344"><vh>class NameNotFoundError</vh></v>
<v t="ekr.20080516150804.345"><vh>class BadIdentifierError</vh></v>
<v t="ekr.20080516150804.346"><vh>class ModuleSyntaxError</vh>
<v t="ekr.20080516150804.347"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.348"><vh>class ModuleDecodeError</vh>
<v t="ekr.20080516150804.349"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.350"><vh>base\fscommands.py</vh>
<v t="ekr.20080516150804.351"><vh>fscommands declarations</vh></v>
<v t="ekr.20080516150804.352"><vh>create_fscommands</vh></v>
<v t="ekr.20080516150804.353"><vh>class FileSystemCommands</vh>
<v t="ekr.20080516150804.354"><vh>create_file</vh></v>
<v t="ekr.20080516150804.355"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.356"><vh>move</vh></v>
<v t="ekr.20080516150804.357"><vh>remove</vh></v>
<v t="ekr.20080516150804.358"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.359"><vh>class SubversionCommands</vh>
<v t="ekr.20080516150804.360"><vh>__init__</vh></v>
<v t="ekr.20080516150804.361"><vh>create_file</vh></v>
<v t="ekr.20080516150804.362"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.363"><vh>move</vh></v>
<v t="ekr.20080516150804.364"><vh>remove</vh></v>
<v t="ekr.20080516150804.365"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.366"><vh>class MercurialCommands</vh>
<v t="ekr.20080516150804.367"><vh>__init__</vh></v>
<v t="ekr.20080516150804.368"><vh>_import_mercurial</vh></v>
<v t="ekr.20080516150804.369"><vh>create_file</vh></v>
<v t="ekr.20080516150804.370"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.371"><vh>move</vh></v>
<v t="ekr.20080516150804.372"><vh>remove</vh></v>
<v t="ekr.20080516150804.373"><vh>write</vh></v>
</v>
<v t="ekr.20080516150804.374"><vh>class GITCommands</vh>
<v t="ekr.20080516150804.375"><vh>__init__</vh></v>
<v t="ekr.20080516150804.376"><vh>create_file</vh></v>
<v t="ekr.20080516150804.377"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.378"><vh>move</vh></v>
<v t="ekr.20080516150804.379"><vh>remove</vh></v>
<v t="ekr.20080516150804.380"><vh>write</vh></v>
<v t="ekr.20080516150804.381"><vh>_do</vh></v>
<v t="ekr.20080516150804.382"><vh>_in_dir</vh></v>
</v>
<v t="ekr.20080516150804.383"><vh>_execute</vh></v>
<v t="ekr.20080516150804.384"><vh>unicode_to_file_data</vh></v>
<v t="ekr.20080516150804.385"><vh>file_data_to_unicode</vh></v>
<v t="ekr.20080516150804.386"><vh>_decode_data</vh></v>
<v t="ekr.20080516150804.387"><vh>read_file_coding</vh></v>
<v t="ekr.20080516150804.388"><vh>read_str_coding</vh></v>
<v t="ekr.20080516150804.389"><vh>_find_coding</vh></v>
</v>
<v t="ekr.20080516150804.390"><vh>base\history.py</vh>
<v t="ekr.20080516150804.391"><vh>history declarations</vh></v>
<v t="ekr.20080516150804.392"><vh>class History</vh>
<v t="ekr.20080516150804.393"><vh>__init__</vh></v>
<v t="ekr.20080516150804.394"><vh>_load_history</vh></v>
<v t="ekr.20080516150804.395"><vh>do</vh></v>
<v t="ekr.20080516150804.396"><vh>_remove_extra_items</vh></v>
<v t="ekr.20080516150804.397"><vh>_is_change_interesting</vh></v>
<v t="ekr.20080516150804.398"><vh>undo</vh></v>
<v t="ekr.20080516150804.399"><vh>redo</vh></v>
<v t="ekr.20080516150804.400"><vh>_move_front</vh></v>
<v t="ekr.20080516150804.401"><vh>_find_dependencies</vh></v>
<v t="ekr.20080516150804.402"><vh>_perform_undos</vh></v>
<v t="ekr.20080516150804.403"><vh>_perform_redos</vh></v>
<v t="ekr.20080516150804.404"><vh>contents_before_current_change</vh></v>
<v t="ekr.20080516150804.405"><vh>_search_for_change_contents</vh></v>
<v t="ekr.20080516150804.406"><vh>write</vh></v>
<v t="ekr.20080516150804.407"><vh>get_file_undo_list</vh></v>
<v t="ekr.20080516150804.408"><vh>__str__</vh></v>
<v t="ekr.20080516150804.409"><vh>tobe_undone</vh></v>
<v t="ekr.20080516150804.410"><vh>tobe_redone</vh></v>
<v t="ekr.20080516150804.411"><vh>max_undos</vh></v>
<v t="ekr.20080516150804.412"><vh>save</vh></v>
<v t="ekr.20080516150804.413"><vh>compress</vh></v>
<v t="ekr.20080516150804.414"><vh>clear</vh></v>
</v>
<v t="ekr.20080516150804.415"><vh>class _FindChangeDependencies</vh>
<v t="ekr.20080516150804.416"><vh>__init__</vh></v>
<v t="ekr.20080516150804.417"><vh>find_dependencies</vh></v>
<v t="ekr.20080516150804.418"><vh>_depends_on</vh></v>
</v>
</v>
<v t="ekr.20080516150804.419"><vh>base\libutils.py</vh>
<v t="ekr.20080516150804.420"><vh>libutils declarations</vh></v>
<v t="ekr.20080516150804.421"><vh>path_to_resource</vh></v>
<v t="ekr.20080516150804.422"><vh>report_change</vh></v>
<v t="ekr.20080516150804.423"><vh>analyze_modules</vh></v>
</v>
<v t="ekr.20080516150804.424"><vh>base\prefs.py</vh>
<v t="ekr.20080516150804.425"><vh>class Prefs</vh>
<v t="ekr.20080516150804.426"><vh>__init__</vh></v>
<v t="ekr.20080516150804.427"><vh>set</vh></v>
<v t="ekr.20080516150804.428"><vh>add</vh></v>
<v t="ekr.20080516150804.429"><vh>get</vh></v>
<v t="ekr.20080516150804.430"><vh>add_callback</vh></v>
<v t="ekr.20080516150804.431"><vh>__setitem__</vh></v>
<v t="ekr.20080516150804.432"><vh>__getitem__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.433"><vh>base\project.py</vh>
<v t="ekr.20080516150804.434"><vh>project declarations</vh></v>
<v t="ekr.20080516150804.435"><vh>class _Project</vh>
<v t="ekr.20080516150804.436"><vh>__init__</vh></v>
<v t="ekr.20080516150804.437"><vh>get_resource</vh></v>
<v t="ekr.20080516150804.438"><vh>validate</vh></v>
<v t="ekr.20080516150804.439"><vh>add_observer</vh></v>
<v t="ekr.20080516150804.440"><vh>remove_observer</vh></v>
<v t="ekr.20080516150804.441"><vh>do</vh></v>
<v t="ekr.20080516150804.442"><vh>get_pycore</vh></v>
<v t="ekr.20080516150804.443"><vh>get_file</vh></v>
<v t="ekr.20080516150804.444"><vh>get_folder</vh></v>
<v t="ekr.20080516150804.445"><vh>is_ignored</vh></v>
<v t="ekr.20080516150804.446"><vh>get_prefs</vh></v>
<v t="ekr.20080516150804.447"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.448"><vh>_get_history</vh></v>
<v t="ekr.20080516150804.449"><vh>close</vh></v>
</v>
<v t="ekr.20080516150804.450"><vh>class Project</vh>
<v t="ekr.20080516150804.451"><vh>__init__</vh></v>
<v t="ekr.20080516150804.452"><vh>get_files</vh></v>
<v t="ekr.20080516150804.453"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.454"><vh>_init_ropefolder</vh></v>
<v t="ekr.20080516150804.455"><vh>_init_prefs</vh></v>
<v t="ekr.20080516150804.456"><vh>_default_config</vh></v>
<v t="ekr.20080516150804.457"><vh>_init_other_parts</vh></v>
<v t="ekr.20080516150804.458"><vh>is_ignored</vh></v>
<v t="ekr.20080516150804.459"><vh>sync</vh></v>
<v t="ekr.20080516150804.460"><vh>close</vh></v>
<v t="ekr.20080516150804.461"><vh>set</vh></v>
<v t="ekr.20080516150804.462"><vh>ropefolder</vh></v>
<v t="ekr.20080516150804.463"><vh>validate</vh></v>
</v>
<v t="ekr.20080516150804.464"><vh>class NoProject</vh>
<v t="ekr.20080516150804.465"><vh>__init__</vh></v>
<v t="ekr.20080516150804.466"><vh>_get_resource_path</vh></v>
<v t="ekr.20080516150804.467"><vh>get_resource</vh></v>
<v t="ekr.20080516150804.468"><vh>get_files</vh></v>
</v>
<v t="ekr.20080516150804.469"><vh>get_no_project</vh></v>
<v t="ekr.20080516150804.470"><vh>class _FileListCacher</vh>
<v t="ekr.20080516150804.471"><vh>__init__</vh></v>
<v t="ekr.20080516150804.472"><vh>get_files</vh></v>
<v t="ekr.20080516150804.473"><vh>observer</vh></v>
<v t="ekr.20080516150804.474"><vh>_updated_resources</vh></v>
<v t="ekr.20080516150804.475"><vh>_update_folder</vh></v>
<v t="ekr.20080516150804.476"><vh>_init_observer</vh></v>
<v t="ekr.20080516150804.477"><vh>_changed</vh></v>
<v t="ekr.20080516150804.478"><vh>_moved</vh></v>
<v t="ekr.20080516150804.479"><vh>_created</vh></v>
<v t="ekr.20080516150804.480"><vh>_removed</vh></v>
<v t="ekr.20080516150804.481"><vh>_validate</vh></v>
</v>
<v t="ekr.20080516150804.482"><vh>class _DataFiles</vh>
<v t="ekr.20080516150804.483"><vh>__init__</vh></v>
<v t="ekr.20080516150804.484"><vh>read_data</vh></v>
<v t="ekr.20080516150804.485"><vh>write_data</vh></v>
<v t="ekr.20080516150804.486"><vh>add_write_hook</vh></v>
<v t="ekr.20080516150804.487"><vh>write</vh></v>
<v t="ekr.20080516150804.488"><vh>_can_compress</vh></v>
<v t="ekr.20080516150804.489"><vh>_import_old_files</vh></v>
<v t="ekr.20080516150804.490"><vh>_get_opener</vh></v>
<v t="ekr.20080516150804.491"><vh>_get_file</vh></v>
</v>
<v t="ekr.20080516150804.492"><vh>_realpath</vh></v>
</v>
<v t="ekr.20080516150804.493"><vh>base\pycore.py</vh>
<v t="ekr.20080516150804.494"><vh>pycore declarations</vh></v>
<v t="ekr.20080516150804.495"><vh>class PyCore</vh>
<v t="ekr.20080516150804.496"><vh>__init__</vh></v>
<v t="ekr.20080516150804.497"><vh>_init_python_files</vh></v>
<v t="ekr.20080516150804.498"><vh>_init_resource_observer</vh></v>
<v t="ekr.20080516150804.499"><vh>_init_source_folders</vh></v>
<v t="ekr.20080516150804.500"><vh>_init_automatic_soa</vh></v>
<v t="ekr.20080516150804.501"><vh>automatic_soa</vh></v>
<v t="ekr.20080516150804.502"><vh>_file_changed_for_soa</vh></v>
<v t="ekr.20080516150804.503"><vh>is_python_file</vh></v>
<v t="ekr.20080516150804.504"><vh>get_module</vh></v>
<v t="ekr.20080516150804.505"><vh>_builtin_module</vh></v>
<v t="ekr.20080516150804.506"><vh>get_relative_module</vh></v>
<v t="ekr.20080516150804.507"><vh>get_string_module</vh></v>
<v t="ekr.20080516150804.508"><vh>get_string_scope</vh></v>
<v t="ekr.20080516150804.509"><vh>_invalidate_resource_cache</vh></v>
<v t="ekr.20080516150804.510"><vh>_find_module_in_source_folder</vh></v>
<v t="ekr.20080516150804.511"><vh>get_python_path_folders</vh></v>
<v t="ekr.20080516150804.512"><vh>find_module</vh></v>
<v t="ekr.20080516150804.513"><vh>find_relative_module</vh></v>
<v t="ekr.20080516150804.514"><vh>_find_module_resource_list</vh></v>
<v t="ekr.20080516150804.515"><vh>get_source_folders</vh></v>
<v t="ekr.20080516150804.516"><vh>resource_to_pyobject</vh></v>
<v t="ekr.20080516150804.517"><vh>get_python_files</vh></v>
<v t="ekr.20080516150804.518"><vh>_is_package</vh></v>
<v t="ekr.20080516150804.519"><vh>_find_source_folders</vh></v>
<v t="ekr.20080516150804.520"><vh>run_module</vh></v>
<v t="ekr.20080516150804.521"><vh>analyze_module (pyCore)</vh></v>
<v t="ekr.20080516150804.522"><vh>get_classes</vh></v>
<v t="ekr.20080516150804.523"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.524"><vh>class _ModuleCache</vh>
<v t="ekr.20080516150804.525"><vh>__init__</vh></v>
<v t="ekr.20080516150804.526"><vh>_invalidate_resource</vh></v>
<v t="ekr.20080516150804.527"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.528"><vh>forget_all_data</vh></v>
<v t="ekr.20080516150804.529"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.530"><vh>class _ExtensionCache</vh>
<v t="ekr.20080516150804.531"><vh>__init__</vh></v>
<v t="ekr.20080516150804.532"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.533"><vh>allowed</vh></v>
</v>
<v t="ekr.20080516150804.534"><vh>perform_soa_on_changed_scopes</vh></v>
<v t="ekr.20080516150804.535"><vh>class _TextChangeDetector</vh>
<v t="ekr.20080516150804.536"><vh>__init__</vh></v>
<v t="ekr.20080516150804.537"><vh>_set_diffs</vh></v>
<v t="ekr.20080516150804.538"><vh>is_changed</vh></v>
<v t="ekr.20080516150804.539"><vh>consume_changes</vh></v>
<v t="ekr.20080516150804.540"><vh>_get_changed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.541"><vh>base\pynames.py</vh>
<v t="ekr.20080516150804.542"><vh>pynames declarations</vh></v>
<v t="ekr.20080516150804.543"><vh>class PyName</vh>
<v t="ekr.20080516150804.544"><vh>get_object</vh></v>
<v t="ekr.20080516150804.545"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.546"><vh>class DefinedName</vh>
<v t="ekr.20080516150804.547"><vh>__init__</vh></v>
<v t="ekr.20080516150804.548"><vh>get_object</vh></v>
<v t="ekr.20080516150804.549"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.550"><vh>class AssignedName</vh></v>
<v t="ekr.20080516150804.551"><vh>class UnboundName</vh>
<v t="ekr.20080516150804.552"><vh>__init__</vh></v>
<v t="ekr.20080516150804.553"><vh>get_object</vh></v>
<v t="ekr.20080516150804.554"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.555"><vh>class AssignmentValue</vh>
<v t="ekr.20080516150804.556"><vh>__init__</vh></v>
<v t="ekr.20080516150804.557"><vh>get_lineno</vh></v>
</v>
<v t="ekr.20080516150804.558"><vh>class EvaluatedName</vh>
<v t="ekr.20080516150804.559"><vh>__init__</vh></v>
<v t="ekr.20080516150804.560"><vh>get_object</vh></v>
<v t="ekr.20080516150804.561"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.562"><vh>invalidate</vh></v>
</v>
<v t="ekr.20080516150804.563"><vh>class ParameterName</vh></v>
<v t="ekr.20080516150804.564"><vh>class ImportedModule</vh>
<v t="ekr.20080516150804.565"><vh>__init__</vh></v>
<v t="ekr.20080516150804.566"><vh>_current_folder</vh></v>
<v t="ekr.20080516150804.567"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.568"><vh>get_object</vh></v>
<v t="ekr.20080516150804.569"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.570"><vh>class ImportedName</vh>
<v t="ekr.20080516150804.571"><vh>__init__</vh></v>
<v t="ekr.20080516150804.572"><vh>_get_imported_pyname</vh></v>
<v t="ekr.20080516150804.573"><vh>get_object</vh></v>
<v t="ekr.20080516150804.574"><vh>get_definition_location</vh></v>
</v>
<v t="ekr.20080516150804.575"><vh>_get_concluded_data</vh></v>
<v t="ekr.20080516150804.576"><vh>_circular_inference</vh></v>
<v t="ekr.20080516150804.577"><vh>class _Inferred</vh>
<v t="ekr.20080516150804.578"><vh>__init__</vh></v>
<v t="ekr.20080516150804.579"><vh>get</vh></v>
<v t="ekr.20080516150804.580"><vh>set</vh></v>
<v t="ekr.20080516150804.581"><vh>_get</vh></v>
</v>
</v>
<v t="ekr.20080516150804.582"><vh>base\pynamesdef.py</vh>
<v t="ekr.20080516150804.583"><vh>pynamesdef declarations</vh></v>
<v t="ekr.20080516150804.584"><vh>class AssignedName</vh>
<v t="ekr.20080516150804.585"><vh>__init__</vh></v>
<v t="ekr.20080516150804.586"><vh>_get_inferred</vh></v>
<v t="ekr.20080516150804.587"><vh>get_object</vh></v>
<v t="ekr.20080516150804.588"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.589"><vh>invalidate</vh></v>
</v>
<v t="ekr.20080516150804.590"><vh>class ParameterName</vh>
<v t="ekr.20080516150804.591"><vh>__init__</vh></v>
<v t="ekr.20080516150804.592"><vh>get_object</vh></v>
<v t="ekr.20080516150804.593"><vh>get_objects</vh></v>
<v t="ekr.20080516150804.594"><vh>get_definition_location</vh></v>
</v>
</v>
<v t="ekr.20080516150804.595"><vh>base\pyobjects.py</vh>
<v t="ekr.20080516150804.596"><vh>pyobjects declarations</vh></v>
<v t="ekr.20080516150804.597"><vh>class PyObject</vh>
<v t="ekr.20080516150804.598"><vh>__init__</vh></v>
<v t="ekr.20080516150804.599"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.600"><vh>get_attribute</vh></v>
<v t="ekr.20080516150804.601"><vh>get_type</vh></v>
<v t="ekr.20080516150804.602"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.603"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.604"><vh>__eq__</vh></v>
<v t="ekr.20080516150804.605"><vh>__hash__</vh></v>
<v t="ekr.20080516150804.606"><vh>__iter__</vh></v>
<v t="ekr.20080516150804.607"><vh>_get_base_type</vh></v>
</v>
<v t="ekr.20080516150804.608"><vh>get_base_type</vh></v>
<v t="ekr.20080516150804.609"><vh>get_unknown</vh></v>
<v t="ekr.20080516150804.610"><vh>class AbstractClass</vh>
<v t="ekr.20080516150804.611"><vh>__init__</vh></v>
<v t="ekr.20080516150804.612"><vh>get_name</vh></v>
<v t="ekr.20080516150804.613"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.614"><vh>get_superclasses</vh></v>
</v>
<v t="ekr.20080516150804.615"><vh>class AbstractFunction</vh>
<v t="ekr.20080516150804.616"><vh>__init__</vh></v>
<v t="ekr.20080516150804.617"><vh>get_name</vh></v>
<v t="ekr.20080516150804.618"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.619"><vh>get_param_names</vh></v>
<v t="ekr.20080516150804.620"><vh>get_returned_object</vh></v>
</v>
<v t="ekr.20080516150804.621"><vh>class AbstractModule</vh>
<v t="ekr.20080516150804.622"><vh>__init__</vh></v>
<v t="ekr.20080516150804.623"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.624"><vh>get_resource</vh></v>
</v>
<v t="ekr.20080516150804.625"><vh>class PyDefinedObject</vh>
<v t="ekr.20080516150804.626"><vh>__init__</vh></v>
<v t="ekr.20080516150804.627"><vh>_get_structural_attributes</vh></v>
<v t="ekr.20080516150804.628"><vh>_get_concluded_attributes</vh></v>
<v t="ekr.20080516150804.629"><vh>get_attributes</vh></v>
<v t="ekr.20080516150804.630"><vh>get_attribute</vh></v>
<v t="ekr.20080516150804.631"><vh>get_scope</vh></v>
<v t="ekr.20080516150804.632"><vh>get_module</vh></v>
<v t="ekr.20080516150804.633"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.634"><vh>_get_defined_objects</vh></v>
<v t="ekr.20080516150804.635"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.636"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.637"><vh>get_ast</vh></v>
<v t="ekr.20080516150804.638"><vh>_create_scope</vh></v>
</v>
<v t="ekr.20080516150804.639"><vh>class PyFunction</vh></v>
<v t="ekr.20080516150804.640"><vh>class PyClass</vh></v>
<v t="ekr.20080516150804.641"><vh>class _ConcludedData</vh>
<v t="ekr.20080516150804.642"><vh>__init__</vh></v>
<v t="ekr.20080516150804.643"><vh>set</vh></v>
<v t="ekr.20080516150804.644"><vh>get</vh></v>
<v t="ekr.20080516150804.645"><vh>_invalidate</vh></v>
<v t="ekr.20080516150804.646"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.647"><vh>class _PyModule</vh>
<v t="ekr.20080516150804.648"><vh>__init__</vh></v>
<v t="ekr.20080516150804.649"><vh>_get_concluded_data</vh></v>
<v t="ekr.20080516150804.650"><vh>_forget_concluded_data</vh></v>
<v t="ekr.20080516150804.651"><vh>get_resource</vh></v>
</v>
<v t="ekr.20080516150804.652"><vh>class PyModule</vh></v>
<v t="ekr.20080516150804.653"><vh>class PyPackage</vh></v>
<v t="ekr.20080516150804.654"><vh>class IsBeingInferredError</vh></v>
</v>
<v t="ekr.20080516150804.655"><vh>base\pyobjectsdef.py</vh>
<v t="ekr.20080516150804.656"><vh>pyobjectsdef declarations</vh></v>
<v t="ekr.20080516150804.657"><vh>class PyFunction</vh>
<v t="ekr.20080516150804.658"><vh>__init__</vh></v>
<v t="ekr.20080516150804.659"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.660"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.661"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.662"><vh>_infer_parameters</vh></v>
<v t="ekr.20080516150804.663"><vh>_infer_returned</vh></v>
<v t="ekr.20080516150804.664"><vh>_handle_special_args</vh></v>
<v t="ekr.20080516150804.665"><vh>_set_parameter_pyobjects</vh></v>
<v t="ekr.20080516150804.666"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.667"><vh>get_parameter</vh></v>
<v t="ekr.20080516150804.668"><vh>get_returned_object</vh></v>
<v t="ekr.20080516150804.669"><vh>get_name</vh></v>
<v t="ekr.20080516150804.670"><vh>get_param_names</vh></v>
<v t="ekr.20080516150804.671"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.672"><vh>decorators</vh></v>
</v>
<v t="ekr.20080516150804.673"><vh>class PyClass</vh>
<v t="ekr.20080516150804.674"><vh>__init__</vh></v>
<v t="ekr.20080516150804.675"><vh>get_superclasses</vh></v>
<v t="ekr.20080516150804.676"><vh>get_name</vh></v>
<v t="ekr.20080516150804.677"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.678"><vh>_get_bases</vh></v>
<v t="ekr.20080516150804.679"><vh>_create_scope</vh></v>
</v>
<v t="ekr.20080516150804.680"><vh>class PyModule</vh>
<v t="ekr.20080516150804.681"><vh>__init__</vh></v>
<v t="ekr.20080516150804.682"><vh>_init_source</vh></v>
<v t="ekr.20080516150804.683"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.684"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.685"><vh>lines</vh></v>
<v t="ekr.20080516150804.686"><vh>logical_lines</vh></v>
</v>
<v t="ekr.20080516150804.687"><vh>class PyPackage</vh>
<v t="ekr.20080516150804.688"><vh>__init__</vh></v>
<v t="ekr.20080516150804.689"><vh>_create_structural_attributes</vh></v>
<v t="ekr.20080516150804.690"><vh>_create_concluded_attributes</vh></v>
<v t="ekr.20080516150804.691"><vh>_get_child_resources</vh></v>
<v t="ekr.20080516150804.692"><vh>_get_init_dot_py</vh></v>
<v t="ekr.20080516150804.693"><vh>_create_scope</vh></v>
<v t="ekr.20080516150804.694"><vh>get_module</vh></v>
</v>
<v t="ekr.20080516150804.695"><vh>class _AssignVisitor</vh>
<v t="ekr.20080516150804.696"><vh>__init__</vh></v>
<v t="ekr.20080516150804.697"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.698"><vh>_assigned</vh></v>
<v t="ekr.20080516150804.699"><vh>_Name</vh></v>
<v t="ekr.20080516150804.700"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.701"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.702"><vh>_Subscript</vh></v>
<v t="ekr.20080516150804.703"><vh>_Slice</vh></v>
</v>
<v t="ekr.20080516150804.704"><vh>class _ScopeVisitor</vh>
<v t="ekr.20080516150804.705"><vh>__init__</vh></v>
<v t="ekr.20080516150804.706"><vh>get_module</vh></v>
<v t="ekr.20080516150804.707"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.708"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.709"><vh>_Assign</vh></v>
<v t="ekr.20080516150804.710"><vh>_AugAssign</vh></v>
<v t="ekr.20080516150804.711"><vh>_For</vh></v>
<v t="ekr.20080516150804.712"><vh>_assigned</vh></v>
<v t="ekr.20080516150804.713"><vh>_update_evaluated</vh></v>
<v t="ekr.20080516150804.714"><vh>_With</vh></v>
<v t="ekr.20080516150804.715"><vh>_excepthandler</vh></v>
<v t="ekr.20080516150804.716"><vh>_ExceptHandler</vh></v>
<v t="ekr.20080516150804.717"><vh>_Import</vh></v>
<v t="ekr.20080516150804.718"><vh>_ImportFrom</vh></v>
<v t="ekr.20080516150804.719"><vh>_is_ignored_import</vh></v>
<v t="ekr.20080516150804.720"><vh>_Global</vh></v>
</v>
<v t="ekr.20080516150804.721"><vh>class _GlobalVisitor</vh>
<v t="ekr.20080516150804.722"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.723"><vh>class _ClassVisitor</vh>
<v t="ekr.20080516150804.724"><vh>__init__</vh></v>
<v t="ekr.20080516150804.725"><vh>_FunctionDef</vh></v>
</v>
<v t="ekr.20080516150804.726"><vh>class _FunctionVisitor</vh>
<v t="ekr.20080516150804.727"><vh>__init__</vh></v>
<v t="ekr.20080516150804.728"><vh>_Return</vh></v>
<v t="ekr.20080516150804.729"><vh>_Yield</vh></v>
</v>
<v t="ekr.20080516150804.730"><vh>class _ClassInitVisitor</vh>
<v t="ekr.20080516150804.731"><vh>__init__</vh></v>
<v t="ekr.20080516150804.732"><vh>_Attribute</vh></v>
<v t="ekr.20080516150804.733"><vh>_Tuple</vh></v>
<v t="ekr.20080516150804.734"><vh>_Name</vh></v>
<v t="ekr.20080516150804.735"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.736"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.737"><vh>_For</vh></v>
<v t="ekr.20080516150804.738"><vh>_With</vh></v>
</v>
<v t="ekr.20080516150804.739"><vh>class StarImport</vh>
<v t="ekr.20080516150804.740"><vh>__init__</vh></v>
<v t="ekr.20080516150804.741"><vh>get_names</vh></v>
</v>
</v>
<v t="ekr.20080516150804.742"><vh>base\pyscopes.py</vh>
<v t="ekr.20080516150804.743"><vh>pyscopes declarations</vh></v>
<v t="ekr.20080516150804.744"><vh>class Scope</vh>
<v t="ekr.20080516150804.745"><vh>__init__</vh></v>
<v t="ekr.20080516150804.746"><vh>get_names</vh></v>
<v t="ekr.20080516150804.747"><vh>get_defined_names</vh></v>
<v t="ekr.20080516150804.748"><vh>get_name</vh></v>
<v t="ekr.20080516150804.749"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.750"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.751"><vh>get_scopes</vh></v>
<v t="ekr.20080516150804.752"><vh>lookup</vh></v>
<v t="ekr.20080516150804.753"><vh>get_propagated_names</vh></v>
<v t="ekr.20080516150804.754"><vh>_propagated_lookup</vh></v>
<v t="ekr.20080516150804.755"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.756"><vh>_get_global_scope</vh></v>
<v t="ekr.20080516150804.757"><vh>get_start</vh></v>
<v t="ekr.20080516150804.758"><vh>get_body_start</vh></v>
<v t="ekr.20080516150804.759"><vh>get_end</vh></v>
<v t="ekr.20080516150804.760"><vh>get_logical_end</vh></v>
<v t="ekr.20080516150804.761"><vh>get_kind</vh></v>
</v>
<v t="ekr.20080516150804.762"><vh>class GlobalScope</vh>
<v t="ekr.20080516150804.763"><vh>__init__</vh></v>
<v t="ekr.20080516150804.764"><vh>get_start</vh></v>
<v t="ekr.20080516150804.765"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.766"><vh>get_name</vh></v>
<v t="ekr.20080516150804.767"><vh>get_names</vh></v>
<v t="ekr.20080516150804.768"><vh>get_inner_scope_for_line</vh></v>
<v t="ekr.20080516150804.769"><vh>get_inner_scope_for_offset</vh></v>
<v t="ekr.20080516150804.770"><vh>_get_scope_finder</vh></v>
<v t="ekr.20080516150804.771"><vh>builtin_names</vh></v>
</v>
<v t="ekr.20080516150804.772"><vh>class FunctionScope</vh>
<v t="ekr.20080516150804.773"><vh>__init__</vh></v>
<v t="ekr.20080516150804.774"><vh>_get_names</vh></v>
<v t="ekr.20080516150804.775"><vh>_visit_function</vh></v>
<v t="ekr.20080516150804.776"><vh>_get_returned_asts</vh></v>
<v t="ekr.20080516150804.777"><vh>_is_generator</vh></v>
<v t="ekr.20080516150804.778"><vh>get_names</vh></v>
<v t="ekr.20080516150804.779"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.780"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.781"><vh>invalidate_data</vh></v>
</v>
<v t="ekr.20080516150804.782"><vh>class ClassScope</vh>
<v t="ekr.20080516150804.783"><vh>__init__</vh></v>
<v t="ekr.20080516150804.784"><vh>get_kind</vh></v>
<v t="ekr.20080516150804.785"><vh>get_propagated_names</vh></v>
</v>
<v t="ekr.20080516150804.786"><vh>class _HoldingScopeFinder</vh>
<v t="ekr.20080516150804.787"><vh>__init__</vh></v>
<v t="ekr.20080516150804.788"><vh>get_indents</vh></v>
<v t="ekr.20080516150804.789"><vh>get_location</vh></v>
<v t="ekr.20080516150804.790"><vh>_get_scope_indents</vh></v>
<v t="ekr.20080516150804.791"><vh>get_holding_scope</vh></v>
<v t="ekr.20080516150804.792"><vh>_is_empty_line</vh></v>
<v t="ekr.20080516150804.793"><vh>_get_body_indents</vh></v>
<v t="ekr.20080516150804.794"><vh>get_holding_scope_for_offset</vh></v>
<v t="ekr.20080516150804.795"><vh>find_scope_end</vh></v>
<v t="ekr.20080516150804.796"><vh>lines</vh></v>
<v t="ekr.20080516150804.797"><vh>code</vh></v>
<v t="ekr.20080516150804.798"><vh>logical_lines</vh></v>
</v>
<v t="ekr.20080516150804.799"><vh>class TemporaryScope</vh>
<v t="ekr.20080516150804.800"><vh>__init__</vh></v>
<v t="ekr.20080516150804.801"><vh>get_names</vh></v>
<v t="ekr.20080516150804.802"><vh>get_defined_names</vh></v>
<v t="ekr.20080516150804.803"><vh>_create_scopes</vh></v>
<v t="ekr.20080516150804.804"><vh>get_kind</vh></v>
</v>
</v>
<v t="ekr.20080516150804.805"><vh>base\resourceobserver.py</vh>
<v t="ekr.20080516150804.806"><vh>resourceobserver declarations</vh></v>
<v t="ekr.20080516150804.807"><vh>class ResourceObserver</vh>
<v t="ekr.20080516150804.808"><vh>__init__</vh></v>
<v t="ekr.20080516150804.809"><vh>resource_changed</vh></v>
<v t="ekr.20080516150804.810"><vh>resource_moved</vh></v>
<v t="ekr.20080516150804.811"><vh>resource_created</vh></v>
<v t="ekr.20080516150804.812"><vh>resource_removed</vh></v>
<v t="ekr.20080516150804.813"><vh>validate</vh></v>
</v>
<v t="ekr.20080516150804.814"><vh>class FilteredResourceObserver</vh>
<v t="ekr.20080516150804.815"><vh>__init__</vh></v>
<v t="ekr.20080516150804.816"><vh>add_resource</vh></v>
<v t="ekr.20080516150804.817"><vh>remove_resource</vh></v>
<v t="ekr.20080516150804.818"><vh>clear_resources</vh></v>
<v t="ekr.20080516150804.819"><vh>resource_changed</vh></v>
<v t="ekr.20080516150804.820"><vh>_update_changes_caused_by_changed</vh></v>
<v t="ekr.20080516150804.821"><vh>_update_changes_caused_by_moved</vh></v>
<v t="ekr.20080516150804.822"><vh>_is_parent_changed</vh></v>
<v t="ekr.20080516150804.823"><vh>resource_moved</vh></v>
<v t="ekr.20080516150804.824"><vh>resource_created</vh></v>
<v t="ekr.20080516150804.825"><vh>_update_changes_caused_by_created</vh></v>
<v t="ekr.20080516150804.826"><vh>resource_removed</vh></v>
<v t="ekr.20080516150804.827"><vh>_perform_changes</vh></v>
<v t="ekr.20080516150804.828"><vh>validate</vh></v>
<v t="ekr.20080516150804.829"><vh>_search_resource_creations</vh></v>
<v t="ekr.20080516150804.830"><vh>_search_resource_moves</vh></v>
<v t="ekr.20080516150804.831"><vh>_search_resource_changes</vh></v>
<v t="ekr.20080516150804.832"><vh>_is_changed</vh></v>
<v t="ekr.20080516150804.833"><vh>_calculate_new_resource</vh></v>
</v>
<v t="ekr.20080516150804.834"><vh>class ChangeIndicator</vh>
<v t="ekr.20080516150804.835"><vh>get_indicator</vh></v>
</v>
<v t="ekr.20080516150804.836"><vh>class _Changes</vh>
<v t="ekr.20080516150804.837"><vh>__init__</vh></v>
<v t="ekr.20080516150804.838"><vh>add_changed</vh></v>
<v t="ekr.20080516150804.839"><vh>add_removed</vh></v>
<v t="ekr.20080516150804.840"><vh>add_created</vh></v>
</v>
</v>
<v t="ekr.20080516150804.841"><vh>base\resources.py</vh>
<v t="ekr.20080516150804.842"><vh>resources declarations</vh></v>
<v t="ekr.20080516150804.843"><vh>class Resource</vh>
<v t="ekr.20080516150804.844"><vh>__init__</vh></v>
<v t="ekr.20080516150804.845"><vh>move</vh></v>
<v t="ekr.20080516150804.846"><vh>remove</vh></v>
<v t="ekr.20080516150804.847"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.848"><vh>create</vh></v>
<v t="ekr.20080516150804.849"><vh>exists</vh></v>
<v t="ekr.20080516150804.850"><vh>parent</vh></v>
<v t="ekr.20080516150804.851"><vh>path</vh></v>
<v t="ekr.20080516150804.852"><vh>name</vh></v>
<v t="ekr.20080516150804.853"><vh>real_path</vh></v>
<v t="ekr.20080516150804.854"><vh>_get_destination_for_move</vh></v>
<v t="ekr.20080516150804.855"><vh>__eq__</vh></v>
<v t="ekr.20080516150804.856"><vh>__hash__</vh></v>
<v t="ekr.20080516150804.857"><vh>_perform_change</vh></v>
</v>
<v t="ekr.20080516150804.858"><vh>class File</vh>
<v t="ekr.20080516150804.859"><vh>__init__</vh></v>
<v t="ekr.20080516150804.860"><vh>read</vh></v>
<v t="ekr.20080516150804.861"><vh>read_bytes</vh></v>
<v t="ekr.20080516150804.862"><vh>write</vh></v>
<v t="ekr.20080516150804.863"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.864"><vh>create</vh></v>
</v>
<v t="ekr.20080516150804.865"><vh>class Folder</vh>
<v t="ekr.20080516150804.866"><vh>__init__</vh></v>
<v t="ekr.20080516150804.867"><vh>is_folder</vh></v>
<v t="ekr.20080516150804.868"><vh>get_children</vh></v>
<v t="ekr.20080516150804.869"><vh>create_file</vh></v>
<v t="ekr.20080516150804.870"><vh>create_folder</vh></v>
<v t="ekr.20080516150804.871"><vh>_get_child_path</vh></v>
<v t="ekr.20080516150804.872"><vh>get_child</vh></v>
<v t="ekr.20080516150804.873"><vh>has_child</vh></v>
<v t="ekr.20080516150804.874"><vh>get_files</vh></v>
<v t="ekr.20080516150804.875"><vh>get_folders</vh></v>
<v t="ekr.20080516150804.876"><vh>contains</vh></v>
<v t="ekr.20080516150804.877"><vh>create</vh></v>
</v>
<v t="ekr.20080516150804.878"><vh>class _ResourceMatcher</vh>
<v t="ekr.20080516150804.879"><vh>__init__</vh></v>
<v t="ekr.20080516150804.880"><vh>set_patterns</vh></v>
<v t="ekr.20080516150804.881"><vh>_add_pattern</vh></v>
<v t="ekr.20080516150804.882"><vh>does_match</vh></v>
<v t="ekr.20080516150804.883"><vh>compiled_patterns</vh></v>
</v>
</v>
<v t="ekr.20080516150804.884"><vh>base\simplify.py</vh>
<v t="ekr.20080516150804.885"><vh>simplify declarations</vh></v>
<v t="ekr.20080516150804.886"><vh>real_code</vh></v>
<v t="ekr.20080516150804.887"><vh>ignored_regions</vh></v>
</v>
<v t="ekr.20080516150804.888"><vh>base\taskhandle.py</vh>
<v t="ekr.20080516150804.889"><vh>taskhandle declarations</vh></v>
<v t="ekr.20080516150804.890"><vh>class TaskHandle</vh>
<v t="ekr.20080516150804.891"><vh>__init__</vh></v>
<v t="ekr.20080516150804.892"><vh>stop</vh></v>
<v t="ekr.20080516150804.893"><vh>current_jobset</vh></v>
<v t="ekr.20080516150804.894"><vh>add_observer</vh></v>
<v t="ekr.20080516150804.895"><vh>is_stopped</vh></v>
<v t="ekr.20080516150804.896"><vh>get_jobsets</vh></v>
<v t="ekr.20080516150804.897"><vh>create_jobset</vh></v>
<v t="ekr.20080516150804.898"><vh>_inform_observers</vh></v>
</v>
<v t="ekr.20080516150804.899"><vh>class JobSet</vh>
<v t="ekr.20080516150804.900"><vh>__init__</vh></v>
<v t="ekr.20080516150804.901"><vh>started_job</vh></v>
<v t="ekr.20080516150804.902"><vh>finished_job</vh></v>
<v t="ekr.20080516150804.903"><vh>check_status</vh></v>
<v t="ekr.20080516150804.904"><vh>get_active_job_name</vh></v>
<v t="ekr.20080516150804.905"><vh>get_percent_done</vh></v>
<v t="ekr.20080516150804.906"><vh>get_name</vh></v>
</v>
<v t="ekr.20080516150804.907"><vh>class NullTaskHandle</vh>
<v t="ekr.20080516150804.908"><vh>__init__</vh></v>
<v t="ekr.20080516150804.909"><vh>is_stopped</vh></v>
<v t="ekr.20080516150804.910"><vh>stop</vh></v>
<v t="ekr.20080516150804.911"><vh>create_jobset</vh></v>
<v t="ekr.20080516150804.912"><vh>get_jobsets</vh></v>
<v t="ekr.20080516150804.913"><vh>add_observer</vh></v>
</v>
<v t="ekr.20080516150804.914"><vh>class NullJobSet</vh>
<v t="ekr.20080516150804.915"><vh>started_job</vh></v>
<v t="ekr.20080516150804.916"><vh>finished_job</vh></v>
<v t="ekr.20080516150804.917"><vh>check_status</vh></v>
<v t="ekr.20080516150804.918"><vh>get_active_job_name</vh></v>
<v t="ekr.20080516150804.919"><vh>get_percent_done</vh></v>
<v t="ekr.20080516150804.920"><vh>get_name</vh></v>
</v>
</v>
<v t="ekr.20080516150804.921"><vh>base\utils.py</vh>
<v t="ekr.20080516150804.922"><vh>cacheit</vh></v>
<v t="ekr.20080516150804.923"><vh>prevent_recursion</vh></v>
<v t="ekr.20080516150804.924"><vh>ignore_exception</vh></v>
<v t="ekr.20080516150804.925"><vh>cached</vh></v>
<v t="ekr.20080516150804.926"><vh>class _Cached</vh>
<v t="ekr.20080516150804.927"><vh>__init__</vh></v>
<v t="ekr.20080516150804.928"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.929"><vh>base\worder.py</vh>
<v t="ekr.20080516150804.930"><vh>worder declarations</vh></v>
<v t="ekr.20080516150804.931"><vh>get_name_at</vh></v>
<v t="ekr.20080516150804.932"><vh>class Worder</vh>
<v t="ekr.20080516150804.933"><vh>__init__</vh></v>
<v t="ekr.20080516150804.934"><vh>_init_ignores</vh></v>
<v t="ekr.20080516150804.935"><vh>_context_call</vh></v>
<v t="ekr.20080516150804.936"><vh>get_primary_at</vh></v>
<v t="ekr.20080516150804.937"><vh>get_word_at</vh></v>
<v t="ekr.20080516150804.938"><vh>get_primary_range</vh></v>
<v t="ekr.20080516150804.939"><vh>get_splitted_primary_before</vh></v>
<v t="ekr.20080516150804.940"><vh>get_word_range</vh></v>
<v t="ekr.20080516150804.941"><vh>is_function_keyword_parameter</vh></v>
<v t="ekr.20080516150804.942"><vh>is_a_class_or_function_name_in_header</vh></v>
<v t="ekr.20080516150804.943"><vh>is_from_statement_module</vh></v>
<v t="ekr.20080516150804.944"><vh>is_from_aliased</vh></v>
<v t="ekr.20080516150804.945"><vh>find_parens_start_from_inside</vh></v>
<v t="ekr.20080516150804.946"><vh>is_a_name_after_from_import</vh></v>
<v t="ekr.20080516150804.947"><vh>is_from_statement</vh></v>
<v t="ekr.20080516150804.948"><vh>get_from_aliased</vh></v>
<v t="ekr.20080516150804.949"><vh>is_import_statement</vh></v>
<v t="ekr.20080516150804.950"><vh>is_assigned_here</vh></v>
<v t="ekr.20080516150804.951"><vh>is_a_function_being_called</vh></v>
<v t="ekr.20080516150804.952"><vh>get_word_parens_range</vh></v>
<v t="ekr.20080516150804.953"><vh>is_name_assigned_in_class_body</vh></v>
<v t="ekr.20080516150804.954"><vh>is_on_function_call_keyword</vh></v>
<v t="ekr.20080516150804.955"><vh>_find_parens_start</vh></v>
<v t="ekr.20080516150804.956"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.957"><vh>get_from_module</vh></v>
<v t="ekr.20080516150804.958"><vh>is_assigned_in_a_tuple_assignment</vh></v>
<v t="ekr.20080516150804.959"><vh>get_assignment_type</vh></v>
<v t="ekr.20080516150804.960"><vh>get_function_and_args_in_header</vh></v>
<v t="ekr.20080516150804.961"><vh>find_function_offset</vh></v>
</v>
<v t="ekr.20080516150804.962"><vh>class _RealFinder</vh>
<v t="ekr.20080516150804.963"><vh>__init__</vh></v>
<v t="ekr.20080516150804.964"><vh>_find_word_start</vh></v>
<v t="ekr.20080516150804.965"><vh>_find_word_end</vh></v>
<v t="ekr.20080516150804.966"><vh>_find_last_non_space_char</vh></v>
<v t="ekr.20080516150804.967"><vh>get_word_at</vh></v>
<v t="ekr.20080516150804.968"><vh>_get_fixed_offset</vh></v>
<v t="ekr.20080516150804.969"><vh>_is_id_char</vh></v>
<v t="ekr.20080516150804.970"><vh>_find_string_start</vh></v>
<v t="ekr.20080516150804.971"><vh>_find_parens_start</vh></v>
<v t="ekr.20080516150804.972"><vh>_find_atom_start</vh></v>
<v t="ekr.20080516150804.973"><vh>_find_primary_without_dot_start</vh></v>
<v t="ekr.20080516150804.974"><vh>_find_primary_start</vh></v>
<v t="ekr.20080516150804.975"><vh>get_primary_at</vh></v>
<v t="ekr.20080516150804.976"><vh>get_splitted_primary_before</vh></v>
<v t="ekr.20080516150804.977"><vh>_get_line_start</vh></v>
<v t="ekr.20080516150804.978"><vh>_get_line_end</vh></v>
<v t="ekr.20080516150804.979"><vh>is_name_assigned_in_class_body</vh></v>
<v t="ekr.20080516150804.980"><vh>is_a_class_or_function_name_in_header</vh></v>
<v t="ekr.20080516150804.981"><vh>_find_first_non_space_char</vh></v>
<v t="ekr.20080516150804.982"><vh>is_a_function_being_called</vh></v>
<v t="ekr.20080516150804.983"><vh>_find_import_end</vh></v>
<v t="ekr.20080516150804.984"><vh>is_import_statement</vh></v>
<v t="ekr.20080516150804.985"><vh>is_from_statement</vh></v>
<v t="ekr.20080516150804.986"><vh>is_from_statement_module</vh></v>
<v t="ekr.20080516150804.987"><vh>is_a_name_after_from_import</vh></v>
<v t="ekr.20080516150804.988"><vh>get_from_module</vh></v>
<v t="ekr.20080516150804.989"><vh>is_from_aliased</vh></v>
<v t="ekr.20080516150804.990"><vh>get_from_aliased</vh></v>
<v t="ekr.20080516150804.991"><vh>is_function_keyword_parameter</vh></v>
<v t="ekr.20080516150804.992"><vh>is_on_function_call_keyword</vh></v>
<v t="ekr.20080516150804.993"><vh>find_parens_start_from_inside</vh></v>
<v t="ekr.20080516150804.994"><vh>is_assigned_here</vh></v>
<v t="ekr.20080516150804.995"><vh>get_assignment_type</vh></v>
<v t="ekr.20080516150804.996"><vh>get_primary_range</vh></v>
<v t="ekr.20080516150804.997"><vh>get_word_range</vh></v>
<v t="ekr.20080516150804.998"><vh>get_word_parens_range</vh></v>
<v t="ekr.20080516150804.999"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1000"><vh>is_assigned_in_a_tuple_assignment</vh></v>
<v t="ekr.20080516150804.1001"><vh>get_function_and_args_in_header</vh></v>
<v t="ekr.20080516150804.1002"><vh>find_function_offset</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1005"><vh>base\oi (**object analysis and inference)</vh>
<v t="ekr.20080516150804.1217"><vh>base\oi\__init__.py</vh>
<v t="ekr.20080516150804.1218"><vh>__init__ declarations (base.oi.ctor)</vh></v>
</v>
<v t="ekr.20080516150804.1006"><vh>base\oi\doa.py</vh>
<v t="ekr.20080516150804.1007"><vh>doa declarations</vh></v>
<v t="ekr.20080516150804.1008"><vh>class PythonFileRunner</vh>
<v t="ekr.20080516150804.1009"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1010"><vh>run</vh></v>
<v t="ekr.20080516150804.1011"><vh>_init_data_receiving</vh></v>
<v t="ekr.20080516150804.1012"><vh>_receive_information</vh></v>
<v t="ekr.20080516150804.1013"><vh>wait_process</vh></v>
<v t="ekr.20080516150804.1014"><vh>kill_process</vh></v>
<v t="ekr.20080516150804.1015"><vh>add_finishing_observer</vh></v>
</v>
<v t="ekr.20080516150804.1016"><vh>class _MessageReceiver</vh>
<v t="ekr.20080516150804.1017"><vh>receive_data</vh></v>
<v t="ekr.20080516150804.1018"><vh>get_send_info</vh></v>
</v>
<v t="ekr.20080516150804.1019"><vh>class _SocketReceiver</vh>
<v t="ekr.20080516150804.1020"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1021"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1022"><vh>receive_data</vh></v>
</v>
<v t="ekr.20080516150804.1023"><vh>class _FIFOReceiver</vh>
<v t="ekr.20080516150804.1024"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1025"><vh>_get_file_name</vh></v>
<v t="ekr.20080516150804.1026"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1027"><vh>receive_data</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1028"><vh>base\oi\memorydb.py</vh>
<v t="ekr.20080516150804.1029"><vh>memorydb declarations</vh></v>
<v t="ekr.20080516150804.1030"><vh>class MemoryDB</vh>
<v t="ekr.20080516150804.1031"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1032"><vh>_load_files</vh></v>
<v t="ekr.20080516150804.1033"><vh>keys</vh></v>
<v t="ekr.20080516150804.1034"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1035"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1036"><vh>create</vh></v>
<v t="ekr.20080516150804.1037"><vh>rename</vh></v>
<v t="ekr.20080516150804.1038"><vh>__delitem__</vh></v>
<v t="ekr.20080516150804.1039"><vh>write</vh></v>
<v t="ekr.20080516150804.1040"><vh>compress</vh></v>
<v t="ekr.20080516150804.1041"><vh>persist</vh></v>
</v>
<v t="ekr.20080516150804.1042"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1043"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1044"><vh>create_scope</vh></v>
<v t="ekr.20080516150804.1045"><vh>keys</vh></v>
<v t="ekr.20080516150804.1046"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1047"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1048"><vh>__delitem__</vh></v>
</v>
<v t="ekr.20080516150804.1049"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1050"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1051"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1052"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1053"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1054"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1055"><vh>add_call</vh></v>
<v t="ekr.20080516150804.1056"><vh>__getstate__</vh></v>
<v t="ekr.20080516150804.1057"><vh>__setstate__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1058"><vh>base\oi\objectdb.py</vh>
<v t="ekr.20080516150804.1059"><vh>objectdb declarations</vh></v>
<v t="ekr.20080516150804.1060"><vh>class ObjectDB</vh>
<v t="ekr.20080516150804.1061"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1062"><vh>validate_files</vh></v>
<v t="ekr.20080516150804.1063"><vh>validate_file</vh></v>
<v t="ekr.20080516150804.1064"><vh>file_moved</vh></v>
<v t="ekr.20080516150804.1065"><vh>get_files</vh></v>
<v t="ekr.20080516150804.1066"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1067"><vh>get_pername</vh></v>
<v t="ekr.20080516150804.1068"><vh>get_callinfos</vh></v>
<v t="ekr.20080516150804.1069"><vh>add_callinfo</vh></v>
<v t="ekr.20080516150804.1070"><vh>add_pername</vh></v>
<v t="ekr.20080516150804.1071"><vh>add_file_list_observer</vh></v>
<v t="ekr.20080516150804.1072"><vh>write</vh></v>
<v t="ekr.20080516150804.1073"><vh>_get_scope_info</vh></v>
<v t="ekr.20080516150804.1074"><vh>_file_removed</vh></v>
<v t="ekr.20080516150804.1075"><vh>_file_added</vh></v>
<v t="ekr.20080516150804.1076"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1077"><vh>class _NullScopeInfo</vh>
<v t="ekr.20080516150804.1078"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1079"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1080"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1081"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1082"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1083"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1084"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1085"><vh>create_scope</vh></v>
</v>
<v t="ekr.20080516150804.1086"><vh>class FileDict</vh>
<v t="ekr.20080516150804.1087"><vh>create</vh></v>
<v t="ekr.20080516150804.1088"><vh>rename</vh></v>
</v>
<v t="ekr.20080516150804.1089"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1090"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1091"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1092"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1093"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1094"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1095"><vh>class CallInfo</vh>
<v t="ekr.20080516150804.1096"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1097"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1098"><vh>get_returned</vh></v>
</v>
<v t="ekr.20080516150804.1099"><vh>class FileListObserver</vh>
<v t="ekr.20080516150804.1100"><vh>added</vh></v>
<v t="ekr.20080516150804.1101"><vh>removed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1102"><vh>base\oi\objectinfo.py</vh>
<v t="ekr.20080516150804.1103"><vh>objectinfo declarations</vh></v>
<v t="ekr.20080516150804.1104"><vh>class ObjectInfoManager</vh>
<v t="ekr.20080516150804.1105"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1106"><vh>_init_objectdb</vh></v>
<v t="ekr.20080516150804.1107"><vh>_init_validation</vh></v>
<v t="ekr.20080516150804.1108"><vh>_resource_changed</vh></v>
<v t="ekr.20080516150804.1109"><vh>_resource_moved</vh></v>
<v t="ekr.20080516150804.1110"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1111"><vh>get_exact_returned</vh></v>
<v t="ekr.20080516150804.1112"><vh>_args_to_textual</vh></v>
<v t="ekr.20080516150804.1113"><vh>get_parameter_objects</vh></v>
<v t="ekr.20080516150804.1114"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1115"><vh>doa_data_received</vh></v>
<v t="ekr.20080516150804.1116"><vh>function_called</vh></v>
<v t="ekr.20080516150804.1117"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1118"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1119"><vh>_save_data</vh></v>
<v t="ekr.20080516150804.1120"><vh>_get_scope</vh></v>
<v t="ekr.20080516150804.1121"><vh>sync</vh></v>
<v t="ekr.20080516150804.1122"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1123"><vh>class TextualValidation</vh>
<v t="ekr.20080516150804.1124"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1125"><vh>is_value_valid</vh></v>
<v t="ekr.20080516150804.1126"><vh>is_more_valid</vh></v>
<v t="ekr.20080516150804.1127"><vh>is_file_valid</vh></v>
<v t="ekr.20080516150804.1128"><vh>is_scope_valid</vh></v>
</v>
<v t="ekr.20080516150804.1129"><vh>class _FileListObserver</vh>
<v t="ekr.20080516150804.1130"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1131"><vh>removed</vh></v>
<v t="ekr.20080516150804.1132"><vh>added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1133"><vh>base\oi\runmod.py</vh>
<v t="ekr.20080516150804.1134"><vh>__rope_start_everything</vh></v>
</v>
<v t="ekr.20080516150804.1135"><vh>base\oi\soa.py</vh>
<v t="ekr.20080516150804.1136"><vh>soa declarations</vh></v>
<v t="ekr.20080516150804.1137" a="E"><vh>analyze_module &amp; helper</vh>
<v t="ekr.20080516150804.1138"><vh>_analyze_node</vh></v>
</v>
<v t="ekr.20080516150804.1139"><vh>class SOIVisitor</vh>
<v t="ekr.20080516150804.1140"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1141"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1142"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.1143"><vh>_Call</vh></v>
<v t="ekr.20080516150804.1144"><vh>_args_with_self</vh></v>
<v t="ekr.20080516150804.1145"><vh>_call</vh></v>
<v t="ekr.20080516150804.1146"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1147"><vh>_Assign</vh></v>
</v>
<v t="ekr.20080516150804.1148"><vh>class _SOIAssignVisitor</vh>
<v t="ekr.20080516150804.1149"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1150"><vh>_added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1151" a="E"><vh>base\oi\soi.py</vh>
<v t="ekr.20080516150804.1152"><vh>soi declarations</vh></v>
<v t="ekr.20080516150804.1153"><vh>infer_returned_object</vh></v>
<v t="ekr.20080516150804.1154"><vh>infer_parameter_objects</vh></v>
<v t="ekr.20080516150804.1155"><vh>_handle_first_parameter</vh></v>
<v t="ekr.20080516150804.1156"><vh>infer_assigned_object</vh></v>
<v t="ekr.20080516150804.1157"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1158"><vh>_infer_returned</vh></v>
<v t="ekr.20080516150804.1159"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1160"><vh>_infer_assignment</vh></v>
<v t="ekr.20080516150804.1161"><vh>_follow_levels</vh></v>
<v t="ekr.20080516150804.1162"><vh>_follow_pyname</vh></v>
<v t="ekr.20080516150804.1163"><vh>_follow_evaluations</vh></v>
<v t="ekr.20080516150804.1164"><vh>_get_lineno_for_node</vh></v>
<v t="ekr.20080516150804.1165"><vh>_get_attribute</vh></v>
</v>
<v t="ekr.20080516150804.1166"><vh>base\oi\transform.py</vh>
<v t="ekr.20080516150804.1167"><vh>transform declarations</vh></v>
<v t="ekr.20080516150804.1168"><vh>class PyObjectToTextual</vh>
<v t="ekr.20080516150804.1169"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1170"><vh>transform</vh></v>
<v t="ekr.20080516150804.1171"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1172"><vh>PyObject_to_textual</vh></v>
<v t="ekr.20080516150804.1173"><vh>PyFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1174"><vh>PyClass_to_textual</vh></v>
<v t="ekr.20080516150804.1175"><vh>_defined_to_textual</vh></v>
<v t="ekr.20080516150804.1176"><vh>PyModule_to_textual</vh></v>
<v t="ekr.20080516150804.1177"><vh>PyPackage_to_textual</vh></v>
<v t="ekr.20080516150804.1178"><vh>List_to_textual</vh></v>
<v t="ekr.20080516150804.1179"><vh>Dict_to_textual</vh></v>
<v t="ekr.20080516150804.1180"><vh>Tuple_to_textual</vh></v>
<v t="ekr.20080516150804.1181"><vh>Set_to_textual</vh></v>
<v t="ekr.20080516150804.1182"><vh>Iterator_to_textual</vh></v>
<v t="ekr.20080516150804.1183"><vh>Generator_to_textual</vh></v>
<v t="ekr.20080516150804.1184"><vh>Str_to_textual</vh></v>
<v t="ekr.20080516150804.1185"><vh>File_to_textual</vh></v>
<v t="ekr.20080516150804.1186"><vh>BuiltinFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1187"><vh>_get_pymodule_path</vh></v>
<v t="ekr.20080516150804.1188"><vh>resource_to_path</vh></v>
</v>
<v t="ekr.20080516150804.1189"><vh>class TextualToPyObject</vh>
<v t="ekr.20080516150804.1190"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1191"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1192"><vh>transform</vh></v>
<v t="ekr.20080516150804.1193"><vh>builtin_to_pyobject</vh></v>
<v t="ekr.20080516150804.1194"><vh>builtin_str_to_pyobject</vh></v>
<v t="ekr.20080516150804.1195"><vh>builtin_list_to_pyobject</vh></v>
<v t="ekr.20080516150804.1196"><vh>builtin_dict_to_pyobject</vh></v>
<v t="ekr.20080516150804.1197"><vh>builtin_tuple_to_pyobject</vh></v>
<v t="ekr.20080516150804.1198"><vh>builtin_set_to_pyobject</vh></v>
<v t="ekr.20080516150804.1199"><vh>builtin_iter_to_pyobject</vh></v>
<v t="ekr.20080516150804.1200"><vh>builtin_generator_to_pyobject</vh></v>
<v t="ekr.20080516150804.1201"><vh>builtin_file_to_pyobject</vh></v>
<v t="ekr.20080516150804.1202"><vh>builtin_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1203"><vh>unknown_to_pyobject</vh></v>
<v t="ekr.20080516150804.1204"><vh>none_to_pyobject</vh></v>
<v t="ekr.20080516150804.1205"><vh>_module_to_pyobject</vh></v>
<v t="ekr.20080516150804.1206"><vh>_hierarchical_defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1207"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1208"><vh>instance_to_pyobject</vh></v>
<v t="ekr.20080516150804.1209"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1210"><vh>path_to_resource</vh></v>
</v>
<v t="ekr.20080516150804.1211"><vh>class DOITextualToPyObject</vh>
<v t="ekr.20080516150804.1212"><vh>_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1213"><vh>_class_to_pyobject</vh></v>
<v t="ekr.20080516150804.1214"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1215"><vh>_find_occurrence</vh></v>
<v t="ekr.20080516150804.1216"><vh>path_to_resource</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080603141637.2"><vh>Classes</vh>
<v t="ekr.20080516150804.34"><vh>base\ast.py</vh>
<v t="ekr.20080516150804.35"><vh>ast declarations</vh></v>
<v t="ekr.20080516150804.36"><vh>parse</vh></v>
<v t="ekr.20080516150804.37"><vh>walk</vh></v>
<v t="ekr.20080516150804.38"><vh>get_child_nodes</vh></v>
<v t="ekr.20080516150804.39"><vh>call_for_nodes</vh></v>
<v t="ekr.20080516150804.40"><vh>get_children</vh></v>
</v>
<v t="ekr.20080516150804.493"><vh>base\pycore.py</vh>
<v t="ekr.20080516150804.494"><vh>pycore declarations</vh></v>
<v t="ekr.20080516150804.495"><vh>class PyCore</vh>
<v t="ekr.20080516150804.496"><vh>__init__</vh></v>
<v t="ekr.20080516150804.497"><vh>_init_python_files</vh></v>
<v t="ekr.20080516150804.498"><vh>_init_resource_observer</vh></v>
<v t="ekr.20080516150804.499"><vh>_init_source_folders</vh></v>
<v t="ekr.20080516150804.500"><vh>_init_automatic_soa</vh></v>
<v t="ekr.20080516150804.501"><vh>automatic_soa</vh></v>
<v t="ekr.20080516150804.502"><vh>_file_changed_for_soa</vh></v>
<v t="ekr.20080516150804.503"><vh>is_python_file</vh></v>
<v t="ekr.20080516150804.504"><vh>get_module</vh></v>
<v t="ekr.20080516150804.505"><vh>_builtin_module</vh></v>
<v t="ekr.20080516150804.506"><vh>get_relative_module</vh></v>
<v t="ekr.20080516150804.507"><vh>get_string_module</vh></v>
<v t="ekr.20080516150804.508"><vh>get_string_scope</vh></v>
<v t="ekr.20080516150804.509"><vh>_invalidate_resource_cache</vh></v>
<v t="ekr.20080516150804.510"><vh>_find_module_in_source_folder</vh></v>
<v t="ekr.20080516150804.511"><vh>get_python_path_folders</vh></v>
<v t="ekr.20080516150804.512"><vh>find_module</vh></v>
<v t="ekr.20080516150804.513"><vh>find_relative_module</vh></v>
<v t="ekr.20080516150804.514"><vh>_find_module_resource_list</vh></v>
<v t="ekr.20080516150804.515"><vh>get_source_folders</vh></v>
<v t="ekr.20080516150804.516"><vh>resource_to_pyobject</vh></v>
<v t="ekr.20080516150804.517"><vh>get_python_files</vh></v>
<v t="ekr.20080516150804.518"><vh>_is_package</vh></v>
<v t="ekr.20080516150804.519"><vh>_find_source_folders</vh></v>
<v t="ekr.20080516150804.520"><vh>run_module</vh></v>
<v t="ekr.20080516150804.521"><vh>analyze_module (pyCore)</vh></v>
<v t="ekr.20080516150804.522"><vh>get_classes</vh></v>
<v t="ekr.20080516150804.523"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.524"><vh>class _ModuleCache</vh>
<v t="ekr.20080516150804.525"><vh>__init__</vh></v>
<v t="ekr.20080516150804.526"><vh>_invalidate_resource</vh></v>
<v t="ekr.20080516150804.527"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.528"><vh>forget_all_data</vh></v>
<v t="ekr.20080516150804.529"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.530"><vh>class _ExtensionCache</vh>
<v t="ekr.20080516150804.531"><vh>__init__</vh></v>
<v t="ekr.20080516150804.532"><vh>get_pymodule</vh></v>
<v t="ekr.20080516150804.533"><vh>allowed</vh></v>
</v>
<v t="ekr.20080516150804.534"><vh>perform_soa_on_changed_scopes</vh></v>
<v t="ekr.20080516150804.535"><vh>class _TextChangeDetector</vh>
<v t="ekr.20080516150804.536"><vh>__init__</vh></v>
<v t="ekr.20080516150804.537"><vh>_set_diffs</vh></v>
<v t="ekr.20080516150804.538"><vh>is_changed</vh></v>
<v t="ekr.20080516150804.539"><vh>consume_changes</vh></v>
<v t="ekr.20080516150804.540"><vh>_get_changed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.238"><vh>base\codeanalyze.py</vh>
<v t="ekr.20080516150804.239"><vh>codeanalyze declarations</vh></v>
<v t="ekr.20080516150804.240"><vh>class ChangeCollector</vh>
<v t="ekr.20080516150804.241"><vh>__init__</vh></v>
<v t="ekr.20080516150804.242"><vh>add_change</vh></v>
<v t="ekr.20080516150804.243"><vh>get_changed</vh></v>
</v>
<v t="ekr.20080516150804.244"><vh>class Lines</vh>
<v t="ekr.20080516150804.245"><vh>get_line</vh></v>
<v t="ekr.20080516150804.246"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.247"><vh>class SourceLinesAdapter</vh>
<v t="ekr.20080516150804.248"><vh>__init__</vh></v>
<v t="ekr.20080516150804.249"><vh>_initialize_line_starts</vh></v>
<v t="ekr.20080516150804.250"><vh>get_line</vh></v>
<v t="ekr.20080516150804.251"><vh>length</vh></v>
<v t="ekr.20080516150804.252"><vh>get_line_number</vh></v>
<v t="ekr.20080516150804.253"><vh>get_line_start</vh></v>
<v t="ekr.20080516150804.254"><vh>get_line_end</vh></v>
</v>
<v t="ekr.20080516150804.255"><vh>class ArrayLinesAdapter</vh>
<v t="ekr.20080516150804.256"><vh>__init__</vh></v>
<v t="ekr.20080516150804.257"><vh>get_line</vh></v>
<v t="ekr.20080516150804.258"><vh>length</vh></v>
</v>
<v t="ekr.20080516150804.259"><vh>class LinesToReadline</vh>
<v t="ekr.20080516150804.260"><vh>__init__</vh></v>
<v t="ekr.20080516150804.261"><vh>readline</vh></v>
<v t="ekr.20080516150804.262"><vh>__call__</vh></v>
</v>
<v t="ekr.20080516150804.263"><vh>class _CustomGenerator</vh>
<v t="ekr.20080516150804.264"><vh>__init__</vh></v>
<v t="ekr.20080516150804.265"><vh>__call__</vh></v>
<v t="ekr.20080516150804.266"><vh>_analyze_line</vh></v>
</v>
<v t="ekr.20080516150804.267"><vh>custom_generator</vh></v>
<v t="ekr.20080516150804.268"><vh>class LogicalLineFinder</vh>
<v t="ekr.20080516150804.269"><vh>__init__</vh></v>
<v t="ekr.20080516150804.270"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.271"><vh>generate_starts</vh></v>
<v t="ekr.20080516150804.272"><vh>generate_regions</vh></v>
<v t="ekr.20080516150804.273"><vh>_block_logical_line</vh></v>
<v t="ekr.20080516150804.274"><vh>_calculate_logical</vh></v>
<v t="ekr.20080516150804.275"><vh>_logical_lines</vh></v>
<v t="ekr.20080516150804.276"><vh>_first_non_blank</vh></v>
</v>
<v t="ekr.20080516150804.277"><vh>tokenizer_generator</vh></v>
<v t="ekr.20080516150804.278"><vh>class CachingLogicalLineFinder</vh>
<v t="ekr.20080516150804.279"><vh>__init__</vh></v>
<v t="ekr.20080516150804.280"><vh>starts</vh></v>
<v t="ekr.20080516150804.281"><vh>ends</vh></v>
<v t="ekr.20080516150804.282"><vh>_init_logicals</vh></v>
<v t="ekr.20080516150804.283"><vh>logical_line_in</vh></v>
<v t="ekr.20080516150804.284"><vh>generate_starts</vh></v>
</v>
<v t="ekr.20080516150804.285"><vh>get_block_start</vh></v>
<v t="ekr.20080516150804.286"><vh>get_block_start_patterns</vh></v>
<v t="ekr.20080516150804.287"><vh>count_line_indents</vh></v>
<v t="ekr.20080516150804.288"><vh>get_string_pattern</vh></v>
<v t="ekr.20080516150804.289"><vh>get_comment_pattern</vh></v>
</v>
<v t="ekr.20080516150804.1240"><vh>contrib\codeassist.py</vh>
<v t="ekr.20080516150804.1241"><vh>codeassist declarations</vh></v>
<v t="ekr.20080516150804.1242"><vh>code_assist</vh></v>
<v t="ekr.20080516150804.1243"><vh>starting_offset</vh></v>
<v t="ekr.20080516150804.1244"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.1245"><vh>get_calltip</vh></v>
<v t="ekr.20080516150804.1246"><vh>get_definition_location</vh></v>
<v t="ekr.20080516150804.1247"><vh>find_occurrences</vh></v>
<v t="ekr.20080516150804.1248"><vh>class CodeAssistProposal</vh>
<v t="ekr.20080516150804.1249"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1250"><vh>class CompletionProposal</vh>
<v t="ekr.20080516150804.1251"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1252"><vh>__str__</vh></v>
<v t="ekr.20080516150804.1253"><vh>__repr__</vh></v>
</v>
<v t="ekr.20080516150804.1254"><vh>sorted_proposals</vh></v>
<v t="ekr.20080516150804.1255"><vh>starting_expression</vh></v>
<v t="ekr.20080516150804.1256"><vh>default_templates</vh></v>
<v t="ekr.20080516150804.1257"><vh>class _PythonCodeAssist</vh>
<v t="ekr.20080516150804.1258"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1259"><vh>_find_starting_offset</vh></v>
<v t="ekr.20080516150804.1260"><vh>_matching_keywords</vh></v>
<v t="ekr.20080516150804.1261"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1262"><vh>_dotted_completions</vh></v>
<v t="ekr.20080516150804.1263"><vh>_undotted_completions</vh></v>
<v t="ekr.20080516150804.1264"><vh>_from_import_completions</vh></v>
<v t="ekr.20080516150804.1265"><vh>_find_module</vh></v>
<v t="ekr.20080516150804.1266"><vh>_is_defined_after</vh></v>
<v t="ekr.20080516150804.1267"><vh>_get_pyname_type</vh></v>
<v t="ekr.20080516150804.1268"><vh>_code_completions</vh></v>
<v t="ekr.20080516150804.1269"><vh>_keyword_parameters</vh></v>
</v>
<v t="ekr.20080516150804.1270"><vh>class _ProposalSorter</vh>
<v t="ekr.20080516150804.1271"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1272"><vh>get_sorted_proposal_list</vh></v>
<v t="ekr.20080516150804.1273"><vh>_proposal_cmp</vh></v>
<v t="ekr.20080516150804.1274"><vh>_compare_underlined_names</vh></v>
</v>
<v t="ekr.20080516150804.1275"><vh>class _Commenter</vh>
<v t="ekr.20080516150804.1276"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1277"><vh>comment</vh></v>
<v t="ekr.20080516150804.1278"><vh>_last_non_blank</vh></v>
<v t="ekr.20080516150804.1279"><vh>_get_block_end</vh></v>
<v t="ekr.20080516150804.1280"><vh>_fix_incomplete_try_blocks</vh></v>
<v t="ekr.20080516150804.1281"><vh>_find_matching_deindent</vh></v>
</v>
<v t="ekr.20080516150804.1282"><vh>_find_pyname_at</vh></v>
<v t="ekr.20080516150804.1283"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1284"><vh>_get_line_indents</vh></v>
<v t="ekr.20080516150804.1285"><vh>_logical_start</vh></v>
<v t="ekr.20080516150804.1286"><vh>class PyDocExtractor</vh>
<v t="ekr.20080516150804.1287"><vh>get_doc</vh></v>
<v t="ekr.20080516150804.1288"><vh>get_calltip</vh></v>
<v t="ekr.20080516150804.1289"><vh>_get_class_docstring</vh></v>
<v t="ekr.20080516150804.1290"><vh>_get_function_docstring</vh></v>
<v t="ekr.20080516150804.1291"><vh>_is_method</vh></v>
<v t="ekr.20080516150804.1292"><vh>_get_single_function_docstring</vh></v>
<v t="ekr.20080516150804.1293"><vh>_get_super_methods</vh></v>
<v t="ekr.20080516150804.1294"><vh>_get_function_signature</vh></v>
<v t="ekr.20080516150804.1295"><vh>_location</vh></v>
<v t="ekr.20080516150804.1296"><vh>_get_module</vh></v>
<v t="ekr.20080516150804.1297"><vh>_trim_docstring</vh></v>
</v>
<v t="ekr.20080516150804.1298"><vh>class TemplateProposal</vh>
<v t="ekr.20080516150804.1299"><vh>__init__</vh></v>
</v>
<v t="ekr.20080516150804.1300"><vh>class Template</vh>
<v t="ekr.20080516150804.1301"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1302"><vh>variables</vh></v>
<v t="ekr.20080516150804.1303"><vh>substitute</vh></v>
<v t="ekr.20080516150804.1304"><vh>get_cursor_location</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1005"><vh>base\oi (**object analysis and inference)</vh>
<v t="ekr.20080516150804.1217"><vh>base\oi\__init__.py</vh>
<v t="ekr.20080516150804.1218"><vh>__init__ declarations (base.oi.ctor)</vh></v>
</v>
<v t="ekr.20080516150804.1006"><vh>base\oi\doa.py</vh>
<v t="ekr.20080516150804.1007"><vh>doa declarations</vh></v>
<v t="ekr.20080516150804.1008"><vh>class PythonFileRunner</vh>
<v t="ekr.20080516150804.1009"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1010"><vh>run</vh></v>
<v t="ekr.20080516150804.1011"><vh>_init_data_receiving</vh></v>
<v t="ekr.20080516150804.1012"><vh>_receive_information</vh></v>
<v t="ekr.20080516150804.1013"><vh>wait_process</vh></v>
<v t="ekr.20080516150804.1014"><vh>kill_process</vh></v>
<v t="ekr.20080516150804.1015"><vh>add_finishing_observer</vh></v>
</v>
<v t="ekr.20080516150804.1016"><vh>class _MessageReceiver</vh>
<v t="ekr.20080516150804.1017"><vh>receive_data</vh></v>
<v t="ekr.20080516150804.1018"><vh>get_send_info</vh></v>
</v>
<v t="ekr.20080516150804.1019"><vh>class _SocketReceiver</vh>
<v t="ekr.20080516150804.1020"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1021"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1022"><vh>receive_data</vh></v>
</v>
<v t="ekr.20080516150804.1023"><vh>class _FIFOReceiver</vh>
<v t="ekr.20080516150804.1024"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1025"><vh>_get_file_name</vh></v>
<v t="ekr.20080516150804.1026"><vh>get_send_info</vh></v>
<v t="ekr.20080516150804.1027"><vh>receive_data</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1028"><vh>base\oi\memorydb.py</vh>
<v t="ekr.20080516150804.1029"><vh>memorydb declarations</vh></v>
<v t="ekr.20080516150804.1030"><vh>class MemoryDB</vh>
<v t="ekr.20080516150804.1031"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1032"><vh>_load_files</vh></v>
<v t="ekr.20080516150804.1033"><vh>keys</vh></v>
<v t="ekr.20080516150804.1034"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1035"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1036"><vh>create</vh></v>
<v t="ekr.20080516150804.1037"><vh>rename</vh></v>
<v t="ekr.20080516150804.1038"><vh>__delitem__</vh></v>
<v t="ekr.20080516150804.1039"><vh>write</vh></v>
<v t="ekr.20080516150804.1040"><vh>compress</vh></v>
<v t="ekr.20080516150804.1041"><vh>persist</vh></v>
</v>
<v t="ekr.20080516150804.1042"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1043"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1044"><vh>create_scope</vh></v>
<v t="ekr.20080516150804.1045"><vh>keys</vh></v>
<v t="ekr.20080516150804.1046"><vh>__contains__</vh></v>
<v t="ekr.20080516150804.1047"><vh>__getitem__</vh></v>
<v t="ekr.20080516150804.1048"><vh>__delitem__</vh></v>
</v>
<v t="ekr.20080516150804.1049"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1050"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1051"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1052"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1053"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1054"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1055"><vh>add_call</vh></v>
<v t="ekr.20080516150804.1056"><vh>__getstate__</vh></v>
<v t="ekr.20080516150804.1057"><vh>__setstate__</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1058"><vh>base\oi\objectdb.py</vh>
<v t="ekr.20080516150804.1059"><vh>objectdb declarations</vh></v>
<v t="ekr.20080516150804.1060"><vh>class ObjectDB</vh>
<v t="ekr.20080516150804.1061"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1062"><vh>validate_files</vh></v>
<v t="ekr.20080516150804.1063"><vh>validate_file</vh></v>
<v t="ekr.20080516150804.1064"><vh>file_moved</vh></v>
<v t="ekr.20080516150804.1065"><vh>get_files</vh></v>
<v t="ekr.20080516150804.1066"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1067"><vh>get_pername</vh></v>
<v t="ekr.20080516150804.1068"><vh>get_callinfos</vh></v>
<v t="ekr.20080516150804.1069"><vh>add_callinfo</vh></v>
<v t="ekr.20080516150804.1070"><vh>add_pername</vh></v>
<v t="ekr.20080516150804.1071"><vh>add_file_list_observer</vh></v>
<v t="ekr.20080516150804.1072"><vh>write</vh></v>
<v t="ekr.20080516150804.1073"><vh>_get_scope_info</vh></v>
<v t="ekr.20080516150804.1074"><vh>_file_removed</vh></v>
<v t="ekr.20080516150804.1075"><vh>_file_added</vh></v>
<v t="ekr.20080516150804.1076"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1077"><vh>class _NullScopeInfo</vh>
<v t="ekr.20080516150804.1078"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1079"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1080"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1081"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1082"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1083"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1084"><vh>class FileInfo</vh>
<v t="ekr.20080516150804.1085"><vh>create_scope</vh></v>
</v>
<v t="ekr.20080516150804.1086"><vh>class FileDict</vh>
<v t="ekr.20080516150804.1087"><vh>create</vh></v>
<v t="ekr.20080516150804.1088"><vh>rename</vh></v>
</v>
<v t="ekr.20080516150804.1089"><vh>class ScopeInfo</vh>
<v t="ekr.20080516150804.1090"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1091"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1092"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1093"><vh>get_call_infos</vh></v>
<v t="ekr.20080516150804.1094"><vh>add_call</vh></v>
</v>
<v t="ekr.20080516150804.1095"><vh>class CallInfo</vh>
<v t="ekr.20080516150804.1096"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1097"><vh>get_parameters</vh></v>
<v t="ekr.20080516150804.1098"><vh>get_returned</vh></v>
</v>
<v t="ekr.20080516150804.1099"><vh>class FileListObserver</vh>
<v t="ekr.20080516150804.1100"><vh>added</vh></v>
<v t="ekr.20080516150804.1101"><vh>removed</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1102"><vh>base\oi\objectinfo.py</vh>
<v t="ekr.20080516150804.1103"><vh>objectinfo declarations</vh></v>
<v t="ekr.20080516150804.1104"><vh>class ObjectInfoManager</vh>
<v t="ekr.20080516150804.1105"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1106"><vh>_init_objectdb</vh></v>
<v t="ekr.20080516150804.1107"><vh>_init_validation</vh></v>
<v t="ekr.20080516150804.1108"><vh>_resource_changed</vh></v>
<v t="ekr.20080516150804.1109"><vh>_resource_moved</vh></v>
<v t="ekr.20080516150804.1110"><vh>get_returned</vh></v>
<v t="ekr.20080516150804.1111"><vh>get_exact_returned</vh></v>
<v t="ekr.20080516150804.1112"><vh>_args_to_textual</vh></v>
<v t="ekr.20080516150804.1113"><vh>get_parameter_objects</vh></v>
<v t="ekr.20080516150804.1114"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1115"><vh>doa_data_received</vh></v>
<v t="ekr.20080516150804.1116"><vh>function_called</vh></v>
<v t="ekr.20080516150804.1117"><vh>save_per_name</vh></v>
<v t="ekr.20080516150804.1118"><vh>get_per_name</vh></v>
<v t="ekr.20080516150804.1119"><vh>_save_data</vh></v>
<v t="ekr.20080516150804.1120"><vh>_get_scope</vh></v>
<v t="ekr.20080516150804.1121"><vh>sync</vh></v>
<v t="ekr.20080516150804.1122"><vh>__str__</vh></v>
</v>
<v t="ekr.20080516150804.1123"><vh>class TextualValidation</vh>
<v t="ekr.20080516150804.1124"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1125"><vh>is_value_valid</vh></v>
<v t="ekr.20080516150804.1126"><vh>is_more_valid</vh></v>
<v t="ekr.20080516150804.1127"><vh>is_file_valid</vh></v>
<v t="ekr.20080516150804.1128"><vh>is_scope_valid</vh></v>
</v>
<v t="ekr.20080516150804.1129"><vh>class _FileListObserver</vh>
<v t="ekr.20080516150804.1130"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1131"><vh>removed</vh></v>
<v t="ekr.20080516150804.1132"><vh>added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1133"><vh>base\oi\runmod.py</vh>
<v t="ekr.20080516150804.1134"><vh>__rope_start_everything</vh></v>
</v>
<v t="ekr.20080516150804.1135"><vh>base\oi\soa.py</vh>
<v t="ekr.20080516150804.1136"><vh>soa declarations</vh></v>
<v t="ekr.20080516150804.1137" a="E"><vh>analyze_module &amp; helper</vh>
<v t="ekr.20080516150804.1138"><vh>_analyze_node</vh></v>
</v>
<v t="ekr.20080516150804.1139"><vh>class SOIVisitor</vh>
<v t="ekr.20080516150804.1140"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1141"><vh>_FunctionDef</vh></v>
<v t="ekr.20080516150804.1142"><vh>_ClassDef</vh></v>
<v t="ekr.20080516150804.1143"><vh>_Call</vh></v>
<v t="ekr.20080516150804.1144"><vh>_args_with_self</vh></v>
<v t="ekr.20080516150804.1145"><vh>_call</vh></v>
<v t="ekr.20080516150804.1146"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1147"><vh>_Assign</vh></v>
</v>
<v t="ekr.20080516150804.1148"><vh>class _SOIAssignVisitor</vh>
<v t="ekr.20080516150804.1149"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1150"><vh>_added</vh></v>
</v>
</v>
<v t="ekr.20080516150804.1151" a="E"><vh>base\oi\soi.py</vh>
<v t="ekr.20080516150804.1152"><vh>soi declarations</vh></v>
<v t="ekr.20080516150804.1153"><vh>infer_returned_object</vh></v>
<v t="ekr.20080516150804.1154"><vh>infer_parameter_objects</vh></v>
<v t="ekr.20080516150804.1155"><vh>_handle_first_parameter</vh></v>
<v t="ekr.20080516150804.1156"><vh>infer_assigned_object</vh></v>
<v t="ekr.20080516150804.1157"><vh>get_passed_objects</vh></v>
<v t="ekr.20080516150804.1158"><vh>_infer_returned</vh></v>
<v t="ekr.20080516150804.1159"><vh>_parameter_objects</vh></v>
<v t="ekr.20080516150804.1160"><vh>_infer_assignment</vh></v>
<v t="ekr.20080516150804.1161"><vh>_follow_levels</vh></v>
<v t="ekr.20080516150804.1162"><vh>_follow_pyname</vh></v>
<v t="ekr.20080516150804.1163"><vh>_follow_evaluations</vh></v>
<v t="ekr.20080516150804.1164"><vh>_get_lineno_for_node</vh></v>
<v t="ekr.20080516150804.1165"><vh>_get_attribute</vh></v>
</v>
<v t="ekr.20080516150804.1166"><vh>base\oi\transform.py</vh>
<v t="ekr.20080516150804.1167"><vh>transform declarations</vh></v>
<v t="ekr.20080516150804.1168"><vh>class PyObjectToTextual</vh>
<v t="ekr.20080516150804.1169"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1170"><vh>transform</vh></v>
<v t="ekr.20080516150804.1171"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1172"><vh>PyObject_to_textual</vh></v>
<v t="ekr.20080516150804.1173"><vh>PyFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1174"><vh>PyClass_to_textual</vh></v>
<v t="ekr.20080516150804.1175"><vh>_defined_to_textual</vh></v>
<v t="ekr.20080516150804.1176"><vh>PyModule_to_textual</vh></v>
<v t="ekr.20080516150804.1177"><vh>PyPackage_to_textual</vh></v>
<v t="ekr.20080516150804.1178"><vh>List_to_textual</vh></v>
<v t="ekr.20080516150804.1179"><vh>Dict_to_textual</vh></v>
<v t="ekr.20080516150804.1180"><vh>Tuple_to_textual</vh></v>
<v t="ekr.20080516150804.1181"><vh>Set_to_textual</vh></v>
<v t="ekr.20080516150804.1182"><vh>Iterator_to_textual</vh></v>
<v t="ekr.20080516150804.1183"><vh>Generator_to_textual</vh></v>
<v t="ekr.20080516150804.1184"><vh>Str_to_textual</vh></v>
<v t="ekr.20080516150804.1185"><vh>File_to_textual</vh></v>
<v t="ekr.20080516150804.1186"><vh>BuiltinFunction_to_textual</vh></v>
<v t="ekr.20080516150804.1187"><vh>_get_pymodule_path</vh></v>
<v t="ekr.20080516150804.1188"><vh>resource_to_path</vh></v>
</v>
<v t="ekr.20080516150804.1189"><vh>class TextualToPyObject</vh>
<v t="ekr.20080516150804.1190"><vh>__init__</vh></v>
<v t="ekr.20080516150804.1191"><vh>__call__</vh></v>
<v t="ekr.20080516150804.1192"><vh>transform</vh></v>
<v t="ekr.20080516150804.1193"><vh>builtin_to_pyobject</vh></v>
<v t="ekr.20080516150804.1194"><vh>builtin_str_to_pyobject</vh></v>
<v t="ekr.20080516150804.1195"><vh>builtin_list_to_pyobject</vh></v>
<v t="ekr.20080516150804.1196"><vh>builtin_dict_to_pyobject</vh></v>
<v t="ekr.20080516150804.1197"><vh>builtin_tuple_to_pyobject</vh></v>
<v t="ekr.20080516150804.1198"><vh>builtin_set_to_pyobject</vh></v>
<v t="ekr.20080516150804.1199"><vh>builtin_iter_to_pyobject</vh></v>
<v t="ekr.20080516150804.1200"><vh>builtin_generator_to_pyobject</vh></v>
<v t="ekr.20080516150804.1201"><vh>builtin_file_to_pyobject</vh></v>
<v t="ekr.20080516150804.1202"><vh>builtin_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1203"><vh>unknown_to_pyobject</vh></v>
<v t="ekr.20080516150804.1204"><vh>none_to_pyobject</vh></v>
<v t="ekr.20080516150804.1205"><vh>_module_to_pyobject</vh></v>
<v t="ekr.20080516150804.1206"><vh>_hierarchical_defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1207"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1208"><vh>instance_to_pyobject</vh></v>
<v t="ekr.20080516150804.1209"><vh>_get_pymodule</vh></v>
<v t="ekr.20080516150804.1210"><vh>path_to_resource</vh></v>
</v>
<v t="ekr.20080516150804.1211"><vh>class DOITextualToPyObject</vh>
<v t="ekr.20080516150804.1212"><vh>_function_to_pyobject</vh></v>
<v t="ekr.20080516150804.1213"><vh>_class_to_pyobject</vh></v>
<v t="ekr.20080516150804.1214"><vh>defined_to_pyobject</vh></v>
<v t="ekr.20080516150804.1215"><vh>_find_occurrence</vh></v>
<v t="ekr.20080516150804.1216"><vh>path_to_resource</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080516150804.521"><vh>analyze_module (pyCore)</vh></v>
</v>
<v t="ekr.20080603141637.3" a="E"><vh>Important docstrings</vh>
<v t="ekr.20080516150804.1218"><vh>__init__ declarations (base.oi.ctor)</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20080516150804.1"></t>
<t tx="ekr.20080516150804.10"></t>
<t tx="ekr.20080516150804.11">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.12">"""rope, a python refactoring library"""

INFO = __doc__
VERSION = '0.8.2'
COPYRIGHT = """\
Copyright (C) 2006-2008 Ali Gholami Rudi

This program is free software; you can redistribute it and/or modify it
under the terms of GNU General Public License as published by the
Free Software Foundation; either version 2 of the license, or (at your
opinion) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details."""
</t>
<t tx="ekr.20080516150804.13"></t>
<t tx="ekr.20080516150804.14">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.15">import rope.base.evaluate
from rope.base import ast


</t>
<t tx="ekr.20080516150804.16">class Arguments(object):
    """A class for evaluating parameters passed to a function

    You can use the `create_arguments` factory.  It handles implicit
    first arguments.

    """
    @others
</t>
<t tx="ekr.20080516150804.17">
def __init__(self, args, scope):
    self.args = args
    self.scope = scope
    self.instance = None

</t>
<t tx="ekr.20080516150804.18">def get_arguments(self, parameters):
    result = []
    for pyname in self.get_pynames(parameters):
        if pyname is None:
            result.append(None)
        else:
            result.append(pyname.get_object())
    return result

</t>
<t tx="ekr.20080516150804.19">def get_pynames(self, parameters):
    result = [None] * max(len(parameters), len(self.args))
    for index, arg in enumerate(self.args):
        if isinstance(arg, ast.keyword) and arg.arg in parameters:
            result[parameters.index(arg.arg)] = self._evaluate(arg.value)
        else:
            result[index] = self._evaluate(arg)
    return result

</t>
<t tx="ekr.20080516150804.20">def get_instance_pyname(self):
    if self.args:
        return self._evaluate(self.args[0])

</t>
<t tx="ekr.20080516150804.21">def _evaluate(self, ast_node):
    return rope.base.evaluate.get_statement_result(self.scope, ast_node)


</t>
<t tx="ekr.20080516150804.22">def create_arguments(primary, pyfunction, call_node, scope):
    """A factory for creating `Arguments`"""
    args = list(call_node.args)
    args.extend(call_node.keywords)
    called = call_node.func
    # XXX: Handle constructors
    if _is_method_call(primary, pyfunction) and \
       isinstance(called, ast.Attribute):
        args.insert(0, called.value)
    return Arguments(args, scope)


</t>
<t tx="ekr.20080516150804.23">class ObjectArguments(object):
    @others
</t>
<t tx="ekr.20080516150804.24">
def __init__(self, pynames):
    self.pynames = pynames

</t>
<t tx="ekr.20080516150804.25">def get_arguments(self, parameters):
    result = []
    for pyname in self.pynames:
        if pyname is None:
            result.append(None)
        else:
            result.append(pyname.get_object())
    return result

</t>
<t tx="ekr.20080516150804.26">def get_pynames(self, parameters):
    return self.pynames

</t>
<t tx="ekr.20080516150804.27">def get_instance_pyname(self):
    return self.pynames[0]
</t>
<t tx="ekr.20080516150804.28">class MixedArguments(object):
    @others
</t>
<t tx="ekr.20080516150804.29">
def __init__(self, pyname, arguments, scope):
    """`argumens` is an instance of `Arguments`"""
    self.pyname = pyname
    self.args = arguments

</t>
<t tx="ekr.20080516150804.30">def get_pynames(self, parameters):
    return [self.pyname] + self.args.get_pynames(parameters[1:])

</t>
<t tx="ekr.20080516150804.31">def get_arguments(self, parameters):
    result = []
    for pyname in self.get_pynames(parameters):
        if pyname is None:
            result.append(None)
        else:
            result.append(pyname.get_object())
    return result

</t>
<t tx="ekr.20080516150804.32">def get_instance_pyname(self):
    return self.pyname


</t>
<t tx="ekr.20080516150804.33">def _is_method_call(primary, pyfunction):
    if primary is None:
        return False
    pyobject = primary.get_object()
    if isinstance(pyobject.get_type(), rope.base.pyobjects.PyClass) and \
       isinstance(pyfunction, rope.base.pyobjects.PyFunction) and \
       isinstance(pyfunction.parent, rope.base.pyobjects.PyClass):
        return True
    if isinstance(pyobject.get_type(), rope.base.pyobjects.AbstractClass) and \
       isinstance(pyfunction, rope.base.builtins.BuiltinFunction):
        return True
    return False
</t>
<t tx="ekr.20080516150804.34">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.35">import _ast
from _ast import *

from rope.base import fscommands


</t>
<t tx="ekr.20080516150804.36">def parse(source, filename='&lt;string&gt;'):
    # NOTE: the raw string should be given to `compile` function
    if isinstance(source, unicode):
        source = fscommands.unicode_to_file_data(source)
    if '\r\n' in source:
        source = source.replace('\r\n', '\n')
    if not source.endswith('\n'):
        source += '\n'
    try:
        return compile(source, filename, 'exec', _ast.PyCF_ONLY_AST)
    except (TypeError, ValueError), e:
        error = SyntaxError()
        error.lineno = 1
        error.filename = filename
        error.msg = str(e)
        raise error


</t>
<t tx="ekr.20080516150804.37">def walk(node, walker):
    """Walk the syntax tree"""
    method_name = '_' + node.__class__.__name__
    method = getattr(walker, method_name, None)
    if method is not None:
        return method(node)
    for child in get_child_nodes(node):
        walk(child, walker)


</t>
<t tx="ekr.20080516150804.38">def get_child_nodes(node):
    if isinstance(node, _ast.Module):
        return node.body
    result = []
    if node._fields is not None:
        for name in node._fields:
            child = getattr(node, name)
            if isinstance(child, list):
                for entry in child:
                    if isinstance(entry, _ast.AST):
                        result.append(entry)
            if isinstance(child, _ast.AST):
                result.append(child)
    return result


</t>
<t tx="ekr.20080516150804.39">def call_for_nodes(node, callback, recursive=False):
    """If callback returns `True` the child nodes are skipped"""
    result = callback(node)
    if recursive and not result:
        for child in get_child_nodes(node):
            call_for_nodes(child, callback, recursive)


</t>
<t tx="ekr.20080516150804.40">def get_children(node):
    result = []
    if node._fields is not None:
        for name in node._fields:
            if name in ['lineno', 'col_offset']:
                continue
            child = getattr(node, name)
            result.append(child)
    return result
</t>
<t tx="ekr.20080516150804.41">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.42">from rope.base import ast


</t>
<t tx="ekr.20080516150804.43">def get_name_levels(node):
    """Return a list of ``(name, level)`` tuples for assigned names

    The `level` is `None` for simple assignments and is a list of
    numbers for tuple assignments for example in::

      a, (b, c) = x

    The levels for for `a` is ``[0]``, for `b` is ``[1, 0]`` and for
    `c` is ``[1, 1]``.

    """
    visitor = _NodeNameCollector()
    ast.walk(node, visitor)
    return visitor.names


</t>
<t tx="ekr.20080516150804.44">class _NodeNameCollector(object):
    @others
</t>
<t tx="ekr.20080516150804.45">
def __init__(self, levels=None):
    self.names = []
    self.levels = levels
    self.index = 0

</t>
<t tx="ekr.20080516150804.46">def _add_node(self, node):
    new_levels = []
    if self.levels is not None:
        new_levels = list(self.levels)
        new_levels.append(self.index)
    self.index += 1
    self._added(node, new_levels)

</t>
<t tx="ekr.20080516150804.47">def _added(self, node, levels):
    if hasattr(node, 'id'):
        self.names.append((node.id, levels))

</t>
<t tx="ekr.20080516150804.48">def _Name(self, node):
    self._add_node(node)

</t>
<t tx="ekr.20080516150804.49">def _Tuple(self, node):
    new_levels = []
    if self.levels is not None:
        new_levels = list(self.levels)
        new_levels.append(self.index)
    self.index += 1
    visitor = _NodeNameCollector(new_levels)
    for child in ast.get_child_nodes(node):
        ast.walk(child, visitor)
    self.names.extend(visitor.names)

</t>
<t tx="ekr.20080516150804.50">def _Subscript(self, node):
    self._add_node(node)

</t>
<t tx="ekr.20080516150804.51">def _Attribute(self, node):
    self._add_node(node)

</t>
<t tx="ekr.20080516150804.52">def _Slice(self, node):
    self._add_node(node)
</t>
<t tx="ekr.20080516150804.53">@language python
@tabwidth -4
@others
_initial_builtins = {
    'list': BuiltinName(get_list_type()),
    'dict': BuiltinName(get_dict_type()),
    'tuple': BuiltinName(get_tuple_type()),
    'set': BuiltinName(get_set_type()),
    'str': BuiltinName(get_str_type()),
    'file': BuiltinName(get_file_type()),
    'open': BuiltinName(get_file_type()),
    'unicode': BuiltinName(get_str_type()),
    'range': BuiltinName(BuiltinFunction(function=_range_function, builtin=range)),
    'reversed': BuiltinName(BuiltinFunction(function=_reversed_function, builtin=reversed)),
    'sorted': BuiltinName(BuiltinFunction(function=_sorted_function, builtin=sorted)),
    'super': BuiltinName(BuiltinFunction(function=_super_function, builtin=super)),
    'property': BuiltinName(BuiltinFunction(function=_property_function, builtin=property)),
    'zip': BuiltinName(BuiltinFunction(function=_zip_function, builtin=zip)),
    'enumerate': BuiltinName(BuiltinFunction(function=_enumerate_function, builtin=enumerate)),
    'object': BuiltinName(BuiltinObject()),
    'type': BuiltinName(BuiltinType()),
    'iter': BuiltinName(BuiltinFunction(function=_iter_function, builtin=iter)),
    'raw_input': BuiltinName(BuiltinFunction(function=_input_function, builtin=raw_input)),
    }

builtins = BuiltinModule('__builtin__', _initial_builtins)
</t>
<t tx="ekr.20080516150804.54">"""This module trys to support builtin types and functions."""
import inspect

import rope.base.evaluate
from rope.base import pynames, pyobjects, arguments


</t>
<t tx="ekr.20080516150804.55">class BuiltinModule(pyobjects.AbstractModule):
    @others
</t>
<t tx="ekr.20080516150804.56">
def __init__(self, name, initial={}):
    super(BuiltinModule, self).__init__()
    self.name = name
    self.initial = initial
    self.attributes = None

</t>
<t tx="ekr.20080516150804.57">parent = None

def get_attributes(self):
    if self.attributes is None:
        self._calculate_attributes()
    return self.attributes

</t>
<t tx="ekr.20080516150804.58">def get_doc(self):
    if self.module:
        return self.module.__doc__

</t>
<t tx="ekr.20080516150804.59">def get_name(self):
    return self.name

</t>
<t tx="ekr.20080516150804.60">def _calculate_attributes(self):
    self.attributes = {}
    if self.module is not None:
        self.attributes = _object_attributes(self.module, self)
    self.attributes.update(self.initial)

</t>
<t tx="ekr.20080516150804.61">_loaded = False
_module = None
@property
def module(self):
    if not self._loaded:
        self._loaded = True
        try:
            self._module = __import__(self.name)
        except ImportError:
            self._module = None
    return self._module


</t>
<t tx="ekr.20080516150804.62">class _BuiltinElement(object):
    @others
</t>
<t tx="ekr.20080516150804.63">
def __init__(self, builtin, parent=None):
    self.builtin = builtin
    self._parent = parent

</t>
<t tx="ekr.20080516150804.64">def get_doc(self):
    if self.builtin:
        return self.builtin.__doc__

</t>
<t tx="ekr.20080516150804.65">def get_name(self):
    if self.builtin:
        return self.builtin.__name__

</t>
<t tx="ekr.20080516150804.66">@property
def parent(self):
    if self._parent is None:
        return builtins
    return self._parent


</t>
<t tx="ekr.20080516150804.67">class BuiltinClass(_BuiltinElement, pyobjects.AbstractClass):
    @others
</t>
<t tx="ekr.20080516150804.68">
def __init__(self, builtin, attributes, parent=None):
    _BuiltinElement.__init__(self, builtin, parent)
    pyobjects.AbstractClass.__init__(self)
    self.initial = attributes
    self.attributes = None

</t>
<t tx="ekr.20080516150804.69">def get_attributes(self):
    if self.attributes is None:
        self.attributes = _object_attributes(self.builtin, self)
        self.attributes.update(self.initial)
    return self.attributes


</t>
<t tx="ekr.20080516150804.70">class BuiltinFunction(_BuiltinElement, pyobjects.AbstractFunction):
    @others
</t>
<t tx="ekr.20080516150804.71">
def __init__(self, returned=None, function=None, builtin=None,
             argnames=[], parent=None):
    _BuiltinElement.__init__(self, builtin, parent)
    pyobjects.AbstractFunction.__init__(self)
    self.argnames = argnames
    self.returned = returned
    self.function = function

</t>
<t tx="ekr.20080516150804.72">def get_returned_object(self, args):
    if self.function is not None:
        return self.function(_CallContext(self.argnames, args))
    else:
        return self.returned

</t>
<t tx="ekr.20080516150804.73">def get_param_names(self, special_args=True):
    return self.argnames


</t>
<t tx="ekr.20080516150804.74">def _object_attributes(obj, parent):
    attributes = {}
    for name in dir(obj):
        if name == 'None':
            continue
        child = getattr(obj, name)
        pyobject = None
        if inspect.isclass(child):
            pyobject = BuiltinClass(child, {}, parent=parent)
        elif inspect.isroutine(child):
            pyobject = BuiltinFunction(builtin=child, parent=parent)
        else:
            pyobject = pyobjects.get_unknown()
        attributes[name] = BuiltinName(pyobject)
    return attributes


</t>
<t tx="ekr.20080516150804.75">def _create_builtin_type_getter(cls):
    def _get_builtin(*args):
        if not hasattr(cls, '_generated'):
            cls._generated = {}
        if args not in cls._generated:
            cls._generated[args] = cls(*args)
        return cls._generated[args]
    return _get_builtin

</t>
<t tx="ekr.20080516150804.76">def _create_builtin_getter(cls):
    type_getter = _create_builtin_type_getter(cls)
    def _get_builtin(*args):
        return pyobjects.PyObject(type_getter(*args))
    return _get_builtin


</t>
<t tx="ekr.20080516150804.77">class _CallContext(object):
    @others
</t>
<t tx="ekr.20080516150804.78">
def __init__(self, argnames, args):
    self.argnames = argnames
    self.args = args

</t>
<t tx="ekr.20080516150804.79">def _get_scope_and_pyname(self, pyname):
    if pyname is not None and isinstance(pyname, pynames.AssignedName):
        pymodule, lineno = pyname.get_definition_location()
        if pymodule is None:
            return None, None
        if lineno is None:
            lineno = 1
        scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
        name = None
        while name is None and scope is not None:
            for current in scope.get_names():
                if scope[current] is pyname:
                    name = current
                    break
            else:
                scope = scope.parent
        return scope, name
    return None, None

</t>
<t tx="ekr.20080516150804.80">def get_argument(self, name):
    if self.args:
        args = self.args.get_arguments(self.argnames)
        return args[self.argnames.index(name)]

</t>
<t tx="ekr.20080516150804.81">def get_pyname(self, name):
    if self.args:
        args = self.args.get_pynames(self.argnames)
        if name in self.argnames:
            return args[self.argnames.index(name)]

</t>
<t tx="ekr.20080516150804.82">def get_arguments(self, argnames):
    if self.args:
        return self.args.get_arguments(argnames)

</t>
<t tx="ekr.20080516150804.83">def get_pynames(self, argnames):
    if self.args:
        return self.args.get_pynames(argnames)

</t>
<t tx="ekr.20080516150804.84">def get_per_name(self):
    if self.args is None:
        return None
    pyname = self.args.get_instance_pyname()
    scope, name = self._get_scope_and_pyname(pyname)
    if name is not None:
        pymodule = pyname.get_definition_location()[0]
        return pymodule.pycore.object_info.get_per_name(scope, name)
    return None

</t>
<t tx="ekr.20080516150804.85">def save_per_name(self, value):
    if self.args is None:
        return None
    pyname = self.args.get_instance_pyname()
    scope, name = self._get_scope_and_pyname(pyname)
    if name is not None:
        pymodule = pyname.get_definition_location()[0]
        pymodule.pycore.object_info.save_per_name(scope, name, value)


</t>
<t tx="ekr.20080516150804.86">class _AttributeCollector(object):
    @others
</t>
<t tx="ekr.20080516150804.87">
def __init__(self, type):
    self.attributes = {}
    self.type = type

</t>
<t tx="ekr.20080516150804.88">def __call__(self, name, returned=None, function=None,
             argnames=['self'], check_existence=True):
    try:
        builtin = getattr(self.type, name)
    except AttributeError:
        if check_existence:
            raise
        builtin=None
    self.attributes[name] = BuiltinName(
        BuiltinFunction(returned=returned, function=function,
                        argnames=argnames, builtin=builtin))

</t>
<t tx="ekr.20080516150804.89">def __setitem__(self, name, value):
    self.attributes[name] = value


</t>
<t tx="ekr.20080516150804.90">class List(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.91">
def __init__(self, holding=None):
    self.holding = holding
    collector = _AttributeCollector(list)

    collector('__iter__', function=self._iterator_get)
    collector('__new__', function=self._new_list)

    # Adding methods
    collector('append', function=self._list_add, argnames=['self', 'value'])
    collector('__setitem__', function=self._list_add,
              argnames=['self', 'index', 'value'])
    collector('insert', function=self._list_add,
              argnames=['self', 'index', 'value'])
    collector('extend', function=self._self_set,
              argnames=['self', 'iterable'])

    # Getting methods
    collector('__getitem__', function=self._list_get)
    collector('pop', function=self._list_get)
    collector('__getslice__', function=self._self_get)

    super(List, self).__init__(list, collector.attributes)

</t>
<t tx="ekr.20080516150804.92">def _new_list(self, args):
    return _create_builtin(args, get_list)

</t>
<t tx="ekr.20080516150804.93">def _list_add(self, context):
    if self.holding is not None:
        return
    holding = context.get_argument('value')
    if holding is not None and holding != pyobjects.get_unknown():
        context.save_per_name(holding)

</t>
<t tx="ekr.20080516150804.94">def _self_set(self, context):
    if self.holding is not None:
        return
    iterable = context.get_pyname('iterable')
    holding = _infer_sequence_for_pyname(iterable)
    if holding is not None and holding != pyobjects.get_unknown():
        context.save_per_name(holding)

</t>
<t tx="ekr.20080516150804.95">def _list_get(self, context):
    if self.holding is not None:
        return self.holding
    return context.get_per_name()

</t>
<t tx="ekr.20080516150804.96">def _iterator_get(self, context):
    return get_iterator(self._list_get(context))

</t>
<t tx="ekr.20080516150804.97">def _self_get(self, context):
    return get_list(self._list_get(context))


</t>
<t tx="ekr.20080516150804.98">get_list = _create_builtin_getter(List)
get_list_type = _create_builtin_type_getter(List)


class Dict(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.99">
def __init__(self, keys=None, values=None):
    self.keys = keys
    self.values = values
    item = get_tuple(self.keys, self.values)
    collector = _AttributeCollector(dict)
    collector('__new__', function=self._new_dict)
    collector('__setitem__', function=self._dict_add)
    collector('popitem', function=self._item_get)
    collector('pop', function=self._value_get)
    collector('get', function=self._key_get)
    collector('keys', function=self._key_list)
    collector('values', function=self._value_list)
    collector('items', function=self._item_list)
    collector('copy', function=self._self_get)
    collector('__getitem__', function=self._value_get)
    collector('__iter__', function=self._key_iter)
    collector('update', function=self._self_set)
    super(Dict, self).__init__(dict, collector.attributes)

</t>
<t tx="ekr.20080516150804.100">def _new_dict(self, args):
    def do_create(holding=None):
        if holding is None:
            return get_dict()
        type = holding.get_type()
        if isinstance(type, Tuple) and len(type.get_holding_objects()) == 2:
            return get_dict(*type.get_holding_objects())
    return _create_builtin(args, do_create)

</t>
<t tx="ekr.20080516150804.101">def _dict_add(self, context):
    if self.keys is not None:
        return
    key, value = context.get_arguments(['self', 'key', 'value'])[1:]
    if key is not None and key != pyobjects.get_unknown():
        context.save_per_name(get_tuple(key, value))

</t>
<t tx="ekr.20080516150804.102">def _item_get(self, context):
    if self.keys is not None:
        return get_tuple(self.keys, self.values)
    item = context.get_per_name()
    if item is None or not isinstance(item.get_type(), Tuple):
        return get_tuple(self.keys, self.values)
    return item

</t>
<t tx="ekr.20080516150804.103">def _value_get(self, context):
    item = self._item_get(context).get_type()
    return item.get_holding_objects()[1]

</t>
<t tx="ekr.20080516150804.104">def _key_get(self, context):
    item = self._item_get(context).get_type()
    return item.get_holding_objects()[0]

</t>
<t tx="ekr.20080516150804.105">def _value_list(self, context):
    return get_list(self._value_get(context))

</t>
<t tx="ekr.20080516150804.106">def _key_list(self, context):
    return get_list(self._key_get(context))

</t>
<t tx="ekr.20080516150804.107">def _item_list(self, context):
    return get_list(self._item_get(context))

</t>
<t tx="ekr.20080516150804.108">def _value_iter(self, context):
    return get_iterator(self._value_get(context))

</t>
<t tx="ekr.20080516150804.109">def _key_iter(self, context):
    return get_iterator(self._key_get(context))

</t>
<t tx="ekr.20080516150804.110">def _item_iter(self, context):
    return get_iterator(self._item_get(context))

</t>
<t tx="ekr.20080516150804.111">def _self_get(self, context):
    item = self._item_get(context).get_type()
    key, value = item.get_holding_objects()[:2]
    return get_dict(key, value)

</t>
<t tx="ekr.20080516150804.112">def _self_set(self, context):
    if self.keys is not None:
        return
    new_dict = context.get_pynames(['self', 'd'])[1]
    if new_dict and isinstance(new_dict.get_object().get_type(), Dict):
        args = arguments.ObjectArguments([new_dict])
        items = new_dict.get_object()['popitem'].\
                get_object().get_returned_object(args)
        context.save_per_name(items)
    else:
        holding = _infer_sequence_for_pyname(new_dict)
        if holding is not None and isinstance(holding.get_type(), Tuple):
            context.save_per_name(holding)


</t>
<t tx="ekr.20080516150804.113">get_dict = _create_builtin_getter(Dict)
get_dict_type = _create_builtin_type_getter(Dict)


class Tuple(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.114">
def __init__(self, *objects):
    self.objects = objects
    first = None
    if objects:
        first = objects[0]
    attributes = {
        '__getitem__': BuiltinName(BuiltinFunction(first)),
        '__getslice__': BuiltinName(BuiltinFunction(pyobjects.PyObject(self))),
        '__new__': BuiltinName(BuiltinFunction(function=self._new_tuple)),
        '__iter__': BuiltinName(BuiltinFunction(get_iterator(first)))}
    super(Tuple, self).__init__(tuple, attributes)

</t>
<t tx="ekr.20080516150804.115">def get_holding_objects(self):
    return self.objects

</t>
<t tx="ekr.20080516150804.116">def _new_tuple(self, args):
    return _create_builtin(args, get_tuple)


</t>
<t tx="ekr.20080516150804.117">get_tuple = _create_builtin_getter(Tuple)
get_tuple_type = _create_builtin_type_getter(Tuple)


class Set(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.118">
def __init__(self, holding=None):
    self.holding = holding
    collector = _AttributeCollector(set)
    collector('__new__', function=self._new_set)

    self_methods = ['copy', 'difference', 'intersection',
                    'symmetric_difference', 'union']
    for method in self_methods:
        collector(method, function=self._self_get)
    collector('add', function=self._set_add)
    collector('update', function=self._self_set)
    collector('update', function=self._self_set)
    collector('symmetric_difference_update', function=self._self_set)
    collector('difference_update', function=self._self_set)

    collector('pop', function=self._set_get)
    collector('__iter__', function=self._iterator_get)
    super(Set, self).__init__(set, collector.attributes)

</t>
<t tx="ekr.20080516150804.119">def _new_set(self, args):
    return _create_builtin(args, get_set)

</t>
<t tx="ekr.20080516150804.120">def _set_add(self, context):
    if self.holding is not None:
        return
    holding = context.get_arguments(['self', 'value'])[1]
    if holding is not None and holding != pyobjects.get_unknown():
        context.save_per_name(holding)

</t>
<t tx="ekr.20080516150804.121">def _self_set(self, context):
    if self.holding is not None:
        return
    iterable = context.get_pyname('iterable')
    holding = _infer_sequence_for_pyname(iterable)
    if holding is not None and holding != pyobjects.get_unknown():
        context.save_per_name(holding)

</t>
<t tx="ekr.20080516150804.122">def _set_get(self, context):
    if self.holding is not None:
        return self.holding
    return context.get_per_name()

</t>
<t tx="ekr.20080516150804.123">def _iterator_get(self, context):
    return get_iterator(self._set_get(context))

</t>
<t tx="ekr.20080516150804.124">def _self_get(self, context):
    return get_list(self._set_get(context))


</t>
<t tx="ekr.20080516150804.125">get_set = _create_builtin_getter(Set)
get_set_type = _create_builtin_type_getter(Set)


class Str(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.126">
def __init__(self):
    self_object = pyobjects.PyObject(self)
    collector = _AttributeCollector(str)
    collector('__iter__', get_iterator(self_object), check_existence=False)

    self_methods = ['__getitem__', '__getslice__', 'capitalize', 'center',
                    'decode', 'encode', 'expandtabs', 'join', 'ljust',
                    'lower', 'lstrip', 'replace', 'rjust', 'rstrip', 'strip',
                    'swapcase', 'title', 'translate', 'upper', 'zfill']
    for method in self_methods:
        collector(method, self_object)

    for method in ['rsplit', 'split', 'splitlines']:
        collector(method, get_list(self_object))

    super(Str, self).__init__(str, collector.attributes)

</t>
<t tx="ekr.20080516150804.127">def get_doc(self):
    return str.__doc__


</t>
<t tx="ekr.20080516150804.128">get_str = _create_builtin_getter(Str)
get_str_type = _create_builtin_type_getter(Str)


class BuiltinName(pynames.PyName):
    @others
</t>
<t tx="ekr.20080516150804.129">
def __init__(self, pyobject):
    self.pyobject = pyobject

</t>
<t tx="ekr.20080516150804.130">def get_object(self):
    return self.pyobject

</t>
<t tx="ekr.20080516150804.131">def get_definition_location(self):
    return (None, None)

</t>
<t tx="ekr.20080516150804.132">class Iterator(pyobjects.AbstractClass):
    @others
</t>
<t tx="ekr.20080516150804.133">
def __init__(self, holding=None):
    super(Iterator, self).__init__()
    self.holding = holding
    self.attributes = {
        'next': BuiltinName(BuiltinFunction(self.holding)),
        '__iter__': BuiltinName(BuiltinFunction(self))}

</t>
<t tx="ekr.20080516150804.134">def get_attributes(self):
    return self.attributes

</t>
<t tx="ekr.20080516150804.135">def get_returned_object(self, args):
    return self.holding

</t>
<t tx="ekr.20080516150804.136">get_iterator = _create_builtin_getter(Iterator)


class Generator(pyobjects.AbstractClass):
    @others
</t>
<t tx="ekr.20080516150804.137">
def __init__(self, holding=None):
    super(Generator, self).__init__()
    self.holding = holding
    self.attributes = {
        'next': BuiltinName(BuiltinFunction(self.holding)),
        '__iter__': BuiltinName(BuiltinFunction(get_iterator(self.holding))),
        'close': BuiltinName(BuiltinFunction()),
        'send': BuiltinName(BuiltinFunction()),
        'throw': BuiltinName(BuiltinFunction())}

</t>
<t tx="ekr.20080516150804.138">def get_attributes(self):
    return self.attributes

</t>
<t tx="ekr.20080516150804.139">def get_returned_object(self, args):
    return self.holding

</t>
<t tx="ekr.20080516150804.140">get_generator = _create_builtin_getter(Generator)


class File(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.141">
def __init__(self):
    self_object = pyobjects.PyObject(self)
    str_object = get_str()
    str_list = get_list(get_str())
    attributes = {}
    def add(name, returned=None, function=None):
        builtin = getattr(file, name, None)
        attributes[name] = BuiltinName(
            BuiltinFunction(returned=returned, function=function,
                            builtin=builtin))
    add('__iter__', get_iterator(str_object))
    for method in ['next', 'read', 'readline', 'readlines']:
        add(method, str_list)
    for method in ['close', 'flush', 'lineno', 'isatty', 'seek', 'tell',
                   'truncate', 'write', 'writelines']:
        add(method)
    super(File, self).__init__(file, attributes)


</t>
<t tx="ekr.20080516150804.142">get_file = _create_builtin_getter(File)
get_file_type = _create_builtin_type_getter(File)


class Property(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.143">
def __init__(self, fget=None, fset=None, fdel=None, fdoc=None):
    self._fget = fget
    self._fdoc = fdoc
    attributes = {
        'fget': BuiltinName(BuiltinFunction()),
        'fset': BuiltinName(pynames.UnboundName()),
        'fdel': BuiltinName(pynames.UnboundName()),
        '__new__': BuiltinName(BuiltinFunction(function=_property_function))}
    super(Property, self).__init__(property, attributes)

</t>
<t tx="ekr.20080516150804.144">def get_property_object(self, args):
    if isinstance(self._fget, pyobjects.AbstractFunction):
        return self._fget.get_returned_object(args)


</t>
<t tx="ekr.20080516150804.145">def _property_function(args):
    parameters = args.get_arguments(['fget', 'fset', 'fdel', 'fdoc'])
    return pyobjects.PyObject(Property(parameters[0]))


</t>
<t tx="ekr.20080516150804.146">class Lambda(pyobjects.AbstractFunction):
    @others
</t>
<t tx="ekr.20080516150804.147">
def __init__(self, node, scope):
    super(Lambda, self).__init__()
    self.node = node
    self.scope = scope

</t>
<t tx="ekr.20080516150804.148">def get_returned_object(self, args):
    result = rope.base.evaluate.get_statement_result(self.scope,
                                                     self.node.body)
    if result is not None:
        return result.get_object()
    else:
        return pyobjects.get_unknown()

</t>
<t tx="ekr.20080516150804.149">def get_pattributes(self):
    return {}


</t>
<t tx="ekr.20080516150804.150">class BuiltinObject(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.151">
def __init__(self):
    super(BuiltinObject, self).__init__(object, {})


</t>
<t tx="ekr.20080516150804.152">class BuiltinType(BuiltinClass):
    @others
</t>
<t tx="ekr.20080516150804.153">
def __init__(self):
    super(BuiltinType, self).__init__(type, {})


</t>
<t tx="ekr.20080516150804.154">def _infer_sequence_for_pyname(pyname):
    if pyname is None:
        return None
    seq = pyname.get_object()
    args = arguments.ObjectArguments([pyname])
    if '__iter__' in seq:
        iter = seq['__iter__'].get_object().\
               get_returned_object(args)
        if iter is not None and 'next' in iter:
            holding = iter['next'].get_object().\
                      get_returned_object(args)
            return holding


</t>
<t tx="ekr.20080516150804.155">def _create_builtin(args, creator):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    if holding is not None:
        return creator(holding)
    else:
        return creator()


</t>
<t tx="ekr.20080516150804.156">def _range_function(args):
    return get_list()

</t>
<t tx="ekr.20080516150804.157">def _reversed_function(args):
    return _create_builtin(args, get_iterator)

</t>
<t tx="ekr.20080516150804.158">def _sorted_function(args):
    return _create_builtin(args, get_list)

</t>
<t tx="ekr.20080516150804.159">def _super_function(args):
    passed_class, passed_self = args.get_arguments(['type', 'self'])
    if passed_self is None:
        return passed_class
    else:
        #pyclass = passed_self.get_type()
        pyclass = passed_class
        if isinstance(pyclass, pyobjects.AbstractClass):
            supers = pyclass.get_superclasses()
            if supers:
                return pyobjects.PyObject(supers[0])
        return passed_self

</t>
<t tx="ekr.20080516150804.160">def _zip_function(args):
    args = args.get_pynames(['sequence'])
    objects = []
    for seq in args:
        if seq is None:
            holding = None
        else:
            holding = _infer_sequence_for_pyname(seq)
        objects.append(holding)
    tuple = get_tuple(*objects)
    return get_list(tuple)

</t>
<t tx="ekr.20080516150804.161">def _enumerate_function(args):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    tuple = get_tuple(None, holding)
    return get_iterator(tuple)

</t>
<t tx="ekr.20080516150804.162">def _iter_function(args):
    passed = args.get_pynames(['sequence'])[0]
    if passed is None:
        holding = None
    else:
        holding = _infer_sequence_for_pyname(passed)
    return get_iterator(holding)

</t>
<t tx="ekr.20080516150804.163">def _input_function(args):
    return get_str()


</t>
<t tx="ekr.20080516150804.164">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.165">import datetime
import difflib
import os
import time
import warnings

import rope.base.fscommands
from rope.base import taskhandle, exceptions


</t>
<t tx="ekr.20080516150804.166">class Change(object):
    """The base class for changes

    Rope refactorings return `Change` objects.  They can be previewed,
    committed or undone.

    """
    @others
</t>
<t tx="ekr.20080516150804.167">
def do(self, job_set=None):
    """Perform the change
    
    .. note:: Do use this directly.  Use `Project.do()` instead.

    """

</t>
<t tx="ekr.20080516150804.168">def undo(self, job_set=None):
    """Perform the change
    
    .. note:: Do use this directly.  Use `History.undo()` instead.

    """

</t>
<t tx="ekr.20080516150804.169">def get_description(self):
    """Return the description of this change

    This can be used for previewing the changes.

    """
    return str(self)

</t>
<t tx="ekr.20080516150804.170">def get_changed_resources(self):
    """Return the list of resources that will be changed"""
    return []


</t>
<t tx="ekr.20080516150804.171">class ChangeSet(Change):
    """A collection of `Change` objects

    This class holds a collection of changes.  This class provides
    these fields:

    * `changes`: the list of changes
    * `description`: the goal of these changes

    """
    @others
</t>
<t tx="ekr.20080516150804.172">
def __init__(self, description, timestamp=None):
    self.changes = []
    self.description = description
    self.time = timestamp

</t>
<t tx="ekr.20080516150804.173">def do(self, job_set=taskhandle.NullJobSet()):
    try:
        done = []
        for change in self.changes:
            change.do(job_set)
            done.append(change)
        self.time = time.time()
    except Exception:
        for change in done:
            change.undo()
        raise

</t>
<t tx="ekr.20080516150804.174">def undo(self, job_set=taskhandle.NullJobSet()):
    try:
        done = []
        for change in reversed(self.changes):
            change.undo(job_set)
            done.append(change)
    except Exception:
        for change in done:
            change.do()
        raise

</t>
<t tx="ekr.20080516150804.175">def add_change(self, change):
    self.changes.append(change)

</t>
<t tx="ekr.20080516150804.176">def get_description(self):
    result = [str(self) + ':\n\n\n']
    for change in self.changes:
        result.append(change.get_description())
        result.append('\n')
    return ''.join(result)

</t>
<t tx="ekr.20080516150804.177">def __str__(self):
    if self.time is not None:
        date = datetime.datetime.fromtimestamp(self.time)
        if date.date() == datetime.date.today():
            string_date = 'today'
        elif date.date() == (datetime.date.today() - datetime.timedelta(1)):
            string_date = 'yesterday'
        elif date.year == datetime.date.today().year:
            string_date = date.strftime('%b %d')
        else:
            string_date = date.strftime('%d %b, %Y')
        string_time = date.strftime('%H:%M:%S')
        string_time = '%s %s ' % (string_date, string_time)
        return self.description + ' - ' + string_time
    return self.description

</t>
<t tx="ekr.20080516150804.178">def get_changed_resources(self):
    result = set()
    for change in self.changes:
        result.update(change.get_changed_resources())
    return result


</t>
<t tx="ekr.20080516150804.179">def _handle_job_set(function):
    """A decorator for handling `taskhandle.JobSet`\s

    A decorator for handling `taskhandle.JobSet`\s for `do` and `undo`
    methods of `Change`\s.
    """
    def call(self, job_set=taskhandle.NullJobSet()):
        job_set.started_job(str(self))
        function(self)
        job_set.finished_job()
    return call


</t>
<t tx="ekr.20080516150804.180">class ChangeContents(Change):
    """A class to change the contents of a file

    Fields:

    * `resource`: The `rope.base.resources.File` to change
    * `new_contents`: What to write in the file

    """
    @others
</t>
<t tx="ekr.20080516150804.181">
def __init__(self, resource, new_contents, old_contents=None):
    self.resource = resource
    # IDEA: Only saving diffs; possible problems when undo/redoing
    self.new_contents = new_contents
    self.old_contents = old_contents
    self.operations = self.resource.project.operations

</t>
<t tx="ekr.20080516150804.182">@_handle_job_set
def do(self):
    if self.old_contents is None:
        self.old_contents = self.resource.read()
    self.operations.write_file(self.resource, self.new_contents)

</t>
<t tx="ekr.20080516150804.183">@_handle_job_set
def undo(self):
    if self.old_contents is None:
        raise exceptions.HistoryError(
            'Undoing a change that is not performed yet!')
    self.operations.write_file(self.resource, self.old_contents)

</t>
<t tx="ekr.20080516150804.184">def __str__(self):
    return 'Change &lt;%s&gt;' % self.resource.path

</t>
<t tx="ekr.20080516150804.185">def get_description(self):
    new = self.new_contents
    old = self.old_contents
    if old is None:
        if self.resource.exists():
            old = self.resource.read()
        else:
            old = ''
    result = difflib.unified_diff(
        old.splitlines(True), new.splitlines(True),
        'a/' + self.resource.path, 'b/' + self.resource.path)
    return ''.join(list(result))

</t>
<t tx="ekr.20080516150804.186">def get_changed_resources(self):
    return [self.resource]


</t>
<t tx="ekr.20080516150804.187">class MoveResource(Change):
    """Move a resource to a new location

    Fields:

    * `resource`: The `rope.base.resources.Resource` to move
    * `new_resource`: The destination for move; It is the moved
      resource not the folder containing that resource.

    """
    @others
</t>
<t tx="ekr.20080516150804.188">
def __init__(self, resource, new_location, exact=False):
    self.project = resource.project
    self.operations = resource.project.operations
    self.resource = resource
    if not exact:
        new_location = _get_destination_for_move(resource, new_location)
    if resource.is_folder():
        self.new_resource = self.project.get_folder(new_location)
    else:
        self.new_resource = self.project.get_file(new_location)

</t>
<t tx="ekr.20080516150804.189">@_handle_job_set
def do(self):
    self.operations.move(self.resource, self.new_resource)

</t>
<t tx="ekr.20080516150804.190">@_handle_job_set
def undo(self):
    self.operations.move(self.new_resource, self.resource)

</t>
<t tx="ekr.20080516150804.191">def __str__(self):
    return 'Move &lt;%s&gt;' % self.resource.path

</t>
<t tx="ekr.20080516150804.192">def get_description(self):
    return 'rename from %s\nrename to %s' % (self.resource.path,
                                             self.new_resource.path)

</t>
<t tx="ekr.20080516150804.193">def get_changed_resources(self):
    return [self.resource, self.new_resource]


</t>
<t tx="ekr.20080516150804.194">class CreateResource(Change):
    """A class to create a resource

    Fields:

    * `resource`: The resource to create

    """
    @others
</t>
<t tx="ekr.20080516150804.195">
def __init__(self, resource):
    self.resource = resource
    self.operations = self.resource.project.operations

</t>
<t tx="ekr.20080516150804.196">@_handle_job_set
def do(self):
    self.operations.create(self.resource)

</t>
<t tx="ekr.20080516150804.197">@_handle_job_set
def undo(self):
    self.operations.remove(self.resource)

</t>
<t tx="ekr.20080516150804.198">def __str__(self):
    return 'Create Resource &lt;%s&gt;' % (self.resource.path)

</t>
<t tx="ekr.20080516150804.199">def get_description(self):
    return 'new file %s' % (self.resource.path)

</t>
<t tx="ekr.20080516150804.200">def get_changed_resources(self):
    return [self.resource]

</t>
<t tx="ekr.20080516150804.201">def _get_child_path(self, parent, name):
    if parent.path == '':
        return name
    else:
        return parent.path + '/' + name


</t>
<t tx="ekr.20080516150804.202">class CreateFolder(CreateResource):
    """A class to create a folder

    See docs for `CreateResource`.
    """
    @others
</t>
<t tx="ekr.20080516150804.203">
def __init__(self, parent, name):
    resource = parent.project.get_folder(self._get_child_path(parent, name))
    super(CreateFolder, self).__init__(resource)


</t>
<t tx="ekr.20080516150804.204">class CreateFile(CreateResource):
    """A class to create a file

    See docs for `CreateResource`.
    """
    @others
</t>
<t tx="ekr.20080516150804.205">
def __init__(self, parent, name):
    resource = parent.project.get_file(self._get_child_path(parent, name))
    super(CreateFile, self).__init__(resource)


</t>
<t tx="ekr.20080516150804.206">class RemoveResource(Change):
    """A class to remove a resource

    Fields

    * `resource`: The resource to be removed

    """
    @others
</t>
<t tx="ekr.20080516150804.207">
def __init__(self, resource):
    self.resource = resource
    self.operations = resource.project.operations

</t>
<t tx="ekr.20080516150804.208">@_handle_job_set
def do(self):
    self.operations.remove(self.resource)

</t>
<t tx="ekr.20080516150804.209"># TODO: Undoing remove operations
@_handle_job_set
def undo(self):
    raise NotImplementedError(
        'Undoing `RemoveResource` is not implemented yet.')

</t>
<t tx="ekr.20080516150804.210">def __str__(self):
    return 'Remove &lt;%s&gt;' % (self.resource.path)

</t>
<t tx="ekr.20080516150804.211">def get_changed_resources(self):
    return [self.resource]


</t>
<t tx="ekr.20080516150804.212">def count_changes(change):
    """Counts the number of basic changes a `Change` will make"""
    if isinstance(change, ChangeSet):
        result = 0
        for child in change.changes:
            result += count_changes(child)
        return result
    return 1

</t>
<t tx="ekr.20080516150804.213">def create_job_set(task_handle, change):
    return task_handle.create_jobset(str(change), count_changes(change))


</t>
<t tx="ekr.20080516150804.214">class _ResourceOperations(object):
    @others
</t>
<t tx="ekr.20080516150804.215">
def __init__(self, project, fscommands):
    self.project = project
    self.fscommands = fscommands
    self.direct_commands = rope.base.fscommands.FileSystemCommands()

</t>
<t tx="ekr.20080516150804.216">def _get_fscommands(self, resource):
    if self.project.is_ignored(resource):
        return self.direct_commands
    return self.fscommands

</t>
<t tx="ekr.20080516150804.217">def write_file(self, resource, contents):
    data = rope.base.fscommands.unicode_to_file_data(contents)
    fscommands = self._get_fscommands(resource)
    fscommands.write(resource.real_path, data)
    for observer in list(self.project.observers):
        observer.resource_changed(resource)

</t>
<t tx="ekr.20080516150804.218">def move(self, resource, new_resource):
    fscommands = self._get_fscommands(resource)
    fscommands.move(resource.real_path, new_resource.real_path)
    for observer in list(self.project.observers):
        observer.resource_moved(resource, new_resource)

</t>
<t tx="ekr.20080516150804.219">def create(self, resource):
    if resource.is_folder():
        self._create_resource(resource.path, kind='folder')
    else:
        self._create_resource(resource.path)
    for observer in list(self.project.observers):
        observer.resource_created(resource)

</t>
<t tx="ekr.20080516150804.220">def remove(self, resource):
    fscommands = self._get_fscommands(resource)
    fscommands.remove(resource.real_path)
    for observer in list(self.project.observers):
        observer.resource_removed(resource)

</t>
<t tx="ekr.20080516150804.221">def _create_resource(self, file_name, kind='file'):
    resource_path = self.project._get_resource_path(file_name)
    if os.path.exists(resource_path):
        raise exceptions.RopeError('Resource &lt;%s&gt; already exists'
                                   % resource_path)
    resource = self.project.get_file(file_name)
    if not resource.parent.exists():
        raise exceptions.ResourceNotFoundError(
            'Parent folder of &lt;%s&gt; does not exist' % resource.path)
    fscommands = self._get_fscommands(resource)
    try:
        if kind == 'file':
            fscommands.create_file(resource_path)
        else:
            fscommands.create_folder(resource_path)
    except IOError, e:
        raise exceptions.RopeError(e)


</t>
<t tx="ekr.20080516150804.222">def _get_destination_for_move(resource, destination):
    dest_path = resource.project._get_resource_path(destination)
    if os.path.isdir(dest_path):
        if destination != '':
            return destination + '/' + resource.name
        else:
            return resource.name
    return destination


</t>
<t tx="ekr.20080516150804.223">class ChangeToData(object):
    @others
</t>
<t tx="ekr.20080516150804.224">
def convertChangeSet(self, change):
    description = change.description
    changes = []
    for child in change.changes:
        changes.append(self(child))
    return (description, changes, change.time)

</t>
<t tx="ekr.20080516150804.225">def convertChangeContents(self, change):
    return (change.resource.path, change.new_contents, change.old_contents)

</t>
<t tx="ekr.20080516150804.226">def convertMoveResource(self, change):
    return (change.resource.path, change.new_resource.path)

</t>
<t tx="ekr.20080516150804.227">def convertCreateResource(self, change):
    return (change.resource.path, change.resource.is_folder())

</t>
<t tx="ekr.20080516150804.228">def convertRemoveResource(self, change):
    return (change.resource.path, change.resource.is_folder())

</t>
<t tx="ekr.20080516150804.229">def __call__(self, change):
    change_type = type(change)
    if change_type in (CreateFolder, CreateFile):
        change_type = CreateResource
    method = getattr(self, 'convert' + change_type.__name__)
    return (change_type.__name__, method(change))


</t>
<t tx="ekr.20080516150804.230">class DataToChange(object):
    @others
</t>
<t tx="ekr.20080516150804.231">
def __init__(self, project):
    self.project = project

</t>
<t tx="ekr.20080516150804.232">def makeChangeSet(self, description, changes, time=None):
    result = ChangeSet(description, time)
    for child in changes:
        result.add_change(self(child))
    return result

</t>
<t tx="ekr.20080516150804.233">def makeChangeContents(self, path, new_contents, old_contents):
    resource = self.project.get_file(path)
    return ChangeContents(resource, new_contents, old_contents)

</t>
<t tx="ekr.20080516150804.234">def makeMoveResource(self, old_path, new_path):
    resource = self.project.get_file(old_path)
    return MoveResource(resource, new_path, exact=True)

</t>
<t tx="ekr.20080516150804.235">def makeCreateResource(self, path, is_folder):
    if is_folder:
        resource = self.project.get_folder(path)
    else:
        resource = self.project.get_file(path)
    return CreateResource(resource)

</t>
<t tx="ekr.20080516150804.236">def makeRemoveResource(self, path, is_folder):
    if is_folder:
        resource = self.project.get_folder(path)
    else:
        resource = self.project.get_file(path)
    return RemoveResource(resource)

</t>
<t tx="ekr.20080516150804.237">def __call__(self, data):
    method = getattr(self, 'make' + data[0])
    return method(*data[1])
</t>
<t tx="ekr.20080516150804.238">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.239">import bisect
import re
import token
import tokenize


</t>
<t tx="ekr.20080516150804.240">class ChangeCollector(object):
    @others
</t>
<t tx="ekr.20080516150804.241">
def __init__(self, text):
    self.text = text
    self.changes = []

</t>
<t tx="ekr.20080516150804.242">def add_change(self, start, end, new_text=None):
    if new_text is None:
        new_text = self.text[start:end]
    self.changes.append((start, end, new_text))

</t>
<t tx="ekr.20080516150804.243">def get_changed(self):
    if not self.changes:
        return None
    def compare_changes(change1, change2):
        return cmp(change1[:2], change2[:2])
    self.changes.sort(compare_changes)
    pieces = []
    last_changed = 0
    for change in self.changes:
        start, end, text = change
        pieces.append(self.text[last_changed:start] + text)
        last_changed = end
    if last_changed &lt; len(self.text):
        pieces.append(self.text[last_changed:])
    result = ''.join(pieces)
    if result != self.text:
        return result


</t>
<t tx="ekr.20080516150804.244">class Lines(object):
    @others
</t>
<t tx="ekr.20080516150804.245">
def get_line(self, line_number):
    pass

</t>
<t tx="ekr.20080516150804.246">def length(self):
    pass


</t>
<t tx="ekr.20080516150804.247">class SourceLinesAdapter(Lines):
    """Adapts source to Lines interface

    Note: The creation of this class is expensive.
    """
    @others
</t>
<t tx="ekr.20080516150804.248">
def __init__(self, source_code):
    self.code = source_code
    self.starts = None
    self._initialize_line_starts()

</t>
<t tx="ekr.20080516150804.249">def _initialize_line_starts(self):
    self.starts = []
    self.starts.append(0)
    try:
        i = 0
        while True:
            i = self.code.index('\n', i) + 1
            self.starts.append(i)
    except ValueError:
        pass
    self.starts.append(len(self.code) + 1)

</t>
<t tx="ekr.20080516150804.250">def get_line(self, lineno):
    return self.code[self.starts[lineno - 1]:
                     self.starts[lineno] - 1]

</t>
<t tx="ekr.20080516150804.251">def length(self):
    return len(self.starts) - 1

</t>
<t tx="ekr.20080516150804.252">def get_line_number(self, offset):
    return bisect.bisect(self.starts, offset)

</t>
<t tx="ekr.20080516150804.253">def get_line_start(self, lineno):
    return self.starts[lineno - 1]

</t>
<t tx="ekr.20080516150804.254">def get_line_end(self, lineno):
    return self.starts[lineno] - 1


</t>
<t tx="ekr.20080516150804.255">class ArrayLinesAdapter(Lines):
    @others
</t>
<t tx="ekr.20080516150804.256">
def __init__(self, lines):
    self.lines = lines

</t>
<t tx="ekr.20080516150804.257">def get_line(self, line_number):
    return self.lines[line_number - 1]

</t>
<t tx="ekr.20080516150804.258">def length(self):
    return len(self.lines)


</t>
<t tx="ekr.20080516150804.259">class LinesToReadline(object):
    @others
</t>
<t tx="ekr.20080516150804.260">
def __init__(self, lines, start):
    self.lines = lines
    self.current = start

</t>
<t tx="ekr.20080516150804.261">def readline(self):
    if self.current &lt;= self.lines.length():
        self.current += 1
        return self.lines.get_line(self.current - 1) + '\n'
    return ''

</t>
<t tx="ekr.20080516150804.262">def __call__(self):
    return self.readline()


</t>
<t tx="ekr.20080516150804.263">class _CustomGenerator(object):
    """A method object for finding the range of a statement"""
    @others
</t>
<t tx="ekr.20080516150804.264">
def __init__(self, lines):
    self.lines = lines
    self.in_string = ''
    self.open_count = 0
    self.continuation = False

</t>
<t tx="ekr.20080516150804.265">def __call__(self):
    size = self.lines.length()
    result = []
    i = 1
    while i &lt;= size:
        while i &lt;= size and not self.lines.get_line(i).strip():
            i += 1
        if i &lt;= size:
            start = i
            while True:
                line = self.lines.get_line(i)
                self._analyze_line(line)
                if not (self.continuation or self.open_count or
                        self.in_string) or i == size:
                    break
                i += 1
            result.append((start, i))
            i += 1
    return result

</t>
<t tx="ekr.20080516150804.266">_main_chars = re.compile(r'[\'|"|#|\\|\[|\]|\{|\}|\(|\)]')
def _analyze_line(self, line):
    char = None
    for match in self._main_chars.finditer(line):
        char = match.group()
        i = match.start()
        if char in '\'"':
            if not self.in_string:
                self.in_string = char
                if char * 3 == line[i:i + 3]:
                    self.in_string = char * 3
            elif self.in_string == line[i:i + len(self.in_string)] and \
                 not (i &gt; 0 and line[i - 1] == '\\' and
                      not (i &gt; 1 and line[i - 2] == '\\')):
                self.in_string = ''
        if self.in_string:
            continue
        if char == '#':
            break
        if char in '([{':
            self.open_count += 1
        elif char in ')]}':
            self.open_count -= 1
    if line and char != '#' and line.endswith('\\'):
        self.continuation = True
    else:
        self.continuation = False

</t>
<t tx="ekr.20080516150804.267">def custom_generator(lines):
    return _CustomGenerator(lines)()


</t>
<t tx="ekr.20080516150804.268">class LogicalLineFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.269">
def __init__(self, lines):
    self.lines = lines

</t>
<t tx="ekr.20080516150804.270">def logical_line_in(self, line_number):
    indents = count_line_indents(self.lines.get_line(line_number))
    tries = 0
    while True:
        block_start = get_block_start(self.lines, line_number, indents)
        try:
            return self._block_logical_line(block_start, line_number)
        except IndentationError, e:
            tries += 1
            if tries == 5:
                raise e
            lineno = e.lineno + block_start - 1
            indents = count_line_indents(self.lines.get_line(lineno))

</t>
<t tx="ekr.20080516150804.271">def generate_starts(self, start_line=1, end_line=None):
    for start, end in self.generate_regions(start_line, end_line):
        yield start

</t>
<t tx="ekr.20080516150804.272">def generate_regions(self, start_line=1, end_line=None):
    # XXX: `block_start` should be at a better position!
    block_start = 1
    readline = LinesToReadline(self.lines, block_start)
    shifted = start_line - block_start + 1
    try:
        for start, end in self._logical_lines(readline):
            real_start = start + block_start - 1
            real_start = self._first_non_blank(real_start)
            if end_line is not None and real_start &gt;= end_line:
                break
            real_end = end + block_start - 1
            if real_start &gt;= start_line:
                yield (real_start, real_end)
    except tokenize.TokenError, e:
        pass

</t>
<t tx="ekr.20080516150804.273">def _block_logical_line(self, block_start, line_number):
    readline = LinesToReadline(self.lines, block_start)
    shifted = line_number - block_start + 1
    region = self._calculate_logical(readline, shifted)
    start = self._first_non_blank(region[0] + block_start - 1)
    if region[1] is None:
        end = self.lines.length()
    else:
        end = region[1] + block_start - 1
    return start, end

</t>
<t tx="ekr.20080516150804.274">def _calculate_logical(self, readline, line_number):
    last_end = 1
    try:
        for start, end in self._logical_lines(readline):
            if line_number &lt;= end:
                return (start, end)
            last_end = end + 1
    except tokenize.TokenError, e:
        current = e.args[1][0]
        return (last_end, max(last_end, current - 1))
    return (last_end, None)

</t>
<t tx="ekr.20080516150804.275">def _logical_lines(self, readline):
    last_end = 1
    for current_token in tokenize.generate_tokens(readline):
        current = current_token[2][0]
        if current_token[0] == token.NEWLINE:
            yield (last_end, current)
            last_end = current + 1

</t>
<t tx="ekr.20080516150804.276">def _first_non_blank(self, line_number):
    current = line_number
    while current &lt; self.lines.length():
        line = self.lines.get_line(current).strip()
        if line and not line.startswith('#'):
            return current
        current += 1
    return current


</t>
<t tx="ekr.20080516150804.277">def tokenizer_generator(lines):
    return LogicalLineFinder(lines).generate_regions()


</t>
<t tx="ekr.20080516150804.278">class CachingLogicalLineFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.279">
def __init__(self, lines, generate=custom_generator):
    self.lines = lines
    self._generate = generate

</t>
<t tx="ekr.20080516150804.280">_starts = None
@property
def starts(self):
    if self._starts is None:
        self._init_logicals()
    return self._starts

</t>
<t tx="ekr.20080516150804.281">_ends = None
@property
def ends(self):
    if self._ends is None:
        self._init_logicals()
    return self._ends

</t>
<t tx="ekr.20080516150804.282">def _init_logicals(self):
    """Should initialize _starts and _ends attributes"""
    size = self.lines.length() + 1
    self._starts = [None] * size
    self._ends = [None] * size
    for start, end in self._generate(self.lines):
        self._starts[start] = True
        self._ends[end] = True

</t>
<t tx="ekr.20080516150804.283">def logical_line_in(self, line_number):
    start = line_number
    while start &gt; 0 and not self.starts[start]:
        start -= 1
    if start == 0:
        try:
            start = self.starts.index(True, line_number)
        except ValueError:
            return (line_number, line_number)
    return (start, self.ends.index(True, start))

</t>
<t tx="ekr.20080516150804.284">def generate_starts(self, start_line=1, end_line=None):
    if end_line is None:
        end_line = self.lines.length()
    for index in range(start_line, end_line):
        if self.starts[index]:
            yield index


</t>
<t tx="ekr.20080516150804.285">def get_block_start(lines, lineno, maximum_indents=80):
    """Approximate block start"""
    pattern = get_block_start_patterns()
    for i in range(lineno, 0, -1):
        match = pattern.search(lines.get_line(i))
        if match is not None and \
           count_line_indents(lines.get_line(i)) &lt;= maximum_indents:
            striped = match.string.lstrip()
            # Maybe we're in a list comprehension or generator expression
            if i &gt; 1 and striped.startswith('if') or striped.startswith('for'):
                bracs = 0
                for j in range(i, min(i + 5, lines.length() + 1)):
                    for c in lines.get_line(j):
                        if c == '#':
                            break
                        if c in '[(':
                            bracs += 1
                        if c in ')]':
                            bracs -= 1
                            if bracs &lt; 0:
                                break
                    if bracs &lt; 0:
                        break
                if bracs &lt; 0:
                    continue
            return i
    return 1


</t>
<t tx="ekr.20080516150804.286">_block_start_pattern = None

def get_block_start_patterns():
    global _block_start_pattern
    if not _block_start_pattern:
        pattern = '^\\s*(((def|class|if|elif|except|for|while|with)\\s)|'\
                  '((try|else|finally|except)\\s*:))'
        _block_start_pattern = re.compile(pattern, re.M)
    return _block_start_pattern


</t>
<t tx="ekr.20080516150804.287">def count_line_indents(line):
    indents = 0
    for char in line:
        if char == ' ':
            indents += 1
        elif char == '\t':
            indents += 8
        else:
            return indents
    return 0


</t>
<t tx="ekr.20080516150804.288">def get_string_pattern():
    start = r'(\b[uU]?[rR]?)?'
    longstr = r'%s"""(\\.|"(?!"")|\\\n|[^"\\])*"""' % start
    shortstr = r'%s"(\\.|[^"\\\n])*"' % start
    return '|'.join([longstr, longstr.replace('"', "'"),
                     shortstr, shortstr.replace('"', "'")])

</t>
<t tx="ekr.20080516150804.289">def get_comment_pattern():
    return r'#[^\n]*'
</t>
<t tx="ekr.20080516150804.290">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.291"># The default ``config.py``


def set_prefs(prefs):
    """This function is called before opening the project"""

    # Specify which files and folders to ignore in the project.
    # Changes to ignored resources are not added to the history and
    # VCSs.  Also they are not returned in `Project.get_files()`.
    # Note that ``?`` and ``*`` match all characters but slashes.
    # '*.pyc': matches 'test.pyc' and 'pkg/test.pyc'
    # 'mod*.pyc': matches 'test/mod1.pyc' but not 'mod/1.pyc'
    # '.svn': matches 'pkg/.svn' and all of its children
    # 'build/*.o': matches 'build/lib.o' but not 'build/sub/lib.o'
    # 'build//*.o': matches 'build/lib.o' and 'build/sub/lib.o'
    prefs['ignored_resources'] = ['*.pyc', '*~', '.ropeproject',
                                  '.hg', '.svn', '_svn', '.git']

    # Specifies which files should be considered python files.  It is
    # useful when you have scripts inside your project.  Only files
    # ending with ``.py`` are considered to be python files by
    # default.
    #prefs['python_files'] = ['*.py']

    # Custom source folders:  By default rope searches the project
    # for finding source folders (folders that should be searched
    # for finding modules).  You can add paths to that list.  Note
    # that rope guesses project source folders correctly most of the
    # time; use this if you have any problems.
    # The folders should be relative to project root and use '/' for
    # separating folders regardless of the platform rope is running on.
    # 'src/my_source_folder' for instance.
    #prefs.add('source_folders', 'src')

    # You can extend python path for looking up modules
    #prefs.add('python_path', '~/python/')

    # Should rope save object information or not.
    prefs['save_objectdb'] = True
    prefs['compress_objectdb'] = False

    # If `True`, rope analyzes each module when it is being saved.
    prefs['automatic_soa'] = True
    # The depth of calls to follow in static object analysis
    prefs['soa_followed_calls'] = 0

    # If `False` when running modules or unit tests "dynamic object
    # analysis" is turned off.  This makes them much faster.
    prefs['perform_doa'] = True

    # Rope can check the validity of its object DB when running.
    prefs['validate_objectdb'] = True

    # How many undos to hold?
    prefs['max_history_items'] = 32

    # Shows whether to save history across sessions.
    prefs['save_history'] = True
    prefs['compress_history'] = False

    # Set the number spaces used for indenting.  According to
    # :PEP:`8`, it is best to use 4 spaces.  Since most of rope's
    # unit-tests use 4 spaces it is more reliable, too.
    prefs['indent_size'] = 4

    # Builtin and c-extension modules that are allowed to be imported
    # and inspected by rope.
    prefs['extension_modules'] = [
        'array', 'binascii', 'cmath', 'bz2', 'collections', 'cPickle', 'crypt',
        'cStringIO', 'datetime', 'errno', 'exceptions', 'gc', 'grp', 'imp',
        'itertools', 'marshal', 'math', 'mmap', 'nt', 'operator', 'posix',
        'pwd', 'select', 'signal', 'sys', 'thread', 'unicodedata', 'zlib',
        'zipimport']

    # If `True` modules with syntax errors are considered to be empty.
    # The default value is `False`; When `False` syntax errors raise
    # `rope.base.exceptions.ModuleSyntaxError` exception.
    prefs['ignore_syntax_errors'] = False

    # If `True`, rope ignores unresolvable imports.  Otherwise, they
    # appear in the importing namespace.
    prefs['ignore_bad_imports'] = False


</t>
<t tx="ekr.20080516150804.292">def project_opened(project):
    """This function is called after opening the project"""
    # Do whatever you like here!
</t>
<t tx="ekr.20080516150804.293">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.294">import rope.base.builtins
import rope.base.pynames
import rope.base.pyobjects
from rope.base import ast, astutils, exceptions, pyobjects, arguments, worder


BadIdentifierError = exceptions.BadIdentifierError

</t>
<t tx="ekr.20080516150804.295">def get_primary_and_pyname_at(pymodule, offset):
    """Find the primary and pyname at offset"""
    pyname_finder = ScopeNameFinder(pymodule)
    return pyname_finder.get_primary_and_pyname_at(offset)


</t>
<t tx="ekr.20080516150804.296">def get_pyname_at(pymodule, offset):
    """Find the pyname at the offset"""
    return get_primary_and_pyname_at(pymodule, offset)[1]


</t>
<t tx="ekr.20080516150804.297">def get_statement_result(scope, node):
    """Evaluate a `ast.AST` node and return a PyName

    Return `None` if the expression cannot be evaluated.

    """
    return get_primary_and_result(scope, node)[1]


</t>
<t tx="ekr.20080516150804.298">def get_primary_and_result(scope, node):
    evaluator = StatementEvaluator(scope)
    ast.walk(node, evaluator)
    return evaluator.old_result, evaluator.result


</t>
<t tx="ekr.20080516150804.299">def get_pyname_in_scope(holding_scope, name):
    return get_primary_and_pyname_in_scope(holding_scope, name)[1]


</t>
<t tx="ekr.20080516150804.300">def get_primary_and_pyname_in_scope(holding_scope, name):
    try:
        # parenthesizing for handling cases like 'a_var.\nattr'
        node = ast.parse('(%s)' % name)
    except SyntaxError:
        raise BadIdentifierError('Not a resolvable python identifier selected.')
    return get_primary_and_result(holding_scope, node)


</t>
<t tx="ekr.20080516150804.301">def get_string_result(scope, string):
    """use `get_pyname_in_scope` instead"""
    evaluator = StatementEvaluator(scope)
    node = ast.parse(string)
    ast.walk(node, evaluator)
    return evaluator.result


</t>
<t tx="ekr.20080516150804.302">class ScopeNameFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.303">
def __init__(self, pymodule):
    self.source_code = pymodule.source_code
    self.module_scope = pymodule.get_scope()
    self.lines = pymodule.lines
    self.word_finder = worder.Worder(self.source_code, True)

</t>
<t tx="ekr.20080516150804.304">def _is_defined_in_class_body(self, holding_scope, offset, lineno):
    if lineno == holding_scope.get_start() and \
       holding_scope.parent is not None and \
       holding_scope.parent.get_kind() == 'Class' and \
       self.word_finder.is_a_class_or_function_name_in_header(offset):
        return True
    if lineno != holding_scope.get_start() and \
       holding_scope.get_kind() == 'Class' and \
       self.word_finder.is_name_assigned_in_class_body(offset):
        return True
    return False

</t>
<t tx="ekr.20080516150804.305">def _is_function_name_in_function_header(self, scope, offset, lineno):
    if scope.get_start() &lt;= lineno &lt;= scope.get_body_start() and \
       scope.get_kind() == 'Function' and \
       self.word_finder.is_a_class_or_function_name_in_header(offset):
        return True
    return False

</t>
<t tx="ekr.20080516150804.306">def get_pyname_at(self, offset):
    return self.get_primary_and_pyname_at(offset)[1]

</t>
<t tx="ekr.20080516150804.307">def get_primary_and_pyname_at(self, offset):
    lineno = self.lines.get_line_number(offset)
    holding_scope = self.module_scope.get_inner_scope_for_line(lineno)
    # function keyword parameter
    if self.word_finder.is_function_keyword_parameter(offset):
        keyword_name = self.word_finder.get_word_at(offset)
        pyobject = self.get_enclosing_function(offset)
        if isinstance(pyobject, pyobjects.PyFunction):
            return (None, pyobject.get_parameters().get(keyword_name, None))

    # class body
    if self._is_defined_in_class_body(holding_scope, offset, lineno):
        class_scope = holding_scope
        if lineno == holding_scope.get_start():
            class_scope = holding_scope.parent
        name = self.word_finder.get_primary_at(offset).strip()
        try:
            return (None, class_scope.pyobject[name])
        except rope.base.exceptions.AttributeNotFoundError:
            return (None, None)
    # function header
    if self._is_function_name_in_function_header(holding_scope, offset, lineno):
        name = self.word_finder.get_primary_at(offset).strip()
        return (None, holding_scope.parent[name])
    # from statement module
    if self.word_finder.is_from_statement_module(offset):
        module = self.word_finder.get_primary_at(offset)
        module_pyname = self._find_module(module)
        return (None, module_pyname)
    if self.word_finder.is_from_aliased(offset):
        name = self.word_finder.get_from_aliased(offset)
    else:
        name = self.word_finder.get_primary_at(offset)
    return get_primary_and_pyname_in_scope(holding_scope, name)

</t>
<t tx="ekr.20080516150804.308">def get_enclosing_function(self, offset):
    function_parens = self.word_finder.find_parens_start_from_inside(offset)
    try:
        function_pyname = self.get_pyname_at(function_parens - 1)
    except BadIdentifierError:
        function_pyname = None
    if function_pyname is not None:
        pyobject = function_pyname.get_object()
        if isinstance(pyobject, pyobjects.AbstractFunction):
            return pyobject
        elif isinstance(pyobject, pyobjects.AbstractClass) and \
             '__init__' in pyobject:
            return pyobject['__init__'].get_object()
        elif '__call__' in pyobject:
            return pyobject['__call__'].get_object()
    return None

</t>
<t tx="ekr.20080516150804.309">def _find_module(self, module_name):
    dots = 0
    while module_name[dots] == '.':
        dots += 1
    return rope.base.pynames.ImportedModule(
        self.module_scope.pyobject, module_name[dots:], dots)


</t>
<t tx="ekr.20080516150804.310">class StatementEvaluator(object):
    @others
</t>
<t tx="ekr.20080516150804.311">
def __init__(self, scope):
    self.scope = scope
    self.result = None
    self.old_result = None

</t>
<t tx="ekr.20080516150804.312">def _Name(self, node):
    self.result = self.scope.lookup(node.id)

</t>
<t tx="ekr.20080516150804.313">def _Attribute(self, node):
    pyname = get_statement_result(self.scope, node.value)
    if pyname is None:
        pyname = rope.base.pynames.UnboundName()
    self.old_result = pyname
    if pyname.get_object() != rope.base.pyobjects.get_unknown():
        try:
            self.result = pyname.get_object()[node.attr]
        except exceptions.AttributeNotFoundError:
            self.result = None

</t>
<t tx="ekr.20080516150804.314">def _Call(self, node):
    primary, pyobject = self._get_primary_and_object_for_node(node.func)
    if pyobject is None:
        return
    def _get_returned(pyobject):
        args = arguments.create_arguments(primary, pyobject,
                                          node, self.scope)
        return pyobject.get_returned_object(args)
    if isinstance(pyobject, rope.base.pyobjects.AbstractClass):
        result = None
        if '__new__' in pyobject:
            new_function = pyobject['__new__'].get_object()
            result = _get_returned(new_function)
        if result is None or \
           result == rope.base.pyobjects.get_unknown():
            result = rope.base.pyobjects.PyObject(pyobject)
        self.result = rope.base.pynames.UnboundName(pyobject=result)
        return

    pyfunction = None
    if isinstance(pyobject, rope.base.pyobjects.AbstractFunction):
        pyfunction = pyobject
    elif '__call__' in pyobject:
        pyfunction = pyobject['__call__'].get_object()
    if pyfunction is not None:
        self.result = rope.base.pynames.UnboundName(
            pyobject=_get_returned(pyfunction))

</t>
<t tx="ekr.20080516150804.315">def _Str(self, node):
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_str())

</t>
<t tx="ekr.20080516150804.316">def _Num(self, node):
    type_name = type(node.n).__name__
    self.result = self._get_builtin_name(type_name)

</t>
<t tx="ekr.20080516150804.317">def _get_builtin_name(self, type_name):
    pytype = rope.base.builtins.builtins[type_name].get_object()
    return rope.base.pynames.UnboundName(
        rope.base.pyobjects.PyObject(pytype))

</t>
<t tx="ekr.20080516150804.318">def _BinOp(self, node):
    self.result = rope.base.pynames.UnboundName(
        self._get_object_for_node(node.left))

</t>
<t tx="ekr.20080516150804.319">def _BoolOp(self, node):
    self.result = rope.base.pynames.UnboundName(
        self._get_object_for_node(node.values[0]))

</t>
<t tx="ekr.20080516150804.320">def _Repr(self, node):
    self.result = self._get_builtin_name('str')

</t>
<t tx="ekr.20080516150804.321">def _UnaryOp(self, node):
    self.result = rope.base.pynames.UnboundName(
        self._get_object_for_node(node.operand))

</t>
<t tx="ekr.20080516150804.322">def _Compare(self, node):
    self.result = self._get_builtin_name('bool')

</t>
<t tx="ekr.20080516150804.323">def _Dict(self, node):
    keys = None
    values = None
    if node.keys:
        keys = self._get_object_for_node(node.keys[0])
        values = self._get_object_for_node(node.values[0])
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_dict(keys, values))

</t>
<t tx="ekr.20080516150804.324">def _List(self, node):
    holding = None
    if node.elts:
        holding = self._get_object_for_node(node.elts[0])
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_list(holding))

</t>
<t tx="ekr.20080516150804.325">def _ListComp(self, node):
    pyobject = self._what_does_comprehension_hold(node)
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_list(pyobject))

</t>
<t tx="ekr.20080516150804.326">def _GeneratorExp(self, node):
    pyobject = self._what_does_comprehension_hold(node)
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_iterator(pyobject))

</t>
<t tx="ekr.20080516150804.327">def _what_does_comprehension_hold(self, node):
    scope = self._make_comprehension_scope(node)
    pyname = get_statement_result(scope, node.elt)
    return pyname.get_object() if pyname is not None else None

</t>
<t tx="ekr.20080516150804.328">def _make_comprehension_scope(self, node):
    scope = self.scope
    module = scope.pyobject.get_module()
    names = {}
    for comp in node.generators:
        new_names = _get_evaluated_names(
            comp.target, comp.iter, module,
            '.__iter__().next()', node.lineno)
        names.update(new_names)
    return rope.base.pyscopes.TemporaryScope(scope.pycore, scope, names)

</t>
<t tx="ekr.20080516150804.329">def _Tuple(self, node):
    objects = []
    if len(node.elts) &lt; 4:
        for stmt in node.elts:
            pyobject = self._get_object_for_node(stmt)
            objects.append(pyobject)
    else:
        objects.append(self._get_object_for_node(node.elts[0]))
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.get_tuple(*objects))

</t>
<t tx="ekr.20080516150804.330">def _get_object_for_node(self, stmt):
    pyname = get_statement_result(self.scope, stmt)
    pyobject = None
    if pyname is not None:
        pyobject = pyname.get_object()
    return pyobject

</t>
<t tx="ekr.20080516150804.331">def _get_primary_and_object_for_node(self, stmt):
    primary, pyname = get_primary_and_result(self.scope, stmt)
    pyobject = None
    if pyname is not None:
        pyobject = pyname.get_object()
    return primary, pyobject

</t>
<t tx="ekr.20080516150804.332">def _Subscript(self, node):
    if isinstance(node.slice, ast.Index):
        self._call_function(node.value, '__getitem__',
                            [node.slice.value])
    elif isinstance(node.slice, ast.Slice):
        self._call_function(node.value, '__getslice__')

</t>
<t tx="ekr.20080516150804.333">def _call_function(self, node, function_name, other_args=None):
    pyname = get_statement_result(self.scope, node)
    if pyname is not None:
        pyobject = pyname.get_object()
    else:
        return
    if function_name in pyobject:
        call_function = pyobject[function_name].get_object()
        args = [node]
        if other_args:
            args += other_args
        arguments_ = arguments.Arguments(args, self.scope)
        self.result = rope.base.pynames.UnboundName(
            pyobject=call_function.get_returned_object(arguments_))

</t>
<t tx="ekr.20080516150804.334">def _Lambda(self, node):
    self.result = rope.base.pynames.UnboundName(
        pyobject=rope.base.builtins.Lambda(node, self.scope))


</t>
<t tx="ekr.20080516150804.335">def _get_evaluated_names(targets, assigned, module, evaluation, lineno):
    result = {}
    for name, levels in astutils.get_name_levels(targets):
        assignment = rope.base.pynames.AssignmentValue(assigned, levels,
                                                       evaluation)
        # XXX: this module should not access `rope.base.pynamesdef`!
        pyname = rope.base.pynamesdef.AssignedName(lineno, module)
        pyname.assignments.append(assignment)
        result[name] = pyname
    return result
</t>
<t tx="ekr.20080516150804.336">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.337">class RopeError(Exception):
    """Base exception for rope"""


</t>
<t tx="ekr.20080516150804.338">class ResourceNotFoundError(RopeError):
    """Resource not found exception"""


</t>
<t tx="ekr.20080516150804.339">class RefactoringError(RopeError):
    """Errors for performing a refactoring"""


</t>
<t tx="ekr.20080516150804.340">class InterruptedTaskError(RopeError):
    """Errors for performing a refactoring"""


</t>
<t tx="ekr.20080516150804.341">class HistoryError(RopeError):
    """Errors for history undo/redo operations"""


</t>
<t tx="ekr.20080516150804.342">class ModuleNotFoundError(RopeError):
    """Module not found exception"""


</t>
<t tx="ekr.20080516150804.343">class AttributeNotFoundError(RopeError):
    """Attribute not found exception"""


</t>
<t tx="ekr.20080516150804.344">class NameNotFoundError(RopeError):
    """Attribute not found exception"""


</t>
<t tx="ekr.20080516150804.345">class BadIdentifierError(RopeError):
    """The name cannot be resolved"""


</t>
<t tx="ekr.20080516150804.346">class ModuleSyntaxError(RopeError):
    """Module has syntax errors

    The `filename` and `lineno` fields indicate where the error has
    occurred.

    """
    @others
</t>
<t tx="ekr.20080516150804.347">
def __init__(self, filename, lineno, message):
    self.filename = filename
    self.lineno = lineno
    self.message_ = message
    super(ModuleSyntaxError, self).__init__(
        'Syntax error in file &lt;%s&gt; line &lt;%s&gt;: %s' %
        (filename, lineno, message))


</t>
<t tx="ekr.20080516150804.348">class ModuleDecodeError(RopeError):
    """Cannot decode module"""
    @others
</t>
<t tx="ekr.20080516150804.349">
def __init__(self, filename, message):
    self.filename = filename
    self.message_ = message
    super(ModuleDecodeError, self).__init__(
        'Cannot decode file &lt;%s&gt;: %s' % (filename, message))
</t>
<t tx="ekr.20080516150804.350">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.351">"""Project file system commands.

This modules implements file system operations used by rope.  Different
version control systems can be supported by implementing the interface
provided by `FileSystemCommands` class.  See `SubversionCommands` and
`MercurialCommands` for example.

"""
import os
import shutil
import subprocess


</t>
<t tx="ekr.20080516150804.352">def create_fscommands(root):
    dirlist = os.listdir(root)
    commands = {'.hg': MercurialCommands,
                '.svn': SubversionCommands,
                '.git': GITCommands,
                '_svn': SubversionCommands}
    for key in commands:
        if key in dirlist:
            try:
                return commands[key](root)
            except (ImportError, OSError):
                pass
    return FileSystemCommands()


</t>
<t tx="ekr.20080516150804.353">class FileSystemCommands(object):
    @others
</t>
<t tx="ekr.20080516150804.354">
def create_file(self, path):
    open(path, 'w').close()

</t>
<t tx="ekr.20080516150804.355">def create_folder(self, path):
    os.mkdir(path)

</t>
<t tx="ekr.20080516150804.356">def move(self, path, new_location):
    shutil.move(path, new_location)

</t>
<t tx="ekr.20080516150804.357">def remove(self, path):
    if os.path.isfile(path):
        os.remove(path)
    else:
        shutil.rmtree(path)

</t>
<t tx="ekr.20080516150804.358">def write(self, path, data):
    file_ = open(path, 'wb')
    try:
        file_.write(data)
    finally:
        file_.close()


</t>
<t tx="ekr.20080516150804.359">class SubversionCommands(object):
    @others
</t>
<t tx="ekr.20080516150804.360">
def __init__(self, *args):
    self.normal_actions = FileSystemCommands()
    import pysvn
    self.client = pysvn.Client()

</t>
<t tx="ekr.20080516150804.361">def create_file(self, path):
    self.normal_actions.create_file(path)
    self.client.add(path, force=True)

</t>
<t tx="ekr.20080516150804.362">def create_folder(self, path):
    self.normal_actions.create_folder(path)
    self.client.add(path, force=True)

</t>
<t tx="ekr.20080516150804.363">def move(self, path, new_location):
    self.client.move(path, new_location, force=True)

</t>
<t tx="ekr.20080516150804.364">def remove(self, path):
    self.client.remove(path, force=True)

</t>
<t tx="ekr.20080516150804.365">def write(self, path, data):
    self.normal_actions.write(path, data)


</t>
<t tx="ekr.20080516150804.366">class MercurialCommands(object):
    @others
</t>
<t tx="ekr.20080516150804.367">
def __init__(self, root):
    self.hg = self._import_mercurial()
    self.normal_actions = FileSystemCommands()
    self.ui = self.hg.ui.ui(
        verbose=False, debug=False, quiet=True,
        interactive=False, traceback=False, report_untrusted=False)
    self.repo = self.hg.hg.repository(self.ui, root)

</t>
<t tx="ekr.20080516150804.368">def _import_mercurial(self):
    import mercurial.commands
    import mercurial.hg
    import mercurial.ui
    return mercurial

</t>
<t tx="ekr.20080516150804.369">def create_file(self, path):
    self.normal_actions.create_file(path)
    self.hg.commands.add(self.ui, self.repo, path)

</t>
<t tx="ekr.20080516150804.370">def create_folder(self, path):
    self.normal_actions.create_folder(path)

</t>
<t tx="ekr.20080516150804.371">def move(self, path, new_location):
    self.hg.commands.rename(self.ui, self.repo, path,
                            new_location, after=False)

</t>
<t tx="ekr.20080516150804.372">def remove(self, path):
    self.hg.commands.remove(self.ui, self.repo, path)

</t>
<t tx="ekr.20080516150804.373">def write(self, path, data):
    self.normal_actions.write(path, data)


</t>
<t tx="ekr.20080516150804.374">class GITCommands(object):
    @others
</t>
<t tx="ekr.20080516150804.375">
def __init__(self, root):
    self.root = root
    self._do(['version'])
    self.normal_actions = FileSystemCommands()

</t>
<t tx="ekr.20080516150804.376">def create_file(self, path):
    self.normal_actions.create_file(path)
    self._do(['add', self._in_dir(path)])

</t>
<t tx="ekr.20080516150804.377">def create_folder(self, path):
    self.normal_actions.create_folder(path)

</t>
<t tx="ekr.20080516150804.378">def move(self, path, new_location):
    self._do(['mv', self._in_dir(path), self._in_dir(new_location)])

</t>
<t tx="ekr.20080516150804.379">def remove(self, path):
    self._do(['rm', self._in_dir(path)])

</t>
<t tx="ekr.20080516150804.380">def write(self, path, data):
    # XXX: should we use ``git add``?
    self.normal_actions.write(path, data)

</t>
<t tx="ekr.20080516150804.381">def _do(self, args):
    _execute(['git'] + args, cwd=self.root)

</t>
<t tx="ekr.20080516150804.382">def _in_dir(self, path):
    if path.startswith(self.root):
        return path[len(self.root) + 1:]
    return self.root


</t>
<t tx="ekr.20080516150804.383">def _execute(args, cwd=None):
    process = subprocess.Popen(args, cwd=cwd, stdout=subprocess.PIPE)
    process.wait()
    return process.returncode


</t>
<t tx="ekr.20080516150804.384">def unicode_to_file_data(contents, encoding=None):
    if not isinstance(contents, unicode):
        return contents
    if encoding is None:
        encoding = read_str_coding(contents)
    if encoding is not None:
        return contents.encode(encoding)
    try:
        return contents.encode()
    except UnicodeEncodeError:
        return contents.encode('utf-8')

</t>
<t tx="ekr.20080516150804.385">def file_data_to_unicode(data, encoding=None):
    result = _decode_data(data, encoding)
    if '\r\n' in result:
        return result.replace('\r\n', '\n')
    return result

</t>
<t tx="ekr.20080516150804.386">def _decode_data(data, encoding):
    if encoding is None:
        encoding = read_str_coding(data)
    if encoding is not None:
        return unicode(data, encoding)
    try:
        return unicode(data)
    except UnicodeDecodeError:
        # Using ``utf-8`` if guessed encoding fails
        return unicode(data, 'utf-8')


</t>
<t tx="ekr.20080516150804.387">def read_file_coding(path):
    file = open(path, 'b')
    count = 0
    result = []
    buffsize = 10
    while True:
        current = file.read(10)
        if not current:
            break
        count += current.count('\n')
        result.append(current)
    file.close()
    return _find_coding(''.join(result))


</t>
<t tx="ekr.20080516150804.388">def read_str_coding(source):
    try:
        first = source.index('\n') + 1
        second = source.index('\n', first) + 1
    except ValueError:
        second = len(source)
    return _find_coding(source[:second])


</t>
<t tx="ekr.20080516150804.389">def _find_coding(first_two_lines):
    coding = 'coding'
    try:
        start = first_two_lines.index(coding) + len(coding)
        while start &lt; len(first_two_lines):
            if first_two_lines[start] not in '=: \t':
                break
            start += 1
        end = start
        while end &lt; len(first_two_lines):
            c = first_two_lines[end]
            if not c.isalnum() and c not in '-_':
                break
            end += 1
        return first_two_lines[start:end]
    except ValueError:
        pass
</t>
<t tx="ekr.20080516150804.390">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.391">from rope.base import exceptions, change, taskhandle


</t>
<t tx="ekr.20080516150804.392">class History(object):
    """A class that holds project history"""
    @others
</t>
<t tx="ekr.20080516150804.393">
def __init__(self, project, maxundos=None):
    self.project = project
    self._undo_list = []
    self._redo_list = []
    self._maxundos = maxundos
    self._load_history()
    self.project.data_files.add_write_hook(self.write)
    self.current_change = None

</t>
<t tx="ekr.20080516150804.394">def _load_history(self):
    if self.save:
        result = self.project.data_files.read_data(
            'history', compress=self.compress, import_=True)
        if result is not None:
            to_change = change.DataToChange(self.project)
            for data in result[0]:
                self._undo_list.append(to_change(data))
            for data in result[1]:
                self._redo_list.append(to_change(data))

</t>
<t tx="ekr.20080516150804.395">def do(self, changes, task_handle=taskhandle.NullTaskHandle()):
    """Perform the change and add it to the `self.undo_list`

    Note that uninteresting changes (changes to ignored files)
    will not be appended to `self.undo_list`.

    """
    self.current_change = changes
    try:
        changes.do(change.create_job_set(task_handle, changes))
    finally:
        self.current_change = None
    if self._is_change_interesting(changes):
        self.undo_list.append(changes)
        self._remove_extra_items()
    del self.redo_list[:]

</t>
<t tx="ekr.20080516150804.396">def _remove_extra_items(self):
    if len(self.undo_list) &gt; self.max_undos:
        del self.undo_list[0:len(self.undo_list) - self.max_undos]

</t>
<t tx="ekr.20080516150804.397">def _is_change_interesting(self, changes):
    for resource in changes.get_changed_resources():
        if not self.project.is_ignored(resource):
            return True
    return False

</t>
<t tx="ekr.20080516150804.398">def undo(self, change=None, task_handle=taskhandle.NullTaskHandle()):
    """Redo done changes from the history

    When `change` is `None`, the last done change will be undone.
    If change is not `None` it should be an item from
    `self.undo_list`; this change and all changes that depend on
    it will be undone.  In both cases the list of undone changes
    will be returned.

    """
    if not self._undo_list:
        raise exceptions.HistoryError('Undo list is empty')
    if change is None:
        change = self.undo_list[-1]
    dependencies = self._find_dependencies(self.undo_list, change)
    self._move_front(self.undo_list, dependencies)
    index = self.undo_list.index(change)
    self._perform_undos(len(dependencies), task_handle)
    return self.redo_list[-len(dependencies):]

</t>
<t tx="ekr.20080516150804.399">def redo(self, change=None, task_handle=taskhandle.NullTaskHandle()):
    """Redo undone changes from the history

    When `change` is `None`, the last undone change will be
    redone.  If change is not `None` it should be an item from
    `self.redo_list`; this change and all changes that depend on
    it will be redone.  In both cases the list of redone changes
    will be returned.

    """
    if not self.redo_list:
        raise exceptions.HistoryError('Redo list is empty')
    if change is None:
        change = self.redo_list[-1]
    dependencies = self._find_dependencies(self.redo_list, change)
    self._move_front(self.redo_list, dependencies)
    index = self.redo_list.index(change)
    self._perform_redos(len(dependencies), task_handle)
    return self.undo_list[-len(dependencies):]

</t>
<t tx="ekr.20080516150804.400">def _move_front(self, change_list, changes):
    for change in changes:
        change_list.remove(change)
        change_list.append(change)

</t>
<t tx="ekr.20080516150804.401">def _find_dependencies(self, change_list, change):
    index = change_list.index(change)
    return _FindChangeDependencies(change_list[index:]).\
           find_dependencies()

</t>
<t tx="ekr.20080516150804.402">def _perform_undos(self, count, task_handle):
    for i in range(count):
        self.current_change = self.undo_list[-1]
        try:
            job_set = change.create_job_set(task_handle,
                                            self.current_change)
            self.current_change.undo(job_set)
        finally:
            self.current_change = None
        self.redo_list.append(self.undo_list.pop())

</t>
<t tx="ekr.20080516150804.403">def _perform_redos(self, count, task_handle):
    for i in range(count):
        self.current_change = self.redo_list[-1]
        try:
            job_set = change.create_job_set(task_handle,
                                            self.current_change)
            self.current_change.do(job_set)
        finally:
            self.current_change = None
        self.undo_list.append(self.redo_list.pop())

</t>
<t tx="ekr.20080516150804.404">def contents_before_current_change(self, file):
    if self.current_change is None:
        return None
    result = self._search_for_change_contents([self.current_change], file)
    if result is not None:
        return result
    if file.exists() and not file.is_folder():
        return file.read()
    else:
        return None

</t>
<t tx="ekr.20080516150804.405">def _search_for_change_contents(self, change_list, file):
    for change_ in reversed(change_list):
        if isinstance(change_, change.ChangeSet):
            result = self._search_for_change_contents(change_.changes,
                                                      file)
            if result is not None:
                return result
        if isinstance(change_, change.ChangeContents) and \
           change_.resource == file:
            return change_.old_contents

</t>
<t tx="ekr.20080516150804.406">def write(self):
    if self.save:
        data = []
        to_data = change.ChangeToData()
        self._remove_extra_items()
        data.append([to_data(change_) for change_ in self.undo_list])
        data.append([to_data(change_) for change_ in self.redo_list])
        self.project.data_files.write_data('history', data,
                                           compress=self.compress)

</t>
<t tx="ekr.20080516150804.407">def get_file_undo_list(self, resource):
    result = []
    for change in self.undo_list:
        if resource in change.get_changed_resources():
            result.append(change)
    return result

</t>
<t tx="ekr.20080516150804.408">def __str__(self):
    return 'History holds %s changes in memory' % \
           (len(self.undo_list) + len(self.redo_list))

</t>
<t tx="ekr.20080516150804.409">undo_list = property(lambda self: self._undo_list)
redo_list = property(lambda self: self._redo_list)

@property
def tobe_undone(self):
    """The last done change if available, `None` otherwise"""
    if self.undo_list:
        return self.undo_list[-1]

</t>
<t tx="ekr.20080516150804.410">@property
def tobe_redone(self):
    """The last undone change if available, `None` otherwise"""
    if self.redo_list:
        return self.redo_list[-1]

</t>
<t tx="ekr.20080516150804.411">@property
def max_undos(self):
    if self._maxundos is None:
        return self.project.prefs.get('max_history_items', 100)
    else:
        return self._maxundos

</t>
<t tx="ekr.20080516150804.412">@property
def save(self):
    return self.project.prefs.get('save_history', False)

</t>
<t tx="ekr.20080516150804.413">@property
def compress(self):
    return self.project.prefs.get('compress_history', False)

</t>
<t tx="ekr.20080516150804.414">def clear(self):
    """Forget all undo and redo information"""
    del self.undo_list[:]
    del self.redo_list[:]


</t>
<t tx="ekr.20080516150804.415">class _FindChangeDependencies(object):
    @others
</t>
<t tx="ekr.20080516150804.416">
def __init__(self, change_list):
    self.change = change_list[0]
    self.change_list = change_list
    self.changed_resources = set(self.change.get_changed_resources())

</t>
<t tx="ekr.20080516150804.417">def find_dependencies(self):
    result = [self.change]
    for change in self.change_list[1:]:
        if self._depends_on(change, result):
            result.append(change)
            self.changed_resources.update(change.get_changed_resources())
    return result

</t>
<t tx="ekr.20080516150804.418">def _depends_on(self, changes, result):
    for resource in changes.get_changed_resources():
        if resource is None:
            continue
        if resource in self.changed_resources:
            return True
        for changed in self.changed_resources:
            if resource.is_folder() and resource.contains(changed):
                return True
            if changed.is_folder() and changed.contains(resource):
                return True
    return False
</t>
<t tx="ekr.20080516150804.419">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.420">"""A few useful functions for using rope as a library"""
import os.path

import rope.base.project
import rope.base.pycore
from rope.base import taskhandle


</t>
<t tx="ekr.20080516150804.421">def path_to_resource(project, path, type=None):
    """Get the resource at path

    You only need to specify `type` if `path` does not exist.  It can
    be either 'file' or 'folder'.  If the type is `None` it is assumed
    that the resource already exists.

    Note that this function uses `Project.get_resource()`,
    `Project.get_file()`, and `Project.get_folder()` methods.

    """
    path = rope.base.project._realpath(path)
    project_path = path
    if path == project.address or path.startswith(project.address + os.sep):
        project_path = path[len(project.address):].lstrip('/' + os.sep)
    else:
        project = rope.base.project.get_no_project()
    if type is None:
        return project.get_resource(project_path)
    if type == 'file':
        return project.get_file(project_path)
    if type == 'folder':
        return project.get_folder(project_path)
    return None


</t>
<t tx="ekr.20080516150804.422">def report_change(project, path, old_content):
    """Report that the contents of file at `path` was changed

    The new contents of file is retrieved by reading the file.

    """
    resource = path_to_resource(project, path)
    if resource is None:
        return
    for observer in list(project.observers):
        observer.resource_changed(resource)
    if project.pycore.automatic_soa:
        rope.base.pycore.perform_soa_on_changed_scopes(project, resource,
                                                       old_content)

</t>
<t tx="ekr.20080516150804.423">def analyze_modules(project, task_handle=taskhandle.NullTaskHandle()):
    """Perform static object analysis on all python files in the project

    Note that this might be really time consuming.
    """
    resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Analyzing Modules', len(resources))
    for resource in resources:
        job_set.started_job(resource.path)
        project.pycore.analyze_module(resource)
        job_set.finished_job()
</t>
<t tx="ekr.20080516150804.424">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.425">class Prefs(object):
    @others
</t>
<t tx="ekr.20080516150804.426">
def __init__(self):
    self.prefs = {}
    self.callbacks = {}

</t>
<t tx="ekr.20080516150804.427">def set(self, key, value):
    """Set the value of `key` preference to `value`."""
    if key in self.callbacks:
        self.callbacks[key](value)
    else:
        self.prefs[key] = value

</t>
<t tx="ekr.20080516150804.428">def add(self, key, value):
    """Add an entry to a list preference

    Add `value` to the list of entries for the `key` preference.

    """
    if not key in self.prefs:
        self.prefs[key] = []
    self.prefs[key].append(value)

</t>
<t tx="ekr.20080516150804.429">def get(self, key, default=None):
    """Get the value of the key preference"""
    return self.prefs.get(key, default)

</t>
<t tx="ekr.20080516150804.430">def add_callback(self, key, callback):
    """Add `key` preference with `callback` function
    
    Whenever `key` is set the callback is called with the
    given `value` as parameter.

    """
    self.callbacks[key] = callback

</t>
<t tx="ekr.20080516150804.431">def __setitem__(self, key, value):
    self.set(key, value)

</t>
<t tx="ekr.20080516150804.432">def __getitem__(self, key):
    return self.get(key)
</t>
<t tx="ekr.20080516150804.433">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.434">import cPickle as pickle
import os
import shutil
import warnings

import rope.base.change
import rope.base.fscommands
from rope.base import exceptions, taskhandle, prefs, history, pycore
from rope.base.resourceobserver import *
from rope.base.resources import File, Folder, _ResourceMatcher


</t>
<t tx="ekr.20080516150804.435">class _Project(object):
    @others
    history = property(_get_history)
    pycore = property(get_pycore)
    ropefolder = None


</t>
<t tx="ekr.20080516150804.436">
def __init__(self, fscommands):
    self.observers = []
    self._history = None
    self.operations = rope.base.change._ResourceOperations(self, fscommands)
    self.prefs = prefs.Prefs()
    self._pycore = None
    self.data_files = _DataFiles(self)

</t>
<t tx="ekr.20080516150804.437">def get_resource(self, resource_name):
    """Get a resource in a project.

    `resource_name` is the path of a resource in a project.  It is
    the path of a resource relative to project root.  Project root
    folder address is an empty string.  If the resource does not
    exist a `exceptions.ResourceNotFound` exception would be
    raised.  Use `get_file()` and `get_folder()` when you need to
    get non- existent `Resource`\s.

    """
    path = self._get_resource_path(resource_name)
    if not os.path.exists(path):
        raise exceptions.ResourceNotFoundError(
            'Resource &lt;%s&gt; does not exist' % resource_name)
    elif os.path.isfile(path):
        return File(self, resource_name)
    elif os.path.isdir(path):
        return Folder(self, resource_name)
    else:
        raise exceptions.ResourceNotFoundError('Unknown resource '
                                               + resource_name)

</t>
<t tx="ekr.20080516150804.438">def validate(self, folder):
    """Validate files and folders contained in this folder

    It validates all of the files and folders contained in this
    folder if some observers are interested in them.

    """
    for observer in list(self.observers):
        observer.validate(folder)

</t>
<t tx="ekr.20080516150804.439">def add_observer(self, observer):
    """Register a `ResourceObserver`

    See `FilteredResourceObserver`.
    """
    self.observers.append(observer)

</t>
<t tx="ekr.20080516150804.440">def remove_observer(self, observer):
    """Remove a registered `ResourceObserver`"""
    if observer in self.observers:
        self.observers.remove(observer)

</t>
<t tx="ekr.20080516150804.441">def do(self, changes, task_handle=taskhandle.NullTaskHandle()):
    """Apply the changes in a `ChangeSet`

    Most of the time you call this function for committing the
    changes for a refactoring.
    """
    self.history.do(changes, task_handle=task_handle)

</t>
<t tx="ekr.20080516150804.442">def get_pycore(self):
    if self._pycore is None:
        self._pycore = pycore.PyCore(self)
    return self._pycore

</t>
<t tx="ekr.20080516150804.443">def get_file(self, path):
    """Get the file with `path` (it may not exist)"""
    return File(self, path)

</t>
<t tx="ekr.20080516150804.444">def get_folder(self, path):
    """Get the folder with `path` (it may not exist)"""
    return Folder(self, path)

</t>
<t tx="ekr.20080516150804.445">def is_ignored(self, resource):
    return False

</t>
<t tx="ekr.20080516150804.446">def get_prefs(self):
    return self.prefs

</t>
<t tx="ekr.20080516150804.447">def _get_resource_path(self, name):
    pass

</t>
<t tx="ekr.20080516150804.448">def _get_history(self):
    if self._history is None:
        self._history = history.History(self)
    return self._history

</t>
<t tx="ekr.20080516150804.449">def close(self):
    warnings.warn('Cannot close a NoProject',
                  DeprecationWarning, stacklevel=2)

</t>
<t tx="ekr.20080516150804.450">class Project(_Project):
    """A Project containing files and folders"""
    @others
    root = property(lambda self: self.get_resource(''))
    address = property(lambda self: self._address)


</t>
<t tx="ekr.20080516150804.451">
def __init__(self, projectroot, fscommands=None,
             ropefolder='.ropeproject', **prefs):
    """A rope project

    :parameters:
        - `projectroot`: The address of the root folder of the project
        - `fscommands`: Implements the file system operations rope uses
          have a look at `rope.base.fscommands`
        - `ropefolder`: The name of the folder in which rope stores
          project configurations and data.  Pass `None` for not using
          such a folder at all.
        - `prefs`: Specify project preferences.  These values
          overwrite config file preferences.

    """
    if projectroot != '/':
        projectroot = _realpath(projectroot).rstrip('/\\')
    self._address = projectroot
    self._ropefolder_name = ropefolder
    if not os.path.exists(self._address):
        os.mkdir(self._address)
    elif not os.path.isdir(self._address):
        raise exceptions.RopeError('Project root exists and'
                                   ' is not a directory')
    if fscommands is None:
        fscommands = rope.base.fscommands.create_fscommands(self._address)
    super(Project, self).__init__(fscommands)
    self.ignored = _ResourceMatcher()
    self.file_list = _FileListCacher(self)
    self.prefs.add_callback('ignored_resources', self.ignored.set_patterns)
    if ropefolder is not None:
        self.prefs['ignored_resources'] = [ropefolder]
    self._init_prefs(prefs)

</t>
<t tx="ekr.20080516150804.452">def get_files(self):
    return self.file_list.get_files()

</t>
<t tx="ekr.20080516150804.453">def _get_resource_path(self, name):
    return os.path.join(self._address, *name.split('/'))

</t>
<t tx="ekr.20080516150804.454">def _init_ropefolder(self):
    if self.ropefolder is not None:
        if not self.ropefolder.exists():
            self.ropefolder.create()
        if not self.ropefolder.has_child('config.py'):
            config = self.ropefolder.create_file('config.py')
            config.write(self._default_config())

</t>
<t tx="ekr.20080516150804.455">def _init_prefs(self, prefs):
    run_globals = {}
    if self.ropefolder is not None:
        config = self.get_file(self.ropefolder.path + '/config.py')
        run_globals.update({'__name__': '__main__',
                            '__builtins__': __builtins__,
                            '__file__': config.real_path})
        if config.exists():
            config = self.ropefolder.get_child('config.py')
            execfile(config.real_path, run_globals)
        else:
            exec(self._default_config(), run_globals)
        if 'set_prefs' in run_globals:
            run_globals['set_prefs'](self.prefs)
    for key, value in prefs.items():
        self.prefs[key] = value
    self._init_other_parts()
    self._init_ropefolder()
    if 'project_opened' in run_globals:
        run_globals['project_opened'](self)

</t>
<t tx="ekr.20080516150804.456">def _default_config(self):
    import rope.base.default_config
    import inspect
    return inspect.getsource(rope.base.default_config)

</t>
<t tx="ekr.20080516150804.457">def _init_other_parts(self):
    # Forcing the creation of `self.pycore` to register observers
    self.pycore

</t>
<t tx="ekr.20080516150804.458">def is_ignored(self, resource):
    return self.ignored.does_match(resource)

</t>
<t tx="ekr.20080516150804.459">def sync(self):
    """Closes project open resources"""
    self.close()

</t>
<t tx="ekr.20080516150804.460">def close(self):
    """Closes project open resources"""
    self.data_files.write()

</t>
<t tx="ekr.20080516150804.461">def set(self, key, value):
    """Set the `key` preference to `value`"""
    self.prefs.set(key, value)

</t>
<t tx="ekr.20080516150804.462">@property
def ropefolder(self):
    if self._ropefolder_name is not None:
        return self.get_folder(self._ropefolder_name)

</t>
<t tx="ekr.20080516150804.463">def validate(self, folder=None):
    if folder is None:
        folder = self.root
    super(Project, self).validate(folder)

</t>
<t tx="ekr.20080516150804.464">class NoProject(_Project):
    """A null object for holding out of project files.

    This class is singleton use `get_no_project` global function
    """
    @others
    _no_project = None


</t>
<t tx="ekr.20080516150804.465">
def __init__(self):
    fscommands = rope.base.fscommands.FileSystemCommands()
    super(NoProject, self).__init__(fscommands)

</t>
<t tx="ekr.20080516150804.466">def _get_resource_path(self, name):
    real_name = name.replace('/', os.path.sep)
    return _realpath(real_name)

</t>
<t tx="ekr.20080516150804.467">def get_resource(self, name):
    universal_name = _realpath(name).replace(os.path.sep, '/')
    return super(NoProject, self).get_resource(universal_name)

</t>
<t tx="ekr.20080516150804.468">def get_files(self):
    return []

</t>
<t tx="ekr.20080516150804.469">def get_no_project():
    if NoProject._no_project is None:
        NoProject._no_project = NoProject()
    return NoProject._no_project


</t>
<t tx="ekr.20080516150804.470">class _FileListCacher(object):
    @others
</t>
<t tx="ekr.20080516150804.471">
def __init__(self, project):
    self.project = project
    self.needs_gc = True
    self._observer = None
    self.files = set()
    self.folders = set()

</t>
<t tx="ekr.20080516150804.472">def get_files(self):
    if self.needs_gc:
        # forcing the creation of the observer
        self.observer
        for file in list(self.files):
            if not file.exists():
                self.files.remove(file)
        for folder in list(self.folders):
            if not folder.exists():
                self.folders.remove(folder)
                self.observer.remove_resource(folder)
        self.needs_gc = False
    return self.files

</t>
<t tx="ekr.20080516150804.473">@property
def observer(self):
    if self._observer is None:
        self._init_observer()
        self._update_folder(self.project.root)
    return self._observer

</t>
<t tx="ekr.20080516150804.474">def _updated_resources(self, folder):
    if not folder.exists():
        return set(), set()
    files = set()
    folders = set([folder])
    files.update(folder.get_files())
    for child in folder.get_folders():
        if child not in self.folders:
            newfiles, newfolders = self._updated_resources(child)
            files.update(newfiles)
            folders.update(newfolders)
    return files, folders

</t>
<t tx="ekr.20080516150804.475">def _update_folder(self, folder):
    files, folders = self._updated_resources(folder)
    self.files.update(files)
    for child in folders - self.folders:
        self.folders.add(child)
        self.observer.add_resource(child)
    self.needs_gc = True

</t>
<t tx="ekr.20080516150804.476">def _init_observer(self):
    self.rawobserver = ResourceObserver(
        self._changed, self._moved, self._created,
        self._removed, self._validate)
    self._observer = FilteredResourceObserver(self.rawobserver)
    self.project.add_observer(self._observer)

</t>
<t tx="ekr.20080516150804.477">def _changed(self, resource):
    if resource.is_folder():
        self._update_folder(resource)

</t>
<t tx="ekr.20080516150804.478">def _moved(self, resource, new_resource):
    if resource.is_folder():
        self._update_folder(resource)
        self._update_folder(new_resource)
    else:
        self._removed(resource)
        self._created(new_resource)

</t>
<t tx="ekr.20080516150804.479">def _created(self, resource):
    if resource.is_folder():
        self._update_folder(resource)
    else:
        if not self.project.is_ignored(resource):
            self.files.add(resource)

</t>
<t tx="ekr.20080516150804.480">def _removed(self, resource):
    if resource.is_folder():
        self._update_folder(resource)
    else:
        if resource in self.files:
            self.files.remove(resource)

</t>
<t tx="ekr.20080516150804.481">def _validate(self, resource):
    pass


</t>
<t tx="ekr.20080516150804.482">class _DataFiles(object):
    @others
</t>
<t tx="ekr.20080516150804.483">
def __init__(self, project):
    self.project = project
    self.hooks = []

</t>
<t tx="ekr.20080516150804.484">def read_data(self, name, compress=False, import_=False):
    if self.project.ropefolder is None:
        return None
    compress = compress and self._can_compress()
    opener = self._get_opener(compress)
    file = self._get_file(name, compress)
    if not compress and import_:
        self._import_old_files(name)
    if file.exists():
        input = opener(file.real_path, 'rb')
        try:
            result = []
            try:
                while True:
                    result.append(pickle.load(input))
            except EOFError:
                pass
            if len(result) == 1:
                return result[0]
            if len(result) &gt; 1:
                return result
        finally:
            input.close()

</t>
<t tx="ekr.20080516150804.485">def write_data(self, name, data, compress=False):
    if self.project.ropefolder is not None:
        compress = compress and self._can_compress()
        file = self._get_file(name, compress)
        opener = self._get_opener(compress)
        output = opener(file.real_path, 'wb')
        try:
            pickle.dump(data, output, 2)
        finally:
            output.close()

</t>
<t tx="ekr.20080516150804.486">def add_write_hook(self, hook):
    self.hooks.append(hook)

</t>
<t tx="ekr.20080516150804.487">def write(self):
    for hook in self.hooks:
        hook()

</t>
<t tx="ekr.20080516150804.488">def _can_compress(self):
    try:
        import gzip
        return True
    except ImportError:
        return False

</t>
<t tx="ekr.20080516150804.489">def _import_old_files(self, name):
    old = self._get_file(name + '.pickle', False)
    new = self._get_file(name, False)
    if old.exists() and not new.exists():
        shutil.move(old.real_path, new.real_path)

</t>
<t tx="ekr.20080516150804.490">def _get_opener(self, compress):
    if compress:
        try:
            import gzip
            return gzip.open
        except ImportError:
            pass
    return open

</t>
<t tx="ekr.20080516150804.491">def _get_file(self, name, compress):
    path = self.project.ropefolder.path + '/' + name
    if compress:
        path += '.gz'
    return self.project.get_file(path)


</t>
<t tx="ekr.20080516150804.492">def _realpath(path):
    """Return the real path of `path`

    Is equivalent to ``realpath(abspath(expanduser(path)))``.

    """
    return os.path.realpath(os.path.abspath(os.path.expanduser(path)))
</t>
<t tx="ekr.20080516150804.493">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.494">import bisect
import difflib
import sys
import warnings

import rope.base.oi.doa
import rope.base.oi.objectinfo
import rope.base.oi.soa
from rope.base import ast, exceptions, taskhandle
from rope.base.exceptions import ModuleNotFoundError
from rope.base.pyobjectsdef import PyModule, PyPackage, PyClass
import rope.base.resources
import rope.base.resourceobserver
from rope.base import builtins


</t>
<t tx="ekr.20080516150804.495">class PyCore(object):
    @others
</t>
<t tx="ekr.20080516150804.496">
def __init__(self, project):
    self.project = project
    self._init_resource_observer()
    self.cache_observers = []
    self.module_cache = _ModuleCache(self)
    self.extension_cache = _ExtensionCache(self)
    self.object_info = rope.base.oi.objectinfo.ObjectInfoManager(project)
    self._init_python_files()
    self._init_automatic_soa()
    self._init_source_folders()

</t>
<t tx="ekr.20080516150804.497">def _init_python_files(self):
    self.python_matcher = None
    patterns = self.project.prefs.get('python_files', None)
    if patterns is not None:
        self.python_matcher = rope.base.resources._ResourceMatcher()
        self.python_matcher.set_patterns(patterns)

</t>
<t tx="ekr.20080516150804.498">def _init_resource_observer(self):
    callback = self._invalidate_resource_cache
    observer = rope.base.resourceobserver.ResourceObserver(
        changed=callback, moved=callback, removed=callback)
    self.observer = rope.base.resourceobserver.FilteredResourceObserver(observer)
    self.project.add_observer(self.observer)

</t>
<t tx="ekr.20080516150804.499">def _init_source_folders(self):
    self._custom_source_folders = []
    for path in self.project.prefs.get('source_folders', []):
        self._custom_source_folders.append(path)

</t>
<t tx="ekr.20080516150804.500">def _init_automatic_soa(self):
    if not self.automatic_soa:
        return
    callback = self._file_changed_for_soa
    observer = rope.base.resourceobserver.ResourceObserver(
        changed=callback, moved=callback, removed=callback)
    self.project.add_observer(observer)

</t>
<t tx="ekr.20080516150804.501">@property
def automatic_soa(self):
    auto_soa = self.project.prefs.get('automatic_soi', None)
    return self.project.prefs.get('automatic_soa', auto_soa)

</t>
<t tx="ekr.20080516150804.502">def _file_changed_for_soa(self, resource, new_resource=None):
    old_contents = self.project.history.\
                   contents_before_current_change(resource)
    if old_contents is not None:
        perform_soa_on_changed_scopes(self.project, resource, old_contents)

</t>
<t tx="ekr.20080516150804.503">def is_python_file(self, resource):
    if resource.is_folder():
        return False
    if self.python_matcher is None:
        return resource.name.endswith('.py')
    return self.python_matcher.does_match(resource)

</t>
<t tx="ekr.20080516150804.504">def get_module(self, name, current_folder=None):
    """Returns a `PyObject` if the module was found."""
    module = self.find_module(name, current_folder)
    if module is None:
        module = self._builtin_module(name)
        if module is None:
            raise ModuleNotFoundError('Module %s not found' % name)
        return module
    return self.resource_to_pyobject(module)

</t>
<t tx="ekr.20080516150804.505">def _builtin_module(self, name):
    return self.extension_cache.get_pymodule(name)

</t>
<t tx="ekr.20080516150804.506">def get_relative_module(self, name, current_folder, level):
    module = self.find_relative_module(name, current_folder, level)
    if module is None:
        raise ModuleNotFoundError('Module %s not found' % name)
    return self.resource_to_pyobject(module)

</t>
<t tx="ekr.20080516150804.507">def get_string_module(self, module_content, resource=None,
                      force_errors=False):
    """Returns a `PyObject` object for the given module_content

    If `force_errors` is `True`, `exceptions.ModuleSyntaxError` is
    raised if module has syntax errors.  This overrides
    ``ignore_syntax_errors`` project config.

    """
    return PyModule(self, module_content, resource,
                    force_errors=force_errors)

</t>
<t tx="ekr.20080516150804.508">def get_string_scope(self, module_content, resource=None):
    """Returns a `Scope` object for the given module_content"""
    return self.get_string_module(module_content, resource).get_scope()

</t>
<t tx="ekr.20080516150804.509">def _invalidate_resource_cache(self, resource, new_resource=None):
    for observer in self.cache_observers:
        observer(resource)

</t>
<t tx="ekr.20080516150804.510">def _find_module_in_source_folder(self, source_folder, module_name):
    result = []
    module = source_folder
    packages = module_name.split('.')
    for pkg in packages[:-1]:
        if  module.is_folder() and module.has_child(pkg):
            module = module.get_child(pkg)
            result.append(module)
        else:
            return None
    if not module.is_folder():
        return None

    if module.has_child(packages[-1]) and \
       module.get_child(packages[-1]).is_folder():
        result.append(module.get_child(packages[-1]))
        return result
    elif module.has_child(packages[-1] + '.py') and \
         not module.get_child(packages[-1] + '.py').is_folder():
        result.append(module.get_child(packages[-1] + '.py'))
        return result
    return None

</t>
<t tx="ekr.20080516150804.511">def get_python_path_folders(self):
    import rope.base.project
    result = []
    for src in self.project.prefs.get('python_path', []) + sys.path:
        try:
            src_folder = rope.base.project.get_no_project().get_resource(src)
            result.append(src_folder)
        except rope.base.exceptions.ResourceNotFoundError:
            pass
    return result

</t>
<t tx="ekr.20080516150804.512">def find_module(self, module_name, current_folder=None):
    """Returns a resource corresponding to the given module

    returns None if it can not be found
    """
    module_resource_list = self._find_module_resource_list(module_name,
                                                           current_folder)
    if module_resource_list is not None:
        return module_resource_list[-1]

</t>
<t tx="ekr.20080516150804.513">def find_relative_module(self, module_name, current_folder, level):
    for i in range(level - 1):
        current_folder = current_folder.parent
    if module_name == '':
        return current_folder
    else:
        module = self._find_module_in_source_folder(current_folder, module_name)
        if module is not None:
            return module[-1]

</t>
<t tx="ekr.20080516150804.514">def _find_module_resource_list(self, module_name, current_folder=None):
    """Returns a list of lists of `Folder`s and `File`s for the given module"""
    for src in self.get_source_folders():
        module = self._find_module_in_source_folder(src, module_name)
        if module is not None:
            return module
    for src in self.get_python_path_folders():
        module = self._find_module_in_source_folder(src, module_name)
        if module is not None:
            return module
    if current_folder is not None:
        module = self._find_module_in_source_folder(current_folder,
                                                    module_name)
        if module is not None:
            return module
    return None

</t>
<t tx="ekr.20080516150804.515"># INFO: It was decided not to cache source folders, since:
#  - Does not take much time when the root folder contains
#    packages, that is most of the time
#  - We need a separate resource observer; `self.observer`
#    does not get notified about module and folder creations
def get_source_folders(self):
    """Returns project source folders"""
    if self.project.root is None:
        return []
    result = list(self._custom_source_folders)
    result.extend(self._find_source_folders(self.project.root))
    return result

</t>
<t tx="ekr.20080516150804.516">def resource_to_pyobject(self, resource, force_errors=False):
    return self.module_cache.get_pymodule(resource, force_errors)

</t>
<t tx="ekr.20080516150804.517">def get_python_files(self):
    """Returns all python files available in the project"""
    return [resource for resource in self.project.get_files()
            if self.is_python_file(resource)]

</t>
<t tx="ekr.20080516150804.518">def _is_package(self, folder):
    if folder.has_child('__init__.py') and \
       not folder.get_child('__init__.py').is_folder():
        return True
    else:
        return False

</t>
<t tx="ekr.20080516150804.519">def _find_source_folders(self, folder):
    for resource in folder.get_folders():
        if self._is_package(resource):
            return [folder]
    result = []
    for resource in folder.get_files():
        if resource.name.endswith('.py'):
            result.append(folder)
            break
    for resource in folder.get_folders():
        result.extend(self._find_source_folders(resource))
    return result

</t>
<t tx="ekr.20080516150804.520">def run_module(self, resource, args=None, stdin=None, stdout=None):
    """Run `resource` module

    Returns a `rope.base.oi.doa.PythonFileRunner` object for
    controlling the process.

    """
    perform_doa = self.project.prefs.get('perform_doi', True)
    perform_doa = self.project.prefs.get('perform_doa', perform_doa)
    receiver = self.object_info.doa_data_received
    if not perform_doa:
        receiver = None
    runner = rope.base.oi.doa.PythonFileRunner(
        self, resource, args, stdin, stdout, receiver)
    runner.add_finishing_observer(self.module_cache.forget_all_data)
    runner.run()
    return runner

</t>
<t tx="ekr.20080516150804.521">def analyze_module(self, resource, should_analyze=lambda py: True,
                   search_subscopes=lambda py: True, followed_calls=None):
    """Analyze `resource` module for static object inference

    This function forces rope to analyze this module to collect
    information about function calls.  `should_analyze` is a
    function that is called with a `PyDefinedObject` argument.  If
    it returns `True` the element is analyzed.  If it is `None` or
    returns `False` the element is not analyzed.

    `search_subscopes` is like `should_analyze`; The difference is
    that if it returns `False` the sub-scopes are not ignored.
    That is it is assumed that `should_analyze` returns `False for
    all of its subscopes.

    `followed_calls` override the value of ``soa_followed_calls``
    project config.
    """
    if followed_calls is None:
        followed_calls = self.project.prefs.get('soa_followed_calls', 0)
    pymodule = self.resource_to_pyobject(resource)
    self.module_cache.forget_all_data()
    rope.base.oi.soa.analyze_module(
        self, pymodule, should_analyze, search_subscopes, followed_calls)

</t>
<t tx="ekr.20080516150804.522">def get_classes(self, task_handle=taskhandle.NullTaskHandle()):
    warnings.warn('`PyCore.get_classes()` is deprecated',
                  DeprecationWarning, stacklevel=2)
    return []

</t>
<t tx="ekr.20080516150804.523">def __str__(self):
    return str(self.module_cache) + str(self.object_info)


</t>
<t tx="ekr.20080516150804.524">class _ModuleCache(object):
    @others
</t>
<t tx="ekr.20080516150804.525">
def __init__(self, pycore):
    self.pycore = pycore
    self.module_map = {}
    self.pycore.cache_observers.append(self._invalidate_resource)
    self.observer = self.pycore.observer

</t>
<t tx="ekr.20080516150804.526">def _invalidate_resource(self, resource):
    if resource in self.module_map:
        self.forget_all_data()
        self.observer.remove_resource(resource)
        del self.module_map[resource]

</t>
<t tx="ekr.20080516150804.527">def get_pymodule(self, resource, force_errors=False):
    if resource in self.module_map:
        return self.module_map[resource]
    if resource.is_folder():
        result = PyPackage(self.pycore, resource,
                           force_errors=force_errors)
    else:
        result = PyModule(self.pycore, resource=resource,
                          force_errors=force_errors)
    self.module_map[resource] = result
    self.observer.add_resource(resource)
    return result

</t>
<t tx="ekr.20080516150804.528">def forget_all_data(self):
    for pymodule in self.module_map.values():
        pymodule._forget_concluded_data()

</t>
<t tx="ekr.20080516150804.529">def __str__(self):
    return 'PyCore caches %d PyModules\n' % len(self.module_map)


</t>
<t tx="ekr.20080516150804.530">class _ExtensionCache(object):
    @others
</t>
<t tx="ekr.20080516150804.531">
def __init__(self, pycore):
    self.project = pycore.project
    self.extensions = {}

</t>
<t tx="ekr.20080516150804.532">def get_pymodule(self, name):
    if name == '__builtin__':
        return builtins.builtins
    if name not in self.extensions and name in self.allowed:
        self.extensions[name] = builtins.BuiltinModule(name)
    return self.extensions.get(name)

</t>
<t tx="ekr.20080516150804.533">@property
def allowed(self):
    return self.project.prefs.get('extension_modules', [])


</t>
<t tx="ekr.20080516150804.534">def perform_soa_on_changed_scopes(project, resource, old_contents):
    pycore = project.pycore
    if resource.exists() and pycore.is_python_file(resource):
        try:
            new_contents = resource.read()
            # detecting changes in new_contents relative to old_contents
            detector = _TextChangeDetector(new_contents, old_contents)
            def search_subscopes(pydefined):
                scope = pydefined.get_scope()
                return detector.is_changed(scope.get_start(), scope.get_end())
            def should_analyze(pydefined):
                scope = pydefined.get_scope()
                start = scope.get_start()
                end = scope.get_end()
                return detector.consume_changes(start, end)
            pycore.analyze_module(resource, should_analyze, search_subscopes)
        except exceptions.ModuleSyntaxError:
            pass


</t>
<t tx="ekr.20080516150804.535">class _TextChangeDetector(object):
    @others
</t>
<t tx="ekr.20080516150804.536">
def __init__(self, old, new):
    self.old = old
    self.new = new
    self._set_diffs()

</t>
<t tx="ekr.20080516150804.537">def _set_diffs(self):
    differ = difflib.Differ()
    self.lines = []
    lineno = 0
    for line in differ.compare(self.old.splitlines(True),
                               self.new.splitlines(True)):
        if line.startswith(' '):
            lineno += 1
        elif line.startswith('-'):
            lineno += 1
            self.lines.append(lineno)

</t>
<t tx="ekr.20080516150804.538">def is_changed(self, start, end):
    """Tell whether any of start till end lines have changed

    The end points are inclusive and indices start from 1.
    """
    left, right = self._get_changed(start, end)
    if left &lt; right:
        return True
    return False

</t>
<t tx="ekr.20080516150804.539">def consume_changes(self, start, end):
    """Clear the changed status of lines from start till end"""
    left, right = self._get_changed(start, end)
    if left &lt; right:
        del self.lines[left:right]
    return left &lt; right

</t>
<t tx="ekr.20080516150804.540">def _get_changed(self, start, end):
    left = bisect.bisect_left(self.lines, start)
    right = bisect.bisect_right(self.lines, end)
    return left, right
</t>
<t tx="ekr.20080516150804.541">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.542">import rope.base.pyobjects
from rope.base import exceptions, utils


</t>
<t tx="ekr.20080516150804.543">class PyName(object):
    """References to `PyObject`\s inside python programs"""
    @others
</t>
<t tx="ekr.20080516150804.544">
def get_object(self):
    """Return the `PyObject` object referenced by this `PyName`"""

</t>
<t tx="ekr.20080516150804.545">def get_definition_location(self):
    """Return a (module, lineno) tuple"""


</t>
<t tx="ekr.20080516150804.546">class DefinedName(PyName):
    @others
</t>
<t tx="ekr.20080516150804.547">
def __init__(self, pyobject):
    self.pyobject = pyobject

</t>
<t tx="ekr.20080516150804.548">def get_object(self):
    return self.pyobject

</t>
<t tx="ekr.20080516150804.549">def get_definition_location(self):
    return (self.pyobject.get_module(), self.pyobject.get_ast().lineno)


</t>
<t tx="ekr.20080516150804.550">class AssignedName(PyName):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.551">class UnboundName(PyName):
    @others
</t>
<t tx="ekr.20080516150804.552">
def __init__(self, pyobject=None):
    self.pyobject = pyobject
    if self.pyobject is None:
        self.pyobject = rope.base.pyobjects.get_unknown()

</t>
<t tx="ekr.20080516150804.553">def get_object(self):
    return self.pyobject

</t>
<t tx="ekr.20080516150804.554">def get_definition_location(self):
    return (None, None)


</t>
<t tx="ekr.20080516150804.555">class AssignmentValue(object):
    """An assigned expression"""
    @others
</t>
<t tx="ekr.20080516150804.556">
def __init__(self, ast_node, levels=None, evaluation='',
             assign_type=False):
    """The `level` is `None` for simple assignments and is
    a list of numbers for tuple assignments for example in::

       a, (b, c) = x

    The levels for for `a` is ``[0]``, for `b` is ``[1, 0]`` and for
    `c` is ``[1, 1]``.

    """
    self.ast_node = ast_node
    if levels == None:
        self.levels = []
    else:
        self.levels = levels
    self.evaluation = evaluation
    self.assign_type = assign_type

</t>
<t tx="ekr.20080516150804.557">def get_lineno(self):
    return self.ast_node.lineno


</t>
<t tx="ekr.20080516150804.558">class EvaluatedName(PyName):
    """A name whose object will be evaluated later"""
    @others
</t>
<t tx="ekr.20080516150804.559">
def __init__(self, callback, module=None, lineno=None):
    self.module = module
    self.lineno = lineno
    self.callback = callback
    self.pyobject = _Inferred(callback, _get_concluded_data(module))

</t>
<t tx="ekr.20080516150804.560">def get_object(self):
    return self.pyobject.get()

</t>
<t tx="ekr.20080516150804.561">def get_definition_location(self):
    return (self.module, self.lineno)

</t>
<t tx="ekr.20080516150804.562">def invalidate(self):
    """Forget the `PyObject` this `PyName` holds"""
    self.pyobject.set(None)


</t>
<t tx="ekr.20080516150804.563">class ParameterName(PyName):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.564">class ImportedModule(PyName):
    @others
</t>
<t tx="ekr.20080516150804.565">
def __init__(self, importing_module, module_name=None,
             level=0, resource=None):
    self.importing_module = importing_module
    self.module_name = module_name
    self.level = level
    self.resource = resource
    self.pymodule = _get_concluded_data(self.importing_module)

</t>
<t tx="ekr.20080516150804.566">def _current_folder(self):
    resource = self.importing_module.get_module().get_resource()
    if resource is None:
        return None
    return resource.parent

</t>
<t tx="ekr.20080516150804.567">def _get_pymodule(self):
    if self.pymodule.get() is None:
        pycore = self.importing_module.pycore
        if self.resource is not None:
            self.pymodule.set(pycore.resource_to_pyobject(self.resource))
        elif self.module_name is not None:
            try:
                if self.level == 0:
                    pymodule = pycore.get_module(self.module_name,
                                                 self._current_folder())
                else:
                    pymodule = pycore.get_relative_module(
                        self.module_name, self._current_folder(), self.level)
                self.pymodule.set(pymodule)
            except exceptions.ModuleNotFoundError:
                pass
    return self.pymodule.get()

</t>
<t tx="ekr.20080516150804.568">def get_object(self):
    if self._get_pymodule() is None:
        return rope.base.pyobjects.get_unknown()
    return self._get_pymodule()

</t>
<t tx="ekr.20080516150804.569">def get_definition_location(self):
    pymodule = self._get_pymodule()
    if not isinstance(pymodule, rope.base.pyobjects.PyDefinedObject):
        return (None, None)
    return (pymodule.get_module(), 1)


</t>
<t tx="ekr.20080516150804.570">class ImportedName(PyName):
    @others
</t>
<t tx="ekr.20080516150804.571">
def __init__(self, imported_module, imported_name):
    self.imported_module = imported_module
    self.imported_name = imported_name

</t>
<t tx="ekr.20080516150804.572">def _get_imported_pyname(self):
    try:
        result = self.imported_module.get_object()[self.imported_name]
        if result != self:
            return result
    except exceptions.AttributeNotFoundError:
        pass
    return UnboundName()

</t>
<t tx="ekr.20080516150804.573">@utils.prevent_recursion(rope.base.pyobjects.get_unknown)
def get_object(self):
    return self._get_imported_pyname().get_object()

</t>
<t tx="ekr.20080516150804.574">@utils.prevent_recursion(lambda: (None, None))
def get_definition_location(self):
    return self._get_imported_pyname().get_definition_location()


</t>
<t tx="ekr.20080516150804.575">def _get_concluded_data(module):
    if module is None:
        return rope.base.pyobjects._ConcludedData()
    return module._get_concluded_data()


</t>
<t tx="ekr.20080516150804.576">def _circular_inference():
    raise rope.base.pyobjects.IsBeingInferredError(
        'Circular Object Inference')

</t>
<t tx="ekr.20080516150804.577">class _Inferred(object):
    @others
</t>
<t tx="ekr.20080516150804.578">
def __init__(self, get_inferred, concluded=None):
    self.get_inferred = get_inferred
    self.concluded = concluded
    if self.concluded is None:
        self.temp = None

</t>
<t tx="ekr.20080516150804.579">@utils.prevent_recursion(_circular_inference)
def get(self, *args, **kwds):
    if self.concluded is None or self.concluded.get() is None:
        self.set(self.get_inferred(*args, **kwds))
    if self._get() is None:
        self.set(rope.base.pyobjects.get_unknown())
    return self._get()

</t>
<t tx="ekr.20080516150804.580">def set(self, pyobject):
    if self.concluded is not None:
        self.concluded.set(pyobject)
    self.temp = pyobject

</t>
<t tx="ekr.20080516150804.581">def _get(self):
    if self.concluded is not None:
        return self.concluded.get()
    return self.temp
</t>
<t tx="ekr.20080516150804.582">@language python
@tabwidth -4
@others
_Inferred = pynames._Inferred
</t>
<t tx="ekr.20080516150804.583">import rope.base.oi.soi
from rope.base import pynames
from rope.base.pynames import *


</t>
<t tx="ekr.20080516150804.584">class AssignedName(pynames.AssignedName):
    @others
</t>
<t tx="ekr.20080516150804.585">
def __init__(self, lineno=None, module=None, pyobject=None):
    self.lineno = lineno
    self.module = module
    self.assignments = []
    self.pyobject = _Inferred(self._get_inferred,
                              pynames._get_concluded_data(module))
    self.pyobject.set(pyobject)

</t>
<t tx="ekr.20080516150804.586">def _get_inferred(self):
    if self.module is not None:
        return rope.base.oi.soi.infer_assigned_object(self)

</t>
<t tx="ekr.20080516150804.587">def get_object(self):
    return self.pyobject.get()

</t>
<t tx="ekr.20080516150804.588">def get_definition_location(self):
    """Returns a (module, lineno) tuple"""
    if self.lineno is None and self.assignments:
        self.lineno = self.assignments[0].get_lineno()
    return (self.module, self.lineno)

</t>
<t tx="ekr.20080516150804.589">def invalidate(self):
    """Forget the `PyObject` this `PyName` holds"""
    self.pyobject.set(None)


</t>
<t tx="ekr.20080516150804.590">class ParameterName(pynames.ParameterName):
    @others
</t>
<t tx="ekr.20080516150804.591">
def __init__(self, pyfunction, index):
    self.pyfunction = pyfunction
    self.index = index

</t>
<t tx="ekr.20080516150804.592">def get_object(self):
    result = self.pyfunction.get_parameter(self.index)
    if result is None:
        result = rope.base.pyobjects.get_unknown()
    return result

</t>
<t tx="ekr.20080516150804.593">def get_objects(self):
    """Returns the list of objects passed as this parameter"""
    return rope.base.oi.soi.get_passed_objects(
        self.pyfunction, self.index)

</t>
<t tx="ekr.20080516150804.594">def get_definition_location(self):
    return (self.pyfunction.get_module(), self.pyfunction.get_ast().lineno)

</t>
<t tx="ekr.20080516150804.595">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.596">from rope.base import exceptions, ast


</t>
<t tx="ekr.20080516150804.597">class PyObject(object):
    @others
</t>
<t tx="ekr.20080516150804.598">
def __init__(self, type_):
    if type_ is None:
        type_ = self
    self.type = type_

</t>
<t tx="ekr.20080516150804.599">def get_attributes(self):
    if self.type is self:
        return {}
    return self.type.get_attributes()

</t>
<t tx="ekr.20080516150804.600">def get_attribute(self, name):
    if name not in self.get_attributes():
        raise exceptions.AttributeNotFoundError(
            'Attribute %s not found' % name)
    return self.get_attributes()[name]

</t>
<t tx="ekr.20080516150804.601">def get_type(self):
    return self.type

</t>
<t tx="ekr.20080516150804.602">def __getitem__(self, key):
    """The same as ``get_attribute(key)``"""
    return self.get_attribute(key)

</t>
<t tx="ekr.20080516150804.603">def __contains__(self, key):
    """The same as ``key in self.get_attributes()``"""
    return key in self.get_attributes()

</t>
<t tx="ekr.20080516150804.604">def __eq__(self, obj):
    """Check the equality of two `PyObject`\s

    Currently it is assumed that instances (the direct instances
    of `PyObject`, not the instances of its subclasses) are equal
    if their types are equal.  For every other object like
    defineds or builtins rope assumes objects are reference
    objects and their identities should match.

    """
    if self.__class__ != obj.__class__:
        return False
    if type(self) == PyObject:
        if self is not self.type:
            return self.type == obj.type
        else:
            return self.type is obj.type
    return self is obj

</t>
<t tx="ekr.20080516150804.605">def __hash__(self):
    """See docs for `__eq__()` method"""
    if type(self) == PyObject and self != self.type:
        return hash(self.type) + 1
    else:
        return super(PyObject, self).__hash__()

</t>
<t tx="ekr.20080516150804.606">def __iter__(self):
    """The same as ``iter(self.get_attributes())``"""
    return iter(self.get_attributes())

</t>
<t tx="ekr.20080516150804.607">_types = None
_unknown = None

@staticmethod
def _get_base_type(name):
    if PyObject._types is None:
        PyObject._types = {}
        base_type = PyObject(None)
        PyObject._types['Type'] = base_type
        PyObject._types['Module'] = PyObject(base_type)
        PyObject._types['Function'] = PyObject(base_type)
        PyObject._types['Unknown'] = PyObject(base_type)
    return PyObject._types[name]


</t>
<t tx="ekr.20080516150804.608">def get_base_type(name):
    """Return the base type with name `name`.

    The base types are 'Type', 'Function', 'Module' and 'Unknown'.  It
    was used to check the type of a `PyObject` but currently its use
    is discouraged.  Use classes defined in this module instead.
    For example instead of
    ``pyobject.get_type() == get_base_type('Function')`` use
    ``isinstance(pyobject, AbstractFunction)``.

    You can use `AbstractClass` for classes, `AbstractFunction` for
    functions, and `AbstractModule` for modules.  You can also use
    `PyFunction` and `PyClass` for testing if an object is
    defined somewhere and rope can access its source.  These classes
    provide more methods.

    """
    return PyObject._get_base_type(name)


</t>
<t tx="ekr.20080516150804.609">def get_unknown():
    """Return a pyobject whose type is unknown

    Note that two unknown objects are equal.  So for example you can
    write::

      if pyname.get_object() != get_unknown():
          print 'Object of pyname is not known'

    Rope could have used `None` for indicating unknown objects but
    we had to check that in many places.  So actually this method
    returns a null object.

    """
    if PyObject._unknown is None:
        PyObject._unknown = PyObject(get_base_type('Unknown'))
    return PyObject._unknown


</t>
<t tx="ekr.20080516150804.610">class AbstractClass(PyObject):
    @others
</t>
<t tx="ekr.20080516150804.611">
def __init__(self):
    super(AbstractClass, self).__init__(get_base_type('Type'))

</t>
<t tx="ekr.20080516150804.612">def get_name(self):
    pass

</t>
<t tx="ekr.20080516150804.613">def get_doc(self):
    pass

</t>
<t tx="ekr.20080516150804.614">def get_superclasses(self):
    return []


</t>
<t tx="ekr.20080516150804.615">class AbstractFunction(PyObject):
    @others
</t>
<t tx="ekr.20080516150804.616">
def __init__(self):
    super(AbstractFunction, self).__init__(get_base_type('Function'))

</t>
<t tx="ekr.20080516150804.617">def get_name(self):
    pass

</t>
<t tx="ekr.20080516150804.618">def get_doc(self):
    pass

</t>
<t tx="ekr.20080516150804.619">def get_param_names(self, special_args=True):
    return []

</t>
<t tx="ekr.20080516150804.620">def get_returned_object(self, args):
    return get_unknown()


</t>
<t tx="ekr.20080516150804.621">class AbstractModule(PyObject):
    @others
</t>
<t tx="ekr.20080516150804.622">
def __init__(self, doc=None):
    super(AbstractModule, self).__init__(get_base_type('Module'))

</t>
<t tx="ekr.20080516150804.623">def get_doc(self):
    pass

</t>
<t tx="ekr.20080516150804.624">def get_resource(self):
    pass


</t>
<t tx="ekr.20080516150804.625">class PyDefinedObject(object):
    """Python defined names that rope can access their sources"""
    @others
</t>
<t tx="ekr.20080516150804.626">
def __init__(self, pycore, ast_node, parent):
    self.pycore = pycore
    self.ast_node = ast_node
    self.scope = None
    self.parent = parent
    self.structural_attributes = None
    self.concluded_attributes = self.get_module()._get_concluded_data()
    self.attributes = self.get_module()._get_concluded_data()
    self.defineds = None

</t>
<t tx="ekr.20080516150804.627">visitor_class = None

def _get_structural_attributes(self):
    if self.structural_attributes is None:
        self.structural_attributes = self._create_structural_attributes()
    return self.structural_attributes

</t>
<t tx="ekr.20080516150804.628">def _get_concluded_attributes(self):
    if self.concluded_attributes.get() is None:
        self._get_structural_attributes()
        self.concluded_attributes.set(self._create_concluded_attributes())
    return self.concluded_attributes.get()

</t>
<t tx="ekr.20080516150804.629">def get_attributes(self):
    if self.attributes.get() is None:
        result = dict(self._get_concluded_attributes())
        result.update(self._get_structural_attributes())
        self.attributes.set(result)
    return self.attributes.get()

</t>
<t tx="ekr.20080516150804.630">def get_attribute(self, name):
    if name in self._get_structural_attributes():
        return self._get_structural_attributes()[name]
    if name in self._get_concluded_attributes():
        return self._get_concluded_attributes()[name]
    raise exceptions.AttributeNotFoundError('Attribute %s not found' %
                                            name)

</t>
<t tx="ekr.20080516150804.631">def get_scope(self):
    if self.scope is None:
        self.scope = self._create_scope()
    return self.scope

</t>
<t tx="ekr.20080516150804.632">def get_module(self):
    current_object = self
    while current_object.parent is not None:
        current_object = current_object.parent
    return current_object

</t>
<t tx="ekr.20080516150804.633">def get_doc(self):
    if len(self.get_ast().body) &gt; 0:
        expr = self.get_ast().body[0]
        if isinstance(expr, ast.Expr) and \
           isinstance(expr.value, ast.Str):
            return expr.value.s

</t>
<t tx="ekr.20080516150804.634">def _get_defined_objects(self):
    if self.defineds is None:
        self._get_structural_attributes()
    return self.defineds

</t>
<t tx="ekr.20080516150804.635">def _create_structural_attributes(self):
    if self.visitor_class is None:
        return {}
    new_visitor = self.visitor_class(self.pycore, self)
    for child in ast.get_child_nodes(self.ast_node):
        ast.walk(child, new_visitor)
    self.defineds = new_visitor.defineds
    return new_visitor.names

</t>
<t tx="ekr.20080516150804.636">def _create_concluded_attributes(self):
    return {}

</t>
<t tx="ekr.20080516150804.637">def get_ast(self):
    return self.ast_node

</t>
<t tx="ekr.20080516150804.638">def _create_scope(self):
    pass


</t>
<t tx="ekr.20080516150804.639">class PyFunction(PyDefinedObject, AbstractFunction):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.640">class PyClass(PyDefinedObject, AbstractClass):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.641">class _ConcludedData(object):
    @others
</t>
<t tx="ekr.20080516150804.642">
def __init__(self):
    self.data_ = None

</t>
<t tx="ekr.20080516150804.643">def set(self, data):
    self.data_ = data

</t>
<t tx="ekr.20080516150804.644">def get(self):
    return self.data_

</t>
<t tx="ekr.20080516150804.645">data = property(get, set)

def _invalidate(self):
    self.data = None

</t>
<t tx="ekr.20080516150804.646">def __str__(self):
    return '&lt;' + str(self.data) + '&gt;'


</t>
<t tx="ekr.20080516150804.647">class _PyModule(PyDefinedObject, AbstractModule):
    @others
</t>
<t tx="ekr.20080516150804.648">
def __init__(self, pycore, ast_node, resource):
    self.resource = resource
    self.concluded_data = []
    AbstractModule.__init__(self)
    PyDefinedObject.__init__(self, pycore, ast_node, None)

</t>
<t tx="ekr.20080516150804.649">def _get_concluded_data(self):
    new_data = _ConcludedData()
    self.concluded_data.append(new_data)
    return new_data

</t>
<t tx="ekr.20080516150804.650">def _forget_concluded_data(self):
    for data in self.concluded_data:
        data._invalidate()

</t>
<t tx="ekr.20080516150804.651">def get_resource(self):
    return self.resource


</t>
<t tx="ekr.20080516150804.652">class PyModule(_PyModule):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.653">class PyPackage(_PyModule):
    """Only a placeholder"""


</t>
<t tx="ekr.20080516150804.654">class IsBeingInferredError(exceptions.RopeError):
    pass
</t>
<t tx="ekr.20080516150804.655">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.656">import rope.base.codeanalyze
import rope.base.evaluate
import rope.base.builtins
import rope.base.oi.soi
import rope.base.pyscopes
from rope.base import (pynamesdef as pynames, exceptions, ast,
                       astutils, pyobjects, fscommands, arguments, utils)
from rope.base.pyobjects import *


</t>
<t tx="ekr.20080516150804.657">class PyFunction(pyobjects.PyFunction):
    @others
</t>
<t tx="ekr.20080516150804.658">
def __init__(self, pycore, ast_node, parent):
    AbstractFunction.__init__(self)
    PyDefinedObject.__init__(self, pycore, ast_node, parent)
    self.arguments = self.ast_node.args
    self.parameter_pyobjects = pynames._Inferred(
        self._infer_parameters, self.get_module()._get_concluded_data())
    self.returned = pynames._Inferred(self._infer_returned)
    self.parameter_pynames = None

</t>
<t tx="ekr.20080516150804.659">def _create_structural_attributes(self):
    return {}

</t>
<t tx="ekr.20080516150804.660">def _create_concluded_attributes(self):
    return {}

</t>
<t tx="ekr.20080516150804.661">def _create_scope(self):
    return rope.base.pyscopes.FunctionScope(self.pycore, self,
                                            _FunctionVisitor)

</t>
<t tx="ekr.20080516150804.662">def _infer_parameters(self):
    pyobjects = rope.base.oi.soi.infer_parameter_objects(self)
    self._handle_special_args(pyobjects)
    return pyobjects

</t>
<t tx="ekr.20080516150804.663">def _infer_returned(self, args=None):
    return rope.base.oi.soi.infer_returned_object(self, args)

</t>
<t tx="ekr.20080516150804.664">def _handle_special_args(self, pyobjects):
    if len(pyobjects) == len(self.arguments.args):
        if self.arguments.vararg:
            pyobjects.append(rope.base.builtins.get_list())
        if self.arguments.kwarg:
            pyobjects.append(rope.base.builtins.get_dict())

</t>
<t tx="ekr.20080516150804.665">def _set_parameter_pyobjects(self, pyobjects):
    if pyobjects is not None:
        self._handle_special_args(pyobjects)
    self.parameter_pyobjects.set(pyobjects)

</t>
<t tx="ekr.20080516150804.666">def get_parameters(self):
    if self.parameter_pynames is None:
        result = {}
        for index, name in enumerate(self.get_param_names()):
            # TODO: handle tuple parameters
            result[name] = pynames.ParameterName(self, index)
        self.parameter_pynames = result
    return self.parameter_pynames

</t>
<t tx="ekr.20080516150804.667">def get_parameter(self, index):
    if index &lt; len(self.parameter_pyobjects.get()):
        return self.parameter_pyobjects.get()[index]

</t>
<t tx="ekr.20080516150804.668">def get_returned_object(self, args):
    return self.returned.get(args)

</t>
<t tx="ekr.20080516150804.669">def get_name(self):
    return self.get_ast().name

</t>
<t tx="ekr.20080516150804.670">def get_param_names(self, special_args=True):
    # TODO: handle tuple parameters
    result = [node.id for node in self.arguments.args
              if isinstance(node, ast.Name)]
    if special_args:
        if self.arguments.vararg:
            result.append(self.arguments.vararg)
        if self.arguments.kwarg:
            result.append(self.arguments.kwarg)
    return result

</t>
<t tx="ekr.20080516150804.671">def get_kind(self):
    """Get function type

    It returns one of 'function', 'method', 'staticmethod' or
    'classmethod' strs.

    """
    scope = self.parent.get_scope()
    if isinstance(self.parent, PyClass):
        for decorator in self.decorators:
            pyname = rope.base.evaluate.get_statement_result(scope,
                                                             decorator)
            if pyname == rope.base.builtins.builtins['staticmethod']:
                return 'staticmethod'
            if pyname == rope.base.builtins.builtins['classmethod']:
                return 'classmethod'
        return 'method'
    return 'function'

</t>
<t tx="ekr.20080516150804.672">@property
def decorators(self):
    try:
        return getattr(self.ast_node, 'decorator_list')
    except AttributeError:
        return getattr(self.ast_node, 'decorators', None)


</t>
<t tx="ekr.20080516150804.673">class PyClass(pyobjects.PyClass):
    @others
</t>
<t tx="ekr.20080516150804.674">
def __init__(self, pycore, ast_node, parent):
    self.visitor_class = _ClassVisitor
    AbstractClass.__init__(self)
    PyDefinedObject.__init__(self, pycore, ast_node, parent)
    self.parent = parent
    self._superclasses = self.get_module()._get_concluded_data()

</t>
<t tx="ekr.20080516150804.675">def get_superclasses(self):
    if self._superclasses.get() is None:
        self._superclasses.set(self._get_bases())
    return self._superclasses.get()

</t>
<t tx="ekr.20080516150804.676">def get_name(self):
    return self.get_ast().name

</t>
<t tx="ekr.20080516150804.677">def _create_concluded_attributes(self):
    result = {}
    for base in reversed(self.get_superclasses()):
        result.update(base.get_attributes())
    return result

</t>
<t tx="ekr.20080516150804.678">def _get_bases(self):
    result = []
    for base_name in self.ast_node.bases:
        base = rope.base.evaluate.get_statement_result(
            self.parent.get_scope(), base_name)
        if base is not None and \
           base.get_object().get_type() == get_base_type('Type'):
            result.append(base.get_object())
    return result

</t>
<t tx="ekr.20080516150804.679">def _create_scope(self):
    return rope.base.pyscopes.ClassScope(self.pycore, self)


</t>
<t tx="ekr.20080516150804.680">class PyModule(pyobjects.PyModule):
    @others
</t>
<t tx="ekr.20080516150804.681">
def __init__(self, pycore, source=None,
             resource=None, force_errors=False):
    ignore = pycore.project.prefs.get('ignore_syntax_errors', False)
    syntax_errors = force_errors or not ignore
    try:
        source, node = self._init_source(pycore, source, resource)
    except exceptions.ModuleSyntaxError:
        if syntax_errors:
            raise
        else:
            source = '\n'
            node = ast.parse('\n')
    self.source_code = source
    self.star_imports = []
    self.visitor_class = _GlobalVisitor
    super(PyModule, self).__init__(pycore, node, resource)

</t>
<t tx="ekr.20080516150804.682">def _init_source(self, pycore, source_code, resource):
    filename = 'string'
    if resource:
        filename = resource.path
    try:
        if source_code is None:
            source_bytes = resource.read_bytes()
            source_code = fscommands.file_data_to_unicode(source_bytes)
        else:
            if isinstance(source_code, unicode):
                source_bytes = fscommands.unicode_to_file_data(source_code)
            else:
                source_bytes = source_code
        ast_node = ast.parse(source_bytes, filename=filename)
    except SyntaxError, e:
        raise exceptions.ModuleSyntaxError(filename, e.lineno, e.msg)
    except UnicodeDecodeError, e:
        raise exceptions.ModuleSyntaxError(filename, 1, '%s' % (e.reason))
    return source_code, ast_node

</t>
<t tx="ekr.20080516150804.683">@utils.prevent_recursion(lambda: {})
def _create_concluded_attributes(self):
    result = {}
    for star_import in self.star_imports:
        result.update(star_import.get_names())
    return result

</t>
<t tx="ekr.20080516150804.684">def _create_scope(self):
    return rope.base.pyscopes.GlobalScope(self.pycore, self)

</t>
<t tx="ekr.20080516150804.685">_lines = None
@property
def lines(self):
    """return a `SourceLinesAdapter`"""
    if self._lines is None:
        self._lines = rope.base.codeanalyze.\
                      SourceLinesAdapter(self.source_code)
    return self._lines

</t>
<t tx="ekr.20080516150804.686">_logical_lines = None
@property
def logical_lines(self):
    """return a `LogicalLinesFinder`"""
    if self._logical_lines is None:
        self._logical_lines = \
            rope.base.codeanalyze.CachingLogicalLineFinder(self.lines)
    return self._logical_lines


</t>
<t tx="ekr.20080516150804.687">class PyPackage(pyobjects.PyPackage):
    @others
</t>
<t tx="ekr.20080516150804.688">
def __init__(self, pycore, resource=None, force_errors=False):
    self.resource = resource
    init_dot_py = self._get_init_dot_py()
    if init_dot_py is not None:
        ast_node = pycore.resource_to_pyobject(
            init_dot_py, force_errors=force_errors).get_ast()
    else:
        ast_node = ast.parse('\n')
    super(PyPackage, self).__init__(pycore, ast_node, resource)

</t>
<t tx="ekr.20080516150804.689">def _create_structural_attributes(self):
    result = {}
    if self.resource is None:
        return result
    for name, resource in self._get_child_resources().items():
        result[name] = pynames.ImportedModule(self, resource=resource)
    return result

</t>
<t tx="ekr.20080516150804.690">def _create_concluded_attributes(self):
    result = {}
    init_dot_py = self._get_init_dot_py()
    if init_dot_py:
        init_object = self.pycore.resource_to_pyobject(init_dot_py)
        result.update(init_object.get_attributes())
    return result

</t>
<t tx="ekr.20080516150804.691">def _get_child_resources(self):
    result = {}
    for child in self.resource.get_children():
        if child.is_folder():
            result[child.name] = child
        elif child.name.endswith('.py') and \
             child.name != '__init__.py':
            name = child.name[:-3]
            result[name] = child
    return result

</t>
<t tx="ekr.20080516150804.692">def _get_init_dot_py(self):
    if self.resource is not None and self.resource.has_child('__init__.py'):
        return self.resource.get_child('__init__.py')
    else:
        return None

</t>
<t tx="ekr.20080516150804.693">def _create_scope(self):
    return self.get_module().get_scope()

</t>
<t tx="ekr.20080516150804.694">def get_module(self):
    init_dot_py = self._get_init_dot_py()
    if init_dot_py:
        return self.pycore.resource_to_pyobject(init_dot_py)
    return self


</t>
<t tx="ekr.20080516150804.695">class _AssignVisitor(object):
    @others
</t>
<t tx="ekr.20080516150804.696">
def __init__(self, scope_visitor):
    self.scope_visitor = scope_visitor
    self.assigned_ast = None

</t>
<t tx="ekr.20080516150804.697">def _Assign(self, node):
    self.assigned_ast = node.value
    for child_node in node.targets:
        ast.walk(child_node, self)

</t>
<t tx="ekr.20080516150804.698">def _assigned(self, name, assignment=None):
    self.scope_visitor._assigned(name, assignment)

</t>
<t tx="ekr.20080516150804.699">def _Name(self, node):
    assignment = None
    if self.assigned_ast is not None:
        assignment = pynames.AssignmentValue(self.assigned_ast)
    self._assigned(node.id, assignment)

</t>
<t tx="ekr.20080516150804.700">def _Tuple(self, node):
    names = astutils.get_name_levels(node)
    for name, levels in names:
        assignment = None
        if self.assigned_ast is not None:
            assignment = pynames.AssignmentValue(self.assigned_ast, levels)
        self._assigned(name, assignment)

</t>
<t tx="ekr.20080516150804.701">def _Attribute(self, node):
    pass

</t>
<t tx="ekr.20080516150804.702">def _Subscript(self, node):
    pass

</t>
<t tx="ekr.20080516150804.703">def _Slice(self, node):
    pass


</t>
<t tx="ekr.20080516150804.704">class _ScopeVisitor(object):
    @others
</t>
<t tx="ekr.20080516150804.705">
def __init__(self, pycore, owner_object):
    self.pycore = pycore
    self.owner_object = owner_object
    self.names = {}
    self.defineds = []

</t>
<t tx="ekr.20080516150804.706">def get_module(self):
    if self.owner_object is not None:
        return self.owner_object.get_module()
    else:
        return None

</t>
<t tx="ekr.20080516150804.707">def _ClassDef(self, node):
    pyclass = PyClass(self.pycore, node, self.owner_object)
    self.names[node.name] = pynames.DefinedName(pyclass)
    self.defineds.append(pyclass)

</t>
<t tx="ekr.20080516150804.708">def _FunctionDef(self, node):
    pyfunction = PyFunction(self.pycore, node, self.owner_object)
    for decorator in pyfunction.decorators:
        if isinstance(decorator, ast.Name) and decorator.id == 'property':
            if isinstance(self, _ClassVisitor):
                type_ = rope.base.builtins.Property(pyfunction)
                arg = pynames.UnboundName(PyObject(self.owner_object))
                def _eval(type_=type_, arg=arg):
                    return type_.get_property_object(
                        arguments.ObjectArguments([arg]))
                self.names[node.name] = pynames.EvaluatedName(
                    _eval, module=self.get_module(), lineno=node.lineno)
                break
    else:
        self.names[node.name] = pynames.DefinedName(pyfunction)
    self.defineds.append(pyfunction)

</t>
<t tx="ekr.20080516150804.709">def _Assign(self, node):
    ast.walk(node, _AssignVisitor(self))

</t>
<t tx="ekr.20080516150804.710">def _AugAssign(self, node):
    pass

</t>
<t tx="ekr.20080516150804.711">def _For(self, node):
    names = self._update_evaluated(node.target, node.iter,
                                   '.__iter__().next()')
    for child in node.body + node.orelse:
        ast.walk(child, self)

</t>
<t tx="ekr.20080516150804.712">def _assigned(self, name, assignment):
    pyname = self.names.get(name, None)
    if pyname is None:
        pyname = pynames.AssignedName(module=self.get_module())
    if isinstance(pyname, pynames.AssignedName):
        if assignment is not None:
            pyname.assignments.append(assignment)
        self.names[name] = pyname

</t>
<t tx="ekr.20080516150804.713">def _update_evaluated(self, targets, assigned,
                      evaluation= '', eval_type=False):
    result = {}
    names = astutils.get_name_levels(targets)
    for name, levels in names:
        assignment = pynames.AssignmentValue(assigned, levels,
                                             evaluation, eval_type)
        self._assigned(name, assignment)
    return result

</t>
<t tx="ekr.20080516150804.714">def _With(self, node):
    if node.optional_vars:
        self._update_evaluated(node.optional_vars,
                               node.context_expr, '.__enter__()')
    for child in node.body:
        ast.walk(child, self)

</t>
<t tx="ekr.20080516150804.715">def _excepthandler(self, node):
    if node.name is not None and isinstance(node.name, ast.Name):
        type_node = node.type
        if isinstance(node.type, ast.Tuple) and type_node.elts:
            type_node = type_node.elts[0]
        self._update_evaluated(node.name, type_node, eval_type=True)
    for child in node.body:
        ast.walk(child, self)

</t>
<t tx="ekr.20080516150804.716">def _ExceptHandler(self, node):
    self._excepthandler(node)

</t>
<t tx="ekr.20080516150804.717">def _Import(self, node):
    for import_pair in node.names:
        module_name = import_pair.name
        alias = import_pair.asname
        first_package = module_name.split('.')[0]
        if alias is not None:
            imported = pynames.ImportedModule(self.get_module(),
                                              module_name)
            if not self._is_ignored_import(imported):
                self.names[alias] = imported
        else:
            imported = pynames.ImportedModule(self.get_module(),
                                              first_package)
            if not self._is_ignored_import(imported):
                self.names[first_package] = imported

</t>
<t tx="ekr.20080516150804.718">def _ImportFrom(self, node):
    level = 0
    if node.level:
        level = node.level
    imported_module = pynames.ImportedModule(self.get_module(),
                                             node.module, level)
    if self._is_ignored_import(imported_module):
        return
    if len(node.names) == 1 and node.names[0].name == '*':
        if isinstance(self.owner_object, PyModule):
            self.owner_object.star_imports.append(
                StarImport(imported_module))
    else:
        for imported_name in node.names:
            imported = imported_name.name
            alias = imported_name.asname
            if alias is not None:
                imported = alias
            self.names[imported] = pynames.ImportedName(imported_module,
                                                        imported_name.name)

</t>
<t tx="ekr.20080516150804.719">def _is_ignored_import(self, imported_module):
    if not self.pycore.project.prefs.get('ignore_bad_imports', False):
        return False
    return not isinstance(imported_module.get_object(), AbstractModule)

</t>
<t tx="ekr.20080516150804.720">def _Global(self, node):
    module = self.get_module()
    for name in node.names:
        if module is not None:
            try:
                pyname = module[name]
            except exceptions.AttributeNotFoundError:
                pyname = pynames.AssignedName(node.lineno)
        self.names[name] = pyname


</t>
<t tx="ekr.20080516150804.721">class _GlobalVisitor(_ScopeVisitor):
    @others
</t>
<t tx="ekr.20080516150804.722">
def __init__(self, pycore, owner_object):
    super(_GlobalVisitor, self).__init__(pycore, owner_object)


</t>
<t tx="ekr.20080516150804.723">class _ClassVisitor(_ScopeVisitor):
    @others
</t>
<t tx="ekr.20080516150804.724">
def __init__(self, pycore, owner_object):
    super(_ClassVisitor, self).__init__(pycore, owner_object)

</t>
<t tx="ekr.20080516150804.725">def _FunctionDef(self, node):
    _ScopeVisitor._FunctionDef(self, node)
    if len(node.args.args) &gt; 0:
        first = node.args.args[0]
        if isinstance(first, ast.Name):
            new_visitor = _ClassInitVisitor(self, first.id)
            for child in ast.get_child_nodes(node):
                ast.walk(child, new_visitor)


</t>
<t tx="ekr.20080516150804.726">class _FunctionVisitor(_ScopeVisitor):
    @others
</t>
<t tx="ekr.20080516150804.727">
def __init__(self, pycore, owner_object):
    super(_FunctionVisitor, self).__init__(pycore, owner_object)
    self.returned_asts = []
    self.generator = False

</t>
<t tx="ekr.20080516150804.728">def _Return(self, node):
    if node.value is not None:
        self.returned_asts.append(node.value)

</t>
<t tx="ekr.20080516150804.729">def _Yield(self, node):
    if node.value is not None:
        self.returned_asts.append(node.value)
    self.generator = True


</t>
<t tx="ekr.20080516150804.730">class _ClassInitVisitor(_AssignVisitor):
    @others
</t>
<t tx="ekr.20080516150804.731">
def __init__(self, scope_visitor, self_name):
    super(_ClassInitVisitor, self).__init__(scope_visitor)
    self.self_name = self_name

</t>
<t tx="ekr.20080516150804.732">def _Attribute(self, node):
    if not isinstance(node.ctx, ast.Store):
        return
    if isinstance(node.value, ast.Name) and \
       node.value.id == self.self_name:
        if node.attr not in self.scope_visitor.names:
            self.scope_visitor.names[node.attr] = pynames.AssignedName(
                lineno=node.lineno, module=self.scope_visitor.get_module())
        if self.assigned_ast is not None:
            pyname = self.scope_visitor.names[node.attr]
            if isinstance(pyname, pynames.AssignedName):
                pyname.assignments.append(
                    pynames.AssignmentValue(self.assigned_ast))

</t>
<t tx="ekr.20080516150804.733">def _Tuple(self, node):
    if not isinstance(node.ctx, ast.Store):
        return
    for child in ast.get_child_nodes(node):
        ast.walk(child, self)

</t>
<t tx="ekr.20080516150804.734">def _Name(self, node):
    pass

</t>
<t tx="ekr.20080516150804.735">def _FunctionDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.736">def _ClassDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.737">def _For(self, node):
    pass

</t>
<t tx="ekr.20080516150804.738">def _With(self, node):
    pass


</t>
<t tx="ekr.20080516150804.739">class StarImport(object):
    @others
</t>
<t tx="ekr.20080516150804.740">
def __init__(self, imported_module):
    self.imported_module = imported_module

</t>
<t tx="ekr.20080516150804.741">def get_names(self):
    result = {}
    imported = self.imported_module.get_object()
    for name in imported:
        if not name.startswith('_'):
            result[name] = pynames.ImportedName(self.imported_module, name)
    return result
</t>
<t tx="ekr.20080516150804.742">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.743">import rope.base.builtins
import rope.base.codeanalyze
import rope.base.pynames
from rope.base import ast, exceptions


</t>
<t tx="ekr.20080516150804.744">class Scope(object):
    @others
</t>
<t tx="ekr.20080516150804.745">
def __init__(self, pycore, pyobject, parent_scope):
    self.pycore = pycore
    self.pyobject = pyobject
    self.parent = parent_scope
    self.scopes = None

</t>
<t tx="ekr.20080516150804.746">def get_names(self):
    """Return the names defined or imported in this scope"""
    return self.pyobject.get_attributes()

</t>
<t tx="ekr.20080516150804.747">def get_defined_names(self):
    """Return the names defined in this scope"""
    return self.pyobject._get_structural_attributes()

</t>
<t tx="ekr.20080516150804.748">def get_name(self, name):
    """Return name `PyName` defined in this scope"""
    if name not in self.get_names():
        raise exceptions.NameNotFoundError('name %s not found' % name)
    return self.get_names()[name]

</t>
<t tx="ekr.20080516150804.749">def __getitem__(self, key):
    """The same as ``get_name(key)``"""
    return self.get_name(key)

</t>
<t tx="ekr.20080516150804.750">def __contains__(self, key):
    """The same as ``key in self.get_names()``"""
    return key in self.get_names()

</t>
<t tx="ekr.20080516150804.751">def get_scopes(self):
    """Return the subscopes of this scope.

    The returned scopes should be sorted by the order they appear
    """
    if self.scopes is None:
        self.scopes = self._create_scopes()
    return self.scopes

</t>
<t tx="ekr.20080516150804.752">def lookup(self, name):
    if name in self.get_names():
        return self.get_names()[name]
    if self.parent is not None:
        return self.parent._propagated_lookup(name)
    return None

</t>
<t tx="ekr.20080516150804.753">def get_propagated_names(self):
    """Return the names defined in this scope that are visible from
    scopes contained in this scope

    This method returns the same dictionary returned by
    `get_names()` except for `ClassScope` which returns an empty
    dict.

    """
    return self.get_names()

</t>
<t tx="ekr.20080516150804.754">def _propagated_lookup(self, name):
    if name in self.get_propagated_names():
        return self.get_propagated_names()[name]
    if self.parent is not None:
        return self.parent._propagated_lookup(name)
    return None

</t>
<t tx="ekr.20080516150804.755">def _create_scopes(self):
    return [pydefined.get_scope()
            for pydefined in self.pyobject._get_defined_objects()]

</t>
<t tx="ekr.20080516150804.756">def _get_global_scope(self):
    current = self
    while current.parent is not None:
        current = current.parent
    return current

</t>
<t tx="ekr.20080516150804.757">def get_start(self):
    return self.pyobject.get_ast().lineno

</t>
<t tx="ekr.20080516150804.758">def get_body_start(self):
    body = self.pyobject.get_ast().body
    if body:
        return body[0].lineno
    return self.get_start()

</t>
<t tx="ekr.20080516150804.759">_end = None

def get_end(self):
    pymodule = self._get_global_scope().pyobject
    return pymodule.logical_lines.logical_line_in(self.logical_end)[1]

</t>
<t tx="ekr.20080516150804.760">def get_logical_end(self):
    if self._end is None:
        global_scope = self._get_global_scope()
        self._end = global_scope._get_scope_finder().find_scope_end(self)
    return self._end

</t>
<t tx="ekr.20080516150804.761">start = property(get_start)
end = property(get_end)
logical_end = property(get_logical_end)

def get_kind(self):
    pass


</t>
<t tx="ekr.20080516150804.762">class GlobalScope(Scope):
    @others
</t>
<t tx="ekr.20080516150804.763">
def __init__(self, pycore, module):
    super(GlobalScope, self).__init__(pycore, module, None)
    self.scope_finder = None
    self.names = module._get_concluded_data()

</t>
<t tx="ekr.20080516150804.764">def get_start(self):
    return 1

</t>
<t tx="ekr.20080516150804.765">def get_kind(self):
    return 'Module'

</t>
<t tx="ekr.20080516150804.766">def get_name(self, name):
    try:
        return self.pyobject[name]
    except exceptions.AttributeNotFoundError:
        if name in self.builtin_names:
            return self.builtin_names[name]
        raise exceptions.NameNotFoundError('name %s not found' % name)

</t>
<t tx="ekr.20080516150804.767">def get_names(self):
    if self.names.get() is None:
        result = dict(self.builtin_names)
        result.update(super(GlobalScope, self).get_names())
        self.names.set(result)
    return self.names.get()

</t>
<t tx="ekr.20080516150804.768">def get_inner_scope_for_line(self, lineno, indents=None):
    return self._get_scope_finder().get_holding_scope(self, lineno, indents)

</t>
<t tx="ekr.20080516150804.769">def get_inner_scope_for_offset(self, offset):
    return self._get_scope_finder().get_holding_scope_for_offset(self, offset)

</t>
<t tx="ekr.20080516150804.770">def _get_scope_finder(self):
    if self.scope_finder is None:
        self.scope_finder = _HoldingScopeFinder(self.pyobject)
    return self.scope_finder

</t>
<t tx="ekr.20080516150804.771">@property
def builtin_names(self):
    return rope.base.builtins.builtins.get_attributes()


</t>
<t tx="ekr.20080516150804.772">class FunctionScope(Scope):
    @others
</t>
<t tx="ekr.20080516150804.773">
def __init__(self, pycore, pyobject, visitor):
    super(FunctionScope, self).__init__(pycore, pyobject,
                                        pyobject.parent.get_scope())
    self.names = None
    self.returned_asts = None
    self.is_generator = None
    self.defineds = None
    self.visitor = visitor

</t>
<t tx="ekr.20080516150804.774">def _get_names(self):
    if self.names is None:
        self._visit_function()
    return self.names

</t>
<t tx="ekr.20080516150804.775">def _visit_function(self):
    if self.names is None:
        new_visitor = self.visitor(self.pycore, self.pyobject)
        for n in ast.get_child_nodes(self.pyobject.get_ast()):
            ast.walk(n, new_visitor)
        self.names = new_visitor.names
        self.names.update(self.pyobject.get_parameters())
        self.returned_asts = new_visitor.returned_asts
        self.is_generator = new_visitor.generator
        self.defineds = new_visitor.defineds

</t>
<t tx="ekr.20080516150804.776">def _get_returned_asts(self):
    if self.names is None:
        self._visit_function()
    return self.returned_asts

</t>
<t tx="ekr.20080516150804.777">def _is_generator(self):
    if self.is_generator is None:
        self._get_returned_asts()
    return self.is_generator

</t>
<t tx="ekr.20080516150804.778">def get_names(self):
    return self._get_names()

</t>
<t tx="ekr.20080516150804.779">def _create_scopes(self):
    if self.defineds is None:
        self._visit_function()
    return [pydefined.get_scope() for pydefined in self.defineds]

</t>
<t tx="ekr.20080516150804.780">def get_kind(self):
    return 'Function'

</t>
<t tx="ekr.20080516150804.781">def invalidate_data(self):
    for pyname in self.get_names().values():
        if isinstance(pyname, (rope.base.pynames.AssignedName,
                               rope.base.pynames.EvaluatedName)):
            pyname.invalidate()


</t>
<t tx="ekr.20080516150804.782">class ClassScope(Scope):
    @others
</t>
<t tx="ekr.20080516150804.783">
def __init__(self, pycore, pyobject):
    super(ClassScope, self).__init__(pycore, pyobject,
                                     pyobject.parent.get_scope())

</t>
<t tx="ekr.20080516150804.784">def get_kind(self):
    return 'Class'

</t>
<t tx="ekr.20080516150804.785">def get_propagated_names(self):
    return {}


</t>
<t tx="ekr.20080516150804.786">class _HoldingScopeFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.787">
def __init__(self, pymodule):
    self.pymodule = pymodule

</t>
<t tx="ekr.20080516150804.788">def get_indents(self, lineno):
    return rope.base.codeanalyze.count_line_indents(
        self.lines.get_line(lineno))

</t>
<t tx="ekr.20080516150804.789">def get_location(self, offset):
    current_pos = 0
    lineno = 1
    while current_pos + len(self.lines.get_line(lineno)) &lt; offset:
        current_pos += len(self.lines.get_line(lineno)) + 1
        lineno += 1
    return (lineno, offset - current_pos)

</t>
<t tx="ekr.20080516150804.790">def _get_scope_indents(self, scope):
    return self.get_indents(scope.get_start())

</t>
<t tx="ekr.20080516150804.791">def get_holding_scope(self, module_scope, lineno, line_indents=None):
    if line_indents is None:
        line_indents = self.get_indents(lineno)
    current_scope = module_scope
    new_scope = current_scope
    while new_scope is not None and \
          (new_scope.get_kind() == 'Module' or
           self._get_scope_indents(new_scope) &lt;= line_indents):
        current_scope = new_scope
        if current_scope.get_start() == lineno and \
           current_scope.get_kind() != 'Module':
            return current_scope
        new_scope = None
        for scope in current_scope.get_scopes():
            if scope.get_start() &lt;= lineno:
                if lineno &lt;= scope.get_end():
                    new_scope = scope
                    break
            else:
                break
    return current_scope

</t>
<t tx="ekr.20080516150804.792">def _is_empty_line(self, lineno):
    line = self.lines.get_line(lineno)
    return line.strip() == '' or line.lstrip().startswith('#')

</t>
<t tx="ekr.20080516150804.793">def _get_body_indents(self, scope):
    return self.get_indents(scope.get_body_start())

</t>
<t tx="ekr.20080516150804.794">def get_holding_scope_for_offset(self, scope, offset):
    return self.get_holding_scope(
        scope, self.lines.get_line_number(offset))

</t>
<t tx="ekr.20080516150804.795">def find_scope_end(self, scope):
    if not scope.parent:
        return self.lines.length()
    end = scope.pyobject.get_ast().body[-1].lineno
    scope_start = self.pymodule.logical_lines.logical_line_in(scope.start)
    if scope_start[1] &gt;= end:
        # handling one-liners
        body_indents = self._get_scope_indents(scope) + 4
    else:
        body_indents = self._get_body_indents(scope)
    for l in self.logical_lines.generate_starts(
        min(end + 1, self.lines.length()), self.lines.length() + 1):
        if not self._is_empty_line(l):
            if self.get_indents(l) &lt; body_indents:
                return end
            else:
                end = l
    return end

</t>
<t tx="ekr.20080516150804.796">@property
def lines(self):
    return self.pymodule.lines

</t>
<t tx="ekr.20080516150804.797">@property
def code(self):
    return self.pymodule.source_code

</t>
<t tx="ekr.20080516150804.798">@property
def logical_lines(self):
    return self.pymodule.logical_lines

</t>
<t tx="ekr.20080516150804.799">class TemporaryScope(Scope):
    """Currently used for list comprehensions and generator expressions

    These scopes do not appear in the `get_scopes()` method of their
    parent scopes.
    """
    @others
</t>
<t tx="ekr.20080516150804.800">
def __init__(self, pycore, parent_scope, names):
    super(TemporaryScope, self).__init__(
        pycore, parent_scope.pyobject, parent_scope)
    self.names = names

</t>
<t tx="ekr.20080516150804.801">def get_names(self):
    return self.names

</t>
<t tx="ekr.20080516150804.802">def get_defined_names(self):
    return self.names

</t>
<t tx="ekr.20080516150804.803">def _create_scopes(self):
    return []

</t>
<t tx="ekr.20080516150804.804">def get_kind(self):
    return 'Temporary'
</t>
<t tx="ekr.20080516150804.805">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.806">import os


</t>
<t tx="ekr.20080516150804.807">class ResourceObserver(object):
    """Provides the interface for observing resources

    `ResourceObserver`\s can be registered using `Project.
    add_observer()`.  But most of the time `FilteredResourceObserver`
    should be used.  `ResourceObserver`\s report all changes passed
    to them and they don't report changes to all resources.  For
    example if a folder is removed, it only calls `removed()` for that
    folder and not its contents.  You can use
    `FilteredResourceObserver` if you are interested in changes only
    to a list of resources.  And you want changes to be reported on
    individual resources.

    """
    @others
</t>
<t tx="ekr.20080516150804.808">
def __init__(self, changed=None, moved=None, created=None,
             removed=None, validate=None):
    self.changed = changed
    self.moved = moved
    self.created = created
    self.removed = removed
    self._validate = validate

</t>
<t tx="ekr.20080516150804.809">def resource_changed(self, resource):
    """It is called when the resource changes"""
    if self.changed is not None:
        self.changed(resource)

</t>
<t tx="ekr.20080516150804.810">def resource_moved(self, resource, new_resource):
    """It is called when a resource is moved"""
    if self.moved is not None:
        self.moved(resource, new_resource)

</t>
<t tx="ekr.20080516150804.811">def resource_created(self, resource):
    """Is called when a new resource is created"""
    if self.created is not None:
        self.created(resource)

</t>
<t tx="ekr.20080516150804.812">def resource_removed(self, resource):
    """Is called when a new resource is removed"""
    if self.removed is not None:
        self.removed(resource)

</t>
<t tx="ekr.20080516150804.813">def validate(self, resource):
    """Validate the existence of this resource and its children.

    This function is called when rope need to update its resource
    cache about the files that might have been changed or removed
    by other processes.

    """
    if self._validate is not None:
        self._validate(resource)


</t>
<t tx="ekr.20080516150804.814">class FilteredResourceObserver(object):
    """A useful decorator for `ResourceObserver`

    Most resource observers have a list of resources and are
    interested only in changes to those files.  This class satisfies
    this need.  It dispatches resource changed and removed messages.
    It performs these tasks:

    * Changes to files and folders are analyzed to check whether any
      of the interesting resources are changed or not.  If they are,
      it reports these changes to `resource_observer` passed to the
      constructor.
    * When a resource is removed it checks whether any of the
      interesting resources are contained in that folder and reports
      them to `resource_observer`.
    * When validating a folder it validates all of the interesting
      files in that folder.

    Since most resource observers are interested in a list of
    resources that change over time, `add_resource` and
    `remove_resource` might be useful.

    """
    @others
</t>
<t tx="ekr.20080516150804.815">
def __init__(self, resource_observer, initial_resources=None,
             timekeeper=None):
    self.observer = resource_observer
    self.resources = {}
    if timekeeper is not None:
        self.timekeeper = timekeeper
    else:
        self.timekeeper = ChangeIndicator()
    if initial_resources is not None:
        for resource in initial_resources:
            self.add_resource(resource)

</t>
<t tx="ekr.20080516150804.816">def add_resource(self, resource):
    """Add a resource to the list of interesting resources"""
    if resource.exists():
        self.resources[resource] = self.timekeeper.get_indicator(resource)
    else:
        self.resources[resource] = None

</t>
<t tx="ekr.20080516150804.817">def remove_resource(self, resource):
    """Add a resource to the list of interesting resources"""
    if resource in self.resources:
        del self.resources[resource]

</t>
<t tx="ekr.20080516150804.818">def clear_resources(self):
    """Removes all registered resources"""
    self.resources.clear()

</t>
<t tx="ekr.20080516150804.819">def resource_changed(self, resource):
    changes = _Changes()
    self._update_changes_caused_by_changed(changes, resource)
    self._perform_changes(changes)

</t>
<t tx="ekr.20080516150804.820">def _update_changes_caused_by_changed(self, changes, changed):
    if changed in self.resources:
        changes.add_changed(changed)
    if self._is_parent_changed(changed):
        changes.add_changed(changed.parent)

</t>
<t tx="ekr.20080516150804.821">def _update_changes_caused_by_moved(self, changes, resource,
                                    new_resource=None):
    if resource in self.resources:
        changes.add_removed(resource, new_resource)
    if new_resource in self.resources:
        changes.add_created(new_resource)
    if resource.is_folder():
        for file in list(self.resources):
            if resource.contains(file):
                new_file = self._calculate_new_resource(
                    resource, new_resource, file)
                changes.add_removed(file, new_file)
    if self._is_parent_changed(resource):
        changes.add_changed(resource.parent)
    if new_resource is not None:
        if self._is_parent_changed(new_resource):
            changes.add_changed(new_resource.parent)

</t>
<t tx="ekr.20080516150804.822">def _is_parent_changed(self, child):
    return child.parent in self.resources

</t>
<t tx="ekr.20080516150804.823">def resource_moved(self, resource, new_resource):
    changes = _Changes()
    self._update_changes_caused_by_moved(changes, resource, new_resource)
    self._perform_changes(changes)

</t>
<t tx="ekr.20080516150804.824">def resource_created(self, resource):
    changes = _Changes()
    self._update_changes_caused_by_created(changes, resource)
    self._perform_changes(changes)

</t>
<t tx="ekr.20080516150804.825">def _update_changes_caused_by_created(self, changes, resource):
    if resource in self.resources:
        changes.add_created(resource)
    if self._is_parent_changed(resource):
        changes.add_changed(resource.parent)

</t>
<t tx="ekr.20080516150804.826">def resource_removed(self, resource):
    changes = _Changes()
    self._update_changes_caused_by_moved(changes, resource)
    self._perform_changes(changes)

</t>
<t tx="ekr.20080516150804.827">def _perform_changes(self, changes):
    for resource in changes.changes:
        self.observer.resource_changed(resource)
        self.resources[resource] = self.timekeeper.get_indicator(resource)
    for resource, new_resource in changes.moves.items():
        self.resources[resource] = None
        if new_resource is not None:
            self.observer.resource_moved(resource, new_resource)
        else:
            self.observer.resource_removed(resource)
    for resource in changes.creations:
        self.observer.resource_created(resource)
        self.resources[resource] = self.timekeeper.get_indicator(resource)

</t>
<t tx="ekr.20080516150804.828">def validate(self, resource):
    changes = _Changes()
    for file in self._search_resource_moves(resource):
        if file in self.resources:
            self._update_changes_caused_by_moved(changes, file)
    for file in self._search_resource_changes(resource):
        if file in self.resources:
            self._update_changes_caused_by_changed(changes, file)
    for file in self._search_resource_creations(resource):
        if file in self.resources:
            changes.add_created(file)
    self._perform_changes(changes)

</t>
<t tx="ekr.20080516150804.829">def _search_resource_creations(self, resource):
    creations = set()
    if resource in self.resources and resource.exists() and \
       self.resources[resource] is None:
        creations.add(resource)
    if resource.is_folder():
        for file in self.resources:
            if file.exists() and resource.contains(file) and \
               self.resources[file] is None:
                creations.add(file)
    return creations

</t>
<t tx="ekr.20080516150804.830">def _search_resource_moves(self, resource):
    all_moved = set()
    if resource in self.resources and not resource.exists():
        all_moved.add(resource)
    if resource.is_folder():
        for file in self.resources:
            if resource.contains(file):
                if not file.exists():
                    all_moved.add(file)
    moved = set(all_moved)
    for folder in [file for file in all_moved if file.is_folder()]:
        if folder in moved:
            for file in list(moved):
                if folder.contains(file):
                    moved.remove(file)
    return moved

</t>
<t tx="ekr.20080516150804.831">def _search_resource_changes(self, resource):
    changed = set()
    if resource in self.resources and self._is_changed(resource):
        changed.add(resource)
    if resource.is_folder():
        for file in self.resources:
            if file.exists() and resource.contains(file):
                if self._is_changed(file):
                    changed.add(file)
    return changed

</t>
<t tx="ekr.20080516150804.832">def _is_changed(self, resource):
    if self.resources[resource] is None:
        return False
    return self.resources[resource] != self.timekeeper.get_indicator(resource)

</t>
<t tx="ekr.20080516150804.833">def _calculate_new_resource(self, main, new_main, resource):
    if new_main is None:
        return None
    diff = resource.path[len(main.path):]
    return resource.project.get_resource(new_main.path + diff)


</t>
<t tx="ekr.20080516150804.834">class ChangeIndicator(object):
    @others
</t>
<t tx="ekr.20080516150804.835">
def get_indicator(self, resource):
    """Return the modification time and size of a `Resource`."""
    path = resource.real_path
    # on dos, mtime does not change for a folder when files are added
    if os.name != 'posix' and os.path.isdir(path):
        return (os.path.getmtime(path),
                len(os.listdir(path)),
                os.path.getsize(path))
    return (os.path.getmtime(path),
            os.path.getsize(path))


</t>
<t tx="ekr.20080516150804.836">class _Changes(object):
    @others
</t>
<t tx="ekr.20080516150804.837">
def __init__(self):
    self.changes = set()
    self.creations = set()
    self.moves = {}

</t>
<t tx="ekr.20080516150804.838">def add_changed(self, resource):
    self.changes.add(resource)

</t>
<t tx="ekr.20080516150804.839">def add_removed(self, resource, new_resource=None):
    self.moves[resource] = new_resource

</t>
<t tx="ekr.20080516150804.840">def add_created(self, resource):
    self.creations.add(resource)
</t>
<t tx="ekr.20080516150804.841">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.842">import os
import re

import rope.base.change
import rope.base.fscommands
from rope.base import exceptions


</t>
<t tx="ekr.20080516150804.843">class Resource(object):
    """Represents files and folders in a project"""
    @others
</t>
<t tx="ekr.20080516150804.844">
def __init__(self, project, path):
    self.project = project
    self._path = path

</t>
<t tx="ekr.20080516150804.845">def move(self, new_location):
    """Move resource to `new_location`"""
    self._perform_change(rope.base.change.MoveResource(self, new_location),
                         'Moving &lt;%s&gt; to &lt;%s&gt;' % (self.path, new_location))

</t>
<t tx="ekr.20080516150804.846">def remove(self):
    """Remove resource from the project"""
    self._perform_change(rope.base.change.RemoveResource(self),
                         'Removing &lt;%s&gt;' % self.path)

</t>
<t tx="ekr.20080516150804.847">def is_folder(self):
    """Return true if the resource is a folder"""

</t>
<t tx="ekr.20080516150804.848">def create(self):
    """Create this resource"""

</t>
<t tx="ekr.20080516150804.849">def exists(self):
    return os.path.exists(self.real_path)

</t>
<t tx="ekr.20080516150804.850">@property
def parent(self):
    parent = '/'.join(self.path.split('/')[0:-1])
    return self.project.get_resource(parent)

</t>
<t tx="ekr.20080516150804.851">@property
def path(self):
    """Return the path of this resource relative to the project root

    The path is the list of parent directories separated by '/' followed
    by the resource name.
    """
    return self._path

</t>
<t tx="ekr.20080516150804.852">@property
def name(self):
    """Return the name of this resource"""
    return self.path.split('/')[-1]

</t>
<t tx="ekr.20080516150804.853">@property
def real_path(self):
    """Return the file system path of this resource"""
    return self.project._get_resource_path(self.path)

</t>
<t tx="ekr.20080516150804.854">def _get_destination_for_move(self, destination):
    dest_path = self.project._get_resource_path(destination)
    if os.path.isdir(dest_path):
        if destination != '':
            return destination + '/' + self.name
        else:
            return self.name
    return destination

</t>
<t tx="ekr.20080516150804.855">def __eq__(self, obj):
    return self.__class__ == obj.__class__ and self.path == obj.path

</t>
<t tx="ekr.20080516150804.856">def __hash__(self):
    return hash(self.path)

</t>
<t tx="ekr.20080516150804.857">def _perform_change(self, change_, description):
    changes = rope.base.change.ChangeSet(description)
    changes.add_change(change_)
    self.project.do(changes)


</t>
<t tx="ekr.20080516150804.858">class File(Resource):
    """Represents a file"""
    @others
</t>
<t tx="ekr.20080516150804.859">
def __init__(self, project, name):
    super(File, self).__init__(project, name)

</t>
<t tx="ekr.20080516150804.860">def read(self):
    data = self.read_bytes()
    try:
        return rope.base.fscommands.file_data_to_unicode(data)
    except UnicodeDecodeError, e:
        raise exceptions.ModuleDecodeError(self.path, e.reason)

</t>
<t tx="ekr.20080516150804.861">def read_bytes(self):
    return open(self.real_path, 'rb').read()

</t>
<t tx="ekr.20080516150804.862">def write(self, contents):
    try:
        if contents == self.read():
            return
    except IOError:
        pass
    self._perform_change(rope.base.change.ChangeContents(self, contents),
                         'Writing file &lt;%s&gt;' % self.path)

</t>
<t tx="ekr.20080516150804.863">def is_folder(self):
    return False

</t>
<t tx="ekr.20080516150804.864">def create(self):
    self.parent.create_file(self.name)


</t>
<t tx="ekr.20080516150804.865">class Folder(Resource):
    """Represents a folder"""
    @others
</t>
<t tx="ekr.20080516150804.866">
def __init__(self, project, name):
    super(Folder, self).__init__(project, name)

</t>
<t tx="ekr.20080516150804.867">def is_folder(self):
    return True

</t>
<t tx="ekr.20080516150804.868">def get_children(self):
    """Return the children of this folder"""
    path = self.real_path
    result = []
    content = os.listdir(path)
    for name in content:
        try:
            child = self.get_child(name)
        except exceptions.ResourceNotFoundError:
            continue
        if not self.project.is_ignored(child):
            result.append(self.get_child(name))
    return result

</t>
<t tx="ekr.20080516150804.869">def create_file(self, file_name):
    self._perform_change(
        rope.base.change.CreateFile(self, file_name),
        'Creating file &lt;%s&gt;' % self._get_child_path(file_name))
    return self.get_child(file_name)

</t>
<t tx="ekr.20080516150804.870">def create_folder(self, folder_name):
    self._perform_change(
        rope.base.change.CreateFolder(self, folder_name),
        'Creating folder &lt;%s&gt;' % self._get_child_path(folder_name))
    return self.get_child(folder_name)

</t>
<t tx="ekr.20080516150804.871">def _get_child_path(self, name):
    if self.path:
        return self.path + '/' + name
    else:
        return name

</t>
<t tx="ekr.20080516150804.872">def get_child(self, name):
    if self.path:
        child_path = self.path + '/' + name
    else:
        child_path = name
    return self.project.get_resource(child_path)

</t>
<t tx="ekr.20080516150804.873">def has_child(self, name):
    try:
        self.get_child(name)
        return True
    except exceptions.ResourceNotFoundError:
        return False

</t>
<t tx="ekr.20080516150804.874">def get_files(self):
    return [resource for resource in self.get_children()
            if not resource.is_folder()]

</t>
<t tx="ekr.20080516150804.875">def get_folders(self):
    return [resource for resource in self.get_children()
            if resource.is_folder()]

</t>
<t tx="ekr.20080516150804.876">def contains(self, resource):
    if self == resource:
        return False
    return self.path == '' or resource.path.startswith(self.path + '/')

</t>
<t tx="ekr.20080516150804.877">def create(self):
    self.parent.create_folder(self.name)


</t>
<t tx="ekr.20080516150804.878">class _ResourceMatcher(object):
    @others
</t>
<t tx="ekr.20080516150804.879">
def __init__(self):
    self.patterns = []
    self._compiled_patterns = []

</t>
<t tx="ekr.20080516150804.880">def set_patterns(self, patterns):
    """Specify which resources to match

    `patterns` is a `list` of `str`\s that can contain ``*`` and
    ``?`` signs for matching resource names.

    """
    self._compiled_patterns = None
    self.patterns = patterns

</t>
<t tx="ekr.20080516150804.881">def _add_pattern(self, pattern):
    re_pattern = pattern.replace('.', '\\.').\
                 replace('*', '[^/]*').replace('?', '[^/]').\
                 replace('//', '/(.*/)?')
    re_pattern = '^(.*/)?' + re_pattern + '(/.*)?$'
    self.compiled_patterns.append(re.compile(re_pattern))

</t>
<t tx="ekr.20080516150804.882">def does_match(self, resource):
    for pattern in self.compiled_patterns:
        if pattern.match(resource.path):
            return True
    path = os.path.join(resource.project.address,
                        *resource.path.split('/'))
    if os.path.islink(path):
        return True
    return False

</t>
<t tx="ekr.20080516150804.883">@property
def compiled_patterns(self):
    if self._compiled_patterns is None:
        self._compiled_patterns = []
        for pattern in self.patterns:
            self._add_pattern(pattern)
    return self._compiled_patterns
</t>
<t tx="ekr.20080516150804.884">@language python
@tabwidth -4
@others
_str = re.compile('%s|%s' % (codeanalyze.get_comment_pattern(),
                             codeanalyze.get_string_pattern()))
_parens = re.compile(r'[\({\[\]}\)\n]')
</t>
<t tx="ekr.20080516150804.885">"""A module to ease code analysis

This module is here to help source code analysis.
"""
import re

from rope.base import codeanalyze, utils


</t>
<t tx="ekr.20080516150804.886">@utils.cached(7)
def real_code(source):
    """Simplify `source` for analysis

    It replaces:

    * comments with spaces
    * strs with a new str filled with spaces
    * implicit and explicit continuations with spaces
    * tabs and semicolons with spaces

    The resulting code is a lot easier to analyze if we are interested
    only in offsets.
    """
    collector = codeanalyze.ChangeCollector(source)
    for start, end in ignored_regions(source):
        if source[start] == '#':
            replacement = ' ' * (end - start)
        else:
            replacement = '"%s"' % (' ' * (end - start - 2))
        collector.add_change(start, end, replacement)
    source = collector.get_changed() or source
    collector = codeanalyze.ChangeCollector(source)
    parens = 0
    for match in _parens.finditer(source):
        i = match.start()
        c = match.group()
        if c in '({[':
            parens += 1
        if c in ')}]':
            parens -= 1
        if c == '\n' and parens &gt; 0:
            collector.add_change(i, i + 1, ' ')
    source = collector.get_changed() or source
    return source.replace('\\\n', '  ').replace('\t', ' ').replace(';', '\n')


</t>
<t tx="ekr.20080516150804.887">@utils.cached(7)
def ignored_regions(source):
    """Return ignored regions like strings and comments in `source` """
    return [(match.start(), match.end()) for match in _str.finditer(source)]


</t>
<t tx="ekr.20080516150804.888">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.889">import warnings

from rope.base import exceptions


</t>
<t tx="ekr.20080516150804.890">class TaskHandle(object):
    @others
</t>
<t tx="ekr.20080516150804.891">
def __init__(self, name='Task', interrupts=True):
    """Construct a TaskHandle

    If `interrupts` is `False` the task won't be interrupted by
    calling `TaskHandle.stop()`.

    """
    self.name = name
    self.interrupts = interrupts
    self.stopped = False
    self.job_sets = []
    self.observers = []

</t>
<t tx="ekr.20080516150804.892">def stop(self):
    """Interrupts the refactoring"""
    if self.interrupts:
        self.stopped = True
        self._inform_observers()

</t>
<t tx="ekr.20080516150804.893">def current_jobset(self):
    """Return the current `JobSet`"""
    if self.job_sets:
        return self.job_sets[-1]

</t>
<t tx="ekr.20080516150804.894">def add_observer(self, observer):
    """Register an observer for this task handle

    The observer is notified whenever the task is stopped or
    a job gets finished.

    """
    self.observers.append(observer)

</t>
<t tx="ekr.20080516150804.895">def is_stopped(self):
    return self.stopped

</t>
<t tx="ekr.20080516150804.896">def get_jobsets(self):
    return self.job_sets

</t>
<t tx="ekr.20080516150804.897">def create_jobset(self, name='JobSet', count=None):
    result = JobSet(self, name=name, count=count)
    self.job_sets.append(result)
    self._inform_observers()
    return result

</t>
<t tx="ekr.20080516150804.898">def _inform_observers(self):
    for observer in list(self.observers):
        observer()


</t>
<t tx="ekr.20080516150804.899">class JobSet(object):
    @others
</t>
<t tx="ekr.20080516150804.900">
def __init__(self, handle, name, count):
    self.handle = handle
    self.name = name
    self.count = count
    self.done = 0
    self.job_name = None

</t>
<t tx="ekr.20080516150804.901">def started_job(self, name):
    self.check_status()
    self.job_name = name
    self.handle._inform_observers()

</t>
<t tx="ekr.20080516150804.902">def finished_job(self):
    self.check_status()
    self.handle._inform_observers()
    self.job_name = None
    self.done += 1

</t>
<t tx="ekr.20080516150804.903">def check_status(self):
    if self.handle.is_stopped():
        raise exceptions.InterruptedTaskError()

</t>
<t tx="ekr.20080516150804.904">def get_active_job_name(self):
    return self.job_name

</t>
<t tx="ekr.20080516150804.905">def get_percent_done(self):
    if self.count is not None and self.count &gt; 0:
        percent = self.done * 100 // self.count
        return min(percent, 100)

</t>
<t tx="ekr.20080516150804.906">def get_name(self):
    return self.name


</t>
<t tx="ekr.20080516150804.907">class NullTaskHandle(object):
    @others
</t>
<t tx="ekr.20080516150804.908">
def __init__(self):
    pass

</t>
<t tx="ekr.20080516150804.909">def is_stopped(self):
    return False

</t>
<t tx="ekr.20080516150804.910">def stop(self):
    pass

</t>
<t tx="ekr.20080516150804.911">def create_jobset(self, *args, **kwds):
    return NullJobSet()

</t>
<t tx="ekr.20080516150804.912">def get_jobsets(self):
    return []

</t>
<t tx="ekr.20080516150804.913">def add_observer(self, observer):
    pass


</t>
<t tx="ekr.20080516150804.914">class NullJobSet(object):
    @others
</t>
<t tx="ekr.20080516150804.915">
def started_job(self, name):
    pass

</t>
<t tx="ekr.20080516150804.916">def finished_job(self):
    pass

</t>
<t tx="ekr.20080516150804.917">def check_status(self):
    pass

</t>
<t tx="ekr.20080516150804.918">def get_active_job_name(self):
    pass

</t>
<t tx="ekr.20080516150804.919">def get_percent_done(self):
    pass

</t>
<t tx="ekr.20080516150804.920">def get_name(self):
    pass
</t>
<t tx="ekr.20080516150804.921">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.922">def cacheit(func):
    """A decorator that caches the return value of a function"""

    name = '_' + func.__name__
    def _wrapper(self, *args, **kwds):
        if not hasattr(self, name):
            setattr(self, name, func(self, *args, **kwds))
        return getattr(self, name)
    return _wrapper


</t>
<t tx="ekr.20080516150804.923">def prevent_recursion(default):
    """A decorator that returns the return value of `default` in recursions"""
    def decorator(func):
        name = '_calling_%s_' % func.__name__
        def newfunc(self, *args, **kwds):
            if getattr(self, name, False):
                return default()
            setattr(self, name, True)
            try:
                return func(self, *args, **kwds)
            finally:
                setattr(self, name, False)
        return newfunc
    return decorator


</t>
<t tx="ekr.20080516150804.924">def ignore_exception(exception_class):
    """A decorator that ignores `exception_class` exceptions"""
    def _decorator(func):
        def newfunc(*args, **kwds):
            try:
                return func(*args, **kwds)
            except exception_class:
                pass
        return newfunc
    return _decorator

</t>
<t tx="ekr.20080516150804.925">def cached(count):
    """A caching decorator based on parameter objects"""
    def decorator(func):
        return _Cached(func, count)
    return decorator


</t>
<t tx="ekr.20080516150804.926">class _Cached(object):
    @others
</t>
<t tx="ekr.20080516150804.927">
def __init__(self, func, count):
    self.func = func
    self.cache = []
    self.count = count

</t>
<t tx="ekr.20080516150804.928">def __call__(self, *args, **kwds):
    key = (args, kwds)
    for cached_key, cached_result in self.cache:
        if cached_key == key:
            return cached_result
    result = self.func(*args, **kwds)
    self.cache.append((key, result))
    if len(self.cache) &gt; self.count:
        del self.cache[0]
    return result
</t>
<t tx="ekr.20080516150804.929">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.930">import bisect

import rope.base.simplify


</t>
<t tx="ekr.20080516150804.931">def get_name_at(resource, offset):
    source_code = resource.read()
    word_finder = Worder(source_code)
    return word_finder.get_word_at(offset)


</t>
<t tx="ekr.20080516150804.932">class Worder(object):
    """A class for finding boundaries of words and expressions

    Note that in these methods, offset should be the index of the
    character not the index of the character after it.
    """
    @others
</t>
<t tx="ekr.20080516150804.933">
def __init__(self, code, handle_ignores=False):
    simplified = rope.base.simplify.real_code(code)
    self.code_finder = _RealFinder(simplified, code)
    self.handle_ignores = handle_ignores
    self.code = code

</t>
<t tx="ekr.20080516150804.934">def _init_ignores(self):
    ignores = rope.base.simplify.ignored_regions(self.code)
    self.dumb_finder = _RealFinder(self.code, self.code)
    self.starts = [ignored[0] for ignored in ignores]
    self.ends = [ignored[1] for ignored in ignores]

</t>
<t tx="ekr.20080516150804.935">def _context_call(self, name, offset):
    if self.handle_ignores:
        if not hasattr(self, 'starts'):
            self._init_ignores()
        start = bisect.bisect(self.starts, offset)
        if start &gt; 0 and offset &lt; self.ends[start - 1]:
            return getattr(self.dumb_finder, name)(offset)
    return getattr(self.code_finder, name)(offset)

</t>
<t tx="ekr.20080516150804.936">def get_primary_at(self, offset):
    return self._context_call('get_primary_at', offset)

</t>
<t tx="ekr.20080516150804.937">def get_word_at(self, offset):
    return self._context_call('get_word_at', offset)

</t>
<t tx="ekr.20080516150804.938">def get_primary_range(self, offset):
    return self._context_call('get_primary_range', offset)

</t>
<t tx="ekr.20080516150804.939">def get_splitted_primary_before(self, offset):
    return self._context_call('get_splitted_primary_before', offset)

</t>
<t tx="ekr.20080516150804.940">def get_word_range(self, offset):
    return self._context_call('get_word_range', offset)

</t>
<t tx="ekr.20080516150804.941">def is_function_keyword_parameter(self, offset):
    return self.code_finder.is_function_keyword_parameter(offset)

</t>
<t tx="ekr.20080516150804.942">def is_a_class_or_function_name_in_header(self, offset):
    return self.code_finder.is_a_class_or_function_name_in_header(offset)

</t>
<t tx="ekr.20080516150804.943">def is_from_statement_module(self, offset):
    return self.code_finder.is_from_statement_module(offset)

</t>
<t tx="ekr.20080516150804.944">def is_from_aliased(self, offset):
    return self.code_finder.is_from_aliased(offset)

</t>
<t tx="ekr.20080516150804.945">def find_parens_start_from_inside(self, offset):
    return self.code_finder.find_parens_start_from_inside(offset)

</t>
<t tx="ekr.20080516150804.946">def is_a_name_after_from_import(self, offset):
    return self.code_finder.is_a_name_after_from_import(offset)

</t>
<t tx="ekr.20080516150804.947">def is_from_statement(self, offset):
    return self.code_finder.is_from_statement(offset)

</t>
<t tx="ekr.20080516150804.948">def get_from_aliased(self, offset):
    return self.code_finder.get_from_aliased(offset)

</t>
<t tx="ekr.20080516150804.949">def is_import_statement(self, offset):
    return self.code_finder.is_import_statement(offset)

</t>
<t tx="ekr.20080516150804.950">def is_assigned_here(self, offset):
    return self.code_finder.is_assigned_here(offset)

</t>
<t tx="ekr.20080516150804.951">def is_a_function_being_called(self, offset):
    return self.code_finder.is_a_function_being_called(offset)

</t>
<t tx="ekr.20080516150804.952">def get_word_parens_range(self, offset):
    return self.code_finder.get_word_parens_range(offset)

</t>
<t tx="ekr.20080516150804.953">def is_name_assigned_in_class_body(self, offset):
    return self.code_finder.is_name_assigned_in_class_body(offset)

</t>
<t tx="ekr.20080516150804.954">def is_on_function_call_keyword(self, offset):
    return self.code_finder.is_on_function_call_keyword(offset)

</t>
<t tx="ekr.20080516150804.955">def _find_parens_start(self, offset):
    return self.code_finder._find_parens_start(offset)

</t>
<t tx="ekr.20080516150804.956">def get_parameters(self, first, last):
    return self.code_finder.get_parameters(first, last)

</t>
<t tx="ekr.20080516150804.957">def get_from_module(self, offset):
    return self.code_finder.get_from_module(offset)

</t>
<t tx="ekr.20080516150804.958">def is_assigned_in_a_tuple_assignment(self, offset):
    return self.code_finder.is_assigned_in_a_tuple_assignment(offset)

</t>
<t tx="ekr.20080516150804.959">def get_assignment_type(self, offset):
    return self.code_finder.get_assignment_type(offset)

</t>
<t tx="ekr.20080516150804.960">def get_function_and_args_in_header(self, offset):
    return self.code_finder.get_function_and_args_in_header(offset)

</t>
<t tx="ekr.20080516150804.961">def find_function_offset(self, offset):
    return self.code_finder.find_function_offset(offset)


</t>
<t tx="ekr.20080516150804.962">class _RealFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.963">
def __init__(self, code, raw):
    self.code = code
    self.raw = raw

</t>
<t tx="ekr.20080516150804.964">def _find_word_start(self, offset):
    current_offset = offset
    while current_offset &gt;= 0 and self._is_id_char(current_offset):
        current_offset -= 1
    return current_offset + 1

</t>
<t tx="ekr.20080516150804.965">def _find_word_end(self, offset):
    while offset + 1 &lt; len(self.code) and self._is_id_char(offset + 1):
        offset += 1
    return offset

</t>
<t tx="ekr.20080516150804.966">def _find_last_non_space_char(self, offset):
    while offset &gt;= 0 and self.code[offset].isspace():
        if self.code[offset] == '\n':
            return offset
        offset -= 1
    return max(-1, offset)

</t>
<t tx="ekr.20080516150804.967">def get_word_at(self, offset):
    offset = self._get_fixed_offset(offset)
    return self.raw[self._find_word_start(offset):
                    self._find_word_end(offset) + 1]

</t>
<t tx="ekr.20080516150804.968">def _get_fixed_offset(self, offset):
    if offset &gt;= len(self.code):
        return offset - 1
    if not self._is_id_char(offset):
        if offset &gt; 0 and self._is_id_char(offset - 1):
            return offset - 1
        if offset &lt; len(self.code) - 1 and self._is_id_char(offset + 1):
            return offset + 1
    return offset

</t>
<t tx="ekr.20080516150804.969">def _is_id_char(self, offset):
    return self.code[offset].isalnum() or self.code[offset] == '_'

</t>
<t tx="ekr.20080516150804.970">def _find_string_start(self, offset):
    kind = self.code[offset]
    try:
        return self.code.rindex(kind, 0, offset - 1)
    except ValueError:
        return 0

</t>
<t tx="ekr.20080516150804.971">def _find_parens_start(self, offset):
    offset = self._find_last_non_space_char(offset - 1)
    while offset &gt;= 0 and self.code[offset] not in '[({':
        if self.code[offset] not in ':,':
            offset = self._find_primary_start(offset)
        offset = self._find_last_non_space_char(offset - 1)
    return offset

</t>
<t tx="ekr.20080516150804.972">def _find_atom_start(self, offset):
    old_offset = offset
    if self.code[offset] == '\n':
        return offset + 1
    if self.code[offset].isspace():
        offset = self._find_last_non_space_char(offset)
    if self.code[offset] in '\'"':
        return self._find_string_start(offset)
    if self.code[offset] in ')]}':
        return self._find_parens_start(offset)
    if self._is_id_char(offset):
        return self._find_word_start(offset)
    return old_offset

</t>
<t tx="ekr.20080516150804.973">def _find_primary_without_dot_start(self, offset):
    """It tries to find the undotted primary start

    It is different from `self._get_atom_start()` in that it
    follows function calls, too; such as in ``f(x)``.

    """
    last_atom = offset
    offset = self._find_last_non_space_char(last_atom)
    while offset &gt; 0 and self.code[offset] in ')]':
        last_atom = self._find_parens_start(offset)
        offset = self._find_last_non_space_char(last_atom - 1)
    if offset &gt;= 0 and (self.code[offset] in '"\'})]' or
                        self._is_id_char(offset)):
        return self._find_atom_start(offset)
    return last_atom

</t>
<t tx="ekr.20080516150804.974">def _find_primary_start(self, offset):
    if offset &gt;= len(self.code):
        offset = len(self.code) - 1
    if self.code[offset] != '.':
        offset = self._find_primary_without_dot_start(offset)
    else:
        offset = offset + 1
    while offset &gt; 0:
        prev = self._find_last_non_space_char(offset - 1)
        if offset &lt;= 0 or self.code[prev] != '.':
            break
        offset = self._find_primary_without_dot_start(prev - 1)
        if not self._is_id_char(offset):
            break

    return offset

</t>
<t tx="ekr.20080516150804.975">def get_primary_at(self, offset):
    offset = self._get_fixed_offset(offset)
    start, end = self.get_primary_range(offset)
    return self.raw[start:end].strip()

</t>
<t tx="ekr.20080516150804.976">def get_splitted_primary_before(self, offset):
    """returns expression, starting, starting_offset

    This function is used in `rope.codeassist.assist` function.
    """
    if offset == 0:
        return ('', '', 0)
    end = offset - 1
    word_start = self._find_atom_start(end)
    real_start = self._find_primary_start(end)
    if self.code[word_start:offset].strip() == '':
        word_start = end
    if self.code[end].isspace():
        word_start = end
    if self.code[real_start:word_start].strip() == '':
        real_start = word_start
    if real_start == word_start == end and not self._is_id_char(end):
        return ('', '', offset)
    if real_start == word_start:
        return ('', self.raw[word_start:offset], word_start)
    else:
        if self.code[end] == '.':
            return (self.raw[real_start:end], '', offset)
        last_dot_position = word_start
        if self.code[word_start] != '.':
            last_dot_position = self._find_last_non_space_char(word_start - 1)
        last_char_position = self._find_last_non_space_char(last_dot_position - 1)
        if self.code[word_start].isspace():
            word_start = offset
        return (self.raw[real_start:last_char_position + 1],
                self.raw[word_start:offset], word_start)

</t>
<t tx="ekr.20080516150804.977">def _get_line_start(self, offset):
    try:
        return self.code.rindex('\n', 0, offset + 1)
    except ValueError:
        return 0

</t>
<t tx="ekr.20080516150804.978">def _get_line_end(self, offset):
    try:
        return self.code.index('\n', offset)
    except ValueError:
        return len(self.code)

</t>
<t tx="ekr.20080516150804.979">def is_name_assigned_in_class_body(self, offset):
    word_start = self._find_word_start(offset - 1)
    word_end = self._find_word_end(offset) + 1
    if '.' in self.code[word_start:word_end]:
        return False
    line_start = self._get_line_start(word_start)
    line = self.code[line_start:word_start].strip()
    return not line and self.get_assignment_type(offset) == '='

</t>
<t tx="ekr.20080516150804.980">def is_a_class_or_function_name_in_header(self, offset):
    word_start = self._find_word_start(offset - 1)
    line_start = self._get_line_start(word_start)
    prev_word = self.code[line_start:word_start].strip()
    return prev_word in ['def', 'class']

</t>
<t tx="ekr.20080516150804.981">def _find_first_non_space_char(self, offset):
    if offset &gt;= len(self.code):
        return len(self.code)
    while offset &lt; len(self.code) and self.code[offset].isspace():
        if self.code[offset] == '\n':
            return offset
        offset += 1
    return offset

</t>
<t tx="ekr.20080516150804.982">def is_a_function_being_called(self, offset):
    word_end = self._find_word_end(offset) + 1
    next_char = self._find_first_non_space_char(word_end)
    return next_char &lt; len(self.code) and \
           self.code[next_char] == '(' and \
           not self.is_a_class_or_function_name_in_header(offset)

</t>
<t tx="ekr.20080516150804.983">def _find_import_end(self, start):
    return self._get_line_end(start)

</t>
<t tx="ekr.20080516150804.984">def is_import_statement(self, offset):
    try:
        last_import = self.code.rindex('import ', 0, offset)
    except ValueError:
        return False
    return self._find_import_end(last_import + 7) &gt;= offset

</t>
<t tx="ekr.20080516150804.985">def is_from_statement(self, offset):
    try:
        last_from = self.code.rindex('from ', 0, offset)
        from_import = self.code.index(' import ', last_from)
        from_names = from_import + 8
    except ValueError:
        return False
    from_names = self._find_first_non_space_char(from_names)
    return self._find_import_end(from_names) &gt;= offset

</t>
<t tx="ekr.20080516150804.986">def is_from_statement_module(self, offset):
    if offset &gt;= len(self.code) - 1:
        return False
    stmt_start = self._find_primary_start(offset)
    line_start = self._get_line_start(stmt_start)
    prev_word = self.code[line_start:stmt_start].strip()
    return prev_word == 'from'

</t>
<t tx="ekr.20080516150804.987">def is_a_name_after_from_import(self, offset):
    try:
        line_start = self._get_line_start(offset)
        last_from = self.code.rindex('from ', line_start, offset)
        from_import = self.code.index(' import ', last_from)
        from_names = from_import + 8
    except ValueError:
        return False
    if from_names - 1 &gt; offset:
        return False
    return self._find_import_end(from_names) &gt;= offset

</t>
<t tx="ekr.20080516150804.988">def get_from_module(self, offset):
    try:
        last_from = self.code.rindex('from ', 0, offset)
        import_offset = self.code.index(' import ', last_from)
        end = self._find_last_non_space_char(import_offset)
        return self.get_primary_at(end)
    except ValueError:
        pass

</t>
<t tx="ekr.20080516150804.989">def is_from_aliased(self, offset):
    if not self.is_a_name_after_from_import(offset):
        return False
    try:
        end = self._find_word_end(offset)
        as_end = min(self._find_word_end(end + 1), len(self.code))
        as_start = self._find_word_start(as_end)
        if self.code[as_start:as_end + 1] == 'as':
            return True
    except ValueError:
        return False

</t>
<t tx="ekr.20080516150804.990">def get_from_aliased(self, offset):
    try:
        end = self._find_word_end(offset)
        as_ = self._find_word_end(end + 1)
        alias = self._find_word_end(as_ + 1)
        start = self._find_word_start(alias)
        return self.raw[start:alias + 1]
    except ValueError:
        pass

</t>
<t tx="ekr.20080516150804.991">def is_function_keyword_parameter(self, offset):
    word_end = self._find_word_end(offset)
    if word_end + 1 == len(self.code):
        return False
    next_char = self._find_first_non_space_char(word_end + 1)
    equals = self.code[next_char:next_char + 2]
    if equals == '==' or not equals.startswith('='):
        return False
    word_start = self._find_word_start(offset)
    prev_char = self._find_last_non_space_char(word_start - 1)
    return prev_char - 1 &gt;= 0 and self.code[prev_char] in ',('

</t>
<t tx="ekr.20080516150804.992">def is_on_function_call_keyword(self, offset):
    stop = self._get_line_start(offset)
    if self._is_id_char(offset):
        offset = self._find_word_start(offset) - 1
    offset = self._find_last_non_space_char(offset)
    if offset &lt;= stop or self.code[offset] not in '(,':
        return False
    parens_start = self.find_parens_start_from_inside(offset)
    return stop &lt; parens_start

</t>
<t tx="ekr.20080516150804.993">def find_parens_start_from_inside(self, offset):
    stop = self._get_line_start(offset)
    opens = 1
    while offset &gt; stop:
        if self.code[offset] == '(':
            break
        if self.code[offset] != ',':
            offset = self._find_primary_start(offset)
        offset -= 1
    return max(stop, offset)

</t>
<t tx="ekr.20080516150804.994">def is_assigned_here(self, offset):
    return self.get_assignment_type(offset) is not None

</t>
<t tx="ekr.20080516150804.995">def get_assignment_type(self, offset):
    # XXX: does not handle tuple assignments
    word_end = self._find_word_end(offset)
    next_char = self._find_first_non_space_char(word_end + 1)
    single = self.code[next_char:next_char + 1]
    double = self.code[next_char:next_char + 2]
    triple = self.code[next_char:next_char + 3]
    if double != '==':
        for op in [single, double, triple]:
            if op.endswith('='):
                return op

</t>
<t tx="ekr.20080516150804.996">def get_primary_range(self, offset):
    start = self._find_primary_start(offset)
    end = self._find_word_end(offset) + 1
    return (start, end)

</t>
<t tx="ekr.20080516150804.997">def get_word_range(self, offset):
    offset = max(0, offset)
    start = self._find_word_start(offset)
    end = self._find_word_end(offset) + 1
    return (start, end)

</t>
<t tx="ekr.20080516150804.998">def get_word_parens_range(self, offset):
    end = self._find_word_end(offset)
    start_parens = self.code.index('(', end)
    index = start_parens
    open_count = 0
    while index &lt; len(self.code):
        if self.code[index] == '(':
            open_count += 1
        if self.code[index] == ')':
            open_count -= 1
        if open_count == 0:
            return (start_parens, index + 1)
        index += 1
    return (start_parens, index)

</t>
<t tx="ekr.20080516150804.999">def get_parameters(self, first, last):
    keywords = []
    args = []
    current = self._find_last_non_space_char(last - 1)
    while current &gt; first:
        primary_start = current
        current = self._find_primary_start(current)
        while current != first and self.code[current] not in '=,':
            current = self._find_last_non_space_char(current - 1)
        primary = self.raw[current + 1:primary_start + 1].strip()
        if self.code[current] == '=':
            primary_start = current - 1
            current -= 1
            while current != first and self.code[current] not in ',':
                current = self._find_last_non_space_char(current - 1)
            param_name = self.raw[current + 1:primary_start + 1].strip()
            keywords.append((param_name, primary))
        else:
            args.append(primary)
        current = self._find_last_non_space_char(current - 1)
    args.reverse()
    keywords.reverse()
    return args, keywords

</t>
<t tx="ekr.20080516150804.1000">def is_assigned_in_a_tuple_assignment(self, offset):
    start = self._get_line_start(offset)
    end = self._get_line_end(offset)
    primary_start = self._find_primary_start(offset)
    primary_end = self._find_word_end(offset)

    prev_char_offset = self._find_last_non_space_char(primary_start - 1)
    next_char_offset = self._find_first_non_space_char(primary_end + 1)
    next_char = prev_char = ''
    if prev_char_offset &gt;= start:
        prev_char = self.code[prev_char_offset]
    if next_char_offset &lt; end:
        next_char = self.code[next_char_offset]
    try:
        equals_offset = self.code.index('=', start, end)
    except ValueError:
        return False
    if prev_char not in '(,' and next_char not in ',)':
        return False
    parens_start = self.find_parens_start_from_inside(offset)
    # XXX: only handling (x, y) = value
    return offset &lt; equals_offset and \
           self.code[start:parens_start].strip() == ''

</t>
<t tx="ekr.20080516150804.1001">def get_function_and_args_in_header(self, offset):
    offset = self.find_function_offset(offset)
    lparens, rparens = self.get_word_parens_range(offset)
    return self.raw[offset:rparens + 1]

</t>
<t tx="ekr.20080516150804.1002">def find_function_offset(self, offset):
    while True:
        offset = self.code.index('def ', offset)
        if offset == 0 or not self._is_id_char(offset - 1):
            break
        offset += 1
    def_ = offset + 4
    return self._find_first_non_space_char(def_)
</t>
<t tx="ekr.20080516150804.1003">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1004">"""Base rope package

This package contains rope core modules that are used by other modules
and packages.

"""

__all__ = ['project', 'libutils', 'exceptions']
</t>
<t tx="ekr.20080516150804.1005"></t>
<t tx="ekr.20080516150804.1006">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1007">import cPickle as pickle
import marshal
import os
import socket
import subprocess
import sys
import tempfile
import threading


</t>
<t tx="ekr.20080516150804.1008">class PythonFileRunner(object):
    """A class for running python project files"""
    @others
</t>
<t tx="ekr.20080516150804.1009">
def __init__(self, pycore, file_, args=None, stdin=None,
             stdout=None, analyze_data=None):
    self.pycore = pycore
    self.file = file_
    self.analyze_data = analyze_data
    self.observers = []
    self.args = args
    self.stdin = stdin
    self.stdout = stdout

</t>
<t tx="ekr.20080516150804.1010">def run(self):
    """Execute the process"""
    env = dict(os.environ)
    file_path = self.file.real_path
    path_folders = self.pycore.get_source_folders() + \
                   self.pycore.get_python_path_folders()
    env['PYTHONPATH'] = os.pathsep.join(folder.real_path
                                        for folder in path_folders)
    runmod_path = self.pycore.find_module('rope.base.oi.runmod').real_path
    self.receiver = None
    self._init_data_receiving()
    send_info = '-'
    if self.receiver:
        send_info = self.receiver.get_send_info()
    args = [sys.executable, runmod_path, send_info,
            self.pycore.project.address, self.file.real_path]
    if self.analyze_data is None:
        del args[1:4]
    if self.args is not None:
        args.extend(self.args)
    self.process = subprocess.Popen(
        executable=sys.executable, args=args, env=env,
        cwd=os.path.split(file_path)[0], stdin=self.stdin,
        stdout=self.stdout, stderr=self.stdout, close_fds=os.name != 'nt')

</t>
<t tx="ekr.20080516150804.1011">def _init_data_receiving(self):
    if self.analyze_data is None:
        return
    # Disabling FIFO data transfer due to blocking when running
    # unittests in the GUI.
    # XXX: Handle FIFO data transfer for `rope.ui.testview`
    if True or os.name == 'nt':
        self.receiver = _SocketReceiver()
    else:
        self.receiver = _FIFOReceiver()
    self.receiving_thread = threading.Thread(target=self._receive_information)
    self.receiving_thread.setDaemon(True)
    self.receiving_thread.start()

</t>
<t tx="ekr.20080516150804.1012">def _receive_information(self):
    #temp = open('/dev/shm/info', 'w')
    for data in self.receiver.receive_data():
        self.analyze_data(data)
        #temp.write(str(data) + '\n')
    #temp.close()
    for observer in self.observers:
        observer()

</t>
<t tx="ekr.20080516150804.1013">def wait_process(self):
    """Wait for the process to finish"""
    self.process.wait()
    if self.analyze_data:
        self.receiving_thread.join()

</t>
<t tx="ekr.20080516150804.1014">def kill_process(self):
    """Stop the process"""
    if os.name != 'nt':
        os.kill(self.process.pid, 9)
    else:
        import ctypes
        ctypes.windll.kernel32.TerminateProcess(int(self.process._handle), -1)

</t>
<t tx="ekr.20080516150804.1015">def add_finishing_observer(self, observer):
    """Notify this observer when execution finishes"""
    self.observers.append(observer)


</t>
<t tx="ekr.20080516150804.1016">class _MessageReceiver(object):
    @others
</t>
<t tx="ekr.20080516150804.1017">
def receive_data(self):
    pass

</t>
<t tx="ekr.20080516150804.1018">def get_send_info(self):
    pass


</t>
<t tx="ekr.20080516150804.1019">class _SocketReceiver(_MessageReceiver):
    @others
</t>
<t tx="ekr.20080516150804.1020">
def __init__(self):
    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.data_port = 3037
    while self.data_port &lt; 4000:
        try:
            self.server_socket.bind(('', self.data_port))
            break
        except socket.error, e:
            self.data_port += 1
    self.server_socket.listen(1)

</t>
<t tx="ekr.20080516150804.1021">def get_send_info(self):
    return str(self.data_port)

</t>
<t tx="ekr.20080516150804.1022">def receive_data(self):
    conn, addr = self.server_socket.accept()
    self.server_socket.close()
    my_file = conn.makefile('r')
    while True:
        try:
            yield pickle.load(my_file)
        except EOFError:
            break
    my_file.close()
    conn.close()


</t>
<t tx="ekr.20080516150804.1023">class _FIFOReceiver(_MessageReceiver):
    @others
</t>
<t tx="ekr.20080516150804.1024">
def __init__(self):
    # XXX: this is insecure and might cause race conditions
    self.file_name = self._get_file_name()
    os.mkfifo(self.file_name)

</t>
<t tx="ekr.20080516150804.1025">def _get_file_name(self):
    prefix = tempfile.gettempdir() + '/__rope_'
    i = 0
    while os.path.exists(prefix + str(i).rjust(4, '0')):
        i += 1
    return prefix + str(i).rjust(4, '0')

</t>
<t tx="ekr.20080516150804.1026">def get_send_info(self):
    return self.file_name

</t>
<t tx="ekr.20080516150804.1027">def receive_data(self):
    my_file = open(self.file_name, 'rb')
    while True:
        try:
            yield marshal.load(my_file)
        except EOFError:
            break
    my_file.close()
    os.remove(self.file_name)
</t>
<t tx="ekr.20080516150804.1028">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1029">from rope.base.oi import objectdb


</t>
<t tx="ekr.20080516150804.1030">class MemoryDB(objectdb.FileDict):
    @others
</t>
<t tx="ekr.20080516150804.1031">
def __init__(self, project, persist=None):
    self.project = project
    self._persist = persist
    self.files = self
    self._load_files()
    self.project.data_files.add_write_hook(self.write)

</t>
<t tx="ekr.20080516150804.1032">def _load_files(self):
    self._files = {}
    if self.persist:
        result = self.project.data_files.read_data(
            'objectdb', compress=self.compress, import_=True)
        if result is not None:
            self._files = result

</t>
<t tx="ekr.20080516150804.1033">def keys(self):
    return self._files.keys()

</t>
<t tx="ekr.20080516150804.1034">def __contains__(self, key):
    return key in self._files

</t>
<t tx="ekr.20080516150804.1035">def __getitem__(self, key):
    return FileInfo(self._files[key])

</t>
<t tx="ekr.20080516150804.1036">def create(self, path):
    self._files[path] = {}

</t>
<t tx="ekr.20080516150804.1037">def rename(self, file, newfile):
    if file not in self._files:
        return
    self._files[newfile] = self._files[file]
    del self[file]

</t>
<t tx="ekr.20080516150804.1038">def __delitem__(self, file):
    del self._files[file]

</t>
<t tx="ekr.20080516150804.1039">def write(self):
    if self.persist:
        self.project.data_files.write_data('objectdb', self._files,
                                           self.compress)

</t>
<t tx="ekr.20080516150804.1040">@property
def compress(self):
    return self.project.prefs.get('compress_objectdb', False)

</t>
<t tx="ekr.20080516150804.1041">@property
def persist(self):
    if self._persist is not None:
        return self._persist
    else:
        return self.project.prefs.get('save_objectdb', False)


</t>
<t tx="ekr.20080516150804.1042">class FileInfo(objectdb.FileInfo):
    @others
</t>
<t tx="ekr.20080516150804.1043">
def __init__(self, scopes):
    self.scopes = scopes

</t>
<t tx="ekr.20080516150804.1044">def create_scope(self, key):
    self.scopes[key] = ScopeInfo()

</t>
<t tx="ekr.20080516150804.1045">def keys(self):
    return self.scopes.keys()

</t>
<t tx="ekr.20080516150804.1046">def __contains__(self, key):
    return key in self.scopes

</t>
<t tx="ekr.20080516150804.1047">def __getitem__(self, key):
    return self.scopes[key]

</t>
<t tx="ekr.20080516150804.1048">def __delitem__(self, key):
    del self.scopes[key]


</t>
<t tx="ekr.20080516150804.1049">class ScopeInfo(objectdb.ScopeInfo):
    @others
</t>
<t tx="ekr.20080516150804.1050">
def __init__(self):
    self.call_info = {}
    self.per_name = {}

</t>
<t tx="ekr.20080516150804.1051">def get_per_name(self, name):
    return self.per_name.get(name, None)

</t>
<t tx="ekr.20080516150804.1052">def save_per_name(self, name, value):
    self.per_name[name] = value

</t>
<t tx="ekr.20080516150804.1053">def get_returned(self, parameters):
    return self.call_info.get(parameters, None)

</t>
<t tx="ekr.20080516150804.1054">def get_call_infos(self):
    for args, returned in self.call_info.items():
        yield objectdb.CallInfo(args, returned)

</t>
<t tx="ekr.20080516150804.1055">def add_call(self, parameters, returned):
    self.call_info[parameters] = returned

</t>
<t tx="ekr.20080516150804.1056">def __getstate__(self):
    return (self.call_info, self.per_name)

</t>
<t tx="ekr.20080516150804.1057">def __setstate__(self, data):
    self.call_info, self.per_name = data
</t>
<t tx="ekr.20080516150804.1058">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1059">import UserDict


</t>
<t tx="ekr.20080516150804.1060">class ObjectDB(object):
    @others
</t>
<t tx="ekr.20080516150804.1061">
def __init__(self, db, validation):
    self.db = db
    self.validation = validation
    self.observers = []
    self.files = db.files

</t>
<t tx="ekr.20080516150804.1062">def validate_files(self):
    for file in list(self.files):
        if not self.validation.is_file_valid(file):
            del self.files[file]
            self._file_removed(file)

</t>
<t tx="ekr.20080516150804.1063">def validate_file(self, file):
    if file not in self.files:
        return
    for key in list(self.files[file]):
        if not self.validation.is_scope_valid(file, key):
            del self.files[file][key]

</t>
<t tx="ekr.20080516150804.1064">def file_moved(self, file, newfile):
    if file not in self.files:
        return
    self.files.rename(file, newfile)
    self._file_removed(file)
    self._file_added(newfile)

</t>
<t tx="ekr.20080516150804.1065">def get_files(self):
    return self.files.keys()

</t>
<t tx="ekr.20080516150804.1066">def get_returned(self, path, key, args):
    scope_info = self._get_scope_info(path, key, readonly=True)
    result = scope_info.get_returned(args)
    if self.validation.is_value_valid(result):
        return result

</t>
<t tx="ekr.20080516150804.1067">def get_pername(self, path, key, name):
    scope_info = self._get_scope_info(path, key, readonly=True)
    result = scope_info.get_per_name(name)
    if self.validation.is_value_valid(result):
        return result

</t>
<t tx="ekr.20080516150804.1068">def get_callinfos(self, path, key):
    scope_info = self._get_scope_info(path, key, readonly=True)
    return scope_info.get_call_infos()

</t>
<t tx="ekr.20080516150804.1069">def add_callinfo(self, path, key, args, returned):
    scope_info = self._get_scope_info(path, key, readonly=False)
    old_returned = scope_info.get_returned(args)
    if self.validation.is_more_valid(returned, old_returned):
        scope_info.add_call(args, returned)

</t>
<t tx="ekr.20080516150804.1070">def add_pername(self, path, key, name, value):
    scope_info = self._get_scope_info(path, key, readonly=False)
    old_value = scope_info.get_per_name(name)
    if self.validation.is_more_valid(value, old_value):
        scope_info.save_per_name(name, value)

</t>
<t tx="ekr.20080516150804.1071">def add_file_list_observer(self, observer):
    self.observers.append(observer)

</t>
<t tx="ekr.20080516150804.1072">def write(self):
    self.db.write()

</t>
<t tx="ekr.20080516150804.1073">def _get_scope_info(self, path, key, readonly=True):
    if path not in self.files:
        if readonly:
            return _NullScopeInfo()
        self.files.create(path)
        self._file_added(path)
    if key not in self.files[path]:
        if readonly:
            return _NullScopeInfo()
        self.files[path].create_scope(key)
    result = self.files[path][key]
    if isinstance(result, dict):
        print self.files, self.files[path], self.files[path][key]
    return result

</t>
<t tx="ekr.20080516150804.1074">def _file_removed(self, path):
    for observer in self.observers:
        observer.removed(path)

</t>
<t tx="ekr.20080516150804.1075">def _file_added(self, path):
    for observer in self.observers:
        observer.added(path)

</t>
<t tx="ekr.20080516150804.1076">def __str__(self):
    scope_count = 0
    for file_dict in self.files.values():
        scope_count += len(file_dict)
    return 'ObjectDB holds %s file and %s scope infos' % \
           (len(self.files), scope_count)


</t>
<t tx="ekr.20080516150804.1077">class _NullScopeInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1078">
def __init__(self, error_on_write=True):
    self.error_on_write = error_on_write

</t>
<t tx="ekr.20080516150804.1079">def get_per_name(self, name):
    pass

</t>
<t tx="ekr.20080516150804.1080">def save_per_name(self, name, value):
    if self.error_on_write:
        raise NotImplementedError()

</t>
<t tx="ekr.20080516150804.1081">def get_returned(self, parameters):
    pass

</t>
<t tx="ekr.20080516150804.1082">def get_call_infos(self):
    return []

</t>
<t tx="ekr.20080516150804.1083">def add_call(self, parameters, returned):
    if self.error_on_write:
        raise NotImplementedError()


</t>
<t tx="ekr.20080516150804.1084">class FileInfo(UserDict.DictMixin):
    @others
</t>
<t tx="ekr.20080516150804.1085">
def create_scope(self, key):
    pass


</t>
<t tx="ekr.20080516150804.1086">class FileDict(UserDict.DictMixin):
    @others
</t>
<t tx="ekr.20080516150804.1087">
def create(self, key):
    pass

</t>
<t tx="ekr.20080516150804.1088">def rename(self, key, new_key):
    pass


</t>
<t tx="ekr.20080516150804.1089">class ScopeInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1090">
def get_per_name(self, name):
    pass

</t>
<t tx="ekr.20080516150804.1091">def save_per_name(self, name, value):
    pass

</t>
<t tx="ekr.20080516150804.1092">def get_returned(self, parameters):
    pass

</t>
<t tx="ekr.20080516150804.1093">def get_call_infos(self):
    pass

</t>
<t tx="ekr.20080516150804.1094">def add_call(self, parameters, returned):
    pass


</t>
<t tx="ekr.20080516150804.1095">class CallInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1096">
def __init__(self, args, returned):
    self.args = args
    self.returned = returned

</t>
<t tx="ekr.20080516150804.1097">def get_parameters(self):
    return self.args

</t>
<t tx="ekr.20080516150804.1098">def get_returned(self):
    return self.returned


</t>
<t tx="ekr.20080516150804.1099">class FileListObserver(object):
    @others
</t>
<t tx="ekr.20080516150804.1100">
def added(self, path):
    pass

</t>
<t tx="ekr.20080516150804.1101">def removed(self, path):
    pass
</t>
<t tx="ekr.20080516150804.1102">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1103">import warnings

from rope.base import exceptions, resourceobserver
from rope.base.oi import objectdb, memorydb, transform


</t>
<t tx="ekr.20080516150804.1104">class ObjectInfoManager(object):
    """Stores object information

    It uses an instance of `objectdb.ObjectDB` for storing
    information.

    """
    @others
</t>
<t tx="ekr.20080516150804.1105">
def __init__(self, project):
    self.project = project
    self.to_textual = transform.PyObjectToTextual(project)
    self.to_pyobject = transform.TextualToPyObject(project)
    self.doi_to_pyobject = transform.DOITextualToPyObject(project)
    self._init_objectdb()
    if project.prefs.get('validate_objectdb', False):
        self._init_validation()

</t>
<t tx="ekr.20080516150804.1106">def _init_objectdb(self):
    dbtype = self.project.get_prefs().get('objectdb_type', None)
    persist = None
    if dbtype is not None:
        warnings.warn(
            '"objectdb_type" project config is deprecated;\n'
            'Use "save_objectdb" instead in your project '
            'config file.\n(".ropeproject/config.py" by default)\n',
            DeprecationWarning)
        if dbtype != 'memory' and self.project.ropefolder is not None:
            persist = True
    self.validation = TextualValidation(self.to_pyobject)
    db = memorydb.MemoryDB(self.project, persist=persist)
    self.objectdb = objectdb.ObjectDB(db, self.validation)

</t>
<t tx="ekr.20080516150804.1107">def _init_validation(self):
    self.objectdb.validate_files()
    observer = resourceobserver.ResourceObserver(
        changed=self._resource_changed, moved=self._resource_moved,
        removed=self._resource_moved)
    files = []
    for path in self.objectdb.get_files():
        resource = self.to_pyobject.path_to_resource(path)
        if resource is not None and resource.project == self.project:
            files.append(resource)
    self.observer = resourceobserver.FilteredResourceObserver(observer,
                                                              files)
    self.objectdb.add_file_list_observer(_FileListObserver(self))
    self.project.add_observer(self.observer)

</t>
<t tx="ekr.20080516150804.1108">def _resource_changed(self, resource):
    try:
        self.objectdb.validate_file(
            self.to_textual.resource_to_path(resource))
    except exceptions.ModuleSyntaxError:
        pass

</t>
<t tx="ekr.20080516150804.1109">def _resource_moved(self, resource, new_resource=None):
    self.observer.remove_resource(resource)
    if new_resource is not None:
        old = self.to_textual.resource_to_path(resource)
        new = self.to_textual.resource_to_path(new_resource)
        self.objectdb.file_moved(old, new)
        self.observer.add_resource(new_resource)

</t>
<t tx="ekr.20080516150804.1110">def get_returned(self, pyobject, args):
    result = self.get_exact_returned(pyobject, args)
    if result is not None:
        return result
    path, key = self._get_scope(pyobject)
    if path is None:
        return None
    for call_info in self.objectdb.get_callinfos(path, key):
        returned = call_info.get_returned()
        if returned and returned[0] not in ('unknown', 'none'):
            result = returned
            break
        if result is None:
            result = returned
    if result is not None:
        return self.to_pyobject(result)

</t>
<t tx="ekr.20080516150804.1111">def get_exact_returned(self, pyobject, args):
    path, key = self._get_scope(pyobject)
    if path is not None:
        returned = self.objectdb.get_returned(
            path, key, self._args_to_textual(pyobject, args))
        if returned is not None:
            return self.to_pyobject(returned)

</t>
<t tx="ekr.20080516150804.1112">def _args_to_textual(self, pyfunction, args):
    parameters = list(pyfunction.get_param_names(special_args=False))
    arguments = args.get_arguments(parameters)[:len(parameters)]
    textual_args = tuple([self.to_textual(arg)
                          for arg in arguments])
    return textual_args

</t>
<t tx="ekr.20080516150804.1113">def get_parameter_objects(self, pyobject):
    path, key = self._get_scope(pyobject)
    if path is None:
        return None
    arg_count = len(pyobject.get_param_names(special_args=False))
    unknowns = arg_count
    parameters = [None] * arg_count
    for call_info in self.objectdb.get_callinfos(path, key):
        args = call_info.get_parameters()
        for index, arg in enumerate(args[:arg_count]):
            old = parameters[index]
            if self.validation.is_more_valid(arg, old):
                parameters[index] = arg
                if self.validation.is_value_valid(arg):
                    unknowns -= 1
        if unknowns == 0:
            break
    if unknowns &lt; arg_count:
        return [self.to_pyobject(parameter)
                for parameter in parameters]

</t>
<t tx="ekr.20080516150804.1114">def get_passed_objects(self, pyfunction, parameter_index):
    path, key = self._get_scope(pyfunction)
    if path is None:
        return []
    result = []
    for call_info in self.objectdb.get_callinfos(path, key):
        args = call_info.get_parameters()
        if len(args) &gt; parameter_index:
            parameter = self.to_pyobject(args[parameter_index])
            if parameter is not None:
                result.append(parameter)
    return result

</t>
<t tx="ekr.20080516150804.1115">def doa_data_received(self, data):
    def doi_to_normal(textual):
        pyobject = self.doi_to_pyobject(textual)
        return self.to_textual(pyobject)
    function = doi_to_normal(data[0])
    args = tuple([doi_to_normal(textual) for textual in data[1]])
    returned = doi_to_normal(data[2])
    if function[0] == 'defined' and len(function) == 3:
        self._save_data(function, args, returned)

</t>
<t tx="ekr.20080516150804.1116">def function_called(self, pyfunction, params, returned=None):
    function_text = self.to_textual(pyfunction)
    params_text = tuple([self.to_textual(param)
                         for param in params])
    returned_text = ('unknown',)
    if returned is not None:
        returned_text = self.to_textual(returned)
    self._save_data(function_text, params_text, returned_text)

</t>
<t tx="ekr.20080516150804.1117">def save_per_name(self, scope, name, data):
    path, key = self._get_scope(scope.pyobject)
    if path is not None:
        self.objectdb.add_pername(path, key, name, self.to_textual(data))

</t>
<t tx="ekr.20080516150804.1118">def get_per_name(self, scope, name):
    path, key = self._get_scope(scope.pyobject)
    if path is not None:
        result = self.objectdb.get_pername(path, key, name)
        if result is not None:
            return self.to_pyobject(result)

</t>
<t tx="ekr.20080516150804.1119">def _save_data(self, function, args, returned=('unknown',)):
    self.objectdb.add_callinfo(function[1], function[2], args, returned)

</t>
<t tx="ekr.20080516150804.1120">def _get_scope(self, pyobject):
    resource = pyobject.get_module().get_resource()
    if resource is None:
        return None, None
    textual = self.to_textual(pyobject)
    if textual[0] == 'defined':
        path = textual[1]
        if len(textual) == 3:
            key = textual[2]
        else:
            key = ''
        return path, key
    return None, None

</t>
<t tx="ekr.20080516150804.1121">def sync(self):
    self.objectdb.sync()

</t>
<t tx="ekr.20080516150804.1122">def __str__(self):
    return str(self.objectdb)


</t>
<t tx="ekr.20080516150804.1123">class TextualValidation(object):
    @others
</t>
<t tx="ekr.20080516150804.1124">
def __init__(self, to_pyobject):
    self.to_pyobject = to_pyobject

</t>
<t tx="ekr.20080516150804.1125">def is_value_valid(self, value):
    # ???: Should none and unknown be considered valid?
    if value is None or value[0] in ('none', 'unknown'):
        return False
    return self.to_pyobject(value) is not None

</t>
<t tx="ekr.20080516150804.1126">def is_more_valid(self, new, old):
    if old is None:
        return True
    return new[0] not in ('unknown', 'none')

</t>
<t tx="ekr.20080516150804.1127">def is_file_valid(self, path):
    return self.to_pyobject.path_to_resource(path) is not None

</t>
<t tx="ekr.20080516150804.1128">def is_scope_valid(self, path, key):
    if key == '':
        textual = ('defined', path)
    else:
        textual = ('defined', path, key)
    return self.to_pyobject(textual) is not None


</t>
<t tx="ekr.20080516150804.1129">class _FileListObserver(object):
    @others
</t>
<t tx="ekr.20080516150804.1130">
def __init__(self, object_info):
    self.object_info = object_info
    self.observer = self.object_info.observer
    self.to_pyobject = self.object_info.to_pyobject

</t>
<t tx="ekr.20080516150804.1131">def removed(self, path):
    resource = self.to_pyobject.path_to_resource(path)
    if resource is not None:
        self.observer.remove_resource(resource)

</t>
<t tx="ekr.20080516150804.1132">def added(self, path):
    resource = self.to_pyobject.path_to_resource(path)
    if resource is not None:
        self.observer.add_resource(resource)
</t>
<t tx="ekr.20080516150804.1133">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    __rope_start_everything()
</t>
<t tx="ekr.20080516150804.1134">
def __rope_start_everything():
    import os
    import sys
    import socket
    import cPickle as pickle
    import marshal
    import inspect
    import types
    import threading

    class _MessageSender(object):

        def send_data(self, data):
            pass

    class _SocketSender(_MessageSender):

        def __init__(self, port):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(('127.0.0.1', port))
            self.my_file = s.makefile('w')

        def send_data(self, data):
            if not self.my_file.closed:
                pickle.dump(data, self.my_file)

        def close(self):
            self.my_file.close()

    class _FileSender(_MessageSender):

        def __init__(self, file_name):
            self.my_file = open(file_name, 'wb')

        def send_data(self, data):
            if not self.my_file.closed:
                marshal.dump(data, self.my_file)

        def close(self):
            self.my_file.close()

    class _FunctionCallDataSender(object):

        def __init__(self, send_info, project_root):
            self.project_root = project_root
            if send_info.isdigit():
                self.sender = _SocketSender(int(send_info))
            else:
                self.sender = _FileSender(send_info)

            def global_trace(frame, event, arg):
                # HACK: Ignoring out-&gt;in calls
                # This might lose some information
                if self._is_an_interesting_call(frame):
                    return self.on_function_call
            sys.settrace(global_trace)
            threading.settrace(global_trace)

        def on_function_call(self, frame, event, arg):
            if event != 'return':
                return
            args = []
            returned = ('unknown',)
            code = frame.f_code
            for argname in code.co_varnames[:code.co_argcount]:
                try:
                    args.append(self._object_to_persisted_form(frame.f_locals[argname]))
                except (TypeError, AttributeError):
                    args.append(('unknown',))
            try:
                returned = self._object_to_persisted_form(arg)
            except (TypeError, AttributeError):
                pass
            try:
                data = (self._object_to_persisted_form(frame.f_code),
                        tuple(args), returned)
                self.sender.send_data(data)
            except (TypeError):
                pass
            return self.on_function_call

        def _is_an_interesting_call(self, frame):
            #if frame.f_code.co_name in ['?', '&lt;module&gt;']:
            #    return False
            #return not frame.f_back or not self._is_code_inside_project(frame.f_back.f_code)

            if not self._is_code_inside_project(frame.f_code) and \
               (not frame.f_back or not self._is_code_inside_project(frame.f_back.f_code)):
                return False
            return True

        def _is_code_inside_project(self, code):
            source = code.co_filename
            return source and source.endswith('.py') and os.path.exists(source) and \
                   _realpath(source).startswith(self.project_root)

        def _get_persisted_code(self, object_):
            source = object_.co_filename
            if not os.path.exists(source):
                raise TypeError('no source')
            return ('defined', _realpath(source), str(object_.co_firstlineno))

        def _get_persisted_class(self, object_):
            try:
                return ('defined', _realpath(inspect.getsourcefile(object_)),
                        object_.__name__)
            except (TypeError, AttributeError):
                return ('unknown',)

        def _get_persisted_builtin(self, object_):
            if isinstance(object_, (str, unicode)):
                return ('builtin', 'str')
            if isinstance(object_, list):
                holding = None
                if len(object_) &gt; 0:
                    holding = object_[0]
                return ('builtin', 'list', self._object_to_persisted_form(holding))
            if isinstance(object_, dict):
                keys = None
                values = None
                if len(object_) &gt; 0:
                    keys = object_.keys()[0]
                    values = object_[keys]
                return ('builtin', 'dict',
                        self._object_to_persisted_form(keys),
                        self._object_to_persisted_form(values))
            if isinstance(object_, tuple):
                objects = []
                if len(object_) &lt; 3:
                    for holding in object_:
                        objects.append(self._object_to_persisted_form(holding))
                else:
                    objects.append(self._object_to_persisted_form(object_[0]))
                return tuple(['builtin', 'tuple'] + objects)
            if isinstance(object_, set):
                holding = None
                if len(object_) &gt; 0:
                    for o in object_:
                        holding = o
                        break
                return ('builtin', 'set', self._object_to_persisted_form(holding))
            return ('unknown',)

        def _object_to_persisted_form(self, object_):
            if object_ is None:
                return ('none',)
            if isinstance(object_, types.CodeType):
                return self._get_persisted_code(object_)
            if isinstance(object_, types.FunctionType):
                return self._get_persisted_code(object_.func_code)
            if isinstance(object_, types.MethodType):
                return self._get_persisted_code(object_.im_func.func_code)
            if isinstance(object_, types.ModuleType):
                return ('defined', _realpath(object_.__file__))
            if isinstance(object_, (str, unicode, list, dict, tuple, set)):
                return self._get_persisted_builtin(object_)
            if isinstance(object_, (types.TypeType, types.ClassType)):
                return self._get_persisted_class(object_)
            return ('instance', self._get_persisted_class(type(object_)))

        def close(self):
            self.sender.close()

    def _realpath(path):
        return os.path.realpath(os.path.abspath(os.path.expanduser(path)))

    send_info = sys.argv[1]
    project_root = sys.argv[2]
    file_to_run = sys.argv[3]
    run_globals = globals()
    run_globals.update({'__name__': '__main__',
                        '__builtins__': __builtins__,
                        '__file__': file_to_run})
    if send_info != '-':
        data_sender = _FunctionCallDataSender(send_info, project_root)
    del sys.argv[1:4]
    execfile(file_to_run, run_globals)
    if send_info != '-':
        data_sender.close()


</t>
<t tx="ekr.20080516150804.1135">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1136">import rope.base.ast
import rope.base.oi.soi
import rope.base.pynames
from rope.base import pyobjects, evaluate, astutils, arguments


</t>
<t tx="ekr.20080516150804.1137">def analyze_module(pycore, pymodule, should_analyze,
                   search_subscopes, followed_calls):
    """Analyze `pymodule` for static object inference

    Analyzes scopes for collecting object information.  The analysis
    starts from inner scopes.

    """
    _analyze_node(pycore, pymodule, should_analyze,
                  search_subscopes, followed_calls)


</t>
<t tx="ekr.20080516150804.1138">def _analyze_node(pycore, pydefined, should_analyze,
                  search_subscopes, followed_calls):
    if search_subscopes(pydefined):
        for scope in pydefined.get_scope().get_scopes():
            _analyze_node(pycore, scope.pyobject, should_analyze,
                          search_subscopes, followed_calls)
    if should_analyze(pydefined):
        new_followed_calls = max(0, followed_calls - 1)
        return_true = lambda pydefined: True
        return_false = lambda pydefined: False
        def _follow(pyfunction):
            _analyze_node(pycore, pyfunction, return_true,
                          return_false, new_followed_calls)
        if not followed_calls:
            _follow = None
        visitor = SOIVisitor(pycore, pydefined, _follow)
        for child in rope.base.ast.get_child_nodes(pydefined.get_ast()):
            rope.base.ast.walk(child, visitor)


</t>
<t tx="ekr.20080516150804.1139">class SOIVisitor(object):
    @others
</t>
<t tx="ekr.20080516150804.1140">
def __init__(self, pycore, pydefined, follow_callback=None):
    self.pycore = pycore
    self.pymodule = pydefined.get_module()
    self.scope = pydefined.get_scope()
    self.follow = follow_callback

</t>
<t tx="ekr.20080516150804.1141">def _FunctionDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.1142">def _ClassDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.1143">def _Call(self, node):
    for child in rope.base.ast.get_child_nodes(node):
        rope.base.ast.walk(child, self)
    primary, pyname = evaluate.get_primary_and_result(self.scope,
                                                      node.func)
    if pyname is None:
        return
    pyfunction = pyname.get_object()
    if isinstance(pyfunction, pyobjects.AbstractFunction):
        args = arguments.create_arguments(primary, pyfunction,
                                          node, self.scope)
    elif isinstance(pyfunction, pyobjects.PyClass):
        pyclass = pyfunction
        if '__init__' in pyfunction:
            pyfunction = pyfunction['__init__'].get_object()
        pyname = rope.base.pynames.UnboundName(pyobjects.PyObject(pyclass))
        args = self._args_with_self(primary, pyname, pyfunction, node)
    elif '__call__' in pyfunction:
        pyfunction = pyfunction['__call__'].get_object()
        args = self._args_with_self(primary, pyname, pyfunction, node)
    else:
        return
    self._call(pyfunction, args)

</t>
<t tx="ekr.20080516150804.1144">def _args_with_self(self, primary, self_pyname, pyfunction, node):
    base_args = arguments.create_arguments(primary, pyfunction,
                                           node, self.scope)
    return arguments.MixedArguments(self_pyname, base_args, self.scope)

</t>
<t tx="ekr.20080516150804.1145">def _call(self, pyfunction, args):
    if isinstance(pyfunction, pyobjects.PyFunction):
        if self.follow is not None:
            before = self._parameter_objects(pyfunction)
        self.pycore.object_info.function_called(
            pyfunction, args.get_arguments(pyfunction.get_param_names()))
        pyfunction._set_parameter_pyobjects(None)
        if self.follow is not None:
            after = self._parameter_objects(pyfunction)
            if after != before:
                self.follow(pyfunction)
    # XXX: Maybe we should not call every builtin function
    if isinstance(pyfunction, rope.base.builtins.BuiltinFunction):
        pyfunction.get_returned_object(args)

</t>
<t tx="ekr.20080516150804.1146">def _parameter_objects(self, pyfunction):
    result = []
    for i in range(len(pyfunction.get_param_names(False))):
        result.append(pyfunction.get_parameter(i))
    return result

</t>
<t tx="ekr.20080516150804.1147">def _Assign(self, node):
    for child in rope.base.ast.get_child_nodes(node):
        rope.base.ast.walk(child, self)
    visitor = _SOIAssignVisitor()
    nodes = []
    for child in node.targets:
        rope.base.ast.walk(child, visitor)
        nodes.extend(visitor.nodes)
    for subscript, levels in nodes:
        instance = evaluate.get_statement_result(self.scope, subscript.value)
        args_pynames = []
        args_pynames.append(evaluate.get_statement_result(
                            self.scope, subscript.slice.value))
        value = rope.base.oi.soi._infer_assignment(
            rope.base.pynames.AssignmentValue(node.value, levels), self.pymodule)
        args_pynames.append(rope.base.pynames.UnboundName(value))
        if instance is not None and value is not None:
            pyobject = instance.get_object()
            if '__setitem__' in pyobject:
                pyfunction = pyobject['__setitem__'].get_object()
                args = arguments.ObjectArguments([instance] + args_pynames)
                self._call(pyfunction, args)
            # IDEA: handle `__setslice__`, too


</t>
<t tx="ekr.20080516150804.1148">class _SOIAssignVisitor(astutils._NodeNameCollector):
    @others
</t>
<t tx="ekr.20080516150804.1149">
def __init__(self):
    super(_SOIAssignVisitor, self).__init__()
    self.nodes = []

</t>
<t tx="ekr.20080516150804.1150">def _added(self, node, levels):
    if isinstance(node, rope.base.ast.Subscript) and \
       isinstance(node.slice, rope.base.ast.Index):
        self.nodes.append((node, levels))
</t>
<t tx="ekr.20080516150804.1151">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1152">"""A module for inferring objects

For more information see the documentation in `rope.base.oi`
package.

"""
import rope.base.builtins
import rope.base.pynames
import rope.base.pyobjects
from rope.base import evaluate, utils, arguments


_ignore_inferred = utils.ignore_exception(
    rope.base.pyobjects.IsBeingInferredError)


</t>
<t tx="ekr.20080516150804.1153">@_ignore_inferred
def infer_returned_object(pyfunction, args):
    """Infer the `PyObject` this `PyFunction` returns after calling"""
    object_info = pyfunction.pycore.object_info
    result = object_info.get_exact_returned(pyfunction, args)
    if result is not None:
        return result
    result = _infer_returned(pyfunction, args)
    if result is not None:
        if args and pyfunction.get_module().get_resource() is not None:
            params = args.get_arguments(
                pyfunction.get_param_names(special_args=False))
            object_info.function_called(pyfunction, params, result)
        return result
    return object_info.get_returned(pyfunction, args)

</t>
<t tx="ekr.20080516150804.1154">@_ignore_inferred
def infer_parameter_objects(pyfunction):
    """Infer the `PyObject`\s of parameters of this `PyFunction`"""
    object_info = pyfunction.pycore.object_info
    result = object_info.get_parameter_objects(pyfunction)
    if result is None:
        result = _parameter_objects(pyfunction)
    _handle_first_parameter(pyfunction, result)
    return result

</t>
<t tx="ekr.20080516150804.1155">def _handle_first_parameter(pyobject, parameters):
    kind = pyobject.get_kind()
    if parameters is None or kind not in ['method', 'classmethod']:
        pass
    if not parameters:
        if not pyobject.get_param_names(special_args=False):
            return
        parameters.append(rope.base.pyobjects.get_unknown())
    if kind == 'method':
        parameters[0] = rope.base.pyobjects.PyObject(pyobject.parent)
    if kind == 'classmethod':
        parameters[0] = pyobject.parent

</t>
<t tx="ekr.20080516150804.1156">@_ignore_inferred
def infer_assigned_object(pyname):
    if not pyname.assignments:
        return
    for assignment in reversed(pyname.assignments):
        result = _infer_assignment(assignment, pyname.module)
        if result is not None:
            return result

</t>
<t tx="ekr.20080516150804.1157">def get_passed_objects(pyfunction, parameter_index):
    object_info = pyfunction.pycore.object_info
    result = object_info.get_passed_objects(pyfunction,
                                            parameter_index)
    if not result:
        statically_inferred = _parameter_objects(pyfunction)
        if len(statically_inferred) &gt; parameter_index:
            result.append(statically_inferred[parameter_index])
    return result

</t>
<t tx="ekr.20080516150804.1158">def _infer_returned(pyobject, args):
    if args:
        # HACK: Setting parameter objects manually
        # This is not thread safe and might cause problems if `args`
        # does not come from a good call site
        pyobject.get_scope().invalidate_data()
        pyobject._set_parameter_pyobjects(
            args.get_arguments(pyobject.get_param_names(special_args=False)))
    scope = pyobject.get_scope()
    if not scope._get_returned_asts():
        return
    maxtries = 3
    for returned_node in reversed(scope._get_returned_asts()[-maxtries:]):
        try:
            resulting_pyname = evaluate.get_statement_result(scope,
                                                             returned_node)
            if resulting_pyname is None:
                continue
            pyobject = resulting_pyname.get_object()
            if pyobject == rope.base.pyobjects.get_unknown():
                continue
            if not scope._is_generator():
                return pyobject
            else:
                return rope.base.builtins.get_generator(pyobject)
        except rope.base.pyobjects.IsBeingInferredError:
            pass

</t>
<t tx="ekr.20080516150804.1159">def _parameter_objects(pyobject):
    params = pyobject.get_param_names(special_args=False)
    return [rope.base.pyobjects.get_unknown()] * len(params)

</t>
<t tx="ekr.20080516150804.1160"># handling `rope.base.pynames.AssignmentValue`

@_ignore_inferred
def _infer_assignment(assignment, pymodule):
    result = _follow_pyname(assignment, pymodule)
    if result is None:
        return None
    pyname, pyobject = result
    pyobject = _follow_evaluations(assignment, pyname, pyobject)
    if pyobject is None:
        return None
    return _follow_levels(assignment, pyobject)

</t>
<t tx="ekr.20080516150804.1161">def _follow_levels(assignment, pyobject):
    for index in assignment.levels:
        if isinstance(pyobject.get_type(), rope.base.builtins.Tuple):
            holdings = pyobject.get_type().get_holding_objects()
            if holdings:
                pyobject = holdings[min(len(holdings) - 1, index)]
            else:
                pyobject = None
        elif isinstance(pyobject.get_type(), rope.base.builtins.List):
            pyobject = pyobject.get_type().holding
        else:
            pyobject = None
        if pyobject is None:
            break
    return pyobject

</t>
<t tx="ekr.20080516150804.1162">@_ignore_inferred
def _follow_pyname(assignment, pymodule, lineno=None):
    assign_node = assignment.ast_node
    if lineno is None:
        lineno = _get_lineno_for_node(assign_node)
    holding_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
    pyname = evaluate.get_statement_result(holding_scope, assign_node)
    if pyname is not None:
        result = pyname.get_object()
        if isinstance(result.get_type(), rope.base.builtins.Property) and \
           holding_scope.get_kind() == 'Class':
            arg = rope.base.pynames.UnboundName(
                rope.base.pyobjects.PyObject(holding_scope.pyobject))
            return pyname, result.get_type().get_property_object(
                arguments.ObjectArguments([arg]))
        return pyname, result

</t>
<t tx="ekr.20080516150804.1163">@_ignore_inferred
def _follow_evaluations(assignment, pyname, pyobject):
    new_pyname = pyname
    tokens = assignment.evaluation.split('.')
    for token in tokens:
        call = token.endswith('()')
        if call:
            token = token[:-2]
        if token:
            pyname = new_pyname
            new_pyname = _get_attribute(pyobject, token)
            if new_pyname is not None:
                pyobject = new_pyname.get_object()
        if pyobject is not None and call:
            if isinstance(pyobject, rope.base.pyobjects.AbstractFunction):
                args = arguments.ObjectArguments([pyname])
                pyobject = pyobject.get_returned_object(args)
            else:
                pyobject = None
        if pyobject is None:
            break
    if pyobject is not None and assignment.assign_type:
        return rope.base.pyobjects.PyObject(pyobject)
    return pyobject


</t>
<t tx="ekr.20080516150804.1164">def _get_lineno_for_node(assign_node):
    if hasattr(assign_node, 'lineno') and \
       assign_node.lineno is not None:
        return assign_node.lineno
    return 1

</t>
<t tx="ekr.20080516150804.1165">def _get_attribute(pyobject, name):
    if pyobject is not None and name in pyobject:
        return pyobject[name]
</t>
<t tx="ekr.20080516150804.1166">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1167">"""Provides classes for persisting `PyObject`\s"""
import os
import re

import rope.base.builtins
from rope.base import exceptions


</t>
<t tx="ekr.20080516150804.1168">class PyObjectToTextual(object):
    """For transforming `PyObject` to textual form

    This can be used for storing `PyObjects` in files.  Use
    `TextualToPyObject` for converting back.

    """
    @others
</t>
<t tx="ekr.20080516150804.1169">
def __init__(self, project):
    self.project = project

</t>
<t tx="ekr.20080516150804.1170">def transform(self, pyobject):
    """Transform a `PyObject` to textual form"""
    if pyobject is None:
        return ('none',)
    object_type = type(pyobject)
    try:
        method = getattr(self, object_type.__name__ + '_to_textual')
        return method(pyobject)
    except AttributeError:
        return ('unknown',)

</t>
<t tx="ekr.20080516150804.1171">def __call__(self, pyobject):
    return self.transform(pyobject)

</t>
<t tx="ekr.20080516150804.1172">def PyObject_to_textual(self, pyobject):
    if isinstance(pyobject.get_type(), rope.base.pyobjects.AbstractClass):
        result = self.transform(pyobject.get_type())
        if result[0] == 'defined':
            return ('instance', result)
        return result
    return ('unknown',)

</t>
<t tx="ekr.20080516150804.1173">def PyFunction_to_textual(self, pyobject):
    return self._defined_to_textual(pyobject)

</t>
<t tx="ekr.20080516150804.1174">def PyClass_to_textual(self, pyobject):
    return self._defined_to_textual(pyobject)

</t>
<t tx="ekr.20080516150804.1175">def _defined_to_textual(self, pyobject):
    address = []
    while pyobject.parent is not None:
        address.insert(0, pyobject.get_name())
        pyobject = pyobject.parent
    return ('defined', self._get_pymodule_path(pyobject.get_module()),
            '.'.join(address))

</t>
<t tx="ekr.20080516150804.1176">def PyModule_to_textual(self, pyobject):
    return ('defined', self._get_pymodule_path(pyobject))

</t>
<t tx="ekr.20080516150804.1177">def PyPackage_to_textual(self, pyobject):
    return ('defined', self._get_pymodule_path(pyobject))

</t>
<t tx="ekr.20080516150804.1178">def List_to_textual(self, pyobject):
    return ('builtin', 'list', self.transform(pyobject.holding))

</t>
<t tx="ekr.20080516150804.1179">def Dict_to_textual(self, pyobject):
    return ('builtin', 'dict', self.transform(pyobject.keys),
            self.transform(pyobject.values))

</t>
<t tx="ekr.20080516150804.1180">def Tuple_to_textual(self, pyobject):
    objects = [self.transform(holding)
               for holding in pyobject.get_holding_objects()]
    return tuple(['builtin', 'tuple'] + objects)

</t>
<t tx="ekr.20080516150804.1181">def Set_to_textual(self, pyobject):
    return ('builtin', 'set', self.transform(pyobject.holding))

</t>
<t tx="ekr.20080516150804.1182">def Iterator_to_textual(self, pyobject):
    return ('builtin', 'iter', self.transform(pyobject.holding))

</t>
<t tx="ekr.20080516150804.1183">def Generator_to_textual(self, pyobject):
    return ('builtin', 'generator', self.transform(pyobject.holding))

</t>
<t tx="ekr.20080516150804.1184">def Str_to_textual(self, pyobject):
    return ('builtin', 'str')

</t>
<t tx="ekr.20080516150804.1185">def File_to_textual(self, pyobject):
    return ('builtin', 'file')

</t>
<t tx="ekr.20080516150804.1186">def BuiltinFunction_to_textual(self, pyobject):
    return ('builtin', 'function', pyobject.get_name())

</t>
<t tx="ekr.20080516150804.1187">def _get_pymodule_path(self, pymodule):
    return self.resource_to_path(pymodule.get_resource())

</t>
<t tx="ekr.20080516150804.1188">def resource_to_path(self, resource):
    if resource.project == self.project:
        return resource.path
    else:
        return resource.real_path


</t>
<t tx="ekr.20080516150804.1189">class TextualToPyObject(object):
    """For transforming textual form to `PyObject`"""
    @others
</t>
<t tx="ekr.20080516150804.1190">
def __init__(self, project, allow_in_project_absolutes=False):
    self.project = project

</t>
<t tx="ekr.20080516150804.1191">def __call__(self, textual):
    return self.transform(textual)

</t>
<t tx="ekr.20080516150804.1192">def transform(self, textual):
    """Transform an object from textual form to `PyObject`"""
    if textual is None:
        return None
    type = textual[0]
    try:
        method = getattr(self, type + '_to_pyobject')
        return method(textual)
    except AttributeError:
        return None

</t>
<t tx="ekr.20080516150804.1193">def builtin_to_pyobject(self, textual):
    name = textual[1]
    method = getattr(self, 'builtin_%s_to_pyobject' % textual[1], None)
    if method is not None:
        return method(textual)

</t>
<t tx="ekr.20080516150804.1194">def builtin_str_to_pyobject(self, textual):
    return rope.base.builtins.get_str()

</t>
<t tx="ekr.20080516150804.1195">def builtin_list_to_pyobject(self, textual):
    holding = self.transform(textual[2])
    return rope.base.builtins.get_list(holding)

</t>
<t tx="ekr.20080516150804.1196">def builtin_dict_to_pyobject(self, textual):
    keys = self.transform(textual[2])
    values = self.transform(textual[3])
    return rope.base.builtins.get_dict(keys, values)

</t>
<t tx="ekr.20080516150804.1197">def builtin_tuple_to_pyobject(self, textual):
    objects = []
    for holding in textual[2:]:
        objects.append(self.transform(holding))
    return rope.base.builtins.get_tuple(*objects)

</t>
<t tx="ekr.20080516150804.1198">def builtin_set_to_pyobject(self, textual):
    holding = self.transform(textual[2])
    return rope.base.builtins.get_set(holding)

</t>
<t tx="ekr.20080516150804.1199">def builtin_iter_to_pyobject(self, textual):
    holding = self.transform(textual[2])
    return rope.base.builtins.get_iterator(holding)

</t>
<t tx="ekr.20080516150804.1200">def builtin_generator_to_pyobject(self, textual):
    holding = self.transform(textual[2])
    return rope.base.builtins.get_generator(holding)

</t>
<t tx="ekr.20080516150804.1201">def builtin_file_to_pyobject(self, textual):
    return rope.base.builtins.get_file()

</t>
<t tx="ekr.20080516150804.1202">def builtin_function_to_pyobject(self, textual):
    if textual[2] in rope.base.builtins.builtins:
        return rope.base.builtins.builtins[textual[2]].get_object()

</t>
<t tx="ekr.20080516150804.1203">def unknown_to_pyobject(self, textual):
    return None

</t>
<t tx="ekr.20080516150804.1204">def none_to_pyobject(self, textual):
    return None

</t>
<t tx="ekr.20080516150804.1205">def _module_to_pyobject(self, textual):
    path = textual[1]
    return self._get_pymodule(path)

</t>
<t tx="ekr.20080516150804.1206">def _hierarchical_defined_to_pyobject(self, textual):
    path = textual[1]
    names = textual[2].split('.')
    pymodule = self._get_pymodule(path)
    pyobject = pymodule
    for name in names:
        if pyobject is None:
            return None
        if isinstance(pyobject, rope.base.pyobjects.PyDefinedObject):
            try:
                pyobject = pyobject.get_scope()[name].get_object()
            except exceptions.NameNotFoundError:
                return None
        else:
            return None
    return pyobject

</t>
<t tx="ekr.20080516150804.1207">def defined_to_pyobject(self, textual):
    if len(textual) == 2 or textual[2] == '':
        return self._module_to_pyobject(textual)
    else:
        return self._hierarchical_defined_to_pyobject(textual)

</t>
<t tx="ekr.20080516150804.1208">def instance_to_pyobject(self, textual):
    type = self.transform(textual[1])
    if type is not None:
        return rope.base.pyobjects.PyObject(type)

</t>
<t tx="ekr.20080516150804.1209">def _get_pymodule(self, path):
    resource = self.path_to_resource(path)
    if resource is not None:
        return self.project.get_pycore().resource_to_pyobject(resource)

</t>
<t tx="ekr.20080516150804.1210">def path_to_resource(self, path):
    try:
        root = self.project.address
        if not os.path.isabs(path):
            return self.project.get_resource(path)
        if path == root or path.startswith(root + os.sep):
            # INFO: This is a project file; should not be absolute
            return None
        import rope.base.project
        return rope.base.project.get_no_project().get_resource(path)
    except exceptions.ResourceNotFoundError:
        return None


</t>
<t tx="ekr.20080516150804.1211">class DOITextualToPyObject(TextualToPyObject):
    """For transforming textual form to `PyObject`
    
    The textual form DOI uses is different from rope's standard
    textual form.  The reason is that we cannot find the needed
    information by analyzing live objects.  This class can be
    used to transform DOI textual form to `PyObject` and later
    we can convert it to standard textual form using
    `TextualToPyObject` class.

    """
    @others
</t>
<t tx="ekr.20080516150804.1212">
def _function_to_pyobject(self, textual):
    path = textual[1]
    lineno = int(textual[2])
    pymodule = self._get_pymodule(path)
    if pymodule is not None:
        scope = pymodule.get_scope()
        inner_scope = scope.get_inner_scope_for_line(lineno)
        return inner_scope.pyobject

</t>
<t tx="ekr.20080516150804.1213">def _class_to_pyobject(self, textual):
    path, name = textual[1:]
    pymodule = self._get_pymodule(path)
    if pymodule is None:
        return None
    module_scope = pymodule.get_scope()
    suspected = None
    if name in module_scope.get_names():
        suspected = module_scope[name].get_object()
    if suspected is not None and \
       isinstance(suspected, rope.base.pyobjects.PyClass):
        return suspected
    else:
        lineno = self._find_occurrence(name, pymodule.get_resource().read())
        if lineno is not None:
            inner_scope = module_scope.get_inner_scope_for_line(lineno)
            return inner_scope.pyobject

</t>
<t tx="ekr.20080516150804.1214">def defined_to_pyobject(self, textual):
    if len(textual) == 2:
        return self._module_to_pyobject(textual)
    else:
        if textual[2].isdigit():
            result = self._function_to_pyobject(textual)
        else:
            result = self._class_to_pyobject(textual)
        if not isinstance(result, rope.base.pyobjects.PyModule):
            return result

</t>
<t tx="ekr.20080516150804.1215">def _find_occurrence(self, name, source):
    pattern = re.compile(r'^\s*class\s*' + name + r'\b')
    lines = source.split('\n')
    for i in range(len(lines)):
        if pattern.match(lines[i]):
            return i + 1

</t>
<t tx="ekr.20080516150804.1216">def path_to_resource(self, path):
    root = self.project.address
    if os.path.isabs(path) and (path == root or
                                path.startswith(root + os.sep)):
        path = path[len(root):].replace(os.sep, '/')
        if path.startswith('/'):
            path = path[1:]
    return super(DOITextualToPyObject, self).path_to_resource(path)
</t>
<t tx="ekr.20080516150804.1217">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1218">"""Rope object analysis and inference package

Rope makes some simplifying assumptions about a python program.  It
assumes that a program only performs assignments and function calls.
Tracking assignments is simple and `PyName` objects handle that.  The
main problem is function calls.  Rope uses these two approaches for
obtaining call information:

* Static object analysis: `rope.base.pycore.PyCore.analyze_module()`

  It can analyze modules to obtain information about functions.  This
  is done by analyzing function calls in a module or scope.  Currently
  SOA analyzes the scopes that are changed while saving or when the
  user asks to analyze a module.  That is mainly because static
  analysis is time-consuming.

* Dynamic object analysis: `rope.base.pycore.PyCore.run_module()`

  When you run a module or your testsuite, when DOA is enabled, it
  collects information about parameters passed to and objects returned
  from functions.  The main problem with this approach is that it is
  quite slow; Not when looking up the information but when collecting
  them.

An instance of `rope.base.oi.objectinfo.ObjectInfoManager` can be used
for accessing these information.  It saves the data in a
`rope.base.oi.objectdb.ObjectDB` internally.

Now if our objectdb does not know anything about a function and we
need the value returned by it, static object inference, SOI, comes
into play.  It analyzes function body and tries to infer the object
that is returned from it (we usually need the returned value for the
given parameter objects).

Rope might collect and store information for other `PyName`\s, too.
For instance rope stores the object builtin containers hold.

"""
</t>
<t tx="ekr.20080516150804.1219"></t>
<t tx="ekr.20080516150804.1220">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1221">import re

from rope.base import exceptions, pynames, resourceobserver, taskhandle
from rope.refactor import importutils


</t>
<t tx="ekr.20080516150804.1222">class AutoImport(object):
    """A class for finding the module that provides a name

    This class maintains a cache of global names in python modules.
    Note that this cache is not accurate and might be out of date.

    """
    @others
</t>
<t tx="ekr.20080516150804.1223">
def __init__(self, project, observe=True, underlined=False):
    """Construct an AutoImport object

    If `observe` is `True`, listen for project changes and update
    the cache.

    If `underlined` is `True`, underlined names are cached, too.
    """
    self.project = project
    self.underlined = underlined
    self.names = project.data_files.read_data('globalnames')
    if self.names is None:
        self.names = {}
    project.data_files.add_write_hook(self._write)
    # XXX: using a filtered observer
    observer = resourceobserver.ResourceObserver(
        changed=self._changed, moved=self._moved, removed=self._removed)
    if observe:
        project.add_observer(observer)

</t>
<t tx="ekr.20080516150804.1224">def import_assist(self, starting):
    """Return a list of ``(name, module)`` tuples

    This function tries to find modules that have a global name
    that starts with `starting`.
    """
    # XXX: breaking if gave up! use generators
    result = []
    for module in self.names:
        for global_name in self.names[module]:
            if global_name.startswith(starting):
                result.append((global_name, module))
    return result

</t>
<t tx="ekr.20080516150804.1225">def get_modules(self, name):
    """Return the list of modules that have global `name`"""
    result = []
    for module in self.names:
        if name in self.names[module]:
            result.append(module)
    return result

</t>
<t tx="ekr.20080516150804.1226">def get_all_names(self):
    """Return the list of all cached global names"""
    result = set()
    for module in self.names:
        result.update(set(self.names[module]))
    return result

</t>
<t tx="ekr.20080516150804.1227">def get_name_locations(self, name):
    """Return a list of ``(resource, lineno)`` tuples"""
    result = []
    pycore = self.project.pycore
    for module in self.names:
        if name in self.names[module]:
            try:
                pymodule = pycore.get_module(module)
                if name in pymodule:
                    pyname = pymodule[name]
                    module, lineno = pyname.get_definition_location()
                    if module is not None:
                        resource = module.get_module().get_resource()
                        if resource is not None and lineno is not None:
                            result.append((resource, lineno))
            except exceptions.ModuleNotFoundError:
                pass
    return result

</t>
<t tx="ekr.20080516150804.1228">def generate_cache(self, resources=None, underlined=None,
                   task_handle=taskhandle.NullTaskHandle()):
    """Generate global name cache for project files

    If `resources` is a list of `rope.base.resource.File`\s, only
    those files are searched; otherwise all python modules in the
    project are cached.

    """
    if resources is None:
        resources = self.project.pycore.get_python_files()
    job_set = task_handle.create_jobset(
        'Generatig autoimport cache', len(resources))
    for file in resources:
        job_set.started_job('Working on &lt;%s&gt;' % file.path)
        self.update_resource(file, underlined)
        job_set.finished_job()

</t>
<t tx="ekr.20080516150804.1229">def generate_modules_cache(self, modules, underlined=None,
                           task_handle=taskhandle.NullTaskHandle()):
    """Generate global name cache for modules listed in `modules`"""
    job_set = task_handle.create_jobset(
        'Generatig autoimport cache for modules', len(modules))
    for modname in modules:
        job_set.started_job('Working on &lt;%s&gt;' % modname)
        self.update_module(modname, underlined)
        job_set.finished_job()

</t>
<t tx="ekr.20080516150804.1230">def clear_cache(self):
    """Clear all entries in global-name cache

    It might be a good idea to use this function before
    regenerating global names.

    """
    self.names.clear()

</t>
<t tx="ekr.20080516150804.1231">def find_insertion_line(self, code):
    """Guess at what line the new import should be inserted"""
    match = re.search(r'^(def|class)\s+', code)
    if match is not None:
        code = code[:match.start()]
    try:
        pymodule = self.project.pycore.get_string_module(code)
    except exceptions.ModuleSyntaxError:
        return 1
    testmodname = '__rope_testmodule_rope'
    importinfo = importutils.NormalImport(((testmodname, None),))
    module_imports = importutils.get_module_imports(
        self.project.pycore, pymodule)
    module_imports.add_import(importinfo)
    code = module_imports.get_changed_source()
    offset = code.index(testmodname)
    lineno = code.count('\n', 0, offset) + 1
    return lineno

</t>
<t tx="ekr.20080516150804.1232">def update_resource(self, resource, underlined=None):
    """Update the cache for global names in `resource`"""
    try:
        pymodule = self.project.pycore.resource_to_pyobject(resource)
        modname = self._module_name(resource)
        self._add_names(pymodule, modname, underlined)
    except exceptions.ModuleSyntaxError:
        pass

</t>
<t tx="ekr.20080516150804.1233">def update_module(self, modname, underlined=None):
    """Update the cache for global names in `modname` module

    `modname` is the name of a module.
    """
    try:
        pymodule = self.project.pycore.get_module(modname)
        self._add_names(pymodule, modname, underlined)
    except exceptions.ModuleNotFoundError:
        pass

</t>
<t tx="ekr.20080516150804.1234">def _module_name(self, resource):
    return importutils.get_module_name(self.project.pycore, resource)

</t>
<t tx="ekr.20080516150804.1235">def _add_names(self, pymodule, modname, underlined):
    if underlined is None:
        underlined = self.underlined
    globals = []
    for name, pyname in pymodule._get_structural_attributes().items():
        if not underlined and name.startswith('_'):
            continue
        if isinstance(pyname, (pynames.AssignedName, pynames.DefinedName)):
            globals.append(name)
    self.names[modname] = globals

</t>
<t tx="ekr.20080516150804.1236">def _write(self):
    self.project.data_files.write_data('globalnames', self.names)

</t>
<t tx="ekr.20080516150804.1237">def _changed(self, resource):
    if not resource.is_folder():
        self.update_resource(resource)

</t>
<t tx="ekr.20080516150804.1238">def _moved(self, resource, newresource):
    if not resource.is_folder():
        modname = self._module_name(resource)
        if modname in self.names:
            del self.names[modname]
        self.update_resource(newresource)

</t>
<t tx="ekr.20080516150804.1239">def _removed(self, resource):
    if not resource.is_folder():
        modname = self._module_name(resource)
        if modname in self.names:
            del self.names[modname]
</t>
<t tx="ekr.20080516150804.1240">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1241">import keyword
import sys
import warnings

import rope.base.codeanalyze
import rope.base.evaluate
import rope.contrib.findit
from rope.base import pyobjects, pynames, builtins, exceptions, worder
from rope.base.codeanalyze import ArrayLinesAdapter, LogicalLineFinder, SourceLinesAdapter
from rope.refactor import functionutils, importutils


</t>
<t tx="ekr.20080516150804.1242">def code_assist(project, source_code, offset, resource=None,
                templates=None, maxfixes=1, later_locals=True):
    """Return python code completions as a list of `CodeAssistProposal`\s

    `resource` is a `rope.base.resources.Resource` object.  If
    provided, relative imports are handled.

    `maxfixes` is the maximum number of errors to fix if the code has
    errors in it.

    If `later_locals` is `False` names defined in this scope and after
    this line is ignored.

    """
    if templates is not None:
        warnings.warn('Codeassist no longer supports templates',
                      DeprecationWarning, stacklevel=2)
    assist = _PythonCodeAssist(
        project, source_code, offset, resource=resource,
        maxfixes=maxfixes, later_locals=later_locals)
    return assist()


</t>
<t tx="ekr.20080516150804.1243">def starting_offset(source_code, offset):
    """Return the offset in which the completion should be inserted

    Usually code assist proposals should be inserted like::

        completion = proposal.name
        result = (source_code[:starting_offset] +
                  completion + source_code[offset:])

    Where starting_offset is the offset returned by this function.

    """
    word_finder = worder.Worder(source_code, True)
    expression, starting, starting_offset = \
        word_finder.get_splitted_primary_before(offset)
    return starting_offset


</t>
<t tx="ekr.20080516150804.1244">def get_doc(project, source_code, offset, resource=None, maxfixes=1):
    """Get the pydoc"""
    pyname = _find_pyname_at(project, source_code, offset, resource, maxfixes)
    if pyname is None:
        return None
    pyobject = pyname.get_object()
    return PyDocExtractor().get_doc(pyobject)


</t>
<t tx="ekr.20080516150804.1245">def get_calltip(project, source_code, offset, resource=None,
                maxfixes=1, ignore_unknown=False):
    """Get the calltip of a function

    The format of the returned string is
    ``module_name.holding_scope_names.function_name(arguments)``.  For
    classes `__init__()` and for normal objects `__call__()` function
    is used.

    Note that the offset is on the function itself *not* after the its
    open parenthesis.  (Actually it used to be the other way but it
    was easily confused when string literals were involved.  So I
    decided it is better for it not to try to be too clever when it
    cannot be clever enough).  You can use a simple search like::

        offset = source_code.rindex('(', 0, offset) - 1

    to handle simple situations.

    If `ignore_unknown` is `True`, `None` is returned for functions
    without source-code like builtins and extensions.
    """
    pyname = _find_pyname_at(project, source_code, offset, resource, maxfixes)
    if pyname is None:
        return None
    pyobject = pyname.get_object()
    return PyDocExtractor().get_calltip(pyobject, ignore_unknown)


</t>
<t tx="ekr.20080516150804.1246">def get_definition_location(project, source_code, offset,
                            resource=None, maxfixes=1):
    """Return the definition location of the python name at `offset`

    Return a (`rope.base.resources.Resource`, lineno) tuple.  If no
    `resource` is given and the definition is inside the same module,
    the first element of the returned tuple would be `None`.  If the
    location cannot be determined ``(None, None)`` is returned.

    """
    pyname = _find_pyname_at(project, source_code, offset, resource, maxfixes)
    if pyname is not None:
        module, lineno = pyname.get_definition_location()
        if module is not None:
            return module.get_module().get_resource(), lineno
    return (None, None)


</t>
<t tx="ekr.20080516150804.1247">def find_occurrences(*args, **kwds):
    warnings.warn('Use `rope.contrib.findit.find_occurrences()` instead',
                  DeprecationWarning, stacklevel=2)
    return rope.contrib.findit.find_occurrences(*args, **kwds)


</t>
<t tx="ekr.20080516150804.1248">class CodeAssistProposal(object):
    """The base class for proposals reported by `code_assist`

    The `kind` instance variable shows the kind of the proposal and
    can be 'global', 'local', 'builtin', 'attribute', 'keyword',
    'parameter_keyword'.

    """
    @others
</t>
<t tx="ekr.20080516150804.1249">
def __init__(self, name, kind):
    self.name = name
    self.kind = kind


</t>
<t tx="ekr.20080516150804.1250">class CompletionProposal(CodeAssistProposal):
    """A completion proposal

    The `type` instance variable shows the type of the proposal and
    can be 'variable', 'class', 'function', 'imported' , 'paramter'
    and `None`.

    """
    @others
</t>
<t tx="ekr.20080516150804.1251">
def __init__(self, name, kind, type=None):
    super(CompletionProposal, self).__init__(name, kind)
    self.type = type

</t>
<t tx="ekr.20080516150804.1252">def __str__(self):
    return '%s (%s, %s)' % (self.name, self.kind, self.type)

</t>
<t tx="ekr.20080516150804.1253">def __repr__(self):
    return str(self)


</t>
<t tx="ekr.20080516150804.1254">def sorted_proposals(proposals, kindpref=None, typepref=None):
    """Sort a list of proposals

    Return a sorted list of the given `CodeAssistProposal`\s.

    `kindpref` can be a list of proposal kinds.  Defaults to
    ``['local', 'parameter_keyword', 'global', 'attribute',
    'keyword']``.

    `typepref` can be a list of proposal types.  Defaults to
    ``['class', 'function', 'variable', 'parameter', 'imported',
    'builtin', None]``.  (`None` stands for completions with no type
    like keywords.)
    """
    sorter = _ProposalSorter(proposals, kindpref, typepref)
    return sorter.get_sorted_proposal_list()


</t>
<t tx="ekr.20080516150804.1255">def starting_expression(source_code, offset):
    """Return the expression to complete"""
    word_finder = worder.Worder(source_code, True)
    expression, starting, starting_offset = \
        word_finder.get_splitted_primary_before(offset)
    if expression:
        return expression + '.' + starting
    return starting


</t>
<t tx="ekr.20080516150804.1256">def default_templates():
    warnings.warn('default_templates() is deprecated.',
                  DeprecationWarning, stacklevel=2)
    return {}


</t>
<t tx="ekr.20080516150804.1257">class _PythonCodeAssist(object):
    @others
</t>
<t tx="ekr.20080516150804.1258">
def __init__(self, project, source_code, offset, resource=None,
             maxfixes=1, later_locals=True):
    self.project = project
    self.pycore = self.project.get_pycore()
    self.code = source_code
    self.resource = resource
    self.maxfixes = maxfixes
    self.later_locals = later_locals
    self.word_finder = worder.Worder(source_code, True)
    self.expression, self.starting, self.offset = \
        self.word_finder.get_splitted_primary_before(offset)

</t>
<t tx="ekr.20080516150804.1259">keywords = keyword.kwlist

def _find_starting_offset(self, source_code, offset):
    current_offset = offset - 1
    while current_offset &gt;= 0 and (source_code[current_offset].isalnum() or
                                   source_code[current_offset] in '_'):
        current_offset -= 1;
    return current_offset + 1

</t>
<t tx="ekr.20080516150804.1260">def _matching_keywords(self, starting):
    result = []
    for kw in self.keywords:
        if kw.startswith(starting):
            result.append(CompletionProposal(kw, 'keyword'))
    return result

</t>
<t tx="ekr.20080516150804.1261">def __call__(self):
    if self.offset &gt; len(self.code):
        return []
    completions = list(self._code_completions().values())
    if self.expression.strip() == '' and self.starting.strip() != '':
        completions.extend(self._matching_keywords(self.starting))
    return completions

</t>
<t tx="ekr.20080516150804.1262">def _dotted_completions(self, module_scope, holding_scope):
    result = {}
    pyname_finder = rope.base.evaluate.ScopeNameFinder(module_scope.pyobject)
    found_pyname = rope.base.evaluate.get_pyname_in_scope(
        holding_scope, self.expression)
    if found_pyname is not None:
        element = found_pyname.get_object()
        for name, pyname in element.get_attributes().items():
            if name.startswith(self.starting):
                result[name] = CompletionProposal(
                    name, 'attribute', self._get_pyname_type(pyname))
    return result

</t>
<t tx="ekr.20080516150804.1263">def _undotted_completions(self, scope, result, lineno=None):
    if scope.parent != None:
        self._undotted_completions(scope.parent, result)
    if lineno is None:
        names = scope.get_propagated_names()
    else:
        names = scope.get_names()
    for name, pyname in names.items():
        if name.startswith(self.starting):
            kind = 'local'
            if scope.get_kind() == 'Module':
                kind = 'global'
            if lineno is None or self.later_locals or \
               not self._is_defined_after(scope, pyname, lineno):
                result[name] = CompletionProposal(
                    name, kind, self._get_pyname_type(pyname))

</t>
<t tx="ekr.20080516150804.1264">def _from_import_completions(self, pymodule):
    module_name = self.word_finder.get_from_module(self.offset)
    if module_name is None:
        return {}
    pymodule = self._find_module(pymodule, module_name)
    result = {}
    for name in pymodule:
        if name.startswith(self.starting):
            result[name] = CompletionProposal(name, kind='global',
                                              type='imported')
    return result

</t>
<t tx="ekr.20080516150804.1265">def _find_module(self, pymodule, module_name):
    dots = 0
    while module_name[dots] == '.':
        dots += 1
    pyname = pynames.ImportedModule(pymodule,
                                    module_name[dots:], dots)
    return pyname.get_object()

</t>
<t tx="ekr.20080516150804.1266">def _is_defined_after(self, scope, pyname, lineno):
    location = pyname.get_definition_location()
    if location is not None and location[1] is not None:
        if location[0] == scope.pyobject.get_module() and \
           lineno &lt;= location[1] &lt;= scope.get_end():
            return True

</t>
<t tx="ekr.20080516150804.1267">def _get_pyname_type(self, pyname):
    if isinstance(pyname, builtins.BuiltinName):
        return 'builtin'
    if isinstance(pyname, pynames.ImportedName) or \
       isinstance(pyname, pynames.ImportedModule):
        return 'imported'
    if isinstance(pyname, pynames.ParameterName):
        return 'parameter'
    if isinstance(pyname, builtins.BuiltinName) or \
       isinstance(pyname, pynames.DefinedName):
        pyobject = pyname.get_object()
        if isinstance(pyobject, pyobjects.AbstractFunction):
            return 'function'
        if isinstance(pyobject, pyobjects.AbstractClass):
            return 'class'
    return 'variable'

</t>
<t tx="ekr.20080516150804.1268">def _code_completions(self):
    lineno = self.code.count('\n', 0, self.offset) + 1
    pymodule = _get_pymodule(self.pycore, self.code,
                             self.resource, self.maxfixes)
    module_scope = pymodule.get_scope()
    code = pymodule.source_code
    lines = code.split('\n')
    result = {}
    start = _logical_start(lines, lineno)
    indents = _get_line_indents(lines[start - 1])
    inner_scope = module_scope.get_inner_scope_for_line(start, indents)
    if self.word_finder.is_a_name_after_from_import(self.offset):
        return self._from_import_completions(pymodule)
    if self.expression.strip() != '':
        result.update(self._dotted_completions(module_scope, inner_scope))
    else:
        result.update(self._keyword_parameters(module_scope.pyobject,
                                               inner_scope))
        self._undotted_completions(inner_scope, result, lineno=lineno)
    return result

</t>
<t tx="ekr.20080516150804.1269">def _keyword_parameters(self, pymodule, scope):
    offset = self.offset
    if offset == 0:
        return {}
    word_finder = worder.Worder(self.code, True)
    lines = SourceLinesAdapter(self.code)
    lineno = lines.get_line_number(offset)
    if word_finder.is_on_function_call_keyword(offset - 1):
        name_finder = rope.base.evaluate.ScopeNameFinder(pymodule)
        function_parens = word_finder.\
            find_parens_start_from_inside(offset - 1)
        primary = word_finder.get_primary_at(function_parens - 1)
        try:
            function_pyname = rope.base.evaluate.\
                get_pyname_in_scope(scope, primary)
        except exceptions.BadIdentifierError, e:
            return {}
        if function_pyname is not None:
            pyobject = function_pyname.get_object()
            if isinstance(pyobject, pyobjects.AbstractFunction):
                pass
            elif isinstance(pyobject, pyobjects.AbstractClass) and \
                 '__init__' in pyobject:
                pyobject = pyobject['__init__'].get_object()
            elif '__call__' in pyobject:
                pyobject = pyobject['__call__'].get_object()
            if isinstance(pyobject, pyobjects.AbstractFunction):
                param_names = []
                param_names.extend(
                    pyobject.get_param_names(special_args=False))
                result = {}
                for name in param_names:
                    if name.startswith(self.starting):
                        result[name + '='] = CompletionProposal(
                            name + '=', 'parameter_keyword')
                return result
    return {}


</t>
<t tx="ekr.20080516150804.1270">class _ProposalSorter(object):
    """Sort a list of code assist proposals"""
    @others
</t>
<t tx="ekr.20080516150804.1271">
def __init__(self, code_assist_proposals, kindpref=None, typepref=None):
    self.proposals = code_assist_proposals
    if kindpref is None:
        kindpref = ['local', 'parameter_keyword', 'global',
                    'attribute', 'keyword']
    self.kindpref = kindpref
    if typepref is None:
        typepref = ['class', 'function', 'variable',
                    'parameter', 'imported', 'builtin', None]
    self.typerank = dict((type, index)
                          for index, type in enumerate(typepref))

</t>
<t tx="ekr.20080516150804.1272">def get_sorted_proposal_list(self):
    """Return a list of `CodeAssistProposal`"""
    proposals = {}
    for proposal in self.proposals:
        proposals.setdefault(proposal.kind, []).append(proposal)
    result = []
    for kind in self.kindpref:
        kind_proposals = proposals.get(kind, [])
        kind_proposals = [proposal for proposal in kind_proposals
                          if proposal.type in self.typerank]
        kind_proposals.sort(self._proposal_cmp)
        result.extend(kind_proposals)
    return result

</t>
<t tx="ekr.20080516150804.1273">def _proposal_cmp(self, proposal1, proposal2):
    if proposal1.type != proposal2.type:
        return cmp(self.typerank.get(proposal1.type, 100),
                   self.typerank.get(proposal2.type, 100))
    return self._compare_underlined_names(proposal1.name,
                                          proposal2.name)

</t>
<t tx="ekr.20080516150804.1274">def _compare_underlined_names(self, name1, name2):
    def underline_count(name):
        result = 0
        while result &lt; len(name) and name[result] == '_':
            result += 1
        return result
    underline_count1 = underline_count(name1)
    underline_count2 = underline_count(name2)
    if underline_count1 != underline_count2:
        return cmp(underline_count1, underline_count2)
    return cmp(name1, name2)


</t>
<t tx="ekr.20080516150804.1275">class _Commenter(object):
    @others
</t>
<t tx="ekr.20080516150804.1276">
def __init__(self, lines):
    self.lines = lines

</t>
<t tx="ekr.20080516150804.1277">def comment(self, lineno):
    start = _logical_start(self.lines, lineno, check_prev=True) - 1
    end = self._get_block_end(start)
    indents = _get_line_indents(self.lines[start])
    if 0 &lt; start:
        last_lineno = self._last_non_blank(start - 1)
        last_line = self.lines[last_lineno]
        if last_line.rstrip().endswith(':'):
            indents = _get_line_indents(last_line) + 4
    self.lines[start] = ' ' * indents + 'pass'
    for line in range(start + 1, end + 1):
        self.lines[line] = self.lines[start]
    self._fix_incomplete_try_blocks(lineno, indents)

</t>
<t tx="ekr.20080516150804.1278">def _last_non_blank(self, start):
    while start &gt; 0 and self.lines[start].strip() == '':
        start -= 1
    return start

</t>
<t tx="ekr.20080516150804.1279">def _get_block_end(self, lineno):
    end_line = lineno
    base_indents = _get_line_indents(self.lines[lineno])
    for i in range(lineno + 1, len(self.lines)):
        if _get_line_indents(self.lines[i]) &gt;= base_indents:
            end_line = i
        else:
            break
    return end_line

</t>
<t tx="ekr.20080516150804.1280">def _fix_incomplete_try_blocks(self, lineno, indents):
    block_start = lineno
    last_indents = current_indents = indents
    while block_start &gt; 0:
        block_start = rope.base.codeanalyze.get_block_start(
            ArrayLinesAdapter(self.lines), block_start) - 1
        if self.lines[block_start].strip().startswith('try:'):
            indents = _get_line_indents(self.lines[block_start])
            if indents &gt; last_indents:
                continue
            last_indents = indents
            block_end = self._find_matching_deindent(block_start)
            line = self.lines[block_end].strip()
            if not (line.startswith('finally:') or
                    line.startswith('except ') or
                    line.startswith('except:')):
                self.lines.insert(block_end, ' ' * indents + 'finally:')
                self.lines.insert(block_end + 1, ' ' * indents + '    pass')

</t>
<t tx="ekr.20080516150804.1281">def _find_matching_deindent(self, line_number):
    indents = _get_line_indents(self.lines[line_number])
    current_line = line_number + 1
    while current_line &lt; len(self.lines):
        line = self.lines[current_line]
        if not line.strip().startswith('#') and not line.strip() == '':
            # HACK: We should have used logical lines here
            if _get_line_indents(self.lines[current_line]) &lt;= indents:
                return current_line
        current_line += 1
    return len(self.lines) - 1


</t>
<t tx="ekr.20080516150804.1282">def _find_pyname_at(project, source_code, offset, resource, maxfixes):
    pymodule = _get_pymodule(project.pycore, source_code,
                             resource, maxfixes=maxfixes)
    def old_pyname():
        word_finder = worder.Worder(source_code, True)
        expression = word_finder.get_primary_at(offset)
        expression = expression.replace('\\\n', ' ').replace('\n', ' ')
        lineno = source_code.count('\n', 0, offset)
        scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
        return rope.base.evaluate.get_pyname_in_scope(scope, expression)
    def new_pyname():
        return rope.base.evaluate.get_pyname_at(pymodule, offset)
    new_code = pymodule.source_code
    if new_code.startswith(source_code[:offset + 1]):
        return new_pyname()
    result = old_pyname()
    if result is None and offset &lt; len(new_code):
        return new_pyname()
    return result


</t>
<t tx="ekr.20080516150804.1283">def _get_pymodule(pycore, code, resource, maxfixes=1):
    """Get a `PyModule`"""
    commenter = None
    errors = []
    tries = 0
    while True:
        try:
            if tries == 0 and resource is not None and resource.read() == code:
                return pycore.resource_to_pyobject(resource, force_errors=True)
            return pycore.get_string_module(code, resource=resource,
                                            force_errors=True)
        except exceptions.ModuleSyntaxError, e:
            if tries &lt; maxfixes:
                tries += 1
                if commenter is None:
                    lines = code.split('\n')
                    lines.append('\n')
                    commenter = _Commenter(lines)
                commenter.comment(e.lineno)
                code = '\n'.join(commenter.lines)
                errors.append('  * line %s: %s ... fixed' % (e.lineno,
                                                             e.message_))
            else:
                errors.append('  * line %s: %s ... raised!' % (e.lineno,
                                                               e.message_))
                new_message = ('\nSyntax errors in file %s:\n' % e.filename) \
                               + '\n'.join(errors)
                raise exceptions.ModuleSyntaxError(e.filename, e.lineno,
                                                   new_message)


</t>
<t tx="ekr.20080516150804.1284">def _get_line_indents(line):
    return rope.base.codeanalyze.count_line_indents(line)


</t>
<t tx="ekr.20080516150804.1285">def _logical_start(lines, lineno, check_prev=False):
    logical_finder = LogicalLineFinder(ArrayLinesAdapter(lines))
    if check_prev:
        prev = lineno - 1
        while prev &gt; 0:
            start, end = logical_finder.logical_line_in(prev)
            if end is None or start &lt;= lineno &lt; end:
                return start
            if start &lt;= prev:
                break
            prev -= 1
    return logical_finder.logical_line_in(lineno)[0]


</t>
<t tx="ekr.20080516150804.1286">class PyDocExtractor(object):
    @others
</t>
<t tx="ekr.20080516150804.1287">
def get_doc(self, pyobject):
    if isinstance(pyobject, pyobjects.AbstractFunction):
        return self._get_function_docstring(pyobject)
    elif isinstance(pyobject, pyobjects.AbstractClass):
        return self._get_class_docstring(pyobject)
    elif isinstance(pyobject, pyobjects.AbstractModule):
        return self._trim_docstring(pyobject.get_doc())
    return None

</t>
<t tx="ekr.20080516150804.1288">def get_calltip(self, pyobject, ignore_unknown=False):
    try:
        if isinstance(pyobject, pyobjects.AbstractClass):
            pyobject = pyobject['__init__'].get_object()
        if not isinstance(pyobject, pyobjects.AbstractFunction):
            pyobject = pyobject['__call__'].get_object()
    except exceptions.AttributeNotFoundError:
        return None
    if ignore_unknown and not isinstance(pyobject, pyobjects.PyFunction):
        return
    if isinstance(pyobject, pyobjects.AbstractFunction):
        return self._get_function_signature(pyobject, add_module=True)

</t>
<t tx="ekr.20080516150804.1289">def _get_class_docstring(self, pyclass):
    contents = self._trim_docstring(pyclass.get_doc(), 2)
    supers = [super.get_name() for super in pyclass.get_superclasses()]
    doc = 'class %s(%s):\n\n' % (pyclass.get_name(), ', '.join(supers)) + contents

    if '__init__' in pyclass:
        init = pyclass['__init__'].get_object()
        if isinstance(init, pyobjects.AbstractFunction):
            doc += '\n\n' + self._get_single_function_docstring(init)
    return doc

</t>
<t tx="ekr.20080516150804.1290">def _get_function_docstring(self, pyfunction):
    functions = [pyfunction]
    if self._is_method(pyfunction):
        functions.extend(self._get_super_methods(pyfunction.parent,
                                                 pyfunction.get_name()))
    return '\n\n'.join([self._get_single_function_docstring(function)
                        for function in functions])

</t>
<t tx="ekr.20080516150804.1291">def _is_method(self, pyfunction):
    return isinstance(pyfunction, pyobjects.PyFunction) and \
           isinstance(pyfunction.parent, pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1292">def _get_single_function_docstring(self, pyfunction):
    signature = self._get_function_signature(pyfunction)
    docs = self._trim_docstring(pyfunction.get_doc(), indents=2)
    return signature + ':\n\n' + docs

</t>
<t tx="ekr.20080516150804.1293">def _get_super_methods(self, pyclass, name):
    result = []
    for super_class in pyclass.get_superclasses():
        if name in super_class:
            function = super_class[name].get_object()
            if isinstance(function, pyobjects.AbstractFunction):
                result.append(function)
        result.extend(self._get_super_methods(super_class, name))
    return result

</t>
<t tx="ekr.20080516150804.1294">def _get_function_signature(self, pyfunction, add_module=False):
    location = self._location(pyfunction, add_module)
    if isinstance(pyfunction, pyobjects.PyFunction):
        info = functionutils.DefinitionInfo.read(pyfunction)
        return location + info.to_string()
    else:
        return '%s(%s)' % (location + pyfunction.get_name(),
                           ', '.join(pyfunction.get_param_names()))

</t>
<t tx="ekr.20080516150804.1295">def _location(self, pyobject, add_module=False):
    location = []
    parent = pyobject.parent
    while parent and not isinstance(parent, pyobjects.AbstractModule):
        location.append(parent.get_name())
        location.append('.')
        parent = parent.parent
    if add_module:
        if isinstance(pyobject, pyobjects.PyFunction):
            module = pyobject.get_module()
            location.insert(0, self._get_module(pyobject))
        if isinstance(parent, builtins.BuiltinModule):
            location.insert(0, parent.get_name() + '.')
    return ''.join(location)

</t>
<t tx="ekr.20080516150804.1296">def _get_module(self, pyfunction):
    module = pyfunction.get_module()
    if module is not None:
        resource = module.get_resource()
        if resource is not None:
            return importutils.get_module_name(
                pyfunction.pycore, resource) + '.'
    return ''

</t>
<t tx="ekr.20080516150804.1297">def _trim_docstring(self, docstring, indents=0):
    """The sample code from :PEP:`257`"""
    if not docstring:
        return ''
    # Convert tabs to spaces (following normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = sys.maxint
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent &lt; sys.maxint:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
    # Return a single string:
    return '\n'.join((' ' * indents + line for line in trimmed))


</t>
<t tx="ekr.20080516150804.1298"># Deprecated classes

class TemplateProposal(CodeAssistProposal):
    @others
</t>
<t tx="ekr.20080516150804.1299">def __init__(self, name, template):
    warnings.warn('TemplateProposal is deprecated.',
                  DeprecationWarning, stacklevel=2)
    super(TemplateProposal, self).__init__(name, 'template')
    self.template = template


</t>
<t tx="ekr.20080516150804.1300">class Template(object):
    @others
</t>
<t tx="ekr.20080516150804.1301">
def __init__(self, template):
    self.template = template
    warnings.warn('Template is deprecated.',
                  DeprecationWarning, stacklevel=2)

</t>
<t tx="ekr.20080516150804.1302">def variables(self):
    return []

</t>
<t tx="ekr.20080516150804.1303">def substitute(self, mapping):
    return self.template

</t>
<t tx="ekr.20080516150804.1304">def get_cursor_location(self, mapping):
    return len(self.template)
</t>
<t tx="ekr.20080516150804.1305">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1306">import rope.base.codeanalyze
import rope.base.evaluate
import rope.base.pyobjects
from rope.base import taskhandle, exceptions, worder
from rope.refactor import occurrences


</t>
<t tx="ekr.20080516150804.1307">def find_occurrences(project, resource, offset, unsure=False, resources=None,
                     in_hierarchy=False, task_handle=taskhandle.NullTaskHandle()):
    """Return a list of `Location`\s

    If `unsure` is `True`, possible matches are returned, too.  You
    can use `Location.unsure` to see which are unsure occurrences.
    `resources` can be a list of `rope.base.resource.File`\s that
    should be searched for occurrences; if `None` all python files
    in the project are searched.

    """
    name = worder.get_name_at(resource, offset)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    primary, pyname = rope.base.evaluate.get_primary_and_pyname_at(
        this_pymodule, offset)
    def is_match(occurrence):
        return unsure
    finder = occurrences.create_finder(
        project.pycore, name, pyname, unsure=is_match,
        in_hierarchy=in_hierarchy, instance=primary)
    if resources is None:
        resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Finding Occurrences',
                                        count=len(resources))
    return _find_locations(finder, resources, job_set)


</t>
<t tx="ekr.20080516150804.1308">def find_implementations(project, resource, offset, resources=None,
                         task_handle=taskhandle.NullTaskHandle()):
    """Find the places a given method is overridden.

    Finds the places a method is implemented.  Returns a list of
    `Location`\s.
    """
    name = worder.get_name_at(resource, offset)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    pyname = rope.base.evaluate.get_pyname_at(this_pymodule, offset)
    if pyname is not None:
        pyobject = pyname.get_object()
        if not isinstance(pyobject, rope.base.pyobjects.PyFunction) or \
           pyobject.get_kind() != 'method':
            raise exceptions.BadIdentifierError('Not a method!')
    else:
        raise exceptions.BadIdentifierError('Cannot resolve the identifier!')
    def is_defined(occurrence):
        if not occurrence.is_defined():
            return False
    def not_self(occurrence):
        if occurrence.get_pyname().get_object() == pyname.get_object():
            return False
    filters = [is_defined, not_self,
               occurrences.InHierarchyFilter(pyname, True)]
    finder = occurrences.Finder(project.pycore, name, filters=filters)
    if resources is None:
        resources = project.pycore.get_python_files()
    job_set = task_handle.create_jobset('Finding Implementations',
                                        count=len(resources))
    return _find_locations(finder, resources, job_set)


</t>
<t tx="ekr.20080516150804.1309">class Location(object):

    resource = None
    offset = None
    unsure = False


</t>
<t tx="ekr.20080516150804.1310">def _find_locations(finder, resources, job_set):
    result = []
    for resource in resources:
        job_set.started_job(resource.path)
        for occurrence in finder.find_occurrences(resource):
            location = Location()
            location.resource = resource
            location.offset = occurrence.get_word_range()[0]
            location.unsure = occurrence.is_unsure()
            result.append(location)
        job_set.finished_job()
    return result
</t>
<t tx="ekr.20080516150804.1311">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1312">import rope.base.evaluate
from rope.base import change, pyobjects, exceptions, pynames, worder, codeanalyze
from rope.refactor import sourceutils, importutils, functionutils, suites


</t>
<t tx="ekr.20080516150804.1313">def create_generate(kind, project, resource, offset):
    """A factory for creating `Generate` objects

    `kind` can be 'variable', 'function', 'class', 'module' or
    'package'.

    """
    generate = eval('Generate' + kind.title())
    return generate(project, resource, offset)


</t>
<t tx="ekr.20080516150804.1314">def create_module(project, name, sourcefolder=None):
    """Creates a module and returns a `rope.base.resources.File`"""
    if sourcefolder is None:
        sourcefolder = project.root
    packages = name.split('.')
    parent = sourcefolder
    for package in packages[:-1]:
        parent = parent.get_child(package)
    return parent.create_file(packages[-1] + '.py')

</t>
<t tx="ekr.20080516150804.1315">def create_package(project, name, sourcefolder=None):
    """Creates a package and returns a `rope.base.resources.Folder`"""
    if sourcefolder is None:
        sourcefolder = project.root
    packages = name.split('.')
    parent = sourcefolder
    for package in packages[:-1]:
        parent = parent.get_child(package)
    made_packages = parent.create_folder(packages[-1])
    made_packages.create_file('__init__.py')
    return made_packages


</t>
<t tx="ekr.20080516150804.1316">class _Generate(object):
    @others
</t>
<t tx="ekr.20080516150804.1317">
def __init__(self, project, resource, offset):
    self.project = project
    self.resource = resource
    self.info = self._generate_info(project, resource, offset)
    self.name = self.info.get_name()
    self._check_exceptional_conditions()

</t>
<t tx="ekr.20080516150804.1318">def _generate_info(self, project, resource, offset):
    return _GenerationInfo(project.pycore, resource, offset)

</t>
<t tx="ekr.20080516150804.1319">def _check_exceptional_conditions(self):
    if self.info.element_already_exists():
        raise exceptions.RefactoringError(
            'Element &lt;%s&gt; already exists.' % self.name)
    if not self.info.primary_is_found():
        raise exceptions.RefactoringError(
            'Cannot determine the scope &lt;%s&gt; should be defined in.' % self.name)

</t>
<t tx="ekr.20080516150804.1320">def get_changes(self):
    changes = change.ChangeSet('Generate %s &lt;%s&gt;' %
                               (self._get_element_kind(), self.name))
    indents = self.info.get_scope_indents()
    blanks = self.info.get_blank_lines()
    base_definition = sourceutils.fix_indentation(self._get_element(), indents)
    definition = '\n' * blanks[0] + base_definition + '\n' * blanks[1]

    resource = self.info.get_insertion_resource()
    start, end = self.info.get_insertion_offsets()

    collector = codeanalyze.ChangeCollector(resource.read())
    collector.add_change(start, end, definition)
    changes.add_change(change.ChangeContents(
                       resource, collector.get_changed()))
    return changes

</t>
<t tx="ekr.20080516150804.1321">def get_location(self):
    return (self.info.get_insertion_resource(),
            self.info.get_insertion_lineno())

</t>
<t tx="ekr.20080516150804.1322">def _get_element_kind(self):
    raise NotImplementedError()

</t>
<t tx="ekr.20080516150804.1323">def _get_element(self):
    raise NotImplementedError()


</t>
<t tx="ekr.20080516150804.1324">class GenerateFunction(_Generate):
    @others
</t>
<t tx="ekr.20080516150804.1325">
def _generate_info(self, project, resource, offset):
    return _FunctionGenerationInfo(project.pycore, resource, offset)

</t>
<t tx="ekr.20080516150804.1326">def _get_element(self):
    decorator = ''
    args = []
    if self.info.is_static_method():
        decorator = '@staticmethod\n'
    if self.info.is_method() or self.info.is_constructor() or \
       self.info.is_instance():
        args.append('self')
    args.extend(self.info.get_passed_args())
    definition = '%sdef %s(%s):\n    pass\n' % (decorator, self.name,
                                                ', '.join(args))
    return definition

</t>
<t tx="ekr.20080516150804.1327">def _get_element_kind(self):
    return 'Function'


</t>
<t tx="ekr.20080516150804.1328">class GenerateVariable(_Generate):
    @others
</t>
<t tx="ekr.20080516150804.1329">
def _get_element(self):
    return '%s = None\n' % self.name

</t>
<t tx="ekr.20080516150804.1330">def _get_element_kind(self):
    return 'Variable'


</t>
<t tx="ekr.20080516150804.1331">class GenerateClass(_Generate):
    @others
</t>
<t tx="ekr.20080516150804.1332">
def _get_element(self):
    return 'class %s(object):\n    pass\n' % self.name

</t>
<t tx="ekr.20080516150804.1333">def _get_element_kind(self):
    return 'Class'


</t>
<t tx="ekr.20080516150804.1334">class GenerateModule(_Generate):
    @others
</t>
<t tx="ekr.20080516150804.1335">
def get_changes(self):
    package = self.info.get_package()
    changes = change.ChangeSet('Generate Module &lt;%s&gt;' % self.name)
    new_resource = self.project.get_file('%s/%s.py' % (package.path, self.name))
    if new_resource.exists():
        raise exceptions.RefactoringError(
            'Module &lt;%s&gt; already exists' % new_resource.path)
    changes.add_change(change.CreateResource(new_resource))
    changes.add_change(_add_import_to_module(
                       self.project.get_pycore(), self.resource, new_resource))
    return changes

</t>
<t tx="ekr.20080516150804.1336">def get_location(self):
    package = self.info.get_package()
    return (package.get_child('%s.py' % self.name) , 1)


</t>
<t tx="ekr.20080516150804.1337">class GeneratePackage(_Generate):
    @others
</t>
<t tx="ekr.20080516150804.1338">
def get_changes(self):
    package = self.info.get_package()
    changes = change.ChangeSet('Generate Package &lt;%s&gt;' % self.name)
    new_resource = self.project.get_folder('%s/%s' % (package.path, self.name))
    if new_resource.exists():
        raise exceptions.RefactoringError(
            'Package &lt;%s&gt; already exists' % new_resource.path)
    changes.add_change(change.CreateResource(new_resource))
    changes.add_change(_add_import_to_module(
                       self.project.get_pycore(), self.resource, new_resource))
    child = self.project.get_folder(package.path + '/' + self.name)
    changes.add_change(change.CreateFile(child, '__init__.py'))
    return changes

</t>
<t tx="ekr.20080516150804.1339">def get_location(self):
    package = self.info.get_package()
    child = package.get_child(self.name)
    return (child.get_child('__init__.py') , 1)


</t>
<t tx="ekr.20080516150804.1340">def _add_import_to_module(pycore, resource, imported):
    pymodule = pycore.resource_to_pyobject(resource)
    import_tools = importutils.ImportTools(pycore)
    module_imports = import_tools.module_imports(pymodule)
    module_name = importutils.get_module_name(pycore, imported)
    new_import = importutils.NormalImport(((module_name, None), ))
    module_imports.add_import(new_import)
    return change.ChangeContents(resource, module_imports.get_changed_source())


</t>
<t tx="ekr.20080516150804.1341">class _GenerationInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1342">
def __init__(self, pycore, resource, offset):
    self.pycore = pycore
    self.resource = resource
    self.offset = offset
    self.source_pymodule = self.pycore.resource_to_pyobject(resource)
    finder = rope.base.evaluate.ScopeNameFinder(self.source_pymodule)
    self.primary, self.pyname = finder.get_primary_and_pyname_at(offset)
    self._init_fields()

</t>
<t tx="ekr.20080516150804.1343">def _init_fields(self):
    self.source_scope = self._get_source_scope()
    self.goal_scope = self._get_goal_scope()
    self.goal_pymodule = self._get_goal_module(self.goal_scope)

</t>
<t tx="ekr.20080516150804.1344">def _get_goal_scope(self):
    if self.primary is None:
        return self._get_source_scope()
    pyobject = self.primary.get_object()
    if isinstance(pyobject, pyobjects.PyDefinedObject):
        return pyobject.get_scope()
    elif isinstance(pyobject.get_type(), pyobjects.PyClass):
        return pyobject.get_type().get_scope()

</t>
<t tx="ekr.20080516150804.1345">def _get_goal_module(self, scope):
    if scope is None:
        return
    while scope.parent is not None:
        scope = scope.parent
    return scope.pyobject

</t>
<t tx="ekr.20080516150804.1346">def _get_source_scope(self):
    module_scope = self.source_pymodule.get_scope()
    lineno = self.source_pymodule.lines.get_line_number(self.offset)
    return module_scope.get_inner_scope_for_line(lineno)

</t>
<t tx="ekr.20080516150804.1347">def get_insertion_lineno(self):
    lines = self.goal_pymodule.lines
    if self.goal_scope == self.source_scope:
        line_finder = self.goal_pymodule.logical_lines
        lineno = lines.get_line_number(self.offset)
        lineno = line_finder.logical_line_in(lineno)[0]
        root = suites.ast_suite_tree(self.goal_scope.pyobject.get_ast())
        suite = root.find_suite(lineno)
        indents = sourceutils.get_indents(lines, lineno)
        while self.get_scope_indents() &lt; indents:
            lineno = suite.get_start()
            indents = sourceutils.get_indents(lines, lineno)
            suite = suite.parent
        return lineno
    else:
        return min(self.goal_scope.get_end() + 1, lines.length())

</t>
<t tx="ekr.20080516150804.1348">def get_insertion_resource(self):
    return self.goal_pymodule.get_resource()

</t>
<t tx="ekr.20080516150804.1349">def get_insertion_offsets(self):
    if self.goal_scope.get_kind() == 'Class':
        start, end = sourceutils.get_body_region(self.goal_scope.pyobject)
        if self.goal_pymodule.source_code[start:end].strip() == 'pass':
            return start, end
    lines = self.goal_pymodule.lines
    start = lines.get_line_start(self.get_insertion_lineno())
    return (start, start)

</t>
<t tx="ekr.20080516150804.1350">def get_scope_indents(self):
    if self.goal_scope.get_kind() == 'Module':
        return 0
    return sourceutils.get_indents(self.goal_pymodule.lines,
                                   self.goal_scope.get_start()) + 4

</t>
<t tx="ekr.20080516150804.1351">def get_blank_lines(self):
    if self.goal_scope.get_kind() == 'Module':
        base_blanks = 2
        if self.goal_pymodule.source_code.strip() == '':
            base_blanks = 0
    if self.goal_scope.get_kind() == 'Class':
        base_blanks = 1
    if self.goal_scope.get_kind() == 'Function':
        base_blanks = 0
    if self.goal_scope == self.source_scope:
        return (0, base_blanks)
    return (base_blanks, 0)

</t>
<t tx="ekr.20080516150804.1352">def get_package(self):
    primary = self.primary
    if self.primary is None:
        return self.pycore.get_source_folders()[0]
    if isinstance(primary.get_object(), pyobjects.PyPackage):
        return primary.get_object().get_resource()
    raise exceptions.RefactoringError(
        'A module/package can be only created in a package.')

</t>
<t tx="ekr.20080516150804.1353">def primary_is_found(self):
    return self.goal_scope is not None

</t>
<t tx="ekr.20080516150804.1354">def element_already_exists(self):
    if self.pyname is None or isinstance(self.pyname, pynames.UnboundName):
        return False
    return self.get_name() in self.goal_scope.get_defined_names()

</t>
<t tx="ekr.20080516150804.1355">def get_name(self):
    return worder.get_name_at(self.resource, self.offset)


</t>
<t tx="ekr.20080516150804.1356">class _FunctionGenerationInfo(_GenerationInfo):
    @others
</t>
<t tx="ekr.20080516150804.1357">
def _get_goal_scope(self):
    if self.is_constructor():
        return self.pyname.get_object().get_scope()
    if self.is_instance():
        return self.pyname.get_object().get_type().get_scope()
    if self.primary is None:
        return self._get_source_scope()
    pyobject = self.primary.get_object()
    if isinstance(pyobject, pyobjects.PyDefinedObject):
        return pyobject.get_scope()
    elif isinstance(pyobject.get_type(), pyobjects.PyClass):
        return pyobject.get_type().get_scope()

</t>
<t tx="ekr.20080516150804.1358">def element_already_exists(self):
    if self.pyname is None or isinstance(self.pyname, pynames.UnboundName):
        return False
    return self.get_name() in self.goal_scope.get_defined_names()

</t>
<t tx="ekr.20080516150804.1359">def is_static_method(self):
    return self.primary is not None and \
           isinstance(self.primary.get_object(), pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1360">def is_method(self):
    return self.primary is not None and \
           isinstance(self.primary.get_object().get_type(), pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1361">def is_constructor(self):
    return self.pyname is not None and \
           isinstance(self.pyname.get_object(), pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1362">def is_instance(self):
    if self.pyname is None:
        return False
    pyobject = self.pyname.get_object()
    return isinstance(pyobject.get_type(), pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1363">def get_name(self):
    if self.is_constructor():
        return '__init__'
    if self.is_instance():
        return '__call__'
    return worder.get_name_at(self.resource, self.offset)

</t>
<t tx="ekr.20080516150804.1364">def get_passed_args(self):
    result = []
    source = self.source_pymodule.source_code
    finder = worder.Worder(source)
    if finder.is_a_function_being_called(self.offset):
        start, end = finder.get_primary_range(self.offset)
        parens_start, parens_end = finder.get_word_parens_range(end - 1)
        call = source[start:parens_end]
        parser = functionutils._FunctionParser(call, False)
        args, keywords = parser.get_parameters()
        for arg in args:
            if self._is_id(arg):
                result.append(arg)
            else:
                result.append('arg%d' % len(result))
        for name, value in keywords:
            result.append(name)
    return result

</t>
<t tx="ekr.20080516150804.1365">def _is_id(self, arg):
    def id_or_underline(c):
        return c.isalpha() or c == '_'
    for c in arg:
        if not id_or_underline(c) and not c.isdigit():
            return False
    return id_or_underline(arg[0])
</t>
<t tx="ekr.20080516150804.1366">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1367">"""rope IDE tools package

This package contains modules that can be used in IDEs
but do not depend on the UI.  So these modules will be used
by `rope.ui` modules.

"""
</t>
<t tx="ekr.20080516150804.1368"></t>
<t tx="ekr.20080516150804.1369">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1370">import copy

import rope.base.exceptions
from rope.base import pyobjects, taskhandle, evaluate, worder, codeanalyze, utils
from rope.base.change import ChangeContents, ChangeSet
from rope.refactor import occurrences, functionutils


</t>
<t tx="ekr.20080516150804.1371">class ChangeSignature(object):
    @others
</t>
<t tx="ekr.20080516150804.1372">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    self.resource = resource
    self.offset = offset
    self._set_name_and_pyname()
    if self.pyname is None or self.pyname.get_object() is None or \
       not isinstance(self.pyname.get_object(), pyobjects.PyFunction):
        raise rope.base.exceptions.RefactoringError(
            'Change method signature should be performed on functions')

</t>
<t tx="ekr.20080516150804.1373">def _set_name_and_pyname(self):
    self.name = worder.get_name_at(self.resource, self.offset)
    this_pymodule = self.pycore.resource_to_pyobject(self.resource)
    self.primary, self.pyname = evaluate.get_primary_and_pyname_at(
        this_pymodule, self.offset)
    if self.pyname is None:
        return
    pyobject = self.pyname.get_object()
    if isinstance(pyobject, pyobjects.PyClass) and \
       '__init__' in pyobject:
        self.pyname = pyobject['__init__']
        self.name = '__init__'
    pyobject = self.pyname.get_object()
    self.others = None
    if self.name == '__init__' and \
       isinstance(pyobject, pyobjects.PyFunction) and \
       isinstance(pyobject.parent, pyobjects.PyClass):
        pyclass = pyobject.parent
        self.others = (pyclass.get_name(),
                       pyclass.parent[pyclass.get_name()])

</t>
<t tx="ekr.20080516150804.1374">def _change_calls(self, call_changer, in_hierarchy=None, resources=None,
                  handle=taskhandle.NullTaskHandle()):
    if resources is None:
        resources = self.pycore.get_python_files()
    changes = ChangeSet('Changing signature of &lt;%s&gt;' % self.name)
    job_set = handle.create_jobset('Collecting Changes', len(resources))
    finder = occurrences.create_finder(
        self.pycore, self.name, self.pyname, instance=self.primary,
        in_hierarchy=in_hierarchy and self.is_method())
    if self.others:
        name, pyname = self.others
        constructor_finder = occurrences.create_finder(
            self.pycore, name, pyname, only_calls=True)
        finder = _MultipleFinders([finder, constructor_finder])
    for file in resources:
        job_set.started_job(file.path)
        change_calls = _ChangeCallsInModule(
            self.pycore, finder, file, call_changer)
        changed_file = change_calls.get_changed_module()
        if changed_file is not None:
            changes.add_change(ChangeContents(file, changed_file))
        job_set.finished_job()
    return changes

</t>
<t tx="ekr.20080516150804.1375">def is_method(self):
    pyfunction = self.pyname.get_object()
    return isinstance(pyfunction.parent, pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1376">def get_definition_info(self):
    return functionutils.DefinitionInfo.read(self.pyname.get_object())

</t>
<t tx="ekr.20080516150804.1377">def normalize(self):
    changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(),
        [ArgumentNormalizer()])
    return self._change_calls(changer)

</t>
<t tx="ekr.20080516150804.1378">def remove(self, index):
    changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(),
        [ArgumentRemover(index)])
    return self._change_calls(changer)

</t>
<t tx="ekr.20080516150804.1379">def add(self, index, name, default=None, value=None):
    changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(),
        [ArgumentAdder(index, name, default, value)])
    return self._change_calls(changer)

</t>
<t tx="ekr.20080516150804.1380">def inline_default(self, index):
    changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(),
        [ArgumentDefaultInliner(index)])
    return self._change_calls(changer)

</t>
<t tx="ekr.20080516150804.1381">def reorder(self, new_ordering):
    changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(),
        [ArgumentReorderer(new_ordering)])
    return self._change_calls(changer)

</t>
<t tx="ekr.20080516150804.1382">def get_changes(self, changers, in_hierarchy=False, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get changes caused by this refactoring

    `changers` is a list of `_ArgumentChanger`\s.  If `in_hierarchy`
    is `True` the changers are applyed to all matching methods in
    the class hierarchy.
    `resources` can be a list of `rope.base.resource.File`\s that
    should be searched for occurrences; if `None` all python files
    in the project are searched.

    """
    function_changer = _FunctionChangers(
        self.pyname.get_object(), self.get_definition_info(), changers)
    return self._change_calls(function_changer, in_hierarchy,
                              resources, task_handle)


</t>
<t tx="ekr.20080516150804.1383">class _FunctionChangers(object):
    @others
</t>
<t tx="ekr.20080516150804.1384">
def __init__(self, pyfunction, definition_info, changers=None):
    self.pyfunction = pyfunction
    self.definition_info = definition_info
    self.changers = changers
    self.changed_definition_infos = self._get_changed_definition_infos()

</t>
<t tx="ekr.20080516150804.1385">def _get_changed_definition_infos(self):
    result = []
    definition_info = self.definition_info
    result.append(definition_info)
    for changer in self.changers:
        definition_info = copy.deepcopy(definition_info)
        changer.change_definition_info(definition_info)
        result.append(definition_info)
    return result

</t>
<t tx="ekr.20080516150804.1386">def change_definition(self, call):
    return self.changed_definition_infos[-1].to_string()

</t>
<t tx="ekr.20080516150804.1387">def change_call(self, primary, pyname, call):
    call_info = functionutils.CallInfo.read(
        primary, pyname, self.definition_info, call)
    mapping = functionutils.ArgumentMapping(self.definition_info, call_info)

    for definition_info, changer in zip(self.changed_definition_infos, self.changers):
        changer.change_argument_mapping(definition_info, mapping)

    return mapping.to_call_info(self.changed_definition_infos[-1]).to_string()


</t>
<t tx="ekr.20080516150804.1388">class _ArgumentChanger(object):
    @others
</t>
<t tx="ekr.20080516150804.1389">
def change_definition_info(self, definition_info):
    pass

</t>
<t tx="ekr.20080516150804.1390">def change_argument_mapping(self, definition_info, argument_mapping):
    pass


</t>
<t tx="ekr.20080516150804.1391">class ArgumentNormalizer(_ArgumentChanger):
    pass


</t>
<t tx="ekr.20080516150804.1392">class ArgumentRemover(_ArgumentChanger):
    @others
</t>
<t tx="ekr.20080516150804.1393">
def __init__(self, index):
    self.index = index

</t>
<t tx="ekr.20080516150804.1394">def change_definition_info(self, call_info):
    if self.index &lt; len(call_info.args_with_defaults):
        del call_info.args_with_defaults[self.index]
    elif self.index == len(call_info.args_with_defaults) and \
       call_info.args_arg is not None:
        call_info.args_arg = None
    elif (self.index == len(call_info.args_with_defaults) and
        call_info.args_arg is None and call_info.keywords_arg is not None) or \
       (self.index == len(call_info.args_with_defaults) + 1 and
        call_info.args_arg is not None and call_info.keywords_arg is not None):
        call_info.keywords_arg = None

</t>
<t tx="ekr.20080516150804.1395">def change_argument_mapping(self, definition_info, mapping):
    if self.index &lt; len(definition_info.args_with_defaults):
        name = definition_info.args_with_defaults[0]
        if name in mapping.param_dict:
            del mapping.param_dict[name]


</t>
<t tx="ekr.20080516150804.1396">class ArgumentAdder(_ArgumentChanger):
    @others
</t>
<t tx="ekr.20080516150804.1397">
def __init__(self, index, name, default=None, value=None):
    self.index = index
    self.name = name
    self.default = default
    self.value = value

</t>
<t tx="ekr.20080516150804.1398">def change_definition_info(self, definition_info):
    for pair in definition_info.args_with_defaults:
        if pair[0] == self.name:
            raise rope.base.exceptions.RefactoringError(
                'Adding duplicate parameter: &lt;%s&gt;.' % self.name)
    definition_info.args_with_defaults.insert(self.index,
                                              (self.name, self.default))

</t>
<t tx="ekr.20080516150804.1399">def change_argument_mapping(self, definition_info, mapping):
    if self.value is not None:
        mapping.param_dict[self.name] = self.value


</t>
<t tx="ekr.20080516150804.1400">class ArgumentDefaultInliner(_ArgumentChanger):
    @others
</t>
<t tx="ekr.20080516150804.1401">
def __init__(self, index):
    self.index = index
    self.remove = False

</t>
<t tx="ekr.20080516150804.1402">def change_definition_info(self, definition_info):
    if self.remove:
        definition_info.args_with_defaults[self.index] = \
            (definition_info.args_with_defaults[self.index][0], None)

</t>
<t tx="ekr.20080516150804.1403">def change_argument_mapping(self, definition_info, mapping):
    default = definition_info.args_with_defaults[self.index][1]
    name = definition_info.args_with_defaults[self.index][0]
    if default is not None and name not in mapping.param_dict:
        mapping.param_dict[name] = default


</t>
<t tx="ekr.20080516150804.1404">class ArgumentReorderer(_ArgumentChanger):
    @others
</t>
<t tx="ekr.20080516150804.1405">
def __init__(self, new_order, autodef=None):
    """Construct an `ArgumentReorderer`

    Note that the `new_order` is a list containing the new
    position of parameters; not the position each parameter
    is going to be moved to. (changed in ``0.5m4``)

    For example changing ``f(a, b, c)`` to ``f(c, a, b)``
    requires passing ``[2, 0, 1]`` and *not* ``[1, 2, 0]``.

    The `autodef` (automatic default) argument, forces rope to use
    it as a default if a default is needed after the change.  That
    happens when an argument without default is moved after
    another that has a default value.  Note that `autodef` should
    be a string or `None`; the latter disables adding automatic
    default.

    """
    self.new_order = new_order
    self.autodef = autodef

</t>
<t tx="ekr.20080516150804.1406">def change_definition_info(self, definition_info):
    new_args = list(definition_info.args_with_defaults)
    for new_index, index in enumerate(self.new_order):
        new_args[new_index] = definition_info.args_with_defaults[index]
    seen_default = False
    for index, (arg, default) in enumerate(list(new_args)):
        if default is not None:
            seen_default = True
        if seen_default and default is None and self.autodef is not None:
            new_args[index] = (arg, self.autodef)
    definition_info.args_with_defaults = new_args


</t>
<t tx="ekr.20080516150804.1407">class _ChangeCallsInModule(object):
    @others
</t>
<t tx="ekr.20080516150804.1408">
def __init__(self, pycore, occurrence_finder, resource, call_changer):
    self.pycore = pycore
    self.occurrence_finder = occurrence_finder
    self.resource = resource
    self.call_changer = call_changer

</t>
<t tx="ekr.20080516150804.1409">def get_changed_module(self):
    word_finder = worder.Worder(self.source)
    change_collector = codeanalyze.ChangeCollector(self.source)
    for occurrence in self.occurrence_finder.find_occurrences(self.resource):
        if not occurrence.is_called() and not occurrence.is_defined():
            continue
        start, end = occurrence.get_primary_range()
        begin_parens, end_parens = word_finder.get_word_parens_range(end - 1)
        if occurrence.is_called():
            primary, pyname = occurrence.get_primary_and_pyname()
            changed_call = self.call_changer.change_call(
                primary, pyname, self.source[start:end_parens])
        else:
            changed_call = self.call_changer.change_definition(
                self.source[start:end_parens])
        if changed_call is not None:
            change_collector.add_change(start, end_parens, changed_call)
    return change_collector.get_changed()

</t>
<t tx="ekr.20080516150804.1410">@property
@utils.cacheit
def pymodule(self):
    return self.pycore.resource_to_pyobject(self.resource)

</t>
<t tx="ekr.20080516150804.1411">@property
@utils.cacheit
def source(self):
    if self.resource is not None:
        return self.resource.read()
    else:
        return self.pymodule.source_code

</t>
<t tx="ekr.20080516150804.1412">@property
@utils.cacheit
def lines(self):
    return self.pymodule.lines


</t>
<t tx="ekr.20080516150804.1413">class _MultipleFinders(object):
    @others
</t>
<t tx="ekr.20080516150804.1414">
def __init__(self, finders):
    self.finders = finders

</t>
<t tx="ekr.20080516150804.1415">def find_occurrences(self, resource=None, pymodule=None):
    all_occurrences = []
    for finder in self.finders:
        all_occurrences.extend(finder.find_occurrences(resource, pymodule))
    all_occurrences.sort(self._cmp_occurrences)
    return all_occurrences

</t>
<t tx="ekr.20080516150804.1416">def _cmp_occurrences(self, o1, o2):
    return cmp(o1.get_primary_range(), o2.get_primary_range())
</t>
<t tx="ekr.20080516150804.1417">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1418">from rope.base import pynames, taskhandle, evaluate, exceptions, worder, utils
from rope.base.change import ChangeSet, ChangeContents
from rope.refactor import sourceutils, occurrences


</t>
<t tx="ekr.20080516150804.1419">class EncapsulateField(object):
    @others
</t>
<t tx="ekr.20080516150804.1420">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    self.name = worder.get_name_at(resource, offset)
    this_pymodule = self.pycore.resource_to_pyobject(resource)
    self.pyname = evaluate.get_pyname_at(this_pymodule, offset)
    if not self._is_an_attribute(self.pyname):
        raise exceptions.RefactoringError(
            'Encapsulate field should be performed on class attributes.')
    self.resource = self.pyname.get_definition_location()[0].get_resource()

</t>
<t tx="ekr.20080516150804.1421">def get_changes(self, getter=None, setter=None, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get the changes this refactoring makes

    If `getter` is not `None`, that will be the name of the
    getter, otherwise ``get_${field_name}`` will be used.  The
    same is true for `setter` and if it is None set_${field_name} is
    used.

    `resources` can be a list of `rope.base.resource.File`\s that
    the refactoring should be applied on; if `None` all python
    files in the project are searched.

    """
    if resources is None:
        resources = self.pycore.get_python_files()
    changes = ChangeSet('Encapsulate field &lt;%s&gt;' % self.name)
    job_set = task_handle.create_jobset('Collecting Changes',
                                        len(resources))
    if getter is None:
        getter = 'get_' + self.name
    if setter is None:
        setter = 'set_' + self.name
    renamer = GetterSetterRenameInModule(
        self.pycore, self.name, self.pyname, getter, setter)
    for file in resources:
        job_set.started_job(file.path)
        if file == self.resource:
            result = self._change_holding_module(changes, renamer,
                                                 getter, setter)
            changes.add_change(ChangeContents(self.resource, result))
        else:
            result = renamer.get_changed_module(file)
            if result is not None:
                changes.add_change(ChangeContents(file, result))
        job_set.finished_job()
    return changes

</t>
<t tx="ekr.20080516150804.1422">def get_field_name(self):
    """Get the name of the field to be encapsulated"""
    return self.name

</t>
<t tx="ekr.20080516150804.1423">def _is_an_attribute(self, pyname):
    if pyname is not None and isinstance(pyname, pynames.AssignedName):
        pymodule, lineno = self.pyname.get_definition_location()
        scope = pymodule.get_scope().\
                         get_inner_scope_for_line(lineno)
        if scope.get_kind() == 'Class':
            return pyname in scope.get_names().values()
        parent = scope.parent
        if parent is not None and parent.get_kind() == 'Class':
            return pyname in parent.get_names().values()
    return False

</t>
<t tx="ekr.20080516150804.1424">def _get_defining_class_scope(self):
    defining_scope = self._get_defining_scope()
    if defining_scope.get_kind() == 'Function':
        defining_scope = defining_scope.parent
    return defining_scope

</t>
<t tx="ekr.20080516150804.1425">def _get_defining_scope(self):
    pymodule, line = self.pyname.get_definition_location()
    return pymodule.get_scope().get_inner_scope_for_line(line)

</t>
<t tx="ekr.20080516150804.1426">def _change_holding_module(self, changes, renamer, getter, setter):
    pymodule = self.pycore.resource_to_pyobject(self.resource)
    class_scope = self._get_defining_class_scope()
    defining_object = self._get_defining_scope().pyobject
    start, end = sourceutils.get_body_region(defining_object)

    new_source = renamer.get_changed_module(pymodule=pymodule,
                                            skip_start=start, skip_end=end)
    if new_source is not None:
        pymodule = self.pycore.get_string_module(new_source, self.resource)
        class_scope = pymodule.get_scope().\
                      get_inner_scope_for_line(class_scope.get_start())
    indents = sourceutils.get_indent(self.pycore) * ' '
    getter = 'def %s(self):\n%sreturn self.%s' % \
             (getter, indents, self.name)
    setter = 'def %s(self, value):\n%sself.%s = value' % \
             (setter, indents, self.name)
    new_source = sourceutils.add_methods(pymodule, class_scope,
                                         [getter, setter])
    return new_source


</t>
<t tx="ekr.20080516150804.1427">class GetterSetterRenameInModule(object):
    @others
</t>
<t tx="ekr.20080516150804.1428">
def __init__(self, pycore, name, pyname, getter, setter):
    self.pycore = pycore
    self.name = name
    self.finder = occurrences.create_finder(pycore, name, pyname)
    self.getter = getter
    self.setter = setter

</t>
<t tx="ekr.20080516150804.1429">def get_changed_module(self, resource=None, pymodule=None,
                       skip_start=0, skip_end=0):
    change_finder = _FindChangesForModule(self, resource, pymodule,
                                          skip_start, skip_end)
    return change_finder.get_changed_module()


</t>
<t tx="ekr.20080516150804.1430">class _FindChangesForModule(object):
    @others
</t>
<t tx="ekr.20080516150804.1431">
def __init__(self, finder, resource, pymodule, skip_start, skip_end):
    self.pycore = finder.pycore
    self.finder = finder.finder
    self.getter = finder.getter
    self.setter = finder.setter
    self.resource = resource
    self.pymodule = pymodule
    self.last_modified = 0
    self.last_set = None
    self.set_index = None
    self.skip_start = skip_start
    self.skip_end = skip_end

</t>
<t tx="ekr.20080516150804.1432">def get_changed_module(self):
    result = []
    for occurrence in self.finder.find_occurrences(self.resource,
                                                   self.pymodule):
        start, end = occurrence.get_word_range()
        if self.skip_start &lt;= start &lt; self.skip_end:
            continue
        self._manage_writes(start, result)
        result.append(self.source[self.last_modified:start])
        if self._is_assigned_in_a_tuple_assignment(occurrence):
            raise exceptions.RefactoringError(
                'Cannot handle tuple assignments in encapsulate field.')
        if occurrence.is_written():
            assignment_type = self.worder.get_assignment_type(start)
            if assignment_type == '=':
                result.append(self.setter + '(')
            else:
                var_name = self.source[occurrence.get_primary_range()[0]:
                                       start] + self.getter + '()'
                result.append(self.setter + '(' + var_name
                              + ' %s ' % assignment_type[:-1])
            current_line = self.lines.get_line_number(start)
            start_line, end_line = self.pymodule.logical_lines.\
                                   logical_line_in(current_line)
            self.last_set = self.lines.get_line_end(end_line)
            end = self.source.index('=', end) + 1
            self.set_index = len(result)
        else:
            result.append(self.getter + '()')
        self.last_modified = end
    if self.last_modified != 0:
        self._manage_writes(len(self.source), result)
        result.append(self.source[self.last_modified:])
        return ''.join(result)
    return None

</t>
<t tx="ekr.20080516150804.1433">def _manage_writes(self, offset, result):
    if self.last_set is not None and self.last_set &lt;= offset:
        result.append(self.source[self.last_modified:self.last_set])
        set_value = ''.join(result[self.set_index:]).strip()
        del result[self.set_index:]
        result.append(set_value + ')')
        self.last_modified = self.last_set
        self.last_set = None

</t>
<t tx="ekr.20080516150804.1434">def _is_assigned_in_a_tuple_assignment(self, occurance):
    offset = occurance.get_word_range()[0]
    return self.worder.is_assigned_in_a_tuple_assignment(offset)

</t>
<t tx="ekr.20080516150804.1435">@property
@utils.cacheit
def source(self):
    if self.resource is not None:
        return self.resource.read()
    else:
        return self.pymodule.source_code

</t>
<t tx="ekr.20080516150804.1436">@property
@utils.cacheit
def lines(self):
    if self.pymodule is None:
        self.pymodule = self.pycore.resource_to_pyobject(self.resource)
    return self.pymodule.lines

</t>
<t tx="ekr.20080516150804.1437">@property
@utils.cacheit
def worder(self):
    return worder.Worder(self.source)
</t>
<t tx="ekr.20080516150804.1438">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1439">import re

from rope.base import ast, codeanalyze
from rope.base.change import ChangeSet, ChangeContents
from rope.base.exceptions import RefactoringError
from rope.refactor import (sourceutils, similarfinder,
                           patchedast, suites, usefunction)


</t>
<t tx="ekr.20080516150804.1440"># Extract refactoring has lots of special cases.  I tried to split it
# to smaller parts to make it more manageable:
#
# _ExtractInfo: holds information about the refactoring; it is passed
# to the parts that need to have information about the refactoring
# 
# _ExtractCollector: merely saves all of the information necessary for
# performing the refactoring.
#
# _DefinitionLocationFinder: finds where to insert the definition.
#
# _ExceptionalConditionChecker: checks for exceptional conditions in
# which the refactoring cannot be applied.
#
# _ExtractMethodParts: generates the pieces of code (like definition)
# needed for performing extract method.
#
# _ExtractVariableParts: like _ExtractMethodParts for variables.
#
# _ExtractPerformer: Uses above classes to collect refactoring
# changes.
#
# There are a few more helper functions and classes used by above
# classes.
class _ExtractRefactoring(object):
    @others
</t>
<t tx="ekr.20080516150804.1441">
def __init__(self, project, resource, start_offset, end_offset,
             variable=False):
    self.project = project
    self.pycore = project.pycore
    self.resource = resource
    self.start_offset = self._fix_start(resource.read(), start_offset)
    self.end_offset = self._fix_end(resource.read(), end_offset)

</t>
<t tx="ekr.20080516150804.1442">def _fix_start(self, source, offset):
    while offset &lt; len(source) and source[offset].isspace():
        offset += 1
    return offset

</t>
<t tx="ekr.20080516150804.1443">def _fix_end(self, source, offset):
    while offset &gt; 0 and source[offset - 1].isspace():
        offset -= 1
    return offset

</t>
<t tx="ekr.20080516150804.1444">def get_changes(self, extracted_name, similar=False, global_=False):
    """Get the changes this refactoring makes

    :parameters:
        - `similar`: if `True`, similar expressions/statements are also
          replaced.
        - `global_`: if `True`, the extracted method/variable will
          be global.

    """
    info = _ExtractInfo(
        self.project, self.resource, self.start_offset, self.end_offset,
        extracted_name, variable=self.kind == 'variable',
        similar=similar, make_global=global_)
    new_contents = _ExtractPerformer(info).extract()
    changes = ChangeSet('Extract %s &lt;%s&gt;' % (self.kind,
                                             extracted_name))
    changes.add_change(ChangeContents(self.resource, new_contents))
    return changes


</t>
<t tx="ekr.20080516150804.1445">class ExtractMethod(_ExtractRefactoring):
    @others
    kind = 'method'


</t>
<t tx="ekr.20080516150804.1446">
def __init__(self, *args, **kwds):
    super(ExtractMethod, self).__init__(*args, **kwds)

</t>
<t tx="ekr.20080516150804.1447">class ExtractVariable(_ExtractRefactoring):
    @others
    kind = 'variable'


</t>
<t tx="ekr.20080516150804.1448">
def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    kwds['variable'] = True
    super(ExtractVariable, self).__init__(*args, **kwds)

</t>
<t tx="ekr.20080516150804.1449">class _ExtractInfo(object):
    """Holds information about the extract to be performed"""
    @others
</t>
<t tx="ekr.20080516150804.1450">
def __init__(self, project, resource, start, end, new_name,
             variable, similar, make_global):
    self.pycore = project.pycore
    self.resource = resource
    self.pymodule = self.pycore.resource_to_pyobject(resource)
    self.global_scope = self.pymodule.get_scope()
    self.source = self.pymodule.source_code
    self.lines = self.pymodule.lines
    self.new_name = new_name
    self.variable = variable
    self.similar = similar
    self._init_parts(start, end)
    self._init_scope()
    self.make_global = make_global

</t>
<t tx="ekr.20080516150804.1451">def _init_parts(self, start, end):
    self.region = (self._choose_closest_line_end(start),
                   self._choose_closest_line_end(end, end=True))

    start = self.logical_lines.logical_line_in(
        self.lines.get_line_number(self.region[0]))[0]
    end = self.logical_lines.logical_line_in(
        self.lines.get_line_number(self.region[1]))[1]
    self.region_lines = (start, end)

    self.lines_region = (self.lines.get_line_start(self.region_lines[0]),
                         self.lines.get_line_end(self.region_lines[1]))

</t>
<t tx="ekr.20080516150804.1452">@property
def logical_lines(self):
    return self.pymodule.logical_lines

</t>
<t tx="ekr.20080516150804.1453">def _init_scope(self):
    start_line = self.region_lines[0]
    scope = self.global_scope.get_inner_scope_for_line(start_line)
    if scope.get_kind() != 'Module' and scope.get_start() == start_line:
        scope = scope.parent
    self.scope = scope
    self.scope_region = self._get_scope_region(self.scope)

</t>
<t tx="ekr.20080516150804.1454">def _get_scope_region(self, scope):
    return (self.lines.get_line_start(scope.get_start()),
            self.lines.get_line_end(scope.get_end()) + 1)

</t>
<t tx="ekr.20080516150804.1455">def _choose_closest_line_end(self, offset, end=False):
    lineno = self.lines.get_line_number(offset)
    line_start = self.lines.get_line_start(lineno)
    line_end = self.lines.get_line_end(lineno)
    if self.source[line_start:offset].strip() == '':
        if end:
            return line_start - 1
        else:
            return line_start
    elif self.source[offset:line_end].strip() == '':
        return min(line_end, len(self.source))
    return offset

</t>
<t tx="ekr.20080516150804.1456">@property
def one_line(self):
    return self.region != self.lines_region and \
           (self.logical_lines.logical_line_in(self.region_lines[0]) ==
            self.logical_lines.logical_line_in(self.region_lines[1]))

</t>
<t tx="ekr.20080516150804.1457">@property
def global_(self):
    return self.scope.parent is None

</t>
<t tx="ekr.20080516150804.1458">@property
def method(self):
    return self.scope.parent is not None and \
           self.scope.parent.get_kind() == 'Class'

</t>
<t tx="ekr.20080516150804.1459">@property
def indents(self):
    return sourceutils.get_indents(self.pymodule.lines,
                                   self.region_lines[0])

</t>
<t tx="ekr.20080516150804.1460">@property
def scope_indents(self):
    if self.global_:
        return 0
    return sourceutils.get_indents(self.pymodule.lines,
                                   self.scope.get_start())

</t>
<t tx="ekr.20080516150804.1461">@property
def extracted(self):
    return self.source[self.region[0]:self.region[1]]

</t>
<t tx="ekr.20080516150804.1462">_returned = None
@property
def returned(self):
    """Does the extracted piece contain return statement"""
    if self._returned is None:
        node = _parse_text(self.extracted)
        self._returned = usefunction._returns_last(node)
    return self._returned


</t>
<t tx="ekr.20080516150804.1463">class _ExtractCollector(object):
    """Collects information needed for performing the extract"""
    @others
</t>
<t tx="ekr.20080516150804.1464">
def __init__(self, info):
    self.definition = None
    self.body_pattern = None
    self.checks = {}
    self.replacement_pattern = None
    self.matches = None
    self.replacements = None
    self.definition_location = None


</t>
<t tx="ekr.20080516150804.1465">class _ExtractPerformer(object):
    @others
</t>
<t tx="ekr.20080516150804.1466">
def __init__(self, info):
    self.info = info
    _ExceptionalConditionChecker()(self.info)

</t>
<t tx="ekr.20080516150804.1467">def extract(self):
    extract_info = self._collect_info()
    content = codeanalyze.ChangeCollector(self.info.source)
    definition = extract_info.definition
    lineno, indents = extract_info.definition_location
    offset = self.info.lines.get_line_start(lineno)
    indented = sourceutils.fix_indentation(definition, indents)
    content.add_change(offset, offset, indented)
    self._replace_occurrences(content, extract_info)
    return content.get_changed()

</t>
<t tx="ekr.20080516150804.1468">def _replace_occurrences(self, content, extract_info):
    for match in extract_info.matches:
        replacement = similarfinder.CodeTemplate(
            extract_info.replacement_pattern)
        mapping = {}
        for name in replacement.get_names():
            node = match.get_ast(name)
            if node:
                start, end = patchedast.node_region(match.get_ast(name))
                mapping[name] = self.info.source[start:end]
            else:
                mapping[name] = name
        region = match.get_region()
        content.add_change(region[0], region[1],
                           replacement.substitute(mapping))

</t>
<t tx="ekr.20080516150804.1469">def _collect_info(self):
    extract_collector = _ExtractCollector(self.info)
    self._find_definition(extract_collector)
    self._find_matches(extract_collector)
    self._find_definition_location(extract_collector)
    return extract_collector

</t>
<t tx="ekr.20080516150804.1470">def _find_matches(self, collector):
    regions = self._where_to_search()
    finder = similarfinder.SimilarFinder(self.info.pymodule)
    matches = []
    for start, end in regions:
        matches.extend((finder.get_matches(collector.body_pattern,
                                           collector.checks, start, end)))
    collector.matches = matches

</t>
<t tx="ekr.20080516150804.1471">def _where_to_search(self):
    if self.info.similar:
        if self.info.make_global or self.info.global_:
            return [(0, len(self.info.pymodule.source_code))]
        if self.info.method and not self.info.variable:
            class_scope = self.info.scope.parent
            regions = []
            method_kind = _get_function_kind(self.info.scope)
            for scope in class_scope.get_scopes():
                if method_kind == 'method' and \
                   _get_function_kind(scope) != 'method':
                    continue
                start = self.info.lines.get_line_start(scope.get_start())
                end = self.info.lines.get_line_end(scope.get_end())
                regions.append((start, end))
            return regions
        else:
            if self.info.variable:
                return [self.info.scope_region]
            else:
                return [self.info._get_scope_region(self.info.scope.parent)]
    else:
        return [self.info.region]

</t>
<t tx="ekr.20080516150804.1472">def _find_definition_location(self, collector):
    matched_lines = []
    for match in collector.matches:
        start = self.info.lines.get_line_number(match.get_region()[0])
        start_line = self.info.logical_lines.logical_line_in(start)[0]
        matched_lines.append(start_line)
    location_finder = _DefinitionLocationFinder(self.info, matched_lines)
    collector.definition_location = (location_finder.find_lineno(),
                                     location_finder.find_indents())

</t>
<t tx="ekr.20080516150804.1473">def _find_definition(self, collector):
    if self.info.variable:
        parts = _ExtractVariableParts(self.info)
    else:
        parts = _ExtractMethodParts(self.info)
    collector.definition = parts.get_definition()
    collector.body_pattern = parts.get_body_pattern()
    collector.replacement_pattern = parts.get_replacement_pattern()
    collector.checks = parts.get_checks()


</t>
<t tx="ekr.20080516150804.1474">class _DefinitionLocationFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.1475">
def __init__(self, info, matched_lines):
    self.info = info
    self.matched_lines = matched_lines
    # This only happens when subexpressions cannot be matched
    if not matched_lines:
        self.matched_lines.append(self.info.region_lines[0])

</t>
<t tx="ekr.20080516150804.1476">def find_lineno(self):
    if self.info.variable and not self.info.make_global:
        return self._get_before_line()
    if self.info.make_global or self.info.global_:
        toplevel = self._find_toplevel(self.info.scope)
        ast = self.info.pymodule.get_ast()
        newlines = sorted(self.matched_lines + [toplevel.get_end() + 1])
        return suites.find_visible(ast, newlines)
    return self._get_after_scope()

</t>
<t tx="ekr.20080516150804.1477">def _find_toplevel(self, scope):
    toplevel = scope
    if toplevel.parent is not None:
        while toplevel.parent.parent is not None:
            toplevel = toplevel.parent
    return toplevel

</t>
<t tx="ekr.20080516150804.1478">def find_indents(self):
    if self.info.variable and not self.info.make_global:
        return sourceutils.get_indents(self.info.lines,
                                       self._get_before_line())
    else:
        if self.info.global_ or self.info.make_global:
            return 0
    return self.info.scope_indents

</t>
<t tx="ekr.20080516150804.1479">def _get_before_line(self):
    ast = self.info.scope.pyobject.get_ast()
    return suites.find_visible(ast, self.matched_lines)

</t>
<t tx="ekr.20080516150804.1480">def _get_after_scope(self):
    return self.info.scope.get_end() + 1


</t>
<t tx="ekr.20080516150804.1481">class _ExceptionalConditionChecker(object):
    @others
</t>
<t tx="ekr.20080516150804.1482">
def __call__(self, info):
    self.base_conditions(info)
    if info.one_line:
        self.one_line_conditions(info)
    else:
        self.multi_line_conditions(info)

</t>
<t tx="ekr.20080516150804.1483">def base_conditions(self, info):
    if info.region[1] &gt; info.scope_region[1]:
        raise RefactoringError('Bad region selected for extract method')
    end_line = info.region_lines[1]
    end_scope = info.global_scope.get_inner_scope_for_line(end_line)
    if end_scope != info.scope and end_scope.get_end() != end_line:
        raise RefactoringError('Bad region selected for extract method')
    try:
        extracted = info.source[info.region[0]:info.region[1]]
        if info.one_line:
            extracted = '(%s)' % extracted
        if _UnmatchedBreakOrContinueFinder.has_errors(extracted):
            raise RefactoringError('A break/continue without having a '
                                   'matching for/while loop.')
    except SyntaxError:
        raise RefactoringError('Extracted piece should '
                               'contain complete statements.')

</t>
<t tx="ekr.20080516150804.1484">def one_line_conditions(self, info):
    if self._is_region_on_a_word(info):
        raise RefactoringError('Should extract complete statements.')
    if info.variable and not info.one_line:
        raise RefactoringError('Extract variable should not '
                               'span multiple lines.')

</t>
<t tx="ekr.20080516150804.1485">def multi_line_conditions(self, info):
    node = _parse_text(info.source[info.region[0]:info.region[1]])
    count = usefunction._return_count(node)
    if count &gt; 1:
        raise RefactoringError('Extracted piece can have only one '
                               'return statement.')
    if usefunction._yield_count(node):
        raise RefactoringError('Extracted piece cannot '
                               'have yield statements.')
    if count == 1 and not usefunction._returns_last(node):
        raise RefactoringError('Return should be the last statement.')
    if info.region != info.lines_region:
        raise RefactoringError('Extracted piece should '
                               'contain complete statements.')

</t>
<t tx="ekr.20080516150804.1486">def _is_region_on_a_word(self, info):
    if info.region[0] &gt; 0 and self._is_on_a_word(info, info.region[0] - 1) or \
       self._is_on_a_word(info, info.region[1] - 1):
        return True

</t>
<t tx="ekr.20080516150804.1487">def _is_on_a_word(self, info, offset):
    prev = info.source[offset]
    if not (prev.isalnum() or prev == '_') or \
       offset + 1 == len(info.source):
        return False
    next = info.source[offset + 1]
    return next.isalnum() or next == '_'


</t>
<t tx="ekr.20080516150804.1488">class _ExtractMethodParts(object):
    @others
</t>
<t tx="ekr.20080516150804.1489">
def __init__(self, info):
    self.info = info
    self.info_collector = self._create_info_collector()

</t>
<t tx="ekr.20080516150804.1490">def get_definition(self):
    if self.info.global_:
        return '\n%s\n' % self._get_function_definition()
    else:
        return '\n%s' % self._get_function_definition()

</t>
<t tx="ekr.20080516150804.1491">def get_replacement_pattern(self):
    variables = []
    variables.extend(self._find_function_arguments())
    variables.extend(self._find_function_returns())
    return similarfinder.make_pattern(self._get_call(), variables)

</t>
<t tx="ekr.20080516150804.1492">def get_body_pattern(self):
    variables = []
    variables.extend(self._find_function_arguments())
    variables.extend(self._find_function_returns())
    variables.extend(self._find_temps())
    return similarfinder.make_pattern(self._get_body(), variables)

</t>
<t tx="ekr.20080516150804.1493">def _get_body(self):
    result = sourceutils.fix_indentation(self.info.extracted, 0)
    if self.info.one_line:
        result = '(%s)' % result
    return result

</t>
<t tx="ekr.20080516150804.1494">def _find_temps(self):
    return usefunction.find_temps(self.info.pycore.project,
                                  self._get_body())

</t>
<t tx="ekr.20080516150804.1495">def get_checks(self):
    if self.info.method and not self.info.make_global:
        if _get_function_kind(self.info.scope) == 'method':
            class_name = similarfinder._pydefined_to_str(
                self.info.scope.parent.pyobject)
            return {self._get_self_name(): 'type=' + class_name}
    return {}

</t>
<t tx="ekr.20080516150804.1496">def _create_info_collector(self):
    zero = self.info.scope.get_start() - 1
    start_line = self.info.region_lines[0] - zero
    end_line = self.info.region_lines[1] - zero
    info_collector = _FunctionInformationCollector(start_line, end_line,
                                                   self.info.global_)
    body = self.info.source[self.info.scope_region[0]:
                            self.info.scope_region[1]]
    node = _parse_text(body)
    ast.walk(node, info_collector)
    return info_collector

</t>
<t tx="ekr.20080516150804.1497">def _get_function_definition(self):
    args = self._find_function_arguments()
    returns = self._find_function_returns()
    result = []
    if self.info.method and not self.info.make_global and \
       _get_function_kind(self.info.scope) != 'method':
        result.append('@staticmethod\n')
    result.append('def %s:\n' % self._get_function_signature(args))
    unindented_body = self._get_unindented_function_body(returns)
    indents = sourceutils.get_indent(self.info.pycore)
    function_body = sourceutils.indent_lines(unindented_body, indents)
    result.append(function_body)
    definition = ''.join(result)

    return definition + '\n'

</t>
<t tx="ekr.20080516150804.1498">def _get_function_signature(self, args):
    args = list(args)
    prefix = ''
    if self.info.method and not self.info.make_global and \
            _get_function_kind(self.info.scope) == 'method':
        self_name = self._get_self_name()
        if self_name in args:
            args.remove(self_name)
        args.insert(0, self_name)
    return prefix + self.info.new_name + \
           '(%s)' % self._get_comma_form(args)

</t>
<t tx="ekr.20080516150804.1499">def _get_self_name(self):
    param_names = self.info.scope.pyobject.get_param_names()
    if param_names:
        return param_names[0]

</t>
<t tx="ekr.20080516150804.1500">def _get_function_call(self, args):
    prefix = ''
    if self.info.method and not self.info.make_global:
        if _get_function_kind(self.info.scope) == 'method':
            self_name = self._get_self_name()
            if  self_name in args:
                args.remove(self_name)
            prefix = self_name + '.'
        else:
            prefix = self.info.scope.parent.pyobject.get_name() + '.'
    return prefix + '%s(%s)' % (self.info.new_name,
                                self._get_comma_form(args))

</t>
<t tx="ekr.20080516150804.1501">def _get_comma_form(self, names):
    result = ''
    if names:
        result += names[0]
        for name in names[1:]:
            result += ', ' + name
    return result

</t>
<t tx="ekr.20080516150804.1502">def _get_call(self):
    if self.info.one_line:
        args = self._find_function_arguments()
        return self._get_function_call(args)
    args = self._find_function_arguments()
    returns = self._find_function_returns()
    call_prefix = ''
    if returns:
        call_prefix = self._get_comma_form(returns) + ' = '
    if self.info.returned:
        call_prefix = 'return '
    return call_prefix + self._get_function_call(args)

</t>
<t tx="ekr.20080516150804.1503">def _find_function_arguments(self):
    # if not make_global, do not pass any global names; they are
    # all visible.
    if self.info.global_ and not self.info.make_global:
        return ()
    if not self.info.one_line:
        return list(self.info_collector.prewritten.
                    intersection(self.info_collector.read))
    start = self.info.region[0]
    if start == self.info.lines_region[0]:
        start = start + re.search('\S', self.info.extracted).start()
    function_definition = self.info.source[start:self.info.region[1]]
    read = _VariableReadsAndWritesFinder.find_reads_for_one_liners(
        function_definition)
    return list(self.info_collector.prewritten.intersection(read))

</t>
<t tx="ekr.20080516150804.1504">def _find_function_returns(self):
    if self.info.one_line or self.info.returned:
        return []
    return list(self.info_collector.written.
                intersection(self.info_collector.postread))

</t>
<t tx="ekr.20080516150804.1505">def _get_unindented_function_body(self, returns):
    if self.info.one_line:
        return 'return ' + _join_lines(self.info.extracted)
    extracted_body = self.info.extracted
    unindented_body = sourceutils.fix_indentation(extracted_body, 0)
    if returns:
        unindented_body += '\nreturn %s' % self._get_comma_form(returns)
    return unindented_body


</t>
<t tx="ekr.20080516150804.1506">class _ExtractVariableParts(object):
    @others
</t>
<t tx="ekr.20080516150804.1507">
def __init__(self, info):
    self.info = info

</t>
<t tx="ekr.20080516150804.1508">def get_definition(self):
    result = self.info.new_name + ' = ' + \
             _join_lines(self.info.extracted) + '\n'
    return result

</t>
<t tx="ekr.20080516150804.1509">def get_body_pattern(self):
    return '(%s)' % self.info.extracted.strip()

</t>
<t tx="ekr.20080516150804.1510">def get_replacement_pattern(self):
    return self.info.new_name

</t>
<t tx="ekr.20080516150804.1511">def get_checks(self):
    return {}


</t>
<t tx="ekr.20080516150804.1512">class _FunctionInformationCollector(object):
    @others
</t>
<t tx="ekr.20080516150804.1513">
def __init__(self, start, end, is_global):
    self.start = start
    self.end = end
    self.is_global = is_global
    self.prewritten = set()
    self.written = set()
    self.read = set()
    self.postread = set()
    self.postwritten = set()
    self.host_function = True

</t>
<t tx="ekr.20080516150804.1514">def _read_variable(self, name, lineno):
    if self.start &lt;= lineno &lt;= self.end:
        if name not in self.written:
            self.read.add(name)
    if self.end &lt; lineno:
        if name not in self.postwritten:
            self.postread.add(name)

</t>
<t tx="ekr.20080516150804.1515">def _written_variable(self, name, lineno):
    if self.start &lt;= lineno &lt;= self.end:
        self.written.add(name)
    if self.start &gt; lineno:
        self.prewritten.add(name)
    if self.end &lt; lineno:
        self.postwritten.add(name)

</t>
<t tx="ekr.20080516150804.1516">def _FunctionDef(self, node):
    if not self.is_global and self.host_function:
        self.host_function = False
        for name in _get_argnames(node.args):
            self._written_variable(name, node.lineno)
        for child in node.body:
            ast.walk(child, self)
    else:
        self._written_variable(node.name, node.lineno)
        visitor = _VariableReadsAndWritesFinder()
        for child in node.body:
            ast.walk(child, visitor)
        for name in visitor.read - visitor.written:
            self._read_variable(name, node.lineno)

</t>
<t tx="ekr.20080516150804.1517">def _Name(self, node):
    if isinstance(node.ctx, (ast.Store, ast.AugStore)):
        self._written_variable(node.id, node.lineno)
    if not isinstance(node.ctx, ast.Store):
        self._read_variable(node.id, node.lineno)

</t>
<t tx="ekr.20080516150804.1518">def _Assign(self, node):
    ast.walk(node.value, self)
    for child in node.targets:
        ast.walk(child, self)

</t>
<t tx="ekr.20080516150804.1519">def _ClassDef(self, node):
    self._written_variable(node.name, node.lineno)


</t>
<t tx="ekr.20080516150804.1520">def _get_argnames(arguments):
    result = [node.id for node in arguments.args
              if isinstance(node, ast.Name)]
    if arguments.vararg:
        result.append(arguments.vararg)
    if arguments.kwarg:
        result.append(arguments.kwarg)
    return result


</t>
<t tx="ekr.20080516150804.1521">class _VariableReadsAndWritesFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.1522">
def __init__(self):
    self.written = set()
    self.read = set()

</t>
<t tx="ekr.20080516150804.1523">def _Name(self, node):
    if isinstance(node.ctx, (ast.Store, ast.AugStore)):
        self.written.add(node.id)
    if not isinstance(node, ast.Store):
        self.read.add(node.id)

</t>
<t tx="ekr.20080516150804.1524">def _FunctionDef(self, node):
    self.written.add(node.name)
    visitor = _VariableReadsAndWritesFinder()
    for child in ast.get_child_nodes(node):
        ast.walk(child, visitor)
    self.read.update(visitor.read - visitor.written)

</t>
<t tx="ekr.20080516150804.1525">def _Class(self, node):
    self.written.add(node.name)

</t>
<t tx="ekr.20080516150804.1526">@staticmethod
def find_reads_and_writes(code):
    if code.strip() == '':
        return set(), set()
    if isinstance(code, unicode):
        code = code.encode('utf-8')
    node = _parse_text(code)
    visitor = _VariableReadsAndWritesFinder()
    ast.walk(node, visitor)
    return visitor.read, visitor.written

</t>
<t tx="ekr.20080516150804.1527">@staticmethod
def find_reads_for_one_liners(code):
    if code.strip() == '':
        return set(), set()
    node = _parse_text(code)
    visitor = _VariableReadsAndWritesFinder()
    ast.walk(node, visitor)
    return visitor.read


</t>
<t tx="ekr.20080516150804.1528">class _UnmatchedBreakOrContinueFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.1529">
def __init__(self):
    self.error = False
    self.loop_count = 0

</t>
<t tx="ekr.20080516150804.1530">def _For(self, node):
    self.loop_encountered(node)

</t>
<t tx="ekr.20080516150804.1531">def _While(self, node):
    self.loop_encountered(node)

</t>
<t tx="ekr.20080516150804.1532">def loop_encountered(self, node):
    self.loop_count += 1
    for child in node.body:
        ast.walk(child, self)
    self.loop_count -= 1
    if node.orelse:
        ast.walk(node.orelse, self)

</t>
<t tx="ekr.20080516150804.1533">def _Break(self, node):
    self.check_loop()

</t>
<t tx="ekr.20080516150804.1534">def _Continue(self, node):
    self.check_loop()

</t>
<t tx="ekr.20080516150804.1535">def check_loop(self):
    if self.loop_count &lt; 1:
        self.error = True

</t>
<t tx="ekr.20080516150804.1536">def _FunctionDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.1537">def _ClassDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.1538">@staticmethod
def has_errors(code):
    if code.strip() == '':
        return False
    node = _parse_text(code)
    visitor = _UnmatchedBreakOrContinueFinder()
    ast.walk(node, visitor)
    return visitor.error

</t>
<t tx="ekr.20080516150804.1539">def _get_function_kind(scope):
    return scope.pyobject.get_kind()


</t>
<t tx="ekr.20080516150804.1540">def _parse_text(body):
    body = sourceutils.fix_indentation(body, 0)
    node = ast.parse(body)
    return node

</t>
<t tx="ekr.20080516150804.1541">def _join_lines(code):
    lines = []
    for line in code.splitlines():
        if line.endswith('\\'):
            lines.append(line[:-1].strip())
        else:
            lines.append(line.strip())
    return ' '.join(lines)
</t>
<t tx="ekr.20080516150804.1542">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1543">import rope.base.exceptions
import rope.base.pyobjects
from rope.base import worder


</t>
<t tx="ekr.20080516150804.1544">class DefinitionInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1545">
def __init__(self, function_name, is_method, args_with_defaults,
             args_arg, keywords_arg):
    self.function_name = function_name
    self.is_method = is_method
    self.args_with_defaults = args_with_defaults
    self.args_arg = args_arg
    self.keywords_arg = keywords_arg

</t>
<t tx="ekr.20080516150804.1546">def to_string(self):
    return '%s(%s)' % (self.function_name, self.arguments_to_string())

</t>
<t tx="ekr.20080516150804.1547">def arguments_to_string(self, from_index=0):
    params = []
    for arg, default in self.args_with_defaults:
        if default is not None:
            params.append('%s=%s' % (arg, default))
        else:
            params.append(arg)
    if self.args_arg is not None:
        params.append('*' + self.args_arg)
    if self.keywords_arg:
        params.append('**' + self.keywords_arg)
    return ', '.join(params[from_index:])

</t>
<t tx="ekr.20080516150804.1548">@staticmethod
def _read(pyfunction, code):
    scope = pyfunction.get_scope()
    parent = scope.parent
    parameter_names = pyfunction.get_param_names()
    is_method = pyfunction.get_kind() == 'method'
    info = _FunctionParser(code, is_method)
    args, keywords = info.get_parameters()
    args_arg = None
    keywords_arg = None
    if args and args[-1].startswith('**'):
        keywords_arg = args[-1][2:]
        del args[-1]
    if args and args[-1].startswith('*'):
        args_arg = args[-1][1:]
        del args[-1]
    args_with_defaults = [(name, None) for name in args]
    args_with_defaults.extend(keywords)
    return DefinitionInfo(info.get_function_name(), is_method,
                          args_with_defaults, args_arg, keywords_arg)

</t>
<t tx="ekr.20080516150804.1549">@staticmethod
def read(pyfunction):
    pymodule = pyfunction.get_module()
    word_finder = worder.Worder(pymodule.source_code)
    lineno = pyfunction.get_ast().lineno
    start = pymodule.lines.get_line_start(lineno)
    call = word_finder.get_function_and_args_in_header(start)
    return DefinitionInfo._read(pyfunction, call)


</t>
<t tx="ekr.20080516150804.1550">class CallInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.1551">
def __init__(self, function_name, args, keywords, args_arg,
             keywords_arg, implicit_arg, constructor):
    self.function_name = function_name
    self.args = args
    self.keywords = keywords
    self.args_arg = args_arg
    self.keywords_arg = keywords_arg
    self.implicit_arg = implicit_arg
    self.constructor = constructor

</t>
<t tx="ekr.20080516150804.1552">def to_string(self):
    function = self.function_name
    if self.implicit_arg:
        function = self.args[0] + '.' + self.function_name
    params = []
    start = 0
    if self.implicit_arg or self.constructor:
        start = 1
    if self.args[start:]:
        params.extend(self.args[start:])
    if self.keywords:
        params.extend(['%s=%s' % (name, value) for name, value in self.keywords])
    if self.args_arg is not None:
        params.append('*' + self.args_arg)
    if self.keywords_arg:
        params.append('**' + self.keywords_arg)
    return '%s(%s)' % (function, ', '.join(params))

</t>
<t tx="ekr.20080516150804.1553">@staticmethod
def read(primary, pyname, definition_info, code):
    is_method_call = CallInfo._is_method_call(primary, pyname)
    is_constructor = CallInfo._is_class(pyname)
    is_classmethod = CallInfo._is_classmethod(pyname)
    info = _FunctionParser(code, is_method_call or is_classmethod)
    args, keywords = info.get_parameters()
    args_arg = None
    keywords_arg = None
    if args and args[-1].startswith('**'):
        keywords_arg = args[-1][2:]
        del args[-1]
    if args and args[-1].startswith('*'):
        args_arg = args[-1][1:]
        del args[-1]
    if is_constructor:
        args.insert(0, definition_info.args_with_defaults[0][0])
    return CallInfo(info.get_function_name(), args, keywords, args_arg,
                    keywords_arg, is_method_call or is_classmethod,
                    is_constructor)

</t>
<t tx="ekr.20080516150804.1554">@staticmethod
def _is_method_call(primary, pyname):
    return primary is not None and \
           isinstance(primary.get_object().get_type(),
                      rope.base.pyobjects.PyClass) and \
                      CallInfo._is_method(pyname)

</t>
<t tx="ekr.20080516150804.1555">@staticmethod
def _is_class(pyname):
    return pyname is not None and \
           isinstance(pyname.get_object(),
                      rope.base.pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1556">@staticmethod
def _is_method(pyname):
    if pyname is not None and \
       isinstance(pyname.get_object(), rope.base.pyobjects.PyFunction):
        return pyname.get_object().get_kind() == 'method'
    return False

</t>
<t tx="ekr.20080516150804.1557">@staticmethod
def _is_classmethod(pyname):
    if pyname is not None and \
       isinstance(pyname.get_object(), rope.base.pyobjects.PyFunction):
        return pyname.get_object().get_kind() == 'classmethod'
    return False


</t>
<t tx="ekr.20080516150804.1558">class ArgumentMapping(object):
    @others
</t>
<t tx="ekr.20080516150804.1559">
def __init__(self, definition_info, call_info):
    self.call_info = call_info
    self.param_dict = {}
    self.keyword_args = []
    self.args_arg = []
    for index, value in enumerate(call_info.args):
        if index &lt; len(definition_info.args_with_defaults):
            name = definition_info.args_with_defaults[index][0]
            self.param_dict[name] = value
        else:
            self.args_arg.append(value)
    for name, value in call_info.keywords:
        index = -1
        for pair in definition_info.args_with_defaults:
            if pair[0] == name:
                self.param_dict[name] = value
                break
        else:
            self.keyword_args.append((name, value))

</t>
<t tx="ekr.20080516150804.1560">def to_call_info(self, definition_info):
    args = []
    keywords = []
    for index in range(len(definition_info.args_with_defaults)):
        name = definition_info.args_with_defaults[index][0]
        if name in self.param_dict:
            args.append(self.param_dict[name])
        else:
            for i in range(index, len(definition_info.args_with_defaults)):
                name = definition_info.args_with_defaults[i][0]
                if name in self.param_dict:
                    keywords.append((name, self.param_dict[name]))
            break
    args.extend(self.args_arg)
    keywords.extend(self.keyword_args)
    return CallInfo(self.call_info.function_name, args, keywords,
                    self.call_info.args_arg, self.call_info.keywords_arg,
                    self.call_info.implicit_arg, self.call_info.constructor)


</t>
<t tx="ekr.20080516150804.1561">class _FunctionParser(object):
    @others
</t>
<t tx="ekr.20080516150804.1562">
def __init__(self, call, implicit_arg):
    self.call = call
    self.implicit_arg = implicit_arg
    self.word_finder = worder.Worder(self.call)
    self.last_parens = self.call.rindex(')')
    self.first_parens = self.word_finder._find_parens_start(self.last_parens)

</t>
<t tx="ekr.20080516150804.1563">def get_parameters(self):
    args, keywords = self.word_finder.get_parameters(self.first_parens,
                                                     self.last_parens)
    if self.is_called_as_a_method():
        instance = self.call[:self.call.rindex('.', 0, self.first_parens)]
        args.insert(0, instance.strip())
    return args, keywords

</t>
<t tx="ekr.20080516150804.1564">def get_instance(self):
    if self.is_called_as_a_method():
        return self.word_finder.get_primary_at(
            self.call.rindex('.', 0, self.first_parens) - 1)

</t>
<t tx="ekr.20080516150804.1565">def get_function_name(self):
    if self.is_called_as_a_method():
        return self.word_finder.get_word_at(self.first_parens - 1)
    else:
        return self.word_finder.get_primary_at(self.first_parens - 1)

</t>
<t tx="ekr.20080516150804.1566">def is_called_as_a_method(self):
    return self.implicit_arg and '.' in self.call[:self.first_parens]
</t>
<t tx="ekr.20080516150804.1567">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1568">import re

import rope.base.exceptions
import rope.refactor.functionutils
from rope.base import pynames, pyobjects, codeanalyze, taskhandle, evaluate, worder
from rope.base.change import ChangeSet, ChangeContents
from rope.refactor import (occurrences, rename, sourceutils,
                           importutils, move, change_signature)


</t>
<t tx="ekr.20080516150804.1569">def create_inline(project, resource, offset):
    """Create a refactoring object for inlining

    Based on `resource` and `offset` it returns an instance of
    `InlineMethod`, `InlineVariable` or `InlineParameter`.

    """
    pycore = project.pycore
    this_pymodule = pycore.resource_to_pyobject(resource)
    pyname = evaluate.get_pyname_at(this_pymodule, offset)
    message = 'Inline refactoring should be performed on ' \
              'a method, local variable or parameter.'
    if pyname is None:
        raise rope.base.exceptions.RefactoringError(message)
    if isinstance(pyname, pynames.AssignedName):
        return InlineVariable(project, resource, offset)
    if isinstance(pyname, pynames.ParameterName):
        return InlineParameter(project, resource, offset)
    if isinstance(pyname.get_object(), pyobjects.PyFunction):
        return InlineMethod(project, resource, offset)
    else:
        raise rope.base.exceptions.RefactoringError(message)


</t>
<t tx="ekr.20080516150804.1570">class _Inliner(object):
    @others
</t>
<t tx="ekr.20080516150804.1571">
def __init__(self, project, resource, offset):
    self.project = project
    self.pycore = project.pycore
    this_pymodule = self.pycore.resource_to_pyobject(resource)
    self.pyname = evaluate.get_pyname_at(this_pymodule, offset)
    range_finder = worder.Worder(resource.read())
    self.region = range_finder.get_primary_range(offset)
    self.name = range_finder.get_word_at(offset)
    self.offset = offset

</t>
<t tx="ekr.20080516150804.1572">def get_changes(self, *args, **kwds):
    pass

</t>
<t tx="ekr.20080516150804.1573">def get_kind(self):
    """Return either 'variable', 'method' or 'parameter'"""


</t>
<t tx="ekr.20080516150804.1574">class InlineMethod(_Inliner):
    @others
</t>
<t tx="ekr.20080516150804.1575">
def __init__(self, *args, **kwds):
    super(InlineMethod, self).__init__(*args, **kwds)
    self.pyfunction = self.pyname.get_object()
    self.pymodule = self.pyfunction.get_module()
    self.resource = self.pyfunction.get_module().get_resource()
    self.occurrence_finder = occurrences.create_finder(
        self.pycore, self.name, self.pyname)
    self.normal_generator = _DefinitionGenerator(self.project,
                                                 self.pyfunction)
    self._init_imports()

</t>
<t tx="ekr.20080516150804.1576">def _init_imports(self):
    self.import_tools = importutils.ImportTools(self.pycore)
    body = sourceutils.get_body(self.pyfunction)
    body, imports = move.moving_code_with_imports(
        self.pycore, self.resource, body)
    self.imports = imports
    self.others_generator = _DefinitionGenerator(
        self.project, self.pyfunction, body=body)

</t>
<t tx="ekr.20080516150804.1577">def _get_scope_range(self):
    scope = self.pyfunction.get_scope()
    lines = self.pymodule.lines
    logicals = self.pymodule.logical_lines
    start_line = scope.get_start()
    if self.pyfunction.decorators:
        decorators = self.pyfunction.decorators
        if hasattr(decorators[0], 'lineno'):
            start_line = decorators[0].lineno
    start_offset = lines.get_line_start(start_line)
    end_offset = min(lines.get_line_end(scope.end) + 1,
                     len(self.pymodule.source_code))
    return (start_offset, end_offset)

</t>
<t tx="ekr.20080516150804.1578">def get_changes(self, remove=True, only_current=False, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get the changes this refactoring makes

    If `remove` is `False` the definition will not be removed.  If
    `only_current` is `True`, the the current occurrence will be
    inlined, only.
    """
    changes = ChangeSet('Inline method &lt;%s&gt;' % self.name)
    if resources is None:
        resources = self.pycore.get_python_files()
    if only_current:
        resources = [self.resource]
    job_set = task_handle.create_jobset('Collecting Changes',
                                        len(resources))
    for file in resources:
        job_set.started_job(file.path)
        if file == self.resource:
            changes.add_change(self._defining_file_changes(
                    changes, remove=remove, only_current=only_current))
        else:
            handle = _InlineFunctionCallsForModuleHandle(
                self.pycore, file, self.others_generator)
            result = move.ModuleSkipRenamer(
                self.occurrence_finder, file, handle).get_changed_module()
            if result is not None:
                result = self._add_imports(result, file)
                changes.add_change(ChangeContents(file, result))
        job_set.finished_job()
    return changes

</t>
<t tx="ekr.20080516150804.1579">def _get_removed_range(self):
    scope = self.pyfunction.get_scope()
    lines = self.pymodule.lines
    logical = self.pymodule.logical_lines
    start_line = scope.get_start()
    start, end = self._get_scope_range()
    end_line = scope.get_end()
    for i in range(end_line + 1, lines.length()):
        if lines.get_line(i).strip() == '':
            end_line = i
        else:
            break
    end = min(lines.get_line_end(end_line) + 1,
              len(self.pymodule.source_code))
    return (start, end)

</t>
<t tx="ekr.20080516150804.1580">def _defining_file_changes(self, changes, remove, only_current):
    start_offset, end_offset = self._get_removed_range()
    aim = None if not only_current else self.offset
    handle = _InlineFunctionCallsForModuleHandle(
        self.pycore, self.resource,
        self.normal_generator, aim_offset=aim)
    replacement = None
    if remove:
        replacement = self._get_method_replacement()
    result = move.ModuleSkipRenamer(
        self.occurrence_finder, self.resource, handle, start_offset,
        end_offset, replacement).get_changed_module()
    return ChangeContents(self.resource, result)

</t>
<t tx="ekr.20080516150804.1581">def _get_method_replacement(self):
    if self._is_the_last_method_of_a_class():
        indents = sourceutils.get_indents(
            self.pymodule.lines, self.pyfunction.get_scope().get_start())
        return ' ' * indents + 'pass\n'
    return ''

</t>
<t tx="ekr.20080516150804.1582">def _is_the_last_method_of_a_class(self):
    pyclass = self.pyfunction.parent
    if not isinstance(pyclass, pyobjects.PyClass):
        return False
    class_start, class_end = sourceutils.get_body_region(pyclass)
    source = self.pymodule.source_code
    lines = self.pymodule.lines
    func_start, func_end = self._get_scope_range()
    if source[class_start:func_start].strip() == '' and \
       source[func_end:class_end].strip() == '':
        return True
    return False

</t>
<t tx="ekr.20080516150804.1583">def _add_imports(self, source, file):
    if not self.imports:
        return source
    pymodule = self.pycore.get_string_module(source, file)
    module_import = importutils.get_module_imports(self.pycore, pymodule)
    for import_info in self.imports:
        module_import.add_import(import_info)
    source = module_import.get_changed_source()
    pymodule = self.pycore.get_string_module(source, file)
    source = self.import_tools.organize_imports(
        pymodule, unused=False, sort=False)
    return source

</t>
<t tx="ekr.20080516150804.1584">def get_kind(self):
    return 'method'


</t>
<t tx="ekr.20080516150804.1585">class InlineVariable(_Inliner):
    @others
</t>
<t tx="ekr.20080516150804.1586">
def __init__(self, *args, **kwds):
    super(InlineVariable, self).__init__(*args, **kwds)
    self.pymodule = self.pyname.get_definition_location()[0]
    self.resource = self.pymodule.get_resource()
    self._check_exceptional_conditions()

</t>
<t tx="ekr.20080516150804.1587">def _check_exceptional_conditions(self):
    if len(self.pyname.assignments) != 1:
        raise rope.base.exceptions.RefactoringError(
            'Local variable should be assigned once for inlining.')

</t>
<t tx="ekr.20080516150804.1588">def get_changes(self, remove=True, only_current=False, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    source = self._get_changed_module(remove, only_current)
    changes = ChangeSet('Inline variable &lt;%s&gt;' % self.name)
    if resources is None or self.resource in resources:
        changes.add_change(ChangeContents(self.resource, source))
    return changes

</t>
<t tx="ekr.20080516150804.1589">def _get_changed_module(self, remove, only_current):
    region = None
    if only_current:
        region = self.region
    return _inline_variable(self.pycore, self.pymodule, self.pyname,
                            self.name, remove=remove, region=region)

</t>
<t tx="ekr.20080516150804.1590">def get_kind(self):
    return 'variable'


</t>
<t tx="ekr.20080516150804.1591">class InlineParameter(_Inliner):
    @others
</t>
<t tx="ekr.20080516150804.1592">
def __init__(self, *args, **kwds):
    super(InlineParameter, self).__init__(*args, **kwds)
    resource, offset = self._function_location()
    index = self.pyname.index
    self.changers = [change_signature.ArgumentDefaultInliner(index)]
    self.signature = change_signature.ChangeSignature(self.project,
                                                      resource, offset)

</t>
<t tx="ekr.20080516150804.1593">def _function_location(self):
    pymodule, lineno = self.pyname.get_definition_location()
    resource = pymodule.get_resource()
    start = pymodule.lines.get_line_start(lineno)
    word_finder = worder.Worder(pymodule.source_code)
    offset = word_finder.find_function_offset(start)
    return resource, offset

</t>
<t tx="ekr.20080516150804.1594">def get_changes(self, **kwds):
    return self.signature.get_changes(self.changers, **kwds)

</t>
<t tx="ekr.20080516150804.1595">def get_kind(self):
    return 'parameter'


</t>
<t tx="ekr.20080516150804.1596">def _join_lines(lines):
    definition_lines = []
    for unchanged_line in lines:
        line = unchanged_line.strip()
        if line.endswith('\\'):
            line = line[:-1].strip()
        definition_lines.append(line)
    joined = ' '.join(definition_lines)
    return joined


</t>
<t tx="ekr.20080516150804.1597">class _DefinitionGenerator(object):
    @others
</t>
<t tx="ekr.20080516150804.1598">
def __init__(self, project, pyfunction, body=None):
    self.pycore = project.pycore
    self.pyfunction = pyfunction
    self.pymodule = pyfunction.get_module()
    self.resource = self.pymodule.get_resource()
    self.definition_info = self._get_definition_info()
    self.definition_params = self._get_definition_params()
    self._calculated_definitions = {}
    if body is not None:
        self.body = body
    else:
        self.body = sourceutils.get_body(self.pyfunction)

</t>
<t tx="ekr.20080516150804.1599">def _get_definition_info(self):
    return rope.refactor.functionutils.DefinitionInfo.read(self.pyfunction)

</t>
<t tx="ekr.20080516150804.1600">def _get_definition_params(self):
    definition_info = self.definition_info
    paramdict = dict([pair for pair in definition_info.args_with_defaults])
    if definition_info.args_arg is not None or \
       definition_info.keywords_arg is not None:
        raise rope.base.exceptions.RefactoringError(
            'Cannot inline functions with list and keyword arguements.')
    if self.pyfunction.get_kind() == 'classmethod':
        paramdict[definition_info.args_with_defaults[0][0]] = \
            self.pyfunction.parent.get_name()
    return paramdict

</t>
<t tx="ekr.20080516150804.1601">def get_function_name(self):
    return self.pyfunction.get_name()

</t>
<t tx="ekr.20080516150804.1602">def get_definition(self, primary, pyname, call, returns=False):
    # caching already calculated definitions
    key = (call, returns)
    if key not in self._calculated_definitions:
        self._calculated_definitions[key] = self._calculate_definition(
            primary, pyname, call, returns)
    return self._calculated_definitions[key]

</t>
<t tx="ekr.20080516150804.1603">def _calculate_definition(self, primary, pyname, call, returns):
    call_info = rope.refactor.functionutils.CallInfo.read(
        primary, pyname, self.definition_info, call)
    paramdict = self.definition_params
    mapping = rope.refactor.functionutils.ArgumentMapping(
        self.definition_info, call_info)
    for param_name, value in mapping.param_dict.items():
        paramdict[param_name] = value
    header = ''
    to_be_inlined = []
    for name, value in paramdict.items():
        if name != value and value is not None:
            header += name + ' = ' + value + '\n'
            to_be_inlined.append(name)
    source = header + self.body
    for name in to_be_inlined:
        pymodule = self.pycore.get_string_module(source, self.resource)
        pyname = pymodule[name]
        source = _inline_variable(self.pycore, pymodule, pyname, name)
    return self._replace_returns_with(source, returns)

</t>
<t tx="ekr.20080516150804.1604">def _replace_returns_with(self, source, returns):
    result = []
    returned = None
    last_changed = 0
    for match in _DefinitionGenerator._get_return_pattern().finditer(source):
        for key, value in match.groupdict().items():
            if value and key == 'return':
                result.append(source[last_changed:match.start('return')])
                if returns:
                    self._check_nothing_after_return(source,
                                                     match.end('return'))
                    returned = _join_lines(
                        source[match.end('return'): len(source)].splitlines())
                    last_changed = len(source)
                else:
                    current = match.end('return')
                    while current &lt; len(source) and source[current] in ' \t':
                        current += 1
                    last_changed = current
                    if current == len(source) or source[current] == '\n':
                        result.append('pass')
    result.append(source[last_changed:])
    return ''.join(result), returned

</t>
<t tx="ekr.20080516150804.1605">def _check_nothing_after_return(self, source, offset):
    lines = codeanalyze.SourceLinesAdapter(source)
    lineno = lines.get_line_number(offset)
    logical_lines = codeanalyze.LogicalLineFinder(lines)
    lineno = logical_lines.logical_line_in(lineno)[1]
    if source[lines.get_line_end(lineno):len(source)].strip() != '':
        raise rope.base.exceptions.RefactoringError(
            'Cannot inline functions with statements after return statement.')

</t>
<t tx="ekr.20080516150804.1606">@classmethod
def _get_return_pattern(cls):
    if not hasattr(cls, '_return_pattern'):
        def named_pattern(name, list_):
            return "(?P&lt;%s&gt;" % name + "|".join(list_) + ")"
        comment_pattern = named_pattern('comment', [r'#[^\n]*'])
        string_pattern = named_pattern('string',
                                       [codeanalyze.get_string_pattern()])
        return_pattern = r'\b(?P&lt;return&gt;return)\b'
        cls._return_pattern = re.compile(comment_pattern + "|" +
                                         string_pattern + "|" +
                                         return_pattern)
    return cls._return_pattern


</t>
<t tx="ekr.20080516150804.1607">class _InlineFunctionCallsForModuleHandle(object):
    @others
    source = property(_get_source)
    lines = property(_get_lines)
    pymodule = property(_get_pymodule)


</t>
<t tx="ekr.20080516150804.1608">
def __init__(self, pycore, resource,
             definition_generator, aim_offset=None):
    """Inlines occurrences

    If `aim` is not `None` only the occurrences that intersect
    `aim` offset will be inlined.

    """
    self.pycore = pycore
    self.generator = definition_generator
    self.resource = resource
    self.aim = aim_offset
    self._pymodule = None
    self._lines = None
    self._source = None

</t>
<t tx="ekr.20080516150804.1609">def occurred_inside_skip(self, change_collector, occurrence):
    if not occurrence.is_defined():
        raise rope.base.exceptions.RefactoringError(
            'Cannot inline functions that reference themselves')

</t>
<t tx="ekr.20080516150804.1610">def occurred_outside_skip(self, change_collector, occurrence):
    start, end = occurrence.get_primary_range()
    if not occurrence.is_called():
        raise rope.base.exceptions.RefactoringError(
            'Reference to inlining function other than function call'
            ' in &lt;file: %s, offset: %d&gt;' % (self.resource.path, start))
    if self.aim is not None and (self.aim &lt; start or self.aim &gt; end):
        return
    end_parens = self._find_end_parens(self.source, end - 1)
    lineno = self.lines.get_line_number(start)
    start_line, end_line = self.pymodule.logical_lines.\
                           logical_line_in(lineno)
    line_start = self.lines.get_line_start(start_line)
    line_end = self.lines.get_line_end(end_line)
    returns = self.source[line_start:start].strip() != '' or \
              self.source[end_parens:line_end].strip() != ''
    indents = sourceutils.get_indents(self.lines, start_line)
    primary, pyname = occurrence.get_primary_and_pyname()
    definition, returned = self.generator.get_definition(
        primary, pyname, self.source[start:end_parens], returns=returns)
    end = min(line_end + 1, len(self.source))
    change_collector.add_change(
        line_start, end, sourceutils.fix_indentation(definition, indents))
    if returns:
        name = returned
        if name is None:
            name = 'None'
        change_collector.add_change(
            line_end, end, self.source[line_start:start] + name +
            self.source[end_parens:end])

</t>
<t tx="ekr.20080516150804.1611">def _find_end_parens(self, source, offset):
    finder = worder.Worder(source)
    return finder.get_word_parens_range(offset)[1]

</t>
<t tx="ekr.20080516150804.1612">def _get_pymodule(self):
    if self._pymodule is None:
        self._pymodule = self.pycore.resource_to_pyobject(self.resource)
    return self._pymodule

</t>
<t tx="ekr.20080516150804.1613">def _get_source(self):
    if self._source is None:
        if self.resource is not None:
            self._source = self.resource.read()
        else:
            self._source = self.pymodule.source_code
    return self._source

</t>
<t tx="ekr.20080516150804.1614">def _get_lines(self):
    if self._lines is None:
        self._lines = self.pymodule.lines
    return self._lines

</t>
<t tx="ekr.20080516150804.1615">def _inline_variable(pycore, pymodule, pyname, name,
                     remove=True, region=None):
    assignment = pyname.assignments[0]
    definition_line = assignment.ast_node.lineno
    lines = pymodule.lines
    logicals = pymodule.logical_lines
    start, end = logicals.logical_line_in(definition_line)
    definition_with_assignment = _join_lines(
        [lines.get_line(n) for n in range(start, end + 1)])
    if assignment.levels:
        raise rope.base.exceptions.RefactoringError(
            'Cannot inline tuple assignments.')
    definition = definition_with_assignment[definition_with_assignment.\
                                            index('=') + 1:].strip()

    occurrence_finder = occurrences.create_finder(pycore, name, pyname)
    changed_source = rename.rename_in_module(
        occurrence_finder, definition, pymodule=pymodule,
        replace_primary=True, writes=False, region=region)
    if changed_source is None:
        changed_source = pymodule.source_code
    if remove:
        lines = codeanalyze.SourceLinesAdapter(changed_source)
        source = changed_source[:lines.get_line_start(start)] + \
                 changed_source[lines.get_line_end(end) + 1:]
    else:
        source = changed_source
    return source
</t>
<t tx="ekr.20080516150804.1616">@language python
@tabwidth -4
@others
IntroduceFactoryRefactoring = IntroduceFactory
</t>
<t tx="ekr.20080516150804.1617">import rope.base.exceptions
import rope.base.pyobjects
from rope.base import taskhandle, evaluate
from rope.base.change import (ChangeSet, ChangeContents)
from rope.refactor import rename, occurrences, sourceutils, importutils


</t>
<t tx="ekr.20080516150804.1618">class IntroduceFactory(object):
    @others
</t>
<t tx="ekr.20080516150804.1619">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    self.offset = offset

    this_pymodule = self.pycore.resource_to_pyobject(resource)
    self.old_pyname = evaluate.get_pyname_at(this_pymodule, offset)
    if self.old_pyname is None or not isinstance(self.old_pyname.get_object(),
                                                 rope.base.pyobjects.PyClass):
        raise rope.base.exceptions.RefactoringError(
            'Introduce factory should be performed on a class.')
    self.old_name = self.old_pyname.get_object().get_name()
    self.pymodule = self.old_pyname.get_object().get_module()
    self.resource = self.pymodule.get_resource()

</t>
<t tx="ekr.20080516150804.1620">def get_changes(self, factory_name, global_factory=False, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get the changes this refactoring makes

    `factory_name` indicates the name of the factory function to
    be added.  If `global_factory` is `True` the factory will be
    global otherwise a static method is added to the class.

    `resources` can be a list of `rope.base.resource.File`\s that
    this refactoring should be applied on; if `None` all python
    files in the project are searched.

    """
    if resources is None:
        resources = self.pycore.get_python_files()
    changes = ChangeSet('Introduce factory method &lt;%s&gt;' % factory_name)
    job_set = task_handle.create_jobset('Collecting Changes',
                                        len(resources))
    self._change_module(resources, changes, factory_name,
                        global_factory, job_set)
    return changes

</t>
<t tx="ekr.20080516150804.1621">def get_name(self):
    """Return the name of the class"""
    return self.old_name

</t>
<t tx="ekr.20080516150804.1622">def _change_module(self, resources, changes,
                   factory_name, global_, job_set):
    if global_:
        replacement = '__rope_factory_%s_' % factory_name
    else:
        replacement = self._new_function_name(factory_name, global_)

    for file_ in resources:
        job_set.started_job(file_.path)
        if file_ == self.resource:
            self._change_resource(changes, factory_name, global_)
            job_set.finished_job()
            continue
        changed_code = self._rename_occurrences(file_, replacement,
                                                global_)
        if changed_code is not None:
            if global_:
                new_pymodule = self.pycore.get_string_module(changed_code,
                                                             self.resource)
                modname = importutils.get_module_name(self.pycore,
                                                      self.resource)
                changed_code, imported = importutils.add_import(
                    self.pycore, new_pymodule, modname, factory_name)
                changed_code = changed_code.replace(replacement, imported)
            changes.add_change(ChangeContents(file_, changed_code))
        job_set.finished_job()

</t>
<t tx="ekr.20080516150804.1623">def _change_resource(self, changes, factory_name, global_):
    class_scope = self.old_pyname.get_object().get_scope()
    source_code = self._rename_occurrences(
        self.resource, self._new_function_name(factory_name,
                                               global_), global_)
    if source_code is None:
        source_code = self.pymodule.source_code
    else:
        self.pymodule = self.pycore.get_string_module(
            source_code, resource=self.resource)
    lines = self.pymodule.lines
    start = self._get_insertion_offset(class_scope, lines)
    result = source_code[:start]
    result += self._get_factory_method(lines, class_scope,
                                       factory_name, global_)
    result += source_code[start:]
    changes.add_change(ChangeContents(self.resource, result))

</t>
<t tx="ekr.20080516150804.1624">def _get_insertion_offset(self, class_scope, lines):
    start_line = class_scope.get_end()
    if class_scope.get_scopes():
        start_line = class_scope.get_scopes()[-1].get_end()
    start = lines.get_line_end(start_line) + 1
    return start

</t>
<t tx="ekr.20080516150804.1625">def _get_factory_method(self, lines, class_scope,
                        factory_name, global_):
    unit_indents = ' ' * sourceutils.get_indent(self.pycore)
    if global_:
        if self._get_scope_indents(lines, class_scope) &gt; 0:
            raise rope.base.exceptions.RefactoringError(
                'Cannot make global factory method for nested classes.')
        return ('\ndef %s(*args, **kwds):\n%sreturn %s(*args, **kwds)\n' %
                (factory_name, unit_indents, self.old_name))
    unindented_factory = \
        ('@staticmethod\ndef %s(*args, **kwds):\n' % factory_name +
         '%sreturn %s(*args, **kwds)\n' % (unit_indents, self.old_name))
    indents = self._get_scope_indents(lines, class_scope) + \
              sourceutils.get_indent(self.pycore)
    return '\n' + sourceutils.indent_lines(unindented_factory, indents)

</t>
<t tx="ekr.20080516150804.1626">def _get_scope_indents(self, lines, scope):
    return sourceutils.get_indents(lines, scope.get_start())

</t>
<t tx="ekr.20080516150804.1627">def _new_function_name(self, factory_name, global_):
    if global_:
        return factory_name
    else:
        return self.old_name + '.' + factory_name

</t>
<t tx="ekr.20080516150804.1628">def _rename_occurrences(self, file_, changed_name, global_factory):
    finder = occurrences.create_finder(self.pycore, self.old_name,
                                       self.old_pyname, only_calls=True)
    result = rename.rename_in_module(finder, changed_name, resource=file_,
                                     replace_primary=global_factory)
    return result

</t>
<t tx="ekr.20080516150804.1629">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1630">import rope.base.change
from rope.base import exceptions, evaluate, worder, codeanalyze
from rope.refactor import functionutils, sourceutils, occurrences


</t>
<t tx="ekr.20080516150804.1631">class IntroduceParameter(object):
    """Introduce parameter refactoring

    This refactoring adds a new parameter to a function and replaces
    references to an expression in it with the new parameter.

    The parameter finding part is different from finding similar
    pieces in extract refactorings.  In this refactoring parameters
    are found based on the object they reference to.  For instance
    in::

      class A(object):
          var = None

      class B(object):
          a = A()

      b = B()
      a = b.a

      def f(a):
          x = b.a.var + a.var

    using this refactoring on ``a.var`` with ``p`` as the new
    parameter name, will result in::

      def f(p=a.var):
          x = p + p

    """
    @others
</t>
<t tx="ekr.20080516150804.1632">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    self.resource = resource
    self.offset = offset
    self.pymodule = self.pycore.resource_to_pyobject(self.resource)
    scope = self.pymodule.get_scope().get_inner_scope_for_offset(offset)
    if scope.get_kind() != 'Function':
        raise exceptions.RefactoringError(
            'Introduce parameter should be performed inside functions')
    self.pyfunction = scope.pyobject
    self.name, self.pyname = self._get_name_and_pyname()
    if self.pyname is None:
        raise exceptions.RefactoringError(
            'Cannot find the definition of &lt;%s&gt;' % self.name)

</t>
<t tx="ekr.20080516150804.1633">def _get_primary(self):
    word_finder = worder.Worder(self.resource.read())
    return word_finder.get_primary_at(self.offset)

</t>
<t tx="ekr.20080516150804.1634">def _get_name_and_pyname(self):
    return (worder.get_name_at(self.resource, self.offset),
            evaluate.get_pyname_at(self.pymodule, self.offset))

</t>
<t tx="ekr.20080516150804.1635">def get_changes(self, new_parameter):
    definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
    definition_info.args_with_defaults.append((new_parameter,
                                               self._get_primary()))
    collector = codeanalyze.ChangeCollector(self.resource.read())
    header_start, header_end = self._get_header_offsets()
    body_start, body_end = sourceutils.get_body_region(self.pyfunction)
    collector.add_change(header_start, header_end,
                         definition_info.to_string())
    self._change_function_occurances(collector, body_start,
                                     body_end, new_parameter)
    changes = rope.base.change.ChangeSet('Introduce parameter &lt;%s&gt;' %
                                         new_parameter)
    change = rope.base.change.ChangeContents(self.resource,
                                             collector.get_changed())
    changes.add_change(change)
    return changes

</t>
<t tx="ekr.20080516150804.1636">def _get_header_offsets(self):
    lines = self.pymodule.lines
    start_line = self.pyfunction.get_scope().get_start()
    end_line = self.pymodule.logical_lines.\
               logical_line_in(start_line)[1]
    start = lines.get_line_start(start_line)
    end = lines.get_line_end(end_line)
    start = self.pymodule.source_code.find('def', start) + 4
    end = self.pymodule.source_code.rfind(':', start, end)
    return start, end

</t>
<t tx="ekr.20080516150804.1637">def _change_function_occurances(self, collector, function_start,
                                function_end, new_name):
    finder = occurrences.create_finder(self.pycore, self.name, self.pyname)
    for occurrence in finder.find_occurrences(resource=self.resource):
        start, end = occurrence.get_primary_range()
        if function_start &lt;= start &lt; function_end:
            collector.add_change(start, end, new_name)
</t>
<t tx="ekr.20080516150804.1638">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1639">from rope.base import pynames, evaluate, exceptions, worder
from rope.refactor.rename import Rename


</t>
<t tx="ekr.20080516150804.1640">class LocalToField(object):
    @others
</t>
<t tx="ekr.20080516150804.1641">
def __init__(self, project, resource, offset):
    self.project = project
    self.pycore = project.pycore
    self.resource = resource
    self.offset = offset

</t>
<t tx="ekr.20080516150804.1642">def get_changes(self):
    name = worder.get_name_at(self.resource, self.offset)
    this_pymodule = self.pycore.resource_to_pyobject(self.resource)
    pyname = evaluate.get_pyname_at(this_pymodule, self.offset)
    if not self._is_a_method_local(pyname):
        raise exceptions.RefactoringError(
            'Convert local variable to field should be performed on \n'
            'a local variable of a method.')

    pymodule, lineno = pyname.get_definition_location()
    function_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
    # Not checking redefinition
    #self._check_redefinition(name, function_scope)

    new_name = self._get_field_name(function_scope.pyobject, name)
    changes = Rename(self.project, self.resource, self.offset).\
              get_changes(new_name, resources=[self.resource])
    return changes

</t>
<t tx="ekr.20080516150804.1643">def _check_redefinition(self, name, function_scope):
    class_scope = function_scope.parent
    if name in class_scope.pyobject:
        raise exceptions.RefactoringError(
            'The field %s already exists' % name)

</t>
<t tx="ekr.20080516150804.1644">def _get_field_name(self, pyfunction, name):
    self_name = pyfunction.get_param_names()[0]
    new_name = self_name + '.' + name
    return new_name

</t>
<t tx="ekr.20080516150804.1645">def _is_a_method_local(self, pyname):
    pymodule, lineno = pyname.get_definition_location()
    holding_scope = pymodule.get_scope().get_inner_scope_for_line(lineno)
    parent = holding_scope.parent
    return isinstance(pyname, pynames.AssignedName) and \
           pyname in holding_scope.get_names().values() and \
           holding_scope.get_kind() == 'Function' and \
           parent is not None and parent.get_kind() == 'Class'
</t>
<t tx="ekr.20080516150804.1646">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1647">import warnings

from rope.base import pyobjects, exceptions, change, evaluate, codeanalyze
from rope.refactor import sourceutils, occurrences, rename


</t>
<t tx="ekr.20080516150804.1648">class MethodObject(object):
    @others
</t>
<t tx="ekr.20080516150804.1649">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    this_pymodule = self.pycore.resource_to_pyobject(resource)
    pyname = evaluate.get_pyname_at(this_pymodule, offset)
    if pyname is None or not isinstance(pyname.get_object(),
                                        pyobjects.PyFunction):
        raise exceptions.RefactoringError(
            'Replace method with method object refactoring should be '
            'performed on a function.')
    self.pyfunction = pyname.get_object()
    self.pymodule = self.pyfunction.get_module()
    self.resource = self.pymodule.get_resource()

</t>
<t tx="ekr.20080516150804.1650">def get_new_class(self, name):
    body = sourceutils.fix_indentation(
        self._get_body(), sourceutils.get_indent(self.pycore) * 2)
    return 'class %s(object):\n\n%s%sdef __call__(self):\n%s' % \
           (name, self._get_init(),
            ' ' * sourceutils.get_indent(self.pycore), body)

</t>
<t tx="ekr.20080516150804.1651">def get_changes(self, classname=None, new_class_name=None):
    if new_class_name is not None:
        warnings.warn(
            'new_class_name parameter is deprecated; use classname',
            DeprecationWarning, stacklevel=2)
        classname = new_class_name
    collector = codeanalyze.ChangeCollector(self.pymodule.source_code)
    start, end = sourceutils.get_body_region(self.pyfunction)
    indents = sourceutils.get_indents(
        self.pymodule.lines, self.pyfunction.get_scope().get_start()) + \
        sourceutils.get_indent(self.pycore)
    new_contents = ' ' * indents + 'return %s(%s)()\n' % \
                   (classname, ', '.join(self._get_parameter_names()))
    collector.add_change(start, end, new_contents)
    insertion = self._get_class_insertion_point()
    collector.add_change(insertion, insertion,
                         '\n\n' + self.get_new_class(classname))
    changes = change.ChangeSet('Replace method with method object refactoring')
    changes.add_change(change.ChangeContents(self.resource,
                                             collector.get_changed()))
    return changes

</t>
<t tx="ekr.20080516150804.1652">def _get_class_insertion_point(self):
    current = self.pyfunction
    while current.parent != self.pymodule:
        current = current.parent
    end = self.pymodule.lines.get_line_end(current.get_scope().get_end())
    return min(end + 1, len(self.pymodule.source_code))

</t>
<t tx="ekr.20080516150804.1653">def _get_body(self):
    body = sourceutils.get_body(self.pyfunction)
    for param in self._get_parameter_names():
        body = param + ' = None\n' + body
        pymod = self.pycore.get_string_module(body, self.resource)
        pyname = pymod[param]
        finder = occurrences.create_finder(self.pycore, param, pyname)
        result = rename.rename_in_module(finder, 'self.' + param,
                                         pymodule=pymod)
        body = result[result.index('\n') + 1:]
    return body

</t>
<t tx="ekr.20080516150804.1654">def _get_init(self):
    params = self._get_parameter_names()
    indents = ' ' * sourceutils.get_indent(self.pycore)
    if not params:
        return ''
    header = indents + 'def __init__(self'
    body = ''
    for arg in params:
        new_name = arg
        if arg == 'self':
            new_name = 'host'
        header += ', %s' % new_name
        body += indents * 2 + 'self.%s = %s\n' % (arg, new_name)
    header += '):'
    return '%s\n%s\n' % (header, body)

</t>
<t tx="ekr.20080516150804.1655">def _get_parameter_names(self):
    return self.pyfunction.get_param_names()
</t>
<t tx="ekr.20080516150804.1656">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1657">"""A module containing classes for move refactoring

`create_move()` is a factory for creating move refactoring objects
based on inputs.

"""
from rope.base import pyobjects, codeanalyze, exceptions, pynames, taskhandle, evaluate, worder
from rope.base.change import ChangeSet, ChangeContents, MoveResource
from rope.refactor import importutils, rename, occurrences, sourceutils, functionutils


</t>
<t tx="ekr.20080516150804.1658">def create_move(project, resource, offset=None):
    """A factory for creating Move objects

    Based on `resource` and `offset`, return one of `MoveModule`,
    `MoveGlobal` or `MoveMethod` for performing move refactoring.

    """
    if offset is None:
        return MoveModule(project, resource)
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    pyname = evaluate.get_pyname_at(this_pymodule, offset)
    if pyname is None:
        raise exceptions.RefactoringError(
            'Move only works on classes, functions, modules and methods.')
    pyobject = pyname.get_object()
    if isinstance(pyobject, pyobjects.PyModule) or \
       isinstance(pyobject, pyobjects.PyPackage):
        return MoveModule(project, pyobject.get_resource())
    if isinstance(pyobject, pyobjects.PyFunction) and \
       isinstance(pyobject.parent, pyobjects.PyClass):
        return MoveMethod(project, resource, offset)
    if isinstance(pyobject, pyobjects.PyDefinedObject) and \
       isinstance(pyobject.parent, pyobjects.PyModule):
        return MoveGlobal(project, resource, offset)
    raise exceptions.RefactoringError(
        'Move only works on global classes/functions, modules and methods.')


</t>
<t tx="ekr.20080516150804.1659">class MoveMethod(object):
    """For moving methods

    It makes a new method in the destination class and changes
    the body of the old method to call the new method.  You can
    inline the old method to change all of its occurrences.

    """
    @others
</t>
<t tx="ekr.20080516150804.1660">
def __init__(self, project, resource, offset):
    self.project = project
    self.pycore = project.pycore
    this_pymodule = self.pycore.resource_to_pyobject(resource)
    pyname = evaluate.get_pyname_at(this_pymodule, offset)
    self.method_name = worder.get_name_at(resource, offset)
    self.pyfunction = pyname.get_object()
    if self.pyfunction.get_kind() != 'method':
        raise exceptions.RefactoringError('Only normal methods'
                                          ' can be moved.')

</t>
<t tx="ekr.20080516150804.1661">def get_changes(self, dest_attr, new_name=None, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Return the changes needed for this refactoring

    Parameters:

    - `dest_attr`: the name of the destination attribute
    - `new_name`: the name of the new method; if `None` uses
      the old name
    - `resources` can be a list of `rope.base.resources.File`\s to
      apply this refactoring on.  If `None`, the restructuring
      will be applied to all python files.

    """
    changes = ChangeSet('Moving method &lt;%s&gt;' % self.method_name)
    if resources is None:
        resources = self.pycore.get_python_files()
    if new_name is None:
        new_name = self.get_method_name()
    resource1, start1, end1, new_content1 = \
        self._get_changes_made_by_old_class(dest_attr, new_name)
    collector1 = codeanalyze.ChangeCollector(resource1.read())
    collector1.add_change(start1, end1, new_content1)

    resource2, start2, end2, new_content2 = \
        self._get_changes_made_by_new_class(dest_attr, new_name)
    if resource1 == resource2:
        collector1.add_change(start2, end2, new_content2)
    else:
        collector2 = codeanalyze.ChangeCollector(resource2.read())
        collector2.add_change(start2, end2, new_content2)
        result = collector2.get_changed()
        import_tools = importutils.ImportTools(self.pycore)
        new_imports = self._get_used_imports(import_tools)
        if new_imports:
            goal_pymodule = self.pycore.get_string_module(result,
                                                          resource2)
            result = _add_imports_to_module(
                import_tools, goal_pymodule, new_imports)
        if resource2 in resources:
            changes.add_change(ChangeContents(resource2, result))

    if resource1 in resources:
        changes.add_change(ChangeContents(resource1,
                                          collector1.get_changed()))
    return changes

</t>
<t tx="ekr.20080516150804.1662">def get_method_name(self):
    return self.method_name

</t>
<t tx="ekr.20080516150804.1663">def _get_used_imports(self, import_tools):
    return importutils.get_imports(self.pycore, self.pyfunction)

</t>
<t tx="ekr.20080516150804.1664">def _get_changes_made_by_old_class(self, dest_attr, new_name):
    pymodule = self.pyfunction.get_module()
    indents = self._get_scope_indents(self.pyfunction)
    body = 'return self.%s.%s(%s)\n' % (dest_attr, new_name,
                                        self._get_passed_arguments_string())
    region = sourceutils.get_body_region(self.pyfunction)
    return (pymodule.get_resource(), region[0], region[1],
            sourceutils.fix_indentation(body, indents))

</t>
<t tx="ekr.20080516150804.1665">def _get_scope_indents(self, pyobject):
    pymodule = pyobject.get_module()
    return sourceutils.get_indents(
        pymodule.lines, pyobject.get_scope().get_start()) + \
        sourceutils.get_indent(self.pycore)

</t>
<t tx="ekr.20080516150804.1666">def _get_changes_made_by_new_class(self, dest_attr, new_name):
    old_pyclass = self.pyfunction.parent
    if dest_attr not in old_pyclass:
        raise exceptions.RefactoringError(
            'Destination attribute &lt;%s&gt; not found' % dest_attr)
    pyclass = old_pyclass[dest_attr].get_object().get_type()
    if not isinstance(pyclass, pyobjects.PyClass):
        raise exceptions.RefactoringError(
            'Unknown class type for attribute &lt;%s&gt;' % dest_attr)
    pymodule = pyclass.get_module()
    resource = pyclass.get_module().get_resource()
    start, end = sourceutils.get_body_region(pyclass)
    pre_blanks = '\n'
    if pymodule.source_code[start:end].strip() != 'pass':
        pre_blanks = '\n\n'
        start = end
    indents = self._get_scope_indents(pyclass)
    body = pre_blanks + sourceutils.fix_indentation(
        self.get_new_method(new_name), indents)
    return resource, start, end, body

</t>
<t tx="ekr.20080516150804.1667">def get_new_method(self, name):
    return '%s\n%s' % (
        self._get_new_header(name),
        sourceutils.fix_indentation(self._get_body(),
                                    sourceutils.get_indent(self.pycore)))

</t>
<t tx="ekr.20080516150804.1668">def _get_unchanged_body(self):
    return sourceutils.get_body(self.pyfunction)

</t>
<t tx="ekr.20080516150804.1669">def _get_body(self, host='host'):
    self_name = self._get_self_name()
    body = self_name + ' = None\n' + self._get_unchanged_body()
    pymodule = self.pycore.get_string_module(body)
    finder = occurrences.create_finder(
        self.pycore, self_name, pymodule[self_name])
    result = rename.rename_in_module(finder, host, pymodule=pymodule)
    if result is None:
        result = body
    return result[result.index('\n') + 1:]

</t>
<t tx="ekr.20080516150804.1670">def _get_self_name(self):
    return self.pyfunction.get_param_names()[0]

</t>
<t tx="ekr.20080516150804.1671">def _get_new_header(self, name):
    header = 'def %s(self' % name
    if self._is_host_used():
        header += ', host'
    definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
    others = definition_info.arguments_to_string(1)
    if others:
        header += ', ' + others
    return header + '):'

</t>
<t tx="ekr.20080516150804.1672">def _get_passed_arguments_string(self):
    result = ''
    if self._is_host_used():
        result = 'self'
    definition_info = functionutils.DefinitionInfo.read(self.pyfunction)
    others = definition_info.arguments_to_string(1)
    if others:
        if result:
            result += ', '
        result += others
    return result

</t>
<t tx="ekr.20080516150804.1673">def _is_host_used(self):
    return self._get_body('__old_self') != self._get_unchanged_body()


</t>
<t tx="ekr.20080516150804.1674">class MoveGlobal(object):
    """For moving global function and classes"""
    @others
</t>
<t tx="ekr.20080516150804.1675">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    this_pymodule = self.pycore.resource_to_pyobject(resource)
    self.old_pyname = evaluate.get_pyname_at(this_pymodule, offset)
    self.old_name = self.old_pyname.get_object().get_name()
    pymodule = self.old_pyname.get_object().get_module()
    self.source = pymodule.get_resource()
    self.tools = _MoveTools(self.pycore, self.source,
                            self.old_pyname, self.old_name)
    self.import_tools = self.tools.import_tools
    self._check_exceptional_conditions()

</t>
<t tx="ekr.20080516150804.1676">def _check_exceptional_conditions(self):
    if self.old_pyname is None or \
       not isinstance(self.old_pyname.get_object(), pyobjects.PyDefinedObject):
        raise exceptions.RefactoringError(
            'Move refactoring should be performed on a class/function.')
    moving_pyobject = self.old_pyname.get_object()
    if not self._is_global(moving_pyobject):
        raise exceptions.RefactoringError(
            'Move refactoring should be performed on a global class/function.')

</t>
<t tx="ekr.20080516150804.1677">def _is_global(self, pyobject):
    return pyobject.get_scope().parent == pyobject.get_module().get_scope()

</t>
<t tx="ekr.20080516150804.1678">def get_changes(self, dest, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    if resources is None:
        resources = self.pycore.get_python_files()
    if dest is None or not dest.exists():
        raise exceptions.RefactoringError(
            'Move destination does not exist.')
    if dest.is_folder() and dest.has_child('__init__.py'):
        dest = dest.get_child('__init__.py')
    if dest.is_folder():
        raise exceptions.RefactoringError(
            'Move destination for non-modules should not be folders.')
    if self.source == dest:
        raise exceptions.RefactoringError(
            'Moving global elements to the same module.')
    return self._calculate_changes(dest, resources, task_handle)

</t>
<t tx="ekr.20080516150804.1679">def _calculate_changes(self, dest, resources, task_handle):
    changes = ChangeSet('Moving global &lt;%s&gt;' % self.old_name)
    job_set = task_handle.create_jobset('Collecting Changes',
                                        len(resources))
    for file_ in resources:
        job_set.started_job(file_.path)
        if file_ == self.source:
            changes.add_change(self._source_module_changes(dest))
        elif file_ == dest:
            changes.add_change(self._dest_module_changes(dest))
        elif self.tools.occurs_in_module(resource=file_):
            pymodule = self.pycore.resource_to_pyobject(file_)
            # Changing occurrences
            placeholder = '__rope_renaming_%s_' % self.old_name
            source = self.tools.rename_in_module(placeholder,
                                                 resource=file_)
            should_import = source is not None
            # Removing out of date imports
            pymodule = self.tools.new_pymodule(pymodule, source)
            source = self.tools.remove_old_imports(pymodule)
            # Adding new import
            if should_import:
                pymodule = self.tools.new_pymodule(pymodule, source)
                source, imported = importutils.add_import(
                    self.pycore, pymodule, self._new_modname(dest), self.old_name)
                source = source.replace(placeholder, imported)
            source = self.tools.new_source(pymodule, source)
            if source != file_.read():
                changes.add_change(ChangeContents(file_, source))
        job_set.finished_job()
    return changes

</t>
<t tx="ekr.20080516150804.1680">def _source_module_changes(self, dest):
    placeholder = '__rope_moving_%s_' % self.old_name
    handle = _ChangeMoveOccurrencesHandle(placeholder)
    occurrence_finder = occurrences.create_finder(
        self.pycore, self.old_name, self.old_pyname)
    start, end = self._get_moving_region()
    renamer = ModuleSkipRenamer(occurrence_finder, self.source,
                                handle, start, end)
    source = renamer.get_changed_module()
    if handle.occurred:
        pymodule = self.pycore.get_string_module(source, self.source)
        # Adding new import
        source, imported = importutils.add_import(
            self.pycore, pymodule, self._new_modname(dest), self.old_name)
        source = source.replace(placeholder, imported)
    return ChangeContents(self.source, source)

</t>
<t tx="ekr.20080516150804.1681">def _new_modname(self, dest):
    return importutils.get_module_name(self.pycore, dest)

</t>
<t tx="ekr.20080516150804.1682">def _dest_module_changes(self, dest):
    # Changing occurrences
    pymodule = self.pycore.resource_to_pyobject(dest)
    source = self.tools.rename_in_module(self.old_name, pymodule)
    pymodule = self.tools.new_pymodule(pymodule, source)

    moving, imports = self._get_moving_element_with_imports()
    source = self.tools.remove_old_imports(pymodule)
    pymodule = self.tools.new_pymodule(pymodule, source)
    pymodule, has_changed = self._add_imports2(pymodule, imports)

    module_with_imports = self.import_tools.module_imports(pymodule)
    source = pymodule.source_code
    if module_with_imports.imports:
        start = pymodule.lines.get_line_end(
            module_with_imports.imports[-1].end_line - 1)
        result = source[:start + 1] + '\n\n'
    else:
        result = ''
        start = -1
    result += moving + source[start + 1:]

    # Organizing imports
    source = result
    pymodule = self.pycore.get_string_module(source, dest)
    source = self.import_tools.organize_imports(pymodule, sort=False,
                                                unused=False)
    return ChangeContents(dest, source)

</t>
<t tx="ekr.20080516150804.1683">def _get_moving_element_with_imports(self):
    return moving_code_with_imports(
        self.pycore, self.source, self._get_moving_element())

</t>
<t tx="ekr.20080516150804.1684">def _get_module_with_imports(self, source_code, resource):
    pymodule = self.pycore.get_string_module(source_code, resource)
    return self.import_tools.module_imports(pymodule)

</t>
<t tx="ekr.20080516150804.1685">def _get_moving_element(self):
    start, end = self._get_moving_region()
    moving = self.source.read()[start:end]
    return moving.rstrip() + '\n'

</t>
<t tx="ekr.20080516150804.1686">def _get_moving_region(self):
    pymodule = self.pycore.resource_to_pyobject(self.source)
    lines = pymodule.lines
    scope = self.old_pyname.get_object().get_scope()
    start = lines.get_line_start(scope.get_start())
    end_line = scope.get_end()
    while end_line &lt; lines.length() and \
          lines.get_line(end_line + 1).strip() == '':
        end_line += 1
    end = min(lines.get_line_end(end_line) + 1, len(pymodule.source_code))
    return start, end

</t>
<t tx="ekr.20080516150804.1687">def _add_imports2(self, pymodule, new_imports):
    source = self.tools.add_imports(pymodule, new_imports)
    if source is None:
        return pymodule, False
    else:
        resource = pymodule.get_resource()
        pymodule = self.pycore.get_string_module(source, resource)
        return pymodule, True


</t>
<t tx="ekr.20080516150804.1688">class MoveModule(object):
    """For moving modules and packages"""
    @others
</t>
<t tx="ekr.20080516150804.1689">
def __init__(self, project, resource):
    self.project = project
    self.pycore = project.pycore
    if not resource.is_folder() and resource.name == '__init__.py':
        resource = resource.parent
    if resource.is_folder() and not resource.has_child('__init__.py'):
        raise exceptions.RefactoringError(
            'Cannot move non-package folder.')
    dummy_pymodule = self.pycore.get_string_module('')
    self.old_pyname = pynames.ImportedModule(dummy_pymodule,
                                             resource=resource)
    self.source = self.old_pyname.get_object().get_resource()
    if self.source.is_folder():
        self.old_name = self.source.name
    else:
        self.old_name = self.source.name[:-3]
    self.tools = _MoveTools(self.pycore, self.source,
                            self.old_pyname, self.old_name)
    self.import_tools = self.tools.import_tools

</t>
<t tx="ekr.20080516150804.1690">def get_changes(self, dest, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    moving_pyobject = self.old_pyname.get_object()
    if resources is None:
        resources = self.pycore.get_python_files()
    if dest is None or not dest.is_folder():
        raise exceptions.RefactoringError(
            'Move destination for modules should be packages.')
    return self._calculate_changes(dest, resources, task_handle)

</t>
<t tx="ekr.20080516150804.1691">def _calculate_changes(self, dest, resources, task_handle):
    changes = ChangeSet('Moving module &lt;%s&gt;' % self.old_name)
    job_set = task_handle.create_jobset('Collecting changes',
                                        len(resources))
    for module in resources:
        job_set.started_job(module.path)
        if module == self.source:
            self._change_moving_module(changes, dest)
        else:
            source = self._change_occurrences_in_module(dest,
                                                        resource=module)
            if source is not None:
                changes.add_change(ChangeContents(module, source))
        job_set.finished_job()
    if self.project == self.source.project:
        changes.add_change(MoveResource(self.source, dest.path))
    return changes

</t>
<t tx="ekr.20080516150804.1692">def _new_modname(self, dest):
    destname = importutils.get_module_name(self.pycore, dest)
    if destname:
        return destname + '.' + self.old_name
    return self.old_name

</t>
<t tx="ekr.20080516150804.1693">def _new_import(self, dest):
    return importutils.NormalImport([(self._new_modname(dest), None)])

</t>
<t tx="ekr.20080516150804.1694">def _change_moving_module(self, changes, dest):
    if not self.source.is_folder():
        pymodule = self.pycore.resource_to_pyobject(self.source)
        source = self.import_tools.relatives_to_absolutes(pymodule)
        pymodule = self.tools.new_pymodule(pymodule, source)
        source = self._change_occurrences_in_module(dest, pymodule)
        source = self.tools.new_source(pymodule, source)
        if source != self.source.read():
            changes.add_change(ChangeContents(self.source, source))

</t>
<t tx="ekr.20080516150804.1695">def _change_occurrences_in_module(self, dest, pymodule=None,
                                  resource=None):
    if not self.tools.occurs_in_module(pymodule=pymodule,
                                       resource=resource):
        return
    if pymodule is None:
        pymodule = self.pycore.resource_to_pyobject(resource)
    new_name = self._new_modname(dest)
    new_import = self._new_import(dest)
    source = self.tools.rename_in_module(
        new_name, imports=True, pymodule=pymodule, resource=resource)
    should_import = self.tools.occurs_in_module(
        pymodule=pymodule, resource=resource, imports=False)
    pymodule = self.tools.new_pymodule(pymodule, source)
    source = self.tools.remove_old_imports(pymodule)
    if should_import:
        pymodule = self.tools.new_pymodule(pymodule, source)
        source = self.tools.add_imports(pymodule, [new_import])
    source = self.tools.new_source(pymodule, source)
    if source != pymodule.resource.read():
        return source


</t>
<t tx="ekr.20080516150804.1696">class _ChangeMoveOccurrencesHandle(object):
    @others
</t>
<t tx="ekr.20080516150804.1697">
def __init__(self, new_name):
    self.new_name = new_name
    self.occurred = False

</t>
<t tx="ekr.20080516150804.1698">def occurred_inside_skip(self, change_collector, occurrence):
    pass

</t>
<t tx="ekr.20080516150804.1699">def occurred_outside_skip(self, change_collector, occurrence):
    start, end = occurrence.get_primary_range()
    change_collector.add_change(start, end, self.new_name)
    self.occurred = True


</t>
<t tx="ekr.20080516150804.1700">class _MoveTools(object):
    @others
</t>
<t tx="ekr.20080516150804.1701">
def __init__(self, pycore, source, pyname, old_name):
    self.pycore = pycore
    self.source = source
    self.old_pyname = pyname
    self.old_name = old_name
    self.import_tools = importutils.ImportTools(self.pycore)

</t>
<t tx="ekr.20080516150804.1702">def remove_old_imports(self, pymodule):
    old_source = pymodule.source_code
    module_with_imports = self.import_tools.module_imports(pymodule)
    class CanSelect(object):
        changed = False
        old_name = self.old_name
        old_pyname = self.old_pyname
        def __call__(self, name):
            try:
                if name == self.old_name and \
                   pymodule[name].get_object() == \
                   self.old_pyname.get_object():
                    self.changed = True
                    return False
            except exceptions.AttributeNotFoundError:
                pass
            return True
    can_select = CanSelect()
    module_with_imports.filter_names(can_select)
    new_source = module_with_imports.get_changed_source()
    if old_source != new_source:
        return new_source

</t>
<t tx="ekr.20080516150804.1703">def rename_in_module(self, new_name, pymodule=None,
                      imports=False, resource=None):
    occurrence_finder = self._create_finder(imports)
    source = rename.rename_in_module(
        occurrence_finder, new_name, replace_primary=True,
        pymodule=pymodule, resource=resource)
    return source

</t>
<t tx="ekr.20080516150804.1704">def occurs_in_module(self, pymodule=None, resource=None, imports=True):
    finder = self._create_finder(imports)
    for occurrence in finder.find_occurrences(pymodule=pymodule,
                                              resource=resource):
        return True
    return False

</t>
<t tx="ekr.20080516150804.1705">def _create_finder(self, imports):
    return occurrences.create_finder(self.pycore, self.old_name,
                                     self.old_pyname, imports=imports)

</t>
<t tx="ekr.20080516150804.1706">def new_pymodule(self, pymodule, source):
    if source is not None:
        return self.pycore.get_string_module(
            source, pymodule.get_resource())
    return pymodule

</t>
<t tx="ekr.20080516150804.1707">def new_source(self, pymodule, source):
    if source is None:
        return pymodule.source_code
    return source

</t>
<t tx="ekr.20080516150804.1708">def add_imports(self, pymodule, new_imports):
    return _add_imports_to_module(self.import_tools, pymodule, new_imports)


</t>
<t tx="ekr.20080516150804.1709">def _add_imports_to_module(import_tools, pymodule, new_imports):
    module_with_imports = import_tools.module_imports(pymodule)
    for new_import in new_imports:
        module_with_imports.add_import(new_import)
    return module_with_imports.get_changed_source()


</t>
<t tx="ekr.20080516150804.1710">def moving_code_with_imports(pycore, resource, source):
    import_tools = importutils.ImportTools(pycore)
    pymodule = pycore.get_string_module(source, resource)
    origin = pycore.resource_to_pyobject(resource)

    imports = []
    for stmt in import_tools.module_imports(origin).imports:
        imports.append(stmt.import_info)

    back_names = []
    for name in origin:
        if name not in pymodule:
            back_names.append(name)
    imports.append(import_tools.get_from_import(resource, back_names))

    source = _add_imports_to_module(import_tools, pymodule, imports)
    pymodule = pycore.get_string_module(source, resource)

    source = import_tools.relatives_to_absolutes(pymodule)
    pymodule = pycore.get_string_module(source, resource)
    source = import_tools.organize_imports(pymodule, selfs=False)
    pymodule = pycore.get_string_module(source, resource)

    # extracting imports after changes
    module_imports = import_tools.module_imports(pymodule)
    imports = [import_stmt.import_info
               for import_stmt in module_imports.imports]
    start = 1
    if module_imports.imports:
        start = module_imports.imports[-1].end_line
    lines = codeanalyze.SourceLinesAdapter(source)
    while start &lt; lines.length() and not lines.get_line(start).strip():
        start += 1
    moving = source[lines.get_line_start(start):]
    return moving, imports


</t>
<t tx="ekr.20080516150804.1711">class ModuleSkipRenamerHandle(object):
    @others
</t>
<t tx="ekr.20080516150804.1712">
def occurred_outside_skip(self, change_collector, occurrence):
    pass

</t>
<t tx="ekr.20080516150804.1713">def occurred_inside_skip(self, change_collector, occurrence):
    pass


</t>
<t tx="ekr.20080516150804.1714">class ModuleSkipRenamer(object):
    """Rename occurrences in a module

    This class can be used when you want to treat a region in a file
    separately from other parts when renaming.

    """
    @others
</t>
<t tx="ekr.20080516150804.1715">
def __init__(self, occurrence_finder, resource, handle=None,
             skip_start=0, skip_end=0, replacement=''):
    """Constructor

    if replacement is `None` the region is not changed.  Otherwise
    it is replaced with `replacement`.

    """
    self.occurrence_finder = occurrence_finder
    self.resource = resource
    self.skip_start = skip_start
    self.skip_end = skip_end
    self.replacement = replacement
    self.handle = handle
    if self.handle is None:
        self.handle = ModuleSkipHandle()

</t>
<t tx="ekr.20080516150804.1716">def get_changed_module(self):
    source = self.resource.read()
    change_collector = codeanalyze.ChangeCollector(source)
    if self.replacement is not None:
        change_collector.add_change(self.skip_start, self.skip_end,
                                    self.replacement)
    for occurrence in self.occurrence_finder.find_occurrences(self.resource):
        start, end = occurrence.get_primary_range()
        if self.skip_start &lt;= start &lt; self.skip_end:
            self.handle.occurred_inside_skip(change_collector, occurrence)
        else:
            self.handle.occurred_outside_skip(change_collector, occurrence)
    result = change_collector.get_changed()
    if result is not None and result != source:
        return result
</t>
<t tx="ekr.20080516150804.1717">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1718">"""This module can be used for performing cross-project refactorings

See the "cross-project refactorings" section of ``docs/library.txt``
file.

"""

from rope.base import resources, project, libutils


</t>
<t tx="ekr.20080516150804.1719">class MultiProjectRefactoring(object):
    @others
</t>
<t tx="ekr.20080516150804.1720">
def __init__(self, refactoring, projects, addpath=True):
    """Create a multiproject proxy for the main refactoring

    `projects` are other project.

    """
    self.refactoring = refactoring
    self.projects = projects
    self.addpath = addpath

</t>
<t tx="ekr.20080516150804.1721">def __call__(self, project, *args, **kwds):
    """Create the refactoring"""
    return _MultiRefactoring(self.refactoring, self.projects,
                             self.addpath, project, *args, **kwds)


</t>
<t tx="ekr.20080516150804.1722">class _MultiRefactoring(object):
    @others
</t>
<t tx="ekr.20080516150804.1723">
def __init__(self, refactoring, other_projects, addpath,
             project, *args, **kwds):
    self.refactoring = refactoring
    self.projects = [project] + other_projects
    for other_project in other_projects:
        for folder in self.project.pycore.get_source_folders():
            other_project.get_prefs().add('python_path', folder.real_path)
    self.refactorings = []
    for other in self.projects:
        args, kwds = self._resources_for_args(other, args, kwds)
        self.refactorings.append(
            self.refactoring(other, *args, **kwds))

</t>
<t tx="ekr.20080516150804.1724">def get_all_changes(self, *args, **kwds):
    """Get a project to changes dict"""
    result = []
    for project, refactoring in zip(self.projects, self.refactorings):
        args, kwds = self._resources_for_args(project, args, kwds)
        result.append((project, refactoring.get_changes(*args, **kwds)))
    return result

</t>
<t tx="ekr.20080516150804.1725">def __getattr__(self, name):
    return getattr(self.main_refactoring, name)

</t>
<t tx="ekr.20080516150804.1726">def _resources_for_args(self, project, args, kwds):
    newargs = [self._change_project_resource(project, arg) for arg in args]
    newkwds = dict((name, self._change_project_resource(project, value))
                   for name, value in kwds.items())
    return newargs, newkwds
    
</t>
<t tx="ekr.20080516150804.1727">def _change_project_resource(self, project, obj):
    if isinstance(obj, resources.Resource) and \
       obj.project != project:
        return libutils.path_to_resource(project, obj.real_path)
    return obj

</t>
<t tx="ekr.20080516150804.1728">@property
def project(self):
    return self.projects[0]

</t>
<t tx="ekr.20080516150804.1729">@property
def main_refactoring(self):
    return self.refactorings[0]


</t>
<t tx="ekr.20080516150804.1730">def perform(project_changes):
    for project, changes in project_changes:
        project.do(changes)
</t>
<t tx="ekr.20080516150804.1731">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1732">import re

import rope.base.pynames
from rope.base import pynames, pyobjects, codeanalyze, evaluate, exceptions, utils, worder


</t>
<t tx="ekr.20080516150804.1733">class Finder(object):
    """For finding occurrences of a name

    The constructor takes a `filters` argument.  It should be a list
    of functions that take a single argument.  For each possible
    occurrence, these functions are called in order with the an
    instance of `Occurrence`:

      * If it returns `None` other filters are tried.
      * If it returns `True`, the occurrence will be a match.
      * If it returns `False`, the occurrence will be skipped.
      * If all of the filters return `None`, it is skipped also.

    """
    @others
</t>
<t tx="ekr.20080516150804.1734">
def __init__(self, pycore, name, filters=[lambda o: True], docs=False):
    self.pycore = pycore
    self.name = name
    self.docs = docs
    self.filters = filters
    self._textual_finder = _TextualFinder(name, docs=docs)

</t>
<t tx="ekr.20080516150804.1735">def find_occurrences(self, resource=None, pymodule=None):
    """Generate `Occurrence` instances"""
    tools = _OccurrenceToolsCreator(self.pycore, resource=resource,
                                    pymodule=pymodule, docs=self.docs)
    for offset in self._textual_finder.find_offsets(tools.source_code):
        occurrence = Occurrence(tools, offset)
        for filter in self.filters:
            result = filter(occurrence)
            if result is None:
                continue
            if result:
                yield occurrence
            break


</t>
<t tx="ekr.20080516150804.1736">def create_finder(pycore, name, pyname, only_calls=False, imports=True,
                  unsure=None, docs=False, instance=None, in_hierarchy=False):
    """A factory for `Finder`

    Based on the arguments it creates a list of filters.  `instance`
    argument is needed only when you want implicit interfaces to be
    considered.

    """
    pynames = set([pyname])
    filters = []
    if only_calls:
        filters.append(CallsFilter())
    if not imports:
        filters.append(NoImportsFilter())
    if isinstance(instance, rope.base.pynames.ParameterName):
        for pyobject in instance.get_objects():
            try:
                pynames.add(pyobject[name])
            except exceptions.AttributeNotFoundError:
                pass
    for pyname in pynames:
        filters.append(PyNameFilter(pyname))
        if in_hierarchy:
            filters.append(InHierarchyFilter(pyname))
    if unsure:
        filters.append(UnsureFilter(unsure))
    return Finder(pycore, name, filters=filters, docs=docs)


</t>
<t tx="ekr.20080516150804.1737">class Occurrence(object):
    @others
</t>
<t tx="ekr.20080516150804.1738">
def __init__(self, tools, offset):
    self.tools = tools
    self.offset = offset
    self.resource = tools.resource

</t>
<t tx="ekr.20080516150804.1739">@utils.cacheit
def get_word_range(self):
    return self.tools.word_finder.get_word_range(self.offset)

</t>
<t tx="ekr.20080516150804.1740">@utils.cacheit
def get_primary_range(self):
    return self.tools.word_finder.get_primary_range(self.offset)

</t>
<t tx="ekr.20080516150804.1741">@utils.cacheit
def get_pyname(self):
    try:
        return self.tools.name_finder.get_pyname_at(self.offset)
    except exceptions.BadIdentifierError:
        pass

</t>
<t tx="ekr.20080516150804.1742">@utils.cacheit
def get_primary_and_pyname(self):
    try:
        return self.tools.name_finder.get_primary_and_pyname_at(self.offset)
    except exceptions.BadIdentifierError:
        pass

</t>
<t tx="ekr.20080516150804.1743">@utils.cacheit
def is_in_import_statement(self):
    return (self.tools.word_finder.is_from_statement(self.offset) or
            self.tools.word_finder.is_import_statement(self.offset))

</t>
<t tx="ekr.20080516150804.1744">def is_called(self):
    return self.tools.word_finder.is_a_function_being_called(self.offset)

</t>
<t tx="ekr.20080516150804.1745">def is_defined(self):
    return self.tools.word_finder.is_a_class_or_function_name_in_header(self.offset)

</t>
<t tx="ekr.20080516150804.1746">def is_a_fixed_primary(self):
    return self.tools.word_finder.is_a_class_or_function_name_in_header(self.offset) or \
           self.tools.word_finder.is_a_name_after_from_import(self.offset)

</t>
<t tx="ekr.20080516150804.1747">def is_written(self):
    return self.tools.word_finder.is_assigned_here(self.offset)

</t>
<t tx="ekr.20080516150804.1748">def is_unsure(self):
    return unsure_pyname(self.get_pyname())


</t>
<t tx="ekr.20080516150804.1749">def same_pyname(expected, pyname):
    """Check whether `expected` and `pyname` are the same"""
    if expected is None or pyname is None:
        return False
    if expected == pyname:
        return True
    if type(expected) not in (pynames.ImportedModule, pynames.ImportedName) and \
       type(pyname) not in (pynames.ImportedModule, pynames.ImportedName):
        return False
    return expected.get_definition_location() == pyname.get_definition_location() and \
           expected.get_object() == pyname.get_object()

</t>
<t tx="ekr.20080516150804.1750">def unsure_pyname(pyname, unbound=True):
    """Return `True` if we don't know what this name references"""
    if pyname is None:
        return True
    if unbound and not isinstance(pyname, pynames.UnboundName):
        return False
    if pyname.get_object() == pyobjects.get_unknown():
        return True


</t>
<t tx="ekr.20080516150804.1751">class PyNameFilter(object):
    """For finding occurrences of a name"""
    @others
</t>
<t tx="ekr.20080516150804.1752">
def __init__(self, pyname):
    self.pyname = pyname

</t>
<t tx="ekr.20080516150804.1753">def __call__(self, occurrence):
    if same_pyname(self.pyname, occurrence.get_pyname()):
        return True


</t>
<t tx="ekr.20080516150804.1754">class InHierarchyFilter(object):
    """For finding occurrences of a name"""
    @others
</t>
<t tx="ekr.20080516150804.1755">
def __init__(self, pyname, implementations_only=False):
    self.pyname = pyname
    self.impl_only = implementations_only
    self.pyclass = self._get_containing_class(pyname)
    if self.pyclass is not None:
        self.name = pyname.get_object().get_name()
        self.roots = self._get_root_classes(self.pyclass, self.name)
    else:
        self.roots = None

</t>
<t tx="ekr.20080516150804.1756">def __call__(self, occurrence):
    if self.roots is None:
        return
    pyclass = self._get_containing_class(occurrence.get_pyname())
    if pyclass is not None:
        roots = self._get_root_classes(pyclass, self.name)
        if self.roots.intersection(roots):
            return True

</t>
<t tx="ekr.20080516150804.1757">def _get_containing_class(self, pyname):
    if isinstance(pyname, pynames.DefinedName):
        scope = pyname.get_object().get_scope()
        parent = scope.parent
        if parent is not None and parent.get_kind() == 'Class':
            return parent.pyobject

</t>
<t tx="ekr.20080516150804.1758">def _get_root_classes(self, pyclass, name):
    if self.impl_only and pyclass == self.pyclass:
        return set([pyclass])
    result = set()
    for superclass in pyclass.get_superclasses():
        if name in superclass:
            result.update(self._get_root_classes(superclass, name))
    if not result:
        return set([pyclass])
    return result


</t>
<t tx="ekr.20080516150804.1759">class UnsureFilter(object):
    @others
</t>
<t tx="ekr.20080516150804.1760">
def __init__(self, unsure):
    self.unsure = unsure

</t>
<t tx="ekr.20080516150804.1761">def __call__(self, occurrence):
    if occurrence.is_unsure() and self.unsure(occurrence):
        return True


</t>
<t tx="ekr.20080516150804.1762">class NoImportsFilter(object):
    @others
</t>
<t tx="ekr.20080516150804.1763">
def __call__(self, occurrence):
    if occurrence.is_in_import_statement():
        return False


</t>
<t tx="ekr.20080516150804.1764">class CallsFilter(object):
    @others
</t>
<t tx="ekr.20080516150804.1765">
def __call__(self, occurrence):
    if not occurrence.is_called():
        return False


</t>
<t tx="ekr.20080516150804.1766">class _TextualFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.1767">
def __init__(self, name, docs=False):
    self.name = name
    self.docs = docs
    self.comment_pattern = _TextualFinder.any('comment', [r'#[^\n]*'])
    self.string_pattern = _TextualFinder.any(
        'string', [codeanalyze.get_string_pattern()])
    self.pattern = self._get_occurrence_pattern(self.name)

</t>
<t tx="ekr.20080516150804.1768">def find_offsets(self, source):
    if not self._fast_file_query(source):
        return
    if self.docs:
        searcher = self._normal_search
    else:
        searcher = self._re_search
    for matched in searcher(source):
        yield matched

</t>
<t tx="ekr.20080516150804.1769">def _re_search(self, source):
    for match in self.pattern.finditer(source):
        for key, value in match.groupdict().items():
            if value and key == 'occurrence':
                yield match.start(key)

</t>
<t tx="ekr.20080516150804.1770">def _normal_search(self, source):
    current = 0
    while True:
        try:
            found = source.index(self.name, current)
            current = found + len(self.name)
            if (found == 0 or not self._is_id_char(source[found - 1])) and \
               (current == len(source) or not self._is_id_char(source[current])):
                yield found
        except ValueError:
            break

</t>
<t tx="ekr.20080516150804.1771">def _is_id_char(self, c):
    return c.isalnum() or c == '_'

</t>
<t tx="ekr.20080516150804.1772">def _fast_file_query(self, source):
    try:
        source.index(self.name)
        return True
    except ValueError:
        return False

</t>
<t tx="ekr.20080516150804.1773">def _get_source(self, resource, pymodule):
    if resource is not None:
        return resource.read()
    else:
        return pymodule.source_code

</t>
<t tx="ekr.20080516150804.1774">def _get_occurrence_pattern(self, name):
    occurrence_pattern = _TextualFinder.any('occurrence',
                                             ['\\b' + name + '\\b'])
    pattern = re.compile(occurrence_pattern + '|' + self.comment_pattern +
                         '|' + self.string_pattern)
    return pattern

</t>
<t tx="ekr.20080516150804.1775">@staticmethod
def any(name, list_):
    return '(?P&lt;%s&gt;' % name + '|'.join(list_) + ')'


</t>
<t tx="ekr.20080516150804.1776">class _OccurrenceToolsCreator(object):
    @others
</t>
<t tx="ekr.20080516150804.1777">
def __init__(self, pycore, resource=None, pymodule=None, docs=False):
    self.pycore = pycore
    self.resource = resource
    self.pymodule = pymodule
    self.docs = docs

</t>
<t tx="ekr.20080516150804.1778">@property
@utils.cacheit
def name_finder(self):
    if self.pymodule is None:
        self.pymodule = self.pycore.resource_to_pyobject(self.resource)
    return evaluate.ScopeNameFinder(self.pymodule)

</t>
<t tx="ekr.20080516150804.1779">@property
@utils.cacheit
def source_code(self):
    if self.resource is not None:
        return self.resource.read()
    else:
        return self.pymodule.source_code

</t>
<t tx="ekr.20080516150804.1780">@property
@utils.cacheit
def word_finder(self):
    return worder.Worder(self.source_code, self.docs)
</t>
<t tx="ekr.20080516150804.1781">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1782">import re
import warnings

from rope.base import ast, codeanalyze, exceptions


</t>
<t tx="ekr.20080516150804.1783">def get_patched_ast(source, sorted_children=False):
    """Adds ``region`` and ``sorted_children`` fields to nodes

    Adds ``sorted_children`` field only if `sorted_children` is True.

    """
    return patch_ast(ast.parse(source), source, sorted_children)


</t>
<t tx="ekr.20080516150804.1784">def patch_ast(node, source, sorted_children=False):
    """Patches the given node

    After calling, each node in `node` will have a new field named
    `region` that is a tuple containing the start and end offsets
    of the code that generated it.

    If `sorted_children` is true, a `sorted_children` field will
    be created for each node, too.  It is a list containing child
    nodes as well as whitespaces and comments that occur between
    them.

    """
    if hasattr(node, 'region'):
        return node
    walker = _PatchingASTWalker(source, children=sorted_children)
    ast.call_for_nodes(node, walker)
    return node


</t>
<t tx="ekr.20080516150804.1785">def node_region(patched_ast_node):
    """Get the region of a patched ast node"""
    return patched_ast_node.region


</t>
<t tx="ekr.20080516150804.1786">def write_ast(patched_ast_node):
    """Extract source form a patched AST node with `sorted_children` field

    If the node is patched with sorted_children turned off you can use
    `node_region` function for obtaining code using module source code.
    """
    result = []
    for child in patched_ast_node.sorted_children:
        if isinstance(child, ast.AST):
            result.append(write_ast(child))
        else:
            result.append(child)
    return ''.join(result)


</t>
<t tx="ekr.20080516150804.1787">class MismatchedTokenError(exceptions.RopeError):
    pass


</t>
<t tx="ekr.20080516150804.1788">class _PatchingASTWalker(object):
    @others
</t>
<t tx="ekr.20080516150804.1789">
def __init__(self, source, children=False):
    self.source = _Source(source)
    self.children = children
    self.lines = codeanalyze.SourceLinesAdapter(source)
    self.children_stack = []

</t>
<t tx="ekr.20080516150804.1790">Number = object()
String = object()

def __call__(self, node):
    method = getattr(self, '_' + node.__class__.__name__, None)
    if method is not None:
        return method(node)
    # ???: Unknown node; what should we do here?
    warnings.warn('Unknown node type &lt;%s&gt;; please report!'
                  % node.__class__.__name__, RuntimeWarning)
    node.region = (self.source.offset, self.source.offset)
    if self.children:
        node.sorted_children = ast.get_children(node)

</t>
<t tx="ekr.20080516150804.1791">def _handle(self, node, base_children, eat_parens=False, eat_spaces=False):
    if hasattr(node, 'region'):
        # ???: The same node was seen twice; what should we do?
        warnings.warn(
            'Node &lt;%s&gt; has been already patched; please report!' %
            node.__class__.__name__, RuntimeWarning)
        return
    self.children_stack.append(base_children)
    children = []
    formats = []
    suspected_start = self.source.offset
    start = suspected_start
    first_token = True
    while base_children:
        child = base_children.pop(0)
        if child is None:
            continue
        offset = self.source.offset
        if isinstance(child, ast.AST):
            ast.call_for_nodes(child, self)
            token_start = child.region[0]
        else:
            if child is self.String:
                region = self.source.consume_string(
                    end=self._find_next_statement_start())
            elif child is self.Number:
                region = self.source.consume_number()
            elif child == '!=':
                # INFO: This has been added to handle deprecated ``&lt;&gt;``
                region = self.source.consume_not_equal()
            else:
                region = self.source.consume(child)
            child = self.source.get(region[0], region[1])
            token_start = region[0]
        if not first_token:
            formats.append(self.source.get(offset, token_start))
            children.append(self.source.get(offset, token_start))
        else:
            first_token = False
            start = token_start
        children.append(child)
    start = self._handle_parens(children, start, formats)
    if eat_parens:
        start = self._eat_surrounding_parens(
            children, suspected_start, start)
    if eat_spaces:
        children.insert(0, self.source[0:start])
        end_spaces = self.source[self.source.offset:]
        self.source.consume(end_spaces)
        children.append(end_spaces)
        start = 0
    if self.children:
        node.sorted_children = children
    node.region = (start, self.source.offset)
    self.children_stack.pop()

</t>
<t tx="ekr.20080516150804.1792">def _handle_parens(self, children, start, formats):
    """Changes `children` and returns new start"""
    opens, closes = self._count_needed_parens(formats)
    old_end = self.source.offset
    new_end = None
    for i in range(closes):
        new_end = self.source.consume(')')[1]
    if new_end is not None:
        children.append(self.source.get(old_end, new_end))
    new_start = start
    for i in range(opens):
        new_start = self.source.rfind_token('(', 0, new_start)
    if new_start != start:
        children.insert(0, self.source.get(new_start, start))
        start = new_start
    return start

</t>
<t tx="ekr.20080516150804.1793">def _eat_surrounding_parens(self, children, suspected_start, start):
    index = self.source.rfind_token('(', suspected_start, start)
    if index is not None:
        old_start = start
        old_offset = self.source.offset
        start = index
        children.insert(0, '(')
        children.insert(1, self.source[start + 1:old_start])
        token_start, token_end = self.source.consume(')')
        children.append(self.source[old_offset:token_start])
        children.append(')')
    return start

</t>
<t tx="ekr.20080516150804.1794">def _count_needed_parens(self, children):
    start = 0
    opens = 0
    for child in children:
        if not isinstance(child, basestring):
            continue
        if child == '' or child[0] in '\'"':
            continue
        index = 0
        while index &lt; len(child):
            if child[index] == ')':
                if opens &gt; 0:
                    opens -= 1
                else:
                    start += 1
            if child[index] == '(':
                opens += 1
            if child[index] == '#':
                try:
                    index = child.index('\n', index)
                except ValueError:
                    break
            index += 1
    return start, opens

</t>
<t tx="ekr.20080516150804.1795">def _find_next_statement_start(self):
    for children in reversed(self.children_stack):
        for child in children:
            if isinstance(child, ast.stmt):
                return self.lines.get_line_start(child.lineno)
    return len(self.source.source)

</t>
<t tx="ekr.20080516150804.1796">_operators = {'And': 'and', 'Or': 'or', 'Add': '+', 'Sub': '-', 'Mult': '*',
              'Div': '/', 'Mod': '%', 'Pow': '**', 'LShift': '&lt;&lt;',
              'RShift': '&gt;&gt;', 'BitOr': '|', 'BitAnd': '&amp;', 'BitXor': '^',
              'FloorDiv': '//', 'Invert': '~', 'Not': 'not', 'UAdd': '+',
              'USub': '-', 'Eq': '==', 'NotEq': '!=', 'Lt': '&lt;',
              'LtE': '&lt;=', 'Gt': '&gt;', 'GtE': '&gt;=', 'Is': 'is',
              'IsNot': 'is not', 'In': 'in', 'NotIn': 'not in'}

def _get_op(self, node):
    return self._operators[node.__class__.__name__].split(' ')

</t>
<t tx="ekr.20080516150804.1797">def _Attribute(self, node):
    self._handle(node, [node.value, '.', node.attr])

</t>
<t tx="ekr.20080516150804.1798">def _Assert(self, node):
    children = ['assert', node.test]
    if node.msg:
        children.append(',')
        children.append(node.msg)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1799">def _Assign(self, node):
    children = self._child_nodes(node.targets, '=')
    children.append('=')
    children.append(node.value)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1800">def _AugAssign(self, node):
    children = [node.target]
    children.extend(self._get_op(node.op))
    children.extend(['=', node.value])
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1801">def _Repr(self, node):
    self._handle(node, ['`', node.value, '`'])

</t>
<t tx="ekr.20080516150804.1802">def _BinOp(self, node):
    children = [node.left] + self._get_op(node.op) + [node.right]
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1803">def _BoolOp(self, node):
    self._handle(node, self._child_nodes(node.values,
                                         self._get_op(node.op)[0]))

</t>
<t tx="ekr.20080516150804.1804">def _Break(self, node):
    self._handle(node, ['break'])

</t>
<t tx="ekr.20080516150804.1805">def _Call(self, node):
    children = [node.func, '(']
    args = list(node.args) + node.keywords
    children.extend(self._child_nodes(args, ','))
    if node.starargs is not None:
        if args:
            children.append(',')
        children.extend(['*', node.starargs])
    if node.kwargs is not None:
        if args or node.starargs is not None:
            children.append(',')
        children.extend(['**', node.kwargs])
    children.append(')')
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1806">def _ClassDef(self, node):
    children = []
    if getattr(node, 'decorator_list', None):
        for decorator in node.decorator_list:
            children.append('@')
            children.append(decorator)
    children.extend(['class', node.name])
    if node.bases:
        children.append('(')
        children.extend(self._child_nodes(node.bases, ','))
        children.append(')')
    children.append(':')
    children.extend(node.body)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1807">def _Compare(self, node):
    children = []
    children.append(node.left)
    for op, expr in zip(node.ops, node.comparators):
        children.extend(self._get_op(op))
        children.append(expr)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1808">def _Delete(self, node):
    self._handle(node, ['del'] + self._child_nodes(node.targets, ','))

</t>
<t tx="ekr.20080516150804.1809">def _Num(self, node):
    self._handle(node, [self.Number])

</t>
<t tx="ekr.20080516150804.1810">def _Str(self, node):
    self._handle(node, [self.String])

</t>
<t tx="ekr.20080516150804.1811">def _Continue(self, node):
    self._handle(node, ['continue'])

</t>
<t tx="ekr.20080516150804.1812">def _Dict(self, node):
    children = []
    children.append('{')
    if node.keys:
        for index, (key, value) in enumerate(zip(node.keys, node.values)):
            children.extend([key, ':', value])
            if index &lt; len(node.keys) - 1:
                children.append(',')
    children.append('}')
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1813">def _Ellipsis(self, node):
    self._handle(node, ['...'])

</t>
<t tx="ekr.20080516150804.1814">def _Expr(self, node):
    self._handle(node, [node.value])

</t>
<t tx="ekr.20080516150804.1815">def _Exec(self, node):
    children = []
    children.extend(['exec', node.body])
    if node.globals:
        children.extend(['in', node.globals])
    if node.locals:
        children.extend([',', node.locals])
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1816">def _For(self, node):
    children = ['for', node.target, 'in', node.iter, ':']
    children.extend(node.body)
    if node.orelse:
        children.extend(['else', ':'])
        children.extend(node.orelse)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1817">def _ImportFrom(self, node):
    children = ['from']
    if node.level:
        children.append('.' * node.level)
    children.extend([node.module, 'import'])
    children.extend(self._child_nodes(node.names, ','))
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1818">def _alias(self, node):
    children = [node.name]
    if node.asname:
        children.extend(['as', node.asname])
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1819">def _FunctionDef(self, node):
    children = []
    try:
        decorators = getattr(node, 'decorator_list')
    except AttributeError:
        decorators = getattr(node, 'decorators', None)
    if decorators:
        for decorator in decorators:
            children.append('@')
            children.append(decorator)
    children.extend(['def', node.name, '(', node.args])
    children.extend([')', ':'])
    children.extend(node.body)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1820">def _arguments(self, node):
    children = []
    args = list(node.args)
    defaults = [None] * (len(args) - len(node.defaults)) + list(node.defaults)
    for index, (arg, default) in enumerate(zip(args, defaults)):
        if index &gt; 0:
            children.append(',')
        self._add_args_to_children(children, arg, default)
    if node.vararg is not None:
        if args:
            children.append(',')
        children.extend(['*', node.vararg])
    if node.kwarg is not None:
        if args or node.vararg is not None:
            children.append(',')
        children.extend(['**', node.kwarg])
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1821">def _add_args_to_children(self, children, arg, default):
    if isinstance(arg, (list, tuple)):
        self._add_tuple_parameter(children, arg)
    else:
        children.append(arg)
    if default is not None:
        children.append('=')
        children.append(default)

</t>
<t tx="ekr.20080516150804.1822">def _add_tuple_parameter(self, children, arg):
    children.append('(')
    for index, token in enumerate(arg):
        if index &gt; 0:
            children.append(',')
        if isinstance(token, (list, tuple)):
            self._add_tuple_parameter(children, token)
        else:
            children.append(token)
    children.append(')')

</t>
<t tx="ekr.20080516150804.1823">def _GeneratorExp(self, node):
    children = [node.elt]
    children.extend(node.generators)
    self._handle(node, children, eat_parens=True)

</t>
<t tx="ekr.20080516150804.1824">def _comprehension(self, node):
    children = ['for', node.target, 'in', node.iter]
    if node.ifs:
        for if_ in node.ifs:
            children.append('if')
            children.append(if_)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1825">def _Global(self, node):
    children = self._child_nodes(node.names, ',')
    children.insert(0, 'global')
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1826">def _If(self, node):
    if self._is_elif(node):
        children = ['elif']
    else:
        children = ['if']
    children.extend([node.test, ':'])
    children.extend(node.body)
    if node.orelse:
        if len(node.orelse) == 1 and self._is_elif(node.orelse[0]):
            pass
        else:
            children.extend(['else', ':'])
        children.extend(node.orelse)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1827">def _is_elif(self, node):
    if not isinstance(node, ast.If):
        return False
    offset = self.lines.get_line_start(node.lineno) + node.col_offset
    word = self.source[offset:offset + 4]
    # XXX: This is a bug; the offset does not point to the first
    alt_word = self.source[offset - 5:offset - 1]
    return 'elif' in (word, alt_word)

</t>
<t tx="ekr.20080516150804.1828">def _IfExp(self, node):
    return self._handle(node, [node.body, 'if', node.test,
                               'else', node.orelse])

</t>
<t tx="ekr.20080516150804.1829">def _Import(self, node):
    children = ['import']
    children.extend(self._child_nodes(node.names, ','))
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1830">def _keyword(self, node):
    self._handle(node, [node.arg, '=', node.value])

</t>
<t tx="ekr.20080516150804.1831">def _Lambda(self, node):
    self._handle(node, ['lambda', node.args, ':', node.body])

</t>
<t tx="ekr.20080516150804.1832">def _List(self, node):
    self._handle(node, ['['] + self._child_nodes(node.elts, ',') + [']'])

</t>
<t tx="ekr.20080516150804.1833">def _ListComp(self, node):
    children = ['[', node.elt]
    children.extend(node.generators)
    children.append(']')
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1834">def _Module(self, node):
    self._handle(node, list(node.body), eat_spaces=True)

</t>
<t tx="ekr.20080516150804.1835">def _Name(self, node):
    self._handle(node, [node.id])

</t>
<t tx="ekr.20080516150804.1836">def _Pass(self, node):
    self._handle(node, ['pass'])

</t>
<t tx="ekr.20080516150804.1837">def _Print(self, node):
    children = ['print']
    if node.dest:
        children.extend(['&gt;&gt;', node.dest])
        if node.values:
            children.append(',')
    children.extend(self._child_nodes(node.values, ','))
    if not node.nl:
        children.append(',')
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1838">def _Raise(self, node):
    children = ['raise']
    if node.type:
        children.append(node.type)
    if node.inst:
        children.append(',')
        children.append(node.inst)
    if node.tback:
        children.append(',')
        children.append(node.tback)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1839">def _Return(self, node):
    children = ['return']
    if node.value:
        children.append(node.value)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1840">def _Sliceobj(self, node):
    children = []
    for index, slice in enumerate(node.nodes):
        if index &gt; 0:
            children.append(':')
        if slice:
            children.append(slice)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1841">def _Index(self, node):
    self._handle(node, [node.value])

</t>
<t tx="ekr.20080516150804.1842">def _Subscript(self, node):
    self._handle(node, [node.value, '[', node.slice, ']'])

</t>
<t tx="ekr.20080516150804.1843">def _Slice(self, node):
    children = []
    if node.lower:
        children.append(node.lower)
    children.append(':')
    if node.upper:
        children.append(node.upper)
    if node.step:
        children.append(':')
        children.append(node.step)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1844">def _TryFinally(self, node):
    children = []
    if len(node.body) != 1 or not isinstance(node.body[0], ast.TryExcept):
        children.extend(['try', ':'])
    children.extend(node.body)
    children.extend(['finally', ':'])
    children.extend(node.finalbody)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1845">def _TryExcept(self, node):
    children = ['try', ':']
    children.extend(node.body)
    children.extend(node.handlers)
    if node.orelse:
        children.extend(['else', ':'])
        children.extend(node.orelse)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1846">def _ExceptHandler(self, node):
    self._excepthandler(node)

</t>
<t tx="ekr.20080516150804.1847">def _excepthandler(self, node):
    children = ['except']
    if node.type:
        children.append(node.type)
    if node.name:
        children.extend([',', node.name])
    children.append(':')
    children.extend(node.body)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1848">def _Tuple(self, node):
    if node.elts:
        self._handle(node, self._child_nodes(node.elts, ','),
                     eat_parens=True)
    else:
        self._handle(node, ['(', ')'])

</t>
<t tx="ekr.20080516150804.1849">def _UnaryOp(self, node):
    children = self._get_op(node.op)
    children.append(node.operand)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1850">def _Yield(self, node):
    children = ['yield']
    if node.value:
        children.append(node.value)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1851">def _While(self, node):
    children = ['while', node.test, ':']
    children.extend(node.body)
    if node.orelse:
        children.extend(['else', ':'])
        children.extend(node.orelse)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1852">def _With(self, node):
    children = ['with', node.context_expr]
    if node.optional_vars:
        children.extend(['as', node.optional_vars])
    children.append(':')
    children.extend(node.body)
    self._handle(node, children)

</t>
<t tx="ekr.20080516150804.1853">def _child_nodes(self, nodes, separator):
    children = []
    for index, child in enumerate(nodes):
        children.append(child)
        if index &lt; len(nodes) - 1:
            children.append(separator)
    return children


</t>
<t tx="ekr.20080516150804.1854">class _Source(object):
    @others
    _string_pattern = None
    _number_pattern = None
    _not_equals_pattern = None
</t>
<t tx="ekr.20080516150804.1855">
def __init__(self, source):
    self.source = source
    self.offset = 0

</t>
<t tx="ekr.20080516150804.1856">def consume(self, token):
    try:
        while True:
            new_offset = self.source.index(token, self.offset)
            if self._good_token(token, new_offset):
                break
            else:
                self._skip_comment()
    except (ValueError, TypeError):
        raise MismatchedTokenError(
            'Token &lt;%s&gt; at %s cannot be matched' %
            (token, self._get_location()))
    self.offset = new_offset + len(token)
    return (new_offset, self.offset)

</t>
<t tx="ekr.20080516150804.1857">def consume_string(self, end=None):
    if _Source._string_pattern is None:
        original = codeanalyze.get_string_pattern()
        pattern = r'(%s)((\s|\\\n|#[^\n]*\n)*(%s))*' % \
                  (original, original)
        _Source._string_pattern = re.compile(pattern)
    repattern = _Source._string_pattern
    return self._consume_pattern(repattern, end)

</t>
<t tx="ekr.20080516150804.1858">def consume_number(self):
    if _Source._number_pattern is None:
        _Source._number_pattern = re.compile(
            self._get_number_pattern())
    repattern = _Source._number_pattern
    return self._consume_pattern(repattern)

</t>
<t tx="ekr.20080516150804.1859">def consume_not_equal(self):
    if _Source._not_equals_pattern is None:
        _Source._not_equals_pattern = re.compile(r'&lt;&gt;|!=')
    repattern = _Source._not_equals_pattern
    return self._consume_pattern(repattern)

</t>
<t tx="ekr.20080516150804.1860">def _good_token(self, token, offset, start=None):
    """Checks whether consumed token is in comments"""
    if start is None:
        start = self.offset
    try:
        comment_index = self.source.rindex('#', start, offset)
    except ValueError:
        return True
    try:
        new_line_index = self.source.rindex('\n', start, offset)
    except ValueError:
        return False
    return comment_index &lt; new_line_index

</t>
<t tx="ekr.20080516150804.1861">def _skip_comment(self):
    self.offset = self.source.index('\n', self.offset + 1)

</t>
<t tx="ekr.20080516150804.1862">def _get_location(self):
    lines = self.source[:self.offset].split('\n')
    return (len(lines), len(lines[-1]))

</t>
<t tx="ekr.20080516150804.1863">def _consume_pattern(self, repattern, end=None):
    while True:
        if end is None:
            end = len(self.source)
        match = repattern.search(self.source, self.offset, end)
        if self._good_token(match.group(), match.start()):
            break
        else:
            self._skip_comment()
    self.offset = match.end()
    return match.start(), match.end()

</t>
<t tx="ekr.20080516150804.1864">def till_token(self, token):
    new_offset = self.source.index(token, self.offset)
    return self.get(self.offset, new_offset)

</t>
<t tx="ekr.20080516150804.1865">def get(self, start, end):
    return self.source[start:end]

</t>
<t tx="ekr.20080516150804.1866">def rfind_token(self, token, start, end):
    index = start
    while True:
        try:
            index = self.source.rindex(token, start, end)
            if self._good_token(token, index, start=start):
                return index
            else:
                end = index
        except ValueError:
            return None

</t>
<t tx="ekr.20080516150804.1867">def from_offset(self, offset):
    return self.get(offset, self.offset)

</t>
<t tx="ekr.20080516150804.1868">def find_backwards(self, pattern, offset):
    return self.source.rindex(pattern, 0, offset)

</t>
<t tx="ekr.20080516150804.1869">def __getitem__(self, index):
    return self.source[index]

</t>
<t tx="ekr.20080516150804.1870">def __getslice__(self, i, j):
    return self.source[i:j]

</t>
<t tx="ekr.20080516150804.1871">def _get_number_pattern(self):
    # HACK: It is merely an approaximation and does the job
    integer = r'(0|0x)?[\da-fA-F]+[lL]?'
    return r'(%s(\.\d*)?|(\.\d+))([eE][-+]?\d*)?[jJ]?' % integer

</t>
<t tx="ekr.20080516150804.1872">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1873">import warnings

from rope.base import exceptions, pyobjects, pynames, taskhandle, evaluate, worder, codeanalyze
from rope.base.change import ChangeSet, ChangeContents, MoveResource
from rope.refactor import occurrences, sourceutils


</t>
<t tx="ekr.20080516150804.1874">class Rename(object):
    """A class for performing rename refactoring

    It can rename everything: classes, functions, modules, packages,
    methods, variables and keyword arguments.

    """
    @others
</t>
<t tx="ekr.20080516150804.1875">
def __init__(self, project, resource, offset=None):
    """If `offset` is None, the `resource` itself will be renamed"""
    self.project = project
    self.pycore = project.pycore
    self.resource = resource
    if offset is not None:
        self.old_name = worder.get_name_at(self.resource, offset)
        this_pymodule = self.pycore.resource_to_pyobject(self.resource)
        self.old_instance, self.old_pyname = \
            evaluate.get_primary_and_pyname_at(this_pymodule, offset)
        if self.old_pyname is None:
            raise exceptions.RefactoringError(
                'Rename refactoring should be performed'
                ' on resolvable python identifiers.')
    else:
        if not resource.is_folder() and resource.name == '__init__.py':
            resource = resource.parent
        dummy_pymodule = self.pycore.get_string_module('')
        self.old_instance = None
        self.old_pyname = pynames.ImportedModule(dummy_pymodule,
                                                 resource=resource)
        if resource.is_folder():
            self.old_name = resource.name
        else:
            self.old_name = resource.name[:-3]

</t>
<t tx="ekr.20080516150804.1876">def get_old_name(self):
    return self.old_name

</t>
<t tx="ekr.20080516150804.1877">def get_changes(self, new_name, in_file=None, in_hierarchy=False,
                unsure=None, docs=False, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get the changes needed for this refactoring

    Parameters:

    - `in_hierarchy`: when renaming a method this keyword forces
      to rename all matching methods in the hierarchy
    - `docs`: when `True` rename refactoring will rename
      occurrences in comments and strings where the name is
      visible.  Setting it will make renames faster, too.
    - `unsure`: decides what to do about unsure occurrences.
      If `None`, they are ignored.  Otherwise `unsure` is
      called with an instance of `occurrence.Occurrence` as
      parameter.  If it returns `True`, the occurrence is
      considered to be a match.
    - `resources` can be a list of `rope.base.resources.File`\s to
      apply this refactoring on.  If `None`, the restructuring
      will be applied to all python files.
    - `in_file`: this argument has been deprecated; use
      `resources` instead.

    """
    if unsure in (True, False):
        warnings.warn(
            'unsure parameter should be a function that returns '
            'True or False', DeprecationWarning, stacklevel=2)
        def unsure_func(value=unsure):
            return value
        unsure = unsure_func
    if in_file is not None:
        warnings.warn(
            '`in_file` argument has been deprecated; use `resources` '
            'instead. ', DeprecationWarning, stacklevel=2)
        if in_file:
            resources = [self.resource]
    if self._is_renaming_a_function_local_name():
        resources = [self.resource]
    if resources is None:
        resources = self.pycore.get_python_files()
    changes = ChangeSet('Renaming &lt;%s&gt; to &lt;%s&gt;' %
                        (self.old_name, new_name))
    finder = occurrences.create_finder(
        self.pycore, self.old_name, self.old_pyname, unsure=unsure,
        docs=docs, instance=self.old_instance,
        in_hierarchy=in_hierarchy and self.is_method())
    job_set = task_handle.create_jobset('Collecting Changes', len(resources))
    for file_ in resources:
        job_set.started_job(file_.path)
        new_content = rename_in_module(finder, new_name, resource=file_)
        if new_content is not None:
            changes.add_change(ChangeContents(file_, new_content))
        job_set.finished_job()
    if self._is_renaming_a_module():
        resource = self.old_pyname.get_object().get_resource()
        if self._is_allowed_to_move(resources, resource):
            self._rename_module(resource, new_name, changes)
    return changes

</t>
<t tx="ekr.20080516150804.1878">def _is_allowed_to_move(self, resources, resource):
    if resource.is_folder():
        try:
            return resource.get_child('__init__.py') in resources
        except exceptions.ResourceNotFoundError:
            return False
    else:
        return resource in resources

</t>
<t tx="ekr.20080516150804.1879">def _is_renaming_a_function_local_name(self):
    module, lineno = self.old_pyname.get_definition_location()
    if lineno is None:
        return False
    scope = module.get_scope().get_inner_scope_for_line(lineno)
    if isinstance(self.old_pyname, pynames.DefinedName) and \
       scope.get_kind() in ('Function', 'Class'):
        scope = scope.parent
    return scope.get_kind() == 'Function' and \
           self.old_pyname in scope.get_names().values() and \
           isinstance(self.old_pyname, pynames.AssignedName)

</t>
<t tx="ekr.20080516150804.1880">def _is_renaming_a_module(self):
    if isinstance(self.old_pyname.get_object(), pyobjects.AbstractModule):
        return True
    return False

</t>
<t tx="ekr.20080516150804.1881">def is_method(self):
    pyname = self.old_pyname
    return isinstance(pyname, pynames.DefinedName) and \
           isinstance(pyname.get_object(), pyobjects.PyFunction) and \
           isinstance(pyname.get_object().parent, pyobjects.PyClass)

</t>
<t tx="ekr.20080516150804.1882">def _rename_module(self, resource, new_name, changes):
    if not resource.is_folder():
        new_name = new_name + '.py'
    parent_path = resource.parent.path
    if parent_path == '':
        new_location = new_name
    else:
        new_location = parent_path + '/' + new_name
    changes.add_change(MoveResource(resource, new_location))


</t>
<t tx="ekr.20080516150804.1883">class ChangeOccurrences(object):
    """A class for changing the occurrences of a name in a scope

    This class replaces the occurrences of a name.  Note that it only
    changes the scope containing the offset passed to the constructor.
    What's more it does not have any side-effects.  That is for
    example changing occurrences of a module does not rename the
    module; it merely replaces the occurrences of that module in a
    scope with the given expression.  This class is useful for
    performing many custom refactorings.

    """
    @others
</t>
<t tx="ekr.20080516150804.1884">
def __init__(self, project, resource, offset):
    self.pycore = project.pycore
    self.resource = resource
    self.offset = offset
    self.old_name = worder.get_name_at(resource, offset)
    self.pymodule = self.pycore.resource_to_pyobject(self.resource)
    self.old_pyname = evaluate.get_pyname_at(self.pymodule, offset)

</t>
<t tx="ekr.20080516150804.1885">def get_old_name(self):
    word_finder = worder.Worder(self.resource.read())
    return word_finder.get_primary_at(self.offset)

</t>
<t tx="ekr.20080516150804.1886">def _get_scope_offset(self):
    lines = self.pymodule.lines
    scope = self.pymodule.get_scope().\
            get_inner_scope_for_line(lines.get_line_number(self.offset))
    start = lines.get_line_start(scope.get_start())
    end = lines.get_line_end(scope.get_end())
    return start, end

</t>
<t tx="ekr.20080516150804.1887">def get_changes(self, new_name, only_calls=False, reads=True, writes=True):
    changes = ChangeSet('Changing &lt;%s&gt; occurrences to &lt;%s&gt;' %
                        (self.old_name, new_name))
    scope_start, scope_end = self._get_scope_offset()
    finder = occurrences.create_finder(
        self.pycore, self.old_name, self.old_pyname,
        imports=False, only_calls=only_calls)
    new_contents = rename_in_module(
        finder, new_name, pymodule=self.pymodule, replace_primary=True,
        region=(scope_start, scope_end), reads=reads, writes=writes)
    if new_contents is not None:
        changes.add_change(ChangeContents(self.resource, new_contents))
    return changes


</t>
<t tx="ekr.20080516150804.1888">def rename_in_module(occurrences_finder, new_name, resource=None, pymodule=None,
                     replace_primary=False, region=None, reads=True, writes=True):
    """Returns the changed source or `None` if there is no changes"""
    if resource is not None:
        source_code = resource.read()
    else:
        source_code = pymodule.source_code
    change_collector = codeanalyze.ChangeCollector(source_code)
    for occurrence in occurrences_finder.find_occurrences(resource, pymodule):
        if replace_primary and occurrence.is_a_fixed_primary():
            continue
        if replace_primary:
            start, end = occurrence.get_primary_range()
        else:
            start, end = occurrence.get_word_range()
        if (not reads and not occurrence.is_written()) or \
           (not writes and occurrence.is_written()):
            continue
        if region is None or region[0] &lt;= start &lt; region[1]:
            change_collector.add_change(start, end, new_name)
    return change_collector.get_changed()
</t>
<t tx="ekr.20080516150804.1889">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1890">import warnings

from rope.base import change, taskhandle, builtins, ast, codeanalyze
from rope.refactor import patchedast, similarfinder, sourceutils
from rope.refactor.importutils import module_imports


</t>
<t tx="ekr.20080516150804.1891">class Restructure(object):
    """A class to perform python restructurings

    A restructuring transforms pieces of code matching `pattern` to
    `goal`.  In the `pattern` wildcards can appear.  Wildcards match
    some piece of code based on their kind and arguments that are
    passed to them through `args`.

    `args` is a dictionary of wildcard names to wildcard arguments.
    If the argument is a tuple, the first item of the tuple is
    considered to be the name of the wildcard to use; otherwise the
    "default" wildcard is used.  For getting the list arguments a
    wildcard supports, see the pydoc of the wildcard.  (see
    `rope.refactor.wildcard.DefaultWildcard` for the default
    wildcard.)

    `wildcards` is the list of wildcard types that can appear in
    `pattern`.  See `rope.refactor.wildcards`.  If a wildcard does not
    specify its kind (by using a tuple in args), the wildcard named
    "default" is used.  So there should be a wildcard with "default"
    name in `wildcards`.

    `imports` is the list of imports that changed modules should
    import.  Note that rope handles duplicate imports and does not add
    the import if it already appears.

    Example #1::

      pattern ${pyobject}.get_attribute(${name})
      goal ${pyobject}[${name}]
      args pyobject: instance=rope.base.pyobjects.PyObject

    Example #2::

      pattern ${name} in ${pyobject}.get_attributes()
      goal ${name} in {pyobject}
      args pyobject: instance=rope.base.pyobjects.PyObject

    Example #3::

      pattern ${pycore}.create_module(${project}.root, ${name})
      goal generate.create_module(${project}, ${name})

      imports
       from rope.contrib import generate

      args
       pycore: type=rope.base.pycore.PyCore
       project: type=rope.base.project.Project

    Example #4::

      pattern ${pow}(${param1}, ${param2})
      goal ${param1} ** ${param2}
      args pow: name=mod.pow, exact

    Example #5::

      pattern ${inst}.longtask(${p1}, ${p2})
      goal
       ${inst}.subtask1(${p1})
       ${inst}.subtask2(${p2})
      args
       inst: type=mod.A,unsure

    """
    @others
</t>
<t tx="ekr.20080516150804.1892">
def __init__(self, project, pattern, goal, args=None,
             imports=None, wildcards=None):
    """Construct a restructuring

    See class pydoc for more info about the arguments.

    """
    self.pycore = project.pycore
    self.pattern = pattern
    self.goal = goal
    self.args = args
    if self.args is None:
        self.args = {}
    self.imports = imports
    if self.imports is None:
        self.imports = []
    self.wildcards = wildcards
    self.template = similarfinder.CodeTemplate(self.goal)

</t>
<t tx="ekr.20080516150804.1893">def get_changes(self, checks=None, imports=None, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    """Get the changes needed by this restructuring

    `resources` can be a list of `rope.base.resources.File`\s to
    apply the restructuring on.  If `None`, the restructuring will
    be applied to all python files.

    `checks` argument has been deprecated.  Use the `args` argument
    of the constructor.  The usage of::

      strchecks = {'obj1.type': 'mod.A', 'obj2': 'mod.B',
                   'obj3.object': 'mod.C'}
      checks = restructuring.make_checks(strchecks)

    can be replaced with::

      args = {'obj1': 'type=mod.A', 'obj2': 'name=mod.B',
              'obj3': 'object=mod.C'}

    where obj1, obj2 and obj3 are wildcard names that appear
    in restructuring pattern.

    """
    if checks is not None:
        warnings.warn(
            'The use of checks parameter is deprecated; '
            'use the args parameter of the constructor instead.',
            DeprecationWarning, stacklevel=2)
        for name, value in checks.items():
            self.args[name] = similarfinder._pydefined_to_str(value)
    if imports is not None:
        warnings.warn(
            'The use of imports parameter is deprecated; '
            'use imports parameter of the constructor, instead.',
            DeprecationWarning, stacklevel=2)
        self.imports = imports
    changes = change.ChangeSet('Restructuring &lt;%s&gt; to &lt;%s&gt;' %
                               (self.pattern, self.goal))
    if resources is not None:
        files = [resource for resource in resources
                 if self.pycore.is_python_file(resource)]
    else:
        files = self.pycore.get_python_files()
    job_set = task_handle.create_jobset('Collecting Changes', len(files))
    for resource in files:
        job_set.started_job(resource.path)
        pymodule = self.pycore.resource_to_pyobject(resource)
        finder = similarfinder.SimilarFinder(pymodule,
                                             wildcards=self.wildcards)
        matches = list(finder.get_matches(self.pattern, self.args))
        computer = self._compute_changes(matches, pymodule)
        result = computer.get_changed()
        if result is not None:
            imported_source = self._add_imports(resource, result,
                                                self.imports)
            changes.add_change(change.ChangeContents(resource,
                                                     imported_source))
        job_set.finished_job()
    return changes

</t>
<t tx="ekr.20080516150804.1894">def _compute_changes(self, matches, pymodule):
    return _ChangeComputer(
        pymodule.source_code, pymodule.get_ast(),
        pymodule.lines, self.template, matches)

</t>
<t tx="ekr.20080516150804.1895">def _add_imports(self, resource, source, imports):
    if not imports:
        return source
    import_infos = self._get_import_infos(resource, imports)
    pymodule = self.pycore.get_string_module(source, resource)
    imports = module_imports.ModuleImports(self.pycore, pymodule)
    for import_info in import_infos:
        imports.add_import(import_info)
    return imports.get_changed_source()

</t>
<t tx="ekr.20080516150804.1896">def _get_import_infos(self, resource, imports):
    pymodule = self.pycore.get_string_module('\n'.join(imports),
                                             resource)
    imports = module_imports.ModuleImports(self.pycore, pymodule)
    return [imports.import_info
            for imports in imports.imports]

</t>
<t tx="ekr.20080516150804.1897">def make_checks(self, string_checks):
    """Convert str to str dicts to str to PyObject dicts

    This function is here to ease writing a UI.

    """
    checks = {}
    for key, value in string_checks.items():
        is_pyname = not key.endswith('.object') and \
                    not key.endswith('.type')
        evaluated = self._evaluate(value, is_pyname=is_pyname)
        if evaluated is not None:
            checks[key] = evaluated
    return checks

</t>
<t tx="ekr.20080516150804.1898">def _evaluate(self, code, is_pyname=True):
    attributes = code.split('.')
    pyname = None
    if attributes[0] in ('__builtin__', '__builtins__'):
        class _BuiltinsStub(object):
            def get_attribute(self, name):
                return builtins.builtins[name]
        pyobject = _BuiltinsStub()
    else:
        pyobject = self.pycore.get_module(attributes[0])
    for attribute in attributes[1:]:
        pyname = pyobject[attribute]
        if pyname is None:
            return None
        pyobject = pyname.get_object()
    return pyname if is_pyname else pyobject


</t>
<t tx="ekr.20080516150804.1899">def replace(code, pattern, goal):
    """used by other refactorings"""
    finder = similarfinder.RawSimilarFinder(code)
    matches = list(finder.get_matches(pattern))
    ast = patchedast.get_patched_ast(code)
    lines = codeanalyze.SourceLinesAdapter(code)
    template = similarfinder.CodeTemplate(goal)
    computer = _ChangeComputer(code, ast, lines, template, matches)
    result = computer.get_changed()
    if result is None:
        return code
    return result


</t>
<t tx="ekr.20080516150804.1900">class _ChangeComputer(object):
    @others
</t>
<t tx="ekr.20080516150804.1901">
def __init__(self, code, ast, lines, goal, matches):
    self.source = code
    self.goal = goal
    self.matches = matches
    self.ast = ast
    self.lines = lines
    self.matched_asts = {}
    self._nearest_roots = {}
    if self._is_expression():
        for match in self.matches:
            self.matched_asts[match.ast] = match

</t>
<t tx="ekr.20080516150804.1902">def get_changed(self):
    if self._is_expression():
        result = self._get_node_text(self.ast)
        if result == self.source:
            return None
        return result
    else:
        collector = codeanalyze.ChangeCollector(self.source)
        last_end = -1
        for match in self.matches:
            start, end = match.get_region()
            if start &lt; last_end:
                if not self._is_expression():
                    continue
            last_end = end
            replacement = self._get_matched_text(match)
            collector.add_change(start, end, replacement)
        return collector.get_changed()

</t>
<t tx="ekr.20080516150804.1903">def _is_expression(self):
    return self.matches and isinstance(self.matches[0],
                                       similarfinder.ExpressionMatch)

</t>
<t tx="ekr.20080516150804.1904">def _get_matched_text(self, match):
    mapping = {}
    for name in self.goal.get_names():
        node = match.get_ast(name)
        if node is None:
            raise similarfinder.BadNameInCheckError(
                'Unknown name &lt;%s&gt;' % name)
        force = self._is_expression() and match.ast == node
        mapping[name] = self._get_node_text(node, force)
    unindented = self.goal.substitute(mapping)
    return self._auto_indent(match.get_region()[0], unindented)

</t>
<t tx="ekr.20080516150804.1905">def _get_node_text(self, node, force=False):
    if not force and node in self.matched_asts:
        return self._get_matched_text(self.matched_asts[node])
    start, end = patchedast.node_region(node)
    main_text = self.source[start:end]
    collector = codeanalyze.ChangeCollector(main_text)
    for node in self._get_nearest_roots(node):
        sub_start, sub_end = patchedast.node_region(node)
        collector.add_change(sub_start - start, sub_end - start,
                             self._get_node_text(node))
    result = collector.get_changed()
    if result is None:
        return main_text
    return result

</t>
<t tx="ekr.20080516150804.1906">def _auto_indent(self, offset, text):
    lineno = self.lines.get_line_number(offset)
    indents = sourceutils.get_indents(self.lines, lineno)
    result = []
    for index, line in enumerate(text.splitlines(True)):
        if index != 0 and line.strip():
            result.append(' ' * indents)
        result.append(line)
    return ''.join(result)

</t>
<t tx="ekr.20080516150804.1907">def _get_nearest_roots(self, node):
    if node not in self._nearest_roots:
        result = []
        for child in ast.get_child_nodes(node):
            if child in self.matched_asts:
                result.append(child)
            else:
                result.extend(self._get_nearest_roots(child))
        self._nearest_roots[node] = result
    return self._nearest_roots[node]
</t>
<t tx="ekr.20080516150804.1908">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1909">"""This module can be used for finding similar code"""
import re

import rope.refactor.wildcards
from rope.base import codeanalyze, evaluate, exceptions, ast, builtins
from rope.refactor import (patchedast, sourceutils, occurrences,
                           wildcards, importutils)


</t>
<t tx="ekr.20080516150804.1910">class BadNameInCheckError(exceptions.RefactoringError):
    pass


</t>
<t tx="ekr.20080516150804.1911">class SimilarFinder(object):
    """`SimilarFinder` can be used to find similar pieces of code

    See the notes in the `rope.refactor.restructure` module for more
    info.

    """
    @others
</t>
<t tx="ekr.20080516150804.1912">
def __init__(self, pymodule, wildcards=None):
    """Construct a SimilarFinder"""
    self.source = pymodule.source_code
    self.raw_finder = RawSimilarFinder(
        pymodule.source_code, pymodule.get_ast(), self._does_match)
    self.pymodule = pymodule
    if wildcards is None:
        self.wildcards = {}
        for wildcard in [rope.refactor.wildcards.
                         DefaultWildcard(pymodule.pycore.project)]:
            self.wildcards[wildcard.get_name()] = wildcard
    else:
        self.wildcards = wildcards

</t>
<t tx="ekr.20080516150804.1913">def get_matches(self, code, args={}, start=0, end=None):
    self.args = args
    if end is None:
        end = len(self.source)
    skip_region = None
    if 'skip' in args.get('', {}):
        resource, region = args['']['skip']
        if resource == self.pymodule.get_resource():
            skip_region = region            
    return self.raw_finder.get_matches(code, start=start, end=end,
                                       skip=skip_region)

</t>
<t tx="ekr.20080516150804.1914">def get_match_regions(self, *args, **kwds):
    for match in self.get_matches(*args, **kwds):
        yield match.get_region()

</t>
<t tx="ekr.20080516150804.1915">def _does_match(self, node, name):
    arg = self.args.get(name, '')
    kind = 'default'
    if isinstance(arg, (tuple, list)):
        kind = arg[0]
        arg = arg[1]
    suspect = wildcards.Suspect(self.pymodule, node, name)
    return self.wildcards[kind].matches(suspect, arg)


</t>
<t tx="ekr.20080516150804.1916">class RawSimilarFinder(object):
    """A class for finding similar expressions and statements"""
    @others
</t>
<t tx="ekr.20080516150804.1917">
def __init__(self, source, node=None, does_match=None):
    if node is None:
        node = ast.parse(source)
    if does_match is None:
        self.does_match = self._simple_does_match
    else:
        self.does_match = does_match
    self._init_using_ast(node, source)

</t>
<t tx="ekr.20080516150804.1918">def _simple_does_match(self, node, name):
    return isinstance(node, (ast.expr, ast.Name))

</t>
<t tx="ekr.20080516150804.1919">def _init_using_ast(self, node, source):
    self.source = source
    self._matched_asts = {}
    if not hasattr(node, 'sorted_children'):
        self.ast = patchedast.patch_ast(node, source)

</t>
<t tx="ekr.20080516150804.1920">def get_matches(self, code, start=0, end=None, skip=None):
    """Search for `code` in source and return a list of `Match`\es

    `code` can contain wildcards.  ``${name}`` matches normal
    names and ``${?name} can match any expression.  You can use
    `Match.get_ast()` for getting the node that has matched a
    given pattern.

    """
    if end is None:
        end = len(self.source)
    for match in self._get_matched_asts(code):
        match_start, match_end = match.get_region()
        if start &lt;= match_start and match_end &lt;= end:
            if skip is not None and (skip[0] &lt; match_end and
                                     skip[1] &gt; match_start):
                continue                    
            yield match

</t>
<t tx="ekr.20080516150804.1921">def _get_matched_asts(self, code):
    if code not in self._matched_asts:
        wanted = self._create_pattern(code)
        matches = _ASTMatcher(self.ast, wanted,
                              self.does_match).find_matches()
        self._matched_asts[code] = matches
    return self._matched_asts[code]

</t>
<t tx="ekr.20080516150804.1922">def _create_pattern(self, expression):
    expression = self._replace_wildcards(expression)
    node = ast.parse(expression)
    # Getting Module.Stmt.nodes
    nodes = node.body
    if len(nodes) == 1 and isinstance(nodes[0], ast.Expr):
        # Getting Discard.expr
        wanted = nodes[0].value
    else:
        wanted = nodes
    return wanted

</t>
<t tx="ekr.20080516150804.1923">def _replace_wildcards(self, expression):
    ropevar = _RopeVariable()
    template = CodeTemplate(expression)
    mapping = {}
    for name in template.get_names():
        mapping[name] = ropevar.get_var(name)
    return template.substitute(mapping)


</t>
<t tx="ekr.20080516150804.1924">class _ASTMatcher(object):
    @others
</t>
<t tx="ekr.20080516150804.1925">
def __init__(self, body, pattern, does_match):
    """Searches the given pattern in the body AST.

    body is an AST node and pattern can be either an AST node or
    a list of ASTs nodes
    """
    self.body = body
    self.pattern = pattern
    self.matches = None
    self.ropevar = _RopeVariable()
    self.matches_callback = does_match

</t>
<t tx="ekr.20080516150804.1926">def find_matches(self):
    if self.matches is None:
        self.matches = []
        ast.call_for_nodes(self.body, self._check_node, recursive=True)
    return self.matches

</t>
<t tx="ekr.20080516150804.1927">def _check_node(self, node):
    if isinstance(self.pattern, list):
        self._check_statements(node)
    else:
        self._check_expression(node)

</t>
<t tx="ekr.20080516150804.1928">def _check_expression(self, node):
    mapping = {}
    if self._match_nodes(self.pattern, node, mapping):
        self.matches.append(ExpressionMatch(node, mapping))

</t>
<t tx="ekr.20080516150804.1929">def _check_statements(self, node):
    for child in ast.get_children(node):
        if isinstance(child, (list, tuple)):
            self.__check_stmt_list(child)

</t>
<t tx="ekr.20080516150804.1930">def __check_stmt_list(self, nodes):
    for index in range(len(nodes)):
        if len(nodes) - index &gt;= len(self.pattern):
            current_stmts = nodes[index:index + len(self.pattern)]
            mapping = {}
            if self._match_stmts(current_stmts, mapping):
                self.matches.append(StatementMatch(current_stmts, mapping))

</t>
<t tx="ekr.20080516150804.1931">def _match_nodes(self, expected, node, mapping):
    if isinstance(expected, ast.Name):
       if self.ropevar.is_var(expected.id):
           return self._match_wildcard(expected, node, mapping)
    if not isinstance(expected, ast.AST):
        return expected == node
    if expected.__class__ != node.__class__:
        return False

    children1 = self._get_children(expected)
    children2 = self._get_children(node)
    if len(children1) != len(children2):
        return False
    for child1, child2 in zip(children1, children2):
        if isinstance(child1, ast.AST):
            if not self._match_nodes(child1, child2, mapping):
                return False
        elif isinstance(child1, (list, tuple)):
            if not isinstance(child2, (list, tuple)) or \
               len(child1) != len(child2):
                return False
            for c1, c2 in zip(child1, child2):
                if not self._match_nodes(c1, c2, mapping):
                    return False
        else:
            if child1 != child2:
                return False
    return True

</t>
<t tx="ekr.20080516150804.1932">def _get_children(self, node):
    """Return not `ast.expr_context` children of `node`"""
    children = ast.get_children(node)
    return [child for child in children
            if not isinstance(child, ast.expr_context)]

</t>
<t tx="ekr.20080516150804.1933">def _match_stmts(self, current_stmts, mapping):
    if len(current_stmts) != len(self.pattern):
        return False
    for stmt, expected in zip(current_stmts, self.pattern):
        if not self._match_nodes(expected, stmt, mapping):
            return False
    return True

</t>
<t tx="ekr.20080516150804.1934">def _match_wildcard(self, node1, node2, mapping):
    name = self.ropevar.get_base(node1.id)
    if name not in mapping:
        if self.matches_callback(node2, name):
            mapping[name] = node2
            return True
        return False
    else:
        return self._match_nodes(mapping[name], node2, {})


</t>
<t tx="ekr.20080516150804.1935">class Match(object):
    @others
</t>
<t tx="ekr.20080516150804.1936">
def __init__(self, mapping):
    self.mapping = mapping

</t>
<t tx="ekr.20080516150804.1937">def get_region(self):
    """Returns match region"""

</t>
<t tx="ekr.20080516150804.1938">def get_ast(self, name):
    """Return the ast node that has matched rope variables"""
    return self.mapping.get(name, None)


</t>
<t tx="ekr.20080516150804.1939">class ExpressionMatch(Match):
    @others
</t>
<t tx="ekr.20080516150804.1940">
def __init__(self, ast, mapping):
    super(ExpressionMatch, self).__init__(mapping)
    self.ast = ast

</t>
<t tx="ekr.20080516150804.1941">def get_region(self):
    return self.ast.region


</t>
<t tx="ekr.20080516150804.1942">class StatementMatch(Match):
    @others
</t>
<t tx="ekr.20080516150804.1943">
def __init__(self, ast_list, mapping):
    super(StatementMatch, self).__init__(mapping)
    self.ast_list = ast_list

</t>
<t tx="ekr.20080516150804.1944">def get_region(self):
    return self.ast_list[0].region[0], self.ast_list[-1].region[1]


</t>
<t tx="ekr.20080516150804.1945">class CodeTemplate(object):
    @others
</t>
<t tx="ekr.20080516150804.1946">
def __init__(self, template):
    self.template = template
    self._find_names()

</t>
<t tx="ekr.20080516150804.1947">def _find_names(self):
    self.names = {}
    for match in CodeTemplate._get_pattern().finditer(self.template):
        if 'name' in match.groupdict() and \
           match.group('name') is not None:
            start, end = match.span('name')
            name = self.template[start + 2:end - 1]
            if name not in self.names:
                self.names[name] = []
            self.names[name].append((start, end))

</t>
<t tx="ekr.20080516150804.1948">def get_names(self):
    return self.names.keys()

</t>
<t tx="ekr.20080516150804.1949">def substitute(self, mapping):
    collector = codeanalyze.ChangeCollector(self.template)
    for name, occurrences in self.names.items():
        for region in occurrences:
            collector.add_change(region[0], region[1], mapping[name])
    result = collector.get_changed()
    if result is None:
        return self.template
    return result

</t>
<t tx="ekr.20080516150804.1950">_match_pattern = None

@classmethod
def _get_pattern(cls):
    if cls._match_pattern is None:
        pattern = codeanalyze.get_comment_pattern() + '|' + \
                  codeanalyze.get_string_pattern() + '|' + \
                  r'(?P&lt;name&gt;\$\{[^\s\$\}]*\})'
        cls._match_pattern = re.compile(pattern)
    return cls._match_pattern


</t>
<t tx="ekr.20080516150804.1951">class _RopeVariable(object):
    """Transform and identify rope inserted wildcards"""

    _normal_prefix = '__rope__variable_normal_'
    _any_prefix = '__rope__variable_any_'

    @others
</t>
<t tx="ekr.20080516150804.1952">def get_var(self, name):
    if name.startswith('?'):
        return self._get_any(name)
    else:
        return self._get_normal(name)

</t>
<t tx="ekr.20080516150804.1953">def is_var(self, name):
    return self._is_normal(name) or self._is_var(name)

</t>
<t tx="ekr.20080516150804.1954">def get_base(self, name):
    if self._is_normal(name):
        return name[len(self._normal_prefix):]
    if self._is_var(name):
        return '?' + name[len(self._any_prefix):]

</t>
<t tx="ekr.20080516150804.1955">def _get_normal(self, name):
    return self._normal_prefix + name

</t>
<t tx="ekr.20080516150804.1956">def _get_any(self, name):
    return self._any_prefix + name[1:]

</t>
<t tx="ekr.20080516150804.1957">def _is_normal(self, name):
    return name.startswith(self._normal_prefix)

</t>
<t tx="ekr.20080516150804.1958">def _is_var(self, name):
    return name.startswith(self._any_prefix)


</t>
<t tx="ekr.20080516150804.1959">def make_pattern(code, variables):
    variables = set(variables)
    collector = codeanalyze.ChangeCollector(code)
    def does_match(node, name):
        return isinstance(node, ast.Name) and node.id == name
    finder = RawSimilarFinder(code, does_match=does_match)
    for variable in variables:
        for match in finder.get_matches('${%s}' % variable):
            start, end = match.get_region()
            collector.add_change(start, end, '${%s}' % variable)
    result = collector.get_changed()
    return result if result is not None else code


</t>
<t tx="ekr.20080516150804.1960">def _pydefined_to_str(pydefined):
    address = []
    if isinstance(pydefined, (builtins.BuiltinClass, builtins.BuiltinFunction)):
        return '__builtins__.' + pydefined.get_name()
    else:
        while pydefined.parent is not None:
            address.insert(0, pydefined.get_name())
            pydefined = pydefined.parent
        module_name = importutils.get_module_name(pydefined.pycore,
                                                  pydefined.resource)
    return '.'.join(module_name.split('.') + address)
</t>
<t tx="ekr.20080516150804.1961">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1962">from rope.base import ast, codeanalyze


</t>
<t tx="ekr.20080516150804.1963">def get_indents(lines, lineno):
    return codeanalyze.count_line_indents(lines.get_line(lineno))


</t>
<t tx="ekr.20080516150804.1964">def find_minimum_indents(source_code):
    result = 80
    lines = source_code.split('\n')
    for line in lines:
        if line.strip() == '':
            continue
        result = min(result, codeanalyze.count_line_indents(line))
    return result


</t>
<t tx="ekr.20080516150804.1965">def indent_lines(source_code, amount):
    if amount == 0:
        return source_code
    lines = source_code.splitlines(True)
    result = []
    for l in lines:
        if l.strip() == '':
            result.append('\n')
            continue
        if amount &lt; 0:
            indents = codeanalyze.count_line_indents(l)
            result.append(max(0, indents + amount) * ' ' + l.lstrip())
        else:
            result.append(' ' * amount + l)
    return ''.join(result)


</t>
<t tx="ekr.20080516150804.1966">def fix_indentation(code, new_indents):
    """Change the indentation of `code` to `new_indents`"""
    min_indents = find_minimum_indents(code)
    return indent_lines(code, new_indents - min_indents)


</t>
<t tx="ekr.20080516150804.1967">def add_methods(pymodule, class_scope, methods_sources):
    source_code = pymodule.source_code
    lines = pymodule.lines
    insertion_line = class_scope.get_end()
    if class_scope.get_scopes():
        insertion_line = class_scope.get_scopes()[-1].get_end()
    insertion_offset = lines.get_line_end(insertion_line)
    methods = '\n\n' + '\n\n'.join(methods_sources)
    indented_methods = fix_indentation(
        methods, get_indents(lines, class_scope.get_start()) +
        get_indent(pymodule.pycore))
    result = []
    result.append(source_code[:insertion_offset])
    result.append(indented_methods)
    result.append(source_code[insertion_offset:])
    return ''.join(result)


</t>
<t tx="ekr.20080516150804.1968">def get_body(pyfunction):
    """Return unindented function body"""
    scope = pyfunction.get_scope()
    pymodule = pyfunction.get_module()
    start, end = get_body_region(pyfunction)
    return fix_indentation(pymodule.source_code[start:end], 0)


</t>
<t tx="ekr.20080516150804.1969">def get_body_region(defined):
    """Return the start and end offsets of function body"""
    scope = defined.get_scope()
    pymodule = defined.get_module()
    lines = pymodule.lines
    node = defined.get_ast()
    start_line = node.lineno
    if defined.get_doc() is None:
        start_line = node.body[0].lineno
    elif len(node.body) &gt; 1:
        start_line = node.body[1].lineno
    start = lines.get_line_start(start_line)
    scope_start = pymodule.logical_lines.logical_line_in(scope.start)
    if scope_start[1] &gt;= start_line:
        # a one-liner!
        # XXX: what if colon appears in a string
        start = pymodule.source_code.index(':', start) + 1
        while pymodule.source_code[start].isspace():
            start += 1
    end = min(lines.get_line_end(scope.end) + 1, len(pymodule.source_code))
    return start, end


</t>
<t tx="ekr.20080516150804.1970">def get_indent(pycore):
    project = pycore.project
    return project.prefs.get('indent_size', 4)
</t>
<t tx="ekr.20080516150804.1971">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1972">from rope.base import ast


</t>
<t tx="ekr.20080516150804.1973">def find_visible(node, lines):
    """Return the line which is visible from all `lines`"""
    root = ast_suite_tree(node)
    return find_visible_for_suite(root, lines)


</t>
<t tx="ekr.20080516150804.1974">def find_visible_for_suite(root, lines):
    if len(lines) == 1:
        return lines[0]
    line1 = lines[0]
    line2 = find_visible_for_suite(root, lines[1:])
    suite1 = root.find_suite(line1)
    suite2 = root.find_suite(line2)
    def valid(suite):
        return suite is not None and not suite.ignored
    if valid(suite1) and not valid(suite2):
        return line1
    if not valid(suite1) and valid(suite2):
        return line2
    if not valid(suite1) and not valid(suite2):
        return None
    while suite1 != suite2 and suite1.parent != suite2.parent:
        if suite1._get_level() &lt; suite2._get_level():
            line2 = suite2.get_start()
            suite2 = suite2.parent
        elif suite1._get_level() &gt; suite2._get_level():
            line1 = suite1.get_start()
            suite1 = suite1.parent
        else:
            line1 = suite1.get_start()
            line2 = suite2.get_start()
            suite1 = suite1.parent
            suite2 = suite2.parent
    if suite1 == suite2:
        return min(line1, line2)
    return min(suite1.get_start(), suite2.get_start())


</t>
<t tx="ekr.20080516150804.1975">def ast_suite_tree(node):
    if hasattr(node, 'lineno'):
        lineno = node.lineno
    else:
        lineno = 1
    return Suite(node.body, lineno)


</t>
<t tx="ekr.20080516150804.1976">class Suite(object):
    @others
</t>
<t tx="ekr.20080516150804.1977">
def __init__(self, child_nodes, lineno, parent=None, ignored=False):
    self.parent = parent
    self.lineno = lineno
    self.child_nodes = child_nodes
    self._children = None
    self.ignored = ignored

</t>
<t tx="ekr.20080516150804.1978">def get_start(self):
    if self.parent is None:
        if self.child_nodes:
            return self.local_start()
        else:
            return 1
    return self.lineno

</t>
<t tx="ekr.20080516150804.1979">def get_children(self):
    if self._children is None:
        walker = _SuiteWalker(self)
        for child in self.child_nodes:
            ast.walk(child, walker)
        self._children = walker.suites
    return self._children

</t>
<t tx="ekr.20080516150804.1980">def local_start(self):
    return self.child_nodes[0].lineno

</t>
<t tx="ekr.20080516150804.1981">def local_end(self):
    end = self.child_nodes[-1].lineno
    if self.get_children():
        end = max(end, self.get_children()[-1].local_end())
    return end

</t>
<t tx="ekr.20080516150804.1982">def find_suite(self, line):
    if line is None:
        return None
    for child in self.get_children():
        if child.local_start() &lt;= line &lt;= child.local_end():
            return child.find_suite(line)
    return self

</t>
<t tx="ekr.20080516150804.1983">def _get_level(self):
    if self.parent is None:
        return 0
    return self.parent._get_level() + 1


</t>
<t tx="ekr.20080516150804.1984">class _SuiteWalker(object):
    @others
</t>
<t tx="ekr.20080516150804.1985">
def __init__(self, suite):
    self.suite = suite
    self.suites = []

</t>
<t tx="ekr.20080516150804.1986">def _If(self, node):
    self._add_if_like_node(node)

</t>
<t tx="ekr.20080516150804.1987">def _For(self, node):
    self._add_if_like_node(node)

</t>
<t tx="ekr.20080516150804.1988">def _While(self, node):
    self._add_if_like_node(node)

</t>
<t tx="ekr.20080516150804.1989">def _With(self, node):
    self.suites.append(Suite(node.body, node.lineno, self.suite))

</t>
<t tx="ekr.20080516150804.1990">def _TryFinally(self, node):
    if len(node.finalbody) == 1 and \
       isinstance(node.body[0], ast.TryExcept):
        self._TryExcept(node.body[0])
    else:
        self.suites.append(Suite(node.body, node.lineno, self.suite))
    self.suites.append(Suite(node.finalbody, node.lineno, self.suite))

</t>
<t tx="ekr.20080516150804.1991">def _TryExcept(self, node):
    self.suites.append(Suite(node.body, node.lineno, self.suite))
    for handler in node.handlers:
        self.suites.append(Suite(handler.body, node.lineno, self.suite))
    if node.orelse:
        self.suites.append(Suite(node.orelse, node.lineno, self.suite))

</t>
<t tx="ekr.20080516150804.1992">def _add_if_like_node(self, node):
    self.suites.append(Suite(node.body, node.lineno, self.suite))
    if node.orelse:
        self.suites.append(Suite(node.orelse, node.lineno, self.suite))

</t>
<t tx="ekr.20080516150804.1993">def _FunctionDef(self, node):
    self.suites.append(Suite(node.body, node.lineno,
                             self.suite, ignored=True))

</t>
<t tx="ekr.20080516150804.1994">def _ClassDef(self, node):
    self.suites.append(Suite(node.body, node.lineno,
                             self.suite, ignored=True))
</t>
<t tx="ekr.20080516150804.1995">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.1996">import rope.refactor.importutils
from rope.base.change import ChangeSet, ChangeContents, MoveResource, CreateFolder


</t>
<t tx="ekr.20080516150804.1997">class ModuleToPackage(object):
    @others
</t>
<t tx="ekr.20080516150804.1998">
def __init__(self, project, resource):
    self.project = project
    self.pycore = project.pycore
    self.resource = resource

</t>
<t tx="ekr.20080516150804.1999">def get_changes(self):
    changes = ChangeSet('Transform &lt;%s&gt; module to package' %
                        self.resource.path)
    new_content = self._transform_relatives_to_absolute(self.resource)
    if new_content is not None:
        changes.add_change(ChangeContents(self.resource, new_content))
    parent = self.resource.parent
    name = self.resource.name[:-3]
    changes.add_change(CreateFolder(parent, name))
    parent_path = parent.path + '/'
    if not parent.path:
        parent_path = ''
    new_path = parent_path + '%s/__init__.py' % name
    if self.resource.project == self.project:
        changes.add_change(MoveResource(self.resource, new_path))
    return changes

</t>
<t tx="ekr.20080516150804.2000">def _transform_relatives_to_absolute(self, resource):
    pymodule = self.pycore.resource_to_pyobject(resource)
    import_tools = rope.refactor.importutils.ImportTools(self.pycore)
    return import_tools.relatives_to_absolutes(pymodule)
</t>
<t tx="ekr.20080516150804.2001">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2002">from rope.base import (change, taskhandle, evaluate,
                       exceptions, pyobjects, pynames, ast)
from rope.refactor import restructure, sourceutils, similarfinder, importutils


</t>
<t tx="ekr.20080516150804.2003">class UseFunction(object):
    """Try to use a function wherever possible"""
    @others
    _rope_result = '_rope__result'
    _rope_returned = '_rope__returned'


</t>
<t tx="ekr.20080516150804.2004">
def __init__(self, project, resource, offset):
    self.project = project
    self.offset = offset
    this_pymodule = project.pycore.resource_to_pyobject(resource)
    pyname = evaluate.get_pyname_at(this_pymodule, offset)
    if pyname is None:
        raise exceptions.RefactoringError('Unresolvable name selected')
    self.pyfunction = pyname.get_object()
    if not isinstance(self.pyfunction, pyobjects.PyFunction) or \
       not isinstance(self.pyfunction.parent, pyobjects.PyModule):
        raise exceptions.RefactoringError(
            'Use function works for global functions, only.')
    self.resource = self.pyfunction.get_module().get_resource()
    self._check_returns()

</t>
<t tx="ekr.20080516150804.2005">def _check_returns(self):
    node = self.pyfunction.get_ast()
    if _yield_count(node):
        raise exceptions.RefactoringError('Use function should not '
                                          'be used on generators.')
    returns = _return_count(node)
    if returns &gt; 1:
        raise exceptions.RefactoringError('usefunction: Function has more '
                                          'than one return statement.')
    if returns == 1 and not _returns_last(node):
        raise exceptions.RefactoringError('usefunction: return should '
                                          'be the last statement.')

</t>
<t tx="ekr.20080516150804.2006">def get_changes(self, resources=None,
                task_handle=taskhandle.NullTaskHandle()):
    if resources is None:
        resources = self.project.pycore.get_python_files()
    changes = change.ChangeSet('Using function &lt;%s&gt;' %
                               self.pyfunction.get_name())
    if self.resource in resources:
        newresources = list(resources)
        newresources.remove(self.resource)
    for c in self._restructure(newresources, task_handle).changes:
        changes.add_change(c)
    if self.resource in resources:
        for c in self._restructure([self.resource], task_handle,
                                   others=False).changes:
            changes.add_change(c)
    return changes

</t>
<t tx="ekr.20080516150804.2007">def get_function_name(self):
    return self.pyfunction.get_name()

</t>
<t tx="ekr.20080516150804.2008">def _restructure(self, resources, task_handle, others=True):
    body = self._get_body()
    pattern = self._make_pattern()
    goal = self._make_goal(import_=others)
    imports = None
    if others:
        imports = ['import %s' % self._module_name()]

    body_region = sourceutils.get_body_region(self.pyfunction)
    args_value = {'skip': (self.resource, body_region)}
    args = {'': args_value}

    restructuring = restructure.Restructure(
        self.project, pattern, goal, args=args, imports=imports)
    return restructuring.get_changes(resources=resources,
                                     task_handle=task_handle)

</t>
<t tx="ekr.20080516150804.2009">def _find_temps(self):
    return find_temps(self.project, self._get_body())

</t>
<t tx="ekr.20080516150804.2010">def _module_name(self):
    return importutils.get_module_name(self.project.pycore,
                                       self.resource)

</t>
<t tx="ekr.20080516150804.2011">def _make_pattern(self):
    params = self.pyfunction.get_param_names()
    body = self._get_body()
    body = restructure.replace(body, 'return', 'pass')
    wildcards = list(params)
    wildcards.extend(self._find_temps())
    if self._does_return():
        if self._is_expression():
            replacement = '${%s}' % self._rope_returned
        else:
            replacement = '%s = ${%s}' % (self._rope_result,
                                          self._rope_returned)
        body = restructure.replace(
            body, 'return ${%s}' % self._rope_returned,
            replacement)
        wildcards.append(self._rope_result)
    return similarfinder.make_pattern(body, wildcards)

</t>
<t tx="ekr.20080516150804.2012">def _get_body(self):
    return sourceutils.get_body(self.pyfunction)

</t>
<t tx="ekr.20080516150804.2013">def _make_goal(self, import_=False):
    params = self.pyfunction.get_param_names()
    function_name = self.pyfunction.get_name()
    if import_:
        function_name = self._module_name() + '.' + function_name
    goal = '%s(%s)' % (function_name,
                       ', ' .join(('${%s}' % p) for p in params))
    if self._does_return() and not self._is_expression():
        goal = '${%s} = %s' % (self._rope_result, goal)
    return goal

</t>
<t tx="ekr.20080516150804.2014">def _does_return(self):
    body = self._get_body()
    removed_return = restructure.replace(body, 'return ${result}', '')
    return removed_return != body

</t>
<t tx="ekr.20080516150804.2015">def _is_expression(self):
    return len(self.pyfunction.get_ast().body) == 1

</t>
<t tx="ekr.20080516150804.2016">def find_temps(project, code):
    code = 'def f():\n' + sourceutils.indent_lines(code, 4)
    pymodule = project.pycore.get_string_module(code)
    result = []
    function_scope = pymodule.get_scope().get_scopes()[0]
    for name, pyname in function_scope.get_names().items():
        if isinstance(pyname, pynames.AssignedName):
            result.append(name)
    return result


</t>
<t tx="ekr.20080516150804.2017">def _returns_last(node):
    return node.body and isinstance(node.body[-1], ast.Return)

</t>
<t tx="ekr.20080516150804.2018">def _yield_count(node):
    visitor = _ReturnOrYieldFinder()
    visitor.start_walking(node)
    return visitor.yields

</t>
<t tx="ekr.20080516150804.2019">def _return_count(node):
    visitor = _ReturnOrYieldFinder()
    visitor.start_walking(node)
    return visitor.returns

</t>
<t tx="ekr.20080516150804.2020">class _ReturnOrYieldFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.2021">
def __init__(self):
    self.returns = 0
    self.yields = 0

</t>
<t tx="ekr.20080516150804.2022">def _Return(self, node):
    self.returns += 1

</t>
<t tx="ekr.20080516150804.2023">def _Yield(self, node):
    self.yields += 1

</t>
<t tx="ekr.20080516150804.2024">def _FunctionDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.2025">def _ClassDef(self, node):
    pass

</t>
<t tx="ekr.20080516150804.2026">def start_walking(self, node):
    nodes = [node]
    if isinstance(node, ast.FunctionDef):
        nodes = ast.get_child_nodes(node)
    for child in nodes:
        ast.walk(child, self)
</t>
<t tx="ekr.20080516150804.2027">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2028">from rope.base import ast, evaluate, builtins, pyobjects
from rope.refactor import patchedast, occurrences


</t>
<t tx="ekr.20080516150804.2029">class Wildcard(object):
    @others
</t>
<t tx="ekr.20080516150804.2030">
def get_name(self):
    """Return the name of this wildcard"""

</t>
<t tx="ekr.20080516150804.2031">def matches(self, suspect, arg):
    """Return `True` if `suspect` matches this wildcard"""


</t>
<t tx="ekr.20080516150804.2032">class Suspect(object):
    @others
</t>
<t tx="ekr.20080516150804.2033">
def __init__(self, pymodule, node, name):
    self.name = name
    self.pymodule = pymodule
    self.node = node


</t>
<t tx="ekr.20080516150804.2034">class DefaultWildcard(object):
    """The default restructuring wildcard

    The argument passed to this wildcard is in the
    ``key1=value1,key2=value2,...`` format.  Possible keys are:

    * name - for checking the reference
    * type - for checking the type
    * object - for checking the object
    * instance - for checking types but similar to builtin isinstance
    * exact - matching only occurrences with the same name as the wildcard
    * unsure - matching unsure occurrences

    """
    @others
</t>
<t tx="ekr.20080516150804.2035">
def __init__(self, project):
    self.project = project

</t>
<t tx="ekr.20080516150804.2036">def get_name(self):
    return 'default'

</t>
<t tx="ekr.20080516150804.2037">def matches(self, suspect, arg=''):
    args = parse_arg(arg)

    if not self._check_exact(args, suspect):
        return False
    if not self._check_object(args, suspect):
        return False
    return True

</t>
<t tx="ekr.20080516150804.2038">def _check_object(self, args, suspect):
    kind = None
    expected = None
    unsure = args.get('unsure', False)
    for check in ['name', 'object', 'type', 'instance']:
        if check in args:
            kind = check
            expected = args[check]
        if expected is not None:
            checker = _CheckObject(self.project, expected,
                                   kind, unsure=unsure)
            return checker(suspect.pymodule, suspect.node)
    return True

</t>
<t tx="ekr.20080516150804.2039">def _check_exact(self, args, suspect):
    node = suspect.node
    if args.get('exact'):
        if not isinstance(node, ast.Name) or not node.id == suspect.name:
            return False
    else:
        if not isinstance(node, ast.expr):
            return False
    return True


</t>
<t tx="ekr.20080516150804.2040">def parse_arg(arg):
    if isinstance(arg, dict):
        return arg
    result = {}
    tokens = arg.split(',')
    for token in tokens:
        if '=' in token:
            parts = token.split('=', 1)
            result[parts[0].strip()] = parts[1].strip()
        else:
            result[token.strip()] = True
    return result


</t>
<t tx="ekr.20080516150804.2041">class _CheckObject(object):
    @others
</t>
<t tx="ekr.20080516150804.2042">
def __init__(self, project, expected, kind='object', unsure=False):
    self.project = project
    self.kind = kind
    self.unsure = unsure
    self.expected = self._evaluate(expected)

</t>
<t tx="ekr.20080516150804.2043">def __call__(self, pymodule, node):
    pyname = self._evaluate_node(pymodule, node)
    if pyname is None or self.expected is None:
        return self.unsure
    if self._unsure_pyname(pyname, unbound=self.kind=='name'):
        return True
    if self.kind == 'name':
        return self._same_pyname(self.expected, pyname)
    else:
        pyobject = pyname.get_object()
        if self.kind == 'object':
            objects = [pyobject]
        if self.kind == 'type':
            objects = [pyobject.get_type()]
        if self.kind == 'instance':
            objects = [pyobject]
            objects.extend(self._get_super_classes(pyobject))
            objects.extend(self._get_super_classes(pyobject.get_type()))
        for pyobject in objects:
            if self._same_pyobject(self.expected.get_object(), pyobject):
                return True
        return False

</t>
<t tx="ekr.20080516150804.2044">def _get_super_classes(self, pyobject):
    result = []
    if isinstance(pyobject, pyobjects.AbstractClass):
        for superclass in pyobject.get_superclasses():
            result.append(superclass)
            result.extend(self._get_super_classes(superclass))
    return result

</t>
<t tx="ekr.20080516150804.2045">def _same_pyobject(self, expected, pyobject):
    return expected == pyobject

</t>
<t tx="ekr.20080516150804.2046">def _same_pyname(self, expected, pyname):
    return occurrences.same_pyname(expected, pyname)

</t>
<t tx="ekr.20080516150804.2047">def _unsure_pyname(self, pyname, unbound=True):
    return self.unsure and occurrences.unsure_pyname(pyname, unbound)

</t>
<t tx="ekr.20080516150804.2048">def _split_name(self, name):
    parts = name.split('.')
    expression, kind = parts[0], parts[-1]
    if len(parts) == 1:
        kind = 'name'
    return expression, kind

</t>
<t tx="ekr.20080516150804.2049">def _evaluate_node(self, pymodule, node):
    scope = pymodule.get_scope().get_inner_scope_for_line(node.lineno)
    expression = node
    if isinstance(expression, ast.Name) and \
       isinstance(expression.ctx, ast.Store):
        start, end = patchedast.node_region(expression)
        text = pymodule.source_code[start:end]
        return evaluate.get_string_result(scope, text)
    else:
        return evaluate.get_statement_result(scope, expression)

</t>
<t tx="ekr.20080516150804.2050">def _evaluate(self, code):
    attributes = code.split('.')
    pyname = None
    if attributes[0] in ('__builtin__', '__builtins__'):
        class _BuiltinsStub(object):
            def get_attribute(self, name):
                return builtins.builtins[name]
            def __getitem__(self, name):
                return builtins.builtins[name]
            def __contains__(self, name):
                return name in builtins.builtins
        pyobject = _BuiltinsStub()
    else:
        pyobject = self.project.pycore.get_module(attributes[0])
    for attribute in attributes[1:]:
        pyname = pyobject[attribute]
        if pyname is None:
            return None
        pyobject = pyname.get_object()
    return pyname
</t>
<t tx="ekr.20080516150804.2051">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2052">"""rope refactor package

This package contains modules that perform python refactorings.
Refactoring classes perform refactorings in 4 steps:

1. Collect some data for performing the refactoring and use them
   to construct a refactoring class.  Like::

     renamer = Rename(project, resource, offset)

2. Some refactorings give you useful information about the
   refactoring after their construction.  Like::

     print(renamer.get_old_name())

3. Give the refactoring class more information about how to
   perform the refactoring and get the changes this refactoring is
   going to make.  This is done by calling `get_changes` method of the
   refactoring class.  Like::

     changes = renamer.get_changes(new_name)

4. You can commit the changes.  Like::

     project.do(changes)

These steps are like the steps IDEs usually do for performing a
refactoring.  These are the things an IDE does in each step:

1. Construct a refactoring object by giving it information like
   resource, offset and ... .  Some of the refactoring problems (like
   performing rename refactoring on language keywords) can be reported
   here.
2. Print some information about the refactoring and ask the user
   about the information that are necessary for completing the
   refactoring (like new name).
3. Call the `get_changes` by passing it information asked from
   the user (if necessary) and get and preview the changes returned by
   it.
4. perform the refactoring.

From ``0.5m5`` release the `get_changes()` method of some time-
consuming refactorings take an optional `rope.base.taskhandle.
TaskHandle` parameter.  You can use this object for stopping or
monitoring the progress of refactorings.

"""
from rope.refactor.importutils import ImportOrganizer
from rope.refactor.topackage import ModuleToPackage


__all__ = ['rename', 'move', 'inline', 'extract', 'restructure', 'topackage',
           'importutils', 'usefunction', 'change_signature',
           'encapsulate_field', 'introduce_factory', 'introduce_parameter',
           'localtofield', 'method_object', 'multiproject']
</t>
<t tx="ekr.20080516150804.2053"></t>
<t tx="ekr.20080516150804.2054">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2055">import os
import sys

from rope.base import pyobjects, exceptions
from rope.refactor.importutils import importinfo


</t>
<t tx="ekr.20080516150804.2056">class ImportInfoVisitor(object):
    @others
</t>
<t tx="ekr.20080516150804.2057">
def dispatch(self, import_):
    try:
        method_name = 'visit' + import_.import_info.__class__.__name__
        method = getattr(self, method_name)
        return method(import_, import_.import_info)
    except exceptions.ModuleNotFoundError:
        pass

</t>
<t tx="ekr.20080516150804.2058">def visitEmptyImport(self, import_stmt, import_info):
    pass

</t>
<t tx="ekr.20080516150804.2059">def visitNormalImport(self, import_stmt, import_info):
    pass

</t>
<t tx="ekr.20080516150804.2060">def visitFromImport(self, import_stmt, import_info):
    pass


</t>
<t tx="ekr.20080516150804.2061">class RelativeToAbsoluteVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2062">
def __init__(self, pycore, current_folder):
    self.to_be_absolute = []
    self.pycore = pycore
    self.folder = current_folder
    self.context = importinfo.ImportContext(pycore, current_folder)

</t>
<t tx="ekr.20080516150804.2063">def visitNormalImport(self, import_stmt, import_info):
    self.to_be_absolute.extend(self._get_relative_to_absolute_list(import_info))
    new_pairs = []
    for name, alias in import_info.names_and_aliases:
        resource = self.pycore.find_module(name, current_folder=self.folder)
        if resource is None:
            new_pairs.append((name, alias))
            continue
        absolute_name = importinfo.get_module_name(self.pycore, resource)
        new_pairs.append((absolute_name, alias))
    if not import_info._are_name_and_alias_lists_equal(
        new_pairs, import_info.names_and_aliases):
        import_stmt.import_info = importinfo.NormalImport(new_pairs)

</t>
<t tx="ekr.20080516150804.2064">def _get_relative_to_absolute_list(self, import_info):
    result = []
    for name, alias in import_info.names_and_aliases:
        if alias is not None:
            continue
        resource = self.pycore.find_module(name, current_folder=self.folder)
        if resource is None:
            continue
        absolute_name = importinfo.get_module_name(self.pycore, resource)
        if absolute_name != name:
            result.append((name, absolute_name))
    return result

</t>
<t tx="ekr.20080516150804.2065">def visitFromImport(self, import_stmt, import_info):
    resource = import_info.get_imported_resource(self.context)
    if resource is None:
        return None
    absolute_name = importinfo.get_module_name(self.pycore, resource)
    if import_info.module_name != absolute_name:
        import_stmt.import_info = importinfo.FromImport(
            absolute_name, 0, import_info.names_and_aliases)


</t>
<t tx="ekr.20080516150804.2066">class FilteringVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2067">
def __init__(self, pycore, folder, can_select):
    self.to_be_absolute = []
    self.pycore = pycore
    self.can_select = self._transform_can_select(can_select)
    self.context = importinfo.ImportContext(pycore, folder)

</t>
<t tx="ekr.20080516150804.2068">def _transform_can_select(self, can_select):
    def can_select_name_and_alias(name, alias):
        imported = name
        if alias is not None:
            imported = alias
        return can_select(imported)
    return can_select_name_and_alias

</t>
<t tx="ekr.20080516150804.2069">def visitNormalImport(self, import_stmt, import_info):
    new_pairs = []
    for name, alias in import_info.names_and_aliases:
        if self.can_select(name, alias):
            new_pairs.append((name, alias))
    return importinfo.NormalImport(new_pairs)

</t>
<t tx="ekr.20080516150804.2070">def visitFromImport(self, import_stmt, import_info):
    if _is_future(import_info):
        return import_info
    new_pairs = []
    if import_info.is_star_import():
        for name in import_info.get_imported_names(self.context):
            if self.can_select(name, None):
                new_pairs.append(import_info.names_and_aliases[0])
                break
    else:
        for name, alias in import_info.names_and_aliases:
            if self.can_select(name, alias):
                new_pairs.append((name, alias))
    return importinfo.FromImport(
        import_info.module_name, import_info.level, new_pairs)


</t>
<t tx="ekr.20080516150804.2071">class RemovingVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2072">
def __init__(self, pycore, folder, can_select):
    self.to_be_absolute = []
    self.pycore = pycore
    self.filtering = FilteringVisitor(pycore, folder, can_select)

</t>
<t tx="ekr.20080516150804.2073">def dispatch(self, import_):
    result = self.filtering.dispatch(import_)
    if result is not None:
        import_.import_info = result


</t>
<t tx="ekr.20080516150804.2074">class AddingVisitor(ImportInfoVisitor):
    """A class for adding imports

    Given a list of `ImportInfo`\s, it tries to add each import to the
    module and returns `True` and gives up when an import can be added
    to older ones.

    """
    @others
</t>
<t tx="ekr.20080516150804.2075">
def __init__(self, pycore, import_list):
    self.pycore = pycore
    self.import_list = import_list
    self.import_info = None

</t>
<t tx="ekr.20080516150804.2076">def dispatch(self, import_):
    for import_info in self.import_list:
        self.import_info = import_info
        if ImportInfoVisitor.dispatch(self, import_):
            return True

</t>
<t tx="ekr.20080516150804.2077"># TODO: Handle adding relative and absolute imports
def visitNormalImport(self, import_stmt, import_info):
    if not isinstance(self.import_info, import_info.__class__):
        return False
    # Adding ``import x`` and ``import x.y`` that results ``import x.y``
    if len(import_info.names_and_aliases) == \
       len(self.import_info.names_and_aliases) == 1:
        imported1 = import_info.names_and_aliases[0]
        imported2 = self.import_info.names_and_aliases[0]
        if imported1[1] == imported2[1] is None:
            if imported1[0].startswith(imported2[0] + '.'):
                return True
            if imported2[0].startswith(imported1[0] + '.'):
                import_stmt.import_info = self.import_info
                return True
    # Multiple imports using a single import statement is discouraged
    # so we won't bother adding them.
    if self.import_info._are_name_and_alias_lists_equal(
        import_info.names_and_aliases, self.import_info.names_and_aliases):
        return True

</t>
<t tx="ekr.20080516150804.2078">def visitFromImport(self, import_stmt, import_info):
    if isinstance(self.import_info, import_info.__class__) and \
       import_info.module_name == self.import_info.module_name and \
       import_info.level == self.import_info.level:
        if import_info.is_star_import():
            return True
        if self.import_info.is_star_import():
            import_stmt.import_info = self.import_info
            return True
        new_pairs = list(import_info.names_and_aliases)
        for pair in self.import_info.names_and_aliases:
            if pair not in new_pairs:
                new_pairs.append(pair)
        import_stmt.import_info = importinfo.FromImport(
            import_info.module_name, import_info.level, new_pairs)
        return True


</t>
<t tx="ekr.20080516150804.2079">class ExpandStarsVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2080">
def __init__(self, pycore, folder, can_select):
    self.pycore = pycore
    self.filtering = FilteringVisitor(pycore, folder, can_select)
    self.context = importinfo.ImportContext(pycore, folder)

</t>
<t tx="ekr.20080516150804.2081">def visitNormalImport(self, import_stmt, import_info):
    self.filtering.dispatch(import_stmt)

</t>
<t tx="ekr.20080516150804.2082">def visitFromImport(self, import_stmt, import_info):
    if import_info.is_star_import():
        new_pairs = []
        for name in import_info.get_imported_names(self.context):
            new_pairs.append((name, None))
        new_import = importinfo.FromImport(
            import_info.module_name, import_info.level, new_pairs)
        import_stmt.import_info = \
            self.filtering.visitFromImport(None, new_import)
    else:
        self.filtering.dispatch(import_stmt)


</t>
<t tx="ekr.20080516150804.2083">class SelfImportVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2084">
def __init__(self, pycore, current_folder, resource):
    self.pycore = pycore
    self.folder = current_folder
    self.resource = resource
    self.to_be_fixed = set()
    self.to_be_renamed = set()
    self.context = importinfo.ImportContext(pycore, current_folder)

</t>
<t tx="ekr.20080516150804.2085">def visitNormalImport(self, import_stmt, import_info):
    new_pairs = []
    for name, alias in import_info.names_and_aliases:
        resource = self.pycore.find_module(name, current_folder=self.folder)
        if resource is not None and resource == self.resource:
            imported = name
            if alias is not None:
                imported = alias
            self.to_be_fixed.add(imported)
        else:
            new_pairs.append((name, alias))
    if not import_info._are_name_and_alias_lists_equal(
        new_pairs, import_info.names_and_aliases):
        import_stmt.import_info = importinfo.NormalImport(new_pairs)

</t>
<t tx="ekr.20080516150804.2086">def visitFromImport(self, import_stmt, import_info):
    resource = import_info.get_imported_resource(self.context)
    if resource is None:
        return
    if resource == self.resource:
        self._importing_names_from_self(import_info, import_stmt)
        return
    pymodule = self.pycore.resource_to_pyobject(resource)
    new_pairs = []
    for name, alias in import_info.names_and_aliases:
        try:
            result = pymodule[name].get_object()
            if isinstance(result, pyobjects.PyModule) and \
               result.get_resource() == self.resource:
                imported = name
                if alias is not None:
                    imported = alias
                self.to_be_fixed.add(imported)
            else:
                new_pairs.append((name, alias))
        except exceptions.AttributeNotFoundError:
            new_pairs.append((name, alias))
    if not import_info._are_name_and_alias_lists_equal(
        new_pairs, import_info.names_and_aliases):
        import_stmt.import_info = importinfo.FromImport(
            import_info.module_name, import_info.level, new_pairs)

</t>
<t tx="ekr.20080516150804.2087">def _importing_names_from_self(self, import_info, import_stmt):
    if not import_info.is_star_import():
        for name, alias in import_info.names_and_aliases:
            if alias is not None:
                self.to_be_renamed.add((alias, name))
    import_stmt.empty_import()


</t>
<t tx="ekr.20080516150804.2088">class SortingVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2089">
def __init__(self, pycore, current_folder):
    self.pycore = pycore
    self.folder = current_folder
    self.standard = set()
    self.third_party = set()
    self.in_project = set()
    self.future = set()
    self.context = importinfo.ImportContext(pycore, current_folder)

</t>
<t tx="ekr.20080516150804.2090">def visitNormalImport(self, import_stmt, import_info):
    if import_info.names_and_aliases:
        name, alias = import_info.names_and_aliases[0]
        resource = self.pycore.find_module(
            name, current_folder=self.folder)
        self._check_imported_resource(import_stmt, resource, name)

</t>
<t tx="ekr.20080516150804.2091">def visitFromImport(self, import_stmt, import_info):
    resource = import_info.get_imported_resource(self.context)
    self._check_imported_resource(import_stmt, resource,
                                  import_info.module_name)

</t>
<t tx="ekr.20080516150804.2092">def _check_imported_resource(self, import_stmt, resource, imported_name):
    info = import_stmt.import_info
    if resource is not None and resource.project == self.pycore.project:
        self.in_project.add(import_stmt)
    elif _is_future(info):
        self.future.add(import_stmt)
    elif imported_name.split('.')[0] in SortingVisitor.standard_modules():
        self.standard.add(import_stmt)
    else:
        self.third_party.add(import_stmt)

</t>
<t tx="ekr.20080516150804.2093">@classmethod
def standard_modules(cls):
    if not hasattr(cls, '_standard_modules'):
        result = set(sys.builtin_module_names)
        if os.name != 'nt':
            lib_path = os.path.join(
                sys.prefix, 'lib', 'python' + sys.version[:3])
        else:
            lib_path = os.path.join(sys.prefix, 'lib%s' % os.sep)
        dynload_path = os.path.join(lib_path, 'lib-dynload')
        if os.path.exists(lib_path):
            for name in os.listdir(lib_path):
                path = os.path.join(lib_path, name)
                if os.path.isdir(path):
                    if '-' not in name:
                        result.add(name)
                else:
                    if name.endswith('.py'):
                        result.add(name[:-3])
        if os.path.exists(dynload_path):
            for name in os.listdir(dynload_path):
                path = os.path.join(dynload_path, name)
                if os.path.isfile(path):
                    if name.endswith('.so'):
                        result.add(name[:-3])
        cls._standard_modules = result
    return cls._standard_modules


</t>
<t tx="ekr.20080516150804.2094">class LongImportVisitor(ImportInfoVisitor):
    @others
</t>
<t tx="ekr.20080516150804.2095">
def __init__(self, current_folder, pycore, maxdots, maxlength):
    self.maxdots = maxdots
    self.maxlength = maxlength
    self.to_be_renamed = set()
    self.current_folder = current_folder
    self.pycore = pycore
    self.new_imports = []

</t>
<t tx="ekr.20080516150804.2096">def visitNormalImport(self, import_stmt, import_info):
    new_pairs = []
    for name, alias in import_info.names_and_aliases:
        if alias is None and self._is_long(name):
            self.to_be_renamed.add(name)
            last_dot = name.rindex('.')
            from_ = name[:last_dot]
            imported = name[last_dot + 1:]
            self.new_imports.append(
                importinfo.FromImport(from_, 0, ((imported, None), )))

</t>
<t tx="ekr.20080516150804.2097">def _is_long(self, name):
    return name.count('.') &gt; self.maxdots or \
           ('.' in name and len(name) &gt; self.maxlength)


</t>
<t tx="ekr.20080516150804.2098">def _is_future(info):
    return isinstance(info, importinfo.FromImport) and \
           info.module_name == '__future__'
</t>
<t tx="ekr.20080516150804.2099">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2100">class ImportStatement(object):
    """Represent an import in a module

    `readonly` attribute controls whether this import can be changed
    by import actions or not.

    """
    @others
</t>
<t tx="ekr.20080516150804.2101">
def __init__(self, import_info, start_line, end_line,
             main_statement=None, blank_lines=0):
    self.start_line = start_line
    self.end_line = end_line
    self.readonly = False
    self.main_statement = main_statement
    self._import_info = None
    self.import_info = import_info
    self._is_changed = False
    self.new_start = None
    self.blank_lines = blank_lines

</t>
<t tx="ekr.20080516150804.2102">def _get_import_info(self):
    return self._import_info

</t>
<t tx="ekr.20080516150804.2103">def _set_import_info(self, new_import):
    if not self.readonly and \
       new_import is not None and not new_import == self._import_info:
        self._is_changed = True
        self._import_info = new_import

</t>
<t tx="ekr.20080516150804.2104">import_info = property(_get_import_info, _set_import_info)

def get_import_statement(self):
    if self._is_changed or self.main_statement is None:
        return self.import_info.get_import_statement()
    else:
        return self.main_statement

</t>
<t tx="ekr.20080516150804.2105">def empty_import(self):
    self.import_info = ImportInfo.get_empty_import()

</t>
<t tx="ekr.20080516150804.2106">def move(self, lineno, blank_lines=0):
    self.new_start = lineno
    self.blank_lines = blank_lines

</t>
<t tx="ekr.20080516150804.2107">def get_old_location(self):
    return self.start_line, self.end_line

</t>
<t tx="ekr.20080516150804.2108">def get_new_start(self):
    return self.new_start

</t>
<t tx="ekr.20080516150804.2109">def is_changed(self):
    return self._is_changed or (self.new_start is not None or
                                self.new_start != self.start_line)

</t>
<t tx="ekr.20080516150804.2110">def accept(self, visitor):
    return visitor.dispatch(self)


</t>
<t tx="ekr.20080516150804.2111">class ImportInfo(object):
    @others
</t>
<t tx="ekr.20080516150804.2112">
def get_imported_primaries(self, context):
    pass

</t>
<t tx="ekr.20080516150804.2113">def get_imported_names(self, context):
    return [primary.split('.')[0]
            for primary in self.get_imported_primaries(context)]

</t>
<t tx="ekr.20080516150804.2114">def get_import_statement(self):
    pass

</t>
<t tx="ekr.20080516150804.2115">def is_empty(self):
    pass

</t>
<t tx="ekr.20080516150804.2116">def __hash__(self):
    return hash(self.get_import_statement())

</t>
<t tx="ekr.20080516150804.2117">def _are_name_and_alias_lists_equal(self, list1, list2):
    if len(list1) != len(list2):
        return False
    for pair1, pair2 in zip(list1, list2):
        if pair1 != pair2:
            return False
    return True

</t>
<t tx="ekr.20080516150804.2118">def __eq__(self, obj):
    return isinstance(obj, self.__class__) and \
           self.get_import_statement() == obj.get_import_statement()

</t>
<t tx="ekr.20080516150804.2119">@staticmethod
def get_empty_import():
    return EmptyImport()


</t>
<t tx="ekr.20080516150804.2120">class NormalImport(ImportInfo):
    @others
</t>
<t tx="ekr.20080516150804.2121">
def __init__(self, names_and_aliases):
    self.names_and_aliases = names_and_aliases

</t>
<t tx="ekr.20080516150804.2122">def get_imported_primaries(self, context):
    result = []
    for name, alias in self.names_and_aliases:
        if alias:
            result.append(alias)
        else:
            result.append(name)
    return result

</t>
<t tx="ekr.20080516150804.2123">def get_import_statement(self):
    result = 'import '
    for name, alias in self.names_and_aliases:
        result += name
        if alias:
            result += ' as ' + alias
        result += ', '
    return result[:-2]

</t>
<t tx="ekr.20080516150804.2124">def is_empty(self):
    return len(self.names_and_aliases) == 0


</t>
<t tx="ekr.20080516150804.2125">class FromImport(ImportInfo):
    @others
</t>
<t tx="ekr.20080516150804.2126">
def __init__(self, module_name, level, names_and_aliases):
    self.module_name = module_name
    self.level = level
    self.names_and_aliases = names_and_aliases

</t>
<t tx="ekr.20080516150804.2127">def get_imported_primaries(self, context):
    if self.names_and_aliases[0][0] == '*':
        module = self.get_imported_module(context)
        return [name for name in module
                if not name.startswith('_')]
    result = []
    for name, alias in self.names_and_aliases:
        if alias:
            result.append(alias)
        else:
            result.append(name)
    return result

</t>
<t tx="ekr.20080516150804.2128">def get_imported_resource(self, context):
    """Get the imported resource

    Returns `None` if module was not found.
    """
    if self.level == 0:
        return context.pycore.find_module(
            self.module_name, current_folder=context.folder)
    else:
        return context.pycore.find_relative_module(
            self.module_name, context.folder, self.level)

</t>
<t tx="ekr.20080516150804.2129">def get_imported_module(self, context):
    """Get the imported `PyModule`

    Raises `rope.base.exceptions.ModuleNotFoundError` if module
    could not be found.
    """
    if self.level == 0:
        return context.pycore.get_module(
            self.module_name, context.folder)
    else:
        return context.pycore.get_relative_module(
            self.module_name, context.folder, self.level)

</t>
<t tx="ekr.20080516150804.2130">def get_import_statement(self):
    result = 'from ' + '.' * self.level + self.module_name + ' import '
    for name, alias in self.names_and_aliases:
        result += name
        if alias:
            result += ' as ' + alias
        result += ', '
    return result[:-2]

</t>
<t tx="ekr.20080516150804.2131">def is_empty(self):
    return len(self.names_and_aliases) == 0

</t>
<t tx="ekr.20080516150804.2132">def is_star_import(self):
    return len(self.names_and_aliases) &gt; 0 and \
           self.names_and_aliases[0][0] == '*'


</t>
<t tx="ekr.20080516150804.2133">class EmptyImport(ImportInfo):

    names_and_aliases = []

    @others
</t>
<t tx="ekr.20080516150804.2134">def is_empty(self):
    return True

</t>
<t tx="ekr.20080516150804.2135">def get_imported_primaries(self, context):
    return []


</t>
<t tx="ekr.20080516150804.2136">def get_module_name(pycore, resource):
    if resource.is_folder():
        module_name = resource.name
        source_folder = resource.parent
    elif resource.name == '__init__.py':
        module_name = resource.parent.name
        source_folder = resource.parent.parent
    else:
        module_name = resource.name[:-3]
        source_folder = resource.parent

    source_folders = pycore.get_source_folders()
    source_folders.extend(pycore.get_python_path_folders())
    while source_folder != source_folder.parent and \
          source_folder not in source_folders:
        module_name = source_folder.name + '.' + module_name
        source_folder = source_folder.parent
    return module_name


</t>
<t tx="ekr.20080516150804.2137">class ImportContext(object):
    @others
</t>
<t tx="ekr.20080516150804.2138">
def __init__(self, pycore, folder):
    self.pycore = pycore
    self.folder = folder
</t>
<t tx="ekr.20080516150804.2139">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2140">import rope.base.pynames
from rope.base import ast, utils
from rope.refactor.importutils import importinfo
from rope.refactor.importutils import actions


</t>
<t tx="ekr.20080516150804.2141">class ModuleImports(object):
    @others
</t>
<t tx="ekr.20080516150804.2142">
def __init__(self, pycore, pymodule, import_filter=None):
    self.pycore = pycore
    self.pymodule = pymodule
    self.separating_lines = 0
    self.filter = import_filter

</t>
<t tx="ekr.20080516150804.2143">@property
@utils.cacheit
def imports(self):
    finder = _GlobalImportFinder(self.pymodule, self.pycore)
    result = finder.find_import_statements()
    self.separating_lines = finder.get_separating_line_count()
    if self.filter is not None:
        for import_stmt in result:
            if not self.filter(import_stmt):
                import_stmt.readonly = True
    return result

</t>
<t tx="ekr.20080516150804.2144">def _get_unbound_names(self, defined_pyobject):
    visitor = _GlobalUnboundNameFinder(self.pymodule, defined_pyobject)
    ast.walk(self.pymodule.get_ast(), visitor)
    return visitor.unbound

</t>
<t tx="ekr.20080516150804.2145">def remove_unused_imports(self):
    can_select = _OneTimeSelector(self._get_unbound_names(self.pymodule))
    visitor = actions.RemovingVisitor(
        self.pycore, self._current_folder(), can_select)
    for import_statement in self.imports:
        import_statement.accept(visitor)

</t>
<t tx="ekr.20080516150804.2146">def get_used_imports(self, defined_pyobject):
    result = []
    can_select = _OneTimeSelector(self._get_unbound_names(defined_pyobject))
    visitor = actions.FilteringVisitor(
        self.pycore, self._current_folder(), can_select)
    for import_statement in self.imports:
        new_import = import_statement.accept(visitor)
        if new_import is not None and not new_import.is_empty():
            result.append(new_import)
    return result

</t>
<t tx="ekr.20080516150804.2147">def get_changed_source(self):
    imports = self.imports
    after_removing = self._remove_imports(imports)
    imports = [stmt for stmt in imports
               if not stmt.import_info.is_empty()]

    first_non_blank = self._first_non_blank_line(after_removing, 0)
    first_import = self._first_import_line() - 1
    result = []
    # Writing module docs
    result.extend(after_removing[first_non_blank:first_import])
    # Writing imports
    sorted_imports = sorted(imports, self._compare_import_locations)
    for stmt in sorted_imports:
        start = self._get_import_location(stmt)
        if stmt != sorted_imports[0]:
            result.append('\n' * stmt.blank_lines)
        result.append(stmt.get_import_statement() + '\n')
    if sorted_imports and first_non_blank &lt; len(after_removing):
        result.append('\n' * self.separating_lines)

    # Writing the body
    first_after_imports = self._first_non_blank_line(after_removing,
                                                     first_import)
    result.extend(after_removing[first_after_imports:])
    return ''.join(result)

</t>
<t tx="ekr.20080516150804.2148">def _get_import_location(self, stmt):
    start = stmt.get_new_start()
    if start is None:
        start = stmt.get_old_location()[0]
    return start

</t>
<t tx="ekr.20080516150804.2149">def _compare_import_locations(self, stmt1, stmt2):
    def get_location(stmt):
        if stmt.get_new_start() is not None:
            return stmt.get_new_start()
        else:
            return stmt.get_old_location()[0]
    return cmp(get_location(stmt1), get_location(stmt2))

</t>
<t tx="ekr.20080516150804.2150">def _remove_imports(self, imports):
    lines = self.pymodule.source_code.splitlines(True)
    after_removing = []
    last_index = 0
    for stmt in imports:
        start, end = stmt.get_old_location()
        after_removing.extend(lines[last_index:start - 1])
        last_index = end - 1
        for i in range(start, end):
            after_removing.append('')
    after_removing.extend(lines[last_index:])
    return after_removing

</t>
<t tx="ekr.20080516150804.2151">def _first_non_blank_line(self, lines, lineno):
    result = lineno
    for line in lines[lineno:]:
        if line.strip() == '':
            result += 1
        else:
            break
    return result

</t>
<t tx="ekr.20080516150804.2152">def add_import(self, import_info):
    visitor = actions.AddingVisitor(self.pycore, [import_info])
    for import_statement in self.imports:
        if import_statement.accept(visitor):
            break
    else:
        lineno = self._get_new_import_lineno()
        blanks = self._get_new_import_blanks()
        self.imports.append(importinfo.ImportStatement(
                            import_info, lineno, lineno,
                            blank_lines=blanks))

</t>
<t tx="ekr.20080516150804.2153">def _get_new_import_blanks(self):
    return 0

</t>
<t tx="ekr.20080516150804.2154">def _get_new_import_lineno(self):
    if self.imports:
        return self.imports[-1].end_line
    return 1

</t>
<t tx="ekr.20080516150804.2155">def filter_names(self, can_select):
    visitor = actions.RemovingVisitor(
        self.pycore, self._current_folder(), can_select)
    for import_statement in self.imports:
        import_statement.accept(visitor)

</t>
<t tx="ekr.20080516150804.2156">def expand_stars(self):
    can_select = _OneTimeSelector(self._get_unbound_names(self.pymodule))
    visitor = actions.ExpandStarsVisitor(
        self.pycore, self._current_folder(), can_select)
    for import_statement in self.imports:
        import_statement.accept(visitor)

</t>
<t tx="ekr.20080516150804.2157">def remove_duplicates(self):
    added_imports = []
    for import_stmt in self.imports:
        visitor = actions.AddingVisitor(self.pycore,
                                        [import_stmt.import_info])
        for added_import in added_imports:
            if added_import.accept(visitor):
                import_stmt.empty_import()
        else:
            added_imports.append(import_stmt)

</t>
<t tx="ekr.20080516150804.2158">def get_relative_to_absolute_list(self):
    visitor = rope.refactor.importutils.actions.RelativeToAbsoluteVisitor(
        self.pycore, self._current_folder())
    for import_stmt in self.imports:
        if not import_stmt.readonly:
            import_stmt.accept(visitor)
    return visitor.to_be_absolute

</t>
<t tx="ekr.20080516150804.2159">def get_self_import_fix_and_rename_list(self):
    visitor = rope.refactor.importutils.actions.SelfImportVisitor(
        self.pycore, self._current_folder(), self.pymodule.get_resource())
    for import_stmt in self.imports:
        if not import_stmt.readonly:
            import_stmt.accept(visitor)
    return visitor.to_be_fixed, visitor.to_be_renamed

</t>
<t tx="ekr.20080516150804.2160">def _current_folder(self):
    return self.pymodule.get_resource().parent

</t>
<t tx="ekr.20080516150804.2161">def sort_imports(self):
    # IDEA: Sort from import list
    visitor = actions.SortingVisitor(self.pycore, self._current_folder())
    for import_statement in self.imports:
        import_statement.accept(visitor)
    in_projects = sorted(visitor.in_project, self._compare_imports)
    third_party = sorted(visitor.third_party, self._compare_imports)
    standards = sorted(visitor.standard, self._compare_imports)
    future = sorted(visitor.future, self._compare_imports)
    blank_lines = 0
    last_index = self._first_import_line()
    last_index = self._move_imports(future, last_index, 0)
    last_index = self._move_imports(standards, last_index, 1)
    last_index = self._move_imports(third_party, last_index, 1)
    last_index = self._move_imports(in_projects, last_index, 1)
    self.separating_lines = 2

</t>
<t tx="ekr.20080516150804.2162">def _first_import_line(self):
    nodes = self.pymodule.get_ast().body
    lineno = 0
    if self.pymodule.get_doc() is not None:
        lineno = 1
    if len(nodes) &gt; lineno:
        lineno = self.pymodule.logical_lines.logical_line_in(
            nodes[lineno].lineno)[0]
    else:
        lineno = self.pymodule.lines.length()
    while lineno &gt; 1:
        line = self.pymodule.lines.get_line(lineno - 1)
        if line.strip() == '':
            lineno -= 1
        else:
            break
    return lineno

</t>
<t tx="ekr.20080516150804.2163">def _compare_imports(self, stmt1, stmt2):
    str1 = stmt1.get_import_statement()
    str2 = stmt2.get_import_statement()
    if str1.startswith('from ') and not str2.startswith('from '):
        return 1
    if not str1.startswith('from ') and str2.startswith('from '):
        return -1
    return cmp(str1, str2)

</t>
<t tx="ekr.20080516150804.2164">def _move_imports(self, imports, index, blank_lines):
    if imports:
        imports[0].move(index, blank_lines)
        index += 1
        if len(imports) &gt; 1:
            for stmt in imports[1:]:
                stmt.move(index)
                index += 1
    return index

</t>
<t tx="ekr.20080516150804.2165">def handle_long_imports(self, maxdots, maxlength):
    visitor = actions.LongImportVisitor(
        self._current_folder(), self.pycore, maxdots, maxlength)
    for import_statement in self.imports:
        if not import_statement.readonly:
            import_statement.accept(visitor)
    for import_info in visitor.new_imports:
        self.add_import(import_info)
    return visitor.to_be_renamed


</t>
<t tx="ekr.20080516150804.2166">class _OneTimeSelector(object):
    @others
</t>
<t tx="ekr.20080516150804.2167">
def __init__(self, names):
    self.names = names
    self.selected_names = set()

</t>
<t tx="ekr.20080516150804.2168">def __call__(self, imported_primary):
    if self._can_name_be_added(imported_primary):
        for name in self._get_dotted_tokens(imported_primary):
            self.selected_names.add(name)
        return True
    return False

</t>
<t tx="ekr.20080516150804.2169">def _get_dotted_tokens(self, imported_primary):
    tokens = imported_primary.split('.')
    for i in range(len(tokens)):
        yield '.'.join(tokens[:i + 1])

</t>
<t tx="ekr.20080516150804.2170">def _can_name_be_added(self, imported_primary):
    for name in self._get_dotted_tokens(imported_primary):
        if name in self.names and name not in self.selected_names:
            return True
    return False


</t>
<t tx="ekr.20080516150804.2171">class _UnboundNameFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.2172">
def __init__(self, pyobject):
    self.pyobject = pyobject

</t>
<t tx="ekr.20080516150804.2173">def _visit_child_scope(self, node):
    pyobject = self.pyobject.get_module().get_scope().\
               get_inner_scope_for_line(node.lineno).pyobject
    visitor = _LocalUnboundNameFinder(pyobject, self)
    for child in ast.get_child_nodes(node):
        ast.walk(child, visitor)

</t>
<t tx="ekr.20080516150804.2174">def _FunctionDef(self, node):
    self._visit_child_scope(node)

</t>
<t tx="ekr.20080516150804.2175">def _ClassDef(self, node):
    self._visit_child_scope(node)

</t>
<t tx="ekr.20080516150804.2176">def _Name(self, node):
    if self._get_root()._is_node_interesting(node) and \
       not self.is_bound(node.id):
        self.add_unbound(node.id)

</t>
<t tx="ekr.20080516150804.2177">def _Attribute(self, node):
    result = []
    while isinstance(node, ast.Attribute):
        result.append(node.attr)
        node = node.value
    if isinstance(node, ast.Name):
        result.append(node.id)
        primary = '.'.join(reversed(result))
        if self._get_root()._is_node_interesting(node) and \
           not self.is_bound(primary):
            self.add_unbound(primary)
    else:
        ast.walk(node, self)

</t>
<t tx="ekr.20080516150804.2178">def _get_root(self):
    pass

</t>
<t tx="ekr.20080516150804.2179">def is_bound(self, name, propagated=False):
    pass

</t>
<t tx="ekr.20080516150804.2180">def add_unbound(self, name):
    pass


</t>
<t tx="ekr.20080516150804.2181">class _GlobalUnboundNameFinder(_UnboundNameFinder):
    @others
</t>
<t tx="ekr.20080516150804.2182">
def __init__(self, pymodule, wanted_pyobject):
    super(_GlobalUnboundNameFinder, self).__init__(pymodule)
    self.unbound = set()
    self.names = set()
    for name, pyname in pymodule._get_structural_attributes().items():
        if not isinstance(pyname, (rope.base.pynames.ImportedName,
                                   rope.base.pynames.ImportedModule)):
            self.names.add(name)
    wanted_scope = wanted_pyobject.get_scope()
    self.start = wanted_scope.get_start()
    self.end = wanted_scope.get_end() + 1

</t>
<t tx="ekr.20080516150804.2183">def _get_root(self):
    return self

</t>
<t tx="ekr.20080516150804.2184">def is_bound(self, primary, propagated=False):
    name = primary.split('.')[0]
    if name in self.names:
        return True
    return False

</t>
<t tx="ekr.20080516150804.2185">def add_unbound(self, name):
    names = name.split('.')
    for i in range(len(names)):
        self.unbound.add('.'.join(names[:i + 1]))

</t>
<t tx="ekr.20080516150804.2186">def _is_node_interesting(self, node):
    start = self.start
    end = self.end
    return start &lt;= node.lineno &lt; end


</t>
<t tx="ekr.20080516150804.2187">class _LocalUnboundNameFinder(_UnboundNameFinder):
    @others
</t>
<t tx="ekr.20080516150804.2188">
def __init__(self, pyobject, parent):
    super(_LocalUnboundNameFinder, self).__init__(pyobject)
    self.parent = parent

</t>
<t tx="ekr.20080516150804.2189">def _get_root(self):
    return self.parent._get_root()

</t>
<t tx="ekr.20080516150804.2190">def is_bound(self, primary, propagated=False):
    name = primary.split('.')[0]
    if propagated:
        names = self.pyobject.get_scope().get_propagated_names()
    else:
        names = self.pyobject.get_scope().get_names()
    if name in names or self.parent.is_bound(name, propagated=True):
        return True
    return False

</t>
<t tx="ekr.20080516150804.2191">def add_unbound(self, name):
    self.parent.add_unbound(name)


</t>
<t tx="ekr.20080516150804.2192">class _GlobalImportFinder(object):
    @others
</t>
<t tx="ekr.20080516150804.2193">
def __init__(self, pymodule, pycore):
    self.current_folder = None
    if pymodule.get_resource():
        self.current_folder = pymodule.get_resource().parent
        self.pymodule = pymodule
    self.pycore = pycore
    self.imports = []
    self.pymodule = pymodule
    self.lines = self.pymodule.lines

</t>
<t tx="ekr.20080516150804.2194">def visit_import(self, node, end_line):
    start_line = node.lineno
    import_statement = importinfo.ImportStatement(
        importinfo.NormalImport(self._get_names(node.names)),
        start_line, end_line, self._get_text(start_line, end_line),
        blank_lines=self._count_empty_lines_before(start_line))
    self.imports.append(import_statement)

</t>
<t tx="ekr.20080516150804.2195">def _count_empty_lines_before(self, lineno):
    result = 0
    for current in range(lineno - 1, 0, -1):
        line = self.lines.get_line(current)
        if line.strip() == '':
            result += 1
        else:
            break
    return result

</t>
<t tx="ekr.20080516150804.2196">def _count_empty_lines_after(self, lineno):
    result = 0
    for current in range(lineno + 1, self.lines.length()):
        line = self.lines.get_line(current)
        if line.strip() == '':
            result += 1
        else:
            break
    return result

</t>
<t tx="ekr.20080516150804.2197">def get_separating_line_count(self):
    if not self.imports:
        return 0
    return self._count_empty_lines_after(self.imports[-1].end_line - 1)

</t>
<t tx="ekr.20080516150804.2198">def _get_text(self, start_line, end_line):
    result = []
    for index in range(start_line, end_line):
        result.append(self.lines.get_line(index))
    return '\n'.join(result)

</t>
<t tx="ekr.20080516150804.2199">def visit_from(self, node, end_line):
    level = 0
    if node.level:
        level = node.level
    import_info = importinfo.FromImport(
        node.module, level, self._get_names(node.names))
    start_line = node.lineno
    self.imports.append(importinfo.ImportStatement(
                        import_info, node.lineno, end_line,
                        self._get_text(start_line, end_line),
                        blank_lines=self._count_empty_lines_before(start_line)))

</t>
<t tx="ekr.20080516150804.2200">def _get_names(self, alias_names):
    result = []
    for alias in alias_names:
        result.append((alias.name, alias.asname))
    return result

</t>
<t tx="ekr.20080516150804.2201">def find_import_statements(self):
    nodes = self.pymodule.get_ast().body
    for index, node in enumerate(nodes):
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            lines = self.pymodule.logical_lines
            end_line = lines.logical_line_in(node.lineno)[1] + 1
        if isinstance(node, ast.Import):
            self.visit_import(node, end_line)
        if isinstance(node, ast.ImportFrom):
            self.visit_from(node, end_line)
    return self.imports
</t>
<t tx="ekr.20080516150804.2202">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2203">"""A package for handling imports

This package provides tools for modifying module imports after
refactorings or as a separate task.

"""
import rope.base.evaluate
from rope.base.change import ChangeSet, ChangeContents
from rope.refactor import occurrences, rename
from rope.refactor.importutils import module_imports
from rope.refactor.importutils.importinfo import \
     (NormalImport, FromImport, get_module_name)
import rope.base.codeanalyze


</t>
<t tx="ekr.20080516150804.2204">class ImportOrganizer(object):
    """Perform some import-related commands

    Each method returns a `rope.base.change.Change` object.

    """
    @others
</t>
<t tx="ekr.20080516150804.2205">
def __init__(self, project):
    self.project = project
    self.pycore = project.pycore
    self.import_tools = ImportTools(self.pycore)

</t>
<t tx="ekr.20080516150804.2206">def organize_imports(self, resource, offset=None):
    return self._perform_command_on_import_tools(
        self.import_tools.organize_imports, resource, offset)

</t>
<t tx="ekr.20080516150804.2207">def expand_star_imports(self, resource, offset=None):
    return self._perform_command_on_import_tools(
        self.import_tools.expand_stars, resource, offset)

</t>
<t tx="ekr.20080516150804.2208">def froms_to_imports(self, resource, offset=None):
    return self._perform_command_on_import_tools(
        self.import_tools.froms_to_imports, resource, offset)

</t>
<t tx="ekr.20080516150804.2209">def relatives_to_absolutes(self, resource, offset=None):
    return self._perform_command_on_import_tools(
        self.import_tools.relatives_to_absolutes, resource, offset)

</t>
<t tx="ekr.20080516150804.2210">def handle_long_imports(self, resource, offset=None):
    return self._perform_command_on_import_tools(
        self.import_tools.handle_long_imports, resource, offset)

</t>
<t tx="ekr.20080516150804.2211">def _perform_command_on_import_tools(self, method, resource, offset):
    pymodule = self.pycore.resource_to_pyobject(resource)
    before_performing = pymodule.source_code
    import_filter = None
    if offset is not None:
        import_filter = self._line_filter(
            pymodule.lines.get_line_number(offset))
    result = method(pymodule, import_filter=import_filter)
    if result is not None and result != before_performing:
        changes = ChangeSet(method.__name__.replace('_', ' ') +
                            ' in &lt;%s&gt;' % resource.path)
        changes.add_change(ChangeContents(resource, result))
        return changes

</t>
<t tx="ekr.20080516150804.2212">def _line_filter(self, lineno):
    def import_filter(import_stmt):
        return import_stmt.start_line &lt;= lineno &lt; import_stmt.end_line
    return import_filter


</t>
<t tx="ekr.20080516150804.2213">class ImportTools(object):
    @others
</t>
<t tx="ekr.20080516150804.2214">
def __init__(self, pycore):
    self.pycore = pycore

</t>
<t tx="ekr.20080516150804.2215">def get_import(self, resource):
    """The import statement for `resource`"""
    module_name = get_module_name(self.pycore, resource)
    return NormalImport(((module_name, None), ))

</t>
<t tx="ekr.20080516150804.2216">def get_from_import(self, resource, name):
    """The from import statement for `name` in `resource`"""
    module_name = get_module_name(self.pycore, resource)
    names = []
    if isinstance(name, list):
        names = [(imported, None) for imported in name]
    else:
        names = [(name, None),]
    return FromImport(module_name, 0, tuple(names))

</t>
<t tx="ekr.20080516150804.2217">def module_imports(self, module, imports_filter=None):
    return module_imports.ModuleImports(self.pycore, module,
                                        imports_filter)

</t>
<t tx="ekr.20080516150804.2218">def froms_to_imports(self, pymodule, import_filter=None):
    pymodule = self._clean_up_imports(pymodule, import_filter)
    module_imports = self.module_imports(pymodule, import_filter)
    for import_stmt in module_imports.imports:
        if import_stmt.readonly or \
           not self._is_transformable_to_normal(import_stmt.import_info):
            continue
        pymodule = self._from_to_normal(pymodule, import_stmt)

    # Adding normal imports in place of froms
    module_imports = self.module_imports(pymodule, import_filter)
    for import_stmt in module_imports.imports:
        if not import_stmt.readonly and \
           self._is_transformable_to_normal(import_stmt.import_info):
            import_stmt.import_info = \
                NormalImport(((import_stmt.import_info.module_name, None),))
    module_imports.remove_duplicates()
    return module_imports.get_changed_source()

</t>
<t tx="ekr.20080516150804.2219">def expand_stars(self, pymodule, import_filter=None):
    module_imports = self.module_imports(pymodule, import_filter)
    module_imports.expand_stars()
    return module_imports.get_changed_source()

</t>
<t tx="ekr.20080516150804.2220">def _from_to_normal(self, pymodule, import_stmt):
    resource = pymodule.get_resource()
    from_import = import_stmt.import_info
    module_name = from_import.module_name
    for name, alias in from_import.names_and_aliases:
        imported = name
        if alias is not None:
            imported = alias
        occurrence_finder = occurrences.create_finder(
            self.pycore, imported, pymodule[imported], imports=False)
        source = rename.rename_in_module(
            occurrence_finder, module_name + '.' + name,
            pymodule=pymodule, replace_primary=True)
        if source is not None:
            pymodule = self.pycore.get_string_module(source, resource)
    return pymodule

</t>
<t tx="ekr.20080516150804.2221">def _clean_up_imports(self, pymodule, import_filter):
    resource = pymodule.get_resource()
    module_with_imports = self.module_imports(pymodule, import_filter)
    module_with_imports.expand_stars()
    source = module_with_imports.get_changed_source()
    if source is not None:
        pymodule = self.pycore.get_string_module(source, resource)
    source = self.relatives_to_absolutes(pymodule)
    if source is not None:
        pymodule = self.pycore.get_string_module(source, resource)

    module_with_imports = self.module_imports(pymodule, import_filter)
    module_with_imports.remove_duplicates()
    module_with_imports.remove_unused_imports()
    source = module_with_imports.get_changed_source()
    if source is not None:
        pymodule = self.pycore.get_string_module(source, resource)
    return pymodule

</t>
<t tx="ekr.20080516150804.2222">def relatives_to_absolutes(self, pymodule, import_filter=None):
    module_imports = self.module_imports(pymodule, import_filter)
    to_be_absolute_list = module_imports.get_relative_to_absolute_list()
    for name, absolute_name in to_be_absolute_list:
        pymodule = self._rename_in_module(pymodule, name, absolute_name)
    module_imports = self.module_imports(pymodule, import_filter)
    module_imports.get_relative_to_absolute_list()
    source = module_imports.get_changed_source()
    if source is None:
        source = pymodule.source_code
    return source

</t>
<t tx="ekr.20080516150804.2223">def _is_transformable_to_normal(self, import_info):
    if not isinstance(import_info, FromImport):
        return False
    return True

</t>
<t tx="ekr.20080516150804.2224">def organize_imports(self, pymodule,
                     unused=True, duplicates=True,
                     selfs=True, sort=True, import_filter=None):
    if unused or duplicates:
        module_imports = self.module_imports(pymodule, import_filter)
        if unused:
            module_imports.remove_unused_imports()
        if duplicates:
            module_imports.remove_duplicates()
        source = module_imports.get_changed_source()
        if source is not None:
            pymodule = self.pycore.get_string_module(
                source, pymodule.get_resource())
    if selfs:
        pymodule = self._remove_self_imports(pymodule, import_filter)
    if sort:
        return self.sort_imports(pymodule, import_filter)
    else:
        return pymodule.source_code

</t>
<t tx="ekr.20080516150804.2225">def _remove_self_imports(self, pymodule, import_filter=None):
    module_imports = self.module_imports(pymodule, import_filter)
    to_be_fixed, to_be_renamed = module_imports.get_self_import_fix_and_rename_list()
    for name in to_be_fixed:
        try:
            pymodule = self._rename_in_module(pymodule, name, '', till_dot=True)
        except ValueError:
            # There is a self import with direct access to it
            return pymodule
    for name, new_name in to_be_renamed:
        pymodule = self._rename_in_module(pymodule, name, new_name)
    module_imports = self.module_imports(pymodule, import_filter)
    module_imports.get_self_import_fix_and_rename_list()
    source = module_imports.get_changed_source()
    if source is not None:
        pymodule = self.pycore.get_string_module(source, pymodule.get_resource())
    return pymodule

</t>
<t tx="ekr.20080516150804.2226">def _rename_in_module(self, pymodule, name, new_name, till_dot=False):
    old_name = name.split('.')[-1]
    old_pyname = rope.base.evaluate.get_string_result(
        pymodule.get_scope(), name)
    occurrence_finder = occurrences.create_finder(
        self.pycore, old_name, old_pyname, imports=False)
    changes = rope.base.codeanalyze.ChangeCollector(pymodule.source_code)
    for occurrence in occurrence_finder.find_occurrences(pymodule=pymodule):
        start, end = occurrence.get_primary_range()
        if till_dot:
            new_end = pymodule.source_code.index('.', end) + 1
            space = pymodule.source_code[end:new_end - 1].strip()
            if not space == '':
                for c in space:
                    if not c.isspace() and c not in '\\':
                        raise ValueError()
            end = new_end
        changes.add_change(start, end, new_name)
    source = changes.get_changed()
    if source is not None:
        pymodule = self.pycore.get_string_module(source, pymodule.get_resource())
    return pymodule

</t>
<t tx="ekr.20080516150804.2227">def sort_imports(self, pymodule, import_filter=None):
    module_imports = self.module_imports(pymodule, import_filter)
    module_imports.sort_imports()
    return module_imports.get_changed_source()

</t>
<t tx="ekr.20080516150804.2228">def handle_long_imports(self, pymodule, maxdots=2, maxlength=27,
                        import_filter=None):
    # IDEA: `maxdots` and `maxlength` can be specified in project config
    # adding new from imports
    module_imports = self.module_imports(pymodule, import_filter)
    to_be_fixed = module_imports.handle_long_imports(maxdots, maxlength)
    # performing the renaming
    pymodule = self.pycore.get_string_module(
        module_imports.get_changed_source(),
        resource=pymodule.get_resource())
    for name in to_be_fixed:
        pymodule = self._rename_in_module(pymodule, name,
                                          name.split('.')[-1])
    # organizing imports
    return self.organize_imports(pymodule, selfs=False, sort=False,
                                 import_filter=import_filter)


</t>
<t tx="ekr.20080516150804.2229">def get_imports(pycore, pydefined):
    """A shortcut for getting the `ImportInfo`\s used in a scope"""
    pymodule = pydefined.get_module()
    module = module_imports.ModuleImports(pycore, pymodule)
    if pymodule == pydefined:
        return [stmt.import_info for stmt in module.imports]
    return module.get_used_imports(pydefined)


</t>
<t tx="ekr.20080516150804.2230">def get_module_imports(pycore, pymodule):
    """A shortcut for creating a `module_imports.ModuleImports` object"""
    return module_imports.ModuleImports(pycore, pymodule)


</t>
<t tx="ekr.20080516150804.2231">def add_import(pycore, pymodule, module_name, name=None):
    imports = get_module_imports(pycore, pymodule)
    candidates = []
    names = []
    # from mod import name
    if name is not None:
        from_import = FromImport(module_name, 0, [(name, None)])
        names.append(name)
        candidates.append(from_import)
    # from pkg import mod
    if '.' in module_name:
        pkg, mod = module_name.rsplit('.', 1)
        candidates.append(FromImport(pkg, 0, [(mod, None)]))
        if name:
            names.append(mod + '.' + name)
        else:
            names.append(mod)
    # import mod
    normal_import = NormalImport([(module_name, None)])
    if name:
        names.append(module_name + '.' + name)
    else:
        names.append(module_name)

    candidates.append(normal_import)

    visitor = actions.AddingVisitor(pycore, candidates)
    selected_import = normal_import
    for import_statement in imports.imports:
        if import_statement.accept(visitor):
            selected_import = visitor.import_info
            break
    imports.add_import(selected_import)
    imported_name = names[candidates.index(selected_import)]
    return imports.get_changed_source(), imported_name
</t>
<t tx="ekr.20080516150804.2232"></t>
<t tx="ekr.20080516150804.2233">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2234">import unittest

import rope.base.oi
import rope.base.libutils
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2235">class DynamicOITest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2236">
def setUp(self):
    super(DynamicOITest, self).setUp()
    self.project = testutils.sample_project(validate_objectdb=True)
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2237">def tearDown(self):
    testutils.remove_project(self.project)
    super(DynamicOITest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2238">def test_simple_dti(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(a_func)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertEquals(pymod['a_func'].get_object(),
                      pymod['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2239">def test_module_dti(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    code = 'import mod1\ndef a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(mod1)\n'
    mod2.write(code)
    self.pycore.run_module(mod2).wait_process()
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(self.pycore.resource_to_pyobject(mod1),
                      pymod2['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2240">def test_class_from_another_module_dti(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    code1 = 'class AClass(object):\n    pass\n'
    code2 = 'from mod1 import AClass\n' \
           '\ndef a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(AClass)\n'
    mod1.write(code1)
    mod2.write(code2)
    self.pycore.run_module(mod2).wait_process()
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(pymod2['AClass'].get_object(),
                      pymod2['a_var'].get_object())


</t>
<t tx="ekr.20080516150804.2241">def test_class_dti(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class AClass(object):\n    pass\n' \
           '\ndef a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(AClass)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertEquals(pymod['AClass'].get_object(),
                      pymod['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2242">def test_instance_dti(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class AClass(object):\n    pass\n' \
           '\ndef a_func(arg):\n    return eval("arg()")\n' \
           'a_var = a_func(AClass)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertEquals(pymod['AClass'].get_object(),
                      pymod['a_var'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2243">def test_method_dti(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class AClass(object):\n    def a_method(self, arg):\n' \
           '        return eval("arg()")\n' \
           'an_instance = AClass()\n' \
           'a_var = an_instance.a_method(AClass)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertEquals(pymod['AClass'].get_object(),
                      pymod['a_var'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2244">def test_function_argument_dti(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    pass\n' \
           'a_func(a_func)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pyscope = self.pycore.resource_to_pyobject(mod).get_scope()
    self.assertEquals(pyscope['a_func'].get_object(),
                      pyscope.get_scopes()[0]['arg'].get_object())

</t>
<t tx="ekr.20080516150804.2245">def test_classes_with_the_same_name(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    class AClass(object):\n' \
           '        pass\n    return eval("arg")\n' \
           'class AClass(object):\n    pass\n' \
           'a_var = a_func(AClass)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertEquals(pymod['AClass'].get_object(),
                      pymod['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2246">def test_nested_classes(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func():\n    class AClass(object):\n' \
           '        pass\n    return AClass\n' \
           'def another_func(arg):\n    return eval("arg")\n' \
           'a_var = another_func(a_func())\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pyscope = self.pycore.resource_to_pyobject(mod).get_scope()
    self.assertEquals(pyscope.get_scopes()[0]['AClass'].get_object(),
                      pyscope['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2247">def test_function_argument_dti2(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg, a_builtin_type):\n    pass\n' \
           'a_func(a_func, [])\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pyscope = self.pycore.resource_to_pyobject(mod).get_scope()
    self.assertEquals(pyscope['a_func'].get_object(),
                      pyscope.get_scopes()[0]['arg'].get_object())

</t>
<t tx="ekr.20080516150804.2248">def test_dti_and_concluded_data_invalidation(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(a_func)\n'
    mod.write(code)
    pymod = self.pycore.resource_to_pyobject(mod)
    pymod['a_var'].get_object()
    self.pycore.run_module(mod).wait_process()
    self.assertEquals(pymod['a_func'].get_object(),
                      pymod['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2249">def test_list_objects_and_dynamicoi(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func([C()])[0]\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2250">def test_for_loops_and_dynamicoi(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'for c in a_func([C()]):\n    a_var = c\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2251">def test_dict_objects_and_dynamicoi(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func({1: C()})[1]\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2252">def test_dict_keys_and_dynamicoi(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func({C(): 1}).keys()[0]\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2253">def test_dict_keys_and_dynamicoi2(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a, b = a_func((C1(), C2()))\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2254">def test_strs_and_dynamicoi(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func("hey")\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(), rope.base.builtins.Str))

</t>
<t tx="ekr.20080516150804.2255">def test_textual_transformations(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n    pass\ndef f():\n    pass\na_var = C()\n' \
           'a_list = [C()]\na_str = "hey"\na_file = open("file.txt")\n'
    mod.write(code)
    to_pyobject = rope.base.oi.transform.TextualToPyObject(self.project)
    to_textual = rope.base.oi.transform.PyObjectToTextual(self.project)
    pymod = self.pycore.resource_to_pyobject(mod)
    def complex_to_textual(pyobject):
        return to_textual.transform(
            to_pyobject.transform(to_textual.transform(pyobject)))
    for name in ('C', 'f', 'a_var', 'a_list', 'a_str', 'a_file'):
        var = pymod[name].get_object()
        self.assertEquals(to_textual.transform(var), complex_to_textual(var))
    self.assertEquals(to_textual.transform(pymod), complex_to_textual(pymod))
    enumerate_func = rope.base.builtins.builtins['enumerate'].get_object()
    self.assertEquals(to_textual.transform(enumerate_func),
                      complex_to_textual(enumerate_func))

</t>
<t tx="ekr.20080516150804.2256">def test_arguments_with_keywords(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a = a_func(arg=C1())\nb = a_func(arg=C2())\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2257">def test_a_function_with_different_returns(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(arg):\n    return eval("arg")\n' \
           'a = a_func(C1())\nb = a_func(C2())\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2258">def test_a_function_with_different_returns2(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(p):\n    if p == C1:\n        return C1()\n' \
           '    else:\n        return C2()\n' \
           'a = a_func(C1)\nb = a_func(C2)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2259">def test_ignoring_star_args(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(p, *args):\n    if p == C1:\n        return C1()\n' \
           '    else:\n        return C2()\n' \
           'a = a_func(C1, 1)\nb = a_func(C2, 2)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2260">def test_ignoring_double_star_args(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(p, *kwds, **args):\n    if p == C1:\n        return C1()\n' \
           '    else:\n        return C2()\n' \
           'a = a_func(C1, kwd=1)\nb = a_func(C2, kwd=2)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    pymod = self.pycore.resource_to_pyobject(mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2261">def test_invalidating_data_after_changing(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def a_func(arg):\n    return eval("arg")\n' \
           'a_var = a_func(a_func)\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    mod.write(code.replace('a_func', 'newfunc'))
    mod.write(code)
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertNotEquals(pymod['a_func'].get_object(),
                         pymod['a_var'].get_object())

</t>
<t tx="ekr.20080516150804.2262">def test_invalidating_data_after_moving(self):
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('class C(object):\n    pass\n')
    mod = testutils.create_module(self.project, 'mod')
    code = 'import mod2\ndef a_func(arg):\n    return eval(arg)\n' \
           'a_var = a_func("mod2.C")\n'
    mod.write(code)
    self.pycore.run_module(mod).wait_process()
    mod.move('newmod.py')
    pymod = self.pycore.get_module('newmod')
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(pymod2['C'].get_object(),
                      pymod['a_var'].get_object())


</t>
<t tx="ekr.20080516150804.2263">class NewStaticOITest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2264">
def setUp(self):
    super(NewStaticOITest, self).setUp()
    self.project = testutils.sample_project(validate_objectdb=True)
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.2265">def tearDown(self):
    testutils.remove_project(self.project)
    super(NewStaticOITest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2266">def test_static_oi_for_simple_function_calls(self):
    code = 'class C(object):\n    pass\ndef f(p):\n    pass\nf(C())\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    f_scope = pymod['f'].get_object().get_scope()
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(c_class, p_type)

</t>
<t tx="ekr.20080516150804.2267">def test_static_oi_not_failing_when_callin_callables(self):
    code = 'class C(object):\n    pass\nC()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)

</t>
<t tx="ekr.20080516150804.2268">def test_static_oi_for_nested_calls(self):
    code = 'class C(object):\n    pass\ndef f(p):\n    pass\n' \
           'def g(p):\n    return p\nf(g(C()))\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    f_scope = pymod['f'].get_object().get_scope()
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(c_class, p_type)

</t>
<t tx="ekr.20080516150804.2269">def test_static_oi_class_methods(self):
    code = 'class C(object):\n    def f(self, p):\n        pass\n' \
           'C().f(C())'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    f_scope = c_class['f'].get_object().get_scope()
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(c_class, p_type)

</t>
<t tx="ekr.20080516150804.2270">def test_static_oi_preventing_soi_maximum_recursion_exceptions(self):
    code = 'item = {}\nfor item in item.keys():\n    pass\n'
    self.mod.write(code)
    try:
        self.pycore.analyze_module(self.mod)
    except RuntimeError, e:
        self.fail(str(e))

</t>
<t tx="ekr.20080516150804.2271">def test_static_oi_for_infering_returned_types_from_functions_based_on_parameters(self):
    code = 'class C(object):\n    pass\ndef func(p):\n    return p\n' \
           'a_var = func(C())\n'
    self.mod.write(code)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2272">def test_a_function_with_different_returns(self):
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'def a_func(arg):\n    return arg\n' \
           'a = a_func(C1())\nb = a_func(C2())\n'
    self.mod.write(code)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2273">def test_not_reporting_out_of_date_information(self):
    code = 'class C1(object):\n    pass\n' \
           'def f(arg):\n    return C1()\na_var = f('')\n'
    self.mod.write(code)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c1_class, a_var.get_type())

    self.mod.write(code.replace('C1', 'C2'))
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c2_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2274">def test_invalidating_concluded_data_in_a_function(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('def func(arg):\n    temp = arg\n    return temp\n')
    mod2.write('import mod1\n'
               'class C1(object):\n    pass\n'
               'class C2(object):\n    pass\n'
               'a_var = mod1.func(C1())\n')
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    c1_class = pymod2['C1'].get_object()
    a_var = pymod2['a_var'].get_object()
    self.assertEquals(c1_class, a_var.get_type())

    mod2.write(mod2.read()[:mod2.read().rfind('C1()')] + 'C2())\n')
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    c2_class = pymod2['C2'].get_object()
    a_var = pymod2['a_var'].get_object()
    self.assertEquals(c2_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2275">def test_handling_generator_functions_for_strs(self):
    self.mod.write('class C(object):\n    pass\ndef f(p):\n    yield p()\n'
                   'for c in f(C):\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2276"># TODO: Returning a generator for functions that yield unknowns
def xxx_test_handling_generator_functions_when_unknown_type_is_yielded(self):
    self.mod.write('class C(object):\n    pass\ndef f():\n    yield eval("C()")\n'
                   'a_var = f()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(),
                               rope.base.builtins.Generator))

</t>
<t tx="ekr.20080516150804.2277">def test_static_oi_for_lists_depending_on_append_function(self):
    code = 'class C(object):\n    pass\nl = list()\n' \
           'l.append(C())\na_var = l.pop()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2278">def test_static_oi_for_lists_per_object_for_get_item(self):
    code = 'class C(object):\n    pass\nl = list()\n' \
           'l.append(C())\na_var = l[0]\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2279">def test_static_oi_for_lists_per_object_for_fields(self):
    code = 'class C(object):\n    pass\n' \
           'class A(object):\n    def __init__(self):\n        self.l = []\n' \
           '    def set(self):\n        self.l.append(C())\n' \
           'a = A()\na.set()\na_var = a.l[0]\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2280">def test_static_oi_for_lists_per_object_for_set_item(self):
    code = 'class C(object):\n    pass\nl = [None]\n' \
           'l[0] = C()\na_var = l[0]\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2281">def test_static_oi_for_lists_per_object_for_extending_lists(self):
    code = 'class C(object):\n    pass\nl = []\n' \
           'l.append(C())\nl2 = []\nl2.extend(l)\na_var = l2[0]\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2282">def test_static_oi_for_lists_per_object_for_iters(self):
    code = 'class C(object):\n    pass\n' \
           'l = []\nl.append(C())\n' \
           'for c in l:\n    a_var = c\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2283">def test_static_oi_for_dicts_depending_on_append_function(self):
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'd = {}\nd[C1()] = C2()\na, b = d.popitem()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2284">def test_static_oi_for_dicts_depending_on_for_loops(self):
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'd = {}\nd[C1()] = C2()\nfor k, v in d.items():\n    a = k\n    b = v\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2285">def test_static_oi_for_dicts_depending_on_update(self):
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'd = {}\nd[C1()] = C2()\nd2 = {}\nd2.update(d)\na, b = d2.popitem()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2286">def test_static_oi_for_dicts_depending_on_update_on_seqs(self):
    code = 'class C1(object):\n    pass\nclass C2(object):\n    pass\n' \
           'd = {}\nd.update([(C1(), C2())])\na, b = d.popitem()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2287">def test_static_oi_for_sets_per_object_for_set_item(self):
    code = 'class C(object):\n    pass\ns = set()\n' \
           's.add(C())\na_var = s.pop() \n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2288">def test_properties_and_calling_get_property(self):
    code = 'class C1(object):\n    pass\n' \
           'class C2(object):\n    c1 = C1()\n' \
           '    def get_c1(self):\n        return self.c1\n' \
           '    p = property(get_c1)\nc2 = C2()\na_var = c2.p\n'
    self.mod.write(code)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c1_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2289">def test_soi_on_constructors(self):
    code = 'class C1(object):\n    pass\n' \
           'class C2(object):\n' \
           '    def __init__(self, arg):\n        self.attr = arg\n' \
           'c2 = C2(C1())\na_var = c2.attr'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c1_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2290">def test_not_saving_unknown_function_returns(self):
    mod2 = testutils.create_module(self.project, 'mod2')
    self.mod.write('class C(object):\n    pass\nl = []\nl.append(C())\n')
    mod2.write('import mod\ndef f():\n    return mod.l.pop()\na_var = f()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    c_class = pymod['C'].get_object()
    a_var = pymod2['a_var']

    self.pycore.analyze_module(mod2)
    self.assertNotEquals(c_class, a_var.get_object().get_type())

    self.pycore.analyze_module(self.mod)
    self.assertEquals(c_class, a_var.get_object().get_type())

</t>
<t tx="ekr.20080516150804.2291">def test_using_the_best_callinfo(self):
    code = 'class C1(object):\n    pass\n' \
           'def f(arg1, arg2, arg3):\n    pass\n' \
           'f("", None, C1())\nf("", C1(), None)\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    f_scope = pymod['f'].get_object().get_scope()
    arg2 = f_scope['arg2'].get_object()
    self.assertEquals(c1_class, arg2.get_type())

</t>
<t tx="ekr.20080516150804.2292">def test_call_function_and_parameters(self):
    code = 'class A(object):\n    def __call__(self, p):\n        pass\n' \
           'A()("")\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    scope = self.pycore.resource_to_pyobject(self.mod).get_scope()
    p_object = scope.get_scopes()[0].get_scopes()[0]['p'].get_object()
    self.assertTrue(isinstance(p_object.get_type(),
                               rope.base.builtins.Str))

</t>
<t tx="ekr.20080516150804.2293">def test_report_change_in_libutils(self):
    self.project.prefs['automatic_soa'] = True
    code = 'class C(object):\n    pass\ndef f(p):\n    pass\nf(C())\n'
    mod_file = open(self.mod.real_path, 'w')
    mod_file.write(code)
    mod_file.close()
    rope.base.libutils.report_change(self.project, self.mod.real_path, '')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    f_scope = pymod['f'].get_object().get_scope()
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(c_class, p_type)

</t>
<t tx="ekr.20080516150804.2294">def test_report_libutils_and_analyze_all_modules(self):
    code = 'class C(object):\n    pass\ndef f(p):\n    pass\nf(C())\n'
    self.mod.write(code)
    rope.base.libutils.analyze_modules(self.project)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    f_scope = pymod['f'].get_object().get_scope()
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(c_class, p_type)

</t>
<t tx="ekr.20080516150804.2295">def test_validation_problems_for_objectdb_retrievals(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('l = []\nvar = l.pop()\n')
    mod2.write('import mod1\n\nclass C(object):\n    pass\n'
               'mod1.l.append(C())\n')
    self.pycore.analyze_module(mod2)

    pymod2 = self.pycore.resource_to_pyobject(mod2)
    c_class = pymod2['C'].get_object()
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    var_pyname = pymod1['var']
    self.assertEquals(c_class, var_pyname.get_object().get_type())
    mod2.write('import mod1\n\nmod1.l.append("")\n')
    self.assertNotEquals(c_class, var_pyname.get_object().get_type(),
                         'Class `C` no more exists')

</t>
<t tx="ekr.20080516150804.2296">def test_validation_problems_for_changing_builtin_types(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('l = []\nl.append("")\n')
    self.pycore.analyze_module(mod1)

    mod1.write('l = {}\nv = l["key"]\n')
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    var = pymod1['v'].get_object()

</t>
<t tx="ekr.20080516150804.2297">def test_always_returning_containing_class_for_selfs(self):
    code = 'class A(object):\n    def f(p):\n        return p\n' \
           'class B(object):\n    pass\nb = B()\nb.f()\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_class = pymod['A'].get_object()
    f_scope = a_class.get_scope().get_scopes()[0]
    p_type = f_scope['p'].get_object().get_type()
    self.assertEquals(a_class, p_type)

</t>
<t tx="ekr.20080516150804.2298">def test_following_function_calls_when_asked_to(self):
    code = 'class A(object):\n    pass\n' \
           'class C(object):\n' \
           '    def __init__(self, arg):\n' \
           '        self.attr = arg\n' \
           'def f(p):\n    return C(p)\n' \
           'c = f(A())\nx = c.attr\n'
    self.mod.write(code)
    self.pycore.analyze_module(self.mod, followed_calls=1)
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_class = pymod['A'].get_object()
    x_var = pymod['x'].get_object().get_type()
    self.assertEquals(a_class, x_var)


</t>
<t tx="ekr.20080516150804.2299">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(DynamicOITest))
    result.addTests(unittest.makeSuite(NewStaticOITest))
    return result


</t>
<t tx="ekr.20080516150804.2300">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2301">import unittest

from rope.base import pyobjects, builtins
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2302">class BuiltinTypesTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2303">
def setUp(self):
    super(BuiltinTypesTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.2304">def tearDown(self):
    testutils.remove_project(self.project)
    super(BuiltinTypesTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2305">def test_simple_case(self):
    self.mod.write('l = []\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('append' in pymod['l'].get_object())

</t>
<t tx="ekr.20080516150804.2306">def test_holding_type_information(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\na_var = l.pop()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2307">def test_get_items(self):
    self.mod.write('class C(object):\n    def __getitem__(self, i):\n        return C()\n'
                   'c = C()\na_var = c[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2308">def test_get_items_for_lists(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\na_var = l[0]\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2309">def test_get_items_from_slices(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\na_var = l[:].pop()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2310">def test_simple_for_loops(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'for c in l:\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2311">def test_definition_location_for_loop_variables(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'for c in l:\n    pass\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_var = pymod['c']
    self.assertEquals((pymod, 4), c_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2312">def test_simple_case_for_dicts(self):
    self.mod.write('d = {}\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('get' in pymod['d'].get_object())

</t>
<t tx="ekr.20080516150804.2313">def test_get_item_for_dicts(self):
    self.mod.write('class C(object):\n    pass\nd = {1: C()}\na_var = d[1]\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2314">def test_popping_dicts(self):
    self.mod.write('class C(object):\n    pass\nd = {1: C()}\na_var = d.pop(1)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2315">def test_getting_keys_from_dicts(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor c in d.keys():\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2316">def test_getting_values_from_dicts(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor c in d.values():\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C2'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2317">def test_getting_iterkeys_from_dicts(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor c in d.keys():\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2318">def test_getting_itervalues_from_dicts(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor c in d.values():\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C2'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2319">def test_using_copy_for_dicts(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor c in d.copy():\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C1'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2320">def test_tuple_assignments_for_items(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nkey, value = d.items()[0]\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    key = pymod['key'].get_object()
    value = pymod['value'].get_object()
    self.assertEquals(c1_class, key.get_type())
    self.assertEquals(c2_class, value.get_type())

</t>
<t tx="ekr.20080516150804.2321">def test_tuple_assignment_for_lists(self):
    self.mod.write('class C(object):\n    pass\nl = [C(), C()]\na, b = l\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c_class, a_var.get_type())
    self.assertEquals(c_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2322">def test_tuple_assignments_for_iteritems_in_fors(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'd = {C1(): C2()}\nfor x, y in d.items():\n    a = x;\n    b = y\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2323">def test_simple_tuple_assignments(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'a, b = C1(), C2()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2324">def test_overriding_builtin_names(self):
    self.mod.write('class C(object):\n    pass\nlist = C\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    list_var = pymod['list'].get_object()
    self.assertEquals(c_class, list_var)

</t>
<t tx="ekr.20080516150804.2325">def test_simple_builtin_scope_test(self):
    self.mod.write('l = list()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('append' in pymod['l'].get_object())

</t>
<t tx="ekr.20080516150804.2326">def test_simple_sets(self):
    self.mod.write('s = set()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('add' in pymod['s'].get_object())

</t>
<t tx="ekr.20080516150804.2327">def test_making_lists_using_the_passed_argument_to_init(self):
    self.mod.write('class C(object):\n    pass\nl1 = [C()]\n'
                   'l2 = list(l1)\na_var = l2.pop()')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2328">def test_making_tuples_using_the_passed_argument_to_init(self):
    self.mod.write('class C(object):\n    pass\nl1 = [C()]\n'
                   'l2 = tuple(l1)\na_var = l2[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2329">def test_making_sets_using_the_passed_argument_to_init(self):
    self.mod.write('class C(object):\n    pass\nl1 = [C()]\n'
                   'l2 = set(l1)\na_var = l2.pop()')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2330">def test_making_dicts_using_the_passed_argument_to_init(self):
    self.mod.write('class C1(object):\n    pass\nclass C2(object):\n    pass\n'
                   'l1 = [(C1(), C2())]\n'
                   'l2 = dict(l1)\na, b = l2.items()[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2331">def test_range_builtin_function(self):
    self.mod.write('l = range(1)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    l = pymod['l'].get_object()
    self.assertTrue('append' in l)

</t>
<t tx="ekr.20080516150804.2332">def test_reversed_builtin_function(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'for x in reversed(l):\n    a_var = x\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2333">def test_sorted_builtin_function(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'a_var = sorted(l).pop()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2334">def test_super_builtin_function(self):
    self.mod.write(
        'class C(object):\n    pass\n'
        'class A(object):\n    def a_f(self):\n        return C()\n'
        'class B(A):\n    def b_f(self):\n        return super(B, self).a_f()\n'
        'a_var = B.b_f()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2335">def test_file_builtin_type(self):
    self.mod.write('for line in open("file.txt"):\n    a_var = line\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(), builtins.Str))

</t>
<t tx="ekr.20080516150804.2336">def test_property_builtin_type(self):
    self.mod.write('p = property()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    p_var = pymod['p'].get_object()
    self.assertTrue('fget' in p_var)

</t>
<t tx="ekr.20080516150804.2337">def test_lambda_functions(self):
    self.mod.write('l = lambda: 1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    l_var = pymod['l'].get_object()
    self.assertEquals(pyobjects.get_base_type('Function'),
                      l_var.get_type())

</t>
<t tx="ekr.20080516150804.2338">def test_lambdas_that_return_unknown(self):
    self.mod.write('a_var = (lambda: None)()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(a_var is not None)

</t>
<t tx="ekr.20080516150804.2339">def test_builtin_zip_function(self):
    self.mod.write(
        'class C1(object):\n    pass\nclass C2(object):\n    pass\n'
        'c1_list = [C1()]\nc2_list = [C2()]\n'
        'a, b = zip(c1_list, c2_list)[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2340">def test_builtin_zip_function_with_more_than_two_args(self):
    self.mod.write(
        'class C1(object):\n    pass\nclass C2(object):\n    pass\n'
        'c1_list = [C1()]\nc2_list = [C2()]\n'
        'a, b, c = zip(c1_list, c2_list, c1_list)[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    c2_class = pymod['C2'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    c_var = pymod['c'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())
    self.assertEquals(c1_class, c_var.get_type())

</t>
<t tx="ekr.20080516150804.2341">def test_wrong_arguments_to_zip_function(self):
    self.mod.write(
        'class C1(object):\n    pass\nc1_list = [C1()]\n'
        'a, b = zip(c1_list, 1)[0]')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c1_class = pymod['C1'].get_object()
    a_var = pymod['a'].get_object()
    b_var = pymod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2342">def test_enumerate_builtin_function(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'for i, x in enumerate(l):\n    a_var = x\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2343">def test_builtin_class_get_name(self):
    self.assertEquals('object',
                      builtins.builtins['object'].get_object().get_name())
    self.assertEquals('property',
                      builtins.builtins['property'].get_object().get_name())

</t>
<t tx="ekr.20080516150804.2344">def test_star_args_and_double_star_args(self):
    self.mod.write('def func(p, *args, **kwds):\n    pass\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    func_scope = pymod['func'].get_object().get_scope()
    args = func_scope['args'].get_object()
    kwds = func_scope['kwds'].get_object()
    self.assertTrue(isinstance(args.get_type(), builtins.List))
    self.assertTrue(isinstance(kwds.get_type(), builtins.Dict))

</t>
<t tx="ekr.20080516150804.2345">def test_simple_list_comprehension_test(self):
    self.mod.write('a_var = [i for i in range(10)]\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(), builtins.List))

</t>
<t tx="ekr.20080516150804.2346">def test_simple_list_generator_expression(self):
    self.mod.write('a_var = (i for i in range(10))\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(), builtins.Iterator))

</t>
<t tx="ekr.20080516150804.2347">def test_iter_builtin_function(self):
    self.mod.write('class C(object):\n    pass\nl = [C()]\n'
                   'for c in iter(l):\n    a_var = c\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    c_class = pymod['C'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2348">def test_simple_int_type(self):
    self.mod.write('l = 1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['int'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2349">def test_simple_float_type(self):
    self.mod.write('l = 1.0\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['float'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2350">def test_simple_float_type2(self):
    self.mod.write('l = 1e1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['float'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2351">def test_simple_complex_type(self):
    self.mod.write('l = 1.0j\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['complex'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2352">def test_handling_unaryop_on_ints(self):
    self.mod.write('l = -(1)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['int'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2353">def test_handling_binop_on_ints(self):
    self.mod.write('l = 1 + 1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['int'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2354">def test_handling_compares(self):
    self.mod.write('l = 1 == 1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['bool'].get_object(),
                      pymod['l'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2355">def test_handling_boolops(self):
    self.mod.write('l = 1 and 2\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(builtins.builtins['int'].get_object(),
                      pymod['l'].get_object().get_type())


</t>
<t tx="ekr.20080516150804.2356">class BuiltinModulesTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2357">
def setUp(self):
    super(BuiltinModulesTest, self).setUp()
    self.project = testutils.sample_project(
        extension_modules=['time', 'invalid_module'])
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.2358">def tearDown(self):
    testutils.remove_project(self.project)
    super(BuiltinModulesTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2359">def test_simple_case(self):
    self.mod.write('import time')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('time' in pymod['time'].get_object())

</t>
<t tx="ekr.20080516150804.2360">def test_ignored_extensions(self):
    self.mod.write('import os')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('rename' not in pymod['os'].get_object())

</t>
<t tx="ekr.20080516150804.2361">def test_ignored_extensions(self):
    self.mod.write('import os')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertTrue('rename' not in pymod['os'].get_object())

</t>
<t tx="ekr.20080516150804.2362">def test_nonexistent_modules(self):
    self.mod.write('import invalid_module')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    pymod['invalid_module'].get_object()


</t>
<t tx="ekr.20080516150804.2363">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(BuiltinTypesTest))
    result.addTests(unittest.makeSuite(BuiltinModulesTest))
    return result


</t>
<t tx="ekr.20080516150804.2364">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2365">import unittest

import rope.base.evaluate
from rope.base import exceptions, ast, worder, codeanalyze
from rope.base.codeanalyze import SourceLinesAdapter, LogicalLineFinder, get_block_start
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2366">class SourceLinesAdapterTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2367">
def setUp(self):
    super(SourceLinesAdapterTest, self).setUp()

</t>
<t tx="ekr.20080516150804.2368">def tearDown(self):
    super(SourceLinesAdapterTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2369">def test_source_lines_simple(self):
    to_lines = SourceLinesAdapter('line1\nline2\n')
    self.assertEquals('line1', to_lines.get_line(1))
    self.assertEquals('line2', to_lines.get_line(2))
    self.assertEquals('', to_lines.get_line(3))
    self.assertEquals(3, to_lines.length())

</t>
<t tx="ekr.20080516150804.2370">def test_source_lines_get_line_number(self):
    to_lines = SourceLinesAdapter('line1\nline2\n')
    self.assertEquals(1, to_lines.get_line_number(0))
    self.assertEquals(1, to_lines.get_line_number(5))
    self.assertEquals(2, to_lines.get_line_number(7))
    self.assertEquals(3, to_lines.get_line_number(12))

</t>
<t tx="ekr.20080516150804.2371">def test_source_lines_get_line_start(self):
    to_lines = SourceLinesAdapter('line1\nline2\n')
    self.assertEquals(0, to_lines.get_line_start(1))
    self.assertEquals(6, to_lines.get_line_start(2))
    self.assertEquals(12, to_lines.get_line_start(3))

</t>
<t tx="ekr.20080516150804.2372">def test_source_lines_get_line_end(self):
    to_lines = SourceLinesAdapter('line1\nline2\n')
    self.assertEquals(5, to_lines.get_line_end(1))
    self.assertEquals(11, to_lines.get_line_end(2))
    self.assertEquals(12, to_lines.get_line_end(3))

</t>
<t tx="ekr.20080516150804.2373">def test_source_lines_last_line_with_no_new_line(self):
    to_lines = SourceLinesAdapter('line1')
    self.assertEquals(1, to_lines.get_line_number(5))


</t>
<t tx="ekr.20080516150804.2374">class WordRangeFinderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2375">
def setUp(self):
    super(WordRangeFinderTest, self).setUp()

</t>
<t tx="ekr.20080516150804.2376">def tearDown(self):
    super(WordRangeFinderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2377">def _find_primary(self, code, offset):
    word_finder = worder.Worder(code)
    result = word_finder.get_primary_at(offset)
    return result

</t>
<t tx="ekr.20080516150804.2378">def test_inside_parans(self):
    code = 'a_func(a_var)'
    self.assertEquals('a_var', self._find_primary(code, 10))

</t>
<t tx="ekr.20080516150804.2379">def test_simple_names(self):
    code = 'a_var = 10'
    self.assertEquals('a_var', self._find_primary(code, 3))

</t>
<t tx="ekr.20080516150804.2380">def test_function_calls(self):
    code = 'sample_function()'
    self.assertEquals('sample_function', self._find_primary(code, 10))

</t>
<t tx="ekr.20080516150804.2381">def test_attribute_accesses(self):
    code = 'a_var.an_attr'
    self.assertEquals('a_var.an_attr', self._find_primary(code, 10))

</t>
<t tx="ekr.20080516150804.2382">def test_word_finder_on_word_beginning(self):
    code = 'print a_var\n'
    word_finder = worder.Worder(code)
    result = word_finder.get_word_at(code.index('a_var'))
    self.assertEquals('a_var', result)

</t>
<t tx="ekr.20080516150804.2383">def test_word_finder_on_primary_beginning(self):
    code = 'print a_var\n'
    result = self._find_primary(code, code.index('a_var'))
    self.assertEquals('a_var', result)

</t>
<t tx="ekr.20080516150804.2384">def test_word_finder_on_word_ending(self):
    code = 'print a_var\n'
    word_finder = worder.Worder(code)
    result = word_finder.get_word_at(code.index('a_var') + 5)
    self.assertEquals('a_var', result)

</t>
<t tx="ekr.20080516150804.2385">def test_word_finder_on_primary_ending(self):
    code = 'print a_var\n'
    result = self._find_primary(code, code.index('a_var') + 5)
    self.assertEquals('a_var', result)

</t>
<t tx="ekr.20080516150804.2386">def test_word_finder_on_primaries_with_dots_inside_parens(self):
    code = '(a_var.\nattr)'
    result = self._find_primary(code, code.index('attr') + 1)
    self.assertEquals('a_var.\nattr', result)

</t>
<t tx="ekr.20080516150804.2387">def test_strings(self):
    code = '"a string".split()'
    self.assertEquals('"a string".split', self._find_primary(code, 14))

</t>
<t tx="ekr.20080516150804.2388">def test_function_calls2(self):
    code = 'file("afile.txt").read()'
    self.assertEquals('file("afile.txt").read', self._find_primary(code, 18))

</t>
<t tx="ekr.20080516150804.2389">def test_parens(self):
    code = '("afile.txt").split()'
    self.assertEquals('("afile.txt").split', self._find_primary(code, 18))

</t>
<t tx="ekr.20080516150804.2390">def test_function_with_no_param(self):
    code = 'AClass().a_func()'
    self.assertEquals('AClass().a_func', self._find_primary(code, 12))

</t>
<t tx="ekr.20080516150804.2391">def test_function_with_multiple_param(self):
    code = 'AClass(a_param, another_param, "a string").a_func()'
    self.assertEquals('AClass(a_param, another_param, "a string").a_func',
                      self._find_primary(code, 44))

</t>
<t tx="ekr.20080516150804.2392">def test_param_expressions(self):
    code = 'AClass(an_object.an_attr).a_func()'
    self.assertEquals('an_object.an_attr', self._find_primary(code, 20))

</t>
<t tx="ekr.20080516150804.2393">def test_string_parens(self):
    code = 'a_func("(").an_attr'
    self.assertEquals('a_func("(").an_attr', self._find_primary(code, 16))

</t>
<t tx="ekr.20080516150804.2394">def test_extra_spaces(self):
    code = 'a_func  (  "(" ) .   an_attr'
    self.assertEquals('a_func  (  "(" ) .   an_attr',
                      self._find_primary(code, 26))

</t>
<t tx="ekr.20080516150804.2395">def test_functions_on_ending_parens(self):
    code = 'A()'
    self.assertEquals('A()', self._find_primary(code, 2))

</t>
<t tx="ekr.20080516150804.2396">def test_splitted_statement(self):
    word_finder = worder.Worder('an_object.an_attr')
    self.assertEquals(('an_object', 'an_at', 10),
                      word_finder.get_splitted_primary_before(15))

</t>
<t tx="ekr.20080516150804.2397">def test_empty_splitted_statement(self):
    word_finder = worder.Worder('an_attr')
    self.assertEquals(('', 'an_at', 0),
                      word_finder.get_splitted_primary_before(5))

</t>
<t tx="ekr.20080516150804.2398">def test_empty_splitted_statement2(self):
    word_finder = worder.Worder('an_object.')
    self.assertEquals(('an_object', '', 10),
                      word_finder.get_splitted_primary_before(10))

</t>
<t tx="ekr.20080516150804.2399">def test_empty_splitted_statement3(self):
    word_finder = worder.Worder('')
    self.assertEquals(('', '', 0),
                      word_finder.get_splitted_primary_before(0))

</t>
<t tx="ekr.20080516150804.2400">def test_empty_splitted_statement4(self):
    word_finder = worder.Worder('a_var = ')
    self.assertEquals(('', '', 8),
                      word_finder.get_splitted_primary_before(8))

</t>
<t tx="ekr.20080516150804.2401">def test_empty_splitted_statement5(self):
    word_finder = worder.Worder('a.')
    self.assertEquals(('a', '', 2),
                      word_finder.get_splitted_primary_before(2))

</t>
<t tx="ekr.20080516150804.2402">def test_operators_inside_parens(self):
    code = '(a_var + another_var).reverse()'
    self.assertEquals('(a_var + another_var).reverse',
                      self._find_primary(code, 25))

</t>
<t tx="ekr.20080516150804.2403">def test_dictionaries(self):
    code = 'print {1: "one", 2: "two"}.keys()'
    self.assertEquals('{1: "one", 2: "two"}.keys',
                      self._find_primary(code, 29))

</t>
<t tx="ekr.20080516150804.2404">def test_following_parens(self):
    code = 'a_var = a_func()()'
    result = self._find_primary(code, code.index(')(') + 3)
    self.assertEquals('a_func()()', result)

</t>
<t tx="ekr.20080516150804.2405">def test_comments_for_finding_statements(self):
    code = '# var2 . \n  var3'
    self.assertEquals('var3', self._find_primary(code, code.index('3')))

</t>
<t tx="ekr.20080516150804.2406">def test_str_in_comments_for_finding_statements(self):
    code = '# "var2" . \n  var3'
    self.assertEquals('var3', self._find_primary(code, code.index('3')))

</t>
<t tx="ekr.20080516150804.2407">def test_comments_for_finding_statements2(self):
    code = 'var1 + "# var2".\n  var3'
    self.assertEquals('var3', self._find_primary(code, 21))

</t>
<t tx="ekr.20080516150804.2408">def test_comments_for_finding_statements3(self):
    code = '"" + # var2.\n  var3'
    self.assertEquals('var3', self._find_primary(code, 21))

</t>
<t tx="ekr.20080516150804.2409">def test_import_statement_finding(self):
    code = 'import mod\na_var = 10\n'
    word_finder = worder.Worder(code)
    self.assertTrue(word_finder.is_import_statement(code.index('mod') + 1))
    self.assertFalse(word_finder.is_import_statement(code.index('a_var') + 1))

</t>
<t tx="ekr.20080516150804.2410">def test_import_statement_finding2(self):
    code = 'import a.b.c.d\nresult = a.b.c.d.f()\n'
    word_finder = worder.Worder(code)
    self.assertFalse(word_finder.is_import_statement(code.rindex('d') + 1))

</t>
<t tx="ekr.20080516150804.2411">def test_word_parens_range(self):
    code = 's = str()\ns.title()\n'
    word_finder = worder.Worder(code)
    result = word_finder.get_word_parens_range(code.rindex('()') - 1)
    self.assertEquals((len(code) - 3, len(code) - 1), result)

</t>
<t tx="ekr.20080516150804.2412">def test_getting_primary_before_get_index(self):
    code = '\na = (b + c).d[0]()\n'
    result = self._find_primary(code, len(code) - 2)
    self.assertEquals('(b + c).d[0]()', result)

</t>
<t tx="ekr.20080516150804.2413">def test_getting_primary_and_strings_at_the_end_of_line(self):
    code = 'f(\'\\\'\')\n'
    result = self._find_primary(code, len(code) - 1)

</t>
<t tx="ekr.20080516150804.2414">def test_getting_primary_and_not_crossing_newlines(self):
    code = '\na = (b + c)\n(4 + 1).x\n'
    result = self._find_primary(code, len(code) - 1)
    self.assertEquals('(4 + 1).x', result)

</t>
<t tx="ekr.20080516150804.2415"># XXX: cancatenated string literals
def xxx_test_getting_primary_cancatenating_strs(self):
    code = 's = "a"\n"b" "c"\n'
    result = self._find_primary(code, len(code) - 2)
    self.assertEquals('"b" "c"', result)

</t>
<t tx="ekr.20080516150804.2416">def test_is_a_function_being_called_with_parens_on_next_line(self):
    code = 'func\n(1, 2)\n'
    word_finder = worder.Worder(code)
    self.assertFalse(word_finder.is_a_function_being_called(1))

</t>
<t tx="ekr.20080516150804.2417"># XXX: handling triple quotes
def xxx_test_triple_quotes(self):
    code = 's = """string"""\n'
    result = self._find_primary(code, len(code) - 1)
    self.assertEquals('"""string"""', result)

</t>
<t tx="ekr.20080516150804.2418">def test_triple_quotes_spanning_multiple_lines(self):
    code = 's = """\\\nl1\nl2\n """\n'
    result = self._find_primary(code, len(code) - 2)
    self.assertEquals('"""\\\nl1\nl2\n """', result)

</t>
<t tx="ekr.20080516150804.2419">def test_get_word_parens_range_and_string_literals(self):
    code = 'f(1, ")", 2)\n'
    word_finder = worder.Worder(code)
    result = word_finder.get_word_parens_range(0)
    self.assertEquals((1, len(code) - 1), result)

</t>
<t tx="ekr.20080516150804.2420">def test_is_assigned_here_for_equality_test(self):
    code = 'a == 1\n'
    word_finder = worder.Worder(code)
    self.assertFalse(word_finder.is_assigned_here(0))

</t>
<t tx="ekr.20080516150804.2421"># XXX: is_assigned_here should work for tuple assignments
def xxx_test_is_assigned_here_for_tuple_assignment(self):
    code = 'a, b = (1, 2)\n'
    word_finder = worder.Worder(code)
    self.assertTrue(word_finder.is_assigned_here(0))

</t>
<t tx="ekr.20080516150804.2422">def test_is_from_with_from_import_and_multiline_parens(self):
    code = 'from mod import \\\n  (f,\n  g, h)\n'
    word_finder = worder.Worder(code)
    self.assertTrue(word_finder.is_from_statement(code.rindex('g')))

</t>
<t tx="ekr.20080516150804.2423">def test_is_from_with_from_import_and_line_breaks_in_the_middle(self):
    code = 'from mod import f,\\\n g\n'
    word_finder = worder.Worder(code)
    self.assertTrue(word_finder.is_from_statement(code.rindex('g')))

</t>
<t tx="ekr.20080516150804.2424">def test_one_letter_function_keyword_arguments(self):
    code = 'f(p=1)\n'
    word_finder = worder.Worder(code)
    index = code.rindex('p')
    self.assertTrue(word_finder.is_function_keyword_parameter(index))

</t>
<t tx="ekr.20080516150804.2425">def test_find_parens_start(self):
    code = 'f(p)\n'
    finder = worder.Worder(code)
    self.assertEquals(1, finder.find_parens_start_from_inside(2))

</t>
<t tx="ekr.20080516150804.2426">def test_find_parens_start_with_multiple_entries(self):
    code = 'myfunc(p1, p2, p3\n'
    finder = worder.Worder(code)
    self.assertEquals(code.index('('),
                      finder.find_parens_start_from_inside(len(code) - 1))

</t>
<t tx="ekr.20080516150804.2427">def test_find_parens_start_with_nested_parens(self):
    code = 'myfunc(p1, (p2, p3), p4\n'
    finder = worder.Worder(code)
    self.assertEquals(code.index('('),
                      finder.find_parens_start_from_inside(len(code) - 1))

</t>
<t tx="ekr.20080516150804.2428">def test_find_parens_start_with_parens_in_strs(self):
    code = 'myfunc(p1, "(", p4\n'
    finder = worder.Worder(code)
    self.assertEquals(code.index('('),
                      finder.find_parens_start_from_inside(len(code) - 1))

</t>
<t tx="ekr.20080516150804.2429">def test_find_parens_start_with_parens_in_strs_in_multiple_lines(self):
    code = 'myfunc  (\np1\n , \n "(" \n, \np4\n'
    finder = worder.Worder(code)
    self.assertEquals(code.index('('),
                      finder.find_parens_start_from_inside(len(code) - 1))

</t>
<t tx="ekr.20080516150804.2430">def test_is_on_function_keyword(self):
    code = 'myfunc(va'
    finder = worder.Worder(code)
    self.assertTrue(finder.is_on_function_call_keyword(len(code) - 1))


</t>
<t tx="ekr.20080516150804.2431">class ScopeNameFinderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2432">
def setUp(self):
    super(ScopeNameFinderTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2433">def tearDown(self):
    testutils.remove_project(self.project)
    super(ScopeNameFinderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2434"># FIXME: in normal scopes the interpreter raises `UnboundLocalName`
# exception, but not in class bodies
def xxx_test_global_name_in_class_body(self):
    code = 'a_var = 10\nclass C(object):\n    a_var = a_var\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    result = name_finder.get_pyname_at(len(code) - 3)
    self.assertEquals(scope['a_var'], result)

</t>
<t tx="ekr.20080516150804.2435">def test_class_variable_attribute_in_class_body(self):
    code = 'a_var = 10\nclass C(object):\n    a_var = a_var\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    a_var_pyname = scope['C'].get_object()['a_var']
    result = name_finder.get_pyname_at(len(code) - 12)
    self.assertEquals(a_var_pyname, result)

</t>
<t tx="ekr.20080516150804.2436">def test_class_variable_attribute_in_class_body2(self):
    code = 'a_var = 10\nclass C(object):\n    a_var \\\n= a_var\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    a_var_pyname = scope['C'].get_object()['a_var']
    result = name_finder.get_pyname_at(len(code) - 12)
    self.assertEquals(a_var_pyname, result)

</t>
<t tx="ekr.20080516150804.2437">def test_class_method_attribute_in_class_body(self):
    code = 'class C(object):\n    def a_method(self):\n        pass\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    a_method_pyname = scope['C'].get_object()['a_method']
    result = name_finder.get_pyname_at(code.index('a_method') + 2)
    self.assertEquals(a_method_pyname, result)

</t>
<t tx="ekr.20080516150804.2438">def test_inner_class_attribute_in_class_body(self):
    code = 'class C(object):\n    class CC(object):\n        pass\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    a_class_pyname = scope['C'].get_object()['CC']
    result = name_finder.get_pyname_at(code.index('CC') + 2)
    self.assertEquals(a_class_pyname, result)

</t>
<t tx="ekr.20080516150804.2439">def test_class_method_in_class_body_but_not_indexed(self):
    code = 'class C(object):\n    def func(self, func):\n        pass\n'
    scope = self.pycore.get_string_scope(code)
    a_func_pyname = scope.get_scopes()[0].get_scopes()[0]['func']
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    result = name_finder.get_pyname_at(code.index(', func') + 3)
    self.assertEquals(a_func_pyname, result)

</t>
<t tx="ekr.20080516150804.2440">def test_function_but_not_indexed(self):
    code = 'def a_func(a_func):\n    pass\n'
    scope = self.pycore.get_string_scope(code)
    a_func_pyname = scope['a_func']
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    result = name_finder.get_pyname_at(code.index('a_func') + 3)
    self.assertEquals(a_func_pyname, result)

</t>
<t tx="ekr.20080516150804.2441">def test_modules_after_from_statements(self):
    root_folder = self.project.root
    mod = testutils.create_module(self.project, 'mod', root_folder)
    mod.write('def a_func():\n    pass\n')
    code = 'from mod import a_func\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    mod_pyobject = self.pycore.resource_to_pyobject(mod)
    found_pyname = name_finder.get_pyname_at(code.index('mod') + 1)
    self.assertEquals(mod_pyobject, found_pyname.get_object())

</t>
<t tx="ekr.20080516150804.2442">def test_renaming_functions_with_from_import_and_parens(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def afunc():\n    pass\n')
    code = 'from mod1 import (\n    afunc as func)\n'
    scope = self.pycore.get_string_scope(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(scope.pyobject)
    mod_pyobject = self.pycore.resource_to_pyobject(mod1)
    afunc = mod_pyobject['afunc']
    found_pyname = name_finder.get_pyname_at(code.index('afunc') + 1)
    self.assertEquals(afunc.get_object(), found_pyname.get_object())

</t>
<t tx="ekr.20080516150804.2443">@testutils.run_only_for_25
def test_relative_modules_after_from_statements(self):
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    mod1 = testutils.create_module(self.project, 'mod1', pkg1)
    mod2 = testutils.create_module(self.project, 'mod2', pkg2)
    mod1.write('def a_func():\n    pass\n')
    code = 'from ..mod1 import a_func\n'
    mod2.write(code)
    mod2_scope = self.pycore.resource_to_pyobject(mod2).get_scope()
    name_finder = rope.base.evaluate.ScopeNameFinder(mod2_scope.pyobject)
    mod1_pyobject = self.pycore.resource_to_pyobject(mod1)
    found_pyname = name_finder.get_pyname_at(code.index('mod1') + 1)
    self.assertEquals(mod1_pyobject, found_pyname.get_object())

</t>
<t tx="ekr.20080516150804.2444">def test_relative_modules_after_from_statements2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    mod2 = testutils.create_module(self.project, 'mod2', pkg2)
    mod1.write('import pkg1.pkg2.mod2')

    mod1_scope = self.pycore.resource_to_pyobject(mod1).get_scope()
    name_finder = rope.base.evaluate.ScopeNameFinder(mod1_scope.pyobject)
    pkg2_pyobject = self.pycore.resource_to_pyobject(pkg2)
    found_pyname = name_finder.get_pyname_at(mod1.read().index('pkg2') + 1)
    self.assertEquals(pkg2_pyobject, found_pyname.get_object())

</t>
<t tx="ekr.20080516150804.2445">@testutils.assert_raises(exceptions.RopeError)
def test_get_pyname_at_on_language_keywords(self):
    code = 'def a_func(a_func):\n    pass\n'
    pymod = self.pycore.get_string_module(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(pymod)
    name_finder.get_pyname_at(code.index('pass'))

</t>
<t tx="ekr.20080516150804.2446">def test_one_liners(self):
    code = 'var = 1\ndef f(): var = 2\nprint var\n'
    pymod = self.pycore.get_string_module(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(pymod)
    pyname = name_finder.get_pyname_at(code.rindex('var'))
    self.assertEquals(pymod['var'], pyname)

</t>
<t tx="ekr.20080516150804.2447">def test_one_liners_with_line_breaks(self):
    code = 'var = 1\ndef f(\n): var = 2\nprint var\n'
    pymod = self.pycore.get_string_module(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(pymod)
    pyname = name_finder.get_pyname_at(code.rindex('var'))
    self.assertEquals(pymod['var'], pyname)

</t>
<t tx="ekr.20080516150804.2448">def test_one_liners_with_line_breaks2(self):
    code = 'var = 1\ndef f(\np): var = 2\nprint var\n'
    pymod = self.pycore.get_string_module(code)
    name_finder = rope.base.evaluate.ScopeNameFinder(pymod)
    pyname = name_finder.get_pyname_at(code.rindex('var'))
    self.assertEquals(pymod['var'], pyname)


</t>
<t tx="ekr.20080516150804.2449">class LogicalLineFinderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2450">
def setUp(self):
    super(LogicalLineFinderTest, self).setUp()

</t>
<t tx="ekr.20080516150804.2451">def tearDown(self):
    super(LogicalLineFinderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2452">def _logical_finder(self, code):
    return LogicalLineFinder(SourceLinesAdapter(code))

</t>
<t tx="ekr.20080516150804.2453">def test_normal_lines(self):
    code = 'a_var = 10'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 1), line_finder.logical_line_in(1))

</t>
<t tx="ekr.20080516150804.2454">def test_normal_lines2(self):
    code = 'another = 10\na_var = 20\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 1), line_finder.logical_line_in(1))
    self.assertEquals((2, 2), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2455">def test_implicit_continuation(self):
    code = 'a_var = 3 + \\\n    4 + \\\n    5'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 3), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2456">def test_explicit_continuation(self):
    code = 'print 2\na_var = (3 + \n    4, \n    5)\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((2, 4), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2457">def test_explicit_continuation_comments(self):
    code = '#\na_var = 3\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((2, 2), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2458">def test_multiple_indented_ifs(self):
    code = 'if True:\n    if True:\n        if True:\n            pass\n    a = 10\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((5, 5), line_finder.logical_line_in(5))

</t>
<t tx="ekr.20080516150804.2459">def test_list_comprehensions_and_fors(self):
    code = 'a_list = [i\n    for i in range(10)]\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 2), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2460">def test_generator_expressions_and_fors(self):
    code = 'a_list = (i\n    for i in range(10))\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 2), line_finder.logical_line_in(2))

</t>
<t tx="ekr.20080516150804.2461">def test_fors_and_block_start(self):
    code = 'l = range(10)\nfor i in l:\n    print i\n'
    self.assertEquals(2, get_block_start(SourceLinesAdapter(code), 2))

</t>
<t tx="ekr.20080516150804.2462">def test_problems_with_inner_indentations(self):
    code = 'if True:\n    if True:\n        if True:\n            pass\n' \
           '    a = \\\n        1\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((5, 6), line_finder.logical_line_in(6))

</t>
<t tx="ekr.20080516150804.2463">def test_problems_with_inner_indentations2(self):
    code = 'if True:\n    if True:\n        pass\n' \
           'a = 1\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((4, 4), line_finder.logical_line_in(4))

</t>
<t tx="ekr.20080516150804.2464">def test_logical_lines_for_else(self):
    code = 'if True:\n    pass\nelse:\n    pass\n'
    line_finder = self._logical_finder(code)
    self.assertEquals((3, 3), line_finder.logical_line_in(3))

</t>
<t tx="ekr.20080516150804.2465">def test_logical_lines_for_lines_with_wrong_continues(self):
    code = 'var = 1 + \\'
    line_finder = self._logical_finder(code)
    self.assertEquals((1, 1), line_finder.logical_line_in(1))

</t>
<t tx="ekr.20080516150804.2466">def test_generating_line_starts(self):
    code = 'a = 1\na = 2\n\na = 3\n'
    line_finder = self._logical_finder(code)
    self.assertEquals([1, 2, 4], list(line_finder.generate_starts()))

</t>
<t tx="ekr.20080516150804.2467">def test_generating_line_starts2(self):
    code = 'a = 1\na = 2\n\na = \\ 3\n'
    line_finder = LogicalLineFinder(SourceLinesAdapter(code))
    self.assertEquals([2, 4], list(line_finder.generate_starts(2)))

</t>
<t tx="ekr.20080516150804.2468">def test_generating_line_starts3(self):
    code = 'a = 1\na = 2\n\na = \\ 3\n'
    line_finder = LogicalLineFinder(SourceLinesAdapter(code))
    self.assertEquals([2], list(line_finder.generate_starts(2, 3)))

</t>
<t tx="ekr.20080516150804.2469">def test_generating_line_starts_for_multi_line_statements(self):
    code = '\na = \\\n 1 + \\\n 1\n'
    line_finder = self._logical_finder(code)
    self.assertEquals([2], list(line_finder.generate_starts()))

</t>
<t tx="ekr.20080516150804.2470">def test_generating_line_starts_and_unmatched_deindents(self):
    code = 'if True:\n    if True:\n        if True:\n' \
           '            a = 1\n    b = 1\n'
    line_finder = self._logical_finder(code)
    self.assertEquals([4, 5], list(line_finder.generate_starts(4)))

</t>
<t tx="ekr.20080516150804.2471">class TokenizerLogicalLineFinderTest(LogicalLineFinderTest):
    @others
</t>
<t tx="ekr.20080516150804.2472">
def _logical_finder(self, code):
    lines = SourceLinesAdapter(code)
    return codeanalyze.CachingLogicalLineFinder(
        lines, codeanalyze.tokenizer_generator)

</t>
<t tx="ekr.20080516150804.2473">class CustomLogicalLineFinderTest(LogicalLineFinderTest):
    @others
</t>
<t tx="ekr.20080516150804.2474">
def _logical_finder(self, code):
    lines = SourceLinesAdapter(code)
    return codeanalyze.CachingLogicalLineFinder(
        lines, codeanalyze.custom_generator)


</t>
<t tx="ekr.20080516150804.2475">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(SourceLinesAdapterTest))
    result.addTests(unittest.makeSuite(WordRangeFinderTest))
    result.addTests(unittest.makeSuite(ScopeNameFinderTest))
    result.addTests(unittest.makeSuite(LogicalLineFinderTest))
    result.addTests(unittest.makeSuite(TokenizerLogicalLineFinderTest))
    result.addTests(unittest.makeSuite(CustomLogicalLineFinderTest))
    return result

</t>
<t tx="ekr.20080516150804.2476">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2477">import unittest

import rope.base.history
from rope.base import exceptions
from rope.base.change import *
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2478">class HistoryTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2479">
def setUp(self):
    super(HistoryTest, self).setUp()
    self.project = testutils.sample_project()
    self.history = self.project.history

</t>
<t tx="ekr.20080516150804.2480">def tearDown(self):
    testutils.remove_project(self.project)
    super(HistoryTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2481">def test_undoing_writes(self):
    my_file = self.project.root.create_file('my_file.txt')
    my_file.write('text1')
    self.history.undo()
    self.assertEquals('', my_file.read())

</t>
<t tx="ekr.20080516150804.2482">def test_moving_files(self):
    my_file = self.project.root.create_file('my_file.txt')
    my_file.move('new_file.txt')
    self.history.undo()
    self.assertEquals('', my_file.read())

</t>
<t tx="ekr.20080516150804.2483">def test_moving_files_to_folders(self):
    my_file = self.project.root.create_file('my_file.txt')
    my_folder = self.project.root.create_folder('my_folder')
    my_file.move(my_folder.path)
    self.history.undo()
    self.assertEquals('', my_file.read())

</t>
<t tx="ekr.20080516150804.2484">def test_writing_files_that_does_not_change_contents(self):
    my_file = self.project.root.create_file('my_file.txt')
    my_file.write('')
    self.project.history.undo()
    self.assertFalse(my_file.exists())


</t>
<t tx="ekr.20080516150804.2485">class IsolatedHistoryTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2486">
def setUp(self):
    super(IsolatedHistoryTest, self).setUp()
    self.project = testutils.sample_project()
    self.history = rope.base.history.History(self.project)
    self.file1 = self.project.root.create_file('file1.txt')
    self.file2 = self.project.root.create_file('file2.txt')

</t>
<t tx="ekr.20080516150804.2487">def tearDown(self):
    testutils.remove_project(self.project)
    super(IsolatedHistoryTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2488">def test_simple_undo(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.assertEquals('1', self.file1.read())
    self.history.undo()
    self.assertEquals('', self.file1.read())

</t>
<t tx="ekr.20080516150804.2489">def test_tobe_undone(self):
    change1 = ChangeContents(self.file1, '1')
    self.assertEquals(None, self.history.tobe_undone)
    self.history.do(change1)
    self.assertEquals(change1, self.history.tobe_undone)
    change2 = ChangeContents(self.file1, '2')
    self.history.do(change2)
    self.assertEquals(change2, self.history.tobe_undone)
    self.history.undo()
    self.assertEquals(change1, self.history.tobe_undone)

</t>
<t tx="ekr.20080516150804.2490">def test_tobe_redone(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.assertEquals(None, self.history.tobe_redone)
    self.history.undo()
    self.assertEquals(change, self.history.tobe_redone)

</t>
<t tx="ekr.20080516150804.2491">@testutils.assert_raises(exceptions.HistoryError)
def test_undo_limit(self):
    history = rope.base.history.History(self.project, maxundos=1)
    history.do(ChangeContents(self.file1, '1'))
    history.do(ChangeContents(self.file1, '2'))
    try:
        history.undo()
        history.undo()
    finally:
        self.assertEquals('1', self.file1.read())

</t>
<t tx="ekr.20080516150804.2492">def test_simple_redo(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.history.undo()
    self.history.redo()
    self.assertEquals('1', self.file1.read())

</t>
<t tx="ekr.20080516150804.2493">def test_simple_re_undo(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.history.undo()
    self.history.redo()
    self.history.undo()
    self.assertEquals('', self.file1.read())

</t>
<t tx="ekr.20080516150804.2494">def test_multiple_undos(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    change = ChangeContents(self.file1, '2')
    self.history.do(change)
    self.history.undo()
    self.assertEquals('1', self.file1.read())
    change = ChangeContents(self.file1, '3')
    self.history.do(change)
    self.history.undo()
    self.assertEquals('1', self.file1.read())
    self.history.redo()
    self.assertEquals('3', self.file1.read())

</t>
<t tx="ekr.20080516150804.2495">@testutils.assert_raises(exceptions.HistoryError)
def test_undo_list_underflow(self):
    self.history.undo()

</t>
<t tx="ekr.20080516150804.2496">@testutils.assert_raises(exceptions.HistoryError)
def test_redo_list_underflow(self):
    self.history.redo()

</t>
<t tx="ekr.20080516150804.2497">def test_undoing_choosen_changes(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.history.undo(change)
    self.assertEquals('', self.file1.read())
    self.assertFalse(self.history.undo_list)

</t>
<t tx="ekr.20080516150804.2498">def test_undoing_choosen_changes2(self):
    change1 = ChangeContents(self.file1, '1')
    self.history.do(change1)
    self.history.do(ChangeContents(self.file1, '2'))
    self.history.undo(change1)
    self.assertEquals('', self.file1.read())
    self.assertFalse(self.history.undo_list)

</t>
<t tx="ekr.20080516150804.2499">def test_undoing_choosen_changes_not_undoing_others(self):
    change1 = ChangeContents(self.file1, '1')
    self.history.do(change1)
    self.history.do(ChangeContents(self.file2, '2'))
    self.history.undo(change1)
    self.assertEquals('', self.file1.read())
    self.assertEquals('2', self.file2.read())

</t>
<t tx="ekr.20080516150804.2500">def test_undoing_writing_after_moving(self):
    change1 = ChangeContents(self.file1, '1')
    self.history.do(change1)
    self.history.do(MoveResource(self.file1, 'file3.txt'))
    file3 = self.project.get_resource('file3.txt')
    self.history.undo(change1)
    self.assertEquals('', self.file1.read())
    self.assertFalse(file3.exists())

</t>
<t tx="ekr.20080516150804.2501">def test_undoing_folder_movements_for_undoing_writes_inside_it(self):
    folder = self.project.root.create_folder('folder')
    file3 = folder.create_file('file3.txt')
    change1 = ChangeContents(file3, '1')
    self.history.do(change1)
    self.history.do(MoveResource(folder, 'new_folder'))
    new_folder = self.project.get_resource('new_folder')
    self.history.undo(change1)
    self.assertEquals('', file3.read())
    self.assertFalse(new_folder.exists())

</t>
<t tx="ekr.20080516150804.2502">def test_undoing_changes_that_depend_on_a_dependant_change(self):
    change1 = ChangeContents(self.file1, '1')
    self.history.do(change1)
    changes = ChangeSet('2nd change')
    changes.add_change(ChangeContents(self.file1, '2'))
    changes.add_change(ChangeContents(self.file2, '2'))
    self.history.do(changes)
    self.history.do(MoveResource(self.file2, 'file3.txt'))
    file3 = self.project.get_resource('file3.txt')

    self.history.undo(change1)
    self.assertEquals('', self.file1.read())
    self.assertEquals('', self.file2.read())
    self.assertFalse(file3.exists())

</t>
<t tx="ekr.20080516150804.2503">def test_undoing_writes_for_undoing_folder_movements_containing_it(self):
    folder = self.project.root.create_folder('folder')
    old_file = folder.create_file('file3.txt')
    change1 = MoveResource(folder, 'new_folder')
    self.history.do(change1)
    new_file = self.project.get_resource('new_folder/file3.txt')
    self.history.do(ChangeContents(new_file, '1'))
    self.history.undo(change1)
    self.assertEquals('', old_file.read())
    self.assertFalse(new_file.exists())

</t>
<t tx="ekr.20080516150804.2504">@testutils.assert_raises(exceptions.HistoryError)
def test_undoing_not_available_change(self):
    change = ChangeContents(self.file1, '1')
    self.history.undo(change)

</t>
<t tx="ekr.20080516150804.2505">def test_ignoring_ignored_resources(self):
    self.project.set('ignored_resources', ['ignored*'])
    ignored = self.project.get_file('ignored.txt')
    change = CreateResource(ignored)
    self.history.do(change)
    self.assertTrue(ignored.exists())
    self.assertEquals(0, len(self.history.undo_list))

</t>
<t tx="ekr.20080516150804.2506">def test_get_file_undo_list_simple(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.assertEquals(set([change]),
                      set(self.history.get_file_undo_list(self.file1)))

</t>
<t tx="ekr.20080516150804.2507">def test_get_file_undo_list_for_moves(self):
    change = MoveResource(self.file1, 'file2.txt')
    self.history.do(change)
    self.assertEquals(set([change]),
                      set(self.history.get_file_undo_list(self.file1)))

</t>
<t tx="ekr.20080516150804.2508"># XXX: What happens for moves before the file is created?
def xxx_test_get_file_undo_list_and_moving_its_contining_folder(self):
    folder = self.project.root.create_folder('folder')
    old_file = folder.create_file('file3.txt')
    change1 = MoveResource(folder, 'new_folder')
    self.history.do(change1)
    self.assertEquals(set([change1]),
                      set(self.history.get_file_undo_list(old_file)))

</t>
<t tx="ekr.20080516150804.2509">def test_clearing_redo_list_after_do(self):
    change = ChangeContents(self.file1, '1')
    self.history.do(change)
    self.history.undo()
    self.history.do(change)
    self.assertEquals(0, len(self.history.redo_list))

</t>
<t tx="ekr.20080516150804.2510">@testutils.assert_raises(exceptions.HistoryError)
def test_undoing_a_not_yet_performed_change(self):
    change = ChangeContents(self.file1, '1')
    str(change)
    change.undo()

</t>
<t tx="ekr.20080516150804.2511">def test_clearing_up_the_history(self):
    change1 = ChangeContents(self.file1, '1')
    change2 = ChangeContents(self.file1, '2')
    self.history.do(change1)
    self.history.do(change2)
    self.history.undo()
    self.history.clear()
    self.assertEquals(0, len(self.history.undo_list))
    self.assertEquals(0, len(self.history.redo_list))

</t>
<t tx="ekr.20080516150804.2512">def test_redoing_choosen_changes_not_undoing_others(self):
    change1 = ChangeContents(self.file1, '1')
    change2 = ChangeContents(self.file2, '2')
    self.history.do(change1)
    self.history.do(change2)
    self.history.undo()
    self.history.undo()
    redone = self.history.redo(change2)
    self.assertEquals([change2], redone)
    self.assertEquals('', self.file1.read())
    self.assertEquals('2', self.file2.read())


</t>
<t tx="ekr.20080516150804.2513">class SavingHistoryTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2514">
def setUp(self):
    super(SavingHistoryTest, self).setUp()
    self.project = testutils.sample_project()
    self.history = rope.base.history.History(self.project)
    self.to_data = ChangeToData()
    self.to_change = DataToChange(self.project)

</t>
<t tx="ekr.20080516150804.2515">def tearDown(self):
    testutils.remove_project(self.project)
    super(SavingHistoryTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2516">def test_simple_set_saving(self):
    data = self.to_data(ChangeSet('testing'))
    change = self.to_change(data)
    self.assertEquals('testing', str(change))

</t>
<t tx="ekr.20080516150804.2517">def test_simple_change_content_saving(self):
    myfile = self.project.get_file('myfile.txt')
    myfile.create()
    myfile.write('1')
    data = self.to_data(ChangeContents(myfile, '2'))
    change = self.to_change(data)
    self.history.do(change)
    self.assertEquals('2', myfile.read())
    self.history.undo()
    self.assertEquals('1', change.old_contents)

</t>
<t tx="ekr.20080516150804.2518">def test_move_resource_saving(self):
    myfile = self.project.root.create_file('myfile.txt')
    myfolder = self.project.root.create_folder('myfolder')
    data = self.to_data(MoveResource(myfile, 'myfolder'))
    change = self.to_change(data)
    self.history.do(change)
    self.assertFalse(myfile.exists())
    self.assertTrue(myfolder.has_child('myfile.txt'))
    self.history.undo()
    self.assertTrue(myfile.exists())
    self.assertFalse(myfolder.has_child('myfile.txt'))

</t>
<t tx="ekr.20080516150804.2519">def test_move_resource_saving_for_folders(self):
    myfolder = self.project.root.create_folder('myfolder')
    newfolder = self.project.get_folder('newfolder')
    change = MoveResource(myfolder, 'newfolder')
    self.history.do(change)

    data = self.to_data(change)
    change = self.to_change(data)
    change.undo()
    self.assertTrue(myfolder.exists())
    self.assertFalse(newfolder.exists())

</t>
<t tx="ekr.20080516150804.2520">def test_create_file_saving(self):
    myfile = self.project.get_file('myfile.txt')
    data = self.to_data(CreateFile(self.project.root, 'myfile.txt'))
    change = self.to_change(data)
    self.history.do(change)
    self.assertTrue(myfile.exists())
    self.history.undo()
    self.assertFalse(myfile.exists())

</t>
<t tx="ekr.20080516150804.2521">def test_create_folder_saving(self):
    myfolder = self.project.get_folder('myfolder')
    data = self.to_data(CreateFolder(self.project.root, 'myfolder'))
    change = self.to_change(data)
    self.history.do(change)
    self.assertTrue(myfolder.exists())
    self.history.undo()
    self.assertFalse(myfolder.exists())

</t>
<t tx="ekr.20080516150804.2522">def test_create_resource_saving(self):
    myfile = self.project.get_file('myfile.txt')
    data = self.to_data(CreateResource(myfile))
    change = self.to_change(data)
    self.history.do(change)
    self.assertTrue(myfile.exists())
    self.history.undo()
    self.assertFalse(myfile.exists())

</t>
<t tx="ekr.20080516150804.2523">def test_remove_resource_saving(self):
    myfile = self.project.root.create_file('myfile.txt')
    data = self.to_data(RemoveResource(myfile))
    change = self.to_change(data)
    self.history.do(change)
    self.assertFalse(myfile.exists())

</t>
<t tx="ekr.20080516150804.2524">def test_change_set_saving(self):
    change = ChangeSet('testing')
    myfile = self.project.get_file('myfile.txt')
    change.add_change(CreateResource(myfile))
    change.add_change(ChangeContents(myfile, '1'))

    data = self.to_data(change)
    change = self.to_change(data)
    self.history.do(change)
    self.assertEquals('1', myfile.read())
    self.history.undo()
    self.assertFalse(myfile.exists())

</t>
<t tx="ekr.20080516150804.2525">def test_writing_and_reading_history(self):
    history_file = self.project.get_file('history.pickle')
    self.project.set('save_history', True)
    history = rope.base.history.History(self.project)
    myfile = self.project.get_file('myfile.txt')
    history.do(CreateResource(myfile))
    history.write()

    history = rope.base.history.History(self.project)
    history.undo()
    self.assertFalse(myfile.exists())

</t>
<t tx="ekr.20080516150804.2526">def test_writing_and_reading_history2(self):
    history_file = self.project.get_file('history.pickle')
    self.project.set('save_history', True)
    history = rope.base.history.History(self.project)
    myfile = self.project.get_file('myfile.txt')
    history.do(CreateResource(myfile))
    history.undo()
    history.write()

    history = rope.base.history.History(self.project)
    history.redo()
    self.assertTrue(myfile.exists())


</t>
<t tx="ekr.20080516150804.2527">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(HistoryTest))
    result.addTests(unittest.makeSuite(IsolatedHistoryTest))
    result.addTests(unittest.makeSuite(SavingHistoryTest))
    return result

</t>
<t tx="ekr.20080516150804.2528">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2529">import unittest

from rope.base.oi import objectdb, memorydb
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2530">def _do_for_all_dbs(function):
    def called(self):
        for db in self.dbs:
            function(self, db)
    return called


</t>
<t tx="ekr.20080516150804.2531">class _MockValidation(object):
    @others
</t>
<t tx="ekr.20080516150804.2532">
def is_value_valid(self, value):
    return value != -1

</t>
<t tx="ekr.20080516150804.2533">def is_more_valid(self, new, old):
    return new != -1

</t>
<t tx="ekr.20080516150804.2534">def is_file_valid(self, path):
    return path != 'invalid'

</t>
<t tx="ekr.20080516150804.2535">def is_scope_valid(self, path, key):
    return path != 'invalid' and key != 'invalid'


</t>
<t tx="ekr.20080516150804.2536">class _MockFileListObserver(object):

    log = ''

    @others
</t>
<t tx="ekr.20080516150804.2537">def added(self, path):
    self.log += 'added %s ' % path

</t>
<t tx="ekr.20080516150804.2538">def removed(self, path):
    self.log += 'removed %s ' % path


</t>
<t tx="ekr.20080516150804.2539">class ObjectDBTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2540">
def setUp(self):
    super(ObjectDBTest, self).setUp()
    self.project = testutils.sample_project()
    validation = _MockValidation()
    self.dbs = [
        objectdb.ObjectDB(memorydb.MemoryDB(self.project), validation)]

</t>
<t tx="ekr.20080516150804.2541">def tearDown(self):
    for db in self.dbs:
        db.write()
    testutils.remove_project(self.project)
    super(ObjectDBTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2542">@_do_for_all_dbs
def test_simple_per_name(self, db):
    db.add_pername('file', 'key', 'name', 1)
    self.assertEqual(1, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2543">@_do_for_all_dbs
def test_simple_per_name_does_not_exist(self, db):
    self.assertEquals(None, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2544">@_do_for_all_dbs
def test_simple_per_name_after_syncing(self, db):
    db.add_pername('file', 'key', 'name', 1)
    db.write()
    self.assertEquals(1, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2545">@_do_for_all_dbs
def test_getting_returned(self, db):
    db.add_callinfo('file', 'key', (1, 2), 3)
    self.assertEquals(3, db.get_returned('file', 'key', (1, 2)))

</t>
<t tx="ekr.20080516150804.2546">@_do_for_all_dbs
def test_getting_returned_when_does_not_match(self, db):
    db.add_callinfo('file', 'key', (1, 2), 3)
    self.assertEquals(None, db.get_returned('file', 'key', (1, 1)))

</t>
<t tx="ekr.20080516150804.2547">@_do_for_all_dbs
def test_getting_call_info(self, db):
    db.add_callinfo('file', 'key', (1, 2), 3)

    call_infos = list(db.get_callinfos('file', 'key'))
    self.assertEquals(1, len(call_infos))
    self.assertEquals((1, 2), call_infos[0].get_parameters())
    self.assertEquals(3, call_infos[0].get_returned())

</t>
<t tx="ekr.20080516150804.2548">@_do_for_all_dbs
def test_invalid_per_name(self, db):
    db.add_pername('file', 'key', 'name', -1)
    self.assertEquals(None, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2549">@_do_for_all_dbs
def test_overwriting_per_name(self, db):
    db.add_pername('file', 'key', 'name', 1)
    db.add_pername('file', 'key', 'name', 2)
    self.assertEquals(2, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2550">@_do_for_all_dbs
def test_not_overwriting_with_invalid_per_name(self, db):
    db.add_pername('file', 'key', 'name', 1)
    db.add_pername('file', 'key', 'name', -1)
    self.assertEquals(1, db.get_pername('file', 'key', 'name'))

</t>
<t tx="ekr.20080516150804.2551">@_do_for_all_dbs
def test_getting_invalid_returned(self, db):
    db.add_callinfo('file', 'key', (1, 2), -1)
    self.assertEquals(None, db.get_returned('file', 'key', (1, 2)))

</t>
<t tx="ekr.20080516150804.2552">@_do_for_all_dbs
def test_not_overwriting_with_invalid_returned(self, db):
    db.add_callinfo('file', 'key', (1, 2), 3)
    db.add_callinfo('file', 'key', (1, 2), -1)
    self.assertEquals(3, db.get_returned('file', 'key', (1, 2)))

</t>
<t tx="ekr.20080516150804.2553">@_do_for_all_dbs
def test_get_files(self, db):
    db.add_callinfo('file1', 'key', (1, 2), 3)
    db.add_callinfo('file2', 'key', (1, 2), 3)
    self.assertEquals(set(['file1', 'file2']), set(db.get_files()))

</t>
<t tx="ekr.20080516150804.2554">@_do_for_all_dbs
def test_validating_files(self, db):
    db.add_callinfo('invalid', 'key', (1, 2), 3)
    db.validate_files()
    self.assertEquals(0, len(db.get_files()))

</t>
<t tx="ekr.20080516150804.2555">@_do_for_all_dbs
def test_validating_file_for_scopes(self, db):
    db.add_callinfo('file', 'invalid', (1, 2), 3)
    db.validate_file('file')
    self.assertEquals(1, len(db.get_files()))
    self.assertEquals(0, len(list(db.get_callinfos('file', 'invalid'))))

</t>
<t tx="ekr.20080516150804.2556">@_do_for_all_dbs
def test_validating_file_moved(self, db):
    db.add_callinfo('file', 'key', (1, 2), 3)

    db.file_moved('file', 'newfile')
    self.assertEquals(1, len(db.get_files()))
    self.assertEquals(1, len(list(db.get_callinfos('newfile', 'key'))))

</t>
<t tx="ekr.20080516150804.2557">@_do_for_all_dbs
def test_using_file_list_observer(self, db):
    db.add_callinfo('invalid', 'key', (1, 2), 3)
    observer = _MockFileListObserver()
    db.add_file_list_observer(observer)
    db.validate_files()
    self.assertEquals('removed invalid ', observer.log)


</t>
<t tx="ekr.20080516150804.2558">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(ObjectDBTest))
    return result


</t>
<t tx="ekr.20080516150804.2559">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2560">import unittest

import rope.base.project
import rope.base.builtins
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2561">class ObjectInferTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2562">
def setUp(self):
    super(ObjectInferTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2563">def tearDown(self):
    testutils.remove_project(self.project)
    super(ObjectInferTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2564">def test_simple_type_inferencing(self):
    code = 'class Sample(object):\n    pass\na_var = Sample()\n'
    scope = self.pycore.get_string_scope(code)
    sample_class = scope['Sample'].get_object()
    a_var = scope['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2565">def test_simple_type_inferencing_classes_defined_in_holding_scope(self):
    code = 'class Sample(object):\n    pass\n' \
           'def a_func():\n    a_var = Sample()\n'
    scope = self.pycore.get_string_scope(code)
    sample_class = scope['Sample'].get_object()
    a_var = scope['a_func'].get_object().\
                    get_scope()['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2566">def test_simple_type_inferencing_classes_in_class_methods(self):
    code = 'class Sample(object):\n    pass\n' \
           'class Another(object):\n' \
           '    def a_method():\n        a_var = Sample()\n'
    scope = self.pycore.get_string_scope(code)
    sample_class = scope['Sample'].get_object()
    another_class = scope['Another'].get_object()
    a_var = another_class['a_method'].\
                    get_object().get_scope()['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2567">def test_simple_type_inferencing_class_attributes(self):
    code = 'class Sample(object):\n    pass\n' \
           'class Another(object):\n' \
           '    def __init__(self):\n        self.a_var = Sample()\n'
    scope = self.pycore.get_string_scope(code)
    sample_class = scope['Sample'].get_object()
    another_class = scope['Another'].get_object()
    a_var = another_class['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2568">def test_simple_type_inferencing_for_in_class_assignments(self):
    code = 'class Sample(object):\n    pass\n' \
           'class Another(object):\n    an_attr = Sample()\n'
    scope = self.pycore.get_string_scope(code)
    sample_class = scope['Sample'].get_object()
    another_class = scope['Another'].get_object()
    an_attr = another_class['an_attr'].get_object()
    self.assertEquals(sample_class, an_attr.get_type())

</t>
<t tx="ekr.20080516150804.2569">def test_simple_type_inferencing_for_chained_assignments(self):
    mod = 'class Sample(object):\n    pass\n' \
          'copied_sample = Sample'
    mod_scope = self.project.get_pycore().get_string_scope(mod)
    sample_class = mod_scope['Sample']
    copied_sample = mod_scope['copied_sample']
    self.assertEquals(sample_class.get_object(),
                      copied_sample.get_object())

</t>
<t tx="ekr.20080516150804.2570">def test_following_chained_assignments_avoiding_circles(self):
    mod = 'class Sample(object):\n    pass\n' \
          'sample_class = Sample\n' \
          'sample_class = sample_class\n'
    mod_scope = self.project.get_pycore().get_string_scope(mod)
    sample_class = mod_scope['Sample']
    sample_class_var = mod_scope['sample_class']
    self.assertEquals(sample_class.get_object(),
                      sample_class_var.get_object())

</t>
<t tx="ekr.20080516150804.2571">def test_function_returned_object_static_type_inference1(self):
    src = 'class Sample(object):\n    pass\n' \
          'def a_func():\n    return Sample\n' \
          'a_var = a_func()\n'
    scope = self.project.get_pycore().get_string_scope(src)
    sample_class = scope['Sample']
    a_var = scope['a_var']
    self.assertEquals(sample_class.get_object(), a_var.get_object())

</t>
<t tx="ekr.20080516150804.2572">def test_function_returned_object_static_type_inference2(self):
    src = 'class Sample(object):\n    pass\n' \
          'def a_func():\n    return Sample()\n' \
          'a_var = a_func()\n'
    scope = self.project.get_pycore().get_string_scope(src)
    sample_class = scope['Sample'].get_object()
    a_var = scope['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2573">def test_recursive_function_returned_object_static_type_inference(self):
    src = 'class Sample(object):\n    pass\n' \
          'def a_func():\n' \
          '    if True:\n        return Sample()\n' \
          '    else:\n        return a_func()\n' \
          'a_var = a_func()\n'
    scope = self.project.get_pycore().get_string_scope(src)
    sample_class = scope['Sample'].get_object()
    a_var = scope['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2574">def test_function_returned_object_using_call_special_function_static_type_inference(self):
    src = 'class Sample(object):\n' \
          '    def __call__(self):\n        return Sample\n' \
          'sample = Sample()\na_var = sample()'
    scope = self.project.get_pycore().get_string_scope(src)
    sample_class = scope['Sample']
    a_var = scope['a_var']
    self.assertEquals(sample_class.get_object(), a_var.get_object())

</t>
<t tx="ekr.20080516150804.2575">def test_list_type_inferencing(self):
    src = 'class Sample(object):\n    pass\na_var = [Sample()]\n'
    scope = self.pycore.get_string_scope(src)
    sample_class = scope['Sample'].get_object()
    a_var = scope['a_var'].get_object()
    self.assertNotEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2576">def test_attributed_object_inference(self):
    src = 'class Sample(object):\n' \
          '    def __init__(self):\n        self.a_var = None\n' \
          '    def set(self):\n        self.a_var = Sample()\n'
    scope = self.pycore.get_string_scope(src)
    sample_class = scope['Sample'].get_object()
    a_var = sample_class['a_var'].get_object()
    self.assertEquals(sample_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2577">def test_getting_property_attributes(self):
    src = 'class A(object):\n    pass\n' \
          'def f(*args):\n    return A()\n' \
          'class B(object):\n    p = property(f)\n' \
          'a_var = B().p\n'
    pymod = self.pycore.get_string_module(src)
    a_class = pymod['A'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(a_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2578">def test_getting_property_attributes_with_method_getters(self):
    src = 'class A(object):\n    pass\n' \
          'class B(object):\n    def p_get(self):\n        return A()\n' \
          '    p = property(p_get)\n' \
          'a_var = B().p\n'
    pymod = self.pycore.get_string_module(src)
    a_class = pymod['A'].get_object()
    a_var = pymod['a_var'].get_object()
    self.assertEquals(a_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2579">def test_lambda_functions(self):
    code = 'class C(object):\n    pass\n' \
           'l = lambda: C()\na_var = l()'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2580">def test_mixing_subscript_with_tuple_assigns(self):
    code = 'class C(object):\n    attr = 0\n' \
           'd = {}\nd[0], b = (0, C())\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['b'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2581">def test_mixing_ass_attr_with_tuple_assignment(self):
    code = 'class C(object):\n    attr = 0\n' \
           'c = C()\nc.attr, b = (0, C())\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['b'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2582">def test_mixing_slice_with_tuple_assigns(self):
    mod = self.pycore.get_string_module(
        'class C(object):\n    attr = 0\n'
        'd = [None] * 3\nd[0:2], b = ((0,), C())\n')
    c_class = mod['C'].get_object()
    a_var = mod['b'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2583">def test_nested_tuple_assignments(self):
    mod = self.pycore.get_string_module(
        'class C1(object):\n    pass\nclass C2(object):\n    pass\n'
        'a, (b, c) = (C1(), (C2(), C1()))\n')
    c1_class = mod['C1'].get_object()
    c2_class = mod['C2'].get_object()
    a_var = mod['a'].get_object()
    b_var = mod['b'].get_object()
    c_var = mod['c'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())
    self.assertEquals(c1_class, c_var.get_type())

</t>
<t tx="ekr.20080516150804.2584">def test_empty_tuples(self):
    mod = self.pycore.get_string_module('t = ()\na, b = t\n')
    a = mod['a'].get_object()

</t>
<t tx="ekr.20080516150804.2585">def test_handling_generator_functions(self):
    code = 'class C(object):\n    pass\n' \
           'def f():\n    yield C()\n' \
           'for c in f():\n    a_var = c\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2586">def test_handling_generator_functions_for_strs(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('def f():\n    yield ""\n'
              'for s in f():\n    a_var = s\n')
    pymod = self.pycore.resource_to_pyobject(mod)
    a_var = pymod['a_var'].get_object()
    self.assertTrue(isinstance(a_var.get_type(), rope.base.builtins.Str))

</t>
<t tx="ekr.20080516150804.2587">def test_considering_nones_to_be_unknowns(self):
    code = 'class C(object):\n    pass\n' \
           'a_var = None\na_var = C()\na_var = None\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2588">def test_basic_list_comprehensions(self):
    code = 'class C(object):\n    pass\n' \
           'l = [C() for i in range(1)]\na_var = l[0]\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2589">def test_basic_generator_expressions(self):
    code = 'class C(object):\n    pass\n' \
           'l = (C() for i in range(1))\na_var = list(l)[0]\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2590">def test_list_comprehensions_and_loop_var(self):
    code = 'class C(object):\n    pass\n' \
           'c_objects = [C(), C()]\n' \
           'l = [c for c in c_objects]\na_var = l[0]\n'
    mod = self.pycore.get_string_module(code)
    c_class = mod['C'].get_object()
    a_var = mod['a_var'].get_object()
    self.assertEquals(c_class, a_var.get_type())

</t>
<t tx="ekr.20080516150804.2591">def test_list_comprehensions_and_multiple_loop_var(self):
    code = 'class C1(object):\n    pass\n' \
           'class C2(object):\n    pass\n' \
           'l = [(c1, c2) for c1 in [C1()] for c2 in [C2()]]\n' \
           'a, b = l[0]\n'
    mod = self.pycore.get_string_module(code)
    c1_class = mod['C1'].get_object()
    c2_class = mod['C2'].get_object()
    a_var = mod['a'].get_object()
    b_var = mod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2592">def test_list_comprehensions_and_multiple_iters(self):
    mod = self.pycore.get_string_module(
        'class C1(object):\n    pass\nclass C2(object):\n    pass\n'
        'l = [(c1, c2) for c1, c2 in [(C1(), C2())]]\n'
        'a, b = l[0]\n')
    c1_class = mod['C1'].get_object()
    c2_class = mod['C2'].get_object()
    a_var = mod['a'].get_object()
    b_var = mod['b'].get_object()
    self.assertEquals(c1_class, a_var.get_type())
    self.assertEquals(c2_class, b_var.get_type())

</t>
<t tx="ekr.20080516150804.2593">def test_we_know_the_type_of_catched_exceptions(self):
    code = 'class MyError(Exception):\n    pass\n' \
           'try:\n    raise MyError()\n' \
           'except MyError, e:\n    pass\n'
    mod = self.pycore.get_string_module(
        code)
    my_error = mod['MyError'].get_object()
    e_var = mod['e'].get_object()
    self.assertEquals(my_error, e_var.get_type())

</t>
<t tx="ekr.20080516150804.2594">def test_we_know_the_type_of_catched_multiple_excepts(self):
    code = 'class MyError(Exception):\n    pass\n' \
           'try:\n    raise MyError()\n' \
           'except (MyError, Exception), e:\n    pass\n'
    mod = self.pycore.get_string_module(
        code)
    my_error = mod['MyError'].get_object()
    e_var = mod['e'].get_object()
    self.assertEquals(my_error, e_var.get_type())

</t>
<t tx="ekr.20080516150804.2595">def test_using_property_as_decorators(self):
    code = 'class A(object):\n    pass\n' \
           'class B(object):\n' \
           '    @property\n    def f(self):\n        return A()\n' \
           'b = B()\nvar = b.f\n'
    mod = self.pycore.get_string_module(code)
    var = mod['var'].get_object()
    a = mod['A'].get_object()
    self.assertEquals(a, var.get_type())

</t>
<t tx="ekr.20080516150804.2596">def test_using_property_as_decorators_and_passing_parameter(self):
    code = 'class B(object):\n' \
           '    @property\n    def f(self):\n        return self\n' \
           'b = B()\nvar = b.f\n'
    mod = self.pycore.get_string_module(code)
    var = mod['var'].get_object()
    a = mod['B'].get_object()
    self.assertEquals(a, var.get_type())


</t>
<t tx="ekr.20080516150804.2597">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(ObjectInferTest))
    return result


</t>
<t tx="ekr.20080516150804.2598">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2599">import os.path
import unittest

from rope.base.exceptions import RopeError, ResourceNotFoundError
from rope.base.fscommands import FileSystemCommands
from rope.base.libutils import path_to_resource
from rope.base.project import Project, NoProject, _realpath
from ropetest import testutils
from rope.base.resourceobserver import ResourceObserver, FilteredResourceObserver



</t>
<t tx="ekr.20080516150804.2600">class ProjectTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2601">
def setUp(self):
    unittest.TestCase.setUp(self)
    self.project = testutils.sample_project(foldername='sampleproject',
                                            ropefolder=None)
    self.project_root = self.project.address
    self._make_sample_project()
    self.no_project = NoProject()

</t>
<t tx="ekr.20080516150804.2602">def _make_sample_project(self):
    self.sample_file = 'sample_file.txt'
    self.sample_path = os.path.join(self.project_root, 'sample_file.txt')
    if not os.path.exists(self.project_root):
        os.mkdir(self.project_root)
    self.sample_folder = 'sample_folder'
    os.mkdir(os.path.join(self.project_root, self.sample_folder))
    sample = open(self.sample_path, 'w')
    sample.write('sample text\n')
    sample.close()

</t>
<t tx="ekr.20080516150804.2603">def tearDown(self):
    testutils.remove_project(self.project)
    unittest.TestCase.tearDown(self)

</t>
<t tx="ekr.20080516150804.2604">def test_project_creation(self):
    self.assertEquals(_realpath(self.project_root),
                      self.project.address)

</t>
<t tx="ekr.20080516150804.2605">def test_getting_project_file(self):
    project_file = self.project.get_resource(self.sample_file)
    self.assertTrue(project_file is not None)

</t>
<t tx="ekr.20080516150804.2606">def test_project_file_reading(self):
    projectFile = self.project.get_resource(self.sample_file)
    self.assertEquals('sample text\n', projectFile.read())

</t>
<t tx="ekr.20080516150804.2607">@testutils.assert_raises(ResourceNotFoundError)
def test_getting_not_existing_project_file(self):
    projectFile = self.project.get_resource('DoesNotExistFile.txt')
    self.fail('Should have failed')

</t>
<t tx="ekr.20080516150804.2608">def test_writing_in_project_files(self):
    project_file = self.project.get_resource(self.sample_file)
    project_file.write('another text\n')
    self.assertEquals('another text\n', project_file.read())

</t>
<t tx="ekr.20080516150804.2609">def test_creating_files(self):
    project_file = 'newfile.txt'
    self.project.root.create_file(project_file)
    newFile = self.project.get_resource(project_file)
    self.assertTrue(newFile is not None)

</t>
<t tx="ekr.20080516150804.2610">@testutils.assert_raises(RopeError)
def test_creating_files_that_already_exist(self):
    self.project.root.create_file(self.sample_file)
    self.fail('Should have failed')

</t>
<t tx="ekr.20080516150804.2611">def test_making_root_folder_if_it_does_not_exist(self):
    project = Project('sampleproject2')
    try:
        self.assertTrue(os.path.exists('sampleproject2') and
                        os.path.isdir('sampleproject2'))
    finally:
        testutils.remove_project(project)

</t>
<t tx="ekr.20080516150804.2612">@testutils.assert_raises(RopeError)
def test_failure_when_project_root_exists_and_is_a_file(self):
    try:
        project_root = 'sampleproject2'
        open(project_root, 'w').close()
        project = Project(project_root)
    finally:
        testutils.remove_recursively(project_root)

</t>
<t tx="ekr.20080516150804.2613">def test_creating_folders(self):
    folderName = 'SampleFolder'
    self.project.root.create_folder(folderName)
    folderPath = os.path.join(self.project.address, folderName)
    self.assertTrue(os.path.exists(folderPath) and os.path.isdir(folderPath))

</t>
<t tx="ekr.20080516150804.2614">@testutils.assert_raises(RopeError)
def test_making_folder_that_already_exists(self):
    folderName = 'SampleFolder'
    self.project.root.create_folder(folderName)
    self.project.root.create_folder(folderName)

</t>
<t tx="ekr.20080516150804.2615">@testutils.assert_raises(RopeError)
def test_failing_if_creating_folder_while_file_already_exists(self):
    folderName = 'SampleFolder'
    self.project.root.create_file(folderName)
    self.project.root.create_folder(folderName)

</t>
<t tx="ekr.20080516150804.2616">def test_creating_file_inside_folder(self):
    folder_name = 'sampleFolder'
    file_name = 'sample2.txt'
    file_path = folder_name + '/' + file_name
    parent_folder = self.project.root.create_folder(folder_name)
    parent_folder.create_file(file_name)
    file = self.project.get_resource(file_path)
    file.write('sample notes')
    self.assertEquals(file_path, file.path)
    self.assertEquals('sample notes', open(os.path.join(self.project.address,
                                                        file_path)).read())

</t>
<t tx="ekr.20080516150804.2617">@testutils.assert_raises(ResourceNotFoundError)
def test_failing_when_creating_file_inside_non_existent_folder(self):
    self.project.root.create_file('NonexistentFolder/SomeFile.txt')

</t>
<t tx="ekr.20080516150804.2618">def test_nested_directories(self):
    folder_name = 'SampleFolder'
    parent = self.project.root.create_folder(folder_name)
    parent.create_folder(folder_name)
    folder_path = os.path.join(self.project.address, folder_name, folder_name)
    self.assertTrue(os.path.exists(folder_path) and os.path.isdir(folder_path))

</t>
<t tx="ekr.20080516150804.2619">def test_removing_files(self):
    self.assertTrue(os.path.exists(self.sample_path))
    self.project.get_resource(self.sample_file).remove()
    self.assertFalse(os.path.exists(self.sample_path))

</t>
<t tx="ekr.20080516150804.2620">def test_removing_files_invalidating_in_project_resource_pool(self):
    root_folder = self.project.root
    my_file = root_folder.create_file('my_file.txt')
    my_file.remove()
    self.assertFalse(root_folder.has_child('my_file.txt'))

</t>
<t tx="ekr.20080516150804.2621">def test_removing_directories(self):
    self.assertTrue(os.path.exists(os.path.join(self.project.address,
                                                self.sample_folder)))
    self.project.get_resource(self.sample_folder).remove()
    self.assertFalse(os.path.exists(os.path.join(self.project.address,
                                                 self.sample_folder)))

</t>
<t tx="ekr.20080516150804.2622">@testutils.assert_raises(ResourceNotFoundError)
def test_removing_non_existent_files(self):
    self.project.get_resource('NonExistentFile.txt').remove()

</t>
<t tx="ekr.20080516150804.2623">def test_removing_nested_files(self):
    file_name = self.sample_folder + '/sample_file.txt'
    self.project.root.create_file(file_name)
    self.project.get_resource(file_name).remove()
    self.assertTrue(os.path.exists(os.path.join(self.project.address,
                                                self.sample_folder)))
    self.assertTrue(not os.path.exists(os.path.join(self.project.address,
                              file_name)))

</t>
<t tx="ekr.20080516150804.2624">def test_file_get_name(self):
    file = self.project.get_resource(self.sample_file)
    self.assertEquals(self.sample_file, file.name)
    file_name = 'nestedFile.txt'
    parent = self.project.get_resource(self.sample_folder)
    filePath = self.sample_folder + '/' + file_name
    parent.create_file(file_name)
    nestedFile = self.project.get_resource(filePath)
    self.assertEquals(file_name, nestedFile.name)

</t>
<t tx="ekr.20080516150804.2625">def test_folder_get_name(self):
    folder = self.project.get_resource(self.sample_folder)
    self.assertEquals(self.sample_folder, folder.name)

</t>
<t tx="ekr.20080516150804.2626">def test_file_get_path(self):
    file = self.project.get_resource(self.sample_file)
    self.assertEquals(self.sample_file, file.path)
    fileName = 'nestedFile.txt'
    parent = self.project.get_resource(self.sample_folder)
    filePath = self.sample_folder + '/' + fileName
    parent.create_file(fileName)
    nestedFile = self.project.get_resource(filePath)
    self.assertEquals(filePath, nestedFile.path)

</t>
<t tx="ekr.20080516150804.2627">def test_folder_get_path(self):
    folder = self.project.get_resource(self.sample_folder)
    self.assertEquals(self.sample_folder, folder.path)

</t>
<t tx="ekr.20080516150804.2628">def test_is_folder(self):
    self.assertTrue(self.project.get_resource(self.sample_folder).is_folder())
    self.assertTrue(not self.project.get_resource(self.sample_file).is_folder())

</t>
<t tx="ekr.20080516150804.2629">def testget_children(self):
    children = self.project.get_resource(self.sample_folder).get_children()
    self.assertEquals([], children)

</t>
<t tx="ekr.20080516150804.2630">def test_nonempty_get_children(self):
    file_name = 'nestedfile.txt'
    filePath = self.sample_folder + '/' + file_name
    parent = self.project.get_resource(self.sample_folder)
    parent.create_file(file_name)
    children = parent.get_children()
    self.assertEquals(1, len(children))
    self.assertEquals(filePath, children[0].path)

</t>
<t tx="ekr.20080516150804.2631">def test_nonempty_get_children2(self):
    file_name = 'nestedfile.txt'
    folder_name = 'nestedfolder.txt'
    filePath = self.sample_folder + '/' + file_name
    folderPath = self.sample_folder + '/' + folder_name
    parent = self.project.get_resource(self.sample_folder)
    parent.create_file(file_name)
    parent.create_folder(folder_name)
    children = parent.get_children()
    self.assertEquals(2, len(children))
    self.assertTrue(filePath == children[0].path or filePath == children[1].path)
    self.assertTrue(folderPath == children[0].path or folderPath == children[1].path)

</t>
<t tx="ekr.20080516150804.2632">def test_getting_files(self):
    files = self.project.root.get_files()
    self.assertEquals(1, len(files))
    self.assertTrue(self.project.get_resource(self.sample_file) in files)

</t>
<t tx="ekr.20080516150804.2633">def test_getting_folders(self):
    folders = self.project.root.get_folders()
    self.assertEquals(1, len(folders))
    self.assertTrue(self.project.get_resource(self.sample_folder) in folders)

</t>
<t tx="ekr.20080516150804.2634">def test_nested_folder_get_files(self):
    parent = self.project.root.create_folder('top')
    parent.create_file('file1.txt')
    parent.create_file('file2.txt')
    files = parent.get_files()
    self.assertEquals(2, len(files))
    self.assertTrue(self.project.get_resource('top/file2.txt') in files)
    self.assertEquals(0, len(parent.get_folders()))

</t>
<t tx="ekr.20080516150804.2635">def test_nested_folder_get_folders(self):
    parent = self.project.root.create_folder('top')
    parent.create_folder('dir1')
    parent.create_folder('dir2')
    folders = parent.get_folders()
    self.assertEquals(2, len(folders))
    self.assertTrue(self.project.get_resource('top/dir1') in folders)
    self.assertEquals(0, len(parent.get_files()))

</t>
<t tx="ekr.20080516150804.2636">def test_root_folder(self):
    root_folder = self.project.root
    self.assertEquals(2, len(root_folder.get_children()))
    self.assertEquals('', root_folder.path)
    self.assertEquals('', root_folder.name)

</t>
<t tx="ekr.20080516150804.2637">def test_get_all_files(self):
    files = tuple(self.project.get_files())
    self.assertEquals(1, len(files))
    self.assertEquals(self.sample_file, files[0].name)

</t>
<t tx="ekr.20080516150804.2638">def test_get_all_files_after_changing(self):
    self.assertEquals(1, len(self.project.get_files()))
    myfile = self.project.root.create_file('myfile.txt')
    self.assertEquals(2, len(self.project.get_files()))
    myfile.move('newfile.txt')
    self.assertEquals(2, len(self.project.get_files()))
    self.project.get_file('newfile.txt').remove()
    self.assertEquals(1, len(self.project.get_files()))

</t>
<t tx="ekr.20080516150804.2639">def test_multifile_get_all_files(self):
    fileName = 'nestedFile.txt'
    parent = self.project.get_resource(self.sample_folder)
    parent.create_file(fileName)
    files = list(self.project.get_files())
    self.assertEquals(2, len(files))
    self.assertTrue(fileName == files[0].name or fileName == files[1].name)

</t>
<t tx="ekr.20080516150804.2640">def test_ignoring_dot_pyc_files_in_get_files(self):
    root = self.project.address
    src_folder = os.path.join(root, 'src')
    os.mkdir(src_folder)
    test_pyc = os.path.join(src_folder, 'test.pyc')
    file(test_pyc, 'w').close()
    for x in self.project.get_files():
        self.assertNotEquals('src/test.pyc', x.path)

</t>
<t tx="ekr.20080516150804.2641">def test_folder_creating_files(self):
    projectFile = 'NewFile.txt'
    self.project.root.create_file(projectFile)
    new_file = self.project.get_resource(projectFile)
    self.assertTrue(new_file is not None and not new_file.is_folder())

</t>
<t tx="ekr.20080516150804.2642">def test_folder_creating_nested_files(self):
    project_file = 'NewFile.txt'
    parent_folder = self.project.get_resource(self.sample_folder)
    parent_folder.create_file(project_file)
    new_file = self.project.get_resource(self.sample_folder
                                        + '/' + project_file)
    self.assertTrue(new_file is not None and not new_file.is_folder())

</t>
<t tx="ekr.20080516150804.2643">def test_folder_creating_files2(self):
    projectFile = 'newfolder'
    self.project.root.create_folder(projectFile)
    new_folder = self.project.get_resource(projectFile)
    self.assertTrue(new_folder is not None and new_folder.is_folder())

</t>
<t tx="ekr.20080516150804.2644">def test_folder_creating_nested_files2(self):
    project_file = 'newfolder'
    parent_folder = self.project.get_resource(self.sample_folder)
    parent_folder.create_folder(project_file)
    new_folder = self.project.get_resource(self.sample_folder
                                           + '/' + project_file)
    self.assertTrue(new_folder is not None and new_folder.is_folder())

</t>
<t tx="ekr.20080516150804.2645">def test_folder_get_child(self):
    folder = self.project.root
    folder.create_file('myfile.txt')
    folder.create_folder('myfolder')
    self.assertEquals(self.project.get_resource('myfile.txt'),
                      folder.get_child('myfile.txt'))
    self.assertEquals(self.project.get_resource('myfolder'),
                      folder.get_child('myfolder'))

</t>
<t tx="ekr.20080516150804.2646">def test_folder_get_child_nested(self):
    root = self.project.root
    folder = root.create_folder('myfolder')
    folder.create_file('myfile.txt')
    folder.create_folder('myfolder')
    self.assertEquals(self.project.get_resource('myfolder/myfile.txt'),
                      folder.get_child('myfile.txt'))
    self.assertEquals(self.project.get_resource('myfolder/myfolder'),
                      folder.get_child('myfolder'))

</t>
<t tx="ekr.20080516150804.2647">def test_project_root_is_root_folder(self):
    self.assertEquals('', self.project.root.path)

</t>
<t tx="ekr.20080516150804.2648">def test_moving_files(self):
    root_folder = self.project.root
    my_file = root_folder.create_file('my_file.txt')
    my_file.move('my_other_file.txt')
    self.assertFalse(my_file.exists())
    root_folder.get_child('my_other_file.txt')

</t>
<t tx="ekr.20080516150804.2649">def test_moving_folders(self):
    root_folder = self.project.root
    my_folder = root_folder.create_folder('my_folder')
    my_file = my_folder.create_file('my_file.txt')
    my_folder.move('new_folder')
    self.assertFalse(root_folder.has_child('my_folder'))
    self.assertFalse(my_file.exists())
    self.assertTrue(root_folder.get_child('new_folder') is not None)

</t>
<t tx="ekr.20080516150804.2650">def test_moving_destination_folders(self):
    root_folder = self.project.root
    my_folder = root_folder.create_folder('my_folder')
    my_file = root_folder.create_file('my_file.txt')
    my_file.move('my_folder')
    self.assertFalse(root_folder.has_child('my_file.txt'))
    self.assertFalse(my_file.exists())
    my_folder.get_child('my_file.txt')

</t>
<t tx="ekr.20080516150804.2651">def test_moving_files_and_resource_objects(self):
    root_folder = self.project.root
    my_file = root_folder.create_file('my_file.txt')
    old_hash = hash(my_file)
    my_file.move('my_other_file.txt')
    self.assertEquals(old_hash, hash(my_file))

</t>
<t tx="ekr.20080516150804.2652">def test_file_encoding_reading(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = u'# -*- coding: utf-8 -*-\n#\N{LATIN SMALL LETTER I WITH DIAERESIS}\n'
    file = open(sample_file.real_path, 'w')
    file.write(contents.encode('utf-8'))
    file.close()
    self.assertEquals(contents, sample_file.read())

</t>
<t tx="ekr.20080516150804.2653">def test_file_encoding_writing(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = u'# -*- coding: utf-8 -*-\n\N{LATIN SMALL LETTER I WITH DIAERESIS}\n'
    sample_file.write(contents)
    self.assertEquals(contents, sample_file.read())

</t>
<t tx="ekr.20080516150804.2654">def test_using_utf8_when_writing_in_case_of_errors(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = u'\n\N{LATIN SMALL LETTER I WITH DIAERESIS}\n'
    sample_file.write(contents)
    self.assertEquals(contents, sample_file.read())

</t>
<t tx="ekr.20080516150804.2655">def test_encoding_declaration_in_the_second_line(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = '\n# -*- coding: latin-1 -*-\n\xa9\n'
    file = open(sample_file.real_path, 'wb')
    file.write(contents)
    file.close()
    self.assertEquals(contents, sample_file.read().encode('latin-1'))

</t>
<t tx="ekr.20080516150804.2656">def test_read_bytes(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = '\n# -*- coding: latin-1 -*-\n\xa9\n'
    file = open(sample_file.real_path, 'wb')
    file.write(contents)
    file.close()
    self.assertEquals(contents, sample_file.read_bytes())

</t>
<t tx="ekr.20080516150804.2657"># TODO: Detecting utf-16 encoding
def xxx_test_using_utf16(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = '# -*- coding: utf-16 -*-\n# This is a sample file ...\n'
    file = open(sample_file.real_path, 'w')
    file.write(contents.encode('utf-16'))
    file.close()
    sample_file.write(contents)
    self.assertEquals(contents, sample_file.read())

</t>
<t tx="ekr.20080516150804.2658"># XXX: supporting utf_8_sig
def xxx_test_file_encoding_reading_for_notepad_styles(self):
    sample_file = self.project.root.create_file('my_file.txt')
    contents = u'#\N{LATIN SMALL LETTER I WITH DIAERESIS}\n'
    file = open(sample_file.real_path, 'w')
    # file.write('\xef\xbb\xbf')
    file.write(contents.encode('utf-8-sig'))
    file.close()
    self.assertEquals(contents, sample_file.read())

</t>
<t tx="ekr.20080516150804.2659">def test_using_project_get_file(self):
    myfile = self.project.get_file(self.sample_file)
    self.assertTrue(myfile.exists())

</t>
<t tx="ekr.20080516150804.2660">def test_using_file_create(self):
    myfile = self.project.get_file('myfile.txt')
    self.assertFalse(myfile.exists())
    myfile.create()
    self.assertTrue(myfile.exists())
    self.assertFalse(myfile.is_folder())

</t>
<t tx="ekr.20080516150804.2661">def test_using_folder_create(self):
    myfolder = self.project.get_folder('myfolder')
    self.assertFalse(myfolder.exists())
    myfolder.create()
    self.assertTrue(myfolder.exists())
    self.assertTrue(myfolder.is_folder())

</t>
<t tx="ekr.20080516150804.2662">@testutils.assert_raises(RopeError)
def test_exception_when_creating_twice(self):
    myfile = self.project.get_file('myfile.txt')
    myfile.create()
    myfile.create()

</t>
<t tx="ekr.20080516150804.2663">@testutils.assert_raises(ResourceNotFoundError)
def test_exception_when_parent_does_not_exist(self):
    myfile = self.project.get_file('myfolder/myfile.txt')
    myfile.create()

</t>
<t tx="ekr.20080516150804.2664">def test_simple_path_to_resource(self):
    myfile = self.project.root.create_file('myfile.txt')
    self.assertEquals(myfile, path_to_resource(self.project,
                                               myfile.real_path))
    self.assertEquals(myfile, path_to_resource(
                      self.project, myfile.real_path, type='file'))
    myfolder = self.project.root.create_folder('myfolder')
    self.assertEquals(myfolder, path_to_resource(self.project,
                                                 myfolder.real_path))
    self.assertEquals(myfolder, path_to_resource(
                      self.project, myfolder.real_path, type='folder'))

</t>
<t tx="ekr.20080516150804.2665">@testutils.run_only_for_unix
def test_ignoring_symlinks_inside_project(self):
    project2 = testutils.sample_project(folder_name='sampleproject2')
    mod = project2.root.create_file('mod.py')
    try:
        path = os.path.join(self.project.address, 'linkedfile.txt')
        os.symlink(mod.real_path, path)
        files = self.project.root.get_files()
        self.assertEquals(1, len(files))
    finally:
        testutils.remove_project(project2)


</t>
<t tx="ekr.20080516150804.2666">class ResourceObserverTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2667">
def setUp(self):
    super(ResourceObserverTest, self).setUp()
    self.project = testutils.sample_project()

</t>
<t tx="ekr.20080516150804.2668">def tearDown(self):
    testutils.remove_project(self.project)
    super(ResourceObserverTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2669">def test_resource_change_observer(self):
    sample_file = self.project.root.create_file('my_file.txt')
    sample_file.write('a sample file version 1')
    sample_observer = _SampleObserver()
    self.project.add_observer(sample_observer)
    sample_file.write('a sample file version 2')
    self.assertEquals(1, sample_observer.change_count)
    self.assertEquals(sample_file, sample_observer.last_changed)

</t>
<t tx="ekr.20080516150804.2670">def test_resource_change_observer_after_removal(self):
    sample_file = self.project.root.create_file('my_file.txt')
    sample_file.write('text')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [sample_file]))
    sample_file.remove()
    self.assertEquals(1, sample_observer.change_count)
    self.assertEquals(sample_file, sample_observer.last_removed)

</t>
<t tx="ekr.20080516150804.2671">def test_resource_change_observer2(self):
    sample_file = self.project.root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(sample_observer)
    self.project.remove_observer(sample_observer)
    sample_file.write('a sample file version 2')
    self.assertEquals(0, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2672">def test_resource_change_observer_for_folders(self):
    root_folder = self.project.root
    my_folder = root_folder.create_folder('my_folder')
    my_folder_observer = _SampleObserver()
    root_folder_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(my_folder_observer,
                                                       [my_folder]))
    self.project.add_observer(FilteredResourceObserver(root_folder_observer,
                                                       [root_folder]))
    my_file = my_folder.create_file('my_file.txt')
    self.assertEquals(1, my_folder_observer.change_count)
    my_file.move('another_file.txt')
    self.assertEquals(2, my_folder_observer.change_count)
    self.assertEquals(1, root_folder_observer.change_count)
    self.project.get_resource('another_file.txt').remove()
    self.assertEquals(2, my_folder_observer.change_count)
    self.assertEquals(2, root_folder_observer.change_count)

</t>
<t tx="ekr.20080516150804.2673">def test_resource_change_observer_after_moving(self):
    sample_file = self.project.root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(sample_observer)
    sample_file.move('new_file.txt')
    self.assertEquals(1, sample_observer.change_count)
    self.assertEquals((sample_file, self.project.get_resource('new_file.txt')),
                       sample_observer.last_moved)

</t>
<t tx="ekr.20080516150804.2674">def test_revalidating_files(self):
    root = self.project.root
    my_file = root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [my_file]))
    os.remove(my_file.real_path)
    self.project.validate(root)
    self.assertEquals(my_file, sample_observer.last_removed)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2675">def test_revalidating_files_and_no_changes2(self):
    root = self.project.root
    my_file = root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [my_file]))
    self.project.validate(root)
    self.assertEquals(None, sample_observer.last_moved)
    self.assertEquals(0, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2676">def test_revalidating_folders(self):
    root = self.project.root
    my_folder = root.create_folder('myfolder')
    my_file = my_folder.create_file('myfile.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [my_folder]))
    testutils.remove_recursively(my_folder.real_path)
    self.project.validate(root)
    self.assertEquals(my_folder, sample_observer.last_removed)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2677">def test_removing_and_adding_resources_to_filtered_observer(self):
    my_file = self.project.root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    filtered_observer = FilteredResourceObserver(sample_observer)
    self.project.add_observer(filtered_observer)
    my_file.write('1')
    self.assertEquals(0, sample_observer.change_count)
    filtered_observer.add_resource(my_file)
    my_file.write('2')
    self.assertEquals(1, sample_observer.change_count)
    filtered_observer.remove_resource(my_file)
    my_file.write('3')
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2678">def test_validation_and_changing_files(self):
    my_file = self.project.root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    timekeeper = _MockChangeIndicator()
    filtered_observer = FilteredResourceObserver(sample_observer, [my_file],
                                                 timekeeper=timekeeper)
    self.project.add_observer(filtered_observer)
    self._write_file(my_file.real_path)
    timekeeper.set_indicator(my_file, 1)
    self.project.validate(self.project.root)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2679">def test_validation_and_changing_files2(self):
    my_file = self.project.root.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    timekeeper = _MockChangeIndicator()
    self.project.add_observer(FilteredResourceObserver(
                              sample_observer, [my_file],
                              timekeeper=timekeeper))
    timekeeper.set_indicator(my_file, 1)
    my_file.write('hey')
    self.assertEquals(1, sample_observer.change_count)
    self.project.validate(self.project.root)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2680">def test_not_reporting_multiple_changes_to_folders(self):
    root = self.project.root
    file1 = root.create_file('file1.txt')
    file2 = root.create_file('file2.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(
                              sample_observer, [root, file1, file2]))
    os.remove(file1.real_path)
    os.remove(file2.real_path)
    self.assertEquals(0, sample_observer.change_count)
    self.project.validate(self.project.root)
    self.assertEquals(3, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2681">def _write_file(self, path):
    my_file = open(path, 'w')
    my_file.write('\n')
    my_file.close()

</t>
<t tx="ekr.20080516150804.2682">def test_moving_and_being_interested_about_a_folder_and_a_child(self):
    my_folder = self.project.root.create_folder('my_folder')
    my_file = my_folder.create_file('my_file.txt')
    sample_observer = _SampleObserver()
    filtered_observer = FilteredResourceObserver(
        sample_observer, [my_folder, my_file])
    self.project.add_observer(filtered_observer)
    my_folder.move('new_folder')
    self.assertEquals(2, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2683">def test_contains_for_folders(self):
    folder1 = self.project.root.create_folder('folder')
    folder2 = self.project.root.create_folder('folder2')
    self.assertFalse(folder1.contains(folder2))

</t>
<t tx="ekr.20080516150804.2684">def test_validating_when_created(self):
    root = self.project.root
    my_file = self.project.get_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [my_file]))
    file(my_file.real_path, 'w').close()
    self.project.validate(root)
    self.assertEquals(my_file, sample_observer.last_created)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2685">def test_validating_twice_when_created(self):
    root = self.project.root
    my_file = self.project.get_file('my_file.txt')
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [my_file]))
    file(my_file.real_path, 'w').close()
    self.project.validate(root)
    self.project.validate(root)
    self.assertEquals(my_file, sample_observer.last_created)
    self.assertEquals(1, sample_observer.change_count)

</t>
<t tx="ekr.20080516150804.2686">def test_changes_and_adding_resources(self):
    root = self.project.root
    file1 = self.project.get_file('file1.txt')
    file2 = self.project.get_file('file2.txt')
    file1.create()
    sample_observer = _SampleObserver()
    self.project.add_observer(FilteredResourceObserver(sample_observer,
                                                       [file1, file2]))
    file1.move(file2.path)
    self.assertEquals(2, sample_observer.change_count)
    self.assertEquals(file2, sample_observer.last_created)
    self.assertEquals((file1, file2), sample_observer.last_moved)

</t>
<t tx="ekr.20080516150804.2687">def test_validating_get_files_list(self):
    root = self.project.root
    self.assertEquals(0, len(self.project.get_files()))
    file = open(os.path.join(self.project.address, 'myfile.txt'), 'w')
    file.close()
    self.project.validate()
    self.assertEquals(1, len(self.project.get_files()))

</t>
<t tx="ekr.20080516150804.2688">def test_clear_observered_resources_for_filtered_observers(self):
    sample_file = self.project.root.create_file('myfile.txt')
    sample_observer = _SampleObserver()
    filtered = FilteredResourceObserver(sample_observer)
    self.project.add_observer(filtered)
    filtered.add_resource(sample_file)
    filtered.clear_resources()
    sample_file.write('1')
    self.assertEquals(0, sample_observer.change_count)


</t>
<t tx="ekr.20080516150804.2689">class _MockChangeIndicator(object):
    @others
</t>
<t tx="ekr.20080516150804.2690">
def __init__(self):
    self.times = {}

</t>
<t tx="ekr.20080516150804.2691">def set_indicator(self, resource, time):
    self.times[resource] = time

</t>
<t tx="ekr.20080516150804.2692">def get_indicator(self, resource):
    return self.times.get(resource, 0)


</t>
<t tx="ekr.20080516150804.2693">class _SampleObserver(object):
    @others
</t>
<t tx="ekr.20080516150804.2694">
def __init__(self):
    self.change_count = 0
    self.last_changed = None
    self.last_moved = None
    self.last_created = None
    self.last_removed = None

</t>
<t tx="ekr.20080516150804.2695">def resource_changed(self, resource):
    self.last_changed = resource
    self.change_count += 1

</t>
<t tx="ekr.20080516150804.2696">def resource_moved(self, resource, new_resource):
    self.last_moved = (resource, new_resource)
    self.change_count += 1

</t>
<t tx="ekr.20080516150804.2697">def resource_created(self, resource):
    self.last_created = resource
    self.change_count += 1

</t>
<t tx="ekr.20080516150804.2698">def resource_removed(self, resource):
    self.last_removed = resource
    self.change_count += 1


</t>
<t tx="ekr.20080516150804.2699">class OutOfProjectTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2700">
def setUp(self):
    super(OutOfProjectTest, self).setUp()
    self.test_directory = 'temp_test_directory'
    testutils.remove_recursively(self.test_directory)
    os.mkdir(self.test_directory)
    self.project = testutils.sample_project()
    self.no_project = NoProject()

</t>
<t tx="ekr.20080516150804.2701">def tearDown(self):
    testutils.remove_project(self.project)
    testutils.remove_recursively(self.test_directory)
    super(OutOfProjectTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2702">def test_simple_out_of_project_file(self):
    sample_file_path = os.path.join(self.test_directory, 'sample.txt')
    sample_file = file(sample_file_path, 'w')
    sample_file.write('sample content\n')
    sample_file.close()
    sample_resource = self.no_project.get_resource(sample_file_path)
    self.assertEquals('sample content\n', sample_resource.read())

</t>
<t tx="ekr.20080516150804.2703">def test_simple_out_of_project_folder(self):
    sample_folder_path = os.path.join(self.test_directory, 'sample_folder')
    os.mkdir(sample_folder_path)
    sample_folder = self.no_project.get_resource(sample_folder_path)
    self.assertEquals([], sample_folder.get_children())

    sample_file_path = os.path.join(sample_folder_path, 'sample.txt')
    file(sample_file_path, 'w').close()
    sample_resource = self.no_project.get_resource(sample_file_path)
    self.assertEquals(sample_resource, sample_folder.get_children()[0])

</t>
<t tx="ekr.20080516150804.2704">def test_using_absolute_path(self):
    sample_file_path = os.path.join(self.test_directory, 'sample.txt')
    file(sample_file_path, 'w').close()
    normal_sample_resource = self.no_project.get_resource(sample_file_path)
    absolute_sample_resource = \
        self.no_project.get_resource(os.path.abspath(sample_file_path))
    self.assertEquals(normal_sample_resource, absolute_sample_resource)

</t>
<t tx="ekr.20080516150804.2705">def test_folder_get_child(self):
    sample_folder_path = os.path.join(self.test_directory, 'sample_folder')
    os.mkdir(sample_folder_path)
    sample_folder = self.no_project.get_resource(sample_folder_path)
    self.assertEquals([], sample_folder.get_children())

    sample_file_path = os.path.join(sample_folder_path, 'sample.txt')
    file(sample_file_path, 'w').close()
    sample_resource = self.no_project.get_resource(sample_file_path)
    self.assertTrue(sample_folder.has_child('sample.txt'))
    self.assertFalse(sample_folder.has_child('doesnothave.txt'))
    self.assertEquals(sample_resource, sample_folder.get_child('sample.txt'))

</t>
<t tx="ekr.20080516150804.2706">def test_out_of_project_files_and_path_to_resource(self):
    sample_file_path = os.path.join(self.test_directory, 'sample.txt')
    sample_file = file(sample_file_path, 'w')
    sample_file.write('sample content\n')
    sample_file.close()
    sample_resource = self.no_project.get_resource(sample_file_path)
    self.assertEquals(sample_resource,
                      path_to_resource(self.project, sample_file_path))


</t>
<t tx="ekr.20080516150804.2707">class _MockFSCommands(object):
    @others
</t>
<t tx="ekr.20080516150804.2708">
def __init__(self):
    self.log = ''
    self.fscommands = FileSystemCommands()

</t>
<t tx="ekr.20080516150804.2709">def create_file(self, path):
    self.log += 'create_file '
    self.fscommands.create_file(path)

</t>
<t tx="ekr.20080516150804.2710">def create_folder(self, path):
    self.log += 'create_folder '
    self.fscommands.create_folder(path)

</t>
<t tx="ekr.20080516150804.2711">def move(self, path, new_location):
    self.log += 'move '
    self.fscommands.move(path, new_location)

</t>
<t tx="ekr.20080516150804.2712">def remove(self, path):
    self.log += 'remove '
    self.fscommands.remove(path)


</t>
<t tx="ekr.20080516150804.2713">class RopeFolderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2714">
def setUp(self):
    super(RopeFolderTest, self).setUp()
    self.project = None

</t>
<t tx="ekr.20080516150804.2715">def tearDown(self):
    if self.project:
        testutils.remove_project(self.project)
    super(RopeFolderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2716">def test_none_project_rope_folder(self):
    self.project = testutils.sample_project(ropefolder=None)
    self.assertTrue(self.project.ropefolder is None)

</t>
<t tx="ekr.20080516150804.2717">def test_getting_project_rope_folder(self):
    self.project = testutils.sample_project(ropefolder='.ropeproject')
    self.assertTrue(self.project.ropefolder.exists())
    self.assertTrue('.ropeproject', self.project.ropefolder.path)

</t>
<t tx="ekr.20080516150804.2718">def test_setting_ignored_resources(self):
    self.project = testutils.sample_project(ignored_resources=['myfile.txt'])
    myfile = self.project.get_file('myfile.txt')
    file2 = self.project.get_file('file2.txt')
    self.assertTrue(self.project.is_ignored(myfile))
    self.assertFalse(self.project.is_ignored(file2))

</t>
<t tx="ekr.20080516150804.2719">def test_ignored_folders(self):
    self.project = testutils.sample_project(ignored_resources=['myfolder'])
    myfolder = self.project.root.create_folder('myfolder')
    self.assertTrue(self.project.is_ignored(myfolder))
    myfile = myfolder.create_file('myfile.txt')
    self.assertTrue(self.project.is_ignored(myfile))

</t>
<t tx="ekr.20080516150804.2720">def test_ignored_resources_and_get_files(self):
    self.project = testutils.sample_project(
        ignored_resources=['myfile.txt'], ropefolder=None)
    myfile = self.project.get_file('myfile.txt')
    self.assertEquals(0, len(self.project.get_files()))
    myfile.create()
    self.assertEquals(0, len(self.project.get_files()))

</t>
<t tx="ekr.20080516150804.2721">def test_ignored_resources_and_get_files2(self):
    self.project = testutils.sample_project(
        ignored_resources=['myfile.txt'], ropefolder=None)
    myfile = self.project.root.create_file('myfile.txt')
    self.assertEquals(0, len(self.project.get_files()))

</t>
<t tx="ekr.20080516150804.2722">def test_setting_ignored_resources_patterns(self):
    self.project = testutils.sample_project(ignored_resources=['m?file.*'])
    myfile = self.project.get_file('myfile.txt')
    file2 = self.project.get_file('file2.txt')
    self.assertTrue(self.project.is_ignored(myfile))
    self.assertFalse(self.project.is_ignored(file2))

</t>
<t tx="ekr.20080516150804.2723">def test_star_should_not_include_slashes(self):
    self.project = testutils.sample_project(ignored_resources=['f*.txt'])
    folder = self.project.root.create_folder('folder')
    file1 = folder.create_file('myfile.txt')
    file2 = folder.create_file('file2.txt')
    self.assertFalse(self.project.is_ignored(file1))
    self.assertTrue(self.project.is_ignored(file2))

</t>
<t tx="ekr.20080516150804.2724">def test_normal_fscommands(self):
    fscommands = _MockFSCommands()
    self.project = testutils.sample_project(fscommands=fscommands)
    myfile = self.project.get_file('myfile.txt')
    myfile.create()
    self.assertTrue('create_file ', fscommands.log)

</t>
<t tx="ekr.20080516150804.2725">def test_fscommands_and_ignored_resources(self):
    fscommands = _MockFSCommands()
    self.project = testutils.sample_project(
        fscommands=fscommands, ignored_resources=['myfile.txt'], ropefolder=None)
    myfile = self.project.get_file('myfile.txt')
    myfile.create()
    self.assertEquals('', fscommands.log)

</t>
<t tx="ekr.20080516150804.2726">def test_ignored_resources_and_prefixes(self):
    self.project = testutils.sample_project(
        ignored_resources=['.hg'])
    myfile = self.project.root.create_file('.hgignore')
    self.assertFalse(self.project.is_ignored(myfile))

</t>
<t tx="ekr.20080516150804.2727">def test_loading_config_dot_py(self):
    self.project = testutils.sample_project(ropefolder='.ropeproject')
    config = self.project.get_file('.ropeproject/config.py')
    if not config.exists():
        config.create()
    config.write('def set_prefs(prefs):\n'
                 '    prefs["ignored_resources"] = ["myfile.txt"]\n'
                 'def project_opened(project):\n'
                 '    project.root.create_file("loaded")\n')
    self.project.close()
    self.project = Project(self.project.address, ropefolder='.ropeproject')
    self.assertTrue(self.project.get_file('loaded').exists())
    myfile = self.project.get_file('myfile.txt')
    self.assertTrue(self.project.is_ignored(myfile))

</t>
<t tx="ekr.20080516150804.2728">def test_ignoring_syntax_errors(self):
    self.project = testutils.sample_project(ropefolder=None,
                                            ignore_syntax_errors=True)
    pycore = self.project.pycore
    mod = testutils.create_module(self.project, 'mod')
    mod.write('xyz print')
    pymod = pycore.resource_to_pyobject(mod)

</t>
<t tx="ekr.20080516150804.2729">def test_compressed_history(self):
    self.project = testutils.sample_project(compress_history=True)
    mod = testutils.create_module(self.project, 'mod')
    mod.write('')

</t>
<t tx="ekr.20080516150804.2730">def test_compressed_objectdb(self):
    self.project = testutils.sample_project(compress_objectdb=True)
    mod = testutils.create_module(self.project, 'mod')
    self.project.pycore.analyze_module(mod)


</t>
<t tx="ekr.20080516150804.2731">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(ProjectTest))
    result.addTests(unittest.makeSuite(ResourceObserverTest))
    result.addTests(unittest.makeSuite(OutOfProjectTest))
    result.addTests(unittest.makeSuite(RopeFolderTest))
    return result

</t>
<t tx="ekr.20080516150804.2732">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2733">import sys
import unittest

from rope.base import exceptions
from rope.base.pycore import _TextChangeDetector
from rope.base.pyobjects import get_base_type, AbstractFunction
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2734">class PyCoreTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2735">
def setUp(self):
    super(PyCoreTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2736">def tearDown(self):
    testutils.remove_project(self.project)
    super(PyCoreTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2737">def test_simple_module(self):
    testutils.create_module(self.project, 'mod')
    result = self.pycore.get_module('mod')
    self.assertEquals(get_base_type('Module'), result.type)
    self.assertEquals(0, len(result.get_attributes()))

</t>
<t tx="ekr.20080516150804.2738">def test_nested_modules(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod = testutils.create_module(self.project, 'mod', pkg)
    package = self.pycore.get_module('pkg')
    self.assertEquals(get_base_type('Module'), package.get_type())
    self.assertEquals(1, len(package.get_attributes()))
    module = package['mod'].get_object()
    self.assertEquals(get_base_type('Module'), module.get_type())

</t>
<t tx="ekr.20080516150804.2739">def test_package(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod = testutils.create_module(self.project, 'mod', pkg)
    result = self.pycore.get_module('pkg')
    self.assertEquals(get_base_type('Module'), result.type)

</t>
<t tx="ekr.20080516150804.2740">def test_simple_class(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class SampleClass(object):\n    pass\n')
    mod_element = self.pycore.get_module('mod')
    result = mod_element['SampleClass'].get_object()
    self.assertEquals(get_base_type('Type'), result.get_type())

</t>
<t tx="ekr.20080516150804.2741">def test_simple_function(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('def sample_function():\n    pass\n')
    mod_element = self.pycore.get_module('mod')
    result = mod_element['sample_function'].get_object()
    self.assertEquals(get_base_type('Function'), result.get_type())

</t>
<t tx="ekr.20080516150804.2742">def test_class_methods(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class SampleClass(object):\n    def sample_method(self):\n        pass\n')
    mod_element = self.pycore.get_module('mod')
    sample_class = mod_element['SampleClass'].get_object()
    self.assertTrue('sample_method' in sample_class)
    method = sample_class['sample_method'].get_object()
    self.assertEquals(get_base_type('Function'), method.get_type())

</t>
<t tx="ekr.20080516150804.2743">def test_global_variables(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('var = 10')
    mod_element = self.pycore.get_module('mod')
    result = mod_element['var']

</t>
<t tx="ekr.20080516150804.2744">def test_class_variables(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class SampleClass(object):\n    var = 10\n')
    mod_element = self.pycore.get_module('mod')
    sample_class = mod_element['SampleClass'].get_object()
    var = sample_class['var']

</t>
<t tx="ekr.20080516150804.2745">def test_class_attributes_set_in_init(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class C(object):\n'
              '    def __init__(self):\n        self.var = 20\n')
    mod_element = self.pycore.get_module('mod')
    sample_class = mod_element['C'].get_object()
    var = sample_class['var']

</t>
<t tx="ekr.20080516150804.2746">def test_class_attributes_set_in_init_overwriting_a_defined(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class C(object):\n'
              '    def __init__(self):\n        self.f = 20\n'
              '    def f():\n        pass\n')
    mod_element = self.pycore.get_module('mod')
    sample_class = mod_element['C'].get_object()
    f = sample_class['f'].get_object()
    self.assertTrue(isinstance(f, AbstractFunction))

</t>
<t tx="ekr.20080516150804.2747">def test_classes_inside_other_classes(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class SampleClass(object):\n    class InnerClass(object):\n        pass\n\n')
    mod_element = self.pycore.get_module('mod')
    sample_class = mod_element['SampleClass'].get_object()
    var = sample_class['InnerClass'].get_object()
    self.assertEquals(get_base_type('Type'), var.get_type())

</t>
<t tx="ekr.20080516150804.2748">@testutils.assert_raises(exceptions.ModuleNotFoundError)
def test_non_existent_module(self):
    self.pycore.get_module('doesnotexistmodule')

</t>
<t tx="ekr.20080516150804.2749">def test_imported_names(self):
    testutils.create_module(self.project, 'mod1')
    mod = testutils.create_module(self.project, 'mod2')
    mod.write('import mod1\n')
    module = self.pycore.get_module('mod2')
    imported_sys = module['mod1'].get_object()
    self.assertEquals(get_base_type('Module'), imported_sys.get_type())

</t>
<t tx="ekr.20080516150804.2750">def test_imported_as_names(self):
    testutils.create_module(self.project, 'mod1')
    mod = testutils.create_module(self.project, 'mod2')
    mod.write('import mod1 as my_import\n')
    module = self.pycore.get_module('mod2')
    imported_mod = module['my_import'].get_object()
    self.assertEquals(get_base_type('Module'), imported_mod.get_type())

</t>
<t tx="ekr.20080516150804.2751">def test_get_string_module(self):
    mod = self.pycore.get_string_module('class Sample(object):\n    pass\n')
    sample_class = mod['Sample'].get_object()
    self.assertEquals(get_base_type('Type'), sample_class.get_type())

</t>
<t tx="ekr.20080516150804.2752">def test_get_string_module_with_extra_spaces(self):
    mod = self.pycore.get_string_module('a = 10\n    ')

</t>
<t tx="ekr.20080516150804.2753">def test_parameter_info_for_functions(self):
    mod = self.pycore.get_string_module('def sample_function(param1, param2=10,' +
                                        ' *param3, **param4):\n    pass')
    sample_function = mod['sample_function']
    self.assertEquals(['param1', 'param2', 'param3', 'param4'],
                      sample_function.get_object().get_param_names())

</t>
<t tx="ekr.20080516150804.2754"># FIXME: Not found modules
def xxx_test_not_found_module_is_module(self):
    mod = self.pycore.get_string_module('import doesnotexist\n')
    self.assertEquals(get_base_type('Module'),
                      mod['doesnotexist'].
                      get_object().get_type())

</t>
<t tx="ekr.20080516150804.2755">def test_mixing_scopes_and_objects_hierarchy(self):
    mod = self.pycore.get_string_module('var = 200\n')
    scope = mod.get_scope()
    self.assertTrue('var' in scope.get_names())

</t>
<t tx="ekr.20080516150804.2756">def test_inheriting_base_class_attributes(self):
    mod = self.pycore.get_string_module(
        'class Base(object):\n    def method(self):\n        pass\n'
        'class Derived(Base):\n    pass\n')
    derived = mod['Derived'].get_object()
    self.assertTrue('method' in derived)
    self.assertEquals(get_base_type('Function'),
                      derived['method'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2757">def test_inheriting_multiple_base_class_attributes(self):
    code = 'class Base1(object):\n    def method1(self):\n        pass\n' \
           'class Base2(object):\n    def method2(self):\n        pass\n' \
           'class Derived(Base1, Base2):\n    pass\n'
    mod = self.pycore.get_string_module(code)
    derived = mod['Derived'].get_object()
    self.assertTrue('method1' in derived)
    self.assertTrue('method2' in derived)

</t>
<t tx="ekr.20080516150804.2758">def test_inheriting_multiple_base_class_attributes_with_the_same_name(self):
    code = 'class Base1(object):\n    def method(self):\n        pass\n' \
           'class Base2(object):\n    def method(self):\n        pass\n' \
           'class Derived(Base1, Base2):\n    pass\n'
    mod = self.pycore.get_string_module(code)
    base1 = mod['Base1'].get_object()
    derived = mod['Derived'].get_object()
    self.assertEquals(base1['method'].get_object(),
                      derived['method'].get_object())

</t>
<t tx="ekr.20080516150804.2759">def test_inheriting_unknown_base_class(self):
    mod = self.pycore.get_string_module('class Derived(NotFound):\n' \
                                        '    def f(self):\n        pass\n')
    derived = mod['Derived'].get_object()
    self.assertTrue('f' in derived)

</t>
<t tx="ekr.20080516150804.2760">def test_module_creation(self):
    new_module = testutils.create_module(self.project, 'module')
    self.assertFalse(new_module.is_folder())
    self.assertEquals(self.project.get_resource('module.py'), new_module)

</t>
<t tx="ekr.20080516150804.2761">def test_packaged_module_creation(self):
    package = self.project.root.create_folder('package')
    new_module = testutils.create_module(self.project, 'package.module')
    self.assertEquals(self.project.get_resource('package/module.py'), new_module)

</t>
<t tx="ekr.20080516150804.2762">def test_packaged_module_creation_with_nested_src(self):
    src = self.project.root.create_folder('src')
    package = src.create_folder('pkg')
    new_module = testutils.create_module(self.project, 'pkg.mod', src)
    self.assertEquals(self.project.get_resource('src/pkg/mod.py'), new_module)

</t>
<t tx="ekr.20080516150804.2763">def test_package_creation(self):
    new_package = testutils.create_package(self.project, 'pkg')
    self.assertTrue(new_package.is_folder())
    self.assertEquals(self.project.get_resource('pkg'), new_package)
    self.assertEquals(self.project.get_resource('pkg/__init__.py'),
                      new_package.get_child('__init__.py'));

</t>
<t tx="ekr.20080516150804.2764">def test_nested_package_creation(self):
    package = testutils.create_package(self.project, 'pkg1')
    nested_package = testutils.create_package(self.project, 'pkg1.pkg2')
    self.assertEquals(self.project.get_resource('pkg1/pkg2'), nested_package)

</t>
<t tx="ekr.20080516150804.2765">def test_packaged_package_creation_with_nested_src(self):
    src = self.project.root.create_folder('src')
    package = testutils.create_package(self.project, 'pkg1', src)
    nested_package = testutils.create_package(self.project, 'pkg1.pkg2', src)
    self.assertEquals(self.project.get_resource('src/pkg1/pkg2'), nested_package)

</t>
<t tx="ekr.20080516150804.2766">def test_find_module(self):
    src = self.project.root.create_folder('src')
    samplemod = testutils.create_module(self.project, 'samplemod', src)
    found_module = self.pycore.find_module('samplemod')
    self.assertEquals(samplemod, found_module)

</t>
<t tx="ekr.20080516150804.2767">def test_find_nested_module(self):
    src = self.project.root.create_folder('src')
    samplepkg = testutils.create_package(self.project, 'samplepkg', src)
    samplemod = testutils.create_module(self.project, 'samplemod', samplepkg)
    found_module = self.pycore.find_module('samplepkg.samplemod')
    self.assertEquals(samplemod, found_module)

</t>
<t tx="ekr.20080516150804.2768">def test_find_multiple_module(self):
    src = self.project.root.create_folder('src')
    samplemod1 = testutils.create_module(self.project, 'samplemod', src)
    samplemod2 = testutils.create_module(self.project, 'samplemod')
    test = self.project.root.create_folder('test')
    samplemod3 = testutils.create_module(self.project, 'samplemod', test)
    found_module = self.pycore.find_module('samplemod')
    self.assertTrue(samplemod1 == found_module or
                    samplemod2 == found_module or
                    samplemod3 == found_module)

</t>
<t tx="ekr.20080516150804.2769">def test_find_module_packages(self):
    src = self.project.root
    samplepkg = testutils.create_package(self.project, 'samplepkg', src)
    found_module = self.pycore.find_module('samplepkg')
    self.assertEquals(samplepkg, found_module)

</t>
<t tx="ekr.20080516150804.2770">def test_find_module_when_module_and_package_with_the_same_name(self):
    src = self.project.root
    samplemod = testutils.create_module(self.project, 'sample', src)
    samplepkg = testutils.create_package(self.project, 'sample', src)
    found_module = self.pycore.find_module('sample')
    self.assertEquals(samplepkg, found_module)

</t>
<t tx="ekr.20080516150804.2771">def test_getting_empty_source_folders(self):
    self.assertEquals([], self.pycore.get_source_folders())

</t>
<t tx="ekr.20080516150804.2772">def test_root_source_folder(self):
    self.project.root.create_file('sample.py')
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(1, len(source_folders))
    self.assertTrue(self.project.root in source_folders)

</t>
<t tx="ekr.20080516150804.2773">def test_root_source_folder2(self):
    self.project.root.create_file('mod1.py')
    self.project.root.create_file('mod2.py')
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(1, len(source_folders))
    self.assertTrue(self.project.root in source_folders)

</t>
<t tx="ekr.20080516150804.2774">def test_src_source_folder(self):
    src = self.project.root.create_folder('src')
    src.create_file('sample.py')
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(1, len(source_folders))
    self.assertTrue(self.project.get_resource('src') in source_folders)

</t>
<t tx="ekr.20080516150804.2775">def test_packages(self):
    src = self.project.root.create_folder('src')
    pkg = src.create_folder('package')
    pkg.create_file('__init__.py')
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(1, len(source_folders))
    self.assertTrue(src in source_folders)

</t>
<t tx="ekr.20080516150804.2776">def test_multi_source_folders(self):
    src = self.project.root.create_folder('src')
    package = src.create_folder('package')
    package.create_file('__init__.py')
    test = self.project.root.create_folder('test')
    test.create_file('alltests.py')
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(2, len(source_folders))
    self.assertTrue(src in source_folders)
    self.assertTrue(test in source_folders)

</t>
<t tx="ekr.20080516150804.2777">def test_multi_source_folders2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    src = self.project.root.create_folder('src')
    package = testutils.create_package(self.project, 'package', src)
    mod2 = testutils.create_module(self.project, 'mod2', package)
    source_folders = self.pycore.get_source_folders()
    self.assertEquals(2, len(source_folders))
    self.assertTrue(self.project.root in source_folders and \
                    src in source_folders)

</t>
<t tx="ekr.20080516150804.2778">def test_get_pyname_definition_location(self):
    mod = self.pycore.get_string_module('a_var = 20\n')
    a_var = mod['a_var']
    self.assertEquals((mod, 1), a_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2779">def test_get_pyname_definition_location_functions(self):
    mod = self.pycore.get_string_module('def a_func():\n    pass\n')
    a_func = mod['a_func']
    self.assertEquals((mod, 1), a_func.get_definition_location())

</t>
<t tx="ekr.20080516150804.2780">def test_get_pyname_definition_location_class(self):
    mod = self.pycore.get_string_module('class AClass(object):\n    pass\n\n')
    a_class = mod['AClass']
    self.assertEquals((mod, 1), a_class.get_definition_location())

</t>
<t tx="ekr.20080516150804.2781">def test_get_pyname_definition_location_local_variables(self):
    mod = self.pycore.get_string_module('def a_func():\n    a_var = 10\n')
    a_func_scope = mod.get_scope().get_scopes()[0]
    a_var = a_func_scope['a_var']
    self.assertEquals((mod, 2), a_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2782">def test_get_pyname_definition_location_reassigning(self):
    mod = self.pycore.get_string_module('a_var = 20\na_var=30\n')
    a_var = mod['a_var']
    self.assertEquals((mod, 1), a_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2783">def test_get_pyname_definition_location_importes(self):
    module = testutils.create_module(self.project, 'mod')
    mod = self.pycore.get_string_module('import mod\n')
    imported_module = self.pycore.get_module('mod')
    module_pyname = mod['mod']
    self.assertEquals((imported_module, 1),
                      module_pyname.get_definition_location())

</t>
<t tx="ekr.20080516150804.2784">def test_get_pyname_definition_location_imports(self):
    module_resource = testutils.create_module(self.project, 'mod')
    module_resource.write('\ndef a_func():\n    pass\n')
    imported_module = self.pycore.get_module('mod')
    mod = self.pycore.get_string_module('from mod import a_func\n')
    a_func = mod['a_func']
    self.assertEquals((imported_module, 2), a_func.get_definition_location())

</t>
<t tx="ekr.20080516150804.2785">def test_get_pyname_definition_location_parameters(self):
    mod = self.pycore.get_string_module('def a_func(param1, param2):\n    a_var = param\n')
    a_func_scope = mod.get_scope().get_scopes()[0]
    param1 = a_func_scope['param1']
    self.assertEquals((mod, 1), param1.get_definition_location())
    param2 = a_func_scope['param2']
    self.assertEquals((mod, 1), param2.get_definition_location())

</t>
<t tx="ekr.20080516150804.2786">def test_module_get_resource(self):
    module_resource = testutils.create_module(self.project, 'mod')
    module = self.pycore.get_module('mod')
    self.assertEquals(module_resource, module.get_resource())
    string_module = self.pycore.get_string_module('from mod import a_func\n')
    self.assertEquals(None, string_module.get_resource())

</t>
<t tx="ekr.20080516150804.2787">def test_get_pyname_definition_location_class2(self):
    mod = self.pycore.get_string_module(
        'class AClass(object):\n    def __init__(self):\n'
        '        self.an_attr = 10\n')
    a_class = mod['AClass'].get_object()
    an_attr = a_class['an_attr']
    self.assertEquals((mod, 3), an_attr.get_definition_location())

</t>
<t tx="ekr.20080516150804.2788">def test_import_not_found_module_get_definition_location(self):
    mod = self.pycore.get_string_module('import doesnotexist\n')
    does_not_exist = mod['doesnotexist']
    self.assertEquals((None, None), does_not_exist.get_definition_location())

</t>
<t tx="ekr.20080516150804.2789">def test_from_not_found_module_get_definition_location(self):
    mod = self.pycore.get_string_module('from doesnotexist import Sample\n')
    sample = mod['Sample']
    self.assertEquals((None, None), sample.get_definition_location())

</t>
<t tx="ekr.20080516150804.2790">def test_from_package_import_module_get_definition_location(self):
    pkg = testutils.create_package(self.project, 'pkg')
    testutils.create_module(self.project, 'mod', pkg)
    pkg_mod = self.pycore.get_module('pkg.mod')
    mod = self.pycore.get_string_module('from pkg import mod\n')
    imported_mod = mod['mod']
    self.assertEquals((pkg_mod, 1),
                      imported_mod.get_definition_location())

</t>
<t tx="ekr.20080516150804.2791">def test_get_module_for_defined_pyobjects(self):
    mod = self.pycore.get_string_module('class AClass(object):\n    pass\n')
    a_class = mod['AClass'].get_object()
    self.assertEquals(mod, a_class.get_module())

</t>
<t tx="ekr.20080516150804.2792">def test_get_definition_location_for_packages(self):
    pkg = testutils.create_package(self.project, 'pkg')
    init_module = self.pycore.get_module('pkg.__init__')
    mod = self.pycore.get_string_module('import pkg\n')
    pkg_pyname = mod['pkg']
    self.assertEquals((init_module, 1), pkg_pyname.get_definition_location())

</t>
<t tx="ekr.20080516150804.2793">def test_get_definition_location_for_filtered_packages(self):
    pkg = testutils.create_package(self.project, 'pkg')
    testutils.create_module(self.project, 'mod', pkg)
    init_module = self.pycore.get_module('pkg.__init__')
    mod = self.pycore.get_string_module('import pkg.mod')
    pkg_pyname = mod['pkg']
    self.assertEquals((init_module, 1), pkg_pyname.get_definition_location())

</t>
<t tx="ekr.20080516150804.2794">def test_out_of_project_modules(self):
    scope = self.pycore.get_string_scope('import rope.base.project as project\n')
    imported_module = scope['project'].get_object()
    self.assertTrue('Project' in imported_module)

</t>
<t tx="ekr.20080516150804.2795">def test_file_encoding_reading(self):
    contents = u'# -*- coding: utf-8 -*-\n#\N{LATIN SMALL LETTER I WITH DIAERESIS}\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(contents)
    self.pycore.get_module('mod')

</t>
<t tx="ekr.20080516150804.2796">def test_global_keyword(self):
    contents = 'a_var = 1\ndef a_func():\n    global a_var\n'
    mod = self.pycore.get_string_module(contents)
    global_var = mod['a_var']
    func_scope = mod['a_func'].get_object().get_scope()
    local_var = func_scope['a_var']
    self.assertEquals(global_var, local_var)

</t>
<t tx="ekr.20080516150804.2797">def test_not_leaking_for_vars_inside_parent_scope(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class C(object):\n    def f(self):\n'
              '        for my_var1, my_var2 in []:\n            pass\n')
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    self.assertFalse('my_var1' in c_class)
    self.assertFalse('my_var2' in c_class)

</t>
<t tx="ekr.20080516150804.2798">def test_not_leaking_for_vars_inside_parent_scope2(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class C(object):\n    def f(self):\n'
              '        for my_var in []:\n            pass\n')
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    self.assertFalse('my_var' in c_class)

</t>
<t tx="ekr.20080516150804.2799">def test_variables_defined_in_excepts(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('try:\n    myvar1 = 1\nexcept:\n    myvar2 = 1\n'
              'finally:\n    myvar3 = 1\n')
    pymod = self.pycore.resource_to_pyobject(mod)
    self.assertTrue('myvar1' in pymod)
    self.assertTrue('myvar2' in pymod)
    self.assertTrue('myvar3' in pymod)

</t>
<t tx="ekr.20080516150804.2800">def test_not_leaking_tuple_assigned_names_inside_parent_scope(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('class C(object):\n    def f(self):\n'
              '        var1, var2 = range(2)\n')
    pymod = self.pycore.resource_to_pyobject(mod)
    c_class = pymod['C'].get_object()
    self.assertFalse('var1' in c_class)

</t>
<t tx="ekr.20080516150804.2801">@testutils.run_only_for_25
def test_with_statement_variables(self):
    code = 'import threading\nwith threading.lock() as var:    pass\n'
    if sys.version_info &lt; (2, 6, 0):
        code = 'from __future__ import with_statement\n' + code
    pymod = self.pycore.get_string_module(code)
    self.assertTrue('var' in pymod)

</t>
<t tx="ekr.20080516150804.2802">@testutils.run_only_for_25
def test_with_statement_variables_and_tuple_assignment(self):
    code = 'class A(object):\n    def __enter__(self):        return (1, 2)\n'\
           '    def __exit__(self, type, value, tb):\n        pass\n'\
           'with A() as (a, b):    pass\n'
    if sys.version_info &lt; (2, 6, 0):
        code = 'from __future__ import with_statement\n' + code
    pymod = self.pycore.get_string_module(code)
    self.assertTrue('a' in pymod)
    self.assertTrue('b' in pymod)

</t>
<t tx="ekr.20080516150804.2803">@testutils.run_only_for_25
def test_with_statement_variable_type(self):
    code = 'class A(object):\n' \
           '    def __enter__(self):        return self\n'\
           '    def __exit__(self, type, value, tb):\n        pass\n'\
           'with A() as var:    pass\n'
    if sys.version_info &lt; (2, 6, 0):
        code = 'from __future__ import with_statement\n' + code
    pymod = self.pycore.get_string_module(code)
    a_class = pymod['A'].get_object()
    var = pymod['var'].get_object()
    self.assertEquals(a_class, var.get_type())

</t>
<t tx="ekr.20080516150804.2804">@testutils.run_only_for_25
def test_with_statement_with_no_vars(self):
    code = 'with open("file"):    pass\n'
    if sys.version_info &lt; (2, 6, 0):
        code = 'from __future__ import with_statement\n' + code
    pymod = self.pycore.get_string_module(code)
    pymod.get_attributes()

</t>
<t tx="ekr.20080516150804.2805">def test_check_for_else_block(self):
    mod = self.pycore.get_string_module('for i in range(10):\n    pass\n'
                                        'else:\n    myvar = 1\n')
    a_var = mod['myvar']
    self.assertEquals((mod, 4), a_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2806">def test_check_names_defined_in_whiles(self):
    mod = self.pycore.get_string_module('while False:\n    myvar = 1\n')
    a_var = mod['myvar']
    self.assertEquals((mod, 2), a_var.get_definition_location())

</t>
<t tx="ekr.20080516150804.2807">def test_get_definition_location_in_tuple_assnames(self):
    mod = self.pycore.get_string_module(
        'def f(x):\n    x.z, a = range(2)\n')
    x = mod['f'].get_object().get_scope()['x']
    a = mod['f'].get_object().get_scope()['a']
    self.assertEquals((mod, 1), x.get_definition_location())
    self.assertEquals((mod, 2), a.get_definition_location())

</t>
<t tx="ekr.20080516150804.2808">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_syntax_errors_in_code(self):
    mod = self.pycore.get_string_module('xyx print\n')

</t>
<t tx="ekr.20080516150804.2809">def test_holding_error_location_information(self):
    try:
        mod = self.pycore.get_string_module('xyx print\n')
    except exceptions.ModuleSyntaxError, e:
        self.assertEquals(1, e.lineno)

</t>
<t tx="ekr.20080516150804.2810">@testutils.assert_raises(exceptions.ModuleDecodeError)
def test_not_syntax_errors_when_cannot_decode_file(self):
    mod = testutils.create_module(self.project, 'mod')
    contents = '\nsdsdsd\n\xa9\n'
    file = open(mod.real_path, 'wb')
    file.write(contents)
    file.close()
    mod.read()

</t>
<t tx="ekr.20080516150804.2811">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_syntax_errors_when_cannot_decode_file2(self):
    mod = testutils.create_module(self.project, 'mod')
    contents = '\n\xa9\n'
    file = open(mod.real_path, 'wb')
    file.write(contents)
    file.close()
    self.pycore.resource_to_pyobject(mod)

</t>
<t tx="ekr.20080516150804.2812">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_syntax_errors_when_null_bytes(self):
    mod = testutils.create_module(self.project, 'mod')
    contents = '\n\x00\n'
    file = open(mod.real_path, 'wb')
    file.write(contents)
    file.close()
    self.pycore.resource_to_pyobject(mod)

</t>
<t tx="ekr.20080516150804.2813">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_syntax_errors_when_bad_strs(self):
    mod = testutils.create_module(self.project, 'mod')
    contents = '\n"\\x0"\n'
    file = open(mod.real_path, 'wb')
    file.write(contents)
    file.close()
    self.pycore.resource_to_pyobject(mod)

</t>
<t tx="ekr.20080516150804.2814">def test_not_reaching_maximum_recursions_with_from_star_imports(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('from mod2 import *\n')
    mod2.write('from mod1 import *\n')
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    pymod1.get_attributes()

</t>
<t tx="ekr.20080516150804.2815">def test_not_reaching_maximum_recursions_when_importing_variables(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('from mod2 import myvar\n')
    mod2.write('from mod1 import myvar\n')
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    pymod1['myvar'].get_object()

</t>
<t tx="ekr.20080516150804.2816">def test_not_reaching_maximum_recursions_when_importing_variables2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('from mod1 import myvar\n')
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    pymod1['myvar'].get_object()

</t>
<t tx="ekr.20080516150804.2817">def test_pyobject_equality_should_compare_types(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('var1 = ""\nvar2 = ""\n')
    pymod1 = self.pycore.resource_to_pyobject(mod1)
    self.assertEquals(pymod1['var1'].get_object(),
                      pymod1['var2'].get_object())


</t>
<t tx="ekr.20080516150804.2818">class PyCoreInProjectsTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2819">
def setUp(self):
    super(self.__class__, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    samplemod = testutils.create_module(self.project, 'samplemod')
    samplemod.write(
        'class SampleClass(object):\n    def sample_method():\n        pass'
        '\n\ndef sample_func():\n    pass\nsample_var = 10\n'
        '\ndef _underlined_func():\n    pass\n\n')
    package = testutils.create_package(self.project, 'package')
    nestedmod = testutils.create_module(self.project, 'nestedmod', package)

</t>
<t tx="ekr.20080516150804.2820">def tearDown(self):
    testutils.remove_project(self.project)
    super(self.__class__, self).tearDown()

</t>
<t tx="ekr.20080516150804.2821">def test_simple_import(self):
    mod = self.pycore.get_string_module('import samplemod\n')
    samplemod = mod['samplemod'].get_object()
    self.assertEquals(get_base_type('Module'), samplemod.get_type())

</t>
<t tx="ekr.20080516150804.2822">def test_from_import_class(self):
    mod = self.pycore.get_string_module('from samplemod import SampleClass\n')
    result = mod['SampleClass'].get_object()
    self.assertEquals(get_base_type('Type'), result.get_type())
    self.assertTrue('sample_func' not in mod.get_attributes())

</t>
<t tx="ekr.20080516150804.2823">def test_from_import_star(self):
    mod = self.pycore.get_string_module('from samplemod import *\n')
    self.assertEquals(get_base_type('Type'),
                      mod['SampleClass'].get_object().get_type())
    self.assertEquals(get_base_type('Function'),
                      mod['sample_func'].get_object().get_type())
    self.assertTrue(mod['sample_var'] is not None)

</t>
<t tx="ekr.20080516150804.2824">def test_from_import_star_overwriting(self):
    code = 'from samplemod import *\n' \
           'class SampleClass(object):\n    pass\n'
    mod = self.pycore.get_string_module(code)
    samplemod = self.pycore.get_module('samplemod')
    sample_class = samplemod['SampleClass'].get_object()
    self.assertNotEquals(sample_class,
                         mod.get_attributes()['SampleClass'].get_object())

</t>
<t tx="ekr.20080516150804.2825">def test_from_import_star_not_imporing_underlined(self):
    mod = self.pycore.get_string_module('from samplemod import *')
    self.assertTrue('_underlined_func' not in mod.get_attributes())

</t>
<t tx="ekr.20080516150804.2826">def test_from_import_star_imports_in_functions(self):
    mod = self.pycore.get_string_module('def f():\n    from os import *\n')
    mod['f'].get_object().get_scope().get_names()

</t>
<t tx="ekr.20080516150804.2827">def test_from_package_import_mod(self):
    mod = self.pycore.get_string_module('from package import nestedmod\n')
    self.assertEquals(get_base_type('Module'),
                      mod['nestedmod'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2828"># XXX: Deciding to import everything on import start from packages
def xxx_test_from_package_import_star(self):
    mod = self.pycore.get_string_module('from package import *\n')
    self.assertTrue('nestedmod' not in mod.get_attributes())

</t>
<t tx="ekr.20080516150804.2829">def test_unknown_when_module_cannot_be_found(self):
    mod = self.pycore.get_string_module('from doesnotexist import nestedmod\n')
    self.assertTrue('nestedmod' in mod)

</t>
<t tx="ekr.20080516150804.2830">def test_from_import_function(self):
    scope = self.pycore.get_string_scope('def f():\n    from samplemod import SampleClass\n')
    self.assertEquals(get_base_type('Type'),
                      scope.get_scopes()[0]['SampleClass'].
                      get_object().get_type())

</t>
<t tx="ekr.20080516150804.2831">def test_circular_imports(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('import mod2\n')
    mod2.write('import mod1\n')
    module1 = self.pycore.get_module('mod1')

</t>
<t tx="ekr.20080516150804.2832">def test_circular_imports2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('from mod2 import Sample2\nclass Sample1(object):\n    pass\n')
    mod2.write('from mod1 import Sample1\nclass Sample2(object):\n    pass\n')
    module1 = self.pycore.get_module('mod1').get_attributes()

</t>
<t tx="ekr.20080516150804.2833">def test_multi_dot_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    pkg_mod = testutils.create_module(self.project, 'mod', pkg)
    pkg_mod.write('def sample_func():\n    pass\n')
    mod = self.pycore.get_string_module('import pkg.mod\n')
    self.assertTrue('pkg' in mod)
    self.assertTrue('sample_func' in mod['pkg'].get_object()['mod'].
                            get_object())

</t>
<t tx="ekr.20080516150804.2834">def test_multi_dot_imports2(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod = self.pycore.get_string_module('import pkg.mod1\nimport pkg.mod2\n')
    package = mod['pkg'].get_object()
    self.assertEquals(2, len(package.get_attributes()))
    self.assertTrue('mod1' in package and
                    'mod2' in package)

</t>
<t tx="ekr.20080516150804.2835">def test_multi_dot_imports3(self):
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    mod1 = testutils.create_module(self.project, 'mod1', pkg2)
    mod2 = testutils.create_module(self.project, 'mod2', pkg2)
    mod = self.pycore.get_string_module('import pkg1.pkg2.mod1\nimport pkg1.pkg2.mod2\n')
    package1 = mod['pkg1'].get_object()
    package2 = package1['pkg2'].get_object()
    self.assertEquals(2, len(package2.get_attributes()))
    self.assertTrue('mod1' in package2 and
                    'mod2' in package2)

</t>
<t tx="ekr.20080516150804.2836">def test_multi_dot_imports_as(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod1.write('def f():\n    pass\n')
    mod = self.pycore.get_string_module('import pkg.mod1 as mod1\n')
    module = mod['mod1'].get_object()
    self.assertTrue('f' in module)

</t>
<t tx="ekr.20080516150804.2837"># TODO: not showing unimported names as attributes of packages
def xxx_test_from_package_import_package(self):
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    module = testutils.create_module(self.project, 'mod', pkg2)
    mod = self.pycore.get_string_module('from pkg1 import pkg2\n')
    package = mod['pkg2']
    self.assertEquals(0, len(package.get_attributes()))

</t>
<t tx="ekr.20080516150804.2838">def test_invalidating_cache_after_resource_change(self):
    module = testutils.create_module(self.project, 'mod')
    module.write('import sys\n')
    mod1 = self.pycore.get_module('mod')
    self.assertTrue('var' not in mod1.get_attributes())
    module.write('var = 10\n')
    mod2 = self.pycore.get_module('mod')
    self.assertTrue('var' in mod2)

</t>
<t tx="ekr.20080516150804.2839">def test_invalidating_cache_after_resource_change_for_init_dot_pys(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod = testutils.create_module(self.project, 'mod')
    init_dot_py = pkg.get_child('__init__.py')
    init_dot_py.write('a_var = 10\n')
    mod.write('import pkg\n')
    pymod = self.pycore.get_module('mod')
    self.assertTrue('a_var' in pymod['pkg'].get_object())
    init_dot_py.write('new_var = 10\n')
    self.assertTrue('a_var' not in pymod['pkg'].get_object().get_attributes())

</t>
<t tx="ekr.20080516150804.2840">def test_invalidating_cache_after_resource_change_for_nested_init_dot_pys(self):
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    mod = testutils.create_module(self.project, 'mod')
    init_dot_py = pkg2.get_child('__init__.py')
    init_dot_py.write('a_var = 10\n')
    mod.write('import pkg1\n')
    pymod = self.pycore.get_module('mod')
    self.assertTrue('a_var' in pymod['pkg1'].get_object()['pkg2'].get_object())
    init_dot_py.write('new_var = 10\n')
    self.assertTrue('a_var' not in pymod['pkg1'].get_object()['pkg2'].get_object())

</t>
<t tx="ekr.20080516150804.2841">def test_from_import_nonexistent_module(self):
    mod = self.pycore.get_string_module('from doesnotexistmod import DoesNotExistClass\n')
    self.assertTrue('DoesNotExistClass' in mod)
    self.assertEquals(get_base_type('Unknown'),
                      mod['DoesNotExistClass'].
                      get_object().get_type())

</t>
<t tx="ekr.20080516150804.2842">def test_from_import_nonexistent_name(self):
    mod = self.pycore.get_string_module('from samplemod import DoesNotExistClass\n')
    self.assertTrue('DoesNotExistClass' in mod)
    self.assertEquals(get_base_type('Unknown'),
                      mod['DoesNotExistClass'].
                      get_object().get_type())

</t>
<t tx="ekr.20080516150804.2843">def test_not_considering_imported_names_as_sub_scopes(self):
    scope = self.pycore.get_string_scope('from samplemod import SampleClass\n')
    self.assertEquals(0, len(scope.get_scopes()))

</t>
<t tx="ekr.20080516150804.2844">def test_not_considering_imported_modules_as_sub_scopes(self):
    scope = self.pycore.get_string_scope('import samplemod\n')
    self.assertEquals(0, len(scope.get_scopes()))

</t>
<t tx="ekr.20080516150804.2845">def test_inheriting_dotted_base_class(self):
    mod = self.pycore.get_string_module('import samplemod\n' +
                                        'class Derived(samplemod.SampleClass):\n    pass\n')
    derived = mod['Derived'].get_object()
    self.assertTrue('sample_method' in derived)

</t>
<t tx="ekr.20080516150804.2846">def test_self_in_methods(self):
    scope = self.pycore.get_string_scope(
        'class Sample(object):\n'
        '    def func(self):\n        pass\n')
    sample_class = scope['Sample'].get_object()
    func_scope = scope.get_scopes()[0].get_scopes()[0]
    self.assertEquals(sample_class,
                      func_scope['self'].get_object().get_type())
    self.assertTrue('func' in func_scope['self'].
                            get_object())

</t>
<t tx="ekr.20080516150804.2847">def test_none_assignments_in_classes(self):
    scope = self.pycore.get_string_scope(
        'class C(object):\n    var = ""\n'
        '    def f(self):\n        self.var += "".join([])\n')
    c_class = scope['C'].get_object()
    self.assertTrue('var' in c_class)

</t>
<t tx="ekr.20080516150804.2848">def test_self_in_methods_with_decorators(self):
    scope = self.pycore.get_string_scope('class Sample(object):\n    @staticmethod\n' +
                                         '    def func(self):\n        pass\n')
    sample_class = scope['Sample'].get_object()
    func_scope = scope.get_scopes()[0].get_scopes()[0]
    self.assertNotEquals(sample_class,
                         func_scope['self'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2849">def test_location_of_imports_when_importing(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('from samplemod import SampleClass\n')
    scope = self.pycore.get_string_scope('from mod import SampleClass\n')
    sample_class = scope['SampleClass']
    samplemod = self.pycore.get_module('samplemod')
    self.assertEquals((samplemod, 1), sample_class.get_definition_location())

</t>
<t tx="ekr.20080516150804.2850">def test_nested_modules(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod = testutils.create_module(self.project, 'mod', pkg)
    imported_module = self.pycore.get_module('pkg.mod')
    scope = self.pycore.get_string_scope('import pkg.mod\n')
    mod_pyobject = scope['pkg'].get_object()['mod']
    self.assertEquals((imported_module, 1),
                      mod_pyobject.get_definition_location())

</t>
<t tx="ekr.20080516150804.2851">def test_reading_init_dot_py(self):
    pkg = testutils.create_package(self.project, 'pkg')
    init_dot_py = pkg.get_child('__init__.py')
    init_dot_py.write('a_var = 1\n')
    pkg_object = self.pycore.get_module('pkg')
    self.assertTrue('a_var' in pkg_object)

</t>
<t tx="ekr.20080516150804.2852">def test_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('import mod1\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_object = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(mod1_object, mod2_object.get_attributes()['mod1'].get_object())

</t>
<t tx="ekr.20080516150804.2853">def test_relative_froms(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod1.write('def a_func():\n    pass\n')
    mod2.write('from mod1 import a_func\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_object = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(mod1_object['a_func'].get_object(),
                      mod2_object['a_func'].get_object())

</t>
<t tx="ekr.20080516150804.2854">def test_relative_imports_for_string_modules(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('import mod1\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_object = self.pycore.get_string_module(mod2.read(), mod2)
    self.assertEquals(mod1_object, mod2_object['mod1'].get_object())

</t>
<t tx="ekr.20080516150804.2855">def test_relative_imports_for_string_scopes(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('import mod1\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_scope = self.pycore.get_string_scope(mod2.read(), mod2)
    self.assertEquals(mod1_object, mod2_scope['mod1'].get_object())

</t>
<t tx="ekr.20080516150804.2856">@testutils.run_only_for_25
def test_new_style_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('from . import mod1\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_object = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(mod1_object, mod2_object['mod1'].get_object())

</t>
<t tx="ekr.20080516150804.2857">@testutils.run_only_for_25
def test_new_style_relative_imports2(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod1.write('def a_func():\n    pass\n')
    mod2.write('from ..mod1 import a_func\n')
    mod1_object = self.pycore.resource_to_pyobject(mod1)
    mod2_object = self.pycore.resource_to_pyobject(mod2)
    self.assertEquals(mod1_object['a_func'].get_object(),
                      mod2_object['a_func'].get_object())

</t>
<t tx="ekr.20080516150804.2858">def test_invalidating_cache_for_from_imports_after_resource_change(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('def a_func():\n    print(1)\n')
    mod1.write('from mod2 import a_func\na_func()\n')

    pymod1 = self.pycore.get_module('mod1')
    pymod2 = self.pycore.get_module('mod2')
    self.assertEquals(pymod1['a_func'].get_object(),
                      pymod2['a_func'].get_object())
    mod2.write(mod2.read() + '\n')
    pymod2 = self.pycore.get_module('mod2')
    self.assertEquals(pymod1['a_func'].get_object(),
                      pymod2['a_func'].get_object())

</t>
<t tx="ekr.20080516150804.2859">def test_invalidating_superclasses_after_change(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('class A(object):\n    def func1(self):\n        pass\n')
    mod2.write('import mod1\nclass B(mod1.A):\n    pass\n')

    b_class = self.pycore.get_module('mod2')['B'].get_object()
    self.assertTrue('func1' in b_class)

    mod1.write('class A(object):\n    def func2(self):\n        pass\n')
    self.assertTrue('func2' in b_class)


</t>
<t tx="ekr.20080516150804.2860">class TextChangeDetectorTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2861">
def test_trivial_case(self):
    detector = _TextChangeDetector('\n', '\n')
    self.assertFalse(detector.is_changed(1, 1))

</t>
<t tx="ekr.20080516150804.2862">def test_one_line_change(self):
    detector = _TextChangeDetector('1\n2\n', '1\n3\n')
    self.assertFalse(detector.is_changed(1, 1))
    self.assertTrue(detector.is_changed(2, 2))

</t>
<t tx="ekr.20080516150804.2863">def test_line_expansion(self):
    detector = _TextChangeDetector('1\n2\n', '1\n3\n4\n2\n')
    self.assertFalse(detector.is_changed(1, 1))
    self.assertFalse(detector.is_changed(2, 2))

</t>
<t tx="ekr.20080516150804.2864">def test_line_removals(self):
    detector = _TextChangeDetector('1\n3\n4\n2\n', '1\n2\n')
    self.assertFalse(detector.is_changed(1, 1))
    self.assertTrue(detector.is_changed(2, 3))
    self.assertFalse(detector.is_changed(4, 4))

</t>
<t tx="ekr.20080516150804.2865">def test_multi_line_checks(self):
    detector = _TextChangeDetector('1\n2\n', '1\n3\n')
    self.assertTrue(detector.is_changed(1, 2))

</t>
<t tx="ekr.20080516150804.2866">def test_consume_change(self):
    detector = _TextChangeDetector('1\n2\n', '1\n3\n')
    self.assertTrue(detector.is_changed(1, 2))
    self.assertTrue(detector.consume_changes(1, 2))
    self.assertFalse(detector.is_changed(1, 2))


</t>
<t tx="ekr.20080516150804.2867">class PyCoreProjectConfigsTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2868">
def setUp(self):
    super(PyCoreProjectConfigsTest, self).setUp()
    self.project = None

</t>
<t tx="ekr.20080516150804.2869">def tearDown(self):
    if self.project:
        testutils.remove_project(self.project)
    super(PyCoreProjectConfigsTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2870">def test_python_files_config(self):
    self.project = testutils.sample_project(python_files=['myscript'])
    myscript = self.project.root.create_file('myscript')
    self.assertTrue(self.project.pycore.is_python_file(myscript))

</t>
<t tx="ekr.20080516150804.2871">def test_ignore_bad_imports(self):
    self.project = testutils.sample_project(ignore_bad_imports=True)
    pymod = self.project.pycore.get_string_module(
        'import some_nonexistent_module\n')
    self.assertFalse('some_nonexistent_module' in pymod)

</t>
<t tx="ekr.20080516150804.2872">def test_ignore_bad_imports_for_froms(self):
    self.project = testutils.sample_project(ignore_bad_imports=True)
    pymod = self.project.pycore.get_string_module(
        'from some_nonexistent_module import var\n')
    self.assertFalse('var' in pymod)

</t>
<t tx="ekr.20080516150804.2873">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_reporting_syntax_errors_with_force_errors(self):
    self.project = testutils.sample_project(ignore_syntax_errors=True)
    mod = testutils.create_module(self.project, 'mod')
    mod.write('syntax error ...\n')
    self.project.pycore.resource_to_pyobject(mod, force_errors=True)

</t>
<t tx="ekr.20080516150804.2874">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_reporting_syntax_errors_in_strings_with_force_errors(self):
    self.project = testutils.sample_project(ignore_syntax_errors=True)
    self.project.pycore.get_string_module('syntax error ...',
                                          force_errors=True)

</t>
<t tx="ekr.20080516150804.2875">def test_not_raising_errors_for_strings_with_ignore_errors(self):
    self.project = testutils.sample_project(ignore_syntax_errors=True)
    self.project.pycore.get_string_module('syntax error ...')

</t>
<t tx="ekr.20080516150804.2876">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_reporting_syntax_errors_with_force_errors_for_packages(self):
    self.project = testutils.sample_project(ignore_syntax_errors=True)
    pkg = testutils.create_package(self.project, 'pkg')
    pkg.get_child('__init__.py').write('syntax error ...\n')
    self.project.pycore.resource_to_pyobject(pkg, force_errors=True)


</t>
<t tx="ekr.20080516150804.2877">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(PyCoreTest))
    result.addTests(unittest.makeSuite(PyCoreInProjectsTest))
    result.addTests(unittest.makeSuite(TextChangeDetectorTest))
    result.addTests(unittest.makeSuite(PyCoreProjectConfigsTest))
    return result


</t>
<t tx="ekr.20080516150804.2878">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2879">import unittest

from rope.base.pyobjects import get_base_type
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2880">class PyCoreScopesTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2881">
def setUp(self):
    super(PyCoreScopesTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2882">def tearDown(self):
    testutils.remove_project(self.project)
    super(PyCoreScopesTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2883">def test_simple_scope(self):
    scope = self.pycore.get_string_scope('def sample_func():\n    pass\n')
    sample_func = scope['sample_func'].get_object()
    self.assertEquals(get_base_type('Function'), sample_func.get_type())

</t>
<t tx="ekr.20080516150804.2884">def test_simple_function_scope(self):
    scope = self.pycore.get_string_scope(
        'def sample_func():\n    a = 10\n')
    self.assertEquals(1, len(scope.get_scopes()))
    sample_func_scope = scope.get_scopes()[0]
    self.assertEquals(1, len(sample_func_scope.get_names()))
    self.assertEquals(0, len(sample_func_scope.get_scopes()))

</t>
<t tx="ekr.20080516150804.2885">def test_classes_inside_function_scopes(self):
    scope = self.pycore.get_string_scope(
        'def sample_func():\n'
        '    class SampleClass(object):\n        pass\n')
    self.assertEquals(1, len(scope.get_scopes()))
    sample_func_scope = scope.get_scopes()[0]
    self.assertEquals(get_base_type('Type'),
                      scope.get_scopes()[0]['SampleClass'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2886">def test_simple_class_scope(self):
    scope = self.pycore.get_string_scope(
        'class SampleClass(object):\n'
        '    def f(self):\n        var = 10\n')
    self.assertEquals(1, len(scope.get_scopes()))
    sample_class_scope = scope.get_scopes()[0]
    self.assertTrue('f' in sample_class_scope)
    self.assertEquals(1, len(sample_class_scope.get_scopes()))
    f_in_class = sample_class_scope.get_scopes()[0]
    self.assertTrue('var' in f_in_class)

</t>
<t tx="ekr.20080516150804.2887">def test_get_lineno(self):
    scope = self.pycore.get_string_scope(
        '\ndef sample_func():\n    a = 10\n')
    self.assertEquals(1, len(scope.get_scopes()))
    sample_func_scope = scope.get_scopes()[0]
    self.assertEquals(1, scope.get_start())
    self.assertEquals(2, sample_func_scope.get_start())

</t>
<t tx="ekr.20080516150804.2888">def test_scope_kind(self):
    scope = self.pycore.get_string_scope(
        'class SampleClass(object):\n    pass\n'
        'def sample_func():\n    pass\n')
    sample_class_scope = scope.get_scopes()[0]
    sample_func_scope = scope.get_scopes()[1]
    self.assertEquals('Module', scope.get_kind())
    self.assertEquals('Class', sample_class_scope.get_kind())
    self.assertEquals('Function', sample_func_scope.get_kind())

</t>
<t tx="ekr.20080516150804.2889">def test_function_parameters_in_scope_names(self):
    scope = self.pycore.get_string_scope(
        'def sample_func(param):\n    a = 10\n')
    sample_func_scope = scope.get_scopes()[0]
    self.assertTrue('param' in sample_func_scope)

</t>
<t tx="ekr.20080516150804.2890">def test_get_names_contains_only_names_defined_in_a_scope(self):
    scope = self.pycore.get_string_scope(
        'var1 = 10\ndef sample_func(param):\n    var2 = 20\n')
    sample_func_scope = scope.get_scopes()[0]
    self.assertTrue('var1' not in sample_func_scope)

</t>
<t tx="ekr.20080516150804.2891">def test_scope_lookup(self):
    scope = self.pycore.get_string_scope(
        'var1 = 10\ndef sample_func(param):\n    var2 = 20\n')
    self.assertTrue(scope.lookup('var2') is None)
    self.assertEquals(get_base_type('Function'),
                      scope.lookup('sample_func').get_object().get_type())
    sample_func_scope = scope.get_scopes()[0]
    self.assertTrue(sample_func_scope.lookup('var1') is not None)

</t>
<t tx="ekr.20080516150804.2892">def test_function_scopes(self):
    scope = self.pycore.get_string_scope('def func():\n    var = 10\n')
    func_scope = scope.get_scopes()[0]
    self.assertTrue('var' in func_scope)

</t>
<t tx="ekr.20080516150804.2893">def test_function_scopes_classes(self):
    scope = self.pycore.get_string_scope(
        'def func():\n    class Sample(object):\n        pass\n')
    func_scope = scope.get_scopes()[0]
    self.assertTrue('Sample' in func_scope)

</t>
<t tx="ekr.20080516150804.2894">def test_function_getting_scope(self):
    mod = self.pycore.get_string_module('def func():    var = 10\n')
    func_scope = mod['func'].get_object().get_scope()
    self.assertTrue('var' in func_scope)

</t>
<t tx="ekr.20080516150804.2895">def test_scopes_in_function_scopes(self):
    scope = self.pycore.get_string_scope(
        'def func():\n    def inner():\n        var = 10\n')
    func_scope = scope.get_scopes()[0]
    inner_scope = func_scope.get_scopes()[0]
    self.assertTrue('var' in inner_scope)

</t>
<t tx="ekr.20080516150804.2896">def test_for_variables_in_scopes(self):
    scope = self.pycore.get_string_scope(
        'for a_var in range(10):\n    pass\n')
    self.assertTrue('a_var' in scope)

</t>
<t tx="ekr.20080516150804.2897">def test_assists_inside_fors(self):
    scope = self.pycore.get_string_scope(
        'for i in range(10):\n    a_var = i\n')
    self.assertTrue('a_var' in scope)

</t>
<t tx="ekr.20080516150804.2898">def test_first_parameter_of_a_method(self):
    code = 'class AClass(object):\n' \
           '    def a_func(self, param):\n        pass\n'
    a_class = self.pycore.get_string_module(code)['AClass']. get_object()
    function_scope = a_class['a_func'].get_object().get_scope()
    self.assertEquals(a_class, function_scope['self'].get_object().get_type())
    self.assertNotEquals(a_class, function_scope['param'].
                         get_object().get_type())

</t>
<t tx="ekr.20080516150804.2899">def test_first_parameter_of_static_methods(self):
    code = 'class AClass(object):\n' \
           '    @staticmethod\n    def a_func(param):\n        pass\n'
    a_class = self.pycore.get_string_module(code)['AClass']. get_object()
    function_scope = a_class['a_func'].\
                     get_object().get_scope()
    self.assertNotEquals(a_class, function_scope['param'].get_object().get_type())

</t>
<t tx="ekr.20080516150804.2900">def test_first_parameter_of_class_methods(self):
    code = 'class AClass(object):\n' \
        '    @classmethod\n    def a_func(cls):\n        pass\n'
    a_class = self.pycore.get_string_module(code)['AClass']. get_object()
    function_scope = a_class['a_func'].get_object().get_scope()
    self.assertEquals(a_class, function_scope['cls'].get_object())

</t>
<t tx="ekr.20080516150804.2901">def test_first_parameter_with_self_as_name_and_unknown_decorator(self):
    code = 'def my_decorator(func):\n    return func\n'\
           'class AClass(object):\n' \
           '    @my_decorator\n    def a_func(self):\n        pass\n'
    a_class = self.pycore.get_string_module(code)['AClass']. get_object()
    function_scope = a_class['a_func'].get_object().get_scope()
    self.assertEquals(a_class, function_scope['self'].
                      get_object().get_type())

</t>
<t tx="ekr.20080516150804.2902">def test_inside_class_scope_attribute_lookup(self):
    scope = self.pycore.get_string_scope(
        'class C(object):\n'
        '    an_attr = 1\n'
        '    def a_func(self):\n        pass')
    self.assertEquals(1, len(scope.get_scopes()))
    c_scope = scope.get_scopes()[0]
    self.assertTrue('an_attr'in c_scope.get_names())
    self.assertTrue(c_scope.lookup('an_attr') is not None)
    f_in_c = c_scope.get_scopes()[0]
    self.assertTrue(f_in_c.lookup('an_attr') is None)

</t>
<t tx="ekr.20080516150804.2903">def test_inside_class_scope_attribute_lookup2(self):
    scope = self.pycore.get_string_scope(
        'class C(object):\n'
        '    def __init__(self):\n        self.an_attr = 1\n'
        '    def a_func(self):\n        pass')
    self.assertEquals(1, len(scope.get_scopes()))
    c_scope = scope.get_scopes()[0]
    f_in_c = c_scope.get_scopes()[0]
    self.assertTrue(f_in_c.lookup('an_attr') is None)

</t>
<t tx="ekr.20080516150804.2904">def test_get_inner_scope_for_staticmethods(self):
    scope = self.pycore.get_string_scope(
        'class C(object):\n'
        '    @staticmethod\n'
        '    def a_func(self):\n        pass\n')
    c_scope = scope.get_scopes()[0]
    f_in_c = c_scope.get_scopes()[0]
    self.assertEquals(f_in_c, scope.get_inner_scope_for_line(4))

</t>
<t tx="ekr.20080516150804.2905">def test_getting_overwritten_scopes(self):
    scope = self.pycore.get_string_scope(
        'def f():\n    pass\ndef f():\n    pass\n')
    self.assertEquals(2, len(scope.get_scopes()))
    f1_scope = scope.get_scopes()[0]
    f2_scope = scope.get_scopes()[1]
    self.assertNotEquals(f1_scope, f2_scope)

</t>
<t tx="ekr.20080516150804.2906">def test_assigning_builtin_names(self):
    mod = self.pycore.get_string_module('range = 1\n')
    range = mod.get_scope().lookup('range')
    self.assertEquals((mod, 1), range.get_definition_location())

</t>
<t tx="ekr.20080516150804.2907">def test_get_inner_scope_and_logical_lines(self):
    scope = self.pycore.get_string_scope(
        'class C(object):\n'
        '    def f():\n        s = """\n1\n2\n"""\n        a = 1\n')
    c_scope = scope.get_scopes()[0]
    f_in_c = c_scope.get_scopes()[0]
    self.assertEquals(f_in_c, scope.get_inner_scope_for_line(7))

</t>
<t tx="ekr.20080516150804.2908">def test_getting_defined_names_for_classes(self):
    scope = self.pycore.get_string_scope(
        'class A(object):\n    def a(self):\n        pass\n'
        'class B(A):\n    def b(self):\n        pass\n')
    a_scope = scope['A'].get_object().get_scope()
    b_scope = scope['B'].get_object().get_scope()
    self.assertTrue('a' in b_scope.get_names())
    self.assertTrue('b' in b_scope.get_names())
    self.assertTrue('a' not in b_scope.get_defined_names())
    self.assertTrue('b' in b_scope.get_defined_names())

</t>
<t tx="ekr.20080516150804.2909">def test_getting_defined_names_for_modules(self):
    scope = self.pycore.get_string_scope(
        'class A(object):\n    pass\n')
    self.assertTrue('open' in scope.get_names())
    self.assertTrue('A' in scope.get_names())
    self.assertTrue('open' not in scope.get_defined_names())
    self.assertTrue('A' in scope.get_defined_names())


</t>
<t tx="ekr.20080516150804.2910">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(PyCoreScopesTest))
    return result


</t>
<t tx="ekr.20080516150804.2911">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2912">import os
import unittest

from rope.base import exceptions
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2913">class PythonFileRunnerTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2914">
def setUp(self):
    super(PythonFileRunnerTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.2915">def tearDown(self):
    testutils.remove_project(self.project)
    super(PythonFileRunnerTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2916">def make_sample_python_file(self, file_path, get_text_function_source=None):
    self.project.root.create_file(file_path)
    file = self.project.get_resource(file_path)
    if not get_text_function_source:
        get_text_function_source = "def get_text():\n    return 'run'\n\n"
    file_content = get_text_function_source + \
                   "output = open('output.txt', 'w')\n" \
                   "output.write(get_text())\noutput.close()\n"
    file.write(file_content)

</t>
<t tx="ekr.20080516150804.2917">def get_output_file_content(self, file_path):
    try:
        output_path = ''
        last_slash = file_path.rfind('/')
        if last_slash != -1:
            output_path = file_path[0:last_slash + 1]
        file = self.project.get_resource(output_path + 'output.txt')
        return file.read()
    except exceptions.ResourceNotFoundError:
        return ''

</t>
<t tx="ekr.20080516150804.2918">def test_making_runner(self):
    file_path = 'sample.py'
    self.make_sample_python_file(file_path)
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource)
    runner.wait_process()
    self.assertEquals('run', self.get_output_file_content(file_path))

</t>
<t tx="ekr.20080516150804.2919">def test_passing_arguments(self):
    file_path = 'sample.py'
    function_source = 'import sys\ndef get_text():\n    return str(sys.argv[1:])\n'
    self.make_sample_python_file(file_path, function_source)
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource, args=['hello', 'world'])
    runner.wait_process()
    self.assertTrue(self.get_output_file_content(file_path).endswith("['hello', 'world']"))

</t>
<t tx="ekr.20080516150804.2920">def test_passing_arguments_with_spaces(self):
    file_path = 'sample.py'
    function_source = 'import sys\ndef get_text():\n    return str(sys.argv[1:])\n'
    self.make_sample_python_file(file_path, function_source)
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource, args=['hello world'])
    runner.wait_process()
    self.assertTrue(self.get_output_file_content(file_path).endswith("['hello world']"))

</t>
<t tx="ekr.20080516150804.2921">def test_killing_runner(self):
    file_path = 'sample.py'
    self.make_sample_python_file(file_path,
                                 "def get_text():" +
                                 "\n    import time\n    time.sleep(1)\n    return 'run'\n")
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource)
    runner.kill_process()
    self.assertEquals('', self.get_output_file_content(file_path))

</t>
<t tx="ekr.20080516150804.2922">def test_running_nested_files(self):
    self.project.root.create_folder('src')
    file_path = 'src/sample.py'
    self.make_sample_python_file(file_path)
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource)
    runner.wait_process()
    self.assertEquals('run', self.get_output_file_content(file_path))

</t>
<t tx="ekr.20080516150804.2923">def test_setting_process_input(self):
    file_path = 'sample.py'
    self.make_sample_python_file(file_path,
                                 "def get_text():" +
                                 "\n    import sys\n    return sys.stdin.readline()\n")
    temp_file_name = 'processtest.tmp'
    try:
        temp_file = open(temp_file_name, 'w')
        temp_file.write('input text\n')
        temp_file.close()
        file_resource = self.project.get_resource(file_path)
        stdin = open(temp_file_name)
        runner = self.pycore.run_module(file_resource, stdin=stdin)
        runner.wait_process()
        stdin.close()
        self.assertEquals('input text\n', self.get_output_file_content(file_path))
    finally:
        os.remove(temp_file_name)

</t>
<t tx="ekr.20080516150804.2924">def test_setting_process_output(self):
    file_path = 'sample.py'
    self.make_sample_python_file(file_path,
                                 "def get_text():" +
                                 "\n    print 'output text'\n    return 'run'\n")
    temp_file_name = 'processtest.tmp'
    try:
        file_resource = self.project.get_resource(file_path)
        stdout = open(temp_file_name, 'w')
        runner = self.pycore.run_module(file_resource, stdout=stdout)
        runner.wait_process()
        stdout.close()
        temp_file = open(temp_file_name, 'r')
        self.assertEquals('output text\n', temp_file.read())
        temp_file.close()
    finally:
        os.remove(temp_file_name)

</t>
<t tx="ekr.20080516150804.2925">def test_setting_pythonpath(self):
    src = self.project.root.create_folder('src')
    src.create_file('sample.py')
    src.get_child('sample.py').write('def f():\n    pass\n')
    self.project.root.create_folder('test')
    file_path = 'test/test.py'
    self.make_sample_python_file(file_path,
                                 "def get_text():\n"
                                 "    import sample\n    sample.f()\n    return'run'\n")
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource)
    runner.wait_process()
    self.assertEquals('run', self.get_output_file_content(file_path))

</t>
<t tx="ekr.20080516150804.2926">def test_making_runner_when_doi_is_disabled(self):
    self.project.set('enable_doi', False)
    file_path = 'sample.py'
    self.make_sample_python_file(file_path)
    file_resource = self.project.get_resource(file_path)
    runner = self.pycore.run_module(file_resource)
    runner.wait_process()
    self.assertEquals('run', self.get_output_file_content(file_path))


</t>
<t tx="ekr.20080516150804.2927">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(PythonFileRunnerTest))
    return result

</t>
<t tx="ekr.20080516150804.2928">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2929">import unittest

from rope.base import simplify


</t>
<t tx="ekr.20080516150804.2930">class SimplifyTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2931">
def setUp(self):
    super(SimplifyTest, self).setUp()

</t>
<t tx="ekr.20080516150804.2932">def tearDown(self):
    super(SimplifyTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2933">def test_trivial_case(self):
    self.assertEquals('', simplify.real_code(''))

</t>
<t tx="ekr.20080516150804.2934">def test_empty_strs(self):
    code = 's = ""\n'
    self.assertEquals(code, simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2935">def test_blanking_strs(self):
    code = 's = "..."\n'
    self.assertEquals('s = "   "\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2936">def test_changing_to_double_quotes(self):
    code = 's = \'\'\n'
    self.assertEquals('s = ""\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2937">def test_changing_to_double_quotes2(self):
    code = 's = """\n"""\n'
    self.assertEquals('s = "     "\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2938">def test_removing_comments(self):
    code = '# c\n'
    self.assertEquals('   \n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2939">def test_removing_comments_that_contain_strings(self):
    code = '# "c"\n'
    self.assertEquals('     \n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2940">def test_removing_strings_containing_comments(self):
    code = '"#c"\n'
    self.assertEquals('"  "\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2941">def test_joining_implicit_continuations(self):
    code = '(\n)\n'
    self.assertEquals('( )\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2942">def test_joining_explicit_continuations(self):
    code = '1 + \\\n 2\n'
    self.assertEquals('1 +    2\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2943">def test_replacing_tabs(self):
    code = '1\t+\t2\n'
    self.assertEquals('1 + 2\n', simplify.real_code(code))

</t>
<t tx="ekr.20080516150804.2944">def test_replacing_semicolons(self):
    code = 'a = 1;b = 2\n'
    self.assertEquals('a = 1\nb = 2\n', simplify.real_code(code))


</t>
<t tx="ekr.20080516150804.2945">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(SimplifyTest))
    return result

</t>
<t tx="ekr.20080516150804.2946">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080516150804.2947">import os.path
import shutil
import sys

import rope.base.project
from rope.contrib import generate


</t>
<t tx="ekr.20080516150804.2948">def sample_project(root=None, foldername=None, **kwds):
    if root is None:
        root = 'sample_project'
        if foldername:
            root = foldername
        # HACK: Using ``/dev/shm/`` for faster tests
        if os.name == 'posix' and os.path.isdir('/dev/shm'):
            root = '/dev/shm/' + root
    # Using these prefs for faster tests
    prefs = {'save_objectdb': False, 'save_history': False,
             'validate_objectdb': False, 'automatic_soa': False,
             'ignored_resources': ['.ropeproject', '*.pyc']}
    prefs.update(kwds)
    remove_recursively(root)
    project = rope.base.project.Project(root, **prefs)
    return project

</t>
<t tx="ekr.20080516150804.2949">create_module = generate.create_module
create_package = generate.create_package

def remove_project(project):
    project.close()
    remove_recursively(project.address)


</t>
<t tx="ekr.20080516150804.2950">def remove_recursively(path):
    import time
    if os.name == 'nt':
        for i in range(12):
            try:
                _remove_recursively(path)
            except WindowsError:
                time.sleep(0.3)
            else:
                break
    else:
        _remove_recursively(path)

</t>
<t tx="ekr.20080516150804.2951">def _remove_recursively(path):
    if not os.path.exists(path):
        return
    if os.path.isfile(path):
        os.remove(path)
    else:
        shutil.rmtree(path)


</t>
<t tx="ekr.20080516150804.2952">def run_only_for_25(func):
    """Should be used as a decorator for a unittest.TestCase test method"""
    if sys.version_info &gt;= (2, 5, 0):
        return func
    else:
        def do_nothing(self):
            pass
        return do_nothing


</t>
<t tx="ekr.20080516150804.2953">def only_for(version):
    """Should be used as a decorator for a unittest.TestCase test method"""
    def decorator(func):
        if sys.version &gt;= version:
            return func
        else:
            def do_nothing(self):
                pass
            return do_nothing
    return decorator


</t>
<t tx="ekr.20080516150804.2954">def run_only_for_unix(func):
    """Should be used as a decorator for a unittest.TestCase test method"""
    if os.name == 'posix':
        return func
    else:
        def do_nothing(self):
            pass
        return do_nothing


</t>
<t tx="ekr.20080516150804.2955">def assert_raises(exception_class):
    """Should be used as a decorator for a unittest.TestCase test method"""
    def _assert_raises(func):
        def call_func(self, *args, **kws):
            self.assertRaises(exception_class, func, self, *args, **kws)
        return call_func
    return _assert_raises
</t>
<t tx="ekr.20080516150804.2956">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite())
</t>
<t tx="ekr.20080516150804.2957">import unittest

import ropetest.projecttest
import ropetest.codeanalyzetest
import ropetest.pycoretest
import ropetest.pyscopestest
import ropetest.objectinfertest
import ropetest.objectdbtest
import ropetest.advanced_oi_test
import ropetest.runmodtest
import ropetest.builtinstest
import ropetest.historytest
import ropetest.simplifytest


</t>
<t tx="ekr.20080516150804.2958">def suite():
    result = unittest.TestSuite()
    result.addTests(ropetest.projecttest.suite())
    result.addTests(ropetest.codeanalyzetest.suite())
    result.addTests(ropetest.pycoretest.suite())
    result.addTests(ropetest.pyscopestest.suite())
    result.addTests(ropetest.objectinfertest.suite())
    result.addTests(ropetest.objectdbtest.suite())
    result.addTests(ropetest.advanced_oi_test.suite())
    result.addTests(ropetest.runmodtest.suite())
    result.addTests(ropetest.builtinstest.suite())
    result.addTests(ropetest.historytest.suite())
    result.addTests(ropetest.simplifytest.suite())
    return result


</t>
<t tx="ekr.20080516150804.2959"></t>
<t tx="ekr.20080516150804.2960">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2961">import unittest

from ropetest import testutils
from rope.contrib import autoimport


</t>
<t tx="ekr.20080516150804.2962">class AutoImportTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2963">
def setUp(self):
    super(AutoImportTest, self).setUp()
    self.project = testutils.sample_project()
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.pkg = testutils.create_package(self.project, 'pkg')
    self.mod2 = testutils.create_module(self.project, 'mod2', self.pkg)
    self.importer = autoimport.AutoImport(self.project, observe=False)

</t>
<t tx="ekr.20080516150804.2964">def tearDown(self):
    testutils.remove_project(self.project)
    super(AutoImportTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2965">def test_simple_case(self):
    self.assertEquals([], self.importer.import_assist('A'))

</t>
<t tx="ekr.20080516150804.2966">def test_update_resource(self):
    self.mod1.write('myvar = None\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals([('myvar', 'mod1')],
                      self.importer.import_assist('myva'))

</t>
<t tx="ekr.20080516150804.2967">def test_update_module(self):
    self.mod1.write('myvar = None')
    self.importer.update_module('mod1')
    self.assertEquals([('myvar', 'mod1')],
                      self.importer.import_assist('myva'))

</t>
<t tx="ekr.20080516150804.2968">def test_update_non_existent_module(self):
    self.importer.update_module('does_not_exists_this')
    self.assertEquals([], self.importer.import_assist('myva'))

</t>
<t tx="ekr.20080516150804.2969">def test_module_with_syntax_errors(self):
    self.mod1.write('this is a syntax error\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals([], self.importer.import_assist('myva'))

</t>
<t tx="ekr.20080516150804.2970">def test_excluding_imported_names(self):
    self.mod1.write('import pkg\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals([], self.importer.import_assist('pkg'))

</t>
<t tx="ekr.20080516150804.2971">def test_get_modules(self):
    self.mod1.write('myvar = None\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals(['mod1'], self.importer.get_modules('myvar'))

</t>
<t tx="ekr.20080516150804.2972">def test_get_modules_inside_packages(self):
    self.mod1.write('myvar = None\n')
    self.mod2.write('myvar = None\n')
    self.importer.update_resource(self.mod1)
    self.importer.update_resource(self.mod2)
    self.assertEquals(set(['mod1', 'pkg.mod2']),
                      set(self.importer.get_modules('myvar')))

</t>
<t tx="ekr.20080516150804.2973">def test_trivial_insertion_line(self):
    result = self.importer.find_insertion_line('')
    self.assertEquals(1, result)

</t>
<t tx="ekr.20080516150804.2974">def test_insertion_line(self):
    result = self.importer.find_insertion_line('import mod\n')
    self.assertEquals(2, result)

</t>
<t tx="ekr.20080516150804.2975">def test_insertion_line_with_pydocs(self):
    result = self.importer.find_insertion_line(
        '"""docs\n\ndocs"""\nimport mod\n')
    self.assertEquals(5, result)

</t>
<t tx="ekr.20080516150804.2976">def test_insertion_line_with_multiple_imports(self):
    result = self.importer.find_insertion_line(
        'import mod1\n\nimport mod2\n')
    self.assertEquals(4, result)

</t>
<t tx="ekr.20080516150804.2977">def test_insertion_line_with_blank_lines(self):
    result = self.importer.find_insertion_line(
        'import mod1\n\n# comment\n')
    self.assertEquals(2, result)

</t>
<t tx="ekr.20080516150804.2978">def test_empty_cache(self):
    self.mod1.write('myvar = None\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals(['mod1'], self.importer.get_modules('myvar'))
    self.importer.clear_cache()
    self.assertEquals([], self.importer.get_modules('myvar'))

</t>
<t tx="ekr.20080516150804.2979">def test_not_caching_underlined_names(self):
    self.mod1.write('_myvar = None\n')
    self.importer.update_resource(self.mod1, underlined=False)
    self.assertEquals([], self.importer.get_modules('_myvar'))
    self.importer.update_resource(self.mod1, underlined=True)
    self.assertEquals(['mod1'], self.importer.get_modules('_myvar'))

</t>
<t tx="ekr.20080516150804.2980">def test_caching_underlined_names_passing_to_the_constructor(self):
    importer = autoimport.AutoImport(self.project, False, True)
    self.mod1.write('_myvar = None\n')
    importer.update_resource(self.mod1)
    self.assertEquals(['mod1'], importer.get_modules('_myvar'))

</t>
<t tx="ekr.20080516150804.2981">def test_name_locations(self):
    self.mod1.write('myvar = None\n')
    self.importer.update_resource(self.mod1)
    self.assertEquals([(self.mod1, 1)],
                      self.importer.get_name_locations('myvar'))

</t>
<t tx="ekr.20080516150804.2982">def test_name_locations_with_multiple_occurrences(self):
    self.mod1.write('myvar = None\n')
    self.mod2.write('\nmyvar = None\n')
    self.importer.update_resource(self.mod1)
    self.importer.update_resource(self.mod2)
    self.assertEquals(set([(self.mod1, 1), (self.mod2, 2)]),
                      set(self.importer.get_name_locations('myvar')))


</t>
<t tx="ekr.20080516150804.2983">class AutoImportObservingTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2984">
def setUp(self):
    super(AutoImportObservingTest, self).setUp()
    self.project = testutils.sample_project()
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.pkg = testutils.create_package(self.project, 'pkg')
    self.mod2 = testutils.create_module(self.project, 'mod2', self.pkg)
    self.importer = autoimport.AutoImport(self.project, observe=True)

</t>
<t tx="ekr.20080516150804.2985">def tearDown(self):
    testutils.remove_project(self.project)
    super(AutoImportObservingTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2986">def test_writing_files(self):
    self.mod1.write('myvar = None\n')
    self.assertEquals(['mod1'], self.importer.get_modules('myvar'))

</t>
<t tx="ekr.20080516150804.2987">def test_moving_files(self):
    self.mod1.write('myvar = None\n')
    self.mod1.move('mod3.py')
    self.assertEquals(['mod3'], self.importer.get_modules('myvar'))

</t>
<t tx="ekr.20080516150804.2988">def test_removing_files(self):
    self.mod1.write('myvar = None\n')
    self.mod1.remove()
    self.assertEquals([], self.importer.get_modules('myvar'))


</t>
<t tx="ekr.20080516150804.2989">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(AutoImportTest))
    result.addTests(unittest.makeSuite(AutoImportObservingTest))
    return result

</t>
<t tx="ekr.20080516150804.2990">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.2991">import unittest

from rope.base import exceptions
from rope.contrib.codeassist import (get_definition_location, get_doc,
                                     starting_expression, code_assist,
                                     sorted_proposals, starting_offset,
                                     get_calltip)
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.2992">class CodeAssistTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.2993">
def setUp(self):
    super(CodeAssistTest, self).setUp()
    self.project = testutils.sample_project()

</t>
<t tx="ekr.20080516150804.2994">def tearDown(self):
    testutils.remove_project(self.project)
    super(CodeAssistTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.2995">def _assist(self, code, offset=None, **args):
    if offset is None:
        offset = len(code)
    return code_assist(self.project, code, offset,  **args)

</t>
<t tx="ekr.20080516150804.2996">def test_simple_assist(self):
    self._assist('', 0)

</t>
<t tx="ekr.20080516150804.2997">def assert_completion_in_result(self, name, kind, result):
    for proposal in result:
        if proposal.name == name and proposal.kind == kind:
            return
    self.fail('completion &lt;%s&gt; not proposed' % name)

</t>
<t tx="ekr.20080516150804.2998">def assert_completion_not_in_result(self, name, kind, result):
    for proposal in result:
        if proposal.name == name and proposal.kind == kind:
            self.fail('completion &lt;%s&gt; was proposed' % name)

</t>
<t tx="ekr.20080516150804.2999">def test_completing_global_variables(self):
    code = 'my_global = 10\nt = my'
    result = self._assist(code)
    self.assert_completion_in_result('my_global', 'global', result)

</t>
<t tx="ekr.20080516150804.3000">def test_not_proposing_unmatched_vars(self):
    code = 'my_global = 10\nt = you'
    result = self._assist(code)
    self.assert_completion_not_in_result('my_global', 'global', result)

</t>
<t tx="ekr.20080516150804.3001">def test_not_proposing_unmatched_vars_with_underlined_starting(self):
    code = 'my_global = 10\nt = your_'
    result = self._assist(code)
    self.assert_completion_not_in_result('my_global', 'global', result)

</t>
<t tx="ekr.20080516150804.3002">def test_not_proposing_local_assigns_as_global_completions(self):
    code = 'def f():    my_global = 10\nt = my_'
    result = self._assist(code)
    self.assert_completion_not_in_result('my_global', 'global', result)

</t>
<t tx="ekr.20080516150804.3003">def test_proposing_functions(self):
    code = 'def my_func():    return 2\nt = my_'
    result = self._assist(code)
    self.assert_completion_in_result('my_func', 'global', result)

</t>
<t tx="ekr.20080516150804.3004">def test_proposing_classes(self):
    code = 'class Sample(object):    pass\nt = Sam'
    result = self._assist(code)
    self.assert_completion_in_result('Sample', 'global', result)

</t>
<t tx="ekr.20080516150804.3005">def test_proposing_each_name_at_most_once(self):
    code = 'variable = 10\nvariable = 20\nt = vari'
    result = self._assist(code)
    count = len([x for x in result
                 if x.name == 'variable' and x.kind == 'global'])
    self.assertEquals(1, count)

</t>
<t tx="ekr.20080516150804.3006">@testutils.assert_raises(exceptions.ModuleSyntaxError)
def test_throwing_exception_in_case_of_syntax_errors(self):
    code = 'sample (sdf+)\n'
    self._assist(code, maxfixes=0)

</t>
<t tx="ekr.20080516150804.3007">def test_fixing_errors_with_maxfixes(self):
    code = 'def f():\n    sldj sldj\ndef g():\n    ran'
    result = self._assist(code, maxfixes=2)
    self.assertTrue(len(result) &gt; 0)

</t>
<t tx="ekr.20080516150804.3008">def test_ignoring_errors_in_current_line(self):
    code = 'def my_func():\n    return 2\nt = '
    result = self._assist(code)
    self.assert_completion_in_result('my_func', 'global', result)

</t>
<t tx="ekr.20080516150804.3009">def test_not_reporting_variables_in_current_line(self):
    code = 'def my_func():    return 2\nt = my_'
    result = self._assist(code)
    self.assert_completion_not_in_result('my_', 'global', result)

</t>
<t tx="ekr.20080516150804.3010">def test_completion_result(self):
    code = 'my_global = 10\nt = my'
    self.assertEquals(len(code) - 2, starting_offset(code, len(code)))

</t>
<t tx="ekr.20080516150804.3011">def test_completing_imported_names(self):
    code = 'import sys\na = sy'
    result = self._assist(code)
    self.assert_completion_in_result('sys', 'global', result)

</t>
<t tx="ekr.20080516150804.3012">def test_completing_imported_names_with_as(self):
    code = 'import sys as mysys\na = mys'
    result = self._assist(code)
    self.assert_completion_in_result('mysys', 'global', result)

</t>
<t tx="ekr.20080516150804.3013">def test_not_completing_imported_names_with_as(self):
    code = 'import sys as mysys\na = sy'
    result = self._assist(code)
    self.assert_completion_not_in_result('sys', 'global', result)

</t>
<t tx="ekr.20080516150804.3014">def test_including_matching_builtins_types(self):
    code = 'my_var = Excep'
    result = self._assist(code)
    self.assert_completion_in_result('Exception', 'global', result)
    self.assert_completion_not_in_result('zip', 'global', result)

</t>
<t tx="ekr.20080516150804.3015">def test_including_matching_builtins_functions(self):
    code = 'my_var = zi'
    result = self._assist(code)
    self.assert_completion_in_result('zip', 'global', result)

</t>
<t tx="ekr.20080516150804.3016">def test_including_keywords(self):
    code = 'fo'
    result = self._assist(code)
    self.assert_completion_in_result('for', 'keyword', result)

</t>
<t tx="ekr.20080516150804.3017">def test_not_reporting_proposals_after_dot(self):
    code = 'a_dict = {}\nkey = 3\na_dict.ke'
    result = self._assist(code)
    self.assert_completion_not_in_result('key', 'global', result)

</t>
<t tx="ekr.20080516150804.3018">def test_proposing_local_variables_in_functions(self):
    code = 'def f(self):\n    my_var = 10\n    my_'
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3019">def test_local_variables_override_global_ones(self):
    code = 'my_var = 20\ndef f(self):\n    my_var = 10\n    my_'
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3020">def test_not_including_class_body_variables(self):
    code = 'class C(object):\n    my_var = 20\n' \
           '    def f(self):\n        a = 20\n        my_'
    result = self._assist(code)
    self.assert_completion_not_in_result('my_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3021">def test_nested_functions(self):
    code = 'def my_func():\n    func_var = 20\n    ' \
           'def inner_func():\n        a = 20\n        func'
    result = self._assist(code)
    self.assert_completion_in_result('func_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3022">def test_scope_endpoint_selection(self):
    code = "def my_func():\n    func_var = 20\n"
    result = self._assist(code)
    self.assert_completion_not_in_result('func_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3023">def test_scope_better_endpoint_selection(self):
    code = "if True:\n    def f():\n        my_var = 10\n    my_"
    result = self._assist(code)
    self.assert_completion_not_in_result('my_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3024">def test_imports_inside_function(self):
    code = "def f():\n    import sys\n    sy"
    result = self._assist(code)
    self.assert_completion_in_result('sys', 'local', result)

</t>
<t tx="ekr.20080516150804.3025">def test_imports_inside_function_dont_mix_with_globals(self):
    code = "def f():\n    import sys\nsy"
    result = self._assist(code)
    self.assert_completion_not_in_result('sys', 'local', result)

</t>
<t tx="ekr.20080516150804.3026">def test_nested_classes_local_names(self):
    code = "global_var = 10\ndef my_func():\n    func_var = 20\n    class C(object):\n" + \
           "        def another_func(self):\n            local_var = 10\n            func"
    result = self._assist(code)
    self.assert_completion_in_result('func_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3027">def test_nested_classes_global(self):
    code = "global_var = 10\ndef my_func():\n    func_var = 20\n    class C(object):\n" + \
           "        def another_func(self):\n            local_var = 10\n            globa"
    result = self._assist(code)
    self.assert_completion_in_result('global_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3028">def test_nested_classes_global_function(self):
    code = "global_var = 10\ndef my_func():\n    func_var = 20\n    class C(object):\n" + \
           "        def another_func(self):\n            local_var = 10\n            my_f"
    result = self._assist(code)
    self.assert_completion_in_result('my_func', 'global', result)

</t>
<t tx="ekr.20080516150804.3029">def test_proposing_function_parameters_in_functions(self):
    code = "def my_func(my_param):\n    my_var = 20\n    my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_param', 'local', result)

</t>
<t tx="ekr.20080516150804.3030">def test_proposing_function_keyword_parameters_in_functions(self):
    code = "def my_func(my_param, *my_list, **my_kws):\n    my_var = 20\n    my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_param', 'local', result)
    self.assert_completion_in_result('my_list', 'local', result)
    self.assert_completion_in_result('my_kws', 'local', result)

</t>
<t tx="ekr.20080516150804.3031">def test_not_proposing_unmatching_function_parameters_in_functions(self):
    code = "def my_func(my_param):\n    my_var = 20\n    you_"
    result = self._assist(code)
    self.assert_completion_not_in_result('my_param', 'local', result)

</t>
<t tx="ekr.20080516150804.3032">def test_ignoring_current_statement(self):
    code = "my_var = 10\nmy_tuple = (10, \n           my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3033">def test_ignoring_current_statement_brackets_continuation(self):
    code = "my_var = 10\n'hello'[10:\n        my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3034">def test_ignoring_current_statement_explicit_continuation(self):
    code = "my_var = 10\nmy_var2 = 2 + \\\n          my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3035">def test_ignoring_current_statement_while_the_first_statement_of_the_block(self):
    code = "my_var = 10\ndef f():\n    my_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3036">def test_ignoring_current_statement_while_current_line_ends_with_a_colon(self):
    code = "my_var = 10\nif my_:\n    pass"
    result = self._assist(code, 18)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3037">def test_ignoring_string_contents(self):
    code = "my_var = '('\nmy_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3038">def test_ignoring_comment_contents(self):
    code = "my_var = 10 #(\nmy_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3039">def test_ignoring_string_contents_backslash_plus_quotes(self):
    code = "my_var = '\\''\nmy_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3040">def test_ignoring_string_contents_backslash_plus_backslash(self):
    code = "my_var = '\\\\'\nmy_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3041">def test_not_proposing_later_defined_variables_in_current_block(self):
    code = "my_\nmy_var = 10\n"
    result = self._assist(code, 3, later_locals=False)
    self.assert_completion_not_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3042">def test_not_proposing_later_defined_variables_in_current_function(self):
    code = "def f():\n    my_\n    my_var = 10\n"
    result = self._assist(code, 16, later_locals=False)
    self.assert_completion_not_in_result('my_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3043">def test_ignoring_string_contents_with_triple_quotes(self):
    code = "my_var = '''(\n'('''\nmy_"
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3044">def test_ignoring_string_contents_with_triple_quotes_and_backslash(self):
    code = 'my_var = """\\"""("""\nmy_'
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3045">def test_ignoring_string_contents_with_triple_quotes_and_double_backslash(self):
    code = 'my_var = """\\\\"""\nmy_'
    result = self._assist(code)
    self.assert_completion_in_result('my_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3046">def test_reporting_params_when_in_the_first_line_of_a_function(self):
    code = 'def f(param):\n    para'
    result = self._assist(code)
    self.assert_completion_in_result('param', 'local', result)

</t>
<t tx="ekr.20080516150804.3047">def test_code_assist_when_having_a_two_line_function_header(self):
    code = 'def f(param1,\n      param2):\n    para'
    result = self._assist(code)
    self.assert_completion_in_result('param1', 'local', result)

</t>
<t tx="ekr.20080516150804.3048">def test_code_assist_with_function_with_two_line_return(self):
    code = 'def f(param1, param2):\n    return(param1,\n           para'
    result = self._assist(code)
    self.assert_completion_in_result('param2', 'local', result)

</t>
<t tx="ekr.20080516150804.3049">def test_get_definition_location(self):
    code = 'def a_func():\n    pass\na_func()'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((None, 1), result)

</t>
<t tx="ekr.20080516150804.3050">def test_get_definition_location_underlined_names(self):
    code = 'def a_sample_func():\n    pass\na_sample_func()'
    result = get_definition_location(self.project, code, len(code) - 11)
    self.assertEquals((None, 1), result)

</t>
<t tx="ekr.20080516150804.3051">def test_get_definition_location_dotted_names(self):
    code = 'class AClass(object):\n    ' + \
           '@staticmethod\n    def a_method():\n        pass\nAClass.a_method()'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((None, 2), result)

</t>
<t tx="ekr.20080516150804.3052">def test_get_definition_location_dotted_module_names(self):
    module_resource = testutils.create_module(self.project, 'mod')
    module_resource.write('def a_func():\n    pass\n')
    code = 'import mod\nmod.a_func()'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((module_resource, 1), result)

</t>
<t tx="ekr.20080516150804.3053">def test_get_definition_location_for_nested_packages(self):
    pycore = self.project.get_pycore()
    mod1 = testutils.create_module(self.project, 'mod1')
    pkg1 = testutils.create_package(self.project, 'pkg1')
    pkg2 = testutils.create_package(self.project, 'pkg2', pkg1)
    mod2 = testutils.create_module(self.project, 'mod2', pkg2)
    mod1.write('import pkg1.pkg2.mod2')

    mod1_scope = pycore.resource_to_pyobject(mod1).get_scope()
    init_dot_py = pkg2.get_child('__init__.py')
    found_pyname = get_definition_location(self.project, mod1.read(),
                                           mod1.read().index('pkg2') + 1)
    self.assertEquals(init_dot_py, found_pyname[0])

</t>
<t tx="ekr.20080516150804.3054">def test_get_definition_location_unknown(self):
    code = 'a_func()\n'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((None, None), result)

</t>
<t tx="ekr.20080516150804.3055">def test_get_definition_location_dot_spaces(self):
    code = 'class AClass(object):\n    ' \
           '@staticmethod\n    def a_method():\n' \
           '        pass\nAClass.\\\n     a_method()'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((None, 2), result)

</t>
<t tx="ekr.20080516150804.3056">def test_get_definition_location_dot_line_break_inside_parens(self):
    code = 'class A(object):\n    def a_method(self):\n        pass\n' + \
           '(A.\na_method)'
    result = get_definition_location(self.project, code,
                                     code.rindex('a_method') + 1)
    self.assertEquals((None, 2), result)

</t>
<t tx="ekr.20080516150804.3057">def test_if_scopes_in_other_scopes_for_get_definition_location(self):
    code = 'def f(a_var):\n    pass\na_var = 10\nif True:\n    print a_var\n'
    result = get_definition_location(self.project, code, len(code) - 3)
    self.assertEquals((None, 3), result)

</t>
<t tx="ekr.20080516150804.3058">def test_code_assists_in_parens(self):
    code = 'def a_func(a_var):\n    pass\na_var = 10\na_func(a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3059">def test_simple_type_inferencing(self):
    code = 'class Sample(object):\n    def __init__(self, a_param):\n        pass\n' + \
           '    def a_method(self):\n        pass\n' + \
           'Sample("hey").a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_method', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3060">def test_proposals_sorter(self):
    code = 'def my_sample_function(self):\n' + \
           '    my_sample_var = 20\n' + \
           '    my_sample_'
    proposals = sorted_proposals(self._assist(code))
    self.assertEquals('my_sample_var', proposals[0].name)
    self.assertEquals('my_sample_function', proposals[1].name)

</t>
<t tx="ekr.20080516150804.3061">def test_proposals_sorter_for_methods_and_attributes(self):
    code = 'class A(object):\n' + \
           '    def __init__(self):\n' + \
           '        self.my_a_var = 10\n' + \
           '    def my_b_func(self):\n' + \
           '        pass\n' + \
           '    def my_c_func(self):\n' + \
           '        pass\n' + \
           'a_var = A()\n' + \
           'a_var.my_'
    proposals = sorted_proposals(self._assist(code))
    self.assertEquals('my_b_func', proposals[0].name)
    self.assertEquals('my_c_func', proposals[1].name)
    self.assertEquals('my_a_var', proposals[2].name)

</t>
<t tx="ekr.20080516150804.3062">def test_proposals_sorter_for_global_methods_and_funcs(self):
    code = 'def my_b_func(self):\n' + \
           '    pass\n' + \
           'my_a_var = 10\n' + \
           'my_'
    proposals = sorted_proposals(self._assist(code))
    self.assertEquals('my_b_func', proposals[0].name)
    self.assertEquals('my_a_var', proposals[1].name)

</t>
<t tx="ekr.20080516150804.3063">def test_proposals_sorter_underlined_methods(self):
    code = 'class A(object):\n' + \
           '    def _my_func(self):\n' + \
           '        self.my_a_var = 10\n' + \
           '    def my_func(self):\n' + \
           '        pass\n' + \
           'a_var = A()\n' + \
           'a_var.'
    proposals = sorted_proposals(self._assist(code))
    self.assertEquals('my_func', proposals[0].name)
    self.assertEquals('_my_func', proposals[1].name)

</t>
<t tx="ekr.20080516150804.3064">def test_proposals_sorter_and_kind_prefs(self):
    code = 'my_global_var = 1\n' \
           'def func(self):\n' \
           '    my_local_var = 2\n' \
           '    my_'
    result = self._assist(code)
    proposals = sorted_proposals(result, kindpref=['global', 'local'])
    self.assertEquals('my_global_var', proposals[0].name)
    self.assertEquals('my_local_var', proposals[1].name)

</t>
<t tx="ekr.20080516150804.3065">def test_proposals_sorter_and_type_prefs(self):
    code = 'my_global_var = 1\n' \
           'def my_global_func(self):\n' \
           '    pass\n' \
           'my_'
    result = self._assist(code)
    proposals = sorted_proposals(result, typepref=['variable', 'function'])
    self.assertEquals('my_global_var', proposals[0].name)
    self.assertEquals('my_global_func', proposals[1].name)

</t>
<t tx="ekr.20080516150804.3066">def test_proposals_sorter_and_missing_type_in_typepref(self):
    code = 'my_global_var = 1\n' \
           'def my_global_func():\n    pass\n' \
           'my_'
    result = self._assist(code)
    proposals = sorted_proposals(result, typepref=['function'])

</t>
<t tx="ekr.20080516150804.3067">def test_get_pydoc_for_functions(self):
    src = 'def a_func():\n    """a function"""\n' \
          '    a_var = 10\na_func()'
    self.assertTrue(get_doc(self.project, src, len(src) - 4).
                    endswith('a function'))
    get_doc(self.project, src, len(src) - 4).index('a_func()')

</t>
<t tx="ekr.20080516150804.3068">def test_get_pydoc_for_classes(self):
    src = 'class AClass(object):\n    pass\n'
    get_doc(self.project, src, src.index('AClass') + 1).index('AClass')

</t>
<t tx="ekr.20080516150804.3069">def test_get_pydoc_for_classes_with_init(self):
    src = 'class AClass(object):\n    def __init__(self):\n        pass\n'
    get_doc(self.project, src, src.index('AClass') + 1).index('AClass')

</t>
<t tx="ekr.20080516150804.3070">def test_get_pydoc_for_modules(self):
    pycore = self.project.get_pycore()
    mod = testutils.create_module(self.project, 'mod')
    mod.write('"""a module"""\n')
    src = 'import mod\nmod'
    self.assertEquals('a module', get_doc(self.project, src, len(src) - 1))

</t>
<t tx="ekr.20080516150804.3071">def test_get_pydoc_for_builtins(self):
    src = 'print(object)\n'
    self.assertTrue(get_doc(self.project, src,
                            src.index('obj')) is not None)

</t>
<t tx="ekr.20080516150804.3072">def test_get_pydoc_for_methods_should_include_class_name(self):
    src = 'class AClass(object):\n    def a_method(self):\n'\
          '        """hey"""\n        pass\n'
    doc = get_doc(self.project, src, src.index('a_method') + 1)
    doc.index('AClass.a_method')
    doc.index('hey')

</t>
<t tx="ekr.20080516150804.3073">def test_get_pydoc_for_methods_should_include_methods_from_super_classes(self):
    src = 'class A(object):\n    def a_method(self):\n' \
          '        """hey1"""\n        pass\n' \
          'class B(A):\n    def a_method(self):\n' \
          '        """hey2"""\n        pass\n'
    doc = get_doc(self.project, src, src.rindex('a_method') + 1)
    doc.index('A.a_method')
    doc.index('hey1')
    doc.index('B.a_method')
    doc.index('hey2')

</t>
<t tx="ekr.20080516150804.3074">def test_get_pydoc_for_classes_should_name_super_classes(self):
    src = 'class A(object):\n    pass\n' \
          'class B(A):\n    pass\n'
    doc = get_doc(self.project, src, src.rindex('B') + 1)
    doc.index('B(A)')

</t>
<t tx="ekr.20080516150804.3075">def test_get_pydoc_for_builtin_functions(self):
    src = 's = "hey"\ns.replace\n'
    doc = get_doc(self.project, src, src.rindex('replace') + 1)
    self.assertTrue(doc is not None)

</t>
<t tx="ekr.20080516150804.3076">def test_commenting_errors_before_offset(self):
    src = 'lsjd lsjdf\ns = "hey"\ns.replace()\n'
    doc = get_doc(self.project, src, src.rindex('replace') + 1)

</t>
<t tx="ekr.20080516150804.3077">def test_proposing_variables_defined_till_the_end_of_scope(self):
    code = 'if True:\n    a_v\na_var = 10\n'
    result = self._assist(code, code.index('a_v') + 3)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3078">def test_completing_in_uncomplete_try_blocks(self):
    code = 'try:\n    a_var = 10\n    a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3079">def test_completing_in_uncomplete_try_blocks_in_functions(self):
    code = 'def a_func():\n    try:\n        a_var = 10\n        a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3080">def test_already_complete_try_blocks_with_finally(self):
    code = 'def a_func():\n    try:\n        a_var = 10\n        a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'local', result)

</t>
<t tx="ekr.20080516150804.3081">def test_already_complete_try_blocks_with_finally2(self):
    code = 'try:\n    a_var = 10\n    a_\nfinally:\n    pass\n'
    result = self._assist(code, code.rindex('a_') + 2)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3082">def test_already_complete_try_blocks_with_except(self):
    code = 'try:\n    a_var = 10\n    a_\nexcept Exception:\n    pass\n'
    result = self._assist(code, code.rindex('a_') + 2)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3083">def test_already_complete_try_blocks_with_except2(self):
    code = 'a_var = 10\ntry:\n    another_var = a_\n    another_var = 10\n' \
           'except Exception:\n    pass\n'
    result = self._assist(code, code.rindex('a_') + 2)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3084">def test_completing_ifs_in_uncomplete_try_blocks(self):
    code = 'try:\n    if True:\n        a_var = 10\n    a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3085">def test_completing_ifs_in_uncomplete_try_blocks2(self):
    code = 'try:\n    if True:\n        a_var = 10\n        a_'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3086">def test_completing_excepts_in_uncomplete_try_blocks(self):
    code = 'try:\n    pass\nexcept Exc'
    result = self._assist(code)
    self.assert_completion_in_result('Exception', 'global', result)

</t>
<t tx="ekr.20080516150804.3087">def test_and_normal_complete_blocks_and_single_fixing(self):
    code = 'try:\n    range.\nexcept:\n    pass\n'
    result = self._assist(code, code.index('.'), maxfixes=1)

</t>
<t tx="ekr.20080516150804.3088">def test_nested_blocks(self):
    code = 'a_var = 10\ntry:\n    try:\n        a_v'
    result = self._assist(code)
    self.assert_completion_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3089">def test_proposing_function_keywords_when_calling(self):
    code = 'def f(p):\n    pass\nf(p'
    result = self._assist(code)
    self.assert_completion_in_result('p=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3090">def test_proposing_function_keywords_when_calling_for_non_functions(self):
    code = 'f = 1\nf(p'
    result = self._assist(code)

</t>
<t tx="ekr.20080516150804.3091">def test_proposing_function_keywords_when_calling_extra_spaces(self):
    code = 'def f(p):\n    pass\nf( p'
    result = self._assist(code)
    self.assert_completion_in_result('p=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3092">def test_proposing_function_keywords_when_calling_on_second_argument(self):
    code = 'def f(p1, p2):\n    pass\nf(1, p'
    result = self._assist(code)
    self.assert_completion_in_result('p2=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3093">def test_proposing_function_keywords_when_calling_not_proposing_args(self):
    code = 'def f(p1, *args):\n    pass\nf(1, a'
    result = self._assist(code)
    self.assert_completion_not_in_result('args=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3094">def test_proposing_function_keywords_when_calling_with_no_nothing_after_parens(self):
    code = 'def f(p):\n    pass\nf('
    result = self._assist(code)
    self.assert_completion_in_result('p=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3095">def test_proposing_function_keywords_when_calling_with_no_nothing_after_parens2(self):
    code = 'def f(p):\n    pass\ndef g():\n    h = f\n    f('
    result = self._assist(code)
    self.assert_completion_in_result('p=', 'parameter_keyword', result)

</t>
<t tx="ekr.20080516150804.3096">def test_codeassists_before_opening_of_parens(self):
    code = 'def f(p):\n    pass\na_var = 1\nf(1)\n'
    result = self._assist(code, code.rindex('f') + 1)
    self.assert_completion_not_in_result('a_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3097">def test_codeassist_before_single_line_indents(self):
    code = 'myvar = 1\nif True:\n    (myv\nif True:\n    pass\n'
    result = self._assist(code, code.rindex('myv') + 3)
    self.assert_completion_not_in_result('myvar', 'local', result)

</t>
<t tx="ekr.20080516150804.3098">def test_codeassist_before_line_indents_in_a_blank_line(self):
    code = 'myvar = 1\nif True:\n    \nif True:\n    pass\n'
    result = self._assist(code, code.rindex('    ') + 4)
    self.assert_completion_not_in_result('myvar', 'local', result)

</t>
<t tx="ekr.20080516150804.3099">def test_simple_get_calltips(self):
    src = 'def f():\n    pass\nvar = f()\n'
    doc = get_calltip(self.project, src, src.rindex('f'))
    self.assertEquals('f()', doc)

</t>
<t tx="ekr.20080516150804.3100">def test_get_calltips_for_classes(self):
    src = 'class C(object):\n' \
          '    def __init__(self):\n        pass\nC('
    doc = get_calltip(self.project, src, len(src) - 1)
    self.assertEquals('C.__init__(self)', doc)

</t>
<t tx="ekr.20080516150804.3101">def test_get_calltips_for_objects_with_call(self):
    src = 'class C(object):\n' \
          '    def __call__(self, p):\n        pass\n' \
          'c = C()\nc(1,'
    doc = get_calltip(self.project, src, src.rindex('c'))
    self.assertEquals('C.__call__(self, p)', doc)

</t>
<t tx="ekr.20080516150804.3102">def test_get_calltips_and_including_module_name(self):
    src = 'class C(object):\n' \
          '    def __call__(self, p):\n        pass\n' \
          'c = C()\nc(1,'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(src)
    doc = get_calltip(self.project, src, src.rindex('c'), mod)
    self.assertEquals('mod.C.__call__(self, p)', doc)

</t>
<t tx="ekr.20080516150804.3103">def test_get_calltips_and_including_module_name(self):
    src = 'range()\n'
    doc = get_calltip(self.project, src, 1, ignore_unknown=True)
    self.assertTrue(doc is None)


</t>
<t tx="ekr.20080516150804.3104">class CodeAssistInProjectsTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3105">
def setUp(self):
    super(CodeAssistInProjectsTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    samplemod = testutils.create_module(self.project, 'samplemod')
    code = 'class SampleClass(object):\n' \
           '    def sample_method():\n        pass\n\n' \
           'def sample_func():\n    pass\n' \
           'sample_var = 10\n\n' \
           'def _underlined_func():\n    pass\n\n'
    samplemod.write(code)
    package = testutils.create_package(self.project, 'package')
    nestedmod = testutils.create_module(self.project, 'nestedmod', package)

</t>
<t tx="ekr.20080516150804.3106">def tearDown(self):
    testutils.remove_project(self.project)
    super(self.__class__, self).tearDown()

</t>
<t tx="ekr.20080516150804.3107">def _assist(self, code, resource=None, **kwds):
    return code_assist(self.project, code, len(code), resource, **kwds)

</t>
<t tx="ekr.20080516150804.3108">def assert_completion_in_result(self, name, kind, result):
    for proposal in result:
        if proposal.name == name and proposal.kind == kind:
            return
    self.fail('completion &lt;%s&gt; not proposed' % name)

</t>
<t tx="ekr.20080516150804.3109">def assert_completion_not_in_result(self, name, kind, result):
    for proposal in result:
        if proposal.name == name and proposal.kind == kind:
            self.fail('completion &lt;%s&gt; was proposed' % name)

</t>
<t tx="ekr.20080516150804.3110">def test_simple_import(self):
    code = 'import samplemod\nsample'
    result = self._assist(code)
    self.assert_completion_in_result('samplemod', 'global', result)

</t>
<t tx="ekr.20080516150804.3111">def test_from_import_class(self):
    code = 'from samplemod import SampleClass\nSample'
    result = self._assist(code)
    self.assert_completion_in_result('SampleClass', 'global', result)

</t>
<t tx="ekr.20080516150804.3112">def test_from_import_function(self):
    code = 'from samplemod import sample_func\nsample'
    result = self._assist(code)
    self.assert_completion_in_result('sample_func', 'global', result)

</t>
<t tx="ekr.20080516150804.3113">def test_from_import_variable(self):
    code = 'from samplemod import sample_var\nsample'
    result = self._assist(code)
    self.assert_completion_in_result('sample_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3114">def test_from_imports_inside_functions(self):
    code = 'def f():\n    from samplemod import SampleClass\n    Sample'
    result = self._assist(code)
    self.assert_completion_in_result('SampleClass', 'local', result)

</t>
<t tx="ekr.20080516150804.3115">def test_from_import_only_imports_imported(self):
    code = 'from samplemod import sample_func\nSample'
    result = self._assist(code)
    self.assert_completion_not_in_result('SampleClass', 'global', result)

</t>
<t tx="ekr.20080516150804.3116">def test_from_import_star(self):
    code = 'from samplemod import *\nSample'
    result = self._assist(code)
    self.assert_completion_in_result('SampleClass', 'global', result)

</t>
<t tx="ekr.20080516150804.3117">def test_from_import_star2(self):
    code = 'from samplemod import *\nsample'
    result = self._assist(code)
    self.assert_completion_in_result('sample_func', 'global', result)
    self.assert_completion_in_result('sample_var', 'global', result)

</t>
<t tx="ekr.20080516150804.3118">def test_from_import_star_not_imporing_underlined(self):
    code = 'from samplemod import *\n_under'
    result = self._assist(code)
    self.assert_completion_not_in_result('_underlined_func', 'global', result)

</t>
<t tx="ekr.20080516150804.3119">def test_from_package_import_mod(self):
    code = 'from package import nestedmod\nnest'
    result = self._assist(code)
    self.assert_completion_in_result('nestedmod', 'global', result)

</t>
<t tx="ekr.20080516150804.3120">def test_completing_after_dot(self):
    code = 'class SampleClass(object):\n    def sample_method(self):\n' \
           '        pass\nSampleClass.sam'
    result = self._assist(code)
    self.assert_completion_in_result('sample_method', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3121">def test_completing_after_multiple_dots(self):
    code = 'class Class1(object):\n    class Class2(object):\n' \
           '        def sample_method(self):\n' \
           '            pass\nClass1.Class2.sam'
    result = self._assist(code)
    self.assert_completion_in_result('sample_method', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3122">def test_completing_after_self_dot(self):
    code = 'class Sample(object):\n    def method1(self):\n        pass\n' \
           '    def method2(self):\n        self.m'
    result = self._assist(code)
    self.assert_completion_in_result('method1', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3123">def test_result_start_offset_for_dotted_completions(self):
    code = 'class Sample(object):\n    def method1(self):\n        pass\n' \
           'Sample.me'
    self.assertEquals(len(code) - 2, starting_offset(code, len(code)))

</t>
<t tx="ekr.20080516150804.3124">def test_backslash_after_dots(self):
    code = 'class Sample(object):\n    def a_method(self):\n        pass\n' \
           'Sample.\\\n       a_m'
    result = self._assist(code)
    self.assert_completion_in_result('a_method', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3125">def test_not_proposing_global_names_after_dot(self):
    code = 'class Sample(object):\n    def a_method(self):\n        pass\n' \
           'Sample.'
    result = self._assist(code)
    self.assert_completion_not_in_result('Sample', 'global', result)

</t>
<t tx="ekr.20080516150804.3126">def test_assist_on_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod1.write('def a_func():\n    pass\n')
    code = 'import mod1\nmod1.'
    result = self._assist(code, resource=mod2)
    self.assert_completion_in_result('a_func', 'attribute', result)

</t>
<t tx="ekr.20080516150804.3127">def test_get_location_on_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod1.write('def a_func():\n    pass\n')
    code = 'import mod1\nmod1.a_func\n'
    result = get_definition_location(self.project, code,
                                     len(code) - 2, mod2)
    self.assertEquals((mod1, 1), result)

</t>
<t tx="ekr.20080516150804.3128">def test_get_definition_location_for_builtins(self):
    code = 'import sys\n'
    result = get_definition_location(self.project, code,
                                     len(code) - 2)
    self.assertEquals((None, None), result)

</t>
<t tx="ekr.20080516150804.3129">def test_get_doc_on_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod1.write('def a_func():\n    """hey"""\n    pass\n')
    code = 'import mod1\nmod1.a_func\n'
    result = get_doc(self.project, code, len(code) - 2, mod2)
    self.assertTrue(result.endswith('hey'))

</t>
<t tx="ekr.20080516150804.3130">def test_get_doc_on_from_import_module(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('"""mod1 docs"""\nvar = 1\n')
    code = 'from mod1 import var\n'
    result = get_doc(self.project, code, code.index('mod1'))
    result.index('mod1 docs')

</t>
<t tx="ekr.20080516150804.3131">def test_fixing_errors_with_maxfixes_in_resources(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'def f():\n    sldj sldj\ndef g():\n    ran'
    mod.write(code)
    result = self._assist(code, maxfixes=2, resource=mod)
    self.assertTrue(len(result) &gt; 0)

</t>
<t tx="ekr.20080516150804.3132">def test_completing_names_after_from_import(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('myvar = None\n')
    result = self._assist('from mod1 import myva', resource=mod2)
    self.assertTrue(len(result) &gt; 0)
    self.assert_completion_in_result('myvar', 'global', result)

</t>
<t tx="ekr.20080516150804.3133">def test_completing_names_after_from_import_and_sorted_proposals(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('myvar = None\n')
    result = self._assist('from mod1 import myva', resource=mod2)
    result = sorted_proposals(result)
    self.assertTrue(len(result) &gt; 0)
    self.assert_completion_in_result('myvar', 'global', result)

</t>
<t tx="ekr.20080516150804.3134">def test_completing_names_after_from_import2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('myvar = None\n')
    result = self._assist('from mod1 import ', resource=mod2)
    self.assertTrue(len(result) &gt; 0)
    self.assert_completion_in_result('myvar', 'global', result)

</t>
<t tx="ekr.20080516150804.3135">def test_starting_expression(self):
    code = 'l = list()\nl.app'
    self.assertEquals('l.app', starting_expression(code, len(code)))


</t>
<t tx="ekr.20080516150804.3136">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(CodeAssistTest))
    result.addTests(unittest.makeSuite(CodeAssistInProjectsTest))
    return result

</t>
<t tx="ekr.20080516150804.3137">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3138">from rope.base import exceptions
import unittest

from rope.contrib.findit import find_occurrences, find_implementations
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3139">class FindItTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3140">
def setUp(self):
    super(FindItTest, self).setUp()
    self.project = testutils.sample_project()

</t>
<t tx="ekr.20080516150804.3141">def tearDown(self):
    testutils.remove_project(self.project)
    super(FindItTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3142">def test_finding_occurrences(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('a_var = 1\n')
    result = find_occurrences(self.project, mod, 1)
    self.assertEquals(mod, result[0].resource)
    self.assertEquals(0, result[0].offset)
    self.assertEquals(False, result[0].unsure)

</t>
<t tx="ekr.20080516150804.3143">def test_finding_occurrences_in_more_than_one_module(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('a_var = 1\n')
    mod2.write('import mod1\nmy_var = mod1.a_var')
    result = find_occurrences(self.project, mod1, 1)
    self.assertEquals(2, len(result))
    modules = (result[0].resource, result[1].resource)
    self.assertTrue(mod1 in modules and mod2 in modules)

</t>
<t tx="ekr.20080516150804.3144">def test_finding_occurrences_matching_when_unsure(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class C(object):\n    def a_func(self):\n        pass\n'
               'def f(arg):\n    arg.a_func()\n')
    result = find_occurrences(
        self.project, mod1, mod1.read().index('a_func'), unsure=True)
    self.assertEquals(2, len(result))

</t>
<t tx="ekr.20080516150804.3145">def test_find_occurrences_resources_parameter(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('a_var = 1\n')
    mod2.write('import mod1\nmy_var = mod1.a_var')
    result = find_occurrences(self.project, mod1, 1, resources=[mod1])
    self.assertEquals(1, len(result))
    self.assertEquals((mod1, 0), (result[0].resource, result[0].offset))

</t>
<t tx="ekr.20080516150804.3146">def test_find_occurrences_and_class_hierarchies(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class A(object):\n    def f():\n        pass\n'
               'class B(A):\n    def f():\n        pass\n')
    offset = mod1.read().rindex('f')
    result1 = find_occurrences(self.project, mod1, offset)
    result2 = find_occurrences(self.project, mod1,
                               offset, in_hierarchy=True)
    self.assertEquals(1, len(result1))
    self.assertEquals(2, len(result2))

</t>
<t tx="ekr.20080516150804.3147">def test_trivial_find_implementations(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class A(object):\n    def f(self):\n        pass\n')
    offset = mod1.read().rindex('f(')
    result = find_implementations(self.project, mod1, offset)
    self.assertEquals([], result)

</t>
<t tx="ekr.20080516150804.3148">def test_find_implementations_and_not_returning_parents(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class A(object):\n    def f(self):\n        pass\n'
               'class B(A):\n    def f(self):\n        pass\n')
    offset = mod1.read().rindex('f(')
    result = find_implementations(self.project, mod1, offset)
    self.assertEquals([], result)

</t>
<t tx="ekr.20080516150804.3149">def test_find_implementations_real_implementation(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class A(object):\n    def f(self):\n        pass\n'
               'class B(A):\n    def f(self):\n        pass\n')
    offset = mod1.read().index('f(')
    result = find_implementations(self.project, mod1, offset)
    self.assertEquals(1, len(result))
    self.assertEquals(mod1.read().rindex('f('), result[0].offset)

</t>
<t tx="ekr.20080516150804.3150">@testutils.assert_raises(exceptions.BadIdentifierError)
def test_find_implementations_real_implementation(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class A(object):\n    pass\n')
    offset = mod1.read().index('A')
    result = find_implementations(self.project, mod1, offset)


</t>
<t tx="ekr.20080516150804.3151">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(FindItTest))
    return result

</t>
<t tx="ekr.20080516150804.3152">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3153">import unittest

from rope.base import exceptions
from rope.contrib import generate
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3154">class GenerateTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3155">
def setUp(self):
    super(GenerateTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod1')
    self.mod2 = testutils.create_module(self.project, 'mod2')
    self.pkg = testutils.create_package(self.project, 'pkg')

</t>
<t tx="ekr.20080516150804.3156">def tearDown(self):
    testutils.remove_project(self.project)
    super(GenerateTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3157">def _get_generate(self, offset):
    return generate.GenerateVariable(self.project, self.mod, offset)

</t>
<t tx="ekr.20080516150804.3158">def _get_generate_class(self, offset):
    return generate.GenerateClass(self.project, self.mod, offset)

</t>
<t tx="ekr.20080516150804.3159">def _get_generate_module(self, offset):
    return generate.GenerateModule(self.project, self.mod, offset)

</t>
<t tx="ekr.20080516150804.3160">def _get_generate_package(self, offset):
    return generate.GeneratePackage(self.project, self.mod, offset)

</t>
<t tx="ekr.20080516150804.3161">def _get_generate_function(self, offset):
    return generate.GenerateFunction(self.project, self.mod, offset)

</t>
<t tx="ekr.20080516150804.3162">def test_getting_location(self):
    code = 'a_var = name\n'
    self.mod.write(code)
    generator = self._get_generate(code.index('name'))
    self.assertEquals((self.mod, 1), generator.get_location())

</t>
<t tx="ekr.20080516150804.3163">def test_generating_variable(self):
    code = 'a_var = name\n'
    self.mod.write(code)
    changes = self._get_generate(code.index('name')).get_changes()
    self.project.do(changes)
    self.assertEquals('name = None\n\n\na_var = name\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3164">def test_generating_variable_inserting_before_statement(self):
    code = 'c = 1\nc = b\n'
    self.mod.write(code)
    changes = self._get_generate(code.index('b')).get_changes()
    self.project.do(changes)
    self.assertEquals('c = 1\nb = None\n\n\nc = b\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3165">def test_generating_variable_in_local_scopes(self):
    code = 'def f():\n    c = 1\n    c = b\n'
    self.mod.write(code)
    changes = self._get_generate(code.index('b')).get_changes()
    self.project.do(changes)
    self.assertEquals('def f():\n    c = 1\n    b = None\n    c = b\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3166">def test_generating_variable_in_other_modules(self):
    code = 'import mod2\nc = mod2.b\n'
    self.mod.write(code)
    generator = self._get_generate(code.index('b'))
    self.project.do(generator.get_changes())
    self.assertEquals((self.mod2, 1), generator.get_location())
    self.assertEquals('b = None\n', self.mod2.read())

</t>
<t tx="ekr.20080516150804.3167">def test_generating_variable_in_classes(self):
    code = 'class C(object):\n    def f(self):\n        pass\n' \
           'c = C()\na_var = c.attr'
    self.mod.write(code)
    changes = self._get_generate(code.index('attr')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n    def f(self):\n        pass\n\n    attr = None\n' \
        'c = C()\na_var = c.attr', self.mod.read())

</t>
<t tx="ekr.20080516150804.3168">def test_generating_variable_in_classes_removing_pass(self):
    code = 'class C(object):\n    pass\nc = C()\na_var = c.attr'
    self.mod.write(code)
    changes = self._get_generate(code.index('attr')).get_changes()
    self.project.do(changes)
    self.assertEquals('class C(object):\n\n    attr = None\n' \
                      'c = C()\na_var = c.attr', self.mod.read())

</t>
<t tx="ekr.20080516150804.3169">def test_generating_variable_in_packages(self):
    code = 'import pkg\na = pkg.a\n'
    self.mod.write(code)
    generator = self._get_generate(code.rindex('a'))
    self.project.do(generator.get_changes())
    init = self.pkg.get_child('__init__.py')
    self.assertEquals((init, 1), generator.get_location())
    self.assertEquals('a = None\n', init.read())

</t>
<t tx="ekr.20080516150804.3170">def test_generating_classes(self):
    code = 'c = C()\n'
    self.mod.write(code)
    changes = self._get_generate_class(code.index('C')).get_changes()
    self.project.do(changes)
    self.assertEquals('class C(object):\n    pass\n\n\nc = C()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3171">def test_generating_modules(self):
    code = 'import pkg\npkg.mod\n'
    self.mod.write(code)
    generator = self._get_generate_module(code.rindex('mod'))
    self.project.do(generator.get_changes())
    mod = self.pkg.get_child('mod.py')
    self.assertEquals((mod, 1), generator.get_location())
    self.assertEquals('import pkg.mod\npkg.mod\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3172">def test_generating_packages(self):
    code = 'import pkg\npkg.pkg2\n'
    self.mod.write(code)
    generator = self._get_generate_package(code.rindex('pkg2'))
    self.project.do(generator.get_changes())
    pkg2 = self.pkg.get_child('pkg2')
    init = pkg2.get_child('__init__.py')
    self.assertEquals((init, 1), generator.get_location())
    self.assertEquals('import pkg.pkg2\npkg.pkg2\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3173">def test_generating_function(self):
    code = 'a_func()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals('def a_func():\n    pass\n\n\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3174">def test_generating_modules_with_empty_primary(self):
    code = 'mod\n'
    self.mod.write(code)
    generator = self._get_generate_module(code.rindex('mod'))
    self.project.do(generator.get_changes())
    mod = self.project.root.get_child('mod.py')
    self.assertEquals((mod, 1), generator.get_location())
    self.assertEquals('import mod\nmod\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3175">@testutils.assert_raises(exceptions.RefactoringError)
def test_generating_variable_already_exists(self):
    code = 'b = 1\nc = b\n'
    self.mod.write(code)
    changes = self._get_generate(code.index('b')).get_changes()

</t>
<t tx="ekr.20080516150804.3176">@testutils.assert_raises(exceptions.RefactoringError)
def test_generating_variable_primary_cannot_be_determined(self):
    code = 'c = can_not_be_found.b\n'
    self.mod.write(code)
    changes = self._get_generate(code.rindex('b')).get_changes()

</t>
<t tx="ekr.20080516150804.3177">@testutils.assert_raises(exceptions.RefactoringError)
def test_generating_modules_when_already_exists(self):
    code = 'mod2\n'
    self.mod.write(code)
    generator = self._get_generate_module(code.rindex('mod'))
    self.project.do(generator.get_changes())

</t>
<t tx="ekr.20080516150804.3178">def test_generating_static_methods(self):
    code = 'class C(object):\n    pass\nC.a_func()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n\n    @staticmethod\n    def a_func():\n        pass\nC.a_func()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3179">def test_generating_methods(self):
    code = 'class C(object):\n    pass\nc = C()\nc.a_func()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n\n    def a_func(self):\n        pass\n'
        'c = C()\nc.a_func()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3180">def test_generating_constructors(self):
    code = 'class C(object):\n    pass\nc = C()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.rindex('C')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n\n    def __init__(self):\n        pass\n'
        'c = C()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3181">def test_generating_calls(self):
    code = 'class C(object):\n    pass\nc = C()\nc()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.rindex('c')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n\n    def __call__(self):\n        pass\n'
        'c = C()\nc()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3182">def test_generating_calls_in_other_modules(self):
    self.mod2.write('class C(object):\n    pass\n')
    code = 'import mod2\nc = mod2.C()\nc()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.rindex('c')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'class C(object):\n\n    def __call__(self):\n        pass\n',
        self.mod2.read())

</t>
<t tx="ekr.20080516150804.3183">def test_generating_function_handling_arguments(self):
    code = 'a_func(1)\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals('def a_func(arg0):\n    pass\n\n\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3184">def test_generating_function_handling_keyword_xarguments(self):
    code = 'a_func(p=1)\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals('def a_func(p):\n    pass\n\n\na_func(p=1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3185">def test_generating_function_handling_arguments_better_naming(self):
    code = 'a_var = 1\na_func(a_var)\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals('a_var = 1\ndef a_func(a_var):\n    pass\n\n\na_func(a_var)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3186">def test_generating_variable_in_other_modules2(self):
    self.mod2.write('\n\n\nprint(1)\n')
    code = 'import mod2\nc = mod2.b\n'
    self.mod.write(code)
    generator = self._get_generate(code.index('b'))
    self.project.do(generator.get_changes())
    self.assertEquals((self.mod2, 5), generator.get_location())
    self.assertEquals('\n\n\nprint(1)\n\n\nb = None\n', self.mod2.read())

</t>
<t tx="ekr.20080516150804.3187">def test_generating_function_in_a_suite(self):
    code = 'if True:\n    a_func()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('a_func')).get_changes()
    self.project.do(changes)
    self.assertEquals('def a_func():\n    pass\n\n\nif True:\n    a_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3188">def test_generating_function_in_a_suite_in_a_function(self):
    code = 'def f():\n    a = 1\n    if 1:\n        g()\n'
    self.mod.write(code)
    changes = self._get_generate_function(code.index('g()')).get_changes()
    self.project.do(changes)
    self.assertEquals(
        'def f():\n    a = 1\n    def g():\n        pass\n'
        '    if 1:\n        g()\n',
        self.mod.read())


</t>
<t tx="ekr.20080516150804.3189">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite())
</t>
<t tx="ekr.20080516150804.3190">import unittest

import ropetest.contrib.autoimporttest
import ropetest.contrib.codeassisttest
import ropetest.contrib.findittest
import ropetest.contrib.generatetest


</t>
<t tx="ekr.20080516150804.3191">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(ropetest.contrib.generatetest.GenerateTest))
    result.addTests(ropetest.contrib.codeassisttest.suite())
    result.addTests(ropetest.contrib.autoimporttest.suite())
    result.addTests(ropetest.contrib.findittest.suite())
    return result


</t>
<t tx="ekr.20080516150804.3192"></t>
<t tx="ekr.20080516150804.3193">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3194">import unittest

import rope.base.exceptions
from rope.refactor import change_signature
from rope.refactor.change_signature import ChangeSignature
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3195">class ChangeSignatureTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3196">
def setUp(self):
    super(ChangeSignatureTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3197">def tearDown(self):
    testutils.remove_project(self.project)
    super(ChangeSignatureTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3198">def test_normalizing_parameters_for_trivial_case(self):
    code = 'def a_func():\n    pass\na_func()'
    self.mod.write(code)
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals(code, self.mod.read())

</t>
<t tx="ekr.20080516150804.3199">def test_normalizing_parameters_for_trivial_case2(self):
    code = 'def a_func(param):\n    pass\na_func(2)'
    self.mod.write(code)
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals(code, self.mod.read())

</t>
<t tx="ekr.20080516150804.3200">def test_normalizing_parameters_for_unneeded_keyword(self):
    self.mod.write('def a_func(param):\n    pass\na_func(param=1)')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(param):\n    pass\na_func(1)', self.mod.read())

</t>
<t tx="ekr.20080516150804.3201">def test_normalizing_parameters_for_unneeded_keyword_for_methods(self):
    self.mod.write('class A(object):\n    def a_func(self, param):\n        pass\n'
                   'a_var = A()\na_var.a_func(param=1)')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals(
        'class A(object):\n    def a_func(self, param):\n        pass\n'
        'a_var = A()\na_var.a_func(1)', self.mod.read())

</t>
<t tx="ekr.20080516150804.3202">def test_normalizing_parameters_for_unsorted_keyword(self):
    self.mod.write('def a_func(p1, p2):\n    pass\na_func(p2=2, p1=1)')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(p1, p2):\n    pass\na_func(1, 2)',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3203">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exceptions_for_non_functions(self):
    self.mod.write('a_var = 10')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_var') + 1)

</t>
<t tx="ekr.20080516150804.3204">def test_normalizing_parameters_for_args_parameter(self):
    self.mod.write('def a_func(*arg):\n    pass\na_func(1, 2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(*arg):\n    pass\na_func(1, 2)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3205">def test_normalizing_parameters_for_args_parameter_and_keywords(self):
    self.mod.write('def a_func(param, *args):\n    pass\na_func(*[1, 2, 3])\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(param, *args):\n    pass\n'
                      'a_func(*[1, 2, 3])\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3206">def test_normalizing_functions_from_other_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func(param):\n    pass\n')
    self.mod.write('import mod1\nmod1.a_func(param=1)\n')
    signature = ChangeSignature(self.project, mod1,
                                mod1.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('import mod1\nmod1.a_func(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3207">def test_normalizing_parameters_for_keyword_parameters(self):
    self.mod.write('def a_func(p1, **kwds):\n    pass\n'
                   'a_func(p2=2, p1=1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(p1, **kwds):\n    pass\n'
                      'a_func(1, p2=2)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3208">def test_removing_arguments(self):
    self.mod.write('def a_func(p1):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(0).do()
    self.assertEquals('def a_func():\n    pass\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3209">def test_removing_arguments_with_multiple_args(self):
    self.mod.write('def a_func(p1, p2):\n    pass\na_func(1, 2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(0).do()
    self.assertEquals('def a_func(p2):\n    pass\na_func(2)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3210">def test_removing_arguments_passed_as_keywords(self):
    self.mod.write('def a_func(p1):\n    pass\na_func(p1=1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(0).do()
    self.assertEquals('def a_func():\n    pass\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3211">def test_removing_arguments_with_defaults(self):
    self.mod.write('def a_func(p1=1):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(0).do()
    self.assertEquals('def a_func():\n    pass\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3212">def test_removing_arguments_star_args(self):
    self.mod.write('def a_func(p1, *args):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(1).do()
    self.assertEquals('def a_func(p1):\n    pass\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3213">def test_removing_keyword_arg(self):
    self.mod.write('def a_func(p1, **kwds):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(1).do()
    self.assertEquals('def a_func(p1):\n    pass\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3214">def test_removing_keyword_arg2(self):
    self.mod.write('def a_func(p1, *args, **kwds):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(2).do()
    self.assertEquals('def a_func(p1, *args):\n    pass\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3215"># XXX: What to do here for star args?
def xxx_test_removing_arguments_star_args2(self):
    self.mod.write('def a_func(p1, *args):\n    pass\n'
                   'a_func(2, 3, p1=1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(1).do()
    self.assertEquals('def a_func(p1):\n    pass\na_func(p1=1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3216"># XXX: What to do here for star args?
def xxx_test_removing_arguments_star_args3(self):
    self.mod.write('def a_func(p1, *args):\n    pass\n'
                   'a_func(*[1, 2, 3])\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(1).do()
    self.assertEquals('def a_func(p1):\n    pass\na_func(*[1, 2, 3])\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3217">def test_adding_arguments_for_normal_args_changing_definition(self):
    self.mod.write('def a_func():\n    pass\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(0, 'p1').do()
    self.assertEquals('def a_func(p1):\n    pass\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3218">def test_adding_arguments_for_normal_args_with_defaults(self):
    self.mod.write('def a_func():\n    pass\na_func()\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(0, 'p1', 'None').do()
    self.assertEquals('def a_func(p1=None):\n    pass\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3219">def test_adding_arguments_for_normal_args_changing_calls(self):
    self.mod.write('def a_func():\n    pass\na_func()\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(0, 'p1', 'None', '1').do()
    self.assertEquals('def a_func(p1=None):\n    pass\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3220">def test_adding_arguments_for_normal_args_changing_calls_with_keywords(self):
    self.mod.write('def a_func(p1=0):\n    pass\na_func()\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(1, 'p2', '0', '1').do()
    self.assertEquals('def a_func(p1=0, p2=0):\n    pass\na_func(p2=1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3221">def test_adding_arguments_for_normal_args_changing_calls_with_no_value(self):
    self.mod.write('def a_func(p2=0):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(0, 'p1', '0', None).do()
    self.assertEquals('def a_func(p1=0, p2=0):\n    pass\na_func(p2=1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3222">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_adding_duplicate_parameter_and_raising_exceptions(self):
    self.mod.write('def a_func(p1):\n    pass\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.add(1, 'p1').do()

</t>
<t tx="ekr.20080516150804.3223">def test_inlining_default_arguments(self):
    self.mod.write('def a_func(p1=0):\n    pass\na_func()\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.inline_default(0).do()
    self.assertEquals('def a_func(p1=0):\n    pass\n'
                      'a_func(0)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3224">def test_inlining_default_arguments2(self):
    self.mod.write('def a_func(p1=0):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.inline_default(0).do()
    self.assertEquals('def a_func(p1=0):\n    pass\n'
                      'a_func(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3225">def test_preserving_args_and_keywords_order(self):
    self.mod.write('def a_func(*args, **kwds):\n    pass\n'
                   'a_func(3, 1, 2, a=1, c=3, b=2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.normalize().do()
    self.assertEquals('def a_func(*args, **kwds):\n    pass\n'
                      'a_func(3, 1, 2, a=1, c=3, b=2)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3226">def test_change_order_for_only_one_parameter(self):
    self.mod.write('def a_func(p1):\n    pass\na_func(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.reorder([0]).do()
    self.assertEquals('def a_func(p1):\n    pass\na_func(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3227">def test_change_order_for_two_parameter(self):
    self.mod.write('def a_func(p1, p2):\n    pass\na_func(1, 2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.reorder([1, 0]).do()
    self.assertEquals('def a_func(p2, p1):\n    pass\na_func(2, 1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3228">def test_reordering_multi_line_function_headers(self):
    self.mod.write('def a_func(p1,\n p2):\n    pass\na_func(1, 2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.reorder([1, 0]).do()
    self.assertEquals('def a_func(p2, p1):\n    pass\na_func(2, 1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3229">def test_changing_order_with_static_params(self):
    self.mod.write('def a_func(p1, p2=0, p3=0):\n    pass\na_func(1, 2)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.reorder([0, 2, 1]).do()
    self.assertEquals('def a_func(p1, p3=0, p2=0):\n    pass\n'
                      'a_func(1, p2=2)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3230">def test_doing_multiple_changes(self):
    changers = []
    self.mod.write('def a_func(p1):\n    pass\na_func(1)\n')
    changers.append(change_signature.ArgumentRemover(0))
    changers.append(change_signature.ArgumentAdder(0, 'p2', None, None))
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.get_changes(changers).do()
    self.assertEquals('def a_func(p2):\n    pass\na_func()\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3231">def test_doing_multiple_changes2(self):
    changers = []
    self.mod.write('def a_func(p1, p2):\n    pass\na_func(p2=2)\n')
    changers.append(change_signature.ArgumentAdder(2, 'p3', None, '3'))
    changers.append(change_signature.ArgumentReorderer([1, 0, 2]))
    changers.append(change_signature.ArgumentRemover(1))
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.get_changes(changers).do()
    self.assertEquals('def a_func(p2, p3):\n    pass\na_func(2, 3)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3232">def test_changing_signature_in_subclasses(self):
    self.mod.write(
        'class A(object):\n    def a_method(self):\n        pass\n'
        'class B(A):\n    def a_method(self):\n        pass\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_method') + 1)
    signature.get_changes([change_signature.ArgumentAdder(1, 'p1')],
                             in_hierarchy=True).do()
    self.assertEquals(
        'class A(object):\n    def a_method(self, p1):\n        pass\n'
        'class B(A):\n    def a_method(self, p1):\n        pass\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3233">def test_differentiating_class_accesses_from_instance_accesses(self):
    self.mod.write(
        'class A(object):\n    def a_func(self, param):\n        pass\n'
        'a_var = A()\nA.a_func(a_var, param=1)')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('a_func') + 1)
    signature.remove(1).do()
    self.assertEquals(
        'class A(object):\n    def a_func(self):\n        pass\n'
        'a_var = A()\nA.a_func(a_var)', self.mod.read())

</t>
<t tx="ekr.20080516150804.3234">def test_changing_signature_for_constructors(self):
    self.mod.write(
        'class C(object):\n    def __init__(self, p):\n        pass\n'
        'c = C(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('C') + 1)
    signature.get_changes([change_signature.ArgumentRemover(1)]).do()
    self.assertEquals(
        'class C(object):\n    def __init__(self):\n        pass\n'
        'c = C()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3235">def test_changing_signature_for_constructors2(self):
    self.mod.write(
        'class C(object):\n    def __init__(self, p):\n        pass\n'
        'c = C(1)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('__init__') + 1)
    signature.get_changes([change_signature.ArgumentRemover(1)]).do()
    self.assertEquals(
        'class C(object):\n    def __init__(self):\n        pass\n'
        'c = C()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3236">def test_changing_signature_for_constructors_when_using_super(self):
    self.mod.write(
        'class A(object):\n    def __init__(self, p):\n        pass\n'
        'class B(A):\n    '
        'def __init__(self, p):\n        super(B, self).__init__(p)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().index('__init__') + 1)
    signature.get_changes([change_signature.ArgumentRemover(1)]).do()
    self.assertEquals(
        'class A(object):\n    def __init__(self):\n        pass\n'
        'class B(A):\n    '
        'def __init__(self, p):\n        super(B, self).__init__()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3237">def test_redordering_arguments_reported_by_mft(self):
    self.mod.write('def f(a, b, c):\n    pass\nf(1, 2, 3)\n')
    signature = ChangeSignature(self.project, self.mod,
                                self.mod.read().rindex('f'))
    signature.get_changes(
        [change_signature.ArgumentReorderer([1, 2, 0])]).do()
    self.assertEquals('def f(b, c, a):\n    pass\nf(2, 3, 1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3238">def test_resources_parameter(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func(param):\n    pass\n')
    self.mod.write('import mod1\nmod1.a_func(1)\n')
    signature = ChangeSignature(self.project, mod1,
                                mod1.read().index('a_func') + 1)
    signature.get_changes([change_signature.ArgumentRemover(0)],
                          resources=[mod1]).do()
    self.assertEquals('import mod1\nmod1.a_func(1)\n', self.mod.read())
    self.assertEquals('def a_func():\n    pass\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3239">def test_reordering_and_automatic_defaults(self):
    code = 'def f(p1, p2=2):\n' \
           '    pass\n' \
           'f(1, 2)\n'
    self.mod.write(code)
    signature = ChangeSignature(self.project, self.mod,
                                code.index('f('))
    reorder = change_signature.ArgumentReorderer([1, 0], autodef='1')
    signature.get_changes([reorder]).do()
    expected = 'def f(p2=2, p1=1):\n' \
               '    pass\n' \
               'f(2, 1)\n'
    self.assertEquals(expected, self.mod.read())


</t>
<t tx="ekr.20080516150804.3240">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3241">import unittest

import rope.base.codeanalyze
import rope.base.exceptions
import ropetest.testutils as testutils
from rope.refactor import extract
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3242">class ExtractMethodTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3243">
def setUp(self):
    super(ExtractMethodTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.3244">def tearDown(self):
    testutils.remove_project(self.project)
    super(ExtractMethodTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3245">def do_extract_method(self, source_code, start, end, extracted, **kwds):
    testmod = testutils.create_module(self.project, 'testmod')
    testmod.write(source_code)
    extractor = extract.ExtractMethod(
        self.project, testmod, start, end)
    self.project.do(extractor.get_changes(extracted, **kwds))
    return testmod.read()

</t>
<t tx="ekr.20080516150804.3246">def do_extract_variable(self, source_code, start, end, extracted, **kwds):
    testmod = testutils.create_module(self.project, 'testmod')
    testmod.write(source_code)
    extractor = extract.ExtractVariable( self.project, testmod, start, end)
    self.project.do(extractor.get_changes(extracted, **kwds))
    return testmod.read()

</t>
<t tx="ekr.20080516150804.3247">def _convert_line_range_to_offset(self, code, start, end):
    lines = rope.base.codeanalyze.SourceLinesAdapter(code)
    return lines.get_line_start(start), lines.get_line_end(end)

</t>
<t tx="ekr.20080516150804.3248">def test_simple_extract_function(self):
    code = "def a_func():\n    print('one')\n    print('two')\n"
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'extracted')
    expected = "def a_func():\n    extracted()\n    print('two')\n\n" \
               "def extracted():\n    print('one')\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3249">def test_extract_function_at_the_end_of_file(self):
    code = "def a_func():\n    print('one')"
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'extracted')
    expected = "def a_func():\n    extracted()\n" \
               "def extracted():\n    print('one')\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3250">def test_extract_function_after_scope(self):
    code = "def a_func():\n    print('one')\n    print('two')\n\nprint('hey')\n"
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'extracted')
    expected = "def a_func():\n    extracted()\n    print('two')\n\n" \
               "def extracted():\n    print('one')\n\nprint('hey')\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3251">def test_simple_extract_function_with_parameter(self):
    code = "def a_func():\n    a_var = 10\n    print(a_var)\n"
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = "def a_func():\n    a_var = 10\n    new_func(a_var)\n\n" \
               "def new_func(a_var):\n    print(a_var)\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3252">def test_not_unread_variables_as_parameter(self):
    code = "def a_func():\n    a_var = 10\n    print('hey')\n"
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = "def a_func():\n    a_var = 10\n    new_func()\n\n" \
               "def new_func():\n    print('hey')\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3253">def test_simple_extract_function_with_two_parameter(self):
    code = 'def a_func():\n    a_var = 10\n    another_var = 20\n' \
           '    third_var = a_var + another_var\n'
    start, end = self._convert_line_range_to_offset(code, 4, 4)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a_var = 10\n    another_var = 20\n' \
               '    new_func(a_var, another_var)\n\n' \
               'def new_func(a_var, another_var):\n' \
               '    third_var = a_var + another_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3254">def test_simple_extract_function_with_return_value(self):
    code = 'def a_func():\n    a_var = 10\n    print(a_var)\n'
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a_var = new_func()\n    print(a_var)\n\n' \
               'def new_func():\n    a_var = 10\n    return a_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3255">def test_extract_function_with_multiple_return_values(self):
    code = 'def a_func():\n    a_var = 10\n    another_var = 20\n' \
           '    third_var = a_var + another_var\n'
    start, end = self._convert_line_range_to_offset(code, 2, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a_var, another_var = new_func()\n' \
               '    third_var = a_var + another_var\n\n' \
               'def new_func():\n    a_var = 10\n    another_var = 20\n' \
               '    return a_var, another_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3256">def test_simple_extract_method(self):
    code = 'class AClass(object):\n\n' \
           '    def a_func(self):\n        print(1)\n        print(2)\n'
    start, end = self._convert_line_range_to_offset(code, 4, 4)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class AClass(object):\n\n' \
               '    def a_func(self):\n' \
               '        self.new_func()\n' \
               '        print(2)\n\n' \
               '    def new_func(self):\n        print(1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3257">def test_extract_method_with_args_and_returns(self):
    code = 'class AClass(object):\n' \
           '    def a_func(self):\n' \
           '        a_var = 10\n' \
           '        another_var = a_var * 3\n' \
           '        third_var = a_var + another_var\n'
    start, end = self._convert_line_range_to_offset(code, 4, 4)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class AClass(object):\n' \
               '    def a_func(self):\n' \
               '        a_var = 10\n' \
               '        another_var = self.new_func(a_var)\n' \
               '        third_var = a_var + another_var\n\n' \
               '    def new_func(self, a_var):\n' \
               '        another_var = a_var * 3\n' \
               '        return another_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3258">def test_extract_method_with_self_as_argument(self):
    code = 'class AClass(object):\n' \
           '    def a_func(self):\n' \
           '        print(self)\n'
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class AClass(object):\n' \
               '    def a_func(self):\n' \
               '        self.new_func()\n\n' \
               '    def new_func(self):\n' \
               '        print(self)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3259">def test_extract_method_with_multiple_methods(self):
    code = 'class AClass(object):\n' \
           '    def a_func(self):\n' \
           '        print(self)\n\n' \
           '    def another_func(self):\n' \
           '        pass\n'
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class AClass(object):\n' \
               '    def a_func(self):\n' \
               '        self.new_func()\n\n' \
               '    def new_func(self):\n' \
               '        print(self)\n\n' \
               '    def another_func(self):\n' \
               '        pass\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3260">def test_extract_function_with_function_returns(self):
    code = 'def a_func():\n    def inner_func():\n        pass\n' \
           '    inner_func()\n'
    start, end = self._convert_line_range_to_offset(code, 2, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n' \
               '    inner_func = new_func()\n    inner_func()\n\n' \
               'def new_func():\n' \
               '    def inner_func():\n        pass\n' \
               '    return inner_func\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3261">def test_simple_extract_global_function(self):
    code = "print('one')\nprint('two')\nprint('three')\n"
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = "print('one')\n\ndef new_func():\n    print('two')\n" \
               "\nnew_func()\nprint('three')\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3262">def test_extract_global_function_inside_ifs(self):
    code = 'if True:\n    a = 10\n'
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = '\ndef new_func():\n    a = 10\n\nif True:\n' \
               '    new_func()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3263">def test_extract_function_while_inner_function_reads(self):
    code = 'def a_func():\n    a_var = 10\n' \
           '    def inner_func():\n        print(a_var)\n' \
           '    return inner_func\n'
    start, end = self._convert_line_range_to_offset(code, 3, 4)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a_var = 10\n' \
               '    inner_func = new_func(a_var)\n    return inner_func\n\n' \
               'def new_func(a_var):\n' \
               '    def inner_func():\n        print(a_var)\n' \
               '    return inner_func\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3264">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_bad_range(self):
    code = "def a_func():\n    pass\na_var = 10\n"
    start, end = self._convert_line_range_to_offset(code, 2, 3)
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3265">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_bad_range2(self):
    code = "class AClass(object):\n    pass\n"
    start, end = self._convert_line_range_to_offset(code, 1, 1)
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3266">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_containing_return(self):
    code = 'def a_func(arg):\n    if arg:\n        return arg * 2\n    return 1'
    start, end = self._convert_line_range_to_offset(code, 2, 4)
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3267">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_containing_yield(self):
    code = "def a_func(arg):\n    yield arg * 2\n"
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3268">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_containing_uncomplete_lines(self):
    code = 'a_var = 20\nanother_var = 30\n'
    start = code.index('20')
    end = code.index('30') + 2
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3269">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_extract_method_containing_uncomplete_lines2(self):
    code = 'a_var = 20\nanother_var = 30\n'
    start = code.index('20')
    end = code.index('another') + 5
    self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3270">def test_extract_function_and_argument_as_paramenter(self):
    code = 'def a_func(arg):\n    print(arg)\n'
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func(arg):\n    new_func(arg)\n\n' \
               'def new_func(arg):\n    print(arg)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3271">def test_extract_function_and_end_as_the_start_of_a_line(self):
    code = 'print("hey")\nif True:\n    pass\n'
    start = 0
    end = code.index('\n') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = '\ndef new_func():\n    print("hey")\n\n' \
               'new_func()\nif True:\n    pass\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3272">def test_extract_function_and_indented_blocks(self):
    code = 'def a_func(arg):\n    if True:\n' \
           '        if True:\n            print(arg)\n'
    start, end = self._convert_line_range_to_offset(code, 3, 4)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func(arg):\n    if True:\n        new_func(arg)\n\n' \
               'def new_func(arg):\n    if True:\n        print(arg)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3273">def test_extract_method_and_multi_line_headers(self):
    code = 'def a_func(\n           arg):\n    print(arg)\n'
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func(\n           arg):\n    new_func(arg)\n\n' \
               'def new_func(arg):\n    print(arg)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3274">def test_single_line_extract_function(self):
    code = 'a_var = 10 + 20\n'
    start = code.index('10')
    end = code.index('20') + 2
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = "\ndef new_func():\n    return 10 + 20\n\na_var = new_func()\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3275">def test_single_line_extract_function2(self):
    code = 'def a_func():\n    a = 10\n    b = a * 20\n'
    start = code.rindex('a')
    end = code.index('20') + 2
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a = 10\n    b = new_func(a)\n' \
               '\ndef new_func(a):\n    return a * 20\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3276">def test_single_line_extract_method_and_logical_lines(self):
    code = 'a_var = 10 +\\\n    20\n'
    start = code.index('10')
    end = code.index('20') + 2
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = '\ndef new_func():\n    return 10 + 20\n\na_var = new_func()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3277">def test_single_line_extract_method_and_logical_lines2(self):
    code = 'a_var = (10,\\\n    20)\n'
    start = code.index('10') - 1
    end = code.index('20') + 3
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = '\ndef new_func():\n' \
               '    return (10, 20)\n\na_var = new_func()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3278">def test_single_line_extract_method(self):
    code = "class AClass(object):\n\n" \
           "    def a_func(self):\n        a = 10\n        b = a * a\n"
    start = code.rindex('=') + 2
    end = code.rindex('a') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class AClass(object):\n\n' \
               '    def a_func(self):\n' \
               '        a = 10\n        b = self.new_func(a)\n\n' \
               '    def new_func(self, a):\n        return a * a\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3279">def test_single_line_extract_function_if_condition(self):
    code = 'if True:\n    pass\n'
    start = code.index('True')
    end = code.index('True') + 4
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = "\ndef new_func():\n    return True\n\nif new_func():\n    pass\n"
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3280">def test_unneeded_params(self):
    code = 'class A(object):\n    ' \
           'def a_func(self):\n        a_var = 10\n        a_var += 2\n'
    start = code.rindex('2')
    end = code.rindex('2') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'class A(object):\n' \
               '    def a_func(self):\n        a_var = 10\n' \
               '        a_var += self.new_func()\n\n' \
               '    def new_func(self):\n        return 2\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3281">def test_breaks_and_continues_inside_loops(self):
    code = 'def a_func():\n    for i in range(10):\n        continue\n'
    start = code.index('for')
    end = len(code) - 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    new_func()\n\n' \
               'def new_func():\n' \
               '    for i in range(10):\n        continue\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3282">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_breaks_and_continues_outside_loops(self):
    code = 'def a_func():\n' \
           '    for i in range(10):\n        a = i\n        continue\n'
    start = code.index('a = i')
    end = len(code) - 1
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3283">def test_variable_writes_followed_by_variable_reads_after_extraction(self):
    code = 'def a_func():\n    a = 1\n    a = 2\n    b = a\n'
    start = code.index('a = 1')
    end = code.index('a = 2') - 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    new_func()\n    a = 2\n    b = a\n\n' \
               'def new_func():\n    a = 1\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3284">def test_variable_writes_followed_by_variable_reads_inside_extraction(self):
    code = 'def a_func():\n    a = 1\n    a = 2\n    b = a\n'
    start = code.index('a = 2')
    end = len(code) - 1
    refactored = self.do_extract_method(code, start, end, 'new_func')
    expected = 'def a_func():\n    a = 1\n    new_func()\n\n' \
               'def new_func():\n    a = 2\n    b = a\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3285">def test_extract_variable(self):
    code = 'a_var = 10 + 20\n'
    start = code.index('10')
    end = code.index('20') + 2
    refactored = self.do_extract_variable(code, start, end, 'new_var')
    expected = 'new_var = 10 + 20\na_var = new_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3286">def test_extract_variable_multiple_lines(self):
    code = 'a = 1\nb = 2\n'
    start = code.index('1')
    end = code.index('1') + 1
    refactored = self.do_extract_variable(code, start, end, 'c')
    expected = 'c = 1\na = c\nb = 2\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3287">def test_extract_variable_in_the_middle_of_statements(self):
    code = 'a = 1 + 2\n'
    start = code.index('1')
    end = code.index('1') + 1
    refactored = self.do_extract_variable(code, start, end, 'c')
    expected = 'c = 1\na = c + 2\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3288">def test_extract_variable_for_a_tuple(self):
    code = 'a = 1, 2\n'
    start = code.index('1')
    end = code.index('2') + 1
    refactored = self.do_extract_variable(code, start, end, 'c')
    expected = 'c = 1, 2\na = c\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3289">def test_extract_variable_for_a_string(self):
    code = 'def a_func():\n    a = "hey!"\n'
    start = code.index('"')
    end = code.rindex('"') + 1
    refactored = self.do_extract_variable(code, start, end, 'c')
    expected = 'def a_func():\n    c = "hey!"\n    a = c\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3290">def test_extract_variable_inside_ifs(self):
    code = 'if True:\n    a = 1 + 2\n'
    start = code.index('1')
    end = code.rindex('2') + 1
    refactored = self.do_extract_variable(code, start, end, 'b')
    expected = 'if True:\n    b = 1 + 2\n    a = b\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3291">def test_extract_variable_inside_ifs_and_logical_lines(self):
    code = 'if True:\n    a = (3 + \n(1 + 2))\n'
    start = code.index('1')
    end = code.index('2') + 1
    refactored = self.do_extract_variable(code, start, end, 'b')
    expected = 'if True:\n    b = 1 + 2\n    a = (3 + \n(b))\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3292"># TODO: Handle when extracting a subexpression
def xxx_test_extract_variable_for_a_subexpression(self):
    code = 'a = 3 + 1 + 2\n'
    start = code.index('1')
    end = code.index('2') + 1
    refactored = self.do_extract_variable(code, start, end, 'b')
    expected = 'b = 1 + 2\na = 3 + b\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3293">def test_extract_variable_starting_from_the_start_of_the_line(self):
    code = 'a_dict = {1: 1}\na_dict.values().count(1)\n'
    start = code.rindex('a_dict')
    end = code.index('count') - 1
    refactored = self.do_extract_variable(code, start, end, 'values')
    expected = 'a_dict = {1: 1}\nvalues = a_dict.values()\nvalues.count(1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3294">def test_extract_variable_on_the_last_line_of_a_function(self):
    code = 'def f():\n    a_var = {}\n    a_var.keys()\n'
    start = code.rindex('a_var')
    end = code.index('.keys')
    refactored = self.do_extract_variable(code, start, end, 'new_var')
    expected = 'def f():\n    a_var = {}\n    new_var = a_var\n    new_var.keys()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3295">def test_extract_variable_on_the_indented_function_statement(self):
    code = 'def f():\n    if True:\n        a_var = 1 + 2\n'
    start = code.index('1')
    end = code.index('2') + 1
    refactored = self.do_extract_variable(code, start, end, 'new_var')
    expected = 'def f():\n    if True:\n' \
               '        new_var = 1 + 2\n        a_var = new_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3296">def test_extract_method_on_the_last_line_of_a_function(self):
    code = 'def f():\n    a_var = {}\n    a_var.keys()\n'
    start = code.rindex('a_var')
    end = code.index('.keys')
    refactored = self.do_extract_method(code, start, end, 'new_f')
    expected = 'def f():\n    a_var = {}\n    new_f(a_var).keys()\n\n' \
               'def new_f(a_var):\n    return a_var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3297">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_when_on_incomplete_variables(self):
    code = 'a_var = 10 + 20\n'
    start = code.index('10') + 1
    end = code.index('20') + 2
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3298">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_when_on_incomplete_variables_on_end(self):
    code = 'a_var = 10 + 20\n'
    start = code.index('10')
    end = code.index('20') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3299">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_on_bad_parens(self):
    code = 'a_var = (10 + 20) + 30\n'
    start = code.index('20')
    end = code.index('30') + 2
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3300">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_on_bad_operators(self):
    code = 'a_var = 10 + 20 + 30\n'
    start = code.index('10')
    end = code.rindex('+') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3301"># FIXME: Extract method should be more intelligent about bad ranges
@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def xxx_test_raising_exception_on_function_parens(self):
    code = 'a = range(10)'
    start = code.index('(')
    end = code.rindex(')') + 1
    refactored = self.do_extract_method(code, start, end, 'new_func')

</t>
<t tx="ekr.20080516150804.3302">def test_extract_method_and_extra_blank_lines(self):
    code = '\nprint(1)\n'
    refactored = self.do_extract_method(code, 0, len(code), 'new_f')
    expected = '\n\ndef new_f():\n    print(1)\n\nnew_f()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3303">def test_variable_writes_in_the_same_line_as_variable_read(self):
    code = 'a = 1\na = 1 + a\n'
    start = code.index('\n') + 1
    end = len(code)
    refactored = self.do_extract_method(code, start, end, 'new_f',
                                        global_=True)
    expected = 'a = 1\n\ndef new_f(a):\n    a = 1 + a\n\nnew_f(a)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3304">def test_variable_writes_in_the_same_line_as_variable_read2(self):
    code = 'a = 1\na += 1\n'
    start = code.index('\n') + 1
    end = len(code)
    refactored = self.do_extract_method(code, start, end, 'new_f',
                                        global_=True)
    expected = 'a = 1\n\ndef new_f():\n    a += 1\n\nnew_f()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3305">def test_variable_and_similar_expressions(self):
    code = 'a = 1\nb = 1\n'
    start = code.index('1')
    end = start + 1
    refactored = self.do_extract_variable(code, start, end,
                                          'one', similar=True)
    expected = 'one = 1\na = one\nb = one\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3306">def test_definition_should_appear_before_the_first_use(self):
    code = 'a = 1\nb = 1\n'
    start = code.rindex('1')
    end = start + 1
    refactored = self.do_extract_variable(code, start, end,
                                          'one', similar=True)
    expected = 'one = 1\na = one\nb = one\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3307">def test_extract_method_and_similar_expressions(self):
    code = 'a = 1\nb = 1\n'
    start = code.index('1')
    end = start + 1
    refactored = self.do_extract_method(code, start, end,
                                        'one', similar=True)
    expected = '\ndef one():\n    return 1\n\na = one()\nb = one()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3308">def test_simple_extract_method_and_similar_statements(self):
    code = 'class AClass(object):\n\n' \
           '    def func1(self):\n        a = 1 + 2\n        b = a\n' \
           '    def func2(self):\n        a = 1 + 2\n        b = a\n'
    start, end = self._convert_line_range_to_offset(code, 4, 4)
    refactored = self.do_extract_method(code, start, end,
                                        'new_func', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    def func1(self):\n' \
               '        a = self.new_func()\n        b = a\n\n' \
               '    def new_func(self):\n' \
               '        a = 1 + 2\n        return a\n' \
               '    def func2(self):\n' \
               '        a = self.new_func()\n        b = a\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3309">def test_extract_method_and_similar_statements2(self):
    code = 'class AClass(object):\n\n' \
           '    def func1(self, p1):\n        a = p1 + 2\n' \
           '    def func2(self, p2):\n        a = p2 + 2\n'
    start = code.rindex('p1')
    end =  code.index('2\n') + 1
    refactored = self.do_extract_method(code, start, end,
                                        'new_func', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    def func1(self, p1):\n        a = self.new_func(p1)\n\n' \
               '    def new_func(self, p1):\n        return p1 + 2\n' \
               '    def func2(self, p2):\n        a = self.new_func(p2)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3310">def test_extract_method_and_similar_statements_where_return_is_different(self):
    code = 'class AClass(object):\n\n' \
           '    def func1(self, p1):\n        a = p1 + 2\n' \
           '    def func2(self, p2):\n        self.attr = p2 + 2\n'
    start = code.rindex('p1')
    end =  code.index('2\n') + 1
    refactored = self.do_extract_method(code, start, end,
                                        'new_func', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    def func1(self, p1):\n        a = self.new_func(p1)\n\n' \
               '    def new_func(self, p1):\n        return p1 + 2\n' \
               '    def func2(self, p2):\n        self.attr = self.new_func(p2)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3311">def test_definition_should_appear_where_it_is_visible(self):
    code = 'if True:\n    a = 1\nelse:\n    b = 1\n'
    start = code.rindex('1')
    end = start + 1
    refactored = self.do_extract_variable(code, start, end,
                                          'one', similar=True)
    expected = 'one = 1\nif True:\n    a = one\nelse:\n    b = one\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3312">def test_extract_variable_and_similar_statements_in_classes(self):
    code = 'class AClass(object):\n\n' \
           '    def func1(self):\n        a = 1\n' \
           '    def func2(self):\n        b = 1\n'
    start = code.index(' 1') + 1
    refactored = self.do_extract_variable(code, start, start + 1,
                                          'one', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    def func1(self):\n        one = 1\n        a = one\n' \
               '    def func2(self):\n        b = 1\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3313">def test_extract_method_in_staticmethods(self):
    code = 'class AClass(object):\n\n' \
           '    @staticmethod\n    def func2():\n        b = 1\n'
    start = code.index(' 1') + 1
    refactored = self.do_extract_method(code, start, start + 1,
                                        'one', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    @staticmethod\n    def func2():\n' \
               '        b = AClass.one()\n\n' \
               '    @staticmethod\n    def one():\n' \
               '        return 1\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3314">def test_extract_normal_method_with_staticmethods(self):
    code = 'class AClass(object):\n\n' \
           '    @staticmethod\n    def func1():\n        b = 1\n' \
           '    def func2(self):\n        b = 1\n'
    start = code.rindex(' 1') + 1
    refactored = self.do_extract_method(code, start, start + 1,
                                        'one', similar=True)
    expected = 'class AClass(object):\n\n' \
               '    @staticmethod\n    def func1():\n        b = 1\n' \
               '    def func2(self):\n        b = self.one()\n\n' \
               '    def one(self):\n        return 1\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3315">def test_extract_variable_with_no_new_lines_at_the_end(self):
    code = 'a_var = 10'
    start = code.index('10')
    end = start + 2
    refactored = self.do_extract_variable(code, start, end, 'new_var')
    expected = 'new_var = 10\na_var = new_var'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3316">def test_extract_method_containing_return_in_functions(self):
    code = 'def f(arg):\n    return arg\nprint(f(1))\n'
    start, end = self._convert_line_range_to_offset(code, 1, 3)
    refactored = self.do_extract_method(code, start, end, 'a_func')
    expected = '\ndef a_func():\n    def f(arg):\n        return arg\n' \
               '    print(f(1))\n\na_func()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3317">def test_extract_method_and_varying_first_parameter(self):
    code = 'class C(object):\n' \
           '    def f1(self):\n        print(str(self))\n' \
           '    def f2(self):\n        print(str(1))\n'
    start = code.index('print(') + 6
    end = code.index('))\n') + 1
    refactored = self.do_extract_method(code, start, end,
                                        'to_str', similar=True)
    expected = 'class C(object):\n' \
               '    def f1(self):\n        print(self.to_str())\n\n' \
               '    def to_str(self):\n        return str(self)\n' \
               '    def f2(self):\n        print(str(1))\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3318">def test_extract_method_when_an_attribute_exists_in_function_scope(self):
    code = 'class A(object):\n    def func(self):\n        pass\n' \
           'a = A()\n' \
           'def f():\n' \
           '    func = a.func()\n' \
           '    print func\n'

    start, end = self._convert_line_range_to_offset(code, 6, 6)
    refactored = self.do_extract_method(code, start, end, 'g')
    refactored = refactored[refactored.index('A()') + 4:]
    expected = 'def f():\n    func = g()\n    print func\n\n' \
               'def g():\n    func = a.func()\n    return func\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3319">def test_global_option_for_extract_method(self):
    code = 'def a_func():\n    print(1)\n'
    start, end = self._convert_line_range_to_offset(code, 2, 2)
    refactored = self.do_extract_method(code, start, end,
                                        'extracted', global_=True)
    expected = 'def a_func():\n    extracted()\n\n' \
               'def extracted():\n    print(1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3320">def test_global_extract_method(self):
    code = 'class AClass(object):\n\n' \
           '    def a_func(self):\n        print(1)\n'
    start, end = self._convert_line_range_to_offset(code, 4, 4)
    refactored = self.do_extract_method(code, start, end,
                                        'new_func', global_=True)
    expected = 'class AClass(object):\n\n' \
               '    def a_func(self):\n        new_func()\n\n' \
               'def new_func():\n    print(1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3321">def test_extract_method_with_multiple_methods(self):
    code = 'class AClass(object):\n' \
           '    def a_func(self):\n' \
           '        print(1)\n\n' \
           '    def another_func(self):\n' \
           '        pass\n'
    start, end = self._convert_line_range_to_offset(code, 3, 3)
    refactored = self.do_extract_method(code, start, end,
                                        'new_func', global_=True)
    expected = 'class AClass(object):\n' \
               '    def a_func(self):\n' \
               '        new_func()\n\n' \
               '    def another_func(self):\n' \
               '        pass\n\n' \
               'def new_func():\n' \
               '    print(1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3322">def test_where_to_seach_when_extracting_global_names(self):
    code = 'def a():\n    return 1\ndef b():\n    return 1\nb = 1\n'
    start = code.index('1')
    end = start + 1
    refactored = self.do_extract_variable(code, start, end, 'one',
                                          similar=True, global_=True)
    expected = 'def a():\n    return one\none = 1\n' \
        'def b():\n    return one\nb = one\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3323">def test_extracting_pieces_with_distinct_temp_names(self):
    code = 'a = 1\nprint a\nb = 1\nprint b\n'
    start = code.index('a')
    end = code.index('\nb')
    refactored = self.do_extract_method(code, start, end, 'f',
                                        similar=True, global_=True)
    expected = '\ndef f():\n    a = 1\n    print a\n\nf()\nf()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3324">def test_extracting_methods_in_global_functions_should_be_global(self):
    code = 'def f():\n    a = 1\ndef g():\n    b = 1\n'
    start = code.rindex('1')
    refactored = self.do_extract_method(code, start, start + 1, 'one',
                                        similar=True, global_=False)
    expected = 'def f():\n    a = one()\ndef g():\n    b = one()\n\n' \
               'def one():\n    return 1\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3325">def test_extracting_methods_in_global_functions_should_be_global(self):
    code = 'if 1:\n    var = 2\n'
    start = code.rindex('2')
    refactored = self.do_extract_method(code, start, start + 1, 'two',
                                        similar=True, global_=False)
    expected = '\ndef two():\n    return 2\n\nif 1:\n    var = two()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3326">def test_extract_method_and_try_blocks(self):
    code = 'def f():\n    try:\n        pass\n' \
           '    except Exception:\n        pass\n'
    start, end = self._convert_line_range_to_offset(code, 2, 5)
    refactored = self.do_extract_method(code, start, end, 'g')
    expected = 'def f():\n    g()\n\ndef g():\n    try:\n        pass\n' \
               '    except Exception:\n        pass\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3327">def test_extract_and_not_passing_global_functions(self):
    code = 'def next(p):\n    return p + 1\nvar = next(1)\n'
    start = code.rindex('next')
    refactored = self.do_extract_method(code, start, len(code) - 1, 'two')
    expected = 'def next(p):\n    return p + 1\n' \
               '\ndef two():\n    return next(1)\n\nvar = two()\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3328">def test_extracting_with_only_one_return(self):
    code = 'def f():\n    var = 1\n    return var\n'
    start, end = self._convert_line_range_to_offset(code, 2, 3)
    refactored = self.do_extract_method(code, start, end, 'g')
    expected = 'def f():\n    return g()\n\n' \
               'def g():\n    var = 1\n    return var\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3329">def test_extracting_variable_and_implicit_continuations(self):
    code = 's = ("1"\n  "2")\n'
    start = code.index('"')
    end = code.rindex('"') + 1
    refactored = self.do_extract_variable(code, start, end, 's2')
    expected = 's2 = "1" "2"\ns = (s2)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3330">def test_extracting_method_and_implicit_continuations(self):
    code = 's = ("1"\n  "2")\n'
    start = code.index('"')
    end = code.rindex('"') + 1
    refactored = self.do_extract_method(code, start, end, 'f')
    expected = '\ndef f():\n    return "1" "2"\n\ns = (f())\n'
    self.assertEquals(expected, refactored)


</t>
<t tx="ekr.20080516150804.3331">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3332">import unittest

from rope.refactor.importutils import ImportTools, importinfo, add_import
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3333">class ImportUtilsTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3334">
def setUp(self):
    super(ImportUtilsTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.import_tools = ImportTools(self.pycore)

    self.mod = testutils.create_module(self.project, 'mod')
    self.pkg1 = testutils.create_package(self.project, 'pkg1')
    self.mod1 = testutils.create_module(self.project, 'mod1', self.pkg1)
    self.pkg2 = testutils.create_package(self.project, 'pkg2')
    self.mod2 = testutils.create_module(self.project, 'mod2', self.pkg2)
    self.mod3 = testutils.create_module(self.project, 'mod3', self.pkg2)
    p1 = testutils.create_package(self.project, 'p1')
    p2 = testutils.create_package(self.project, 'p2', p1)
    p3 = testutils.create_package(self.project, 'p3', p2)
    m1 = testutils.create_module(self.project, 'm1', p3)
    l = testutils.create_module(self.project, 'l', p3)

</t>
<t tx="ekr.20080516150804.3335">def tearDown(self):
    testutils.remove_project(self.project)
    super(ImportUtilsTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3336">def test_get_import_for_module(self):
    mod = self.pycore.find_module('mod')
    import_statement = self.import_tools.get_import(mod)
    self.assertEquals('import mod', import_statement.get_import_statement())

</t>
<t tx="ekr.20080516150804.3337">def test_get_import_for_module_in_nested_modules(self):
    mod = self.pycore.find_module('pkg1.mod1')
    import_statement = self.import_tools.get_import(mod)
    self.assertEquals('import pkg1.mod1', import_statement.get_import_statement())

</t>
<t tx="ekr.20080516150804.3338">def test_get_import_for_module_in_init_dot_py(self):
    init_dot_py = self.pkg1.get_child('__init__.py')
    import_statement = self.import_tools.get_import(init_dot_py)
    self.assertEquals('import pkg1', import_statement.get_import_statement())


</t>
<t tx="ekr.20080516150804.3339">def test_get_from_import_for_module(self):
    mod = self.pycore.find_module('mod')
    import_statement = self.import_tools.get_from_import(mod, 'a_func')
    self.assertEquals('from mod import a_func',
                      import_statement.get_import_statement())

</t>
<t tx="ekr.20080516150804.3340">def test_get_from_import_for_module_in_nested_modules(self):
    mod = self.pycore.find_module('pkg1.mod1')
    import_statement = self.import_tools.get_from_import(mod, 'a_func')
    self.assertEquals('from pkg1.mod1 import a_func',
                      import_statement.get_import_statement())

</t>
<t tx="ekr.20080516150804.3341">def test_get_from_import_for_module_in_init_dot_py(self):
    init_dot_py = self.pkg1.get_child('__init__.py')
    import_statement = self.import_tools.\
                       get_from_import(init_dot_py, 'a_func')
    self.assertEquals('from pkg1 import a_func',
                      import_statement.get_import_statement())


</t>
<t tx="ekr.20080516150804.3342">def test_get_import_statements(self):
    self.mod.write('import pkg1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('import pkg1',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3343">def test_get_import_statements_with_alias(self):
    self.mod.write('import pkg1.mod1 as mod1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('import pkg1.mod1 as mod1',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3344">def test_get_import_statements_for_froms(self):
    self.mod.write('from pkg1 import mod1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('from pkg1 import mod1',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3345">def test_get_multi_line_import_statements_for_froms(self):
    self.mod.write('from pkg1 \\\n    import mod1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('from pkg1 import mod1',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3346">def test_get_import_statements_for_from_star(self):
    self.mod.write('from pkg1 import *\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('from pkg1 import *',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3347">@testutils.run_only_for_25
def test_get_import_statements_for_new_relatives(self):
    self.mod2.write('from .mod3 import x\n')
    pymod = self.pycore.get_module('pkg2.mod2')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals('from .mod3 import x',
                      imports[0].import_info.get_import_statement())

</t>
<t tx="ekr.20080516150804.3348">def test_ignoring_indented_imports(self):
    self.mod.write('if True:\n    import pkg1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    self.assertEquals(0, len(imports))

</t>
<t tx="ekr.20080516150804.3349">def test_import_get_names(self):
    self.mod.write('import pkg1 as pkg\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    context = importinfo.ImportContext(self.pycore, self.project.root)
    self.assertEquals(['pkg'],
                      imports[0].import_info.get_imported_names(context))

</t>
<t tx="ekr.20080516150804.3350">def test_import_get_names_with_alias(self):
    self.mod.write('import pkg1.mod1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    context = importinfo.ImportContext(self.pycore, self.project.root)
    self.assertEquals(['pkg1'],
                      imports[0].import_info.get_imported_names(context))

</t>
<t tx="ekr.20080516150804.3351">def test_import_get_names_with_alias2(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.imports
    context = importinfo.ImportContext(self.pycore, self.project.root)
    self.assertEquals(['a_func'],
                      imports[0].import_info.get_imported_names(context))

</t>
<t tx="ekr.20080516150804.3352">def test_empty_getting_used_imports(self):
    self.mod.write('')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(pymod)
    self.assertEquals(0, len(imports))

</t>
<t tx="ekr.20080516150804.3353">def test_empty_getting_used_imports2(self):
    self.mod.write('import pkg\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(pymod)
    self.assertEquals(0, len(imports))

</t>
<t tx="ekr.20080516150804.3354">def test_simple_getting_used_imports(self):
    self.mod.write('import pkg\nprint(pkg)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(pymod)
    self.assertEquals(1, len(imports))
    self.assertEquals('import pkg', imports[0].get_import_statement())

</t>
<t tx="ekr.20080516150804.3355">def test_simple_getting_used_imports2(self):
    self.mod.write('import pkg\ndef a_func():\n    print(pkg)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(pymod)
    self.assertEquals(1, len(imports))
    self.assertEquals('import pkg', imports[0].get_import_statement())

</t>
<t tx="ekr.20080516150804.3356">def test_getting_used_imports_for_nested_scopes(self):
    self.mod.write('import pkg1\nprint(pkg1)\ndef a_func():\n    pass\nprint(pkg1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(
        pymod['a_func'].get_object())
    self.assertEquals(0, len(imports))

</t>
<t tx="ekr.20080516150804.3357">def test_getting_used_imports_for_nested_scopes2(self):
    self.mod.write('from pkg1 import mod1\ndef a_func():\n    print(mod1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(
        pymod['a_func'].get_object())
    self.assertEquals(1, len(imports))
    self.assertEquals('from pkg1 import mod1', imports[0].get_import_statement())

</t>
<t tx="ekr.20080516150804.3358">def test_empty_removing_unused_imports(self):
    self.mod.write('import pkg1\nprint(pkg1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('import pkg1\nprint(pkg1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3359">def test_simple_removing_unused_imports(self):
    self.mod.write('import pkg1\n\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('', module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3360">def test_simple_removing_unused_imports_for_froms(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import a_func, another_func\n\na_func()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import a_func\n\na_func()\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3361">def test_simple_removing_unused_imports_for_from_stars(self):
    self.mod.write('from pkg1.mod1 import *\n\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('', module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3362">def test_simple_removing_unused_imports_for_nested_modules(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write('import pkg1.mod1\npkg1.mod1.a_func()')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('import pkg1.mod1\npkg1.mod1.a_func()',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3363">def test_removing_unused_imports_and_functions_of_the_same_name(self):
    self.mod.write('def a_func():\n    pass\ndef a_func():\n    pass\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('def a_func():\n    pass\ndef a_func():\n    pass\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3364">def test_removing_unused_imports_for_from_import_with_as(self):
    self.mod.write('a_var = 1\n')
    self.mod1.write('from mod import a_var as myvar\na_var = myvar\n')
    pymod = self.pycore.resource_to_pyobject(self.mod1)
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from mod import a_var as myvar\na_var = myvar\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3365">def test_not_removing_imports_that_conflict_with_class_names(self):
    code = 'import pkg1\nclass A(object):\n    pkg1 = 0\n' \
           '    def f(self):\n        a_var = pkg1\n'
    self.mod.write(code)
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals(code, module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3366">def test_adding_imports(self):
    self.mod.write('\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    new_import = self.import_tools.get_import(self.mod1)
    module_with_imports.add_import(new_import)
    self.assertEquals('import pkg1.mod1\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3367">def test_adding_from_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import a_func\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    new_import = self.import_tools.get_from_import(
        self.mod1, 'another_func')
    module_with_imports.add_import(new_import)
    self.assertEquals('from pkg1.mod1 import a_func, another_func\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3368">def test_adding_to_star_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    new_import = self.import_tools.get_from_import(
        self.mod1, 'another_func')
    module_with_imports.add_import(new_import)
    self.assertEquals('from pkg1.mod1 import *\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3369">def test_adding_star_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import a_func\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    new_import = self.import_tools.get_from_import(self.mod1,
                                                              '*')
    module_with_imports.add_import(new_import)
    self.assertEquals('from pkg1.mod1 import *\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3370">def test_adding_imports_and_preserving_spaces_after_imports(self):
    self.mod.write('import pkg1\n\n\nprint(pkg1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    new_import = self.import_tools.get_import(self.pkg2)
    module_with_imports.add_import(new_import)
    self.assertEquals('import pkg1\nimport pkg2\n\n\nprint(pkg1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3371">def test_not_changing_the_format_of_unchanged_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import (a_func,\n    another_func)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    self.assertEquals(
        'from pkg1.mod1 import (a_func,\n    another_func)\n',
        module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3372">def test_not_changing_the_format_of_unchanged_imports2(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import (a_func)\na_func()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import (a_func)\na_func()\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3373">def test_removing_unused_imports_and_reoccuring_names(self):
    self.mod1.write('def a_func():\n    pass\n'
                    'def another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\n'
                   'from pkg1.mod1 import a_func\na_func()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import *\na_func()\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3374">def test_removing_unused_imports_and_reoccuring_names2(self):
    self.mod.write('import pkg2.mod2\nimport pkg2.mod3\n'
                   'print(pkg2.mod2, pkg2.mod3)')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals(
        'import pkg2.mod2\nimport pkg2.mod3\nprint(pkg2.mod2, pkg2.mod3)',
        module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3375">def test_removing_unused_imports_and_common_packages(self):
    self.mod.write('import pkg1.mod1\nimport pkg1\nprint(pkg1, pkg1.mod1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('import pkg1.mod1\nprint(pkg1, pkg1.mod1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3376">def test_removing_unused_imports_and_common_packages_reversed(self):
    self.mod.write('import pkg1\nimport pkg1.mod1\nprint(pkg1, pkg1.mod1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_duplicates()
    self.assertEquals('import pkg1.mod1\nprint(pkg1, pkg1.mod1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3377">def test_removing_unused_imports_and_common_packages2(self):
    self.mod.write('import pkg1.mod1\nimport pkg1.mod2\nprint(pkg1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('import pkg1.mod1\nprint(pkg1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3378">def test_removing_unused_imports_and_froms(self):
    self.mod1.write('def func1():\n    pass\n')
    self.mod.write('from pkg1.mod1 import func1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('', module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3379">def test_removing_unused_imports_and_froms2(self):
    self.mod1.write('def func1():\n    pass\n')
    self.mod.write('from pkg1.mod1 import func1\nfunc1()')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import func1\nfunc1()',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3380">def test_removing_unused_imports_and_froms3(self):
    self.mod1.write('def func1():\n    pass\n')
    self.mod.write('from pkg1.mod1 import func1\n'
                   'def a_func():\n    func1()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals(
        'from pkg1.mod1 import func1\ndef a_func():\n    func1()\n',
        module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3381">def test_removing_unused_imports_and_froms4(self):
    self.mod1.write('def func1():\n    pass\n')
    self.mod.write('from pkg1.mod1 import func1\nclass A(object):\n'
                   '    def a_func(self):\n        func1()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import func1\nclass A(object):\n'
                      '    def a_func(self):\n        func1()\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3382">def test_removing_unused_imports_and_getting_attributes(self):
    self.mod1.write('class A(object):\n    def f(self):\n        pass\n')
    self.mod.write('from pkg1.mod1 import A\nvar = A().f()')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('from pkg1.mod1 import A\nvar = A().f()',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3383">def test_removing_unused_imports_function_parameters(self):
    self.mod1.write('def func1():\n    pass\n')
    self.mod.write('import pkg1\ndef a_func(pkg1):\n    my_var = pkg1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('def a_func(pkg1):\n    my_var = pkg1\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3384">def test_trivial_expanding_star_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.expand_stars()
    self.assertEquals('', module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3385">def test_expanding_star_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\na_func()\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.expand_stars()
    self.assertEquals('from pkg1.mod1 import a_func\na_func()\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3386">def test_removing_duplicate_imports(self):
    self.mod.write('import pkg1\nimport pkg1\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_duplicates()
    self.assertEquals('import pkg1\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3387">def test_removing_duplicates_and_reoccuring_names(self):
    self.mod.write('import pkg2.mod2\nimport pkg2.mod3\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_duplicates()
    self.assertEquals('import pkg2.mod2\nimport pkg2.mod3\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3388">def test_removing_duplicate_imports_for_froms(self):
    self.mod1.write(
        'def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1 import a_func\n'
                   'from pkg1 import a_func, another_func\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_duplicates()
    self.assertEquals('from pkg1 import a_func, another_func\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3389">def test_transforming_froms_to_normal_changing_imports(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import a_func\nprint(a_func)\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg1.mod1\nprint(pkg1.mod1.a_func)\n',
                      changed_module)

</t>
<t tx="ekr.20080516150804.3390">def test_transforming_froms_to_normal_changing_occurances(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import a_func\na_func()')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg1.mod1\npkg1.mod1.a_func()',
                      changed_module)

</t>
<t tx="ekr.20080516150804.3391">def test_transforming_froms_to_normal_for_multi_imports(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\na_func()\nanother_func()\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals(
        'import pkg1.mod1\npkg1.mod1.a_func()\npkg1.mod1.another_func()\n',
        changed_module)

</t>
<t tx="ekr.20080516150804.3392">def test_transforming_froms_to_normal_for_multi_imports_inside_parens(self):
    self.mod1.write('def a_func():\n    pass\ndef another_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import (a_func, \n    another_func)' \
                   '\na_func()\nanother_func()\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals(
        'import pkg1.mod1\npkg1.mod1.a_func()\npkg1.mod1.another_func()\n',
        changed_module)

</t>
<t tx="ekr.20080516150804.3393">def test_transforming_froms_to_normal_from_stars(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write('from pkg1.mod1 import *\na_func()\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg1.mod1\npkg1.mod1.a_func()\n', changed_module)

</t>
<t tx="ekr.20080516150804.3394">def test_transforming_froms_to_normal_from_stars2(self):
    self.mod1.write('a_var = 10')
    self.mod.write('import pkg1.mod1\nfrom pkg1.mod1 import a_var\n' \
                   'def a_func():\n    print(pkg1.mod1, a_var)\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg1.mod1\n' \
                      'def a_func():\n    print(pkg1.mod1, pkg1.mod1.a_var)\n',
                      changed_module)

</t>
<t tx="ekr.20080516150804.3395">def test_transforming_froms_to_normal_from_with_alias(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod.write(
        'from pkg1.mod1 import a_func as another_func\nanother_func()\n')
    pymod = self.pycore.get_module('mod')
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg1.mod1\npkg1.mod1.a_func()\n',
                      changed_module)

</t>
<t tx="ekr.20080516150804.3396">def test_transforming_froms_to_normal_for_relatives(self):
    self.mod2.write('def a_func():\n    pass\n')
    self.mod3.write('from mod2 import *\na_func()\n')
    pymod = self.pycore.resource_to_pyobject(self.mod3)
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import pkg2.mod2\npkg2.mod2.a_func()\n',
                      changed_module)

</t>
<t tx="ekr.20080516150804.3397">def test_transforming_froms_to_normal_for_os_path(self):
    self.mod.write('from os import path\npath.exists(\'.\')\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    changed_module = self.import_tools.froms_to_imports(pymod)
    self.assertEquals('import os\nos.path.exists(\'.\')\n', changed_module)

</t>
<t tx="ekr.20080516150804.3398">def test_transform_relatives_imports_to_absolute_imports_doing_nothing(self):
    self.mod2.write('from pkg1 import mod1\nimport mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('from pkg1 import mod1\nimport mod1\n',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3399">def test_transform_relatives_to_absolute_imports_for_normal_imports(self):
    self.mod2.write('import mod3\n')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('import pkg2.mod3\n',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3400">def test_transform_relatives_imports_to_absolute_imports_for_froms(self):
    self.mod3.write('def a_func():\n    pass\n')
    self.mod2.write('from mod3 import a_func\n')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('from pkg2.mod3 import a_func\n',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3401">@testutils.run_only_for_25
def test_transform_relatives_imports_to_absolute_imports_for_new_relatives(self):
    self.mod3.write('def a_func():\n    pass\n')
    self.mod2.write('from .mod3 import a_func\n')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('from pkg2.mod3 import a_func\n',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3402">def test_transform_relatives_to_absolute_imports_for_normal_imports2(self):
    self.mod2.write('import mod3\nprint(mod3)')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('import pkg2.mod3\nprint(pkg2.mod3)',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3403">def test_transform_relatives_to_absolute_imports_for_aliases(self):
    self.mod2.write('import mod3 as mod3\nprint(mod3)')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals('import pkg2.mod3 as mod3\nprint(mod3)',
                      self.import_tools.relatives_to_absolutes(pymod))

</t>
<t tx="ekr.20080516150804.3404">def test_organizing_imports(self):
    self.mod1.write('import mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod1)
    self.assertEquals('', self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3405">def test_removing_self_imports(self):
    self.mod.write('import mod\nmod.a_var = 1\nprint(mod.a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3406">def test_removing_self_imports2(self):
    self.mod1.write('import pkg1.mod1\npkg1.mod1.a_var = 1\n'
                    'print(pkg1.mod1.a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod1)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3407">def test_removing_self_imports_with_as(self):
    self.mod.write('import mod as mymod\n'
                   'mymod.a_var = 1\nprint(mymod.a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3408">def test_removing_self_imports_for_froms(self):
    self.mod1.write('from pkg1 import mod1\n'
                    'mod1.a_var = 1\nprint(mod1.a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod1)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3409">def test_removing_self_imports_for_froms_with_as(self):
    self.mod1.write('from pkg1 import mod1 as mymod\n'
                    'mymod.a_var = 1\nprint(mymod.a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod1)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3410">def test_removing_self_imports_for_froms2(self):
    self.mod.write('from mod import a_var\na_var = 1\nprint(a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3411">def test_removing_self_imports_for_froms3(self):
    self.mod.write('from mod import a_var\na_var = 1\nprint(a_var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3412">def test_removing_self_imports_for_froms4(self):
    self.mod.write('from mod import a_var as myvar\n'
                   'a_var = 1\nprint(myvar)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(a_var)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3413">def test_removing_self_imports_with_no_dot_after_mod(self):
    self.mod.write('import mod\nprint(mod)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import mod\n\n\nprint(mod)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3414">def test_removing_self_imports_with_no_dot_after_mod2(self):
    self.mod.write('import mod\na_var = 1\n'
                   'print(mod\\\n     \\\n     .var)\n\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(var)\n\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3415">def test_removing_self_imports_for_from_import_star(self):
    self.mod.write('from mod import *\na_var = 1\nprint(myvar)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('a_var = 1\nprint(myvar)\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3416">def test_not_removing_future_imports(self):
    self.mod.write('from __future__ import division\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('from __future__ import division\n',
                      self.import_tools.organize_imports(pymod))

</t>
<t tx="ekr.20080516150804.3417">def test_sorting_empty_imports(self):
    self.mod.write('')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('', self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3418">def test_sorting_one_import(self):
    self.mod.write('import pkg1.mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import pkg1.mod1\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3419">def test_sorting_imports_alphabetically(self):
    self.mod.write('import pkg2.mod2\nimport pkg1.mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import pkg1.mod1\nimport pkg2.mod2\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3420">def test_sorting_imports_and_froms(self):
    self.mod.write('import pkg2.mod2\nfrom pkg1 import mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import pkg2.mod2\nfrom pkg1 import mod1\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3421">def test_sorting_imports_and_standard_modules(self):
    self.mod.write('import pkg1\nimport sys\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import sys\n\nimport pkg1\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3422">def test_sorting_imports_and_standard_modules2(self):
    self.mod.write('import sys\n\nimport time\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import sys\nimport time\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3423">def test_sorting_only_standard_modules(self):
    self.mod.write('import sys\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import sys\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3424">def test_sorting_third_party(self):
    self.mod.write('import pkg1\nimport a_third_party\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import a_third_party\n\nimport pkg1\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3425">def test_sorting_only_third_parties(self):
    self.mod.write('import a_third_party\na_var = 1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals('import a_third_party\n\n\na_var = 1\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3426">def test_simple_handling_long_imports(self):
    self.mod.write('import pkg1.mod1\n\n\nm = pkg1.mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import pkg1.mod1\n\n\nm = pkg1.mod1\n',
        self.import_tools.handle_long_imports(pymod, maxdots=2))

</t>
<t tx="ekr.20080516150804.3427">def test_handling_long_imports_for_many_dots(self):
    self.mod.write('import p1.p2.p3.m1\n\n\nm = p1.p2.p3.m1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from p1.p2.p3 import m1\n\n\nm = m1\n',
        self.import_tools.handle_long_imports(pymod, maxdots=2))

</t>
<t tx="ekr.20080516150804.3428">def test_handling_long_imports_for_their_length(self):
    self.mod.write('import p1.p2.p3.m1\n\n\nm = p1.p2.p3.m1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import p1.p2.p3.m1\n\n\nm = p1.p2.p3.m1\n',
        self.import_tools.handle_long_imports(pymod, maxdots=3,
                                              maxlength=20))

</t>
<t tx="ekr.20080516150804.3429">def test_handling_long_imports_for_many_dots2(self):
    self.mod.write('import p1.p2.p3.m1\n\n\nm = p1.p2.p3.m1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from p1.p2.p3 import m1\n\n\nm = m1\n',
        self.import_tools.handle_long_imports(pymod, maxdots=3,
                                              maxlength=10))

</t>
<t tx="ekr.20080516150804.3430">def test_handling_long_imports_with_one_letter_last(self):
    self.mod.write('import p1.p2.p3.l\n\n\nm = p1.p2.p3.l\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from p1.p2.p3 import l\n\n\nm = l\n',
        self.import_tools.handle_long_imports(pymod, maxdots=2))

</t>
<t tx="ekr.20080516150804.3431">def test_empty_removing_unused_imports_and_eating_blank_lines(self):
    self.mod.write('import pkg1\nimport pkg2\n\n\nprint(pkg1)\n')
    pymod = self.pycore.get_module('mod')
    module_with_imports = self.import_tools.module_imports(pymod)
    module_with_imports.remove_unused_imports()
    self.assertEquals('import pkg1\n\n\nprint(pkg1)\n',
                      module_with_imports.get_changed_source())

</t>
<t tx="ekr.20080516150804.3432">def test_sorting_imports_moving_to_top(self):
    self.mod.write('import mod\ndef f():\n    print(mod, pkg1, pkg2)\n'
                   'import pkg1\nimport pkg2\n')
    pymod = self.pycore.get_module('mod')
    self.assertEquals('import mod\nimport pkg1\nimport pkg2\n\n\n'
                      'def f():\n    print(mod, pkg1, pkg2)\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3433">def test_sorting_imports_moving_to_top2(self):
    self.mod.write('def f():\n    print(mod)\nimport mod\n')
    pymod = self.pycore.get_module('mod')
    self.assertEquals('import mod\n\n\ndef f():\n    print(mod)\n',
                      self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3434">def test_sorting_imports_moving_to_top_and_module_docs(self):
    self.mod.write('"""\ndocs\n"""\ndef f():\n    print(mod)\nimport mod\n')
    pymod = self.pycore.get_module('mod')
    self.assertEquals(
        '"""\ndocs\n"""\nimport mod\n\n\ndef f():\n    print(mod)\n',
        self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3435">def test_sorting_future_imports(self):
    self.mod.write('import os\nfrom __future__ import devision\n')
    pymod = self.pycore.get_module('mod')
    self.assertEquals(
        'from __future__ import devision\n\nimport os\n',
        self.import_tools.sort_imports(pymod))

</t>
<t tx="ekr.20080516150804.3436">def test_customized_import_organization(self):
    self.mod.write('import sys\nimport sys\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import sys\n',
        self.import_tools.organize_imports(pymod, unused=False))

</t>
<t tx="ekr.20080516150804.3437">def test_customized_import_organization2(self):
    self.mod.write('import sys\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import sys\n',
        self.import_tools.organize_imports(pymod, unused=False))

</t>
<t tx="ekr.20080516150804.3438">def test_customized_import_organization3(self):
    self.mod.write('import sys\nimport mod\n\n\nvar = 1\nprint(mod.var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import sys\n\n\nvar = 1\nprint(var)\n',
        self.import_tools.organize_imports(pymod, unused=False))

</t>
<t tx="ekr.20080516150804.3439">def test_trivial_filtered_expand_stars(self):
    self.pkg1.get_child('__init__.py').write('var1 = 1\n')
    self.pkg2.get_child('__init__.py').write('var2 = 1\n')
    self.mod.write('from pkg1 import *\nfrom pkg2 import *\n\n'
                   'print(var1, var2)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from pkg1 import *\nfrom pkg2 import *\n\nprint(var1, var2)\n',
         self.import_tools.expand_stars(pymod, lambda stmt: False))

</t>
<t tx="ekr.20080516150804.3440">def _line_filter(self, lineno):
    def import_filter(import_stmt):
        return import_stmt.start_line &lt;= lineno &lt; import_stmt.end_line
    return import_filter

</t>
<t tx="ekr.20080516150804.3441">def test_filtered_expand_stars(self):
    self.pkg1.get_child('__init__.py').write('var1 = 1\n')
    self.pkg2.get_child('__init__.py').write('var2 = 1\n')
    self.mod.write('from pkg1 import *\nfrom pkg2 import *\n\n'
                   'print(var1, var2)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from pkg1 import *\nfrom pkg2 import var2\n\nprint(var1, var2)\n',
         self.import_tools.expand_stars(pymod, self._line_filter(2)))

</t>
<t tx="ekr.20080516150804.3442">def test_filtered_relative_to_absolute(self):
    self.mod3.write('var = 1')
    self.mod2.write('import mod3\n\nprint(mod3.var)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod2)
    self.assertEquals(
        'import mod3\n\nprint(mod3.var)\n',
         self.import_tools.relatives_to_absolutes(
                      pymod, lambda stmt: False))
    self.assertEquals(
        'import pkg2.mod3\n\nprint(pkg2.mod3.var)\n',
         self.import_tools.relatives_to_absolutes(
                      pymod, self._line_filter(1)))

</t>
<t tx="ekr.20080516150804.3443">def test_filtered_froms_to_normals(self):
    self.pkg1.get_child('__init__.py').write('var1 = 1\n')
    self.pkg2.get_child('__init__.py').write('var2 = 1\n')
    self.mod.write('from pkg1 import var1\nfrom pkg2 import var2\n\n'
                   'print(var1, var2)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from pkg1 import var1\nfrom pkg2 import var2\n\nprint(var1, var2)\n',
         self.import_tools.expand_stars(pymod, lambda stmt: False))
    self.assertEquals(
        'from pkg1 import var1\nimport pkg2\n\nprint(var1, pkg2.var2)\n',
         self.import_tools.froms_to_imports(pymod, self._line_filter(2)))

</t>
<t tx="ekr.20080516150804.3444">def test_filtered_froms_to_normals2(self):
    self.pkg1.get_child('__init__.py').write('var1 = 1\n')
    self.pkg2.get_child('__init__.py').write('var2 = 1\n')
    self.mod.write('from pkg1 import *\nfrom pkg2 import *\n\n'
                   'print(var1, var2)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from pkg1 import *\nimport pkg2\n\nprint(var1, pkg2.var2)\n',
         self.import_tools.froms_to_imports(pymod, self._line_filter(2)))

</t>
<t tx="ekr.20080516150804.3445">def test_filtered_handle_long_imports(self):
    self.mod.write('import p1.p2.p3.m1\nimport pkg1.mod1\n\n\n'
                   'm = p1.p2.p3.m1, pkg1.mod1\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'import p1.p2.p3.m1\nfrom pkg1 import mod1\n\n\n'
        'm = p1.p2.p3.m1, mod1\n',
        self.import_tools.handle_long_imports(
                      pymod, maxlength=5,
                      import_filter=self._line_filter(2)))

</t>
<t tx="ekr.20080516150804.3446">def test_filtering_and_import_actions_with_more_than_one_phase(self):
    self.pkg1.get_child('__init__.py').write('var1 = 1\n')
    self.pkg2.get_child('__init__.py').write('var2 = 1\n')
    self.mod.write('from pkg1 import *\nfrom pkg2 import *\n\n'
                   'print(var2)\n')
    pymod = self.pycore.resource_to_pyobject(self.mod)
    self.assertEquals(
        'from pkg2 import *\n\nprint(var2)\n',
         self.import_tools.expand_stars(pymod, self._line_filter(1)))

</t>
<t tx="ekr.20080516150804.3447">def test_non_existent_module_and_used_imports(self):
    self.mod.write(
        'from does_not_exist import func\n\nfunc()\n')
    pymod = self.pycore.get_module('mod')

    module_with_imports = self.import_tools.module_imports(pymod)
    imports = module_with_imports.get_used_imports(pymod)
    self.assertEquals(1, len(imports))


</t>
<t tx="ekr.20080516150804.3448">class AddImportTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3449">
def setUp(self):
    super(AddImportTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.mod2 = testutils.create_module(self.project, 'mod2')
    self.pkg = testutils.create_package(self.project, 'pkg')
    self.mod3 = testutils.create_module(self.project, 'mod3', self.pkg)

</t>
<t tx="ekr.20080516150804.3450">def tearDown(self):
    testutils.remove_project(self.project)
    super(AddImportTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3451">def test_normal_imports(self):
    self.mod2.write('myvar = None\n')
    self.mod1.write('\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'mod2', 'myvar')
    self.assertEquals('import mod2\n', result)
    self.assertEquals('mod2.myvar', name)

</t>
<t tx="ekr.20080516150804.3452">def test_not_reimporting_a_name(self):
    self.mod2.write('myvar = None\n')
    self.mod1.write('from mod2 import myvar\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'mod2', 'myvar')
    self.assertEquals('from mod2 import myvar\n', result)
    self.assertEquals('myvar', name)

</t>
<t tx="ekr.20080516150804.3453">def test_adding_import_when_siblings_are_imported(self):
    self.mod2.write('var1 = None\nvar2 = None\n')
    self.mod1.write('from mod2 import var1\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'mod2', 'var2')
    self.assertEquals('from mod2 import var1, var2\n', result)
    self.assertEquals('var2', name)

</t>
<t tx="ekr.20080516150804.3454">def test_adding_import_when_the_package_is_imported(self):
    self.pkg.get_child('__init__.py').write('var1 = None\n')
    self.mod3.write('var2 = None\n')
    self.mod1.write('from pkg import var1\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'pkg.mod3', 'var2')
    self.assertEquals('from pkg import var1, mod3\n', result)
    self.assertEquals('mod3.var2', name)

</t>
<t tx="ekr.20080516150804.3455">def test_adding_import_for_modules_instead_of_names(self):
    self.pkg.get_child('__init__.py').write('var1 = None\n')
    self.mod3.write('\n')
    self.mod1.write('from pkg import var1\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'pkg.mod3', None)
    self.assertEquals('from pkg import var1, mod3\n', result)
    self.assertEquals('mod3', name)

</t>
<t tx="ekr.20080516150804.3456">def test_adding_import_for_modules_with_normal_duplicate_imports(self):
    self.pkg.get_child('__init__.py').write('var1 = None\n')
    self.mod3.write('\n')
    self.mod1.write('import pkg.mod3\n')
    pymod = self.pycore.get_module('mod1')
    result, name = add_import(self.pycore, pymod, 'pkg.mod3', None)
    self.assertEquals('import pkg.mod3\n', result)
    self.assertEquals('pkg.mod3', name)


</t>
<t tx="ekr.20080516150804.3457">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(ImportUtilsTest))
    result.addTests(unittest.makeSuite(AddImportTest))
    return result

</t>
<t tx="ekr.20080516150804.3458">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3459">import unittest

import rope.base.exceptions
from rope.refactor import inline
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3460">class InlineTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3461">
def setUp(self):
    super(InlineTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')
    self.mod2 = testutils.create_module(self.project, 'mod2')

</t>
<t tx="ekr.20080516150804.3462">def tearDown(self):
    testutils.remove_project(self.project)
    super(InlineTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3463">def _inline(self, code, offset, **kwds):
    self.mod.write(code)
    self._inline2(self.mod, offset, **kwds)
    return self.mod.read()

</t>
<t tx="ekr.20080516150804.3464">def _inline2(self, resource, offset, **kwds):
    inliner = inline.create_inline(self.project, resource, offset)
    changes = inliner.get_changes(**kwds)
    self.project.do(changes)
    return self.mod.read()

</t>
<t tx="ekr.20080516150804.3465">def test_simple_case(self):
    code = 'a_var = 10\nanother_var = a_var\n'
    refactored = self._inline(code, code.index('a_var') + 1)
    self.assertEquals('another_var = 10\n', refactored)

</t>
<t tx="ekr.20080516150804.3466">def test_empty_case(self):
    code = 'a_var = 10\n'
    refactored = self._inline(code, code.index('a_var') + 1)
    self.assertEquals('', refactored)

</t>
<t tx="ekr.20080516150804.3467">def test_long_definition(self):
    code = 'a_var = 10 + (10 + 10)\nanother_var = a_var\n'
    refactored = self._inline(code, code.index('a_var') + 1)
    self.assertEquals('another_var = 10 + (10 + 10)\n', refactored)

</t>
<t tx="ekr.20080516150804.3468">def test_explicit_continuation(self):
    code = 'a_var = (10 +\n 10)\nanother_var = a_var\n'
    refactored = self._inline(code, code.index('a_var') + 1)
    self.assertEquals('another_var = (10 + 10)\n', refactored)

</t>
<t tx="ekr.20080516150804.3469">def test_implicit_continuation(self):
    code = 'a_var = 10 +\\\n       10\nanother_var = a_var\n'
    refactored = self._inline(code, code.index('a_var') + 1)
    self.assertEquals('another_var = 10 + 10\n', refactored)

</t>
<t tx="ekr.20080516150804.3470">def test_inlining_at_the_end_of_input(self):
    code = 'a = 1\nb = a'
    refactored = self._inline(code, code.index('a') + 1)
    self.assertEquals('b = 1', refactored)

</t>
<t tx="ekr.20080516150804.3471">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_on_classes(self):
    code = 'class AClass(object):\n    pass\n'
    refactored = self._inline(code, code.index('AClass') + 1)

</t>
<t tx="ekr.20080516150804.3472">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_multiple_assignments(self):
    code = 'a_var = 10\na_var = 20\n'
    refactored = self._inline(code, code.index('a_var') + 1)

</t>
<t tx="ekr.20080516150804.3473">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_tuple_assignments(self):
    code = 'a_var, another_var = (20, 30)\n'
    refactored = self._inline(code, code.index('a_var') + 1)

</t>
<t tx="ekr.20080516150804.3474">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_on_unknown_vars(self):
    code = 'a_var = another_var\n'
    refactored = self._inline(code, code.index('another_var') + 1)

</t>
<t tx="ekr.20080516150804.3475">def test_attribute_inlining(self):
    code = 'class A(object):\n    def __init__(self):\n' \
           '        self.an_attr = 3\n        range(self.an_attr)\n'
    refactored = self._inline(code, code.index('an_attr') + 1)
    expected = 'class A(object):\n    def __init__(self):\n' \
               '        range(3)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3476">def test_attribute_inlining2(self):
    code = 'class A(object):\n    def __init__(self):\n' \
           '        self.an_attr = 3\n        range(self.an_attr)\n' \
           'a = A()\nrange(a.an_attr)'
    refactored = self._inline(code, code.index('an_attr') + 1)
    expected = 'class A(object):\n    def __init__(self):\n' \
               '        range(3)\n' \
               'a = A()\nrange(3)'
    self.assertEquals(expected, refactored)


</t>
<t tx="ekr.20080516150804.3477">def test_a_function_with_no_occurance(self):
    self.mod.write('def a_func():\n    pass\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('', self.mod.read())

</t>
<t tx="ekr.20080516150804.3478">def test_a_function_with_no_occurance2(self):
    self.mod.write('a_var = 10\ndef a_func():\n    pass\nprint(a_var)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('a_var = 10\nprint(a_var)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3479">def test_replacing_calls_with_function_definition_in_other_modules(self):
    self.mod.write('def a_func():\n    print(1)\n')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod\nmod.a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('import mod\nprint(1)\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3480">def test_replacing_calls_with_function_definition_in_other_modules2(self):
    self.mod.write('def a_func():\n    print(1)\n')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod\nif True:\n    mod.a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('import mod\nif True:\n    print(1)\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3481">def test_replacing_calls_with_method_definition_in_other_modules(self):
    self.mod.write('class A(object):\n    var = 10\n'
                   '    def a_func(self):\n        print(1)\n')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod\nmod.A().a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('import mod\nprint(1)\n', mod1.read())
    self.assertEquals('class A(object):\n    var = 10\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3482">def test_replacing_calls_with_function_definition_in_defining_module(self):
    self.mod.write('def a_func():\n    print(1)\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3483">def test_replacing_calls_with_function_definition_in_defining_module2(self):
    self.mod.write('def a_func():\n    for i in range(10):\n        print(1)\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('for i in range(10):\n    print(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3484">def test_replacing_calls_with_method_definition_in_defining_modules(self):
    self.mod.write('class A(object):\n    var = 10\n'
                   '    def a_func(self):\n        print(1)\nA().a_func()')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('class A(object):\n    var = 10\nprint(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3485">def test_parameters_with_the_same_name_as_passed(self):
    self.mod.write('def a_func(var):\n    print(var)\nvar = 1\na_func(var)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var = 1\nprint(var)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3486">def test_parameters_with_the_same_name_as_passed2(self):
    self.mod.write('def a_func(var):\n    print(var)\nvar = 1\na_func(var=var)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var = 1\nprint(var)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3487">def test_simple_parameters_renaming(self):
    self.mod.write('def a_func(param):\n    print(param)\nvar = 1\na_func(var)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var = 1\nprint(var)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3488">def test_simple_parameters_renaming_for_multiple_params(self):
    self.mod.write('def a_func(param1, param2):\n    p = param1 + param2\n'
                   'var1 = 1\nvar2 = 1\na_func(var1, var2)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var1 = 1\nvar2 = 1\np = var1 + var2\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3489">def test_parameters_renaming_for_passed_constants(self):
    self.mod.write('def a_func(param):\n    print(param)\na_func(1)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3490">def test_parameters_renaming_for_passed_statements(self):
    self.mod.write('def a_func(param):\n    print(param)\na_func((1 + 2) / 3)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print((1 + 2) / 3)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3491">def test_simple_parameters_renaming_for_multiple_params_using_keywords(self):
    self.mod.write('def a_func(param1, param2):\n    p = param1 + param2\n'
                   'var1 = 1\nvar2 = 1\na_func(param2=var1, param1=var2)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var1 = 1\nvar2 = 1\np = var2 + var1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3492">def test_simple_parameters_renaming_for_multiple_params_using_mixed_keywords(self):
    self.mod.write('def a_func(param1, param2):\n    p = param1 + param2\n'
                   'var1 = 1\nvar2 = 1\na_func(var2, param2=var1)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('var1 = 1\nvar2 = 1\np = var2 + var1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3493">def test_simple_putting_in_default_arguments(self):
    self.mod.write('def a_func(param=None):\n    print(param)\n'
                   'a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(None)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3494">def test_overriding_default_arguments(self):
    self.mod.write('def a_func(param1=1, param2=2):\n    print(param1, param2)\n'
                   'a_func(param2=3)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(1, 3)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3495">def test_badly_formatted_text(self):
    self.mod.write('def a_func  (  param1 =  1 ,param2 = 2 )  :\n    print(param1, param2)\n'
                   'a_func  ( param2 \n  = 3 )  \n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(1, 3)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3496">def test_passing_first_arguments_for_methods(self):
    a_class = 'class A(object):\n' \
              '    def __init__(self):\n' \
              '        self.var = 1\n' \
              '        self.a_func(self.var)\n' \
              '    def a_func(self, param):\n' \
              '        print(param)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    def __init__(self):\n' \
               '        self.var = 1\n' \
               '        print(self.var)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3497">def test_passing_first_arguments_for_methods2(self):
    a_class = 'class A(object):\n' \
              '    def __init__(self):\n' \
              '        self.var = 1\n' \
              '    def a_func(self, param):\n' \
              '        print(param, self.var)\n' \
              'an_a = A()\n' \
              'an_a.a_func(1)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    def __init__(self):\n' \
               '        self.var = 1\n' \
               'an_a = A()\n' \
               'print(1, an_a.var)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3498">def test_passing_first_arguments_for_methods3(self):
    a_class = 'class A(object):\n' \
              '    def __init__(self):\n' \
              '        self.var = 1\n' \
              '    def a_func(self, param):\n' \
              '        print(param, self.var)\n' \
              'an_a = A()\n' \
              'A.a_func(an_a, 1)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    def __init__(self):\n' \
               '        self.var = 1\n' \
               'an_a = A()\n' \
               'print(1, an_a.var)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3499">def test_inlining_staticmethods(self):
    a_class = 'class A(object):\n' \
              '    @staticmethod\n' \
              '    def a_func(param):\n' \
              '        print(param)\n' \
              'A.a_func(1)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    pass\n' \
              'print(1)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3500">def test_static_methods2(self):
    a_class = 'class A(object):\n' \
              '    var = 10\n' \
              '    @staticmethod\n' \
              '    def a_func(param):\n' \
              '        print(param)\n' \
              'an_a = A()\n' \
              'an_a.a_func(1)\n' \
              'A.a_func(2)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
              '    var = 10\n' \
              'an_a = A()\n' \
              'print(1)\n' \
              'print(2)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3501">def test_inlining_classmethods(self):
    a_class = 'class A(object):\n' \
              '    @classmethod\n' \
              '    def a_func(cls, param):\n' \
              '        print(param)\n' \
              'A.a_func(1)\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    pass\n' \
               'print(1)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3502">def test_inlining_classmethods2(self):
    a_class = 'class A(object):\n' \
              '    @classmethod\n' \
              '    def a_func(cls, param):\n' \
              '        return cls\n' \
              'print(A.a_func(1))\n'
    self.mod.write(a_class)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    expected = 'class A(object):\n' \
               '    pass\n' \
               'print(A)\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3503">def test_simple_return_values_and_inlining_functions(self):
    self.mod.write('def a_func():\n    return 1\na = a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('a = 1\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3504">def test_simple_return_values_and_inlining_lonely_functions(self):
    self.mod.write('def a_func():\n    return 1\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3505">def test_empty_returns_and_inlining_lonely_functions(self):
    self.mod.write('def a_func():\n    if True:\n        return\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('if True:\n    pass\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3506">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_multiple_returns(self):
    self.mod.write('def less_than_five(var):\n    if var &lt; 5:\n'
                   '        return True\n    return False\n'
                   'a = less_than_five(2)\n')
    self._inline2(self.mod, self.mod.read().index('less') + 1)

</t>
<t tx="ekr.20080516150804.3507">def test_multiple_returns_and_not_using_the_value(self):
    self.mod.write('def less_than_five(var):\n    if var &lt; 5:\n'
                   '        return True\n    return False\nless_than_five(2)\n')
    self._inline2(self.mod, self.mod.read().index('less') + 1)
    self.assertEquals('if 2 &lt; 5:\n    True\nFalse\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3508">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_for_list_arguments(self):
    self.mod.write('def a_func(*args):\n    print(args)\na_func(1)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)

</t>
<t tx="ekr.20080516150804.3509">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_raising_exception_for_list_keywods(self):
    self.mod.write('def a_func(**kwds):\n    print(kwds)\na_func(n=1)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)

</t>
<t tx="ekr.20080516150804.3510">def test_function_parameters_and_returns_in_other_functions(self):
    code = 'def a_func(param1, param2):\n' \
           '    return param1 + param2\n' \
           'range(a_func(20, param2=abs(10)))\n'
    self.mod.write(code)
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('range(20 + abs(10))\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3511">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_function_references_other_than_call(self):
    self.mod.write('def a_func(param):\n    print(param)\nf = a_func\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)

</t>
<t tx="ekr.20080516150804.3512">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_function_referencing_itself(self):
    self.mod.write('def a_func(var):\n    func = a_func\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)

</t>
<t tx="ekr.20080516150804.3513">@testutils.assert_raises(rope.base.exceptions.RefactoringError)
def test_recursive_functions(self):
    self.mod.write('def a_func(var):\n    a_func(var)\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)

</t>
<t tx="ekr.20080516150804.3514"># TODO: inlining on function parameters
def xxx_test_inlining_function_default_parameters(self):
    self.mod.write('def a_func(p1=1):\n    pass\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('p1') + 1)
    self.assertEquals('def a_func(p1=1):\n    pass\na_func()\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3515">def test_simple_inlining_after_extra_indented_lines(self):
    self.mod.write('def a_func():\n    for i in range(10):\n        pass\n'
                   'if True:\n    pass\na_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('if True:\n    pass\nfor i in range(10):\n    pass\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3516">def test_inlining_a_function_with_pydoc(self):
    self.mod.write('def a_func():\n    """docs"""\n    a = 1\na_func()')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('a = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3517">def test_inlining_methods(self):
    self.mod.write("class A(object):\n    name = 'hey'\n"
                   "    def get_name(self):\n        return self.name\n"
                   "a = A()\nname = a.get_name()\n")
    self._inline2(self.mod, self.mod.read().rindex('get_name') + 1)
    self.assertEquals("class A(object):\n    name = 'hey'\n"
                      "a = A()\nname = a.name\n", self.mod.read())

</t>
<t tx="ekr.20080516150804.3518">def test_simple_returns_with_backslashes(self):
    self.mod.write('def a_func():\n    return 1\\\n        + 2\na = a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('a = 1 + 2\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3519">def test_a_function_with_pass_body(self):
    self.mod.write('def a_func():\n    print(1)\na = a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func') + 1)
    self.assertEquals('print(1)\na = None\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3520">def test_inlining_the_last_method_of_a_class(self):
    self.mod.write('class A(object):\n'
                   '    def a_func(self):\n        pass\n')
    self._inline2(self.mod, self.mod.read().rindex('a_func') + 1)
    self.assertEquals('class A(object):\n    pass\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3521">def test_adding_needed_imports_in_the_dest_module(self):
    self.mod.write('import sys\n\ndef ver():\n    print(sys.version)\n')
    self.mod2.write('import mod\n\nmod.ver()')
    self._inline2(self.mod, self.mod.read().index('ver') + 1)
    self.assertEquals('import mod\nimport sys\n\nprint(sys.version)\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3522">def test_adding_needed_imports_in_the_dest_module_removing_selfs(self):
    self.mod.write('import mod2\n\ndef f():\n    print(mod2.var)\n')
    self.mod2.write('import mod\n\nvar = 1\nmod.f()\n')
    self._inline2(self.mod, self.mod.read().index('f(') + 1)
    self.assertEquals('import mod\n\nvar = 1\nprint(var)\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3523">def test_handling_relative_imports_when_inlining(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod3 = testutils.create_module(self.project, 'mod3', pkg)
    mod4 = testutils.create_module(self.project, 'mod4', pkg)
    mod4.write('var = 1\n')
    mod3.write('from . import mod4\n\ndef f():\n    print(mod4.var)\n')
    self.mod.write('import pkg.mod3\n\npkg.mod3.f()\n')
    self._inline2(self.mod, self.mod.read().index('f(') + 1)
    # Cannot determine the exact import
    self.assertTrue('\n\nprint(mod4.var)\n' in self.mod.read())

</t>
<t tx="ekr.20080516150804.3524">def test_adding_needed_imports_for_elements_in_source(self):
    self.mod.write('def f1():\n    return f2()\ndef f2():\n    return 1\n')
    self.mod2.write('import mod\n\nprint(mod.f1())\n')
    self._inline2(self.mod, self.mod.read().index('f1') + 1)
    self.assertEquals('import mod\nfrom mod import f2\n\nprint(f2())\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3525">def test_relative_imports_and_changing_inlining_body(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod3 = testutils.create_module(self.project, 'mod3', pkg)
    mod4 = testutils.create_module(self.project, 'mod4', pkg)
    mod4.write('var = 1\n')
    mod3.write('import mod4\n\ndef f():\n    print(mod4.var)\n')
    self.mod.write('import pkg.mod3\n\npkg.mod3.f()\n')
    self._inline2(self.mod, self.mod.read().index('f(') + 1)
    self.assertEquals(
        'import pkg.mod3\nimport pkg.mod4\n\nprint(pkg.mod4.var)\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3526">def test_inlining_with_different_returns(self):
    self.mod.write('def f(p):\n    return p\n'
                   'print(f(1))\nprint(f(2))\nprint(f(1))\n')
    self._inline2(self.mod, self.mod.read().index('f(') + 1)
    self.assertEquals('print(1)\nprint(2)\nprint(1)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3527">def test_not_removing_definition_for_variables(self):
    code = 'a_var = 10\nanother_var = a_var\n'
    refactored = self._inline(code, code.index('a_var') + 1,
                              remove=False)
    self.assertEquals('a_var = 10\nanother_var = 10\n', refactored)

</t>
<t tx="ekr.20080516150804.3528">def test_not_removing_definition_for_methods(self):
    code = 'def func():\n    print(1)\n\nfunc()\n'
    refactored = self._inline(code, code.index('func') + 1,
                              remove=False)
    self.assertEquals('def func():\n    print(1)\n\nprint(1)\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3529">def test_only_current_for_methods(self):
    code = 'def func():\n    print(1)\n\nfunc()\nfunc()\n'
    refactored = self._inline(code, code.rindex('func') + 1,
                              remove=False, only_current=True)
    self.assertEquals('def func():\n    print(1)\n\nfunc()\nprint(1)\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3530">def test_only_current_for_variables(self):
    code = 'one = 1\n\na = one\nb = one\n'
    refactored = self._inline(code, code.rindex('one') + 1,
                              remove=False, only_current=True)
    self.assertEquals('one = 1\n\na = one\nb = 1\n', refactored)

</t>
<t tx="ekr.20080516150804.3531">def test_inlining_one_line_functions(self):
    code = 'def f(): return 1\nvar = f()\n'
    refactored = self._inline(code, code.rindex('f'))
    self.assertEquals('var = 1\n', refactored)

</t>
<t tx="ekr.20080516150804.3532">def test_inlining_one_line_functions_with_breaks(self):
    code = 'def f(\np): return p\nvar = f(1)\n'
    refactored = self._inline(code, code.rindex('f'))
    self.assertEquals('var = 1\n', refactored)

</t>
<t tx="ekr.20080516150804.3533">def test_inlining_one_line_functions_with_breaks2(self):
    code = 'def f(\n): return 1\nvar = f()\n'
    refactored = self._inline(code, code.rindex('f'))
    self.assertEquals('var = 1\n', refactored)

</t>
<t tx="ekr.20080516150804.3534">def test_resources_parameter(self):
    self.mod.write('def a_func():\n    print(1)\n')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod\nmod.a_func()\n')
    self._inline2(self.mod, self.mod.read().index('a_func'),
                  resources=[self.mod])
    self.assertEquals('', self.mod.read())
    self.assertEquals('import mod\nmod.a_func()\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3535">def test_inlining_parameters(self):
    code = 'def f(p=1):\n    pass\nf()\n'
    result = self._inline(code, code.index('p'))
    self.assertEquals('def f(p=1):\n    pass\nf(1)\n', result)


</t>
<t tx="ekr.20080516150804.3536">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(InlineTest))
    return result


</t>
<t tx="ekr.20080516150804.3537">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3538">import unittest

from rope.base import exceptions
from rope.refactor import move
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3539">class MoveRefactoringTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3540">
def setUp(self):
    super(MoveRefactoringTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.mod2 = testutils.create_module(self.project, 'mod2')
    self.mod3 = testutils.create_module(self.project, 'mod3')
    self.pkg = testutils.create_package(self.project, 'pkg')
    self.mod4 = testutils.create_module(self.project, 'mod4', self.pkg)
    self.mod5 = testutils.create_module(self.project, 'mod5', self.pkg)

</t>
<t tx="ekr.20080516150804.3541">def tearDown(self):
    testutils.remove_project(self.project)
    super(MoveRefactoringTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3542">def _move(self, resource, offset, dest_resource):
    changes = move.create_move(self.project, resource, offset).\
              get_changes(dest_resource)
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3543">def test_simple_moving(self):
    self.mod1.write('class AClass(object):\n    pass\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
                          self.mod2)
    self.assertEquals('', self.mod1.read())
    self.assertEquals('class AClass(object):\n    pass\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3544">def test_changing_other_modules_adding_normal_imports(self):
    self.mod1.write('class AClass(object):\n    pass\n')
    self.mod3.write('import mod1\na_var = mod1.AClass()\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
               self.mod2)
    self.assertEquals('import mod1\nimport mod2\na_var = mod2.AClass()\n',
                      self.mod3.read())

</t>
<t tx="ekr.20080516150804.3545">def test_changing_other_modules_removing_from_imports(self):
    self.mod1.write('class AClass(object):\n    pass\n')
    self.mod3.write('from mod1 import AClass\na_var = AClass()\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
               self.mod2)
    self.assertEquals('import mod2\na_var = mod2.AClass()\n',
                      self.mod3.read())

</t>
<t tx="ekr.20080516150804.3546">def test_changing_source_module(self):
    self.mod1.write('class AClass(object):\n    pass\na_var = AClass()\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
               self.mod2)
    self.assertEquals('import mod2\na_var = mod2.AClass()\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3547">def test_changing_destination_module(self):
    self.mod1.write('class AClass(object):\n    pass\n')
    self.mod2.write('from mod1 import AClass\na_var = AClass()\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
               self.mod2)
    self.assertEquals('class AClass(object):\n    pass\na_var = AClass()\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3548">@testutils.assert_raises(exceptions.RefactoringError)
def test_folder_destination(self):
    folder = self.project.root.create_folder('folder')
    self.mod1.write('class AClass(object):\n    pass\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1, folder)

</t>
<t tx="ekr.20080516150804.3549">@testutils.assert_raises(exceptions.RefactoringError)
def test_raising_exception_for_moving_non_global_elements(self):
    self.mod1.write('def a_func():\n    class AClass(object):\n        pass\n')
    self._move(self.mod1, self.mod1.read().index('AClass') + 1,
               self.mod2)

</t>
<t tx="ekr.20080516150804.3550">@testutils.assert_raises(exceptions.RefactoringError)
def test_raising_exception_for_moving_global_elements_to_the_same_module(self):
    self.mod1.write('def a_func():\n    pass\n')
    self._move(self.mod1, self.mod1.read().index('a_func'), self.mod1)

</t>
<t tx="ekr.20080516150804.3551">def test_moving_used_imports_to_destination_module(self):
    self.mod3.write('a_var = 10')
    code = 'import mod3\n' \
           'from mod3 import a_var\n' \
           'def a_func():\n' \
           '    print(mod3, a_var)\n'
    self.mod1.write(code)
    self._move(self.mod1, code.index('a_func') + 1, self.mod2)
    expected = 'import mod3\n' \
               'from mod3 import a_var\n\n\n' \
               'def a_func():\n    print(mod3, a_var)\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3552">def test_moving_used_names_to_destination_module2(self):
    code = 'a_var = 10\n' \
           'def a_func():\n' \
           '    print(a_var)\n'
    self.mod1.write(code)
    self._move(self.mod1, code.index('a_func') + 1, self.mod2)
    self.assertEquals('a_var = 10\n', self.mod1.read())
    expected = 'from mod1 import a_var\n\n\n' \
               'def a_func():\n' \
               '    print(a_var)\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3553">def test_moving_used_underlined_names_to_destination_module(self):
    code = '_var = 10\n' \
           'def a_func():\n' \
           '    print(_var)\n'
    self.mod1.write(code)
    self._move(self.mod1, code.index('a_func') + 1, self.mod2)
    expected = 'from mod1 import _var\n\n\n' \
               'def a_func():\n' \
               '    print(_var)\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3554">def test_moving_and_used_relative_imports(self):
    code = 'import mod5\n' \
           'def a_func():\n' \
           '    print(mod5)\n'
    self.mod4.write(code)
    self._move(self.mod4, code.index('a_func') + 1, self.mod1)
    expected = 'import pkg.mod5\n\n\n' \
               'def a_func():\n' \
               '    print(pkg.mod5)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3555">def test_moving_modules(self):
    code = 'import mod1\nprint(mod1)'
    self.mod2.write(code)
    self._move(self.mod2, code.index('mod1') + 1, self.pkg)
    expected = 'import pkg.mod1\nprint(pkg.mod1)'
    self.assertEquals(expected, self.mod2.read())
    self.assertTrue(not self.mod1.exists() and
                    self.pycore.find_module('pkg.mod1') is not None)

</t>
<t tx="ekr.20080516150804.3556">def test_moving_modules_and_removing_out_of_date_imports(self):
    code = 'import pkg.mod4\nprint(pkg.mod4)'
    self.mod2.write(code)
    self._move(self.mod2, code.index('mod4') + 1, self.project.root)
    expected = 'import mod4\nprint(mod4)'
    self.assertEquals(expected, self.mod2.read())
    self.assertTrue(self.pycore.find_module('mod4') is not None)

</t>
<t tx="ekr.20080516150804.3557">def test_moving_modules_and_removing_out_of_date_froms(self):
    code = 'from pkg import mod4\nprint(mod4)'
    self.mod2.write(code)
    self._move(self.mod2, code.index('mod4') + 1, self.project.root)
    self.assertEquals('import mod4\nprint(mod4)', self.mod2.read())

</t>
<t tx="ekr.20080516150804.3558">def test_moving_modules_and_removing_out_of_date_froms2(self):
    self.mod4.write('a_var = 10')
    code = 'from pkg.mod4 import a_var\nprint(a_var)\n'
    self.mod2.write(code)
    self._move(self.mod2, code.index('mod4') + 1, self.project.root)
    expected = 'from mod4 import a_var\nprint(a_var)\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3559">def test_moving_modules_and_relative_import(self):
    self.mod4.write('import mod5\nprint(mod5)\n')
    code = 'import pkg.mod4\nprint(pkg.mod4)'
    self.mod2.write(code)
    self._move(self.mod2, code.index('mod4') + 1, self.project.root)
    moved = self.pycore.find_module('mod4')
    expected = 'import pkg.mod5\nprint(pkg.mod5)\n'
    self.assertEquals(expected, moved.read())

</t>
<t tx="ekr.20080516150804.3560">def test_moving_packages(self):
    pkg2 = testutils.create_package(self.project, 'pkg2')
    code = 'import pkg.mod4\nprint(pkg.mod4)'
    self.mod1.write(code)
    self._move(self.mod1, code.index('pkg') + 1, pkg2)
    self.assertFalse(self.pkg.exists())
    self.assertTrue(self.pycore.find_module('pkg2.pkg.mod4') is not None)
    self.assertTrue(self.pycore.find_module('pkg2.pkg.mod4') is not None)
    self.assertTrue(self.pycore.find_module('pkg2.pkg.mod5') is not None)
    expected = 'import pkg2.pkg.mod4\nprint(pkg2.pkg.mod4)'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3561">def test_moving_modules_with_self_imports(self):
    self.mod1.write('import mod1\nprint(mod1)\n')
    self.mod2.write('import mod1\n')
    self._move(self.mod2, self.mod2.read().index('mod1') + 1, self.pkg)
    moved = self.pycore.find_module('pkg.mod1')
    self.assertEquals('import pkg.mod1\nprint(pkg.mod1)\n', moved.read())

</t>
<t tx="ekr.20080516150804.3562">def test_moving_funtions_to_imported_module(self):
    code = 'import mod1\n' \
           'def a_func():\n' \
           '    var = mod1.a_var\n'
    self.mod1.write('a_var = 1\n')
    self.mod2.write(code)
    self._move(self.mod2, code.index('a_func') + 1, self.mod1)
    expected = 'def a_func():\n' \
               '    var = a_var\n' \
               'a_var = 1\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3563">def test_moving_resources_using_move_module_refactoring(self):
    self.mod1.write('a_var = 1')
    self.mod2.write('import mod1\nmy_var = mod1.a_var\n')
    mover = move.create_move(self.project, self.mod1)
    mover.get_changes(self.pkg).do()
    expected = 'import pkg.mod1\nmy_var = pkg.mod1.a_var\n'
    self.assertEquals(expected, self.mod2.read())
    self.assertTrue(self.pkg.get_child('mod1.py') is not None)

</t>
<t tx="ekr.20080516150804.3564">def test_moving_resources_using_move_module_for_packages(self):
    self.mod1.write('import pkg\nmy_pkg = pkg')
    pkg2 = testutils.create_package(self.project, 'pkg2')
    mover = move.create_move(self.project, self.pkg)
    mover.get_changes(pkg2).do()
    expected = 'import pkg2.pkg\nmy_pkg = pkg2.pkg'
    self.assertEquals(expected, self.mod1.read())
    self.assertTrue(pkg2.get_child('pkg') is not None)

</t>
<t tx="ekr.20080516150804.3565">def test_moving_resources_using_move_module_for_init_dot_py(self):
    self.mod1.write('import pkg\nmy_pkg = pkg')
    pkg2 = testutils.create_package(self.project, 'pkg2')
    init = self.pkg.get_child('__init__.py')
    mover = move.create_move(self.project, init)
    mover.get_changes(pkg2).do()
    self.assertEquals('import pkg2.pkg\nmy_pkg = pkg2.pkg',
                      self.mod1.read())
    self.assertTrue(pkg2.get_child('pkg') is not None)

</t>
<t tx="ekr.20080516150804.3566">def test_moving_module_and_star_imports(self):
    self.mod1.write('a_var = 1')
    self.mod2.write('from mod1 import *\na = a_var\n')
    mover = move.create_move(self.project, self.mod1)
    mover.get_changes(self.pkg).do()
    self.assertEquals('from pkg.mod1 import *\na = a_var\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3567">def test_moving_module_and_not_removing_blanks_after_imports(self):
    self.mod4.write('a_var = 1')
    self.mod2.write('from pkg import mod4\n'
                    'import os\n\n\nprint(mod4.a_var)\n')
    mover = move.create_move(self.project, self.mod4)
    mover.get_changes(self.project.root).do()
    self.assertEquals('import os\nimport mod4\n\n\n'
                      'print(mod4.a_var)\n', self.mod2.read())

</t>
<t tx="ekr.20080516150804.3568">@testutils.assert_raises(exceptions.RefactoringError)
def test_moving_module_refactoring_and_nonexistent_destinations(self):
    self.mod4.write('a_var = 1')
    self.mod2.write('from pkg import mod4\n'
                    'import os\n\n\nprint(mod4.a_var)\n')
    mover = move.create_move(self.project, self.mod4)
    mover.get_changes(None).do()

</t>
<t tx="ekr.20080516150804.3569">def test_moving_methods_choosing_the_correct_class(self):
    code = 'class A(object):\n    def a_method(self):\n        pass\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1, code.index('a_method'))
    self.assertTrue(isinstance(mover, move.MoveMethod))

</t>
<t tx="ekr.20080516150804.3570">def test_moving_methods_getting_new_method_for_empty_methods(self):
    code = 'class A(object):\n    def a_method(self):\n        pass\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self):\n    pass\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3571">def test_moving_methods_getting_new_method_for_constant_methods(self):
    code = 'class A(object):\n    def a_method(self):\n        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self):\n    return 1\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3572">def test_moving_methods_getting_new_method_passing_simple_paremters(self):
    code = 'class A(object):\n' \
           '    def a_method(self, p):\n        return p\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self, p):\n    return p\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3573">def test_moving_methods_getting_new_method_using_main_object(self):
    code = 'class A(object):\n    attr = 1\n' \
           '    def a_method(host):\n        return host.attr\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self, host):\n    return host.attr\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3574">def test_moving_methods_getting_new_method_renaming_main_object(self):
    code = 'class A(object):\n    attr = 1\n' \
           '    def a_method(self):\n        return self.attr\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self, host):\n    return host.attr\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3575">def test_moving_methods_gettin_new_method_with_keyword_arguments(self):
    code = 'class A(object):\n    attr = 1\n' \
           '    def a_method(self, p=None):\n        return p\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals('def new_method(self, p=None):\n    return p\n',
                      mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3576">def test_moving_methods_gettin_new_method_with_many_kinds_arguments(self):
    code = 'class A(object):\n    attr = 1\n' \
           '    def a_method(self, p1, *args, **kwds):\n' \
           '        return self.attr\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    expected = 'def new_method(self, host, p1, *args, **kwds):\n' \
               '    return host.attr\n'
    self.assertEquals(expected, mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3577">def test_moving_methods_getting_new_method_for_multi_line_methods(self):
    code = 'class A(object):\n' \
           '    def a_method(self):\n' \
           '        a = 2\n' \
           '        return a\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    self.assertEquals(
        'def new_method(self):\n    a = 2\n    return a\n',
        mover.get_new_method('new_method'))

</t>
<t tx="ekr.20080516150804.3578">def test_moving_methods_getting_old_method_for_constant_methods(self):
    self.mod2.write('class B(object):\n    pass\n')
    code = 'import mod2\n\n' \
           'class A(object):\n' \
           '    attr = mod2.B()\n' \
           '    def a_method(self):\n' \
           '        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    expected = 'import mod2\n\n' \
               'class A(object):\n' \
               '    attr = mod2.B()\n' \
               '    def a_method(self):\n' \
               '        return self.attr.new_method()\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3579">def test_moving_methods_getting_getting_changes_for_goal_class(self):
    self.mod2.write('class B(object):\n    var = 1\n')
    code = 'import mod2\n\n' \
           'class A(object):\n' \
           '    attr = mod2.B()\n' \
           '    def a_method(self):\n' \
           '        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    expected = 'class B(object):\n' \
               '    var = 1\n\n\n' \
               '    def new_method(self):\n' \
               '        return 1\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3580">def test_moving_methods_getting_getting_changes_for_goal_class2(self):
    code = 'class B(object):\n    var = 1\n\n' \
           'class A(object):\n    attr = B()\n' \
           '    def a_method(self):\n        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    self.assertEquals(
        'class B(object):\n    var = 1\n\n\n'
        '    def new_method(self):\n'
        '        return 1\n\n'
        'class A(object):\n    attr = B()\n'
        '    def a_method(self):\n'
        '        return self.attr.new_method()\n',
        self.mod1.read())

</t>
<t tx="ekr.20080516150804.3581">@testutils.assert_raises(exceptions.RefactoringError)
def test_moving_methods_and_nonexistent_attributes(self):
    code = 'class A(object):\n' \
           '    def a_method(self):\n        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('x', 'new_method')

</t>
<t tx="ekr.20080516150804.3582">@testutils.assert_raises(exceptions.RefactoringError)
def test_unknown_attribute_type(self):
    code = 'class A(object):\n    attr = 1\n' \
           '    def a_method(self):\n        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method')

</t>
<t tx="ekr.20080516150804.3583">def test_moving_methods_and_moving_used_imports(self):
    self.mod2.write('class B(object):\n    var = 1\n')
    code = 'import sys\nimport mod2\n\n' \
           'class A(object):\n' \
           '    attr = mod2.B()\n' \
           '    def a_method(self):\n' \
           '        return sys.version\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    code = 'import sys\n' \
           'class B(object):\n' \
           '    var = 1\n\n\n' \
           '    def new_method(self):\n' \
           '        return sys.version\n'
    self.assertEquals(code, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3584">def test_moving_methods_getting_getting_changes_for_goal_class3(self):
    self.mod2.write('class B(object):\n    pass\n')
    code = 'import mod2\n\n' \
           'class A(object):\n' \
           '    attr = mod2.B()\n' \
           '    def a_method(self):\n' \
           '        return 1\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    expected = 'class B(object):\n\n' \
               '    def new_method(self):\n' \
               '        return 1\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3585">def test_moving_methods_and_source_class_with_parameters(self):
    self.mod2.write('class B(object):\n    pass\n')
    code = 'import mod2\n\n' \
           'class A(object):\n' \
           '    attr = mod2.B()\n' \
           '    def a_method(self, p):\n        return p\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('a_method'))
    mover.get_changes('attr', 'new_method').do()
    expected1 = 'import mod2\n\n' \
                'class A(object):\n' \
                '    attr = mod2.B()\n' \
                '    def a_method(self, p):\n' \
                '        return self.attr.new_method(p)\n'
    self.assertEquals(expected1, self.mod1.read())
    expected2 = 'class B(object):\n\n' \
                '    def new_method(self, p):\n' \
                '        return p\n'
    self.assertEquals(expected2, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3586">def test_moving_globals_to_a_module_with_only_docstrings(self):
    self.mod1.write('import sys\n\n\ndef f():\n    print(sys.version)\n')
    self.mod2.write('"""doc\n\nMore docs ...\n\n"""\n')
    mover = move.create_move(self.project, self.mod1,
                             self.mod1.read().index('f()') + 1)
    self.project.do(mover.get_changes(self.mod2))
    self.assertEquals(
        '"""doc\n\nMore docs ...\n\n"""\n'
        'import sys\n\n\ndef f():\n    print(sys.version)\n',
        self.mod2.read())

</t>
<t tx="ekr.20080516150804.3587">def test_moving_globals_to_a_module_with_only_docstrings2(self):
    code = 'import os\n' \
           'import sys\n\n\n' \
           'def f():\n' \
           '    print(sys.version, os.path)\n'
    self.mod1.write(code)
    self.mod2.write('"""doc\n\nMore docs ...\n\n"""\n')
    mover = move.create_move(self.project, self.mod1,
                             self.mod1.read().index('f()') + 1)
    self.project.do(mover.get_changes(self.mod2))
    expected = '"""doc\n\nMore docs ...\n\n"""\n' \
               'import os\n' \
               'import sys\n\n\n' \
               'def f():\n' \
               '    print(sys.version, os.path)\n'
    self.assertEquals(expected, self.mod2.read())

</t>
<t tx="ekr.20080516150804.3588">def test_moving_a_global_when_it_is_used_after_a_multiline_str(self):
    code = 'def f():\n    pass\ns = """\\\n"""\nr = f()\n'
    self.mod1.write(code)
    mover = move.create_move(self.project, self.mod1,
                             code.index('f()') + 1)
    self.project.do(mover.get_changes(self.mod2))
    expected = 'import mod2\ns = """\\\n"""\nr = mod2.f()\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3589">@testutils.assert_raises(exceptions.RefactoringError)
def test_raising_an_exception_when_moving_non_package_folders(self):
    dir = self.project.root.create_folder('dir')
    mover = move.create_move(self.project, dir)


</t>
<t tx="ekr.20080516150804.3590">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3591">import unittest

import rope.base.codeanalyze
import rope.refactor.occurrences
from rope.refactor import multiproject, rename, move
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3592">class MultiProjectRefactoringTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3593">
def setUp(self):
    super(MultiProjectRefactoringTest, self).setUp()
    self.project1 = testutils.sample_project(foldername='testproject1')
    self.project2 = testutils.sample_project(foldername='testproject2')
    self.mod1 = self.project1.root.create_file('mod1.py')
    self.other = self.project1.root.create_file('other.py')
    self.mod2 = self.project2.root.create_file('mod2.py')

</t>
<t tx="ekr.20080516150804.3594">def tearDown(self):
    testutils.remove_project(self.project1)
    testutils.remove_project(self.project2)
    super(MultiProjectRefactoringTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3595">def test_trivial_rename(self):
    self.mod1.write('var = 1\n')
    refactoring = multiproject.MultiProjectRefactoring(
        rename.Rename, [])
    renamer = refactoring(self.project1, self.mod1, 1)
    multiproject.perform(renamer.get_all_changes('newvar'))
    self.assertEquals('newvar = 1\n', self.mod1.read())

</t>
<t tx="ekr.20080516150804.3596">def test_rename(self):
    self.mod1.write('var = 1\n')
    self.mod2.write('import mod1\nmyvar = mod1.var\n')
    refactoring = multiproject.MultiProjectRefactoring(
        rename.Rename, [self.project2])
    renamer = refactoring(self.project1, self.mod1, 1)
    multiproject.perform(renamer.get_all_changes('newvar'))
    self.assertEquals('newvar = 1\n', self.mod1.read())
    self.assertEquals('import mod1\nmyvar = mod1.newvar\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3597">def test_move(self):
    self.mod1.write('def a_func():\n    pass\n')
    self.mod2.write('import mod1\nmyvar = mod1.a_func()\n')
    refactoring = multiproject.MultiProjectRefactoring(
        move.create_move, [self.project2])
    renamer = refactoring(self.project1, self.mod1,
                          self.mod1.read().index('_func'))
    multiproject.perform(renamer.get_all_changes(self.other))
    self.assertEquals('', self.mod1.read())
    self.assertEquals('def a_func():\n    pass\n', self.other.read())
    self.assertEquals(
        'import mod1\nimport other\nmyvar = other.a_func()\n',
        self.mod2.read())

</t>
<t tx="ekr.20080516150804.3598">def test_rename_from_the_project_not_containing_the_change(self):
    self.project2.get_prefs().add('python_path', self.project1.address)
    self.mod1.write('var = 1\n')
    self.mod2.write('import mod1\nmyvar = mod1.var\n')
    refactoring = multiproject.MultiProjectRefactoring(
        rename.Rename, [self.project1])
    renamer = refactoring(self.project2, self.mod2,
                          self.mod2.read().rindex('var'))
    multiproject.perform(renamer.get_all_changes('newvar'))
    self.assertEquals('newvar = 1\n', self.mod1.read())
    self.assertEquals('import mod1\nmyvar = mod1.newvar\n',
                      self.mod2.read())


</t>
<t tx="ekr.20080516150804.3599">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3600">import unittest

from rope.base import ast
from rope.refactor import patchedast
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3601">class PatchedASTTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3602">
def setUp(self):
    super(PatchedASTTest, self).setUp()

</t>
<t tx="ekr.20080516150804.3603">def tearDown(self):
    super(PatchedASTTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3604">def test_integer_literals_and_region(self):
    source = 'a = 10\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.index('10')
    checker.check_region('Num', start, start + 2)

</t>
<t tx="ekr.20080516150804.3605">def test_integer_literals_and_sorted_children(self):
    source = 'a = 10\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.index('10')
    checker.check_children('Num', ['10'])

</t>
<t tx="ekr.20080516150804.3606">def test_ass_name_node(self):
    source = 'a = 10\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.index('a')
    checker.check_region('Name', start, start + 1)
    checker.check_children('Name', ['a'])

</t>
<t tx="ekr.20080516150804.3607">def test_assign_node(self):
    source = 'a = 10\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.index('a')
    checker.check_region('Assign', 0, len(source) - 1)
    checker.check_children(
        'Assign', ['Name', ' ', '=', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3608">def test_add_node(self):
    source = '1 + 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3609">def test_lshift_node(self):
    source = '1 &lt;&lt; 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['Num', ' ', '&lt;&lt;', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3610">def test_and_node(self):
    source = 'True and True\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BoolOp', 0, len(source) - 1)
    checker.check_children(
        'BoolOp', ['Name', ' ', 'and', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3611">def test_basic_closing_parens(self):
    source = '1 + (2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' (', 'Num', ')'])

</t>
<t tx="ekr.20080516150804.3612">def test_basic_opening_parens(self):
    source = '(1) + 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['(', 'Num', ') ', '+', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3613">def test_basic_opening_biway(self):
    source = '(1) + (2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['(', 'Num', ') ', '+', ' (', 'Num', ')'])

</t>
<t tx="ekr.20080516150804.3614">def test_basic_opening_double(self):
    source = '1 + ((2))\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' ((', 'Num', '))'])

</t>
<t tx="ekr.20080516150804.3615">def test_handling_comments(self):
    source = '(1 + #(\n2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' #(\n', 'Num'])

</t>
<t tx="ekr.20080516150804.3616">def test_handling_parens_with_spaces(self):
    source = '1 + (2\n    )\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' (', 'Num', '\n    )'])

</t>
<t tx="ekr.20080516150804.3617">def test_handling_strings(self):
    source = '1 + "("\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num', ' ', '+', ' ', 'Str'])

</t>
<t tx="ekr.20080516150804.3618">def test_handling_implicit_string_concatenation(self):
    source = "a = '1''2'"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Assign', ['Name' , ' ', '=', ' ', 'Str'])
    checker.check_children('Str', ["'1''2'"])

</t>
<t tx="ekr.20080516150804.3619">def test_handling_implicit_string_concatenation_line_breaks(self):
    source = "a = '1' \\\n'2'"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Assign', ['Name' , ' ', '=', ' ', 'Str'])
    checker.check_children('Str', ["'1' \\\n'2'"])

</t>
<t tx="ekr.20080516150804.3620">def test_handling_explicit_string_concatenation_line_breaks(self):
    source = "a = ('1' \n'2')"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Assign', ['Name' , ' ', '=', ' (', 'Str', ')'])
    checker.check_children('Str', ["'1' \n'2'"])

</t>
<t tx="ekr.20080516150804.3621">def test_not_concatenating_strings_on_separate_lines(self):
    source = "'1'\n'2'\n"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Module', ['', 'Expr', '\n', 'Expr', '\n'])

</t>
<t tx="ekr.20080516150804.3622">def test_long_integer_literals(self):
    source = "0x1L + a"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num' , ' ', '+', ' ', 'Name'])
    checker.check_children('Num', ['0x1L'])

</t>
<t tx="ekr.20080516150804.3623">def test_complex_number_literals(self):
    source = "1.0e2j + a"
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num' , ' ', '+', ' ', 'Name'])
    checker.check_children('Num', ['1.0e2j'])

</t>
<t tx="ekr.20080516150804.3624">def test_ass_attr_node(self):
    source = 'a.b = 1\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Attribute', 0, source.index('=') - 1)
    checker.check_children('Attribute', ['Name', '', '.', '', 'b'])

</t>
<t tx="ekr.20080516150804.3625">def test_ass_list_node(self):
    source = '[a, b] = 1, 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('List', 0, source.index(']') + 1)
    checker.check_children('List', ['[', '', 'Name', '', ',',
                                    ' ', 'Name', '', ']'])

</t>
<t tx="ekr.20080516150804.3626">def test_ass_tuple(self):
    source = 'a, b = range(2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Tuple', 0, source.index('=') - 1)
    checker.check_children(
        'Tuple', ['Name', '', ',', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3627">def test_ass_tuple2(self):
    source = '(a, b) = range(2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Tuple', 0, source.index('=') - 1)
    checker.check_children(
        'Tuple', ['(', '', 'Name', '', ',', ' ', 'Name', '', ')'])

</t>
<t tx="ekr.20080516150804.3628">def test_assert(self):
    source = 'assert True\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Assert', 0, len(source) - 1)
    checker.check_children(
        'Assert', ['assert', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3629">def test_assert2(self):
    source = 'assert True, "error"\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Assert', 0, len(source) - 1)
    checker.check_children(
        'Assert', ['assert', ' ', 'Name', '', ',', ' ', 'Str'])

</t>
<t tx="ekr.20080516150804.3630">def test_aug_assign_node(self):
    source = 'a += 1\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.index('a')
    checker.check_region('AugAssign', 0, len(source) - 1)
    checker.check_children(
        'AugAssign', ['Name', ' ', '+', '', '=', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3631">def test_back_quotenode(self):
    source = '`1`\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Repr', 0, len(source) - 1)
    checker.check_children(
        'Repr', ['`', '', 'Num', '', '`'])

</t>
<t tx="ekr.20080516150804.3632">def test_bitand(self):
    source = '1 &amp; 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children(
        'BinOp', ['Num', ' ', '&amp;', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3633">def test_bitor(self):
    source = '1 | 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'BinOp', ['Num', ' ', '|', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3634">def test_call_func(self):
    source = 'f(1, 2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Call', 0, len(source) - 1)
    checker.check_children(
        'Call', ['Name', '', '(', '', 'Num', '', ',',
                 ' ', 'Num', '', ')'])

</t>
<t tx="ekr.20080516150804.3635">def test_call_func_and_keywords(self):
    source = 'f(1, p=2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Call', ['Name', '', '(', '', 'Num', '', ',',
                 ' ', 'keyword', '', ')'])

</t>
<t tx="ekr.20080516150804.3636">def test_call_func_and_start_args(self):
    source = 'f(1, *args)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Call', ['Name', '', '(', '', 'Num', '', ',',
                 ' ', '*', '', 'Name', '', ')'])

</t>
<t tx="ekr.20080516150804.3637">def test_call_func_and_only_dstart_args(self):
    source = 'f(**kwds)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Call', ['Name', '', '(', '', '**', '', 'Name', '', ')'])

</t>
<t tx="ekr.20080516150804.3638">def test_call_func_and_both_varargs_and_kwargs(self):
    source = 'f(*args, **kwds)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Call', ['Name', '', '(', '', '*', '', 'Name', '', ',',
                 ' ', '**', '', 'Name', '', ')'])

</t>
<t tx="ekr.20080516150804.3639">def test_class_node(self):
    source = 'class A(object):\n    """class docs"""\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Class', 0, len(source) - 1)
    checker.check_children(
        'Class', ['class', ' ', 'A', '', '(', '', 'Name', '', ')',
                  '', ':', '\n    ', 'Expr', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3640">def test_class_with_no_bases(self):
    source = 'class A:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Class', 0, len(source) - 1)
    checker.check_children(
        'Class', ['class', ' ', 'A', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3641">def test_simple_compare(self):
    source = '1 &lt; 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Compare', 0, len(source) - 1)
    checker.check_children(
        'Compare', ['Num', ' ', '&lt;', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3642">def test_multiple_compare(self):
    source = '1 &lt; 2 &lt;= 3\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Compare', 0, len(source) - 1)
    checker.check_children(
        'Compare', ['Num', ' ', '&lt;', ' ', 'Num', ' ',
                    '&lt;=', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3643">def test_decorators_node(self):
    source = '@d\ndef f():\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('FunctionDef', 0, len(source) - 1)
    checker.check_children(
        'FunctionDef',
        ['@', '', 'Name', '\n', 'def', ' ', 'f', '', '(', '', 'arguments',
         '', ')', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3644">@testutils.only_for('2.6')
def test_decorators_for_classes(self):
    source = '@d\nclass C(object):\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('ClassDef', 0, len(source) - 1)
    checker.check_children(
        'ClassDef',
        ['@', '', 'Name', '\n', 'class', ' ', 'C', '', '(', '', 'Name',
         '', ')', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3645">def test_both_varargs_and_kwargs(self):
    source = 'def f(*args, **kwds):\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'arguments', ['*', '', 'args' , '', ',' , ' ', '**', '', 'kwds'])

</t>
<t tx="ekr.20080516150804.3646">def test_function_node(self):
    source = 'def f():\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Function', 0, len(source) - 1)
    checker.check_children('Function', ['def', ' ', 'f', '', '(', '', 'arguments', '',
                                        ')', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3647">def test_function_node2(self):
    source = 'def f(p1, **p2):\n    """docs"""\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Function', 0, len(source) - 1)
    checker.check_children(
        'Function', ['def', ' ', 'f', '', '(', '', 'arguments',
                     '', ')' , '', ':', '\n    ', 'Expr', '\n    ', 'Pass'])
    checker.check_children(
        'arguments', ['Name', '', ',',
                      ' ', '**', '', 'p2'])

</t>
<t tx="ekr.20080516150804.3648">def test_function_node_and_tuple_parameters(self):
    source = 'def f(a, (b, c)):\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Function', 0, len(source) - 1)
    checker.check_children(
        'Function', ['def', ' ', 'f', '', '(', '', 'arguments',
                     '', ')' , '', ':', '\n    ', 'Pass'])
    checker.check_children(
        'arguments', ['Name', '', ',', ' ', 'Tuple'])

</t>
<t tx="ekr.20080516150804.3649">def test_dict_node(self):
    source = '{1: 2, 3: 4}\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Dict', 0, len(source) - 1)
    checker.check_children(
        'Dict', ['{', '', 'Num', '', ':', ' ', 'Num', '', ',',
                 ' ', 'Num', '', ':', ' ', 'Num', '', '}'])

</t>
<t tx="ekr.20080516150804.3650">def test_div_node(self):
    source = '1 / 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('BinOp', 0, len(source) - 1)
    checker.check_children('BinOp', ['Num', ' ', '/', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3651">def test_simple_exec_node(self):
    source = 'exec ""\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Exec', 0, len(source) - 1)
    checker.check_children('Exec', ['exec', ' ', 'Str'])

</t>
<t tx="ekr.20080516150804.3652">def test_exec_node(self):
    source = 'exec "" in locals(), globals()\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Exec', 0, len(source) - 1)
    checker.check_children(
        'Exec', ['exec', ' ', 'Str', ' ', 'in',
                 ' ', 'Call', '', ',', ' ', 'Call'])

</t>
<t tx="ekr.20080516150804.3653">def test_for_node(self):
    source = 'for i in range(1):\n    pass\nelse:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('For', 0, len(source) - 1)
    checker.check_children(
        'For', ['for', ' ', 'Name', ' ', 'in', ' ', 'Call', '',
                ':', '\n    ', 'Pass', '\n',
                'else', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3654">def test_normal_from_node(self):
    source = 'from x import y\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('ImportFrom', 0, len(source) - 1)
    checker.check_children(
        'ImportFrom', ['from', ' ', 'x', ' ', 'import', ' ', 'alias'])
    checker.check_children('alias', ['y'])

</t>
<t tx="ekr.20080516150804.3655">@testutils.run_only_for_25
def test_from_node(self):
    source = 'from ..x import y as z\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('ImportFrom', 0, len(source) - 1)
    checker.check_children(
        'ImportFrom', ['from', ' ', '..', '', 'x', ' ',
                       'import', ' ', 'alias'])
    checker.check_children('alias', ['y', ' ', 'as', ' ', 'z'])

</t>
<t tx="ekr.20080516150804.3656">def test_simple_gen_expr_node(self):
    source = 'zip(i for i in x)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('GeneratorExp', 4, len(source) - 2)
    checker.check_children(
        'GeneratorExp', ['Name', ' ', 'comprehension'])
    checker.check_children(
        'comprehension', ['for', ' ', 'Name', ' ', 'in', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3657">def test_gen_expr_node_handling_surrounding_parens(self):
    source = '(i for i in x)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('GeneratorExp', 0, len(source) - 1)
    checker.check_children(
        'GeneratorExp', ['(', '', 'Name', ' ', 'comprehension', '', ')'])

</t>
<t tx="ekr.20080516150804.3658">def test_gen_expr_node2(self):
    source = 'zip(i for i in range(1) if i == 1)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'comprehension', ['for', ' ', 'Name', ' ', 'in', ' ', 'Call',
                          ' ', 'if', ' ', 'Compare'])

</t>
<t tx="ekr.20080516150804.3659">def test_get_attr_node(self):
    source = 'a.b\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Attribute', 0, len(source) - 1)
    checker.check_children('Attribute', ['Name', '', '.', '', 'b'])

</t>
<t tx="ekr.20080516150804.3660">def test_global_node(self):
    source = 'global a, b\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Global', 0, len(source) - 1)
    checker.check_children('Global', ['global', ' ', 'a', '', ',', ' ', 'b'])

</t>
<t tx="ekr.20080516150804.3661">def test_if_node(self):
    source = 'if True:\n    pass\nelse:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('If', 0, len(source) - 1)
    checker.check_children(
        'If', ['if', ' ', 'Name', '', ':', '\n    ', 'Pass', '\n',
               'else', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3662">def test_if_node2(self):
    source = 'if True:\n    pass\nelif False:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('If', 0, len(source) - 1)
    checker.check_children(
        'If', ['if', ' ', 'Name', '', ':', '\n    ', 'Pass', '\n',
               'If'])

</t>
<t tx="ekr.20080516150804.3663">def test_if_node3(self):
    source = 'if True:\n    pass\nelse:\n' \
             '    if True:\n        pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('If', 0, len(source) - 1)
    checker.check_children(
        'If', ['if', ' ', 'Name', '', ':', '\n    ', 'Pass', '\n',
               'else', '', ':', '\n    ', 'If'])

</t>
<t tx="ekr.20080516150804.3664">def test_import_node(self):
    source = 'import a, b as c\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Import', 0, len(source) - 1)
    checker.check_children(
        'Import', ['import', ' ', 'alias', '', ',', ' ', 'alias'])

</t>
<t tx="ekr.20080516150804.3665">def test_lambda_node(self):
    source = 'lambda a, b=1, *z: None\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Lambda', 0, len(source) - 1)
    checker.check_children(
        'Lambda', ['lambda', ' ', 'arguments', '', ':', ' ', 'Name'])
    checker.check_children(
        'arguments', ['Name', '', ',', ' ', 'Name', '', '=', '',
                      'Num', '', ',', ' ', '*', '', 'z'])

</t>
<t tx="ekr.20080516150804.3666">def test_list_node(self):
    source = '[1, 2]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('List', 0, len(source) - 1)
    checker.check_children(
        'List', ['[', '', 'Num', '', ',', ' ', 'Num', '', ']'])

</t>
<t tx="ekr.20080516150804.3667">def test_list_comp_node(self):
    source = '[i for i in range(1) if True]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('ListComp', 0, len(source) - 1)
    checker.check_children(
        'ListComp', ['[', '', 'Name', ' ', 'comprehension', '', ']'])
    checker.check_children(
        'comprehension', ['for', ' ', 'Name', ' ', 'in', ' ',
                          'Call', ' ', 'if', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3668">def test_list_comp_node_with_multiple_comprehensions(self):
    source = '[i for i in range(1) for j in range(1) if True]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('ListComp', 0, len(source) - 1)
    checker.check_children(
        'ListComp', ['[', '', 'Name', ' ', 'comprehension',
                     ' ', 'comprehension', '', ']'])
    checker.check_children(
        'comprehension', ['for', ' ', 'Name', ' ', 'in', ' ',
                          'Call', ' ', 'if', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3669">def test_simple_module_node(self):
    source = 'pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Module', 0, len(source))
    checker.check_children('Module', ['', 'Pass', '\n'])

</t>
<t tx="ekr.20080516150804.3670">def test_module_node(self):
    source = '"""docs"""\npass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Module', 0, len(source))
    checker.check_children('Module', ['', 'Expr', '\n', 'Pass', '\n'])
    checker.check_children('Str', ['"""docs"""'])

</t>
<t tx="ekr.20080516150804.3671">def test_not_and_or_nodes(self):
    source = 'not True or False\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Expr', ['BoolOp'])
    checker.check_children('BoolOp', ['UnaryOp', ' ', 'or', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3672">def test_print_node(self):
    source = 'print &gt;&gt;out, 1,\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Print', 0, len(source) - 1)
    checker.check_children('Print', ['print', ' ', '&gt;&gt;', '', 'Name', '',
                                     ',', ' ', 'Num', '', ','])

</t>
<t tx="ekr.20080516150804.3673">def test_printnl_node(self):
    source = 'print 1\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Print', 0, len(source) - 1)
    checker.check_children('Print', ['print', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3674">def test_raise_node(self):
    source = 'raise x, y, z\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_region('Raise', 0, len(source) - 1)
    checker.check_children(
        'Raise', ['raise', ' ', 'Name', '', ',', ' ', 'Name', '', ',',
                  ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3675">def test_return_node(self):
    source = 'def f():\n    return None\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Return', ['return', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3676">def test_empty_return_node(self):
    source = 'def f():\n    return\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Return', ['return'])

</t>
<t tx="ekr.20080516150804.3677">def test_simple_slice_node(self):
    source = 'a[1:2]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Subscript', ['Name', '', '[', '', 'Slice', '', ']'])
    checker.check_children(
        'Slice', ['Num', '', ':', '', 'Num'])

</t>
<t tx="ekr.20080516150804.3678">def test_slice_node2(self):
    source = 'a[:]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Subscript', ['Name', '', '[', '', 'Slice', '', ']'])
    checker.check_children('Slice', [':'])

</t>
<t tx="ekr.20080516150804.3679">def test_simple_subscript(self):
    source = 'a[1]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Subscript', ['Name', '', '[', '', 'Index', '', ']'])
    checker.check_children('Index', ['Num'])

</t>
<t tx="ekr.20080516150804.3680">def test_tuple_node(self):
    source = '(1, 2)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Tuple', ['(', '', 'Num', '', ',', ' ', 'Num', '', ')'])

</t>
<t tx="ekr.20080516150804.3681">def test_tuple_node2(self):
    source = '#(\n1, 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Tuple', ['Num', '', ',', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3682">def test_one_item_tuple_node(self):
    source = '(1,)\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Tuple', ['(', '', 'Num', ',', ')'])

</t>
<t tx="ekr.20080516150804.3683">def test_empty_tuple_node(self):
    source = '()\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Tuple', ['(', '', ')'])

</t>
<t tx="ekr.20080516150804.3684">def test_yield_node(self):
    source = 'def f():\n    yield None\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children('Yield', ['yield', ' ', 'Name'])

</t>
<t tx="ekr.20080516150804.3685">def test_while_node(self):
    source = 'while True:\n    pass\nelse:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'While', ['while', ' ', 'Name', '', ':', '\n    ', 'Pass', '\n',
                  'else', '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3686">@testutils.run_only_for_25
def test_with_node(self):
    source = 'from __future__ import with_statement\nwith a as b:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'With', ['with', ' ', 'Name', ' ', 'as', ' ', 'Name', '', ':',
                 '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3687">def test_try_finally_node(self):
    source = 'try:\n    pass\nfinally:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'TryFinally', ['try', '', ':', '\n    ', 'Pass', '\n', 'finally',
                       '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3688">def test_try_except_node(self):
    source = 'try:\n    pass\nexcept Exception, e:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'TryExcept', ['try', '', ':', '\n    ', 'Pass', '\n',
                      ('excepthandler', 'ExceptHandler')])
    checker.check_children(
        ('excepthandler', 'ExceptHandler'),
        ['except', ' ', 'Name', '', ',', ' ', 'Name', '', ':',
         '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3689">@testutils.run_only_for_25
def test_try_except_and_finally_node(self):
    source = 'try:\n    pass\nexcept:\n    pass\nfinally:\n    pass\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'TryFinally', ['TryExcept', '\n', 'finally',
                       '', ':', '\n    ', 'Pass'])

</t>
<t tx="ekr.20080516150804.3690">def test_ignoring_comments(self):
    source = '#1\n1\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    start = source.rindex('1')
    checker.check_region('Num', start, start + 1)

</t>
<t tx="ekr.20080516150804.3691">def test_simple_sliceobj(self):
    source = 'a[1::3]\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Slice', ['Num', '', ':', '', ':', '', 'Num'])

</t>
<t tx="ekr.20080516150804.3692">def test_ignoring_strings_that_start_with_a_char(self):
    source = 'r"""("""\n1\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Module', ['', 'Expr', '\n', 'Expr', '\n'])

</t>
<t tx="ekr.20080516150804.3693">def test_how_to_handle_old_not_equals(self):
    source = '1 &lt;&gt; 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Compare', ['Num', ' ', '&lt;&gt;', ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3694">def test_semicolon(self):
    source = '1;\n'
    ast = patchedast.get_patched_ast(source, True)

</t>
<t tx="ekr.20080516150804.3695">@testutils.run_only_for_25
def test_if_exp_node(self):
    source = '1 if True else 2\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'IfExp', ['Num', ' ', 'if', ' ', 'Name', ' ', 'else',
                  ' ', 'Num'])

</t>
<t tx="ekr.20080516150804.3696">def test_delete_node(self):
    source = 'del a, b\n'
    ast = patchedast.get_patched_ast(source, True)
    checker = _ResultChecker(self, ast)
    checker.check_children(
        'Delete', ['del', ' ', 'Name', '', ',', ' ', 'Name'])


</t>
<t tx="ekr.20080516150804.3697">class _ResultChecker(object):
    @others
</t>
<t tx="ekr.20080516150804.3698">
def __init__(self, test_case, ast):
    self.test_case = test_case
    self.ast = ast

</t>
<t tx="ekr.20080516150804.3699">def check_region(self, text, start, end):
    node = self._find_node(text)
    if node is None:
        self.test_case.fail('Node &lt;%s&gt; cannot be found' % text)
    self.test_case.assertEquals((start, end), node.region)

</t>
<t tx="ekr.20080516150804.3700">def _find_node(self, text):
    goal = text
    if not isinstance(text, (tuple, list)):
        goal = [text]
    class Search(object):
        result = None
        def __call__(self, node):
            for text in goal:
                if str(node).startswith(text):
                    self.result = node
                    break
                if node.__class__.__name__.startswith(text):
                    self.result = node
                    break
            return self.result is not None
    search = Search()
    ast.call_for_nodes(self.ast, search, recursive=True)
    return search.result

</t>
<t tx="ekr.20080516150804.3701">def check_children(self, text, children):
    node = self._find_node(text)
    if node is None:
        self.test_case.fail('Node &lt;%s&gt; cannot be found' % text)
    result = list(node.sorted_children)
    self.test_case.assertEquals(len(children), len(result))
    for expected, child in zip(children, result):
        goals = expected
        if not isinstance(expected, (tuple, list)):
            goals = [expected]
        for goal in goals:
            if goal == '' or isinstance(child, basestring):
                self.test_case.assertEquals(goal, child)
                break
        else:
            self.test_case.assertNotEquals(
                '', text, 'probably ignoring some node')
            self.test_case.assertTrue(
                child.__class__.__name__.startswith(expected),
                msg='Expected &lt;%s&gt; but was &lt;%s&gt;' %
                (expected, child.__class__.__name__))


</t>
<t tx="ekr.20080516150804.3702">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3703">import sys
import unittest

import rope.base.codeanalyze
import rope.refactor.occurrences
from rope.refactor import rename
from rope.refactor.rename import Rename
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3704">class RenameRefactoringTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3705">
def setUp(self):
    super(RenameRefactoringTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.3706">def tearDown(self):
    testutils.remove_project(self.project)
    super(RenameRefactoringTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3707">def _local_rename(self, source_code, offset, new_name):
    testmod = testutils.create_module(self.project, 'testmod')
    testmod.write(source_code)
    changes = Rename(self.project, testmod, offset).\
        get_changes(new_name, resources=[testmod])
    self.project.do(changes)
    return testmod.read()

</t>
<t tx="ekr.20080516150804.3708">def _rename(self, resource, offset, new_name, **kwds):
    changes = Rename(self.project, resource, offset).\
              get_changes(new_name, **kwds)
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3709">def test_simple_global_variable_renaming(self):
    refactored = self._local_rename('a_var = 20\n', 2, 'new_var')
    self.assertEquals('new_var = 20\n', refactored)

</t>
<t tx="ekr.20080516150804.3710">def test_variable_renaming_only_in_its_scope(self):
    refactored = self._local_rename(
        'a_var = 20\ndef a_func():\n    a_var = 10\n', 32, 'new_var')
    self.assertEquals('a_var = 20\ndef a_func():\n    new_var = 10\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3711">def test_not_renaming_dot_name(self):
    refactored = self._local_rename(
        "replace = True\n'aaa'.replace('a', 'b')\n", 1, 'new_var')
    self.assertEquals("new_var = True\n'aaa'.replace('a', 'b')\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3712">def test_renaming_multiple_names_in_the_same_line(self):
    refactored = self._local_rename(
        'a_var = 10\na_var = 10 + a_var / 2\n', 2, 'new_var')
    self.assertEquals('new_var = 10\nnew_var = 10 + new_var / 2\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3713">def test_renaming_names_when_getting_some_attribute(self):
    refactored = self._local_rename(
        "a_var = 'a b c'\na_var.split('\\n')\n", 2, 'new_var')
    self.assertEquals("new_var = 'a b c'\nnew_var.split('\\n')\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3714">def test_renaming_names_when_getting_some_attribute2(self):
    refactored = self._local_rename(
        "a_var = 'a b c'\na_var.split('\\n')\n", 20, 'new_var')
    self.assertEquals("new_var = 'a b c'\nnew_var.split('\\n')\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3715">def test_renaming_function_parameters1(self):
    refactored = self._local_rename(
        "def f(a_param):\n    print(a_param)\n", 8, 'new_param')
    self.assertEquals("def f(new_param):\n    print(new_param)\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3716">def test_renaming_function_parameters2(self):
    refactored = self._local_rename(
        "def f(a_param):\n    print(a_param)\n", 30, 'new_param')
    self.assertEquals("def f(new_param):\n    print(new_param)\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3717">def test_renaming_occurrences_inside_functions(self):
    code = 'def a_func(p1):\n    a = p1\na_func(1)\n'
    refactored = self._local_rename(code, code.index('p1') + 1, 'new_param')
    self.assertEquals(
        'def a_func(new_param):\n    a = new_param\na_func(1)\n', 
        refactored)

</t>
<t tx="ekr.20080516150804.3718">def test_renaming_arguments_for_normal_args_changing_calls(self):
    code = 'def a_func(p1=None, p2=None):\n    pass\na_func(p2=1)\n'
    refactored = self._local_rename(code, code.index('p2') + 1, 'p3')
    self.assertEquals(
        'def a_func(p1=None, p3=None):\n    pass\na_func(p3=1)\n',
        refactored)

</t>
<t tx="ekr.20080516150804.3719">def test_renaming_function_parameters_of_class_init(self):
    code = 'class A(object):\n    def __init__(self, a_param):\n        pass\n' \
           'a_var = A(a_param=1)\n'
    refactored = self._local_rename(code, code.index('a_param') + 1, 'new_param')
    expected = 'class A(object):\n    def __init__(self, new_param):\n        pass\n' \
               'a_var = A(new_param=1)\n'
    self.assertEquals(expected, refactored)

</t>
<t tx="ekr.20080516150804.3720">def test_renaming_functions_parameters_and_occurances_in_other_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('def a_func(a_param):\n    print(a_param)\n')
    mod2.write('from mod1 import a_func\na_func(a_param=10)\n')
    self._rename(mod1, mod1.read().index('a_param') + 1, 'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n',
                      mod1.read())
    self.assertEquals('from mod1 import a_func\na_func(new_param=10)\n',
                      mod2.read())

</t>
<t tx="ekr.20080516150804.3721">def test_renaming_with_backslash_continued_names(self):
    refactored = self._local_rename(
        "replace = True\n'ali'.\\\nreplace\n", 2, 'is_replace')
    self.assertEquals("is_replace = True\n'ali'.\\\nreplace\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3722">def test_not_renaming_string_contents(self):
    refactored = self._local_rename("a_var = 20\na_string='a_var'\n",
                                    2, 'new_var')
    self.assertEquals("new_var = 20\na_string='a_var'\n",
                      refactored)

</t>
<t tx="ekr.20080516150804.3723">def test_not_renaming_comment_contents(self):
    refactored = self._local_rename("a_var = 20\n# a_var\n",
                                    2, 'new_var')
    self.assertEquals("new_var = 20\n# a_var\n", refactored)

</t>
<t tx="ekr.20080516150804.3724">def test_renaming_all_occurances_in_containing_scope(self):
    code = 'if True:\n    a_var = 1\nelse:\n    a_var = 20\n'
    refactored = self._local_rename(code, 16, 'new_var')
    self.assertEquals(
        'if True:\n    new_var = 1\nelse:\n    new_var = 20\n', refactored)

</t>
<t tx="ekr.20080516150804.3725">def test_renaming_a_variable_with_arguement_name(self):
    code = 'a_var = 10\ndef a_func(a_var):\n    print(a_var)\n'
    refactored = self._local_rename(code, 1, 'new_var')
    self.assertEquals(
        'new_var = 10\ndef a_func(a_var):\n    print(a_var)\n', refactored)

</t>
<t tx="ekr.20080516150804.3726">def test_renaming_an_arguement_with_variable_name(self):
    code = 'a_var = 10\ndef a_func(a_var):\n    print(a_var)\n'
    refactored = self._local_rename(code, len(code) - 3, 'new_var')
    self.assertEquals(
        'a_var = 10\ndef a_func(new_var):\n    print(new_var)\n',
        refactored)

</t>
<t tx="ekr.20080516150804.3727">def test_renaming_function_with_local_variable_name(self):
    code = 'def a_func():\n    a_func=20\na_func()'
    refactored = self._local_rename(code, len(code) - 3, 'new_func')
    self.assertEquals('def new_func():\n    a_func=20\nnew_func()',
                      refactored)

</t>
<t tx="ekr.20080516150804.3728">def test_renaming_functions(self):
    code = 'def a_func():\n    pass\na_func()\n'
    refactored = self._local_rename(code, len(code) - 5, 'new_func')
    self.assertEquals('def new_func():\n    pass\nnew_func()\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3729">def test_renaming_functions_across_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\na_func()\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('import mod1\nmod1.a_func()\n')
    self._rename(mod1, len(mod1.read()) - 5, 'new_func')
    self.assertEquals('def new_func():\n    pass\nnew_func()\n',
                      mod1.read())
    self.assertEquals('import mod1\nmod1.new_func()\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3730">def test_renaming_functions_across_modules_from_import(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\na_func()\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('from mod1 import a_func\na_func()\n')
    self._rename(mod1, len(mod1.read()) - 5, 'new_func')
    self.assertEquals('def new_func():\n    pass\nnew_func()\n',
                      mod1.read())
    self.assertEquals('from mod1 import new_func\nnew_func()\n',
                      mod2.read())

</t>
<t tx="ekr.20080516150804.3731">def test_renaming_functions_from_another_module(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\na_func()\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('import mod1\nmod1.a_func()\n')
    self._rename(mod2, len(mod2.read()) - 5, 'new_func')
    self.assertEquals('def new_func():\n    pass\nnew_func()\n',
                      mod1.read())
    self.assertEquals('import mod1\nmod1.new_func()\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3732">def test_applying_all_changes_together(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod2\nmod2.a_func()\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('def a_func():\n    pass\na_func()\n')
    self._rename(mod2, len(mod2.read()) - 5, 'new_func')
    self.assertEquals('import mod2\nmod2.new_func()\n', mod1.read())
    self.assertEquals('def new_func():\n    pass\nnew_func()\n',
                      mod2.read())

</t>
<t tx="ekr.20080516150804.3733">def test_renaming_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('from mod1 import a_func\n')
    self._rename(mod2, mod2.read().index('mod1') + 1, 'newmod')
    self.assertTrue(not mod1.exists() and
                    self.pycore.find_module('newmod') is not None)
    self.assertEquals('from newmod import a_func\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3734">def test_renaming_packages(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod1.write('def a_func():\n    pass\n')
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('from pkg.mod1 import a_func\n')
    self._rename(mod2, 6, 'newpkg')
    self.assertTrue(self.pycore.find_module('newpkg.mod1') is not None)
    new_mod2 = self.pycore.find_module('newpkg.mod2')
    self.assertEquals('from newpkg.mod1 import a_func\n', new_mod2.read())

</t>
<t tx="ekr.20080516150804.3735">def test_module_dependencies(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class AClass(object):\n    pass\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('import mod1\na_var = mod1.AClass()\n')
    self.pycore.resource_to_pyobject(mod2).get_attributes()['mod1']
    mod1.write('def AClass():\n    return 0\n')

    self._rename(mod2, len(mod2.read()) - 3, 'a_func')
    self.assertEquals('def a_func():\n    return 0\n', mod1.read())
    self.assertEquals('import mod1\na_var = mod1.a_func()\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3736">def test_renaming_class_attributes(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class AClass(object):\n    def __init__(self):\n'
               '        self.an_attr = 10\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('import mod1\na_var = mod1.AClass()\n'
               'another_var = a_var.an_attr')

    self._rename(mod1, mod1.read().index('an_attr'), 'attr')
    self.assertEquals('class AClass(object):\n    def __init__(self):\n'
                      '        self.attr = 10\n', mod1.read())
    self.assertEquals(
        'import mod1\na_var = mod1.AClass()\nanother_var = a_var.attr',
        mod2.read())

</t>
<t tx="ekr.20080516150804.3737">def test_renaming_class_attributes2(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('class AClass(object):\n    def __init__(self):\n'
               '        an_attr = 10\n        self.an_attr = 10\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('import mod1\na_var = mod1.AClass()\n'
               'another_var = a_var.an_attr')

    self._rename(mod1, mod1.read().rindex('an_attr'), 'attr')
    self.assertEquals(
        'class AClass(object):\n    def __init__(self):\n'
        '        an_attr = 10\n        self.attr = 10\n', mod1.read())
    self.assertEquals(
        'import mod1\na_var = mod1.AClass()\nanother_var = a_var.attr',
        mod2.read())

</t>
<t tx="ekr.20080516150804.3738">def test_renaming_methods_in_subclasses(self):
    mod = testutils.create_module(self.project, 'mod1')
    mod.write('class A(object):\n    def a_method(self):\n        pass\n'
              'class B(A):\n    def a_method(self):\n        pass\n')

    self._rename(mod, mod.read().rindex('a_method') + 1, 'new_method',
                 in_hierarchy=True)
    self.assertEquals(
        'class A(object):\n    def new_method(self):\n        pass\n'
        'class B(A):\n    def new_method(self):\n        pass\n', mod.read())

</t>
<t tx="ekr.20080516150804.3739">def test_renaming_methods_in_sibling_classes(self):
    mod = testutils.create_module(self.project, 'mod1')
    mod.write('class A(object):\n    def a_method(self):\n        pass\n'
              'class B(A):\n    def a_method(self):\n        pass\n'
              'class C(A):\n    def a_method(self):\n        pass\n')

    self._rename(mod, mod.read().rindex('a_method') + 1, 'new_method',
                 in_hierarchy=True)
    self.assertEquals(
        'class A(object):\n    def new_method(self):\n        pass\n'
        'class B(A):\n    def new_method(self):\n        pass\n'
        'class C(A):\n    def new_method(self):\n        pass\n', mod.read())

</t>
<t tx="ekr.20080516150804.3740">def test_not_renaming_methods_in_hierarchies(self):
    mod = testutils.create_module(self.project, 'mod1')
    mod.write('class A(object):\n    def a_method(self):\n        pass\n'
              'class B(A):\n    def a_method(self):\n        pass\n')

    self._rename(mod, mod.read().rindex('a_method') + 1, 'new_method',
                 in_hierarchy=False)
    self.assertEquals(
        'class A(object):\n    def a_method(self):\n        pass\n'
        'class B(A):\n    def new_method(self):\n        pass\n', mod.read())

</t>
<t tx="ekr.20080516150804.3741">def test_undoing_refactorings(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\na_func()\n')
    self._rename(mod1, len(mod1.read()) - 5, 'new_func')
    self.project.history.undo()
    self.assertEquals('def a_func():\n    pass\na_func()\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3742">def test_undoing_renaming_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('def a_func():\n    pass\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('from mod1 import a_func\n')
    self._rename(mod2, 6, 'newmod')
    self.project.history.undo()
    self.assertEquals('mod1.py', mod1.path)
    self.assertEquals('from mod1 import a_func\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3743">def test_rename_in_module_renaming_one_letter_names_for_expressions(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('a = 10\nprint(1+a)\n')
    pymod = self.pycore.get_module('mod1')
    old_pyname = pymod['a']
    finder = rope.refactor.occurrences.create_finder(
        self.pycore, 'a', old_pyname)
    refactored = rename.rename_in_module(
        finder, 'new_var', pymodule=pymod, replace_primary=True)
    self.assertEquals('new_var = 10\nprint(1+new_var)\n', refactored)

</t>
<t tx="ekr.20080516150804.3744">def test_renaming_for_loop_variable(self):
    code = 'for var in range(10):\n    print(var)\n'
    refactored = self._local_rename(code, code.find('var') + 1, 'new_var')
    self.assertEquals('for new_var in range(10):\n    print(new_var)\n',
                      refactored)

</t>
<t tx="ekr.20080516150804.3745">def test_renaming_parameters(self):
    code = 'def a_func(param):\n    print(param)\na_func(param=hey)\n'
    refactored = self._local_rename(code, code.find('param') + 1,
                                    'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'a_func(new_param=hey)\n', refactored)

</t>
<t tx="ekr.20080516150804.3746">def test_renaming_assigned_parameters(self):
    code = 'def f(p):\n    p = p + 1\n    return p\nf(p=1)\n'
    refactored = self._local_rename(code, code.find('p'), 'arg')
    self.assertEquals('def f(arg):\n    arg = arg + 1\n'
                      '    return arg\nf(arg=1)\n', refactored)

</t>
<t tx="ekr.20080516150804.3747">def test_renaming_parameters_not_renaming_others(self):
    code = 'def a_func(param):\n    print(param)\nparam=10\na_func(param)\n'
    refactored = self._local_rename(code, code.find('param') + 1, 'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'param=10\na_func(param)\n', refactored)

</t>
<t tx="ekr.20080516150804.3748">def test_renaming_parameters_not_renaming_others2(self):
    code = 'def a_func(param):\n    print(param)\nparam=10\na_func(param=param)'
    refactored = self._local_rename(code, code.find('param') + 1, 'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'param=10\na_func(new_param=param)', refactored)

</t>
<t tx="ekr.20080516150804.3749">def test_renaming_parameters_with_multiple_params(self):
    code = 'def a_func(param1, param2):\n    print(param1)\n'\
           'a_func(param1=1, param2=2)\n'
    refactored = self._local_rename(code, code.find('param1') + 1, 'new_param')
    self.assertEquals(
        'def a_func(new_param, param2):\n    print(new_param)\n'
        'a_func(new_param=1, param2=2)\n', refactored)

</t>
<t tx="ekr.20080516150804.3750">def test_renaming_parameters_with_multiple_params2(self):
    code = 'def a_func(param1, param2):\n    print(param1)\n' \
           'a_func(param1=1, param2=2)\n'
    refactored = self._local_rename(code, code.rfind('param2') + 1,
                                    'new_param')
    self.assertEquals('def a_func(param1, new_param):\n    print(param1)\n'
                      'a_func(param1=1, new_param=2)\n', refactored)

</t>
<t tx="ekr.20080516150804.3751">def test_renaming_parameters_on_calls(self):
    code = 'def a_func(param):\n    print(param)\na_func(param = hey)\n'
    refactored = self._local_rename(code, code.rfind('param') + 1,
                                    'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'a_func(new_param = hey)\n', refactored)

</t>
<t tx="ekr.20080516150804.3752">def test_renaming_parameters_spaces_before_call(self):
    code = 'def a_func(param):\n    print(param)\na_func  (param=hey)\n'
    refactored = self._local_rename(code, code.rfind('param') + 1,
                                    'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'a_func  (new_param=hey)\n', refactored)

</t>
<t tx="ekr.20080516150804.3753">def test_renaming_parameter_like_objects_after_keywords(self):
    code = 'def a_func(param):\n    print(param)\ndict(param=hey)\n'
    refactored = self._local_rename(code, code.find('param') + 1, 'new_param')
    self.assertEquals('def a_func(new_param):\n    print(new_param)\n'
                      'dict(param=hey)\n', refactored)

</t>
<t tx="ekr.20080516150804.3754">def test_renaming_variables_in_init_dot_pys(self):
    pkg = testutils.create_package(self.project, 'pkg')
    init_dot_py = pkg.get_child('__init__.py')
    init_dot_py.write('a_var = 10\n')
    mod = testutils.create_module(self.project, 'mod')
    mod.write('import pkg\nprint(pkg.a_var)\n')
    self._rename(mod, mod.read().index('a_var') + 1, 'new_var')
    self.assertEquals('new_var = 10\n', init_dot_py.read())
    self.assertEquals('import pkg\nprint(pkg.new_var)\n', mod.read())

</t>
<t tx="ekr.20080516150804.3755">def test_renaming_variables_in_init_dot_pys2(self):
    pkg = testutils.create_package(self.project, 'pkg')
    init_dot_py = pkg.get_child('__init__.py')
    init_dot_py.write('a_var = 10\n')
    mod = testutils.create_module(self.project, 'mod')
    mod.write('import pkg\nprint(pkg.a_var)\n')
    self._rename(init_dot_py,
                 init_dot_py.read().index('a_var') + 1, 'new_var')
    self.assertEquals('new_var = 10\n', init_dot_py.read())
    self.assertEquals('import pkg\nprint(pkg.new_var)\n', mod.read())

</t>
<t tx="ekr.20080516150804.3756">def test_renaming_variables_in_init_dot_pys3(self):
    pkg = testutils.create_package(self.project, 'pkg')
    init_dot_py = pkg.get_child('__init__.py')
    init_dot_py.write('a_var = 10\n')
    mod = testutils.create_module(self.project, 'mod')
    mod.write('import pkg\nprint(pkg.a_var)\n')
    self._rename(mod, mod.read().index('a_var') + 1, 'new_var')
    self.assertEquals('new_var = 10\n', init_dot_py.read())
    self.assertEquals('import pkg\nprint(pkg.new_var)\n', mod.read())

</t>
<t tx="ekr.20080516150804.3757">def test_renaming_resources_using_rename_module_refactoring(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('a_var = 1')
    mod2.write('import mod1\nmy_var = mod1.a_var\n')
    renamer = rename.Rename(self.project, mod1)
    renamer.get_changes('newmod').do()
    self.assertEquals('import newmod\nmy_var = newmod.a_var\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3758">def test_renaming_resources_using_rename_module_refactoring_for_packages(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    pkg = testutils.create_package(self.project, 'pkg')
    mod1.write('import pkg\nmy_pkg = pkg')
    renamer = rename.Rename(self.project, pkg)
    renamer.get_changes('newpkg').do()
    self.assertEquals('import newpkg\nmy_pkg = newpkg', mod1.read())

</t>
<t tx="ekr.20080516150804.3759">def test_renaming_resources_using_rename_module_refactoring_for_init_dot_py(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    pkg = testutils.create_package(self.project, 'pkg')
    mod1.write('import pkg\nmy_pkg = pkg')
    renamer = rename.Rename(self.project, pkg.get_child('__init__.py'))
    renamer.get_changes('newpkg').do()
    self.assertEquals('import newpkg\nmy_pkg = newpkg', mod1.read())

</t>
<t tx="ekr.20080516150804.3760">def test_renaming_global_variables(self):
    code = 'a_var = 1\ndef a_func():\n    global a_var\n    var = a_var\n'
    refactored = self._local_rename(code, code.index('a_var'), 'new_var')
    self.assertEquals(
        'new_var = 1\ndef a_func():\n    global new_var\n    var = new_var\n',
        refactored)

</t>
<t tx="ekr.20080516150804.3761">def test_renaming_global_variables2(self):
    code = 'a_var = 1\ndef a_func():\n    global a_var\n    var = a_var\n'
    refactored = self._local_rename(code, code.rindex('a_var'), 'new_var')
    self.assertEquals(
        'new_var = 1\ndef a_func():\n    global new_var\n    var = new_var\n',
        refactored)

</t>
<t tx="ekr.20080516150804.3762">def test_renaming_when_unsure(self):
    code = 'class C(object):\n    def a_func(self):\n        pass\n' \
           'def f(arg):\n    arg.a_func()\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_func'),
                 'new_func', unsure=self._true)
    self.assertEquals(
        'class C(object):\n    def new_func(self):\n        pass\n' \
        'def f(arg):\n    arg.new_func()\n',
        mod1.read())

</t>
<t tx="ekr.20080516150804.3763">def _true(self, *args):
    return True

</t>
<t tx="ekr.20080516150804.3764">def test_renaming_when_unsure_with_confirmation(self):
    def confirm(occurrence):
        return False
    code = 'class C(object):\n    def a_func(self):\n        pass\n' \
           'def f(arg):\n    arg.a_func()\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_func'), 'new_func', unsure=confirm)
    self.assertEquals(
        'class C(object):\n    def new_func(self):\n        pass\n' \
        'def f(arg):\n    arg.a_func()\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3765">def test_renaming_when_unsure_not_renaming_knowns(self):
    code = 'class C1(object):\n    def a_func(self):\n        pass\n' \
           'class C2(object):\n    def a_func(self):\n        pass\n' \
           'c1 = C1()\nc1.a_func()\nc2 = C2()\nc2.a_func()\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_func'), 'new_func', unsure=self._true)
    self.assertEquals(
        'class C1(object):\n    def new_func(self):\n        pass\n' \
        'class C2(object):\n    def a_func(self):\n        pass\n' \
        'c1 = C1()\nc1.new_func()\nc2 = C2()\nc2.a_func()\n',
        mod1.read())

</t>
<t tx="ekr.20080516150804.3766">def test_renaming_in_strings_and_comments(self):
    code = 'a_var = 1\n# a_var\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_var'), 'new_var', docs=True)
    self.assertEquals('new_var = 1\n# new_var\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3767">def test_not_renaming_in_strings_and_comments_where_not_visible(self):
    code = 'def f():\n    a_var = 1\n# a_var\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_var'), 'new_var', docs=True)
    self.assertEquals('def f():\n    new_var = 1\n# a_var\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3768">def test_not_renaming_all_text_occurrences_in_strings_and_comments(self):
    code = 'a_var = 1\n# a_vard _a_var\n'
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.index('a_var'), 'new_var', docs=True)
    self.assertEquals('new_var = 1\n# a_vard _a_var\n', mod1.read())

</t>
<t tx="ekr.20080516150804.3769">def test_renaming_occurrences_in_overwritten_scopes(self):
    refactored = self._local_rename(
        'a_var = 20\ndef f():\n    print(a_var)\n'
        'def f():\n    print(a_var)\n', 2, 'new_var')
    self.assertEquals('new_var = 20\ndef f():\n    print(new_var)\n'
                      'def f():\n    print(new_var)\n', refactored)

</t>
<t tx="ekr.20080516150804.3770">def test_renaming_occurrences_in_overwritten_scopes2(self):
    code = 'def f():\n    a_var = 1\n    print(a_var)\n' \
           'def f():\n    a_var = 1\n    print(a_var)\n'
    refactored = self._local_rename(code, code.index('a_var') + 1, 'new_var')
    self.assertEquals(code.replace('a_var', 'new_var', 2), refactored)

</t>
<t tx="ekr.20080516150804.3771">def test_dos_line_ending_and_renaming(self):
    code = '\r\na = 1\r\n\r\nprint(2 + a + 2)\r\n'
    offset = code.replace('\r\n', '\n').rindex('a')
    refactored = self._local_rename(code, offset, 'b')
    self.assertEquals('\nb = 1\n\nprint(2 + b + 2)\n',
                      refactored.replace('\r\n', '\n'))

</t>
<t tx="ekr.20080516150804.3772">def test_multi_byte_strs_and_renaming(self):
    s = u'{LATIN SMALL LETTER I WITH DIAERESIS}' * 4
    code = u'# -*- coding: utf-8 -*-\n# ' + s + \
            '\na = 1\nprint(2 + a + 2)\n'
    refactored = self._local_rename(code, code.rindex('a'), 'b')
    self.assertEquals(u'# -*- coding: utf-8 -*-\n# ' + s +
                      '\nb = 1\nprint(2 + b + 2)\n', refactored)

</t>
<t tx="ekr.20080516150804.3773">def test_resources_parameter(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('def f():\n    pass\n')
    mod2.write('import mod1\nmod1.f()\n')
    self._rename(mod1, mod1.read().rindex('f'), 'g',
                 resources=[mod1])
    self.assertEquals('def g():\n    pass\n', mod1.read())
    self.assertEquals('import mod1\nmod1.f()\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3774">def test_resources_parameter_not_changing_defining_module(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('def f():\n    pass\n')
    mod2.write('import mod1\nmod1.f()\n')
    self._rename(mod1, mod1.read().rindex('f'), 'g',
                 resources=[mod2])
    self.assertEquals('def f():\n    pass\n', mod1.read())
    self.assertEquals('import mod1\nmod1.g()\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3775"># XXX: with variables should not leak
@testutils.only_for('2.5')
def xxx_test_with_statement_variables_should_not_leak(self):
    code = 'f = 1\nwith open("1.txt") as f:\n    print(f)\n'
    if sys.version_info &lt; (2, 6, 0):
        code = 'from __future__ import with_statement\n' + code
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write(code)
    self._rename(mod1, code.rindex('f'), 'file')
    expected = 'f = 1\nwith open("1.txt") as file:\n    print(file)\n'
    self.assertEquals(expected, mod1.read())


</t>
<t tx="ekr.20080516150804.3776">class ChangeOccurrencesTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3777">
def setUp(self):
    self.project = testutils.sample_project()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3778">def tearDown(self):
    testutils.remove_project(self.project)
    super(ChangeOccurrencesTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3779">def test_simple_case(self):
    self.mod.write('a_var = 1\nprint(a_var)\n')
    changer = rename.ChangeOccurrences(self.project, self.mod,
                                       self.mod.read().index('a_var'))
    changer.get_changes('new_var').do()
    self.assertEquals('new_var = 1\nprint(new_var)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3780">def test_only_performing_inside_scopes(self):
    self.mod.write('a_var = 1\nnew_var = 2\ndef f():\n    print(a_var)\n')
    changer = rename.ChangeOccurrences(self.project, self.mod,
                                       self.mod.read().rindex('a_var'))
    changer.get_changes('new_var').do()
    self.assertEquals(
        'a_var = 1\nnew_var = 2\ndef f():\n    print(new_var)\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3781">def test_only_performing_on_calls(self):
    self.mod.write('def f1():\n    pass\ndef f2():\n    pass\n'
                   'g = f1\na = f1()\n')
    changer = rename.ChangeOccurrences(self.project, self.mod,
                                       self.mod.read().rindex('f1'))
    changer.get_changes('f2', only_calls=True).do()
    self.assertEquals(
        'def f1():\n    pass\ndef f2():\n    pass\ng = f1\na = f2()\n',
        self.mod.read())

</t>
<t tx="ekr.20080516150804.3782">def test_only_performing_on_reads(self):
    self.mod.write('a = 1\nb = 2\nprint(a)\n')
    changer = rename.ChangeOccurrences(self.project, self.mod,
                                       self.mod.read().rindex('a'))
    changer.get_changes('b', writes=False).do()
    self.assertEquals('a = 1\nb = 2\nprint(b)\n', self.mod.read())


</t>
<t tx="ekr.20080516150804.3783">class ImplicitInterfacesTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3784">
def setUp(self):
    super(ImplicitInterfacesTest, self).setUp()
    self.project = testutils.sample_project(validate_objectdb=True)
    self.pycore = self.project.get_pycore()
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.mod2 = testutils.create_module(self.project, 'mod2')

</t>
<t tx="ekr.20080516150804.3785">def tearDown(self):
    testutils.remove_project(self.project)
    super(ImplicitInterfacesTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3786">def _rename(self, resource, offset, new_name, **kwds):
    changes = Rename(self.project, resource, offset).\
              get_changes(new_name, **kwds)
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3787">def test_performing_rename_on_parameters(self):
    self.mod1.write('def f(arg):\n    arg.run()\n')
    self.mod2.write('import mod1\n\n\n'
                    'class A(object):\n    def run(self):\n        pass\n'
                    'class B(object):\n    def run(self):\n        pass\n'
                    'mod1.f(A())\nmod1.f(B())\n')
    self.pycore.analyze_module(self.mod2)
    self._rename(self.mod1, self.mod1.read().index('run'), 'newrun')
    self.assertEquals('def f(arg):\n    arg.newrun()\n', self.mod1.read())
    self.assertEquals(
        'import mod1\n\n\n'
        'class A(object):\n    def newrun(self):\n        pass\n'
        'class B(object):\n    def newrun(self):\n        pass\n'
        'mod1.f(A())\nmod1.f(B())\n', self.mod2.read())


</t>
<t tx="ekr.20080516150804.3788">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(RenameRefactoringTest))
    result.addTests(unittest.makeSuite(ChangeOccurrencesTest))
    result.addTests(unittest.makeSuite(ImplicitInterfacesTest))
    return result


</t>
<t tx="ekr.20080516150804.3789">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3790">from rope.refactor import restructure
from ropetest import testutils

import unittest


</t>
<t tx="ekr.20080516150804.3791">class RestructureTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3792">
def setUp(self):
    super(RestructureTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3793">def tearDown(self):
    testutils.remove_project(self.project)
    super(RestructureTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3794">def test_trivial_case(self):
    refactoring = restructure.Restructure(self.project,
                                          'a = 1', 'a = 0')
    self.mod.write('b = 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('b = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3795">def test_replacing_simple_patterns(self):
    refactoring = restructure.Restructure(self.project,
                                          'a = 1', 'a = int(1)')
    self.mod.write('a = 1\nb = 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = int(1)\nb = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3796">def test_replacing_patterns_with_normal_names(self):
    refactoring = restructure.Restructure(
        self.project, '${a} = 1', '${a} = int(1)', args={'a': 'exact'})
    self.mod.write('a = 1\nb = 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = int(1)\nb = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3797">def test_replacing_patterns_with_any_names(self):
    refactoring = restructure.Restructure(self.project,
                                          '${a} = 1', '${a} = int(1)')
    self.mod.write('a = 1\nb = 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = int(1)\nb = int(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3798">def test_replacing_patterns_with_any_names2(self):
    refactoring = restructure.Restructure(
        self.project, '${x} + ${x}', '${x} * 2')
    self.mod.write('a = 1 + 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 1 * 2\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3799">def test_replacing_patterns_with_checks(self):
    self.mod.write('def f(p=1):\n    return p\ng = f\ng()\n')
    refactoring = restructure.Restructure(
        self.project, '${f}()', '${f}(2)', args={'f': 'object=mod.f'})
    self.project.do(refactoring.get_changes())
    self.assertEquals('def f(p=1):\n    return p\ng = f\ng(2)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3800">def test_replacing_assignments_with_sets(self):
    refactoring = restructure.Restructure(
        self.project, '${a} = ${b}', '${a}.set(${b})')
    self.mod.write('a = 1\nb = 1\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a.set(1)\nb.set(1)\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3801">def test_replacing_sets_with_assignments(self):
    refactoring = restructure.Restructure(
        self.project, '${a}.set(${b})', '${a} = ${b}')
    self.mod.write('a.set(1)\nb.set(1)\n')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 1\nb = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3802">def test_using_make_checks(self):
    self.mod.write('def f(p=1):\n    return p\ng = f\ng()\n')
    refactoring = restructure.Restructure(
        self.project, '${f}()', '${f}(2)', args={'f': 'object=mod.f'})
    self.project.do(refactoring.get_changes())
    self.assertEquals('def f(p=1):\n    return p\ng = f\ng(2)\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3803">def test_using_make_checking_builtin_types(self):
    self.mod.write('a = 1 + 1\n')
    refactoring = restructure.Restructure(
        self.project, '${i} + ${i}', '${i} * 2',
        args={'i': 'type=__builtin__.int'})
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 1 * 2\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3804">def test_auto_indentation_when_no_indentation(self):
    self.mod.write('a = 2\n')
    refactoring = restructure.Restructure(
        self.project, '${a} = 2', '${a} = 1\n${a} += 1')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 1\na += 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3805">def test_auto_indentation(self):
    self.mod.write('def f():\n    a = 2\n')
    refactoring = restructure.Restructure(
        self.project, '${a} = 2', '${a} = 1\n${a} += 1')
    self.project.do(refactoring.get_changes())
    self.assertEquals('def f():\n    a = 1\n    a += 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3806">def test_auto_indentation_and_not_indenting_blanks(self):
    self.mod.write('def f():\n    a = 2\n')
    refactoring = restructure.Restructure(
        self.project, '${a} = 2', '${a} = 1\n\n${a} += 1')
    self.project.do(refactoring.get_changes())
    self.assertEquals('def f():\n    a = 1\n\n    a += 1\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3807">def test_importing_names(self):
    self.mod.write('a = 2\n')
    refactoring = restructure.Restructure(
        self.project, '${a} = 2', '${a} = myconsts.two',
        imports=['import myconsts'])
    self.project.do(refactoring.get_changes())
    self.assertEquals('import myconsts\na = myconsts.two\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3808">def test_not_importing_names_when_there_are_no_changes(self):
    self.mod.write('a = True\n')
    refactoring = restructure.Restructure(
        self.project, '${a} = 2', '${a} = myconsts.two',
        imports=['import myconsts'])
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = True\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3809">def test_handling_containing_matches(self):
    self.mod.write('a = 1 / 2 / 3\n')
    refactoring = restructure.Restructure(
        self.project, '${a} / ${b}', '${a} // ${b}')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 1 // 2 // 3\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3810">def test_handling_overlapping_matches(self):
    self.mod.write('a = 1\na = 1\na = 1\n')
    refactoring = restructure.Restructure(
        self.project, 'a = 1\na = 1\n', 'b = 1')
    self.project.do(refactoring.get_changes())
    self.assertEquals('b = 1\na = 1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3811">def test_preventing_stack_overflow_when_matching(self):
    self.mod.write('1\n')
    refactoring = restructure.Restructure(self.project, '${a}', '${a}')
    self.project.do(refactoring.get_changes())
    self.assertEquals('1\n', self.mod.read())

</t>
<t tx="ekr.20080516150804.3812">def test_performing_a_restructuring_to_all_modules(self):
    mod2 = testutils.create_module(self.project, 'mod2')
    self.mod.write('a = 1\n')
    mod2.write('b = 1\n')
    refactoring = restructure.Restructure(self.project, '1', '2 / 1')
    self.project.do(refactoring.get_changes())
    self.assertEquals('a = 2 / 1\n', self.mod.read())
    self.assertEquals('b = 2 / 1\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3813">def test_performing_a_restructuring_to_selected_modules(self):
    mod2 = testutils.create_module(self.project, 'mod2')
    self.mod.write('a = 1\n')
    mod2.write('b = 1\n')
    refactoring = restructure.Restructure(self.project, '1', '2 / 1')
    self.project.do(refactoring.get_changes(resources=[mod2]))
    self.assertEquals('a = 1\n', self.mod.read())
    self.assertEquals('b = 2 / 1\n', mod2.read())

</t>
<t tx="ekr.20080516150804.3814">def test_unsure_argument_of_default_wildcard(self):
    self.mod.write('def f(p):\n    return p * 2\nx = "" * 2\ni = 1 * 2\n')
    refactoring = restructure.Restructure(
        self.project, '${s} * 2', 'dup(${s})',
        args={'s': {'type': '__builtins__.str','unsure': True}})
    self.project.do(refactoring.get_changes())
    self.assertEquals('def f(p):\n    return dup(p)\nx = dup("")\n'
                      'i = 1 * 2\n', self.mod.read())


</t>
<t tx="ekr.20080516150804.3815">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3816">import unittest

from rope.refactor import similarfinder
from ropetest import testutils


</t>
<t tx="ekr.20080516150804.3817">class SimilarFinderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3818">
def setUp(self):
    super(SimilarFinderTest, self).setUp()
    self.project = testutils.sample_project()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3819">def tearDown(self):
    testutils.remove_project(self.project)
    super(SimilarFinderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3820">def _create_finder(self, source, **kwds):
    self.mod.write(source)
    pymodule = self.project.pycore.resource_to_pyobject(self.mod)
    return similarfinder.SimilarFinder(pymodule, **kwds)

</t>
<t tx="ekr.20080516150804.3821">def test_trivial_case(self):
    finder = self._create_finder('')
    self.assertEquals([], list(finder.get_match_regions('10')))

</t>
<t tx="ekr.20080516150804.3822">def test_constant_integer(self):
    source = 'a = 10\n'
    finder = self._create_finder(source)
    result = [(source.index('10'), source.index('10') + 2)]
    self.assertEquals(result, list(finder.get_match_regions('10')))

</t>
<t tx="ekr.20080516150804.3823">def test_simple_addition(self):
    source = 'a = 1 + 2\n'
    finder = self._create_finder(source)
    result = [(source.index('1'), source.index('2') + 1)]
    self.assertEquals(result, list(finder.get_match_regions('1 + 2')))

</t>
<t tx="ekr.20080516150804.3824">def test_simple_addition2(self):
    source = 'a = 1 +2\n'
    finder = self._create_finder(source)
    result = [(source.index('1'), source.index('2') + 1)]
    self.assertEquals(result, list(finder.get_match_regions('1 + 2')))

</t>
<t tx="ekr.20080516150804.3825">def test_simple_assign_statements(self):
    source = 'a = 1 + 2\n'
    finder = self._create_finder(source)
    self.assertEquals([(0, len(source) - 1)],
                      list(finder.get_match_regions('a = 1 + 2')))

</t>
<t tx="ekr.20080516150804.3826">def test_simple_multiline_statements(self):
    source = 'a = 1\nb = 2\n'
    finder = self._create_finder(source)
    self.assertEquals([(0, len(source) - 1)],
                      list(finder.get_match_regions('a = 1\nb = 2')))

</t>
<t tx="ekr.20080516150804.3827">def test_multiple_matches(self):
    source = 'a = 1 + 1\n'
    finder = self._create_finder(source)
    result = list(finder.get_match_regions('1'))
    self.assertEquals(2, len(result))
    start1 = source.index('1')
    self.assertEquals((start1, start1 + 1) , result[0])
    start2 = source.rindex('1')
    self.assertEquals((start2, start2 + 1) , result[1])

</t>
<t tx="ekr.20080516150804.3828">def test_multiple_matches2(self):
    source = 'a = 1\nb = 2\n\na = 1\nb = 2\n'
    finder = self._create_finder(source)
    self.assertEquals(
        2, len(list(finder.get_match_regions('a = 1\nb = 2'))))

</t>
<t tx="ekr.20080516150804.3829">def test_restricting_the_region_to_search(self):
    source = '1\n\n1\n'
    finder = self._create_finder(source)
    result = list(finder.get_match_regions('1', start=2))
    start = source.rfind('1')
    self.assertEquals([(start, start + 1)], result)

</t>
<t tx="ekr.20080516150804.3830">def test_matching_basic_patterns(self):
    source = 'b = a\n'
    finder = self._create_finder(source)
    result = list(finder.get_match_regions('${a}', args={'a': 'exact'}))
    start = source.rfind('a')
    self.assertEquals([(start, start + 1)], result)

</t>
<t tx="ekr.20080516150804.3831">def test_match_get_ast(self):
    source = 'b = a\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('${a}', args={'a': 'exact'}))
    self.assertEquals('a', result[0].get_ast('a').id)

</t>
<t tx="ekr.20080516150804.3832">def test_match_get_ast_for_statements(self):
    source = 'b = a\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('b = ${a}'))
    self.assertEquals('a', result[0].get_ast('a').id)

</t>
<t tx="ekr.20080516150804.3833">def test_matching_multiple_patterns(self):
    source = 'c = a + b\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('${a} + ${b}'))
    self.assertEquals('a', result[0].get_ast('a').id)
    self.assertEquals('b', result[0].get_ast('b').id)

</t>
<t tx="ekr.20080516150804.3834">def test_matching_any_patterns(self):
    source = 'b = a\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('b = ${x}'))
    self.assertEquals('a', result[0].get_ast('x').id)

</t>
<t tx="ekr.20080516150804.3835">def test_matching_any_patterns_repeating(self):
    source = 'b = 1 + 1\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('b = ${x} + ${x}'))
    self.assertEquals(1, result[0].get_ast('x').n)

</t>
<t tx="ekr.20080516150804.3836">def test_matching_any_patterns_not_matching_different_nodes(self):
    source = 'b = 1 + 2\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('b = ${x} + ${x}'))
    self.assertEquals(0, len(result))

</t>
<t tx="ekr.20080516150804.3837">def test_matching_normal_names_and_assname(self):
    source = 'a = 1\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('${a} = 1'))
    self.assertEquals('a', result[0].get_ast('a').id)

</t>
<t tx="ekr.20080516150804.3838">def test_matching_normal_names_and_assname2(self):
    source = 'a = 1\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('${a}', args={'a': 'exact'}))
    self.assertEquals(1, len(result))

</t>
<t tx="ekr.20080516150804.3839">def test_matching_normal_names_and_attributes(self):
    source = 'x.a = 1\n'
    finder = self._create_finder(source)
    result = list(finder.get_matches('${a} = 1', args={'a': 'exact'}))
    self.assertEquals(0, len(result))

</t>
<t tx="ekr.20080516150804.3840">def test_functions_not_matching_when_only_first_parameters(self):
    source = 'f(1, 2)\n'
    finder = self._create_finder(source)
    self.assertEquals(0, len(list(finder.get_matches('f(1)'))))

</t>
<t tx="ekr.20080516150804.3841">def test_matching_nested_try_finally(self):
    source = 'if 1:\n    try:\n        pass\n    except:\n        pass\n'
    pattern = 'try:\n    pass\nexcept:\n    pass\n'
    finder = self._create_finder(source)
    self.assertEquals(1, len(list(finder.get_matches(pattern))))

</t>
<t tx="ekr.20080516150804.3842">def test_matching_dicts_inside_functions(self):
    source = 'def f(p):\n    d = {1: p.x}\n'
    pattern = '{1: ${a}.x}'
    finder = self._create_finder(source)
    self.assertEquals(1, len(list(finder.get_matches(pattern))))


</t>
<t tx="ekr.20080516150804.3843">class CheckingFinderTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3844">
def setUp(self):
    super(CheckingFinderTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod1 = testutils.create_module(self.project, 'mod1')

</t>
<t tx="ekr.20080516150804.3845">def tearDown(self):
    testutils.remove_project(self.project)
    super(CheckingFinderTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3846">def test_trivial_case(self):
    self.mod1.write('')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    self.assertEquals([], list(finder.get_matches('10', {})))

</t>
<t tx="ekr.20080516150804.3847">def test_simple_finding(self):
    self.mod1.write('class A(object):\n    pass\na = A()\n')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${anything} = ${A}()', {}))
    self.assertEquals(1, len(result))

</t>
<t tx="ekr.20080516150804.3848">def test_not_matching_when_the_name_does_not_match(self):
    self.mod1.write('class A(object):\n    pass\na = list()\n')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${anything} = ${C}()',
                                     {'C': 'name=mod1.A'}))
    self.assertEquals(0, len(result))

</t>
<t tx="ekr.20080516150804.3849">def test_not_matching_unknowns_finding(self):
    self.mod1.write('class A(object):\n    pass\na = unknown()\n')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${anything} = ${C}()',
                                     {'C': 'name=mod1.A'}))
    self.assertEquals(0, len(result))

</t>
<t tx="ekr.20080516150804.3850">def test_finding_and_matching_pyobjects(self):
    source = 'class A(object):\n    pass\nNewA = A\na = NewA()\n'
    self.mod1.write(source)
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${anything} = ${A}()',
                                     {'A': 'object=mod1.A'}))
    self.assertEquals(1, len(result))
    start = source.rindex('a =')
    self.assertEquals((start, len(source) - 1), result[0].get_region())

</t>
<t tx="ekr.20080516150804.3851">def test_finding_and_matching_types(self):
    source = 'class A(object):\n    def f(self):\n        pass\n' \
             'a = A()\nb = a.f()\n'
    self.mod1.write(source)
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${anything} = ${inst}.f()',
                                     {'inst': 'type=mod1.A'}))
    self.assertEquals(1, len(result))
    start = source.rindex('b')
    self.assertEquals((start, len(source) - 1), result[0].get_region())

</t>
<t tx="ekr.20080516150804.3852">def test_checking_the_type_of_an_ass_name_node(self):
    self.mod1.write('class A(object):\n    pass\nan_a = A()\n')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${a} = ${assigned}',
                                     {'a': 'type=mod1.A'}))
    self.assertEquals(1, len(result))

</t>
<t tx="ekr.20080516150804.3853">def test_checking_instance_of_an_ass_name_node(self):
    self.mod1.write('class A(object):\n    pass\n'
                    'class B(A):\n    pass\nb = B()\n')
    pymodule = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymodule)
    result = list(finder.get_matches('${a} = ${assigned}',
                                     {'a': 'instance=mod1.A'}))
    self.assertEquals(1, len(result))

</t>
<t tx="ekr.20080516150804.3854">def test_checking_equality_of_imported_pynames(self):
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('class A(object):\n    pass\n')
    self.mod1.write('from mod2 import A\nan_a = A()\n')
    pymod2 = self.pycore.resource_to_pyobject(mod2)
    pymod1 = self.pycore.resource_to_pyobject(self.mod1)
    finder = similarfinder.SimilarFinder(pymod1)
    result = list(finder.get_matches('${a_class}()',
                                     {'a_class': 'name=mod2.A'}))
    self.assertEquals(1, len(result))


</t>
<t tx="ekr.20080516150804.3855">class TemplateTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3856">
def test_simple_templates(self):
    template = similarfinder.CodeTemplate('${a}\n')
    self.assertEquals(set(['a']), set(template.get_names()))

</t>
<t tx="ekr.20080516150804.3857">def test_ignoring_matches_in_comments(self):
    template = similarfinder.CodeTemplate('#${a}\n')
    self.assertEquals([], template.get_names())

</t>
<t tx="ekr.20080516150804.3858">def test_ignoring_matches_in_strings(self):
    template = similarfinder.CodeTemplate("'${a}'\n")
    self.assertEquals([], template.get_names())

</t>
<t tx="ekr.20080516150804.3859">def test_simple_substitution(self):
    template = similarfinder.CodeTemplate('${a}\n')
    self.assertEquals('b\n', template.substitute({'a': 'b'}))

</t>
<t tx="ekr.20080516150804.3860">def test_substituting_multiple_names(self):
    template = similarfinder.CodeTemplate('${a}, ${b}\n')
    self.assertEquals('1, 2\n', template.substitute({'a': '1', 'b': '2'}))


</t>
<t tx="ekr.20080516150804.3861">def suite():
    result = unittest.TestSuite()
    result.addTests(unittest.makeSuite(SimilarFinderTest))
    result.addTests(unittest.makeSuite(CheckingFinderTest))
    result.addTests(unittest.makeSuite(TemplateTest))
    return result

</t>
<t tx="ekr.20080516150804.3862">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3863">import unittest

from rope.base import ast
from rope.refactor import suites


</t>
<t tx="ekr.20080516150804.3864">class SuiteTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3865">
def setUp(self):
    super(SuiteTest, self).setUp()

</t>
<t tx="ekr.20080516150804.3866">def tearDown(self):
    super(SuiteTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3867">def test_trivial_case(self):
    root = source_suite_tree('')
    self.assertEquals(1, root.get_start())
    self.assertEquals(0, len(root.get_children()))

</t>
<t tx="ekr.20080516150804.3868">def test_simple_ifs(self):
    root = source_suite_tree('if True:\n    pass')
    self.assertEquals(1, len(root.get_children()))

</t>
<t tx="ekr.20080516150804.3869">def test_simple_else(self):
    root = source_suite_tree(
        'if True:\n    pass\nelse:\n    pass\n')
    self.assertEquals(2, len(root.get_children()))
    self.assertEquals(1, root.get_children()[1].get_start())

</t>
<t tx="ekr.20080516150804.3870">def test_for(self):
    root = source_suite_tree(
        '\nfor i in range(10):\n    pass\nelse:\n    pass\n')
    self.assertEquals(2, len(root.get_children()))
    self.assertEquals(2, root.get_children()[1].get_start())

</t>
<t tx="ekr.20080516150804.3871">def test_while(self):
    root = source_suite_tree(
        'while True:\n    pass\n')
    self.assertEquals(1, len(root.get_children()))
    self.assertEquals(1, root.get_children()[0].get_start())

</t>
<t tx="ekr.20080516150804.3872">def test_with(self):
    root = source_suite_tree(
        'from __future__ import with_statement\nwith file(x):    pass\n')
    self.assertEquals(1, len(root.get_children()))
    self.assertEquals(2, root.get_children()[0].get_start())

</t>
<t tx="ekr.20080516150804.3873">def test_try_finally(self):
    root = source_suite_tree(
        'try:\n    pass\nfinally:\n    pass\n')
    self.assertEquals(2, len(root.get_children()))
    self.assertEquals(1, root.get_children()[0].get_start())

</t>
<t tx="ekr.20080516150804.3874">def test_try_except(self):
    root = source_suite_tree(
        'try:\n    pass\nexcept:\n    pass\nelse:\n    pass\n')
    self.assertEquals(3, len(root.get_children()))
    self.assertEquals(1, root.get_children()[2].get_start())

</t>
<t tx="ekr.20080516150804.3875">def test_try_except_finally(self):
    root = source_suite_tree(
        'try:\n    pass\nexcept:\n    pass\nfinally:\n    pass\n')
    self.assertEquals(3, len(root.get_children()))
    self.assertEquals(1, root.get_children()[2].get_start())

</t>
<t tx="ekr.20080516150804.3876">def test_local_start_and_end(self):
    root = source_suite_tree('if True:\n    pass\nelse:\n    pass\n')
    self.assertEquals(1, root.local_start())
    self.assertEquals(4, root.local_end())
    if_suite = root.get_children()[0]
    self.assertEquals(2, if_suite.local_start())
    self.assertEquals(2, if_suite.local_end())
    else_suite = root.get_children()[1]
    self.assertEquals(4, else_suite.local_start())
    self.assertEquals(4, else_suite.local_end())

</t>
<t tx="ekr.20080516150804.3877">def test_find_suite(self):
    root = source_suite_tree('\n')
    self.assertEquals(root, root.find_suite(1))

</t>
<t tx="ekr.20080516150804.3878">def test_find_suite_for_ifs(self):
    root = source_suite_tree('if True:\n    pass\n')
    if_suite = root.get_children()[0]
    self.assertEquals(if_suite, root.find_suite(2))

</t>
<t tx="ekr.20080516150804.3879">def test_find_suite_for_between_suites(self):
    root = source_suite_tree(
        'if True:\n    pass\nprint(1)\nif True:\n    pass\n')
    if_suite1 = root.get_children()[0]
    if_suite2 = root.get_children()[1]
    self.assertEquals(if_suite1, root.find_suite(2))
    self.assertEquals(if_suite2, root.find_suite(5))
    self.assertEquals(root, root.find_suite(3))

</t>
<t tx="ekr.20080516150804.3880">def test_simple_find_visible(self):
    root = source_suite_tree('a = 1\n')
    self.assertEquals(1, suites.find_visible_for_suite(root, [1]))

</t>
<t tx="ekr.20080516150804.3881">def test_simple_find_visible_ifs(self):
    root = source_suite_tree('\nif True:\n    a = 1\n    b = 2\n')
    self.assertEquals(root.find_suite(3), root.find_suite(4))
    self.assertEquals(3, suites.find_visible_for_suite(root, [3, 4]))

</t>
<t tx="ekr.20080516150804.3882">def test_simple_find_visible_for_else(self):
    root = source_suite_tree('\nif True:\n    pass\nelse:    pass\n')
    self.assertEquals(2, suites.find_visible_for_suite(root, [2, 4]))

</t>
<t tx="ekr.20080516150804.3883">def test_simple_find_visible_for_different_suites(self):
    root = source_suite_tree('if True:\n    pass\na = 1\n'
                             'if False:\n    pass\n')
    self.assertEquals(1, suites.find_visible_for_suite(root, [2, 3]))
    self.assertEquals(5, suites.find_visible_for_suite(root, [5]))
    self.assertEquals(1, suites.find_visible_for_suite(root, [2, 5]))

</t>
<t tx="ekr.20080516150804.3884">def test_not_always_selecting_scope_start(self):
    root = source_suite_tree(
        'if True:\n    a = 1\n    if True:\n        pass\n'
        '    else:\n        pass\n')
    self.assertEquals(3, suites.find_visible_for_suite(root, [4, 6]))
    self.assertEquals(3, suites.find_visible_for_suite(root, [3, 5]))
    self.assertEquals(3, suites.find_visible_for_suite(root, [4, 5]))

</t>
<t tx="ekr.20080516150804.3885">def test_ignoring_functions(self):
    root = source_suite_tree(
        'def f():\n    pass\na = 1\n')
    self.assertEquals(3, suites.find_visible_for_suite(root, [2, 3]))

</t>
<t tx="ekr.20080516150804.3886">def test_ignoring_classes(self):
    root = source_suite_tree(
        'a = 1\nclass C():\n    pass\n')
    self.assertEquals(1, suites.find_visible_for_suite(root, [1, 3]))


</t>
<t tx="ekr.20080516150804.3887">def source_suite_tree(source):
    return suites.ast_suite_tree(ast.parse(source))


</t>
<t tx="ekr.20080516150804.3888">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20080516150804.3889">import unittest

from rope.base import exceptions
from ropetest import testutils
from rope.refactor.usefunction import UseFunction


</t>
<t tx="ekr.20080516150804.3890">class UseFunctionTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3891">
def setUp(self):
    super(UseFunctionTest, self).setUp()
    self.project = testutils.sample_project()
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.mod2 = testutils.create_module(self.project, 'mod2')

</t>
<t tx="ekr.20080516150804.3892">def tearDown(self):
    testutils.remove_project(self.project)
    super(UseFunctionTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3893">def test_simple_case(self):
    code = 'def f():\n    pass\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals(code, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3894">def test_simple_function(self):
    code = 'def f(p):\n    print(p)\nprint(1)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals('def f(p):\n    print(p)\nf(1)\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3895">def test_simple_function2(self):
    code = 'def f(p):\n    print(p + 1)\nprint(1 + 1)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals('def f(p):\n    print(p + 1)\nf(1)\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3896">def test_functions_with_multiple_statements(self):
    code = 'def f(p):\n    r = p + 1\n    print(r)\nr = 2 + 1\nprint(r)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals('def f(p):\n    r = p + 1\n    print(r)\nf(2)\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3897">def test_returning(self):
    code = 'def f(p):\n    return p + 1\nr = 2 + 1\nprint(r)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals(
        'def f(p):\n    return p + 1\nr = f(2)\nprint(r)\n',
        self.mod1.read())

</t>
<t tx="ekr.20080516150804.3898">def test_returning_a_single_expression(self):
    code = 'def f(p):\n    return p + 1\nprint(2 + 1)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals(
        'def f(p):\n    return p + 1\nprint(f(2))\n',
        self.mod1.read())

</t>
<t tx="ekr.20080516150804.3899">def test_occurrences_in_other_modules(self):
    code = 'def f(p):\n    return p + 1\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.mod2.write('print(2 + 1)\n')
    self.project.do(user.get_changes())
    self.assertEquals('import mod1\nprint(mod1.f(2))\n',
                      self.mod2.read())

</t>
<t tx="ekr.20080516150804.3900">@testutils.assert_raises(exceptions.RefactoringError)
def test_when_performing_on_non_functions(self):
    code = 'var = 1\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('var'))

</t>
<t tx="ekr.20080516150804.3901">def test_differing_in_the_inner_temp_names(self):
    code = 'def f(p):\n    a = p + 1\n    print(a)\nb = 2 + 1\nprint(b)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals('def f(p):\n    a = p + 1\n    print(a)\nf(2)\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3902"># TODO: probably new options should be added to restructure
def xxx_test_being_a_bit_more_intelligent_when_returning_assigneds(self):
    code = 'def f(p):\n    a = p + 1\n    return a\n'\
           'var = 2 + 1\nprint(var)\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.rindex('f'))
    self.project.do(user.get_changes())
    self.assertEquals('def f(p):\n    a = p + 1\n    return a\n'
                      'var = f(p)\nprint(var)\n', self.mod1.read())

</t>
<t tx="ekr.20080516150804.3903">@testutils.assert_raises(exceptions.RefactoringError)
def test_exception_when_performing_a_function_with_yield(self):
    code = 'def func():\n    yield 1\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.index('func'))

</t>
<t tx="ekr.20080516150804.3904">@testutils.assert_raises(exceptions.RefactoringError)
def test_exception_when_performing_a_function_two_returns(self):
    code = 'def func():\n    return 1\n    return 2\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.index('func'))

</t>
<t tx="ekr.20080516150804.3905">@testutils.assert_raises(exceptions.RefactoringError)
def test_exception_when_returns_is_not_the_last_statement(self):
    code = 'def func():\n    return 2\n    a = 1\n'
    self.mod1.write(code)
    user = UseFunction(self.project, self.mod1, code.index('func'))


</t>
<t tx="ekr.20080516150804.3906">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    import sys
    if len(sys.argv) &gt; 1:
        unittest.main()
    else:
        runner = unittest.TextTestRunner()
        runner.run(suite())
</t>
<t tx="ekr.20080516150804.3907">import unittest

import rope.base.taskhandle
import rope.refactor.introduce_parameter
import ropetest.refactor.extracttest
import ropetest.refactor.importutilstest
import ropetest.refactor.inlinetest
import ropetest.refactor.movetest
import ropetest.refactor.multiprojecttest
import ropetest.refactor.patchedasttest
import ropetest.refactor.renametest
import ropetest.refactor.restructuretest
import ropetest.refactor.suitestest
import ropetest.refactor.usefunctiontest
from rope.base.exceptions import RefactoringError, InterruptedTaskError
from rope.refactor.encapsulate_field import EncapsulateField
from rope.refactor.introduce_factory import IntroduceFactory
from rope.refactor.localtofield import LocalToField
from rope.refactor.method_object import MethodObject
from ropetest import testutils
from ropetest.refactor import change_signature_test, similarfindertest


</t>
<t tx="ekr.20080516150804.3908">class MethodObjectTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3909">
def setUp(self):
    super(MethodObjectTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3910">def tearDown(self):
    testutils.remove_project(self.project)
    super(MethodObjectTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3911">def test_empty_method(self):
    code = 'def func():\n    pass\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n    def __call__(self):\n        pass\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3912">def test_trivial_return(self):
    code = 'def func():\n    return 1\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n    def __call__(self):\n        return 1\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3913">def test_multi_line_header(self):
    code = 'def func(\n    ):\n    return 1\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n    def __call__(self):\n        return 1\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3914">def test_a_single_parameter(self):
    code = 'def func(param):\n    return 1\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n'
        '    def __init__(self, param):\n        self.param = param\n\n'
        '    def __call__(self):\n        return 1\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3915">def test_self_parameter(self):
    code = 'def func(self):\n    return 1\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n'
        '    def __init__(self, host):\n        self.self = host\n\n'
        '    def __call__(self):\n        return 1\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3916">def test_simple_using_passed_parameters(self):
    code = 'def func(param):\n    return param\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.assertEquals(
        'class _New(object):\n\n'
        '    def __init__(self, param):\n        self.param = param\n\n'
        '    def __call__(self):\n        return self.param\n',
        replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3917">def test_self_keywords_and_args_parameters(self):
    code = 'def func(arg, *args, **kwds):\n' \
           '    result = arg + args[0] + kwds[arg]\n' \
           '    return result\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    expected = 'class _New(object):\n\n' \
               '    def __init__(self, arg, args, kwds):\n' \
               '        self.arg = arg\n' \
               '        self.args = args\n' \
               '        self.kwds = kwds\n\n' \
               '    def __call__(self):\n' \
               '        result = self.arg + self.args[0] + self.kwds[self.arg]\n' \
               '        return result\n'
    self.assertEquals(expected, replacer.get_new_class('_New'))

</t>
<t tx="ekr.20080516150804.3918">@testutils.assert_raises(RefactoringError)
def test_performing_on_not_a_function(self):
    code = 'my_var = 10\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('my_var'))

</t>
<t tx="ekr.20080516150804.3919">def test_changing_the_module(self):
    code = 'def func():\n    return 1\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.project.do(replacer.get_changes('_New'))
    expected = 'def func():\n' \
               '    return _New()()\n\n\n' \
               'class _New(object):\n\n' \
               '    def __call__(self):\n' \
               '        return 1\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3920">def test_changing_the_module_and_class_methods(self):
    code = 'class C(object):\n\n' \
           '    def a_func(self):\n' \
           '        return 1\n\n' \
           '    def another_func(self):\n' \
           '        pass\n'
    self.mod.write(code)
    replacer = MethodObject(self.project, self.mod, code.index('func'))
    self.project.do(replacer.get_changes('_New'))
    expected = 'class C(object):\n\n' \
               '    def a_func(self):\n' \
               '        return _New(self)()\n\n' \
               '    def another_func(self):\n' \
               '        pass\n\n\n' \
               'class _New(object):\n\n' \
               '    def __init__(self, host):\n' \
               '        self.self = host\n\n' \
               '    def __call__(self):\n' \
               '        return 1\n'
    self.assertEquals(expected, self.mod.read())


</t>
<t tx="ekr.20080516150804.3921">class IntroduceFactoryTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3922">
def setUp(self):
    super(IntroduceFactoryTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()

</t>
<t tx="ekr.20080516150804.3923">def tearDown(self):
    testutils.remove_project(self.project)
    super(IntroduceFactoryTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3924">def _introduce_factory(self, resource, offset, *args, **kwds):
    factory_introducer = IntroduceFactory(self.project,
                                          resource, offset)
    changes = factory_introducer.get_changes(*args, **kwds)
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3925">def test_adding_the_method(self):
    code = 'class AClass(object):\n    an_attr = 10\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n' \
               '    an_attr = 10\n\n' \
               '    @staticmethod\n' \
               '    def create(*args, **kwds):\n' \
               '        return AClass(*args, **kwds)\n'
    self._introduce_factory(mod, mod.read().index('AClass') + 1, 'create')
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3926">def test_changing_occurances_in_the_main_module(self):
    code = 'class AClass(object):\n' \
           '    an_attr = 10\n' \
           'a_var = AClass()'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n' \
               '    an_attr = 10\n\n' \
               '    @staticmethod\n' \
               '    def create(*args, **kwds):\n' \
               '        return AClass(*args, **kwds)\n'\
               'a_var = AClass.create()'
    self._introduce_factory(mod, mod.read().index('AClass') + 1, 'create')
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3927">def test_changing_occurances_with_arguments(self):
    code = 'class AClass(object):\n' \
           '    def __init__(self, arg):\n' \
           '        pass\n' \
           'a_var = AClass(10)\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n' \
               '    def __init__(self, arg):\n' \
               '        pass\n\n' \
               '    @staticmethod\n' \
               '    def create(*args, **kwds):\n' \
               '        return AClass(*args, **kwds)\n' \
               'a_var = AClass.create(10)\n'
    self._introduce_factory(mod, mod.read().index('AClass') + 1, 'create')
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3928">def test_changing_occurances_in_other_modules(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('class AClass(object):\n    an_attr = 10\n')
    mod2.write('import mod1\na_var = mod1.AClass()\n')
    self._introduce_factory(mod1, mod1.read().index('AClass') + 1, 'create')
    expected1 = 'class AClass(object):\n' \
                '    an_attr = 10\n\n' \
                '    @staticmethod\n' \
                '    def create(*args, **kwds):\n' \
                '        return AClass(*args, **kwds)\n'
    expected2 = 'import mod1\n' \
                'a_var = mod1.AClass.create()\n'
    self.assertEquals(expected1, mod1.read())
    self.assertEquals(expected2, mod2.read())

</t>
<t tx="ekr.20080516150804.3929">@testutils.assert_raises(RefactoringError)
def test_raising_exception_for_non_classes(self):
    mod = testutils.create_module(self.project, 'mod')
    mod.write('def a_func():\n    pass\n')
    self._introduce_factory(mod, mod.read().index('a_func') + 1, 'create')

</t>
<t tx="ekr.20080516150804.3930">def test_undoing_introduce_factory(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    code1 = 'class AClass(object):\n    an_attr = 10\n'
    mod1.write(code1)
    code2 = 'from mod1 import AClass\na_var = AClass()\n'
    mod2.write(code2)
    self._introduce_factory(mod1, mod1.read().index('AClass') + 1, 'create')
    self.project.history.undo()
    self.assertEquals(code1, mod1.read())
    self.assertEquals(code2, mod2.read())

</t>
<t tx="ekr.20080516150804.3931">def test_using_on_an_occurance_outside_the_main_module(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('class AClass(object):\n    an_attr = 10\n')
    mod2.write('import mod1\na_var = mod1.AClass()\n')
    self._introduce_factory(mod2, mod2.read().index('AClass') + 1, 'create')
    expected1 = 'class AClass(object):\n' \
                '    an_attr = 10\n\n' \
                '    @staticmethod\n' \
                '    def create(*args, **kwds):\n' \
                '        return AClass(*args, **kwds)\n'
    expected2 = 'import mod1\n' \
                'a_var = mod1.AClass.create()\n'
    self.assertEquals(expected1, mod1.read())
    self.assertEquals(expected2, mod2.read())

</t>
<t tx="ekr.20080516150804.3932">def test_introduce_factory_in_nested_scopes(self):
    code = 'def create_var():\n'\
           '    class AClass(object):\n'\
           '        an_attr = 10\n'\
           '    return AClass()\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'def create_var():\n'\
               '    class AClass(object):\n'\
               '        an_attr = 10\n\n'\
               '        @staticmethod\n        def create(*args, **kwds):\n'\
               '            return AClass(*args, **kwds)\n'\
               '    return AClass.create()\n'
    self._introduce_factory(mod, mod.read().index('AClass') + 1, 'create')
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3933">def test_adding_factory_for_global_factories(self):
    code = 'class AClass(object):\n    an_attr = 10\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n' \
               '    an_attr = 10\n\n' \
               'def create(*args, **kwds):\n' \
               '    return AClass(*args, **kwds)\n'
    self._introduce_factory(mod, mod.read().index('AClass') + 1,
                                    'create', global_factory=True)
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3934">def test_get_name_for_factories(self):
    code = 'class C(object):\n    pass\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    factory = IntroduceFactory(self.project, mod,
                               mod.read().index('C') + 1)
    self.assertEquals('C', factory.get_name())

</t>
<t tx="ekr.20080516150804.3935">@testutils.assert_raises(RefactoringError)
def test_raising_exception_for_global_factory_for_nested_classes(self):
    code = 'def create_var():\n'\
           '    class AClass(object):\n'\
           '        an_attr = 10\n'\
           '    return AClass()\n'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    self._introduce_factory(mod, mod.read().index('AClass') + 1,
                                       'create', global_factory=True)

</t>
<t tx="ekr.20080516150804.3936">def test_changing_occurances_in_the_main_module_for_global_factories(self):
    code = 'class AClass(object):\n' \
           '    an_attr = 10\n' \
           'a_var = AClass()'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n    an_attr = 10\n\n' \
               'def create(*args, **kwds):\n' \
               '    return AClass(*args, **kwds)\n'\
               'a_var = create()'
    self._introduce_factory(mod, mod.read().index('AClass') + 1,
                                       'create', global_factory=True)
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3937">def test_changing_occurances_in_other_modules_for_global_factories(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('class AClass(object):\n    an_attr = 10\n')
    mod2.write('import mod1\na_var = mod1.AClass()\n')
    self._introduce_factory(mod1, mod1.read().index('AClass') + 1,
                                       'create', global_factory=True)
    expected1 = 'class AClass(object):\n' \
                '    an_attr = 10\n\n' \
                'def create(*args, **kwds):\n' \
                '    return AClass(*args, **kwds)\n'
    expected2 = 'import mod1\n' \
                'a_var = mod1.create()\n'
    self.assertEquals(expected1, mod1.read())
    self.assertEquals(expected2, mod2.read())

</t>
<t tx="ekr.20080516150804.3938">def test_importing_if_necessary_in_other_modules_for_global_factories(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod1.write('class AClass(object):\n    an_attr = 10\n')
    mod2.write('from mod1 import AClass\npair = AClass(), AClass\n')
    self._introduce_factory(mod1, mod1.read().index('AClass') + 1,
                                       'create', global_factory=True)
    expected1 = 'class AClass(object):\n' \
                '    an_attr = 10\n\n' \
                'def create(*args, **kwds):\n' \
                '    return AClass(*args, **kwds)\n'
    expected2 = 'from mod1 import AClass, create\n' \
                'pair = create(), AClass\n'
    self.assertEquals(expected1, mod1.read())
    self.assertEquals(expected2, mod2.read())

</t>
<t tx="ekr.20080516150804.3939">def test_changing_occurances_for_renamed_classes(self):
    code = 'class AClass(object):\n    an_attr = 10\na_class = AClass\na_var = a_class()'
    mod = testutils.create_module(self.project, 'mod')
    mod.write(code)
    expected = 'class AClass(object):\n' \
               '    an_attr = 10\n\n' \
               '    @staticmethod\n' \
               '    def create(*args, **kwds):\n' \
               '        return AClass(*args, **kwds)\n' \
               'a_class = AClass\n' \
               'a_var = a_class()'
    self._introduce_factory(mod, mod.read().index('a_class') + 1, 'create')
    self.assertEquals(expected, mod.read())

</t>
<t tx="ekr.20080516150804.3940">def test_changing_occurrences_in_the_same_module_with_conflicting_ranges(self):
    mod = testutils.create_module(self.project, 'mod')
    code = 'class C(object):\n' \
           '    def create(self):\n' \
           '        return C()\n'
    mod.write(code)
    self._introduce_factory(mod, mod.read().index('C'), 'create_c', True)
    expected = 'class C(object):\n' \
               '    def create(self):\n' \
               '        return create_c()\n'
    self.assertTrue(mod.read().startswith(expected))

</t>
<t tx="ekr.20080516150804.3941">def _transform_module_to_package(self, resource):
    self.project.do(rope.refactor.ModuleToPackage(
                    self.project, resource).get_changes())

</t>
<t tx="ekr.20080516150804.3942">def test_transform_module_to_package(self):
    mod1 = testutils.create_module(self.project, 'mod1')
    mod1.write('import mod2\nfrom mod2 import AClass\n')
    mod2 = testutils.create_module(self.project, 'mod2')
    mod2.write('class AClass(object):\n    pass\n')
    self._transform_module_to_package(mod2)
    mod2 = self.project.get_resource('mod2')
    root_folder = self.project.root
    self.assertFalse(root_folder.has_child('mod2.py'))
    self.assertEquals('class AClass(object):\n    pass\n',
                      root_folder.get_child('mod2').
                      get_child('__init__.py').read())

</t>
<t tx="ekr.20080516150804.3943">def test_transform_module_to_package_undoing(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod = testutils.create_module(self.project, 'mod', pkg)
    self._transform_module_to_package(mod)
    self.assertFalse(pkg.has_child('mod.py'))
    self.assertTrue(pkg.get_child('mod').has_child('__init__.py'))
    self.project.history.undo()
    self.assertTrue(pkg.has_child('mod.py'))
    self.assertFalse(pkg.has_child('mod'))

</t>
<t tx="ekr.20080516150804.3944">def test_transform_module_to_package_with_relative_imports(self):
    pkg = testutils.create_package(self.project, 'pkg')
    mod1 = testutils.create_module(self.project, 'mod1', pkg)
    mod1.write('import mod2\nfrom mod2 import AClass\n')
    mod2 = testutils.create_module(self.project, 'mod2', pkg)
    mod2.write('class AClass(object):\n    pass\n')
    self._transform_module_to_package(mod1)
    new_init = self.project.get_resource('pkg/mod1/__init__.py')
    self.assertEquals('import pkg.mod2\nfrom pkg.mod2 import AClass\n',
                      new_init.read())

</t>
<t tx="ekr.20080516150804.3945">def test_resources_parameter(self):
    code = 'class A(object):\n    an_attr = 10\n'
    code1 = 'import mod\na = mod.A()\n'
    mod = testutils.create_module(self.project, 'mod')
    mod1 = testutils.create_module(self.project, 'mod1')
    mod.write(code)
    mod1.write(code1)
    expected = 'class A(object):\n' \
               '    an_attr = 10\n\n' \
               '    @staticmethod\n' \
               '    def create(*args, **kwds):\n' \
               '        return A(*args, **kwds)\n'
    self._introduce_factory(mod, mod.read().index('A') + 1,
                            'create', resources=[mod])
    self.assertEquals(expected, mod.read())
    self.assertEquals(code1, mod1.read())


</t>
<t tx="ekr.20080516150804.3946">class EncapsulateFieldTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3947">
def setUp(self):
    super(EncapsulateFieldTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')
    self.mod1 = testutils.create_module(self.project, 'mod1')
    self.a_class = 'class A(object):\n' \
                   '    def __init__(self):\n' \
                   '        self.attr = 1\n'
    self.added_methods = '\n' \
        '    def get_attr(self):\n' \
        '        return self.attr\n\n' \
        '    def set_attr(self, value):\n' \
        '        self.attr = value\n'
    self.encapsulated = self.a_class + self.added_methods

</t>
<t tx="ekr.20080516150804.3948">def tearDown(self):
    testutils.remove_project(self.project)
    super(EncapsulateFieldTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3949">def _encapsulate(self, resource, offset, **args):
    changes = EncapsulateField(self.project, resource, offset).\
              get_changes(**args)
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3950">def test_adding_getters_and_setters(self):
    code = self.a_class
    self.mod.write(code)
    self._encapsulate(self.mod, code.index('attr') + 1)
    self.assertEquals(self.encapsulated, self.mod.read())

</t>
<t tx="ekr.20080516150804.3951">def test_changing_getters_in_other_modules(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'range(a_var.attr)\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'range(a_var.get_attr())\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3952">def test_changing_setters_in_other_modules(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr = 1\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'a_var.set_attr(1)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3953">def test_changing_getters_in_setters(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr = 1 + a_var.attr\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'a_var.set_attr(1 + a_var.get_attr())\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3954">def test_appending_to_class_end(self):
    self.mod1.write(self.a_class + 'a_var = A()\n')
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)
    self.assertEquals(self.encapsulated + 'a_var = A()\n',
                      self.mod1.read())

</t>
<t tx="ekr.20080516150804.3955">def test_performing_in_other_modules(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'range(a_var.attr)\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)
    self.assertEquals(self.encapsulated, self.mod.read())
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'range(a_var.get_attr())\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3956">def test_changing_main_module_occurances(self):
    code = self.a_class + \
           'a_var = A()\n' \
           'a_var.attr = a_var.attr * 2\n'
    self.mod1.write(code)
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)
    expected = self.encapsulated + \
               'a_var = A()\n' \
               'a_var.set_attr(a_var.get_attr() * 2)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3957">@testutils.assert_raises(RefactoringError)
def test_raising_exception_when_performed_on_non_attributes(self):
    self.mod1.write('attr = 10')
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)

</t>
<t tx="ekr.20080516150804.3958">@testutils.assert_raises(RefactoringError)
def test_raising_exception_on_tuple_assignments(self):
    self.mod.write(self.a_class)
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr = 1\n' \
           'a_var.attr, b = 1, 2\n'
    self.mod1.write(code)
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)

</t>
<t tx="ekr.20080516150804.3959">@testutils.assert_raises(RefactoringError)
def test_raising_exception_on_tuple_assignments2(self):
    self.mod.write(self.a_class)
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr = 1\n' \
           'b, a_var.attr = 1, 2\n'
    self.mod1.write(code)
    self._encapsulate(self.mod1, self.mod1.read().index('attr') + 1)

</t>
<t tx="ekr.20080516150804.3960">def test_tuple_assignments_and_function_calls(self):
    code = 'import mod\n' \
           'def func(a1=0, a2=0):\n' \
           '    pass\n' \
           'a_var = mod.A()\n' \
           'func(a_var.attr, a2=2)\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'def func(a1=0, a2=0):\n' \
               '    pass\n' \
               'a_var = mod.A()\n' \
               'func(a_var.get_attr(), a2=2)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3961">def test_tuple_assignments(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a, b = a_var.attr, 1\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'a, b = a_var.get_attr(), 1\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3962">def test_changing_augmented_assignments(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr += 1\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'a_var.set_attr(a_var.get_attr() + 1)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3963">def test_changing_augmented_assignments2(self):
    code = 'import mod\n' \
           'a_var = mod.A()\n' \
           'a_var.attr &lt;&lt;= 1\n'
    self.mod1.write(code)
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = 'import mod\n' \
               'a_var = mod.A()\n' \
               'a_var.set_attr(a_var.get_attr() &lt;&lt; 1)\n'
    self.assertEquals(expected, self.mod1.read())

</t>
<t tx="ekr.20080516150804.3964">def test_changing_occurrences_inside_the_class(self):
    new_class = self.a_class + '\n' \
                '    def a_func(self):\n' \
                '        self.attr = 1\n'
    self.mod.write(new_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1)
    expected = self.a_class + '\n' \
               '    def a_func(self):\n' \
               '        self.set_attr(1)\n' + \
               self.added_methods
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3965">def test_getter_and_setter_parameters(self):
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1,
                      getter='getAttr', setter='setAttr')
    new_methods = self.added_methods.replace('get_attr', 'getAttr').\
                  replace('set_attr', 'setAttr')
    expected = self.a_class + new_methods
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3966">def test_using_resources_parameter(self):
    self.mod1.write('import mod\na = mod.A()\nvar = a.attr\n')
    self.mod.write(self.a_class)
    self._encapsulate(self.mod, self.mod.read().index('attr') + 1,
                      resources=[self.mod])
    self.assertEquals('import mod\na = mod.A()\nvar = a.attr\n',
                      self.mod1.read())
    expected = self.a_class + self.added_methods
    self.assertEquals(expected, self.mod.read())


</t>
<t tx="ekr.20080516150804.3967">class LocalToFieldTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3968">
def setUp(self):
    super(LocalToFieldTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3969">def tearDown(self):
    testutils.remove_project(self.project)
    super(LocalToFieldTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3970">def _perform_convert_local_variable_to_field(self, resource, offset):
    changes = LocalToField(
        self.project, resource, offset).get_changes()
    self.project.do(changes)

</t>
<t tx="ekr.20080516150804.3971">def test_simple_local_to_field(self):
    code = 'class A(object):\n' \
           '    def a_func(self):\n' \
           '        var = 10\n'
    self.mod.write(code)
    self._perform_convert_local_variable_to_field(self.mod,
                                                  code.index('var') + 1)
    expected = 'class A(object):\n' \
               '    def a_func(self):\n' \
               '        self.var = 10\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3972">@testutils.assert_raises(RefactoringError)
def test_raising_exception_when_performed_on_a_global_var(self):
    self.mod.write('var = 10\n')
    self._perform_convert_local_variable_to_field(
        self.mod, self.mod.read().index('var') + 1)

</t>
<t tx="ekr.20080516150804.3973">@testutils.assert_raises(RefactoringError)
def test_raising_exception_when_performed_on_field(self):
    code = 'class A(object):\n' \
           '    def a_func(self):\n' \
           '        self.var = 10\n'
    self.mod.write(code)
    self._perform_convert_local_variable_to_field(
        self.mod, self.mod.read().index('var') + 1)

</t>
<t tx="ekr.20080516150804.3974">@testutils.assert_raises(RefactoringError)
def test_raising_exception_when_performed_on_a_parameter(self):
    code = 'class A(object):\n' \
           '    def a_func(self, var):\n' \
           '        a = var\n'
    self.mod.write(code)
    self._perform_convert_local_variable_to_field(
        self.mod, self.mod.read().index('var') + 1)

</t>
<t tx="ekr.20080516150804.3975"># NOTE: This situation happens alot and is normally not an error
#@testutils.assert_raises(RefactoringError)
def test_not_raising_exception_when_there_is_a_field_with_the_same_name(self):
    code = 'class A(object):\n' \
           '    def __init__(self):\n' \
           '        self.var = 1\n' \
           '    def a_func(self):\n        var = 10\n'
    self.mod.write(code)
    self._perform_convert_local_variable_to_field(
        self.mod, self.mod.read().rindex('var') + 1)

</t>
<t tx="ekr.20080516150804.3976">def test_local_to_field_with_self_renamed(self):
    code = 'class A(object):\n' \
           '    def a_func(myself):\n' \
           '        var = 10\n'
    self.mod.write(code)
    self._perform_convert_local_variable_to_field(self.mod,
                                                     code.index('var') + 1)
    expected = 'class A(object):\n' \
               '    def a_func(myself):\n' \
               '        myself.var = 10\n'
    self.assertEquals(expected, self.mod.read())


</t>
<t tx="ekr.20080516150804.3977">class IntroduceParameterTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3978">
def setUp(self):
    super(IntroduceParameterTest, self).setUp()
    self.project = testutils.sample_project()
    self.pycore = self.project.get_pycore()
    self.mod = testutils.create_module(self.project, 'mod')

</t>
<t tx="ekr.20080516150804.3979">def tearDown(self):
    testutils.remove_project(self.project)
    super(IntroduceParameterTest, self).tearDown()

</t>
<t tx="ekr.20080516150804.3980">def _introduce_parameter(self, offset, name):
    rope.refactor.introduce_parameter.IntroduceParameter(
        self.project, self.mod, offset).get_changes(name).do()

</t>
<t tx="ekr.20080516150804.3981">def test_simple_case(self):
    code = 'var = 1\n' \
           'def f():\n' \
           '    b = var\n'
    self.mod.write(code)
    offset = self.mod.read().rindex('var')
    self._introduce_parameter(offset, 'var')
    expected = 'var = 1\n' \
               'def f(var=var):\n' \
               '    b = var\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3982">def test_changing_function_body(self):
    code = 'var = 1\n' \
           'def f():\n' \
           '    b = var\n'
    self.mod.write(code)
    offset = self.mod.read().rindex('var')
    self._introduce_parameter(offset, 'p1')
    expected = 'var = 1\n' \
               'def f(p1=var):\n' \
               '    b = p1\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3983">@testutils.assert_raises(RefactoringError)
def test_unknown_variables(self):
    self.mod.write('def f():\n    b = var + c\n')
    offset = self.mod.read().rindex('var')
    self._introduce_parameter(offset, 'p1')
    self.assertEquals('def f(p1=var):\n    b = p1 + c\n',
                      self.mod.read())

</t>
<t tx="ekr.20080516150804.3984">@testutils.assert_raises(RefactoringError)
def test_failing_when_not_inside(self):
    self.mod.write('var = 10\nb = var\n')
    offset = self.mod.read().rindex('var')
    self._introduce_parameter(offset, 'p1')

</t>
<t tx="ekr.20080516150804.3985">def test_attribute_accesses(self):
    code = 'class C(object):\n' \
           '    a = 10\nc = C()\n' \
           'def f():\n' \
           '    b = c.a\n'
    self.mod.write(code)
    offset = self.mod.read().rindex('a')
    self._introduce_parameter(offset, 'p1')
    expected = 'class C(object):\n' \
               '    a = 10\n' \
               'c = C()\n' \
               'def f(p1=c.a):\n' \
               '    b = p1\n'
    self.assertEquals(expected, self.mod.read())

</t>
<t tx="ekr.20080516150804.3986">def test_introducing_parameters_for_methods(self):
    code = 'var = 1\n' \
           'class C(object):\n' \
           '    def f(self):\n' \
           '        b = var\n'
    self.mod.write(code)
    offset = self.mod.read().rindex('var')
    self._introduce_parameter(offset, 'p1')
    expected = 'var = 1\n' \
               'class C(object):\n' \
               '    def f(self, p1=var):\n' \
               '        b = p1\n'
    self.assertEquals(expected, self.mod.read())


</t>
<t tx="ekr.20080516150804.3987">class _MockTaskObserver(object):
    @others
</t>
<t tx="ekr.20080516150804.3988">
def __init__(self):
    self.called = 0

</t>
<t tx="ekr.20080516150804.3989">def __call__(self):
    self.called += 1

</t>
<t tx="ekr.20080516150804.3990">class TaskHandleTest(unittest.TestCase):
    @others
</t>
<t tx="ekr.20080516150804.3991">
def test_trivial_case(self):
    handle = rope.base.taskhandle.TaskHandle()
    self.assertFalse(handle.is_stopped())

</t>
<t tx="ekr.20080516150804.3992">def test_stopping(self):
    handle = rope.base.taskhandle.TaskHandle()
    handle.stop()
    self.assertTrue(handle.is_stopped())

</t>
<t tx="ekr.20080516150804.3993">def test_job_sets(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset()
    self.assertEquals([jobs], handle.get_jobsets())

</t>
<t tx="ekr.20080516150804.3994">def test_starting_and_finishing_jobs(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset(name='test job set', count=1)
    jobs.started_job('job1')
    jobs.finished_job()

</t>
<t tx="ekr.20080516150804.3995">@testutils.assert_raises(InterruptedTaskError)
def test_test_checking_status(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset()
    handle.stop()
    jobs.check_status()

</t>
<t tx="ekr.20080516150804.3996">@testutils.assert_raises(InterruptedTaskError)
def test_test_checking_status_when_starting(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset()
    handle.stop()
    jobs.started_job('job1')

</t>
<t tx="ekr.20080516150804.3997">def test_calling_the_observer_after_stopping(self):
    handle = rope.base.taskhandle.TaskHandle()
    observer = _MockTaskObserver()
    handle.add_observer(observer)
    handle.stop()
    self.assertEquals(1, observer.called)

</t>
<t tx="ekr.20080516150804.3998">def test_calling_the_observer_after_creating_job_sets(self):
    handle = rope.base.taskhandle.TaskHandle()
    observer = _MockTaskObserver()
    handle.add_observer(observer)
    jobs = handle.create_jobset()
    self.assertEquals(1, observer.called)

</t>
<t tx="ekr.20080516150804.3999">def test_calling_the_observer_when_starting_and_finishing_jobs(self):
    handle = rope.base.taskhandle.TaskHandle()
    observer = _MockTaskObserver()
    handle.add_observer(observer)
    jobs = handle.create_jobset(name='test job set', count=1)
    jobs.started_job('job1')
    jobs.finished_job()
    self.assertEquals(3, observer.called)

</t>
<t tx="ekr.20080516150804.4000">def test_job_set_get_percent_done(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset(name='test job set', count=2)
    self.assertEquals(0, jobs.get_percent_done())
    jobs.started_job('job1')
    jobs.finished_job()
    self.assertEquals(50, jobs.get_percent_done())
    jobs.started_job('job2')
    jobs.finished_job()
    self.assertEquals(100, jobs.get_percent_done())

</t>
<t tx="ekr.20080516150804.4001">def test_getting_job_name(self):
    handle = rope.base.taskhandle.TaskHandle()
    jobs = handle.create_jobset(name='test job set', count=1)
    self.assertEquals('test job set', jobs.get_name())
    self.assertEquals(None, jobs.get_active_job_name())
    jobs.started_job('job1')
    self.assertEquals('job1', jobs.get_active_job_name())


</t>
<t tx="ekr.20080516150804.4002">def suite():
    result = unittest.TestSuite()
    result.addTests(ropetest.refactor.renametest.suite())
    result.addTests(unittest.makeSuite(
                    ropetest.refactor.extracttest.ExtractMethodTest))
    result.addTests(unittest.makeSuite(IntroduceFactoryTest))
    result.addTests(unittest.makeSuite(
                    ropetest.refactor.movetest.MoveRefactoringTest))
    result.addTests(ropetest.refactor.inlinetest.suite())
    result.addTests(unittest.makeSuite(
                    ropetest.refactor.patchedasttest.PatchedASTTest))
    result.addTests(unittest.makeSuite(EncapsulateFieldTest))
    result.addTests(unittest.makeSuite(LocalToFieldTest))
    result.addTests(unittest.makeSuite(
                    change_signature_test.ChangeSignatureTest))
    result.addTests(unittest.makeSuite(IntroduceParameterTest))
    result.addTests(ropetest.refactor.importutilstest.suite())
    result.addTests(similarfindertest.suite())
    result.addTests(unittest.makeSuite(TaskHandleTest))
    result.addTests(unittest.makeSuite(ropetest.refactor.
                                       restructuretest.RestructureTest))
    result.addTests(unittest.makeSuite(ropetest.refactor.
                                       suitestest.SuiteTest))
    result.addTests(unittest.makeSuite(ropetest.refactor.multiprojecttest.
                                       MultiProjectRefactoringTest))
    result.addTests(unittest.makeSuite(ropetest.refactor.usefunctiontest.
                                       UseFunctionTest))
    return result


</t>
<t tx="ekr.20080516155317.1"></t>
<t tx="ekr.20080603141637.1"></t>
<t tx="ekr.20080603141637.2"></t>
<t tx="ekr.20080603141637.3"></t>
</tnodes>
</leo_file>
