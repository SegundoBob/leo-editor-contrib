<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="4" clone_windows="0"/>
<globals body_outline_ratio="0.52064220183486243">
	<global_window_position top="10" left="322" height="872" width="913"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040104185618"><vh>Recursive import script</vh>
<v t="ekr.20040104185618.1"><vh>importFiles</vh></v>
<v t="ekr.20040104185618.2"><vh>importDir</vh></v>
<v t="ekr.20040104185618.3"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20040104192700"><vh>Find script: remove copyrights</vh></v>
<v t="ekr.20040104225604"><vh>Find script: remove leading blank lines</vh></v>
<v t="ekr.20040104185606" a="E"><vh>Zope-2.6.2-src</vh>
<v t="ekr.20040104194922"><vh>copyright noticies</vh>
<v t="ekr.20040104190843"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20040104194303"><vh>&lt;&lt; c copyright &gt;&gt;</vh></v>
<v t="ekr.20040104194739"><vh>&lt;&lt; c components copyright &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185809"><vh>lib/Components</vh>
<v t="ekr.20040104185809.1"><vh>BTree folder</vh>
<v t="ekr.20040104185809.2"><vh>@file IIBTree.c</vh></v>
<v t="ekr.20040104185809.4"><vh>@file BTree.c</vh>
<v t="ekr.20040104185809.5"><vh>&lt;&lt; BTree #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.6"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185809.7"><vh>newBTreeItems</vh></v>
<v t="ekr.20040104185809.8"><vh>BTreeItems_dealloc</vh></v>
<v t="ekr.20040104185809.9"><vh>BTreeItems_length</vh></v>
<v t="ekr.20040104185809.10"><vh>BTreeItems_concat</vh></v>
<v t="ekr.20040104185809.11"><vh>BTreeItems_repeat</vh></v>
<v t="ekr.20040104185809.12"><vh>BTreeItems_item_BTree</vh></v>
<v t="ekr.20040104185809.13"><vh>BTreeItems_item</vh></v>
<v t="ekr.20040104185809.14"><vh>BTreeItems_slice</vh></v>
<v t="ekr.20040104185809.15"><vh>BTreeItems_ass_item</vh></v>
<v t="ekr.20040104185809.16"><vh>BTreeItems_ass_slice</vh></v>
<v t="ekr.20040104185809.17"><vh>PyMalloc</vh></v>
<v t="ekr.20040104185809.18"><vh>PyRealloc</vh></v>
<v t="ekr.20040104185809.19"><vh>BTree_ini</vh></v>
<v t="ekr.20040104185809.20"><vh>BTree_init</vh></v>
<v t="ekr.20040104185809.21"><vh>bucket_index</vh></v>
<v t="ekr.20040104185809.22"><vh>_bucket_get</vh></v>
<v t="ekr.20040104185809.23"><vh>bucket_get</vh></v>
<v t="ekr.20040104185809.24"><vh>bucket_map</vh></v>
<v t="ekr.20040104185809.25"><vh>BTree_index</vh></v>
<v t="ekr.20040104185809.26"><vh>_BTree_get</vh></v>
<v t="ekr.20040104185809.27"><vh>BTree_get</vh></v>
<v t="ekr.20040104185809.28"><vh>BTree_map</vh></v>
<v t="ekr.20040104185809.29"><vh>_bucket_set</vh></v>
<v t="ekr.20040104185809.30"><vh>bucket_setitem</vh></v>
<v t="ekr.20040104185809.31"><vh>bucket_split</vh></v>
<v t="ekr.20040104185809.32"><vh>BTree_count</vh></v>
<v t="ekr.20040104185809.33"><vh>BTree_split</vh></v>
<v t="ekr.20040104185809.34"><vh>BTree_clone</vh></v>
<v t="ekr.20040104185809.35"><vh>BTree_grow</vh></v>
<v t="ekr.20040104185809.36"><vh>_BTree_set</vh></v>
<v t="ekr.20040104185809.37"><vh>BTree_setitem</vh></v>
<v t="ekr.20040104185809.38"><vh>bucket_keys</vh></v>
<v t="ekr.20040104185809.39"><vh>bucket_values</vh></v>
<v t="ekr.20040104185809.40"><vh>bucket_items</vh></v>
<v t="ekr.20040104185809.41"><vh>bucket__p___reinit__</vh></v>
<v t="ekr.20040104185809.42"><vh>bucket_clear</vh></v>
<v t="ekr.20040104185809.43"><vh>_BTree_clear</vh></v>
<v t="ekr.20040104185809.44"><vh>BTree__p___reinit__</vh></v>
<v t="ekr.20040104185809.45"><vh>BTree_clear</vh></v>
<v t="ekr.20040104185809.46"><vh>bucket_getstate</vh></v>
<v t="ekr.20040104185809.47"><vh>bucket_setstate</vh></v>
<v t="ekr.20040104185809.48"><vh>bucket_has_key</vh></v>
<v t="ekr.20040104185809.49"><vh>bucket_getm</vh></v>
<v t="ekr.20040104185809.50"><vh>_bucket_intset_operation</vh></v>
<v t="ekr.20040104185809.51"><vh>bucket_set_operation</vh></v>
<v t="ekr.20040104185809.52"><vh>bucket_union</vh></v>
<v t="ekr.20040104185809.53"><vh>bucket_intersection</vh></v>
<v t="ekr.20040104185809.54"><vh>bucket_difference</vh></v>
<v t="ekr.20040104185809.55"><vh>BTree_getstate</vh></v>
<v t="ekr.20040104185809.56"><vh>BTree_setstate</vh></v>
<v t="ekr.20040104185809.57"><vh>BTree_elements</vh></v>
<v t="ekr.20040104185809.58"><vh>BTree_keys</vh></v>
<v t="ekr.20040104185809.59"><vh>BTree_values</vh></v>
<v t="ekr.20040104185809.60"><vh>BTree_items</vh></v>
<v t="ekr.20040104185809.61"><vh>BTree_has_key</vh></v>
<v t="ekr.20040104185809.62"><vh>BTree_getm</vh></v>
<v t="ekr.20040104185809.63"><vh>Bucket_dealloc</vh></v>
<v t="ekr.20040104185809.64"><vh>BTree_dealloc</vh></v>
<v t="ekr.20040104185809.65"><vh>Bucket_length</vh></v>
<v t="ekr.20040104185809.66"><vh>BTree_length</vh></v>
<v t="ekr.20040104185809.67"><vh>bucket_repr</vh></v>
<v t="ekr.20040104185809.68"><vh>initIIBTree</vh></v>
</v>
<v t="ekr.20040104185809.69"><vh>@file IOBTree.c</vh></v>
<v t="ekr.20040104185809.71"><vh>@file OIBTree.c</vh></v>
<v t="ekr.20040104185809.73"><vh>@file intSet.c</vh>
<v t="ekr.20040104185809.75"><vh>&lt;&lt; intSet declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.76"><vh>intSet_has_key</vh></v>
<v t="ekr.20040104185809.77"><vh>intSet_grow</vh></v>
<v t="ekr.20040104185809.78"><vh>intSet_modify</vh></v>
<v t="ekr.20040104185809.79"><vh>intSet_insert</vh></v>
<v t="ekr.20040104185809.80"><vh>intSet_remove</vh></v>
<v t="ekr.20040104185809.81"><vh>intSet_clear</vh></v>
<v t="ekr.20040104185809.82"><vh>intSet___getstate__</vh></v>
<v t="ekr.20040104185809.83"><vh>intSet___setstate__</vh></v>
<v t="ekr.20040104185809.84"><vh>intSet_set_operation</vh></v>
<v t="ekr.20040104185809.85"><vh>intSet_add</vh></v>
<v t="ekr.20040104185809.86"><vh>intSet_union</vh></v>
<v t="ekr.20040104185809.87"><vh>intSet_intersection</vh></v>
<v t="ekr.20040104185809.88"><vh>intSet_difference</vh></v>
<v t="ekr.20040104185809.89"><vh>intSet__p___reinit__</vh></v>
<v t="ekr.20040104185809.90"><vh>intSet_dealloc</vh></v>
<v t="ekr.20040104185809.91"><vh>intSet_getattr</vh></v>
<v t="ekr.20040104185809.92"><vh>intSet_length</vh></v>
<v t="ekr.20040104185809.93"><vh>intSet_repeat</vh></v>
<v t="ekr.20040104185809.94"><vh>intSet_item</vh></v>
<v t="ekr.20040104185809.95"><vh>intSet_slice</vh></v>
<v t="ekr.20040104185809.96"><vh>intSet_ass_item</vh></v>
<v t="ekr.20040104185809.97"><vh>intSet_ass_slice</vh></v>
<v t="ekr.20040104185809.98"><vh>initintSet</vh></v>
</v>
</v>
<v t="ekr.20040104185809.99"><vh>ExtensionClass folder</vh>
<v t="ekr.20040104185809.100"><vh>@file LICENSE.txt</vh></v>
<v t="ekr.20040104185809.101"><vh>@file Xaq.py</vh></v>
<v t="ekr.20040104185809.102"><vh>@file setup.py</vh></v>
<v t="ekr.20040104185809.103"><vh>doc</vh>
<v t="ekr.20040104185809.104"><vh>@file Acquisition.html</vh></v>
<v t="ekr.20040104185809.105"><vh>@file ExtensionClass.html</vh></v>
<v t="ekr.20040104185809.106"><vh>@file Installation.html</vh></v>
<v t="ekr.20040104185809.107"><vh>@file MultiMapping.html</vh></v>
<v t="ekr.20040104185809.108"><vh>@file index.html</vh></v>
<v t="ekr.20040104185809.109"><vh>@file release.notes.html</vh></v>
</v>
<v t="ekr.20040104185809.110"><vh>src</vh>
<v t="ekr.20040104185809.111"><vh>@file Acquisition.c</vh>
<v t="ekr.20040104185809.112"><vh>&lt;&lt; Acquisition #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.114"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185809.115"><vh>init_py_names</vh></v>
<v t="ekr.20040104185809.116"><vh>CallMethodO</vh></v>
<v t="ekr.20040104185809.117"><vh>Wrapper__init__</vh></v>
<v t="ekr.20040104185809.118"><vh>__of__</vh></v>
<v t="ekr.20040104185809.119"><vh>newWrapper</vh></v>
<v t="ekr.20040104185809.120"><vh>Wrapper_dealloc</vh></v>
<v t="ekr.20040104185809.121"><vh>Wrapper_special</vh></v>
<v t="ekr.20040104185809.122"><vh>apply_filter</vh></v>
<v t="ekr.20040104185809.123"><vh>Wrapper_findattr</vh></v>
<v t="ekr.20040104185809.124"><vh>Wrapper_acquire</vh></v>
<v t="ekr.20040104185809.125"><vh>Wrapper_getattro</vh></v>
<v t="ekr.20040104185809.126"><vh>Xaq_getattro</vh></v>
<v t="ekr.20040104185809.127"><vh>Wrapper_setattro</vh></v>
<v t="ekr.20040104185809.128"><vh>Wrapper_compare</vh></v>
<v t="ekr.20040104185809.129"><vh>Wrapper_repr</vh></v>
<v t="ekr.20040104185809.130"><vh>Wrapper_str</vh></v>
<v t="ekr.20040104185809.131"><vh>Wrapper_hash</vh></v>
<v t="ekr.20040104185809.132"><vh>Wrapper_call</vh></v>
<v t="ekr.20040104185809.133"><vh>Wrapper_length</vh></v>
<v t="ekr.20040104185809.134"><vh>Wrapper_add</vh></v>
<v t="ekr.20040104185809.135"><vh>Wrapper_mul</vh></v>
<v t="ekr.20040104185809.136"><vh>Wrapper_item</vh></v>
<v t="ekr.20040104185809.137"><vh>Wrapper_slice</vh></v>
<v t="ekr.20040104185809.138"><vh>Wrapper_ass_item</vh></v>
<v t="ekr.20040104185809.139"><vh>Wrapper_ass_slice</vh></v>
<v t="ekr.20040104185809.140"><vh>Wrapper_subscript</vh></v>
<v t="ekr.20040104185809.141"><vh>Wrapper_ass_sub</vh></v>
<v t="ekr.20040104185809.142"><vh>Wrapper_sub</vh></v>
<v t="ekr.20040104185809.143"><vh>Wrapper_div</vh></v>
<v t="ekr.20040104185809.144"><vh>Wrapper_mod</vh></v>
<v t="ekr.20040104185809.145"><vh>Wrapper_divmod</vh></v>
<v t="ekr.20040104185809.146"><vh>Wrapper_pow</vh></v>
<v t="ekr.20040104185809.147"><vh>Wrapper_neg</vh></v>
<v t="ekr.20040104185809.148"><vh>Wrapper_pos</vh></v>
<v t="ekr.20040104185809.149"><vh>Wrapper_abs</vh></v>
<v t="ekr.20040104185809.150"><vh>Wrapper_invert</vh></v>
<v t="ekr.20040104185809.151"><vh>Wrapper_lshift</vh></v>
<v t="ekr.20040104185809.152"><vh>Wrapper_rshift</vh></v>
<v t="ekr.20040104185809.153"><vh>Wrapper_and</vh></v>
<v t="ekr.20040104185809.154"><vh>Wrapper_xor</vh></v>
<v t="ekr.20040104185809.155"><vh>Wrapper_or</vh></v>
<v t="ekr.20040104185809.156"><vh>Wrapper_coerce</vh></v>
<v t="ekr.20040104185809.157"><vh>Wrapper_int</vh></v>
<v t="ekr.20040104185809.158"><vh>Wrapper_long</vh></v>
<v t="ekr.20040104185809.159"><vh>Wrapper_float</vh></v>
<v t="ekr.20040104185809.160"><vh>Wrapper_oct</vh></v>
<v t="ekr.20040104185809.161"><vh>Wrapper_hex</vh></v>
<v t="ekr.20040104185809.162"><vh>Wrapper_nonzero</vh></v>
<v t="ekr.20040104185809.163"><vh>Wrapper_acquire_method</vh></v>
<v t="ekr.20040104185809.164"><vh>Wrapper_inContextOf</vh></v>
<v t="ekr.20040104185809.165"><vh>acquire_of</vh></v>
<v t="ekr.20040104185809.166"><vh>xaq_of</vh></v>
<v t="ekr.20040104185809.167"><vh>capi_aq_acquire</vh></v>
<v t="ekr.20040104185809.168"><vh>module_aq_acquire</vh></v>
<v t="ekr.20040104185809.169"><vh>capi_aq_get</vh></v>
<v t="ekr.20040104185809.170"><vh>module_aq_get</vh></v>
<v t="ekr.20040104185809.171"><vh>capi_aq_iswrapper</vh></v>
<v t="ekr.20040104185809.172"><vh>capi_aq_base</vh></v>
<v t="ekr.20040104185809.173"><vh>module_aq_base</vh></v>
<v t="ekr.20040104185809.174"><vh>capi_aq_parent</vh></v>
<v t="ekr.20040104185809.175"><vh>module_aq_parent</vh></v>
<v t="ekr.20040104185809.176"><vh>capi_aq_self</vh></v>
<v t="ekr.20040104185809.177"><vh>module_aq_self</vh></v>
<v t="ekr.20040104185809.178"><vh>capi_aq_inner</vh></v>
<v t="ekr.20040104185809.179"><vh>module_aq_inner</vh></v>
<v t="ekr.20040104185809.180"><vh>capi_aq_chain</vh></v>
<v t="ekr.20040104185809.181"><vh>module_aq_chain</vh></v>
<v t="ekr.20040104185809.182"><vh>initAcquisition</vh></v>
</v>
<v t="ekr.20040104185809.183"><vh>@file ComputedAttribute.c</vh>
<v t="ekr.20040104185809.185"><vh>&lt;&lt; ComputedAttribute declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.186"><vh>CA__init__</vh></v>
<v t="ekr.20040104185809.187"><vh>CA_dealloc</vh></v>
<v t="ekr.20040104185809.188"><vh>CA_of</vh></v>
<v t="ekr.20040104185809.189"><vh>initComputedAttribute</vh></v>
</v>
<v t="ekr.20040104185809.190"><vh>@file ExtensionClass.c</vh>
<v t="ekr.20040104185809.191"><vh>&lt;&lt; ExtensionClass #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.192"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185809.193"><vh>init_py_names</vh></v>
<v t="ekr.20040104185809.194"><vh>CallMethodO</vh></v>
<v t="ekr.20040104185809.195"><vh>JimErr_Format</vh></v>
<v t="ekr.20040104185809.196"><vh>JimString_Build</vh></v>
<v t="ekr.20040104185809.197"><vh>EC_NewObject</vh></v>
<v t="ekr.20040104185809.198"><vh>CMethod_issubclass</vh></v>
<v t="ekr.20040104185809.199"><vh>newCMethod</vh></v>
<v t="ekr.20040104185809.200"><vh>bindCMethod</vh></v>
<v t="ekr.20040104185809.201"><vh>CMethod_dealloc</vh></v>
<v t="ekr.20040104185809.202"><vh>call_cmethod</vh></v>
<v t="ekr.20040104185809.203"><vh>callCMethodWithHook</vh></v>
<v t="ekr.20040104185809.204"><vh>CMethod_call</vh></v>
<v t="ekr.20040104185809.205"><vh>CMethod_getattro</vh></v>
<v t="ekr.20040104185809.206"><vh>newPMethod</vh></v>
<v t="ekr.20040104185809.207"><vh>bindPMethod</vh></v>
<v t="ekr.20040104185809.208"><vh>PMethod_New</vh></v>
<v t="ekr.20040104185809.209"><vh>PMethod_dealloc</vh></v>
<v t="ekr.20040104185809.210"><vh>callMethodWithPossibleHook</vh></v>
<v t="ekr.20040104185809.211"><vh>call_PMethod</vh></v>
<v t="ekr.20040104185809.212"><vh>PMethod_call</vh></v>
<v t="ekr.20040104185809.213"><vh>PMethod_repr</vh></v>
<v t="ekr.20040104185809.214"><vh>PMethod_getattro</vh></v>
<v t="ekr.20040104185809.215"><vh>CCL_hasattr</vh></v>
<v t="ekr.20040104185809.216"><vh>UNARY_OP</vh></v>
<v t="ekr.20040104185809.217"><vh>call_by_name</vh></v>
<v t="ekr.20040104185809.218"><vh>compare_by_name</vh></v>
<v t="ekr.20040104185809.219"><vh>getattr_by_name</vh></v>
<v t="ekr.20040104185809.220"><vh>setattr_by_name</vh></v>
<v t="ekr.20040104185809.221"><vh>delsetattr_by_name</vh></v>
<v t="ekr.20040104185809.222"><vh>getattro_by_name</vh></v>
<v t="ekr.20040104185809.223"><vh>setattro_by_name</vh></v>
<v t="ekr.20040104185809.224"><vh>delsetattro_by_name</vh></v>
<v t="ekr.20040104185809.225"><vh>length_by_name</vh></v>
<v t="ekr.20040104185809.226"><vh>getitem_by_name</vh></v>
<v t="ekr.20040104185809.227"><vh>initializeBaseExtensionClass</vh></v>
<v t="ekr.20040104185809.228"><vh>CCL_dealloc</vh></v>
<v t="ekr.20040104185809.229"><vh>ExtensionClass_FindInstanceAttribute</vh></v>
<v t="ekr.20040104185809.230"><vh>EC_findiattrs</vh></v>
<v t="ekr.20040104185809.231"><vh>EC_findiattro</vh></v>
<v t="ekr.20040104185809.232"><vh>CCL_getattr2</vh></v>
<v t="ekr.20040104185809.233"><vh>CCL_getattr</vh></v>
<v t="ekr.20040104185809.234"><vh>CCL_reduce</vh></v>
<v t="ekr.20040104185809.235"><vh>CCL_getattro</vh></v>
<v t="ekr.20040104185809.236"><vh>CCL_setattro</vh></v>
<v t="ekr.20040104185809.237"><vh>CCL_call</vh></v>
<v t="ekr.20040104185809.238"><vh>CCL_repr</vh></v>
<v t="ekr.20040104185809.239"><vh>subclass_getspecial</vh></v>
<v t="ekr.20040104185809.240"><vh>subclass_getattro</vh></v>
<v t="ekr.20040104185809.241"><vh>subclass_simple_setattro</vh></v>
<v t="ekr.20040104185809.242"><vh>subclass_simple_setattr</vh></v>
<v t="ekr.20040104185809.243"><vh>subclass_setattr</vh></v>
<v t="ekr.20040104185809.244"><vh>subclass_setattro</vh></v>
<v t="ekr.20040104185809.245"><vh>subclass_compare</vh></v>
<v t="ekr.20040104185809.246"><vh>subclass_hash</vh></v>
<v t="ekr.20040104185809.247"><vh>default_subclass_repr</vh></v>
<v t="ekr.20040104185809.248"><vh>subclass_repr</vh></v>
<v t="ekr.20040104185809.249"><vh>subclass_call</vh></v>
<v t="ekr.20040104185809.250"><vh>subclass_str</vh></v>
<v t="ekr.20040104185809.251"><vh>subclass_add</vh></v>
<v t="ekr.20040104185809.252"><vh>BINSUB</vh></v>
<v t="ekr.20040104185809.253"><vh>BINSUB</vh></v>
<v t="ekr.20040104185809.254"><vh>BINSUB</vh></v>
<v t="ekr.20040104185809.255"><vh>UNSUB</vh></v>
<v t="ekr.20040104185809.256"><vh>subclass_length</vh></v>
<v t="ekr.20040104185809.257"><vh>subclass_item</vh></v>
<v t="ekr.20040104185809.258"><vh>subclass_slice</vh></v>
<v t="ekr.20040104185809.259"><vh>subclass_ass_item</vh></v>
<v t="ekr.20040104185809.260"><vh>subclass_ass_slice</vh></v>
<v t="ekr.20040104185809.261"><vh>subclass_repeat</vh></v>
<v t="ekr.20040104185809.262"><vh>subclass_subscript</vh></v>
<v t="ekr.20040104185809.263"><vh>subclass_ass_subscript</vh></v>
<v t="ekr.20040104185809.264"><vh>dealloc_base</vh></v>
<v t="ekr.20040104185809.265"><vh>subclass_dealloc</vh></v>
<v t="ekr.20040104185809.266"><vh>datafull_baseclassesf</vh></v>
<v t="ekr.20040104185809.267"><vh>datafull_baseclasses</vh></v>
<v t="ekr.20040104185809.268"><vh>datafull_baseclass</vh></v>
<v t="ekr.20040104185809.269"><vh>extension_baseclass</vh></v>
<v t="ekr.20040104185809.270"><vh>subclass_hasattr</vh></v>
<v t="ekr.20040104185809.271"><vh>subclass_init_getattr</vh></v>
<v t="ekr.20040104185809.272"><vh>subclass_init_setattr</vh></v>
<v t="ekr.20040104185809.273"><vh>CopyMethods</vh></v>
<v t="ekr.20040104185809.274"><vh>subclass__init__</vh></v>
<v t="ekr.20040104185809.275"><vh>set_subclass_watcher</vh></v>
<v t="ekr.20040104185809.276"><vh>export_type</vh></v>
<v t="ekr.20040104185809.277"><vh>initExtensionClass</vh></v>
</v>
<v t="ekr.20040104185809.278"><vh>@file MethodObject.c</vh>
<v t="ekr.20040104185809.279"><vh>&lt;&lt; MethodObject #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.280"><vh>of</vh></v>
<v t="ekr.20040104185809.281"><vh>initMethodObject</vh></v>
</v>
<v t="ekr.20040104185809.282"><vh>@file Missing.c</vh>
<v t="ekr.20040104185809.283"><vh>&lt;&lt; Missing #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.284"><vh>&lt;&lt; Missing declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.285"><vh>Missing_dealloc</vh></v>
<v t="ekr.20040104185809.286"><vh>Missing_repr</vh></v>
<v t="ekr.20040104185809.287"><vh>Missing_str</vh></v>
<v t="ekr.20040104185809.288"><vh>Missing_bin</vh></v>
<v t="ekr.20040104185809.289"><vh>Missing_pow</vh></v>
<v t="ekr.20040104185809.290"><vh>Missing_un</vh></v>
<v t="ekr.20040104185809.291"><vh>Missing_nonzero</vh></v>
<v t="ekr.20040104185809.292"><vh>Missing_coerce</vh></v>
<v t="ekr.20040104185809.293"><vh>Missing_reduce</vh></v>
<v t="ekr.20040104185809.294"><vh>Missing_getattr</vh></v>
<v t="ekr.20040104185809.295"><vh>Missing_call</vh></v>
<v t="ekr.20040104185809.296"><vh>Missing_cmp</vh></v>
<v t="ekr.20040104185809.297"><vh>initMissing</vh></v>
</v>
<v t="ekr.20040104185809.298"><vh>@file MultiMapping.c</vh>
<v t="ekr.20040104185809.299"><vh>&lt;&lt; MultiMapping #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.300"><vh>&lt;&lt; MultiMapping declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.301"><vh>MM_push</vh></v>
<v t="ekr.20040104185809.302"><vh>MM_pop</vh></v>
<v t="ekr.20040104185809.303"><vh>MM__init__</vh></v>
<v t="ekr.20040104185809.304"><vh>MM_subscript</vh></v>
<v t="ekr.20040104185809.305"><vh>MM_has_key</vh></v>
<v t="ekr.20040104185809.306"><vh>MM_get</vh></v>
<v t="ekr.20040104185809.307"><vh>MM_dealloc</vh></v>
<v t="ekr.20040104185809.308"><vh>MM_getattr</vh></v>
<v t="ekr.20040104185809.309"><vh>MM_length</vh></v>
<v t="ekr.20040104185809.310"><vh>initMultiMapping</vh></v>
</v>
<v t="ekr.20040104185809.311"><vh>@file Record.c</vh>
<v t="ekr.20040104185809.312"><vh>&lt;&lt; Record #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.313"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185809.314"><vh>Record_init</vh></v>
<v t="ekr.20040104185809.315"><vh>Record___setstate__</vh></v>
<v t="ekr.20040104185809.316"><vh>Record___getstate__</vh></v>
<v t="ekr.20040104185809.317"><vh>Record_deal</vh></v>
<v t="ekr.20040104185809.318"><vh>Record__p_deactivate</vh></v>
<v t="ekr.20040104185809.319"><vh>Record_dealloc</vh></v>
<v t="ekr.20040104185809.320"><vh>Record_getattr</vh></v>
<v t="ekr.20040104185809.321"><vh>Record_setattr</vh></v>
<v t="ekr.20040104185809.322"><vh>pRecord_getattr</vh></v>
<v t="ekr.20040104185809.323"><vh>pRecord_setattr</vh></v>
<v t="ekr.20040104185809.324"><vh>Record_compare</vh></v>
<v t="ekr.20040104185809.325"><vh>Record_concat</vh></v>
<v t="ekr.20040104185809.326"><vh>Record_repeat</vh></v>
<v t="ekr.20040104185809.327"><vh>IndexError</vh></v>
<v t="ekr.20040104185809.328"><vh>Record_item</vh></v>
<v t="ekr.20040104185809.329"><vh>Record_slice</vh></v>
<v t="ekr.20040104185809.330"><vh>Record_ass_item</vh></v>
<v t="ekr.20040104185809.331"><vh>Record_ass_slice</vh></v>
<v t="ekr.20040104185809.332"><vh>Record_subscript</vh></v>
<v t="ekr.20040104185809.333"><vh>Record_ass_sub</vh></v>
<v t="ekr.20040104185809.334"><vh>initRecord</vh></v>
</v>
<v t="ekr.20040104185809.335"><vh>@file Sync.c</vh>
<v t="ekr.20040104185809.337"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185809.338"><vh>Synchronized___call_method__</vh></v>
<v t="ekr.20040104185809.339"><vh>initSync</vh></v>
</v>
<v t="ekr.20040104185809.340"><vh>@file ThreadLock.c</vh>
<v t="ekr.20040104185809.341"><vh>&lt;&lt; ThreadLock #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.342"><vh>&lt;&lt; ThreadLock declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.343"><vh>cacquire</vh></v>
<v t="ekr.20040104185809.344"><vh>acquire</vh></v>
<v t="ekr.20040104185809.345"><vh>crelease</vh></v>
<v t="ekr.20040104185809.346"><vh>release</vh></v>
<v t="ekr.20040104185809.347"><vh>call_method</vh></v>
<v t="ekr.20040104185809.348"><vh>ThreadLock_dealloc</vh></v>
<v t="ekr.20040104185809.349"><vh>ThreadLock_getattr</vh></v>
<v t="ekr.20040104185809.350"><vh>newThreadLockObject</vh></v>
<v t="ekr.20040104185809.351"><vh>ident</vh></v>
<v t="ekr.20040104185809.352"><vh>initThreadLock</vh></v>
</v>
<v t="ekr.20040104185809.353"><vh>@file Xaq.py</vh></v>
</v>
<v t="ekr.20040104185809.354"><vh>test</vh>
<v t="ekr.20040104185809.355"><vh>@file regrtest.py</vh></v>
<v t="ekr.20040104185809.356"><vh>@file test_AqAlg.py</vh>
<v t="ekr.20040104185809.357"><vh>&lt;&lt; test_AqAlg declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.358"><vh>uid</vh></v>
<v t="ekr.20040104185809.359"><vh>pretty</vh></v>
<v t="ekr.20040104185809.360"><vh>class I</vh>
<v t="ekr.20040104185809.361"><vh>__init__</vh></v>
<v t="ekr.20040104185809.362"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185809.363"><vh>show</vh></v>
<v t="ekr.20040104185809.364"><vh>main</vh></v>
</v>
<v t="ekr.20040104185809.365"><vh>@file test_MultiMapping.py</vh></v>
<v t="ekr.20040104185809.366"><vh>@file test_Sync.py</vh>
<v t="ekr.20040104185809.367"><vh>&lt;&lt; test_Sync declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.368"><vh>class P</vh>
<v t="ekr.20040104185809.369"><vh>__init__</vh></v>
<v t="ekr.20040104185809.370"><vh>inc</vh></v>
<v t="ekr.20040104185809.371"><vh>incn</vh></v>
</v>
<v t="ekr.20040104185809.372"><vh>test</vh></v>
<v t="ekr.20040104185809.373"><vh>thread_finished</vh></v>
</v>
<v t="ekr.20040104185809.374"><vh>@file test_ThreadLock.py</vh>
<v t="ekr.20040104185809.375"><vh>&lt;&lt; test_ThreadLock declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.376"><vh>class P</vh>
<v t="ekr.20040104185809.377"><vh>__oldcall_method__</vh></v>
<v t="ekr.20040104185809.378"><vh>__init__</vh></v>
<v t="ekr.20040104185809.379"><vh>inc</vh></v>
<v t="ekr.20040104185809.380"><vh>incn</vh></v>
</v>
<v t="ekr.20040104185809.381"><vh>test</vh></v>
<v t="ekr.20040104185809.382"><vh>thread_finished</vh></v>
</v>
<v t="ekr.20040104185809.383"><vh>@file test_acquisition.py</vh>
<v t="ekr.20040104185809.384"><vh>&lt;&lt; test_acquisition declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.385"><vh>class B</vh>
<v t="ekr.20040104185809.386"><vh>&lt;&lt; class B declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185809.387"><vh>class A</vh>
<v t="ekr.20040104185809.388"><vh>hi</vh></v>
</v>
<v t="ekr.20040104185809.389"><vh>checkContext</vh></v>
</v>
<v t="ekr.20040104185809.390"><vh>@file test_add.py</vh>
<v t="ekr.20040104185809.391"><vh>&lt;&lt; test_add declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.392"><vh>class foo</vh>
<v t="ekr.20040104185809.393"><vh>__add__</vh></v>
</v>
</v>
<v t="ekr.20040104185809.394"><vh>@file test_binding.py</vh>
<v t="ekr.20040104185809.395"><vh>&lt;&lt; test_binding declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.396"><vh>class foo</vh>
<v t="ekr.20040104185809.397"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185809.398"><vh>class bar</vh>
<v t="ekr.20040104185809.399"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20040104185809.400"><vh>@file test_explicit_acquisition.py</vh>
<v t="ekr.20040104185809.401"><vh>&lt;&lt; test_explicit_acquisition declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.402"><vh>class B</vh>
<v t="ekr.20040104185809.403"><vh>&lt;&lt; class B declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185809.404"><vh>class A</vh>
<v t="ekr.20040104185809.405"><vh>hi</vh></v>
</v>
</v>
<v t="ekr.20040104185809.406"><vh>@file test_method_hook.py</vh>
<v t="ekr.20040104185809.407"><vh>&lt;&lt; test_method_hook declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.408"><vh>class C</vh>
<v t="ekr.20040104185809.409"><vh>__call_method__</vh></v>
<v t="ekr.20040104185809.410"><vh>hi</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040104185809.411"><vh>cPickle  folder</vh>
<v t="ekr.20040104185809.412"><vh>@file cPickle.c</vh>
<v t="ekr.20040104185809.413"><vh>&lt;&lt; cPickle #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.414"><vh>&lt;&lt; cPickle declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185809.415"><vh>Pdata_dealloc</vh></v>
<v t="ekr.20040104185809.416"><vh>Pdata_New</vh></v>
<v t="ekr.20040104185809.417"><vh>stackUnderflow</vh></v>
<v t="ekr.20040104185809.418"><vh>Pdata_clear</vh></v>
<v t="ekr.20040104185809.419"><vh>Pdata_grow</vh></v>
<v t="ekr.20040104185809.420"><vh>Pdata_popTuple</vh></v>
<v t="ekr.20040104185809.421"><vh>Pdata_popList</vh></v>
<v t="ekr.20040104185809.422"><vh>cPickle_PyMapping_HasKey</vh></v>
<v t="ekr.20040104195608"><vh>More... (big)</vh></v>
</v>
<v t="ekr.20040104185809.423"><vh>@file cStringIO.c</vh>
<v t="ekr.20040104185809.424"><vh>&lt;&lt; cStringIO #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185809.425"><vh>&lt;&lt; cStringIO declarations &gt;&gt;</vh></v>
<v t="ekr.20040104205714"><vh>&lt;&lt; cStringIO_module_documentation &gt;&gt;</vh></v>
<v t="ekr.20040104185809.426"><vh>IO__opencheck</vh></v>
<v t="ekr.20040104185809.427"><vh>IO_flush</vh></v>
<v t="ekr.20040104185809.428"><vh>IO_cgetval</vh></v>
<v t="ekr.20040104185809.429"><vh>IO_getval</vh></v>
<v t="ekr.20040104185809.430"><vh>IO_isatty</vh></v>
<v t="ekr.20040104185809.431"><vh>IO_cread</vh></v>
<v t="ekr.20040104185809.432"><vh>IO_read</vh></v>
<v t="ekr.20040104185809.433"><vh>IO_creadline</vh></v>
<v t="ekr.20040104185809.434"><vh>IO_readline</vh></v>
<v t="ekr.20040104185809.435"><vh>IO_readlines</vh></v>
<v t="ekr.20040104185809.436"><vh>IO_reset</vh></v>
<v t="ekr.20040104185809.437"><vh>IO_tell</vh></v>
<v t="ekr.20040104185809.438"><vh>IO_truncate</vh></v>
<v t="ekr.20040104185809.439"><vh>O_seek</vh></v>
<v t="ekr.20040104185809.440"><vh>O_cwrite</vh></v>
<v t="ekr.20040104185809.441"><vh>O_write</vh></v>
<v t="ekr.20040104185809.442"><vh>O_close</vh></v>
<v t="ekr.20040104185809.443"><vh>O_writelines</vh></v>
<v t="ekr.20040104185809.444"><vh>O_dealloc</vh></v>
<v t="ekr.20040104185809.445"><vh>O_getattr</vh></v>
<v t="ekr.20040104185809.446"><vh>O_setattr</vh></v>
<v t="ekr.20040104185809.447"><vh>newOobject</vh></v>
<v t="ekr.20040104185809.448"><vh>I_close</vh></v>
<v t="ekr.20040104185809.449"><vh>I_seek</vh></v>
<v t="ekr.20040104185809.450"><vh>I_dealloc</vh></v>
<v t="ekr.20040104185809.451"><vh>I_getattr</vh></v>
<v t="ekr.20040104185809.452"><vh>newIobject</vh></v>
<v t="ekr.20040104185809.453"><vh>IO_StringIO</vh></v>
<v t="ekr.20040104185809.454"><vh>DL_EXPORT</vh></v>
</v>
<v t="ekr.20040104185809.455"><vh>@file copy_reg.py</vh>
<v t="ekr.20040104185809.457"><vh>pickle</vh></v>
<v t="ekr.20040104185809.458"><vh>constructor</vh></v>
<v t="ekr.20040104185809.459"><vh>pickle_complex</vh></v>
</v>
</v>
<v t="ekr.20040104185809.460"><vh>initgroups folder</vh>
<v t="ekr.20040104185809.461"><vh>@file initgroups.c</vh>
<v t="ekr.20040104185809.463"><vh>initgroups_initgroups</vh></v>
<v t="ekr.20040104185809.464"><vh>initinitgroups</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913" a="E"><vh>lib/python (marked nodes are just as they were imported)</vh>
<v t="ekr.20040104190843.1"><vh>top level</vh>
<v t="ekr.20040104185913.1"><vh>@file Globals.py</vh>
<v t="ekr.20040104214040"><vh>&lt;&lt; global imports &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2"><vh>@file ImageFile.py</vh></v>
<v t="ekr.20040104185913.3"><vh>@file LOG.py</vh></v>
<v t="ekr.20040104185913.4"><vh>@file Lifetime.py</vh>
<v t="ekr.20040104185913.6"><vh>shutdown</vh></v>
<v t="ekr.20040104185913.7"><vh>loop</vh></v>
<v t="ekr.20040104185913.8"><vh>lifetime_loop</vh></v>
<v t="ekr.20040104185913.9"><vh>graceful_shutdown_loop</vh></v>
</v>
<v t="ekr.20040104185913.10"><vh>@file Main.py</vh>
<v t="ekr.20040104214040.1"><vh>&lt;&lt; main imports &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.11"><vh>@file dcdb.py</vh></v>
<v t="ekr.20040104185913.14"><vh>@file ts_regex.py</vh>
<v t="ekr.20040104185913.15"><vh>&lt;&lt; ts_regex imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.16"><vh>class allocate_lock</vh>
<v t="ekr.20040104185913.17"><vh>acquire</vh></v>
<v t="ekr.20040104185913.18"><vh>release</vh></v>
</v>
<v t="ekr.20040104185913.19"><vh>class SafeFunction</vh>
<v t="ekr.20040104185913.20"><vh>&lt;&lt; class SafeFunction declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.21"><vh>__init__</vh></v>
<v t="ekr.20040104185913.22"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.23"><vh>class compile</vh>
<v t="ekr.20040104185913.24"><vh>&lt;&lt; class compile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.25"><vh>__init__</vh></v>
<v t="ekr.20040104185913.26"><vh>_init</vh></v>
<v t="ekr.20040104185913.27"><vh>match</vh></v>
<v t="ekr.20040104185913.28"><vh>search</vh></v>
<v t="ekr.20040104185913.29"><vh>search_group</vh></v>
<v t="ekr.20040104185913.30"><vh>match_group</vh></v>
<v t="ekr.20040104185913.31"><vh>search_regs</vh></v>
<v t="ekr.20040104185913.32"><vh>match_regs</vh></v>
</v>
<v t="ekr.20040104185913.33"><vh>class symcomp</vh>
<v t="ekr.20040104185913.34"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.35"><vh>@file xmlrpclib.py</vh>
<v t="ekr.20040104214837"><vh>&lt;&lt; xmlrpclib versions &gt;&gt;</vh></v>
<v t="ekr.20040104214837.1"><vh>&lt;&lt; xmlrpclib copyright &gt;&gt;</vh></v>
<v t="ekr.20040104214837.2"><vh>&lt;&lt; xmlrpclib todo &gt;&gt;</vh></v>
<v t="ekr.20040104214837.3"><vh>&lt;&lt; xmlrpclib docstring &gt;&gt;</vh></v>
<v t="ekr.20040104185913.36"><vh>&lt;&lt; xmlrpclib imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.37"><vh>_decode</vh></v>
<v t="ekr.20040104185913.38"><vh>escape</vh></v>
<v t="ekr.20040104185913.39"><vh>_stringify</vh></v>
<v t="ekr.20040104185913.41"><vh>class Error</vh>
<v t="ekr.20040104185913.42"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.43"><vh>class ProtocolError</vh>
<v t="ekr.20040104185913.44"><vh>__init__</vh></v>
<v t="ekr.20040104185913.45"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.46"><vh>class ResponseError</vh>
<v t="ekr.20040104185913.47"><vh>&lt;&lt; class ResponseError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.48"><vh>class Fault</vh>
<v t="ekr.20040104185913.49"><vh>__init__</vh></v>
<v t="ekr.20040104185913.50"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104215044"><vh>Special values...</vh>
<v t="ekr.20040104185913.51"><vh>class Boolean</vh>
<v t="ekr.20040104185913.52"><vh>__init__</vh></v>
<v t="ekr.20040104185913.53"><vh>encode</vh></v>
<v t="ekr.20040104185913.54"><vh>__cmp__</vh></v>
<v t="ekr.20040104185913.55"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.56"><vh>__int__</vh></v>
<v t="ekr.20040104185913.57"><vh>__nonzero__</vh></v>
</v>
<v t="ekr.20040104185913.59"><vh>class DateTime</vh>
<v t="ekr.20040104185913.60"><vh>__init__</vh></v>
<v t="ekr.20040104185913.61"><vh>__cmp__</vh></v>
<v t="ekr.20040104185913.62"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.63"><vh>decode</vh></v>
<v t="ekr.20040104185913.64"><vh>encode</vh></v>
</v>
<v t="ekr.20040104185913.66"><vh>class Binary</vh>
<v t="ekr.20040104185913.67"><vh>__init__</vh></v>
<v t="ekr.20040104185913.68"><vh>__cmp__</vh></v>
<v t="ekr.20040104185913.69"><vh>decode</vh></v>
<v t="ekr.20040104185913.70"><vh>encode</vh></v>
</v>
</v>
<v t="ekr.20040104215044.1"><vh>xml parsers...</vh>
<v t="ekr.20040104185913.72"><vh>class SgmlopParser</vh>
<v t="ekr.20040104185913.73"><vh>__init__</vh></v>
<v t="ekr.20040104185913.74"><vh>close</vh></v>
<v t="ekr.20040104185913.75"><vh>handle_proc</vh></v>
<v t="ekr.20040104185913.76"><vh>handle_entityref</vh></v>
</v>
<v t="ekr.20040104185913.77"><vh>class ExpatParser</vh>
<v t="ekr.20040104185913.79"><vh>__init__</vh></v>
<v t="ekr.20040104185913.80"><vh>feed</vh></v>
<v t="ekr.20040104185913.81"><vh>close</vh></v>
</v>
<v t="ekr.20040104185913.82"><vh>class SlowParser</vh>
<v t="ekr.20040104185913.84"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104215235"><vh>marshalling and unmarshalling code</vh>
<v t="ekr.20040104185913.85"><vh>class Marshaller</vh>
<v t="ekr.20040104185913.86"><vh>&lt;&lt; class Marshaller declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.87"><vh>__init__</vh></v>
<v t="ekr.20040104185913.88"><vh>dumps</vh></v>
<v t="ekr.20040104185913.89"><vh>__dump</vh></v>
<v t="ekr.20040104185913.90"><vh>dump_int</vh></v>
<v t="ekr.20040104185913.91"><vh>dump_long</vh></v>
<v t="ekr.20040104185913.92"><vh>dump_double</vh></v>
<v t="ekr.20040104185913.93"><vh>dump_string</vh></v>
<v t="ekr.20040104185913.94"><vh>dump_unicode</vh></v>
<v t="ekr.20040104185913.95"><vh>dump_none</vh></v>
<v t="ekr.20040104185913.96"><vh>opencontainer</vh></v>
<v t="ekr.20040104185913.97"><vh>closecontainer</vh></v>
<v t="ekr.20040104185913.98"><vh>dump_array</vh></v>
<v t="ekr.20040104185913.99"><vh>dump_struct</vh></v>
<v t="ekr.20040104185913.100"><vh>dump_instance</vh></v>
</v>
<v t="ekr.20040104185913.101"><vh>class Unmarshaller</vh>
<v t="ekr.20040104185913.102"><vh>&lt;&lt; class Unmarshaller declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.103"><vh>__init__</vh></v>
<v t="ekr.20040104185913.104"><vh>close</vh></v>
<v t="ekr.20040104185913.105"><vh>getmethodname</vh></v>
<v t="ekr.20040104185913.106"><vh>xml</vh></v>
<v t="ekr.20040104185913.107"><vh>start</vh></v>
<v t="ekr.20040104185913.108"><vh>data</vh></v>
<v t="ekr.20040104185913.109"><vh>end</vh></v>
<v t="ekr.20040104185913.110"><vh>end_dispatch</vh></v>
<v t="ekr.20040104185913.111"><vh>end_boolean</vh></v>
<v t="ekr.20040104185913.112"><vh>end_int</vh></v>
<v t="ekr.20040104185913.113"><vh>end_double</vh></v>
<v t="ekr.20040104185913.114"><vh>end_string</vh></v>
<v t="ekr.20040104185913.115"><vh>end_array</vh></v>
<v t="ekr.20040104185913.116"><vh>end_struct</vh></v>
<v t="ekr.20040104185913.117"><vh>end_base64</vh></v>
<v t="ekr.20040104185913.118"><vh>end_dateTime</vh></v>
<v t="ekr.20040104185913.119"><vh>end_value</vh></v>
<v t="ekr.20040104185913.120"><vh>end_params</vh></v>
<v t="ekr.20040104185913.121"><vh>end_fault</vh></v>
<v t="ekr.20040104185913.122"><vh>end_methodName</vh></v>
</v>
</v>
<v t="ekr.20040104214837.4"><vh>Convenience functions...</vh>
<v t="ekr.20040104185913.123"><vh>getparser</vh></v>
<v t="ekr.20040104185913.124"><vh>dumps</vh></v>
<v t="ekr.20040104185913.125"><vh>loads</vh></v>
</v>
<v t="ekr.20040104185913.126"><vh>class _Method</vh>
<v t="ekr.20040104185913.127"><vh>&lt;&lt; class _Method declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.128"><vh>__init__</vh></v>
<v t="ekr.20040104185913.129"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.130"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.131"><vh>class Transport</vh>
<v t="ekr.20040104185913.132"><vh>&lt;&lt; class Transport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.133"><vh>request</vh></v>
<v t="ekr.20040104185913.134"><vh>getparser</vh></v>
<v t="ekr.20040104185913.135"><vh>make_connection</vh></v>
<v t="ekr.20040104185913.136"><vh>send_request</vh></v>
<v t="ekr.20040104185913.137"><vh>send_host</vh></v>
<v t="ekr.20040104185913.138"><vh>send_user_agent</vh></v>
<v t="ekr.20040104185913.139"><vh>send_content</vh></v>
<v t="ekr.20040104185913.140"><vh>parse_response</vh></v>
</v>
<v t="ekr.20040104185913.141"><vh>class SafeTransport</vh>
<v t="ekr.20040104185913.142"><vh>make_connection</vh></v>
<v t="ekr.20040104185913.143"><vh>send_host</vh></v>
</v>
<v t="ekr.20040104185913.144"><vh>class ServerProxy</vh>
<v t="ekr.20040104185913.145"><vh>__init__</vh></v>
<v t="ekr.20040104185913.146"><vh>__request</vh></v>
<v t="ekr.20040104185913.147"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.148"><vh>__getattr__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.149"><vh>@file version.txt</vh></v>
</v>
<v t="ekr.20040104185913.150" a="E"><vh>AccessControl</vh>
<v t="ekr.20040104190843.2" a="EV"><vh>top level</vh>
<v t="ekr.20040104185913.151"><vh>@file AccessControl.txt</vh></v>
<v t="ekr.20040104185913.152"><vh>@file AuthEncoding.py  (import problems)</vh>
<v t="ekr.20040104185913.154"><vh>class PasswordEncryptionScheme</vh>
<v t="ekr.20040104185913.155"><vh>encrypt</vh></v>
<v t="ekr.20040104185913.156"><vh>validate</vh></v>
</v>
<v t="ekr.20040104185913.157"><vh>registerScheme</vh></v>
<v t="ekr.20040104185913.158"><vh>listSchemes</vh></v>
<v t="ekr.20040104185913.159"><vh>class SSHADigestScheme</vh>
<v t="ekr.20040104185913.160"><vh>&lt;&lt; class SSHADigestScheme declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.161"><vh>generate_salt</vh></v>
<v t="ekr.20040104185913.162"><vh>encrypt</vh></v>
<v t="ekr.20040104185913.163"><vh>validate</vh></v>
</v>
<v t="ekr.20040104185913.164"><vh>class SHADigestScheme</vh>
<v t="ekr.20040104185913.165"><vh>encrypt</vh></v>
<v t="ekr.20040104185913.166"><vh>validate</vh></v>
</v>
<v t="ekr.20040104185913.167"><vh>class CryptDigestScheme</vh>
<v t="ekr.20040104185913.168"><vh>generate_salt</vh></v>
<v t="ekr.20040104185913.169"><vh>encrypt</vh></v>
<v t="ekr.20040104185913.170"><vh>validate</vh></v>
</v>
<v t="ekr.20040104185913.171"><vh>pw_validate</vh></v>
<v t="ekr.20040104185913.172"><vh>is_encrypted</vh></v>
<v t="ekr.20040104185913.173"><vh>pw_encrypt</vh></v>
</v>
<v t="ekr.20040104185913.174"><vh>@file DTML.py</vh>
<v t="ekr.20040104185913.176"><vh>class RestrictedDTML</vh>
<v t="ekr.20040104185913.177"><vh>guarded_getattr</vh></v>
<v t="ekr.20040104185913.178"><vh>guarded_getitem</vh></v>
</v>
<v t="ekr.20040104185913.179"><vh>class RestrictedDTML</vh></v>
<v t="ekr.20040104185913.181"><vh>class DTMLSecurityAPI</vh>
<v t="ekr.20040104185913.182"><vh>SecurityValidate</vh></v>
<v t="ekr.20040104185913.183"><vh>SecurityValidateValue</vh></v>
<v t="ekr.20040104185913.184"><vh>SecurityCheckPermission</vh></v>
<v t="ekr.20040104185913.185"><vh>SecurityGetUser</vh></v>
<v t="ekr.20040104185913.186"><vh>SecurityCalledByExecutable</vh></v>
</v>
</v>
<v t="ekr.20040104185913.187"><vh>@file IUserFolder.py</vh>
<v t="ekr.20040104185913.188"><vh>class IStandardUserFolder</vh>
<v t="ekr.20040104185913.189"><vh>getUser</vh></v>
<v t="ekr.20040104185913.190"><vh>getUsers</vh></v>
<v t="ekr.20040104185913.191"><vh>getUserNames</vh></v>
</v>
</v>
<v t="ekr.20040104185913.192"><vh>@file Owned.py</vh>
<v t="ekr.20040104185913.194"><vh>ownableFilter</vh></v>
<v t="ekr.20040104185913.195"><vh>class Owned</vh>
<v t="ekr.20040104185913.196"><vh>&lt;&lt; class Owned declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.197"><vh>owner_info</vh></v>
<v t="ekr.20040104185913.198"><vh>getOwner</vh></v>
<v t="ekr.20040104185913.199"><vh>changeOwnership</vh></v>
<v t="ekr.20040104185913.200"><vh>userCanTakeOwnership</vh></v>
<v t="ekr.20040104185913.201"><vh>manage_takeOwnership</vh></v>
<v t="ekr.20040104185913.202"><vh>manage_changeOwnershipType</vh></v>
<v t="ekr.20040104185913.203"><vh>_deleteOwnershipAfterAdd</vh></v>
<v t="ekr.20040104185913.204"><vh>manage_fixupOwnershipAfterAdd</vh></v>
</v>
<v t="ekr.20040104185913.205"><vh>class EmergencyUserCannotOwn</vh></v>
<v t="ekr.20040104185913.207"><vh>class EditUnowned</vh></v>
<v t="ekr.20040104185913.209"><vh>absattr</vh></v>
<v t="ekr.20040104185913.210"><vh>ownerInfo</vh></v>
</v>
<v t="ekr.20040104185913.211"><vh>@file Permission.py</vh>
<v t="ekr.20040104185913.213"><vh>pname</vh></v>
<v t="ekr.20040104185913.214"><vh>class Permission</vh>
<v t="ekr.20040104185913.216"><vh>__init__</vh></v>
<v t="ekr.20040104185913.217"><vh>getRoles</vh></v>
<v t="ekr.20040104185913.218"><vh>setRoles</vh></v>
<v t="ekr.20040104185913.219"><vh>setRole</vh></v>
<v t="ekr.20040104185913.220"><vh>__len__</vh></v>
<v t="ekr.20040104185913.221"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.222"><vh>registerPermissions</vh></v>
</v>
<v t="ekr.20040104185913.223"><vh>@file PermissionMapping.py</vh>
<v t="ekr.20040104185913.225"><vh>class RoleManager</vh>
<v t="ekr.20040104185913.226"><vh>manage_getPermissionMapping</vh></v>
<v t="ekr.20040104185913.227"><vh>manage_setPermissionMapping</vh></v>
<v t="ekr.20040104185913.228"><vh>_isBeingUsedAsAMethod</vh></v>
<v t="ekr.20040104185913.229"><vh>_isBeingAccessedAsZClassDefinedInstanceMethod</vh></v>
</v>
<v t="ekr.20040104185913.230"><vh>getPermissionMapping</vh></v>
<v t="ekr.20040104185913.231"><vh>setPermissionMapping</vh></v>
<v t="ekr.20040104185913.232"><vh>class PM</vh>
<v t="ekr.20040104185913.234"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040104185913.235"><vh>aqwrap</vh></v>
<v t="ekr.20040104185913.236"><vh>class Rewrapper</vh>
<v t="ekr.20040104185913.237"><vh>__of__</vh></v>
<v t="ekr.20040104185913.238"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.239"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.240"><vh>@file PermissionRole.py</vh>
<v t="ekr.20040104185913.241"><vh>&lt;&lt; PermissionRole imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.242"><vh>rolesForPermissionOn</vh></v>
<v t="ekr.20040104185913.243"><vh>class PermissionRole</vh>
<v t="ekr.20040104185913.244"><vh>__init__</vh></v>
<v t="ekr.20040104185913.245"><vh>__of__</vh></v>
</v>
<v t="ekr.20040104185913.246"><vh>class imPermissionRole</vh>
<v t="ekr.20040104185913.247"><vh>__of__</vh></v>
<v t="ekr.20040104185913.248"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.249"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.250"><vh>main (test functions)</vh></v>
</v>
<v t="ekr.20040104185913.251"><vh>@file Permissions.py</vh></v>
<v t="ekr.20040104185913.252"><vh>@file Role.py</vh>
<v t="ekr.20040104185913.253"><vh>&lt;&lt; Role imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.254"><vh>_isBeingUsedAsAMethod</vh></v>
<v t="ekr.20040104185913.255"><vh>_isNotBeingUsedAsAMethod</vh></v>
<v t="ekr.20040104185913.256"><vh>class RoleManager</vh>
<v t="ekr.20040104185913.257"><vh>&lt;&lt; class RoleManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.258"><vh>ac_inherited_permissions</vh></v>
<v t="ekr.20040104185913.259"><vh>permission_settings</vh></v>
<v t="ekr.20040104185913.260"><vh>manage_role</vh></v>
<v t="ekr.20040104185913.261"><vh>manage_acquiredPermissions</vh></v>
<v t="ekr.20040104185913.262"><vh>manage_permission</vh></v>
<v t="ekr.20040104185913.263"><vh>manage_access</vh></v>
<v t="ekr.20040104185913.264"><vh>manage_changePermissions</vh></v>
<v t="ekr.20040104185913.265"><vh>permissionsOfRole</vh></v>
<v t="ekr.20040104185913.266"><vh>rolesOfPermission</vh></v>
<v t="ekr.20040104185913.267"><vh>acquiredRolesAreUsedBy</vh></v>
<v t="ekr.20040104185913.268"><vh>has_local_roles</vh></v>
<v t="ekr.20040104185913.269"><vh>get_local_roles</vh></v>
<v t="ekr.20040104185913.270"><vh>users_with_local_role</vh></v>
<v t="ekr.20040104185913.271"><vh>get_valid_userids</vh></v>
<v t="ekr.20040104185913.272"><vh>get_local_roles_for_userid</vh></v>
<v t="ekr.20040104185913.273"><vh>manage_addLocalRoles</vh></v>
<v t="ekr.20040104185913.274"><vh>manage_setLocalRoles</vh></v>
<v t="ekr.20040104185913.275"><vh>manage_delLocalRoles</vh></v>
<v t="ekr.20040104185913.276"><vh>access_debug_info</vh></v>
<v t="ekr.20040104185913.277"><vh>valid_roles</vh></v>
<v t="ekr.20040104185913.278"><vh>validate_roles</vh></v>
<v t="ekr.20040104185913.279"><vh>userdefined_roles</vh></v>
<v t="ekr.20040104185913.280"><vh>manage_defined_roles</vh></v>
<v t="ekr.20040104185913.281"><vh>_addRole</vh></v>
<v t="ekr.20040104185913.282"><vh>_delRoles</vh></v>
<v t="ekr.20040104185913.283"><vh>_has_user_defined_role</vh></v>
<v t="ekr.20040104185913.284"><vh>manage_editRoles</vh></v>
<v t="ekr.20040104185913.285"><vh>_setRoles</vh></v>
<v t="ekr.20040104185913.286"><vh>possible_permissions</vh></v>
</v>
<v t="ekr.20040104185913.287"><vh>reqattr</vh></v>
<v t="ekr.20040104185913.288"><vh>classattr</vh></v>
<v t="ekr.20040104185913.289"><vh>instance_dict</vh></v>
<v t="ekr.20040104185913.290"><vh>class_dict</vh></v>
<v t="ekr.20040104185913.291"><vh>instance_attrs</vh></v>
<v t="ekr.20040104185913.292"><vh>class_attrs</vh></v>
<v t="ekr.20040104185913.293"><vh>gather_permissions</vh></v>
</v>
<v t="ekr.20040104185913.294"><vh>@file SecurityInfo.py</vh>
<v t="ekr.20040104185913.295"><vh>&lt;&lt; SecurityInfo docstring &gt;&gt;</vh></v>
<v t="ekr.20040104185913.296"><vh>class SecurityInfo</vh>
<v t="ekr.20040104185913.298"><vh>__init__</vh></v>
<v t="ekr.20040104185913.299"><vh>_setaccess</vh></v>
<v t="ekr.20040104185913.300"><vh>declarePublic</vh></v>
<v t="ekr.20040104185913.301"><vh>declarePrivate</vh></v>
<v t="ekr.20040104185913.302"><vh>declareProtected</vh></v>
<v t="ekr.20040104185913.303"><vh>declareObjectPublic</vh></v>
<v t="ekr.20040104185913.304"><vh>declareObjectPrivate</vh></v>
<v t="ekr.20040104185913.305"><vh>declareObjectProtected</vh></v>
<v t="ekr.20040104185913.306"><vh>setPermissionDefault</vh></v>
<v t="ekr.20040104185913.307"><vh>setDefaultAccess</vh></v>
</v>
<v t="ekr.20040104185913.308"><vh>class ClassSecurityInfo</vh>
<v t="ekr.20040104185913.310"><vh>apply</vh></v>
</v>
<v t="ekr.20040104185913.311"><vh>class ClassSecurityInformation</vh></v>
<v t="ekr.20040104185913.313"><vh>secureModule</vh></v>
<v t="ekr.20040104185913.314"><vh>ModuleSecurityInfo</vh></v>
<v t="ekr.20040104185913.315"><vh>class _ModuleSecurityInfo</vh>
<v t="ekr.20040104185913.317"><vh>__init__</vh></v>
<v t="ekr.20040104185913.318"><vh>__call__</vh></v>
<v t="ekr.20040104185913.319"><vh>apply</vh></v>
<v t="ekr.20040104185913.320"><vh>declareProtected</vh></v>
<v t="ekr.20040104185913.321"><vh>declareObjectProtected</vh></v>
<v t="ekr.20040104185913.322"><vh>setDefaultRoles</vh></v>
</v>
<v t="ekr.20040104185913.323"><vh>allow_module</vh></v>
<v t="ekr.20040104185913.324"><vh>allow_class</vh></v>
</v>
<v t="ekr.20040104185913.325"><vh>@file SecurityManagement.py</vh>
<v t="ekr.20040104185913.327"><vh>getSecurityManager</vh></v>
<v t="ekr.20040104185913.328"><vh>newSecurityManager</vh></v>
<v t="ekr.20040104185913.329"><vh>noSecurityManager</vh></v>
<v t="ekr.20040104185913.330"><vh>setSecurityPolicy</vh></v>
<v t="ekr.20040104185913.331"><vh>class SecurityContext</vh>
<v t="ekr.20040104185913.332"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.333"><vh>@file SecurityManager.py</vh>
<v t="ekr.20040104185913.335"><vh>setSecurityPolicy</vh></v>
<v t="ekr.20040104185913.336"><vh>class SecurityManager</vh>
<v t="ekr.20040104185913.337"><vh>&lt;&lt; class SecurityManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.338"><vh>__init__</vh></v>
<v t="ekr.20040104185913.339"><vh>validate</vh></v>
<v t="ekr.20040104185913.340"><vh>DTMLValidate</vh></v>
<v t="ekr.20040104185913.341"><vh>validateValue</vh></v>
<v t="ekr.20040104185913.342"><vh>checkPermission</vh></v>
<v t="ekr.20040104185913.343"><vh>addContext</vh></v>
<v t="ekr.20040104185913.344"><vh>removeContext</vh></v>
<v t="ekr.20040104185913.345"><vh>getUser</vh></v>
<v t="ekr.20040104185913.346"><vh>calledByExecutable</vh></v>
</v>
<v t="ekr.20040104185913.347"><vh>class SecurityManager</vh></v>
</v>
<v t="ekr.20040104185913.348"><vh>@file SimpleObjectPolicies.py</vh>
<v t="ekr.20040104185913.350"><vh>class _dummy_class</vh></v>
<v t="ekr.20040104185913.351"><vh>allow_type</vh></v>
</v>
<v t="ekr.20040104185913.352"><vh>@file SpecialUsers.py</vh></v>
<v t="ekr.20040104185913.353"><vh>@file User.py</vh>
<v t="ekr.20040104185913.354"><vh>&lt;&lt; User imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.355"><vh>class BasicUser</vh>
<v t="ekr.20040104185913.356"><vh>&lt;&lt; class BasicUser declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.357"><vh>__allow_access_to_unprotected_subobjects__</vh></v>
<v t="ekr.20040104185913.358"><vh>__init__</vh></v>
<v t="ekr.20040104185913.359"><vh>getUserName</vh></v>
<v t="ekr.20040104185913.360"><vh>getId</vh></v>
<v t="ekr.20040104185913.361"><vh>_getPassword</vh></v>
<v t="ekr.20040104185913.362"><vh>getRoles</vh></v>
<v t="ekr.20040104185913.363"><vh>getRolesInContext</vh></v>
<v t="ekr.20040104185913.364"><vh>getDomains</vh></v>
<v t="ekr.20040104185913.365"><vh>authenticate</vh></v>
<v t="ekr.20040104185913.366"><vh>_shared_roles</vh></v>
<v t="ekr.20040104185913.367"><vh>_check_context</vh></v>
<v t="ekr.20040104185913.368"><vh>allowed</vh></v>
<v t="ekr.20040104185913.369"><vh>hasRole</vh></v>
<v t="ekr.20040104185913.370"><vh>has_role</vh></v>
<v t="ekr.20040104185913.371"><vh>has_permission</vh></v>
<v t="ekr.20040104185913.372"><vh>__len__</vh></v>
<v t="ekr.20040104185913.373"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.374"><vh>class SimpleUser</vh>
<v t="ekr.20040104185913.375"><vh>__init__</vh></v>
<v t="ekr.20040104185913.376"><vh>getUserName</vh></v>
<v t="ekr.20040104185913.377"><vh>_getPassword</vh></v>
<v t="ekr.20040104185913.378"><vh>getRoles</vh></v>
<v t="ekr.20040104185913.379"><vh>getDomains</vh></v>
</v>
<v t="ekr.20040104185913.380"><vh>class SpecialUser</vh>
<v t="ekr.20040104185913.381"><vh>getId</vh></v>
</v>
<v t="ekr.20040104185913.382"><vh>class User</vh></v>
<v t="ekr.20040104185913.383"><vh>class UnrestrictedUser</vh>
<v t="ekr.20040104185913.384"><vh>allowed</vh></v>
<v t="ekr.20040104185913.385"><vh>hasRole</vh></v>
<v t="ekr.20040104185913.386"><vh>has_role</vh></v>
<v t="ekr.20040104185913.387"><vh>has_permission</vh></v>
</v>
<v t="ekr.20040104185913.388"><vh>class NullUnrestrictedUser</vh>
<v t="ekr.20040104185913.390"><vh>__init__</vh></v>
<v t="ekr.20040104185913.391"><vh>getUserName</vh></v>
<v t="ekr.20040104185913.392"><vh>getRoles</vh></v>
<v t="ekr.20040104185913.393"><vh>getRolesInContext</vh></v>
<v t="ekr.20040104185913.394"><vh>authenticate</vh></v>
<v t="ekr.20040104185913.395"><vh>allowed</vh></v>
<v t="ekr.20040104185913.396"><vh>hasRole</vh></v>
<v t="ekr.20040104185913.397"><vh>has_role</vh></v>
<v t="ekr.20040104185913.398"><vh>has_permission</vh></v>
</v>
<v t="ekr.20040104185913.399"><vh>readUserAccessFile</vh></v>
<v t="ekr.20040104185913.400"><vh>class BasicUserFolder</vh>
<v t="ekr.20040104185913.401"><vh>&lt;&lt; class BasicUserFolder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.402"><vh>getUserNames</vh></v>
<v t="ekr.20040104185913.403"><vh>getUsers</vh></v>
<v t="ekr.20040104185913.404"><vh>getUser</vh></v>
<v t="ekr.20040104185913.405"><vh>getUserById</vh></v>
<v t="ekr.20040104185913.406"><vh>_doAddUser</vh></v>
<v t="ekr.20040104185913.407"><vh>_doChangeUser</vh></v>
<v t="ekr.20040104185913.408"><vh>_doDelUsers</vh></v>
<v t="ekr.20040104185913.409"><vh>userFolderAddUser</vh></v>
<v t="ekr.20040104185913.410"><vh>userFolderEditUser</vh></v>
<v t="ekr.20040104185913.411"><vh>userFolderDelUsers</vh></v>
<v t="ekr.20040104185913.412"><vh>identify</vh></v>
<v t="ekr.20040104185913.413"><vh>authenticate</vh></v>
<v t="ekr.20040104185913.414"><vh>authorize</vh></v>
<v t="ekr.20040104185913.415"><vh>validate</vh></v>
<v t="ekr.20040104185913.416"><vh>validate</vh></v>
<v t="ekr.20040104185913.417"><vh>_getobcontext</vh></v>
<v t="ekr.20040104185913.418"><vh>_isTop</vh></v>
<v t="ekr.20040104185913.419"><vh>__len__</vh></v>
<v t="ekr.20040104185913.420"><vh>manage_userFolderProperties</vh></v>
<v t="ekr.20040104185913.421"><vh>manage_setUserFolderProperties</vh></v>
<v t="ekr.20040104185913.422"><vh>_isPasswordEncrypted</vh></v>
<v t="ekr.20040104185913.423"><vh>_encryptPassword</vh></v>
<v t="ekr.20040104185913.424"><vh>domainSpecValidate</vh></v>
<v t="ekr.20040104185913.425"><vh>_addUser</vh></v>
<v t="ekr.20040104185913.426"><vh>_changeUser</vh></v>
<v t="ekr.20040104185913.427"><vh>_delUsers</vh></v>
<v t="ekr.20040104185913.428"><vh>manage_users</vh></v>
<v t="ekr.20040104185913.429"><vh>user_names</vh></v>
<v t="ekr.20040104185913.430"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.431"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.432"><vh>__creatable_by_emergency_user__</vh></v>
<v t="ekr.20040104185913.433"><vh>_setId</vh></v>
<v t="ekr.20040104185913.434"><vh>setDomainAuthenticationMode</vh></v>
<v t="ekr.20040104185913.435"><vh>domainAuthModeEnabled</vh></v>
</v>
<v t="ekr.20040104185913.436"><vh>class UserFolder</vh>
<v t="ekr.20040104185913.437"><vh>&lt;&lt; class UserFolder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.438"><vh>__init__</vh></v>
<v t="ekr.20040104185913.439"><vh>getUserNames</vh></v>
<v t="ekr.20040104185913.440"><vh>getUsers</vh></v>
<v t="ekr.20040104185913.441"><vh>getUser</vh></v>
<v t="ekr.20040104185913.442"><vh>_doAddUser</vh></v>
<v t="ekr.20040104185913.443"><vh>_doChangeUser</vh></v>
<v t="ekr.20040104185913.444"><vh>_doDelUsers</vh></v>
<v t="ekr.20040104185913.445"><vh>_createInitialUser</vh></v>
</v>
<v t="ekr.20040104185913.446"><vh>manage_addUserFolder</vh></v>
<v t="ekr.20040104185913.447"><vh>rolejoin</vh></v>
<v t="ekr.20040104185913.448"><vh>domainSpecMatch</vh></v>
<v t="ekr.20040104185913.449"><vh>absattr</vh></v>
<v t="ekr.20040104185913.450"><vh>reqattr</vh></v>
</v>
<v t="ekr.20040104185913.451"><vh>@file ZopeGuards.py (import problems)</vh>
<v t="ekr.20040104185913.452"><vh>&lt;&lt; ZopeGuards imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.453"><vh>aq_validate</vh></v>
<v t="ekr.20040104185913.454"><vh>guarded_getattr</vh></v>
<v t="ekr.20040104185913.455"><vh>guarded_hasattr</vh></v>
<v t="ekr.20040104185913.456"><vh>guarded_getitem</vh></v>
<v t="ekr.20040104185913.457"><vh>guarded_filter</vh></v>
<v t="ekr.20040104185913.458"><vh>guarded_map</vh></v>
<v t="ekr.20040104185913.459"><vh>guarded_import</vh></v>
<v t="ekr.20040104185913.460"><vh>load_module</vh></v>
</v>
<v t="ekr.20040104185913.461"><vh>@file ZopeSecurityPolicy.py</vh>
<v t="ekr.20040104185913.462"><vh>&lt;&lt; ZopeSecurityPolicy imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.463"><vh>class ZopeSecurityPolicy</vh>
<v t="ekr.20040104185913.464"><vh>__init__</vh></v>
<v t="ekr.20040104185913.465" a="M"><vh>validate</vh>
<v t="ekr.20040106170833"><vh>&lt;&lt; Provide special rules for the acquisition attributes &gt;&gt;</vh></v>
<v t="ekr.20040106170833.1"><vh>&lt;&lt; try to get roles from the container &gt;&gt;</vh></v>
<v t="ekr.20040106170833.2"><vh>&lt;&lt; Short-circuit tests if we can &gt;&gt;</vh></v>
<v t="ekr.20040106170833.3"><vh>&lt;&lt; Check executable security &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.466"><vh>checkPermission</vh></v>
</v>
</v>
<v t="ekr.20040104185913.467"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.468"><vh>@file cAccessControl.c</vh>
<v t="ekr.20040104185913.469"><vh>&lt;&lt; cAccessControl #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.470"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040106165810"><vh>callfunction n...</vh>
<v t="ekr.20040104185913.471"><vh>callfunction1</vh></v>
<v t="ekr.20040104185913.472"><vh>callmethod1</vh></v>
<v t="ekr.20040104185913.473"><vh>callfunction2</vh></v>
<v t="ekr.20040104185913.474"><vh>callfunction3</vh></v>
<v t="ekr.20040104185913.475"><vh>callfunction4</vh></v>
<v t="ekr.20040104185913.476"><vh>callfunction5</vh></v>
<v t="ekr.20040104185913.477"><vh>callfunction6</vh></v>
</v>
<v t="ekr.20040106165810.1"><vh>unpacktuple n...</vh>
<v t="ekr.20040104185913.478"><vh>unpacktuple1</vh></v>
<v t="ekr.20040104185913.479"><vh>unpacktuple2</vh></v>
<v t="ekr.20040104185913.480"><vh>unpacktuple3</vh></v>
<v t="ekr.20040104185913.481"><vh>unpacktuple5</vh></v>
<v t="ekr.20040104185913.482"><vh>unpacktuple6</vh></v>
</v>
<v t="ekr.20040106165810.2"><vh>structures</vh></v>
<v t="ekr.20040106165810.3"><vh>prototypes</vh></v>
<v t="ekr.20040106165810.4"><vh>constants</vh></v>
<v t="ekr.20040106170026"><vh>static objects</vh></v>
<v t="ekr.20040106170026.1"><vh>Zope security methods...</vh>
<v t="ekr.20040104185913.483"><vh>ZopeSecurityPolicy_setup</vh></v>
<v t="ekr.20040104185913.484"><vh>unauthErr</vh></v>
<v t="ekr.20040104185913.485"><vh>ZopeSecurityPolicy_validate</vh></v>
<v t="ekr.20040104185913.486"><vh>ZopeSecurityPolicy_checkPermission</vh></v>
<v t="ekr.20040104185913.487"><vh>ZopeSecurityPolicy_dealloc</vh></v>
<v t="ekr.20040104185913.488"><vh>SecurityManager_validate</vh></v>
<v t="ekr.20040104185913.489"><vh>SecurityManager_validateValue</vh></v>
<v t="ekr.20040104185913.490"><vh>SecurityManager_DTMLValidate</vh></v>
<v t="ekr.20040104185913.491"><vh>SecurityManager_checkPermission</vh></v>
<v t="ekr.20040104185913.492"><vh>SecurityManager_dealloc</vh></v>
<v t="ekr.20040104185913.493"><vh>SecurityManager_getattro</vh></v>
<v t="ekr.20040104185913.494"><vh>SecurityManager_setattro</vh></v>
<v t="ekr.20040104185913.495"><vh>PermissionRole_init</vh></v>
<v t="ekr.20040104185913.496"><vh>PermissionRole_of</vh></v>
<v t="ekr.20040104185913.497"><vh>PermissionRole_dealloc</vh></v>
<v t="ekr.20040104185913.498"><vh>imPermissionRole_of</vh></v>
<v t="ekr.20040104185913.499"><vh>imPermissionRole_length</vh></v>
<v t="ekr.20040104185913.500"><vh>imPermissionRole_get</vh></v>
<v t="ekr.20040104185913.501"><vh>imPermissionRole_dealloc</vh></v>
<v t="ekr.20040104185913.502"><vh>rolesForPermissionOn</vh></v>
<v t="ekr.20040104185913.503"><vh>c_rolesForPermissionOn</vh></v>
<v t="ekr.20040104185913.504"><vh>permissionName</vh></v>
<v t="ekr.20040104185913.505"><vh>guarded_getattr</vh></v>
<v t="ekr.20040104185913.506"><vh>module_guarded_getattr</vh></v>
<v t="ekr.20040104185913.507"><vh>module_aq_validate</vh></v>
<v t="ekr.20040104185913.508"><vh>dtml_guarded_getattr</vh></v>
</v>
<v t="ekr.20040104185913.509"><vh>initcAccessControl (Module initialization)</vh></v>
</v>
<v t="ekr.20040104185913.510"><vh>@file unauthorized.py</vh>
<v t="ekr.20040104185913.512"><vh>class Unauthorized</vh>
<v t="ekr.20040104185913.513"><vh>getValueName</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.514"><vh>securitySuite</vh>
<v t="ekr.20040104185913.515"><vh>@file framework.py</vh></v>
<v t="ekr.20040104185913.516"><vh>@file ResultObject.py</vh>
<v t="ekr.20040104185913.518"><vh>class ResultObject</vh>
<v t="ekr.20040104185913.519"><vh>__str__</vh></v>
<v t="ekr.20040104185913.520"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.521"><vh>@file SecurityBase.py</vh>
<v t="ekr.20040104185913.523"><vh>index_html</vh></v>
<v t="ekr.20040104185913.524"><vh>class BoboApplication</vh>
<v t="ekr.20040104185913.526"><vh>__bobo_traverse__</vh></v>
</v>
<v t="ekr.20040104185913.527"><vh>class SecurityBase</vh>
<v t="ekr.20040104185913.529"><vh>_testHierarchy</vh></v>
<v t="ekr.20040104185913.530"><vh>_PrintTestEnvironment</vh></v>
<v t="ekr.20040104185913.531"><vh>_checkPermission</vh></v>
<v t="ekr.20040104185913.532"><vh>_checkRoles</vh></v>
<v t="ekr.20040104185913.533"><vh>_checkRequest</vh></v>
<v t="ekr.20040104185913.534"><vh>_perm_debug</vh></v>
<v t="ekr.20040104185913.535"><vh>_roles_debug</vh></v>
<v t="ekr.20040104185913.536"><vh>_request_debug</vh></v>
<v t="ekr.20040104185913.537"><vh>_request</vh></v>
</v>
</v>
<v t="ekr.20040104185913.538"><vh>@file regressionSecurity.py</vh>
<v t="ekr.20040104185913.539"><vh>&lt;&lt; regressionSecurity declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.540"><vh>class TestObject</vh>
<v t="ekr.20040104185913.541"><vh>&lt;&lt; class TestObject declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.542"><vh>__init__</vh></v>
<v t="ekr.20040104185913.543"><vh>private_func</vh></v>
<v t="ekr.20040104185913.544"><vh>manage_func</vh></v>
<v t="ekr.20040104185913.545"><vh>manage_func2</vh></v>
<v t="ekr.20040104185913.546"><vh>protected_func</vh></v>
<v t="ekr.20040104185913.547"><vh>public_func</vh></v>
</v>
<v t="ekr.20040104185913.548"><vh>class TestFolder</vh>
<v t="ekr.20040104185913.549"><vh>__init__</vh></v>
<v t="ekr.20040104185913.550"><vh>getId</vh></v>
</v>
<v t="ekr.20040104185913.551"><vh>class User</vh>
<v t="ekr.20040104185913.552"><vh>__init__</vh></v>
<v t="ekr.20040104185913.553"><vh>auth</vh></v>
<v t="ekr.20040104185913.554"><vh>__str__ &amp; __repr__</vh></v>
</v>
<v t="ekr.20040104185913.555"><vh>getAuth</vh></v>
<v t="ekr.20040104185913.556"><vh>class AVeryBasicSecurityTest</vh>
<v t="ekr.20040104185913.557"><vh>&lt;&lt; class AVeryBasicSecurityTest declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.558"><vh>setUp</vh></v>
<v t="ekr.20040104185913.559"><vh>testNobody</vh></v>
<v t="ekr.20040104185913.560"><vh>testPermissionAccess</vh></v>
<v t="ekr.20040104185913.561"><vh>testZPublisherAccess</vh></v>
</v>
<v t="ekr.20040104185913.562"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.563"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20040104185913.564"><vh>tests</vh>
<v t="ekr.20040104185913.565"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.566"><vh>@file testClassSecurityInfo.py</vh>
<v t="ekr.20040104185913.567"><vh>&lt;&lt; testClassSecurityInfo declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.568"><vh>class ClassSecurityInfoTests</vh>
<v t="ekr.20040104185913.569"><vh>testSetPermissionDefault</vh></v>
</v>
<v t="ekr.20040104185913.570"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.571"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.572"><vh>@file testDeprecatedAPI.py</vh>
<v t="ekr.20040104185913.573"><vh>&lt;&lt; testDeprecatedAPI declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.574"><vh>class DeprecatedAPI</vh>
<v t="ekr.20040104185913.575"><vh>setUp</vh></v>
<v t="ekr.20040104185913.576"><vh>testDeprecatedHasRole</vh></v>
<v t="ekr.20040104185913.577"><vh>testAllowed</vh></v>
<v t="ekr.20040104185913.578"><vh>tearDown</vh></v>
</v>
<v t="ekr.20040104185913.579"><vh>class BasicUser</vh>
<v t="ekr.20040104185913.580"><vh>&lt;&lt; class BasicUser declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.581"><vh>class UnrestrictedUser</vh>
<v t="ekr.20040104185913.582"><vh>&lt;&lt; class UnrestrictedUser declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.583"><vh>class NullUnrestrictedUser</vh>
<v t="ekr.20040104185913.584"><vh>&lt;&lt; class NullUnrestrictedUser declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.585"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.586"><vh>@file testModuleSecurity.py</vh>
<v t="ekr.20040104185913.587"><vh>&lt;&lt; testModuleSecurity declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.588"><vh>class SecurityTests</vh>
<v t="ekr.20040104185913.589"><vh>assertUnauth</vh></v>
<v t="ekr.20040104185913.590"><vh>assertAuth</vh></v>
<v t="ekr.20040104185913.591"><vh>testPrivateModule</vh></v>
<v t="ekr.20040104185913.592"><vh>testMixedModule</vh></v>
<v t="ekr.20040104185913.593"><vh>testPublicModule</vh></v>
</v>
<v t="ekr.20040104185913.594"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.595"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.596"><vh>@file testPasswordDigest.py</vh>
<v t="ekr.20040104185913.597"><vh>&lt;&lt; testPasswordDigest declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.598"><vh>class PasswordDigestTests</vh>
<v t="ekr.20040104185913.599"><vh>testGoodPassword</vh></v>
<v t="ekr.20040104185913.600"><vh>testBadPasword</vh></v>
<v t="ekr.20040104185913.601"><vh>testShortPassword</vh></v>
<v t="ekr.20040104185913.602"><vh>testLongPassword</vh></v>
<v t="ekr.20040104185913.603"><vh>testBlankPassword</vh></v>
<v t="ekr.20040104185913.604"><vh>testUnencryptedPassword</vh></v>
</v>
<v t="ekr.20040104185913.605"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.606"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.607"><vh>@file testPermissionRole.py</vh>
<v t="ekr.20040104185913.608"><vh>&lt;&lt; testPermissionRole declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.609"><vh>class AppRoot</vh>
<v t="ekr.20040104185913.610"><vh>&lt;&lt; class AppRoot declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.611"><vh>class ImplicitContainer</vh>
<v t="ekr.20040104185913.612"><vh>&lt;&lt; class ImplicitContainer declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.613"><vh>class ExplicitContainer</vh>
<v t="ekr.20040104185913.614"><vh>&lt;&lt; class ExplicitContainer declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.615"><vh>class RestrictiveObject</vh>
<v t="ekr.20040104185913.616"><vh>&lt;&lt; class RestrictiveObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.617"><vh>class PermissiveObject</vh>
<v t="ekr.20040104185913.618"><vh>&lt;&lt; class PermissiveObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.619"><vh>class ZClassMethodish</vh>
<v t="ekr.20040104185913.620"><vh>&lt;&lt; class ZClassMethodish declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.621"><vh>assertPRoles</vh></v>
<v t="ekr.20040104185913.622"><vh>class PermissionRoleTests</vh>
<v t="ekr.20040104185913.623"><vh>testRestrictive</vh></v>
<v t="ekr.20040104185913.624"><vh>testPermissive</vh></v>
<v t="ekr.20040104185913.625"><vh>testExplicit</vh></v>
<v t="ekr.20040104185913.626"><vh>testAppDefaults</vh></v>
<v t="ekr.20040104185913.627"><vh>testPermissionMapping</vh></v>
</v>
<v t="ekr.20040104185913.628"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.629"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.630"><vh>@file testSecurity.py</vh>
<v t="ekr.20040104185913.631"><vh>&lt;&lt; testSecurity declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.632"><vh>class UnownedDTML</vh>
<v t="ekr.20040104185913.633"><vh>getOwner</vh></v>
</v>
<v t="ekr.20040104185913.634"><vh>class SecurityTests</vh>
<v t="ekr.20040104185913.635"><vh>&lt;&lt; class SecurityTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.636"><vh>testNoImplicitAccess</vh></v>
<v t="ekr.20040104185913.637"><vh>testExprExplicitDeny</vh></v>
<v t="ekr.20040104185913.638"><vh>testSecurityInSyntax</vh></v>
</v>
<v t="ekr.20040104185913.639"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.640"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.641"><vh>@file testUserFolder.py</vh>
<v t="ekr.20040104185913.642"><vh>&lt;&lt; testUserFolder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.643"><vh>class UserFolderTests</vh>
<v t="ekr.20040104185913.644"><vh>testMaxListUsers</vh></v>
</v>
<v t="ekr.20040104185913.645"><vh>class UserTests</vh>
<v t="ekr.20040104185913.646"><vh>testGetUserName</vh></v>
<v t="ekr.20040104185913.647"><vh>testGetUserId</vh></v>
<v t="ekr.20040104185913.648"><vh>testBaseUserGetIdEqualGetName</vh></v>
<v t="ekr.20040104185913.649"><vh>testGetPassword</vh></v>
<v t="ekr.20040104185913.650"><vh>testGetRoles</vh></v>
<v t="ekr.20040104185913.651"><vh>testGetDomains</vh></v>
</v>
<v t="ekr.20040104185913.652"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.653"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.654"><vh>@file testZopeSecurityPolicy.py</vh>
<v t="ekr.20040104185913.655"><vh>&lt;&lt; testZopeSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.656"><vh>class App</vh>
<v t="ekr.20040104185913.657"><vh>&lt;&lt; class App declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.658"><vh>class PublicMethod</vh>
<v t="ekr.20040104185913.659"><vh>getOwner</vh></v>
</v>
<v t="ekr.20040104185913.660"><vh>class ProtectedMethod</vh>
<v t="ekr.20040104185913.661"><vh>&lt;&lt; class ProtectedMethod declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.662"><vh>class OwnedMethod</vh>
<v t="ekr.20040104185913.663"><vh>&lt;&lt; class OwnedMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.664"><vh>getOwner</vh></v>
</v>
<v t="ekr.20040104185913.665"><vh>class setuidMethod</vh>
<v t="ekr.20040104185913.666"><vh>&lt;&lt; class setuidMethod declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.667"><vh>class DangerousMethod</vh>
<v t="ekr.20040104185913.668"><vh>&lt;&lt; class DangerousMethod declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.669"><vh>class SimpleItemish</vh>
<v t="ekr.20040104185913.670"><vh>&lt;&lt; class SimpleItemish declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.671"><vh>class UnprotectedSimpleItem</vh>
<v t="ekr.20040104185913.672"><vh>&lt;&lt; class UnprotectedSimpleItem declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.673"><vh>class RestrictedSimpleItem</vh>
<v t="ekr.20040104185913.674"><vh>&lt;&lt; class RestrictedSimpleItem declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.675"><vh>class PartlyProtectedSimpleItem1</vh>
<v t="ekr.20040104185913.676"><vh>&lt;&lt; class PartlyProtectedSimpleItem1 declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.677"><vh>class PartlyProtectedSimpleItem2</vh>
<v t="ekr.20040104185913.678"><vh>__allow_access_to_unprotected_subobjects__</vh></v>
</v>
<v t="ekr.20040104185913.679"><vh>class PartlyProtectedSimpleItem3</vh>
<v t="ekr.20040104185913.680"><vh>&lt;&lt; class PartlyProtectedSimpleItem3 declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.681"><vh>class SimpleClass</vh>
<v t="ekr.20040104185913.682"><vh>&lt;&lt; class SimpleClass declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.683"><vh>class ZopeSecurityPolicyTests</vh>
<v t="ekr.20040104185913.684"><vh>&lt;&lt; class ZopeSecurityPolicyTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.685"><vh>setUp</vh></v>
<v t="ekr.20040104185913.686"><vh>assertPolicyAllows</vh></v>
<v t="ekr.20040104185913.687"><vh>assertPolicyDenies</vh></v>
<v t="ekr.20040104185913.688"><vh>testUserAccess</vh></v>
<v t="ekr.20040104185913.689"><vh>testOwnerAccess</vh></v>
<v t="ekr.20040104185913.690"><vh>testProxyAccess</vh></v>
<v t="ekr.20040104185913.691"><vh>testAccessToUnprotectedSubobjects</vh></v>
<v t="ekr.20040104185913.692"><vh>testAccessToSimpleContainer</vh></v>
<v t="ekr.20040104185913.693"><vh>testRolesForPermission</vh></v>
<v t="ekr.20040104185913.694"><vh>testAqNames</vh></v>
<v t="ekr.20040104185913.695"><vh>testInsaneRoles</vh></v>
</v>
<v t="ekr.20040104185913.696"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.697"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.698"><vh>mixed_module</vh>
<v t="ekr.20040104185913.699"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.700"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.701"><vh>priv</vh></v>
<v t="ekr.20040104185913.702"><vh>pub</vh></v>
</v>
<v t="ekr.20040104185913.703"><vh>c:/prog/Zope-2.6.2-src/lib/python\AccessControl\tests\mixed_module\submodule</vh>
<v t="ekr.20040104185913.704"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.705"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.706"><vh>priv</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.707"><vh>private_module</vh>
<v t="ekr.20040104185913.708"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.709"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.710"><vh>priv</vh></v>
</v>
<v t="ekr.20040104185913.711"><vh>c:/prog/Zope-2.6.2-src/lib/python\AccessControl\tests\private_module\submodule</vh>
<v t="ekr.20040104185913.712"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.713"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.714"><vh>priv</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.715"><vh>public_module</vh>
<v t="ekr.20040104185913.716"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.717"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.718"><vh>pub</vh></v>
</v>
<v t="ekr.20040104185913.719"><vh>c:/prog/Zope-2.6.2-src/lib/python\AccessControl\tests\public_module\submodule</vh>
<v t="ekr.20040104185913.720"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.721"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.722"><vh>pub</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040104185913.723"><vh>App</vh>
<v t="ekr.20040104185913.724"><vh>@file ApplicationManager.py</vh>
<v t="ekr.20040104185913.725"><vh>&lt;&lt; ApplicationManager imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.726"><vh>class Fake</vh>
<v t="ekr.20040104185913.727"><vh>locked_in_version</vh></v>
</v>
<v t="ekr.20040104185913.728"><vh>class DatabaseManager</vh>
<v t="ekr.20040104185913.729"><vh>&lt;&lt; class DatabaseManager declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.730"><vh>class VersionManager</vh>
<v t="ekr.20040104185913.731"><vh>&lt;&lt; class VersionManager declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.732"><vh>class DebugManager</vh>
<v t="ekr.20040104185913.733"><vh>&lt;&lt; class DebugManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.734"><vh>refcount</vh></v>
<v t="ekr.20040104185913.735"><vh>refdict</vh></v>
<v t="ekr.20040104185913.736"><vh>rcsnapshot</vh></v>
<v t="ekr.20040104185913.737"><vh>rcdate</vh></v>
<v t="ekr.20040104185913.738"><vh>rcdeltas</vh></v>
<v t="ekr.20040104185913.739"><vh>dbconnections</vh></v>
<v t="ekr.20040104185913.740"><vh>manage_profile_stats</vh></v>
<v t="ekr.20040104185913.741"><vh>manage_getSysPath</vh></v>
</v>
<v t="ekr.20040104185913.742"><vh>class ApplicationManager</vh>
<v t="ekr.20040104185913.743"><vh>&lt;&lt; class ApplicationManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.744"><vh>version_txt</vh></v>
<v t="ekr.20040104185913.745"><vh>sys_version</vh></v>
<v t="ekr.20040104185913.746"><vh>sys_platform</vh></v>
<v t="ekr.20040104185913.747"><vh>__init__</vh></v>
<v t="ekr.20040104185913.748"><vh>_canCopy</vh></v>
<v t="ekr.20040104185913.749"><vh>_init</vh></v>
<v t="ekr.20040104185913.750"><vh>manage_app</vh></v>
<v t="ekr.20040104185913.751"><vh>process_time</vh></v>
<v t="ekr.20040104185913.752"><vh>thread_get_ident</vh></v>
<v t="ekr.20040104185913.753"><vh>db_name</vh></v>
<v t="ekr.20040104185913.754"><vh>db_size</vh></v>
<v t="ekr.20040104185913.755"><vh>manage_restart</vh></v>
<v t="ekr.20040104185913.756"><vh>manage_shutdown</vh></v>
<v t="ekr.20040104185913.757"><vh>manage_pack</vh></v>
<v t="ekr.20040104185913.758"><vh>revert_points</vh></v>
<v t="ekr.20040104185913.759"><vh>version_list</vh></v>
<v t="ekr.20040104185913.760"><vh>version_info</vh></v>
<v t="ekr.20040104185913.761"><vh>manage_saveVersions</vh></v>
<v t="ekr.20040104185913.762"><vh>manage_discardVersions</vh></v>
<v t="ekr.20040104185913.763"><vh>getSOFTWARE_HOME</vh></v>
<v t="ekr.20040104185913.764"><vh>getZOPE_HOME</vh></v>
<v t="ekr.20040104185913.765"><vh>getINSTANCE_HOME</vh></v>
<v t="ekr.20040104185913.766"><vh>getCLIENT_HOME</vh></v>
<v t="ekr.20040104185913.767"><vh>objectIds</vh></v>
</v>
</v>
<v t="ekr.20040104185913.768"><vh>@file CacheManager.py</vh>
<v t="ekr.20040104185913.770"><vh>class CacheManager</vh>
<v t="ekr.20040104185913.771"><vh>&lt;&lt; class CacheManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.772"><vh>cache_length</vh></v>
<v t="ekr.20040104185913.773"><vh>cache_detail_length</vh></v>
<v t="ekr.20040104185913.774"><vh>database_size</vh></v>
<v t="ekr.20040104185913.775"><vh>cache_age</vh></v>
<v t="ekr.20040104185913.776"><vh>manage_cache_age</vh></v>
<v t="ekr.20040104185913.777"><vh>cache_size</vh></v>
<v t="ekr.20040104185913.778"><vh>manage_cache_size</vh></v>
<v t="ekr.20040104185913.779"><vh>cacheStatistics</vh></v>
<v t="ekr.20040104185913.780"><vh>cache_mean_age</vh></v>
<v t="ekr.20040104185913.781"><vh>cache_mean_deal</vh></v>
<v t="ekr.20040104185913.782"><vh>cache_mean_deac</vh></v>
<v t="ekr.20040104185913.783"><vh>cache_last_gc_time</vh></v>
<v t="ekr.20040104185913.784"><vh>manage_full_sweep</vh></v>
<v t="ekr.20040104185913.785"><vh>manage_minimize</vh></v>
<v t="ekr.20040104185913.786"><vh>initialize_cache</vh></v>
<v t="ekr.20040104185913.787"><vh>cache_detail</vh></v>
<v t="ekr.20040104185913.788"><vh>cache_extreme_detail</vh></v>
<v t="ekr.20040104185913.789"><vh>_getActivityMonitor</vh></v>
<v t="ekr.20040104185913.790"><vh>getHistoryLength</vh></v>
<v t="ekr.20040104185913.791"><vh>manage_setHistoryLength</vh></v>
<v t="ekr.20040104185913.792"><vh>getActivityChartData</vh></v>
</v>
</v>
<v t="ekr.20040104185913.793"><vh>@file Common.py</vh>
<v t="ekr.20040104185913.795"><vh>iso8601_date</vh></v>
<v t="ekr.20040104185913.796"><vh>rfc850_date</vh></v>
<v t="ekr.20040104185913.797"><vh>rfc1123_date</vh></v>
<v t="ekr.20040104185913.798"><vh>absattr</vh></v>
<v t="ekr.20040104185913.799"><vh>aq_base</vh></v>
<v t="ekr.20040104185913.800"><vh>is_acquired</vh></v>
<v t="ekr.20040104185913.801"><vh>package_home</vh></v>
<v t="ekr.20040104185913.802"><vh>attrget</vh></v>
<v t="ekr.20040104185913.803"><vh>Dictionary</vh></v>
<v t="ekr.20040104185913.804"><vh>realpath</vh></v>
</v>
<v t="ekr.20040104185913.805"><vh>@file DavLockManager.py</vh>
<v t="ekr.20040104185913.807"><vh>class DavLockManager</vh>
<v t="ekr.20040104185913.808"><vh>&lt;&lt; class DavLockManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.809"><vh>locked_in_version</vh></v>
<v t="ekr.20040104185913.810"><vh>findLockedObjects</vh></v>
<v t="ekr.20040104185913.811"><vh>unlockObjects</vh></v>
<v t="ekr.20040104185913.812"><vh>manage_unlockObjects</vh></v>
<v t="ekr.20040104185913.813"><vh>_findapply</vh></v>
</v>
</v>
<v t="ekr.20040104185913.814"><vh>@file Dialogs.py</vh>
<v t="ekr.20040106165012"><vh>&lt;&lt; message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.815"><vh>@file Extensions.py</vh>
<v t="ekr.20040104185913.817"><vh>class FuncCode</vh>
<v t="ekr.20040104185913.818"><vh>__init__</vh></v>
<v t="ekr.20040104185913.819"><vh>__cmp__</vh></v>
</v>
<v t="ekr.20040104185913.820"><vh>_getPath</vh></v>
<v t="ekr.20040104185913.821"><vh>getPath</vh></v>
<v t="ekr.20040104185913.822"><vh>getObject</vh></v>
<v t="ekr.20040104185913.823"><vh>class NoBrains</vh></v>
<v t="ekr.20040104185913.824"><vh>getBrain</vh></v>
</v>
<v t="ekr.20040104185913.825"><vh>@file Factory.py</vh>
<v t="ekr.20040104185913.827"><vh>class Factory</vh>
<v t="ekr.20040104185913.828"><vh>&lt;&lt; class Factory declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.829"><vh>__init__</vh></v>
<v t="ekr.20040104185913.830"><vh>initializePermission</vh></v>
<v t="ekr.20040104185913.831"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.832"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.833"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.834"><vh>_register</vh></v>
<v t="ekr.20040104185913.835"><vh>_unregister</vh></v>
<v t="ekr.20040104185913.836"><vh>index_html</vh></v>
<v t="ekr.20040104185913.837"><vh>objectIds</vh></v>
</v>
<v t="ekr.20040104185913.838"><vh>class ProductFactory</vh></v>
</v>
<v t="ekr.20040104185913.839"><vh>@file FactoryDispatcher.py</vh>
<v t="ekr.20040104185913.841"><vh>class ProductDispatcher</vh>
<v t="ekr.20040104185913.843"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.844"><vh>__bobo_traverse__</vh></v>
</v>
<v t="ekr.20040104185913.845"><vh>class FactoryDispatcher</vh>
<v t="ekr.20040104185913.847"><vh>__init__</vh></v>
<v t="ekr.20040104185913.848"><vh>Destination</vh></v>
<v t="ekr.20040104185913.849"><vh>DestinationURL</vh></v>
<v t="ekr.20040104185913.850"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.851"><vh>manage_main</vh></v>
</v>
<v t="ekr.20040104185913.852"><vh>class ofWrapper</vh>
<v t="ekr.20040104185913.853"><vh>__init__</vh></v>
<v t="ekr.20040104185913.854"><vh>__of__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.855"><vh>@file FindHomes.py</vh></v>
<v t="ekr.20040104185913.856"><vh>@file Hotfixes.py</vh>
<v t="ekr.20040104185913.858"><vh>isMerged</vh></v>
<v t="ekr.20040104185913.859"><vh>logHotfix</vh></v>
<v t="ekr.20040104185913.860"><vh>beforeApplyHotfix</vh></v>
</v>
<v t="ekr.20040104185913.861"><vh>@file ImageFile.py</vh>
<v t="ekr.20040104185913.863"><vh>class ImageFile</vh>
<v t="ekr.20040104185913.864"><vh>__init__</vh></v>
<v t="ekr.20040104185913.865"><vh>index_html</vh></v>
<v t="ekr.20040104185913.866"><vh>HEAD</vh></v>
<v t="ekr.20040104185913.867"><vh>__len__</vh></v>
<v t="ekr.20040104185913.868"><vh>__str__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.869"><vh>@file Management.py</vh>
<v t="ekr.20040104185913.871"><vh>class Tabs</vh>
<v t="ekr.20040104185913.872"><vh>&lt;&lt; class Tabs declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.873"><vh>filtered_manage_options</vh></v>
<v t="ekr.20040104185913.874"><vh>manage_workspace</vh></v>
<v t="ekr.20040104185913.875"><vh>tabs_path_default</vh></v>
<v t="ekr.20040104185913.876"><vh>tabs_path_info</vh></v>
<v t="ekr.20040104185913.877"><vh>class_manage_path</vh></v>
</v>
<v t="ekr.20040104185913.878"><vh>class Navigation</vh>
<v t="ekr.20040104185913.879"><vh>&lt;&lt; class Navigation declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.880"><vh>manage_zmi_logout</vh></v>
</v>
</v>
<v t="ekr.20040104185913.881"><vh>@file Permission.py</vh>
<v t="ekr.20040104185913.883"><vh>class Permission</vh>
<v t="ekr.20040104185913.884"><vh>&lt;&lt; class Permission declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.885"><vh>__init__</vh></v>
<v t="ekr.20040104185913.886"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.887"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.888"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.889"><vh>_register</vh></v>
<v t="ekr.20040104185913.890"><vh>_unregister</vh></v>
</v>
<v t="ekr.20040104185913.891"><vh>class PermissionManager</vh>
<v t="ekr.20040104185913.892"><vh>&lt;&lt; class PermissionManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.893"><vh>manage_addPermission</vh></v>
</v>
</v>
<v t="ekr.20040104185913.894"><vh>@file PersistentExtra.py</vh>
<v t="ekr.20040104185913.896"><vh>class PersistentUtil</vh>
<v t="ekr.20040104185913.897"><vh>bobobase_modification_time</vh></v>
<v t="ekr.20040104185913.898"><vh>locked_in_version</vh></v>
<v t="ekr.20040104185913.899"><vh>modified_in_version</vh></v>
</v>
</v>
<v t="ekr.20040104185913.900"><vh>@file Product.py</vh>
<v t="ekr.20040104185913.901"><vh>&lt;&lt; Product imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.902"><vh>class ProductFolder</vh>
<v t="ekr.20040104185913.903"><vh>&lt;&lt; class ProductFolder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.904"><vh>_product</vh></v>
<v t="ekr.20040104185913.905"><vh>manage_addProduct</vh></v>
<v t="ekr.20040104185913.906"><vh>_canCopy</vh></v>
</v>
<v t="ekr.20040104185913.907"><vh>class Product</vh>
<v t="ekr.20040104185913.908"><vh>&lt;&lt; class Product declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.909"><vh>new_version</vh></v>
<v t="ekr.20040104185913.910"><vh>manage_addPrincipiaFactory</vh></v>
<v t="ekr.20040104185913.911"><vh>__init__</vh></v>
<v t="ekr.20040104185913.912"><vh>Destination</vh></v>
<v t="ekr.20040104185913.913"><vh>DestinationURL</vh></v>
<v t="ekr.20040104185913.914"><vh>manage_distribute</vh></v>
<v t="ekr.20040104185913.915"><vh>_distribution</vh></v>
<v t="ekr.20040104185913.916"><vh>class Distributions</vh>
<v t="ekr.20040104185913.917"><vh>&lt;&lt; class Distributions declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.918"><vh>__bobo_traverse__</vh></v>
</v>
<v t="ekr.20040104185913.919"><vh>manage_get_product_readme__</vh></v>
<v t="ekr.20040104185913.920"><vh>permissionMappingPossibleValues</vh></v>
<v t="ekr.20040104185913.921"><vh>zclass_product_name</vh></v>
<v t="ekr.20040104185913.922"><vh>getProductHelp</vh></v>
<v t="ekr.20040104185913.923"><vh>_readRefreshTxt</vh></v>
<v t="ekr.20040104185913.924"><vh>manage_refresh</vh></v>
<v t="ekr.20040104185913.925"><vh>manage_performRefresh</vh></v>
<v t="ekr.20040104185913.926"><vh>manage_enableAutoRefresh</vh></v>
<v t="ekr.20040104185913.927"><vh>manage_selectDependentProducts</vh></v>
</v>
<v t="ekr.20040104185913.928"><vh>class CompressedOutputFile</vh>
<v t="ekr.20040104185913.929"><vh>__init__</vh></v>
<v t="ekr.20040104185913.930"><vh>write</vh></v>
<v t="ekr.20040104185913.931"><vh>getdata</vh></v>
</v>
<v t="ekr.20040104185913.932"><vh>class CompressedInputFile</vh>
<v t="ekr.20040104185913.933"><vh>&lt;&lt; class CompressedInputFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.934"><vh>__init__</vh></v>
<v t="ekr.20040104185913.935"><vh>_next</vh></v>
<v t="ekr.20040104185913.936"><vh>read</vh></v>
<v t="ekr.20040104185913.937"><vh>readline</vh></v>
</v>
<v t="ekr.20040104185913.938"><vh>class Distribution</vh>
<v t="ekr.20040104185913.939"><vh>&lt;&lt; class Distribution declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.940"><vh>__init__</vh></v>
<v t="ekr.20040104185913.941"><vh>index_html</vh></v>
</v>
<v t="ekr.20040104185913.942"><vh>initializeProduct</vh></v>
<v t="ekr.20040104185913.943"><vh>ihasattr</vh></v>
<v t="ekr.20040104185913.944"><vh>doInstall</vh></v>
</v>
<v t="ekr.20040104185913.945"><vh>@file ProductContext.py</vh>
<v t="ekr.20040104185913.946"><vh>&lt;&lt; ProductContext imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.947"><vh>class ProductContext</vh>
<v t="ekr.20040104185913.948"><vh>__init__</vh></v>
<v t="ekr.20040104185913.949"><vh>registerClass</vh></v>
<v t="ekr.20040104185913.950"><vh>registerZClass</vh></v>
<v t="ekr.20040104185913.951"><vh>registerBaseClass</vh></v>
<v t="ekr.20040104185913.952"><vh>getProductHelp</vh></v>
<v t="ekr.20040104185913.953"><vh>registerHelpTopic</vh></v>
<v t="ekr.20040104185913.954"><vh>registerHelpTitle</vh></v>
<v t="ekr.20040104185913.955"><vh>registerHelp</vh></v>
</v>
</v>
<v t="ekr.20040104185913.956"><vh>@file ProductRegistry.py</vh>
<v t="ekr.20040104185913.958"><vh>class ProductRegistryMixin</vh>
<v t="ekr.20040104185913.960"><vh>_manage_remove_product_meta_type</vh></v>
<v t="ekr.20040104185913.961"><vh>_constructor_prefix_string</vh></v>
<v t="ekr.20040104185913.962"><vh>_manage_add_product_meta_type</vh></v>
<v t="ekr.20040104185913.963"><vh>_manage_remove_product_permission</vh></v>
<v t="ekr.20040104185913.964"><vh>_manage_add_product_permission</vh></v>
<v t="ekr.20040104185913.965"><vh>aq_maybe</vh></v>
<v t="ekr.20040104185913.966"><vh>_manage_add_product_data</vh></v>
<v t="ekr.20040104185913.967"><vh>_manage_remove_product_data</vh></v>
</v>
<v t="ekr.20040104185913.968"><vh>class ProductRegistry</vh>
<v t="ekr.20040104185913.970"><vh>_getProducts</vh></v>
<v t="ekr.20040104185913.971"><vh>_getProductRegistryMetaTypes</vh></v>
<v t="ekr.20040104185913.972"><vh>_setProductRegistryMetaTypes</vh></v>
<v t="ekr.20040104185913.973"><vh>_getProductRegistryData</vh></v>
<v t="ekr.20040104185913.974"><vh>_setProductRegistryData</vh></v>
</v>
</v>
<v t="ekr.20040104185913.975"><vh>@file RefreshFuncs.py</vh>
<v t="ekr.20040104185913.976"><vh>&lt;&lt; RefreshFuncs imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.977"><vh>class dummyClass</vh></v>
<v t="ekr.20040104185913.978"><vh>class dummyClass2</vh></v>
<v t="ekr.20040104185913.979"><vh>dummyFunc</vh></v>
<v t="ekr.20040104185913.980"><vh>_getCentralRefreshData</vh></v>
<v t="ekr.20040104185913.981"><vh>isAutoRefreshEnabled</vh></v>
<v t="ekr.20040104185913.982"><vh>enableAutoRefresh</vh></v>
<v t="ekr.20040104185913.983"><vh>listAutoRefreshableProducts</vh></v>
<v t="ekr.20040104185913.984"><vh>getDependentProducts</vh></v>
<v t="ekr.20040104185913.985"><vh>setDependentProducts</vh></v>
<v t="ekr.20040104185913.986"><vh>getReloadVar</vh></v>
<v t="ekr.20040104185913.987"><vh>listRefreshableModules</vh></v>
<v t="ekr.20040104185913.988"><vh>logBadRefresh</vh></v>
<v t="ekr.20040104185913.989"><vh>performRefresh</vh></v>
<v t="ekr.20040104185913.990"><vh>performSafeRefresh</vh></v>
<v t="ekr.20040104185913.991"><vh>performFullRefresh</vh></v>
<v t="ekr.20040104185913.992"><vh>getLastRefreshException</vh></v>
<v t="ekr.20040104185913.993"><vh>tryFindProductDirectory</vh></v>
<v t="ekr.20040104185913.994"><vh>tryFindModuleFilename</vh></v>
<v t="ekr.20040104185913.995"><vh>setupModTimes</vh></v>
<v t="ekr.20040104185913.996"><vh>checkModTimes</vh></v>
<v t="ekr.20040104185913.997"><vh>checkAutoRefresh</vh></v>
<v t="ekr.20040104185913.998"><vh>finishAutoRefresh</vh></v>
<v t="ekr.20040104185913.999"><vh>autoRefresh</vh></v>
<v t="ekr.20040104185913.1000"><vh>setupAutoRefresh</vh></v>
</v>
<v t="ekr.20040104185913.1001"><vh>@file Undo.py</vh>
<v t="ekr.20040104185913.1002"><vh>&lt;&lt; Undo imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1003"><vh>class UndoSupport</vh>
<v t="ekr.20040104185913.1004"><vh>&lt;&lt; class UndoSupport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1005"><vh>get_request_var_or_attr</vh></v>
<v t="ekr.20040104185913.1006"><vh>undoable_transactions</vh></v>
<v t="ekr.20040104185913.1007"><vh>manage_undo_transactions</vh></v>
</v>
<v t="ekr.20040104185913.1008"><vh>encode64</vh></v>
<v t="ekr.20040104185913.1009"><vh>decode64</vh></v>
</v>
<v t="ekr.20040104185913.1010"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1011"><vh>@file class_init.py</vh>
<v t="ekr.20040104185913.1013"><vh>class ApplicationDefaultPermissions</vh></v>
<v t="ekr.20040104185913.1015"><vh>default__class_init__</vh></v>
</v>
<v t="ekr.20040104185913.1016"><vh>@file special_dtml.py</vh>
<v t="ekr.20040104185913.1018"><vh>class HTML</vh>
<v t="ekr.20040104185913.1019"><vh>&lt;&lt; class HTML declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1020"><vh>class ClassicHTMLFile</vh>
<v t="ekr.20040104185913.1021"><vh>&lt;&lt; class ClassicHTMLFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1022"><vh>class func_code</vh>
<v t="ekr.20040104185913.1023"><vh>&lt;&lt; class func_code declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1024"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1025"><vh>_cook_check</vh></v>
<v t="ekr.20040104185913.1026"><vh>_setName</vh></v>
<v t="ekr.20040104185913.1027"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1028"><vh>class DTMLFile</vh>
<v t="ekr.20040104185913.1029"><vh>&lt;&lt; class DTMLFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1030"><vh>_get__roles__</vh></v>
<v t="ekr.20040104185913.1031"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1032"><vh>getOwner</vh></v>
<v t="ekr.20040104185913.1033"><vh>_exec</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1034"><vh>@file tar.py</vh>
<v t="ekr.20040104185913.1036"><vh>oct8</vh></v>
<v t="ekr.20040104185913.1037"><vh>oct12</vh></v>
<v t="ekr.20040104185913.1038"><vh>pad</vh></v>
<v t="ekr.20040104185913.1039"><vh>class TarEntry</vh>
<v t="ekr.20040104185913.1040"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1041"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.1042"><vh>tar</vh></v>
<v t="ekr.20040104185913.1043"><vh>tgz</vh></v>
<v t="ekr.20040104185913.1044"><vh>class tgzarchive</vh>
<v t="ekr.20040104185913.1045"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1046"><vh>add</vh></v>
<v t="ekr.20040104185913.1047"><vh>finish</vh></v>
<v t="ekr.20040104185913.1048"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.1049"><vh>class gzFile</vh>
<v t="ekr.20040104185913.1050"><vh>&lt;&lt; class gzFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1051"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1052"><vh>write</vh></v>
<v t="ekr.20040104185913.1053"><vh>getdata</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1054"><vh>@file version_txt.py</vh>
<v t="ekr.20040104185913.1056"><vh>intval</vh></v>
<v t="ekr.20040104185913.1057"><vh>strval</vh></v>
<v t="ekr.20040104185913.1058"><vh>_prep_version_data</vh></v>
<v t="ekr.20040104185913.1059"><vh>version_txt</vh></v>
<v t="ekr.20040104185913.1060"><vh>getZopeVersion</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1061" a="M"><vh>BTrees</vh>
<v t="ekr.20040104185913.1062" a="M" tnodeList="ekr.20040104185913.1062,ekr.20040104185913.1063,ekr.20040104185913.1064,ekr.20040104185913.1065,ekr.20040104185913.1066,ekr.20040104185913.1067,ekr.20040104185913.1068,ekr.20040104185913.1069,ekr.20040104185913.1070,ekr.20040104185913.1071,ekr.20040104185913.1072,ekr.20040104185913.1073"><vh>@file BTreeItemsTemplate.c</vh>
<v t="ekr.20040104185913.1063"><vh>&lt;&lt; BTreeItemsTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1064"><vh>BTreeItems_dealloc</vh></v>
<v t="ekr.20040104185913.1065"><vh>BTreeItems_length_or_nonzero</vh></v>
<v t="ekr.20040104185913.1066"><vh>BTreeItems_length</vh></v>
<v t="ekr.20040104185913.1067"><vh>BTreeItems_seek</vh></v>
<v t="ekr.20040104185913.1068"><vh>BTreeItems_item</vh></v>
<v t="ekr.20040104185913.1069"><vh>BTreeItems_slice</vh></v>
<v t="ekr.20040104185913.1070"><vh>BTreeItems_nonzero</vh></v>
<v t="ekr.20040104185913.1071"><vh>newBTreeItems</vh></v>
<v t="ekr.20040104185913.1072"><vh>nextBTreeItems</vh></v>
<v t="ekr.20040104185913.1073"><vh>nextTreeSetItems</vh></v>
</v>
<v t="ekr.20040104185913.1074" a="M"><vh>@file BTreeModuleTemplate.c</vh>
<v t="ekr.20040104185913.1075"><vh>&lt;&lt; BTreeModuleTemplate #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1076"><vh>&lt;&lt; BTreeModuleTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1077"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185913.1078"><vh>finiSetIteration</vh></v>
<v t="ekr.20040104185913.1079"><vh>IndexError</vh></v>
<v t="ekr.20040104185913.1080"><vh>PreviousBucket</vh></v>
<v t="ekr.20040104185913.1081"><vh>PyMalloc</vh></v>
<v t="ekr.20040104185913.1082"><vh>PyRealloc</vh></v>
<v t="ekr.20040104185913.1083"><vh>INITMODULE</vh></v>
</v>
<v t="ekr.20040104185913.1084" a="M" tnodeList="ekr.20040104185913.1084,ekr.20040104185913.1085,ekr.20040104185913.1086,ekr.20040104185913.1087,ekr.20040104185913.1088,ekr.20040104185913.1089,ekr.20040104185913.1090,ekr.20040104185913.1091,ekr.20040104185913.1092,ekr.20040104185913.1093,ekr.20040104185913.1094,ekr.20040104185913.1095,ekr.20040104185913.1096,ekr.20040104185913.1097,ekr.20040104185913.1098,ekr.20040104185913.1099,ekr.20040104185913.1100,ekr.20040104185913.1101,ekr.20040104185913.1102,ekr.20040104185913.1103,ekr.20040104185913.1104,ekr.20040104185913.1105,ekr.20040104185913.1106,ekr.20040104185913.1107,ekr.20040104185913.1108,ekr.20040104185913.1109,ekr.20040104185913.1110,ekr.20040104185913.1111,ekr.20040104185913.1112,ekr.20040104185913.1113,ekr.20040104185913.1114"><vh>@file BTreeTemplate.c</vh>
<v t="ekr.20040104185913.1085"><vh>&lt;&lt; BTreeTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1086"><vh>BTree_split_root</vh></v>
<v t="ekr.20040104185913.1087"><vh>BTree_grow</vh></v>
<v t="ekr.20040104185913.1088"><vh>BTree_lastBucket</vh></v>
<v t="ekr.20040104185913.1089"><vh>BTree_deleteNextBucket</vh></v>
<v t="ekr.20040104185913.1090"><vh>_BTree_clear</vh></v>
<v t="ekr.20040104185913.1091"><vh>_BTree_set</vh></v>
<v t="ekr.20040104185913.1092"><vh>BTree_setitem</vh></v>
<v t="ekr.20040104185913.1093"><vh>BTree__p_deactivate</vh></v>
<v t="ekr.20040104185913.1094"><vh>BTree_clear</vh></v>
<v t="ekr.20040104185913.1095"><vh>BTree_getstate</vh></v>
<v t="ekr.20040104185913.1096"><vh>_BTree_setstate</vh></v>
<v t="ekr.20040104185913.1097"><vh>BTree_setstate</vh></v>
<v t="ekr.20040104185913.1098"><vh>BTree__p_resolveConflict</vh></v>
<v t="ekr.20040104185913.1099"><vh>BTree_findRangeEnd</vh></v>
<v t="ekr.20040104185913.1100"><vh>BTree_maxminKey</vh></v>
<v t="ekr.20040104185913.1101"><vh>BTree_minKey</vh></v>
<v t="ekr.20040104185913.1102"><vh>BTree_maxKey</vh></v>
<v t="ekr.20040104185913.1103"><vh>BTree_rangeSearch</vh></v>
<v t="ekr.20040104185913.1104"><vh>BTree_keys</vh></v>
<v t="ekr.20040104185913.1105"><vh>BTree_values</vh></v>
<v t="ekr.20040104185913.1106"><vh>BTree_items</vh></v>
<v t="ekr.20040104185913.1107"><vh>BTree_byValue</vh></v>
<v t="ekr.20040104185913.1108"><vh>BTree_getm</vh></v>
<v t="ekr.20040104185913.1109"><vh>BTree_has_key</vh></v>
<v t="ekr.20040104185913.1110"><vh>BTree_addUnique</vh></v>
<v t="ekr.20040104185913.1111"><vh>BTree_dealloc</vh></v>
<v t="ekr.20040104185913.1112"><vh>BTree_length_or_nonzero</vh></v>
<v t="ekr.20040104185913.1113"><vh>BTree_length</vh></v>
<v t="ekr.20040104185913.1114"><vh>BTree_nonzero</vh></v>
</v>
<v t="ekr.20040104185913.1115" a="M" tnodeList="ekr.20040104185913.1115,ekr.20040104185913.1116,ekr.20040104185913.1117,ekr.20040104185913.1118,ekr.20040104185913.1119,ekr.20040104185913.1120,ekr.20040104185913.1121,ekr.20040104185913.1122"><vh>@file BucketTemplate.c</vh>
<v t="ekr.20040104185913.1116"><vh>&lt;&lt; BucketTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1117"><vh>_bucket__p_resolveConflict</vh></v>
<v t="ekr.20040104185913.1118"><vh>bucket__p_resolveConflict</vh></v>
<v t="ekr.20040104185913.1119"><vh>Bucket_dealloc</vh></v>
<v t="ekr.20040104185913.1120"><vh>Bucket_length</vh></v>
<v t="ekr.20040104185913.1121"><vh>bucket_repr</vh></v>
<v t="ekr.20040104185913.1122"><vh>nextBucket</vh></v>
</v>
<v t="ekr.20040104185913.1123"><vh>@file IIBTree.py</vh></v>
<v t="ekr.20040104185913.1124"><vh>@file IOBTree.py</vh></v>
<v t="ekr.20040104185913.1125" a="M"><vh>@file Interfaces.py</vh>
<v t="ekr.20040104185913.1126"><vh>&lt;&lt; Interfaces declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1127"><vh>class ICollection</vh>
<v t="ekr.20040104185913.1128"><vh>clear</vh></v>
<v t="ekr.20040104185913.1129"><vh>__nonzero__</vh></v>
</v>
<v t="ekr.20040104185913.1130"><vh>class IReadSequence</vh>
<v t="ekr.20040104185913.1131"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.1132"><vh>__getslice__</vh></v>
</v>
<v t="ekr.20040104185913.1133"><vh>class IKeyed</vh>
<v t="ekr.20040104185913.1134"><vh>has_key</vh></v>
<v t="ekr.20040104185913.1135"><vh>keys</vh></v>
<v t="ekr.20040104185913.1136"><vh>maxKey</vh></v>
<v t="ekr.20040104185913.1137"><vh>minKey</vh></v>
</v>
<v t="ekr.20040104185913.1138"><vh>class ISetMutable</vh>
<v t="ekr.20040104185913.1139"><vh>insert</vh></v>
<v t="ekr.20040104185913.1140"><vh>remove</vh></v>
<v t="ekr.20040104185913.1141"><vh>update</vh></v>
</v>
<v t="ekr.20040104185913.1142"><vh>class ISized</vh>
<v t="ekr.20040104185913.1143"><vh>&lt;&lt; class ISized declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1144"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.1145"><vh>class IKeySequence</vh>
<v t="ekr.20040104185913.1146"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.1147"><vh>class ISet</vh>
<v t="ekr.20040104185913.1148"><vh>&lt;&lt; class ISet declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1149"><vh>class ITreeSet</vh>
<v t="ekr.20040104185913.1150"><vh>&lt;&lt; class ITreeSet declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1151"><vh>class IMinimalDictionary</vh>
<v t="ekr.20040104185913.1152"><vh>has_key</vh></v>
<v t="ekr.20040104185913.1153"><vh>get</vh></v>
<v t="ekr.20040104185913.1154"><vh>__setitem__</vh></v>
<v t="ekr.20040104185913.1155"><vh>__delitem__</vh></v>
<v t="ekr.20040104185913.1156"><vh>values</vh></v>
<v t="ekr.20040104185913.1157"><vh>keys</vh></v>
<v t="ekr.20040104185913.1158"><vh>items</vh></v>
</v>
<v t="ekr.20040104185913.1159"><vh>class IDictionaryIsh</vh>
<v t="ekr.20040104185913.1160"><vh>update</vh></v>
<v t="ekr.20040104185913.1161"><vh>values</vh></v>
<v t="ekr.20040104185913.1162"><vh>items</vh></v>
<v t="ekr.20040104185913.1163"><vh>byValue</vh></v>
</v>
<v t="ekr.20040104185913.1164"><vh>class IBTree</vh>
<v t="ekr.20040104185913.1165"><vh>insert</vh></v>
</v>
<v t="ekr.20040104185913.1166"><vh>class IMerge</vh>
<v t="ekr.20040104185913.1167"><vh>difference</vh></v>
<v t="ekr.20040104185913.1168"><vh>union</vh></v>
<v t="ekr.20040104185913.1169"><vh>intersection</vh></v>
</v>
<v t="ekr.20040104185913.1170"><vh>class IIMerge</vh>
<v t="ekr.20040104185913.1171"><vh>weightedUnion</vh></v>
<v t="ekr.20040104185913.1172"><vh>weightedIntersection</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1173"><vh>@file Length.py</vh>
<v t="ekr.20040104185913.1175"><vh>class Length</vh>
<v t="ekr.20040104185913.1176"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1177"><vh>__getstate__</vh></v>
<v t="ekr.20040104185913.1178"><vh>__setstate__</vh></v>
<v t="ekr.20040104185913.1179"><vh>set</vh></v>
<v t="ekr.20040104185913.1180"><vh>_p_resolveConflict</vh></v>
<v t="ekr.20040104185913.1181"><vh>_p_independent</vh></v>
<v t="ekr.20040104185913.1182"><vh>change</vh></v>
<v t="ekr.20040104185913.1183"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1184"><vh>@file Maintainer.txt</vh></v>
<v t="ekr.20040104185913.1185" a="M" tnodeList="ekr.20040104185913.1185"><vh>@file MergeTemplate.c</vh></v>
<v t="ekr.20040104185913.1186"><vh>@file OIBTree.py</vh></v>
<v t="ekr.20040104185913.1187"><vh>@file OOBTree.py</vh></v>
<v t="ekr.20040104185913.1188" a="M"><vh>@file SetOpTemplate.c</vh>
<v t="ekr.20040104185913.1189"><vh>&lt;&lt; SetOpTemplate #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1190"><vh>nextIntSet</vh></v>
</v>
<v t="ekr.20040104185913.1191" a="M" tnodeList="ekr.20040104185913.1191,ekr.20040104185913.1192,ekr.20040104185913.1193,ekr.20040104185913.1194,ekr.20040104185913.1195,ekr.20040104185913.1196"><vh>@file SetTemplate.c</vh>
<v t="ekr.20040104185913.1192"><vh>&lt;&lt; SetTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1193"><vh>set_repr</vh></v>
<v t="ekr.20040104185913.1194"><vh>set_length</vh></v>
<v t="ekr.20040104185913.1195"><vh>set_item</vh></v>
<v t="ekr.20040104185913.1196"><vh>nextSet</vh></v>
</v>
<v t="ekr.20040104185913.1197" a="M" tnodeList="ekr.20040104185913.1197"><vh>@file TreeSetTemplate.c</vh></v>
<v t="ekr.20040104185913.1198"><vh>@file _IIBTree.c</vh>
<v t="ekr.20040104185913.1199"><vh>&lt;&lt; _IIBTree #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1200"><vh>@file _IOBTree.c</vh>
<v t="ekr.20040104185913.1201"><vh>&lt;&lt; _IOBTree #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1202"><vh>@file _OIBTree.c</vh>
<v t="ekr.20040104185913.1203"><vh>&lt;&lt; _OIBTree #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1204"><vh>@file _OOBTree.c</vh>
<v t="ekr.20040104185913.1205"><vh>&lt;&lt; _OOBTree #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1206"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1207" a="M"><vh>@file _fsBTree.c</vh>
<v t="ekr.20040104185913.1208"><vh>&lt;&lt; _fsBTree #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1209" a="M"><vh>@file check.py</vh>
<v t="ekr.20040104185913.1210"><vh>&lt;&lt; check declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1211"><vh>classify</vh></v>
<v t="ekr.20040104185913.1212"><vh>crack_btree</vh></v>
<v t="ekr.20040104185913.1213"><vh>crack_bucket</vh></v>
<v t="ekr.20040104185913.1214"><vh>type_and_adr</vh></v>
<v t="ekr.20040104185913.1215"><vh>class Walker</vh>
<v t="ekr.20040104185913.1216"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1217"><vh>visit_btree</vh></v>
<v t="ekr.20040104185913.1218"><vh>visit_bucket</vh></v>
<v t="ekr.20040104185913.1219"><vh>walk</vh></v>
</v>
<v t="ekr.20040104185913.1220"><vh>class Checker</vh>
<v t="ekr.20040104185913.1221"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1222"><vh>check</vh></v>
<v t="ekr.20040104185913.1223"><vh>visit_btree</vh></v>
<v t="ekr.20040104185913.1224"><vh>visit_bucket</vh></v>
<v t="ekr.20040104185913.1225"><vh>check_sorted</vh></v>
<v t="ekr.20040104185913.1226"><vh>complain</vh></v>
</v>
<v t="ekr.20040104185913.1227"><vh>class Printer</vh>
<v t="ekr.20040104185913.1228"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1229"><vh>display</vh></v>
<v t="ekr.20040104185913.1230"><vh>visit_btree</vh></v>
<v t="ekr.20040104185913.1231"><vh>visit_bucket</vh></v>
</v>
<v t="ekr.20040104185913.1232"><vh>check</vh></v>
<v t="ekr.20040104185913.1233"><vh>display</vh></v>
</v>
<v t="ekr.20040104185913.1234"><vh>@file convert.py</vh>
<v t="ekr.20040104185913.1236"><vh>convert</vh></v>
</v>
<v t="ekr.20040104185913.1237" a="M"><vh>@file sorters.c</vh>
<v t="ekr.20040104185913.1238"><vh>&lt;&lt; sorters #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1239"><vh>&lt;&lt; sorters declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1240"><vh>radixsort_int4</vh></v>
<v t="ekr.20040104185913.1241"><vh>uniq</vh></v>
<v t="ekr.20040104185913.1242"><vh>insertionsort</vh></v>
<v t="ekr.20040104185913.1243"><vh>quicksort</vh></v>
<v t="ekr.20040104185913.1244"><vh>sort_int4_nodups</vh></v>
</v>
<v t="ekr.20040104185913.1245" a="M"><vh>tests</vh>
<v t="ekr.20040104185913.1246"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1247"><vh>@file testBTrees.py</vh>
<v t="ekr.20040104185913.1248"><vh>&lt;&lt; testBTrees declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1249"><vh>class Base</vh>
<v t="ekr.20040104185913.1250"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.1251"><vh>_getRoot</vh></v>
<v t="ekr.20040104185913.1252"><vh>_closeDB</vh></v>
<v t="ekr.20040104185913.1253"><vh>_delDB</vh></v>
<v t="ekr.20040104185913.1254"><vh>testLoadAndStore</vh></v>
<v t="ekr.20040104185913.1255"><vh>testGhostUnghost</vh></v>
</v>
<v t="ekr.20040104185913.1256"><vh>class MappingBase</vh>
<v t="ekr.20040104185913.1257"><vh>_populate</vh></v>
<v t="ekr.20040104185913.1258"><vh>testGetItemFails</vh></v>
<v t="ekr.20040104185913.1259"><vh>_getitemfail</vh></v>
<v t="ekr.20040104185913.1260"><vh>testGetReturnsDefault</vh></v>
<v t="ekr.20040104185913.1261"><vh>testSetItemGetItemWorks</vh></v>
<v t="ekr.20040104185913.1262"><vh>testReplaceWorks</vh></v>
<v t="ekr.20040104185913.1263"><vh>testLen</vh></v>
<v t="ekr.20040104185913.1264"><vh>testHasKeyWorks</vh></v>
<v t="ekr.20040104185913.1265"><vh>testValuesWorks</vh></v>
<v t="ekr.20040104185913.1266"><vh>testValuesWorks1</vh></v>
<v t="ekr.20040104185913.1267"><vh>testKeysWorks</vh></v>
<v t="ekr.20040104185913.1268"><vh>testItemsWorks</vh></v>
<v t="ekr.20040104185913.1269"><vh>testDeleteInvalidKeyRaisesKeyError</vh></v>
<v t="ekr.20040104185913.1270"><vh>_deletefail</vh></v>
<v t="ekr.20040104185913.1271"><vh>testMaxKeyMinKey</vh></v>
<v t="ekr.20040104185913.1272"><vh>testClear</vh></v>
<v t="ekr.20040104185913.1273"><vh>testUpdate</vh></v>
<v t="ekr.20040104185913.1274"><vh>testEmptyRangeSearches</vh></v>
<v t="ekr.20040104185913.1275"><vh>testSlicing</vh></v>
<v t="ekr.20040104185913.1276"><vh>testBadUpdateTupleSize</vh></v>
</v>
<v t="ekr.20040104185913.1277"><vh>class NormalSetTests</vh>
<v t="ekr.20040104185913.1278"><vh>_populate</vh></v>
<v t="ekr.20040104185913.1279"><vh>testInsertReturnsValue</vh></v>
<v t="ekr.20040104185913.1280"><vh>testDuplicateInsert</vh></v>
<v t="ekr.20040104185913.1281"><vh>testInsert</vh></v>
<v t="ekr.20040104185913.1282"><vh>testBigInsert</vh></v>
<v t="ekr.20040104185913.1283"><vh>testRemoveSucceeds</vh></v>
<v t="ekr.20040104185913.1284"><vh>testRemoveFails</vh></v>
<v t="ekr.20040104185913.1285"><vh>_removenonexistent</vh></v>
<v t="ekr.20040104185913.1286"><vh>testHasKeyFails</vh></v>
<v t="ekr.20040104185913.1287"><vh>testKeys</vh></v>
<v t="ekr.20040104185913.1288"><vh>testClear</vh></v>
<v t="ekr.20040104185913.1289"><vh>testMaxKeyMinKey</vh></v>
<v t="ekr.20040104185913.1290"><vh>testUpdate</vh></v>
<v t="ekr.20040104185913.1291"><vh>testEmptyRangeSearches</vh></v>
<v t="ekr.20040104185913.1292"><vh>testSlicing</vh></v>
</v>
<v t="ekr.20040104185913.1293"><vh>class ExtendedSetTests</vh>
<v t="ekr.20040104185913.1294"><vh>testLen</vh></v>
<v t="ekr.20040104185913.1295"><vh>testGetItem</vh></v>
</v>
<v t="ekr.20040104185913.1296"><vh>class BucketTests</vh>
<v t="ekr.20040104185913.1297"><vh>&lt;&lt; class BucketTests declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1298"><vh>class BTreeTests</vh>
<v t="ekr.20040104185913.1299"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.1300"><vh>testDeleteNoChildrenWorks</vh></v>
<v t="ekr.20040104185913.1301"><vh>testDeleteOneChildWorks</vh></v>
<v t="ekr.20040104185913.1302"><vh>testDeleteTwoChildrenNoInorderSuccessorWorks</vh></v>
<v t="ekr.20040104185913.1303"><vh>testDeleteTwoChildrenInorderSuccessorWorks</vh></v>
<v t="ekr.20040104185913.1304"><vh>testDeleteRootWorks</vh></v>
<v t="ekr.20040104185913.1305"><vh>testRandomNonOverlappingInserts</vh></v>
<v t="ekr.20040104185913.1306"><vh>testRandomOverlappingInserts</vh></v>
<v t="ekr.20040104185913.1307"><vh>testRandomDeletes</vh></v>
<v t="ekr.20040104185913.1308"><vh>testTargetedDeletes</vh></v>
<v t="ekr.20040104185913.1309"><vh>testPathologicalRightBranching</vh></v>
<v t="ekr.20040104185913.1310"><vh>testPathologicalLeftBranching</vh></v>
<v t="ekr.20040104185913.1311"><vh>testSuccessorChildParentRewriteExerciseCase</vh></v>
<v t="ekr.20040104185913.1312"><vh>testRangeSearchAfterSequentialInsert</vh></v>
<v t="ekr.20040104185913.1313"><vh>testRangeSearchAfterRandomInsert</vh></v>
<v t="ekr.20040104185913.1314"><vh>testPathologicalRangeSearch</vh></v>
<v t="ekr.20040104185913.1315"><vh>testInsertMethod</vh></v>
<v t="ekr.20040104185913.1316"><vh>testDamagedIterator</vh></v>
</v>
<v t="ekr.20040104185913.1317"><vh>class TestIOBTrees</vh>
<v t="ekr.20040104185913.1318"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1319"><vh>nonIntegerKeyRaises</vh></v>
<v t="ekr.20040104185913.1320"><vh>_stringraises</vh></v>
<v t="ekr.20040104185913.1321"><vh>_floatraises</vh></v>
<v t="ekr.20040104185913.1322"><vh>_noneraises</vh></v>
<v t="ekr.20040104185913.1323"><vh>testEmptyFirstBucketReportedByGuido</vh></v>
</v>
<v t="ekr.20040104185913.1324"><vh>class TestOOBTrees</vh>
<v t="ekr.20040104185913.1325"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1326"><vh>class TestOIBTrees</vh>
<v t="ekr.20040104185913.1327"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1328"><vh>testNonIntegerValueRaises</vh></v>
<v t="ekr.20040104185913.1329"><vh>_stringraises</vh></v>
<v t="ekr.20040104185913.1330"><vh>_floatraises</vh></v>
<v t="ekr.20040104185913.1331"><vh>_noneraises</vh></v>
</v>
<v t="ekr.20040104185913.1332"><vh>class TestIIBTrees</vh>
<v t="ekr.20040104185913.1333"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1334"><vh>testNonIntegerKeyRaises</vh></v>
<v t="ekr.20040104185913.1335"><vh>testNonIntegerValueRaises</vh></v>
<v t="ekr.20040104185913.1336"><vh>_stringraiseskey</vh></v>
<v t="ekr.20040104185913.1337"><vh>_floatraiseskey</vh></v>
<v t="ekr.20040104185913.1338"><vh>_noneraiseskey</vh></v>
<v t="ekr.20040104185913.1339"><vh>_stringraisesvalue</vh></v>
<v t="ekr.20040104185913.1340"><vh>_floatraisesvalue</vh></v>
<v t="ekr.20040104185913.1341"><vh>_noneraisesvalue</vh></v>
</v>
<v t="ekr.20040104185913.1342"><vh>class TestIOSets</vh>
<v t="ekr.20040104185913.1343"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1344"><vh>testNonIntegerInsertRaises</vh></v>
<v t="ekr.20040104185913.1345"><vh>_insertstringraises</vh></v>
<v t="ekr.20040104185913.1346"><vh>_insertfloatraises</vh></v>
<v t="ekr.20040104185913.1347"><vh>_insertnoneraises</vh></v>
</v>
<v t="ekr.20040104185913.1348"><vh>class TestOOSets</vh>
<v t="ekr.20040104185913.1349"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1350"><vh>class TestIISets</vh>
<v t="ekr.20040104185913.1351"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1352"><vh>class TestOISets</vh>
<v t="ekr.20040104185913.1353"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1354"><vh>class TestIOTreeSets</vh>
<v t="ekr.20040104185913.1355"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1356"><vh>class TestOOTreeSets</vh>
<v t="ekr.20040104185913.1357"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1358"><vh>class TestIITreeSets</vh>
<v t="ekr.20040104185913.1359"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1360"><vh>_build_degenerate_tree</vh></v>
<v t="ekr.20040104185913.1361"><vh>testDegenerateBasicOps</vh></v>
<v t="ekr.20040104185913.1362"><vh>_checkRanges</vh></v>
<v t="ekr.20040104185913.1363"><vh>testRanges</vh></v>
<v t="ekr.20040104185913.1364"><vh>testDeletes</vh></v>
</v>
<v t="ekr.20040104185913.1365"><vh>class TestOITreeSets</vh>
<v t="ekr.20040104185913.1366"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1367"><vh>class TestIOBuckets</vh>
<v t="ekr.20040104185913.1368"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1369"><vh>class TestOOBuckets</vh>
<v t="ekr.20040104185913.1370"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1371"><vh>class TestIIBuckets</vh>
<v t="ekr.20040104185913.1372"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1373"><vh>class TestOIBuckets</vh>
<v t="ekr.20040104185913.1374"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1375"><vh>class DoesntLikeBeingCompared</vh>
<v t="ekr.20040104185913.1376"><vh>__cmp__</vh></v>
</v>
<v t="ekr.20040104185913.1377"><vh>class TestCmpError</vh>
<v t="ekr.20040104185913.1378"><vh>testFoo</vh></v>
</v>
<v t="ekr.20040104185913.1379"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.1380"><vh>lsubtract</vh></v>
<v t="ekr.20040104185913.1381"><vh>realseq</vh></v>
<v t="ekr.20040104185913.1382"><vh>permutations</vh></v>
<v t="ekr.20040104185913.1383"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.1384"><vh>@file testBTreesUnicode.py</vh>
<v t="ekr.20040104185913.1385"><vh>&lt;&lt; testBTreesUnicode declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1386"><vh>class TestBTreesUnicode</vh>
<v t="ekr.20040104185913.1387"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1388"><vh>testAllKeys</vh></v>
<v t="ekr.20040104185913.1389"><vh>testUnicodeKeys</vh></v>
<v t="ekr.20040104185913.1390"><vh>testAsciiKeys</vh></v>
</v>
<v t="ekr.20040104185913.1391"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.1392"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.1393"><vh>@file testConflict.py</vh>
<v t="ekr.20040104185913.1394"><vh>&lt;&lt; testConflict declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1395"><vh>class Base</vh>
<v t="ekr.20040104185913.1396"><vh>&lt;&lt; class Base declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1397"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.1398"><vh>openDB</vh></v>
</v>
<v t="ekr.20040104185913.1399"><vh>class MappingBase</vh>
<v t="ekr.20040104185913.1400"><vh>_deletefail</vh></v>
<v t="ekr.20040104185913.1401"><vh>_setupConflict</vh></v>
<v t="ekr.20040104185913.1402"><vh>testSimpleConflict</vh></v>
<v t="ekr.20040104185913.1403"><vh>testMergeDelete</vh></v>
<v t="ekr.20040104185913.1404"><vh>testMergeDeleteAndUpdate</vh></v>
<v t="ekr.20040104185913.1405"><vh>testMergeUpdate</vh></v>
<v t="ekr.20040104185913.1406"><vh>testFailMergeDelete</vh></v>
<v t="ekr.20040104185913.1407"><vh>testFailMergeUpdate</vh></v>
<v t="ekr.20040104185913.1408"><vh>testFailMergeDeleteAndUpdate</vh></v>
<v t="ekr.20040104185913.1409"><vh>testMergeInserts</vh></v>
<v t="ekr.20040104185913.1410"><vh>testMergeInsertsFromEmpty</vh></v>
<v t="ekr.20040104185913.1411"><vh>testMergeEmptyAndFill</vh></v>
<v t="ekr.20040104185913.1412"><vh>testMergeEmpty</vh></v>
<v t="ekr.20040104185913.1413"><vh>testFailMergeInsert</vh></v>
</v>
<v t="ekr.20040104185913.1414"><vh>class SetTests</vh>
<v t="ekr.20040104185913.1415"><vh>&lt;&lt; class SetTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1416"><vh>_setupConflict</vh></v>
<v t="ekr.20040104185913.1417"><vh>testMergeDelete</vh></v>
<v t="ekr.20040104185913.1418"><vh>testFailMergeDelete</vh></v>
<v t="ekr.20040104185913.1419"><vh>testMergeInserts</vh></v>
<v t="ekr.20040104185913.1420"><vh>testMergeInsertsFromEmpty</vh></v>
<v t="ekr.20040104185913.1421"><vh>testMergeEmptyAndFill</vh></v>
<v t="ekr.20040104185913.1422"><vh>testMergeEmpty</vh></v>
<v t="ekr.20040104185913.1423"><vh>testFailMergeInsert</vh></v>
</v>
<v t="ekr.20040104185913.1424"><vh>test_merge</vh></v>
<v t="ekr.20040104185913.1425"><vh>class BucketTests</vh></v>
<v t="ekr.20040104185913.1426"><vh>class BTreeTests</vh>
<v t="ekr.20040104185913.1427"><vh>&lt;&lt; class BTreeTests declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1428"><vh>class TestIOBTrees</vh>
<v t="ekr.20040104185913.1429"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1430"><vh>class TestOOBTrees</vh>
<v t="ekr.20040104185913.1431"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1432"><vh>class TestOIBTrees</vh>
<v t="ekr.20040104185913.1433"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1434"><vh>class TestIIBTrees</vh>
<v t="ekr.20040104185913.1435"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1436"><vh>class TestIOSets</vh>
<v t="ekr.20040104185913.1437"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1438"><vh>class TestOOSets</vh>
<v t="ekr.20040104185913.1439"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1440"><vh>class TestIISets</vh>
<v t="ekr.20040104185913.1441"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1442"><vh>class TestOISets</vh>
<v t="ekr.20040104185913.1443"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1444"><vh>class TestIOTreeSets</vh>
<v t="ekr.20040104185913.1445"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1446"><vh>class TestOOTreeSets</vh>
<v t="ekr.20040104185913.1447"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1448"><vh>class TestIITreeSets</vh>
<v t="ekr.20040104185913.1449"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1450"><vh>class TestOITreeSets</vh>
<v t="ekr.20040104185913.1451"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1452"><vh>class TestIOBuckets</vh>
<v t="ekr.20040104185913.1453"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1454"><vh>class TestOOBuckets</vh>
<v t="ekr.20040104185913.1455"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1456"><vh>class TestIIBuckets</vh>
<v t="ekr.20040104185913.1457"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1458"><vh>class TestOIBuckets</vh>
<v t="ekr.20040104185913.1459"><vh>setUp</vh></v>
</v>
<v t="ekr.20040104185913.1460"><vh>class NastyConfict</vh>
<v t="ekr.20040104185913.1461"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1462"><vh>testResolutionBlowsUp</vh></v>
<v t="ekr.20040104185913.1463"><vh>testBucketSplitConflict</vh></v>
<v t="ekr.20040104185913.1464"><vh>testEmptyBucketConflict</vh></v>
<v t="ekr.20040104185913.1465"><vh>testEmptyBucketNoConflict</vh></v>
</v>
<v t="ekr.20040104185913.1466"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.1467"><vh>@file testSetOps.py</vh>
<v t="ekr.20040104185913.1468"><vh>&lt;&lt; testSetOps declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1469"><vh>class SetResult</vh>
<v t="ekr.20040104185913.1470"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1471"><vh>_union</vh></v>
<v t="ekr.20040104185913.1472"><vh>_intersection</vh></v>
<v t="ekr.20040104185913.1473"><vh>_difference</vh></v>
<v t="ekr.20040104185913.1474"><vh>testNone</vh></v>
<v t="ekr.20040104185913.1475"><vh>testEmptyUnion</vh></v>
<v t="ekr.20040104185913.1476"><vh>testEmptyIntersection</vh></v>
<v t="ekr.20040104185913.1477"><vh>testEmptyDifference</vh></v>
<v t="ekr.20040104185913.1478"><vh>testUnion</vh></v>
<v t="ekr.20040104185913.1479"><vh>testIntersection</vh></v>
<v t="ekr.20040104185913.1480"><vh>testDifference</vh></v>
<v t="ekr.20040104185913.1481"><vh>testLargerInputs</vh></v>
</v>
<v t="ekr.20040104185913.1482"><vh>makeBuilder</vh></v>
<v t="ekr.20040104185913.1483"><vh>class PureII</vh>
<v t="ekr.20040104185913.1484"><vh>&lt;&lt; class PureII declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1485"><vh>class PureIO</vh>
<v t="ekr.20040104185913.1486"><vh>&lt;&lt; class PureIO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1487"><vh>class PureOO</vh>
<v t="ekr.20040104185913.1488"><vh>&lt;&lt; class PureOO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1489"><vh>class PureOI</vh>
<v t="ekr.20040104185913.1490"><vh>&lt;&lt; class PureOI declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1491"><vh>class MultiUnion</vh>
<v t="ekr.20040104185913.1492"><vh>testEmpty</vh></v>
<v t="ekr.20040104185913.1493"><vh>testOne</vh></v>
<v t="ekr.20040104185913.1494"><vh>testValuesIgnored</vh></v>
<v t="ekr.20040104185913.1495"><vh>testBigInput</vh></v>
<v t="ekr.20040104185913.1496"><vh>testLotsOfLittleOnes</vh></v>
<v t="ekr.20040104185913.1497"><vh>testFunkyKeyIteration</vh></v>
</v>
<v t="ekr.20040104185913.1498"><vh>class TestIIMultiUnion</vh>
<v t="ekr.20040104185913.1499"><vh>&lt;&lt; class TestIIMultiUnion declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1500"><vh>class TestIOMultiUnion</vh>
<v t="ekr.20040104185913.1501"><vh>&lt;&lt; class TestIOMultiUnion declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1502"><vh>class TestImports</vh>
<v t="ekr.20040104185913.1503"><vh>testWeightedUnion</vh></v>
<v t="ekr.20040104185913.1504"><vh>testWeightedIntersection</vh></v>
<v t="ekr.20040104185913.1505"><vh>testMultiunion</vh></v>
</v>
<v t="ekr.20040104185913.1506"><vh>class Weighted</vh>
<v t="ekr.20040104185913.1507"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1508"><vh>testBothNone</vh></v>
<v t="ekr.20040104185913.1509"><vh>testLeftNone</vh></v>
<v t="ekr.20040104185913.1510"><vh>testRightNone</vh></v>
<v t="ekr.20040104185913.1511"><vh>_normalize</vh></v>
<v t="ekr.20040104185913.1512"><vh>_wunion</vh></v>
<v t="ekr.20040104185913.1513"><vh>testUnion</vh></v>
<v t="ekr.20040104185913.1514"><vh>_wintersection</vh></v>
<v t="ekr.20040104185913.1515"><vh>testIntersection</vh></v>
</v>
<v t="ekr.20040104185913.1516"><vh>itemsToSet</vh></v>
<v t="ekr.20040104185913.1517"><vh>isaset</vh></v>
<v t="ekr.20040104185913.1518"><vh>class TestWeightedII</vh>
<v t="ekr.20040104185913.1519"><vh>&lt;&lt; class TestWeightedII declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1520"><vh>class TestWeightedOI</vh>
<v t="ekr.20040104185913.1521"><vh>&lt;&lt; class TestWeightedOI declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1522"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.1523"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.1524"><vh>@file test_check.py</vh>
<v t="ekr.20040104185913.1525"><vh>&lt;&lt; test_check declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1526"><vh>class CheckTest</vh>
<v t="ekr.20040104185913.1527"><vh>setUp</vh></v>
<v t="ekr.20040104185913.1528"><vh>testNormal</vh></v>
<v t="ekr.20040104185913.1529"><vh>testKeyTooLarge</vh></v>
<v t="ekr.20040104185913.1530"><vh>testKeyTooSmall</vh></v>
<v t="ekr.20040104185913.1531"><vh>testKeysSwapped</vh></v>
</v>
<v t="ekr.20040104185913.1532"><vh>test_suite</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.1533"><vh>DateTime</vh>
<v t="ekr.20040104185913.1534"><vh>@file DateTime.html</vh></v>
<v t="ekr.20040104185913.1535"><vh>@file DateTime.py</vh>
<v t="ekr.20040104185913.1536"><vh>&lt;&lt; DateTime imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1537"><vh>time</vh></v>
<v t="ekr.20040104185913.1538"><vh>class _timezone</vh>
<v t="ekr.20040104185913.1539"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1540"><vh>default_index</vh></v>
<v t="ekr.20040104185913.1541"><vh>index</vh></v>
<v t="ekr.20040104185913.1542"><vh>info</vh></v>
</v>
<v t="ekr.20040104185913.1543"><vh>class _cache</vh>
<v t="ekr.20040104185913.1544"><vh>&lt;&lt; class _cache declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1545"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1546"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.1547"><vh>_findLocalTimeZoneName</vh></v>
<v t="ekr.20040104185913.1548"><vh>_calcSD</vh></v>
<v t="ekr.20040104185913.1549"><vh>_calcDependentSecond</vh></v>
<v t="ekr.20040104185913.1550"><vh>_calcDependentSecond2</vh></v>
<v t="ekr.20040104185913.1551"><vh>_calcIndependentSecondEtc</vh></v>
<v t="ekr.20040104185913.1552"><vh>_calcHMS</vh></v>
<v t="ekr.20040104185913.1553"><vh>_calcYMDHMS</vh></v>
<v t="ekr.20040104185913.1554"><vh>_julianday</vh></v>
<v t="ekr.20040104185913.1555"><vh>_calendarday</vh></v>
<v t="ekr.20040104185913.1556"><vh>_tzoffset</vh></v>
<v t="ekr.20040104185913.1557"><vh>_correctYear</vh></v>
<v t="ekr.20040104185913.1558"><vh>safegmtime</vh></v>
<v t="ekr.20040104185913.1559"><vh>safelocaltime</vh></v>
<v t="ekr.20040104185913.1560"><vh>_tzoffset2rfc822zone</vh></v>
<v t="ekr.20040104185913.1561"><vh>class DateTime</vh>
<v t="ekr.20040104185913.1562"><vh>&lt;&lt; class DateTime declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1563"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1564"><vh>localZone</vh></v>
<v t="ekr.20040104185913.1565"><vh>_calcTimezoneName</vh></v>
<v t="ekr.20040104185913.1566"><vh>_parse</vh></v>
<v t="ekr.20040104185913.1567"><vh>__getinitargs__</vh></v>
<v t="ekr.20040104185913.1568"><vh>_validDate</vh></v>
<v t="ekr.20040104185913.1569"><vh>_validTime</vh></v>
<v t="ekr.20040104185913.1570"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.1571"><vh>timeTime</vh></v>
<v t="ekr.20040104185913.1572"><vh>toZone</vh></v>
<v t="ekr.20040104185913.1573"><vh>isFuture</vh></v>
<v t="ekr.20040104185913.1574"><vh>isPast</vh></v>
<v t="ekr.20040104185913.1575"><vh>isCurrentYear</vh></v>
<v t="ekr.20040104185913.1576"><vh>isCurrentMonth</vh></v>
<v t="ekr.20040104185913.1577"><vh>isCurrentDay</vh></v>
<v t="ekr.20040104185913.1578"><vh>isCurrentHour</vh></v>
<v t="ekr.20040104185913.1579"><vh>isCurrentMinute</vh></v>
<v t="ekr.20040104185913.1580"><vh>earliestTime</vh></v>
<v t="ekr.20040104185913.1581"><vh>latestTime</vh></v>
<v t="ekr.20040104185913.1582"><vh>greaterThan</vh></v>
<v t="ekr.20040104185913.1583"><vh>greaterThanEqualTo</vh></v>
<v t="ekr.20040104185913.1584"><vh>equalTo</vh></v>
<v t="ekr.20040104185913.1585"><vh>notEqualTo</vh></v>
<v t="ekr.20040104185913.1586"><vh>lessThan</vh></v>
<v t="ekr.20040104185913.1587"><vh>lessThanEqualTo</vh></v>
<v t="ekr.20040104185913.1588"><vh>isLeapYear</vh></v>
<v t="ekr.20040104185913.1589"><vh>dayOfYear</vh></v>
<v t="ekr.20040104185913.1590"><vh>parts</vh></v>
<v t="ekr.20040104185913.1591"><vh>timezone</vh></v>
<v t="ekr.20040104185913.1592"><vh>tzoffset</vh></v>
<v t="ekr.20040104185913.1593"><vh>year</vh></v>
<v t="ekr.20040104185913.1594"><vh>month</vh></v>
<v t="ekr.20040104185913.1595"><vh>Month</vh></v>
<v t="ekr.20040104185913.1596"><vh>aMonth</vh></v>
<v t="ekr.20040104185913.1597"><vh>Mon</vh></v>
<v t="ekr.20040104185913.1598"><vh>pMonth</vh></v>
<v t="ekr.20040104185913.1599"><vh>Mon_</vh></v>
<v t="ekr.20040104185913.1600"><vh>day</vh></v>
<v t="ekr.20040104185913.1601"><vh>Day</vh></v>
<v t="ekr.20040104185913.1602"><vh>DayOfWeek</vh></v>
<v t="ekr.20040104185913.1603"><vh>aDay</vh></v>
<v t="ekr.20040104185913.1604"><vh>pDay</vh></v>
<v t="ekr.20040104185913.1605"><vh>Day_</vh></v>
<v t="ekr.20040104185913.1606"><vh>dow</vh></v>
<v t="ekr.20040104185913.1607"><vh>dow_1</vh></v>
<v t="ekr.20040104185913.1608"><vh>h_12</vh></v>
<v t="ekr.20040104185913.1609"><vh>h_24</vh></v>
<v t="ekr.20040104185913.1610"><vh>ampm</vh></v>
<v t="ekr.20040104185913.1611"><vh>hour</vh></v>
<v t="ekr.20040104185913.1612"><vh>minute</vh></v>
<v t="ekr.20040104185913.1613"><vh>second</vh></v>
<v t="ekr.20040104185913.1614"><vh>millis</vh></v>
<v t="ekr.20040104185913.1615"><vh>_upgrade_old</vh></v>
<v t="ekr.20040104185913.1616"><vh>strftime</vh></v>
<v t="ekr.20040104185913.1617"><vh>Date</vh></v>
<v t="ekr.20040104185913.1618"><vh>Time</vh></v>
<v t="ekr.20040104185913.1619"><vh>TimeMinutes</vh></v>
<v t="ekr.20040104185913.1620"><vh>AMPM</vh></v>
<v t="ekr.20040104185913.1621"><vh>AMPMMinutes</vh></v>
<v t="ekr.20040104185913.1622"><vh>PreciseTime</vh></v>
<v t="ekr.20040104185913.1623"><vh>PreciseAMPM</vh></v>
<v t="ekr.20040104185913.1624"><vh>yy</vh></v>
<v t="ekr.20040104185913.1625"><vh>mm</vh></v>
<v t="ekr.20040104185913.1626"><vh>dd</vh></v>
<v t="ekr.20040104185913.1627"><vh>rfc822</vh></v>
<v t="ekr.20040104185913.1628"><vh>fCommon</vh></v>
<v t="ekr.20040104185913.1629"><vh>fCommonZ</vh></v>
<v t="ekr.20040104185913.1630"><vh>aCommon</vh></v>
<v t="ekr.20040104185913.1631"><vh>aCommonZ</vh></v>
<v t="ekr.20040104185913.1632"><vh>pCommon</vh></v>
<v t="ekr.20040104185913.1633"><vh>pCommonZ</vh></v>
<v t="ekr.20040104185913.1634"><vh>ISO</vh></v>
<v t="ekr.20040104185913.1635"><vh>HTML4</vh></v>
<v t="ekr.20040104185913.1636"><vh>__add__</vh></v>
<v t="ekr.20040104185913.1637"><vh>__sub__</vh></v>
<v t="ekr.20040104185913.1638"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.1639"><vh>__str__</vh></v>
<v t="ekr.20040104185913.1640"><vh>__cmp__</vh></v>
<v t="ekr.20040104185913.1641"><vh>__hash__</vh></v>
<v t="ekr.20040104185913.1642"><vh>__int__</vh></v>
<v t="ekr.20040104185913.1643"><vh>__long__</vh></v>
<v t="ekr.20040104185913.1644"><vh>__float__</vh></v>
<v t="ekr.20040104185913.1645"><vh>_parse_iso8601</vh></v>
<v t="ekr.20040104185913.1646"><vh>__parse_iso8601</vh></v>
<v t="ekr.20040104185913.1647"><vh>JulianDay</vh></v>
<v t="ekr.20040104185913.1648"><vh>week</vh></v>
</v>
<v t="ekr.20040104185913.1649"><vh>class strftimeFormatter</vh>
<v t="ekr.20040104185913.1650"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1651"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1652"><vh>Timezones</vh></v>
</v>
<v t="ekr.20040104185913.1653"><vh>@file DateTimeZone.py</vh>
<v t="ekr.20040104202012"><vh>&lt;&lt; define _data &gt;&gt; (big)</vh></v>
</v>
<v t="ekr.20040104185913.1654"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1655"><vh>tests</vh>
<v t="ekr.20040104185913.1656"><vh>@file testDateTime.py</vh>
<v t="ekr.20040104185913.1657"><vh>&lt;&lt; testDateTime declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1658"><vh>class DateTimeTests</vh>
<v t="ekr.20040104185913.1659"><vh>_compare</vh></v>
<v t="ekr.20040104185913.1660"><vh>testBug1203</vh></v>
<v t="ekr.20040104185913.1661"><vh>testDSTInEffect</vh></v>
<v t="ekr.20040104185913.1662"><vh>testDSTNotInEffect</vh></v>
<v t="ekr.20040104185913.1663"><vh>testAddPrecision</vh></v>
<v t="ekr.20040104185913.1664"><vh>testConstructor3</vh></v>
<v t="ekr.20040104185913.1665"><vh>testConstructor4</vh></v>
<v t="ekr.20040104185913.1666"><vh>testConstructor5</vh></v>
<v t="ekr.20040104185913.1667"><vh>testConstructor6</vh></v>
<v t="ekr.20040104185913.1668"><vh>testConstructor7</vh></v>
<v t="ekr.20040104185913.1669"><vh>testDayOfWeek</vh></v>
<v t="ekr.20040104185913.1670"><vh>testOldDate</vh></v>
<v t="ekr.20040104185913.1671"><vh>testSubtraction</vh></v>
<v t="ekr.20040104185913.1672"><vh>testTZ1add</vh></v>
<v t="ekr.20040104185913.1673"><vh>testTZ1sub</vh></v>
<v t="ekr.20040104185913.1674"><vh>testTZ1diff</vh></v>
<v t="ekr.20040104185913.1675"><vh>testCompareMethods</vh></v>
<v t="ekr.20040104185913.1676"><vh>testCompareOperations</vh></v>
<v t="ekr.20040104185913.1677"><vh>testUpgradeOldInstances</vh></v>
<v t="ekr.20040104185913.1678"><vh>testTZ2</vh></v>
<v t="ekr.20040104185913.1679"><vh>testTZDiffDaylight</vh></v>
<v t="ekr.20040104185913.1680"><vh>testY10KDate</vh></v>
<v t="ekr.20040104185913.1681"><vh>test_tzoffset</vh></v>
<v t="ekr.20040104185913.1682"><vh>testISO8601</vh></v>
<v t="ekr.20040104185913.1683"><vh>testJulianWeek</vh></v>
<v t="ekr.20040104185913.1684"><vh>testRFC822</vh></v>
</v>
<v t="ekr.20040104185913.1685"><vh>test_suite</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.1686" a="M"><vh>DocumentTemplate</vh>
<v t="ekr.20040104213514"><vh>top level</vh>
<v t="ekr.20040104185913.1687"><vh>@file DT_HTML.py</vh>
<v t="ekr.20040104185913.1688"><vh>&lt;&lt; DT_HTML imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1689"><vh>class dtml_re_class</vh>
<v t="ekr.20040104185913.1690"><vh>search</vh></v>
<v t="ekr.20040104185913.1691"><vh>group</vh></v>
<v t="ekr.20040104185913.1692"><vh>start</vh></v>
</v>
<v t="ekr.20040104185913.1693"><vh>class HTML</vh>
<v t="ekr.20040104185913.1694"><vh>&lt;&lt; class HTML declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1695"><vh>tagre</vh></v>
<v t="ekr.20040104185913.1696"><vh>parseTag</vh></v>
<v t="ekr.20040104185913.1697"><vh>SubTemplate</vh></v>
<v t="ekr.20040104185913.1698"><vh>varExtra</vh></v>
<v t="ekr.20040104185913.1699"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.1700"><vh>quotedHTML</vh></v>
<v t="ekr.20040104185913.1701"><vh>__str__</vh></v>
<v t="ekr.20040104185913.1702"><vh>management_interface</vh></v>
<v t="ekr.20040104185913.1703"><vh>manage_editForm</vh></v>
</v>
<v t="ekr.20040104185913.1704"><vh>class HTMLDefault</vh>
<v t="ekr.20040104185913.1705"><vh>&lt;&lt; class HTMLDefault declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1706"><vh>manage_edit</vh></v>
</v>
<v t="ekr.20040104185913.1707"><vh>class HTMLFile</vh>
<v t="ekr.20040104185913.1708"><vh>&lt;&lt; class HTMLFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1709"><vh>manage_default</vh></v>
<v t="ekr.20040104185913.1710"><vh>manage_editForm</vh></v>
<v t="ekr.20040104185913.1711"><vh>manage_edit</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1712"><vh>@file DT_If.py</vh>
<v t="ekr.20040104185913.1713"><vh>&lt;&lt; DT_If __doc__ &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1714"><vh>class If</vh>
<v t="ekr.20040104185913.1715"><vh>&lt;&lt; class If declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1716"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.1717"><vh>class Unless</vh>
<v t="ekr.20040104185913.1718"><vh>&lt;&lt; class Unless declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1719"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.1720"><vh>class Else</vh>
<v t="ekr.20040104185913.1721"><vh>&lt;&lt; class Else declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1722"><vh>@file DT_In.py</vh>
<v t="ekr.20040104185913.1723"><vh>&lt;&lt; DT_In __doc__ &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1724"><vh>class InFactory</vh>
<v t="ekr.20040104185913.1725"><vh>&lt;&lt; class InFactory declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1726"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1727"><vh>class InClass</vh>
<v t="ekr.20040104185913.1728"><vh>&lt;&lt; class InClass declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1729"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1730"><vh>renderwb</vh></v>
<v t="ekr.20040104185913.1731"><vh>renderwob</vh></v>
<v t="ekr.20040104185913.1732"><vh>sort_sequence</vh></v>
<v t="ekr.20040104185913.1733"><vh>reverse_sequence</vh></v>
</v>
<v t="ekr.20040104185913.1734"><vh>int_param</vh></v>
<v t="ekr.20040104185913.1735"><vh>nocase</vh></v>
<v t="ekr.20040104185913.1736"><vh>strcoll_nocase</vh></v>
<v t="ekr.20040104185913.1737"><vh>make_sortfunctions</vh></v>
<v t="ekr.20040104185913.1738"><vh>class SortBy</vh>
<v t="ekr.20040104185913.1739"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1740"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1741"><vh>@file DT_InSV.py</vh>
<v t="ekr.20040104185913.1742"><vh>&lt;&lt; DT_InSV imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1743"><vh>class sequence_variables</vh>
<v t="ekr.20040104185913.1745"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1746"><vh>__len__</vh></v>
<v t="ekr.20040104185913.1747"><vh>number</vh></v>
<v t="ekr.20040104185913.1748"><vh>even</vh></v>
<v t="ekr.20040104185913.1749"><vh>odd</vh></v>
<v t="ekr.20040104185913.1750"><vh>letter</vh></v>
<v t="ekr.20040104185913.1751"><vh>Letter</vh></v>
<v t="ekr.20040104185913.1752"><vh>key</vh></v>
<v t="ekr.20040104185913.1753"><vh>item</vh></v>
<v t="ekr.20040104185913.1754"><vh>roman</vh></v>
<v t="ekr.20040104185913.1755"><vh>Roman</vh></v>
<v t="ekr.20040104185913.1756"><vh>value</vh></v>
<v t="ekr.20040104185913.1757"><vh>first</vh></v>
<v t="ekr.20040104185913.1758"><vh>last</vh></v>
<v t="ekr.20040104185913.1759"><vh>length</vh></v>
<v t="ekr.20040104185913.1760"><vh>query</vh></v>
<v t="ekr.20040104185913.1761"><vh>statistics</vh></v>
<v t="ekr.20040104185913.1762"><vh>next_batches</vh></v>
<v t="ekr.20040104185913.1763"><vh>previous_batches</vh></v>
<v t="ekr.20040104185913.1764"><vh>__setitem__</vh></v>
<v t="ekr.20040104185913.1765"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.1766"><vh>opt</vh></v>
</v>
<v t="ekr.20040104185913.1767" a="M"><vh>@file DT_Let.py</vh>
<v t="ekr.20040104185913.1768"><vh>&lt;&lt; DT_Let declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1769"><vh>class Let</vh>
<v t="ekr.20040104185913.1770"><vh>&lt;&lt; class Let declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1771"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1772"><vh>render</vh></v>
</v>
<v t="ekr.20040104185913.1773"><vh>parse_let_params</vh></v>
</v>
<v t="ekr.20040104185913.1774" a="M"><vh>@file DT_Raise.py</vh>
<v t="ekr.20040104185913.1775"><vh>&lt;&lt; DT_Raise declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1776"><vh>class Raise</vh>
<v t="ekr.20040104185913.1777"><vh>&lt;&lt; class Raise declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1778"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1779"><vh>render</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1780" a="M"><vh>@file DT_Return.py</vh>
<v t="ekr.20040104185913.1781"><vh>&lt;&lt; DT_Return declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1782"><vh>class ReturnTag</vh>
<v t="ekr.20040104185913.1783"><vh>&lt;&lt; class ReturnTag declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1784"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1785"><vh>render</vh></v>
</v>
<v t="ekr.20040104185913.1786"><vh>class DTReturn</vh>
<v t="ekr.20040104185913.1787"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1788" a="M"><vh>@file DT_String.py</vh>
<v t="ekr.20040104185913.1789"><vh>&lt;&lt; DT_String declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1790"><vh>class String</vh>
<v t="ekr.20040104185913.1791"><vh>&lt;&lt; class String declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1792"><vh>class func_code</vh>
<v t="ekr.20040104185913.1793"><vh>&lt;&lt; class func_code declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1794"><vh>errQuote</vh></v>
<v t="ekr.20040104185913.1795"><vh>parse_error</vh></v>
<v t="ekr.20040104185913.1796"><vh>SubTemplate</vh></v>
<v t="ekr.20040104185913.1797"><vh>tagre</vh></v>
<v t="ekr.20040104185913.1798"><vh>_parseTag</vh></v>
<v t="ekr.20040104185913.1799"><vh>parseTag</vh></v>
<v t="ekr.20040104185913.1800"><vh>varExtra</vh></v>
<v t="ekr.20040104185913.1801"><vh>parse</vh></v>
<v t="ekr.20040104185913.1802"><vh>skip_eol</vh></v>
<v t="ekr.20040104185913.1803"><vh>parse_block</vh></v>
<v t="ekr.20040104185913.1804"><vh>parse_close</vh></v>
<v t="ekr.20040104185913.1805"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1806"><vh>name</vh></v>
<v t="ekr.20040104185913.1807"><vh>setName</vh></v>
<v t="ekr.20040104185913.1808"><vh>default</vh></v>
<v t="ekr.20040104185913.1809"><vh>var</vh></v>
<v t="ekr.20040104185913.1810"><vh>munge</vh></v>
<v t="ekr.20040104185913.1811"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.1812"><vh>read_raw</vh></v>
<v t="ekr.20040104185913.1813"><vh>read</vh></v>
<v t="ekr.20040104185913.1814"><vh>cook</vh></v>
<v t="ekr.20040104185913.1815"><vh>initvars</vh></v>
<v t="ekr.20040104185913.1816"><vh>ZDocumentTemplate_beforeRender</vh></v>
<v t="ekr.20040104185913.1817"><vh>ZDocumentTemplate_afterRender</vh></v>
<v t="ekr.20040104185913.1818"><vh>__call__</vh></v>
<v t="ekr.20040104185913.1819"><vh>__str__</vh></v>
<v t="ekr.20040104185913.1820"><vh>__getstate__</vh></v>
</v>
<v t="ekr.20040104185913.1821"><vh>class FileMixin</vh>
<v t="ekr.20040104185913.1822"><vh>&lt;&lt; class FileMixin declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1823"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1824"><vh>read_raw</vh></v>
</v>
<v t="ekr.20040104185913.1825"><vh>class File</vh>
<v t="ekr.20040104185913.1826"><vh>&lt;&lt; class File declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1827"><vh>manage_edit</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1828" a="M"><vh>@file DT_Try.py</vh>
<v t="ekr.20040104185913.1829"><vh>&lt;&lt; DT_Try declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1830"><vh>class Try</vh>
<v t="ekr.20040104185913.1831"><vh>&lt;&lt; class Try declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1832"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1833"><vh>render</vh></v>
<v t="ekr.20040104185913.1834"><vh>render_try_except</vh></v>
<v t="ekr.20040104185913.1835"><vh>render_try_finally</vh></v>
<v t="ekr.20040104185913.1836"><vh>find_handler</vh></v>
<v t="ekr.20040104185913.1837"><vh>match_base</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1838" a="M"><vh>@file DT_UI.py</vh></v>
<v t="ekr.20040104185913.1839" a="M"><vh>@file DT_Util.py</vh>
<v t="ekr.20040104185913.1840"><vh>&lt;&lt; DT_Util declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1841"><vh>int_param</vh></v>
<v t="ekr.20040104185913.1842"><vh>class NotBindable</vh>
<v t="ekr.20040104185913.1843"><vh>&lt;&lt; class NotBindable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1844"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.1845"><vh>class StringModuleWrapper</vh>
<v t="ekr.20040104185913.1846"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040104185913.1847"><vh>class StringFunctionWrapper</vh>
<v t="ekr.20040104185913.1848"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1849"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1850"><vh>careful_getattr</vh></v>
<v t="ekr.20040104185913.1851"><vh>careful_hasattr</vh></v>
<v t="ekr.20040104185913.1852"><vh>namespace</vh></v>
<v t="ekr.20040104185913.1853"><vh>render</vh></v>
<v t="ekr.20040104185913.1854"><vh>class Eval</vh>
<v t="ekr.20040104185913.1855"><vh>eval</vh></v>
<v t="ekr.20040104185913.1856"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1857"><vh>class Add_with_prefix</vh>
<v t="ekr.20040104185913.1858"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1859"><vh>__setitem__</vh></v>
</v>
<v t="ekr.20040104185913.1860"><vh>add_with_prefix</vh></v>
<v t="ekr.20040104185913.1861"><vh>name_param</vh></v>
<v t="ekr.20040104185913.1862"><vh>parse_params</vh></v>
</v>
<v t="ekr.20040104185913.1863" a="M"><vh>@file DT_Var.py</vh>
<v t="ekr.20040104185913.1864"><vh>&lt;&lt; DT_Var declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1865"><vh>class Var</vh>
<v t="ekr.20040104185913.1866"><vh>&lt;&lt; class Var declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1867"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1868"><vh>render</vh></v>
</v>
<v t="ekr.20040104185913.1869"><vh>class Call</vh>
<v t="ekr.20040104185913.1870"><vh>&lt;&lt; class Call declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1871"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.1872"><vh>url_quote</vh></v>
<v t="ekr.20040104185913.1873"><vh>url_quote_plus</vh></v>
<v t="ekr.20040104185913.1874"><vh>url_unquote</vh></v>
<v t="ekr.20040104185913.1875"><vh>url_unquote_plus</vh></v>
<v t="ekr.20040104185913.1876"><vh>newline_to_br</vh></v>
<v t="ekr.20040104185913.1877"><vh>whole_dollars</vh></v>
<v t="ekr.20040104185913.1878"><vh>dollars_and_cents</vh></v>
<v t="ekr.20040104185913.1879"><vh>thousands_commas</vh></v>
<v t="ekr.20040104185913.1880"><vh>whole_dollars_with_commas</vh></v>
<v t="ekr.20040104185913.1881"><vh>dollars_and_cents_with_commas</vh></v>
<v t="ekr.20040104185913.1882"><vh>len_format</vh></v>
<v t="ekr.20040104185913.1883"><vh>len_comma</vh></v>
<v t="ekr.20040104185913.1884"><vh>structured_text</vh></v>
<v t="ekr.20040104185913.1885"><vh>sql_quote</vh></v>
<v t="ekr.20040104185913.1886"><vh>spacify</vh></v>
<v t="ekr.20040104185913.1887"><vh>class Comment</vh>
<v t="ekr.20040104185913.1888"><vh>&lt;&lt; class Comment declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1889"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1890"><vh>render</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1891" a="M"><vh>@file DT_With.py</vh>
<v t="ekr.20040104185913.1892"><vh>&lt;&lt; DT_With declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1893"><vh>class With</vh>
<v t="ekr.20040104185913.1894"><vh>&lt;&lt; class With declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1895"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1896"><vh>render</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1897" a="M"><vh>@file DTtestExpr.py</vh>
<v t="ekr.20040104185913.1898"><vh>&lt;&lt; DTtestExpr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1899"><vh>test1</vh></v>
<v t="ekr.20040104185913.1900"><vh>test2</vh></v>
<v t="ekr.20040104185913.1901"><vh>test3</vh></v>
<v t="ekr.20040104185913.1902"><vh>test4</vh></v>
</v>
<v t="ekr.20040104185913.1903" a="M"><vh>@file DocumentTemplate.py</vh></v>
<v t="ekr.20040104185913.1904" a="M"><vh>@file VSEval.py</vh>
<v t="ekr.20040104185913.1905"><vh>&lt;&lt; VSEval declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1906"><vh>careful_mul</vh></v>
</v>
<v t="ekr.20040104185913.1907" a="M"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1908" a="M"><vh>@file cDocumentTemplate.c</vh>
<v t="ekr.20040104185913.1909"><vh>&lt;&lt; cDocumentTemplate #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1910"><vh>&lt;&lt; cDocumentTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1911"><vh>PyVar_Assign</vh></v>
<v t="ekr.20040104185913.1912"><vh>InstanceDict___init__</vh></v>
<v t="ekr.20040104185913.1913"><vh>InstanceDict_dealloc</vh></v>
<v t="ekr.20040104185913.1914"><vh>InstanceDict_getattr</vh></v>
<v t="ekr.20040104185913.1915"><vh>InstanceDict_repr</vh></v>
<v t="ekr.20040104185913.1916"><vh>InstanceDict_length</vh></v>
<v t="ekr.20040104185913.1917"><vh>InstanceDict_subscript</vh></v>
<v t="ekr.20040104185913.1918"><vh>InstanceDict_ass_sub</vh></v>
<v t="ekr.20040104185913.1919"><vh>MM_push</vh></v>
<v t="ekr.20040104185913.1920"><vh>MM_pop</vh></v>
<v t="ekr.20040104185913.1921"><vh>MM__init__</vh></v>
<v t="ekr.20040104185913.1922"><vh>safe_PyCallable_Check</vh></v>
<v t="ekr.20040104185913.1923"><vh>dtObjectIsCallable</vh></v>
<v t="ekr.20040104185913.1924"><vh>dtObjectIsDocTemp</vh></v>
<v t="ekr.20040104185913.1925"><vh>MM_cget</vh></v>
<v t="ekr.20040104185913.1926"><vh>MM_get</vh></v>
<v t="ekr.20040104185913.1927"><vh>MM_has_key</vh></v>
<v t="ekr.20040104185913.1928"><vh>MM_dealloc</vh></v>
<v t="ekr.20040104185913.1929"><vh>MM_getattro</vh></v>
<v t="ekr.20040104185913.1930"><vh>MM_setattro</vh></v>
<v t="ekr.20040104185913.1931"><vh>MM_length</vh></v>
<v t="ekr.20040104185913.1932"><vh>MM_subscript</vh></v>
<v t="ekr.20040104185913.1933"><vh>DictInstance_dealloc</vh></v>
<v t="ekr.20040104185913.1934"><vh>DictInstance_getattr</vh></v>
<v t="ekr.20040104185913.1935"><vh>newDictInstance</vh></v>
<v t="ekr.20040104185913.1936"><vh>MM_call</vh></v>
<v t="ekr.20040104185913.1937"><vh>if_finally</vh></v>
<v t="ekr.20040104185913.1938"><vh>render_blocks_</vh></v>
<v t="ekr.20040104185913.1939"><vh>render_blocks</vh></v>
<v t="ekr.20040104185913.1940"><vh>safe_callable</vh></v>
<v t="ekr.20040104185913.1941"><vh>_join_unicode</vh></v>
<v t="ekr.20040104185913.1942"><vh>join_unicode</vh></v>
<v t="ekr.20040104185913.1943"><vh>initcDocumentTemplate</vh></v>
</v>
<v t="ekr.20040104185913.1944" a="M"><vh>@file html_quote.py</vh>
<v t="ekr.20040104185913.1945"><vh>&lt;&lt; html_quote declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1946"><vh>html_quote</vh></v>
</v>
<v t="ekr.20040104185913.1947" a="M"><vh>@file pDocumentTemplate.py</vh>
<v t="ekr.20040104185913.1948"><vh>&lt;&lt; pDocumentTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1949"><vh>class c</vh>
<v t="ekr.20040104185913.1950"><vh>&lt;&lt; class c declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.1951"><vh>safe_callable</vh></v>
<v t="ekr.20040104185913.1952"><vh>class InstanceDict</vh>
<v t="ekr.20040104185913.1953"><vh>&lt;&lt; class InstanceDict declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1954"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1955"><vh>has_key</vh></v>
<v t="ekr.20040104185913.1956"><vh>keys</vh></v>
<v t="ekr.20040104185913.1957"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.1958"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.1959"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.1960"><vh>class MultiMapping</vh>
<v t="ekr.20040104185913.1961"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1962"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.1963"><vh>push</vh></v>
<v t="ekr.20040104185913.1964"><vh>pop</vh></v>
<v t="ekr.20040104185913.1965"><vh>keys</vh></v>
</v>
<v t="ekr.20040104185913.1966"><vh>class DictInstance</vh>
<v t="ekr.20040104185913.1967"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1968"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040104185913.1969"><vh>class TemplateDict</vh>
<v t="ekr.20040104185913.1970"><vh>&lt;&lt; class TemplateDict declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1971"><vh>_pop</vh></v>
<v t="ekr.20040104185913.1972"><vh>_push</vh></v>
<v t="ekr.20040104185913.1973"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1974"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.1975"><vh>__len__</vh></v>
<v t="ekr.20040104185913.1976"><vh>has_key</vh></v>
<v t="ekr.20040104185913.1977"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.1978"><vh>render_blocks</vh></v>
<v t="ekr.20040104185913.1979"><vh>join_unicode</vh></v>
</v>
<v t="ekr.20040104185913.1980"><vh>@file ustr.py</vh>
<v t="ekr.20040104185913.1982"><vh>ustr</vh></v>
<v t="ekr.20040104185913.1983"><vh>_exception_str</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1984"><vh>sequence</vh>
<v t="ekr.20040104185913.1985"><vh>@file SortEx.py</vh>
<v t="ekr.20040104185913.1986"><vh>&lt;&lt; SortEx declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.1987"><vh>sort</vh></v>
<v t="ekr.20040104185913.1988"><vh>nocase</vh></v>
<v t="ekr.20040104185913.1989"><vh>strcoll_nocase</vh></v>
<v t="ekr.20040104185913.1990"><vh>make_sortfunctions</vh></v>
<v t="ekr.20040104185913.1991"><vh>class SortBy</vh>
<v t="ekr.20040104185913.1992"><vh>__init__</vh></v>
<v t="ekr.20040104185913.1993"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.1994"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1995"><vh>c:/prog/Zope-2.6.2-src/lib/python\DocumentTemplate\sequence\tests</vh>
<v t="ekr.20040104185913.1996"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.1997"><vh>@file results.py</vh></v>
<v t="ekr.20040104185913.1998"><vh>@file testSequence.py</vh>
<v t="ekr.20040104185913.1999"><vh>&lt;&lt; testSequence declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2000"><vh>class TestCase</vh>
<v t="ekr.20040104185913.2001"><vh>setUp</vh></v>
<v t="ekr.20040104185913.2002"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.2003"><vh>test1</vh></v>
<v t="ekr.20040104185913.2004"><vh>test2</vh></v>
<v t="ekr.20040104185913.2005"><vh>test3</vh></v>
<v t="ekr.20040104185913.2006"><vh>test4</vh></v>
<v t="ekr.20040104185913.2007"><vh>test5</vh></v>
<v t="ekr.20040104185913.2008"><vh>test6</vh></v>
<v t="ekr.20040104185913.2009"><vh>test7</vh></v>
</v>
<v t="ekr.20040104185913.2010"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2011"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.2012"><vh>@file ztestlib.py</vh>
<v t="ekr.20040104185913.2013"><vh>class standard_html</vh>
<v t="ekr.20040104185913.2014"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.2015"><vh>test</vh></v>
<v t="ekr.20040104185913.2016"><vh>exception</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.2017"><vh>tests</vh>
<v t="ekr.20040104185913.2018"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.2019"><vh>@file testDTML.py</vh>
<v t="ekr.20040104185913.2020"><vh>&lt;&lt; testDTML declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2021"><vh>read_file</vh></v>
<v t="ekr.20040104185913.2022"><vh>class D</vh>
<v t="ekr.20040104185913.2023"><vh>&lt;&lt; class D declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2024"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2025"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.2026"><vh>d</vh></v>
<v t="ekr.20040104185913.2027"><vh>class DTMLTests</vh>
<v t="ekr.20040104185913.2028"><vh>&lt;&lt; class DTMLTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2029"><vh>testBatchingEtc</vh></v>
<v t="ekr.20040104185913.2030"><vh>testSequenceSummaries</vh></v>
<v t="ekr.20040104185913.2031"><vh>testDTMLDateFormatting</vh></v>
<v t="ekr.20040104185913.2032"><vh>testSimpleString</vh></v>
<v t="ekr.20040104185913.2033"><vh>testStringDateFormatting</vh></v>
<v t="ekr.20040104185913.2034"><vh>testSequence1</vh></v>
<v t="ekr.20040104185913.2035"><vh>testSequence2</vh></v>
<v t="ekr.20040104185913.2036"><vh>testNull</vh></v>
<v t="ekr.20040104185913.2037"><vh>testUrlUnquote</vh></v>
<v t="ekr.20040104185913.2038"><vh>test_fmt</vh></v>
<v t="ekr.20040104185913.2039"><vh>testPropogatedError</vh></v>
<v t="ekr.20040104185913.2040"><vh>testRenderCallable</vh></v>
<v t="ekr.20040104185913.2041"><vh>testWith</vh></v>
<v t="ekr.20040104185913.2042"><vh>testRaise</vh></v>
<v t="ekr.20040104185913.2043"><vh>testNoItemPush</vh></v>
<v t="ekr.20040104185913.2044"><vh>testBasicHTMLIn</vh></v>
<v t="ekr.20040104185913.2045"><vh>testBasicHTMLIn2</vh></v>
<v t="ekr.20040104185913.2046"><vh>testBasicHTMLIn3</vh></v>
<v t="ekr.20040104185913.2047"><vh>testHTMLInElse</vh></v>
<v t="ekr.20040104185913.2048"><vh>testBasicStringIn</vh></v>
</v>
<v t="ekr.20040104185913.2049"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2050"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.2051"><vh>@file testDTMLUnicode.py</vh>
<v t="ekr.20040104185913.2052"><vh>&lt;&lt; testDTMLUnicode declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2053"><vh>class force_str</vh>
<v t="ekr.20040104185913.2054"><vh>&lt;&lt; class force_str declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2055"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2056"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.2057"><vh>class DTMLUnicodeTests</vh>
<v t="ekr.20040104185913.2058"><vh>&lt;&lt; class DTMLUnicodeTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2059"><vh>testAA</vh></v>
<v t="ekr.20040104185913.2060"><vh>testUU</vh></v>
<v t="ekr.20040104185913.2061"><vh>testAU</vh></v>
<v t="ekr.20040104185913.2062"><vh>testAB</vh></v>
<v t="ekr.20040104185913.2063"><vh>testUB</vh></v>
<v t="ekr.20040104185913.2064"><vh>testUB2</vh></v>
<v t="ekr.20040104185913.2065"><vh>testUnicodeStr</vh></v>
<v t="ekr.20040104185913.2066"><vh>testUqB</vh></v>
<v t="ekr.20040104185913.2067"><vh>testSize</vh></v>
</v>
<v t="ekr.20040104185913.2068"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2069"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.2070"><vh>@file testustr.py</vh>
<v t="ekr.20040104185913.2071"><vh>&lt;&lt; testustr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2072"><vh>class force_str</vh>
<v t="ekr.20040104185913.2073"><vh>&lt;&lt; class force_str declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2074"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2075"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.2076"><vh>class UnicodeTests</vh>
<v t="ekr.20040104185913.2077"><vh>testPlain</vh></v>
<v t="ekr.20040104185913.2078"><vh>testUnicode</vh></v>
<v t="ekr.20040104185913.2079"><vh>testExceptions</vh></v>
</v>
<v t="ekr.20040104185913.2080"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2081"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.2082"><vh>HelpSys</vh>
<v t="ekr.20040104185913.2083"><vh>@file APIHelpTopic.py</vh>
<v t="ekr.20040104185913.2084"><vh>&lt;&lt; APIHelpTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2085"><vh>class APIHelpTopic</vh>
<v t="ekr.20040104185913.2086"><vh>&lt;&lt; class APIHelpTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2087"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2088"><vh>SearchableText</vh></v>
</v>
<v t="ekr.20040104185913.2089"><vh>class APIDoc</vh>
<v t="ekr.20040104185913.2090"><vh>&lt;&lt; class APIDoc declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2091"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2092"><vh>_createFromInterface</vh></v>
<v t="ekr.20040104185913.2093"><vh>_createFromClass</vh></v>
<v t="ekr.20040104185913.2094"><vh>SearchableText</vh></v>
</v>
<v t="ekr.20040104185913.2095"><vh>class AttributeDoc</vh>
<v t="ekr.20040104185913.2096"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.2097"><vh>class MethodDoc</vh>
<v t="ekr.20040104185913.2098"><vh>&lt;&lt; class MethodDoc declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2099"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2100"><vh>_createFromInterfaceMethod</vh></v>
<v t="ekr.20040104185913.2101"><vh>_createFromFunc</vh></v>
</v>
<v t="ekr.20040104185913.2102"><vh>trim_doc_string</vh></v>
</v>
<v t="ekr.20040104185913.2103"><vh>@file HelpSys.py</vh>
<v t="ekr.20040104185913.2104"><vh>&lt;&lt; HelpSys imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2105"><vh>class HelpSys</vh>
<v t="ekr.20040104185913.2106"><vh>&lt;&lt; class HelpSys declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2107"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2108"><vh>helpValues</vh></v>
<v t="ekr.20040104185913.2109"><vh>__call__</vh></v>
<v t="ekr.20040104185913.2110"><vh>HelpButton</vh></v>
<v t="ekr.20040104185913.2111"><vh>helpLink</vh></v>
<v t="ekr.20040104185913.2112"><vh>tpValues</vh></v>
</v>
<v t="ekr.20040104185913.2113"><vh>class TreeCollection</vh>
<v t="ekr.20040104185913.2114"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2115"><vh>tpValues</vh></v>
<v t="ekr.20040104185913.2116"><vh>tpId</vh></v>
</v>
<v t="ekr.20040104185913.2117"><vh>class ProductHelp</vh>
<v t="ekr.20040104185913.2118"><vh>&lt;&lt; class ProductHelp declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2119"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2120"><vh>addTopic</vh></v>
<v t="ekr.20040104185913.2121"><vh>helpValues</vh></v>
<v t="ekr.20040104185913.2122"><vh>tpValues</vh></v>
<v t="ekr.20040104185913.2123"><vh>all_meta_types</vh></v>
<v t="ekr.20040104185913.2124"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2125"><vh>@file HelpTopic.py</vh>
<v t="ekr.20040104185913.2126"><vh>&lt;&lt; HelpTopic imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2127"><vh>class HelpTopicBase</vh>
<v t="ekr.20040104185913.2128"><vh>&lt;&lt; class HelpTopicBase declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2129"><vh>_permissions_values</vh></v>
<v t="ekr.20040104185913.2130"><vh>helpValues</vh></v>
<v t="ekr.20040104185913.2131"><vh>authorized</vh></v>
<v t="ekr.20040104185913.2132"><vh>SearchableText</vh></v>
<v t="ekr.20040104185913.2133"><vh>url</vh></v>
<v t="ekr.20040104185913.2134"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.2135"><vh>manage_afterClone</vh></v>
<v t="ekr.20040104185913.2136"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.2137"><vh>_setPropValue</vh></v>
<v t="ekr.20040104185913.2138"><vh>index_object</vh></v>
<v t="ekr.20040104185913.2139"><vh>unindex_object</vh></v>
<v t="ekr.20040104185913.2140"><vh>reindex_object</vh></v>
<v t="ekr.20040104185913.2141"><vh>get_catalog</vh></v>
</v>
<v t="ekr.20040104185913.2142"><vh>class HelpTopic</vh>
<v t="ekr.20040104185913.2143"><vh>&lt;&lt; class HelpTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2144"><vh>_set_last_read</vh></v>
<v t="ekr.20040104185913.2145"><vh>_check_for_update</vh></v>
<v t="ekr.20040104185913.2146"><vh>index_html</vh></v>
</v>
<v t="ekr.20040104185913.2147"><vh>class DTMLDocumentTopic</vh>
<v t="ekr.20040104185913.2148"><vh>&lt;&lt; class DTMLDocumentTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2149"><vh>munge</vh></v>
<v t="ekr.20040104185913.2150"><vh>SearchableText</vh></v>
</v>
<v t="ekr.20040104185913.2151"><vh>class DTMLTopic</vh>
<v t="ekr.20040104185913.2152"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2153"><vh>SearchableText</vh></v>
</v>
<v t="ekr.20040104185913.2154"><vh>class TextTopic</vh>
<v t="ekr.20040104185913.2155"><vh>&lt;&lt; class TextTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2156"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2157"><vh>__call__</vh></v>
<v t="ekr.20040104185913.2158"><vh>SearchableText</vh></v>
</v>
<v t="ekr.20040104185913.2159"><vh>class STXTopic</vh>
<v t="ekr.20040104185913.2160"><vh>&lt;&lt; class STXTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2161"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.2162"><vh>class ImageTopic</vh>
<v t="ekr.20040104185913.2163"><vh>&lt;&lt; class ImageTopic declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2164"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2165"><vh>index_html</vh></v>
<v t="ekr.20040104185913.2166"><vh>SearchableText</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2167"><vh>@file HelpUtil.py</vh>
<v t="ekr.20040104185913.2169"><vh>class HelpBase</vh>
<v t="ekr.20040104185913.2170"><vh>__bobo_traverse__</vh></v>
<v t="ekr.20040104185913.2171"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.2172"><vh>class object</vh>
<v t="ekr.20040104185913.2173"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2174"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.2175"><vh>__len__</vh></v>
<v t="ekr.20040104185913.2176"><vh>get_id</vh></v>
<v t="ekr.20040104185913.2177"><vh>get_name</vh></v>
<v t="ekr.20040104185913.2178"><vh>get_type</vh></v>
<v t="ekr.20040104185913.2179"><vh>get_value</vh></v>
<v t="ekr.20040104185913.2180"><vh>get_docstring</vh></v>
<v t="ekr.20040104185913.2181"><vh>get_docstring_html</vh></v>
<v t="ekr.20040104185913.2182"><vh>version</vh></v>
</v>
<v t="ekr.20040104185913.2183"><vh>class moduleobject</vh>
<v t="ekr.20040104185913.2184"><vh>get_file</vh></v>
<v t="ekr.20040104185913.2185"><vh>get_modules</vh></v>
<v t="ekr.20040104185913.2186"><vh>get_classes</vh></v>
</v>
<v t="ekr.20040104185913.2187"><vh>class classobject</vh>
<v t="ekr.20040104185913.2188"><vh>get_metatype</vh></v>
<v t="ekr.20040104185913.2189"><vh>get_module</vh></v>
<v t="ekr.20040104185913.2190"><vh>get_file</vh></v>
<v t="ekr.20040104185913.2191"><vh>get_bases</vh></v>
<v t="ekr.20040104185913.2192"><vh>get_base_list</vh></v>
<v t="ekr.20040104185913.2193"><vh>get_methods</vh></v>
<v t="ekr.20040104185913.2194"><vh>get_method_dict</vh></v>
<v t="ekr.20040104185913.2195"><vh>get_method_list</vh></v>
</v>
<v t="ekr.20040104185913.2196"><vh>class methodobject</vh>
<v t="ekr.20040104185913.2197"><vh>get_class</vh></v>
<v t="ekr.20040104185913.2198"><vh>get_module</vh></v>
<v t="ekr.20040104185913.2199"><vh>get_file</vh></v>
<v t="ekr.20040104185913.2200"><vh>get_docstring</vh></v>
<v t="ekr.20040104185913.2201"><vh>get_signaturex</vh></v>
<v t="ekr.20040104185913.2202"><vh>get_signature</vh></v>
</v>
<v t="ekr.20040104185913.2203"><vh>is_module</vh></v>
<v t="ekr.20040104185913.2204"><vh>is_class</vh></v>
<v t="ekr.20040104185913.2205"><vh>is_method</vh></v>
<v t="ekr.20040104185913.2206"><vh>is_attribute</vh></v>
<v t="ekr.20040104185913.2207"><vh>_chModule</vh></v>
<v t="ekr.20040104185913.2208"><vh>_chClass</vh></v>
<v t="ekr.20040104185913.2209"><vh>_chMethod</vh></v>
<v t="ekr.20040104185913.2210"><vh>_chAttribute</vh></v>
</v>
<v t="ekr.20040104185913.2211"><vh>@file ObjectRef.py</vh>
<v t="ekr.20040104185913.2213"><vh>class ObjectItem</vh>
<v t="ekr.20040104185913.2215"><vh>hs_id</vh></v>
<v t="ekr.20040104185913.2216"><vh>hs_url</vh></v>
<v t="ekr.20040104185913.2217"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.2218"><vh>get_method_list</vh></v>
<v t="ekr.20040104185913.2219"><vh>hs_objectvalues</vh></v>
</v>
<v t="ekr.20040104185913.2220"><vh>class ObjectRef</vh>
<v t="ekr.20040104185913.2222"><vh>hs_deferred__init__</vh></v>
<v t="ekr.20040104185913.2223"><vh>hs_search_mod</vh></v>
<v t="ekr.20040104185913.2224"><vh>hs_objectvalues</vh></v>
<v t="ekr.20040104185913.2225"><vh>__getitem__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2226"><vh>@file __init__.py</vh></v>
</v>
<v t="ekr.20040104185913.2227" a="M"><vh>Interface</vh>
<v t="ekr.20040104185913.2228"><vh>@file Attribute.py</vh>
<v t="ekr.20040104185913.2230"><vh>class Attribute</vh></v>
</v>
<v t="ekr.20040104185913.2232"><vh>@file Document.py</vh>
<v t="ekr.20040104185913.2234"><vh>asStructuredText</vh></v>
<v t="ekr.20040104185913.2235"><vh>_trim_doc_string</vh></v>
<v t="ekr.20040104185913.2236"><vh>_justify_and_indent</vh></v>
</v>
<v t="ekr.20040104185913.2237"><vh>@file Exceptions.py</vh>
<v t="ekr.20040104185913.2239"><vh>class DoesNotImplement</vh>
<v t="ekr.20040104185913.2240"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2241"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.2242"><vh>class BrokenImplementation</vh>
<v t="ekr.20040104185913.2243"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2244"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.2245"><vh>class BrokenMethodImplementation</vh>
<v t="ekr.20040104185913.2246"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2247"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.2248"><vh>class InvalidInterface</vh></v>
<v t="ekr.20040104185913.2249"><vh>class BadImplements</vh></v>
</v>
<v t="ekr.20040104185913.2250"><vh>@file IAttribute.py</vh>
<v t="ekr.20040104185913.2252"><vh>class IAttribute</vh></v>
</v>
<v t="ekr.20040104185913.2253"><vh>@file IElement.py</vh>
<v t="ekr.20040104185913.2255"><vh>class IElement</vh>
<v t="ekr.20040104185913.2256"><vh>&lt;&lt; class IElement declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2257"><vh>getName</vh></v>
<v t="ekr.20040104185913.2258"><vh>getDoc</vh></v>
<v t="ekr.20040104185913.2259"><vh>getTaggedValue</vh></v>
<v t="ekr.20040104185913.2260"><vh>getTaggedValueTags</vh></v>
<v t="ekr.20040104185913.2261"><vh>setTaggedValue</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2262" a="M"><vh>@file IInterface.py</vh>
<v t="ekr.20040104185913.2263"><vh>&lt;&lt; IInterface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2264"><vh>class IInterface</vh>
<v t="ekr.20040104185913.2265"><vh>getBases</vh></v>
<v t="ekr.20040104185913.2266"><vh>extends</vh></v>
<v t="ekr.20040104185913.2267"><vh>isImplementedBy</vh></v>
<v t="ekr.20040104185913.2268"><vh>isImplementedByInstancesOf</vh></v>
<v t="ekr.20040104185913.2269"><vh>names</vh></v>
<v t="ekr.20040104185913.2270"><vh>namesAndDescriptions</vh></v>
<v t="ekr.20040104185913.2271"><vh>getDescriptionFor</vh></v>
<v t="ekr.20040104185913.2272"><vh>queryDescriptionFor</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2273" a="M"><vh>@file IMethod.py</vh>
<v t="ekr.20040104185913.2274"><vh>&lt;&lt; IMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2275"><vh>class IMethod</vh>
<v t="ekr.20040104185913.2276"><vh>&lt;&lt; class IMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2277"><vh>getSignatureString</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2278" a="M"><vh>@file Implements.py</vh>
<v t="ekr.20040104185913.2279"><vh>&lt;&lt; Implements declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2280"><vh>getImplements</vh></v>
<v t="ekr.20040104185913.2281"><vh>getImplementsOfInstances</vh></v>
<v t="ekr.20040104185913.2282"><vh>visitImplements</vh></v>
<v t="ekr.20040104185913.2283"><vh>assertTypeImplements</vh></v>
<v t="ekr.20040104185913.2284"><vh>objectImplements</vh></v>
<v t="ekr.20040104185913.2285"><vh>instancesOfObjectImplements</vh></v>
<v t="ekr.20040104185913.2286"><vh>_flatten</vh></v>
<v t="ekr.20040104185913.2287"><vh>flattenInterfaces</vh></v>
<v t="ekr.20040104185913.2288"><vh>implements</vh></v>
</v>
<v t="ekr.20040104185913.2289" a="M"><vh>@file Mapping.py</vh>
<v t="ekr.20040104185913.2291"><vh>class Mapping</vh>
<v t="ekr.20040104185913.2293"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.2294"><vh>class QueryMapping</vh>
<v t="ekr.20040104185913.2295"><vh>has_key</vh></v>
<v t="ekr.20040104185913.2296"><vh>get</vh></v>
</v>
<v t="ekr.20040104185913.2297"><vh>class Sized</vh>
<v t="ekr.20040104185913.2299"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.2300"><vh>class MutableMapping</vh>
<v t="ekr.20040104185913.2302"><vh>__setitem__</vh></v>
<v t="ekr.20040104185913.2303"><vh>__delitem__</vh></v>
</v>
<v t="ekr.20040104185913.2304"><vh>class EnumerableMapping</vh>
<v t="ekr.20040104185913.2305"><vh>keys</vh></v>
</v>
<v t="ekr.20040104185913.2306"><vh>class MinimalDictionary</vh>
<v t="ekr.20040104185913.2308"><vh>values</vh></v>
<v t="ekr.20040104185913.2309"><vh>items</vh></v>
</v>
<v t="ekr.20040104185913.2310"><vh>class Sequence</vh></v>
<v t="ekr.20040104185913.2312"><vh>class Sequential</vh></v>
</v>
<v t="ekr.20040104185913.2314" a="M"><vh>@file Method.py</vh>
<v t="ekr.20040104185913.2315"><vh>&lt;&lt; Method declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2316"><vh>class Method</vh>
<v t="ekr.20040104185913.2317"><vh>&lt;&lt; class Method declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2318"><vh>__call__</vh></v>
<v t="ekr.20040104185913.2319"><vh>getSignatureInfo</vh></v>
<v t="ekr.20040104185913.2320"><vh>getSignatureString</vh></v>
</v>
<v t="ekr.20040104185913.2321"><vh>fromFunction</vh></v>
<v t="ekr.20040104185913.2322"><vh>fromMethod</vh></v>
</v>
<v t="ekr.20040104185913.2323" a="M"><vh>@file Verify.py</vh>
<v t="ekr.20040104185913.2324"><vh>&lt;&lt; Verify declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2325"><vh>_verify</vh></v>
<v t="ekr.20040104185913.2326"><vh>verifyClass</vh></v>
<v t="ekr.20040104185913.2327"><vh>verifyObject</vh></v>
<v t="ekr.20040104185913.2328"><vh>_incompat</vh></v>
</v>
<v t="ekr.20040104185913.2329" a="M"><vh>@file _Element.py</vh>
<v t="ekr.20040104185913.2330"><vh>&lt;&lt; _Element declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2331"><vh>class Element</vh>
<v t="ekr.20040104185913.2332"><vh>&lt;&lt; class Element declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2333"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2334"><vh>getName</vh></v>
<v t="ekr.20040104185913.2335"><vh>getDoc</vh></v>
<v t="ekr.20040104185913.2336"><vh>getTaggedValue</vh></v>
<v t="ekr.20040104185913.2337"><vh>getTaggedValueTags</vh></v>
<v t="ekr.20040104185913.2338"><vh>setTaggedValue</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2339"><vh>@file _Interface.py</vh>
<v t="ekr.20040104185913.2340"><vh>&lt;&lt; _Interface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2341"><vh>wire</vh></v>
</v>
<v t="ekr.20040104185913.2342" a="M"><vh>@file _InterfaceClass.py</vh>
<v t="ekr.20040104185913.2343"><vh>&lt;&lt; _InterfaceClass declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2344"><vh>class Interface</vh>
<v t="ekr.20040104185913.2345"><vh>&lt;&lt; class Interface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2346"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2347"><vh>getBases</vh></v>
<v t="ekr.20040104185913.2348"><vh>extends</vh></v>
<v t="ekr.20040104185913.2349"><vh>isEqualOrExtendedBy</vh></v>
<v t="ekr.20040104185913.2350"><vh>isImplementedBy</vh></v>
<v t="ekr.20040104185913.2351"><vh>isImplementedByInstancesOf</vh></v>
<v t="ekr.20040104185913.2352"><vh>names</vh></v>
<v t="ekr.20040104185913.2353"><vh>namesAndDescriptions</vh></v>
<v t="ekr.20040104185913.2354"><vh>getDescriptionFor</vh></v>
<v t="ekr.20040104185913.2355"><vh>queryDescriptionFor</vh></v>
<v t="ekr.20040104185913.2356"><vh>deferred</vh></v>
<v t="ekr.20040104185913.2357"><vh>_getInterface</vh></v>
<v t="ekr.20040104185913.2358"><vh>__d</vh></v>
<v t="ekr.20040104185913.2359"><vh>__repr__</vh></v>
<v t="ekr.20040104185913.2360"><vh>__reduce__</vh></v>
<v t="ekr.20040104185913.2361"><vh>__hash__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2362" a="M"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.2363" a="M"><vh>@file _object.py</vh>
<v t="ekr.20040104185913.2364"><vh>&lt;&lt; _object declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2365"><vh>class _x</vh>
<v t="ekr.20040104185913.2366"><vh>m</vh></v>
</v>
<v t="ekr.20040104185913.2367"><vh>class object</vh>
<v t="ekr.20040104185913.2368"><vh>&lt;&lt; class object declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2369"><vh>isInstance</vh></v>
<v t="ekr.20040104185913.2370"><vh>class _x</vh>
<v t="ekr.20040104185913.2371"><vh>m</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2372" a="M"><vh>@file iclass.py</vh>
<v t="ekr.20040104185913.2373"><vh>&lt;&lt; iclass declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2374"><vh>class Interface</vh>
<v t="ekr.20040104185913.2375"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2376" a="M"><vh>@file pprint.py</vh>
<v t="ekr.20040104185913.2377"><vh>&lt;&lt; pprint declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2378"><vh>trim_doc_string</vh></v>
<v t="ekr.20040104185913.2379"><vh>justify_and_indent</vh></v>
<v t="ekr.20040104185913.2380"><vh>interface_as_stx</vh></v>
</v>
<v t="ekr.20040104185913.2381" a="M"><vh>@file pyskel.py</vh>
<v t="ekr.20040104185913.2382"><vh>&lt;&lt; pyskel imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2383"><vh>rskel</vh></v>
<v t="ekr.20040104185913.2384"><vh>skel</vh></v>
<v t="ekr.20040104185913.2385"><vh>resolve</vh></v>
<v t="ekr.20040104185913.2386"><vh>guessOrder</vh></v>
<v t="ekr.20040104185913.2387"><vh>getAttributesInOrder</vh></v>
</v>
<v t="ekr.20040104185913.2388" a="M"><vh>Common</vh>
<v t="ekr.20040104185913.2389"><vh>@file Mapping.py</vh>
<v t="ekr.20040104185913.2390"><vh>&lt;&lt; Mapping declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2391"><vh>class IReadMapping</vh>
<v t="ekr.20040104185913.2392"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.2393"><vh>get</vh></v>
<v t="ekr.20040104185913.2394"><vh>has_key</vh></v>
</v>
<v t="ekr.20040104185913.2395"><vh>class IEnumerableMapping</vh>
<v t="ekr.20040104185913.2396"><vh>keys</vh></v>
<v t="ekr.20040104185913.2397"><vh>values</vh></v>
<v t="ekr.20040104185913.2398"><vh>items</vh></v>
<v t="ekr.20040104185913.2399"><vh>__len__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2400"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.2401"><vh>tests</vh>
<v t="ekr.20040104185913.2402"><vh>@file BaseTestMapping.py</vh>
<v t="ekr.20040104185913.2403"><vh>&lt;&lt; BaseTestMapping declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2404"><vh>testIReadMapping</vh></v>
<v t="ekr.20040104185913.2405"><vh>test_keys</vh></v>
<v t="ekr.20040104185913.2406"><vh>test_values</vh></v>
<v t="ekr.20040104185913.2407"><vh>test_items</vh></v>
<v t="ekr.20040104185913.2408"><vh>test___len__</vh></v>
<v t="ekr.20040104185913.2409"><vh>testIEnumerableMapping</vh></v>
<v t="ekr.20040104185913.2410"><vh>class BaseTestIReadMapping</vh>
<v t="ekr.20040104185913.2411"><vh>testIReadMapping</vh></v>
</v>
<v t="ekr.20040104185913.2412"><vh>class BaseTestIEnumerableMapping</vh>
<v t="ekr.20040104185913.2413"><vh>test_keys</vh></v>
<v t="ekr.20040104185913.2414"><vh>test_values</vh></v>
<v t="ekr.20040104185913.2415"><vh>test_items</vh></v>
<v t="ekr.20040104185913.2416"><vh>test___len__</vh></v>
<v t="ekr.20040104185913.2417"><vh>_IReadMapping__stateDict</vh></v>
<v t="ekr.20040104185913.2418"><vh>_IReadMapping__sample</vh></v>
<v t="ekr.20040104185913.2419"><vh>_IReadMapping__absentKeys</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2420"><vh>@file __init__.py</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2421" a="M"><vh>tests</vh>
<v t="ekr.20040104185913.2422"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.2423"><vh>@file IFoo.py</vh>
<v t="ekr.20040104185913.2424"><vh>&lt;&lt; IFoo declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2425"><vh>class IFoo</vh>
<v t="ekr.20040104185913.2426"><vh>bar</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2427"><vh>@file dummy.py</vh>
<v t="ekr.20040104185913.2428"><vh>&lt;&lt; dummy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2429"><vh>bar</vh></v>
</v>
<v t="ekr.20040104185913.2430"><vh>@file testDocument.py</vh>
<v t="ekr.20040104185913.2431"><vh>&lt;&lt; testDocument declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2432"><vh>class Test</vh>
<v t="ekr.20040104185913.2433"><vh>testBlech</vh></v>
</v>
<v t="ekr.20040104185913.2434"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2435"><vh>class _I1</vh>
<v t="ekr.20040104185913.2436"><vh>f11</vh></v>
<v t="ekr.20040104185913.2437"><vh>f12</vh></v>
</v>
<v t="ekr.20040104185913.2438"><vh>class I2</vh>
<v t="ekr.20040104185913.2439"><vh>&lt;&lt; class I2 declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2440"><vh>f21</vh></v>
<v t="ekr.20040104185913.2441"><vh>f22</vh></v>
<v t="ekr.20040104185913.2442"><vh>f23</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2443"><vh>@file testElement.py</vh>
<v t="ekr.20040104185913.2444"><vh>&lt;&lt; testElement declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2445"><vh>class ElementTests</vh>
<v t="ekr.20040104185913.2446"><vh>test_taggedValues</vh></v>
</v>
<v t="ekr.20040104185913.2447"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2448"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2449"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.2450"><vh>@file testImplements.py</vh>
<v t="ekr.20040104185913.2451"><vh>&lt;&lt; testImplements declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2452"><vh>class Test</vh>
<v t="ekr.20040104185913.2453"><vh>testSimple</vh></v>
<v t="ekr.20040104185913.2454"><vh>testAdd</vh></v>
</v>
<v t="ekr.20040104185913.2455"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.2456"><vh>@file testInterface.py</vh>
<v t="ekr.20040104185913.2457"><vh>&lt;&lt; testInterface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2458"><vh>class InterfaceTests</vh>
<v t="ekr.20040104185913.2459"><vh>setUp</vh></v>
<v t="ekr.20040104185913.2460"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.2461"><vh>testClassImplements</vh></v>
<v t="ekr.20040104185913.2462"><vh>testUtil</vh></v>
<v t="ekr.20040104185913.2463"><vh>testObjectImplements</vh></v>
<v t="ekr.20040104185913.2464"><vh>testDeferredClass</vh></v>
<v t="ekr.20040104185913.2465"><vh>testInterfaceExtendsInterface</vh></v>
<v t="ekr.20040104185913.2466"><vh>testVerifyImplementation</vh></v>
<v t="ekr.20040104185913.2467"><vh>test_names</vh></v>
<v t="ekr.20040104185913.2468"><vh>test_namesAndDescriptions</vh></v>
<v t="ekr.20040104185913.2469"><vh>test_getDescriptionFor</vh></v>
<v t="ekr.20040104185913.2470"><vh>testAttr</vh></v>
</v>
<v t="ekr.20040104185913.2471"><vh>class _I1</vh>
<v t="ekr.20040104185913.2472"><vh>&lt;&lt; class _I1 declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2473"><vh>f11</vh></v>
<v t="ekr.20040104185913.2474"><vh>f12</vh></v>
</v>
<v t="ekr.20040104185913.2475"><vh>class __I1</vh></v>
<v t="ekr.20040104185913.2476"><vh>class ___I1</vh></v>
<v t="ekr.20040104185913.2477"><vh>class _I2</vh>
<v t="ekr.20040104185913.2478"><vh>f21</vh></v>
<v t="ekr.20040104185913.2479"><vh>f22</vh></v>
<v t="ekr.20040104185913.2480"><vh>f23</vh></v>
</v>
<v t="ekr.20040104185913.2481"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.2482"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.2483"><vh>@file testVerify.py</vh>
<v t="ekr.20040104185913.2484"><vh>&lt;&lt; testVerify declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2485"><vh>class Test</vh>
<v t="ekr.20040104185913.2486"><vh>testNotImplemented</vh></v>
<v t="ekr.20040104185913.2487"><vh>testMissingAttr</vh></v>
<v t="ekr.20040104185913.2488"><vh>testMissingAttr_with_Extended_Interface</vh></v>
<v t="ekr.20040104185913.2489"><vh>testWrongArgs</vh></v>
<v t="ekr.20040104185913.2490"><vh>testExtraArgs</vh></v>
<v t="ekr.20040104185913.2491"><vh>testNoVar</vh></v>
<v t="ekr.20040104185913.2492"><vh>testNoKW</vh></v>
<v t="ekr.20040104185913.2493"><vh>testModule</vh></v>
</v>
<v t="ekr.20040104185913.2494"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.2495"><vh>@file testVisitImplements.py</vh>
<v t="ekr.20040104185913.2496"><vh>&lt;&lt; testVisitImplements declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2497"><vh>class I1</vh></v>
<v t="ekr.20040104185913.2498"><vh>class I2</vh></v>
<v t="ekr.20040104185913.2499"><vh>class I3</vh></v>
<v t="ekr.20040104185913.2500"><vh>class Test</vh>
<v t="ekr.20040104185913.2501"><vh>testSimpleImplements</vh></v>
<v t="ekr.20040104185913.2502"><vh>testSimpleBadImplements</vh></v>
<v t="ekr.20040104185913.2503"><vh>testComplexImplements</vh></v>
<v t="ekr.20040104185913.2504"><vh>testComplexBadImplements</vh></v>
</v>
<v t="ekr.20040104185913.2505"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.2506"><vh>@file unitfixtures.py</vh>
<v t="ekr.20040104185913.2507"><vh>&lt;&lt; unitfixtures declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2508"><vh>class mytest</vh>
<v t="ekr.20040104185913.2509"><vh>&lt;&lt; class mytest declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2510"><vh>class C</vh>
<v t="ekr.20040104185913.2511"><vh>m1</vh></v>
<v t="ekr.20040104185913.2512"><vh>m2</vh></v>
</v>
<v t="ekr.20040104185913.2513"><vh>class IC</vh>
<v t="ekr.20040104185913.2514"><vh>m1</vh></v>
<v t="ekr.20040104185913.2515"><vh>m2</vh></v>
</v>
<v t="ekr.20040104185913.2516"><vh>class I1</vh>
<v t="ekr.20040104185913.2517"><vh>ma</vh></v>
</v>
<v t="ekr.20040104185913.2518"><vh>class I2</vh></v>
<v t="ekr.20040104185913.2519"><vh>class I3</vh></v>
<v t="ekr.20040104185913.2520"><vh>class I4</vh></v>
<v t="ekr.20040104185913.2521"><vh>class A</vh>
<v t="ekr.20040104185913.2522"><vh>&lt;&lt; class A declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2523"><vh>class B</vh>
<v t="ekr.20040104185913.2524"><vh>&lt;&lt; class B declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2525"><vh>class D</vh></v>
<v t="ekr.20040104185913.2526"><vh>class E</vh>
<v t="ekr.20040104185913.2527"><vh>&lt;&lt; class E declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2528"><vh>class FooInterface</vh>
<v t="ekr.20040104185913.2529"><vh>&lt;&lt; class FooInterface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2530"><vh>aMethod</vh></v>
<v t="ekr.20040104185913.2531"><vh>anotherMethod</vh></v>
<v t="ekr.20040104185913.2532"><vh>wammy</vh></v>
<v t="ekr.20040104185913.2533"><vh>useless</vh></v>
</v>
<v t="ekr.20040104185913.2534"><vh>class Foo</vh>
<v t="ekr.20040104185913.2535"><vh>&lt;&lt; class Foo declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2536"><vh>aMethod</vh></v>
<v t="ekr.20040104185913.2537"><vh>anotherMethod</vh></v>
<v t="ekr.20040104185913.2538"><vh>wammy</vh></v>
<v t="ekr.20040104185913.2539"><vh>useless</vh></v>
</v>
<v t="ekr.20040104185913.2540"><vh>class Blah</vh>
<v t="ekr.20040104185913.2541"><vh>&lt;&lt; class Blah declarations &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040104185913.2542" a="M"><vh>OFS</vh>
<v t="ekr.20040104185913.2543"><vh>@file Application.py</vh>
<v t="ekr.20040104185913.2544"><vh>&lt;&lt; Application imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2545"><vh>class Application</vh>
<v t="ekr.20040104185913.2546"><vh>&lt;&lt; class Application declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2547"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.2548"><vh>title_or_id</vh></v>
<v t="ekr.20040104185913.2549"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2550"><vh>id</vh></v>
<v t="ekr.20040104185913.2551"><vh>__class_init__</vh></v>
<v t="ekr.20040104185913.2552"><vh>PrincipiaRedirect</vh></v>
<v t="ekr.20040104185913.2553"><vh>__bobo_traverse__</vh></v>
<v t="ekr.20040104185913.2554"><vh>PrincipiaTime</vh></v>
<v t="ekr.20040104185913.2555"><vh>ZopeAttributionButton</vh></v>
<v t="ekr.20040104185913.2556"><vh>DELETE</vh></v>
<v t="ekr.20040104185913.2557"><vh>MOVE</vh></v>
<v t="ekr.20040104185913.2558"><vh>absolute_url</vh></v>
<v t="ekr.20040104185913.2559"><vh>getPhysicalPath</vh></v>
<v t="ekr.20040104185913.2560"><vh>getPhysicalRoot</vh></v>
<v t="ekr.20040104185913.2561"><vh>fixupZClassDependencies</vh></v>
<v t="ekr.20040104185913.2562"><vh>checkGlobalRegistry</vh></v>
</v>
<v t="ekr.20040104185913.2563"><vh>class Expired</vh>
<v t="ekr.20040104185913.2564"><vh>&lt;&lt; class Expired declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2565"><vh>__setstate__</vh></v>
<v t="ekr.20040104185913.2566"><vh>__save__</vh></v>
</v>
<v t="ekr.20040104185913.2567"><vh>initialize</vh></v>
<v t="ekr.20040104185913.2568"><vh>get_products</vh></v>
<v t="ekr.20040104185913.2569"><vh>import_products</vh></v>
<v t="ekr.20040104185913.2570"><vh>import_product</vh></v>
<v t="ekr.20040104185913.2571"><vh>install_products</vh></v>
<v t="ekr.20040104185913.2572"><vh>get_folder_permissions</vh></v>
<v t="ekr.20040104185913.2573"><vh>install_product</vh></v>
<v t="ekr.20040104185913.2574"><vh>install_standards</vh></v>
<v t="ekr.20040104185913.2575"><vh>reinstall_product</vh></v>
<v t="ekr.20040104185913.2576"><vh>reimport_product</vh></v>
<v t="ekr.20040104185913.2577"><vh>removeProductMetaTypes</vh></v>
<v t="ekr.20040104185913.2578"><vh>pgetattr</vh></v>
</v>
<v t="ekr.20040104185913.2579"><vh>@file Cache.py</vh>
<v t="ekr.20040104185913.2580"><vh>&lt;&lt; Cache declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2581"><vh>isCacheable</vh></v>
<v t="ekr.20040104185913.2582"><vh>managersExist</vh></v>
<v t="ekr.20040104185913.2583"><vh>filterCacheTab</vh></v>
<v t="ekr.20040104185913.2584"><vh>filterCacheManagers</vh></v>
<v t="ekr.20040104185913.2585"><vh>getVerifiedManagerIds</vh></v>
<v t="ekr.20040104185913.2586"><vh>class Cacheable</vh>
<v t="ekr.20040104185913.2587"><vh>&lt;&lt; class Cacheable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2588"><vh>ZCacheable_getManager</vh></v>
<v t="ekr.20040104185913.2589"><vh>ZCacheable_getCache</vh></v>
<v t="ekr.20040104185913.2590"><vh>ZCacheable_isCachingEnabled</vh></v>
<v t="ekr.20040104185913.2591"><vh>ZCacheable_isAMethod</vh></v>
<v t="ekr.20040104185913.2592"><vh>ZCacheable_getObAndView</vh></v>
<v t="ekr.20040104185913.2593"><vh>ZCacheable_get</vh></v>
<v t="ekr.20040104185913.2594"><vh>ZCacheable_set</vh></v>
<v t="ekr.20040104185913.2595"><vh>ZCacheable_invalidate</vh></v>
<v t="ekr.20040104185913.2596"><vh>ZCacheable_getModTime</vh></v>
<v t="ekr.20040104185913.2597"><vh>ZCacheable_getManagerId</vh></v>
<v t="ekr.20040104185913.2598"><vh>ZCacheable_getManagerURL</vh></v>
<v t="ekr.20040104185913.2599"><vh>ZCacheable_getManagerIds</vh></v>
<v t="ekr.20040104185913.2600"><vh>ZCacheable_setManagerId</vh></v>
<v t="ekr.20040104185913.2601"><vh>ZCacheable_enabled</vh></v>
<v t="ekr.20040104185913.2602"><vh>ZCacheable_setEnabled</vh></v>
<v t="ekr.20040104185913.2603"><vh>ZCacheable_configHTML</vh></v>
</v>
<v t="ekr.20040104185913.2604"><vh>findCacheables</vh></v>
<v t="ekr.20040104185913.2605"><vh>class Cache</vh>
<v t="ekr.20040104185913.2606"><vh>ZCache_invalidate</vh></v>
<v t="ekr.20040104185913.2607"><vh>ZCache_get</vh></v>
<v t="ekr.20040104185913.2608"><vh>ZCache_set</vh></v>
</v>
<v t="ekr.20040104185913.2609"><vh>class CacheManager</vh>
<v t="ekr.20040104185913.2610"><vh>&lt;&lt; class CacheManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2611"><vh>ZCacheManager_getCache</vh></v>
<v t="ekr.20040104185913.2612"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.2613"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.2614"><vh>ZCacheManager_locate</vh></v>
<v t="ekr.20040104185913.2615"><vh>ZCacheManager_setAssociations</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2616"><vh>@file CopySupport.py</vh>
<v t="ekr.20040104185913.2617"><vh>&lt;&lt; CopySupport imports &gt;&gt;</vh></v>
<v t="ekr.20040104203230"><vh>&lt;&lt; message &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2618"><vh>class CopyContainer</vh>
<v t="ekr.20040104185913.2619"><vh>&lt;&lt; class CopyContainer declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2620"><vh>_setOb</vh></v>
<v t="ekr.20040104185913.2621"><vh>_delOb</vh></v>
<v t="ekr.20040104185913.2622"><vh>_getOb</vh></v>
<v t="ekr.20040104185913.2623"><vh>manage_CopyContainerFirstItem</vh></v>
<v t="ekr.20040104185913.2624"><vh>manage_CopyContainerAllItems</vh></v>
<v t="ekr.20040104185913.2625"><vh>manage_cutObjects</vh></v>
<v t="ekr.20040104185913.2626"><vh>manage_copyObjects</vh></v>
<v t="ekr.20040104185913.2627"><vh>_get_id</vh></v>
<v t="ekr.20040104185913.2628"><vh>manage_pasteObjects</vh></v>
<v t="ekr.20040104185913.2629"><vh>manage_renameObjects</vh></v>
<v t="ekr.20040104185913.2630"><vh>manage_renameObject</vh></v>
<v t="ekr.20040104185913.2631"><vh>manage_clone</vh></v>
<v t="ekr.20040104185913.2632"><vh>cb_dataValid</vh></v>
<v t="ekr.20040104185913.2633"><vh>cb_dataItems</vh></v>
<v t="ekr.20040104185913.2634"><vh>_verifyObjectPaste</vh></v>
</v>
<v t="ekr.20040104185913.2635"><vh>class CopySource</vh>
<v t="ekr.20040104185913.2636"><vh>&lt;&lt; class CopySource declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2637"><vh>_canCopy</vh></v>
<v t="ekr.20040104185913.2638"><vh>_notifyOfCopyTo</vh></v>
<v t="ekr.20040104185913.2639"><vh>_getCopy</vh></v>
<v t="ekr.20040104185913.2640"><vh>_postCopy</vh></v>
<v t="ekr.20040104185913.2641"><vh>_setId</vh></v>
<v t="ekr.20040104185913.2642"><vh>cb_isCopyable</vh></v>
<v t="ekr.20040104185913.2643"><vh>cb_isMoveable</vh></v>
<v t="ekr.20040104185913.2644"><vh>cb_userHasCopyOrMovePermission</vh></v>
</v>
<v t="ekr.20040104185913.2645"><vh>sanity_check</vh></v>
<v t="ekr.20040104185913.2646"><vh>absattr</vh></v>
<v t="ekr.20040104185913.2647"><vh>_cb_encode</vh></v>
<v t="ekr.20040104185913.2648"><vh>_cb_decode</vh></v>
<v t="ekr.20040104185913.2649"><vh>cookie_path</vh></v>
</v>
<v t="ekr.20040104185913.2650"><vh>@file DTMLDocument.py</vh>
<v t="ekr.20040104185913.2651"><vh>&lt;&lt; DTMLDocument imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2652"><vh>class DTMLDocument</vh>
<v t="ekr.20040104185913.2653"><vh>&lt;&lt; class DTMLDocument declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2654"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.2655"><vh>manage_upload</vh></v>
<v t="ekr.20040104185913.2656"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.2657"><vh>addDTMLDocument</vh></v>
</v>
<v t="ekr.20040104185913.2658"><vh>@file DTMLMethod.py</vh>
<v t="ekr.20040104185913.2659"><vh>&lt;&lt; DTMLMethod imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2660"><vh>class DTMLMethod</vh>
<v t="ekr.20040104185913.2661"><vh>&lt;&lt; class DTMLMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2662"><vh>class func_code</vh>
<v t="ekr.20040104185913.2663"><vh>&lt;&lt; class func_code declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2664"><vh>__call__</vh></v>
<v t="ekr.20040104185913.2665"><vh>validate</vh></v>
<v t="ekr.20040104185913.2666"><vh>ZDocumentTemplate_beforeRender</vh></v>
<v t="ekr.20040104185913.2667"><vh>ZDocumentTemplate_afterRender</vh></v>
<v t="ekr.20040104185913.2668"><vh>getCacheNamespaceKeys</vh></v>
<v t="ekr.20040104185913.2669"><vh>setCacheNamespaceKeys</vh></v>
<v t="ekr.20040104185913.2670"><vh>get_size</vh></v>
<v t="ekr.20040104185913.2671"><vh>_er</vh></v>
<v t="ekr.20040104185913.2672"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.2673"><vh>manage_upload</vh></v>
<v t="ekr.20040104185913.2674"><vh>manage_haveProxy</vh></v>
<v t="ekr.20040104185913.2675"><vh>_validateProxy</vh></v>
<v t="ekr.20040104185913.2676"><vh>manage_proxy</vh></v>
<v t="ekr.20040104185913.2677"><vh>PrincipiaSearchSource</vh></v>
<v t="ekr.20040104185913.2678"><vh>document_src</vh></v>
<v t="ekr.20040104185913.2679"><vh>PUT</vh></v>
<v t="ekr.20040104185913.2680"><vh>manage_FTPget</vh></v>
<v t="ekr.20040104185913.2681"><vh>manage_historyCompare</vh></v>
</v>
<v t="ekr.20040104185913.2682"><vh>decapitate</vh></v>
<v t="ekr.20040104185913.2683"><vh>addDTMLMethod</vh></v>
</v>
<v t="ekr.20040104185913.2684" a="M"><vh>@file DefaultObservable.py</vh>
<v t="ekr.20040104185913.2685"><vh>&lt;&lt; DefaultObservable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2686"><vh>class DefaultObservable</vh>
<v t="ekr.20040104185913.2687"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2688"><vh>_normalize</vh></v>
<v t="ekr.20040104185913.2689"><vh>registerObserver</vh></v>
<v t="ekr.20040104185913.2690"><vh>unregisterObserver</vh></v>
<v t="ekr.20040104185913.2691"><vh>notify</vh></v>
</v>
<v t="ekr.20040104185913.2692"><vh>class DontGoHere</vh></v>
<v t="ekr.20040104185913.2693"><vh>class TestSubject</vh>
<v t="ekr.20040104185913.2694"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2695"><vh>restrictedTraverse</vh></v>
</v>
<v t="ekr.20040104185913.2696"><vh>recordCallback</vh></v>
<v t="ekr.20040104185913.2697"><vh>class TestObserver</vh>
<v t="ekr.20040104185913.2698"><vh>__call__</vh></v>
<v t="ekr.20040104185913.2699"><vh>namedCallback</vh></v>
<v t="ekr.20040104185913.2700"><vh>named2Callback</vh></v>
<v t="ekr.20040104185913.2701"><vh>boundCallback</vh></v>
</v>
<v t="ekr.20040104185913.2702"><vh>freefuncObserver</vh></v>
<v t="ekr.20040104185913.2703"><vh>tryVeto</vh></v>
</v>
<v t="ekr.20040104185913.2704" a="M"><vh>@file Document.py</vh></v>
<v t="ekr.20040104185913.2705" a="M"><vh>@file FTPInterface.py</vh>
<v t="ekr.20040104185913.2706"><vh>&lt;&lt; FTPInterface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2707"><vh>class FTPInterface</vh>
<v t="ekr.20040104185913.2708"><vh>&lt;&lt; class FTPInterface declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2709"><vh>manage_FTPstat</vh></v>
<v t="ekr.20040104185913.2710"><vh>manage_FTPlist</vh></v>
<v t="ekr.20040104185913.2711"><vh>manage_FTPget</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2712" a="M"><vh>@file FindSupport.py</vh>
<v t="ekr.20040104185913.2713"><vh>&lt;&lt; FindSupport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2714"><vh>class FindSupport</vh>
<v t="ekr.20040104185913.2715"><vh>&lt;&lt; class FindSupport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2716"><vh>ZopeFind</vh></v>
<v t="ekr.20040104185913.2717"><vh>ZopeFindAndApply</vh></v>
</v>
<v t="ekr.20040104185913.2718"><vh>class td</vh>
<v t="ekr.20040104185913.2719"><vh>&lt;&lt; class td declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2720"><vh>expr_match</vh></v>
<v t="ekr.20040104185913.2721"><vh>mtime_match</vh></v>
<v t="ekr.20040104185913.2722"><vh>role_match</vh></v>
<v t="ekr.20040104185913.2723"><vh>absattr</vh></v>
<v t="ekr.20040104185913.2724"><vh>p_name</vh></v>
</v>
<v t="ekr.20040104185913.2725" a="M"><vh>@file Folder.py</vh>
<v t="ekr.20040104185913.2726"><vh>&lt;&lt; Folder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2727"><vh>manage_addFolder</vh></v>
<v t="ekr.20040104185913.2728"><vh>class Folder</vh>
<v t="ekr.20040104185913.2729"><vh>&lt;&lt; class Folder declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2730" a="M"><vh>@file History.py</vh>
<v t="ekr.20040104185913.2731"><vh>&lt;&lt; History declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2732"><vh>class TemporalParadox</vh></v>
<v t="ekr.20040104185913.2733"><vh>class HistorySelectionError</vh></v>
<v t="ekr.20040104185913.2734"><vh>class HystoryJar</vh>
<v t="ekr.20040104185913.2735"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2736"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.2737"><vh>commit</vh></v>
<v t="ekr.20040104185913.2738"><vh>abort</vh></v>
</v>
<v t="ekr.20040104185913.2739"><vh>historicalRevision</vh></v>
<v t="ekr.20040104185913.2740"><vh>class Historian</vh>
<v t="ekr.20040104185913.2741"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.2742"><vh>manage_workspace</vh></v>
</v>
<v t="ekr.20040104185913.2743"><vh>class Historical</vh>
<v t="ekr.20040104185913.2744"><vh>&lt;&lt; class Historical declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2745"><vh>manage_change_history</vh></v>
<v t="ekr.20040104185913.2746"><vh>manage_beforeHistoryCopy</vh></v>
<v t="ekr.20040104185913.2747"><vh>manage_historyCopy</vh></v>
<v t="ekr.20040104185913.2748"><vh>manage_afterHistoryCopy</vh></v>
<v t="ekr.20040104185913.2749"><vh>manage_historyCompare</vh></v>
<v t="ekr.20040104185913.2750"><vh>manage_historicalComparison</vh></v>
</v>
<v t="ekr.20040104185913.2751"><vh>dump</vh></v>
<v t="ekr.20040104185913.2752"><vh>replace</vh></v>
<v t="ekr.20040104185913.2753"><vh>html_diff</vh></v>
</v>
<v t="ekr.20040104185913.2754" a="M"><vh>@file Image.py</vh>
<v t="ekr.20040104185913.2755"><vh>&lt;&lt; Image declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2756"><vh>manage_addFile</vh></v>
<v t="ekr.20040104185913.2757"><vh>class File</vh>
<v t="ekr.20040104185913.2758"><vh>&lt;&lt; class File declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2759"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2760"><vh>id</vh></v>
<v t="ekr.20040104185913.2761"><vh>index_html</vh></v>
<v t="ekr.20040104185913.2762"><vh>view_image_or_file</vh></v>
<v t="ekr.20040104185913.2763"><vh>update_data</vh></v>
<v t="ekr.20040104185913.2764"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.2765"><vh>manage_upload</vh></v>
<v t="ekr.20040104185913.2766"><vh>_get_content_type</vh></v>
<v t="ekr.20040104185913.2767"><vh>_read_data</vh></v>
<v t="ekr.20040104185913.2768"><vh>PUT</vh></v>
<v t="ekr.20040104185913.2769"><vh>get_size</vh></v>
<v t="ekr.20040104185913.2770"><vh>getContentType</vh></v>
<v t="ekr.20040104185913.2771"><vh>__str__</vh></v>
<v t="ekr.20040104185913.2772"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.2773"><vh>manage_addImage</vh></v>
<v t="ekr.20040104185913.2774"><vh>getImageInfo</vh></v>
<v t="ekr.20040104185913.2775"><vh>class Image</vh>
<v t="ekr.20040104185913.2776"><vh>&lt;&lt; class Image declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2777"><vh>update_data</vh></v>
<v t="ekr.20040104185913.2778"><vh>__str__</vh></v>
<v t="ekr.20040104185913.2779"><vh>tag</vh></v>
</v>
<v t="ekr.20040104185913.2780"><vh>cookId</vh></v>
<v t="ekr.20040104185913.2781"><vh>class Pdata</vh>
<v t="ekr.20040104185913.2782"><vh>&lt;&lt; class Pdata declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2783"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2784"><vh>__getslice__</vh></v>
<v t="ekr.20040104185913.2785"><vh>__len__</vh></v>
<v t="ekr.20040104185913.2786"><vh>__str__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2787" a="M"><vh>@file Moniker.py</vh>
<v t="ekr.20040104185913.2788"><vh>&lt;&lt; Moniker declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2789"><vh>class Moniker</vh>
<v t="ekr.20040104185913.2790"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2791"><vh>bind</vh></v>
<v t="ekr.20040104185913.2792"><vh>dump</vh></v>
</v>
<v t="ekr.20040104185913.2793"><vh>loadMoniker</vh></v>
<v t="ekr.20040104185913.2794"><vh>absattr</vh></v>
</v>
<v t="ekr.20040104185913.2795" a="M"><vh>@file ObjectManager.py</vh>
<v t="ekr.20040104185913.2796"><vh>&lt;&lt; ObjectManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2797"><vh>checkValidId</vh></v>
<v t="ekr.20040104185913.2798"><vh>class BeforeDeleteException</vh></v>
<v t="ekr.20040104185913.2799"><vh>class BreakoutException</vh></v>
<v t="ekr.20040104185913.2800"><vh>class ObjectManager</vh>
<v t="ekr.20040104185913.2801"><vh>&lt;&lt; class ObjectManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2802"><vh>__class_init__</vh></v>
<v t="ekr.20040104185913.2803"><vh>all_meta_types</vh></v>
<v t="ekr.20040104185913.2804"><vh>_subobject_permissions</vh></v>
<v t="ekr.20040104185913.2805"><vh>filtered_meta_types</vh></v>
<v t="ekr.20040104185913.2806"><vh>_setOb</vh></v>
<v t="ekr.20040104185913.2807"><vh>_delOb</vh></v>
<v t="ekr.20040104185913.2808"><vh>_getOb</vh></v>
<v t="ekr.20040104185913.2809"><vh>_setObject</vh></v>
<v t="ekr.20040104185913.2810"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.2811"><vh>manage_afterClone</vh></v>
<v t="ekr.20040104185913.2812"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.2813"><vh>_delObject</vh></v>
<v t="ekr.20040104185913.2814"><vh>objectIds</vh></v>
<v t="ekr.20040104185913.2815"><vh>objectValues</vh></v>
<v t="ekr.20040104185913.2816"><vh>objectItems</vh></v>
<v t="ekr.20040104185913.2817"><vh>objectMap</vh></v>
<v t="ekr.20040104185913.2818"><vh>objectIds_d</vh></v>
<v t="ekr.20040104185913.2819"><vh>objectValues_d</vh></v>
<v t="ekr.20040104185913.2820"><vh>objectItems_d</vh></v>
<v t="ekr.20040104185913.2821"><vh>objectMap_d</vh></v>
<v t="ekr.20040104185913.2822"><vh>superValues</vh></v>
<v t="ekr.20040104185913.2823"><vh>manage_delObjects</vh></v>
<v t="ekr.20040104185913.2824"><vh>tpValues</vh></v>
<v t="ekr.20040104185913.2825"><vh>manage_exportObject</vh></v>
<v t="ekr.20040104185913.2826"><vh>manage_importObject</vh></v>
<v t="ekr.20040104185913.2827"><vh>_importObjectFromFile</vh></v>
<v t="ekr.20040104185913.2828"><vh>manage_FTPlist</vh></v>
<v t="ekr.20040104185913.2829"><vh>manage_FTPstat</vh></v>
<v t="ekr.20040104185913.2830"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.2831"><vh>findChilds</vh></v>
<v t="ekr.20040104185913.2832"><vh>class IFAwareObjectManager</vh>
<v t="ekr.20040104185913.2833"><vh>all_meta_types</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2834" a="M"><vh>@file PropertyManager.py</vh>
<v t="ekr.20040104185913.2835"><vh>&lt;&lt; PropertyManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2836"><vh>class PropertyManager</vh>
<v t="ekr.20040104185913.2837"><vh>&lt;&lt; class PropertyManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2838"><vh>valid_property_id</vh></v>
<v t="ekr.20040104185913.2839"><vh>hasProperty</vh></v>
<v t="ekr.20040104185913.2840"><vh>getProperty</vh></v>
<v t="ekr.20040104185913.2841"><vh>getPropertyType</vh></v>
<v t="ekr.20040104185913.2842"><vh>_wrapperCheck</vh></v>
<v t="ekr.20040104185913.2843"><vh>_setPropValue</vh></v>
<v t="ekr.20040104185913.2844"><vh>_delPropValue</vh></v>
<v t="ekr.20040104185913.2845"><vh>_setProperty</vh></v>
<v t="ekr.20040104185913.2846"><vh>_updateProperty</vh></v>
<v t="ekr.20040104185913.2847"><vh>_delProperty</vh></v>
<v t="ekr.20040104185913.2848"><vh>propertyIds</vh></v>
<v t="ekr.20040104185913.2849"><vh>propertyValues</vh></v>
<v t="ekr.20040104185913.2850"><vh>propertyItems</vh></v>
<v t="ekr.20040104185913.2851"><vh>_propertyMap</vh></v>
<v t="ekr.20040104185913.2852"><vh>propertyMap</vh></v>
<v t="ekr.20040104185913.2853"><vh>propertyLabel</vh></v>
<v t="ekr.20040104185913.2854"><vh>propdict</vh></v>
<v t="ekr.20040104185913.2855"><vh>manage_addProperty</vh></v>
<v t="ekr.20040104185913.2856"><vh>manage_editProperties</vh></v>
<v t="ekr.20040104185913.2857"><vh>manage_changeProperties</vh></v>
<v t="ekr.20040104185913.2858"><vh>manage_changePropertyTypes</vh></v>
<v t="ekr.20040104185913.2859"><vh>manage_delProperties</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2860" a="M"><vh>@file PropertySheets.py</vh>
<v t="ekr.20040104185913.2861"><vh>&lt;&lt; PropertySheets declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2862"><vh>class View</vh>
<v t="ekr.20040104185913.2863"><vh>manage_workspace</vh></v>
<v t="ekr.20040104185913.2864"><vh>tpURL</vh></v>
<v t="ekr.20040104185913.2865"><vh>manage_options</vh></v>
<v t="ekr.20040104185913.2866"><vh>tabs_path_info</vh></v>
<v t="ekr.20040104185913.2867"><vh>meta_type</vh></v>
</v>
<v t="ekr.20040104185913.2868"><vh>class PropertySheet</vh>
<v t="ekr.20040104185913.2869"><vh>&lt;&lt; class PropertySheet declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2870"><vh>property_extensible_schema__</vh></v>
<v t="ekr.20040104185913.2871"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2872"><vh>getId</vh></v>
<v t="ekr.20040104185913.2873"><vh>xml_namespace</vh></v>
<v t="ekr.20040104185913.2874"><vh>v_self</vh></v>
<v t="ekr.20040104185913.2875"><vh>p_self</vh></v>
<v t="ekr.20040104185913.2876"><vh>valid_property_id</vh></v>
<v t="ekr.20040104185913.2877"><vh>hasProperty</vh></v>
<v t="ekr.20040104185913.2878"><vh>getProperty</vh></v>
<v t="ekr.20040104185913.2879"><vh>getPropertyType</vh></v>
<v t="ekr.20040104185913.2880"><vh>_wrapperCheck</vh></v>
<v t="ekr.20040104185913.2881"><vh>_setProperty</vh></v>
<v t="ekr.20040104185913.2882"><vh>_updateProperty</vh></v>
<v t="ekr.20040104185913.2883"><vh>_delProperty</vh></v>
<v t="ekr.20040104185913.2884"><vh>propertyIds</vh></v>
<v t="ekr.20040104185913.2885"><vh>propertyValues</vh></v>
<v t="ekr.20040104185913.2886"><vh>propertyItems</vh></v>
<v t="ekr.20040104185913.2887"><vh>propertyInfo</vh></v>
<v t="ekr.20040104185913.2888"><vh>_propertyMap</vh></v>
<v t="ekr.20040104185913.2889"><vh>propertyMap</vh></v>
<v t="ekr.20040104185913.2890"><vh>_propdict</vh></v>
<v t="ekr.20040104185913.2891"><vh>dav__allprop</vh></v>
<v t="ekr.20040104185913.2892"><vh>dav__propnames</vh></v>
<v t="ekr.20040104185913.2893"><vh>dav__propstat</vh></v>
<v t="ekr.20040104185913.2894"><vh>manage_propertiesForm</vh></v>
<v t="ekr.20040104185913.2895"><vh>manage_addProperty</vh></v>
<v t="ekr.20040104185913.2896"><vh>manage_editProperties</vh></v>
<v t="ekr.20040104185913.2897"><vh>manage_changeProperties</vh></v>
<v t="ekr.20040104185913.2898"><vh>manage_delProperties</vh></v>
</v>
<v t="ekr.20040104185913.2899"><vh>class Virtual</vh>
<v t="ekr.20040104185913.2900"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2901"><vh>v_self</vh></v>
</v>
<v t="ekr.20040104185913.2902"><vh>class DefaultProperties</vh>
<v t="ekr.20040104185913.2903"><vh>&lt;&lt; class DefaultProperties declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.2904"><vh>class DAVProperties</vh>
<v t="ekr.20040104185913.2905"><vh>&lt;&lt; class DAVProperties declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2906"><vh>getProperty</vh></v>
<v t="ekr.20040104185913.2907"><vh>_setProperty</vh></v>
<v t="ekr.20040104185913.2908"><vh>_updateProperty</vh></v>
<v t="ekr.20040104185913.2909"><vh>_delProperty</vh></v>
<v t="ekr.20040104185913.2910"><vh>_propertyMap</vh></v>
<v t="ekr.20040104185913.2911"><vh>propertyMap</vh></v>
<v t="ekr.20040104185913.2912"><vh>dav__creationdate</vh></v>
<v t="ekr.20040104185913.2913"><vh>dav__displayname</vh></v>
<v t="ekr.20040104185913.2914"><vh>dav__resourcetype</vh></v>
<v t="ekr.20040104185913.2915"><vh>dav__getlastmodified</vh></v>
<v t="ekr.20040104185913.2916"><vh>dav__getcontenttype</vh></v>
<v t="ekr.20040104185913.2917"><vh>dav__getcontentlength</vh></v>
<v t="ekr.20040104185913.2918"><vh>dav__source</vh></v>
<v t="ekr.20040104185913.2919"><vh>dav__supportedlock</vh></v>
<v t="ekr.20040104185913.2920"><vh>dav__lockdiscovery</vh></v>
</v>
<v t="ekr.20040104185913.2921"><vh>class PropertySheets</vh>
<v t="ekr.20040104185913.2922"><vh>&lt;&lt; class PropertySheets declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2923"><vh>_get_defaults</vh></v>
<v t="ekr.20040104185913.2924"><vh>__propsets__</vh></v>
<v t="ekr.20040104185913.2925"><vh>__bobo_traverse__</vh></v>
<v t="ekr.20040104185913.2926"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.2927"><vh>values</vh></v>
<v t="ekr.20040104185913.2928"><vh>items</vh></v>
<v t="ekr.20040104185913.2929"><vh>get</vh></v>
<v t="ekr.20040104185913.2930"><vh>manage_addPropertySheet</vh></v>
<v t="ekr.20040104185913.2931"><vh>addPropertySheet</vh></v>
<v t="ekr.20040104185913.2932"><vh>delPropertySheet</vh></v>
<v t="ekr.20040104185913.2933"><vh>__len__</vh></v>
<v t="ekr.20040104185913.2934"><vh>getId</vh></v>
<v t="ekr.20040104185913.2935"><vh>manage_options</vh></v>
<v t="ekr.20040104185913.2936"><vh>tabs_path_info</vh></v>
</v>
<v t="ekr.20040104185913.2937"><vh>class DefaultPropertySheets</vh>
<v t="ekr.20040104185913.2938"><vh>&lt;&lt; class DefaultPropertySheets declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2939"><vh>_get_defaults</vh></v>
</v>
<v t="ekr.20040104185913.2940"><vh>class FixedSchema</vh>
<v t="ekr.20040104185913.2941"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2942"><vh>_propertyMap</vh></v>
<v t="ekr.20040104185913.2943"><vh>propertyMap</vh></v>
<v t="ekr.20040104185913.2944"><vh>property_extensible_schema__</vh></v>
</v>
<v t="ekr.20040104185913.2945"><vh>class vps</vh>
<v t="ekr.20040104185913.2946"><vh>__init__</vh></v>
<v t="ekr.20040104185913.2947"><vh>__of__</vh></v>
</v>
<v t="ekr.20040104185913.2948"><vh>absattr</vh></v>
<v t="ekr.20040104185913.2949"><vh>xml_escape</vh></v>
</v>
<v t="ekr.20040104185913.2950" a="M"><vh>@file SimpleItem.py</vh>
<v t="ekr.20040104185913.2951"><vh>&lt;&lt; SimpleItem declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2952"><vh>class Item</vh>
<v t="ekr.20040104185913.2953"><vh>&lt;&lt; class Item declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2954"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.2955"><vh>manage_beforeDelete</vh></v>
<v t="ekr.20040104185913.2956"><vh>manage_afterClone</vh></v>
<v t="ekr.20040104185913.2957"><vh>getId</vh></v>
<v t="ekr.20040104185913.2958"><vh>title_or_id</vh></v>
<v t="ekr.20040104185913.2959"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.2960"><vh>this</vh></v>
<v t="ekr.20040104185913.2961"><vh>tpURL</vh></v>
<v t="ekr.20040104185913.2962"><vh>tpValues</vh></v>
<v t="ekr.20040104185913.2963"><vh>manage_editedDialog</vh></v>
<v t="ekr.20040104185913.2964"><vh>raise_standardErrorMessage</vh></v>
<v t="ekr.20040104185913.2965"><vh>manage</vh></v>
<v t="ekr.20040104185913.2966"><vh>objectValues</vh></v>
<v t="ekr.20040104185913.2967"><vh>manage_FTPstat</vh></v>
<v t="ekr.20040104185913.2968"><vh>manage_FTPlist</vh></v>
<v t="ekr.20040104185913.2969"><vh>__len__</vh></v>
</v>
<v t="ekr.20040104185913.2970"><vh>class Item_w__name__</vh>
<v t="ekr.20040104185913.2971"><vh>title_or_id</vh></v>
<v t="ekr.20040104185913.2972"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.2973"><vh>_setId</vh></v>
<v t="ekr.20040104185913.2974"><vh>getPhysicalPath</vh></v>
</v>
<v t="ekr.20040104185913.2975"><vh>pretty_tb</vh></v>
<v t="ekr.20040104185913.2976"><vh>class SimpleItem</vh>
<v t="ekr.20040104185913.2977"><vh>&lt;&lt; class SimpleItem declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2978"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2979" a="M"><vh>@file Traversable.py</vh>
<v t="ekr.20040104185913.2980"><vh>&lt;&lt; Traversable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2981"><vh>class Traversable</vh>
<v t="ekr.20040104185913.2982"><vh>&lt;&lt; class Traversable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2983"><vh>absolute_url</vh></v>
<v t="ekr.20040104185913.2984"><vh>getPhysicalPath</vh></v>
<v t="ekr.20040104185913.2985"><vh>unrestrictedTraverse</vh></v>
<v t="ekr.20040104185913.2986"><vh>restrictedTraverse</vh></v>
</v>
</v>
<v t="ekr.20040104185913.2987" a="M"><vh>@file Uninstalled.py</vh>
<v t="ekr.20040104185913.2988"><vh>&lt;&lt; Uninstalled declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2989"><vh>class BrokenClass</vh>
<v t="ekr.20040104185913.2990"><vh>&lt;&lt; class BrokenClass declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2991"><vh>__getstate__</vh></v>
<v t="ekr.20040104185913.2992"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040104185913.2993"><vh>Broken</vh></v>
</v>
<v t="ekr.20040104185913.2994" a="M"><vh>@file XMLExportImport.py</vh>
<v t="ekr.20040104185913.2995"><vh>&lt;&lt; XMLExportImport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.2996"><vh>XMLrecord</vh></v>
<v t="ekr.20040104185913.2997"><vh>exportXML</vh></v>
<v t="ekr.20040104185913.2998"><vh>class zopedata</vh>
<v t="ekr.20040104185913.2999"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3000"><vh>append</vh></v>
</v>
<v t="ekr.20040104185913.3001"><vh>start_zopedata</vh></v>
<v t="ekr.20040104185913.3002"><vh>save_zopedata</vh></v>
<v t="ekr.20040104185913.3003"><vh>save_record</vh></v>
<v t="ekr.20040104185913.3004"><vh>importXML</vh></v>
</v>
<v t="ekr.20040104185913.3005" a="M"><vh>@file ZDOM.py</vh>
<v t="ekr.20040104185913.3006"><vh>&lt;&lt; ZDOM declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3007"><vh>class DOMException</vh>
<v t="ekr.20040104185913.3008"><vh>&lt;&lt; class DOMException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3009"><vh>class IndexSizeException</vh>
<v t="ekr.20040104185913.3010"><vh>&lt;&lt; class IndexSizeException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3011"><vh>class DOMStringSizeException</vh>
<v t="ekr.20040104185913.3012"><vh>&lt;&lt; class DOMStringSizeException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3013"><vh>class HierarchyRequestException</vh>
<v t="ekr.20040104185913.3014"><vh>&lt;&lt; class HierarchyRequestException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3015"><vh>class WrongDocumentException</vh>
<v t="ekr.20040104185913.3016"><vh>&lt;&lt; class WrongDocumentException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3017"><vh>class InvalidCharacterException</vh>
<v t="ekr.20040104185913.3018"><vh>&lt;&lt; class InvalidCharacterException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3019"><vh>class NoDataAllowedException</vh>
<v t="ekr.20040104185913.3020"><vh>&lt;&lt; class NoDataAllowedException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3021"><vh>class NoModificationAllowedException</vh>
<v t="ekr.20040104185913.3022"><vh>&lt;&lt; class NoModificationAllowedException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3023"><vh>class NotFoundException</vh>
<v t="ekr.20040104185913.3024"><vh>&lt;&lt; class NotFoundException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3025"><vh>class NotSupportedException</vh>
<v t="ekr.20040104185913.3026"><vh>&lt;&lt; class NotSupportedException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3027"><vh>class InUseAttributeException</vh>
<v t="ekr.20040104185913.3028"><vh>&lt;&lt; class InUseAttributeException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3029"><vh>class Node</vh>
<v t="ekr.20040104185913.3030"><vh>&lt;&lt; class Node declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3031"><vh>getNodeName</vh></v>
<v t="ekr.20040104185913.3032"><vh>getNodeValue</vh></v>
<v t="ekr.20040104185913.3033"><vh>getParentNode</vh></v>
<v t="ekr.20040104185913.3034"><vh>getChildNodes</vh></v>
<v t="ekr.20040104185913.3035"><vh>getFirstChild</vh></v>
<v t="ekr.20040104185913.3036"><vh>getLastChild</vh></v>
<v t="ekr.20040104185913.3037"><vh>getPreviousSibling</vh></v>
<v t="ekr.20040104185913.3038"><vh>getNextSibling</vh></v>
<v t="ekr.20040104185913.3039"><vh>getAttributes</vh></v>
<v t="ekr.20040104185913.3040"><vh>getOwnerDocument</vh></v>
<v t="ekr.20040104185913.3041"><vh>hasChildNodes</vh></v>
</v>
<v t="ekr.20040104185913.3042"><vh>class Document</vh>
<v t="ekr.20040104185913.3043"><vh>&lt;&lt; class Document declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3044"><vh>getImplementation</vh></v>
<v t="ekr.20040104185913.3045"><vh>getDoctype</vh></v>
<v t="ekr.20040104185913.3046"><vh>getDocumentElement</vh></v>
<v t="ekr.20040104185913.3047"><vh>getNodeName</vh></v>
<v t="ekr.20040104185913.3048"><vh>getNodeType</vh></v>
<v t="ekr.20040104185913.3049"><vh>getOwnerDocument</vh></v>
<v t="ekr.20040104185913.3050"><vh>getChildNodes</vh></v>
<v t="ekr.20040104185913.3051"><vh>getFirstChild</vh></v>
<v t="ekr.20040104185913.3052"><vh>getLastChild</vh></v>
<v t="ekr.20040104185913.3053"><vh>hasChildNodes</vh></v>
</v>
<v t="ekr.20040104185913.3054"><vh>class DOMImplementation</vh>
<v t="ekr.20040104185913.3055"><vh>&lt;&lt; class DOMImplementation declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3056"><vh>hasFeature</vh></v>
</v>
<v t="ekr.20040104185913.3057"><vh>class Element</vh>
<v t="ekr.20040104185913.3058"><vh>&lt;&lt; class Element declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3059"><vh>getTagName</vh></v>
<v t="ekr.20040104185913.3060"><vh>getNodeName</vh></v>
<v t="ekr.20040104185913.3061"><vh>getNodeType</vh></v>
<v t="ekr.20040104185913.3062"><vh>getParentNode</vh></v>
<v t="ekr.20040104185913.3063"><vh>getChildNodes</vh></v>
<v t="ekr.20040104185913.3064"><vh>getFirstChild</vh></v>
<v t="ekr.20040104185913.3065"><vh>getLastChild</vh></v>
<v t="ekr.20040104185913.3066"><vh>getPreviousSibling</vh></v>
<v t="ekr.20040104185913.3067"><vh>getNextSibling</vh></v>
<v t="ekr.20040104185913.3068"><vh>getAttribute</vh></v>
<v t="ekr.20040104185913.3069"><vh>getAttributeNode</vh></v>
<v t="ekr.20040104185913.3070"><vh>getElementsByTagName</vh></v>
</v>
<v t="ekr.20040104185913.3071"><vh>class ElementWithAttributes</vh>
<v t="ekr.20040104185913.3072"><vh>getAttributes</vh></v>
<v t="ekr.20040104185913.3073"><vh>getAttribute</vh></v>
<v t="ekr.20040104185913.3074"><vh>getAttributeNode</vh></v>
</v>
<v t="ekr.20040104185913.3075"><vh>class ElementWithTitle</vh>
<v t="ekr.20040104185913.3076"><vh>getAttributes</vh></v>
<v t="ekr.20040104185913.3077"><vh>getAttribute</vh></v>
<v t="ekr.20040104185913.3078"><vh>getAttributeNode</vh></v>
</v>
<v t="ekr.20040104185913.3079"><vh>class Root</vh>
<v t="ekr.20040104185913.3080"><vh>getOwnerDocument</vh></v>
</v>
<v t="ekr.20040104185913.3081"><vh>class NodeList</vh>
<v t="ekr.20040104185913.3082"><vh>&lt;&lt; class NodeList declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3083"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3084"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.3085"><vh>item</vh></v>
<v t="ekr.20040104185913.3086"><vh>getLength</vh></v>
</v>
<v t="ekr.20040104185913.3087"><vh>class NamedNodeMap</vh>
<v t="ekr.20040104185913.3088"><vh>&lt;&lt; class NamedNodeMap declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3089"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3090"><vh>item</vh></v>
<v t="ekr.20040104185913.3091"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.3092"><vh>getLength</vh></v>
<v t="ekr.20040104185913.3093"><vh>getNamedItem</vh></v>
</v>
<v t="ekr.20040104185913.3094"><vh>class Attr</vh>
<v t="ekr.20040104185913.3095"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3096"><vh>getNodeName</vh></v>
<v t="ekr.20040104185913.3097"><vh>getName</vh></v>
<v t="ekr.20040104185913.3098"><vh>getNodeValue</vh></v>
<v t="ekr.20040104185913.3099"><vh>getNodeType</vh></v>
<v t="ekr.20040104185913.3100"><vh>getSpecified</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3101" a="M"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.3102" a="M"><vh>@file content_types.py</vh>
<v t="ekr.20040104185913.3103"><vh>&lt;&lt; content_types declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3104"><vh>text_type</vh></v>
<v t="ekr.20040104185913.3105"><vh>guess_content_type</vh></v>
</v>
<v t="ekr.20040104185913.3106" a="M"><vh>@file misc_.py</vh>
<v t="ekr.20040104185913.3107"><vh>&lt;&lt; misc_ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3108"><vh>class misc_</vh>
<v t="ekr.20040104185913.3109"><vh>&lt;&lt; class misc_ declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3110"><vh>class p_</vh>
<v t="ekr.20040104185913.3111"><vh>&lt;&lt; class p_ declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3112"><vh>class Misc_</vh>
<v t="ekr.20040104185913.3113"><vh>&lt;&lt; class Misc_ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3114"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3115"><vh>__str__</vh></v>
<v t="ekr.20040104185913.3116"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.3117"><vh>__setitem__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3118" a="M"><vh>@file ndiff.py</vh>
<v t="ekr.20040104185913.3119"><vh>&lt;&lt; ndiff declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3120"><vh>IS_LINE_JUNK</vh></v>
<v t="ekr.20040104185913.3121"><vh>IS_CHARACTER_JUNK</vh></v>
<v t="ekr.20040104185913.3122"><vh>class SequenceMatcher</vh>
<v t="ekr.20040104185913.3123"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3124"><vh>set_seqs</vh></v>
<v t="ekr.20040104185913.3125"><vh>set_seq1</vh></v>
<v t="ekr.20040104185913.3126"><vh>set_seq2</vh></v>
<v t="ekr.20040104185913.3127"><vh>__chain_b</vh></v>
<v t="ekr.20040104185913.3128"><vh>find_longest_match</vh></v>
<v t="ekr.20040104185913.3129"><vh>get_matching_blocks</vh></v>
<v t="ekr.20040104185913.3130"><vh>__helper</vh></v>
<v t="ekr.20040104185913.3131"><vh>ratio</vh></v>
<v t="ekr.20040104185913.3132"><vh>quick_ratio</vh></v>
<v t="ekr.20040104185913.3133"><vh>real_quick_ratio</vh></v>
<v t="ekr.20040104185913.3134"><vh>get_opcodes</vh></v>
</v>
<v t="ekr.20040104185913.3135"><vh>dump</vh></v>
<v t="ekr.20040104185913.3136"><vh>plain_replace</vh></v>
<v t="ekr.20040104185913.3137"><vh>fancy_replace</vh></v>
<v t="ekr.20040104185913.3138"><vh>fancy_helper</vh></v>
<v t="ekr.20040104185913.3139"><vh>fail</vh></v>
<v t="ekr.20040104185913.3140"><vh>fopen</vh></v>
<v t="ekr.20040104185913.3141"><vh>fcompare</vh></v>
<v t="ekr.20040104185913.3142"><vh>main</vh></v>
<v t="ekr.20040104185913.3143"><vh>restore</vh></v>
</v>
<v t="ekr.20040104185913.3144" a="M"><vh>@file rPickle.py</vh>
<v t="ekr.20040104185913.3145"><vh>&lt;&lt; rPickle declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3146"><vh>class Unpickler</vh>
<v t="ekr.20040104185913.3147"><vh>find_class</vh></v>
<v t="ekr.20040104185913.3148"><vh>load_string</vh></v>
</v>
<v t="ekr.20040104185913.3149"><vh>loads</vh></v>
<v t="ekr.20040104185913.3150"><vh>register</vh></v>
<v t="ekr.20040104185913.3151"><vh>unregister</vh></v>
</v>
<v t="ekr.20040104185913.3152" a="M"><vh>tests</vh>
<v t="ekr.20040104185913.3153"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.3154"><vh>@file testCopySupport.py</vh>
<v t="ekr.20040104185913.3155"><vh>&lt;&lt; testCopySupport declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3156"><vh>class UnitTestSecurityPolicy</vh>
<v t="ekr.20040104185913.3157"><vh>&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3158"><vh>validate</vh></v>
<v t="ekr.20040104185913.3159"><vh>checkPermission</vh></v>
</v>
<v t="ekr.20040104185913.3160"><vh>class UnitTestUser</vh>
<v t="ekr.20040104185913.3161"><vh>getId</vh></v>
<v t="ekr.20040104185913.3162"><vh>allowed</vh></v>
</v>
<v t="ekr.20040104185913.3163"><vh>makeConnection</vh></v>
<v t="ekr.20040104185913.3164"><vh>class TestCopySupport</vh>
<v t="ekr.20040104185913.3165"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3166"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3167"><vh>testRename</vh></v>
<v t="ekr.20040104185913.3168"><vh>testCopy</vh></v>
<v t="ekr.20040104185913.3169"><vh>testCut</vh></v>
<v t="ekr.20040104185913.3170"><vh>testCopyNewObject</vh></v>
<v t="ekr.20040104185913.3171"><vh>testPasteSingleNotSameID</vh></v>
<v t="ekr.20040104185913.3172"><vh>testPasteSingleSameID</vh></v>
<v t="ekr.20040104185913.3173"><vh>testPasteMultiNotSameID</vh></v>
<v t="ekr.20040104185913.3174"><vh>testPasteMultiSameID</vh></v>
</v>
<v t="ekr.20040104185913.3175"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.3176"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.3177"><vh>@file testRanges.py</vh>
<v t="ekr.20040104185913.3178"><vh>&lt;&lt; testRanges declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3179"><vh>makeConnection</vh></v>
<v t="ekr.20040104185913.3180"><vh>createBigFile</vh></v>
<v t="ekr.20040104185913.3181"><vh>class TestRequestRange</vh>
<v t="ekr.20040104185913.3182"><vh>&lt;&lt; class TestRequestRange declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3183"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3184"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3185"><vh>uploadBigFile</vh></v>
<v t="ekr.20040104185913.3186"><vh>doGET</vh></v>
<v t="ekr.20040104185913.3187"><vh>createLastModifiedDate</vh></v>
<v t="ekr.20040104185913.3188"><vh>expectUnsatisfiable</vh></v>
<v t="ekr.20040104185913.3189"><vh>expectOK</vh></v>
<v t="ekr.20040104185913.3190"><vh>expectSingleRange</vh></v>
<v t="ekr.20040104185913.3191"><vh>expectMultipleRanges</vh></v>
<v t="ekr.20040104185913.3192"><vh>testNegativeZero</vh></v>
<v t="ekr.20040104185913.3193"><vh>testStartBeyondLength</vh></v>
<v t="ekr.20040104185913.3194"><vh>testMultipleUnsatisfiable</vh></v>
<v t="ekr.20040104185913.3195"><vh>testGarbage</vh></v>
<v t="ekr.20040104185913.3196"><vh>testIllegalSpec</vh></v>
<v t="ekr.20040104185913.3197"><vh>testSimpleRange</vh></v>
<v t="ekr.20040104185913.3198"><vh>testOpenEndedRange</vh></v>
<v t="ekr.20040104185913.3199"><vh>testSuffixRange</vh></v>
<v t="ekr.20040104185913.3200"><vh>testWithNegativeZero</vh></v>
<v t="ekr.20040104185913.3201"><vh>testEndOverflow</vh></v>
<v t="ekr.20040104185913.3202"><vh>testBigFile</vh></v>
<v t="ekr.20040104185913.3203"><vh>testBigFileEndOverflow</vh></v>
<v t="ekr.20040104185913.3204"><vh>testAdjacentRanges</vh></v>
<v t="ekr.20040104185913.3205"><vh>testMultipleRanges</vh></v>
<v t="ekr.20040104185913.3206"><vh>testMultipleRangesDraft</vh></v>
<v t="ekr.20040104185913.3207"><vh>testMultipleRangesBigFile</vh></v>
<v t="ekr.20040104185913.3208"><vh>testMultipleRangesBigFileOutOfOrder</vh></v>
<v t="ekr.20040104185913.3209"><vh>testMultipleRangesBigFileEndOverflow</vh></v>
<v t="ekr.20040104185913.3210"><vh>testIllegalIfRange</vh></v>
<v t="ekr.20040104185913.3211"><vh>testEqualIfRangeDate</vh></v>
<v t="ekr.20040104185913.3212"><vh>testIsModifiedIfRangeDate</vh></v>
<v t="ekr.20040104185913.3213"><vh>testIsNotModifiedIfRangeDate</vh></v>
<v t="ekr.20040104185913.3214"><vh>testEqualIfRangeEtag</vh></v>
<v t="ekr.20040104185913.3215"><vh>testNotEqualIfRangeEtag</vh></v>
</v>
<v t="ekr.20040104185913.3216"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.3217"><vh>main</vh></v>
</v>
<v t="ekr.20040104185913.3218"><vh>@file testTraverse.py</vh>
<v t="ekr.20040104185913.3219"><vh>&lt;&lt; testTraverse declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3220"><vh>class UnitTestSecurityPolicy</vh>
<v t="ekr.20040104185913.3221"><vh>&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3222"><vh>validate</vh></v>
<v t="ekr.20040104185913.3223"><vh>checkPermission</vh></v>
</v>
<v t="ekr.20040104185913.3224"><vh>class CruelSecurityPolicy</vh>
<v t="ekr.20040104185913.3225"><vh>&lt;&lt; class CruelSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3226"><vh>validate</vh></v>
<v t="ekr.20040104185913.3227"><vh>checkPermission</vh></v>
</v>
<v t="ekr.20040104185913.3228"><vh>class UnitTestUser</vh>
<v t="ekr.20040104185913.3229"><vh>getId</vh></v>
<v t="ekr.20040104185913.3230"><vh>allowed</vh></v>
</v>
<v t="ekr.20040104185913.3231"><vh>class BoboTraversable</vh>
<v t="ekr.20040104185913.3232"><vh>&lt;&lt; class BoboTraversable declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3233"><vh>__bobo_traverse__</vh></v>
</v>
<v t="ekr.20040104185913.3234"><vh>makeConnection</vh></v>
<v t="ekr.20040104185913.3235"><vh>class TestTraverse</vh>
<v t="ekr.20040104185913.3236"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3237"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3238"><vh>testTraversePath</vh></v>
<v t="ekr.20040104185913.3239"><vh>testTraverseURLNoSlash</vh></v>
<v t="ekr.20040104185913.3240"><vh>testTraverseURLSlash</vh></v>
<v t="ekr.20040104185913.3241"><vh>testTraverseToNone</vh></v>
<v t="ekr.20040104185913.3242"><vh>testTraverseThroughBoboTraverse</vh></v>
<v t="ekr.20040104185913.3243"><vh>testAcquiredAttributeDenial</vh></v>
</v>
<v t="ekr.20040104185913.3244"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.3245"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3246"><vh>Persistence</vh>
<v t="ekr.20040104185913.3277"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.3278"><vh>@file cPersistence.c</vh>
<v t="ekr.20040104185913.3280"><vh>&lt;&lt; cPersistence declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3281"><vh>call_debug</vh></v>
<v t="ekr.20040104185913.3282"><vh>init_strings</vh></v>
<v t="ekr.20040104185913.3283"><vh>checknoargs</vh></v>
<v t="ekr.20040104185913.3284"><vh>callmethod</vh></v>
<v t="ekr.20040104185913.3285"><vh>callmethod1</vh></v>
<v t="ekr.20040104185913.3286"><vh>unghostify</vh></v>
<v t="ekr.20040104185913.3287"><vh>accessed</vh></v>
<v t="ekr.20040104185913.3288"><vh>ghostify</vh></v>
<v t="ekr.20040104185913.3289"><vh>deallocated</vh></v>
<v t="ekr.20040104185913.3290"><vh>changed</vh></v>
<v t="ekr.20040104185913.3291"><vh>Per___changed__</vh></v>
<v t="ekr.20040104185913.3292"><vh>Per__p_deactivate</vh></v>
<v t="ekr.20040104185913.3293"><vh>Per_setstate</vh></v>
<v t="ekr.20040104185913.3294"><vh>Per__getstate__</vh></v>
<v t="ekr.20040104185913.3295"><vh>Per__setstate__</vh></v>
<v t="ekr.20040104185913.3296"><vh>Per_dealloc</vh></v>
<v t="ekr.20040104185913.3297"><vh>orNothing</vh></v>
<v t="ekr.20040104185913.3298"><vh>Per_getattr</vh></v>
<v t="ekr.20040104185913.3299"><vh>Per_getattro</vh></v>
<v t="ekr.20040104185913.3300"><vh>_setattro</vh></v>
<v t="ekr.20040104185913.3301"><vh>Per_setattro</vh></v>
<v t="ekr.20040104185913.3302"><vh>set_debug_log</vh></v>
<v t="ekr.20040104185913.3303"><vh>initcPersistence</vh></v>
</v>
<v t="ekr.20040104185913.3304"><vh>@file cPickleCache.c</vh>
<v t="ekr.20040104185913.3305"><vh>&lt;&lt; cPickleCache #includes &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3306"><vh>&lt;&lt; cPickleCache declarations &gt;&gt;</vh></v>
<v t="ekr.20040104204617"><vh>&lt;&lt; documentation &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3307"><vh>object_from_ring</vh></v>
<v t="ekr.20040104185913.3308"><vh>scan_gc_items</vh></v>
<v t="ekr.20040104185913.3309"><vh>lockgc</vh></v>
<v t="ekr.20040104185913.3310"><vh>cc_incrgc</vh></v>
<v t="ekr.20040104185913.3311"><vh>cc_full_sweep</vh></v>
<v t="ekr.20040104185913.3312"><vh>cc_minimize</vh></v>
<v t="ekr.20040104185913.3313"><vh>_invalidate</vh></v>
<v t="ekr.20040104185913.3314"><vh>cc_invalidate</vh></v>
<v t="ekr.20040104185913.3315"><vh>cc_get</vh></v>
<v t="ekr.20040104185913.3316"><vh>cc_klass_items</vh></v>
<v t="ekr.20040104185913.3317"><vh>cc_lru_items</vh></v>
<v t="ekr.20040104185913.3318"><vh>cc_oid_unreferenced</vh></v>
<v t="ekr.20040104185913.3319"><vh>cc_ringlen</vh></v>
<v t="ekr.20040104185913.3320"><vh>cc_dealloc</vh></v>
<v t="ekr.20040104185913.3321"><vh>cc_getattr</vh></v>
<v t="ekr.20040104185913.3322"><vh>cc_setattr</vh></v>
<v t="ekr.20040104185913.3323"><vh>cc_length</vh></v>
<v t="ekr.20040104185913.3324"><vh>cc_subscript</vh></v>
<v t="ekr.20040104185913.3325"><vh>cc_add_item</vh></v>
<v t="ekr.20040104185913.3326"><vh>cc_del_item</vh></v>
<v t="ekr.20040104185913.3327"><vh>cc_ass_sub</vh></v>
<v t="ekr.20040104185913.3328"><vh>_ring_corrupt</vh></v>
<v t="ekr.20040104185913.3329"><vh>ring_corrupt</vh></v>
<v t="ekr.20040104185913.3330"><vh>present_in_ring</vh></v>
<v t="ekr.20040104185913.3331"><vh>newccobject</vh></v>
<v t="ekr.20040104185913.3332"><vh>cCM_new</vh></v>
<v t="ekr.20040104185913.3333"><vh>initcPickleCache</vh></v>
</v>
<v t="ekr.20040104185913.3247"><vh>@file PersistentList.py</vh>
<v t="ekr.20040104185913.3250"><vh>&lt;&lt; class PersistentList declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3264"><vh>__cmp__</vh></v>
<v t="ekr.20040104185913.3252"><vh>__delitem__</vh></v>
<v t="ekr.20040104185913.3254"><vh>__delslice__</vh></v>
<v t="ekr.20040104185913.3255"><vh>__iadd__</vh></v>
<v t="ekr.20040104185913.3256"><vh>__imul__</vh></v>
<v t="ekr.20040104185913.3251"><vh>__setitem__</vh></v>
<v t="ekr.20040104185913.3253"><vh>__setslice__</vh></v>
<v t="ekr.20040104185913.3257"><vh>append</vh></v>
<v t="ekr.20040104185913.3263"><vh>extend</vh></v>
<v t="ekr.20040104185913.3258"><vh>insert</vh></v>
<v t="ekr.20040104185913.3259"><vh>pop</vh></v>
<v t="ekr.20040104185913.3260"><vh>remove</vh></v>
<v t="ekr.20040104185913.3261"><vh>reverse</vh></v>
<v t="ekr.20040104185913.3262"><vh>sort</vh></v>
</v>
<v t="ekr.20040104185913.3265"><vh>@file PersistentMapping.py</vh>
<v t="ekr.20040104185913.3268"><vh>&lt;&lt; class PersistentMapping declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3269"><vh>__delitem__</vh></v>
<v t="ekr.20040104185913.3270"><vh>__setitem__</vh></v>
<v t="ekr.20040104185913.3271"><vh>clear</vh></v>
<v t="ekr.20040104185913.3272"><vh>update</vh></v>
<v t="ekr.20040104185913.3273"><vh>setdefault</vh></v>
<v t="ekr.20040104185913.3274"><vh>popitem</vh></v>
<v t="ekr.20040104185913.3275"><vh>__getstate__</vh></v>
<v t="ekr.20040104185913.3276"><vh>__setstate__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3334" a="M"><vh>Products</vh>
<v t="ekr.20040104185913.3335"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.3336"><vh>ExternalMethod</vh>
<v t="ekr.20040104185913.3337"><vh>@file CHANGES.txt</vh></v>
<v t="ekr.20040104185913.3338"><vh>@file ExternalMethod.py</vh>
<v t="ekr.20040104185913.3339"><vh>&lt;&lt; ExternalMethod imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3340"><vh>manage_addExternalMethod</vh></v>
<v t="ekr.20040104185913.3341"><vh>class ExternalMethod</vh>
<v t="ekr.20040104185913.3342"><vh>&lt;&lt; class ExternalMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3343"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3344"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.3345"><vh>getFunction</vh></v>
<v t="ekr.20040104185913.3346"><vh>reloadIfChanged</vh></v>
<v t="ekr.20040104185913.3347"><vh>getFuncDefaults</vh></v>
<v t="ekr.20040104185913.3348"><vh>getFuncDefaults</vh></v>
<v t="ekr.20040104185913.3349"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3350"><vh>function</vh></v>
<v t="ekr.20040104185913.3351"><vh>module</vh></v>
<v t="ekr.20040104185913.3352"><vh>filepath</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3353"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.3354"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.3356"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.3357"><vh>@file version.txt</vh></v>
<v t="ekr.20040104185913.3358"><vh>help</vh>
<v t="ekr.20040104185913.3359"><vh>@file ExternalMethod.py</vh>
<v t="ekr.20040104185913.3361"><vh>manage_addExternalMethod</vh></v>
<v t="ekr.20040104185913.3362"><vh>class ExternalMethod</vh>
<v t="ekr.20040104185913.3364"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.3365"><vh>__call__</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3366"><vh>tests</vh>
<v t="ekr.20040104185913.3367"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.3368"><vh>@file testExternalMethod.py</vh>
<v t="ekr.20040104185913.3369"><vh>&lt;&lt; testExternalMethod imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3370"><vh>class Test</vh>
<v t="ekr.20040104185913.3371"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3372"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3373"><vh>testStorage</vh></v>
<v t="ekr.20040104185913.3374"><vh>test_mapply</vh></v>
</v>
<v t="ekr.20040104185913.3375"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.3376"><vh>package_home</vh></v>
</v>
<v t="ekr.20040104185913.3377"><vh>Extensions</vh>
<v t="ekr.20040104185913.3378"><vh>@file Test.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3381" a="M"><vh>MIMETools</vh>
<v t="ekr.20040104185913.3382"><vh>@file MIMETag.py</vh>
<v t="ekr.20040104185913.3383"><vh>&lt;&lt; MIMETag declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3384"><vh>class MIMETag</vh>
<v t="ekr.20040104185913.3385"><vh>&lt;&lt; class MIMETag declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3386"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3387"><vh>render</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3388"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.3389"><vh>@file __init__.py</vh></v>
</v>
<v t="ekr.20040104185913.3390" a="M"><vh>MailHost</vh>
<v t="ekr.20040104185913.3391"><vh>@file MailHost.py</vh>
<v t="ekr.20040104185913.3392"><vh>&lt;&lt; MailHost declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3393"><vh>manage_addMailHost</vh></v>
<v t="ekr.20040104185913.3394"><vh>class MailBase</vh>
<v t="ekr.20040104185913.3395"><vh>&lt;&lt; class MailBase declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3396"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3397"><vh>_init</vh></v>
<v t="ekr.20040104185913.3398"><vh>manage_makeChanges</vh></v>
<v t="ekr.20040104185913.3399"><vh>sendTemplate</vh></v>
<v t="ekr.20040104185913.3400"><vh>send</vh></v>
<v t="ekr.20040104185913.3401"><vh>simple_send</vh></v>
<v t="ekr.20040104185913.3402"><vh>_send</vh></v>
</v>
<v t="ekr.20040104185913.3403"><vh>class MailHost</vh>
<v t="ekr.20040104185913.3404"><vh>&lt;&lt; class MailHost declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3405"><vh>_encode</vh></v>
<v t="ekr.20040104185913.3406"><vh>_mungeHeaders</vh></v>
</v>
<v t="ekr.20040104185913.3407"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.3408"><vh>@file SendMailTag.py</vh>
<v t="ekr.20040104185913.3409"><vh>&lt;&lt; SendMailTag declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3410"><vh>class SendMailTag</vh>
<v t="ekr.20040104185913.3411"><vh>&lt;&lt; class SendMailTag declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3412"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3413"><vh>render</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3414"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.3415"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3416"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.3417"><vh>@file version.txt</vh></v>
<v t="ekr.20040104185913.3418"><vh>c:/prog/Zope-2.6.2-src/lib/python\Products\MailHost\help</vh>
<v t="ekr.20040104185913.3419"><vh>@file MailHost.py</vh>
<v t="ekr.20040104185913.3420"><vh>&lt;&lt; MailHost declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3421"><vh>manage_addMailHost</vh></v>
<v t="ekr.20040104185913.3422"><vh>class MailHost</vh>
<v t="ekr.20040104185913.3423"><vh>&lt;&lt; class MailHost declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3424"><vh>send</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3425"><vh>c:/prog/Zope-2.6.2-src/lib/python\Products\MailHost\tests</vh>
<v t="ekr.20040104185913.3426"><vh>@file testMailHost.py</vh>
<v t="ekr.20040104185913.3427"><vh>&lt;&lt; testMailHost declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3428"><vh>class TestMailHost</vh>
<v t="ekr.20040104185913.3429"><vh>testAllHeaders</vh></v>
<v t="ekr.20040104185913.3430"><vh>testMissingHeaders</vh></v>
<v t="ekr.20040104185913.3431"><vh>testNoHeaders</vh></v>
<v t="ekr.20040104185913.3432"><vh>testBCCHeader</vh></v>
<v t="ekr.20040104185913.3433"><vh>testAddressParser</vh></v>
</v>
<v t="ekr.20040104185913.3434"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.3435"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3436" a="M"><vh>OFSP</vh>
<v t="ekr.20040104185913.3437"><vh>@file Draft.py</vh>
<v t="ekr.20040104185913.3438"><vh>&lt;&lt; Draft declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3439"><vh>manage_addPrincipiaDraft</vh></v>
<v t="ekr.20040104185913.3440"><vh>class Draft</vh>
<v t="ekr.20040104185913.3441"><vh>&lt;&lt; class Draft declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3442"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3443"><vh>icon</vh></v>
<v t="ekr.20040104185913.3444"><vh>manage_options</vh></v>
<v t="ekr.20040104185913.3445"><vh>title</vh></v>
<v t="ekr.20040104185913.3446"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.3447"><vh>__bobo_traverse__</vh></v>
<v t="ekr.20040104185913.3448"><vh>nonempty</vh></v>
<v t="ekr.20040104185913.3449"><vh>manage_Save__draft__</vh></v>
<v t="ekr.20040104185913.3450"><vh>manage_Discard__draft__</vh></v>
<v t="ekr.20040104185913.3451"><vh>manage_afterClone</vh></v>
<v t="ekr.20040104185913.3452"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.3453"><vh>manage_beforeDelete</vh></v>
</v>
<v t="ekr.20040104185913.3454"><vh>getdraft</vh></v>
<v t="ekr.20040104185913.3455"><vh>class Cleanup</vh></v>
</v>
<v t="ekr.20040104185913.3456"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.3457"><vh>@file Session.py</vh></v>
<v t="ekr.20040104185913.3458"><vh>@file Version.py</vh>
<v t="ekr.20040104185913.3459"><vh>&lt;&lt; Version declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3460"><vh>class VersionException</vh></v>
<v t="ekr.20040104185913.3461"><vh>manage_addVersion</vh></v>
<v t="ekr.20040104185913.3462"><vh>class Version</vh>
<v t="ekr.20040104185913.3463"><vh>&lt;&lt; class Version declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3464"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3465"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.3466"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.3467"><vh>enter</vh></v>
<v t="ekr.20040104185913.3468"><vh>leave</vh></v>
<v t="ekr.20040104185913.3469"><vh>leave_another</vh></v>
<v t="ekr.20040104185913.3470"><vh>save</vh></v>
<v t="ekr.20040104185913.3471"><vh>discard</vh></v>
<v t="ekr.20040104185913.3472"><vh>nonempty</vh></v>
<v t="ekr.20040104185913.3473"><vh>_canCopy</vh></v>
<v t="ekr.20040104185913.3474"><vh>manage_afterClone</vh></v>
<v t="ekr.20040104185913.3475"><vh>manage_afterAdd</vh></v>
<v t="ekr.20040104185913.3476"><vh>manage_beforeDelete</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3477"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.3478"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3479"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.3480"><vh>@file version.txt</vh></v>
<v t="ekr.20040104185913.3481"><vh>help</vh>
<v t="ekr.20040104185913.3482"><vh>@file AccessControl.py</vh>
<v t="ekr.20040104185913.3483"><vh>&lt;&lt; AccessControl declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3484"><vh>getSecurityManager</vh></v>
<v t="ekr.20040104185913.3485"><vh>class SecurityManager</vh>
<v t="ekr.20040104185913.3486"><vh>validate</vh></v>
<v t="ekr.20040104185913.3487"><vh>validateValue</vh></v>
<v t="ekr.20040104185913.3488"><vh>checkPermission</vh></v>
<v t="ekr.20040104185913.3489"><vh>getUser</vh></v>
<v t="ekr.20040104185913.3490"><vh>calledByExecutable</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3491"><vh>@file AuthenticatedUser.py</vh>
<v t="ekr.20040104185913.3492"><vh>&lt;&lt; AuthenticatedUser declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3493"><vh>class AuthenticatedUser</vh>
<v t="ekr.20040104185913.3494"><vh>getUserName</vh></v>
<v t="ekr.20040104185913.3495"><vh>has_role</vh></v>
<v t="ekr.20040104185913.3496"><vh>has_permission</vh></v>
<v t="ekr.20040104185913.3497"><vh>getRoles</vh></v>
<v t="ekr.20040104185913.3498"><vh>getRolesInContext</vh></v>
<v t="ekr.20040104185913.3499"><vh>getId</vh></v>
<v t="ekr.20040104185913.3500"><vh>getDomains</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3501"><vh>@file DTMLDocument.py</vh>
<v t="ekr.20040104185913.3502"><vh>&lt;&lt; DTMLDocument declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3503"><vh>manage_addDocument</vh></v>
<v t="ekr.20040104185913.3504"><vh>class DTMLDocument</vh>
<v t="ekr.20040104185913.3505"><vh>&lt;&lt; class DTMLDocument declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3506"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3507"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.3508"><vh>document_src</vh></v>
<v t="ekr.20040104185913.3509"><vh>get_size</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3510"><vh>@file DTMLMethod.py</vh>
<v t="ekr.20040104185913.3511"><vh>&lt;&lt; DTMLMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3512"><vh>manage_addDTMLMethod</vh></v>
<v t="ekr.20040104185913.3513"><vh>class DTMLMethod</vh>
<v t="ekr.20040104185913.3514"><vh>&lt;&lt; class DTMLMethod declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3515"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3516"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.3517"><vh>document_src</vh></v>
<v t="ekr.20040104185913.3518"><vh>get_size</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3519"><vh>@file DateTime.py</vh>
<v t="ekr.20040104185913.3520"><vh>&lt;&lt; DateTime declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3521"><vh>class DateTime</vh>
<v t="ekr.20040104185913.3522"><vh>timeTime</vh></v>
<v t="ekr.20040104185913.3523"><vh>toZone</vh></v>
<v t="ekr.20040104185913.3524"><vh>isFuture</vh></v>
<v t="ekr.20040104185913.3525"><vh>isPast</vh></v>
<v t="ekr.20040104185913.3526"><vh>isCurrentYear</vh></v>
<v t="ekr.20040104185913.3527"><vh>isCurrentMonth</vh></v>
<v t="ekr.20040104185913.3528"><vh>isCurrentDay</vh></v>
<v t="ekr.20040104185913.3529"><vh>isCurrentHour</vh></v>
<v t="ekr.20040104185913.3530"><vh>isCurrentMinute</vh></v>
<v t="ekr.20040104185913.3531"><vh>earliestTime</vh></v>
<v t="ekr.20040104185913.3532"><vh>latestTime</vh></v>
<v t="ekr.20040104185913.3533"><vh>greaterThan</vh></v>
<v t="ekr.20040104185913.3534"><vh>greaterThanEqualTo</vh></v>
<v t="ekr.20040104185913.3535"><vh>equalTo</vh></v>
<v t="ekr.20040104185913.3536"><vh>notEqualTo</vh></v>
<v t="ekr.20040104185913.3537"><vh>lessThan</vh></v>
<v t="ekr.20040104185913.3538"><vh>lessThanEqualTo</vh></v>
<v t="ekr.20040104185913.3539"><vh>isLeapYear</vh></v>
<v t="ekr.20040104185913.3540"><vh>dayOfYear</vh></v>
<v t="ekr.20040104185913.3541"><vh>parts</vh></v>
<v t="ekr.20040104185913.3542"><vh>timezone</vh></v>
<v t="ekr.20040104185913.3543"><vh>year</vh></v>
<v t="ekr.20040104185913.3544"><vh>month</vh></v>
<v t="ekr.20040104185913.3545"><vh>Month</vh></v>
<v t="ekr.20040104185913.3546"><vh>aMonth</vh></v>
<v t="ekr.20040104185913.3547"><vh>Mon</vh></v>
<v t="ekr.20040104185913.3548"><vh>pMonth</vh></v>
<v t="ekr.20040104185913.3549"><vh>Mon_</vh></v>
<v t="ekr.20040104185913.3550"><vh>day</vh></v>
<v t="ekr.20040104185913.3551"><vh>Day</vh></v>
<v t="ekr.20040104185913.3552"><vh>DayOfWeek</vh></v>
<v t="ekr.20040104185913.3553"><vh>aDay</vh></v>
<v t="ekr.20040104185913.3554"><vh>pDay</vh></v>
<v t="ekr.20040104185913.3555"><vh>Day_</vh></v>
<v t="ekr.20040104185913.3556"><vh>dow</vh></v>
<v t="ekr.20040104185913.3557"><vh>dow_1</vh></v>
<v t="ekr.20040104185913.3558"><vh>h_12</vh></v>
<v t="ekr.20040104185913.3559"><vh>h_24</vh></v>
<v t="ekr.20040104185913.3560"><vh>ampm</vh></v>
<v t="ekr.20040104185913.3561"><vh>hour</vh></v>
<v t="ekr.20040104185913.3562"><vh>minute</vh></v>
<v t="ekr.20040104185913.3563"><vh>second</vh></v>
<v t="ekr.20040104185913.3564"><vh>millis</vh></v>
<v t="ekr.20040104185913.3565"><vh>strftime</vh></v>
<v t="ekr.20040104185913.3566"><vh>Date</vh></v>
<v t="ekr.20040104185913.3567"><vh>Time</vh></v>
<v t="ekr.20040104185913.3568"><vh>TimeMinutes</vh></v>
<v t="ekr.20040104185913.3569"><vh>AMPM</vh></v>
<v t="ekr.20040104185913.3570"><vh>AMPMMinutes</vh></v>
<v t="ekr.20040104185913.3571"><vh>PreciseTime</vh></v>
<v t="ekr.20040104185913.3572"><vh>PreciseAMPM</vh></v>
<v t="ekr.20040104185913.3573"><vh>yy</vh></v>
<v t="ekr.20040104185913.3574"><vh>mm</vh></v>
<v t="ekr.20040104185913.3575"><vh>dd</vh></v>
<v t="ekr.20040104185913.3576"><vh>rfc822</vh></v>
<v t="ekr.20040104185913.3577"><vh>fCommon</vh></v>
<v t="ekr.20040104185913.3578"><vh>fCommonZ</vh></v>
<v t="ekr.20040104185913.3579"><vh>aCommon</vh></v>
<v t="ekr.20040104185913.3580"><vh>aCommonZ</vh></v>
<v t="ekr.20040104185913.3581"><vh>pCommon</vh></v>
<v t="ekr.20040104185913.3582"><vh>pCommonZ</vh></v>
<v t="ekr.20040104185913.3583"><vh>ISO</vh></v>
<v t="ekr.20040104185913.3584"><vh>HTML4</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3585"><vh>@file File.py</vh>
<v t="ekr.20040104185913.3586"><vh>&lt;&lt; File declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3587"><vh>manage_addFile</vh></v>
<v t="ekr.20040104185913.3588"><vh>class File</vh>
<v t="ekr.20040104185913.3589"><vh>&lt;&lt; class File declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3590"><vh>update_data</vh></v>
<v t="ekr.20040104185913.3591"><vh>getSize</vh></v>
<v t="ekr.20040104185913.3592"><vh>getContentType</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3593"><vh>@file Folder.py</vh>
<v t="ekr.20040104185913.3594"><vh>&lt;&lt; Folder declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3595"><vh>manage_addFolder</vh></v>
<v t="ekr.20040104185913.3596"><vh>class Folder</vh>
<v t="ekr.20040104185913.3597"><vh>&lt;&lt; class Folder declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3598"><vh>@file Image.py</vh>
<v t="ekr.20040104185913.3599"><vh>&lt;&lt; Image declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3600"><vh>manage_addImage</vh></v>
<v t="ekr.20040104185913.3601"><vh>class Image</vh>
<v t="ekr.20040104185913.3602"><vh>&lt;&lt; class Image declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3603"><vh>tag</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3604"><vh>@file ObjectManager.py</vh>
<v t="ekr.20040104185913.3605"><vh>&lt;&lt; ObjectManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3606"><vh>class ObjectManager</vh>
<v t="ekr.20040104185913.3607"><vh>objectIds</vh></v>
<v t="ekr.20040104185913.3608"><vh>objectValues</vh></v>
<v t="ekr.20040104185913.3609"><vh>objectItems</vh></v>
<v t="ekr.20040104185913.3610"><vh>superValues</vh></v>
<v t="ekr.20040104185913.3611"><vh>manage_delObjects</vh></v>
<v t="ekr.20040104185913.3612"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.3613"><vh>setBrowserDefaultId</vh></v>
<v t="ekr.20040104185913.3614"><vh>getBrowserDefaultId</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3615"><vh>@file ObjectManagerItem.py</vh>
<v t="ekr.20040104185913.3616"><vh>&lt;&lt; ObjectManagerItem declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3617"><vh>class ObjectManagerItem</vh>
<v t="ekr.20040104185913.3618"><vh>getId</vh></v>
<v t="ekr.20040104185913.3619"><vh>title_or_id</vh></v>
<v t="ekr.20040104185913.3620"><vh>title_and_id</vh></v>
<v t="ekr.20040104185913.3621"><vh>manage_workspace</vh></v>
<v t="ekr.20040104185913.3622"><vh>this</vh></v>
<v t="ekr.20040104185913.3623"><vh>absolute_url</vh></v>
<v t="ekr.20040104185913.3624"><vh>getPhysicalRoot</vh></v>
<v t="ekr.20040104185913.3625"><vh>getPhysicalPath</vh></v>
<v t="ekr.20040104185913.3626"><vh>unrestrictedTraverse</vh></v>
<v t="ekr.20040104185913.3627"><vh>restrictedTraverse</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3628"><vh>@file PropertyManager.py</vh>
<v t="ekr.20040104185913.3629"><vh>&lt;&lt; PropertyManager declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3630"><vh>class PropertyManager</vh>
<v t="ekr.20040104185913.3631"><vh>getProperty</vh></v>
<v t="ekr.20040104185913.3632"><vh>getPropertyType</vh></v>
<v t="ekr.20040104185913.3633"><vh>hasProperty</vh></v>
<v t="ekr.20040104185913.3634"><vh>propertyIds</vh></v>
<v t="ekr.20040104185913.3635"><vh>propertyValues</vh></v>
<v t="ekr.20040104185913.3636"><vh>propertyItems</vh></v>
<v t="ekr.20040104185913.3637"><vh>propertyMap</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3638"><vh>@file PropertySheet.py</vh>
<v t="ekr.20040104185913.3639"><vh>&lt;&lt; PropertySheet declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3640"><vh>class PropertySheet</vh>
<v t="ekr.20040104185913.3641"><vh>xml_namespace</vh></v>
<v t="ekr.20040104185913.3642"><vh>getProperty</vh></v>
<v t="ekr.20040104185913.3643"><vh>getPropertyType</vh></v>
<v t="ekr.20040104185913.3644"><vh>hasProperty</vh></v>
<v t="ekr.20040104185913.3645"><vh>propertyIds</vh></v>
<v t="ekr.20040104185913.3646"><vh>propertyValues</vh></v>
<v t="ekr.20040104185913.3647"><vh>propertyItems</vh></v>
<v t="ekr.20040104185913.3648"><vh>propertyMap</vh></v>
<v t="ekr.20040104185913.3649"><vh>propertyInfo</vh></v>
<v t="ekr.20040104185913.3650"><vh>manage_addProperty</vh></v>
<v t="ekr.20040104185913.3651"><vh>manage_changeProperties</vh></v>
<v t="ekr.20040104185913.3652"><vh>manage_delProperties</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3653"><vh>@file PropertySheets.py</vh>
<v t="ekr.20040104185913.3654"><vh>&lt;&lt; PropertySheets declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3655"><vh>class PropertySheets</vh>
<v t="ekr.20040104185913.3656"><vh>values</vh></v>
<v t="ekr.20040104185913.3657"><vh>items</vh></v>
<v t="ekr.20040104185913.3658"><vh>get</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3659"><vh>@file Request.py</vh>
<v t="ekr.20040104185913.3660"><vh>&lt;&lt; Request declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3661"><vh>class Request</vh>
<v t="ekr.20040104185913.3662"><vh>set</vh></v>
<v t="ekr.20040104185913.3663"><vh>get_header</vh></v>
<v t="ekr.20040104185913.3664"><vh>has_key</vh></v>
<v t="ekr.20040104185913.3665"><vh>keys</vh></v>
<v t="ekr.20040104185913.3666"><vh>items</vh></v>
<v t="ekr.20040104185913.3667"><vh>values</vh></v>
<v t="ekr.20040104185913.3668"><vh>setServerURL</vh></v>
<v t="ekr.20040104185913.3669"><vh>setVirtualRoot</vh></v>
<v t="ekr.20040104185913.3670"><vh>text</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3671"><vh>@file Response.py</vh>
<v t="ekr.20040104185913.3672"><vh>&lt;&lt; Response declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3673"><vh>class Response</vh>
<v t="ekr.20040104185913.3674"><vh>setStatus</vh></v>
<v t="ekr.20040104185913.3675"><vh>setHeader</vh></v>
<v t="ekr.20040104185913.3676"><vh>addHeader</vh></v>
<v t="ekr.20040104185913.3677"><vh>setBase</vh></v>
<v t="ekr.20040104185913.3678"><vh>appendCookie</vh></v>
<v t="ekr.20040104185913.3679"><vh>expireCookie</vh></v>
<v t="ekr.20040104185913.3680"><vh>setCookie</vh></v>
<v t="ekr.20040104185913.3681"><vh>appendHeader</vh></v>
<v t="ekr.20040104185913.3682"><vh>redirect</vh></v>
<v t="ekr.20040104185913.3683"><vh>write</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3684"><vh>@file UserFolder.py</vh>
<v t="ekr.20040104185913.3685"><vh>class UserFolder</vh>
<v t="ekr.20040104185913.3686"><vh>getUser</vh></v>
<v t="ekr.20040104185913.3687"><vh>getUsers</vh></v>
<v t="ekr.20040104185913.3688"><vh>getUserNames</vh></v>
<v t="ekr.20040104185913.3689"><vh>userFolderAddUser</vh></v>
<v t="ekr.20040104185913.3690"><vh>userFolderEditUser</vh></v>
<v t="ekr.20040104185913.3691"><vh>userFolderDelUsers</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3692"><vh>@file math.py</vh></v>
<v t="ekr.20040104185913.3693"><vh>@file random.py</vh></v>
<v t="ekr.20040104185913.3694"><vh>@file sequence.py</vh>
<v t="ekr.20040104185913.3695"><vh>&lt;&lt; sequence declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3696"><vh>sort</vh></v>
</v>
<v t="ekr.20040104185913.3697"><vh>@file string.py</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3698" a="M"><vh>PageTemplates</vh>
<v t="ekr.20040104185913.3699"><vh>@file CHANGES.txt</vh></v>
<v t="ekr.20040104185913.3700"><vh>@file Expressions.py</vh>
<v t="ekr.20040104185913.3701"><vh>&lt;&lt; Expressions declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3702"><vh>getEngine</vh></v>
<v t="ekr.20040104185913.3703"><vh>installHandlers</vh></v>
<v t="ekr.20040104185913.3704"><vh>acquisition_security_filter</vh></v>
<v t="ekr.20040104185913.3705"><vh>render</vh></v>
<v t="ekr.20040104185913.3706"><vh>class SubPathExpr</vh>
<v t="ekr.20040104185913.3707"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3708"><vh>_eval</vh></v>
</v>
<v t="ekr.20040104185913.3709"><vh>class PathExpr</vh>
<v t="ekr.20040104185913.3710"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3711"><vh>_exists</vh></v>
<v t="ekr.20040104185913.3712"><vh>_eval</vh></v>
<v t="ekr.20040104185913.3713"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3714"><vh>__str__</vh></v>
<v t="ekr.20040104185913.3715"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.3716"><vh>class StringExpr</vh>
<v t="ekr.20040104185913.3717"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3718"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3719"><vh>__str__</vh></v>
<v t="ekr.20040104185913.3720"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.3721"><vh>class NotExpr</vh>
<v t="ekr.20040104185913.3722"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3723"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3724"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.3725"><vh>class DeferWrapper</vh>
<v t="ekr.20040104185913.3726"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3727"><vh>__str__</vh></v>
<v t="ekr.20040104185913.3728"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.3729"><vh>class DeferExpr</vh>
<v t="ekr.20040104185913.3730"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3731"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3732"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.3733"><vh>restrictedTraverse</vh></v>
</v>
<v t="ekr.20040104185913.3734"><vh>@file GlobalTranslationService.py</vh>
<v t="ekr.20040104185913.3735"><vh>&lt;&lt; GlobalTranslationService declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3736"><vh>class DummyTranslationService</vh>
<v t="ekr.20040104185913.3737"><vh>translate</vh></v>
</v>
<v t="ekr.20040104185913.3738"><vh>setGlobalTranslationService</vh></v>
<v t="ekr.20040104185913.3739"><vh>getGlobalTranslationService</vh></v>
</v>
<v t="ekr.20040104185913.3740"><vh>@file HISTORY.txt</vh></v>
<v t="ekr.20040104185913.3741"><vh>@file PageTemplate.py</vh>
<v t="ekr.20040104185913.3742"><vh>&lt;&lt; PageTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3743"><vh>class PageTemplate</vh>
<v t="ekr.20040104185913.3744"><vh>&lt;&lt; class PageTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3745"><vh>StringIO</vh></v>
<v t="ekr.20040104185913.3746"><vh>macros</vh></v>
<v t="ekr.20040104185913.3747"><vh>pt_edit</vh></v>
<v t="ekr.20040104185913.3748"><vh>pt_getContext</vh></v>
<v t="ekr.20040104185913.3749"><vh>pt_render</vh></v>
<v t="ekr.20040104185913.3750"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3751"><vh>pt_errors</vh></v>
<v t="ekr.20040104185913.3752"><vh>pt_warnings</vh></v>
<v t="ekr.20040104185913.3753"><vh>pt_macros</vh></v>
<v t="ekr.20040104185913.3754"><vh>pt_source_file</vh></v>
<v t="ekr.20040104185913.3755"><vh>write</vh></v>
<v t="ekr.20040104185913.3756"><vh>read</vh></v>
<v t="ekr.20040104185913.3757"><vh>_cook</vh></v>
<v t="ekr.20040104185913.3758"><vh>html</vh></v>
</v>
<v t="ekr.20040104185913.3759"><vh>class _ModuleImporter</vh>
<v t="ekr.20040104185913.3760"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.3761"><vh>class PTRuntimeError</vh>
<v t="ekr.20040104185913.3762"><vh>&lt;&lt; class PTRuntimeError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3763"><vh>class PageTemplateTracebackSupplement</vh>
<v t="ekr.20040104185913.3764"><vh>&lt;&lt; class PageTemplateTracebackSupplement declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3765"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3766"><vh>@file PageTemplateFile.py</vh>
<v t="ekr.20040104185913.3767"><vh>&lt;&lt; PageTemplateFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3768"><vh>class PageTemplateFile</vh>
<v t="ekr.20040104185913.3769"><vh>&lt;&lt; class PageTemplateFile declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3770"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3771"><vh>pt_getContext</vh></v>
<v t="ekr.20040104185913.3772"><vh>_exec</vh></v>
<v t="ekr.20040104185913.3773"><vh>pt_macros</vh></v>
<v t="ekr.20040104185913.3774"><vh>pt_source_file</vh></v>
<v t="ekr.20040104185913.3775"><vh>_cook_check</vh></v>
<v t="ekr.20040104185913.3776"><vh>document_src</vh></v>
<v t="ekr.20040104185913.3777"><vh>_get__roles__</vh></v>
<v t="ekr.20040104185913.3778"><vh>getOwner</vh></v>
<v t="ekr.20040104185913.3779"><vh>__getstate__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3780"><vh>@file PathIterator.py</vh>
<v t="ekr.20040104185913.3781"><vh>&lt;&lt; PathIterator declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3782"><vh>class Iterator</vh>
<v t="ekr.20040104185913.3783"><vh>__bobo_traverse__</vh></v>
<v t="ekr.20040104185913.3784"><vh>same_part</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3785"><vh>@file PythonExpr.py</vh>
<v t="ekr.20040104185913.3786"><vh>&lt;&lt; PythonExpr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3787"><vh>class getSecurityManager</vh>
<v t="ekr.20040104185913.3788"><vh>validate</vh></v>
</v>
<v t="ekr.20040104185913.3789"><vh>class PythonExpr</vh>
<v t="ekr.20040104185913.3790"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3791"><vh>_get_used_names</vh></v>
<v t="ekr.20040104185913.3792"><vh>_bind_used_names</vh></v>
<v t="ekr.20040104185913.3793"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3794"><vh>__str__</vh></v>
<v t="ekr.20040104185913.3795"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.3796"><vh>class ExprTypeProxy</vh>
<v t="ekr.20040104185913.3797"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3798"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3799"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.3800"><vh>@file TALES.py</vh>
<v t="ekr.20040104185913.3801"><vh>&lt;&lt; TALES declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3802"><vh>class TALESError</vh></v>
<v t="ekr.20040104185913.3803"><vh>class Undefined</vh></v>
<v t="ekr.20040104185913.3804"><vh>class RegistrationError</vh></v>
<v t="ekr.20040104185913.3805"><vh>class CompilerError</vh></v>
<v t="ekr.20040104185913.3806"><vh>class Default</vh></v>
<v t="ekr.20040104185913.3807"><vh>class SafeMapping</vh>
<v t="ekr.20040104185913.3808"><vh>&lt;&lt; class SafeMapping declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3809"><vh>class Iterator</vh>
<v t="ekr.20040104185913.3810"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3811"><vh>next</vh></v>
</v>
<v t="ekr.20040104185913.3812"><vh>class ErrorInfo</vh>
<v t="ekr.20040104185913.3813"><vh>&lt;&lt; class ErrorInfo declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3814"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.3815"><vh>class Engine</vh>
<v t="ekr.20040104185913.3816"><vh>&lt;&lt; class Engine declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3817"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3818"><vh>registerType</vh></v>
<v t="ekr.20040104185913.3819"><vh>getTypes</vh></v>
<v t="ekr.20040104185913.3820"><vh>compile</vh></v>
<v t="ekr.20040104185913.3821"><vh>getContext</vh></v>
<v t="ekr.20040104185913.3822"><vh>getCompilerError</vh></v>
</v>
<v t="ekr.20040104185913.3823"><vh>class Context</vh>
<v t="ekr.20040104185913.3824"><vh>&lt;&lt; class Context declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3825"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3826"><vh>getCompiler</vh></v>
<v t="ekr.20040104185913.3827"><vh>beginScope</vh></v>
<v t="ekr.20040104185913.3828"><vh>endScope</vh></v>
<v t="ekr.20040104185913.3829"><vh>setLocal</vh></v>
<v t="ekr.20040104185913.3830"><vh>setGlobal</vh></v>
<v t="ekr.20040104185913.3831"><vh>setRepeat</vh></v>
<v t="ekr.20040104185913.3832"><vh>evaluate</vh></v>
<v t="ekr.20040104185913.3833"><vh>evaluateText</vh></v>
<v t="ekr.20040104185913.3834"><vh>evaluateStructure</vh></v>
<v t="ekr.20040104185913.3835"><vh>evaluateMacro</vh></v>
<v t="ekr.20040104185913.3836"><vh>createErrorInfo</vh></v>
<v t="ekr.20040104185913.3837"><vh>getDefault</vh></v>
<v t="ekr.20040104185913.3838"><vh>setSourceFile</vh></v>
<v t="ekr.20040104185913.3839"><vh>setPosition</vh></v>
<v t="ekr.20040104185913.3840"><vh>translate</vh></v>
</v>
<v t="ekr.20040104185913.3841"><vh>class TALESTracebackSupplement</vh>
<v t="ekr.20040104185913.3842"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3843"><vh>getInfo</vh></v>
</v>
<v t="ekr.20040104185913.3844"><vh>class SimpleExpr</vh>
<v t="ekr.20040104185913.3845"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3846"><vh>__call__</vh></v>
<v t="ekr.20040104185913.3847"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3848"><vh>@file ZPythonExpr.py</vh>
<v t="ekr.20040104185913.3849"><vh>&lt;&lt; ZPythonExpr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3850"><vh>class PythonExpr</vh>
<v t="ekr.20040104185913.3851"><vh>__init__</vh></v>
</v>
<v t="ekr.20040104185913.3852"><vh>class _SecureModuleImporter</vh>
<v t="ekr.20040104185913.3853"><vh>&lt;&lt; class _SecureModuleImporter declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3854"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.3855"><vh>validate</vh></v>
<v t="ekr.20040104185913.3856"><vh>call_with_ns</vh></v>
</v>
<v t="ekr.20040104185913.3857"><vh>@file ZRPythonExpr.py</vh>
<v t="ekr.20040104185913.3858"><vh>&lt;&lt; ZRPythonExpr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3859"><vh>class PythonExpr</vh>
<v t="ekr.20040104185913.3860"><vh>&lt;&lt; class PythonExpr declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3861"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3862"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.3863"><vh>class _SecureModuleImporter</vh>
<v t="ekr.20040104185913.3864"><vh>&lt;&lt; class _SecureModuleImporter declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3865"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.3866"><vh>class Rtd</vh>
<v t="ekr.20040104185913.3867"><vh>&lt;&lt; class Rtd declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3868"><vh>call_with_ns</vh></v>
</v>
<v t="ekr.20040104185913.3869"><vh>@file ZopePageTemplate.py</vh>
<v t="ekr.20040104185913.3870"><vh>&lt;&lt; ZopePageTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3871"><vh>class ZopePageTemplate</vh>
<v t="ekr.20040104185913.3872"><vh>&lt;&lt; class ZopePageTemplate declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3873"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3874"><vh>_setPropValue</vh></v>
<v t="ekr.20040104185913.3875"><vh>pt_editAction</vh></v>
<v t="ekr.20040104185913.3876"><vh>pt_setTitle</vh></v>
<v t="ekr.20040104185913.3877"><vh>pt_upload</vh></v>
<v t="ekr.20040104185913.3878"><vh>pt_changePrefs</vh></v>
<v t="ekr.20040104185913.3879"><vh>ZScriptHTML_tryParams</vh></v>
<v t="ekr.20040104185913.3880"><vh>manage_historyCompare</vh></v>
<v t="ekr.20040104185913.3881"><vh>pt_getContext</vh></v>
<v t="ekr.20040104185913.3882"><vh>write</vh></v>
<v t="ekr.20040104185913.3883"><vh>_exec</vh></v>
<v t="ekr.20040104185913.3884"><vh>PUT</vh></v>
<v t="ekr.20040104185913.3885"><vh>manage_FTPget</vh></v>
<v t="ekr.20040104185913.3886"><vh>get_size</vh></v>
<v t="ekr.20040104185913.3887"><vh>PrincipiaSearchSource</vh></v>
<v t="ekr.20040104185913.3888"><vh>document_src</vh></v>
<v t="ekr.20040104185913.3889"><vh>om_icons</vh></v>
<v t="ekr.20040104185913.3890"><vh>__setstate__</vh></v>
<v t="ekr.20040104185913.3891"><vh>pt_source_file</vh></v>
<v t="ekr.20040104185913.3892"><vh>wl_isLocked</vh></v>
</v>
<v t="ekr.20040104185913.3893"><vh>class Src</vh>
<v t="ekr.20040104185913.3894"><vh>&lt;&lt; class Src declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3895"><vh>__before_publishing_traverse__</vh></v>
<v t="ekr.20040104185913.3896"><vh>__call__</vh></v>
</v>
<v t="ekr.20040104185913.3897"><vh>manage_addPageTemplate</vh></v>
<v t="ekr.20040104185913.3898"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.3899"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.3900"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3901"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.3902"><vh>@file version.txt</vh></v>
<v t="ekr.20040104185913.3903"><vh>help</vh>
<v t="ekr.20040104185913.3904"><vh>@file ZTUtils.py</vh>
<v t="ekr.20040104185913.3905"><vh>&lt;&lt; ZTUtils declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3906"><vh>class Batch</vh>
<v t="ekr.20040104185913.3907"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.3908"><vh>tests</vh>
<v t="ekr.20040104185913.3909"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.3910"><vh>all</vh></v>
<v t="ekr.20040104185913.3911"><vh>class harness1</vh>
<v t="ekr.20040104185913.3912"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3913"><vh>_assert_</vh></v>
<v t="ekr.20040104185913.3914"><vh>_complete_</vh></v>
<v t="ekr.20040104185913.3915"><vh>__getattr__</vh></v>
<v t="ekr.20040104185913.3916"><vh>_method_</vh></v>
</v>
<v t="ekr.20040104185913.3917"><vh>class harness2</vh>
<v t="ekr.20040104185913.3918"><vh>_assert_</vh></v>
<v t="ekr.20040104185913.3919"><vh>_method_</vh></v>
</v>
</v>
<v t="ekr.20040104185913.3920"><vh>@file batch.py</vh>
<v t="ekr.20040104185913.3921"><vh>&lt;&lt; batch declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3922"><vh>class batch</vh>
<v t="ekr.20040104185913.3923"><vh>__init__</vh></v>
<v t="ekr.20040104185913.3924"><vh>previous_sequence</vh></v>
<v t="ekr.20040104185913.3925"><vh>previous_sequence_end_number</vh></v>
<v t="ekr.20040104185913.3926"><vh>previous_sequence_start_number</vh></v>
<v t="ekr.20040104185913.3927"><vh>previous_sequence_end_item</vh></v>
<v t="ekr.20040104185913.3928"><vh>previous_sequence_start_item</vh></v>
<v t="ekr.20040104185913.3929"><vh>next_sequence_end_number</vh></v>
<v t="ekr.20040104185913.3930"><vh>next_sequence_start_number</vh></v>
<v t="ekr.20040104185913.3931"><vh>next_sequence_end_item</vh></v>
<v t="ekr.20040104185913.3932"><vh>next_sequence_start_item</vh></v>
<v t="ekr.20040104185913.3933"><vh>next_sequence</vh></v>
<v t="ekr.20040104185913.3934"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20040104185913.3935"><vh>opt</vh></v>
</v>
<v t="ekr.20040104185913.3936"><vh>@file run.py</vh>
<v t="ekr.20040104185913.3937"><vh>&lt;&lt; run declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3938"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.3939"><vh>@file testDTMLTests.py</vh>
<v t="ekr.20040104185913.3940"><vh>&lt;&lt; testDTMLTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3941"><vh>class AqPageTemplate</vh>
<v t="ekr.20040104185913.3942"><vh>&lt;&lt; class AqPageTemplate declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3943"><vh>class UnitTestSecurityPolicy</vh>
<v t="ekr.20040104185913.3944"><vh>&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3945"><vh>validate</vh></v>
<v t="ekr.20040104185913.3946"><vh>checkPermission</vh></v>
</v>
<v t="ekr.20040104185913.3947"><vh>class DTMLTests</vh>
<v t="ekr.20040104185913.3948"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3949"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3950"><vh>check1</vh></v>
<v t="ekr.20040104185913.3951"><vh>check3</vh></v>
</v>
<v t="ekr.20040104185913.3952"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.3953"><vh>@file testExpressions.py</vh>
<v t="ekr.20040104185913.3954"><vh>&lt;&lt; testExpressions declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3955"><vh>class ExpressionTests</vh>
<v t="ekr.20040104185913.3956"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3957"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3958"><vh>testCompile</vh></v>
<v t="ekr.20040104185913.3959"><vh>testSimpleEval</vh></v>
<v t="ekr.20040104185913.3960"><vh>testEval1</vh></v>
<v t="ekr.20040104185913.3961"><vh>testHybrid</vh></v>
</v>
<v t="ekr.20040104185913.3962"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.3963"><vh>@file testHTMLTests.py</vh>
<v t="ekr.20040104185913.3964"><vh>&lt;&lt; testHTMLTests declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3965"><vh>class AqPageTemplate</vh>
<v t="ekr.20040104185913.3966"><vh>&lt;&lt; class AqPageTemplate declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3967"><vh>class Folder</vh>
<v t="ekr.20040104185913.3968"><vh>&lt;&lt; class Folder declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.3969"><vh>class TestTranslationService</vh>
<v t="ekr.20040104185913.3970"><vh>translate</vh></v>
</v>
<v t="ekr.20040104185913.3971"><vh>class UnitTestSecurityPolicy</vh>
<v t="ekr.20040104185913.3972"><vh>&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.3973"><vh>validate</vh></v>
<v t="ekr.20040104185913.3974"><vh>checkPermission</vh></v>
</v>
<v t="ekr.20040104185913.3975"><vh>class HTMLTests</vh>
<v t="ekr.20040104185913.3976"><vh>setUp</vh></v>
<v t="ekr.20040104185913.3977"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.3978"><vh>assert_expected</vh></v>
<v t="ekr.20040104185913.3979"><vh>assert_expected_unicode</vh></v>
<v t="ekr.20040104185913.3980"><vh>getProducts</vh></v>
<v t="ekr.20040104185913.3981"><vh>check1</vh></v>
<v t="ekr.20040104185913.3982"><vh>check2</vh></v>
<v t="ekr.20040104185913.3983"><vh>check3</vh></v>
<v t="ekr.20040104185913.3984"><vh>checkSimpleLoop</vh></v>
<v t="ekr.20040104185913.3985"><vh>checkFancyLoop</vh></v>
<v t="ekr.20040104185913.3986"><vh>checkGlobalsShadowLocals</vh></v>
<v t="ekr.20040104185913.3987"><vh>checkStringExpressions</vh></v>
<v t="ekr.20040104185913.3988"><vh>checkReplaceWithNothing</vh></v>
<v t="ekr.20040104185913.3989"><vh>checkWithXMLHeader</vh></v>
<v t="ekr.20040104185913.3990"><vh>checkNotExpression</vh></v>
<v t="ekr.20040104185913.3991"><vh>checkPathNothing</vh></v>
<v t="ekr.20040104185913.3992"><vh>checkPathAlt</vh></v>
<v t="ekr.20040104185913.3993"><vh>checkBatchIteration</vh></v>
<v t="ekr.20040104185913.3994"><vh>checkUnicodeInserts</vh></v>
<v t="ekr.20040104185913.3995"><vh>checkI18nTranslate</vh></v>
<v t="ekr.20040104185913.3996"><vh>checkI18nTranslateHooked</vh></v>
</v>
<v t="ekr.20040104185913.3997"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.3998"><vh>@file testTALES.py</vh>
<v t="ekr.20040104185913.3999"><vh>&lt;&lt; testTALES declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4000"><vh>class DummyUnicodeExpr</vh>
<v t="ekr.20040104185913.4001"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4002"><vh>__call__</vh></v>
<v t="ekr.20040104185913.4003"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040104185913.4004"><vh>class TALESTests</vh>
<v t="ekr.20040104185913.4005"><vh>testIterator0</vh></v>
<v t="ekr.20040104185913.4006"><vh>testIterator1</vh></v>
<v t="ekr.20040104185913.4007"><vh>testIterator2</vh></v>
<v t="ekr.20040104185913.4008"><vh>testRegisterType</vh></v>
<v t="ekr.20040104185913.4009"><vh>testRegisterTypeUnique</vh></v>
<v t="ekr.20040104185913.4010"><vh>testRegisterTypeNameConstraints</vh></v>
<v t="ekr.20040104185913.4011"><vh>testCompile</vh></v>
<v t="ekr.20040104185913.4012"><vh>testGetContext</vh></v>
<v t="ekr.20040104185913.4013"><vh>getContext</vh></v>
<v t="ekr.20040104185913.4014"><vh>testContext0</vh></v>
<v t="ekr.20040104185913.4015"><vh>testContextUnicode</vh></v>
<v t="ekr.20040104185913.4016"><vh>testVariables</vh></v>
</v>
<v t="ekr.20040104185913.4017"><vh>test_suite</vh></v>
</v>
<v t="ekr.20040104185913.4018"><vh>@file util.py</vh>
<v t="ekr.20040104185913.4020"><vh>class Bruce</vh>
<v t="ekr.20040104185913.4021"><vh>&lt;&lt; class Bruce declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4022"><vh>__str__</vh></v>
<v t="ekr.20040104185913.4023"><vh>__int__</vh></v>
<v t="ekr.20040104185913.4024"><vh>__float__</vh></v>
<v t="ekr.20040104185913.4025"><vh>keys</vh></v>
<v t="ekr.20040104185913.4026"><vh>values</vh></v>
<v t="ekr.20040104185913.4027"><vh>items</vh></v>
<v t="ekr.20040104185913.4028"><vh>__len__</vh></v>
<v t="ekr.20040104185913.4029"><vh>__getitem__</vh></v>
<v t="ekr.20040104185913.4030"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040104185913.4031"><vh>class arg</vh>
<v t="ekr.20040104185913.4032"><vh>&lt;&lt; class arg declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4033"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4034"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.4035"><vh>class argv</vh>
<v t="ekr.20040104185913.4036"><vh>&lt;&lt; class argv declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4037"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4038"><vh>items</vh></v>
<v t="ekr.20040104185913.4039"><vh>values</vh></v>
<v t="ekr.20040104185913.4040"><vh>getPhysicalRoot</vh></v>
</v>
<v t="ekr.20040104185913.4041"><vh>nicerange</vh></v>
<v t="ekr.20040104185913.4042"><vh>check_html</vh></v>
<v t="ekr.20040104185913.4043"><vh>check_xml</vh></v>
<v t="ekr.20040104185913.4044"><vh>normalize_html</vh></v>
<v t="ekr.20040104185913.4045"><vh>normalize_xml</vh></v>
<v t="ekr.20040104185913.4046"><vh>read_input</vh></v>
<v t="ekr.20040104185913.4047"><vh>read_output</vh></v>
</v>
<v t="ekr.20040104185913.4048"><vh>tests\input</vh>
<v t="ekr.20040104185913.4049"><vh>@file CheckBatchIteration.html</vh></v>
<v t="ekr.20040104185913.4050"><vh>@file CheckI18nTranslate.html</vh></v>
<v t="ekr.20040104185913.4051"><vh>@file CheckI18nTranslateHooked.html</vh></v>
<v t="ekr.20040104185913.4052"><vh>@file CheckNotExpression.html</vh></v>
<v t="ekr.20040104185913.4053"><vh>@file CheckNothing.html</vh></v>
<v t="ekr.20040104185913.4054"><vh>@file CheckPathAlt.html</vh></v>
<v t="ekr.20040104185913.4055"><vh>@file CheckPathNothing.html</vh></v>
<v t="ekr.20040104185913.4056"><vh>@file CheckUnicodeInserts.html</vh></v>
<v t="ekr.20040104185913.4057"><vh>@file CheckWithXMLHeader.html</vh></v>
<v t="ekr.20040104185913.4058"><vh>@file DTML1.html</vh></v>
<v t="ekr.20040104185913.4059"><vh>@file DTML3.html</vh></v>
<v t="ekr.20040104185913.4060"><vh>@file GlobalsShadowLocals.html</vh></v>
<v t="ekr.20040104185913.4061"><vh>@file Loop1.html</vh></v>
<v t="ekr.20040104185913.4062"><vh>@file Loop2.html</vh></v>
<v t="ekr.20040104185913.4063"><vh>@file StringExpression.html</vh></v>
<v t="ekr.20040104185913.4064"><vh>@file TeeShop1.html</vh></v>
<v t="ekr.20040104185913.4065"><vh>@file TeeShop2.html</vh></v>
<v t="ekr.20040104185913.4066"><vh>@file TeeShopLAF.html</vh></v>
</v>
<v t="ekr.20040104185913.4067"><vh>tests\output</vh>
<v t="ekr.20040104185913.4068"><vh>@file CheckBatchIteration.html</vh></v>
<v t="ekr.20040104185913.4069"><vh>@file CheckI18nTranslate.html</vh></v>
<v t="ekr.20040104185913.4070"><vh>@file CheckI18nTranslateHooked.html</vh></v>
<v t="ekr.20040104185913.4071"><vh>@file CheckNotExpression.html</vh></v>
<v t="ekr.20040104185913.4072"><vh>@file CheckNothing.html</vh></v>
<v t="ekr.20040104185913.4073"><vh>@file CheckPathAlt.html</vh></v>
<v t="ekr.20040104185913.4074"><vh>@file CheckPathNothing.html</vh></v>
<v t="ekr.20040104185913.4075"><vh>@file CheckUnicodeInserts.html</vh></v>
<v t="ekr.20040104185913.4076"><vh>@file CheckWithXMLHeader.html</vh></v>
<v t="ekr.20040104185913.4077"><vh>@file DTML1a.html</vh></v>
<v t="ekr.20040104185913.4078"><vh>@file DTML1b.html</vh></v>
<v t="ekr.20040104185913.4079"><vh>@file DTML3.html</vh></v>
<v t="ekr.20040104185913.4080"><vh>@file GlobalsShadowLocals.html</vh></v>
<v t="ekr.20040104185913.4081"><vh>@file Loop1.html</vh></v>
<v t="ekr.20040104185913.4082"><vh>@file Loop2.html</vh></v>
<v t="ekr.20040104185913.4083"><vh>@file StringExpression.html</vh></v>
<v t="ekr.20040104185913.4084"><vh>@file TeeShop1.html</vh></v>
<v t="ekr.20040104185913.4085"><vh>@file TeeShop2.html</vh></v>
<v t="ekr.20040104185913.4086"><vh>@file TeeShopLAF.html</vh></v>
</v>
</v>
<v t="ekr.20040104185913.4087"><vh>www</vh>
<v t="ekr.20040104185913.4088"><vh>@file default.html</vh></v>
</v>
</v>
<v t="ekr.20040104185913.4089" a="M"><vh>PluginIndexes</vh>
<v t="ekr.20040104185913.4090"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.4091"><vh>@file __init__.py</vh>
<v t="ekr.20040104185913.4092"><vh>&lt;&lt; __init__ imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4093"><vh>initialize</vh></v>
</v>
<v t="ekr.20040104185913.4094"><vh>DateIndex</vh>
<v t="ekr.20040104185913.4105"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4095"><vh>@file DateIndex.py</vh>
<v t="ekr.20040104185913.4096"><vh>&lt;&lt; DateIndex imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4097"><vh>class DateIndex</vh>
<v t="ekr.20040104185913.4098"><vh>&lt;&lt; class DateIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4099"><vh>clear</vh></v>
<v t="ekr.20040104185913.4100"><vh>index_object</vh></v>
<v t="ekr.20040104185913.4101"><vh>_apply_index</vh></v>
<v t="ekr.20040104185913.4102"><vh>_convert</vh></v>
</v>
<v t="ekr.20040104185913.4103"><vh>manage_addDateIndex</vh></v>
</v>
<v t="ekr.20040104185913.4104"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.4106"><vh>tests</vh>
<v t="ekr.20040104185913.4107"><vh>@file test_DateIndex.py</vh>
<v t="ekr.20040104185913.4109"><vh>class Dummy</vh>
<v t="ekr.20040104185913.4110"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4111"><vh>name</vh></v>
<v t="ekr.20040104185913.4112"><vh>date</vh></v>
<v t="ekr.20040104185913.4113"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.4114"><vh>class DI_Tests</vh>
<v t="ekr.20040104185913.4115"><vh>setUp</vh></v>
<v t="ekr.20040104185913.4116"><vh>_populateIndex</vh></v>
<v t="ekr.20040104185913.4117"><vh>_checkApply</vh></v>
<v t="ekr.20040104185913.4118"><vh>_convert</vh></v>
<v t="ekr.20040104185913.4119"><vh>test_empty</vh></v>
<v t="ekr.20040104185913.4120"><vh>test_retrieval</vh></v>
</v>
<v t="ekr.20040104185913.4121"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.4122"><vh>run</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.4123" a="M"><vh>DateRangeIndex</vh>
<v t="ekr.20040104185913.4145"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4124"><vh>@file DateRangeIndex.py</vh>
<v t="ekr.20040104185913.4125"><vh>&lt;&lt; DateRangeIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4126"><vh>class DateRangeIndex</vh>
<v t="ekr.20040104185913.4127"><vh>&lt;&lt; class DateRangeIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4128"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4129"><vh>getSinceField</vh></v>
<v t="ekr.20040104185913.4130"><vh>getUntilField</vh></v>
<v t="ekr.20040104185913.4131"><vh>manage_edit</vh></v>
<v t="ekr.20040104185913.4132"><vh>_edit</vh></v>
<v t="ekr.20040104185913.4133"><vh>clear</vh></v>
<v t="ekr.20040104185913.4134"><vh>getEntryForObject</vh></v>
<v t="ekr.20040104185913.4135"><vh>index_object</vh></v>
<v t="ekr.20040104185913.4136"><vh>unindex_object</vh></v>
<v t="ekr.20040104185913.4137"><vh>uniqueValues</vh></v>
<v t="ekr.20040104185913.4138"><vh>_apply_index</vh></v>
<v t="ekr.20040104185913.4139"><vh>numObjects</vh></v>
<v t="ekr.20040104185913.4140"><vh>_insertForwardIndexEntry</vh></v>
<v t="ekr.20040104185913.4141"><vh>_removeForwardIndexEntry</vh></v>
<v t="ekr.20040104185913.4142"><vh>_convertDateTime</vh></v>
</v>
<v t="ekr.20040104185913.4143"><vh>manage_addDateRangeIndex</vh></v>
</v>
<v t="ekr.20040104185913.4144"><vh>@file README.txt</vh></v>
<v t="ekr.20040104185913.4146"><vh>tests</vh>
<v t="ekr.20040104185913.4147"><vh>@file test_DateRangeIndex.py</vh>
<v t="ekr.20040104185913.4148"><vh>&lt;&lt; test_DateRangeIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4149"><vh>class Dummy</vh>
<v t="ekr.20040104185913.4150"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4151"><vh>name</vh></v>
<v t="ekr.20040104185913.4152"><vh>start</vh></v>
<v t="ekr.20040104185913.4153"><vh>stop</vh></v>
<v t="ekr.20040104185913.4154"><vh>datum</vh></v>
</v>
<v t="ekr.20040104185913.4155"><vh>matchingDummies</vh></v>
<v t="ekr.20040104185913.4156"><vh>class DRI_Tests</vh>
<v t="ekr.20040104185913.4157"><vh>setUp</vh></v>
<v t="ekr.20040104185913.4158"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.4159"><vh>test_empty</vh></v>
<v t="ekr.20040104185913.4160"><vh>test_retrieval</vh></v>
</v>
<v t="ekr.20040104185913.4161"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.4162"><vh>run</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.4163" a="M"><vh>FieldIndex</vh>
<v t="ekr.20040104185913.4169"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4164"><vh>@file FieldIndex.py</vh>
<v t="ekr.20040104185913.4165"><vh>&lt;&lt; FieldIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4166"><vh>class FieldIndex</vh>
<v t="ekr.20040104185913.4167"><vh>&lt;&lt; class FieldIndex declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040104185913.4168"><vh>manage_addFieldIndex</vh></v>
</v>
<v t="ekr.20040104185913.4170"><vh>tests</vh>
<v t="ekr.20040104185913.4171"><vh>@file testFieldIndex.py</vh>
<v t="ekr.20040104185913.4172"><vh>&lt;&lt; testFieldIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4173"><vh>class Dummy</vh>
<v t="ekr.20040104185913.4174"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4175"><vh>foo</vh></v>
<v t="ekr.20040104185913.4176"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.4177"><vh>class TestCase</vh>
<v t="ekr.20040104185913.4178"><vh>setUp</vh></v>
<v t="ekr.20040104185913.4179"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.4180"><vh>_populateIndex</vh></v>
<v t="ekr.20040104185913.4181"><vh>_checkApply</vh></v>
<v t="ekr.20040104185913.4182"><vh>testEmpty</vh></v>
<v t="ekr.20040104185913.4183"><vh>testPopulated</vh></v>
<v t="ekr.20040104185913.4184"><vh>testZero</vh></v>
<v t="ekr.20040104185913.4185"><vh>testNone</vh></v>
<v t="ekr.20040104185913.4186"><vh>testReindex</vh></v>
<v t="ekr.20040104185913.4187"><vh>testRange</vh></v>
</v>
<v t="ekr.20040104185913.4188"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.4189"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.4190" a="M"><vh>KeywordIndex</vh>
<v t="ekr.20040104185913.4200"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4191"><vh>@file KeywordIndex.py</vh>
<v t="ekr.20040104185913.4192"><vh>&lt;&lt; KeywordIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4193"><vh>class KeywordIndex</vh>
<v t="ekr.20040104185913.4194"><vh>&lt;&lt; class KeywordIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4195"><vh>index_object</vh></v>
<v t="ekr.20040104185913.4196"><vh>_get_object_keywords</vh></v>
<v t="ekr.20040104185913.4197"><vh>unindex_objectKeywords</vh></v>
<v t="ekr.20040104185913.4198"><vh>unindex_object</vh></v>
</v>
<v t="ekr.20040104185913.4199"><vh>manage_addKeywordIndex</vh></v>
</v>
<v t="ekr.20040104185913.4201"><vh>tests</vh>
<v t="ekr.20040104185913.4202"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4203"><vh>@file testKeywordIndex.py</vh>
<v t="ekr.20040104185913.4204"><vh>&lt;&lt; testKeywordIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4205"><vh>class Dummy</vh>
<v t="ekr.20040104185913.4206"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4207"><vh>foo</vh></v>
<v t="ekr.20040104185913.4208"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.4209"><vh>sortedUnique</vh></v>
<v t="ekr.20040104185913.4210"><vh>class TestKeywordIndex</vh>
<v t="ekr.20040104185913.4211"><vh>&lt;&lt; class TestKeywordIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4212"><vh>setUp</vh></v>
<v t="ekr.20040104185913.4213"><vh>tearDown</vh></v>
<v t="ekr.20040104185913.4214"><vh>_catch_log_errors</vh></v>
<v t="ekr.20040104185913.4215"><vh>_ignore_log_errors</vh></v>
<v t="ekr.20040104185913.4216"><vh>_populateIndex</vh></v>
<v t="ekr.20040104185913.4217"><vh>_checkApply</vh></v>
<v t="ekr.20040104185913.4218"><vh>testAddObjectWOKeywords</vh></v>
<v t="ekr.20040104185913.4219"><vh>testEmpty</vh></v>
<v t="ekr.20040104185913.4220"><vh>testPopulated</vh></v>
<v t="ekr.20040104185913.4221"><vh>testZero</vh></v>
<v t="ekr.20040104185913.4222"><vh>testReindexChange</vh></v>
<v t="ekr.20040104185913.4223"><vh>testReindexNoChange</vh></v>
<v t="ekr.20040104185913.4224"><vh>testIntersectionWithRange</vh></v>
<v t="ekr.20040104185913.4225"><vh>testDuplicateKeywords</vh></v>
</v>
<v t="ekr.20040104185913.4226"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.4227"><vh>main</vh></v>
</v>
</v>
</v>
<v t="ekr.20040104185913.4228"><vh>PathIndex</vh>
<v t="ekr.20040104185913.4252"><vh>@file __init__.py</vh></v>
<v t="ekr.20040104185913.4229"><vh>@file PathIndex.py</vh>
<v t="ekr.20040104185913.4230"><vh>&lt;&lt; PathIndex imports &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4231"><vh>class PathIndex</vh>
<v t="ekr.20040104185913.4232"><vh>&lt;&lt; class PathIndex declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4233"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4234"><vh>getId</vh></v>
<v t="ekr.20040104185913.4235"><vh>clear</vh></v>
<v t="ekr.20040104185913.4236"><vh>insertEntry</vh></v>
<v t="ekr.20040104185913.4237"><vh>index_object</vh></v>
<v t="ekr.20040104185913.4238"><vh>unindex_object</vh></v>
<v t="ekr.20040104185913.4239"><vh>printIndex</vh></v>
<v t="ekr.20040104185913.4240"><vh>splitPath</vh></v>
<v t="ekr.20040104185913.4241"><vh>search</vh></v>
<v t="ekr.20040104185913.4242"><vh>__len__</vh></v>
<v t="ekr.20040104185913.4243"><vh>numObjects</vh></v>
<v t="ekr.20040104185913.4244"><vh>keys</vh></v>
<v t="ekr.20040104185913.4245"><vh>values</vh></v>
<v t="ekr.20040104185913.4246"><vh>items</vh></v>
<v t="ekr.20040104185913.4247"><vh>_apply_index</vh></v>
<v t="ekr.20040104185913.4248"><vh>uniqueValues</vh></v>
<v t="ekr.20040104185913.4249"><vh>getEntryForObject</vh></v>
</v>
<v t="ekr.20040104185913.4250"><vh>manage_addPathIndex</vh></v>
</v>
<v t="ekr.20040104185913.4251"><vh>@file PathIndex.txt</vh></v>
<v t="ekr.20040104185913.4253"><vh>tests</vh>
<v t="ekr.20040104185913.4254"><vh>@file testPathIndex.py</vh>
<v t="ekr.20040104185913.4256"><vh>class Dummy</vh>
<v t="ekr.20040104185913.4257"><vh>&lt;&lt; class Dummy declarations &gt;&gt;</vh></v>
<v t="ekr.20040104185913.4258"><vh>__init__</vh></v>
<v t="ekr.20040104185913.4259"><vh>getPhysicalPath</vh></v>
<v t="ekr.20040104185913.4260"><vh>__str__</vh></v>
</v>
<v t="ekr.20040104185913.4261"><vh>class TestCase</vh>
<v t="ekr.20040104185913.4262"><vh>setUp</vh></v>
<v t="ekr.20040104185913.4263"><vh>_populateIndex</vh></v>
<v t="ekr.20040104185913.4264"><vh>testEmpty</vh></v>
<v t="ekr.20040104185913.4265"><vh>testUnIndex</vh></v>
<v t="ekr.20040104185913.4266"><vh>testUnIndexError</vh></v>
<v t="ekr.20040104185913.4267"><vh>testRoot</vh></v>
<v t="ekr.20040104185913.4268"><vh>testSimpleTests</vh></v>
<v t="ekr.20040104185913.4269"><vh>testComplexOrTests</vh></v>
<v t="ekr.20040104185913.4270"><vh>testComplexANDTests</vh></v>
</v>
<v t="ekr.20040104185913.4271"><vh>test_suite</vh></v>
<v t="ekr.20040104185913.4272"><vh>main</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20040104185606">@ignore
@language python</t>
<t tx="ekr.20040104185618"># An example of running this script:

from leoGlobals import *

@others

types = (".py",".c",".html",".txt")

dir = "c:/prog/Zope-2.6.2-src/lib/python"
dir = "c:/prog/Zope-2.6.2-src/lib/Components"

importFiles(dir,types,recursive=true)

es("done",color="blue")</t>
<t tx="ekr.20040104185618.1">def importFiles (dir,type=None,kind="@file",recursive=false):
	
	c = top() ; v = c.currentVnode()

	# Check the params.
	if kind != "@file" and kind != "@root":
		es("kind must be @file or @root: " + `kind`)
		return

	if not os_path_exists(dir):
		es("directory does not exist: " + `dir`)
		return
	
	c.beginUpdate()
	root = createLastChildOf(v,"imported files")
	try:
		importDir (dir,type,kind,recursive,root)
		root.contract()
	except:
		es_exception()
	c.endUpdate()
</t>
<t tx="ekr.20040104185618.2">def importDir (dir,types,kind,recursive,root):
	
	c = top() # Get the commander.
	es("dir: " + dir,color="blue")
	
	try:
		files = os.listdir(dir)
		files2 = [] ; dirs =[]
		for f in files:
			path = os_path_join(dir,f)
			if os_path_isfile(path):
				name, ext = os_path_splitext(f)
				if not types or ext in types:
					files2.append(path)
			elif recursive:
				dirs.append(path)
		if len(files2) &gt; 0 or len(dirs) &gt; 0:
			child = createLastChildOf(root,dir)
			c.selectVnode(child)
		if len(files2) &gt; 0:
			c.importCommands.importFilesCommand(files2,kind)
		if len(dirs) &gt; 0:
			dirs.sort()
			for dir in dirs:
				importDir(dir,types,kind,recursive,child)
	except:
		es("exception in importFiles script")
		es_exception()
</t>
<t tx="ekr.20040104185618.3">def createLastChildOf (v,headline):
	
	child = v.insertAsLastChild()
	child.initHeadString(headline)
	return child
</t>
<t tx="ekr.20040104185809"></t>
<t tx="ekr.20040104185809.1"></t>
<t tx="ekr.20040104185809.2">@language c

&lt;&lt; c copyright &gt;&gt;
 
/* $Id: IIBTree.c,v 1.8 2002/08/01 20:02:01 bwarsaw Exp $ */

#define INTKEY int
#define INTVAL int

#include "BTree.c"

</t>
<t tx="ekr.20040104185809.4">@language c

&lt;&lt; c copyright &gt;&gt;

static char BTree_module_documentation[] = 
""
"\n$Id: BTree.c,v 1.32 2002/03/27 10:13:59 htrd Exp $"
;

#define PERSISTENT

&lt;&lt; BTree #includes &gt;&gt;

@others
</t>
<t tx="ekr.20040104185809.5">#ifdef PERSISTENT

#include "cPersistence.h"

#ifdef INTKEY
#ifdef INTVAL
#include "intSet.h"
#endif
#endif

#else

#include "ExtensionClass.h"
#define PER_USE_OR_RETURN(self, NULL)
#define PER_ALLOW_DEACTIVATION(self)
#define PER_PREVENT_DEACTIVATION(self)
#define PER_DEL(self)

#endif</t>
<t tx="ekr.20040104185809.6">static void PyVar_Assign(PyObject **v, PyObject *e) { Py_XDECREF(*v); *v=e;}
</t>
<t tx="ekr.20040104185809.7">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if(!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define RETURN_NONE Py_INCREF(Py_None); return Py_None
#define LIST(O) ((PyListObject*)(O))
#define OBJECT(O) ((PyObject*)(O))

#define MIN_BUCKET_ALLOC 8
#define MAX_SIZE(N) 32

#ifdef INTKEY
#define KEY_TYPE INTKEY
#define KEY_PARSE "i"
#define TEST_KEY(k) ((k)-ikey)
#define DECREF_KEY(k)
#define ASSIGN_KEY(k,e) (k=e)
#else
#define KEY_TYPE PyObject *
#define KEY_PARSE "O"
#define TEST_KEY(k) PyObject_Compare(k,key)
#define DECREF_KEY(k) Py_DECREF(k)
#define ASSIGN_KEY(k,e) ASSIGN(k,e)
#endif

#ifdef INTVAL
#define VALUE_TYPE INTVAL
#define VALUE_PARSE "i"
#define DECREF_VALUE(k)
#define ASSIGN_VALUE(k,e) (k=e)
#else
#define VALUE_TYPE PyObject *
#define VALUE_PARSE "O"
#define DECREF_VALUE(k) Py_DECREF(k)
#define ASSIGN_VALUE(k,e) ASSIGN(k,e)
#endif


typedef struct ItemStruct {
  KEY_TYPE key;
  VALUE_TYPE value;
} Item;

typedef struct BTreeItemStruct {
  KEY_TYPE key;
  PyObject *value;
  int count;
} BTreeItem;

typedef struct {
  cPersistent_HEAD
  int size, len;
  Item *data;
} Bucket;

staticforward PyExtensionClass BucketType;

#define BUCKET(O) ((Bucket*)(O))
#define Bucket_Check(O) ((O)-&gt;ob_type==(PyTypeObject*)&amp;BucketType)

typedef struct {
  cPersistent_HEAD
  int size, len;	
  BTreeItem *data;
  int count;
} BTree;


staticforward PyExtensionClass BucketType;

#define BTREE(O) ((BTree*)(O))
#define BTree_Check(O) ((O)-&gt;ob_type==(PyTypeObject*)&amp;BTreeType)

/************************************************************************
  BTreeItems
  */

typedef struct {
  PyObject_HEAD
  BTree *data;
  int first, len;
  char kind;
} BTreeItems;

staticforward PyTypeObject BTreeItemsType;

static PyObject *
newBTreeItems(BTree *data, char kind, int first, int last)
{
  BTreeItems *self;
	
  UNLESS(self = PyObject_NEW(BTreeItems, &amp;BTreeItemsType)) return NULL;
  Py_INCREF(data);
  self-&gt;data=data;
  self-&gt;kind=kind;
  self-&gt;first=first;
  self-&gt;len=last-first;
  return OBJECT(self);
}
</t>
<t tx="ekr.20040104185809.8">static void
BTreeItems_dealloc(BTreeItems *self)
{
  Py_DECREF(self-&gt;data);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.9">static int
BTreeItems_length( BTreeItems *self)
{
  return self-&gt;len;
}
</t>
<t tx="ekr.20040104185809.10">static PyObject * 
BTreeItems_concat( BTreeItems *self, PyObject *bb)
{
  PyErr_SetString(PyExc_TypeError,
		  "BTreeItems objects do not support concatenation");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.11">static PyObject *
BTreeItems_repeat(BTreeItems *self, int n)
{
  PyErr_SetString(PyExc_TypeError,
		  "BTreeItems objects do not support repetition");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.12">static PyObject *
BTreeItems_item_BTree(char kind, int i, BTree *btree)
{
  int l;
  BTreeItem *d;
  PyObject *r;

  PER_USE_OR_RETURN(btree, NULL);

  for(d=btree-&gt;data, l=btree-&gt;len;
      --l &gt;= 0 &amp;&amp; i &gt;= d-&gt;count;
      i -= d-&gt;count, d++);

  PER_ALLOW_DEACTIVATION(btree);

  if(Bucket_Check(d-&gt;value))
    {
      PER_USE_OR_RETURN((Bucket*)(d-&gt;value), NULL);
      switch(kind)
	{
	case 'k': 
#ifdef INTKEY
	  r=PyInt_FromLong((BUCKET(d-&gt;value)-&gt;data[i].key));
#else
	  r=(BUCKET(d-&gt;value)-&gt;data[i].key);
	  Py_INCREF(r);
#endif
	  break;
	case 'v': 
#ifdef INTVAL
	  r=PyInt_FromLong((BUCKET(d-&gt;value)-&gt;data[i].value));
#else
	  r=(BUCKET(d-&gt;value)-&gt;data[i].value);
	  Py_INCREF(r);
#endif
	  break;
	default:
	  r=Py_BuildValue(KEY_PARSE VALUE_PARSE,
			  BUCKET(d-&gt;value)-&gt;data[i].key,
			  BUCKET(d-&gt;value)-&gt;data[i].value);
	}
      PER_ALLOW_DEACTIVATION(BUCKET(d-&gt;value));
      return r;
    }
  return BTreeItems_item_BTree(kind, i, BTREE(d-&gt;value));
}
</t>
<t tx="ekr.20040104185809.13">static PyObject *
BTreeItems_item(BTreeItems *self, int i)
{
  int j, l, L;

  j=i;
  l=self-&gt;len;
  if(j &lt; 0) j += l;
  i=j+self-&gt;first;

  PER_USE_OR_RETURN(self-&gt;data, NULL);
  L=self-&gt;data-&gt;count;
  PER_ALLOW_DEACTIVATION(self-&gt;data);

  if(j &lt; 0 || j &gt;= l || i &gt;= L)
    {
      PyObject *v;
      v=PyInt_FromLong(i);
      UNLESS(v)
	{
	  v=Py_None;
	  Py_INCREF(v);
	}
      PyErr_SetObject(PyExc_IndexError, v);
      Py_DECREF(v);
      return NULL;
    }

  return BTreeItems_item_BTree(self-&gt;kind, i, self-&gt;data);
}
</t>
<t tx="ekr.20040104185809.14">static PyObject *
BTreeItems_slice(BTreeItems *self, int ilow, int ihigh)
{
  if(ihigh &gt; self-&gt;len) ihigh=self-&gt;len;
  ilow  += self-&gt;first;
  ihigh += self-&gt;first;
  return newBTreeItems(self-&gt;data, self-&gt;kind, ilow, ihigh);
}
</t>
<t tx="ekr.20040104185809.15">static int
BTreeItems_ass_item(BTreeItems *self, int i, PyObject *v)
{
  PyErr_SetString(PyExc_TypeError,
		  "BTreeItems objects do not support item assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185809.16">static int
BTreeItems_ass_slice(PyListObject *self, int ilow, int ihigh, PyObject *v)
{
  PyErr_SetString(PyExc_TypeError,
		  "BTreeItems objects do not support slice assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185809.17">static PySequenceMethods BTreeItems_as_sequence = {
	(inquiry)BTreeItems_length,		/*sq_length*/
	(binaryfunc)BTreeItems_concat,		/*sq_concat*/
	(intargfunc)BTreeItems_repeat,		/*sq_repeat*/
	(intargfunc)BTreeItems_item,		/*sq_item*/
	(intintargfunc)BTreeItems_slice,		/*sq_slice*/
	(intobjargproc)BTreeItems_ass_item,	/*sq_ass_item*/
	(intintobjargproc)BTreeItems_ass_slice,	/*sq_ass_slice*/
};

/* -------------------------------------------------------------- */

static PyTypeObject BTreeItemsType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "BTreeItems",			/*tp_name*/
  sizeof(BTreeItems),	/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)BTreeItems_dealloc,	/*tp_dealloc*/
  (printfunc)0,	/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,	/*tp_compare*/
  (reprfunc)0,		/*tp_repr*/
  0,		/*tp_as_number*/
  &amp;BTreeItems_as_sequence,		/*tp_as_sequence*/
  0,		/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,	/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  0,			/*tp_getattro*/
  0,			/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Sequence type used to iterate over BTree items." /* Documentation string */
};

/************************************************************************/


static void *
PyMalloc(size_t sz)
{
  void *r;

  if((r=malloc(sz))) return r;

  PyErr_NoMemory();
  return NULL;
}
</t>
<t tx="ekr.20040104185809.18">static void *
PyRealloc(void *p, size_t sz)
{
  void *r;

  if((r=realloc(p,sz))) return r;

  PyErr_NoMemory();
  return NULL;
}
</t>
<t tx="ekr.20040104185809.19">static int
BTree_ini(BTree *self)
{
  PyObject *b;

  UNLESS(b=PyObject_CallObject(OBJECT(&amp;BucketType), NULL)) return -1;
#ifndef INTKEY
  Py_INCREF(Py_None);
  self-&gt;data-&gt;key=Py_None;
#endif
  self-&gt;data-&gt;value=b;
  self-&gt;data-&gt;count=0;
  self-&gt;len=1;
  self-&gt;count=0;
  return 0;
}
</t>
<t tx="ekr.20040104185809.20">static int
BTree_init(BTree *self)
{
  UNLESS(self-&gt;data=PyMalloc(sizeof(BTreeItem)*2)) return -1;
  self-&gt;size=2;
  return BTree_ini(self);
}
</t>
<t tx="ekr.20040104185809.21">static int
bucket_index(Bucket *self, PyObject *key, int less)
{
  /*
    If less, return the index of the largest key that is less than or
    equall to key.  Otherwise return the index of the smallest key
    that is greater than or equal to key.
   */
  int min, max, i, l, cmp;
#ifdef INTKEY
  int ikey;

  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __getitem__ expected integer key");
      return -9;
    }
  ikey=PyInt_AsLong(key);
#endif

  PER_USE_OR_RETURN(self, -1);

  for(min=0, max=self-&gt;len, i=max/2, l=max; i != l; l=i, i=(min+max)/2)
    {
      cmp=TEST_KEY(self-&gt;data[i].key);
      if(cmp &lt; 0) min=i;
      else if(cmp == 0)
	{
	  PER_ALLOW_DEACTIVATION(self);
	  return i;
	}
      else max=i;
    }

  PER_ALLOW_DEACTIVATION(self);

  if(less) return max-1;
  if(max==min) return min;
  return min+1;
}
</t>
<t tx="ekr.20040104185809.22">static PyObject *
_bucket_get(Bucket *self, PyObject *key, int has_key)
{
  int min, max, i, l, cmp;
  PyObject *r;
#ifdef INTKEY
  int ikey;

  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __getitem__ expected integer key");
      return NULL;
    }
  ikey=PyInt_AsLong(key);
#endif

  PER_USE_OR_RETURN(self, NULL);

  for(min=0, max=self-&gt;len, i=max/2, l=max; i != l; l=i, i=(min+max)/2)
    {
      cmp=TEST_KEY(self-&gt;data[i].key);
      if(cmp &lt; 0) min=i;
      else if(cmp == 0)
	{
	  if(has_key) r=PyInt_FromLong(1);
	  else
	    {
#ifdef INTVAL
	      r=PyInt_FromLong(self-&gt;data[i].value);
#else
	      r=self-&gt;data[i].value;
	      Py_INCREF(r);
#endif
	    }
	  PER_ALLOW_DEACTIVATION(self);
	  return r;
	}
      else max=i;
    }

  PER_ALLOW_DEACTIVATION(self);
  if(has_key) return PyInt_FromLong(0);
  PyErr_SetObject(PyExc_KeyError, key);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.23">static PyObject *
bucket_get(Bucket *self, PyObject *key)
{
  return _bucket_get(self, key, 0);
}
</t>
<t tx="ekr.20040104185809.24">static PyObject *
bucket_map(Bucket *self, PyObject *args)
{
  PyObject *keys, *key, *r;
  int l, i, a;

  UNLESS(PyArg_ParseTuple(args,"O", &amp;keys)) return NULL;
  if((l=PyObject_Length(keys)) &lt; 0) return NULL;
  UNLESS(r=PyList_New(0)) return NULL;

  for(i=0; i &lt; l; i++)
    {
      UNLESS(key=PySequence_GetItem(keys,i)) goto err;
      ASSIGN(key, _bucket_get(self, key, 0));
      if(key)
	{
	  a=PyList_Append(r,key);
	  Py_DECREF(key);
	  if(a&lt;0) goto err;
	}
      else PyErr_Clear();
    }

  return r;

err:
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.25">static int
BTree_index(BTree *self, PyObject *key, int less)
{
  /*
    If less, return the index of the largest key that is less than or
    equall to key.  Otherwise return the index of the smallest key
    that is greater than or equal to key.
   */
  int min, max, i, cmp;
#ifdef INTKEY
  int ikey;

  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __getitem__ expected integer key");
      return -9;
    }
  ikey=PyInt_AsLong(key);
#endif

  PER_USE_OR_RETURN(self, -1);
  
  UNLESS(self-&gt;data) if(BTree_init(self) &lt; 0) goto err;
  
  for(min=0, max=self-&gt;len, i=max/2; max-min &gt; 1; i=(min+max)/2)
    {
      cmp=TEST_KEY(self-&gt;data[i].key);
      if(cmp &lt; 0) min=i;
      else if(cmp == 0)
	{
	  min=i;
	  break;
	}
      else max=i;
    }

  if(Bucket_Check(self-&gt;data[min].value))
    i=bucket_index(BUCKET(self-&gt;data[min].value), key, less);
  else
    i= BTree_index( BTREE(self-&gt;data[min].value), key, less);

  if(i==-9) goto err;

  while(--min &gt;= 0) i+=self-&gt;data[min].count;

  PER_ALLOW_DEACTIVATION(self);
  return i;

err:

  PER_ALLOW_DEACTIVATION(self);
  return -9;
}</t>
<t tx="ekr.20040104185809.26">static PyObject *
_BTree_get(BTree *self, PyObject *key, int has_key)
{
  int min, max, i, cmp;
  PyObject *r;
#ifdef INTKEY
  int ikey;

  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __getitem__ expected integer key");
      return NULL;
    }
  ikey=PyInt_AsLong(key);
#endif

  PER_USE_OR_RETURN(self, NULL);

  UNLESS(self-&gt;data) if(BTree_init(self) &lt; 0) goto err;
  
  for(min=0, max=self-&gt;len, i=max/2; max-min &gt; 1; i=(min+max)/2)
    {
      cmp=TEST_KEY(self-&gt;data[i].key);
      if(cmp &lt; 0) min=i;
      else if(cmp == 0)
	{
	  min=i;
	  break;
	}
      else max=i;
    }

  if(Bucket_Check(self-&gt;data[min].value))
    r=_bucket_get(BUCKET(self-&gt;data[min].value), key, has_key);
  else
    r=_BTree_get( BTREE(self-&gt;data[min].value), key, has_key);

  PER_ALLOW_DEACTIVATION(self);
  return r;

err:

  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}</t>
<t tx="ekr.20040104185809.27">static PyObject *
BTree_get(BTree *self, PyObject *key)
{
  return _BTree_get(self, key, 0);
}
</t>
<t tx="ekr.20040104185809.28">static PyObject *
BTree_map(BTree *self, PyObject *args)
{
  PyObject *keys, *key, *r;
  int l, i, a;

  UNLESS(PyArg_ParseTuple(args,"O", &amp;keys)) return NULL;
  if((l=PyObject_Length(keys)) &lt; 0) return NULL;
  UNLESS(r=PyList_New(0)) return NULL;

  for(i=0; i &lt; l; i++)
    {
      UNLESS(key=PySequence_GetItem(keys,i)) goto err;
      ASSIGN(key, _BTree_get(self, key, 0));
      if(key)
	{
	  a=PyList_Append(r,key);
	  Py_DECREF(key);
	  if(a&lt;0) goto err;
	}
      else PyErr_Clear();
    }

  return r;

err:
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.29">static int
_bucket_set(Bucket *self, PyObject *key, PyObject *v)
{
  int min, max, i, l, cmp;
  Item *d;
#ifdef INTKEY
  int ikey;
#endif
#ifdef INTVAL
  int iv = 0;
#endif

#ifdef INTKEY
  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __setitem__ expected integer value");
      return -1;
    }
  ikey=PyInt_AsLong(key);
#endif

#ifdef INTVAL
  if(v)
    {
      UNLESS(PyInt_Check(v))
	{
	  PyErr_SetString(PyExc_TypeError,
			  "Bucket __getitem__ expected integer key");
	  return -1;
	}
      iv=PyInt_AsLong(v);
    }
#endif

  PER_USE_OR_RETURN(self, -1);

  for(min=0, max=l=self-&gt;len, i=max/2; i != l; l=i, i=(min+max)/2)
    {
      if((cmp=TEST_KEY(self-&gt;data[i].key)) &lt; 0) min=i;
      else if(cmp==0)
	{
	  if(v)			/* Assign value to key */
	    {
#ifdef INTVAL
	      self-&gt;data[i].value=iv;
#else
	      Py_INCREF(v);
	      ASSIGN(self-&gt;data[i].value, v);
#endif
	      if(PER_CHANGED(self) &lt; 0) goto err;
	      PER_ALLOW_DEACTIVATION(self);
	      return 0;
	    }
	  else			/* There's no value so remove the item */
	    {
	      self-&gt;len--;
	      d=self-&gt;data+i;
	      DECREF_KEY(d-&gt;key);
	      DECREF_VALUE(d-&gt;value);
	      if(i &lt; self-&gt;len)	memmove(d,d+1,sizeof(Item)*(self-&gt;len-i));
	      else if(! self-&gt;len)
		{
		  self-&gt;size=0;
		  free(self-&gt;data);
		  self-&gt;data=NULL;
		}
	      if(PER_CHANGED(self) &lt; 0) goto err;
	      PER_ALLOW_DEACTIVATION(self);
	      return 1;
	    }
	}
      else max=i;
    }

  if(!v)
    {
      PyErr_SetObject(PyExc_KeyError, key);
      goto err;
    }

  if(self-&gt;len==self-&gt;size)
    {
      if(self-&gt;data)
	{
	  UNLESS(d=PyRealloc(self-&gt;data, sizeof(Item)*self-&gt;size*2)) goto err;
	  self-&gt;data=d;
	  self-&gt;size*=2;
	}
      else
	{
	  UNLESS(self-&gt;data=PyMalloc(sizeof(Item)*MIN_BUCKET_ALLOC)) goto err;
	  self-&gt;size=MIN_BUCKET_ALLOC;
	}
    }
  if(max != i) i++;
  d=self-&gt;data+i;
  if(self-&gt;len &gt; i) memmove(d+1,d,sizeof(Item)*(self-&gt;len-i));
#ifdef INTKEY
  d-&gt;key=ikey;
#else
  d-&gt;key=key;
  Py_INCREF(key);
#endif
#ifdef INTVAL
  d-&gt;value=iv;
#else
  d-&gt;value=v;
  Py_INCREF(v);
#endif
  self-&gt;len++;

  if(PER_CHANGED(self) &lt; 0) goto err;
  PER_ALLOW_DEACTIVATION(self);
  return 1;

err:
  PER_ALLOW_DEACTIVATION(self);
  return -1;
}
</t>
<t tx="ekr.20040104185809.30">static int
bucket_setitem(Bucket *self, PyObject *key, PyObject *v)
{
  if(_bucket_set(self,key,v) &lt; 0) return -1;
  return 0;
}
</t>
<t tx="ekr.20040104185809.31">static int
bucket_split(Bucket *self, int index, Bucket *next)
{
  if(index &lt; 0 || index &gt;= self-&gt;len) index=self-&gt;len/2;

  UNLESS(next-&gt;data=PyMalloc(sizeof(Item)*(self-&gt;len-index))) return -1;
  next-&gt;len=self-&gt;len-index;
  next-&gt;size=next-&gt;len;
  memcpy(next-&gt;data, self-&gt;data+index, sizeof(Item)*next-&gt;size);

  self-&gt;len=index;

  return 0;
}
</t>
<t tx="ekr.20040104185809.32">static int
BTree_count(BTree *self)
{
  int i, c=0;
  BTreeItem *d;

  for(i=self-&gt;len, d=self-&gt;data; --i &gt;= 0; d++)
    c += d-&gt;count;

  return c;
}
</t>
<t tx="ekr.20040104185809.33">static int
BTree_split(BTree *self, int index, BTree *next)
{
  if(index &lt; 0 || index &gt;= self-&gt;len) index=self-&gt;len/2;
  
  UNLESS(next-&gt;data=PyMalloc(sizeof(BTreeItem)*(self-&gt;len-index)))
    return -1;
  next-&gt;len=self-&gt;len-index;
  next-&gt;size=next-&gt;len;
  memcpy(next-&gt;data, self-&gt;data+index, sizeof(BTreeItem)*next-&gt;size);
  if((next-&gt;count=BTree_count(next)) &lt; 0) return -1;
  
  self-&gt;len = index;
  self-&gt;count -= next-&gt;count;
  
  return 0;
}
</t>
<t tx="ekr.20040104185809.34">static int
BTree_clone(BTree *self)
{
  /* We've grown really big without anybody splitting us.
     We should split ourselves.
   */
  BTree *n1=0, *n2=0;
  BTreeItem *d=0;
  int count;
  
  /* Create two BTrees to hold ourselves after split */
  UNLESS(n1=BTREE(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL))) return -1;
  UNLESS(n2=BTREE(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL))) goto err;

  /* Create a new data buffer to hold two BTrees */
  UNLESS(d=PyMalloc(sizeof(BTreeItem)*2)) goto err;

  count=self-&gt;count;

  /* Split ourself */
  if(BTree_split(self,-1,n2) &lt; 0) goto err;
  
  /* Move our data to new BTree */
  n1-&gt;size=self-&gt;size;
  n1-&gt;len=self-&gt;len;
  n1-&gt;count=self-&gt;count;
  n1-&gt;data=self-&gt;data;

  /* Initialize our data to hold split data */
  self-&gt;data=d;
  Py_INCREF(Py_None);
#ifndef INTKEY
  self-&gt;data-&gt;key=Py_None;
#endif
  self-&gt;len=2;
  self-&gt;size=2;
  self-&gt;data-&gt;value=OBJECT(n1);
  self-&gt;data-&gt;count=n1-&gt;count;
#ifndef INTKEY
  Py_INCREF(n2-&gt;data-&gt;key);
#endif
  self-&gt;data[1].key=n2-&gt;data-&gt;key;
  self-&gt;data[1].value=OBJECT(n2);
  self-&gt;data[1].count=n2-&gt;count;
  self-&gt;count=count;

  return 0;

err:
  Py_XDECREF(n1);
  Py_XDECREF(n2);
  free(d);
  return -1;
}
</t>
<t tx="ekr.20040104185809.35">static int 
BTree_grow(BTree *self, int index)
{
  int i;
  PyObject *v, *e=0;
  BTreeItem *d;

  if(self-&gt;len == self-&gt;size)
    {
      UNLESS(d=PyRealloc(self-&gt;data, sizeof(BTreeItem)*self-&gt;size*2))
	return -1;
      self-&gt;data=d;
      self-&gt;size *= 2;
    }

  d=self-&gt;data+index;
  v=d-&gt;value;
  UNLESS(e=PyObject_CallObject(OBJECT(v-&gt;ob_type), NULL)) return -1;

  PER_USE_OR_RETURN((Bucket*)v, -1);

  if(Bucket_Check(v))
    {
      i=bucket_split(BUCKET(v), -1, BUCKET(e));
      d-&gt;count=BUCKET(v)-&gt;len;
    }
  else
    {
      i=BTree_split(  BTREE(v), -1,   BTREE(e));
      d-&gt;count=BTREE(v)-&gt;count;      
    }

  PER_ALLOW_DEACTIVATION(BUCKET(v));

  if(i &lt; 0)
    {
      Py_DECREF(e);
      return -1;
    }

  index++;
  d++;
  if(self-&gt;len &gt; index)
    memmove(d+1, d, sizeof(BTreeItem)*(self-&gt;len-index));

  if(Bucket_Check(v))
    {
      d-&gt;key=BUCKET(e)-&gt;data-&gt;key;
      d-&gt;count=BUCKET(e)-&gt;len;
    }
  else
    {
      d-&gt;key=BTREE(e)-&gt;data-&gt;key;
      d-&gt;count=BTREE(e)-&gt;count;      
    }
#ifndef INTKEY
  Py_INCREF(d-&gt;key);
#endif
  d-&gt;value=e;
  
  self-&gt;len++;

  if(self-&gt;len &gt;= MAX_SIZE(self) * 2) return BTree_clone(self);
  
  return 0;
}
</t>
<t tx="ekr.20040104185809.36">static int
_BTree_set(BTree *self, PyObject *key, PyObject *value)
{
  int i, min, max, cmp, grew;
  BTreeItem *d;
#ifdef INTKEY
  int ikey;
#endif

#ifdef INTKEY
  UNLESS(PyInt_Check(key))
    {
      PyErr_SetString(PyExc_TypeError,
		      "Bucket __setitem__ expected integer value");
      return -1;
    }
  ikey=PyInt_AsLong(key);
#endif

  PER_USE_OR_RETURN(self, -1);

  UNLESS(self-&gt;data) if(BTree_init(self) &lt; 0) goto err;

  for(min=0, max=self-&gt;len, i=max/2; max-min &gt; 1; i=(max+min)/2)
    {
      d=self-&gt;data+i;
      cmp=TEST_KEY(d-&gt;key);
      if(cmp &lt; 0) min=i;
      else if(cmp==0)
	{
	  min=i;
	  break;
	}
      else max=i;
    }

  d=self-&gt;data+min;
  if(Bucket_Check(d-&gt;value))
    grew=_bucket_set(BUCKET(d-&gt;value), key, value);
  else
    grew= _BTree_set( BTREE(d-&gt;value), key, value);
  if(grew &lt; 0) goto err;

  if(grew)
    {
      if(value)			/* got bigger */
	{
	  d-&gt;count++;
	  self-&gt;count++;
	  if(BUCKET(d-&gt;value)-&gt;len &gt; MAX_SIZE(self) &amp;&amp;
	     BTree_grow(self,min) &lt; 0) goto err;
	}
      else			/* got smaller */
	{
	  d-&gt;count--;
	  self-&gt;count--;
	  if(! d-&gt;count &amp;&amp; self-&gt;len &gt; 1)
	    {
	      self-&gt;len--;
	      Py_DECREF(d-&gt;value);
	      DECREF_KEY(d-&gt;key);
	      if(min &lt; self-&gt;len)
		memmove(d, d+1, (self-&gt;len-min)*sizeof(BTreeItem));
	    }
	}
      if(PER_CHANGED(self) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  return grew;

err:
  PER_ALLOW_DEACTIVATION(self);
  return -1;
}
</t>
<t tx="ekr.20040104185809.37">static int
BTree_setitem(BTree *self, PyObject *key, PyObject *v)
{
  if(_BTree_set(self,key,v) &lt; 0) return -1;
  return 0;
}
</t>
<t tx="ekr.20040104185809.38">static PyObject *
bucket_keys(Bucket *self, PyObject *args)
{
  PyObject *r=0, *key;
  int i;
  
  PER_USE_OR_RETURN(self, NULL);

  UNLESS(r=PyList_New(self-&gt;len)) goto err;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
#ifdef INTKEY
      UNLESS(key=PyInt_FromLong(self-&gt;data[i].key)) goto err;
#else
      key=self-&gt;data[i].key;
      Py_INCREF(key);
#endif
      if(PyList_SetItem(r, i, key) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.39">static PyObject *
bucket_values(Bucket *self, PyObject *args)
{
  PyObject *r=0, *v;
  int i;
  
  PER_USE_OR_RETURN(self, NULL);
  
  UNLESS(r=PyList_New(self-&gt;len)) goto err;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
#ifdef INTVAL
      UNLESS(v=PyInt_FromLong(self-&gt;data[i].value)) goto err;
#else
      v=self-&gt;data[i].value;
      Py_INCREF(v);
#endif
      if(PyList_SetItem(r, i, v) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.40">static PyObject *
bucket_items(Bucket *self, PyObject *args)
{
  PyObject *r, *item;
  int i;
  
  PER_USE_OR_RETURN(self, NULL);
  
  UNLESS(r=PyList_New(self-&gt;len)) goto err;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
      UNLESS(item=Py_BuildValue(KEY_PARSE VALUE_PARSE,
				self-&gt;data[i].key,self-&gt;data[i].value))
	goto err;
      if(PyList_SetItem(r, i, item) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.41">#ifdef PERSISTENT
static PyObject *
bucket__p___reinit__(Bucket *self, PyObject *args)
{
  if(self-&gt;state==cPersistent_UPTODATE_STATE)
    {
      int i;
      PyObject *dict;

      for(i=self-&gt;len; --i &gt;= 0; )
	{
	  DECREF_KEY(self-&gt;data[i].key);
	  DECREF_VALUE(self-&gt;data[i].value);
	}
      if(HasInstDict(self) &amp;&amp; (dict=INSTANCE_DICT(self))) PyDict_Clear(dict);
      self-&gt;len=0;
      PER_GHOSTIFY(self);
    }

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.42">#endif
  
static PyObject *
bucket_clear(Bucket *self, PyObject *args)
{
  int i;

  PER_USE_OR_RETURN(self, NULL);

  for(i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;data[i].key);
      DECREF_VALUE(self-&gt;data[i].value);
    }
  self-&gt;len=0;
  if(PER_CHANGED(self) &lt; 0) goto err;
  PER_ALLOW_DEACTIVATION(self);
  RETURN_NONE;

err:
  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.43">static int
_BTree_clear(BTree *self)
{
  int i;

  UNLESS(self-&gt;data) return 0;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;data[i].key);
      Py_DECREF(self-&gt;data[i].value);
    }

  i=BTree_ini(self);

  return i;
}
</t>
<t tx="ekr.20040104185809.44">#ifdef PERSISTENT
static PyObject *
BTree__p___reinit__(BTree *self, PyObject *args)
{
  if(self-&gt;state==cPersistent_UPTODATE_STATE)
    {
      PyObject *dict;

      if(_BTree_clear(self) &lt; 0) return NULL;
      if(HasInstDict(self) &amp;&amp; (dict=INSTANCE_DICT(self))) PyDict_Clear(dict);
      PER_GHOSTIFY(self);
    }

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.45">#endif

static PyObject *
BTree_clear(BTree *self, PyObject *args)
{
  PER_USE_OR_RETURN(self, NULL);
  if(_BTree_clear(self) &lt; 0) goto err;

  if(PER_CHANGED(self) &lt; 0) goto err;

  PER_ALLOW_DEACTIVATION(self);

  RETURN_NONE;

err:
  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.46">static PyObject *
bucket_getstate(Bucket *self, PyObject *args)
{
  PyObject *r, *keys=0, *values=0;
  int i, l;
#ifdef INTKEY
  int v;
  char *c;
#else
#ifdef INTVAL
  int v;
  char *c;
#endif
#endif

  PER_USE_OR_RETURN(self, NULL);

  l=self-&gt;len;

#ifdef INTKEY
  UNLESS(keys=PyString_FromStringAndSize(NULL,l*sizeof(int))) goto err;
  UNLESS(c=PyString_AsString(keys)) goto err;
  for(i=0; i &lt; l; i++)
    {
      v=self-&gt;data[i].key;
      *c++ = (int)( v        &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 8)  &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 16) &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 24) &amp; 0xff);
    }
#else
  UNLESS(keys=PyTuple_New(self-&gt;len)) goto err;
  for(i=0; i&lt;l; i++)
    {
      r=self-&gt;data[i].key;
      Py_INCREF(r);
      PyTuple_SET_ITEM(keys,i,r);
    }
#endif

#ifdef INTVAL
  UNLESS(values=PyString_FromStringAndSize(NULL,l*sizeof(int))) goto err;
  UNLESS(c=PyString_AsString(values)) goto err;
  for(i=0; i &lt; l; i++)
    {
      v=self-&gt;data[i].value;
      *c++ = (int)( v        &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 8)  &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 16) &amp; 0xff);
      *c++ = (int)((v &gt;&gt; 24) &amp; 0xff);
    }
#else
  UNLESS(values=PyTuple_New(self-&gt;len)) goto err;
  for(i=0; i&lt;l; i++)
    {
      r=self-&gt;data[i].value;
      Py_INCREF(r);
      PyTuple_SET_ITEM(values,i,r);
    }
#endif

  PER_ALLOW_DEACTIVATION(self);
  r=Py_BuildValue("OO",keys,values);
  Py_DECREF(keys);
  Py_DECREF(values);
  return r;

err:
  PER_ALLOW_DEACTIVATION(self);
  Py_XDECREF(keys);
  Py_XDECREF(values);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.47">static PyObject *
bucket_setstate(Bucket *self, PyObject *args)
{
  PyObject *r, *keys=0, *values=0;
  int i, l, v;
  Item *d;
#ifdef INTKEY
  char *ck;
#endif
#ifdef INTVAL
  char *cv;
#endif

  PER_PREVENT_DEACTIVATION(self); 

  UNLESS(PyArg_ParseTuple(args,"O",&amp;r)) goto err;
  UNLESS(PyArg_ParseTuple(r,"OO",&amp;keys,&amp;values)) goto err;

  if((l=PyObject_Length(keys)) &lt; 0) goto err;
#ifdef INTKEY
  l/=4;
  UNLESS(ck=PyString_AsString(keys)) goto err;
#endif

  if((v=PyObject_Length(values)) &lt; 0) goto err;
#ifdef INTVAL
  v/=4;
  UNLESS(cv=PyString_AsString(values)) goto err;
#endif

  if(l!=v)
    {
      PyErr_SetString(PyExc_ValueError,
		      "number of keys differs from number of values");
      goto err;
    }
  
  if(l &gt; self-&gt;size)
    if(self-&gt;data)
      {
	UNLESS(d=PyRealloc(self-&gt;data, sizeof(Item)*l)) goto err;
	self-&gt;data=d;
	self-&gt;size=l;
      }
    else
      {
	UNLESS(d=PyMalloc(sizeof(Item)*l)) goto err;
	self-&gt;data=d;
	self-&gt;size=l;
      }
  else d=self-&gt;data;

#ifdef INTKEY
  for(i=l; --i &gt;= 0; d++)
    {
      v  = ((int)(unsigned char)*ck++)      ;
      v |= ((int)(unsigned char)*ck++) &lt;&lt;  8;
      v |= ((int)(unsigned char)*ck++) &lt;&lt; 16;
      v |= ((int)(unsigned char)*ck++) &lt;&lt; 24;
      d-&gt;key=v;
    }
#else

  for(i=0; i&lt;l; i++, d++)
    {
      UNLESS(r=PySequence_GetItem(keys,i)) goto err;
      if(i &lt; self-&gt;len) {
        Py_DECREF(d-&gt;key);
      }
      d-&gt;key=r;
    }
#endif

  d=self-&gt;data;

#ifdef INTVAL
  for(i=l; --i &gt;= 0; d++)
    {
      v  = ((int)(unsigned char)*cv++)      ;
      v |= ((int)(unsigned char)*cv++) &lt;&lt;  8;
      v |= ((int)(unsigned char)*cv++) &lt;&lt; 16;
      v |= ((int)(unsigned char)*cv++) &lt;&lt; 24;
      d-&gt;value=v;
    }
#else

  for(i=0; i&lt;l; i++, d++)
    {
      UNLESS(r=PySequence_GetItem(values,i)) goto err;
      if(i &lt; self-&gt;len) {
        Py_DECREF(d-&gt;value);
      }
      d-&gt;value=r;
    }
#endif

  self-&gt;len=l;

  PER_ALLOW_DEACTIVATION(self);
  Py_INCREF(Py_None);
  return Py_None;

err:
  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.48">static PyObject *
bucket_has_key(Bucket *self, PyObject *args)
{
  PyObject *key;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  return _bucket_get(self, key, 1);
}
</t>
<t tx="ekr.20040104185809.49">static PyObject *
bucket_getm(Bucket *self, PyObject *args)
{
  PyObject *key, *d=Py_None, *r;

  UNLESS(PyArg_ParseTuple(args, "O|O", &amp;key, &amp;d)) return NULL;
  if((r=_bucket_get(self, key, 0))) return r;
  PyErr_Clear();
  Py_INCREF(d);
  return d;
}
</t>
<t tx="ekr.20040104185809.50">#ifdef INTKEY
#ifdef INTVAL

static PyObject *
_bucket_intset_operation(Bucket *self, intSet *other, 
			 int cpysrc, int cpyboth, int cpyoth)
{
  Bucket *r=0;
  int i, l, io, lo;
  Item *d;
  INTSET_DATA_TYPE *od;

  Item v;
  int vo;



  PER_USE_OR_RETURN(self, NULL); 
  PER_USE_OR_RETURN(other, NULL);

  od=other-&gt;data;		
  d=self-&gt;data;

  UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL)))
    goto err;

  for(i=0, l=self-&gt;len, io=0, lo=other-&gt;len; i &lt; l &amp;&amp; io &lt; lo; )
    {
      v=d[i];
      vo=od[io];
      if(v.key &lt; vo)
	{
	  if(cpysrc)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(v.key), 
				PyInt_FromLong(v.value))
		 ) goto err;
	    }
	  i++;
	}
      else if(v.key==vo)
	{
	  if(cpyboth)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(v.key), 
				PyInt_FromLong(v.value+1))
		 ) goto err;
	    }
	  i++;
	  io++;
	}
      else
	{
	  if(cpyoth)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(vo), 
				PyInt_FromLong(1))
		 ) goto err;
	    }
	  io++;
	}
    }
  
  
  if(cpysrc &amp;&amp; i &lt; l)
    {
      for(;i&lt;l;i++){
	v=d[i];
	if(bucket_setitem(r, PyInt_FromLong(v.key), 
			  PyInt_FromLong(v.value))
	   ) goto err;
      }
    }
  else if(cpyoth &amp;&amp; io &lt; lo)
    {
      
      for(;io&lt;lo;io++){
	vo=od[io];
	
	if(bucket_setitem(r, PyInt_FromLong(vo), 
			  PyInt_FromLong(1))
	   ) goto err;
      }
    }
 

  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(other);
  return OBJECT(r);

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(other);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.51">static PyObject *
bucket_set_operation(Bucket *self, PyObject *other, 
		     int cpysrc, int cpyboth, int cpyoth)
{
  Bucket *r=0, *o;
  int i, l, io, lo;
  Item *d, *od;
  Item v, vo;

  if (intSetType == OBJECT(other-&gt;ob_type))
    return _bucket_intset_operation(self, INTSET(other), 
				    cpysrc, cpyboth, cpyoth); 
  else if(other-&gt;ob_type != self-&gt;ob_type)
    {
      PyErr_SetString(PyExc_TypeError,
		      "IIBTree set operations requires an object of type "
		      "IIBTree or intSet");
      return NULL;
  }
  else 
    o=BUCKET(other);		


  PER_USE_OR_RETURN(self, NULL); 
  PER_USE_OR_RETURN(BUCKET(other), NULL);

  od=o-&gt;data;		
  d=self-&gt;data;

  UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL)))
    goto err;

  for(i=0, l=self-&gt;len, io=0, lo=o-&gt;len; i &lt; l &amp;&amp; io &lt; lo; )
    {
      v=d[i];
      vo=od[io];
      if(v.key &lt; vo.key)
	{
	  if(cpysrc)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(v.key), 
				PyInt_FromLong(v.value))
		 ) goto err;
	    }
	  i++;
	}
      else if(v.key==vo.key)
	{
	  if(cpyboth)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(v.key), 
				PyInt_FromLong(v.value+vo.value))
		 ) goto err;
	    }
	  i++;
	  io++;
	}
      else
	{
	  if(cpyoth)
	    {
	      if(bucket_setitem(r, PyInt_FromLong(vo.key), 
				PyInt_FromLong(vo.value))
		 ) goto err;
	    }
	  io++;
	}
    }
  
  if(cpysrc &amp;&amp; i &lt; l)
    {
      for(;i&lt;l;i++)
	{
	  v=d[i];
	  if(bucket_setitem(r, PyInt_FromLong(v.key), 
			    PyInt_FromLong(v.value))
	     ) goto err;
	}
    }
  else if(cpyoth &amp;&amp; io &lt; lo)
    {
      
      for(;io&lt;lo;io++)
	{
	  vo=od[io];
	  
	  if(bucket_setitem(r, PyInt_FromLong(vo.key), 
			    PyInt_FromLong(vo.value))
	     ) goto err;
	}
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(o);
  return OBJECT(r);

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(o);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.52">static PyObject *
bucket_union(Bucket *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return bucket_set_operation(self,other,1,1,1);
}
</t>
<t tx="ekr.20040104185809.53">static PyObject *
bucket_intersection(Bucket *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return bucket_set_operation(self,other,0,1,0);
}
</t>
<t tx="ekr.20040104185809.54">static PyObject *
bucket_difference(Bucket *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return bucket_set_operation(self,other,1,0,0);
}
</t>
<t tx="ekr.20040104185809.55">#endif
#endif


static struct PyMethodDef Bucket_methods[] = {
  {"__getstate__", (PyCFunction)bucket_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction)bucket_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"keys",	(PyCFunction)bucket_keys,	METH_VARARGS,
     "keys() -- Return the keys"},
  {"has_key",	(PyCFunction)bucket_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"values",	(PyCFunction)bucket_values,	METH_VARARGS,
     "values() -- Return the values"},
  {"items",	(PyCFunction)bucket_items,	METH_VARARGS,
     "items() -- Return the items"},
  {"clear",	(PyCFunction)bucket_clear,	METH_VARARGS,
     "clear() -- Remove all of the items from the bucket"},
  {"map",	(PyCFunction)bucket_map,	METH_VARARGS,
     "map(keys) -- map a sorted sequence of keys into values\n\n"
     "Invalid keys are skipped"},
  {"get",	(PyCFunction)bucket_getm,	METH_VARARGS,
   "get(key[,default]) -- Look up a value\n\n"
   "Return the default (or None) if the key is not found."
  },
#ifdef PERSISTENT
  {"_p___reinit__",	(PyCFunction)bucket__p___reinit__,	METH_VARARGS,
   "_p___reinit__() -- Reinitialize from a newly created copy"},
  {"_p_deactivate",	(PyCFunction)bucket__p___reinit__,	METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
#ifdef INTKEY
#ifdef INTVAL
  {"union",	(PyCFunction)bucket_union, METH_VARARGS,
   "union(other) -- "
   "Return the union of the set with another set"},
  {"intersection",	(PyCFunction)bucket_intersection, METH_VARARGS,
   "intersection(other) -- "
   "Return the intersection of the set with another set"},
  {"difference",	(PyCFunction)bucket_difference, METH_VARARGS,
   "difference(other) -- "
   "Return the difference of the set with another set"},
#endif
#endif
  {NULL,		NULL}		/* sentinel */
};

static PyObject *
BTree_getstate(BTree *self, PyObject *args)
{
  PyObject *r=0, *item;
  int i;

  PER_USE_OR_RETURN(self, NULL);

  UNLESS(r=PyTuple_New(self-&gt;len)) goto err;
  for(i=self-&gt;len; --i &gt;= 0; )
    {
      UNLESS(item=Py_BuildValue(KEY_PARSE "Oi",
				self-&gt;data[i].key, self-&gt;data[i].value,
				self-&gt;data[i].count))
	goto err;
      PyTuple_SET_ITEM(r,i,item);
    }

  PER_ALLOW_DEACTIVATION(self);
  return r;

err:
  PER_ALLOW_DEACTIVATION(self);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.56">static PyObject *
BTree_setstate(BTree *self, PyObject *args)
{
  PyObject *state;
  BTreeItem *d;
  int l, i;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;state)) return NULL;
  if((l=PyTuple_Size(state))&lt;0) return NULL;
 
  PER_PREVENT_DEACTIVATION(self); 

  if (l==0)
    {
      if (_BTree_clear(self) &lt; 0) return NULL;

      PER_ALLOW_DEACTIVATION(self);
      Py_INCREF(Py_None);
      return Py_None;
    }

  if(l&gt;self-&gt;size)
    {
      if(self-&gt;data)
	{
	  UNLESS(d=PyRealloc(self-&gt;data, sizeof(BTreeItem)*l)) goto err;
	  self-&gt;data=d;
	  self-&gt;size=l;
	}
      else
	{
	  UNLESS(self-&gt;data=PyMalloc(sizeof(BTreeItem)*l)) goto err;
	  self-&gt;size=l;
	}
    }
  for(i=self-&gt;len, d=self-&gt;data; --i &gt;= 0; d++)
    {
      DECREF_KEY(d-&gt;key);
      Py_DECREF(d-&gt;value);
    }
  for(self-&gt;len=0, self-&gt;count=0, i=0, d=self-&gt;data; i &lt; l;
      i++, d++, self-&gt;len++)
    {
      UNLESS(PyArg_ParseTuple(PyTuple_GET_ITEM(state,i),
			      KEY_PARSE "Oi",
			      &amp;(d-&gt;key), &amp;(d-&gt;value), &amp;(d-&gt;count)))
	goto err;
#ifndef INTKEY
      Py_INCREF(d-&gt;key);
#endif
      Py_INCREF(d-&gt;value);
      self-&gt;count+=d-&gt;count;
    }

  PER_ALLOW_DEACTIVATION(self);
  Py_INCREF(Py_None);
  return Py_None;

err:
  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.57">static PyObject *
BTree_elements(BTree *self, PyObject *args, char type)
{
  PyObject *f=0, *l=0;
  int fi, li;

  UNLESS(PyArg_ParseTuple(args,"|OO",&amp;f, &amp;l)) return NULL;

  PER_USE_OR_RETURN(self, NULL);

  if(f &amp;&amp; f != Py_None)
    {
      fi=BTree_index(self, f, 0);
      if(fi==-9) goto err;
    }
  else fi=0;

  if(l)
    {
      li=BTree_index(self, l, 1);
      if(li==-9) goto err;
      li++;
    }
  else li=self-&gt;count;
  
  PER_ALLOW_DEACTIVATION(self);
  return newBTreeItems(self,type,fi,li);

err:
  PER_ALLOW_DEACTIVATION(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.58">static PyObject *
BTree_keys(BTree *self, PyObject *args)
{
  return BTree_elements(self,args,'k');
}
</t>
<t tx="ekr.20040104185809.59">static PyObject *
BTree_values(BTree *self, PyObject *args)
{
  return BTree_elements(self,args,'v');
}
</t>
<t tx="ekr.20040104185809.60">static PyObject *
BTree_items(BTree *self, PyObject *args)
{
  return BTree_elements(self,args,'i');
}
</t>
<t tx="ekr.20040104185809.61">static PyObject *
BTree_has_key(BTree *self, PyObject *args)
{
  PyObject *key;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  return _BTree_get(self, key, 1);
}
</t>
<t tx="ekr.20040104185809.62">static PyObject *
BTree_getm(BTree *self, PyObject *args)
{
  PyObject *key, *d=Py_None, *r;

  UNLESS(PyArg_ParseTuple(args, "O|O", &amp;key, &amp;d)) return NULL;
  if((r=_BTree_get(self, key, 0))) return r;
  PyErr_Clear();
  Py_INCREF(d);
  return d;
}
</t>
<t tx="ekr.20040104185809.63">static struct PyMethodDef BTree_methods[] = {
  {"__getstate__",	(PyCFunction)BTree_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction)BTree_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"has_key",	(PyCFunction)BTree_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"keys",	(PyCFunction)BTree_keys,	METH_VARARGS,
     "keys() -- Return the keys"},
  {"values",	(PyCFunction)BTree_values,	METH_VARARGS,
     "values() -- Return the values"},
  {"items",	(PyCFunction)BTree_items,	METH_VARARGS,
     "items() -- Return the items"},
  {"clear",	(PyCFunction)BTree_clear,	METH_VARARGS,
     "clear() -- Remove all of the items from the BTree"},  
  {"map",	(PyCFunction)BTree_map,	METH_VARARGS,
     "map(keys) -- map a sorted sequence of keys into values\n\n"
     "Invalid keys are skipped"},
  {"get",	(PyCFunction)BTree_getm,	METH_VARARGS,
   "get(key[,default]) -- Look up a value\n\n"
   "Return the default (or None) if the key is not found."
  },
#ifdef PERSISTENT
  {"_p___reinit__",	(PyCFunction)BTree__p___reinit__,	METH_VARARGS,
   "_p___reinit__() -- Reinitialize from a newly created copy"},
  {"_p_deactivate",	(PyCFunction)BTree__p___reinit__,	METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
  {NULL,		NULL}		/* sentinel */
};

static void
Bucket_dealloc(Bucket *self)
{
  int i;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;data[i].key);
      DECREF_VALUE(self-&gt;data[i].value);
    }
  free(self-&gt;data);
  PER_DEL(self);

  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.64">static void
BTree_dealloc(BTree *self)
{
  int i;

  for(i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;data[i].key);
      Py_DECREF(self-&gt;data[i].value);
    }
  free(self-&gt;data);
  PER_DEL(self);

  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.65">@ Code to access Bucket objects as mappings
@c

static int
Bucket_length( Bucket *self)
{
  int r;
  PER_USE_OR_RETURN(self, -1);
  r=self-&gt;len;
  PER_ALLOW_DEACTIVATION(self);
  return r;
}
</t>
<t tx="ekr.20040104185809.66">static PyMappingMethods Bucket_as_mapping = {
  (inquiry)Bucket_length,		/*mp_length*/
  (binaryfunc)bucket_get,		/*mp_subscript*/
  (objobjargproc)bucket_setitem,	/*mp_ass_subscript*/
};

static int
BTree_length( BTree *self)
{
  int r;
  PER_USE_OR_RETURN(self, -1);
  r=self-&gt;count;
  PER_ALLOW_DEACTIVATION(self);
  return r;
}
</t>
<t tx="ekr.20040104185809.67">static PyMappingMethods BTree_as_mapping = {
  (inquiry)BTree_length,		/*mp_length*/
  (binaryfunc)BTree_get,		/*mp_subscript*/
  (objobjargproc)BTree_setitem,	/*mp_ass_subscript*/
};

static PyObject *
bucket_repr(Bucket *self)
{
  static PyObject *format;
  PyObject *r, *t;

  UNLESS(format) UNLESS(format=PyString_FromString("Bucket(%s)")) return NULL;
  UNLESS(t=PyTuple_New(1)) return NULL;
  UNLESS(r=bucket_items(self,NULL)) goto err;
  PyTuple_SET_ITEM(t,0,r);
  r=t;
  ASSIGN(r,PyString_Format(format,r));
  return r;
err:
  Py_DECREF(t);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.68">static PyExtensionClass BucketType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "Bucket",			/*tp_name*/
  sizeof(Bucket),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /*********** methods ***********************/
  (destructor)Bucket_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)bucket_repr,	/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  &amp;Bucket_as_mapping,		/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,		/*tp_getattro*/
  0,				/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Mapping type implemented as sorted list of items", 
  METHOD_CHAIN(Bucket_methods),
  EXTENSIONCLASS_BASICNEW_FLAG | PERSISTENT_TYPE_FLAG,
};

static PyExtensionClass BTreeType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "BTree",			/*tp_name*/
  sizeof(BTree),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /************* methods ********************/
  (destructor)BTree_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)0,			/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  &amp;BTree_as_mapping,		/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,
  0,				/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Mapping type implemented as sorted list of items", 
  METHOD_CHAIN(BTree_methods),
  PERSISTENCE_FLAGS,
};

static struct PyMethodDef module_methods[] = {
  {NULL,		NULL}		/* sentinel */
};

void
#ifdef INTKEY
#ifdef INTVAL
initIIBTree(void)
#define MODNAME "IIBTree"
#else
initIOBTree(void)
#define MODNAME "IOBTree"
#endif
#else
#ifdef INTVAL
initOIBTree(void)
#define MODNAME "OIBTree"
#else
initBTree(void)
#define MODNAME "BTree"
#endif
#endif
{
  PyObject *m, *d;

  UNLESS(PyExtensionClassCAPI=PyCObject_Import("ExtensionClass","CAPI"))
      return;

#ifdef PERSISTENT
  if((cPersistenceCAPI=PyCObject_Import("cPersistence","CAPI")))
    {
	BucketType.methods.link=cPersistenceCAPI-&gt;methods;
	BucketType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	BucketType.tp_setattro=cPersistenceCAPI-&gt;setattro;

	BTreeType.methods.link=cPersistenceCAPI-&gt;methods;
	BTreeType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	BTreeType.tp_setattro=cPersistenceCAPI-&gt;setattro;
    }
  else return;
#else
  BucketType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
  BTreeType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
#endif

  BTreeItemsType.ob_type=&amp;PyType_Type;

#ifdef INTKEY
#ifdef INTVAL
  UNLESS(d = PyImport_ImportModule("intSet")) return;
  UNLESS(intSetType = PyObject_GetAttrString (d, "intSet")) return;
  Py_DECREF (d); 
#endif
#endif
 

  /* Create the module and add the functions */
  m = Py_InitModule4(MODNAME, module_methods,
		     BTree_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,"Bucket",BucketType);
  PyExtensionClass_Export(d,"BTree",BTreeType);

  /* Check for errors */
  if (PyErr_Occurred())
    Py_FatalError("can't initialize module BTree");
}
</t>
<t tx="ekr.20040104185809.69">@language c

&lt;&lt; c copyright &gt;&gt;

/* $Id: IOBTree.c,v 1.8 2002/08/01 20:02:01 bwarsaw Exp $ */

#define INTKEY int

#include "BTree.c"
</t>
<t tx="ekr.20040104185809.71">@language c

&lt;&lt; c copyright &gt;&gt;

/* $Id: OIBTree.c,v 1.8 2002/08/01 20:02:01 bwarsaw Exp $ */

#define INTVAL int

#include "BTree.c"

</t>
<t tx="ekr.20040104185809.73">@language c

&lt;&lt; c copyright &gt;&gt;

static char intSet_module_documentation[] = 
""
"\n$Id: intSet.c,v 1.23.32.1 2003/01/06 16:58:34 chrisw Exp $"
;

#include &lt;limits.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include "cPersistence.h"

&lt;&lt; intSet declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185809.75">#define UNLESS(E) if(!(E))
#define RETURN_NONE Py_INCREF(Py_None); return Py_None

#define MIN_INTSET_ALLOC 8

#define INTSET_DATA_TYPE int
#define INTSET_DATA_FLAG "l"

typedef struct {
  cPersistent_HEAD
  int size, len;
  INTSET_DATA_TYPE *data;
} intSet;


staticforward PyExtensionClass intSetType;</t>
<t tx="ekr.20040104185809.76">#define OBJECT(O) ((PyObject*)(O))
#define INTSET(O) ((intSet*)(O))

/* We want to be sticky most of the time */
#define PER_RETURN(O,R) R
#define PER_INT_RETURN(O,R) R
#undef PER_ALLOW_DEACTIVATION
#define PER_ALLOW_DEACTIVATION(O)

static PyObject *
intSet_has_key(intSet *self, PyObject *args)
{
  int min, max, i, l;
  INTSET_DATA_TYPE k, key;

  UNLESS(PyArg_ParseTuple(args,INTSET_DATA_FLAG,&amp;key)) return NULL;

  PER_USE_OR_RETURN(self, NULL);
  
  for(min=0, max=self-&gt;len, i=max/2, l=max; i != l; l=i, i=(min+max)/2)
    {
      k=self-&gt;data[i];
      if(k == key) return PER_RETURN(self, PyInt_FromLong(1));
      if(k &gt; key) max=i;
      else min=i;
    }
  return PER_RETURN(self, PyInt_FromLong(0));
}
</t>
<t tx="ekr.20040104185809.77">static int
intSet_grow(intSet *self, int l)
{
  int g;
  INTSET_DATA_TYPE *data;

  if(self-&gt;data)
    {
      g=self-&gt;size*2;
      if(g &lt; l) g=l;
      UNLESS(data=realloc(self-&gt;data, sizeof(INTSET_DATA_TYPE)*g))
	{
	  PyErr_NoMemory();
	  return -1;
	}
      self-&gt;data=data;
      self-&gt;size=g;
    }
  else
    {
      g=l &lt; MIN_INTSET_ALLOC ? MIN_INTSET_ALLOC : l;
      UNLESS(self-&gt;data=malloc(sizeof(INTSET_DATA_TYPE)*g))
	{
	  PyErr_NoMemory();
	  return -1;
	}
      self-&gt;size=g;
    }
  return 0;
}</t>
<t tx="ekr.20040104185809.78">static INTSET_DATA_TYPE
intSet_modify(intSet *self, INTSET_DATA_TYPE ikey, int add)
{
  int min, max, i, l;
  INTSET_DATA_TYPE *data, k;
  
  PER_USE_OR_RETURN(self, -1);

  data=self-&gt;data;

  for(min=0, max=self-&gt;len, i=max/2, l=max; i != l; l=i, i=(min+max)/2)
    {
      k=data[i];
      if(k == ikey) 
	{
	  if(! add)
	    {
	      data+=i;
	      self-&gt;len--;
	      if(i &lt; (self-&gt;len))
		memmove(data, data+1, (self-&gt;len-i)*sizeof(INTSET_DATA_TYPE));
	      if(PER_CHANGED(self) &lt; 0) return PER_INT_RETURN(self, -1);
	    }

	  return PER_INT_RETURN(self, 0);
	}
      if(k &gt; ikey) max=i;
      else min=i;
    }
  if(!add) return PER_INT_RETURN(self, 0);
  if(self-&gt;len &gt;= self-&gt;size &amp;&amp; intSet_grow(self,self-&gt;len+1) &lt; 0)
    return PER_INT_RETURN(self, -1);
  if(max != i) i++;
  data=self-&gt;data+i;
  if(self-&gt;len &gt; i)
    memmove(data+1,data,(self-&gt;len-i)*sizeof(INTSET_DATA_TYPE));
  *data=ikey;
  self-&gt;len++;
  if(PER_CHANGED(self) &lt; 0) return PER_INT_RETURN(self, -1);
  return PER_INT_RETURN(self, ikey);
}
</t>
<t tx="ekr.20040104185809.79">static PyObject *
intSet_insert(intSet *self, PyObject *args)
{
  INTSET_DATA_TYPE key;

  UNLESS(PyArg_ParseTuple(args,INTSET_DATA_FLAG,&amp;key)) return NULL;

  if(intSet_modify(self, key, 1) &lt; 0) return NULL;
  RETURN_NONE;
}
</t>
<t tx="ekr.20040104185809.80">static PyObject *
intSet_remove(intSet *self, PyObject *args)
{
  INTSET_DATA_TYPE key;

  UNLESS(PyArg_ParseTuple(args,INTSET_DATA_FLAG,&amp;key)) return NULL;

  if(intSet_modify(self, key, 0) &lt; 0) return NULL;
  RETURN_NONE;
}
</t>
<t tx="ekr.20040104185809.81">static PyObject *
intSet_clear(intSet *self, PyObject *args)
{
  self-&gt;len=0;
  if(PER_CHANGED(self) &lt; 0) return PER_RETURN(self, NULL);
  RETURN_NONE;
}
</t>
<t tx="ekr.20040104185809.82">static PyObject *
intSet___getstate__(intSet *self, PyObject *args)
{
  PyObject *r=0;
  int i, l;
  char *c;
  INTSET_DATA_TYPE *d;

  PER_USE_OR_RETURN(self, NULL);

  l=self-&gt;len;
  UNLESS(r=PyString_FromStringAndSize(NULL,l*4)) goto err;
  UNLESS(c=PyString_AsString(r)) goto err;
  d=self-&gt;data;
  for(i=0; i &lt; l; i++, d++)
    {
      *c++ = (int)( *d        &amp; 0xff);
      *c++ = (int)((*d &gt;&gt; 8)  &amp; 0xff);
      *c++ = (int)((*d &gt;&gt; 16) &amp; 0xff);
      *c++ = (int)((*d &gt;&gt; 24) &amp; 0xff);
    }
  
  return PER_RETURN(self, r);

err:
  Py_DECREF(r);
  return PER_RETURN(self, NULL);
}
</t>
<t tx="ekr.20040104185809.83">static PyObject *
intSet___setstate__(intSet *self, PyObject *args)
{
  PyObject *data;
  int i, l, v;
  char *c;

  PER_PREVENT_DEACTIVATION(self); 

  UNLESS(PyArg_ParseTuple(args,"O",&amp;data)) return PER_RETURN(self, NULL);
  UNLESS(c=PyString_AsString(data)) return PER_RETURN(self, NULL);

  if((l=PyString_Size(data)) &lt; 0) return PER_RETURN(self, NULL);
  l/=4;

  intSet_clear(self, NULL);
  if(l &gt; self-&gt;size &amp;&amp; intSet_grow(self,l) &lt; 0)
    return PER_RETURN(self, NULL);

  PyErr_Clear();

  for(i=0; i &lt; l; i++)
    {
      v  = ((int)(unsigned char)*c++)      ;
      v |= ((int)(unsigned char)*c++) &lt;&lt;  8;
      v |= ((int)(unsigned char)*c++) &lt;&lt; 16;
      v |= ((int)(unsigned char)*c++) &lt;&lt; 24;
      self-&gt;data[i]=v;
    }

  self-&gt;len=l;

  Py_INCREF(Py_None);
  return PER_RETURN(self, Py_None);
}
</t>
<t tx="ekr.20040104185809.84">static PyObject *
intSet_set_operation(intSet *self, PyObject *other,
		     int cpysrc, int cpyboth, int cpyoth)
{
  intSet *r=0, *o;
  int i, l, io, lo;
  INTSET_DATA_TYPE *d, *od, v, vo;
  
  if(other-&gt;ob_type != self-&gt;ob_type)
    {
      PyErr_SetString(PyExc_TypeError,
		      "intSet set operations require same-type operands");
      return NULL;
    }
  o=INTSET(other);

  PER_USE_OR_RETURN(self, NULL);
  PER_USE_OR_RETURN((intSet*)other, NULL);

  od=o-&gt;data;

  d=self-&gt;data;

  UNLESS(r=INTSET(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL)))
    goto err;

  for(i=0, l=self-&gt;len, io=0, lo=o-&gt;len; i &lt; l &amp;&amp; io &lt; lo; )
    {
      v=d[i];
      vo=od[io];
      if(v &lt; vo)
	{
	  if(cpysrc)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; intSet_grow(r,0) &lt; 0) goto err;
	      r-&gt;data[r-&gt;len]=v;
	      r-&gt;len++;
	    }
	  i++;
	}
      else if(v==vo)
	{
	  if(cpyboth)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; intSet_grow(r,0) &lt; 0) goto err;
	      r-&gt;data[r-&gt;len]=v;
	      r-&gt;len++;
	    }
	  i++;
	  io++;
	}
      else
	{
	  if(cpyoth)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; intSet_grow(r,0) &lt; 0) goto err;
	      r-&gt;data[r-&gt;len]=vo;
	      r-&gt;len++;
	    }
	  io++;
	}
    }
  if(cpysrc &amp;&amp; i &lt; l)
    {
      l-=i;
      if(r-&gt;len+l &gt; r-&gt;size &amp;&amp; intSet_grow(r,r-&gt;len+l) &lt; 0) goto err;
      memcpy(r-&gt;data+r-&gt;len, d+i, l*sizeof(INTSET_DATA_TYPE));
      r-&gt;len += l;
    }
  else if(cpyoth &amp;&amp; io &lt; lo)
    {
      lo-=io;
      if(r-&gt;len+lo &gt; r-&gt;size &amp;&amp; intSet_grow(r,r-&gt;len+lo) &lt; 0) goto err;
      memcpy(r-&gt;data+r-&gt;len, od+io, lo*sizeof(INTSET_DATA_TYPE));
      r-&gt;len += lo;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(o);
  return OBJECT(r);

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ALLOW_DEACTIVATION(o);
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.85">static PyObject *
intSet_add(intSet *self, PyObject *other)
{
  return intSet_set_operation(self,other,1,1,1);
}
</t>
<t tx="ekr.20040104185809.86">static PyObject *
intSet_union(intSet *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return intSet_set_operation(self,other,1,1,1);
}
</t>
<t tx="ekr.20040104185809.87">static PyObject *
intSet_intersection(intSet *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return intSet_set_operation(self,other,0,1,0);
}
</t>
<t tx="ekr.20040104185809.88">static PyObject *
intSet_difference(intSet *self, PyObject *args)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return intSet_set_operation(self,other,1,0,0);
}
</t>
<t tx="ekr.20040104185809.89">static PyObject *
intSet__p___reinit__(intSet *self, PyObject *args)
{
  PyObject *dict;

  if(self-&gt;state==cPersistent_UPTODATE_STATE 
     &amp;&amp; HasInstDict(self) &amp;&amp; (dict=INSTANCE_DICT(self)))
    {
      PyDict_Clear(dict);
    }

  PER_GHOSTIFY(self);
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.90">static struct PyMethodDef intSet_methods[] = {
  {"has_key",	(PyCFunction)intSet_has_key,	METH_VARARGS,
   "has_key(id) -- Test whether the set has the given id"},
  {"insert",	(PyCFunction)intSet_insert,	METH_VARARGS,
   "insert(id,[ignored]) -- Add an id to the set"},
  {"remove",	(PyCFunction)intSet_remove,	METH_VARARGS,
   "remove(id) -- Remove an id from the set"},
  {"clear",	(PyCFunction)intSet_clear,	METH_VARARGS,
   "clear() -- Remove all of the ids from the set"},
  {"union",	(PyCFunction)intSet_union,	METH_VARARGS,
   "union(other) -- Return the union of the set with another set"},
  {"intersection",	(PyCFunction)intSet_intersection, METH_VARARGS,
   "intersection(other) -- "
   "Return the intersection of the set with another set"},
  {"difference",	(PyCFunction)intSet_difference,	METH_VARARGS,
   "difference(other) -- Return the difference of the set with another set"
  },
  {"__getstate__",	(PyCFunction)intSet___getstate__, METH_VARARGS,
   "__getstate__() -- get the persistent state"},  	 
  {"__setstate__",	(PyCFunction)intSet___setstate__, METH_VARARGS,
   "__setstate__() -- set the persistent state"},  	 
  {"_p___reinit__",	(PyCFunction)intSet__p___reinit__, METH_VARARGS,
   "_p___reinit__(oid,jar,copy) -- Reinitialize from a newly created copy"},
  {"_p_deactivate",	(PyCFunction)intSet__p___reinit__, METH_VARARGS,
   "_p_deactivate(oid,jar,copy) -- Reinitialize from a newly created copy"},
  {NULL,		NULL}		/* sentinel */
};

static void
intSet_dealloc(intSet *self)
{
  free(self-&gt;data);
  PER_DEL(self);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.91">static PyObject *
intSet_getattr(intSet *self, PyObject *name)
{
  return Py_FindAttr((PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185809.92">@ Code to handle accessing intSet objects as sequence objects
@c

static int
intSet_length(intSet *self)
{
  PER_USE_OR_RETURN(self,-1);
  return PER_INT_RETURN(self,self-&gt;len);
}
</t>
<t tx="ekr.20040104185809.93">static PyObject *
intSet_repeat(intSet *self, int n)
{
  PyErr_SetString(PyExc_TypeError,
		  "intSet objects do not support repetition");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.94">static PyObject *
intSet_item(intSet *self, int i)
{
  PyObject *e;

  PER_USE_OR_RETURN(self,NULL);

  if(i &gt;= 0 &amp;&amp; i &lt; self-&gt;len)
    return PER_RETURN(self,PyInt_FromLong(self-&gt;data[i]));
  UNLESS(e=PyInt_FromLong(i)) goto err;
  PyErr_SetObject(PyExc_IndexError, e);
  Py_DECREF(e);
err:
  PER_ALLOW_DEACTIVATION(self)
  return NULL;
}
</t>
<t tx="ekr.20040104185809.95">static PyObject *
intSet_slice(intSet *self, int ilow, int ihigh)
{
  PyErr_SetString(PyExc_TypeError,
		  "intSet objects do not support slicing");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.96">static int
intSet_ass_item(intSet *self, int i, PyObject *v)
{
  PyErr_SetString(PyExc_TypeError,
		  "intSet objects do not support item assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185809.97">static int
intSet_ass_slice(PyListObject *self, int ilow, int ihigh, PyObject *v)
{
  PyErr_SetString(PyExc_TypeError,
		  "intSet objects do not support slice assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185809.98">static PySequenceMethods intSet_as_sequence = {
	(inquiry)intSet_length,		/*sq_length*/
	(binaryfunc)intSet_add,		/*sq_concat*/
	(intargfunc)intSet_repeat,		/*sq_repeat*/
	(intargfunc)intSet_item,		/*sq_item*/
	(intintargfunc)intSet_slice,		/*sq_slice*/
	(intobjargproc)intSet_ass_item,	/*sq_ass_item*/
	(intintobjargproc)intSet_ass_slice,	/*sq_ass_slice*/
};

static PyExtensionClass intSetType = {
  PyObject_HEAD_INIT(NULL)
  0,			/*ob_size*/
  "intSet",		/*tp_name*/
  sizeof(intSet),	/*tp_basicsize*/
  0,			/*tp_itemsize*/
  /* methods */
  (destructor)intSet_dealloc,	/*tp_dealloc*/
  (printfunc)0,		/*tp_print*/
  (getattrfunc)0,	/*obsolete tp_getattr*/
  (setattrfunc)0,	/*obsolete tp_setattr*/
  (cmpfunc)0,		/*tp_compare*/
  (reprfunc)0,		/*tp_repr*/
  0,			/*tp_as_number*/
  &amp;intSet_as_sequence,	/*tp_as_sequence*/
  0,			/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,	/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  (getattrofunc)intSet_getattr,			/*tp_getattro*/
  0,			/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "A set of integers", 
  METHOD_CHAIN(intSet_methods),
  PERSISTENCE_FLAGS,
};

static struct PyMethodDef module_methods[] = {
  {NULL,		NULL}		/* sentinel */
};

void
initintSet(void)
{
  PyObject *m, *d;

  UNLESS(ExtensionClassImported) return;

  if((cPersistenceCAPI=PyCObject_Import("cPersistence","CAPI")))
    {
      intSetType.methods.link=cPersistenceCAPI-&gt;methods;
      intSetType.tp_getattro=cPersistenceCAPI-&gt;getattro;
      intSetType.tp_setattro=cPersistenceCAPI-&gt;setattro;
    }
  else return;

  /* Create the module and add the functions */
  m = Py_InitModule4("intSet", module_methods,
		     intSet_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,"intSet",intSetType);

  /* Check for errors */
  if (PyErr_Occurred())
    Py_FatalError("can't initialize module intSet");
}
</t>
<t tx="ekr.20040104185809.99"></t>
<t tx="ekr.20040104185809.100">@nocolor

Zope Public License (ZPL) Version 2.0
-----------------------------------------------

This software is Copyright (c) Zope Corporation (tm) and
Contributors. All rights reserved.

This license has been certified as open source. It has also
been designated as GPL compatible by the Free Software
Foundation (FSF).

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:

1. Redistributions in source code must retain the above
   copyright notice, this list of conditions, and the following
   disclaimer.

2. Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions, and the following
   disclaimer in the documentation and/or other materials
   provided with the distribution.

3. The name Zope Corporation (tm) must not be used to
   endorse or promote products derived from this software
   without prior written permission from Zope Corporation.

4. The right to distribute this software or to use it for
   any purpose does not give you the right to use Servicemarks
   (sm) or Trademarks (tm) of Zope Corporation. Use of them is
   covered in a separate agreement (see
   http://www.zope.com/Marks).

5. If any files are modified, you must cause the modified
   files to carry prominent notices stating that you changed
   the files and the date of any change.

Disclaimer

  THIS SOFTWARE IS PROVIDED BY ZOPE CORPORATION ``AS IS''
  AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
  NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
  NO EVENT SHALL ZOPE CORPORATION OR ITS CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.

This software consists of contributions made by Zope
Corporation and many individuals on behalf of Zope
Corporation.  Specific attributions are listed in the
accompanying credits file.</t>
<t tx="ekr.20040104185809.101"># Compatibility module
# $Id: Xaq.py,v 1.1 1997/06/19 19:26:30 jim Exp $

import Acquisition

Acquirer = Acquisition.Explicit
</t>
<t tx="ekr.20040104185809.102">#!/usr/bin/env python

&lt;&lt; copyright &gt;&gt;

"""Support for Python classes implemented in C

A lightweight mechanism has been developed for making Python
extension types more class-like.  Classes can be developed in an
extension language, such as C or C++, and these classes can be
treated like other python classes:

- They can be sub-classed in python,

- They provide access to method documentation strings, and

- They can be used to directly create new instances.

An example class shows how extension classes are implemented and how
they differ from extension types.

Extension classes provide additional extensions to class and
instance semantics, including:

- A protocol for accessing subobjects "in the context of" their
  containers.  This is used to implement custom method types
  and "environmental acquisition":Acquisition.html.

- A protocol for overriding method call semantics.  This is used
  to implement "synchonized" classes and could be used to
  implement argument type checking.

- A protocol for class initialization that supports execution of a
  special '__class_init__' method after a class has been
  initialized.

Extension classes illustrate how the Python class mechanism can be
extended and may provide a basis for improved or specialized class
models.
"""

# Setup file for ExtensionClass
# setup.py contributed by A.M. Kuchling &lt;amk1@bigfoot.com&gt;

from distutils.core import setup
from distutils.extension import Extension

ExtensionClass = Extension(name = 'ExtensionClass',
                           sources = ['src/ExtensionClass.c'])

Acquisition = Extension(name = 'Acquisition',
                        sources = ['src/Acquisition.c'])

ComputedAttribute = Extension(name = 'ComputedAttribute',
                              sources = ['src/ComputedAttribute.c'])

MethodObject = Extension(name = 'MethodObject',
                         sources = ['src/MethodObject.c'])

Missing = Extension(name = 'Missing',
                    sources = ['src/Missing.c'])

MultiMapping = Extension(name = 'MultiMapping',
                         sources = ['src/MultiMapping.c'])

Record = Extension(name = 'Record', sources = ['src/Record.c'])

Sync = Extension(name = 'Sync', sources = ['src/Sync.c'])

ThreadLock = Extension(name = 'ThreadLock',
                       sources = ['src/ThreadLock.c'])

setup(name = "ExtensionClass",
      version = "1.3",
      description = "Support for Python classes implemented in C",
      maintainer = "Zope Corporation",
      maintainer_email = "zodb-dev@zope.org",
      url = "http://www.zope.com",

      ext_modules = [ExtensionClass, Acquisition, ComputedAttribute,
                     MethodObject, Missing, MultiMapping, Sync,
                     ThreadLock, Record],
      headers = ["src/ExtensionClass.h"],

      long_description=__doc__
      )
</t>
<t tx="ekr.20040104185809.103">@language html</t>
<t tx="ekr.20040104185809.104">&lt;h1&gt;Acquisition&lt;/h1&gt;
&lt;p&gt;  &lt;a href="COPYRIGHT.html"&gt;Copyright (C) 1996-1998, Digital Creations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;  Acquisition &lt;a href="#1"&gt;[1]&lt;/a&gt; is a mechanism that allows objects to obtain
  attributes from their environment.  It is similar to inheritence,
  except that, rather than traversing an inheritence hierarchy
  to obtain attributes, a containment hierarchy is traversed.&lt;/p&gt;

&lt;p&gt;  The &lt;a href="ExtensionClass.html"&gt;ExtensionClass&lt;/a&gt;. release includes mix-in
  extension base classes that can be used to add acquisition as a
  feature to extension subclasses.  These mix-in classes use the
  context-wrapping feature of ExtensionClasses to implement
  acquisition. Consider the following example:&lt;/p&gt;
&lt;PRE&gt;
    import ExtensionClass, Acquisition

    class C(ExtensionClass.Base):
      color='red'

    class A(Acquisition.Implicit):

      def report(self):
        print self.color

    a=A()
    c=C()
    c.a=A()

    c.a.report() # prints 'red'

    d=C()
    d.color='green'
    d.a=a

    d.a.report() # prints 'green'

    a.report() # raises an attribute error

&lt;/PRE&gt;

&lt;p&gt;  The class &lt;code&gt;A&lt;/code&gt; inherits acquisition behavior from
  &lt;code&gt;Acquisition.Implicit&lt;/code&gt;.  The object, &lt;code&gt;a&lt;/code&gt;, "has" the color of
  objects &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; when it is accessed through them, but it
  has no color by itself.  The object &lt;code&gt;a&lt;/code&gt; obtains attributes
  from it's environment, where it's environment is defined by
  the access path used to reach &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Acquisition wrappers&lt;/h2&gt;
&lt;p&gt;    When an object that supports acquisition is accessed through
    an extension class instance, a special object, called an
    acquisition wrapper, is returned.  In the example above, the
    expression &lt;code&gt;c.a&lt;/code&gt; returns an acquisition wrapper that
    contains references to both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;.  It is this wrapper
    that performs attribute lookup in &lt;code&gt;c&lt;/code&gt; when an attribute
    cannot be found in &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;    Aquisition wrappers provide access to the wrapped objects
    through the attributes &lt;code&gt;aq_parent&lt;/code&gt;, &lt;code&gt;aq_self&lt;/code&gt;, &lt;code&gt;aq_base&lt;/code&gt;.  
    In the example above, the expressions:&lt;/p&gt;
&lt;PRE&gt;
       'c.a.aq_parent is c'

&lt;/PRE&gt;

&lt;p&gt;    and:&lt;/p&gt;
&lt;PRE&gt;
       'c.a.aq_self is a'

&lt;/PRE&gt;

&lt;p&gt;    both evaluate to true, but the expression:&lt;/p&gt;
&lt;PRE&gt;
       'c.a is a'

&lt;/PRE&gt;

&lt;p&gt;    evaluates to false, because the expression &lt;code&gt;c.a&lt;/code&gt; evaluates
    to an acquisition wrapper around &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, not &lt;code&gt;a&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;    The attribute &lt;code&gt;aq_base&lt;/code&gt; is similar to &lt;code&gt;aq_self&lt;/code&gt;.  Wrappers may be
    nested and &lt;code&gt;aq_self&lt;/code&gt; may be a wrapped object.  The &lt;code&gt;aq_base&lt;/code&gt;
    attribute is the underlying object with all wrappers removed.&lt;/p&gt;


&lt;h2&gt;Acquisition Control&lt;/h2&gt;
&lt;p&gt;    Two styles of acquisition are supported in the current
    ExtensionClass release, implicit and explicit aquisition.&lt;/p&gt;

&lt;h3&gt;Implicit acquisition&lt;/h3&gt;
&lt;p&gt;      Implicit acquisition is so named because it searches for
      attributes from the environment automatically whenever an
      attribute cannot be obtained directly from an object or
      through inheritence.&lt;/p&gt;

&lt;p&gt;      An attribute may be implicitly acquired if it's name does
      not begin with an underscore, &lt;code&gt;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;      To support implicit acquisition, an object should inherit
      from the mix-in class &lt;code&gt;Acquisition.Implicit&lt;/code&gt;.&lt;/p&gt;


&lt;h3&gt;Explicit Acquisition&lt;/h3&gt;
&lt;p&gt;      When explicit acquisition is used, attributes are not
      automatically obtained from the environment.  Instead, the
      method &lt;code&gt;aq_aquire&lt;/code&gt; must be used, as in:&lt;/p&gt;
&lt;PRE&gt;
        print c.a.aq_acquire('color')

&lt;/PRE&gt;

&lt;p&gt;      To support explicit acquisition, an object should inherit
      from the mix-in class &lt;code&gt;Acquisition.Explicit&lt;/code&gt;.&lt;/p&gt;


&lt;h3&gt;Controlled Acquisition&lt;/h3&gt;
&lt;p&gt;      A class (or instance) can provide attribute by attribute control
      over acquisition.  This is done by:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;subclassing from &lt;code&gt;Acquisition.Explicit&lt;/code&gt;, and&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setting all attributes that should be acquired to the special
        value: &lt;code&gt;Acquisition.Acquired&lt;/code&gt;.  Setting an attribute to this
        value also allows inherited attributes to be overridden with
        acquired ones.&lt;/p&gt;
&lt;p&gt;        For example, in:&lt;/p&gt;
&lt;PRE&gt;
          class C(Acquisition.Explicit):
             id=1
             secret=2
             color=Acquisition.Acquired
             __roles__=Acquisition.Acquired

&lt;/PRE&gt;

&lt;p&gt;        The &lt;em&gt;only&lt;/em&gt; attributes that are automatically acquired from
        containing objects are &lt;code&gt;color&lt;/code&gt;, and &lt;code&gt;__roles__&lt;/code&gt;.  Note also
        that the &lt;code&gt;__roles__&lt;/code&gt; attribute is acquired even though it's
        name begins with an underscore.  In fact, the special
        &lt;code&gt;Acquisition.Acquired&lt;/code&gt; value can be used in
        &lt;code&gt;Acquisition.Implicit&lt;/code&gt; objects to implicitly acquire selected
        objects that smell like private objects.&lt;/p&gt;


&lt;/li&gt;&lt;/ul&gt;

&lt;h3&gt;Filtered Acquisition&lt;/h3&gt;
&lt;p&gt;      The acquisition method, &lt;code&gt;aq_acquire&lt;/code&gt;, accepts two optional
      arguments. The first of the additional arguments is a
      "filtering" function that is used when considering whether to
      acquire an object.  The second of the additional arguments is an
      object that is passed as extra data when calling the filtering
      function and which defaults to &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;      The filter function is called with five arguments:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;The object that the &lt;code&gt;aq_acquire&lt;/code&gt; method was called on,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The object where an object was found,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The name of the object, as passed to &lt;code&gt;aq_acquire&lt;/code&gt;,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The object found, and&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The extra data passed to &lt;code&gt;aq_acquire&lt;/code&gt;.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;      If the filter returns a true object that the object found is
      returned, otherwise, the acquisition search continues.&lt;/p&gt;

&lt;p&gt;      For example, in:&lt;/p&gt;
&lt;PRE&gt;
        from Acquisition import Explicit

        class HandyForTesting:
            def __init__(self, name): self.name=name
            def __str__(self):
                return &amp;quot;%s(%s)&amp;quot; % (self.name, self.__class__.__name__)
            __repr__=__str__

        class E(Explicit, HandyForTesting): pass

        class Nice(HandyForTesting):
            isNice=1
            def __str__(self):
                return HandyForTesting.__str__(self)+' and I am nice!'
            __repr__=__str__

        a=E('a')
        a.b=E('b')
        a.b.c=E('c')
        a.p=Nice('spam')
        a.b.p=E('p')

        def find_nice(self, ancestor, name, object, extra):
            return hasattr(object,'isNice') and object.isNice

        print a.b.c.aq_acquire('p', find_nice)

&lt;/PRE&gt;

&lt;p&gt;      The filtered acquisition in the last line skips over the first
      attribute it finds with the name &lt;code&gt;p&lt;/code&gt;, because the attribute
      doesn't satisfy the condition given in the filter. The output of
      the last line is:&lt;/p&gt;
&lt;PRE&gt;
        spam(Nice) and I am nice!

&lt;/PRE&gt;



&lt;h2&gt;Acquisition and methods&lt;/h2&gt;
&lt;p&gt;    Python methods of objects that support acquisition can use
    acquired attributes as in the &lt;code&gt;report&lt;/code&gt; method of the first example
    above.  When a Python method is called on an object that is
    wrapped by an acquisition wrapper, the wrapper is passed to the
    method as the first argument.  This rule also applies to
    user-defined method types and to C methods defined in pure mix-in
    classes.&lt;/p&gt;

&lt;p&gt;    Unfortunately, C methods defined in extension base classes that
    define their own data structures, cannot use aquired attributes at
    this time.  This is because wrapper objects do not conform to the
    data structures expected by these methods.&lt;/p&gt;


&lt;h2&gt;Acquiring Acquiring objects&lt;/h2&gt;
&lt;p&gt;    Consider the following example:&lt;/p&gt;
&lt;PRE&gt;
      from Acquisition import Implicit

      class C(Implicit):
          def __init__(self, name): self.name=name
          def __str__(self):
              return &amp;quot;%s(%s)&amp;quot; % (self.name, self.__class__.__name__)
          __repr__=__str__

      a=C(&amp;quot;a&amp;quot;)
      a.b=C(&amp;quot;b&amp;quot;)
      a.b.pref=&amp;quot;spam&amp;quot;
      a.b.c=C(&amp;quot;c&amp;quot;)
      a.b.c.color=&amp;quot;red&amp;quot;
      a.b.c.pref=&amp;quot;eggs&amp;quot;
      a.x=C(&amp;quot;x&amp;quot;)

      o=a.b.c.x

&lt;/PRE&gt;

&lt;p&gt;    The expression &lt;code&gt;o.color&lt;/code&gt; might be expected to return &lt;code&gt;"red"&lt;/code&gt;. In
    earlier versions of ExtensionClass, however, this expression
    failed.  Acquired acquiring objects did not acquire from the
    environment they were accessed in, because objects were only
    wrapped when they were first found, and were not rewrapped as they
    were passed down the acquisition tree.&lt;/p&gt;

&lt;p&gt;    In the current release of ExtensionClass, the expression "o.color"
    does indeed return &lt;code&gt;"red"&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;    When searching for an attribute in &lt;code&gt;o&lt;/code&gt;, objects are searched in
    the order &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. So, for example, the expression,
    &lt;code&gt;o.pref&lt;/code&gt; returns &lt;code&gt;"spam"&lt;/code&gt;, not &lt;code&gt;"eggs"&lt;/code&gt;.  In earlier releases of
    ExtensionClass, the attempt to get the &lt;code&gt;pref&lt;/code&gt; attribute from &lt;code&gt;o&lt;/code&gt;
    would have failed.&lt;/p&gt;

&lt;p&gt;    If desired, the current rules for looking up attributes in complex
    expressions can best be understood through repeated application of
    the &lt;code&gt;__of__&lt;/code&gt; method:&lt;/p&gt;

&lt;dl&gt;&lt;dt&gt;    &lt;code&gt;a.x&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;code&gt;x.__of__(a)&lt;/code&gt;&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;    &lt;code&gt;a.b&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;code&gt;b.__of__(a)&lt;/code&gt;&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;    &lt;code&gt;a.b.x&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;code&gt;x.__of__(a).__of__(b.__of__(a))&lt;/code&gt;&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;    &lt;code&gt;a.b.c&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;code&gt;c.__of__(b.__of__(a))&lt;/code&gt;&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;    &lt;code&gt;a.b.c.x&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;code&gt;x.__of__(a).__of__(b.__of__(a)).__of__(c.__of__(b.__of__(a)))&lt;/code&gt;&lt;/p&gt;

&lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;    and by keeping in mind that attribute lookup in a wrapper
    is done by trying to lookup the attribute in the wrapped object
    first and then in the parent object.  In the expressions above
    involving the &lt;code&gt;__of__&lt;/code&gt; method, lookup proceeds from left to right.&lt;/p&gt;

&lt;p&gt;    Note that heuristics are used to avoid most of the repeated
    lookups. For example, in the expression: &lt;code&gt;a.b.c.x.foo&lt;/code&gt;, the object
    &lt;code&gt;a&lt;/code&gt; is searched no more than once, even though it is wrapped three
    times.&lt;/p&gt;


&lt;p&gt;  &lt;a name="1"&gt;[1]&lt;/a&gt; Gil, J., Lorenz, D., 
   &lt;a href="http://www.bell-labs.com/people/cope/oopsla/Oopsla96TechnicalProgramAbstracts.html#GilLorenz"&gt;Environmental Acquisition--A New Inheritance-Like Abstraction Mechanism&lt;/a&gt; 
   OOPSLA '96 Proceedings, ACM SIG-PLAN, October, 1996&lt;/p&gt;

&lt;p&gt;
&lt;TABLE BORDER=1 CELLPADDING=2&gt;
&lt;/TABLE&gt;&lt;/p&gt;



</t>
<t tx="ekr.20040104185809.105">&lt;h1&gt;Extension Classes, Python Extension Types Become Classes&lt;/h1&gt;
&lt;p&gt;  Jim Fulton, Digital Creations, Inc.
  jim@digicool.com&lt;/p&gt;

&lt;p&gt;  &lt;a href="COPYRIGHT.html"&gt;Copyright (C) 1996-1998, Digital Creations&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Abstract&lt;/h2&gt;
&lt;p&gt;    A lightweight mechanism has been developed for making Python
    extension types more class-like.  Classes can be developed in an
    extension language, such as C or C++, and these classes can be
    treated like other python classes:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;They can be sub-classed in python,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;They provide access to method documentation strings, and&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;They can be used to directly create new instances.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    An example class shows how extension classes are implemented and how
    they differ from extension types.&lt;/p&gt;

&lt;p&gt;    Extension classes provide additional extensions to class and
    instance semantics, including:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;A protocol for accessing subobjects "in the context of" their
      containers.  This is used to implement custom method types
      and &lt;a href="Acquisition.html"&gt;environmental acquisition&lt;/a&gt;.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A protocol for overriding method call semantics.  This is used
      to implement "synchonized" classes and could be used to
      implement argument type checking.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A protocol for class initialization that supports execution of a
      special &lt;code&gt;__class_init__&lt;/code&gt; method after a class has been
      initialized.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    Extension classes illustrate how the Python class mechanism can be
    extended and may provide a basis for improved or specialized class
    models. &lt;/p&gt;


&lt;h2&gt;Releases&lt;/h2&gt;
&lt;p&gt;    To find out what's changed in this release,
    see the &lt;a href="release.html"&gt;release notes&lt;/a&gt;.&lt;/p&gt;


&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;    Currently, Python provides two ways of defining new kinds of objects:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;Python classes&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extension types&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    Each approach has it's strengths.  Extension types provide much greater
    control to the programmer and, generally, better performance.  Because
    extension types are written in C, the programmer has greater access to 
    external resources. (Note that Python's use of the term type has
    little to do with the notion of type as a formal specification.)&lt;/p&gt;

&lt;p&gt;    Classes provide a higher level of abstraction and are generally much
    easier to develop.  Classes provide full inheritance support, while
    support for inheritance when developing extension types is very
    limited. Classes provide run-time meta-data, such as method documentation
    strings, that are useful for documentation and discovery.  Classes
    act as factories for creating instances, while separate functions
    must be provided to create instances of types.&lt;/p&gt;

&lt;p&gt;    It would be useful to combine the features of the two approaches.  It 
    would be useful to be able to have better support for inheritance for
    types, or to be able to subclass from types in Python.  It would be
    useful to be able to have class-like meta-data support for types and
    the ability to construct instances directly from types.&lt;/p&gt;

&lt;p&gt;    Our software is developed in Python.  When necessary, we convert
    debugged Python routines and classes to C for improved
    performance.  In most cases, a small number of methods in a class
    is responsible for most of the computation.  It should be possible
    to convert only these methods to C, while leaving the other method
    in Python.  A natural way to approach this is to create a base
    class in C that contains only the performance-critical aspects of
    a class' implementation and mix this base class into a Python
    class. &lt;/p&gt;

&lt;p&gt;    We have need, in a number of projects, for semantics that are
    slightly different than the usual class and instance semantics,
    yet we don't want to do most of our development in C.  For
    example, we have developed a persistence mechanism &lt;a href="#1"&gt;[1]&lt;/a&gt; that
    redefines &lt;code&gt;__getattr__&lt;/code&gt; and &lt;code&gt;__setattr__&lt;/code&gt; to take storage-related
    actions when object state is accessed or modified.  We want to be
    able to take certain actions on &lt;em&gt;every&lt;/em&gt; attribute reference, but
    for python class instances, &lt;code&gt;__getattr__&lt;/code&gt; is only called when
    attribute lookup fails by normal means.&lt;/p&gt;

&lt;p&gt;    As another example, we would like to have greater control over how
    methods are bound.  Currently, when accessing a class
    instance attribute, the attribute value is bound together with the
    instance in a method object &lt;em&gt;if and only if&lt;/em&gt; the attribute value is a
    python function.  For some applications, we might also want to be
    able to bind extension functions, or other types of callable
    objects, such as HTML document templates &lt;a href="#2"&gt;[2]&lt;/a&gt;. Furthermore,
    we might want to have greater control over how objects are bound.
    For example, we might want to bind instances and callable objects
    with special method objects that assure that no more than one thread
    accesses the object or method at one time.&lt;/p&gt;

&lt;p&gt;    We can provide these special semantics in extension types, but we
    wish to provide them for classes developed in Python.&lt;/p&gt;


&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;    At the first Python Workshop, Don Beaudry presented work &lt;a href="#3"&gt;[3]&lt;/a&gt; done
    at V.I. Corp to integrate Python with C++ frameworks.  This system
    provided a number of important features, including:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;Definition of extension types that provide class-like meta-data
      and that can be called to create instances.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ability to subclass in python from C types.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ability to define classes in python who's data are stored as
      C structures rather than in dictionaries to better interface to
      C and C++ libraries, and for better performance.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Less dynamic data structures.  In particular, the data structure
      for a class is declared during class definition.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support for enumeration types.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    This work was not released, initially.&lt;/p&gt;

&lt;p&gt;    Shortly after the workshop, changes were made to Python to support
    the sub-classing features described in &lt;a href="#3"&gt;[3]&lt;/a&gt;.  These changes were not
    documented until the fourth Python Workshop &lt;a href="#4"&gt;[4]&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;    At the third Python workshop, I presented some work I had done on
    generating module documentation for extension types.  Based on the
    discussion at this workshop, I developed a meta-type proposal &lt;a href="#5"&gt;[5]&lt;/a&gt;.
    This meta-type proposal was for an object that simply stored
    meta-information for a type, for the purpose of generating module
    documentation.&lt;/p&gt;

&lt;p&gt;    In the summer of 1996, Don Beaudry released the system described in
    &lt;a href="#3"&gt;[3]&lt;/a&gt; under the name MESS &lt;a href="#6"&gt;[6]&lt;/a&gt;. MESS addresses a number of needs but
    has a few drawbacks:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;Only single inheritance is supported.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The mechanisms for defining MESS extension types is very different
      from and more complicated than the standard Python type creation
      mechanism.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Defining MESS types requires the use of an extensive C
      applications programming interface.  This presents problems for
      configuring dynamically-loaded extension modules unless the MESS
      library is linked into the Python interpreter.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because the system tries to do a number of different things, it is
      fairly large, about 15,000 lines.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is very little documentation, especially for the C
      programming interface.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The system is a work in progress, with a number of outstanding
      bugs.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    As MESS matures, we expect most of these problems to be addressed.&lt;/p&gt;


&lt;h2&gt;Extension Classes&lt;/h2&gt;
&lt;p&gt;    To meet short term needs for a C-based persistence mechanism &lt;a href="#1"&gt;[1]&lt;/a&gt;, an
    extension class module was developed using the mechanism described
    in &lt;a href="#4"&gt;[4]&lt;/a&gt; and building on ideas from MESS &lt;a href="#6"&gt;[6]&lt;/a&gt;.  The extension class module
    recasts extension types as "extension classes" by seeking to
    eliminate, or at least reduce semantic differences between types and
    classes. The module was designed to meet the following goal:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;Provide class-like behavior for extension types, including
      interfaces for meta information and for constructing instances.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support sub-classing in Python from extension classes, with support
      for multiple inheritance.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide a small hardened implementation that can be used for
      current products.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide a mechanism that requires minimal modification to existing
      extension types.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Provide a basis for research on alternative semantics for classes
      and inheritance.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    &lt;strong&gt;Note:&lt;/strong&gt; I use &lt;em&gt;non-standard&lt;/em&gt; terminology here.  By standard
    &lt;em&gt;python&lt;/em&gt; terminology, only standard python classes can be called
    classes.  ExtensionClass "classes" are technically just "types"
    that happen to swim, walk and quack like python classes.&lt;/p&gt;

&lt;h3&gt;Base extension classes and extension subclasses&lt;/h3&gt;
&lt;p&gt;      Base extension classes are implemented in C.  Extension subclasses
      are implemented in Python and inherit, directly or indirectly from
      one or more base extension classes.  An extension subclass may
      inherit from base extension classes, extension subclasses, and
      ordinary python classes.  The usual inheritance order rules
      apply.  Currently, extension subclasses must conform to the
      following two rules:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;The first super class listed in the class statement defining an
        extension subclass must be either a base extension class or an
        extension subclass.  This restriction will be removed in
        Python-1.5.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At most one base extension direct or indirect super class may
        define C data members.  If an extension subclass inherits from
        multiple base extension classes, then all but one must be mix-in
        classes that provide extension methods but no data.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;h3&gt;Meta Information&lt;/h3&gt;
&lt;p&gt;      Like standard python classes, extension classes have the following
      attributes containing meta-data:&lt;/p&gt;

&lt;dl&gt;&lt;dt&gt;      &lt;code&gt;__doc__&lt;/code&gt;  &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;a documentation string for the class,&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;      &lt;code&gt;__name__&lt;/code&gt; &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;the class name,&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;      &lt;code&gt;__bases__&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;a sequence of base classes,&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;      &lt;code&gt;__dict__&lt;/code&gt; &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;a class dictionary, and&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;      &lt;code&gt;__module__&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;the name of the module in which the class was
                      defined. &lt;/p&gt;

&lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;      The class dictionary provides access to unbound methods and their
      documentation strings, including extension methods and special
      methods, such as methods that implement sequence and numeric
      protocols.  Unbound methods can be called with instance first
      arguments.&lt;/p&gt;


&lt;h3&gt;Subclass instance data&lt;/h3&gt;
&lt;p&gt;      Extension subclass instances have instance dictionaries, just
      like Python class instances do.  When fetching attribute values,
      extension class instances will first try to obtain data from the
      base extension class data structure, then from the instance
      dictionary, then from the class dictionary, and finally from base
      classes.  When setting attributes, extension classes first attempt
      to use extension base class attribute setting operations, and if
      these fail, then data are placed in the instance dictionary.&lt;/p&gt;



&lt;h2&gt;Implementing base extension classes&lt;/h2&gt;
&lt;p&gt;    A base extension class is implemented in much the same way that an
    extension type is implemented, except:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;The include file, &lt;code&gt;ExtensionClass.h&lt;/code&gt;, must be included.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The type structure is declared to be of type &lt;code&gt;PyExtensionClass&lt;/code&gt;, rather 
      than of type &lt;code&gt;PyTypeObject&lt;/code&gt;.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The type structure has an additional member that must be defined
      after the documentation string.  This extra member is a method chain
      (&lt;code&gt;PyMethodChain&lt;/code&gt;) containing a linked list of method definition
      (&lt;code&gt;PyMethodDef&lt;/code&gt;) lists.  Method chains can be used to implement
      method inheritance in C.  Most extensions don't use method chains,
      but simply define method lists, which are null-terminated arrays
      of method definitions.  A macro, &lt;code&gt;METHOD_CHAIN&lt;/code&gt; is defined in
      &lt;code&gt;ExtensionClass.h&lt;/code&gt; that converts a method list to a method chain.
      (See the example below.)&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Module functions that create new instances must be replaced by 
      &lt;code&gt;__init__&lt;/code&gt; methods that initialize, but does not create storage for 
      instances.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The extension class must be initialized and exported to the module
      with::&lt;/p&gt;
&lt;PRE&gt;
          PyExtensionClass_Export(d,&amp;quot;name&amp;quot;,type);

      where 'name' is the module name and 'type' is the extension class
      type object.

&lt;/PRE&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;h3&gt;Attribute lookup&lt;/h3&gt;
&lt;p&gt;      Attribute lookup is performed by calling the base extension class
      &lt;code&gt;getattr&lt;/code&gt; operation for the base extension class that includes C
      data, or for the first base extension class, if none of the base
      extension classes include C data.  &lt;code&gt;ExtensionClass.h&lt;/code&gt; defines a
      macro &lt;code&gt;Py_FindAttrString&lt;/code&gt; that can be used to find an object's
      attributes that are stored in the object's instance dictionary or
      in the object's class or base classes:&lt;/p&gt;
&lt;PRE&gt;
         v = Py_FindAttrString(self,name);

&lt;/PRE&gt;

&lt;p&gt;      where &lt;code&gt;name&lt;/code&gt; is a C string containing the attribute name.&lt;/p&gt;

&lt;p&gt;      In addition, a macro is provided that replaces &lt;code&gt;Py_FindMethod&lt;/code&gt;
      calls with logic to perform the same sort of lookup that is
      provided by &lt;code&gt;Py_FindAttrString&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;      If an attribute name is contained in a Python string object,
      rather than a C string object, then the macro &lt;code&gt;Py_FindAttr&lt;/code&gt; should
      be used to look up an attribute value.&lt;/p&gt;


&lt;h3&gt;Linking&lt;/h3&gt;
&lt;p&gt;      The extension class mechanism was designed to be useful with
      dynamically linked extension modules.  Modules that implement
      extension classes do not have to be linked against an extension
      class library.  The macro &lt;code&gt;PyExtensionClass_Export&lt;/code&gt; imports the
      &lt;code&gt;ExtensionClass&lt;/code&gt; module and uses objects imported from this module
      to initialize an extension class with necessary behavior.&lt;/p&gt;


&lt;h3&gt;Example: MultiMapping objects&lt;/h3&gt;
&lt;p&gt;      An &lt;a href="MultiMapping.html"&gt;example&lt;/a&gt; is provided that illustrates the
      changes needed to convert an existing type to an ExtensionClass.&lt;/p&gt;



&lt;h2&gt;Implementing base extension class constructors&lt;/h2&gt;
&lt;p&gt;    Some care should be taken when implementing or overriding base
    class constructors.  When a Python class overrides a base class
    constructor and fails to call the base class constructor, a
    program using the class may fail, but it will not crash the
    interpreter. On the other hand, an extension subclass that
    overrides a constructor in an extension base class must call the
    extension base class constructor or risk crashing the interpreter.
    This is because the base class constructor may set C pointers that,
    if not set properly, will cause the interpreter to crash when
    accessed.  This is the case with the &lt;code&gt;MultiMapping&lt;/code&gt; extension base
    class shown in the example above.&lt;/p&gt;

&lt;p&gt;    If no base class constructor is provided, extension class instance
    memory will be initialized to 0.  It is a good idea to design
    extension base classes so that instance methods check for
    uninitialized memory and perform initialialization if necessary.
    This was not done above to simplify the example.&lt;/p&gt;


&lt;h2&gt;Overriding methods inherited from Python base classes&lt;/h2&gt;
&lt;p&gt;    A problem occurs when trying to overide methods inherited from
    Python base classes.  Consider the following example:&lt;/p&gt;
&lt;PRE&gt;
      from ExtensionClass import Base

      class Spam:

        def __init__(self, name):
          self.name=name

      class ECSpam(Base, Spam):

        def __init__(self, name, favorite_color):
          Spam.__init__(self,name)
          self.favorite_color=favorite_color

&lt;/PRE&gt;

&lt;p&gt;    This implementation will fail when an &lt;code&gt;ECSpam&lt;/code&gt; object is
    instantiated.  The problem is that &lt;code&gt;ECSpam.__init__&lt;/code&gt; calls
    &lt;code&gt;Spam.__init__&lt;/code&gt;, and &lt;code&gt;Spam.__init__&lt;/code&gt; can only be called with a
    Python instance (an object of type &lt;code&gt;"instance"&lt;/code&gt;) as the first
    argument.  The first argument passed to &lt;code&gt;Spam.__init__&lt;/code&gt; will be an
    &lt;code&gt;ECSpam&lt;/code&gt; instance (an object of type &lt;code&gt;ECSPam&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;    To overcome this problem, extension classes provide a class method
    &lt;code&gt;inheritedAttribute&lt;/code&gt; that can be used to obtain an inherited
    attribute that is suitable for calling with an extension class
    instance.  Using the &lt;code&gt;inheritedAttribute&lt;/code&gt; method, the above
    example can be rewritten as:&lt;/p&gt;
&lt;PRE&gt;
      from ExtensionClass import Base

      class Spam:

        def __init__(self, name):
          self.name=name

      class ECSpam(Base, Spam):

        def __init__(self, name, favorite_color):
          ECSpam.inheritedAttribute('__init__')(self,name)
          self.favorite_color=favorite_color

&lt;/PRE&gt;

&lt;p&gt;    This isn't as pretty but does provide the desired result.&lt;/p&gt;


&lt;h2&gt;New class and instance semantics&lt;/h2&gt;
&lt;h3&gt;Context Wrapping&lt;/h3&gt;
&lt;p&gt;      It is sometimes useful to be able to wrap up an object together
      with a containing object.  I call this "context wrapping"
      because an object is accessed in the context of the object it is
      accessed through.&lt;/p&gt;

&lt;p&gt;      We have found many applications for this, including:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;User-defined method objects,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="Acquisition.html"&gt;Acquisition&lt;/a&gt; and&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Computed attributes&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;h4&gt;User-defined method objects&lt;/h4&gt;
&lt;p&gt;        Python classes wrap Python function attributes into methods.  When a
        class has a function attribute that is accessed as an instance
        attribute, a method object is created and returned that contains
        references to the original function and instance.  When the method
        is called, the original function is called with the instance as the
        first argument followed by any arguments passed to the method.&lt;/p&gt;

&lt;p&gt;        Extension classes provide a similar mechanism for attributes that
        are Python functions or inherited extension functions.  In
        addition, if an extension class attribute is an instance of an
        extension class that defines an &lt;code&gt;__of__&lt;/code&gt; method, then when the
        attribute is accessed through an instance, it's &lt;code&gt;__of__&lt;/code&gt; method
        will be called to create a bound method.&lt;/p&gt;

&lt;p&gt;        Consider the following example:&lt;/p&gt;
&lt;PRE&gt;
          import ExtensionClass

          class CustomMethod(ExtensionClass.Base):

            def __call__(self,ob): 
              print 'a %s was called' % ob.__class__.__name__

            class wrapper:

              def __init__(self,m,o): self.meth, self.ob=m,o

              def __call__(self): self.meth(self.ob)

            def __of__(self,o): return self.wrapper(self,o)

          class bar(ExtensionClass.Base):
            hi=CustomMethod()

          x=bar()
          hi=x.hi()

&lt;/PRE&gt;

&lt;p&gt;        Note that &lt;code&gt;ExtensionClass.Base&lt;/code&gt; is a base extension class that
        provides very basic ExtensionClass behavior. &lt;/p&gt;

&lt;p&gt;        When run, this program outputs: &lt;code&gt;a bar was called&lt;/code&gt;.&lt;/p&gt;


&lt;h4&gt;Computed Attributes&lt;/h4&gt;
&lt;p&gt;        It is not uncommon to wish to expose information via the
        attribute interface without affecting implementation data
        structures.  One can use a custom &lt;code&gt;__getattr__&lt;/code&gt; method to
        implement computed attributes, however, this can be a bit
        cumbersome and can interfere with other uses of &lt;code&gt;__getattr__&lt;/code&gt;,
        such as for persistence.&lt;/p&gt;

&lt;p&gt;        The &lt;code&gt;__of__&lt;/code&gt; protocol provides a convenient way to implement
        computed attributes. First, we define a ComputedAttribute
        class.  a ComputedAttribute is constructed with a function to
        be used to compute an attribute, and calls the function when
        it's &lt;code&gt;__of__&lt;/code&gt; method is called:&lt;/p&gt;
&lt;p&gt;          import ExtensionClass&lt;/p&gt;

&lt;p&gt;          class ComputedAttribute(ExtensionClass.Base):&lt;/p&gt;
&lt;p&gt;            def __init__(self, func): self.func=func&lt;/p&gt;

&lt;p&gt;            def __of__(self, parent): return self.func(parent)&lt;/p&gt;



&lt;p&gt;        Then we can use this class to create computed attributes.  In the
        example below, we create a computed attribute, &lt;code&gt;radius&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;          from math import sqrt&lt;/p&gt;

&lt;p&gt;          class Point(ExtensionClass.Base):&lt;/p&gt;
&lt;p&gt;            def __init__(self, x, y): self.x, self.y = x, y&lt;/p&gt;

&lt;p&gt;            radius=ComputedAttribute(lambda self: sqrt(self.x**2+self.y**2))&lt;/p&gt;



&lt;p&gt;        which we can use just like an ordinary attribute:&lt;/p&gt;
&lt;p&gt;          p=Point(2,2)
          print p.radius&lt;/p&gt;




&lt;h3&gt;Overriding method calls&lt;/h3&gt;
&lt;p&gt;      Normally, when a method is called, the function wrapped by the
      method is called directly by the method.  In some cases, it is
      useful for user-defined logic to participate in the actual
      function call.  Extension classes introduce a new protocol that
      provides extension classes greater control over how their
      methods are called.  If an extension class defines a special
      method, &lt;code&gt;__call_method__&lt;/code&gt;, then this method will be called to
      call the functions (or other callable object) wrapped by the
      method.  The method. &lt;code&gt;__call_method__&lt;/code&gt; should provide the same
      interface as provided by the Python builtin &lt;code&gt;apply&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;      For example, consider the expression: &lt;code&gt;x.meth(arg1, arg2)&lt;/code&gt;.  The
      expression is evaluated by first computing a method object that
      wraps &lt;code&gt;x&lt;/code&gt; and the attribute of &lt;code&gt;x&lt;/code&gt; stored under the name &lt;code&gt;meth&lt;/code&gt;.
      Assuming that &lt;code&gt;x&lt;/code&gt; has a &lt;code&gt;__call_method__&lt;/code&gt; method defined, then
      the &lt;code&gt;__call_method__&lt;/code&gt; method of &lt;code&gt;x&lt;/code&gt; will be called with two
      arguments, the attribute of &lt;code&gt;x&lt;/code&gt; stored under the name &lt;code&gt;meth&lt;/code&gt;,
      and a tuple containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;arg1&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;      To see how this feature may be used, see the Python module,
      &lt;code&gt;Syn.py&lt;/code&gt;, which is included in the ExtensionClass distribution.
      This module provides a mix-in class that provides Java-like
      "synchonized" classes that limit access to their methods to one
      thread at a time.&lt;/p&gt;

&lt;p&gt;      An interesting application of this mechanism would be to
      implement interface checking on method calls.&lt;/p&gt;


&lt;h3&gt;Method attributes&lt;/h3&gt;
&lt;p&gt;      Methods of ExtensionClass instances can have user-defined
      attributes, which are stored in their associated instances.&lt;/p&gt;

&lt;p&gt;      For example:&lt;/p&gt;
&lt;PRE&gt;
        class C(ExtensionClass.Base):

          def f(self):
            &amp;quot;Get a secret&amp;quot;
            ....

        c=C()

        c.f.__roles__=['Trusted People']

        print c.f.__roles__ # outputs ['Trusted People']
        print c.f__roles__  # outputs ['Trusted People']

        print C.f.__roles__ # fails, unbound method

&lt;/PRE&gt;

&lt;p&gt;      A bound method attribute is set by setting an attribute in it's
      instance with a name consisting of the concatination of the
      method's &lt;code&gt;__name__&lt;/code&gt; attribute and the attribute name.
      Attributes cannot be set on unbound methods.&lt;/p&gt;


&lt;h3&gt;Class initialization&lt;/h3&gt;
&lt;p&gt;      Normal Python class initialization is similar to but subtley
      different from instance initialization.  An instance &lt;code&gt;__init__&lt;/code&gt;
      function is called on an instance immediately &lt;em&gt;after&lt;/em&gt; it is
      created.  An instance &lt;code&gt;__init__&lt;/code&gt; function can use instance
      information, like it's class and can pass the instance to other
      functions.  On the other hand, the code in class statements is
      executed immediately &lt;em&gt;before&lt;/em&gt; the class is created.  This means
      that the code in a class statement cannot use class attributes,
      like &lt;code&gt;__bases__&lt;/code&gt;, or pass the class to functions.&lt;/p&gt;

&lt;p&gt;      Extension classes provide a mechanism for specifying code to be
      run &lt;em&gt;after&lt;/em&gt; a class has been created.  If a class or one of it's
      base classes defines a &lt;code&gt;__class_init__&lt;/code&gt; method, then this method
      will be called just after a class has been created.  The one
      argument passed to the method will be the class, &lt;em&gt;not&lt;/em&gt; an
      instance of the class.&lt;/p&gt;



&lt;h2&gt;Useful macros defined in ExtensionClass.h&lt;/h2&gt;
&lt;p&gt;    A number of useful macros are defined in ExtensionClass.h.
    These are documented in &lt;code&gt;ExtensionClass.h&lt;/code&gt;.&lt;/p&gt;


&lt;h2&gt;Pickleability&lt;/h2&gt;
&lt;p&gt;    Classes created with ExtensionClass, including extension base
    classes are automatically pickleable.  The usual gymnastics
    necessary to pickle &lt;code&gt;non-standard&lt;/code&gt; types are not necessray for
    types that have been modified to be extension base classes.&lt;/p&gt;


&lt;h2&gt;Status&lt;/h2&gt;
&lt;p&gt;    The current release of the extension class module is &lt;a href="http://www.digicool.com/releases/ExtensionClass/ExtensionClass-1.1.tar.gz"&gt;1.1&lt;/a&gt;.
    The core implementation has less than four thousand lines of code,
    including comments.  This release requires Python 1.4 or higher.&lt;/p&gt;

&lt;p&gt;    To find out what's changed in this release, see the
    &lt;a href="release.html"&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;    &lt;a href="Installation.html"&gt;Installation instructions&lt;/a&gt; are provided.&lt;/p&gt;


&lt;h2&gt;Issues&lt;/h2&gt;
&lt;p&gt;    There are a number of issues that came up in the course of this work
    and that deserve mention.&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;In Python 1.4, the class extension mechanism described in &lt;a href="#4"&gt;[4]&lt;/a&gt; required
      that the first superclass in a list of super-classes must be of the
      extended class type.  This may not be convenient if mix-in
      behavior is desired.  If a list of base classes starts with a
      standard python class, but includes an extension class, then an
      error was raised.  It would be more useful if, when a list of base
      classes contains one or more objects that are not python classes,
      the first such object was used to control the extended class
      definition.  To get around this, the &lt;code&gt;ExtensionClass&lt;/code&gt; module exports
      a base extension class, &lt;code&gt;Base&lt;/code&gt;, that can be used as the first base
      class in a list of base classes to assure that an extension
      subclass is created.&lt;/p&gt;
&lt;p&gt;      Python 1.5 allows the class extension even if the first non-class
      object in the list of base classes is not the first object in
      the list.  This issue appears to go away in Python 1.5, however,
      the restriction that the first non-class object in a list of
      base classes must be the first in the list may reappear in later
      versions of Python.&lt;/p&gt;


&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Currently, only one base extension class can define any data in
      C.  The data layout of subclasses-instances is the same as for the
      base class that defines data in C, except that the data structure
      is extended to hold an instance dictionary.  The data structure
      begins with a standard python header, and extension methods expect
      the C instance data to occur immediately after the object header.  If
      two or more base classes defined C data, the methods for the
      different base classes would expect their data to be in the same
      location. A solution might be to allocate base class instances and
      store pointers to these instances in the subclass data structure.
      The method binding mechanism would have to be a more complicated
      to make sure that methods were bound to the correct base data
      structure.  Alternatively, the signature of C methods could be
      expanded to allow pointers to expected class data to be passed
      in addition to object pointers.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is currently no support for sub-classing in C, beyond that
      provided by method chains.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rules for mixed-type arithmetic are different for python class
      instances than they are for extension type instances.  Python
      classes can define right and left versions of numeric binary
      operators, or they can define a coercion operator for converting
      binary operator operands to a common type.  For extension types,
      only the latter, coercion-based, approach is supported.  The
      coercion-based approach does not work well for many data types for
      which coercion rules depend on the operator.  Because extension
      classes are based on extension types, they are currently limited
      to the coercion-based approach.  It should be possible to
      extend the extension class implementation to allow both types of
      mixed-type arithmetic control.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I considered making extension classes immutable, meaning that
      class attributes could not be set after class creation.  I also
      considered making extension subclasses cache inherited
      attributes.  Both of these are related and attractive for some
      applications, however, I decided that it would be better to retain
      standard class instance semantics and provide these features as
      options at a later time.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The extension class module defines new method types to bind C and
      python methods to extension class instances.  It would be useful
      for these method objects to provide access to function call
      information, such as the number and names of arguments and the
      number of defaults, by parsing extension function documentation
      strings.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;h2&gt;Applications&lt;/h2&gt;
&lt;p&gt;    Aside from test and demonstration applications, the extension class
    mechanism has been used to provide an extension-based implementation
    of the persistence mechanism described in &lt;a href="#1"&gt;[1]&lt;/a&gt;.  We have developed
    this further to provide features such as automatic deactivation of
    objects not used after some period of time and to provide more
    efficient persistent-object cache management.&lt;/p&gt;

&lt;p&gt;    Acquisition has been heavily used in our recent products.
    Synchonized classes have also been used in recent products.&lt;/p&gt;


&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;    The extension-class mechanism described here provides a way to add
    class services to extension types.  It allows:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;Sub-classing extension classes in Python,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Construction of extension class instances by calling extension
        classes,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extension classes to provide meta-data, such as unbound methods
        and their documentation string.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;    In addition, the extension class module provides a relatively
    concise example of the use of mechanisms that were added to Python
    to support MESS &lt;a href="#6"&gt;[6]&lt;/a&gt;, and that were described at the fourth Python
    Workshop &lt;a href="#4"&gt;[4]&lt;/a&gt;.  It is hoped that this will spur research in improved
    and specialized models for class implementation in Python.&lt;/p&gt;


&lt;p&gt;  References&lt;/p&gt;

&lt;p&gt;  &lt;a name="1"&gt;[1]&lt;/a&gt; Fulton, J., &lt;a href="http://www.digicool.com/papers/Persistence.html"&gt;Providing Persistence for World-Wide-Web Applications&lt;/a&gt;
 Proceedings of the 5th Python Workshop.&lt;/p&gt;

&lt;p&gt;  &lt;a name="2"&gt;[2]&lt;/a&gt; Page, R. and Cropper, S., &lt;a href="http://www.digicool.com/papers/DocumentTemplate.html"&gt;Document Template&lt;/a&gt;
 Proceedings of the 5th Python Workshop.&lt;/p&gt;

&lt;p&gt;  &lt;a name="3"&gt;[3]&lt;/a&gt; Beaudry, D., &lt;a href="http://www.python.org/workshops/1994-11/BuiltInClasses/BuiltInClasses_1.html"&gt;Deriving Built-In Classes in Python&lt;/a&gt;
 Proceedings of the First International Python Workshop.&lt;/p&gt;

&lt;p&gt;  &lt;a name="4"&gt;[4]&lt;/a&gt; Van Rossum, G., &lt;a href="http://www.python.org/workshops/1996-06/notes/thursday.html"&gt;Don Beaudry Hack - MESS&lt;/a&gt;
 presented in the Developer's Future Enhancements session of the 
 4th Python Workshop. &lt;/p&gt;

&lt;p&gt;  &lt;a name="5"&gt;[5]&lt;/a&gt; Fulton, J., &lt;a href="http://www.digicool.com/jim/MetaType.c"&gt;Meta-Type Object&lt;/a&gt;
 This is a small proposal, the text of which is contained in a 
 sample implementation source file,  &lt;/p&gt;
&lt;p&gt;  &lt;a name="6"&gt;[6]&lt;/a&gt; Beaudry, D., and Ascher, D., &lt;a href="http://starship.skyport.net/~da/mess/"&gt;The Meta-Extension Set&lt;/a&gt;.
&lt;/p&gt;




</t>
<t tx="ekr.20040104185809.106">&lt;h1&gt;Installation&lt;/h1&gt;
&lt;p&gt;   &lt;a href="COPYRIGHT.html"&gt;Copyright (C) 1996-1998, Digital Creations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;   The ExtensionClass distribution now uses the "Universal Unix
   Makefile for Python extensions", &lt;code&gt;Makefile.pre.in&lt;/code&gt;, which was
   introduced as part of Python1.4.  Copies of this file for Python
   1.4 and Python 1.5 are included with this release.  See the
   instructions in the make file, itself.  Note that you will need to
   copy or rename the the file for the Python version you're using to
   Makefile.pre.in.&lt;/p&gt;


&lt;h1&gt;Files&lt;/h1&gt;
&lt;dl&gt;&lt;dt&gt;  ExtensionClass.stx  &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;This file in structured text format&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  ExtensionClass.html &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;This file in HTML format&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Installation        &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Installation instructions in structured text
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Installation.html   &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Installation instructions in HTML
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Acquisition.stx     &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Acquisition documentation in structured text
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Acquisition.html    &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Acquisition documentation in HTML
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  MultiMapping.stx    &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The MultiMapping example in structured text
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  MultiMapping.html   &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The MultiMapping example in structured text
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  release.notes       &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Release notes in structured text
                          format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  release.html        &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;Release notes in HTML format.  &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  README              &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;A file that says to read this file.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Makefile.pre.in-1.4 &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The Universal Unix Makefile for Python
                          extensions.  This is the Python 1.4
                          version.  Copy this to Makefile.pre.in
                          before using it.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Makefile.pre.in-1.5 &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The Universal Unix Makefile for Python
                          extensions.  This is the Python 1.5
                          version.  Copy this to Makefile.pre.in
                          before using it.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Setup               &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;a configuration file used by the Universal
                          Unix Makefile for Python extensions &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  ExtensionClass.c    &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The ExtensionClass source&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  ExtensionClass.h    &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The ExtensionClass header file&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Acquisition.c       &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The source for the &lt;code&gt;Acquisition&lt;/code&gt; module
                          that provides mix-in classes to support
                          environmental acquisition&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  MethodObject.c      &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The source for the &lt;code&gt;MethodObject&lt;/code&gt; module
                          that provides a mix-in class for
                          user-defined method types.  To create a
                          user-defined method type, just create an
                          extension subclass of
                          &lt;code&gt;MethodObject.MethodObject&lt;/code&gt; that has an
                          &lt;code&gt;__call__&lt;/code&gt; method.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Missing.c           &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The source for the &lt;code&gt;Missing&lt;/code&gt; module
                          that provides a class for objects that
                          model "missing" or unknown data.  Missing
                          objects have the property that all
                          mathematical operations yield a missing
                          value.  This is included mainly as an
                          example (and test) of a numeric extension
                          base class.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  MultiMapping.c       &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The source for a slightly enhanced
                           &lt;code&gt;MultiMapping&lt;/code&gt; module that is based on the
                           &lt;code&gt;MultiMapping&lt;/code&gt; example given in this
                           paper.  If present, document templates &lt;a href="#2"&gt;[2]&lt;/a&gt;
                           will take advantage of this module to
                           significantly increase rendering
                           performance. &lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  Sync.py              &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;A Python module that provides a
                           &lt;code&gt;Synchonized&lt;/code&gt; mix-in class that limits access
                           to an object's methods to one thread at a
                           time.  This requires the installation of
                           the ThreadLock module.&lt;/p&gt;

&lt;/dd&gt;
&lt;dt&gt;  ThreadLock.c         &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;The source for the &lt;code&gt;ThreadLock&lt;/code&gt; module that
                           provides &lt;code&gt;ThreadLock&lt;/code&gt; objects.  These are
                           similar to the lock objects provided by
                           the &lt;code&gt;thread&lt;/code&gt; modules.  Unlike normal
                           Python lock objects, &lt;code&gt;ThreadLock&lt;/code&gt; objects
                           can be acquired (and released) more than
                           once by the same thread.&lt;/p&gt;

&lt;/dd&gt;&lt;/dl&gt;
&lt;p&gt;  In addition to the files listed above, several "test" modules are
  included. These are modules that I used to test ExtensionClass.
  They do not constitute a regression testing suit and I've made
  little effort to assure that they actually work, although that
  would be a good thing to do if time permits.
&lt;/p&gt;



</t>
<t tx="ekr.20040104185809.107">&lt;h1&gt;Example: MultiMapping objects&lt;/h1&gt;
&lt;p&gt;  &lt;a href="COPYRIGHT.html"&gt;Copyright (C) 1996-1998, Digital Creations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;  As an example, consider an extension class that implements a
  "MultiMapping". A multi-mapping is an object that encapsulates 0
  or more mapping objects.  When an attempt is made to lookup an
  object, the encapsulated mapping objects are searched until an
  object is found.&lt;/p&gt;

&lt;p&gt;  Consider an implementation of a MultiMapping extension type,
  without use of the extension class mechanism:&lt;/p&gt;
&lt;PRE&gt;
    #include &amp;quot;Python.h&amp;quot;

    #define UNLESS(E) if(!(E))

    typedef struct {
        PyObject_HEAD
        PyObject *data;
    } MMobject;

    staticforward PyTypeObject MMtype;

    static PyObject *
    MM_push(MMobject *self, PyObject *args){
        PyObject *src;
        UNLESS(PyArg_ParseTuple(args, &amp;quot;O&amp;quot;, &amp;amp;src)) return NULL;
        UNLESS(-1 != PyList_Append(self-&amp;gt;data,src)) return NULL;
        Py_INCREF(Py_None);
        return Py_None;
    }

    static PyObject *
    MM_pop(MMobject *self, PyObject *args){
        long l;
        PyObject *r;
        static PyObject *emptyList=0;

        UNLESS(emptyList) UNLESS(emptyList=PyList_New(0)) return NULL;
        UNLESS(PyArg_ParseTuple(args, &amp;quot;&amp;quot;)) return NULL;
        UNLESS(-1 != (l=PyList_Size(self-&amp;gt;data))) return NULL;
        l--;
        UNLESS(r=PySequence_GetItem(self-&amp;gt;data,l)) return NULL;
        UNLESS(-1 != PyList_SetSlice(self-&amp;gt;data,l,l+1,emptyList)) goto err;
        return r;
    err:
        Py_DECREF(r);
        return NULL;
    }

    static struct PyMethodDef MM_methods[] = {
        {&amp;quot;push&amp;quot;, (PyCFunction) MM_push, 1,
         &amp;quot;push(mapping_object) -- Add a data source&amp;quot;},
        {&amp;quot;pop&amp;quot;,  (PyCFunction) MM_pop,  1,
         &amp;quot;pop() -- Remove and return the last data source added&amp;quot;}, 
        {NULL,              NULL}           /* sentinel */
    };

    static PyObject *
    newMMobject(PyObject *ignored, PyObject *args){
        MMobject *self;

        UNLESS(PyArg_ParseTuple(args, &amp;quot;&amp;quot;)) return NULL;
        UNLESS(self = PyObject_NEW(MMobject, &amp;amp;MMtype)) return NULL;
        UNLESS(self-&amp;gt;data=PyList_New(0)) goto err;
        return (PyObject *)self;
    err:
        Py_DECREF(self);
        return NULL;
    }

    static void
    MM_dealloc(MMobject *self){
        Py_XDECREF(self-&amp;gt;data);
        PyMem_DEL(self);
    }

    static PyObject *
    MM_getattr(MMobject *self, char *name){
        return Py_FindMethod(MM_methods, (PyObject *)self, name);
    }

    static int
    MM_length(MMobject *self){
        long l=0, el, i;
        PyObject *e=0;

        UNLESS(-1 != (i=PyList_Size(self-&amp;gt;data))) return -1;
        while(--i &amp;gt;= 0)
          {
            e=PyList_GetItem(self-&amp;gt;data,i);
            UNLESS(-1 != (el=PyObject_Length(e))) return -1;
            l+=el;
          }
        return l;
    }

    static PyObject *
    MM_subscript(MMobject *self, PyObject *key){
        long i;
        PyObject *e;

        UNLESS(-1 != (i=PyList_Size(self-&amp;gt;data))) return NULL;
        while(--i &amp;gt;= 0)
          {
            e=PyList_GetItem(self-&amp;gt;data,i);
            if(e=PyObject_GetItem(e,key)) return e;
            PyErr_Clear();
          }
        PyErr_SetObject(PyExc_KeyError,key);
        return NULL;
    }

    static PyMappingMethods MM_as_mapping = {
              (inquiry)MM_length,           /*mp_length*/
              (binaryfunc)MM_subscript,             /*mp_subscript*/
              (objobjargproc)NULL,          /*mp_ass_subscript*/
    };

    /* -------------------------------------------------------- */

    static char MMtype__doc__[] = 
    &amp;quot;MultiMapping -- Combine multiple mapping objects for lookup&amp;quot;
    ;

    static PyTypeObject MMtype = {
              PyObject_HEAD_INIT(&amp;amp;PyType_Type)
              0,                            /*ob_size*/
              &amp;quot;MultMapping&amp;quot;,                        /*tp_name*/
              sizeof(MMobject),             /*tp_basicsize*/
              0,                            /*tp_itemsize*/
              /* methods */
              (destructor)MM_dealloc,               /*tp_dealloc*/
              (printfunc)0,                 /*tp_print*/
              (getattrfunc)MM_getattr,      /*tp_getattr*/
              (setattrfunc)0,                       /*tp_setattr*/
              (cmpfunc)0,                   /*tp_compare*/
              (reprfunc)0,                  /*tp_repr*/
              0,                            /*tp_as_number*/
              0,                            /*tp_as_sequence*/
              &amp;amp;MM_as_mapping,                       /*tp_as_mapping*/
              (hashfunc)0,                  /*tp_hash*/
              (ternaryfunc)0,                       /*tp_call*/
              (reprfunc)0,                  /*tp_str*/

              /* Space for future expansion */
              0L,0L,0L,0L,
              MMtype__doc__ /* Documentation string */
    };

    static struct PyMethodDef MultiMapping_methods[] = {
        {&amp;quot;MultiMapping&amp;quot;, (PyCFunction)newMMobject, 1,
         &amp;quot;MultiMapping() -- Create a new empty multi-mapping&amp;quot;},
        {NULL,              NULL}           /* sentinel */
    };

    void
    initMultiMapping(){
        PyObject *m;

        m = Py_InitModule4(
            &amp;quot;MultiMapping&amp;quot;, MultiMapping_methods,
              &amp;quot;MultiMapping -- Wrap multiple mapping objects for lookup&amp;quot;,
              (PyObject*)NULL,PYTHON_API_VERSION);

        if (PyErr_Occurred()) 
           Py_FatalError(&amp;quot;can't initialize module MultiMapping&amp;quot;);
    }

&lt;/PRE&gt;

&lt;p&gt;  This module defines an extension type, &lt;code&gt;MultiMapping&lt;/code&gt;, and exports a
  module function, &lt;code&gt;MultiMapping&lt;/code&gt;, that creates &lt;code&gt;MultiMapping&lt;/code&gt;
  Instances. The type provides two methods, &lt;code&gt;push&lt;/code&gt;, and &lt;code&gt;pop&lt;/code&gt;, for
  adding and removing mapping objects to the multi-mapping.
  The type provides mapping behavior, implementing mapping length
  and subscript operators but not mapping a subscript assignment
  operator.&lt;/p&gt;

&lt;p&gt;  Now consider an extension class implementation of MultiMapping
  objects:&lt;/p&gt;
&lt;PRE&gt;
    #include &amp;quot;Python.h&amp;quot;
    #include &amp;quot;ExtensionClass.h&amp;quot;

    #define UNLESS(E) if(!(E))

    typedef struct {
        PyObject_HEAD
        PyObject *data;
    } MMobject;

    staticforward PyExtensionClass MMtype;

    static PyObject *
    MM_push(self, args)
              MMobject *self;
              PyObject *args;
    {
        PyObject *src;
        UNLESS(PyArg_ParseTuple(args, &amp;quot;O&amp;quot;, &amp;amp;src)) return NULL;
        UNLESS(-1 != PyList_Append(self-&amp;gt;data,src)) return NULL;
        Py_INCREF(Py_None);
        return Py_None;
    }

    static PyObject *
    MM_pop(self, args)
              MMobject *self;
              PyObject *args;
    {
        long l;
        PyObject *r;
        static PyObject *emptyList=0;

        UNLESS(emptyList) UNLESS(emptyList=PyList_New(0)) return NULL;
        UNLESS(PyArg_ParseTuple(args, &amp;quot;&amp;quot;)) return NULL;
        UNLESS(-1 != (l=PyList_Size(self-&amp;gt;data))) return NULL;
        l--;
        UNLESS(r=PySequence_GetItem(self-&amp;gt;data,l)) return NULL;
        UNLESS(-1 != PyList_SetSlice(self-&amp;gt;data,l,l+1,emptyList)) goto err;
        return r;
    err:
        Py_DECREF(r);
        return NULL;
    }

    static PyObject *
    MM__init__(self, args)
           MMobject *self;
           PyObject *args;
    {
        UNLESS(PyArg_ParseTuple(args, &amp;quot;&amp;quot;)) return NULL;
        UNLESS(self-&amp;gt;data=PyList_New(0)) goto err;
        Py_INCREF(Py_None);
        return Py_None;
    err:
        Py_DECREF(self);
        return NULL;
    }

    static struct PyMethodDef MM_methods[] = {
        {&amp;quot;__init__&amp;quot;, (PyCFunction)MM__init__, 1,
         &amp;quot;__init__() -- Create a new empty multi-mapping&amp;quot;},
        {&amp;quot;push&amp;quot;, (PyCFunction) MM_push, 1,
         &amp;quot;push(mapping_object) -- Add a data source&amp;quot;},
        {&amp;quot;pop&amp;quot;,  (PyCFunction) MM_pop,  1,
         &amp;quot;pop() -- Remove and return the last data source added&amp;quot;}, 
        {NULL,              NULL}           /* sentinel */
    };

    static void
    MM_dealloc(self)
           MMobject *self;
    {
        Py_XDECREF(self-&amp;gt;data);
        PyMem_DEL(self);
    }

    static PyObject *
    MM_getattr(self, name)
              MMobject *self;
              char *name;
    {
        return Py_FindMethod(MM_methods, (PyObject *)self, name);
    }

    static int
    MM_length(self)
              MMobject *self;
    {
        long l=0, el, i;
        PyObject *e=0;

        UNLESS(-1 != (i=PyList_Size(self-&amp;gt;data))) return -1;
        while(--i &amp;gt;= 0)
          {
            e=PyList_GetItem(self-&amp;gt;data,i);
            UNLESS(-1 != (el=PyObject_Length(e))) return -1;
            l+=el;
          }
        return l;
    }

    static PyObject *
    MM_subscript(self, key)
              MMobject *self;
              PyObject *key;
    {
        long i;
        PyObject *e;

        UNLESS(-1 != (i=PyList_Size(self-&amp;gt;data))) return NULL;
        while(--i &amp;gt;= 0)
          {
            e=PyList_GetItem(self-&amp;gt;data,i);
            if(e=PyObject_GetItem(e,key)) return e;
            PyErr_Clear();
          }
        PyErr_SetObject(PyExc_KeyError,key);
        return NULL;
    }

    static PyMappingMethods MM_as_mapping = {
              (inquiry)MM_length,           /*mp_length*/
              (binaryfunc)MM_subscript,             /*mp_subscript*/
              (objobjargproc)NULL,          /*mp_ass_subscript*/
    };

    /* -------------------------------------------------------- */

    static char MMtype__doc__[] = 
    &amp;quot;MultiMapping -- Combine multiple mapping objects for lookup&amp;quot;
    ;

    static PyExtensionClass MMtype = {
              PyObject_HEAD_INIT(&amp;amp;PyType_Type)
              0,                            /*ob_size*/
              &amp;quot;MultMapping&amp;quot;,                        /*tp_name*/
              sizeof(MMobject),             /*tp_basicsize*/
              0,                            /*tp_itemsize*/
              /* methods */
              (destructor)MM_dealloc,               /*tp_dealloc*/
              (printfunc)0,                 /*tp_print*/
              (getattrfunc)MM_getattr,      /*tp_getattr*/
              (setattrfunc)0,                       /*tp_setattr*/
              (cmpfunc)0,                   /*tp_compare*/
              (reprfunc)0,                  /*tp_repr*/
              0,                            /*tp_as_number*/
              0,                            /*tp_as_sequence*/
              &amp;amp;MM_as_mapping,                       /*tp_as_mapping*/
              (hashfunc)0,                  /*tp_hash*/
              (ternaryfunc)0,                       /*tp_call*/
              (reprfunc)0,                  /*tp_str*/

              /* Space for future expansion */
              0L,0L,0L,0L,
              MMtype__doc__, /* Documentation string */
              METHOD_CHAIN(MM_methods)
    };

    static struct PyMethodDef MultiMapping_methods[] = {
        {NULL,              NULL}           /* sentinel */
    };

    void
    initMultiMapping()
    {
        PyObject *m, *d;

        m = Py_InitModule4(
            &amp;quot;MultiMapping&amp;quot;, MultiMapping_methods,
            &amp;quot;MultiMapping -- Wrap multiple mapping objects for lookup&amp;quot;,
            (PyObject*)NULL,PYTHON_API_VERSION);
        d = PyModule_GetDict(m);
        PyExtensionClass_Export(d,&amp;quot;MultiMapping&amp;quot;,MMtype);

        if (PyErr_Occurred()) 
           Py_FatalError(&amp;quot;can't initialize module MultiMapping&amp;quot;);
    }

&lt;/PRE&gt;

&lt;p&gt;  This version includes &lt;code&gt;ExtensionClass.h&lt;/code&gt;.  The two declarations of
  &lt;code&gt;MMtype&lt;/code&gt; have been changed from &lt;code&gt;PyTypeObject&lt;/code&gt; to &lt;code&gt;PyExtensionClass&lt;/code&gt;.
  The &lt;code&gt;METHOD_CHAIN&lt;/code&gt; macro has been used to add methods to the end of
  the definition for &lt;code&gt;MMtype&lt;/code&gt;.  The module function, newMMobject has
  been replaced by the &lt;code&gt;MMtype&lt;/code&gt; method, &lt;code&gt;MM__init__&lt;/code&gt;.  Note that this
  method does not create or return a new object.  Finally, the lines:&lt;/p&gt;
&lt;PRE&gt;
    d = PyModule_GetDict(m);
    PyExtensionClass_Export(d,&amp;quot;MultiMapping&amp;quot;,MMtype);

&lt;/PRE&gt;

&lt;p&gt;  Have been added to both initialize the extension class and to export
  it in the module dictionary.&lt;/p&gt;

&lt;p&gt;  To use this module, compile, link, and import it as with any other
  extension module.  The following python code illustrates the
  module's use:&lt;/p&gt;
&lt;PRE&gt;
    from MultiMapping import MultiMapping
    m=MultiMapping()
    m.push({'spam':1, 'eggs':2})
    m.push({'spam':3, 'ham':4})

    m['spam'] # returns 3
    m['ham']  # returns 4
    m['foo']  # raises a key error

&lt;/PRE&gt;

&lt;p&gt;  Creating the &lt;code&gt;MultiMapping&lt;/code&gt; object took three steps, one to create
  an empty &lt;code&gt;MultiMapping&lt;/code&gt;, and two to add mapping objects to it.  We
  might wish to simplify the process of creating MultiMapping
  objects by providing a constructor that takes source mapping
  objects as parameters.  We can do this by sub-classing MultiMapping
  in Python:&lt;/p&gt;
&lt;PRE&gt;
    from MultiMapping import MultiMapping
    class ExtendedMultiMapping(MultiMapping):
        def __init__(self,*data):
          MultiMapping.__init__(self)
          for d in data: self.push(d)

    m=ExtendedMultiMapping({'spam':1, 'eggs':2}, {'spam':3, 'ham':4})

    m['spam'] # returns 3
    m['ham']  # returns 4
    m['foo']  # raises a key error

&lt;/PRE&gt;

&lt;p&gt;  Note that the source file included in the ExtensionClass
  distribution has numerous enhancements beyond the version shown in
  this document.
&lt;/p&gt;



</t>
<t tx="ekr.20040104185809.108">&lt;p&gt;
Extension Class&lt;/p&gt;
&lt;p&gt;    &lt;a href="COPYRIGHT.html"&gt;Copyright (C) 1996-1998, Digital Creations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;    A lightweight mechanism has been developed for making Python
    extension types more class-like.  Classes can be developed in an
    extension language, such as C or C++, and these classes can be
    treated like other python classes:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;They can be sub-classed in python,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;They provide access to method documentation strings, and&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;They can be used to directly create new instances.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    Extension classes provide additional extensions to class and
    instance semantics, including:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;A protocol for accessing subobjects "in the context of" their
      containers.  This is used to implement custom method types
      and &lt;a href="Acquisition.html"&gt;environmental acquisition&lt;/a&gt;.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A protocol for overriding method call semantics.  This is used
      to implement "synchonized" classes and could be used to
      implement argument type checking.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A protocol for class initialization that supports execution of a
      special &lt;code&gt;__class_init__&lt;/code&gt; method after a class has been
      initialized.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;    Extension classes illustrate how the Python class mechanism can be
    extended and may provide a basis for improved or specialized class
    models. &lt;/p&gt;

&lt;h1&gt;Releases&lt;/h1&gt;
&lt;p&gt;    The current release is &lt;a href="ExtensionClass-1.2.tar.gz"&gt;1.2&lt;/a&gt;
    To find out what's changed in this release,
    see the &lt;a href="release.html"&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;    Documentation is available &lt;a href="ExtensionClass.html"&gt;on-line&lt;/a&gt;.&lt;/p&gt;


&lt;h1&gt;Windows Binaries&lt;/h1&gt;
&lt;p&gt;    A win32 binary release, &lt;a href="ec12.zip"&gt;ec12.zip&lt;/a&gt; is available.  This
    release includes all of the ExtensionClass modules built as 
    Windows extension modules (.pyd) files.  These were built for
    Python 1.5.1 using Microsoft Visual C++ 5.0 in "Release" mode.&lt;/p&gt;


&lt;p&gt;
&lt;TABLE BORDER=1 CELLPADDING=2&gt;
&lt;/TABLE&gt;&lt;/p&gt;



</t>
<t tx="ekr.20040104185809.109">&lt;h1&gt;Release Notes&lt;/h1&gt;
&lt;h2&gt;1.2&lt;/h2&gt;
&lt;p&gt;    This release provides some important bug fixes, some new features,
    and a new copyright.&lt;/p&gt;

&lt;p&gt;    New functionality:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;One or more mapping objects can be passed to the MultiMapping
        constructor.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MultiMapping objects implement the has_key and get methods as
        defined for Python 1.5 dictionaries.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;    Bugs fixed:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;When support was added for passing acquisition wrappers to
        methods of data-less C mix-in classes, C-based __call_method__
        hooks were broken.  The most notable example of this was the
        breaking of the Synchronized class.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Calling C-base-class special methods from overriding methods,
        as in::&lt;/p&gt;
&lt;PRE&gt;
          class LowerMultiMapping(MultiMapping):

            def __getitem__(self, key):
              return MultiMapping.__getitem__(self, lower(key))

        caused infinite loops.

&lt;/PRE&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A typo in the Acquisition probably caused __delitem__
        calls on wrapped mapping objects to fail.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;


&lt;h2&gt;1.1&lt;/h2&gt;
&lt;p&gt;     New functionality:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;Changed the way that methods in pure mix-in classes are
        constructed.  Now methods are wrapped in such a way that
        tricky wrapper objects (like Acquisition wrappers) can
        bind them to wrapped objects.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An "is subclass" test is provided via the macros
        &lt;code&gt;ExtensionClassSubclass_Check&lt;/code&gt;, and
        &lt;code&gt;ExtensionClassSubclassInstance_Check&lt;/code&gt;, which are
        documented in &lt;code&gt;ExtensionClass.h&lt;/code&gt;.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Methods and Acquisition wrappers use free list to improve
        allocation and deallocation performance.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bound methods have attributes who's values are stored in
        their instances.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added &lt;code&gt;__module__&lt;/code&gt; attribute to ExtensionClasses to be
        consistent with Python 1.5 classes and to work correctly
        with 1.5 pickling.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added the &lt;code&gt;__basic__&lt;/code&gt; new class method to allow
        ExtensionClass instances to be unpickled without calling
        their constructors.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Acquired acquiring objects can nor acquire from the object
        they were accessed in, in addition to the object they were
        acquired from.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added new &lt;code&gt;Acquisition&lt;/code&gt; variable, &lt;code&gt;Acquired&lt;/code&gt;, to support
        "Controlled Acquisition'.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added a new &lt;code&gt;aq_acquire&lt;/code&gt; method for objects that subclass
        &lt;code&gt;Acquisition.Implicit&lt;/code&gt; or &lt;code&gt;Acquisition.Explicit&lt;/code&gt;. This
        supports explicit acquisition and provides an option
        filter function to support "Filtered Acquisiition".&lt;/p&gt;
&lt;p&gt;        The &lt;code&gt;acquire&lt;/code&gt; method available in earlier releases is still
        available, but is deprecated.&lt;/p&gt;


&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;     Bugs fixed:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;There were some incorrect C-level error return values.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A bug in handling method chains caused "C inheritence"
        to fail.  This only affected extension types that
        inherited from extension types using method chains, &lt;em&gt;not&lt;/em&gt;
        extension subclasses defined in Python inheriting from
        extension base classes defined in C.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expressions like &lt;code&gt;not foo&lt;/code&gt; or statements like::&lt;/p&gt;
&lt;PRE&gt;
         if foo:
           ...

        often failed for non-collection types because of an
        incorrect attempt to take the 'len' of an object.

&lt;/PRE&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comparisons of objects with different classes didn't work
        correctly.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instances provided access to their class &lt;code&gt;__bases__&lt;/code&gt;
        attribute.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;


&lt;h2&gt;1.0.2&lt;/h2&gt;
&lt;p&gt;     Bugs fixed:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;Fixed bug in handling subclasses of Sequence objects.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fixed comparison bug in Missing objects.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;


&lt;h2&gt;1.0.1&lt;/h2&gt;
&lt;p&gt;    Added functionality to and fixed bug in Missing module&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;p&gt;Fixed horible reference-counting bug&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Changed so that &lt;code&gt;Missing.Value.spam(a1,a2,whatever)&lt;/code&gt;
      returns &lt;code&gt;Missing.Value&lt;/code&gt; for any method name (except
      &lt;code&gt;__reduce__&lt;/code&gt;) and any arguments.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Changed so that missing values are picklable.  Note that
      the special global, Missing.Value, is pickled in a
      slightly more efficient manner than other missing values.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;h2&gt;1.0&lt;/h2&gt;
&lt;p&gt;     First non-beta release&lt;/p&gt;

&lt;p&gt;     This release is the result of a major rewrite and "hardening"
     effort to increase performance and reliability.  This version
     is being used in several Digital Creations products, so if
     parts are broken, we probably don't use them. :-)&lt;/p&gt;

&lt;p&gt;     This release also contains several new features and example
     modules, including:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;Acquisition,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Custom method calls,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Class initialization protocol,&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A class method that makes it possible to explicitly call
         Python base-class methods.&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A sample application of custom method calls that provides
         Java-like synchronized classes that prevent more than one
         thread from accessing an object's methods at one time.&lt;/p&gt;

&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;     Note that there is one known incompatibility with previous
     releases.  In previouse releases, the method used to support
     context wrapping was named &lt;code&gt;__bind_to_object__&lt;/code&gt;.  The name of
     this method was changed to &lt;code&gt;__of__&lt;/code&gt; in this release and I do
     not expect this name to change in the future.
&lt;/p&gt;




</t>
<t tx="ekr.20040104185809.110"></t>
<t tx="ekr.20040104185809.111">@language c

&lt;&lt; c copyright &gt;&gt;

&lt;&lt; Acquisition #includes &gt;&gt;

static ACQUISITIONCAPI AcquisitionCAPI;

@others
</t>
<t tx="ekr.20040104185809.112">#include "ExtensionClass.h"


#define _IN_ACQUISITION_C
#include "Acquisition.h"

</t>
<t tx="ekr.20040104185809.114">static void
PyVar_Assign(PyObject **v,  PyObject *e)
{
  Py_XDECREF(*v);
  *v=e;
}
</t>
<t tx="ekr.20040104185809.115">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if (!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define OBJECT(O) ((PyObject*)(O))

static PyObject *py__add__, *py__sub__, *py__mul__, *py__div__,
  *py__mod__, *py__pow__, *py__divmod__, *py__lshift__, *py__rshift__,
  *py__and__, *py__or__, *py__xor__, *py__coerce__, *py__neg__,
  *py__pos__, *py__abs__, *py__nonzero__, *py__invert__, *py__int__,
  *py__long__, *py__float__, *py__oct__, *py__hex__,
  *py__getitem__, *py__setitem__, *py__delitem__,
  *py__getslice__, *py__setslice__, *py__delslice__,
  *py__len__, *py__of__, *py__call__, *py__repr__, *py__str__, *py__cmp__;

static PyObject *Acquired=0;

static void
init_py_names(void)
{
#define INIT_PY_NAME(N) py ## N = PyString_FromString(#N)
  INIT_PY_NAME(__add__);
  INIT_PY_NAME(__sub__);
  INIT_PY_NAME(__mul__);
  INIT_PY_NAME(__div__);
  INIT_PY_NAME(__mod__);
  INIT_PY_NAME(__pow__);
  INIT_PY_NAME(__divmod__);
  INIT_PY_NAME(__lshift__);
  INIT_PY_NAME(__rshift__);
  INIT_PY_NAME(__and__);
  INIT_PY_NAME(__or__);
  INIT_PY_NAME(__xor__);
  INIT_PY_NAME(__coerce__);
  INIT_PY_NAME(__neg__);
  INIT_PY_NAME(__pos__);
  INIT_PY_NAME(__abs__);
  INIT_PY_NAME(__nonzero__);
  INIT_PY_NAME(__invert__);
  INIT_PY_NAME(__int__);
  INIT_PY_NAME(__long__);
  INIT_PY_NAME(__float__);
  INIT_PY_NAME(__oct__);
  INIT_PY_NAME(__hex__);
  INIT_PY_NAME(__getitem__);
  INIT_PY_NAME(__setitem__);
  INIT_PY_NAME(__delitem__);
  INIT_PY_NAME(__getslice__);
  INIT_PY_NAME(__setslice__);
  INIT_PY_NAME(__delslice__);
  INIT_PY_NAME(__len__);
  INIT_PY_NAME(__of__);
  INIT_PY_NAME(__call__);
  INIT_PY_NAME(__repr__);
  INIT_PY_NAME(__str__);
  INIT_PY_NAME(__cmp__);
  
#undef INIT_PY_NAME
}</t>
<t tx="ekr.20040104185809.116">static PyObject *
CallMethodO(PyObject *self, PyObject *name,
		     PyObject *args, PyObject *kw)
{
  if (! args &amp;&amp; PyErr_Occurred()) return NULL;
  UNLESS(name=PyObject_GetAttr(self,name)) {
    if (args) { Py_DECREF(args); }
    return NULL;
  }
  ASSIGN(name,PyEval_CallObjectWithKeywords(name,args,kw));
  if (args) { Py_DECREF(args); }
  return name;
}
</t>
<t tx="ekr.20040104185809.117">#define Build Py_BuildValue

/* Declarations for objects of type Wrapper */

typedef struct {
  PyObject_HEAD
  PyObject *obj;
  PyObject *container;
} Wrapper;

staticforward PyExtensionClass Wrappertype, XaqWrappertype;

#define isWrapper(O) ((O)-&gt;ob_type==(PyTypeObject*)&amp;Wrappertype || \
		      (O)-&gt;ob_type==(PyTypeObject*)&amp;XaqWrappertype)
#define WRAPPER(O) ((Wrapper*)(O))

static PyObject *
Wrapper__init__(Wrapper *self, PyObject *args)
{
  PyObject *obj, *container;

  UNLESS(PyArg_Parse(args,"(OO)",&amp;obj,&amp;container)) return NULL;

  if (self == WRAPPER(obj)) {
  	PyErr_SetString(PyExc_ValueError,
		"Cannot wrap acquisition wrapper in itself (Wrapper__init__)");
  	return NULL;
  }

  Py_INCREF(obj);
  Py_INCREF(container);
  self-&gt;obj=obj;
  self-&gt;container=container;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.118">static PyObject *
__of__(PyObject *inst, PyObject *parent)
{
  PyObject *r, *t;

  UNLESS(r=PyObject_GetAttr(inst, py__of__)) return NULL;
  UNLESS(t=PyTuple_New(1)) goto err;
  PyTuple_SET_ITEM(t,0,parent);
  ASSIGN(r,PyObject_CallObject(r,t));
  PyTuple_SET_ITEM(t,0,NULL);
  Py_DECREF(t);

  if (r 
      &amp;&amp; r-&gt;ob_refcnt==1
      &amp;&amp; isWrapper(r) 
      &amp;&amp; WRAPPER(r)-&gt;container &amp;&amp; isWrapper(WRAPPER(r)-&gt;container)
      )
    while (WRAPPER(r)-&gt;obj &amp;&amp; isWrapper(WRAPPER(r)-&gt;obj)
	   &amp;&amp; (WRAPPER(WRAPPER(r)-&gt;obj)-&gt;container == 
	       WRAPPER(WRAPPER(r)-&gt;container)-&gt;obj)
	   )
      {
	/* Simplify wrapper */
	Py_XINCREF(WRAPPER(WRAPPER(r)-&gt;obj)-&gt;obj);
	ASSIGN(WRAPPER(r)-&gt;obj, WRAPPER(WRAPPER(r)-&gt;obj)-&gt;obj);
      }

  return r;
err:
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.119">static Wrapper *freeWrappers=0;
static int nWrappers=0;
#define MAX_CACHED_WRAPPERS 200

static PyObject *
newWrapper(PyObject *obj, PyObject *container, PyTypeObject *Wrappertype)
{
  Wrapper *self;
  
  if (freeWrappers)
    {
      self=freeWrappers;
      freeWrappers=(Wrapper*)self-&gt;obj;
      _Py_NewReference((PyObject *)self);
      assert(self-&gt;ob_refcnt == 1);
      self-&gt;ob_type=Wrappertype;
      nWrappers--;
    }
  else
    {
      UNLESS(self = PyObject_NEW(Wrapper, Wrappertype)) return NULL;
    }

  if (self == WRAPPER(obj)) {
  	PyErr_SetString(PyExc_ValueError,
		"Cannot wrap acquisition wrapper in itself (newWrapper)");
	Py_DECREF(self);
	return NULL;
  }

  Py_INCREF(Wrappertype);
  Py_XINCREF(obj);
  Py_XINCREF(container);
  self-&gt;obj=obj;
  self-&gt;container=container;
  return OBJECT(self);
}
</t>
<t tx="ekr.20040104185809.120">static void
Wrapper_dealloc(Wrapper *self)     
{
  Py_XDECREF(self-&gt;obj);
  Py_XDECREF(self-&gt;container);
  Py_DECREF(self-&gt;ob_type);

  if (nWrappers &lt; MAX_CACHED_WRAPPERS)
    {
      self-&gt;obj=OBJECT(freeWrappers);
      freeWrappers=self;
      nWrappers++;
    }
  else 
    {
      PyObject_DEL(self);
    }
}
</t>
<t tx="ekr.20040104185809.121">static PyObject *
Wrapper_special(Wrapper *self, char *name, PyObject *oname)
{
  PyObject *r=0;

  switch(*name)
    {
    case 'b':
      if (strcmp(name,"base")==0)
	{
	  if (self-&gt;obj)
	    {
	      r=self-&gt;obj;
	      while (isWrapper(r) &amp;&amp; WRAPPER(r)-&gt;obj) r=WRAPPER(r)-&gt;obj;
	    }
	  else r=Py_None;
	  Py_INCREF(r);
	  return r;
	}
      break;
    case 'p':
      if (strcmp(name,"parent")==0)
	{
	  if (self-&gt;container) r=self-&gt;container;
	  else r=Py_None;
	  Py_INCREF(r);
	  return r;
	}
      break;
    case 's':
      if (strcmp(name,"self")==0)
	{
	  if (self-&gt;obj) r=self-&gt;obj;
	  else r=Py_None;
	  Py_INCREF(r);
	  return r;
	}
      break;
    case 'e':
      if (strcmp(name,"explicit")==0)
	{
	  if (self-&gt;ob_type != (PyTypeObject *)&amp;XaqWrappertype)
	    return newWrapper(self-&gt;obj, self-&gt;container, 
			      (PyTypeObject *)&amp;XaqWrappertype);
	  Py_INCREF(self);
	  return OBJECT(self);
	}
      break;
    case 'a':
      if (strcmp(name,"acquire")==0)
	{
	  return Py_FindAttr(OBJECT(self),oname);
	}
      break;
    case 'c':
      if (strcmp(name,"chain")==0)
	{
	  if ((r = PyList_New(0)))
	    while (1)
	      {
		if (PyList_Append(r,OBJECT(self)) &gt;= 0)
		  {
		    if (isWrapper(self) &amp;&amp; self-&gt;container) 
		      {
			self=WRAPPER(self-&gt;container);
			continue;
		      }
		  }
		else
		  {
		    Py_DECREF(r);
		  }
		break;
	      }
	  return r;
	}
      break;
    case 'i':
      if (strcmp(name,"inContextOf")==0)
	{
	  return Py_FindAttr(OBJECT(self),oname);
	}
      if (strcmp(name,"inner")==0)
	{
	  if (self-&gt;obj)
	    {
	      r=self-&gt;obj;
	      while (isWrapper(r) &amp;&amp; WRAPPER(r)-&gt;obj) 
		{
		  self=WRAPPER(r);
		  r=WRAPPER(r)-&gt;obj;
		}
	      r=OBJECT(self);
	    }
	  else r=Py_None;

	  Py_INCREF(r);
	  return r;
	}
      break;

    case 'u':
      if (strcmp(name,"uncle")==0)
	{
	  return PyString_FromString("Bob");
	}
      break;
      
    }

  return NULL;
}
</t>
<t tx="ekr.20040104185809.122">static int
apply_filter(PyObject *filter, PyObject *inst, PyObject *oname, PyObject *r,
	     PyObject *extra, PyObject *orig)
{
  PyObject *fr;
  int ir;

  UNLESS(fr=PyTuple_New(5)) goto err;
  PyTuple_SET_ITEM(fr,0,orig);
  Py_INCREF(orig);
  PyTuple_SET_ITEM(fr,1,inst);
  Py_INCREF(inst);
  PyTuple_SET_ITEM(fr,2,oname);
  Py_INCREF(oname);
  PyTuple_SET_ITEM(fr,3,r);
  Py_INCREF(r);
  PyTuple_SET_ITEM(fr,4,extra);
  Py_INCREF(extra);
  UNLESS_ASSIGN(fr,PyObject_CallObject(filter, fr)) goto err;
  ir=PyObject_IsTrue(fr);
  Py_DECREF(fr);
  if (ir) return 1;
  Py_DECREF(r);
  return 0;
err:
  Py_DECREF(r);
  return -1;
}
</t>
<t tx="ekr.20040104185809.123">static PyObject *
Wrapper_acquire(Wrapper *self, PyObject *oname, 
		PyObject *filter, PyObject *extra, PyObject *orig,
		int explicit, int containment);

static PyObject *
Wrapper_findattr(Wrapper *self, PyObject *oname,
		PyObject *filter, PyObject *extra, PyObject *orig,
		int sob, int sco, int explicit, int containment)
{
  PyObject *r, *v, *tb;
  char *name="";

  if (PyString_Check(oname)) name=PyString_AS_STRING(oname);
  if (*name=='a' &amp;&amp; name[1]=='q' &amp;&amp; name[2]=='_')
    if ((r=Wrapper_special(self, name+3, oname)))
      {
	if (filter)
	  switch(apply_filter(filter,OBJECT(self),oname,r,extra,orig))
	    {
	    case -1: return NULL;
	    case 1: return r;
	    }
	else return r;
      }
    else PyErr_Clear();
  else if (*name=='_' &amp;&amp; name[1]=='_' &amp;&amp; strcmp(name+2,"reduce__")==0)
    {
      PyErr_SetString(PyExc_TypeError, 
                      "Can't pickle objects in acquisition wrappers.");
      return NULL;
    }

  /* If we are doing a containment search, then replace self with aq_inner */
  if (containment)
    while (self-&gt;obj &amp;&amp; isWrapper(self-&gt;obj))
      self=WRAPPER(self-&gt;obj);

  if (sob &amp;&amp; self-&gt;obj)
    {
      if (isWrapper(self-&gt;obj))
	{
	  if (self == WRAPPER(self-&gt;obj)) {
	  	PyErr_SetString(PyExc_RuntimeError,
			"Recursion detected in acquisition wrapper");
		return NULL;
	  }
	  if ((r=Wrapper_findattr(WRAPPER(self-&gt;obj),
				 oname, filter, extra, orig, 1, 

				 /* Search object container if explicit,
				    or object is implicit acquirer */
				 explicit ||
				 self-&gt;obj-&gt;ob_type == 
				 (PyTypeObject*)&amp;Wrappertype,
				  explicit, containment)))
	    {
	      if (PyECMethod_Check(r) &amp;&amp; PyECMethod_Self(r)==self-&gt;obj)
		ASSIGN(r,PyECMethod_New(r,OBJECT(self)));
	      else if (has__of__(r)) ASSIGN(r,__of__(r,OBJECT(self)));
	      return r;
	    }

	  PyErr_Fetch(&amp;r,&amp;v,&amp;tb);
	  if (r &amp;&amp; (r != PyExc_AttributeError))
	    {
	      PyErr_Restore(r,v,tb);
	      return NULL;
	    }
	  Py_XDECREF(r); Py_XDECREF(v); Py_XDECREF(tb);
	  r=NULL;
	}
      else if ((r=PyObject_GetAttr(self-&gt;obj,oname)))
	{
	  if (r==Acquired)
	    {
	      Py_DECREF(r);
	      return Wrapper_acquire(self, oname, filter, extra, orig, 1, 
				     containment);
	    }

	  if (PyECMethod_Check(r) &amp;&amp; PyECMethod_Self(r)==self-&gt;obj)
	    ASSIGN(r,PyECMethod_New(r,OBJECT(self)));
	  else if (has__of__(r)) ASSIGN(r,__of__(r,OBJECT(self)));

	  if (filter)
	    switch(apply_filter(filter,OBJECT(self),oname,r,extra,orig))
	      {
	      case -1: return NULL;
	      case 1: return r;
	      }
	  else return r;
	}
      else {
	PyErr_Fetch(&amp;r,&amp;v,&amp;tb);
	if (r != PyExc_AttributeError)
	  {
	    PyErr_Restore(r,v,tb);
	    return NULL;
	  }
	Py_XDECREF(r); Py_XDECREF(v); Py_XDECREF(tb);
	r=NULL;
      }
      PyErr_Clear();
    }

  if (sco &amp;&amp; (*name != '_' || explicit)) 
    return Wrapper_acquire(self, oname, filter, extra, orig, explicit, 
			   containment);

  PyErr_SetObject(PyExc_AttributeError,oname);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.124">static PyObject *
Wrapper_acquire(Wrapper *self, PyObject *oname, 
		PyObject *filter, PyObject *extra, PyObject *orig,
		int explicit, int containment)
{
  PyObject *r;
  int sob=1, sco=1;

  if (self-&gt;container)
    {
      if (isWrapper(self-&gt;container))
	{
	  if (self-&gt;obj &amp;&amp; isWrapper(self-&gt;obj))
	    {
	      /* Try to optimize search by recognizing repeated obs in path */
	      if (WRAPPER(self-&gt;obj)-&gt;container==
		  WRAPPER(self-&gt;container)-&gt;container) 
		sco=0;
	      else if (WRAPPER(self-&gt;obj)-&gt;container==
		      WRAPPER(self-&gt;container)-&gt;obj)  
		sob=0;
	   }

	  r=Wrapper_findattr((Wrapper*)self-&gt;container,
			     oname, filter, extra, orig, sob, sco, explicit, 
			     containment);
	  
	  if (r &amp;&amp; has__of__(r)) ASSIGN(r,__of__(r,OBJECT(self)));
	  return r;
	}
      else
	{
	  if ((r=PyObject_GetAttr(self-&gt;container,oname))) {
	    if (r == Acquired)
	      {
		Py_DECREF(r);
	      }
	    else {
	      if (filter)
		switch(apply_filter(filter,self-&gt;container,oname,r,
				    extra,orig))
		  {
		  case -1: 
		    return NULL;
		  case 1: 
		    if (has__of__(r)) ASSIGN(r,__of__(r,OBJECT(self)));
		    return r;
		  }
	      else 
		{
		  if (has__of__(r)) ASSIGN(r,__of__(r,OBJECT(self)));
		  return r;
		}
	    }
	  }
	}
    }
  
  PyErr_SetObject(PyExc_AttributeError, oname);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.125">static PyObject *
Wrapper_getattro(Wrapper *self, PyObject *oname)
{
  if (self-&gt;obj || self-&gt;container)
    return Wrapper_findattr(self, oname, NULL, NULL, NULL, 1, 1, 0, 0);

  /* Maybe we are getting initialized? */
  return Py_FindAttr(OBJECT(self),oname);
}
</t>
<t tx="ekr.20040104185809.126">static PyObject *
Xaq_getattro(Wrapper *self, PyObject *oname)
{
  char *name="";

  /* Special case backward-compatible acquire method. */
  if (PyString_Check(oname)) name=PyString_AS_STRING(oname);
  if (*name=='a' &amp;&amp; name[1]=='c' &amp;&amp; strcmp(name+2,"quire")==0)
    return Py_FindAttr(OBJECT(self),oname);

  if (self-&gt;obj || self-&gt;container)
    return Wrapper_findattr(self, oname, NULL, NULL, NULL, 1, 0, 0, 0);

  /* Maybe we are getting initialized? */
  return Py_FindAttr(OBJECT(self),oname);
}
</t>
<t tx="ekr.20040104185809.127">static int
Wrapper_setattro(Wrapper *self, PyObject *oname, PyObject *v)
{
  char *name="";

  /* Allow assignment to parent, to change context. */
  if (PyString_Check(oname)) name=PyString_AS_STRING(oname);
  if (*name=='a' &amp;&amp; name[1]=='q' &amp;&amp; name[2]=='_' 
      &amp;&amp; strcmp(name+3,"parent")==0)
    {
      Py_XINCREF(v);
      ASSIGN(self-&gt;container, v);
      return 0;
    }

  if (self-&gt;obj)
    {
      /* Unwrap passed in wrappers! */
      while (v &amp;&amp; isWrapper(v))
	v=WRAPPER(v)-&gt;obj;

      if (v) return PyObject_SetAttr(self-&gt;obj, oname, v);
      else   return PyObject_DelAttr(self-&gt;obj, oname);
    }

  PyErr_SetString(PyExc_AttributeError, 
		  "Attempt to set attribute on empty acquisition wrapper");
  return -1;
}
</t>
<t tx="ekr.20040104185809.128">static int
Wrapper_compare(Wrapper *self, PyObject *w)
{
  PyObject *obj, *wobj;
  PyObject *m;
  int r;

  if (OBJECT(self) == w) return 0;

  UNLESS (m=PyObject_GetAttr(OBJECT(self), py__cmp__))
    {
      /* Unwrap self completely -&gt; obj. */
      while (self-&gt;obj &amp;&amp; isWrapper(self-&gt;obj))
        self=WRAPPER(self-&gt;obj);
      obj = self-&gt;obj;
      /* Unwrap w completely -&gt; wobj. */
      if (isWrapper(w))
        {
          while (WRAPPER(w)-&gt;obj &amp;&amp; isWrapper(WRAPPER(w)-&gt;obj))
            w=WRAPPER(w)-&gt;obj;
          wobj = WRAPPER(w)-&gt;obj;
        }
      else wobj = w;

      PyErr_Clear();
      if (obj == wobj) return 0;
      return (obj &lt; w) ? -1 : 1;
    }

  ASSIGN(m, PyObject_CallFunction(m, "O", w));
  UNLESS (m) return -1;
  
  r=PyInt_AsLong(m);

  Py_DECREF(m);

  return r;  
}
</t>
<t tx="ekr.20040104185809.129">static PyObject *
Wrapper_repr(Wrapper *self)
{
  PyObject *r;

  if ((r=PyObject_GetAttr(OBJECT(self),py__repr__)))
    {
      ASSIGN(r,PyObject_CallFunction(r,NULL,NULL));
      return r;
    }
  else
    {
      PyErr_Clear();
      return PyObject_Repr(self-&gt;obj);
    }
}
</t>
<t tx="ekr.20040104185809.130">static PyObject *
Wrapper_str(Wrapper *self)
{
  PyObject *r;

  if ((r=PyObject_GetAttr(OBJECT(self),py__str__)))
    {
      ASSIGN(r,PyObject_CallFunction(r,NULL,NULL));
      return r;
    }
  else
    {
      PyErr_Clear();
      return PyObject_Str(self-&gt;obj);
    }
}
</t>
<t tx="ekr.20040104185809.131">static long
Wrapper_hash(Wrapper *self)
{
  return PyObject_Hash(self-&gt;obj);
}
</t>
<t tx="ekr.20040104185809.132">static PyObject *
Wrapper_call(Wrapper *self, PyObject *args, PyObject *kw)
{
  Py_INCREF(args);
  return CallMethodO(OBJECT(self),py__call__,args,kw);
}
</t>
<t tx="ekr.20040104185809.133">@ Code to handle accessing Wrapper objects as sequence objects
@c

static int
Wrapper_length(Wrapper *self)
{
  long l;
  PyObject *r;

  UNLESS(r=PyObject_GetAttr(OBJECT(self), py__len__)) return -1;
  UNLESS_ASSIGN(r,PyObject_CallObject(r,NULL)) return -1;
  l=PyInt_AsLong(r);
  Py_DECREF(r);
  return l;
}
</t>
<t tx="ekr.20040104185809.134">static PyObject *
Wrapper_add(Wrapper *self, PyObject *bb)
{
  return CallMethodO(OBJECT(self),py__add__,Build("(O)", bb) ,NULL);
}
</t>
<t tx="ekr.20040104185809.135">static PyObject *
Wrapper_mul(Wrapper *self, int  n)
{
  return CallMethodO(OBJECT(self),py__mul__,Build("(i)", n),NULL);
}
</t>
<t tx="ekr.20040104185809.136">static PyObject *
Wrapper_item(Wrapper *self, int  i)
{
  return CallMethodO(OBJECT(self),py__getitem__, Build("(i)", i),NULL);
}
</t>
<t tx="ekr.20040104185809.137">static PyObject *
Wrapper_slice(Wrapper *self, int  ilow, int  ihigh)
{
  return CallMethodO(OBJECT(self),py__getslice__,
		     Build("(ii)", ilow, ihigh),NULL);
}
</t>
<t tx="ekr.20040104185809.138">static int
Wrapper_ass_item(Wrapper *self, int  i, PyObject *v)
{
  if (v)
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__setitem__,
			   Build("(iO)", i, v),NULL))
	return -1;
    }
  else
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__delitem__,
			   Build("(i)", i),NULL))
	return -1;
    }
  Py_DECREF(v);
  return 0;
}
</t>
<t tx="ekr.20040104185809.139">static int
Wrapper_ass_slice(Wrapper *self, int  ilow, int  ihigh, PyObject *v)
{
  if (v)
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__setslice__,
			   Build("(iiO)", ilow, ihigh, v),NULL))
	return -1;
    }
  else
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__delslice__,
			   Build("(ii)", ilow, ihigh),NULL))
	return -1;
    }
  Py_DECREF(v);
  return 0;
}
</t>
<t tx="ekr.20040104185809.140">static PySequenceMethods Wrapper_as_sequence = {
	(inquiry)Wrapper_length,		/*sq_length*/
	(binaryfunc)Wrapper_add,		/*sq_concat*/
	(intargfunc)Wrapper_mul,		/*sq_repeat*/
	(intargfunc)Wrapper_item,		/*sq_item*/
	(intintargfunc)Wrapper_slice,		/*sq_slice*/
	(intobjargproc)Wrapper_ass_item,	/*sq_ass_item*/
	(intintobjargproc)Wrapper_ass_slice,	/*sq_ass_slice*/
};

/* -------------------------------------------------------------- */

/* Code to access Wrapper objects as mappings */

static PyObject *
Wrapper_subscript(Wrapper *self, PyObject *key)
{
  return CallMethodO(OBJECT(self),py__getitem__,Build("(O)", key),NULL);
}
</t>
<t tx="ekr.20040104185809.141">static int
Wrapper_ass_sub(Wrapper *self, PyObject *key, PyObject *v)
{
  if (v)
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__setitem__,
			   Build("(OO)", key, v),NULL))
	return -1;
    }
  else
    {
      UNLESS(v=CallMethodO(OBJECT(self),py__delitem__,
			   Build("(O)", key),NULL))
	return -1;
    }
  Py_XDECREF(v);
  return 0;
}
</t>
<t tx="ekr.20040104185809.142">static PyMappingMethods Wrapper_as_mapping = {
  (inquiry)Wrapper_length,		/*mp_length*/
  (binaryfunc)Wrapper_subscript,	/*mp_subscript*/
  (objobjargproc)Wrapper_ass_sub,	/*mp_ass_subscript*/
};

/* -------------------------------------------------------------- */

/* Code to access Wrapper objects as numbers */

static PyObject *
Wrapper_sub(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__sub__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.143">static PyObject *
Wrapper_div(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__div__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.144">static PyObject *
Wrapper_mod(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__mod__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.145">static PyObject *
Wrapper_divmod(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__divmod__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.146">static PyObject *
Wrapper_pow(Wrapper *self, PyObject *o, PyObject *m)
{
  return CallMethodO(OBJECT(self),py__pow__,Build("(OO)", o, m),NULL);
}
</t>
<t tx="ekr.20040104185809.147">static PyObject *
Wrapper_neg(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__neg__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.148">static PyObject *
Wrapper_pos(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__pos__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.149">static PyObject *
Wrapper_abs(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__abs__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.150">static PyObject *
Wrapper_invert(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__invert__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.151">static PyObject *
Wrapper_lshift(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__lshift__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.152">static PyObject *
Wrapper_rshift(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__rshift__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.153">static PyObject *
Wrapper_and(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__and__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.154">static PyObject *
Wrapper_xor(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__xor__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.155">static PyObject *
Wrapper_or(Wrapper *self, PyObject *o)
{
  return CallMethodO(OBJECT(self),py__or__,Build("(O)", o),NULL);
}
</t>
<t tx="ekr.20040104185809.156">static int 
Wrapper_coerce(Wrapper **self, PyObject **o)
{
  PyObject *m;

  UNLESS (m=PyObject_GetAttr(OBJECT(*self), py__coerce__))
    {
      PyErr_Clear();
      Py_INCREF(*self);
      Py_INCREF(*o);
      return 0;
    }

  ASSIGN(m, PyObject_CallFunction(m, "O", *o));
  UNLESS (m) return -1;

  UNLESS (PyArg_ParseTuple(m,"OO", self, o)) goto err;
  Py_INCREF(*self);
  Py_INCREF(*o);
  Py_DECREF(m);
  return 0;

err:
  Py_DECREF(m);
  return -1;  
}
</t>
<t tx="ekr.20040104185809.157">static PyObject *
Wrapper_int(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__int__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.158">static PyObject *
Wrapper_long(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__long__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.159">static PyObject *
Wrapper_float(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__float__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.160">static PyObject *
Wrapper_oct(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__oct__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.161">static PyObject *
Wrapper_hex(Wrapper *self)
{
  return CallMethodO(OBJECT(self), py__hex__, NULL, NULL);
}
</t>
<t tx="ekr.20040104185809.162">static int
Wrapper_nonzero(Wrapper *self)
{
  long l;
  PyObject *r;

  UNLESS(r=PyObject_GetAttr(OBJECT(self), py__nonzero__))
    {
      PyErr_Clear();

      /* Try len */
      UNLESS(r=PyObject_GetAttr(OBJECT(self), py__len__))
      {
        /* No len, it's true :-) */
        PyErr_Clear();
        return 1;
      }
    }

  UNLESS_ASSIGN(r,PyObject_CallObject(r,NULL)) return -1;
  l=PyInt_AsLong(r);
  Py_DECREF(r);
  return l;
}
</t>
<t tx="ekr.20040104185809.163">static PyNumberMethods Wrapper_as_number = {
	(binaryfunc)Wrapper_add,	/*nb_add*/
	(binaryfunc)Wrapper_sub,	/*nb_subtract*/
	(binaryfunc)Wrapper_mul,	/*nb_multiply*/
	(binaryfunc)Wrapper_div,	/*nb_divide*/
	(binaryfunc)Wrapper_mod,	/*nb_remainder*/
	(binaryfunc)Wrapper_divmod,	/*nb_divmod*/
	(ternaryfunc)Wrapper_pow,	/*nb_power*/
	(unaryfunc)Wrapper_neg,		/*nb_negative*/
	(unaryfunc)Wrapper_pos,		/*nb_positive*/
	(unaryfunc)Wrapper_abs,		/*nb_absolute*/
	(inquiry)Wrapper_nonzero,	/*nb_nonzero*/
	(unaryfunc)Wrapper_invert,	/*nb_invert*/
	(binaryfunc)Wrapper_lshift,	/*nb_lshift*/
	(binaryfunc)Wrapper_rshift,	/*nb_rshift*/
	(binaryfunc)Wrapper_and,	/*nb_and*/
	(binaryfunc)Wrapper_xor,	/*nb_xor*/
	(binaryfunc)Wrapper_or,		/*nb_or*/
	(coercion)Wrapper_coerce,	/*nb_coerce*/
	(unaryfunc)Wrapper_int,		/*nb_int*/
	(unaryfunc)Wrapper_long,	/*nb_long*/
	(unaryfunc)Wrapper_float,	/*nb_float*/
	(unaryfunc)Wrapper_oct,		/*nb_oct*/
	(unaryfunc)Wrapper_hex,		/*nb_hex*/
};


/* -------------------------------------------------------- */


static char *acquire_args[] = {"object", "name", "filter", "extra", "explicit",
			       "default", "containment", NULL};

static PyObject *
Wrapper_acquire_method(Wrapper *self, PyObject *args, PyObject *kw)
{
  PyObject *name, *filter=0, *extra=Py_None;
  PyObject *expl=0, *defalt=0;
  int explicit=1;
  int containment=0;

  UNLESS (PyArg_ParseTupleAndKeywords(
	     args, kw, "O|OOOOi", acquire_args+1,
	     &amp;name, &amp;filter, &amp;extra, &amp;explicit, &amp;defalt, &amp;containment
	     ))
    return NULL;

  if (expl) explicit=PyObject_IsTrue(expl);

  if (filter==Py_None) filter=0;

  return Wrapper_findattr(self,name,filter,extra,OBJECT(self),1,
			  explicit || 
			  self-&gt;ob_type==(PyTypeObject*)&amp;Wrappertype,
			  explicit, containment);
}
</t>
<t tx="ekr.20040104185809.164">static PyObject *
Wrapper_inContextOf(Wrapper *self, PyObject *args)
{
  PyObject *subob, *o, *c;
  int inner=1;

  UNLESS(PyArg_ParseTuple(args,"O|i",&amp;o,&amp;inner)) return NULL;

  if (inner) {
    /* subob = self */
    subob = OBJECT(self);

    /* o = aq_base(o) */
    while (isWrapper(o) &amp;&amp; WRAPPER(o)-&gt;obj) o=WRAPPER(o)-&gt;obj;

    /* while 1: */
    while (1) {

      /*   if aq_base(subob) is o: return 1 */
      c = subob;
      while (isWrapper(c) &amp;&amp; WRAPPER(c)-&gt;obj) c = WRAPPER(c)-&gt;obj;
      if (c == o) return PyInt_FromLong(1);

      /*   self = aq_inner(subob) */
      /*   if self is None: break */
      if (isWrapper(subob)) {
        self = WRAPPER(subob);
        while (self-&gt;obj &amp;&amp; isWrapper(self-&gt;obj))
          self = WRAPPER(self-&gt;obj);
      }
      else break;

      /*   subob = aq_parent(self) */
      /*   if subob is None: break */
      if (self-&gt;container)
        subob = self-&gt;container;
      else break;
    }
  }
  else {
    /* Follow wrappers instead. */
    c = OBJECT(self);
    while (1) {
      if (c==o) return PyInt_FromLong(1);
      if (c &amp;&amp; isWrapper(c)) c=WRAPPER(c)-&gt;container;
      else break;
    }
  }

  return PyInt_FromLong(0);
}
</t>
<t tx="ekr.20040104185809.165">static struct PyMethodDef Wrapper_methods[] = {
  {"__init__", (PyCFunction)Wrapper__init__, 0,
   "Initialize an Acquirer Wrapper"},
  {"acquire", (PyCFunction)Wrapper_acquire_method, 
   METH_VARARGS|METH_KEYWORDS,
   "Get an attribute, acquiring it if necessary"},
  {"aq_acquire", (PyCFunction)Wrapper_acquire_method, 
   METH_VARARGS|METH_KEYWORDS,
   "Get an attribute, acquiring it if necessary"},
  {"aq_inContextOf", (PyCFunction)Wrapper_inContextOf, METH_VARARGS,
   "Test whether the object is currently in the context of the argument"},
  {NULL,		NULL}		/* sentinel */
};

static PyExtensionClass Wrappertype = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  "ImplicitAcquirerWrapper",		/*tp_name*/
  sizeof(Wrapper),       		/*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor)Wrapper_dealloc,		/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  (getattrfunc)0,			/*tp_getattr*/
  (setattrfunc)0,			/*tp_setattr*/
  (cmpfunc)Wrapper_compare,    		/*tp_compare*/
  (reprfunc)Wrapper_repr,      		/*tp_repr*/
  &amp;Wrapper_as_number,			/*tp_as_number*/
  &amp;Wrapper_as_sequence,			/*tp_as_sequence*/
  &amp;Wrapper_as_mapping,			/*tp_as_mapping*/
  (hashfunc)Wrapper_hash,      		/*tp_hash*/
  (ternaryfunc)Wrapper_call,		/*tp_call*/
  (reprfunc)Wrapper_str,       		/*tp_str*/
  (getattrofunc)Wrapper_getattro,	/*tp_getattr with object key*/
  (setattrofunc)Wrapper_setattro,      	/*tp_setattr with object key*/

  /* Space for future expansion */
  0L,0L,
  "Wrapper object for implicit acquisition", /* Documentation string */
  METHOD_CHAIN(Wrapper_methods),
  EXTENSIONCLASS_BINDABLE_FLAG,
};

static PyExtensionClass XaqWrappertype = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  "ExplicitAcquirerWrapper",		/*tp_name*/
  sizeof(Wrapper),       		/*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor)Wrapper_dealloc,		/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  (getattrfunc)0,			/*tp_getattr*/
  (setattrfunc)0,			/*tp_setattr*/
  (cmpfunc)Wrapper_compare,    		/*tp_compare*/
  (reprfunc)Wrapper_repr,      		/*tp_repr*/
  &amp;Wrapper_as_number,			/*tp_as_number*/
  &amp;Wrapper_as_sequence,			/*tp_as_sequence*/
  &amp;Wrapper_as_mapping,			/*tp_as_mapping*/
  (hashfunc)Wrapper_hash,      		/*tp_hash*/
  (ternaryfunc)Wrapper_call,		/*tp_call*/
  (reprfunc)Wrapper_str,       		/*tp_str*/
  (getattrofunc)Xaq_getattro,		/*tp_getattr with object key*/
  (setattrofunc)Wrapper_setattro,      	/*tp_setattr with object key*/

  /* Space for future expansion */
  0L,0L,
  "Wrapper object for explicit acquisition", /* Documentation string */
  METHOD_CHAIN(Wrapper_methods),
  EXTENSIONCLASS_BINDABLE_FLAG,
};

static PyObject *
acquire_of(PyObject *self, PyObject *args)
{
  PyObject *inst;

  UNLESS(PyArg_ParseTuple(args, "O", &amp;inst)) return NULL;

  UNLESS(PyExtensionInstance_Check(inst))
    {
      PyErr_SetString(PyExc_TypeError,
		      "attempt to wrap extension method using an object that\n"
		      "is not an extension class instance.");
      return NULL;
    }

  return newWrapper(self, inst, (PyTypeObject *)&amp;Wrappertype);
}
</t>
<t tx="ekr.20040104185809.166">static PyObject *
xaq_of(PyObject *self, PyObject *args)
{
  PyObject *inst;

  UNLESS(PyArg_ParseTuple(args, "O", &amp;inst)) return NULL;

  UNLESS(PyExtensionInstance_Check(inst))
    {
      PyErr_SetString(PyExc_TypeError,
		      "attempt to wrap extension method using an object that\n"
		      "is not an extension class instance.");
      return NULL;
    }

  return newWrapper(self, inst, (PyTypeObject *)&amp;XaqWrappertype);
}
</t>
<t tx="ekr.20040104185809.167">static struct PyMethodDef Acquirer_methods[] = {
  {"__of__",(PyCFunction)acquire_of, METH_VARARGS, 
   "__of__(context) -- return the object in a context"},
  
  {NULL,		NULL}		/* sentinel */
};

static struct PyMethodDef Xaq_methods[] = {
  {"__of__",(PyCFunction)xaq_of, METH_VARARGS,""},
  
  {NULL,		NULL}		/* sentinel */
};

static PyObject *
capi_aq_acquire(PyObject *self, PyObject *name, PyObject *filter,
	PyObject *extra, int explicit, PyObject *defalt, int containment)
{
  
  PyObject *result;

  if (filter==Py_None) filter=0;

  /* We got a wrapped object, so business as usual */
  if (isWrapper(self)) 
    return Wrapper_findattr(
	      WRAPPER(self), name, filter, extra, OBJECT(self),1,
	      explicit || 
	      WRAPPER(self)-&gt;ob_type==(PyTypeObject*)&amp;Wrappertype,
	      explicit, containment);
  
  /* Not wrapped and no filter, so just getattr */
  if (! filter) return PyObject_GetAttr(self, name);

  /* Crap, we've got to construct a wrapper so we can use Wrapper_findattr */
  UNLESS (self=newWrapper(self, NULL, (PyTypeObject*)&amp;Wrappertype)) 
    return NULL;
  
  result=Wrapper_findattr(WRAPPER(self), name, filter, extra, OBJECT(self),
			   1, 1, explicit, containment);

  /* get rid of temp wrapper */
  Py_DECREF(self);

  return result;
}
</t>
<t tx="ekr.20040104185809.168">static PyObject *
module_aq_acquire(PyObject *ignored, PyObject *args, PyObject *kw)
{
  PyObject *self;
  PyObject *name, *filter=0, *extra=Py_None;
  PyObject *expl=0, *defalt=0;
  int explicit=1, containment=0;

  UNLESS (PyArg_ParseTupleAndKeywords(
	     args, kw, "OO|OOOOi", acquire_args,
	     &amp;self, &amp;name, &amp;filter, &amp;extra, &amp;expl, &amp;defalt, &amp;containment
	     ))
    return NULL;

  if (expl) explicit=PyObject_IsTrue(expl);

  return capi_aq_acquire(self, name, filter, extra, explicit, defalt,
  	containment);
}
</t>
<t tx="ekr.20040104185809.169">static PyObject *
capi_aq_get(PyObject *self, PyObject *name, PyObject *defalt, int containment)
{
  PyObject *result = NULL;
  /* We got a wrapped object, so business as usual */
  if (isWrapper(self)) 
    result=Wrapper_findattr(WRAPPER(self), name, 0, 0, OBJECT(self), 1, 1, 1, 
		       containment);
  else
    result=PyObject_GetAttr(self, name);

  if (! result &amp;&amp; defalt)
    {
      PyErr_Clear();
      result=defalt;
      Py_INCREF(result);
    }
  
  return result;
}
</t>
<t tx="ekr.20040104185809.170">static PyObject *
module_aq_get(PyObject *r, PyObject *args)
{
  PyObject *self, *name, *defalt=0;
  int containment=0;
  
  UNLESS (PyArg_ParseTuple(args, "OO|Oi", 
			   &amp;self, &amp;name, &amp;defalt, &amp;containment
			   )) return NULL;
  return capi_aq_get(self, name, defalt, containment);
}
</t>
<t tx="ekr.20040104185809.171">static int 
capi_aq_iswrapper(PyObject *self) {
	return isWrapper(self);
}
</t>
<t tx="ekr.20040104185809.172">static PyObject *
capi_aq_base(PyObject *self)
{
  PyObject *result;
  if (! isWrapper(self)) 
    {
      Py_INCREF(self);
      return self;
    }
  
  if (WRAPPER(self)-&gt;obj)
    {
      result=WRAPPER(self)-&gt;obj;
      while (isWrapper(result) &amp;&amp; WRAPPER(result)-&gt;obj)
      	result=WRAPPER(result)-&gt;obj;
    }
  else result=Py_None;
  Py_INCREF(result);
  return result;
}
</t>
<t tx="ekr.20040104185809.173">static PyObject *
module_aq_base(PyObject *ignored, PyObject *args)
{
  PyObject *self;
  UNLESS (PyArg_ParseTuple(args, "O", &amp;self)) return NULL;

  return capi_aq_base(self);
}
</t>
<t tx="ekr.20040104185809.174">static PyObject *
capi_aq_parent(PyObject *self)
{
  PyObject *result=Py_None;

  if (isWrapper(self) &amp;&amp; WRAPPER(self)-&gt;container)
  	result=WRAPPER(self)-&gt;container;

  Py_INCREF(result);
  return result;
}
</t>
<t tx="ekr.20040104185809.175">static PyObject *
module_aq_parent(PyObject *ignored, PyObject *args)
{
  PyObject *self;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;self)) return NULL;

  return capi_aq_parent(self);
}
</t>
<t tx="ekr.20040104185809.176">static PyObject *
capi_aq_self(PyObject *self)
{
  PyObject *result;
  if (! isWrapper(self)) 
    {
      Py_INCREF(self);
      return self;
    }
  
  if (WRAPPER(self)-&gt;obj) result=WRAPPER(self)-&gt;obj;
  else result=Py_None;

  Py_INCREF(result);
  return result;
}
</t>
<t tx="ekr.20040104185809.177">static PyObject *
module_aq_self(PyObject *ignored, PyObject *args)
{
  PyObject *self;
  UNLESS (PyArg_ParseTuple(args, "O", &amp;self)) return NULL;
  return capi_aq_self(self);
}
</t>
<t tx="ekr.20040104185809.178">static PyObject *
capi_aq_inner(PyObject *self)
{
  PyObject *result;
  if (! isWrapper(self)) 
    {
      Py_INCREF(self);
      return self;
    }

  if (WRAPPER(self)-&gt;obj)
    {
      result=WRAPPER(self)-&gt;obj;
      while (isWrapper(result) &amp;&amp; WRAPPER(result)-&gt;obj) 
	{
	  self=result;
	  result=WRAPPER(result)-&gt;obj;
	}
      result=self;
    }
  else result=Py_None;

  Py_INCREF(result);
  return result;
}
</t>
<t tx="ekr.20040104185809.179">static PyObject *
module_aq_inner(PyObject *ignored, PyObject *args)
{
  PyObject *self;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;self)) return NULL;
  return capi_aq_inner(self);
}
</t>
<t tx="ekr.20040104185809.180">static PyObject *
capi_aq_chain(PyObject *self, int containment)
{
  PyObject *result;

  UNLESS (result=PyList_New(0)) return NULL;

  while (1)
    {
      if (isWrapper(self))
	{
	  if (WRAPPER(self)-&gt;obj)
	    {
	      if (containment)
		while (WRAPPER(self)-&gt;obj &amp;&amp; isWrapper(WRAPPER(self)-&gt;obj))
		  self=WRAPPER(self)-&gt;obj;
	      if (PyList_Append(result,OBJECT(self)) &lt; 0)
		goto err;
	    }
	  if (WRAPPER(self)-&gt;container) 
	    {
	      self=WRAPPER(self)-&gt;container;
	      continue;
	    }
	}
      else
	if (PyList_Append(result, self) &lt; 0)
	  goto err;

      break;
    }
  
  return result;
err:
  Py_DECREF(result);
  return result;
}
</t>
<t tx="ekr.20040104185809.181">static PyObject *
module_aq_chain(PyObject *ignored, PyObject *args)
{
  PyObject *self;
  int containment=0;

  UNLESS (PyArg_ParseTuple(args, "O|i", &amp;self, &amp;containment))
    return NULL;

  return capi_aq_chain(self, containment);
}
</t>
<t tx="ekr.20040104185809.182">static struct PyMethodDef methods[] = {
  {"aq_acquire", (PyCFunction)module_aq_acquire, METH_VARARGS|METH_KEYWORDS, 
   "aq_acquire(ob, name [, filter, extra, explicit]) -- "
   "Get an attribute, acquiring it if necessary"
  },
  {"aq_get", (PyCFunction)module_aq_get, METH_VARARGS,
   "aq_get(ob, name [, default]) -- "
   "Get an attribute, acquiring it if necessary."
  },
  {"aq_base", (PyCFunction)module_aq_base, METH_VARARGS, 
   "aq_base(ob) -- Get the object unwrapped"},
  {"aq_parent", (PyCFunction)module_aq_parent, METH_VARARGS, 
   "aq_parent(ob) -- Get the parent of an object"},
  {"aq_self", (PyCFunction)module_aq_self, METH_VARARGS, 
   "aq_self(ob) -- Get the object with the outermost wrapper removed"},
  {"aq_inner", (PyCFunction)module_aq_inner, METH_VARARGS, 
   "aq_inner(ob) -- "
   "Get the object with alll but the innermost wrapper removed"},
  {"aq_chain", (PyCFunction)module_aq_chain, METH_VARARGS, 
   "aq_chain(ob [, containment]) -- "
   "Get a list of objects in the acquisition environment"},
  {NULL,	NULL}
};

void
initAcquisition(void)
{
  PyObject *m, *d;
  PyObject *api;

  PURE_MIXIN_CLASS(Acquirer,
    "Base class for objects that implicitly"
    " acquire attributes from containers\n"
    , Acquirer_methods);
  PURE_MIXIN_CLASS(ExplicitAcquirer,
    "Base class for objects that explicitly"
    " acquire attributes from containers\n"
    , Xaq_methods);

  UNLESS(ExtensionClassImported) return;

  UNLESS(Acquired=PyString_FromStringAndSize(NULL,42)) return;
  strcpy(PyString_AsString(Acquired),
	 "&lt;Special Object Used to Force Acquisition&gt;");

  /* Create the module and add the functions */
  m = Py_InitModule4("Acquisition", methods,
	   "Provide base classes for acquiring objects\n\n"
	   "$Id: Acquisition.c,v 1.59 2002/06/10 22:48:46 jeremy Exp $\n",
		     OBJECT(NULL),PYTHON_API_VERSION);

  d = PyModule_GetDict(m);
  init_py_names();
  PyExtensionClass_Export(d,"Acquirer",AcquirerType);
  PyExtensionClass_Export(d,"ImplicitAcquisitionWrapper",Wrappertype);
  PyExtensionClass_Export(d,"ExplicitAcquirer",ExplicitAcquirerType);
  PyExtensionClass_Export(d,"ExplicitAcquisitionWrapper",XaqWrappertype);

  /* Create aliases */
  PyDict_SetItemString(d,"Implicit",OBJECT(&amp;AcquirerType));
  PyDict_SetItemString(d,"Explicit",OBJECT(&amp;ExplicitAcquirerType));
  PyDict_SetItemString(d,"Acquired",Acquired);

  AcquisitionCAPI.AQ_Acquire = capi_aq_acquire;
  AcquisitionCAPI.AQ_Get = capi_aq_get;
  AcquisitionCAPI.AQ_IsWrapper = capi_aq_iswrapper;
  AcquisitionCAPI.AQ_Base = capi_aq_base;
  AcquisitionCAPI.AQ_Parent = capi_aq_parent;
  AcquisitionCAPI.AQ_Self = capi_aq_self;
  AcquisitionCAPI.AQ_Inner = capi_aq_inner;
  AcquisitionCAPI.AQ_Chain = capi_aq_chain;

  api = PyCObject_FromVoidPtr(&amp;AcquisitionCAPI, NULL);
  PyDict_SetItemString(d, "AcquisitionCAPI", api);
  Py_DECREF(api);

  CHECK_FOR_ERRORS("can't initialize module Acquisition");
}
</t>
<t tx="ekr.20040104185809.183">@language c

&lt;&lt; c copyright &gt;&gt;

#include "ExtensionClass.h"

&lt;&lt; ComputedAttribute declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185809.185">#define UNLESS(E) if(!(E))
#define OBJECT(O) ((PyObject*)(O))

typedef struct {
  PyObject_HEAD
  PyObject *callable;
  int level;
} CA;
</t>
<t tx="ekr.20040104185809.186">static PyObject *
CA__init__(CA *self, PyObject *args)
{
  PyObject *callable;
  int level=0;

  UNLESS(PyArg_ParseTuple(args,"O|i",&amp;callable, &amp;level)) return NULL;

  if (level &gt; 0) 
    {
      callable=PyObject_CallFunction(OBJECT(self-&gt;ob_type), "Oi", 
				     callable, self-&gt;level-1);
      UNLESS (callable) return NULL;
      self-&gt;level=level;
    }
  else
    {
      Py_INCREF(callable);
      self-&gt;level=0;
    }

  self-&gt;callable=callable;

  Py_INCREF(Py_None);
  return Py_None;
}</t>
<t tx="ekr.20040104185809.187">static void
CA_dealloc(CA *self)     
{
  Py_DECREF(self-&gt;callable);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.188">static PyObject *
CA_of(CA *self, PyObject *args)
{
  if (self-&gt;level &gt; 0) 
    {
      Py_INCREF(self-&gt;callable);
      return self-&gt;callable;
    }

  if (PyString_Check(self-&gt;callable))
    {
      /* Special case string as simple alias. */
      PyObject *o;

      UNLESS (PyArg_ParseTuple(args,"O", &amp;o)) return NULL;
      return PyObject_GetAttr(o, self-&gt;callable);
    }

  return PyObject_CallObject(self-&gt;callable, args);
}
</t>
<t tx="ekr.20040104185809.189">static struct PyMethodDef CA_methods[] = {
  {"__init__",(PyCFunction)CA__init__, METH_VARARGS, ""},
  {"__of__",  (PyCFunction)CA_of,      METH_VARARGS, ""},
  {NULL,		NULL}		/* sentinel */
};

static PyExtensionClass ComputedAttributeType = {
  PyObject_HEAD_INIT(NULL) 0,
  "ComputedAttribute", sizeof(CA),
  0,
  (destructor)CA_dealloc,
  0,0,0,0,0,   0,0,0,   0,0,0,0,0,   0,0,
  "ComputedAttribute(callable) -- Create a computed attribute",
  METHOD_CHAIN(CA_methods), 
  EXTENSIONCLASS_BINDABLE_FLAG
};

static struct PyMethodDef methods[] = {
  {NULL,		NULL}
};

void
initComputedAttribute(void)
{
  PyObject *m, *d;

  UNLESS(ExtensionClassImported) return;

  ComputedAttributeType.tp_getattro=
    (getattrofunc)PyExtensionClassCAPI-&gt;getattro;
  
  /* Create the module and add the functions */
  m = Py_InitModule4("ComputedAttribute", methods,
	   "Provide Computed Attributes\n\n"
	   "$Id: ComputedAttribute.c,v 1.7 2002/06/10 22:48:46 jeremy Exp $\n",
		     OBJECT(NULL),PYTHON_API_VERSION);

  d = PyModule_GetDict(m);
  PyExtensionClass_Export(d,"ComputedAttribute",ComputedAttributeType);
  CHECK_FOR_ERRORS("can't initialize module Acquisition");
}
</t>
<t tx="ekr.20040104185809.190">@language c

&lt;&lt; c copyright &gt;&gt;

static char ExtensionClass_module_documentation[] = 
"ExtensionClass - Classes implemented in c\n"
"\n"
"Built-in C classes are like Built-in types except that\n"
"they provide some of the behavior of Python classes:\n"
"\n"
"  - They provide access to unbound methods,\n"
"  - They can be called to create instances.\n"
"\n"
"$Id: ExtensionClass.c,v 1.57.2.1 2002/11/13 16:40:01 jeremy Exp $\n"
;

&lt;&lt; ExtensionClass #includes &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.191">#include "ExtensionClass.h"
</t>
<t tx="ekr.20040104185809.192">static void
PyVar_Assign(PyObject **v,  PyObject *e)
{
  Py_XDECREF(*v);
  *v=e;
}
</t>
<t tx="ekr.20040104185809.193">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if (!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define OBJECT(O) ((PyObject*)O)

/* Declarations for objects of type ExtensionClass */

staticforward PyExtensionClass ECType;

#define ExtensionClass_Check(O) ((O)-&gt;ob_type == (PyTypeObject*)&amp;ECType)
#define ExtensionInstance_Check(O) \
   ((O)-&gt;ob_type-&gt;ob_type == (PyTypeObject*)&amp;ECType)
#define AsExtensionClass(O) ((PyExtensionClass*)(O))
#define ExtensionClassOf(O) ((PyExtensionClass*)((O)-&gt;ob_type))
#define AsPyObject(O) ((PyObject*)(O))
#define NeedsToBeBound(O) \
   ((O)-&gt;ob_type-&gt;ob_type == (PyTypeObject*)&amp;ECType &amp;&amp; \
    (((PyExtensionClass*)((O)-&gt;ob_type))-&gt;class_flags &amp; \
     EXTENSIONCLASS_BINDABLE_FLAG))
#define HasMethodHook(O) \
   ((O)-&gt;ob_type-&gt;ob_type == (PyTypeObject*)&amp;ECType &amp;&amp; \
    (((PyExtensionClass*)((O)-&gt;ob_type))-&gt;class_flags &amp; \
     EXTENSIONCLASS_METHODHOOK_FLAG))

#define ALLOC_FREE(T) \
  if (free ## T) { \
      self=free ## T; \
      free ## T=(T*)self-&gt;self; \
      _Py_NewReference((PyObject *)self); \
      assert(self-&gt;ob_refcnt == 1); \
    } \
  else UNLESS(self = PyObject_NEW(T, &amp; T ## Type)) return NULL;

#define METH_BY_NAME (2 &lt;&lt; 16)

static PyObject *py__add__, *py__sub__, *py__mul__, *py__div__,
  *py__mod__, *py__pow__, *py__divmod__, *py__lshift__, *py__rshift__,
  *py__and__, *py__or__, *py__xor__, *py__coerce__, *py__neg__,
  *py__pos__, *py__abs__, *py__nonzero__, *py__inv__, *py__int__,
  *py__long__, *py__float__, *py__oct__, *py__hex__,
  *py__of__, *py__call__, *py__call_method__,
  *py__getitem__, *py__setitem__, *py__delitem__,
  *py__getslice__, *py__setslice__, *py__delslice__, *py__len__,
  *py__getattr__, *py__setattr__, *py__delattr__,
  *py__del__, *py__repr__, *py__str__, *py__class__, *py__name__,
  *py__hash__, *py__cmp__, *py__var_size__, *py__init__, *py__getinitargs__,
  *py__getstate__, *py__setstate__, *py__dict__, *pyclass_,
  *py__module__;

static PyObject *concat_fmt=0;
static PyObject *subclass_watcher=0;  /* Object that subclass events */

static void
init_py_names(void)
{
#define INIT_PY_NAME(N) py ## N = PyString_FromString(#N)
  INIT_PY_NAME(__add__);
  INIT_PY_NAME(__sub__);
  INIT_PY_NAME(__mul__);
  INIT_PY_NAME(__div__);
  INIT_PY_NAME(__mod__);
  INIT_PY_NAME(__pow__);
  INIT_PY_NAME(__divmod__);
  INIT_PY_NAME(__lshift__);
  INIT_PY_NAME(__rshift__);
  INIT_PY_NAME(__and__);
  INIT_PY_NAME(__or__);
  INIT_PY_NAME(__xor__);
  INIT_PY_NAME(__coerce__);
  INIT_PY_NAME(__neg__);
  INIT_PY_NAME(__pos__);
  INIT_PY_NAME(__abs__);
  INIT_PY_NAME(__nonzero__);
  INIT_PY_NAME(__inv__);
  INIT_PY_NAME(__int__);
  INIT_PY_NAME(__long__);
  INIT_PY_NAME(__float__);
  INIT_PY_NAME(__oct__);
  INIT_PY_NAME(__hex__);
  INIT_PY_NAME(__getitem__);
  INIT_PY_NAME(__setitem__);
  INIT_PY_NAME(__delitem__);
  INIT_PY_NAME(__getslice__);
  INIT_PY_NAME(__setslice__);
  INIT_PY_NAME(__delslice__);
  INIT_PY_NAME(__len__);
  INIT_PY_NAME(__of__);
  INIT_PY_NAME(__call__);
  INIT_PY_NAME(__call_method__);
  INIT_PY_NAME(__getattr__);
  INIT_PY_NAME(__setattr__);
  INIT_PY_NAME(__delattr__);
  INIT_PY_NAME(__del__);
  INIT_PY_NAME(__repr__);
  INIT_PY_NAME(__str__);
  INIT_PY_NAME(__class__);
  INIT_PY_NAME(__name__);
  INIT_PY_NAME(__hash__);
  INIT_PY_NAME(__cmp__);
  INIT_PY_NAME(__var_size__);
  INIT_PY_NAME(__init__);
  INIT_PY_NAME(__getinitargs__);
  INIT_PY_NAME(__getstate__);
  INIT_PY_NAME(__setstate__);
  INIT_PY_NAME(__dict__);
  INIT_PY_NAME(class_);
  INIT_PY_NAME(__module__);
  
#undef INIT_PY_NAME
}
</t>
<t tx="ekr.20040104185809.194">static PyObject *
CallMethodO(PyObject *self, PyObject *name,
		     PyObject *args, PyObject *kw)
{
  if (! args &amp;&amp; PyErr_Occurred()) return NULL;
  UNLESS(name=PyObject_GetAttr(self,name)) return NULL;
  ASSIGN(name,PyEval_CallObjectWithKeywords(name,args,kw));
  if (args) { Py_DECREF(args); }
  return name;
}
</t>
<t tx="ekr.20040104185809.195">#define Build Py_BuildValue

/* CMethod objects: */

typedef struct {
  PyObject_HEAD
  PyTypeObject *type;
  PyObject *self;
  char		*name;
  PyCFunction	meth;
  int		flags;
  char		*doc;
} CMethod;

staticforward PyTypeObject CMethodType;

#define CMethod_Check(O) ((O)-&gt;ob_type==&amp;CMethodType)
#define UnboundCMethod_Check(O) \
  ((O)-&gt;ob_type==&amp;CMethodType &amp;&amp; ! ((CMethod*)(O))-&gt;self)
#define AsCMethod(O) ((CMethod*)(O))
#define CMETHOD(O) ((CMethod*)(O))


#define PMethod PyECMethodObject
#define PMethodType PyECMethodObjectType

staticforward PyTypeObject PMethodType;

#define PMethod_Check(O) ((O)-&gt;ob_type==&amp;PMethodType)
#define UnboundPMethod_Check(O) \
  ((O)-&gt;ob_type==&amp;PMethodType &amp;&amp; ! ((PMethod*)(O))-&gt;self)

#define UnboundEMethod_Check(O) \
  (((O)-&gt;ob_type==&amp;PMethodType ||(O)-&gt;ob_type==&amp;CMethodType) \
   &amp;&amp; ! ((PMethod*)(O))-&gt;self)

#define PMETHOD(O) ((PMethod*)(O))

static PyObject *
bindPMethod(PMethod *m, PyObject *inst);

static PyObject *
#ifdef HAVE_STDARG_PROTOTYPES
/* VARARGS 2 */
JimErr_Format(PyObject *ErrType, char *stringformat, char *format, ...)
#else
/* VARARGS */
JimErr_Format(va_alist) va_dcl
#endif
{
  va_list va;
  PyObject *args=0, *retval=0;
#ifdef HAVE_STDARG_PROTOTYPES
  va_start(va, format);
#else
  PyObject *ErrType;
  char *stringformat, *format;
  va_start(va);
  ErrType = va_arg(va, PyObject *);
  stringformat   = va_arg(va, char *);
  format   = va_arg(va, char *);
#endif
  
  if (format) args = Py_VaBuildValue(format, va);
  va_end(va);
  if (format &amp;&amp; ! args) return NULL;
  if (stringformat &amp;&amp; !(retval=PyString_FromString(stringformat))) return NULL;

  if (retval)
    {
      if (args)
	{
	  PyObject *v;
	  v=PyString_Format(retval, args);
	  Py_DECREF(retval);
	  Py_DECREF(args);
	  if (! v) return NULL;
	  retval=v;
	}
    }
  else
    if (args) retval=args;
    else
      {
	PyErr_SetObject(ErrType,Py_None);
	return NULL;
      }
  PyErr_SetObject(ErrType,retval);
  Py_DECREF(retval);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.196">static PyObject *
#ifdef HAVE_STDARG_PROTOTYPES
/* VARARGS 2 */
JimString_Build(char *out_format, char *build_format, ...)
#else
/* VARARGS */
JimString_Build(va_alist) va_dcl
#endif
{
  va_list va;
  PyObject *args, *retval, *fmt;
#ifdef HAVE_STDARG_PROTOTYPES
  va_start(va, build_format);
#else
  char *build_format;
  char *out_format;
  va_start(va);
  out_format = va_arg(va, char *);
  build_format   = va_arg(va, char *);
#endif

  if (build_format)
    args = Py_VaBuildValue(build_format, va);
  else
    args = PyTuple_New(0);
  
  va_end(va);
  
  if (! args)
    return NULL;

  if (! PyTuple_Check(args))
    {
      PyObject *a;
      
      a=PyTuple_New(1);
      if (! a)
        return NULL;
      
      if (PyTuple_SetItem(a,0,args) == -1)
        return NULL;
      
      args=a;
    }

  fmt = PyString_FromString(out_format);
  
  retval = PyString_Format(fmt, args);
  
  Py_DECREF(args);
  Py_DECREF(fmt);
  
  return retval;
}
</t>
<t tx="ekr.20040104185809.197">static PyObject *
EC_NewObject(PyTypeObject *type, int size)
{
    PyObject *inst;
    int len;

    if (type-&gt;tp_itemsize) {
	inst = PyObject_NEW_VAR(PyObject, type, size);
	if (inst == NULL)
	    return NULL;
	((PyVarObject *)inst)-&gt;ob_size = size;
    } 
    else {
	assert(size == 0);
	inst = PyObject_NEW(PyObject, type);
	if (inst == NULL)
	    return NULL;
    }
    Py_INCREF(type);
    len = (type-&gt;tp_basicsize + type-&gt;tp_itemsize * size) - sizeof(PyObject);
    memset(((char *)inst) + sizeof(PyObject), 0, len);
    return inst;
}
</t>
<t tx="ekr.20040104185809.198">static int
CMethod_issubclass(PyExtensionClass *sub, PyExtensionClass *type)
{
  int i,l;
  PyObject *t;

  if (sub==type) return 1;
  if (! sub-&gt;bases) return 0;
  l=PyTuple_Size(sub-&gt;bases);
  for (i=0; i &lt; l; i++)
    {
      t=PyTuple_GET_ITEM(sub-&gt;bases, i);
      if (t==(PyObject*)type) return 1;
      if (ExtensionClass_Check(t)
	 &amp;&amp; AsExtensionClass(t)-&gt;bases
	 &amp;&amp; CMethod_issubclass(AsExtensionClass(t),type)
	 ) return 1;
    }
  return 0;
}
</t>
<t tx="ekr.20040104185809.199">#define Subclass_Check(C1,C2) \
CMethod_issubclass((PyExtensionClass *)(C1), (PyExtensionClass *)(C2))

#define SubclassInstance_Check(C1,C2) \
CMethod_issubclass((PyExtensionClass *)((C1)-&gt;ob_type), \
	     (PyExtensionClass *)(C2))


static CMethod *freeCMethod=0;

static PyObject *
newCMethod(PyExtensionClass *type, PyObject *inst,
   char *name, PyCFunction meth, int flags, char *doc)
{
CMethod *self;

ALLOC_FREE(CMethod);

Py_INCREF(type);
Py_XINCREF(inst);
self-&gt;type=(PyTypeObject*)type;
self-&gt;self=inst;
self-&gt;name=name;
self-&gt;meth=meth;
self-&gt;flags=flags;
self-&gt;doc=doc;
return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.200">static CMethod *
bindCMethod(CMethod *m, PyObject *inst)
{
  CMethod *self;
  
  UNLESS(inst-&gt;ob_type==m-&gt;type
	 || (ExtensionInstance_Check(inst)
	     &amp;&amp; SubclassInstance_Check(inst,m-&gt;type))
	 || ((m-&gt;flags &amp; METH_CLASS_METHOD) &amp;&amp; ExtensionClass_Check(inst))
	 )
    {
      Py_INCREF(m);
      return m;
    }

  ALLOC_FREE(CMethod);

  Py_INCREF(inst);
  Py_INCREF(m-&gt;type);
  self-&gt;type=m-&gt;type;
  self-&gt;self=inst;
  self-&gt;name=m-&gt;name;
  self-&gt;meth=m-&gt;meth;
  self-&gt;flags=m-&gt;flags;
  self-&gt;doc=m-&gt;doc;
  return self;
}
</t>
<t tx="ekr.20040104185809.201">static void
CMethod_dealloc(CMethod *self)
{
#ifdef TRACE_DEALLOC
  fprintf(stderr,"Deallocating C method %s\n", self-&gt;name); 
#endif
  Py_XDECREF(self-&gt;type);
  Py_XDECREF(self-&gt;self);
  self-&gt;self=(PyObject*)freeCMethod;
  freeCMethod=self;
}
</t>
<t tx="ekr.20040104185809.202">typedef PyObject *(*call_by_name_type)(PyObject*,PyObject*,PyObject*,
				       PyTypeObject*);
typedef PyObject *(*by_name_type)(PyObject*,PyObject*,
				  PyTypeObject*);
static PyObject *
call_cmethod(CMethod *self, PyObject *inst, PyObject *args, PyObject *kw)
{
  if (!(self-&gt;flags &amp; METH_VARARGS))
    {
      int size = PyTuple_Size(args);
      if (size == 1)      args = PyTuple_GET_ITEM(args, 0);
      else if (size == 0) args = NULL;
    }
  if (self-&gt;flags &amp; METH_KEYWORDS)
    {
      if (self-&gt;flags &amp; METH_BY_NAME)
	return (*(call_by_name_type)self-&gt;meth)(inst, args, kw,
					       self-&gt;type);
      else
	return (*(PyCFunctionWithKeywords)self-&gt;meth)(inst, args, kw);
    }
  else if (self-&gt;flags &amp; METH_BY_NAME)
    return (*(by_name_type)self-&gt;meth)(inst, args, self-&gt;type);
  else
    {
      if (kw != NULL &amp;&amp; PyDict_Size(kw) != 0)
	{
	  PyErr_SetString(PyExc_TypeError,
			  "this function takes no keyword arguments");
	  return NULL;
	}
      return (*self-&gt;meth)(inst, args);
    }
}
</t>
<t tx="ekr.20040104185809.203">static char *hook_mark="C method being called through a hook.";

static PyObject *
callCMethodWithHook(CMethod *self, PyObject *inst,
		    PyObject *args, PyObject *kw)
{
  PyObject *hook, *m;

  UNLESS(m=newCMethod(AsExtensionClass(self-&gt;type),
		      inst, self-&gt;name, self-&gt;meth,
		      self-&gt;flags, hook_mark)) return NULL;

  if ((hook=PyObject_GetAttr(inst,py__call_method__)))
    {
      if ((CMethod_Check(hook) &amp;&amp; CMETHOD(hook)-&gt;meth==self-&gt;meth)
	 ||
	 (PMethod_Check(hook)
	  &amp;&amp; CMethod_Check(PMETHOD(hook)-&gt;meth)
	  &amp;&amp; CMETHOD(PMETHOD(hook)-&gt;meth)-&gt;meth==self-&gt;meth)
	 )
	{
	  /* Oops, we are already calling the hook! */
	  Py_DECREF(hook);
	  return PyEval_CallObjectWithKeywords(m,args,kw);
	}
      if (kw)
	ASSIGN(hook,PyObject_CallFunction(hook,"OOO",m,args,kw));
      else
	ASSIGN(hook,PyObject_CallFunction(hook,"OO",m,args));
    }
  else
    {
      PyErr_Clear();
      hook=PyEval_CallObjectWithKeywords(m,args,kw);
    }

  Py_DECREF(m);
  return hook;
}
</t>
<t tx="ekr.20040104185809.204">static PyObject *
CMethod_call(CMethod *self, PyObject *args, PyObject *kw)
{
  int size;

  if (self-&gt;self)
    {
      if (HasMethodHook(self-&gt;self) &amp;&amp;
	 self-&gt;doc != hook_mark	/* This check prevents infinite recursion */
	 )
	return callCMethodWithHook(self,self-&gt;self,args,kw);
      return call_cmethod(self,self-&gt;self,args,kw);
    }

  if ((size=PyTuple_Size(args)) &gt; 0)
    {
      PyObject *first=0;

      UNLESS(first=PyTuple_GET_ITEM(args, 0)) return NULL;
      if (
	  first-&gt;ob_type==self-&gt;type
	  ||
	  (ExtensionInstance_Check(first)
	   &amp;&amp;
	   CMethod_issubclass(ExtensionClassOf(first),
			      AsExtensionClass(self-&gt;type))
	  )
	  )
      {
	PyObject *rest=0;
	UNLESS (rest=PySequence_GetSlice(args,1,size)) return NULL;
	if (HasMethodHook(first) &amp;&amp;
	   self-&gt;doc != hook_mark /* This check prevents infinite recursion */
	   )
          ASSIGN(rest, callCMethodWithHook(self, first, rest, kw) );
        else
          ASSIGN(rest, call_cmethod(self, first, rest, kw) );
	return rest;
      }
    }

  return JimErr_Format(PyExc_TypeError,
		      "unbound C method must be called with %s 1st argument",
		      "s", self-&gt;type-&gt;tp_name);
}
</t>
<t tx="ekr.20040104185809.205">static PyObject *
CMethod_getattro(CMethod *self, PyObject *oname)
{
  PyObject *r;
  
  if (PyString_Check(oname))
    {
      char *name;

      UNLESS(name=PyString_AsString(oname)) return NULL;
        	        
      if (name[0] != '_' &amp;&amp; name[0] &amp;&amp; name[1] != '_' &amp;&amp;
	  PyEval_GetRestricted())
	{
	  PyErr_SetString(PyExc_RuntimeError,
	       	  "function attributes not accessible in restricted mode");
	  return NULL;
	}

      if (strcmp(name,"__name__")==0 || strcmp(name,"func_name")==0 )
	return PyString_FromString(self-&gt;name);
      if (strcmp(name,"func_code")==0 ||
	 strcmp(name,"im_func")==0)
	{
	  Py_INCREF(self);
	  return (PyObject *)self;
	}
      if (strcmp(name,"__doc__")==0 ||
	 strcmp(name,"func_doc")==0)
	{
	  if (self-&gt;doc)
	    return PyString_FromString(self-&gt;doc);
	  else
	    return PyString_FromString("");
	}
      if (strcmp(name,"im_class")==0)
	{
	  Py_INCREF(self-&gt;type);
	  return (PyObject *)self-&gt;type;
	}
      if (strcmp(name,"im_self")==0)
	{
	  if (self-&gt;self) r=self-&gt;self;
	  else           r=Py_None;
	  Py_INCREF(r);
	  return r;
	}
    }

  if (self-&gt;self)	/* Psuedo attributes */
    {
      UNLESS(oname=Py_BuildValue("sO", self-&gt;name, oname)) return NULL;
      UNLESS_ASSIGN(oname,PyString_Format(concat_fmt, oname)) return NULL;
      r=PyObject_GetAttr(OBJECT(self-&gt;self), py__class__);
      if (r)
	{
	  ASSIGN(r, PyObject_GetAttr(r, oname));

	  if (r) {
	    if (UnboundCMethod_Check(r))
	      ASSIGN(r, (PyObject*)bindCMethod((CMethod*)r, self-&gt;self));
	    else if (UnboundPMethod_Check(r))
	      ASSIGN(r, bindPMethod((PMethod*)r, self-&gt;self));
	  }
	}
      Py_DECREF(oname);
      return r;
    }

  PyErr_SetObject(PyExc_AttributeError, oname);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.206">static PyTypeObject CMethodType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "CMethod",			/*tp_name*/
  sizeof(CMethod),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)CMethod_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  0,				/*tp_getattr*/
  (setattrfunc)0,		/*tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)0,			/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  0,				/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)CMethod_call,	/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)CMethod_getattro, 	/* tp_getattro */
  (setattrofunc)0, 		/* tp_setattro */
  
  /* Space for future expansion */
  0L,0L,
  "Storage manager for unbound C function PyObject data"
  /* Documentation string */
};

/* PMethod objects: */

static PMethod *freePMethod=0;

static PyObject *
newPMethod(PyExtensionClass *type, PyObject *meth)
{
  PMethod *self;
  
  ALLOC_FREE(PMethod);

  Py_INCREF(type);
  Py_INCREF(meth);
  self-&gt;type=(PyTypeObject*)type;
  self-&gt;self=NULL;
  self-&gt;meth=meth;
  return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.207">static PyObject *
bindPMethod(PMethod *m, PyObject *inst)
{
  PMethod *self;

  if (NeedsToBeBound(m-&gt;meth))
    return CallMethodO(m-&gt;meth, py__of__, Build("(O)", inst), NULL);
  if (m-&gt;ob_refcnt==1)
    {
      Py_INCREF(inst);
      ASSIGN(m-&gt;self, inst);
      Py_INCREF(m);
      return (PyObject*)m;
    }
  
  ALLOC_FREE(PMethod);

  Py_INCREF(inst);
  Py_INCREF(m-&gt;type);
  Py_INCREF(m-&gt;meth);
  self-&gt;type=m-&gt;type;
  self-&gt;self=inst;
  self-&gt;meth=m-&gt;meth;
  return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.208">static PyObject *
PMethod_New(PyObject *meth, PyObject *inst)
{
  if (PMethod_Check(meth)) return bindPMethod((PMethod*)meth,inst);
  UNLESS(ExtensionInstance_Check(inst))
    return JimErr_Format(PyExc_TypeError,
			"Attempt to use %s as method for %s, which is "
			"not an extension class instance.",
			"OO",meth,inst);
  if ((meth=newPMethod(ExtensionClassOf(inst), meth)))
    UNLESS_ASSIGN(((PMethod*)meth)-&gt;self,inst) return NULL;
  Py_INCREF(inst);
  return meth;
}
</t>
<t tx="ekr.20040104185809.209">static void
PMethod_dealloc(PMethod *self)
{
#ifdef TRACE_DEALLOC
  fprintf(stderr,"Deallocating PM ... ");
#endif
  Py_XDECREF(self-&gt;type);
  Py_XDECREF(self-&gt;self);
  Py_XDECREF(self-&gt;meth);
  self-&gt;self=(PyObject*)freePMethod;
  freePMethod=self;
#ifdef TRACE_DEALLOC
  fprintf(stderr," Done Deallocating PM\n");
#endif
}</t>
<t tx="ekr.20040104185809.210">static PyObject *
callMethodWithPossibleHook(PyObject *inst,
			   PyObject *meth, PyObject *args, PyObject *kw)
{
  if (HasMethodHook(inst))
    {
      PyObject *hook;
      if ((hook=PyObject_GetAttr(inst,py__call_method__)))
	{
	  if (PMethod_Check(hook) &amp;&amp; ((PMethod*)hook)-&gt;meth==meth)
	    {
	      /* Oops, we are already calling the hook! */
	      Py_DECREF(hook);
	      return PyEval_CallObjectWithKeywords(meth,args,kw);
	    }
	  if (kw)
	    ASSIGN(hook,PyObject_CallFunction(hook,"OOO",meth,args,kw));
	  else
	    ASSIGN(hook,PyObject_CallFunction(hook,"OO",meth,args));
	  return hook;
	}
      PyErr_Clear();
    }
  return PyEval_CallObjectWithKeywords(meth,args,kw);
}
</t>
<t tx="ekr.20040104185809.211">static PyObject *
call_PMethod(PMethod *self, PyObject *inst, PyObject *args, PyObject *kw)
{
  PyObject *a;

  if (CMethod_Check(self-&gt;meth)
     &amp;&amp; CMETHOD(self-&gt;meth)-&gt;type-&gt;tp_basicsize == sizeof(PyPureMixinObject)
     &amp;&amp; ! (CMETHOD(self-&gt;meth)-&gt;self)
     )
    {
      /* Special HACK^H^H^Hcase:
	 we are wrapping an abstract unbound CMethod */
      if (HasMethodHook(inst) &amp;&amp;
	 /* This check prevents infinite recursion: */
	 CMETHOD(self-&gt;meth)-&gt;doc != hook_mark 
	 )
	return callCMethodWithHook(CMETHOD(self-&gt;meth),inst,args,kw);
      return call_cmethod(CMETHOD(self-&gt;meth),inst,args,kw);
      
    }
  else
    {
      a=Py_BuildValue("(O)",inst);
      if (a) ASSIGN(a,PySequence_Concat(a,args));
      if (a) ASSIGN(a,callMethodWithPossibleHook(inst,self-&gt;meth,a,kw));
      return a;
    }
}
</t>
<t tx="ekr.20040104185809.212">static PyObject *
PMethod_call(PMethod *self, PyObject *args, PyObject *kw)
{
  int size;

  if (self-&gt;self) return call_PMethod(self,self-&gt;self,args,kw);

  if ((size=PyTuple_Size(args)) &gt; 0)
    {
      PyObject *first=0, *ftype=0;
      UNLESS(first=PyTuple_GET_ITEM(args, 0)) return NULL;
      if (! self-&gt;type ||
	 ((ftype=PyObject_GetAttr(first,py__class__)) &amp;&amp;
	  (ftype==(PyObject*)self-&gt;type ||
	   (ExtensionClass_Check(ftype) &amp;&amp;
	    CMethod_issubclass(AsExtensionClass(ftype),
			       AsExtensionClass(self-&gt;type))
	    )
	   )
	  )
	 )
	{
	  if (NeedsToBeBound(self-&gt;meth))
	    {
	      PyObject *r, *rest;
	      UNLESS(r=CallMethodO(self-&gt;meth,py__of__,Build("(O)", first),
				   NULL))
		return NULL;
	      UNLESS(rest=PySequence_GetSlice(args,1,size))
		{
		  Py_DECREF(r);
		  return NULL;
		}
	      ASSIGN(r,callMethodWithPossibleHook(first,r,rest,kw));
	      Py_DECREF(rest);
	      return r;
	    }
	  Py_DECREF(ftype);
	  return callMethodWithPossibleHook(first,self-&gt;meth,args,kw);
	}
      Py_XDECREF(ftype);
    }

  return JimErr_Format(PyExc_TypeError,
		      "unbound Python method must be called with %s"
		      " 1st argument",
		      "s", self-&gt;type-&gt;tp_name);
}
</t>
<t tx="ekr.20040104185809.213">static PyObject *
PMethod_repr(PMethod *self)
{
    char *func_name, buf[8192];
    int n;

    if (PyFunction_Check(self-&gt;meth)) {
	func_name = PyString_AS_STRING(
		((PyFunctionObject*)self-&gt;meth)-&gt;func_name);
    }
    else {
	/* self-&gt;meth is some other kind of object */
	func_name = "(?)";
    }
    
    if (self-&gt;self) {
	PyObject *repr = PyObject_Repr(self-&gt;self);
	if (!repr)
	    return NULL;
	n = sprintf(buf,
		     "&lt;bound method %.1000s.%.1000s of %.1000s&gt;",
		     self-&gt;type-&gt;tp_name, func_name,
		     PyString_AS_STRING(repr));
	Py_DECREF(repr);
    }
    else {
	n = sprintf(buf, 
		     "&lt;unbound method %.1000s.%.1000s&gt;",
		     self-&gt;type-&gt;tp_name, func_name);
    }
    return PyString_FromStringAndSize(buf, n);
}
</t>
<t tx="ekr.20040104185809.214">static PyObject *
PMethod_getattro(PMethod *self, PyObject *oname)
{
  PyObject *r;

  if (PyString_Check(oname))
    {
      char *name;

      UNLESS(name=PyString_AsString(oname)) return NULL;

      if (name[0]=='_' &amp;&amp; name[1]=='_')
	{
	  if (strcmp(name+2,"name__")==0)
	    return PyObject_GetAttrString(self-&gt;meth,"__name__");
	  if (strcmp(name+2,"doc__")==0)
	    return PyObject_GetAttrString(self-&gt;meth,"__doc__");
	}        
      else if (PyEval_GetRestricted())
	{
	  PyErr_SetString(PyExc_RuntimeError,
	       "function attributes not accessible in restricted mode");
	  return NULL;
	}
      else if (name[0]=='f' &amp;&amp; name[1]=='u' &amp;&amp; name[2]=='n' &amp;&amp; name[3]=='c'
	      &amp;&amp; name[4]=='_')
	{
	  if (strcmp(name+5,"name")==0 )
	    return PyObject_GetAttrString(self-&gt;meth,"__name__");
	  if (strcmp(name+5,"doc")==0)
	    return PyObject_GetAttrString(self-&gt;meth,"__doc__");
	}

      if (*name++=='i' &amp;&amp; *name++=='m' &amp;&amp; *name++=='_')
	{
	  if (strcmp(name,"func")==0)
	    {
	      Py_INCREF(self-&gt;meth);
	      return self-&gt;meth;
	    }
	  if (strcmp(name,"class")==0)
	    {
	      Py_INCREF(self-&gt;type);
	      return (PyObject *)self-&gt;type;
	    }
	  if (strcmp(name,"self")==0)
	    {
	      if (self-&gt;self) r=self-&gt;self;
	      else           r=Py_None;
	      Py_INCREF(r);
	      return r;
	    }
	}
    }

  if (self-&gt;meth)
    {
      if ((r=PyObject_GetAttr(self-&gt;meth, oname))) return r;
      PyErr_Clear();

      if (self-&gt;self) /* Psuedo attrs */
	{
	  PyObject *myname;
	  
	  UNLESS(myname=PyObject_GetAttr(self-&gt;meth, py__name__)) return NULL;
	  oname=Py_BuildValue("OO", myname, oname);
	  Py_DECREF(myname);
	  UNLESS(oname) return NULL;
	  UNLESS_ASSIGN(oname,PyString_Format(concat_fmt, oname)) return NULL;
	  r=PyObject_GetAttr(OBJECT(self-&gt;self), py__class__);
	  if (r)
	    {
	      ASSIGN(r, PyObject_GetAttr(r, oname));
      
	      if (r) {
		if (UnboundCMethod_Check(r))
		  ASSIGN(r, (PyObject*)bindCMethod((CMethod*)r, self-&gt;self));
		else if (UnboundPMethod_Check(r))
		  ASSIGN(r, bindPMethod((PMethod*)r, self-&gt;self));
	      }
	    }
	  Py_DECREF(oname);
	  return r;
	}
    }

  PyErr_SetObject(PyExc_AttributeError, oname);
  return NULL;

  return PyObject_GetAttr(self-&gt;meth, oname);
}
</t>
<t tx="ekr.20040104185809.215">static PyTypeObject PMethodType = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  "Python Method",			/*tp_name*/
  sizeof(PMethod),			/*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor)PMethod_dealloc,		/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  0,					/*tp_getattr*/
  (setattrfunc)0,			/*tp_setattr*/
  (cmpfunc)0,				/*tp_compare*/
  (reprfunc)PMethod_repr,		/*tp_repr*/
  0,					/*tp_as_number*/
  0,					/*tp_as_sequence*/
  0,					/*tp_as_mapping*/
  (hashfunc)0,				/*tp_hash*/
  (ternaryfunc)PMethod_call,		/*tp_call*/
  (reprfunc)0,				/*tp_str*/
  (getattrofunc)PMethod_getattro,	/*tp_getattro*/
  (setattrofunc)0, 			/* tp_setattro */
  
  /* Space for future expansion */
  0L,0L,
  "Storage manager for unbound C function PyObject data"
  /* Documentation string */
};

static PyObject *CCL_getattr(PyExtensionClass*,PyObject*,int);

static int
CCL_hasattr(PyExtensionClass *self,PyObject *name)
{
  PyObject *r;

  r=CCL_getattr(self, name, 0);
  if (r)
    {
      Py_DECREF(r);
      return 1;
    }
  else
    PyErr_Clear();
  
  return 0;
}
</t>
<t tx="ekr.20040104185809.216">@ Special Methods
@c

#define UNARY_OP(OP) \
static PyObject * \
OP ## _by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type) { \
  UNLESS(PyArg_ParseTuple(args,"")) return NULL; \
  return ob_type-&gt;tp_ ## OP(self); \
} 

UNARY_OP(repr)
UNARY_OP(str)

static PyObject * 
hash_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type) { 
  long r; 
  UNLESS(PyArg_ParseTuple(args,"")) return NULL; 
  UNLESS(-1 != (r=ob_type-&gt;tp_hash(self))) return NULL; 
  return PyInt_FromLong(r); 
}</t>
<t tx="ekr.20040104185809.217">static PyObject *
call_by_name(PyObject *self, PyObject *args, PyObject *kw,
	     PyTypeObject *ob_type)
{
  return ob_type-&gt;tp_call(self,args,kw);
}
</t>
<t tx="ekr.20040104185809.218">static PyObject *
compare_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *other;

  UNLESS(PyArg_ParseTuple(args,"O", &amp;other)) return NULL; 
  return PyInt_FromLong(ob_type-&gt;tp_compare(self,other)); 
}</t>
<t tx="ekr.20040104185809.219">static PyObject *
getattr_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  char *name;
  UNLESS(PyArg_ParseTuple(args,"s",&amp;name)) return NULL;
  return ob_type-&gt;tp_getattr(self,name);
}
</t>
<t tx="ekr.20040104185809.220">static PyObject *
setattr_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  char *name;
  PyObject *v;
  UNLESS(PyArg_ParseTuple(args,"sO",&amp;name,&amp;v)) return NULL;
  UNLESS(-1 != ob_type-&gt;tp_setattr(self,name,v)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.221">static PyObject *
delsetattr_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  char *name;
  UNLESS(PyArg_ParseTuple(args,"s",&amp;name)) return NULL;
  UNLESS(-1 != ob_type-&gt;tp_setattr(self,name,NULL)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.222">static PyObject *
getattro_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *name;
  UNLESS(PyArg_ParseTuple(args,"O",&amp;name)) return NULL;
  return ob_type-&gt;tp_getattro(self,name);
}
</t>
<t tx="ekr.20040104185809.223">static PyObject *
setattro_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *name;
  PyObject *v;
  UNLESS(PyArg_ParseTuple(args,"OO",&amp;name,&amp;v)) return NULL;
  UNLESS(-1 != ob_type-&gt;tp_setattro(self,name,v)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.224">static PyObject *
delsetattro_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *name;
  UNLESS(PyArg_ParseTuple(args,"O",&amp;name)) return NULL;
  UNLESS(-1 != ob_type-&gt;tp_setattro(self,name,NULL)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.225">static PyObject * 
length_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{ 
  long r; 
  UNLESS(PyArg_ParseTuple(args,"")) return NULL; 
  if (ob_type-&gt;tp_as_sequence)
    {
      UNLESS(-1 != (r=ob_type-&gt;tp_as_sequence-&gt;sq_length(self)))
	return NULL;
    }
  else
    {
      UNLESS(-1 != (r=ob_type-&gt;tp_as_mapping-&gt;mp_length(self)))
	return NULL;
    }
  return PyInt_FromLong(r); 
}</t>
<t tx="ekr.20040104185809.226">static PyObject * 
getitem_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{ 
  PyObject *key;
  
  UNLESS(PyArg_ParseTuple(args,"O",&amp;key)) return NULL; 
  if (ob_type-&gt;tp_as_mapping)
    return ob_type-&gt;tp_as_mapping-&gt;mp_subscript(self,key);
  else
    {
      int index;
      UNLESS(-1 != (index=PyInt_AsLong(key))) return NULL;
      return ob_type-&gt;tp_as_sequence-&gt;sq_item(self,index);
    }
}</t>
<t tx="ekr.20040104185809.227">static PyCFunction item_by_name=(PyCFunction)getitem_by_name;
static PyCFunction subscript_by_name=(PyCFunction)getitem_by_name;
  
static PyObject *
setitem_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{ 
  PyObject *key, *v;
  long r;
  
  UNLESS(PyArg_ParseTuple(args,"OO",&amp;key,&amp;v)) return NULL; 
  if (ob_type-&gt;tp_as_mapping)
    r=ob_type-&gt;tp_as_mapping-&gt;mp_ass_subscript(self,key,v);
  else
    {
      int index;
      UNLESS(-1 != (index=PyInt_AsLong(key))) return NULL;
      r=ob_type-&gt;tp_as_sequence-&gt;sq_ass_item(self,index,v);
    }
  if (r &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

static PyCFunction ass_item_by_name=(PyCFunction)setitem_by_name;
static PyCFunction ass_subscript_by_name=(PyCFunction)setitem_by_name;

static PyObject *
slice_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  int i1,i2;

  UNLESS(PyArg_ParseTuple(args,"ii",&amp;i1,&amp;i2)) return NULL;
  return ob_type-&gt;tp_as_sequence-&gt;sq_slice(self,i1,i2);
}

static PyObject *
ass_slice_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  int i1,i2;
  PyObject *v;
  long r;

  UNLESS(PyArg_ParseTuple(args,"iiO",&amp;i1,&amp;i2,&amp;v)) return NULL;
  r=ob_type-&gt;tp_as_sequence-&gt;sq_ass_slice(self,i1,i2,v);
  if (r&lt;0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

static PyObject *
concat_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *other;
  UNLESS(PyArg_ParseTuple(args,"O",&amp;other)) return NULL;
  return ob_type-&gt;tp_as_sequence-&gt;sq_concat(self,other);
}

static PyObject *
repeat_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  int r;
  UNLESS(PyArg_ParseTuple(args,"i",&amp;r)) return NULL;
  return ob_type-&gt;tp_as_sequence-&gt;sq_repeat(self,r);
}

#define BINOP(OP,AOP) \
static PyObject * \
OP ## _by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type) { \
  PyObject *v; \
  UNLESS(PyArg_ParseTuple(args,"O",&amp;v)) return NULL; \
  return ob_type-&gt;tp_as_number-&gt;nb_ ## OP(self, v); \
}

BINOP(add,Add)
BINOP(subtract,Subtract)
BINOP(multiply,Multiply)
BINOP(divide,Divide)
BINOP(remainder,Remainder)
BINOP(divmod,Divmod)

static PyObject *
power_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *v, *z=NULL;
  UNLESS(PyArg_ParseTuple(args,"O|O",&amp;v,&amp;z)) return NULL; 
  return ob_type-&gt;tp_as_number-&gt;nb_power(self,v,z);
}

#define UNOP(OP) \
static PyObject * \
OP ## _by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type) { \
  UNLESS(PyArg_ParseTuple(args,"")) return NULL; \
  return ob_type-&gt;tp_as_number-&gt;nb_ ## OP(self); \
}

UNOP(negative)
UNOP(positive)
UNOP(absolute)

static PyObject * 
nonzero_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type) { 
  long r; 
  UNLESS(PyArg_ParseTuple(args,"")) return NULL; 
  UNLESS(-1 != (r=ob_type-&gt;tp_as_number-&gt;nb_nonzero(self))) return NULL; 
  return PyInt_FromLong(r); 
} 

UNOP(invert)

BINOP(lshift,Lshift)
BINOP(rshift,Rshift)
BINOP(and,And)
BINOP(or,Or)
BINOP(xor,Xor)

static PyObject *
coerce_by_name(PyObject *self, PyObject *args, PyTypeObject *ob_type)
{
  PyObject *v;
  int r;
  UNLESS(PyArg_ParseTuple(args,"O", &amp;v)) return NULL;
  UNLESS(-1 != (r=ob_type-&gt;tp_as_number-&gt;nb_coerce(&amp;self,&amp;v)))
    {
      Py_INCREF(Py_None);
      return Py_None;
    }
  args=Py_BuildValue("OO",self,v);
  Py_DECREF(self);
  Py_DECREF(v);
  return args;
} 

UNOP(long)
UNOP(int)
UNOP(float)
UNOP(oct)
UNOP(hex)

#define FILLENTRY(T,MN,N,F,D) if (T ## _ ## MN) { \
  UNLESS(-1 != PyMapping_SetItemString(dict,"__" # N "__", \
    newCMethod(type, NULL, "__" # N "__", \
               (PyCFunction)MN ## _by_name, F | METH_BY_NAME, # D))) \
    goto err; }

#define delFILLENTRY(T,MN,N,F,D) if (T ## _ ## MN) { \
  UNLESS(-1 != PyMapping_SetItemString(dict,"__" # N "__", \
    newCMethod(type, NULL, "__" # N "__", \
               (PyCFunction)del ## MN ## _by_name, F | METH_BY_NAME, # D))) \
    goto err; }

static PyObject *
getBaseDictionary(PyExtensionClass *type)
{
  PyNumberMethods *nm;
  PySequenceMethods *sm;
  PyMappingMethods *mm;
  PyObject *dict;

  UNLESS(dict=type-&gt;class_dictionary)
    UNLESS(dict=PyDict_New()) return NULL;
  
  FILLENTRY(type-&gt;tp, repr, repr, METH_VARARGS,
	    "convert to an expression string");
  FILLENTRY(type-&gt;tp, hash, hash, METH_VARARGS, "compute a hash value");
  FILLENTRY(type-&gt;tp, call, call, METH_VARARGS | METH_KEYWORDS,
	    "call as a function");
  FILLENTRY(type-&gt;tp, compare, comp, METH_VARARGS,
	    "compare with another object");
 
  UNLESS (type-&gt;class_flags &amp; EXTENSIONCLASS_PYTHONICATTR_FLAG)
    {
      FILLENTRY(type-&gt;tp, getattr, getattr, METH_VARARGS, "Get an attribute");
      FILLENTRY(type-&gt;tp, setattr, setattr, METH_VARARGS, "Set an attribute");
      delFILLENTRY(type-&gt;tp, setattr, delattr, METH_VARARGS, 
		   "Delete an attribute");
      
      FILLENTRY(type-&gt;tp, getattro, getattr, METH_VARARGS, "Get an attribute");
      FILLENTRY(type-&gt;tp, setattro, setattr, METH_VARARGS, "Set an attribute");
      delFILLENTRY(type-&gt;tp, setattro, delattr, METH_VARARGS, 
		   "Delete an attribute");
    }

  if ((sm=type-&gt;tp_as_sequence))
    {
      FILLENTRY(sm-&gt;sq, length, len, METH_VARARGS, "Get the object length");
      FILLENTRY(sm-&gt;sq, repeat, mul, METH_VARARGS,
		"Get a new object that is the object repeated.");
      FILLENTRY(sm-&gt;sq, item, getitem, METH_VARARGS, "Get an item");
      FILLENTRY(sm-&gt;sq, slice, getslice, METH_VARARGS, "Get a slice");
      FILLENTRY(sm-&gt;sq, ass_item, setitem, METH_VARARGS, "Assign an item");
      FILLENTRY(sm-&gt;sq, ass_slice, setslice, METH_VARARGS, "Assign a slice");
    }      

  if ((mm=type-&gt;tp_as_mapping))
    {
      FILLENTRY(mm-&gt;mp, length, len, METH_VARARGS, "Get the object length");
      FILLENTRY(mm-&gt;mp, subscript, getitem, METH_VARARGS, "Get an item");
      FILLENTRY(mm-&gt;mp, ass_subscript, setitem, METH_VARARGS,
		"Assign an item");
    }      

  if ((nm=type-&gt;tp_as_number) != NULL)
    {
      FILLENTRY(nm-&gt;nb, add, add, METH_VARARGS, "Add to another");
      FILLENTRY(nm-&gt;nb, subtract, sub, METH_VARARGS, "Subtract another");
      FILLENTRY(nm-&gt;nb, multiply, mul, METH_VARARGS, "Multiple by another");
      FILLENTRY(nm-&gt;nb, divide, div, METH_VARARGS, "Divide by another");
      FILLENTRY(nm-&gt;nb, remainder, mod, METH_VARARGS, "Compute a remainder");
      FILLENTRY(nm-&gt;nb, power, pow, METH_VARARGS, "Raise to a power");
      FILLENTRY(nm-&gt;nb, divmod, divmod, METH_VARARGS,
		"Compute the whole result and remainder of dividing\n"
		"by another");
      FILLENTRY(nm-&gt;nb, negative, neg, METH_VARARGS,
		"Get the negative value.");
      FILLENTRY(nm-&gt;nb, positive, pos, METH_VARARGS, "Compute positive value");
      FILLENTRY(nm-&gt;nb, absolute, abs, METH_VARARGS, "Compute absolute value");
      FILLENTRY(nm-&gt;nb, nonzero, nonzero, METH_VARARGS,
		"Determine whether nonzero");
      FILLENTRY(nm-&gt;nb, invert, inv, METH_VARARGS, "Compute inverse");
      FILLENTRY(nm-&gt;nb, lshift, lshift, METH_VARARGS, "Shist left");
      FILLENTRY(nm-&gt;nb, rshift, rshift, METH_VARARGS, "Shist right");
      FILLENTRY(nm-&gt;nb, and, and, METH_VARARGS, "bitwize logical and");
      FILLENTRY(nm-&gt;nb, or, or, METH_VARARGS, "bitwize logical or");
      FILLENTRY(nm-&gt;nb, xor, xor, METH_VARARGS, "bitwize logical excusive or");
      FILLENTRY(nm-&gt;nb, coerce, coerce, METH_VARARGS,
		"Coerce woth another to a common type");
      FILLENTRY(nm-&gt;nb, int, int, METH_VARARGS, "Convert to an integer");
      FILLENTRY(nm-&gt;nb, long, long, METH_VARARGS,
		"Convert to an infinite-precision integer");
      FILLENTRY(nm-&gt;nb, float, float, METH_VARARGS,
		"Convert to floating point number");
      FILLENTRY(nm-&gt;nb, oct, oct, METH_VARARGS, "Convert to an octal string");
      FILLENTRY(nm-&gt;nb, hex, hex, METH_VARARGS,
		"Convert to a hexadecimal string");
    }

  if ((sm=type-&gt;tp_as_sequence))
    {
      FILLENTRY(sm-&gt;sq, concat, add, METH_VARARGS,
		"Concatinate the object with another");
    }      

  return dict;
err:
  Py_DECREF(dict);
  return NULL;
}

#undef UNARY_OP
#undef BINOP
#undef UNOP
#undef FILLENTRY

PyObject *
EC_reduce(PyObject *self, PyObject *args)
{
  PyObject *state=0;

  if ((args=PyObject_GetAttr(self,py__getinitargs__)))
    {
      UNLESS_ASSIGN(args,PyEval_CallObject(args,NULL)) return NULL;
      UNLESS_ASSIGN(args,PySequence_Tuple(args)) return NULL;
    }
  else
    {
      PyErr_Clear();
      if (ExtensionClassOf(self)-&gt;class_flags &amp; EXTENSIONCLASS_BASICNEW_FLAG)
	{
	  args=Py_None;
	  Py_INCREF(args);
	}
      else args=PyTuple_New(0);
    }

  if ((state=PyObject_GetAttr(self,py__getstate__)))
    {
      UNLESS_ASSIGN(state,PyEval_CallObject(state,NULL)) goto err;
      ASSIGN(args,Py_BuildValue("OOO", self-&gt;ob_type, args, state));
      Py_DECREF(state);
    }
  else
    {
      PyErr_Clear();

      if ((state=PyObject_GetAttr(self, py__dict__)))
	{
	  ASSIGN(args,Py_BuildValue("OOO", self-&gt;ob_type, args, state));
	  Py_DECREF(state);
	}
      else
	{
	  PyErr_Clear();
	  ASSIGN(args, Py_BuildValue("OO", self-&gt;ob_type, args));
	}
    }

  return args;

err:
  Py_DECREF(args);
  return NULL;
}

static PyObject *
inheritedAttribute(PyExtensionClass *self, PyObject *args)
{
  PyObject *name;

  UNLESS(PyArg_ParseTuple(args,"O!",&amp;PyString_Type, &amp;name)) return NULL;

  return CCL_getattr(AsExtensionClass(self),name,1);
}

static PyObject *
basicnew(PyExtensionClass *self, PyObject *args)
{
  PyObject *inst=0;
  int size = 0;

  if (! self-&gt;tp_dealloc)
    {
      PyErr_SetString(PyExc_TypeError,
		      "Attempt to create instance of an abstract type");
      return NULL;
    }

  UNLESS(self-&gt;class_flags &amp; EXTENSIONCLASS_BASICNEW_FLAG)
    return PyObject_CallObject(OBJECT(self), NULL);      

  if (self-&gt;tp_itemsize)
    {
      /* We have a variable-sized object, we need to get it's size */
      PyObject *var_size;
      
      UNLESS(var_size=CCL_getattr(self, py__var_size__, 0)) return NULL;
      UNLESS_ASSIGN(var_size,PyObject_CallObject(var_size,NULL)) return NULL;
      size=PyInt_AsLong(var_size);
      if (PyErr_Occurred()) return NULL;
    }
  UNLESS(inst=EC_NewObject((PyTypeObject *)self, size))
    return NULL;

  if (ClassHasInstDict(self))
    UNLESS(INSTANCE_DICT(inst)=PyDict_New()) goto err;

  if (self-&gt;bases &amp;&amp; subclass_watcher &amp;&amp;
     ! PyObject_CallMethod(subclass_watcher,"created","O",inst))
    PyErr_Clear();

  return inst;

err:
  Py_DECREF(inst);
  return NULL;
}

struct PyMethodDef ECI_methods[] = {
  {"__reduce__",(PyCFunction)EC_reduce, METH_VARARGS,
   "__reduce__() -- Reduce an instance into it's class and creation data"
  },
  {"inheritedAttribute",(PyCFunction)inheritedAttribute,
   METH_VARARGS | METH_CLASS_METHOD,
   "inheritedAttribute(class,name) -- Get an inherited attribute\n\n"
   "Get an attribute that would be inherited if the given (extension)\n"
   "class did not define it.  This method is used when overriding\n"
   "inherited methods.  It provides 2 advantages over accessing\n"
   "\n"
   "attributes directly through a superclass:\n"
   "\n"
   "1. The superclass need not be known,\n"
   "\n"
   "2. The superclass may be a Python class.  Without this method, it would\n"
   "   be possible to override methods inherited from python classes because\n"
   "   unbound methods gotten from Python classes cannot be called with \n"
   "   extension class instances.  \n"
  },
  {"__basicnew__",(PyCFunction)basicnew,
   METH_VARARGS | METH_CLASS_METHOD,
   "__basicnew__() -- return a new uninitialized instance"
  },
  {NULL,		NULL}		/* sentinel */
};

static PyObject *
initializeBaseExtensionClass(PyExtensionClass *self)
{
  static PyMethodChain top = { ECI_methods, NULL };
  PyMethodChain *chain;
  PyObject *dict;
  int abstract;

  /* Is this an abstract, or at least a dataless, class? */
  abstract=self-&gt;tp_basicsize == sizeof(PyPureMixinObject);

  self-&gt;ob_type=(PyTypeObject*)&amp;ECType;
  Py_INCREF(self-&gt;ob_type);

  UNLESS(dict=self-&gt;class_dictionary=getBaseDictionary(self)) return NULL;

  if (self-&gt;tp_name)
    {
      PyObject *name;

      UNLESS(name=PyString_FromString(self-&gt;tp_name)) goto err;
      if (0 &gt; PyMapping_SetItemString(dict,"__doc__",name)) goto err;
      Py_DECREF(name);
    }
  else if (0 &gt; PyMapping_SetItemString(dict,"__doc__",Py_None)) goto err;
  
  if (&amp;self-&gt;methods) chain=&amp;(self-&gt;methods);
  else chain=&amp;top;
  
  while (1)
    {
      PyMethodDef *ml = chain-&gt;methods;

      for (; ml &amp;&amp; ml-&gt;ml_name != NULL; ml++) 
	{
	  if (ml-&gt;ml_meth)
	    {
	      if (! PyMapping_HasKeyString(dict,ml-&gt;ml_name))
		{
		  PyObject *m;

		  /* Note that we create a circular reference here.
		     I suppose that this isn't so bad, since this is
		     probably a static thing anyway. Still, it is a
		     bit troubling. Oh well.
		  */
		  if (ml-&gt;ml_flags &amp; METH_CLASS_METHOD)
		    {
		      UNLESS(m=newCMethod(
                         AsExtensionClass(self-&gt;ob_type), NULL,
			 ml-&gt;ml_name, ml-&gt;ml_meth,
			 ml-&gt;ml_flags, ml-&gt;ml_doc))
			return NULL;
		    }
		  else
		    {
		      UNLESS(m=newCMethod(self, NULL, ml-&gt;ml_name, ml-&gt;ml_meth,
					  ml-&gt;ml_flags, ml-&gt;ml_doc))
			return NULL;
		  
		      if (abstract)
			UNLESS_ASSIGN(m, newPMethod(self, m))
			  return NULL;
		    }

		  if (PyMapping_SetItemString(dict,ml-&gt;ml_name,m) &lt; 0)
		    return NULL;
		}
	    }
	  else if (ml-&gt;ml_doc &amp;&amp; *(ml-&gt;ml_doc))
	    {
	      /* No actual meth, this is probably to hook a doc string
		 onto a special method. */
	      PyObject *m;

	      if ((m=PyMapping_GetItemString(dict,ml-&gt;ml_name)))
		{
		  if (m-&gt;ob_type==&amp;CMethodType)
		    ((CMethod *)(m))-&gt;doc=ml-&gt;ml_doc;
		}
	      else
		PyErr_Clear();
	    }
	}
      
      if (chain == &amp;top) break;

      UNLESS(chain=chain-&gt;link) chain=&amp;top;
    }
  return (PyObject*)self;

err:
  Py_DECREF(dict);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.228">static void
CCL_dealloc(PyExtensionClass *self)
{
#ifdef TRACE_DEALLOC
  fprintf(stderr,"Deallocating %s\n", self-&gt;tp_name);
#endif
  Py_XDECREF(self-&gt;class_dictionary);
  if (self-&gt;bases)
    {
      /* If we are a subclass, then we strduped our name */
      free(self-&gt;tp_name);

      /* And we allocated our own protocol structures */
      if (self-&gt;tp_as_number)   free(self-&gt;tp_as_number);
      if (self-&gt;tp_as_sequence) free(self-&gt;tp_as_sequence);
      if (self-&gt;tp_as_mapping)  free(self-&gt;tp_as_mapping);
      
      Py_DECREF(self-&gt;bases);
    }
  if (((PyExtensionClass*)self-&gt;ob_type) != self) {
      Py_XDECREF(self-&gt;ob_type);
  }
  PyObject_DEL(self);
}
</t>
<t tx="ekr.20040104185809.229">static PyObject *
ExtensionClass_FindInstanceAttribute(PyObject *inst, PyObject *oname,
				     char *name)
{
  /* Look up an attribute for an instance from:

     The instance dictionary,
     The class dictionary, or
     The base objects.
   */
  PyObject *r=0;
  PyExtensionClass *self;

  if (! name) return NULL;

  self=(PyExtensionClass*)(inst-&gt;ob_type);

  if (*name=='_' &amp;&amp; name[1]=='_')
    {
      char *n=name+2;
      if (*n == 'c' &amp;&amp; strcmp(n,"class__")==0)
	{
	  Py_INCREF(self);
	  return (PyObject*)self;
	}
      if (ClassHasInstDict(self) &amp;&amp; *n=='d' &amp;&amp; strcmp(n,"dict__")==0)
	{
	  r = INSTANCE_DICT(inst);
	  Py_INCREF(r);
	  return r;
	}
    }

  if (ClassHasInstDict(self))
    {
      r= INSTANCE_DICT(inst);
      if (PyDict_Check(r))
        {
          r = PyDict_GetItem(r,oname);
          Py_XINCREF(r);
        }
      else
        {
          UNLESS (r = PyObject_GetItem(r,oname))
            PyErr_Clear();
        }

      if (r)
        {
          if (NeedsToBeBound(r))
            {
              ASSIGN(r, CallMethodO(r, py__of__, Build("(O)", inst), NULL));
            }
          return r;
        }
    }

  if (*name=='_' &amp;&amp; name[1]=='_' 
      &amp;&amp; 
      (   (name[2]=='b' &amp;&amp; strcmp(name+2,"bases__")==0) 
          || (name[2]=='d' &amp;&amp; strcmp(name+2,"dict__")==0)
          )
      )
    {
      PyErr_SetObject(PyExc_AttributeError, oname);
      return NULL;
    }
  
  UNLESS(r=CCL_getattr(self,oname,0)) return NULL;
  
  /* We got something from our class, maybe its an unbound method. */
  if (UnboundCMethod_Check(r))
    ASSIGN(r,(PyObject*)bindCMethod((CMethod*)r,inst));
  else if (UnboundPMethod_Check(r))
    ASSIGN(r,bindPMethod((PMethod*)r,inst));
      
  return r;
}
</t>
<t tx="ekr.20040104185809.230">static PyObject *
EC_findiattrs(PyObject *self, char *name)
{
  PyObject *s, *r;

  UNLESS(s=PyString_FromString(name)) return NULL;
  r=ExtensionClass_FindInstanceAttribute(self,s,name);
  Py_DECREF(s);
  return r;
}
</t>
<t tx="ekr.20040104185809.231">static PyObject *
EC_findiattro(PyObject *self, PyObject *name)
{
  return ExtensionClass_FindInstanceAttribute(self,name,
					      PyString_AsString(name));
}
</t>
<t tx="ekr.20040104185809.232">static int
subclass_simple_setattr(PyObject *self, char *name, PyObject *v);

static PyObject *
CCL_getattr2(PyObject *self, PyObject *oname, int look_super)
{
  PyObject *r=0, *b, *d;

  if (ExtensionClass_Check(self))
    {
      b=((PyExtensionClass*)self)-&gt;bases;
      d=((PyExtensionClass*)self)-&gt;class_dictionary;
    }
  else if (PyClass_Check(self))
    {
      b=((PyClassObject*)self)-&gt;cl_bases;
      d=((PyClassObject*)self)-&gt;cl_dict;
    }
  else
    {
      UNLESS (r=PyObject_GetAttr(self, oname)) PyErr_Clear();
      return r;
    }

  if (! look_super &amp;&amp; d)
    {
      if (PyDict_Check(d))
        {
          if((r=PyDict_GetItem(d, oname)))
            {          
              Py_INCREF(r);
              return r;
            }
        }
      else
        {
          if((r=PyObject_GetItem(d, oname))) return r;
          PyErr_Clear();
        }
    }

  if (b)
    {
      int n, i;
      
      n = PyTuple_Check(b) ? PyTuple_GET_SIZE(b) : 0; /* I don't care ;) */
      for (i=0; i &lt; n; i++)
        {
          r=CCL_getattr2(PyTuple_GET_ITEM(b, i), oname, 0);
          if (r) return r;
        }
    }

  return NULL;
}
</t>
<t tx="ekr.20040104185809.233">static PyObject *
CCL_getattr(PyExtensionClass *self, PyObject *oname, int look_super)
{
  PyObject *r=0;

  UNLESS (r=CCL_getattr2(OBJECT(self), oname, look_super)) 
    {
      PyErr_SetObject(PyExc_AttributeError, oname);
      return NULL;
    }

  if (PyFunction_Check(r) || NeedsToBeBound(r))
    ASSIGN(r,newPMethod(self,r));
  else if (PyMethod_Check(r) &amp;&amp; ! PyMethod_Self(r))
    ASSIGN(r,newPMethod(self, PyMethod_Function(r)));

  return r;
}
</t>
<t tx="ekr.20040104185809.234">static PyObject *
CCL_reduce(PyExtensionClass *self, PyObject *args)
{
  return PyString_FromString(self-&gt;tp_name);
}
</t>
<t tx="ekr.20040104185809.235">PyObject *
CCL_getattro(PyExtensionClass *self, PyObject *name)
{
  char *n, *nm=0;
  PyObject *r;

  if (PyString_Check(name) &amp;&amp; (n=nm=PyString_AS_STRING((PyStringObject*)name)))
    {
      if (*n=='_' &amp;&amp; *++n=='_')
	{
	  switch (*++n)
	    {
	    case 's':
	      if (strcmp(n,"safe_for_unpickling__")==0)
		return PyInt_FromLong(1);
	      break;
	    case 'n':
	      if (strcmp(n,"name__")==0)
		return PyString_FromString(self-&gt;tp_name);
	      break;
	    case 'b':
	      if (strcmp(n,"bases__")==0)
		{
		  if (self-&gt;bases)
		    {
		      Py_INCREF(self-&gt;bases);
		      return self-&gt;bases;
		    }
		  else
		    return PyTuple_New(0);
		}
	      break;
	    case 'r':
	      if (strcmp(n,"reduce__")==0)
		return newCMethod(self,(PyObject*)self,
		   "__reduce__",(PyCFunction)CCL_reduce,0,
		   "__reduce__() -- Reduce the class to a class name");
	      break;
	    case 'd':
	      if (strcmp(n,"dict__")==0)
		{
		  Py_INCREF(self-&gt;class_dictionary);
		  return self-&gt;class_dictionary;
		}
	      break;
	    case 'c':
	      if (strcmp(n,"class__")==0)
		{
		  Py_INCREF(self-&gt;ob_type);
		  return OBJECT(self-&gt;ob_type);
		}
	      break;
	    }
	}
    }

  if ((r=CCL_getattr(self,name,0)))
    {
      if (UnboundCMethod_Check(r) &amp;&amp; (AsCMethod(r)-&gt;flags &amp; METH_CLASS_METHOD))
	ASSIGN(r,(PyObject*)bindCMethod((CMethod*)r,OBJECT(self)));
    }
   
  return r;
}
</t>
<t tx="ekr.20040104185809.236">static int
CCL_setattro(PyExtensionClass *self, PyObject *name, PyObject *v)
{
  if (! v) return PyObject_DelItem(self-&gt;class_dictionary, name);

  if (v &amp;&amp; UnboundCMethod_Check(v) &amp;&amp;
     ! (self-&gt;class_flags &amp; EXTENSIONCLASS_METHODHOOK_FLAG)
     )
    {
      char *n;
      PyNumberMethods *nm;
      PySequenceMethods *s, *ms;
      PyMappingMethods *m, *mm;

      UNLESS(n=PyString_AsString(name)) return -1;
      if (*n++=='_' &amp;&amp; *n++=='_')
	{
#define SET_SPECIAL(C,P) \
	  if (strcmp(n,#P "__")==0 \
	     &amp;&amp; AsCMethod(v)-&gt;meth==(PyCFunction)C ## _by_name \
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type)) { \
	      self-&gt;tp_ ## C=AsCMethod(v)-&gt;type-&gt;tp_ ## C; \
	      return PyObject_SetItem(self-&gt;class_dictionary, name, v); }
	  /*
	  SET_SPECIAL(setattr,setattr);
	  SET_SPECIAL(setattro,setattr);
	  */
	  SET_SPECIAL(compare,cmp);
	  SET_SPECIAL(hash,hash);
	  SET_SPECIAL(repr,repr);
	  SET_SPECIAL(call,call);
	  SET_SPECIAL(str,str);
#undef SET_SPECIAL

#define SET_SPECIAL(C,P) \
	  if (strcmp(n,#P "__")==0 \
	     &amp;&amp; AsCMethod(v)-&gt;meth==(PyCFunction)C ## _by_name \
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type) \
	     &amp;&amp; (nm=self-&gt;tp_as_number)) { \
	      nm-&gt;nb_ ## C=AsCMethod(v)-&gt;type-&gt;tp_as_number-&gt;nb_ ## C; \
	      return PyObject_SetItem(self-&gt;class_dictionary, name, v); } 

	  SET_SPECIAL(add,add);
	  SET_SPECIAL(subtract,sub);
	  SET_SPECIAL(multiply,mult);
	  SET_SPECIAL(divide,div);
	  SET_SPECIAL(remainder,mod);
	  SET_SPECIAL(power,pow);
	  SET_SPECIAL(divmod,divmod);
	  SET_SPECIAL(lshift,lshift);
	  SET_SPECIAL(rshift,rshift);
	  SET_SPECIAL(and,and);
	  SET_SPECIAL(or,or);
	  SET_SPECIAL(xor,xor);
	  SET_SPECIAL(coerce,coerce);
	  SET_SPECIAL(negative,neg);
	  SET_SPECIAL(positive,pos);
	  SET_SPECIAL(absolute,abs);
	  SET_SPECIAL(nonzero,nonzero);
	  SET_SPECIAL(invert,inv);
	  SET_SPECIAL(int,int);
	  SET_SPECIAL(long,long);
	  SET_SPECIAL(float,float);
	  SET_SPECIAL(oct,oct);
	  SET_SPECIAL(hex,hex);
#undef SET_SPECIAL

	  if (strcmp(n,"len__")==0
	     &amp;&amp; AsCMethod(v)-&gt;meth==(PyCFunction)length_by_name 
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type))
	     {
	       if ((s=self-&gt;tp_as_sequence) &amp;&amp;
		  (ms=AsCMethod(v)-&gt;type-&gt;tp_as_sequence) &amp;&amp;
		  ms-&gt;sq_length)
		 s-&gt;sq_length=ms-&gt;sq_length;
	       if ((m=self-&gt;tp_as_mapping) &amp;&amp;
		  (mm=AsCMethod(v)-&gt;type-&gt;tp_as_mapping) &amp;&amp;
		  mm-&gt;mp_length)
		 m-&gt;mp_length=mm-&gt;mp_length;
	       return PyObject_SetItem(self-&gt;class_dictionary, name, v);
	     } 

	  if (strcmp(n,"getitem__")==0
	     &amp;&amp; AsCMethod(v)-&gt;meth==(PyCFunction)getitem_by_name 
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type))
	     {
	       if ((s=self-&gt;tp_as_sequence) &amp;&amp;
		  (ms=AsCMethod(v)-&gt;type-&gt;tp_as_sequence) &amp;&amp;
		  ms-&gt;sq_item)
		 s-&gt;sq_item=ms-&gt;sq_item;
	       if ((m=self-&gt;tp_as_mapping) &amp;&amp;
		  (mm=AsCMethod(v)-&gt;type-&gt;tp_as_mapping) &amp;&amp;
		  mm-&gt;mp_subscript)
		 m-&gt;mp_subscript=mm-&gt;mp_subscript;
	       return PyObject_SetItem(self-&gt;class_dictionary, name, v);
	     } 

	  if (strcmp(n,"setitem__")==0 &amp;&amp;
	     AsCMethod(v)-&gt;meth==(PyCFunction)setitem_by_name 
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type))
	     {
	       if ((s=self-&gt;tp_as_sequence) &amp;&amp;
		  (ms=AsCMethod(v)-&gt;type-&gt;tp_as_sequence) &amp;&amp;
		  ms-&gt;sq_ass_item)
		 s-&gt;sq_ass_item=ms-&gt;sq_ass_item;
	       if ((m=self-&gt;tp_as_mapping) &amp;&amp;
		  (mm=AsCMethod(v)-&gt;type-&gt;tp_as_mapping) &amp;&amp;
		  mm-&gt;mp_ass_subscript)
		 m-&gt;mp_ass_subscript=mm-&gt;mp_ass_subscript;
	       return PyObject_SetItem(self-&gt;class_dictionary, name, v);
	     } 

#define SET_SPECIAL(C,P) \
	  if (strcmp(n,#P "__")==0 \
	     &amp;&amp; AsCMethod(v)-&gt;meth==(PyCFunction)C ## _by_name \
	     &amp;&amp; Subclass_Check(self,AsCMethod(v)-&gt;type) \
	     &amp;&amp; (s=self-&gt;tp_as_sequence)) { \
	      s-&gt;sq_ ## C=AsCMethod(v)-&gt;type-&gt;tp_as_sequence-&gt;sq_ ## C; \
	      return PyObject_SetItem(self-&gt;class_dictionary, name, v); } 
	  SET_SPECIAL(slice,getslice);
	  SET_SPECIAL(ass_slice,setslice);
	  SET_SPECIAL(concat,concat);
	  SET_SPECIAL(repeat,repeat);
#undef SET_SPECIAL

	}
    }
  return PyObject_SetItem(self-&gt;class_dictionary, name, v);
}
</t>
<t tx="ekr.20040104185809.237">static PyObject *
CCL_call(PyExtensionClass *self, PyObject *arg, PyObject *kw)
{
  PyObject *inst=0, *init=0, *args=0;
  int size = 0;

  if (! self-&gt;tp_dealloc)
    {
      PyErr_SetString(PyExc_TypeError,
		      "Attempt to create instance of an abstract type");
      return NULL;
    }

  if (self-&gt;tp_itemsize)
    {
      /* We have a variable-sized object, we need to get it's size */
      PyObject *var_size;
      
      if ((var_size=CCL_getattr(self,py__var_size__, 0)))
	{
	  UNLESS_ASSIGN(var_size,PyObject_CallObject(var_size,arg))
	    return NULL;
	  size=PyInt_AsLong(var_size);
	  if (PyErr_Occurred()) return NULL;
	}
      else
	{
	  UNLESS(-1 != (size=PyTuple_Size(arg))) return NULL;
	  if (size &gt; 0)
	    {
	      var_size=PyTuple_GET_ITEM(arg, 0);
	      if (PyInt_Check(var_size))
		size=PyInt_AsLong(var_size);
	      else
		size=-1;
	    }
	  else
	    size=-1;
	  if (size &lt; 0)
	    {
	      PyErr_SetString(PyExc_TypeError,
			      "object size expected as first argument");
	      return NULL;
	    }
	}
    }
  UNLESS(inst=EC_NewObject((PyTypeObject *)self, size)) return NULL;

  if (ClassHasInstDict(self))
    UNLESS(INSTANCE_DICT(inst)=PyDict_New()) goto err;

   if ((init=CCL_getattr(self,py__init__,0)))
      {
       UNLESS(args=Py_BuildValue("(O)",inst)) goto err;
       if (arg) UNLESS_ASSIGN(args,PySequence_Concat(args,arg)) goto err;
       UNLESS_ASSIGN(args,PyEval_CallObjectWithKeywords(init,args,kw)) goto err;
       Py_DECREF(args);
       Py_DECREF(init);
      }
   else PyErr_Clear();

  if (self-&gt;bases &amp;&amp; subclass_watcher &amp;&amp;
     ! PyObject_CallMethod(subclass_watcher,"created","O",inst))
    PyErr_Clear();

  return inst;
err:
  Py_DECREF(inst);
  Py_XDECREF(init);
  Py_XDECREF(args);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.238">static PyObject *
CCL_repr(PyExtensionClass *self)
{
  char p[128], *pp;
  PyObject *m;

  if ((m=PyObject_GetAttr(OBJECT(self), py__module__)))
    {
      if (! PyObject_IsTrue(m)) 
	{
	  Py_DECREF(m);
	  m=0;
	}
    }
  else PyErr_Clear();

  sprintf(p,"%p",self);
  if (*p=='0' &amp;&amp; p[1]=='x') pp=p+2;
  else                      pp=p;
			      

  if (m) ASSIGN(m, JimString_Build("&lt;extension class %s.%s at %s&gt;","Oss",
				   m, self-&gt;tp_name, pp));
  else          m= JimString_Build("&lt;extension class %s at %s&gt;","ss",
				   self-&gt;tp_name, pp);

  return m;
}
</t>
<t tx="ekr.20040104185809.239">static PyTypeObject ECTypeType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "ExtensionClass Class",	/*tp_name*/
  sizeof(PyExtensionClass),    	/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)CCL_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*tp_getattr*/
  (setattrfunc)0,		/*tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)CCL_repr,		/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  0,				/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)CCL_call,       	/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)CCL_getattro,	/*tp_getattr with object key*/
  (setattrofunc)CCL_setattro,	/*tp_setattr with object key*/
  /* Space for future expansion */
  0L,0L,
  "Class of C classes" /* Documentation string */
};

/* End of code for ExtensionClass objects */
/* -------------------------------------------------------- */

/* subclassing code: */
  
static PyObject *
subclass_getspecial(PyObject *inst, PyObject *oname)
{
  PyObject *r=0;
  PyExtensionClass *self;

  self=(PyExtensionClass*)(inst-&gt;ob_type);
  if (HasInstDict(inst))
    {
      r= INSTANCE_DICT(inst);
      if (PyDict_Check(r))
        {
          if ((r = PyDict_GetItem(r,oname)))
            Py_INCREF(r);
          else
            r=CCL_getattr(self,oname,0);
        }
      else
        {
          UNLESS (r = PyObject_GetItem(r,oname))
            {
              PyErr_Clear();
              r=CCL_getattr(self,oname,0);
            }
        }
    }
  else 
    r=CCL_getattr(self,oname,0);
  
  return r;
}
</t>
<t tx="ekr.20040104185809.240">static PyObject *
subclass_getattro(PyObject *self, PyObject *name)
{
  PyObject *r;

  if (! name) return NULL;
  UNLESS(r=EC_findiattro(self,name))
    {
      PyErr_Clear();
      r=EC_findiattro(self,py__getattr__);
      if (r) ASSIGN(r,PyObject_CallFunction(r,"O",name));
      if (r &amp;&amp; NeedsToBeBound(r))
	ASSIGN(r, CallMethodO(r, py__of__, Build("(O)", self), NULL));
    }
  return r;
}
</t>
<t tx="ekr.20040104185809.241">static int
subclass_simple_setattro(PyObject *self, PyObject *name, PyObject *v)
{
  if (! HasInstDict(self))
    {
      PyErr_SetObject(PyExc_AttributeError, name);
      return -1;
    }
  if (v)
    return PyDict_SetItem(INSTANCE_DICT(self),name,v);
  else
    return PyDict_DelItem(INSTANCE_DICT(self),name);
}
</t>
<t tx="ekr.20040104185809.242">static int
subclass_simple_setattr(PyObject *self, char *name, PyObject *v)
{
  if (! HasInstDict(self))
    {
      PyErr_SetString(PyExc_AttributeError, name);
      return -1;
    }
  if (v)
    return PyDict_SetItemString(INSTANCE_DICT(self),name,v);
  else
    return PyDict_DelItemString(INSTANCE_DICT(self),name);
}
</t>
<t tx="ekr.20040104185809.243">static int 
subclass_setattr(PyObject *self, PyObject *oname, char *name, PyObject *v)
{
  PyObject *m=0, *et, *ev, *etb;

  if (! name) return -1;

  if (!v &amp;&amp; (m=subclass_getspecial(self,py__delattr__)))
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OO",self,oname)) return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",oname)) return -1;
      Py_DECREF(m);
      return 0;
    }

  UNLESS(m=subclass_getspecial(self,py__setattr__))
    goto default_setattr;
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)setattr_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type))
    {
      UNLESS(-1 != AsCMethod(m)-&gt;type-&gt;tp_setattr(self,name,v))
	goto dictionary_setattr;
      return 0;
    }
  else 
    if (UnboundCMethod_Check(m)
       &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)setattro_by_name
       &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type))
      {
	UNLESS(-1 != AsCMethod(m)-&gt;type-&gt;tp_setattro(self,oname,v))
	  goto dictionary_setattr;
	return 0;
      }
  if (! v) goto default_setattr;
  if (UnboundEMethod_Check(m))
    {
      UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OOO",self,oname,v)) return -1;
    }
  else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OO",oname,v)) return -1;
  Py_DECREF(m);
  return 0;

dictionary_setattr:

  Py_XDECREF(m);

  PyErr_Fetch(&amp;et, &amp;ev, &amp;etb);
  if (et==PyExc_AttributeError)
    {
      char *s;
      
      if (ev &amp;&amp; PyString_Check(ev) &amp;&amp; (s=PyString_AsString(ev)) &amp;&amp;
	 strcmp(s,name)==0)
	{
	  Py_XDECREF(et);
	  Py_XDECREF(ev);
	  Py_XDECREF(etb);
	  et=0;
	}
    }
  if (et)
    {
      PyErr_Restore(et,ev,etb);
      return -1;
    }	
  
default_setattr:

  PyErr_Clear();
  
  return subclass_simple_setattro(self, oname, v);
}
</t>
<t tx="ekr.20040104185809.244">static int
subclass_setattro(PyObject *self, PyObject *name, PyObject *v)
{
  return subclass_setattr(self,name,PyString_AsString(name),v);
}
</t>
<t tx="ekr.20040104185809.245">static int
subclass_compare(PyObject *self, PyObject *v)
{
  PyObject *m;
  long r;

  UNLESS(m=subclass_getspecial(self,py__cmp__))
    {
      PyErr_Clear();
      return self-v;
    }

  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)compare_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    r=AsCMethod(m)-&gt;type-&gt;tp_compare(self,v);
  else
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OO",self,v))
	    return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",v)) return -1;
      r=PyInt_AsLong(m);
    }
  Py_DECREF(m);
  return r;
}</t>
<t tx="ekr.20040104185809.246">static long
subclass_hash(PyObject *self)
{
  PyObject *m;
  long r;

  UNLESS(m=subclass_getspecial(self,py__hash__)) return -1;
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)hash_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    r=AsCMethod(m)-&gt;type-&gt;tp_hash(self);
  else
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",self))
	    return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"")) return -1;
      r=PyInt_AsLong(m);
    }
  Py_DECREF(m);
  return r;
}</t>
<t tx="ekr.20040104185809.247">static PyObject *
default_subclass_repr(PyObject *self)
{
  char p[128], *pp;
  
  PyErr_Clear();
  sprintf(p,"%p",self);
  if (*p=='0' &amp;&amp; p[1]=='x') pp=p+2;
  else                      pp=p;
  return JimString_Build("&lt;%s instance at %s&gt;","ss",
			self-&gt;ob_type-&gt;tp_name, pp);
}
</t>
<t tx="ekr.20040104185809.248">static PyObject *
subclass_repr(PyObject *self)
{
  PyObject *m;

  UNLESS(m=subclass_getspecial(self,py__repr__))
    return default_subclass_repr(self);

  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)repr_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_repr(self));
  else if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"O",self));
  else
    ASSIGN(m,PyObject_CallFunction(m,""));
  return m;
}</t>
<t tx="ekr.20040104185809.249">static PyObject *
subclass_call(PyObject *self, PyObject *args, PyObject *kw)
{
  PyObject *m;

  UNLESS(m=subclass_getspecial(self,py__call__)) return NULL;
  if (UnboundCMethod_Check(m) &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)call_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_call(self,args,kw));
  else
    {
      if (UnboundEMethod_Check(m))
	{
	  PyObject *a;
	  a=Py_BuildValue("(O)",self);
	  if (a) ASSIGN(a,PySequence_Concat(a,args));
	  if (a) ASSIGN(m,PyEval_CallObjectWithKeywords(m,a,kw));
	  else  ASSIGN(m,NULL);
	  Py_XDECREF(a);
	}
      else
	ASSIGN(m,PyEval_CallObjectWithKeywords(m,args,kw));
    }
  return m;
}</t>
<t tx="ekr.20040104185809.250">static PyObject *
subclass_str(PyObject *self)
{
  PyObject *m;

  UNLESS(m=subclass_getspecial(self,py__str__))
    {
      PyErr_Clear();
      return subclass_repr(self);
    }
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)str_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_str(self));
  else if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"O",self));
  else
    ASSIGN(m,PyObject_CallFunction(m,""));
  return m;
}</t>
<t tx="ekr.20040104185809.251">#define BINSUB(M,N,A) \
static PyObject * \
subclass_ ## M(PyObject *self, PyObject *v) \
{ \
  PyObject *m; \
  UNLESS(m=subclass_getspecial(self,py__ ## N ## __)) return NULL; \
  if (UnboundCMethod_Check(m) \
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)M ## _by_name \
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type) \
     &amp;&amp; ! HasMethodHook(self)) \
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_ ## M(self,v)); \
  else if (UnboundEMethod_Check(m)) \
    ASSIGN(m,PyObject_CallFunction(m,"OO",self,v)); \
  else \
    ASSIGN(m,PyObject_CallFunction(m,"O",v)); \
  return m; \
}  

static PyObject * 
subclass_add(PyObject *self, PyObject *v)
{ 
  PyObject *m; 

  UNLESS(m=subclass_getspecial(self,py__add__)) return NULL; 

  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)concat_by_name 
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self)) 
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_sequence-&gt;sq_concat(self,v)); 
  else if (UnboundCMethod_Check(m)
	  &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)add_by_name 
	  &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
	  &amp;&amp; ! HasMethodHook(self)) 
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_add(self,v)); 
  else if (UnboundEMethod_Check(m)) 
    ASSIGN(m,PyObject_CallFunction(m,"OO",self,v)); 
  else 
    ASSIGN(m,PyObject_CallFunction(m,"O",v)); 

  return m; 
}</t>
<t tx="ekr.20040104185809.252">BINSUB(subtract,sub,Subtract)

static PyObject * 
subclass_multiply(PyObject *self, PyObject *v)
{ 
  PyObject *m; 

  UNLESS(m=subclass_getspecial(self,py__mul__)) return NULL; 
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)repeat_by_name 
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      int i;

      i=PyInt_AsLong(v);
      if (i==-1 &amp;&amp; PyErr_Occurred()) return NULL;
      ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_sequence-&gt;sq_repeat(self,i));
    }
  else if (UnboundCMethod_Check(m)
	  &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)multiply_by_name 
	  &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
	  &amp;&amp; ! HasMethodHook(self)) 
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_multiply(self,v)); 
  else if (UnboundEMethod_Check(m)) 
    ASSIGN(m,PyObject_CallFunction(m,"OO",self,v)); 
  else 
    ASSIGN(m,PyObject_CallFunction(m,"O",v)); 
  return m; 
}</t>
<t tx="ekr.20040104185809.253">BINSUB(divide,div,Divide)
BINSUB(remainder,mod,Remainder)

static PyObject * 
subclass_power(PyObject *self, PyObject *v, PyObject *w) 
{ 
  PyObject *m; 
  UNLESS(m=subclass_getspecial(self,py__pow__)) return NULL; 
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)power_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self)) 
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_power(self,v,w));
  else if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"OOO",self,v,w));
  else
    ASSIGN(m,PyObject_CallFunction(m,"OO",v,w)); 
  return m; 
}</t>
<t tx="ekr.20040104185809.254">BINSUB(divmod,divmod,Divmod)
BINSUB(lshift,lshift,Lshift)
BINSUB(rshift,rshift,Rshift)
BINSUB(and,and,And)
BINSUB(or,or,Or)
BINSUB(xor,xor,Xor)


static int
subclass_coerce(PyObject **self, PyObject **v) 
{ 
  PyObject *m; 
  int r;

  UNLESS(m=subclass_getspecial(*self,py__coerce__))
    {
      PyErr_Clear();
      Py_INCREF(*self);
      Py_INCREF(*v);
      return 0;
    }
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)coerce_by_name
     &amp;&amp; SubclassInstance_Check(*self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(*self)) 
    r=AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_coerce(self,v);
  else 
    { 
      if (UnboundEMethod_Check(m))
	ASSIGN(m,PyObject_CallFunction(m,"OO",*self,*v));
      else
	ASSIGN(m,PyObject_CallFunction(m,"O",*v));

      UNLESS (m) return -1;

      if (m==Py_None) r=-1;
      else
	{
	  if (PyArg_ParseTuple(m,"OO", self, v))
	    {
	      Py_INCREF(*self);
	      Py_INCREF(*v);
	      r=0;
	    }
	  else r=-1;
	}
    } 
  Py_DECREF(m);
  return r; 
}</t>
<t tx="ekr.20040104185809.255">#define UNSUB(M,N) \
static PyObject * \
subclass_ ## M(PyObject *self) \
{ \
  PyObject *m; \
  UNLESS(m=subclass_getspecial(self,py__ ## N ## __)) return NULL; \
  if (UnboundCMethod_Check(m) \
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)M ## _by_name \
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type) \
     &amp;&amp; ! HasMethodHook(self)) \
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_ ## M(self)); \
  else if (UnboundEMethod_Check(m)) \
    ASSIGN(m,PyObject_CallFunction(m,"O",self)); \
  else \
    ASSIGN(m,PyObject_CallFunction(m,"")); \
  return m; \
}  

UNSUB(negative, neg)
UNSUB(positive, pos)
UNSUB(absolute, abs)

static int
subclass_nonzero(PyObject *self)
{
  PyObject *m;
  long r;

  UNLESS(m=subclass_getspecial(self,py__nonzero__))
    { /* We are being asked is we are true
	 Check out len, and if that fails, say we are true.
       */
      PyErr_Clear();
      UNLESS(m=subclass_getspecial(self,py__len__))
	{
	  PyErr_Clear();
	  return 1;
	}
    }
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)nonzero_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    r=AsCMethod(m)-&gt;type-&gt;tp_as_number-&gt;nb_nonzero(self);
  else
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",self))
	    return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"")) return -1;
      r=PyInt_AsLong(m);
    }
  Py_DECREF(m);
  return r;
}</t>
<t tx="ekr.20040104185809.256">UNSUB(invert, inv)
UNSUB(int, int)
UNSUB(long, long)
UNSUB(float, float)
UNSUB(oct, oct)
UNSUB(hex, hex)

#undef UNSUB
#undef BINSUB


static PyNumberMethods subclass_as_number = {
  (binaryfunc)subclass_add,		/*nb_add*/
  (binaryfunc)subclass_subtract,	/*nb_subtract*/
  (binaryfunc)subclass_multiply,	/*nb_multiply*/
  (binaryfunc)subclass_divide,		/*nb_divide*/
  (binaryfunc)subclass_remainder,	/*nb_remainder*/
  (binaryfunc)subclass_divmod,		/*nb_divmod*/
  (ternaryfunc)subclass_power,		/*nb_power*/
  (unaryfunc)subclass_negative,		/*nb_negative*/
  (unaryfunc)subclass_positive,		/*nb_positive*/
  (unaryfunc)subclass_absolute,		/*nb_absolute*/
  (inquiry)subclass_nonzero,		/*nb_nonzero*/
  (unaryfunc)subclass_invert,		/*nb_invert*/
  (binaryfunc)subclass_lshift,		/*nb_lshift*/
  (binaryfunc)subclass_rshift,		/*nb_rshift*/
  (binaryfunc)subclass_and,		/*nb_and*/
  (binaryfunc)subclass_xor,		/*nb_xor*/
  (binaryfunc)subclass_or,		/*nb_or*/
  (coercion)subclass_coerce,		/*nb_coerce*/
  (unaryfunc)subclass_int,		/*nb_int*/
  (unaryfunc)subclass_long,		/*nb_long*/
  (unaryfunc)subclass_float,		/*nb_float*/
  (unaryfunc)subclass_oct,		/*nb_oct*/
  (unaryfunc)subclass_hex,		/*nb_hex*/
};

static long
subclass_length(PyObject *self)
{
  PyObject *m;
  long r;
  PyExtensionClass *t;

  UNLESS(m=subclass_getspecial(self,py__len__))
    {
      /* Hm. Maybe we are being checked to see if we are true.

	 Check to see if we have a __getitem__.  If we don't, then
	 answer that we are true.
       */
      PyErr_Clear();
      if ((m=subclass_getspecial(self,py__getitem__)))
	{
	  /* Hm, we have getitem, must be error */
	  Py_DECREF(m);
	  PyErr_SetObject(PyExc_AttributeError, py__len__);
	  return -1;
	}
      PyErr_Clear();
      return subclass_nonzero(self);
    }
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)length_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      t=(PyExtensionClass*)AsCMethod(m)-&gt;type;
      Py_DECREF(m);
      if (t-&gt;tp_as_sequence)
	return t-&gt;tp_as_sequence-&gt;sq_length(self);
      else
	return t-&gt;tp_as_mapping-&gt;mp_length(self);
    }
  if (UnboundEMethod_Check(m))
    {
      UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",self)) return -1;
    }
  else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"")) return -1;
  r=PyInt_AsLong(m);
  Py_DECREF(m);
  return r;
}
</t>
<t tx="ekr.20040104185809.257">static PyObject *
subclass_item(PyObject *self, int index)
{
  PyObject *m;
  PyExtensionClass *t;

  UNLESS(m=subclass_getspecial(self,py__getitem__)) return NULL;
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)getitem_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      t=(PyExtensionClass*)AsCMethod(m)-&gt;type;
      if (t-&gt;tp_as_sequence &amp;&amp; t-&gt;tp_as_sequence-&gt;sq_item)
	{
	  Py_DECREF(m);
	  return t-&gt;tp_as_sequence-&gt;sq_item(self,index);
	}
    }
  if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"Oi",self,index));
  else
    ASSIGN(m,PyObject_CallFunction(m,"i",index));
  return m;
}
</t>
<t tx="ekr.20040104185809.258">static PyObject *
subclass_slice(PyObject *self, int i1, int i2)
{
  PyObject *m;

  UNLESS(m=subclass_getspecial(self,py__getslice__)) return NULL;
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)slice_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_sequence-&gt;sq_slice(self,i1,i2));
  else if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"Oii",self,i1,i2));
  else
    ASSIGN(m,PyObject_CallFunction(m,"ii",i1,i2));
  return m;
}
</t>
<t tx="ekr.20040104185809.259">static long
subclass_ass_item(PyObject *self, int index, PyObject *v)
{
  PyObject *m;
  PyExtensionClass *t;

  if (! v &amp;&amp; (m=subclass_getspecial(self,py__delitem__)))
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"Oi",self,index)) return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"i",index)) return -1;
      Py_DECREF(m);
      return 0;
    }

  UNLESS(m=subclass_getspecial(self,py__setitem__)) return -1;
  if (UnboundCMethod_Check(m) &amp;&amp;
     AsCMethod(m)-&gt;meth==(PyCFunction)setitem_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      t=(PyExtensionClass*)AsCMethod(m)-&gt;type;
      if (t-&gt;tp_as_sequence &amp;&amp; t-&gt;tp_as_sequence-&gt;sq_ass_item)
	{
	  Py_DECREF(m);
	  return t-&gt;tp_as_sequence-&gt;sq_ass_item(self,index,v);
	}
    }
  if (! v)
    {
      PyErr_SetObject(PyExc_AttributeError, py__delitem__);
      return -1;
    }
  if (UnboundEMethod_Check(m))
    {
      UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OiO",self,index,v)) return -1;
    }
  else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"iO",index,v)) return -1;
  Py_DECREF(m);
  return 0;
}
</t>
<t tx="ekr.20040104185809.260">static int
subclass_ass_slice(PyObject *self, int i1, int i2, PyObject *v)
{
  PyObject *m;
  long r;

  if (! v &amp;&amp; (m=subclass_getspecial(self,py__delslice__)))
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"Oii",self,i1,i2)) return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"ii",i1,i2)) return -1;
      Py_DECREF(m);
      return 0;
    }

  UNLESS(m=subclass_getspecial(self,py__setslice__)) return -1;
  if (UnboundCMethod_Check(m) &amp;&amp;
     AsCMethod(m)-&gt;meth==(PyCFunction)ass_slice_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {	
      r=AsCMethod(m)-&gt;type-&gt;tp_as_sequence-&gt;sq_ass_slice(self,i1,i2,v);
      Py_DECREF(m);
      return r;
    }

  if (! v)
    {
      PyErr_SetObject(PyExc_AttributeError, py__delslice__);
      return -1;
    }

  if (UnboundEMethod_Check(m))
    {
      UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OiiO",self,i1,i2,v))
	return -1;
    }
  else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"iiO",i1,i2,v)) return -1;
  Py_DECREF(m);
  return 0;
}</t>
<t tx="ekr.20040104185809.261">static PyObject *
subclass_repeat(PyObject *self, int v)
{
  PyObject *m;

  UNLESS(m=subclass_getspecial(self,py__mul__)) return NULL;
  if (UnboundCMethod_Check(m)
     &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)repeat_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    ASSIGN(m,AsCMethod(m)-&gt;type-&gt;tp_as_sequence-&gt;sq_repeat(self,v));
  else if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"Oi",self,v));
  else
    ASSIGN(m,PyObject_CallFunction(m,"i",v));
  return m;
}
</t>
<t tx="ekr.20040104185809.262">PySequenceMethods subclass_as_sequence = {
	(inquiry)subclass_length,   		/*sq_length*/
	(binaryfunc)subclass_add,		/*sq_concat*/
	(intargfunc)subclass_repeat,		/*sq_repeat*/
	(intargfunc)subclass_item,		/*sq_item*/
	(intintargfunc)subclass_slice,		/*sq_slice*/
	(intobjargproc)subclass_ass_item,	/*sq_ass_item*/
	(intintobjargproc)subclass_ass_slice,	/*sq_ass_slice*/
};

static PyObject *
subclass_subscript(PyObject *self, PyObject *key)
{
  PyObject *m;
  PyExtensionClass *t;

  UNLESS(m=subclass_getspecial(self,py__getitem__)) return NULL;
  if (UnboundCMethod_Check(m) &amp;&amp;
     AsCMethod(m)-&gt;meth==(PyCFunction)getitem_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      t=(PyExtensionClass*)AsCMethod(m)-&gt;type;
      if (t-&gt;tp_as_mapping &amp;&amp; t-&gt;tp_as_mapping-&gt;mp_subscript)
	{
	  Py_DECREF(m);
	  return t-&gt;tp_as_mapping-&gt;mp_subscript(self,key);
	}
      else if (t-&gt;tp_as_sequence &amp;&amp; t-&gt;tp_as_sequence-&gt;sq_item)
	{
	  int i, l;

	  Py_DECREF(m);
	  
	  UNLESS(PyInt_Check(key))
	    {
	      PyErr_SetString(PyExc_TypeError, "sequence subscript not int");
	      return NULL;
	    }
	  i=PyInt_AsLong(key);
	  if (i &lt; 0)
	    {
	      if ((l=PyObject_Length(self)) &lt; 0) return NULL;
	      i+=l;
	    }
	  return t-&gt;tp_as_sequence-&gt;sq_item(self,i);
	}
    }
  if (UnboundEMethod_Check(m))
    ASSIGN(m,PyObject_CallFunction(m,"OO",self,key));
  else
    ASSIGN(m,PyObject_CallFunction(m,"O",key));
  return m;
}
</t>
<t tx="ekr.20040104185809.263">static long
subclass_ass_subscript(PyObject *self, PyObject *index, PyObject *v)
{
  PyObject *m;
  PyExtensionClass *t;

  if (! v &amp;&amp; (m=subclass_getspecial(self,py__delitem__)))
    {
      if (UnboundEMethod_Check(m))
	{
	  UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OO",self,index)) return -1;
	}
      else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"O",index)) return -1;
      Py_DECREF(m);
      return 0;
    }

  UNLESS(m=subclass_getspecial(self,py__setitem__)) return -1;
  if (UnboundCMethod_Check(m) &amp;&amp;
     AsCMethod(m)-&gt;meth==(PyCFunction)setitem_by_name
     &amp;&amp; SubclassInstance_Check(self,AsCMethod(m)-&gt;type)
     &amp;&amp; ! HasMethodHook(self))
    {
      t=(PyExtensionClass*)AsCMethod(m)-&gt;type;
      if (t-&gt;tp_as_mapping &amp;&amp; t-&gt;tp_as_mapping-&gt;mp_ass_subscript)
	{
	  Py_DECREF(m);
	  return t-&gt;tp_as_mapping-&gt;mp_ass_subscript(self,index,v);
	}
      else if (t-&gt;tp_as_sequence &amp;&amp; t-&gt;tp_as_sequence-&gt;sq_ass_item)
	{
	  int i, l;

	  Py_DECREF(m);
	  
	  UNLESS(PyInt_Check(index))
	    {
	      PyErr_SetString(PyExc_TypeError, "sequence subscript not int");
	      return -1;
	    }
	  i=PyInt_AsLong(index);
	  if (i &lt; 0)
	    {
	      if ((l=PyObject_Length(self)) &lt; 0) return -1;
	      i+=l;
	    }
	  return t-&gt;tp_as_sequence-&gt;sq_ass_item(self,i,v);
	}
    }
  if (! v)
    {
      PyErr_SetObject(PyExc_AttributeError, py__delitem__);
      return -1;
    }
  if (UnboundEMethod_Check(m))
    {
      UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OOO",self,index,v)) return -1;
    }
  else UNLESS_ASSIGN(m,PyObject_CallFunction(m,"OO",index,v)) return -1;
  Py_DECREF(m);
  return 0;
}
</t>
<t tx="ekr.20040104185809.264">PyMappingMethods subclass_as_mapping = {
	(inquiry)subclass_length,		/*mp_length*/
	(binaryfunc)subclass_subscript,		/*mp_subscript*/
	(objobjargproc)subclass_ass_subscript,	/*mp_ass_subscript*/
};

static int
dealloc_base(PyObject *inst, PyExtensionClass* self)
{
  int i,l;
  PyObject *t;

  l=PyTuple_Size(self-&gt;bases);
  for (i=0; i &lt; l; i++)
    {
      t=PyTuple_GET_ITEM(self-&gt;bases, i);
      if (ExtensionClass_Check(t))
	{
	  if (AsExtensionClass(t)-&gt;bases)
	    {
	      if (dealloc_base(inst,AsExtensionClass(t))) return 1;
	    }
	  else
	    {
	      if (((PyExtensionClass*)t)-&gt;tp_dealloc)
		{
		  ((PyExtensionClass*)t)-&gt;tp_dealloc(inst);
		  return 1;
		}
	    }
	}
    }
  return 0;
}
</t>
<t tx="ekr.20040104185809.265">static void
subclass_dealloc(PyObject *self)
{
  PyObject *m, *t, *v, *tb;
  int base_dealloced;

#ifdef TRACE_DEALLOC
  fprintf(stderr,"Deallocating a %s\n", self-&gt;ob_type-&gt;tp_name);
#endif

  PyErr_Fetch(&amp;t,&amp;v,&amp;tb);
  Py_INCREF(self);		/* Give us a new lease on life */

  if (subclass_watcher &amp;&amp;
     ! PyObject_CallMethod(subclass_watcher,"destroying","O",self))
    PyErr_Clear();


  if ((m=subclass_getspecial(self,py__del__)))
    {
      if (UnboundEMethod_Check(m))
	ASSIGN(m,PyObject_CallFunction(m,"O",self));
      else
	ASSIGN(m,PyObject_CallFunction(m,""));
      Py_XDECREF(m);
    }

  PyErr_Clear();

  if (--self-&gt;ob_refcnt &gt; 0)
    {
      PyErr_Restore(t,v,tb);
      return; /* we added a reference; don't delete now */
    }
  
  if (HasInstDict(self)) {
      Py_XDECREF(INSTANCE_DICT(self));
  }

  /* See if there was a dealloc handler in a (C) base class.
     If there was, then it deallocates the object and we
     get a true value back. 

     Note that if there *is* a base class dealloc, then
     *it* should decref the class.
  */
  base_dealloced=dealloc_base(self,(PyExtensionClass*)self-&gt;ob_type);

  /* We only deallocate ourselves if a base class didn't */
  UNLESS(base_dealloced) 
    {
      Py_DECREF(self-&gt;ob_type);
      PyObject_DEL(self);
    }

  PyErr_Restore(t,v,tb);
}
</t>
<t tx="ekr.20040104185809.266">static void
datafull_baseclassesf(PyExtensionClass *type, PyObject **c1, PyObject **c2)
{
  /* Find the number of classes that have data and return them.
     There should be no more than one.
     */
  int l, i;
  PyObject *base;
  
  l=PyTuple_Size(type-&gt;bases);
  for (i=0; i &lt; l &amp;&amp; ! (*c1 &amp;&amp; *c2); i++)
    {
      base=PyTuple_GET_ITEM(type-&gt;bases, i);
      if (ExtensionClass_Check(base))
	{
	  if (AsExtensionClass(base)-&gt;bases)
	    datafull_baseclassesf(AsExtensionClass(base),c1,c2);
	  else
	    {
	      if (AsExtensionClass(base)-&gt;tp_basicsize &gt;
		 sizeof(PyPureMixinObject) ||
		 AsExtensionClass(base)-&gt;tp_itemsize &gt; 0)
		{
		  if (! *c1)
		    *c1=base;
		  else if (*c1 != base)
		    *c2=base;
		}      
	    }
	}
    }
}
</t>
<t tx="ekr.20040104185809.267">static int
datafull_baseclasses(PyExtensionClass *type)
{
  PyObject *c1=0, *c2=0;
  datafull_baseclassesf(type, &amp;c1, &amp;c2);
  if (c2) return 2;
  if (c1) return 1;
  return 0;
}
</t>
<t tx="ekr.20040104185809.268">static PyObject *
datafull_baseclass(PyExtensionClass *type)
{
  /* Find the baseclass that has data and.  There should be only one. */
  int l, i;
  PyObject *base, *dbase;
  
  l=PyTuple_Size(type-&gt;bases);
  for (i=0; i &lt; l; i++)
    {
      base=PyTuple_GET_ITEM(type-&gt;bases, i);
      if (ExtensionClass_Check(base))
	{
	  if (AsExtensionClass(base)-&gt;bases)
	    {
	      if ((dbase=datafull_baseclass(AsExtensionClass(base))))
		return dbase;
	    }
	  else
	    {
	      if (AsExtensionClass(base)-&gt;tp_basicsize &gt;
		 sizeof(PyPureMixinObject) ||
		 AsExtensionClass(base)-&gt;tp_itemsize &gt; 0)
		return base;
	    }
	}
    }
  return NULL;
}
</t>
<t tx="ekr.20040104185809.269">static PyObject *
extension_baseclass(PyExtensionClass *type)
{
  /* Find the first immediate base class that is an extension class */
  int l, i;
  PyObject *base;
  
  l=PyTuple_Size(type-&gt;bases);
  for (i=0; i &lt; l; i++)
    {
      base=PyTuple_GET_ITEM(type-&gt;bases, i);
      if (ExtensionClass_Check(base)) return base;
    }
  return JimErr_Format(PyExc_TypeError,
		      "No extension class found in subclass", NULL);
}
</t>
<t tx="ekr.20040104185809.270">static int 
subclass_hasattr(PyExtensionClass *type, PyObject *name)
{
  PyObject *o;

  if ((o=CCL_getattro(type,name)))
    {
      Py_DECREF(o);
      return 1;
    }
  PyErr_Clear();
  return 0;
}
</t>
<t tx="ekr.20040104185809.271">static void
subclass_init_getattr(PyExtensionClass *self, PyObject *methods)
{
  PyObject *m;

  if ((m=CCL_getattr(self,py__getattr__,0)))
    {
      if (UnboundCMethod_Check(m)
	 &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)getattr_by_name
	 &amp;&amp; Subclass_Check(self,AsCMethod(m)-&gt;type))
	{
	  self-&gt;tp_getattr=AsCMethod(m)-&gt;type-&gt;tp_getattr;
	}
      else if (UnboundCMethod_Check(m)
	      &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)getattro_by_name
	      &amp;&amp; Subclass_Check(self,AsCMethod(m)-&gt;type))
	{
	    self-&gt;tp_getattro=AsCMethod(m)-&gt;type-&gt;tp_getattro;
	}
      else
	{
	  PyObject_SetItem(methods,py__getattr__,m);
	  self-&gt;tp_getattro=subclass_getattro;
	}
      Py_DECREF(m);
    }
  else
    {
      PyErr_Clear();
      self-&gt;tp_getattro=EC_findiattro;
    }
}
</t>
<t tx="ekr.20040104185809.272">static void
subclass_init_setattr(PyExtensionClass *self, PyObject *methods)
{
  PyObject *m;
  
  if ((m=CCL_getattr(self,py__setattr__,0)))
    {
      if (UnboundCMethod_Check(m)
	 &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)setattr_by_name
	 &amp;&amp; Subclass_Check(self,AsCMethod(m)-&gt;type))
	{
	  self-&gt;tp_setattr=AsCMethod(m)-&gt;type-&gt;tp_setattr;
	}
      else if (UnboundCMethod_Check(m)
	      &amp;&amp; AsCMethod(m)-&gt;meth==(PyCFunction)setattro_by_name
	      &amp;&amp; Subclass_Check(self,AsCMethod(m)-&gt;type))
	  {
	    self-&gt;tp_setattro=AsCMethod(m)-&gt;type-&gt;tp_setattro;
	  }
      else
	{
	  PyObject_SetItem(methods,py__setattr__,m);
	  self-&gt;tp_setattro=subclass_setattro;
	}
      Py_DECREF(m);
    }
  else
    {
      PyErr_Clear();
      self-&gt;tp_setattro=subclass_simple_setattro;
    }
}
</t>
<t tx="ekr.20040104185809.273">static PyObject *
CopyMethods(PyExtensionClass *type, PyObject *base_methods)
{
  PyObject *methods, *key, *v;
  int pos;

  UNLESS(type-&gt;class_dictionary &amp;&amp; PyDict_Check(base_methods) &amp;&amp;
	 ExtensionInstance_Check(type-&gt;class_dictionary))
    {
      Py_INCREF(base_methods);
      return base_methods;
    }

  UNLESS(methods=
	 PyObject_CallObject((PyObject*)type-&gt;class_dictionary-&gt;ob_type, NULL))
    return NULL;

  for (pos=0; PyDict_Next(base_methods, &amp;pos, &amp;key, &amp;v); )
    UNLESS(0 &lt;= PyObject_SetItem(methods,key,v)) goto err;

  return methods;

err:
  Py_DECREF(methods);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.274">@ Constructor for building subclasses of C classes.   That is, we want to build a C class object that described a  subclass of a built-in type.
@c

static PyObject *
subclass__init__(PyExtensionClass *self, PyObject *args)
{
  PyObject *bases, *methods, *class_init;
  PyExtensionClass *type;
  char *name, *p;
  int l;

  UNLESS(PyArg_ParseTuple(args,"sOO", &amp;name, &amp;bases, &amp;methods)) return NULL;
  l=strlen(name)+1;
  UNLESS(p=(char*)malloc(l*sizeof(char))) return PyErr_NoMemory();
  memcpy(p,name,l);
  name=p;

  UNLESS(PyTuple_Check(bases) &amp;&amp; PyTuple_Size(bases))
    {
      PyErr_SetString
	(PyExc_TypeError,
	 "second argument must be a tuple of 1 or more base classes");
    }

  self-&gt;bases=bases;
  Py_INCREF(bases);

  if (datafull_baseclasses(self) &gt; 1)
    {
      PyErr_SetString(PyExc_TypeError, "too many datafull base classes");
      return NULL;
    }
  UNLESS(type=(PyExtensionClass *)datafull_baseclass(self))
    UNLESS(type=(PyExtensionClass *)extension_baseclass(self)) return NULL;
    
  self-&gt;tp_name=name;

  UNLESS(self-&gt;class_dictionary=CopyMethods(type,methods)) return NULL;

#define copy_member(M) self-&gt;M=type-&gt;M
  copy_member(ob_size);
  copy_member(class_flags);

  copy_member(tp_itemsize);
  copy_member(tp_print);
  self-&gt;tp_dealloc=subclass_dealloc;

  if (type-&gt;class_flags &amp; EXTENSIONCLASS_PYTHONICATTR_FLAG)
    {
      /* The base class wants subclass __get/setattr__ to have
         Python class semantics and *it* will be providing them.
	 That means that we simply copy the base class 
	 get/setattr.
      */
      copy_member(tp_getattr);
      copy_member(tp_getattro);
      copy_member(tp_setattr);
      copy_member(tp_setattro);
      self-&gt;class_flags |= EXTENSIONCLASS_PYTHONICATTR_FLAG;

      if (CCL_hasattr(self, py__getattr__))
	self-&gt;class_flags |= EXTENSIONCLASS_USERGETATTR_FLAG;
      if (CCL_hasattr(self, py__setattr__))
	self-&gt;class_flags |= EXTENSIONCLASS_USERSETATTR_FLAG;
      if (CCL_hasattr(self, py__delattr__))
	self-&gt;class_flags |= EXTENSIONCLASS_USERDELATTR_FLAG;
    }
  else
    {
      subclass_init_getattr(self, methods);
      subclass_init_setattr(self, methods);
    }

#define subclass_set(OP,N) \
  self-&gt;tp_ ##OP = subclass_ ##OP
  
  subclass_set(compare,cmp);
  subclass_set(repr,repr);

  if (subclass_hasattr(self,py__of__))
    self-&gt;class_flags |= EXTENSIONCLASS_BINDABLE_FLAG;

  if (subclass_hasattr(self,py__call_method__))
    self-&gt;class_flags |= EXTENSIONCLASS_METHODHOOK_FLAG;

  UNLESS(self-&gt;class_flags &amp; EXTENSIONCLASS_NOINSTDICT_FLAG)
    self-&gt;class_flags |= EXTENSIONCLASS_INSTDICT_FLAG;

  if (type-&gt;bases || ! ClassHasInstDict(self))
    copy_member(tp_basicsize);
  else
    {
      self-&gt;tp_basicsize=type-&gt;tp_basicsize/sizeof(PyObject*)*sizeof(PyObject*);
      if (self-&gt;tp_basicsize &lt; type-&gt;tp_basicsize)
	self-&gt;tp_basicsize += sizeof(PyObject*); /* To align on PyObject */
      self-&gt;tp_basicsize += sizeof(PyObject*); /* For instance dictionary */
    }


  self-&gt;tp_as_number=(PyNumberMethods*)malloc(sizeof(PyNumberMethods));
  UNLESS(self-&gt;tp_as_number) return PyErr_NoMemory();
  *(self-&gt;tp_as_number)=subclass_as_number;
    
  self-&gt;tp_as_sequence=
    (PySequenceMethods*)malloc(sizeof(PySequenceMethods));
  UNLESS(self-&gt;tp_as_sequence) return PyErr_NoMemory();
  *(self-&gt;tp_as_sequence)=subclass_as_sequence;
  
  self-&gt;tp_as_mapping=(PyMappingMethods*)malloc(sizeof(PyMappingMethods));
  UNLESS(self-&gt;tp_as_mapping) return PyErr_NoMemory();
  *(self-&gt;tp_as_mapping)=subclass_as_mapping;

  subclass_set(hash,hash);
  subclass_set(call,call);
  subclass_set(str,str);
  self-&gt;tp_doc=0;

  /* Implement __module__=__name__ */
  if (PyDict_GetItem(methods, py__module__) == NULL)
    {
      PyObject *globals = PyEval_GetGlobals();
      if (globals != NULL)
	{
	  PyObject *modname = PyDict_GetItem(globals, py__name__);
	  if (modname != NULL) {
	    if (PyDict_SetItem(methods, py__module__, modname) &lt; 0)
	      return NULL;
	  }
	}
    }

  /* Check for and use __class_init__ */
  if ((class_init=PyObject_GetAttrString(AsPyObject(self),"__class_init__")))
    {
      UNLESS_ASSIGN(class_init,PyObject_GetAttrString(class_init,"im_func"))
        return NULL;
      UNLESS_ASSIGN(class_init,PyObject_CallFunction(class_init,"O",self))
	return NULL;
      Py_DECREF(class_init);
    }
  else
    PyErr_Clear();

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.275">struct PyMethodDef ExtensionClass_methods[] = {
  {"__init__",(PyCFunction)subclass__init__,1,""},
  {NULL,		NULL}		/* sentinel */
};

static PyExtensionClass ECType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "ExtensionClass",		/*tp_name*/
  sizeof(PyExtensionClass),    	/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)CCL_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*tp_getattr*/
  (setattrfunc)0,		/*tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)CCL_repr,		/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  0,				/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)CCL_call,       	/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)CCL_getattro,	/*tp_getattr with object key*/
  (setattrofunc)CCL_setattro,	/*tp_setattr with object key*/
  /* Space for future expansion */
  0L,0L,
  "C classes", /* Documentation string */
  METHOD_CHAIN(ExtensionClass_methods)
};

/* List of methods defined in the module */

static PyObject *
set_subclass_watcher(PyObject *ignored, PyObject *args)
{
  PyObject *old, *sw=0;

  UNLESS(PyArg_ParseTuple(args,"|O",&amp;sw)) return NULL;
  old=subclass_watcher;
  subclass_watcher=sw;
  if (sw) Py_INCREF(sw);
  if (old) return old;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.276">static struct PyMethodDef CC_methods[] = {
  {"subclass_watcher", (PyCFunction)set_subclass_watcher, 1,
   "subclass_watcher(ob) -- "
   "Register an object to watch subclass instance events"
  },
  {NULL,		NULL}		/* sentinel */
};

static int
export_type(PyObject *dict, char *name, PyExtensionClass *typ)
{
  initializeBaseExtensionClass(typ);

  if (PyErr_Occurred()) return -1;

  if (PyDict_GetItem(typ-&gt;class_dictionary, py__module__) == NULL)
    {
      PyObject *modname = PyDict_GetItem(dict, py__name__);
      if (modname != NULL) {
	if (PyDict_SetItem(typ-&gt;class_dictionary, py__module__, modname) &lt; 0)
	  return -1;
      }
    }
  PyErr_Clear();
  
  return PyMapping_SetItemString(dict,name,(PyObject*)typ);
}
</t>
<t tx="ekr.20040104185809.277">static struct ExtensionClassCAPIstruct
TrueExtensionClassCAPI = {
  export_type,			/* Export */
  EC_findiattrs,		/* getattrs */
  EC_findiattro,		/* getattro */
  subclass_simple_setattr,	/* setattrs */
  subclass_simple_setattro,	/* setattro */
  (PyObject*)&amp;ECType,		/* ExtensionClassType */
  (PyObject*)&amp;PMethodType,	/* MethodType */
  PMethod_New,			/* Method_New */
  CMethod_issubclass,		/* issubclass */
};

void
initExtensionClass(void)
{
  PyObject *m, *d, *s;
  PURE_MIXIN_CLASS(Base, "Minimalbase class for Extension Classes", NULL);

  PMethodType.ob_type=&amp;PyType_Type;
  CMethodType.ob_type=&amp;PyType_Type;
  ECTypeType.ob_type=&amp;PyType_Type;
  ECType.ob_type=&amp;ECTypeType;

  UNLESS(concat_fmt=PyString_FromString("%s%s"));
  
  m = Py_InitModule4("ExtensionClass", CC_methods,
		     ExtensionClass_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  d = PyModule_GetDict(m);

  init_py_names();

  if (0) PyCObject_Import14("this will go away", "in 1.5 :-)");

  initializeBaseExtensionClass(&amp;ECType);
  PyDict_SetItemString(d, "ExtensionClass", (PyObject*)&amp;ECType);

  initializeBaseExtensionClass(&amp;BaseType);
  PyDict_SetItemString(d, "Base", (PyObject*)&amp;BaseType);

  PyDict_SetItemString(d, "PythonMethodType", (PyObject*)&amp;PMethodType);
  PyDict_SetItemString(d, "ExtensionMethodType", (PyObject*)&amp;CMethodType);

  /* Export C attribute lookup API */
  PyExtensionClassCAPI=&amp;TrueExtensionClassCAPI;
  
  s = PyCObject_FromVoidPtr(PyExtensionClassCAPI, NULL);
  PyDict_SetItemString(d, "CAPI", s);
  Py_XDECREF(s);

  CHECK_FOR_ERRORS("can't initialize module ExtensionClass");
}
</t>
<t tx="ekr.20040104185809.278">@language c

&lt;&lt; c copyright &gt;&gt;

&lt;&lt; MethodObject #includes &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.279">#include "ExtensionClass.h"
</t>
<t tx="ekr.20040104185809.280">static PyObject *
of(PyObject *self, PyObject *args)
{
  PyObject *inst;

  if(PyArg_Parse(args,"O",&amp;inst)) return PyECMethod_New(self,inst);
  else return NULL;
}
</t>
<t tx="ekr.20040104185809.281">struct PyMethodDef Method_methods[] = {
  {"__of__",(PyCFunction)of,0,""},  
  {NULL,		NULL}		/* sentinel */
};

static struct PyMethodDef methods[] = {{NULL,	NULL}};

void
initMethodObject(void)
{
  PyObject *m, *d;
  PURE_MIXIN_CLASS(Method,
	"Base class for objects that want to be treated as methods\n"
	"\n"
	"The method class provides a method, __of__, that\n"
	"binds an object to an instance.  If a method is a subobject\n"
	"of an extension-class instance, the the method will be bound\n"
	"to the instance and when the resulting object is called, it\n"
	"will call the method and pass the instance in addition to\n"
	"other arguments.  It is the responsibility of Method objects\n"
	"to implement (or inherit) a __call__ method.\n",
	Method_methods);

  /* Create the module and add the functions */
  m = Py_InitModule4("MethodObject", methods,
		     "Method-object mix-in class module\n\n"
		     "$Id: MethodObject.c,v 1.8 2002/06/10 22:48:46 jeremy Exp $\n",
		     (PyObject*)NULL,PYTHON_API_VERSION);

  d = PyModule_GetDict(m);
  PyExtensionClass_Export(d,"Method",MethodType);

  /* Check for errors */
  CHECK_FOR_ERRORS("can't initialize module MethodObject");
}
</t>
<t tx="ekr.20040104185809.282">@language c

&lt;&lt; c copyright &gt;&gt;

static char Missing_module_documentation[] = 
""
"\n$Id: Missing.c,v 1.13.10.4 2003/05/09 21:58:15 jeremy Exp $"
;

&lt;&lt; Missing #includes &gt;&gt;
&lt;&lt; Missing declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.283">#include "ExtensionClass.h"
</t>
<t tx="ekr.20040104185809.284">/* Declarations for objects of type Missing */

typedef struct {
  PyObject_HEAD
} Missing;

static PyObject *vname=0, *Missing_dot_Value=0, *empty_string=0, *reduce=0;
static PyObject *theValue, *notMissing;
</t>
<t tx="ekr.20040104185809.285">static void
Missing_dealloc(Missing *self)
{
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.286">static PyObject *
Missing_repr(Missing *self)
{
  Py_INCREF(Missing_dot_Value);
  return Missing_dot_Value;
}
</t>
<t tx="ekr.20040104185809.287">static PyObject *
Missing_str(Missing *self)
{
  Py_INCREF(empty_string);
  return empty_string;
}
</t>
<t tx="ekr.20040104185809.288">@ Code to access Missing objects as numbers.   We must guarantee that notMissing is never returned to Python code,  because it would violate the guarantee that all Python-accessible  Missing values are equal to each other.
@c

static PyObject *
Missing_bin(PyObject *v, PyObject *w)
{
    if (v == notMissing)
	v = w;
    assert(v != notMissing);
    Py_INCREF(v);
    return v;
}
</t>
<t tx="ekr.20040104185809.289">static PyObject *
Missing_pow(PyObject *v, PyObject *w, PyObject *z)
{
    if (v == notMissing)
	v = w;
    assert(v != notMissing);
    Py_INCREF(v);
    return v;
}</t>
<t tx="ekr.20040104185809.290">static PyObject *
Missing_un(PyObject *v)
{
  Py_INCREF(v);
  return v;
}
</t>
<t tx="ekr.20040104185809.291">static int
Missing_nonzero(PyObject *v)
{
  return 0;
}
</t>
<t tx="ekr.20040104185809.292">@ Always return the distinguished notMissing object as the result  of the coercion. The notMissing object does not compare equal  to other Missing objects.
@c

static int
Missing_coerce(PyObject **pv, PyObject **pw)
{
    Py_INCREF(*pv);
    Py_INCREF(notMissing);
    *pw = notMissing;
    return 0;
}
</t>
<t tx="ekr.20040104185809.293">static PyNumberMethods Missing_as_number = {
	(binaryfunc)Missing_bin,	/*nb_add*/
	(binaryfunc)Missing_bin,	/*nb_subtract*/
	(binaryfunc)Missing_bin,	/*nb_multiply*/
	(binaryfunc)Missing_bin,	/*nb_divide*/
	(binaryfunc)Missing_bin,	/*nb_remainder*/
	(binaryfunc)Missing_bin,	/*nb_divmod*/
	(ternaryfunc)Missing_pow,	/*nb_power*/
	(unaryfunc)Missing_un,		/*nb_negative*/
	(unaryfunc)Missing_un,		/*nb_positive*/
	(unaryfunc)Missing_un,		/*nb_absolute*/
	(inquiry)Missing_nonzero,	/*nb_nonzero*/
	(unaryfunc)Missing_un,		/*nb_invert*/
	(binaryfunc)Missing_bin,	/*nb_lshift*/
	(binaryfunc)Missing_bin,	/*nb_rshift*/
	(binaryfunc)Missing_bin,	/*nb_and*/
	(binaryfunc)Missing_bin,	/*nb_xor*/
	(binaryfunc)Missing_bin,	/*nb_or*/
	(coercion)Missing_coerce,	/*nb_coerce*/
	0,		/*nb_int*/
	0,		/*nb_long*/
	0,		/*nb_float*/
	0,		/*nb_oct*/
	0,		/*nb_hex*/
#if PY_MAJOR_VERSION == 2 &amp;&amp; PY_MINOR_VERSION != 1
	0,		/* nb_inplace_add */
	0,		/* nb_inplace_subtract */
	0,		/* nb_inplace_multiply */
	0,		/* nb_inplace_divide */
	0,		/* nb_inplace_remainder */
	0, 		/* nb_inplace_power */
	0,		/* nb_inplace_lshift */
	0,		/* nb_inplace_rshift */
	0,		/* nb_inplace_and */
	0,		/* nb_inplace_xor */
	0,		/* nb_inplace_or */
	Missing_bin, /* nb_floor_divide */
	Missing_bin,	/* nb_true_divide */
	0,		/* nb_inplace_floor_divide */
	0,		/* nb_inplace_true_divide */
#endif
};

/* ------------------------------------------------------- */

static PyObject *
Missing_reduce(PyObject *self, PyObject *args, PyObject *kw)
{
  if(self==theValue)
    {
      Py_INCREF(vname);
      return vname;
    }
  return Py_BuildValue("O()",self-&gt;ob_type);
}
</t>
<t tx="ekr.20040104185809.294">static struct PyMethodDef reduce_ml[] = {  
  {"__reduce__", (PyCFunction)Missing_reduce, 1,
   "Return a missing value reduced to standard python objects"
  }
};

static PyObject *
Missing_getattr(PyObject *self, PyObject *name)
{
  char *c, *legal;

  if(!(c=PyString_AsString(name))) return NULL;

  legal=c;
  if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 
	     *legal) != NULL)
    {
      for (legal++; *legal; legal++)
	if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 
		   *legal) == NULL) 
	  {
	    legal=NULL;
	    break;
	  }
    }
  else legal=NULL;

  if(! legal)
    {
      if(strcmp(c,"__reduce__")==0)
	{
	  if(self==theValue)
	    {
	      Py_INCREF(reduce);
	      return reduce;
	    }
	  return PyCFunction_New(reduce_ml, self);
	}
      PyErr_SetObject(PyExc_AttributeError, name);
      return NULL;
    }

  Py_INCREF(self);
  return self;
}
</t>
<t tx="ekr.20040104185809.295">static PyObject *
Missing_call(PyObject *self, PyObject *args, PyObject *kw)
{
  Py_INCREF(self);
  return self;
}
</t>
<t tx="ekr.20040104185809.296">@ All Missing objects are equal to each other, except for the  special notMissing object. It is returned by coerce to   indicate that Missing is being compare to something else.
@c

static int
Missing_cmp(PyObject *m1, PyObject *m2)
{
    if (m1 == notMissing)
	return -1;
    return (m2 == notMissing);
}
</t>
<t tx="ekr.20040104185809.297">static PyExtensionClass MissingType = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  "Missing",				/*tp_name*/
  sizeof(Missing),			/*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor)Missing_dealloc,		/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  (getattrfunc)0,			/*obsolete tp_getattr*/
  (setattrfunc)0,			/*obsolete tp_setattr*/
  Missing_cmp,				/*tp_compare*/
  (reprfunc)Missing_repr,		/*tp_repr*/
  &amp;Missing_as_number,			/*tp_as_number*/
  0,					/*tp_as_sequence*/
  0,					/*tp_as_mapping*/
  (hashfunc)0,				/*tp_hash*/
  (ternaryfunc)Missing_call,		/*tp_call*/
  (reprfunc)Missing_str,		/*tp_str*/
  (getattrofunc)Missing_getattr,	/*tp_getattro*/
  (setattrofunc)0,			/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Represent totally unknown quantities\n"
  "\n"
  "Missing values are used to represent numeric quantities that are\n"
  "unknown.  They support all mathematical operations except\n"
  "conversions by returning themselves.\n",
  METHOD_CHAIN(NULL)
};

/* End of code for Missing objects */
/* -------------------------------------------------------- */


/* List of methods defined in the module */

static struct PyMethodDef Module_Level__methods[] = {  
  {NULL, (PyCFunction)NULL, 0, NULL}		/* sentinel */
};

void
initMissing(void)
{
  PyObject *m, *d;

  if(! ((vname=PyString_FromString("V"))
	&amp;&amp; (Missing_dot_Value=PyString_FromString("Missing.Value"))
	&amp;&amp; (empty_string=PyString_FromString(""))
	)) return;

  /* Create the module and add the functions */
  m = Py_InitModule4("Missing", Module_Level__methods,
		     Missing_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,"Missing",MissingType);

  theValue = PyObject_CallObject((PyObject*)&amp;MissingType, NULL);
  notMissing = PyObject_CallObject((PyObject*)&amp;MissingType, NULL);
  reduce=PyCFunction_New(reduce_ml, theValue);

  PyDict_SetItemString(d, "Value", theValue);
  PyDict_SetItemString(d, "V", theValue); 
  PyDict_SetItemString(d, "MV", theValue); 
}
</t>
<t tx="ekr.20040104185809.298">@language c

&lt;&lt; c copyright &gt;&gt;

&lt;&lt; MultiMapping #includes &gt;&gt;
&lt;&lt; MultiMapping declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.299">#include "Python.h"
#include "ExtensionClass.h"
</t>
<t tx="ekr.20040104185809.300">#define UNLESS(E) if(!(E))

typedef struct {
  PyObject_HEAD
  PyObject *data;
} MMobject;

staticforward PyExtensionClass MMtype;
</t>
<t tx="ekr.20040104185809.301">static PyObject *
MM_push(MMobject *self, PyObject *args)
{
  PyObject *src;
  UNLESS(PyArg_ParseTuple(args, "O", &amp;src)) return NULL;
  UNLESS(-1 != PyList_Append(self-&gt;data,src)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.302">static PyObject *
MM_pop(MMobject *self, PyObject *args)
{
  int i=1, l;
  PyObject *r;

  if(args) UNLESS(PyArg_ParseTuple(args, "|i", &amp;i)) return NULL;
  if((l=PyList_Size(self-&gt;data)) &lt; 0) return NULL;
  i=l-i;
  UNLESS(r=PySequence_GetItem(self-&gt;data,l-1)) return NULL;
  if(PyList_SetSlice(self-&gt;data,i,l,NULL) &lt; 0) goto err;
  return r;
err:
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.303">static PyObject *
MM__init__(MMobject *self, PyObject *args)
{
  UNLESS(self-&gt;data=PyList_New(0)) return NULL;
  if (args)
    {
      int l, i;

      if ((l=PyTuple_Size(args)) &lt; 0) return NULL;
      for (i=0; i &lt; l; i++) 
	if (PyList_Append(self-&gt;data, PyTuple_GET_ITEM(args, i)) &lt; 0)
	  return NULL;
    }
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.304">static PyObject *
MM_subscript(MMobject *self, PyObject *key)
{
  long i;
  PyObject *e;

  UNLESS(-1 != (i=PyList_Size(self-&gt;data))) return NULL;
  while(--i &gt;= 0)
    {
      e=PyList_GetItem(self-&gt;data,i);
      if((e=PyObject_GetItem(e,key))) return e;
      PyErr_Clear();
    }
  PyErr_SetObject(PyExc_KeyError,key);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.305">static PyObject *
MM_has_key(MMobject *self, PyObject *args)
{
  PyObject *key;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  if((key=MM_subscript(self, key)))
    {
      Py_DECREF(key);
      return PyInt_FromLong(1);
    }
  PyErr_Clear();
  return PyInt_FromLong(0);
}
</t>
<t tx="ekr.20040104185809.306">static PyObject *
MM_get(MMobject *self, PyObject *args)
{
  PyObject *key, *d=Py_None;

  UNLESS(PyArg_ParseTuple(args,"O|O",&amp;key,&amp;d)) return NULL;
  if((key=MM_subscript(self, key))) return key;
  PyErr_Clear();
  Py_INCREF(d);
  return d;
}
</t>
<t tx="ekr.20040104185809.307">static struct PyMethodDef MM_methods[] = {
  {"__init__", (PyCFunction)MM__init__, METH_VARARGS,
   "__init__([m1, m2, ...]) -- Create a new empty multi-mapping"},
  {"get",  (PyCFunction) MM_get,  METH_VARARGS,
   "get(key,[default]) -- Return a value for the given key or a default"}, 
  {"has_key",  (PyCFunction) MM_has_key,  METH_VARARGS,
   "has_key(key) -- Return 1 if the mapping has the key, and 0 otherwise"}, 
  {"push", (PyCFunction) MM_push, METH_VARARGS,
   "push(mapping_object) -- Add a data source"},
  {"pop",  (PyCFunction) MM_pop,  METH_VARARGS,
   "pop([n]) -- Remove and return the last data source added"}, 
  {NULL,		NULL}		/* sentinel */
};

static void
MM_dealloc(MMobject *self)
{
  Py_XDECREF(self-&gt;data);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.308">static PyObject *
MM_getattr(MMobject *self, char *name)
{
  return Py_FindMethod(MM_methods, (PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185809.309">static int
MM_length(MMobject *self)
{
  long l=0, el, i;
  PyObject *e=0;

  UNLESS(-1 != (i=PyList_Size(self-&gt;data))) return -1;
  while(--i &gt;= 0)
    {
      e=PyList_GetItem(self-&gt;data,i);
      UNLESS(-1 != (el=PyObject_Length(e))) return -1;
      l+=el;
    }
  return l;
}
</t>
<t tx="ekr.20040104185809.310">static PyMappingMethods MM_as_mapping = {
	(inquiry)MM_length,		/*mp_length*/
	(binaryfunc)MM_subscript,      	/*mp_subscript*/
	(objobjargproc)NULL,		/*mp_ass_subscript*/
};

/* -------------------------------------------------------- */

static char MMtype__doc__[] = 
"MultiMapping -- Combine multiple mapping objects for lookup"
;

static PyExtensionClass MMtype = {
	PyObject_HEAD_INIT(NULL)
	0,				/*ob_size*/
	"MultiMapping",			/*tp_name*/
	sizeof(MMobject),		/*tp_basicsize*/
	0,				/*tp_itemsize*/
	/* methods */
	(destructor)MM_dealloc,		/*tp_dealloc*/
	(printfunc)0,			/*tp_print*/
	(getattrfunc)MM_getattr,	/*tp_getattr*/
	(setattrfunc)0,			/*tp_setattr*/
	(cmpfunc)0,			/*tp_compare*/
	(reprfunc)0,			/*tp_repr*/
	0,				/*tp_as_number*/
	0,				/*tp_as_sequence*/
	&amp;MM_as_mapping,			/*tp_as_mapping*/
	(hashfunc)0,			/*tp_hash*/
	(ternaryfunc)0,			/*tp_call*/
	(reprfunc)0,			/*tp_str*/

	/* Space for future expansion */
	0L,0L,0L,0L,
	MMtype__doc__, /* Documentation string */
	METHOD_CHAIN(MM_methods)
};

static struct PyMethodDef MultiMapping_methods[] = {
  {NULL,		NULL}		/* sentinel */
};

void
initMultiMapping(void)
{
  PyObject *m, *d;

  m = Py_InitModule4(
      "MultiMapping", MultiMapping_methods,
      "MultiMapping -- Wrap multiple mapping objects for lookup"
      "\n\n"
      "$Id: MultiMapping.c,v 1.11 2002/06/10 22:48:46 jeremy Exp $\n",
      (PyObject*)NULL,PYTHON_API_VERSION);
  d = PyModule_GetDict(m);
  PyExtensionClass_Export(d,"MultiMapping",MMtype);

  if (PyErr_Occurred()) Py_FatalError("can't initialize module MultiMapping");
}
</t>
<t tx="ekr.20040104185809.311">@language c

&lt;&lt; c copyright &gt;&gt;

static char Record_module_documentation[] = 
""
"\n$Id: Record.c,v 1.17 2002/06/10 22:48:46 jeremy Exp $"
;

&lt;&lt; Record #includes &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.312">#ifdef PERSISTENCE
#include "cPersistence.h"
#else
#include "ExtensionClass.h"
#endif
</t>
<t tx="ekr.20040104185809.313">/* ----------------------------------------------------- */

static void PyVar_Assign(PyObject **v, PyObject *e) { Py_XDECREF(*v); *v=e;}
</t>
<t tx="ekr.20040104185809.314">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if(!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define OBJECT(O) ((PyObject*)(O))

static PyObject *py___record_schema__;

/* Declarations for objects of type Record */

typedef struct {
#ifdef PERSISTENCE
  cPersistent_HEAD
#else
  PyObject_HEAD
#endif
  PyObject **data;
  PyObject *schema;
} Record;

staticforward PyExtensionClass RecordType;

/* ---------------------------------------------------------------- */

static int
Record_init(Record *self)
{
  int l;

  UNLESS(self-&gt;schema)
    UNLESS(self-&gt;schema=PyObject_GetAttr(OBJECT(self-&gt;ob_type),
					 py___record_schema__)) return -1;
  if((l=PyObject_Length(self-&gt;schema)) &lt; 0) return -1;
  UNLESS(self-&gt;data) 
    {
      UNLESS(self-&gt;data=malloc(sizeof(PyObject*)*(l+1)))
	{
	  PyErr_NoMemory();
	  return -1;
	}
      memset(self-&gt;data, 0, sizeof(PyObject*)*(l+1));
    }
  
  return l;
}</t>
<t tx="ekr.20040104185809.315">static PyObject *
Record___setstate__(Record *self, PyObject *args)
{
  PyObject *state=0, *parent, **d;
  int l, ls, i;

  if((l=Record_init(self)) &lt; 0) return NULL;

  UNLESS(PyArg_ParseTuple(args, "|OO", &amp;state, &amp;parent)) return NULL;

  if(state) {
    if(PyDict_Check(state))
      {
	PyObject *k, *v;
	
	for(i=0; PyDict_Next(state, &amp;i, &amp;k, &amp;v);)
	  if(k &amp;&amp; v &amp;&amp; PyObject_SetAttr(OBJECT(self),k,v) &lt; 0)
	    PyErr_Clear();
      }
    else
      {
	if((ls=PyObject_Length(state)) &lt; 0) return NULL;
	
	for(i=0, d=self-&gt;data; i &lt; l &amp;&amp; i &lt; ls; i++, d++)
	  {
	    ASSIGN(*d, PySequence_GetItem(state, i));
	    UNLESS(*d) return NULL;
	  }
      }
  }

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.316">static PyObject *
Record___getstate__( Record *self, PyObject *args)
{
  PyObject *r, **d, *v;
  int i, l;

  UNLESS(self-&gt;data) return PyTuple_New(0);

  if((l=Record_init(self)) &lt; 0) return NULL;
  UNLESS(r=PyTuple_New(l)) return NULL;
  for(d=self-&gt;data, i=0; i &lt; l; i++, d++)
    {
      v= *d;
      if(!v) v=Py_None;
      Py_INCREF(v);
      PyTuple_SET_ITEM(r,i,v);
    }
  return r;
}
</t>
<t tx="ekr.20040104185809.317">static void
Record_deal(Record *self)
{
  int l;
  PyObject **d;

  if(self-&gt;schema)
    {
      l=PyObject_Length(self-&gt;schema);
      for(d=self-&gt;data; --l &gt;= 0; d++)
	{
	  Py_XDECREF(*d);
	}
      Py_DECREF(self-&gt;schema);
      free(self-&gt;data);
    }
}
</t>
<t tx="ekr.20040104185809.318">#ifdef PERSISTENCE
static PyObject *
Record__p_deactivate(Record *self, PyObject *args)
{
  Record_deal(self);
  self-&gt;schema=NULL;
  self-&gt;data=NULL;
  PER_GHOSTIFY(self);
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.319">#endif

static struct PyMethodDef Record_methods[] = {
  {"__getstate__",	(PyCFunction)Record___getstate__,	METH_VARARGS,
   "__getstate__() -- Get the record's data"
  },
  {"__setstate__",	(PyCFunction)Record___setstate__,	METH_VARARGS,
   "__setstate__(v) -- Set the record's data"
  },
  {"__init__",	(PyCFunction)Record___setstate__,	METH_VARARGS,
   "__init__([v]) -- Initialize a record, possibly with state"
  },
#ifdef PERSISTENCE
  {"_p_deactivate",	(PyCFunction)Record__p_deactivate,	METH_VARARGS,
   "_p_deactivate() -- Reset the record's data"
  },
#endif
  {NULL,		NULL}		/* sentinel */
};

/* ---------- */

static void
Record_dealloc(Record *self)
{
  Record_deal(self);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.320">static PyObject *
Record_getattr(Record *self, PyObject *name)
{
  int l, i;
  PyObject *io;

  if((l=Record_init(self)) &lt; 0) return NULL;

  if ((io=Py_FindAttr((PyObject *)self, name))) return io;

  PyErr_Clear();

  if((io=PyObject_GetItem(self-&gt;schema, name)))
    {
      UNLESS(PyInt_Check(io))
	{
	  PyErr_SetString(PyExc_TypeError, "invalid record schema");
	  return NULL;
	}
      i=PyInt_AsLong(io);
      if(i &gt;= 0 &amp;&amp; i &lt; l)
	{
	  ASSIGN(io, self-&gt;data[i]);
	  UNLESS(io) io=Py_None;
	}
      else ASSIGN(io, Py_None);
      Py_INCREF(io);
      return io;
    }

  PyErr_SetObject(PyExc_AttributeError, name);  
  
  return NULL;
}
</t>
<t tx="ekr.20040104185809.321">static int
Record_setattr(Record *self, PyObject *name, PyObject *v)
{
  int l, i;
  PyObject *io;

  if((l=Record_init(self)) &lt; 0) return -1;
  if((io=PyObject_GetItem(self-&gt;schema, name)))
    {
      UNLESS(PyInt_Check(io))
	{
	  PyErr_SetString(PyExc_TypeError, "invalid record schema");
	  return -1;
	}
      i=PyInt_AsLong(io);
      Py_DECREF(io);
      if(i &gt;= 0 &amp;&amp; i &lt; l)
	{
	  Py_XINCREF(v);
	  ASSIGN(self-&gt;data[i],v);
	  return 0;
	}
    }

  PyErr_SetObject(PyExc_AttributeError, name);
  return -1;
}
</t>
<t tx="ekr.20040104185809.322">#ifdef PERSISTENCE
static PyObject *
pRecord_getattr(Record *self, PyObject *name)
{
  char *c;
  UNLESS(c=PyString_AsString(name)) return NULL;
  return cPersistenceCAPI-&gt;pergetattro(OBJECT(self),name,c,
				       Record_getattr);
}
</t>
<t tx="ekr.20040104185809.323">static int
pRecord_setattr(Record *self, PyObject *name, PyObject *v)
{
  return cPersistenceCAPI-&gt;persetattro(OBJECT(self),name,v,Record_setattr);
}
</t>
<t tx="ekr.20040104185809.324">#endif


static int
Record_compare(Record *v, Record *w)
{
  int lv, lw, i, c;
  PyObject **dv, **dw;

  if((lv=Record_init(v)) &lt; 0) return -1;
  if((lw=Record_init(w)) &lt; 0) return -1;
  if(lw &lt; lv) lv=lw;

  for(i=0, dv=v-&gt;data, dw=w-&gt;data; i &lt; lv; i++, dv++, dw++)
    {
      if(*dv)
	if(*dw)
	  {
	    if((c=PyObject_Compare(*dv,*dw))) return c;
	  }
	else return 1;
      else if(*dw) return -1;
    }
  if(*dv) return 1;
  if(*dw) return -1;
  return 0;
}
</t>
<t tx="ekr.20040104185809.325">@ Code to handle accessing Record objects as sequence objects
@c

static PyObject * 
Record_concat(Record *self, PyObject *bb)
{
  PyErr_SetString(PyExc_TypeError,
		  "Record objects do not support concatenation");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.326">static PyObject *
Record_repeat(Record *self, int n)
{
  PyErr_SetString(PyExc_TypeError,
		  "Record objects do not support repetition");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.327">static PyObject *
IndexError(int i)
{
  PyObject *v;

  if((v=PyInt_FromLong(i)))
    {
      PyErr_SetObject(PyExc_IndexError, v);
      Py_DECREF(v);
    }

  return NULL;
}
</t>
<t tx="ekr.20040104185809.328">static PyObject *
Record_item(Record *self, int i)
{
  PyObject *o;
  int l;

  if((l=Record_init(self)) &lt; 0) return NULL;
  if(i &lt; 0 || i &gt;= l) return IndexError(i);

  o=self-&gt;data[i];
  UNLESS(o) o=Py_None;

  Py_INCREF(o);
  return o;
}
</t>
<t tx="ekr.20040104185809.329">static PyObject *
Record_slice(Record *self, int ilow, int ihigh)
{
  PyErr_SetString(PyExc_TypeError,
		  "Record objects do not support slicing");
  return NULL;
}
</t>
<t tx="ekr.20040104185809.330">static int
Record_ass_item(Record *self, int i, PyObject *v)
{
  int l;

  if((l=Record_init(self)) &lt; 0) return -1;
  if(i &lt; 0 || i &gt;= l)
    {
      IndexError(i);
      return -1;
    }

  UNLESS(v)
    {
      PyErr_SetString(PyExc_TypeError,"cannot delete record items");
      return -1;
    }

  Py_INCREF(v);
  ASSIGN(self-&gt;data[i], v);
  return 0;
}
</t>
<t tx="ekr.20040104185809.331">static int
Record_ass_slice(Record *self, int ilow, int ihigh, PyObject *v)
{
  PyErr_SetString(PyExc_TypeError,
		  "Record objects do not support slice assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185809.332">static PySequenceMethods Record_as_sequence = {
  (inquiry)Record_init,			/*sq_length*/
  (binaryfunc)Record_concat,		/*sq_concat*/
  (intargfunc)Record_repeat,		/*sq_repeat*/
  (intargfunc)Record_item,		/*sq_item*/
  (intintargfunc)Record_slice,		/*sq_slice*/
  (intobjargproc)Record_ass_item,	/*sq_ass_item*/
  (intintobjargproc)Record_ass_slice,	/*sq_ass_slice*/
};

/* -------------------------------------------------------------- */

static PyObject *
Record_subscript(Record *self, PyObject *key)
{
  int i, l;
  PyObject *io;

  if((l=Record_init(self)) &lt; 0) return NULL;

  if(PyInt_Check(key))
    {
      i=PyInt_AsLong(key);
      if(i&lt;0) i+=l;
      return Record_item(self, i);
    }

  if((io=PyObject_GetItem(self-&gt;schema, key)))
    {
      UNLESS(PyInt_Check(io))
	{
	  PyErr_SetString(PyExc_TypeError, "invalid record schema");
	  return NULL;
	}
      i=PyInt_AsLong(io);
      if(i &gt;= 0 &amp;&amp; i &lt; l)
	{
	  ASSIGN(io, self-&gt;data[i]);
	  UNLESS(io) io=Py_None;
	}
      else ASSIGN(io, Py_None);
      Py_INCREF(io);
      return io;
    }

  PyErr_Clear();
  if ((io=PyObject_GetAttr(OBJECT(self), key))) return io;

  PyErr_SetObject(PyExc_KeyError, key);					   
  return NULL;
}
</t>
<t tx="ekr.20040104185809.333">static int
Record_ass_sub(Record *self, PyObject *key, PyObject *v)
{
  int i, l;
  PyObject *io;

  if((l=Record_init(self)) &lt; 0) return -1;

  if(PyInt_Check(key))
    {
      i=PyInt_AsLong(key);
      if(i&lt;0) i+=l;
      return Record_ass_item(self, i, v);
    }

  if((io=PyObject_GetItem(self-&gt;schema, key)))
    {
      UNLESS(PyInt_Check(io))
	{
	  PyErr_SetString(PyExc_TypeError, "invalid record schema");
	  return -1;
	}
      i=PyInt_AsLong(io);
      Py_DECREF(io);
      if(i &gt;= 0 &amp;&amp; i &lt; l)
	{
	  Py_XINCREF(v);
	  ASSIGN(self-&gt;data[i],v);
	  return 0;
	}
    }

  return -1;
}
</t>
<t tx="ekr.20040104185809.334">static PyMappingMethods Record_as_mapping = {
  (inquiry)Record_init,		/*mp_length*/
  (binaryfunc)Record_subscript,		/*mp_subscript*/
  (objobjargproc)Record_ass_sub,	/*mp_ass_subscript*/
};

/* -------------------------------------------------------- */

static PyExtensionClass RecordType = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  "Record",				/*tp_name*/
  sizeof(Record),			/*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor)Record_dealloc,		/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  (getattrfunc)0,			/*obsolete tp_getattr*/
  (setattrfunc)0,			/*obsolete tp_setattr*/
  (cmpfunc)Record_compare,		/*tp_compare*/
  (reprfunc)0,				/*tp_repr*/
  0,					/*tp_as_number*/
  &amp;Record_as_sequence,					/*tp_as_sequence*/
  &amp;Record_as_mapping,					/*tp_as_mapping*/
  (hashfunc)0,				/*tp_hash*/
  (ternaryfunc)0,			/*tp_call*/
  (reprfunc)0,				/*tp_str*/
#ifdef PERSISTENCE
  (getattrofunc)pRecord_getattr,	/*tp_getattro*/
  (setattrofunc)pRecord_setattr,	/*tp_setattro*/
#else
  (getattrofunc)Record_getattr,			/*tp_getattro*/
  (setattrofunc)Record_setattr,			/*tp_setattro*/
#endif  
  /* Space for future expansion */
  0L,0L,
  "Simple Record Types", 		/* Documentation string */
  METHOD_CHAIN(Record_methods),
  EXTENSIONCLASS_NOINSTDICT_FLAG,
};

/* End of code for Record objects */
/* -------------------------------------------------------- */


/* List of methods defined in the module */

static struct PyMethodDef Module_Level__methods[] = {
  
  {NULL, (PyCFunction)NULL, 0, NULL}		/* sentinel */
};

/* Initialization function for the module (*must* be called initRecord) */

void
initRecord(void)
{
  PyObject *m, *d;

  UNLESS(py___record_schema__=PyString_FromString("__record_schema__")) return;

  UNLESS(ExtensionClassImported) return;

#ifdef PERSISTENCE
  if(cPersistenceCAPI=PyCObject_Import("cPersistence","CAPI"))
    {
      static PyMethodChain m;
      m.methods=RecordType.methods.methods;
      RecordType.methods.methods=cPersistenceCAPI-&gt;methods-&gt;methods;
      RecordType.methods.link=&amp;m;
    }
  else return;
#endif

  /* Create the module and add the functions */
  m = Py_InitModule4("Record", Module_Level__methods,
		     Record_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,"Record",RecordType);

  /* Check for errors */
  if (PyErr_Occurred()) Py_FatalError("can't initialize module Record");
}
</t>
<t tx="ekr.20040104185809.335">@language c

&lt;&lt; c copyright &gt;&gt;

static char Sync_module_documentation[] = 
""
"\n$Id: Sync.c,v 1.5 2002/06/10 22:48:46 jeremy Exp $"
;

#include "ExtensionClass.h"

@others
</t>
<t tx="ekr.20040104185809.337">static void PyVar_Assign(PyObject **v, PyObject *e) { Py_XDECREF(*v); *v=e;}
</t>
<t tx="ekr.20040104185809.338">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if(!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define OBJECT(O) ((PyObject*)(O))

PyObject *lockstr, *aqstr, *restr, *newlock;

static PyObject *
Synchronized___call_method__(PyObject *self, PyObject *args)
{
  PyObject *f, *a, *k=0, *l=0, *aq=0, *t, *v, *tb, *r;
  UNLESS(PyArg_ParseTuple(args, "OO|O", &amp;f, &amp;a, &amp;k)) return NULL;

  UNLESS(l=PyObject_GetAttr(self, lockstr))
    {
      PyErr_Clear();
      UNLESS(l=PyObject_CallObject(newlock, NULL)) return NULL;
      if(PyObject_SetAttr(self, lockstr, l) &lt; 0) goto err;
    }

  UNLESS(aq=PyObject_GetAttr(l, aqstr)) goto err;
  UNLESS_ASSIGN(aq,PyObject_CallObject(aq,NULL)) goto err;

  if(k) r=PyEval_CallObjectWithKeywords(f,a,k);
  else  r=PyObject_CallObject(f,a);

  PyErr_Fetch(&amp;t, &amp;v, &amp;tb);

  ASSIGN(aq,PyObject_GetAttr(l, restr));
  if(aq) ASSIGN(aq,PyObject_CallObject(aq,NULL));

  Py_XDECREF(aq);
  Py_DECREF(l);

  PyErr_Restore(t, v, tb);

  return r;

err:
  Py_DECREF(l);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.339">static struct PyMethodDef Synchronized_methods[] = {
  {"__call_method__", (PyCFunction)Synchronized___call_method__, METH_VARARGS,
   "Call a method by first getting a thread lock"
  },
  {NULL,		NULL}
};

static struct PyMethodDef Module_Level__methods[] = {  
  {NULL, (PyCFunction)NULL, 0, NULL}
};

void
initSync(void)
{
  PyObject *m, *d;
  PURE_MIXIN_CLASS(
       Synchronized,
       "Mix-in class that provides synchonization of method calls\n"
       "\n"
       "Only one thread is allowed to call a synchronized \n"
       "object's methods.\n",
       Synchronized_methods);

  UNLESS((lockstr=PyString_FromString("_sync__lock")) &amp;&amp;
	 (aqstr=PyString_FromString("acquire")) &amp;&amp;
	 (restr=PyString_FromString("release")) &amp;&amp;
	 (newlock=PyImport_ImportModule("ThreadLock"))
	 ) return;

  ASSIGN(newlock, PyObject_GetAttrString(newlock, "allocate_lock"));
  UNLESS(newlock) return;

  m = Py_InitModule4("Sync", Module_Level__methods,
		     Sync_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  d = PyModule_GetDict(m);
  PyExtensionClass_Export(d,"Synchronized",SynchronizedType);

  CHECK_FOR_ERRORS("can't initialize module MethodObject");
}
</t>
<t tx="ekr.20040104185809.340">@language c

&lt;&lt; c copyright &gt;&gt;

static char ThreadLock_module_documentation[] = 
""
"\n$Id: ThreadLock.c,v 1.13 2002/06/10 22:48:46 jeremy Exp $"
;

&lt;&lt; ThreadLock #includes &gt;&gt;
&lt;&lt; ThreadLock declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185809.341">#include "Python.h"

#ifdef WITH_THREAD

#include "listobject.h"

#ifdef PyList_SET_ITEM

#include "pythread.h"
#define get_thread_ident PyThread_get_thread_ident
#define acquire_lock PyThread_acquire_lock
#define release_lock PyThread_release_lock
#define type_lock PyThread_type_lock
#define free_lock PyThread_free_lock
#define allocate_lock PyThread_allocate_lock

#else

#include "thread.h"

#endif

#endif</t>
<t tx="ekr.20040104185809.342">static PyObject *ErrorObject;

/* ----------------------------------------------------- */

#define UNLESS(E) if(!(E))

/* Declarations for objects of type ThreadLock */

typedef struct {
  PyObject_HEAD
  int count;
  long id;
#ifdef WITH_THREAD
  type_lock lock;
#endif
} ThreadLockObject;

staticforward PyTypeObject ThreadLockType;
</t>
<t tx="ekr.20040104185809.343">static int
cacquire(ThreadLockObject *self, int wait)
{
  int acquired = 1;
#ifdef WITH_THREAD
  long id = get_thread_ident();
#else
  long id = 1;
#endif
  if(self-&gt;count &gt;= 0 &amp;&amp; self-&gt;id==id)
    {
      /* Somebody has locked me.  It is either the current thread or
         another thread. */
      /* So this thread has it.  I can't have a race condition, because,
	 if another thread had the lock, then the id would not be this
	 one. */
      self-&gt;count++;
    }
  else
    {
#ifdef WITH_THREAD
      Py_BEGIN_ALLOW_THREADS
      acquired = acquire_lock(self-&gt;lock, wait ? WAIT_LOCK : NOWAIT_LOCK);
      Py_END_ALLOW_THREADS
#endif
      if (acquired)
        {
          self-&gt;count=0;
          self-&gt;id=id;
        }
    }
  return acquired;
}
</t>
<t tx="ekr.20040104185809.344">static PyObject *
acquire(ThreadLockObject *self, PyObject *args)
{
  int wait = -1, acquired;
  if (! PyArg_ParseTuple(args, "|i", &amp;wait)) return NULL;
  acquired=cacquire(self, wait);
  if(acquired &lt; 0) return NULL;
  if (wait &gt;= 0) return PyInt_FromLong(acquired);
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.345">static int
crelease(ThreadLockObject *self)
{
#ifdef WITH_THREAD
  long id = get_thread_ident();
#else
  long id = 1;
#endif

  if(self-&gt;count &gt;= 0 &amp;&amp; self-&gt;id==id)
    {
      /* Somebody has locked me.  It is either the current thread or
         another thread. */
      /* So this thread has it.  I can't have a race condition, because,
	 if another thread had the lock, then the id would not be this
	 one. */
      self-&gt;count--;
#ifdef WITH_THREAD
      if(self-&gt;count &lt; 0) release_lock(self-&gt;lock);
#endif
    }
  else
    {
      PyErr_SetString(ErrorObject, "release unlocked lock");
      return -1;
    }
  return 0;
}
</t>
<t tx="ekr.20040104185809.346">static PyObject *
release(ThreadLockObject *self, PyObject *args)
{
  if (! PyArg_ParseTuple(args, "")) return NULL;
  if(crelease(self) &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185809.347">static PyObject *
call_method(ThreadLockObject *self, PyObject *args)
{
  PyObject *f, *a=0, *k=0;

  UNLESS(PyArg_ParseTuple(args,"OO|O",&amp;f, &amp;a, &amp;k)) return NULL;
  if(cacquire(self, -1) &lt; 0) return NULL;
  f=PyEval_CallObjectWithKeywords(f,a,k);
  if(crelease(self) &lt; 0)
    {
      Py_XDECREF(f);
      f=NULL;
    }
  return f;
}
</t>
<t tx="ekr.20040104185809.348">static struct PyMethodDef ThreadLock_methods[] = {
  {"guarded_apply", (PyCFunction)call_method, 1,
   "guarded_apply(FUNCTION, ARGS[, KEYWORDS]) -- Make a guarded function call\n"
   "\n"
   "Acquire the lock, call the function, and then release the lock.\n"
  },
  {"acquire", (PyCFunction)acquire, 1,
   "acquire([wait]) -- Acquire a lock, taking the thread ID into account"
  },
  {"release", (PyCFunction)release, 1,
   "release() -- Release a lock, taking the thread ID into account"
  },
  {NULL,		NULL}		/* sentinel */
};

static void
ThreadLock_dealloc(ThreadLockObject *self)
{
#ifdef WITH_THREAD
  free_lock(self-&gt;lock);
#endif
  PyObject_DEL(self);
}
</t>
<t tx="ekr.20040104185809.349">static PyObject *
ThreadLock_getattr(ThreadLockObject *self, PyObject *name)
{
  char *cname;

  if((cname=PyString_AsString(name)))
    {
      if(*cname=='c' &amp;&amp; strcmp(cname,"count")==0)
	return PyInt_FromLong(self-&gt;count);
      if(*cname=='i' &amp;&amp; strcmp(cname,"id")==0)
	return PyInt_FromLong(self-&gt;id);
      return Py_FindMethod(ThreadLock_methods, (PyObject *)self, cname);
    }
  PyErr_SetObject(PyExc_AttributeError, name);
  return NULL;
}
</t>
<t tx="ekr.20040104185809.350">static PyTypeObject ThreadLockType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "ThreadLock",			/*tp_name*/
  sizeof(ThreadLockObject),	/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)ThreadLock_dealloc,	/*tp_dealloc*/
  (printfunc)0,	/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,	/*tp_compare*/
  (reprfunc)0,		/*tp_repr*/
  0,		/*tp_as_number*/
  0,		/*tp_as_sequence*/
  0,		/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,	/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  (getattrofunc)ThreadLock_getattr,			/*tp_getattro*/
  0,			/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Thread-based lock objects\n"
  "\n"
  "These lock objects may be allocated multiple times by the same\n"
  "thread, but may only be allocated by one thread at a time.\n"
  "This is useful for locking instances in possibly nested method calls\n"
};

static PyObject *
newThreadLockObject(ThreadLockObject *self, PyObject *args)
{
	
  UNLESS(PyArg_ParseTuple(args,"")) return NULL;
  UNLESS(self = PyObject_NEW(ThreadLockObject, &amp;ThreadLockType)) return NULL;
  self-&gt;count=-1;
#ifdef WITH_THREAD
  self-&gt;lock = allocate_lock();
  if (self-&gt;lock == NULL) {
    PyObject_DEL(self);
    self = NULL;
    PyErr_SetString(ErrorObject, "can't allocate lock");
  }
#endif
  return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.351">static PyObject *
ident(PyObject *self, PyObject *args)
{
#ifdef WITH_THREAD
  return PyInt_FromLong(get_thread_ident());
#else
  return PyInt_FromLong(0);
#endif
}
</t>
<t tx="ekr.20040104185809.352">static struct PyMethodDef Module_methods[] = {
  { "allocate_lock", (PyCFunction)newThreadLockObject, 1,
    "allocate_lock() -- Return a new lock object"
  },
  { "get_ident", (PyCFunction)ident, 1,
    "get_ident() -- Get the id of the current thread"
  },
  {NULL, (PyCFunction)NULL, 0, NULL}		/* sentinel */
};

void
initThreadLock(void)
{
  PyObject *m, *d;

  m = Py_InitModule4("ThreadLock", Module_methods,
		     ThreadLock_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  d = PyModule_GetDict(m);

  ThreadLockType.ob_type=&amp;PyType_Type;
  PyDict_SetItemString(d,"ThreadLockType", (PyObject*)&amp;ThreadLockType);

  ErrorObject = PyString_FromString("ThreadLock.error");
  PyDict_SetItemString(d, "error", ErrorObject);

#ifdef WITH_THREAD
  PyDict_SetItemString(d, "WITH_THREAD", PyInt_FromLong(1));
#else
  PyDict_SetItemString(d, "WITH_THREAD", Py_None);
#endif  
	
  /* Check for errors */
  if (PyErr_Occurred())
    Py_FatalError("can't initialize module ThreadLock");
}
</t>
<t tx="ekr.20040104185809.353">&lt;&lt; copyright &gt;&gt;

# Compatibility module
# $Id: Xaq.py,v 1.3 2002/08/14 21:24:48 mj Exp $

import Acquisition

Acquirer = Acquisition.Explicit
</t>
<t tx="ekr.20040104185809.354"></t>
<t tx="ekr.20040104185809.355">#! /usr/bin/env python

&lt;&lt; copyright &gt;&gt;

import os
import sys
import test.regrtest

ec_tests = ["test_AqAlg", "test_MultiMapping", "test_Sync",
            "test_ThreadLock", "test_acquisition", "test_add",
            "test_binding", "test_explicit_acquisition",
            "test_method_hook"]

ec_testdir = os.path.split(sys.argv[0])[0] or '.'

test.regrtest.STDTESTS = ec_tests
test.regrtest.NOTTESTS = []

test.regrtest.main(testdir=ec_testdir)
</t>
<t tx="ekr.20040104185809.356">&lt;&lt; test_AqAlg declarations &gt;&gt;
@others


if __name__=='__main__':
    main()
</t>
<t tx="ekr.20040104185809.357">&lt;&lt; copyright &gt;&gt;

__doc__='''Examples from the Acquisition Algebra Presentation


$Id: test_AqAlg.py,v 1.5 2002/08/14 21:24:48 mj Exp $'''
__version__='$Revision: 1.5 $'[11:-2]

import Acquisition

import sys

</t>
<t tx="ekr.20040104185809.358">def uid(obj, uids={}):
    uid = uids.get(id(obj))
    if uid is None:
        uid = uids[id(obj)] = len(uids) + 1
    return uid
</t>
<t tx="ekr.20040104185809.359">def pretty(self, indent=0):
    context=getattr(self, 'aq_parent', None)
    if context is None: return self.__name__
    return "\n%s(%s \n%sof %s\n%s)" % (
        '  '*indent,
        pretty(self.aq_self, indent+1),
        '  '*indent,
        pretty(context, indent+1),
        '  '*indent,
        )
</t>
<t tx="ekr.20040104185809.360">class I(Acquisition.Implicit):
	@others

    __repr__=__str__</t>
<t tx="ekr.20040104185809.361">def __init__(self, name):
    self.__name__=name
</t>
<t tx="ekr.20040104185809.362">def __str__(self):
    context=getattr(self, 'aq_parent', None)
    if context is None: return self.__name__
    return "(%s: %s of %s)" % (uid(self), self.aq_self, context)
</t>
<t tx="ekr.20040104185809.363">A=I('A')
print id(A)
print A
A.B=I('B')
A.B.color='red'
A.C=I('C')
A.C.D=I('D')

def show(s, globals=globals()):
    print s, '--&gt;', eval(s, globals)
</t>
<t tx="ekr.20040104185809.364">def main():
    show('A')
    show('Acquisition.aq_chain(A)')
    show('Acquisition.aq_chain(A, 1)')
    show('map(Acquisition.aq_base, Acquisition.aq_chain(A, 1))')
    print

    show('A.C')
    show('Acquisition.aq_chain(A.C)')
    show('Acquisition.aq_chain(A.C, 1)')
    show('map(Acquisition.aq_base, Acquisition.aq_chain(A.C, 1))')
    print

    show('A.C.D')
    show('Acquisition.aq_chain(A.C.D)')
    show('Acquisition.aq_chain(A.C.D, 1)')
    show('map(Acquisition.aq_base, Acquisition.aq_chain(A.C.D, 1))')
    print

    show('A.B.C')
    show('Acquisition.aq_chain(A.B.C)')
    show('Acquisition.aq_chain(A.B.C, 1)')
    show('map(Acquisition.aq_base, Acquisition.aq_chain(A.B.C, 1))')
    print

    show('A.B.C.D')
    show('Acquisition.aq_chain(A.B.C.D)')
    show('Acquisition.aq_chain(A.B.C.D, 1)')
    show('map(Acquisition.aq_base, Acquisition.aq_chain(A.B.C.D, 1))')
    print

    show('A.B.C.D.color')
    show('Acquisition.aq_get(A.B.C.D, "color", None)')
    show('Acquisition.aq_get(A.B.C.D, "color", None, 1)')
</t>
<t tx="ekr.20040104185809.365">from pprint import pprint
from MultiMapping import *

m=MultiMapping()

m.push({'spam':1, 'eggs':2})

print m['spam']
print m['eggs']

m.push({'spam':3})

print m['spam']
print m['eggs']

pprint(m.pop())
pprint(m.pop())

try:
    print m.pop()
    raise "That\'s odd", "This last pop should have failed!"
except: # I should probably raise a specific error in this case.
    pass
</t>
<t tx="ekr.20040104185809.366">&lt;&lt; test_Sync declarations &gt;&gt;
@others

num_threads = 8
for i in range(num_threads):
    thread.start_new_thread(test, ())

while num_threads &gt; 0:
    sleep(1)
</t>
<t tx="ekr.20040104185809.367">&lt;&lt; copyright &gt;&gt;
from Sync import Synchronized
import thread
from random import random
from time import sleep

</t>
<t tx="ekr.20040104185809.368">class P(Synchronized):
	@others
</t>
<t tx="ekr.20040104185809.369">def __init__(self,*args,**kw):
    self.count=0
</t>
<t tx="ekr.20040104185809.370">def inc(self):
    c = self.count
    if random() &gt; 0.7:
        sleep(1)
    self.count = self.count + 1
    return c, self.count
</t>
<t tx="ekr.20040104185809.371">def incn(self,n):
    c = self.count
    for i in range(n):
        self.inc()
    return c, self.count
</t>
<t tx="ekr.20040104185809.372">p = P(1, 2, spam=3)

def test():
    for i in range(8):
        n = 3
        old, new = p.incn(n)
        if old + n != new:
            print 'oops'
        sleep(2)
    thread_finished()
</t>
<t tx="ekr.20040104185809.373">def thread_finished(lock=thread.allocate_lock()):
    global num_threads
    lock.acquire()
    num_threads = num_threads - 1
    lock.release()
</t>
<t tx="ekr.20040104185809.374">&lt;&lt; test_ThreadLock declarations &gt;&gt;
@others

num_threads = 8
for i in range(num_threads):
    thread.start_new_thread(test, ())

while num_threads &gt; 0:
    sleep(1)
</t>
<t tx="ekr.20040104185809.375">&lt;&lt; copyright &gt;&gt;
import ThreadLock, thread
from random import random
from time import sleep

from ExtensionClass import Base

with_lock=1

</t>
<t tx="ekr.20040104185809.376">class P(Base):
	@others
</t>
<t tx="ekr.20040104185809.377">def __oldcall_method__(self,f,a,k={}):
    if with_lock:
        try: lock=self.lock
        except AttributeError: return apply(f,a,k)
    else: return apply(f,a,k)
    try:
        lock.acquire()
        return apply(f,a,k)
    finally:
        lock.release()
</t>
<t tx="ekr.20040104185809.378">__call_method__=apply

def __init__(self,*args,**kw):
    self.count=0
    if with_lock:
        self.lock=lock=ThreadLock.allocate_lock()
        self.__call_method__=lock.guarded_apply
</t>
<t tx="ekr.20040104185809.379">def inc(self):
    c=self.count
    if random() &gt; 0.7:
        sleep(1)
    self.count=self.count+1
    return c,self.count
</t>
<t tx="ekr.20040104185809.380">def incn(self,n):
    c=self.count
    for i in range(n): self.inc()
    return c,self.count
</t>
<t tx="ekr.20040104185809.381">p=P(1,2,spam=3)

def test():

    for i in range(8):
        n = 3
        old, new = p.incn(n)
        if old + n != new:
            print 'oops'
        sleep(3)
    thread_finished()
</t>
<t tx="ekr.20040104185809.382">def thread_finished(lock=thread.allocate_lock()):
    global num_threads
    lock.acquire()
    num_threads = num_threads - 1
    lock.release()
</t>
<t tx="ekr.20040104185809.383">&lt;&lt; test_acquisition declarations &gt;&gt;
@others


assert checkContext(b.c, b)
assert not checkContext(b.c, b.a)

assert b.a.aq_inContextOf(b)
assert b.c.aq_inContextOf(b)
assert b.c.d.aq_inContextOf(b)
assert b.c.d.aq_inContextOf(c)
assert b.c.d.aq_inContextOf(b.c)
assert not b.c.aq_inContextOf(foo)
assert not b.c.aq_inContextOf(b.a)
assert not b.a.aq_inContextOf('somestring')
</t>
<t tx="ekr.20040104185809.384">&lt;&lt; copyright &gt;&gt;
from ExtensionClass import Base
import Acquisition

</t>
<t tx="ekr.20040104185809.385">class B(Base):
	&lt;&lt; class B declarations &gt;&gt;
</t>
<t tx="ekr.20040104185809.386">color='red'

</t>
<t tx="ekr.20040104185809.387">class A(Acquisition.Implicit):
	@others
</t>
<t tx="ekr.20040104185809.388">def hi(self):
    print "%s()" % self.__class__.__name__, self.color
</t>
<t tx="ekr.20040104185809.389">b=B()
b.a=A()
b.a.hi()
b.a.color='green'
b.a.hi()
try:
    A().hi()
    raise 'Program error', 'spam'
except AttributeError: pass

#
#   New test for wrapper comparisons.
#
foo = b.a
bar = b.a
assert( foo == bar )
c = A()
b.c = c
b.c.d = c
assert( b.c.d == c )
assert( b.c.d == b.c )
assert( b.c == c )


def checkContext(self, o):
    # Python equivalent to aq_inContextOf
    from Acquisition import aq_base, aq_parent, aq_inner
    subob = self
    o = aq_base(o)
    while 1:
        if aq_base(subob) is o: return 1
        self = aq_inner(subob)
        if self is None: break
        subob = aq_parent(self)
        if subob is None: break
</t>
<t tx="ekr.20040104185809.390">&lt;&lt; test_add declarations &gt;&gt;
@others


foo()+foo()
</t>
<t tx="ekr.20040104185809.391">&lt;&lt; copyright &gt;&gt;

from ExtensionClass import *

</t>
<t tx="ekr.20040104185809.392">class foo(Base):
	@others
</t>
<t tx="ekr.20040104185809.393">def __add__(self,other): print 'add called'
</t>
<t tx="ekr.20040104185809.394">&lt;&lt; test_binding declarations &gt;&gt;
@others


x=bar()
hi=x.hi
print type(hi)
hi(1,2,3,name='spam')
</t>
<t tx="ekr.20040104185809.395">&lt;&lt; copyright &gt;&gt;
from ExtensionClass import Base
from MethodObject import Method

</t>
<t tx="ekr.20040104185809.396">class foo(Method):
	@others
</t>
<t tx="ekr.20040104185809.397">def __call__(self, ob, *args, **kw):
    print 'called', ob, args, kw
</t>
<t tx="ekr.20040104185809.398">class bar(Base):
	@others
    hi = foo()</t>
<t tx="ekr.20040104185809.399">def __repr__(self):
    return "bar()"
</t>
<t tx="ekr.20040104185809.400">&lt;&lt; test_explicit_acquisition declarations &gt;&gt;
@others

b=B()
b.a=A()
b.a.hi()
b.a.color='green'
b.a.hi()
try:
    A().hi()
    raise 'Program error', 'spam'
except AttributeError: pass
</t>
<t tx="ekr.20040104185809.401">&lt;&lt; copyright &gt;&gt;
from ExtensionClass import Base
import Acquisition

</t>
<t tx="ekr.20040104185809.402">class B(Base):
	&lt;&lt; class B declarations &gt;&gt;
</t>
<t tx="ekr.20040104185809.403">color='red'

</t>
<t tx="ekr.20040104185809.404">class A(Acquisition.Explicit):
	@others
</t>
<t tx="ekr.20040104185809.405">def hi(self):
    print self.__class__.__name__, self.acquire('color')
</t>
<t tx="ekr.20040104185809.406">&lt;&lt; test_method_hook declarations &gt;&gt;
@others

c=C()
c.hi()
c.hi(1,2,3)
c.hi(1,2,spam='eggs')
</t>
<t tx="ekr.20040104185809.407">&lt;&lt; copyright &gt;&gt;
import ExtensionClass

</t>
<t tx="ekr.20040104185809.408">class C(ExtensionClass.Base):
	@others
</t>
<t tx="ekr.20040104185809.409">def __call_method__(self, meth, args, kw={}):
    print 'give us a hook, hook, hook...'
    return apply(meth, args, kw)
</t>
<t tx="ekr.20040104185809.410">def hi(self, *args, **kw):
    print "%s()" % self.__class__.__name__, args, kw
</t>
<t tx="ekr.20040104185809.411"></t>
<t tx="ekr.20040104185809.412">@language c

/*
 * $Id: cPickle.c,v 1.75 2002/08/26 13:40:29 Brian Exp $
 */

&lt;&lt; c copyright &gt;&gt;

static char cPickle_module_documentation[] = 
"C implementation and optimization of the Python pickle module\n"
"\n"
"$Id: cPickle.c,v 1.75 2002/08/26 13:40:29 Brian Exp $\n"
;

&lt;&lt; cPickle #includes &gt;&gt;
&lt;&lt; cPickle declarations &gt;&gt;

@others</t>
<t tx="ekr.20040104185809.413">#include "Python.h"
#include "cStringIO.h"
#include "mymath.h"

#ifndef Py_eval_input
#include &lt;graminit.h&gt;
#define Py_eval_input eval_input
#endif /* Py_eval_input */

#include &lt;errno.h&gt;</t>
<t tx="ekr.20040104185809.414">#define UNLESS(E) if (!(E))

#define DEL_LIST_SLICE(list, from, to) (PyList_SetSlice(list, from, to, NULL))

#define WRITE_BUF_SIZE 256

/* --------------------------------------------------------------------------
NOTES on format codes.
XXX much more is needed here

Integer types
BININT1         8-bit unsigned integer; followed by 1 byte.
BININT2         16-bit unsigned integer; followed by 2 bytes, little-endian.
BININT          32-bit signed integer; followed by 4 bytes, little-endian.
INT             Integer; natural decimal string conversion, then newline.
                CAUTION:  INT-reading code can't assume that what follows
                fits in a Python int, because the size of Python ints varies
                across platforms.
LONG            Long (unbounded) integer; repr(i), then newline.
-------------------------------------------------------------------------- */

#define MARK        '('
#define STOP        '.'
#define POP         '0'
#define POP_MARK    '1'
#define DUP         '2'
#define FLOAT       'F'
#define BINFLOAT    'G'
#define INT         'I'
#define BININT      'J'
#define BININT1     'K'
#define LONG        'L'
#define BININT2     'M'
#define NONE        'N'
#define PERSID      'P'
#define BINPERSID   'Q'
#define REDUCE      'R'
#define STRING      'S'
#define BINSTRING   'T'
#define SHORT_BINSTRING 'U'
#define APPEND      'a'
#define BUILD       'b'
#define GLOBAL      'c'
#define DICT        'd'
#define EMPTY_DICT  '}'
#define APPENDS     'e'
#define GET         'g'
#define BINGET      'h'
#define INST        'i'
#define LONG_BINGET 'j'
#define LIST        'l'
#define EMPTY_LIST  ']'
#define OBJ         'o'
#define PUT         'p'
#define BINPUT      'q'
#define LONG_BINPUT 'r'
#define SETITEM     's'
#define TUPLE       't'
#define EMPTY_TUPLE ')'
#define SETITEMS    'u'

static char MARKv = MARK;

/* atol function from string module */
static PyObject *atol_func;

static PyObject *PickleError;
static PyObject *PicklingError;
static PyObject *UnpickleableError;
static PyObject *UnpicklingError;
static PyObject *BadPickleGet;


static PyObject *dispatch_table;
static PyObject *safe_constructors;
static PyObject *empty_tuple;

static PyObject *__class___str, *__getinitargs___str, *__dict___str,
  *__getstate___str, *__setstate___str, *__name___str, *__reduce___str,
  *write_str, *__safe_for_unpickling___str, *append_str,
  *read_str, *readline_str, *__main___str, *__basicnew___str,
  *copy_reg_str, *dispatch_table_str, *safe_constructors_str, *empty_str;

static int save();
static int put2();

#ifndef PyList_SET_ITEM
#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))
#endif
#ifndef PyList_GET_SIZE
#define PyList_GET_SIZE(op)    (((PyListObject *)(op))-&gt;ob_size)
#endif
#ifndef PyTuple_SET_ITEM
#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = (v))
#endif
#ifndef PyTuple_GET_SIZE
#define PyTuple_GET_SIZE(op)    (((PyTupleObject *)(op))-&gt;ob_size)
#endif
#ifndef PyString_GET_SIZE
#define PyString_GET_SIZE(op)    (((PyStringObject *)(op))-&gt;ob_size)
#endif

/*************************************************************************
 Internal Data type for pickle data.                                     */

typedef struct {
     PyObject_HEAD
     int length, size;
     PyObject **data;
} Pdata;
</t>
<t tx="ekr.20040104185809.415">static void 
Pdata_dealloc(Pdata *self) {
    int i;
    PyObject **p;

    for (i=self-&gt;length, p=self-&gt;data; --i &gt;= 0; p++) Py_DECREF(*p);

    if (self-&gt;data) free(self-&gt;data);

    PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.416">static PyTypeObject PdataType = {
    PyObject_HEAD_INIT(NULL) 0, "Pdata", sizeof(Pdata), 0,
    (destructor)Pdata_dealloc,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0L,0L,0L,0L, ""
};

#define Pdata_Check(O) ((O)-&gt;ob_type == &amp;PdataType)

static PyObject *
Pdata_New() {
    Pdata *self;

    UNLESS (self = PyObject_NEW(Pdata, &amp;PdataType)) return NULL;
    self-&gt;size=8;
    self-&gt;length=0;
    self-&gt;data=malloc(self-&gt;size * sizeof(PyObject*));
    if (self-&gt;data) return (PyObject*)self;
    Py_DECREF(self);
    return PyErr_NoMemory();
}
</t>
<t tx="ekr.20040104185809.417">static int 
stackUnderflow() {
    PyErr_SetString(UnpicklingError, "unpickling stack underflow");
    return -1;
}
</t>
<t tx="ekr.20040104185809.418">static int
Pdata_clear(Pdata *self, int clearto) {
    int i;
    PyObject **p;

    if (clearto &lt; 0) return stackUnderflow();
    if (clearto &gt;= self-&gt;length) return 0;

    for (i=self-&gt;length, p=self-&gt;data+clearto; --i &gt;= clearto; p++)
      Py_DECREF(*p);
    self-&gt;length=clearto;

    return 0;
}
</t>
<t tx="ekr.20040104185809.419">static int 
Pdata_grow(Pdata *self) {
  if (! self-&gt;size) {
      PyErr_NoMemory();
      return -1;
  }
  self-&gt;size *= 2;                          
  self-&gt;data = realloc(self-&gt;data, self-&gt;size*sizeof(PyObject*));
  if (! self-&gt;data) {
    self-&gt;size = 0;                       
    PyErr_NoMemory();                              
    return -1;                                     
  }
  return 0;
}</t>
<t tx="ekr.20040104185809.420">#define PDATA_POP(D,V) {                                      \
if ((D)-&gt;length) V=D-&gt;data[--((D)-&gt;length)];              \
else {                                                    \
    PyErr_SetString(UnpicklingError, "bad pickle data");  \
    V=NULL;                                               \
}                                                         \
}


static PyObject *
Pdata_popTuple(Pdata *self, int start) {
PyObject *r;
int i, j, l;

l=self-&gt;length-start;
UNLESS (r=PyTuple_New(l)) return NULL;
for (i=start, j=0 ; j &lt; l; i++, j++)
    PyTuple_SET_ITEM(r, j, self-&gt;data[i]);

self-&gt;length=start;
return r;
}
</t>
<t tx="ekr.20040104185809.421">static PyObject *
Pdata_popList(Pdata *self, int start) {
    PyObject *r;
    int i, j, l;

    l=self-&gt;length-start;
    UNLESS (r=PyList_New(l)) return NULL;
    for (i=start, j=0 ; j &lt; l; i++, j++)
        PyList_SET_ITEM(r, j, self-&gt;data[i]);

    self-&gt;length=start;
    return r;
}
</t>
<t tx="ekr.20040104185809.422">#define PDATA_APPEND_(D,O,ER) { \
if (Pdata_Append(((Pdata*)(D)), O) &lt; 0) return ER; \
}

#define PDATA_APPEND(D,O,ER) {                                 \
  if (((Pdata*)(D))-&gt;length == ((Pdata*)(D))-&gt;size &amp;&amp;        \
      Pdata_grow((Pdata*)(D)) &lt; 0)                           \
      return ER;                                             \
  Py_INCREF(O);                                              \
  ((Pdata*)(D))-&gt;data[((Pdata*)(D))-&gt;length++]=O;            \
}

#define PDATA_PUSH(D,O,ER) {                                   \
  if (((Pdata*)(D))-&gt;length == ((Pdata*)(D))-&gt;size &amp;&amp;        \
      Pdata_grow((Pdata*)(D)) &lt; 0) {                         \
      Py_DECREF(O);                                          \
      return ER;                                             \
  }                                                          \
  ((Pdata*)(D))-&gt;data[((Pdata*)(D))-&gt;length++]=O;            \
}

/*************************************************************************/

#define ARG_TUP(self, o) {                          \
if (self-&gt;arg || (self-&gt;arg=PyTuple_New(1))) {    \
    Py_XDECREF(PyTuple_GET_ITEM(self-&gt;arg,0));    \
    PyTuple_SET_ITEM(self-&gt;arg,0,o);              \
}                                                 \
else {                                            \
    Py_DECREF(o);                                 \
}                                                 \
}

#define FREE_ARG_TUP(self) {                        \
  if (self-&gt;arg-&gt;ob_refcnt &gt; 1) {                 \
    Py_DECREF(self-&gt;arg);                         \
    self-&gt;arg=NULL;                               \
  }                                               \
}

typedef struct {
   PyObject_HEAD
   FILE *fp;
   PyObject *write;
   PyObject *file;
   PyObject *memo;
   PyObject *arg;
   PyObject *pers_func;
   PyObject *inst_pers_func;
   int bin;
   int fast; /* Fast mode doesn't save in memo, don't use if circ ref */
   int (*write_func)();
   char *write_buf;
   int buf_size;
   PyObject *dispatch_table;
} Picklerobject;

staticforward PyTypeObject Picklertype;

typedef struct {
   PyObject_HEAD
   FILE *fp;
   PyObject *file;
   PyObject *readline;
   PyObject *read;
   PyObject *memo;
   PyObject *arg;
   Pdata *stack;
   PyObject *mark;
   PyObject *pers_func;
   PyObject *last_string;
   int *marks;
   int num_marks;
   int marks_size;
   int (*read_func)();
   int (*readline_func)();
   int buf_size;
   char *buf;
   PyObject *safe_constructors;
   PyObject *find_class;
} Unpicklerobject;

staticforward PyTypeObject Unpicklertype;

int 
cPickle_PyMapping_HasKey(PyObject *o, PyObject *key) {
  PyObject *v;

  if ((v = PyObject_GetItem(o,key))) {
      Py_DECREF(v);
      return 1;
  }

  PyErr_Clear();
  return 0;
}
</t>
<t tx="ekr.20040104185809.423">@language c

&lt;&lt; c components copyright &gt;&gt;
&lt;&lt; cStringIO_module_documentation &gt;&gt;
&lt;&lt; cStringIO #includes &gt;&gt;
&lt;&lt; cStringIO declarations &gt;&gt;

@others</t>
<t tx="ekr.20040104185809.424">#include "Python.h"
#include "import.h"
#include "cStringIO.h"
</t>
<t tx="ekr.20040104185809.425">#define UNLESS(E) if (!(E))

/* Declaration for file-like objects that manage data as strings 

   The IOobject type should be though of as a common base type for
   Iobjects, which provide input (read-only) StringIO objects and
   Oobjects, which provide read-write objects.  Most of the methods
   depend only on common data.
*/

typedef struct {
  PyObject_HEAD
  char *buf;
  int pos, string_size;
} IOobject;

#define IOOOBJECT(O) ((IOobject*)(O))

/* Declarations for objects of type StringO */

typedef struct { /* Subtype of IOobject */
  PyObject_HEAD
  char *buf;
  int pos, string_size;

  int buf_size, softspace;
} Oobject;

/* Declarations for objects of type StringI */

typedef struct { /* Subtype of IOobject */
  PyObject_HEAD
  char *buf;
  int pos, string_size;

  PyObject *pbuf;
} Iobject;

/* IOobject (common) methods */

static char IO_flush__doc__[] = "flush(): does nothing.";
</t>
<t tx="ekr.20040104185809.426">static int
IO__opencheck(IOobject *self) {
        UNLESS (self-&gt;buf) {
                PyErr_SetString(PyExc_ValueError,
                                "I/O operation on closed file");
                return 0;
        }
        return 1;
}
</t>
<t tx="ekr.20040104185809.427">static PyObject *
IO_flush(IOobject *self, PyObject *args) {

        UNLESS (IO__opencheck(self)) return NULL;
        UNLESS (PyArg_ParseTuple(args, ":flush")) return NULL;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.428">static char IO_getval__doc__[] = 
   "getvalue([use_pos]) -- Get the string value."
   "\n"
   "If use_pos is specified and is a true value, then the string returned\n"
   "will include only the text up to the current file position.\n"
;

static PyObject *
IO_cgetval(PyObject *self) {
        UNLESS (IO__opencheck(IOOOBJECT(self))) return NULL;
        return PyString_FromStringAndSize(((IOobject*)self)-&gt;buf,
                                          ((IOobject*)self)-&gt;pos);
}
</t>
<t tx="ekr.20040104185809.429">static PyObject *
IO_getval(IOobject *self, PyObject *args) {
        PyObject *use_pos=Py_None;
        int s;

        UNLESS (IO__opencheck(self)) return NULL;
        UNLESS (PyArg_ParseTuple(args,"|O:getval",&amp;use_pos)) return NULL;

        if (PyObject_IsTrue(use_pos)) {
                  s=self-&gt;pos;
                  if (s &gt; self-&gt;string_size) s=self-&gt;string_size;
        }
        else
                  s=self-&gt;string_size;
        return PyString_FromStringAndSize(self-&gt;buf, s);
}
</t>
<t tx="ekr.20040104185809.430">static char IO_isatty__doc__[] = "isatty(): always returns 0";

static PyObject *
IO_isatty(IOobject *self, PyObject *args) {

        UNLESS (PyArg_ParseTuple(args, ":isatty")) return NULL;

        return PyInt_FromLong(0);
}
</t>
<t tx="ekr.20040104185809.431">static char IO_read__doc__[] = 
"read([s]) -- Read s characters, or the rest of the string"
;

static int
IO_cread(PyObject *self, char **output, int  n) {
        int l;

        UNLESS (IO__opencheck(IOOOBJECT(self))) return -1;
        l = ((IOobject*)self)-&gt;string_size - ((IOobject*)self)-&gt;pos;  
        if (n &lt; 0 || n &gt; l) {
                n = l;
                if (n &lt; 0) n=0;
        }

        *output=((IOobject*)self)-&gt;buf + ((IOobject*)self)-&gt;pos;
        ((IOobject*)self)-&gt;pos += n;
        return n;
}
</t>
<t tx="ekr.20040104185809.432">static PyObject *
IO_read(IOobject *self, PyObject *args) {
        int n = -1;
        char *output;

        UNLESS (PyArg_ParseTuple(args, "|i:read", &amp;n)) return NULL;

        if ( (n=IO_cread((PyObject*)self,&amp;output,n)) &lt; 0) return NULL;

        return PyString_FromStringAndSize(output, n);
}
</t>
<t tx="ekr.20040104185809.433">static char IO_readline__doc__[] = 
"readline() -- Read one line"
;

static int
IO_creadline(PyObject *self, char **output) {
        char *n, *s;
        int l;

        UNLESS (IO__opencheck(IOOOBJECT(self))) return -1;

        for (n = ((IOobject*)self)-&gt;buf + ((IOobject*)self)-&gt;pos,
               s = ((IOobject*)self)-&gt;buf + ((IOobject*)self)-&gt;string_size; 
             n &lt; s &amp;&amp; *n != '\n'; n++);
        if (n &lt; s) n++;

        *output=((IOobject*)self)-&gt;buf + ((IOobject*)self)-&gt;pos;
        l = n - ((IOobject*)self)-&gt;buf - ((IOobject*)self)-&gt;pos;
        ((IOobject*)self)-&gt;pos += l;
        return l;
}
</t>
<t tx="ekr.20040104185809.434">static PyObject *
IO_readline(IOobject *self, PyObject *args) {
        int n, m=-1;
        char *output;

        UNLESS (PyArg_ParseTuple(args, "|i:readline", &amp;m)) return NULL;

        if( (n=IO_creadline((PyObject*)self,&amp;output)) &lt; 0) return NULL;
        if (m &gt;= 0 &amp;&amp; m &lt; n) {
                m = n - m;
                n -= m;
                self-&gt;pos -= m;
        }
        return PyString_FromStringAndSize(output, n);
}
</t>
<t tx="ekr.20040104185809.435">static char IO_readlines__doc__[] = 
"readlines() -- Read all lines"
;

static PyObject *
IO_readlines(IOobject *self, PyObject *args) {
	int n;
	char *output;
	PyObject *result, *line;
        int hint = 0, length = 0;
	
        UNLESS (PyArg_ParseTuple(args, "|i:readlines", &amp;hint)) return NULL;

	result = PyList_New(0);
	if (!result)
		return NULL;

	while (1){
		if ( (n = IO_creadline((PyObject*)self,&amp;output)) &lt; 0)
                        goto err;
		if (n == 0)
			break;
		line = PyString_FromStringAndSize (output, n);
		if (!line) 
                        goto err;
		PyList_Append (result, line);
		Py_DECREF (line);
                length += n;
                if (hint &gt; 0 &amp;&amp; length &gt;= hint)
			break;
	}
	return result;
 err:
        Py_DECREF(result);
        return NULL;
}
</t>
<t tx="ekr.20040104185809.436">static char IO_reset__doc__[] = 
"reset() -- Reset the file position to the beginning"
;

static PyObject *
IO_reset(IOobject *self, PyObject *args) {

        UNLESS (IO__opencheck(self)) return NULL;
        UNLESS (PyArg_ParseTuple(args, ":reset")) return NULL;

        self-&gt;pos = 0;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.437">static char IO_tell__doc__[] =
"tell() -- get the current position.";

static PyObject *
IO_tell(IOobject *self, PyObject *args) {

        UNLESS (IO__opencheck(self)) return NULL;
        UNLESS (PyArg_ParseTuple(args, ":tell")) return NULL;

        return PyInt_FromLong(self-&gt;pos);
}
</t>
<t tx="ekr.20040104185809.438">static char IO_truncate__doc__[] = 
"truncate(): truncate the file at the current position.";

static PyObject *
IO_truncate(IOobject *self, PyObject *args) {
        int pos = -1;
	
        UNLESS (IO__opencheck(self)) return NULL;
        UNLESS (PyArg_ParseTuple(args, "|i:truncate", &amp;pos)) return NULL;
        if (pos &lt; 0) pos = self-&gt;pos;

        if (self-&gt;string_size &gt; pos) self-&gt;string_size = pos;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.439">@ Read-write object methods
@c

static char O_seek__doc__[] =
"seek(position)       -- set the current position\n"
"seek(position, mode) -- mode 0: absolute; 1: relative; 2: relative to EOF";

static PyObject *
O_seek(Oobject *self, PyObject *args) {
        int position, mode = 0;

        UNLESS (IO__opencheck(IOOOBJECT(self))) return NULL;
        UNLESS (PyArg_ParseTuple(args, "i|i:seek", &amp;position, &amp;mode)) 
                return NULL;

        if (mode == 2) {
                position += self-&gt;string_size;
        }
        else if (mode == 1) {
                position += self-&gt;pos;
        }

        if (position &gt; self-&gt;buf_size) {
                  self-&gt;buf_size*=2;
                  if (self-&gt;buf_size &lt;= position) self-&gt;buf_size=position+1;
                  UNLESS (self-&gt;buf=(char*)
                          realloc(self-&gt;buf,self-&gt;buf_size*sizeof(char))) {
                      self-&gt;buf_size=self-&gt;pos=0;
                      return PyErr_NoMemory();
                    }
          }
        else if (position &lt; 0) position=0;

        self-&gt;pos=position;

        while (--position &gt;= self-&gt;string_size) self-&gt;buf[position]=0;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.440">static char O_write__doc__[] = 
"write(s) -- Write a string to the file"
"\n\nNote (hack:) writing None resets the buffer"
;


static int
O_cwrite(PyObject *self, char *c, int  l) {
        int newl;

        UNLESS (IO__opencheck(IOOOBJECT(self))) return -1;

        newl=((Oobject*)self)-&gt;pos+l;
        if (newl &gt;= ((Oobject*)self)-&gt;buf_size) {
            ((Oobject*)self)-&gt;buf_size*=2;
            if (((Oobject*)self)-&gt;buf_size &lt;= newl) 
                    ((Oobject*)self)-&gt;buf_size=newl+1;
            UNLESS (((Oobject*)self)-&gt;buf=
                   (char*)realloc(
                        ((Oobject*)self)-&gt;buf,
                        (((Oobject*)self)-&gt;buf_size) *sizeof(char))) {
                    PyErr_SetString(PyExc_MemoryError,"out of memory");
                    ((Oobject*)self)-&gt;buf_size=((Oobject*)self)-&gt;pos=0;
                    return -1;
              }
          }

        memcpy(((Oobject*)((Oobject*)self))-&gt;buf+((Oobject*)self)-&gt;pos,c,l);

        ((Oobject*)self)-&gt;pos += l;

        if (((Oobject*)self)-&gt;string_size &lt; ((Oobject*)self)-&gt;pos) {
            ((Oobject*)self)-&gt;string_size = ((Oobject*)self)-&gt;pos;
          }

        return l;
}
</t>
<t tx="ekr.20040104185809.441">static PyObject *
O_write(Oobject *self, PyObject *args) {
        PyObject *s;
        char *c;
        int l;

        UNLESS (PyArg_ParseTuple(args, "O:write", &amp;s)) return NULL;

        UNLESS (-1 != (l=PyString_Size(s))) return NULL;
        UNLESS (c=PyString_AsString(s)) return NULL;
        if (O_cwrite((PyObject*)self,c,l) &lt; 0) return NULL;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.442">static char O_close__doc__[] = "close(): explicitly release resources held.";

static PyObject *
O_close(Oobject *self, PyObject *args) {

        UNLESS (PyArg_ParseTuple(args, ":close")) return NULL;

        if (self-&gt;buf != NULL) free(self-&gt;buf);
        self-&gt;buf = NULL;

        self-&gt;pos = self-&gt;string_size = self-&gt;buf_size = 0;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.443">static char O_writelines__doc__[] =
"writelines(sequence_of_strings): write each string";
static PyObject *
O_writelines(Oobject *self, PyObject *args) {
        PyObject *tmp = 0;
        static PyObject *string_joinfields = 0;

        UNLESS (PyArg_ParseTuple(args, "O:writelines", &amp;args)) return NULL;

        if (!string_joinfields) {
                UNLESS (tmp = PyImport_ImportModule("string")) return NULL;
                string_joinfields=PyObject_GetAttrString(tmp, "joinfields");
                Py_DECREF(tmp);
                UNLESS (string_joinfields) return NULL;
        }

        if (PyObject_Length(args) &lt; 0) return NULL;

        tmp = PyObject_CallFunction(string_joinfields, "Os", args, "");
        UNLESS (tmp) return NULL;

        args = Py_BuildValue("(O)", tmp);
        Py_DECREF(tmp);
        UNLESS (args) return NULL;

        tmp = O_write(self, args);
        Py_DECREF(args);
        return tmp;
}
</t>
<t tx="ekr.20040104185809.444">static struct PyMethodDef O_methods[] = {
  /* Common methods: */
  {"flush",     (PyCFunction)IO_flush,    METH_VARARGS, IO_flush__doc__},
  {"getvalue",  (PyCFunction)IO_getval,   METH_VARARGS, IO_getval__doc__},
  {"isatty",    (PyCFunction)IO_isatty,   METH_VARARGS, IO_isatty__doc__},
  {"read",	(PyCFunction)IO_read,     METH_VARARGS, IO_read__doc__},
  {"readline",	(PyCFunction)IO_readline, METH_VARARGS, IO_readline__doc__},
  {"readlines",	(PyCFunction)IO_readlines,METH_VARARGS, IO_readlines__doc__},
  {"reset",	(PyCFunction)IO_reset,	  METH_VARARGS, IO_reset__doc__},
  {"tell",      (PyCFunction)IO_tell,     METH_VARARGS, IO_tell__doc__},
  {"truncate",  (PyCFunction)IO_truncate, METH_VARARGS, IO_truncate__doc__},

  /* Read-write StringIO specific  methods: */
  {"close",      (PyCFunction)O_close,      METH_VARARGS, O_close__doc__},
  {"seek",       (PyCFunction)O_seek,       METH_VARARGS, O_seek__doc__},
  {"write",	 (PyCFunction)O_write,      METH_VARARGS, O_write__doc__},
  {"writelines", (PyCFunction)O_writelines, METH_VARARGS, O_writelines__doc__},
  {NULL,	 NULL}		/* sentinel */
};

static void
O_dealloc(Oobject *self) {
  if (self-&gt;buf != NULL)
    free(self-&gt;buf);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.445">static PyObject *
O_getattr(Oobject *self, char *name) {
        if (strcmp(name, "softspace") == 0) {
                return PyInt_FromLong(self-&gt;softspace);
        }
        return Py_FindMethod(O_methods, (PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185809.446">static int
O_setattr(Oobject *self, char *name, PyObject *value) {
	long x;
	if (strcmp(name, "softspace") != 0) {
		PyErr_SetString(PyExc_AttributeError, name);
		return -1;
	}
	x = PyInt_AsLong(value);
	if (x &lt; 0 &amp;&amp; PyErr_Occurred())
		return -1;
	self-&gt;softspace = x;
	return 0;
}
</t>
<t tx="ekr.20040104185809.447">static char Otype__doc__[] = 
"Simple type for output to strings."
;

static PyTypeObject Otype = {
  PyObject_HEAD_INIT(NULL)
  0,	       		/*ob_size*/
  "StringO",     		/*tp_name*/
  sizeof(Oobject),       	/*tp_basicsize*/
  0,	       		/*tp_itemsize*/
  /* methods */
  (destructor)O_dealloc,	/*tp_dealloc*/
  (printfunc)0,		/*tp_print*/
  (getattrfunc)O_getattr,	/*tp_getattr*/
  (setattrfunc)O_setattr,	/*tp_setattr*/
  (cmpfunc)0,		/*tp_compare*/
  (reprfunc)0,		/*tp_repr*/
  0,			/*tp_as_number*/
  0,			/*tp_as_sequence*/
  0,			/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  
  /* Space for future expansion */
  0L,0L,0L,0L,
  Otype__doc__ 		/* Documentation string */
};

static PyObject *
newOobject(int  size) {
        Oobject *self;

        self = PyObject_NEW(Oobject, &amp;Otype);
        if (self == NULL)
                return NULL;
        self-&gt;pos=0;
        self-&gt;string_size = 0;
        self-&gt;softspace = 0;

        UNLESS (self-&gt;buf=malloc(size*sizeof(char))) {
                  PyErr_SetString(PyExc_MemoryError,"out of memory");
                  self-&gt;buf_size = 0;
                  return NULL;
          }

        self-&gt;buf_size=size;
        return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.448">@ End of code for StringO objects
--------------------------------------------------------
@c

static PyObject *
I_close(Iobject *self, PyObject *args) {

        UNLESS (PyArg_ParseTuple(args, ":close")) return NULL;

        Py_XDECREF(self-&gt;pbuf);
        self-&gt;pbuf = NULL;
        self-&gt;buf = NULL;

        self-&gt;pos = self-&gt;string_size = 0;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.449">static PyObject *
I_seek(Iobject *self, PyObject *args) {
        int position, mode = 0;

        UNLESS (IO__opencheck(IOOOBJECT(self))) return NULL;
        UNLESS (PyArg_ParseTuple(args, "i|i:seek", &amp;position, &amp;mode)) 
                return NULL;

        if (mode == 2) position += self-&gt;string_size;
        else if (mode == 1) position += self-&gt;pos;

        if (position &lt; 0) position=0;

        self-&gt;pos=position;

        Py_INCREF(Py_None);
        return Py_None;
}
</t>
<t tx="ekr.20040104185809.450">static struct PyMethodDef I_methods[] = {
  /* Common methods: */
  {"flush",     (PyCFunction)IO_flush,    METH_VARARGS, IO_flush__doc__},
  {"getvalue",  (PyCFunction)IO_getval,   METH_VARARGS, IO_getval__doc__},
  {"isatty",    (PyCFunction)IO_isatty,   METH_VARARGS, IO_isatty__doc__},
  {"read",	(PyCFunction)IO_read,     METH_VARARGS, IO_read__doc__},
  {"readline",	(PyCFunction)IO_readline, METH_VARARGS, IO_readline__doc__},
  {"readlines",	(PyCFunction)IO_readlines,METH_VARARGS, IO_readlines__doc__},
  {"reset",	(PyCFunction)IO_reset,	  METH_VARARGS, IO_reset__doc__},
  {"tell",      (PyCFunction)IO_tell,     METH_VARARGS, IO_tell__doc__},
  {"truncate",  (PyCFunction)IO_truncate, METH_VARARGS, IO_truncate__doc__},

  /* Read-only StringIO specific  methods: */
  {"close",     (PyCFunction)I_close,    METH_VARARGS, O_close__doc__},
  {"seek",      (PyCFunction)I_seek,     METH_VARARGS, O_seek__doc__},  
  {NULL,	NULL}
};

static void
I_dealloc(Iobject *self) {
  Py_XDECREF(self-&gt;pbuf);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185809.451">static PyObject *
I_getattr(Iobject *self, char *name) {
  return Py_FindMethod(I_methods, (PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185809.452">static char Itype__doc__[] = 
"Simple type for treating strings as input file streams"
;

static PyTypeObject Itype = {
  PyObject_HEAD_INIT(NULL)
  0,		       	/*ob_size*/
  "StringI",	       	/*tp_name*/
  sizeof(Iobject),       	/*tp_basicsize*/
  0,		       	/*tp_itemsize*/
  /* methods */
  (destructor)I_dealloc,	/*tp_dealloc*/
  (printfunc)0,		/*tp_print*/
  (getattrfunc)I_getattr,	/*tp_getattr*/
  (setattrfunc)0,		/*tp_setattr*/
  (cmpfunc)0,		/*tp_compare*/
  (reprfunc)0,		/*tp_repr*/
  0,			/*tp_as_number*/
  0,			/*tp_as_sequence*/
  0,			/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  
  /* Space for future expansion */
  0L,0L,0L,0L,
  Itype__doc__ 		/* Documentation string */
};

static PyObject *
newIobject(PyObject *s) {
  Iobject *self;
  char *buf;
  int size;

  if (!PyString_Check(s)) {
      PyErr_Format(PyExc_TypeError, "expected string, %.200s found",
		   s-&gt;ob_type-&gt;tp_name);
      return NULL;
  }
  buf = PyString_AS_STRING(s);
  size = PyString_GET_SIZE(s);
  UNLESS (self = PyObject_NEW(Iobject, &amp;Itype)) return NULL;
  Py_INCREF(s);
  self-&gt;buf=buf;
  self-&gt;string_size=size;
  self-&gt;pbuf=s;
  self-&gt;pos=0;
  
  return (PyObject*)self;
}
</t>
<t tx="ekr.20040104185809.453">@ End of code for StringI objects
--------------------------------------------------------
@c

static char IO_StringIO__doc__[] =
"StringIO([s]) -- Return a StringIO-like stream for reading or writing"
;

static PyObject *
IO_StringIO(PyObject *self, PyObject *args) {
  PyObject *s=0;

  if (!PyArg_ParseTuple(args, "|O:StringIO", &amp;s)) return NULL;

  if (s) return newIobject(s);
  return newOobject(128);
}
</t>
<t tx="ekr.20040104185809.454">@ List of methods defined in the module
@c

static struct PyMethodDef IO_methods[] = {
  {"StringIO",	(PyCFunction)IO_StringIO,	
   METH_VARARGS,	IO_StringIO__doc__},
  {NULL,		NULL}		/* sentinel */
};


/* Initialization function for the module (*must* be called initcStringIO) */

static struct PycStringIO_CAPI CAPI = {
  IO_cread,
  IO_creadline,
  O_cwrite,
  IO_cgetval,
  newOobject,
  newIobject,
  &amp;Itype,
  &amp;Otype,
};

#ifndef DL_EXPORT	/* declarations for DLL import/export */
#define DL_EXPORT(RTYPE) RTYPE
#endif
DL_EXPORT(void)
initcStringIO(void) {
  PyObject *m, *d, *v;


  /* Create the module and add the functions */
  m = Py_InitModule4("cStringIO", IO_methods,
		     cStringIO_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);
  
  /* Export C API */
  Itype.ob_type=&amp;PyType_Type;
  Otype.ob_type=&amp;PyType_Type;
  PyDict_SetItemString(d,"cStringIO_CAPI",
		       v = PyCObject_FromVoidPtr(&amp;CAPI,NULL));
  Py_XDECREF(v);

  /* Export Types */
  PyDict_SetItemString(d,"InputType",  (PyObject*)&amp;Itype);
  PyDict_SetItemString(d,"OutputType", (PyObject*)&amp;Otype);

  /* Maybe make certain warnings go away */
  if (0) PycString_IMPORT;
}
</t>
<t tx="ekr.20040104185809.455"># Helper to provide extensibility for pickle/cPickle.

dispatch_table = {}
safe_constructors = {}

@others

pickle(type(1j), pickle_complex, complex)
</t>
<t tx="ekr.20040104185809.457">def pickle(ob_type, pickle_function, constructor_ob = None):
    dispatch_table[ob_type] = pickle_function

    if constructor_ob is not None:
        constructor(constructor_ob)
</t>
<t tx="ekr.20040104185809.458">def constructor(object):
    safe_constructors[object] = 1
</t>
<t tx="ekr.20040104185809.459"># Example: provide pickling support for complex numbers.

def pickle_complex(c):
    return complex, (c.real, c.imag)
</t>
<t tx="ekr.20040104185809.460"></t>
<t tx="ekr.20040104185809.461">@language c

&lt;&lt; c copyright &gt;&gt;

#include "Python.h"

@others
</t>
<t tx="ekr.20040104185809.463">#if defined(__unix__) || defined(unix)

#include &lt;grp.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static PyObject *
initgroups_initgroups(PyObject *self, PyObject *args)
{
	char *username;
	gid_t gid;

	if (!PyArg_ParseTuple(args, "sl:initgroups", &amp;username, &amp;gid))
		return NULL;

	if (initgroups(username, gid) == -1)
		return PyErr_SetFromErrno(PyExc_OSError);

	Py_INCREF(Py_None);
	return Py_None;
}

static PyMethodDef InitgroupsMethods[] = {
	{"initgroups",	initgroups_initgroups,	METH_VARARGS},
	{NULL,		NULL}
};

#else

/* This module is empty on non-UNIX systems. */

static PyMethodDef InitgroupsMethods[] = {
	{NULL,		NULL}
};

#endif /* defined(__unix__) || defined(unix) */</t>
<t tx="ekr.20040104185809.464">void
initinitgroups(void)
{
	Py_InitModule("initgroups", InitgroupsMethods);
}
</t>
<t tx="ekr.20040104185913"></t>
<t tx="ekr.20040104185913.1">&lt;&lt; copyright &gt;&gt;

"""Global definitions"""

__version__='$Revision: 1.53 $'[11:-2]

# Global constants: __replaceable__ flags:
NOT_REPLACEABLE = 0
REPLACEABLE = 1
UNIQUE = 2

&lt;&lt; global imports &gt;&gt;

VersionNameName='Zope-Version'

data_dir = os.path.join(INSTANCE_HOME, 'var')
opened=[]

# Check,if DEBUG variables are set
DevelopmentMode=None

z1 = os.environ.get('Z_DEBUG_MODE','')
z2 = os.environ.get('BOBO_DEBUG_MODE','')

if z1.lower() in ('yes','y') or z1.isdigit():
    DevelopmentMode=1
elif z2.lower() in ('yes','y') or z2.isdigit():
    DevelopmentMode=1</t>
<t tx="ekr.20040104185913.2">&lt;&lt; copyright &gt;&gt;

"""Image object that is stored in a file"""

__version__='$Revision: 1.13 $'[11:-2]

# Eventually this module will go away!

from App.ImageFile import ImageFile
</t>
<t tx="ekr.20040104185913.3">&lt;&lt; copyright &gt;&gt;

# We've renamed this module to zLOG. This one will dissappear soon.
from zLOG import *
</t>
<t tx="ekr.20040104185913.4">import sys, asyncore, time

_shutdown_phase = 0
_shutdown_timeout = 30 # seconds per phase

@ The shutdown phase counts up from 0 to 4.

0  Not yet terminating. running in main loop

1  Loss of service is imminent. Prepare any front-end proxies for this happening
   by stopping any ICP servers, so that they can choose to send requests to other
   Zope servers in the cluster.
   
2  Stop accepting any new requests.

3  Wait for all old requests to have been processed

4  Already terminated

It is up to individual socket handlers to implement these actions, by providing the
'clean_shutdown_control' method. This is called intermittantly during shutdown with
two parameters; the current phase number, and the amount of time that it has currently
been in that phase. This method should return true if it does not yet want shutdown to
proceed to the next phase.
@c

@others</t>
<t tx="ekr.20040104185913.6">def shutdown(exit_code,fast = 0):
    global _shutdown_phase
    global _shutdown_timeout
    if _shutdown_phase == 0:
        # Thread safety? proably no need to care
        sys.ZServerExitCode = exit_code
        _shutdown_phase = 1
    if fast:
        # Someone wants us to shutdown fast. This is hooked into SIGTERM - so possibly
        # the system is going down and we can expect a SIGKILL within a few seconds.
        # Limit each shutdown phase to one second. This is fast enough, but still clean.
        _shutdown_timeout = 1.0
</t>
<t tx="ekr.20040104185913.7">def loop():
    # Run the main loop until someone calls shutdown()
    lifetime_loop()
    # Gradually close sockets in the right order, while running a select
    # loop to allow remaining requests to trickle away.
    graceful_shutdown_loop()
</t>
<t tx="ekr.20040104185913.8">def lifetime_loop():
    # The main loop. Stay in here until we need to shutdown
    map = asyncore.socket_map
    timeout = 30.0
    while map and _shutdown_phase == 0:
        asyncore.poll(timeout, map)
</t>
<t tx="ekr.20040104185913.9">def graceful_shutdown_loop():
    # The shutdown loop. Allow various services to shutdown gradually.
    global _shutdown_phase
    timestamp = time.time()
    timeout = 1.0
    map = asyncore.socket_map
    while map and _shutdown_phase &lt; 4:
        time_in_this_phase = time.time()-timestamp 
        veto = 0
        for fd,obj in map.items():
            try:
                fn = getattr(obj,'clean_shutdown_control')
            except AttributeError:
                pass
            else:
                try:
                    veto = veto or fn(_shutdown_phase,time_in_this_phase)
                except:
                    obj.handle_error()
        if veto and time_in_this_phase&lt;_shutdown_timeout:
            # Any open socket handler can veto moving on to the next shutdown phase.
            # (but not forever)
            asyncore.poll(timeout, map)
        else:
            # No vetos? That is one step closer to shutting down
            _shutdown_phase += 1
            timestamp = time.time()
    </t>
<t tx="ekr.20040104185913.10">&lt;&lt; copyright &gt;&gt;

"""Provide a Main application for the Zope framework

The Job of this module is to:

 - Configure and open the database

 - Establish the top-level object for ZPublisher

 - Perform very high-level configuration tasks

"""

&lt;&lt; main imports &gt;&gt;

Globals.BobobaseName = os.path.join(Globals.data_dir, 'Data.bbb')
Globals.DatabaseVersion='2'

# Setup support for broken objects:
import OFS.Uninstalled, BoboPOS.PickleJar
BoboPOS.PickleJar.PickleJar.Broken=OFS.Uninstalled.Broken

# Open the application database
OFS.Application.import_products()
revision=read_only=None
if os.environ.has_key('ZOPE_READ_ONLY'):
    read_only=1
    try:
        from DateTime import DateTime
        revision=DateTime(os.environ['ZOPE_READ_ONLY']).timeTime()
    except: pass

Bobobase=Globals.Bobobase=BoboPOS.PickleDictionary(
    Globals.BobobaseName, read_only=read_only, revision=revision)
Globals.opened.append(Bobobase)
VersionBase=Globals.VersionBase=TJar.TM(Bobobase)
Globals.opened.append(VersionBase)

try: app=Bobobase['Application']
except KeyError:
    app=OFS.Application.Application()
    Bobobase['Application']=app
    get_transaction().note('created Application object')
    get_transaction().commit()

bobo_application=app

OFS.Application.initialize(app)

if os.environ.has_key('ZOPE_DATABASE_QUOTA'):
    quota=int(os.environ['ZOPE_DATABASE_QUOTA'])
    Bobobase._jar.db.set_quota(
        lambda x, quota=quota, otherdb=VersionBase.TDB:
        x + otherdb.pos &gt; quota)
    VersionBase.TDB.set_quota(
        lambda x, quota=quota, otherdb=Bobobase._jar.db:
        x + otherdb.pos &gt; quota)

SingleThreadedTransaction.Transaction.commit=VersionBase.committer()

__bobo_debug_mode__=Globals.DevelopmentMode</t>
<t tx="ekr.20040104185913.11">&lt;&lt; copyright &gt;&gt;

def debug():
    x=1</t>
<t tx="ekr.20040104185913.14">&lt;&lt; copyright &gt;&gt;

&lt;&lt; ts_regex imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.15">"""Provide a thread-safe interface to regex
"""
import regex, regsub #, Sync
from regex import *
from regsub import split, sub, gsub, splitx, capwords

try:
    import thread
except:
</t>
<t tx="ekr.20040104185913.16">class allocate_lock:
	@others
</t>
<t tx="ekr.20040104185913.17">def acquire(*args): pass
</t>
<t tx="ekr.20040104185913.18">def release(*args): pass
</t>
<t tx="ekr.20040104185913.19">else:
    class SafeFunction:
	&lt;&lt; class SafeFunction declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.20">_l=thread.allocate_lock()
_a=_l.acquire
_r=_l.release

</t>
<t tx="ekr.20040104185913.21">def __init__(self, f):
    self._f=f
</t>
<t tx="ekr.20040104185913.22">def __call__(self, *args, **kw):
    self._a()
    try: return apply(self._f, args, kw)
    finally: self._r()
</t>
<t tx="ekr.20040104185913.23">split=SafeFunction(split)
sub=SafeFunction(sub)
gsub=SafeFunction(gsub)
splitx=SafeFunction(splitx)
capwords=SafeFunction(capwords)

allocate_lock=thread.allocate_lock

class compile:
	&lt;&lt; class compile declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.24">_r=None
groupindex=None

</t>
<t tx="ekr.20040104185913.25">def __init__(self, *args):
    self._r=r=apply(regex.compile,args)
    self._init(r)
</t>
<t tx="ekr.20040104185913.26">def _init(self, r):
    lock=allocate_lock()
    self.__a=lock.acquire
    self.__r=lock.release
    self.translate=r.translate
    self.givenpat=r.givenpat
    self.realpat=r.realpat
</t>
<t tx="ekr.20040104185913.27">def match(self, string, pos=0):
    self.__a()
    try: return self._r.match(string, pos)
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.28">def search(self, string, pos=0):
    self.__a()
    try: return self._r.search(string, pos)
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.29">def search_group(self, str, group, pos=0):
    """Search a string for a pattern.

    If the pattern was not found, then None is returned,
    otherwise, the location where the pattern was found,
    as well as any specified group are returned.
    """
    self.__a()
    try:
        r=self._r
        l=r.search(str, pos)
        if l &lt; 0: return None
        return l, apply(r.group, group)
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.30">def match_group(self, str, group, pos=0):
    """Match a pattern against a string

    If the string does not match the pattern, then None is
    returned, otherwise, the length of the match, as well
    as any specified group are returned.
    """
    self.__a()
    try:
        r=self._r
        l=r.match(str, pos)
        if l &lt; 0: return None
        return l, apply(r.group, group)
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.31">def search_regs(self, str, pos=0):
    """Search a string for a pattern.

    If the pattern was not found, then None is returned,
    otherwise, the 'regs' attribute of the expression is
    returned.
    """
    self.__a()
    try:
        r=self._r
        r.search(str, pos)
        return r.regs
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.32">def match_regs(self, str, pos=0):
    """Match a pattern against a string

    If the string does not match the pattern, then None is
    returned, otherwise, the 'regs' attribute of the expression is
    returned.
    """
    self.__a()
    try:
        r=self._r
        r.match(str, pos)
        return r.regs
    finally: self.__r()
</t>
<t tx="ekr.20040104185913.33">class symcomp(compile):
	@others
</t>
<t tx="ekr.20040104185913.34">def __init__(self, *args):
    self._r=r=apply(regex.symcomp,args)
    self._init(r)
    self.groupindex=r.groupindex
</t>
<t tx="ekr.20040104185913.35">&lt;&lt; xmlrpclib versions &gt;&gt;
&lt;&lt; xmlrpclib copyright &gt;&gt;
&lt;&lt; xmlrpclib todo &gt;&gt;
&lt;&lt; xmlrpclib docstring &gt;&gt;
&lt;&lt; xmlrpclib imports &gt;&gt;

@others

if __name__ == "__main__":

    # simple test program (from the XML-RPC specification)

    # server = ServerProxy("http://localhost:8000") # local server
    server = ServerProxy("http://betty.userland.com")

    print server

    try:
        print server.examples.getStateName(41)
    except Error, v:
        print "ERROR", v</t>
<t tx="ekr.20040104185913.36">import re, string, time, operator

from types import *

try:
    unicode
except NameError:
    unicode = None # unicode support not available</t>
<t tx="ekr.20040104185913.37">def _decode(data, encoding, is8bit=re.compile("[\x80-\xff]").search):
    # decode non-ascii string (if possible)
    if unicode and encoding and is8bit(data):
        data = unicode(data, encoding)
    return data
</t>
<t tx="ekr.20040104185913.38">def escape(s, replace=string.replace):
    s = replace(s, "&amp;", "&amp;amp;")
    s = replace(s, "&lt;", "&amp;lt;")
    return replace(s, "&gt;", "&amp;gt;",)
</t>
<t tx="ekr.20040104185913.39">MAXINT =  2L**31-1
MININT = -2L**31

if unicode:
    def _stringify(string):
        # convert to 7-bit ascii if possible
        try:
            return str(string)
        except UnicodeError:
            return string
else:
    def _stringify(string):
        return string</t>
<t tx="ekr.20040104185913.41">__version__ = "1.0.0"

# --------------------------------------------------------------------
# Exceptions

class Error(Exception):
    """Base class for client errors."""
	@others
</t>
<t tx="ekr.20040104185913.42">def __str__(self):
    return repr(self)
</t>
<t tx="ekr.20040104185913.43">class ProtocolError(Error):
    """Indicates an HTTP protocol error."""
	@others
</t>
<t tx="ekr.20040104185913.44">def __init__(self, url, errcode, errmsg, headers):
    Error.__init__(self)
    self.url = url
    self.errcode = errcode
    self.errmsg = errmsg
    self.headers = headers
</t>
<t tx="ekr.20040104185913.45">def __repr__(self):
    return (
        "&lt;ProtocolError for %s: %s %s&gt;" %
        (self.url, self.errcode, self.errmsg)
        )
</t>
<t tx="ekr.20040104185913.46">class ResponseError(Error):
    """Indicates a broken response package."""
	&lt;&lt; class ResponseError declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.47">pass

</t>
<t tx="ekr.20040104185913.48">class Fault(Error):
    """Indicates an XML-RPC fault package."""
	@others
</t>
<t tx="ekr.20040104185913.49">def __init__(self, faultCode, faultString, **extra):
    Error.__init__(self)
    self.faultCode = faultCode
    self.faultString = faultString
</t>
<t tx="ekr.20040104185913.50">def __repr__(self):
    return (
        "&lt;Fault %s: %s&gt;" %
        (self.faultCode, repr(self.faultString))
        )
</t>
<t tx="ekr.20040104185913.51">class Boolean:
    """Boolean-value wrapper.

    Use True or False to generate a "boolean" XML-RPC value.
    """
	@others

True, False = Boolean(1), Boolean(0)

def boolean(value, truefalse=(False, True)):
    """Convert any Python value to XML-RPC 'boolean'."""
    return truefalse[operator.truth(value)]
</t>
<t tx="ekr.20040104185913.52">def __init__(self, value = 0):
    self.value = operator.truth(value)
</t>
<t tx="ekr.20040104185913.53">def encode(self, out):
    out.write("&lt;value&gt;&lt;boolean&gt;%d&lt;/boolean&gt;&lt;/value&gt;\n" % self.value)
</t>
<t tx="ekr.20040104185913.54">def __cmp__(self, other):
    if isinstance(other, Boolean):
        other = other.value
    return cmp(self.value, other)
</t>
<t tx="ekr.20040104185913.55">def __repr__(self):
    if self.value:
        return "&lt;Boolean True at %x&gt;" % id(self)
    else:
        return "&lt;Boolean False at %x&gt;" % id(self)
</t>
<t tx="ekr.20040104185913.56">def __int__(self):
    return self.value
</t>
<t tx="ekr.20040104185913.57">def __nonzero__(self):
    return self.value
</t>
<t tx="ekr.20040104185913.59">class DateTime:
    """DateTime wrapper for an ISO 8601 string or time tuple or
    localtime integer value to generate 'dateTime.iso8601' XML-RPC
    value.
    """
	@others

def datetime(data):
    value = DateTime()
    value.decode(data)
    return value
</t>
<t tx="ekr.20040104185913.60">def __init__(self, value=0):
    if not isinstance(value, StringType):
        if not isinstance(value, TupleType):
            if value == 0:
                value = time.time()
            value = time.localtime(value)
        value = time.strftime("%Y%m%dT%H:%M:%S", value)
    self.value = value
</t>
<t tx="ekr.20040104185913.61">def __cmp__(self, other):
    if isinstance(other, DateTime):
        other = other.value
    return cmp(self.value, other)
</t>
<t tx="ekr.20040104185913.62">def __repr__(self):
    return "&lt;DateTime %s at %x&gt;" % (self.value, id(self))
</t>
<t tx="ekr.20040104185913.63">def decode(self, data):
    self.value = string.strip(data)
</t>
<t tx="ekr.20040104185913.64">def encode(self, out):
    out.write("&lt;value&gt;&lt;dateTime.iso8601&gt;")
    out.write(self.value)
    out.write("&lt;/dateTime.iso8601&gt;&lt;/value&gt;\n")
</t>
<t tx="ekr.20040104185913.66">class Binary:
    """Wrapper for binary data."""
	@others

def binary(data):
    value = Binary()
    value.decode(data)
    return value</t>
<t tx="ekr.20040104185913.67">def __init__(self, data=None):
    self.data = data
</t>
<t tx="ekr.20040104185913.68">def __cmp__(self, other):
    if isinstance(other, Binary):
        other = other.data
    return cmp(self.data, other)
</t>
<t tx="ekr.20040104185913.69">def decode(self, data):
    import base64
    self.data = base64.decodestring(data)
</t>
<t tx="ekr.20040104185913.70">def encode(self, out):
    import base64, StringIO
    out.write("&lt;value&gt;&lt;base64&gt;\n")
    base64.encode(StringIO.StringIO(self.data), out)
    out.write("&lt;/base64&gt;&lt;/value&gt;\n")
</t>
<t tx="ekr.20040104185913.72">try:
    # optional xmlrpclib accelerator.  for more information on this
    # component, contact info@pythonware.com
    import _xmlrpclib
    FastParser = _xmlrpclib.Parser
    FastUnmarshaller = _xmlrpclib.Unmarshaller
except (AttributeError, ImportError):
    FastParser = FastUnmarshaller = None

#
# the SGMLOP parser is about 15x faster than Python's builtin
# XML parser.  SGMLOP sources can be downloaded from:
#
#     http://www.pythonware.com/products/xml/sgmlop.htm
#

try:
    import sgmlop
    if not hasattr(sgmlop, "XMLParser"):
        raise ImportError
except ImportError:
    SgmlopParser = None # sgmlop accelerator not available
else:
    class SgmlopParser:
	@others
</t>
<t tx="ekr.20040104185913.73">def __init__(self, target):

    # setup callbacks
    self.finish_starttag = target.start
    self.finish_endtag = target.end
    self.handle_data = target.data
    self.handle_xml = target.xml

    # activate parser
    self.parser = sgmlop.XMLParser()
    self.parser.register(self)
    self.feed = self.parser.feed
    self.entity = {
        "amp": "&amp;", "gt": "&gt;", "lt": "&lt;",
        "apos": "'", "quot": '"'
        }
</t>
<t tx="ekr.20040104185913.74">def close(self):
    try:
        self.parser.close()
    finally:
        self.parser = self.feed = None # nuke circular reference
</t>
<t tx="ekr.20040104185913.75">def handle_proc(self, tag, attr):
    import re
    m = re.search("encoding\s*=\s*['\"]([^\"']+)[\"']", attr)
    if m:
        self.handle_xml(m.group(1), 1)
</t>
<t tx="ekr.20040104185913.76">def handle_entityref(self, entity):
    # &lt;string&gt; entity
    try:
        self.handle_data(self.entity[entity])
    except KeyError:
        self.handle_data("&amp;%s;" % entity)
</t>
<t tx="ekr.20040104185913.77">try:
    from xml.parsers import expat
    if not hasattr(expat, "ParserCreate"):
        raise ImportError, "ParserCreate"
except ImportError:
    ExpatParser = None
else:
    class ExpatParser:
	 	# fast expat parser for Python 2.0.  this is about 50%
        # slower than sgmlop, on roundtrip testing

	@others
</t>
<t tx="ekr.20040104185913.79">def __init__(self, target):
    self._parser = parser = expat.ParserCreate(None, None)
    self._target = target
    parser.StartElementHandler = target.start
    parser.EndElementHandler = target.end
    parser.CharacterDataHandler = target.data
    encoding = None
    if not parser.returns_unicode:
        encoding = "utf-8"
    target.xml(encoding, None)
</t>
<t tx="ekr.20040104185913.80">def feed(self, data):
    self._parser.Parse(data, 0)
</t>
<t tx="ekr.20040104185913.81">def close(self):
    self._parser.Parse("", 1) # end of data
    del self._target, self._parser # get rid of circular references
</t>
<t tx="ekr.20040104185913.82">class SlowParser:

    """Default XML parser (based on xmllib.XMLParser)."""
	# this is about 10 times slower than sgmlop, on roundtrip
    # testing.

	@others</t>
<t tx="ekr.20040104185913.84">def __init__(self, target):
    import xmllib # lazy subclassing (!)
    if xmllib.XMLParser not in SlowParser.__bases__:
        SlowParser.__bases__ = (xmllib.XMLParser,)
    self.handle_xml = target.xml
    self.unknown_starttag = target.start
    self.handle_data = target.data
    self.handle_cdata = target.data
    self.unknown_endtag = target.end
    try:
        xmllib.XMLParser.__init__(self, accept_utf8=1)
    except TypeError:
        xmllib.XMLParser.__init__(self) # pre-2.0
</t>
<t tx="ekr.20040104185913.85">class Marshaller:
    """Generate an XML-RPC params chunk from a Python data structure.

    Create a Marshaller instance for each set of parameters, and use
    the "dumps" method to convert your data (represented as a tuple)
    to an XML-RPC params chunk.  To write a fault response, pass a
    Fault instance instead.  You may prefer to use the "dumps" module
    function for this purpose.
    """
	&lt;&lt; class Marshaller declarations &gt;&gt;
	@others
    dispatch[InstanceType] = dump_instance</t>
<t tx="ekr.20040104185913.86">    # by the way, if you don't understand what's going on in here,
    # that's perfectly ok.

</t>
<t tx="ekr.20040104185913.87">def __init__(self, encoding=None):
    self.memo = {}
    self.data = None
    self.encoding = encoding
</t>
<t tx="ekr.20040104185913.88">dispatch = {}

def dumps(self, values):
    self.__out = []
    self.write = write = self.__out.append
    if isinstance(values, Fault):
        # fault instance
        write("&lt;fault&gt;\n")
        self.__dump(vars(values))
        write("&lt;/fault&gt;\n")
    else:
        # parameter block
        # FIXME: the xml-rpc specification allows us to leave out
        # the entire &lt;params&gt; block if there are no parameters.
        # however, changing this may break older code (including
        # old versions of xmlrpclib.py), so this is better left as
        # is for now.  See @XMLRPC3 for more information. /F
        write("&lt;params&gt;\n")
        for v in values:
            write("&lt;param&gt;\n")
            self.__dump(v)
            write("&lt;/param&gt;\n")
        write("&lt;/params&gt;\n")
    result = string.join(self.__out, "")
    del self.__out, self.write # don't need this any more
    return result
</t>
<t tx="ekr.20040104185913.89">def __dump(self, value):
    try:
        f = self.dispatch[type(value)]
    except KeyError:
        raise TypeError, "cannot marshal %s objects" % type(value)
    else:
        f(self, value)
</t>
<t tx="ekr.20040104185913.90">def dump_int(self, value):
    # in case ints are &gt; 32 bits
    if value &gt; MAXINT or value &lt; MININT:
        raise OverflowError, "int exceeds XML-RPC limits"
    self.write("&lt;value&gt;&lt;int&gt;%s&lt;/int&gt;&lt;/value&gt;\n" % value)
</t>
<t tx="ekr.20040104185913.91">dispatch[IntType] = dump_int

def dump_long(self, value):
    # in case ints are &gt; 32 bits
    if value &gt; MAXINT or value &lt; MININT:
        raise OverflowError, "long int exceeds XML-RPC limits"
    self.write("&lt;value&gt;&lt;int&gt;%s&lt;/int&gt;&lt;/value&gt;\n" % int(value))
</t>
<t tx="ekr.20040104185913.92">dispatch[LongType] = dump_long

def dump_double(self, value):
    self.write("&lt;value&gt;&lt;double&gt;%s&lt;/double&gt;&lt;/value&gt;\n" % repr(value))
</t>
<t tx="ekr.20040104185913.93">dispatch[FloatType] = dump_double

def dump_string(self, value, escape=escape):
    self.write("&lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt;\n" % escape(value))
</t>
<t tx="ekr.20040104185913.94">dispatch[StringType] = dump_string

if unicode:
    def dump_unicode(self, value, escape=escape):
        value = value.encode(self.encoding)
        self.write("&lt;value&gt;&lt;string&gt;%s&lt;/string&gt;&lt;/value&gt;\n" % escape(value))
    dispatch[UnicodeType] = dump_unicode
</t>
<t tx="ekr.20040104185913.95"># Zope-specific extension; xmlrpc doesnt have an equivalent of
# Python's None. the standard xmlrpclib raises an exception,
# but marshalling it as a zero is more convenient.
def dump_none(self, value):
    self.write("&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;\n")
</t>
<t tx="ekr.20040104185913.96">dispatch[NoneType] = dump_none

def opencontainer(self, value):
    if value:
        i = id(value)
        if self.memo.has_key(i):
            raise TypeError, "cannot marshal recursive data structures"
        self.memo[i] = None
</t>
<t tx="ekr.20040104185913.97">def closecontainer(self, value):
    if value:
        del self.memo[id(value)]
</t>
<t tx="ekr.20040104185913.98">def dump_array(self, value):
    self.opencontainer(value)
    write = self.write
    dump = self.__dump
    write("&lt;value&gt;&lt;array&gt;&lt;data&gt;\n")
    for v in value:
        dump(v)
    write("&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;\n")
    self.closecontainer(value)
</t>
<t tx="ekr.20040104185913.99">dispatch[TupleType] = dump_array
dispatch[ListType] = dump_array

def dump_struct(self, value, escape=escape):
    self.opencontainer(value)
    write = self.write
    dump = self.__dump
    write("&lt;value&gt;&lt;struct&gt;\n")
    for k, v in value.items():
        write("&lt;member&gt;\n")
        if type(k) is not StringType:
            raise TypeError, "dictionary key must be string"
        write("&lt;name&gt;%s&lt;/name&gt;\n" % escape(k))
        dump(v)
        write("&lt;/member&gt;\n")
    write("&lt;/struct&gt;&lt;/value&gt;\n")
    self.closecontainer(value)
</t>
<t tx="ekr.20040104185913.100">dispatch[DictType] = dump_struct

def dump_instance(self, value):
    # check for special wrappers
    if value.__class__ in WRAPPERS:
        value.encode(self)
    else:
        # store instance attributes as a struct (really?)
        self.dump_struct(value.__dict__)
</t>
<t tx="ekr.20040104185913.101">class Unmarshaller:
    """Unmarshal an XML-RPC response, based on incoming XML event
    messages (start, data, end).  Call close() to get the resulting
    data structure.

    Note that this reader is fairly tolerant, and gladly accepts bogus
    XML-RPC data without complaining (but not bogus XML).
    """
	&lt;&lt; class Unmarshaller declarations &gt;&gt;
	@others
    dispatch["methodName"] = end_methodName</t>
<t tx="ekr.20040104185913.102">    # and again, if you don't understand what's going on in here,
    # that's perfectly ok.

</t>
<t tx="ekr.20040104185913.103">def __init__(self):
    self._type = None
    self._stack = []
    self._marks = []
    self._data = []
    self._methodname = None
    self._encoding = "utf-8"
    self.append = self._stack.append
</t>
<t tx="ekr.20040104185913.104">def close(self):
    # return response tuple and target method
    if self._type is None or self._marks:
        raise ResponseError()
    if self._type == "fault":
        raise apply(Fault, (), self._stack[0])
    return tuple(self._stack)
</t>
<t tx="ekr.20040104185913.105">def getmethodname(self):
    return self._methodname
</t>
<t tx="ekr.20040104185913.106">#
# event handlers

def xml(self, encoding, standalone):
    self._encoding = encoding
</t>
<t tx="ekr.20040104185913.107">    # FIXME: assert standalone == 1 ???

def start(self, tag, attrs):
    # prepare to handle this element
    if tag == "array" or tag == "struct":
        self._marks.append(len(self._stack))
    self._data = []
    self._value = (tag == "value")
</t>
<t tx="ekr.20040104185913.108">def data(self, text):
    self._data.append(text)
</t>
<t tx="ekr.20040104185913.109">def end(self, tag, join=string.join):
    # call the appropriate end tag handler
    try:
        f = self.dispatch[tag]
    except KeyError:
        pass # unknown tag ?
    else:
        return f(self, join(self._data, ""))
</t>
<t tx="ekr.20040104185913.110">#
# accelerator support

def end_dispatch(self, tag, data):
    # dispatch data
    try:
        f = self.dispatch[tag]
    except KeyError:
        pass # unknown tag ?
    else:
        return f(self, data)
</t>
<t tx="ekr.20040104185913.111">#
# element decoders

dispatch = {}

def end_boolean(self, data):
    if data == "0":
        self.append(False)
    elif data == "1":
        self.append(True)
    else:
        raise TypeError, "bad boolean value"
    self._value = 0
</t>
<t tx="ekr.20040104185913.112">dispatch["boolean"] = end_boolean

def end_int(self, data):
    self.append(int(data))
    self._value = 0
</t>
<t tx="ekr.20040104185913.113">dispatch["i4"] = end_int
dispatch["int"] = end_int

def end_double(self, data):
    self.append(float(data))
    self._value = 0
</t>
<t tx="ekr.20040104185913.114">dispatch["double"] = end_double

def end_string(self, data):
    if self._encoding:
        data = _decode(data, self._encoding)
    self.append(_stringify(data))
    self._value = 0
</t>
<t tx="ekr.20040104185913.115">dispatch["string"] = end_string
dispatch["name"] = end_string # struct keys are always strings

def end_array(self, data):
    mark = self._marks[-1]
    del self._marks[-1]
    # map arrays to Python lists
    self._stack[mark:] = [self._stack[mark:]]
    self._value = 0
</t>
<t tx="ekr.20040104185913.116">dispatch["array"] = end_array

def end_struct(self, data):
    mark = self._marks[-1]
    del self._marks[-1]
    # map structs to Python dictionaries
    dict = {}
    items = self._stack[mark:]
    for i in range(0, len(items), 2):
        dict[_stringify(items[i])] = items[i+1]
    self._stack[mark:] = [dict]
    self._value = 0
</t>
<t tx="ekr.20040104185913.117">dispatch["struct"] = end_struct

def end_base64(self, data):
    value = Binary()
    value.decode(data)
    self.append(value)
    self._value = 0
</t>
<t tx="ekr.20040104185913.118">dispatch["base64"] = end_base64

def end_dateTime(self, data):
    value = DateTime()
    value.decode(data)
    self.append(value)
</t>
<t tx="ekr.20040104185913.119">dispatch["dateTime.iso8601"] = end_dateTime

def end_value(self, data):
    # if we stumble upon an value element with no internal
    # elements, treat it as a string element
    if self._value:
        self.end_string(data)
</t>
<t tx="ekr.20040104185913.120">dispatch["value"] = end_value

def end_params(self, data):
    self._type = "params"
</t>
<t tx="ekr.20040104185913.121">dispatch["params"] = end_params

def end_fault(self, data):
    self._type = "fault"
</t>
<t tx="ekr.20040104185913.122">dispatch["fault"] = end_fault

def end_methodName(self, data):
    if self._encoding:
        data = _decode(data, self._encoding)
    self._methodname = data
    self._type = "methodName" # no params
</t>
<t tx="ekr.20040104185913.123">def getparser():
    """getparser() -&gt; parser, unmarshaller

    Create an instance of the fastest available parser, and attach it
    to an unmarshalling object.  Return both objects.
    """
    if FastParser and FastUnmarshaller:
        target = FastUnmarshaller(True, False, binary, datetime)
        parser = FastParser(target)
    else:
        target = Unmarshaller()
        if FastParser:
            parser = FastParser(target)
        elif SgmlopParser:
            parser = SgmlopParser(target)
        elif ExpatParser:
            parser = ExpatParser(target)
        else:
            parser = SlowParser(target)
    return parser, target
</t>
<t tx="ekr.20040104185913.124">def dumps(params, methodname=None, methodresponse=None, encoding=None):
    """data [,options] -&gt; marshalled data

    Convert an argument tuple or a Fault instance to an XML-RPC
    request (or response, if the methodresponse option is used).

    In addition to the data object, the following options can be given
    as keyword arguments:

        methodname: the method name for a methodCall packet

        methodresponse: true to create a methodResponse packet.
        If this option is used with a tuple, the tuple must be
        a singleton (i.e. it can contain only one element).

        encoding: the packet encoding (default is UTF-8)

    All 8-bit strings in the data structure are assumed to use the
    packet encoding.  Unicode strings are automatically converted,
    where necessary.
    """

    assert isinstance(params, TupleType) or isinstance(params, Fault),\
           "argument must be tuple or Fault instance"

    if isinstance(params, Fault):
        methodresponse = 1
    elif methodresponse and isinstance(params, TupleType):
        assert len(params) == 1, "response tuple must be a singleton"

    if not encoding:
        encoding = "utf-8"

    m = Marshaller(encoding)
    data = m.dumps(params)

    if encoding != "utf-8":
        xmlheader = "&lt;?xml version='1.0' encoding=%s?&gt;\n" % repr(encoding)
    else:
        xmlheader = "&lt;?xml version='1.0'?&gt;\n" # utf-8 is default

    # standard XML-RPC wrappings
    if methodname:
        # a method call
        if not isinstance(methodname, StringType):
            methodname = methodname.encode(encoding)
        data = (
            xmlheader,
            "&lt;methodCall&gt;\n"
            "&lt;methodName&gt;", methodname, "&lt;/methodName&gt;\n",
            data,
            "&lt;/methodCall&gt;\n"
            )
    elif methodresponse:
        # a method response, or a fault structure
        data = (
            xmlheader,
            "&lt;methodResponse&gt;\n",
            data,
            "&lt;/methodResponse&gt;\n"
            )
    else:
        return data # return as is
    return string.join(data, "")
</t>
<t tx="ekr.20040104185913.125">def loads(data):
    """data -&gt; unmarshalled data, method name

    Convert an XML-RPC packet to unmarshalled data plus a method
    name (None if not present).

    If the XML-RPC packet represents a fault condition, this function
    raises a Fault exception.
    """
    p, u = getparser()
    p.feed(data)
    p.close()
    return u.close(), u.getmethodname()
</t>
<t tx="ekr.20040104185913.126"># request dispatcher

class _Method:
	&lt;&lt; class _Method declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.127">    # some magic to bind an XML-RPC method to an RPC server.
    # supports "nested" methods (e.g. examples.getStateName)
</t>
<t tx="ekr.20040104185913.128">def __init__(self, send, name):
    self.__send = send
    self.__name = name
</t>
<t tx="ekr.20040104185913.129">def __getattr__(self, name):
    return _Method(self.__send, "%s.%s" % (self.__name, name))
</t>
<t tx="ekr.20040104185913.130">def __call__(self, *args):
    return self.__send(self.__name, args)
</t>
<t tx="ekr.20040104185913.131">class Transport:
    """Handles an HTTP transaction to an XML-RPC server."""
	&lt;&lt; class Transport declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.132"># client identifier (may be overridden)
user_agent = "xmlrpclib.py/%s (by www.pythonware.com)" % __version__

</t>
<t tx="ekr.20040104185913.133">def request(self, host, handler, request_body, verbose=0):
    # issue XML-RPC request

    h = self.make_connection(host)
    if verbose:
        h.set_debuglevel(1)

    self.send_request(h, handler, request_body)
    self.send_host(h, host)
    self.send_user_agent(h)
    self.send_content(h, request_body)

    errcode, errmsg, headers = h.getreply()

    if errcode != 200:
        raise ProtocolError(
            host + handler,
            errcode, errmsg,
            headers
            )

    self.verbose = verbose

    return self.parse_response(h.getfile())
</t>
<t tx="ekr.20040104185913.134">def getparser(self):
    # get parser and unmarshaller
    return getparser()
</t>
<t tx="ekr.20040104185913.135">def make_connection(self, host):
    # create a HTTP connection object from a host descriptor
    import httplib
    return httplib.HTTP(host)
</t>
<t tx="ekr.20040104185913.136">def send_request(self, connection, handler, request_body):
    connection.putrequest("POST", handler)
</t>
<t tx="ekr.20040104185913.137">def send_host(self, connection, host):
    connection.putheader("Host", host)
</t>
<t tx="ekr.20040104185913.138">def send_user_agent(self, connection):
    connection.putheader("User-Agent", self.user_agent)
</t>
<t tx="ekr.20040104185913.139">def send_content(self, connection, request_body):
    connection.putheader("Content-Type", "text/xml")
    connection.putheader("Content-Length", str(len(request_body)))
    connection.endheaders()
    if request_body:
        connection.send(request_body)
</t>
<t tx="ekr.20040104185913.140">def parse_response(self, f):
    # read response from input file, and parse it

    p, u = self.getparser()

    while 1:
        response = f.read(1024)
        if not response:
            break
        if self.verbose:
            print "body:", repr(response)
        p.feed(response)

    f.close()
    p.close()

    return u.close()
</t>
<t tx="ekr.20040104185913.141">class SafeTransport(Transport):
    """Handles an HTTPS transaction to an XML-RPC server."""
	@others
</t>
<t tx="ekr.20040104185913.142">def make_connection(self, host):
    # create a HTTPS connection object from a host descriptor
    # host may be a string, or a (host, x509-dict) tuple
    import httplib
    if isinstance(host, TupleType):
        host, x509 = host
    else:
        x509 = {}
    try:
        HTTPS = httplib.HTTPS
    except AttributeError:
        raise NotImplementedError,\
              "your version of httplib doesn't support HTTPS"
    else:
        return apply(HTTPS, (host, None), x509)
</t>
<t tx="ekr.20040104185913.143">def send_host(self, connection, host):
    if isinstance(host, TupleType):
        host, x509 = host
    connection.putheader("Host", host)
</t>
<t tx="ekr.20040104185913.144">class ServerProxy:
    """uri [,options] -&gt; a logical connection to an XML-RPC server

    uri is the connection point on the server, given as
    scheme://host/target.

    The standard implementation always supports the "http" scheme.  If
    SSL socket support is available (Python 2.0), it also supports
    "https".

    If the target part and the slash preceding it are both omitted,
    "/RPC2" is assumed.

    The following options can be given as keyword arguments:

        transport: a transport factory
        encoding: the request encoding (default is UTF-8)

    All 8-bit strings passed to the server proxy are assumed to use
    the given encoding.
    """
	@others

# compatibility
Server = ServerProxy</t>
<t tx="ekr.20040104185913.145">def __init__(self, uri, transport=None, encoding=None, verbose=0):
    # establish a "logical" server connection

    # get the url
    import urllib
    type, uri = urllib.splittype(uri)
    if type not in ("http", "https"):
        raise IOError, "unsupported XML-RPC protocol"
    self.__host, self.__handler = urllib.splithost(uri)
    if not self.__handler:
        self.__handler = "/RPC2"

    if transport is None:
        if type == "https":
            transport = SafeTransport()
        else:
            transport = Transport()
    self.__transport = transport

    self.__encoding = encoding
    self.__verbose = verbose
</t>
<t tx="ekr.20040104185913.146">def __request(self, methodname, params):
    # call a method on the remote server

    request = dumps(params, methodname, encoding=self.__encoding)

    response = self.__transport.request(
        self.__host,
        self.__handler,
        request,
        verbose=self.__verbose
        )

    if len(response) == 1:
        response = response[0]

    return response
</t>
<t tx="ekr.20040104185913.147">def __repr__(self):
    return (
        "&lt;ServerProxy for %s%s&gt;" %
        (self.__host, self.__handler)
        )
</t>
<t tx="ekr.20040104185913.148">__str__ = __repr__

def __getattr__(self, name):
    # magic method dispatcher
    return _Method(self.__request, name)

    # note: to call a remote object with an non-standard name, use
    # result getattr(server, "strange-python-name")(args)</t>
<t tx="ekr.20040104185913.149">Zope 2.6.2 (source release, python 2.1, linux2)</t>
<t tx="ekr.20040104185913.150"></t>
<t tx="ekr.20040104185913.151">@nocolor

Security Architecture
---------------------

Users
-----

Objects representing users may be created in Principia
User Folder objects. User objects maintain the information
used to authenticate users, and allow roles to be associated
with a user.

Permissions
-----------

A "permission" is the smallest unit of access to an object,
roughly equivalent to the atomic permissions seen in NT:
R (Read), W(Write), X(Execute), etc. In Principia, a permission
usually describes a fine-grained logical operation on an object,
such as "View Management Screens", "Add Properties", etc.

Different types of objects will define different permissions
as appropriate for the object.


Types of access
---------------

A "type of access" is a named grouping of 0 or more of the
permissions defined by an object. All objects have one predefined
type of access called Full Access (all permissions defined by that 
object). A user who has the special role "Manager" always has Full 
Access to all objects at or below the level in the object hierarchy 
at which the user is defined.

New types of access may be defined as combinations of the
various permissions defined by a given object. These new
types of access may be defined by the programmer, or by
users at runtime. 

Roles
-----

A role is a name that ties users (authentication of identity)
to permissions (authorization for that identity) in the system.
Roles may be defined in any Folder (or Folderish) object in the
system. Sub folders can make use of roles defined higher in the
hierarchy. These roles can be assigned to users. All users, 
including non-authenticated users have the built-in role of 
"Anonymous". 

Principia objects allow the association of defined roles 
with a single "type of access" each, in the context of that 
object. A single role is associated with one and only one 
type of access in the context of a given object.



Examples
--------

  User                        Object1

  o has the role "RoleA"      o has given "RoleA" Full Access

  Result: the user has Full Access to Object1.



  User                        Object2
  o has the role "RoleA"      o has given "RoleB" Full Access

                              o has given the role "RoleA" View Access,
                                a custom type of access that allows only
                                viewing of the object.

  Result: the user has only View Access.



Notes
-----

All objects define a permission called "Default permission". If this
permission is given to a role, users with that role will be able to
access subobjects which do not explicitly restrict access.



Technical
---------

Objects define their permissions as logical operations.
Programmers have to determine the appropriate operations
for their object type, and provide a mapping of permission
name to attribute names. It is important to note that permissions
cannot overlap - none of the attributes named in a permission
can occur in any of the other permissions. The following are
proposed permissions for some current principia objects:


Folder
  o View management screens
  o Change permissions
  o Undo changes
  o Add objects
  o Delete objects
  o Add properties
  o Change properties
  o Delete properties
  o Default permission

Confera Topic
  o View management screens
  o Change permissions
  o Undo changes
  o Add objects
  o Delete objects
  o Add properties
  o Change properties
  o Delete properties
  o Default permission
  o Change Configuration
  o Add Messages
  o Change Messages
  o Delete Messages

Tabula Collection
  o View management screens
  o Change permissions
  o Undo changes
  o Add objects
  o Delete objects
  o Add properties
  o Change properties
  o Delete properties
  o Default permission
  o Change schema
  o Upload data
  o Add computed fields
  o Change computed fields
  o Delete computed fields

Document/Image/File
  o View management screens
  o Change permissions
  o Change/upload data
  o View

Session
  o View management screens
  o Change permissions
  o Change session config
  o Join/leave session
  o Save/discard session

Mail Host
  o View management screens
  o Change permissions
  o Change configuration




To support the architecture, developers must derive an
object from the AccessControl.RoleManager mixin class,
and define in their class an __ac_permissions__ attribute.

This should be a tuple of tuples, where each tuple represents
a permission and contains a string permission name as its first
element and a list of attribute names as its second element.

Example:

    __ac_permissions__=(

    ('View management screens',
     ['manage','manage_menu','manage_main','manage_copyright',
      'manage_tabs','manage_propertiesForm','manage_UndoForm']),
    ('Undo changes',       ['manage_undo_transactions']),
    ('Change permissions', ['manage_access']),
    ('Add objects',        ['manage_addObject']),
    ('Delete objects',     ['manage_delObjects']),
    ('Add properties',     ['manage_addProperty']),
    ('Change properties',  ['manage_editProperties']),
    ('Delete properties',  ['manage_delProperties']),
    ('Default permission', ['']),
    )
   


The developer may also predefine useful types of access, by
specifying an __ac_types__ attribute. This should be a tuple of 
tuples, where each tuple represents a type of access and contains 
a string name as its first element and a list of permission names 
as its second element.

By default, only "Full Access" is defined (by the RoleManager mixin).
If you wish to override __ac_types__ to provide convenient types of
access, you must always be sure to define "Full Access" as containing 
the names of all possible permissions for your object.

Example:

    __ac_types__=(

    ('Full Access', map(lambda x: x[0], __ac_permissions__)),
    ('Change', ['Add Objects', 'Add Properties', 'Change Properties']),

    )



Developers may also provide pre-defined role names that are
not deletable via the interface by specifying an __ac_roles__
attribute. This is probably not something we'll ever use under
the new architecture, but it's there if you need it.

Example:

    __ac_roles__=('Manager', 'Anonymous')


























</t>
<t tx="ekr.20040104185913.152">&lt;&lt; copyright &gt;&gt;

__version__='$Revision: 1.7 $'[11:-2]

import sha, binascii
from binascii import b2a_base64, a2b_base64
from random import choice, randrange


@others

 </t>
<t tx="ekr.20040104185913.154">class PasswordEncryptionScheme:  # An Interface
	@others
</t>
<t tx="ekr.20040104185913.155">def encrypt(pw):
    """
    Encrypt the provided plain text password.
    """
</t>
<t tx="ekr.20040104185913.156">def validate(reference, attempt):
    """
    Validate the provided password string.  Reference is the
    correct password, which may be encrypted; attempt is clear text
    password attempt.
    """
</t>
<t tx="ekr.20040104185913.157">_schemes = []

def registerScheme(id, s):
    '''
    Registers an LDAP password encoding scheme.
    '''
    _schemes.append((id, '{%s}' % id, s))
</t>
<t tx="ekr.20040104185913.158">def listSchemes():
    r = []
    for id, prefix, scheme in _schemes:
        r.append(id)
    return r
</t>
<t tx="ekr.20040104185913.159">class SSHADigestScheme:
    '''
    SSHA is a modification of the SHA digest scheme with a salt
    starting at byte 20 of the base64-encoded string.
    '''
	&lt;&lt; class SSHADigestScheme declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.160">    # Source: http://developer.netscape.com/docs/technote/ldap/pass_sha.html

</t>
<t tx="ekr.20040104185913.161">def generate_salt(self):
    # Salt can be any length, but not more than about 37 characters
    # because of limitations of the binascii module.
    # 7 is what Netscape's example used and should be enough.
    # All 256 characters are available.
    salt = ''
    for n in range(7):
        salt += chr(randrange(256))
    return salt
</t>
<t tx="ekr.20040104185913.162">def encrypt(self, pw):
    pw = str(pw)
    salt = self.generate_salt()
    return b2a_base64(sha.new(pw + salt).digest() + salt)[:-1]
</t>
<t tx="ekr.20040104185913.163">def validate(self, reference, attempt):
    try:
        ref = a2b_base64(reference)
    except binascii.Error:
        # Not valid base64.
        return 0
    salt = ref[20:]
    compare = b2a_base64(sha.new(attempt + salt).digest() + salt)[:-1]
    return (compare == reference)
</t>
<t tx="ekr.20040104185913.164">registerScheme('SSHA', SSHADigestScheme())


class SHADigestScheme:
	@others
</t>
<t tx="ekr.20040104185913.165">def encrypt(self, pw):
    return b2a_base64(sha.new(pw).digest())[:-1]
</t>
<t tx="ekr.20040104185913.166">def validate(self, reference, attempt):
    compare = b2a_base64(sha.new(attempt).digest())[:-1]
    return (compare == reference)
</t>
<t tx="ekr.20040104185913.167">registerScheme('SHA', SHADigestScheme())


# Bogosity on various platforms due to ITAR restrictions
try:
    from crypt import crypt
except ImportError:
    crypt = None

if crypt is not None:

    class CryptDigestScheme:
	@others</t>
<t tx="ekr.20040104185913.168">def generate_salt(self):
    choices = ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"
               "abcdefghijklmnopqrstuvwxyz"
               "0123456789./")
    return choice(choices) + choice(choices)
</t>
<t tx="ekr.20040104185913.169">def encrypt(self, pw):
    return crypt(pw, self.generate_salt())
</t>
<t tx="ekr.20040104185913.170">def validate(self, reference, attempt):
    a = crypt(attempt, reference[:2])
    return (a == reference)
</t>
<t tx="ekr.20040104185913.171">registerScheme('CRYPT', CryptDigestScheme())


def pw_validate(reference, attempt):
</t>
<t tx="ekr.20040104185913.172">"""Validate the provided password string, which uses LDAP-style encoding
notation.  Reference is the correct password, attempt is clear text
password attempt."""
for id, prefix, scheme in _schemes:
    lp = len(prefix)
    if reference[:lp] == prefix:
        return scheme.validate(reference[lp:], attempt)
# Assume cleartext.
return (reference == attempt)

def is_encrypted(pw):
	for id, prefix, scheme in _schemes:
		lp = len(prefix)
		if pw[:lp] == prefix:
			return 1
	return 0</t>
<t tx="ekr.20040104185913.173">def pw_encrypt(pw, encoding='SSHA'):
   """Encrypt the provided plain text password using the encoding if provided
    and return it in an LDAP-style representation."""
    for id, prefix, scheme in _schemes:
        if encoding == id:
            return prefix + scheme.encrypt(pw)
    raise ValueError, 'Not supported: %s' % encoding

pw_encode = pw_encrypt  # backward compatibility
</t>
<t tx="ekr.20040104185913.174">&lt;&lt; copyright &gt;&gt;

'''Add security system support to Document Templates

$Id: DTML.py,v 1.10 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.10 $'[11:-2]

from DocumentTemplate import DT_Util
import SecurityManagement, string, math, whrandom, random
import DocumentTemplate.sequence

from ZopeGuards import guarded_getattr, guarded_getitem

@others</t>
<t tx="ekr.20040104185913.176">class RestrictedDTML:
    '''
    A mix-in for derivatives of DT_String.String that adds Zope security.
    '''
	@others
</t>
<t tx="ekr.20040104185913.177">def guarded_getattr(self, *args): # ob, name [, default]
    return guarded_getattr(*args)
</t>
<t tx="ekr.20040104185913.178">def guarded_getitem(self, ob, index):
    return guarded_getitem(ob, index)
</t>
<t tx="ekr.20040104185913.179">try:
    #raise ImportError
    import os
    if os.environ.get("ZOPE_SECURITY_POLICY", None) == "PYTHON":
        raise ImportError # :)
    from cAccessControl import RestrictedDTMLMixin
except ImportError:
    pass
else:
    class RestrictedDTML(RestrictedDTMLMixin, RestrictedDTML):
        '''
        A mix-in for derivatives of DT_String.String that adds Zope security.
        '''
		# Allow access to unprotected attributes
		DT_Util.TemplateDict.__allow_access_to_unprotected_subobjects__=1
		string.__allow_access_to_unprotected_subobjects__=1
		math.__allow_access_to_unprotected_subobjects__=1
		whrandom.__allow_access_to_unprotected_subobjects__=1
		random.__allow_access_to_unprotected_subobjects__=1
		
		DocumentTemplate.sequence.__allow_access_to_unprotected_subobjects__=1</t>
<t tx="ekr.20040104185913.181"># Add security testing capabilities

class DTMLSecurityAPI:
    """API for performing security checks in DTML using '_' methods.
    """
	@others

DT_Util.TemplateDict.__dict__.update(DTMLSecurityAPI.__dict__)
</t>
<t tx="ekr.20040104185913.182">def SecurityValidate(md, inst, parent, name, value):
    """Validate access.

    Arguments:

    accessed -- the object that was being accessed

    container -- the object the value was found in

    name -- The name used to access the value

    value -- The value retrieved though the access.

    The arguments may be provided as keyword arguments. Some of these
    arguments may be ommitted, however, the policy may reject access
    in some cases when arguments are ommitted.  It is best to provide
    all the values possible.
    """
    return (SecurityManagement
            .getSecurityManager()
            .validate(inst, parent, name, value)
            )
</t>
<t tx="ekr.20040104185913.183">def SecurityValidateValue(md, value):
    """Convenience for common case of simple value validation.
    """
    return (SecurityManagement
            .getSecurityManager()
            .validateValue(value)
            )
</t>
<t tx="ekr.20040104185913.184">def SecurityCheckPermission(md, permission, object):
    """Check whether the security context allows the given permission on
    the given object.

    Arguments:

    permission -- A permission name

    object -- The object being accessed according to the permission
    """
    return (SecurityManagement
            .getSecurityManager()
            .checkPermission(permission, object)
            )
</t>
<t tx="ekr.20040104185913.185">def SecurityGetUser(md):
    """Gen the current authenticated user"""
    return (SecurityManagement
            .getSecurityManager()
            .getUser()
            )
</t>
<t tx="ekr.20040104185913.186">def SecurityCalledByExecutable(md):
    """Return a boolean value indicating if this context was called
    by an executable"""
    r = (SecurityManagement
         .getSecurityManager()
         .calledByExecutable()
         )
    if r &gt; 0: return r-1
    return r
</t>
<t tx="ekr.20040104185913.187">@others
</t>
<t tx="ekr.20040104185913.188">class IStandardUserFolder:
	@others
</t>
<t tx="ekr.20040104185913.189">def getUser(self, name):
    """
    Returns the user object specified by name.  If there is no
    user named 'name' in the user folder, return None.
    """
</t>
<t tx="ekr.20040104185913.190">def getUsers(self):
    """
    Returns a sequence of all user objects which reside in the user
    folder.
    """
</t>
<t tx="ekr.20040104185913.191">def getUserNames(self):
    """
    Returns a sequence of names of the users which reside in the user
    folder.
    """
</t>
<t tx="ekr.20040104185913.192">&lt;&lt; copyright &gt;&gt;

__doc__='''Support for owned objects

$Id: Owned.py,v 1.18 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.18 $'[11:-2]

import Globals, urlparse, SpecialUsers, ExtensionClass
from AccessControl import getSecurityManager, Unauthorized
from Acquisition import aq_get, aq_parent, aq_base

UnownableOwner=[]

@others
</t>
<t tx="ekr.20040104185913.194">def ownableFilter(self,
                  aq_get=aq_get,
                  UnownableOwner=UnownableOwner):
    _owner=aq_get(self, '_owner', None, 1)
    return _owner is not UnownableOwner
</t>
<t tx="ekr.20040104185913.195"># Marker to use as a getattr default.
_mark=ownableFilter

class Owned(ExtensionClass.Base):
	&lt;&lt; class Owned declarations &gt;&gt;
	@others

Globals.default__class_init__(Owned)</t>
<t tx="ekr.20040104185913.196">__ac_permissions__=(
    ('View management screens',
     ('manage_owner', 'owner_info', 'userCanChangeOwnershipType')),
    ('Take ownership',
     ('manage_takeOwnership','manage_changeOwnershipType'),
     ("Owner",)),
    )

manage_options=({'label':  'Ownership',
                 'action': 'manage_owner',
                 'help':   ('OFSP','Ownership.stx'),
                 'filter': ownableFilter
                 },
               )

manage_owner=Globals.DTMLFile('dtml/owner', globals())

</t>
<t tx="ekr.20040104185913.197">def owner_info(self):
    """Get ownership info for display
    """
    owner=self.getOwner(1)
    if owner is None or owner is UnownableOwner: return owner
    d={'path': '/'.join(owner[0]), 'id': owner[1],
       'explicit': hasattr(self, '_owner'),
       'userCanChangeOwnershipType':
       getSecurityManager().checkPermission('Take ownership', self)
       }
    return d
</t>
<t tx="ekr.20040104185913.198">getOwner__roles__=()
def getOwner(self, info=0,
             aq_get=aq_get, None=None,
             UnownableOwner=UnownableOwner,
             getSecurityManager=getSecurityManager,
             ):
    """Get the owner

    If a true argument is provided, then only the owner path and id are
    returned. Otherwise, the owner object is returned.
    """
    owner=aq_get(self, '_owner', None, 1)
    if info or (owner is None): return owner

    if owner is UnownableOwner: return None

    udb, oid = owner

    root=self.getPhysicalRoot()
    udb=root.unrestrictedTraverse(udb, None)
    if udb is None:
        user = SpecialUsers.nobody
    else:
        user = udb.getUserById(oid, None)
        if user is None: user = SpecialUsers.nobody
    return user
</t>
<t tx="ekr.20040104185913.199">changeOwnership__roles__=()
def changeOwnership(self, user, recursive=0,
                    aq_get=aq_get, None=None,
                    ):
    """Change the ownership to the given user.  If 'recursive' is
    true then also take ownership of all sub-objects, otherwise
    sub-objects retain their ownership information."""

    new=ownerInfo(user)
    if new is None: return # Special user!
    old=aq_get(self, '_owner', None, 1)
    if old==new: return
    if old is UnownableOwner: return

    for child in self.objectValues():
        if recursive:
            child.changeOwnership(user, 1)
        else:
            # make ownership explicit
            child._owner=new

    if old is not UnownableOwner:
        self._owner=new
</t>
<t tx="ekr.20040104185913.200">def userCanTakeOwnership(self):
    security=getSecurityManager()
    user=security.getUser()
    info=ownerInfo(user)
    if info is None: return 0
    owner=self.getOwner(1)
    if owner == info: return 0
    return security.checkPermission('Take ownership', self)
</t>
<t tx="ekr.20040104185913.201">def manage_takeOwnership(self, REQUEST, RESPONSE, recursive=0):
    """
    Take ownership (responsibility) for an object. If 'recursive'
    is true, then also take ownership of all sub-objects.
    """
    security=getSecurityManager()
    want_referer=REQUEST['URL1']+'/manage_owner'
    got_referer=("%s://%s%s" %
                 urlparse.urlparse(REQUEST['HTTP_REFERER'])[:3])
    __traceback_info__=want_referer, got_referer
    if (want_referer != got_referer or security.calledByExecutable()):
        raise Unauthorized, (
            'manage_takeOwnership was called from an invalid context'
            )

    self.changeOwnership(security.getUser(), recursive)

    RESPONSE.redirect(REQUEST['HTTP_REFERER'])
</t>
<t tx="ekr.20040104185913.202">def manage_changeOwnershipType(self, explicit=1,
                               RESPONSE=None, REQUEST=None):
    """Change the type (implicit or explicit) of ownership.
    """
    old=getattr(self, '_owner', None)
    if explicit:
        if old is not None: return
        owner=aq_get(self, '_owner', None, 1)
        if owner is not None and owner is not UnownableOwner:
            self._owner=owner
    else:
        if old is None: return
        new=aq_get(aq_parent(self), '_owner', None, 1)
        if old is new and (
            self.__dict__.get('_owner', _mark) is not _mark
            ):
            del self._owner

    if RESPONSE is not None: RESPONSE.redirect(REQUEST['HTTP_REFERER'])
</t>
<t tx="ekr.20040104185913.203">def _deleteOwnershipAfterAdd(self):

    # Only delete _owner if it is an instance attribute.
    if self.__dict__.get('_owner', _mark) is not _mark:
        del self._owner

    for object in self.objectValues():
        try: s=object._p_changed
        except: s=0
        try: object._deleteOwnershipAfterAdd()
        except: pass
        if s is None: object._p_deactivate()
</t>
<t tx="ekr.20040104185913.204">def manage_fixupOwnershipAfterAdd(self):

    # Sigh, get the parent's _owner
    parent=getattr(self, 'aq_parent', None)
    if parent is not None: _owner=aq_get(parent, '_owner', None, 1)
    else: _owner=None

    if (_owner is None and
        ((not hasattr(self, 'aq_parent')) or
         (not hasattr(self, 'getPhysicalRoot'))
         )
        ):
        # This is a special case. An object is
        # being added to an object that hasn't
        # been added to the object hierarchy yet.
        # We can delay fixing up the ownership until the
        # object is actually added.
        return None

    if _owner is UnownableOwner:
        # We want to acquire Unownable ownership!
        return self._deleteOwnershipAfterAdd()
    else:
        # Otherwise change the ownership
        user=getSecurityManager().getUser()
        if (SpecialUsers.emergency_user and
            aq_base(user) is SpecialUsers.emergency_user):
            __creatable_by_emergency_user__=getattr(
                self,'__creatable_by_emergency_user__', None)
            if (__creatable_by_emergency_user__ is None or
                (not __creatable_by_emergency_user__())):
                raise EmergencyUserCannotOwn, (
                    "Objects cannot be owned by the emergency user")
        self.changeOwnership(user)

    # Force all subs to acquire ownership!
    for object in self.objectValues():
        try: s=object._p_changed
        except: s=0
        try: object._deleteOwnershipAfterAdd()
        except: pass
        if s is None: object._p_deactivate()
</t>
<t tx="ekr.20040104185913.205">class EmergencyUserCannotOwn(Exception):
	"The emergency user cannot own anything"</t>
<t tx="ekr.20040104185913.207">class EditUnowned(Exception):
	"Can't edit unowned executables"
</t>
<t tx="ekr.20040104185913.209">def absattr(attr):
    if callable(attr): return attr()
    return attr
</t>
<t tx="ekr.20040104185913.210">def ownerInfo(user,
              getattr=getattr, type=type, st=type(''), None=None):
    if user is None:
        return None
    uid=user.getId()
    if uid is None: return uid
    db=user.aq_inner.aq_parent
    path=[absattr(db.id)]
    root=db.getPhysicalRoot()
    while 1:
        db=getattr(db,'aq_inner', None)
        if db is None: break
        db=db.aq_parent
        if db is root: break
        id=db.id
        if type(id) is not st:
            try: id=id()
            except: id=str(id)
        path.append(id)

    path.reverse()

    return path, uid
</t>
<t tx="ekr.20040104185913.211">&lt;&lt; copyright &gt;&gt;

__doc__='''short description


$Id: Permission.py,v 1.10 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.10 $'[11:-2]

import string, Products, Globals

ListType=type([])

name_trans=filter(lambda c, an=string.letters+string.digits+'_': c not in an,
                  map(chr,range(256)))
name_trans=string.maketrans(''.join(name_trans), '_'*len(name_trans))

@others
</t>
<t tx="ekr.20040104185913.213">def pname(name, translate=string.translate, name_trans=name_trans):
    return '_'+translate(name,name_trans)+"_Permission"
</t>
<t tx="ekr.20040104185913.214">_marker=[]
class Permission:
	 # A Permission maps a named logical permission to a set
    # of attribute names. Attribute names which appear in a
    # permission may not appear in any other permission defined
    # by the object.
	@others
</t>
<t tx="ekr.20040104185913.216">def __init__(self,name,data,obj,default=None):
    self.name=name
    self._p='_'+string.translate(name,name_trans)+"_Permission"
    self.data=data
    if hasattr(obj, 'aq_base'): obj=obj.aq_base
    self.obj=obj
    self.default=default
</t>
<t tx="ekr.20040104185913.217">def getRoles(self, default=_marker):
    # Return the list of role names which have been given
    # this permission for the object in question. To do
    # this, we try to get __roles__ from all of the object
    # attributes that this permission represents.
    obj=self.obj
    name=self._p
    if hasattr(obj, name): return getattr(obj, name)
    roles=default
    for name in self.data:
        if name:
            if hasattr(obj, name):
                attr=getattr(obj, name)
                if hasattr(attr,'im_self'):
                    attr=attr.im_self
                    if hasattr(attr, '__dict__'):
                        attr=attr.__dict__
                        name=name+'__roles__'
                        if attr.has_key(name):
                            roles=attr[name]
                            break
        elif hasattr(obj, '__dict__'):
            attr=obj.__dict__
            if attr.has_key('__roles__'):
                roles=attr['__roles__']
                break

    if roles:
        try:
            if 'Shared' not in roles: return tuple(roles)
            roles=list(roles)
            roles.remove('Shared')
            return roles
        except: return []

    if roles is None: return ['Manager','Anonymous']
    if roles is _marker: return ['Manager']

    return roles
</t>
<t tx="ekr.20040104185913.218">def setRoles(self, roles):
    obj=self.obj

    if type(roles) is ListType and not roles:
        if hasattr(obj, self._p): delattr(obj, self._p)
    else:
        setattr(obj, self._p, roles)

    for name in self.data:
        if name=='': attr=obj
        else: attr=getattr(obj, name)
        try: del attr.__roles__
        except: pass
        try: delattr(obj,name+'__roles__')
        except: pass
</t>
<t tx="ekr.20040104185913.219">def setRole(self, role, present):
    roles=self.getRoles()
    if role in roles:
        if present: return
        if type(roles) is ListType: roles.remove(role)
        else:
            roles=list(roles)
            roles.remove(role)
            roles=tuple(roles)
    elif not present: return
    else:
        if type(roles) is ListType: roles.append(role)
        else: roles=roles+(role,)
    self.setRoles(roles)
</t>
<t tx="ekr.20040104185913.220">def __len__(self): return 1
</t>
<t tx="ekr.20040104185913.221">def __str__(self): return self.name
</t>
<t tx="ekr.20040104185913.222">_registeredPermissions={}
_registerdPermission=_registeredPermissions.has_key

def registerPermissions(permissions, defaultDefault=('Manager',)):
    """Register an __ac_permissions__ sequence.
    """
    for setting in permissions:
        if _registerdPermission(setting[0]): continue
        if len(setting)==2:
            perm, methods = setting
            default = defaultDefault
        else:
            perm, methods, default = setting
        _registeredPermissions[perm]=1
        Products.__ac_permissions__=(
            Products.__ac_permissions__+((perm,(),default),))
        mangled=pname(perm) # get mangled permission name
        if not hasattr(Globals.ApplicationDefaultPermissions, mangled):
            setattr(Globals.ApplicationDefaultPermissions,
                    mangled, default)
</t>
<t tx="ekr.20040104185913.223">&lt;&lt; copyright &gt;&gt;

"""Permission Mapping

Sometimes, we need an object's permissions to be remapped to other permissions
when the object is used in specual ways.  This is rather hard, since we
need the object's ordinary permissions intact so we can manage it.
"""

import ExtensionClass, Acquisition
from Permission import pname
from Owned import UnownableOwner
from Globals import InitializeClass
from cgi import escape

@others

InitializeClass(RoleManager)
</t>
<t tx="ekr.20040104185913.225">class RoleManager:
	@others
</t>
<t tx="ekr.20040104185913.226">def manage_getPermissionMapping(self):
    """Return the permission mapping for the object

    This is a list of dictionaries with:

      permission_name -- The name of the native object permission

      class_permission -- The class permission the permission is
         mapped to.
    """
    wrapper=getattr(self, '_permissionMapper', None)
    if wrapper is None: wrapper=PM()

    perms={}
    for p in self.possible_permissions():
        perms[pname(p)]=p

    r=[]
    a=r.append
    for ac_perms in self.ac_inherited_permissions(1):
        p=perms.get(getPermissionMapping(ac_perms[0], wrapper), '')
        a({'permission_name': ac_perms[0], 'class_permission': p})
    return r
</t>
<t tx="ekr.20040104185913.227">def manage_setPermissionMapping(self,
                                permission_names=[],
                                class_permissions=[], REQUEST=None):
    """Change the permission mapping
    """
    wrapper=getattr(self, '_permissionMapper', None)
    if wrapper is None: wrapper=PM()

    perms=self.possible_permissions()
    for i in range(len(permission_names)):
        name=permission_names[i]
        p=class_permissions[i]
        if p and (p not in perms):
            __traceback_info__=perms, p, i
            raise 'Permission mapping error', (
                """Attempted to map a permission to a permission, %s,
                that is not valid. This should never happen. (Waaa).
                """ % escape(p))


        setPermissionMapping(name, wrapper, p)

    self._permissionMapper=wrapper

    if REQUEST is not None:
        return self.manage_access(
            REQUEST,
            manage_tabs_message='The permission mapping has been updated')
</t>
<t tx="ekr.20040104185913.228">def _isBeingUsedAsAMethod(self, REQUEST =None, wannaBe=0):
    try:
        if hasattr(self, 'aq_self'):
            r=self.aq_acquire('_isBeingUsedAsAMethod_')
        else:
            r=self._isBeingUsedAsAMethod_
    except: r=0

    if REQUEST is not None:
        if not r != (not wannaBe): REQUEST.response.notFoundError()

    return r
</t>
<t tx="ekr.20040104185913.229">def _isBeingAccessedAsZClassDefinedInstanceMethod(self):
    p=getattr(self,'aq_parent',None)
    if p is None: return 0          # Not wrapped
    base=getattr(p, 'aq_base', None)
    return type(base) is PermissionMapper
</t>
<t tx="ekr.20040104185913.230">def getPermissionMapping(name, obj, st=type('')):
    obj=getattr(obj, 'aq_base', obj)
    name=pname(name)
    r=getattr(obj, name, '')
    if type(r) is not st: r=''
    return r
</t>
<t tx="ekr.20040104185913.231">def setPermissionMapping(name, obj, v):
    name=pname(name)
    if v: setattr(obj, name, pname(v))
    elif obj.__dict__.has_key(name): delattr(obj, name)
</t>
<t tx="ekr.20040104185913.232">class PM(ExtensionClass.Base):
	_owner=UnownableOwner
	_View_Permission='_View_Permission'
	_is_wrapperish = 1
	@others
	
PermissionMapper=PM</t>
<t tx="ekr.20040104185913.234">def __getattr__(self, name):
    # We want to make sure that any non-explicitly set methods are
    # private!
    if name.startswith('_') and name.endswith("_Permission"): return ''
    raise AttributeError, escape(name)
</t>
<t tx="ekr.20040104185913.235">def aqwrap(object, wrapper, parent):
    r=Rewrapper()
    r._ugh=wrapper, object, parent
    return r
</t>
<t tx="ekr.20040104185913.236">class Rewrapper(ExtensionClass.Base):
	@others
</t>
<t tx="ekr.20040104185913.237">def __of__(self, parent):
    w, m, p = self._ugh
    return m.__of__(
        Acquisition.ImplicitAcquisitionWrapper(
            w, parent))
</t>
<t tx="ekr.20040104185913.238">def __getattr__(self, name):
    w, m, parent = self._ugh
    self=m.__of__(
        Acquisition.ImplicitAcquisitionWrapper(
            w, parent))
    return getattr(self, name)
</t>
<t tx="ekr.20040104185913.239">def __call__(self, *args, **kw):
    w, m, parent = self._ugh
    self=m.__of__(
        Acquisition.ImplicitAcquisitionWrapper(
            w, parent))
    return apply(self, args, kw)
</t>
<t tx="ekr.20040104185913.240">&lt;&lt; copyright &gt;&gt;

__doc__='''Objects that implement Permission-based roles.

$Id: PermissionRole.py,v 1.16 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.16 $'[11:-2]

_use_python_impl = 0

&lt;&lt; PermissionRole imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.241">import os
if os.environ.get("ZOPE_SECURITY_POLICY", None) == "PYTHON":
    _use_python_impl = 1
else:
    try:
        # C Optimization:
        from cAccessControl import rolesForPermissionOn, \
             PermissionRole, imPermissionRole, _what_not_even_god_should_do
    except ImportError:
        # Fall back to Python implementation.
        _use_python_impl = 1


if _use_python_impl:

    import sys

    from ExtensionClass import Base

    import string

    name_trans=filter(lambda c, an=string.letters+string.digits+'_': c not in an,
                      map(chr,range(256)))
    name_trans=string.maketrans(''.join(name_trans), '_'*len(name_trans))

</t>
<t tx="ekr.20040104185913.242">def rolesForPermissionOn(perm, object, default=('Manager',)):
    """Return the roles that have the given permission on the given object
    """
    im=imPermissionRole()
    im._p='_'+string.translate(perm, name_trans)+"_Permission"
    im._d=default
    return im.__of__(object)
</t>
<t tx="ekr.20040104185913.243">class PermissionRole(Base):
    """Implement permission-based roles.

    Under normal circumstances, our __of__ method will be
    called with an unwrapped object.  The result will then be called
    with a wrapped object, if the original object was wrapped.
    To deal with this, we have to create an intermediate object.

    """
	@others
</t>
<t tx="ekr.20040104185913.244">def __init__(self, name, default=('Manager',)):
    self.__name__=name
    self._p='_'+string.translate(name,name_trans)+"_Permission"
    self._d=default
</t>
<t tx="ekr.20040104185913.245">def __of__(self, parent, None=None, getattr=getattr):
    r=imPermissionRole()
    r._p=self._p
    r._pa=parent
    r._d=self._d
    p=getattr(parent, 'aq_inner', None)
    if p is not None:
        return r.__of__(p)
    else:
        return r
</t>
<t tx="ekr.20040104185913.246"># This is used when a permission maps explicitly to no permission.
_what_not_even_god_should_do=[]

class imPermissionRole(Base):
    """Implement permission-based roles
    """
	@others
</t>
<t tx="ekr.20040104185913.247">def __of__(self, parent,tt=type(()),st=type(''),getattr=getattr,None=None):
    obj=parent
    n=self._p
    r=None
    while 1:
        if hasattr(obj,n):
            roles=getattr(obj, n)

            if roles is None: return 'Anonymous',

            t=type(roles)

            if t is tt:
                # If we get a tuple, then we don't acquire
                if r is None: return roles
                return r+list(roles)

            if t is st:
                # We found roles set to a name.  Start over
                # with the new permission name.  If the permission
                # name is '', then treat as private!
                if roles:
                    if roles != n:
                        n=roles
                    # If we find a name that is the same as the
                    # current name, we just ignore it.
                    roles=None
                else:
                    return _what_not_even_god_should_do

            elif roles:
                if r is None: r=list(roles)
                else: r=r+list(roles)

        obj=getattr(obj, 'aq_inner', None)
        if obj is None: break
        obj=obj.aq_parent

    if r is None: r=self._d

    return r
</t>
<t tx="ekr.20040104185913.248"># The following methods are needed in the unlikely case that an unwrapped
# object is accessed:
def __getitem__(self, i):
    try:
        v=self._v
    except:
        v=self._v=self.__of__(self._pa)
        del self._pa

    return v[i]
</t>
<t tx="ekr.20040104185913.249">def __len__(self):
    try:
        v=self._v
    except:
        v=self._v=self.__of__(self._pa)
        del self._pa

    return len(v)
</t>
<t tx="ekr.20040104185913.250">def main():
    # The "main" program for this module

    import sys
    sys.path.append('/projects/_/ExtensionClass')

    from Acquisition import Implicit
    class I(Implicit):
        x__roles__=PermissionRole('x')
        y__roles__=PermissionRole('y')
        z__roles__=PermissionRole('z')
        def x(self): pass
        def y(self): pass
        def z(self): pass

    a=I()
    a.b=I()
    a.b.c=I()
    a.q=I()
    a.q._x_Permission=('foo',)
    a._y_Permission=('bar',)
    a._z_Permission=('zee',)
    a.b.c._y_Permission=('Manage',)
    a.b._z_Permission=['also']

    print a.x.__roles__, list(a.x.__roles__)
    print a.b.x.__roles__
    print a.b.c.x.__roles__
    print a.q.x.__roles__
    print a.b.q.x.__roles__
    print a.b.c.q.x.__roles__
    print

    print a.y.__roles__, list(a.y.__roles__)
    print a.b.y.__roles__
    print a.b.c.y.__roles__
    print a.q.y.__roles__
    print a.b.q.y.__roles__
    print a.b.c.q.y.__roles__
    print

    print a.z.__roles__, list(a.z.__roles__)
    print a.b.z.__roles__
    print a.b.c.z.__roles__
    print a.q.z.__roles__
    print a.b.q.z.__roles__
    print a.b.c.q.z.__roles__
    print
</t>
<t tx="ekr.20040104185913.251">&lt;&lt; copyright &gt;&gt;

"""Constant definitions for built-in Zope permissions"""

__version__='$Revision: 1.5.6.1 $'[11:-2]

access_contents_information='Access contents information'
add_database_methods='Add Database Methods'
add_documents_images_and_files='Add Documents, Images, and Files'
add_external_methods='Add External Methods'
add_folders='Add Folders'
add_mailhost_objects='Add MailHost objects'
add_python_scripts='Add Python Scripts'
add_user_folders='Add User Folders'
add_versions='Add Versions'
add_vocabularies='Add Vocabularies'
add_z_gadfly_database_connections='Add Z Gadfly Database Connections'
add_zcatalogs='Add ZCatalogs'
add_zope_tutorials='Add Zope Tutorials'
change_dtml_documents='Change DTML Documents'
change_dtml_methods='Change DTML Methods'
change_database_connections='Change Database Connections'
change_database_methods='Change Database Methods'
change_external_methods='Change External Methods'
change_images_and_files='Change Images and Files'
change_python_scripts='Change Python Scripts'
change_versions='Change Versions'
change_configuration='Change configuration'
change_permissions='Change permissions'
change_proxy_roles='Change proxy roles'
create_class_instances='Create class instances'
define_permissions='Define permissions'
delete_objects='Delete objects'
edit_factories='Edit Factories'
ftp_access='FTP access'
import_export_objects='Import/Export objects'
join_leave_versions='Join/leave Versions'
manage_vocabulary='Manage Vocabulary'
manage_zclasses='Manage Z Classes'
manage_zcatalog_entries='Manage ZCatalog Entries'
manage_zcatalog_indexes='Manage ZCatalogIndex Entries'
manage_properties='Manage properties'
manage_users='Manage users'
open_close_database_connection='Open/Close Database Connection'
open_close_database_connections='Open/Close Database Connections'
query_vocabulary='Query Vocabulary'
save_discard_version_changes='Save/discard Version changes'
search_zcatalog='Search ZCatalog'
take_ownership='Take ownership'
test_database_connections='Test Database Connections'
undo_changes='Undo changes'
use_database_methods='Use Database Methods'
use_factories='Use Factories'
use_mailhost_services='Use mailhost services'
view='View'
view_history='View History'
view_management_screens='View management screens'
copy_or_move='Copy or Move'</t>
<t tx="ekr.20040104185913.252">&lt;&lt; copyright &gt;&gt;

"""Access control support"""

__version__='$Revision: 1.55.6.1 $'[11:-2]

&lt;&lt; Role imports &gt;&gt;

ListType=type([])

DEFAULTMAXLISTUSERS=250

@others
</t>
<t tx="ekr.20040104185913.253">from Globals import DTMLFile, MessageDialog, Dictionary
from Acquisition import Implicit, Acquired, aq_get
import Globals, ExtensionClass, PermissionMapping, Products
from Permission import Permission
from App.Common import aq_base
from cgi import escape</t>
<t tx="ekr.20040104185913.254">def _isBeingUsedAsAMethod(self):
    return aq_get(self, '_isBeingUsedAsAMethod_', 0)
</t>
<t tx="ekr.20040104185913.255">def _isNotBeingUsedAsAMethod(self):
    return not aq_get(self, '_isBeingUsedAsAMethod_', 0)
</t>
<t tx="ekr.20040104185913.256">class RoleManager(ExtensionClass.Base, PermissionMapping.RoleManager):
    """An obect that has configurable permissions"""
	&lt;&lt; class RoleManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.257">__ac_permissions__=(
    ('Change permissions',
     ('manage_access', 'permission_settings',
      'ac_inherited_permissions',
      'manage_roleForm', 'manage_role',
      'manage_acquiredForm', 'manage_acquiredPermissions',
      'manage_permissionForm', 'manage_permission',
      'manage_changePermissions', 'permissionsOfRole',
      'rolesOfPermission', 'acquiredRolesAreUsedBy',
      'manage_defined_roles', 'userdefined_roles',
      'manage_listLocalRoles', 'manage_editLocalRoles',
      'manage_setLocalRoles', 'manage_addLocalRoles',
      'manage_delLocalRoles'
      )),
    )

manage_options=(
    {'label':'Security', 'action':'manage_access',
     'help':('OFSP','Security.stx'),
     'filter': _isNotBeingUsedAsAMethod,
     },
    {'label':'Define Permissions', 'action':'manage_access',
     'help':('OFSP','Security_Define-Permissions.stx'),
     'filter': _isBeingUsedAsAMethod,
     },
    )

__ac_roles__=('Manager', 'Owner', 'Anonymous', 'Authenticated')

permissionMappingPossibleValues=Acquired

#------------------------------------------------------------

</t>
<t tx="ekr.20040104185913.258">def ac_inherited_permissions(self, all=0):
    # Get all permissions not defined in ourself that are inherited
    # This will be a sequence of tuples with a name as the first item and
    # an empty tuple as the second.
    d={}
    perms=self.__ac_permissions__
    for p in perms: d[p[0]]=None

    r=gather_permissions(self.__class__, [], d)
    if all:
        if hasattr(self, '_subobject_permissions'):
            for p in self._subobject_permissions():
                pname=p[0]
                if not d.has_key(pname):
                    d[pname]=1
                    r.append(p)

        r=list(perms)+r
        r.sort()

    return tuple(r)
</t>
<t tx="ekr.20040104185913.259">def permission_settings(self):
    """Return user-role permission settings
    """
    result=[]
    valid=self.valid_roles()
    indexes=range(len(valid))
    ip=0
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        p=Permission(name,value,self)
        roles=p.getRoles(default=[])
        d={'name': name,
           'acquire': type(roles) is ListType and 'CHECKED' or '',
           'roles': map(
               lambda ir, roles=roles, valid=valid, ip=ip:
               {
                   'name': "p%dr%d" % (ip,ir),
                   'checked': (valid[ir] in roles) and 'CHECKED' or '',
                   },
               indexes)
           }
        ip=ip+1
        result.append(d)
    return result
</t>
<t tx="ekr.20040104185913.260">manage_roleForm=DTMLFile('dtml/roleEdit', globals(),
                         management_view='Security',
                         help_topic='Security_Manage-Role.stx',
                         help_product='OFSP')

def manage_role(self, role_to_manage, permissions=[], REQUEST=None):
    "Change the permissions given to the given role"
    self._isBeingUsedAsAMethod(REQUEST, 0)
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        p=Permission(name,value,self)
        p.setRole(role_to_manage, name in permissions)

    if REQUEST is not None: return self.manage_access(REQUEST)
</t>
<t tx="ekr.20040104185913.261">manage_acquiredForm=DTMLFile('dtml/acquiredEdit', globals(),
                             management_view='Security',
                             help_topic='Security_Manage-Acquisition.stx',
                             help_product='OFSP')

def manage_acquiredPermissions(self, permissions=[], REQUEST=None):
    "Change the permissions that acquire"
    self._isBeingUsedAsAMethod(REQUEST, 0)
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        p=Permission(name,value,self)
        roles=p.getRoles()
        if roles is None: continue
        if name in permissions: p.setRoles(list(roles))
        else:                   p.setRoles(tuple(roles))

    if REQUEST is not None: return self.manage_access(REQUEST)
</t>
<t tx="ekr.20040104185913.262">manage_permissionForm=DTMLFile('dtml/permissionEdit', globals(),
                               management_view='Security',
                               help_topic='Security_Manage-Permission.stx',
                               help_product='OFSP')

def manage_permission(self, permission_to_manage,
                      roles=[], acquire=0, REQUEST=None):
    """Change the settings for the given permission

    If optional arg acquire is true, then the roles for the permission
    are acquired, in addition to the ones specified, otherwise the
    permissions are restricted to only the designated roles."""
    self._isBeingUsedAsAMethod(REQUEST, 0)
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        if name==permission_to_manage:
            p=Permission(name,value,self)
            if acquire: roles=list(roles)
            else: roles=tuple(roles)
            p.setRoles(roles)
            if REQUEST is not None: return self.manage_access(REQUEST)
            return

    raise 'Invalid Permission', (
        "The permission &lt;em&gt;%s&lt;/em&gt; is invalid." %
            escape(permission_to_manage))
</t>
<t tx="ekr.20040104185913.263">_normal_manage_access=DTMLFile('dtml/access', globals())

_method_manage_access=DTMLFile('dtml/methodAccess', globals())

def manage_access(self, REQUEST, **kw):
    "Return an interface for making permissions settings"
    if hasattr(self, '_isBeingUsedAsAMethod') and \
       self._isBeingUsedAsAMethod():
        return apply(self._method_manage_access,(), kw)
    else:
        return apply(self._normal_manage_access,(), kw)
</t>
<t tx="ekr.20040104185913.264">def manage_changePermissions(self, REQUEST):
    "Change all permissions settings, called by management screen"
    self._isBeingUsedAsAMethod(REQUEST, 0)
    valid_roles=self.valid_roles()
    indexes=range(len(valid_roles))
    have=REQUEST.has_key
    permissions=self.ac_inherited_permissions(1)
    fails = []
    for ip in range(len(permissions)):
        roles=[]
        for ir in indexes:
            if have("p%dr%d" % (ip,ir)): roles.append(valid_roles[ir])
        name, value = permissions[ip][:2]
        try:
            p=Permission(name,value,self)
            if not have('a%d' % ip): roles=tuple(roles)
            p.setRoles(roles)
        except:
            fails.append(name)

    if fails:
        return MessageDialog(title="Warning!",
                             message="Some permissions had errors: "
                               + ', '.join(fails),
                             action='manage_access')
    return MessageDialog(
        title  ='Success!',
        message='Your changes have been saved',
        action ='manage_access')
</t>
<t tx="ekr.20040104185913.265">def permissionsOfRole(self, role):
    "used by management screen"
    r=[]
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        p=Permission(name,value,self)
        roles=p.getRoles()
        r.append({'name': name,
                  'selected': role in roles and 'SELECTED' or '',
                  })
    return r
</t>
<t tx="ekr.20040104185913.266">def rolesOfPermission(self, permission):
    "used by management screen"
    valid_roles=self.valid_roles()
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        if name==permission:
            p=Permission(name,value,self)
            roles=p.getRoles()
            return map(
                lambda role, roles=roles:
                {'name': role,
                 'selected': role in roles and 'SELECTED' or '',
                 },
                valid_roles)

    raise 'Invalid Permission', (
        "The permission &lt;em&gt;%s&lt;/em&gt; is invalid." % escape(permission))
</t>
<t tx="ekr.20040104185913.267">def acquiredRolesAreUsedBy(self, permission):
    "used by management screen"
    for p in self.ac_inherited_permissions(1):
        name, value = p[:2]
        if name==permission:
            p=Permission(name,value,self)
            roles=p.getRoles()
            return type(roles) is ListType and 'CHECKED' or ''

    raise 'Invalid Permission', (
        "The permission &lt;em&gt;%s&lt;/em&gt; is invalid." % escape(permission))
</t>
<t tx="ekr.20040104185913.268"># Local roles support
# -------------------
#
# Local roles allow a user to be given extra roles in the context
# of a particular object (and its children). When a user is given
# extra roles in a particular object, an entry for that user is made
# in the __ac_local_roles__ dict containing the extra roles.

__ac_local_roles__=None

manage_listLocalRoles=DTMLFile('dtml/listLocalRoles', globals(),
                               management_view='Security',
                               help_topic='Security_Local-Roles.stx',
                               help_product='OFSP')

manage_editLocalRoles=DTMLFile('dtml/editLocalRoles', globals(),
                               management_view='Security',
                               help_topic='Security_User-Local-Roles.stx',
                               help_product='OFSP')

def has_local_roles(self):
    dict=self.__ac_local_roles__ or {}
    return len(dict)
</t>
<t tx="ekr.20040104185913.269">def get_local_roles(self):
    dict=self.__ac_local_roles__ or {}
    keys=dict.keys()
    keys.sort()
    info=[]
    for key in keys:
        value=tuple(dict[key])
        info.append((key, value))
    return tuple(info)
</t>
<t tx="ekr.20040104185913.270">def users_with_local_role(self, role):
    got = {}
    for user, roles in self.get_local_roles():
        if role in roles:
            got[user] = 1
    return got.keys()
</t>
<t tx="ekr.20040104185913.271">def get_valid_userids(self):
    item=self
    dict={}
    _notfound = []
    while 1:
        aclu = getattr(aq_base(item), '__allow_groups__', _notfound)
        if aclu is not _notfound:
            mlu = getattr(aclu, 'maxlistusers', _notfound)
            if type(mlu) != type(1): mlu = DEFAULTMAXLISTUSERS
            if mlu &lt; 0: raise OverflowError
            un = getattr(aclu, 'user_names', _notfound)
            if un is not _notfound:
                unl = un()
                # maxlistusers of 0 is list all
                if len(unl) &gt; mlu and mlu != 0:
                    raise OverflowError
                for name in un():
                    dict[name]=1
        item = getattr(item, 'aq_parent', _notfound)
        if item is _notfound:
            break
    keys=dict.keys()
    keys.sort()
    return tuple(keys)
</t>
<t tx="ekr.20040104185913.272">def get_local_roles_for_userid(self, userid):
    dict=self.__ac_local_roles__ or {}
    return tuple(dict.get(userid, []))
</t>
<t tx="ekr.20040104185913.273">def manage_addLocalRoles(self, userid, roles, REQUEST=None):
    """Set local roles for a user."""
    if not roles:
        raise ValueError, 'One or more roles must be given!'
    dict=self.__ac_local_roles__ or {}
    local_roles = list(dict.get(userid, []))
    for r in roles:
        if r not in local_roles:
            local_roles.append(r)
    dict[userid] = local_roles
    self.__ac_local_roles__=dict
    if REQUEST is not None:
        stat='Your changes have been saved.'
        return self.manage_listLocalRoles(self, REQUEST, stat=stat)
</t>
<t tx="ekr.20040104185913.274">def manage_setLocalRoles(self, userid, roles, REQUEST=None):
    """Set local roles for a user."""
    if not roles:
        raise ValueError, 'One or more roles must be given!'
    dict=self.__ac_local_roles__ or {}
    dict[userid]=roles
    self.__ac_local_roles__=dict
    if REQUEST is not None:
        stat='Your changes have been saved.'
        return self.manage_listLocalRoles(self, REQUEST, stat=stat)
</t>
<t tx="ekr.20040104185913.275">def manage_delLocalRoles(self, userids, REQUEST=None):
    """Remove all local roles for a user."""
    dict=self.__ac_local_roles__ or {}
    for userid in userids:
        if dict.has_key(userid):
            del dict[userid]
    self.__ac_local_roles__=dict
    if REQUEST is not None:
        stat='Your changes have been saved.'
        return self.manage_listLocalRoles(self, REQUEST, stat=stat)
</t>
<t tx="ekr.20040104185913.276">#------------------------------------------------------------

access_debug_info__roles__=()
def access_debug_info(self):
    "Return debug info"
    clas=class_attrs(self)
    inst=instance_attrs(self)
    data=[]
    _add=data.append
    for key, value in inst.items():
        if key.find('__roles__') &gt;= 0:
            _add({'name': key, 'value': value, 'class': 0})
        if hasattr(value, '__roles__'):
            _add({'name': '%s.__roles__' % key, 'value': value.__roles__,
                  'class': 0})
    for key, value in clas.items():
        if key.find('__roles__') &gt;= 0:
            _add({'name': key, 'value': value, 'class' : 1})
        if hasattr(value, '__roles__'):
            _add({'name': '%s.__roles__' % key, 'value': value.__roles__,
                  'class': 1})
    return data
</t>
<t tx="ekr.20040104185913.277">def valid_roles(self):
    "Return list of valid roles"
    obj=self
    dict={}
    dup =dict.has_key
    x=0
    while x &lt; 100:
        if hasattr(obj, '__ac_roles__'):
            roles=obj.__ac_roles__
            for role in roles:
                if not dup(role):
                    dict[role]=1
        if not hasattr(obj, 'aq_parent'):
            break
        obj=obj.aq_parent
        x=x+1
    roles=dict.keys()
    roles.sort()
    return tuple(roles)
</t>
<t tx="ekr.20040104185913.278">def validate_roles(self, roles):
    "Return true if all given roles are valid"
    valid=self.valid_roles()
    for role in roles:
        if role not in valid:
            return 0
    return 1
</t>
<t tx="ekr.20040104185913.279">def userdefined_roles(self):
    "Return list of user-defined roles"
    roles=list(self.__ac_roles__)
    for role in classattr(self.__class__,'__ac_roles__'):
        try:    roles.remove(role)
        except: pass
    return tuple(roles)
</t>
<t tx="ekr.20040104185913.280">def manage_defined_roles(self,submit=None,REQUEST=None):
    """Called by management screen."""

    if submit=='Add Role':
        role=reqattr(REQUEST, 'role')
        return self._addRole(role, REQUEST)

    if submit=='Delete Role':
        roles=reqattr(REQUEST, 'roles')
        return self._delRoles(roles, REQUEST)

    return self.manage_access(REQUEST)
</t>
<t tx="ekr.20040104185913.281">def _addRole(self, role, REQUEST=None):
    if not role:
        return MessageDialog(
               title  ='Incomplete',
               message='You must specify a role name',
               action ='manage_access')
    if role in self.__ac_roles__:
        return MessageDialog(
               title  ='Role Exists',
               message='The given role is already defined',
               action ='manage_access')
    data=list(self.__ac_roles__)
    data.append(role)
    self.__ac_roles__=tuple(data)
    if REQUEST is not None:
        return self.manage_access(REQUEST)
</t>
<t tx="ekr.20040104185913.282">def _delRoles(self, roles, REQUEST):
    if not roles:
        return MessageDialog(
               title  ='Incomplete',
               message='You must specify a role name',
               action ='manage_access')
    data=list(self.__ac_roles__)
    for role in roles:
        try:    data.remove(role)
        except: pass
    self.__ac_roles__=tuple(data)
    if REQUEST is not None:
        return self.manage_access(REQUEST)
</t>
<t tx="ekr.20040104185913.283">def _has_user_defined_role(self, role):
    return role in self.__ac_roles__
</t>
<t tx="ekr.20040104185913.284"># Compatibility names only!!

smallRolesWidget=selectedRoles=aclAChecked=aclPChecked=aclEChecked=''
validRoles=valid_roles
#manage_rolesForm=manage_access

def manage_editRoles(self,REQUEST,acl_type='A',acl_roles=[]):
    pass
</t>
<t tx="ekr.20040104185913.285">def _setRoles(self,acl_type,acl_roles):
    pass
</t>
<t tx="ekr.20040104185913.286">def possible_permissions(self):
    d={}
    for p in Products.__ac_permissions__:
        d[p[0]]=1
    for p in self.aq_acquire('_getProductRegistryData')('ac_permissions'):
        d[p[0]]=1

    for p in self.ac_inherited_permissions(1):
        d[p[0]]=1

    d=d.keys()
    d.sort()

    return d
</t>
<t tx="ekr.20040104185913.287">Globals.default__class_init__(RoleManager)


def reqattr(request, attr):
    try:    return request[attr]
    except: return None
</t>
<t tx="ekr.20040104185913.288">def classattr(cls, attr):
    if hasattr(cls, attr):
        return getattr(cls, attr)
    try:    bases=cls.__bases__
    except: bases=()
    for base in bases:
        if classattr(base, attr):
            return attr
    return None
</t>
<t tx="ekr.20040104185913.289">def instance_dict(inst):
    try:    return inst.__dict__
    except: return {}
</t>
<t tx="ekr.20040104185913.290">def class_dict(_class):
    try:    return _class.__dict__
    except: return {}
</t>
<t tx="ekr.20040104185913.291">def instance_attrs(inst):
    return instance_dict(inst)
</t>
<t tx="ekr.20040104185913.292">def class_attrs(inst, _class=None, data=None):
    if _class is None:
        _class=inst.__class__
        data={}

    clas_dict=class_dict(_class)
    inst_dict=instance_dict(inst)
    inst_attr=inst_dict.has_key
    for key, value in clas_dict.items():
        if not inst_attr(key):
            data[key]=value
    for base in _class.__bases__:
        data=class_attrs(inst, base, data)
    return data
</t>
<t tx="ekr.20040104185913.293">def gather_permissions(klass, result, seen):
    for base in klass.__bases__:
        if base.__dict__.has_key('__ac_permissions__'):
            for p in base.__ac_permissions__:
                name=p[0]
                if seen.has_key(name): continue
                result.append((name, ()))
                seen[name]=None
        gather_permissions(base, result, seen)
    return result
</t>
<t tx="ekr.20040104185913.294">&lt;&lt; copyright &gt;&gt;

&lt;&lt; SecurityInfo docstring &gt;&gt;

__version__='$Revision$'[11:-2]

import Acquisition, PermissionRole, sys
from zLOG import LOG, WARNING

# Security constants - these are imported into the AccessControl
# namespace and can be referenced as AccessControl.PUBLIC etc.

ACCESS_NONE    = PermissionRole._what_not_even_god_should_do
ACCESS_PRIVATE = ()
ACCESS_PUBLIC  = None

_marker = []

@others</t>
<t tx="ekr.20040104185913.295">"""SecurityInfo objects and access control constants.

   SecurityInfo objects are used in class definitions to allow
   a declarative style of associating access control information
   with class attributes.

   More information on using SecurityInfo and guide to Zope security
   for developers can be found in the dev.zope.org "Declarative Security"
   project:

   http://dev.zope.org/Wikis/DevSite/Projects/DeclarativeSecurity

   While SecurityInfo objects largely remove the need for Python
   programmers to care about the underlying implementation, there
   are several constants defined that should be used by code that
   must set __roles__ attributes directly. (the constants are also
   accessible from the AccessControl namespace). The defined access
   control constants and their meanings are:

   ACCESS_PUBLIC:  accessible from restricted code and possibly
                   through the web (if object has a docstring)

   ACCESS_PRIVATE: accessible only from python code

   ACCESS_NONE:    no access

"""</t>
<t tx="ekr.20040104185913.296">class SecurityInfo(Acquisition.Implicit):
    """Encapsulate security information."""
	__security_info__ = 1
	__roles__ = ACCESS_PRIVATE
	@others
</t>
<t tx="ekr.20040104185913.298">def __init__(self):
    self.names = {}
    self.roles = {}
</t>
<t tx="ekr.20040104185913.299">def _setaccess(self, names, access):
    # Empty names list sets access to the class itself, named ''
    if not len(names):
        names = ('',)
    for name in names:
        if self.names.get(name, access) != access:
            LOG('SecurityInfo', WARNING, 'Conflicting security '
                'declarations for "%s"' % name)
            self._warnings = 1
        self.names[name] = access
</t>
<t tx="ekr.20040104185913.300">declarePublic__roles__=ACCESS_PRIVATE
def declarePublic(self, *names):
    """Declare names to be publicly accessible."""
    self._setaccess(names, ACCESS_PUBLIC)
</t>
<t tx="ekr.20040104185913.301">declarePrivate__roles__=ACCESS_PRIVATE
def declarePrivate(self, *names):
    """Declare names to be inaccessible to restricted code."""
    self._setaccess(names, ACCESS_PRIVATE)
</t>
<t tx="ekr.20040104185913.302">declareProtected__roles__=ACCESS_PRIVATE
def declareProtected(self, permission_name, *names):
    """Declare names to be associated with a permission."""
    self._setaccess(names, permission_name)
</t>
<t tx="ekr.20040104185913.303">declareObjectPublic__roles__=ACCESS_PRIVATE
def declareObjectPublic(self):
    """Declare the object to be publicly accessible."""
    self._setaccess((), ACCESS_PUBLIC)
</t>
<t tx="ekr.20040104185913.304">declareObjectPrivate__roles__=ACCESS_PRIVATE
def declareObjectPrivate(self):
    """Declare the object to be inaccessible to restricted code."""
    self._setaccess((), ACCESS_PRIVATE)
</t>
<t tx="ekr.20040104185913.305">declareObjectProtected__roles__=ACCESS_PRIVATE
def declareObjectProtected(self, permission_name):
    """Declare the object to be associated with a permission."""
    self._setaccess((), permission_name)
</t>
<t tx="ekr.20040104185913.306">setPermissionDefault__roles__=ACCESS_PRIVATE
def setPermissionDefault(self, permission_name, roles):
    """Declare default roles for a permission"""
    rdict = {}
    for role in roles:
        rdict[role] = 1
    if self.roles.get(permission_name, rdict) != rdict:
        LOG('SecurityInfo', WARNING, 'Conflicting default role'
            'declarations for permission "%s"' % permission_name)
        self._warnings = 1
    self.roles[permission_name] = rdict
</t>
<t tx="ekr.20040104185913.307">setDefaultAccess__roles__=ACCESS_PRIVATE
def setDefaultAccess(self, access):
    """Declare default attribute access policy.

    This should be a boolean value, a map of attribute names to
    booleans, or a callable (name, value) -&gt; boolean.
    """
    if type(access) == type(''):
        access = access.lower()
        if access == 'allow':
            access = 1
        elif access == 'deny':
            access = 0
        else:
            raise ValueError, "'allow' or 'deny' expected"
    self.access = access
</t>
<t tx="ekr.20040104185913.308">class ClassSecurityInfo(SecurityInfo):
    """Encapsulate security information for class objects."""
	__roles__ = ACCESS_PRIVATE
	apply__roles__ = ACCESS_PRIVATE
	@others
</t>
<t tx="ekr.20040104185913.310">def apply(self, classobj):
    """Apply security information to the given class object."""

    dict = classobj.__dict__

    # Check the class for an existing __ac_permissions__ and
    # incorporate that if present to support older classes or
    # classes that haven't fully switched to using SecurityInfo.
    if dict.has_key('__ac_permissions__'):
        for item in dict['__ac_permissions__']:
            permission_name = item[0]
            self._setaccess(item[1], permission_name)
            if len(item) &gt; 2:
                self.setPermissionDefault(permission_name, item[2])

    # Set __roles__ for attributes declared public or private.
    # Collect protected attribute names in ac_permissions.
    ac_permissions = {}
    for name, access in self.names.items():
        if access in (ACCESS_PRIVATE, ACCESS_PUBLIC, ACCESS_NONE):
            dict['%s__roles__' % name] = access
        else:
            if not ac_permissions.has_key(access):
                ac_permissions[access] = []
            ac_permissions[access].append(name)

    # Now transform our nested dict structure into the nested tuple
    # structure expected of __ac_permissions__ attributes and set
    # it on the class object.
    getRoles = self.roles.get
    __ac_permissions__ = []
    permissions = ac_permissions.items()
    permissions.sort()
    for permission_name, names in permissions:
        roles = getRoles(permission_name, ())
        if len(roles):
            entry = (permission_name, tuple(names), tuple(roles.keys()))
        else:
            entry = (permission_name, tuple(names))
        __ac_permissions__.append(entry)
    dict['__ac_permissions__'] = tuple(__ac_permissions__)

    # Take care of default attribute access policy
    access = getattr(self, 'access', _marker)
    if access is not _marker:
        dict['__allow_access_to_unprotected_subobjects__'] = access

    if getattr(self, '_warnings', None):
        LOG('SecurityInfo', WARNING, 'Class "%s" had conflicting '
            'security declarations' % classobj.__name__)
</t>
<t tx="ekr.20040104185913.311">class ClassSecurityInformation(ClassSecurityInfo):
	# Default policy is disallow
	access = 0</t>
<t tx="ekr.20040104185913.313">_moduleSecurity = {}
_appliedModuleSecurity = {}

def secureModule(mname, *imp):
    modsec = _moduleSecurity.get(mname, None)
    if modsec is None:
        return
    del _moduleSecurity[mname]

    if len(imp):
        apply(__import__, (mname,) + tuple(imp))
    module = sys.modules[mname]
    modsec.apply(module.__dict__)
    _appliedModuleSecurity[mname] = modsec
    return module
</t>
<t tx="ekr.20040104185913.314">def ModuleSecurityInfo(module_name=None):
    if module_name is not None:
        modsec = _moduleSecurity.get(module_name, None)
        if modsec is not None:
            return modsec
        modsec = _appliedModuleSecurity.get(module_name, None)
        if modsec is not None:
            # Move security info back to to-apply dict (needed for product
            # refresh). Also invoke this check for parent packages already
            # applied
            del _appliedModuleSecurity[module_name]
            _moduleSecurity[module_name] = modsec
            dot = module_name.rfind('.')
            if dot &gt; 0:
                ModuleSecurityInfo(module_name[:dot])
            return modsec
        dot = module_name.rfind('.')
        if dot &gt; 0:
            # If the module is in a package, recursively make sure
            # there are security declarations for the package steps
            # leading to the module
            modname = module_name[dot + 1:]
            pmodsec = ModuleSecurityInfo(module_name[:dot])
            if not pmodsec.names.has_key(modname):
                pmodsec.declarePublic(modname)
    return _ModuleSecurityInfo(module_name)
</t>
<t tx="ekr.20040104185913.315">class _ModuleSecurityInfo(SecurityInfo):
    """Encapsulate security information for modules."""
	__roles__ = ACCESS_PRIVATE
	@others
</t>
<t tx="ekr.20040104185913.317">def __init__(self, module_name=None):
    self.names = {}
    if module_name is not None:
        global _moduleSecurity
        _moduleSecurity[module_name] = self
</t>
<t tx="ekr.20040104185913.318">__call____roles__ = ACCESS_PRIVATE
def __call__(self, name, value):
    """Callback for __allow_access_to_unprotected_subobjects__ hook."""
    access = self.names.get(name, _marker)
    if access is not _marker:
        return access == ACCESS_PUBLIC

    return getattr(self, 'access', 0)
</t>
<t tx="ekr.20040104185913.319">apply__roles__ = ACCESS_PRIVATE
def apply(self, dict):
    """Apply security information to the given module dict."""

    # Start with default attribute access policy
    access = getattr(self, 'access', _marker)
    if access is not _marker or len(self.names):
        dict['__allow_access_to_unprotected_subobjects__'] = self

    if getattr(self, '_warnings', None):
        LOG('SecurityInfo', WARNING, 'Module "%s" had conflicting '
            'security declarations' % dict['__name__'])
</t>
<t tx="ekr.20040104185913.320">declareProtected__roles__=ACCESS_PRIVATE
def declareProtected(self, permission_name, *names):
    """Cannot declare module names protected."""
    pass
</t>
<t tx="ekr.20040104185913.321">declareObjectProtected__roles__=ACCESS_PRIVATE
def declareObjectProtected(self, permission_name):
    """Cannot declare module protected."""
    pass
</t>
<t tx="ekr.20040104185913.322">setDefaultRoles__roles__=ACCESS_PRIVATE
def setDefaultRoles(self, permission_name, roles):
    """Cannot set default roles for permissions in a module."""
    pass
</t>
<t tx="ekr.20040104185913.323"># Handy little utility functions

def allow_module(module_name):
    """Allow a module and all its contents to be used from a
    restricted Script. The argument module_name may be a simple
    or dotted module or package name. Note that if a package
    path is given, all modules in the path will be available."""
    ModuleSecurityInfo(module_name).setDefaultAccess(1)
    dot = module_name.find('.')
    while dot &gt; 0:
        ModuleSecurityInfo(module_name[:dot]).setDefaultAccess(1)
        dot = module_name.find('.', dot + 1)
</t>
<t tx="ekr.20040104185913.324">def allow_class(Class):
    """Allow a class and all of its methods to be used from a
    restricted Script.  The argument Class must be a class."""
    Class._security = sec = ClassSecurityInfo()
    sec.declareObjectPublic()
    sec.setDefaultAccess(1)
    sec.apply(Class)
    from Globals import InitializeClass
    InitializeClass(Class)
</t>
<t tx="ekr.20040104185913.325">&lt;&lt; copyright &gt;&gt;

__doc__='''short description

$Id: SecurityManagement.py,v 1.7 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.7 $'[11:-2]

@others
</t>
<t tx="ekr.20040104185913.327">def getSecurityManager():
    """Get a security manager, for the current thread.
    """
    thread_id=get_ident()
    manager=_managers.get(thread_id, None)
    if manager is None:
        manager=SecurityManager(
            thread_id,
            SecurityContext(SpecialUsers.nobody))
        _managers[thread_id]=manager

    return manager
</t>
<t tx="ekr.20040104185913.328">import SpecialUsers
from SecurityManager import SecurityManager
try:    import thread
except: get_ident=lambda: 0
else:   get_ident=thread.get_ident

_managers={}

def newSecurityManager(request, user):
    """Set up a new security context for a request for a user
    """
    thread_id=get_ident()
    _managers[thread_id]=SecurityManager(
        thread_id,
        SecurityContext(user),
        )
</t>
<t tx="ekr.20040104185913.329">def noSecurityManager():
    try: del _managers[get_ident()]
    except: pass
</t>
<t tx="ekr.20040104185913.330">def setSecurityPolicy(aSecurityPolicy):
    """Set the system default security policy.

    This method should only be caused by system startup code. It should
    never, for example, be called during a web request.
    """
    SecurityManager.setSecurityPolicy(aSecurityPolicy)
</t>
<t tx="ekr.20040104185913.331">class SecurityContext:
    """The security context is an object used internally to the security
    machinery. It captures data about the current security context.
    """
	@others
</t>
<t tx="ekr.20040104185913.332">def __init__(self, user):
    self.stack=[]
    self.user=user
    self.objectCache = {}
</t>
<t tx="ekr.20040104185913.333">&lt;&lt; copyright &gt;&gt;

__doc__='''short description

$Id: SecurityManager.py,v 1.13 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.13 $'[11:-2]

import ZopeSecurityPolicy, os

_noroles = ZopeSecurityPolicy._noroles

try: max_stack_size=int(os.environ.get('Z_MAX_STACK_SIZE','100'))
except: max_stack_size=100

if os.environ.has_key("ZSP_OWNEROUS_SKIP"): ownerous=0
else: ownerous=1
if os.environ.has_key("ZSP_AUTHENTICATION_SKIP"): authenticated=0
else: authenticated=1

_defaultPolicy=ZopeSecurityPolicy.ZopeSecurityPolicy(ownerous=ownerous,
    authenticated=authenticated)

@others
</t>
<t tx="ekr.20040104185913.335">def setSecurityPolicy(aSecurityPolicy):
    """Set the system default security policy.

    This method should only be caused by system startup code. It should
    never, for example, be called during a web request.
    """
    global _defaultPolicy
    last=_defaultPolicy
    _defaultPolicy=aSecurityPolicy
    return last
</t>
<t tx="ekr.20040104185913.336">class SecurityManager:
    """A security manager provides methods for checking access and managing
    executable context and policies
    """
	&lt;&lt; class SecurityManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.337">__allow_access_to_unprotected_subobjects__ = {
    'validate': 1, 'validateValue': 1, 'checkPermission': 1,
    'getUser': 1, 'calledByExecutable': 1
    }

</t>
<t tx="ekr.20040104185913.338">def __init__(self, thread_id, context):
    self._thread_id=thread_id
    self._context=context
    self._policy=_defaultPolicy
</t>
<t tx="ekr.20040104185913.339">def validate(self, accessed=None, container=None, name=None, value=None,
             roles=_noroles):
    """Validate access.

    Arguments:

    accessed -- the object that was being accessed

    container -- the object the value was found in

    name -- The name used to access the value

    value -- The value retrieved though the access.

    roles -- The roles of the object if already known.

    The arguments may be provided as keyword arguments. Some of these
    arguments may be ommitted, however, the policy may reject access
    in some cases when arguments are ommitted.  It is best to provide
    all the values possible.
    """
    policy=self._policy
    if roles is _noroles:
        return policy.validate(accessed, container, name, value,
                               self._context)
    else:
        return policy.validate(accessed, container, name, value,
                               self._context, roles)
</t>
<t tx="ekr.20040104185913.340">def DTMLValidate(self, accessed=None, container=None, name=None,
                value=None, md=None):

    """Validate access.
    * THIS EXISTS FOR DTML COMPATIBILITY *

    Arguments:

    accessed -- the object that was being accessed

    container -- the object the value was found in

    name -- The name used to access the value

    value -- The value retrieved though the access.

    md -- multidict for DTML (ignored)

    The arguments may be provided as keyword arguments. Some of these
    arguments may be ommitted, however, the policy may reject access
    in some cases when arguments are ommitted.  It is best to provide
    all the values possible.

    """
    policy=self._policy
    return policy.validate(accessed, container, name, value,
                           self._context)
</t>
<t tx="ekr.20040104185913.341">def validateValue(self, value, roles=_noroles):
    """Convenience for common case of simple value validation.
    """
    policy=self._policy
    if roles is _noroles:
        return policy.validate(None, None, None, value,
                               self._context)
    else:
        return policy.validate(None, None, None, value,
                               self._context, roles)
</t>
<t tx="ekr.20040104185913.342">def checkPermission(self, permission, object):
    """Check whether the security context allows the given permission on
    the given object.

    Arguments:

    permission -- A permission name

    object -- The object being accessed according to the permission
    """
    policy=self._policy
    return policy.checkPermission(permission, object,
                                  self._context)
</t>
<t tx="ekr.20040104185913.343">def addContext(self, anExecutableObject,
               getattr=getattr):
    """Add an ExecutableObject to the current security
    context. Optionally, add a new SecurityPolicy as well.
    """
    stack=self._context.stack
    if len(stack) &gt; max_stack_size:
        raise SystemError, 'Excessive recursion'
    stack.append(anExecutableObject)
    p=getattr(anExecutableObject, '_customSecurityPolicy', None)
    if p is not None:
        p=p()
    else:
        p=_defaultPolicy
    self._policy=p
</t>
<t tx="ekr.20040104185913.344">def removeContext(self, anExecutableObject,
                  getattr=getattr):
    """Remove an ExecutableObject, and optionally, a
    SecurityPolicy, from the current security context.
    """
    stack=self._context.stack
    if not stack: return
    top=stack[-1]
    if top is anExecutableObject:
        del stack[-1]
    else:
        indexes=range(len(stack))
        indexes.reverse()
        for i in indexes:
            top=stack[i]
            if top is anExecutableObject:
                del stack[i:]
                break
        else:
            return

    if stack:
        top=stack[-1]
        p=getattr(top, '_customSecurityPolicy', None)
        if p is not None:
            p=p()
        else:
            p=_defaultPolicy
        self._policy=p
    else:
        self._policy=_defaultPolicy
</t>
<t tx="ekr.20040104185913.345">def getUser(self):
    """Get the current authenticated user"""
    return self._context.user
</t>
<t tx="ekr.20040104185913.346">def calledByExecutable(self):
    """Return a boolean value indicating if this context was called
    by an executable"""
    return len(self._context.stack)
</t>
<t tx="ekr.20040104185913.347">try:
    #raise ImportError # uncomment to disable C optimization
    import os
    if os.environ.get("ZOPE_SECURITY_POLICY", None) == "PYTHON":
        raise ImportError # :)
    from cAccessControl import SecurityManager as cSecurityManager
except ImportError:
    pass
else:
    class SecurityManager(cSecurityManager, SecurityManager):
        """A security manager provides methods for checking access and managing
        executable context and policies
        """
</t>
<t tx="ekr.20040104185913.348">&lt;&lt; copyright &gt;&gt;

__doc__='''Collect rules for access to objects that don\'t have roles.

$Id: SimpleObjectPolicies.py,v 1.12 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.12 $'[11:-2]

_noroles=[] # this is imported from various places

import Record

# Allow access to unprotected attributes
Record.Record.__allow_access_to_unprotected_subobjects__=1

ContainerAssertions={
    type(()): 1,
    type([]): 1,
    type({}): 1,
    type(''): 1,
    type(u''): 1,
    }

@others
</t>
<t tx="ekr.20040104185913.350">class _dummy_class: pass
</t>
<t tx="ekr.20040104185913.351">from DocumentTemplate.DT_Util import TemplateDict
# Temporarily create a DictInstance so that we can mark its type as
# being a key in the ContainerAssertions.
templateDict = TemplateDict()
try:
    dictInstance = templateDict(dummy=1)[0]
    if type(dictInstance) is not type(_dummy_class()):
        ContainerAssertions[type(dictInstance)]=1
except:
    # Hmm, this may cause _() and _.namespace() to fail.
    # What to do?
    pass

Containers=ContainerAssertions.get

from types import IntType, DictType, TypeType
def allow_type(Type, allowed=1):
    """Allow a type and all of its methods and attributes to be used from
    restricted code.  The argument Type must be a type."""
    if type(Type) is not TypeType:
        raise ValueError, "%s is not a type" % `Type`
    if hasattr(Type, '__roles__'):
        raise ValueError, "%s handles its own security" % `Type`
    if not (isinstance(allowed, IntType) or isinstance(allowed, DictType)):
        raise ValueError, "The 'allowed' argument must be an int or dict."
    ContainerAssertions[Type] = allowed
</t>
<t tx="ekr.20040104185913.352">&lt;&lt; copyright &gt;&gt;

__doc__='''Place to find special users

This is needed to avoid a circular import problem.
$Id: SpecialUsers.py,v 1.4 2002/08/14 21:29:07 mj Exp $'''
__version__='$Revision: 1.4 $'[11:-2]
</t>
<t tx="ekr.20040104185913.353">&lt;&lt; copyright &gt;&gt;

"""Access control package"""

__version__='$Revision: 1.170.6.5 $'[11:-2]

&lt;&lt; User imports &gt;&gt;

ListType=type([])
NotImplemented='NotImplemented'

_marker=[]

@others

Super = UnrestrictedUser  # Note: use of the Super alias is deprecated.
</t>
<t tx="ekr.20040104185913.354">import Globals, socket, SpecialUsers,re
import os
from Globals import DTMLFile, MessageDialog, Persistent, PersistentMapping
from App.Management import Navigation, Tabs
from Acquisition import Implicit
from OFS.SimpleItem import Item
from base64 import decodestring
from App.ImageFile import ImageFile
from Role import RoleManager, DEFAULTMAXLISTUSERS
from PermissionRole import _what_not_even_god_should_do, rolesForPermissionOn
import AuthEncoding
from AccessControl import getSecurityManager
from zExceptions import Unauthorized
from AccessControl.SecurityManagement import newSecurityManager
from AccessControl.SecurityManagement import noSecurityManager
from AccessControl.ZopeSecurityPolicy import _noroles</t>
<t tx="ekr.20040104185913.355">class BasicUser(Implicit):
    """Base class for all User objects"""
	&lt;&lt; class BasicUser declarations &gt;&gt;
	@others
    __repr__=__str__</t>
<t tx="ekr.20040104185913.356">    # ----------------------------
    # Public User object interface
    # ----------------------------

    # Maybe allow access to unprotected attributes. Note that this is
    # temporary to avoid exposing information but without breaking
    # everyone's current code. In the future the security will be
    # clamped down and permission-protected here. Because there are a
    # fair number of user object types out there, this method denies
    # access to names that are private parts of the standard User
    # interface or implementation only. The other approach (only
    # allowing access to public names in the User interface) would
    # probably break a lot of other User implementations with extended
    # functionality that we cant anticipate from the base scaffolding.
</t>
<t tx="ekr.20040104185913.357">def __allow_access_to_unprotected_subobjects__(self, name, value=None):
    deny_names=('name', '__', 'roles', 'domains', '_getPassword',
                'authenticate', '_shared_roles')
    if name in deny_names:
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.358">def __init__(self,name,password,roles,domains):
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.359">def getUserName(self):
    """Return the username of a user"""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.360">def getId(self):
    """Get the ID of the user. The ID can be used, at least from
    Python, to get the user from the user's
    UserDatabase"""
    return self.getUserName()
</t>
<t tx="ekr.20040104185913.361">def _getPassword(self):
    """Return the password of the user."""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.362">def getRoles(self):
    """Return the list of roles assigned to a user."""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.363">def getRolesInContext(self, object):
    """Return the list of roles assigned to the user,
       including local roles assigned in context of
       the passed in object."""
    userid=self.getId()
    roles=self.getRoles()
    local={}
    object=getattr(object, 'aq_inner', object)
    while 1:
        local_roles = getattr(object, '__ac_local_roles__', None)
        if local_roles:
            if callable(local_roles):
                local_roles=local_roles()
            dict=local_roles or {}
            for r in dict.get(userid, []):
                local[r]=1
        inner = getattr(object, 'aq_inner', object)
        parent = getattr(inner, 'aq_parent', None)
        if parent is not None:
            object = parent
            continue
        if hasattr(object, 'im_self'):
            object=object.im_self
            object=getattr(object, 'aq_inner', object)
            continue
        break
    roles=list(roles) + local.keys()
    return roles
</t>
<t tx="ekr.20040104185913.364">def getDomains(self):
    """Return the list of domain restrictions for a user"""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.365"># ------------------------------
# Internal User object interface
# ------------------------------

def authenticate(self, password, request):
    passwrd=self._getPassword()
    result = AuthEncoding.pw_validate(passwrd, password)
    domains=self.getDomains()
    if domains:
        return result and domainSpecMatch(domains, request)
    return result
</t>
<t tx="ekr.20040104185913.366">def _shared_roles(self, parent):
    r=[]
    while 1:
        if hasattr(parent,'__roles__'):
            roles=parent.__roles__
            if roles is None: return 'Anonymous',
            if 'Shared' in roles:
                roles=list(roles)
                roles.remove('Shared')
                r=r+roles
            else:
                try: return r+list(roles)
                except: return r
        if hasattr(parent, 'aq_parent'):
            while hasattr(parent.aq_self,'aq_self'):
                parent=parent.aq_self
            parent=parent.aq_parent
        else: return r
</t>
<t tx="ekr.20040104185913.367">def _check_context(self, object):
    # Check that 'object' exists in the acquisition context of
    # the parent of the acl_users object containing this user,
    # to prevent "stealing" access through acquisition tricks.
    # Return true if in context, false if not or if context
    # cannot be determined (object is not wrapped).
    parent  = getattr(self, 'aq_parent', None)
    context = getattr(parent, 'aq_parent', None)
    if context is not None:
        if object is None:
            return 1
        if not hasattr(object, 'aq_inContextOf'):
            if hasattr(object, 'im_self'):
                # This is a method.  Grab its self.
                object=object.im_self
            if not hasattr(object, 'aq_inContextOf'):
                # Object is not wrapped, so return false.
                return 0
        return object.aq_inContextOf(context, 1)

    # This is lame, but required to keep existing behavior.
    return 1
</t>
<t tx="ekr.20040104185913.368">def allowed(self, object, object_roles=None):
    """Check whether the user has access to object. The user must
       have one of the roles in object_roles to allow access."""

    if object_roles is _what_not_even_god_should_do: return 0

    # Short-circuit the common case of anonymous access.
    if object_roles is None or 'Anonymous' in object_roles:
        return 1

    # Provide short-cut access if object is protected by 'Authenticated'
    # role and user is not nobody
    if 'Authenticated' in object_roles and (
        self.getUserName() != 'Anonymous User'):
        return 1

    # Check for ancient role data up front, convert if found.
    # This should almost never happen, and should probably be
    # deprecated at some point.
    if 'Shared' in object_roles:
        object_roles = self._shared_roles(object)
        if object_roles is None or 'Anonymous' in object_roles:
            return 1

    # Check for a role match with the normal roles given to
    # the user, then with local roles only if necessary. We
    # want to avoid as much overhead as possible.
    user_roles = self.getRoles()
    for role in object_roles:
        if role in user_roles:
            if self._check_context(object):
                return 1
            return None

    # Still have not found a match, so check local roles. We do
    # this manually rather than call getRolesInContext so that
    # we can incur only the overhead required to find a match.
    inner_obj = getattr(object, 'aq_inner', object)
    userid = self.getId()
    while 1:
        local_roles = getattr(inner_obj, '__ac_local_roles__', None)
        if local_roles:
            if callable(local_roles):
                local_roles = local_roles()
            dict = local_roles or {}
            local_roles = dict.get(userid, [])
            for role in object_roles:
                if role in local_roles:
                    if self._check_context(object):
                        return 1
                    return 0
        inner = getattr(inner_obj, 'aq_inner', inner_obj)
        parent = getattr(inner, 'aq_parent', None)
        if parent is not None:
            inner_obj = parent
            continue
        if hasattr(inner_obj, 'im_self'):
            inner_obj=inner_obj.im_self
            inner_obj=getattr(inner_obj, 'aq_inner', inner_obj)
            continue
        break
    return None
</t>
<t tx="ekr.20040104185913.369">def hasRole(self, *args, **kw):
    """hasRole is an alias for 'allowed' and has been deprecated.

    Code still using this method should convert to either 'has_role' or
    'allowed', depending on the intended behaviour.

    """
    import warnings
    warnings.warn('BasicUser.hasRole is deprecated, please use '
        'BasicUser.allowed instead; hasRole was an alias for allowed, but '
        'you may have ment to use has_role.', DeprecationWarning)
    return self.allowed(*args, **kw)
</t>
<t tx="ekr.20040104185913.370">domains=[]

def has_role(self, roles, object=None):
    """Check to see if a user has a given role or roles."""
    if type(roles)==type('s'):
        roles=[roles]
    if object is not None:
        user_roles = self.getRolesInContext(object)
    else:
        # Global roles only...
        user_roles=self.getRoles()
    for role in roles:
        if role in user_roles:
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.371">def has_permission(self, permission, object):
    """Check to see if a user has a given permission on an object."""
    roles=rolesForPermissionOn(permission, object)
    if type(roles) is type(''):
        roles=[roles]
    return self.allowed(object, roles)
</t>
<t tx="ekr.20040104185913.372">def __len__(self): return 1
</t>
<t tx="ekr.20040104185913.373">def __str__(self): return self.getUserName()
</t>
<t tx="ekr.20040104185913.374">class SimpleUser(BasicUser):
    """A very simple user implementation

    that doesn't make a database commitment"""
	@others
</t>
<t tx="ekr.20040104185913.375">def __init__(self,name,password,roles,domains):
    self.name   =name
    self.__     =password
    self.roles  =roles
    self.domains=domains
</t>
<t tx="ekr.20040104185913.376">def getUserName(self):
    """Return the username of a user"""
    return self.name
</t>
<t tx="ekr.20040104185913.377">def _getPassword(self):
    """Return the password of the user."""
    return self.__
</t>
<t tx="ekr.20040104185913.378">def getRoles(self):
    """Return the list of roles assigned to a user."""
    if self.name == 'Anonymous User': return tuple(self.roles)
    else: return tuple(self.roles) + ('Authenticated',)
</t>
<t tx="ekr.20040104185913.379">def getDomains(self):
    """Return the list of domain restrictions for a user"""
    return tuple(self.domains)
</t>
<t tx="ekr.20040104185913.380">class SpecialUser(SimpleUser):
    """Class for special users, like emergency user and nobody"""
	@others
</t>
<t tx="ekr.20040104185913.381">def getId(self): pass
</t>
<t tx="ekr.20040104185913.382">class User(SimpleUser, Persistent):
    """Standard User object"""
</t>
<t tx="ekr.20040104185913.383">class UnrestrictedUser(SpecialUser):
    """User that passes all security checks.  Note, however, that modules
    like Owner.py can still impose restrictions.
    """
	@others
</t>
<t tx="ekr.20040104185913.384">def allowed(self,parent,roles=None):
    return roles is not _what_not_even_god_should_do
</t>
<t tx="ekr.20040104185913.385">def hasRole(self, *args, **kw):
    """hasRole is an alias for 'allowed' and has been deprecated.

    Code still using this method should convert to either 'has_role' or
    'allowed', depending on the intended behaviour.

    """
    import warnings
    warnings.warn('UnrestrictedUser.hasRole is deprecated, please use '
        'UnrestrictedUser.allowed instead; hasRole was an alias for '
        'allowed, but you may have ment to use has_role.',
        DeprecationWarning)
    self.allowed(*args, **kw)
</t>
<t tx="ekr.20040104185913.386">def has_role(self, roles, object=None): return 1
</t>
<t tx="ekr.20040104185913.387">def has_permission(self, permission, object): return 1
</t>
<t tx="ekr.20040104185913.388">class NullUnrestrictedUser(SpecialUser):
    """User created if no emergency user exists. It is only around to
       satisfy third party userfolder implementations that may
       expect the emergency user to exist and to be able to call certain
       methods on it (in other words, backward compatibility).

       Note that when no emergency user is installed, this object that
       exists in its place is more of an anti-superuser since you cannot
       login as this user and it has no priveleges at all."""
	__null_user__=1
	@others
</t>
<t tx="ekr.20040104185913.390">def __init__(self):
    pass
</t>
<t tx="ekr.20040104185913.391">def getUserName(self):
    # return an unspellable username
    return (None, None)
</t>
<t tx="ekr.20040104185913.392">_getPassword=getUserName

def getRoles(self):
    return ()
</t>
<t tx="ekr.20040104185913.393">getDomains=getRoles

def getRolesInContext(self, object):
    return ()
</t>
<t tx="ekr.20040104185913.394">def authenticate(self, password, request):
    return 0
</t>
<t tx="ekr.20040104185913.395">def allowed(self, parent, roles=None):
    return 0
</t>
<t tx="ekr.20040104185913.396">def hasRole(self, *args, **kw):
    """hasRole is an alias for 'allowed' and has been deprecated.

    Code still using this method should convert to either 'has_role' or
    'allowed', depending on the intended behaviour.

    """
    import warnings
    warnings.warn('NullUnrestrictedUser.hasRole is deprecated, please use '
        'NullUnrestrictedUser.allowed instead; hasRole was an alias for '
        'allowed, but you may have ment to use has_role.',
        DeprecationWarning)
    self.allowed(*args, **kw)
</t>
<t tx="ekr.20040104185913.397">def has_role(self, roles, object=None):
    return 0
</t>
<t tx="ekr.20040104185913.398">def has_permission(self, permission, object):
    return 0
</t>
<t tx="ekr.20040104185913.399">def readUserAccessFile(filename):
    '''Reads an access file from INSTANCE_HOME.
    Returns name, password, domains, remote_user_mode.
    '''
    try:
        f = open(os.path.join(INSTANCE_HOME, filename), 'r')
        line = f.readline()
        f.close()
    except IOError:
        return None

    if line:
        data = line.strip().split(':')
        remote_user_mode = not data[1]
        try:    ds = data[2].split(' ')
        except: ds = []
        return data[0], data[1], ds, remote_user_mode
    else:
        return None
</t>
<t tx="ekr.20040104185913.400"># Create emergency user.
_remote_user_mode=0

info = readUserAccessFile('access')
if info:
    _remote_user_mode = info[3]
    emergency_user = UnrestrictedUser(
        info[0], info[1], ('manage',), info[2])
else:
    emergency_user = NullUnrestrictedUser()

super = emergency_user  # Note: use of the 'super' name is deprecated.
del info

nobody=SpecialUser('Anonymous User','',('Anonymous',), [])
system=UnrestrictedUser('System Processes','',('manage',), [])

# stuff these in a handier place for importing
SpecialUsers.nobody=nobody
SpecialUsers.system=system
SpecialUsers.emergency_user=emergency_user
# Note: use of the 'super' name is deprecated.
SpecialUsers.super=emergency_user

class BasicUserFolder(Implicit, Persistent, Navigation, Tabs, RoleManager,Item):
	&lt;&lt; class BasicUserFolder declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.401">"""Base class for UserFolder-like objects"""

meta_type='User Folder'
id       ='acl_users'
title    ='User Folder'

isPrincipiaFolderish=1
isAUserFolder=1
maxlistusers = DEFAULTMAXLISTUSERS

encrypt_passwords = 0

manage_options=(
(
{'label':'Contents', 'action':'manage_main',
'help':('OFSP','User-Folder_Contents.stx')},
{'label':'Properties', 'action':'manage_userFolderProperties',
'help':('OFSP','User-Folder_Properties.stx')},
)
+RoleManager.manage_options
+Item.manage_options
)

__ac_permissions__=(
('Manage users',
('manage_users','getUserNames', 'getUser', 'getUsers',
'getUserById', 'user_names', 'setDomainAuthenticationMode',
'userFolderAddUser', 'userFolderEditUser', 'userFolderDelUsers',
)
),
)


# ----------------------------------
# Public UserFolder object interface
# ----------------------------------

</t>
<t tx="ekr.20040104185913.402">def getUserNames(self):
    """Return a list of usernames"""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.403">def getUsers(self):
    """Return a list of user objects"""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.404">def getUser(self, name):
    """Return the named user object or None"""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.405">def getUserById(self, id, default=_marker):
    """Return the user corresponding to the given id.
    """
    # The connection between getting by ID and by name is not a strong
    # one
    try:
        return self.getUser(id)
    except:
        if default is _marker: raise
        return default
</t>
<t tx="ekr.20040104185913.406">def _doAddUser(self, name, password, roles, domains, **kw):
    """Create a new user. This should be implemented by subclasses to
       do the actual adding of a user. The 'password' will be the
       original input password, unencrypted. The implementation of this
       method is responsible for performing any needed encryption."""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.407">def _doChangeUser(self, name, password, roles, domains, **kw):
    """Modify an existing user. This should be implemented by subclasses
       to make the actual changes to a user. The 'password' will be the
       original input password, unencrypted. The implementation of this
       method is responsible for performing any needed encryption."""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.408">def _doDelUsers(self, names):
    """Delete one or more users. This should be implemented by subclasses
       to do the actual deleting of users."""
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.409"># As of Zope 2.5, userFolderAddUser, userFolderEditUser and
# userFolderDelUsers offer aliases for the the _doAddUser, _doChangeUser
# and _doDelUsers methods (with the difference that they can be called
# from XML-RPC or untrusted scripting code, given the necessary
# permissions).
#
# Authors of custom user folders don't need to do anything special to
# support these - they will just call the appropriate '_' methods that
# user folder subclasses already implement.
def userFolderAddUser(self, name, password, roles, domains, **kw):
    """API method for creating a new user object. Note that not all
       user folder implementations support dynamic creation of user
       objects."""
    if hasattr(self, '_doAddUser'):
        return self._doAddUser(name, password, roles, domains, **kw)
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.410">def userFolderEditUser(self, name, password, roles, domains, **kw):
    """API method for changing user object attributes. Note that not
       all user folder implementations support changing of user object
       attributes."""
    if hasattr(self, '_doChangeUser'):
        return self._doChangeUser(name, password, roles, domains, **kw)
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.411">def userFolderDelUsers(self, names):
    """API method for deleting one or more user objects. Note that not
       all user folder implementations support deletion of user objects."""
    if hasattr(self, '_doDelUsers'):
        return self._doDelUsers(names)
    raise NotImplemented
</t>
<t tx="ekr.20040104185913.412"># -----------------------------------
# Private UserFolder object interface
# -----------------------------------

_remote_user_mode=_remote_user_mode
_domain_auth_mode=0
_emergency_user=emergency_user
# Note: use of the '_super' name is deprecated.
_super=emergency_user
_nobody=nobody


def identify(self, auth):
    if auth and auth.lower().startswith('basic '):
        try: name, password=tuple(decodestring(
                                  auth.split(' ')[-1]).split(':', 1))
        except:
            raise 'Bad Request', 'Invalid authentication token'
        return name, password
    else:
        return None, None
</t>
<t tx="ekr.20040104185913.413">def authenticate(self, name, password, request):
    emergency = self._emergency_user
    if name is None:
        return None
    if emergency and name==emergency.getUserName():
        user = emergency
    else:
        user = self.getUser(name)
    if user is not None and user.authenticate(password, request):
        return user
    else:
        return None
</t>
<t tx="ekr.20040104185913.414">def authorize(self, user, accessed, container, name, value, roles):
    user = getattr(user, 'aq_base', user).__of__(self)
    newSecurityManager(None, user)
    security = getSecurityManager()
    try:
        try:
            if security.validate(accessed, container, name, value, roles):
                return 1
        except:
            noSecurityManager()
            raise
    except Unauthorized: pass
    return 0
</t>
<t tx="ekr.20040104185913.415">def validate(self, request, auth='', roles=_noroles):
    """
    this method performs identification, authentication, and
    authorization
    v is the object (value) we're validating access to
    n is the name used to access the object
    a is the object the object was accessed through
    c is the physical container of the object

    We allow the publishing machinery to defer to higher-level user
    folders or to raise an unauthorized by returning None from this
    method.
    """
    v = request['PUBLISHED'] # the published object
    a, c, n, v = self._getobcontext(v, request)

    # we need to continue to support this silly mode
    # where if there is no auth info, but if a user in our
    # database has no password and he has domain restrictions,
    # return him as the authorized user.
    if not auth:
        if self._domain_auth_mode:
            for user in self.getUsers():
                if user.getDomains():
                    if self.authenticate(user.getUserName(), '', request):
                        if self.authorize(user, a, c, n, v, roles):
                            return user.__of__(self)

    name, password = self.identify(auth)
    user = self.authenticate(name, password, request)
    # user will be None if we can't authenticate him or if we can't find
    # his username in this user database.
    emergency = self._emergency_user
    if emergency and user is emergency:
        if self._isTop():
            # we do not need to authorize the emergency user against the
            # published object.
            return emergency.__of__(self)
        else:
            # we're not the top-level user folder
            return None
    elif user is None:
        # either we didn't find the username, or the user's password
        # was incorrect.  try to authorize and return the anonymous user.
        if self._isTop() and self.authorize(self._nobody, a,c,n,v,roles):
            return self._nobody.__of__(self)
        else:
            # anonymous can't authorize or we're not top-level user folder
            return None
    else:
        # We found a user, his password was correct, and the user
        # wasn't the emergency user.  We need to authorize the user
        # against the published object.
        if self.authorize(user, a, c, n, v, roles):
            return user.__of__(self)
        # That didn't work.  Try to authorize the anonymous user.
        elif self._isTop() and self.authorize(self._nobody,a,c,n,v,roles):
            return self._nobody.__of__(self)
        else:
            # we can't authorize the user, and we either can't authorize
            # nobody against the published object or we're not top-level
            return None
</t>
<t tx="ekr.20040104185913.416">if _remote_user_mode:

    def validate(self, request, auth='', roles=_noroles):
        v = request['PUBLISHED']
        a, c, n, v = self._getobcontext(v, request)
        name = request.environ.get('REMOTE_USER', None)
        if name is None:
            if self._domain_auth_mode:
                for user in self.getUsers():
                    if user.getDomains():
                        if self.authenticate(
                            user.getUserName(), '', request
                            ):
                            if self.authorize(user, a, c, n, v, roles):
                                return user.__of__(self)

        user = self.getUser(name)
        # user will be None if we can't find his username in this user
        # database.
        emergency = self._emergency_user
        if emergency and name==emergency.getUserName():
            if self._isTop():
                # we do not need to authorize the emergency user against
                #the published object.
                return emergency.__of__(self)
            else:
                # we're not the top-level user folder
                return None
        elif user is None:
            # we didn't find the username in this database
            # try to authorize and return the anonymous user.
            if self._isTop() and self.authorize(self._nobody,
                                                a, c, n, v, roles):
                return self._nobody.__of__(self)
            else:
                # anonymous can't authorize or we're not top-level user
                # folder
                return None
        else:
            # We found a user and the user wasn't the emergency user.
            # We need to authorize the user against the published object.
            if self.authorize(user, a, c, n, v, roles):
                return user.__of__(self)
            # That didn't work.  Try to authorize the anonymous user.
            elif self._isTop() and self.authorize(
                self._nobody, a, c, n, v, roles):
                return self._nobody.__of__(self)
            else:
                # we can't authorize the user, and we either can't
                # authorize nobody against the published object or
                # we're not top-level
                return None
</t>
<t tx="ekr.20040104185913.417">def _getobcontext(self, v, request):
    """
    v is the object (value) we're validating access to
    n is the name used to access the object
    a is the object the object was accessed through
    c is the physical container of the object
    """
    if len(request.steps) == 0: # someone deleted root index_html
        request.RESPONSE.notFoundError('no default view (root default view'
                                       ' was probably deleted)')
    n = request.steps[-1]
    # default to accessed and container as v.aq_parent
    a = c = request['PARENTS'][0]
    # try to find actual container
    inner = getattr(v, 'aq_inner', v)
    innerparent = getattr(inner, 'aq_parent', None)
    if innerparent is not None:
        # this is not a method, we needn't treat it specially
        c = innerparent
    elif hasattr(v, 'im_self'):
        # this is a method, we need to treat it specially
        c = v.im_self
        c = getattr(v, 'aq_inner', v)
    request_container = getattr(request['PARENTS'][-1], 'aq_parent', [])
    # if pub's aq_parent or container is the request container, it
    # means pub was accessed from the root
    if a is request_container:
        a = request['PARENTS'][-1]
    if c is request_container:
        c = request['PARENTS'][-1]

    return a, c, n, v
</t>
<t tx="ekr.20040104185913.418">def _isTop(self):
    try:
        return self.aq_parent.aq_base.isTopLevelPrincipiaApplicationObject
    except:
        return 0
</t>
<t tx="ekr.20040104185913.419">def __len__(self):
    return 1
</t>
<t tx="ekr.20040104185913.420">_mainUser=DTMLFile('dtml/mainUser', globals())
_add_User=DTMLFile('dtml/addUser', globals(),
                   remote_user_mode__=_remote_user_mode)
_editUser=DTMLFile('dtml/editUser', globals(),
                   remote_user_mode__=_remote_user_mode)
manage=manage_main=_mainUser
manage_main._setName('manage_main')

_userFolderProperties = DTMLFile('dtml/userFolderProps', globals())

def manage_userFolderProperties(self, REQUEST=None,
                                manage_tabs_message=None):
    """
    """
    return self._userFolderProperties(
        self, REQUEST, manage_tabs_message=manage_tabs_message,
        management_view='Properties')
</t>
<t tx="ekr.20040104185913.421">def manage_setUserFolderProperties(self, encrypt_passwords=0,
                                   update_passwords=0,
                                   maxlistusers=DEFAULTMAXLISTUSERS,
                                   REQUEST=None):
    """
    Sets the properties of the user folder.
    """
    self.encrypt_passwords = not not encrypt_passwords
    try:
        self.maxlistusers = int(maxlistusers)
    except ValueError:
        self.maxlistusers = DEFAULTMAXLISTUSERS
    if encrypt_passwords and update_passwords:
        changed = 0
        for u in self.getUsers():
            pw = u._getPassword()
            if not self._isPasswordEncrypted(pw):
                pw = self._encryptPassword(pw)
                self._doChangeUser(u.getUserName(), pw, u.getRoles(),
                                   u.getDomains())
                changed = changed + 1
        if REQUEST is not None:
            if not changed:
                msg = 'All passwords already encrypted.'
            else:
                msg = 'Encrypted %d password(s).' % changed
            return self.manage_userFolderProperties(
                REQUEST, manage_tabs_message=msg)
        else:
            return changed
    else:
        if REQUEST is not None:
            return self.manage_userFolderProperties(
                REQUEST, manage_tabs_message='Saved changes.')
</t>
<t tx="ekr.20040104185913.422">def _isPasswordEncrypted(self, pw):
    return AuthEncoding.is_encrypted(pw)
</t>
<t tx="ekr.20040104185913.423">def _encryptPassword(self, pw):
    return AuthEncoding.pw_encrypt(pw, 'SSHA')
</t>
<t tx="ekr.20040104185913.424">def domainSpecValidate(self,spec):

    for ob in spec:

        am = addr_match(ob)
        hm = host_match(ob)

        if am is None and hm is None:
            return 0

    return 1
</t>
<t tx="ekr.20040104185913.425">def _addUser(self,name,password,confirm,roles,domains,REQUEST=None):
    if not name:
        return MessageDialog(
               title  ='Illegal value',
               message='A username must be specified',
               action ='manage_main')
    if not password or not confirm:
        if not domains:
            return MessageDialog(
               title  ='Illegal value',
               message='Password and confirmation must be specified',
               action ='manage_main')
    if self.getUser(name) or (self._emergency_user and
                              name == self._emergency_user.getUserName()):
        return MessageDialog(
               title  ='Illegal value',
               message='A user with the specified name already exists',
               action ='manage_main')
    if (password or confirm) and (password != confirm):
        return MessageDialog(
               title  ='Illegal value',
               message='Password and confirmation do not match',
               action ='manage_main')

    if not roles: roles=[]
    if not domains: domains=[]

    if domains and not self.domainSpecValidate(domains):
        return MessageDialog(
               title  ='Illegal value',
               message='Illegal domain specification',
               action ='manage_main')
    self._doAddUser(name, password, roles, domains)
    if REQUEST: return self._mainUser(self, REQUEST)
</t>
<t tx="ekr.20040104185913.426">def _changeUser(self,name,password,confirm,roles,domains,REQUEST=None):
    if password == 'password' and confirm == 'pconfirm':
        # Protocol for editUser.dtml to indicate unchanged password
        password = confirm = None
    if not name:
        return MessageDialog(
               title  ='Illegal value',
               message='A username must be specified',
               action ='manage_main')
    if password == confirm == '':
        if not domains:
            return MessageDialog(
               title  ='Illegal value',
               message='Password and confirmation must be specified',
               action ='manage_main')
    if not self.getUser(name):
        return MessageDialog(
               title  ='Illegal value',
               message='Unknown user',
               action ='manage_main')
    if (password or confirm) and (password != confirm):
        return MessageDialog(
               title  ='Illegal value',
               message='Password and confirmation do not match',
               action ='manage_main')

    if not roles: roles=[]
    if not domains: domains=[]

    if domains and not self.domainSpecValidate(domains):
        return MessageDialog(
               title  ='Illegal value',
               message='Illegal domain specification',
               action ='manage_main')
    self._doChangeUser(name, password, roles, domains)
    if REQUEST: return self._mainUser(self, REQUEST)
</t>
<t tx="ekr.20040104185913.427">def _delUsers(self,names,REQUEST=None):
    if not names:
        return MessageDialog(
               title  ='Illegal value',
               message='No users specified',
               action ='manage_main')
    self._doDelUsers(names)
    if REQUEST: return self._mainUser(self, REQUEST)
</t>
<t tx="ekr.20040104185913.428">def manage_users(self,submit=None,REQUEST=None,RESPONSE=None):
    """This method handles operations on users for the web based forms
       of the ZMI. Application code (code that is outside of the forms
       that implement the UI of a user folder) are encouraged to use
       manage_std_addUser"""
    if submit=='Add...':
        return self._add_User(self, REQUEST)

    if submit=='Edit':
        try:    user=self.getUser(reqattr(REQUEST, 'name'))
        except: return MessageDialog(
                title  ='Illegal value',
                message='The specified user does not exist',
                action ='manage_main')
        return self._editUser(self,REQUEST,user=user,password=user.__)

    if submit=='Add':
        name    =reqattr(REQUEST, 'name')
        password=reqattr(REQUEST, 'password')
        confirm =reqattr(REQUEST, 'confirm')
        roles   =reqattr(REQUEST, 'roles')
        domains =reqattr(REQUEST, 'domains')
        return self._addUser(name,password,confirm,roles,domains,REQUEST)

    if submit=='Change':
        name    =reqattr(REQUEST, 'name')
        password=reqattr(REQUEST, 'password')
        confirm =reqattr(REQUEST, 'confirm')
        roles   =reqattr(REQUEST, 'roles')
        domains =reqattr(REQUEST, 'domains')
        return self._changeUser(name,password,confirm,roles,
                                domains,REQUEST)

    if submit=='Delete':
        names=reqattr(REQUEST, 'names')
        return self._delUsers(names,REQUEST)

    return self._mainUser(self, REQUEST)
</t>
<t tx="ekr.20040104185913.429">def user_names(self):
    return self.getUserNames()
</t>
<t tx="ekr.20040104185913.430">def manage_beforeDelete(self, item, container):
    if item is self:
        try: del container.__allow_groups__
        except: pass
</t>
<t tx="ekr.20040104185913.431">def manage_afterAdd(self, item, container):
    if item is self:
        if hasattr(self, 'aq_base'): self=self.aq_base
        container.__allow_groups__=self
</t>
<t tx="ekr.20040104185913.432">def __creatable_by_emergency_user__(self): return 1
</t>
<t tx="ekr.20040104185913.433">def _setId(self, id):
    if id != self.id:
        raise Globals.MessageDialog(
            title='Invalid Id',
            message='Cannot change the id of a UserFolder',
            action ='./manage_main',)
</t>
<t tx="ekr.20040104185913.434"># Domain authentication support. This is a good candidate to
# become deprecated in future Zope versions.

def setDomainAuthenticationMode(self, domain_auth_mode):
    """Set the domain-based authentication mode. By default, this
       mode is off due to the high overhead of the operation that
       is incurred for all anonymous accesses. If you have the
       'Manage Users' permission, you can call this method via
       the web, passing a boolean value for domain_auth_mode to
       turn this behavior on or off."""
    v = self._domain_auth_mode = domain_auth_mode and 1 or 0
    return 'Domain authentication mode set to %d' % v
</t>
<t tx="ekr.20040104185913.435">def domainAuthModeEnabled(self):
    """ returns true if domain auth mode is set to true"""
    return getattr(self, '_domain_auth_mode', None)
</t>
<t tx="ekr.20040104185913.436">class UserFolder(BasicUserFolder):
    """Standard UserFolder object

    A UserFolder holds User objects which contain information
    about users including name, password domain, and roles.
    UserFolders function chiefly to control access by authenticating
    users and binding them to a collection of roles."""
	&lt;&lt; class UserFolder declarations &gt;&gt;
	@others

Globals.default__class_init__(UserFolder)</t>
<t tx="ekr.20040104185913.437">meta_type='User Folder'
id       ='acl_users'
title    ='User Folder'
icon     ='p_/UserFolder'

</t>
<t tx="ekr.20040104185913.438">def __init__(self):
    self.data=PersistentMapping()
</t>
<t tx="ekr.20040104185913.439">def getUserNames(self):
    """Return a list of usernames"""
    names=self.data.keys()
    names.sort()
    return names
</t>
<t tx="ekr.20040104185913.440">def getUsers(self):
    """Return a list of user objects"""
    data=self.data
    names=data.keys()
    names.sort()
    users=[]
    f=users.append
    for n in names:
        f(data[n])
    return users
</t>
<t tx="ekr.20040104185913.441">def getUser(self, name):
    """Return the named user object or None"""
    return self.data.get(name, None)
</t>
<t tx="ekr.20040104185913.442">def _doAddUser(self, name, password, roles, domains, **kw):
    """Create a new user"""
    if password is not None and self.encrypt_passwords:
        password = self._encryptPassword(password)
    self.data[name]=User(name,password,roles,domains)
</t>
<t tx="ekr.20040104185913.443">def _doChangeUser(self, name, password, roles, domains, **kw):
    user=self.data[name]
    if password is not None:
        if self.encrypt_passwords and not self._isPasswordEncrypted(password):
            password = self._encryptPassword(password)
        user.__=password
    user.roles=roles
    user.domains=domains
</t>
<t tx="ekr.20040104185913.444">def _doDelUsers(self, names):
    for name in names:
        del self.data[name]
</t>
<t tx="ekr.20040104185913.445">def _createInitialUser(self):
    """
    If there are no users or only one user in this user folder,
    populates from the 'inituser' file in INSTANCE_HOME.
    We have to do this even when there is already a user
    just in case the initial user ignored the setup messages.
    We don't do it for more than one user to avoid
    abuse of this mechanism.
    Called only by OFS.Application.initialize().
    """
    if len(self.data) &lt;= 1:
        info = readUserAccessFile('inituser')
        if info:
            name, password, domains, remote_user_mode = info
            self._doDelUsers(self.getUserNames())
            self._doAddUser(name, password, ('Manager',), domains)
            try:
                os.remove(os.path.join(INSTANCE_HOME, 'inituser'))
            except:
                pass
</t>
<t tx="ekr.20040104185913.446">def manage_addUserFolder(self,dtself=None,REQUEST=None,**ignored):
    """ """
    f=UserFolder()
    self=self.this()
    try:    self._setObject('acl_users', f)
    except: return MessageDialog(
                   title  ='Item Exists',
                   message='This object already contains a User Folder',
                   action ='%s/manage_main' % REQUEST['URL1'])
    self.__allow_groups__=f
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(self.absolute_url()+'/manage_main')
</t>
<t tx="ekr.20040104185913.447">def rolejoin(roles, other):
    dict={}
    for role in roles:
        dict[role]=1
    for role in other:
        dict[role]=1
    roles=dict.keys()
    roles.sort()
    return roles
</t>
<t tx="ekr.20040104185913.448">addr_match=re.compile(r'((\d{1,3}\.){1,3}\*)|((\d{1,3}\.){3}\d{1,3})').match
host_match=re.compile(r'(([\_0-9a-zA-Z\-]*\.)*[0-9a-zA-Z\-]*)').match

def domainSpecMatch(spec, request):
    host=''
    addr=''

    # Fast exit for the match-all case
    if len(spec) == 1 and spec[0] == '*':
        return 1

    if request.has_key('REMOTE_HOST'):
        host=request['REMOTE_HOST']

    if request.has_key('REMOTE_ADDR'):
        addr=request['REMOTE_ADDR']

    if not host and not addr:
        return 0

    if not host:
        try:    host=socket.gethostbyaddr(addr)[0]
        except: pass
    if not addr:
        try:    addr=socket.gethostbyname(host)
        except: pass


    _host=host.split('.')
    _addr=addr.split('.')
    _hlen=len(_host)
    _alen=len(_addr)

    for ob in spec:
        sz=len(ob)
        _ob=ob.split('.')
        _sz=len(_ob)

        mo = addr_match(ob)
        if mo is not None:
            if mo.end(0)==sz:
                fail=0
                for i in range(_sz):
                    a=_addr[i]
                    o=_ob[i]
                    if (o != a) and (o != '*'):
                        fail=1
                        break
                if fail:
                    continue
                return 1

        mo = host_match(ob)
        if mo is not None:
            if mo.end(0)==sz:
                if _hlen &lt; _sz:
                    continue
                elif _hlen &gt; _sz:
                    _item=_host[-_sz:]
                else:
                    _item=_host
                fail=0
                for i in range(_sz):
                    h=_item[i]
                    o=_ob[i]
                    if (o != h) and (o != '*'):
                        fail=1
                        break
                if fail:
                    continue
                return 1
    return 0
</t>
<t tx="ekr.20040104185913.449">def absattr(attr):
    if callable(attr): return attr()
    return attr
</t>
<t tx="ekr.20040104185913.450">def reqattr(request, attr):
    try:    return request[attr]
    except: return None
</t>
<t tx="ekr.20040104185913.451">&lt;&lt; copyright &gt;&gt;

__version__='$Revision: 1.12.4.2 $'[11:-2]

&lt;&lt; ZopeGuards imports &gt;&gt;

_marker = []  # Create a new marker object.

safe_builtins = safe_builtins.copy()
safe_builtins.update(utility_builtins)

try:
    #raise ImportError
    import os
    if os.environ.get("ZOPE_SECURITY_POLICY", None) == "PYTHON":
        raise ImportError # :)
    from cAccessControl import aq_validate, guarded_getattr

except ImportError:
	@others</t>
<t tx="ekr.20040104185913.452">from RestrictedPython.Guards import safe_builtins, _full_read_guard, \
     full_write_guard
from RestrictedPython.Utilities import utility_builtins
from SecurityManagement import getSecurityManager
from SecurityInfo import secureModule
from SimpleObjectPolicies import Containers
from zExceptions import Unauthorized</t>
<t tx="ekr.20040104185913.453">def aq_validate(inst, obj, name, v, validate):
    return validate(inst, obj, name, v)
</t>
<t tx="ekr.20040104185913.454">def guarded_getattr(inst, name, default=_marker):
    if name[:1] != '_':
        # Try to get the attribute normally so that unusual
        # exceptions are caught early.
        try: v = getattr(inst, name)
        except AttributeError:
            if default is not _marker:
                return default
            raise
        if Containers(type(inst)):
            # Simple type.  Short circuit.
            return v
        validate = getSecurityManager().validate
        # Filter out the objects we can't access.
        if hasattr(inst, 'aq_acquire'):
            return inst.aq_acquire(name, aq_validate, validate)
        # Or just try to get the attribute directly.
        if validate(inst, inst, name, v):
            return v
    raise Unauthorized, name
</t>
<t tx="ekr.20040104185913.455">safe_builtins['getattr'] = guarded_getattr

def guarded_hasattr(object, name):
    try:
        guarded_getattr(object, name)
    except (AttributeError, Unauthorized):
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.456">safe_builtins['hasattr'] = guarded_hasattr

SliceType = type(slice(0))
def guarded_getitem(object, index):
    if type(index) is SliceType:
        if index.step is not None:
            v = object[index]
        else:
            start = index.start
            stop = index.stop
            if start is None:
                start = 0
            if stop is None:
                v = object[start:]
            else:
                v = object[start:stop]
        # We don't guard slices.
        return v
    v = object[index]
    if Containers(type(object)) and Containers(type(v)):
        # Simple type.  Short circuit.
        return v
    if getSecurityManager().validate(object, object, index, v):
        return v
    raise Unauthorized, 'unauthorized access to element %s' % `i`
</t>
<t tx="ekr.20040104185913.457">full_read_guard = _full_read_guard(guarded_getattr, guarded_getitem)


def guarded_filter(f, seq, skip_unauthorized=0):
    if type(seq) is type(''):
        return filter(f, seq)
    if f is None:
        def f(x): return x
    v = getSecurityManager().validate
    result = []
    a = result.append
    for el in seq:
        if v(seq, seq, None, el):
            if f(el): a(el)
        elif not skip_unauthorized:
            raise Unauthorized, 'unauthorized access to element'
    return result
</t>
<t tx="ekr.20040104185913.458">safe_builtins['filter'] = guarded_filter

def guarded_map(f, *seqs):
    safe_seqs = []
    for seqno in range(len(seqs)):
        seq = guarded_getitem(seqs, seqno)
        safe_seqs.append(seq)
    return map(f, *safe_seqs)
</t>
<t tx="ekr.20040104185913.459">safe_builtins['map'] = guarded_map

import sys
def guarded_import(mname, globals={}, locals={}, fromlist=None):
    mnameparts = mname.split('.')
    firstmname = mnameparts[0]
    validate = getSecurityManager().validate
    module = load_module(None, None, mnameparts, validate, globals, locals)
    if module is not None:
        if fromlist is None:
            fromlist = ()
        try:
            for name in fromlist:
                if name == '*':
                    raise ImportError, ('"from %s import *" is not allowed'
                                        % mname)
                v = getattr(module, name, None)
                if v is None:
                    v = load_module(module, mname, [name], validate,
                                    globals, locals)
                if not validate(module, module, name, v):
                    raise Unauthorized
            else:
                return __import__(mname, globals, locals, fromlist)
        except Unauthorized, why:
            raise ImportError, ('import of "%s" from "%s" is unauthorized. %s'
                                % (name, mname, why))
    raise ImportError, 'import of "%s" is unauthorized' % mname
</t>
<t tx="ekr.20040104185913.460">safe_builtins['__import__'] = guarded_import

def load_module(module, mname, mnameparts, validate, globals, locals):
    modules = sys.modules
    while mnameparts:
        nextname = mnameparts.pop(0)
        if mname is None:
            mname = nextname
        else:
            mname = '%s.%s' % (mname, nextname)
        nextmodule = modules.get(mname, None)
        if nextmodule is None:
            nextmodule = secureModule(mname, globals, locals)
            if nextmodule is None:
                return
        else:
            secureModule(mname)
        if module and not validate(module, module, nextname, nextmodule):
            return
        module = nextmodule
    return module
</t>
<t tx="ekr.20040104185913.461">&lt;&lt; copyright &gt;&gt;

__doc__='''Define Zope\'s default security policy


$Id: ZopeSecurityPolicy.py,v 1.20 2002/08/21 19:31:59 shane Exp $'''
__version__='$Revision: 1.20 $'[11:-2]

_use_python_impl = 0

&lt;&lt; ZopeSecurityPolicy imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.462">import os
if os.environ.get("ZOPE_SECURITY_POLICY", None) == "PYTHON":
    _use_python_impl = 1
else:
    try:
        # C Optimization:
        from cAccessControl import ZopeSecurityPolicy
        from SimpleObjectPolicies import _noroles
    except ImportError:
        # Fall back to Python implementation.
        _use_python_impl = 1


if _use_python_impl:

    from types import StringType

    import SimpleObjectPolicies
    from AccessControl import Unauthorized
    _noroles=SimpleObjectPolicies._noroles
    from zLOG import LOG, PROBLEM
    from Acquisition import aq_base

    from PermissionRole import _what_not_even_god_should_do, \
         rolesForPermissionOn</t>
<t tx="ekr.20040104185913.463">class ZopeSecurityPolicy:
	@others
</t>
<t tx="ekr.20040104185913.464">def __init__(self, ownerous=1, authenticated=1):
    """Create a Zope security policy.

    Two optional keyword arguments may be provided:

    ownerous -- Untrusted users can create code
                (e.g. Python scripts or templates),
                so check that code owners can access resources.
                The argument must have a truth value.
                The default is true.

    authenticated -- Allow access to resources based on the
                privaledges of the authenticated user.
                The argument must have a truth value.
                The default is true.

                This (somewhat experimental) option can be set
                to false on sites that allow only public
                (unauthenticated) access. An anticipated
                scenario is a ZEO configuration in which some
                clients allow only public access and other
                clients allow full management.
    """

    self._ownerous=ownerous
    self._authenticated=authenticated
</t>
<t tx="ekr.20040104185913.465">def validate(self, accessed, container, name, value, context,
             roles=_noroles, None=None, type=type, IntType=type(0),
             DictType=type({}), getattr=getattr, _noroles=_noroles,
             StringType=type(''),
             Containers=SimpleObjectPolicies.Containers,
             valid_aq_=('aq_parent','aq_inner', 'aq_explicit')):

    &lt;&lt; Provide special rules for the acquisition attributes &gt;&gt;

    # If roles weren't passed in, we'll try to get them from the object
    if roles is _noroles:
        roles=getattr(value, '__roles__', _noroles)

    # We still might not have any roles
    if roles is _noroles:
		&lt;&lt; try to get roles from the container &gt;&gt;
		
    &lt;&lt; Short-circuit tests if we can &gt;&gt;
    &lt;&lt; Check executable security &gt;&gt;

    # We don't want someone to acquire if they can't get an unacquired!
    if accessedbase is containerbase:
        raise Unauthorized(name, value)

    return 0</t>
<t tx="ekr.20040104185913.466">def checkPermission(self, permission, object, context):
    # XXX proxy roles and executable owner are not checked
    roles=rolesForPermissionOn(permission, object)
    if type(roles) is StringType:
        roles=[roles]
    return context.user.allowed(object, roles)
</t>
<t tx="ekr.20040104185913.467">&lt;&lt; copyright &gt;&gt;

from unauthorized import Unauthorized

import DTML
del DTML

from SecurityManagement import getSecurityManager, setSecurityPolicy
from SecurityInfo import ClassSecurityInfo, ModuleSecurityInfo
from SecurityInfo import ACCESS_PRIVATE
from SecurityInfo import ACCESS_PUBLIC
from SecurityInfo import ACCESS_NONE
from SecurityInfo import secureModule, allow_module, allow_class
from SimpleObjectPolicies import allow_type
from ZopeGuards import full_read_guard, full_write_guard, safe_builtins

ModuleSecurityInfo('AccessControl').declarePublic('getSecurityManager')
</t>
<t tx="ekr.20040104185913.468">@language c

/*
**	cAccessControl.c
**
**	Access control acceleration routines
**/

&lt;&lt; c components copyright &gt;&gt;

&lt;&lt; cAccessControl #includes &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.469">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "ExtensionClass.h"
#include "Acquisition.h"
</t>
<t tx="ekr.20040104185913.470">static void
PyVar_Assign(PyObject **v,  PyObject *e)
{
  Py_XDECREF(*v);
  *v=e;
}
</t>
<t tx="ekr.20040104185913.471">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if (!(E))
#define OBJECT(o) ((PyObject *) (o))

static PyObject *
callfunction1(PyObject *function, PyObject *arg)
{
  PyObject *t, *r;
  t = PyTuple_New(1);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg);
  PyTuple_SET_ITEM(t, 0, arg);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.472">static PyObject *
callmethod1(PyObject *self, PyObject *name, PyObject *arg)
{
  UNLESS(self = PyObject_GetAttr(self,name)) return NULL;
  ASSIGN(self, callfunction1(self, arg));
  return self;
}
</t>
<t tx="ekr.20040104185913.473">static PyObject *
callfunction2(PyObject *function, PyObject *arg0, PyObject *arg1)
{
  PyObject *t, *r;
  t = PyTuple_New(2);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg0);
  Py_INCREF(arg1);
  PyTuple_SET_ITEM(t, 0, arg0);
  PyTuple_SET_ITEM(t, 1, arg1);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.474">static PyObject *
callfunction3(PyObject *function, 
              PyObject *arg0, PyObject *arg1, 
              PyObject *arg2
              )
{
  PyObject *t, *r;
  t = PyTuple_New(3);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg0);
  Py_INCREF(arg1);
  Py_INCREF(arg2);
  PyTuple_SET_ITEM(t, 0, arg0);
  PyTuple_SET_ITEM(t, 1, arg1);
  PyTuple_SET_ITEM(t, 2, arg2);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.475">static PyObject *
callfunction4(PyObject *function, 
              PyObject *arg0, PyObject *arg1, 
              PyObject *arg2, PyObject *arg3 
              )
{
  PyObject *t, *r;
  t = PyTuple_New(4);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg0);
  Py_INCREF(arg1);
  Py_INCREF(arg2);
  Py_INCREF(arg3);
  PyTuple_SET_ITEM(t, 0, arg0);
  PyTuple_SET_ITEM(t, 1, arg1);
  PyTuple_SET_ITEM(t, 2, arg2);
  PyTuple_SET_ITEM(t, 3, arg3);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.476">static PyObject *
callfunction5(PyObject *function, 
              PyObject *arg0, PyObject *arg1, 
              PyObject *arg2, PyObject *arg3, PyObject *arg4 
              )
{
  PyObject *t, *r;
  t = PyTuple_New(5);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg0);
  Py_INCREF(arg1);
  Py_INCREF(arg2);
  Py_INCREF(arg3);
  Py_INCREF(arg4);
  PyTuple_SET_ITEM(t, 0, arg0);
  PyTuple_SET_ITEM(t, 1, arg1);
  PyTuple_SET_ITEM(t, 2, arg2);
  PyTuple_SET_ITEM(t, 3, arg3);
  PyTuple_SET_ITEM(t, 4, arg4);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.477">static PyObject *
callfunction6(PyObject *function, 
              PyObject *arg0, PyObject *arg1, 
              PyObject *arg2, PyObject *arg3,
              PyObject *arg4, PyObject *arg5
              )
{
  PyObject *t, *r;
  t = PyTuple_New(6);
  if (t == NULL)
    return NULL;
  Py_INCREF(arg0);
  Py_INCREF(arg1);
  Py_INCREF(arg2);
  Py_INCREF(arg3);
  Py_INCREF(arg4);
  Py_INCREF(arg5);
  PyTuple_SET_ITEM(t, 0, arg0);
  PyTuple_SET_ITEM(t, 1, arg1);
  PyTuple_SET_ITEM(t, 2, arg2);
  PyTuple_SET_ITEM(t, 3, arg3);
  PyTuple_SET_ITEM(t, 4, arg4);
  PyTuple_SET_ITEM(t, 5, arg5);
  r = PyObject_CallObject(function, t);
  Py_DECREF(t);
  return r;
}
</t>
<t tx="ekr.20040104185913.478">static int 
unpacktuple1(PyObject *args, char *name, int min, PyObject **a0)
{ 
  int l;
  l=PyTuple_Size(args);
  if (l &lt; 0) return -1;
  if (l &lt; min) 
    {
      PyErr_Format(PyExc_TypeError, "expected %d arguments, got %d", min, l);
      return -1;
    }
  if (l &gt; 0) *a0=PyTuple_GET_ITEM(args, 0);
  return 0;
}
</t>
<t tx="ekr.20040104185913.479">static int 
unpacktuple2(PyObject *args, char *name, int min, 
             PyObject **a0, PyObject **a1)
{ 
  int l;
  l=PyTuple_Size(args);
  if (l &lt; 0) return -1;
  if (l &lt; min) 
    {
      PyErr_Format(PyExc_TypeError, "expected %d arguments, got %d", min, l);
      return -1;
    }
  if (l &gt; 0) *a0=PyTuple_GET_ITEM(args, 0);
  if (l &gt; 1) *a1=PyTuple_GET_ITEM(args, 1);
  return 0;
}
</t>
<t tx="ekr.20040104185913.480">static int 
unpacktuple3(PyObject *args, char *name, int min, 
             PyObject **a0, PyObject **a1, PyObject **a2)
{ 
  int l;
  l=PyTuple_Size(args);
  if (l &lt; 0) return -1;
  if (l &lt; min) 
    {
      PyErr_Format(PyExc_TypeError, "expected %d arguments, got %d", min, l);
      return -1;
    }
  if (l &gt; 0) *a0=PyTuple_GET_ITEM(args, 0);
  if (l &gt; 1) *a1=PyTuple_GET_ITEM(args, 1);
  if (l &gt; 2) *a2=PyTuple_GET_ITEM(args, 2);
  return 0;
}
</t>
<t tx="ekr.20040104185913.481">static int 
unpacktuple5(PyObject *args, char *name, int min, 
             PyObject **a0, PyObject **a1, PyObject **a2, 
             PyObject **a3, PyObject **a4)
{ 
  int l;
  l=PyTuple_Size(args);
  if (l &lt; 0) return -1;
  if (l &lt; min) 
    {
      PyErr_Format(PyExc_TypeError, "expected %d arguments, got %d", min, l);
      return -1;
    }
  if (l &gt; 0) *a0=PyTuple_GET_ITEM(args, 0);
  if (l &gt; 1) *a1=PyTuple_GET_ITEM(args, 1);
  if (l &gt; 2) *a2=PyTuple_GET_ITEM(args, 2);
  if (l &gt; 3) *a3=PyTuple_GET_ITEM(args, 3);
  if (l &gt; 4) *a4=PyTuple_GET_ITEM(args, 4);
  return 0;
}
</t>
<t tx="ekr.20040104185913.482">static int 
unpacktuple6(PyObject *args, char *name, int min, 
             PyObject **a0, PyObject **a1, PyObject **a2, 
             PyObject **a3, PyObject **a4, PyObject **a5)
{ 
  int l;
  l=PyTuple_Size(args);
  if (l &lt; 0) return -1;
  if (l &lt; min) 
    {
      PyErr_Format(PyExc_TypeError, "expected %d arguments, got %d", min, l);
      return -1;
    }
  if (l &gt; 0) *a0=PyTuple_GET_ITEM(args, 0);
  if (l &gt; 1) *a1=PyTuple_GET_ITEM(args, 1);
  if (l &gt; 2) *a2=PyTuple_GET_ITEM(args, 2);
  if (l &gt; 3) *a3=PyTuple_GET_ITEM(args, 3);
  if (l &gt; 4) *a4=PyTuple_GET_ITEM(args, 4);
  if (l &gt; 5) *a5=PyTuple_GET_ITEM(args, 5);
  return 0;
}
</t>
<t tx="ekr.20040104185913.483">/* Setup for ZopeSecurityPolicy -- load all necessary objects from
** elsewhere... (e.g. imports)
*/

static int 
ZopeSecurityPolicy_setup(void) {
        UNLESS (NoSequenceFormat = PyString_FromString(
                    "'%s' passed as roles"
                    " during validation of '%s' is not a sequence."
                    )) return -1;

	UNLESS (defaultPermission = Py_BuildValue("(s)", "Manager")) return -1;
	UNLESS (_what_not_even_god_should_do = Py_BuildValue("[]")) return -1;
	UNLESS (__roles__ = PyString_FromString("__roles__")) return -1;
	UNLESS (__of__ = PyString_FromString("__of__")) return -1;
	UNLESS (Anonymous = PyString_FromString("Anonymous")) return -1;
	UNLESS (AnonymousTuple = Py_BuildValue("(s)", "Anonymous")) return -1;
	UNLESS (stack_str = PyString_FromString("stack")) return -1;
	UNLESS (user_str = PyString_FromString("user")) return -1;
	UNLESS (validate_str = PyString_FromString("validate")) return -1;
	UNLESS (_proxy_roles_str = PyString_FromString("_proxy_roles"))
          return -1;
	UNLESS (allowed_str = PyString_FromString("allowed")) return -1;
	UNLESS (getOwner_str = PyString_FromString("getOwner")) return -1;
	UNLESS (checkPermission_str = PyString_FromString("checkPermission")) 
          return -1;
        UNLESS (__allow_access_to_unprotected_subobjects__ = 
                PyString_FromString(
                "__allow_access_to_unprotected_subobjects__"))
          return -1;

	if (getenv("ZSP_OWNEROUS_SKIP") != NULL) ownerous = 0;
	if (getenv("ZSP_AUTHENTICATED_SKIP") != NULL) authenticated = 0;


	return 0;
}
</t>
<t tx="ekr.20040104185913.484">@ ** unauthErr ** ** Generate the unauthorized error
@c

static void unauthErr(PyObject *name, PyObject *value) {

        PyObject *v;

        if ((v=Py_BuildValue("OO", name, value)))
          {
            PyErr_SetObject(Unauthorized, v);
            Py_DECREF(v);
          }
}
</t>
<t tx="ekr.20040104185913.485">@ ** ZopeSecurityPolicy_validate
@c

static PyObject *ZopeSecurityPolicy_validate(PyObject *self, PyObject *args) {
	PyObject *accessed = NULL;
	PyObject *container = NULL;
	PyObject *name = NULL;
	PyObject *value = NULL;
	PyObject *context = NULL;
	PyObject *roles = NULL;	
        /* Import from SimpleObject Policy._noroles */
        /* Note that _noroles means missing roles, spelled with a NULL in C.
           Jim. */
	PyObject *containerbase = NULL;
	PyObject *accessedbase = NULL;
	PyObject *p = NULL;
	PyObject *rval = NULL;
	PyObject *stack = NULL;
	PyObject *user = NULL;
	char *sname;


	/*| def validate(self, accessed, container, name, value, context
	**|	roles=_noroles ...
	*/

	if (unpacktuple6(args, "validate", 5, &amp;accessed, &amp;container,
                         &amp;name, &amp;value, &amp;context, &amp;roles) &lt; 0) 
          return NULL;

	/*| # Provide special rules for acquisition attributes
	**| if type(name) is StringType:
	**|     if name[:3] == 'aq_' and name not in valid_aq_:
	**|	   return 0
	*/ 

	if (PyString_Check(name)) {		/* XXX what about unicode? */
		sname = PyString_AS_STRING(name);
		if (*sname == 'a' &amp;&amp; sname[1]=='q' &amp;&amp; sname[2]=='_') {
			if (strcmp(sname,"aq_parent")   != 0 &amp;&amp;
                            strcmp(sname,"aq_inner") != 0 &amp;&amp;
                            strcmp(sname,"aq_explicit") != 0) {
				/* Access control violation, return 0 */
				return PyInt_FromLong(0);
			}
		}
	}

	Py_XINCREF(roles);	/* Convert the borrowed ref to a real one */

	/*| containerbase = aq_base(container)
	**| accessedbase = getattr(accessed, 'aq_base', container)
	*/

	containerbase = aq_base(container);
	if (containerbase == NULL) goto err;
	
	if (aq_isWrapper(accessed))
		accessedbase = aq_base(accessed);
	else {
		Py_INCREF(container);
		accessedbase = container;
	}

	/*| # If roles weren't passed in, we'll try to get them from
	**| # the object
	**|
	**| if roles is _noroles:
	**|    roles = getattr(value, "__roles__", _noroles)
	*/

        if (roles == NULL) {
          roles = PyObject_GetAttr(value, __roles__);
          if (roles == NULL)
            PyErr_Clear();
	}

	/*| # We still might not have any roles
	**| 
	**| if roles is _noroles:
	*/

	if (roles == NULL) {

		/*| # We have an object without roles and we didn't get
		**| # a list of roles passed in.  Presumably, the value
		**| # is some simple object like a string or a list.
		**| # We'll try to get roles from it's container
		**|
		**| if container is None: return 0  # Bail if no container
		*/

		if (container == Py_None)  {
			rval= PyInt_FromLong(0);
			goto err;
		}

		/*| roles = getattr(container, "__roles__", _noroles)
		**| if roles is _noroles:
		**|    aq = getattr(container, 'aq_acquire', None)
		**|    if aq is None:
		**|       roles = _noroles
		**|       if containerbase is not accessedbase: return 0
		**|    else:
		**|       # Try to acquire roles
		**|      try: roles = aq('__roles__')
		**|      except AttributeError:
		**|	    roles = _noroles
		**|         if containerbase is not accessedbase: return 0
		*/
                roles = PyObject_GetAttr(container, __roles__);
		if (roles == NULL) {
			PyErr_Clear();

			if (!aq_isWrapper(container)) {
				if (containerbase != accessedbase)  {
					rval = PyInt_FromLong(0);
					goto err;
				}
			} 
                        else {
				roles = aq_acquire(container, __roles__);
				if (roles == NULL) {
                                  if (PyErr_ExceptionMatches(
                                      PyExc_AttributeError))
                                    {
                                        PyErr_Clear();
				        if (containerbase != accessedbase) {
						rval = PyInt_FromLong(0);
						goto err;
					}
                                    }
                                  else
                                    goto err;
				}
			}
		}

		/*| # We need to make sure that we are allowed to get
		**| # unprotected attributes from the container.  We are
		**| # allowed for certain simple containers and if the
		**| # container says we can.  Simple containers may also
		**| # impose name restrictions.
		**|
		**| p = Containers(type(container), None)
		**| if p is None:
		**|    p = getattr(container,
		**|        "__allow_access_to_unprotected_subobjects__", None)
		*/

		/** XXX do we need to incref this stuff?  I dont think so */
		p = callfunction2(Containers, OBJECT(container-&gt;ob_type),
                                  Py_None);
		if (p == NULL)
                  goto err;

		if (p == Py_None) {
                        ASSIGN(p, PyObject_GetAttr(container,
				__allow_access_to_unprotected_subobjects__));
			if (p == NULL) 
                          PyErr_Clear();
		}

		/*| if p is not None:
		**|    tp = type(p)
		**|    if tp is not IntType:
		**|       if tp is DictType:
		**|          p = p.get(name, None)
		**|       else:
		**|          p = p(name, value)
		*/

		if (p) {
			if (! PyInt_Check(p)) {
				if (PyDict_Check(p)) {
                                        ASSIGN(p, PyObject_GetItem(p, name));
                                        if (p == NULL)
                                          PyErr_Clear();
				} else {
                                  ASSIGN(p, callfunction2(p, name, value));
                                  if (p == NULL)
                                    goto err;
				}
			}
		}

		/*| if not p:
		**|    if containerbase is accessedbase:
		**|	  raise Unauthorized, cleanupName(name, value)
		**|    else:
		**|       return 0
		*/
               
		if (p == NULL || ! PyObject_IsTrue(p)) {
			Py_XDECREF(p);
			if (containerbase == accessedbase) {
				unauthErr(name, value);
				goto err;
			} else {
				rval = PyInt_FromLong(0);
				goto err;
			}
		}
                else
                  Py_DECREF(p);

		/*| if roles is _noroles: return 1
		*/

		if (roles == NULL) {
			rval = PyInt_FromLong(1);
			goto err;
		}

		/*| # We are going to need a security-aware object to pass
		**| # to allowed().  We'll use the container
		**| 
		**| value = container
		*/

		value = container; 	/* Both are borrowed references */

	} /* if (roles == NULL) */

	/*| # Short-circuit tests if we can
	**| try:
	**|    if roles is None or 'Anonymous' in roles: return 1
	**| except TypeError:
	**|     LOG("Zope Security Policy", PROBLEM, '"%s' passed as roles"
	**|		" during validation of '%s' is not a sequence." % 
	**|		('roles', name))
	**|	raise
	*/

	if (roles == Py_None) {
		rval = PyInt_FromLong(1);
		goto err;
	}
        else
        {
          int i;
          i = PySequence_Contains(roles, Anonymous);
          if (i &gt; 0)
            {
              rval = PyInt_FromLong(1);
              goto err;
            }
          else if (i &lt; 0)
            { /* Error */
              PyObject *m, *t, *v, *tb;

              if (!PyErr_ExceptionMatches(PyExc_TypeError))
                goto err;
              PyErr_Fetch(&amp;t, &amp;v, &amp;tb);
              
              m=PyObject_Repr(roles);
              if (m) ASSIGN(m, Py_BuildValue("OO", m, name));
              if (m) ASSIGN(m, PyString_Format(NoSequenceFormat, m));
              if (m) ASSIGN(m, PyObject_CallFunction(LOG, "sOO",
                     "Zope Security Policy", PROBLEM, m)); 
              Py_XDECREF(m);
              PyErr_Restore(t, v, tb);
              goto err;
            }
        }

	/*| # Check executable security
	**| stack = context.stack
	**| if stack:
	*/

	stack = PyObject_GetAttr(context, stack_str);
	if (stack == NULL) goto err;

	if (PyObject_IsTrue(stack)) {
		PyObject *eo;
		PyObject *owner;
		PyObject *proxy_roles;

	/*|    eo = stack[-1]
	**|    # If the executable had an owner, can it execute?
	**|    owner = eo.getOwner()
	**|    if (owner is not None) and not owner.allowed(value, roles)
	**| 	  # We don't want someone to acquire if they can't 
	**|	  # get an unacquired!
	**|	  if accessedbase is containerbase:
	**|	     raise Unauthorized, ('You are not authorized to'
	**|		'access &lt;em&gt;%s&lt;/em&gt;.' % cleanupName(name, value))
	**|       return 0
	*/

		eo = PySequence_GetItem(stack, -1);
		if (eo == NULL) goto err;

		if (ownerous) {	/* Tabbing not adjusted for diff reasons*/

                owner = PyObject_GetAttr(eo, getOwner_str);
                if (owner) ASSIGN(owner, PyObject_CallObject(owner, NULL));
                if (owner ==NULL) 
                  {
                    Py_DECREF(eo);
                    goto err;
                  }

		if (owner != Py_None) {
                  ASSIGN(owner,PyObject_GetAttr(owner, allowed_str));
                  if (owner)
                    ASSIGN(owner, callfunction2(owner, value, roles));
                  if (owner == NULL)
                    {
                      Py_DECREF(eo);
                      goto err;
                    }

                  if (! PyObject_IsTrue(owner))
                    {
                      Py_DECREF(owner);
                      Py_DECREF(eo);
                      if (accessedbase == containerbase) {
                        unauthErr(name, value);
                      } 
                      else rval = PyInt_FromLong(0);
                      goto err;
                    }
		}
		Py_DECREF(owner);

		} /* End of if ownerous */

	/*|    # Proxy roles, which are a lot safer now
	**|    proxy_roles = getattr(eo, "_proxy_roles", None)
	**|    if proxy_roles:
	**|       for r in proxy_roles:
	**|          if r in roles: return 1
	**|
	**|       # proxy roles actually limit access!
	**|       if accessedbase is containerbase:
	**|	     raise Unauthorized, ('You are not authorized to access'
	**|		'&lt;em&gt;%s&lt;/em&gt;.' % cleanupName(name, value))
	**|
	**|	  return 0
	*/
		proxy_roles = PyObject_GetAttr(eo, _proxy_roles_str);
                Py_DECREF(eo);
		if (proxy_roles == NULL) 
                  {
                    PyErr_Clear();
                  }
                else if (PyObject_IsTrue(proxy_roles)) 
                  {
                    int i, l, contains=0;
                    PyObject *r;
                    if (PyTuple_Check(proxy_roles)) 
                      {
                        l=PyTuple_GET_SIZE(proxy_roles);
                        for (i=0; i &lt; l; i++)
                          {
                            r=PyTuple_GET_ITEM(proxy_roles, i);
                            if ((contains = PySequence_Contains(roles, r)))
                              break;
                          }
                      }
                    else 
                      {
                        l=PySequence_Size(proxy_roles);
                        if (l &lt; 0) contains = -1;
                        for (i=0; i &lt; l; i++)
                          {
                            if ((r=PySequence_GetItem(proxy_roles, i)))
                              {
                                contains = PySequence_Contains(roles, r);
                                Py_DECREF(r);
                              }
                            else
                              contains = -1;
                            if (contains &lt; 0)                          
                              break;
                          }
                      }
                    Py_DECREF(proxy_roles);

                    if (contains &gt; 0)
                      rval = PyInt_FromLong(contains);
                    else if (contains == 0) {
                      if (accessedbase == containerbase) {
                        unauthErr(name, value);
                      }
                      else rval = PyInt_FromLong(contains);
                    }
                    goto err;
                  }
                else 
                  Py_DECREF(proxy_roles);
	} /* End of stack check */

	/*| try:
	**|    if context.user.allowed(value, roles): return 1
	**| except AttributeError: pass
	*/
	if (authenticated) { /* Authentication skip for public only access */
	user = PyObject_GetAttr(context, user_str);
        if (user) ASSIGN(user, PyObject_GetAttr(user, allowed_str));
        if (user == NULL)
          {
            if (PyErr_ExceptionMatches(PyExc_AttributeError))
              PyErr_Clear();
            else
              goto err;
          }
        else
          {
            ASSIGN(user, callfunction2(user, value, roles));
            if (user == NULL) goto err;
            if (PyObject_IsTrue(user))
              {
                rval = PyInt_FromLong(1);
                Py_DECREF(user);
                goto err;
              }
            Py_DECREF(user);
          }
        } /* End of authentiction skip for public only access */

	/*| # we don't want someone to acquire if they can't get an
	**| # unacquired!
	**| if accessedbase is containerbase:
	**|   raise Unauthorizied, ("You are not authorized to access"
	**|	 "&lt;em&gt;%s&lt;/em&gt;." % cleanupName(name, value))
	**| return 0
	*/


        if (accessedbase == containerbase) 
          unauthErr(name, value);
        else
          rval = PyInt_FromLong(0);        
  err:

	Py_XDECREF(stack);
	Py_XDECREF(roles);
	Py_XDECREF(containerbase);
	Py_XDECREF(accessedbase);

	return rval;
}
</t>
<t tx="ekr.20040104185913.486">@ ** ZopeSecurityPolicy_checkPermission **
@c

static PyObject *ZopeSecurityPolicy_checkPermission(PyObject *self,
	PyObject *args) {

	PyObject *permission = NULL;
	PyObject *object = NULL;
	PyObject *context = NULL;
	PyObject *roles;
	PyObject *result = NULL;
	PyObject *user;

	/*| def checkPermission(self, permission, object, context)
	*/

	if (unpacktuple3(args, "checkPermission", 3, 
                         &amp;permission, &amp;object, &amp;context) &lt; 0)
		return NULL;

	/*| roles = rolesForPermissionOn(permission, object)
	*/

	roles = c_rolesForPermissionOn(self, permission, object, OBJECT(NULL));
	if (roles == NULL)
          return NULL;

	/*| if type(roles) is StringType:
	**|	roles = [roles]
	*/

	if (PyString_Check(roles)) {
          PyObject *r;

          r = PyList_New(1);
          if (r == NULL) {
            Py_DECREF(roles);
            return NULL;
          }
          /* Note: ref to roles is passed to the list object. */
          PyList_SET_ITEM(r, 0, roles);
          roles = r;
	}

	/*| return context.user.allowed(object, roles)
	*/

	user = PyObject_GetAttr(context, user_str);
	if (user != NULL) {
          ASSIGN(user, PyObject_GetAttr(user, allowed_str));
          if (user != NULL) {
            result = callfunction2(user, object, roles);
            Py_DECREF(user);
          }
	}

	Py_DECREF(roles);

	return result;
}
</t>
<t tx="ekr.20040104185913.487">@ ** ZopeSecurityPolicy_dealloc **
@c

static void ZopeSecurityPolicy_dealloc(ZopeSecurityPolicy *self) {

	Py_DECREF(self-&gt;ob_type);	/* Extensionclass init incref'd */
	PyMem_DEL(self);  
}
</t>
<t tx="ekr.20040104185913.488">@ SecurityManager
@c

#define CHECK_SECURITY_MANAGER_STATE(self, R) \
UNLESS (self-&gt;policy) { \
    PyErr_SetString(PyExc_AttributeError, "_policy"); return R; } \
UNLESS (self-&gt;context) { \
    PyErr_SetString(PyExc_AttributeError, "_policy"); return R; }

#define GET_SECURITY_MANAGER_VALIDATE(self, R) \
if (self-&gt;validate == NULL &amp;&amp; \
    ((self-&gt;validate = PyObject_GetAttr(self-&gt;policy, validate_str)) \
      == NULL)) return R;


static PyObject *
SecurityManager_validate(SecurityManager *self, PyObject *args)
{
PyObject *accessed=Py_None, *container=Py_None, *name=Py_None, 
  *value=Py_None, *roles=NULL;

if (unpacktuple5(args, "validate", 0,
                     &amp;accessed, &amp;container, &amp;name, &amp;value, &amp;roles) &lt; 0)
  return NULL;

CHECK_SECURITY_MANAGER_STATE(self, NULL);
GET_SECURITY_MANAGER_VALIDATE(self, NULL);

if (roles== NULL)
  return callfunction5(self-&gt;validate, 
                       accessed, container, name, value, self-&gt;context);
return callfunction6(self-&gt;validate, 
                     accessed, container, name, value, self-&gt;context, roles);
}
</t>
<t tx="ekr.20040104185913.489">static PyObject *
SecurityManager_validateValue(SecurityManager *self, PyObject *args)
{
  PyObject *value=Py_None, *roles=NULL;
  
  if (unpacktuple2(args, "validateValue", 1, &amp;value, &amp;roles) &lt; 0) return NULL;
          
  CHECK_SECURITY_MANAGER_STATE(self, NULL);
  GET_SECURITY_MANAGER_VALIDATE(self, NULL);
  
  if (roles==NULL) 
    return callfunction5(self-&gt;validate, 
                         Py_None, Py_None, Py_None, value, self-&gt;context);
  return callfunction6(self-&gt;validate, 
                       Py_None, Py_None, Py_None, value, self-&gt;context, roles);
}
</t>
<t tx="ekr.20040104185913.490">static PyObject *
SecurityManager_DTMLValidate(SecurityManager *self, PyObject *args)
{
  PyObject *accessed=Py_None, *container=Py_None, *name=Py_None, 
    *value=Py_None, *md=NULL;
  
  if (unpacktuple5(args, "DTMLValidate", 0,
                   &amp;accessed, &amp;container, &amp;name, &amp;value, &amp;md) &lt; 0)
    return NULL;

  CHECK_SECURITY_MANAGER_STATE(self, NULL);
  GET_SECURITY_MANAGER_VALIDATE(self, NULL);
  
  return callfunction5(self-&gt;validate, 
                       accessed, container, name, value, self-&gt;context);
}
</t>
<t tx="ekr.20040104185913.491">static PyObject *
SecurityManager_checkPermission(SecurityManager *self, PyObject *args)
{
  PyObject *permission, *object;
  
  if (unpacktuple2(args, "checkPermission", 2, &amp;permission, &amp;object) &lt; 0)
    return NULL;

  CHECK_SECURITY_MANAGER_STATE(self, NULL);
  if (self-&gt;checkPermission == NULL &amp;&amp; 
      ((self-&gt;checkPermission = PyObject_GetAttr(self-&gt;policy, 
                                                 checkPermission_str)) 
       == NULL)) return NULL;

  return callfunction3(self-&gt;checkPermission, 
                       permission, object, self-&gt;context);
}
</t>
<t tx="ekr.20040104185913.492">static void 
SecurityManager_dealloc(SecurityManager *self)
{
  Py_XDECREF(self-&gt;thread_id);
  Py_XDECREF(self-&gt;context);
  Py_XDECREF(self-&gt;policy);
  Py_XDECREF(self-&gt;validate);
  Py_XDECREF(self-&gt;checkPermission);
  Py_DECREF(self-&gt;ob_type);	/* Extensionclass init incref'd */
  PyMem_DEL(self);  
}
</t>
<t tx="ekr.20040104185913.493">static PyObject *
SecurityManager_getattro(SecurityManager *self, PyObject *name)
{
  if (PyString_Check(name) &amp;&amp; PyString_AS_STRING(name)[0]=='_')
    {
      if (strcmp(PyString_AS_STRING(name), "_thread_id")==0 
          &amp;&amp; self-&gt;thread_id)
        {
          Py_INCREF(self-&gt;thread_id);
          return self-&gt;thread_id;
        }
      else if (strcmp(PyString_AS_STRING(name), "_context")==0 
               &amp;&amp; self-&gt;context)
        {
          Py_INCREF(self-&gt;context);
          return self-&gt;context;
        }
      else if (strcmp(PyString_AS_STRING(name), "_policy")==0 
               &amp;&amp; self-&gt;policy)
        {
          Py_INCREF(self-&gt;policy);
          return self-&gt;policy;
        }
    }

  return Py_FindAttr(OBJECT(self), name);
}
</t>
<t tx="ekr.20040104185913.494">static int 
SecurityManager_setattro(SecurityManager *self, PyObject *name, PyObject *v)
{
  if (v &amp;&amp; PyString_Check(name) &amp;&amp; PyString_AS_STRING(name)[0]=='_')
    {
      if (strcmp(PyString_AS_STRING(name), "_thread_id")==0)
        {
          Py_INCREF(v);
          ASSIGN(self-&gt;thread_id, v);
          return 0;
        }
      else if (strcmp(PyString_AS_STRING(name), "_context")==0)
        {
          Py_INCREF(v);
          ASSIGN(self-&gt;context, v);
          return 0;
        }
      else if (strcmp(PyString_AS_STRING(name), "_policy")==0)
        {
          Py_INCREF(v);
          ASSIGN(self-&gt;policy, v);
          if (self-&gt;validate)
            {
              Py_DECREF(self-&gt;validate);
              self-&gt;validate=0;
            }
          if (self-&gt;checkPermission)
            {
              Py_DECREF(self-&gt;checkPermission);
              self-&gt;checkPermission=0;
            }
          return 0;
        }
    }
  PyErr_SetObject(PyExc_AttributeError, name);
  return -1;
}
</t>
<t tx="ekr.20040104185913.495">@ ** PermissionRole_init **
@c

static PyObject *PermissionRole_init(PermissionRole *self, PyObject *args) {

	PyObject *name = NULL;
	PyObject *deflt = NULL;

	/*|def __init__(self, name, default=('Manager',)):
	**|  self.__name__ = name
	**|  self._p = "_" + string.translate(name, name_trans) + "_Permission"
	**|  self._d = default
	*/ 

	if (unpacktuple2(args, "__init__", 1, &amp;name, &amp;deflt) &lt; 0) return NULL;

	if (deflt == NULL) deflt = defaultPermission;

        UNLESS(self-&gt;_p = permissionName(name)) return NULL;

	self-&gt;__name__ = name;
	Py_INCREF(name);

	self-&gt;__roles__ = deflt;
	Py_INCREF(deflt);

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20040104185913.496">@ ** PermissionRole_of **
@c

static PyObject *PermissionRole_of(PermissionRole *self, PyObject *args) {

	PyObject *parent = NULL;
	imPermissionRole *r = NULL;
	PyObject *_p = NULL;
	PyObject *result = NULL;

	/*|def __of__(self, parent):
	*/

	if (unpacktuple1(args,"__of__", 1, &amp;parent) &lt; 0) return NULL;

	/*| r = imPermissionRole()
	*/

        r = (imPermissionRole*)PyObject_CallObject(imPermissionRoleObj, NULL);
	if (r == NULL) return NULL;

	/*| r._p = self._p
	*/

	r-&gt;_p = self-&gt;_p;
	Py_INCREF(r-&gt;_p);

	/*| r._pa = parent
	*/

	r-&gt;_pa = parent;
	Py_INCREF(parent);
	
	/*| r._d = self._d
	*/

	r-&gt;__roles__ = self-&gt;__roles__;
	Py_INCREF(r-&gt;__roles__);


	/*| p = getattr(parent, 'aq_inner', None)
	**| if p is not None:
	**|	return r.__of__(p)
	**| else:
	**|	return r
	*/


	if (aq_isWrapper(parent)) {
		_p = aq_inner(parent);
		result = callmethod1(OBJECT(r), __of__, _p);
		Py_DECREF(_p);
		/* Dont need goto */
	} else {
		result = OBJECT(r);
		Py_INCREF(r);
	}

	Py_DECREF(r);

	return result;
}
</t>
<t tx="ekr.20040104185913.497">@ ** PermissionRole_dealloc **
@c

static void PermissionRole_dealloc(PermissionRole *self) {

	Py_XDECREF(self-&gt;__name__);

	Py_XDECREF(self-&gt;_p);

	Py_XDECREF(self-&gt;__roles__);

	Py_XDECREF(self-&gt;ob_type);	/* Extensionclass init incref'd */

	PyMem_DEL(self);  
}
</t>
<t tx="ekr.20040104185913.498">@ ** imPermissionRole_of **
@c

static PyObject *imPermissionRole_of(imPermissionRole *self, PyObject *args) {

	PyObject *parent = NULL;
	PyObject *obj = NULL;
	PyObject *n = NULL;
	PyObject *r = NULL;
	PyObject *roles = NULL;
	PyObject *result = NULL;
	PyObject *tobj = NULL;

	/*|def __of__(self, parent):
	**| obj = parent
	**| n = self._p
	**| r = None
	*/

	if (unpacktuple1(args, "__of__", 1, &amp;parent) &lt; 0) return NULL;

	obj = parent;
	Py_INCREF(obj);

	n = self-&gt;_p;
	if (n == NULL) {
                /* XXX Should not be possible */
		PyErr_SetString(PyExc_AttributeError, "_p");
                Py_DECREF(obj);
                return NULL;
	}
	Py_INCREF(n);

	r = Py_None;
	Py_INCREF(r);
	
	/*| while 1:
	*/
	
	while (1) {

	/*|    if hasattr(obj, n):
	**|       roles = getattr(obj, n)   
	**|
	**|       if roles is None: return 'Anonymous', 
	*/

		roles = PyObject_GetAttr(obj, n);
		if (roles != NULL) {

			if (roles == Py_None) {
				result = AnonymousTuple;
				Py_INCREF(result);
				goto err;
			}

		/*|
		**|	  t = type(roles)
		**|  
		**|	  if t is TupleType:
		**|          # If we get a tuple, then we don't acquire
		**|	     if r is None: return roles
		**|	     return r + list(roles)
		*/
			if (PyTuple_Check(roles)) {
				if (r == Py_None) {
					result = roles;
					roles = NULL;	/* avoid inc/decref */
					goto err;
				} else {
					PyObject *list;
					list = PySequence_List(roles);
                                        if (list != NULL) {
                                          result = PySequence_Concat(r, list);
                                          Py_DECREF(list);
                                        }
					goto err;
				}
			}
		
		/*|
		**|       if t is StringType:
		**|          # We found roles set to a name.  Start over
		**|	     # with the new permission name.  If the permission
		**|	     # name is '', then treat as private!
		*/

			if (PyString_Check(roles)) {

		/*|
		**|          if roles:
		**|             if roles != n:
		**|                n = roles
		**|             # If we find a name that is the same as the
		**|             # current name, we just ignore it.
		**|             roles = None
		**|          else:
		**|             return _what_not_even_god_should_do
		**|
		*/
				if (PyObject_IsTrue(roles)) {
                                  if (PyObject_Compare(roles, n) != 0)  {
                                    Py_DECREF(n);
                                    n = roles;
                                    Py_INCREF(n);
                                  }
                                  Py_DECREF(roles);
                                  roles = Py_None;
                                  Py_INCREF(roles);
				} else {
                                  result = _what_not_even_god_should_do;
                                  Py_INCREF(result);
                                  goto err;
				}
			} else {

		/*|       elif roles:
		**|          if r is None: r = list(roles)
		**|          else: r = r+list(roles)
		*/
                          if (PyObject_IsTrue(roles)) {
                            if (r == Py_None) {
                              Py_DECREF(r);
                              r = PySequence_List(roles);
                            } else {
                              PyObject *list;

                              list = PySequence_List(roles);
                              if (list != NULL) {
                                ASSIGN(r, PySequence_Concat(r, list));
                                Py_DECREF(list);
                                if (r == NULL)
                                  goto err;
                              }
                              else
                                goto err;
                            }
                          }
			}
		}
                else
                  PyErr_Clear();

	/*|    obj = getattr(obj, 'aq_inner', None)
	**|    if obj is None: break
	**|    obj = obj.aq_parent
	*/

		if (!aq_isWrapper(obj)) break;
		tobj = aq_inner(obj);
		if (tobj == NULL) goto err;
		Py_DECREF(obj);
		obj = tobj;

		if (obj == Py_None) break;
		if (!aq_isWrapper(obj)) break;
		tobj = aq_parent(obj);
		if (tobj == NULL) goto err;
		Py_DECREF(obj);
		obj = tobj;
		
	}	/* end while 1 */

	/*|
	**| if r is None: r = self._d
	*/

	if (r == Py_None) {
		Py_DECREF(r);
		r = self-&gt;__roles__;
		if (r == NULL) goto err;
		Py_INCREF(r);
	}

	/*|
	**| return r
	*/

	result = r;
	Py_INCREF(result);

	err:

	Py_XDECREF(n);
	Py_XDECREF(r);
	Py_XDECREF(obj);
	Py_XDECREF(roles);

	return result;
}
</t>
<t tx="ekr.20040104185913.499">@ ** imPermissionRole_length
@c

static int imPermissionRole_length(imPermissionRole *self) {

	int l;
	PyObject *v;
	PyObject *pa;

	/*|
	**| try:
	**|     v=self._v
	**| except:
	**|     v = self._v = self.__of__(self._pa)
	**|     del self._pa
	**|
	**| return len(v)
	*/

	v = self-&gt;_v;
	if (v == NULL) {
		pa = self-&gt;_pa;
                if (pa == NULL) {
                  PyErr_SetString(PyExc_AttributeError, "_pa");
                  return -1;
                }
		v = callmethod1(OBJECT(self), __of__, pa);
                if (v == NULL)
                  return -1;
		self-&gt;_v = v;
		Py_DECREF(pa);
		self-&gt;_pa = NULL;
	}

	l = PyObject_Length(v);

	return l;
}
</t>
<t tx="ekr.20040104185913.500">@ ** imPermissionRole_get
@c

static PyObject *imPermissionRole_get(imPermissionRole *self,
	int item) {

	PyObject *v;
	PyObject *pa;
	PyObject *result;

	/*| try:
	**|	v = self._v
	**| except:
	**|	v = self._v = self.__of__(self._pa)
	**|	del self._pa
	**| return v[i]
	*/

	v = self-&gt;_v;

	if (v == NULL) {
                pa = self-&gt;_pa;
                if (pa == NULL) {
                  PyErr_SetString(PyExc_AttributeError, "_pa");
                  return NULL;
                }
                v = callmethod1(OBJECT(self), __of__, pa);
                if (v == NULL)
                  return NULL;
                self-&gt;_v = v;
                Py_DECREF(pa);
                self-&gt;_pa = NULL;
	}

	result = PySequence_GetItem(v, item);

	return result;
}
</t>
<t tx="ekr.20040104185913.501">@ ** imPermissionRole_dealloc **
@c

static void imPermissionRole_dealloc(imPermissionRole *self) {
	Py_XDECREF(self-&gt;_p);

	Py_XDECREF(self-&gt;_pa);

	Py_XDECREF(self-&gt;__roles__);

	Py_XDECREF(self-&gt;_v);

	Py_DECREF(self-&gt;ob_type);	/* Extensionclass init incref'd */

	PyMem_DEL(self);  
}
</t>
<t tx="ekr.20040104185913.502">@ ** rolesForPermissionOn
@c

static PyObject *rolesForPermissionOn(PyObject *self, PyObject *args) {
	PyObject *perm = NULL;
	PyObject *object = NULL;
	PyObject *deflt = NULL;

	/*|def rolesForPermissionOn(perm, object, default=('Manager',)):
	**|
	**| """Return the roles that have the permisson on the given object"""
	*/

	if (unpacktuple3(args, "rolesForPermissionOn", 2, 
                         &amp;perm, &amp;object, &amp;deflt) &lt; 0)
		return NULL;
        return c_rolesForPermissionOn(self, perm, object, deflt);
}
</t>
<t tx="ekr.20040104185913.503">static PyObject *
c_rolesForPermissionOn(PyObject *self, PyObject *perm, PyObject *object,
                       PyObject *deflt) {
	imPermissionRole *im = NULL;
	PyObject *result;

	/*| im = imPermissionRole()
	**|
	**| im._p="_"+string.translate(perm, name_trans)+"_Permission"
	**| im._d = default
	**| return im.__of__(object)
	*/

        im = (imPermissionRole*)PyObject_CallObject(imPermissionRoleObj, NULL);
	if (im == NULL)
          return NULL;

	im-&gt;_p = permissionName(perm);
        if (im-&gt;_p == NULL) {
          Py_DECREF(im);
          return NULL;
        }

	if (deflt == NULL) deflt = defaultPermission;
	im-&gt;__roles__ = deflt;
	Py_INCREF(deflt);

	result = callmethod1(OBJECT(im), __of__, object);
	Py_DECREF(im);

	return result;
}
</t>
<t tx="ekr.20040104185913.504">@ ** permissionName ** ** Can silently truncate permission names if they are really long
@c

static PyObject *permissionName(PyObject *name) {
	char namebuff[512];
	register int len = sizeof(namebuff) - 1;
	char *c = namebuff;
	char *in;
	char r;

	*c = '_';

	c++;
	len--;

	in = PyString_AsString(name);
        if (in == NULL)
          return NULL;
	
	while (len &amp;&amp; *in) {
		r = *(in++);
		if (!isalnum(r)) r='_';
		*(c++) = r;
		len--;
	}

	if (len) {
		in = "_Permission";
		while (len &amp;&amp; *in) {
			*(c++) = *(in++);
			len--;
		}
	}

	*c = '\0';	/* Saved room in len */

	return PyString_FromString(namebuff);

}
</t>
<t tx="ekr.20040104185913.505">@ def guarded_getattr(inst, name, default=_marker):
@c

static PyObject *
guarded_getattr(PyObject *inst, PyObject *name, PyObject *default_, 
                PyObject *validate)
{
  PyObject *v=0, *t=0;
  int i;

  /* if name[:1] != '_': */
  if (PyString_Check(name) &amp;&amp; PyString_AS_STRING(name)[0] != '_')
    {

      /*
        # Try to get the attribute normally so that unusual
        # exceptions are caught early.
        try: v = getattr(inst, name)
        except AttributeError:
            if default is not _marker:
                return default
            raise
       */

      v=PyObject_GetAttr(inst, name);
      if (v==NULL)
        {
          if (default_ &amp;&amp; PyErr_Occurred() == PyExc_AttributeError)
            {
              PyErr_Clear();
              Py_INCREF(default_);
              return default_;
            }
          return NULL;
        }

      /*
        if Containers(type(inst)):
            # Simple type.  Short circuit.
            return v
      */
      t=callfunction1(Containers, OBJECT(inst-&gt;ob_type));
      if (t==NULL) goto err;
      i=PyObject_IsTrue(t);
      if (i &lt; 0) goto err;
      Py_DECREF(t);
      if (i) return v;

      /*
        # Filter out the objects we can't access.
        if hasattr(inst, 'aq_acquire'):
            return inst.aq_acquire(name, aq_validate, validate)
       */
      if (aq_isWrapper(inst))
        {
          ASSIGN(v, aq_Acquire(inst, name, aq_validate, validate, 1, NULL, 0));
          return v;
        }

      /*
        # Or just try to get the attribute directly.
        if validate(inst, inst, name, v):
            return v
       */
      validate=callfunction4(validate, inst, inst, name, v);
      if (validate==NULL) goto err;
      i=PyObject_IsTrue(validate);
      Py_DECREF(validate);
      if (i &lt; 0) goto err;
      if (i &gt; 0) return v;
      
      unauthErr(name, v);
    err:
      Py_DECREF(v);
      return NULL;
    }

  /* raise Unauthorized, name */
  PyErr_SetObject(Unauthorized, name);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.506">static PyObject *
module_guarded_getattr(PyObject *ignored, PyObject *args)
{
  PyObject *inst, *name, *default_=0, *validate;

  if (unpacktuple3(args, "guarded_getattr", 2, &amp;inst, &amp;name, &amp;default_) &lt; 0)
    return NULL;

  /*
        validate = getSecurityManager().validate
  */
  validate=PyObject_CallObject(getSecurityManager, NULL);
  if (! validate) return NULL;
  ASSIGN(validate, PyObject_GetAttr(validate, validate_str));
  if (! validate) return NULL;
  ASSIGN(validate, guarded_getattr(inst, name, default_, validate));

  return validate;
}
</t>
<t tx="ekr.20040104185913.507">@ def aq_validate(inst, obj, name, v, validate):     return validate(inst, obj, name, v)
@c

static PyObject *
module_aq_validate(PyObject *ignored, PyObject *args)
{
  PyObject *inst, *obj, *name, *v, *validate;

  if (unpacktuple5(args, "validate", 0,
                   &amp;inst, &amp;obj, &amp;name, &amp;v, &amp;validate) &lt; 0) return NULL;
  return callfunction4(validate, inst, obj, name, v);
}
</t>
<t tx="ekr.20040104185913.508">static PyObject *
dtml_guarded_getattr(PyObject *self, PyObject *args)
{
  PyObject *ob, *name, *default_=0, *validate;

  if (unpacktuple3(args, "guarded_getattr", 2, &amp;ob, &amp;name, &amp;default_) &lt; 0)
    return NULL;

  
  UNLESS (validate = PyObject_GetAttr(self, validate_str)) 
    {
      /* This section is pure paranoia at this point. It was necessary
         while debugging. */
      PyErr_Clear();
      validate=PyObject_CallObject(getSecurityManager, NULL);
      if (! validate) return NULL;
      ASSIGN(validate, PyObject_GetAttr(validate, validate_str));
      if (! validate) return NULL;
    }

  ASSIGN(validate, guarded_getattr(ob, name, default_, validate));

  return validate;
}
</t>
<t tx="ekr.20040104185913.509">static struct PyMethodDef dtml_methods[] = {
  {"guarded_getattr", (PyCFunction)dtml_guarded_getattr, 
   METH_VARARGS|METH_KEYWORDS, "" },
  {NULL,	NULL}
};


/* ----------------------------------------------------------------
** Module initialization
** ----------------------------------------------------------------
*/
#define IMPORT(module, name) if ((module = PyImport_ImportModule(name)) == NULL) return;
#define GETATTR(module, name) if ((name = PyObject_GetAttrString(module, #name)) == NULL) return;

void initcAccessControl(void) {
	PyObject *module;
	PyObject *dict;
        PURE_MIXIN_CLASS(RestrictedDTMLMixin,
                         "A mix-in for derivatives of DT_String.String "
                         "that adds Zope security."
                         , dtml_methods);

	if (!ExtensionClassImported) return;

	if (ZopeSecurityPolicy_setup() &lt; 0) return;

	ZopeSecurityPolicyType.tp_getattro =
		(getattrofunc) PyExtensionClassCAPI-&gt;getattro;

	PermissionRoleType.tp_getattro =
		(getattrofunc) PyExtensionClassCAPI-&gt;getattro;

	imPermissionRoleType.tp_getattro =
		(getattrofunc) PyExtensionClassCAPI-&gt;getattro;

	module = Py_InitModule3("cAccessControl",
		cAccessControl_methods,
		"$Id: cAccessControl.c,v 1.17 2002/07/23 14:08:55 matt Exp $\n");

	aq_init(); /* For Python &lt;= 2.1.1, aq_init() should be after
                      Py_InitModule(). */

	dict = PyModule_GetDict(module);

	PyDict_SetItemString(dict, "_what_not_even_god_should_do",
		_what_not_even_god_should_do);

        PyExtensionClass_Export(dict, "RestrictedDTMLMixin",
                                RestrictedDTMLMixinType);

	PyExtensionClass_Export(dict, "ZopeSecurityPolicy",
		ZopeSecurityPolicyType);

        PyExtensionClass_Export(dict,"SecurityManager",
                SecurityManagerType);

	PyExtensionClass_Export(dict, "PermissionRole",
		PermissionRoleType);

	PyExtensionClass_Export(dict, "imPermissionRole",
		imPermissionRoleType);

 	imPermissionRoleObj = PyMapping_GetItemString(dict, 
                                                      "imPermissionRole");

        aq_validate = PyMapping_GetItemString(dict, "aq_validate");

	/*| from SimpleObjectPolicies import Containers
	*/

	IMPORT(module, "AccessControl.SimpleObjectPolicies");
	GETATTR(module, Containers);
	Py_DECREF(module);
	module = NULL;

	/*| from unauthorized import Unauthorized
	*/

	IMPORT(module, "AccessControl.unauthorized");
	GETATTR(module, Unauthorized);
	Py_DECREF(module);
	module = NULL;

	/*| from AccessControl.SecurityManagement import getSecurityManager
	*/

	IMPORT(module, "AccessControl.SecurityManagement");
	GETATTR(module, getSecurityManager);
	Py_DECREF(module);
	module = NULL;

	/*| from zLOG import LOG, PROBLEM
	*/

	IMPORT(module, "zLOG");
	GETATTR(module, LOG);
	GETATTR(module, PROBLEM);
	Py_DECREF(module);
	module = NULL;
}
</t>
<t tx="ekr.20040104185913.510">&lt;&lt; copyright &gt;&gt;

"""Access control exceptions
"""

import zExceptions

@others
</t>
<t tx="ekr.20040104185913.512">class Unauthorized(zExceptions.Unauthorized):
	@others
</t>
<t tx="ekr.20040104185913.513">def getValueName(self):
    v=self.value
    n=getattr(v, 'getId', v)
    if n is v:  n=getattr(v, 'id', v)
    if n is v:  n=getattr(v, '__name__', v)
    if n is not v:
        if callable(n):
            try: n = n()
            except TypeError: pass
        return n

    c = getattr(v, '__class__', type(v))
    c = getattr(c, '__name__', 'object')
    return "a particular %s" % c
</t>
<t tx="ekr.20040104185913.514"></t>
<t tx="ekr.20040104185913.515">&lt;&lt; copyright &gt;&gt;


######################################################################
# Set up unit testing framework
#
# The following code should be at the top of every test module:
#
# import os, sys
# execfile(os.path.join(sys.path[0], 'framework.py'))
#
# ...and the following at the bottom:
#
# framework()


# Find the Testing package
if not sys.modules.has_key('Testing'):
    p0 = sys.path[0]
    if p0 and __name__ == '__main__':
        os.chdir(p0)
        p0 = ''
    p = d = os.path.abspath(os.curdir)
    while d:
        if os.path.isdir(os.path.join(p, 'Testing')):
            sys.path[:1] = [p0, os.pardir, p]
            break
        p, d = os.path.split(p)
    else:
        print 'Unable to locate Testing package.'
        sys.exit(1)

import Testing, unittest
execfile(os.path.join(os.path.split(Testing.__file__)[0], 'common.py'))
</t>
<t tx="ekr.20040104185913.516">&lt;&lt; copyright &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.518">class ResultObject:
    """ result object used for keeping results from the
        ZPublisher.Zope() calls

        $Id: ResultObject.py,v 1.4 2002/08/14 21:27:32 mj Exp $
    """
	@others
</t>
<t tx="ekr.20040104185913.519">def __str__(self,expected=-1,with_output=1):
    s  = '\n'
    s+= '-'*78
    s+= "\nRequest: %s" % self.request
    s+= "\nUser: %s" % self.user
    s+= "\nExpected: %s" % expected + "  got: %s %s" % (self.code,self.return_text)
    if with_output:
        s+= "\nOutput:"
        s+= self.output
    s+= "\n"

    return s
</t>
<t tx="ekr.20040104185913.520">__repr__ = __str__

def __call__(self,expected=-1):
    return self.__str__(expected)
</t>
<t tx="ekr.20040104185913.521">&lt;&lt; copyright &gt;&gt;

import sys, re, unittest, cStringIO
import ZPublisher, ResultObject
import OFS.Application
import AccessControl.SecurityManagement

# Set up a publishable, non-ZODB Zope application.
app = OFS.Application.Application()

@others
</t>
<t tx="ekr.20040104185913.523">def index_html():
    " "
    return "This is index_html."
</t>
<t tx="ekr.20040104185913.524">app.index_html = index_html  # Will index_html ever go away? ;-)

class BoboApplication:
	# OFS.Application has a __bobo_traverse__ that ZPublisher thinks
    # it should use to find the "real" root of the application.
    # This class gets around that.

	@others</t>
<t tx="ekr.20040104185913.526">def __bobo_traverse__(self, request, name=None):
    return app
</t>
<t tx="ekr.20040104185913.527"># ZPublisher will look for these vars.
bobo_application = BoboApplication()
zpublisher_validated_hook=AccessControl.SecurityManagement.newSecurityManager
__bobo_before__=AccessControl.SecurityManagement.noSecurityManager


class SecurityBase(unittest.TestCase) :
    """ Base class for all security tests
    $Id: SecurityBase.py,v 1.7 2002/08/14 21:27:32 mj Exp $
    """
	status_regex = re.compile("Status: ([0-9]{1,4}) (.*)",re.I)\
	@others
</t>
<t tx="ekr.20040104185913.529">################################################################
# print the object hierachy
################################################################

def _testHierarchy(self):
    """ print all test objects, permissions and roles """
    self._PrintTestEnvironment(root=self.root.test)
</t>
<t tx="ekr.20040104185913.530">def _PrintTestEnvironment(self,root):
    """ print recursive all objects """

    print '....'*len(root.getPhysicalPath()),root.getId()

    folderObjs = []

    for id,obj in root.objectItems():

        if obj.meta_type in ['Folder','TestFolder']:
            folderObjs.append(obj)

        else:
            print '    '*(1+len(root.getPhysicalPath())),obj.getId(),
            print getattr(obj,"__roles__",(None,))

    for folder in folderObjs:
        self._PrintTestEnvironment(folder)
</t>
<t tx="ekr.20040104185913.531">################################################################
# Check functions for permissions, roles and friends
################################################################

def _checkPermission(self, user, hier, perm, expected):
    """ permission check on an objects for a given user.

       -- 'user' is a user object as returned from a user folder

       -- 'hier' is the path to the object in the notation 'f1.f2.f3.obj'

       -- 'perm' is a permission name

       -- 'expected' is either 0 or 1
    """

    s = "self.root.%s" % hier
    obj = eval(s)

    res = user.has_permission(perm,obj)

    if res != expected:
        raise AssertionError, \
            self._perm_debug (s,perm,res,expected)
</t>
<t tx="ekr.20040104185913.532">def _checkRoles(self,hier,expected_roles=()):
    """ check roles for a given object.

       -- 'hier' is the path to the object in the notation 'f1.f2.f3.obj'

       -- 'expected_roles' is a sequence of expected roles

    """

    s = "self.root.%s.__roles__" % hier
    roles = eval(s)

    same = 0
    if roles is None or expected_roles is None:
        if (roles is None or tuple(roles) == ('Anonymous',)) and (
            expected_roles is None or
            tuple(expected_roles) == ('Anonymous',)):
            same = 1
    else:
        got = {}
        for r in roles: got[r] = 1
        expected = {}
        for r in expected_roles: expected[r] = 1
        if got == expected:  # Dict compare does the Right Thing.
            same = 1
    if not same:
        raise AssertionError, self._roles_debug(hier,roles,expected_roles)
</t>
<t tx="ekr.20040104185913.533">def _checkRequest(self,*args,**kw):
    """ perform a ZPublisher request """


    expected_code = kw.get('expected',200)
    del kw['expected']
    res = apply(self._request,args,kw)

    if expected_code != res.code:
        raise AssertionError, \
           self._request_debug(res,expected_code,args,kw)
</t>
<t tx="ekr.20040104185913.534">################################################################
# Debugging helpers when raising AssertionError
################################################################

def _perm_debug(self, obj , perm, res, expected):
    s+= 'Object: %s' % obj
    s+= ', Permission: %s' % perm
    s+= ', has permission: %s' % res
    s+= ', expected: %s' % expected

    return s
</t>
<t tx="ekr.20040104185913.535">def _roles_debug(self,hier,got_roles,expected_roles):

    s = 'Object: %s' % hier
    s+= ', has roles: %s' % `got_roles`
    s+= ', expected roles: %s' % `expected_roles`

    return s
</t>
<t tx="ekr.20040104185913.536">def _request_debug(self,res,expected,args,kw):

    s = 'Args: %s' % str(args)
    s+= ', KW: %s' % str(kw)
    s+= '\n%s\n' % res.__str__(with_output=0,expected=expected)

    return s
</t>
<t tx="ekr.20040104185913.537">def _request(self,*args,**kw):
    """ perform a Zope request """

    io =cStringIO.StringIO()
    kw['fp']=io
    # Publish this module.
    testargs = (__name__,) + args
    real_stdout = sys.stdout
    garbage_out = cStringIO.StringIO()
    sys.stdout = garbage_out  # Silence, ZPublisher!
    try:
        ZPublisher.test(*testargs,**kw)
    finally:
        sys.stdout = real_stdout
    outp = io.getvalue()
    mo = self.status_regex.search(outp)

    code,txt = mo.groups()

    res = ResultObject.ResultObject()
    res.request     = args
    res.user        = kw.get('u','')
    res.code        = int(code)
    res.return_text = txt
    res.output      = outp

    return res
</t>
<t tx="ekr.20040104185913.538">&lt;&lt; regressionSecurity declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.539">#!/usr/bin/env python2.1

&lt;&lt; copyright &gt;&gt;

# $Id: regressionSecurity.py,v 1.5 2002/08/14 21:27:32 mj Exp $

import os, sys, unittest

import ZODB
import SecurityBase
from OFS.Folder import Folder
from OFS.SimpleItem  import SimpleItem
from AccessControl import ClassSecurityInfo,getSecurityManager
from AccessControl.User import nobody
import Globals


# let's define some permissions first

MAGIC_PERMISSION1 = 'Magic Permission 1'
MAGIC_PERMISSION2 = 'Magic Permission 2'


</t>
<t tx="ekr.20040104185913.540">class TestObject(SimpleItem):
    """ test object """
	&lt;&lt; class TestObject declarations &gt;&gt;
	@others

    security.setPermissionDefault(MAGIC_PERMISSION1, ("Manager","Owner"))
    security.setPermissionDefault(MAGIC_PERMISSION2, ("TestRole",))
	
Globals.InitializeClass(TestObject)</t>
<t tx="ekr.20040104185913.541">security = ClassSecurityInfo()
__allow_access_to_unprotected_subobjects__ = 0

public_attr     = 1
_protected_attr = 2

</t>
<t tx="ekr.20040104185913.542">def __init__(self,id):
    self.id = id
</t>
<t tx="ekr.20040104185913.543">security.declarePrivate("private_func")
def private_func(self):
    """ private func """
    return "i am private"
</t>
<t tx="ekr.20040104185913.544">def manage_func(self):
    """ should be protected by manager role """
    return "i am your manager function"
</t>
<t tx="ekr.20040104185913.545">security.declareProtected(MAGIC_PERMISSION2,"manage_func2")
def manage_func2(self):
    """ should be protected by manager role """
    return "i am your manager function2"
</t>
<t tx="ekr.20040104185913.546">security.declareProtected(MAGIC_PERMISSION1,"protected_func")
def protected_func(self):
    """ proteced func """
    return "i am protected "
</t>
<t tx="ekr.20040104185913.547">security.declarePublic("public_func")
def public_func(self):
    """ public func """
    return "i am public"
</t>
<t tx="ekr.20040104185913.548">class TestFolder(Folder):
    """ test class """
	@others

    meta_type = 'TestFolder'

    security = ClassSecurityInfo()
	
Globals.InitializeClass(TestFolder)</t>
<t tx="ekr.20040104185913.549">def __init__(self,id):
    self.id = id
</t>
<t tx="ekr.20040104185913.550">def getId(self): return self.id
</t>
<t tx="ekr.20040104185913.551">class User:
	@others</t>
<t tx="ekr.20040104185913.552">def __init__(self,username,password,roles):
    self.username = username
    self.password = password
    self.roles    = roles
</t>
<t tx="ekr.20040104185913.553">def auth(self):
    return "%s:%s" % (self.username,self.password)
</t>
<t tx="ekr.20040104185913.554">def __str__(self):
    return "User(%s:%s:%s)" % (self.username,self.password,self.roles)

 __repr__ = __str__</t>
<t tx="ekr.20040104185913.555">USERS = (
    User('user1','123',[]),
    User('user2','123',[]),
    User('owner','123',('Owner',)),
    User('manager','123',('Manager',))
)

def getAuth(username):

    for user in USERS:
        if user.username==username:
            return "%s:%s" % (user.username,user.password)

    raise KeyError,"no such username: %" % username
</t>
<t tx="ekr.20040104185913.556">class AVeryBasicSecurityTest(SecurityBase.SecurityBase):
	&lt;&lt; class AVeryBasicSecurityTest declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.557">    </t>
<t tx="ekr.20040104185913.558">################################################################
# set up the test hierachy of objects
################################################################

def setUp(self):
    """ my setup """

    self.root = SecurityBase.app
    acl = self.root.acl_users

    for user in USERS:
        try: acl._delUsers( user.username )
        except: pass

    for user in USERS:
        acl._addUser(user.username,user.password,user.password,
                        user.roles, [])

    # try to remove old crap

    if 'test' in self.root.objectIds():
        self.root._delObject('test')

    # setup Folder hierarchy

    test     = TestFolder('test')
    f1       = TestFolder('f1')
    f2       = TestFolder('f2')
    f3       = TestFolder('f3')
    obj      = TestObject('obj3')
    anonobj  = TestObject('anonobj')
    anonobj.__roles__ = ('Anonymous',)

    self.root._setObject('test',test)
    self.root.test._setObject('f1',f1)
    self.root.test._setObject('f2',f2)
    self.root.test.f1._setObject('anonobj',anonobj)
    self.root.test.f2._setObject('f3',f3)
    self.root.test.f2.f3._setObject('obj3',obj)
</t>
<t tx="ekr.20040104185913.559">def testNobody(self):
    """ check permissions for nobody user """

    self._checkPermission(nobody,'test.f1',   'View',1)
    self._checkPermission(nobody,'test.f2',   'View',1)
    self._checkPermission(nobody,'test.f2.f3','View',1)
    self._checkPermission(nobody,'test.f1',   MAGIC_PERMISSION1, None)
    self._checkPermission(nobody,'test.f2',   MAGIC_PERMISSION1, None)
    self._checkPermission(nobody,'test.f2.f3',MAGIC_PERMISSION1, None)
</t>
<t tx="ekr.20040104185913.560">def testPermissionAccess(self):
    """ check permission based access """

    self._checkRoles('test.f2.f3.obj3.public_func',     None)
    self._checkRoles('test.f2.f3.obj3.protected_func',  ('Manager','Owner'))
    self._checkRoles('test.f2.f3.obj3.manage_func',     ('Manager',))
    self._checkRoles('test.f2.f3.obj3.private_func',    ())
</t>
<t tx="ekr.20040104185913.561">def testZPublisherAccess(self):
    """ test access through ZPublisher """

    _r = [
           ('/test/f1/',                        None,    200),
           ('/test/f2',                         None,    200),
           ('/test/f2/f3',                      None,    200),
           ('/test/f2/f3/obj3/public_func',     None,    200),
           ('/test/f2/f3/obj3/protected_func',  None,    401),
           ('/test/f2/f3/obj3/manage_func',     None,    401),
           ('/test/f2/f3/obj3/private_func',    None,    401),

           ('/test/f1/',                        getAuth('manager'),    200),
           ('/test/f2',                         getAuth('manager'),    200),
           ('/test/f2/f3',                      getAuth('manager'),    200),
           ('/test/f2/f3/obj3/public_func',     getAuth('manager'),    200),
           ('/test/f2/f3/obj3/protected_func',  getAuth('manager'),    200),
           ('/test/f2/f3/obj3/manage_func',     getAuth('manager'),    200),
           ('/test/f2/f3/obj3/private_func',    getAuth('manager'),    401),

           ('/test/f1/',                        getAuth('owner'),    200),
           ('/test/f2',                         getAuth('owner'),    200),
           ('/test/f2/f3',                      getAuth('owner'),    200),
           ('/test/f2/f3/obj3/public_func',     getAuth('owner'),    200),
           ('/test/f2/f3/obj3/protected_func',  getAuth('owner'),    200),
           ('/test/f2/f3/obj3/manage_func',     getAuth('owner'),    401),
           ('/test/f2/f3/obj3/private_func',    getAuth('owner'),    401),

          ]

    for path,auth,expected in _r:
        if auth:
            res = self._checkRequest(path,u=auth,expected=expected)
        else:
            res = self._checkRequest(path,expected=expected)
</t>
<t tx="ekr.20040104185913.562">def test_suite():
    return unittest.makeSuite(AVeryBasicSecurityTest)
</t>
<t tx="ekr.20040104185913.563">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.564"></t>
<t tx="ekr.20040104185913.565"></t>
<t tx="ekr.20040104185913.566">&lt;&lt; testClassSecurityInfo declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.567">&lt;&lt; copyright &gt;&gt;

""" """

import os, sys, unittest, ZODB, Globals
from AccessControl.SecurityInfo import ClassSecurityInfo
from OFS.Folder import Folder


</t>
<t tx="ekr.20040104185913.568">class ClassSecurityInfoTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.569">def testSetPermissionDefault(self):
    """Test setting default roles for permissions."""

    # Setup a test class with default role -&gt; permission decls.
    class Test(Folder):
        """Test class"""
        __ac_roles__ = ('Role A', 'Role B', 'Role C')

        meta_type = "Test"

        security = ClassSecurityInfo()

        security.setPermissionDefault(
            'Test permission',
            ('Manager', 'Role A', 'Role B', 'Role C')
            )

        security.declareProtected('Test permission', 'foo')
        def foo(self, REQUEST=None):
            """ """
            pass

    # Do class initialization.
    Globals.InitializeClass(Test)

    # Now check the resulting class to see if the mapping was made
    # correctly. Note that this uses carnal knowledge of the internal
    # structures used to store this information!
    object = Test()
    imPermissionRole = object.foo__roles__
    self.failUnless(len(imPermissionRole) == 4)
    for item in ('Manager', 'Role A', 'Role B', 'Role C'):
        self.failUnless(item in imPermissionRole)
</t>
<t tx="ekr.20040104185913.570">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ClassSecurityInfoTests))
    return suite
</t>
<t tx="ekr.20040104185913.571">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.572">&lt;&lt; testDeprecatedAPI declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.573">&lt;&lt; copyright &gt;&gt;

"""Tests for the DeprecationWarning thrown by accessing hasRole

To be removed together with the API in due time.

"""

__rcs_id__='$Id: testDeprecatedAPI.py,v 1.4 2002/08/14 21:28:08 mj Exp $'
__version__='$Revision: 1.4 $'[11:-2]

import ZODB # Sigh. Persistent needs to be set, so we import ZODB.
from AccessControl import User
import unittest, warnings

</t>
<t tx="ekr.20040104185913.574">class DeprecatedAPI(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.575">def setUp(self):
    # We test for warnings by turning them into exceptions
    warnings.filterwarnings('error', category=DeprecationWarning,
        module='AccessControl')
</t>
<t tx="ekr.20040104185913.576">def testDeprecatedHasRole(self):
    """hasRole has been deprecated, we expect a warning."""
    try:
        self.userObject.hasRole(None)
    except DeprecationWarning:
        pass
    else:
        self.fail('Expected DeprecationWarning, none given')
</t>
<t tx="ekr.20040104185913.577">def testAllowed(self):
    """hasRole is an alias for allowed, which should be unaffected."""
    try:
        self.userObject.allowed(None)
    except DeprecationWarning:
        self.fail('Unexpected DeprecationWarning, '
            'no warnings expected here')
    else:
        pass
</t>
<t tx="ekr.20040104185913.578">def tearDown(self):
    warnings.resetwarnings()
</t>
<t tx="ekr.20040104185913.579">class BasicUser(DeprecatedAPI):
	&lt;&lt; class BasicUser declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.580">userObject = User.SimpleUser('JoeBloke', '123', [], [])

</t>
<t tx="ekr.20040104185913.581">class UnrestrictedUser(DeprecatedAPI):
	&lt;&lt; class UnrestrictedUser declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.582">userObject = User.UnrestrictedUser('Special', '123', [], [])

</t>
<t tx="ekr.20040104185913.583">class NullUnrestrictedUser(DeprecatedAPI):
	&lt;&lt; class NullUnrestrictedUser declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.584">userObject = User.NullUnrestrictedUser()

</t>
<t tx="ekr.20040104185913.585">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(BasicUser))
    suite.addTest(unittest.makeSuite(UnrestrictedUser))
    suite.addTest(unittest.makeSuite(NullUnrestrictedUser))
    return suite
</t>
<t tx="ekr.20040104185913.586">&lt;&lt; testModuleSecurity declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.587">&lt;&lt; copyright &gt;&gt;

"""Module Import Tests
"""

__rcs_id__='$Id: testModuleSecurity.py,v 1.4 2002/08/21 20:01:37 shane Exp $'
__version__='$Revision: 1.4 $'[11:-2]

import os, sys, unittest

import Testing
import ZODB
from AccessControl import User
from AccessControl import Unauthorized, ModuleSecurityInfo
from AccessControl.ZopeGuards import guarded_import

ModuleSecurityInfo('AccessControl.tests.mixed_module').declarePublic('pub')

ModuleSecurityInfo('AccessControl.tests.public_module').declarePublic('pub')
ModuleSecurityInfo('AccessControl.tests.public_module.submodule'
                   ).declarePublic('pub')

</t>
<t tx="ekr.20040104185913.588">class SecurityTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.589">def assertUnauth(self, module, fromlist):
    try:
        guarded_import(module, fromlist=fromlist)
    except (Unauthorized, ImportError):
        # Passed the test.
        pass
    else:
        assert 0, ('Did not protect module instance %s, %s' %
                   (`module`, `fromlist`))
</t>
<t tx="ekr.20040104185913.590">def assertAuth(self, module, fromlist):
    try:
        guarded_import(module, fromlist=fromlist)
    except (Unauthorized, ImportError):
        assert 0, ('Did not expose module instance %s, %s' %
                   (`module`, `fromlist`))
</t>
<t tx="ekr.20040104185913.591">def testPrivateModule(self):
    for name in '', '.submodule':
        for fromlist in (), ('priv',):
            self.assertUnauth(
                'AccessControl.tests.private_module%s' % name,
                fromlist)
</t>
<t tx="ekr.20040104185913.592">def testMixedModule(self):
    self.assertAuth('AccessControl.tests.mixed_module', ())
    self.assertAuth('AccessControl.tests.mixed_module', ('pub',))
    self.assertUnauth('AccessControl.tests.mixed_module', ('priv',))
    self.assertUnauth('AccessControl.tests.mixed_module.submodule', ())
</t>
<t tx="ekr.20040104185913.593">def testPublicModule(self):
    for name in '', '.submodule':
        for fromlist in (), ('pub',):
            self.assertAuth(
                'AccessControl.tests.public_module%s' % name,
                fromlist)
</t>
<t tx="ekr.20040104185913.594">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( SecurityTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.595">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.596">&lt;&lt; testPasswordDigest declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.597">&lt;&lt; copyright &gt;&gt;

"""Test of AuthEncoding
"""

__rcs_id__='$Id: testPasswordDigest.py,v 1.4 2002/08/14 21:28:08 mj Exp $'
__version__='$Revision: 1.4 $'[11:-2]

import os, sys, unittest

from AccessControl import AuthEncoding
import unittest


</t>
<t tx="ekr.20040104185913.598">class PasswordDigestTests (unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.599">def testGoodPassword(self):
    pw = 'good_password'
    assert len(AuthEncoding.listSchemes()) &gt; 0  # At least one must exist!
    for id in AuthEncoding.listSchemes():
        enc = AuthEncoding.pw_encrypt(pw, id)
        assert enc != pw
        assert AuthEncoding.pw_validate(enc, pw)
        assert AuthEncoding.is_encrypted(enc)
        assert not AuthEncoding.is_encrypted(pw)
</t>
<t tx="ekr.20040104185913.600">def testBadPasword(self):
    pw = 'OK_pa55w0rd \n'
    for id in AuthEncoding.listSchemes():
        enc = AuthEncoding.pw_encrypt(pw, id)
        assert enc != pw
        assert not AuthEncoding.pw_validate(enc, 'xxx')
        assert not AuthEncoding.pw_validate(enc, enc)
        if id != 'CRYPT':
            # crypt truncates passwords and would fail this test.
            assert not AuthEncoding.pw_validate(enc, pw[:-1])
        assert not AuthEncoding.pw_validate(enc, pw[1:])
        assert AuthEncoding.pw_validate(enc, pw)
</t>
<t tx="ekr.20040104185913.601">def testShortPassword(self):
    pw = '1'
    for id in AuthEncoding.listSchemes():
        enc = AuthEncoding.pw_encrypt(pw, id)
        assert enc != pw
        assert AuthEncoding.pw_validate(enc, pw)
        assert not AuthEncoding.pw_validate(enc, enc)
        assert not AuthEncoding.pw_validate(enc, 'xxx')
</t>
<t tx="ekr.20040104185913.602">def testLongPassword(self):
    pw = 'Pw' * 10000
    for id in AuthEncoding.listSchemes():
        enc = AuthEncoding.pw_encrypt(pw, id)
        assert enc != pw
        assert AuthEncoding.pw_validate(enc, pw)
        assert not AuthEncoding.pw_validate(enc, enc)
        assert not AuthEncoding.pw_validate(enc, 'xxx')
        if id != 'CRYPT':
            # crypt truncates passwords and would fail these tests.
            assert not AuthEncoding.pw_validate(enc, pw[:-2])
            assert not AuthEncoding.pw_validate(enc, pw[2:])
</t>
<t tx="ekr.20040104185913.603">def testBlankPassword(self):
    pw = ''
    for id in AuthEncoding.listSchemes():
        enc = AuthEncoding.pw_encrypt(pw, id)
        assert enc != pw
        assert AuthEncoding.pw_validate(enc, pw)
        assert not AuthEncoding.pw_validate(enc, enc)
        assert not AuthEncoding.pw_validate(enc, 'xxx')
</t>
<t tx="ekr.20040104185913.604">def testUnencryptedPassword(self):
    # Sanity check
    pw = 'my-password'
    assert AuthEncoding.pw_validate(pw, pw)
</t>
<t tx="ekr.20040104185913.605">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( PasswordDigestTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.606">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.607">&lt;&lt; testPermissionRole declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.608">&lt;&lt; copyright &gt;&gt;

"""Tests of PermissionRole
"""

__rcs_id__='$Id: testPermissionRole.py,v 1.3 2002/08/14 21:28:08 mj Exp $'
__version__='$Revision: 1.3 $'[11:-2]

import os, sys, unittest

from AccessControl.PermissionRole import PermissionRole
from Acquisition import Implicit, Explicit, aq_base

ViewPermission = 'View'
EditThingsPermission = 'Edit Things!'
DeletePermission = 'Delete'


</t>
<t tx="ekr.20040104185913.609">class AppRoot(Explicit):
	&lt;&lt; class AppRoot declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.610">_View_Permission = None
_Edit_Things__Permission = ('Manager', 'Owner')
# No default for delete permission.

</t>
<t tx="ekr.20040104185913.611">class ImplicitContainer(Implicit):
	&lt;&lt; class ImplicitContainer declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.612">pass

</t>
<t tx="ekr.20040104185913.613">class ExplicitContainer(Explicit):
	&lt;&lt; class ExplicitContainer declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.614">pass

</t>
<t tx="ekr.20040104185913.615">class RestrictiveObject(Implicit):
	&lt;&lt; class RestrictiveObject declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.616">_View_Permission = ('Manager',)
_Delete_Permission = ()  # Nobody

</t>
<t tx="ekr.20040104185913.617">class PermissiveObject(Explicit):
	&lt;&lt; class PermissiveObject declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.618">_Edit_Things__Permission = ['Anonymous']

</t>
<t tx="ekr.20040104185913.619">class ZClassMethodish(Implicit):
	&lt;&lt; class ZClassMethodish declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.620"># Think of this as a method that should only be visible to users
# who have the edit permission.
_View_Permission = '_Edit_Things__Permission'
_Edit_Things__Permission = ''
_Delete_Permission = ''


</t>
<t tx="ekr.20040104185913.621">def assertPRoles(ob, permission, expect):
    """
    Asserts that in the context of ob, the given permission maps to
    the given roles.
    """
    pr = PermissionRole(permission)
    roles = pr.__of__(ob)
    roles2 = aq_base(pr).__of__(ob)
    assert roles == roles2 or tuple(roles) == tuple(roles2), (
        'Different methods of checking roles computed unequal results')
    same = 0
    if roles is None or expect is None:
        if (roles is None or tuple(roles) == ('Anonymous',)) and (
            expect is None or tuple(expect) == ('Anonymous',)):
            same = 1
    else:
        got = {}
        for r in roles: got[r] = 1
        expected = {}
        for r in expect: expected[r] = 1
        if got == expected:  # Dict compare does the Right Thing.
            same = 1
    assert same, 'Expected roles: %s, got: %s' % (`expect`, `roles`)
</t>
<t tx="ekr.20040104185913.622">class PermissionRoleTests (unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.623">def testRestrictive(self, explicit=0):
    app = AppRoot()
    if explicit:
        app.c = ExplicitContainer()
    else:
        app.c = ImplicitContainer()
    app.c.o = RestrictiveObject()
    o = app.c.o
    assertPRoles(o, ViewPermission,       ('Manager',))
    assertPRoles(o, EditThingsPermission, ('Manager','Owner',))
    assertPRoles(o, DeletePermission,     ())
</t>
<t tx="ekr.20040104185913.624">def testPermissive(self, explicit=0):
    app = AppRoot()
    if explicit:
        app.c = ExplicitContainer()
    else:
        app.c = ImplicitContainer()
    app.c.o = PermissiveObject()
    o = app.c.o
    assertPRoles(o, ViewPermission,       ('Anonymous',))
    assertPRoles(o, EditThingsPermission, ('Anonymous','Manager','Owner',))
    assertPRoles(o, DeletePermission,     ('Manager',))
</t>
<t tx="ekr.20040104185913.625">def testExplicit(self):
    self.testRestrictive(1)
    self.testPermissive(1)
</t>
<t tx="ekr.20040104185913.626">def testAppDefaults(self):
    o = AppRoot()
    assertPRoles(o, ViewPermission,       ('Anonymous',))
    assertPRoles(o, EditThingsPermission, ('Manager','Owner',))
    assertPRoles(o, DeletePermission,     ('Manager',))
</t>
<t tx="ekr.20040104185913.627">def testPermissionMapping(self):
    app = AppRoot()
    app.c = ImplicitContainer()
    app.c.o = ZClassMethodish()
    o = app.c.o
    assertPRoles(o, ViewPermission,       ('Manager','Owner',))
    assertPRoles(o, EditThingsPermission, ())
    assertPRoles(o, DeletePermission,     ())
</t>
<t tx="ekr.20040104185913.628">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(PermissionRoleTests))
    return suite
</t>
<t tx="ekr.20040104185913.629">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.630">&lt;&lt; testSecurity declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.631">&lt;&lt; copyright &gt;&gt;

"""Document Template Tests
"""

__rcs_id__='$Id: testSecurity.py,v 1.10 2002/08/14 21:28:08 mj Exp $'
__version__='$Revision: 1.10 $'[11:-2]

import os, sys, unittest

import ZODB
from DocumentTemplate import HTML
from DocumentTemplate.tests.testDTML import DTMLTests
from Products.PythonScripts.standard import DTML
from AccessControl import User, Unauthorized
from ExtensionClass import Base

</t>
<t tx="ekr.20040104185913.632">class UnownedDTML(DTML):
	@others
</t>
<t tx="ekr.20040104185913.633">def getOwner(self):
    return None
</t>
<t tx="ekr.20040104185913.634">class SecurityTests (DTMLTests):
	&lt;&lt; class SecurityTests declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.635">doc_class = UnownedDTML
unrestricted_doc_class = HTML

</t>
<t tx="ekr.20040104185913.636">def testNoImplicitAccess(self):
    class person:
        name='Jim'

    doc = self.doc_class(
        '&lt;dtml-with person&gt;Hi, my name is '
        '&lt;dtml-var name&gt;&lt;/dtml-with&gt;')
    try:
        doc(person=person())
    except Unauthorized:
        # Passed the test.
        pass
    else:
        assert 0, 'Did not protect class instance'
</t>
<t tx="ekr.20040104185913.637">def testExprExplicitDeny(self):
    class myclass (Base):
        __roles__ = None  # Public
        somemethod__roles__ = ()  # Private
        def somemethod(self):
            return "This is a protected operation of public object"

    html = self.doc_class('&lt;dtml-var expr="myinst.somemethod()"&gt;')
    self.failUnlessRaises(Unauthorized, html, myinst=myclass())
</t>
<t tx="ekr.20040104185913.638">def testSecurityInSyntax(self):
    '''
    Ensures syntax errors are thrown for an expr with restricted
    syntax.
    '''
    expr = '&lt;dtml-var expr="(lambda x, _read=(lambda ob:ob): x.y)(c)"&gt;'
    try:
        # This would be a security hole.
        html = self.doc_class(expr)  # It might compile here...
        html()                       # or it might compile here.
    except SyntaxError:
        # Passed the test.
        pass
    else:
        assert 0, 'Did not catch bad expr'
    # Now be sure the syntax error occurred for security purposes.
    html = self.unrestricted_doc_class(expr)
    class c:
        y = 10
    res = html(c=c)
    assert res == '10', res
</t>
<t tx="ekr.20040104185913.639">    # Note: we need more tests!

def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( SecurityTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.640">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.641">&lt;&lt; testUserFolder declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.642">&lt;&lt; copyright &gt;&gt;

"""User folder tests
"""

__rcs_id__='$Id: testUserFolder.py,v 1.5.6.2 2003/01/21 02:59:48 chrism Exp $'
__version__='$Revision: 1.5.6.2 $'[11:-2]

import os, sys, unittest

import ZODB
from AccessControl import User, Unauthorized
from AccessControl.User import BasicUserFolder, UserFolder, User
from ExtensionClass import Base

</t>
<t tx="ekr.20040104185913.643">class UserFolderTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.644">def testMaxListUsers(self):
    # create a folder-ish thing which contains a roleManager,
    # then put an acl_users object into the folde-ish thing

    class Folderish(BasicUserFolder):
        def __init__(self, size, count):
            self.maxlistusers = size
            self.users = []
            self.acl_users = self
            self.__allow_groups__ = self
            for i in xrange(count):
                self.users.append("Nobody")

        def getUsers(self):
            return self.users

        def user_names(self):
            return self.getUsers()


    tinyFolderOver = Folderish(15, 20)
    tinyFolderUnder = Folderish(15, 10)

    assert tinyFolderOver.maxlistusers == 15
    assert tinyFolderUnder.maxlistusers == 15
    assert len(tinyFolderOver.user_names()) == 20
    assert len(tinyFolderUnder.user_names()) == 10

    try:
        list = tinyFolderOver.get_valid_userids()
        assert 0, "Did not raise overflow error"
    except OverflowError:
        pass

    try:
        list = tinyFolderUnder.get_valid_userids()
        pass
    except OverflowError:
        assert 0, "Raised overflow error erroneously"
</t>
<t tx="ekr.20040104185913.645">class UserTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.646">def testGetUserName(self):
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f.getUserName(), 'chris')
</t>
<t tx="ekr.20040104185913.647">def testGetUserId(self):
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f.getId(), 'chris')
</t>
<t tx="ekr.20040104185913.648">def testBaseUserGetIdEqualGetName(self):
    # this is true for the default user type, but will not
    # always be true for extended user types going forward (post-2.6)
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f.getId(), f.getUserName())
</t>
<t tx="ekr.20040104185913.649">def testGetPassword(self):
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f._getPassword(), '123')
</t>
<t tx="ekr.20040104185913.650">def testGetRoles(self):
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f.getRoles(), ('Manager', 'Authenticated'))
</t>
<t tx="ekr.20040104185913.651">def testGetDomains(self):
    f = User('chris', '123', ['Manager'], [])
    self.assertEqual(f.getDomains(), ())
</t>
<t tx="ekr.20040104185913.652">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(UserFolderTests))
    suite.addTest(unittest.makeSuite(UserTests))
    return suite
</t>
<t tx="ekr.20040104185913.653">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.654">&lt;&lt; testZopeSecurityPolicy declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.655">&lt;&lt; copyright &gt;&gt;

"""Tests of ZopeSecurityPolicy
"""

__rcs_id__='$Id: testZopeSecurityPolicy.py,v 1.5 2002/08/14 21:28:08 mj Exp $'
__version__='$Revision: 1.5 $'[11:-2]

import os, sys, unittest

import ZODB
try:
    from zExceptions import Unauthorized
except ImportError:
    Unauthorized = 'Unauthorized'
from AccessControl.ZopeSecurityPolicy import ZopeSecurityPolicy
from AccessControl.User import UserFolder
from AccessControl.SecurityManagement import SecurityContext
from Acquisition import Implicit, Explicit, aq_base
from MethodObject import Method
from ComputedAttribute import ComputedAttribute


user_roles = ('RoleOfUser',)
eo_roles = ('RoleOfExecutableOwner',)
sysadmin_roles = ('RoleOfSysAdmin',)


</t>
<t tx="ekr.20040104185913.656">class App(Explicit):
	&lt;&lt; class App declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.657">pass


</t>
<t tx="ekr.20040104185913.658">class PublicMethod (Method):
	@others

    __roles__ = None</t>
<t tx="ekr.20040104185913.659">def getOwner(self):
    return None
</t>
<t tx="ekr.20040104185913.660">class ProtectedMethod (PublicMethod):
	&lt;&lt; class ProtectedMethod declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.661">__roles__ = user_roles


</t>
<t tx="ekr.20040104185913.662">class OwnedMethod (PublicMethod):
	&lt;&lt; class OwnedMethod declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.663">__roles__ = eo_roles

</t>
<t tx="ekr.20040104185913.664">def getOwner(self):
    return self.aq_parent.aq_parent.acl_users.getUserById('theowner')
</t>
<t tx="ekr.20040104185913.665">class setuidMethod (PublicMethod):
	&lt;&lt; class setuidMethod declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.666">_proxy_roles = sysadmin_roles


</t>
<t tx="ekr.20040104185913.667">class DangerousMethod (PublicMethod):
	&lt;&lt; class DangerousMethod declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.668"># Only accessible to sysadmin or people who use proxy roles
__roles__ = sysadmin_roles


</t>
<t tx="ekr.20040104185913.669">class SimpleItemish (Implicit):
	&lt;&lt; class SimpleItemish declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.670">public_m = PublicMethod()
protected_m = ProtectedMethod()
owned_m = OwnedMethod()
setuid_m = setuidMethod()
dangerous_m = DangerousMethod()
public_prop = 'Public Value'
private_prop = 'Private Value'


</t>
<t tx="ekr.20040104185913.671">class UnprotectedSimpleItem (SimpleItemish):
	&lt;&lt; class UnprotectedSimpleItem declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.672">__allow_access_to_unprotected_subobjects__ = 1


</t>
<t tx="ekr.20040104185913.673">class RestrictedSimpleItem (SimpleItemish):
	&lt;&lt; class RestrictedSimpleItem declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.674">__allow_access_to_unprotected_subobjects__ = 0

_View_Permission = eo_roles


</t>
<t tx="ekr.20040104185913.675">class PartlyProtectedSimpleItem1 (SimpleItemish):
	&lt;&lt; class PartlyProtectedSimpleItem1 declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.676">__allow_access_to_unprotected_subobjects__ = {'public_prop': 1,}


</t>
<t tx="ekr.20040104185913.677">class PartlyProtectedSimpleItem2 (SimpleItemish):
	@others
</t>
<t tx="ekr.20040104185913.678">def __allow_access_to_unprotected_subobjects__(self, name, value):
    if name == 'public_prop':
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.679">class PartlyProtectedSimpleItem3 (PartlyProtectedSimpleItem1):
	&lt;&lt; class PartlyProtectedSimpleItem3 declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.680"># Set the roles of objects that are accessible because of
# __allow_access_to_unprotected_subobjects__ .
__roles__ = sysadmin_roles


</t>
<t tx="ekr.20040104185913.681">class SimpleClass:
	&lt;&lt; class SimpleClass declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.682">attr = 1


</t>
<t tx="ekr.20040104185913.683">class ZopeSecurityPolicyTests (unittest.TestCase):
	&lt;&lt; class ZopeSecurityPolicyTests declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.684">policy = ZopeSecurityPolicy()

</t>
<t tx="ekr.20040104185913.685">def setUp(self):
    a = App()
    self.a = a
    a.item = UnprotectedSimpleItem()
    self.item = a.item
    a.r_item = RestrictedSimpleItem()
    a.item1 = PartlyProtectedSimpleItem1()
    a.item2 = PartlyProtectedSimpleItem2()
    a.item3 = PartlyProtectedSimpleItem3()
    uf = UserFolder()
    a.acl_users = uf
    self.uf = a.acl_users
    uf._addUser('joe', 'password', 'password', user_roles, ())
    uf._addUser('theowner', 'password', 'password', eo_roles, ())
    user = uf.getUserById('joe')
    self.user = user
    context = SecurityContext(user)
    self.context = context
</t>
<t tx="ekr.20040104185913.686">def assertPolicyAllows(self, ob, attrname):
    res = self.policy.validate(ob, ob, attrname, getattr(ob, attrname),
                               self.context)
    if not res:
        assert 0, 'Policy quietly denied %s' % attrname
</t>
<t tx="ekr.20040104185913.687">def assertPolicyDenies(self, ob, attrname):
    try:
        res = self.policy.validate(ob, ob, attrname, getattr(ob, attrname),
                                   self.context)
    except Unauthorized:
        # Passed the test.
        pass
    else:
        if res:
            assert 0, 'Policy quietly allowed %s' % attrname
        else:
            assert 0, ('Policy denied %s, but did not '
                       'throw an exception.' % attrname)
</t>
<t tx="ekr.20040104185913.688">def testUserAccess(self):
    item = self.item
    self.assertPolicyAllows(item, 'public_m')
    self.assertPolicyAllows(item, 'protected_m')
    self.assertPolicyDenies(item, 'owned_m')
    self.assertPolicyAllows(item, 'setuid_m')
    self.assertPolicyDenies(item, 'dangerous_m')
</t>
<t tx="ekr.20040104185913.689">def testOwnerAccess(self):
    self.context = SecurityContext(self.uf.getUserById('theowner'))
    item = self.item
    self.assertPolicyAllows(item, 'public_m')
    self.assertPolicyDenies(item, 'protected_m')
    self.assertPolicyAllows(item, 'owned_m')
    self.assertPolicyAllows(item, 'setuid_m')
    self.assertPolicyDenies(item, 'dangerous_m')
</t>
<t tx="ekr.20040104185913.690">def testProxyAccess(self):
    item = self.item
    self.context.stack.append(item.setuid_m)
    self.assertPolicyAllows(item, 'public_m')
    self.assertPolicyDenies(item, 'protected_m')
    self.assertPolicyDenies(item, 'owned_m')
    self.assertPolicyAllows(item, 'setuid_m')
    self.assertPolicyAllows(item, 'dangerous_m')
</t>
<t tx="ekr.20040104185913.691">def testAccessToUnprotectedSubobjects(self):
    item = self.item
    r_item = self.a.r_item
    item1 = self.a.item1
    item2 = self.a.item2
    item3 = self.a.item3
    self.assertPolicyAllows(item,  'public_prop')
    self.assertPolicyDenies(r_item,'public_prop')
    self.assertPolicyAllows(item1, 'public_prop')
    self.assertPolicyAllows(item2, 'public_prop')
    self.assertPolicyDenies(item3,'public_prop')
    self.assertPolicyAllows(item,  'private_prop')
    self.assertPolicyDenies(r_item,'private_prop')
    self.assertPolicyDenies(item1, 'private_prop')
    self.assertPolicyDenies(item2, 'private_prop')
    self.assertPolicyDenies(item3, 'private_prop')
</t>
<t tx="ekr.20040104185913.692">def testAccessToSimpleContainer(self):
    self.assertPolicyAllows({}, 'keys')
    self.assertPolicyAllows([], 'append')
    self.assertPolicyDenies(SimpleClass, 'attr')
    self.assertPolicyDenies(SimpleClass(), 'attr')
    c = SimpleClass()
    c.attr = PublicMethod()
    self.assertPolicyAllows(c, 'attr')
</t>
<t tx="ekr.20040104185913.693">def testRolesForPermission(self):
    # Test of policy.checkPermission().
    r_item = self.a.r_item
    context = self.context
    v = self.policy.checkPermission('View', r_item, context)
    assert not v, '_View_Permission should deny access to user'
    o_context = SecurityContext(self.uf.getUserById('theowner'))
    v = self.policy.checkPermission('View', r_item, o_context)
    assert v, '_View_Permission should grant access to theowner'
</t>
<t tx="ekr.20040104185913.694">def testAqNames(self):
    policy = self.policy
    assert not policy.validate('', '', 'aq_self', '', None)
    assert not policy.validate('', '', 'aq_base', '', None)
    assert policy.validate('', '', 'aq_parent', '', None)
    assert policy.validate('', '', 'aq_explicit', '', None)
    assert policy.validate('', '', 'aq_inner', '', None)
</t>
<t tx="ekr.20040104185913.695">if 0:
    # This test purposely generates a log entry.
    # Enable it if you don't mind it adding to the log.
    def testInsaneRoles(self):
        # Makes sure the policy doesn't blow up on bad input.
        c = SimpleClass()
        m = PublicMethod()
        c.m = m
        # Test good roles
        self.assertPolicyAllows(c, 'm')
        # Test bad roles
        m.__roles__ = 1950
        try:
            self.assertPolicyAllows(c, 'm')
        except TypeError:
            pass
        else:
            assert 0, 'Policy accepted bad __roles__'
</t>
<t tx="ekr.20040104185913.696">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ZopeSecurityPolicyTests))
    return suite
</t>
<t tx="ekr.20040104185913.697">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.698"></t>
<t tx="ekr.20040104185913.699">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.700"># test module, partially private

</t>
<t tx="ekr.20040104185913.701">def priv():
    pass
</t>
<t tx="ekr.20040104185913.702">def pub():
    pass
</t>
<t tx="ekr.20040104185913.703"></t>
<t tx="ekr.20040104185913.704">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.705"># test module, private

</t>
<t tx="ekr.20040104185913.706">def priv():
    pass
</t>
<t tx="ekr.20040104185913.707"></t>
<t tx="ekr.20040104185913.708">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.709"># test module, all private

</t>
<t tx="ekr.20040104185913.710">def priv():
    pass
</t>
<t tx="ekr.20040104185913.711"></t>
<t tx="ekr.20040104185913.712">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.713"># test module, all private

</t>
<t tx="ekr.20040104185913.714">def priv():
    pass
</t>
<t tx="ekr.20040104185913.715"></t>
<t tx="ekr.20040104185913.716">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.717"># test module, public

from Acquisition import aq_base  # Foil the old ZopeSecurityPolicy

</t>
<t tx="ekr.20040104185913.718">def pub():
    pass
</t>
<t tx="ekr.20040104185913.719"></t>
<t tx="ekr.20040104185913.720">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.721"># test module, public

</t>
<t tx="ekr.20040104185913.722">def pub():
    pass
</t>
<t tx="ekr.20040104185913.723"></t>
<t tx="ekr.20040104185913.724">&lt;&lt; copyright &gt;&gt;

__doc__="""System management components"""

__version__='$Revision: 1.81.6.2 $'[11:-2]

&lt;&lt; ApplicationManager imports &gt;&gt;

try: import thread
except: get_ident=lambda: 0
else: get_ident=thread.get_ident

@others
</t>
<t tx="ekr.20040104185913.725">import sys,os,time,Globals, Acquisition, os, Undo
from Globals import DTMLFile
from OFS.ObjectManager import ObjectManager
from OFS.Folder import Folder
from CacheManager import CacheManager
from DavLockManager import DavLockManager
from DateTime.DateTime import DateTime
from OFS import SimpleItem
from App.Dialogs import MessageDialog
from Product import ProductFolder
from version_txt import version_txt
from cStringIO import StringIO
from AccessControl import getSecurityManager
import zLOG</t>
<t tx="ekr.20040104185913.726">class Fake:
	@others
</t>
<t tx="ekr.20040104185913.727">def locked_in_version(self): return 0
</t>
<t tx="ekr.20040104185913.728">class DatabaseManager(Fake, SimpleItem.Item, Acquisition.Implicit):
    """Database management"""
	&lt;&lt; class DatabaseManager declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.729">manage=manage_main=DTMLFile('dtml/dbMain', globals())
manage_main._setName('manage_main')
id        ='DatabaseManagement'
name=title='Database Management'
meta_type ='Database Management'
icon='p_/DatabaseManagement_icon'

manage_options=(
    (
    {'label':'Database', 'action':'manage_main',
     'help':('OFSP','Database-Management_Database.stx')},
    {'label':'Activity', 'action':'manage_activity',
     'help':('OFSP','Database-Management_Activity.stx')},
    {'label':'Cache Parameters', 'action':'manage_cacheParameters',
     'help':('OFSP','Database-Management_Cache-Parameters.stx')},
    {'label':'Flush Cache', 'action':'manage_cacheGC',
     'help':('OFSP','Database-Management_Flush-Cache.stx')},
    )
    )

# These need to be here rather to make tabs work correctly. This
# needs to be revisited.
manage_activity=Globals.DTMLFile('dtml/activity', globals())
manage_cacheParameters=Globals.DTMLFile('dtml/cacheParameters', globals())
manage_cacheGC=Globals.DTMLFile('dtml/cacheGC', globals())


</t>
<t tx="ekr.20040104185913.730">Globals.default__class_init__(DatabaseManager)

class VersionManager(Fake, SimpleItem.Item, Acquisition.Implicit):
    """Version management"""
	&lt;&lt; class VersionManager declarations &gt;&gt;

Globals.default__class_init__(VersionManager)</t>
<t tx="ekr.20040104185913.731">manage=manage_main=DTMLFile('dtml/versionManager', globals())
manage_main._setName('manage_main')
id        ='Versions'
name=title='Version Management'
meta_type ='Version Management'
icon='p_/VersionManagement_icon'

manage_options=(
    (
    {'label':'Version', 'action':'manage_main',
     'help':('OFSP','Version-Management_Version.stx')},
    )
    )

</t>
<t tx="ekr.20040104185913.732"># refcount snapshot info
_v_rcs=None
_v_rst=None

class DebugManager(Fake, SimpleItem.Item, Acquisition.Implicit):
    """Debug and profiling information"""
	&lt;&lt; class DebugManager declarations &gt;&gt;
	@others

Globals.default__class_init__(DebugManager)</t>
<t tx="ekr.20040104185913.733">manage=manage_main=DTMLFile('dtml/debug', globals())
manage_main._setName('manage_main')
id        ='DebugInfo'
name=title='Debug Information'
meta_type = name
icon='p_/DebugManager_icon'

manage_options=(
    (  {'label':'Debugging Info', 'action':'manage_main',
        'help':('OFSP','Debug-Information_Debug.stx')},
       {'label':'Profiling', 'action':'manage_profile',
        'help':('OFSP','Debug-Information_Profile.stx')},
       )
    )

manage_debug=DTMLFile('dtml/debug', globals())

</t>
<t tx="ekr.20040104185913.734">def refcount(self, n=None, t=(type(Fake), type(Acquisition.Implicit))):
    # return class reference info
    dict={}
    for m in sys.modules.values():
        for sym in dir(m):
            ob=getattr(m, sym)
            if type(ob) in t:
                dict[ob]=sys.getrefcount(ob)
    pairs=[]
    append=pairs.append
    for ob, v in dict.items():
        if hasattr(ob, '__module__'):
            name='%s.%s' % (ob.__module__, ob.__name__)
        else: name='%s' % ob.__name__
        append((v, name))
    pairs.sort()
    pairs.reverse()
    if n is not None:
        pairs=pairs[:n]
    return pairs
</t>
<t tx="ekr.20040104185913.735">def refdict(self):
    rc=self.refcount()
    dict={}
    for v, n in rc:
        dict[n]=v
    return dict
</t>
<t tx="ekr.20040104185913.736">def rcsnapshot(self):
    global _v_rcs
    global _v_rst
    _v_rcs=self.refdict()
    _v_rst=DateTime()
</t>
<t tx="ekr.20040104185913.737">def rcdate(self):
    return _v_rst
</t>
<t tx="ekr.20040104185913.738">def rcdeltas(self):
    if _v_rcs is None:
        self.rcsnapshot()
    nc=self.refdict()
    rc=_v_rcs
    rd=[]
    for n, c in nc.items():
        try:
            prev=rc[n]
            if c &gt; prev:
                rd.append( (c - prev, (c, prev, n)) )
        except: pass
    rd.sort()
    rd.reverse()
    return map(lambda n: {'name': n[1][2],
                          'delta': n[0],
                          'pc': n[1][1],
                          'rc': n[1][0]}, rd)
</t>
<t tx="ekr.20040104185913.739">def dbconnections(self):
    return Globals.DB.connectionDebugInfo()
</t>
<t tx="ekr.20040104185913.740"># Profiling support

manage_profile=DTMLFile('dtml/profile', globals())

def manage_profile_stats(self, sort='time', limit=200):
    """Return profile data if available"""
    stats=getattr(sys, '_ps_', None)
    if stats is None:
        return None
    output=StringIO()
    stdout=sys.stdout
    sys.stdout=output
    stats.strip_dirs().sort_stats(sort).print_stats(limit)
    sys.stdout.flush()
    sys.stdout=stdout
    return output.getvalue()
</t>
<t tx="ekr.20040104185913.741">def manage_getSysPath(self):
    return list(sys.path)
</t>
<t tx="ekr.20040104185913.742">class ApplicationManager(Folder,CacheManager):
    """System management"""
	&lt;&lt; class ApplicationManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.743">__roles__=('Manager',)
isPrincipiaFolderish=1
Database= DatabaseManager()
Versions= VersionManager()
DebugInfo=DebugManager()
DavLocks = DavLockManager()

manage=manage_main=DTMLFile('dtml/cpContents', globals())
manage_main._setName('manage_main')

</t>
<t tx="ekr.20040104185913.744">def version_txt(self):
    if not hasattr(self, '_v_version_txt'):
        self._v_version_txt=version_txt()

    return self._v_version_txt
</t>
<t tx="ekr.20040104185913.745">def sys_version(self): return sys.version
</t>
<t tx="ekr.20040104185913.746">def sys_platform(self): return sys.platform
</t>
<t tx="ekr.20040104185913.747">_objects=(
    {'id': 'Database',
     'meta_type': Database.meta_type},
    {'id': 'Versions',
     'meta_type': Versions.meta_type},
    {'id': 'DavLocks',
     'meta_type': DavLocks.meta_type},
    {'id': 'Products',
     'meta_type': 'Product Management'},
    {'id': 'DebugInfo',
     'meta_type': DebugInfo.meta_type},
    )

manage_options=(
    (
    {'label':'Contents', 'action':'manage_main',
     'help':('OFSP','Control-Panel_Contents.stx')},
    )
    +Undo.UndoSupport.manage_options
    )

id        ='Control_Panel'
name=title='Control Panel'
meta_type ='Control Panel'
icon='p_/ControlPanel_icon'

process_id=os.getpid()
process_start=int(time.time())

# Disable some inappropriate operations
manage_addObject=None
manage_delObjects=None
manage_addProperty=None
manage_editProperties=None
manage_delProperties=None

def __init__(self):
    self.Products=ProductFolder()
</t>
<t tx="ekr.20040104185913.748"># Note by brian:
#
# This __setstate__ does not seem to work - it creates a new ProductFolder
# and adds it to the CP instance if needed, but the resulting PF does not
# seem to be persistent ;( Rather than spend much time figuring out why,
# I just added a check in Application.open_bobobase to create the PF if
# it is needed (this is where several other b/c checks are done anyway.)
#
#
#    def __setstate__(self, v):
#        ApplicationManager.inheritedAttribute('__setstate__')(self, v)
#        if not hasattr(self, 'Products'):
#            self.Products=ProductFolder()


def _canCopy(self, op=0):
    return 0
</t>
<t tx="ekr.20040104185913.749">def _init(self):
    pass
</t>
<t tx="ekr.20040104185913.750">def manage_app(self, URL2):
    """Return to the main management screen"""
    raise 'Redirect', URL2+'/manage'
</t>
<t tx="ekr.20040104185913.751">def process_time(self):
    s=int(time.time())-self.process_start
    d=int(s/86400)
    s=s-(d*86400)
    h=int(s/3600)
    s=s-(h*3600)
    m=int(s/60)
    s=s-(m*60)
    d=d and ('%d day%s'  % (d, (d != 1 and 's' or ''))) or ''
    h=h and ('%d hour%s' % (h, (h != 1 and 's' or ''))) or ''
    m=m and ('%d min' % m) or ''
    s='%d sec' % s
    return '%s %s %s %s' % (d, h, m, s)
</t>
<t tx="ekr.20040104185913.752">def thread_get_ident(self): return get_ident()
</t>
<t tx="ekr.20040104185913.753">def db_name(self):
    return self._p_jar.db().getName()
</t>
<t tx="ekr.20040104185913.754">def db_size(self):
    if Globals.DatabaseVersion=='2':
        s=os.stat(self.db_name())[6]
    else:
        s=self._p_jar.db().getSize()
        if type(s) is type(''): return s

    if s &gt;= 1048576.0: return '%.1fM' % (s/1048576.0)
    return '%.1fK' % (s/1024.0)
</t>
<t tx="ekr.20040104185913.755">if hasattr(sys, 'ZMANAGED'):

    manage_restartable=1
    def manage_restart(self, URL1):
        """Shut down the application"""
        try:
            user = '"%s"' % getSecurityManager().getUser().getUserName()
        except:
            user = 'unknown user'
        zLOG.LOG("ApplicationManager", zLOG.INFO,
                 "Restart requested by %s" % user)
        for db in Globals.opened: db.close()
        raise SystemExit, """&lt;html&gt;
        &lt;head&gt;&lt;meta HTTP-EQUIV=REFRESH CONTENT="5; URL=%s/manage_main"&gt;
        &lt;/head&gt;
        &lt;body&gt;Zope is restarting&lt;/body&gt;&lt;/html&gt;
        """ % URL1
        sys.exit(1)
</t>
<t tx="ekr.20040104185913.756">def manage_shutdown(self):
    """Shut down the application"""
    try:
        user = '"%s"' % getSecurityManager().getUser().getUserName()
    except:
        user = 'unknown user'
    zLOG.LOG("ApplicationManager", zLOG.INFO,
             "Shutdown requested by %s" % user)
    for db in Globals.opened: db.close()
    sys.exit(0)
</t>
<t tx="ekr.20040104185913.757">def manage_pack(self, days=0, REQUEST=None):
    """Pack the database"""

    t=time.time()-days*86400

    db=self._p_jar.db()
    t=db.pack(t)
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(
            REQUEST['URL1']+'/manage_workspace')
    return t
</t>
<t tx="ekr.20040104185913.758">def revert_points(self): return ()
</t>
<t tx="ekr.20040104185913.759">def version_list(self):
    # Return a list of currently installed products/versions
    path_join=os.path.join
    isdir=os.path.isdir
    exists=os.path.exists

    product_dir=path_join(SOFTWARE_HOME,'Products')
    product_names=os.listdir(product_dir)
    product_names.sort()
    info=[]
    for product_name in product_names:
        package_dir=path_join(product_dir, product_name)
        if not isdir(package_dir):
            continue
        version_txt = None
        for name in ('VERSION.TXT', 'VERSION.txt', 'version.txt'):
            v = path_join(package_dir, name)
            if exists(v):
                version_txt = v
                break
        if version_txt is not None:
            file=open(version_txt, 'r')
            data=file.readline()
            file.close()
            info.append(data.strip())
    return info
</t>
<t tx="ekr.20040104185913.760">def version_info(self):
    r=[]
    try: db=self._p_jar.db()
    except: raise 'Zope database version error', """
    Sorry, &lt;em&gt;Version management&lt;/em&gt; is only supported if you use ZODB 3.
    """
    for v in db.versions():
        if db.versionEmpty(v): continue
        r.append({'id': v})
    return r
</t>
<t tx="ekr.20040104185913.761">def manage_saveVersions(self, versions, REQUEST=None):
    "Commit some versions"
    db=self._p_jar.db()
    for v in versions:
        db.commitVersion(v)
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.762">def manage_discardVersions(self, versions, REQUEST=None):
    "Discard some versions"
    db=self._p_jar.db()
    for v in versions:
        db.abortVersion(v)
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.763">def getSOFTWARE_HOME(self):
    return SOFTWARE_HOME
</t>
<t tx="ekr.20040104185913.764">def getZOPE_HOME(self):
    return ZOPE_HOME
</t>
<t tx="ekr.20040104185913.765">def getINSTANCE_HOME(self):
    return INSTANCE_HOME
</t>
<t tx="ekr.20040104185913.766">def getCLIENT_HOME(self):
    return CLIENT_HOME
</t>
<t tx="ekr.20040104185913.767">def objectIds(self, spec=None):
    """ this is a patch for pre-2.4 Zope installations. Such
        installations don't have an entry for the WebDAV LockManager
        introduced in 2.4.
    """

    meta_types = map(lambda x: x.get('meta_type',None) , self._objects)

    if not self.DavLocks.meta_type in meta_types:

        lst = list(self._objects)
        lst.append(  {'id': 'DavLocks', \
            'meta_type': self.DavLocks.meta_type})
        self._objects = tuple(lst)

    return Folder.objectIds(self, spec)
</t>
<t tx="ekr.20040104185913.768">&lt;&lt; copyright &gt;&gt;

__doc__='''Cache management support

$Id: CacheManager.py,v 1.26.6.1 2002/10/09 15:26:26 shane Exp $'''

__version__='$Revision: 1.26.6.1 $'[11:-2]

import Globals, time, sys
from DateTime import DateTime


@others

Globals.default__class_init__(CacheManager)
</t>
<t tx="ekr.20040104185913.770">class CacheManager:
    """Cache management mix-in
    """
	&lt;&lt; class CacheManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.771">_cache_age=60
_cache_size=400
_vcache_age=60
_vcache_size=400
_history_length = 3600  # Seconds

manage_cacheParameters=Globals.DTMLFile('dtml/cacheParameters', globals())
manage_cacheGC=Globals.DTMLFile('dtml/cacheGC', globals())

transparent_bar = Globals.ImageFile('www/transparent_bar.gif', globals())
store_bar = Globals.ImageFile('www/store_bar.gif', globals())
load_bar = Globals.ImageFile('www/load_bar.gif', globals())

</t>
<t tx="ekr.20040104185913.772">def cache_length(self):
    try: db=self._p_jar.db()
    except:
        # BoboPOS2
        return len(Globals.Bobobase._jar.cache)
    else: return db.cacheSize()
</t>
<t tx="ekr.20040104185913.773">def cache_detail_length(self):
    try: db=self._p_jar.db()
    except:
        return ()
    else: return db.cacheDetailSize()
</t>
<t tx="ekr.20040104185913.774">def database_size(self):
    try: db=self._p_jar.db()
    except:
        # BoboPOS2
        return len(Globals.Bobobase._jar.db.index)*4
    else: return db.objectCount()
</t>
<t tx="ekr.20040104185913.775">def cache_age(self):
    try:
        if self._p_jar.getVersion():
            return self._vcache_age
    except: pass

    return self._cache_age
</t>
<t tx="ekr.20040104185913.776">def manage_cache_age(self,value,REQUEST):
    "set cache age"
    try:
        v=self._p_jar.getVersion()
    except:
        # BoboPOS2:
        if self._p_jar.db is not Globals.Bobobase._jar.db:
            raise 'Version Error', (
                '''You may not change the database cache age
                while working in a &lt;em&gt;version&lt;/em&gt;''')
        self._cache_age=Globals.Bobobase._jar.cache.cache_age=value
    else:
        if v:
            self._vcache_age=value
            self._p_jar.db().setVersionCacheDeactivateAfter(value)
        else:
            self._cache_age=value
            self._p_jar.db().setCacheDeactivateAfter(value)

    if REQUEST is not None:
        response=REQUEST['RESPONSE']
        response.redirect(REQUEST['URL1']+'/manage_cacheParameters')
</t>
<t tx="ekr.20040104185913.777">def cache_size(self):
    try:
        if self._p_jar.getVersion():
            return self._vcache_size
    except: pass
    return self._cache_size
</t>
<t tx="ekr.20040104185913.778">def manage_cache_size(self,value,REQUEST):
    "set cache size"
    try:
        v=self._p_jar.getVersion()
    except:
        # BoboPOS2:
        if self._p_jar.db is not Globals.Bobobase._jar.db:
            raise 'Version Error', (
                '''You may not change the database cache size
                while working in a &lt;em&gt;version&lt;/em&gt;''')
        self._cache_size=Globals.Bobobase._jar.cache.cache_size=value
    else:
        if v:
            self._vcache_size=value
            self._p_jar.db().setVersionCacheSize(value)
        else:
            self._cache_size=value
            self._p_jar.db().setCacheSize(value)

    if REQUEST is not None:
        response=REQUEST['RESPONSE']
        response.redirect(REQUEST['URL1']+'/manage_cacheParameters')
</t>
<t tx="ekr.20040104185913.779">def cacheStatistics(self):
    try: return self._p_jar.db().cacheStatistics()
    except: pass

    # BoboPOS 2
    return (
        ('Mean time since last access (minutes)',
         "%.4g" % (Globals.Bobobase._jar.cache.cache_mean_age/60.0)),
        ('Deallocation rate (objects/minute)',
         "%.4g" % (Globals.Bobobase._jar.cache.cache_mean_deal*60)),
        ('Deactivation rate (objects/minute)',
         "%.4g" % (Globals.Bobobase._jar.cache.cache_mean_deac*60)),
        ('Time of last cache garbage collection',
         time.asctime(time.localtime(
             Globals.Bobobase._jar.cache.cache_last_gc_time
             ))
         ),
        )
</t>
<t tx="ekr.20040104185913.780"># BoboPOS 2
def cache_mean_age(self):
    return Globals.Bobobase._jar.cache.cache_mean_age/60.0
</t>
<t tx="ekr.20040104185913.781"># BoboPOS 2
def cache_mean_deal(self):
    return Globals.Bobobase._jar.cache.cache_mean_deal*60
</t>
<t tx="ekr.20040104185913.782"># BoboPOS 2
def cache_mean_deac(self):
    return Globals.Bobobase._jar.cache.cache_mean_deac*60
</t>
<t tx="ekr.20040104185913.783"># BoboPOS 2
def cache_last_gc_time(self):
    t=Globals.Bobobase._jar.cache.cache_last_gc_time
    return time.asctime(time.localtime(t))
</t>
<t tx="ekr.20040104185913.784">def manage_full_sweep(self,value,REQUEST):
    "Perform a full sweep through the cache"
    try: db=self._p_jar.db()
    except:
        # BoboPOS2
        Globals.Bobobase._jar.cache.full_sweep(value)
    else: db.cacheFullSweep(value)

    if REQUEST is not None:
        response=REQUEST['RESPONSE']
        response.redirect(REQUEST['URL1']+'/manage_cacheGC')
</t>
<t tx="ekr.20040104185913.785">def manage_minimize(self,value=1,REQUEST=None):
    "Perform a full sweep through the cache"
    try: db=self._p_jar.db()
    except:
        # BoboPOS2
        Globals.Bobobase._jar.cache.minimize(value)
    else: db.cacheMinimize(value)

    if REQUEST is not None:
        response=REQUEST['RESPONSE']
        response.redirect(REQUEST['URL1']+'/manage_cacheGC')
</t>
<t tx="ekr.20040104185913.786">def initialize_cache(self):
    try: db=self._p_jar.db()
    except:
        # BoboPOS2
        Globals.Bobobase._jar.cache.cache_size=self._cache_size
        Globals.Bobobase._jar.cache.cache_age =self._cache_age
    else:
        db.setCacheSize(self._cache_size)
        db.setCacheDeactivateAfter(self._cache_age)
        db.setVersionCacheSize(self._vcache_size)
        db.setVersionCacheDeactivateAfter(self._vcache_age)
        am = self._getActivityMonitor()
        if am is not None:
            am.setHistoryLength(self._history_length)
</t>
<t tx="ekr.20040104185913.787">def cache_detail(self, REQUEST=None):
    """
    Returns the name of the classes of the objects in the cache
    and the number of objects in the cache for each class.
    """
    db=self._p_jar.db()
    detail = db.cacheDetail()
    if REQUEST is not None:
        # format as text
        REQUEST.RESPONSE.setHeader('Content-Type', 'text/plain')
        return '\n'.join(map(lambda (name, count): '%6d %s' %
                               (count, name), detail))
    else:
        # raw
        return detail
</t>
<t tx="ekr.20040104185913.788">def cache_extreme_detail(self, REQUEST=None):
    """
    Returns information about each object in the cache.
    """
    db=self._p_jar.db()
    detail = db.cacheExtremeDetail()
    if REQUEST is not None:
        # sort the list.
        lst = map(lambda dict: ((dict['conn_no'], dict['oid']), dict),
                  detail)
        # format as text.
        res = [
            '# Table shows connection number, oid, refcount, state, '
            'and class.',
            '# States: L = loaded, G = ghost, C = changed']
        for sortkey, dict in lst:
            id = dict.get('id', None)
            if id:
                idinfo = ' (%s)' % id
            else:
                idinfo = ''
            s = dict['state']
            if s == 0:
                state = 'L'  # loaded
            elif s == 1:
                state = 'C'  # changed
            else:
                state = 'G'  # ghost
            res.append('%d %-34s %6d %s %s%s' % (
                dict['conn_no'], `dict['oid']`, dict['rc'],
                state, dict['klass'], idinfo))
        REQUEST.RESPONSE.setHeader('Content-Type', 'text/plain')
        return '\n'.join(res)
    else:
        # raw
        return detail
</t>
<t tx="ekr.20040104185913.789">def _getActivityMonitor(self):
    db = self._p_jar.db()
    if not hasattr(db, 'getActivityMonitor'):
        return None
    am = db.getActivityMonitor()
    if am is None:
        return None
    return am
</t>
<t tx="ekr.20040104185913.790">def getHistoryLength(self):
    am = self._getActivityMonitor()
    if am is None:
        return 0
    return am.getHistoryLength()
</t>
<t tx="ekr.20040104185913.791">def manage_setHistoryLength(self, length, REQUEST=None):
    """Change the length of the activity monitor history.
    """
    am = self._getActivityMonitor()
    length = int(length)
    if length &lt; 0:
        raise ValueError, 'length can not be negative'
    if am is not None:
        am.setHistoryLength(length)
    self._history_length = length  # Restore on startup

    if REQUEST is not None:
        response = REQUEST['RESPONSE']
        response.redirect(REQUEST['URL1'] + '/manage_activity')
</t>
<t tx="ekr.20040104185913.792">def getActivityChartData(self, segment_height, REQUEST=None):
    """Returns information for generating an activity chart.
    """
    am = self._getActivityMonitor()
    if am is None:
        return None

    if REQUEST is not None:
        start = float(REQUEST.get('chart_start', 0))
        end = float(REQUEST.get('chart_end', 0))
        divisions = int(REQUEST.get('chart_divisions', 10))
        analysis = am.getActivityAnalysis(start, end, divisions)
    else:
        analysis = am.getActivityAnalysis()

    total_load_count = 0
    total_store_count = 0
    total_connections = 0
    limit = 0
    divs = []
    for div in analysis:
        total_store_count = total_store_count + div['stores']
        total_load_count = total_load_count + div['loads']
        total_connections = total_connections + div['connections']
        sum = div['stores'] + div['loads']
        if sum &gt; limit:
            limit = sum

    if analysis:
        segment_time = analysis[0]['end'] - analysis[0]['start']
    else:
        segment_time = 0

    for div in analysis:
        stores = div['stores']
        if stores &gt; 0:
            store_len = max(int(segment_height * stores / limit), 1)
        else:
            store_len = 0
        loads = div['loads']
        if loads &gt; 0:
            load_len = max(int(segment_height * loads / limit), 1)
        else:
            load_len = 0

        t = div['end'] - analysis[-1]['end']  # Show negative numbers.
        if segment_time &gt;= 3600:
            # Show hours.
            time_offset = '%dh' % (t / 3600)
        elif segment_time &gt;= 60:
            # Show minutes.
            time_offset = '%dm' % (t / 60)
        elif segment_time &gt;= 1:
            # Show seconds.
            time_offset = '%ds' % t
        else:
            # Show fractions.
            time_offset = '%.2fs' % t
        divs.append({
            'store_len': store_len,
            'load_len': load_len,
            'trans_len': max(segment_height - store_len - load_len, 0),
            'store_count': div['stores'],
            'load_count': div['loads'],
            'connections': div['connections'],
            'start': div['start'],
            'end': div['end'],
            'time_offset': time_offset,
            })

    if analysis:
        start_time = DateTime(divs[0]['start']).aCommonZ()
        end_time = DateTime(divs[-1]['end']).aCommonZ()
    else:
        start_time = ''
        end_time = ''

    res = {'start_time': start_time,
           'end_time': end_time,
           'divs': divs,
           'total_store_count': total_store_count,
           'total_load_count': total_load_count,
           'total_connections': total_connections,
           }
    return res
</t>
<t tx="ekr.20040104185913.793">&lt;&lt; copyright &gt;&gt;

"""Commonly used utility functions."""

__version__='$Revision: 1.16.2.1 $'[11:-2]

import sys, os, time

# These are needed because the various date formats below must
# be in english per the RFCs. That means we can't use strftime,
# which is affected by different locale settings.
weekday_abbr = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
weekday_full = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                'Friday', 'Saturday', 'Sunday']
monthname    = [None, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

@others
</t>
<t tx="ekr.20040104185913.795">def iso8601_date(ts=None):
    # Return an ISO 8601 formatted date string, required
    # for certain DAV properties.
    # '2000-11-10T16:21:09-08:00
    if ts is None: ts=time.time()
    return time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime(ts))
</t>
<t tx="ekr.20040104185913.796">def rfc850_date(ts=None):
    # Return an HTTP-date formatted date string.
    # 'Friday, 10-Nov-00 16:21:09 GMT'
    if ts is None: ts=time.time()
    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(ts)
    return "%s, %02d-%3s-%2s %02d:%02d:%02d GMT" % (
            weekday_full[wd],
            day, monthname[month],
            str(year)[2:],
            hh, mm, ss)
</t>
<t tx="ekr.20040104185913.797">def rfc1123_date(ts=None):
    # Return an RFC 1123 format date string, required for
    # use in HTTP Date headers per the HTTP 1.1 spec.
    # 'Fri, 10 Nov 2000 16:21:09 GMT'
    if ts is None: ts=time.time()
    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(ts)
    return "%s, %02d %3s %4d %02d:%02d:%02d GMT" % (weekday_abbr[wd],
                                                    day, monthname[month],
                                                    year,
                                                    hh, mm, ss)
</t>
<t tx="ekr.20040104185913.798">def absattr(attr, c=callable):
    # Return the absolute value of an attribute,
    # calling the attr if it is callable.
    if c(attr):
        return attr()
    return attr
</t>
<t tx="ekr.20040104185913.799">def aq_base(ob, getattr=getattr):
    # Return the aq_base of an object.
    return getattr(ob, 'aq_base', ob)
</t>
<t tx="ekr.20040104185913.800">def is_acquired(ob, hasattr=hasattr, aq_base=aq_base, absattr=absattr):
    # Return true if this object is not considered to be
    # a direct subobject of its acquisition parent
    # Used to prevent acquisition side-affects in FTP traversal
    # Note that this method is misnamed since parents can (and do)
    # spoof it. It is not a true measure of whether something is
    # acquired, it relies on the parent's parent-ness exclusively
    if not hasattr(ob, 'aq_parent'):
        # We can't be acquired if we don't have an aq_parent
        return 0

    parent = aq_base(ob.aq_parent)
    absId  = absattr(ob.id)

    if hasattr(parent, absId):
        # Consider direct attributes not acquired
        return 0

    if hasattr(parent, '__getitem__'):
        # Use __getitem__ as opposed to has_key to avoid TTW namespace
        # issues, and to support the most minimal mapping objects
        try:
            # We assume that getitem will not acquire which
            # is the standard behavior for Zope objects
            if aq_base(ob.aq_parent[absId]) is aq_base(ob):
                # This object is an item of the aq_parent, its not acquired
                return 0
        except KeyError:
            pass

    if hasattr(parent,'_objects'):
        # XXX This is really icky
        # This ugly mess is for ZClass methods I think
        if absId+' ' in parent.objectIds():
            return 0

    if hasattr(aq_base(ob), 'isTopLevelPrincipiaApplicationObject') and \
            ob.isTopLevelPrincipiaApplicationObject:
        # This object the top level
        return 0
    return 1 # This object is acquired by our measure
</t>
<t tx="ekr.20040104185913.801">def package_home(globals_dict):
    __name__=globals_dict['__name__']
    m=sys.modules[__name__]
    if hasattr(m,'__path__'):
        r=m.__path__[0]
    elif "." in __name__:
        r=sys.modules[__name__[:__name__.rfind('.')]].__path__[0]
    else:
        r=__name__
    return os.path.join(os.getcwd(), r)
</t>
<t tx="ekr.20040104185913.802">def attrget(o,name,default):
    if hasattr(o,name): return getattr(o,name)
    return default
</t>
<t tx="ekr.20040104185913.803">def Dictionary(**kw): return kw # Sorry Guido
</t>
<t tx="ekr.20040104185913.804">try:
    # Python 2.2. already has a realpath function, while 2.1 doesn't
    realpath = os.path.realpath
except:
    if os.name == 'posix':
        def realpath(filename):
            """
            Return the canonical path of the specified filename,
            eliminating any symbolic links encountered in the path
            (this is ripped off from Python 2.2).
            """
            filename = os.path.abspath(filename)

            bits = ['/'] + filename.split('/')[1:]
            for i in range(2, len(bits)+1):
                component = os.path.join(*bits[0:i])
                if os.path.islink(component):
                    resolved = os.readlink(component)
                    (dir, file) = os.path.split(component)
                    resolved = os.path.normpath(os.path.join(dir, resolved))
                    newpath = os.path.join(*([resolved] + bits[i:]))
                    return realpath(newpath)

            return filename
    else:
        # other platforms are assumed to not have symlinks, so we alias
        # realpath to abspath
        realpath = os.path.abspath
</t>
<t tx="ekr.20040104185913.805">&lt;&lt; copyright &gt;&gt;

__version__ = "$Revision: 1.8 $"[11:-2]

import OFS, Acquisition, Globals
from AccessControl import getSecurityManager, ClassSecurityInfo
from webdav.Lockable import wl_isLocked

@others


</t>
<t tx="ekr.20040104185913.807">class DavLockManager(OFS.SimpleItem.Item, Acquisition.Implicit):
	&lt;&lt; class DavLockManager declarations &gt;&gt;
	@others

Globals.default__class_init__(DavLockManager)
</t>
<t tx="ekr.20040104185913.808">id           = 'DavLockManager'
name = title = 'WebDAV Lock Manager'
meta_type    = 'WebDAV Lock Manager'
icon = 'p_/davlocked'

security = ClassSecurityInfo()
security.declareProtected('Manage WebDAV Locks',
                          'findLockedObjects', 'manage_davlocks',
                          'manage_unlockObjects')
security.declarePrivate('unlockObjects')

manage_davlocks=manage_main=manage=Globals.DTMLFile(
    'dtml/davLockManager', globals())
manage_davlocks._setName('manage_davlocks')

manage_options = (
    {'label': 'Write Locks', 'action': 'manage_main',
     'help': ('OFSP', 'DavLocks-ManageLocks.stx'), },
    )

</t>
<t tx="ekr.20040104185913.809">def locked_in_version(self): return 0
</t>
<t tx="ekr.20040104185913.810">def findLockedObjects(self, frompath=''):
    app = self.getPhysicalRoot()

    if frompath:
        if frompath[0] == '/': frompath = frompath[1:]
        # since the above will turn '/' into an empty string, check
        # for truth before chopping a final slash
        if frompath and frompath[-1] == '/': frompath= frompath[:-1]

    # Now we traverse to the node specified in the 'frompath' if
    # the user chose to filter the search, and run a ZopeFind with
    # the expression 'wl_isLocked()' to find locked objects.
    obj = app.unrestrictedTraverse(frompath)
    lockedobjs = self._findapply(obj, path=frompath)

    return lockedobjs
</t>
<t tx="ekr.20040104185913.811">def unlockObjects(self, paths=[]):
    app = self.getPhysicalRoot()

    for path in paths:
        ob = app.unrestrictedTraverse(path)
        ob.wl_clearLocks()
</t>
<t tx="ekr.20040104185913.812">def manage_unlockObjects(self, paths=[], REQUEST=None):
    " Management screen action to unlock objects. "
    if paths: self.unlockObjects(paths)
    if REQUEST is not None:
        m = '%s objects unlocked.' % len(paths)
        return self.manage_davlocks(self, REQUEST, manage_tabs_message=m)
</t>
<t tx="ekr.20040104185913.813">def _findapply(self, obj, result=None, path=''):
    # recursive function to actually dig through and find the locked
    # objects.

    if result is None:
        result = []
    base = Acquisition.aq_base(obj)
    if not hasattr(base, 'objectItems'):
        return result
    try: items = obj.objectItems()
    except: return result

    addresult = result.append
    for id, ob in items:
        if path: p = '%s/%s' % (path, id)
        else: p = id

        dflag = hasattr(ob, '_p_changed') and (ob._p_changed == None)
        bs = Acquisition.aq_base(ob)
        if wl_isLocked(ob):
            li = []
            addlockinfo = li.append
            for token, lock in ob.wl_lockItems():
                addlockinfo({'owner':lock.getCreatorPath(),
                             'token':token})
            addresult((p, li))
            dflag = 0
        if hasattr(bs, 'objectItems'):
            self._findapply(ob, result, p)
        if dflag: ob._p_deactivate()

    return result
</t>
<t tx="ekr.20040104185913.814">&lt;&lt; copyright &gt;&gt;

"""Common HTML dialog boxes

    MessageDialog(title, message, action, [target])

    A very simple dialog used to display an HTML page titled title,
    displaying message message and an OK button. Clicking the OK
    button will take the browser to the URL specified in action.
    The *optional* target argument can be used to force a (frames
    capable) browser to load the URL specified in action into a specific
    frame. (Specifying '_new' will cause the browser to load the
    specified URL into a new window, for example).

    example usage:
    &lt;PRE&gt;
    return MessageDialog(title='Just thought you should know...',
                         message='You have wiped out your data.',
                         action='/paid_tech_support/prices.html',
                         target='_top')
    &lt;/PRE&gt;"""

__version__='$Revision: 1.8 $'[11:-2]

from Globals import HTML

MessageDialog = HTML(
	&lt;&lt; message &gt;&gt;, target='', action='manage_main', title='Changed')</t>
<t tx="ekr.20040104185913.815">&lt;&lt; copyright &gt;&gt;

__doc__='''Standard routines for handling extensions.

Extensions currently include external methods and pluggable brains.

$Id: Extensions.py,v 1.19 2002/08/14 21:31:40 mj Exp $'''

__version__='$Revision: 1.19 $'[11:-2]

import os, zlib, rotor, imp
import Products

path_split=os.path.split
path_join=os.path.join
exists=os.path.exists

@others
</t>
<t tx="ekr.20040104185913.817">class FuncCode:
	@others
</t>
<t tx="ekr.20040104185913.818">def __init__(self, f, im=0):
    self.co_varnames=f.func_code.co_varnames[im:]
    self.co_argcount=f.func_code.co_argcount-im
</t>
<t tx="ekr.20040104185913.819">def __cmp__(self,other):
    if other is None: return 1
    try: return cmp((self.co_argcount, self.co_varnames),
                    (other.co_argcount, other.co_varnames))
    except: return 1
</t>
<t tx="ekr.20040104185913.820">def _getPath(home, prefix, name, suffixes):
    d=path_join(home, prefix)
    if d==prefix: raise ValueError, (
        'The prefix, %s, should be a relative path' % prefix)
    d=path_join(d,name)
    if d==name: raise ValueError, ( # Paranoia
        'The file name, %s, should be a simple file name' % name)
    for s in suffixes:
        if s: s="%s.%s" % (d, s)
        else: s=d
        if exists(s): return s
</t>
<t tx="ekr.20040104185913.821">def getPath(prefix, name, checkProduct=1, suffixes=('',)):
    """Find a file in one of several relative locations

    Arguments:

      prefix -- The location, relative to some home, to look for the
                file

      name -- The name of the file.  This must not be a path.

      checkProduct -- a flag indicating whether product directories
        should be used as additional hope ares to be searched. This
        defaults to a true value.

        If this is true and the name contains a dot, then the
        text before the dot is treated as a product name and
        the product package directory is used as anothe rhome.

      suffixes -- a sequences of file suffixes to check.
        By default, the name is used without a suffix.

    The search takes on multiple homes which are INSTANCE_HOME,
    the directory containing the directory containing SOFTWARE_HOME, and
    possibly product areas.
    """
    d,n = path_split(name)
    if d: raise ValueError, (
        'The file name, %s, should be a simple file name' % name)

    if checkProduct:
        l = name.find('.')
        if l &gt; 0:
            p = name[:l]
            n = name[l + 1:]
            for product_dir in Products.__path__:
                r = _getPath(product_dir, os.path.join(p, prefix), n, suffixes)
                if r is not None: return r

    sw=path_split(path_split(SOFTWARE_HOME)[0])[0]
    for home in (INSTANCE_HOME, sw):
        r=_getPath(home, prefix, name, suffixes)
        if r is not None: return r
</t>
<t tx="ekr.20040104185913.822">def getObject(module, name, reload=0,
              # The use of a mutable default is intentional here,
              # because modules is a module cache.
              modules={}
              ):

    # The use of modules here is not thread safe, however, there is
    # no real harm in a rece condition here.  If two threads
    # update the cache, then one will have simply worked a little
    # harder than need be.  So, in this case, we won't incur
    # the expense of a lock.
    if modules.has_key(module):
        old=modules[module]
        if old.has_key(name) and not reload: return old[name]
    else:
        old=None

    if module[-3:]=='.py': p=module[:-3]
    elif module[-4:]=='.pyp': p=module[:-4]
    elif module[-4:]=='.pyc': p=module[:-4]
    else: p=module
    p=getPath('Extensions', p, suffixes=('','py','pyp','pyc'))
    if p is None:
        raise "Module Error", (
            "The specified module, &lt;em&gt;%s&lt;/em&gt;, couldn't be found." % module)

    __traceback_info__=p, module


    if p[-4:]=='.pyc':
        file = open(p, 'rb')
        binmod=imp.load_compiled('Extension', p, file)
        file.close()
        m=binmod.__dict__

    elif p[-4:]=='.pyp':
        prod_id=module.split('.')[0]
        data=zlib.decompress(
            rotor.newrotor(prod_id +' shshsh').decrypt(open(p,'rb').read())
            )
        execsrc=compile(data, module, 'exec')
        m={}
        exec execsrc in m

    else:
        try: execsrc=open(p)
        except: raise "Module Error", (
            "The specified module, &lt;em&gt;%s&lt;/em&gt;, couldn't be opened."
            % module)
        m={}
        exec execsrc in m

    try: r=m[name]
    except KeyError:
        raise 'Invalid Object Name', (
            "The specified object, &lt;em&gt;%s&lt;/em&gt;, was not found in module, "
            "&lt;em&gt;%s&lt;/em&gt;." % (name, module))

    if old:
        for k, v in m.items(): old[k]=v
    modules[module]=m

    return r
</t>
<t tx="ekr.20040104185913.823">class NoBrains: pass
</t>
<t tx="ekr.20040104185913.824">def getBrain(module, class_name, reload=0):
    'Check/load a class'

    if not module and not class_name: return NoBrains

    try: c=getObject(module, class_name, reload)
    except KeyError, v:
        if v == class_name: raise ValueError, (
            'The class, %s, is not defined in file, %s' % (class_name, module))

    if not hasattr(c,'__bases__'): raise ValueError, (
        '%s, is not a class' % class_name)

    return c
</t>
<t tx="ekr.20040104185913.825">&lt;&lt; copyright &gt;&gt;

__doc__='''Factory objects

$Id: Factory.py,v 1.26 2002/08/14 21:31:40 mj Exp $'''
__version__='$Revision: 1.26 $'[11:-2]

import OFS.SimpleItem, Acquisition, Globals, AccessControl.Role
import Products, Product

@others
</t>
<t tx="ekr.20040104185913.827">class Factory(
	&lt;&lt; class Factory declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.828">AccessControl.Role.RoleManager,
Globals.Persistent, Acquisition.Implicit, OFS.SimpleItem.Item
):
"Model factory meta-data"
meta_type='Zope Factory'
icon='p_/Factory_icon'

permission='' # Waaaa

_setObject=_getOb=Acquisition.Acquired

__ac_permissions__=(
    ('Edit Factories', ('manage_edit','manage_main')),
    ('Use Factories', ('index_html','')),
    )

manage_options=(
    (
    {'label':'Edit', 'action':'manage_main',
     'help':('OFSP','Zope-Factory_Edit.stx')},
    )
    +AccessControl.Role.RoleManager.manage_options
    +OFS.SimpleItem.Item.manage_options
    )

</t>
<t tx="ekr.20040104185913.829">def __init__(self, id, title, object_type, initial, permission=''):
    self.id=id
    self.title=title
    self.object_type=object_type
    self.initial=initial
    self.permission=permission
</t>
<t tx="ekr.20040104185913.830">initializePermission__roles__ = ()
def initializePermission(self):
    self.manage_setPermissionMapping(('Use Factories',),
                                     (self.permission,))
</t>
<t tx="ekr.20040104185913.831">def manage_edit(self, title, object_type, initial, permission='',
                REQUEST=None):
    "Modify factory properties."
    self._unregister()
    self.title=title
    self.object_type=object_type
    self.initial=initial
    self.permission=permission
    self.manage_setPermissionMapping(('Use Factories',), (permission,))
    self._register()
    if REQUEST is not None: return self.manage_main(self, REQUEST)
</t>
<t tx="ekr.20040104185913.832">def manage_afterAdd(self, item, container):
    if hasattr(self, 'aq_parent'):
        container=self.aq_parent
    elif item is not self:
        container=None
    if (item is self or
        getattr(container, '__class__', None) is Product.Product):
        self._register()
</t>
<t tx="ekr.20040104185913.833">def manage_beforeDelete(self, item, container):
    if hasattr(self, 'aq_parent'):
        container=self.aq_parent
    elif item is not self:
        container=None

    if (item is self or
        getattr(container, '__class__', None) is Product.Product):
        self._unregister()
</t>
<t tx="ekr.20040104185913.834">def _register(self):
    # Register with the product folder
    product=self.aq_parent
    product.aq_acquire('_manage_add_product_meta_type')(
        product, self.id, self.object_type, self.permission)
</t>
<t tx="ekr.20040104185913.835">def _unregister(self):
    # Unregister with the product folder
    product=self.aq_parent
    product.aq_acquire('_manage_remove_product_meta_type')(
        product, self.id, self.object_type)
</t>
<t tx="ekr.20040104185913.836">manage_main=Globals.DTMLFile('dtml/editFactory',globals())

def index_html(self, REQUEST):
    " "
    return getattr(self, self.initial)(self.aq_parent, REQUEST)
</t>
<t tx="ekr.20040104185913.837">def objectIds(self):
    return filter(
        lambda id, myid=self.id: id != myid,
        self.aq_parent.objectIds()
        )
</t>
<t tx="ekr.20040104185913.838">class ProductFactory(Factory): pass
</t>
<t tx="ekr.20040104185913.839">&lt;&lt; copyright &gt;&gt;

# Implement the manage_addProduct method of object managers
import Acquisition, sys, Products
from AccessControl.PermissionMapping import aqwrap
from AccessControl.Owned import UnownableOwner

@others
</t>
<t tx="ekr.20040104185913.841">class ProductDispatcher(Acquisition.Implicit):
	
	" "
	# Allow access to factory dispatchers
	__allow_access_to_unprotected_subobjects__=1

	@others</t>
<t tx="ekr.20040104185913.843">def __getitem__(self, name):
    return self.__bobo_traverse__(None, name)
</t>
<t tx="ekr.20040104185913.844">def __bobo_traverse__(self, REQUEST, name):
    product=self.aq_acquire('_getProducts')()._product(name)

    # Try to get a custom dispatcher from a Python product
    dispatcher_class=getattr(
        getattr(Products, name, None),
        '__FactoryDispatcher__',
        FactoryDispatcher)

    dispatcher=dispatcher_class(product, self.aq_parent, REQUEST)
    return dispatcher.__of__(self)
</t>
<t tx="ekr.20040104185913.845">class FactoryDispatcher(Acquisition.Implicit):
	
    """Provide a namespace for product "methods"
    """
	_owner=UnownableOwner

	@others
</t>
<t tx="ekr.20040104185913.847">def __init__(self, product, dest, REQUEST=None):
    if hasattr(product,'aq_base'): product=product.aq_base
    self._product=product
    self._d=dest
    if REQUEST is not None:
        try:
            v=REQUEST['URL']
        except KeyError: pass
        else:
            v=v[:v.rfind('/')]
            self._u=v[:v.rfind('/')]
</t>
<t tx="ekr.20040104185913.848">def Destination(self):
    "Return the destination for factory output"
    return self.__dict__['_d'] # we don't want to wrap the result!
</t>
<t tx="ekr.20040104185913.849">this=Destination
this__roles__=Destination__roles__=None


def DestinationURL(self):
    "Return the URL for the destination for factory output"
    url=getattr(self, '_u', None)
    if url is None:
        url=self.Destination().absolute_url()
    return url
</t>
<t tx="ekr.20040104185913.850">DestinationURL__roles__=None

def __getattr__(self, name):
    p=self.__dict__['_product']
    d=p.__dict__
    if hasattr(p,name) and d.has_key(name):
        m=d[name]
        w=getattr(m, '_permissionMapper', None)
        if w is not None:
            m=ofWrapper(aqwrap(m, getattr(w,'aq_base',w), self))

        return m

    # Waaa
    m='Products.%s' % p.id
    if sys.modules.has_key(m) and sys.modules[m]._m.has_key(name):
        return sys.modules[m]._m[name]

    raise AttributeError, name
</t>
<t tx="ekr.20040104185913.851"># Provide acquired indicators for critical OM methods:
_setObject=_getOb=Acquisition.Acquired

# Make sure factory methods are unowned:
_owner=UnownableOwner

# Provide a replacement for manage_main that does a redirection:
def manage_main(trueself, self, REQUEST, update_menu=0):
    """Implement a contents view by redirecting to the true view
    """
    d = update_menu and '/manage_main?update_menu=1' or '/manage_main'
    REQUEST['RESPONSE'].redirect(self.DestinationURL()+d)
</t>
<t tx="ekr.20040104185913.852">import ExtensionClass
class ofWrapper(ExtensionClass.Base):
	@others
</t>
<t tx="ekr.20040104185913.853">def __init__(self, o):
    self._o=o
</t>
<t tx="ekr.20040104185913.854">def __of__(self, parent): return self.__dict__['_o']
</t>
<t tx="ekr.20040104185913.855">&lt;&lt; copyright &gt;&gt;

"""Commonly used utility functions."""

__version__='$Revision: 1.11 $'[11:-2]

import os, sys, Products
from Common import package_home, realpath
path_join = os.path.join
path_split = os.path.split

try: home=os.environ['SOFTWARE_HOME']
except:
    home=package_home(Products.__dict__)
    if not os.path.isabs(home):
        home=path_join(os.getcwd(), home)

    home,e=path_split(home)
    if path_split(home)[1]=='.': home=path_split(home)[0]
    if path_split(home)[1]=='..':
        home=path_split(path_split(home)[0])[0]

home=realpath(home)
sys.modules['__builtin__'].SOFTWARE_HOME=SOFTWARE_HOME=home

try: zhome=os.environ['ZOPE_HOME']
except:
    zhome=os.path.join(home, '..', '..')

zhome=realpath(zhome)
sys.modules['__builtin__'].ZOPE_HOME=ZOPE_HOME=zhome

try:
    chome=os.environ['INSTANCE_HOME']
    chome = realpath(chome)
except:
    chome=home
    d,e=path_split(chome)
    if e=='python':
        d,e=path_split(d)
        if e=='lib': chome=d or os.getcwd()
else:
    inst_ppath = path_join(chome, 'lib', 'python')
    if os.path.isdir(inst_ppath):
        sys.path.insert(0, inst_ppath)

sys.modules['__builtin__'].INSTANCE_HOME=INSTANCE_HOME=chome

# CLIENT_HOME allows ZEO clients to easily keep distinct pid and
# log files. This is currently an *experimental* feature, as I expect
# that increasing ZEO deployment will cause bigger changes to the
# way that z2.py works fairly soon.
try:    CLIENT_HOME = os.environ['CLIENT_HOME']
except: CLIENT_HOME = path_join(INSTANCE_HOME, 'var')

sys.modules['__builtin__'].CLIENT_HOME=CLIENT_HOME

# If there is a Products package in INSTANCE_HOME, add it to the
# Products package path
ip=path_join(INSTANCE_HOME, 'Products')
ippart = 0
ppath = Products.__path__
if os.path.isdir(ip) and ip not in ppath:
    disallow=os.environ.get('DISALLOW_LOCAL_PRODUCTS','').lower()
    if disallow in ('no', 'off', '0', ''):
        ppath.insert(0, ip)
        ippart = 1

ppathpat = os.environ.get('PRODUCTS_PATH', None)
if ppathpat is not None:
    psep = os.pathsep
    if ppathpat.find('%(') &gt;= 0:
        newppath = (ppathpat % {
            'PRODUCTS_PATH': psep.join(ppath ),
            'SOFTWARE_PRODUCTS': psep.join(ppath[ippart:] ),
            'INSTANCE_PRODUCTS': ip,
            }).split(psep)
    else:
        newppath = ppathpat.split(psep)
    del ppath[:]
    for p in filter(None, newppath):
        p = os.path.abspath(p)
        if os.path.isdir(p) and p not in ppath:
            ppath.append(p)
</t>
<t tx="ekr.20040104185913.856">&lt;&lt; copyright &gt;&gt;

from version_txt import getZopeVersion
from zLOG import LOG, INFO, WARNING

merged_hotfixes = {
    'Hotfix_2001-09-28': 1,
    'Hotfix_2002-03-01': 1,
    'Hotfix_2002-04-15': 1,
    'Hotfix_2002-06-14': 1,
    }

APPLY = 1
ALREADY_MERGED = 0
OUTDATED_ZOPE = None

@others
</t>
<t tx="ekr.20040104185913.858">def isMerged(name):
    return merged_hotfixes.get(name, 0)
</t>
<t tx="ekr.20040104185913.859">def logHotfix(id, apply_hotfix):
    if apply_hotfix:
        LOG('Hotfixes', INFO, 'Applying %s' % id)
    elif apply_hotfix is OUTDATED_ZOPE:
        LOG('Hotfixes', WARNING, 'Not applying %s.  It is not designed for '
            'this version of Zope.  Please uninstall the hotfix product.'
            % id)
    else:  # ALREADY_MERGED
        LOG('Hotfixes', WARNING, 'Not applying %s.  The fix has already been '
            'merged into Zope.  Please uninstall the hotfix product.'
            % id)
</t>
<t tx="ekr.20040104185913.860">def beforeApplyHotfix(id, req_major, req_minor, req_micro):
    major, minor, micro = getZopeVersion()[:3]
    if major &gt; 0 and (
        (major * 10000 + minor * 100 + micro) &lt;
        (req_major * 10000 + req_minor * 100 + req_micro)):
        # The version of Zope is too old for this hotfix.
        apply_hotfix = OUTDATED_ZOPE
    elif isMerged(id):
        apply_hotfix = ALREADY_MERGED
    else:
        apply_hotfix = APPLY
    logHotfix(id, apply_hotfix)
    return apply_hotfix
</t>
<t tx="ekr.20040104185913.861">&lt;&lt; copyright &gt;&gt;

"""Image object that is stored in a file"""

__version__='$Revision: 1.18 $'[11:-2]

from OFS.content_types import guess_content_type
from Globals import package_home
from Common import rfc1123_date
from DateTime import DateTime
from time import time
from os import stat
import Acquisition
import Globals
import  os

@others
</t>
<t tx="ekr.20040104185913.863">class ImageFile(Acquisition.Explicit):
    """Image objects stored in external files."""
	@others
</t>
<t tx="ekr.20040104185913.864">def __init__(self,path,_prefix=None):
    if _prefix is None: _prefix=SOFTWARE_HOME
    elif type(_prefix) is not type(''):
        _prefix=package_home(_prefix)
    path = os.path.join(_prefix, path)
    self.path=path
    if Globals.DevelopmentMode:
        # In development mode, a shorter time is handy
        max_age = 60 # One minute
    else:
        # A longer time reduces latency in production mode
        max_age = 3600 # One hour
    self.cch = 'public,max-age=%d' % max_age

    file=open(path, 'rb')
    data=file.read()
    file.close()
    content_type, enc=guess_content_type(path, data)
    if content_type:
        self.content_type=content_type
    else:
        self.content_type='image/%s' % path[path.rfind('.')+1:]
    self.__name__=path[path.rfind('/')+1:]
    self.lmt=float(stat(path)[8]) or time()
    self.lmh=rfc1123_date(self.lmt)
</t>
<t tx="ekr.20040104185913.865">def index_html(self, REQUEST, RESPONSE):
    """Default document"""
    # HTTP If-Modified-Since header handling. This is duplicated
    # from OFS.Image.Image - it really should be consolidated
    # somewhere...
    RESPONSE.setHeader('Content-Type', self.content_type)
    RESPONSE.setHeader('Last-Modified', self.lmh)
    RESPONSE.setHeader('Cache-Control', self.cch)
    header=REQUEST.get_header('If-Modified-Since', None)
    if header is not None:
        header=header.split(';')[0]
        # Some proxies seem to send invalid date strings for this
        # header. If the date string is not valid, we ignore it
        # rather than raise an error to be generally consistent
        # with common servers such as Apache (which can usually
        # understand the screwy date string as a lucky side effect
        # of the way they parse it).
        try:    mod_since=long(DateTime(header).timeTime())
        except: mod_since=None
        if mod_since is not None:
            if getattr(self, 'lmt', None):
                last_mod = long(self.lmt)
            else:
                last_mod = long(0)
            if last_mod &gt; 0 and last_mod &lt;= mod_since:
                RESPONSE.setStatus(304)
                return ''

    f=open(self.path,'rb')
    data=f.read()
    f.close()
    return data
</t>
<t tx="ekr.20040104185913.866">HEAD__roles__=None
def HEAD(self, REQUEST, RESPONSE):
    """ """
    RESPONSE.setHeader('Content-Type', self.content_type)
    RESPONSE.setHeader('Last-Modified', self.lmh)
    return ''
</t>
<t tx="ekr.20040104185913.867">def __len__(self):
    # This is bogus and needed because of the way Python tests truth.
    return 1
</t>
<t tx="ekr.20040104185913.868">def __str__(self):
    return '&lt;img src="%s" alt="" /&gt;' % self.__name__
</t>
<t tx="ekr.20040104185913.869">&lt;&lt; copyright &gt;&gt;

"""Standard management interface support

$Id: Management.py,v 1.61 2002/08/14 21:31:40 mj Exp $"""

__version__='$Revision: 1.61 $'[11:-2]

import sys, Globals, ExtensionClass, urllib
from Dialogs import MessageDialog
from Globals import DTMLFile, HTMLFile
from AccessControl import getSecurityManager, Unauthorized

@others

file = DTMLFile('dtml/manage_page_style.css', globals())
setattr(Navigation, 'manage_page_style.css', file)
setattr(Navigation, 'manage_page_style.css__roles__', None)</t>
<t tx="ekr.20040104185913.871">class Tabs(ExtensionClass.Base):
    """Mix-in provides management folder tab support."""
	&lt;&lt; class Tabs declarations &gt;&gt;
	@others

Globals.default__class_init__(Tabs)</t>
<t tx="ekr.20040104185913.872">manage_tabs__roles__=('Anonymous',)
manage_tabs=DTMLFile('dtml/manage_tabs', globals())


manage_options  =()

filtered_manage_options__roles__=None
</t>
<t tx="ekr.20040104185913.873">def filtered_manage_options(self, REQUEST=None):

    validate=getSecurityManager().validate

    result=[]

    try: options=tuple(self.manage_options)
    except: options=tuple(self.manage_options())

    for d in options:

        filter=d.get('filter', None)
        if filter is not None and not filter(self):
            continue

        path=d.get('path', None)
        if path is None: path=d['action']

        o=self.unrestrictedTraverse(path, None)
        if o is None: continue

        try:
            if validate(None, self, None, o):
                result.append(d)
        except:
            if not hasattr(o, '__roles__'):
                result.append(d)

    return result
</t>
<t tx="ekr.20040104185913.874">manage_workspace__roles__=('Authenticated',)
def manage_workspace(self, REQUEST):
    """Dispatch to first interface in manage_options
    """
    options=self.filtered_manage_options(REQUEST)
    try:
        m=options[0]['action']
        if m=='manage_workspace': raise TypeError
    except:
        raise Unauthorized, (
            'You are not authorized to view this object.')

    if m.find('/'):
        raise 'Redirect', (
            "%s/%s" % (REQUEST['URL1'], m))

    return getattr(self, m)(self, REQUEST)
</t>
<t tx="ekr.20040104185913.875">def tabs_path_default(self, REQUEST,
                      # Static var
                      unquote=urllib.unquote,
                      ):
    steps = REQUEST._steps[:-1]
    script = REQUEST['BASEPATH1']
    linkpat = '&lt;a href="%s/manage_workspace"&gt;%s&lt;/a&gt;'
    out = []
    url = linkpat % (script, '&amp;nbsp;/')
    if not steps:
        return url
    last = steps.pop()
    for step in steps:
        script = '%s/%s' % (script, step)
        out.append(linkpat % (script, unquote(step)))
    script = '%s/%s' % (script, last)
    out.append('&lt;a class="strong-link" href="%s/manage_workspace"&gt;%s&lt;/a&gt;'%
               (script, unquote(last)))
    return '%s%s' % (url, '/'.join(out))
</t>
<t tx="ekr.20040104185913.876">def tabs_path_info(self, script, path,
                   # Static vars
                   quote=urllib.quote,
                   ):
    out=[]
    while path[:1]=='/': path=path[1:]
    while path[-1:]=='/': path=path[:-1]
    while script[:1]=='/': script=script[1:]
    while script[-1:]=='/': script=script[:-1]
    path=path.split('/')[:-1]
    if script: path=[script]+path
    if not path: return ''
    script=''
    last=path[-1]
    del path[-1]
    for p in path:
        script="%s/%s" % (script, quote(p))
        out.append('&lt;a href="%s/manage_workspace"&gt;%s&lt;/a&gt;' % (script, p))
    out.append(last)
    return '/'.join(out)
</t>
<t tx="ekr.20040104185913.877">class_manage_path__roles__=None
def class_manage_path(self):
    if self.__class__.__module__[:1] != '*': return
    path = getattr(self.__class__, '_v_manage_path_roles', None)
    if path is None:
        meta_type = self.meta_type
        for zclass in self.getPhysicalRoot()._getProductRegistryData(
            'zclasses'):
            if zclass['meta_type'] == meta_type:
                break
        else:
            self.__class__._v_manage_path_roles = ''
            return
        path = self.__class__._v_manage_path_roles = (
            '%(product)s/%(id)s' % zclass)
    if path:
        return '/Control_Panel/Products/%s/manage_workspace' % path
</t>
<t tx="ekr.20040104185913.878">class Navigation(ExtensionClass.Base):
    """Basic navigation UI support"""
	&lt;&lt; class Navigation declarations &gt;&gt;
	@others

    manage_zmi_prefs=DTMLFile('dtml/manage_zmi_prefs', globals())
    manage_zmi_prefs__roles__ = None
	
Globals.default__class_init__(Navigation)
</t>
<t tx="ekr.20040104185913.879">__ac_permissions__=(
    ('View management screens',
     ('manage', 'manage_menu', 'manage_top_frame',
      'manage_page_header',
      'manage_page_footer',
      )),
    )

manage            =DTMLFile('dtml/manage', globals())
manage_menu       =DTMLFile('dtml/menu', globals())

manage_top_frame  =DTMLFile('dtml/manage_top_frame', globals())
manage_page_header=DTMLFile('dtml/manage_page_header', globals())
manage_page_footer=DTMLFile('dtml/manage_page_footer', globals())

manage_form_title =DTMLFile('dtml/manage_form_title', globals(),
                            form_title='Add Form',
                            help_product=None,
                            help_topic=None)
manage_form_title._setFuncSignature(
    varnames=('form_title', 'help_product', 'help_topic') )
manage_form_title__roles__ = None

zope_quick_start=DTMLFile('dtml/zope_quick_start', globals())
zope_quick_start__roles__=None

manage_copyright=DTMLFile('dtml/copyright', globals())
manage_copyright__roles__ = None

manage_zmi_logout__roles__ = None
</t>
<t tx="ekr.20040104185913.880">def manage_zmi_logout(self, REQUEST, RESPONSE):
    """Logout current user"""
    p = getattr(REQUEST, '_logout_path', None)
    if p is not None:
        return apply(self.restrictedTraverse(p))

    realm=RESPONSE.realm
    RESPONSE.setStatus(401)
    RESPONSE.setHeader('WWW-Authenticate', 'basic realm="%s"' % realm, 1)
    RESPONSE.setBody("""&lt;html&gt;
&lt;head&gt;&lt;title&gt;Logout&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
You have been logged out.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;""")
    return
</t>
<t tx="ekr.20040104185913.881">&lt;&lt; copyright &gt;&gt;

__doc__='''Zope registerable permissions

$Id: Permission.py,v 1.8.6.1 2003/05/28 14:50:25 shane Exp $'''

__version__='$Revision: 1.8.6.1 $'[11:-2]

import OFS.SimpleItem, Acquisition, Globals, ExtensionClass, AccessControl.Role
from AccessControl import ClassSecurityInfo, Permissions

view_management_screens = Permissions.view_management_screens
define_permissions = Permissions.define_permissions

@others

Globals.InitializeClass(PermissionManager)
</t>
<t tx="ekr.20040104185913.883">class Permission(
	&lt;&lt; class Permission declarations &gt;&gt;
	@others

    security.declareProtected(view_management_screens, 'manage_main')
    manage_main=Globals.DTMLFile('dtml/editPermission',globals())

    index_html=None</t>
<t tx="ekr.20040104185913.884">AccessControl.Role.RoleManager,
Globals.Persistent, Acquisition.Implicit, OFS.SimpleItem.Item
):
"Model Permission meta-data"
meta_type='Zope Permission'
icon='p_/Permission_icon'
security = ClassSecurityInfo()

manage_options=(
    (
    {'label':'Edit', 'action':'manage_main',
     'help':('OFSP','Zope-Permission_Edit.stx')},
    )
    +AccessControl.Role.RoleManager.manage_options
    +OFS.SimpleItem.Item.manage_options
    )

</t>
<t tx="ekr.20040104185913.885">def __init__(self, id, title, name):
    self.id=id
    self.title=title
    self.name=name
</t>
<t tx="ekr.20040104185913.886">security.declareProtected(define_permissions, 'manage_edit')
def manage_edit(self, title, name, REQUEST=None):
    "Modify Permission properties."
    if title != self.title: self.title=title
    if name != self.name:
        self._unregister()
        self.name=name
        self._register()
    if REQUEST is not None: return self.manage_main(self, REQUEST)
</t>
<t tx="ekr.20040104185913.887">security.declarePrivate('manage_afterAdd')
def manage_afterAdd(self, item, container):
    self._register()
</t>
<t tx="ekr.20040104185913.888">security.declarePrivate('manage_beforeDelete')
def manage_beforeDelete(self, item, container):
    self._unregister()
</t>
<t tx="ekr.20040104185913.889">def _register(self):
    # Register with the product folder
    product=self.aq_parent
    product.aq_acquire('_manage_add_product_permission')(
        product, self.name)
</t>
<t tx="ekr.20040104185913.890">def _unregister(self):
    # Unregister with the product folder
    product=self.aq_parent
    product.aq_acquire('_manage_remove_product_permission')(
        product, self.name)
</t>
<t tx="ekr.20040104185913.891">Globals.InitializeClass(Permission)


class PermissionManager(ExtensionClass.Base):
	&lt;&lt; class PermissionManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.892">security = ClassSecurityInfo()

meta_types={
    'name': Permission.meta_type, 'action': 'manage_addPermissionForm'
    },

security.declareProtected(define_permissions, 'manage_addPermissionForm')
manage_addPermissionForm=Globals.DTMLFile('dtml/addPermission',globals())

security.declareProtected(define_permissions, 'manage_addPermission')
</t>
<t tx="ekr.20040104185913.893">def manage_addPermission(
    self, id, title, permission, REQUEST=None):
    ' '
    i=Permission(id, title, permission)
    self._setObject(id,i)
    if REQUEST is not None:
        return self.manage_main(self,REQUEST,update_menu=1)
</t>
<t tx="ekr.20040104185913.894">&lt;&lt; copyright &gt;&gt;

from class_init import default__class_init__
from Persistence import Persistent
import Globals
from DateTime import DateTime

Persistent.__dict__['__class_init__']=default__class_init__

@others

for k, v in PersistentUtil.__dict__.items():
	Persistent.__dict__[k]=v

</t>
<t tx="ekr.20040104185913.896">class PersistentUtil:
	@others
</t>
<t tx="ekr.20040104185913.897">def bobobase_modification_time(self):
    jar=self._p_jar
    oid=self._p_oid
    if jar is None or oid is None: return DateTime()

    try:
        t=self._p_mtime
        if t is None: return DateTime()
    except: t=0
    return DateTime(t)
</t>
<t tx="ekr.20040104185913.898">def locked_in_version(self):
    """Was the object modified in any version?
    """
    jar=self._p_jar
    oid=self._p_oid
    if jar is None or oid is None: return None
    try: mv=jar.modifiedInVersion
    except: pass
    else: return mv(oid)

    # BoboPOS 2 code:
    oid=self._p_oid
    return (oid
            and Globals.VersionBase.locks.has_key(oid)
            and Globals.VersionBase.verify_lock(oid)
            and 'some version')
</t>
<t tx="ekr.20040104185913.899">def modified_in_version(self):
    """Was the object modified in this version?
    """
    jar=self._p_jar
    oid=self._p_oid
    if jar is None or oid is None: return None
    try: mv=jar.modifiedInVersion
    except: pass
    else: return mv(oid)==jar.getVersion()

    # BoboPOS 2 code:
    jar=self._p_jar
    if jar is None:
        if hasattr(self,'aq_parent') and hasattr(self.aq_parent, '_p_jar'):
            jar=self.aq_parent._p_jar
        if jar is None: return 0
    if not jar.name: return 0
    try: jar.db[self._p_oid]
    except: return 0
    return 1
</t>
<t tx="ekr.20040104185913.900">&lt;&lt; copyright &gt;&gt;

"""Product objects
"""
# The new Product model:
#
#   Products may be defined in the Products folder or by placing directories
#   in lib/python/Products.
#
#   Products in lib/python/Products may have up to three sources of information:
#
#       - Static information defined via Python.  This information is
#         described and made available via __init__.py.
#
#       - Dynamic object data that gets copied into the Bobobase.
#         This is contained in product.dat (which is obfuscated).
#
#       - Static extensions supporting the dynamic data.  These too
#         are obfuscated.
#
#   Products may be copied and pasted only within the products folder.
#
#   If a product is deleted (or cut), it is automatically recreated
#   on restart if there is still a product directory.

&lt;&lt; Product imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.901">import Globals, OFS.Folder, OFS.SimpleItem, os,  Acquisition, Products
import re, zlib, Globals, cPickle, marshal, rotor
import ZClasses, ZClasses.ZClass, AccessControl.Owned
from urllib import quote
from cgi import escape

from OFS.Folder import Folder
from Factory import Factory
from Permission import PermissionManager
import ZClasses, ZClasses.ZClass
from HelpSys.HelpSys import ProductHelp
import RefreshFuncs
from AccessControl import Unauthorized</t>
<t tx="ekr.20040104185913.902">class ProductFolder(Folder):
	&lt;&lt; class ProductFolder declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.903">"Manage a collection of Products"

id        ='Products'
name=title='Product Management'
meta_type ='Product Management'
icon='p_/ProductFolder_icon'

all_meta_types={'name': 'Product', 'action': 'manage_addProductForm'},
meta_types=all_meta_types

# This prevents subobjects from being owned!
_owner=AccessControl.Owned.UnownableOwner

</t>
<t tx="ekr.20040104185913.904">def _product(self, name): return getattr(self, name)
</t>
<t tx="ekr.20040104185913.905">manage_addProductForm=Globals.DTMLFile('dtml/addProduct',globals())
def manage_addProduct(self, id, title, REQUEST=None):
    ' '
    i=Product(id, title)
    self._setObject(id,i)
    if REQUEST is not None:
        return self.manage_main(self,REQUEST,update_menu=1)
</t>
<t tx="ekr.20040104185913.906">def _canCopy(self, op=0):
    return 0
</t>
<t tx="ekr.20040104185913.907">Globals.InitializeClass(ProductFolder)


class Product(Folder, PermissionManager):
    """Model a product that can be created through the web.
    """
	&lt;&lt; class Product declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.908">meta_type='Product'
icon='p_/Product_icon'
version=''
configurable_objects_=()
redistributable=0
import_error_=None
_isBeingUsedAsAMethod_=1

</t>
<t tx="ekr.20040104185913.909">def new_version(self,
                _intending=re.compile(r"[0-9]+").search, #TS
                ):
    # Return a new version number based on the existing version.
    v=str(self.version)
    if not v: return '1.0'
    match = _intending(v)
    if match is None:
        return v
    while 1:
        # Find the last set of digits.
        m = _intending(v, match.end())
        if m is None:
            break
        else:
            match = m
    start = match.start()
    end = match.end()
    return v[:start] + str(1 + int(v[start:end])) + v[end:]
</t>
<t tx="ekr.20040104185913.910">meta_types=(
    ZClasses.meta_types+PermissionManager.meta_types+
    (
        {
            'name': Factory.meta_type,
            'action': 'manage_addPrincipiaFactoryForm'
            },
        )
    )

manage_addZClassForm=ZClasses.methods['manage_addZClassForm']
manage_addZClass    =ZClasses.methods['manage_addZClass']
manage_subclassableClassNames=ZClasses.methods[
    'manage_subclassableClassNames']

manage_options=(
    (Folder.manage_options[0],) +
    tuple(Folder.manage_options[2:]) +
    (
    {'label':'Distribution', 'action':'manage_distributionView',
     'help':('OFSP','Product_Distribution.stx')},
    )
    )

manage_distributionView=Globals.DTMLFile(
    'dtml/distributionView',globals())

_properties=Folder._properties+(
    {'id':'version', 'type': 'string'},
    )

_reserved_names=('Help',)

manage_addPrincipiaFactoryForm=Globals.DTMLFile(
    'dtml/addFactory',globals())
def manage_addPrincipiaFactory(
    self, id, title, object_type, initial, permission=None, REQUEST=None):
    ' '
    i=Factory(id, title, object_type, initial, permission)
    self._setObject(id,i)
    factory = self._getOb(id)
    factory.initializePermission()
    if REQUEST is not None:
        return self.manage_main(self,REQUEST,update_menu=1)
</t>
<t tx="ekr.20040104185913.911">def __init__(self, id, title):
    self.id=id
    self.title=title

    # Workaround for unknown problem with help system and PluginIndexes product
    # NEEDS to be fixed for 2.4 ! (ajung)

    try:
        self._setObject('Help', ProductHelp('Help', id))
    except:
        pass
</t>
<t tx="ekr.20040104185913.912">def Destination(self):
    "Return the destination for factory output"
    return self
</t>
<t tx="ekr.20040104185913.913">Destination__roles__=None

def DestinationURL(self):
    "Return the URL for the destination for factory output"
    return self.REQUEST['BASE4']
</t>
<t tx="ekr.20040104185913.914">DestinationURL__roles__=None

def manage_distribute(self, version, RESPONSE, configurable_objects=[],
                      redistributable=0):
    "Set the product up to create a distribution and give a link"
    if self.__dict__.has_key('manage_options'):
        raise TypeError, 'This product is &lt;b&gt;not&lt;/b&gt; redistributable.'
    self.version=version=version.strip()
    self.configurable_objects_=configurable_objects
    self.redistributable=redistributable
    RESPONSE.redirect('Distributions/%s-%s.tar.gz' %
                      (quote(self.id), quote(version)))
</t>
<t tx="ekr.20040104185913.915">def _distribution(self):
    # Return a distribution
    if self.__dict__.has_key('manage_options'):
        raise TypeError, 'This product is &lt;b&gt;not&lt;/b&gt; redistributable.'

    id=self.id

    import tar
    rot=rotor.newrotor(id+' shshsh')
    ar=tar.tgzarchive("%s-%s" % (id, self.version))
    prefix="Products/%s/" % self.id

    # __init__.py
    ar.add(prefix+"__init__.py",
           '''"Product %s"
           ''' % id
           )

    # Extensions
    pp=id+'.'
    lpp=len(pp)
    ed=os.path.join(INSTANCE_HOME,'Extensions')
    if os.path.exists(ed):
        for name in os.listdir(ed):
            suffix=''
            if name[:lpp]==pp:
                path=os.path.join(ed, name)
                try:
                    f=open(path)
                    data=f.read()
                    f.close()
                    if name[-3:]=='.py':
                        data=rot.encrypt(zlib.compress(data))
                        suffix='p'
                except: data=None
                if data:
                    ar.add("%sExtensions/%s%s" %
                           (prefix,name[lpp:],suffix),
                           data)

    # version.txt
    ar.add(prefix+'version.txt', self.version)

    # product.dat
    f=CompressedOutputFile(rot)
    if self.redistributable:
        # Since it's redistributable, make all objects configurable.
        objectList = self._objects
    else:
        objectList = tuple(filter(
            lambda o, obs=self.configurable_objects_:
            o['id'] in obs,
            self._objects))
    meta={
        '_objects': objectList,
        'redistributable': self.redistributable,
        }
    f.write(cPickle.dumps(meta,1))

    self._p_jar.exportFile(self._p_oid, f)
    ar.add(prefix+'product.dat', f.getdata())

    ar.finish()
    return str(ar)
</t>
<t tx="ekr.20040104185913.916">class Distributions(Acquisition.Explicit):
	&lt;&lt; class Distributions declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.917">"Product Distributions"

</t>
<t tx="ekr.20040104185913.918">def __bobo_traverse__(self, REQUEST, name):
    if name[-7:] != '.tar.gz': raise 'Invalid Name', escape(name)
    l=name.find('-')
    id, version = name[:l], name[l+1:-7]
    product=self.aq_parent
    if product.id==id and product.version==version:
        return Distribution(product)

    raise 'Invalid version or product id', escape(name)
</t>
<t tx="ekr.20040104185913.919">Distributions=Distributions()

manage_traceback=Globals.DTMLFile('dtml/traceback',globals())
manage_readme=Globals.DTMLFile('dtml/readme',globals())
def manage_get_product_readme__(self):
    for name in ('README.txt', 'README.TXT', 'readme.txt'):
        path = os.path.join(self.home, name)
        if os.path.isfile(path):
            return open(path).read()
    return ''
</t>
<t tx="ekr.20040104185913.920">def permissionMappingPossibleValues(self):
    return self.possible_permissions()
</t>
<t tx="ekr.20040104185913.921">def zclass_product_name(self):
    return self.id
</t>
<t tx="ekr.20040104185913.922">def getProductHelp(self):
    """
    Returns the ProductHelp object associated
    with the Product.
    """
    if not hasattr(self, 'Help'):
        self._setObject('Help', ProductHelp('Help', self.id))
    return self.Help
</t>
<t tx="ekr.20040104185913.923">#
# Product refresh
#

_refresh_dtml = Globals.DTMLFile('dtml/refresh', globals())

def _readRefreshTxt(self, pid=None):
    refresh_txt = None
    if pid is None:
        pid = self.id
    for productDir in Products.__path__:
        found = 0
        for name in ('refresh.txt', 'REFRESH.txt', 'REFRESH.TXT'):
            p = os.path.join(productDir, pid, name)
            if os.path.exists(p):
                found = 1
                break
        if found:
            try:
                file = open(p)
                text = file.read()
                file.close()
                refresh_txt = text
                break
            except:
                # Not found here.
                pass
    return refresh_txt
</t>
<t tx="ekr.20040104185913.924">def manage_refresh(self, REQUEST, manage_tabs_message=None):
    '''
    Displays the refresh management screen.
    '''
    error_type = error_value = error_tb = None
    exc = RefreshFuncs.getLastRefreshException(self.id)
    if exc is not None:
        error_type, error_value, error_tb = exc
        exc = None

    refresh_txt = self._readRefreshTxt()

    # Read the persistent refresh information.
    auto = RefreshFuncs.isAutoRefreshEnabled(self._p_jar, self.id)
    deps = RefreshFuncs.getDependentProducts(self._p_jar, self.id)

    # List all product modules.
    mods = RefreshFuncs.listRefreshableModules(self.id)
    loaded_modules = []
    prefix = 'Products.%s' % self.id
    prefixdot = prefix + '.'
    lpdot = len(prefixdot)
    for name, module in mods:
        if name == prefix or name[:lpdot] == prefixdot:
            name = name[lpdot:]
            if not name:
                name = '__init__'
        loaded_modules.append(name)

    all_auto = RefreshFuncs.listAutoRefreshableProducts(self._p_jar)
    for pid in all_auto:
        # Ignore products that don't have a refresh.txt.
        if self._readRefreshTxt(pid) is None:
            all_auto.remove(pid)
    auto_other = filter(lambda productId, myId=self.id:
                        productId != myId, all_auto)

    # Return rendered DTML.
    return self._refresh_dtml(REQUEST,
                              id=self.id,
                              refresh_txt=refresh_txt,
                              error_type=error_type,
                              error_value=error_value,
                              error_tb=error_tb,
                              devel_mode=Globals.DevelopmentMode,
                              auto_refresh_enabled=auto,
                              auto_refresh_other=auto_other,
                              dependent_products=deps,
                              loaded_modules=loaded_modules,
                              manage_tabs_message=manage_tabs_message,
                              management_view='Refresh')
</t>
<t tx="ekr.20040104185913.925">def manage_performRefresh(self, REQUEST=None):
    '''
    Attempts to perform a refresh operation.
    '''
    if self._readRefreshTxt() is None:
        raise Unauthorized, 'refresh.txt not found'
    message = None
    if RefreshFuncs.performFullRefresh(self._p_jar, self.id):
        from ZODB import Connection
        Connection.updateCodeTimestamp() # Clears cache in next connection.
        message = 'Product refreshed.'
    else:
        message = 'An exception occurred.'
    if REQUEST is not None:
        return self.manage_refresh(REQUEST, manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.926">def manage_enableAutoRefresh(self, enable=0, REQUEST=None):
    '''
    Changes the auto refresh flag for this product.
    '''
    if self._readRefreshTxt() is None:
        raise Unauthorized, 'refresh.txt not created'
    RefreshFuncs.enableAutoRefresh(self._p_jar, self.id, enable)
    if enable:
        message = 'Enabled auto refresh.'
    else:
        message = 'Disabled auto refresh.'
    if REQUEST is not None:
        return self.manage_refresh(REQUEST, manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.927">def manage_selectDependentProducts(self, selections=(), REQUEST=None):
    '''
    Selects which products to refresh simultaneously.
    '''
    if self._readRefreshTxt() is None:
        raise Unauthorized, 'refresh.txt not created'
    RefreshFuncs.setDependentProducts(self._p_jar, self.id, selections)
    if REQUEST is not None:
        return self.manage_refresh(REQUEST)
</t>
<t tx="ekr.20040104185913.928">Globals.InitializeClass(Product)


class CompressedOutputFile:
	@others
</t>
<t tx="ekr.20040104185913.929">def __init__(self, rot):
    self._c=zlib.compressobj()
    self._r=[]
    self._rot=rot
    rot.encrypt('')
</t>
<t tx="ekr.20040104185913.930">def write(self, s):
    self._r.append(self._rot.encryptmore(self._c.compress(s)))
</t>
<t tx="ekr.20040104185913.931">def getdata(self):
    self._r.append(self._rot.encryptmore(self._c.flush()))
    return ''.join(self._r)
</t>
<t tx="ekr.20040104185913.932">class CompressedInputFile:
	&lt;&lt; class CompressedInputFile declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.933">_done=0
</t>
<t tx="ekr.20040104185913.934">def __init__(self, f, rot):
    self._c=zlib.decompressobj()
    self._b=''
    if type(rot) is type(''): rot=rotor.newrotor(rot)
    self._rot=rot
    rot.decrypt('')
    self._f=f
</t>
<t tx="ekr.20040104185913.935">def _next(self):
    if self._done: return
    l=self._f.read(8196)
    if not l:
        l=self._c.flush()
        self._done=1
    else:
        l=self._c.decompress(self._rot.decryptmore(l))
    self._b=self._b+l
</t>
<t tx="ekr.20040104185913.936">def read(self, l=None):
    if l is None:
        while not self._done: self._next()
        l=len(self._b)
    else:
        while l &gt; len(self._b) and not self._done: self._next()
    r=self._b[:l]
    self._b=self._b[l:]

    return r
</t>
<t tx="ekr.20040104185913.937">def readline(self):
    l=self._b.find('\n')
    while l &lt; 0 and not self._done:
        self._next()
        l=self._b.find('\n')
    if l &lt; 0: l=len(self._b)
    else: l=l+1
    r=self._b[:l]
    self._b=self._b[l:]
    return r
</t>
<t tx="ekr.20040104185913.938">class Distribution:
	&lt;&lt; class Distribution declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.939">"A distribution builder"

</t>
<t tx="ekr.20040104185913.940">def __init__(self, product):
    self._product=product
</t>
<t tx="ekr.20040104185913.941">def index_html(self, RESPONSE):
    "Return distribution data"
    r=self._product._distribution()
    RESPONSE['content-type']='application/x-gzip'
    return r
</t>
<t tx="ekr.20040104185913.942">def initializeProduct(productp, name, home, app):
    # Initialize a levered product
    products=app.Control_Panel.Products
    fver = ''

    if hasattr(productp, '__import_error__'): ie=productp.__import_error__
    else: ie=None
        
    # Retrieve version number from any suitable version.txt
    for fname in ('version.txt', 'VERSION.txt', 'VERSION.TXT'):
        try:
            fpath = os.path.join(home, fname)
            fhandle = open(fpath, 'r')
            fver = fhandle.read().strip()
            fhandle.close()
            break
        except IOError:
            continue

    old=None
    try:
        if ihasattr(products,name):
            old=getattr(products, name)
            if ihasattr(old,'version') and old.version==fver:
                if hasattr(old, 'import_error_') and \
                   old.import_error_==ie:
                    # Version hasn't changed. Don't reinitialize.
                    return old
    except: pass

    disable_distribution = 1
    try:
        f=CompressedInputFile(open(home+'/product.dat','rb'), name+' shshsh')
    except:
        f=fver and (" (%s)" % fver)
        product=Product(name, 'Installed product %s%s' % (name,f))
    else:
        meta=cPickle.Unpickler(f).load()
        product=app._p_jar.importFile(f)
        if meta.get('redistributable', 0):
            disable_distribution = 0
        product._objects=meta['_objects']

    if old is not None:
        app._manage_remove_product_meta_type(product)
        products._delObject(name)
        for id, v in old.objectItems():
            try: product._setObject(id, v)
            except: pass

    products._setObject(name, product)
    #product.__of__(products)._postCopy(products)
    product.icon='p_/InstalledProduct_icon'
    product.version=fver
    product.home=home
    if disable_distribution:
        product.manage_options=(Folder.manage_options[0],) + \
                                tuple(Folder.manage_options[2:])
        product._distribution=None
        product.manage_distribution=None
    product.thisIsAnInstalledProduct=1

    if ie:
        product.import_error_=ie
        product.title='Broken product %s' % name
        product.icon='p_/BrokenProduct_icon'
        product.manage_options=(
            {'label':'Traceback', 'action':'manage_traceback'},
            )

    for name in ('README.txt', 'README.TXT', 'readme.txt'):
        path = os.path.join(home, name)
        if os.path.isfile(path):
            product.manage_options=product.manage_options+(
                {'label':'README', 'action':'manage_readme'},
                )
            break

    # Ensure this product has a refresh tab.
    found = 0
    for option in product.manage_options:
        if option.get('label') == 'Refresh':
            found = 1
            break
    if not found:
        product.manage_options = product.manage_options + (
            {'label':'Refresh', 'action':'manage_refresh',
             'help': ('OFSP','Product_Refresh.stx')},)

    if not doInstall():
        get_transaction().abort()
        return product

    # Give the ZClass fixup code in Application
    Globals.__disk_product_installed__=1
    return product
</t>
<t tx="ekr.20040104185913.943">def ihasattr(o, name):
    return hasattr(o, name) and o.__dict__.has_key(name)
</t>
<t tx="ekr.20040104185913.944">def doInstall():
    if os.environ.has_key('FORCE_PRODUCT_LOAD'):
        return not not os.environ['FORCE_PRODUCT_LOAD']

    return not os.environ.get('ZEO_CLIENT')
</t>
<t tx="ekr.20040104185913.945">&lt;&lt; copyright &gt;&gt;

"""Objects providing context for product initialization
"""

&lt;&lt; ProductContext imports &gt;&gt;

if not hasattr(Products, 'meta_types'): Products.meta_types=()
if not hasattr(Products, 'meta_classes'):
    Products.meta_classes={}
    Products.meta_class_info={}

_marker = []  # Create a new marker object

@others
</t>
<t tx="ekr.20040104185913.946">from AccessControl.PermissionRole import PermissionRole
import Globals, os, OFS.ObjectManager, OFS.misc_, Products
import AccessControl.Permission
from HelpSys import HelpTopic, APIHelpTopic
from HelpSys.HelpSys import ProductHelp
from FactoryDispatcher import FactoryDispatcher
from zLOG import LOG, WARNING
import os.path, re
import stat
from DateTime import DateTime
from types import ListType, TupleType
from Interface.Implements import instancesOfObjectImplements
from App.Product import doInstall

import ZClasses # to enable 'PC.registerBaseClass()'</t>
<t tx="ekr.20040104185913.947">class ProductContext:
	@others
</t>
<t tx="ekr.20040104185913.948">def __init__(self, product, app, package):
    self.__prod=product
    self.__app=app
    self.__pack=package
</t>
<t tx="ekr.20040104185913.949">def registerClass(self, instance_class=None, meta_type='',
                  permission=None, constructors=(),
                  icon=None, permissions=None, legacy=(),
                  visibility="Global",interfaces=_marker,
                  container_filter=None
    ):
    """Register a constructor

    Keyword arguments are used to provide meta data:

    instance_class -- The class of the object that will be created.

      This is not currently used, but may be used in the future to
      increase object mobility.

    meta_type -- The kind of object being created
       This appears in add lists.  If not specified, then the class
       meta_type will be used.

    permission -- The permission name for the constructors.
       If not specified, then a permission name based on the
       meta type will be used.

    constructors -- A list of constructor methods
      A method can me a callable object with a __name__
      attribute giving the name the method should have in the
      product, or the method may be a tuple consisting of a
      name and a callable object.  The method must be picklable.

      The first method will be used as the initial method called
      when creating an object.

    icon -- The name of an image file in the package to
            be used for instances. Note that the class icon
            attribute will be set automagically if an icon is
            provided.

    permissions -- Additional permissions to be registered
       If not provided, then permissions defined in the
       class will be registered.

    legacy -- A list of legacy methods to be added to ObjectManager
              for backward compatibility

    visibility -- "Global" if the object is globally visible, None else

    interfaces -- a list of the interfaces the object supports

    container_filter -- function that is called with an ObjectManager
       object as the only parameter, which should return a true object
       if the object is happy to be created in that container. The
       filter is called before showing ObjectManager's Add list,
       and before pasting (after object copy or cut), but not
       before calling an object's constructor.

    """
    app=self.__app
    pack=self.__pack
    initial=constructors[0]
    tt=type(())
    productObject=self.__prod
    pid=productObject.id

    if icon and instance_class is not None:
        setattr(instance_class, 'icon', 'misc_/%s/%s' %
                (pid, os.path.split(icon)[1]))

    OM=OFS.ObjectManager.ObjectManager

    if permissions:
        if type(permissions) is type(''): # You goofed it!
            raise TypeError, ('Product context permissions should be a '
                'list of permissions not a string', permissions)
        for p in permissions:
            if type(p) is tt:
                p, default= p
                AccessControl.Permission.registerPermissions(
                    ((p, (), default),))
            else:
                AccessControl.Permission.registerPermissions(
                    ((p, ()),))

    ############################################################
    # Constructor permission setup
    if permission is None:
        permission="Add %ss" % (meta_type or instance_class.meta_type)

    if type(permission) is tt:
        permission, default = permission
    else:
        default = ('Manager',)

    pr=PermissionRole(permission,default)
    AccessControl.Permission.registerPermissions(
        ((permission, (), default),))
    ############################################################

    for method in legacy:
        if type(method) is tt:
            name, method = method
            aliased = 1
        else:
            name=method.__name__
            aliased = 0
        if not OM.__dict__.has_key(name):
            setattr(OM, name, method)
            setattr(OM, name+'__roles__', pr)
            if aliased:
                # Set the unaliased method name and its roles
                # to avoid security holes.  XXX: All "legacy"
                # methods need to be eliminated.
                setattr(OM, method.__name__, method)
                setattr(OM, method.__name__+'__roles__', pr)

    if type(initial) is tt: name, initial = initial
    else: name=initial.__name__

    fd=getattr(pack, '__FactoryDispatcher__', None)
    if fd is None:
        class __FactoryDispatcher__(FactoryDispatcher):
            "Factory Dispatcher for a Specific Product"

        fd = pack.__FactoryDispatcher__ = __FactoryDispatcher__

    if not hasattr(pack, '_m'): pack._m=fd.__dict__
    m=pack._m

    if interfaces is _marker:
        if instance_class is None:
            interfaces = ()
        else:
            interfaces = instancesOfObjectImplements(instance_class)

    Products.meta_types=Products.meta_types+(
        { 'name': meta_type or instance_class.meta_type,
          'action': ('manage_addProduct/%s/%s' % (pid, name)),
          'product': pid,
          'permission': permission,
          'visibility': visibility,
          'interfaces': interfaces,
          'instance': instance_class,
          'container_filter': container_filter
          },)

    m[name]=initial
    m[name+'__roles__']=pr

    for method in constructors[1:]:
        if type(method) is tt: name, method = method
        else:
            name=os.path.split(method.__name__)[-1]
        if not productObject.__dict__.has_key(name):
            m[name]=method
            m[name+'__roles__']=pr

    if icon:
        name=os.path.split(icon)[1]
        icon=Globals.ImageFile(icon, self.__pack.__dict__)
        icon.__roles__=None
        if not hasattr(OFS.misc_.misc_, pid):
            setattr(OFS.misc_.misc_, pid, OFS.misc_.Misc_(pid, {}))
        getattr(OFS.misc_.misc_, pid)[name]=icon
</t>
<t tx="ekr.20040104185913.950">def registerZClass(self, Z, meta_type=None):
    #
    #   Convenience method, now deprecated -- clients should
    #   call 'ZClasses.createZClassForBase()' themselves at
    #   module import time, passing 'globals()', so that the
    #   ZClass will be available immediately.
    #
    base_class=Z._zclass_
    if meta_type is None:
        if hasattr(base_class, 'meta_type'): meta_type=base_class.meta_type
        else:                                meta_type=base_class.__name__

    module=base_class.__module__
    name=base_class.__name__

    key="%s/%s" % (module, name)

    if module[:9]=='Products.': module=module.split('.')[1]
    else: module=module.split('.')[0]

    info="%s: %s" % (module, name)

    Products.meta_class_info[key]=info # meta_type
    Products.meta_classes[key]=Z
</t>
<t tx="ekr.20040104185913.951">def registerBaseClass(self, base_class, meta_type=None):
    #
    #   Convenience method, now deprecated -- clients should
    #   call 'ZClasses.createZClassForBase()' themselves at
    #   module import time, passing 'globals()', so that the
    #   ZClass will be available immediately.
    #
    Z = ZClasses.createZClassForBase( base_class, self.__pack )
    return Z
</t>
<t tx="ekr.20040104185913.952">def getProductHelp(self):
    """
    Returns the ProductHelp associated with the current Product.
    """
    return self.__prod.__of__(self.__app.Control_Panel.Products).getProductHelp()
</t>
<t tx="ekr.20040104185913.953">def registerHelpTopic(self, id, topic):
    """
    Register a Help Topic for a product.
    """
    self.getProductHelp()._setObject(id, topic)
</t>
<t tx="ekr.20040104185913.954">def registerHelpTitle(self, title):
    """
    Sets the title of the Product's Product Help
    """
    h = self.getProductHelp()
    if getattr(h, 'title', None) != title:
        h.title = title
</t>
<t tx="ekr.20040104185913.955">def registerHelp(self, directory='help', clear=1,
        title_re=re.compile(r'&lt;title&gt;(.+?)&lt;/title&gt;', re.I)):
    """
    Registers Help Topics for all objects in a directory.

    Nothing will be done if the files in the directory haven't
    changed since the last registerHelp call.

    'clear' indicates whether or not to delete all existing
    Topics from the Product.

    HelpTopics are created for these kind of files

    .dtml            -- DTMLHelpTopic
    .html .htm       -- TextHelpTopic
    .stx .txt        -- STXHelpTopic
    .jpg .png .gif   -- ImageHelpTopic
    .py              -- APIHelpTopic
    """

    if not doInstall():
        return

    help=self.getProductHelp()
    path=os.path.join(Globals.package_home(self.__pack.__dict__),
                      directory)

    # If help directory does not exist, log a warning and return.
    try:
        dir_mod_time=DateTime(os.stat(path)[stat.ST_MTIME])
    except OSError, (errno, text):
        LOG("Zope", WARNING, '%s: %s' % (text, path))
        return

    # test to see if nothing has changed since last registration
    if help.lastRegistered is not None and \
            help.lastRegistered &gt;= dir_mod_time:
        return
    help.lastRegistered=DateTime()

    if clear:
        for id in help.objectIds(['Help Topic','Help Image']):
            help._delObject(id)

    for file in os.listdir(path):
        ext=os.path.splitext(file)[1]
        ext=ext.lower()
        if ext in ('.dtml',):
            contents = open(os.path.join(path,file),'rb').read()
            m = title_re.search(contents)
            if m:
                title = m.group(1)
            else:
                title = ''
            ht=HelpTopic.DTMLTopic(file, '', os.path.join(path,file))
            self.registerHelpTopic(file, ht)
        elif ext in ('.html', '.htm'):
            contents = open(os.path.join(path,file),'rb').read()
            m = title_re.search(contents)
            if m:
                title = m.group(1)
            else:
                title = ''
            ht=HelpTopic.TextTopic(file, title, os.path.join(path,file))
            self.registerHelpTopic(file, ht)
        elif ext in ('.stx', '.txt'):
            title=(open(os.path.join(path,file),'rb').readline()).split(':')[0]
            ht=HelpTopic.STXTopic(file, title, os.path.join(path, file))
            self.registerHelpTopic(file, ht)
        elif ext in ('.jpg', '.gif', '.png'):
            ht=HelpTopic.ImageTopic(file, '', os.path.join(path, file))
            self.registerHelpTopic(file, ht)
        elif ext in ('.py',):
            if file[0] == '_': # ignore __init__.py
                continue
            ht=APIHelpTopic.APIHelpTopic(file, '', os.path.join(path, file))
            self.registerHelpTopic(file, ht)
</t>
<t tx="ekr.20040104185913.956">&lt;&lt; copyright &gt;&gt;

# Product registry and new product factory model.  There will be a new
# mechanism for defining actions for meta types.  If an action is of
# the form:
#
#  manage_addProduct-name-factoryid
#
# Then the machinery that invokes an add-product form
# will return:
# ....what?

from OFS.Folder import Folder

@others
</t>
<t tx="ekr.20040104185913.958">class ProductRegistryMixin:

	# This class implements a protocol for registering products that
    # are defined through the web.
    # This class is a mix-in class for the top-level application object.

	@others
</t>
<t tx="ekr.20040104185913.960">def _manage_remove_product_meta_type(self, product,
                                     id=None, meta_type=None):
    r=[]
    pid=product.id
    for mt in self._getProductRegistryMetaTypes():
        if mt.has_key('product'):
            if mt['product']==pid and (
                meta_type is None or meta_type==mt['name']):
                continue
            elif meta_type==mt['name']: continue
            r.append(mt)

    self._setProductRegistryMetaTypes(tuple(r))
</t>
<t tx="ekr.20040104185913.961">def _constructor_prefix_string(self, pid):
    return 'manage_addProduct/%s/' % pid
</t>
<t tx="ekr.20040104185913.962">def _manage_add_product_meta_type(self, product, id, meta_type,
                                  permission=''):
    pid=product.id

    meta_types=self._getProductRegistryMetaTypes()

    for mt in meta_types:
        if mt['name']==meta_type:
            if not mt.has_key('product'): mt['product']=pid
            if mt['product'] != pid:
                raise 'Type Exists', (
                    'The type &lt;em&gt;%s&lt;/em&gt; is already defined.' % meta_type)
            mt['action']='%s%s' % (
                self._constructor_prefix_string(pid), id)
            if permission: mt['permission']=permission
            return

    mt={
        'name': meta_type,
        'action': ('%s%s' % (
            self._constructor_prefix_string(pid), id)),
        'product': pid
        }
    if permission: mt['permission']=permission

    self._setProductRegistryMetaTypes(meta_types+(mt,))
</t>
<t tx="ekr.20040104185913.963">def _manage_remove_product_permission(self, product, permission=None):
    r=[]
    r2=[]
    pid=product.id
    for d in self._getProductRegistryData('permissions'):
        if d.has_key('product'):
            if d['product']==pid and (
                permission is None or permission==d['name']):
                continue
            elif permission==d['name']: continue
            r.append(d)
            r2.append((d['name'], d['methods'], d['default']))

    self._setProductRegistryData('permissions', tuple(r))
    self._setProductRegistryData('ac_permissions', tuple(r2))
</t>
<t tx="ekr.20040104185913.964">def _manage_add_product_permission(
    self, product, permission, methods=(), default=('Manager',)
    ):

    permissions=self._getProductRegistryData('permissions')

    for d in permissions:
        if d['name']==permission:
            raise 'Type Exists', (
                'The permission &lt;em&gt;%s&lt;/em&gt; is already defined.'
                % permission)

    d={'name': permission, 'methods': methods, 'permission': permission,
            'default': default, 'product': product.id}

    self._setProductRegistryData('permissions', permissions + (d,))
    self._setProductRegistryData(
        'ac_permissions',
        self._getProductRegistryData('ac_permissions')
        +((d['name'], d['methods'], d['default']),)
        )
</t>
<t tx="ekr.20040104185913.965"># HACK - sometimes an unwrapped App object seems to be passed as
# self to these methods, which means that they dont have an aq_aquire
# method. Until Jim has time to look into this, this aq_maybe method
# appears to be an effective work-around...
def aq_maybe(self, name):
    if hasattr(self, name):
        return getattr(self, name)
    return self.aq_acquire(name)
</t>
<t tx="ekr.20040104185913.966">def _manage_add_product_data(self, type, product, id, **data):
    values=filter(
        lambda d, product=product, id=id:
        not (d['product']==product and d['id']==id),
        list(self.aq_maybe('_getProductRegistryData')(type))
        )

    data['product']=product
    data['id']=id
    values.append(data)

    self.aq_maybe('_setProductRegistryData')(type, tuple(values))
</t>
<t tx="ekr.20040104185913.967">def _manage_remove_product_data(self, type, product, id):
    values=filter(
        lambda d, product=product, id=id:
        not (d['product'] in
             (product,
              'methods' # hack to get around inner ZClass reg. bug
              ) and d['id']==id),
        self.aq_maybe('_getProductRegistryData')(type)
        )

    self.aq_maybe('_setProductRegistryData')(type, tuple(values))
</t>
<t tx="ekr.20040104185913.968">class ProductRegistry(ProductRegistryMixin):
	
	# This class implements a protocol for registering products that
    # are defined through the web.  It also provides methods for
    # getting hold of the Product Registry, Control_Panel.Products.

    # This class is a mix-in class for the top-level application object.

	@others</t>
<t tx="ekr.20040104185913.970">def _getProducts(self): return self.Control_Panel.Products
</t>
<t tx="ekr.20040104185913.971">_product_meta_types=()
_product_permissions=()
_product_ac_permissions=()

_product_zclasses=() # product, id, meta_type, class


def _getProductRegistryMetaTypes(self): return self._product_meta_types
</t>
<t tx="ekr.20040104185913.972">def _setProductRegistryMetaTypes(self, v): self._product_meta_types=v
</t>
<t tx="ekr.20040104185913.973">def _getProductRegistryData(self, name):
    return getattr(self, '_product_%s' % name)
</t>
<t tx="ekr.20040104185913.974">def _setProductRegistryData(self, name, v):
    name='_product_%s' % name
    if hasattr(self, name):
        return setattr(self, name, v)
    else:
        raise AttributeError, name
</t>
<t tx="ekr.20040104185913.975">&lt;&lt; copyright &gt;&gt;

'''
Functions for refreshing products.
$Id: RefreshFuncs.py,v 1.6 2002/08/14 21:31:40 mj Exp $
'''

&lt;&lt; RefreshFuncs imports &gt;&gt;

global_classes_timestamp = 0
products_mod_times = {}

_marker = []  # create a new marker object.

refresh_exc_info = {}

@others</t>
<t tx="ekr.20040104185913.976">import os, sys
from time import time
import Products
from ExtensionClass import Base
from Globals import PersistentMapping
from zLOG import format_exception, LOG, ERROR, INFO</t>
<t tx="ekr.20040104185913.977">class dummyClass: pass
</t>
<t tx="ekr.20040104185913.978">class dummyClass2 (Base): pass
</t>
<t tx="ekr.20040104185913.979">def dummyFunc(): pass
</t>
<t tx="ekr.20040104185913.980">ClassTypes = (type(dummyClass), type(dummyClass2))
ModuleType = type(sys)
FuncType = type(dummyFunc)

next_auto_refresh_check = 0
AUTO_REFRESH_INTERVAL = 2  # 2 seconds.

# Functions for storing and retrieving the auto-refresh state for
# each product.

def _getCentralRefreshData(jar, create=0):
    root = jar.root()
    if root.has_key('RefreshData'):
        rd = root['RefreshData']
    else:
        rd = PersistentMapping()
        if create:
            root['RefreshData'] = rd
    return rd
</t>
<t tx="ekr.20040104185913.981">def isAutoRefreshEnabled(jar, productid):
    rd = _getCentralRefreshData(jar)
    ids = rd.get('auto', None)
    if ids:
        return ids.get(productid, 0)
    else:
        return 0
</t>
<t tx="ekr.20040104185913.982">def enableAutoRefresh(jar, productid, enable):
    productid = str(productid)
    rd = _getCentralRefreshData(jar, 1)
    ids = rd.get('auto', None)
    if ids is None:
        if enable:
            rd['auto'] = ids = PersistentMapping()
        else:
            return
    if enable:
        ids[productid] = 1
    else:
        if ids.has_key(productid):
            del ids[productid]
</t>
<t tx="ekr.20040104185913.983">def listAutoRefreshableProducts(jar):
    rd = _getCentralRefreshData(jar)
    auto = rd.get('auto', None)
    if auto:
        ids = []
        for k, v in auto.items():
            if v:
                ids.append(k)
        return ids
    else:
        return ()
</t>
<t tx="ekr.20040104185913.984">def getDependentProducts(jar, productid):
    rd = _getCentralRefreshData(jar)
    products = rd.get('products', None)
    if products is None:
        return ()
    product = products.get(productid, None)
    if product is None:
        return ()
    return product.get('dependent_products', ())
</t>
<t tx="ekr.20040104185913.985">def setDependentProducts(jar, productid, dep_ids):
    productid = str(productid)
    rd = _getCentralRefreshData(jar, 1)
    products = rd.get('products', None)
    if products is None:
        rd['products'] = products = PersistentMapping()
    product = products.get(productid, None)
    if product is None:
        products[productid] = product = PersistentMapping()
    product['dependent_products'] = tuple(map(str, dep_ids))
</t>
<t tx="ekr.20040104185913.986"># Functions for performing refresh.

def getReloadVar(module):
    reload_var = getattr(module, '__refresh_module__', _marker)
    if reload_var is _marker:
        reload_var = getattr(module, '__reload_module__', _marker)
    if reload_var is _marker:
        reload_var = 1
    return reload_var
</t>
<t tx="ekr.20040104185913.987">def listRefreshableModules(productid):
    prefix = "Products.%s" % productid
    prefixdot = prefix + '.'
    lpdot = len(prefixdot)
    rval = []
    for name, module in sys.modules.items():
        if module and (name == prefix or name[:lpdot] == prefixdot):
            reload_var = getReloadVar(module)
            if reload_var:
                rval.append((name, module))
    return rval
</t>
<t tx="ekr.20040104185913.988">def logBadRefresh(productid):
    exc = sys.exc_info()
    try:
        LOG('Refresh', ERROR, 'Exception while refreshing %s'
            % productid, error=exc)
        if hasattr(exc[0], '__name__'):
            error_type = exc[0].__name__
        else:
            error_type = str(exc[0])
        error_value = str(exc[1])
        info = ''.join(format_exception(exc[0], exc[1], exc[2], limit=200))
        refresh_exc_info[productid] = (error_type, error_value, info)
    finally:
        exc = None
</t>
<t tx="ekr.20040104185913.989">def performRefresh(jar, productid):
    '''Attempts to perform a refresh operation.
    '''
    refresh_exc_info[productid] = None
    setupModTimes(productid)  # Refresh again only if changed again.

    modlist = listRefreshableModules(productid)
    former_modules = {}
    try:
        # Remove modules from sys.modules but keep a handle
        # on the old modules in case there's a problem.
        for name, module in modlist:
            m = sys.modules.get(name, None)
            if m is not None:
                former_modules[name] = m
                del sys.modules[name]

        # Reimport and reinstall the product.
        from OFS import Application
        Application.reimport_product(productid)
        app = jar.root()['Application']
        Application.reinstall_product(app, productid)
        return 1
    except:
        # Couldn't refresh.  Reinstate removed modules.
        for name, module in former_modules.items():
            sys.modules[name] = module
        raise
</t>
<t tx="ekr.20040104185913.990">def performSafeRefresh(jar, productid):
    try:
        LOG('Refresh', INFO, 'Refreshing product %s' % productid)
        if not performRefresh(jar, productid):
            return 0
    except:
        logBadRefresh(productid)
        return 0
    else:
        return 1
</t>
<t tx="ekr.20040104185913.991">def performFullRefresh(jar, productid):
    # Refresh dependent products also.
    if performSafeRefresh(jar, productid):
        dep_ids = getDependentProducts(jar, productid)
        for dep_id in dep_ids:
            if isAutoRefreshEnabled(jar, dep_id):
                if not performSafeRefresh(jar, dep_id):
                    return 0
    else:
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.992">def getLastRefreshException(productid):
    return refresh_exc_info.get(productid, None)
</t>
<t tx="ekr.20040104185913.993"># Functions for quickly scanning the dates of product modules.

def tryFindProductDirectory(productid):
    path_join = os.path.join
    isdir = os.path.isdir
    exists = os.path.exists

    for products_dir in Products.__path__:
        product_dir = path_join(products_dir, productid)
        if not isdir(product_dir): continue
        if not exists(path_join(product_dir, '__init__.py')):
            if not exists(path_join(product_dir, '__init__.pyc')):
                continue
        return product_dir
    return None
</t>
<t tx="ekr.20040104185913.994">def tryFindModuleFilename(product_dir, filename):
    # Try different variations of the filename of a module.
    path_join = os.path.join
    isdir = os.path.isdir
    exists = os.path.exists

    found = None
    fn = path_join(product_dir, filename + '.py')
    if exists(fn):
        found = fn
    if not found:
        fn = fn + 'c'
        if exists(fn):
            found = fn
    if not found:
        fn = path_join(product_dir, filename)
        if isdir(fn):
            fn = path_join(fn, '__init__.py')
            if exists(fn):
                found = fn
            else:
                fn = fn + 'c'
                if exists(fn):
                    found = fn
    return found
</t>
<t tx="ekr.20040104185913.995">def setupModTimes(productid):
    mod_times = []
    product_dir = tryFindProductDirectory(productid)
    if product_dir is not None:
        modlist = listRefreshableModules(productid)

        path_join = os.path.join
        exists = os.path.exists

        for name, module in modlist:
            splitname = name.split( '.')[2:]
            if not splitname:
                filename = '__init__'
            else:
                filename = apply(path_join, splitname)
            found = tryFindModuleFilename(product_dir, filename)

            if found:
                try: mtime = os.stat(found)[8]
                except: mtime = 0
                mod_times.append((found, mtime))
    products_mod_times[productid] = mod_times
</t>
<t tx="ekr.20040104185913.996">def checkModTimes(productid):
    # Returns 1 if there were changes.
    mod_times = products_mod_times.get(productid, None)
    if mod_times is None:
        # Initialize the mod times.
        setupModTimes(productid)
        return 0
    for filename, mod_time in mod_times:
        try: mtime = os.stat(filename)[8]
        except: mtime = 0
        if mtime != mod_time:
            # Something changed!
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.997"># Functions for performing auto-refresh.

def checkAutoRefresh(jar):
    '''
    Returns the IDs of products that need to be auto-refreshed.
    '''
    # Note: this function is NOT allowed to change the database!
    global next_auto_refresh_check
    now = time()
    if next_auto_refresh_check and next_auto_refresh_check &gt; now:
        # Not enough time has passed.
        return ()
    next_auto_refresh_check = now + AUTO_REFRESH_INTERVAL

    rd = _getCentralRefreshData(jar)
    ids = rd.get('auto', None)
    if not ids:
        return ()
    auto_refresh_ids = []
    for productid in ids.keys():
        if checkModTimes(productid):
            auto_refresh_ids.append(productid)
    return auto_refresh_ids
</t>
<t tx="ekr.20040104185913.998">def finishAutoRefresh(jar, productids):
    # This function is allowed to change the database.
    for productid in productids:
        performFullRefresh(jar, productid)
</t>
<t tx="ekr.20040104185913.999">def autoRefresh(jar):
    # Must be called before there are any changes made
    # by the connection to the database!
    auto_refresh_ids = checkAutoRefresh(jar)
    if auto_refresh_ids:
        finishAutoRefresh(jar, auto_refresh_ids)
        from ZODB import Connection
        Connection.updateCodeTimestamp()
        get_transaction().commit()
        jar._resetCache()
        get_transaction().begin()
</t>
<t tx="ekr.20040104185913.1000">def setupAutoRefresh(jar):
    # Install hook.
    from ZODB.ZApplication import connection_open_hooks
    connection_open_hooks.append(autoRefresh)
    # Init mod times.
    checkAutoRefresh(jar)
</t>
<t tx="ekr.20040104185913.1001">&lt;&lt; copyright &gt;&gt;

"""
$Id: Undo.py,v 1.31.6.1 2002/11/15 17:47:43 jeremy Exp $"""

__version__='$Revision: 1.31.6.1 $'[11:-2]

&lt;&lt; undo imports &gt;&gt;

@others

del binascii
</t>
<t tx="ekr.20040104185913.1002">import base64

from AccessControl import getSecurityManager
from DateTime import DateTime
import Globals, ExtensionClass
from ZopeUndo.Prefix import Prefix

</t>
<t tx="ekr.20040104185913.1003">class UndoSupport(ExtensionClass.Base):
	&lt;&lt; class UndoSupport declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1004">__ac_permissions__=(
    ('Undo changes', (
        'manage_undo_transactions',
        'undoable_transactions',
        'manage_UndoForm',
        )),
    )

manage_options=(
    {'label':'Undo', 'action':'manage_UndoForm',
     'help':('OFSP','Undo.stx')},
    )

manage_UndoForm=Globals.DTMLFile(
    'dtml/undo',
    globals(),
    PrincipiaUndoBatchSize=20,
    first_transaction=0,
    last_transaction=20
    )

</t>
<t tx="ekr.20040104185913.1005">def get_request_var_or_attr(self, name, default):
    if hasattr(self, 'REQUEST'):
        REQUEST=self.REQUEST
        if REQUEST.has_key(name): return REQUEST[name]
        if hasattr(self, name): v=getattr(self, name)
        else: v=default
        REQUEST[name]=v
        return v
    else:
        if hasattr(self, name): v=getattr(self, name)
        else: v=default
        return v
</t>
<t tx="ekr.20040104185913.1006">def undoable_transactions(self, first_transaction=None,
                          last_transaction=None,
                          PrincipiaUndoBatchSize=None):

    if first_transaction is None:
        first_transaction=self.get_request_var_or_attr(
            'first_transaction', 0)

    if PrincipiaUndoBatchSize is None:
        PrincipiaUndoBatchSize=self.get_request_var_or_attr(
            'PrincipiaUndoBatchSize', 20)

    if last_transaction is None:
        last_transaction=self.get_request_var_or_attr(
            'last_transaction',
            first_transaction+PrincipiaUndoBatchSize)

    spec={}

    # A user is allowed to undo transactions that were initiated
    # by any member of a user folder in the place where the user
    # is defined.
    user = getSecurityManager().getUser()
    if hasattr(user, 'aq_parent'):
        path = '/'.join(user.aq_parent.getPhysicalPath()[1:-1])
    else:
        path=''
    if path: spec['user_name']=Prefix(path)

    # We also only want to undo things done here
    opath='/'.join(self.getPhysicalPath())
    if opath: spec['description']=Prefix(opath)

    r=Globals.UndoManager.undoInfo(
        first_transaction, last_transaction, spec)

    encode = base64.encodestring
    for d in r:
        d['time']=t=DateTime(d['time'])
        desc = d['description']
        tid=d['id']
        if desc:
            desc = desc.split()
            d1=desc[0]
            desc = ''.join(desc[1:])
            if len(desc) &gt; 60: desc = desc[:56]+' ...'
            tid = "%s %s %s %s" % (encode64(tid), t, d1, desc)
        else:
            tid = "%s %s" % (encode64(tid), t)
        d['id']=tid


    return r
</t>
<t tx="ekr.20040104185913.1007">def manage_undo_transactions(self, transaction_info=(), REQUEST=None):
    """
    """
    undo=Globals.UndoManager.undo
    for tid in transaction_info:
        tid=tid.split()
        if tid:
            get_transaction().note("Undo %s" % ''.join(tid[1:]))
            tid=decode64(tid[0])
            undo(tid)

    if REQUEST is None: return
    REQUEST['RESPONSE'].redirect("%s/manage_UndoForm" % REQUEST['URL1'])
    return ''
</t>
<t tx="ekr.20040104185913.1008">Globals.default__class_init__(UndoSupport)

########################################################################
# Blech, need this cause binascii.b2a_base64 is too pickly

import binascii

def encode64(s, b2a=binascii.b2a_base64):
    if len(s) &lt; 58: return b2a(s)
    r=[]; a=r.append
    for i in range(0, len(s), 57):
        a(b2a(s[i:i+57])[:-1])
    return ''.join(r)
</t>
<t tx="ekr.20040104185913.1009">def decode64(s, a2b=binascii.a2b_base64):
    __traceback_info__=len(s), `s`
    return a2b(s+'\n')
</t>
<t tx="ekr.20040104185913.1010">&lt;&lt; copyright &gt;&gt;</t>
<t tx="ekr.20040104185913.1011">&lt;&lt; copyright &gt;&gt;

from AccessControl.PermissionRole import PermissionRole
import AccessControl.Permission

@others
</t>
<t tx="ekr.20040104185913.1013">class ApplicationDefaultPermissions:
	_View_Permission='Manager', 'Anonymous'
	_Access_contents_information_Permission='Manager', 'Anonymous'
</t>
<t tx="ekr.20040104185913.1015">def default__class_init__(self):
    dict=self.__dict__
    have=dict.has_key
    ft=type(default__class_init__)
    dict_items=dict.items()

    for name, v in dict_items:
        if getattr(v, '_need__name__', 0):
            d = v.__dict__
            oldname = d.get('__name__', '')
            if d.get('_implicit__name__', 0):
                # Already supplied a name.
                if name != oldname:
                    # Tried to implicitly assign a different name!
                    try: classname = '%s.%s' % (
                        self.__module__, self.__name__)
                    except AttributeError: classname = `self`
                    from zLOG import LOG, WARNING
                    LOG('Init', WARNING, 'Ambiguous name for method of %s: '
                        '"%s" != "%s"' % (classname, d['__name__'], name))
            else:
                # Supply a name implicitly so that the method can
                # find the security assertions on its container.
                d['_implicit__name__'] = 1
                d['__name__']=name
            if name=='manage' or name[:7]=='manage_':
                name=name+'__roles__'
                if not have(name): dict[name]=('Manager',)
        elif name=='manage' or name[:7]=='manage_' and type(v) is ft:
            name=name+'__roles__'
            if not have(name): dict[name]='Manager',

    # Look for a SecurityInfo object on the class. If found, call its
    # apply() method to generate __ac_permissions__ for the class. We
    # delete the SecurityInfo from the class dict after it has been
    # applied out of paranoia.
    for key, value in dict_items:
        if hasattr(value, '__security_info__'):
            security_info=value
            security_info.apply(self)
            del dict[key]
            break

    if self.__dict__.has_key('__ac_permissions__'):
        AccessControl.Permission.registerPermissions(self.__ac_permissions__)
        for acp in self.__ac_permissions__:
            pname, mnames = acp[:2]
            if len(acp) &gt; 2:
                roles = acp[2]
                pr = PermissionRole(pname, roles)
            else:
                pr=PermissionRole(pname)
            for mname in mnames:
                dict[mname+'__roles__']=pr
</t>
<t tx="ekr.20040104185913.1016">&lt;&lt; copyright &gt;&gt;

import DocumentTemplate, Common, Persistence, MethodObject, Globals, os, sys
from types import InstanceType
from zLOG import LOG,WARNING

@others</t>
<t tx="ekr.20040104185913.1018">class HTML(DocumentTemplate.HTML,Persistence.Persistent,):
	&lt;&lt; class HTML declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1019">"Persistent HTML Document Templates"

</t>
<t tx="ekr.20040104185913.1020">class ClassicHTMLFile(DocumentTemplate.HTMLFile,MethodObject.Method,):
	&lt;&lt; class ClassicHTMLFile declarations &gt;&gt;
	@others

HTMLFile = ClassicHTMLFile</t>
<t tx="ekr.20040104185913.1021">"Persistent HTML Document Templates read from files"

</t>
<t tx="ekr.20040104185913.1022">class func_code: pass
	&lt;&lt; class func_code declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1023">func_code=func_code()
</t>
<t tx="ekr.20040104185913.1024">func_code.co_varnames='trueself', 'self', 'REQUEST'
func_code.co_argcount=3
_need__name__=1
_v_last_read=0

def __init__(self,name,_prefix=None, **kw):
    if _prefix is None: _prefix=SOFTWARE_HOME
    elif type(_prefix) is not type(''):
        _prefix=Common.package_home(_prefix)
    args=(self, os.path.join(_prefix, name + '.dtml'))
    if not kw.has_key('__name__'):
        kw['__name__']=os.path.split(name)[-1]
    apply(ClassicHTMLFile.inheritedAttribute('__init__'),args,kw)
</t>
<t tx="ekr.20040104185913.1025">def _cook_check(self):
    if Globals.DevelopmentMode:
        __traceback_info__=self.raw
        try:    mtime=os.stat(self.raw)[8]
        except: mtime=0
        if mtime != self._v_last_read:
            self.cook()
            self._v_last_read=mtime
    elif not hasattr(self,'_v_cooked'):
        try: changed=self.__changed__()
        except: changed=1
        self.cook()
        if not changed: self.__changed__(0)
</t>
<t tx="ekr.20040104185913.1026">def _setName(self, name):
    self.__name__ = name
    self._need__name__ = 0
</t>
<t tx="ekr.20040104185913.1027">def __call__(self, *args, **kw):
    self._cook_check()
    return apply(HTMLFile.inheritedAttribute('__call__'),
                 (self,)+args[1:],kw)
</t>
<t tx="ekr.20040104185913.1028">defaultBindings = {'name_context': 'context',
                   'name_container': 'container',
                   'name_m_self': 'self',
                   'name_ns': 'caller_namespace',
                   'name_subpath': 'traverse_subpath'}

from Shared.DC.Scripts.Bindings import Bindings
from Acquisition import Explicit, aq_inner, aq_parent
from DocumentTemplate.DT_String import _marker, DTReturn, render_blocks
from DocumentTemplate.DT_Util import TemplateDict, InstanceDict
from AccessControl import getSecurityManager
from ComputedAttribute import ComputedAttribute

class DTMLFile(Bindings, Explicit, ClassicHTMLFile):
	&lt;&lt; class DTMLFile declarations &gt;&gt;
	@others
    from Shared.DC.Scripts.Signature import _setFuncSignature</t>
<t tx="ekr.20040104185913.1029">"HTMLFile with bindings and support for __render_with_namespace__"

func_code = None
func_defaults = None
_need__name__=1

_Bindings_ns_class = TemplateDict
</t>
<t tx="ekr.20040104185913.1030">def _get__roles__(self):
    imp = getattr(aq_parent(aq_inner(self)),
                  '%s__roles__' % self.__name__)
    if hasattr(imp, '__of__'):
        return imp.__of__(self)
    return imp
</t>
<t tx="ekr.20040104185913.1031">__roles__ = ComputedAttribute(_get__roles__, 1)

# By default, we want to look up names in our container.
_Bindings_client = 'container'

def __init__(self, name, _prefix=None, **kw):

    self.ZBindings_edit(defaultBindings)
    self._setFuncSignature()
    apply(DTMLFile.inheritedAttribute('__init__'),
          (self, name, _prefix), kw)
</t>
<t tx="ekr.20040104185913.1032">def getOwner(self, info=0):
    '''
    This method is required of all objects that go into
    the security context stack.
    '''
    return None
</t>
<t tx="ekr.20040104185913.1033">def _exec(self, bound_data, args, kw):
    # Cook if we haven't already
    self._cook_check()

    # Get our caller's namespace, and set up our own.
    cns = bound_data['caller_namespace']
    ns = self._Bindings_ns_class()
    push = ns._push
    ns.guarded_getattr = None
    ns.guarded_getitem = None

    req = None
    kw_bind = kw
    if cns:
        # Someone called us.
        push(cns)
        ns.level = cns.level + 1
        ns.this = getattr(cns, 'this', None)
        # Get their bindings.  Copy the request reference
        # forward, and include older keyword arguments in the
        # current 'keyword_args' binding.
        try:
            last_bound = ns[('current bindings',)]
            last_req = last_bound.get('REQUEST', None)
            if last_req:
                bound_data['REQUEST'] = last_req
            old_kw = last_bound['keyword_args']
            if old_kw:
                kw_bind = old_kw.copy()
                kw_bind.update(kw)
        except: pass
    else:
        # We're first, so get the REQUEST.
        try:
            req = self.aq_acquire('REQUEST')
            if hasattr(req, 'taintWrapper'):
                req = req.taintWrapper()
        except: pass
        bound_data['REQUEST'] = req
        ns.this = bound_data['context']
    # Bind 'keyword_args' to the complete set of keyword arguments.
    bound_data['keyword_args'] = kw_bind

    # Push globals, initialized variables, REQUEST (if any),
    # and keyword arguments onto the namespace stack

    for nsitem in (self.globals, self._vars, req, kw):
        if nsitem:
            push(nsitem)

    # Push the 'container' (default), 'context', or nothing.
    bind_to = self._Bindings_client
    if bind_to in ('container', 'client'):
        push(InstanceDict(bound_data[bind_to], ns))

    # Push the name bindings, and a reference to grab later.
    push(bound_data)
    push({('current bindings',): bound_data})

    security = getSecurityManager()
    security.addContext(self)
    try:
        value = self.ZDocumentTemplate_beforeRender(ns, _marker)
        if value is _marker:
            try: result = render_blocks(self._v_blocks, ns)
            except DTReturn, v: result = v.v
            except AttributeError:
                if type(sys.exc_value)==InstanceType and sys.exc_value.args[0]=="_v_blocks":
                    LOG("ZPublisher",WARNING,"DTML file '%s' could not be read" % self.raw)
                    raise "DTML file error","Check logfile for details"
                else:
                    raise

            self.ZDocumentTemplate_afterRender(ns, result)
            return result
        else:
            return value
    finally:
        security.removeContext(self)
        # Clear the namespace, breaking circular references.
        while len(ns): ns._pop()
</t>
<t tx="ekr.20040104185913.1034">&lt;&lt; copyright &gt;&gt;

__doc__='''Simple module for writing tar files

$Id: tar.py,v 1.6 2002/08/14 21:31:41 mj Exp $'''
__version__='$Revision: 1.6 $'[11:-2]

import sys, time, zlib
try:
    from newstruct import pack
except:
    from struct import pack

@others
</t>
<t tx="ekr.20040104185913.1036">def oct8(i):
    i=oct(i)
    return '0'*(6-len(i))+i+' \0'
</t>
<t tx="ekr.20040104185913.1037">def oct12(i):
    i=oct(i)
    return '0'*(11-len(i))+i+' '
</t>
<t tx="ekr.20040104185913.1038">def pad(s,l):
    ls=len(s)
    if ls &gt;= l: raise ValueError, 'value, %s, too wide for field (%d)' % (s,l)
    return s+'\0'*(l-ls)
</t>
<t tx="ekr.20040104185913.1039">class TarEntry:
	@others
</t>
<t tx="ekr.20040104185913.1040">def __init__(self, path, data,
             mode=0644, uid=0, gid=0, mtime=None, typeflag='0',
             linkname='', uname='jim', gname='system', prefix=''):
    "Initialize a Tar archive entry"
    self.data=data
    if mtime is None: mtime=int(time.time())
    header=''.join([
        pad(path,      100),
        oct8(mode),
        oct8(uid),
        oct8(gid),
        oct12(len(data)),
        oct12(mtime),
        ' ' * 8,
        typeflag,
        pad(linkname,  100),
        'ustar\0',
        '00',
        pad(uname,      32),
        pad(gname,      32),
        '000000 \0',
        '000000 \0',
        pad(prefix,    155),
        '\0'*12,
        ])
    if len(header) != 512: raise 'Bad Header Length', len(header)
    header=(header[:148]+
            oct8(reduce(lambda a,b: a+b, map(ord,header)))+
            header[156:])
    self.header=header
</t>
<t tx="ekr.20040104185913.1041">def __str__(self):
    data=self.data
    l=len(data)
    if l%512: data=data+'\0'*(512-l%512)
    return self.header+data
</t>
<t tx="ekr.20040104185913.1042">def tar(entries):
    r=[]
    ra=r.append
    for name, data in entries:
        ra(str(TarEntry(name,data)))
    ra('\0'*1024)
    return ''.join(r)
</t>
<t tx="ekr.20040104185913.1043">def tgz(entries):
    c=zlib.compressobj()
    compress=c.compress
    r=[]
    ra=r.append
    for name, data in entries:
        ra(compress(str(TarEntry(name,data))))
    ra(compress('\0'*1024))
    ra(c.flush())
    return ''.join(r)
</t>
<t tx="ekr.20040104185913.1044">class tgzarchive:
	@others
</t>
<t tx="ekr.20040104185913.1045">def __init__(self, name, time=None):
    self._f=gzFile('%s.tar' % name, time)
</t>
<t tx="ekr.20040104185913.1046">def add(self, name, data):
    self._f.write(str(TarEntry(name,data)))
</t>
<t tx="ekr.20040104185913.1047">def finish(self):
    self._f.write('\0'*1024)
</t>
<t tx="ekr.20040104185913.1048">def __str__(self):
    return self._f.getdata()
</t>
<t tx="ekr.20040104185913.1049">class gzFile:
	&lt;&lt; class gzFile declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1050">_l=0
_crc=zlib.crc32("")

</t>
<t tx="ekr.20040104185913.1051">def __init__(self, name, t=None):
    self._c=zlib.compressobj(9, zlib.DEFLATED, -zlib.MAX_WBITS,
                             zlib.DEF_MEM_LEVEL, 0)
    if t is None: t=time.time()
    self._r=['\037\213\010\010',
             pack("&lt;i", int(t)),
             '\2\377',
             name,
             '\0'
             ]
</t>
<t tx="ekr.20040104185913.1052">def write(self, s):
    self._crc=zlib.crc32(s, self._crc)
    self._r.append(self._c.compress(s))
    self._l=self._l+len(s)
</t>
<t tx="ekr.20040104185913.1053">def getdata(self):
    r=self._r
    append=r.append
    append(self._c.flush())
    append(pack("&lt;i", self._crc))
    append(pack("&lt;i", self._l))
    return ''.join(r)
</t>
<t tx="ekr.20040104185913.1054">&lt;&lt; copyright &gt;&gt;

import os,sys,re

v=sys.version_info

_version_string = None
_zope_version = None

@others
</t>
<t tx="ekr.20040104185913.1056">def intval(dict, key):
    v = dict.get(key, None)
    if v is None:
        return 0
    else:
        return int(v)
</t>
<t tx="ekr.20040104185913.1057">def strval(dict, key):
    v = dict.get(key, None)
    if v is None:
        return ''
    else:
        return str(v)
</t>
<t tx="ekr.20040104185913.1058">def _prep_version_data():
    global _version_string, _zope_version
    if _version_string is None:
        try:
            s = open(os.path.join(SOFTWARE_HOME,'version.txt')).read()
            ss = re.sub("\(.*?\)\?","",s)
            ss = '%s, python %d.%d.%d, %s' % (ss,v[0],v[1],v[2],sys.platform)
            _version_string = ss

            expr = re.compile(
                r'(?P&lt;product&gt;[A-Za-z0-9]+) +(?P&lt;major&gt;[0-9]+)'
                '\.(?P&lt;minor&gt;[0-9]+)\.(?P&lt;micro&gt;[0-9]+)'
                '(?P&lt;status&gt;[A-Za-z]+)?(?P&lt;release&gt;[0-9]+)?')
            dict = expr.match(s).groupdict()
            _zope_version = (
                intval(dict, 'major'),
                intval(dict, 'minor'),
                intval(dict, 'micro'),
                strval(dict, 'status'),
                intval(dict, 'release'))
        except:
            ss = 'unreleased version, python %d.%d.%d, %s' % (
                v[0],v[1],v[2],sys.platform)
            _version_string = ss
            _zope_version = (-1, -1, -1, '', -1)
</t>
<t tx="ekr.20040104185913.1059">def version_txt():
    _prep_version_data()
    return '(%s)' % _version_string
</t>
<t tx="ekr.20040104185913.1060">def getZopeVersion():
    """
    Format of zope_version tuple:
    (major &lt;int&gt;, minor &lt;int&gt;, micro &lt;int&gt;, status &lt;string&gt;, release &lt;int&gt;)
    If unreleased, integers may be -1.
    """
    _prep_version_data()
    return _zope_version
</t>
<t tx="ekr.20040104185913.1061"></t>
<t tx="ekr.20040104185913.1062">@language c

&lt;&lt; BTreeItemsTemplate declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.1063">&lt;&lt; c copyright &gt;&gt;

#define BTREEITEMSTEMPLATE_C "$Id: BTreeItemsTemplate.c,v 1.17.10.2 2003/06/18 21:19:01 tim_one Exp $\n"

/* A BTreeItems struct is returned from calling .items(), .keys() or
 * .values() on a BTree-based data structure, and is also the result of
 * taking slices of those.  It represents a contiguous slice of a BTree.
 *
 * The start of the slice is in firstbucket, at offset first.  The end of
 * the slice is in lastbucket, at offset last.  Both endpoints are inclusive.
 * It must possible to get from firstbucket to lastbucket via following
 * bucket 'next' pointers zero or more times.  firstbucket, first, lastbucket,
 * and last are readonly after initialization.  An empty slice is represented
 * by  firstbucket == lastbucket == currentbucket == NULL.
 *
 * 'kind' determines whether this slice represents 'k'eys alone, 'v'alues
 * alone, or 'i'items (key+value pairs).  'kind' is also readonly after
 * initialization.
 *
 * The combination of currentbucket, currentoffset and pseudoindex acts as
 * a search finger.  Offset currentoffset in bucket currentbucket is at index
 * pseudoindex, where pseudoindex==0 corresponds to offset first in bucket
 * firstbucket, and pseudoindex==-1 corresponds to offset last in bucket
 * lastbucket.  The function BTreeItems_seek() can be used to set this combo
 * correctly for any in-bounds index, and uses this combo on input to avoid
 * needing to search from the start (or end) on each call.  Calling
 * BTreeItems_seek() with consecutive larger positions is very efficent.
 * Calling it with consecutive smaller positions is more efficient than if
 * a search finger weren't being used at all, but is still quadratic time
 * in the number of buckets in the slice.
 */
typedef struct {
  PyObject_HEAD
  Bucket *firstbucket;		/* First bucket		          */
  Bucket *currentbucket;	/* Current bucket (search finger) */
  Bucket *lastbucket;		/* Last bucket		          */
  int currentoffset;		/* Offset in currentbucket        */
  int pseudoindex;		/* search finger index            */
  int first;                    /* Start offset in firstbucket    */
  int last;                     /* End offset in lastbucket       */
  char kind;                    /* 'k', 'v', 'i'                  */
} BTreeItems;

#define ITEMS(O)((BTreeItems*)(O))

static PyObject *
newBTreeItems(char kind,
              Bucket *lowbucket, int lowoffset,
              Bucket *highbucket, int highoffset);
</t>
<t tx="ekr.20040104185913.1064">static void
BTreeItems_dealloc(BTreeItems *self)
{
  Py_XDECREF(self-&gt;firstbucket);
  Py_XDECREF(self-&gt;lastbucket);
  Py_XDECREF(self-&gt;currentbucket);
  PyObject_DEL(self);
}
</t>
<t tx="ekr.20040104185913.1065">static int
BTreeItems_length_or_nonzero(BTreeItems *self, int nonzero)
{
  int r;
  Bucket *b, *next;

  b=self-&gt;firstbucket;
  UNLESS(b) return 0;

  r=self-&gt;last + 1 - self-&gt;first;

  if (nonzero &amp;&amp; r &gt; 0)
    /* Short-circuit if all we care about is nonempty */
    return 1;

  if (b == self-&gt;lastbucket) return r;

  Py_INCREF(b);
  PER_USE_OR_RETURN(b, -1);
  while ((next=b-&gt;next))
    {
      r += b-&gt;len;
      if (nonzero &amp;&amp; r &gt; 0)
        /* Short-circuit if all we care about is nonempty */
        break;

      if (next == self-&gt;lastbucket)
        break; /* we already counted the last bucket */

      Py_INCREF(next);
      PER_ALLOW_DEACTIVATION(b);
      PER_ACCESSED(b);
      Py_DECREF(b);
      b=next;
      PER_USE_OR_RETURN(b, -1);
    }
  PER_ALLOW_DEACTIVATION(b);
  PER_ACCESSED(b);
  Py_DECREF(b);

  return r &gt;= 0 ? r : 0;
}
</t>
<t tx="ekr.20040104185913.1066">static int
BTreeItems_length( BTreeItems *self)
{
  return BTreeItems_length_or_nonzero(self, 0);
}
</t>
<t tx="ekr.20040104185913.1067">@ ** BTreeItems_seek ** ** Find the ith position in the BTreeItems. ** ** Arguments:  self The BTree ** i the index to seek to, in 0 .. len(self)-1, or in **           -len(self) .. -1, as for indexing a Python sequence. ** ** ** Returns 0 if successful, -1 on failure to seek (like out-of-bounds). ** Upon successful return, index i is at offset self-&gt;currentoffset in bucket ** self-&gt;currentbucket.
@c

static int
BTreeItems_seek(BTreeItems *self, int i)
{
    int delta, pseudoindex, currentoffset;
    Bucket *b, *currentbucket;
    int error;

    pseudoindex = self-&gt;pseudoindex;
    currentoffset = self-&gt;currentoffset;
    currentbucket = self-&gt;currentbucket;
    if (currentbucket == NULL) goto no_match;

    /* Make sure that the index and pseudoindex have the same sign. */
    if (pseudoindex &lt; 0 &amp;&amp; i &gt;= 0) {
        /* Position to the start of the sequence. */
        currentbucket = self-&gt;firstbucket;
        currentoffset = self-&gt;first;
        pseudoindex = 0;
    }
    else if (pseudoindex &gt;= 0 &amp;&amp; i &lt; 0) {
        /* Position to the end of the sequence. */
        currentbucket = self-&gt;lastbucket;
        currentoffset = self-&gt;last;
        pseudoindex = -1;
    }

    delta = i - pseudoindex;
    while (delta &gt; 0) {         /* move right */
        int max;
        /* Want to move right delta positions; the most we can move right in
         * this bucket is currentbucket-&gt;len - currentoffset - 1 positions.
         */
        PER_USE_OR_RETURN(currentbucket, -1);
        max = currentbucket-&gt;len - currentoffset - 1;
        b = currentbucket-&gt;next;
        PER_ALLOW_DEACTIVATION(currentbucket);
        PER_ACCESSED(currentbucket);
        if (delta &lt;= max) {
            currentoffset += delta;
            pseudoindex += delta;
            if (currentbucket == self-&gt;lastbucket
                &amp;&amp; currentoffset &gt; self-&gt;last) goto no_match;
            break;
        }
        /* Move to start of next bucket. */
        if (currentbucket == self-&gt;lastbucket || b == NULL) goto no_match;
        currentbucket = b;
        pseudoindex += max + 1;
        delta -= max + 1;
        currentoffset = 0;
    }
    while (delta &lt; 0) {         /* move left */
        int status;
        /* Want to move left -delta positions; the most we can move left in
         * this bucket is currentoffset positions.
         */
        if ((-delta) &lt;= currentoffset) {
            currentoffset += delta;
            pseudoindex += delta;
            if (currentbucket == self-&gt;firstbucket
                &amp;&amp; currentoffset &lt; self-&gt;first) goto no_match;
            break;
        }
        /* Move to end of previous bucket. */
        if (currentbucket == self-&gt;firstbucket) goto no_match;
        status = PreviousBucket(&amp;currentbucket, self-&gt;firstbucket);
        if (status == 0)
            goto no_match;
        else if (status &lt; 0)
            return -1;
        pseudoindex -= currentoffset + 1;
        delta += currentoffset + 1;
        PER_USE_OR_RETURN(currentbucket, -1);
        currentoffset = currentbucket-&gt;len - 1;
        PER_ALLOW_DEACTIVATION(currentbucket);
        PER_ACCESSED(currentbucket);
    }

    assert(pseudoindex == i);

    /* Alas, the user may have mutated the bucket since the last time we
     * were called, and if they deleted stuff, we may be pointing into
     * trash memory now.
     */
    PER_USE_OR_RETURN(currentbucket, -1);
    error = currentoffset &lt; 0 || currentoffset &gt;= currentbucket-&gt;len;
    PER_ALLOW_DEACTIVATION(currentbucket);
    PER_ACCESSED(currentbucket);
    if (error) {
	PyErr_SetString(PyExc_RuntimeError,
	                "the bucket being iterated changed size");
	return -1;
    }

    Py_INCREF(currentbucket);
    Py_DECREF(self-&gt;currentbucket);
    self-&gt;currentbucket = currentbucket;
    self-&gt;currentoffset = currentoffset;
    self-&gt;pseudoindex = pseudoindex;
    return 0;

no_match:
    IndexError(i);
    return -1;
}
</t>
<t tx="ekr.20040104185913.1068">@ ** BTreeItems_item ** ** Arguments: self a BTreeItems structure ** i Which item to inspect ** ** Returns: the BTreeItems_item_BTree of self-&gt;kind, i ** (ie pulls the ith item out)
@c

static PyObject *
BTreeItems_item(BTreeItems *self, int i)
{
  PyObject *r, *k=0, *v=0;

  if (BTreeItems_seek(self, i) &lt; 0) return NULL;

  PER_USE_OR_RETURN(self-&gt;currentbucket, NULL);

  switch(self-&gt;kind) {

  case 'v':
    COPY_VALUE_TO_OBJECT(r, self-&gt;currentbucket-&gt;values[self-&gt;currentoffset]);
    break;

  case 'i':
    COPY_KEY_TO_OBJECT(k, self-&gt;currentbucket-&gt;keys[self-&gt;currentoffset]);
    UNLESS (k) return NULL;

    COPY_VALUE_TO_OBJECT(v, self-&gt;currentbucket-&gt;values[self-&gt;currentoffset]);
    UNLESS (v) return NULL;

    UNLESS (r=PyTuple_New(2)) goto err;

    PyTuple_SET_ITEM(r, 0, k);
    PyTuple_SET_ITEM(r, 1, v);
    break;

  default:
    COPY_KEY_TO_OBJECT(r, self-&gt;currentbucket-&gt;keys[self-&gt;currentoffset]);
    break;
  }

  PER_UNUSE(self-&gt;currentbucket);
  return r;

 err:
  Py_DECREF(k);
  Py_XDECREF(v);
  PER_UNUSE(self-&gt;currentbucket);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1069">@ ** BTreeItems_slice ** ** Creates a new BTreeItems structure representing the slice ** between the low and high range ** ** Arguments: self The old BTreeItems structure ** ilow The start index ** ihigh The end index ** ** Returns: BTreeItems item
@c

static PyObject *
BTreeItems_slice(BTreeItems *self, int ilow, int ihigh)
{
  Bucket *lowbucket;
  Bucket *highbucket;
  int lowoffset;
  int highoffset;
  int length = -1;  /* len(self), but computed only if needed */

  /* Complications:
   * A Python slice never raises IndexError, but BTreeItems_seek does.
   * Python did only part of index normalization before calling this:
   *     ilow may be &lt; 0 now, and ihigh may be arbitrarily large.  It's
   *     our responsibility to clip them.
   * A Python slice is exclusive of the high index, but a BTreeItems
   *     struct is inclusive on both ends.
   */

  /* First adjust ilow and ihigh to be legit endpoints in the Python
   * sense (ilow inclusive, ihigh exclusive).  This block duplicates the
   * logic from Python's list_slice function (slicing for builtin lists).
   */
  if (ilow &lt; 0)
      ilow = 0;
  else {
      if (length &lt; 0)
          length = BTreeItems_length(self);
      if (ilow &gt; length)
          ilow = length;
  }

  if (ihigh &lt; ilow)
      ihigh = ilow;
  else {
      if (length &lt; 0)
          length = BTreeItems_length(self);
      if (ihigh &gt; length)
          ihigh = length;
  }
  assert(0 &lt;= ilow &amp;&amp; ilow &lt;= ihigh);
  assert(length &lt; 0 || ihigh &lt;= length);

  /* Now adjust for that our struct is inclusive on both ends.  This is
   * easy *except* when the slice is empty:  there's no good way to spell
   * that in an inclusive-on-both-ends scheme.  For example, if the
   * slice is btree.items([:0]), ilow == ihigh == 0 at this point, and if
   * we were to subtract 1 from ihigh that would get interpreted by
   * BTreeItems_seek as meaning the *entire* set of items.  Setting ilow==1
   * and ihigh==0 doesn't work either, as BTreeItems_seek raises IndexError
   * if we attempt to seek to ilow==1 when the underlying sequence is empty.
   * It seems simplest to deal with empty slices as a special case here.
   */
   if (ilow == ihigh) {
       /* empty slice */
       lowbucket = highbucket = NULL;
       lowoffset = 1;
       highoffset = 0;
   }
   else {
       assert(ilow &lt; ihigh);
       --ihigh;  /* exclusive -&gt; inclusive */

       if (BTreeItems_seek(self, ilow) &lt; 0) return NULL;
       lowbucket = self-&gt;currentbucket;
       lowoffset = self-&gt;currentoffset;

       if (BTreeItems_seek(self, ihigh) &lt; 0) return NULL;

       highbucket = self-&gt;currentbucket;
       highoffset = self-&gt;currentoffset;
  }
  return newBTreeItems(self-&gt;kind,
                       lowbucket, lowoffset, highbucket, highoffset);
}
</t>
<t tx="ekr.20040104185913.1070">static PySequenceMethods BTreeItems_as_sequence = {
  (inquiry) BTreeItems_length,
  (binaryfunc)0,
  (intargfunc)0,
  (intargfunc) BTreeItems_item,
  (intintargfunc) BTreeItems_slice,
};

/* Number Method items (just for nb_nonzero!) */

static int
BTreeItems_nonzero(BTreeItems *self)
{
  return BTreeItems_length_or_nonzero(self, 1);
}
</t>
<t tx="ekr.20040104185913.1071">static PyNumberMethods BTreeItems_as_number_for_nonzero = {
  0,0,0,0,0,0,0,0,0,0,
   (inquiry)BTreeItems_nonzero};

static PyTypeObject BTreeItemsType = {
  PyObject_HEAD_INIT(NULL)
  0,					/*ob_size*/
  MOD_NAME_PREFIX "BTreeItems",	        /*tp_name*/
  sizeof(BTreeItems),		        /*tp_basicsize*/
  0,					/*tp_itemsize*/
  /* methods */
  (destructor) BTreeItems_dealloc,	/*tp_dealloc*/
  (printfunc)0,				/*tp_print*/
  (getattrfunc)0,			/*obsolete tp_getattr*/
  (setattrfunc)0,			/*obsolete tp_setattr*/
  (cmpfunc)0,				/*tp_compare*/
  (reprfunc)0,				/*tp_repr*/
  &amp;BTreeItems_as_number_for_nonzero,	/*tp_as_number*/
  &amp;BTreeItems_as_sequence,		/*tp_as_sequence*/
  0,					/*tp_as_mapping*/
  (hashfunc)0,				/*tp_hash*/
  (ternaryfunc)0,			/*tp_call*/
  (reprfunc)0,				/*tp_str*/
  0,					/*tp_getattro*/
  0,					/*tp_setattro*/

  /* Space for future expansion */
  0L,0L,
  "Sequence type used to iterate over BTree items." /* Documentation string */
};

/* Returns a new BTreeItems object representing the contiguous slice from
 * offset lowoffset in bucket lowbucket through offset highoffset in bucket
 * highbucket, inclusive.  Pass lowbucket == NULL for an empty slice.
 * The currentbucket is set to lowbucket, currentoffset ot lowoffset, and
 * pseudoindex to 0.  kind is 'k', 'v' or 'i' (see BTreeItems struct docs).
 */
static PyObject *
newBTreeItems(char kind,
              Bucket *lowbucket, int lowoffset,
              Bucket *highbucket, int highoffset)
{
  BTreeItems *self;

  UNLESS (self = PyObject_NEW(BTreeItems, &amp;BTreeItemsType)) return NULL;
  self-&gt;kind = kind;

  self-&gt;first = lowoffset;
  self-&gt;last = highoffset;

  if (! lowbucket || ! highbucket
      || (lowbucket == highbucket &amp;&amp; lowoffset &gt; highoffset))
    {
      self-&gt;firstbucket   = 0;
      self-&gt;lastbucket    = 0;
      self-&gt;currentbucket = 0;
    }
  else
    {
      Py_INCREF(lowbucket);
      self-&gt;firstbucket = lowbucket;
      Py_XINCREF(highbucket);
      self-&gt;lastbucket = highbucket;
      Py_XINCREF(lowbucket);
      self-&gt;currentbucket = lowbucket;
    }

  self-&gt;currentoffset = lowoffset;
  self-&gt;pseudoindex = 0;

  return OBJECT(self);
}
</t>
<t tx="ekr.20040104185913.1072">static int
nextBTreeItems(SetIteration *i)
{
  if (i-&gt;position &gt;= 0)
    {
      if (i-&gt;position)
        {
          DECREF_KEY(i-&gt;key);
          DECREF_VALUE(i-&gt;value);
        }

      if (BTreeItems_seek(ITEMS(i-&gt;set), i-&gt;position) &gt;= 0)
        {
          Bucket *currentbucket;

          currentbucket = BUCKET(ITEMS(i-&gt;set)-&gt;currentbucket);
          UNLESS(PER_USE(currentbucket))
            {
              /* Mark iteration terminated, so that finiSetIteration doesn't
               * try to redundantly decref the key and value
               */
              i-&gt;position = -1;
              return -1;
            }

          COPY_KEY(i-&gt;key, currentbucket-&gt;keys[ITEMS(i-&gt;set)-&gt;currentoffset]);
          INCREF_KEY(i-&gt;key);

          COPY_VALUE(i-&gt;value,
                     currentbucket-&gt;values[ITEMS(i-&gt;set)-&gt;currentoffset]);
          INCREF_VALUE(i-&gt;value);

          i-&gt;position ++;

          PER_UNUSE(currentbucket);
        }
      else
        {
          i-&gt;position = -1;
          PyErr_Clear();
        }
    }
  return 0;
}
</t>
<t tx="ekr.20040104185913.1073">static int
nextTreeSetItems(SetIteration *i)
{
  if (i-&gt;position &gt;= 0)
    {
      if (i-&gt;position)
        {
          DECREF_KEY(i-&gt;key);
        }

      if (BTreeItems_seek(ITEMS(i-&gt;set), i-&gt;position) &gt;= 0)
        {
          Bucket *currentbucket;

          currentbucket = BUCKET(ITEMS(i-&gt;set)-&gt;currentbucket);
          UNLESS(PER_USE(currentbucket))
            {
              /* Mark iteration terminated, so that finiSetIteration doesn't
               * try to redundantly decref the key and value
               */
              i-&gt;position = -1;
              return -1;
            }

          COPY_KEY(i-&gt;key, currentbucket-&gt;keys[ITEMS(i-&gt;set)-&gt;currentoffset]);
          INCREF_KEY(i-&gt;key);

          i-&gt;position ++;

          PER_UNUSE(currentbucket);
        }
      else
        {
          i-&gt;position = -1;
          PyErr_Clear();
        }
    }
  return 0;
}
</t>
<t tx="ekr.20040104185913.1074">@language c

&lt;&lt; c copyright &gt;&gt;

#ifdef PERSISTENT
&lt;&lt; BTreeModuleTemplate #includes &gt;&gt;
&lt;&lt; BTreeModuleTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1075">#include "cPersistence.h"
</t>
<t tx="ekr.20040104185913.1076">/***************************************************************
   The following are macros that ought to be in cPersistence.h */
#ifndef PER_USE

#define PER_USE(O) \
(((O)-&gt;state != cPersistent_GHOST_STATE \
  || (cPersistenceCAPI-&gt;setstate((PyObject*)(O)) &gt;= 0)) \
 ? (((O)-&gt;state==cPersistent_UPTODATE_STATE) \
    ? ((O)-&gt;state=cPersistent_STICKY_STATE) : 1) : 0)

#define PER_ACCESSED(O) ((O)-&gt;atime=((long)(time(NULL)/3))%65536)


#endif
/***************************************************************/

#else
#include "ExtensionClass.h"
#define PER_USE_OR_RETURN(self, NULL)
#define PER_ALLOW_DEACTIVATION(self)
#define PER_PREVENT_DEACTIVATION(self)
#define PER_DEL(self)
#define PER_USE(O) 1
#define PER_ACCESSED(O) 1
#define PER_CHANGED(O) 0
#endif

/* So sue me.  This pair gets used all over the place, so much so that it
 * interferes with understanding non-persistence parts of algorithms.
 * PER_UNUSE can be used after a successul PER_USE or PER_USE_OR_RETURN.
 * It allows the object to become ghostified, and tells the persistence
 * machinery that the object's fields were used recently.
 */
#define PER_UNUSE(OBJ) do {             \
    PER_ALLOW_DEACTIVATION(OBJ);        \
    PER_ACCESSED(OBJ);                  \
} while (0)

static PyObject *sort_str, *reverse_str, *items_str, *__setstate___str;
static PyObject *ConflictError = NULL;
</t>
<t tx="ekr.20040104185913.1077">static void PyVar_Assign(PyObject **v, PyObject *e) { Py_XDECREF(*v); *v=e;}
</t>
<t tx="ekr.20040104185913.1078">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define ASSIGNC(V,E) (Py_INCREF((E)), PyVar_Assign(&amp;(V),(E)))
#define UNLESS(E) if (!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define LIST(O) ((PyListObject*)(O))
#define OBJECT(O) ((PyObject*)(O))

#define MIN_BUCKET_ALLOC 16
#define MAX_BTREE_SIZE(B) DEFAULT_MAX_BTREE_SIZE
#define MAX_BUCKET_SIZE(B) DEFAULT_MAX_BUCKET_SIZE

#define SameType_Check(O1, O2) ((O1)-&gt;ob_type==(O2)-&gt;ob_type)

#define ASSERT(C, S, R) if (! (C)) { \
PyErr_SetString(PyExc_AssertionError, (S)); return (R); }

/* Various kinds of BTree and Bucket structs are instances of
* "sized containers", and have a common initial layout:
*     The stuff needed for all Python objects, or all Persistent objects.
*     int size:  The maximum number of things that could be contained
*                without growing the container.
*     int len:   The number of things currently contained.
*
* Invariant:  0 &lt;= len &lt;= size.
*
* A sized container typically goes on to declare one or more pointers
* to contiguous arrays with 'size' elements each, the initial 'len' of
* which are currently in use.
*/
#ifdef PERSISTENT
#define sizedcontainer_HEAD         \
  cPersistent_HEAD                \
  int size;                       \
  int len;
#else
#define sizedcontainer_HEAD         \
  PyObject_HEAD                   \
  int size;                       \
  int len;
#endif

/* Nothing is actually of type Sized, but (pointers to) BTree nodes and
* Buckets can be cast to Sized* in contexts that only need to examine
* the members common to all sized containers.
*/
typedef struct Sized_s {
  sizedcontainer_HEAD
} Sized;

#define SIZED(O) ((Sized*)(O))

/* A Bucket wraps contiguous vectors of keys and values.  Keys are unique,
* and stored in sorted order.  The 'values' pointer may be NULL if the
* Bucket is used to implement a set.  Buckets serving as leafs of BTrees
* are chained together via 'next', so that the entire BTree contents
* can be traversed in sorted order quickly and easily.
*/
typedef struct Bucket_s {
sizedcontainer_HEAD
struct Bucket_s *next;    /* the bucket with the next-larger keys */
KEY_TYPE *keys;           /* 'len' keys, in increasing order */
VALUE_TYPE *values;       /* 'len' corresponding values; NULL if a set */
} Bucket;

#define BUCKET(O) ((Bucket*)(O))

/* A BTree is complicated.  See Maintainer.txt.
*/

typedef struct BTreeItem_s {
KEY_TYPE key;
Sized *child; /* points to another BTree, or to a Bucket of some sort */
} BTreeItem;

typedef struct BTree_s {
sizedcontainer_HEAD

/* firstbucket points to the bucket containing the smallest key in
 * the BTree.  This is found by traversing leftmost child pointers
 * (data[0].child) until reaching a Bucket.
 */
Bucket *firstbucket;

/* The BTree points to 'len' children, via the "child" fields of the data
 * array.  There are len-1 keys in the 'key' fields, stored in increasing
 * order.  data[0].key is unused.  For i in 0 .. len-1, all keys reachable
 * from data[i].child are &gt;= data[i].key and &lt; data[i+1].key, at the
 * endpoints pretending that data[0].key is minus infinity and
 * data[len].key is positive infinity.
 */
BTreeItem *data;
} BTree;

staticforward PyExtensionClass BTreeType;

#define BTREE(O) ((BTree*)(O))

/* Use BTREE_SEARCH to find which child pointer to follow.
* RESULT   An int lvalue to hold the index i such that SELF-&gt;data[i].child
*          is the correct node to search next.
* SELF     A pointer to a BTree node.
* KEY      The key you're looking for, of type KEY_TYPE.
* ONERROR  What to do if key comparison raises an exception; for example,
*          perhaps 'return NULL'.
*
* See Maintainer.txt for discussion:  this is optimized in subtle ways.
* It's recommended that you call this at the start of a routine, waiting
* to check for self-&gt;len == 0 after.
*/
#define BTREE_SEARCH(RESULT, SELF, KEY, ONERROR) {          \
  int _lo = 0;                                            \
  int _hi = (SELF)-&gt;len;                                  \
  int _i, _cmp;                                           \
  for (_i = _hi &gt;&gt; 1; _i &gt; _lo; _i = (_lo + _hi) &gt;&gt; 1) {  \
      TEST_KEY_SET_OR(_cmp, (SELF)-&gt;data[_i].key, (KEY))  \
          ONERROR;                                        \
      if      (_cmp &lt; 0) _lo = _i;                        \
      else if (_cmp &gt; 0) _hi = _i;                        \
      else   /* equal */ break;                           \
  }                                                       \
  (RESULT) = _i;                                          \
}

/* SetIteration structs are used in the internal set iteration protocol.
* When you want to iterate over a set or bucket or BTree (even an
* individual key!),
* 1. Declare a new iterator:
*        SetIteration si = {0,0,0};
*    Using "{0,0,0}" or "{0,0}" appear most common.  Only one {0} is
*    necssary.  At least one must be given so that finiSetIteration() works
*    correctly even if you don't get around to calling initSetIteration().
* 2. Initialize it via
*        initSetIteration(&amp;si, PyObject *s, useValues)
*    It's an error if that returns an int &lt; 0.  In case of error on the
*    init call, calling finiSetIteration(&amp;si) is optional.  But if the
*    init call succeeds, you must eventually call finiSetIteration(),
*    and whether or not subsequent calls to si.next() fail.
* 3. Get the first element:
*        if (si.next(&amp;si) &lt; 0) { there was an error }
*    If the set isn't empty, this sets si.position to an int &gt;= 0,
*    si.key to the element's key (of type KEY_TYPE), and maybe si.value to
*    the element's value (of type VALUE_TYPE).  si.value is defined
*    iff si.usesValue is true.
* 4. Process all the elements:
*        while (si.position &gt;= 0) {
*            do something with si.key and/or si.value;
*            if (si.next(&amp;si) &lt; 0) { there was an error; }
*        }
* 5. Finalize the SetIterator:
*        finiSetIteration(&amp;si);
*    This is mandatory!  si may contain references to iterator objects,
*    keys and values, and they must be cleaned up else they'll leak.  If
*    this were C++ we'd hide that in the destructor, but in C you have to
*    do it by hand.
*/
typedef struct SetIteration_s
{
PyObject *set;    /* the set, bucket, BTree, ..., being iterated */
int position;     /* initialized to 0; set to -1 by next() when done */
int usesValue;    /* true iff 'set' has values &amp; we iterate them */
KEY_TYPE key;     /* next() sets to next key */
VALUE_TYPE value; /* next() may set to next value */
int (*next)(struct SetIteration_s*);  /* function to get next key+value */
} SetIteration;

/* Finish the set iteration protocol.  This MUST be called by everyone
* who starts a set iteration, unless the initial call to initSetIteration
* failed; in that case, and only that case, calling finiSetIteration is
* optional.
*/
static void
finiSetIteration(SetIteration *i)
{
  assert(i != NULL);
  if (i-&gt;set == NULL)
      return;
  Py_DECREF(i-&gt;set);
  i-&gt;set = NULL;      /* so it doesn't hurt to call this again */

  if (i-&gt;position &gt; 0) {
      /* next() was called at least once, but didn't finish iterating
       * (else position would be negative).  So the cached key and
       * value need to be cleaned up.
       */
      DECREF_KEY(i-&gt;key);
      if (i-&gt;usesValue) {
          DECREF_VALUE(i-&gt;value);
      }
  }
  i-&gt;position = -1;   /* stop any stray next calls from doing harm */
}
</t>
<t tx="ekr.20040104185913.1079">static PyObject *
IndexError(int i)
{
  PyObject *v;

  v=PyInt_FromLong(i);
  UNLESS (v) {
    v=Py_None;
    Py_INCREF(v);
  }
  PyErr_SetObject(PyExc_IndexError, v);
  Py_DECREF(v);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1080">@ Search for the bucket immediately preceding *current, in the bucket chain * starting at first. current, *current and first must not be NULL. * * Return: *   1  *current holds the correct bucket; this is a borrowed reference *   0  no such bucket exists; *current unaltered *  -1  error; *current unaltered
@c

static int
PreviousBucket(Bucket **current, Bucket *first)
{
    Bucket *trailing = NULL;    /* first travels; trailing follows it */
    int result = 0;

    assert(current &amp;&amp; *current &amp;&amp; first);
    if (first == *current)
        return 0;

    do {
        trailing = first;
	PER_USE_OR_RETURN(first, -1);
        first = first-&gt;next;
        PER_ALLOW_DEACTIVATION(trailing);
	PER_ACCESSED(trailing);

	if (first == *current) {
	    *current = trailing;
	    result = 1;
	    break;
	}
    } while (first);

    return result;
}
</t>
<t tx="ekr.20040104185913.1081">static void *
PyMalloc(size_t sz)
{
  void *r;

  ASSERT(sz &gt; 0, "non-positive size malloc", NULL);

  if ((r = malloc(sz))) return r;

  PyErr_NoMemory();
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1082">static void *
PyRealloc(void *p, size_t sz)
{
  void *r;

  ASSERT(sz &gt; 0, "non-positive size realloc", NULL);

  if (p) r = realloc(p,sz);
  else r = malloc(sz);

  UNLESS (r) PyErr_NoMemory();

  return r;
}
</t>
<t tx="ekr.20040104185913.1083">#include "BTreeItemsTemplate.c"
#include "BucketTemplate.c"
#include "SetTemplate.c"
#include "BTreeTemplate.c"
#include "TreeSetTemplate.c"
#include "SetOpTemplate.c"
#include "MergeTemplate.c"

static struct PyMethodDef module_methods[] = {
  {"difference", (PyCFunction) difference_m,	METH_VARARGS,
   "difference(o1, o2) -- "
   "compute the difference between o1 and o2"
  },
  {"union", (PyCFunction) union_m,	METH_VARARGS,
   "union(o1, o2) -- compute the union of o1 and o2\n"
  },
  {"intersection", (PyCFunction) intersection_m,	METH_VARARGS,
   "intersection(o1, o2) -- "
   "compute the intersection of o1 and o2"
  },
#ifdef MERGE
  {"weightedUnion", (PyCFunction) wunion_m,	METH_VARARGS,
   "weightedUnion(o1, o2 [, w1, w2]) -- compute the union of o1 and o2\n"
   "\nw1 and w2 are weights."
  },
  {"weightedIntersection", (PyCFunction) wintersection_m,	METH_VARARGS,
   "weightedIntersection(o1, o2 [, w1, w2]) -- "
   "compute the intersection of o1 and o2\n"
   "\nw1 and w2 are weights."
  },
#endif
#ifdef MULTI_INT_UNION
  {"multiunion", (PyCFunction) multiunion_m, METH_VARARGS,
   "multiunion(seq) -- compute union of a sequence of integer sets.\n"
   "\n"
   "Each element of seq must be an integer set, or convertible to one\n"
   "via the set iteration protocol.  The union returned is an IISet."
  },
#endif
  {NULL,		NULL}		/* sentinel */
};

static char BTree_module_documentation[] =
"\n"
MASTER_ID
BTREEITEMSTEMPLATE_C
"$Id: BTreeModuleTemplate.c,v 1.37 2002/06/25 22:02:27 tim_one Exp $\n"
BTREETEMPLATE_C
BUCKETTEMPLATE_C
KEYMACROS_H
MERGETEMPLATE_C
SETOPTEMPLATE_C
SETTEMPLATE_C
TREESETTEMPLATE_C
VALUEMACROS_H
BTREEITEMSTEMPLATE_C
;

void
INITMODULE (void)
{
  PyObject *m, *d, *c;

  UNLESS (sort_str=PyString_FromString("sort")) return;
  UNLESS (reverse_str=PyString_FromString("reverse")) return;
  UNLESS (items_str=PyString_FromString("items")) return;
  UNLESS (__setstate___str=PyString_FromString("__setstate__")) return;

  UNLESS (PyExtensionClassCAPI=PyCObject_Import("ExtensionClass","CAPI"))
      return;

#ifdef PERSISTENT
  if ((cPersistenceCAPI=PyCObject_Import("cPersistence","CAPI")))
    {
	BucketType.methods.link=cPersistenceCAPI-&gt;methods;
	BucketType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	BucketType.tp_setattro=cPersistenceCAPI-&gt;setattro;

	SetType.methods.link=cPersistenceCAPI-&gt;methods;
	SetType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	SetType.tp_setattro=cPersistenceCAPI-&gt;setattro;

	BTreeType.methods.link=cPersistenceCAPI-&gt;methods;
	BTreeType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	BTreeType.tp_setattro=cPersistenceCAPI-&gt;setattro;

	TreeSetType.methods.link=cPersistenceCAPI-&gt;methods;
	TreeSetType.tp_getattro=cPersistenceCAPI-&gt;getattro;
	TreeSetType.tp_setattro=cPersistenceCAPI-&gt;setattro;
    }
  else return;

  /* Grab the ConflictError class */

  m = PyImport_ImportModule("ZODB.POSException");

  if (m != NULL) {
  	c = PyObject_GetAttrString(m, "BTreesConflictError");
  	if (c != NULL)
  		ConflictError = c;
	Py_DECREF(m);
  }

  if (ConflictError == NULL) {
  	Py_INCREF(PyExc_ValueError);
	ConflictError=PyExc_ValueError;
  }

#else
  BTreeType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
  BucketType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
  SetType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
  TreeSetType.tp_getattro=PyExtensionClassCAPI-&gt;getattro;
#endif

  BTreeItemsType.ob_type=&amp;PyType_Type;

#ifdef INTSET_H
  UNLESS(d = PyImport_ImportModule("intSet")) return;
  UNLESS(intSetType = PyObject_GetAttrString (d, "intSet")) return;
  Py_DECREF (d);
#endif

  /* Create the module and add the functions */
  m = Py_InitModule4("_" MOD_NAME_PREFIX "BTree", module_methods,
		     BTree_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  /* Add some symbolic constants to the module */
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,MOD_NAME_PREFIX "Bucket", BucketType);
  PyExtensionClass_Export(d,MOD_NAME_PREFIX "BTree", BTreeType);
  PyExtensionClass_Export(d,MOD_NAME_PREFIX "Set", SetType);
  PyExtensionClass_Export(d,MOD_NAME_PREFIX "TreeSet", TreeSetType);
}
</t>
<t tx="ekr.20040104185913.1084">&lt;&lt; BTreeTemplate declarations &gt;&gt;
@others

static PyNumberMethods BTree_as_number_for_nonzero = {
  0,0,0,0,0,0,0,0,0,0,
  (inquiry)BTree_nonzero};

static PyExtensionClass BTreeType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  MOD_NAME_PREFIX "BTree",			/*tp_name*/
  sizeof(BTree),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /************* methods ********************/
  (destructor) BTree_dealloc,/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)0,			/*tp_repr*/
  &amp;BTree_as_number_for_nonzero,	/*tp_as_number*/
  0,				/*tp_as_sequence*/
  &amp;BTree_as_mapping,	/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,
  0,				/*tp_setattro*/

  /* Space for future expansion */
  0L,0L,
  "Mapping type implemented as sorted list of items",
  METHOD_CHAIN(BTree_methods),
  EXTENSIONCLASS_BASICNEW_FLAG
#ifdef PERSISTENT
  | PERSISTENT_TYPE_FLAG
#endif
  | EXTENSIONCLASS_NOINSTDICT_FLAG,
};
</t>
<t tx="ekr.20040104185913.1085">&lt;&lt; c copyright &gt;&gt;

#define BTREETEMPLATE_C "$Id: BTreeTemplate.c,v 1.71.10.3 2003/04/18 18:03:18 tim_one Exp $\n"

/* Sanity-check a BTree.  This is a private helper for BTree_check.  Return:
 *      -1         Error.  If it's an internal inconsistency in the BTree,
 *                 AssertionError is set.
 *       0         No problem found.
 *
 * nextbucket is the bucket "one beyond the end" of the BTree; the last bucket
 * directly reachable from following right child pointers *should* be linked
 * to nextbucket (and this is checked).
 */
static int
BTree_check_inner(BTree *self, Bucket *nextbucket)
{
    int i;
    Bucket *bucketafter;
    Sized *child;
    char *errormsg = "internal error";  /* someone should have overriden */
    Sized *activated_child = NULL;
    int result = -1;    /* until proved innocent */

#define CHECK(CONDITION, ERRORMSG)          \
    if (!(CONDITION)) {                     \
        errormsg = (ERRORMSG);              \
        goto Error;                         \
    }

    PER_USE_OR_RETURN(self, -1);
    CHECK(self-&gt;len &gt;= 0, "BTree len &lt; 0");
    CHECK(self-&gt;len &lt;= self-&gt;size, "BTree len &gt; size");
    if (self-&gt;len == 0) {
        /* Empty BTree. */
        CHECK(self-&gt;firstbucket == NULL,
              "Empty BTree has non-NULL firstbucket");
        result = 0;
        goto Done;
    }
    /* Non-empty BTree. */
    CHECK(self-&gt;firstbucket != NULL, "Non-empty BTree has NULL firstbucket");

    /* Obscure:  The first bucket is pointed to at least by self-&gt;firstbucket
     * and data[0].child of whichever BTree node it's a child of.  However,
     * if persistence is enabled then the latter BTree node may be a ghost
     * at this point, and so its pointers "don't count":  we can only rely
     * on self's pointers being intact.
     */
#ifdef PERSISTENT
    CHECK(self-&gt;firstbucket-&gt;ob_refcnt &gt;= 1,
          "Non-empty BTree firstbucket has refcount &lt; 1");
#else
    CHECK(self-&gt;firstbucket-&gt;ob_refcnt &gt;= 2,
          "Non-empty BTree firstbucket has refcount &lt; 2");
#endif

    for (i = 0; i &lt; self-&gt;len; ++i) {
        CHECK(self-&gt;data[i].child != NULL, "BTree has NULL child");
    }

    if (SameType_Check(self, self-&gt;data[0].child)) {
        /* Our children are also BTrees. */
        child = self-&gt;data[0].child;
        UNLESS (PER_USE(child)) goto Done;
        activated_child = child;
        CHECK(self-&gt;firstbucket == BTREE(child)-&gt;firstbucket,
               "BTree has firstbucket different than "
               "its first child's firstbucket");
        PER_ALLOW_DEACTIVATION(child);
        activated_child = NULL;
        for (i = 0; i &lt; self-&gt;len; ++i) {
            child = self-&gt;data[i].child;
            CHECK(SameType_Check(self, child),
                  "BTree children have different types");
            if (i == self-&gt;len - 1)
                bucketafter = nextbucket;
            else {
                BTree *child2 = BTREE(self-&gt;data[i+1].child);
                UNLESS (PER_USE(child2)) goto Done;
                bucketafter = child2-&gt;firstbucket;
                PER_ALLOW_DEACTIVATION(child2);
            }
            if (BTree_check_inner(BTREE(child), bucketafter) &lt; 0) goto Done;
        }
    }
    else {
        /* Our children are buckets. */
        CHECK(self-&gt;firstbucket == BUCKET(self-&gt;data[0].child),
              "Bottom-level BTree node has inconsistent firstbucket belief");
        for (i = 0; i &lt; self-&gt;len; ++i) {
            child = self-&gt;data[i].child;
            UNLESS (PER_USE(child)) goto Done;
            activated_child = child;
            CHECK(!SameType_Check(self, child),
                  "BTree children have different types");
            CHECK(child-&gt;len &gt;= 1, "Bucket length &lt; 1"); /* no empty buckets! */
            CHECK(child-&gt;len &lt;= child-&gt;size, "Bucket len &gt; size");
#ifdef PERSISTENT
            CHECK(child-&gt;ob_refcnt &gt;= 1, "Bucket has refcount &lt; 1");
#else
            CHECK(child-&gt;ob_refcnt &gt;= 2, "Bucket has refcount &lt; 2");
#endif
            if (i == self-&gt;len - 1)
                bucketafter = nextbucket;
            else
                bucketafter = BUCKET(self-&gt;data[i+1].child);
            CHECK(BUCKET(child)-&gt;next == bucketafter,
                  "Bucket next pointer is damaged");
            PER_ALLOW_DEACTIVATION(child);
            activated_child = NULL;
        }
    }
    result = 0;
    goto Done;

Error:
    PyErr_SetString(PyExc_AssertionError, errormsg);
    result = -1;
Done:
    /* No point updating access time -- this isn't a "real" use. */
    PER_ALLOW_DEACTIVATION(self);
    if (activated_child) {
        PER_ALLOW_DEACTIVATION(activated_child);
    }
    return result;

#undef CHECK
}

/* Sanity-check a BTree.  This is the ._check() method.  Return:
 *      NULL       Error.  If it's an internal inconsistency in the BTree,
 *                 AssertionError is set.
 *      Py_None    No problem found.
 */
static PyObject*
BTree_check(BTree *self, PyObject *args)
{
    PyObject *result = NULL;
    int i = BTree_check_inner(self, NULL);

    if (i &gt;= 0) {
        result = Py_None;
        Py_INCREF(result);
    }
    return result;
}

/*
** _BTree_get
**
** Search a BTree.
**
** Arguments
**      self        a pointer to a BTree
**      keyarg      the key to search for, as a Python object
**      has_key     true/false; when false, try to return the associated
**                  value; when true, return a boolean
** Return
**      When has_key false:
**          If key exists, its associated value.
**          If key doesn't exist, NULL and KeyError is set.
**      When has_key true:
**          A Python int is returned in any case.
**          If key exists, the depth of the bucket in which it was found.
**          If key doesn't exist, 0.
*/
static PyObject *
_BTree_get(BTree *self, PyObject *keyarg, int has_key)
{
    KEY_TYPE key;
    PyObject *result = NULL;    /* guilty until proved innocent */
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS (copied) return NULL;

    PER_USE_OR_RETURN(self, NULL);
    if (self-&gt;len == 0) {
        /* empty BTree */
        if (has_key)
            result = PyInt_FromLong(0);
        else
            PyErr_SetObject(PyExc_KeyError, keyarg);
    }
    else {
        for (;;) {
            int i;
            Sized *child;

            BTREE_SEARCH(i, self, key, goto Done);
            child = self-&gt;data[i].child;
            has_key += has_key != 0;    /* bump depth counter, maybe */
            if (SameType_Check(self, child)) {
                PER_UNUSE(self);
                self = BTREE(child);
                PER_USE_OR_RETURN(self, NULL);
            }
            else {
                result = _bucket_get(BUCKET(child), keyarg, has_key);
                break;
            }
        }
    }

Done:
    PER_UNUSE(self);
    return result;
}

static PyObject *
BTree_get(BTree *self, PyObject *key)
{
  return _BTree_get(self, key, 0);
}

/*
 * Move data from the current BTree, from index onward, to the newly created
 * BTree 'next'.  self and next must both be activated.  If index is OOB (&lt; 0
 * or &gt;= self-&gt;len), use self-&gt;len / 2 as the index (i.e., split at the
 * midpoint).  self must have at least 2 children on entry, and index must
 * be such that self and next each have at least one child at exit.  self's
 * accessed time is updated.
 *
 * Return:
 *    -1    error
 *     0    OK
 */
static int
BTree_split(BTree *self, int index, BTree *next)
{
    int next_size;
    Sized *child;

    if (index &lt; 0 || index &gt;= self-&gt;len)
	index = self-&gt;len / 2;

    next_size = self-&gt;len - index;
    ASSERT(index &gt; 0, "split creates empty tree", -1);
    ASSERT(next_size &gt; 0, "split creates empty tree", -1);

    next-&gt;data = PyMalloc(sizeof(BTreeItem) * next_size);
    if (!next-&gt;data)
	return -1;
    memcpy(next-&gt;data, self-&gt;data + index, sizeof(BTreeItem) * next_size);
    next-&gt;size = next_size;  /* but don't set len until we succeed */

    /* Set next's firstbucket.  self-&gt;firstbucket is still correct. */
    child = next-&gt;data[0].child;
    if (SameType_Check(self, child)) {
        PER_USE_OR_RETURN(child, -1);
	next-&gt;firstbucket = BTREE(child)-&gt;firstbucket;
	PER_UNUSE(child);
    }
    else
	next-&gt;firstbucket = BUCKET(child);
    Py_INCREF(next-&gt;firstbucket);

    next-&gt;len = next_size;
    self-&gt;len = index;
    return PER_CHANGED(self) &lt; 0 ? -1 : 0;
}


/* Fwd decl -- BTree_grow and BTree_split_root reference each other. */
static int BTree_grow(BTree *self, int index, int noval);
</t>
<t tx="ekr.20040104185913.1086">@ Split the root. This is a little special because the root isn't a child * of anything else, and the root needs to retain its object identity. So * this routine moves the root's data into a new child, and splits the * latter. This leaves the root with two children. * * Return: *   0  OK *   -1  error * * CAUTION: The caller must call PER_CHANGED on self.
@c

static int
BTree_split_root(BTree *self, int noval)
{
    BTree *child;
    BTreeItem *d;

    /* Create a child BTree, and a new data vector for self. */
    child = BTREE(PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL));
    if (!child) return -1;

    d = PyMalloc(sizeof(BTreeItem) * 2);
    if (!d) {
        Py_DECREF(child);
        return -1;
    }

    /* Move our data to new BTree. */
    child-&gt;size = self-&gt;size;
    child-&gt;len = self-&gt;len;
    child-&gt;data = self-&gt;data;
    child-&gt;firstbucket = self-&gt;firstbucket;
    Py_INCREF(child-&gt;firstbucket);

    /* Point self to child and split the child. */
    self-&gt;data = d;
    self-&gt;len = 1;
    self-&gt;size = 2;
    self-&gt;data[0].child = SIZED(child); /* transfers reference ownership */
    return BTree_grow(self, 0, noval);
}
</t>
<t tx="ekr.20040104185913.1087">@ ** BTree_grow ** ** Grow a BTree ** ** Arguments: self The BTree ** index self-&gt;data[index].child needs to be split. index **           must be 0 if self is empty (len == 0), and a new **           empty bucket is created then. **       noval  Boolean; is this a set (true) or mapping (false)? ** ** Returns: 0 on success ** -1 on failure ** ** CAUTION: If self is empty on entry, this routine adds an empty bucket. ** That isn't a legitimate BTree; if the caller doesn't put something in ** in the bucket (say, because of a later error), the BTree must be cleared ** to get rid of the empty bucket.
@c

static int
BTree_grow(BTree *self, int index, int noval)
{
  int i;
  Sized *v, *e = 0;
  BTreeItem *d;

  if (self-&gt;len == self-&gt;size)
    {
      if (self-&gt;size)
        {
          d = PyRealloc(self-&gt;data, sizeof(BTreeItem) * self-&gt;size * 2);
          if (d == NULL)
            return -1;
          self-&gt;data = d;
          self-&gt;size *= 2;
        }
      else
        {
          d = PyMalloc(sizeof(BTreeItem) * 2);
          if (d == NULL)
            return -1;
          self-&gt;data = d;
          self-&gt;size = 2;
        }
    }

  if (self-&gt;len)
    {
      d = self-&gt;data + index;
      v = d-&gt;child;
      /* Create a new object of the same type as the target value */
      e = SIZED(PyObject_CallObject(OBJECT(v-&gt;ob_type), NULL));
      UNLESS (e) return -1;

      UNLESS(PER_USE(v))
        {
          Py_DECREF(e);
          return -1;
        }

      /* Now split between the original (v) and the new (e) at the midpoint*/
      if (SameType_Check(self, v))
        {
          i = BTree_split(BTREE(v), -1,   BTREE(e));
        }
      else
        {
          i = bucket_split(BUCKET(v), -1, BUCKET(e));
        }
      PER_ALLOW_DEACTIVATION(v);

      if (i &lt; 0)
        {
          Py_DECREF(e);
          return -1;
        }

      index++;
      d++;
      if (self-&gt;len &gt; index)	/* Shift up the old values one array slot */
        memmove(d+1, d, sizeof(BTreeItem)*(self-&gt;len-index));

      if (SameType_Check(self, v))
        {
          COPY_KEY(d-&gt;key, BTREE(e)-&gt;data-&gt;key);

          /* We take the unused reference from e, so there's no
             reason to INCREF!
          */
          /* INCREF_KEY(self-&gt;data[1].key); */
        }
      else
        {
          COPY_KEY(d-&gt;key, BUCKET(e)-&gt;keys[0]);
          INCREF_KEY(d-&gt;key);
        }
      d-&gt;child = e;

      self-&gt;len++;

      if (self-&gt;len &gt;= MAX_BTREE_SIZE(self) * 2)    /* the root is huge */
        return BTree_split_root(self, noval);
    }
  else
    {
      /* The BTree is empty.  Create an empty bucket.  See CAUTION in
       * the comments preceding.
       */
      assert(index == 0);
      d = self-&gt;data;
      if (noval)
        {
          d-&gt;child = SIZED(PyObject_CallObject(OBJECT(&amp;SetType), NULL));
          UNLESS (d-&gt;child) return -1;
        }
      else
        {
          d-&gt;child = SIZED(PyObject_CallObject(OBJECT(&amp;BucketType), NULL));
          UNLESS (d-&gt;child) return -1;
        }
      self-&gt;len = 1;
      Py_INCREF(d-&gt;child);
      self-&gt;firstbucket = BUCKET(d-&gt;child);
    }

  return 0;
}
</t>
<t tx="ekr.20040104185913.1088">@ Return the rightmost bucket reachable from following child pointers * from self. The caller gets a new reference to this bucket. Note that * bucket 'next' pointers are not followed: if self is an interior node * of a BTree, this returns the rightmost bucket in that node's subtree. * In case of error, returns NULL. * * self must not be a ghost; this isn't checked. The result may be a ghost. * * Pragmatics: Note that the rightmost bucket's last key is the largest * key in self's subtree.
@c

static Bucket *
BTree_lastBucket(BTree *self)
{
    Sized *pchild;
    Bucket *result;

    UNLESS (self-&gt;data &amp;&amp; self-&gt;len) {
        IndexError(-1); /*XXX*/
        return NULL;
    }

    pchild = self-&gt;data[self-&gt;len - 1].child;
    if (SameType_Check(self, pchild)) {
        self = BTREE(pchild);
        PER_USE_OR_RETURN(self, NULL);
        result = BTree_lastBucket(self);
        PER_ALLOW_DEACTIVATION(self);
        PER_ACCESSED(self);
    }
    else {
        Py_INCREF(pchild);
        result = BUCKET(pchild);
    }
    return result;
}
</t>
<t tx="ekr.20040104185913.1089">static int
BTree_deleteNextBucket(BTree *self)
{
  Bucket *b;

  PER_USE_OR_RETURN(self, -1);

  UNLESS (b=BTree_lastBucket(self)) goto err;
  if (Bucket_deleteNextBucket(b) &lt; 0) goto err;

  Py_DECREF(b);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return 0;

 err:
  Py_XDECREF(b);
  PER_ALLOW_DEACTIVATION(self);
  return -1;
}
</t>
<t tx="ekr.20040104185913.1090">@ ** _BTree_clear ** ** Clears out all of the values in the BTree (firstbucket, keys, and children); ** leaving self an empty BTree. ** ** Arguments: self The BTree ** ** Returns: 0 on success ** -1 on failure ** ** Internal: Deallocation order is important. The danger is that a long ** list of buckets may get freed "at once" via decref'ing the first bucket, ** in which case a chain of consequenct Py_DECREF calls may blow the stack. ** Luckily, every bucket has a refcount of at least two, one due to being a ** BTree node's child, and another either because it's not the first bucket in ** the chain (so the preceding bucket points to it), or because firstbucket ** points to it. By clearing in the natural depth-first, left-to-right ** order, the BTree-&gt;bucket child pointers prevent Py_DECREF(bucket-&gt;next) ** calls from freeing bucket-&gt;next, and the maximum stack depth is equal ** to the height of the tree. *
@c

static int
_BTree_clear(BTree *self)
{
    const int len = self-&gt;len;

    if (self-&gt;firstbucket) {
        /* Obscure:  The first bucket is pointed to at least by
         * self-&gt;firstbucket and data[0].child of whichever BTree node it's
         * a child of.  However, if persistence is enabled then the latter
         * BTree node may be a ghost at this point, and so its pointers "don't
         * count":  we can only rely on self's pointers being intact.
         */
#ifdef PERSISTENT
	ASSERT(self-&gt;firstbucket-&gt;ob_refcnt &gt; 0,
	       "Invalid firstbucket pointer", -1);
#else
	ASSERT(self-&gt;firstbucket-&gt;ob_refcnt &gt; 1,
	       "Invalid firstbucket pointer", -1);
#endif
	Py_DECREF(self-&gt;firstbucket);
	self-&gt;firstbucket = NULL;
    }

    if (self-&gt;data) {
        int i;
        if (len &gt; 0) { /* 0 is special because key 0 is trash */
            Py_DECREF(self-&gt;data[0].child);
	}

        for (i = 1; i &lt; len; i++) {
#ifdef KEY_TYPE_IS_PYOBJECT
	    DECREF_KEY(self-&gt;data[i].key);
#endif
            Py_DECREF(self-&gt;data[i].child);
        }
	free(self-&gt;data);
	self-&gt;data = NULL;
    }

    self-&gt;len = self-&gt;size = 0;
    return 0;
}
</t>
<t tx="ekr.20040104185913.1091">@ Set (value != 0) or delete (value=0) a tree item.  If unique is non-zero, then only change if the key is  new.  If noval is non-zero, then don't set a value (the tree  is a set).  Return:   -1 error   0 successful, and number of entries didn't change   &gt;0 successful, and number of entries did change  Internal   There are two distinct return values &gt; 0:    1 Successful, number of entries changed, but firstbucket did not go away.    2 Successful, number of entries changed, firstbucket did go away.     This can only happen on a delete (value == NULL). The caller may     need to change its own firstbucket pointer, and in any case *someone*     needs to adjust the 'next' pointer of the bucket immediately preceding     the bucket that went away (it needs to point to the bucket immediately     following the bucket that went away).
@c

static int
_BTree_set(BTree *self, PyObject *keyarg, PyObject *value,
           int unique, int noval)
{
    int changed = 0;    /* did I mutate? */
    int min;            /* index of child I searched */
    BTreeItem *d;       /* self-&gt;data[min] */
    int childlength;    /* len(self-&gt;data[min].child) */
    int status;         /* our return value; and return value from callee */
    int self_was_empty; /* was self empty at entry? */

    KEY_TYPE key;
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS (copied) return -1;

    PER_USE_OR_RETURN(self, -1);

    self_was_empty = self-&gt;len == 0;
    if (self_was_empty) {
        /* We're empty.  Make room. */
	if (value) {
	    if (BTree_grow(self, 0, noval) &lt; 0)
		goto Error;
	}
	else {
	    /* Can't delete a key from an empty BTree. */
	    PyErr_SetObject(PyExc_KeyError, keyarg);
	    goto Error;
	}
    }

    /* Find the right child to search, and hand the work off to it. */
    BTREE_SEARCH(min, self, key, goto Error);
    d = self-&gt;data + min;

    if (SameType_Check(self, d-&gt;child))
	status = _BTree_set(BTREE(d-&gt;child), keyarg, value, unique, noval);
    else {
        int bucket_changed = 0;
	status = _bucket_set(BUCKET(d-&gt;child), keyarg,
	                     value, unique, noval, &amp;bucket_changed);
#ifdef PERSISTENT
	/* If a BTree contains only a single bucket, BTree.__getstate__()
	 * includes the bucket's entire state, and the bucket doesn't get
	 * an oid of its own.  So if we have a single oid-less bucket that
	 * changed, it's *our* oid that should be marked as changed.
	 */
	if (bucket_changed
	    &amp;&amp; self-&gt;len == 1
	    &amp;&amp; self-&gt;data[0].child-&gt;oid == NULL)
	{
	    changed = 1;
	}
#endif
    }
    if (status == 0) goto Done;
    if (status &lt; 0) goto Error;
    assert(status == 1 || status == 2);

    /* The child changed size.  Get its new size.  Note that since the tree
     * rooted at the child changed size, so did the tree rooted at self:
     * our status must be &gt;= 1 too.
     */
    UNLESS(PER_USE(d-&gt;child)) goto Error;
    childlength = d-&gt;child-&gt;len;
    PER_UNUSE(d-&gt;child);

    if (value) {
        /* A bucket got bigger -- if it's "too big", split it. */
        int toobig;

        assert(status == 1);    /* can be 2 only on deletes */
        if (SameType_Check(self, d-&gt;child))
            toobig = childlength &gt; MAX_BTREE_SIZE(d-&gt;child);
        else
            toobig = childlength &gt; MAX_BUCKET_SIZE(d-&gt;child);

        if (toobig) {
            if (BTree_grow(self, min, noval) &lt; 0) goto Error;
            changed = 1;        /* BTree_grow mutated self */
        }
        goto Done;      /* and status still == 1 */
    }

    /* A bucket got smaller.  This is much harder, and despite that we
     * don't try to rebalance the tree.
     */
    if (status == 2) {  /*  this is the last reference to child status */
        /* Two problems to solve:  May have to adjust our own firstbucket,
         * and the bucket that went away needs to get unlinked.
         */
        if (min) {
            /* This wasn't our firstbucket, so no need to adjust ours (note
             * that it can't be the firstbucket of any node above us either).
             * Tell "the tree to the left" to do the unlinking.
             */
            if (BTree_deleteNextBucket(BTREE(d[-1].child)) &lt; 0) goto Error;
            status = 1;     /* we solved the child's firstbucket problem */
        }
        else {
            /* This was our firstbucket.  Update to new firstbucket value. */
            Bucket *nextbucket;
            UNLESS(PER_USE(d-&gt;child)) goto Error;
            nextbucket = BTREE(d-&gt;child)-&gt;firstbucket;
            PER_UNUSE(d-&gt;child);

            Py_XINCREF(nextbucket);
            Py_DECREF(self-&gt;firstbucket);
            self-&gt;firstbucket = nextbucket;
            changed = 1;

            /* The caller has to do the unlinking -- we can't.  Also, since
             * it was our firstbucket, it may also be theirs.
             */
            assert(status == 2);
        }
    }

    /* If the child isn't empty, we're done!  We did all that was possible for
     * us to do with the firstbucket problems the child gave us, and since the
     * child isn't empty don't create any new firstbucket problems of our own.
     */
    if (childlength) goto Done;

    /* The child became empty:  we need to remove it from self-&gt;data.
     * But first, if we're a bottom-level node, we've got more bucket-fiddling
     * to set up.
     */
    if (!SameType_Check(self, d-&gt;child)) {
        /* We're about to delete a bucket. */
        if (min) {
            /* It's not our first bucket, so we can tell the previous
             * bucket to adjust its reference to it.  It can't be anyone
             * else's first bucket either, so the caller needn't do anything.
             */
            if (Bucket_deleteNextBucket(BUCKET(d[-1].child)) &lt; 0) goto Error;
            /* status should be 1, and already is:  if it were 2, the
             * block above would have set it to 1 in its min != 0 branch.
             */
            assert(status == 1);
        }
        else {
            Bucket *nextbucket;
            /* It's our first bucket.  We can't unlink it directly. */
            /* 'changed' will be set true by the deletion code following. */
            UNLESS(PER_USE(d-&gt;child)) goto Error;
            nextbucket = BUCKET(d-&gt;child)-&gt;next;
            PER_UNUSE(d-&gt;child);

            Py_XINCREF(nextbucket);
            Py_DECREF(self-&gt;firstbucket);
            self-&gt;firstbucket = nextbucket;

            status = 2; /* we're giving our caller a new firstbucket problem */
         }
    }

    /* Remove the child from self-&gt;data. */
    Py_DECREF(d-&gt;child);
#ifdef KEY_TYPE_IS_PYOBJECT
    if (min) {
        DECREF_KEY(d-&gt;key);
    }
    else if (self-&gt;len &gt; 1) {
	/* We're deleting the first child of a BTree with more than one
	 * child.  The key at d+1 is about to be shifted into slot 0,
	 * and hence never to be referenced again (the key in slot 0 is
	 * trash).
	 */
	DECREF_KEY((d+1)-&gt;key);
    }
    /* Else min==0 and len==1:  we're emptying the BTree entirely, and
     * there is no key in need of decrefing.
     */
#endif
    --self-&gt;len;
    if (min &lt; self-&gt;len)
        memmove(d, d+1, (self-&gt;len - min) * sizeof(BTreeItem));
    changed = 1;

Done:
#ifdef PERSISTENT
    if (changed) {
        if (PER_CHANGED(self) &lt; 0) goto Error;
    }
#endif
    PER_UNUSE(self);
    return status;

Error:
    if (self_was_empty) {
        /* BTree_grow may have left the BTree in an invalid state.  Make
         * sure the tree is a legitimate empty tree.
         */
        _BTree_clear(self);
    }
    PER_UNUSE(self);
    return -1;
}
</t>
<t tx="ekr.20040104185913.1092">@ ** BTree_setitem ** ** wrapper for _BTree_set ** ** Arguments: self The BTree ** key The key to insert ** v The value to insert ** ** Returns -1 on failure **  0 on success
@c

static int
BTree_setitem(BTree *self, PyObject *key, PyObject *v)
{
  if (_BTree_set(self, key, v, 0, 0) &lt; 0) return -1;
  return 0;
}
</t>
<t tx="ekr.20040104185913.1093">#ifdef PERSISTENT
static PyObject *
BTree__p_deactivate(BTree *self, PyObject *args)
{
  if (self-&gt;state==cPersistent_UPTODATE_STATE &amp;&amp; self-&gt;jar)
    {
      if (_BTree_clear(self) &lt; 0) return NULL;
      PER_GHOSTIFY(self);
    }

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.1094">#endif

static PyObject *
BTree_clear(BTree *self, PyObject *args)
{
  PER_USE_OR_RETURN(self, NULL);

  if (self-&gt;len)
    {
      if (_BTree_clear(self) &lt; 0) goto err;
      if (PER_CHANGED(self) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  Py_INCREF(Py_None);
  return Py_None;

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1095">@ * Return: * * For an empty BTree (self-&gt;len == 0), None. * * For a BTree with one child (self-&gt;len == 1), and that child is a bucket, * and that bucket has a NULL oid, a one-tuple containing a one-tuple * containing the bucket's state: * *   ( *     ( *       child[0].__getstate__(), *     ), *   ) * * Else a two-tuple. The first element is a tuple interleaving the BTree's * keys and direct children, of size 2*self-&gt;len - 1 (key[0] is unused and * is not saved). The second element is the firstbucket: * *   ( *     (child[0], key[1], child[1], key[2], child[2], ..., *                    key[len-1], child[len-1]), *     self-&gt;firstbucket *   ) * * In the above, key[i] means self-&gt;data[i].key, and similarly for child[i].
@c

static PyObject *
BTree_getstate(BTree *self, PyObject *args)
{
  PyObject *r=0, *o;
  int i, l;

  PER_USE_OR_RETURN(self, NULL);

  if (self-&gt;len)
    {
      UNLESS (r=PyTuple_New(self-&gt;len*2-1)) goto err;

      if (self-&gt;len == 1
          &amp;&amp; self-&gt;data-&gt;child-&gt;ob_type != self-&gt;ob_type
#ifdef PERSISTENT
          &amp;&amp; BUCKET(self-&gt;data-&gt;child)-&gt;oid == NULL
#endif
          )
        {
          /* We have just one bucket. Save its data directly. */
          UNLESS(o=bucket_getstate(BUCKET(self-&gt;data-&gt;child), NULL)) goto err;
          PyTuple_SET_ITEM(r,0,o);
          ASSIGN(r, Py_BuildValue("(O)", r));
        }
      else
        {
          for (i=0, l=0; i &lt; self-&gt;len; i++)
            {
              if (i)
                {
                  COPY_KEY_TO_OBJECT(o, self-&gt;data[i].key);
                  PyTuple_SET_ITEM(r,l,o);
                  l++;
                }
              o = OBJECT(self-&gt;data[i].child);
              Py_INCREF(o);
              PyTuple_SET_ITEM(r,l,o);
              l++;
            }
          ASSIGN(r, Py_BuildValue("OO", r, self-&gt;firstbucket));
        }

    }
  else
    {
      r = Py_None;
      Py_INCREF(r);
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return r;

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1096">static int
_BTree_setstate(BTree *self, PyObject *state, int noval)
{
    PyObject *items, *firstbucket=0;
    BTreeItem *d;
    int len, l, i, copied=1;

    if (_BTree_clear(self) &lt; 0)
	return -1;

    /* The state of a BTree can be one of the following:
       None -- an empty BTree
       A one-tuple -- a single bucket btree
       A two-tuple -- a BTree with more than one bucket
       See comments for BTree_getstate() for the details.
    */

    if (state == Py_None)
	return 0;

    if (!PyArg_ParseTuple(state, "O|O:__setstate__", &amp;items, &amp;firstbucket))
        return -1;

    len = PyTuple_Size(items);
    if (len &lt; 0)
	return -1;
    len = (len + 1) / 2;
    assert(len &gt; 0);

    assert(self-&gt;size == 0); /* XXX we called _BTree_clear() above! */
    assert(self-&gt;data == NULL); /* ditto */
    self-&gt;data = PyMalloc(sizeof(BTreeItem) * len);
    if (self-&gt;data == NULL)
	return -1;
    self-&gt;size = len;

    for (i = 0, d = self-&gt;data, l = 0; i &lt; len; i++, d++) {
	PyObject *v;
	if (i) { /* skip the first key slot */
	    COPY_KEY_FROM_ARG(d-&gt;key, PyTuple_GET_ITEM(items,l), copied);
	    l++;
	    if (!copied)
		return -1;
	    INCREF_KEY(d-&gt;key);
	}
	v = PyTuple_GET_ITEM(items, l);
	if (PyTuple_Check(v)) {
	    /* Handle the special case in __getstate__() for a BTree
	       with a single bucket. */
	    if (noval) {
		d-&gt;child = SIZED(PyObject_CallObject(OBJECT(&amp;SetType),
						     NULL));
		UNLESS (d-&gt;child) return -1;
		if (_set_setstate(BUCKET(d-&gt;child), v) &lt; 0)
		    return -1;
	    }
	    else {
		d-&gt;child = SIZED(PyObject_CallObject(OBJECT(&amp;BucketType),
						     NULL));
		UNLESS (d-&gt;child) return -1;
		if (_bucket_setstate(BUCKET(d-&gt;child), v) &lt; 0)
		    return -1;
	    }
	}
	else {
	    d-&gt;child = (Sized *)v;
	    Py_INCREF(v);
	}
	l++;
    }

    if (!firstbucket)
	firstbucket = OBJECT(self-&gt;data-&gt;child);

    if (!ExtensionClassSubclassInstance_Check(
	    firstbucket, noval ? &amp;SetType : &amp;BucketType)) {
	PyErr_SetString(PyExc_TypeError, "No firstbucket in non-empty BTree");
	return -1;
    }

    self-&gt;firstbucket = BUCKET(firstbucket);
    Py_INCREF(firstbucket);
#ifndef PERSISTENT
    /* firstbucket is also the child of some BTree node, but that node may
     * be a ghost if persistence is enabled.
     */
    assert(self-&gt;firstbucket-&gt;ob_refcnt &gt; 1);
#endif

    self-&gt;len = len;

    return 0;
}
</t>
<t tx="ekr.20040104185913.1097">static PyObject *
BTree_setstate(BTree *self, PyObject *args)
{
  int r;

  if (!PyArg_ParseTuple(args,"O",&amp;args)) return NULL;

  PER_PREVENT_DEACTIVATION(self);
  r=_BTree_setstate(self, args, 0);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  if (r &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.1098">#ifdef PERSISTENT
static PyObject *
BTree__p_resolveConflict(BTree *self, PyObject *args)
{
  PyObject *s[3], *r;
  int i;

  r = NULL;

  UNLESS (PyArg_ParseTuple(args, "OOO", s, s+1, s+2)) goto err;

                                /* for each state, detuplefy it twice */
  for (i=0; i &lt; 3; i++)
    UNLESS (s[i]==Py_None || PyArg_ParseTuple(s[i], "O", s+i)) goto err;
  for (i=0; i &lt; 3; i++)
    UNLESS (s[i]==Py_None || PyArg_ParseTuple(s[i], "O", s+i)) goto err;

  for (i=0; i &lt; 3; i++)         /* Now make sure detupled thing is a tuple */
    UNLESS (s[i]==Py_None || PyTuple_Check(s[i]))
      return merge_error(-100, -100, -100, -100);

  if (ExtensionClassSubclassInstance_Check(self, &amp;BTreeType))
      r = _bucket__p_resolveConflict(OBJECT(&amp;BucketType), s);
  else
      r = _bucket__p_resolveConflict(OBJECT(&amp;SetType), s);

err:

  if (r) {
  	ASSIGN(r, Py_BuildValue("((O))", r));
  }
  else {
  	PyObject *error;
	PyObject *value;
	PyObject *traceback;
  	/* Change any errors to ConflictErrors */

	PyErr_Fetch(&amp;error, &amp;value, &amp;traceback);
	Py_INCREF(ConflictError);
	Py_XDECREF(error);
	PyErr_Restore(ConflictError, value, traceback);
  }

  return r;
}
</t>
<t tx="ekr.20040104185913.1099">#endif

/*
 BTree_findRangeEnd -- Find one end, expressed as a bucket and
 position, for a range search.

 If low, return bucket and index of the smallest item &gt;= key,
 otherwise return bucket and index of the largest item &lt;= key.

 Return:
    -1      Error; offset and bucket unchanged
     0      Not found; offset and bucket unchanged
     1      Correct bucket and offset stored; the caller owns a new reference
            to the bucket.

 Internal:
    We do binary searches in BTree nodes downward, at each step following
    C(i) where K(i) &lt;= key &lt; K(i+1).  As always, K(i) &lt;= C(i) &lt; K(i+1) too.
    (See Maintainer.txt for the meaning of that notation.)  That eventually
    leads to a bucket where we do Bucket_findRangeEnd.  That usually works,
    but there are two cases where it can fail to find the correct answer:

    1. On a low search, we find a bucket with keys &gt;= K(i), but that doesn't
       imply there are keys in the bucket &gt;= key.  For example, suppose
       a bucket has keys in 1..100, its successor's keys are in 200..300, and
       we're doing a low search on 150.  We'll end up in the first bucket,
       but there are no keys &gt;= 150 in it.  K(i+1) &gt; key, though, and all
       the keys in C(i+1) &gt;= K(i+1) &gt; key, so the first key in the next
       bucket (if any) is the correct result.  This is easy to find by
       following the bucket 'next' pointer.

    2. On a high search, again that the keys in the bucket are &gt;= K(i)
       doesn't imply that any key in the bucket is &lt;= key, but it's harder
       for this to fail (and an earlier version of this routine didn't
       catch it):  if K(i) itself is in the bucket, it works (then
       K(i) &lt;= key is *a* key in the bucket that's in the desired range).
       But when keys get deleted from buckets, they aren't also deleted from
       BTree nodes, so there's no guarantee that K(i) is in the bucket.
       For example, delete the smallest key S from some bucket, and S
       remains in the interior BTree nodes.  Do a high search for S, and
       the BTree nodes direct the search to the bucket S used to be in,
       but all keys remaining in that bucket are &gt; S.  The largest key in
       the *preceding* bucket (if any) is &lt; K(i), though, and K(i) &lt;= key,
       so the largest key in the preceding bucket is &lt; key and so is the
       proper result.

       This is harder to get at efficiently, as buckets are linked only in
       the increasing direction.  While we're searching downward,
       deepest_smaller is set to the  node deepest in the tree where
       we *could* have gone to the left of C(i).  The rightmost bucket in
       deepest_smaller's subtree is the bucket preceding the bucket we find
       at first.  This is clumsy to get at, but efficient.
*/
static int
BTree_findRangeEnd(BTree *self, PyObject *keyarg, int low,
                   Bucket **bucket, int *offset) {
    Sized *deepest_smaller = NULL;      /* last possibility to move left */
    int deepest_smaller_is_btree = 0;   /* Boolean; if false, it's a bucket */
    Bucket *pbucket;
    int self_got_rebound = 0;   /* Boolean; when true, deactivate self */
    int result = -1;            /* Until proven innocent */
    int i;
    KEY_TYPE key;
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS (copied) return -1;

    /* We don't need to: PER_USE_OR_RETURN(self, -1);
       because the caller does. */
    UNLESS (self-&gt;data &amp;&amp; self-&gt;len) return 0;

    /* Search downward until hitting a bucket, stored in pbucket. */
    for (;;) {
        Sized *pchild;
        int pchild_is_btree;

        BTREE_SEARCH(i, self, key, goto Done);
        pchild = self-&gt;data[i].child;
        pchild_is_btree = SameType_Check(self, pchild);
        if (i) {
            deepest_smaller = self-&gt;data[i-1].child;
            deepest_smaller_is_btree = pchild_is_btree;
        }

        if (pchild_is_btree) {
            if (self_got_rebound) {
                PER_ALLOW_DEACTIVATION(self);
                PER_ACCESSED(self);
            }
            self = BTREE(pchild);
            self_got_rebound = 1;
            PER_USE_OR_RETURN(self, -1);
        }
        else {
            pbucket = BUCKET(pchild);
            break;
        }
    }

    /* Search the bucket for a suitable key. */
    i = Bucket_findRangeEnd(pbucket, keyarg, low, offset);
    if (i &lt; 0)
        goto Done;
    if (i &gt; 0) {
        Py_INCREF(pbucket);
        *bucket = pbucket;
        result = 1;
        goto Done;
    }
    /* This may be one of the two difficult cases detailed in the comments. */
    if (low) {
        Bucket *next;

        UNLESS(PER_USE(pbucket)) goto Done;
        next = pbucket-&gt;next;
        if (next) {
                result = 1;
                Py_INCREF(next);
                *bucket = next;
                *offset = 0;
        }
        else
                result = 0;
        PER_ALLOW_DEACTIVATION(pbucket);
        PER_ACCESSED(pbucket);
    }
    /* High-end search:  if it's possible to go left, do so. */
    else if (deepest_smaller) {
        if (deepest_smaller_is_btree) {
            UNLESS(PER_USE(deepest_smaller)) goto Done;
            /* We own the reference this returns. */
            pbucket = BTree_lastBucket(BTREE(deepest_smaller));
            PER_ALLOW_DEACTIVATION(deepest_smaller);
            PER_ACCESSED(deepest_smaller);
            if (pbucket == NULL) goto Done;   /* error */
        }
        else {
            pbucket = BUCKET(deepest_smaller);
            Py_INCREF(pbucket);
        }
        UNLESS(PER_USE(pbucket)) goto Done;
        result = 1;
        *bucket = pbucket;  /* transfer ownership to caller */
        *offset = pbucket-&gt;len - 1;
        PER_ALLOW_DEACTIVATION(pbucket);
        PER_ACCESSED(pbucket);
    }
    else
        result = 0;     /* simply not found */

Done:
    if (self_got_rebound) {
        PER_ALLOW_DEACTIVATION(self);
        PER_ACCESSED(self);
    }
    return result;
}
</t>
<t tx="ekr.20040104185913.1100">static PyObject *
BTree_maxminKey(BTree *self, PyObject *args, int min)
{
  PyObject *key = 0;
  Bucket *bucket = NULL;
  int offset, rc;

  UNLESS (PyArg_ParseTuple(args, "|O", &amp;key)) return NULL;

  PER_USE_OR_RETURN(self, NULL);

  UNLESS (self-&gt;data &amp;&amp; self-&gt;len) goto empty;

  /* Find the  range */

  if (key)
    {
      if ((rc = BTree_findRangeEnd(self, key, min, &amp;bucket, &amp;offset)) &lt;= 0)
        {
          if (rc &lt; 0) goto err;
          goto empty;
        }
      PER_ALLOW_DEACTIVATION(self);
      PER_ACCESSED(self);
      UNLESS (PER_USE(bucket))
        {
          Py_DECREF(bucket);
          return NULL;
        }
    }
  else if (min)
    {
      bucket = self-&gt;firstbucket;
      PER_ALLOW_DEACTIVATION(self);
      PER_ACCESSED(self);
      PER_USE_OR_RETURN(bucket, NULL);
      Py_INCREF(bucket);
      offset = 0;
    }
  else
    {
      bucket = BTree_lastBucket(self);
      PER_ALLOW_DEACTIVATION(self);
      PER_ACCESSED(self);
      UNLESS (PER_USE(bucket))
        {
          Py_DECREF(bucket);
          return NULL;
        }
      assert(bucket-&gt;len);
      offset = bucket-&gt;len - 1;
    }

  COPY_KEY_TO_OBJECT(key, bucket-&gt;keys[offset]);
  PER_ALLOW_DEACTIVATION(bucket);
  PER_ACCESSED(bucket);
  Py_DECREF(bucket);

  return key;

 empty:
  PyErr_SetString(PyExc_ValueError, "empty tree");

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  if (bucket)
    {
      PER_ALLOW_DEACTIVATION(bucket);
      PER_ACCESSED(bucket);
      Py_DECREF(bucket);
    }
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1101">static PyObject *
BTree_minKey(BTree *self, PyObject *args)
{
  return BTree_maxminKey(self, args, 1);
}
</t>
<t tx="ekr.20040104185913.1102">static PyObject *
BTree_maxKey(BTree *self, PyObject *args)
{
  return BTree_maxminKey(self, args, 0);
}
</t>
<t tx="ekr.20040104185913.1103">@ ** BTree_rangeSearch ** ** Generates a BTreeItems object based on the two indexes passed in, ** being the range between them. **
@c

static PyObject *
BTree_rangeSearch(BTree *self, PyObject *args, char type)
{
  PyObject *f=0, *l=0;
  int rc;
  Bucket *lowbucket = NULL;
  Bucket *highbucket = NULL;
  int lowoffset;
  int highoffset;

  UNLESS (! args || PyArg_ParseTuple(args,"|OO",&amp;f, &amp;l)) return NULL;

  PER_USE_OR_RETURN(self, NULL);

  UNLESS (self-&gt;data &amp;&amp; self-&gt;len) goto empty;

  /* Find the low range */

  if (f &amp;&amp; f != Py_None)
    {
      if ((rc = BTree_findRangeEnd(self, f, 1, &amp;lowbucket, &amp;lowoffset)) &lt;= 0)
        {
          if (rc &lt; 0) goto err;
          goto empty;
        }
    }
  else
    {
      lowbucket = self-&gt;firstbucket;
      Py_INCREF(lowbucket);
      lowoffset = 0;
    }

  /* Find the high range */

  if (l &amp;&amp; l != Py_None)
    {
      if ((rc = BTree_findRangeEnd(self, l, 0, &amp;highbucket, &amp;highoffset)) &lt;= 0)
        {
          Py_DECREF(lowbucket);
          if (rc &lt; 0) goto err;
          goto empty;
        }
    }
  else
    {
      highbucket = BTree_lastBucket(self);
      assert(highbucket != NULL);  /* we know self isn't empty */
      UNLESS (PER_USE(highbucket))
        {
          Py_DECREF(lowbucket);
          Py_DECREF(highbucket);
          goto err;
        }
      highoffset = highbucket-&gt;len - 1;
      PER_ALLOW_DEACTIVATION(highbucket);
      PER_ACCESSED(highbucket);
    }

  /* It's still possible that the range is empty, even if f &lt; l.  For
   * example, if f=3 and l=4, and 3 and 4 aren't in the BTree, but 2 and
   * 5 are, then the low position points to the 5 now and the high position
   * points to the 2 now.  They're not necessarily even in the same bucket,
   * so there's no trick we can play with pointer compares to get out
   * cheap in general.
   */
  if (lowbucket == highbucket &amp;&amp; lowoffset &gt; highoffset)
    goto empty_and_decref_buckets;      /* definitely empty */

  /* The buckets differ, or they're the same and the offsets show a non-
   * empty range.
   */
  if (f &amp;&amp; f != Py_None             /* both args user-supplied */
      &amp;&amp; l &amp;&amp; l != Py_None
      &amp;&amp; lowbucket != highbucket)   /* and different buckets */
    {
      KEY_TYPE first;
      KEY_TYPE last;
      int cmp;

      /* Have to check the hard way:  see how the endpoints compare. */
      UNLESS (PER_USE(lowbucket)) goto err_and_decref_buckets;
      COPY_KEY(first, lowbucket-&gt;keys[lowoffset]);
      PER_ALLOW_DEACTIVATION(lowbucket);
      PER_ACCESSED(lowbucket);

      UNLESS (PER_USE(highbucket)) goto err_and_decref_buckets;
      COPY_KEY(last, highbucket-&gt;keys[highoffset]);
      PER_ALLOW_DEACTIVATION(highbucket);
      PER_ACCESSED(highbucket);

      TEST_KEY_SET_OR(cmp, first, last) goto err_and_decref_buckets;
      if (cmp &gt; 0) goto empty_and_decref_buckets;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  f = newBTreeItems(type, lowbucket, lowoffset, highbucket, highoffset);
  Py_DECREF(lowbucket);
  Py_DECREF(highbucket);
  return f;

 err_and_decref_buckets:
  Py_DECREF(lowbucket);
  Py_DECREF(highbucket);

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return NULL;

 empty_and_decref_buckets:
  Py_DECREF(lowbucket);
  Py_DECREF(highbucket);

 empty:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return newBTreeItems(type, 0, 0, 0, 0);
}
</t>
<t tx="ekr.20040104185913.1104">@ ** BTree_keys
@c

static PyObject *
BTree_keys(BTree *self, PyObject *args)
{
  return BTree_rangeSearch(self,args, 'k');
}
</t>
<t tx="ekr.20040104185913.1105">@ ** BTree_values
@c

static PyObject *
BTree_values(BTree *self, PyObject *args)
{
  return BTree_rangeSearch(self,args,'v');
}
</t>
<t tx="ekr.20040104185913.1106">@ ** BTree_items
@c

static PyObject *
BTree_items(BTree *self, PyObject *args)
{
  return BTree_rangeSearch(self,args,'i');
}
</t>
<t tx="ekr.20040104185913.1107">static PyObject *
BTree_byValue(BTree *self, PyObject *args)
{
  PyObject *r=0, *o=0, *item=0, *omin;
  VALUE_TYPE min;
  VALUE_TYPE v;
  int copied=1;
  SetIteration it = {0, 0, 1};

  PER_USE_OR_RETURN(self, NULL);

  UNLESS (PyArg_ParseTuple(args, "O", &amp;omin)) return NULL;
  COPY_VALUE_FROM_ARG(min, omin, copied);
  UNLESS(copied) return NULL;

  UNLESS (r=PyList_New(0)) goto err;

  it.set=BTree_rangeSearch(self, NULL, 'i');
  UNLESS(it.set) goto err;

  if (nextBTreeItems(&amp;it) &lt; 0) goto err;

  while (it.position &gt;= 0)
    {
      if (TEST_VALUE(it.value, min) &gt;= 0)
        {
          UNLESS (item = PyTuple_New(2)) goto err;

          COPY_KEY_TO_OBJECT(o, it.key);
          UNLESS (o) goto err;
          PyTuple_SET_ITEM(item, 1, o);

          COPY_VALUE(v, it.value);
          NORMALIZE_VALUE(v, min);
          COPY_VALUE_TO_OBJECT(o, v);
          DECREF_VALUE(v);
          UNLESS (o) goto err;
          PyTuple_SET_ITEM(item, 0, o);

          if (PyList_Append(r, item) &lt; 0) goto err;
          Py_DECREF(item);
          item = 0;
        }
      if (nextBTreeItems(&amp;it) &lt; 0) goto err;
    }

  item=PyObject_GetAttr(r,sort_str);
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_CallObject(item, NULL));
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_GetAttr(r, reverse_str));
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_CallObject(item, NULL));
  UNLESS (item) goto err;
  Py_DECREF(item);

  finiSetIteration(&amp;it);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(r);
  finiSetIteration(&amp;it);
  Py_XDECREF(item);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1108">@ ** BTree_getm
@c

static PyObject *
BTree_getm(BTree *self, PyObject *args)
{
  PyObject *key, *d=Py_None, *r;

  UNLESS (PyArg_ParseTuple(args, "O|O", &amp;key, &amp;d)) return NULL;
  if ((r=_BTree_get(self, key, 0))) return r;
  UNLESS (PyErr_ExceptionMatches(PyExc_KeyError)) return NULL;
  PyErr_Clear();
  Py_INCREF(d);
  return d;
}
</t>
<t tx="ekr.20040104185913.1109">@ ** BTree_has_key
@c

static PyObject *
BTree_has_key(BTree *self, PyObject *args)
{
  PyObject *key;

  UNLESS (PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  return _BTree_get(self, key, 1);
}
</t>
<t tx="ekr.20040104185913.1110">static PyObject *
BTree_addUnique(BTree *self, PyObject *args)
{
  int grew;
  PyObject *key, *v;

  UNLESS (PyArg_ParseTuple(args, "OO", &amp;key, &amp;v)) return NULL;

  if ((grew=_BTree_set(self, key, v, 1, 0)) &lt; 0) return NULL;
  return PyInt_FromLong(grew);
}
</t>
<t tx="ekr.20040104185913.1111">static struct PyMethodDef BTree_methods[] = {
  {"__getstate__", (PyCFunction) BTree_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction) BTree_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"has_key",	(PyCFunction) BTree_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"keys",	(PyCFunction) BTree_keys,	METH_VARARGS,
     "keys([min, max]) -- Return the keys"},
  {"values",	(PyCFunction) BTree_values,	METH_VARARGS,
     "values([min, max]) -- Return the values"},
  {"items",	(PyCFunction) BTree_items,	METH_VARARGS,
     "items([min, max]) -- Return the items"},
  {"byValue",	(PyCFunction) BTree_byValue,	METH_VARARGS,
   "byValue(min) -- "
   "Return value-keys with values &gt;= min and reverse sorted by values"
  },
  {"get",	(PyCFunction) BTree_getm,	METH_VARARGS,
   "get(key[,default]) -- Look up a value\n\n"
   "Return the default (or None) if the key is not found."
  },
  {"maxKey", (PyCFunction) BTree_maxKey,	METH_VARARGS,
   "maxKey([key]) -- Find the maximum key\n\n"
   "If an argument is given, find the maximum &lt;= the argument"},
  {"minKey", (PyCFunction) BTree_minKey,	METH_VARARGS,
   "minKey([key]) -- Find the minimum key\n\n"
   "If an argument is given, find the minimum &gt;= the argument"},
  {"clear",	(PyCFunction) BTree_clear,	METH_VARARGS,
   "clear() -- Remove all of the items from the BTree"},
  {"insert", (PyCFunction)BTree_addUnique, METH_VARARGS,
   "insert(key, value) -- Add an item if the key is not already used.\n\n"
   "Return 1 if the item was added, or 0 otherwise"
  },
  {"update",	(PyCFunction) Mapping_update,	METH_VARARGS,
   "update(collection) -- Add the items from the given collection"},
  {"__init__",	(PyCFunction) Mapping_update,	METH_VARARGS,
   "__init__(collection) -- Initialize with items from the given collection"},
  {"_check", (PyCFunction) BTree_check,         METH_VARARGS,
   "Perform sanity check on BTree, and raise exception if flawed."},
#ifdef PERSISTENT
  {"_p_resolveConflict", (PyCFunction) BTree__p_resolveConflict, METH_VARARGS,
   "_p_resolveConflict() -- Reinitialize from a newly created copy"},
  {"_p_deactivate", (PyCFunction) BTree__p_deactivate,	METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
  {NULL,		NULL}		/* sentinel */
};

static void
BTree_dealloc(BTree *self)
{
  if (self-&gt;state != cPersistent_GHOST_STATE)
    _BTree_clear(self);

  PER_DEL(self);

  Py_DECREF(self-&gt;ob_type);
  PyObject_Del(self);
}
</t>
<t tx="ekr.20040104185913.1112">@ * Return the number of elements in a BTree. nonzero is a Boolean, and * when true requests just a non-empty/empty result. Testing for emptiness * is efficient (constant-time). Getting the true length takes time * proportional to the number of leaves (buckets). * * Return: *   When nonzero true: *     -1 error *      0 empty *      1 not empty *   When nonzero false (possibly expensive!): *     -1 error *    &gt;= 0 number of elements.
@c

static int
BTree_length_or_nonzero(BTree *self, int nonzero)
{
    int result;
    Bucket *b;
    Bucket *next;

    PER_USE_OR_RETURN(self, -1);
    b = self-&gt;firstbucket;
    PER_UNUSE(self);
    if (nonzero)
        return b != NULL;

    result = 0;
    while (b) {
        PER_USE_OR_RETURN(b, -1);
        result += b-&gt;len;
        next = b-&gt;next;
        PER_UNUSE(b);
        b = next;
    }
    return result;
}
</t>
<t tx="ekr.20040104185913.1113">static int
BTree_length( BTree *self)
{
  return BTree_length_or_nonzero(self, 0);
}
</t>
<t tx="ekr.20040104185913.1114">static PyMappingMethods BTree_as_mapping = {
  (inquiry)BTree_length,		/*mp_length*/
  (binaryfunc)BTree_get,		/*mp_subscript*/
  (objobjargproc)BTree_setitem,	        /*mp_ass_subscript*/
};

static int
BTree_nonzero( BTree *self)
{
  return BTree_length_or_nonzero(self, 1);
}
</t>
<t tx="ekr.20040104185913.1115">&lt;&lt; BucketTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1116">&lt;&lt; c copyright &gt;&gt;

#define BUCKETTEMPLATE_C "$Id: BucketTemplate.c,v 1.47.10.4 2003/05/12 16:36:09 tim_one Exp $\n"

/* Use BUCKET_SEARCH to find the index at which a key belongs.
 * INDEX    An int lvalue to hold the index i such that KEY belongs at
 *          SELF-&gt;keys[i].  Note that this will equal SELF-&gt;len if KEY
 *          is larger than the bucket's largest key.  Else it's the
 *          smallest i such that SELF-&gt;keys[i] &gt;= KEY.
 * ABSENT   An int lvalue to hold a Boolean result, true (!= 0) if the
 *          key is absent, false (== 0) if the key is at INDEX.
 * SELF     A pointer to a Bucket node.
 * KEY      The key you're looking for, of type KEY_TYPE.
 * ONERROR  What to do if key comparison raises an exception; for example,
 *          perhaps 'return NULL'.
 *
 * See Maintainer.txt for discussion:  this is optimized in subtle ways.
 * It's recommended that you call this at the start of a routine, waiting
 * to check for self-&gt;len == 0 after (if an empty bucket is special in
 * context; INDEX becomes 0 and ABSENT becomes true if this macro is run
 * with an empty SELF, and that may be all the invoker needs to know).
 */
#define BUCKET_SEARCH(INDEX, ABSENT, SELF, KEY, ONERROR) {  \
    int _lo = 0;                                            \
    int _hi = (SELF)-&gt;len;                                  \
    int _i;                                                 \
    int _cmp = 1;                                           \
    for (_i = _hi &gt;&gt; 1; _lo &lt; _hi; _i = (_lo + _hi) &gt;&gt; 1) { \
        TEST_KEY_SET_OR(_cmp, (SELF)-&gt;keys[_i], (KEY))      \
            ONERROR;                                        \
        if      (_cmp &lt; 0)  _lo = _i + 1;                   \
        else if (_cmp == 0) break;                          \
        else                _hi = _i;                       \
    }                                                       \
    (INDEX) = _i;                                           \
    (ABSENT) = _cmp;                                        \
}

/*
** _bucket_get
**
** Search a bucket for a given key.
**
** Arguments
**     self	The bucket
**     keyarg	The key to look for
**     has_key	Boolean; if true, return a true/false result; else return
**              the value associated with the key.
**
** Return
**     If has_key:
**         Returns the Python int 0 if the key is absent, else returns
**         has_key itself as a Python int.  A BTree caller generally passes
**         the depth of the bucket for has_key, so a true result returns
**         the bucket depth then.
**         Note that has_key should be tree when searching set buckets.
**     If not has_key:
**         If the key is present, returns the associated value, and the
**         caller owns the reference.  Else returns NULL and sets KeyError.
**     Whether or not has_key:
**         If a comparison sets an exception, returns NULL.
*/
static PyObject *
_bucket_get(Bucket *self, PyObject *keyarg, int has_key)
{
    int i, cmp;
    KEY_TYPE key;
    PyObject *r = NULL;
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS (copied) return NULL;

    PER_USE_OR_RETURN(self, NULL);

    BUCKET_SEARCH(i, cmp, self, key, goto Done);
    if (has_key)
    	r = PyInt_FromLong(cmp ? 0 : has_key);
    else {
        if (cmp == 0) {
            COPY_VALUE_TO_OBJECT(r, self-&gt;values[i]);
        }
        else
            PyErr_SetObject(PyExc_KeyError, keyarg);
    }

Done:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;
}

static PyObject *
bucket_getitem(Bucket *self, PyObject *key)
{
  return _bucket_get(self, key, 0);
}

/*
** Bucket_grow
**
** Resize a bucket.
**
** Arguments:   self    The bucket.
**              newsize The new maximum capacity.  If &lt; 0, double the
**                      current size unless the bucket is currently empty,
**                      in which case use MIN_BUCKET_ALLOC.
**              noval   Boolean; if true, allocate only key space and not
**                      value space
**
** Returns:     -1      on error, and MemoryError exception is set
**               0      on success
*/
static int
Bucket_grow(Bucket *self, int newsize, int noval)
{
  KEY_TYPE *keys;
  VALUE_TYPE *values;

  if (self-&gt;size)
    {
      if (newsize &lt; 0)
        newsize = self-&gt;size * 2;
      if (newsize &lt; 0)    /* int overflow */
        goto Overflow;
      UNLESS (keys = PyRealloc(self-&gt;keys, sizeof(KEY_TYPE) * newsize))
        return -1;

      UNLESS (noval)
        {
          values = PyRealloc(self-&gt;values, sizeof(VALUE_TYPE) * newsize);
          if (values == NULL)
            {
              free(keys);
              return -1;
            }
          self-&gt;values = values;
        }
      self-&gt;keys = keys;
    }
  else
    {
      if (newsize &lt; 0)
        newsize = MIN_BUCKET_ALLOC;
      UNLESS (self-&gt;keys = PyMalloc(sizeof(KEY_TYPE) * newsize))
        return -1;
      UNLESS (noval)
        {
          self-&gt;values = PyMalloc(sizeof(VALUE_TYPE) * newsize);
          if (self-&gt;values == NULL)
            {
              free(self-&gt;keys);
              self-&gt;keys = NULL;
              return -1;
            }
        }
    }
  self-&gt;size = newsize;
  return 0;

Overflow:
  PyErr_NoMemory();
  return -1;
}

/*
 * Append a slice of the "from" bucket to self.
 *
 * self         Append (at least keys) to this bucket.  self must be activated
 *              upon entry, and remains activated at exit.  If copyValues
 *              is true, self must be empty or already have a non-NULL values
 *              pointer.  self's access and modification times aren't updated.
 * from         The bucket from which to take keys, and possibly values.  from
 *              must be activated upon entry, and remains activated at exit.
 *              If copyValues is true, from must have a non-NULL values
 *              pointer.  self and from must not be the same.  from's access
 *              time isn't updated.
 * i, n         The slice from[i : i+n] is appended to self.  Must have
 *              i &gt;= 0, n &gt; 0 and i+n &lt;= from-&gt;len.
 * copyValues   Boolean.  If true, copy values from the slice as well as keys.
 *              In this case, from must have a non-NULL values pointer, and
 *              self must too (unless self is empty, in which case a values
 *              vector will be allocated for it).
 * overallocate Boolean.  If self doesn't have enough room upon entry to hold
 *              all the appended stuff, then if overallocate is false exactly
 *              enough room will be allocated to hold the new stuff, else if
 *              overallocate is true an excess will be allocated.  overallocate
 *              may be a good idea if you expect to append more stuff to self
 *              later; else overallocate should be false.
 *
 * CAUTION:  If self is empty upon entry (self-&gt;size == 0), and copyValues is
 * false, then no space for values will get allocated.  This can be a trap if
 * the caller intends to copy values itself.
 *
 * Return
 *    -1        Error.
 *     0        OK.
 */
static int
bucket_append(Bucket *self, Bucket *from, int i, int n,
              int copyValues, int overallocate)
{
    int newlen;

    assert(self &amp;&amp; from &amp;&amp; self != from);
    assert(i &gt;= 0);
    assert(n &gt; 0);
    assert(i+n &lt;= from-&gt;len);

    /* Make room. */
    newlen = self-&gt;len + n;
    if (newlen &gt; self-&gt;size) {
        int newsize = newlen;
        if (overallocate)   /* boost by 25% -- pretty arbitrary */
            newsize += newsize &gt;&gt; 2;
        if (Bucket_grow(self, newsize, ! copyValues) &lt; 0)
            return -1;
    }
    assert(newlen &lt;= self-&gt;size);

    /* Copy stuff. */
    memcpy(self-&gt;keys + self-&gt;len, from-&gt;keys + i, n * sizeof(KEY_TYPE));
    if (copyValues) {
        assert(self-&gt;values);
        assert(from-&gt;values);
        memcpy(self-&gt;values + self-&gt;len, from-&gt;values + i,
                n * sizeof(VALUE_TYPE));
    }
    self-&gt;len = newlen;

    /* Bump refcounts. */
#ifdef KEY_TYPE_IS_PYOBJECT
    {
        int j;
        PyObject **p = from-&gt;keys + i;
        for (j = 0; j &lt; n; ++j, ++p) {
            Py_INCREF(*p);
        }
    }
#endif
#ifdef VALUE_TYPE_IS_PYOBJECT
    if (copyValues) {
        int j;
        PyObject **p = from-&gt;values + i;
        for (j = 0; j &lt; n; ++j, ++p) {
            Py_INCREF(*p);
        }
    }
#endif
    return 0;
}


/*
** _bucket_set: Assign a value to a key in a bucket, delete a key+value
**  pair, or just insert a key.
**
** Arguments
**     self     The bucket
**     keyarg   The key to look for
**     v        The value to associate with key; NULL means delete the key.
**              If NULL, it's an error (KeyError) if the key isn't present.
**              Note that if this is a set bucket, and you want to insert
**              a new set element, v must be non-NULL although its exact
**              value will be ignored.  Passing Py_None is good for this.
**     unique   Boolean; when true, don't replace the value if the key is
**              already present.
**     noval    Boolean; when true, operate on keys only (ignore values)
**     changed  ignored on input
**
** Return
**     -1       on error
**      0       on success and the # of bucket entries didn't change
**      1       on success and the # of bucket entries did change
**  *changed    If non-NULL, set to 1 on any mutation of the bucket.
*/
static int
_bucket_set(Bucket *self, PyObject *keyarg, PyObject *v,
            int unique, int noval, int *changed)
{
    int i, cmp;
    KEY_TYPE key;

    /* Subtle:  there may or may not be a value.  If there is, we need to
     * check its type early, so that in case of error we can get out before
     * mutating the bucket.  But because value isn't used on all paths, if
     * we don't initialize value then gcc gives a nuisance complaint that
     * value may be used initialized (it can't be, but gcc doesn't know
     * that).  So we initialize it.  However, VALUE_TYPE can be various types,
     * including int, PyObject*, and char[6], so it's a puzzle to spell
     * initialization.  It so happens that {0} is a valid initializer for all
     * these types.
     */
    VALUE_TYPE value = {0};	/* squash nuisance warning */
    int result = -1;    /* until proven innocent */
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS(copied) return -1;

    /* Copy the value early (if needed), so that in case of error a
     * pile of bucket mutations don't need to be undone.
     */
    if (v &amp;&amp; !noval) {
    	COPY_VALUE_FROM_ARG(value, v, copied);
    	UNLESS(copied) return -1;
    }

    PER_USE_OR_RETURN(self, -1);

    BUCKET_SEARCH(i, cmp, self, key, goto Done);
    if (cmp == 0) {
        /* The key exists, at index i. */

        if (v) {
            /* The key exists at index i, and there's a new value.
             * If unique, we're not supposed to replace it.  If noval, or this
             * is a set bucket (self-&gt;values is NULL), there's nothing to do.
             */
            if (unique || noval || self-&gt;values == NULL) {
                result = 0;
                goto Done;
            }

            /* The key exists at index i, and we need to replace the value. */
#ifdef VALUE_SAME
            /* short-circuit if no change */
            if (VALUE_SAME(self-&gt;values[i], value)) {
                result = 0;
                goto Done;
            }
#endif
            if (changed)
                *changed = 1;
            DECREF_VALUE(self-&gt;values[i]);
            COPY_VALUE(self-&gt;values[i], value);
            INCREF_VALUE(self-&gt;values[i]);
            if (PER_CHANGED(self) &gt;= 0)
                result = 0;
            goto Done;
        }

        /* The key exists at index i, and should be deleted. */
        DECREF_KEY(self-&gt;keys[i]);
        self-&gt;len--;
        if (i &lt; self-&gt;len)
            memmove(self-&gt;keys + i, self-&gt;keys + i+1,
                    sizeof(KEY_TYPE)*(self-&gt;len - i));

        if (self-&gt;values) {
            DECREF_VALUE(self-&gt;values[i]);
            if (i &lt; self-&gt;len)
                memmove(self-&gt;values + i, self-&gt;values + i+1,
                        sizeof(VALUE_TYPE)*(self-&gt;len - i));
        }

        if (! self-&gt;len) {
            self-&gt;size = 0;
            free(self-&gt;keys);
            self-&gt;keys = NULL;
            if (self-&gt;values) {
                free(self-&gt;values);
                self-&gt;values = NULL;
            }
        }

        if (changed)
            *changed = 1;
        if (PER_CHANGED(self) &gt;= 0)
            result = 1;
        goto Done;
    }

    /* The key doesn't exist, and belongs at index i. */
    if (!v) {
        /* Can't delete a non-existent key. */
        PyErr_SetObject(PyExc_KeyError, keyarg);
        goto Done;
    }

    /* The key doesn't exist and should be inserted at index i. */
    if (self-&gt;len == self-&gt;size &amp;&amp; Bucket_grow(self, -1, noval) &lt; 0)
        goto Done;

    if (self-&gt;len &gt; i) {
        memmove(self-&gt;keys + i+1, self-&gt;keys + i,
                sizeof(KEY_TYPE)*(self-&gt;len - i));
        if (self-&gt;values) {
            memmove(self-&gt;values + i+1, self-&gt;values + i,
                    sizeof(VALUE_TYPE)*(self-&gt;len - i));
        }
    }

    COPY_KEY(self-&gt;keys[i], key);
    INCREF_KEY(self-&gt;keys[i]);

    if (! noval) {
        COPY_VALUE(self-&gt;values[i], value);
        INCREF_VALUE(self-&gt;values[i]);
    }

    self-&gt;len++;
    if (changed)
        *changed = 1;
    if (PER_CHANGED(self) &gt;= 0)
        result = 1;

Done:
    PER_ALLOW_DEACTIVATION(self);
    PER_ACCESSED(self);
    return result;
}

/*
** bucket_setitem
**
** wrapper for _bucket_setitem (eliminates +1 return code)
**
** Arguments:	self	The bucket
**		key	The key to insert under
**		v	The value to insert
**
** Returns	 0 	on success
**		-1	on failure
*/
static int
bucket_setitem(Bucket *self, PyObject *key, PyObject *v)
{
  if (_bucket_set(self, key, v, 0, 0, 0) &lt; 0) return -1;
  return 0;
}

/**
 ** Mapping_update()
 **
 ** Accepts a sequence of 2-tuples or any object with an items()
 ** method that returns a sequence of 2-tuples.
 **
 */

static PyObject *
Mapping_update(PyObject *self, PyObject *args)
{
  PyObject *seq=0, *o, *t, *v, *tb, *k, *items = NULL;
  int i;

  UNLESS(PyArg_ParseTuple(args, "|O:update", &amp;seq)) return NULL;

  if (!seq)
    {
      Py_INCREF(Py_None);
      return Py_None;
    }

  if (!PySequence_Check(seq))
    {
      items = PyObject_GetAttr(seq, items_str);
      UNLESS(items) return NULL;
      ASSIGN(items, PyObject_CallObject(items, NULL));
      UNLESS(items) return NULL;
      /* items is DECREFed on exit, seq is not */
      seq = items;
    }

  for (i=0; ; i++)
    {
      o = PySequence_GetItem(seq, i);
      UNLESS (o)
	{
	  PyErr_Fetch(&amp;t, &amp;v, &amp;tb);
	  if (t != PyExc_IndexError)
	    {
	      PyErr_Restore(t, v, tb);
	      goto err;
	    }
	  Py_XDECREF(t);
	  Py_XDECREF(v);
	  Py_XDECREF(tb);
	  break;
	}

      if (!PyTuple_Check(o) || PyTuple_GET_SIZE(o) != 2)
        {
	  Py_DECREF(o);
	  PyErr_SetString(PyExc_TypeError,
			  "Sequence must contain 2-item tuples");
	  goto err;
        }
      k = PyTuple_GET_ITEM(o, 0);
      v = PyTuple_GET_ITEM(o, 1);
      if (PyObject_SetItem(self, k, v) &lt; 0)
        {
          Py_DECREF(o);
	  goto err;
        }
      Py_DECREF(o);
    }

  Py_XDECREF(items);
  Py_INCREF(Py_None);
  return Py_None;

 err:
  Py_XDECREF(items);
  return NULL;
}


/*
** bucket_split
**
** Splits one bucket into two
**
** Arguments:	self	The bucket
**		index	the index of the key to split at (O.O.B use midpoint)
**		next	the new bucket to split into
**
** Returns:	 0	on success
**		-1	on failure
*/
static int
bucket_split(Bucket *self, int index, Bucket *next)
{
  int next_size;

  ASSERT(self-&gt;len &gt; 1, "split of empty bucket", -1);

  if (index &lt; 0 || index &gt;= self-&gt;len)
    index = self-&gt;len / 2;

  next_size = self-&gt;len - index;

  next-&gt;keys = PyMalloc(sizeof(KEY_TYPE) * next_size);
  if (!next-&gt;keys)
      return -1;
  memcpy(next-&gt;keys, self-&gt;keys + index, sizeof(KEY_TYPE) * next_size);
  if (self-&gt;values)
    {
      next-&gt;values = PyMalloc(sizeof(VALUE_TYPE) * next_size);
      if (!next-&gt;values)
        {
          free(next-&gt;keys);
          next-&gt;keys = NULL;
          return -1;
        }
      memcpy(next-&gt;values, self-&gt;values + index,
             sizeof(VALUE_TYPE) * next_size);
    }
  next-&gt;size = next_size;
  next-&gt;len = next_size;
  self-&gt;len = index;

  next-&gt;next = self-&gt;next;

  Py_INCREF(next);
  self-&gt;next = next;

  if (PER_CHANGED(self) &lt; 0)
    return -1;

  return 0;
}

/* Set self-&gt;next to self-&gt;next-&gt;next, i.e. unlink self's successor from
 * the chain.
 *
 * Return:
 *     -1       error
 *      0       OK
 */
static int
Bucket_deleteNextBucket(Bucket *self)
{
    int result = -1;    /* until proven innocent */
    Bucket *successor;

    PER_USE_OR_RETURN(self, -1);
    successor = self-&gt;next;
    if (successor) {
        Bucket *next;
        /* Before:  self -&gt; successor -&gt; next
         * After:   self --------------&gt; next
         */
        UNLESS (PER_USE(successor)) goto Done;
        next = successor-&gt;next;
        PER_UNUSE(successor);

        Py_XINCREF(next);       /* it may be NULL, of course */
        self-&gt;next = next;
        Py_DECREF(successor);
	if (PER_CHANGED(self) &lt; 0)
	    goto Done;
    }
    result = 0;

Done:
    PER_UNUSE(self);
    return result;
}

/*
 Bucket_findRangeEnd -- Find the index of a range endpoint
 (possibly) contained in a bucket.

 Arguments:     self        The bucket
                keyarg      The key to match against
                low         Boolean; true for low end of range, false for high
                offset      The output offset

 If low true, *offset &lt;- index of the smallest item &gt;= key,
 if low false the index of the largest item &lt;= key.  In either case, if there
 is no such index, *offset is left alone and 0 is returned.

 Return:
      0     No suitable index exists; *offset has not been changed
      1     The correct index was stored into *offset
     -1     Error

 Example:  Suppose the keys are [2, 4].  Searching for 2 sets *offset to 0 and
 returns 1 regardless of low.  Searching for 4 sets *offset to 1 and returns
 1 regardless of low.
 Searching for 1:
     If low true, sets *offset to 0, returns 1.
     If low false, returns 0.
 Searching for 3:
     If low true, sets *offset to 1, returns 1.
     If low false, sets *offset to 0, returns 1.
 Searching for 5:
     If low true, returns 0.
     If low false, sets *offset to 1, returns 1.
 */
static int
Bucket_findRangeEnd(Bucket *self, PyObject *keyarg, int low, int *offset)
{
    int i, cmp;
    int result = -1;    /* until proven innocent */
    KEY_TYPE key;
    int copied = 1;

    COPY_KEY_FROM_ARG(key, keyarg, copied);
    UNLESS (copied) return -1;

    PER_USE_OR_RETURN(self, -1);

    BUCKET_SEARCH(i, cmp, self, key, goto Done);
    if (cmp == 0)   /* exact match at index i */
        result = 1;

    /* Else keys[i-1] &lt; key &lt; keys[i], picturing infinities at OOB indices */
    else if (low)   /* i has the smallest item &gt; key, unless i is OOB */
        result = i &lt; self-&gt;len;

    else {          /* i-1 has the largest item &lt; key, unless i-1 is 0OB */
        --i;
        result = i &gt;= 0;
    }

    if (result)
        *offset = i;

Done:
    PER_ALLOW_DEACTIVATION(self);
    PER_ACCESSED(self);
    return result;
}

static PyObject *
Bucket_maxminKey(Bucket *self, PyObject *args, int min)
{
  PyObject *key=0;
  int rc, offset;

  if (args &amp;&amp; ! PyArg_ParseTuple(args, "|O", &amp;key)) return NULL;

  PER_USE_OR_RETURN(self, NULL);

  UNLESS (self-&gt;len) goto empty;

  /* Find the low range */
  if (key)
    {
      if ((rc = Bucket_findRangeEnd(self, key, min, &amp;offset)) &lt;= 0)
        {
          if (rc &lt; 0) return NULL;
          goto empty;
        }
    }
  else if (min) offset = 0;
  else offset = self-&gt;len -1;

  COPY_KEY_TO_OBJECT(key, self-&gt;keys[offset]);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return key;

 empty:
  PyErr_SetString(PyExc_ValueError, "empty bucket");
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return NULL;
}

static PyObject *
Bucket_minKey(Bucket *self, PyObject *args)
{
  return Bucket_maxminKey(self, args, 1);
}

static PyObject *
Bucket_maxKey(Bucket *self, PyObject *args)
{
  return Bucket_maxminKey(self, args, 0);
}

static int
Bucket_rangeSearch(Bucket *self, PyObject *args, int *low, int *high)
{
  PyObject *f=0, *l=0;
  int rc;

  if (args &amp;&amp; ! PyArg_ParseTuple(args,"|OO",&amp;f, &amp;l)) return -1;

  UNLESS (self-&gt;len) goto empty;

  /* Find the low range */
  if (f &amp;&amp; f != Py_None)
    {
      UNLESS (rc = Bucket_findRangeEnd(self, f, 1, low))
        {
          if (rc &lt; 0) return -1;
          goto empty;
        }
    }
  else *low = 0;

  /* Find the high range */
  if (l &amp;&amp; l != Py_None)
    {
      UNLESS (rc = Bucket_findRangeEnd(self, l, 0, high))
        {
          if (rc &lt; 0) return -1;
          goto empty;
        }
    }
  else *high = self-&gt;len - 1;

  /* If f &lt; l to begin with, it's quite possible that low &gt; high now. */
  if (*low &lt;= *high)
    return 0;

 empty:
  *low = 0;
  *high = -1;
  return 0;
}

/*
** bucket_keys
**
** Generate a list of all keys in the bucket
**
** Arguments:	self	The Bucket
**		args	(unused)
**
** Returns:	list of bucket keys
*/
static PyObject *
bucket_keys(Bucket *self, PyObject *args)
{
  PyObject *r=0, *key;
  int i, low, high;

  PER_USE_OR_RETURN(self, NULL);

  if (Bucket_rangeSearch(self, args, &amp;low, &amp;high) &lt; 0) goto err;

  UNLESS (r=PyList_New(high-low+1)) goto err;

  for (i=low; i &lt;= high; i++)
    {
      COPY_KEY_TO_OBJECT(key, self-&gt;keys[i]);
      if (PyList_SetItem(r, i-low , key) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(r);
  return NULL;
}

/*
** bucket_values
**
** Generate a list of all values in the bucket
**
** Arguments:	self	The Bucket
**		args	(unused)
**
** Returns	list of values
*/
static PyObject *
bucket_values(Bucket *self, PyObject *args)
{
  PyObject *r=0, *v;
  int i, low, high;

  PER_USE_OR_RETURN(self, NULL);

  if (Bucket_rangeSearch(self, args, &amp;low, &amp;high) &lt; 0) goto err;

  UNLESS (r=PyList_New(high-low+1)) goto err;

  for (i=low; i &lt;= high; i++)
    {
      COPY_VALUE_TO_OBJECT(v, self-&gt;values[i]);
      UNLESS (v) goto err;
      if (PyList_SetItem(r, i-low, v) &lt; 0) goto err;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(r);
  return NULL;
}

/*
** bucket_items
**
** Returns a list of all items in a bucket
**
** Arguments:	self	The Bucket
**		args	(unused)
**
** Returns:	list of all items in the bucket
*/
static PyObject *
bucket_items(Bucket *self, PyObject *args)
{
  PyObject *r=0, *o=0, *item=0;
  int i, low, high;

  PER_USE_OR_RETURN(self, NULL);

  if (Bucket_rangeSearch(self, args, &amp;low, &amp;high) &lt; 0) goto err;

  UNLESS (r=PyList_New(high-low+1)) goto err;

  for (i=low; i &lt;= high; i++)
    {
      UNLESS (item = PyTuple_New(2)) goto err;

      COPY_KEY_TO_OBJECT(o, self-&gt;keys[i]);
      UNLESS (o) goto err;
      PyTuple_SET_ITEM(item, 0, o);

      COPY_VALUE_TO_OBJECT(o, self-&gt;values[i]);
      UNLESS (o) goto err;
      PyTuple_SET_ITEM(item, 1, o);

      if (PyList_SetItem(r, i-low, item) &lt; 0) goto err;

      item = 0;
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(r);
  Py_XDECREF(item);
  return NULL;
}

static PyObject *
bucket_byValue(Bucket *self, PyObject *args)
{
  PyObject *r=0, *o=0, *item=0, *omin;
  VALUE_TYPE min;
  VALUE_TYPE v;
  int i, l, copied=1;

  PER_USE_OR_RETURN(self, NULL);

  UNLESS (PyArg_ParseTuple(args, "O", &amp;omin)) return NULL;
  COPY_VALUE_FROM_ARG(min, omin, copied);
  UNLESS(copied) return NULL;

  for (i=0, l=0; i &lt; self-&gt;len; i++)
    if (TEST_VALUE(self-&gt;values[i], min) &gt;= 0)
      l++;

  UNLESS (r=PyList_New(l)) goto err;

  for (i=0, l=0; i &lt; self-&gt;len; i++)
    {
      if (TEST_VALUE(self-&gt;values[i], min) &lt; 0) continue;

      UNLESS (item = PyTuple_New(2)) goto err;

      COPY_KEY_TO_OBJECT(o, self-&gt;keys[i]);
      UNLESS (o) goto err;
      PyTuple_SET_ITEM(item, 1, o);

      COPY_VALUE(v, self-&gt;values[i]);
      NORMALIZE_VALUE(v, min);
      COPY_VALUE_TO_OBJECT(o, v);
      DECREF_VALUE(v);
      UNLESS (o) goto err;
      PyTuple_SET_ITEM(item, 0, o);

      if (PyList_SetItem(r, l, item) &lt; 0) goto err;
      l++;

      item = 0;
    }

  item=PyObject_GetAttr(r,sort_str);
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_CallObject(item, NULL));
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_GetAttr(r, reverse_str));
  UNLESS (item) goto err;
  ASSIGN(item, PyObject_CallObject(item, NULL));
  UNLESS (item) goto err;
  Py_DECREF(item);

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;

 err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(r);
  Py_XDECREF(item);
  return NULL;
}

static int
_bucket_clear(Bucket *self)
{
    const int len = self-&gt;len;
    /* Don't declare i at this level.  If neither keys nor values are
     * PyObject*, i won't be referenced, and you'll get a nuisance compiler
     * wng for declaring it here.
     */
    self-&gt;len = self-&gt;size = 0;

    if (self-&gt;next) {
        Py_DECREF(self-&gt;next);
        self-&gt;next = NULL;
    }

    /* Silence compiler warning about unused variable len for the case
       when neither key nor value is an object, i.e. II. */
    (void)len;

    if (self-&gt;keys) {
#ifdef KEY_TYPE_IS_PYOBJECT
        int i;
        for (i = 0; i &lt; len; ++i)
            DECREF_KEY(self-&gt;keys[i]);
#endif
        free(self-&gt;keys);
        self-&gt;keys = NULL;
    }

    if (self-&gt;values) {
#ifdef VALUE_TYPE_IS_PYOBJECT
        int i;
        for (i = 0; i &lt; len; ++i)
            DECREF_VALUE(self-&gt;values[i]);
#endif
        free(self-&gt;values);
        self-&gt;values = NULL;
    }
    return 0;
}

#ifdef PERSISTENT
static PyObject *
bucket__p_deactivate(Bucket *self, PyObject *args)
{
  if (self-&gt;state==cPersistent_UPTODATE_STATE &amp;&amp; self-&gt;jar)
    {
      if (_bucket_clear(self) &lt; 0) return NULL;
      PER_GHOSTIFY(self);
    }

  Py_INCREF(Py_None);
  return Py_None;
}
#endif

static PyObject *
bucket_clear(Bucket *self, PyObject *args)
{
  PER_USE_OR_RETURN(self, NULL);

  if (self-&gt;len)
    {
      if (_bucket_clear(self) &lt; 0) return NULL;
      if (PER_CHANGED(self) &lt; 0) goto err;
    }
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_INCREF(Py_None);
  return Py_None;

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return NULL;
}

/*
 * Return:
 *
 * For a set bucket (self-&gt;values is NULL), a one-tuple or two-tuple.  The
 * first element is a tuple of keys, of length self-&gt;len.  The second element
 * is the next bucket, present if and only if next is non-NULL:
 *
 *     (
 *          (keys[0], keys[1], ..., keys[len-1]),
 *          &lt;self-&gt;next iff non-NULL&gt;
 *     )
 *
 * For a mapping bucket (self-&gt;values is not NULL), a one-tuple or two-tuple.
 * The first element is a tuple interleaving keys and values, of length
 * 2 * self-&gt;len.  The second element is the next bucket, present iff next is
 * non-NULL:
 *
 *     (
 *          (keys[0], values[0], keys[1], values[1], ...,
 *                               keys[len-1], values[len-1]),
 *          &lt;self-&gt;next iff non-NULL&gt;
 *     )
 */
static PyObject *
bucket_getstate(Bucket *self, PyObject *args)
{
  PyObject *o=0, *items=0;
  int i, len, l;

  if (args &amp;&amp; ! PyArg_ParseTuple(args, "")) return NULL;

  PER_USE_OR_RETURN(self, NULL);

  len=self-&gt;len;

  if (self-&gt;values)
    {                           /* Bucket */
      UNLESS (items=PyTuple_New(len*2)) goto err;
      for (i=0, l=0; i &lt; len; i++)
        {
          COPY_KEY_TO_OBJECT(o, self-&gt;keys[i]);
          UNLESS (o) goto err;
          PyTuple_SET_ITEM(items, l, o);
          l++;

          COPY_VALUE_TO_OBJECT(o, self-&gt;values[i]);
          UNLESS (o) goto err;
          PyTuple_SET_ITEM(items, l, o);
          l++;
        }
    }
  else
    {                           /* Set */
      UNLESS (items=PyTuple_New(len)) goto err;
      for (i=0; i &lt; len; i++)
        {
          COPY_KEY_TO_OBJECT(o, self-&gt;keys[i]);
          UNLESS (o) goto err;
          PyTuple_SET_ITEM(items, i, o);
        }
    }

  if (self-&gt;next)
    ASSIGN(items, Py_BuildValue("OO", items, self-&gt;next));
  else
    ASSIGN(items, Py_BuildValue("(O)", items));

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return items;

err:
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  Py_XDECREF(items);
  return NULL;
}

static int
_bucket_setstate(Bucket *self, PyObject *args)
{
  PyObject *k, *v, *items;
  Bucket *next=0;
  int i, l, len, copied=1;
  KEY_TYPE *keys;
  VALUE_TYPE *values;

  UNLESS (PyArg_ParseTuple(args, "O|O", &amp;items, &amp;next))
    return -1;

  if ((len=PyTuple_Size(items)) &lt; 0) return -1;
  len /= 2;

  for (i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;keys[i]);
      DECREF_VALUE(self-&gt;values[i]);
    }
  self-&gt;len=0;

  if (self-&gt;next)
    {
      Py_DECREF(self-&gt;next);
      self-&gt;next=0;
    }

  if (len &gt; self-&gt;size)
    {
      UNLESS (keys=PyRealloc(self-&gt;keys, sizeof(KEY_TYPE)*len))
        return -1;
      UNLESS (values=PyRealloc(self-&gt;values, sizeof(VALUE_TYPE)*len))
        return -1;
      self-&gt;keys=keys;
      self-&gt;values=values;
      self-&gt;size=len;
    }

  for (i=0, l=0; i&lt;len; i++)
    {
      k=PyTuple_GET_ITEM(items, l);
      l++;
      v=PyTuple_GET_ITEM(items, l);
      l++;

      COPY_KEY_FROM_ARG(self-&gt;keys[i], k, copied);
      UNLESS (copied) return -1;
      COPY_VALUE_FROM_ARG(self-&gt;values[i], v, copied);
      UNLESS (copied) return -1;
      INCREF_KEY(self-&gt;keys[i]);
      INCREF_VALUE(self-&gt;values[i]);
    }

  self-&gt;len=len;

  if (next)
    {
      self-&gt;next=next;
      Py_INCREF(next);
    }

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return 0;
}

static PyObject *
bucket_setstate(Bucket *self, PyObject *args)
{
  int r;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;args)) return NULL;

  PER_PREVENT_DEACTIVATION(self);
  r=_bucket_setstate(self, args);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  if (r &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

/*
** bucket_has_key
**
*/
static PyObject *
bucket_has_key(Bucket *self, PyObject *args)
{
  PyObject *key;

  UNLESS (PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  return _bucket_get(self, key, 1);
}

/*
** bucket_getm
**
*/
static PyObject *
bucket_getm(Bucket *self, PyObject *args)
{
  PyObject *key, *d=Py_None, *r;

  UNLESS (PyArg_ParseTuple(args, "O|O", &amp;key, &amp;d)) return NULL;
  if ((r=_bucket_get(self, key, 0))) return r;
  UNLESS (PyErr_ExceptionMatches(PyExc_KeyError)) return NULL;
  PyErr_Clear();
  Py_INCREF(d);
  return d;
}

#ifdef PERSISTENT
static PyObject *merge_error(int p1, int p2, int p3, int reason);
static PyObject *bucket_merge(Bucket *s1, Bucket *s2, Bucket *s3);
</t>
<t tx="ekr.20040104185913.1117">static PyObject *
_bucket__p_resolveConflict(PyObject *ob_type, PyObject *s[3])
{
  PyObject *r=0, *a;
  Bucket *b[3];
  int i;

  for (i=0; i &lt; 3; i++)
    {
      if ((b[i]=(Bucket*)PyObject_CallObject(OBJECT(ob_type), NULL)))
        {
          if ((s[i] == Py_None))  /* None is equivalent to empty, for BTrees */
            continue;
          ASSIGN(r, PyObject_GetAttr(OBJECT(b[i]), __setstate___str));
          if ((a=PyTuple_New(1)))
            {
              if (r)
                {
                  PyTuple_SET_ITEM(a, 0, s[i]);
                  Py_INCREF(s[i]);
                  ASSIGN(r, PyObject_CallObject(r, a));
                }
              Py_DECREF(a);
              if (r) continue;
            }
        }
      Py_XDECREF(r);
      while (--i &gt;= 0)
        {
          Py_DECREF(b[i]);
        }
      return NULL;
    }
  Py_DECREF(r);
  r=NULL;

  if (b[0]-&gt;next != b[1]-&gt;next || b[0]-&gt;next != b[2]-&gt;next)
    {
      merge_error(-1, -1, -1, -1);
      goto err;
    }

  r=bucket_merge(b[0], b[1], b[2]);

 err:
  Py_DECREF(b[0]);
  Py_DECREF(b[1]);
  Py_DECREF(b[2]);

  if (r == NULL) {
  	PyObject *error;
  	PyObject *value;
  	PyObject *traceback;

  	PyErr_Fetch(&amp;error, &amp;value, &amp;traceback);
	Py_INCREF(ConflictError);
	Py_XDECREF(error);
	PyErr_Restore(ConflictError, value, traceback);
  }

  return r;
}
</t>
<t tx="ekr.20040104185913.1118">static PyObject *
bucket__p_resolveConflict(Bucket *self, PyObject *args)
{
  PyObject *s[3];

  UNLESS(PyArg_ParseTuple(args, "OOO", &amp;s[0], &amp;s[1], &amp;s[2])) return NULL;

  return _bucket__p_resolveConflict(OBJECT(self-&gt;ob_type), s);
}
</t>
<t tx="ekr.20040104185913.1119">#endif

static struct PyMethodDef Bucket_methods[] = {
  {"__getstate__", (PyCFunction) bucket_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction) bucket_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"keys",	(PyCFunction) bucket_keys,	METH_VARARGS,
     "keys([min, max]) -- Return the keys"},
  {"has_key",	(PyCFunction) bucket_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"clear",	(PyCFunction) bucket_clear,	METH_VARARGS,
   "clear() -- Remove all of the items from the bucket"},
  {"update",	(PyCFunction) Mapping_update,	METH_VARARGS,
   "update(collection) -- Add the items from the given collection"},
  {"__init__",	(PyCFunction) Mapping_update,	METH_VARARGS,
   "__init__(collection) -- Initialize with items from the given collection"},
  {"maxKey", (PyCFunction) Bucket_maxKey,	METH_VARARGS,
   "maxKey([key]) -- Find the maximum key\n\n"
   "If an argument is given, find the maximum &lt;= the argument"},
  {"minKey", (PyCFunction) Bucket_minKey,	METH_VARARGS,
   "minKey([key]) -- Find the minimum key\n\n"
   "If an argument is given, find the minimum &gt;= the argument"},
  {"values",	(PyCFunction) bucket_values,	METH_VARARGS,
     "values([min, max]) -- Return the values"},
  {"items",	(PyCFunction) bucket_items,	METH_VARARGS,
     "items([min, max])) -- Return the items"},
  {"byValue",	(PyCFunction) bucket_byValue,	METH_VARARGS,
   "byValue(min) -- "
   "Return value-keys with values &gt;= min and reverse sorted by values"
  },
  {"get",	(PyCFunction) bucket_getm,	METH_VARARGS,
   "get(key[,default]) -- Look up a value\n\n"
   "Return the default (or None) if the key is not found."
  },
#ifdef PERSISTENT
  {"_p_resolveConflict", (PyCFunction) bucket__p_resolveConflict, METH_VARARGS,
   "_p_resolveConflict() -- Reinitialize from a newly created copy"},
  {"_p_deactivate", (PyCFunction) bucket__p_deactivate, METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
  {NULL,		NULL}		/* sentinel */
};

static void
Bucket_dealloc(Bucket *self)
{
    if (self-&gt;state != cPersistent_GHOST_STATE)
	_bucket_clear(self);

    PER_DEL(self);

    Py_DECREF(self-&gt;ob_type);
    PyObject_Del(self);
}
</t>
<t tx="ekr.20040104185913.1120">@ Code to access Bucket objects as mappings
@c

static int
Bucket_length( Bucket *self)
{
  int r;
  PER_USE_OR_RETURN(self, -1);
  r=self-&gt;len;
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);
  return r;
}
</t>
<t tx="ekr.20040104185913.1121">static PyMappingMethods Bucket_as_mapping = {
  (inquiry)Bucket_length,		/*mp_length*/
  (binaryfunc)bucket_getitem,		/*mp_subscript*/
  (objobjargproc)bucket_setitem,	/*mp_ass_subscript*/
};

static PyObject *
bucket_repr(Bucket *self)
{
  static PyObject *format;
  PyObject *r, *t;

  UNLESS (format) UNLESS (format=PyString_FromString(MOD_NAME_PREFIX "Bucket(%s)"))
    return NULL;
  UNLESS (t=PyTuple_New(1)) return NULL;
  UNLESS (r=bucket_items(self,NULL)) goto err;
  PyTuple_SET_ITEM(t,0,r);
  r=t;
  ASSIGN(r,PyString_Format(format,r));
  return r;
err:
  Py_DECREF(t);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1122">static PyExtensionClass BucketType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  MOD_NAME_PREFIX "Bucket",			/*tp_name*/
  sizeof(Bucket),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /*********** methods ***********************/
  (destructor) Bucket_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc) bucket_repr,	/*tp_repr*/
  0,				/*tp_as_number*/
  0,				/*tp_as_sequence*/
  &amp;Bucket_as_mapping,		/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,		/*tp_getattro*/
  0,				/*tp_setattro*/

  /* Space for future expansion */
  0L,0L,
  "Mapping type implemented as sorted list of items",
  METHOD_CHAIN(Bucket_methods),
  EXTENSIONCLASS_BASICNEW_FLAG
#ifdef PERSISTENT
  | PERSISTENT_TYPE_FLAG
#endif
  | EXTENSIONCLASS_NOINSTDICT_FLAG,
};


static int
nextBucket(SetIteration *i)
{
  if (i-&gt;position &gt;= 0)
    {
      UNLESS(PER_USE(BUCKET(i-&gt;set))) return -1;

      if (i-&gt;position)
        {
          DECREF_KEY(i-&gt;key);
          DECREF_VALUE(i-&gt;value);
        }

      if (i-&gt;position &lt; BUCKET(i-&gt;set)-&gt;len)
        {
          COPY_KEY(i-&gt;key, BUCKET(i-&gt;set)-&gt;keys[i-&gt;position]);
          INCREF_KEY(i-&gt;key);
          COPY_VALUE(i-&gt;value, BUCKET(i-&gt;set)-&gt;values[i-&gt;position]);
          INCREF_VALUE(i-&gt;value);
          i-&gt;position ++;
        }
      else
        {
          i-&gt;position = -1;
          PER_ACCESSED(BUCKET(i-&gt;set));
        }

      PER_ALLOW_DEACTIVATION(BUCKET(i-&gt;set));
    }


  return 0;
}
</t>
<t tx="ekr.20040104185913.1123">&lt;&lt; copyright &gt;&gt;

# hack to overcome dynamic-linking headache.
from _IIBTree import *

# We don't really want _ names in pickles, so update all of the __module__
# references.
##for o in globals().values():
##    if hasattr(o, '__module__'):
##        o.__module__=__name__
</t>
<t tx="ekr.20040104185913.1124">&lt;&lt; copyright &gt;&gt;

# hack to overcome dynamic-linking headache.
from _IOBTree import *

# We don't really want _ names in pickles, so update all of the __module__
# references.
##for o in globals().values():
##    if hasattr(o, '__module__'):
##        o.__module__=__name__
</t>
<t tx="ekr.20040104185913.1125">&lt;&lt; Interfaces declarations &gt;&gt;

@others

# IMPORTANT NOTE
#
# Getting the length of a BTree, TreeSet, or output of keys,
# values, or items of same is expensive. If you need to get the
# length, you need to maintain this separately.
#
# Eventually, I need to express this through the interfaces.

OOBTree.OOSet.__implements__=ISet
OOBTree.OOTreeSet.__implements__=ITreeSet
OOBTree.OOBucket.__implements__=IDictionaryIsh
OOBTree.OOBTree.__implements__=IBTree
</t>
<t tx="ekr.20040104185913.1126">&lt;&lt; copyright &gt;&gt;

import OOBTree, Interface
from Interface import Interface

</t>
<t tx="ekr.20040104185913.1127">class ICollection(Interface):
	@others
</t>
<t tx="ekr.20040104185913.1128">def clear():
    """Remove all of the items from the collection"""
</t>
<t tx="ekr.20040104185913.1129">def __nonzero__():
    """Check if the collection is non-empty.

    Return a true value if the collection is non-empty and a
    false otherwise.
    """
</t>
<t tx="ekr.20040104185913.1130">class IReadSequence(Interface):
	@others
</t>
<t tx="ekr.20040104185913.1131">def __getitem__(index):
    """Return a value at the givem index

    An IndexError is raised if the index cannot be found.
    """
</t>
<t tx="ekr.20040104185913.1132">def __getslice__(index1, index2):
    """Return a subsequence from the original sequence

    Such that the subsequence includes the items from index1 up
    to, but not including, index2.
    """
</t>
<t tx="ekr.20040104185913.1133">class IKeyed(ICollection):
	@others
</t>
<t tx="ekr.20040104185913.1134">def has_key(key):
    """Check whether the object has an item with the given key"""
</t>
<t tx="ekr.20040104185913.1135">def keys(min=None, max=None):
    """Return an IReadSequence containing the keys in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.

    If a min is specified, then output is constrained to
    items having keys greater than or equal to the given min.
    A min value of None is ignored.

    If a max is specified, then output is constrained to
    items having keys less than or equal to the given min.
    A max value of None is ignored.
    """
</t>
<t tx="ekr.20040104185913.1136">def maxKey(key=None):
    """Return the maximum key

    If a key argument if provided, return the largest key that is
    less than or equal to the argument.
    """
</t>
<t tx="ekr.20040104185913.1137">def minKey(key=None):
    """Return the minimum key

    If a key argument if provided, return the smallest key that is
    greater than or equal to the argument.
    """
</t>
<t tx="ekr.20040104185913.1138">class ISetMutable(IKeyed):
	@others
</t>
<t tx="ekr.20040104185913.1139">def insert(key):
    """Add the key (value) to the set.

    If the key was already in the set, return 0, otherwise return 1.
    """
</t>
<t tx="ekr.20040104185913.1140">def remove(key):
    """Remove the key from the set."""
</t>
<t tx="ekr.20040104185913.1141">def update(seq):
    """Add the items from the given sequence to the set"""
</t>
<t tx="ekr.20040104185913.1142">class ISized(Interface):
	&lt;&lt; class ISized declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1143">"anything supporting __len"

</t>
<t tx="ekr.20040104185913.1144">def __len__():
    """Return the number of items in the container"""
</t>
<t tx="ekr.20040104185913.1145">class IKeySequence(IKeyed, ISized):
	@others
</t>
<t tx="ekr.20040104185913.1146">def __getitem__(index):
    """Return the key in the given index position

    This allows iteration with for loops and use in functions,
    like map and list, that read sequences.
    """
</t>
<t tx="ekr.20040104185913.1147">class ISet(IKeySequence, ISetMutable):
	&lt;&lt; class ISet declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1148">pass

</t>
<t tx="ekr.20040104185913.1149">class ITreeSet(IKeyed, ISetMutable):
	&lt;&lt; class ITreeSet declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1150">pass

</t>
<t tx="ekr.20040104185913.1151">class IMinimalDictionary(ISized):
	@others
</t>
<t tx="ekr.20040104185913.1152">def has_key(key):
    """Check whether the object has an item with the given key"""
</t>
<t tx="ekr.20040104185913.1153">def get(key, default):
    """Get the value for the given key

    Return the default if the key is not in the  collection.
    """
</t>
<t tx="ekr.20040104185913.1154">def __setitem__(key, value):
    """Set the value for the given key"""
</t>
<t tx="ekr.20040104185913.1155">def __delitem__(key):
    """delete the value for the given key

    Raise a key error if the key if not in the collection."""
</t>
<t tx="ekr.20040104185913.1156">def values():
    """Return a IReadSequence containing the values in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.1157">def keys():
    """Return an Sequence containing the keys in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.1158">def items():
    """Return a IReadSequence containing the items in the collection

    An item is a key-value tuple.

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.1159">class IDictionaryIsh(IKeyed, IMinimalDictionary):
	@others
</t>
<t tx="ekr.20040104185913.1160">def update(collection):
    """Add the items from the given collection object to the collection

    The input collection must be a sequence of key-value tuples,
    or an object with an 'items' method that returns a sequence of
    key-value tuples.
    """
</t>
<t tx="ekr.20040104185913.1161">def values(min=None, max=None):
    """Return a IReadSequence containing the values in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.

    If a min is specified, then output is constrained to
    items having keys greater than or equal to the given min.
    A min value of None is ignored.

    If a max is specified, then output is constrained to
    items having keys less than or equal to the given min.
    A max value of None is ignored.
    """
</t>
<t tx="ekr.20040104185913.1162">def items(min=None, max=None):
    """Return a IReadSequence containing the items in the collection

    An item is a key-value tuple.

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.

    If a min is specified, then output is constrained to
    items having keys greater than or equal to the given min.
    A min value of None is ignored.

    If a max is specified, then output is constrained to
    items having keys less than or equal to the given min.
    A max value of None is ignored.
    """
</t>
<t tx="ekr.20040104185913.1163">def byValue(minValue):
    """Return a sequence of value-key pairs, sorted by value

    Values &lt; min are ommitted and other values are "normalized" by
    the minimum value. This normalization may be a noop, but, for
    integer values, the normalization is division.
    """
</t>
<t tx="ekr.20040104185913.1164">class IBTree(IDictionaryIsh):
	@others
</t>
<t tx="ekr.20040104185913.1165">def insert(key, value):
    """Insert a key and value into the collection.

    If the key was already in the collection, then there is no
    change and 0 is returned.

    If the key was not already in the collection, then the item is
    added and 1 is returned.

    This method is here to allow one to generate random keys and
    to insert and test whether the key was there in one operation.

    A standard idiom for generating new keys will be::

      key=generate_key()
      while not t.insert(key, value):
          key=generate_key()
    """
</t>
<t tx="ekr.20040104185913.1166">class IMerge(Interface):
    """Object with methods for merging sets, buckets, and trees.

    These methods are supplied in modules that define collection
    classes with particular key and value types. The operations apply
    only to collections from the same module.  For example, the
    IIBTree.union can only be used with IIBTree.IIBTree,
    IIBTree.IIBucket, IIBTree.IISet, and IIBTree.IITreeSet.

    The implementing module has a value type. The IOBTree and OOBTree
    modules have object value type. The IIBTree and OIBTree modules
    have integer value tyoes. Other modules may be defined in the
    future that have other value types.

    The individual types are classified into set (Set and TreeSet) and
    mapping (Bucket and BTree) types.
    """
	@others
</t>
<t tx="ekr.20040104185913.1167">def difference(c1, c2):
    """Return the keys or items in c1 for which there is no key in
    c2.

    If c1 is None, then None is returned.  If c2 is None, then c1
    is returned.

    If neither c1 nor c2 is None, the output is a Set if c1 is a Set or
    TreeSet, and is a Bucket if c1 is a Bucket or BTree.
    """
</t>
<t tx="ekr.20040104185913.1168">def union(c1, c2):
    """Compute the Union of c1 and c2.

    If c1 is None, then c2 is returned, otherwise, if c2 is None,
    then c1 is returned.

    The output is a Set containing keys from the input
    collections.
    """
</t>
<t tx="ekr.20040104185913.1169">def intersection(c1, c2):
    """Compute the intersection of c1 and c2.

    If c1 is None, then c2 is returned, otherwise, if c2 is None,
    then c1 is returned.

    The output is a Set containing matching keys from the input
    collections.
    """
</t>
<t tx="ekr.20040104185913.1170">class IIMerge(IMerge):
    """Merge collections with integer value type.

    A primary intent is to support operations with no or integer
    values, which are used as "scores" to rate indiviual keys. That
    is, in this context, a BTree or Bucket is viewed as a set with
    scored keys, using integer scores.
    """
	@others
</t>
<t tx="ekr.20040104185913.1171">def weightedUnion(c1, c2, weight1=1, weight2=1):
    """Compute the weighted union of c1 and c2.

    If c1 and c2 are None, the output is (0, None).

    If c1 is None and c2 is not None, the output is (weight2, c2).

    If c1 is not None and c2 is None, the output is (weight1, c1).

    Else, and hereafter, c1 is not None and c2 is not None.

    If c1 and c2 are both sets, the output is 1 and the (unweighted)
    union of the sets.

    Else the output is 1 and a Bucket whose keys are the union of c1 and
    c2's keys, and whose values are::

      v1*weight1 + v2*weight2

      where:

        v1 is 0        if the key is not in c1
              1        if the key is in c1 and c1 is a set
              c1[key]  if the key is in c1 and c1 is a mapping

        v2 is 0        if the key is not in c2
              1        if the key is in c2 and c2 is a set
              c2[key]  if the key is in c2 and c2 is a mapping

    Note that c1 and c2 must be collections.

    """
</t>
<t tx="ekr.20040104185913.1172">def weightedIntersection(c1, c2, weight1=1, weight2=1):
    """Compute the weighted intersection of c1 and c2.

    If c1 and c2 are None, the output is (0, None).

    If c1 is None and c2 is not None, the output is (weight2, c2).

    If c1 is not None and c2 is None, the output is (weight1, c1).

    Else, and hereafter, c1 is not None and c2 is not None.

    If c1 and c2 are both sets, the output is the sum of the weights
    and the (unweighted) intersection of the sets.

    Else the output is 1 and a Bucket whose keys are the intersection of
    c1 and c2's keys, and whose values are::

      v1*weight1 + v2*weight2

      where:

        v1 is 1        if c1 is a set
              c1[key]  if c1 is a mapping

        v2 is 1        if c2 is a set
              c2[key]  if c2 is a mapping

    Note that c1 and c2 must be collections.
    """
</t>
<t tx="ekr.20040104185913.1173">&lt;&lt; copyright &gt;&gt;

import Persistence

@others
</t>
<t tx="ekr.20040104185913.1175">class Length(Persistence.Persistent):
    """BTree lengths are too expensive to compute

    Objects that use BTrees need to keep track of lengths themselves.
    This class provides an object for doing this.

    As a bonus, the object support application-level conflict resolution.
    """
	@others
</t>
<t tx="ekr.20040104185913.1176">def __init__(self, v=0): self.value=v
</t>
<t tx="ekr.20040104185913.1177">def __getstate__(self): return self.value
</t>
<t tx="ekr.20040104185913.1178">def __setstate__(self, v): self.value=v
</t>
<t tx="ekr.20040104185913.1179">def set(self, v): self.value=v
</t>
<t tx="ekr.20040104185913.1180">def _p_resolveConflict(self, old, s1, s2): return s1 + s2 - old
</t>
<t tx="ekr.20040104185913.1181">def _p_independent(self):
    # My state doesn't depend on or materially effect the state of
    # other objects.
    return 1
</t>
<t tx="ekr.20040104185913.1182">def change(self, delta): self.value = self.value + delta
</t>
<t tx="ekr.20040104185913.1183">def __call__(self, *args): return self.value
</t>
<t tx="ekr.20040104185913.1184">@nocolor

This document provides information for developers who maintain or
extend BTrees.

Macros
======
BTrees are defined using a "template", roughly akin to a a C++
template.  To create a new family of BTrees, create a source file that
defines macros used to handle differences in key and value types:


Configuration Macros

MASTER_ID
A string to hold an RCS/CVS Id key to be included in compiled binaries.

MOD_NAME_PREFIX
A string (like "IO" or "OO") that provides the prefix used for the
module.  This gets used to generate type names and the internal module
name string.

DEFAULT_MAX_BUCKET_SIZE
An int giving the maximum bucket size (number of key/value pairs).
When a bucket gets larger than this due to an insertion *into a BTREE*,
it splits.  Inserting into a bucket directly doesn't split, and
functions that produce a bucket output (e.g., union()) also have no
bound on how large a bucket may get.  Someday this will be tunable
on BTree instances.

DEFAULT_MAX_BTREE_SIZE
An int giving the maximum size (number of children) of an internal
btree node.  Someday this will be tunable on BTree instances.

Macros for Keys

KEY_TYPE
The C type declaration for keys (e.g., int or PyObject*).

KEY_TYPE_IS_PYOBJECT
Define if KEY_TYPE is a PyObject*, else undef.

KEY_CHECK(K)
Tests whether the PyObject* K can be converted to the (C) key type
(KEY_TYPE).  The macro should return a boolean (zero for false,
non-zero for true).  When it returns false, its caller should probably
set a TypeError exception.

TEST_KEY_SET_OR(V, K, T)
Like Python's cmp().  Compares K(ey) to T(arget), where K &amp; T are C
values of type KEY_TYPE.  V is assigned an int value depending on
the outcome:
   &lt; 0 if K &lt; T
  == 0 if K == T
   &gt; 0 if K &gt; T
This macro acts like an 'if', where the following statement is
executed only if a Python exception has been raised because the
values could not be compared.

DECREF_KEY(K)
K is a value of KEY_TYPE.  If KEY_TYPE is a flavor of PyObject*, write
this to do Py_DECREF(K).  Else (e.g., KEY_TYPE is int) make it a nop.

INCREF_KEY(K)
K is a value of KEY_TYPE.  If KEY_TYPE is a flavor of PyObject*, write
this to do Py_INCREF(K).  Else (e.g., KEY_TYPE is int) make it a nop.

COPY_KEY(K, E)
Like K=E.  Copy a key from E to K, both of KEY_TYPE.  Note that this
doesn't decref K or incref E when KEY_TYPE is a PyObject*; the caller
is responsible for keeping refcounts straight.

COPY_KEY_TO_OBJECT(O, K)
Roughly like O=K.  O is a PyObject*, and the macro must build a Python
object form of K, assign it to O, and ensure that O owns the reference
to its new value.  It may do this by creating a new Python object based
on K (e.g., PyInt_FromLong(K) when KEY_TYPE is int), or simply by doing
Py_INCREF(K) if KEY_TYPE is a PyObject*.

COPY_KEY_FROM_ARG(TARGET, ARG, STATUS)
Copy an argument to the target without creating a new reference to ARG.
ARG is a PyObject*, and TARGET is of type KEY_TYPE.  If this can't be
done (for example, KEY_CHECK(ARG) returns false), set a Python error
and set status to 0.  If there is no error, leave status alone.


Macros for Values

VALUE_TYPE
The C type declaration for values (e.g., int or PyObject*).

VALUE_TYPE_IS_PYOBJECT
Define if VALUE_TYPE is a PyObject*, else undef.

TEST_VALUE(X, Y)
Like Python's cmp().  Compares X to Y, where X &amp; Y are C values of
type VALUE_TYPE.  The macro returns an int, with value
   &lt; 0 if X &lt; Y
  == 0 if X == Y
   &gt; 0 if X &gt; Y
XXX There is no provision for determining whether the comparison
attempt failed (set a Python exception).

DECREF_VALUE(K)
Like DECREF_KEY, except applied to values of VALUE_TYPE.

INCREF_VALUE(K)
Like INCREF_KEY, except applied to values of VALUE_TYPE.

COPY_VALUE(K, E)
Like COPY_KEY, except applied to values of VALUE_TYPE.

COPY_VALUE_TO_OBJECT(O, K)
Like COPY_KEY_TO_OBJECT, except applied to values of VALUE_TYPE.

COPY_VALUE_FROM_ARG(TARGET, ARG, STATUS)
Like COPY_KEY_FROM_ARG, except applied to values of VALUE_TYPE.

NORMALIZE_VALUE(V, MIN)
Normalize the value, V, using the parameter MIN.  This is almost
certainly a YAGNI.  It is a no op for most types. For integers, V is
replaced by V/MIN only if MIN &gt; 0.


Macros for Set Operations

MERGE_DEFAULT
A value of VALUE_TYPE specifying the value to associate with set
elements when sets are merged with mappings via weighed union or
weighted intersection.

MERGE(O1, w1, O2, w2)
Performs a weighted merge of two values, O1 and O2, using weights w1
and w2.  The result must be of VALUE_TYPE.  Note that weighted unions
and weighted intersections are not enabled if this macro is left
undefined.

MERGE_WEIGHT(O, w)
Computes a weighted value for O.  The result must be of VALUE_TYPE.
This is used for "filling out" weighted unions, i.e. to compute a
weighted value for keys that appear in only one of the input
mappings.  If left undefined, MERGE_WEIGHT defaults to

    #define MERGE_WEIGHT(O, w) (O)

MULTI_INT_UNION
The value doesn't matter.  If defined, SetOpTemplate.c compiles
code for a multiunion() function (compute a union of many input sets
at high speed).  This currently makes sense only for structures with
integer keys.


BTree Clues
===========
More or less random bits of helpful info.

+ In papers and textbooks, this flavor of BTree is usually called
  a B+-Tree, where "+" is a superscript.

+ All keys and all values live in the bucket leaf nodes.  Keys in
  interior (BTree) nodes merely serve to guide a search efficiently
  toward the correct leaf.

+ When a key is deleted, it's physically removed from the bucket
  it's in, but this doesn't propagate back up the tree:  since keys
  in interior nodes only serve to guide searches, it's OK-- and
  saves time --to leave "stale" keys in interior nodes.

+ No attempt is made to rebalance the tree after a deletion, unless
  a bucket thereby becomes entirely empty.  "Classic BTrees" do
  rebalance, keeping all buckets at least half full (provided there
  are enough keys in the entire tree to fill half a bucket).  The
  tradeoffs are murky.  Pathological cases in the presence of
  deletion do exist.  Pathologies include trees tending toward only
  one key per bucket, and buckets at differing depths (all buckets
  are at the same depth in a classic BTree).

+ DEFAULT_MAX_BUCKET_SIZE and DEFAULT_MAX_BTREE_SIZE are chosen
  mostly to "even out" pickle sizes in storage.  That's why, e.g.,
  an IIBTree has larger values than an OOBTree:  pickles store ints
  more efficiently than they can store arbitrary Python objects.

+ In a non-empty BTree, every bucket node contains at least one key,
  and every BTree node contains at least one child and a non-NULL
  firstbucket pointer.  However, a BTree node may not contain any keys.

+ An empty BTree consists solely of a BTree node with len==0 and
  firstbucket==NULL.

+ Although a BTree can become unbalanced under a mix of inserts and
  deletes (meaning both that there's nothing stronger that can be
  said about buckets than that they're not empty, and that buckets
  can appear at different depths), a BTree node always has children
  of the same kind:  they're all buckets, or they're all BTree nodes.


The BTREE_SEARCH Macro
======================
For notational ease, consider a fixed BTree node x, and let

    K(i) mean x-&gt;data.key[i]
    C(i) mean all the keys reachable from x-&gt;data.child[i]

For each i in 0 to x-&gt;len-1 inclusive,

    K(i) &lt;= C(i) &lt; K(i+1)

is a BTree node invariant, where we pretend that K(0) holds a key
smaller than any possible key, and K(x-&gt;len) holds a key larger
than any possible key.  (Note that K(x-&gt;len) doesn't actually exist,
and K(0) is never used although space for it exists in non-empty
BTree nodes.)

When searching for a key k, then, the child pointer we want to follow
is the one at index i such that K(i) &lt;= k &lt; K(i+1).  There can be
at most one such i, since the K(i) are strictly increasing.  And there
is at least one such i provided the tree isn't empty (so that 0 &lt; len).
For the moment, assume the tree isn't empty (we'll get back to that
later).

The macro's chief loop invariant is

    K(lo) &lt; k &lt; K(hi)

This holds trivially at the start, since lo is set to 0, and hi to
x-&gt;len, and we pretend K(0) is minus infinity and K(len) is plus
infinity.  Inside the loop, if K(i) &lt; k we set lo to i, and if
K(i) &gt; k we set hi to i.  These obviously preserve the invariant.
If K(i) == k, the loop breaks and sets the result to i, and since
K(i) == k in that case i is obviously the correct result.

Other cases depend on how i = floor((lo + hi)/2) works, exactly.
Suppose lo + d = hi for some d &gt;= 0.  Then i = floor((lo + lo + d)/2) =
floor(lo + d/2) = lo + floor(d/2).  So:

a. [d == 0] (lo == i == hi) if and only if (lo   == hi).
b. [d == 1] (lo == i  &lt; hi) if and only if (lo+1 == hi).
c. [d  &gt; 1] (lo  &lt; i  &lt; hi) if and only if (lo+1  &lt; hi).

If the node is empty (x-&gt;len == 0), then lo==i==hi==0 at the start,
and the loop exits immediately (the first "i &gt; lo" test fails),
without entering the body.

Else lo &lt; hi at the start, and the invariant K(lo) &lt; k &lt; K(hi) holds.

If lo+1 &lt; hi, we're in case #c:  i is strictly between lo and hi,
so the loop body is entered, and regardless of whether the body sets
the new lo or the new hi to i, the new lo is strictly less than the
new hi, and the difference between the new lo and new hi is strictly
less than the difference between the old lo and old hi.  So long as
the new lo + 1 remains &lt; the new hi, we stay in this case.  We can't
stay in this case forever, though:  because hi-lo decreases on each
trip but remains &gt; 0, lo+1 == hi must eventually become true.  (In
fact, it becomes true quickly, in about log2(x-&gt;len) trips; the
point is more that lo doesn't equal hi when the loop ends, it has to
end with lo+1==hi and i==lo).

Then we're in case #b:  i==lo==hi-1 then, and the loop exits.  The
invariant still holds, with lo==i and hi==lo+1==i+1:

    K(i) &lt; k &lt; K(i+1)

so i is again the correct answer.

Optimization points:

+ Division by 2 is done via shift rather via "/2".  These are
  signed ints, and almost all C compilers treat signed int division
  as truncating, and shifting is not the same as truncation for
  signed int division.  The compiler has no way to know these values
  aren't negative, so has to generate longer-winded code for "/2".
  But we know these values aren't negative, and exploit it.

+ The order of _cmp comparisons matters.  We're in an interior
  BTree node, and are looking at only a tiny fraction of all the
  keys that exist.  So finding the key exactly in this node is
  unlikely, and checking _cmp == 0 is a waste of time to the same
  extent.  It doesn't matter whether we check for _cmp &lt; 0 or
  _cmp &gt; 0 first, so long as we do both before worrying about
  equality.

+ At the start of a routine, it's better to run this macro even
  if x-&gt;len is 0 (check for that afterwards).  We just called a
  function and so probably drained the pipeline.  If the first thing
  we do then is read up self-&gt;len and check it against 0, we just
  sit there waiting for the data to get read up, and then another
  immediate test-and-branch, and for a very unlikely case (BTree
  nodes are rarely empty).  It's better to get into the loop right
  away so the normal case makes progress ASAP.


The BUCKET_SEARCH Macro
=======================
This has a different job than BTREE_SEARCH:  the key 0 slot is
legitimate in a bucket, and we want to find the index at which the
key belongs.  If the key is larger than the bucket's largest key, a
new slot at index len is where it belongs, else it belongs at the
smallest i with keys[i] &gt;= the key we're looking for.  We also need
to know whether or not the key is present (BTREE_SEARCH didn't care;
it only wanted to find the next node to search).

The mechanics of the search are quite similar, though.  The primary
loop invariant changes to (say we're searching for key k):

    K(lo-1) &lt; k &lt; K(hi)

where K(i) means keys[i], and we pretend K(-1) is minus infinity and
K(len) is plus infinity.

If the bucket is empty, lo=hi=i=0 at the start, the loop body is never
entered, and the macro sets INDEX to 0 and ABSENT to true.  That's why
_cmp is initialized to 1 (_cmp becomes ABSENT).

Else the bucket is not empty, lo&lt;hi at the start, and the loop body
is entered.  The invariant is obviously satisfied then, as lo=0 and
hi=len.

If K[i]&lt;k, lo is set to i+1, preserving that K(lo-1) = K[i] &lt; k.
If K[i]&gt;k, hi is set to i, preserving that K[hi] = K[i] &gt; k.
If the loop exits after either of those, _cmp != 0, so ABSENT becomes
true.
If K[i]=k, the loop breaks, so that INDEX becomes i, and ABSENT
becomes false (_cmp=0 in this case).

The same case analysis for BTREE_SEARCH on lo and hi holds here:

a. (lo == i == hi) if and only if (lo   == hi).
b. (lo == i  &lt; hi) if and only if (lo+1 == hi).
c. (lo  &lt; i  &lt; hi) if and only if (lo+1  &lt; hi).

So long as lo+1 &lt; hi, we're in case #c, and either break with
equality (in which case the right results are obviously computed) or
narrow the range.  If equality doesn't obtain, the range eventually
narrows to cases #a or #b.

To go from #c to #a, we must have lo+2==hi at the start, and
K[i]=K[lo+1]&lt;k.  Then the new lo gets set to i+1 = lo+2 = hi, and the
loop exits with lo=hi=i and _cmp&lt;0.  This is correct, because we
know that k != K(i) (loop invariant! we actually know something
stronger, that k &lt; K(hi); since i=hi, this implies k != K(i)).

Else #c eventually falls into case #b, lo+1==hi and i==lo.  The
invariant tells us K(lo-1) &lt; k &lt; K(hi) = K(lo+1), so if the key
is present it must be at K(lo).  i==lo in this case, so we test
K(lo) against k.  As always, if equality obtains we do the right
thing, else case #b becomes case #a.

When #b becomes #a, the last comparison was non-equal, so _cmp is
non-zero, and the loop exits because lo==hi==i in case #a.  The
invariant then tells us K(lo-1) &lt; k &lt; K(lo), so the key is in fact
not present, it's correct to exit with _cmp non-zero, and i==lo is
again the index at which k belongs.

Optimization points:

+ As for BTREE_SEARCH, shifting of signed ints is cheaper than
  division.

+ Unlike as for BTREE_SEARCH, there's nothing special about searching
  an empty bucket, and the macro computes thoroughly sensible results
  in that case.

+ The order of _cmp comparisons differs from BTREE_SEARCH.  When
  searching a bucket, it's much more likely (than when searching a
  BTree node) that the key is present, so testing __cmp==0 isn't a
  systematic waste of cycles.  At the extreme, if all searches are
  successful (key present), on average this saves one comparison per
  search, against leaving the determination of _cmp==0 implicit (as
  BTREE_SEARCH does).  But even on successful searches, __cmp != 0 is
  a more popular outcome than __cmp == 0 across iterations (unless
  the bucket has only a few keys), so it's important to check one
  of the inequality cases first.  It turns out it's better on average
  to check K(i) &lt; key (than to check K(i) &gt; key), because when it
  pays it narrows the range more (we get a little boost from setting
  lo=i+1 in this case; the other case sets hi=i, which isn't as much
  of a narrowing).
</t>
<t tx="ekr.20040104185913.1185">@language c
&lt;&lt; c copyright &gt;&gt;

#define MERGETEMPLATE_C "$Id: MergeTemplate.c,v 1.15.10.2 2003/01/30 23:25:09 bwarsaw Exp $\n"

/****************************************************************************
 Set operations
 ****************************************************************************/

static int
merge_output(Bucket *r, SetIteration *i, int mapping)
{
  if(r-&gt;len &gt;= r-&gt;size &amp;&amp; Bucket_grow(r, -1, ! mapping) &lt; 0) return -1;
  COPY_KEY(r-&gt;keys[r-&gt;len], i-&gt;key);
  INCREF_KEY(r-&gt;keys[r-&gt;len]);
  if (mapping)
    {
      COPY_VALUE(r-&gt;values[r-&gt;len], i-&gt;value);
      INCREF_VALUE(r-&gt;values[r-&gt;len]);
    }
  r-&gt;len++;
  return 0;
}

static PyObject *
merge_error(int p1, int p2, int p3, int reason)
{
  PyObject *r;

  UNLESS (r=Py_BuildValue("iiii", p1, p2, p3, reason)) r=Py_None;
  if (ConflictError == NULL) {
  	ConflictError=PyExc_ValueError;
	Py_INCREF(ConflictError);
  }
  PyErr_SetObject(ConflictError, r);
  if (r != Py_None)
    {
      Py_DECREF(r);
    }

  return NULL;
}

static PyObject *
bucket_merge(Bucket *s1, Bucket *s2, Bucket *s3)
{
  Bucket *r=0;
  PyObject *s;
  SetIteration i1 = {0,0,0}, i2 = {0,0,0}, i3 = {0,0,0};
  int cmp12, cmp13, cmp23, mapping, set;

  if (initSetIteration(&amp;i1, OBJECT(s1), 1) &lt; 0) goto err;
  if (initSetIteration(&amp;i2, OBJECT(s2), 1) &lt; 0) goto err;
  if (initSetIteration(&amp;i3, OBJECT(s3), 1) &lt; 0) goto err;

  mapping = i1.usesValue | i2.usesValue | i3.usesValue;
  set = ! mapping;

  if (mapping)
    {
      UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(&amp;BucketType), NULL)))
        goto err;
    }
  else
    {
      UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(&amp;SetType), NULL)))
        goto err;
    }

  if (i1.next(&amp;i1) &lt; 0) goto err;
  if (i2.next(&amp;i2) &lt; 0) goto err;
  if (i3.next(&amp;i3) &lt; 0) goto err;

  while (i1.position &gt;= 0 &amp;&amp; i2.position &gt;= 0 &amp;&amp; i3.position &gt;= 0)
    {
      TEST_KEY_SET_OR(cmp12, i1.key, i2.key) goto err;
      TEST_KEY_SET_OR(cmp13, i1.key, i3.key) goto err;
      if (cmp12==0)
        {
          if (cmp13==0)
            {
              if (set || (TEST_VALUE(i1.value, i2.value) == 0))
                {               /* change in i3 or all same */
                  if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
                }
              else if (set || (TEST_VALUE(i1.value, i3.value) == 0))
                {               /* change in i2 */
                  if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
                }
              else
                {               /* conflicting changes in i2 and i3 */
                  merge_error(i1.position, i2.position, i3.position, 1);
                  goto err;
                }
              if (i1.next(&amp;i1) &lt; 0) goto err;
              if (i2.next(&amp;i2) &lt; 0) goto err;
              if (i3.next(&amp;i3) &lt; 0) goto err;
            }
          else if (cmp13 &gt; 0)
            {                   /* insert i3 */
              if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
              if (i3.next(&amp;i3) &lt; 0) goto err;
            }
          else if (set || (TEST_VALUE(i1.value, i2.value) == 0))
            {                   /* delete i3 */
              if (i1.next(&amp;i1) &lt; 0) goto err;
              if (i2.next(&amp;i2) &lt; 0) goto err;
            }
          else
            {                   /* conflicting del in i3 and change in i2 */
              merge_error(i1.position, i2.position, i3.position, 2);
              goto err;
            }
        }
      else if (cmp13 == 0)
        {
          if (cmp12 &gt; 0)
            {                   /* insert i2 */
              if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
              if (i2.next(&amp;i2) &lt; 0) goto err;
            }
          else if (set || (TEST_VALUE(i1.value, i3.value) == 0))
            {                   /* delete i2 */
              if (i1.next(&amp;i1) &lt; 0) goto err;
              if (i3.next(&amp;i3) &lt; 0) goto err;
            }
          else
            {                   /* conflicting del in i2 and change in i3 */
              merge_error(i1.position, i2.position, i3.position, 3);
              goto err;
            }
        }
      else
        {                       /* Both keys changed */
          TEST_KEY_SET_OR(cmp23, i2.key, i3.key) goto err;
          if (cmp23==0)
            {                   /* dualing inserts or deletes */
              merge_error(i1.position, i2.position, i3.position, 4);
              goto err;
            }
          if (cmp12 &gt; 0)
            {                   /* insert i2 */
              if (cmp23 &gt; 0)
                {               /* insert i3 first */
                  if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
                  if (i3.next(&amp;i3) &lt; 0) goto err;
                }
              else
                {               /* insert i2 first */
                  if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
                  if (i2.next(&amp;i2) &lt; 0) goto err;
                }
            }
          else if (cmp13 &gt; 0)
            {                   /* Insert i3 */
              if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
              if (i3.next(&amp;i3) &lt; 0) goto err;
            }
          else
            {                   /* Dueling deletes */
              merge_error(i1.position, i2.position, i3.position, 5);
              goto err;
            }
        }
    }

  while (i2.position &gt;= 0 &amp;&amp; i3.position &gt;= 0)
    {                           /* New inserts */
      TEST_KEY_SET_OR(cmp23, i2.key, i3.key) goto err;
      if (cmp23==0)
        {                       /* dualing inserts */
          merge_error(i1.position, i2.position, i3.position, 6);
          goto err;
        }
      if (cmp23 &gt; 0)
        {                       /* insert i3 */
          if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
          if (i3.next(&amp;i3) &lt; 0) goto err;
        }
      else
        {                       /* insert i2 */
          if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
          if (i2.next(&amp;i2) &lt; 0) goto err;
        }
    }

  while (i1.position &gt;= 0 &amp;&amp; i2.position &gt;= 0)
    {                           /* deleting i3 */
      TEST_KEY_SET_OR(cmp12, i1.key, i2.key) goto err;
      if (cmp12 &gt; 0)
        {                       /* insert i2 */
          if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
          if (i2.next(&amp;i2) &lt; 0) goto err;
        }
      else if (cmp12==0 &amp;&amp; (set || (TEST_VALUE(i1.value, i2.value) == 0)))
        {                       /* delete i3 */
          if (i1.next(&amp;i1) &lt; 0) goto err;
          if (i2.next(&amp;i2) &lt; 0) goto err;
        }
      else
        {                       /* Dualing deletes or delete and change */
          merge_error(i1.position, i2.position, i3.position, 7);
          goto err;
        }
    }

  while (i1.position &gt;= 0 &amp;&amp; i3.position &gt;= 0)
    {                           /* deleting i2 */
      TEST_KEY_SET_OR(cmp13, i1.key, i3.key) goto err;
      if (cmp13 &gt; 0)
        {                       /* insert i3 */
          if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
          if (i3.next(&amp;i3) &lt; 0) goto err;
        }
      else if (cmp13==0 &amp;&amp; (set || (TEST_VALUE(i1.value, i3.value) == 0)))
        {                       /* delete i2 */
          if (i1.next(&amp;i1) &lt; 0) goto err;
          if (i3.next(&amp;i3) &lt; 0) goto err;
        }
      else
        {                       /* Dualing deletes or delete and change */
          merge_error(i1.position, i2.position, i3.position, 8);
          goto err;
        }
    }

  if (i1.position &gt;= 0)
    {                           /* Dueling deletes */
      merge_error(i1.position, i2.position, i3.position, 9);
      goto err;
    }

  while (i2.position &gt;= 0)
    {                           /* Inserting i2 at end */
      if (merge_output(r, &amp;i2, mapping) &lt; 0) goto err;
      if (i2.next(&amp;i2) &lt; 0) goto err;
    }

  while (i3.position &gt;= 0)
    {                           /* Inserting i2 at end */
      if (merge_output(r, &amp;i3, mapping) &lt; 0) goto err;
      if (i3.next(&amp;i3) &lt; 0) goto err;
    }

  /* If the output bucket is empty, conflict resolution doesn't have
   * enough info to unlink it from its containing BTree correctly.
   */
  if (r-&gt;len == 0)
    {
      merge_error(-1, -1, -1, 10);
      goto err;
    }

  finiSetIteration(&amp;i1);
  finiSetIteration(&amp;i2);
  finiSetIteration(&amp;i3);

  if (s1-&gt;next)
    {
      Py_INCREF(s1-&gt;next);
      r-&gt;next = s1-&gt;next;
    }
  s=bucket_getstate(r, NULL);
  Py_DECREF(r);

  return s;

 err:
  finiSetIteration(&amp;i1);
  finiSetIteration(&amp;i2);
  finiSetIteration(&amp;i3);
  Py_XDECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1186">&lt;&lt; copyright &gt;&gt;

# hack to overcome dynamic-linking headache.
from _OIBTree import *

# We don't really want _ names in pickles, so update all of the __module__
# references.
for o in globals().values():
    if hasattr(o, '__module__'):
        o.__module__=__name__
</t>
<t tx="ekr.20040104185913.1187">&lt;&lt; copyright &gt;&gt;

# hack to overcome dynamic-linking headache.
from _OOBTree import *

# We don't really want _ names in pickles, so update all of the __module__
# references.
for o in globals().values():
    if hasattr(o, '__module__'):
        o.__module__=__name__
</t>
<t tx="ekr.20040104185913.1188">@language c

&lt;&lt; c copyright &gt;&gt;

/****************************************************************************
 Set operations
 ****************************************************************************/

#define SETOPTEMPLATE_C "$Id: SetOpTemplate.c,v 1.29 2002/06/27 22:24:16 tim_one Exp $\n"

#ifdef INTSET_H
static int
nextIntSet(SetIteration *i)
{
  if (i-&gt;position &gt;= 0)
    {
      UNLESS(PER_USE(INTSET(i-&gt;set))) return -1;

      if (i-&gt;position &lt; INTSET(i-&gt;set)-&gt;len)
        {
          i-&gt;key = INTSET(i-&gt;set)-&gt;data[i-&gt;position];
          i-&gt;position ++;
        }
      else
        {
          i-&gt;position = -1;
          PER_ACCESSED(INTSET(i-&gt;set));
        }

      PER_ALLOW_DEACTIVATION(INTSET(i-&gt;set));
    }


  return 0;
}
#endif

#ifdef KEY_CHECK
static int
nextKeyAsSet(SetIteration *i)
{
    if (i-&gt;position &gt;= 0) {
        if (i-&gt;position) {
            DECREF_KEY(i-&gt;key);
            i-&gt;position = -1;
        }
        else
            i-&gt;position = 1;
    }
    return 0;
}
#endif

/* initSetIteration
 *
 * Start the set iteration protocol.  See the comments at struct SetIteration.
 *
 * Arguments
 *      i           The address of a SetIteration control struct.
 *      s           The address of the set, bucket, BTree, ..., to be iterated.
 *      useValues   Boolean; if true, and s has values (is a mapping), copy
 *                  them into i-&gt;value each time i-&gt;next() is called; else
 *                  ignore s's values even if s is a mapping.
 *
 * Return
 *      0 on success; -1 and an exception set if error.
 *      i.usesValue is set to 1 (true) if s has values and useValues was
 *          true; else usesValue is set to 0 (false).
 *      i.set gets a new reference to s, or to some other object used to
 *          iterate over s.
 *      i.position is set to 0.
 *      i.next is set to an appropriate iteration function.
 *      i.key and i.value are left alone.
 *
 * Internal
 *      i.position &lt; 0 means iteration terminated.
 *      i.position = 0 means iteration hasn't yet begun (next() hasn't
 *          been called yet).
 *      In all other cases, i.key, and possibly i.value, own references.
 *          These must be cleaned up, either by next() routines, or by
 *          finiSetIteration.
 *      next() routines must ensure the above.  They should return without
 *          doing anything when i.position &lt; 0.
 *      It's the responsibility of {init, fini}setIteration to clean up
 *          the reference in i.set, and to ensure that no stale references
 *          live in i.key or i.value if iteration terminates abnormally.
 *          A SetIteration struct has been cleaned up iff i.set is NULL.
 */
static int
initSetIteration(SetIteration *i, PyObject *s, int useValues)
{
  i-&gt;set = NULL;
  i-&gt;position = -1;     /* set to 0 only on normal return */
  i-&gt;usesValue = 0;     /* assume it's a set or that values aren't iterated */

  if (ExtensionClassSubclassInstance_Check(s, &amp;BucketType))
    {
      i-&gt;set = s;
      Py_INCREF(s);

      if (useValues)
        {
          i-&gt;usesValue = 1;
          i-&gt;next = nextBucket;
        }
      else
        i-&gt;next = nextSet;
    }
  else if (ExtensionClassSubclassInstance_Check(s, &amp;SetType))
    {
      i-&gt;set = s;
      Py_INCREF(s);
      i-&gt;next = nextSet;
    }
  else if (ExtensionClassSubclassInstance_Check(s, &amp;BTreeType))
    {
      i-&gt;set = BTree_rangeSearch(BTREE(s), NULL, 'i');
      UNLESS(i-&gt;set) return -1;

      if (useValues)
        {
          i-&gt;usesValue = 1;
          i-&gt;next = nextBTreeItems;
        }
      else
        i-&gt;next = nextTreeSetItems;
    }
  else if (ExtensionClassSubclassInstance_Check(s, &amp;TreeSetType))
    {
      i-&gt;set = BTree_rangeSearch(BTREE(s), NULL, 'k');
      UNLESS(i-&gt;set) return -1;
      i-&gt;next = nextTreeSetItems;
    }
#ifdef INTSET_H
  else if (s-&gt;ob_type == (PyTypeObject*)intSetType)
    {
      i-&gt;set = s;
      Py_INCREF(s);
      i-&gt;next = nextIntSet;
    }
#endif
#ifdef KEY_CHECK
  else if (KEY_CHECK(s))
    {
      int copied = 1;
      COPY_KEY_FROM_ARG(i-&gt;key, s, copied);
      UNLESS (copied) return -1;

      INCREF_KEY(i-&gt;key);
      i-&gt;set = s;
      Py_INCREF(s);
      i-&gt;next = nextKeyAsSet;
    }
#endif
  else
    {
      PyErr_SetString(PyExc_TypeError, "invalid argument");
      return -1;
    }

  i-&gt;position = 0;

  return 0;
}

#ifndef MERGE_WEIGHT
#define MERGE_WEIGHT(O, w) (O)
#endif

static int
copyRemaining(Bucket *r, SetIteration *i, int merge, int w)
{
  while (i-&gt;position &gt;= 0)
    {
      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; Bucket_grow(r, -1, ! merge) &lt; 0) return -1;
      COPY_KEY(r-&gt;keys[r-&gt;len], i-&gt;key);
      INCREF_KEY(r-&gt;keys[r-&gt;len]);

      if (merge)
        {
          COPY_VALUE(r-&gt;values[r-&gt;len], MERGE_WEIGHT(i-&gt;value, w));
          INCREF_VALUE(r-&gt;values[r-&gt;len]);
        }
      r-&gt;len++;
      if (i-&gt;next(i) &lt; 0) return -1;
    }

  return 0;
}

/* This is the workhorse for all set merge operations:  the weighted and
 * unweighted flavors of union and intersection, and set difference.  The
 * algorithm is conceptually simple but the code is complicated due to all
 * the options.
 *
 * s1, s2
 *     The input collections to be merged.
 *
 * usevalues1, usevalues2
 *     Booleans.  In the output, should values from s1 (or s2) be used?  This
 *     only makes sense when an operation intends to support mapping outputs;
 *     these should both be false for operations that want pure set outputs.
 *
 * w1, w2
 *     If usevalues1(2) are true, these are the weights to apply to the
 *     input values.
 *
 * c1
 *     Boolean.  Should keys that appear in c1 but not c2 appear in the output?
 * c12
 *     Boolean.  Should keys that appear in both inputs appear in the output?
 * c2
 *     Boolean.  Should keys that appear in c2 but not c1 appear in the output?
 *
 * Returns NULL if error, else a Set or Bucket, depending on whether a set or
 * mapping was requested.
 */
static PyObject *
set_operation(PyObject *s1, PyObject *s2,
              int usevalues1, int usevalues2,
              int w1, int w2,
              int c1, int c12, int c2)
{
  Bucket *r=0;
  SetIteration i1 = {0,0,0}, i2 = {0,0,0};
  int cmp, merge;

  if (initSetIteration(&amp;i1, s1, usevalues1) &lt; 0) goto err;
  if (initSetIteration(&amp;i2, s2, usevalues2) &lt; 0) goto err;
  merge = i1.usesValue | i2.usesValue;

  if (merge)
    {
#ifndef MERGE
      if (c12 &amp;&amp; i1.usesValue &amp;&amp; i2.usesValue) goto invalid_set_operation;
#endif
      if (! i1.usesValue &amp;&amp; i2.usesValue)
        {
          SetIteration t;
          int i;

          t=i1; i1=i2; i2=t;
          i=c1; c1=c2; c2=i;
          i=w1; w1=w2; w2=i;
        }
#ifdef MERGE_DEFAULT
      i1.value=MERGE_DEFAULT;
      i2.value=MERGE_DEFAULT;
#else
      if (i1.usesValue)
        {
          if (! i2.usesValue &amp;&amp; c2) goto invalid_set_operation;
        }
      else
        {
          if (c1 || c12) goto invalid_set_operation;
        }
#endif

      UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(&amp;BucketType), NULL)))
        goto err;
    }
  else
    {
      UNLESS(r=BUCKET(PyObject_CallObject(OBJECT(&amp;SetType), NULL)))
        goto err;
    }

  if (i1.next(&amp;i1) &lt; 0) goto err;
  if (i2.next(&amp;i2) &lt; 0) goto err;

  while (i1.position &gt;= 0 &amp;&amp; i2.position &gt;= 0)
    {
      TEST_KEY_SET_OR(cmp, i1.key, i2.key) goto err;
      if(cmp &lt; 0)
	{
	  if(c1)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; Bucket_grow(r, -1, ! merge) &lt; 0) goto err;
              COPY_KEY(r-&gt;keys[r-&gt;len], i1.key);
              INCREF_KEY(r-&gt;keys[r-&gt;len]);
              if (merge)
                {
                  COPY_VALUE(r-&gt;values[r-&gt;len], MERGE_WEIGHT(i1.value, w1));
                  INCREF_VALUE(r-&gt;values[r-&gt;len]);
                }
	      r-&gt;len++;
	    }
          if (i1.next(&amp;i1) &lt; 0) goto err;
	}
      else if(cmp==0)
	{
	  if(c12)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; Bucket_grow(r, -1, ! merge) &lt; 0) goto err;
              COPY_KEY(r-&gt;keys[r-&gt;len], i1.key);
              INCREF_KEY(r-&gt;keys[r-&gt;len]);
              if (merge)
                {
#ifdef MERGE
                  r-&gt;values[r-&gt;len] = MERGE(i1.value, w1, i2.value, w2);
#else
                  COPY_VALUE(r-&gt;values[r-&gt;len], i1.value);
                  INCREF_VALUE(r-&gt;values[r-&gt;len]);
#endif
                }
	      r-&gt;len++;
	    }
          if (i1.next(&amp;i1) &lt; 0) goto err;
          if (i2.next(&amp;i2) &lt; 0) goto err;
	}
      else
	{
	  if(c2)
	    {
	      if(r-&gt;len &gt;= r-&gt;size &amp;&amp; Bucket_grow(r, -1, ! merge) &lt; 0) goto err;
              COPY_KEY(r-&gt;keys[r-&gt;len], i2.key);
              INCREF_KEY(r-&gt;keys[r-&gt;len]);
              if (merge)
                {
                  COPY_VALUE(r-&gt;values[r-&gt;len], MERGE_WEIGHT(i2.value, w2));
                  INCREF_VALUE(r-&gt;values[r-&gt;len]);
                }
	      r-&gt;len++;
	    }
          if (i2.next(&amp;i2) &lt; 0) goto err;
	}
    }
  if(c1 &amp;&amp; copyRemaining(r, &amp;i1, merge, w1) &lt; 0) goto err;
  if(c2 &amp;&amp; copyRemaining(r, &amp;i2, merge, w2) &lt; 0) goto err;

  finiSetIteration(&amp;i1);
  finiSetIteration(&amp;i2);

  return OBJECT(r);

#ifndef MERGE_DEFAULT
invalid_set_operation:
  PyErr_SetString(PyExc_TypeError, "invalid set operation");
#endif

err:
  finiSetIteration(&amp;i1);
  finiSetIteration(&amp;i2);
  Py_XDECREF(r);
  return NULL;
}

static PyObject *
difference_m(PyObject *ignored, PyObject *args)
{
  PyObject *o1, *o2;

  UNLESS(PyArg_ParseTuple(args, "OO", &amp;o1, &amp;o2)) return NULL;


  if (o1 == Py_None || o2 == Py_None)
    {
      /* difference(None, X) -&gt; None; difference(X, None) -&gt; X */
      Py_INCREF(o1);
      return o1;
    }

  return set_operation(o1, o2, 1, 0, /* preserve values from o1, ignore o2's */
                       1, 0,         /* o1's values multiplied by 1 */
                       1, 0, 0);     /* take only keys unique to o1 */
}

static PyObject *
union_m(PyObject *ignored, PyObject *args)
{
  PyObject *o1, *o2;

  UNLESS(PyArg_ParseTuple(args, "OO", &amp;o1, &amp;o2)) return NULL;

  if (o1==Py_None)
    {
      Py_INCREF(o2);
      return o2;
    }
  else if (o2 == Py_None)
    {
      Py_INCREF(o1);
      return o1;
    }

  return set_operation(o1, o2, 0, 0,    /* ignore values in both */
                       1, 1,            /* the weights are irrelevant */
                       1, 1, 1);        /* take all keys */
}

static PyObject *
intersection_m(PyObject *ignored, PyObject *args)
{
  PyObject *o1, *o2;

  UNLESS(PyArg_ParseTuple(args, "OO", &amp;o1, &amp;o2)) return NULL;

  if (o1 == Py_None)
    {
      Py_INCREF(o2);
      return o2;
    }
  else if (o2 == Py_None)
    {
      Py_INCREF(o1);
      return o1;
    }

  return set_operation(o1, o2, 0, 0,    /* ignore values in both */
                       1, 1,            /* the weights are irrelevant */
                       0, 1, 0);        /* take only keys common to both */
}

#ifdef MERGE

static PyObject *
wunion_m(PyObject *ignored, PyObject *args)
{
  PyObject *o1, *o2;
  int w1 = 1, w2 = 1;

  UNLESS(PyArg_ParseTuple(args, "OO|ii", &amp;o1, &amp;o2, &amp;w1, &amp;w2)) return NULL;

  if (o1 == Py_None)
    return Py_BuildValue("iO", (o2 == Py_None ? 0 : w2), o2);
  else if (o2 == Py_None)
    return Py_BuildValue("iO", w1, o1);

  o1 = set_operation(o1, o2, 1, 1, w1, w2, 1, 1, 1);
  if (o1) ASSIGN(o1, Py_BuildValue("iO", 1, o1));

  return o1;
}

static PyObject *
wintersection_m(PyObject *ignored, PyObject *args)
{
  PyObject *o1, *o2;
  int w1 = 1, w2 = 1;

  UNLESS(PyArg_ParseTuple(args, "OO|ii", &amp;o1, &amp;o2, &amp;w1, &amp;w2)) return NULL;

  if (o1 == Py_None)
    return Py_BuildValue("iO", (o2 == Py_None ? 0 : w2), o2);
  else if (o2 == Py_None)
    return Py_BuildValue("iO", w1, o1);

  o1 = set_operation(o1, o2, 1, 1, w1, w2, 0, 1, 0);
  if (o1)
    ASSIGN(o1, Py_BuildValue("iO",
            ((o1-&gt;ob_type == (PyTypeObject*)(&amp;SetType)) ? w2+w1 : 1),
                             o1));

  return o1;
}

#endif

#ifdef MULTI_INT_UNION
&lt;&lt; SetOpTemplate #includes &gt;&gt;
@others

#endif
</t>
<t tx="ekr.20040104185913.1189">#include "sorters.c"
</t>
<t tx="ekr.20040104185913.1190">@ Input is a sequence of integer sets (or convertible to sets by the  set iteration protocol). Output is the union of the sets. The point  is to run much faster than doing pairs of unions.
@c

static PyObject *
multiunion_m(PyObject *ignored, PyObject *args)
{
    PyObject *seq;          /* input sequence */
    int n;                  /* length of input sequence */
    PyObject *set = NULL;   /* an element of the input sequence */
    Bucket *result;         /* result set */
    SetIteration setiter = {0};
    int i;

    UNLESS(PyArg_ParseTuple(args, "O", &amp;seq))
        return NULL;

    n = PyObject_Length(seq);
    if (n &lt; 0)
        return NULL;

    /* Construct an empty result set. */
    result = BUCKET(PyObject_CallObject(OBJECT(&amp;SetType), NULL));
    if (result == NULL)
        return NULL;

    /* For each set in the input sequence, append its elements to the result
       set.  At this point, we ignore the possibility of duplicates. */
    for (i = 0; i &lt; n; ++i) {
        set = PySequence_GetItem(seq, i);
        if (set == NULL)
            goto Error;

        /* If set is a bucket, do a straight resize + memcpy. */
        if (set-&gt;ob_type == (PyTypeObject*)&amp;SetType ||
            set-&gt;ob_type == (PyTypeObject*)&amp;BucketType)
        {
            Bucket *b = BUCKET(set);
            int status = 0;

            UNLESS (PER_USE(b)) goto Error;
            if (b-&gt;len)
                status = bucket_append(result, b, 0, b-&gt;len, 0, i &lt; n-1);
            PER_UNUSE(b);
            if (status &lt; 0) goto Error;
        }
        else {
            /* No cheap way:  iterate over set's elements one at a time. */
            if (initSetIteration(&amp;setiter, set, 0) &lt; 0) goto Error;
            if (setiter.next(&amp;setiter) &lt; 0) goto Error;
            while (setiter.position &gt;= 0) {
                if (result-&gt;len &gt;= result-&gt;size &amp;&amp; Bucket_grow(result, -1, 1) &lt; 0)
                    goto Error;
                COPY_KEY(result-&gt;keys[result-&gt;len], setiter.key);
                ++result-&gt;len;
                /* We know the key is an int, so no need to incref it. */
                if (setiter.next(&amp;setiter) &lt; 0) goto Error;
            }
            finiSetIteration(&amp;setiter);
        }
        Py_DECREF(set);
        set = NULL;
    }

    /* Combine, sort, remove duplicates, and reset the result's len.
       If the set shrinks (which happens if and only if there are
       duplicates), no point to realloc'ing the set smaller, as we
       expect the result set to be short-lived.
    */
    if (result-&gt;len &gt; 0) {
        size_t newlen;          /* number of elements in final result set */
        newlen = sort_int4_nodups(result-&gt;keys, (size_t)result-&gt;len);
        result-&gt;len = (int)newlen;
    }
    return (PyObject *)result;

Error:
    Py_DECREF(result);
    Py_XDECREF(set);
    finiSetIteration(&amp;setiter);
    return NULL;
}
</t>
<t tx="ekr.20040104185913.1191">@language c
&lt;&lt; SetTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1192">&lt;&lt; c copyright &gt;&gt;

#define SETTEMPLATE_C "$Id: SetTemplate.c,v 1.15.68.2 2003/01/30 23:25:09 bwarsaw Exp $\n"

static PyObject *
Set_insert(Bucket *self, PyObject *args)
{
  PyObject *key;
  int i;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;key)) return NULL;
  if ( (i=_bucket_set(self, key, Py_None, 1, 1, 0)) &lt; 0) return NULL;
  return PyInt_FromLong(i);
}

static PyObject *
Set_update(Bucket *self, PyObject *args)
{
  PyObject *seq=0, *o, *t, *v, *tb;
  int i, n=0, ind;

  UNLESS(PyArg_ParseTuple(args, "|O:update", &amp;seq)) return NULL;

  if (seq)
    {
      for (i=0; ; i++)
        {
          UNLESS (o=PySequence_GetItem(seq, i))
            {
              PyErr_Fetch(&amp;t, &amp;v, &amp;tb);
              if (t != PyExc_IndexError)
                {
                  PyErr_Restore(t, v, tb);
                  return NULL;
                }
              Py_XDECREF(t);
              Py_XDECREF(v);
              Py_XDECREF(tb);
              break;
            }
          ind=_bucket_set(self, o, Py_None, 1, 1, 0);
          Py_DECREF(o);
          if (ind &lt; 0) return NULL;
          n += ind;
        }
    }

  return PyInt_FromLong(n);
}

static PyObject *
Set_remove(Bucket *self, PyObject *args)
{
  PyObject *key;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;key)) return NULL;
  if (_bucket_set(self, key, NULL, 0, 1, 0) &lt; 0) return NULL;

  Py_INCREF(Py_None);
  return Py_None;
}

static int
_set_setstate(Bucket *self, PyObject *args)
{
  PyObject *k, *items;
  Bucket *next=0;
  int i, l, copied=1;
  KEY_TYPE *keys;

  UNLESS (PyArg_ParseTuple(args, "O|O", &amp;items, &amp;next))
    return -1;

  if ((l=PyTuple_Size(items)) &lt; 0) return -1;

  for (i=self-&gt;len; --i &gt;= 0; )
    {
      DECREF_KEY(self-&gt;keys[i]);
    }
  self-&gt;len=0;

  if (self-&gt;next)
    {
      Py_DECREF(self-&gt;next);
      self-&gt;next=0;
    }
  
  if (l &gt; self-&gt;size)
    {
      UNLESS (keys=PyRealloc(self-&gt;keys, sizeof(KEY_TYPE)*l)) return -1;
      self-&gt;keys=keys;
      self-&gt;size=l;
    }
  
  for (i=0; i&lt;l; i++)
    {
      k=PyTuple_GET_ITEM(items, i);
      COPY_KEY_FROM_ARG(self-&gt;keys[i], k, copied);
      UNLESS (copied) return -1;
      INCREF_KEY(self-&gt;keys[i]);
    }

  self-&gt;len=l;

  if (next)
    {
      self-&gt;next=next;
      Py_INCREF(next);
    }

  return 0;
}

static PyObject *
set_setstate(Bucket *self, PyObject *args)
{
  int r;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;args)) return NULL;

  PER_PREVENT_DEACTIVATION(self); 
  r=_set_setstate(self, args);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  if (r &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

static struct PyMethodDef Set_methods[] = {
  {"__getstate__", (PyCFunction) bucket_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction) set_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"keys",	(PyCFunction) bucket_keys,	METH_VARARGS,
     "keys() -- Return the keys"},
  {"has_key",	(PyCFunction) bucket_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"clear",	(PyCFunction) bucket_clear,	METH_VARARGS,
   "clear() -- Remove all of the items from the bucket"},
  {"maxKey", (PyCFunction) Bucket_maxKey,	METH_VARARGS,
   "maxKey([key]) -- Find the maximum key\n\n"
   "If an argument is given, find the maximum &lt;= the argument"},
  {"minKey", (PyCFunction) Bucket_minKey,	METH_VARARGS,
   "minKey([key]) -- Find the minimum key\n\n"
   "If an argument is given, find the minimum &gt;= the argument"},
#ifdef PERSISTENT
  {"_p_resolveConflict", (PyCFunction) bucket__p_resolveConflict, METH_VARARGS,
   "_p_resolveConflict() -- Reinitialize from a newly created copy"},
  {"_p_deactivate", (PyCFunction) bucket__p_deactivate, METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
  {"insert",	(PyCFunction)Set_insert,	METH_VARARGS,
   "insert(id,[ignored]) -- Add a key to the set"},
  {"update",	(PyCFunction)Set_update,	METH_VARARGS,
   "update(seq) -- Add the items from the given sequence to the set"},
  {"__init__",	(PyCFunction)Set_update,	METH_VARARGS,
   "__init__(seq) -- Initialize with  the items from the given sequence"},
  {"remove",	(PyCFunction)Set_remove,	METH_VARARGS,
   "remove(id) -- Remove an id from the set"},

  {NULL,		NULL}		/* sentinel */
};
</t>
<t tx="ekr.20040104185913.1193">static PyObject *
set_repr(Bucket *self)
{
  static PyObject *format;
  PyObject *r, *t;

  UNLESS (format) UNLESS (format=PyString_FromString(MOD_NAME_PREFIX "Set(%s)")) 
    return NULL;
  UNLESS (t=PyTuple_New(1)) return NULL;
  UNLESS (r=bucket_keys(self,NULL)) goto err;
  PyTuple_SET_ITEM(t,0,r);
  r=t;
  ASSIGN(r,PyString_Format(format,r));
  return r;
err:
  Py_DECREF(t);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1194">static int
set_length(Bucket *self) 
{
  int r;

  PER_USE_OR_RETURN(self, -1);
  r = self-&gt;len;
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return r;
}
</t>
<t tx="ekr.20040104185913.1195">static PyObject *
set_item(Bucket *self, int index)
{
  PyObject *r=0;

  PER_USE_OR_RETURN(self, NULL);
  if (index &gt;= 0 &amp;&amp; index &lt; self-&gt;len)
    {
      COPY_KEY_TO_OBJECT(r, self-&gt;keys[index]);
    }
  else
    IndexError(index);

  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  return r;
}
</t>
<t tx="ekr.20040104185913.1196">static PySequenceMethods set_as_sequence = {
	(inquiry)set_length,		/*sq_length*/
	(binaryfunc)0,		/*sq_concat*/
	(intargfunc)0,		/*sq_repeat*/
	(intargfunc)set_item,		/*sq_item*/
	(intintargfunc)0,		/*sq_slice*/
	(intobjargproc)0,	/*sq_ass_item*/
	(intintobjargproc)0,	/*sq_ass_slice*/
};

static PyExtensionClass SetType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  MOD_NAME_PREFIX "Set",			/*tp_name*/
  sizeof(Bucket),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /*********** methods ***********************/
  (destructor) Bucket_dealloc,	/*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc) set_repr,		/*tp_repr*/
  0,				/*tp_as_number*/
  &amp;set_as_sequence,		/*tp_as_sequence*/
  0,		                /*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,		/*tp_getattro*/
  0,				/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  "Set implemented as sorted keys", 
  METHOD_CHAIN(Set_methods),
  EXTENSIONCLASS_BASICNEW_FLAG 
#ifdef PERSISTENT
  | PERSISTENT_TYPE_FLAG 
#endif
  | EXTENSIONCLASS_NOINSTDICT_FLAG,
};

static int 
nextSet(SetIteration *i)
{
          
  if (i-&gt;position &gt;= 0)
    {
      UNLESS(PER_USE(BUCKET(i-&gt;set))) return -1;

      if (i-&gt;position)
        {
          DECREF_KEY(i-&gt;key);
        }

      if (i-&gt;position &lt; BUCKET(i-&gt;set)-&gt;len)
        {
          COPY_KEY(i-&gt;key, BUCKET(i-&gt;set)-&gt;keys[i-&gt;position]);
          INCREF_KEY(i-&gt;key);
          i-&gt;position ++;
        }
      else
        {
          i-&gt;position = -1;
          PER_ACCESSED(BUCKET(i-&gt;set));
        }

      PER_ALLOW_DEACTIVATION(BUCKET(i-&gt;set));
    }

          
  return 0;
}
</t>
<t tx="ekr.20040104185913.1197">@language c

&lt;&lt; c copyright &gt;&gt;

#define TREESETTEMPLATE_C "$Id: TreeSetTemplate.c,v 1.14.10.2 2003/01/30 23:25:09 bwarsaw Exp $\n"

static PyObject *
TreeSet_insert(BTree *self, PyObject *args)
{
  PyObject *key;
  int i;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;key)) return NULL;
  if ((i=_BTree_set(self, key, Py_None, 1, 1)) &lt; 0) return NULL;
  return PyInt_FromLong(i);
}

static PyObject *
TreeSet_update(BTree *self, PyObject *args)
{
  PyObject *seq=0, *o, *t, *v, *tb;
  int i, n=0, ind;

  UNLESS(PyArg_ParseTuple(args, "|O:update", &amp;seq)) return NULL;

  if (seq)
    {
      for (i=0; ; i++)
        {
          UNLESS (o=PySequence_GetItem(seq, i))
            {
              PyErr_Fetch(&amp;t, &amp;v, &amp;tb);
              if (t != PyExc_IndexError)
                {
                  PyErr_Restore(t, v, tb);
                  return NULL;
                }
              Py_XDECREF(t);
              Py_XDECREF(v);
              Py_XDECREF(tb);
              break;
            }
          ind=_BTree_set(self, o, Py_None, 1, 1);
          Py_DECREF(o);
          if (ind &lt; 0) return NULL;
          n += ind;
        }
    }

  return PyInt_FromLong(n);
}


static PyObject *
TreeSet_remove(BTree *self, PyObject *args)
{
  PyObject *key;

  UNLESS (PyArg_ParseTuple(args, "O", &amp;key)) return NULL;
  if (_BTree_set(self, key, NULL, 0, 1) &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

static PyObject *
TreeSet_setstate(BTree *self, PyObject *args)
{
  int r;

  if (!PyArg_ParseTuple(args,"O",&amp;args)) return NULL;

  PER_PREVENT_DEACTIVATION(self);
  r=_BTree_setstate(self, args, 1);
  PER_ALLOW_DEACTIVATION(self);
  PER_ACCESSED(self);

  if (r &lt; 0) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}

static struct PyMethodDef TreeSet_methods[] = {
  {"__getstate__", (PyCFunction) BTree_getstate,	METH_VARARGS,
   "__getstate__() -- Return the picklable state of the object"},
  {"__setstate__", (PyCFunction) TreeSet_setstate,	METH_VARARGS,
   "__setstate__() -- Set the state of the object"},
  {"has_key",	(PyCFunction) BTree_has_key,	METH_VARARGS,
     "has_key(key) -- Test whether the bucket contains the given key"},
  {"keys",	(PyCFunction) BTree_keys,	METH_VARARGS,
     "keys() -- Return the keys"},
  {"maxKey", (PyCFunction) BTree_maxKey,	METH_VARARGS,
   "maxKey([key]) -- Find the maximum key\n\n"
   "If an argument is given, find the maximum &lt;= the argument"},
  {"minKey", (PyCFunction) BTree_minKey,	METH_VARARGS,
   "minKey([key]) -- Find the minimum key\n\n"
   "If an argument is given, find the minimum &gt;= the argument"},
  {"clear",	(PyCFunction) BTree_clear,	METH_VARARGS,
   "clear() -- Remove all of the items from the BTree"},
  {"insert",	(PyCFunction)TreeSet_insert,	METH_VARARGS,
   "insert(id,[ignored]) -- Add an id to the set"},
  {"update",	(PyCFunction)TreeSet_update,	METH_VARARGS,
   "update(seq) -- Add the items from the given sequence to the set"},
  {"__init__",	(PyCFunction)TreeSet_update,	METH_VARARGS,
   "__init__(seq) -- Initialize with  the items from the given sequence"},
  {"remove",	(PyCFunction)TreeSet_remove,	METH_VARARGS,
   "remove(id) -- Remove a key from the set"},
  {"_check", (PyCFunction) BTree_check,         METH_VARARGS,
   "Perform sanity check on TreeSet, and raise exception if flawed."},
#ifdef PERSISTENT
  {"_p_resolveConflict", (PyCFunction) BTree__p_resolveConflict, METH_VARARGS,
   "_p_resolveConflict() -- Reinitialize from a newly created copy"},
  {"_p_deactivate", (PyCFunction) BTree__p_deactivate,	METH_VARARGS,
   "_p_deactivate() -- Reinitialize from a newly created copy"},
#endif
  {NULL,		NULL}		/* sentinel */
};

static PyMappingMethods TreeSet_as_mapping = {
  (inquiry)BTree_length,		/*mp_length*/
};

static PyExtensionClass TreeSetType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  MOD_NAME_PREFIX "TreeSet",		/*tp_name*/
  sizeof(BTree),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /************* methods ********************/
  (destructor) BTree_dealloc,   /*tp_dealloc*/
  (printfunc)0,			/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,			/*tp_compare*/
  (reprfunc)0,			/*tp_repr*/
  &amp;BTree_as_number_for_nonzero,	/*tp_as_number*/
  0,				/*tp_as_sequence*/
  &amp;TreeSet_as_mapping,		/*tp_as_mapping*/
  (hashfunc)0,			/*tp_hash*/
  (ternaryfunc)0,		/*tp_call*/
  (reprfunc)0,			/*tp_str*/
  (getattrofunc)0,
  0,				/*tp_setattro*/

  /* Space for future expansion */
  0L,0L,
  "Set implemented as sorted tree of items",
  METHOD_CHAIN(TreeSet_methods),
  EXTENSIONCLASS_BASICNEW_FLAG
#ifdef PERSISTENT
  | PERSISTENT_TYPE_FLAG
#endif
  | EXTENSIONCLASS_NOINSTDICT_FLAG,
};
</t>
<t tx="ekr.20040104185913.1198">@language c

/* Setup template macros */

#define MASTER_ID "$Id: _IIBTree.c,v 1.7 2002/06/25 02:00:55 tim_one Exp $\n"

#define PERSISTENT

#define MOD_NAME_PREFIX "II"
#define INITMODULE init_IIBTree
#define DEFAULT_MAX_BUCKET_SIZE 120
#define DEFAULT_MAX_BTREE_SIZE 500

&lt;&lt; _IIBTree #includes &gt;&gt;</t>
<t tx="ekr.20040104185913.1199">#include "intkeymacros.h"
#include "intvaluemacros.h"
#include "cPersistence.h"

#ifndef EXCLUDE_INTSET_SUPPORT
#include "BTree/intSet.h"
#endif

#include "BTreeModuleTemplate.c"
</t>
<t tx="ekr.20040104185913.1200">@language c

#define MASTER_ID "$Id: _IOBTree.c,v 1.5 2002/02/21 21:41:17 jeremy Exp $\n"

#define PERSISTENT

#define MOD_NAME_PREFIX "IO"
#define DEFAULT_MAX_BUCKET_SIZE 60
#define DEFAULT_MAX_BTREE_SIZE 500
#define INITMODULE init_IOBTree
                                
&lt;&lt; _IOBTree #includes &gt;&gt;</t>
<t tx="ekr.20040104185913.1201">#include "intkeymacros.h"
#include "objectvaluemacros.h"
#include "cPersistence.h"

#ifndef EXCLUDE_INTSET_SUPPORT
#include "BTree/intSet.h"
#endif
#include "BTreeModuleTemplate.c"
</t>
<t tx="ekr.20040104185913.1202">@language c

#define MASTER_ID "$Id: _OIBTree.c,v 1.2 2001/03/27 16:37:42 jim Exp $\n"

#define PERSISTENT

#define MOD_NAME_PREFIX "OI"
#define INITMODULE init_OIBTree
#define DEFAULT_MAX_BUCKET_SIZE 60
#define DEFAULT_MAX_BTREE_SIZE 250
                                
&lt;&lt; _OIBTree #includes &gt;&gt;
</t>
<t tx="ekr.20040104185913.1203">#include "objectkeymacros.h"
#include "intvaluemacros.h"
#include "BTreeModuleTemplate.c"
</t>
<t tx="ekr.20040104185913.1204">@language c
#define MASTER_ID "$Id: _OOBTree.c,v 1.2 2001/03/27 16:37:42 jim Exp $\n"

#define PERSISTENT

#define MOD_NAME_PREFIX "OO"
#define INITMODULE init_OOBTree
#define DEFAULT_MAX_BUCKET_SIZE 30
#define DEFAULT_MAX_BTREE_SIZE 250
                                
&lt;&lt; _OOBTree #includes &gt;&gt;
</t>
<t tx="ekr.20040104185913.1205">#include "objectkeymacros.h"
#include "objectvaluemacros.h"
#include "BTreeModuleTemplate.c"
</t>
<t tx="ekr.20040104185913.1206">import ZODB

try: import intSet
except: pass
else: del intSet

# Register interfaces
try: import Interface
except ImportError: pass # Don't register interfaces if no scarecrow
else:
    import Interfaces
    del Interfaces
    del Interface
</t>
<t tx="ekr.20040104185913.1207">@language c

/* fsBTree - FileStorage index BTree

   This BTree implments a mapping from 2-character strings
   to six-character strings. This allows us to effieciently store
   a FileStorage index as a nested mapping of 6-character oid prefix
   to mapping of 2-character oid suffix to 6-character (byte) file
   positions.
*/

typedef unsigned char char2[2];
typedef unsigned char char6[6];


/* Setup template macros */

#define MASTER_ID "$Id: _fsBTree.c,v 1.4.10.3 2003/06/23 14:42:25 tim_one Exp $\n"

#define PERSISTENT

#define MOD_NAME_PREFIX "fs"
#define INITMODULE init_fsBTree
#define DEFAULT_MAX_BUCKET_SIZE 500
#define DEFAULT_MAX_BTREE_SIZE 500
                
/*#include "intkeymacros.h"*/

#define KEYMACROS_H "$Id: _fsBTree.c,v 1.4.10.3 2003/06/23 14:42:25 tim_one Exp $\n"
#define KEY_TYPE char2
#undef KEY_TYPE_IS_PYOBJECT
#define KEY_CHECK(K) (PyString_Check(K) &amp;&amp; PyString_GET_SIZE(K)==2)
#define TEST_KEY_SET_OR(V, K, T) if ( ( (V) = ((*(K) &lt; *(T) || (*(K) == *(T) &amp;&amp; (K)[1] &lt; (T)[1])) ? -1 : ((*(K) == *(T) &amp;&amp; (K)[1] == (T)[1]) ? 0 : 1)) ), 0 )
#define DECREF_KEY(KEY)
#define INCREF_KEY(k)
#define COPY_KEY(KEY, E) (*(KEY)=*(E), (KEY)[1]=(E)[1])
#define COPY_KEY_TO_OBJECT(O, K) O=PyString_FromStringAndSize(K,2)
#define COPY_KEY_FROM_ARG(TARGET, ARG, STATUS) \
  if (KEY_CHECK(ARG)) memcpy(TARGET, PyString_AS_STRING(ARG), 2); else { \
      PyErr_SetString(PyExc_TypeError, "expected two-character string key"); \
      (STATUS)=0; } 

/*#include "intvaluemacros.h"*/
#define VALUEMACROS_H "$Id: _fsBTree.c,v 1.4.10.3 2003/06/23 14:42:25 tim_one Exp $\n"
#define VALUE_TYPE char6
#undef VALUE_TYPE_IS_PYOBJECT
#define TEST_VALUE(K, T) memcmp(K,T,6)
#define DECLARE_VALUE(NAME) VALUE_TYPE NAME
#define DECREF_VALUE(k)
#define INCREF_VALUE(k)
#define COPY_VALUE(V, E) (memcpy(V, E, 6))
#define COPY_VALUE_TO_OBJECT(O, K) O=PyString_FromStringAndSize(K,6)
#define COPY_VALUE_FROM_ARG(TARGET, ARG, STATUS) \
  if ((PyString_Check(ARG) &amp;&amp; PyString_GET_SIZE(ARG)==6)) \
      memcpy(TARGET, PyString_AS_STRING(ARG), 6); else { \
      PyErr_SetString(PyExc_TypeError, "expected six-character string key"); \
      (STATUS)=0; } 
  
#define NORMALIZE_VALUE(V, MIN)
&lt;&lt; _fsBTree #includes &gt;&gt;
</t>
<t tx="ekr.20040104185913.1208">#include "BTreeModuleTemplate.c"
</t>
<t tx="ekr.20040104185913.1209">&lt;&lt; check declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1210">&lt;&lt; copyright &gt;&gt;

"""
Utilities for working with BTrees (TreeSets, Buckets, and Sets) at a low
level.

The primary function is check(btree), which performs value-based consistency
checks of a kind btree._check() does not perform.  See the function docstring
for details.

display(btree) displays the internal structure of a BTree (TreeSet, etc) to
stdout.

CAUTION:  When a BTree node has only a single bucket child, it can be
impossible to get at the bucket from Python code (__getstate__() may squash
the bucket object out of existence, as a pickling storage optimization).  In
such a case, the code here synthesizes a temporary bucket with the same keys
(and values, if the bucket is of a mapping type).  This has no first-order
consequences, but can mislead if you pay close attention to reported object
addresses and/or object identity (the synthesized bucket has an address
that doesn't exist in the actual BTree).
"""

from types import TupleType

from BTrees.OOBTree import OOBTree, OOBucket, OOSet, OOTreeSet
from BTrees.OIBTree import OIBTree, OIBucket, OISet, OITreeSet
from BTrees.IOBTree import IOBTree, IOBucket, IOSet, IOTreeSet
from BTrees.IIBTree import IIBTree, IIBucket, IISet, IITreeSet

TYPE_UNKNOWN, TYPE_BTREE, TYPE_BUCKET = range(3)

try:
    True
except NameError:
    True = 1
    False = 0

_type2kind = {IOBTree: (TYPE_BTREE, True),
              IIBTree: (TYPE_BTREE, True),
              OIBTree: (TYPE_BTREE, True),
              OOBTree: (TYPE_BTREE, True),

              IOBucket: (TYPE_BUCKET, True),
              IIBucket: (TYPE_BUCKET, True),
              OIBucket: (TYPE_BUCKET, True),
              OOBucket: (TYPE_BUCKET, True),

              IOTreeSet: (TYPE_BTREE, False),
              IITreeSet: (TYPE_BTREE, False),
              OITreeSet: (TYPE_BTREE, False),
              OOTreeSet: (TYPE_BTREE, False),

              IOSet: (TYPE_BUCKET, False),
              IISet: (TYPE_BUCKET, False),
              OISet: (TYPE_BUCKET, False),
              OOSet: (TYPE_BUCKET, False),
             }

# Return pair
#
#     TYPE_BTREE or TYPE_BUCKET, is_mapping

</t>
<t tx="ekr.20040104185913.1211">def classify(obj):
    return _type2kind[type(obj)]
</t>
<t tx="ekr.20040104185913.1212">BTREE_EMPTY, BTREE_ONE, BTREE_NORMAL = range(3)

# If the BTree is empty, returns
#
#     BTREE_EMPTY, [], []
#
# If the BTree has only one bucket, sometimes returns
#
#     BTREE_ONE, bucket_state, None
#
# Else returns
#
#     BTREE_NORMAL, list of keys, list of kids
#
# and the list of kids has one more entry than the list of keys.
#
# BTree.__getstate__() docs:
#
# For an empty BTree (self-&gt;len == 0), None.
#
# For a BTree with one child (self-&gt;len == 1), and that child is a bucket,
# and that bucket has a NULL oid, a one-tuple containing a one-tuple
# containing the bucket's state:
#
#     (
#         (
#              child[0].__getstate__(),
#         ),
#     )
#
# Else a two-tuple.  The first element is a tuple interleaving the BTree's
# keys and direct children, of size 2*self-&gt;len - 1 (key[0] is unused and
# is not saved).  The second element is the firstbucket:
#
#     (
#          (child[0], key[1], child[1], key[2], child[2], ...,
#                                       key[len-1], child[len-1]),
#          self-&gt;firstbucket
#     )

_btree2bucket = {IOBTree: IOBucket,
                 IOTreeSet: IOSet,

                 IIBTree: IIBucket,
                 IITreeSet: IISet,

                 OIBTree: OIBucket,
                 OITreeSet: OISet,

                 OOBTree: OOBucket,
                 OOTreeSet: OOSet}

def crack_btree(t, is_mapping):
    state = t.__getstate__()
    if state is None:
        return BTREE_EMPTY, [], []

    assert isinstance(state, TupleType)
    if len(state) == 1:
        state = state[0]
        assert isinstance(state, TupleType) and len(state) == 1
        state = state[0]
        return BTREE_ONE, state, None

    assert len(state) == 2
    data, firstbucket = state
    n = len(data)
    assert n &amp; 1
    kids = []
    keys = []
    i = 0
    for x in data:
        if i &amp; 1:
            keys.append(x)
        else:
            kids.append(x)
        i += 1
    return BTREE_NORMAL, keys, kids
</t>
<t tx="ekr.20040104185913.1213"># Returns
#
#     keys, values  # for a mapping; len(keys) == len(values) in this case
# or
#     keys, []      # for a set
#
# bucket.__getstate__() docs:
#
# For a set bucket (self-&gt;values is NULL), a one-tuple or two-tuple.  The
# first element is a tuple of keys, of length self-&gt;len.  The second element
# is the next bucket, present if and only if next is non-NULL:
#
#     (
#          (keys[0], keys[1], ..., keys[len-1]),
#          &lt;self-&gt;next iff non-NULL&gt;
#     )
#
# For a mapping bucket (self-&gt;values is not NULL), a one-tuple or two-tuple.
# The first element is a tuple interleaving keys and values, of length
# 2 * self-&gt;len.  The second element is the next bucket, present iff next is
# non-NULL:
#
#     (
#          (keys[0], values[0], keys[1], values[1], ...,
#                               keys[len-1], values[len-1]),
#          &lt;self-&gt;next iff non-NULL&gt;
#     )

def crack_bucket(b, is_mapping):
    state = b.__getstate__()
    assert isinstance(state, TupleType)
    assert 1 &lt;= len(state) &lt;= 2
    data = state[0]
    if not is_mapping:
        return data, []
    keys = []
    values = []
    n = len(data)
    assert n &amp; 1 == 0
    i = 0
    for x in data:
        if i &amp; 1:
            values.append(x)
        else:
            keys.append(x)
        i += 1
    return keys, values
</t>
<t tx="ekr.20040104185913.1214">def type_and_adr(obj):
    return "%s (0x%x)" % (type(obj).__name__, id(obj))
</t>
<t tx="ekr.20040104185913.1215"># Walker implements a depth-first search of a BTree (or TreeSet or Set or
# Bucket).  Subclasses must implement the visit_btree() and visit_bucket()
# methods, and arrange to call the walk() method.  walk() calls the
# visit_XYZ() methods once for each node in the tree, in depth-first
# left-to-right order.

class Walker:
	@others
</t>
<t tx="ekr.20040104185913.1216">def __init__(self, obj):
    self.obj = obj
</t>
<t tx="ekr.20040104185913.1217"># obj is the BTree (BTree or TreeSet).
# path is a list of indices, from the root.  For example, if a BTree node
# is child[5] of child[3] of the root BTree, [3, 5].
# parent is the parent BTree object, or None if this is the root BTree.
# is_mapping is True for a BTree and False for a TreeSet.
# keys is a list of the BTree's internal keys.
# kids is a list of the BTree's children.
# If the BTree is an empty root node, keys == kids == [].
# Else len(kids) == len(keys) + 1.
# lo and hi are slice bounds on the values the elements of keys *should*
# lie in (lo inclusive, hi exclusive).  lo is None if there is no lower
# bound known, and hi is None if no upper bound is known.

def visit_btree(self, obj, path, parent, is_mapping,
                keys, kids, lo, hi):
    raise NotImplementedError
</t>
<t tx="ekr.20040104185913.1218"># obj is the bucket (Bucket or Set).
# path is a list of indices, from the root.  For example, if a bucket
# node is child[5] of child[3] of the root BTree, [3, 5].
# parent is the parent BTree object.
# is_mapping is True for a Bucket and False for a Set.
# keys is a list of the bucket's keys.
# values is a list of the bucket's values.
# If is_mapping is false, values == [].  Else len(keys) == len(values).
# lo and hi are slice bounds on the values the elements of keys *should*
# lie in (lo inclusive, hi exclusive).  lo is None if there is no lower
# bound known, and hi is None if no upper bound is known.

def visit_bucket(self, obj, path, parent, is_mapping,
                 keys, values, lo, hi):
    raise NotImplementedError
</t>
<t tx="ekr.20040104185913.1219">def walk(self):
    obj = self.obj
    path = []
    stack = [(obj, path, None, None, None)]
    while stack:
        obj, path, parent, lo, hi = stack.pop()
        kind, is_mapping = classify(obj)
        if kind is TYPE_BTREE:
            bkind, keys, kids = crack_btree(obj, is_mapping)
            if bkind is BTREE_NORMAL:
                # push the kids, in reverse order (so they're popped off
                # the stack in forward order)
                n = len(kids)
                for i in range(len(kids)-1, -1, -1):
                    newlo, newhi = lo,  hi
                    if i &lt; n-1:
                        newhi = keys[i]
                    if i &gt; 0:
                        newlo = keys[i-1]
                    stack.append((kids[i],
                                  path + [i],
                                  obj,
                                  newlo,
                                  newhi))

            elif bkind is BTREE_EMPTY:
                pass
            else:
                assert bkind is BTREE_ONE
                # Yuck.  There isn't a bucket object to pass on, as
                # the bucket state is embedded directly in the BTree
                # state.  Synthesize a bucket.
                assert kids is None   # and "keys" is really the bucket
                                      # state
                bucket = _btree2bucket[type(obj)]()
                bucket.__setstate__(keys)
                stack.append((bucket,
                              path + [0],
                              obj,
                              lo,
                              hi))
                keys = []
                kids = [bucket]

            self.visit_btree(obj,
                             path,
                             parent,
                             is_mapping,
                             keys,
                             kids,
                             lo,
                             hi)
        else:
            assert kind is TYPE_BUCKET
            keys, values = crack_bucket(obj, is_mapping)
            self.visit_bucket(obj,
                              path,
                              parent,
                              is_mapping,
                              keys,
                              values,
                              lo,
                              hi)
</t>
<t tx="ekr.20040104185913.1220">class Checker(Walker):
	@others
</t>
<t tx="ekr.20040104185913.1221">def __init__(self, obj):
    Walker.__init__(self, obj)
    self.errors = []
</t>
<t tx="ekr.20040104185913.1222">def check(self):
    self.walk()
    if self.errors:
        s = "Errors found in %s:" % type_and_adr(self.obj)
        self.errors.insert(0, s)
        s = "\n".join(self.errors)
        raise AssertionError(s)
</t>
<t tx="ekr.20040104185913.1223">def visit_btree(self, obj, path, parent, is_mapping,
                keys, kids, lo, hi):
    self.check_sorted(obj, path, keys, lo, hi)
</t>
<t tx="ekr.20040104185913.1224">def visit_bucket(self, obj, path, parent, is_mapping,
                 keys, values, lo, hi):
    self.check_sorted(obj, path, keys, lo, hi)
</t>
<t tx="ekr.20040104185913.1225">def check_sorted(self, obj, path, keys, lo, hi):
    i, n = 0, len(keys)
    for x in keys:
        if lo is not None and not lo &lt;= x:
            s = "key %r &lt; lower bound %r at index %d" % (x, lo, i)
            self.complain(s, obj, path)
        if hi is not None and not x &lt; hi:
            s = "key %r &gt;= upper bound %r at index %d" % (x, hi, i)
            self.complain(s, obj, path)
        if i &lt; n-1 and not x &lt; keys[i+1]:
            s = "key %r at index %d &gt;= key %r at index %d" % (
                x, i, keys[i+1], i+1)
            self.complain(s, obj, path)
        i += 1
</t>
<t tx="ekr.20040104185913.1226">def complain(self, msg, obj, path):
    s = "%s, in %s, path from root %s" % (
            msg,
            type_and_adr(obj),
            ".".join(map(str, path)))
    self.errors.append(s)
</t>
<t tx="ekr.20040104185913.1227">class Printer(Walker):
	@others
</t>
<t tx="ekr.20040104185913.1228">def __init__(self, obj):
    Walker.__init__(self, obj)
</t>
<t tx="ekr.20040104185913.1229">def display(self):
    self.walk()
</t>
<t tx="ekr.20040104185913.1230">def visit_btree(self, obj, path, parent, is_mapping,
                keys, kids, lo, hi):
    indent = "    " * len(path)
    print "%s%s %s with %d children" % (
              indent,
              ".".join(map(str, path)),
              type_and_adr(obj),
              len(kids))
    indent += "    "
    n = len(keys)
    for i in range(n):
        print "%skey %d: %r" % (indent, i, keys[i])
</t>
<t tx="ekr.20040104185913.1231">def visit_bucket(self, obj, path, parent, is_mapping,
                 keys, values, lo, hi):
    indent = "    " * len(path)
    print "%s%s %s with %d keys" % (
              indent,
              ".".join(map(str, path)),
              type_and_adr(obj),
              len(keys))
    indent += "    "
    n = len(keys)
    for i in range(n):
        print "%skey %d: %r" % (indent, i, keys[i]),
        if is_mapping:
            print "value %r" % (values[i],)
</t>
<t tx="ekr.20040104185913.1232">def check(btree):
    """Check internal value-based invariants in a BTree or TreeSet.

    The btree._check() method checks internal C-level pointer consistency.
    The check() function here checks value-based invariants:  whether the
    keys in leaf bucket and internal nodes are in strictly increasing order,
    and whether they all lie in their expected range.  The latter is a subtle
    invariant that can't be checked locally -- it requires propagating
    range info down from the root of the tree, and modifying it at each
    level for each child.

    Raises AssertionError if anything is wrong, with a string detail
    explaining the problems.  The entire tree is checked before
    AssertionError is raised, and the string detail may be large (depending
    on how much went wrong).
    """

    Checker(btree).check()
</t>
<t tx="ekr.20040104185913.1233">def display(btree):
    "Display the internal structure of a BTree, Bucket, TreeSet or Set."
    Printer(btree).display()
</t>
<t tx="ekr.20040104185913.1234">&lt;&lt; copyright &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.1236">def convert(old, new, threshold=200, f=None):
    "Utility for converting old btree to new"
    n=0
    for k, v in old.items():
        if f is not None: v=f(v)
        new[k]=v
        n=n+1
        if n &gt; threshold:
            get_transaction().commit(1)
            old._p_jar.cacheMinimize(3)
            n=0

    get_transaction().commit(1)
    old._p_jar.cacheMinimize(3)
</t>
<t tx="ekr.20040104185913.1237">@language c

&lt;&lt; c copyright &gt;&gt;

/* Revision information: $Id: sorters.c,v 1.4 2002/06/12 04:17:48 tim_one Exp $ */

/* The only routine here intended to be used outside the file is
   size_t sort_int4_nodups(int *p, size_t n)

   Sort the array of n ints pointed at by p, in place, and also remove
   duplicates.  Return the number of unique elements remaining, which occupy
   a contiguous and monotonically increasing slice of the array starting at p.

   Example:  If the input array is [3, 1, 2, 3, 1, 5, 2], sort_int4_nodups
   returns 4, and the first 4 elements of the array are changed to
   [1, 2, 3, 5].  The content of the remaining array positions is not defined.

   Notes:

   + This is specific to 4-byte signed ints, with endianness natural to the
     platform.

   + 4*n bytes of available heap memory are required for best speed.
*/

&lt;&lt; sorters #includes &gt;&gt;
&lt;&lt; sorters declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1238">#include &lt;stdlib.h&gt;
#include &lt;stddef.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
</t>
<t tx="ekr.20040104185913.1239">/* The type of array elements to be sorted.  Most of the routines don't
   care about the type, and will work fine for any scalar C type (provided
   they're recompiled with element_type appropriately redefined).  However,
   the radix sort has to know everything about the type's internal
   representation.
*/
typedef int element_type;
</t>
<t tx="ekr.20040104185913.1240">@ The radixsort is faster than the quicksort for large arrays, but radixsort  has high fixed overhead, making it a poor choice for small arrays. The  crossover point isn't critical, and is sensitive to things like compiler  and machine cache structure, so don't worry much about this.
@c

#define QUICKSORT_BEATS_RADIXSORT 800U

/* In turn, the quicksort backs off to an insertion sort for very small
   slices.  MAX_INSERTION is the largest slice quicksort leaves entirely to
   insertion.  Because this version of quicksort uses a median-of-3 rule for
   selecting a pivot, MAX_INSERTION must be at least 2 (so that quicksort
   has at least 3 values to look at in a slice).  Again, the exact value here
   isn't critical.
*/
#define MAX_INSERTION 25U

#if MAX_INSERTION &lt; 2U
#   error "MAX_INSERTION must be &gt;= 2"
#endif

/* LSB-first radix sort of the n elements in 'in'.
   'work' is work storage at least as large as 'in'.  Depending on how many
   swaps are done internally, the final result may come back in 'in' or 'work';
   and that pointer is returned.

   radixsort_int4 is specific to signed 4-byte ints, with natural machine
   endianness.
*/
static element_type*
radixsort_int4(element_type *in, element_type *work, size_t n)
{
	/* count[i][j] is the number of input elements that have byte value j
	   in byte position i, where byte position 0 is the LSB.  Note that
	   holding i fixed, the sum of count[i][j] over all j in range(256)
	   is n.
	*/
	size_t count[4][256];
	size_t i;
	int offset, offsetinc;

	/* Which byte position are we working on now?  0=LSB, 1, 2, ... */
	int bytenum;

	assert(sizeof(element_type) == 4);
	assert(in);
	assert(work);

	/* Compute all of count in one pass. */
	memset(count, 0, sizeof(count));
	for (i = 0; i &lt; n; ++i) {
		element_type const x = in[i];
		++count[0][(x      ) &amp; 0xff];
		++count[1][(x &gt;&gt;  8) &amp; 0xff];
		++count[2][(x &gt;&gt; 16) &amp; 0xff];
		++count[3][(x &gt;&gt; 24) &amp; 0xff];
	}

	/* For p an element_type* cast to char*, offset is how much farther we
	   have to go to get to the LSB of the element; this is 0 for little-
	   endian boxes and sizeof(element_type)-1 for big-endian.
	   offsetinc is 1 or -1, respectively, telling us which direction to go
	   from p+offset to get to the element's more-significant bytes.
	*/
	{
		int one = 1;
		if (*(char*)&amp;one) {
			/* Little endian. */
			offset = 0;
			offsetinc = 1;
		}
		else {
			/* Big endian. */
			offset = sizeof(element_type) - 1;
			offsetinc = -1;
		}
	}

	/* The radix sort. */
	for (bytenum = 0;
	     bytenum &lt; sizeof(element_type);
	     ++bytenum, offset += offsetinc) {

		/* Do a stable distribution sort on byte position bytenum,
		   from in to work.  index[i] tells us the work index at which
		   to store the next in element with byte value i.  pinbyte
		   points to the correct byte in the input array.
		*/
	     	size_t index[256];
		unsigned char* pinbyte;
		size_t total = 0;
		size_t *pcount = count[bytenum];

		/* Compute the correct output starting index for each possible
		   byte value.
		*/
		if (bytenum &lt; sizeof(element_type) - 1) {
			for (i = 0; i &lt; 256; ++i) {
				const size_t icount = pcount[i];
				index[i] = total;
				total += icount;
				if (icount == n)
					break;
			}
			if (i &lt; 256) {
				/* All bytes in the current position have value
				   i, so there's nothing to do on this pass.
				*/
				continue;
			}
		}
		else {
			/* The MSB of signed ints needs to be distributed
			   differently than the other bytes, in order
			   0x80, 0x81, ... 0xff, 0x00, 0x01, ... 0x7f
			*/
			for (i = 128; i &lt; 256; ++i) {
				const size_t icount = pcount[i];
				index[i] = total;
				total += icount;
				if (icount == n)
					break;
			}
			if (i &lt; 256)
				continue;
			for (i = 0; i &lt; 128; ++i) {
				const size_t icount = pcount[i];
				index[i] = total;
				total += icount;
				if (icount == n)
					break;
			}
			if (i &lt; 128)
				continue;
		}
		assert(total == n);

		/* Distribute the elements according to byte value.  Note that
		   this is where most of the time is spent.
		   Note:  The loop is unrolled 4x by hand, for speed.  This
		   may be a pessimization someday, but was a significant win
		   on my MSVC 6.0 timing tests.
		*/
		pinbyte = (unsigned char  *)in + offset;
		i = 0;
		/* Reduce number of elements to copy to a multiple of 4. */
		while ((n - i) &amp; 0x3) {
			unsigned char byte = *pinbyte;
			work[index[byte]++] = in[i];
			++i;
			pinbyte += sizeof(element_type);
		}
		for (; i &lt; n; i += 4, pinbyte += 4 * sizeof(element_type)) {
			unsigned char byte1 = *(pinbyte                           );
			unsigned char byte2 = *(pinbyte +     sizeof(element_type));
			unsigned char byte3 = *(pinbyte + 2 * sizeof(element_type));
			unsigned char byte4 = *(pinbyte + 3 * sizeof(element_type));

			element_type in1 = in[i  ];
			element_type in2 = in[i+1];
			element_type in3 = in[i+2];
			element_type in4 = in[i+3];

			work[index[byte1]++] = in1;
			work[index[byte2]++] = in2;
			work[index[byte3]++] = in3;
			work[index[byte4]++] = in4;
		}
		/* Swap in and work (just a pointer swap). */
		{
			element_type *temp = in;
			in = work;
			work = temp;
		}
	}

	return in;
}
</t>
<t tx="ekr.20040104185913.1241">@ Remove duplicates from sorted array in, storing exactly one of each distinct  element value into sorted array out. It's OK (and expected!) for in == out,  but otherwise the n elements beginning at in must not overlap with the n  beginning at out.  Return the number of elements in out.
@c

static size_t
uniq(element_type *out, element_type *in, size_t n)
{
	size_t i;
	element_type lastelt;
	element_type *pout;

	assert(out);
	assert(in);
	if (n == 0)
		return 0;

	/* i &lt;- first index in 'in' that contains a duplicate.
	   in[0], in[1], ... in[i-1] are unique, but in[i-1] == in[i].
	   Set i to n if everything is unique.
	*/
	for (i = 1; i &lt; n; ++i) {
		if (in[i-1] == in[i])
			break;
	}

	/* in[:i] is unique; copy to out[:i] if needed. */
	assert(i &gt; 0);
	if (in != out)
		memcpy(out, in, i * sizeof(element_type));

	pout = out + i;
	lastelt = in[i-1];  /* safe even when i == n */
	for (++i; i &lt; n; ++i) {
		element_type elt = in[i];
		if (elt != lastelt)
			*pout++ = lastelt = elt;
	}
	return pout - out;
}
</t>
<t tx="ekr.20040104185913.1242">#if 0
/* insertionsort is no longer referenced directly, but I'd like to keep
 *  the code here just in case.
 */

/* Straight insertion sort of the n elements starting at 'in'. */
static void
insertionsort(element_type *in, size_t n)
{
	element_type *p, *q;
	element_type minimum;  /* smallest seen so far */
	element_type *plimit = in + n;

	assert(in);
	if (n &lt; 2)
		return;

	minimum = *in;
	for (p = in+1; p &lt; plimit; ++p) {
		/* *in &lt;= *(in+1) &lt;= ... &lt;= *(p-1).  Slide *p into place. */
		element_type thiselt = *p;
		if (thiselt &lt; minimum) {
			/* This is a new minimum.  This saves p-in compares
			   when it happens, but should happen so rarely that
			   it's not worth checking for its own sake:  the
			   point is that the far more popular 'else' branch can
			   exploit that thiselt is *not* the smallest so far.
			*/
			memmove(in+1, in, (p - in) * sizeof(*in));
			*in = minimum = thiselt;
		}
		else {
			/* thiselt &gt;= minimum, so the loop will find a q
			   with *q &lt;= thiselt.  This saves testing q &gt;= in
			   on each trip.  It's such a simple loop that saving
			   a per-trip test is a major speed win.
			*/
			for (q = p-1; *q &gt; thiselt; --q)
				*(q+1) = *q;
			*(q+1) = thiselt;
		}
	}
}
</t>
<t tx="ekr.20040104185913.1243">#endif

/* The maximum number of elements in the pending-work stack quicksort
   maintains.  The maximum stack depth is approximately log2(n), so
   arrays of size up to approximately MAX_INSERTION * 2**STACKSIZE can be
   sorted.  The memory burden for the stack is small, so better safe than
   sorry.
*/
#define STACKSIZE 60

/* A _stacknode remembers a contiguous slice of an array that needs to sorted.
   lo must be &lt;= hi, and, unlike Python array slices, this includes both ends.
*/
struct _stacknode {
	element_type *lo;
	element_type *hi;
};

static void
quicksort(element_type *plo, size_t n)
{
	element_type *phi;

	/* Swap two array elements. */
	element_type _temp;
#define SWAP(P, Q) (_temp = *(P), *(P) = *(Q), *(Q) = _temp)

	/* Stack of pending array slices to be sorted. */
	struct _stacknode stack[STACKSIZE];
	struct _stacknode *stackfree = stack;	/* available stack slot */

	/* Push an array slice on the pending-work stack. */
#define PUSH(PLO, PHI)					\
	do {						\
		assert(stackfree - stack &lt; STACKSIZE);	\
		assert((PLO) &lt;= (PHI));			\
		stackfree-&gt;lo = (PLO);			\
		stackfree-&gt;hi = (PHI);			\
		++stackfree;				\
	} while(0)

	assert(plo);
	phi = plo + n - 1;

	for (;;) {
		element_type pivot;
		element_type *pi, *pj;

		assert(plo &lt;= phi);
		n = phi - plo + 1;
		if (n &lt;= MAX_INSERTION) {
			/* Do a small insertion sort.  Contra Knuth, we do
			   this now instead of waiting until the end, because
			   this little slice is likely still in cache now.
			*/
			element_type *p, *q;
			element_type minimum = *plo;

			for (p = plo+1; p &lt;= phi; ++p) {
				/* *plo &lt;= *(plo+1) &lt;= ... &lt;= *(p-1).
				   Slide *p into place. */
				element_type thiselt = *p;
				if (thiselt &lt; minimum) {
					/* New minimum. */
					memmove(plo+1,
						plo,
						(p - plo) * sizeof(*p));
					*plo = minimum = thiselt;
				}
				else {
					/* thiselt &gt;= minimum, so the loop will
					   find a q with *q &lt;= thiselt.
					*/
					for (q = p-1; *q &gt; thiselt; --q)
						*(q+1) = *q;
					*(q+1) = thiselt;
				}
			}

			/* Pop another slice off the stack. */
			if (stack == stackfree)
				break;	/* no more slices -- we're done */
			--stackfree;
			plo = stackfree-&gt;lo;
			phi = stackfree-&gt;hi;
			continue;
		}

		/* Parition the slice.
		   For pivot, take the median of the leftmost, rightmost, and
		   middle elements.  First sort those three; then the median
		   is the middle one.  For technical reasons, the middle
		   element is swapped to plo+1 first (see Knuth Vol 3 Ed 2
		   section 5.2.2 exercise 55 -- reverse-sorted arrays can
		   take quadratic time otherwise!).
		*/
		{
			element_type *plop1 = plo + 1;
			element_type *pmid = plo + (n &gt;&gt; 1);

			assert(plo &lt; pmid &amp;&amp; pmid &lt; phi);
			SWAP(plop1, pmid);

			/* Sort plo, plop1, phi. */
			/* Smaller of rightmost two -&gt; middle. */
			if (*plop1 &gt; *phi)
				SWAP(plop1, phi);
			/* Smallest of all -&gt; left; if plo is already the
			   smallest, the sort is complete.
			*/
			if (*plo &gt; *plop1) {
				SWAP(plo, plop1);
				/* Largest of all -&gt; right. */
				if (*plop1 &gt; *phi)
					SWAP(plop1, phi);
			}
			pivot = *plop1;
			pi = plop1;
		}
		assert(*plo &lt;= pivot);
		assert(*pi == pivot);
		assert(*phi &gt;= pivot);
		pj = phi;

		/* Partition wrt pivot.  This is the time-critical part, and
		   nearly every decision in the routine aims at making this
		   loop as fast as possible -- even small points like
		   arranging that all loop tests can be done correctly at the
		   bottoms of loops instead of the tops, and that pointers can
		   be derefenced directly as-is (without fiddly +1 or -1).
		   The aim is to make the C here so simple that a compiler
		   has a good shot at doing as well as hand-crafted assembler.
		*/
		for (;;) {
			/* Invariants:
			   1. pi &lt; pj.
			   2. All elements at plo, plo+1 .. pi are &lt;= pivot.
			   3. All elements at pj, pj+1 .. phi are &gt;= pivot.
			   4. There is an element &gt;= pivot to the right of pi.
			   5. There is an element &lt;= pivot to the left of pj.

			   Note that #4 and #5 save us from needing to check
			   that the pointers stay in bounds.
			*/
			assert(pi &lt; pj);

			do { ++pi; } while (*pi &lt; pivot);
			assert(pi &lt;= pj);

			do { --pj; } while (*pj &gt; pivot);
			assert(pj &gt;= pi - 1);

			if (pi &lt; pj)
				SWAP(pi, pj);
			else
				break;
		}
		assert(plo+1 &lt; pi &amp;&amp; pi &lt;= phi);
		assert(plo &lt; pj &amp;&amp; pj &lt; phi);
		assert(*pi &gt;= pivot);
		assert( (pi == pj &amp;&amp; *pj == pivot) ||
			(pj + 1 == pi &amp;&amp; *pj &lt;= pivot) );

		/* Swap pivot into its final position, pj. */
		assert(plo[1] == pivot);
		plo[1] = *pj;
		*pj = pivot;

		/* Subfiles are from plo to pj-1 inclusive, and pj+1 to phi
		   inclusive.  Push the larger one, and loop back to do the
		   smaller one directly.
		*/
		if (pj - plo &gt;= phi - pj) {
			PUSH(plo, pj-1);
			plo = pj+1;
		}
		else {
			PUSH(pj+1, phi);
			phi = pj-1;
		}
	}

#undef PUSH
#undef SWAP
}
</t>
<t tx="ekr.20040104185913.1244">@ Sort p and remove duplicates, as fast as we can.
@c

static size_t
sort_int4_nodups(int *p, size_t n)
{
	size_t nunique;
	element_type *work;

	assert(sizeof(int) == sizeof(element_type));
	assert(p);

	/* Use quicksort if the array is small, OR if malloc can't find
	   enough temp memory for radixsort.
	*/
	work = NULL;
	if (n &gt; QUICKSORT_BEATS_RADIXSORT)
		work = (element_type *)malloc(n * sizeof(element_type));

	if (work) {
		element_type *out = radixsort_int4(p, work, n);
		nunique = uniq(p, out, n);
		free(work);
	}
	else {
		quicksort(p, n);
		nunique = uniq(p, p, n);
	}

	return nunique;
}
</t>
<t tx="ekr.20040104185913.1245"></t>
<t tx="ekr.20040104185913.1246"># If tests is a package, debugging is a bit easier.
</t>
<t tx="ekr.20040104185913.1247">&lt;&lt; testBTrees declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.1248">&lt;&lt; copyright &gt;&gt;

import sys, os, time, random
import os, sys

from BTrees.OOBTree import OOBTree, OOBucket, OOSet, OOTreeSet
from BTrees.IOBTree import IOBTree, IOBucket, IOSet, IOTreeSet
from BTrees.IIBTree import IIBTree, IIBucket, IISet, IITreeSet
from BTrees.OIBTree import OIBTree, OIBucket, OISet, OITreeSet

from BTrees.check import check

from unittest import TestCase, TestSuite, TextTestRunner, makeSuite

from glob import glob

from ZODB.tests.StorageTestBase import removefs

</t>
<t tx="ekr.20040104185913.1249">class Base:
    """ Tests common to all types: sets, buckets, and BTrees """
	@others
</t>
<t tx="ekr.20040104185913.1250">def tearDown(self):
    self.t = None
    del self.t
</t>
<t tx="ekr.20040104185913.1251">def _getRoot(self):
    from ZODB.FileStorage import FileStorage
    from ZODB.DB import DB
    self._fsname = 'fs_tmp__%s' % os.getpid()
    s = FileStorage(self._fsname)
    db = DB(s)
    root = db.open().root()
    return root
</t>
<t tx="ekr.20040104185913.1252">def _closeDB(self, root):
    if root is not None:
        root._p_jar._db.close()
</t>
<t tx="ekr.20040104185913.1253">def _delDB(self):
    removefs(self._fsname)
</t>
<t tx="ekr.20040104185913.1254">def testLoadAndStore(self):
    for i in 0, 10, 1000:
        t = self.t.__class__()
        self._populate(t, i)
        root = None
        try:
            root = self._getRoot()
            root[i] = t
            get_transaction().commit()
        except:
            self._closeDB(root)
            self._delDB()
            raise

        self._closeDB(root)

        root = None
        try:
            root = self._getRoot()
            #XXX BTree stuff doesn't implement comparison
            if hasattr(t, 'items'):
                self.assertEqual(list(root[i].items()) , list(t.items()))
            else:
                self.assertEqual(list(root[i].keys()) , list(t.keys()))
        finally:
            self._closeDB(root)
            self._delDB()
</t>
<t tx="ekr.20040104185913.1255">def testGhostUnghost(self):
    for i in 0, 10, 1000:
        t = self.t.__class__()
        self._populate(t, i)
        root = None
        try:
            root = self._getRoot()
            root[i] = t
            get_transaction().commit()
        except:
            self._closeDB(root)
            self._delDB()
            raise

        self._closeDB(root)

        root = None
        try:
            root = self._getRoot()
            root[i]._p_changed = None
            get_transaction().commit()
            if hasattr(t,'items'):
                self.assertEqual(list(root[i].items()) , list(t.items()))
            else:
                self.assertEqual(list(root[i].keys()) , list(t.keys()))
        finally:
            self._closeDB(root)
            self._delDB()
</t>
<t tx="ekr.20040104185913.1256">class MappingBase(Base):
    """ Tests common to mappings (buckets, btrees) """
	@others
</t>
<t tx="ekr.20040104185913.1257">def _populate(self, t, l):
    # Make some data
    for i in range(l): t[i]=i
</t>
<t tx="ekr.20040104185913.1258">def testGetItemFails(self):
    self.assertRaises(KeyError, self._getitemfail)
</t>
<t tx="ekr.20040104185913.1259">def _getitemfail(self):
    return self.t[1]
</t>
<t tx="ekr.20040104185913.1260">def testGetReturnsDefault(self):
    self.assertEqual(self.t.get(1) , None)
    self.assertEqual(self.t.get(1, 'foo') , 'foo')
</t>
<t tx="ekr.20040104185913.1261">def testSetItemGetItemWorks(self):
    self.t[1] = 1
    a = self.t[1]
    self.assertEqual(a , 1, `a`)
</t>
<t tx="ekr.20040104185913.1262">def testReplaceWorks(self):
    self.t[1] = 1
    self.assertEqual(self.t[1] , 1, self.t[1])
    self.t[1] = 2
    self.assertEqual(self.t[1] , 2, self.t[1])
</t>
<t tx="ekr.20040104185913.1263">def testLen(self):
    added = {}
    r = range(1000)
    for x in r:
        k = random.choice(r)
        self.t[k] = x
        added[k] = x
    addl = added.keys()
    self.assertEqual(len(self.t) , len(addl), len(self.t))
</t>
<t tx="ekr.20040104185913.1264">def testHasKeyWorks(self):
    self.t[1] = 1
    self.assert_(self.t.has_key(1))
</t>
<t tx="ekr.20040104185913.1265">def testValuesWorks(self):
    for x in range(100):
        self.t[x] = x*x
    v = self.t.values()
    for i in range(100):
        self.assertEqual(v[i],i*i , (i*i,i))
</t>
<t tx="ekr.20040104185913.1266">def testValuesWorks1(self):

    for x in range(100):
        self.t[99-x] = x

    for x in range(40):
        lst = list(self.t.values(0+x,99-x))
        lst.sort()
        self.assertEqual(lst,range(0+x,99-x+1))
</t>
<t tx="ekr.20040104185913.1267">def testKeysWorks(self):
    for x in range(100):
        self.t[x] = x
    v = self.t.keys()
    i = 0
    for x in v:
        self.assertEqual(x,i)
        i = i + 1

    for x in range(40):
        lst = self.t.keys(0+x,99-x)
        self.assertEqual(list(lst),range(0+x,99-x+1))

    # BTree items must lie about their lengths, so we convert to list
    self.assertEqual(len(v) , 100, len(v))
</t>
<t tx="ekr.20040104185913.1268">    #self.assertEqual(len(v) , 100, len(v))

def testItemsWorks(self):
    for x in range(100):
        self.t[x] = x
    v = self.t.items()
    i = 0
    for x in v:
        self.assertEqual(x[0] , i, (x[0], i))
        self.assertEqual(x[1] , i, (x[0], i))
        i = i + 1
</t>
<t tx="ekr.20040104185913.1269">def testDeleteInvalidKeyRaisesKeyError(self):
    self.assertRaises(KeyError, self._deletefail)
</t>
<t tx="ekr.20040104185913.1270">def _deletefail(self):
    del self.t[1]
</t>
<t tx="ekr.20040104185913.1271">def testMaxKeyMinKey(self):
    self.t[7] = 6
    self.t[3] = 10
    self.t[8] = 12
    self.t[1] = 100
    self.t[5] = 200
    self.t[10] = 500
    self.t[6] = 99
    self.t[4] = 150
    del self.t[7]
    t = self.t
    self.assertEqual(t.maxKey() , 10)
    self.assertEqual(t.maxKey(6) , 6)
    self.assertEqual(t.maxKey(9) , 8)
    self.assertEqual(t.minKey() , 1)
    self.assertEqual(t.minKey(3) , 3)
    self.assertEqual(t.minKey(9) , 10)
</t>
<t tx="ekr.20040104185913.1272">def testClear(self):
    r = range(100)
    for x in r:
        rnd = random.choice(r)
        self.t[rnd] = 0
    self.t.clear()
    diff = lsubtract(list(self.t.keys()), [])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1273">def testUpdate(self):
    d={}
    l=[]
    for i in range(10000):
        k=random.randrange(-2000, 2001)
        d[k]=i
        l.append((k, i))

    items=d.items()
    items.sort()

    self.t.update(d)
    self.assertEqual(list(self.t.items()) , items)

    self.t.clear()
    self.assertEqual(list(self.t.items()) , [])

    self.t.update(l)
    self.assertEqual(list(self.t.items()) , items)
</t>
<t tx="ekr.20040104185913.1274">def testEmptyRangeSearches(self):
    t = self.t
    t.update([(1,1), (5,5), (9,9)])
    self.assertEqual(list(t.keys(-6,-4)), [], list(t.keys(-6,-4)))
    self.assertEqual(list(t.keys(2,4)), [], list(t.keys(2,4)))
    self.assertEqual(list(t.keys(6,8)), [], list(t.keys(6,8)))
    self.assertEqual(list(t.keys(10,12)), [], list(t.keys(10,12)))
    self.assertEqual(list(t.keys(9, 1)), [], list(t.keys(9, 1)))

    # For IITreeSets, this one was returning 31 for len(keys), and
    # list(keys) produced a list with 100 elements.
    t.clear()
    t.update(zip(range(300), range(300)))
    keys = t.keys(200, 50)
    self.assertEqual(len(keys), 0)
    self.assertEqual(list(keys), [])
</t>
<t tx="ekr.20040104185913.1275">def testSlicing(self):
    # Test that slicing of .keys()/.values()/.items() works exactly the
    # same way as slicing a Python list with the same contents.
    # This tests fixes to several bugs in this area, starting with
    # http://collector.zope.org/Zope/419,
    # "BTreeItems slice contains 1 too many elements".

    t = self.t
    for n in range(10):
        t.clear()
        self.assertEqual(len(t), 0)

        keys = []
        values = []
        items = []
        for key in range(n):
            value = -2 * key
            t[key] = value
            keys.append(key)
            values.append(value)
            items.append((key, value))
        self.assertEqual(len(t), n)

        kslice = t.keys()
        vslice = t.values()
        islice = t.items()
        self.assertEqual(len(kslice), n)
        self.assertEqual(len(vslice), n)
        self.assertEqual(len(islice), n)

        # Test whole-structure slices.
        x = kslice[:]
        self.assertEqual(list(x), keys[:])

        x = vslice[:]
        self.assertEqual(list(x), values[:])

        x = islice[:]
        self.assertEqual(list(x), items[:])

        for lo in range(-2*n, 2*n+1):
            # Test one-sided slices.
            x = kslice[:lo]
            self.assertEqual(list(x), keys[:lo])
            x = kslice[lo:]
            self.assertEqual(list(x), keys[lo:])

            x = vslice[:lo]
            self.assertEqual(list(x), values[:lo])
            x = vslice[lo:]
            self.assertEqual(list(x), values[lo:])

            x = islice[:lo]
            self.assertEqual(list(x), items[:lo])
            x = islice[lo:]
            self.assertEqual(list(x), items[lo:])

            for hi in range(-2*n, 2*n+1):
                # Test two-sided slices.
                x = kslice[lo:hi]
                self.assertEqual(list(x), keys[lo:hi])

                x = vslice[lo:hi]
                self.assertEqual(list(x), values[lo:hi])

                x = islice[lo:hi]
                self.assertEqual(list(x), items[lo:hi])

    # The specific test case from Zope collector 419.
    t.clear()
    for i in xrange(100):
        t[i] = 1
    tslice = t.items()[20:80]
    self.assertEqual(len(tslice), 60)
    self.assertEqual(list(tslice), zip(range(20, 80), [1]*60))
</t>
<t tx="ekr.20040104185913.1276">def testBadUpdateTupleSize(self):
    # This one silently ignored the excess in Zope3.
    try:
        self.t.update([(1, 2, 3)])
    except TypeError:
        pass
    else:
        self.fail("update() with 3-tuple didn't complain")

    # This one dumped core in Zope3.
    try:
        self.t.update([(1,)])
    except TypeError:
        pass
    else:
        self.fail("update() with 1-tuple didn't complain")

    # This one should simply succeed.
    self.t.update([(1, 2)])
    self.assertEqual(list(self.t.items()), [(1, 2)])
</t>
<t tx="ekr.20040104185913.1277">class NormalSetTests(Base):
    """ Test common to all set types """
	@others
</t>
<t tx="ekr.20040104185913.1278">def _populate(self, t, l):
    # Make some data
    t.update(range(l))
</t>
<t tx="ekr.20040104185913.1279">def testInsertReturnsValue(self):
    t = self.t
    self.assertEqual(t.insert(5) , 1)
</t>
<t tx="ekr.20040104185913.1280">def testDuplicateInsert(self):
    t = self.t
    t.insert(5)
    self.assertEqual(t.insert(5) , 0)
</t>
<t tx="ekr.20040104185913.1281">def testInsert(self):
    t = self.t
    t.insert(1)
    self.assert_(t.has_key(1))
</t>
<t tx="ekr.20040104185913.1282">def testBigInsert(self):
    t = self.t
    r = xrange(10000)
    for x in r:
        t.insert(x)
    for x in r:
        self.assert_(t.has_key(x))
</t>
<t tx="ekr.20040104185913.1283">def testRemoveSucceeds(self):
    t = self.t
    r = xrange(10000)
    for x in r: t.insert(x)
    for x in r: t.remove(x)
</t>
<t tx="ekr.20040104185913.1284">def testRemoveFails(self):
    self.assertRaises(KeyError, self._removenonexistent)
</t>
<t tx="ekr.20040104185913.1285">def _removenonexistent(self):
    self.t.remove(1)
</t>
<t tx="ekr.20040104185913.1286">def testHasKeyFails(self):
    t = self.t
    self.assert_(not t.has_key(1))
</t>
<t tx="ekr.20040104185913.1287">def testKeys(self):
    t = self.t
    r = xrange(1000)
    for x in r: t.insert(x)
    diff = lsubtract(t.keys(), r)
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1288">def testClear(self):
    t = self.t
    r = xrange(1000)
    for x in r: t.insert(x)
    t.clear()
    diff = lsubtract(t.keys(), [])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1289">def testMaxKeyMinKey(self):
    t = self.t
    t.insert(1)
    t.insert(2)
    t.insert(3)
    t.insert(8)
    t.insert(5)
    t.insert(10)
    t.insert(6)
    t.insert(4)
    self.assertEqual(t.maxKey() , 10)
    self.assertEqual(t.maxKey(6) , 6)
    self.assertEqual(t.maxKey(9) , 8)
    self.assertEqual(t.minKey() , 1)
    self.assertEqual(t.minKey(3) , 3)
    self.assertEqual(t.minKey(9) , 10)
</t>
<t tx="ekr.20040104185913.1290">def testUpdate(self):
    d={}
    l=[]
    for i in range(10000):
        k=random.randrange(-2000, 2001)
        d[k]=i
        l.append(k)

    items=d.keys()
    items.sort()

    self.t.update(l)
    self.assertEqual(list(self.t.keys()) , items)
</t>
<t tx="ekr.20040104185913.1291">def testEmptyRangeSearches(self):
    t = self.t
    t.update([1, 5, 9])
    self.assertEqual(list(t.keys(-6,-4)), [], list(t.keys(-6,-4)))
    self.assertEqual(list(t.keys(2,4)), [], list(t.keys(2,4)))
    self.assertEqual(list(t.keys(6,8)), [], list(t.keys(6,8)))
    self.assertEqual(list(t.keys(10,12)), [], list(t.keys(10,12)))
    self.assertEqual(list(t.keys(9,1)), [], list(t.keys(9,1)))

    # For IITreeSets, this one was returning 31 for len(keys), and
    # list(keys) produced a list with 100 elements.
    t.clear()
    t.update(range(300))
    keys = t.keys(200, 50)
    self.assertEqual(len(keys), 0)
    self.assertEqual(list(keys), [])
</t>
<t tx="ekr.20040104185913.1292">def testSlicing(self):
    # Test that slicing of .keys() works exactly the same way as slicing
    # a Python list with the same contents.

    t = self.t
    for n in range(10):
        t.clear()
        self.assertEqual(len(t), 0)

        keys = range(10*n, 11*n)
        t.update(keys)
        self.assertEqual(len(t), n)

        kslice = t.keys()
        self.assertEqual(len(kslice), n)

        # Test whole-structure slices.
        x = kslice[:]
        self.assertEqual(list(x), keys[:])

        for lo in range(-2*n, 2*n+1):
            # Test one-sided slices.
            x = kslice[:lo]
            self.assertEqual(list(x), keys[:lo])
            x = kslice[lo:]
            self.assertEqual(list(x), keys[lo:])

            for hi in range(-2*n, 2*n+1):
                # Test two-sided slices.
                x = kslice[lo:hi]
                self.assertEqual(list(x), keys[lo:hi])
</t>
<t tx="ekr.20040104185913.1293">class ExtendedSetTests(NormalSetTests):
	@others
</t>
<t tx="ekr.20040104185913.1294">def testLen(self):
    t = self.t
    r = xrange(10000)
    for x in r: t.insert(x)
    self.assertEqual(len(t) , 10000, len(t))
</t>
<t tx="ekr.20040104185913.1295">def testGetItem(self):
    t = self.t
    r = xrange(10000)
    for x in r: t.insert(x)
    for x in r:
        self.assertEqual(t[x] , x)
</t>
<t tx="ekr.20040104185913.1296">class BucketTests(MappingBase):
    """ Tests common to all buckets """
	&lt;&lt; class BucketTests declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1297">pass

</t>
<t tx="ekr.20040104185913.1298">class BTreeTests(MappingBase):
    """ Tests common to all BTrees """
	@others
</t>
<t tx="ekr.20040104185913.1299">def tearDown(self):
    self.t._check()
    check(self.t)
    MappingBase.tearDown(self)
</t>
<t tx="ekr.20040104185913.1300">def testDeleteNoChildrenWorks(self):
    self.t[5] = 6
    self.t[2] = 10
    self.t[6] = 12
    self.t[1] = 100
    self.t[3] = 200
    self.t[10] = 500
    self.t[4] = 99
    del self.t[4]
    diff = lsubtract(self.t.keys(), [1,2,3,5,6,10])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1301">def testDeleteOneChildWorks(self):
    self.t[5] = 6
    self.t[2] = 10
    self.t[6] = 12
    self.t[1] = 100
    self.t[3] = 200
    self.t[10] = 500
    self.t[4] = 99
    del self.t[3]
    diff = lsubtract(self.t.keys(), [1,2,4,5,6,10])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1302">def testDeleteTwoChildrenNoInorderSuccessorWorks(self):
    self.t[5] = 6
    self.t[2] = 10
    self.t[6] = 12
    self.t[1] = 100
    self.t[3] = 200
    self.t[10] = 500
    self.t[4] = 99
    del self.t[2]
    diff = lsubtract(self.t.keys(), [1,3,4,5,6,10])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1303">def testDeleteTwoChildrenInorderSuccessorWorks(self):
    # 7, 3, 8, 1, 5, 10, 6, 4 -- del 3
    self.t[7] = 6
    self.t[3] = 10
    self.t[8] = 12
    self.t[1] = 100
    self.t[5] = 200
    self.t[10] = 500
    self.t[6] = 99
    self.t[4] = 150
    del self.t[3]
    diff = lsubtract(self.t.keys(), [1,4,5,6,7,8,10])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1304">def testDeleteRootWorks(self):
    # 7, 3, 8, 1, 5, 10, 6, 4 -- del 7
    self.t[7] = 6
    self.t[3] = 10
    self.t[8] = 12
    self.t[1] = 100
    self.t[5] = 200
    self.t[10] = 500
    self.t[6] = 99
    self.t[4] = 150
    del self.t[7]
    diff = lsubtract(self.t.keys(), [1,3,4,5,6,8,10])
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1305">def testRandomNonOverlappingInserts(self):
    added = {}
    r = range(100)
    for x in r:
        k = random.choice(r)
        if not added.has_key(k):
            self.t[k] = x
            added[k] = 1
    addl = added.keys()
    addl.sort()
    diff = lsubtract(list(self.t.keys()), addl)
    self.assertEqual(diff , [], (diff, addl, list(self.t.keys())))
</t>
<t tx="ekr.20040104185913.1306">def testRandomOverlappingInserts(self):
    added = {}
    r = range(100)
    for x in r:
        k = random.choice(r)
        self.t[k] = x
        added[k] = 1
    addl = added.keys()
    addl.sort()
    diff = lsubtract(self.t.keys(), addl)
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1307">def testRandomDeletes(self):
    r = range(1000)
    added = []
    for x in r:
        k = random.choice(r)
        self.t[k] = x
        added.append(k)
    deleted = []
    for x in r:
        k = random.choice(r)
        if self.t.has_key(k):
            del self.t[k]
            deleted.append(k)
            if self.t.has_key(k):
                raise "had problems deleting %s" % k
    badones = []
    for x in deleted:
        if self.t.has_key(x):
            badones.append(x)
    self.assertEqual(badones , [], (badones, added, deleted))
</t>
<t tx="ekr.20040104185913.1308">def testTargetedDeletes(self):
    r = range(1000)
    for x in r:
        k = random.choice(r)
        self.t[k] = x
    for x in r:
        try:
            del self.t[x]
        except KeyError:
            pass
    self.assertEqual(realseq(self.t.keys()) , [], realseq(self.t.keys()))
</t>
<t tx="ekr.20040104185913.1309">def testPathologicalRightBranching(self):
    r = range(1000)
    for x in r:
        self.t[x] = 1
    self.assertEqual(realseq(self.t.keys()) , r, realseq(self.t.keys()))
    for x in r:
        del self.t[x]
    self.assertEqual(realseq(self.t.keys()) , [], realseq(self.t.keys()))
</t>
<t tx="ekr.20040104185913.1310">def testPathologicalLeftBranching(self):
    r = range(1000)
    revr = r[:]
    revr.reverse()
    for x in revr:
        self.t[x] = 1
    self.assertEqual(realseq(self.t.keys()) , r, realseq(self.t.keys()))

    for x in revr:
        del self.t[x]
    self.assertEqual(realseq(self.t.keys()) , [], realseq(self.t.keys()))
</t>
<t tx="ekr.20040104185913.1311">def testSuccessorChildParentRewriteExerciseCase(self):
    add_order = [
        85, 73, 165, 273, 215, 142, 233, 67, 86, 166, 235, 225, 255,
        73, 175, 171, 285, 162, 108, 28, 283, 258, 232, 199, 260,
        298, 275, 44, 261, 291, 4, 181, 285, 289, 216, 212, 129,
        243, 97, 48, 48, 159, 22, 285, 92, 110, 27, 55, 202, 294,
        113, 251, 193, 290, 55, 58, 239, 71, 4, 75, 129, 91, 111,
        271, 101, 289, 194, 218, 77, 142, 94, 100, 115, 101, 226,
        17, 94, 56, 18, 163, 93, 199, 286, 213, 126, 240, 245, 190,
        195, 204, 100, 199, 161, 292, 202, 48, 165, 6, 173, 40, 218,
        271, 228, 7, 166, 173, 138, 93, 22, 140, 41, 234, 17, 249,
        215, 12, 292, 246, 272, 260, 140, 58, 2, 91, 246, 189, 116,
        72, 259, 34, 120, 263, 168, 298, 118, 18, 28, 299, 192, 252,
        112, 60, 277, 273, 286, 15, 263, 141, 241, 172, 255, 52, 89,
        127, 119, 255, 184, 213, 44, 116, 231, 173, 298, 178, 196,
        89, 184, 289, 98, 216, 115, 35, 132, 278, 238, 20, 241, 128,
        179, 159, 107, 206, 194, 31, 260, 122, 56, 144, 118, 283,
        183, 215, 214, 87, 33, 205, 183, 212, 221, 216, 296, 40,
        108, 45, 188, 139, 38, 256, 276, 114, 270, 112, 214, 191,
        147, 111, 299, 107, 101, 43, 84, 127, 67, 205, 251, 38, 91,
        297, 26, 165, 187, 19, 6, 73, 4, 176, 195, 90, 71, 30, 82,
        139, 210, 8, 41, 253, 127, 190, 102, 280, 26, 233, 32, 257,
        194, 263, 203, 190, 111, 218, 199, 29, 81, 207, 18, 180,
        157, 172, 192, 135, 163, 275, 74, 296, 298, 265, 105, 191,
        282, 277, 83, 188, 144, 259, 6, 173, 81, 107, 292, 231,
        129, 65, 161, 113, 103, 136, 255, 285, 289, 1
        ]
    delete_order = [
        276, 273, 12, 275, 2, 286, 127, 83, 92, 33, 101, 195,
        299, 191, 22, 232, 291, 226, 110, 94, 257, 233, 215, 184,
        35, 178, 18, 74, 296, 210, 298, 81, 265, 175, 116, 261,
        212, 277, 260, 234, 6, 129, 31, 4, 235, 249, 34, 289, 105,
        259, 91, 93, 119, 7, 183, 240, 41, 253, 290, 136, 75, 292,
        67, 112, 111, 256, 163, 38, 126, 139, 98, 56, 282, 60, 26,
        55, 245, 225, 32, 52, 40, 271, 29, 252, 239, 89, 87, 205,
        213, 180, 97, 108, 120, 218, 44, 187, 196, 251, 202, 203,
        172, 28, 188, 77, 90, 199, 297, 282, 141, 100, 161, 216,
        73, 19, 17, 189, 30, 258
        ]
    for x in add_order:
        self.t[x] = 1
    for x in delete_order:
        try: del self.t[x]
        except KeyError:
            if self.t.has_key(x): self.assertEqual(1,2,"failed to delete %s" % x)
</t>
<t tx="ekr.20040104185913.1312">def testRangeSearchAfterSequentialInsert(self):
    r = range(100)
    for x in r:
        self.t[x] = 0
    diff = lsubtract(list(self.t.keys(0, 100)), r)
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1313">def testRangeSearchAfterRandomInsert(self):
    r = range(100)
    a = {}
    for x in r:
        rnd = random.choice(r)
        self.t[rnd] = 0
        a[rnd] = 0
    diff = lsubtract(list(self.t.keys(0, 100)), a.keys())
    self.assertEqual(diff , [], diff)
</t>
<t tx="ekr.20040104185913.1314">def testPathologicalRangeSearch(self):
    t = self.t
    # Build a 2-level tree with at least two buckets.
    for i in range(200):
        t[i] = i
    items, dummy = t.__getstate__()
    self.assert_(len(items) &gt; 2)   # at least two buckets and a key
    # All values in the first bucket are &lt; firstkey.  All in the
    # second bucket are &gt;= firstkey, and firstkey is the first key in
    # the second bucket.
    firstkey = items[1]
    therange = t.keys(-1, firstkey)
    self.assertEqual(len(therange), firstkey + 1)
    self.assertEqual(list(therange), range(firstkey + 1))
    # Now for the tricky part.  If we delete firstkey, the second bucket
    # loses its smallest key, but firstkey remains in the BTree node.
    # If we then do a high-end range search on firstkey, the BTree node
    # directs us to look in the second bucket, but there's no longer any
    # key &lt;= firstkey in that bucket.  The correct answer points to the
    # end of the *first* bucket.  The algorithm has to be smart enough
    # to "go backwards" in the BTree then; if it doesn't, it will
    # erroneously claim that the range is empty.
    del t[firstkey]
    therange = t.keys(-1, firstkey)
    self.assertEqual(len(therange), firstkey)
    self.assertEqual(list(therange), range(firstkey))
</t>
<t tx="ekr.20040104185913.1315">def testInsertMethod(self):
    t = self.t
    t[0] = 1
    self.assertEqual(t.insert(0, 1) , 0)
    self.assertEqual(t.insert(1, 1) , 1)
    self.assertEqual(lsubtract(list(t.keys()), [0,1]) , [])
</t>
<t tx="ekr.20040104185913.1316">def testDamagedIterator(self):
    # A cute one from Steve Alexander.  This caused the BTreeItems
    # object to go insane, accessing memory beyond the allocated part
    # of the bucket.  If it fails, the symptom is either a C-level
    # assertion error (if the BTree code was compiled without NDEBUG),
    # or most likely a segfault (if the BTree code was compiled with
    # NDEBUG).

    t = self.t.__class__()
    self._populate(t, 10)
    # In order for this to fail, it's important that k be a "lazy"
    # iterator, referring to the BTree by indirect position (index)
    # instead of a fully materialized list.  Then the position can
    # end up pointing into trash memory, if the bucket pointed to
    # shrinks.
    k = t.keys()
    for dummy in range(20):
        try:
            del t[k[0]]
        except RuntimeError, detail:
            self.assertEqual(str(detail), "the bucket being iterated "
                                          "changed size")
            break
</t>
<t tx="ekr.20040104185913.1317">## BTree tests

class TestIOBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1318">def setUp(self):
    self.t = IOBTree()
</t>
<t tx="ekr.20040104185913.1319">def nonIntegerKeyRaises(self):
    self.assertRaises(TypeError, self._stringraises)
    self.assertRaises(TypeError, self._floatraises)
    self.assertRaises(TypeError, self._noneraises)
</t>
<t tx="ekr.20040104185913.1320">def _stringraises(self):
    self.t['c'] = 1
</t>
<t tx="ekr.20040104185913.1321">def _floatraises(self):
    self.t[2.5] = 1
</t>
<t tx="ekr.20040104185913.1322">def _noneraises(self):
    self.t[None] = 1
</t>
<t tx="ekr.20040104185913.1323">def testEmptyFirstBucketReportedByGuido(self):
    b = self.t
    for i in xrange(29972): # reduce to 29971 and it works
        b[i] = i
    for i in xrange(30): # reduce to 29 and it works
        del b[i]
        b[i+40000] = i

    self.assertEqual(b.keys()[0], 30)
</t>
<t tx="ekr.20040104185913.1324">class TestOOBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1325">def setUp(self):
    self.t = OOBTree()
</t>
<t tx="ekr.20040104185913.1326">class TestOIBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1327">def setUp(self):
    self.t = OIBTree()
</t>
<t tx="ekr.20040104185913.1328">def testNonIntegerValueRaises(self):
    self.assertRaises(TypeError, self._stringraises)
    self.assertRaises(TypeError, self._floatraises)
    self.assertRaises(TypeError, self._noneraises)
</t>
<t tx="ekr.20040104185913.1329">def _stringraises(self):
    self.t[1] = 'c'
</t>
<t tx="ekr.20040104185913.1330">def _floatraises(self):
    self.t[1] = 1.4
</t>
<t tx="ekr.20040104185913.1331">def _noneraises(self):
    self.t[1] = None
</t>
<t tx="ekr.20040104185913.1332">class TestIIBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1333">def setUp(self):
    self.t = IIBTree()
</t>
<t tx="ekr.20040104185913.1334">def testNonIntegerKeyRaises(self):
    self.assertRaises(TypeError, self._stringraiseskey)
    self.assertRaises(TypeError, self._floatraiseskey)
    self.assertRaises(TypeError, self._noneraiseskey)
</t>
<t tx="ekr.20040104185913.1335">def testNonIntegerValueRaises(self):
    self.assertRaises(TypeError, self._stringraisesvalue)
    self.assertRaises(TypeError, self._floatraisesvalue)
    self.assertRaises(TypeError, self._noneraisesvalue)
</t>
<t tx="ekr.20040104185913.1336">def _stringraiseskey(self):
    self.t['c'] = 1
</t>
<t tx="ekr.20040104185913.1337">def _floatraiseskey(self):
    self.t[2.5] = 1
</t>
<t tx="ekr.20040104185913.1338">def _noneraiseskey(self):
    self.t[None] = 1
</t>
<t tx="ekr.20040104185913.1339">def _stringraisesvalue(self):
    self.t[1] = 'c'
</t>
<t tx="ekr.20040104185913.1340">def _floatraisesvalue(self):
    self.t[1] = 1.4
</t>
<t tx="ekr.20040104185913.1341">def _noneraisesvalue(self):
    self.t[1] = None
</t>
<t tx="ekr.20040104185913.1342">## Set tests

class TestIOSets(ExtendedSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1343">def setUp(self):
    self.t = IOSet()
</t>
<t tx="ekr.20040104185913.1344">def testNonIntegerInsertRaises(self):
    self.assertRaises(TypeError,self._insertstringraises)
    self.assertRaises(TypeError,self._insertfloatraises)
    self.assertRaises(TypeError,self._insertnoneraises)
</t>
<t tx="ekr.20040104185913.1345">def _insertstringraises(self):
    self.t.insert('a')
</t>
<t tx="ekr.20040104185913.1346">def _insertfloatraises(self):
    self.t.insert(1.4)
</t>
<t tx="ekr.20040104185913.1347">def _insertnoneraises(self):
    self.t.insert(None)
</t>
<t tx="ekr.20040104185913.1348">class TestOOSets(ExtendedSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1349">def setUp(self):
    self.t = OOSet()
</t>
<t tx="ekr.20040104185913.1350">class TestIISets(ExtendedSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1351">def setUp(self):
    self.t = IISet()
</t>
<t tx="ekr.20040104185913.1352">class TestOISets(ExtendedSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1353">def setUp(self):
    self.t = OISet()
</t>
<t tx="ekr.20040104185913.1354">class TestIOTreeSets(NormalSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1355">def setUp(self):
    self.t = IOTreeSet()
</t>
<t tx="ekr.20040104185913.1356">class TestOOTreeSets(NormalSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1357">def setUp(self):
    self.t = OOTreeSet()
</t>
<t tx="ekr.20040104185913.1358">class TestIITreeSets(NormalSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1359">def setUp(self):
    self.t = IITreeSet()
</t>
<t tx="ekr.20040104185913.1360"># Build a degenerate tree (set).  Boxes are BTree nodes.  There are
# 5 leaf buckets, each containing a single int.  Keys in the BTree
# nodes don't appear in the buckets.  Seven BTree nodes are purely
# indirection nodes (no keys).  Buckets aren't all at the same depth:
#
#     +------------------------+
#     |          4             |
#     +------------------------+
#         |              |
#         |              v
#         |             +-+
#         |             | |
#         |             +-+
#         |              |
#         v              v
#     +-------+   +-------------+
#     |   2   |   |   6     10  |
#     +-------+   +-------------+
#      |     |     |     |     |
#      v     v     v     v     v
#     +-+   +-+   +-+   +-+   +-+
#     | |   | |   | |   | |   | |
#     +-+   +-+   +-+   +-+   +-+
#      |     |     |     |     |
#      v     v     v     v     v
#      1     3    +-+    7     11
#                 | |
#                 +-+
#                  |
#                  v
#                  5
#
# This is nasty for many algorithms.  Consider a high-end range search
# for 4.  The BTree nodes direct it to the 5 bucket, but the correct
# answer is the 3 bucket, which requires going in a different direction
# at the very top node already.  Consider a low-end range search for
# 9.  The BTree nodes direct it to the 7 bucket, but the correct answer
# is the 11 bucket.  This is also a nasty-case tree for deletions.

def _build_degenerate_tree(self):
    # Build the buckets and chain them together.
    bucket11 = IISet([11])

    bucket7 = IISet()
    bucket7.__setstate__(((7,), bucket11))

    bucket5 = IISet()
    bucket5.__setstate__(((5,), bucket7))

    bucket3 = IISet()
    bucket3.__setstate__(((3,), bucket5))

    bucket1 = IISet()
    bucket1.__setstate__(((1,), bucket3))

    # Build the deepest layers of indirection nodes.
    ts = IITreeSet
    tree1 = ts()
    tree1.__setstate__(((bucket1,), bucket1))

    tree3 = ts()
    tree3.__setstate__(((bucket3,), bucket3))

    tree5lower = ts()
    tree5lower.__setstate__(((bucket5,), bucket5))
    tree5 = ts()
    tree5.__setstate__(((tree5lower,), bucket5))

    tree7 = ts()
    tree7.__setstate__(((bucket7,), bucket7))

    tree11 = ts()
    tree11.__setstate__(((bucket11,), bucket11))

    # Paste together the middle layers.
    tree13 = ts()
    tree13.__setstate__(((tree1, 2, tree3), bucket1))

    tree5711lower = ts()
    tree5711lower.__setstate__(((tree5, 6, tree7, 10, tree11), bucket5))
    tree5711 = ts()
    tree5711.__setstate__(((tree5711lower,), bucket5))

    # One more.
    t = ts()
    t.__setstate__(((tree13, 4, tree5711), bucket1))
    t._check()
    check(t)
    return t, [1, 3, 5, 7, 11]
</t>
<t tx="ekr.20040104185913.1361">def testDegenerateBasicOps(self):
    t, keys = self._build_degenerate_tree()
    self.assertEqual(len(t), len(keys))
    self.assertEqual(list(t.keys()), keys)
    # has_key actually returns the depth of a bucket.
    self.assertEqual(t.has_key(1), 4)
    self.assertEqual(t.has_key(3), 4)
    self.assertEqual(t.has_key(5), 6)
    self.assertEqual(t.has_key(7), 5)
    self.assertEqual(t.has_key(11), 5)
    for i in 0, 2, 4, 6, 8, 9, 10, 12:
        self.assertEqual(t.has_key(i), 0)
</t>
<t tx="ekr.20040104185913.1362">def _checkRanges(self, tree, keys):
    self.assertEqual(len(tree), len(keys))
    sorted_keys = keys[:]
    sorted_keys.sort()
    self.assertEqual(list(tree.keys()), sorted_keys)
    for k in keys:
        self.assert_(tree.has_key(k))
    if keys:
        lokey = sorted_keys[0]
        hikey = sorted_keys[-1]
        self.assertEqual(lokey, tree.minKey())
        self.assertEqual(hikey, tree.maxKey())
    else:
        lokey = hikey = 42

    # Try all range searches.
    for lo in range(lokey - 1, hikey + 2):
        for hi in range(lo - 1, hikey + 2):
            want = [k for k in keys if lo &lt;= k &lt;= hi]
            got = list(tree.keys(lo, hi))
            self.assertEqual(want, got)
</t>
<t tx="ekr.20040104185913.1363">def testRanges(self):
    t, keys = self._build_degenerate_tree()
    self._checkRanges(t, keys)
</t>
<t tx="ekr.20040104185913.1364">def testDeletes(self):
    # Delete keys in all possible orders, checking each tree along
    # the way.

    # This is a tough test.  Previous failure modes included:
    # 1. A variety of assertion failures in _checkRanges.
    # 2. Assorted "Invalid firstbucket pointer" failures at
    #    seemingly random times, coming out of the BTree destructor.
    # 3. Under Python 2.3 CVS, some baffling
    #      RuntimeWarning: tp_compare didn't return -1 or -2 for exception
    #    warnings, possibly due to memory corruption after a BTree
    #    goes insane.

    t, keys = self._build_degenerate_tree()
    for oneperm in permutations(keys):
        t, keys = self._build_degenerate_tree()
        for key in oneperm:
            t.remove(key)
            keys.remove(key)
            t._check()
            check(t)
            self._checkRanges(t, keys)
        # We removed all the keys, so the tree should be empty now.
        self.assertEqual(t.__getstate__(), None)

        # A damaged tree may trigger an "invalid firstbucket pointer"
        # failure at the time its destructor is invoked.  Try to force
        # that to happen now, so it doesn't look like a baffling failure
        # at some unrelated line.
        del t   # trigger destructor
</t>
<t tx="ekr.20040104185913.1365">class TestOITreeSets(NormalSetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1366">def setUp(self):
    self.t = OITreeSet()
</t>
<t tx="ekr.20040104185913.1367">## Bucket tests

class TestIOBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1368">def setUp(self):
    self.t = IOBucket()
</t>
<t tx="ekr.20040104185913.1369">class TestOOBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1370">def setUp(self):
    self.t = OOBucket()
</t>
<t tx="ekr.20040104185913.1371">class TestIIBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1372">def setUp(self):
    self.t = IIBucket()
</t>
<t tx="ekr.20040104185913.1373">class TestOIBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1374">def setUp(self):
    self.t = OIBucket()
</t>
<t tx="ekr.20040104185913.1375"># cmp error propagation tests

class DoesntLikeBeingCompared:
	@others
</t>
<t tx="ekr.20040104185913.1376">def __cmp__(self,other):
    raise ValueError('incomparable')
</t>
<t tx="ekr.20040104185913.1377">class TestCmpError(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1378">def testFoo(self):
    t = OOBTree()
    t['hello world'] = None
    try:
        t[DoesntLikeBeingCompared()] = None
    except ValueError,e:
        assert str(e)=='incomparable'
    else:
        raise ValueError('incomarable objects should not be allowed into the tree')
</t>
<t tx="ekr.20040104185913.1379">def test_suite():
    TIOBTree = makeSuite(TestIOBTrees, 'test')
    TOOBTree = makeSuite(TestOOBTrees, 'test')
    TOIBTree = makeSuite(TestOIBTrees, 'test')
    TIIBTree = makeSuite(TestIIBTrees, 'test')

    TIOSet = makeSuite(TestIOSets, 'test')
    TOOSet = makeSuite(TestOOSets, 'test')
    TOISet = makeSuite(TestOISets, 'test')
    TIISet = makeSuite(TestIISets, 'test')

    TIOTreeSet = makeSuite(TestIOTreeSets, 'test')
    TOOTreeSet = makeSuite(TestOOTreeSets, 'test')
    TOITreeSet = makeSuite(TestOITreeSets, 'test')
    TIITreeSet = makeSuite(TestIITreeSets, 'test')

    TIOBucket = makeSuite(TestIOBuckets, 'test')
    TOOBucket = makeSuite(TestOOBuckets, 'test')
    TOIBucket = makeSuite(TestOIBuckets, 'test')
    TIIBucket = makeSuite(TestIIBuckets, 'test')

    alltests = TestSuite((TIOSet, TOOSet, TOISet, TIISet,
                          TIOTreeSet, TOOTreeSet, TOITreeSet, TIITreeSet,
                          TIOBucket, TOOBucket, TOIBucket, TIIBucket,
                          TIOBTree, TOOBTree, TOIBTree, TIIBTree,
                          makeSuite(TestCmpError),
                         ))

    return alltests
</t>
<t tx="ekr.20040104185913.1380">## utility functions

def lsubtract(l1, l2):
    l1=list(l1)
    l2=list(l2)
    l = filter(lambda x, l1=l1: x not in l1, l2)
    l = l + filter(lambda x, l2=l2: x not in l2, l1)
    return l
</t>
<t tx="ekr.20040104185913.1381">def realseq(itemsob):
    return map(lambda x: x, itemsob)
</t>
<t tx="ekr.20040104185913.1382">def permutations(x):
    # Return a list of all permutations of list x.
    n = len(x)
    if n &lt;= 1:
        return [x]
    result = []
    x0 = x[0]
    for i in range(n):
        # Build the (n-1)! permutations with x[i] in the first position.
        xcopy = x[:]
        first, xcopy[i] = xcopy[i], x0
        result.extend([[first] + p for p in permutations(xcopy[1:])])
    return result
</t>
<t tx="ekr.20040104185913.1383">def main():
    TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.1384">&lt;&lt; testBTreesUnicode declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.1385">&lt;&lt; copyright &gt;&gt;

__version__ = '$Id: testBTreesUnicode.py,v 1.7 2002/06/08 19:40:13 tim_one Exp $'

import unittest,types
from BTrees.OOBTree import OOBTree

# When an OOBtree contains unicode strings as keys,
# it is neccessary accessing non-unicode strings are
# either ascii strings or encoded as unicoded using the
# corresponding encoding

encoding = 'ISO-8859-1'

</t>
<t tx="ekr.20040104185913.1386">class TestBTreesUnicode(unittest.TestCase):
    """ test unicode"""
	@others
</t>
<t tx="ekr.20040104185913.1387">def setUp(self):
    """setup an OOBTree with some unicode strings"""

    self.s = unicode('dreit\xe4gigen', 'latin1')

    self.data = [('alien', 1),
                 ('k\xf6nnten', 2),
                 ('fox', 3),
                 ('future', 4),
                 ('quick', 5),
                 ('zerst\xf6rt', 6),
                 (unicode('dreit\xe4gigen','latin1'), 7),
                ]

    self.tree = OOBTree()
    for k, v in self.data:
        if isinstance(k, types.StringType):
            k = unicode(k, 'latin1')
        self.tree[k] = v
</t>
<t tx="ekr.20040104185913.1388">def testAllKeys(self):
    # check every item of the tree
    for k, v in self.data:
        if isinstance(k, types.StringType):
            k = unicode(k, encoding)
        self.assert_(self.tree.has_key(k))
        self.assertEqual(self.tree[k], v)
</t>
<t tx="ekr.20040104185913.1389">def testUnicodeKeys(self):
    # try to access unicode keys in tree
    k, v = self.data[-1]
    self.assertEqual(k, self.s)
    self.assertEqual(self.tree[k], v)
    self.assertEqual(self.tree[self.s], v)
</t>
<t tx="ekr.20040104185913.1390">def testAsciiKeys(self):
    # try to access some "plain ASCII" keys in the tree
    for k, v in self.data[0], self.data[2]:
        self.assert_(isinstance(k, types.StringType))
        self.assertEqual(self.tree[k], v)
</t>
<t tx="ekr.20040104185913.1391">def test_suite():
    return unittest.makeSuite(TestBTreesUnicode)
</t>
<t tx="ekr.20040104185913.1392">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.1393">&lt;&lt; testConflict declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1394">&lt;&lt; copyright &gt;&gt;

import os

from BTrees.OOBTree import OOBTree, OOBucket, OOSet, OOTreeSet
from BTrees.IOBTree import IOBTree, IOBucket, IOSet, IOTreeSet
from BTrees.IIBTree import IIBTree, IIBucket, IISet, IITreeSet
from BTrees.OIBTree import OIBTree, OIBucket, OISet, OITreeSet
from unittest import TestCase, TestSuite, makeSuite

from ZODB.POSException import ConflictError
</t>
<t tx="ekr.20040104185913.1395">class Base:
    """ Tests common to all types: sets, buckets, and BTrees """
	&lt;&lt; class Base declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1396">storage = None

</t>
<t tx="ekr.20040104185913.1397">def tearDown(self):
    from ZODB.tests.StorageTestBase import removefs
    del self.t
    if self.storage is not None:
        self.storage.close()
        removefs(self.fsname)
</t>
<t tx="ekr.20040104185913.1398">def openDB(self):
    from ZODB.FileStorage import FileStorage
    from ZODB.DB import DB
    self.fsname = 'fs_tmp__%s' % os.getpid()
    self.storage = FileStorage(self.fsname)
    self.db = DB(self.storage)
</t>
<t tx="ekr.20040104185913.1399">class MappingBase(Base):
    """ Tests common to mappings (buckets, btrees) """
	@others
</t>
<t tx="ekr.20040104185913.1400">def _deletefail(self):
    del self.t[1]
</t>
<t tx="ekr.20040104185913.1401">def _setupConflict(self):

    l=[ -5124, -7377, 2274, 8801, -9901, 7327, 1565, 17, -679,
        3686, -3607, 14, 6419, -5637, 6040, -4556, -8622, 3847, 7191,
        -4067]


    e1=[(-1704, 0), (5420, 1), (-239, 2), (4024, 3), (-6984, 4)]
    e2=[(7745, 0), (4868, 1), (-2548, 2), (-2711, 3), (-3154, 4)]


    base=self.t
    base.update([(i, i*i) for i in l[:20]])
    b1=base.__class__(base)
    b2=base.__class__(base)
    bm=base.__class__(base)

    items=base.items()

    return  base, b1, b2, bm, e1, e2, items
</t>
<t tx="ekr.20040104185913.1402">def testSimpleConflict(self):
    # Unlike all the other tests, invoke conflict resolution
    # by committing a transaction and catching a conflict
    # in the storage.
    self.openDB()

    r1 = self.db.open().root()
    r1["t"] = self.t
    get_transaction().commit()

    r2 = self.db.open().root()
    copy = r2["t"]
    list(copy.items())  # ensure it's all loaded

    self.assertEqual(self.t._p_serial, copy._p_serial)

    self.t.update({1:2, 2:3})
    get_transaction().commit()

    copy.update({3:4})
    get_transaction().commit()
</t>
<t tx="ekr.20040104185913.1403">def testMergeDelete(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    del b1[items[0][0]]
    del b2[items[5][0]]
    del b1[items[-1][0]]
    del b2[items[-2][0]]
    del bm[items[0][0]]
    del bm[items[5][0]]
    del bm[items[-1][0]]
    del bm[items[-2][0]]
    test_merge(base, b1, b2, bm, 'merge  delete')
</t>
<t tx="ekr.20040104185913.1404">def testMergeDeleteAndUpdate(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    del b1[items[0][0]]
    b2[items[5][0]]=1
    del b1[items[-1][0]]
    b2[items[-2][0]]=2
    del bm[items[0][0]]
    bm[items[5][0]]=1
    del bm[items[-1][0]]
    bm[items[-2][0]]=2
    test_merge(base, b1, b2, bm, 'merge update and delete')
</t>
<t tx="ekr.20040104185913.1405">def testMergeUpdate(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1[items[0][0]]=1
    b2[items[5][0]]=2
    b1[items[-1][0]]=3
    b2[items[-2][0]]=4
    bm[items[0][0]]=1
    bm[items[5][0]]=2
    bm[items[-1][0]]=3
    bm[items[-2][0]]=4
    test_merge(base, b1, b2, bm, 'merge update')
</t>
<t tx="ekr.20040104185913.1406">def testFailMergeDelete(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    del b1[items[0][0]]
    del b2[items[0][0]]
    test_merge(base, b1, b2, bm, 'merge conflicting delete',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1407">def testFailMergeUpdate(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1[items[0][0]]=1
    b2[items[0][0]]=2
    test_merge(base, b1, b2, bm, 'merge conflicting update',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1408">def testFailMergeDeleteAndUpdate(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    del b1[items[0][0]]
    b2[items[0][0]]=-9
    test_merge(base, b1, b2, bm, 'merge conflicting update and delete',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1409">def testMergeInserts(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1[-99999]=-99999
    b1[e1[0][0]]=e1[0][1]
    b2[99999]=99999
    b2[e1[2][0]]=e1[2][1]

    bm[-99999]=-99999
    bm[e1[0][0]]=e1[0][1]
    bm[99999]=99999
    bm[e1[2][0]]=e1[2][1]
    test_merge(base, b1, b2, bm, 'merge insert')
</t>
<t tx="ekr.20040104185913.1410">def testMergeInsertsFromEmpty(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    base.clear()
    b1.clear()
    b2.clear()
    bm.clear()

    b1.update(e1)
    bm.update(e1)
    b2.update(e2)
    bm.update(e2)

    test_merge(base, b1, b2, bm, 'merge insert from empty')
</t>
<t tx="ekr.20040104185913.1411">def testMergeEmptyAndFill(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1.clear()
    bm.clear()
    b2.update(e2)
    bm.update(e2)

    test_merge(base, b1, b2, bm, 'merge insert from empty')
</t>
<t tx="ekr.20040104185913.1412">def testMergeEmpty(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1.clear()
    bm.clear()

    test_merge(base, b1, b2, bm, 'empty one and not other', should_fail=1)
</t>
<t tx="ekr.20040104185913.1413">def testFailMergeInsert(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1[-99999]=-99999
    b1[e1[0][0]]=e1[0][1]
    b2[99999]=99999
    b2[e1[0][0]]=e1[0][1]
    test_merge(base, b1, b2, bm, 'merge conflicting inserts',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1414">class SetTests(Base):
	&lt;&lt; class SetTests declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1415">"Set (as opposed to TreeSet) specific tests."

</t>
<t tx="ekr.20040104185913.1416">def _setupConflict(self):
    l=[ -5124, -7377, 2274, 8801, -9901, 7327, 1565, 17, -679,
        3686, -3607, 14, 6419, -5637, 6040, -4556, -8622, 3847, 7191,
        -4067]

    e1=[-1704, 5420, -239, 4024, -6984]
    e2=[7745, 4868, -2548, -2711, -3154]


    base = self.t
    base.update(l)
    b1 = base.__class__(base.keys())
    b2 = base.__class__(base.keys())
    bm = base.__class__(base.keys())

    items = base.keys()

    return  base, b1, b2, bm, e1, e2, items
</t>
<t tx="ekr.20040104185913.1417">def testMergeDelete(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1.remove(items[0])
    b2.remove(items[5])
    b1.remove(items[-1])
    b2.remove(items[-2])
    bm.remove(items[0])
    bm.remove(items[5])
    bm.remove(items[-1])
    bm.remove(items[-2])
    test_merge(base, b1, b2, bm, 'merge  delete')
</t>
<t tx="ekr.20040104185913.1418">def testFailMergeDelete(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1.remove(items[0])
    b2.remove(items[0])
    test_merge(base, b1, b2, bm, 'merge conflicting delete',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1419">def testMergeInserts(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1.insert(-99999)
    b1.insert(e1[0])
    b2.insert(99999)
    b2.insert(e1[2])

    bm.insert(-99999)
    bm.insert(e1[0])
    bm.insert(99999)
    bm.insert(e1[2])
    test_merge(base, b1, b2, bm, 'merge insert')
</t>
<t tx="ekr.20040104185913.1420">def testMergeInsertsFromEmpty(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    base.clear()
    b1.clear()
    b2.clear()
    bm.clear()

    b1.update(e1)
    bm.update(e1)
    b2.update(e2)
    bm.update(e2)

    test_merge(base, b1, b2, bm, 'merge insert from empty')
</t>
<t tx="ekr.20040104185913.1421">def testMergeEmptyAndFill(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1.clear()
    bm.clear()
    b2.update(e2)
    bm.update(e2)

    test_merge(base, b1, b2, bm, 'merge insert from empty')
</t>
<t tx="ekr.20040104185913.1422">def testMergeEmpty(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()

    b1.clear()
    bm.clear()

    test_merge(base, b1, b2, bm, 'empty one and not other', should_fail=1)
</t>
<t tx="ekr.20040104185913.1423">def testFailMergeInsert(self):
    base, b1, b2, bm, e1, e2, items = self._setupConflict()
    b1.insert(-99999)
    b1.insert(e1[0])
    b2.insert(99999)
    b2.insert(e1[0])
    test_merge(base, b1, b2, bm, 'merge conflicting inserts',
               should_fail=1)
</t>
<t tx="ekr.20040104185913.1424">def test_merge(o1, o2, o3, expect, message='failed to merge', should_fail=0):
    s1=o1.__getstate__()
    s2=o2.__getstate__()
    s3=o3.__getstate__()
    expected=expect.__getstate__()
    if expected is None:
        expected = ((((),),),)

    if should_fail:
        try:
            merged=o1._p_resolveConflict(s1, s2, s3)
        except ConflictError, err:
            pass
        else:
            assert 0, message
    else:
        merged=o1._p_resolveConflict(s1, s2, s3)
        assert merged==expected, message
</t>
<t tx="ekr.20040104185913.1425">class BucketTests(MappingBase):
    """ Tests common to all buckets """
</t>
<t tx="ekr.20040104185913.1426">class BTreeTests(MappingBase):
    """ Tests common to all BTrees """
	&lt;&lt; class BTreeTests declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1427">## BTree tests

</t>
<t tx="ekr.20040104185913.1428">class TestIOBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1429">def setUp(self):
    self.t = IOBTree()
</t>
<t tx="ekr.20040104185913.1430">class TestOOBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1431">def setUp(self):
    self.t = OOBTree()
</t>
<t tx="ekr.20040104185913.1432">class TestOIBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1433">def setUp(self):
    self.t = OIBTree()
</t>
<t tx="ekr.20040104185913.1434">class TestIIBTrees(BTreeTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1435">def setUp(self):
    self.t = IIBTree()
</t>
<t tx="ekr.20040104185913.1436">## Set tests

class TestIOSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1437">def setUp(self):
    self.t = IOSet()
</t>
<t tx="ekr.20040104185913.1438">class TestOOSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1439">def setUp(self):
    self.t = OOSet()
</t>
<t tx="ekr.20040104185913.1440">class TestIISets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1441">def setUp(self):
    self.t = IISet()
</t>
<t tx="ekr.20040104185913.1442">class TestOISets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1443">def setUp(self):
    self.t = OISet()
</t>
<t tx="ekr.20040104185913.1444">class TestIOTreeSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1445">def setUp(self):
    self.t = IOTreeSet()
</t>
<t tx="ekr.20040104185913.1446">class TestOOTreeSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1447">def setUp(self):
    self.t = OOTreeSet()
</t>
<t tx="ekr.20040104185913.1448">class TestIITreeSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1449">def setUp(self):
    self.t = IITreeSet()
</t>
<t tx="ekr.20040104185913.1450">class TestOITreeSets(SetTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1451">def setUp(self):
    self.t = OITreeSet()
</t>
<t tx="ekr.20040104185913.1452">## Bucket tests

class TestIOBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1453">def setUp(self):
    self.t = IOBucket()
</t>
<t tx="ekr.20040104185913.1454">class TestOOBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1455">def setUp(self):
    self.t = OOBucket()
</t>
<t tx="ekr.20040104185913.1456">class TestIIBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1457">def setUp(self):
    self.t = IIBucket()
</t>
<t tx="ekr.20040104185913.1458">class TestOIBuckets(BucketTests, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1459">def setUp(self):
    self.t = OIBucket()
</t>
<t tx="ekr.20040104185913.1460">class NastyConfict(Base, TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1461">def setUp(self):
    self.t = OOBTree()
</t>
<t tx="ekr.20040104185913.1462"># This tests a problem that cropped up while trying to write
# testBucketSplitConflict (below):  conflict resolution wasn't
# working at all in non-trivial cases.  Symptoms varied from
# strange complaints about pickling (despite that the test isn't
# doing any *directly*), thru SystemErrors from Python and
# AssertionErrors inside the BTree code.
def testResolutionBlowsUp(self):
    b = self.t
    for i in range(0, 200, 4):
        b[i] = i
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 64 .. 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # If these fail, the *preconditions* for running the test aren't
    # satisfied -- the test itself hasn't been run yet.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    # Invoke conflict resolution by committing a transaction.
    self.openDB()

    r1 = self.db.open().root()
    r1["t"] = self.t
    get_transaction().commit()

    r2 = self.db.open().root()
    copy = r2["t"]
    # Make sure all of copy is loaded.
    list(copy.values())

    self.assertEqual(self.t._p_serial, copy._p_serial)

    self.t.update({1:2, 2:3})
    get_transaction().commit()

    copy.update({3:4})
    get_transaction().commit()  # if this doesn't blow up
    list(copy.values())         # and this doesn't either, then fine
</t>
<t tx="ekr.20040104185913.1463">def testBucketSplitConflict(self):
    # Tests that a bucket split is viewed as a conflict.
    # It's (almost necessarily) a white-box test, and sensitive to
    # implementation details.
    b = self.t
    for i in range(0, 200, 4):
        b[i] = i
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 64 .. 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # If these fail, the *preconditions* for running the test aren't
    # satisfied -- the test itself hasn't been run yet.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    # Invoke conflict resolution by committing a transaction.
    self.openDB()

    r1 = self.db.open().root()
    r1["t"] = self.t
    get_transaction().commit()

    r2 = self.db.open().root()
    copy = r2["t"]
    # Make sure all of copy is loaded.
    list(copy.values())

    self.assertEqual(self.t._p_serial, copy._p_serial)

    # In one transaction, add 16 new keys to bucket1, to force a bucket
    # split.
    b = self.t
    numtoadd = 16
    candidate = 60
    while numtoadd:
        if not b.has_key(candidate):
            b[candidate] = candidate
            numtoadd -= 1
        candidate += 1
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 61 .. 74
    # bucket 2 has 16 values: [75, 76 .. 81] + [84, 88 ..116]
    # bucket 3 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((b0, 60, b1, 75, b2, 120, b3), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state) , 2)
    self.assertEqual(len(state[0]), 7)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 75)
    self.assertEqual(state[0][5], 120)

    get_transaction().commit()

    # In the other transaction, add 3 values near the tail end of bucket1.
    # This doesn't cause a split.
    b = copy
    for i in range(112, 116):
        b[i] = i
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 18 values: 60, 64 .. 112, 113, 114, 115, 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    self.assertRaises(ConflictError, get_transaction().commit)
    get_transaction().abort()   # horrible things happen w/o this
</t>
<t tx="ekr.20040104185913.1464">def testEmptyBucketConflict(self):
    # Tests that an emptied bucket *created by* conflict resolution is
    # viewed as a conflict:  conflict resolution doesn't have enough
    # info to unlink the empty bucket from the BTree correctly.
    b = self.t
    for i in range(0, 200, 4):
        b[i] = i
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 64 .. 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # If these fail, the *preconditions* for running the test aren't
    # satisfied -- the test itself hasn't been run yet.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    # Invoke conflict resolution by committing a transaction.
    self.openDB()

    r1 = self.db.open().root()
    r1["t"] = self.t
    get_transaction().commit()

    r2 = self.db.open().root()
    copy = r2["t"]
    # Make sure all of copy is loaded.
    list(copy.values())

    self.assertEqual(self.t._p_serial, copy._p_serial)

    # In one transaction, delete half of bucket 1.
    b = self.t
    for k in 60, 64, 68, 72, 76, 80, 84, 88:
        del b[k]
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 7 values: 92, 96, 100, 104, 108, 112, 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state) , 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    get_transaction().commit()

    # In the other transaction, delete the other half of bucket 1.
    b = copy
    for k in 92, 96, 100, 104, 108, 112, 116:
        del b[k]
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 8 values: 60, 64, 68, 72, 76, 80, 84, 88
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    # Conflict resolution empties bucket1 entirely.  This used to
    # create an "insane" BTree (a legit BTree cannot contain an empty
    # bucket -- it contains NULL pointers the BTree code doesn't
    # expect, and segfaults result).
    self.assertRaises(ConflictError, get_transaction().commit)
    get_transaction().abort()   # horrible things happen w/o this
</t>
<t tx="ekr.20040104185913.1465">def testEmptyBucketNoConflict(self):
    # Tests that a plain empty bucket (on input) is not viewed as a
    # conflict.
    b = self.t
    for i in range(0, 200, 4):
        b[i] = i
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 64 .. 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # If these fail, the *preconditions* for running the test aren't
    # satisfied -- the test itself hasn't been run yet.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    # Invoke conflict resolution by committing a transaction.
    self.openDB()

    r1 = self.db.open().root()
    r1["t"] = self.t
    get_transaction().commit()

    r2 = self.db.open().root()
    copy = r2["t"]
    # Make sure all of copy is loaded.
    list(copy.values())

    self.assertEqual(self.t._p_serial, copy._p_serial)

    # In one transaction, just add a key.
    b = self.t
    b[1] = 1
    # bucket 0 has 16 values: [0, 1] + [4, 8 .. 56]
    # bucket 1 has 15 values: 60, 64 .. 116
    # bucket 2 has 20 values: 120, 124 .. 196
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1, 120, bucket2), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 5)
    self.assertEqual(state[0][1], 60)
    self.assertEqual(state[0][3], 120)

    get_transaction().commit()

    # In the other transaction, delete bucket 2.
    b = copy
    for k in range(120, 200, 4):
        del b[k]
    # bucket 0 has 15 values: 0, 4 .. 56
    # bucket 1 has 15 values: 60, 64 .. 116
    state = b.__getstate__()
    # Looks like:  ((bucket0, 60, bucket1), firstbucket)
    # The next block is still verifying preconditions.
    self.assertEqual(len(state), 2)
    self.assertEqual(len(state[0]), 3)
    self.assertEqual(state[0][1], 60)

    # This shouldn't create a ConflictError.
    get_transaction().commit()
    # And the resulting BTree shouldn't have internal damage.
    b._check()
</t>
<t tx="ekr.20040104185913.1466">def test_suite():
    suite = TestSuite()
    for k in (TestIOBTrees,   TestOOBTrees,   TestOIBTrees,   TestIIBTrees,
              TestIOSets,     TestOOSets,     TestOISets,     TestIISets,
              TestIOTreeSets, TestOOTreeSets, TestOITreeSets, TestIITreeSets,
              TestIOBuckets,  TestOOBuckets,  TestOIBuckets,  TestIIBuckets,
              NastyConfict):
        suite.addTest(makeSuite(k))
    return suite
</t>
<t tx="ekr.20040104185913.1467">&lt;&lt; testSetOps declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.1468">&lt;&lt; copyright &gt;&gt;

import random
from unittest import TestCase, TestSuite, TextTestRunner, makeSuite

from BTrees.OOBTree import OOBTree, OOBucket, OOSet, OOTreeSet
from BTrees.IOBTree import IOBTree, IOBucket, IOSet, IOTreeSet
from BTrees.IIBTree import IIBTree, IIBucket, IISet, IITreeSet
from BTrees.OIBTree import OIBTree, OIBucket, OISet, OITreeSet

# Subclasses have to set up:
#     builders - functions to build inputs, taking an optional keys arg
#     intersection, union, difference - set to the type-correct versions

</t>
<t tx="ekr.20040104185913.1469">class SetResult(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1470">def setUp(self):
    self.Akeys = [1,    3,    5, 6   ]
    self.Bkeys = [   2, 3, 4,    6, 7]
    self.As = [makeset(self.Akeys) for makeset in self.builders]
    self.Bs = [makeset(self.Bkeys) for makeset in self.builders]
    self.emptys = [makeset() for makeset in self.builders]
</t>
<t tx="ekr.20040104185913.1471"># Slow but obviously correct Python implementations of basic ops.
def _union(self, x, y):
    result = list(x.keys())
    for e in y.keys():
        if e not in result:
            result.append(e)
    result.sort()
    return result
</t>
<t tx="ekr.20040104185913.1472">def _intersection(self, x, y):
    result = []
    ykeys = y.keys()
    for e in x.keys():
        if e in ykeys:
            result.append(e)
    return result
</t>
<t tx="ekr.20040104185913.1473">def _difference(self, x, y):
    result = list(x.keys())
    for e in y.keys():
        if e in result:
            result.remove(e)
    # Difference preserves LHS values.
    if hasattr(x, "values"):
        result = [(k, x[k]) for k in result]
    return result
</t>
<t tx="ekr.20040104185913.1474">def testNone(self):
    for op in self.union, self.intersection, self.difference:
        C = op(None, None)
        self.assert_(C is None)

    for op in self.union, self.intersection, self.difference:
        for A in self.As:
            C = op(A, None)
            self.assert_(C is A)

            C = op(None, A)
            if op is self.difference:
                self.assert_(C is None)
            else:
                self.assert_(C is A)
</t>
<t tx="ekr.20040104185913.1475">def testEmptyUnion(self):
    for A in self.As:
        for E in self.emptys:
            C = self.union(A, E)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), self.Akeys)

            C = self.union(E, A)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), self.Akeys)
</t>
<t tx="ekr.20040104185913.1476">def testEmptyIntersection(self):
    for A in self.As:
        for E in self.emptys:
            C = self.intersection(A, E)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), [])

            C = self.intersection(E, A)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), [])
</t>
<t tx="ekr.20040104185913.1477">def testEmptyDifference(self):
    for A in self.As:
        for E in self.emptys:
            C = self.difference(A, E)
            # Difference preserves LHS values.
            self.assertEqual(hasattr(C, "values"), hasattr(A, "values"))
            if hasattr(A, "values"):
                self.assertEqual(list(C.items()), list(A.items()))
            else:
                self.assertEqual(list(C), self.Akeys)

            C = self.difference(E, A)
            self.assertEqual(hasattr(C, "values"), hasattr(E, "values"))
            self.assertEqual(list(C.keys()), [])
</t>
<t tx="ekr.20040104185913.1478">def testUnion(self):
    inputs = self.As + self.Bs
    for A in inputs:
        for B in inputs:
            C = self.union(A, B)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), self._union(A, B))
</t>
<t tx="ekr.20040104185913.1479">def testIntersection(self):
    inputs = self.As + self.Bs
    for A in inputs:
        for B in inputs:
            C = self.intersection(A, B)
            self.assert_(not hasattr(C, "values"))
            self.assertEqual(list(C), self._intersection(A, B))
</t>
<t tx="ekr.20040104185913.1480">def testDifference(self):
    inputs = self.As + self.Bs
    for A in inputs:
        for B in inputs:
            C = self.difference(A, B)
            # Difference preserves LHS values.
            self.assertEqual(hasattr(C, "values"), hasattr(A, "values"))
            want = self._difference(A, B)
            if hasattr(A, "values"):
                self.assertEqual(list(C.items()), want)
            else:
                self.assertEqual(list(C), want)
</t>
<t tx="ekr.20040104185913.1481">def testLargerInputs(self):
    from random import randint
    MAXSIZE = 200
    MAXVAL = 400
    for i in range(3):
        n = randint(0, MAXSIZE)
        Akeys = [randint(1, MAXVAL) for j in range(n)]
        As = [makeset(Akeys) for makeset in self.builders]
        Akeys = IISet(Akeys)

        n = randint(0, MAXSIZE)
        Bkeys = [randint(1, MAXVAL) for j in range(n)]
        Bs = [makeset(Bkeys) for makeset in self.builders]
        Bkeys = IISet(Bkeys)

        for op, simulator in ((self.union, self._union),
                              (self.intersection, self._intersection),
                              (self.difference, self._difference)):
            for A in As:
                for B in Bs:
                    got = op(A, B)
                    want = simulator(Akeys, Bkeys)
                    self.assertEqual(list(got.keys()), want,
                                     (A, B,
                                      Akeys, Bkeys,
                                      list(got.keys()), want))
</t>
<t tx="ekr.20040104185913.1482"># Given a mapping builder (IIBTree, OOBucket, etc), return a function
# that builds an object of that type given only a list of keys.
def makeBuilder(mapbuilder):
    def result(keys=[], mapbuilder=mapbuilder):
        return mapbuilder(zip(keys, keys))
    return result
</t>
<t tx="ekr.20040104185913.1483">class PureII(SetResult):
	&lt;&lt; class PureII declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1484">from BTrees.IIBTree import union, intersection, difference
builders = IISet, IITreeSet, makeBuilder(IIBTree), makeBuilder(IIBucket)

</t>
<t tx="ekr.20040104185913.1485">class PureIO(SetResult):
	&lt;&lt; class PureIO declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1486">from BTrees.IOBTree import union, intersection, difference
builders = IOSet, IOTreeSet, makeBuilder(IOBTree), makeBuilder(IOBucket)

</t>
<t tx="ekr.20040104185913.1487">class PureOO(SetResult):
	&lt;&lt; class PureOO declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1488">from BTrees.OOBTree import union, intersection, difference
builders = OOSet, OOTreeSet, makeBuilder(OOBTree), makeBuilder(OOBucket)

</t>
<t tx="ekr.20040104185913.1489">class PureOI(SetResult):
	&lt;&lt; class PureOI declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1490">from BTrees.OIBTree import union, intersection, difference
builders = OISet, OITreeSet, makeBuilder(OIBTree), makeBuilder(OIBucket)

# Subclasses must set up (as class variables):
#     multiunion, union
#     mkset, mktreeset
#     mkbucket, mkbtree
</t>
<t tx="ekr.20040104185913.1491">class MultiUnion(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1492">def testEmpty(self):
    self.assertEqual(len(self.multiunion([])), 0)
</t>
<t tx="ekr.20040104185913.1493">def testOne(self):
    for sequence in [3], range(20), range(-10, 0, 2) + range(1, 10, 2):
        seq1 = sequence[:]
        seq2 = sequence[:]
        seq2.reverse()
        seqsorted = sequence[:]
        seqsorted.sort()
        for seq in seq1, seq2, seqsorted:
            for builder in self.mkset, self.mktreeset:
                input = builder(seq)
                output = self.multiunion([input])
                self.assertEqual(len(seq), len(output))
                self.assertEqual(seqsorted, list(output))
</t>
<t tx="ekr.20040104185913.1494">def testValuesIgnored(self):
    for builder in self.mkbucket, self.mkbtree:
        input = builder([(1, 2), (3, 4), (5, 6)])
        output = self.multiunion([input])
        self.assertEqual([1, 3, 5], list(output))
</t>
<t tx="ekr.20040104185913.1495">def testBigInput(self):
    N = 100000
    input = self.mkset(range(N))
    output = self.multiunion([input] * 10)
    self.assertEqual(len(output), N)
    self.assertEqual(output.minKey(), 0)
    self.assertEqual(output.maxKey(), N-1)
    self.assertEqual(list(output), range(N))
</t>
<t tx="ekr.20040104185913.1496">def testLotsOfLittleOnes(self):
    from random import shuffle
    N = 5000
    inputs = []
    mkset, mktreeset = self.mkset, self.mktreeset
    for i in range(N):
        base = i * 4 - N
        inputs.append(mkset([base, base+1]))
        inputs.append(mktreeset([base+2, base+3]))
    shuffle(inputs)
    output = self.multiunion(inputs)
    self.assertEqual(len(output), N*4)
    self.assertEqual(list(output), range(-N, 3*N))
</t>
<t tx="ekr.20040104185913.1497">def testFunkyKeyIteration(self):
    # The internal set iteration protocol allows "iterating over" a
    # a single key as if it were a set.
    N = 100
    union, mkset = self.union, self.mkset
    slow = mkset()
    for i in range(N):
        slow = union(slow, mkset([i]))
    fast = self.multiunion(range(N))  # acts like N distinct singleton sets
    self.assertEqual(len(slow), N)
    self.assertEqual(len(fast), N)
    self.assertEqual(list(slow.keys()), list(fast.keys()))
    self.assertEqual(list(fast.keys()), range(N))
</t>
<t tx="ekr.20040104185913.1498">class TestIIMultiUnion(MultiUnion):
	&lt;&lt; class TestIIMultiUnion declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1499">from BTrees.IIBTree import multiunion, union
from BTrees.IIBTree import IISet as mkset, IITreeSet as mktreeset
from BTrees.IIBTree import IIBucket as mkbucket, IIBTree as mkbtree

</t>
<t tx="ekr.20040104185913.1500">class TestIOMultiUnion(MultiUnion):
	&lt;&lt; class TestIOMultiUnion declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1501">from BTrees.IOBTree import multiunion, union
from BTrees.IOBTree import IOSet as mkset, IOTreeSet as mktreeset
from BTrees.IOBTree import IOBucket as mkbucket, IOBTree as mkbtree

# Check that various special module functions are and aren't imported from
# the expected BTree modules.
</t>
<t tx="ekr.20040104185913.1502">class TestImports(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1503">def testWeightedUnion(self):
    from BTrees.IIBTree import weightedUnion
    from BTrees.OIBTree import weightedUnion

    try:
        from BTrees.IOBTree import weightedUnion
    except ImportError:
        pass
    else:
        self.fail("IOBTree shouldn't have weightedUnion")

    try:
        from BTrees.OOBTree import weightedUnion
    except ImportError:
        pass
    else:
        self.fail("OOBTree shouldn't have weightedUnion")
</t>
<t tx="ekr.20040104185913.1504">def testWeightedIntersection(self):
    from BTrees.IIBTree import weightedIntersection
    from BTrees.OIBTree import weightedIntersection

    try:
        from BTrees.IOBTree import weightedIntersection
    except ImportError:
        pass
    else:
        self.fail("IOBTree shouldn't have weightedIntersection")

    try:
        from BTrees.OOBTree import weightedIntersection
    except ImportError:
        pass
    else:
        self.fail("OOBTree shouldn't have weightedIntersection")
</t>
<t tx="ekr.20040104185913.1505">def testMultiunion(self):
    from BTrees.IIBTree import multiunion
    from BTrees.IOBTree import multiunion

    try:
        from BTrees.OIBTree import multiunion
    except ImportError:
        pass
    else:
        self.fail("OIBTree shouldn't have multiunion")

    try:
        from BTrees.OOBTree import multiunion
    except ImportError:
        pass
    else:
        self.fail("OOBTree shouldn't have multiunion")
</t>
<t tx="ekr.20040104185913.1506"># Subclasses must set up (as class variables):
#     weightedUnion, weightedIntersection
#     builders -- sequence of constructors, taking items
#     union, intersection -- the module routines of those names
#     mkbucket -- the module bucket builder
class Weighted(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1507">def setUp(self):
    self.Aitems = [(1, 10), (3, 30),  (5, 50), (6, 60)]
    self.Bitems = [(2, 21), (3, 31), (4, 41),  (6, 61), (7, 71)]

    self.As = [make(self.Aitems) for make in self.builders]
    self.Bs = [make(self.Bitems) for make in self.builders]
    self.emptys = [make([]) for make in self.builders]

    weights = []
    for w1 in -3, -1, 0, 1, 7:
        for w2 in -3, -1, 0, 1, 7:
            weights.append((w1, w2))
    self.weights = weights
</t>
<t tx="ekr.20040104185913.1508">def testBothNone(self):
    for op in self.weightedUnion, self.weightedIntersection:
        w, C = op(None, None)
        self.assert_(C is None)
        self.assertEqual(w, 0)

        w, C = op(None, None, 42, 666)
        self.assert_(C is None)
        self.assertEqual(w, 0)
</t>
<t tx="ekr.20040104185913.1509">def testLeftNone(self):
    for op in self.weightedUnion, self.weightedIntersection:
        for A in self.As + self.emptys:
            w, C = op(None, A)
            self.assert_(C is A)
            self.assertEqual(w, 1)

            w, C = op(None, A, 42, 666)
            self.assert_(C is A)
            self.assertEqual(w, 666)
</t>
<t tx="ekr.20040104185913.1510">def testRightNone(self):
    for op in self.weightedUnion, self.weightedIntersection:
        for A in self.As + self.emptys:
            w, C = op(A, None)
            self.assert_(C is A)
            self.assertEqual(w, 1)

            w, C = op(A, None, 42, 666)
            self.assert_(C is A)
            self.assertEqual(w, 42)
</t>
<t tx="ekr.20040104185913.1511"># If obj is a set, return a bucket with values all 1; else return obj.
def _normalize(self, obj):
    if isaset(obj):
        obj = self.mkbucket(zip(obj.keys(), [1] * len(obj)))
    return obj
</t>
<t tx="ekr.20040104185913.1512"># Python simulation of weightedUnion.
def _wunion(self, A, B, w1=1, w2=1):
    if isaset(A) and isaset(B):
        return 1, self.union(A, B).keys()
    A = self._normalize(A)
    B = self._normalize(B)
    result = []
    for key in self.union(A, B):
        v1 = A.get(key, 0)
        v2 = B.get(key, 0)
        result.append((key, v1*w1 + v2*w2))
    return 1, result
</t>
<t tx="ekr.20040104185913.1513">def testUnion(self):
    inputs = self.As + self.Bs + self.emptys
    for A in inputs:
        for B in inputs:
            want_w, want_s = self._wunion(A, B)
            got_w, got_s = self.weightedUnion(A, B)
            self.assertEqual(got_w, want_w)
            if isaset(got_s):
                self.assertEqual(got_s.keys(), want_s)
            else:
                self.assertEqual(got_s.items(), want_s)

            for w1, w2 in self.weights:
                want_w, want_s = self._wunion(A, B, w1, w2)
                got_w, got_s = self.weightedUnion(A, B, w1, w2)
                self.assertEqual(got_w, want_w)
                if isaset(got_s):
                    self.assertEqual(got_s.keys(), want_s)
                else:
                    self.assertEqual(got_s.items(), want_s)
</t>
<t tx="ekr.20040104185913.1514"># Python simulation weightedIntersection.
def _wintersection(self, A, B, w1=1, w2=1):
    if isaset(A) and isaset(B):
        return w1 + w2, self.intersection(A, B).keys()
    A = self._normalize(A)
    B = self._normalize(B)
    result = []
    for key in self.intersection(A, B):
        result.append((key, A[key]*w1 + B[key]*w2))
    return 1, result
</t>
<t tx="ekr.20040104185913.1515">def testIntersection(self):
    inputs = self.As + self.Bs + self.emptys
    for A in inputs:
        for B in inputs:
            want_w, want_s = self._wintersection(A, B)
            got_w, got_s = self.weightedIntersection(A, B)
            self.assertEqual(got_w, want_w)
            if isaset(got_s):
                self.assertEqual(got_s.keys(), want_s)
            else:
                self.assertEqual(got_s.items(), want_s)

            for w1, w2 in self.weights:
                want_w, want_s = self._wintersection(A, B, w1, w2)
                got_w, got_s = self.weightedIntersection(A, B, w1, w2)
                self.assertEqual(got_w, want_w)
                if isaset(got_s):
                    self.assertEqual(got_s.keys(), want_s)
                else:
                    self.assertEqual(got_s.items(), want_s)
</t>
<t tx="ekr.20040104185913.1516"># Given a set builder (like OITreeSet or OISet), return a function that
# takes a list of (key, value) pairs and builds a set out of the keys.
def itemsToSet(setbuilder):
    def result(items, setbuilder=setbuilder):
        return setbuilder([key for key, value in items])
    return result
</t>
<t tx="ekr.20040104185913.1517"># 'thing' is a bucket, btree, set or treeset.  Return true iff it's one of the
# latter two.
def isaset(thing):
    return not hasattr(thing, 'values')
</t>
<t tx="ekr.20040104185913.1518">class TestWeightedII(Weighted):
	&lt;&lt; class TestWeightedII declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1519">from BTrees.IIBTree import weightedUnion, weightedIntersection
from BTrees.IIBTree import union, intersection
from BTrees.IIBTree import IIBucket as mkbucket
builders = IIBucket, IIBTree, itemsToSet(IISet), itemsToSet(IITreeSet)

</t>
<t tx="ekr.20040104185913.1520">class TestWeightedOI(Weighted):
	&lt;&lt; class TestWeightedOI declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1521">from BTrees.OIBTree import weightedUnion, weightedIntersection
from BTrees.OIBTree import union, intersection
from BTrees.OIBTree import OIBucket as mkbucket
builders = OIBucket, OIBTree, itemsToSet(OISet), itemsToSet(OITreeSet)


</t>
<t tx="ekr.20040104185913.1522">def test_suite():
    s = TestSuite()
    for klass in (TestIIMultiUnion, TestIOMultiUnion,
                  TestImports,
                  PureII, PureIO, PureOI, PureOO,
                  TestWeightedII, TestWeightedOI):
        s.addTest(makeSuite(klass))
    return s
</t>
<t tx="ekr.20040104185913.1523">def main():
    TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.1524">&lt;&lt; test_check declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1525">&lt;&lt; copyright &gt;&gt;

"""Test the BTree check.check() function."""

import unittest

from BTrees.OOBTree import OOBTree
from BTrees.check import check

</t>
<t tx="ekr.20040104185913.1526">class CheckTest(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1527">def setUp(self):
    self.t = t = OOBTree()
    for i in range(31):
        t[i] = 2*i
    self.state = t.__getstate__()
</t>
<t tx="ekr.20040104185913.1528">def testNormal(self):
    s = self.state
    # Looks like (state, first_bucket)
    # where state looks like (bucket0, 15, bucket1).
    self.assertEqual(len(s), 2)
    self.assertEqual(len(s[0]), 3)
    self.assertEqual(s[0][1], 15)
    self.t._check() # shouldn't blow up
    check(self.t)   # shouldn't blow up
</t>
<t tx="ekr.20040104185913.1529">def testKeyTooLarge(self):
    # Damage an invariant by dropping the BTree key to 14.
    s = self.state
    news = (s[0][0], 14, s[0][2]), s[1]
    self.t.__setstate__(news)
    self.t._check() # not caught
    try:
        # Expecting "... key %r &gt;= upper bound %r at index %d"
        check(self.t)
    except AssertionError, detail:
        self.failUnless(str(detail).find("&gt;= upper bound") &gt; 0)
    else:
        self.fail("expected self.t_check() to catch the problem")
</t>
<t tx="ekr.20040104185913.1530">def testKeyTooSmall(self):
    # Damage an invariant by bumping the BTree key to 16.
    s = self.state
    news = (s[0][0], 16, s[0][2]), s[1]
    self.t.__setstate__(news)
    self.t._check() # not caught
    try:
        # Expecting "... key %r &lt; lower bound %r at index %d"
        check(self.t)
    except AssertionError, detail:
        self.failUnless(str(detail).find("&lt; lower bound") &gt; 0)
    else:
        self.fail("expected self.t_check() to catch the problem")
</t>
<t tx="ekr.20040104185913.1531">def testKeysSwapped(self):
    # Damage an invariant by swapping two key/value pairs.
    s = self.state
    # Looks like (state, first_bucket)
    # where state looks like (bucket0, 15, bucket1).
    (b0, num, b1), firstbucket = s
    self.assertEqual(b0[4], 8)
    self.assertEqual(b0[5], 10)
    b0state = b0.__getstate__()
    self.assertEqual(len(b0state), 2)
    # b0state looks like
    # ((k0, v0, k1, v1, ...), nextbucket)
    pairs, nextbucket = b0state
    self.assertEqual(pairs[8], 4)
    self.assertEqual(pairs[9], 8)
    self.assertEqual(pairs[10], 5)
    self.assertEqual(pairs[11], 10)
    newpairs = pairs[:8] + (5, 10, 4, 8) + pairs[12:]
    b0.__setstate__((newpairs, nextbucket))
    self.t._check() # not caught
    try:
        check(self.t)
    except AssertionError, detail:
        self.failUnless(str(detail).find(
            "key 5 at index 4 &gt;= key 4 at index 5") &gt; 0)
    else:
        self.fail("expected self.t_check() to catch the problem")
</t>
<t tx="ekr.20040104185913.1532">def test_suite():
    return unittest.makeSuite(CheckTest)
</t>
<t tx="ekr.20040104185913.1533"></t>
<t tx="ekr.20040104185913.1534">@language html

&lt;html&gt;
&lt;head&gt;&lt;title&gt;Module DateTime&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;

&lt;dl&gt;&lt;dt&gt;&lt;h1&gt;DateTime&lt;/h1&gt;&lt;dd&gt;Encapsulation of date/time values&lt;/dl&gt;
&lt;h1&gt;Module Functions&lt;/h1&gt;

&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Timezones()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the list of recognized timezone names&lt;/p&gt;


&lt;/dl&gt;


&lt;h1&gt;Class DateTime&lt;/h1&gt;

&lt;p&gt;DateTime objects represent instants in time and provide
       interfaces for controlling its representation without
       affecting the absolute value of the object. &lt;/p&gt;
&lt;p&gt;       DateTime objects may be created from a wide variety of string 
       or numeric data, or may be computed from other DateTime objects.
       DateTimes support the ability to convert their representations
       to many major timezones, as well as the ablility to create a
       DateTime object in the context of a given timezone.&lt;/p&gt;

&lt;p&gt;       DateTime objects provide partial numerical behavior:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;Two date-time objects can be subtracted to obtain a time,
            in days between the two.&lt;/p&gt;


&lt;li&gt;&lt;p&gt;A date-time object and a positive or negative number may
            be added to obtain a new date-time object that is the given
            number of days later than the input date-time object.&lt;/p&gt;


&lt;li&gt;&lt;p&gt;A positive or negative number and a date-time object may
            be added to obtain a new date-time object that is the given
            number of days later than the input date-time object.&lt;/p&gt;


&lt;li&gt;&lt;p&gt;A positive or negative number may be subtracted from a
            date-time object to obtain a new date-time object that is
            the given number of days earlier than the input date-time
            object.&lt;/p&gt;

&lt;/ul&gt;
&lt;p&gt;        DateTime objects may be converted to integer, long, or float
        numbers of days since January 1, 1901, using the standard int, 
        long, and float functions (Compatibility Note: int, long and
        float return the number of days since 1901 in GMT rather than
        local machine timezone). DateTime objects also provide access
        to their value in a float format usable with the python time
        module, provided that the value of the object falls in the
        range of the epoch-based time module.&lt;/p&gt;

&lt;p&gt;        A DateTime object should be considered immutable; all conversion
        and numeric operations return a new DateTime object rather than
        modify the current object.&lt;/p&gt;

&lt;dl&gt;&lt;dt&gt;&lt;p&gt;&lt;strong&gt;Constructor For DateTime&lt;/strong&gt;&lt;/p&gt;&lt;dd&gt;

&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;DateTime()&lt;/strong&gt;&lt;dd&gt;
&lt;h3&gt;Return a new date-time object&lt;/h3&gt;
&lt;p&gt;        A DateTime object always maintains its value as an absolute 
        UTC time, and is represented in the context of some timezone
        based on the arguments used to create the object. A DateTime
        object's methods return values based on the timezone context.&lt;/p&gt;

&lt;p&gt;        Note that in all cases the local machine timezone is used for
        representation if no timezone is specified.&lt;/p&gt;

&lt;h4&gt;        DateTimes may be created with from zero to seven arguments.&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;If the function is called with no arguments, then the 
            current date/time is returned, represented in the 
            timezone of the local machine.&lt;/p&gt;


&lt;li&gt;&lt;p&gt;If the function is invoked with a single string argument
            which is a recognized timezone name, an object representing
            the current time is returned, represented in the specified
            timezone.&lt;/p&gt;


&lt;li&gt;&lt;p&gt;If the function is invoked with a single string argument
            representing a valid date/time, an object representing
            that date/time will be returned.&lt;/p&gt;
&lt;p&gt;            As a general rule, any date-time representation that is 
            recognized and unambigous to a resident of North America is
            acceptable.(The reason for this qualification is that
            in North America, a date like: 2/1/1994 is interpreted
            as February 1, 1994, while in some parts of the world,
            it is interpreted as January 2, 1994.) A date/time
            string consists of two components, a date component and
            an optional time component, separated by one or more
            spaces. If the time component is omited, 12:00am is
            assumed. Any recognized timezone name specified as the
            final element of the date/time string will be used for
            computing the date/time value. (If you create a DateTime
            with the string &lt;code&gt;Mar 9, 1997 1:45pm US/Pacific&lt;/code&gt;, the
            value will essentially be the same as if you had captured
            time.time() at the specified date and time on a machine in
            that timezone)
            &lt;PRE&gt;&lt;/p&gt;

&lt;p&gt;            e=DateTime(&lt;code&gt;US/Eastern&lt;/code&gt;)
            # returns current date/time, represented in US/Eastern.&lt;/p&gt;

&lt;p&gt;            x=DateTime(&lt;code&gt;1997/3/9 1:45pm&lt;/code&gt;)
            # returns specified time, represented in local machine zone.&lt;/p&gt;

&lt;p&gt;            y=DateTime(&lt;code&gt;Mar 9, 1997 13:45:00&lt;/code&gt;)
            # y is equal to x&lt;/p&gt;

&lt;p&gt;            &lt;/PRE&gt;&lt;/p&gt;

&lt;p&gt;            The date component consists of year, month, and day
            values. The year value must be a one-, two-, or
            four-digit integer. If a one- or two-digit year is
            used, the year is assumed to be in the twentieth
            century. The month may an integer, from 1 to 12, a
            month name, or a month abreviation, where a period may
            optionally follow the abreviation. The day must be an
            integer from 1 to the number of days in the month. The
            year, month, and day values may be separated by
            periods, hyphens, forward, shashes, or spaces. Extra
            spaces are permitted around the delimiters. Year,
            month, and day values may be given in any order as long
            as it is possible to distinguish the components. If all
            three components are numbers that are less than 13,
            then a a month-day-year ordering is assumed.&lt;/p&gt;

&lt;p&gt;            The time component consists of hour, minute, and second
            values separated by colons.  The hour value must be an
            integer between 0 and 23 inclusively. The minute value
            must be an integer between 0 and 59 inclusively. The
            second value may be an integer value between 0 and
            59.999 inclusively. The second value or both the minute
            and second values may be ommitted. The time may be
            followed by am or pm in upper or lower case, in which
            case a 12-hour clock is assumed.&lt;/p&gt;

&lt;li&gt;&lt;p&gt;If the DateTime function is invoked with a single
            Numeric argument, the number is assumed to be either
            a floating point value such as that returned by 
            time.time() , or a number of days after January 1, 1901 
            00:00:00 UTC.&lt;/p&gt;
&lt;p&gt;            A DateTime object is returned that represents either
            the gmt value of the time.time() float represented in
            the local machine's timezone, or that number of days 
            after January 1, 1901. Note that the number of days 
            after 1901 need to be expressed from the viewpoint of
            the local machine's timezone. A negative argument will 
            yield a date-time value before 1901.&lt;/p&gt;

&lt;li&gt;&lt;p&gt;If the function is invoked with two numeric arguments,
            then the first is taken to be an integer year and the
            second argument is taken to be an offset in days from
            the beginning of the year, in the context of the local
            machine timezone.
            The date-time value returned is the given offset number of 
            days from the beginning of the given year, represented in
            the timezone of the local machine. The offset may be positive
            or negative.
            Two-digit years are assumed to be in the twentieth
            century.&lt;/p&gt;

&lt;li&gt;&lt;p&gt;If the function is invoked with two arguments, the first
            a float representing a number of seconds past the epoch
            in gmt (such as those returned by time.time()) and the 
            second a string naming a recognized timezone, a DateTime
            with a value of that gmt time will be returned, represented
            in the given timezone.
            &lt;PRE&gt;
            import time
            t=time.time()&lt;/p&gt;
&lt;p&gt;            now_east=DateTime(t,'US/Eastern')
            # Time t represented as US/Eastern&lt;/p&gt;

&lt;p&gt;            now_west=DateTime(t,'US/Pacific')
            # Time t represented as US/Pacific&lt;/p&gt;

&lt;p&gt;            # now_east == now_west
            # only their representations are different&lt;/p&gt;

&lt;p&gt;            &lt;/PRE&gt;&lt;/p&gt;


&lt;li&gt;&lt;p&gt;If the function is invoked with three or more numeric
            arguments, then the first is taken to be an integer
            year, the second is taken to be an integer month, and
            the third is taken to be an integer day. If the
            combination of values is not valid, then a
            DateTimeError is raised. Two-digit years are assumed
            to be in the twentieth century. The fourth, fifth, and
            sixth arguments are floating point, positive or
            negative offsets in units of hours, minutes, and days,
            and default to zero if not given. An optional string may
            be given as the final argument to indicate timezone (the
            effect of this is as if you had taken the value of time.time()
            at that time on a machine in the specified timezone).&lt;/p&gt;

&lt;/ul&gt;

&lt;p&gt;
        If a string argument passed to the DateTime constructor cannot be
        parsed, it will raise DateTime.SyntaxError. Invalid date, time, or
        timezone components will raise a DateTime.DateTimeError. &lt;/p&gt;

&lt;p&gt;        The module function Timezones() will return a list of the 
        timezones recognized by the DateTime module. Recognition of 
        timezone names is case-insensitive.&lt;/p&gt;
&lt;/dl&gt;
&lt;/dl&gt;

&lt;dl&gt;&lt;dt&gt;&lt;p&gt;&lt;strong&gt;Instance Methods For DateTime&lt;/strong&gt;&lt;/p&gt;&lt;dd&gt;

&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aMonth()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the abreviated month name.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;pCommon()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: Mar. 1, 1997 1:45 pm&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;minute()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the minute&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isLeapYear()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if the current year (in the context of the object's
           timezone) is a leap year&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;pMonth()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the abreviated (with period) month name.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;DayOfWeek()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compatibility: see Day&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Day_()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compatibility: see pDay&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isCurrentDay()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           that falls within the current day, in the context
           of this object's timezone representation&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Mon()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compatibility: see aMonth&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;hour()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the 24-hour clock representation of the hour&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Date()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the date string for the object.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aCommonZ()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: Mar 1, 1997 1:45 pm US/Eastern&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;fCommonZ()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: March 1, 1997 1:45 pm US/Eastern&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isCurrentYear()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           that falls within the current year, in the context
           of this object's timezone representation&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;AMPMMinutes()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for an object not showing seconds.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;dd()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return day as a 2 digit string&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;TimeMinutes()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for an object not showing seconds.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;h_24()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the 24-hour clock representation of the hour&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isPast()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           earlier than the time of the call&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;dow()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the integer day of the week, where sunday is 0&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isFuture()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           later than the time of the call&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;pCommonZ()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: Mar. 1, 1997 1:45 pm US/Eastern&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;timezone()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the timezone in which the object is represented.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;h_12()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the 12-hour clock representation of the hour&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;PreciseTime()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for the object.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isCurrentMinute()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           that falls within the current minute, in the context
           of this object's timezone representation&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;rfc822()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the date in RFC 822 format&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;equalTo(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time equal to the specified DateTime
           or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;yy()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return calendar year as a 2 digit string&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;mm()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return month as a 2 digit string&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Mon_()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compatibility: see pMonth&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;toZone(z)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a DateTime with the value as the current
           object, represented in the indicated timezone.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;earliestTime()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a new DateTime object that represents the earliest
           possible time (in whole seconds) that still falls within
           the current object's day, in the object's timezone context&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aDay()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the abreviated name of the day of the week&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;dayOfYear()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the day of the year, in context of
           the timezone representation of the object&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;latestTime()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a new DateTime object that represents the latest
           possible time (in whole seconds) that still falls within
           the current object's day, in the object's timezone context&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;notEqualTo(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time not equal to the specified DateTime
           or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;PreciseAMPM()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for the object.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;day()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the integer day&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;timeTime()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the date/time as a floating-point number in UTC,
           in the format used by the python time module.
           Note that it is possible to create date/time values
           with DateTime that have no meaningful value to the
           time module, and in such cases a DateTimeError is 
           raised. A DateTime object's value must generally be
           between Jan 1, 1970 (or your local machine epoch) and
           Jan 2038 to produce a valid time.time() style value.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;ampm()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the appropriate time modifier (am or pm)&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;greaterThan(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time greater than the specified DateTime
           or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;month()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the month of the object as an integer&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;AMPM()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for an object to the nearest second.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;second()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the second&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;parts()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a tuple containing the calendar year, month,
           day, hour, minute second and timezone of the object&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;greaterThanEqualTo(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time greater than or equal to the 
           specified DateTime or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;lessThanEqualTo(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time less than or equal to the specified 
           DateTime or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isCurrentHour()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           that falls within the current hour, in the context
           of this object's timezone representation&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aCommon()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: Mar 1, 1997 1:45 pm&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;dow_1()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the integer day of the week, where sunday is 1&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Day()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the full name of the day of the week&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;fCommon()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return a string representing the object's value
           in the format: March 1, 1997 1:45 pm&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Month()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the full month name&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;isCurrentMonth()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return true if this object represents a date/time
           that falls within the current month, in the context
           of this object's timezone representation&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;year()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the calendar year of the object&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;lessThan(t)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare this DateTime object to another DateTime object
           OR a floating point number such as that which is returned 
           by the python time module. Returns true if the object 
           represents a date/time less than the specified DateTime
           or time module style time.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;Time()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the time string for an object to the nearest second.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;pDay()&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Return the abreviated (with period) name of the day of the week&lt;/p&gt;


&lt;/dl&gt;
&lt;/dl&gt;

&lt;dl&gt;&lt;dt&gt;&lt;p&gt;&lt;strong&gt;General Services Provided by DateTime&lt;/strong&gt;&lt;/p&gt;&lt;dd&gt;

&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;`aDateTime`&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Convert a DateTime to a string that 
           looks like a Python expression.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;str(aDateTime)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Convert a DateTime to a string.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;cmp(aDateTime, other)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compare a DateTime with another DateTime object, or
           a float such as those returned by time.time().&lt;/p&gt;
&lt;p&gt;           NOTE: __cmp__ support is provided for backward 
           compatibility only, and mixing DateTimes with
           ExtensionClasses could cause __cmp__ to break.
           You should use the methods lessThan, greaterThan,
           lessThanEqualTo, greaterThanEqualTo, equalTo and
           notEqualTo to avoid potential problems later!!&lt;/p&gt;



&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;hash(aDateTime)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Compute a hash value for a DateTime&lt;/p&gt;


&lt;/dl&gt;
&lt;/dl&gt;

&lt;dl&gt;&lt;dt&gt;&lt;p&gt;&lt;strong&gt;Numeric Services Provided by DateTime&lt;/strong&gt;&lt;/p&gt;&lt;dd&gt;

&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aDateTime + other&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;A DateTime may be added to a number and a number may be 
           added to a DateTime;  two DateTimes cannot be added.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;aDateTime - other&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Either a DateTime or a number may be subtracted from a
           DateTime, however, a DateTime may not be subtracted from 
           a number.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;other + aDateTimeAdd aDateTime to other.&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;A DateTime may be added to a number and a number may be 
           added to a DateTime;  two DateTimes cannot be added.&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;int(aDateTime)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Convert to an integer number of days since Jan. 1, 1901 (gmt)&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;long(aDateTime)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Convert to a long-int number of days since Jan. 1, 1901 (gmt)&lt;/p&gt;


&lt;/dl&gt;
&lt;dl&gt;&lt;dt&gt;&lt;strong&gt;float(aDateTime)&lt;/strong&gt;&lt;dd&gt;
&lt;p&gt;Convert to floating-point number of days since Jan. 1, 1901 (gmt)&lt;/p&gt;


&lt;/dl&gt;
&lt;/dl&gt;



&lt;hr&gt;Last Modified: 14 March 1997
&lt;/body&gt;&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.1535">&lt;&lt; copyright &gt;&gt;

"""Encapsulation of date/time values"""

__version__='$Revision: 1.79.6.6 $'[11:-2]

&lt;&lt; DateTime imports &gt;&gt;

# To control rounding errors, we round system time to the nearest
# millisecond.  Then delicate calculations can rely on that the
# maximum precision that needs to be preserved is known.
_system_time = time

@others</t>
<t tx="ekr.20040104185913.1536">import re,sys, os, math,  DateTimeZone
from time import time, gmtime, localtime, asctime
from time import daylight, timezone, altzone, strftime
from types import InstanceType,IntType,FloatType,StringType,UnicodeType

try: from time import tzname
except: tzname=('UNKNOWN','UNKNOWN')</t>
<t tx="ekr.20040104185913.1537">def time():
    return round(_system_time(), 3)
</t>
<t tx="ekr.20040104185913.1538"># Determine machine epoch
tm=((0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334),
    (0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335))
yr,mo,dy,hr,mn,sc=gmtime(0)[:6]
i=int(yr-1)
to_year =int(i*365+i/4-i/100+i/400-693960.0)
to_month=tm[yr%4==0 and (yr%100!=0 or yr%400==0)][mo]
EPOCH  =(to_year+to_month+dy+(hr/24.0+mn/1440.0+sc/86400.0))*86400
jd1901 =2415385L

numericTimeZoneMatch=re.compile(r'[+-][0-9][0-9][0-9][0-9]').match #TS

class _timezone:
	@others
</t>
<t tx="ekr.20040104185913.1539">def __init__(self,data):
    self.name,self.timect,self.typect, \
    self.ttrans,self.tindex,self.tinfo,self.az=data
</t>
<t tx="ekr.20040104185913.1540">def default_index(self):
    if self.timect == 0: return 0
    for i in range(self.typect):
        if self.tinfo[i][1] == 0: return i
    return 0
</t>
<t tx="ekr.20040104185913.1541">def index(self,t=None):
    t=t or time()
    if self.timect==0: idx=(0, 0, 0)
    elif t &lt; self.ttrans[0]:
        i=self.default_index()
        idx=(i, ord(self.tindex[0]),i)
    elif t &gt;= self.ttrans[-1]:
        if self.timect &gt; 1:
            idx=(ord(self.tindex[-1]),ord(self.tindex[-1]),
                 ord(self.tindex[-2]))
        else:
            idx=(ord(self.tindex[-1]),ord(self.tindex[-1]),
                 self.default_index())
    else:
        for i in range(self.timect-1):
            if t &lt; self.ttrans[i+1]:
                if i==0: idx=(ord(self.tindex[0]),ord(self.tindex[1]),
                              self.default_index())
                else:    idx=(ord(self.tindex[i]),ord(self.tindex[i+1]),
                              ord(self.tindex[i-1]))
                break
    return idx
</t>
<t tx="ekr.20040104185913.1542">def info(self,t=None):
    idx=self.index(t)[0]
    zs =self.az[self.tinfo[idx][2]:]
    return self.tinfo[idx][0],self.tinfo[idx][1],zs[:zs.find('\000')]
</t>
<t tx="ekr.20040104185913.1543">class _cache:
	&lt;&lt; class _cache declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1544">_zlst=['Brazil/Acre','Brazil/DeNoronha','Brazil/East',
       'Brazil/West','Canada/Atlantic','Canada/Central',
       'Canada/Eastern','Canada/East-Saskatchewan',
       'Canada/Mountain','Canada/Newfoundland',
       'Canada/Pacific','Canada/Yukon',
       'Chile/Continental','Chile/EasterIsland','CST','Cuba',
       'Egypt','EST','GB-Eire','Greenwich','Hongkong','Iceland',
       'Iran','Israel','Jamaica','Japan','Mexico/BajaNorte',
       'Mexico/BajaSur','Mexico/General','MST','Poland','PST',
       'Singapore','Turkey','Universal','US/Alaska','US/Aleutian',
       'US/Arizona','US/Central','US/Eastern','US/East-Indiana',
       'US/Hawaii','US/Indiana-Starke','US/Michigan',
       'US/Mountain','US/Pacific','US/Samoa','UTC','UCT','GMT',

       'GMT+0100','GMT+0200','GMT+0300','GMT+0400','GMT+0500',
       'GMT+0600','GMT+0700','GMT+0800','GMT+0900','GMT+1000',
       'GMT+1100','GMT+1200','GMT+1300','GMT-0100','GMT-0200',
       'GMT-0300','GMT-0400','GMT-0500','GMT-0600','GMT-0700',
       'GMT-0800','GMT-0900','GMT-1000','GMT-1100','GMT-1200',
       'GMT+1',

       'GMT+0130', 'GMT+0230', 'GMT+0330', 'GMT+0430', 'GMT+0530',
       'GMT+0630', 'GMT+0730', 'GMT+0830', 'GMT+0930', 'GMT+1030',
       'GMT+1130', 'GMT+1230',

       'GMT-0130', 'GMT-0230', 'GMT-0330', 'GMT-0430', 'GMT-0530',
       'GMT-0630', 'GMT-0730', 'GMT-0830', 'GMT-0930', 'GMT-1030',
       'GMT-1130', 'GMT-1230',

       'UT','BST','MEST','SST','FST','WADT','EADT','NZDT',
       'WET','WAT','AT','AST','NT','IDLW','CET','MET',
       'MEWT','SWT','FWT','EET','EEST','BT','ZP4','ZP5','ZP6',
       'WAST','CCT','JST','EAST','GST','NZT','NZST','IDLE']


_zmap={'aest':'GMT+1000', 'aedt':'GMT+1100',
       'aus eastern standard time':'GMT+1000',
       'sydney standard time':'GMT+1000',
       'tasmania standard time':'GMT+1000',
       'e. australia standard time':'GMT+1000',
       'aus central standard time':'GMT+0930',
       'cen. australia standard time':'GMT+0930',
       'w. australia standard time':'GMT+0800',

       'brazil/acre':'Brazil/Acre',
       'brazil/denoronha':'Brazil/Denoronha',
       'brazil/east':'Brazil/East','brazil/west':'Brazil/West',
       'canada/atlantic':'Canada/Atlantic',
       'canada/central':'Canada/Central',
       'canada/eastern':'Canada/Eastern',
       'canada/east-saskatchewan':'Canada/East-Saskatchewan',
       'canada/mountain':'Canada/Mountain',
       'canada/newfoundland':'Canada/Newfoundland',
       'canada/pacific':'Canada/Pacific','canada/yukon':'Canada/Yukon',
       'central europe standard time':'GMT+0100',
       'chile/continental':'Chile/Continental',
       'chile/easterisland':'Chile/EasterIsland',
       'cst':'US/Central','cuba':'Cuba','est':'US/Eastern','egypt':'Egypt',
       'eastern standard time':'US/Eastern',
       'us eastern standard time':'US/Eastern',
       'central standard time':'US/Central',
       'mountain standard time':'US/Mountain',
       'pacific standard time':'US/Pacific',
       'gb-eire':'GB-Eire','gmt':'GMT',

       'gmt+0000':'GMT+0', 'gmt+0':'GMT+0',


       'gmt+0100':'GMT+1', 'gmt+0200':'GMT+2', 'gmt+0300':'GMT+3',
       'gmt+0400':'GMT+4', 'gmt+0500':'GMT+5', 'gmt+0600':'GMT+6',
       'gmt+0700':'GMT+7', 'gmt+0800':'GMT+8', 'gmt+0900':'GMT+9',
       'gmt+1000':'GMT+10','gmt+1100':'GMT+11','gmt+1200':'GMT+12',
       'gmt+1300':'GMT+13',
       'gmt-0100':'GMT-1', 'gmt-0200':'GMT-2', 'gmt-0300':'GMT-3',
       'gmt-0400':'GMT-4', 'gmt-0500':'GMT-5', 'gmt-0600':'GMT-6',
       'gmt-0700':'GMT-7', 'gmt-0800':'GMT-8', 'gmt-0900':'GMT-9',
       'gmt-1000':'GMT-10','gmt-1100':'GMT-11','gmt-1200':'GMT-12',

       'gmt+1': 'GMT+1', 'gmt+2': 'GMT+2', 'gmt+3': 'GMT+3',
       'gmt+4': 'GMT+4', 'gmt+5': 'GMT+5', 'gmt+6': 'GMT+6',
       'gmt+7': 'GMT+7', 'gmt+8': 'GMT+8', 'gmt+9': 'GMT+9',
       'gmt+10':'GMT+10','gmt+11':'GMT+11','gmt+12':'GMT+12',
       'gmt+13':'GMT+13',
       'gmt-1': 'GMT-1', 'gmt-2': 'GMT-2', 'gmt-3': 'GMT-3',
       'gmt-4': 'GMT-4', 'gmt-5': 'GMT-5', 'gmt-6': 'GMT-6',
       'gmt-7': 'GMT-7', 'gmt-8': 'GMT-8', 'gmt-9': 'GMT-9',
       'gmt-10':'GMT-10','gmt-11':'GMT-11','gmt-12':'GMT-12',

       'gmt+130':'GMT+0130',  'gmt+0130':'GMT+0130',
       'gmt+230':'GMT+0230',  'gmt+0230':'GMT+0230',
       'gmt+330':'GMT+0330',  'gmt+0330':'GMT+0330',
       'gmt+430':'GMT+0430',  'gmt+0430':'GMT+0430',
       'gmt+530':'GMT+0530',  'gmt+0530':'GMT+0530',
       'gmt+630':'GMT+0630',  'gmt+0630':'GMT+0630',
       'gmt+730':'GMT+0730',  'gmt+0730':'GMT+0730',
       'gmt+830':'GMT+0830',  'gmt+0830':'GMT+0830',
       'gmt+930':'GMT+0930',  'gmt+0930':'GMT+0930',
       'gmt+1030':'GMT+1030',
       'gmt+1130':'GMT+1130',
       'gmt+1230':'GMT+1230',

       'gmt-130':'GMT-0130',  'gmt-0130':'GMT-0130',
       'gmt-230':'GMT-0230',  'gmt-0230':'GMT-0230',
       'gmt-330':'GMT-0330',  'gmt-0330':'GMT-0330',
       'gmt-430':'GMT-0430',  'gmt-0430':'GMT-0430',
       'gmt-530':'GMT-0530',  'gmt-0530':'GMT-0530',
       'gmt-630':'GMT-0630',  'gmt-0630':'GMT-0630',
       'gmt-730':'GMT-0730',  'gmt-0730':'GMT-0730',
       'gmt-830':'GMT-0830',  'gmt-0830':'GMT-0830',
       'gmt-930':'GMT-0930',  'gmt-0930':'GMT-0930',
       'gmt-1030':'GMT-1030',
       'gmt-1130':'GMT-1130',
       'gmt-1230':'GMT-1230',

       'greenwich':'Greenwich','hongkong':'Hongkong',
       'iceland':'Iceland','iran':'Iran','israel':'Israel',
       'jamaica':'Jamaica','japan':'Japan',
       'mexico/bajanorte':'Mexico/BajaNorte',
       'mexico/bajasur':'Mexico/BajaSur','mexico/general':'Mexico/General',
       'mst':'US/Mountain','pst':'US/Pacific','poland':'Poland',
       'singapore':'Singapore','turkey':'Turkey','universal':'Universal',
       'utc':'Universal','uct':'Universal','us/alaska':'US/Alaska',
       'us/aleutian':'US/Aleutian','us/arizona':'US/Arizona',
       'us/central':'US/Central','us/eastern':'US/Eastern',
       'us/east-indiana':'US/East-Indiana','us/hawaii':'US/Hawaii',
       'us/indiana-starke':'US/Indiana-Starke','us/michigan':'US/Michigan',
       'us/mountain':'US/Mountain','us/pacific':'US/Pacific',
       'us/samoa':'US/Samoa',

       'ut':'Universal',
       'bst':'GMT+1', 'mest':'GMT+2', 'sst':'GMT+2',
       'fst':'GMT+2', 'wadt':'GMT+8', 'eadt':'GMT+11', 'nzdt':'GMT+13',
       'wet':'GMT', 'wat':'GMT-1', 'at':'GMT-2', 'ast':'GMT-4',
       'nt':'GMT-11', 'idlw':'GMT-12', 'cet':'GMT+1', 'cest':'GMT+2',
       'met':'GMT+1',
       'mewt':'GMT+1', 'swt':'GMT+1', 'fwt':'GMT+1', 'eet':'GMT+2',
       'eest':'GMT+3',
       'bt':'GMT+3', 'zp4':'GMT+4', 'zp5':'GMT+5', 'zp6':'GMT+6',
       'wast':'GMT+7', 'cct':'GMT+8', 'jst':'GMT+9', 'east':'GMT+10',
       'gst':'GMT+10', 'nzt':'GMT+12', 'nzst':'GMT+12', 'idle':'GMT+12',
       'ret':'GMT+4'
       }

</t>
<t tx="ekr.20040104185913.1545">def __init__(self):
    self._db=DateTimeZone._data
    self._d,self._zidx={},self._zmap.keys()
</t>
<t tx="ekr.20040104185913.1546">def __getitem__(self,k):
    try:   n=self._zmap[k.lower()]
    except KeyError:
        if numericTimeZoneMatch(k) == None:
            raise 'DateTimeError','Unrecognized timezone: %s' % k
        return k
    try: return self._d[n]
    except KeyError:
        z=self._d[n]=_timezone(self._db[n])
        return z
</t>
<t tx="ekr.20040104185913.1547">def _findLocalTimeZoneName(isDST):
    if not daylight:
        # Daylight savings does not occur in this time zone.
        isDST = 0
    try:
        # Get the name of the current time zone depending
        # on DST.
        _localzone = _cache._zmap[tzname[isDST].lower()]
    except:
        try:
            # Generate a GMT-offset zone name.
            if isDST:
                localzone = altzone
            else:
                localzone = timezone
            offset=(-localzone/(60*60))
            majorOffset=int(offset)
            if majorOffset != 0 :
                minorOffset=abs(int((offset % majorOffset) * 60.0))
            else: minorOffset = 0
            m=majorOffset &gt;= 0 and '+' or ''
            lz='%s%0.02d%0.02d' % (m, majorOffset, minorOffset)
            _localzone = _cache._zmap[('GMT%s' % lz).lower()]
        except:
            _localzone = ''
    return _localzone
</t>
<t tx="ekr.20040104185913.1548"># Some utility functions for calculating dates:

def _calcSD(t):
    # Returns timezone-independent days since epoch and the fractional
    # part of the days.
    dd = t + EPOCH - 86400.0
    d = dd / 86400.0
    s = d - math.floor(d)
    return s, d
</t>
<t tx="ekr.20040104185913.1549">def _calcDependentSecond(tz, t):
    # Calculates the timezone-dependent second (integer part only)
    # from the timezone-independent second.
    fset = _tzoffset(tz, t)
    return fset + long(math.floor(t)) + long(EPOCH) - 86400L
</t>
<t tx="ekr.20040104185913.1550">def _calcDependentSecond2(yr,mo,dy,hr,mn,sc):
    # Calculates the timezone-dependent second (integer part only)
    # from the date given.
    ss = int(hr) * 3600 + int(mn) * 60 + int(sc)
    x = long(_julianday(yr,mo,dy)-jd1901) * 86400 + ss
    return x
</t>
<t tx="ekr.20040104185913.1551">def _calcIndependentSecondEtc(tz, x, ms):
    # Derive the timezone-independent second from the timezone
    # dependent second.
    fsetAtEpoch = _tzoffset(tz, 0.0)
    nearTime = x - fsetAtEpoch - long(EPOCH) + 86400L + ms
    # nearTime is now within an hour of being correct.
    # Recalculate t according to DST.
    fset = long(_tzoffset(tz, nearTime))
    x_adjusted = x - fset + ms
    d = x_adjusted / 86400.0
    t = x_adjusted - long(EPOCH) + 86400L
    millis = (x + 86400 - fset) * 1000 + \
             long(round(ms * 1000.0)) - long(EPOCH * 1000.0)
    s = d - math.floor(d)
    return s,d,t,millis
</t>
<t tx="ekr.20040104185913.1552">def _calcHMS(x, ms):
    # hours, minutes, seconds from integer and float.
    hr = x / 3600
    x = x - hr * 3600
    mn = x / 60
    sc = x - mn * 60 + ms
    return hr,mn,sc
</t>
<t tx="ekr.20040104185913.1553">def _calcYMDHMS(x, ms):
    # x is a timezone-dependent integer of seconds.
    # Produces yr,mo,dy,hr,mn,sc.
    yr,mo,dy=_calendarday(x / 86400 + jd1901)
    x = int(x - (x / 86400) * 86400)
    hr = x / 3600
    x = x - hr * 3600
    mn = x / 60
    sc = x - mn * 60 + ms
    return yr,mo,dy,hr,mn,sc
</t>
<t tx="ekr.20040104185913.1554">def _julianday(yr,mo,dy):
    y,m,d=long(yr),long(mo),long(dy)
    if m &gt; 12L:
        y=y+m/12L
        m=m%12L
    elif m &lt; 1L:
        m=-m
        y=y-m/12L-1L
        m=12L-m%12L
    if y &gt; 0L: yr_correct=0L
    else:      yr_correct=3L
    if m &lt; 3L: y, m=y-1L,m+12L
    if y*10000L+m*100L+d &gt; 15821014L: b=2L-y/100L+y/400L
    else: b=0L
    return (1461L*y-yr_correct)/4L+306001L*(m+1L)/10000L+d+1720994L+b
</t>
<t tx="ekr.20040104185913.1555">def _calendarday(j):
    j=long(j)
    if(j &lt; 2299160L):
        b=j+1525L
    else:
        a=(4L*j-7468861L)/146097L
        b=j+1526L+a-a/4L
    c=(20L*b-2442L)/7305L
    d=1461L*c/4L
    e=10000L*(b-d)/306001L
    dy=int(b-d-306001L*e/10000L)
    mo=(e &lt; 14L) and int(e-1L) or int(e-13L)
    yr=(mo &gt; 2) and (c-4716L) or (c-4715L)
    return int(yr),int(mo),int(dy)
</t>
<t tx="ekr.20040104185913.1556">def _tzoffset(tz, t):
    """Returns the offset in seconds to GMT from a specific timezone (tz) at 
    a specific time (t).  NB! The _tzoffset result is the same same sign as 
    the time zone, i.e. GMT+2 has a 7200 second offset. This is the opposite 
    sign of time.timezone which (confusingly) is -7200 for GMT+2."""
    try:
        return DateTime._tzinfo[tz].info(t)[0]
    except:
        if numericTimeZoneMatch(tz) is not None:
            return int(tz[0:3])*3600+int(tz[0]+tz[3:5])*60
        else:
            return 0 # ??
</t>
<t tx="ekr.20040104185913.1557">def _correctYear(year):
    # Y2K patch.
    if year &gt;= 0 and year &lt; 100:
        # 00-69 means 2000-2069, 70-99 means 1970-1999.
        if year &lt; 70:
            year = 2000 + year
        else:
            year = 1900 + year
    return year
</t>
<t tx="ekr.20040104185913.1558">def safegmtime(t):
    '''gmtime with a safety zone.'''
    try:
        t_int = int(t)
        return  gmtime(t_int)
    except (IOError, OverflowError):
        raise 'TimeError', 'The time %f is beyond the range ' \
              'of this Python implementation.' % float(t)
</t>
<t tx="ekr.20040104185913.1559">def safelocaltime(t):
    '''localtime with a safety zone.'''
    try:
        t_int = int(t)
    except OverflowError:
        raise 'TimeError', 'The time %f is beyond the range ' \
              'of this Python implementation.' % float(t)
    rval = localtime(t_int)
    return rval
</t>
<t tx="ekr.20040104185913.1560">def _tzoffset2rfc822zone(seconds):
    """Takes an offset, such as from _tzoffset(), and returns an rfc822 
       compliant zone specification. Please note that the result of 
       _tzoffset() is the negative of what time.localzone and time.altzone is."""
    return "%+03d%02d" % divmod( (seconds/60), 60) 
</t>
<t tx="ekr.20040104185913.1561">class DateTime:
    """DateTime objects represent instants in time and provide
       interfaces for controlling its representation without
       affecting the absolute value of the object.

       DateTime objects may be created from a wide variety of string
       or numeric data, or may be computed from other DateTime objects.
       DateTimes support the ability to convert their representations
       to many major timezones, as well as the ablility to create a
       DateTime object in the context of a given timezone.

       DateTime objects provide partial numerical behavior:

          - Two date-time objects can be subtracted to obtain a time,
            in days between the two.

          - A date-time object and a positive or negative number may
            be added to obtain a new date-time object that is the given
            number of days later than the input date-time object.

          - A positive or negative number and a date-time object may
            be added to obtain a new date-time object that is the given
            number of days later than the input date-time object.

          - A positive or negative number may be subtracted from a
            date-time object to obtain a new date-time object that is
            the given number of days earlier than the input date-time
            object.

        DateTime objects may be converted to integer, long, or float
        numbers of days since January 1, 1901, using the standard int,
        long, and float functions (Compatibility Note: int, long and
        float return the number of days since 1901 in GMT rather than
        local machine timezone). DateTime objects also provide access
        to their value in a float format usable with the python time
        module, provided that the value of the object falls in the
        range of the epoch-based time module.

        A DateTime object should be considered immutable; all conversion
        and numeric operations return a new DateTime object rather than
        modify the current object."""
	&lt;&lt; class DateTime declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1562"># For security machinery:
__roles__=None
__allow_access_to_unprotected_subobjects__=1

</t>
<t tx="ekr.20040104185913.1563">def __init__(self,*args):
    """Return a new date-time object

    A DateTime object always maintains its value as an absolute
    UTC time, and is represented in the context of some timezone
    based on the arguments used to create the object. A DateTime
    object's methods return values based on the timezone context.

    Note that in all cases the local machine timezone is used for
    representation if no timezone is specified.

    DateTimes may be created with from zero to seven arguments.


      - If the function is called with no arguments, then the
        current date/time is returned, represented in the
        timezone of the local machine.

      - If the function is invoked with a single string argument
        which is a recognized timezone name, an object representing
        the current time is returned, represented in the specified
        timezone.

      - If the function is invoked with a single string argument
        representing a valid date/time, an object representing
        that date/time will be returned.

        As a general rule, any date-time representation that is
        recognized and unambigous to a resident of North America is
        acceptable.(The reason for this qualification is that
        in North America, a date like: 2/1/1994 is interpreted
        as February 1, 1994, while in some parts of the world,
        it is interpreted as January 2, 1994.) A date/time
        string consists of two components, a date component and
        an optional time component, separated by one or more
        spaces. If the time component is omited, 12:00am is
        assumed. Any recognized timezone name specified as the
        final element of the date/time string will be used for
        computing the date/time value. (If you create a DateTime
        with the string 'Mar 9, 1997 1:45pm US/Pacific', the
        value will essentially be the same as if you had captured
        time.time() at the specified date and time on a machine in
        that timezone)
        &lt;PRE&gt;

        e=DateTime('US/Eastern')
        # returns current date/time, represented in US/Eastern.

        x=DateTime('1997/3/9 1:45pm')
        # returns specified time, represented in local machine zone.

        y=DateTime('Mar 9, 1997 13:45:00')
        # y is equal to x


        &lt;/PRE&gt;

        New in Zope 2.4:
        The DateTime constructor automatically detects and handles
        ISO8601 compliant dates (YYYY-MM-DDThh:ss:mmTZD).
        See http://www.w3.org/TR/NOTE-datetime for full specs.

        The date component consists of year, month, and day
        values. The year value must be a one-, two-, or
        four-digit integer. If a one- or two-digit year is
        used, the year is assumed to be in the twentieth
        century. The month may an integer, from 1 to 12, a
        month name, or a month abreviation, where a period may
        optionally follow the abreviation. The day must be an
        integer from 1 to the number of days in the month. The
        year, month, and day values may be separated by
        periods, hyphens, forward, shashes, or spaces. Extra
        spaces are permitted around the delimiters. Year,
        month, and day values may be given in any order as long
        as it is possible to distinguish the components. If all
        three components are numbers that are less than 13,
        then a a month-day-year ordering is assumed.

        The time component consists of hour, minute, and second
        values separated by colons.  The hour value must be an
        integer between 0 and 23 inclusively. The minute value
        must be an integer between 0 and 59 inclusively. The
        second value may be an integer value between 0 and
        59.999 inclusively. The second value or both the minute
        and second values may be ommitted. The time may be
        followed by am or pm in upper or lower case, in which
        case a 12-hour clock is assumed.

      - If the DateTime function is invoked with a single
        Numeric argument, the number is assumed to be
        a floating point value such as that returned by
        time.time().

        A DateTime object is returned that represents
        the gmt value of the time.time() float represented in
        the local machine's timezone.

      - If the function is invoked with two numeric arguments,
        then the first is taken to be an integer year and the
        second argument is taken to be an offset in days from
        the beginning of the year, in the context of the local
        machine timezone.
        The date-time value returned is the given offset number of
        days from the beginning of the given year, represented in
        the timezone of the local machine. The offset may be positive
        or negative.
        Two-digit years are assumed to be in the twentieth
        century.

      - If the function is invoked with two arguments, the first
        a float representing a number of seconds past the epoch
        in gmt (such as those returned by time.time()) and the
        second a string naming a recognized timezone, a DateTime
        with a value of that gmt time will be returned, represented
        in the given timezone.
        &lt;PRE&gt;
        import time
        t=time.time()

        now_east=DateTime(t,'US/Eastern')
        # Time t represented as US/Eastern

        now_west=DateTime(t,'US/Pacific')
        # Time t represented as US/Pacific

        # now_east == now_west
        # only their representations are different

        &lt;/PRE&gt;

      - If the function is invoked with three or more numeric
        arguments, then the first is taken to be an integer
        year, the second is taken to be an integer month, and
        the third is taken to be an integer day. If the
        combination of values is not valid, then a
        DateError is raised. Two-digit years are assumed
        to be in the twentieth century. The fourth, fifth, and
        sixth arguments specify a time in hours, minutes, and
        seconds; hours and minutes should be positive integers
        and seconds is a positive floating point value, all of
        these default to zero if not given. An optional string may
        be given as the final argument to indicate timezone (the
        effect of this is as if you had taken the value of time.time()
        at that time on a machine in the specified timezone).

    In any case that a floating point number of seconds is given
    or derived, it's rounded to the nearest millisecond.

    If a string argument passed to the DateTime constructor cannot be
    parsed, it will raise DateTime.SyntaxError. Invalid date components
    will raise a DateError, while invalid time or timezone components
    will raise a DateTimeError.

    The module function Timezones() will return a list of the
    timezones recognized by the DateTime module. Recognition of
    timezone names is case-insensitive.""" #'

    d=t=s=None
    ac=len(args)
    millisecs = None

    if ac and args[0]==None: return
    elif ac==10:
        # Internal format called only by DateTime
        yr,mo,dy,hr,mn,sc,tz,t,d,s=args
    elif ac == 11:
        # Internal format that includes milliseconds.
        yr,mo,dy,hr,mn,sc,tz,t,d,s,millisecs=args

    elif not args:
        # Current time, to be displayed in local timezone
        t = time()
        lt = safelocaltime(t)
        tz = self.localZone(lt)
        ms = (t - math.floor(t))
        s,d = _calcSD(t)
        yr,mo,dy,hr,mn,sc=lt[:6]
        sc=sc+ms

    elif ac==1:
        arg=args[0]

        if arg=='':
            raise self.SyntaxError, arg

        if type(arg) in [StringType,UnicodeType] and arg.lower() in self._tzinfo._zidx:
            # Current time, to be displayed in specified timezone
            t,tz=time(),self._tzinfo._zmap[arg.lower()]
            ms=(t-math.floor(t))
            # Use integer arithmetic as much as possible.
            s,d = _calcSD(t)
            x = _calcDependentSecond(tz, t)
            yr,mo,dy,hr,mn,sc = _calcYMDHMS(x, ms)

        elif type(arg) in [StringType,UnicodeType]:
            # Date/time string

            if arg.find(' ')==-1 and arg[4]=='-':
                yr,mo,dy,hr,mn,sc,tz=self._parse_iso8601(arg)
            else:
                yr,mo,dy,hr,mn,sc,tz=self._parse(arg)


            if not self._validDate(yr,mo,dy):
                raise self.DateTimeError, 'Invalid date: %s' % arg
            if not self._validTime(hr,mn,int(sc)):
                raise self.DateTimeError, 'Invalid time: %s' % arg
            ms = sc - math.floor(sc)
            x = _calcDependentSecond2(yr,mo,dy,hr,mn,sc)

            if tz:
                try: tz=self._tzinfo._zmap[tz.lower()]
                except KeyError:
                    if numericTimeZoneMatch(tz) is None:
                        raise self.DateTimeError, \
                              'Unknown time zone in date: %s' % arg
            else:
                tz = self._calcTimezoneName(x, ms)
            s,d,t,millisecs = _calcIndependentSecondEtc(tz, x, ms)

        else:
            # Seconds from epoch, gmt
            t = arg
            lt = safelocaltime(t)
            tz = self.localZone(lt)
            ms=(t-math.floor(t))
            s,d = _calcSD(t)
            yr,mo,dy,hr,mn,sc=lt[:6]
            sc=sc+ms

    elif ac==2:
        if type(args[1])==StringType:
            # Seconds from epoch (gmt) and timezone
            t,tz=args
            ms = (t - math.floor(t))
            tz=self._tzinfo._zmap[tz.lower()]
            # Use integer arithmetic as much as possible.
            s,d = _calcSD(t)
            x = _calcDependentSecond(tz, t)
            yr,mo,dy,hr,mn,sc = _calcYMDHMS(x, ms)
        else:
            # Year, julian expressed in local zone
            t = time()
            lt = safelocaltime(t)
            tz = self.localZone(lt)
            yr,jul=args
            yr = _correctYear(yr)
            d=(_julianday(yr,1,0)-jd1901)+jul
            x_float = d * 86400.0
            x_floor = math.floor(x_float)
            ms = x_float - x_floor
            x = long(x_floor)
            yr,mo,dy,hr,mn,sc = _calcYMDHMS(x, ms)
            s,d,t,millisecs = _calcIndependentSecondEtc(tz, x, ms)
    else:
        # Explicit format
        yr,mo,dy=args[:3]
        hr,mn,sc,tz=0,0,0,0
        yr = _correctYear(yr)
        if not self._validDate(yr,mo,dy):
            raise self.DateTimeError, 'Invalid date: %s' % (args,)
        args=args[3:]
        if args:
            hr,args=args[0],args[1:]
            if args:
                mn,args=args[0],args[1:]
                if args:
                    sc,args=args[0],args[1:]
                    if args:
                        tz,args=args[0],args[1:]
                        if args:
                            raise self.DateTimeError,'Too many arguments'
        if not self._validTime(hr,mn,sc):
            raise self.DateTimeError, 'Invalid time: %s' % `args`
        leap = (yr % 4 == 0) and (yr % 100 != 0 or yr % 400 == 0)

        x = _calcDependentSecond2(yr,mo,dy,hr,mn,sc)
        ms = sc - math.floor(sc)
        if tz:
            try: tz=self._tzinfo._zmap[tz.lower()]
            except KeyError:
                if numericTimeZoneMatch(tz) is None:
                    raise self.DateTimeError, \
                          'Unknown time zone: %s' % tz
        else:
            # Get local time zone name
            tz = self._calcTimezoneName(x, ms)
        s,d,t,millisecs = _calcIndependentSecondEtc(tz, x, ms)

    if hr&gt;12:
        self._pmhour=hr-12
        self._pm='pm'
    else:
        self._pmhour=hr or 12
        self._pm= (hr==12) and 'pm' or 'am'
    self._dayoffset=dx=int((_julianday(yr,mo,dy)+2L)%7)
    self._fmon,self._amon,self._pmon= \
        self._months[mo],self._months_a[mo],self._months_p[mo]
    self._fday,self._aday,self._pday= \
        self._days[dx],self._days_a[dx],self._days_p[dx]
    # Round to nearest millisecond in platform-independent way.  You
    # cannot rely on C sprintf (Python '%') formatting to round
    # consistently; doing it ourselves ensures that all but truly
    # horrid C sprintf implementations will yield the same result
    # x-platform, provided the format asks for exactly 3 digits after
    # the decimal point.
    sc = round(sc, 3)
    if sc &gt;= 60.0:  # can happen if, e.g., orig sc was 59.9999
        sc = 59.999
    self._nearsec=math.floor(sc)
    self._year,self._month,self._day     =yr,mo,dy
    self._hour,self._minute,self._second =hr,mn,sc
    self.time,self._d,self._t,self._tz   =s,d,t,tz
    if millisecs is None:
        millisecs = long(math.floor(t * 1000.0))
    self._millis = millisecs
</t>
<t tx="ekr.20040104185913.1564">    # self._millis is the time since the epoch
    # in long integer milliseconds.

DateTimeError='DateTimeError'
SyntaxError  ='Invalid Date-Time String'
DateError    ='Invalid Date Components'
int_pattern  =re.compile(r'([0-9]+)') #AJ
flt_pattern  =re.compile(r':([0-9]+\.[0-9]+)') #AJ
name_pattern =re.compile(r'([a-zA-Z]+)', re.I) #AJ
space_chars  =' \t\n'
delimiters   ='-/.:,+'
_month_len  =((0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
              (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31))
_until_month=((0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334),
              (0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335))
_months     =['','January','February','March','April','May','June','July',
                 'August', 'September', 'October', 'November', 'December']
_months_a   =['','Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
_months_p   =['','Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'June',
                 'July', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.']
_monthmap   ={'january': 1,   'jan': 1,
              'february': 2,  'feb': 2,
              'march': 3,     'mar': 3,
              'april': 4,     'apr': 4,
              'may': 5,
              'june': 6,      'jun': 6,
              'july': 7,      'jul': 7,
              'august': 8,    'aug': 8,
              'september': 9, 'sep': 9, 'sept': 9,
              'october': 10,  'oct': 10,
              'november': 11, 'nov': 11,
              'december': 12, 'dec': 12}
_days       =['Sunday','Monday','Tuesday','Wednesday',
              'Thursday','Friday','Saturday']
_days_a     =['Sun',  'Mon',  'Tue',  'Wed',  'Thu',  'Fri',  'Sat' ]
_days_p     =['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.']
_daymap     ={'sunday': 1,    'sun': 1,
              'monday': 2,    'mon': 2,
              'tuesday': 3,   'tues': 3,  'tue': 3,
              'wednesday': 4, 'wed': 4,
              'thursday': 5,  'thurs': 5, 'thur': 5, 'thu': 5,
              'friday': 6,    'fri': 6,
              'saturday': 7,  'sat': 7}

_localzone0 = _findLocalTimeZoneName(0)
_localzone1 = _findLocalTimeZoneName(1)
_multipleZones = (_localzone0 != _localzone1)
# For backward compatibility only:
_isDST = localtime(time())[8]
_localzone  = _isDST and _localzone1 or _localzone0

_tzinfo     = _cache()

def localZone(self, ltm=None):
    '''Returns the time zone on the given date.  The time zone
    can change according to daylight savings.'''
    if not DateTime._multipleZones:
        return DateTime._localzone0
    if ltm == None:
        ltm = localtime(time())
    isDST = ltm[8]
    lz = isDST and DateTime._localzone1 or DateTime._localzone0
    return lz
</t>
<t tx="ekr.20040104185913.1565">def _calcTimezoneName(self, x, ms):
    # Derive the name of the local time zone at the given
    # timezone-dependent second.
    if not DateTime._multipleZones:
        return DateTime._localzone0
    fsetAtEpoch = _tzoffset(DateTime._localzone0, 0.0)
    nearTime = x - fsetAtEpoch - long(EPOCH) + 86400L + ms
    # nearTime is within an hour of being correct.
    try:
        ltm = safelocaltime(nearTime)
    except:
        # We are beyond the range of Python's date support.
        # Hopefully we can assume that daylight savings schedules
        # repeat every 28 years.  Calculate the name of the
        # time zone using a supported range of years.
        yr,mo,dy,hr,mn,sc = _calcYMDHMS(x, 0)
        yr = ((yr - 1970) % 28) + 1970
        x = _calcDependentSecond2(yr,mo,dy,hr,mn,sc)
        nearTime = x - fsetAtEpoch - long(EPOCH) + 86400L + ms
        ltm = safelocaltime(nearTime)
    tz = self.localZone(ltm)
    return tz
</t>
<t tx="ekr.20040104185913.1566">def _parse(self,st):
    # Parse date-time components from a string
    month=year=tz=tm=None
    spaces        =self.space_chars
    intpat        =self.int_pattern
    fltpat        =self.flt_pattern
    wordpat       =self.name_pattern
    delimiters    =self.delimiters
    MonthNumbers  =self._monthmap
    DayOfWeekNames=self._daymap
    ValidZones    =self._tzinfo._zidx
    TimeModifiers =['am','pm']

    # Find timezone first, since it should always be the last
    # element, and may contain a slash, confusing the parser.
    st= st.strip()
    sp=st.split()
    tz=sp[-1]
    if tz and (tz.lower() in ValidZones): st=' '.join(sp[:-1])
    else: tz = None  # Decide later, since the default time zone
    # could depend on the date.

    ints,dels=[],[]
    i,l=0,len(st)
    while i &lt; l:
        while i &lt; l and st[i] in spaces    : i=i+1
        if i &lt; l and st[i] in delimiters:
            d=st[i]
            i=i+1
        else: d=''
        while i &lt; l and st[i] in spaces    : i=i+1

        # The float pattern needs to look back 1 character, because it
        # actually looks for a preceding colon like ':33.33'. This is
        # needed to avoid accidentally matching the date part of a
        # dot-separated date string such as '1999.12.31'.
        if i &gt; 0: b=i-1
        else: b=i

        ts_results = fltpat.match(st, b)
        if ts_results:
            s=ts_results.group(1)
            i=i+len(s)
            ints.append(float(s))
            continue

        #AJ
        ts_results = intpat.match(st, i)
        if ts_results:
            s=ts_results.group(0)

            ls=len(s)
            i=i+ls
            if (ls==4 and d and d in '+-' and
                (len(ints) + (not not month) &gt;= 3)):
                tz='%s%s' % (d,s)
            else:
                v=int(s)
                ints.append(v)
            continue


        ts_results = wordpat.match(st, i)
        if ts_results:
            o,s=ts_results.group(0),ts_results.group(0).lower()
            i=i+len(s)
            if i &lt; l and st[i]=='.': i=i+1
            # Check for month name:
            if MonthNumbers.has_key(s):
                v=MonthNumbers[s]
                if month is None: month=v
                else: raise self.SyntaxError, st
                continue
            # Check for time modifier:
            if s in TimeModifiers:
                if tm is None: tm=s
                else: raise self.SyntaxError, st
                continue
            # Check for and skip day of week:
            if DayOfWeekNames.has_key(s):
                continue

        raise self.SyntaxError, st

    day=None
    if ints[-1] &gt; 60 and d not in ['.',':'] and len(ints) &gt; 2:
        year=ints[-1]
        del ints[-1]
        if month:
            day=ints[0]
            del ints[:1]
        else:
            month=ints[0]
            day=ints[1]
            del ints[:2]
    elif month:
        if len(ints) &gt; 1:
            if ints[0] &gt; 31:
                year=ints[0]
                day=ints[1]
            else:
                year=ints[1]
                day=ints[0]
            del ints[:2]
    elif len(ints) &gt; 2:
        if ints[0] &gt; 31:
            year=ints[0]
            if ints[1] &gt; 12:
                day=ints[1]
                month=ints[2]
            else:
                day=ints[2]
                month=ints[1]
        if ints[1] &gt; 31:
            year=ints[1]
            if ints[0] &gt; 12 and ints[2] &lt;= 12:
                day=ints[0]
                month=ints[2]
            elif ints[2] &gt; 12 and ints[0] &lt;= 12:
                day=ints[2]
                month=ints[0]
        elif ints[2] &gt; 31:
            year=ints[2]
            if ints[0] &gt; 12:
                day=ints[0]
                month=ints[1]
            else:
                day=ints[1]
                month=ints[0]
        elif ints[0] &lt;= 12:
            month=ints[0]
            day=ints[1]
            year=ints[2]
        del ints[:3]

    if day is None:
        # Use today's date.
        year,month,day = localtime(time())[:3]

    year = _correctYear(year)
    if year &lt; 1000: raise self.SyntaxError, st

    leap = year%4==0 and (year%100!=0 or year%400==0)
    try:
        if not day or day &gt; self._month_len[leap][month]:
            raise self.DateError, st
    except IndexError:
        raise self.DateError, st
    tod=0
    if ints:
        i=ints[0]
        # Modify hour to reflect am/pm
        if tm and (tm=='pm') and i&lt;12:  i=i+12
        if tm and (tm=='am') and i==12: i=0
        if i &gt; 24: raise self.DateTimeError, st
        tod = tod + int(i) * 3600
        del ints[0]
        if ints:
            i=ints[0]
            if i &gt; 60: raise self.DateTimeError, st
            tod = tod + int(i) * 60
            del ints[0]
            if ints:
                i=ints[0]
                if i &gt; 60: raise self.DateTimeError, st
                tod = tod + i
                del ints[0]
                if ints: raise self.SyntaxError,st


    tod_int = int(math.floor(tod))
    ms = tod - tod_int
    hr,mn,sc = _calcHMS(tod_int, ms)
    if not tz:
        # Figure out what time zone it is in the local area
        # on the given date.
        x = _calcDependentSecond2(year,month,day,hr,mn,sc)
        tz = self._calcTimezoneName(x, ms)

    return year,month,day,hr,mn,sc,tz
</t>
<t tx="ekr.20040104185913.1567"># Internal methods
def __getinitargs__(self): return (None,)
</t>
<t tx="ekr.20040104185913.1568">def _validDate(self,y,m,d):
    if m&lt;1 or m&gt;12 or y&lt;0 or d&lt;1 or d&gt;31: return 0
    return d&lt;=self._month_len[(y%4==0 and (y%100!=0 or y%400==0))][m]
</t>
<t tx="ekr.20040104185913.1569">def _validTime(self,h,m,s):
    return h&gt;=0 and h&lt;=23 and m&gt;=0 and m&lt;=59 and s&gt;=0 and s &lt; 60
</t>
<t tx="ekr.20040104185913.1570">def __getattr__(self, name):
    if '%' in name: return strftimeFormatter(self, name)
    raise AttributeError, name
</t>
<t tx="ekr.20040104185913.1571"># Conversion and comparison methods
def timeTime(self):
    """Return the date/time as a floating-point number in UTC,
       in the format used by the python time module.
       Note that it is possible to create date/time values
       with DateTime that have no meaningful value to the
       time module."""
    return self._t
</t>
<t tx="ekr.20040104185913.1572">def toZone(self, z):
    """Return a DateTime with the value as the current
       object, represented in the indicated timezone."""
    t,tz=self._t,self._tzinfo._zmap[z.lower()]
    millis = self.millis()
    #if (t&gt;0 and ((t/86400.0) &lt; 24837)):
    try:
        # Try to use time module for speed.
        yr,mo,dy,hr,mn,sc=safegmtime(t+_tzoffset(tz, t))[:6]
        sc=self._second
        return self.__class__(yr,mo,dy,hr,mn,sc,tz,t,
                              self._d,self.time,millis)
    except:  # gmtime can't perform the calculation in the given range.
        # Calculate the difference between the two time zones.
        tzdiff = _tzoffset(tz, t) - _tzoffset(self._tz, t)
        if tzdiff == 0:
            return self
        sc = self._second
        ms = sc - math.floor(sc)
        x = _calcDependentSecond2(self._year, self._month, self._day,
                                  self._hour, self._minute, sc)
        x_new = x + tzdiff
        yr,mo,dy,hr,mn,sc = _calcYMDHMS(x_new, ms)
        return self.__class__(yr,mo,dy,hr,mn,sc,tz,t,
                              self._d,self.time,millis)
</t>
<t tx="ekr.20040104185913.1573">def isFuture(self):
    """Return true if this object represents a date/time
       later than the time of the call"""
    return (self._t &gt; time())
</t>
<t tx="ekr.20040104185913.1574">def isPast(self):
    """Return true if this object represents a date/time
       earlier than the time of the call"""
    return (self._t &lt; time())
</t>
<t tx="ekr.20040104185913.1575">def isCurrentYear(self):
    """Return true if this object represents a date/time
       that falls within the current year, in the context
       of this object\'s timezone representation"""
    t=time()
    return safegmtime(t+_tzoffset(self._tz, t))[0]==self._year
</t>
<t tx="ekr.20040104185913.1576">def isCurrentMonth(self):
    """Return true if this object represents a date/time
       that falls within the current month, in the context
       of this object\'s timezone representation"""
    t=time()
    gmt=safegmtime(t+_tzoffset(self._tz, t))
    return gmt[0]==self._year and gmt[1]==self._month
</t>
<t tx="ekr.20040104185913.1577">def isCurrentDay(self):
    """Return true if this object represents a date/time
       that falls within the current day, in the context
       of this object\'s timezone representation"""
    t=time()
    gmt=safegmtime(t+_tzoffset(self._tz, t))
    return gmt[0]==self._year and gmt[1]==self._month and gmt[2]==self._day
</t>
<t tx="ekr.20040104185913.1578">def isCurrentHour(self):
    """Return true if this object represents a date/time
       that falls within the current hour, in the context
       of this object\'s timezone representation"""
    t=time()
    gmt=safegmtime(t+_tzoffset(self._tz, t))
    return (gmt[0]==self._year and gmt[1]==self._month and
            gmt[2]==self._day and gmt[3]==self._hour)
</t>
<t tx="ekr.20040104185913.1579">def isCurrentMinute(self):
    """Return true if this object represents a date/time
       that falls within the current minute, in the context
       of this object\'s timezone representation"""
    t=time()
    gmt=safegmtime(t+_tzoffset(self._tz, t))
    return (gmt[0]==self._year and gmt[1]==self._month and
            gmt[2]==self._day and gmt[3]==self._hour and
            gmt[4]==self._minute)
</t>
<t tx="ekr.20040104185913.1580">def earliestTime(self):
    """Return a new DateTime object that represents the earliest
       possible time (in whole seconds) that still falls within
       the current object\'s day, in the object\'s timezone context"""
    return self.__class__(self._year,self._month,self._day,0,0,0,self._tz)
</t>
<t tx="ekr.20040104185913.1581">def latestTime(self):
    """Return a new DateTime object that represents the latest
       possible time (in whole seconds) that still falls within
       the current object\'s day, in the object\'s timezone context"""
    return self.__class__(self._year,self._month,self._day,
                          23,59,59,self._tz)
</t>
<t tx="ekr.20040104185913.1582">def greaterThan(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time greater than the specified DateTime
       or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis &gt; t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t &gt; t)
</t>
<t tx="ekr.20040104185913.1583">__gt__ = greaterThan

def greaterThanEqualTo(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time greater than or equal to the
       specified DateTime or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis &gt;= t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t &gt;= t)
</t>
<t tx="ekr.20040104185913.1584">__ge__ = greaterThanEqualTo

def equalTo(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time equal to the specified DateTime
       or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis == t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t == t)
</t>
<t tx="ekr.20040104185913.1585">__eq__ = equalTo

def notEqualTo(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time not equal to the specified DateTime
       or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis != t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t != t)
</t>
<t tx="ekr.20040104185913.1586">__ne__ = notEqualTo

def lessThan(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time less than the specified DateTime
       or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis &lt; t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t &lt; t)
</t>
<t tx="ekr.20040104185913.1587">__lt__ = lessThan

def lessThanEqualTo(self,t):
    """Compare this DateTime object to another DateTime object
       OR a floating point number such as that which is returned
       by the python time module. Returns true if the object
       represents a date/time less than or equal to the specified
       DateTime or time module style time.
       Revised to give more correct results through comparison of
       long integer milliseconds.
       """
    # Optimized for sorting speed
    try:
        return (self._millis &lt;= t._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return (self._t &lt;= t)
</t>
<t tx="ekr.20040104185913.1588">__le__ = lessThanEqualTo

def isLeapYear(self):
    """Return true if the current year (in the context of the object\'s
       timezone) is a leap year"""
    return self._year%4==0 and (self._year%100!=0 or self._year%400==0)
</t>
<t tx="ekr.20040104185913.1589">def dayOfYear(self):
    """Return the day of the year, in context of
       the timezone representation of the object"""
    d=int(self._d+(_tzoffset(self._tz, self._t)/86400.0))
    return int((d+jd1901)-_julianday(self._year,1,0))
</t>
<t tx="ekr.20040104185913.1590"># Component access
def parts(self):
    """Return a tuple containing the calendar year, month,
       day, hour, minute second and timezone of the object"""
    return self._year, self._month, self._day, self._hour, \
           self._minute, self._second, self._tz
</t>
<t tx="ekr.20040104185913.1591">def timezone(self):
    """Return the timezone in which the object is represented."""
    return self._tz
</t>
<t tx="ekr.20040104185913.1592">def tzoffset(self):
    """Return the timezone offset for the objects timezone."""
    return _tzoffset(self._tz, self._t)
</t>
<t tx="ekr.20040104185913.1593">def year(self):
    """Return the calendar year of the object"""
    return self._year
</t>
<t tx="ekr.20040104185913.1594">def month(self):
    """Return the month of the object as an integer"""
    return self._month
</t>
<t tx="ekr.20040104185913.1595">def Month(self):
    """Return the full month name"""
    return self._fmon
</t>
<t tx="ekr.20040104185913.1596">def aMonth(self):
    """Return the abreviated month name."""
    return self._amon
</t>
<t tx="ekr.20040104185913.1597">def Mon(self):
    """Compatibility: see aMonth"""
    return self._amon
</t>
<t tx="ekr.20040104185913.1598">def pMonth(self):
    """Return the abreviated (with period) month name."""
    return self._pmon
</t>
<t tx="ekr.20040104185913.1599">def Mon_(self):
    """Compatibility: see pMonth"""
    return self._pmon
</t>
<t tx="ekr.20040104185913.1600">def day(self):
    """Return the integer day"""
    return self._day
</t>
<t tx="ekr.20040104185913.1601">def Day(self):
    """Return the full name of the day of the week"""
    return self._fday
</t>
<t tx="ekr.20040104185913.1602">def DayOfWeek(self):
    """Compatibility: see Day"""
    return self._fday
</t>
<t tx="ekr.20040104185913.1603">def aDay(self):
    """Return the abreviated name of the day of the week"""
    return self._aday
</t>
<t tx="ekr.20040104185913.1604">def pDay(self):
    """Return the abreviated (with period) name of the day of the week"""
    return self._pday
</t>
<t tx="ekr.20040104185913.1605">def Day_(self):
    """Compatibility: see pDay"""
    return self._pday
</t>
<t tx="ekr.20040104185913.1606">def dow(self):
    """Return the integer day of the week, where sunday is 0"""
    return self._dayoffset
</t>
<t tx="ekr.20040104185913.1607">def dow_1(self):
    """Return the integer day of the week, where sunday is 1"""
    return self._dayoffset+1
</t>
<t tx="ekr.20040104185913.1608">def h_12(self):
    """Return the 12-hour clock representation of the hour"""
    return self._pmhour
</t>
<t tx="ekr.20040104185913.1609">def h_24(self):
    """Return the 24-hour clock representation of the hour"""
    return self._hour
</t>
<t tx="ekr.20040104185913.1610">def ampm(self):
    """Return the appropriate time modifier (am or pm)"""
    return self._pm
</t>
<t tx="ekr.20040104185913.1611">def hour(self):
    """Return the 24-hour clock representation of the hour"""
    return self._hour
</t>
<t tx="ekr.20040104185913.1612">def minute(self):
    """Return the minute"""
    return self._minute
</t>
<t tx="ekr.20040104185913.1613">def second(self):
    """Return the second"""
    return self._second
</t>
<t tx="ekr.20040104185913.1614">def millis(self):
    """Return the millisecond since the epoch in GMT."""
    try:
        return self._millis
    except AttributeError:
        return self._upgrade_old()
</t>
<t tx="ekr.20040104185913.1615">def _upgrade_old(self):
    """Upgrades a previously pickled DateTime object."""
    millis = long(math.floor(self._t * 1000.0))
    self._millis = millis
    return millis
</t>
<t tx="ekr.20040104185913.1616">def strftime(self, format):
    # Format the date/time using the *current timezone representation*.
    diff = _tzoffset(self._tz, self._t)
    format = re.sub('(^\|[^%])%z',
                           '\\1%+05d' % (diff / 36),
                           format)
    return strftime(format, safegmtime(self.timeTime() + diff))
</t>
<t tx="ekr.20040104185913.1617"># General formats from previous DateTime
def Date(self):
    """Return the date string for the object."""
    return "%s/%2.2d/%2.2d" % (self._year, self._month, self._day)
</t>
<t tx="ekr.20040104185913.1618">def Time(self):
    """Return the time string for an object to the nearest second."""
    return '%2.2d:%2.2d:%2.2d' % (self._hour,self._minute,self._nearsec)
</t>
<t tx="ekr.20040104185913.1619">def TimeMinutes(self):
    """Return the time string for an object not showing seconds."""
    return '%2.2d:%2.2d' % (self._hour,self._minute)
</t>
<t tx="ekr.20040104185913.1620">def AMPM(self):
    """Return the time string for an object to the nearest second."""
    return '%2.2d:%2.2d:%2.2d %s' % (
            self._pmhour,self._minute,self._nearsec,self._pm)
</t>
<t tx="ekr.20040104185913.1621">def AMPMMinutes(self):
    """Return the time string for an object not showing seconds."""
    return '%2.2d:%2.2d %s' % (self._pmhour,self._minute,self._pm)
</t>
<t tx="ekr.20040104185913.1622">def PreciseTime(self):
    """Return the time string for the object."""
    return '%2.2d:%2.2d:%06.3f' % (self._hour,self._minute,self._second)
</t>
<t tx="ekr.20040104185913.1623">def PreciseAMPM(self):
    """Return the time string for the object."""
    return '%2.2d:%2.2d:%06.3f %s' % (
            self._pmhour,self._minute,self._second,self._pm)
</t>
<t tx="ekr.20040104185913.1624">def yy(self):
    """Return calendar year as a 2 digit string"""
    return str(self._year)[-2:]
</t>
<t tx="ekr.20040104185913.1625">def mm(self):
    """Return month as a 2 digit string"""
    return '%02d' % self._month
</t>
<t tx="ekr.20040104185913.1626">def dd(self):
    """Return day as a 2 digit string"""
    return '%02d' % self._day
</t>
<t tx="ekr.20040104185913.1627">def rfc822(self):
    """Return the date in RFC 822 format"""
    tzoffset = _tzoffset2rfc822zone(_tzoffset(self._tz, self._t))
        
    return '%s, %2.2d %s %d %2.2d:%2.2d:%2.2d %s' % (
        self._aday,self._day,self._amon,self._year,
        self._hour,self._minute,self._nearsec,tzoffset)
</t>
<t tx="ekr.20040104185913.1628"># New formats
def fCommon(self):
    """Return a string representing the object\'s value
       in the format: March 1, 1997 1:45 pm"""
    return '%s %s, %4.4d %s:%2.2d %s' % (
           self._fmon,self._day,self._year,self._pmhour,
           self._minute,self._pm)
</t>
<t tx="ekr.20040104185913.1629">def fCommonZ(self):
    """Return a string representing the object\'s value
       in the format: March 1, 1997 1:45 pm US/Eastern"""
    return '%s %s, %4.4d %d:%2.2d %s %s' % (
           self._fmon,self._day,self._year,self._pmhour,
           self._minute,self._pm,self._tz)
</t>
<t tx="ekr.20040104185913.1630">def aCommon(self):
    """Return a string representing the object\'s value
       in the format: Mar 1, 1997 1:45 pm"""
    return '%s %s, %4.4d %s:%2.2d %s' % (
           self._amon,self._day,self._year,self._pmhour,
           self._minute,self._pm)
</t>
<t tx="ekr.20040104185913.1631">def aCommonZ(self):
    """Return a string representing the object\'s value
       in the format: Mar 1, 1997 1:45 pm US/Eastern"""
    return '%s %s, %4.4d %d:%2.2d %s %s' % (
           self._amon,self._day,self._year,self._pmhour,
           self._minute,self._pm,self._tz)
</t>
<t tx="ekr.20040104185913.1632">def pCommon(self):
    """Return a string representing the object\'s value
       in the format: Mar. 1, 1997 1:45 pm"""
    return '%s %s, %4.4d %s:%2.2d %s' % (
           self._pmon,self._day,self._year,self._pmhour,
           self._minute,self._pm)
</t>
<t tx="ekr.20040104185913.1633">def pCommonZ(self):
    """Return a string representing the object\'s value
       in the format: Mar. 1, 1997 1:45 pm US/Eastern"""
    return '%s %s, %4.4d %d:%2.2d %s %s' % (
           self._pmon,self._day,self._year,self._pmhour,
           self._minute,self._pm,self._tz)
</t>
<t tx="ekr.20040104185913.1634">def ISO(self):
    """Return the object in ISO standard format

    Dates are output as: YYYY-MM-DD HH:MM:SS
    """
    return "%.4d-%.2d-%.2d %.2d:%.2d:%.2d" % (
        self._year, self._month, self._day,
        self._hour, self._minute, self._second)
</t>
<t tx="ekr.20040104185913.1635">def HTML4(self):
    """Return the object in the format used in the HTML4.0 specification,
    one of the standard forms in ISO8601.  See
           http://www.w3.org/TR/NOTE-datetime

    Dates are output as: YYYY-MM-DDTHH:MM:SSZ
       T, Z are literal characters.
       The time is in UTC.
    """

    newdate = self.toZone('UTC')
    return "%0.4d-%0.2d-%0.2dT%0.2d:%0.2d:%0.2dZ" % (
        newdate._year, newdate._month, newdate._day,
        newdate._hour, newdate._minute, newdate._second)
</t>
<t tx="ekr.20040104185913.1636">def __add__(self,other):
    """A DateTime may be added to a number and a number may be
       added to a DateTime;  two DateTimes cannot be added."""
    if hasattr(other,'_t'):
        raise self.DateTimeError,'Cannot add two DateTimes'
    o=float(other)
    tz = self._tz
    t = (self._t + (o*86400.0))
    d = (self._d + o)
    s = d - math.floor(d)
    ms = t - math.floor(t)
    x = _calcDependentSecond(tz, t)
    yr,mo,dy,hr,mn,sc = _calcYMDHMS(x, ms)
    return self.__class__(yr,mo,dy,hr,mn,sc,self._tz,t,d,s)
</t>
<t tx="ekr.20040104185913.1637">__radd__=__add__

def __sub__(self,other):
    """Either a DateTime or a number may be subtracted from a
       DateTime, however, a DateTime may not be subtracted from
       a number."""
    if hasattr(other, '_d'):
        if 0:  # This logic seems right but is incorrect.
            my_t = self._t + _tzoffset(self._tz, self._t)
            ob_t = other._t + _tzoffset(other._tz, other._t)
            return (my_t - ob_t) / 86400.0
        return self._d - other._d
    else:
        return self.__add__(-(other))
</t>
<t tx="ekr.20040104185913.1638">def __repr__(self):
    """Convert a DateTime to a string that
       looks like a Python expression."""
    return '%s(\'%s\')' % (self.__class__.__name__,str(self))
</t>
<t tx="ekr.20040104185913.1639">def __str__(self):
    """Convert a DateTime to a string."""
    y,m,d   =self._year,self._month,self._day
    h,mn,s,t=self._hour,self._minute,self._second,self._tz
    if h == mn == s == 0:
        # hh:mm:ss all zero -- suppress the time.
        return '%4.4d/%2.2d/%2.2d' % (y, m, d)
    elif s == int(s):
        # A whole number of seconds -- suppress milliseconds.
        return '%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d %s' % (
                y, m, d, h, mn, s, t)
    else:
        # s is already rounded to the nearest millisecond, and
        # it's not a whole number of seconds.  Be sure to print
        # 2 digits before the decimal point.
        return '%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%06.3f %s' % (
                y, m, d, h, mn, s, t)
</t>
<t tx="ekr.20040104185913.1640">def __cmp__(self,obj):
    """Compare a DateTime with another DateTime object, or
       a float such as those returned by time.time().

       NOTE: __cmp__ support is provided for backward
       compatibility only, and mixing DateTimes with
       ExtensionClasses could cause __cmp__ to break.
       You should use the methods lessThan, greaterThan,
       lessThanEqualTo, greaterThanEqualTo, equalTo and
       notEqualTo to avoid potential problems later!!"""
    # Optimized for sorting speed.
    try:
        return cmp(self._millis, obj._millis)
    except AttributeError:
        try: self._millis
        except AttributeError: self._upgrade_old()
    return cmp(self._t,obj)
</t>
<t tx="ekr.20040104185913.1641">def __hash__(self):
    """Compute a hash value for a DateTime"""
    return int(((self._year%100*12+self._month)*31+
                 self._day+self.time)*100)
</t>
<t tx="ekr.20040104185913.1642">def __int__(self):
    """Convert to an integer number of seconds since the epoch (gmt)"""
    return int(self.millis() / 1000)
</t>
<t tx="ekr.20040104185913.1643">def __long__(self):
    """Convert to a long-int number of seconds since the epoch (gmt)"""
    return long(self.millis() / 1000)
</t>
<t tx="ekr.20040104185913.1644">def __float__(self):
    """Convert to floating-point number of seconds since the epoch (gmt)"""
    return float(self._t)
</t>
<t tx="ekr.20040104185913.1645">def _parse_iso8601(self,s):
    try:
        return self.__parse_iso8601(s)
    except IndexError:
        raise self.DateError,'Not an ISO 8601 compliant date string: "%s"' %  s
</t>
<t tx="ekr.20040104185913.1646">def __parse_iso8601(self,s):
    """ parse an ISO 8601 compliant date """
    year=0
    month=day=1
    hour=minute=seconds=hour_off=min_off=0

    datereg = re.compile('([0-9]{4})(-([0-9][0-9]))?(-([0-9][0-9]))?')
    timereg = re.compile('([0-9]{2})(:([0-9][0-9]))?(:([0-9][0-9]))?(\.[0-9]{1,20})?')

    # Date part

    fields = datereg.split(s.strip())

    if fields[1]:   year  = int(fields[1])
    if fields[3]:   month = int(fields[3])
    if fields[5]:   day   = int(fields[5])

    if s.find('T')&gt;-1:
        fields = timereg.split(s[s.find('T')+1:])

        if fields[1]:   hour     = int(fields[1])
        if fields[3]:   minute   = int(fields[3])
        if fields[5]:   seconds  = int(fields[5])
        if fields[6]:   seconds  = seconds+float(fields[6])

    if s.find('Z')&gt;-1:
        pass

    if s[-3]==':' and s[-6] in ['+','-']:
        hour_off = int(s[-6:-3])
        min_off  = int(s[-2:])

    return year,month,day,hour,minute,seconds,'GMT%+03d%02d' % (hour_off,min_off)
</t>
<t tx="ekr.20040104185913.1647">def JulianDay(self):
    """
    Return the Julian day according to
    http://www.tondering.dk/claus/cal/node3.html#sec-calcjd
    """
    a = (14 - self._month)/12 #integer division, discard remainder
    y = self._year + 4800 - a
    m = self._month + (12*a) - 3
    return self._day + (153*m+2)/5 + 365*y + y/4 - y/100 + y/400 - 32045
</t>
<t tx="ekr.20040104185913.1648">def week(self):
    """
    Return the week number according to ISO
    see http://www.tondering.dk/claus/cal/node6.html#SECTION00670000000000000000
    """
    J = self.JulianDay()
    d4 = (J + 31741 - (J % 7)) % 146097 % 36524 % 1461
    L = d4/1460
    d1 = (( d4 - L) % 365) + L
    return d1/7 + 1
</t>
<t tx="ekr.20040104185913.1649">class strftimeFormatter:
	@others
</t>
<t tx="ekr.20040104185913.1650">def __init__(self, dt, format):
    self._dt=dt
    self._f=format
</t>
<t tx="ekr.20040104185913.1651">def __call__(self): return self._dt.strftime(self._f)
</t>
<t tx="ekr.20040104185913.1652"># Module methods
def Timezones():
    """Return the list of recognized timezone names"""
    return _cache._zlst
</t>
<t tx="ekr.20040104185913.1653">&lt;&lt; copyright &gt;&gt;

&lt;&lt; define _data &gt;&gt;</t>
<t tx="ekr.20040104185913.1654">&lt;&lt; copyright &gt;&gt;

from DateTime import DateTime
from DateTime import Timezones
</t>
<t tx="ekr.20040104185913.1655"></t>
<t tx="ekr.20040104185913.1656">&lt;&lt; testDateTime declarations &gt;&gt;

@others

if __name__=="__main__":
    unittest.main(defaultTest='test_suite')
</t>
<t tx="ekr.20040104185913.1657"># To run these tests, use:
#   python unittest.py DateTime.tests.suite

import math
import os
import time
import unittest

from DateTime import DateTime

try:
    __file__
except NameError:
    import sys
    f = sys.argv[0]
else:
    f = __file__

DATADIR = os.path.dirname(os.path.abspath(f))
del f
</t>
<t tx="ekr.20040104185913.1658">class DateTimeTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.1659">def _compare(self, dt1, dt2, ms=1):
    '''Compares the internal representation of dt1 with
    the representation in dt2.  Allows sub-millisecond variations.
    Primarily for testing.'''
    if ms:
        self.assertEqual(dt1.millis(),dt2.millis())
    self.assertEqual(math.floor(dt1._t * 1000.0),
                     math.floor(dt2._t * 1000.0))
    self.assertEqual(math.floor(dt1._d * 86400000.0),
                     math.floor(dt2._d * 86400000.0))
    self.assertEqual(math.floor(dt1.time * 86400000.0),
                     math.floor(dt2.time * 86400000.0))
</t>
<t tx="ekr.20040104185913.1660">def testBug1203(self):
    '''01:59:60 occurred in old DateTime'''
    dt = DateTime(7200, 'GMT')
    self.assert_(str(dt).find('60') &lt; 0, dt)
</t>
<t tx="ekr.20040104185913.1661">def testDSTInEffect(self):
    '''Checks GMT offset for a DST date in the US/Eastern time zone'''
    dt = DateTime(2000, 5, 9, 15, 0, 0, 'US/Eastern')
    self.assertEqual(dt.toZone('GMT').hour(), 19,
                     (dt, dt.toZone('GMT')))
</t>
<t tx="ekr.20040104185913.1662">def testDSTNotInEffect(self):
    '''Checks GMT offset for a non-DST date in the US/Eastern time zone'''
    dt = DateTime(2000, 11, 9, 15, 0, 0, 'US/Eastern')
    self.assertEqual(dt.toZone('GMT').hour(), 20,
                     (dt, dt.toZone('GMT')))
</t>
<t tx="ekr.20040104185913.1663">def testAddPrecision(self):
    '''Precision of serial additions'''
    dt = DateTime()
    self.assertEqual(str(dt + 0.10 + 3.14 + 6.76 - 10), str(dt),
                     dt)
</t>
<t tx="ekr.20040104185913.1664">def testConstructor3(self):
    '''Constructor from date/time string'''
    dt = DateTime()
    dt1s = '%d/%d/%d %d:%d:%f %s' % (
        dt.year(),
        dt.month(),
        dt.day(),
        dt.hour(),
        dt.minute(),
        dt.second(),
        dt.timezone())
    dt1 = DateTime(dt1s)
    # Compare representations as it's the
    # only way to compare the dates to the same accuracy
    self.assertEqual(repr(dt),repr(dt1))
</t>
<t tx="ekr.20040104185913.1665">def testConstructor4(self):
    '''Constructor from time float'''
    dt = DateTime()
    dt1 = DateTime(float(dt))
    self._compare(dt,dt1)
</t>
<t tx="ekr.20040104185913.1666">def testConstructor5(self):
    '''Constructor from time float and timezone'''
    dt = DateTime()
    dt1 = DateTime(float(dt), dt.timezone())
    self.assertEqual(str(dt), str(dt1), (dt, dt1))
</t>
<t tx="ekr.20040104185913.1667">def testConstructor6(self):
    '''Constructor from year and julian date'''
    # This test must normalize the time zone, or it *will* break when
    # DST changes!
    dt1 = DateTime(2000, 5.500000578705)
    dt = DateTime('2000/1/5 12:00:00.050 pm %s' % dt1.localZone())
    self._compare(dt, dt1)
</t>
<t tx="ekr.20040104185913.1668">def testConstructor7(self):
    '''Constructor from parts'''
    dt = DateTime()
    dt1 = DateTime(
        dt.year(),
        dt.month(),
        dt.day(),
        dt.hour(),
        dt.minute(),
        dt.second(),
        dt.timezone())
    # Compare representations as it's the
    # only way to compare the dates to the same accuracy
    self.assertEqual(repr(dt), repr(dt1))
</t>
<t tx="ekr.20040104185913.1669">def testDayOfWeek(self):
    '''strftime() used to always be passed a day of week of 0.'''
    dt = DateTime('2000/6/16')
    s = dt.strftime('%A')
    self.assertEqual(s, 'Friday', (dt, s))
</t>
<t tx="ekr.20040104185913.1670">def testOldDate(self):
    '''Fails when an 1800 date is displayed with negative signs'''
    dt = DateTime('1830/5/6 12:31:46.213 pm')
    dt1 = dt.toZone('GMT+6')
    self.assert_(str(dt1).find('-') &lt; 0, (dt, dt1))
</t>
<t tx="ekr.20040104185913.1671">def testSubtraction(self):
    '''Reconstruction of a DateTime from its parts, with subtraction'''
    dt = DateTime()
    dt1 = dt - 3.141592653
    dt2 = DateTime(
        dt.year(),
        dt.month(),
        dt.day(),
        dt.hour(),
        dt.minute(),
        dt.second())
    dt3 = dt2 - 3.141592653
    self.assertEqual(dt1, dt3, (dt, dt1, dt2, dt3))
</t>
<t tx="ekr.20040104185913.1672">def testTZ1add(self):
    '''Time zone manipulation: add to a date'''
    dt = DateTime('1997/3/8 1:45am GMT-4')
    dt1 = DateTime('1997/3/9 1:45pm GMT+8')
    self.assertEqual(dt + 1.0, dt1, (dt, dt1))
</t>
<t tx="ekr.20040104185913.1673">def testTZ1sub(self):
    '''Time zone manipulation: subtract from a date'''
    dt = DateTime('1997/3/8 1:45am GMT-4')
    dt1 = DateTime('1997/3/9 1:45pm GMT+8')
    self.assertEqual(dt1 - 1.0, dt, (dt, dt1))
</t>
<t tx="ekr.20040104185913.1674">def testTZ1diff(self):
    '''Time zone manipulation: diff two dates'''
    dt = DateTime('1997/3/8 1:45am GMT-4')
    dt1 = DateTime('1997/3/9 1:45pm GMT+8')
    self.assertEqual(dt1 - dt, 1.0, (dt, dt1))
</t>
<t tx="ekr.20040104185913.1675">def testCompareMethods(self):
    '''Compare two dates using several methods'''
    dt = DateTime('1997/1/1')
    dt1 = DateTime('1997/2/2')
    self.failUnless(dt1.greaterThan(dt))
    self.failUnless(dt1.greaterThanEqualTo(dt))
    self.failUnless(dt.lessThan(dt1))
    self.failUnless(dt.lessThanEqualTo(dt1))
    self.failUnless(dt.notEqualTo(dt1))
    self.failUnless(not dt.equalTo(dt1))
</t>
<t tx="ekr.20040104185913.1676">def testCompareOperations(self, dt=None, dt1=None):
    """Compare two dates using several operations"""
    if dt is None:
        dt = DateTime('1997/1/1')
    if dt1 is None:
        dt1 = DateTime('1997/2/2')
    self.failUnless(dt1 &gt; dt)
    self.failUnless(dt1 &gt;= dt)
    self.failUnless(dt &lt; dt1)
    self.failUnless(dt &lt;= dt1)
    self.failUnless(dt != dt1)
    self.failUnless(not (dt == dt1))
</t>
<t tx="ekr.20040104185913.1677">def testUpgradeOldInstances(self):
    """Compare dates that don't have the _millis attribute yet."""
    dt = DateTime('1997/1/1')
    dt1 = DateTime('1997/2/2')
    del dt._millis
    del dt1._millis
    self.testCompareOperations(dt, dt1)
</t>
<t tx="ekr.20040104185913.1678">def testTZ2(self):
    '''Time zone manipulation test 2'''
    dt = DateTime()
    dt1 = dt.toZone('GMT')
    s = dt.second()
    s1 = dt1.second()
    self.assertEqual(s, s1, (dt, dt1, s, s1))
</t>
<t tx="ekr.20040104185913.1679">def testTZDiffDaylight(self):
    '''Diff dates across daylight savings dates'''
    dt = DateTime('2000/6/8 1:45am US/Eastern')
    dt1 = DateTime('2000/12/8 12:45am US/Eastern')
    self.assertEqual(dt1 - dt, 183, (dt, dt1, dt1 - dt))
</t>
<t tx="ekr.20040104185913.1680">def testY10KDate(self):
    '''Comparison of a Y10K date and a Y2K date'''
    dt = DateTime('10213/09/21')
    dt1 = DateTime(2000, 1, 1)

    dsec = (dt.millis() - dt1.millis()) / 1000.0
    ddays = math.floor((dsec / 86400.0) + 0.5)

    self.assertEqual(ddays, 3000000L, ddays)
</t>
<t tx="ekr.20040104185913.1681">def test_tzoffset(self):
    '''Test time-zone given as an offset'''

    # GMT
    dt = DateTime('Tue, 10 Sep 2001 09:41:03 GMT')
    self.assertEqual(dt.tzoffset(), 0)

    # Timezone by name, a timezone that hasn't got daylightsaving.
    dt = DateTime('Tue, 2 Mar 2001 09:41:03 GMT+3')
    self.assertEqual(dt.tzoffset(), 10800)

    # Timezone by name, has daylightsaving but is not in effect.
    dt = DateTime('Tue, 21 Jan 2001 09:41:03 PST')
    self.assertEqual(dt.tzoffset(), -28800)

    # Timezone by name, with daylightsaving in effect
    dt = DateTime('Tue, 24 Aug 2001 09:41:03 PST')
    self.assertEqual(dt.tzoffset(), -25200)

    # A negative numerical timezone
    dt = DateTime('Tue, 24 Jul 2001 09:41:03 -0400')
    self.assertEqual(dt.tzoffset(), -14400)
    
    # A positive numerical timzone
    dt = DateTime('Tue, 6 Dec 1966 01:41:03 +0200')
    self.assertEqual(dt.tzoffset(), 7200)
    
    # A negative numerical timezone with minutes.
    dt = DateTime('Tue, 24 Jul 2001 09:41:03 -0637')
    self.assertEqual(dt.tzoffset(), -23820)

    # A positive numerical timezone with minutes.
    dt = DateTime('Tue, 24 Jul 2001 09:41:03 +0425')
    self.assertEqual(dt.tzoffset(), 15900)
</t>
<t tx="ekr.20040104185913.1682">def testISO8601(self):
    ''' iso 8601 dates '''

    ref0 = DateTime('2002/5/2 8:00am GMT')
    ref1 = DateTime('2002/5/2 8:00am US/Eastern')

    isoDt = DateTime('2002-05-02T08:00:00')
    self.assertEqual( ref0, isoDt)
    isoDt = DateTime('2002-05-02T08:00:00Z')
    self.assertEqual( ref0, isoDt)

    isoDt = DateTime('2002-05-02T08:00:00Z-04:00')
    self.assertEqual( ref1, isoDt)
</t>
<t tx="ekr.20040104185913.1683">def testJulianWeek(self):
    """ check JulianDayWeek function """

    try:
        import gzip
    except ImportError:
        print "Warning: testJulianWeek disabled: module gzip not found"
        return 0

    fn = os.path.join(DATADIR, 'julian_testdata.txt.gz')
    lines = gzip.GzipFile(fn).readlines()

    for line in lines:
        d = DateTime(line[:10])
        result_from_mx=tuple(map(int, line[12:-2].split(',')))
        self.assertEqual(result_from_mx[1], d.week())
</t>
<t tx="ekr.20040104185913.1684">def testRFC822(self):
    '''rfc822 conversion'''
    dt = DateTime('2002-05-02T08:00:00Z+00:00')
    self.assertEqual(dt.rfc822(), 'Thu, 02 May 2002 08:00:00 +0000')

    dt = DateTime('2002-05-02T08:00:00Z+02:00')
    self.assertEqual(dt.rfc822(), 'Thu, 02 May 2002 08:00:00 +0200')

    dt = DateTime('2002-05-02T08:00:00Z-02:00')
    self.assertEqual(dt.rfc822(), 'Thu, 02 May 2002 08:00:00 -0200')

    # Checking that conversion from local time is working.
    dt = DateTime()
    dts = dt.rfc822().split(' ')
    times = dts[4].split(':')
    _isDST = time.localtime(time.time())[8]
    if _isDST: offset = time.altzone
    else:      offset = time.timezone

    self.assertEqual(dts[0], dt.aDay() + ',')
    self.assertEqual(int(dts[1]), dt.day())
    self.assertEqual(dts[2], dt.aMonth())
    self.assertEqual(int(dts[3]), dt.year())
    self.assertEqual(int(times[0]), dt.h_24())
    self.assertEqual(int(times[1]), dt.minute())
    self.assertEqual(int(times[2]), int(dt.second()))
    self.assertEqual(dts[5], "%+03d%02d" % divmod( (-offset/60), 60) )
</t>
<t tx="ekr.20040104185913.1685">def test_suite():
    return unittest.makeSuite(DateTimeTests)
</t>
<t tx="ekr.20040104185913.1686"></t>
<t tx="ekr.20040104185913.1687">&lt;&lt; copyright &gt;&gt;

"""HTML formated DocumentTemplates

$Id: DT_HTML.py,v 1.32 2002/08/14 22:29:52 mj Exp $"""

&lt;&lt; DT_HTML imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.1688">from DT_String import String, FileMixin
import DT_String, re
from DT_Util import ParseError, str</t>
<t tx="ekr.20040104185913.1689">class dtml_re_class:
    """ This needs to be replaced before 2.4.  It's a hackaround. """
	@others
</t>
<t tx="ekr.20040104185913.1690">def search(self, text, start=0,
           name_match=re.compile('[\000- ]*[a-zA-Z]+[\000- ]*').match,
           end_match=re.compile('[\000- ]*(/|end)', re.I).match,
           start_search=re.compile('[&lt;&amp;]').search,
           ent_name=re.compile('[-a-zA-Z0-9_.]+').match,
           ):

    while 1:
        mo = start_search(text,start)
        if mo is None: return None
        s = mo.start(0)
        if text[s:s+5] == '&lt;!--#':
            n=s+5
            e=text.find('--&gt;',n)
            if e &lt; 0: return None
            en=3

            mo =end_match(text,n)
            if mo is not None:
                l = mo.end(0) - mo.start(0)
                end=text[n:n+l].strip()
                n=n+l
            else: end=''

        elif text[s:s+6] == '&lt;dtml-':
            e=n=s+6
            while 1:
                e=text.find('&gt;',e+1)
                if e &lt; 0: return None
                if len(text[n:e].split('"'))%2:
                    # check for even number of "s inside
                    break

            en=1
            end=''

        elif text[s:s+7] == '&lt;/dtml-':
            e=n=s+7
            while 1:
                e=text.find('&gt;',e+1)
                if e &lt; 0: return None
                if len(text[n:e].split('"'))%2:
                    # check for even number of "s inside
                    break

            en=1
            end='/'

        else:
            if text[s:s+5] == '&amp;dtml' and text[s+5] in '.-':
                n=s+6
                e=text.find(';',n)
                if e &gt;= 0:
                    args=text[n:e]
                    l=len(args)
                    mo = ent_name(args)
                    if mo is not None:
                        if mo.end(0)-mo.start(0) == l:
                            d=self.__dict__
                            if text[s+5]=='-':
                                d[1]=d['end']=''
                                d[2]=d['name']='var'
                                d[0]=text[s:e+1]
                                d[3]=d['args']=args+' html_quote'
                                self._start = s
                                return self
                            else:
                                nn=args.find('-')
                                if nn &gt;= 0 and nn &lt; l-1:
                                    d[1]=d['end']=''
                                    d[2]=d['name']='var'
                                    d[0]=text[s:e+1]
                                    args=args[nn+1:]+' '+ \
                                          args[:nn].replace('.',' ')
                                    d[3]=d['args']=args
                                    self._start = s
                                    return self

            start=s+1
            continue

        break

    mo = name_match(text,n)
    if mo is None: return None
    l = mo.end(0) - mo.start(0)

    a=n+l
    name=text[n:a].strip()

    args=text[a:e].strip()

    d=self.__dict__
    d[0]=text[s:e+en]
    d[1]=d['end']=end
    d[2]=d['name']=name
    d[3]=d['args']=args
    self._start = s
    return self
</t>
<t tx="ekr.20040104185913.1691">def group(self, *args):
    get=self.__dict__.get
    if len(args)==1:
        return get(args[0])
    return tuple(map(get, args))
</t>
<t tx="ekr.20040104185913.1692">def start(self, *args):
    return self._start
</t>
<t tx="ekr.20040104185913.1693">class HTML(DT_String.String):
    """HTML Document Templates

    HTML Document templates use HTML server-side-include syntax,
    rather than Python format-string syntax.  Here's a simple example:

      &lt;!--#in results--&gt;
        &lt;!--#var name--&gt;
      &lt;!--#/in--&gt;

    HTML document templates quote HTML tags in source when the
    template is converted to a string.  This is handy when templates
    are inserted into HTML editing forms.
    """
	&lt;&lt; class HTML declarations &gt;&gt;
	@others

    manage_editDocument__roles__=()
    manage__roles__=()
    manage_editDocument=manage=manage_editForm</t>
<t tx="ekr.20040104185913.1694">tagre__roles__=()
</t>
<t tx="ekr.20040104185913.1695">def tagre(self):
    return dtml_re_class()
</t>
<t tx="ekr.20040104185913.1696">parseTag__roles__=()
def parseTag(self, match_ob, command=None, sargs=''):
    """Parse a tag using an already matched re

    Return: tag, args, command, coname

    where: tag is the tag,
           args is the tag\'s argument string,
           command is a corresponding command info structure if the
              tag is a start tag, or None otherwise, and
           coname is the name of a continue tag (e.g. else)
             or None otherwise
    """
    tag, end, name, args = match_ob.group(0, 'end', 'name', 'args')
    args=args.strip()
    if end:
        if not command or name != command.name:
            raise ParseError, ('unexpected end tag', tag)
        return tag, args, None, None

    if command and name in command.blockContinuations:

        if name=='else' and args:
            # Waaaaaah! Have to special case else because of
            # old else start tag usage. Waaaaaaah!
            l=len(args)
            if not (args==sargs or
                    args==sargs[:l] and sargs[l:l+1] in ' \t\n'):
                return tag, args, self.commands[name], None

        return tag, args, None, name

    try: return tag, args, self.commands[name], None
    except KeyError:
        raise ParseError, ('Unexpected tag', tag)
</t>
<t tx="ekr.20040104185913.1697">SubTemplate__roles__=()
def SubTemplate(self, name): return HTML('', __name__=name)
</t>
<t tx="ekr.20040104185913.1698">varExtra__roles__=()
def varExtra(self, match_ob): return 's'
</t>
<t tx="ekr.20040104185913.1699">manage_edit__roles__=()
def manage_edit(self,data,REQUEST=None):
    'edit a template'
    self.munge(data)
    if REQUEST: return self.editConfirmation(self,REQUEST)
</t>
<t tx="ekr.20040104185913.1700">quotedHTML__roles__=()
def quotedHTML(self,
               text=None,
               character_entities=(
                   (('&amp;'), '&amp;amp;'),
                   (("&lt;"), '&amp;lt;' ),
                   (("&gt;"), '&amp;gt;' ),
                   (('"'), '&amp;quot;'))): #"
    if text is None: text=self.read_raw()
    for re,name in character_entities:
        if text.find(re) &gt;= 0: text=name.join(text.split(re))
    return text
</t>
<t tx="ekr.20040104185913.1701">errQuote__roles__=()
errQuote=quotedHTML

def __str__(self):
    return self.quotedHTML()
</t>
<t tx="ekr.20040104185913.1702"># these should probably all be deprecated.
management_interface__roles__=()
def management_interface(self):
    '''Hook to allow public execution of management interface with
    everything else private.'''
    return self
</t>
<t tx="ekr.20040104185913.1703">manage_editForm__roles__=()
def manage_editForm(self, URL1, REQUEST):
    '''Display doc template editing form''' #"

    return self._manage_editForm(
        self,
        mapping=REQUEST,
        __str__=str(self),
        URL1=URL1
        )
</t>
<t tx="ekr.20040104185913.1704">class HTMLDefault(HTML):
    '''\
    HTML document templates that edit themselves through copy.

    This is to make a distinction from HTML objects that should edit
    themselves in place.
    '''
	&lt;&lt; class HTMLDefault declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1705">copy_class__roles__=()
copy_class=HTML

manage_edit__roles__=()
</t>
<t tx="ekr.20040104185913.1706">def manage_edit(self,data,PARENTS,URL1,REQUEST):
    'edit a template'
    newHTML=self.copy_class(data,self.globals,self.__name__)
    setattr(PARENTS[1],URL1[URL1.rfind('/')+1:],newHTML)
    return self.editConfirmation(self,REQUEST)
</t>
<t tx="ekr.20040104185913.1707">class HTMLFile(FileMixin, HTML):
    """\
    HTML Document templates read from files.

    If the object is pickled, the file name, rather
    than the file contents is pickled.  When the object is
    unpickled, then the file will be re-read to obtain the string.
    Note that the file will not be read until the document
    template is used the first time.
    """
	&lt;&lt; class HTMLFile declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1708">manage_default__roles__=()
</t>
<t tx="ekr.20040104185913.1709">def manage_default(self, REQUEST=None):
    'Revert to factory defaults'
    if self.edited_source:
        self.edited_source=''
        self._v_cooked=self.cook()
    if REQUEST: return self.editConfirmation(self,REQUEST)
</t>
<t tx="ekr.20040104185913.1710">manage_editForm__roles__=()
def manage_editForm(self, URL1, REQUEST):
    '''Display doc template editing form'''

    return self._manage_editForm(mapping=REQUEST,
                                 document_template_edit_width=
                                 self.document_template_edit_width,
                                 document_template_edit_header=
                                 self.document_template_edit_header,
                                 document_template_form_header=
                                 self.document_template_form_header,
                                 document_template_edit_footer=
                                 self.document_template_edit_footer,
                                 URL1=URL1,
                                 __str__=str(self),
                                 FactoryDefaultString=FactoryDefaultString,
                                 )
</t>
<t tx="ekr.20040104185913.1711">manage_editDocument__roles__=()
manage__roles__=()
manage_editDocument=manage=manage_editForm

manage_edit__roles__=()
def manage_edit(self,data,
                PARENTS=[],URL1='',URL2='',REQUEST='', SUBMIT=''):
    'edit a template'
    if SUBMIT==FactoryDefaultString: return self.manage_default(REQUEST)
    if data.find('\r'):
        data='\n\r'.join(data.split('\r\n'))
        data='\n'.join(data.split('\n\r'))

    if self.edited_source:
        self.edited_source=data
        self._v_cooked=self.cook()
    else:
        __traceback_info__=self.__class__
        newHTML=self.__class__()
        newHTML.__setstate__(self.__getstate__())
        newHTML.edited_source=data
        setattr(PARENTS[1],URL1[URL1.rfind('/')+1:],newHTML)
    if REQUEST: return self.editConfirmation(self,REQUEST)
</t>
<t tx="ekr.20040104185913.1712">&lt;&lt; copyright &gt;&gt;

&lt;&lt; DT_If __doc__ &gt;&gt;

__rcs_id__='$Id: DT_If.py,v 1.19 2002/08/14 22:29:52 mj Exp $'
__version__='$Revision: 1.19 $'[11:-2]

from DT_Util import ParseError, parse_params, name_param, str

@others
</t>
<t tx="ekr.20040104185913.1713">__doc__='''Conditional insertion

       Conditional insertion is performed using 'if' and 'else'
       commands.

       To include text when an object is true using the EPFS
       format, use::

          %(if name)[
               text
          %(if name)]

       To include text when an object is true using the HTML
       format, use::

          &lt;!--#if name--&gt;
               text
          &lt;!--#/if name--&gt;

       where 'name' is the name bound to the object.

       To include text when an object is false using the EPFS
       format, use::

          %(else name)[
               text
          %(else name)]

       To include text when an object is false using the HTML
       format, use::

          &lt;!--#else name--&gt;
               text
          &lt;!--#/else name--&gt;

       Finally to include text when an object is true and to
       include different text when the object is false using the
       EPFS format, use::

          %(if name)[
               true text
          %(if name)]
          %(else name)[
               false text
          %(else name)]

       and to include text when an object is true and to
       include different text when the object is false using the
       HTML format, use::

          &lt;!--#if name--&gt;
               true text
          &lt;!--#else name--&gt;
               false text
          &lt;!--#/if name--&gt;

       Notes:

       - if a variable is nor defined, it is considered to be false.

       - A variable if only evaluated once in an 'if' tag.  If the value
         is used inside the tag, including in enclosed tags, the
         variable is not reevaluated.

'''</t>
<t tx="ekr.20040104185913.1714">class If:
	&lt;&lt; class If declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1715">blockContinuations='else','elif'
name='if'
elses=None
expr=''

</t>
<t tx="ekr.20040104185913.1716">def __init__(self, blocks):

    tname, args, section = blocks[0]
    args=parse_params(args, name='', expr='')
    name,expr=name_param(args,'if',1)
    self.__name__= name
    if expr is None: cond=name
    else: cond=expr.eval
    sections=[cond, section.blocks]

    if blocks[-1][0]=='else':
        tname, args, section = blocks[-1]
        del blocks[-1]
        args=parse_params(args, name='')
        if args:
            ename,expr=name_param(args,'else',1)
            if ename != name:
                raise ParseError, ('name in else does not match if', 'in')
        elses=section.blocks
    else: elses=None

    for tname, args, section in blocks[1:]:
        if tname=='else':
            raise ParseError, (
                'more than one else tag for a single if tag', 'in')
        args=parse_params(args, name='', expr='')
        name,expr=name_param(args,'elif',1)
        if expr is None: cond=name
        else: cond=expr.eval
        sections.append(cond)
        sections.append(section.blocks)

    if elses is not None: sections.append(elses)

    self.simple_form=('i',)+tuple(sections)
</t>
<t tx="ekr.20040104185913.1717">class Unless:
	&lt;&lt; class Unless declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1718">name='unless'
blockContinuations=()

</t>
<t tx="ekr.20040104185913.1719">def __init__(self, blocks):
    tname, args, section = blocks[0]
    args=parse_params(args, name='', expr='')
    name,expr=name_param(args,'unless',1)
    if expr is None: cond=name
    else: cond=expr.eval
    self.simple_form=('i',cond,None,section.blocks)
</t>
<t tx="ekr.20040104185913.1720">class Else(Unless):
	&lt;&lt; class Else declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1721"># The else tag is included for backward compatibility and is deprecated.
name='else'
</t>
<t tx="ekr.20040104185913.1722">&lt;&lt; copyright &gt;&gt;

&lt;&lt; DT_In __doc__ &gt;&gt;

#'

__rcs_id__='$Id: DT_In.py,v 1.60 2002/08/14 22:29:52 mj Exp $'
__version__='$Revision: 1.60 $'[11:-2]

import sys
from DT_Util import ParseError, parse_params, name_param, str, join_unicode
from DT_Util import render_blocks, InstanceDict, ValidationError, Eval
from DT_Util import simple_name, add_with_prefix
import re
from DT_InSV import sequence_variables, opt

TupleType=type(())
StringTypes = (type(''), type(u''))

@others</t>
<t tx="ekr.20040104185913.1723">'''Sequence insertion

       A sequence may be inserted using an 'in' command.  The 'in'
       command specifies the name of a sequence object and text to
       be inserted for each element in the sequence.

       The EPFS syntax for the in command is::

          %(in name)[
               text
          %(in name)]

       The HTML syntax for the in command is::

          &lt;!--#in name--&gt;
               text
          &lt;!--#/in name--&gt;

      See the example below that shows how 'if', 'else', and 'in' commands
      may be combined to display a possibly empty list of objects.

      The text included within an 'in' command will be refered to
      as an 'in' block.

    Synopsis

      If the variable 'sequence' exists as a sequence, a simple case
      of the 'in' tag is used as follows::

         &lt;!--#in sequence--&gt;some markup&lt;!--#/in--&gt;

      A more complete case is used as follows::

        &lt;!--#in sequence sort=age--&gt;
          &lt;!--#var sequence-number--&gt;) &lt;!--#var age--&gt;
        &lt;!--#/in--&gt;

    Attributes

      sort -- Define the sort order for sequence items.  Parameter to the
      attribute is either a sort option, or list of sort options separated
      by comma.  Every sort option consists of variable name, optional
      comparison function name (default is cmp) and optional sort order
      (default is asc).
          Examples: sort="date" or sort="date,time" or
      sort="title/locale,date/cmp/desc". If you want to specify sort order,
      you cannot omit the function; use cmp for standard comparison.
          Few predefined comparison functions available: standard cmp,
      nocase (ignore string case), strcoll (alias "locale"),
      strcoll_nocase (alias "locale_nocase"). Locale functions are
      available only if module locale is already imported (you started Zope
      with -L locale).

      sort_expr -- The "sort" attribute accepts only static list of
      sort options. This calculated parameter allows you to calculate the
      list of sort options on the fly.

      sort_expr -- This allows an expression to control sort order.

      reverse -- Reverse the sequence (may be combined with sort).  Note
      that this can cause a huge memory use in lazy activation instances.

      reverse_expr -- This calculated parameter allows you to calculate the
      need of reversing on the fly.

      Within an 'in' block, variables are substituted from the
      elements of the iteration unless the 'no_push_item' optional
      is specified.  The elements may be either instance or mapping
      objects.  In addition, the variables:

         'sequence-item' -- The element.

         'sequence-var-nnn' -- The value of a specific named attribute
           of the item, where 'nnn' is the name.  For example, to get
           an items 'title' attribute, use 'sequence-var-title'.  This
           construct is most useful in an 'if' tag to test whether an
           attribute is present, because the attribute lookup will be
           extended to the full document template namespace.

         'sequence-key' -- The key associated with the element in an
           items list. See below.

         'sequence-index' -- The index, starting from 0, of the
           element within the sequence.

         'sequence-number' -- The index, starting from 1, of the
           element within the sequence.

         'sequence-letter' -- The index, starting from 'a', of the
           element within the sequence.

         'sequence-Letter' -- The index, starting from 'A', of the
           element within the sequence.

         'sequence-roman' -- The index, starting from 'i', of the
           element within the sequence.

         'sequence-Roman' -- The index, starting from 'I', of the
           element within the sequence.

         'sequence-start' -- A variable that is true if the element
           being displayed is the first of the displayed elements,
           and false otherwise.

         'sequence-end' -- A variable that is true if the element
           being displayed is the last of the displayed elements,
           and false otherwise.

      are defined for each element.

      Normally, 'in' blocks are used to iterate over sequences of
      instances.  If the optional parameter 'mapping' is specified
      after the sequence name, then the elements of the sequence
      will be treated as mapping objects.

      An 'in' command may be used to iterate over a sequence of
      dictionary items.  If the elements of the iteration are
      two-element tuples, then then the template code given in the
      'in' block will be applied to the second element of each
      tuple and may use a variable, 'sequence-key' to access the
      first element in each tuple.

    Batch sequence insertion

      When displaying a large number of objects, it is sometimes
      desirable to display just a sub-sequence of the data.
      An 'in' command may have optional parameters,
      as in::

          &lt;!--#in values start=start_var size=7--&gt;

      The parameter values may be either integer literals or
      variable names.

      Up to five parameters may be set:

          'start'   -- The number of the first element to be shown,
                       where elements are numbered from 1.

          'end'     -- The number of the last element to be shown,
                       where elements are numbered from 1.

          'size'    -- The desired number of elements to be shown at
                       once.

          'orphan'  -- The desired minimum number of objects to be
                       displayed.  The default value for this
                       parameter is 0.

          'overlap' -- The desired overlap between batches. The
                       default is no overlap.

      Typically, only 'start' and 'size' will be specified.

      When batch insertion is used, several additional variables are
      defined for use within the sequence insertion text:

          'sequence-query' -- The original query string given in a get
             request with the form variable named in the 'start'
             attribute removed.  This is extremely useful when
             building URLs to fetch another batch.

             To see how this is used, consider the following example::

                 &lt;!--#in search_results size=20 start=batch_start--&gt;

                    ... display rows

                    &lt;!--#if sequence-end--&gt; &lt;!--#if next-sequence--&gt;
                      &lt;a href="&lt;!--#var URL--&gt;/&lt;!--#var sequence-query
                          --&gt;&amp;batch_start=&lt;!--#var
                          next-sequence-start-number--&gt;"&gt;
                      (Next &lt;!--#var next-sequence-size--&gt; results)
                      &lt;/a&gt;
                    &lt;!--#/if--&gt; &lt;!--#/if--&gt;

                 &lt;!--#/in--&gt;

             If the original URL is: 'foo/bar?x=1&amp;y=2', then the
             rendered text (after row data are displayed) will be::

                      &lt;a href="foo/bar?x=1&amp;y=2&amp;batch_start=20"&gt;
                      (Next 20 results)
                      &lt;/a&gt;

             If the original URL is: 'foo/bar?batch_start=10&amp;x=1&amp;y=2',
             then the rendered text (after row data are displayed)
             will be::

                      &lt;a href="foo/bar?x=1&amp;y=2&amp;batch_start=30"&gt;
                      (Next 20 results)
                      &lt;/a&gt;

          'sequence-step-start-index' -- The index, starting from 0,
             of the start of the current batch.

          'sequence-step-end-index' -- The index, starting from 0, of
             the end of the current batch.

          'sequence-step-size' -- The batch size used.

          'previous-sequence' -- This variable will be true when the
             first element is displayed and when the first element
             displayed is not the first element in the sequence.

          'previous-sequence-start-index' -- The index, starting from
             0, of the start of the batch previous to the current
             batch.

          'previous-sequence-end-index' -- The index, starting from
             0, of the end of the batch previous to the current
             batch.

          'previous-sequence-size' -- The size of the batch previous to
             the current batch.

          'previous-batches' -- A sequence of mapping objects
             containing information about all of the batches prior
             to the batch being displayed.

             Each of these mapping objects include the following
             variables:

                batch-start-index -- The index, starting from
                   0, of the beginning of the batch.

                batch-end-index -- The index, starting from
                   0, of the end of the batch.

                batch-size -- The size of the batch.

          'next-sequence' -- This variable will be true when the last
             element is displayed and when the last element
             displayed is not the last element in the sequence.

          'next-sequence-start-index' -- The index, starting from
             0, of the start of the batch after the current
             batch.

          'next-sequence-end-index' -- The index, starting from
             0, of the end of the batch after the current
             batch.

          'next-sequence-size' -- The size of the batch after
             the current batch.

          'next-batches' -- A sequence of mapping objects
             containing information about all of the batches after
             the batch being displayed.

             Each of these mapping objects include the following
             variables:

                batch-start-index -- The index, starting from
                   0, of the beginning of the batch.

                batch-end-index -- The index, starting from
                   0, of the end of the batch.

                batch-size -- The size of the batch.

      For each of the variables listed above with names ending in
      "-index", there are variables with names ending in "-number",
      "-roman", "-Roman", "-letter", and "-Letter" that are indexed
      from 1, "i", "I", "a", and "A", respectively.  In addition,
      for every one of these variables there are variables with
      names ending in "-var-xxx", where "xxx" is an element
      attribute name or key.

    Summary statistics

      When performing sequence insertion, special variables may be
      used to obtain summary statistics.  To obtain a summary
      statistic for a variable, use the variable name:
      'statistic-name', where 'statistic' is a statistic name and
      'name' is the name of a data variable.

      Currently supported statistic names are:

        total -- The total of numeric values.

        count -- The total number of non-missing values.

        min -- The minimum of non-missing values.

        max -- The maximum of non-missing values.

        median -- The median of non-missing values.

        mean -- The mean of numeric values values.

        variance -- The variance of numeric values computed with a
          degrees of freedom equal to the count - 1.

        variance-n -- The variance of numeric values computed with a
          degrees of freedom equal to the count.

        standard-deviation -- The standard deviation of numeric values
          computed with a degrees of freedom equal to the count - 1.

        standard-deviation-n -- The standard deviation of numeric
          values computed with a degrees of freedom equal to the count.

      Missing values are either 'None' or the attribute 'Value'
      of the module 'Missing', if present.

    'else' continuation tag within in

      An 'else' tag may be used as a continuation tag in the 'in' tag.
      The source after the 'else' tag is inserted if:

        - The sequence given to the 'in' tag is of zero length, or

        - The 'previous' attribute was used and their are no
          previous batches, or

        - The 'next' attribute was used and their are no
          next batches, or

'''</t>
<t tx="ekr.20040104185913.1724">class InFactory:
	&lt;&lt; class InFactory declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1725">blockContinuations=('else',)
name='in'

</t>
<t tx="ekr.20040104185913.1726">def __call__(self, blocks):
    i=InClass(blocks)
    if i.batch: return i.renderwb
    else: return i.renderwob
</t>
<t tx="ekr.20040104185913.1727">In=InFactory()

class InClass:
	&lt;&lt; class InClass declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1728">elses=None
expr=sort=batch=mapping=no_push_item=None
start_name_re=None
reverse=None
sort_expr=reverse_expr=None

</t>
<t tx="ekr.20040104185913.1729">def __init__(self, blocks):
    tname, args, section = blocks[0]
    args=parse_params(args, name='', start='1',end='-1',size='10',
                      orphan='0',overlap='1',mapping=1,
                      no_push_item=1,
                      skip_unauthorized=1,
                      previous=1, next=1, expr='', sort='',
                      reverse=1, sort_expr='', reverse_expr='',
                      prefix='')
    self.args=args
    has_key=args.has_key

    if has_key('sort'):
        self.sort=sort=args['sort']
        if sort=='sequence-item': self.sort=''

    if has_key('sort_expr'):
        self.sort_expr=Eval(args['sort_expr'])

    if has_key('reverse_expr'):
        self.reverse_expr=Eval(args['reverse_expr'])

    if has_key('reverse'):
        self.reverse=args['reverse']

    if has_key('no_push_item'):
        self.no_push_item=args['no_push_item']

    if has_key('mapping'): self.mapping=args['mapping']
    for n in 'start', 'size', 'end':
        if has_key(n): self.batch=1

    prefix = args.get('prefix')
    if prefix and not simple_name(prefix):
        raise ParseError, _tm(
            'prefix is not a simple name', 'in')

    for n in 'orphan','overlap','previous','next':
        if has_key(n) and not self.batch:
            raise ParseError, (
                """
                The %s attribute was used but neither of the
                &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, or &lt;code&gt;size&lt;/code&gt;
                attributes were used.
                """ % n, 'in')

    if has_key('start'):
        v=args['start']
        if type(v)==type(''):
            try: int(v)
            except:

                self.start_name_re=re.compile(
                    '&amp;+'+
                    ''.join(["[%s]" % c for c in v])+
                    '=[0-9]+&amp;+')

    name,expr=name_param(args,'in',1)
    if expr is not None: expr=expr.eval
    self.__name__, self.expr = name, expr
    self.section=section.blocks
    if len(blocks) &gt; 1:
        if len(blocks) != 2: raise ParseError, (
            'too many else blocks', 'in')
        tname, args, section = blocks[1]
        args=parse_params(args, name='')
        if args:
            ename=name_param(args)
            if ename != name:
                raise ParseError, (
                    'name in else does not match in', 'in')
        self.elses=section.blocks
</t>
<t tx="ekr.20040104185913.1730">def renderwb(self, md):
    expr=self.expr
    name=self.__name__
    if expr is None:
        sequence=md[name]
        cache={ name: sequence }
    else:
        sequence=expr(md)
        cache=None

    if not sequence:
        if self.elses: return render_blocks(self.elses, md)
        return ''

    if type(sequence) is type(''):
        raise 'InError', (
            'Strings are not allowed as input to the in tag.')


    section=self.section
    params=self.args

    mapping=self.mapping
    no_push_item=self.no_push_item

    if self.sort_expr is not None:
        self.sort=self.sort_expr.eval(md)
        sequence=self.sort_sequence(sequence, md)
    elif self.sort is not None:
        sequence=self.sort_sequence(sequence, md)

    if self.reverse_expr is not None and self.reverse_expr.eval(md):
        sequence=self.reverse_sequence(sequence)
    elif self.reverse is not None:
        sequence=self.reverse_sequence(sequence)

    next=previous=0
    try: start=int_param(params,md,'start',0)
    except: start=1
    end=int_param(params,md,'end',0)
    size=int_param(params,md,'size',0)
    overlap=int_param(params,md,'overlap',0)
    orphan=int_param(params,md,'orphan','0')
    start,end,sz=opt(start,end,size,orphan,sequence)
    if params.has_key('next'): next=1
    if params.has_key('previous'): previous=1

    last=end-1
    first=start-1

    try: query_string=md['QUERY_STRING']
    except: query_string=''
    prefix = params.get('prefix')
    vars = sequence_variables(sequence, '?'+query_string,
                              self.start_name_re, prefix)
    kw=vars.data
    pkw = add_with_prefix(kw, 'sequence', prefix)
    for k, v in kw.items():
        pkw[k] = v
    pkw['sequence-step-size']=sz
    pkw['sequence-step-overlap']=overlap
    pkw['sequence-step-start']=start
    pkw['sequence-step-end']=end
    pkw['sequence-step-start-index']=start-1
    pkw['sequence-step-end-index']=end-1
    pkw['sequence-step-orphan']=orphan

    kw['mapping']=mapping

    push=md._push
    pop=md._pop
    render=render_blocks

    if cache: push(cache)
    push(vars)
    try:
        if previous:
            if first &gt; 0:
                pstart,pend,psize=opt(0,first+overlap,
                                      sz,orphan,sequence)
                pkw['previous-sequence']=1
                pkw['previous-sequence-start-index']=pstart-1
                pkw['previous-sequence-end-index']=pend-1
                pkw['previous-sequence-size']=pend+1-pstart
                result=render(section,md)

            elif self.elses: result=render(self.elses, md)
            else: result=''
        elif next:
            try:
                # The following line is a sneaky way to test whether
                # there are more items, without actually
                # computing a length:
                sequence[end]
            except IndexError:
                if self.elses: result=render(self.elses, md)
                else: result=''
            else:
                pstart,pend,psize=opt(end+1-overlap,0,
                                      sz,orphan,sequence)
                pkw['next-sequence']=1
                pkw['next-sequence-start-index']=pstart-1
                pkw['next-sequence-end-index']=pend-1
                pkw['next-sequence-size']=pend+1-pstart
                result=render(section,md)
        else:
            result = []
            append=result.append
            guarded_getitem = getattr(md, 'guarded_getitem', None)
            for index in range(first,end):
                # preset
                pkw['previous-sequence']= 0
                pkw['next-sequence']= 0 # now more often defined then previously
                #
                if index==first or index==last:
                    # provide batching information
                    if first &gt; 0:
                        pstart,pend,psize=opt(0,first+overlap,
                                              sz,orphan,sequence)
                        if index==first: pkw['previous-sequence']=1
                        pkw['previous-sequence-start-index']=pstart-1
                        pkw['previous-sequence-end-index']=pend-1
                        pkw['previous-sequence-size']=pend+1-pstart
                    try:
                        # The following line is a sneaky way to
                        # test whether there are more items,
                        # without actually computing a length:
                        sequence[end]
                        pstart,pend,psize=opt(end+1-overlap,0,
                                              sz,orphan,sequence)
                        if index==last: pkw['next-sequence']=1
                        pkw['next-sequence-start-index']=pstart-1
                        pkw['next-sequence-end-index']=pend-1
                        pkw['next-sequence-size']=pend+1-pstart
                    except: pass

                if index==last: pkw['sequence-end']=1

                if guarded_getitem is not None:
                    try: client = guarded_getitem(sequence, index)
                    except ValidationError, vv:
                        if (params.has_key('skip_unauthorized') and
                            params['skip_unauthorized']):
                            if index==first: pkw['sequence-start']=0
                            continue
                        raise ValidationError, '(item %s): %s' % (
                            index, vv), sys.exc_info()[2]
                else:
                    client = sequence[index]

                pkw['sequence-index']=index
                t = type(client)
                if t is TupleType and len(client)==2:
                    client=client[1]

                if no_push_item:
                    pushed = 0
                elif mapping:
                    pushed = 1
                    push(client)
                elif t in StringTypes:
                    pushed = 0
                else:
                    pushed = 1
                    push(InstanceDict(client, md))

                try: append(render(section, md))
                finally:
                    if pushed:
                        pop()

                if index==first: pkw['sequence-start']=0


            result = join_unicode(result)

    finally:
        if cache: pop()
        pop()

    return result
</t>
<t tx="ekr.20040104185913.1731">def renderwob(self, md):
    """RENDER WithOutBatch"""
    expr=self.expr
    name=self.__name__
    if expr is None:
        sequence=md[name]
        cache={ name: sequence }
    else:
        sequence=expr(md)
        cache=None

    if not sequence:
        if self.elses: return render_blocks(self.elses, md)
        return ''

    if type(sequence) is type(''):
        raise 'InError', (
            'Strings are not allowed as input to the in tag.')

    section=self.section
    mapping=self.mapping
    no_push_item=self.no_push_item

    if self.sort_expr is not None:
        self.sort=self.sort_expr.eval(md)
        sequence=self.sort_sequence(sequence, md)
    elif self.sort is not None:
        sequence=self.sort_sequence(sequence, md)

    if self.reverse_expr is not None and self.reverse_expr.eval(md):
        sequence=self.reverse_sequence(sequence)
    elif self.reverse is not None:
        sequence=self.reverse_sequence(sequence)

    prefix = self.args.get('prefix')
    vars=sequence_variables(sequence, alt_prefix=prefix)
    kw=vars.data
    pkw = add_with_prefix(kw, 'sequence', prefix)
    for k, v in kw.items():
        pkw[k] = v
    kw['mapping']=mapping

    l=len(sequence)
    last=l-1

    push=md._push
    pop=md._pop
    render=render_blocks

    if cache: push(cache)
    push(vars)
    try:
        result = []
        append=result.append
        guarded_getitem = getattr(md, 'guarded_getitem', None)
        for index in range(l):
            if index==last: pkw['sequence-end']=1
            if guarded_getitem is not None:
                try: client = guarded_getitem(sequence, index)
                except ValidationError, vv:
                    if (self.args.has_key('skip_unauthorized') and
                        self.args['skip_unauthorized']):
                        if index==1: pkw['sequence-start']=0
                        continue
                    raise ValidationError, '(item %s): %s' % (
                        index, vv), sys.exc_info()[2]
            else:
                client = sequence[index]

            pkw['sequence-index']=index
            t = type(client)
            if t is TupleType and len(client)==2:
                client=client[1]

            if no_push_item:
                pushed = 0
            elif mapping:
                pushed = 1
                push(client)
            elif t in StringTypes:
                pushed = 0
            else:
                pushed = 1
                push(InstanceDict(client, md))

            try: append(render(section, md))
            finally:
                if pushed:
                    pop()
            if index==0: pkw['sequence-start']=0

        result = join_unicode(result)

    finally:
        if cache: pop()
        pop()

    return result
</t>
<t tx="ekr.20040104185913.1732">def sort_sequence(self, sequence, md):

    # Modified with multiple sort fields by Ross Lazarus
    # April 7 2000 rossl@med.usyd.edu.au
    # eg &lt;dtml-in "foo" sort="akey,anotherkey"&gt;

    # Modified with advanced sort functions by
    # Oleg Broytmann &lt;phd@phd.pp.ru&gt; 30 Mar 2001
    # eg &lt;dtml-in "foo" sort="akey/nocase,anotherkey/cmp/desc"&gt;

    sort=self.sort
    need_sortfunc = sort.find('/') &gt;= 0

    sortfields = sort.split(',')   # multi sort = key1,key2
    multsort = len(sortfields) &gt; 1 # flag: is multiple sort

    if need_sortfunc:
        # prepare the list of functions and sort order multipliers
        sf_list = make_sortfunctions(sortfields, md)

        # clean the mess a bit
        if multsort: # More than one sort key.
            sortfields = map(lambda x: x[0], sf_list)
        else:
            sort = sf_list[0][0]

    mapping=self.mapping
    isort=not sort

    s=[]
    for client in sequence:
        k = None
        if type(client)==TupleType and len(client)==2:
            if isort: k=client[0]
            v=client[1]
        else:
            if isort: k=client
            v=client

        if sort:
            if multsort: # More than one sort key.
                k = []
                for sk in sortfields:
                    try:
                        if mapping: akey = v[sk]
                        else: akey = getattr(v, sk)
                    except AttributeError, KeyError: akey = None
                    if not basic_type(akey):
                        try: akey = akey()
                        except: pass
                    k.append(akey)
            else: # One sort key.
                try:
                    if mapping: k = v[sort]
                    else: k = getattr(v, sort)
                except AttributeError, KeyError: k = None
                if not basic_type(type(k)):
                    try: k = k()
                    except: pass

        s.append((k,client))

    if need_sortfunc:
        by = SortBy(multsort, sf_list)
        s.sort(by)
    else:
        s.sort()

    sequence=[]
    for k, client in s:
        sequence.append(client)
    return sequence
</t>
<t tx="ekr.20040104185913.1733">def reverse_sequence(self, sequence):
    s=list(sequence)
    s.reverse()
    return s
</t>
<t tx="ekr.20040104185913.1734">basic_type={type(''): 1, type(0): 1, type(0.0): 1, type(()): 1, type([]): 1,
            type(None) : 1 }.has_key

def int_param(params,md,name,default=0, st=type('')):
    try: v=params[name]
    except: v=default
    if v:
        try: v=int(v)
        except:
            v=md[v]
            if type(v) is st: v=int(v)
    return v
</t>
<t tx="ekr.20040104185913.1735"># phd: Advanced sort support

def nocase(str1, str2):
    return cmp(str1.lower(), str2.lower())
</t>
<t tx="ekr.20040104185913.1736">if sys.modules.has_key("locale"): # only if locale is already imported
    from locale import strcoll

    def strcoll_nocase(str1, str2):
        return strcoll(str1.lower(), str2.lower())
</t>
<t tx="ekr.20040104185913.1737">def make_sortfunctions(sortfields, md):
    """Accepts a list of sort fields; splits every field, finds comparison
    function. Returns a list of 3-tuples (field, cmp_function, asc_multplier)"""

    sf_list = []
    for field in sortfields:
        f = field.split('/')
        l = len(f)

        if l == 1:
            f.append("cmp")
            f.append("asc")
        elif l == 2:
            f.append("asc")
        elif l == 3:
            pass
        else:
            raise SyntaxError, "sort option must contain no more than 2 slashes"

        f_name = f[1]

        # predefined function?
        if f_name == "cmp":
            func = cmp # builtin
        elif f_name == "nocase":
            func = nocase
        elif f_name in ("locale", "strcoll"):
            func = strcoll
        elif f_name in ("locale_nocase", "strcoll_nocase"):
            func = strcoll_nocase
        else: # no - look it up in the namespace
            func = md.getitem(f_name, 0)

        sort_order = f[2].lower()

        if sort_order == "asc":
            multiplier = +1
        elif sort_order == "desc":
            multiplier = -1
        else:
            raise SyntaxError, "sort oder must be either ASC or DESC"

        sf_list.append((f[0], func, multiplier))

    return sf_list
</t>
<t tx="ekr.20040104185913.1738">class SortBy:
	@others
</t>
<t tx="ekr.20040104185913.1739">def __init__(self, multsort, sf_list):
    self.multsort = multsort
    self.sf_list = sf_list
</t>
<t tx="ekr.20040104185913.1740">def __call__(self, o1, o2):
    multsort = self.multsort
    if multsort:
        o1 = o1[0] # if multsort - take the first element (key list)
        o2 = o2[0]

    sf_list = self.sf_list
    l = len(sf_list)

    # assert that o1 and o2 are tuples of apropriate length
    assert len(o1) == l + 1 - multsort, "%s, %d" % (o1, l + multsort)
    assert len(o2) == l + 1 - multsort, "%s, %d" % (o2, l + multsort)

    # now run through the list of functions in sf_list and
    # compare every object in o1 and o2
    for i in range(l):
        # if multsort - we already extracted the key list
        # if not multsort - i is 0, and the 0th element is the key
        c1, c2 = o1[i], o2[i]
        func, multiplier = sf_list[i][1:3]
        n = func(c1, c2)
        if n: return n*multiplier

    # all functions returned 0 - identical sequences
    return 0
</t>
<t tx="ekr.20040104185913.1741">&lt;&lt; copyright &gt;&gt;

__doc__='''Sequence variables support

$Id: DT_InSV.py,v 1.22 2002/08/14 22:29:52 mj Exp $'''
__version__='$Revision: 1.22 $'[11:-2]

&lt;&lt; DT_InSV imports &gt;&gt;

@others</t>
<t tx="ekr.20040104185913.1742">from math import sqrt
import re
TupleType=type(())
try:
    import Missing
    mv=Missing.Value
except: mv=None


</t>
<t tx="ekr.20040104185913.1743">class sequence_variables:
	alt_prefix = None
	@others
</t>
<t tx="ekr.20040104185913.1745">def __init__(self,items=None,query_string='',start_name_re=None,
             alt_prefix=''):

    self.items=items
    self.query_string=query_string
    self.start_name_re=start_name_re
    if alt_prefix:
        self.alt_prefix = alt_prefix + '_'

    self.data=data={
        'previous-sequence': 0,
        'next-sequence': 0,
        'sequence-start': 1,
        'sequence-end': 0,
        }
</t>
<t tx="ekr.20040104185913.1746">def __len__(self): return 1
</t>
<t tx="ekr.20040104185913.1747">def number(self,index): return index+1
</t>
<t tx="ekr.20040104185913.1748">def even(self,index): return index%2 == 0
</t>
<t tx="ekr.20040104185913.1749">def odd(self,index): return index%2
</t>
<t tx="ekr.20040104185913.1750">def letter(self,index): return chr(ord('a')+index)
</t>
<t tx="ekr.20040104185913.1751">def Letter(self,index): return chr(ord('A')+index)
</t>
<t tx="ekr.20040104185913.1752">def key(self,index):    return self.items[index][0]
</t>
<t tx="ekr.20040104185913.1753">def item(self,index, tt=type(())):
    i=self.items[index]
    if type(i) is tt and len(i)==2: return i[1]
    return i
</t>
<t tx="ekr.20040104185913.1754">def roman(self,index): return self.Roman(index).lower()
</t>
<t tx="ekr.20040104185913.1755">def Roman(self,num):
    # Force number to be an integer value
    num = int(num)+1

    # Initialize roman as an empty string
    roman = ''

    while num &gt;= 1000:
        num = num - 1000
        roman = '%sM' % roman

    while num &gt;= 500:
        num = num - 500
        roman = '%sD' % roman

    while num &gt;= 100:
        num = num - 100
        roman = '%sC' % roman

    while num &gt;= 50:
        num = num - 50
        roman = '%sL' % roman

    while num &gt;= 10:
        num = num - 10
        roman = '%sX' % roman

    while num &gt;= 5:
        num = num - 5
        roman = '%sV' % roman

    while num &lt; 5 and num &gt;= 1:
        num = num - 1
        roman = '%sI' % roman

    # Replaces special cases in Roman Numerals

    roman = roman.replace('DCCCC', 'CM')
    roman = roman.replace('CCCC', 'CD')
    roman = roman.replace('LXXXX', 'XC')
    roman = roman.replace('XXXX', 'XL')
    roman = roman.replace('VIIII', 'IX')
    roman = roman.replace('IIII', 'IV')

    return roman
</t>
<t tx="ekr.20040104185913.1756">def value(self,index,name):
    data=self.data
    item=self.items[index]
    if type(item)==TupleType and len(item)==2:
        item=item[1]
    if data['mapping']: return item[name]
    return getattr(item,name)
</t>
<t tx="ekr.20040104185913.1757">def first(self,name,key=''):
    data=self.data
    if data['sequence-start']: return 1
    index=data['sequence-index']
    return self.value(index,name) != self.value(index-1,name)
</t>
<t tx="ekr.20040104185913.1758">def last(self,name,key=''):
    data=self.data
    if data['sequence-end']: return 1
    index=data['sequence-index']
    return self.value(index,name) != self.value(index+1,name)
</t>
<t tx="ekr.20040104185913.1759">def length(self, ignored):
    l=self['sequence-length']=len(self.items)
    return l
</t>
<t tx="ekr.20040104185913.1760">def query(self, *ignored):

    if self.start_name_re is None: raise KeyError, 'sequence-query'
    query_string=self.query_string
    while query_string and query_string[:1] in '?&amp;':
        query_string=query_string[1:]
    while query_string[-1:] == '&amp;':
        query_string=query_string[:-1]
    if query_string:
        query_string='&amp;%s&amp;' % query_string
        reg=self.start_name_re

        if type(reg)==type(re.compile(r"")):
            mo = reg.search(query_string)
            if mo is not None:
                v = mo.group(0)
                l = mo.start(0)
                query_string=(query_string[:l]+ query_string[l+len(v)-1:])

        else:
            l=reg.search_group(query_string, (0,))
            if l:
                v=l[1]
                l=l[0]
                query_string=(query_string[:l]+ query_string[l+len(v)-1:])

        query_string='?'+query_string[1:]
    else: query_string='?'
    self['sequence-query']=query_string

    return query_string
</t>
<t tx="ekr.20040104185913.1761">statistic_names=(
    'total', 'count', 'min', 'max', 'median', 'mean',
    'variance', 'variance-n','standard-deviation', 'standard-deviation-n',
    )

def statistics(self,name,key):
    items=self.items
    data=self.data
    mapping=data['mapping']
    count=sum=sumsq=0
    min=max=None
    scount=smin=smax=None
    values=[]
    svalues=[]
    for item in items:
        try:
            if mapping: item=item[name]
            else:
                try: item=getattr(item,name)
                except:
                    if name != 'item':
                        raise
            try:
                if item is mv:
                    item = None
                if type(item)==type(1):
                    s=item*long(item)
                else:
                    s=item*item
                sum=sum+item
                sumsq=sumsq+s
                values.append(item)
                if min is None:
                    min=max=item
                else:
                    if item &lt; min: min=item
                    if item &gt; max: max=item
            except:
                if item is not None and item is not mv:
                    if smin is None: smin=smax=item
                    else:
                        if item &lt; smin: smin=item
                        if item &gt; smax: smax=item
                    svalues.append(item)
        except: pass

    # Initialize all stats to empty strings:
    for stat in self.statistic_names: data['%s-%s' % (stat,name)]=''

    count=len(values)
    try: # Numeric statistics
        n=float(count)
        mean=sum/n
        sumsq=sumsq/n - mean*mean
        data['mean-%s' % name]=mean
        data['total-%s' % name]=sum
        data['variance-n-%s' % name]=sumsq
        data['standard-deviation-n-%s' % name]=sqrt(sumsq)
        if count &gt; 1:
            sumsq=sumsq*n/(n-1)
            data['variance-%s' % name]=sumsq
            data['standard-deviation-%s' % name]=sqrt(sumsq)
        else:
            data['variance-%s' % name]=''
            data['standard-deviation-%s' % name]=''
    except:
        if min is None: min,max,values=smin,smax,svalues
        else:
            if smin &lt; min: min=smin
            if smax &gt; max: max=smax
            values=values+svalues
        count=len(values)

    data['count-%s' % name]=count
    # data['_values']=values
    if min is not None:
        data['min-%s' % name]=min
        data['max-%s' % name]=max
        values.sort()
        if count==1:
            data['median-%s' % name]=min
        else:
            n=count+1
            if n/2*2==n: data['median-%s' % name]=values[n/2-1]
            else:
                n=n/2
                try: data['median-%s' % name]=(values[n]+values[n-1])/2
                except:
                    try: data['median-%s' % name]=(
                        "between %s and %s" % (values[n],values[n-1]))
                    except: pass

    return data[key]
</t>
<t tx="ekr.20040104185913.1762">def next_batches(self, suffix='batches',key=''):
    if suffix != 'batches': raise KeyError, key
    data=self.data
    sequence=self.items
    try:
        if not data['next-sequence']: return ()
        sz=data['sequence-step-size']
        start=data['sequence-step-start']
        end=data['sequence-step-end']
        l=len(sequence)
        orphan=data['sequence-step-orphan']
        overlap=data['sequence-step-overlap']
    except: AttributeError, 'next-batches'
    r=[]
    while end &lt; l:
        start,end,spam=opt(end+1-overlap,0,sz,orphan,sequence)
        v=sequence_variables(self.items,
                             self.query_string,self.start_name_re)
        d=v.data
        d['batch-start-index']=start-1
        d['batch-end-index']=end-1
        d['batch-size']=end+1-start
        d['mapping']=data['mapping']
        r.append(v)
    data['next-batches']=r
    return r
</t>
<t tx="ekr.20040104185913.1763">def previous_batches(self, suffix='batches',key=''):
    if suffix != 'batches': raise KeyError, key
    data=self.data
    sequence=self.items
    try:
        if not data['previous-sequence']: return ()
        sz=data['sequence-step-size']
        start=data['sequence-step-start']
        end=data['sequence-step-end']
        l=len(sequence)
        orphan=data['sequence-step-orphan']
        overlap=data['sequence-step-overlap']
    except: AttributeError, 'previous-batches'
    r=[]
    while start &gt; 1:
        start,end,spam=opt(0,start-1+overlap,sz,orphan,sequence)
        v=sequence_variables(self.items,
                             self.query_string,self.start_name_re)
        d=v.data
        d['batch-start-index']=start-1
        d['batch-end-index']=end-1
        d['batch-size']=end+1-start
        d['mapping']=data['mapping']
        r.append(v)
    r.reverse()
    data['previous-batches']=r
    return r
</t>
<t tx="ekr.20040104185913.1764">special_prefixes={
    'first': first,
    'last': last,
    'previous': previous_batches,
    'next': next_batches,
    # These two are for backward compatability with a missfeature:
    'sequence-index': lambda self, suffix, key: self['sequence-'+suffix],
    'sequence-index-is': lambda self, suffix, key: self['sequence-'+suffix],
    }
for n in statistic_names: special_prefixes[n]=statistics

def __setitem__(self, key, value):
    self.data[key] = value
    if self.alt_prefix:
        if key.startswith('sequence-'): key = key[9:]
        self.data[self.alt_prefix + key] = value
</t>
<t tx="ekr.20040104185913.1765">def __getitem__(self,key,
                special_prefixes=special_prefixes,
                special_prefix=special_prefixes.has_key
                ):
    data=self.data
    if data.has_key(key): return data[key]

    l=key.rfind('-')
    if l &lt; 0:
        alt_prefix = self.alt_prefix
        if not (alt_prefix and key.startswith(alt_prefix)):
            raise KeyError, key

        suffix = key[len(alt_prefix):].replace('_', '-')
        if '-' in suffix:
            try: return self[suffix]
            except KeyError: pass
        prefix = 'sequence'
        key = 'sequence-' + suffix
    else:
        suffix=key[l+1:]
        prefix=key[:l]

    if hasattr(self, suffix):
        try: v=data[prefix+'-index']
        except: pass
        else: return getattr(self,suffix)(v)

    if special_prefix(prefix):
        return special_prefixes[prefix](self, suffix, key)

    if prefix[-4:]=='-var':
        prefix=prefix[:-4]
        try: return self.value(data[prefix+'-index'],suffix)
        except: pass

    if key=='sequence-query': return self.query()

    raise KeyError, key
</t>
<t tx="ekr.20040104185913.1766">def opt(start,end,size,orphan,sequence):
    if size &lt; 1:
        if start &gt; 0 and end &gt; 0 and end &gt;= start:
            size=end+1-start
        else: size=7

    if start &gt; 0:

        try: sequence[start-1]
        except: start=len(sequence)
        # if start &gt; l: start=l

        if end &gt; 0:
            if end &lt; start: end=start
        else:
            end=start+size-1
            try: sequence[end+orphan-1]
            except: end=len(sequence)
            # if l - end &lt; orphan: end=l
    elif end &gt; 0:
        try: sequence[end-1]
        except: end=len(sequence)
        # if end &gt; l: end=l
        start=end+1-size
        if start - 1 &lt; orphan: start=1
    else:
        start=1
        end=start+size-1
        try: sequence[end+orphan-1]
        except: end=len(sequence)
        # if l - end &lt; orphan: end=l
    return start,end,size
</t>
<t tx="ekr.20040104185913.1767">&lt;&lt; DT_Let declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1768">&lt;&lt; copyright &gt;&gt;

''' The Let tag was contributed to Zope by and is copyright, 1999
    Phillip J. Eby.  Permission has been granted to release the Let tag
    under the Zope Public License.


   Let name=value...

   The 'let' tag is used to bind variables to values within a block.

   The text enclosed in the let tag is rendered using information
   from the given variables or expressions.

   For example::

     &lt;!--#let foofunc="foo()" my_bar=bar--&gt;
       foo() = &lt;!--#var foofunc--&gt;,
       bar = &lt;!--#var my_bar--&gt;
     &lt;!--#/let--&gt;

   Notice that both 'name' and 'expr' style attributes may be used to
   specify data.  'name' style attributes (e.g. my_bar=bar) will be
   rendered as they are for var/with/in/etc.  Quoted attributes will
   be treated as Python expressions.

   Variables are processed in sequence, so later assignments can
   reference and/or overwrite the results of previous assignments,
   as desired.
'''

from DT_Util import render_blocks, Eval, ParseError
from DT_Util import str # Probably needed due to hysterical pickles.
import re


</t>
<t tx="ekr.20040104185913.1769">class Let:
	&lt;&lt; class Let declarations &gt;&gt;
	@others

    __call__ = render</t>
<t tx="ekr.20040104185913.1770">blockContinuations=()
name='let'

</t>
<t tx="ekr.20040104185913.1771">def __init__(self, blocks):
    tname, args, section = blocks[0]
    self.__name__ = args
    self.section = section.blocks
    self.args = args = parse_let_params(args)

    for i in range(len(args)):
        name,expr = args[i]
        if expr[:1]=='"' and expr[-1:]=='"' and len(expr) &gt; 1:
                            # expr shorthand
            expr=expr[1:-1]
            try: args[i] = name, Eval(expr).eval
            except SyntaxError, v:
                m,(huh,l,c,src) = v
                raise ParseError, (
                    '&lt;strong&gt;Expression (Python) Syntax error&lt;/strong&gt;:'
                    '\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n' % v[0],
                    'let')
</t>
<t tx="ekr.20040104185913.1772">def render(self, md):
    d={}; md._push(d)
    try:
        for name,expr in self.args:
            if type(expr) is type(''): d[name]=md[expr]
            else: d[name]=expr(md)
        return render_blocks(self.section, md)
    finally: md._pop(1)
</t>
<t tx="ekr.20040104185913.1773">def parse_let_params(text,
            result=None,
            tag='let',
            parmre=re.compile('([\000- ]*([^\000- ="]+)=([^\000- ="]+))'),
            qparmre=re.compile('([\000- ]*([^\000- ="]+)="([^"]*)")'),
            **parms):

    result=result or []

    mo = parmre.match(text)
    mo1= qparmre.match(text)

    if mo is not None:
        name=mo.group(2)
        value=mo.group(3)
        l=len(mo.group(1))
    elif mo1 is not None:
        name=mo1.group(2)
        value='"%s"' % mo1.group(3)
        l=len(mo1.group(1))
    else:
        if not text or not text.strip(): return result
        raise ParseError, ('invalid parameter: "%s"' % text, tag)

    result.append((name,value))

    text=text[l:].strip()
    if text: return apply(parse_let_params,(text,result,tag),parms)
    else: return result
</t>
<t tx="ekr.20040104185913.1774">&lt;&lt; DT_Raise declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1775">&lt;&lt; copyright &gt;&gt;

'''Raising exceptions

   Errors can be raised from DTML using the 'raise' tag.

   For example::

    &lt;!--#if expr="condition_that_tests_input"--&gt;
       &lt;!--#raise type="Input Error"--&gt;
           The value you entered is not valid
       &lt;!--#/raise--&gt;
    &lt;!--#/if--&gt;

'''
__rcs_id__='$Id: DT_Raise.py,v 1.13 2002/08/14 22:29:52 mj Exp $'
__version__='$Revision: 1.13 $'[11:-2]

from DT_Util import parse_params, name_param, render_blocks, str

</t>
<t tx="ekr.20040104185913.1776">class Raise:
	&lt;&lt; class Raise declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.1777">blockContinuations=()
name='raise'
expr=''

</t>
<t tx="ekr.20040104185913.1778">def __init__(self, blocks):

    tname, args, section = blocks[0]
    self.section=section.blocks
    args=parse_params(args, type='', expr='')
    self.__name__, self.expr = name_param(args, 'raise', 1, attr='type')
</t>
<t tx="ekr.20040104185913.1779">def render(self,md):
    expr=self.expr
    if expr is None:
        t=self.__name__
        if t[-5:]=='Error' and __builtins__.has_key(t):
            t=__builtins__[t]
    else:
        try: t=expr.eval(md)
        except: t='Invalid Error Type Expression'

    try: v=render_blocks(self.section,md)
    except: v='Invalid Error Value'

    raise t, v
</t>
<t tx="ekr.20040104185913.1780">&lt;&lt; DT_Return declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1781">&lt;&lt; copyright &gt;&gt;

__version__='$Revision: 1.7 $'[11:-2]

from DT_Util import parse_params, name_param, str
import  sys

</t>
<t tx="ekr.20040104185913.1782">class ReturnTag:
	&lt;&lt; class ReturnTag declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.1783">name='return'
expr=None

</t>
<t tx="ekr.20040104185913.1784">def __init__(self, args):
    args = parse_params(args, name='', expr='')
    name, expr = name_param(args,'var',1)
    self.__name__, self.expr = name, expr
</t>
<t tx="ekr.20040104185913.1785">def render(self, md):
    name=self.__name__
    val=self.expr
    if val is None:
        val = md[name]
    else:
        val=val.eval(md)

    raise DTReturn(val)
</t>
<t tx="ekr.20040104185913.1786">class DTReturn:
	@others
</t>
<t tx="ekr.20040104185913.1787">def __init__(self, v):
    self.v=v
</t>
<t tx="ekr.20040104185913.1788">&lt;&lt; DT_String declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1789">&lt;&lt; copyright &gt;&gt;

"$Id: DT_String.py,v 1.51 2002/08/14 22:29:52 mj Exp $"

import thread,re,exceptions,os

from DT_Util import ParseError, InstanceDict, TemplateDict, render_blocks, str
from DT_Var import Var, Call, Comment
from DT_Return import ReturnTag, DTReturn

_marker = []  # Create a new marker object.

</t>
<t tx="ekr.20040104185913.1790">class String:
    """Document templates defined from strings.

    Document template strings use an extended form of python string
    formatting.  To insert a named value, simply include text of the
    form: '%(name)x', where 'name' is the name of the value and 'x' is
    a format specification, such as '12.2d'.

    To intrduce a block such as an 'if' or an 'in' or a block continuation,
    such as an 'else', use '[' as the format specification.  To
    terminate a block, ise ']' as the format specification, as in::

      %(in results)[
        %(name)s
      %(in results)]

    """
	&lt;&lt; class String declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1791">isDocTemp=1

# Document Templates masquerade as functions:
</t>
<t tx="ekr.20040104185913.1792">class func_code: pass
	&lt;&lt; class func_code declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1793">func_code=func_code()
</t>
<t tx="ekr.20040104185913.1794">func_code.co_varnames='self','REQUEST'
func_code.co_argcount=2
func_code.__roles__=()

func_defaults__roles__=()
func_defaults=()

errQuote__roles__=()
def errQuote(self, s): return s
</t>
<t tx="ekr.20040104185913.1795">parse_error__roles__=()
def parse_error(self, mess, tag, text, start):
    raise ParseError, "%s, for tag %s, on line %s of %s&lt;p&gt;" % (
        mess, self.errQuote(tag), len(text[:start].split('\n')),
        self.errQuote(self.__name__))
</t>
<t tx="ekr.20040104185913.1796">commands__roles__=()
commands={
    'var': Var,
    'call': Call,
    'in': ('in', 'DT_In','In'),
    'with': ('with', 'DT_With','With'),
    'if': ('if', 'DT_If','If'),
    'unless': ('unless', 'DT_If','Unless'),
    'else': ('else', 'DT_If','Else'),
    'comment': Comment,
    'raise': ('raise', 'DT_Raise','Raise'),
    'try': ('try', 'DT_Try','Try'),
    'let': ('let', 'DT_Let', 'Let'),
    'return': ReturnTag,
    }

SubTemplate__roles__=()
def SubTemplate(self, name):
    return String('', __name__=name)
</t>
<t tx="ekr.20040104185913.1797">tagre__roles__=()
def tagre(self):
    return re.compile(
        '%\\('                                  # beginning
        '(?P&lt;name&gt;[a-zA-Z0-9_/.-]+)'              # tag name
        '('
        '[\000- ]+'                             # space after tag name
        '(?P&lt;args&gt;([^\\)"]+("[^"]*")?)*)'         # arguments
        ')?'
        '\\)(?P&lt;fmt&gt;[0-9]*[.]?[0-9]*[a-z]|[]![])' # end
        , re.I)
</t>
<t tx="ekr.20040104185913.1798">_parseTag__roles__=()
def _parseTag(self, match_ob, command=None, sargs='', tt=type(())):
    tag, args, command, coname = self.parseTag(match_ob,command,sargs)
    if type(command) is tt:
        cname, module, name = command
        d={}
        try:
            exec 'from %s import %s' % (module, name) in d
        except ImportError:
            exec 'from DocumentTemplate.%s import %s' % (module, name) in d
        command=d[name]
        self.commands[cname]=command
    return tag, args, command, coname
</t>
<t tx="ekr.20040104185913.1799">parseTag__roles__=()
def parseTag(self, match_ob, command=None, sargs=''):
    """Parse a tag using an already matched re

    Return: tag, args, command, coname

    where: tag is the tag,
           args is the tag\'s argument string,
           command is a corresponding command info structure if the
              tag is a start tag, or None otherwise, and
           coname is the name of a continue tag (e.g. else)
             or None otherwise
    """
    tag, name, args, fmt = match_ob.group(0, 'name', 'args', 'fmt')
    args=args and args.strip() or ''

    if fmt==']':
        if not command or name != command.name:
            raise ParseError, ('unexpected end tag', tag)
        return tag, args, None, None
    elif fmt=='[' or fmt=='!':
        if command and name in command.blockContinuations:

            if name=='else' and args:
                # Waaaaaah! Have to special case else because of
                # old else start tag usage. Waaaaaaah!
                l=len(args)
                if not (args==sargs or
                        args==sargs[:l] and sargs[l:l+1] in ' \t\n'):
                    return tag, args, self.commands[name], None

            return tag, args, None, name

        try: return tag, args, self.commands[name], None
        except KeyError:
            raise ParseError, ('Unexpected tag', tag)
    else:
        # Var command
        args=args and ("%s %s" % (name, args)) or name
        return tag, args, Var, None
</t>
<t tx="ekr.20040104185913.1800">varExtra__roles__=()
def varExtra(self, match_ob):
    return match_ob.group('fmt')
</t>
<t tx="ekr.20040104185913.1801">parse__roles__=()
def parse(self,text,start=0,result=None,tagre=None):
    if result is None: result=[]
    if tagre is None: tagre=self.tagre()
    mo = tagre.search(text,start)
    while mo :
        l = mo.start(0)

        try: tag, args, command, coname = self._parseTag(mo)
        except ParseError, m: self.parse_error(m[0],m[1],text,l)

        s=text[start:l]
        if s: result.append(s)
        start=l+len(tag)

        if hasattr(command,'blockContinuations'):
            start=self.parse_block(text, start, result, tagre,
                                   tag, l, args, command)
        else:
            try:
                if command is Var: r=command(args, self.varExtra(mo))
                else: r=command(args)
                if hasattr(r,'simple_form'): r=r.simple_form
                result.append(r)
            except ParseError, m: self.parse_error(m[0],tag,text,l)

        mo = tagre.search(text,start)

    text=text[start:]
    if text: result.append(text)
    return result
</t>
<t tx="ekr.20040104185913.1802">skip_eol__roles__=()
def skip_eol(self, text, start, eol=re.compile('[ \t]*\n')):
    # if block open is followed by newline, then skip past newline
    mo =eol.match(text,start)
    if mo is not None:
        start = start + mo.end(0) - mo.start(0)

    return start
</t>
<t tx="ekr.20040104185913.1803">parse_block__roles__=()
def parse_block(self, text, start, result, tagre,
                stag, sloc, sargs, scommand):

    start=self.skip_eol(text,start)

    blocks=[]
    tname=scommand.name
    sname=stag
    sstart=start
    sa=sargs
    while 1:

        mo = tagre.search(text,start)
        if mo is None: self.parse_error('No closing tag', stag, text, sloc)
        l = mo.start(0)

        try: tag, args, command, coname= self._parseTag(mo,scommand,sa)
        except ParseError, m: self.parse_error(m[0],m[1], text, l)

        if command:
            start=l+len(tag)
            if hasattr(command, 'blockContinuations'):
                # New open tag.  Need to find closing tag.
                start=self.parse_close(text, start, tagre, tag, l,
                                       command, args)
        else:
            # Either a continuation tag or an end tag
            section=self.SubTemplate(sname)
            section._v_blocks=section.blocks=self.parse(text[:l],sstart)
            section._v_cooked=None
            blocks.append((tname,sargs,section))

            start=self.skip_eol(text,l+len(tag))

            if coname:
                tname=coname
                sname=tag
                sargs=args
                sstart=start
            else:
                try:
                    r=scommand(blocks)
                    if hasattr(r,'simple_form'): r=r.simple_form
                    result.append(r)
                except ParseError, m: self.parse_error(m[0],stag,text,l)

                return start
</t>
<t tx="ekr.20040104185913.1804">parse_close__roles__=()
def parse_close(self, text, start, tagre, stag, sloc, scommand, sa):
    while 1:
        mo = tagre.search(text,start)
        if mo is None: self.parse_error('No closing tag', stag, text, sloc)
        l = mo.start(0)

        try: tag, args, command, coname= self._parseTag(mo,scommand,sa)
        except ParseError, m: self.parse_error(m[0],m[1], text, l)

        start=l+len(tag)
        if command:
            if hasattr(command, 'blockContinuations'):
                # New open tag.  Need to find closing tag.
                start=self.parse_close(text, start, tagre, tag, l,
                                       command,args)
        elif not coname: return start
</t>
<t tx="ekr.20040104185913.1805">shared_globals__roles__=()
shared_globals={}

def __init__(self, source_string='', mapping=None, __name__='&lt;string&gt;',
             **vars):
    """\
    Create a document template from a string.

    The optional parameter, 'mapping', may be used to provide a
    mapping object containing defaults for values to be inserted.
    """
    self.raw=source_string
    self.initvars(mapping, vars)
    self.setName(__name__)
</t>
<t tx="ekr.20040104185913.1806">def name(self): return self.__name__
</t>
<t tx="ekr.20040104185913.1807">id=name

setName__roles__=()
def setName(self,v): self.__dict__['__name__']=v
</t>
<t tx="ekr.20040104185913.1808">default__roles__=()
def default(self,name=None,**kw):
    """\
    Change or query default values in a document template.

    If a name is specified, the value of the named default value
    before the operation is returned.

    Keyword arguments are used to provide default values.
    """
    if name: name=self.globals[name]
    for key in kw.keys(): self.globals[key]=kw[key]
    return name
</t>
<t tx="ekr.20040104185913.1809">var__roles__=()
def var(self,name=None,**kw):
    """\
    Change or query a variable in a document template.

    If a name is specified, the value of the named variable before
    the operation is returned.

    Keyword arguments are used to provide variable values.
    """
    if name: name=self._vars[name]
    for key in kw.keys(): self._vars[key]=kw[key]
    return name
</t>
<t tx="ekr.20040104185913.1810">munge__roles__=()
def munge(self,source_string=None,mapping=None,**vars):
    """\
    Change the text or default values for a document template.
    """
    if mapping is not None or vars:
        self.initvars(mapping, vars)
    if source_string is not None:
        self.raw=source_string
    self.cook()
</t>
<t tx="ekr.20040104185913.1811">manage_edit__roles__=()
def manage_edit(self,data,REQUEST=None):
    self.munge(data)
</t>
<t tx="ekr.20040104185913.1812">read_raw__roles__=()
def read_raw(self,raw=None):
    return self.raw
</t>
<t tx="ekr.20040104185913.1813">read__roles__=()
def read(self,raw=None):
    return self.read_raw()
</t>
<t tx="ekr.20040104185913.1814">cook__roles__=()
def cook(self,
         cooklock=thread.allocate_lock(),
         ):
    cooklock.acquire()
    try:
        self._v_blocks=self.parse(self.read())
        self._v_cooked=None
    finally:
        cooklock.release()
</t>
<t tx="ekr.20040104185913.1815">initvars__roles__=()
def initvars(self, globals, vars):
    if globals:
        for k in globals.keys():
            if k[:1] != '_' and not vars.has_key(k): vars[k]=globals[k]
    self.globals=vars
    self._vars={}
</t>
<t tx="ekr.20040104185913.1816">ZDocumentTemplate_beforeRender__roles__ = ()
def ZDocumentTemplate_beforeRender(self, md, default):
    return default
</t>
<t tx="ekr.20040104185913.1817">ZDocumentTemplate_afterRender__roles__ = ()
def ZDocumentTemplate_afterRender(self, md, result):
    pass
</t>
<t tx="ekr.20040104185913.1818">def __call__(self,client=None,mapping={},**kw):
    '''\
    Generate a document from a document template.

    The document will be generated by inserting values into the
    format string specified when the document template was
    created.  Values are inserted using standard python named
    string formats.

    The optional argument 'client' is used to specify a object
    containing values to be looked up.  Values will be looked up
    using getattr, so inheritence of values is supported.  Note
    that names beginning with '_' will not be looked up from the
    client.

    The optional argument, 'mapping' is used to specify a mapping
    object containing values to be inserted.

    Values to be inserted may also be specified using keyword
    arguments.

    Values will be inserted from one of several sources.  The
    sources, in the order in which they are consulted, are:

      o  Keyword arguments,

      o  The 'client' argument,

      o  The 'mapping' argument,

      o  The keyword arguments provided when the object was
         created, and

      o  The 'mapping' argument provided when the template was
         created.

    '''
    # print '============================================================'
    # print '__called__'
    # print self.raw
    # print kw
    # print client
    # print mapping
    # print '============================================================'

    if mapping is None: mapping = {}
    if hasattr(mapping, 'taintWrapper'): mapping = mapping.taintWrapper()

    if not hasattr(self,'_v_cooked'):
        try: changed=self.__changed__()
        except: changed=1
        self.cook()
        if not changed: self.__changed__(0)

    pushed=None
    try:
        # Support Python 1.5.2, but work better in 2.1
        if (mapping.__class__ is TemplateDict or
            isinstance(mapping, TemplateDict)): pushed=0
    except: pass

    globals=self.globals
    if pushed is not None:
        # We were passed a TemplateDict, so we must be a sub-template
        md=mapping
        push=md._push
        if globals:
            push(self.globals)
            pushed=pushed+1
    else:
        md=TemplateDict()
        push=md._push
        shared_globals=self.shared_globals
        if shared_globals: push(shared_globals)
        if globals: push(globals)
        if mapping:
            push(mapping)
        md.guarded_getattr=self.guarded_getattr
        md.guarded_getitem=self.guarded_getitem
        if client is not None:
            if type(client)==type(()):
                md.this=client[-1]
            else: md.this=client
        pushed=0

    level=md.level
    if level &gt; 200: raise SystemError, (
        'infinite recursion in document template')
    md.level=level+1

    if client is not None:
        if type(client)==type(()):
            # if client is a tuple, it represents a "path" of clients
            # which should be pushed onto the md in order.
            for ob in client:
                push(InstanceDict(ob, md)) # Circ. Ref. 8-|
                pushed=pushed+1
        else:
            # otherwise its just a normal client object.
            push(InstanceDict(client, md)) # Circ. Ref. 8-|
            pushed=pushed+1

    if self._vars:
        push(self._vars)
        pushed=pushed+1

    if kw:
        push(kw)
        pushed=pushed+1

    try:
        value = self.ZDocumentTemplate_beforeRender(md, _marker)
        if value is _marker:
            try: result = render_blocks(self._v_blocks, md)
            except DTReturn, v: result = v.v
            self.ZDocumentTemplate_afterRender(md, result)
            return result
        else:
            return value
    finally:
        if pushed: md._pop(pushed) # Get rid of circular reference!
        md.level=level # Restore previous level
</t>
<t tx="ekr.20040104185913.1819">guarded_getattr=None
guarded_getitem=None

def __str__(self):
    return self.read()
</t>
<t tx="ekr.20040104185913.1820">def __getstate__(self, _special=('_v_', '_p_')):
    # Waaa, we need _v_ behavior but we may not subclass Persistent
    d={}
    for k, v in self.__dict__.items():
        if k[:3] in _special: continue
        d[k]=v
    return d
</t>
<t tx="ekr.20040104185913.1821">class FileMixin:
	&lt;&lt; class FileMixin declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1822"># Mix-in class to abstract certain file-related attributes
edited_source=''

</t>
<t tx="ekr.20040104185913.1823">def __init__(self, file_name='', mapping=None, __name__='', **vars):
    """\
    Create a document template based on a named file.

    The optional parameter, 'mapping', may be used to provide a
    mapping object containing defaults for values to be inserted.
    """
    self.raw=file_name
    self.initvars(mapping, vars)
    self.setName(__name__ or file_name)
</t>
<t tx="ekr.20040104185913.1824">read_raw__roles__=()
def read_raw(self):
    if self.edited_source: return self.edited_source
    if not os.path.exists(self.raw):
        print 'file not found: %s' % self.raw

    if self.raw: return open(self.raw,'r').read()
    return ''
</t>
<t tx="ekr.20040104185913.1825">class File(FileMixin, String):
    """\
    Document templates read from files.

    If the object is pickled, the file name, rather
    than the file contents is pickled.  When the object is
    unpickled, then the file will be re-read to obtain the string.
    Note that the file will not be read until the document
    template is used the first time.
    """
	&lt;&lt; class File declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1826">manage_edit__roles__=()
</t>
<t tx="ekr.20040104185913.1827">def manage_edit(self,data): raise TypeError, 'cannot edit files'
</t>
<t tx="ekr.20040104185913.1828">&lt;&lt; DT_Try declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1829">&lt;&lt; copyright &gt;&gt;

import  sys, traceback
from cStringIO import StringIO
from DT_Util import ParseError, parse_params, render_blocks
from DT_Util import namespace, InstanceDict
from DT_Return import DTReturn

</t>
<t tx="ekr.20040104185913.1830">class Try:
    """Zope DTML Exception handling

    usage:

    &lt;!--#try--&gt;
    &lt;!--#except SomeError AnotherError--&gt;
    &lt;!--#except YetAnotherError--&gt;
    &lt;!--#except--&gt;
    &lt;!--#else--&gt;
    &lt;!--#/try--&gt;

    or:

    &lt;!--#try--&gt;
    &lt;!--#finally--&gt;
    &lt;!--#/try--&gt;

    The DTML try tag functions quite like Python's try command.

    The contents of the try tag are rendered. If an exception is raised,
    then control switches to the except blocks. The first except block to
    match the type of the error raised is rendered. If an except block has
    no name then it matches all raised errors.

    The try tag understands class-based exceptions, as well as string-based
    exceptions. Note: the 'raise' tag raises string-based exceptions.

    Inside the except blocks information about the error is available via
    three variables.

      'error_type' -- This variable is the name of the exception caught.

      'error_value' -- This is the caught exception's value.

      'error_tb' -- This is a traceback for the caught exception.

    The optional else block is rendered when no exception occurs in the
    try block. Exceptions in the else block are not handled by the preceding
    except blocks.

    The try..finally form specifies a `cleanup` block, to be rendered even
    when an exception occurs. Note that any rendered result is discarded if
    an exception occurs in either the try or finally blocks. The finally block
    is only of any use if you need to clean up something that will not be
    cleaned up by the transaction abort code.

    The finally block will always be called, wether there was an exception in
    the try block or not, or wether or not you used a return tag in the try
    block. Note that any output of the finally block is discarded if you use a
    return tag in the try block.

    If an exception occurs in the try block, and an exception occurs in the
    finally block, or you use the return tag in that block, any information
    about that first exception is lost. No information about the first
    exception is available in the finally block. Also, if you use a return tag
    in the try block, and an exception occurs in the finally block or you use
    a return tag there as well, the result returned in the try block will be
    lost.

    Original version by Jordan B. Baker.

    Try..finally and try..else implementation by Martijn Pieters.
    """
	&lt;&lt; class Try declarations &gt;&gt;
	@others

    __call__ = render</t>
<t tx="ekr.20040104185913.1831">name = 'try'
blockContinuations = 'except', 'else', 'finally'
finallyBlock=None
elseBlock=None

</t>
<t tx="ekr.20040104185913.1832">def __init__(self, blocks):
    tname, args, section = blocks[0]

    self.args = parse_params(args)
    self.section = section.blocks


    # Find out if this is a try..finally type
    if len(blocks) == 2 and blocks[1][0] == 'finally':
        self.finallyBlock = blocks[1][2].blocks

    # This is a try [except]* [else] block.
    else:
        # store handlers as tuples (name,block)
        self.handlers = []
        defaultHandlerFound = 0

        for tname,nargs,nsection in blocks[1:]:
            if tname == 'else':
                if not self.elseBlock is None:
                    raise ParseError, (
                        'No more than one else block is allowed',
                        self.name)
                self.elseBlock = nsection.blocks

            elif tname == 'finally':
                raise ParseError, (
                    'A try..finally combination cannot contain '
                    'any other else, except or finally blocks',
                    self.name)

            else:
                if not self.elseBlock is None:
                    raise ParseError, (
                        'The else block should be the last block '
                        'in a try tag', self.name)

                for errname in nargs.split():
                    self.handlers.append((errname,nsection.blocks))
                if nargs.strip()=='':
                    if defaultHandlerFound:
                        raise ParseError, (
                            'Only one default exception handler '
                            'is allowed', self.name)
                    else:
                        defaultHandlerFound = 1
                        self.handlers.append(('',nsection.blocks))
</t>
<t tx="ekr.20040104185913.1833">def render(self, md):
    if (self.finallyBlock is None):
        return self.render_try_except(md)
    else:
        return self.render_try_finally(md)
</t>
<t tx="ekr.20040104185913.1834">def render_try_except(self, md):
    result = ''

    # first we try to render the first block
    try:
        result = render_blocks(self.section, md)
    except DTReturn:
        raise
    except:
        # but an error occurs.. save the info.
        t,v = sys.exc_info()[:2]
        if type(t)==type(''):
            errname = t
        else:
            errname = t.__name__

        handler = self.find_handler(t)

        if handler is None:
            # we didn't find a handler, so reraise the error
            raise

        # found the handler block, now render it
        try:
            f=StringIO()
            traceback.print_exc(100,f)
            error_tb=f.getvalue()
            ns = namespace(md, error_type=errname, error_value=v,
                error_tb=error_tb)[0]
            md._push(InstanceDict(ns,md))
            return render_blocks(handler, md)
        finally:
            md._pop(1)

    else:
        # No errors have occured, render the optional else block
        if (self.elseBlock is None):
            return result
        else:
            return result + render_blocks(self.elseBlock, md)
</t>
<t tx="ekr.20040104185913.1835">def render_try_finally(self, md):
    result = ''
    # first try to render the first block
    try:
        result = render_blocks(self.section, md)
    # Then handle finally block
    finally:
        result = result + render_blocks(self.finallyBlock, md)
    return result
</t>
<t tx="ekr.20040104185913.1836">def find_handler(self,exception):
    "recursively search for a handler for a given exception"
    if type(exception)==type(''):
        for e,h in self.handlers:
            if exception==e or e=='':
                return h
        else:
            return None
    for e,h in self.handlers:
        if e==exception.__name__ or e=='' or self.match_base(exception,e):
            return h
    return None
</t>
<t tx="ekr.20040104185913.1837">def match_base(self,exception,name):
    for base in exception.__bases__:
        if base.__name__==name or self.match_base(base,name):
            return 1
    return None
</t>
<t tx="ekr.20040104185913.1838">&lt;&lt; copyright &gt;&gt;

__doc__='''Machinery to support through-the-web editing

$Id: DT_UI.py,v 1.13 2002/08/26 13:30:18 Brian Exp $'''
__version__='$Revision: 1.13 $'[11:-2]

from DT_HTML import HTML

FactoryDefaultString="Factory Default"

HTML.document_template_edit_header='&lt;h2&gt;Edit Document&lt;/h2&gt;'
HTML.document_template_form_header=''
HTML.document_template_edit_footer=(
    """&lt;FONT SIZE="-1"&gt;
    &lt;I&gt;&lt;A HREF="http://www.zope.com"&gt;
    &amp;copy; 2002 Zope Corporation&lt;/A&gt;&lt;/I&gt;&lt;/FONT&gt;""")

HTML.document_template_edit_width=58

HTML._manage_editForm = HTML(
    """&lt;HTML&gt;
    &lt;HEAD&gt;
    &lt;TITLE&gt;HTML Template Editor&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY bgcolor="#FFFFFF"&gt;
    &lt;!--#var document_template_edit_header--&gt;

    &lt;FORM name="editform" ACTION="&lt;!--#var URL1--&gt;/manage_edit" METHOD="POST"&gt;
    &lt;!--#var document_template_form_header--&gt;
    Document template source:
    &lt;center&gt;
    &lt;br&gt;
    &lt;TEXTAREA NAME="data:text" cols="&lt;!--#var document_template_edit_width--&gt;"
                    rows="20"&gt;&lt;!--#var __str__--&gt;&lt;/TEXTAREA&gt;

    &lt;br&gt;
      &lt;INPUT NAME=SUBMIT TYPE="SUBMIT" VALUE="Change"&gt;
      &lt;INPUT NAME=SUBMIT TYPE="RESET"  VALUE="Reset"&gt;
      &lt;INPUT NAME="dt_edit_name" TYPE="HIDDEN"
             VALUE="&lt;!--#var URL1--&gt;"&gt;
      &lt;!--#if FactoryDefaultString--&gt;
        &lt;INPUT NAME=SUBMIT TYPE="SUBMIT"
         VALUE="&lt;!--#var FactoryDefaultString--&gt;"&gt;
      &lt;!--#/if FactoryDefaultString--&gt;
      &lt;INPUT NAME=SUBMIT TYPE="SUBMIT" VALUE="Cancel"&gt;
      &lt;!--#if HTTP_REFERER--&gt;
         &lt;INPUT NAME="CANCEL_ACTION" TYPE="HIDDEN"
                VALUE="&lt;!--#var HTTP_REFERER--&gt;"&gt;
      &lt;!--#else HTTP_REFERER--&gt;
         &lt;!--#if URL1--&gt;
           &lt;INPUT NAME="CANCEL_ACTION" TYPE="HIDDEN"
                  VALUE="&lt;!--#var URL1--&gt;"&gt;
         &lt;!--#/if URL1--&gt;
      &lt;!--#/if HTTP_REFERER--&gt;
    &lt;/center&gt;
    &lt;/FORM&gt;

    &lt;BR CLEAR="ALL"&gt;
    &lt;!--#var document_template_edit_footer--&gt;

    &lt;/BODY&gt;
    &lt;/HTML&gt;""",)

HTML.editConfirmation=HTML(
    """&lt;html&gt;&lt;head&gt;&lt;title&gt;Change Successful&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
    &lt;!--#if CANCEL_ACTION--&gt;
      &lt;form action="&lt;!--#var CANCEL_ACTION--&gt;" method="POST"&gt;
        &lt;center&gt;
           &lt;em&gt;&lt;!--#var dt_edit_name--&gt;&lt;/em&gt;&lt;br&gt;has been changed.&lt;br&gt;&lt;br&gt;
           &lt;input type=submit name="SUBMIT" value="OK"&gt;
        &lt;/center&gt;
      &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
    &lt;!--#else CANCEL_ACTION--&gt;
      &lt;center&gt;
         &lt;em&gt;&lt;!--#var dt_edit_name--&gt;&lt;/em&gt;&lt;br&gt;has been changed.
      &lt;/center&gt;
    &lt;!--#/if CANCEL_ACTION--&gt;""")
</t>
<t tx="ekr.20040104185913.1839">&lt;&lt; DT_Util declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1840">&lt;&lt; copyright &gt;&gt;

'''$Id: DT_Util.py,v 1.88 2002/08/14 22:29:52 mj Exp $'''
__version__='$Revision: 1.88 $'[11:-2]

import re, os
from html_quote import html_quote, ustr # for import by other modules, dont remove!
from RestrictedPython.Guards import safe_builtins
from RestrictedPython.Utilities import utility_builtins
from RestrictedPython.Eval import RestrictionCapableEval

test = utility_builtins['test'] # for backwards compatibility, dont remove!

LIMITED_BUILTINS = 1

str=__builtins__['str'] # Waaaaa, waaaaaaaa needed for pickling waaaaa

ParseError='Document Template Parse Error'
from zExceptions import Unauthorized as ValidationError

</t>
<t tx="ekr.20040104185913.1841">def int_param(params,md,name,default=0, st=type('')):
    try: v=params[name]
    except: v=default
    if v:
        try: v=int(v)
        except:
            v=md[v]
            if type(v) is st: v=int(v)
    return v or 0
</t>
<t tx="ekr.20040104185913.1842">try:
    import ExtensionClass
    from cDocumentTemplate import InstanceDict, TemplateDict, \
         render_blocks, safe_callable, join_unicode
except: from pDocumentTemplate import InstanceDict, TemplateDict, \
        render_blocks, safe_callable, join_unicode

functype = type(int_param)
class NotBindable:
	&lt;&lt; class NotBindable declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1843">    # Used to prevent TemplateDict from trying to bind to functions.
</t>
<t tx="ekr.20040104185913.1844">def __init__(self, f):
    self.__call__ = f
</t>
<t tx="ekr.20040104185913.1845">d = TemplateDict.__dict__
for name, f in safe_builtins.items() + utility_builtins.items():
    if type(f) is functype:
        d[name] = NotBindable(f)
    else:
        d[name] = f

if LIMITED_BUILTINS:
    # Replace certain builtins with limited versions.
    from RestrictedPython.Limits import limited_builtins
    for name, f in limited_builtins.items():
        if type(f) is functype:
            d[name] = NotBindable(f)
        else:
            d[name] = f

try:
    # Wrap the string module so it can deal with TaintedString strings.
    from ZPublisher.TaintedString import TaintedString
    from types import FunctionType, BuiltinFunctionType, StringType
    import string

    class StringModuleWrapper:
	@others
</t>
<t tx="ekr.20040104185913.1846">def __getattr__(self, key):
    attr = getattr(string, key)
    if (isinstance(attr, FunctionType) or
        isinstance(attr, BuiltinFunctionType)):
        return StringFunctionWrapper(attr)
    else:
        return attr
</t>
<t tx="ekr.20040104185913.1847">class StringFunctionWrapper:
	@others
</t>
<t tx="ekr.20040104185913.1848">def __init__(self, method):
    self._method = method
</t>
<t tx="ekr.20040104185913.1849">def __call__(self, *args, **kw):
    tainted = 0
    args = list(args)
    for i in range(len(args)):
        if isinstance(args[i], TaintedString):
            tainted = 1
            args[i] = str(args[i])
    for k, v in kw.items():
        if isinstance(v, TaintedString):
            tainted = 1
            kw[k] = str(v)
    args = tuple(args)

    retval = self._method(*args, **kw)
    if tainted and isinstance(retval, StringType) and '&lt;' in retval:
        retval = TaintedString(retval)
    return retval
</t>
<t tx="ekr.20040104185913.1850">d['string'] = StringModuleWrapper()

except ImportError:
# Use the string module already defined in RestrictedPython.Utilities
pass

# The functions below are meant to bind to the TemplateDict.

_marker = []  # Create a new marker object.

def careful_getattr(md, inst, name, default=_marker):
</t>
<t tx="ekr.20040104185913.1851">get = md.guarded_getattr
if get is None:
    get = getattr
try:
    return get(inst, name)
except AttributeError:
    if default is _marker:
        raise
    return default

def careful_hasattr(md, inst, name):
</t>
<t tx="ekr.20040104185913.1852">get = md.guarded_getattr
if get is None:
    get = getattr
try:
    get(inst, name)
except (AttributeError, ValidationError, KeyError):
    return 0
else:
    return 1

d['getattr']=careful_getattr
d['hasattr']=careful_hasattr

def namespace(self, **kw):
</t>
<t tx="ekr.20040104185913.1853">"""Create a tuple consisting of a single instance whose attributes are
provided as keyword arguments."""
if not (getattr(self, '__class__', None) == TemplateDict or
        isinstance(self, TemplateDict)):
    raise TypeError,'''A call was made to DT_Util.namespace() with an
    incorrect "self" argument.  It could be caused by a product which
    is not yet compatible with this version of Zope.  The traceback
    information may contain more details.)'''
return apply(self, (), kw)

d['namespace']=namespace

def render(self, v):
</t>
<t tx="ekr.20040104185913.1854">"Render an object in the way done by the 'name' attribute"
if hasattr(v, '__render_with_namespace__'):
    v = v.__render_with_namespace__(self)
else:
    vbase = getattr(v, 'aq_base', v)
    if safe_callable(vbase):
        if getattr(vbase, 'isDocTemp', 0):
            v = v(None, self)
        else:
            v = v()
return v

d['render']=render


class Eval(RestrictionCapableEval):
	@others
</t>
<t tx="ekr.20040104185913.1855">def eval(self, md):
    gattr = getattr(md, 'guarded_getattr', None)
    if gattr is not None:
        gitem = getattr(md, 'guarded_getitem', None)
        self.prepRestrictedCode()
        code = self.rcode
        d = {'_': md, '_vars': md,
             '_getattr_': gattr,
             '_getitem_': gitem,
             '__builtins__': None}
    else:
        self.prepUnrestrictedCode()
        code = self.ucode
        d = {'_': md, '_vars': md}
    d.update(self.globals)
    has_key = d.has_key
    for name in self.used:
        __traceback_info__ = name
        try:
            if not has_key(name):
                d[name] = md.getitem(name, 0)
        except KeyError:
            # Swallow KeyErrors since the expression
            # might not actually need the name.  If it
            # does need the name, a NameError will occur.
            pass
    return eval(code, d)
</t>
<t tx="ekr.20040104185913.1856">def __call__(self, **kw):
    # Never used?
    md = TemplateDict()
    md._push(kw)
    return self.eval(md)
</t>
<t tx="ekr.20040104185913.1857">simple_name = re.compile('[a-z][a-z0-9_]*', re.I).match

class Add_with_prefix:
	@others
</t>
<t tx="ekr.20040104185913.1858">def __init__(self, map, defprefix, prefix):
    self.map = map
    self.defprefix = defprefix
    self.prefix = prefix
</t>
<t tx="ekr.20040104185913.1859">def __setitem__(self, name, value):
    map = self.map
    map[name] = value
    dp = self.defprefix
    if name.startswith(dp + '-'):
        map[self.prefix + name[len(dp):].replace('-', '_')] = value
    else:
        map['%s_%s' % (self.prefix, name)] = value
</t>
<t tx="ekr.20040104185913.1860">def add_with_prefix(map, defprefix, prefix):
    if not prefix: return map
    return Add_with_prefix(map, defprefix, prefix)
</t>
<t tx="ekr.20040104185913.1861">def name_param(params,tag='',expr=0, attr='name', default_unnamed=1):
    used=params.has_key
    __traceback_info__=params, tag, expr, attr

    #if expr and used('expr') and used('') and not used(params['']):
    #   # Fix up something like: &lt;!--#in expr="whatever" mapping--&gt;
    #   params[params['']]=default_unnamed
    #   del params['']

    if used(''):
        v=params['']

        if v[:1]=='"' and v[-1:]=='"' and len(v) &gt; 1: # expr shorthand
            if used(attr):
                raise ParseError, ('%s and expr given' % attr, tag)
            if expr:
                if used('expr'):
                    raise ParseError, ('two exprs given', tag)
                v=v[1:-1]
                try: expr=Eval(v)
                except SyntaxError, v:
                    raise ParseError, (
                        '&lt;strong&gt;Expression (Python) Syntax error&lt;/strong&gt;:'
                        '\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n' % v[0],
                        tag)
                return v, expr
            else: raise ParseError, (
                'The "..." shorthand for expr was used in a tag '
                'that doesn\'t support expr attributes.',
                tag)

        else: # name shorthand
            if used(attr):
                raise ParseError, ('Two %s values were given' % attr, tag)
            if expr:
                if used('expr'):
                    # raise 'Waaaaaa', 'waaa'
                    raise ParseError, ('%s and expr given' % attr, tag)
                return params[''],None
            return params['']

    elif used(attr):
        if expr:
            if used('expr'):
                raise ParseError, ('%s and expr given' % attr, tag)
            return params[attr],None
        return params[attr]
    elif expr and used('expr'):
        name=params['expr']
        expr=Eval(name)
        return name, expr

    raise ParseError, ('No %s given' % attr, tag)
</t>
<t tx="ekr.20040104185913.1862">Expr_doc="""


Python expression support

  Several document template tags, including 'var', 'in', 'if', 'else',
  and 'elif' provide support for using Python expressions via an
  'expr' tag attribute.

  Expressions may be used where a simple variable value is
  inadequate.  For example, an expression might be used to test
  whether a variable is greater than some amount::

     &lt;!--#if expr="age &gt; 18"--&gt;

  or to transform some basic data::

     &lt;!--#var expr="phone[:3]"--&gt;

  Objects available in the document templates namespace may be used.
  Subobjects of these objects may be used as well, although subobject
  access is restricted by the optional validation method.

  In addition, a special additional name, '_', is available.  The '_'
  variable provides access to the document template namespace as a
  mapping object.  This variable can be useful for accessing objects
  in a document template namespace that have names that are not legal
  Python variable names::

     &lt;!--#var expr="_['sequence-number']*5"--&gt;

  This variable also has attributes that provide access to standard
  utility objects.  These attributes include:

  - The objects: 'None', 'abs', 'chr', 'divmod', 'float', 'hash',
       'hex', 'int', 'len', 'max', 'min', 'oct', 'ord', 'pow',
       'round', and 'str' from the standard Python builtin module.

  - Special security-aware versions of 'getattr' and 'hasattr',

  - The Python 'string', 'math', and 'whrandom' modules, and

  - A special function, 'test', that supports if-then expressions.
    The 'test' function accepts any number of arguments.  If the
    first argument is true, then the second argument is returned,
    otherwise if the third argument is true, then the fourth
    argument is returned, and so on.  If there is an odd number of
    arguments, then the last argument is returned in the case that
    none of the tested arguments is true, otherwise None is
    returned.

  For example, to convert a value to lower case::

    &lt;!--#var expr="_.string.lower(title)"--&gt;

"""

ListType=type([])
def parse_params(text,
                 result=None,
                 tag='',
                 unparmre=re.compile('([\000- ]*([^\000- ="]+))'),
                 qunparmre=re.compile('([\000- ]*("[^"]*"))'),
                 parmre=re.compile('([\000- ]*([^\000- ="]+)=([^\000- ="]+))'),
                 qparmre=re.compile('([\000- ]*([^\000- ="]+)="([^"]*)")'),
                 **parms):

    """Parse tag parameters

    The format of tag parameters consists of 1 or more parameter
    specifications separated by whitespace.  Each specification
    consists of an unnamed and unquoted value, a valueless name, or a
    name-value pair.  A name-value pair consists of a name and a
    quoted or unquoted value separated by an '='.

    The input parameter, text, gives the text to be parsed.  The
    keyword parameters give valid parameter names and default values.

    If a specification is not a name-value pair and it is not the
    first specification and it is a
    valid parameter name, then it is treated as a name-value pair with
    a value as given in the keyword argument.  Otherwise, if it is not
    a name-value pair, it is treated as an unnamed value.

    The data are parsed into a dictionary mapping names to values.
    Unnamed values are mapped from the name '""'.  Only one value may
    be given for a name and there may be only one unnamed value. """

    result=result or {}

    # HACK - we precalculate all matches. Maybe we don't need them
    # all. This should be fixed for performance issues

    mo_p = parmre.match(text)
    mo_q = qparmre.match(text)
    mo_unp = unparmre.match(text)
    mo_unq = qunparmre.match(text)

    if mo_p:
        name=mo_p.group(2).lower()
        value=mo_p.group(3)
        l=len(mo_p.group(1))
    elif mo_q:
        name=mo_q.group(2).lower()
        value=mo_q.group(3)
        l=len(mo_q.group(1))
    elif mo_unp:
        name=mo_unp.group(2)
        l=len(mo_unp.group(1))
        if result:
            if parms.has_key(name):
                if parms[name] is None: raise ParseError, (
                    'Attribute %s requires a value' % name, tag)

                result[name]=parms[name]
            else: raise ParseError, (
                'Invalid attribute name, "%s"' % name, tag)
        else:
            result['']=name
        return apply(parse_params,(text[l:],result),parms)
    elif mo_unq:
        name=mo_unq.group(2)
        l=len(mo_unq.group(1))
        if result: raise ParseError, (
            'Invalid attribute name, "%s"' % name, tag)
        else: result['']=name
        return apply(parse_params,(text[l:],result),parms)
    else:
        if not text or not text.strip(): return result
        raise ParseError, ('invalid parameter: "%s"' % text, tag)

    if not parms.has_key(name):
        raise ParseError, (
            'Invalid attribute name, "%s"' % name, tag)

    if result.has_key(name):
        p=parms[name]
        if type(p) is not ListType or p:
            raise ParseError, (
                'Duplicate values for attribute "%s"' % name, tag)

    result[name]=value

    text=text[l:].strip()
    if text: return apply(parse_params,(text,result),parms)
    else: return result
</t>
<t tx="ekr.20040104185913.1863">&lt;&lt; DT_Var declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1864">&lt;&lt; copyright &gt;&gt;

__doc__='''Variable insertion parameters

    When inserting variables, parameters may be specified to
    control how the data will be formatted.  In HTML source, the
    'fmt' parameter is used to specify a C-style or custom format
    to be used when inserting an object.  In EPFS source, the 'fmt'
    parameter is only used for custom formats, a C-style format is
    specified after the closing parenthesis.

    Custom formats

       A custom format is used when outputing user-defined
       objects.  The value of a custom format is a method name to
       be invoked on the object being inserted.  The method should
       return an object that, when converted to a string, yields
       the desired text.  For example, the DTML code::

          &lt;dtml-var date fmt=DayOfWeek&gt;

       Inserts the result of calling the method 'DayOfWeek' of the
       object bound to the variable 'date', with no arguments.

       In addition to object methods, serveral additional custom
       formats are available:

           'whole-dollars' -- Show a numeric value with a dollar symbol.

           'dollars-and-cents' -- Show a numeric value with a dollar
             symbol and two decimal places.

           'collection-length' -- Get the length of a collection of objects.

       Note that when using the EPFS source format, both a
       C-style and a custom format may be provided.  In this case,
       the C-Style format is applied to the result of calling
       the custom formatting method.

    Null values and missing variables

       In some applications, and especially in database applications,
       data variables may alternate between "good" and "null" or
       "missing" values.  A format that is used for good values may be
       inappropriate for null values.  For this reason, the 'null'
       parameter can be used to specify text to be used for null
       values.  Null values are defined as values that:

         - Cannot be formatted with the specified format, and

         - Are either the special Python value 'None' or
           are false and yield an empty string when converted to
           a string.

       For example, when showing a monitary value retrieved from a
       database that is either a number or a missing value, the
       following variable insertion might be used::

           &lt;dtml-var cost fmt="$%.2d" null=\'n/a\'&gt;

       Missing values are providing for variables which are not
       present in the name space, rather than raising an NameError,
       you could do this:

           &lt;dtml-var cost missing=0&gt;

       and in this case, if cost was missing, it would be set to 0.
       In the case where you want to deal with both at the same time,
       you can use 'default':

           &lt;dtml-var description default=''&gt;

       In this case, it would use '' if the value was null or if the
       variable was missing.

    String manipulation

       A number of special attributes are provided to transform the
       value after formatting has been applied.  These parameters
       are supplied without arguments.

       'lower' --  cause all upper-case letters to be converted to lower case.

       'upper' --  cause all upper-case letters to be converted to lower case.

       'capitalize' -- cause the first character of the inserted value
       to be converted to upper case.

       'spacify' -- cause underscores in the inserted value to be
       converted to spaces.

       'thousands_commas' -- cause commas to be inserted every three
       digits to the left of a decimal point in values containing
       numbers.  For example, the value, "12000 widgets" becomes
       "12,000 widgets".

       'html_quote' -- convert characters that have special meaning
       in HTML to HTML character entities.

       'url_quote' -- convert characters that have special meaning
       in URLS to HTML character entities using decimal values.

       'url_quote_plus' -- like url_quote but also replace blank
       space characters with '+'. This is needed for building
       query strings in some cases.

       'url_unquote' -- convert HTML character entities in strings
       back to their real values.

       'url_unquote_plus' -- like url_unquote, but also
       replace '+' characters with spaces.

       'sql_quote' -- Convert single quotes to pairs of single
       quotes. This is needed to safely include values in
       Standard Query Language (SQL) strings.

       'newline_to_br' -- Convert newlines and carriage-return and
       newline combinations to break tags.

       'url' -- Get the absolute URL of the object by calling it\'s
       'absolute_url' method, if it has one.

    Truncation

       The attributes 'size' and 'etc'  can be used to truncate long
       strings.  If the 'size' attribute is specified, the string to
       be inserted is truncated at the given length.  If a space
       occurs in the second half of the truncated string, then the
       string is further truncated to the right-most space.  After
       truncation, the value given for the 'etc' attribute is added to
       the string.  If the 'etc' attribute is not provided, then '...'
       is used.  For example, if the value of spam is
       '"blah blah blah blah"', then the tag
       '&lt;dtml-var spam size=10&gt;' inserts '"blah blah ..."'.


Evaluating expressions without rendering results

   A 'call' tag is provided for evaluating named objects or expressions
   without rendering the result.


''' # '
__rcs_id__='$Id: DT_Var.py,v 1.57.6.3 2002/09/20 19:52:25 matt Exp $'
__version__='$Revision: 1.57.6.3 $'[11:-2]

from DT_Util import parse_params, name_param, str, ustr
import os, string, re,  sys
from urllib import quote, quote_plus, unquote, unquote_plus
from cgi import escape
from html_quote import html_quote # for import by other modules, dont remove!
from types import StringType
from Acquisition import aq_base
from ZPublisher.TaintedString import TaintedString

</t>
<t tx="ekr.20040104185913.1865">class Var:
	&lt;&lt; class Var declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.1866">name='var'
expr=None

</t>
<t tx="ekr.20040104185913.1867">def __init__(self, args, fmt='s'):
    if args[:4]=='var ': args=args[4:]
    args = parse_params(args, name='', lower=1, upper=1, expr='',
                        capitalize=1, spacify=1, null='', fmt='s',
                        size=0, etc='...', thousands_commas=1,
                        html_quote=1, url_quote=1, sql_quote=1,
                        url_quote_plus=1, url_unquote=1,
                        url_unquote_plus=1,missing='',
                        newline_to_br=1, url=1)
    self.args=args

    self.modifiers=tuple(
        map(lambda t: t[1],
            filter(lambda m, args=args, used=args.has_key:
                   used(m[0]) and args[m[0]],
                   modifiers)))

    name, expr = name_param(args,'var',1)

    self.__name__, self.expr = name, expr
    self.fmt = fmt

    if len(args)==1 and fmt=='s':
        if expr is None: expr=name
        else: expr=expr.eval
        self.simple_form=('v', expr)
    elif len(args)==2  and fmt=='s' and args.has_key('html_quote'):
        if expr is None: expr=name
        else: expr=expr.eval
        self.simple_form=('v', expr, 'h')
</t>
<t tx="ekr.20040104185913.1868">def render(self, md):
    args=self.args
    have_arg=args.has_key
    name=self.__name__

    val=self.expr

    if val is None:
        if md.has_key(name):
            if have_arg('url'):
                val=md.getitem(name,0)
                val=val.absolute_url()
            else:
                val = md[name]
        else:
            if have_arg('missing'):
                return args['missing']
            else:
                raise KeyError, name
    else:
        val=val.eval(md)
        if have_arg('url'): val=val.absolute_url()

    __traceback_info__=name, val, args

    if have_arg('null') and not val and val != 0:
        # check for null (false but not zero, including None, [], '')
        return args['null']


    # handle special formats defined using fmt= first
    if have_arg('fmt'):
        _get = getattr(md, 'guarded_getattr', None)
        if _get is None:
            _get = getattr

        fmt=args['fmt']
        if have_arg('null') and not val and val != 0:
            try:
                if hasattr(val, fmt):
                    val = _get(val, fmt)()
                elif special_formats.has_key(fmt):
                    if fmt == 'html-quote' and \
                       isinstance(val, TaintedString):
                        # TaintedStrings will be quoted by default, don't
                        # double quote.
                        pass
                    else:
                        val = special_formats[fmt](val, name, md)
                elif fmt=='': val=''
                else:
                    if isinstance(val, TaintedString):
                        val = TaintedString(fmt % val)
                    else:
                        val = fmt % val
            except:
                t, v= sys.exc_type, sys.exc_value
                if hasattr(sys, 'exc_info'): t, v = sys.exc_info()[:2]
                if val is None or not str(val): return args['null']
                raise t, v

        else:
            # We duplicate the code here to avoid exception handler
            # which tends to screw up stack or leak
            if hasattr(val, fmt):
                val = _get(val, fmt)()
            elif special_formats.has_key(fmt):
                if fmt == 'html-quote' and \
                    isinstance(val, TaintedString):
                    # TaintedStrings will be quoted by default, don't
                    # double quote.
                    pass
                else:
                    val = special_formats[fmt](val, name, md)
            elif fmt=='': val=''
            else:
                if isinstance(val, TaintedString):
                    val = TaintedString(fmt % val)
                else:
                    val = fmt % val

    # finally, pump it through the actual string format...
    fmt=self.fmt
    if fmt=='s':
        # Keep tainted strings as tainted strings here.
        if not isinstance(val, TaintedString):
            val=ustr(val)
    else:
        # Keep tainted strings as tainted strings here.
        wastainted = 0
        if isinstance(val, TaintedString): wastainted = 1
        val = ('%'+self.fmt) % (val,)
        if wastainted and '&lt;' in val:
            val = TaintedString(val)

    # next, look for upper, lower, etc
    for f in self.modifiers:
        if f.__name__ == 'html_quote' and isinstance(val, TaintedString):
            # TaintedStrings will be quoted by default, don't double quote.
            continue
        val=f(val)

    if have_arg('size'):
        size=args['size']
        try: size=int(size)
        except: raise 'Document Error',(
            '''a &lt;code&gt;size&lt;/code&gt; attribute was used in a &lt;code&gt;var&lt;/code&gt;
            tag with a non-integer value.''')
        if len(val) &gt; size:
            val=val[:size]
            l=val.rfind(' ')
            if l &gt; size/2:
                val=val[:l+1]
            if have_arg('etc'): l=args['etc']
            else: l='...'
            val=val+l

    if isinstance(val, TaintedString):
        val = val.quoted()

    return val
</t>
<t tx="ekr.20040104185913.1869">class Call:
	&lt;&lt; class Call declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1870">name='call'
expr=None

</t>
<t tx="ekr.20040104185913.1871">def __init__(self, args):
    args = parse_params(args, name='', expr='')
    name, expr = name_param(args,'call',1)
    if expr is None: expr=name
    else: expr=expr.eval
    self.simple_form=('i', expr, None)
</t>
<t tx="ekr.20040104185913.1872">def url_quote(v, name='(Unknown name)', md={}):
    return quote(str(v))
</t>
<t tx="ekr.20040104185913.1873">def url_quote_plus(v, name='(Unknown name)', md={}):
    return quote_plus(str(v))
</t>
<t tx="ekr.20040104185913.1874">def url_unquote(v, name='(Unknown name)', md={}):
    return unquote(str(v))
</t>
<t tx="ekr.20040104185913.1875">def url_unquote_plus(v, name='(Unknown name)', md={}):
    return unquote_plus(str(v))
</t>
<t tx="ekr.20040104185913.1876">def newline_to_br(v, name='(Unknown name)', md={}):
    # Unsafe data is explicitly quoted here; we don't expect this to be HTML
    # quoted later on anyway.
    if isinstance(v, TaintedString): v = v.quoted()
    v=ustr(v)
    if v.find('\r') &gt;= 0: v=''.join(v.split('\r'))
    if v.find('\n') &gt;= 0: v='&lt;br /&gt;\n'.join(v.split('\n'))
    return v
</t>
<t tx="ekr.20040104185913.1877">def whole_dollars(v, name='(Unknown name)', md={}):
    try: return "$%d" % v
    except: return ''
</t>
<t tx="ekr.20040104185913.1878">def dollars_and_cents(v, name='(Unknown name)', md={}):
    try: return "$%.2f" % v
    except: return ''
</t>
<t tx="ekr.20040104185913.1879">def thousands_commas(v, name='(Unknown name)', md={},
                     thou=re.compile(
                         r"([0-9])([0-9][0-9][0-9]([,.]|$))").search):
    v=str(v)
    vl=v.split('.')
    if not vl: return v
    v=vl[0]
    del vl[0]
    if vl: s='.'+'.'.join(vl)
    else: s=''
    mo=thou(v)
    while mo is not None:
        l = mo.start(0)
        v=v[:l+1]+','+v[l+1:]
        mo=thou(v)
    return v+s
</t>
<t tx="ekr.20040104185913.1880">def whole_dollars_with_commas(v, name='(Unknown name)', md={}):
    try: v= "$%d" % v
    except: v=''
    return thousands_commas(v)
</t>
<t tx="ekr.20040104185913.1881">def dollars_and_cents_with_commas(v, name='(Unknown name)', md={}):
    try: v= "$%.2f" % v
    except: v= ''
    return thousands_commas(v)
</t>
<t tx="ekr.20040104185913.1882">def len_format(v, name='(Unknown name)', md={}):
    return str(len(v))
</t>
<t tx="ekr.20040104185913.1883">def len_comma(v, name='(Unknown name)', md={}):
    return thousands_commas(str(len(v)))
</t>
<t tx="ekr.20040104185913.1884">StructuredText=None
def structured_text(v, name='(Unknown name)', md={}):
    global StructuredText
    if StructuredText is None:
        from StructuredText.StructuredText import HTML

    if isinstance(v,StringType): txt = v

    elif aq_base(v).meta_type in ['DTML Document','DTML Method']:
        txt = aq_base(v).read_raw()

    else: txt = str(v)

    return HTML(txt,
                level=int(os.environ.get('STX_DEFAULT_LEVEL',3)),
                header=0)
</t>
<t tx="ekr.20040104185913.1885">def sql_quote(v, name='(Unknown name)', md={}):
    """Quote single quotes in a string by doubling them.

    This is needed to securely insert values into sql
    string literals in templates that generate sql.
    """
    if v.find("'") &gt;= 0: return v.replace("'", "''")
    return v
</t>
<t tx="ekr.20040104185913.1886">special_formats={
    'whole-dollars': whole_dollars,
    'dollars-and-cents': dollars_and_cents,
    'collection-length': len_format,
    'structured-text': structured_text,

    # The rest are deprecated:
    'sql-quote': sql_quote,
    'html-quote': html_quote,
    'url-quote': url_quote,
    'url-quote-plus': url_quote_plus,
    'url-unquote': url_unquote,
    'url-unquote-plus': url_unquote_plus,
    'multi-line': newline_to_br,
    'comma-numeric': thousands_commas,
    'dollars-with-commas': whole_dollars_with_commas,
    'dollars-and-cents-with-commas': dollars_and_cents_with_commas,
    }

def spacify(val):
    if val.find('_') &gt;= 0: val=val.replace('_', ' ')
    return val
</t>
<t tx="ekr.20040104185913.1887">modifiers=(html_quote, url_quote, url_quote_plus, url_unquote,
           url_unquote_plus, newline_to_br,
           string.lower, string.upper, string.capitalize, spacify,
           thousands_commas, sql_quote, url_unquote, url_unquote_plus)
modifiers=map(lambda f: (f.__name__, f), modifiers)

class Comment:
    '''Comments

    The 'comment' tag can be used to simply include comments
    in DTML source.

    For example::

      &lt;!--#comment--&gt;

        This text is not rendered.

      &lt;!--#/comment--&gt;
    '''
	&lt;&lt; class Comment declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.1888">name='comment'
blockContinuations=()

</t>
<t tx="ekr.20040104185913.1889">def __init__(self, args, fmt=''): pass
</t>
<t tx="ekr.20040104185913.1890">def render(self, md):
    return ''
</t>
<t tx="ekr.20040104185913.1891">&lt;&lt; DT_With declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1892">&lt;&lt; copyright &gt;&gt;

'''Nested namespace access

   The 'with' tag is used to introduce nested namespaces.

   The text enclosed in the with tag is rendered using information
   from the given variable or expression.

   For example, if the variable 'person' is bound to an object that
   has attributes 'name' and 'age', then a 'with' tag like the
   following can be used to access these attributes::

     &lt;!--#with person--&gt;
       &lt;!--#var name--&gt;,
       &lt;!--#var age--&gt;
     &lt;!--#/with--&gt;

   Eather a 'name' or an 'expr' attribute may be used to specify data.
   A 'mapping' attribute may be used to indicate that the given data
   should be treated as mapping object, rather than as an object with
   named attributes.

'''

__rcs_id__='$Id: DT_With.py,v 1.15 2002/08/14 22:29:52 mj Exp $'
__version__='$Revision: 1.15 $'[11:-2]

from DT_Util import parse_params, name_param, InstanceDict, render_blocks, str
from DT_Util import TemplateDict
</t>
<t tx="ekr.20040104185913.1893">class With:
	&lt;&lt; class With declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.1894">blockContinuations=()
name='with'
mapping=None
only=0

</t>
<t tx="ekr.20040104185913.1895">def __init__(self, blocks):
    tname, args, section = blocks[0]
    args=parse_params(args, name='', expr='', mapping=1, only=1)
    name,expr=name_param(args,'with',1)
    if expr is None: expr=name
    else: expr=expr.eval
    self.__name__, self.expr = name, expr
    self.section=section.blocks
    if args.has_key('mapping') and args['mapping']: self.mapping=1
    if args.has_key('only') and args['only']: self.only=1
</t>
<t tx="ekr.20040104185913.1896">def render(self, md):
    expr=self.expr
    if type(expr) is type(''): v=md[expr]
    else: v=expr(md)

    if not self.mapping:
        if type(v) is type(()) and len(v)==1: v=v[0]
        v=InstanceDict(v,md)

    if self.only:
        _md=md
        md=TemplateDict()
        if hasattr(_md, 'guarded_getattr'):
            md.guarded_getattr = _md.guarded_getattr
        if hasattr(_md, 'guarded_getitem'):
            md.guarded_getitem = _md.guarded_getitem

    md._push(v)
    try: return render_blocks(self.section, md)
    finally: md._pop(1)
</t>
<t tx="ekr.20040104185913.1897">&lt;&lt; DTtestExpr declarations &gt;&gt;
@others


if __name__ == "__main__":
    try: command=sys.argv[1]
    except: command='main'
    globals()[command]()
</t>
<t tx="ekr.20040104185913.1898">&lt;&lt; copyright &gt;&gt;

__doc__='''short description


$Id: DTtestExpr.py,v 1.8 2002/08/14 22:29:52 mj Exp $'''
__version__='$Revision: 1.8 $'[11:-2]

from DocumentTemplate import *
import sys

</t>
<t tx="ekr.20040104185913.1899">def test1():
    print HTML('area code=&lt;!--#var expr="phone[:3]"--&gt;')(phone='7035551212')
</t>
<t tx="ekr.20040104185913.1900">def test2():
    print HTML('area code=&lt;!--#var expr="phone.number"--&gt;')(phone='7035551212')
</t>
<t tx="ekr.20040104185913.1901">def test3():
    print HTML('area code=&lt;!--#var expr="phone*1000"--&gt;')(phone='7035551212')
</t>
<t tx="ekr.20040104185913.1902">def test4():

    h=HTML(
        """
        &lt;!--#if expr="level==1"--&gt;
        level was 1
        &lt;!--#elif expr="level==2"--&gt;
        level was 2
        &lt;!--#elif expr="level==3"--&gt;
        level was 3
        &lt;!--#else--&gt;
        level was something else
        &lt;!--#endif--&gt;
        """)

    for i in range(4):
        print '-' * 77
        print i, h(level=i)
    print '-' * 77
</t>
<t tx="ekr.20040104185913.1903">&lt;&lt; copyright &gt;&gt;

'''Document templates with fill-in fields

Document templates provide for creation of textual documents, such as
HTML pages, from template source by inserting data from python objects
and name-spaces.

When a document template is created, a collection of default values to
be inserted may be specified with a mapping object and with keyword
arguments.

A document templated may be called to create a document with values
inserted.  When called, an instance, a mapping object, and keyword
arguments may be specified to provide values to be inserted.  If an
instance is provided, the document template will try to look up values
in the instance using getattr, so inheritence of values is supported.
If an inserted value is a function, method, or class, then an attempt
will be made to call the object to obtain values.  This allows
instance methods to be included in documents.

Document templates masquerade as functions, so the python object
publisher (Bobo) will call templates that are stored as instances of
published objects. Bobo will pass the object the template was found in
and the HTTP request object.

Two source formats are supported:

   Extended Python format strings (EPFS) --
      This format is based on the insertion by name format strings
      of python with additional format characters, '[' and ']' to
      indicate block boundaries.  In addition, parameters may be
      used within formats to control how insertion is done.

      For example:

         %%(date fmt=DayOfWeek upper)s

      causes the contents of variable 'date' to be inserted using
      custom format 'DayOfWeek' and with all lower case letters
      converted to upper case.

   HTML --
      This format uses HTML server-side-include syntax with
      commands for inserting text. Parameters may be included to
      customize the operation of a command.

      For example:

         &lt;!--#var total fmt=12.2f--&gt;

      is used to insert the variable 'total' with the C format
      '12.2f'.

Document templates support conditional and sequence insertion

    Document templates extend python string substitition rules with a
    mechanism that allows conditional insertion of template text and that
    allows sequences to be inserted with element-wise insertion of
    template text.

Access Control

    Document templates provide a basic level of access control by
    preventing access to names beginning with an underscore.
    Additional control may be provided by providing document templates
    with a 'guarded_getattr' and 'guarded_getitem' method.  This would
    typically be done by subclassing one or more of the DocumentTemplate
    classes.

    If provided, the the 'guarded_getattr' method will be called when
    objects are accessed as instance attributes or when they are
    accessed through keyed access in an expression.

Document Templates may be created 4 ways:

    DocumentTemplate.String -- Creates a document templated from a
        string using an extended form of python string formatting.

    DocumentTemplate.File -- Creates a document templated bound to a
        named file using an extended form of python string formatting.
        If the object is pickled, the file name, rather than the file
        contents is pickled.  When the object is unpickled, then the
        file will be re-read to obtain the string.  Note that the file
        will not be read until the document template is used the first
        time.

    DocumentTemplate.HTML -- Creates a document templated from a
        string using HTML server-side-include rather than
        python-format-string syntax.

    DocumentTemplate.HTMLFile -- Creates an HTML document template
        from a named file.

'''


__version__='$Revision: 1.14 $'[11:-2]

ParseError='Document Template Parse Error'

from DT_String import String, File
from DT_HTML import HTML, HTMLFile, HTMLDefault
# import DT_UI # Install HTML editing
</t>
<t tx="ekr.20040104185913.1904">&lt;&lt; VSEval declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1905"># alias module for backwards compatibility

from DT_Util import Eval

</t>
<t tx="ekr.20040104185913.1906">def careful_mul(env, *factors):
    r = 1
    for factor in factors:
        r=r*factor
    return r
</t>
<t tx="ekr.20040104185913.1907">&lt;&lt; copyright &gt;&gt;

__doc__='''Package wrapper for Document Template

This wrapper allows the (now many) document template modules to be
segregated in a separate package.

$Id: __init__.py,v 1.17 2002/08/14 22:29:53 mj Exp $'''
__version__='$Revision: 1.17 $'[11:-2]

import ExtensionClass # work-around for import bug.
from DocumentTemplate import String, File, HTML, HTMLDefault, HTMLFile
</t>
<t tx="ekr.20040104185913.1908">@language c

&lt;&lt; c copyright &gt;&gt;

static char cDocumentTemplate_module_documentation[] = 
""
"\n$Id: cDocumentTemplate.c,v 1.48 2002/08/05 20:51:14 shane Exp $"
;

&lt;&lt; cDocumentTemplate #includes &gt;&gt;
&lt;&lt; cDocumentTemplate declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.1909">#include "ExtensionClass.h"
</t>
<t tx="ekr.20040104185913.1910">static PyObject *py_isDocTemp=0, *py_blocks=0, *py_=0, *join=0, *py_acquire;
static PyObject *py___call__, *py___roles__, *py_AUTHENTICATED_USER;
static PyObject *py_hasRole, *py__proxy_roles, *py_Unauthorized;
static PyObject *py_Unauthorized_fmt, *py_guarded_getattr;
static PyObject *py__push, *py__pop, *py_aq_base, *py_renderNS;
static PyObject *py___class__, *html_quote, *ustr, *untaint_name;
</t>
<t tx="ekr.20040104185913.1911">@ -----------------------------------------------------
@c

static void PyVar_Assign(PyObject **v, PyObject *e) { Py_XDECREF(*v); *v=e;}
</t>
<t tx="ekr.20040104185913.1912">#define ASSIGN(V,E) PyVar_Assign(&amp;(V),(E))
#define UNLESS(E) if (!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E); UNLESS(V)
#define OBJECT(O)(((PyObject*)O))

typedef struct {
  PyObject_HEAD
  PyObject *inst;
  PyObject *cache;
  PyObject *namespace;
  PyObject *guarded_getattr;
} InstanceDictobject;

staticforward PyExtensionClass InstanceDictType;

staticforward PyObject *_join_unicode(PyObject *prejoin);

static PyObject *
InstanceDict___init__(InstanceDictobject *self, PyObject *args)
{
  self-&gt;guarded_getattr=NULL;
  UNLESS(PyArg_ParseTuple(args, "OO|O",
			  &amp;(self-&gt;inst),
			  &amp;(self-&gt;namespace),
			  &amp;(self-&gt;guarded_getattr)))
    return NULL;
  Py_INCREF(self-&gt;inst);
  Py_INCREF(self-&gt;namespace);
  if (self-&gt;guarded_getattr)
    Py_INCREF(self-&gt;guarded_getattr);
  else
    UNLESS(self-&gt;guarded_getattr=PyObject_GetAttr(self-&gt;namespace,
                                                  py_guarded_getattr))
       return NULL;
    
  UNLESS(self-&gt;cache=PyDict_New()) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.1913">static struct PyMethodDef InstanceDict_methods[] = {
  {"__init__",	(PyCFunction)InstanceDict___init__, 1,
   ""},
  
  {NULL,		NULL}		/* sentinel */
};

/* ---------- */

static void
InstanceDict_dealloc(InstanceDictobject *self)
{
  Py_XDECREF(self-&gt;inst);
  Py_XDECREF(self-&gt;cache);
  Py_XDECREF(self-&gt;namespace);
  Py_XDECREF(self-&gt;guarded_getattr);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185913.1914">static PyObject *
InstanceDict_getattr(InstanceDictobject *self, PyObject *name)
{
  return Py_FindAttr((PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185913.1915">static PyObject *
InstanceDict_repr(InstanceDictobject *self)
{
  return PyObject_Repr(self-&gt;inst);
}
</t>
<t tx="ekr.20040104185913.1916">@ Code to access InstanceDict objects as mappings
@c

static int
InstanceDict_length( InstanceDictobject *self)
{
  return 1;
}
</t>
<t tx="ekr.20040104185913.1917">static PyObject *
InstanceDict_subscript( InstanceDictobject *self, PyObject *key)
{
  PyObject *r, *v;
  char *name;
  
  /* Try to get value from the cache */
  if ((r=PyObject_GetItem(self-&gt;cache, key))) return r;
  PyErr_Clear();
  
  /* Check for __str__ */
  UNLESS(name=PyString_AsString(key)) return NULL;
  if (*name=='_')
    {
      UNLESS(strcmp(name,"__str__")==0) goto KeyError;
      return PyObject_Str(self-&gt;inst);
    }
  
  if (self-&gt;guarded_getattr != Py_None) {
    r = PyObject_CallFunction(self-&gt;guarded_getattr, "OO", self-&gt;inst, key);
  }
  else {
    r = PyObject_GetAttr(self-&gt;inst, key);
  }

  if (!r) {
    PyObject *tb;

    PyErr_Fetch(&amp;r, &amp;v, &amp;tb);
    if (r != PyExc_AttributeError) /* || PyObject_Compare(v,key)) */
      {
	PyErr_Restore(r,v,tb);
	return NULL;
      }
    Py_XDECREF(r);
    Py_XDECREF(v);
    Py_XDECREF(tb);

    goto KeyError;
  }
  
  if (r &amp;&amp; PyObject_SetItem(self-&gt;cache, key, r) &lt; 0) PyErr_Clear();
  
  return r;
  
KeyError:
  PyErr_SetObject(PyExc_KeyError, key);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1918">static int
InstanceDict_ass_sub( InstanceDictobject *self, PyObject *v, PyObject *w)
{
  PyErr_SetString(PyExc_TypeError,
		  "InstanceDict objects do not support item assignment");
  return -1;
}
</t>
<t tx="ekr.20040104185913.1919">static PyMappingMethods InstanceDict_as_mapping = {
  (inquiry)InstanceDict_length,		/*mp_length*/
  (binaryfunc)InstanceDict_subscript,		/*mp_subscript*/
  (objobjargproc)InstanceDict_ass_sub,	/*mp_ass_subscript*/
};

/* -------------------------------------------------------- */


static char InstanceDicttype__doc__[] = 
""
;

static PyExtensionClass InstanceDictType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "InstanceDict",			/*tp_name*/
  sizeof(InstanceDictobject),	/*tp_basicsize*/
  0,				/*tp_itemsize*/
  /* methods */
  (destructor)InstanceDict_dealloc,	/*tp_dealloc*/
  (printfunc)0,	/*tp_print*/
  (getattrfunc)0,		/*obsolete tp_getattr*/
  (setattrfunc)0,		/*obsolete tp_setattr*/
  (cmpfunc)0,	/*tp_compare*/
  (reprfunc)InstanceDict_repr,		/*tp_repr*/
  0,		/*tp_as_number*/
  0,		/*tp_as_sequence*/
  &amp;InstanceDict_as_mapping,		/*tp_as_mapping*/
  (hashfunc)0,		/*tp_hash*/
  (ternaryfunc)0,	/*tp_call*/
  (reprfunc)0,		/*tp_str*/
  (getattrofunc)InstanceDict_getattr,			/*tp_getattro*/
  0,			/*tp_setattro*/
  
  /* Space for future expansion */
  0L,0L,
  InstanceDicttype__doc__, /* Documentation string */
  METHOD_CHAIN(InstanceDict_methods)
};

typedef struct {
  PyObject_HEAD
  int level;
  PyObject *dict;
  PyObject *data;
} MM;

staticforward PyExtensionClass MMtype;

static PyObject *
MM_push(MM *self, PyObject *args)
{
  PyObject *src;
  UNLESS(PyArg_Parse(args, "O", &amp;src)) return NULL;
  UNLESS(-1 != PyList_Append(self-&gt;data,src)) return NULL;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.1920">static PyObject *
MM_pop(MM *self, PyObject *args)
{
  int i=1, l;
  PyObject *r;

  if (args) UNLESS(PyArg_Parse(args, "i", &amp;i)) return NULL;
  if ((l=PyList_Size(self-&gt;data)) &lt; 0) return NULL;
  i=l-i;
  UNLESS(r=PySequence_GetItem(self-&gt;data,l-1)) return NULL;
  if (PyList_SetSlice(self-&gt;data,i,l,NULL) &lt; 0) goto err;
  return r;
err:
  Py_DECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1921">static PyObject *
MM__init__(MM *self, PyObject *args)
{
  UNLESS(PyArg_Parse(args, "")) return NULL;
  UNLESS(self-&gt;data=PyList_New(0)) return NULL;
  self-&gt;dict=NULL;
  self-&gt;level=0;
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.1922">static int
safe_PyCallable_Check(PyObject *x)
{
  PyObject *klass;

  if (x == NULL)
    return 0;
  klass = PyObject_GetAttr(x, py___class__);
  if (klass) {
    PyObject *call = PyObject_GetAttr(x, py___call__);
    if (call) {
      Py_DECREF(klass);
      Py_DECREF(call);
      return 1;
    }
    else {
      PyErr_Clear();
      Py_DECREF(klass);
      if (PyClass_Check(x) || PyExtensionClass_Check(x))
        return 1;
      else
        return 0;
    }
  }
  else {
    PyErr_Clear();
    return PyCallable_Check(x);
  }
}
</t>
<t tx="ekr.20040104185913.1923">static int 
dtObjectIsCallable(PyObject *ob) {
  PyObject *base=0;
  int result=0;

  /* Ensure that an object is really callable by unwrapping it */
  UNLESS(base=PyObject_GetAttr(ob, py_aq_base)) {
    PyErr_Clear();
    return safe_PyCallable_Check(ob);
  }
  result=safe_PyCallable_Check(base);
  Py_DECREF(base);
  return result;
}
</t>
<t tx="ekr.20040104185913.1924">static int
dtObjectIsDocTemp(PyObject *ob) {
  PyObject *base=0;
  PyObject *value=0;
  int result=0;

  /* Ensure that 'isDocTemp' is not acquired */
  UNLESS(base=PyObject_GetAttr(ob, py_aq_base)) {
    PyErr_Clear();
    base = ob;
    Py_INCREF(base);
  }

  if ( (value = PyObject_GetAttr(base, py_isDocTemp)) ) {
    if (PyObject_IsTrue(value)) {
      result = 1;
    }
    Py_DECREF(value);
  }
  else PyErr_Clear();

  Py_DECREF(base);
  return result;
}
</t>
<t tx="ekr.20040104185913.1925">static PyObject *
MM_cget(MM *self, PyObject *key, int call)
{
  long i;
  PyObject *e, *rr;

  UNLESS(-1 != (i=PyList_Size(self-&gt;data))) return NULL;
  while (--i &gt;= 0)
    {
      e=PyList_GET_ITEM(self-&gt;data,i);
      if (PyDict_Check(e))
        {
          e=PyDict_GetItem(e, key);
          Py_XINCREF(e);
        }
      else
        {
          UNLESS (e=PyObject_GetItem(e,key)) 
            {
              if (PyErr_Occurred() == PyExc_KeyError)
                PyErr_Clear();
              else
                return NULL;
            }
        }

      if (e)
	{
          if (!call) return e;

          /* Try calling __render_with_namespace__ */
          if ((rr = PyObject_GetAttr(e, py_renderNS))) 
            {
              Py_DECREF(e);
              UNLESS_ASSIGN(rr, PyObject_CallFunction(rr, "O", self))
                return NULL;
              return rr;
            }
          else PyErr_Clear();

	  if (dtObjectIsCallable(e))
	    {
	      /* Try calling the object */
              if (dtObjectIsDocTemp(e))
                {
                  ASSIGN(e,PyObject_CallFunction(e,"OO", Py_None, self));
                  UNLESS(e) return NULL;
                  return e;
                }

              rr=PyObject_CallObject(e,NULL);
              if (rr) ASSIGN(e,rr);
              else {
                Py_DECREF(e);
                return NULL;
              }
            }
	  return e;
	}
    }
  PyErr_SetObject(PyExc_KeyError, key);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1926">static PyObject *
MM_get(MM *self, PyObject *args)
{
  PyObject *key, *call=Py_None;

  UNLESS(PyArg_ParseTuple(args,"O|O",&amp;key,&amp;call)) return NULL;
  return MM_cget(self, key, PyObject_IsTrue(call));
}
</t>
<t tx="ekr.20040104185913.1927">static PyObject *
MM_has_key(MM *self, PyObject *args)
{
  PyObject *key;

  UNLESS(PyArg_ParseTuple(args,"O",&amp;key)) return NULL;
  if ((key=MM_cget(self, key, 0)))
    {
      Py_DECREF(key);
      return PyInt_FromLong(1);
    }
  PyErr_Clear();
  return PyInt_FromLong(0);
}
</t>
<t tx="ekr.20040104185913.1928">static struct PyMethodDef MM_methods[] = {
  {"__init__", (PyCFunction)MM__init__, 0,
   "__init__() -- Create a new empty multi-mapping"},
  {"_push", (PyCFunction) MM_push, 0,
   "_push(mapping_object) -- Add a data source"},
  {"_pop",  (PyCFunction) MM_pop,  0,
   "_pop() -- Remove and return the last data source added"}, 
  {"getitem",  (PyCFunction) MM_get,  METH_VARARGS,
   "getitem(key[,call]) -- Get a value\n\n"
   "Normally, callable objects that can be called without arguments are\n"
   "called during retrieval. This can be suppressed by providing a\n"
   "second argument that is false.\n"
  }, 
  {"has_key",  (PyCFunction) MM_has_key,  METH_VARARGS,
   "has_key(key) -- Test whether the mapping has the given key"
  }, 
  {NULL,		NULL}		/* sentinel */
};

static void
MM_dealloc(MM *self)
{
  Py_XDECREF(self-&gt;data);
  Py_XDECREF(self-&gt;dict);
  Py_DECREF(self-&gt;ob_type);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185913.1929">static PyObject *
MM_getattro(MM *self, PyObject *name)
{
  if (PyString_Check(name))
    {
      if (strcmp(PyString_AsString(name),"level")==0)
	return PyInt_FromLong(self-&gt;level);
    }
  
  if (self-&gt;dict)
    {
      PyObject *v;

      if ((v=PyDict_GetItem(self-&gt;dict, name)))
	{
	  Py_INCREF(v);
	  return v;
	}
    }
  
  return Py_FindAttr((PyObject *)self, name);
}
</t>
<t tx="ekr.20040104185913.1930">static int
MM_setattro(MM *self, PyObject *name, PyObject *v)
{
  if (v &amp;&amp; PyString_Check(name))
    {
      if (strcmp(PyString_AsString(name),"level")==0)
	{
	  self-&gt;level=PyInt_AsLong(v);
	  if (PyErr_Occurred()) return -1;
	  return 0;
	}
    }

  if (! self-&gt;dict &amp;&amp; ! (self-&gt;dict=PyDict_New())) return -1;
  
  if (v) return PyDict_SetItem(self-&gt;dict, name, v);
  else  return PyDict_DelItem(self-&gt;dict, name);
}
</t>
<t tx="ekr.20040104185913.1931">static int
MM_length(MM *self)
{
  long l=0, el, i;
  PyObject *e=0;

  UNLESS(-1 != (i=PyList_Size(self-&gt;data))) return -1;
  while (--i &gt;= 0)
    {
      e=PyList_GetItem(self-&gt;data,i);
      UNLESS(-1 != (el=PyObject_Length(e))) return -1;
      l+=el;
    }
  return l;
}
</t>
<t tx="ekr.20040104185913.1932">static PyObject *
MM_subscript(MM *self, PyObject *key)
{
  return MM_cget(self, key, 1);
}
</t>
<t tx="ekr.20040104185913.1933">typedef struct {
  PyObject_HEAD
  PyObject *data;
} DictInstance;

static void
DictInstance_dealloc(DictInstance *self)
{
  Py_DECREF(self-&gt;data);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185913.1934">static PyObject *
DictInstance_getattr(DictInstance *self, PyObject *name)
{
  PyObject *r;

  if ((r=PyObject_GetItem(self-&gt;data, name))) return r;
  PyErr_SetObject(PyExc_AttributeError, name);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1935">static PyTypeObject DictInstanceType = {
  PyObject_HEAD_INIT(NULL)
  0,				/*ob_size*/
  "DictInstance",			/*tp_name*/
  sizeof(DictInstance),		/*tp_basicsize*/
  0,				/*tp_itemsize*/
  (destructor)DictInstance_dealloc,
  (printfunc)0,
  (getattrfunc)0,
  (setattrfunc)0,
  (cmpfunc)0,
  (reprfunc)0,
  0, 0, 0,
  (hashfunc)0,
  (ternaryfunc)0,
  (reprfunc)0,
  (getattrofunc)DictInstance_getattr,
  (setattrofunc)0,
  0L,0L,
  "Wrap a mapping object to look like an instance"
};

static DictInstance *
newDictInstance(PyObject *data)
{
  DictInstance *self;
	
  UNLESS(self = PyObject_NEW(DictInstance, &amp;DictInstanceType)) return NULL;
  self-&gt;data=data;
  Py_INCREF(data);
  return self;
}
</t>
<t tx="ekr.20040104185913.1936">static PyObject *
MM_call(MM *self, PyObject *args, PyObject *kw)
{
  PyObject *r, *t;
  int i, l=0;

  if (args &amp;&amp; (l=PyTuple_Size(args)) &lt; 0) return NULL;
  if (l)
    {
      UNLESS(r=PyObject_CallObject(OBJECT(self-&gt;ob_type), NULL)) return NULL;
      for (i=0; i &lt; l; i++) 
	if (PyList_Append(((MM*)r)-&gt;data, PyTuple_GET_ITEM(args, i)) &lt; 0) 
	  goto err;
      if (kw &amp;&amp; PyList_Append(((MM*)r)-&gt;data, kw) &lt; 0) goto err;
    }
  else
    {
      if (!kw) 
	{
	  Py_INCREF(Py_None);
	  return Py_None;
	}
      r=kw;
      Py_INCREF(r);
    }

  ASSIGN(r, OBJECT(newDictInstance(r)));
  UNLESS(t=PyTuple_New(1)) goto err;
  PyTuple_SET_ITEM(t, 0, r);
  return t;

err:
  Py_XDECREF(r);
  return NULL;
}
</t>
<t tx="ekr.20040104185913.1937">static PyMappingMethods MM_as_mapping = {
	(inquiry)MM_length,		/*mp_length*/
	(binaryfunc)MM_subscript,      	/*mp_subscript*/
	(objobjargproc)NULL,		/*mp_ass_subscript*/
};

/* -------------------------------------------------------- */

static char MMtype__doc__[] = 
"TemplateDict -- Combine multiple mapping objects for lookup"
;

static PyExtensionClass MMtype = {
	PyObject_HEAD_INIT(NULL)
	0,				/*ob_size*/
	"TemplateDict",			/*tp_name*/
	sizeof(MM),			/*tp_basicsize*/
	0,				/*tp_itemsize*/
	/* methods */
	(destructor)MM_dealloc,		/*tp_dealloc*/
	(printfunc)0,			/*tp_print*/
	(getattrfunc)0,			/*tp_getattr*/
	(setattrfunc)0,			/*tp_setattr*/
	(cmpfunc)0,			/*tp_compare*/
	(reprfunc)0,			/*tp_repr*/
	0,				/*tp_as_number*/
	0,				/*tp_as_sequence*/
	&amp;MM_as_mapping,			/*tp_as_mapping*/
	(hashfunc)0,			/*tp_hash*/
	(ternaryfunc)MM_call,		/*tp_call*/
	(reprfunc)0,			/*tp_str*/
	(getattrofunc)MM_getattro,	/*tp_getattro*/
	(setattrofunc)MM_setattro,	/*tp_setattro*/

	/* Space for future expansion */
	0L,0L,
	MMtype__doc__, /* Documentation string */
	METHOD_CHAIN(MM_methods)
};


/* List of methods defined in the module */

static int
if_finally(PyObject *md, int err)
{
  PyObject *t, *v, *tb;

  if (err) PyErr_Fetch(&amp;t, &amp;v, &amp;tb);

  md=PyObject_GetAttr(md,py__pop);
  if (md) ASSIGN(md, PyObject_CallObject(md,NULL));
  
  if (err) PyErr_Restore(t,v,tb);
  
  if (md)
    {
      Py_DECREF(md);
      return -1;
    }
  else 
    return -2;
}
</t>
<t tx="ekr.20040104185913.1938">static int
render_blocks_(PyObject *blocks, PyObject *rendered,
	       PyObject *md, PyObject *mda)
{
  PyObject *block, *t, *args;
  int l, i, k=0, append;
  int skip_html_quote;

  if ((l=PyList_Size(blocks)) &lt; 0) return -1;
  for (i=0; i &lt; l; i++)
    {
      block=PyList_GET_ITEM(((PyListObject*)blocks), i);
      append=1;

      if (PyTuple_Check(block) 
          &amp;&amp; PyTuple_GET_SIZE(block) &gt; 1 
          &amp;&amp; PyTuple_GET_ITEM(block, 0)
          &amp;&amp; PyString_Check(PyTuple_GET_ITEM(block, 0)))
	{
          switch (PyString_AS_STRING(PyTuple_GET_ITEM(block, 0))[0])
            {
            case 'v': /* var  */
	      t=PyTuple_GET_ITEM(block,1);

	      if (t == NULL) return -1;

	      if (PyString_Check(t)) t=PyObject_GetItem(md, t);
	      else t=PyObject_CallObject(t, mda);

              if (t == NULL) return -1;

	      skip_html_quote = 0;
	      if (! ( PyString_Check(t) || PyUnicode_Check(t) ) )
	        {
		  /* This might be a TaintedString object */
		  PyObject *untaintmethod = NULL;

		  untaintmethod = PyObject_GetAttr(t, untaint_name);
		  if (untaintmethod) {
		     /* Quote it */
		     UNLESS_ASSIGN(t,
		   	    PyObject_CallObject(untaintmethod, NULL)) return -1;
		     skip_html_quote = 1;

		  } else PyErr_Clear();

		  Py_XDECREF(untaintmethod);
	        }

              if (! ( PyString_Check(t) || PyUnicode_Check(t) ) )
                {
                  args = PyTuple_New(1);
                  if(!args) return -1;
                  PyTuple_SET_ITEM(args,0,t);
                  t = PyObject_CallObject(ustr, args);
                  Py_DECREF(args);
                  args = NULL;
                  UNLESS(t) return -1;
                }

              if (skip_html_quote == 0 &amp;&amp; PyTuple_GET_SIZE(block) == 3)
		       /* html_quote */
                {
                  if (PyString_Check(t))
                    {
                      if (strchr(PyString_AS_STRING(t), '&amp;') ||
                          strchr(PyString_AS_STRING(t), '&lt;') ||
                          strchr(PyString_AS_STRING(t), '&gt;') ||
                          strchr(PyString_AS_STRING(t), '"')     )
                        {
                          /* string includes html problem characters, so
                             we cant skip the quoting process */
                          skip_html_quote = 0;
                        }
                      else
                        {
                          skip_html_quote = 1;
                        }
                    }
                  else
                    {
                      /* never skip the quoting for unicode strings */
                      skip_html_quote = 0;
                    }
                  if (!skip_html_quote)
                    {
                      ASSIGN(t, PyObject_CallFunction(html_quote, "O", t));
                      if (t == NULL) return -1;
                    }
                }
                  
              block = t;
              break;
            case 'i': /* if */
              {
                int icond, m, bs;
                PyObject *cond, *n, *cache;

                bs = PyTuple_GET_SIZE(block) - 1; /* subtract code */

                UNLESS(cache=PyDict_New()) return -1;
                cond=PyObject_GetAttr(md,py__push);
                if (cond) ASSIGN(cond, PyObject_CallFunction(cond,"O",cache));
                Py_DECREF(cache);
                if (cond) Py_DECREF(cond);
                else return -1;
	      
                append=0;
                m=bs-1;
                for (icond=0; icond &lt; m; icond += 2)
                  {
                    cond=PyTuple_GET_ITEM(block,icond+1);
                    if (PyString_Check(cond))
                      {
                        /* We have to be careful to handle key errors here */
                        n=cond;
                        if ((cond=PyObject_GetItem(md,cond)))
                          {
                            if (PyDict_SetItem(cache, n, cond) &lt; 0)
                              {
                                Py_DECREF(cond);
                                return if_finally(md,1);
                              }
                          }
                        else
                          {
                            PyObject *t, *v, *tb;
                            
                            PyErr_Fetch(&amp;t, &amp;v, &amp;tb);
                            if (t != PyExc_KeyError || PyObject_Compare(v,n))
                              {
                                PyErr_Restore(t,v,tb);
                                return if_finally(md,1);
                              }
                            Py_XDECREF(t);
                            Py_XDECREF(v);
                            Py_XDECREF(tb);
                            cond=Py_None;
                            Py_INCREF(cond);
                          }
                      }
                    else
                      UNLESS(cond=PyObject_CallObject(cond,mda))
                        return if_finally(md,1);
                    
                    if (PyObject_IsTrue(cond))
                      {
                        Py_DECREF(cond);
                        block=PyTuple_GET_ITEM(block,icond+1+1);
                        if (block!=Py_None &amp;&amp;
                            render_blocks_(block, rendered, md, mda) &lt; 0)
                          return if_finally(md,1);
                        m=-1;
                        break;
                      }
                    else Py_DECREF(cond);
                  }
		if (icond==m)
		  {
		    block=PyTuple_GET_ITEM(block,icond+1);
		    if (block!=Py_None &amp;&amp;
                        render_blocks_(block, rendered, md, mda) &lt; 0)
		      return if_finally(md,1);
		  }
                
		if (if_finally(md,0) == -2) return -1;
              }
              break;
            default:
              PyErr_Format(PyExc_ValueError,
                           "Invalid DTML command code, %s",
                           PyString_AS_STRING(PyTuple_GET_ITEM(block, 0)));
              return -1;
            }
        }
      else if (PyString_Check(block) || PyUnicode_Check(block))
	{
	  Py_INCREF(block);
	}
      else
	{
	  UNLESS(block=PyObject_CallObject(block,mda)) return -1;
	}

      if (append &amp;&amp; PyObject_IsTrue(block))
	{
	  k=PyList_Append(rendered,block);
	  Py_DECREF(block);
	  if (k &lt; 0) return -1;
	}
    }

  return 0;
}
</t>
<t tx="ekr.20040104185913.1939">static PyObject *
render_blocks(PyObject *self, PyObject *args)
{
  PyObject *md, *blocks, *mda=0, *rendered=0;
  int l;

  UNLESS(PyArg_ParseTuple(args,"OO", &amp;blocks, &amp;md)) return NULL;
  UNLESS(rendered=PyList_New(0)) goto err;
  UNLESS(mda=Py_BuildValue("(O)",md)) goto err;
  
  if (render_blocks_(blocks, rendered, md, mda) &lt; 0) goto err;

  Py_DECREF(mda);

  l=PyList_Size(rendered);
  if (l==0)
    {
      Py_INCREF(py_);
      ASSIGN(rendered, py_);
    }
  else if (l==1)
    ASSIGN(rendered, PySequence_GetItem(rendered,0));
  else
    ASSIGN(rendered, _join_unicode(rendered));

  return rendered;

err:
  Py_XDECREF(mda);
  Py_XDECREF(rendered);
  return NULL;
}</t>
<t tx="ekr.20040104185913.1940">static PyObject *
safe_callable(PyObject *self, PyObject *args)
{
  PyObject *ob;
  int res;

  UNLESS(PyArg_ParseTuple(args,"O", &amp;ob)) return NULL;
  res = safe_PyCallable_Check(ob);
  if (res)
    return PyInt_FromLong(1);
  else
    return PyInt_FromLong(0);
}
</t>
<t tx="ekr.20040104185913.1941">static PyObject *
_join_unicode(PyObject *prejoin)
{
    PyObject *joined;
    joined = PyObject_CallFunction(join,"OO",prejoin,py_);
    if(!joined &amp;&amp; PyErr_ExceptionMatches(PyExc_UnicodeError))
    {
        int i,l;
        PyObject *list;
        PyErr_Clear();
        list = PySequence_List(prejoin);
        if(!list)
        {
            return NULL;
        }
        l = PyList_Size(list);
        for(i=0;i&lt;l;++i)
        {
            PyObject *item = PyList_GetItem(list,i);
            if(PyString_Check(item))
            {
                PyObject *unicode = PyUnicode_DecodeLatin1(PyString_AsString(item),PyString_Size(item),NULL);
                if(unicode)
                {
                    PyList_SetItem(list,i,unicode);
                }
                else
                {
                    Py_DECREF(list);
                    return NULL;
                }
           }
       }
       joined = PyObject_CallFunction(join,"OO",list,py_);
       Py_DECREF(list);
    }
    return joined;
}
</t>
<t tx="ekr.20040104185913.1942">static PyObject *
join_unicode(PyObject *self, PyObject *args)
{
  PyObject *ob;

  UNLESS(PyArg_ParseTuple(args,"O", &amp;ob)) return NULL;
  return _join_unicode(ob);
}
</t>
<t tx="ekr.20040104185913.1943">static struct PyMethodDef Module_Level__methods[] = {
  {"render_blocks", (PyCFunction)render_blocks,	METH_VARARGS,
   ""},
  {"join_unicode", (PyCFunction)join_unicode,	METH_VARARGS,
   "join a list of plain strings into a single plain string,\n"
   "a list of unicode strings into a single unicode strings,\n"
   "or a list containing a mix into a single unicode string with\n"
   "the plain strings converted from latin-1"},
  {"safe_callable", (PyCFunction)safe_callable,	METH_VARARGS,
   "callable() with a workaround for a problem with ExtensionClasses\n"
   "and __call__()."},
  {NULL, (PyCFunction)NULL, 0, NULL}		/* sentinel */
};

void
initcDocumentTemplate(void)
{
  PyObject *m, *d;

  DictInstanceType.ob_type=&amp;PyType_Type;

  UNLESS (html_quote = PyImport_ImportModule("html_quote")) return;
  ASSIGN(ustr, PyObject_GetAttrString(html_quote, "ustr"));
  UNLESS (ustr) return;
  ASSIGN(html_quote, PyObject_GetAttrString(html_quote, "html_quote"));
  UNLESS (html_quote) return;

  UNLESS(py_isDocTemp=PyString_FromString("isDocTemp")) return;
  UNLESS(py_renderNS=PyString_FromString("__render_with_namespace__")) return;
  UNLESS(py_blocks=PyString_FromString("blocks")) return;
  UNLESS(untaint_name=PyString_FromString("__untaint__")) return;
  UNLESS(py_acquire=PyString_FromString("aq_acquire")) return;
  UNLESS(py___call__=PyString_FromString("__call__")) return;
  UNLESS(py___roles__=PyString_FromString("__roles__")) return;
  UNLESS(py__proxy_roles=PyString_FromString("_proxy_roles")) return;
  UNLESS(py_hasRole=PyString_FromString("hasRole")) return;
  UNLESS(py_guarded_getattr=PyString_FromString("guarded_getattr")) return;
  UNLESS(py__push=PyString_FromString("_push")) return;
  UNLESS(py__pop=PyString_FromString("_pop")) return;
  UNLESS(py_aq_base=PyString_FromString("aq_base")) return;
  UNLESS(py_Unauthorized=PyString_FromString("Unauthorized")) return;
  UNLESS(py_Unauthorized_fmt=PyString_FromString(
	 "You are not authorized to access &lt;em&gt;%s&lt;/em&gt;.")) return;
  UNLESS(py___class__=PyString_FromString("__class__")) return;

  UNLESS(py_AUTHENTICATED_USER=PyString_FromString("AUTHENTICATED_USER"))
    return;

  UNLESS(py_=PyString_FromString("")) return;
  UNLESS(join=PyImport_ImportModule("string")) return;
  ASSIGN(join,PyObject_GetAttrString(join,"join"));
  UNLESS(join) return;
  UNLESS(ExtensionClassImported) return;

  m = Py_InitModule4("cDocumentTemplate", Module_Level__methods,
		     cDocumentTemplate_module_documentation,
		     (PyObject*)NULL,PYTHON_API_VERSION);

  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d,"InstanceDict",InstanceDictType);
  PyExtensionClass_Export(d,"TemplateDict",MMtype);

}
</t>
<t tx="ekr.20040104185913.1944">&lt;&lt; html_quote declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1945"># split off into its own module for aliasing without circrefs

from cgi import escape
from ustr import ustr

</t>
<t tx="ekr.20040104185913.1946">def html_quote(v, name='(Unknown name)', md={}):
    return escape(ustr(v), 1)
</t>
<t tx="ekr.20040104185913.1947">&lt;&lt; pDocumentTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1948">&lt;&lt; copyright &gt;&gt;

__doc__='''Python implementations of document template some features


$Id: pDocumentTemplate.py,v 1.36 2002/08/14 22:29:53 mj Exp $'''
__version__='$Revision: 1.36 $'[11:-2]

import  sys, types

ClassTypes = [types.ClassType]

try:
    from ExtensionClass import Base
except ImportError:
    pass
else:
</t>
<t tx="ekr.20040104185913.1949">class c(Base): pass
	&lt;&lt; class c declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.1950">ClassTypes.append(c.__class__)


</t>
<t tx="ekr.20040104185913.1951">def safe_callable(ob):
    # Works with ExtensionClasses and Acquisition.
    if hasattr(ob, '__class__'):
        if hasattr(ob, '__call__'):
            return 1
        else:
            return type(ob) in ClassTypes
    else:
        return callable(ob)
</t>
<t tx="ekr.20040104185913.1952">StringType=type('')
UnicodeType=type(u'')
TupleType=type(())


class InstanceDict:
	&lt;&lt; class InstanceDict declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1953">guarded_getattr=None

</t>
<t tx="ekr.20040104185913.1954">def __init__(self,o,namespace,guarded_getattr=None):
    self.self=o
    self.cache={}
    self.namespace=namespace
    if guarded_getattr is None:
        self.guarded_getattr = namespace.guarded_getattr
    else: self.guarded_getattr = guarded_getattr
</t>
<t tx="ekr.20040104185913.1955">def has_key(self,key):
    return hasattr(self.self,key)
</t>
<t tx="ekr.20040104185913.1956">def keys(self):
    return self.self.__dict__.keys()
</t>
<t tx="ekr.20040104185913.1957">def __repr__(self): return 'InstanceDict(%s)' % str(self.self)
</t>
<t tx="ekr.20040104185913.1958">def __getitem__(self,key):

    cache=self.cache
    if cache.has_key(key): return cache[key]

    inst=self.self

    if key[:1]=='_':
        if key != '__str__':
            raise KeyError, key # Don't divuldge private data
        else:
            return str(inst)

    get = self.guarded_getattr
    if get is None:
        get = getattr

    try: r = get(inst, key)
    except AttributeError: raise KeyError, key

    self.cache[key]=r
    return r
</t>
<t tx="ekr.20040104185913.1959">def __len__(self):
    return 1
</t>
<t tx="ekr.20040104185913.1960">class MultiMapping:
	@others
</t>
<t tx="ekr.20040104185913.1961">def __init__(self): self.dicts=[]
</t>
<t tx="ekr.20040104185913.1962">def __getitem__(self, key):
    for d in self.dicts:
        try: return d[key]
        except KeyError, AttributeError: pass
    raise KeyError, key
</t>
<t tx="ekr.20040104185913.1963">def push(self,d): self.dicts.insert(0,d)
</t>
<t tx="ekr.20040104185913.1964">def pop(self, n=1):
    r = self.dicts[-1]
    del self.dicts[:n]
    return r
</t>
<t tx="ekr.20040104185913.1965">def keys(self):
    kz = []
    for d in self.dicts:
        kz = kz + d.keys()
    return kz
</t>
<t tx="ekr.20040104185913.1966">class DictInstance:
	@others
</t>
<t tx="ekr.20040104185913.1967">def __init__(self, mapping):
    self.__d=mapping
</t>
<t tx="ekr.20040104185913.1968">def __getattr__(self, name):
    try: return self.__d[name]
    except KeyError: raise AttributeError, name
</t>
<t tx="ekr.20040104185913.1969">class TemplateDict:
	&lt;&lt; class TemplateDict declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.1970">level=0

</t>
<t tx="ekr.20040104185913.1971">def _pop(self, n=1): return self.dicts.pop(n)
</t>
<t tx="ekr.20040104185913.1972">def _push(self, d): return self.dicts.push(d)
</t>
<t tx="ekr.20040104185913.1973">def __init__(self):
    m=self.dicts=MultiMapping()
    self._pop=m.pop
    self._push=m.push
    try: self.keys=m.keys
    except: pass
</t>
<t tx="ekr.20040104185913.1974">def __getitem__(self,key,call=1):

    v = self.dicts[key]
    if call:
        if hasattr(v, '__render_with_namespace__'):
            return v.__render_with_namespace__(self)
        vbase = getattr(v, 'aq_base', v)
        if safe_callable(vbase):
            if getattr(vbase, 'isDocTemp', 0):
                v = v(None, self)
            else:
                v = v()
    return v
</t>
<t tx="ekr.20040104185913.1975">def __len__(self):
    total = 0
    for d in self.dicts.dicts:
        total = total + len(d)
    return total
</t>
<t tx="ekr.20040104185913.1976">def has_key(self,key):
    try:
        v=self.dicts[key]
    except KeyError:
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.1977">getitem=__getitem__

def __call__(self, *args, **kw):
    if args:
        if len(args)==1 and not kw:
            m=args[0]
        else:
            m=self.__class__()
            for a in args: m._push(a)
            if kw: m._push(kw)
    else: m=kw
    return (DictInstance(m),)
</t>
<t tx="ekr.20040104185913.1978">def render_blocks(blocks, md):
    rendered = []
    append=rendered.append
    for section in blocks:
        if type(section) is TupleType:
            l=len(section)
            if l==1:
                # Simple var
                section=section[0]
                if type(section) is StringType: section=md[section]
                else: section=section(md)
                section=ustr(section)
            else:
                # if
                cache={}
                md._push(cache)
                try:
                    i=0
                    m=l-1
                    while i &lt; m:
                        cond=section[i]
                        if type(cond) is StringType:
                            n=cond
                            try:
                                cond=md[cond]
                                cache[n]=cond
                            except KeyError, v:
                                v=str(v)
                                if n != v: raise KeyError, v, sys.exc_traceback
                                cond=None
                        else: cond=cond(md)
                        if cond:
                            section=section[i+1]
                            if section: section=render_blocks(section,md)
                            else: section=''
                            m=0
                            break
                        i=i+2
                    if m:
                        if i==m: section=render_blocks(section[i],md)
                        else: section=''

                finally: md._pop()

        elif type(section) is not StringType and type(section) is not UnicodeType:
            section=section(md)

        if section: rendered.append(section)

    l=len(rendered)
    if l==0: return ''
    elif l==1: return rendered[0]
    return join_unicode(rendered)
</t>
<t tx="ekr.20040104185913.1979">def join_unicode(rendered):
    """join a list of plain strings into a single plain string,
    a list of unicode strings into a single unicode strings,
    or a list containing a mix into a single unicode string with
    the plain strings converted from latin-1
    """
    try:
        return ''.join(rendered)
    except UnicodeError:
        # A mix of unicode string and non-ascii plain strings.
        # Fix up the list, treating normal strings as latin-1
        rendered = list(rendered)
        for i in range(len(rendered)):
            if type(rendered[i]) is StringType:
                rendered[i] = unicode(rendered[i],'latin-1')
        return u''.join(rendered)
</t>
<t tx="ekr.20040104185913.1980">&lt;&lt; copyright &gt;&gt;

from types import StringType, UnicodeType, InstanceType

nasty_exception_str = Exception.__str__.im_func

@others
</t>
<t tx="ekr.20040104185913.1982">def ustr(v):
    """Convert any object to a plain string or unicode string,
    minimising the chance of raising a UnicodeError. This
    even works with uncooperative objects like Exceptions
    """
    string_types = (StringType,UnicodeType)
    if type(v) in string_types:
        return v
    else:
        fn = getattr(v,'__str__',None)
        if fn is not None:
            # An object that wants to present its own string representation,
            # but we dont know what type of string. We cant use any built-in
            # function like str() or unicode() to retrieve it because
            # they all constrain the type which potentially raises an exception.
            # To avoid exceptions we have to call __str__ direct.
            if getattr(fn,'im_func',None)==nasty_exception_str:
                # Exception objects have been optimised into C, and their
                # __str__ function fails when given a unicode object.
                # Unfortunately this scenario is all too common when
                # migrating to unicode, because of code which does:
                # raise ValueError(something_I_wasnt_expecting_to_be_unicode)
                return _exception_str(v)
            else:
                # Trust the object to do this right
                v = fn()
                if type(v) in string_types:
                    return v
                else:
                    raise ValueError('__str__ returned wrong type')
        # Drop through for non-instance types, and instances that
        # do not define a special __str__
        return str(v)
</t>
<t tx="ekr.20040104185913.1983">def _exception_str(exc):
    if hasattr(exc, 'args'):
        if not exc.args:
            return ''
        elif len(exc.args) == 1:
            return ustr(exc.args[0])
        else:
            return str(exc.args)
    return str(exc)
</t>
<t tx="ekr.20040104185913.1984"></t>
<t tx="ekr.20040104185913.1985">&lt;&lt; SortEx declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.1986">&lt;&lt; copyright &gt;&gt;
"""
Advanced sort support by Oleg Broytmann &lt;phd@@phd.pp.ru&gt; 23 Apr 2001
eg Sort(sequence, (("akey", "nocase"), ("anotherkey", "cmp", "desc")))

$Id: SortEx.py,v 1.5.6.1 2002/09/25 15:56:05 jeremy Exp $
"""


TupleType=type(())


</t>
<t tx="ekr.20040104185913.1987">def sort(sequence, sort=(), _=None, mapping=0):
    """
    - sequence is a sequence of objects to be sorted

    - sort is a sequence of tuples (key,func,direction)
      that define the sort order:

      - key is the name of an attribute to sort the objects by

      - func is the name of a comparison function. This parameter is
        optional

        allowed values:

        - "cmp" -- the standard comparison function (default)

        - "nocase" -- case-insensitive comparison

        - "strcoll" or "locale" -- locale-aware string comparison

        - "strcoll_nocase" or "locale_nocase" -- locale-aware case-insensitive
           string comparison

        - "xxx" -- a user-defined comparison function

      - direction -- defines the sort direction for the key (optional).
        (allowed values: "asc" (default) , "desc")
    """



    need_sortfunc = 0
    if sort:
        for s in sort:
            if len(s) &gt; 1: # extended sort if there is reference to...
                # ...comparison function or sort order, even if they are "cmp" and "asc"
                need_sortfunc = 1
                break

    sortfields = sort # multi sort = key1,key2
    multsort = len(sortfields) &gt; 1 # flag: is multiple sort

    if need_sortfunc:
        # prepare the list of functions and sort order multipliers
        sf_list = make_sortfunctions(sortfields, _)

        # clean the mess a bit
        if multsort: # More than one sort key.
            sortfields = map(lambda x: x[0], sf_list)
        else:
            sort = sf_list[0][0]

    elif sort:
        if multsort: # More than one sort key.
            sortfields = map(lambda x: x[0], sort)
        else:
            sort = sort[0][0]

    isort=not sort

    s=[]
    for client in sequence:
        k = None
        if type(client)==TupleType and len(client)==2:
            if isort: k=client[0]
            v=client[1]
        else:
            if isort: k=client
            v=client

        if sort:
            if multsort: # More than one sort key.
                k = []
                for sk in sortfields:
                    try:
                        if mapping: akey = v[sk]
                        else: akey = getattr(v, sk)
                    except (AttributeError, KeyError):
                        akey = None
                    if not basic_type(akey):
                        try: akey = akey()
                        except: pass
                    k.append(akey)
            else: # One sort key.
                try:
                    if mapping: k = v[sort]
                    else: k = getattr(v, sort)
                except (AttributeError, KeyError):
                    k = None
                if not basic_type(type(k)):
                    try: k = k()
                    except: pass

        s.append((k,client))

    if need_sortfunc:
        by = SortBy(multsort, sf_list)
        s.sort(by)
    else:
        s.sort()

    sequence=[]
    for k, client in s:
        sequence.append(client)
    return sequence
</t>
<t tx="ekr.20040104185913.1988">SortEx = sort

basic_type={type(''): 1, type(0): 1, type(0.0): 1, type(()): 1, type([]): 1,
            type(None) : 1 }.has_key

def nocase(str1, str2):
    return cmp(str1.lower(), str2.lower())
</t>
<t tx="ekr.20040104185913.1989">import sys
if sys.modules.has_key("locale"): # only if locale is already imported
    from locale import strcoll

    def strcoll_nocase(str1, str2):
        return strcoll(str1.lower(), str2.lower())
</t>
<t tx="ekr.20040104185913.1990">def make_sortfunctions(sortfields, _):
    """Accepts a list of sort fields; splits every field, finds comparison
    function. Returns a list of 3-tuples (field, cmp_function, asc_multplier)"""

    sf_list = []
    for field in sortfields:
        f = list(field)
        l = len(f)

        if l == 1:
            f.append("cmp")
            f.append("asc")
        elif l == 2:
            f.append("asc")
        elif l == 3:
            pass
        else:
            raise SyntaxError, "sort option must contains no more than 2 fields"

        f_name = f[1]

        # predefined function?
        if f_name == "cmp":
            func = cmp # builtin
        elif f_name == "nocase":
            func = nocase
        elif f_name in ("locale", "strcoll"):
            func = strcoll
        elif f_name in ("locale_nocase", "strcoll_nocase"):
            func = strcoll_nocase
        else: # no - look it up in the namespace
            func = _.getitem(f_name, 0)

        sort_order = f[2].lower()

        if sort_order == "asc":
            multiplier = +1
        elif sort_order == "desc":
            multiplier = -1
        else:
            raise SyntaxError, "sort oder must be either ASC or DESC"

        sf_list.append((f[0], func, multiplier))

    return sf_list
</t>
<t tx="ekr.20040104185913.1991">class SortBy:
	@others
</t>
<t tx="ekr.20040104185913.1992">def __init__(self, multsort, sf_list):
    self.multsort = multsort
    self.sf_list = sf_list
</t>
<t tx="ekr.20040104185913.1993">def __call__(self, o1, o2):
    multsort = self.multsort
    if multsort:
        o1 = o1[0] # if multsort - take the first element (key list)
        o2 = o2[0]

    sf_list = self.sf_list
    l = len(sf_list)

    # assert that o1 and o2 are tuples of apropriate length
    assert len(o1) == l + 1 - multsort, "%s, %d" % (o1, l + multsort)
    assert len(o2) == l + 1 - multsort, "%s, %d" % (o2, l + multsort)

    # now run through the list of functions in sf_list and
    # compare every object in o1 and o2
    for i in range(l):
        # if multsort - we already extracted the key list
        # if not multsort - i is 0, and the 0th element is the key
        c1, c2 = o1[i], o2[i]
        func, multiplier = sf_list[i][1:3]
        n = func(c1, c2)
        if n: return n*multiplier

    # all functions returned 0 - identical sequences
    return 0
</t>
<t tx="ekr.20040104185913.1994">&lt;&lt; copyright &gt;&gt;


from SortEx import *
</t>
<t tx="ekr.20040104185913.1995"></t>
<t tx="ekr.20040104185913.1996">"""
Python package.
"""
</t>
<t tx="ekr.20040104185913.1997">res1=[{'weight': 1, 'word': 'AAA', 'key': 'aaa'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}]
res2=[{'weight': 1, 'word': 'AAA', 'key': 'aaa'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}]
res3=[{'weight': 1, 'word': 'AAA', 'key': 'aaa'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}]
res4=[{'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 1, 'word': 'AAA', 'key': 'aaa'}]
res5=[{'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}, {'weight': 1, 'word': 'AAA', 'key': 'aaa'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}]
res6=[{'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 1, 'word': 'AAA', 'key': 'aaa'}]
res7=[{'weight': -1, 'word': 'JJJ', 'key': 'jjj'}, {'weight': -1, 'word': 'QQQ', 'key': 'qqq'}, {'weight': -1, 'word': 'YYY', 'key': 'yyy'}, {'weight': 0, 'word': 'BBB', 'key': 'bbb'}, {'weight': 0, 'word': 'CCC', 'key': 'ccc'}, {'weight': 0, 'word': 'DDD', 'key': 'ddd'}, {'weight': 0, 'word': 'FFF', 'key': 'fff'}, {'weight': 0, 'word': 'GGG', 'key': 'ggg'}, {'weight': 0, 'word': 'HHH', 'key': 'hhh'}, {'weight': 0, 'word': 'KKK', 'key': 'kkk'}, {'weight': 0, 'word': 'LLL', 'key': 'lll'}, {'weight': 0, 'word': 'MMM', 'key': 'mmm'}, {'weight': 0, 'word': 'NNN', 'key': 'nnn'}, {'weight': 0, 'word': 'PPP', 'key': 'ppp'}, {'weight': 0, 'word': 'RRR', 'key': 'rrr'}, {'weight': 0, 'word': 'SSS', 'key': 'sss'}, {'weight': 0, 'word': 'TTT', 'key': 'ttt'}, {'weight': 0, 'word': 'VVV', 'key': 'vvv'}, {'weight': 0, 'word': 'WWW', 'key': 'www'}, {'weight': 0, 'word': 'XXX', 'key': 'xxx'}, {'weight': 0, 'word': 'ZZZ', 'key': 'zzz'}, {'weight': 1, 'word': 'AAA', 'key': 'aaa'}, {'weight': 1, 'word': 'EEE', 'key': 'eee'}, {'weight': 1, 'word': 'III', 'key': 'iii'}, {'weight': 1, 'word': 'OOO', 'key': 'ooo'}, {'weight': 1, 'word': 'UUU', 'key': 'uuu'}]
</t>
<t tx="ekr.20040104185913.1998">&lt;&lt; testSequence declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.1999">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest

from DocumentTemplate.sequence.SortEx import *
from DocumentTemplate.sequence.tests.ztestlib import *
from DocumentTemplate.sequence.tests.results import *


</t>
<t tx="ekr.20040104185913.2000">class TestCase( unittest.TestCase ):
    """
        Test SortEx .
    """
	@others
</t>
<t tx="ekr.20040104185913.2001">def setUp( self ):
    """
    """
</t>
<t tx="ekr.20040104185913.2002">def tearDown( self ):
    """
    """
</t>
<t tx="ekr.20040104185913.2003">def test1( self ):
    "test1"
    assert res1==SortEx(wordlist)
</t>
<t tx="ekr.20040104185913.2004">def test2( self ):
    "test2"
    assert res2==SortEx(wordlist, (("key",),), mapping=1)
</t>
<t tx="ekr.20040104185913.2005">def test3( self ):
    "test3"
    assert res3==SortEx(wordlist, (("key", "cmp"),), mapping=1)
</t>
<t tx="ekr.20040104185913.2006">def test4( self ):
    "test4"
    assert res4==SortEx(wordlist, (("key", "cmp", "desc"),), mapping=1)
</t>
<t tx="ekr.20040104185913.2007">def test5( self ):
    "test5"
    assert res5==SortEx(wordlist, (("weight",), ("key",)), mapping=1)
</t>
<t tx="ekr.20040104185913.2008">def test6( self ):
    "test6"
    assert res6==SortEx(wordlist, (("weight",), ("key", "nocase", "desc")), mapping=1)
</t>
<t tx="ekr.20040104185913.2009">def test7(self):
    "test7"

    def myCmp(s1, s2):
        return -cmp(s1, s2)

    # Create namespace...
    from DocumentTemplate.DT_Util import TemplateDict
    md = TemplateDict()

    #... and push out function onto the namespace
    md._push({"myCmp" : myCmp})

    assert res7==SortEx( wordlist
                       , ( ("weight",)
                         , ("key", "myCmp", "desc")
                         )
                       , md
                       , mapping=1
                       )
</t>
<t tx="ekr.20040104185913.2010">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestCase ) )
    return suite
</t>
<t tx="ekr.20040104185913.2011">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2012">@others


wordlist = [
   {"key": "aaa", "word": "AAA", "weight": 1},
   {"key": "bbb", "word": "BBB", "weight": 0},
   {"key": "ccc", "word": "CCC", "weight": 0},
   {"key": "ddd", "word": "DDD", "weight": 0},
   {"key": "eee", "word": "EEE", "weight": 1},
   {"key": "fff", "word": "FFF", "weight": 0},
   {"key": "ggg", "word": "GGG", "weight": 0},
   {"key": "hhh", "word": "HHH", "weight": 0},
   {"key": "iii", "word": "III", "weight": 1},
   {"key": "jjj", "word": "JJJ", "weight": -1},
   {"key": "kkk", "word": "KKK", "weight": 0},
   {"key": "lll", "word": "LLL", "weight": 0},
   {"key": "mmm", "word": "MMM", "weight": 0},
   {"key": "nnn", "word": "NNN", "weight": 0},
   {"key": "ooo", "word": "OOO", "weight": 1},
   {"key": "ppp", "word": "PPP", "weight": 0},
   {"key": "qqq", "word": "QQQ", "weight": -1},
   {"key": "rrr", "word": "RRR", "weight": 0},
   {"key": "sss", "word": "SSS", "weight": 0},
   {"key": "ttt", "word": "TTT", "weight": 0},
   {"key": "uuu", "word": "UUU", "weight": 1},
   {"key": "vvv", "word": "VVV", "weight": 0},
   {"key": "www", "word": "WWW", "weight": 0},
   {"key": "xxx", "word": "XXX", "weight": 0},
   {"key": "yyy", "word": "YYY", "weight": -1},
   {"key": "zzz", "word": "ZZZ", "weight": 0}
]
</t>
<t tx="ekr.20040104185913.2013">class standard_html: # Base class for using with ZTemplates
	@others
</t>
<t tx="ekr.20040104185913.2014">def __init__(self, title):
    self.standard_html_header = """&lt;HTML&gt;
&lt;HEAD&gt;
  &lt;TITLE&gt;
     %s
  &lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;BODY&gt;""" % title

    self.standard_html_footer = """&lt;/BODY&gt;
&lt;/HTML&gt;"""

    self.title = title
</t>
<t tx="ekr.20040104185913.2015">def test(s):
    outfile = open("test.out", 'w')
    outfile.write(s)
    outfile.close()
</t>
<t tx="ekr.20040104185913.2016">def exception():
    import sys, traceback
    exc_type, exc_value, exc_tb = sys.exc_info()

    outfile = open("test.err", 'w')
    traceback.print_exception(exc_type, exc_value, exc_tb, None, outfile)
    outfile.close()
</t>
<t tx="ekr.20040104185913.2017"></t>
<t tx="ekr.20040104185913.2018">'''
Python package.
'''
</t>
<t tx="ekr.20040104185913.2019">&lt;&lt; testDTML declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.2020">&lt;&lt; copyright &gt;&gt;
"""Document Template Tests
"""

__rcs_id__='$Id: testDTML.py,v 1.14 2002/08/14 22:29:53 mj Exp $'
__version__='$Revision: 1.14 $'[11:-2]

import sys, os
import unittest

if __name__=='__main__':
    here = os.curdir
else:
    from DocumentTemplate import tests
    here = tests.__path__[0]

</t>
<t tx="ekr.20040104185913.2021">def read_file(name):
    f = open(os.path.join(here, name), 'r')
    res = f.read()
    f.close()
    return res
</t>
<t tx="ekr.20040104185913.2022">from DocumentTemplate.DT_HTML import HTML, String
from ExtensionClass import Base
class D:
	&lt;&lt; class D declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2023">__allow_access_to_unprotected_subobjects__ = 1

</t>
<t tx="ekr.20040104185913.2024">def __init__(self, **kw):
    for k, v in kw.items(): self.__dict__[k]=v
</t>
<t tx="ekr.20040104185913.2025">def __repr__(self): return "D(%s)" % `self.__dict__`
</t>
<t tx="ekr.20040104185913.2026">def d(**kw): return kw
</t>
<t tx="ekr.20040104185913.2027">class DTMLTests (unittest.TestCase):
	&lt;&lt; class DTMLTests declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2028">doc_class = HTML

</t>
<t tx="ekr.20040104185913.2029">def testBatchingEtc(self):

    def item(key,**kw): return (key,kw)
    def item2(key,**kw): return kw

    class item_class:
        def __init__(self,key,**kw):
            for k in kw.keys(): self.__dict__[k]=kw[k]

    items=(
        item( 1,dealer='Bay Chevy', make='Chevrolet',
              model='Caprice', year=96),
        item( 2,dealer='Bay Chevy', make='Chevrolet',
              model='Nova', year=96),
        item( 4,dealer='Bay Chevy', make='Chevrolet',
              model='Nova', year=96),
        item( 5,dealer='Bay Chevy', make='Chevrolet',
              model='Nova', year=96),
        item( 3,dealer='Bay Chevy', make='Chevrolet',
              model='Corvett', year=96),
        item( 6,dealer='Bay Chevy', make='Chevrolet',
              model='Lumina', year=96),
        item( 7,dealer='Bay Chevy', make='Chevrolet',
              model='Lumina', year=96),
        item( 8,dealer='Bay Chevy', make='Chevrolet',
              model='Lumina', year=95),
        item( 9,dealer='Bay Chevy', make='Chevrolet',
              model='Corsica', year=96),
        item(10,dealer='Bay Chevy', make='Chevrolet',
             model='Corsica', year=96),
        item(11,dealer='Bay Chevy', make='Toyota',
             model='Camry', year=95),
        item(12,dealer='Colman Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Colman Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Colman Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Colman Olds', make='Olds',
             model='Cutlass', year=96),
        item(12,dealer='Colman Olds', make='Olds',
             model='Cutlas', year=95),
        item(12,dealer='Colman Olds', make='Dodge',
             model='Shadow', year=93),
        item(12,dealer='Colman Olds', make='Jeep',
             model='Cheroke', year=94),
        item(12,dealer='Colman Olds', make='Toyota',
             model='Previa', year=92),
        item(12,dealer='Colman Olds', make='Toyota',
             model='Celica', year=93),
        item(12,dealer='Colman Olds', make='Toyota',
             model='Camry', year=93),
        item(12,dealer='Colman Olds', make='Honda',
             model='Accord', year=94),
        item(12,dealer='Colman Olds', make='Honda',
             model='Accord', year=92),
        item(12,dealer='Colman Olds', make='Honda',
             model='Civic', year=94),
        item(12,dealer='Colman Olds', make='Honda',
             model='Civix', year=93),
        item( 1,dealer='Spam Chev', make='Chevrolet',
              model='Caprice', year=96),
        item( 2,dealer='Spam Chev', make='Chevrolet',
              model='Nova', year=96),
        item( 4,dealer='Spam Chev', make='Chevrolet',
              model='Nova', year=96),
        item( 5,dealer='Spam Chev', make='Chevrolet',
              model='Nova', year=96),
        item( 3,dealer='Spam Chev', make='Chevrolet',
              model='Corvett', year=96),
        item( 6,dealer='Spam Chev', make='Chevrolet',
              model='Lumina', year=96),
        item( 7,dealer='Spam Chev', make='Chevrolet',
              model='Lumina', year=96),
        item( 8,dealer='Spam Chev', make='Chevrolet',
              model='Lumina', year=95),
        item( 9,dealer='Spam Chev', make='Chevrolet',
              model='Corsica', year=96),
        item(10,dealer='Spam Chev', make='Chevrolet',
             model='Corsica', year=96),
        item(11,dealer='Spam Chevy', make='Toyota',
             model='Camry', year=95),
        item(12,dealer='Spam Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Spam Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Spam Olds', make='Olds',
             model='Ciera', year=96),
        item(12,dealer='Spam Olds', make='Olds',
             model='Cutlass', year=96),
        item(12,dealer='Spam Olds', make='Olds',
             model='Cutlas', year=95),
        item(12,dealer='Spam Olds', make='Dodge',
             model='Shadow', year=93),
        item(12,dealer='Spam Olds', make='Jeep',
             model='Cheroke', year=94),
        item(12,dealer='Spam Olds', make='Toyota',
             model='Previa', year=92),
        item(12,dealer='Spam Olds', make='Toyota',
             model='Celica', year=93),
        item(12,dealer='Spam Olds', make='Toyota',
             model='Camry', year=93),
        item(12,dealer='Spam Olds', make='Honda',
             model='Accord', year=94),
        item(12,dealer='Spam Olds', make='Honda',
             model='Accord', year=92),
        item(12,dealer='Spam Olds', make='Honda',
             model='Civic', year=94),
        item(12,dealer='Spam Olds', make='Honda',
             model='Civix', year=93),
        )

    html=self.doc_class(read_file('dealers.dtml'))
    res = html(inventory=items, first_ad=15)
    expected = read_file('dealers.out')
    self.assertEqual(res,expected)
</t>
<t tx="ekr.20040104185913.2030">def testSequenceSummaries(self):
    def d(**kw): return kw
    data=(d(name='jim', age=38),
          # d(name='kak', age=40),
          d(name='will', age=7),
          d(name='drew', age=4),
          d(name='ches', age=1),
          )
    html = self.doc_class('&lt;dtml-in data mapping&gt;'
                '&lt;dtml-if sequence-end&gt;'
                'Variable "name": '
                'min=&lt;dtml-var min-name&gt; '
                'max=&lt;dtml-var max-name&gt; '
                'count=&lt;dtml-var count-name&gt; '
                'total=&lt;dtml-var total-name&gt; '
                'median=&lt;dtml-var median-name&gt; '
                'Variable "age": '
                'min=&lt;dtml-var min-age&gt; '
                'max=&lt;dtml-var max-age&gt; '
                'count=&lt;dtml-var count-age&gt; '
                'total=&lt;dtml-var total-age&gt; '
                'median=&lt;dtml-var median-age&gt; '
                'mean=&lt;dtml-var mean-age&gt; '
                '&lt;dtml-let sda=standard-deviation-age&gt;'
                's.d.=&lt;dtml-var expr="_.int(sda)"&gt;'
                '&lt;/dtml-let&gt;'
                '&lt;/dtml-if sequence-end&gt;'
                '&lt;/dtml-in data&gt;')
    res = html(data=data)
    expected = ('Variable "name": min=ches max=will count=4 total= '
                'median=between jim and drew '
                'Variable "age": min=1 max=38 count=4 total=50 '
                'median=5 mean=12.5 s.d.=17')
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2031">def testDTMLDateFormatting(self):
    import DateTime
    html = self.doc_class(
    "&lt;dtml-var name capitalize spacify&gt; is "
    "&lt;dtml-var date fmt=year&gt;/&lt;dtml-var date "
                "fmt=month&gt;/&lt;dtml-var date fmt=day&gt;")
    res = html(date=DateTime.DateTime("1995-12-25"),
               name='christmas_day')
    expected = 'Christmas day is 1995/12/25'
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2032">def testSimpleString(self):
    dt = String('%(name)s')
    res = dt(name='Chris')
    expected = 'Chris'
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2033">def testStringDateFormatting(self):
    import DateTime
    html = String("%(name capitalize spacify)s is "
                  "%(date fmt=year)s/%(date fmt=month)s/%(date fmt=day)s")
    res = html(date=DateTime.DateTime("2001-04-27"),
               name='the_date')
    expected = 'The date is 2001/4/27'
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2034">def testSequence1(self):
    html=self.doc_class(
        '&lt;dtml-in spam&gt;&lt;dtml-in sequence-item&gt;&lt;dtml-var sequence-item&gt; '
        '&lt;/dtml-in sequence-item&gt;&lt;/dtml-in spam&gt;')
    expected = '1 2 3 4 5 6 '
    res = html(spam=[[1,2,3],[4,5,6]])
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2035">def testSequence2(self):
    html=self.doc_class(
        '&lt;dtml-in spam&gt;&lt;dtml-in sequence-item&gt;&lt;dtml-var sequence-item&gt;-'
        '&lt;/dtml-in sequence-item&gt;&lt;/dtml-in spam&gt;')
    expected = '1-2-3-4-5-6-'
    res = html(spam=[[1,2,3],[4,5,6]])
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2036">def testNull(self):
    html=self.doc_class('&lt;dtml-var spam fmt="$%.2f bobs your uncle" '
              'null="spam%eggs!|"&gt;')
    expected = '$42.00 bobs your unclespam%eggs!|'
    res = html(spam=42) + html(spam=None)
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2037">def testUrlUnquote(self):
    html1 = self.doc_class(
        """
        &lt;dtml-var expr="'http%3A//www.zope.org%3Fa%3Db%20123'" fmt=url-unquote&gt;
        """
        )
    html2 = self.doc_class(
        """
        &lt;dtml-var expr="'http%3A%2F%2Fwww.zope.org%3Fa%3Db+123'" fmt=url-unquote-plus&gt;
        """
        )

    expected = (
        """
        http://www.zope.org?a=b 123
        """
        )
    self.assertEqual(html1(), expected)
    self.assertEqual(html2(), expected)
    html1 = self.doc_class(
        """
        &lt;dtml-var expr="'http%3A//www.zope.org%3Fa%3Db%20123'" url_unquote&gt;
        """
        )
    html2 = self.doc_class(
        """
        &lt;dtml-var expr="'http%3A%2F%2Fwww.zope.org%3Fa%3Db+123'" url_unquote_plus&gt;
        """
        )

    expected = (
        """
        http://www.zope.org?a=b 123
        """
        )
    self.assertEqual(html1(), expected)
    self.assertEqual(html2(), expected)
</t>
<t tx="ekr.20040104185913.2038">def test_fmt(self):
    html=self.doc_class(
        """
        &lt;dtml-var spam&gt;
        html=&lt;dtml-var spam fmt=html-quote&gt;
        url=&lt;dtml-var spam fmt=url-quote&gt;
        multi=&lt;dtml-var spam fmt=multi-line&gt;
        dollars=&lt;dtml-var spam fmt=whole-dollars&gt;
        cents=&lt;dtml-var spam fmt=dollars-and-cents&gt;
        dollars,=&lt;dtml-var spam fmt=dollars-with-commas&gt;
        cents,=&lt;dtml-var spam fmt=dollars-and-cents-with-commas&gt;""")

    expected = (
        '''
        4200000
        html=4200000
        url=4200000
        multi=4200000
        dollars=$4200000
        cents=$4200000.00
        dollars,=$4,200,000
        cents,=$4,200,000.00
        None
        html=None
        url=None
        multi=None
        dollars=
        cents=
        dollars,=
        cents,=
        &lt;a href="spam"&gt;
foo bar
        html=&amp;lt;a href=&amp;quot;spam&amp;quot;&amp;gt;
foo bar
        url=%3Ca%20href%3D%22spam%22%3E%0Afoo%20bar
        multi=&lt;a href="spam"&gt;&lt;br /&gt;
foo bar
        dollars=
        cents=
        dollars,=
        cents,=''')

    res = html(spam=4200000) + html(spam=None) + html(
        spam='&lt;a href="spam"&gt;\nfoo bar')
    self.assertEqual(res,expected)
</t>
<t tx="ekr.20040104185913.2039">def testPropogatedError(self):

    class foo:
        def __len__(self): return 9
        def __getitem__(self,i):
            if i &gt;= 9: raise IndexError, i
            return self.testob(i)

        class testob (Base):
            __roles__ = None  # Public
            def __init__(self, index):
                self.index = index
                self.value = 'item %s' % index

            getValue__roles__ = None  # Public
            def getValue(self):
                return self.value

            puke__roles__ = None  # Public
            def puke(self):
                raise 'Puke', 'raaalf'

    html=self.doc_class(
        """
        &lt;dtml-if spam&gt;
        &lt;dtml-in spam&gt;
        &lt;dtml-var getValue&gt;
        &lt;dtml-var puke&gt;
        &lt;/dtml-in spam&gt;
        &lt;/dtml-if spam&gt;
        """)
    try:
        html(spam=foo())
    except 'Puke':
        # Passed the test.
        pass
    else:
        assert 0, 'Puke error not propogated'
</t>
<t tx="ekr.20040104185913.2040">def testRenderCallable(self):
    "Test automatic rendering of callable objects"
    class C (Base):
        __allow_access_to_unprotected_subobjects__ = 1
        x=1
        def y(self): return self.x*2
    C.h = self.doc_class("The h method, &lt;dtml-var x&gt; &lt;dtml-var y&gt;")
    C.h2 = self.doc_class("The h2 method")

    expected = "1, 2, The h method, 1 2"
    res = self.doc_class("&lt;dtml-var x&gt;, &lt;dtml-var y&gt;, &lt;dtml-var h&gt;")(C())
    assert res == expected, res

    expected = (
        '''
        1,
        2,
        The h2 method''')
    res = self.doc_class(
        '''
        &lt;dtml-var expr="_.render(i.x)"&gt;,
        &lt;dtml-var expr="_.render(i.y)"&gt;,
        &lt;dtml-var expr="_.render(i.h2)"&gt;''')(i=C())
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2041">def testWith(self):
    class person:
        __allow_access_to_unprotected_subobjects__ = 1
        name='Jim'
        height_inches=73

    expected = 'Hi, my name is %s and my height is %d cm.' % (
        person.name, int(person.height_inches * 2.54))

    res = self.doc_class(
        '&lt;dtml-with person&gt;Hi, my name is &lt;dtml-var name&gt; '
        'and my height is &lt;dtml-var "_.int(height_inches*2.54)"&gt; '
        'cm.&lt;/dtml-with&gt;')(person=person)
    assert res == expected, res
</t>
<t tx="ekr.20040104185913.2042">def testRaise(self):
    try:
        res = self.doc_class(
        "&lt;dtml-raise IndexError&gt;success!&lt;/dtml-raise&gt;")()
    except IndexError, v:
        res = v
    assert str(res) == 'success!', `res`
</t>
<t tx="ekr.20040104185913.2043">def testNoItemPush(self):
    data=d(sec='B', name='XXX', sub=(d(name='b1'),d(name='b2',sec='XXX')))
    html = """
&lt;dtml-with data mapping&gt;&lt;dtml-in sub no_push_item&gt;
&lt;dtml-var sec&gt;.&lt;dtml-with sequence-item mapping&gt;&lt;dtml-var name&gt;&lt;/dtml-with&gt;
&lt;/dtml-in&gt;&lt;/dtml-with&gt;
"""
    expected = """
B.b1    B.b2"""
    result = self.doc_class(html)(data=data)
    assert result == expected, result
</t>
<t tx="ekr.20040104185913.2044">def testBasicHTMLIn(self):
    data=(
        d(name='jim', age=39),
        d(name='kak', age=29),
        d(name='will', age=8),
        d(name='andrew', age=5),
        d(name='chessie',age=2),
        )

    html="""
&lt;!--#in data mapping--&gt;
&lt;!--#var name--&gt;, &lt;!--#var age--&gt;
&lt;!--#/in--&gt;
"""
    expected = """
jim, 39
kak, 29
will, 8
andrew, 5
chessie, 2
"""
    result = self.doc_class(html)(data=data)
    assert result == expected, result
</t>
<t tx="ekr.20040104185913.2045">def testBasicHTMLIn2(self):
    xxx=(D(name=1), D(name=2), D(name=3))
    html = """
&lt;!--#in xxx--&gt;
&lt;!--#var name  --&gt;
&lt;!--#/in--&gt;
"""
    expected = """
1
2
3
"""
    result = self.doc_class(html)(xxx=xxx)
    assert result == expected, result
</t>
<t tx="ekr.20040104185913.2046">def testBasicHTMLIn3(self):
    ns = {'prop_ids': ('title', 'id'), 'title': 'good', 'id': 'times'}
    html = """:&lt;dtml-in prop_ids&gt;&lt;dtml-var sequence-item&gt;=&lt;dtml-var
    expr="_[_['sequence-item']]"&gt;:&lt;/dtml-in&gt;"""
    result = self.doc_class(html)(None, ns)
    expected = ":title=good:id=times:"

    assert result == expected, result
</t>
<t tx="ekr.20040104185913.2047">def testHTMLInElse(self):
    xxx=(D(name=1), D(name=2), D(name=3))
    html="""
&lt;!--#in data mapping--&gt;
&lt;!--#var name--&gt;, &lt;!--#var age--&gt;
&lt;!--#else--&gt;
&lt;!--#in xxx--&gt;
&lt;!--#var name --&gt;
&lt;!--#/in--&gt;
&lt;!--#/in--&gt;
"""
    expected = """
1
2
3
"""
    result = self.doc_class(html)(xxx=xxx, data={})
    assert result == expected, result
</t>
<t tx="ekr.20040104185913.2048">def testBasicStringIn(self):
    data=(
        d(name='jim', age=39),
        d(name='kak', age=29),
        d(name='will', age=8),
        d(name='andrew', age=5),
        d(name='chessie',age=2),
        )
    s="""
%(in data mapping)[
%(name)s, %(age)s
%(in)]
"""
    expected = """
jim, 39
kak, 29
will, 8
andrew, 5
chessie, 2
"""
    result = String(s)(data=data)
    assert expected == result, result
</t>
<t tx="ekr.20040104185913.2049">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( DTMLTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.2050">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2051">&lt;&lt; testDTMLUnicode declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.2052">&lt;&lt; copyright &gt;&gt;
"""Document Template Tests
"""

__rcs_id__='$Id: testDTMLUnicode.py,v 1.3.6.1 2002/09/16 10:10:26 htrd Exp $'
__version__='$Revision: 1.3.6.1 $'[11:-2]

import sys, os
import unittest

from DocumentTemplate.DT_HTML import HTML, String
from ExtensionClass import Base

</t>
<t tx="ekr.20040104185913.2053">class force_str:
	&lt;&lt; class force_str declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2054">    # A class whose string representation is not always a plain string:
</t>
<t tx="ekr.20040104185913.2055">def __init__(self,s):
    self.s = s
</t>
<t tx="ekr.20040104185913.2056">def __str__(self):
    return self.s
</t>
<t tx="ekr.20040104185913.2057">class DTMLUnicodeTests (unittest.TestCase):
	&lt;&lt; class DTMLUnicodeTests declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2058">doc_class = HTML

</t>
<t tx="ekr.20040104185913.2059">def testAA(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = 'helloworld'
    res = html(a='hello',b='world')
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2060">def testUU(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = u'helloworld'
    res = html(a=u'hello',b=u'world')
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2061">def testAU(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = u'helloworld'
    res = html(a='hello',b=u'world')
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2062">def testAB(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = 'hello\xc8'
    res = html(a='hello',b=chr(200))
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2063">def testUB(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = u'hello\xc8'
    res = html(a=u'hello',b=chr(200))
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2064">def testUB2(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = u'\u07d0\xc8'
    res = html(a=unichr(2000),b=chr(200))
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2065">def testUnicodeStr(self):
    html=self.doc_class('&lt;dtml-var a&gt;&lt;dtml-var b&gt;')
    expected = u'\u07d0\xc8'
    res = html(a=force_str(unichr(2000)),b=chr(200))
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2066">def testUqB(self):
    html=self.doc_class('&lt;dtml-var a html_quote&gt;&lt;dtml-var b&gt;')
    expected = u'he&amp;gt;llo\xc8'
    res = html(a=u'he&gt;llo',b=chr(200))
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2067">def testSize(self):
    html=self.doc_class('&lt;dtml-var "_.unichr(200)*4" size=2&gt;')
    expected = unichr(200)*2+'...'
    res = html()
    assert res == expected, `res`
</t>
<t tx="ekr.20040104185913.2068">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( DTMLUnicodeTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.2069">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2070">&lt;&lt; testustr declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.2071">&lt;&lt; copyright &gt;&gt;
"""Document Template Tests
"""

__rcs_id__='$Id: testustr.py,v 1.3 2002/08/14 22:29:53 mj Exp $'
__version__='$Revision: 1.3 $'[11:-2]

import sys, os
import unittest

from DocumentTemplate.ustr import ustr
from ExtensionClass import Base

</t>
<t tx="ekr.20040104185913.2072">class force_str:
	&lt;&lt; class force_str declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2073">    # A class whose string representation is not always a plain string:
</t>
<t tx="ekr.20040104185913.2074">def __init__(self,s):
    self.s = s
</t>
<t tx="ekr.20040104185913.2075">def __str__(self):
    return self.s
</t>
<t tx="ekr.20040104185913.2076">class UnicodeTests (unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2077">def testPlain(self):
    a = ustr('hello')
    assert a=='hello', `a`
    a = ustr(force_str('hello'))
    assert a=='hello', `a`
    a = ustr(chr(200))
    assert a==chr(200), `a`
    a = ustr(force_str(chr(200)))
    assert a==chr(200), `a`
    a = ustr(22)
    assert a=='22', `a`
    a = ustr([1,2,3])
    assert a=='[1, 2, 3]', `a`
</t>
<t tx="ekr.20040104185913.2078">def testUnicode(self):
    a = ustr(u'hello')
    assert a=='hello', `a`
    a = ustr(force_str(u'hello'))
    assert a=='hello', `a`
    a = ustr(unichr(200))
    assert a==unichr(200), `a`
    a = ustr(force_str(unichr(200)))
    assert a==unichr(200), `a`
</t>
<t tx="ekr.20040104185913.2079">def testExceptions(self):
    a = ustr(ValueError(unichr(200)))
    assert a==unichr(200), `a`
</t>
<t tx="ekr.20040104185913.2080">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( UnicodeTests ) )
    return suite
</t>
<t tx="ekr.20040104185913.2081">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2082"></t>
<t tx="ekr.20040104185913.2083">&lt;&lt; copyright &gt;&gt;

"""
API documentation help topics
"""

&lt;&lt; APIHelpTopic declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.2084">import types
import HelpTopic
from Globals import DTMLFile, Persistent

_ignore_objects = {}

try:
    import Interface
    _ignore_objects.update(Interface.__dict__)
except ImportError:
    pass

</t>
<t tx="ekr.20040104185913.2085">class APIHelpTopic(HelpTopic.HelpTopic):
    """
    Provides API documentation.
    """
	&lt;&lt; class APIHelpTopic declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2086">isAPIHelpTopic=1
funcs=() # for backward compatibility

</t>
<t tx="ekr.20040104185913.2087">def __init__(self, id, title, file):
    self.id=id
    self.title=title
    dict={}
    execfile(file, dict)
    self.doc=dict.get('__doc__','')

    self.apis=[]
    self.funcs=[]
    for k, v in dict.items():
        if (not _ignore_objects.has_key(k) or
            _ignore_objects[k] is not v):
            if type(v)==types.ClassType:
                # A class.
                self.apis.append(APIDoc(v, 0))
            elif (hasattr(v, 'isImplementedByInstancesOf')):
                # A scarecrow interface.
                self.apis.append(APIDoc(v, 1))
            elif type(v)==types.FunctionType:
                # A function
                self.funcs.append(MethodDoc(v, 0))
    # try to get title from first non-blank line
    # of module docstring
    if not self.title:
        lines=self.doc.split('\n')
        while 1:
            line=lines[0].strip()
            if line:
                # get rid of anything after a colon in the line
                self.title=line.split(':')[0]
                break
            lines.pop(0)
            if not lines:
                break
    # otherwise get title from first class name
    if not self.title:
        self.title=self.apis[0].name
</t>
<t tx="ekr.20040104185913.2088">index_html=DTMLFile('dtml/APIHelpView', globals())

def SearchableText(self):
    "The full text of the Help Topic, for indexing purposes"
    text="%s %s" % (self.title, self.doc)
    for api in self.apis + self.funcs:
        text="%s %s" % (text, api.SearchableText())
    return text
</t>
<t tx="ekr.20040104185913.2089">class APIDoc(Persistent):
    """
    Describes an API.
    """
	&lt;&lt; class APIDoc declarations &gt;&gt;
	@others

    view=DTMLFile('dtml/APIView', globals())</t>
<t tx="ekr.20040104185913.2090">extends=()

</t>
<t tx="ekr.20040104185913.2091">def __init__(self, klass, isInterface=0):
    if isInterface:
        self._createFromInterface(klass)
    else:
        self._createFromClass(klass)
</t>
<t tx="ekr.20040104185913.2092">def _createFromInterface(self, klass):
    # Creates an APIDoc instance given an interface object.
    self.name=klass.__name__
    self.doc=trim_doc_string(klass.__doc__)

    # inheritence information
    self.extends=[]
##        for base in klass.getBases():
##            names = string.split(base.__name__, '.')
##            url="%s/Help/%s.py#%s" % (names[0], names[1], names[2])
##            self.extends.append((names[2], url))

    # constructor information
##        if hasattr(klass, '__constructor__'):
##            self.constructor=MethodDoc(klass.__constructor__)

    # Get info on methods and attributes, ignore special items
    self.attributes=[]
    self.methods=[]
    from Interface.Method import Method
    for k,v in klass.namesAndDescriptions():
        if hasattr(v, 'getSignatureInfo'):
            self.methods.append(MethodDoc(v, 1))
        else:
            self.attributes.append(AttributeDoc(k, v.__doc__))
</t>
<t tx="ekr.20040104185913.2093">def _createFromClass(self, klass):
    # Creates an APIDoc instance given a python class.
    # the class describes the API; it contains
    # methods, arguments and doc strings.
    #
    # The name of the API is deduced from the name
    # of the class.
    #
    # The base APIs are deduced from the __extends__
    # attribute.

    self.name=klass.__name__
    self.doc=trim_doc_string(klass.__doc__)

    # inheritence information
    if hasattr(klass,'__extends__'):
        self.extends=[]
        for base in klass.__extends__:
            names=base.split( '.')
            url="%s/Help/%s.py#%s" % (names[0], names[1], names[2])
            self.extends.append((names[2], url))

    # constructor information
    if hasattr(klass, '__constructor__'):
        self.constructor=MethodDoc(klass.__constructor__)

    # Get info on methods and attributes, ignore special items
    self.attributes=[]
    self.methods=[]
    for k,v in klass.__dict__.items():
        if k not in ('__extends__', '__doc__', '__constructor__'):
            if type(v)==types.FunctionType:
                self.methods.append(MethodDoc(v, 0))
            else:
                self.attributes.append(AttributeDoc(k, v))
</t>
<t tx="ekr.20040104185913.2094">def SearchableText(self):
    """
    The full text of the API, for indexing purposes.
    """
    text="%s %s" % (self.name, self.doc)
    for attribute in self.attributes:
        text="%s %s" % (text, attribute.name)
    for method in self.methods:
        text="%s %s %s" % (text, method.name, method.doc)
    return text
</t>
<t tx="ekr.20040104185913.2095">class AttributeDoc(Persistent):
    """
    Describes an attribute of an API.
    """
	@others

    view=DTMLFile('dtml/attributeView', globals())</t>
<t tx="ekr.20040104185913.2096">def __init__(self, name, value):
    self.name=name
    self.value=value
</t>
<t tx="ekr.20040104185913.2097">class MethodDoc(Persistent):
    """
    Describes a method of an API.

    required - a sequence of required arguments
    optional - a sequence of tuples (name, default value)
    varargs - the name of the variable argument or None
    kwargs - the name of the kw argument or None
    """
	&lt;&lt; class MethodDoc declarations &gt;&gt;
	@others

    view=DTMLFile('dtml/methodView', globals())</t>
<t tx="ekr.20040104185913.2098">varargs=None
kwargs=None

</t>
<t tx="ekr.20040104185913.2099">def __init__(self, func, isInterface=0):
    if isInterface:
        self._createFromInterfaceMethod(func)
    else:
        self._createFromFunc(func)
</t>
<t tx="ekr.20040104185913.2100">def _createFromInterfaceMethod(self, func):
    self.name = func.__name__
    self.doc = trim_doc_string(func.__doc__)
    self.required = func.required
    opt = []
    for p in func.positional[len(func.required):]:
        opt.append((p, func.optional[p]))
    self.optional = tuple(opt)
    if func.varargs:
        self.varargs = func.varargs
    if func.kwargs:
        self.kwargs = func.kwargs
</t>
<t tx="ekr.20040104185913.2101">def _createFromFunc(self, func):
    if hasattr(func, 'im_func'):
        func=func.im_func

    self.name=func.__name__
    self.doc=trim_doc_string(func.__doc__)

    # figure out the method arguments
    # mostly stolen from pythondoc
    CO_VARARGS = 4
    CO_VARKEYWORDS = 8
    names = func.func_code.co_varnames
    nrargs = func.func_code.co_argcount
    if func.func_defaults:
        nrdefaults = len(func.func_defaults)
    else:
        nrdefaults = 0
    self.required = names[:nrargs-nrdefaults]
    if func.func_defaults:
        self.optional = tuple(map(None, names[nrargs-nrdefaults:nrargs],
                             func.func_defaults))
    else:
        self.optional = ()
    varargs = []
    ix = nrargs
    if func.func_code.co_flags &amp; CO_VARARGS:
        self.varargs=names[ix]
        ix = ix+1
    if func.func_code.co_flags &amp; CO_VARKEYWORDS:
        self.kwargs=names[ix]
</t>
<t tx="ekr.20040104185913.2102">def trim_doc_string(text):
    """
    Trims a doc string to make it format
    correctly with structured text.
    """
    text=text.strip()
    text=text.replace( '\r\n', '\n')
    lines=text.split('\n')
    nlines=[lines[0]]
    if len(lines) &gt; 1:
        min_indent=None
        for line in lines[1:]:
            if not line:
                continue
            indent=len(line) - len(line.lstrip())
            if indent &lt; min_indent or min_indent is None:
                min_indent=indent
        for line in lines[1:]:
            nlines.append(line[min_indent:])
    return '\n'.join(nlines)
</t>
<t tx="ekr.20040104185913.2103">&lt;&lt; copyright &gt;&gt;

&lt;&lt; HelpSys imports &gt;&gt;

@others</t>
<t tx="ekr.20040104185913.2104">import Acquisition
from OFS.SimpleItem import Item
from OFS.ObjectManager import ObjectManager
from Globals import Persistent, DTMLFile, HTML
from Products.ZCatalog.ZCatalog import ZCatalog
from Products.ZCatalog.Lazy import LazyCat
import Products
import HelpTopic
import Globals

</t>
<t tx="ekr.20040104185913.2105">class HelpSys(Acquisition.Implicit, ObjectManager, Item, Persistent):
    """
    Zope Help System

    Provides browsing and searching of Zope Product Help.
    """
	&lt;&lt; class HelpSys declarations &gt;&gt;
	@others

Globals.default__class_init__(HelpSys)</t>
<t tx="ekr.20040104185913.2106">meta_type='Help System'

manage_options=(
    {'label' : 'Contents', 'action' : 'menu'},
    {'label' : 'Search', 'action' : 'search'},
)

__ac_permissions__=(
    ('View',
     ('__call__', 'searchResults', 'HelpButton', '',
      'index_html', 'menu', 'search', 'results', 'main',
      'helpLink')),
    ('Access contents information', ('helpValues',)),
    )

</t>
<t tx="ekr.20040104185913.2107">def __init__(self, id='HelpSys'):
    self.id=id
</t>
<t tx="ekr.20040104185913.2108">def helpValues(self, spec=None):
    "ProductHelp objects of all Products that have help"
    hv=[]
    for product in self.Control_Panel.Products.objectValues():
        productHelp=product.getProductHelp()
        # only list products that actually have help
        if productHelp.helpValues():
            hv.append(productHelp)
    return hv
</t>
<t tx="ekr.20040104185913.2109"># Seaching does an aggregated search of all ProductHelp
# objects. Only Help Topics for which the user has permissions
# are returned.
def __call__(self, REQUEST=None, **kw):
    "Searchable interface"
    if REQUEST is not None:
        perms=[]
        user=REQUEST.AUTHENTICATED_USER
        for p in self.ac_inherited_permissions():
            if user.has_permission(p[0], self):
                perms.append(p[0])
        REQUEST.set('permissions',perms)
    results=[]
    for ph in self.helpValues():
        results.append(apply(getattr(ph, '__call__'), (REQUEST,) , kw))
    return LazyCat(results)
</t>
<t tx="ekr.20040104185913.2110">searchResults=__call__

index_html=DTMLFile('dtml/frame', globals())
menu=DTMLFile('dtml/menu', globals())
search=DTMLFile('dtml/search', globals())
results=DTMLFile('dtml/results', globals())
main=HTML("""&lt;html&gt;&lt;/html&gt;""")
standard_html_header=DTMLFile('dtml/menu_header', globals())
standard_html_footer=DTMLFile('dtml/menu_footer', globals())

button=DTMLFile('dtml/button', globals())

def HelpButton(self, topic, product):
    """
    Insert a help button linked to a help topic.
    """
    return self.button(self, self.REQUEST, product=product, topic=topic)
</t>
<t tx="ekr.20040104185913.2111">helpURL=DTMLFile('dtml/helpURL',globals())

def helpLink(self, product='OFSP', topic='ObjectManager_Contents.stx'):
    # Generate an &lt;a href...&gt; tag linking to a help topic. This
    # is a little lighter weight than the help button approach.
    basepath=self.REQUEST['BASEPATH1']
    help_url='%s/Control_Panel/Products/%s/Help/%s' % (
        basepath,
        product,
        topic
        )
    help_url='%s?help_url=%s' % (self.absolute_url(), help_url)

    script='window.open(\'%s\',\'zope_help\',\'width=600,' \
            'height=500,menubar=yes,toolbar=yes,scrollbars=yes,' \
            'resizable=yes\'); return false;' % help_url

    h_link='&lt;a href="%s" onClick="%s" onMouseOver="window.status=' \
           '\'Open online help\'; return true;" onMouseOut="' \
           'window.status=\'\'; return true;"&gt;Help!&lt;/a&gt;' % (
           help_url, script
           )

    return h_link
</t>
<t tx="ekr.20040104185913.2112">def tpValues(self):
    """
    Tree protocol - returns child nodes

    Aggregates Product Helps with the same title.
    """
    helps={}
    for help in self.helpValues():
        if helps.has_key(help.title):
            helps[help.title].append(help)
        else:
            helps[help.title]=[help]
    cols=[]
    for k,v in helps.items():
        cols.append(TreeCollection(k,v,0))
    return cols
</t>
<t tx="ekr.20040104185913.2113">class TreeCollection:
    """
    A temporary wrapper for a collection of objects
    objects, used for help topic browsing to make a collection
    of objects appear as a single object.
    """
	@others
</t>
<t tx="ekr.20040104185913.2114">def __init__(self, id, objs, simple=1):
    self.id=self.title=id
    self.objs=objs
    self.simple=simple
</t>
<t tx="ekr.20040104185913.2115">def tpValues(self):
    values=[]
    if self.simple:
        values=self.objs
    else:
        for obj in self.objs:
            values=values + list(obj.tpValues())
    # resolve overlap
    ids={}
    for value in values:
        if ids.has_key(value.id):
            ids[value.id].append(value)
        else:
            ids[value.id]=[value]
    results=[]
    for k,v in ids.items():
        if len(v)==1:
            results.append(v[0])
        else:
            values=[]
            for topic in v:
                values=values + list(topic.tpValues())
            results.append(TreeCollection(k, values))
    results.sort(lambda x, y: cmp(x.id, y.id))
    return results
</t>
<t tx="ekr.20040104185913.2116">def tpId(self):
    return self.id
</t>
<t tx="ekr.20040104185913.2117">class ProductHelp(Acquisition.Implicit, ObjectManager, Item, Persistent):
    """
    Manages a collection of Help Topics for a given Product.

    Provides searching services to HelpSystem.
    """
	&lt;&lt; class ProductHelp declarations &gt;&gt;
	@others

    standard_html_header=DTMLFile('dtml/topic_header', globals())
    standard_html_footer=DTMLFile('dtml/topic_footer', globals())
	
Globals.default__class_init__(ProductHelp)
</t>
<t tx="ekr.20040104185913.2118">meta_type='Product Help'
icon='p_/ProductHelp_icon'

lastRegistered=None

meta_types=({'name':'Help Topic',
             'action':'addTopicForm',
             'permission':'Add Documents, Images, and Files'},
            )

manage_options=(
    ObjectManager.manage_options +
    Item.manage_options
    )

__ac_permissions__=(
    ('Add Documents, Images, and Files', ('addTopicForm', 'addTopic')),
    )

</t>
<t tx="ekr.20040104185913.2119">def __init__(self, id='Help', title=''):
    self.id=id
    self.title=title
    c=self.catalog=ZCatalog('catalog')
    # clear catalog
    for index in c.indexes():
        c.delIndex(index)
    for col in c.schema():
        c.delColumn(col)
    c.addIndex('SearchableText', 'TextIndex')
    c.addIndex('categories', 'KeywordIndex')
    c.addIndex('permissions', 'KeywordIndex')
    c.addColumn('categories')
    c.addColumn('permissions')
    c.addColumn('title_or_id')
    c.addColumn('url')
    c.addColumn('id')
</t>
<t tx="ekr.20040104185913.2120">addTopicForm=DTMLFile('dtml/addTopic', globals())

def addTopic(self, id, title, REQUEST=None):
    "Add a Help Topic"
    topic=HelpTopic.DTMLDocumentTopic(
        HelpTopic.default_topic_content, __name__=id)
    topic.title=title
    self._setObject(id, topic)
    if REQUEST is not None:
        return self.manage_main(self, REQUEST,
                                manage_tabs_message='Help Topic added.')
</t>
<t tx="ekr.20040104185913.2121">def helpValues(self, REQUEST=None):
    """
    Lists contained Help Topics.
    Help Topics for which the user is not authorized
    are not listed.
    """
    topics=self.objectValues('Help Topic')
    if REQUEST is None:
        return topics
    return filter(
        lambda ht, u=REQUEST.AUTHENTICATED_USER: ht.authorized(u), topics)
</t>
<t tx="ekr.20040104185913.2122">def tpValues(self):
    """
    Tree protocol - child nodes
    """
    topics=[]
    apitopics=[]
    dtmltopics=[]
    zpttopics=[]
    for topic in self.objectValues('Help Topic'):
        if hasattr(topic,'isAPIHelpTopic') and topic.isAPIHelpTopic:
            apitopics.append(topic)
        else:
            if callable(topic.id):
                id=topic.id()
            else:
                id=topic.id
            if id[:5]=='dtml-':
                dtmltopics.append(topic)
            if (id[:5] in ('metal', 'tales') and id[5] in ('.', '-')) or \
               (id[:3]=='tal' and id[3] in ('.', '-')):
                zpttopics.append(topic)
            else:
                topics.append(topic)
    if dtmltopics:
        topics = topics + [TreeCollection(' DTML Reference', dtmltopics)]
    if apitopics:
        topics = topics + [TreeCollection(' API Reference', apitopics)]
    if zpttopics:
        topics = topics + [TreeCollection(' ZPT Reference', zpttopics)]
    return topics
</t>
<t tx="ekr.20040104185913.2123">def all_meta_types(self):
    f=lambda x: x['name'] in ('Image', 'File')
    return filter(f, Products.meta_types) + self.meta_types
</t>
<t tx="ekr.20040104185913.2124">def __call__(self, *args, **kw):
    """
    Searchable interface
    """
    return apply(self.catalog.__call__, args, kw)
</t>
<t tx="ekr.20040104185913.2125">&lt;&lt; copyright &gt;&gt;

&lt;&lt; HelpTopic imports &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.2126">import Acquisition
from ComputedAttribute import ComputedAttribute
from OFS.SimpleItem import Item
from Globals import Persistent, HTML, DTMLFile, ImageFile
from OFS.DTMLDocument import DTMLDocument
from OFS.PropertyManager import PropertyManager
import os.path
import Globals

</t>
<t tx="ekr.20040104185913.2127">class HelpTopicBase:
	&lt;&lt; class HelpTopicBase declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2128">"Mix-in Help Topic support class"

_properties=(
    {'id':'title', 'type':'string', 'mode':'w'},
    {'id':'categories', 'type':'multiple selection',
     'select_variable':'categories_values', 'mode':'w'},
    {'id':'permissions', 'type':'multiple selection',
     'select_variable':'permissions_values', 'mode':'w'},
    )

# default values
categories=('Content Manager Information',)
permissions=('View',)

</t>
<t tx="ekr.20040104185913.2129">def _permissions_values(self):
    perms=[]
    for m in self.permission_settings():
        perms.append(m['name'])
    return perms
</t>
<t tx="ekr.20040104185913.2130">permissions_values=ComputedAttribute(_permissions_values, 1)

categories_values=(
    'Content Manager Information',
    'DTML Programmer Information',
    'Python Programmer Information',
    )

def helpValues(self, REQUEST=None):
    return ()
</t>
<t tx="ekr.20040104185913.2131">def authorized(self, user):
    "Is a given user authorized to view this Help Topic?"
    if not self.permissions:
        return 1
    for perm in self.permissions:
        if user.has_permission(perm, self):
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.2132"># Indexable methods
# -----------------

def SearchableText(self):
    "The full text of the Help Topic, for indexing purposes"
    raise "Unimplemented"
</t>
<t tx="ekr.20040104185913.2133">def url(self):
    "URL for indexing purposes"
    return '/'.join(self.getPhysicalPath())
</t>
<t tx="ekr.20040104185913.2134"># Private indexing methods
# ------------------------

def manage_afterAdd(self, item, container):
    self.index_object()
</t>
<t tx="ekr.20040104185913.2135">def manage_afterClone(self, item):
    self.index_object()
</t>
<t tx="ekr.20040104185913.2136">def manage_beforeDelete(self, item, container):
    self.unindex_object()
</t>
<t tx="ekr.20040104185913.2137">def _setPropValue(self, id, value):
    setattr(self,id,value)
    self.reindex_object()
</t>
<t tx="ekr.20040104185913.2138">def index_object(self, prefix=''):
    self.get_catalog().catalog_object(self, prefix + self.url())
</t>
<t tx="ekr.20040104185913.2139">def unindex_object(self, prefix=''):
    self.get_catalog().uncatalog_object(prefix + self.url())
</t>
<t tx="ekr.20040104185913.2140">def reindex_object(self):
    self.unindex_object()
    self.index_object()
</t>
<t tx="ekr.20040104185913.2141">def get_catalog(self):
    return self.catalog
</t>
<t tx="ekr.20040104185913.2142">class HelpTopic(Acquisition.Implicit, HelpTopicBase, Item, PropertyManager, Persistent):
    """
    Abstract base class for Help Topics
    """
	&lt;&lt; class HelpTopic declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2143">meta_type='Help Topic'
icon='p_/HelpTopic_icon'
_v_last_read = 0

manage_options=(
    {'label':'Properties', 'action':'manage_propertiesForm'},
    {'label':'View', 'action':'index_html'},
    )

__ac_permissions__=(
    ('View', ('index_html', 'SearchableText', 'url')),
    ('Access contents information', ('helpValues',)),
    )

</t>
<t tx="ekr.20040104185913.2144">def _set_last_read(self, filepath):
    try:    mtime = os.stat(filepath)[8]
    except: mtime = 0
    self._v_last_read = mtime
</t>
<t tx="ekr.20040104185913.2145">def _check_for_update(self):
    if Globals.DevelopmentMode:
        try:    mtime=os.stat(self.file)[8]
        except: mtime=0
        if mtime != self._v_last_read:
            fileob = open(self.file)
            self.obj = fileob.read()
            fileob.close()
            self._v_last_read=mtime
            self.reindex_object()
</t>
<t tx="ekr.20040104185913.2146">def index_html(self, REQUEST, RESPONSE):
    "View the Help Topic"
    raise "Unimplemented"
</t>
<t tx="ekr.20040104185913.2147">class DTMLDocumentTopic(HelpTopicBase, DTMLDocument):
    """
    A user addable Help Topic based on DTML Document.
    """
	&lt;&lt; class DTMLDocumentTopic declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2148">meta_type='Help Topic'
icon='p_/HelpTopic_icon'

</t>
<t tx="ekr.20040104185913.2149">def munge(self,*args, **kw):
    apply(DTMLDocument.munge, (self,) + args, kw)
    self.reindex_object()
</t>
<t tx="ekr.20040104185913.2150">def SearchableText(self):
    return '%s %s' % (self.title, self.read())
</t>
<t tx="ekr.20040104185913.2151">default_topic_content="""\
&lt;dtml-var standard_html_header&gt;
&lt;h2&gt;&lt;dtml-var title&gt;&lt;/h2&gt;
&lt;p&gt;This is the &lt;dtml-var id&gt; Help Topic.&lt;/p&gt;
&lt;dtml-var standard_html_footer&gt;
"""

class DTMLTopic(HelpTopic):
    """
    A basic Help Topic. Holds a HTMLFile object.
    """
	@others
</t>
<t tx="ekr.20040104185913.2152">def __init__(self, id, title, file, permissions=None, categories=None):
    self.id=id
    self.title=title
    file,ext=os.path.splitext(file)
    prefix,file=os.path.split(file)
    self.index_html=DTMLFile(file,prefix)
    if permissions is not None:
        self.permissions=permissions
    if categories is not None:
        self.categories=categories
</t>
<t tx="ekr.20040104185913.2153">def SearchableText(self):
    "The full text of the Help Topic, for indexing purposes"
    return '%s %s' % (self.title, self.index_html.read())
</t>
<t tx="ekr.20040104185913.2154">class TextTopic(HelpTopic):
    """
    A basic Help Topic. Holds a text file.
    """
	&lt;&lt; class TextTopic declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2155">index_html = None
</t>
<t tx="ekr.20040104185913.2156">def __init__(self, id, title, file, permissions=None, categories=None):
    self.id=id
    self.title=title
    self.file = file
    self.obj=open(file).read()
    self._set_last_read(file)
    if permissions is not None:
        self.permissions=permissions
    if categories is not None:
        self.categories=categories
</t>
<t tx="ekr.20040104185913.2157">def __call__(self, REQUEST=None):
    "View the Help Topic"
    self._check_for_update()
    return self.obj
</t>
<t tx="ekr.20040104185913.2158">def SearchableText(self):
    "The full text of the Help Topic, for indexing purposes"
    return '%s %s' % (self.title, self.obj)
</t>
<t tx="ekr.20040104185913.2159">class STXTopic(TextTopic):
    """
    A structured-text topic. Holds a HTMLFile object.
    """
	&lt;&lt; class STXTopic declarations &gt;&gt;
	@others

    htmlfile = HTML("""\
&lt;dtml-var standard_html_header&gt;
&lt;dtml-var obj fmt="structured-text"&gt;
&lt;dtml-var standard_html_footer&gt;""")</t>
<t tx="ekr.20040104185913.2160">index_html = None

</t>
<t tx="ekr.20040104185913.2161">def __call__(self, REQUEST=None):
    """ View the STX Help Topic """
    self._check_for_update()
    return self.htmlfile(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2162">class ImageTopic(HelpTopic):
    """
    A image Help Topic. Holds an ImageFile object.
    """
	&lt;&lt; class ImageTopic declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2163">meta_type='Help Image'

</t>
<t tx="ekr.20040104185913.2164">def __init__(self, id, title, file, categories=None, permissions=None):
    self.id=id
    self.title=title
    self.file = file
    self.obj=open(file).read()
    self._set_last_read(file)
    dir, file=os.path.split(file)
    self.image=ImageFile(file, dir)
    if permissions is not None:
        self.permissions=permissions
    if categories is not None:
        self.categories=categories
</t>
<t tx="ekr.20040104185913.2165">def index_html(self, REQUEST, RESPONSE):
    "View the Help Topic"
    self._check_for_update()
    return self.image.index_html(REQUEST, RESPONSE)
</t>
<t tx="ekr.20040104185913.2166">def SearchableText(self):
    "The full text of the Help Topic, for indexing purposes"
    return ''
</t>
<t tx="ekr.20040104185913.2167">&lt;&lt; copyright &gt;&gt;

"""Help system support module"""

__version__='$Revision: 1.12 $'[11:-2]

import Globals, Acquisition
import StructuredText.StructuredText
import sys, os,  re

stx_class=StructuredText.StructuredText.HTML

@others
</t>
<t tx="ekr.20040104185913.2169">class HelpBase(Acquisition.Implicit):
    """ """
	@others
</t>
<t tx="ekr.20040104185913.2170">def __bobo_traverse__(self, REQUEST, name=None):
    # A sneaky trick - we cant really _have_ an index_html
    # because that would often hide the index_html of a
    # wrapped object ;(
    if name=='index_html':
        return self.hs_index
    return getattr(self, name)
</t>
<t tx="ekr.20040104185913.2171">def __len__(self):
    return 1
</t>
<t tx="ekr.20040104185913.2172">class object(Acquisition.Implicit):
	
	@others

    tpId   =get_name
    tpURL  =get_name
    __str__=get_name
</t>
<t tx="ekr.20040104185913.2173">def __init__(self, name, ob, op=None):
    self._name=name
    self._obj_=ob
    self._obp_=op
</t>
<t tx="ekr.20040104185913.2174">def __getattr__(self, name):
    return getattr(self.__dict__['_obj_'], name)
</t>
<t tx="ekr.20040104185913.2175">def __len__(self):
    return 1
</t>
<t tx="ekr.20040104185913.2176">def get_id(self):
    return id(self._obj_)
</t>
<t tx="ekr.20040104185913.2177">def get_name(self):
    return self._name
</t>
<t tx="ekr.20040104185913.2178">def get_type(self):
    return type(self._obj_).__name__
</t>
<t tx="ekr.20040104185913.2179">def get_value(self):
    return self._obj_
</t>
<t tx="ekr.20040104185913.2180">def get_docstring(self):
    if hasattr(self._obj_, '__doc__'):
        doc=self._obj_.__doc__
        if not doc: doc=''
        return doc
    return ''
</t>
<t tx="ekr.20040104185913.2181">def get_docstring_html(self):
    doc=self.get_docstring()
    if doc.find('\n\n') &gt; -1:
        doc=doc.split('\n\n')
        if len(doc) &gt; 1:
            doc[1]=doc[1].strip()
        doc='\n\n'.join(doc)

    return str(stx_class(doc))
</t>
<t tx="ekr.20040104185913.2182">def version(self):
    if hasattr(self._obj_, '__version__'):
        return self._obj_.__version__
</t>
<t tx="ekr.20040104185913.2183">class moduleobject(object):
	@others
</t>
<t tx="ekr.20040104185913.2184">def get_file(self):
    if hasattr(self._obj_, '__file__'):
        return self._obj_.__file__
</t>
<t tx="ekr.20040104185913.2185">def get_modules(self):
    data=[]
    for name, ob in self._obj_.__dict__.items():
        if is_module(ob) and _chModule(name, ob):
            data.append(moduleobject(name, ob, self))
    return data
</t>
<t tx="ekr.20040104185913.2186">def get_classes(self):
    data=[]
    for name, ob in self._obj_.__dict__.items():
        if is_class(ob) and _chClass(name, ob):
            data.append(classobject(name, ob, self))
    return data
</t>
<t tx="ekr.20040104185913.2187">class classobject(object):
	@others
</t>
<t tx="ekr.20040104185913.2188">def get_metatype(self):
    try: return self._obj_.meta_type
    except:
        t, v = sys.exc_info()[:2]
        return '%s %s' % (t, v)
</t>
<t tx="ekr.20040104185913.2189">def get_module(self):
    if hasattr(self._obj_, '__module__'):
        module=sys.modules[self._obj_.__module__]
        return moduleobject(module.__name__, module)
</t>
<t tx="ekr.20040104185913.2190">def get_file(self):
    return self.get_module().get_file()
</t>
<t tx="ekr.20040104185913.2191">def get_bases(self):
    bases=[]
    if hasattr(self._obj_, '__bases__'):
        for base in self._obj_.__bases__:
            bases.append(classobject(base.__name__, base))
    return bases
</t>
<t tx="ekr.20040104185913.2192">def get_base_list(self, list=None):
    if list is None: list=[]
    list.append(self)
    for base in self.get_bases():
        list=base.get_base_list(list)
    return list
</t>
<t tx="ekr.20040104185913.2193">def get_methods(self):
    keys=self._obj_.__dict__.keys()
    dict=self._obj_.__dict__
    keys.sort()
    methods=[]
    for name in keys:
        ob=dict[name]
        if is_method(ob) and _chMethod(name, ob):
            methods.append(methodobject(name, ob, self))
    return methods
</t>
<t tx="ekr.20040104185913.2194">def get_method_dict(self, dict=None):
    if dict is None:
        dict={}
    dup=dict.has_key
    for method in self.get_methods():
        name=method.get_name()
        if not dup(name):
            dict[name]=method
    for base in self.get_bases():
        dict=base.get_method_dict(dict)
    return dict
</t>
<t tx="ekr.20040104185913.2195">def get_method_list(self):
    dict=self.get_method_dict()
    keys=dict.keys()
    keys.sort()
    list=[]
    for key in keys:
        list.append(dict[key])
    del dict
    return list
</t>
<t tx="ekr.20040104185913.2196">##     def obAttributes(self):
##         # Return list of class attributes
##         keys=self._obj_.__dict__.keys()
##         dict=self._obj_.__dict__
##         keys.sort()
##         attrs=[]
##         for name in keys:
##             ob=dict[name]
##             if _isAttribute(ob) and _chAttribute(name, ob):
##                 attrs.append(AttributeObject(name, ob, self))
##         return attrs

##     def obAttributeDict(self, dict=None):
##         # Return dict of attrs in class and superclasses
##         if dict is None:
##             dict={}
##             root=1
##         else: root=0
##         dup=dict.has_key
##         for attr in self._obj_Attributes():
##             name=attr.obName()
##             if not dup(name):
##                 dict[name]=attr
##         for base in self._obj_Bases():
##             dict=base.obAttributeDict(dict)
##         return dict

##     def obAttributeList(self):
##         # Return list of attrs in class and superclasses
##         dict=self._obj_AttributeDict()
##         keys=dict.keys()
##         keys.sort()
##         list=[]
##         append=list.append
##         for name in keys:
##             append(dict[name])
##             del dict
##         return list



# needs to be tested !!! The conversion of reconvert.convert looks suspicious
sig_match=re.compile(r'[\w]*\([^)]*\)').match # matches "f(arg1, arg2)"
pre_match=re.compile(r'[\w]*\([^)]*\)[ -]*').match # with ' ' or '-' included

class methodobject(object):
	@others
</t>
<t tx="ekr.20040104185913.2197">def get_class(self):
    return self._obp_
</t>
<t tx="ekr.20040104185913.2198">def get_module(self):
    return self.get_class().get_module()
</t>
<t tx="ekr.20040104185913.2199">def get_file(self):
    return self.get_module().get_file()
</t>
<t tx="ekr.20040104185913.2200">def get_docstring(self):
    func=self._obj_
    doc=''
    if hasattr(func, 'im_func'):
        func=func.im_func
    if hasattr(func, '__doc__'):
        doc=func.__doc__
        if not doc: doc=''
        doc=doc.strip()
    if hasattr(func, 'func_code'):
        if hasattr(func.func_code, 'co_varnames'):
            return doc
    mo=pre_match(doc)
    if mo is not None:
        return doc[mo.end(0):]
    return doc
</t>
<t tx="ekr.20040104185913.2201">def get_signaturex(self):
    name=self._name
    func=self._obj_
    method=None

    if hasattr(func, 'im_func'):
        method=1
        func=func.im_func

    # Normal functions
    if hasattr(func, 'func_code'):
        if hasattr(func.func_code, 'co_varnames'):
            args=map(lambda x: x,
                 func.func_code.co_varnames[:func.func_code.co_argcount])
            ndefaults=func.func_defaults
            ndefaults=ndefaults and len(ndefaults) or 0
            if '__ick__' in args:
                nick=len(args)-args.index('__ick__')
                args=args[:-nick]
                ndefaults=ndefaults-nick
            if ndefaults &gt; 0:
                args[-ndefaults]='['+args[-ndefaults]
                args[-1]=args[-1]+']'
            if method: args=args[1:]
            if name=='__call__':
                name='Call Operation'
            return '%s(%s)' % (name, ', '.join(args))

    # Other functions - look for something that smells like
    # a signature at the beginning of the docstring.
    if hasattr(func, '__doc__'):
        doc=func.__doc__
        if not doc: doc=''
        doc=doc.strip()
        mo=sig_match(doc)
        if mo is not None:
            return doc[:mo.end(0)]
    return '%s()' % name
</t>
<t tx="ekr.20040104185913.2202">def get_signature(self):
    try: return self.get_signaturex()
    except:
        t, v = sys.exc_info()[:2]
        return '%s %s' % (t, v)
</t>
<t tx="ekr.20040104185913.2203">## class AttributeObject(_ob_):
##     def obClass(self):
##         return self.op

##     def obModule(self):
##         return self.obClass().obModule()

##     def obFile(self):
##         return self.obModule().obFile()

## class InstanceObject(_ob_):
##     def obClass(self):
##         # Return the class for this instance
##         c=self._obj_.__class__
##         return ClassObject(c.__name__, c)

##     def obClassList(self):
##         # Return list of all superclasses
##         return self._obj_Class().obClassList()

##     def obMethods(self):
##         # Return list of instance methods
##         keys=self._obj_.__dict__.keys()
##         dict=self._obj_.__dict__
##         keys.sort()
##         methods=[]
##         for name in keys:
##             ob=dict[name]
##             if _isMethod(ob) and _chMethod(name, ob):
##                methods.append(MethodObject(name, ob))
##         return methods

##     def obMethodDict(self):
##         # Return dict of instance and superclass methods
##         dict=self._obj_Class().obMethodDict()
##         for method in self._obj_Methods():
##             dict[method.obName()]=method
##         return dict

##     def obMethodList(self):
##         # Return list of instance and superclass methods
##         dict=self._obj_MethodDict()
##         keys=dict.keys()
##         keys.sort()
##         list=[]
##         append=list.append
##         for name in keys:
##             append(dict[name])
##         return list

##     def obAttributes(self):
##         # Return list of instance attributes
##         keys=self._obj_.__dict__.keys()
##         dict=self._obj_.__dict__
##         keys.sort()
##         attrs=[]
##         for name in keys:
##             ob=dict[name]
##             if _isAttribute(ob) and _chAttribute(name, ob):
##                 attrs.append(AttributeObject(name, ob, self))
##         return attrs

##     def obAttributeDict(self):
##         # Return dict of instance and superclass attributes
##         dict=self._obj_Class().obAttributeDict()
##         for attr in self._obj_Attributes():
##             dict[attr.obName()]=attr
##         return dict

##     def obAttributeList(self):
##         # Return list of instance and superclass attributes
##         dict=self._obj_AttributeDict()
##         keys=dict.keys()
##         keys.sort()
##         list=[]
##         append=list.append
##         for name in keys:
##             append(dict[name])
##         return list

_classtypes=(type(Globals.HTML),
             type(Globals.Persistent),
            )

_methodtypes=(type([].sort),
              type(Globals.default__class_init__),
              type(Globals.HTML.manage_edit),
              type(Globals.HTML.__changed__),
              type(Globals.MessageDialog.manage_edit),
             )

def is_module(ob):
    return type(ob)==type(sys)
</t>
<t tx="ekr.20040104185913.2204">def is_class(ob):
    return type(ob) in _classtypes
</t>
<t tx="ekr.20040104185913.2205">def is_method(ob):
    if type(ob) in _methodtypes or hasattr(ob, 'func_code'):
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.2206">def is_attribute(ob):
    return not is_method(ob)
</t>
<t tx="ekr.20040104185913.2207">def _chModule(name, ob):
    if name[0]=='_':
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2208">def _chClass(name, ob):
    if name[0]=='_':
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2209">def _chMethod(name, ob):
    if name[0]=='_':
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2210">def _chAttribute(name, ob):
    if name[0]=='_':
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2211">&lt;&lt; copyright &gt;&gt;

"""Object Reference implementation"""

__version__='$Revision: 1.10 $'[11:-2]

import sys, os,  Globals, Acquisition
from HelpUtil import HelpBase, classobject
from HelpUtil import is_class, is_module
from Globals import DTMLFile
from urllib import quote

@others
</t>
<t tx="ekr.20040104185913.2213">class ObjectItem(HelpBase, classobject):
    """ """
	__roles__=None

	hs_main=DTMLFile('dtml/objectitem', globals())
	
	hs_cicon='HelpSys/hs_dnode'
	hs_eicon='HelpSys/hs_dnode'

	@others</t>
<t tx="ekr.20040104185913.2215">def hs_id(self):
    return self._obj_.meta_type
</t>
<t tx="ekr.20040104185913.2216">def hs_url(self):
    return quote(self._obj_.meta_type)
</t>
<t tx="ekr.20040104185913.2217">hs_title=hs_id

def __getattr__(self, name):
    if name in ('isDocTemp', '__call__'):
        raise AttributeError, name
    return getattr(self.__dict__['_obj_'], name)
</t>
<t tx="ekr.20040104185913.2218">def get_method_list(self):
    rdict=classobject.get_method_dict(self)
    perms=self.__ac_permissions__
    mdict={}
    mlist=[]
    for p in self.__ac_permissions__:
        pname=p[0]
        fnames=p[1]
        for fname in fnames:
            if rdict.has_key(fname):
                fn=rdict[fname]
                fn.permission=pname
                mdict[fname]=fn
    keys=mdict.keys()
    keys.sort()
    for key in keys:
        fn=mdict[key]
        if not hasattr(fn._obj_, '__doc__'):
            continue
        doc=fn._obj_.__doc__
        if hasattr(fn._obj_, '__class__') and \
           fn._obj_.__class__.__doc__ is doc:
            continue

        mlist.append(mdict[key])
    del rdict
    del mdict
    return mlist
</t>
<t tx="ekr.20040104185913.2219">hs_objectvalues__roles__=None

def hs_objectvalues(self):
    return []
</t>
<t tx="ekr.20040104185913.2220">class ObjectRef(HelpBase):
    """ """
	__names__=None
	__roles__=None
	
	hs_main=DTMLFile('dtml/objectref', globals())
	
	hs_cicon='HelpSys/hs_cbook'
	hs_eicon='HelpSys/hs_obook'
	
	hs_id   ='ObjectRef'
	hs_title='Object Reference'
	hs_url  =hs_id

	@others</t>
<t tx="ekr.20040104185913.2222">def hs_deferred__init__(self):
    # This is necessary because we want to wait until all
    # products have been installed (imported).
    dict={}
    for k, v in sys.modules.items():
        if v is not None and k != '__builtins__':
            dict=self.hs_search_mod(v, dict)
    keys=dict.keys()
    keys.sort()
    __traceback_info__=(`dict`,)
    for key in keys:
        setattr(self, key, dict[key])
    self.__names__=keys
</t>
<t tx="ekr.20040104185913.2223">def hs_search_mod(self, mod, dict):
    # Root through a module for things that look like
    # createable object classes.
    hidden=('Control Panel', 'Principia Draft', 'simple item',
            'Broken Because Product is Gone')
    for k, v in mod.__dict__.items():
        if is_class(v) and hasattr(v, 'meta_type') and \
           hasattr(v, '__ac_permissions__'):
            if callable(v.meta_type):
                try: meta_type=v.meta_type()
                except:
                    # Ack. probably a ZClass :(
                    meta_type=None
            else: meta_type=v.meta_type
            if (meta_type is not None) and (meta_type not in hidden):
                dict[meta_type]=ObjectItem(k, v)
        if is_module(v) and hasattr(v, '__path__'):
            dict=self.hs_search_mod(v, dict)
    return dict
</t>
<t tx="ekr.20040104185913.2224">hs_objectvalues__roles__=None

def hs_objectvalues(self):
    if self.__names__ is None:
        self.hs_deferred__init__()
    items=[]
    for id in self.__names__:
        items.append(getattr(self, id))
    return items
</t>
<t tx="ekr.20040104185913.2225">def __getitem__(self, key):
    return self.__dict__[key].__of__(self)
</t>
<t tx="ekr.20040104185913.2226">&lt;&lt; copyright &gt;&gt;

# backward compatibility
import HelpSys
import sys

sys.modules['HelpSys.HelpSystem']=HelpSys
</t>
<t tx="ekr.20040104185913.2227"></t>
<t tx="ekr.20040104185913.2228">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: Attribute.py,v 1.5 2002/08/14 21:35:32 mj Exp $
"""

from _Element import Element

@others
</t>
<t tx="ekr.20040104185913.2230">class Attribute(Element):
    """Attribute descriptions
    """

	# We can't say this yet because we don't have enough
    # infrastructure in place.
    #
    #__implements__ = IAttribute

</t>
<t tx="ekr.20040104185913.2232">&lt;&lt; copyright &gt;&gt;

""" Pretty-Print an Interface object as structured text (Yum)

This module provides a function, asStructuredText, for rendering an
interface as structured text.

Revision information:
$Id: Document.py,v 1.3 2002/08/14 21:35:32 mj Exp $
"""

from string import maketrans

@others
</t>
<t tx="ekr.20040104185913.2234">def asStructuredText(I, munge=0):
    """ Output structured text format.  Note, this will wack any existing
    'structured' format of the text.  """


    r = ["%s\n\n" % I.getName()]
    outp = r.append
    level = 1

    if I.getDoc():
        outp(_justify_and_indent(_trim_doc_string(I.getDoc()), level)+ "\n\n")

    if I.getBases():
        outp((" " * level) + "This interface extends:\n\n")
        level = level + 1
        for b in I.getBases():
            item = "o %s" % b.getName()
            outp(_justify_and_indent(_trim_doc_string(item), level, munge)
                 + "\n\n")

        level = level - 1

    namesAndDescriptions = list(I.namesAndDescriptions())
    namesAndDescriptions.sort()


    outp(_justify_and_indent("Attributes:", level, munge)+'\n\n')
    level = level + 1
    for name, desc in namesAndDescriptions:
        if not hasattr(desc, 'getSignatureString'):   # ugh...
            item = "%s -- %s" % (desc.getName(),
                                 desc.getDoc() or 'no documentation')
            outp(_justify_and_indent(_trim_doc_string(item), level, munge)
                 + "\n\n")
    level = level - 1

    outp(_justify_and_indent("Methods:", level, munge)+'\n\n')
    level = level + 1
    for name, desc in namesAndDescriptions:
        if hasattr(desc, 'getSignatureString'):   # ugh...
            item = "%s%s -- %s" % (desc.getName(),
                                   desc.getSignatureString(),
                                   desc.getDoc() or 'no documentation')
            outp(_justify_and_indent(_trim_doc_string(item), level, munge)
                 + "\n\n")

    return "".join(r)
</t>
<t tx="ekr.20040104185913.2235">def _trim_doc_string(text):
    """
    Trims a doc string to make it format
    correctly with structured text.
    """
    text = text.strip().replace('\r\n', '\n')
    lines = text.split('\n')
    nlines = [lines[0]]
    if len(lines) &gt; 1:
        min_indent=None
        for line in lines[1:]:
            indent=len(line) - len(line.lstrip())
            if indent &lt; min_indent or min_indent is None:
                min_indent=indent
        for line in lines[1:]:
            nlines.append(line[min_indent:])
    return '\n'.join(nlines)
</t>
<t tx="ekr.20040104185913.2236">_trans = maketrans("\r\n", "  ")
def _justify_and_indent(text, level, munge=0, width=72):
    """ indent and justify text, rejustify (munge) if specified """

    lines = []

    if munge:
        line = " " * level
        text = text.translate(text, _trans).strip().split()

        for word in text:
            line = ' '.join([line, word])
            if len(line) &gt; width:
                lines.append(line)
                line = " " * level
        else:
            lines.append(line)

        return "\n".join(lines)

    else:
        text = text.replace("\r\n", "\n").split("\n")

        for line in text:
            lines.append( (" " * level) + line)

        return '\n'.join(lines)
</t>
<t tx="ekr.20040104185913.2237">&lt;&lt; copyright &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.2239">class DoesNotImplement(Exception):
    """ This object does not implement """
	@others
</t>
<t tx="ekr.20040104185913.2240">def __init__(self, interface):
    self.interface = interface
</t>
<t tx="ekr.20040104185913.2241">def __str__(self):
    return """An object does not implement interface %(interface)s

    """ % self.__dict__
</t>
<t tx="ekr.20040104185913.2242">class BrokenImplementation(Exception):
    """An attribute is not completely implemented.
    """
	@others
</t>
<t tx="ekr.20040104185913.2243">def __init__(self, interface, name):
    self.interface=interface
    self.name=name
</t>
<t tx="ekr.20040104185913.2244">def __str__(self):
    return """An object has failed to implement interface %(interface)s

    The %(name)s attribute was not provided.
    """ % self.__dict__
</t>
<t tx="ekr.20040104185913.2245">class BrokenMethodImplementation(Exception):
    """An method is not completely implemented.
    """
	@others
</t>
<t tx="ekr.20040104185913.2246">def __init__(self, method, mess):
    self.method=method
    self.mess=mess
</t>
<t tx="ekr.20040104185913.2247">def __str__(self):
    return """The implementation of %(method)s violates its contract
    because %(mess)s.
    """ % self.__dict__
</t>
<t tx="ekr.20040104185913.2248">class InvalidInterface(Exception):
    """The interface has invalid contents
    """
</t>
<t tx="ekr.20040104185913.2249">class BadImplements(TypeError):
    """An implementation assertion is invalid

    because it doesn't contain an interface or a sequence of valid
    implementation assertions.
    """
</t>
<t tx="ekr.20040104185913.2250">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: IAttribute.py,v 1.3 2002/08/14 21:35:32 mj Exp $
"""

from IElement import IElement

@others</t>
<t tx="ekr.20040104185913.2252">class IAttribute(IElement):
    """Attribute descriptors"""
</t>
<t tx="ekr.20040104185913.2253">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: IElement.py,v 1.5 2002/08/14 21:35:32 mj Exp $
"""

from _Interface import Interface
from Attribute import Attribute

@others
</t>
<t tx="ekr.20040104185913.2255">class IElement(Interface):
    """Objects that have basic documentation and tagged values.
    """
	&lt;&lt; class IElement declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2256">__name__ = Attribute('__name__', 'The object name')
__doc__  = Attribute('__doc__', 'The object doc string')

</t>
<t tx="ekr.20040104185913.2257">def getName():
    """Returns the name of the object."""
</t>
<t tx="ekr.20040104185913.2258">def getDoc():
    """Returns the documentation for the object."""
</t>
<t tx="ekr.20040104185913.2259">def getTaggedValue(tag):
    """Returns the value associated with 'tag'."""
</t>
<t tx="ekr.20040104185913.2260">def getTaggedValueTags():
    """Returns a list of all tags."""
</t>
<t tx="ekr.20040104185913.2261">def setTaggedValue(tag, value):
    """Associates 'value' with 'key'."""
</t>
<t tx="ekr.20040104185913.2262">&lt;&lt; IInterface declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2263">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: IInterface.py,v 1.3 2002/08/14 21:35:32 mj Exp $
"""

from IElement import IElement

</t>
<t tx="ekr.20040104185913.2264">class IInterface(IElement):
    """Interface objects

    Interface objects describe the behavior of an object by containing
    useful information about the object.  This information includes:

      o Prose documentation about the object.  In Python terms, this
        is called the "doc string" of the interface.  In this element,
        you describe how the object works in prose language and any
        other useful information about the object.

      o Descriptions of attributes.  Attribute descriptions include
        the name of the attribute and prose documentation describing
        the attributes usage.

      o Descriptions of methods.  Method descriptions can include:

        o Prose "doc string" documentation about the method and its
          usage.

        o A description of the methods arguments; how many arguments
          are expected, optional arguments and their default values,
          the position or arguments in the signature, whether the
          method accepts arbitrary arguments and whether the method
          accepts arbitrary keyword arguments.

      o Optional tagged data.  Interface objects (and their attributes and
        methods) can have optional, application specific tagged data
        associated with them.  Examples uses for this are examples,
        security assertions, pre/post conditions, and other possible
        information you may want to associate with an Interface or its
        attributes.

    Not all of this information is mandatory.  For example, you may
    only want the methods of your interface to have prose
    documentation and not describe the arguments of the method in
    exact detail.  Interface objects are flexible and let you give or
    take any of these components.

    Interfaces are created with the Python class statement using
    either Interface.Interface or another interface, as in::

      from Interface import Interface

      class IMyInterface(Interface):
        '''Interface documentation
        '''

        def meth(arg1, arg2):
            '''Documentation for meth
            '''

        # Note that there is no self argument

     class IMySubInterface(IMyInterface):
        '''Interface documentation
        '''

        def meth2():
            '''Documentation for meth2
            '''

    You use interfaces in two ways:

    o You assert that your object implement the interfaces.

      There are several ways that you can assert that an object
      implements an interface::

      1. Include an '__implements__' attribute in the object's class
         definition. The value of the '__implements__' attribute must
         be an implementation specification. An implementation
         specification is either an interface or a tuple of
         implementation specifications.

      2. Incluse an '__implements__' attribute in the object.
         Because Python classes don't have their own attributes, to
         assert that a class implements interfaces, you must provide a
         '__class_implements__' attribute in the class definition.

         **Important**: A class usually doesn't implement the
           interfaces that it's instances implement. The class and
           it's instances are separate objects with their own
           interfaces.

      3. Call 'Interface.Implements.implements' to assert that instances
         of a class implement an interface.

         For example::

           from Interface.Implements import implements

           implements(some_class, some_interface)

         This is approach is useful when it is not an option to modify
         the class source.  Note that this doesn't affect what the
         class itself implements, but only what it's instances
         implement.

      4. For types that can't be modified, you can assert that
         instances of the type implement an interface using
         'Interface.Implements.assertTypeImplements'.

         For example::

           from Interface.Implements import assertTypeImplements

           assertTypeImplements(some_type, some_interface)

    o You query interface meta-data. See the IInterface methods and
      attributes for details.

    """
	@others
</t>
<t tx="ekr.20040104185913.2265">def getBases():
    """Return a sequence of the base interfaces
    """
</t>
<t tx="ekr.20040104185913.2266">def extends(other, strict=1):
    """Test whether the interface extends another interface

    A true value is returned in the interface extends the other
    interface, and false otherwise.

    Normally, an interface doesn't extend itself. If a false value
    is passed as the second argument, or via the 'strict' keyword
    argument, then a true value will be returned if the interface
    and the other interface are the same.
    """
</t>
<t tx="ekr.20040104185913.2267">def isImplementedBy(object):
    """Test whether the interface is implemented by the object.

    Return true of the object asserts that it implements the
    interface, including asseting that it implements an extended
    interface.
    """
</t>
<t tx="ekr.20040104185913.2268">def isImplementedByInstancesOf(class_):
    """Test whether the interface is implemented by instances of the class

    Return true of the class asserts that it's instances implement the
    interface, including asseting that they implement an extended
    interface.
    """
</t>
<t tx="ekr.20040104185913.2269">def names(all=0):
    """Get the interface attribute names.

    Return a sequence of the names of the attributes, including
    methods, included in the interface definition.

    Normally, only directly defined attributes are included. If
    a true positional or keyword argument is given, then
    attributes defined by nase classes will be included.
    """
</t>
<t tx="ekr.20040104185913.2270">def namesAndDescriptions(all=0):
    """Get the interface attribute names and descriptions.

    Return a sequence of the names and descriptions of the
    attributes, including methods, as name-value pairs, included
    in the interface definition.

    Normally, only directly defined attributes are included. If
    a true positional or keyword argument is given, then
    attributes defined by nase classes will be included.
    """
</t>
<t tx="ekr.20040104185913.2271">def getDescriptionFor(name):
    """Get the description for a name

    If the named attribute does not exist, a KeyError is raised.
    """
</t>
<t tx="ekr.20040104185913.2272">def queryDescriptionFor(name, default=None):
    """Get the description for a name

    Return the default if no description exists.
    """
</t>
<t tx="ekr.20040104185913.2273">&lt;&lt; IMethod declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2274">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: IMethod.py,v 1.3 2002/08/14 21:35:32 mj Exp $
"""

from IAttribute import IAttribute

</t>
<t tx="ekr.20040104185913.2275">class IMethod(IAttribute):
    """Method attributes
    """
	&lt;&lt; class IMethod declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2276">    # XXX What the heck should methods provide? Grrrr

</t>
<t tx="ekr.20040104185913.2277">def getSignatureString():
    """Return a signature string suitable for inclusion in documentation.
    """
</t>
<t tx="ekr.20040104185913.2278">&lt;&lt; Implements declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2279">&lt;&lt; copyright &gt;&gt;

"""Implemantation assertion facilities.

Revision information:
$Id: Implements.py,v 1.3.6.1 2003/02/12 08:43:26 andreasjung Exp $
"""

import Exceptions
from types import ClassType
from Verify import verifyClass
from _InterfaceClass import Interface as InterfaceClass
from types import TupleType, ClassType, StringType

# Special value indicating the object supports
# what its class supports.
CLASS_INTERFACES = 1

from _object import ClassTypes, isInstance

_typeImplements={}

</t>
<t tx="ekr.20040104185913.2280">def getImplements(object):
    t = type(object)
    if t in ClassTypes:
        if hasattr(object, '__class_implements__'):
            return object.__class_implements__
    elif hasattr(object, '__implements__'):
        return object.__implements__

    return _typeImplements.get(t, None)
</t>
<t tx="ekr.20040104185913.2281">def getImplementsOfInstances(klass, tiget=_typeImplements.get):
    if type(klass) in ClassTypes:
        if hasattr(klass, '__implements__'):
            return klass.__implements__
        else:
            return None
    else:
        return tiget(klass, None)
</t>
<t tx="ekr.20040104185913.2282">def visitImplements(implements, object, visitor, getInterface=None):
    """
    Visits the interfaces described by an __implements__ attribute,
    invoking the visitor for each interface object.
    If the visitor returns anything true, the loop stops.
    This does not, and should not, visit superinterfaces.
    """
    # this allows us to work with proxy wrappers in Python 2.2,
    # yet remain compatible with earlier versions of python.
    implements_class = getattr(implements, '__class__', None)

    if implements_class == InterfaceClass or \
       isInstance(implements, InterfaceClass):
        return visitor(implements)
    elif implements == CLASS_INTERFACES:
        klass = getattr(object, '__class__', None)
        if klass is not None:
            i = getImplementsOfInstances(klass)
            if i:
                return visitImplements(i, object, visitor, getInterface)
    elif implements_class == StringType or type(implements) is StringType:
        if getInterface is not None:
            # Look up a named interface.
            i = getInterface(object, implements)
            if i is not None:
                return visitImplements(i, object, visitor, getInterface)
    elif implements_class == TupleType or type(implements) is TupleType:
        for i in implements:
            r = visitImplements(i, object, visitor, getInterface)
            if r:
                # If the visitor returns anything true, stop.
                return r
    else:
        if implements_class is not None and \
           type(implements) != implements_class:
            raise Exceptions.BadImplements(
                """__implements__ should be an interface or tuple,
                not a %s pretending to be a %s"""
                % (type(implements).__name__, implements_class.__name__)
                )
        raise Exceptions.BadImplements(
            """__implements__ should be an interface or tuple,
            not a %s""" % type(implements).__name__)
    return 0
</t>
<t tx="ekr.20040104185913.2283">def assertTypeImplements(type, interfaces):
    """Assign a set of interfaces to a Python type such as int, str, tuple,
       list and dict.
    """
    _typeImplements[type]=interfaces
</t>
<t tx="ekr.20040104185913.2284">def objectImplements(object, getInterface=None):
    r = []
    implements = getImplements(object)
    if not implements:
        return r
    visitImplements(implements, object, r.append, getInterface)
    return r
</t>
<t tx="ekr.20040104185913.2285">def instancesOfObjectImplements(klass, getInterface=None):
    r = []
    implements = getImplementsOfInstances(klass)
    if not implements:
        return r
    visitImplements(implements, klass, r.append, getInterface)
    return r
</t>
<t tx="ekr.20040104185913.2286">def _flatten(i, append):
    append(i)
    bases = i.getBases()
    if bases:
        for b in bases:
            _flatten(b, append)
</t>
<t tx="ekr.20040104185913.2287">def flattenInterfaces(interfaces, remove_duplicates=1):
    res = []
    for i in interfaces:
        _flatten(i, res.append)
    if remove_duplicates:
        # Remove duplicates in reverse.
        # Similar to Python 2.2's method resolution order.
        seen = {}
        index = len(res) - 1
        while index &gt;= 0:
            i = res[index]
            if seen.has_key(i):
                del res[index]
            else:
                seen[i] = 1
            index = index - 1
    return res
</t>
<t tx="ekr.20040104185913.2288">def implements(klass, interface, check=1):
    if check:
        verifyClass(interface, klass, tentative=1)

    old=getattr(klass, '__implements__', None)
    if old is None:
        klass.__implements__ = interface
    else:
        klass.__implements__ = old, interface
</t>
<t tx="ekr.20040104185913.2289">import Basic, Util

@others

Util.assertTypeImplements(type(()), (Sequence, Sized, Basic.HashKey))
Util.assertTypeImplements(type([]), (Sequence, Sized, MutableMapping))
Util.assertTypeImplements(type({}), (Mapping, Sized, MutableMapping))
</t>
<t tx="ekr.20040104185913.2291">class Mapping(Basic.Base):
	
	"anything supporting __getitem__"

	@others
</t>
<t tx="ekr.20040104185913.2293">def __getitem__(key):
    """Get the value for the given key

    Raise a key error if the key if not in the collection.
    """
</t>
<t tx="ekr.20040104185913.2294">class QueryMapping(Mapping):
	@others
</t>
<t tx="ekr.20040104185913.2295">def has_key(key):
    """Check whether the object has an item with the given key"""
</t>
<t tx="ekr.20040104185913.2296">def get(key, default=None):
    """Get the value for the given key

    Return the default if the key is not in the  collection.
    """
</t>
<t tx="ekr.20040104185913.2297">class Sized(Basic.Base):

	"anything supporting __len"

	@others
</t>
<t tx="ekr.20040104185913.2299">def __len__():
    """Return the number of items in the container"""
</t>
<t tx="ekr.20040104185913.2300">class MutableMapping(Basic.Mutable):
	"Has __setitem__ and __delitem__"
	@others
</t>
<t tx="ekr.20040104185913.2302">def __setitem__(key, value):
    """Set the value for the given key"""
</t>
<t tx="ekr.20040104185913.2303">def __delitem__(key):
    """delete the value for the given key

    Raise a key error if the key if not in the collection."""
</t>
<t tx="ekr.20040104185913.2304">class EnumerableMapping(Mapping):
	@others
</t>
<t tx="ekr.20040104185913.2305">def keys():
    """Return an Sequence containing the keys in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.2306">class MinimalDictionary(QueryMapping, Sized, MutableMapping,EnumerableMapping):
	"""Provide minimal dictionary-like behavior
	"""
	@others
</t>
<t tx="ekr.20040104185913.2308">def values():
    """Return a IReadSequence containing the values in the collection

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.2309">def items():
    """Return a IReadSequence containing the items in the collection

    An item is a key-value tuple.

    The type of the IReadSequence is not specified. It could be a
    list or a tuple or some other type.
    """
</t>
<t tx="ekr.20040104185913.2310">class Sequence(Mapping):
	"Keys must be integers in a sequence starting at 0."
</t>
<t tx="ekr.20040104185913.2312">class Sequential(Sequence):
	"Keys must be used in order"
</t>
<t tx="ekr.20040104185913.2314">&lt;&lt; Method declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2315">&lt;&lt; copyright &gt;&gt;

"""Method interfaces

Revision information:
$Id: Method.py,v 1.12 2002/08/14 21:35:32 mj Exp $
"""
import Exceptions
from Attribute import Attribute

sig_traits = ['positional', 'required', 'optional', 'varargs', 'kwargs']

CO_VARARGS = 4
CO_VARKEYWORDS = 8

</t>
<t tx="ekr.20040104185913.2316">class Method(Attribute):
    """Method interfaces

    The idea here is that you have objects that describe methods.
    This provides an opportunity for rich meta-data.
    """
	&lt;&lt; class Method declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2317"># We can't say this yet because we don't have enough
# infrastructure in place.
#
#__implements__ = IMethod

interface=''

</t>
<t tx="ekr.20040104185913.2318">def __call__(self, *args, **kw):
    raise Exceptions.BrokenImplementation(self.interface, self.__name__)
</t>
<t tx="ekr.20040104185913.2319">def getSignatureInfo(self):
    info = {}
    for t in sig_traits:
        info[t] = getattr(self, t)

    return info
</t>
<t tx="ekr.20040104185913.2320">def getSignatureString(self):
    sig = "("
    for v in self.positional:
        sig = sig + v
        if v in self.optional.keys():
            sig = sig + "=%s" % `self.optional[v]`
        sig = sig + ", "
    if self.varargs:
        sig = sig + ("*%s, " % self.varargs)
    if self.kwargs:
        sig = sig + ("**%s, " % self.kwargs)

    # slice off the last comma and space
    if self.positional or self.varargs or self.kwargs:
        sig = sig[:-2]

    sig = sig + ")"
    return sig
</t>
<t tx="ekr.20040104185913.2321">def fromFunction(func, interface='', imlevel=0):
    m=Method(func.__name__, func.__doc__)
    defaults=func.func_defaults or ()
    c=func.func_code
    na=c.co_argcount-imlevel
    names=c.co_varnames[imlevel:]
    d={}
    nr=na-len(defaults)
    if nr &lt; 0:
        defaults=defaults[-nr:]
        nr=0

    for i in range(len(defaults)):
        d[names[i+nr]]=defaults[i]

    m.positional=names[:na]
    m.required=names[:nr]
    m.optional=d

    argno = na
    if c.co_flags &amp; CO_VARARGS:
        m.varargs = names[argno]
        argno = argno + 1
    else:
        m.varargs = None
    if c.co_flags &amp; CO_VARKEYWORDS:
        m.kwargs = names[argno]
    else:
        m.kwargs = None

    m.interface=interface
    return m
</t>
<t tx="ekr.20040104185913.2322">def fromMethod(meth, interface=''):
    func = meth.im_func
    return fromFunction(func, interface, imlevel=1)
</t>
<t tx="ekr.20040104185913.2323">&lt;&lt; Verify declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2324">&lt;&lt; copyright &gt;&gt;

from Exceptions import BrokenImplementation, DoesNotImplement
from Exceptions import BrokenMethodImplementation
from types import FunctionType
from Method import fromMethod, fromFunction
from _object import MethodTypes

</t>
<t tx="ekr.20040104185913.2325">def _verify(iface, candidate, tentative=0, vtype=None):
    """

    Verify that 'candidate' might correctly implements 'iface'.
    This involves:

      o Making sure the candidate defines all the necessary methods

      o Making sure the methods have the correct signature

      o Making sure the candidate asserts that it implements the interface

    Note that this isn't the same as verifying that the class does
    implement the interface.

    If optional tentative is true, suppress the "is implemented by" test.
    """

    if vtype is 'c':
        tester = iface.isImplementedByInstancesOf
    else:
        tester = iface.isImplementedBy

    if not tentative and not tester( candidate ):
        raise DoesNotImplement(iface)

    for n, d in iface.namesAndDescriptions(1):
        if not hasattr(candidate, n):
            raise BrokenImplementation(iface, n)

        attr = getattr(candidate, n)
        if type(attr) is FunctionType:
            # should never get here
            meth = fromFunction(attr, n)
        elif type(attr) in MethodTypes:
            meth = fromMethod(attr, n)
        else:
            continue # must be an attribute...

        d=d.getSignatureInfo()
        meth = meth.getSignatureInfo()

        mess = _incompat(d, meth)
        if mess:
            raise BrokenMethodImplementation(n, mess)

    return 1
</t>
<t tx="ekr.20040104185913.2326">def verifyClass(iface, candidate, tentative=0):
    return _verify(iface, candidate, tentative, vtype='c')
</t>
<t tx="ekr.20040104185913.2327">def verifyObject(iface, candidate, tentative=0):
    return _verify(iface, candidate, tentative, vtype='o')
</t>
<t tx="ekr.20040104185913.2328">def _incompat(required, implemented):
    #if (required['positional'] !=
    #    implemented['positional'][:len(required['positional'])]
    #    and implemented['kwargs'] is None):
    #    return 'imlementation has different argument names'
    if len(implemented['required']) &gt; len(required['required']):
        return 'implementation requires too many arguments'
    if ((len(implemented['positional']) &lt; len(required['positional']))
        and not implemented['varargs']):
        return "implementation doesn't allow enough arguments"
    if required['kwargs'] and not implemented['kwargs']:
        return "implementation doesn't support keyword arguments"
    if required['varargs'] and not implemented['varargs']:
        return "implementation doesn't support variable arguments"
</t>
<t tx="ekr.20040104185913.2329">&lt;&lt; _Element declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2330">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: _Element.py,v 1.3.6.2 2003/07/30 22:13:14 philikon Exp $
"""

from _object import object

</t>
<t tx="ekr.20040104185913.2331">class Element(object):
	&lt;&lt; class Element declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2332">    # We can't say this yet because we don't have enough
    # infrastructure in place.
    #
    #__implements__ = IElement

</t>
<t tx="ekr.20040104185913.2333">def __init__(self, __name__=None, __doc__=''):
    """Create an 'attribute' description
    """
    if not __doc__ and __name__ and __name__.find(' ') &gt;= 0:
        __doc__ = __name__
        __name__ = None

    self.__name__=__name__
    self.__doc__=__doc__
    self.__tagged_values = {}
</t>
<t tx="ekr.20040104185913.2334">def getName(self):
    """ Returns the name of the object. """
    return self.__name__
</t>
<t tx="ekr.20040104185913.2335">def getDoc(self):
    """ Returns the documentation for the object. """
    return self.__doc__
</t>
<t tx="ekr.20040104185913.2336">def getTaggedValue(self, tag):
    """ Returns the value associated with 'tag'. """
    return self.__tagged_values[tag]
</t>
<t tx="ekr.20040104185913.2337">def getTaggedValueTags(self):
    """ Returns a list of all tags. """
    return self.__tagged_values.keys()
</t>
<t tx="ekr.20040104185913.2338">def setTaggedValue(self, tag, value):
    """ Associates 'value' with 'key'. """
    self.__tagged_values[tag] = value
</t>
<t tx="ekr.20040104185913.2339">&lt;&lt; _Interface declarations &gt;&gt;
@others

wire()
del wire
del InterfaceClass
</t>
<t tx="ekr.20040104185913.2340">&lt;&lt; copyright &gt;&gt;

"""Interface object implementation

Revision information:
$Id: _Interface.py,v 1.5 2002/08/14 21:35:32 mj Exp $
"""

from _InterfaceClass import Interface as InterfaceClass

Interface = InterfaceClass("Interface")

# Now we can create the interesting interfaces and wire them up:
</t>
<t tx="ekr.20040104185913.2341">def wire():

    from Implements import implements

    from Attribute import Attribute
    from IAttribute import IAttribute
    implements(Attribute, IAttribute)

    from Method import Method
    from IMethod import IMethod
    implements(Method, IMethod)

    from IInterface import IInterface
    implements(InterfaceClass, IInterface)
</t>
<t tx="ekr.20040104185913.2342">&lt;&lt; _InterfaceClass declarations &gt;&gt;
@others

# We import this here to deal with module dependencies.
from Implements import getImplementsOfInstances, visitImplements, getImplements
from Implements import instancesOfObjectImplements
</t>
<t tx="ekr.20040104185913.2343">&lt;&lt; copyright &gt;&gt;

"""Interface object implementation

Revision information:
$Id: _InterfaceClass.py,v 1.6 2002/08/14 21:35:32 mj Exp $
"""

from inspect import currentframe
import sys
from Method import Method, fromFunction
from Attribute import Attribute
from types import FunctionType
import Exceptions
from _Element import Element
from _object import isInstance

</t>
<t tx="ekr.20040104185913.2344">class Interface(Element):
    """Prototype (scarecrow) Interfaces Implementation
    """
	&lt;&lt; class Interface declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2345">    # We can't say this yet because we don't have enough
    # infrastructure in place.
    #
    #__implements__ = IInterface

</t>
<t tx="ekr.20040104185913.2346">def __init__(self, name, bases=(), attrs=None, __doc__=None,
             __module__=None):

    if __module__ is None:
        if attrs is not None and attrs.has_key('__module__'):
            __module__ = attrs['__module__']
            del attrs['__module__']
        else:
            try:
                # Figure out what module defined the interface.
                # This is how cPython figures out the module of
                # a class, but of course it does it in C. :-/
                __module__ = currentframe().f_back.f_globals['__name__']
            except (AttributeError, KeyError):
                pass
    self.__module__ = __module__

    for b in bases:
        if not isInstance(b, Interface):
            raise TypeError, 'Expected base interfaces'
    self.__bases__=bases

    if attrs is None: attrs={}
    if attrs.has_key('__doc__'):
        if __doc__ is None: __doc__=attrs['__doc__']
        del attrs['__doc__']

    if __doc__ is not None:
        self.__doc__=__doc__
    else:
        self.__doc__ = ""

    Element.__init__(self, name, __doc__)

    for k, v in attrs.items():
        if isInstance(v, Attribute):
            v.interface=name
            if not v.__name__:
                v.__name__ = k
        elif isinstance(v, FunctionType):
            attrs[k]=fromFunction(v, name)
        else:
            raise Exceptions.InvalidInterface(
                "Concrete attribute, %s" % k)

    self.__attrs = attrs
</t>
<t tx="ekr.20040104185913.2347">def getBases(self):
    return self.__bases__
</t>
<t tx="ekr.20040104185913.2348">def extends(self, other, strict=1):
    """Does an interface extend another?
    """
    if not strict and self is other:
        return 1

    for b in self.__bases__:
        if b == other: return 1
        if b.extends(other): return 1
    return 0
</t>
<t tx="ekr.20040104185913.2349">def isEqualOrExtendedBy(self, other):
    """Same interface or extends?
    """
    if self == other:
        return 1
    return other.extends(self)
</t>
<t tx="ekr.20040104185913.2350">def isImplementedBy(self, object):
    """Does the given object implement the interface?
    """
    i = getImplements(object)
    if i is not None:
        return visitImplements(
            i, object, self.isEqualOrExtendedBy, self._getInterface)
    return 0
</t>
<t tx="ekr.20040104185913.2351">def isImplementedByInstancesOf(self, klass):
    """Do instances of the given class implement the interface?
    """
    i = getImplementsOfInstances(klass)
    if i is not None:
        return visitImplements(
            i, klass, self.isEqualOrExtendedBy, self._getInterface)
    return 0
</t>
<t tx="ekr.20040104185913.2352">def names(self, all=0):
    """Return the attribute names defined by the interface
    """
    if not all:
        return self.__attrs.keys()

    r = {}
    for name in self.__attrs.keys():
        r[name] = 1
    for base in self.__bases__:
        for name in base.names(all):
            r[name] = 1
    return r.keys()
</t>
<t tx="ekr.20040104185913.2353">def namesAndDescriptions(self, all=0):
    """Return the attribute names and descriptions defined by the interface
    """
    if not all:
        return self.__attrs.items()

    r = {}
    for name, d in self.__attrs.items():
        r[name] = d

    for base in self.__bases__:
        for name, d in base.namesAndDescriptions(all):
            if not r.has_key(name):
                r[name] = d

    return r.items()
</t>
<t tx="ekr.20040104185913.2354">def getDescriptionFor(self, name):
    """Return the attribute description for the given name
    """
    r = self.queryDescriptionFor(name)
    if r is not None:
        return r

    raise KeyError, name
</t>
<t tx="ekr.20040104185913.2355">def queryDescriptionFor(self, name, default=None):
    """Return the attribute description for the given name
    """
    r = self.__attrs.get(name, self)
    if r is not self:
        return r
    for base in self.__bases__:
        r = base.queryDescriptionFor(name, self)
        if r is not self:
            return r

    return default
</t>
<t tx="ekr.20040104185913.2356">def deferred(self):
    """Return a defered class corresponding to the interface
    """
    if hasattr(self, "_deferred"): return self._deferred

    klass={}
    exec "class %s: pass" % self.__name__ in klass
    klass=klass[self.__name__]

    self.__d(klass.__dict__)

    self._deferred=klass

    return klass
</t>
<t tx="ekr.20040104185913.2357">def _getInterface(self, ob, name):
    '''
    Retrieve a named interface.
    '''
    return None
</t>
<t tx="ekr.20040104185913.2358">def __d(self, dict):

    for k, v in self.__attrs.items():
        if isInstance(v, Method) and not dict.has_key(k):
            dict[k]=v

    for b in self.__bases__: b.__d(dict)
</t>
<t tx="ekr.20040104185913.2359">def __repr__(self):
    name = self.__name__
    m = self.__module__
    if m:
        name = '%s.%s' % (m, name)
    return "&lt;%s %s at %x&gt;" % (self.__class__.__name__, name, id(self))
</t>
<t tx="ekr.20040104185913.2360">def __reduce__(self):
    return self.__name__
</t>
<t tx="ekr.20040104185913.2361">def __hash__(self):
    """ interface instances need to be hashable, and inheriting
    from extensionclass makes instances unhashable unless we declare
    a __hash__ method here"""
    return id(self)
</t>
<t tx="ekr.20040104185913.2362">&lt;&lt; copyright &gt;&gt;

"""Interfaces

This package implements the Python "scarecrow" proposal.

The package exports a single name, 'Interface' directly. Interface
is used to create an interface with a class statement, as in:

  from Interface import Interface

  class IMyInterface(Interface):
    '''Interface documentation
    '''

    def meth(arg1, arg2):
        '''Documentation for meth
        '''

    # Note that there is no self argument

To find out what you can do with interfaces, see the interface
interface, IInterface in the IInterface module.

The package has several public modules:

  o Attribute has the implementation for interface attributes
    for people who want to build interfaces by hand.
    (Maybe someone should cry YAGNI for this. ;)

  o Document has a utility for documenting an interface as structured text.

  o Exceptions has the interface-defined exceptions

  o IAttribute defines the attribute descriptor interface.

  o IElement defined the base interface for IAttribute, IInterface,
    and IMethod.

  o IInterface defines the interface interface

  o IMethod defined the method interface.

  o Implements has various utilities for examining interface assertions.

  o Method has the implementation for interface methods. See above.

  o Verify has utilities for verifying (sort of) interfaces.

See the module doc strings for more information.

There is also a script, pyself.py in the package that can be used to
create interface skeletins. Run it without arguments to get documentation.

Revision information:
$Id: __init__.py,v 1.9 2002/08/14 21:35:32 mj Exp $
"""

from _Interface import Interface
from Attribute import Attribute
Base = Interface # XXX We need to stamp out Base usage
</t>
<t tx="ekr.20040104185913.2363">&lt;&lt; _object declarations &gt;&gt;
@others

    ClassTypes  += (type(_x), )
    MethodTypes += (type(_x.m), )
</t>
<t tx="ekr.20040104185913.2364">&lt;&lt; copyright &gt;&gt;

"""Provide a halfway believable rendition of Python 2.2's object

$Id: _object.py,v 1.4 2002/08/14 21:35:32 mj Exp $
"""

</t>
<t tx="ekr.20040104185913.2365">class _x:
	@others
</t>
<t tx="ekr.20040104185913.2366">def m(self):
    pass
</t>
<t tx="ekr.20040104185913.2367">ClassTypes  = (type(_x), )
MethodTypes = (type(_x.m), )
isInstance = isinstance


try:
    object
except NameError:
    # Python 2.1
    try:
        from ExtensionClass import Base as object
    except ImportError:
        class object: pass
	&lt;&lt; class object declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2368">else:
    # Python 2.2
</t>
<t tx="ekr.20040104185913.2369">ClassTypes += (type, )
object = object


try:
import ExtensionClass
except ImportError:
# ExtensionClass is not present
pass
else:
# ExtensionClass is present
def isInstance(ob, klass):
    if type(type(ob)) is type(klass):
        return isinstance(ob, klass)
    return 0
</t>
<t tx="ekr.20040104185913.2370">class _x(ExtensionClass.Base):
	@others
</t>
<t tx="ekr.20040104185913.2371">def m(self): pass
</t>
<t tx="ekr.20040104185913.2372">&lt;&lt; iclass declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2373">import warnings
warnings.warn("""\
The Interface.iclass module is no more. 
This is a stub module to allow ZClasses that subclass ObjectManager 
to continue to function - please fix your ZClasses (using the 'Subobjects' 
tab)""", 
DeprecationWarning)
# Old interface object. Provided for backwards compatibility - allows ZClasses
# that subclass ObjectManager to be used in 2.6.
</t>
<t tx="ekr.20040104185913.2374">class Interface:
	@others
</t>
<t tx="ekr.20040104185913.2375">def __init__(self, *args, **kwargs):
   pass
</t>
<t tx="ekr.20040104185913.2376">&lt;&lt; pprint declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2377">""" Pretty-Print an Interface object as structured text (Yum) """

import string

</t>
<t tx="ekr.20040104185913.2378">def trim_doc_string(text):
    """
    Trims a doc string to make it format
    correctly with structured text.
    """
    text=text.strip()
    text=text.replace('\r\n', '\n')
    lines=text.split('\n')
    nlines=[lines[0]]
    if len(lines) &gt; 1:
        min_indent=None
        for line in lines[1:]:
            indent=len(line) - len(line.lstrip())
            if indent &lt; min_indent or min_indent is None:
                min_indent=indent
        for line in lines[1:]:
            nlines.append(line[min_indent:])
    return '\n'.join(nlines, '\n')
</t>
<t tx="ekr.20040104185913.2379">def justify_and_indent(text, level, munge=0, width=72):
    """ indent and justify text, rejustify (munge) if specified """

    lines = []

    if munge:
        line = " " * level
        text = (string.translate(text, string.maketrans("\r\n", "  "))).strip.split()

        for word in text:
            line = ''.join([line, word])
            if len(line) &gt; width:
                lines.append(line)
                line = " " * level
        else:
            lines.append(line)

        return '\n'.join(lines)

    else:
        text = text.replace("\r\n", "\n").split( "\n")

        for line in text:
            lines.append( (" " * level) + line)

        return '\n'.join(lines)
</t>
<t tx="ekr.20040104185913.2380">def interface_as_stx(I, munge=0):
    """ Output structured text format.  Note, this will wack any existing
    'structured' format of the text.  """

    outp = "%s\n\n" % I.getName()
    level = 1

    if I.getDoc():
        outp = outp + justify_and_indent(trim_doc_string(I.getDoc()), level) + "\n\n"

    if I.getBases():
        outp = outp + (" " * level) + "This interface extends:\n\n"
        level = level + 1
        for b in I.getBases():
            item = "o %s" % b.getName()
            outp = outp + justify_and_indent(trim_doc_string(item), level, munge) + "\n\n"
        level = level - 1

    level = level + 1
    for name, desc in I.namesAndDescriptions():
        if hasattr(desc, 'getSignatureRepr'):   # ugh...
            item = "%s%s -- %s" % (desc.getName(), desc.getSignatureRepr(), desc.getDoc())
        else:
            item = "%s -- %s" % (desc.getName(), desc.getDoc())

        outp = outp + justify_and_indent(trim_doc_string(item), level, munge)  + "\n\n"

    return outp
</t>
<t tx="ekr.20040104185913.2381">#!/usr/bin/env python

&lt;&lt; copyright &gt;&gt;

"""
Generate method skeletins for intefaces.

Usage: python pyskel.py dotted_name

Example:

    cd lib/python
    python Interface/pyskel.py Zope.App.Security.IRoleService.IRoleService

The dotted name is the module name and interface object name connected
with a dot.

Revision information: $Id: pyskel.py,v 1.6 2002/08/14 21:35:32 mj Exp $
"""

&lt;&lt; pyskel imports &gt;&gt;

class_re = re.compile(r'\s*class\s+([a-zA-Z_][a-zA-Z0-9_]*)')
def_re = re.compile(r'\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)')
attr_re = re.compile(r'\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*Attribute')

@others

if __name__ == '__main__':
    for a in sys.argv[1:]:
        skel(a)
</t>
<t tx="ekr.20040104185913.2382">import sys, os, re

sys.path.insert(0, os.getcwd())

from _object import isInstance

from types import ModuleType
from Interface.Method import Method
from Interface.Attribute import Attribute</t>
<t tx="ekr.20040104185913.2383">def rskel(iface, print_iface=1):
    name = "%s.%s" % (iface.__module__, iface.__name__)

    file = resolve(iface.__module__).__file__
    if file.endswith('pyc'):
        file = file[:-1]
    order = guessOrder(open(file))
    namesAndDescriptions =  getAttributesInOrder(iface, order)

    if namesAndDescriptions and print_iface:
        print
        print "    ######################################"
        print "    # from:", name

    for aname, ades in namesAndDescriptions:
        if isInstance(ades, Method):
            sig = ades.getSignatureString()[1:-1]
            if sig: sig = "self, %s" % sig
            else:   sig = "self"
            print
            print "    def %s(%s):" % (aname, sig)
            print "        'See %s'" % name

        elif isInstance(ades, Attribute):
            print
            print "    # See %s" % name
            print "    %s = None" %aname

    for base in iface.__bases__:
        if base.__name__ not in ('Interface',):
            rskel(base)
</t>
<t tx="ekr.20040104185913.2384">def skel(name):
    iface = resolve(name)
    class_name = iface.__name__
    if class_name.startswith('I'):
        class_name = class_name[1:]
    print "from %s import %s" % (iface.__module__, iface.__name__)
    print
    print "class %s:" %class_name
    print
    print "    __implements__ = ", iface.__name__
    print
    print "    ############################################################"
    print "    # Implementation methods for interface"
    print "    #", name

    rskel(iface, 0)

    print
    print "    #"
    print "    ############################################################"
</t>
<t tx="ekr.20040104185913.2385">def resolve(name, _silly=('__doc__',), _globals={}):
    # Support for file path syntax; this way I can use TAB to search for
    # the module.
    if '/' in name or name.endswith('.py'):
        # We got a relative path. Let's try to get the full one and then
        # make a package path out of it.
        if not name.startswith('/'):
            cwd = os.getcwd()
            for path in sys.path[1:]: # Yeah, we need to exclude the cwd itself
                if path != '' and cwd.startswith(path):
                    name = os.path.join(cwd[len(path)+1:], name)
                    name = os.path.normpath(name)
                    break

        # get rid of the file ending :)
        if name.endswith('.py'):
            name = name[:-3]
        name = name.replace('/', '.')

    # Now to the regular lookup
    if name[:1]=='.':
        name='ZopeProducts'+name

    if name[-1:] == '.':
        name = name[:-1]
        repeat = 1
    else:
        repeat = 0

    names=name.split('.')
    last=names[-1]
    mod='.'.join(names[:-1])

    while 1:
        m=__import__(mod, _globals, _globals, _silly)
        try:
            a=getattr(m, last)
        except AttributeError:
            pass
        else:
            if not repeat or (type(a) is not ModuleType):
                return a
        mod += '.' + last
</t>
<t tx="ekr.20040104185913.2386">def guessOrder(source_file):
    order = {}  # { class name -&gt; list of methods }
    lines = source_file.readlines()
    class_name = None
    for line in lines:
        m = class_re.match(line)
        if m and m.groups():
            class_name = m.groups()[0]
        else:
            for m in (def_re.match(line),
                      attr_re.match(line)):
                if m and m.groups():
                    def_name = m.groups()[0]
                    name_order = order.get(class_name)
                    if name_order is None:
                        name_order = []
                        order[class_name] = name_order
                    name_order.append(def_name)

    return order
</t>
<t tx="ekr.20040104185913.2387">def getAttributesInOrder(interface, order):
    # order is the dictionary returned from guessOrder().
    # interface is a metaclass-based interface object.
    name_order = order.get(interface.__name__)

    if name_order is None:
        # Something's wrong.  Oh well.
        return interface.__dict__.items()
    else:
        items = []
        for key, value in interface.namesAndDescriptions():
            if key in name_order:
                items.append((name_order.index(key), key, value))
            else:
                items.append((99999, key, value))  # Go to end.
        items.sort()
        return map(lambda item: item[1:], items)
</t>
<t tx="ekr.20040104185913.2388"></t>
<t tx="ekr.20040104185913.2389">&lt;&lt; Mapping declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2390">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: Mapping.py,v 1.3 2002/08/14 21:35:33 mj Exp $
"""

from Interface import Interface

</t>
<t tx="ekr.20040104185913.2391">class IReadMapping(Interface):
    """Basic mapping interface
    """
	@others
</t>
<t tx="ekr.20040104185913.2392">def __getitem__(key):
    """Get a value for a key

    A KeyError is raised if there is no value for the key.
    """
</t>
<t tx="ekr.20040104185913.2393">def get(key, default=None):
    """Get a value for a key

    The default is returned if there is no value for the key.
    """
</t>
<t tx="ekr.20040104185913.2394">def has_key(key):
    """Tell if a key exists in the mapping
    """
</t>
<t tx="ekr.20040104185913.2395">class IEnumerableMapping(IReadMapping):
    """Mapping objects whose items can be enumerated
    """
	@others
</t>
<t tx="ekr.20040104185913.2396">def keys():
    """Return the keys of the mapping object
    """
</t>
<t tx="ekr.20040104185913.2397">def values():
    """Return the values of the mapping object
    """
</t>
<t tx="ekr.20040104185913.2398">def items():
    """Return the items of the mapping object
    """
</t>
<t tx="ekr.20040104185913.2399">def __len__():
    """Return the number of items
    """
</t>
<t tx="ekr.20040104185913.2400">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.2401"></t>
<t tx="ekr.20040104185913.2402">&lt;&lt; BaseTestMapping declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2403">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: BaseTestMapping.py,v 1.3 2002/08/14 21:35:33 mj Exp $
"""

from operator import __getitem__

</t>
<t tx="ekr.20040104185913.2404">def testIReadMapping(self, inst, state, absent):

    for key in state:
        self.assertEqual(inst[key], state[key])
        self.assertEqual(inst.get(key, None), state[key])
        self.failUnless(inst.has_key(key))

    for key in absent:
        self.assertEqual(inst.get(key, None), None)
        self.assertEqual(inst.get(key), None)
        self.assertEqual(inst.get(key, self), self)
        self.assertRaises(KeyError, __getitem__, inst, key)
</t>
<t tx="ekr.20040104185913.2405">def test_keys(self, inst, state):
    """Return the keys of the mapping object
    """
    inst_keys = list(inst.keys()); inst_keys.sort()
    state_keys = list(state.keys()) ; state_keys.sort()
    self.assertEqual(inst_keys, state_keys)
</t>
<t tx="ekr.20040104185913.2406">def test_values(self, inst, state):
    """Return the values of the mapping object
    """
    inst_values = list(inst.values()); inst_values.sort()
    state_values = list(state.values()) ; state_values.sort()
    self.assertEqual(inst_values, state_values)
</t>
<t tx="ekr.20040104185913.2407">def test_items(self, inst, state):
    """Return the items of the mapping object
    """
    inst_items = list(inst.items()); inst_items.sort()
    state_items = list(state.items()) ; state_items.sort()
    self.assertEqual(inst_items, state_items)
</t>
<t tx="ekr.20040104185913.2408">def test___len__(self, inst, state):
    """Return the number of items
    """
    self.assertEqual(len(inst), len(state))
</t>
<t tx="ekr.20040104185913.2409">def testIEnumerableMapping(self, inst, state):
    test_keys(self, inst, state)
    test_items(self, inst, state)
    test_values(self, inst, state)
    test___len__(self, inst, state)
</t>
<t tx="ekr.20040104185913.2410">class BaseTestIReadMapping:
	@others
</t>
<t tx="ekr.20040104185913.2411">def testIReadMapping(self):

    inst = self._IReadMapping__sample()
    state = self._IReadMapping__stateDict()
    absent = self._IReadMapping__absentKeys()

    testIReadMapping(self, inst, state, absent)
</t>
<t tx="ekr.20040104185913.2412">class BaseTestIEnumerableMapping(BaseTestIReadMapping):
    """Mapping objects whose items can be enumerated
    """
	@others
</t>
<t tx="ekr.20040104185913.2413">def test_keys(self):
    """Return the keys of the mapping object
    """
    inst = self._IEnumerableMapping__sample()
    state = self._IEnumerableMapping__stateDict()
    test_keys(self, inst, state)
</t>
<t tx="ekr.20040104185913.2414">def test_values(self):
    """Return the values of the mapping object
    """
    inst = self._IEnumerableMapping__sample()
    state = self._IEnumerableMapping__stateDict()
    test_values(self, inst, state)
</t>
<t tx="ekr.20040104185913.2415">def test_items(self):
    """Return the items of the mapping object
    """
    inst = self._IEnumerableMapping__sample()
    state = self._IEnumerableMapping__stateDict()
    test_items(self, inst, state)
</t>
<t tx="ekr.20040104185913.2416">def test___len__(self):
    """Return the number of items
    """
    inst = self._IEnumerableMapping__sample()
    state = self._IEnumerableMapping__stateDict()
    test___len__(self, inst, state)
</t>
<t tx="ekr.20040104185913.2417">def _IReadMapping__stateDict(self):
    return self._IEnumerableMapping__stateDict()
</t>
<t tx="ekr.20040104185913.2418">def _IReadMapping__sample(self):
    return self._IEnumerableMapping__sample()
</t>
<t tx="ekr.20040104185913.2419">def _IReadMapping__absentKeys(self):
    return self._IEnumerableMapping__absentKeys()
</t>
<t tx="ekr.20040104185913.2420">&lt;&lt; copyright &gt;&gt;
</t>
<t tx="ekr.20040104185913.2421"></t>
<t tx="ekr.20040104185913.2422">&lt;&lt; copyright &gt;&gt;

""" Packagize. """
</t>
<t tx="ekr.20040104185913.2423">&lt;&lt; IFoo declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2424">&lt;&lt; copyright &gt;&gt;

from Interface import Interface

</t>
<t tx="ekr.20040104185913.2425">class IFoo( Interface ):
    """
        Dummy interface for unit tests.
    """
	@others
</t>
<t tx="ekr.20040104185913.2426">def bar( baz ):
    """
        Just a note.
    """
</t>
<t tx="ekr.20040104185913.2427">&lt;&lt; dummy declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2428">&lt;&lt; copyright &gt;&gt;

from Interface.tests.IFoo import IFoo

__implements__ = IFoo

</t>
<t tx="ekr.20040104185913.2429">def bar( baz ):
    pass
</t>
<t tx="ekr.20040104185913.2430">&lt;&lt; testDocument declarations &gt;&gt;
@others

if __name__=='__main__':
    main(defaultTest='test_suite')
</t>
<t tx="ekr.20040104185913.2431">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: testDocument.py,v 1.5 2002/08/14 21:35:33 mj Exp $
"""

from unittest import TestCase, TestSuite, main, makeSuite
from Interface import Interface
from Interface.Attribute import Attribute

</t>
<t tx="ekr.20040104185913.2432">class Test(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2433">def testBlech(self):
    from Interface.Document import asStructuredText

    self.assertEqual(asStructuredText(I2), '''\
I2

I2 doc

This interface extends:

o _I1

Attributes:

a1 -- no documentation

a2 -- a2 doc

Methods:

f21() -- f21 doc

f22() -- no documentation

f23() -- f23 doc

''')
</t>
<t tx="ekr.20040104185913.2434">def test_suite():
    return TestSuite((
        makeSuite(Test),
        ))
</t>
<t tx="ekr.20040104185913.2435">class _I1(Interface):
	@others
</t>
<t tx="ekr.20040104185913.2436">def f11(): pass
</t>
<t tx="ekr.20040104185913.2437">def f12(): pass
</t>
<t tx="ekr.20040104185913.2438">class I2(_I1):
	&lt;&lt; class I2 declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2439">"I2 doc"

a1 = Attribute('a1')
a2 = Attribute('a2', 'a2 doc')

</t>
<t tx="ekr.20040104185913.2440">def f21(): "f21 doc"
</t>
<t tx="ekr.20040104185913.2441">def f22(): pass
</t>
<t tx="ekr.20040104185913.2442">def f23(): "f23 doc"
</t>
<t tx="ekr.20040104185913.2443">&lt;&lt; testElement declarations &gt;&gt;
@others

if __name__=="__main__":
    main()
</t>
<t tx="ekr.20040104185913.2444">&lt;&lt; copyright &gt;&gt;

import unittest
from Interface._Element import Element

</t>
<t tx="ekr.20040104185913.2445">class ElementTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2446">def test_taggedValues(self):
    """Test that we can update tagged values of more than one element
    """
    
    e1 = Element("foo")
    e2 = Element("bar")
    e1.setTaggedValue("x", 1)
    e2.setTaggedValue("x", 2)
    self.assertEqual(e1.getTaggedValue("x"), 1)
    self.assertEqual(e2.getTaggedValue("x"), 2)
</t>
<t tx="ekr.20040104185913.2447">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(ElementTests))
    return suite
</t>
<t tx="ekr.20040104185913.2448">def test_suite():
    return unittest.makeSuite(ElementTests)
</t>
<t tx="ekr.20040104185913.2449">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2450">&lt;&lt; testImplements declarations &gt;&gt;
@others

if __name__=='__main__':
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2451">&lt;&lt; copyright &gt;&gt;

from __future__ import nested_scopes
from Interface import Interface
from Interface.Implements import implements
from Interface.Exceptions import DoesNotImplement, BrokenImplementation
from Interface.Exceptions import BrokenMethodImplementation

import unittest, sys

</t>
<t tx="ekr.20040104185913.2452">class Test(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2453">def testSimple(self):

    class I(Interface):
        def f(): pass

    class C: pass

    self.assertRaises(BrokenImplementation, implements, C, I)

    C.f=lambda self: None

    implements(C, I)

    self.assertEqual(C.__implements__, I)
</t>
<t tx="ekr.20040104185913.2454">def testAdd(self):

    class I(Interface):
        def f(): pass

    class I2(Interface):
        def g(): pass

    class C:
        __implements__=I2

    self.assertRaises(BrokenImplementation, implements, C, I)
    self.assertRaises(BrokenImplementation, implements, C, I2)

    C.f=lambda self: None

    implements(C, I)

    self.assertEqual(C.__implements__, (I2, I))
    self.assertRaises(BrokenImplementation, implements, C, I2)

    C.g=C.f
    implements(C, I)
    implements(C, I2)
</t>
<t tx="ekr.20040104185913.2455">def test_suite():
    loader=unittest.TestLoader()
    return loader.loadTestsFromTestCase(Test)
</t>
<t tx="ekr.20040104185913.2456">&lt;&lt; testInterface declarations &gt;&gt;
@others

if __name__=="__main__":
    main()
</t>
<t tx="ekr.20040104185913.2457">&lt;&lt; copyright &gt;&gt;

import unittest
import Interface
from unitfixtures import *  # hehehe
from Interface.Exceptions import BrokenImplementation
from Interface.Implements import instancesOfObjectImplements
from Interface.Implements import objectImplements
from Interface import Interface
from Interface.Attribute import Attribute

</t>
<t tx="ekr.20040104185913.2458">class InterfaceTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2459">def setUp(self):
    pass
</t>
<t tx="ekr.20040104185913.2460">def tearDown(self):
    pass
</t>
<t tx="ekr.20040104185913.2461">def testClassImplements(self):
    assert IC.isImplementedByInstancesOf(C)

    assert I1.isImplementedByInstancesOf(A)
    assert I1.isImplementedByInstancesOf(B)
    assert not I1.isImplementedByInstancesOf(C)
    assert I1.isImplementedByInstancesOf(D)
    assert I1.isImplementedByInstancesOf(E)

    assert not I2.isImplementedByInstancesOf(A)
    assert I2.isImplementedByInstancesOf(B)
    assert not I2.isImplementedByInstancesOf(C)
    assert not I2.isImplementedByInstancesOf(D)
    assert not I2.isImplementedByInstancesOf(E)
</t>
<t tx="ekr.20040104185913.2462">def testUtil(self):
    f = instancesOfObjectImplements
    assert IC in f(C)
    assert I1 in f(A)
    assert not I1 in f(C)
    assert I2 in f(B)
    assert not I2 in f(C)

    f = objectImplements
    assert IC in f(C())
    assert I1 in f(A())
    assert not I1 in f(C())
    assert I2 in f(B())
    assert not I2 in f(C())
</t>
<t tx="ekr.20040104185913.2463">def testObjectImplements(self):
    assert IC.isImplementedBy(C())

    assert I1.isImplementedBy(A())
    assert I1.isImplementedBy(B())
    assert not I1.isImplementedBy(C())
    assert I1.isImplementedBy(D())
    assert I1.isImplementedBy(E())

    assert not I2.isImplementedBy(A())
    assert I2.isImplementedBy(B())
    assert not I2.isImplementedBy(C())
    assert not I2.isImplementedBy(D())
    assert not I2.isImplementedBy(E())
</t>
<t tx="ekr.20040104185913.2464">def testDeferredClass(self):
    a = A()
    self.assertRaises(BrokenImplementation, a.ma)
</t>
<t tx="ekr.20040104185913.2465">def testInterfaceExtendsInterface(self):
    assert BazInterface.extends(BobInterface)
    assert BazInterface.extends(BarInterface)
    assert BazInterface.extends(FunInterface)
    assert not BobInterface.extends(FunInterface)
    assert not BobInterface.extends(BarInterface)
    assert BarInterface.extends(FunInterface)
    assert not BarInterface.extends(BazInterface)
</t>
<t tx="ekr.20040104185913.2466">def testVerifyImplementation(self):
    from Interface.Verify import verifyClass
    assert verifyClass(FooInterface, Foo)
    assert Interface.isImplementedBy(I1)
</t>
<t tx="ekr.20040104185913.2467">def test_names(self):
    names = list(_I2.names()); names.sort()
    self.assertEqual(names, ['f21', 'f22', 'f23'])
    names = list(_I2.names(1)); names.sort()
    self.assertEqual(names, ['a1', 'f11', 'f12', 'f21', 'f22', 'f23'])
</t>
<t tx="ekr.20040104185913.2468">def test_namesAndDescriptions(self):
    names = [nd[0] for nd in _I2.namesAndDescriptions()]; names.sort()
    self.assertEqual(names, ['f21', 'f22', 'f23'])
    names = [nd[0] for nd in _I2.namesAndDescriptions(1)]; names.sort()
    self.assertEqual(names, ['a1', 'f11', 'f12', 'f21', 'f22', 'f23'])

    for name, d in _I2.namesAndDescriptions(1):
        self.assertEqual(name, d.__name__)
</t>
<t tx="ekr.20040104185913.2469">def test_getDescriptionFor(self):
    self.assertEqual(_I2.getDescriptionFor('f11').__name__, 'f11')
    self.assertEqual(_I2.getDescriptionFor('f22').__name__, 'f22')
    self.assertEqual(_I2.queryDescriptionFor('f33', self), self)
    self.assertRaises(KeyError, _I2.getDescriptionFor, 'f33')
</t>
<t tx="ekr.20040104185913.2470">def testAttr(self):
    description = _I2.getDescriptionFor('a1')
    self.assertEqual(description.__name__, 'a1')
    self.assertEqual(description.__doc__, 'This is an attribute')
</t>
<t tx="ekr.20040104185913.2471">class _I1(Interface):
	&lt;&lt; class _I1 declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2472">a1 = Attribute("This is an attribute")

</t>
<t tx="ekr.20040104185913.2473">def f11(): pass
</t>
<t tx="ekr.20040104185913.2474">def f12(): pass
</t>
<t tx="ekr.20040104185913.2475">class __I1(_I1): pass
</t>
<t tx="ekr.20040104185913.2476">class ___I1(__I1): pass
</t>
<t tx="ekr.20040104185913.2477">class _I2(___I1):
	@others
</t>
<t tx="ekr.20040104185913.2478">def f21(): pass
</t>
<t tx="ekr.20040104185913.2479">def f22(): pass
</t>
<t tx="ekr.20040104185913.2480">def f23(): pass
</t>
<t tx="ekr.20040104185913.2481">def test_suite():
    return unittest.makeSuite(InterfaceTests)
</t>
<t tx="ekr.20040104185913.2482">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2483">&lt;&lt; testVerify declarations &gt;&gt;
@others

if __name__=='__main__':
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2484">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: testVerify.py,v 1.3.6.1 2002/11/11 19:55:33 mj Exp $
"""
from __future__ import nested_scopes


from Interface import Interface
from Interface.Verify import verifyClass, verifyObject
from Interface.Exceptions import DoesNotImplement, BrokenImplementation
from Interface.Exceptions import BrokenMethodImplementation

import unittest, sys

</t>
<t tx="ekr.20040104185913.2485">class Test(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2486">def testNotImplemented(self):

    class C: pass

    class I(Interface): pass

    self.assertRaises(DoesNotImplement, verifyClass, I, C)

    C.__implements__=I

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2487">def testMissingAttr(self):

    class I(Interface):
        def f(): pass

    class C:

        __implements__=I

    self.assertRaises(BrokenImplementation, verifyClass, I, C)

    C.f=lambda self: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2488">def testMissingAttr_with_Extended_Interface(self):
   
    class II(Interface):
        def f():
            pass

    class I(II):
        pass

    class C:

        __implements__=I

    self.assertRaises(BrokenImplementation, verifyClass, I, C)

    C.f=lambda self: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2489">def testWrongArgs(self):

    class I(Interface):
        def f(a): pass

    class C:

        def f(self, b): pass

        __implements__=I

    # We no longer require names to match.
    #self.assertRaises(BrokenMethodImplementation, verifyClass, I, C)

    C.f=lambda self, a: None

    verifyClass(I, C)

    C.f=lambda self, **kw: None

    self.assertRaises(BrokenMethodImplementation, verifyClass, I, C)

    C.f=lambda self, a, *args: None

    verifyClass(I, C)

    C.f=lambda self, a, *args, **kw: None

    verifyClass(I, C)

    C.f=lambda self, *args: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2490">def testExtraArgs(self):

    class I(Interface):
        def f(a): pass

    class C:

        def f(self, a, b): pass

        __implements__=I

    self.assertRaises(BrokenMethodImplementation, verifyClass, I, C)

    C.f=lambda self, a: None

    verifyClass(I, C)

    C.f=lambda self, a, b=None: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2491">def testNoVar(self):

    class I(Interface):
        def f(a, *args): pass

    class C:

        def f(self, a): pass

        __implements__=I

    self.assertRaises(BrokenMethodImplementation, verifyClass, I, C)

    C.f=lambda self, a, *foo: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2492">def testNoKW(self):

    class I(Interface):
        def f(a, **args): pass

    class C:

        def f(self, a): pass

        __implements__=I

    self.assertRaises(BrokenMethodImplementation, verifyClass, I, C)

    C.f=lambda self, a, **foo: None

    verifyClass(I, C)
</t>
<t tx="ekr.20040104185913.2493">def testModule(self):

    from Interface.tests.IFoo import IFoo
    from Interface.tests import dummy

    verifyObject(IFoo, dummy)
</t>
<t tx="ekr.20040104185913.2494">def test_suite():
    loader=unittest.TestLoader()
    return loader.loadTestsFromTestCase(Test)
</t>
<t tx="ekr.20040104185913.2495">&lt;&lt; testVisitImplements declarations &gt;&gt;
@others

if __name__=='__main__':
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.2496">&lt;&lt; copyright &gt;&gt;

import unittest, sys

from Interface.Implements import visitImplements
from Interface import Interface
from Interface.Exceptions import BadImplements

</t>
<t tx="ekr.20040104185913.2497">class I1(Interface): pass
</t>
<t tx="ekr.20040104185913.2498">class I2(Interface): pass
</t>
<t tx="ekr.20040104185913.2499">class I3(Interface): pass
</t>
<t tx="ekr.20040104185913.2500">class Test(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.2501">def testSimpleImplements(self):
    data=[]
    visitImplements(I1, None, data.append)
    self.assertEqual(data, [I1])
</t>
<t tx="ekr.20040104185913.2502">def testSimpleBadImplements(self):
    data=[]
    self.assertRaises(BadImplements,
                      visitImplements, unittest, None, data.append)
</t>
<t tx="ekr.20040104185913.2503">def testComplexImplements(self):
    data=[]
    visitImplements((I1, (I2, I3)), None, data.append)
    data = map(lambda i: i.__name__, data)
    self.assertEqual(data, ['I1', 'I2', 'I3'])
</t>
<t tx="ekr.20040104185913.2504">def testComplexBadImplements(self):
    data=[]
    self.assertRaises(BadImplements,
                      visitImplements, (I1, (I2, unittest)),
                      None, data.append)
</t>
<t tx="ekr.20040104185913.2505">def test_suite():
    loader=unittest.TestLoader()
    return loader.loadTestsFromTestCase(Test)
</t>
<t tx="ekr.20040104185913.2506">&lt;&lt; unitfixtures declarations &gt;&gt;
@others
new = Interface.__class__
FunInterface = new('FunInterface')
BarInterface = new('BarInterface', [FunInterface])
BobInterface = new('BobInterface')
BazInterface = new('BazInterface', [BobInterface, BarInterface])
</t>
<t tx="ekr.20040104185913.2507">&lt;&lt; copyright &gt;&gt;

from Interface import Interface
from Interface.Attribute import Attribute

</t>
<t tx="ekr.20040104185913.2508">class mytest(Interface):
	&lt;&lt; class mytest declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2509">pass

</t>
<t tx="ekr.20040104185913.2510">class C:
	@others
</t>
<t tx="ekr.20040104185913.2511">def m1(self, a, b):
    "return 1"
    return 1
</t>
<t tx="ekr.20040104185913.2512">def m2(self, a, b):
    "return 2"
    return 2
</t>
<t tx="ekr.20040104185913.2513"># testInstancesOfClassImplements




#  YAGNI IC=Interface.impliedInterface(C)
class IC(Interface):
	@others
</t>
<t tx="ekr.20040104185913.2514">def m1(a, b):
    "return 1"
</t>
<t tx="ekr.20040104185913.2515">def m2(a, b):
    "return 2"
</t>
<t tx="ekr.20040104185913.2516">C.__implements__=IC

class I1(Interface):
	@others
</t>
<t tx="ekr.20040104185913.2517">def ma():
    "blah"
</t>
<t tx="ekr.20040104185913.2518">class I2(I1): pass
</t>
<t tx="ekr.20040104185913.2519">class I3(Interface): pass
</t>
<t tx="ekr.20040104185913.2520">class I4(Interface): pass
</t>
<t tx="ekr.20040104185913.2521">class A(I1.deferred()):
	&lt;&lt; class A declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2522">__implements__=I1

</t>
<t tx="ekr.20040104185913.2523">class B:
	&lt;&lt; class B declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2524">__implements__=I2, I3

</t>
<t tx="ekr.20040104185913.2525">class D(A, B): pass
</t>
<t tx="ekr.20040104185913.2526">class E(A, B):
	&lt;&lt; class E declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2527">__implements__ = A.__implements__, C.__implements__


</t>
<t tx="ekr.20040104185913.2528">class FooInterface(Interface):
    """ This is an Abstract Base Class """
	&lt;&lt; class FooInterface declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2529">foobar = Attribute("fuzzed over beyond all recognition")

</t>
<t tx="ekr.20040104185913.2530">def aMethod(foo, bar, bingo):
    """ This is aMethod """
</t>
<t tx="ekr.20040104185913.2531">def anotherMethod(foo=6, bar="where you get sloshed", bingo=(1,3,)):
    """ This is anotherMethod """
</t>
<t tx="ekr.20040104185913.2532">def wammy(zip, *argues):
    """ yadda yadda """
</t>
<t tx="ekr.20040104185913.2533">def useless(**keywords):
    """ useless code is fun! """
</t>
<t tx="ekr.20040104185913.2534">class Foo:
    """ A concrete class """
	&lt;&lt; class Foo declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2535">__implements__ = FooInterface,

foobar = "yeah"

</t>
<t tx="ekr.20040104185913.2536">def aMethod(self, foo, bar, bingo):
    """ This is aMethod """
    return "barf!"
</t>
<t tx="ekr.20040104185913.2537">def anotherMethod(self, foo=6, bar="where you get sloshed", bingo=(1,3,)):
    """ This is anotherMethod """
    return "barf!"
</t>
<t tx="ekr.20040104185913.2538">def wammy(self, zip, *argues):
    """ yadda yadda """
    return "barf!"
</t>
<t tx="ekr.20040104185913.2539">def useless(self, **keywords):
    """ useless code is fun! """
    return "barf!"
</t>
<t tx="ekr.20040104185913.2540">foo_instance = Foo()

class Blah:
	&lt;&lt; class Blah declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2541">pass

</t>
<t tx="ekr.20040104185913.2542"></t>
<t tx="ekr.20040104185913.2543">&lt;&lt; copyright &gt;&gt;
__doc__='''Application support

$Id: Application.py,v 1.188.4.3 2003/06/24 13:44:11 chrism Exp $'''
__version__='$Revision: 1.188.4.3 $'[11:-2]

&lt;&lt; Application imports &gt;&gt;

@others</t>
<t tx="ekr.20040104185913.2544">import Globals,Folder,os,sys,App.Product, App.ProductRegistry, misc_
import time, traceback, os,  Products
from DateTime import DateTime
from AccessControl.User import UserFolder
from App.ApplicationManager import ApplicationManager
from webdav.NullResource import NullResource
from FindSupport import FindSupport
from urllib import quote
from StringIO import StringIO
from AccessControl.PermissionRole import PermissionRole
from App.ProductContext import ProductContext
from misc_ import Misc_
import ZDOM
from zLOG import LOG, ERROR, WARNING, INFO
from HelpSys.HelpSys import HelpSys
from Acquisition import aq_base
from App.Product import doInstall</t>
<t tx="ekr.20040104185913.2545">class Application(Globals.ApplicationDefaultPermissions,
	&lt;&lt; class Application declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2546">ZDOM.Root, Folder.Folder,
App.ProductRegistry.ProductRegistry, FindSupport):
"""Top-level system object"""
title    ='Zope'
#__roles__=['Manager', 'Anonymous']
__defined_roles__=('Manager','Anonymous','Owner')
web__form__method='GET'
isTopLevelPrincipiaApplicationObject=1
_isBeingUsedAsAMethod_=0

# Create the help system object
HelpSys=HelpSys('HelpSys')

p_=misc_.p_
misc_=misc_.misc_

_reserved_names=('Control_Panel',
   'browser_id_manager',
   'temp_folder')

# This class-default __allow_groups__ ensures that the
# emergency user can still access the system if the top-level
# UserFolder is deleted. This is necessary to allow people
# to replace the top-level UserFolder object.

__allow_groups__=UserFolder()

# Set the universal default method to index_html
_object_manager_browser_default_id = 'index_html'

</t>
<t tx="ekr.20040104185913.2547">def title_and_id(self): return self.title
</t>
<t tx="ekr.20040104185913.2548">def title_or_id(self): return self.title
</t>
<t tx="ekr.20040104185913.2549">def __init__(self):
    # Initialize users
    uf=UserFolder()
    self.__allow_groups__=uf
    self._setObject('acl_users', uf)

    # Initialize control panel
    cpl=ApplicationManager()
    cpl._init()
    self._setObject('Control_Panel', cpl)
    get_transaction().note("Created Zope Application")
</t>
<t tx="ekr.20040104185913.2550">def id(self):
    try:    return self.REQUEST['SCRIPT_NAME'][1:]
    except: return self.title
</t>
<t tx="ekr.20040104185913.2551">def __class_init__(self): Globals.default__class_init__(self)
</t>
<t tx="ekr.20040104185913.2552">def PrincipiaRedirect(self,destination,URL1):
    """Utility function to allow user-controlled redirects"""
    if destination.find('//') &gt;= 0: raise 'Redirect', destination
    raise 'Redirect', ("%s/%s" % (URL1, destination))
</t>
<t tx="ekr.20040104185913.2553">Redirect=ZopeRedirect=PrincipiaRedirect

def __bobo_traverse__(self, REQUEST, name=None):

    try: return getattr(self, name)
    except AttributeError: pass
    try: return self[name]
    except KeyError: pass
    method=REQUEST.get('REQUEST_METHOD', 'GET')
    if not method in ('GET', 'POST'):
        return NullResource(self, name, REQUEST).__of__(self)

    # Waaa. unrestrictedTraverse calls us with a fake REQUEST.
    # There is proabably a better fix for this.
    try: REQUEST.RESPONSE.notFoundError("%s\n%s" % (name, method))
    except AttributeError:
        raise KeyError, name
</t>
<t tx="ekr.20040104185913.2554">def PrincipiaTime(self, *args):
    """Utility function to return current date/time"""
    return apply(DateTime, args)
</t>
<t tx="ekr.20040104185913.2555">ZopeTime=PrincipiaTime

ZopeAttributionButton__roles__=None
def ZopeAttributionButton(self):
    """Returns an HTML fragment that displays the 'powered by zope'
    button along with a link to the Zope site."""
    return '&lt;a href="http://www.zope.org/Credits" target="_top"&gt;&lt;img ' \
           'src="%s/p_/ZopeButton" width="115" height="50" ' \
           'border="0" alt="Powered by Zope" /&gt;&lt;/a&gt;' % self.REQUEST.BASE1
</t>
<t tx="ekr.20040104185913.2556">def DELETE(self, REQUEST, RESPONSE):
    """Delete a resource object."""
    self.dav__init(REQUEST, RESPONSE)
    raise 'Forbidden', 'This resource cannot be deleted.'
</t>
<t tx="ekr.20040104185913.2557">def MOVE(self, REQUEST, RESPONSE):
    """Move a resource to a new location."""
    self.dav__init(REQUEST, RESPONSE)
    raise 'Forbidden', 'This resource cannot be moved.'
</t>
<t tx="ekr.20040104185913.2558">test_url___allow_groups__=None
test_url=ZopeAttributionButton

def absolute_url(self, relative=0):
    """Return an absolute url to the object. Note that the url
    will reflect the acquisition path of the object if the object
    has been acquired."""
    if relative: return ''
    return self.aq_acquire('REQUEST')['BASE1']
</t>
<t tx="ekr.20040104185913.2559">def getPhysicalPath(self):
    '''Returns a path that can be used to access this object again
    later, for example in a copy/paste operation.  Designed to
    be used with getPhysicalRoot().
    '''
    # We're at the base of the path.
    return ('',)
</t>
<t tx="ekr.20040104185913.2560">def getPhysicalRoot(self): return self
</t>
<t tx="ekr.20040104185913.2561">fixupZClassDependencies__roles__=()
def fixupZClassDependencies(self, rebuild=0):
    # Note that callers should not catch exceptions from this method
    # to ensure that the transaction gets aborted if the registry
    # cannot be rebuilt for some reason. Returns true if any ZClasses
    # were registered as a result of the call or the registry was
    # rebuilt.
    jar=self._p_jar
    result=0

    if rebuild:
        import BTree
        jar.root()['ZGlobals']=BTree.BTree()
        result=1

    zglobals =jar.root()['ZGlobals']
    reg_has_key=zglobals.has_key

    products=self.Control_Panel.Products
    for product in products.objectValues():
        items=list(product.objectItems())
        finished_dict={}
        finished = finished_dict.has_key
        while items:
            name, ob = items.pop()
            base=aq_base(ob)
            if finished(id(base)):
                continue
            finished_dict[id(base)] = None
            try:
                # Try to re-register ZClasses if they need it.
                if hasattr(base,'_register') and hasattr(base,'_zclass_'):
                    class_id=getattr(base._zclass_, '__module__', None)
                    if class_id and not reg_has_key(class_id):
                        ob._register()
                        result=1
                        if not rebuild:
                            LOG('Zope', INFO,
                                'Registered ZClass: %s' % ob.id
                                )
                # Include subobjects.
                if hasattr(base, 'objectItems'):
                    m = list(ob.objectItems())
                    items.extend(m)
                # Try to find ZClasses-in-ZClasses.
                if hasattr(base, 'propertysheets'):
                    ps = ob.propertysheets
                    if (hasattr(ps, 'methods') and
                        hasattr(ps.methods, 'objectItems')):
                        m = list(ps.methods.objectItems())
                        items.extend(m)
            except:
                LOG('Zope', WARNING,
                    'Broken objects exist in product %s.' % product.id,
                    error=sys.exc_info())

    return result
</t>
<t tx="ekr.20040104185913.2562">checkGlobalRegistry__roles__=()
def checkGlobalRegistry(self):
    """Check the global (zclass) registry for problems, which can
    be caused by things like disk-based products being deleted.
    Return true if a problem is found"""
    try:
        keys=list(self._p_jar.root()['ZGlobals'].keys())
    except:
        LOG('Zope', ERROR,
            'A problem was found when checking the global product '\
            'registry.  This is probably due to a Product being '\
            'uninstalled or renamed.  The traceback follows.',
            error=sys.exc_info())
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.2563">class Expired(Globals.Persistent):
	&lt;&lt; class Expired declarations &gt;&gt;
	@others

    __inform_commit__=__save__</t>
<t tx="ekr.20040104185913.2564">icon='p_/broken'

</t>
<t tx="ekr.20040104185913.2565">def __setstate__(self, s={}):
    dict=self.__dict__
    if s.has_key('id'):
        dict['id']=s['id']
    elif s.has_key('__name__'):
        dict['id']=s['__name__']
    else: dict['id']='Unknown'
    dict['title']='** Expired **'
</t>
<t tx="ekr.20040104185913.2566">def __save__(self):
    pass
</t>
<t tx="ekr.20040104185913.2567">def initialize(app):
    # Initialize the application

    # The following items marked b/c are backward compatibility hacks
    # which make sure that expected system objects are added to the
    # bobobase. This is required because the bobobase in use may pre-
    # date the introduction of certain system objects such as those
    # which provide Lever support.

    # b/c: Ensure that Control Panel exists.
    if not hasattr(app, 'Control_Panel'):
        cpl=ApplicationManager()
        cpl._init()
        app._setObject('Control_Panel', cpl)
        get_transaction().note('Added Control_Panel')
        get_transaction().commit()

    # Initialize the cache:
    app.Control_Panel.initialize_cache()

    # b/c: Ensure that a ProductFolder exists.
    if not hasattr(aq_base(app.Control_Panel), 'Products'):
        app.Control_Panel.Products=App.Product.ProductFolder()
        get_transaction().note('Added Control_Panel.Products')
        get_transaction().commit()

    # Ensure that a temp folder exists
    if not hasattr(app, 'temp_folder'):
        from Products.TemporaryFolder.TemporaryFolder import \
             MountedTemporaryFolder
        tf = MountedTemporaryFolder('temp_folder','Temporary Folder')
        app._setObject('temp_folder', tf)
        get_transaction().note('Added temp_folder')
        get_transaction().commit()
        del tf

    # Ensure that there is a transient container in the temp folder
    tf = app.temp_folder
    if not hasattr(aq_base(tf), 'session_data'):
        env_has = os.environ.get
        from Products.Transience.Transience import TransientObjectContainer
        addnotify = env_has('ZSESSION_ADD_NOTIFY', None)
        delnotify = env_has('ZSESSION_DEL_NOTIFY', None)
        default_limit = 1000
        limit = env_has('ZSESSION_OBJECT_LIMIT', default_limit)
        try:
            limit=int(limit)
            if limit != default_limit:
                LOG('Zope Default Object Creation', INFO,
                    ('using ZSESSION_OBJECT_LIMIT-specified max objects '
                     'value of %s' % limit))
        except ValueError:
            LOG('Zope Default Object Creation', WARNING,
                ('Noninteger value %s specified for ZSESSION_OBJECT_LIMIT, '
                 'defaulting to %s' % (limit, default_limit)))
            limit = default_limit
        if addnotify and app.unrestrictedTraverse(addnotify, None) is None:
            LOG('Zope Default Object Creation', WARNING,
                ('failed to use nonexistent "%s" script as '
                 'ZSESSION_ADD_NOTIFY' % addnotify))
            addnotify=None
        elif addnotify:
            LOG('Zope Default Object Creation', INFO,
                'using %s as add notification script' % addnotify)
        if delnotify and app.unrestrictedTraverse(delnotify, None) is None:
            LOG('Zope Default Object Creation', WARNING,
                ('failed to use nonexistent "%s" script as '
                 'ZSESSION_DEL_NOTIFY' % delnotify))
            delnotify=None
        elif delnotify:
            LOG('Zope Default Object Creation', INFO,
                'using %s as delete notification script' % delnotify)

        toc = TransientObjectContainer('session_data',
              'Session Data Container', addNotification = addnotify,
              delNotification = delnotify, limit=limit)
        timeout_spec = env_has('ZSESSION_TIMEOUT_MINS', '')
        if timeout_spec:
            try:
                timeout_spec = int(timeout_spec)
            except ValueError:
                LOG('Zope Default Object Creation', WARNING,
                    ('"%s" is an illegal value for ZSESSION_TIMEOUT_MINS, '
                     'using default timeout instead.' % timeout_spec))
            else:
                LOG('Zope Default Object Creation', INFO,
                    ('using ZSESSION_TIMEOUT_MINS-specified session timeout '
                     'value of %s' % timeout_spec))
                toc = TransientObjectContainer('session_data',
                      'Session Data Container', timeout_mins = timeout_spec,
                      addNotification=addnotify, delNotification = delnotify,
                      limit=limit)
        tf._setObject('session_data', toc)
        tf_reserved = getattr(tf, '_reserved_names', ())
        if 'session_data' not in tf_reserved:
            tf._reserved_names = tf_reserved + ('session_data',)
        get_transaction().note('Added session_data to temp_folder')
        get_transaction().commit()
        del toc
        del addnotify
        del delnotify
        del timeout_spec
        del env_has

    del tf

    # Ensure that a browser ID manager exists
    if not hasattr(app, 'browser_id_manager'):
        from Products.Sessions.BrowserIdManager import BrowserIdManager
        bid = BrowserIdManager('browser_id_manager', 'Browser Id Manager')
        app._setObject('browser_id_manager', bid)
        get_transaction().note('Added browser_id_manager')
        get_transaction().commit()
        del bid

    # Ensure that a session data manager exists
    if not hasattr(app, 'session_data_manager'):
        from Products.Sessions.SessionDataManager import SessionDataManager
        sdm = SessionDataManager('session_data_manager',
            title='Session Data Manager',
            path='/temp_folder/session_data',
            requestName='SESSION')
        app._setObject('session_data_manager', sdm)
        get_transaction().note('Added session_data_manager')
        get_transaction().commit()
        del sdm

    # b/c: Ensure that Owner role exists.
    if hasattr(app, '__ac_roles__') and not ('Owner' in app.__ac_roles__):
        app.__ac_roles__=app.__ac_roles__ + ('Owner',)
        get_transaction().note('Added Owner role')
        get_transaction().commit()

    # ensure the Authenticated role exists.
    if hasattr(app, '__ac_roles__'):
        if not 'Authenticated' in app.__ac_roles__:
            app.__ac_roles__=app.__ac_roles__ + ('Authenticated',)
            get_transaction().note('Added Authenticated role')
            get_transaction().commit()

    # Make sure we have Globals
    root=app._p_jar.root()
    if not root.has_key('ZGlobals'):
        import BTree
        app._p_jar.root()['ZGlobals']=BTree.BTree()
        get_transaction().note('Added Globals')
        get_transaction().commit()

    # Install the initial user.
    if hasattr(app, 'acl_users'):
        users = app.acl_users
        if hasattr(users, '_createInitialUser'):
            app.acl_users._createInitialUser()
            get_transaction().note('Created initial user')
            get_transaction().commit()

    # Install an error_log
    if not hasattr(app, 'error_log'):
        from Products.SiteErrorLog.SiteErrorLog import SiteErrorLog
        error_log = SiteErrorLog()
        app._setObject('error_log', error_log)
        get_transaction().note('Added site error_log at /error_log')
        get_transaction().commit()

    install_products(app)
    install_standards(app)

    # Note that the code from here on only runs if we are not a ZEO
    # client, or if we are a ZEO client and we've specified by way
    # of env variable that we want to force products to load.
    if not doInstall():
        return

    # Check for dangling pointers (broken zclass dependencies) in the
    # global class registry. If found, rebuild the registry. Note that
    # if the check finds problems but fails to successfully rebuild the
    # registry we abort the transaction so that we don't leave it in an
    # indeterminate state.

    did_fixups=0
    bad_things=0
    try:
        if app.checkGlobalRegistry():
            LOG('Zope', INFO,
                'Beginning attempt to rebuild the global ZClass registry.')
            app.fixupZClassDependencies(rebuild=1)
            did_fixups=1
            LOG('Zope', INFO,
                'The global ZClass registry has successfully been rebuilt.')
            get_transaction().note('Rebuilt global product registry')
            get_transaction().commit()
    except:
        bad_things=1
        LOG('Zope', ERROR, 'The attempt to rebuild the registry failed.',
            error=sys.exc_info())
        get_transaction().abort()

    # Now we need to see if any (disk-based) products were installed
    # during intialization. If so (and the registry has no errors),
    # there may still be zclasses dependent on a base class in the
    # newly installed product that were previously broken and need to
    # be fixed up. If any really Bad Things happened (dangling pointers
    # were found in the registry but it couldn't be rebuilt), we don't
    # try to do anything to avoid making the problem worse.
    if (not did_fixups) and (not bad_things):

        # App.Product.initializeProduct will set this if a disk-based
        # product was added or updated and we are not a ZEO client.
        if getattr(Globals, '__disk_product_installed__', 0):
            try:
                LOG('Zope', INFO, 'New disk product detected, determining '\
                    'if we need to fix up any ZClasses.')
                if app.fixupZClassDependencies():
                    LOG('Zope', INFO, 'Repaired broken ZClass dependencies.')
                    get_transaction().commit()
            except:
                LOG('Zope', ERROR,
                    'Attempt to fixup ZClass dependencies after detecting ' \
                    'an updated disk-based product failed.',
                    error=sys.exc_info())
                get_transaction().abort()
</t>
<t tx="ekr.20040104185913.2568">def get_products():
    """ Return a list of tuples in the form:
    [(priority, dir_name, index, base_dir), ...] for each Product directory
    found, sort before returning """
    products = []
    i = 0
    for product_dir in Products.__path__:
        product_names=os.listdir(product_dir)
        for name in product_names:
            priority = (name != 'PluginIndexes') # import PluginIndexes 1st
            # i is used as sort ordering in case a conflict exists
            # between Product names.  Products will be found as
            # per the ordering of Products.__path__
            products.append((priority, name, i, product_dir))
        i = i + 1
    products.sort()
    return products
</t>
<t tx="ekr.20040104185913.2569">def import_products():
    # Try to import each product, checking for and catching errors.
    done={}

    products = get_products()

    for priority, product_name, index, product_dir in products:
        if done.has_key(product_name):
            LOG('OFS.Application', WARNING, 'Duplicate Product name',
                'After loading Product %s from %s,\n'
                'I skipped the one in %s.\n' % (
                `product_name`, `done[product_name]`, `product_dir`) )
            continue
        done[product_name]=product_dir
        import_product(product_dir, product_name,
                       raise_exc=Globals.DevelopmentMode)
</t>
<t tx="ekr.20040104185913.2570">def import_product(product_dir, product_name, raise_exc=0, log_exc=1):
    path_join=os.path.join
    isdir=os.path.isdir
    exists=os.path.exists
    _st=type('')
    global_dict=globals()
    silly=('__doc__',)
    modules=sys.modules
    have_module=modules.has_key

    try:
        package_dir=path_join(product_dir, product_name)
        if not isdir(package_dir): return
        if not exists(path_join(package_dir, '__init__.py')):
            if not exists(path_join(package_dir, '__init__.pyc')):
                if not exists(path_join(package_dir, '__init__.pyo')):
                    return

        pname="Products.%s" % product_name
        try:
            product=__import__(pname, global_dict, global_dict, silly)
            if hasattr(product, '__module_aliases__'):
                for k, v in product.__module_aliases__:
                    if not have_module(k):
                        if type(v) is _st and have_module(v): v=modules[v]
                        modules[k]=v
        except:
            exc = sys.exc_info()
            if log_exc:
                LOG('Zope', ERROR, 'Could not import %s' % pname,
                    error=exc)
            f=StringIO()
            traceback.print_exc(100,f)
            f=f.getvalue()
            try: modules[pname].__import_error__=f
            except: pass
            if raise_exc:
                raise exc[0], exc[1], exc[2]
    finally:
        exc = None
</t>
<t tx="ekr.20040104185913.2571">def install_products(app):
    # Install a list of products into the basic folder class, so
    # that all folders know about top-level objects, aka products

    folder_permissions = get_folder_permissions()
    meta_types=[]
    done={}

    get_transaction().note('Prior to product installs')
    get_transaction().commit()

    products = get_products()

    for priority, product_name, index, product_dir in products:
        # For each product, we will import it and try to call the
        # intialize() method in the product __init__ module. If
        # the method doesnt exist, we put the old-style information
        # together and do a default initialization.
        if done.has_key(product_name):
            continue
        done[product_name]=1
        install_product(app, product_dir, product_name, meta_types,
                        folder_permissions,
                        raise_exc=Globals.DevelopmentMode)

    Products.meta_types=Products.meta_types+tuple(meta_types)
    Globals.default__class_init__(Folder.Folder)
</t>
<t tx="ekr.20040104185913.2572">def get_folder_permissions():
    folder_permissions={}
    for p in Folder.Folder.__ac_permissions__:
        permission, names = p[:2]
        folder_permissions[permission]=names
    return folder_permissions
</t>
<t tx="ekr.20040104185913.2573">def install_product(app, product_dir, product_name, meta_types,
                    folder_permissions, raise_exc=0, log_exc=1):

    path_join=os.path.join
    isdir=os.path.isdir
    exists=os.path.exists
    DictType=type({})
    global_dict=globals()
    silly=('__doc__',)

    if 1:  # Preserve indentation for diff :-)
        package_dir=path_join(product_dir, product_name)
        __traceback_info__=product_name
        if not isdir(package_dir): return
        if not exists(path_join(package_dir, '__init__.py')):
            if not exists(path_join(package_dir, '__init__.pyc')):
                if not exists(path_join(package_dir, '__init__.pyo')):
                    return
        try:
            product=__import__("Products.%s" % product_name,
                               global_dict, global_dict, silly)

            # Install items into the misc_ namespace, used by products
            # and the framework itself to store common static resources
            # like icon images.
            misc_=pgetattr(product, 'misc_', {})
            if misc_:
                if type(misc_) is DictType:
                    misc_=Misc_(product_name, misc_)
                Application.misc_.__dict__[product_name]=misc_

            # Here we create a ProductContext object which contains
            # information about the product and provides an interface
            # for registering things like classes and help topics that
            # should be associated with that product. Products are
            # expected to implement a method named 'initialize' in
            # their __init__.py that takes the ProductContext as an
            # argument.
            productObject=App.Product.initializeProduct(
                product, product_name, package_dir, app)
            context=ProductContext(productObject, app, product)

            # Look for an 'initialize' method in the product. If it does
            # not exist, then this is an old product that has never been
            # updated. In that case, we will analyze the product and
            # build up enough information to do initialization manually.
            initmethod=pgetattr(product, 'initialize', None)
            if initmethod is not None:
                initmethod(context)

            # Support old-style product metadata. Older products may
            # define attributes to name their permissions, meta_types,
            # constructors, etc.
            permissions={}
            new_permissions={}
            for p in pgetattr(product, '__ac_permissions__', ()):
                permission, names, default = (
                    tuple(p)+('Manager',))[:3]
                if names:
                    for name in names:
                        permissions[name]=permission
                elif not folder_permissions.has_key(permission):
                    new_permissions[permission]=()

            for meta_type in pgetattr(product, 'meta_types', ()):
                # Modern product initialization via a ProductContext
                # adds 'product' and 'permission' keys to the meta_type
                # mapping. We have to add these here for old products.
                pname=permissions.get(meta_type['action'], None)
                if pname is not None:
                    meta_type['permission']=pname
                meta_type['product']=productObject.id
                meta_type['visibility'] = 'Global'
                meta_types.append(meta_type)

            for name,method in pgetattr(
                product, 'methods', {}).items():
                if not hasattr(Folder.Folder, name):
                    setattr(Folder.Folder, name, method)
                    if name[-9:]!='__roles__': # not Just setting roles
                        if (permissions.has_key(name) and
                            not folder_permissions.has_key(
                                permissions[name])):
                            permission=permissions[name]
                            if new_permissions.has_key(permission):
                                new_permissions[permission].append(name)
                            else:
                                new_permissions[permission]=[name]

            if new_permissions:
                new_permissions=new_permissions.items()
                for permission, names in new_permissions:
                    folder_permissions[permission]=names
                new_permissions.sort()
                Folder.Folder.__dict__['__ac_permissions__']=tuple(
                    list(Folder.Folder.__ac_permissions__)+new_permissions)

            if not doInstall():
                get_transaction().abort()
            else:
                get_transaction().note('Installed product '+product_name)
                get_transaction().commit()

        except:
            if log_exc:
                LOG('Zope',ERROR,'Couldn\'t install %s' % product_name,
                    error=sys.exc_info())
            get_transaction().abort()
            if raise_exc:
                raise
</t>
<t tx="ekr.20040104185913.2574">def install_standards(app):
    # Check to see if we've already done this before
    # Don't do it twice (Casey)
    if getattr(app, '_standard_objects_have_been_added', 0):
        return

    # Install the replaceable standard objects
    from Products.PageTemplates.PageTemplateFile import PageTemplateFile
    std_dir = os.path.join(Globals.package_home(globals()), 'standard')
    wrote = 0
    for fn in os.listdir(std_dir):
        base, ext = os.path.splitext(fn)
        if ext == '.dtml':
            ob = Globals.DTMLFile(base, std_dir)
            fn = base
            if hasattr(app, fn):
                continue
            app.manage_addProduct['OFSP'].manage_addDTMLMethod(
                id=fn, file=open(ob.raw))
        elif ext in ('.pt', '.zpt'):
            ob = PageTemplateFile(fn, std_dir, __name__=fn)
            if hasattr(app, fn):
                continue
            app.manage_addProduct['PageTemplates'].manage_addPageTemplate(
                id=fn, title='', text=open(ob.filename))
        else:
            continue
        wrote = 1
        # Below is icky and sneaky since it makes these impossible to delete
        #ob.__replaceable__ = Globals.REPLACEABLE
        #setattr(Application, fn, ob)
    if wrote:
        app._standard_objects_have_been_added = 1
        get_transaction().note('Installed standard objects')
        get_transaction().commit()
</t>
<t tx="ekr.20040104185913.2575">def reinstall_product(app, product_name):
    folder_permissions = get_folder_permissions()
    meta_types=[]

    get_transaction().note('Prior to product reinstall')
    get_transaction().commit()

    for product_dir in Products.__path__:
        product_names=os.listdir(product_dir)
        product_names.sort()
        if product_name in product_names:
            removeProductMetaTypes(product_name)
            install_product(app, product_dir, product_name, meta_types,
                            folder_permissions, raise_exc=1, log_exc=0)
            break

    Products.meta_types=Products.meta_types+tuple(meta_types)
    Globals.default__class_init__(Folder.Folder)
</t>
<t tx="ekr.20040104185913.2576">def reimport_product(product_name):
    for product_dir in Products.__path__:
        product_names=os.listdir(product_dir)
        product_names.sort()
        if product_name in product_names:
            import_product(product_dir, product_name,
                           raise_exc=1, log_exc=0)
            break
</t>
<t tx="ekr.20040104185913.2577">def removeProductMetaTypes(pid):
    '''
    Unregisters the meta types registered by a product.
    '''
    meta_types = Products.meta_types
    new_mts = []
    changed = 0
    for meta_type in meta_types:
        if meta_type.get('product', None) == pid:
            # Remove this meta type.
            changed = 1
        else:
            new_mts.append(meta_type)
    if changed:
        Products.meta_types = tuple(new_mts)
</t>
<t tx="ekr.20040104185913.2578">def pgetattr(product, name, default=install_products, __init__=0):
    if not __init__ and hasattr(product, name): return getattr(product, name)
    if hasattr(product, '__init__'):
        product=product.__init__
        if hasattr(product, name): return getattr(product, name)

    if default is not install_products: return default

    raise AttributeError, name
</t>
<t tx="ekr.20040104185913.2579">&lt;&lt; copyright &gt;&gt;

__doc__="""Cacheable object and cache management base classes.

$Id: Cache.py,v 1.10 2002/08/14 21:42:56 mj Exp $"""

__version__='$Revision: 1.10 $'[11:-2]

&lt;&lt; Cache imports &gt;&gt;

ZCM_MANAGERS = '__ZCacheManager_ids__'

ViewManagementScreensPermission = 'View management screens'
ChangeCacheSettingsPermission = 'Change cache settings'

@others

Globals.default__class_init__(CacheManager)
</t>
<t tx="ekr.20040104185913.2580">import time, sys
import Globals
from Globals import DTMLFile
from Acquisition import aq_get, aq_acquire, aq_inner, aq_parent, aq_base
from zLOG import LOG, WARNING
from AccessControl import getSecurityManager
from AccessControl.Role import _isBeingUsedAsAMethod
from AccessControl import Unauthorized</t>
<t tx="ekr.20040104185913.2581">def isCacheable(ob):
    return getattr(aq_base(ob), '_isCacheable', 0)
</t>
<t tx="ekr.20040104185913.2582">def managersExist(ob):
    # Returns 1 if any CacheManagers exist in the context of ob.
    if aq_get(ob, ZCM_MANAGERS, None, 1):
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.2583">def filterCacheTab(ob):
    if _isBeingUsedAsAMethod(ob):
        # Show tab when in a ZClass def that uses Cacheable as a base.
        parent = aq_parent(aq_inner(ob))
        return isCacheable(parent)
    else:
        return managersExist(ob)
</t>
<t tx="ekr.20040104185913.2584">def filterCacheManagers(orig, container, name, value, extra):
    '''
    This is a filter method for aq_acquire.
    It causes objects to be found only if they are
    in the list of cache managers.
    '''
    if (hasattr(aq_base(container), ZCM_MANAGERS) and
        name in getattr(container, ZCM_MANAGERS)):
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.2585">def getVerifiedManagerIds(container):
    '''
    Gets the list of cache managers in a container, verifying each one.
    '''
    ids = getattr(container, ZCM_MANAGERS, ())
    rval = []
    for id in ids:
        if getattr(getattr(container, id, None), '_isCacheManager', 0):
            rval.append(id)
    return tuple(rval)
</t>
<t tx="ekr.20040104185913.2586"># Anytime a CacheManager is added or removed, all _v_ZCacheable_cache
# attributes must be invalidated.  manager_timestamp is a way to do
# that.
manager_timestamp = 0


class Cacheable:
    '''Mix-in for cacheable objects.
    '''
	&lt;&lt; class Cacheable declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2587">manage_options = ({
    'label':'Cache',
    'action':'ZCacheable_manage',
    'filter':filterCacheTab,
    'help':('OFSP','Cacheable-properties.stx'),
    },)

__ac_permissions__ = (
    (ViewManagementScreensPermission,
     ('ZCacheable_manage',
      'ZCacheable_invalidate',
      'ZCacheable_isMethod',
      'ZCacheable_enabled',
      'ZCacheable_getManagerId',
      'ZCacheable_getManagerIds',
      'ZCacheable_configHTML',
      )),
    (ChangeCacheSettingsPermission,
     ('ZCacheable_setManagerId',
      'ZCacheable_setEnabled',
      ), ('Manager',)),
    )

ZCacheable_manage = DTMLFile('dtml/cacheable', globals())

_v_ZCacheable_cache = None
_v_ZCacheable_manager_timestamp = 0
__manager_id = None
__enabled = 1
_isCacheable = 1

ZCacheable_getManager__roles__ = ()
</t>
<t tx="ekr.20040104185913.2588">def ZCacheable_getManager(self):
    '''Returns the currently associated cache manager.'''
    manager_id = self.__manager_id
    if manager_id is None:
        return None
    try:
        return aq_acquire(
            self, manager_id, containment=1,
            filter=filterCacheManagers, extra=None, default=None)
    except AttributeError:
        return None
</t>
<t tx="ekr.20040104185913.2589">ZCacheable_getCache__roles__ = ()
def ZCacheable_getCache(self):
    '''Gets the cache associated with this object.
    '''
    if self.__manager_id is None:
        return None
    c = self._v_ZCacheable_cache
    if c is not None:
        # We have a volatile reference to the cache.
        if self._v_ZCacheable_manager_timestamp == manager_timestamp:
            return aq_base(c)
    manager = self.ZCacheable_getManager()
    if manager is not None:
        c = aq_base(manager.ZCacheManager_getCache())
    else:
        return None
    # Set a volatile reference to the cache then return it.
    self._v_ZCacheable_cache = c
    self._v_ZCacheable_manager_timestamp = manager_timestamp
    return c
</t>
<t tx="ekr.20040104185913.2590">ZCacheable_isCachingEnabled__roles__ = ()
def ZCacheable_isCachingEnabled(self):
    '''
    Returns true only if associated with a cache manager and
    caching of this method is enabled.
    '''
    return self.__enabled and self.ZCacheable_getCache()
</t>
<t tx="ekr.20040104185913.2591">def ZCacheable_isAMethod(self):
    '''
    Returns 1 when this object is a ZClass method.
    '''
    m = _isBeingUsedAsAMethod(self)
    return m
</t>
<t tx="ekr.20040104185913.2592">ZCacheable_getObAndView__roles__ = ()
def ZCacheable_getObAndView(self, view_name):
    """
    If this object is a method of a ZClass and we're working
    with the primary view, uses the ZClass instance as ob
    and our own ID as the view_name.  Otherwise returns
    self and view_name unchanged.
    """
    ob = self
    if not view_name and self.ZCacheable_isAMethod():
        # This is a ZClass method.
        ob = aq_parent(aq_inner(self))
        if isCacheable(ob):
            view_name = self.getId()
        else:
            # Both the parent and the child have to be
            # cacheable.
            ob = self
    return ob, view_name
</t>
<t tx="ekr.20040104185913.2593">ZCacheable_get__roles__ = ()
def ZCacheable_get(self, view_name='', keywords=None,
                   mtime_func=None, default=None):
    '''Retrieves the cached view for the object under the
    conditions specified by keywords. If the value is
    not yet cached, returns the default.
    '''
    c = self.ZCacheable_getCache()
    if c is not None and self.__enabled:
        ob, view_name = self.ZCacheable_getObAndView(view_name)
        try:
            val = c.ZCache_get(ob, view_name, keywords,
                               mtime_func, default)
            return val
        except:
            LOG('Cache', WARNING, 'ZCache_get() exception',
                error=sys.exc_info())
            return default
    return default
</t>
<t tx="ekr.20040104185913.2594">ZCacheable_set__roles__ = ()
def ZCacheable_set(self, data, view_name='', keywords=None,
                   mtime_func=None):
    '''Cacheable views should call this method after generating
    cacheable results. The data argument can be of any Python type.
    '''
    c = self.ZCacheable_getCache()
    if c is not None and self.__enabled:
        ob, view_name = self.ZCacheable_getObAndView(view_name)
        try:
            c.ZCache_set(ob, data, view_name, keywords,
                         mtime_func)
        except:
            LOG('Cache', WARNING, 'ZCache_set() exception',
                error=sys.exc_info())
</t>
<t tx="ekr.20040104185913.2595">def ZCacheable_invalidate(self, view_name='', REQUEST=None):
    '''Called after a cacheable object is edited. Causes all
    cache entries that apply to the view_name to be removed.
    Returns a status message.
    '''
    c = self.ZCacheable_getCache()
    if c is not None:
        ob, view_name = self.ZCacheable_getObAndView(view_name)
        try:
            message = c.ZCache_invalidate(ob)
            if not message:
                message = 'Invalidated.'
        except:
            exc = sys.exc_info()
            try:
                LOG('Cache', WARNING, 'ZCache_invalidate() exception',
                    error=exc)
                message = 'An exception occurred: %s: %s' % exc[:2]
            finally:
                exc = None
    else:
        message = 'This object is not associated with a cache manager.'
    if REQUEST is not None:
        return self.ZCacheable_manage(
            self, REQUEST, management_view='Cache',
            manage_tabs_message=message)
    else:
        return message
</t>
<t tx="ekr.20040104185913.2596">ZCacheable_getModTime__roles__=()
def ZCacheable_getModTime(self, mtime_func=None):
    '''Returns the highest of the last mod times.'''
    # Based on:
    #   mtime_func
    #   self.mtime
    #   self.__class__.mtime
    #   (if in a ZClass) zclass_instance.mtime
    #                    zclass_instance.__class__.mtime
    mtime = 0
    if mtime_func:
        # Allow mtime_func to influence the mod time.
        mtime = mtime_func()
    base = aq_base(self)
    mtime = max(getattr(base, '_p_mtime', mtime), mtime)
    klass = getattr(base, '__class__', None)
    if klass:
        mtime = max(getattr(klass, '_p_mtime', mtime), mtime)
    if self.ZCacheable_isAMethod():
        # This is a ZClass method.
        instance = aq_parent(aq_inner(self))
        base = aq_base(instance)
        mtime = max(getattr(base, '_p_mtime', mtime), mtime)
        klass = getattr(base, '__class__', None)
        if klass:
            mtime = max(getattr(klass, '_p_mtime', mtime), mtime)
    return mtime
</t>
<t tx="ekr.20040104185913.2597">def ZCacheable_getManagerId(self):
    '''Returns the id of the current ZCacheManager.'''
    return self.__manager_id
</t>
<t tx="ekr.20040104185913.2598">def ZCacheable_getManagerURL(self):
    '''Returns the URL of the current ZCacheManager.'''
    manager = self.ZCacheable_getManager()
    if manager is not None:
        return manager.absolute_url()
    return None
</t>
<t tx="ekr.20040104185913.2599">def ZCacheable_getManagerIds(self):
    '''Returns a list of mappings containing the id and title
    of the available ZCacheManagers.'''
    rval = []
    ob = self
    used_ids = {}
    while ob is not None:
        if hasattr(aq_base(ob), ZCM_MANAGERS):
            ids = getattr(ob, ZCM_MANAGERS)
            for id in ids:
                manager = getattr(ob, id, None)
                if manager is not None:
                    id = manager.getId()
                    if not used_ids.has_key(id):
                        title = getattr(aq_base(manager),
                                        'title', '')
                        rval.append({'id':id, 'title':title})
                        used_ids[id] = 1
        ob = aq_parent(aq_inner(ob))
    return tuple(rval)
</t>
<t tx="ekr.20040104185913.2600">def ZCacheable_setManagerId(self, manager_id, REQUEST=None):
    '''Changes the manager_id for this object.'''
    self.ZCacheable_invalidate()
    if not manager_id:
        # User requested disassociation
        # from the cache manager.
        manager_id = None
    else:
        manager_id = str(manager_id)
    self.__manager_id = manager_id
    self._v_ZCacheable_cache = None
    if REQUEST is not None:
        return self.ZCacheable_manage(
            self, REQUEST, management_view='Cache',
            manage_tabs_message='Cache settings changed.')
</t>
<t tx="ekr.20040104185913.2601">def ZCacheable_enabled(self):
    '''Returns true if caching is enabled for this object
    or method.'''
    return self.__enabled
</t>
<t tx="ekr.20040104185913.2602">def ZCacheable_setEnabled(self, enabled=0, REQUEST=None):
    '''Changes the enabled flag. Normally used only when
    setting up cacheable ZClass methods.'''
    self.__enabled = enabled and 1 or 0
    if REQUEST is not None:
        return self.ZCacheable_manage(
            self, REQUEST, management_view='Cache',
            manage_tabs_message='Cache settings changed.')
</t>
<t tx="ekr.20040104185913.2603">def ZCacheable_configHTML(self):
    '''Override to provide configuration of caching
    behavior that can only be specific to the cacheable object.
    '''
    return ''
</t>
<t tx="ekr.20040104185913.2604">Globals.default__class_init__(Cacheable)


def findCacheables(ob, manager_id, require_assoc, subfolders,
                   meta_types, rval, path):
    '''
    Used by the CacheManager UI.  Recursive.  Similar to the Zope
    "Find" function.  Finds all Cacheable objects in a hierarchy.
    '''
    try:
        if meta_types:
            subobs = ob.objectValues(meta_types)
        else:
            subobs = ob.objectValues()
        sm = getSecurityManager()

        # Add to the list of cacheable objects.
        for subob in subobs:
            if not isCacheable(subob):
                continue
            associated = (subob.ZCacheable_getManagerId() == manager_id)
            if require_assoc and not associated:
                continue
            if not sm.checkPermission('Change cache settings', subob):
                continue
            subpath = path + (subob.getId(),)
            icon = getattr(aq_base(subob), 'icon', '')
            info = {
                'sortkey': subpath,
                'path': '/'.join(subpath),
                'title': getattr(aq_base(subob), 'title', ''),
                'icon': icon,
                'associated': associated,}
            rval.append(info)

        # Visit subfolders.
        if subfolders:
            if meta_types:
                subobs = ob.objectValues()
            for subob in subobs:
                subpath = path + (subob.getId(),)
                if hasattr(aq_base(subob), 'objectValues'):
                    if sm.checkPermission(
                        'Access contents information', subob):
                        findCacheables(
                            subob, manager_id, require_assoc,
                            subfolders, meta_types, rval, subpath)
    except:
        # Ignore exceptions.
        import traceback
        traceback.print_exc()
</t>
<t tx="ekr.20040104185913.2605">class Cache:
    '''
    A base class (and interface description) for caches.
    Note that Cache objects are not intended to be visible by
    restricted code.
    '''
	@others
</t>
<t tx="ekr.20040104185913.2606">def ZCache_invalidate(self, ob):
    raise 'Not implemented'
</t>
<t tx="ekr.20040104185913.2607">def ZCache_get(self, ob, view_name, keywords, mtime_func, default):
    # view_name: If an object provides different views that would
    #   benefit from caching, it will set view_name.
    #   Otherwise view_name will be an empty string.
    #
    # keywords: Either None or a mapping containing keys that
    #   distinguish this cache entry from others even though
    #   ob and view_name are the same.  DTMLMethods use keywords
    #   derived from the DTML namespace.
    #
    # mtime_func: When the Cache calls ZCacheable_getModTime(),
    #   it should pass this as an argument.  It is provided to
    #   allow cacheable objects to provide their own computation
    #   of the object's modification time.
    #
    # default: If no entry is found, ZCache_get() should return
    #   default.
    raise 'Not implemented'
</t>
<t tx="ekr.20040104185913.2608">def ZCache_set(self, ob, data, view_name, keywords, mtime_func):
    # See ZCache_get() for parameter descriptions.
    raise 'Not implemented'
</t>
<t tx="ekr.20040104185913.2609">class CacheManager:
    '''
    A base class for cache managers.  Implement ZCacheManager_getCache().
    '''
	&lt;&lt; class CacheManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2610">ZCacheManager_getCache__roles__ = ()
</t>
<t tx="ekr.20040104185913.2611">def ZCacheManager_getCache(self):
    raise 'Not implemented'
</t>
<t tx="ekr.20040104185913.2612">_isCacheManager = 1

__ac_permissions__ = (
    ('Change cache settings', ('ZCacheManager_locate',
                               'ZCacheManager_setAssociations',
                               'ZCacheManager_associate'),
     ('Manager',)),
    )

manage_options = (
    {'label':'Associate',
     'action':'ZCacheManager_associate',
     'help':('OFSP','CacheManager-associate.stx'),
     },
    )

def manage_afterAdd(self, item, container):
    # Adds self to the list of cache managers in the container.
    if aq_base(self) is aq_base(item):
        ids = getVerifiedManagerIds(container)
        id = self.getId()
        if id not in ids:
            setattr(container, ZCM_MANAGERS, ids + (id,))
            global manager_timestamp
            manager_timestamp = time.time()
</t>
<t tx="ekr.20040104185913.2613">def manage_beforeDelete(self, item, container):
    # Removes self from the list of cache managers.
    if aq_base(self) is aq_base(item):
        ids = getVerifiedManagerIds(container)
        id = self.getId()
        if id in ids:
            setattr(container, ZCM_MANAGERS, filter(
                lambda s, id=id: s != id, ids))
            global manager_timestamp
            manager_timestamp = time.time()
</t>
<t tx="ekr.20040104185913.2614">ZCacheManager_associate = DTMLFile('dtml/cmassoc', globals())

def ZCacheManager_locate(self, require_assoc, subfolders,
                         meta_types=[], REQUEST=None):
    '''Locates cacheable objects.
    '''
    ob = aq_parent(aq_inner(self))
    rval = []
    manager_id = self.getId()
    if '' in meta_types:
        # User selected "All".
        meta_types = []
    findCacheables(ob, manager_id, require_assoc, subfolders,
                   meta_types, rval, ())
    if REQUEST is not None:
        return self.ZCacheManager_associate(
            self, REQUEST, show_results=1, results=rval,
            management_view="Associate")
    else:
        return rval
</t>
<t tx="ekr.20040104185913.2615">def ZCacheManager_setAssociations(self, props=None, REQUEST=None):
    '''Associates and un-associates cacheable objects with this
    cache manager.
    '''
    addcount = 0
    remcount = 0
    parent = aq_parent(aq_inner(self))
    sm = getSecurityManager()
    my_id = str(self.getId())
    if props is None:
        props = REQUEST.form
    for key, do_associate in props.items():
        if key[:10] == 'associate_':
            path = key[10:]
            ob = parent.restrictedTraverse(path)
            if not sm.checkPermission('Change cache settings', ob):
                raise Unauthorized
            if not isCacheable(ob):
                # Not a cacheable object.
                continue
            manager_id = str(ob.ZCacheable_getManagerId())
            if do_associate:
                if manager_id != my_id:
                    ob.ZCacheable_setManagerId(my_id)
                    addcount = addcount + 1
            else:
                if manager_id == my_id:
                    ob.ZCacheable_setManagerId(None)
                    remcount = remcount + 1
    if REQUEST is not None:
        return self.ZCacheManager_associate(
            self, REQUEST, management_view="Associate",
            manage_tabs_message='%d association(s) made, %d removed.'%
            (addcount, remcount)
            )
</t>
<t tx="ekr.20040104185913.2616">&lt;&lt; copyright &gt;&gt;

__doc__="""Copy interface"""
__version__='$Revision: 1.82.6.1 $'[11:-2]

&lt;&lt; CopySupport imports &gt;&gt;

CopyError='Copy Error'

_marker=[]

@others

fMessageDialog=Globals.HTML(
	&lt;&lt;message&gt;&gt;,target='', action='manage_main', title='Changed')

eNoData=MessageDialog(
        title='No Data',
        message='No clipboard data found.',
        action ='manage_main',)

eInvalid=MessageDialog(
         title='Clipboard Error',
         message='The data in the clipboard could not be read, possibly due ' \
         'to cookie data being truncated by your web browser. Try copying ' \
         'fewer objects.',
         action ='manage_main',)

eNotFound=MessageDialog(
          title='Item Not Found',
          message='One or more items referred to in the clipboard data was ' \
          'not found. The item may have been moved or deleted after you ' \
          'copied it.',
          action ='manage_main',)

eNotSupported=fMessageDialog(
              title='Not Supported',
              message=(
              'The action against the &lt;em&gt;%s&lt;/em&gt; object could not be carried '
              'out. '
              'One of the following constraints caused the problem: &lt;br&gt;&lt;br&gt;'
              'The object does not support this operation.'
              '&lt;br&gt;&lt;br&gt;-- OR --&lt;br&gt;&lt;br&gt;'
              'The currently logged-in user does not have the &lt;b&gt;Copy or '
              'Move&lt;/b&gt; permission respective to the object.'
              ),
              action ='manage_main',)

eNoItemsSpecified=MessageDialog(
                  title='No items specified',
                  message='You must select one or more items to perform ' \
                  'this operation.',
                  action ='manage_main'
                  )
</t>
<t tx="ekr.20040104185913.2617">import sys,  Globals, Moniker, tempfile, ExtensionClass
from marshal import loads, dumps
from urllib import quote, unquote
from zlib import compress, decompress
from App.Dialogs import MessageDialog
from AccessControl import getSecurityManager
from Acquisition import aq_base, aq_inner, aq_parent
from zExceptions import Unauthorized
from AccessControl import getSecurityManager</t>
<t tx="ekr.20040104185913.2618">class CopyContainer(ExtensionClass.Base):
    """Interface for containerish objects which allow cut/copy/paste"""
	&lt;&lt; class CopyContainer declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2619">__ac_permissions__=(
    ('View management screens',
     ('manage_cutObjects', 'manage_copyObjects', 'manage_pasteObjects',
      'manage_renameForm', 'manage_renameObject', 'manage_renameObjects',)),
    )


# The following three methods should be overridden to store sub-objects
# as non-attributes.
</t>
<t tx="ekr.20040104185913.2620">def _setOb(self, id, object): setattr(self, id, object)
</t>
<t tx="ekr.20040104185913.2621">def _delOb(self, id): delattr(self, id)
</t>
<t tx="ekr.20040104185913.2622">def _getOb(self, id, default=_marker):
    self = aq_base(self)
    if default is _marker: return getattr(self, id)
    try: return getattr(self, id)
    except: return default
</t>
<t tx="ekr.20040104185913.2623">def manage_CopyContainerFirstItem(self, REQUEST):
    return self._getOb(REQUEST['ids'][0])
</t>
<t tx="ekr.20040104185913.2624">def manage_CopyContainerAllItems(self, REQUEST):
    return map(lambda i, s=self: s._getOb(i), tuple(REQUEST['ids']))
</t>
<t tx="ekr.20040104185913.2625">def manage_cutObjects(self, ids=None, REQUEST=None):
    """Put a reference to the objects named in ids in the clip board"""
    if ids is None and REQUEST is not None:
        return eNoItemsSpecified
    elif ids is None:
        raise ValueError, 'ids must be specified'

    if type(ids) is type(''):
        ids=[ids]
    oblist=[]
    for id in ids:
        ob=self._getOb(id)
        if not ob.cb_isMoveable():
            raise CopyError, eNotSupported % id
        m=Moniker.Moniker(ob)
        oblist.append(m.dump())
    cp=(1, oblist)
    cp=_cb_encode(cp)
    if REQUEST is not None:
        resp=REQUEST['RESPONSE']
        resp.setCookie('__cp', cp, path='%s' % cookie_path(REQUEST))
        REQUEST['__cp'] = cp
        return self.manage_main(self, REQUEST)
    return cp
</t>
<t tx="ekr.20040104185913.2626">def manage_copyObjects(self, ids=None, REQUEST=None, RESPONSE=None):
    """Put a reference to the objects named in ids in the clip board"""
    if ids is None and REQUEST is not None:
        return eNoItemsSpecified
    elif ids is None:
        raise ValueError, 'ids must be specified'

    if type(ids) is type(''):
        ids=[ids]
    oblist=[]
    for id in ids:
        ob=self._getOb(id)
        if not ob.cb_isCopyable():
            raise CopyError, eNotSupported % id
        m=Moniker.Moniker(ob)
        oblist.append(m.dump())
    cp=(0, oblist)
    cp=_cb_encode(cp)
    if REQUEST is not None:
        resp=REQUEST['RESPONSE']
        resp.setCookie('__cp', cp, path='%s' % cookie_path(REQUEST))
        REQUEST['__cp'] = cp
        return self.manage_main(self, REQUEST)
    return cp
</t>
<t tx="ekr.20040104185913.2627">def _get_id(self, id):
    # Allow containers to override the generation of
    # object copy id by attempting to call its _get_id
    # method, if it exists.
    n=0
    if (len(id) &gt; 8) and (id[8:]=='copy_of_'):
        n=1
    orig_id=id
    while 1:
        if self._getOb(id, None) is None:
            return id
        id='copy%s_of_%s' % (n and n+1 or '', orig_id)
        n=n+1
</t>
<t tx="ekr.20040104185913.2628">def manage_pasteObjects(self, cb_copy_data=None, REQUEST=None):
    """Paste previously copied objects into the current object.
       If calling manage_pasteObjects from python code, pass
       the result of a previous call to manage_cutObjects or
       manage_copyObjects as the first argument."""
    cp=None
    if cb_copy_data is not None:
        cp=cb_copy_data
    else:
        if REQUEST and REQUEST.has_key('__cp'):
            cp=REQUEST['__cp']
    if cp is None:
        raise CopyError, eNoData

    try:    cp=_cb_decode(cp)
    except: raise CopyError, eInvalid

    oblist=[]
    op=cp[0]
    app = self.getPhysicalRoot()
    result = []

    for mdata in cp[1]:
        m = Moniker.loadMoniker(mdata)
        try: ob = m.bind(app)
        except: raise CopyError, eNotFound
        self._verifyObjectPaste(ob)
        oblist.append(ob)

    if op==0:
        # Copy operation
        for ob in oblist:
            if not ob.cb_isCopyable():
                raise CopyError, eNotSupported % ob.getId()
            try:    ob._notifyOfCopyTo(self, op=0)
            except: raise CopyError, MessageDialog(
                title='Copy Error',
                message=sys.exc_info()[1],
                action ='manage_main')
            ob=ob._getCopy(self)
            orig_id=ob.getId()
            id=self._get_id(ob.getId())
            result.append({'id':orig_id, 'new_id':id})
            ob._setId(id)
            self._setObject(id, ob)
            ob = self._getOb(id)
            ob.manage_afterClone(ob)

        if REQUEST is not None:
            return self.manage_main(self, REQUEST, update_menu=1,
                                    cb_dataValid=1)

    if op==1:
        # Move operation
        for ob in oblist:
            id=ob.getId()
            if not ob.cb_isMoveable():
                raise CopyError, eNotSupported % id
            try:    ob._notifyOfCopyTo(self, op=1)
            except: raise CopyError, MessageDialog(
                title='Move Error',
                message=sys.exc_info()[1],
                action ='manage_main')
            if not sanity_check(self, ob):
                raise CopyError, 'This object cannot be pasted into itself'

            # try to make ownership explicit so that it gets carried
            # along to the new location if needed.
            ob.manage_changeOwnershipType(explicit=1)

            aq_parent(aq_inner(ob))._delObject(id)
            ob = aq_base(ob)
            orig_id=id
            id=self._get_id(id)
            result.append({'id':orig_id, 'new_id':id })
            ob._setId(id)

            self._setObject(id, ob, set_owner=0)

            # try to make ownership implicit if possible
            ob=self._getOb(id)
            ob.manage_changeOwnershipType(explicit=0)

        if REQUEST is not None:
            REQUEST['RESPONSE'].setCookie('__cp', 'deleted',
                                path='%s' % cookie_path(REQUEST),
                                expires='Wed, 31-Dec-97 23:59:59 GMT')
            REQUEST['__cp'] = None
            return self.manage_main(self, REQUEST, update_menu=1,
                                    cb_dataValid=0)
    return result
</t>
<t tx="ekr.20040104185913.2629">manage_renameForm=Globals.DTMLFile('dtml/renameForm', globals())

def manage_renameObjects(self, ids=[], new_ids=[], REQUEST=None):
    """Rename several sub-objects"""
    if len(ids) != len(new_ids):
        raise 'Bad Request','Please rename each listed object.'
    for i in range(len(ids)):
        if ids[i] != new_ids[i]:
            self.manage_renameObject(ids[i], new_ids[i], REQUEST)
    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
    return None
</t>
<t tx="ekr.20040104185913.2630">def manage_renameObject(self, id, new_id, REQUEST=None):
    """Rename a particular sub-object"""
    try: self._checkId(new_id)
    except: raise CopyError, MessageDialog(
                  title='Invalid Id',
                  message=sys.exc_info()[1],
                  action ='manage_main')
    ob=self._getOb(id)
    if not ob.cb_isMoveable():
        raise CopyError, eNotSupported % id
    self._verifyObjectPaste(ob)
    try:    ob._notifyOfCopyTo(self, op=1)
    except: raise CopyError, MessageDialog(
                  title='Rename Error',
                  message=sys.exc_info()[1],
                  action ='manage_main')
    self._delObject(id)
    ob = aq_base(ob)
    ob._setId(new_id)

    # Note - because a rename always keeps the same context, we
    # can just leave the ownership info unchanged.
    self._setObject(new_id, ob, set_owner=0)

    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
    return None
</t>
<t tx="ekr.20040104185913.2631"># Why did we give this a manage_ prefix if its really
# supposed to be public since it does its own auth ?
#
# Because it's still a "management" function.
manage_clone__roles__=None
def manage_clone(self, ob, id, REQUEST=None):
    # Clone an object, creating a new object with the given id.
    if not ob.cb_isCopyable():
        raise CopyError, eNotSupported % ob.getId()
    try: self._checkId(id)
    except: raise CopyError, MessageDialog(
                  title='Invalid Id',
                  message=sys.exc_info()[1],
                  action ='manage_main')
    self._verifyObjectPaste(ob)
    try:    ob._notifyOfCopyTo(self, op=0)
    except: raise CopyError, MessageDialog(
                  title='Clone Error',
                  message=sys.exc_info()[1],
                  action ='manage_main')
    ob=ob._getCopy(self)
    ob._setId(id)
    self._setObject(id, ob)
    ob=ob.__of__(self)
    ob.manage_afterClone(ob)
    return ob
</t>
<t tx="ekr.20040104185913.2632">def cb_dataValid(self):
    # Return true if clipboard data seems valid.
    try:    cp=_cb_decode(self.REQUEST['__cp'])
    except: return 0
    return 1
</t>
<t tx="ekr.20040104185913.2633">def cb_dataItems(self):
    # List of objects in the clip board
    try:    cp=_cb_decode(self.REQUEST['__cp'])
    except: return []
    oblist=[]

    app = self.getPhysicalRoot()
    for mdata in cp[1]:
        m = Moniker.loadMoniker(mdata)
        oblist.append(m.bind(app))
    return oblist
</t>
<t tx="ekr.20040104185913.2634">validClipData=cb_dataValid

def _verifyObjectPaste(self, object, validate_src=1):
    # Verify whether the current user is allowed to paste the
    # passed object into self. This is determined by checking
    # to see if the user could create a new object of the same
    # meta_type of the object passed in and checking that the
    # user actually is allowed to access the passed in object
    # in its existing context.
    #
    # Passing a false value for the validate_src argument will skip
    # checking the passed in object in its existing context. This is
    # mainly useful for situations where the passed in object has no
    # existing context, such as checking an object during an import
    # (the object will not yet have been connected to the acquisition
    # heirarchy).
    if not hasattr(object, 'meta_type'):
        raise CopyError, MessageDialog(
              title='Not Supported',
              message='The object &lt;EM&gt;%s&lt;/EM&gt; does not support this' \
                      ' operation' % absattr(object.id),
              action='manage_main')
    mt=object.meta_type
    if not hasattr(self, 'all_meta_types'):
        raise CopyError, MessageDialog(
              title='Not Supported',
              message='Cannot paste into this object.',
              action='manage_main')

    method_name=None
    mt_permission=None
    meta_types=absattr(self.all_meta_types)
    for d in meta_types:
        if d['name']==mt:
            method_name=d['action']
            mt_permission=d.get( 'permission', None )
            break

    if mt_permission is not None:
        if getSecurityManager().checkPermission( mt_permission, self ):
            if not validate_src:
                return
            # Ensure the user is allowed to access the object on the
            # clipboard.
            try:    parent=aq_parent(aq_inner(object))
            except: parent=None
            if getSecurityManager().validate(None, parent, None, object):
                return
            raise Unauthorized, absattr(object.id)
        else:
            raise Unauthorized(permission=mt_permission)
    #
    #   XXX:    Ancient cruft, left here in true co-dependent fashion
    #           to keep from breaking old products which don't put
    #           permissions on their metadata registry entries.
    #
    if method_name is not None:
        meth=self.unrestrictedTraverse(method_name)
        if hasattr(meth, 'im_self'):
            parent = meth.im_self
        else:
            try:    parent=aq_parent(aq_inner(meth))
            except: parent=None
        if getSecurityManager().validate(None, parent, None, meth):
            # Ensure the user is allowed to access the object on the
            # clipboard.
            if not validate_src:
                return
            try:    parent=aq_parent(aq_inner(object))
            except: parent=None
            if getSecurityManager().validate(None, parent, None, object):
                return
            raise Unauthorized, absattr(object.id)
        else:
            raise Unauthorized, method_name

    raise CopyError, MessageDialog(
          title='Not Supported',
          message='The object &lt;EM&gt;%s&lt;/EM&gt; does not support this ' \
                  'operation.' % absattr(object.id),
          action='manage_main')
</t>
<t tx="ekr.20040104185913.2635">Globals.default__class_init__(CopyContainer)



class CopySource(ExtensionClass.Base):
    """Interface for objects which allow themselves to be copied."""
	&lt;&lt; class CopySource declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2636"># declare a dummy permission for Copy or Move here that we check
# in cb_isCopyable.
__ac_permissions__=(
    ('Copy or Move', (), ('Anonymous', 'Manager',)),
    )

</t>
<t tx="ekr.20040104185913.2637">def _canCopy(self, op=0):
    """Called to make sure this object is copyable. The op var
    is 0 for a copy, 1 for a move."""
    return 1
</t>
<t tx="ekr.20040104185913.2638">def _notifyOfCopyTo(self, container, op=0):
    """Overide this to be pickly about where you go! If you dont
    want to go there, raise an exception. The op variable is
    0 for a copy, 1 for a move."""
    pass
</t>
<t tx="ekr.20040104185913.2639">def _getCopy(self, container):
    # Commit a subtransaction to:
    # 1) Make sure the data about to be exported is current
    # 2) Ensure self._p_jar and container._p_jar are set even if
    #    either one is a new object
    get_transaction().commit(1)

    if self._p_jar is None:
        raise CopyError, (
            'Object "%s" needs to be in the database to be copied' %
            `self`)
    if container._p_jar is None:
        raise CopyError, (
            'Container "%s" needs to be in the database' %
            `container`)

    # Ask an object for a new copy of itself.
    f=tempfile.TemporaryFile()
    self._p_jar.exportFile(self._p_oid,f)
    f.seek(0)
    ob=container._p_jar.importFile(f)
    f.close()
    return ob
</t>
<t tx="ekr.20040104185913.2640">def _postCopy(self, container, op=0):
    # Called after the copy is finished to accomodate special cases.
    # The op var is 0 for a copy, 1 for a move.
    pass
</t>
<t tx="ekr.20040104185913.2641">def _setId(self, id):
    # Called to set the new id of a copied object.
    self.id=id
</t>
<t tx="ekr.20040104185913.2642">def cb_isCopyable(self):
    # Is object copyable? Returns 0 or 1
    if not (hasattr(self, '_canCopy') and self._canCopy(0)):
        return 0
    if not self.cb_userHasCopyOrMovePermission():
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2643">def cb_isMoveable(self):
    # Is object moveable? Returns 0 or 1
    if not (hasattr(self, '_canCopy') and self._canCopy(1)):
        return 0
    if hasattr(self, '_p_jar') and self._p_jar is None:
        return 0
    try:    n=aq_parent(aq_inner(self))._reserved_names
    except: n=()
    if absattr(self.id) in n:
        return 0
    if not self.cb_userHasCopyOrMovePermission():
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2644">def cb_userHasCopyOrMovePermission(self):
    if getSecurityManager().checkPermission('Copy or Move', self):
        return 1
</t>
<t tx="ekr.20040104185913.2645">Globals.default__class_init__(CopySource)


def sanity_check(c, ob):
    # This is called on cut/paste operations to make sure that
    # an object is not cut and pasted into itself or one of its
    # subobjects, which is an undefined situation.
    ob = aq_base(ob)
    while 1:
        if aq_base(c) is ob:
            return 0
        inner = aq_inner(c)
        if aq_parent(inner) is None:
            return 1
        c = aq_parent(inner)
</t>
<t tx="ekr.20040104185913.2646">def absattr(attr):
    if callable(attr): return attr()
    return attr
</t>
<t tx="ekr.20040104185913.2647">def _cb_encode(d):
    return quote(compress(dumps(d), 9))
</t>
<t tx="ekr.20040104185913.2648">def _cb_decode(s):
    return loads(decompress(unquote(s)))
</t>
<t tx="ekr.20040104185913.2649">def cookie_path(request):
    # Return a "path" value for use in a cookie that refers
    # to the root of the Zope object space.
    return request['BASEPATH1'] or "/"
</t>
<t tx="ekr.20040104185913.2650">&lt;&lt; copyright &gt;&gt;

"""DTML Document objects."""

__version__='$Revision: 1.48 $'[11:-2]

&lt;&lt; DTMLDocument imports &gt;&gt;

done='done'

_marker = []  # Create a new marker object.

@others
</t>
<t tx="ekr.20040104185913.2651">from ZPublisher.Converters import type_converters
from Globals import HTML, DTMLFile, MessageDialog
from OFS.content_types import guess_content_type
from DTMLMethod import DTMLMethod, decapitate
from PropertyManager import PropertyManager
from webdav.common import rfc1123_date
from webdav.Lockable import ResourceLockedError
from webdav.WriteLockInterface import WriteLockInterface
from sgmllib import SGMLParser
from urllib import quote
import Globals
from AccessControl import getSecurityManager</t>
<t tx="ekr.20040104185913.2652">class DTMLDocument(PropertyManager, DTMLMethod):
    """DTML Document objects are DocumentTemplate.HTML objects that act
       as methods whose 'self' is the DTML Document itself."""
	&lt;&lt; class DTMLDocument declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2653">__implements__ = (WriteLockInterface,)
meta_type='DTML Document'
icon     ='p_/dtmldoc'

manage_options=(
    DTMLMethod.manage_options[:2] +
    PropertyManager.manage_options +
    DTMLMethod.manage_options[2:]
    )

__ac_permissions__=(
    ('Change DTML Documents',
     ('manage_editForm', 'manage', 'manage_main',
      'manage_edit', 'manage_upload', 'PUT',
      'manage_historyCopy',
      'manage_beforeHistoryCopy', 'manage_afterHistoryCopy',
      )
     ),
    )

</t>
<t tx="ekr.20040104185913.2654">def manage_edit(self,data,title,SUBMIT='Change',dtpref_cols='50',
                dtpref_rows='20',REQUEST=None):
    """
    Replaces a Documents contents with Data, Title with Title.

    The SUBMIT parameter is also used to change the size of the editing
    area on the default Document edit screen.  If the value is "Smaller",
    the rows and columns decrease by 5.  If the value is "Bigger", the
    rows and columns increase by 5.  If any other or no value is supplied,
    the data gets checked for DTML errors and is saved.
    """
    self._validateProxy(REQUEST)
    if self._size_changes.has_key(SUBMIT):
        return self._er(data,title,SUBMIT,dtpref_cols,dtpref_rows,REQUEST)
    if self.wl_isLocked():
        raise ResourceLockedError, (
            'This document has been locked via WebDAV.')

    self.title=str(title)
    if type(data) is not type(''): data=data.read()
    self.munge(data)
    self.ZCacheable_invalidate()
    if REQUEST:
        message="Content changed."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2655">def manage_upload(self,file='', REQUEST=None):
    """Replace the contents of the document with the text in file."""
    self._validateProxy(REQUEST)
    if self.wl_isLocked():
        raise ResourceLockedError, (
            'This document has been locked via WebDAV.')

    if type(file) is not type(''):
        if REQUEST and not file:
            raise ValueError, 'No file specified'
        file=file.read()

    self.munge(file)
    self.ZCacheable_invalidate()
    if REQUEST:
        message="Content uploaded."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2656">def __call__(self, client=None, REQUEST={}, RESPONSE=None, **kw):
    """Render the document given a client object, REQUEST mapping,
    Response, and key word arguments."""

    if not self._cache_namespace_keys:
        data = self.ZCacheable_get(default=_marker)
        if data is not _marker:
            # Return cached results.
            return data

    kw['document_id']   =self.getId()
    kw['document_title']=self.title
    if hasattr(self, 'aq_explicit'):
        bself=self.aq_explicit
    else: bself=self

    security=getSecurityManager()
    security.addContext(self)

    try:
        if client is None:
            # Called as subtemplate, so don't need error propigation!
            r=apply(HTML.__call__, (self, bself, REQUEST), kw)
            if RESPONSE is None: result = r
            else: result = decapitate(r, RESPONSE)
            if not self._cache_namespace_keys:
                self.ZCacheable_set(result)
            return result

        r=apply(HTML.__call__, (self, (client, bself), REQUEST), kw)
        if type(r) is not type('') or RESPONSE is None:
            if not self._cache_namespace_keys:
                self.ZCacheable_set(r)
            return r

    finally: security.removeContext(self)

    have_key=RESPONSE.headers.has_key
    if not (have_key('content-type') or have_key('Content-Type')):
        if self.__dict__.has_key('content_type'):
            c=self.content_type
        else:
            c, e=guess_content_type(self.__name__, r)
        RESPONSE.setHeader('Content-Type', c)
    result = decapitate(r, RESPONSE)
    if not self._cache_namespace_keys:
        self.ZCacheable_set(result)
    return result
</t>
<t tx="ekr.20040104185913.2657">Globals.default__class_init__(DTMLDocument)


default_dd_html="""&lt;dtml-var standard_html_header&gt;
&lt;h2&gt;&lt;dtml-var title_or_id&gt;&lt;/h2&gt;
&lt;p&gt;
This is the &lt;dtml-var id&gt; Document.
&lt;/p&gt;
&lt;dtml-var standard_html_footer&gt;"""

addForm=DTMLFile('dtml/documentAdd', globals())

def addDTMLDocument(self, id, title='', file='', REQUEST=None, submit=None):
    """Add a DTML Document object with the contents of file. If
    'file' is empty, default document text is used.
    """
    if type(file) is not type(''): file=file.read()
    if not file: file=default_dd_html
    id=str(id)
    title=str(title)
    ob=DTMLDocument(file, __name__=id)
    ob.title=title
    id=self._setObject(id, ob)
    if REQUEST is not None:
        try: u=self.DestinationURL()
        except: u=REQUEST['URL1']
        if submit==" Add and Edit ": u="%s/%s" % (u,quote(id))
        REQUEST.RESPONSE.redirect(u+'/manage_main')
    return ''
</t>
<t tx="ekr.20040104185913.2658">&lt;&lt; copyright &gt;&gt;

"""DTML Method objects."""

__version__='$Revision: 1.79.6.2 $'[11:-2]

&lt;&lt; DTMLMethod imports &gt;&gt;

_marker = []  # Create a new marker object.

@others
</t>
<t tx="ekr.20040104185913.2659">import History
from Globals import HTML, DTMLFile, MessageDialog
from SimpleItem import Item_w__name__, pretty_tb
from OFS.content_types import guess_content_type
from PropertyManager import PropertyManager
from AccessControl.Role import RoleManager
from webdav.common import rfc1123_date
from webdav.Lockable import ResourceLockedError
from webdav.WriteLockInterface import WriteLockInterface
from ZDOM import ElementWithTitle
from DateTime.DateTime import DateTime
from urllib import quote
import  Globals, sys, Acquisition
from AccessControl import getSecurityManager
from AccessControl.DTML import RestrictedDTML
from Cache import Cacheable</t>
<t tx="ekr.20040104185913.2660">class DTMLMethod(RestrictedDTML, HTML, Acquisition.Implicit, RoleManager,
	&lt;&lt; class DTMLMethod declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2661">ElementWithTitle, Item_w__name__,
History.Historical,
Cacheable,
):
"""DTML Method objects are DocumentTemplate.HTML objects that act
as methods of their containers."""
meta_type='DTML Method'
_proxy_roles=()
index_html=None # Prevent accidental acquisition
_cache_namespace_keys=()

__implements__ = (WriteLockInterface,)

# Documents masquerade as functions:
</t>
<t tx="ekr.20040104185913.2662">class func_code: pass
	&lt;&lt; class func_code declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2663">func_code=func_code()
</t>
<t tx="ekr.20040104185913.2664">func_code.co_varnames='self','REQUEST','RESPONSE'
func_code.co_argcount=3

manage_options=(
    (
        {'label':'Edit', 'action':'manage_main',
         'help':('OFSP','DTML-DocumentOrMethod_Edit.stx')},
        #upload is deprecated
        #{'label':'Upload', 'action':'manage_uploadForm',
        # 'help':('OFSP','DTML-DocumentOrMethod_Upload.stx')},
        {'label':'View', 'action':'',
         'help':('OFSP','DTML-DocumentOrMethod_View.stx')},
        {'label':'Proxy', 'action':'manage_proxyForm',
         'help':('OFSP','DTML-DocumentOrMethod_Proxy.stx')},
        )
    +History.Historical.manage_options
    +RoleManager.manage_options
    +Item_w__name__.manage_options
    +Cacheable.manage_options
    )

__ac_permissions__=(
('View management screens',
 ('document_src', 'PrincipiaSearchSource')),
('Change DTML Methods',
 ('manage_editForm', 'manage', 'manage_main',
  'manage_edit', 'manage_upload', 'PUT',
  'manage_historyCopy',
  'manage_beforeHistoryCopy', 'manage_afterHistoryCopy',
  'ZCacheable_configHTML', 'getCacheNamespaceKeys',
  'setCacheNamespaceKeys',
  )
 ),
('Change proxy roles', ('manage_proxyForm', 'manage_proxy')),
('View', ('__call__', 'get_size', '')),
('FTP access', ('manage_FTPstat','manage_FTPget','manage_FTPlist')),
)

# support a more reasonable default for content-type
# for http HEAD requests.
default_content_type='text/html'

def __call__(self, client=None, REQUEST={}, RESPONSE=None, **kw):
    """Render the document given a client object, REQUEST mapping,
    Response, and key word arguments."""

    if not self._cache_namespace_keys:
        data = self.ZCacheable_get(default=_marker)
        if data is not _marker:
            # Return cached results.
            return data

    kw['document_id']   =self.getId()
    kw['document_title']=self.title

    security=getSecurityManager()
    security.addContext(self)
    if self.__dict__.has_key('validate'):
        first_time_through = 0
    else:
        self.__dict__['validate'] = security.DTMLValidate
        first_time_through = 1
    try:

        if client is None:
            # Called as subtemplate, so don't need error propagation!
            r=apply(HTML.__call__, (self, client, REQUEST), kw)
            if RESPONSE is None: result = r
            else: result = decapitate(r, RESPONSE)
            if not self._cache_namespace_keys:
                self.ZCacheable_set(result)
            return result

        r=apply(HTML.__call__, (self, client, REQUEST), kw)
        if type(r) is not type('') or RESPONSE is None:
            if not self._cache_namespace_keys:
                self.ZCacheable_set(r)
            return r

    finally:
        security.removeContext(self)
        if first_time_through:
            del self.__dict__['validate']

    have_key=RESPONSE.headers.has_key
    if not (have_key('content-type') or have_key('Content-Type')):
        if self.__dict__.has_key('content_type'):
            c=self.content_type
        else:
            c, e=guess_content_type(self.getId(), r)
        RESPONSE.setHeader('Content-Type', c)
    result = decapitate(r, RESPONSE)
    if not self._cache_namespace_keys:
        self.ZCacheable_set(result)
    return result
</t>
<t tx="ekr.20040104185913.2665">def validate(self, inst, parent, name, value, md=None):
    return getSecurityManager().validate(inst, parent, name, value)
</t>
<t tx="ekr.20040104185913.2666">def ZDocumentTemplate_beforeRender(self, md, default):
    # Tries to get a cached value.
    if self._cache_namespace_keys:
        # Use the specified keys from the namespace to identify a
        # cache entry.
        kw = {}
        for key in self._cache_namespace_keys:
            try: val = md[key]
            except: val = None
            kw[key] = val
        return self.ZCacheable_get(keywords=kw, default=default)
    return default
</t>
<t tx="ekr.20040104185913.2667">def ZDocumentTemplate_afterRender(self, md, result):
    # Tries to set a cache value.
    if self._cache_namespace_keys:
        kw = {}
        for key in self._cache_namespace_keys:
            try: val = md[key]
            except: val = None
            kw[key] = val
        self.ZCacheable_set(result, keywords=kw)
</t>
<t tx="ekr.20040104185913.2668">ZCacheable_configHTML = DTMLFile('dtml/cacheNamespaceKeys', globals())

def getCacheNamespaceKeys(self):
    '''
    Returns the cacheNamespaceKeys.
    '''
    return self._cache_namespace_keys
</t>
<t tx="ekr.20040104185913.2669">def setCacheNamespaceKeys(self, keys, REQUEST=None):
    '''
    Sets the list of names that should be looked up in the
    namespace to provide a cache key.
    '''
    ks = []
    for key in keys:
        key = str(key).strip()
        if key:
            ks.append(key)
    self._cache_namespace_keys = tuple(ks)
    if REQUEST is not None:
        return self.ZCacheable_manage(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2670">def get_size(self):
    return len(self.raw)
</t>
<t tx="ekr.20040104185913.2671"># deprecated; use get_size!
getSize=get_size

manage_editForm=DTMLFile('dtml/documentEdit', globals())
manage_editForm._setName('manage_editForm')

# deprecated!
manage_uploadForm=manage_editForm

manage=manage_main=manage_editDocument=manage_editForm
manage_proxyForm=DTMLFile('dtml/documentProxy', globals())

_size_changes={
    'Bigger': (5,5),
    'Smaller': (-5,-5),
    'Narrower': (0,-5),
    'Wider': (0,5),
    'Taller': (5,0),
    'Shorter': (-5,0),
    }

def _er(self,data,title,SUBMIT,dtpref_cols,dtpref_rows,REQUEST):
    dr,dc = self._size_changes[SUBMIT]

    rows=str(max(1,int(dtpref_rows)+dr))

    if dtpref_cols[-1]=='%':
        cols= str(min(100, max(25,int(dtpref_cols[:-1])+dc)))+'%'
    else:
        cols=str(max(35,int(dtpref_cols)+dc))

    e=(DateTime('GMT') + 365).rfc822()
    resp=REQUEST['RESPONSE']
    resp.setCookie('dtpref_rows',str(rows),path='/',expires=e)
    resp.setCookie('dtpref_cols',str(cols),path='/',expires=e)
    return self.manage_main(
        self,REQUEST,title=title,__str__=self.quotedHTML(data),
        dtpref_cols=cols,dtpref_rows=rows)
</t>
<t tx="ekr.20040104185913.2672">def manage_edit(self,data,title,SUBMIT='Change',dtpref_cols='100%',
                dtpref_rows='20',REQUEST=None):
    """
    Replaces a Documents contents with Data, Title with Title.

    The SUBMIT parameter is also used to change the size of the editing
    area on the default Document edit screen.  If the value is "Smaller",
    the rows and columns decrease by 5.  If the value is "Bigger", the
    rows and columns increase by 5.  If any other or no value is supplied,
    the data gets checked for DTML errors and is saved.
    """
    self._validateProxy(REQUEST)
    if self._size_changes.has_key(SUBMIT):
        return self._er(data,title,SUBMIT,dtpref_cols,dtpref_rows,REQUEST)
    if self.wl_isLocked():
        raise ResourceLockedError, 'This DTML Method is locked via WebDAV'

    self.title=str(title)
    if type(data) is not type(''): data=data.read()
    self.munge(data)
    self.ZCacheable_invalidate()
    if REQUEST:
        message="Saved changes."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2673">def manage_upload(self,file='', REQUEST=None):
    """Replace the contents of the document with the text in file."""
    self._validateProxy(REQUEST)
    if self.wl_isLocked():
        raise ResourceLockedError, 'This DTML Method is locked via WebDAV'

    if type(file) is not type(''):
        if REQUEST and not file:
            raise ValueError, 'No file specified'
        file=file.read()

    self.munge(file)
    self.ZCacheable_invalidate()
    if REQUEST:
        message="Saved changes."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2674">def manage_haveProxy(self,r): return r in self._proxy_roles
</t>
<t tx="ekr.20040104185913.2675">def _validateProxy(self, request, roles=None):
    if roles is None: roles=self._proxy_roles
    if not roles: return
    user=u=getSecurityManager().getUser()
    user=user.allowed
    for r in roles:
        if r and not user(self, (r,)):
            user=None
            break

    if user is not None: return

    raise 'Forbidden', (
        'You are not authorized to change &lt;em&gt;%s&lt;/em&gt; because you '
        'do not have proxy roles.\n&lt;!--%s, %s--&gt;' % (self.__name__, u, roles))
</t>
<t tx="ekr.20040104185913.2676">def manage_proxy(self, roles=(), REQUEST=None):
    "Change Proxy Roles"
    self._validateProxy(REQUEST, roles)
    self._validateProxy(REQUEST)
    self._proxy_roles=tuple(roles)
    self.ZCacheable_invalidate()
    if REQUEST:
        message="Saved changes."
        return self.manage_proxyForm(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2677">def PrincipiaSearchSource(self):
    "Support for searching - the document's contents are searched."
    return self.read()
</t>
<t tx="ekr.20040104185913.2678">def document_src(self, REQUEST=None, RESPONSE=None):
    """Return unprocessed document source."""
    if RESPONSE is not None:
        RESPONSE.setHeader('Content-Type', 'text/plain')
    return self.read()
</t>
<t tx="ekr.20040104185913.2679">## Protocol handlers

def PUT(self, REQUEST, RESPONSE):
    """Handle HTTP PUT requests."""
    self.dav__init(REQUEST, RESPONSE)
    self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)
    body=REQUEST.get('BODY', '')
    self._validateProxy(REQUEST)
    self.munge(body)
    self.ZCacheable_invalidate()
    RESPONSE.setStatus(204)
    return RESPONSE
</t>
<t tx="ekr.20040104185913.2680">def manage_FTPget(self):
    "Get source for FTP download"
    return self.read()
</t>
<t tx="ekr.20040104185913.2681">def manage_historyCompare(self, rev1, rev2, REQUEST,
                          historyComparisonResults=''):
    return DTMLMethod.inheritedAttribute('manage_historyCompare')(
        self, rev1, rev2, REQUEST,
        historyComparisonResults=History.html_diff(
            rev1.read(), rev2.read()
            ))
</t>
<t tx="ekr.20040104185913.2682">import re
token = "[a-zA-Z0-9!#$%&amp;'*+\-.\\\\^_`|~]+"
hdr_start = re.compile(r'(%s):(.*)' % token).match


def decapitate(html, RESPONSE=None):
    headers = []
    spos  = 0
    eolen = 1
    while 1:
        m = hdr_start(html, spos)
        if not m:
            if html[spos:spos+2] == '\r\n':
                eolen = 2
                break
            if html[spos:spos+1] == '\n':
                eolen = 1
                break
            return html
        header = list(m.groups())
        headers.append(header)
        spos = m.end() + 1
        while spos &lt; len(html) and html[spos] in ' \t':
            eol = html.find('\r\n', spos)
            if eol &lt;&gt; -1:
                eolen = 2
            else:
                eol = html.find('\n', spos)
                if eol &lt; 0: return html
                eolen = 1
            header.append(html[spos:eol].strip())
            spos = eol + eolen
    if RESPONSE is not None:
        for header in headers:
            hkey = header.pop(0)
            RESPONSE.setHeader(hkey, ' '.join(header).strip())
    return html[spos + eolen:]
</t>
<t tx="ekr.20040104185913.2683">default_dm_html="""&lt;dtml-var standard_html_header&gt;
&lt;h2&gt;&lt;dtml-var title_or_id&gt; &lt;dtml-var document_title&gt;&lt;/h2&gt;
&lt;p&gt;
This is the &lt;dtml-var document_id&gt; Document
in the &lt;dtml-var title_and_id&gt; Folder.
&lt;/p&gt;
&lt;dtml-var standard_html_footer&gt;"""

addForm=DTMLFile('dtml/methodAdd', globals())

def addDTMLMethod(self, id, title='', file='', REQUEST=None, submit=None):
    """Add a DTML Method object with the contents of file. If
    'file' is empty, default document text is used.
    """
    if type(file) is not type(''): file=file.read()
    if not file: file=default_dm_html
    id=str(id)
    title=str(title)
    ob=DTMLMethod(file, __name__=id)
    ob.title=title
    id=self._setObject(id, ob)
    if REQUEST is not None:
        try: u=self.DestinationURL()
        except: u=REQUEST['URL1']
        if submit==" Add and Edit ": u="%s/%s" % (u,quote(id))
        REQUEST.RESPONSE.redirect(u+'/manage_main')
    return ''
</t>
<t tx="ekr.20040104185913.2684">&lt;&lt; DefaultObservable declarations &gt;&gt;
@others

    observer = TestObserver()

    # Simulate Zope's path traversal mechanism.
    paths = {}
    paths[ 'direct'         ] = observer
    paths[ 'direct/named'   ] = observer.namedCallback
    paths[ 'direct/named2'  ] = observer.named2Callback
    paths[ 'bound'          ] = observer.boundCallback
    paths[ 'freefunc'       ] = freefuncObserver
    paths[ 'tryVeto'        ] = tryVeto

    subject = TestSubject( paths )

    subject.registerObserver( 'direct' )
    subject.registerObserver( 'bound' )
    subject.registerObserver( 'direct/named' )
    subject.registerObserver( ( 'direct', 'named2' ) )
    subject.registerObserver( 'freefunc' )
    subject.registerObserver( 'tryVeto' )

    try:
        subject.registerObserver( 'nonesuch' )
        raise DontGoHere( 'path not found' )
    except NameError:
        pass
    except:
        import traceback
        traceback.print_exc()

    try:
        subject.registerObserver( 3.1415926 )
        raise DontGoHere( 'non-path' )
    except TypeError:
        pass
    except:
        import traceback
        traceback.print_exc()

    subject.notify( 'First event' )

    subject.unregisterObserver( 'bound' )
    subject.notify( { 'name' : 'Second event', 'value' : 42 } )

    for key in callbacks.keys():
        print '[%s]' % key
        for cb in callbacks[ key ]:
            print '    %s' % `cb`
</t>
<t tx="ekr.20040104185913.2685">&lt;&lt; copyright &gt;&gt;
__doc__="""Implement Observable interface (see
http://www.zope.org/Members/michel/Projects/Interfaces/ObserverAndNotification)
This class is intended to be used as a mixin (note that it doesn't derive
from any Zope persistence classes, for instance).

$Id: DefaultObservable.py,v 1.6 2002/08/14 21:42:56 mj Exp $"""

__version__='$Revision: 1.6 $'[11:-2]

from types import StringType

</t>
<t tx="ekr.20040104185913.2686">class DefaultObservable:
    """
    See the Interfaces wiki for design notes:

http://www.zope.org/Members/michel/Projects/Interfaces/ObserverAndNotification

    DefaultObservable is intended to be used as a mix-in, like so::

        from OFS.SimpleItem import SimpleItem
        from OFS.DefaultObservable import DefaultObservable

        class Foo( SimpleItem, DefaultObservable ):
            '''
                Some foo or other
            '''
            ...
            def bar( self, ... ):
                '''
                '''
                ...
                self.notify( "bar" )

    Clients register with a Foo instance using the methods of the
    Observable interface, e.g.::

        foo.registerObserver( self.getPhysicalPath() + ( 'watchFoo',) )

    When the Foo instance has its 'bar()' method called, it will
    notify all registered observers, passing 'bar' as the event;  in
    this case, the client's 'watchFoo()' method will be called, with
    the foo object and 'bar' passed as parameters.
    """
	@others
</t>
<t tx="ekr.20040104185913.2687">def __init__( self, debug=0 ):
    self._observers = []
    self._debug = debug
</t>
<t tx="ekr.20040104185913.2688">def _normalize( self, observer ):

    # Assert that observer is a string or a sequence of strings.
    if type( observer ) != StringType:
        observer = '/'.join( observer)

    return observer
</t>
<t tx="ekr.20040104185913.2689">#
#   Observable interface methods.
#
def registerObserver( self, observer ):

    normal = self._normalize( observer )
    if self.restrictedTraverse( normal, None ):
        self._observers.append( normal )
    else:
        raise NameError, observer
</t>
<t tx="ekr.20040104185913.2690">def unregisterObserver( self, observer ):

    self._observers.remove( self._normalize( observer ) )
</t>
<t tx="ekr.20040104185913.2691">#
#   Convenience method for derivatives.
#
def notify( self, event=None ):

    bozos = []

    for observer in self._observers:

        obj = self.restrictedTraverse( observer, None )

        if obj is not None:
            try:
                obj( self, event )
            except:
                bozos.append( observer ) # Veto not allowed!
                if self._debug:
                    import traceback
                    traceback.print_exc()
        else:
            bozos.append( observer )

    for bozo in bozos:
        try: # avoid race condition if unregister() called before now
            self._observers.remove( bozo )
        except:
            pass
</t>
<t tx="ekr.20040104185913.2692">#
#   Unit tests
#

if __name__ == '__main__':

    class DontGoHere( Exception ): pass
</t>
<t tx="ekr.20040104185913.2693">class TestSubject( DefaultObservable ):
	@others
</t>
<t tx="ekr.20040104185913.2694">def __init__( self, paths ):
    DefaultObservable.__init__( self, 0 )
    self.paths = paths
</t>
<t tx="ekr.20040104185913.2695">def restrictedTraverse( self, path, default ):
    return self.paths.get( path, default )
</t>
<t tx="ekr.20040104185913.2696">callbacks = {}

def recordCallback( name, subject, event ):
    cbrec = callbacks.get( name, None )
    if cbrec is None:
        cbrec = callbacks[ name ] = []
    cbrec.append( ( subject, event ) )
</t>
<t tx="ekr.20040104185913.2697">class TestObserver:
	@others
</t>
<t tx="ekr.20040104185913.2698">def __call__( self, subject, event ):
    recordCallback( 'direct', subject, event )
</t>
<t tx="ekr.20040104185913.2699">def namedCallback( self, subject, event ):
    recordCallback( 'named', subject, event )
</t>
<t tx="ekr.20040104185913.2700">def named2Callback( self, subject, event ):
    recordCallback( 'named2', subject, event )
</t>
<t tx="ekr.20040104185913.2701">def boundCallback( self, subject, event ):
    recordCallback( 'bound', subject, event )
</t>
<t tx="ekr.20040104185913.2702">def freefuncObserver( subject, event ):
    recordCallback( 'freefunc', subject, event )
</t>
<t tx="ekr.20040104185913.2703">def tryVeto( subject, event ):
    """ Simulate attempted veto. """
    raise 'Idawanna!'
</t>
<t tx="ekr.20040104185913.2704">&lt;&lt; copyright &gt;&gt;
"""Deprecated - use DTMLMethod"""

__version__='$Revision: 1.76 $'[11:-2]

import DTMLMethod

Document=DTMLMethod.DTMLMethod
manage_addDocument=DTMLMethod.addDTMLMethod
</t>
<t tx="ekr.20040104185913.2705">&lt;&lt; FTPInterface declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2706">&lt;&lt; copyright &gt;&gt;

"""FTP Support for Zope classes.

Preliminary FTP support interface. Note, most FTP functions are
provided by existing methods such as PUT and manage_delObjects.

All FTP methods should be governed by a single permission:
'FTP access'.

"""

</t>
<t tx="ekr.20040104185913.2707">class FTPInterface:
	&lt;&lt; class FTPInterface declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2708">"Interface for FTP objects"

# XXX The stat and list marshal format should probably
#     be XML, not marshal, maybe Andrew K's xml-marshal.
#     This will probably be changed later.

</t>
<t tx="ekr.20040104185913.2709">def manage_FTPstat(self,REQUEST):
    """Returns a stat-like tuple. (marshalled to a string) Used by
    FTP for directory listings, and MDTM and SIZE"""
</t>
<t tx="ekr.20040104185913.2710">def manage_FTPlist(self,REQUEST):
    """Returns a directory listing consisting of a tuple of
    (id,stat) tuples, marshaled to a string. Note, the listing it
    should include '..' if there is a Folder above the current
    one.

    In the case of non-foldoid objects it should return a single
    tuple (id,stat) representing itself."""
</t>
<t tx="ekr.20040104185913.2711"># Optional method to support FTP download.
# Should not be implemented by Foldoid objects.

def manage_FTPget(self):
    """Returns the source content of an object. For example, the
    source text of a Document, or the data of a file."""
</t>
<t tx="ekr.20040104185913.2712">&lt;&lt; FindSupport declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2713">&lt;&lt; copyright &gt;&gt;
__doc__="""Find support"""
__version__='$Revision: 1.31 $'[11:-2]


import sys, os, time, Globals, ExtensionClass
from DocumentTemplate.DT_Util import Eval
from AccessControl.Permission import name_trans
from Globals import DTMLFile
from DocumentTemplate.DT_Util import InstanceDict, TemplateDict
from DateTime import DateTime
from string import translate
from AccessControl.DTML import RestrictedDTML

</t>
<t tx="ekr.20040104185913.2714">class FindSupport(ExtensionClass.Base):
    """Find support for Zope Folders"""
	&lt;&lt; class FindSupport declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2715">#findframe is deprecated
manage_findFrame=DTMLFile('dtml/findFrame', globals())
manage_findForm=DTMLFile('dtml/findForm', globals(),
                         management_view='Find')
manage_findAdv=DTMLFile('dtml/findAdv', globals(),
                        management_view='Find',
                        help_topic='Find_Advanced.stx',
                        help_product='OFSP')
manage_findResult=DTMLFile('dtml/findResult', globals(),
                           management_view='Find')

__ac_permissions__=(
    ('View management screens',
     ('manage_findFrame', 'manage_findForm', 'manage_findAdv',
      'manage_findResult')),
    )

manage_options=(
    {'label':'Find', 'action':'manage_findForm',
     'help':('OFSP','Find.stx')},
    )

</t>
<t tx="ekr.20040104185913.2716">def ZopeFind(self, obj, obj_ids=None, obj_metatypes=None,
             obj_searchterm=None, obj_expr=None,
             obj_mtime=None, obj_mspec=None,
             obj_permission=None, obj_roles=None,
             search_sub=0,
             REQUEST=None, result=None, pre=''):
    """Zope Find interface"""

    if result is None:
        result=[]

        if obj_metatypes and 'all' in obj_metatypes:
            obj_metatypes=None

        if obj_mtime and type(obj_mtime)==type('s'):
            obj_mtime=DateTime(obj_mtime).timeTime()

        if obj_permission:
            obj_permission=p_name(obj_permission)

        if obj_roles and type(obj_roles) is type('s'):
            obj_roles=[obj_roles]

        if obj_expr:
            # Setup expr machinations
            md=td()
            obj_expr=(Eval(obj_expr), md, md._push, md._pop)

    base=obj
    if hasattr(obj, 'aq_base'):
        base=obj.aq_base

    if hasattr(base, 'objectItems'):
        try:    items=obj.objectItems()
        except: return result
    else:
        if getattr(base, 'meta_type', None) == 'Z Class':
            try:    items=obj.propertysheets.methods.objectItems()
            except: return result
        else:
            return result

    try: add_result=result.append
    except:
        raise AttributeError, `result`

    for id, ob in items:
        if pre: p="%s/%s" % (pre, id)
        else:   p=id

        dflag=0
        if hasattr(ob, '_p_changed') and (ob._p_changed == None):
            dflag=1

        if hasattr(ob, 'aq_base'):
            bs=ob.aq_base
        else: bs=ob

        if (
            (not obj_ids or absattr(bs.getId()) in obj_ids)
            and
            (not obj_metatypes or (hasattr(bs, 'meta_type') and
             bs.meta_type in obj_metatypes))
            and
            (not obj_searchterm or
             (hasattr(ob, 'PrincipiaSearchSource') and
              ob.PrincipiaSearchSource().find(obj_searchterm) &gt;= 0
              ))
            and
            (not obj_expr or expr_match(ob, obj_expr))
            and
            (not obj_mtime or mtime_match(ob, obj_mtime, obj_mspec))
            and
            ( (not obj_permission or not obj_roles) or \
               role_match(ob, obj_permission, obj_roles)
            )
            ):
            add_result((p, ob))
            dflag=0

        is_zclass = getattr(bs, 'meta_type', None) == 'Z Class'
        if search_sub and (hasattr(bs, 'objectItems') or is_zclass):
            if is_zclass:
                subob = ob.propertysheets.methods
                sub_p = '%s/propertysheets/methods' % p
            else:
                subob = ob
                sub_p = p
            self.ZopeFind(subob, obj_ids, obj_metatypes,
                               obj_searchterm, obj_expr,
                               obj_mtime, obj_mspec,
                               obj_permission, obj_roles,
                               search_sub,
                               REQUEST, result, sub_p)
        if dflag: ob._p_deactivate()

    return result
</t>
<t tx="ekr.20040104185913.2717">PrincipiaFind=ZopeFind

def ZopeFindAndApply(self, obj, obj_ids=None, obj_metatypes=None,
                     obj_searchterm=None, obj_expr=None,
                     obj_mtime=None, obj_mspec=None,
                     obj_permission=None, obj_roles=None,
                     search_sub=0,
                     REQUEST=None, result=None, pre='',
                     apply_func=None, apply_path=''):
    """Zope Find interface and apply"""

    if result is None:
        result=[]

        if obj_metatypes and 'all' in obj_metatypes:
            obj_metatypes=None

        if obj_mtime and type(obj_mtime)==type('s'):
            obj_mtime=DateTime(obj_mtime).timeTime()

        if obj_permission:
            obj_permission=p_name(obj_permission)

        if obj_roles and type(obj_roles) is type('s'):
            obj_roles=[obj_roles]

        if obj_expr:
            # Setup expr machinations
            md=td()
            obj_expr=(Eval(obj_expr), md, md._push, md._pop)

    base=obj
    if hasattr(obj, 'aq_base'):
        base=obj.aq_base

    if not hasattr(base, 'objectItems'):
        return result
    try:    items=obj.objectItems()
    except: return result

    try: add_result=result.append
    except:
        raise AttributeError, `result`

    for id, ob in items:
        if pre: p="%s/%s" % (pre, id)
        else:   p=id

        dflag=0
        if hasattr(ob, '_p_changed') and (ob._p_changed == None):
            dflag=1

        if hasattr(ob, 'aq_base'):
            bs=ob.aq_base
        else: bs=ob

        if (
            (not obj_ids or absattr(bs.getId()) in obj_ids)
            and
            (not obj_metatypes or (hasattr(bs, 'meta_type') and
             bs.meta_type in obj_metatypes))
            and
            (not obj_searchterm or
             (hasattr(ob, 'PrincipiaSearchSource') and
              ob.PrincipiaSearchSource().find(obj_searchterm) &gt;= 0
              ))
            and
            (not obj_expr or expr_match(ob, obj_expr))
            and
            (not obj_mtime or mtime_match(ob, obj_mtime, obj_mspec))
            and
            ( (not obj_permission or not obj_roles) or \
               role_match(ob, obj_permission, obj_roles)
            )
            ):
            if apply_func:
                apply_func(ob, (apply_path+'/'+p))
            else:
                add_result((p, ob))
                dflag=0

        if search_sub and hasattr(bs, 'objectItems'):
            self.ZopeFindAndApply(ob, obj_ids, obj_metatypes,
                                  obj_searchterm, obj_expr,
                                  obj_mtime, obj_mspec,
                                  obj_permission, obj_roles,
                                  search_sub,
                                  REQUEST, result, p,
                                  apply_func, apply_path)
        if dflag: ob._p_deactivate()

    return result
</t>
<t tx="ekr.20040104185913.2718">class td(RestrictedDTML, TemplateDict):
	&lt;&lt; class td declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2719">pass


</t>
<t tx="ekr.20040104185913.2720">def expr_match(ob, ed, c=InstanceDict, r=0):
    e, md, push, pop=ed
    push(c(ob, md))
    try: r=e.eval(md)
    finally:
        pop()
        return r
</t>
<t tx="ekr.20040104185913.2721">def mtime_match(ob, t, q, fn=hasattr):
    if not fn(ob, '_p_mtime'):
        return 0
    return q=='&lt;' and (ob._p_mtime &lt; t) or (ob._p_mtime &gt; t)
</t>
<t tx="ekr.20040104185913.2722">def role_match(ob, permission, roles, lt=type([]), tt=type(())):
    pr=[]
    fn=pr.append

    while 1:
        if hasattr(ob, permission):
            p=getattr(ob, permission)
            if type(p) is lt:
                map(fn, p)
                if hasattr(ob, 'aq_parent'):
                    ob=ob.aq_parent
                    continue
                break
            if type(p) is tt:
                map(fn, p)
                break
            if p is None:
                map(fn, ('Manager', 'Anonymous'))
                break

        if hasattr(ob, 'aq_parent'):
            ob=ob.aq_parent
            continue
        break

    for role in roles:
        if not (role in pr):
            return 0
    return 1
</t>
<t tx="ekr.20040104185913.2723">Globals.default__class_init__(FindSupport)

# Helper functions

def absattr(attr):
    if callable(attr): return attr()
    return attr
</t>
<t tx="ekr.20040104185913.2724">def p_name(name):
    return '_' + translate(name, name_trans) + '_Permission'
</t>
<t tx="ekr.20040104185913.2725">&lt;&lt; Folder declarations &gt;&gt;
@others
Globals.default__class_init__(Folder)
</t>
<t tx="ekr.20040104185913.2726">&lt;&lt; copyright &gt;&gt;

"""Folder object

Folders are the basic container objects and are analogous to directories.

$Id: Folder.py,v 1.101 2002/08/14 21:42:56 mj Exp $"""

__version__='$Revision: 1.101 $'[11:-2]

import Globals, SimpleItem, ObjectManager, PropertyManager
import AccessControl.Role, webdav.Collection, FindSupport
from webdav.WriteLockInterface import WriteLockInterface
from AccessControl import Unauthorized

from Globals import DTMLFile
from AccessControl import getSecurityManager


manage_addFolderForm=DTMLFile('dtml/folderAdd', globals())

</t>
<t tx="ekr.20040104185913.2727">def manage_addFolder(self, id, title='',
                     createPublic=0,
                     createUserF=0,
                     REQUEST=None):
    """Add a new Folder object with id *id*.

    If the 'createPublic' and 'createUserF' parameters are set to any true
    value, an 'index_html' and a 'UserFolder' objects are created respectively
    in the new folder.
    """
    ob=Folder()
    ob.id=str(id)
    ob.title=title
    self._setObject(id, ob)
    ob=self._getOb(id)

    checkPermission=getSecurityManager().checkPermission

    if createUserF:
        if not checkPermission('Add User Folders', ob):
            raise Unauthorized, (
                  'You are not authorized to add User Folders.'
                  )
        ob.manage_addUserFolder()

    if createPublic:
        if not checkPermission('Add Page Templates', ob):
            raise Unauthorized, (
                  'You are not authorized to add Page Templates.'
                  )
        ob.manage_addProduct['PageTemplates'].manage_addPageTemplate(
            id='index_html', title='')

    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
</t>
<t tx="ekr.20040104185913.2728">class Folder(
	&lt;&lt; class Folder declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2729">ObjectManager.ObjectManager,
PropertyManager.PropertyManager,
AccessControl.Role.RoleManager,
webdav.Collection.Collection,
SimpleItem.Item,
FindSupport.FindSupport,
):
"""
Folders are basic container objects that provide a standard
interface for object management. Folder objects also implement
a management interface and can have arbitrary properties.
"""
__implements__ = (WriteLockInterface,)
meta_type='Folder'

_properties=({'id':'title', 'type': 'string','mode':'w'},)

manage_options=(
    ObjectManager.ObjectManager.manage_options+
    (
    {'label':'View', 'action':'',
     'help':('OFSP','Folder_View.stx')},
    )+
    PropertyManager.PropertyManager.manage_options+
    AccessControl.Role.RoleManager.manage_options+
    SimpleItem.Item.manage_options+
    FindSupport.FindSupport.manage_options
    )

__ac_permissions__=()


</t>
<t tx="ekr.20040104185913.2730">&lt;&lt; History declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2731">&lt;&lt; copyright &gt;&gt;
"""Object Histories"""

__version__='$Revision: 1.14.6.2 $'[11:-2]

import Globals, ExtensionClass, difflib
from DateTime import DateTime
from Acquisition import Implicit, aq_base
from struct import pack, unpack
from cgi import escape

</t>
<t tx="ekr.20040104185913.2732">class TemporalParadox(Exception): pass
</t>
<t tx="ekr.20040104185913.2733">class HistorySelectionError(Exception): pass
</t>
<t tx="ekr.20040104185913.2734">class HystoryJar:
    """A ZODB Connection-like object that provides access to data
    but prevents history from being changed."""
	@others

    tpc_begin = tpc_finish = abort</t>
<t tx="ekr.20040104185913.2735">def __init__(self, base):
    self.__base__=base
</t>
<t tx="ekr.20040104185913.2736">def __getattr__(self, name):
    return getattr(self.__base__, name)
</t>
<t tx="ekr.20040104185913.2737">def commit(self, object, transaction):
    if object._p_changed:
        raise TemporalParadox, "You can't change history!"
</t>
<t tx="ekr.20040104185913.2738">def abort(*args, **kw): pass
</t>
<t tx="ekr.20040104185913.2739">def historicalRevision(self, serial):
    state=self._p_jar.oldstate(self, serial)
    rev=self.__class__.__basicnew__()
    rev._p_jar=HystoryJar(self._p_jar)
    rev._p_oid=self._p_oid
    rev._p_serial=serial
    rev.__setstate__(state)
    rev._p_changed=0
    return rev
</t>
<t tx="ekr.20040104185913.2740">class Historian(Implicit):
    """An Historian's job is to find hysterical revisions of
    objects, given a time."""
	@others
</t>
<t tx="ekr.20040104185913.2741">def __getitem__(self, key):
    self=self.aq_parent

    serial=apply(pack, ('&gt;HHHH',)+tuple(map(int, key.split('.'))))

    if serial == self._p_serial: return self

    rev=historicalRevision(self, serial)

    return rev.__of__(self.aq_parent)
</t>
<t tx="ekr.20040104185913.2742">def manage_workspace(self, REQUEST):
    "We aren't real, so we delegate to that that spawned us!"
    raise 'Redirect', REQUEST['URL2']+'/manage_change_history_page'
</t>
<t tx="ekr.20040104185913.2743">class Historical(ExtensionClass.Base):
    """Mix-in class to provide a veiw that shows hystorical changes

    The display is similar to that used for undo, except that the transactions
    are limited to those that effect the displayed object and that the
    interface doesn't provide an undo capability.

    This interface is generally *only* interesting for objects, such
    as methods, and documents, that are self-contained, meaning that
    they don't have persistent sub-objects.
    """
	&lt;&lt; class Historical declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2744">HistoricalRevisions=Historian()

__ac_permissions__=(
    ('View History',
     ('manage_change_history_page','manage_change_history',
      'manage_historyCompare', 'manage_historicalComparison',
      )
     ),
    )

manage_options=({'label':'History', 'action':'manage_change_history_page',
                 'help':('OFSP','History.stx')
                 },
               )

manage_change_history_page=Globals.DTMLFile(
    'dtml/history', globals(),
    HistoryBatchSize=20,
    first_transaction=0, last_transaction=20)

</t>
<t tx="ekr.20040104185913.2745">def manage_change_history(self):
    first=0
    last=20
    request=getattr(self, 'REQUEST', None)
    if request is not None:
        first=request.get('first_transaction', first)
        last=request.get('last_transaction',last)


    r=self._p_jar.db().history(self._p_oid, None, last)
    if r is None:
        # storage doesn't support history
        return ()
    r=r[first:]

    for d in r:
        d['time']=DateTime(d['time'])
        d['key']='.'.join(map(str, unpack("&gt;HHHH", d['serial'])))

    return r
</t>
<t tx="ekr.20040104185913.2746">def manage_beforeHistoryCopy(self): pass # ? (Hook)
</t>
<t tx="ekr.20040104185913.2747">def manage_historyCopy(self, keys=[], RESPONSE=None, URL1=None):
    "Copy a selected revision to the present"
    if not keys:
        raise HistorySelectionError, (
            "No historical revision was selected.&lt;p&gt;")

    if len(keys) &gt; 1:
        raise HistorySelectionError, (
            "Only one historical revision can be "
            "copied to the present.&lt;p&gt;")

    key=keys[0]
    serial=apply(pack, ('&gt;HHHH',)+tuple(map(int, key.split('.'))))

    if serial != self._p_serial:
        self.manage_beforeHistoryCopy()
        state=self._p_jar.oldstate(self, serial)
        # Scrub the object before restoring the old state
        base = aq_base(self)
        base._p_changed=0
        base._p_deactivate()
        base.__setstate__(state)
        base._p_changed=1

        self.manage_afterHistoryCopy()

    if RESPONSE is not None and URL1 is not None:
        RESPONSE.redirect(URL1+'/manage_workspace')
</t>
<t tx="ekr.20040104185913.2748">def manage_afterHistoryCopy(self): pass # ? (Hook)
</t>
<t tx="ekr.20040104185913.2749">_manage_historyComparePage=Globals.DTMLFile(
    'dtml/historyCompare', globals(), management_view='History')
def manage_historyCompare(self, rev1, rev2, REQUEST,
                          historyComparisonResults=''):
    dt1=DateTime(rev1._p_mtime)
    dt2=DateTime(rev2._p_mtime)
    return self._manage_historyComparePage(
        self, REQUEST,
        dt1=dt1, dt2=dt2,
        historyComparisonResults=historyComparisonResults)
</t>
<t tx="ekr.20040104185913.2750">def manage_historicalComparison(self, REQUEST, keys=[]):
    "Compare two selected revisions"
    if not keys:
        raise HistorySelectionError, (
            "No historical revision was selected.&lt;p&gt;")
    if len(keys) &gt; 2:
        raise HistorySelectionError, (
            "Only two historical revision can be compared&lt;p&gt;")

    serial=apply(pack, ('&gt;HHHH',)+tuple(map(int, keys[-1].split('.'))))
    rev1=historicalRevision(self, serial)

    if len(keys)==2:
        serial=apply(pack,
                     ('&gt;HHHH',)+tuple(map(int, keys[0].split('.'))))

        rev2=historicalRevision(self, serial)
    else:
        rev2=self

    return self.manage_historyCompare(rev1, rev2, REQUEST)
</t>
<t tx="ekr.20040104185913.2751">Globals.default__class_init__(Historical)

def dump(tag, x, lo, hi, r):
    r1=[]
    r2=[]
    for i in xrange(lo, hi):
        r1.append(tag)
        r2.append(x[i])
    r.append("&lt;tr&gt;\n"
            "&lt;td&gt;&lt;pre&gt;\n%s\n&lt;/pre&gt;&lt;/td&gt;\n"
            "&lt;td&gt;&lt;pre&gt;\n%s\n&lt;/pre&gt;&lt;/td&gt;\n"
            "&lt;/tr&gt;\n"
            % ('\n'.join(r1), escape('\n'.join(r2))))
</t>
<t tx="ekr.20040104185913.2752">def replace(x, xlo, xhi, y, ylo, yhi, r):

    rx1=[]
    rx2=[]
    for i in xrange(xlo, xhi):
        rx1.append('-')
        rx2.append(x[i])

    ry1=[]
    ry2=[]
    for i in xrange(ylo, yhi):
        ry1.append('+')
        ry2.append(y[i])


    r.append("&lt;tr&gt;\n"
            "&lt;td&gt;&lt;pre&gt;\n%s\n%s\n&lt;/pre&gt;&lt;/td&gt;\n"
            "&lt;td&gt;&lt;pre&gt;\n%s\n%s\n&lt;/pre&gt;&lt;/td&gt;\n"
            "&lt;/tr&gt;\n"
            % ('\n'.join(rx1), '\n'.join(ry1),
               escape('\n'.join(rx2)), escape('\n'.join(ry2))))
</t>
<t tx="ekr.20040104185913.2753">def html_diff(s1, s2):
    a=s1.split('\n')
    b=s2.split('\n')
    cruncher=difflib.SequenceMatcher()
    cruncher.set_seqs(a,b)

    r=['&lt;table border=1&gt;']
    for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
        if tag == 'replace':
            replace(a, alo, ahi, b, blo, bhi, r)
        elif tag == 'delete':
            dump('-', a, alo, ahi, r)
        elif tag == 'insert':
            dump('+', b, blo, bhi, r)
        elif tag == 'equal':
            dump(' ', a, alo, ahi, r)
        else:
            raise ValueError, 'unknown tag ' + `tag`
    r.append('&lt;/table&gt;')

    return '\n'.join(r)
</t>
<t tx="ekr.20040104185913.2754">&lt;&lt; Image declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2755">&lt;&lt; copyright &gt;&gt;
"""Image object"""

__version__='$Revision: 1.141.4.6 $'[11:-2]

import Globals, struct
from OFS.content_types import guess_content_type
from Globals import DTMLFile
from PropertyManager import PropertyManager
from AccessControl.Role import RoleManager
from webdav.common import rfc1123_date
from webdav.Lockable import ResourceLockedError
from webdav.WriteLockInterface import WriteLockInterface
from SimpleItem import Item_w__name__
from cStringIO import StringIO
from Globals import Persistent
from Acquisition import Implicit
from DateTime import DateTime
from Cache import Cacheable
from mimetools import choose_boundary
from ZPublisher import HTTPRangeSupport
from ZPublisher.HTTPRequest import FileUpload
from cgi import escape

StringType=type('')
manage_addFileForm=DTMLFile('dtml/imageAdd', globals(),Kind='File',kind='file')
</t>
<t tx="ekr.20040104185913.2756">def manage_addFile(self,id,file='',title='',precondition='', content_type='',
                   REQUEST=None):
    """Add a new File object.

    Creates a new File object 'id' with the contents of 'file'"""

    id=str(id)
    title=str(title)
    content_type=str(content_type)
    precondition=str(precondition)

    id, title = cookId(id, title, file)

    self=self.this()

    # First, we create the file without data:
    self._setObject(id, File(id,title,'',content_type, precondition))

    # Now we "upload" the data.  By doing this in two steps, we
    # can use a database trick to make the upload more efficient.
    if file:
        self._getOb(id).manage_upload(file)
    if content_type:
        self._getOb(id).content_type=content_type

    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(self.absolute_url()+'/manage_main')
</t>
<t tx="ekr.20040104185913.2757">class File(Persistent, Implicit, PropertyManager,
	&lt;&lt; class File declarations &gt;&gt;
	@others

    manage_FTPget=index_html</t>
<t tx="ekr.20040104185913.2758">RoleManager, Item_w__name__, Cacheable):
"""A File object is a content object for arbitrary files."""

__implements__ = (WriteLockInterface, HTTPRangeSupport.HTTPRangeInterface)
meta_type='File'


precondition=''
size=None

manage_editForm  =DTMLFile('dtml/fileEdit',globals(),
                    Kind='File',kind='file')
manage_editForm._setName('manage_editForm')
manage=manage_main=manage_editForm
manage_uploadForm=manage_editForm

manage_options=(
(
{'label':'Edit', 'action':'manage_main',
'help':('OFSP','File_Edit.stx')},
{'label':'View', 'action':'',
'help':('OFSP','File_View.stx')},
)
+ PropertyManager.manage_options
+ RoleManager.manage_options
+ Item_w__name__.manage_options
+ Cacheable.manage_options
)


__ac_permissions__=(
('View management screens',
('manage', 'manage_main',)),
('Change Images and Files',
('manage_edit','manage_upload','PUT')),
('View',
('index_html', 'view_image_or_file', 'get_size',
'getContentType', '')),
('FTP access',
('manage_FTPstat','manage_FTPget','manage_FTPlist')),
('Delete objects',
('DELETE',)),
)


_properties=({'id':'title', 'type': 'string'},
      {'id':'content_type', 'type':'string'},
      )

</t>
<t tx="ekr.20040104185913.2759">def __init__(self, id, title, file, content_type='', precondition=''):
    self.__name__=id
    self.title=title
    self.precondition=precondition

    data, size = self._read_data(file)
    content_type=self._get_content_type(file, data, id, content_type)
    self.update_data(data, content_type, size)
</t>
<t tx="ekr.20040104185913.2760">def id(self):
    return self.__name__
</t>
<t tx="ekr.20040104185913.2761">def index_html(self, REQUEST, RESPONSE):
    """
    The default view of the contents of a File or Image.

    Returns the contents of the file or image.  Also, sets the
    Content-Type HTTP header to the objects content type.
    """

    # HTTP If-Modified-Since header handling.
    header=REQUEST.get_header('If-Modified-Since', None)
    if header is not None:
        header=header.split( ';')[0]
        # Some proxies seem to send invalid date strings for this
        # header. If the date string is not valid, we ignore it
        # rather than raise an error to be generally consistent
        # with common servers such as Apache (which can usually
        # understand the screwy date string as a lucky side effect
        # of the way they parse it).
        # This happens to be what RFC2616 tells us to do in the face of an
        # invalid date.
        try:    mod_since=long(DateTime(header).timeTime())
        except: mod_since=None
        if mod_since is not None:
            if self._p_mtime:
                last_mod = long(self._p_mtime)
            else:
                last_mod = long(0)
            if last_mod &gt; 0 and last_mod &lt;= mod_since:
                # Set header values since apache caching will return Content-Length
                # of 0 in response if size is not set here
                RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))
                RESPONSE.setHeader('Content-Type', self.content_type)
                RESPONSE.setHeader('Content-Length', self.size)
                RESPONSE.setHeader('Accept-Ranges', 'bytes')
                self.ZCacheable_set(None)
                RESPONSE.setStatus(304)
                return ''

    if self.precondition and hasattr(self,self.precondition):
        # Grab whatever precondition was defined and then
        # execute it.  The precondition will raise an exception
        # if something violates its terms.
        c=getattr(self,self.precondition)
        if hasattr(c,'isDocTemp') and c.isDocTemp:
            c(REQUEST['PARENTS'][1],REQUEST)
        else:
            c()

    # HTTP Range header handling
    range = REQUEST.get_header('Range', None)
    request_range = REQUEST.get_header('Request-Range', None)
    if request_range is not None:
        # Netscape 2 through 4 and MSIE 3 implement a draft version
        # Later on, we need to serve a different mime-type as well.
        range = request_range
    if_range = REQUEST.get_header('If-Range', None)
    if range is not None:
        ranges = HTTPRangeSupport.parseRange(range)

        if if_range is not None:
            # Only send ranges if the data isn't modified, otherwise send
            # the whole object. Support both ETags and Last-Modified dates!
            if len(if_range) &gt; 1 and if_range[:2] == 'ts':
                # ETag:
                if if_range != self.http__etag():
                    # Modified, so send a normal response. We delete
                    # the ranges, which causes us to skip to the 200
                    # response.
                    ranges = None
            else:
                # Date
                date = if_range.split( ';')[0]
                try: mod_since=long(DateTime(date).timeTime())
                except: mod_since=None
                if mod_since is not None:
                    if self._p_mtime:
                        last_mod = long(self._p_mtime)
                    else:
                        last_mod = long(0)
                    if last_mod &gt; mod_since:
                        # Modified, so send a normal response. We delete
                        # the ranges, which causes us to skip to the 200
                        # response.
                        ranges = None

        if ranges:
            # Search for satisfiable ranges.
            satisfiable = 0
            for start, end in ranges:
                if start &lt; self.size:
                    satisfiable = 1
                    break

            if not satisfiable:
                RESPONSE.setHeader('Content-Range',
                    'bytes */%d' % self.size)
                RESPONSE.setHeader('Accept-Ranges', 'bytes')
                RESPONSE.setHeader('Last-Modified',
                    rfc1123_date(self._p_mtime))
                RESPONSE.setHeader('Content-Type', self.content_type)
                RESPONSE.setHeader('Content-Length', self.size)
                RESPONSE.setStatus(416)
                return ''

            ranges = HTTPRangeSupport.expandRanges(ranges, self.size)
                            
            if len(ranges) == 1:
                # Easy case, set extra header and return partial set.
                start, end = ranges[0]
                size = end - start

                RESPONSE.setHeader('Last-Modified',
                    rfc1123_date(self._p_mtime))
                RESPONSE.setHeader('Content-Type', self.content_type)
                RESPONSE.setHeader('Content-Length', size)
                RESPONSE.setHeader('Accept-Ranges', 'bytes')
                RESPONSE.setHeader('Content-Range',
                    'bytes %d-%d/%d' % (start, end - 1, self.size))
                RESPONSE.setStatus(206) # Partial content

                data = self.data
                if type(data) is StringType:
                    return data[start:end]

                # Linked Pdata objects. Urgh.
                pos = 0
                while data is not None:
                    l = len(data.data)
                    pos = pos + l
                    if pos &gt; start:
                        # We are within the range
                        lstart = l - (pos - start)

                        if lstart &lt; 0: lstart = 0

                        # find the endpoint
                        if end &lt;= pos:
                            lend = l - (pos - end)

                            # Send and end transmission
                            RESPONSE.write(data[lstart:lend])
                            break

                        # Not yet at the end, transmit what we have.
                        RESPONSE.write(data[lstart:])

                    data = data.next

                return ''

            else:
                boundary = choose_boundary()

                # Calculate the content length
                size = (8 + len(boundary) + # End marker length
                    len(ranges) * (         # Constant lenght per set
                        49 + len(boundary) + len(self.content_type) +
                        len('%d' % self.size)))
                for start, end in ranges:
                    # Variable length per set
                    size = (size + len('%d%d' % (start, end - 1)) +
                        end - start)


                # Some clients implement an earlier draft of the spec, they
                # will only accept x-byteranges.
                draftprefix = (request_range is not None) and 'x-' or ''

                RESPONSE.setHeader('Content-Length', size)
                RESPONSE.setHeader('Accept-Ranges', 'bytes')
                RESPONSE.setHeader('Last-Modified',
                    rfc1123_date(self._p_mtime))
                RESPONSE.setHeader('Content-Type',
                    'multipart/%sbyteranges; boundary=%s' % (
                        draftprefix, boundary))
                RESPONSE.setStatus(206) # Partial content

                data = self.data
                # The Pdata map allows us to jump into the Pdata chain
                # arbitrarily during out-of-order range searching.
                pdata_map = {}
                pdata_map[0] = data

                for start, end in ranges:
                    RESPONSE.write('\r\n--%s\r\n' % boundary)
                    RESPONSE.write('Content-Type: %s\r\n' %
                        self.content_type)
                    RESPONSE.write(
                        'Content-Range: bytes %d-%d/%d\r\n\r\n' % (
                            start, end - 1, self.size))

                    if type(data) is StringType:
                        RESPONSE.write(data[start:end])

                    else:
                        # Yippee. Linked Pdata objects. The following
                        # calculations allow us to fast-forward through the
                        # Pdata chain without a lot of dereferencing if we
                        # did the work already.
                        first_size = len(pdata_map[0].data)
                        if start &lt; first_size:
                            closest_pos = 0
                        else:
                            closest_pos = (
                                ((start - first_size) &gt;&gt; 16 &lt;&lt; 16) +
                                first_size)
                        pos = min(closest_pos, max(pdata_map.keys()))
                        data = pdata_map[pos]

                        while data is not None:
                            l = len(data.data)
                            pos = pos + l
                            if pos &gt; start:
                                # We are within the range
                                lstart = l - (pos - start)

                                if lstart &lt; 0: lstart = 0

                                # find the endpoint
                                if end &lt;= pos:
                                    lend = l - (pos - end)

                                    # Send and loop to next range
                                    RESPONSE.write(data[lstart:lend])
                                    break

                                # Not yet at the end, transmit what we have.
                                RESPONSE.write(data[lstart:])

                            data = data.next
                            # Store a reference to a Pdata chain link so we
                            # don't have to deref during this request again.
                            pdata_map[pos] = data

                # Do not keep the link references around.
                del pdata_map

                RESPONSE.write('\r\n--%s--\r\n' % boundary)
                return ''

    RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))
    RESPONSE.setHeader('Content-Type', self.content_type)
    RESPONSE.setHeader('Content-Length', self.size)
    RESPONSE.setHeader('Accept-Ranges', 'bytes')

    # Don't cache the data itself, but provide an opportunity
    # for a cache manager to set response headers.
    self.ZCacheable_set(None)

    data=self.data
    if type(data) is type(''): 
        RESPONSE.setBase(None)
        return data

    while data is not None:
        RESPONSE.write(data.data)
        data=data.next

    return ''
</t>
<t tx="ekr.20040104185913.2762">def view_image_or_file(self, URL1):
    """
    The default view of the contents of the File or Image.
    """
    raise 'Redirect', URL1
</t>
<t tx="ekr.20040104185913.2763"># private
update_data__roles__=()
def update_data(self, data, content_type=None, size=None):
    if content_type is not None: self.content_type=content_type
    if size is None: size=len(data)
    self.size=size
    self.data=data
    self.ZCacheable_invalidate()
    self.http__refreshEtag()
</t>
<t tx="ekr.20040104185913.2764">def manage_edit(self, title, content_type, precondition='',
                filedata=None, REQUEST=None):
    """
    Changes the title and content type attributes of the File or Image.
    """
    if self.wl_isLocked():
        raise ResourceLockedError, "File is locked via WebDAV"

    self.title=str(title)
    self.content_type=str(content_type)
    if precondition: self.precondition=str(precondition)
    elif self.precondition: del self.precondition
    if filedata is not None:
        self.update_data(filedata, content_type, len(filedata))
    else:
        self.ZCacheable_invalidate()
    if REQUEST:
        message="Saved changes."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2765">def manage_upload(self,file='',REQUEST=None):
    """
    Replaces the current contents of the File or Image object with file.

    The file or images contents are replaced with the contents of 'file'.
    """
    if self.wl_isLocked():
        raise ResourceLockedError, "File is locked via WebDAV"

    data, size = self._read_data(file)
    content_type=self._get_content_type(file, data, self.__name__,
                                        'application/octet-stream')
    self.update_data(data, content_type, size)

    if REQUEST:
        message="Saved changes."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2766">def _get_content_type(self, file, body, id, content_type=None):
    headers=getattr(file, 'headers', None)
    if headers and headers.has_key('content-type'):
        content_type=headers['content-type']
    else:
        if type(body) is not type(''): body=body.data
        content_type, enc=guess_content_type(
            getattr(file, 'filename',id), body, content_type)
    return content_type
</t>
<t tx="ekr.20040104185913.2767">def _read_data(self, file):

    n=1 &lt;&lt; 16

    if type(file) is StringType:
        size=len(file)
        if size &lt; n: return file, size
        return Pdata(file), size
    elif isinstance(file, FileUpload) and not file:
        raise ValueError, 'File not specified'

    if hasattr(file, '__class__') and file.__class__ is Pdata:
        size=len(file)
        return file, size

    seek=file.seek
    read=file.read

    seek(0,2)
    size=end=file.tell()

    if size &lt;= 2*n:
        seek(0)
        if size &lt; n: return read(size), size
        return Pdata(read(size)), size

    # Make sure we have an _p_jar, even if we are a new object, by
    # doing a sub-transaction commit.
    get_transaction().commit(1)

    jar=self._p_jar

    if jar is None:
        # Ugh
        seek(0)
        return Pdata(read(size)), size

    # Now we're going to build a linked list from back
    # to front to minimize the number of database updates
    # and to allow us to get things out of memory as soon as
    # possible.
    next=None
    while end &gt; 0:
        pos=end-n
        if pos &lt; n: pos=0 # we always want at least n bytes
        seek(pos)
        data=Pdata(read(end-pos))

        # Woooop Woooop Woooop! This is a trick.
        # We stuff the data directly into our jar to reduce the
        # number of updates necessary.
        data._p_jar=jar

        # This is needed and has side benefit of getting
        # the thing registered:
        data.next=next

        # Now make it get saved in a sub-transaction!
        get_transaction().commit(1)

        # Now make it a ghost to free the memory.  We
        # don't need it anymore!
        data._p_changed=None

        next=data
        end=pos

    return next, size
</t>
<t tx="ekr.20040104185913.2768">def PUT(self, REQUEST, RESPONSE):
    """Handle HTTP PUT requests"""
    self.dav__init(REQUEST, RESPONSE)
    self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)
    type=REQUEST.get_header('content-type', None)

    file=REQUEST['BODYFILE']

    data, size = self._read_data(file)
    content_type=self._get_content_type(file, data, self.__name__,
                                        type or self.content_type)
    self.update_data(data, content_type, size)

    RESPONSE.setStatus(204)
    return RESPONSE
</t>
<t tx="ekr.20040104185913.2769">def get_size(self):
    """Get the size of a file or image.

    Returns the size of the file or image.
    """
    size=self.size
    if size is None: size=len(self.data)
    return size
</t>
<t tx="ekr.20040104185913.2770"># deprecated; use get_size!
getSize=get_size

def getContentType(self):
    """Get the content type of a file or image.

    Returns the content type (MIME type) of a file or image.
    """
    return self.content_type
</t>
<t tx="ekr.20040104185913.2771">def __str__(self): return str(self.data)
</t>
<t tx="ekr.20040104185913.2772">def __len__(self): return 1
</t>
<t tx="ekr.20040104185913.2773">manage_addImageForm=DTMLFile('dtml/imageAdd',globals(),
                             Kind='Image',kind='image')
def manage_addImage(self, id, file, title='', precondition='', content_type='',
                    REQUEST=None):
    """
    Add a new Image object.

    Creates a new Image object 'id' with the contents of 'file'.
    """

    id=str(id)
    title=str(title)
    content_type=str(content_type)
    precondition=str(precondition)

    id, title = cookId(id, title, file)

    self=self.this()

    # First, we create the image without data:
    self._setObject(id, Image(id,title,'',content_type, precondition))

    # Now we "upload" the data.  By doing this in two steps, we
    # can use a database trick to make the upload more efficient.
    if file:
        self._getOb(id).manage_upload(file)
    if content_type:
        self._getOb(id).content_type=content_type

    if REQUEST is not None:
        try:    url=self.DestinationURL()
        except: url=REQUEST['URL1']
        REQUEST.RESPONSE.redirect('%s/manage_main' % url)
    return id
</t>
<t tx="ekr.20040104185913.2774">def getImageInfo(data):
    data = str(data)
    size = len(data)
    height = -1
    width = -1
    content_type = ''

    # handle GIFs
    if (size &gt;= 10) and data[:6] in ('GIF87a', 'GIF89a'):
        # Check to see if content_type is correct
        content_type = 'image/gif'
        w, h = struct.unpack("&lt;HH", data[6:10])
        width = int(w)
        height = int(h)

    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)
    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'
    # and finally the 4-byte width, height
    elif ((size &gt;= 24) and (data[:8] == '\211PNG\r\n\032\n')
          and (data[12:16] == 'IHDR')):
        content_type = 'image/png'
        w, h = struct.unpack("&gt;LL", data[16:24])
        width = int(w)
        height = int(h)

    # Maybe this is for an older PNG version.
    elif (size &gt;= 16) and (data[:8] == '\211PNG\r\n\032\n'):
        # Check to see if we have the right content type
        content_type = 'image/png'
        w, h = struct.unpack("&gt;LL", data[8:16])
        width = int(w)
        height = int(h)

    # handle JPEGs
    elif (size &gt;= 2) and (data[:2] == '\377\330'):
        content_type = 'image/jpeg'
        jpeg = StringIO(data)
        jpeg.read(2)
        b = jpeg.read(1)
        try:
            while (b and ord(b) != 0xDA):
                while (ord(b) != 0xFF): b = jpeg.read(1)
                while (ord(b) == 0xFF): b = jpeg.read(1)
                if (ord(b) &gt;= 0xC0 and ord(b) &lt;= 0xC3):
                    jpeg.read(3)
                    h, w = struct.unpack("&gt;HH", jpeg.read(4))
                    break
                else:
                    jpeg.read(int(struct.unpack("&gt;H", jpeg.read(2))[0])-2)
                b = jpeg.read(1)
            width = int(w)
            height = int(h)
        except: pass

    return content_type, width, height
</t>
<t tx="ekr.20040104185913.2775">class Image(File):
    """Image objects can be GIF, PNG or JPEG and have the same methods
    as File objects.  Images also have a string representation that
    renders an HTML 'IMG' tag.
    """
	&lt;&lt; class Image declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2776">__implements__ = (WriteLockInterface,)
meta_type='Image'


height=''
width=''

__ac_permissions__=(
    ('View management screens',
     ('manage', 'manage_main',)),
    ('Change Images and Files',
     ('manage_edit','manage_upload','PUT')),
    ('View',
     ('index_html', 'tag', 'view_image_or_file', 'get_size',
      'getContentType', '')),
    ('FTP access',
     ('manage_FTPstat','manage_FTPget','manage_FTPlist')),
    ('Delete objects',
     ('DELETE',)),
    )

_properties=({'id':'title', 'type': 'string'},
             {'id':'content_type', 'type':'string','mode':'w'},
             {'id':'height', 'type':'string'},
             {'id':'width', 'type':'string'},
             )

manage_options=(
    ({'label':'Edit', 'action':'manage_main',
     'help':('OFSP','Image_Edit.stx')},
     {'label':'View', 'action':'view_image_or_file',
     'help':('OFSP','Image_View.stx')},)
    + PropertyManager.manage_options
    + RoleManager.manage_options
    + Item_w__name__.manage_options
    + Cacheable.manage_options
    )

manage_editForm  =DTMLFile('dtml/imageEdit',globals(),
                           Kind='Image',kind='image')
view_image_or_file =DTMLFile('dtml/imageView',globals())
manage_editForm._setName('manage_editForm')
manage=manage_main=manage_editForm
manage_uploadForm=manage_editForm

# private
update_data__roles__=()
</t>
<t tx="ekr.20040104185913.2777">def update_data(self, data, content_type=None, size=None):
    if size is None: size=len(data)

    self.size=size
    self.data=data

    ct, width, height = getImageInfo(data)
    if ct:
        content_type = ct
    if width &gt;= 0 and height &gt;= 0:
        self.width = width
        self.height = height

    # Now we should have the correct content type, or still None
    if content_type is not None: self.content_type = content_type

    self.ZCacheable_invalidate()
</t>
<t tx="ekr.20040104185913.2778">def __str__(self):
    return self.tag()
</t>
<t tx="ekr.20040104185913.2779">def tag(self, height=None, width=None, alt=None,
        scale=0, xscale=0, yscale=0, css_class=None, title=None, **args):
    """
    Generate an HTML IMG tag for this image, with customization.
    Arguments to self.tag() can be any valid attributes of an IMG tag.
    'src' will always be an absolute pathname, to prevent redundant
    downloading of images. Defaults are applied intelligently for
    'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',
    and 'yscale' keyword arguments will be used to automatically adjust
    the output height and width values of the image tag.

    Since 'class' is a Python reserved word, it cannot be passed in
    directly in keyword arguments which is a problem if you are
    trying to use 'tag()' to include a CSS class. The tag() method
    will accept a 'css_class' argument that will be converted to
    'class' in the output tag to work around this.
    """
    if height is None: height=self.height
    if width is None:  width=self.width

    # Auto-scaling support
    xdelta = xscale or scale
    ydelta = yscale or scale

    if xdelta and width:
        width =  str(int(round(int(width) * xdelta)))
    if ydelta and height:
        height = str(int(round(int(height) * ydelta)))

    result='&lt;img src="%s"' % (self.absolute_url())

    if alt is None:
        alt=getattr(self, 'title', '')
    result = '%s alt="%s"' % (result, escape(alt, 1))

    if title is None:
        title=getattr(self, 'title', '')
    result = '%s title="%s"' % (result, escape(title, 1))

    if height:
        result = '%s height="%s"' % (result, height)

    if width:
        result = '%s width="%s"' % (result, width)

    if not 'border' in [ x.lower() for x in  args.keys()]:
        result = '%s border="0"' % result

    if css_class is not None:
        result = '%s class="%s"' % (result, css_class)

    for key in args.keys():
        value = args.get(key)
        result = '%s %s="%s"' % (result, key, value)

    return '%s /&gt;' % result
</t>
<t tx="ekr.20040104185913.2780">def cookId(id, title, file):
    if not id and hasattr(file,'filename'):
        filename=file.filename
        title=title or filename
        id=filename[max(filename.rfind('/'),
                        filename.rfind('\\'),
                        filename.rfind(':'),
                        )+1:]
    return id, title
</t>
<t tx="ekr.20040104185913.2781">class Pdata(Persistent, Implicit):
	&lt;&lt; class Pdata declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2782"># Wrapper for possibly large data

next=None

</t>
<t tx="ekr.20040104185913.2783">def __init__(self, data):
    self.data=data
</t>
<t tx="ekr.20040104185913.2784">def __getslice__(self, i, j):
    return self.data[i:j]
</t>
<t tx="ekr.20040104185913.2785">def __len__(self):
    data = str(self)
    return len(data)
</t>
<t tx="ekr.20040104185913.2786">def __str__(self):
    next=self.next
    if next is None: return self.data

    r=[self.data]
    while next is not None:
        self=next
        r.append(self.data)
        next=self.next

    return ''.join(r)
</t>
<t tx="ekr.20040104185913.2787">&lt;&lt; Moniker declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2788">&lt;&lt; copyright &gt;&gt;
"""Object monikers

   An object moniker is an intelligent reference to a
   persistent object. A moniker can be turned back into
   a real object that retains its correct version context
   and aquisition relationships via a simple interface.

"""
__version__='$Revision: 1.16 $'[11:-2]


import Globals

</t>
<t tx="ekr.20040104185913.2789">class Moniker:
    """An object moniker is an intelligent reference to a
    persistent object. A moniker can be turned back into
    a real object that retains its correct version context
    and acquisition relationships via a simple interface."""
	@others
</t>
<t tx="ekr.20040104185913.2790">def __init__(self, ob=None):
    if ob is None: return
    self.idpath = ob.getPhysicalPath()
</t>
<t tx="ekr.20040104185913.2791">def bind(self, app):
    "Returns the real object named by this moniker"
    ob = app.unrestrictedTraverse(self.idpath)
    return ob
</t>
<t tx="ekr.20040104185913.2792">def dump(self):
    '''Returns an object which can be reconstituted by
    loadMoniker().  Result must be compatible with marshal.dump().
    '''
    return self.idpath
</t>
<t tx="ekr.20040104185913.2793">def loadMoniker(data):
    '''Re-creates a Moniker object from the given data which had been
    generated by Moniker.dump().'''
    m = Moniker()
    m.idpath = data
    return m
</t>
<t tx="ekr.20040104185913.2794">def absattr(attr):
    if callable(attr): return attr()
    return attr
</t>
<t tx="ekr.20040104185913.2795">&lt;&lt; ObjectManager declarations &gt;&gt;
@others

Globals.default__class_init__(ObjectManager)
</t>
<t tx="ekr.20040104185913.2796">&lt;&lt; copyright &gt;&gt;
__doc__="""Object Manager

$Id: ObjectManager.py,v 1.158 2002/08/14 21:42:56 mj Exp $"""

__version__='$Revision: 1.158 $'[11:-2]

import App.Management, Acquisition, Globals, CopySupport, Products
import os, App.FactoryDispatcher, re, Products
from OFS.Traversable import Traversable
from OFS import SimpleItem
from Globals import DTMLFile, Persistent
from Globals import MessageDialog, default__class_init__
from Globals import REPLACEABLE, NOT_REPLACEABLE, UNIQUE
from webdav.NullResource import NullResource
from webdav.Collection import Collection
from Acquisition import aq_base
from AccessControl.SecurityInfo import ClassSecurityInfo
from urllib import quote
from cStringIO import StringIO
import marshal
import App.Common
from AccessControl import getSecurityManager
from zLOG import LOG, ERROR
import sys,fnmatch,copy
from cgi import escape
from types import StringType, UnicodeType

import XMLExportImport
customImporters={
    XMLExportImport.magic: XMLExportImport.importXML,
    }

bad_id=re.compile(r'[^a-zA-Z0-9-_~,.$\(\)# ]').search #TS

BadRequestException = 'Bad Request'

</t>
<t tx="ekr.20040104185913.2797">def checkValidId(self, id, allow_dup=0):
    # If allow_dup is false, an error will be raised if an object
    # with the given id already exists. If allow_dup is true,
    # only check that the id string contains no illegal chars;
    # check_valid_id() will be called again later with allow_dup
    # set to false before the object is added.

    if not id or not isinstance(id, StringType):
        if isinstance(id, UnicodeType): id = escape(id)
        raise BadRequestException, ('Empty or invalid id specified', id)
    if bad_id(id) is not None:
        raise BadRequestException, (
            'The id "%s" contains characters illegal in URLs.' % escape(id))
    if id[0]=='_': raise BadRequestException, (
        'The id "%s" is invalid - it begins with an underscore.'  % id)
    if id[:3]=='aq_': raise BadRequestException, (
        'The id "%s" is invalid - it begins with "aq_".'  % id)
    if id[-2:]=='__': raise BadRequestException, (
        'The id "%s" is invalid - it ends with two underscores.'  % id)
    if not allow_dup:
        obj = getattr(self, id, None)
        if obj is not None:
            # An object by the given id exists either in this
            # ObjectManager or in the acquisition path.
            flags = getattr(obj, '__replaceable__', NOT_REPLACEABLE)
            if hasattr(aq_base(self), id):
                # The object is located in this ObjectManager.
                if not flags &amp; REPLACEABLE:
                    raise BadRequestException, ('The id "%s" is invalid--'
                                          'it is already in use.' % id)
                # else the object is replaceable even if the UNIQUE
                # flag is set.
            elif flags &amp; UNIQUE:
                raise BadRequestException, ('The id "%s" is reserved.' % id)
    if id == 'REQUEST':
        raise BadRequestException, 'REQUEST is a reserved name.'
    if '/' in id:
        raise BadRequestException, (
            'The id "%s" contains characters illegal in URLs.' % id
            )
</t>
<t tx="ekr.20040104185913.2798">class BeforeDeleteException( Exception ): pass # raise to veto deletion
</t>
<t tx="ekr.20040104185913.2799">class BreakoutException ( Exception ): pass  # raised to break out of loops
</t>
<t tx="ekr.20040104185913.2800">_marker=[]
class ObjectManager(
	&lt;&lt; class ObjectManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2801">CopySupport.CopyContainer,
App.Management.Navigation,
App.Management.Tabs,
Acquisition.Implicit,
Persistent,
Collection,
Traversable,
):
"""Generic object manager

This class provides core behavior for collections of heterogeneous objects.
"""

__ac_permissions__=(
    ('View management screens', ('manage_main','manage_menu')),
    ('Access contents information',
     ('objectIds', 'objectValues', 'objectItems',''),
     ('Anonymous', 'Manager'),
     ),
    ('Delete objects',     ('manage_delObjects',)),
    ('FTP access',         ('manage_FTPstat','manage_FTPlist')),
    ('Import/Export objects',
     ('manage_importObject','manage_importExportForm',
      'manage_exportObject')
     ),
)


meta_type  ='Object Manager'

meta_types=() # Sub-object types that are specific to this object

_objects   =()

manage_main=DTMLFile('dtml/main', globals())
manage_index_main=DTMLFile('dtml/index_main', globals())

manage_options=(
    {'label':'Contents', 'action':'manage_main',
     'help':('OFSP','ObjectManager_Contents.stx')},
    )

isAnObjectManager=1

isPrincipiaFolderish=1

</t>
<t tx="ekr.20040104185913.2802">def __class_init__(self):
    try:    mt=list(self.meta_types)
    except: mt=[]
    for b in self.__bases__:
        try:
            for t in b.meta_types:
                if t not in mt: mt.append(t)
        except: pass
    mt.sort()
    self.meta_types=tuple(mt)

    default__class_init__(self)
</t>
<t tx="ekr.20040104185913.2803">def all_meta_types(self, interfaces=None):
    # A list of products registered elsewhere
    external_candidates = []

    # Look at _product_meta_types, if there is one
    _pmt=()
    if hasattr(self, '_product_meta_types'): _pmt=self._product_meta_types
    elif hasattr(self, 'aq_acquire'):
        try: _pmt=self.aq_acquire('_product_meta_types')
        except:  pass
    external_candidates.extend(list(_pmt))

    # Look at all globally visible meta types.
    for entry in Products.meta_types:
        if ( (interfaces is not None) or (entry.get("visibility", None)=="Global") ):
            external_candidates.append(entry)

    # Filter the list of external candidates based on the
    # specified interface constraint
    if interfaces is None:
        interface_constrained_meta_types = external_candidates
    else:
        interface_constrained_meta_types = []
        for entry in external_candidates:
            try:
                eil = entry.get('interfaces',None)
                if eil is not None:
                    for ei in eil:
                        for i in interfaces:
                            if ei is i or ei.extends(i):
                                interface_constrained_meta_types.append(entry)
                                raise BreakoutException # only append 1ce
            except BreakoutException:
                pass

    # Meta types specified by this instance are not checked against the
    # interface constraint. This is as it always has been, but Im not
    # sure it is correct.
    interface_constrained_meta_types.extend(list(self.meta_types))

    # Filter the list based on each meta-types's container_filter
    meta_types = []
    for entry in interface_constrained_meta_types:
        container_filter = entry.get('container_filter',None)
        if container_filter is None:
            meta_types.append(entry)
        else:
            if container_filter(self):
                meta_types.append(entry)

    return meta_types
</t>
<t tx="ekr.20040104185913.2804">def _subobject_permissions(self):
    return (Products.__ac_permissions__+
            self.aq_acquire('_getProductRegistryData')('ac_permissions')
            )
</t>
<t tx="ekr.20040104185913.2805">def filtered_meta_types(self, user=None):
    # Return a list of the types for which the user has
    # adequate permission to add that type of object.
    user=getSecurityManager().getUser()
    meta_types=[]
    if callable(self.all_meta_types):
        all=self.all_meta_types()
    else:
        all=self.all_meta_types
    for meta_type in all:
        if meta_type.has_key('permission'):
            if user.has_permission(meta_type['permission'],self):
                meta_types.append(meta_type)
        else:
            meta_types.append(meta_type)
    return meta_types
</t>
<t tx="ekr.20040104185913.2806">_checkId = checkValidId

def _setOb(self, id, object): setattr(self, id, object)
</t>
<t tx="ekr.20040104185913.2807">def _delOb(self, id): delattr(self, id)
</t>
<t tx="ekr.20040104185913.2808">def _getOb(self, id, default=_marker):
    # FIXME: what we really need to do here is ensure that only
    # sub-items are returned. That could have a measurable hit
    # on performance as things are currently implemented, so for
    # the moment we just make sure not to expose private attrs.
    if id[:1] != '_' and hasattr(aq_base(self), id):
        return getattr(self, id)
    if default is _marker:
        raise AttributeError, id
    return default
</t>
<t tx="ekr.20040104185913.2809">def _setObject(self,id,object,roles=None,user=None, set_owner=1):
    v=self._checkId(id)
    if v is not None: id=v
    try:    t=object.meta_type
    except: t=None

    # If an object by the given id already exists, remove it.
    for object_info in self._objects:
        if object_info['id'] == id:
            self._delObject(id)
            break

    self._objects=self._objects+({'id':id,'meta_type':t},)
    self._setOb(id,object)
    object=self._getOb(id)

    if set_owner:
        object.manage_fixupOwnershipAfterAdd()

        # Try to give user the local role "Owner", but only if
        # no local roles have been set on the object yet.
        if hasattr(object, '__ac_local_roles__'):
            if object.__ac_local_roles__ is None:
                user=getSecurityManager().getUser()
                if user is not None:
                    name=user.getUserName()
                    if name != 'Anonymous User':
                        object.manage_setLocalRoles(name, ['Owner'])

    object.manage_afterAdd(object, self)
    return id
</t>
<t tx="ekr.20040104185913.2810">def manage_afterAdd(self, item, container):
    for object in self.objectValues():
        try: s=object._p_changed
        except: s=0
        if hasattr(aq_base(object), 'manage_afterAdd'):
            object.manage_afterAdd(item, container)
        if s is None: object._p_deactivate()
</t>
<t tx="ekr.20040104185913.2811">def manage_afterClone(self, item):
    for object in self.objectValues():
        try: s=object._p_changed
        except: s=0
        if hasattr(aq_base(object), 'manage_afterClone'):
            object.manage_afterClone(item)
        if s is None: object._p_deactivate()
</t>
<t tx="ekr.20040104185913.2812">def manage_beforeDelete(self, item, container):
    for object in self.objectValues():
        try: s=object._p_changed
        except: s=0
        try:
            if hasattr(aq_base(object), 'manage_beforeDelete'):
                object.manage_beforeDelete(item, container)
        except BeforeDeleteException, ob:
            raise
        except:
            LOG('Zope',ERROR,'manage_beforeDelete() threw',
                error=sys.exc_info())
            pass
        if s is None: object._p_deactivate()
</t>
<t tx="ekr.20040104185913.2813">def _delObject(self, id, dp=1):
    object=self._getOb(id)
    try:
        object.manage_beforeDelete(object, self)
    except BeforeDeleteException, ob:
        raise
    except:
        LOG('Zope',ERROR,'manage_beforeDelete() threw',
            error=sys.exc_info())
        pass
    self._objects=tuple(filter(lambda i,n=id: i['id']!=n, self._objects))
    self._delOb(id)

    # Indicate to the object that it has been deleted. This is
    # necessary for object DB mount points. Note that we have to
    # tolerate failure here because the object being deleted could
    # be a Broken object, and it is not possible to set attributes
    # on Broken objects.
    try:    object._v__object_deleted__ = 1
    except: pass
</t>
<t tx="ekr.20040104185913.2814">def objectIds(self, spec=None):
    # Returns a list of subobject ids of the current object.
    # If 'spec' is specified, returns objects whose meta_type
    # matches 'spec'.
    if spec is not None:
        if type(spec)==type('s'):
            spec=[spec]
        set=[]
        for ob in self._objects:
            if ob['meta_type'] in spec:
                set.append(ob['id'])
        return set
    return map(lambda i: i['id'], self._objects)
</t>
<t tx="ekr.20040104185913.2815">def objectValues(self, spec=None):
    # Returns a list of actual subobjects of the current object.
    # If 'spec' is specified, returns only objects whose meta_type
    # match 'spec'.
    return map(self._getOb, self.objectIds(spec))
</t>
<t tx="ekr.20040104185913.2816">def objectItems(self, spec=None):
    # Returns a list of (id, subobject) tuples of the current object.
    # If 'spec' is specified, returns only objects whose meta_type match
    # 'spec'
    r=[]
    a=r.append
    g=self._getOb
    for id in self.objectIds(spec): a((id, g(id)))
    return r
</t>
<t tx="ekr.20040104185913.2817">def objectMap(self):
    # Return a tuple of mappings containing subobject meta-data
    return tuple(map(lambda dict: dict.copy(), self._objects))
</t>
<t tx="ekr.20040104185913.2818">def objectIds_d(self,t=None):
    if hasattr(self, '_reserved_names'): n=self._reserved_names
    else: n=()
    if not n: return self.objectIds(t)
    r=[]
    a=r.append
    for id in self.objectIds(t):
        if id not in n: a(id)
    return r
</t>
<t tx="ekr.20040104185913.2819">def objectValues_d(self,t=None):
    return map(self._getOb, self.objectIds_d(t))
</t>
<t tx="ekr.20040104185913.2820">def objectItems_d(self,t=None):
    r=[]
    a=r.append
    g=self._getOb
    for id in self.objectIds_d(t): a((id, g(id)))
    return r
</t>
<t tx="ekr.20040104185913.2821">def objectMap_d(self,t=None):
    if hasattr(self, '_reserved_names'): n=self._reserved_names
    else: n=()
    if not n: return self._objects
    r=[]
    a=r.append
    for d in self._objects:
        if d['id'] not in n: a(d.copy())
    return r
</t>
<t tx="ekr.20040104185913.2822">def superValues(self,t):
    # Return all of the objects of a given type located in
    # this object and containing objects.
    if type(t)==type('s'): t=(t,)
    obj=self
    seen={}
    vals=[]
    relativePhysicalPath = ()
    have=seen.has_key
    x=0
    while x &lt; 100:
        if not hasattr(obj,'_getOb'): break
        get=obj._getOb
        if hasattr(obj,'_objects'):
            for i in obj._objects:
                try:
                    id=i['id']
                    physicalPath = relativePhysicalPath + (id,)
                    if (not have(physicalPath)) and (i['meta_type'] in t):
                        vals.append(get(id))
                        seen[physicalPath]=1
                except: pass

        if hasattr(obj,'aq_parent'):
            obj=obj.aq_parent
            relativePhysicalPath = ('..',) + relativePhysicalPath
        else:
            return vals
        x=x+1
    return vals
</t>
<t tx="ekr.20040104185913.2823">manage_addProduct=App.FactoryDispatcher.ProductDispatcher()

def manage_delObjects(self, ids=[], REQUEST=None):
    """Delete a subordinate object

    The objects specified in 'ids' get deleted.
    """
    if type(ids) is type(''): ids=[ids]
    if not ids:
        return MessageDialog(title='No items specified',
               message='No items were specified!',
               action ='./manage_main',)
    try:    p=self._reserved_names
    except: p=()
    for n in ids:
        if n in p:
            return MessageDialog(title='Not Deletable',
                   message='&lt;EM&gt;%s&lt;/EM&gt; cannot be deleted.' % escape(n),
                   action ='./manage_main',)
    while ids:
        id=ids[-1]
        v=self._getOb(id, self)
        if v is self:
            raise 'BadRequest', '%s does not exist' % escape(ids[-1])
        self._delObject(id)
        del ids[-1]
    if REQUEST is not None:
        return self.manage_main(self, REQUEST, update_menu=1)
</t>
<t tx="ekr.20040104185913.2824">def tpValues(self):
    # Return a list of subobjects, used by tree tag.
    r=[]
    if hasattr(aq_base(self), 'tree_ids'):
        tree_ids=self.tree_ids
        try:   tree_ids=list(tree_ids)
        except TypeError:
            pass
        if hasattr(tree_ids, 'sort'):
            tree_ids.sort()
        for id in tree_ids:
            if hasattr(self, id):
                r.append(self._getOb(id))
    else:
        obj_ids=self.objectIds()
        obj_ids.sort()
        for id in obj_ids:
            o=self._getOb(id)
            if hasattr(o, 'isPrincipiaFolderish') and \
               o.isPrincipiaFolderish:
                r.append(o)
    return r
</t>
<t tx="ekr.20040104185913.2825">def manage_exportObject(self, id='', download=None, toxml=None,
                        RESPONSE=None,REQUEST=None):
    """Exports an object to a file and returns that file."""
    if not id:
        # can't use getId() here (breaks on "old" exported objects)
        id=self.id
        if hasattr(id, 'im_func'): id=id()
        ob=self
    else: ob=self._getOb(id)

    suffix=toxml and 'xml' or 'zexp'

    if download:
        f=StringIO()
        if toxml: XMLExportImport.exportXML(ob._p_jar, ob._p_oid, f)
        else:     ob._p_jar.exportFile(ob._p_oid, f)
        if RESPONSE is not None:
            RESPONSE.setHeader('Content-type','application/data')
            RESPONSE.setHeader('Content-Disposition',
                               'inline;filename=%s.%s' % (id, suffix))
        return f.getvalue()

    f = os.path.join(CLIENT_HOME, '%s.%s' % (id, suffix))
    if toxml:
        XMLExportImport.exportXML(ob._p_jar, ob._p_oid, f)
    else:
        ob._p_jar.exportFile(ob._p_oid, f)

    if REQUEST is not None:
        return self.manage_main(self, REQUEST,
            manage_tabs_message=
            '&lt;em&gt;%s&lt;/em&gt; sucessfully exported to &lt;em&gt;%s&lt;/em&gt;' % (id,f),
            title = 'Object exported')
</t>
<t tx="ekr.20040104185913.2826">manage_importExportForm=DTMLFile('dtml/importExport',globals())

def manage_importObject(self, file, REQUEST=None, set_owner=1):
    """Import an object from a file"""
    dirname, file=os.path.split(file)
    if dirname:
        raise BadRequestException, 'Invalid file name %s' % escape(file)

    instance_home = INSTANCE_HOME
    zope_home = ZOPE_HOME

    for impath in (instance_home, zope_home):
        filepath = os.path.join(impath, 'import', file)
        if os.path.exists(filepath):
            break
    else:
        raise BadRequestException, 'File does not exist: %s' % escape(file)

    self._importObjectFromFile(filepath, verify=not not REQUEST,
                               set_owner=set_owner)

    if REQUEST is not None:
        return self.manage_main(self, REQUEST,
            manage_tabs_message='&lt;em&gt;%s&lt;/em&gt; sucessfully imported' % id,
            title = 'Object imported',
            update_menu=1)
</t>
<t tx="ekr.20040104185913.2827">def _importObjectFromFile(self, filepath, verify=1, set_owner=1):
    # locate a valid connection
    connection=self._p_jar
    obj=self

    while connection is None:
        obj=obj.aq_parent
        connection=obj._p_jar
    ob=connection.importFile(
        filepath, customImporters=customImporters)
    if verify: self._verifyObjectPaste(ob, validate_src=0)
    id=ob.id
    if hasattr(id, 'im_func'): id=id()
    self._setObject(id, ob, set_owner=set_owner)

    # try to make ownership implicit if possible in the context
    # that the object was imported into.
    ob=self._getOb(id)
    ob.manage_changeOwnershipType(explicit=0)
</t>
<t tx="ekr.20040104185913.2828"># FTP support methods

def manage_FTPlist(self, REQUEST):
    "Directory listing for FTP"
    out=()

    # check to see if we are being acquiring or not
    ob=self
    while 1:
        if App.Common.is_acquired(ob):
            raise ValueError('FTP List not supported on acquired objects')
        if not hasattr(ob,'aq_parent'):
            break
        ob=ob.aq_parent

    files=self.objectItems()

    # recursive ride through all subfolders (ls -R) (ajung)

    if REQUEST.environ.get('FTP_RECURSIVE',0) == 1:

        all_files = copy.copy(files)
        for f in files:
            if f[1].meta_type == "Folder":
                all_files.extend(findChilds(f[1]))
            else:
                all_files.append(f)

        files = all_files

    try:
        files.sort()
    except AttributeError:
        files=list(files)
        files.sort()

    # Perform globbing on list of files (ajung)

    globbing = REQUEST.environ.get('GLOBBING','')
    if globbing :
        files = filter(lambda x,g=globbing: fnmatch.fnmatch(x[0],g) , files)

    try:
        files.sort()
    except AttributeError:
        files=list(files)
        files.sort()

    if not (hasattr(self,'isTopLevelPrincipiaApplicationObject') and
            self.isTopLevelPrincipiaApplicationObject):
        files.insert(0,('..',self.aq_parent))
    for k,v in files:
        # Note that we have to tolerate failure here, because
        # Broken objects won't stat correctly. If an object fails
        # to be able to stat itself, we will ignore it.
        try:    stat=marshal.loads(v.manage_FTPstat(REQUEST))
        except: stat=None
        if stat is not None:
            out=out+((k,stat),)
    return marshal.dumps(out)
</t>
<t tx="ekr.20040104185913.2829">def manage_FTPstat(self,REQUEST):
    "Psuedo stat used for FTP listings"
    mode=0040000
    from AccessControl.User import nobody
    # check to see if we are acquiring our objectValues or not
    if not (len(REQUEST.PARENTS) &gt; 1 and
            self.objectValues() == REQUEST.PARENTS[1].objectValues()):
        try:
            if getSecurityManager().validateValue(self.manage_FTPlist):
                mode=mode | 0770
        except: pass
        if nobody.allowed(
                    self.manage_FTPlist,
                    self.manage_FTPlist.__roles__):
            mode=mode | 0007
    mtime=self.bobobase_modification_time().timeTime()
    # get owner and group
    owner=group='Zope'
    for user, roles in self.get_local_roles():
        if 'Owner' in roles:
            owner=user
            break
    return marshal.dumps((mode,0,0,1,owner,group,0,mtime,mtime,mtime))
</t>
<t tx="ekr.20040104185913.2830">def __getitem__(self, key):
    v=self._getOb(key, None)
    if v is not None: return v
    if hasattr(self, 'REQUEST'):
        request=self.REQUEST
        method=request.get('REQUEST_METHOD', 'GET')
        if request.maybe_webdav_client and not method in ('GET', 'POST'):
            return NullResource(self, key, request).__of__(self)
    raise KeyError, key
</t>
<t tx="ekr.20040104185913.2831">def findChilds(obj,dirname=''):
    """ recursive walk through the object hierarchy to
    find all childs of an object (ajung)
    """

    lst =[]
    for name,child in obj.objectItems():
        if child.meta_type=="Folder":
            lst.extend(findChilds(child,dirname+ obj.id + '/'))
        else:
            lst.append( (dirname + obj.id + "/" + name,child) )

    return lst
</t>
<t tx="ekr.20040104185913.2832">class IFAwareObjectManager:
	@others
</t>
<t tx="ekr.20040104185913.2833">def all_meta_types(self, interfaces=None):

    if interfaces is None:
        if hasattr(self, '_product_interfaces'):
            interfaces=self._product_interfaces
        elif hasattr(self, 'aq_acquire'):
            try: interfaces=self.aq_acquire('_product_interfaces')
            except: pass    # Bleah generic pass is bad

    return ObjectManager.all_meta_types(self, interfaces)
</t>
<t tx="ekr.20040104185913.2834">&lt;&lt; PropertyManager declarations &gt;&gt;
@others




Globals.default__class_init__(PropertyManager)
</t>
<t tx="ekr.20040104185913.2835">&lt;&lt; copyright &gt;&gt;

"""Property management"""
__version__='$Revision: 1.46.6.6 $'[11:-2]

import ExtensionClass, Globals
import ZDOM
from PropertySheets import DefaultPropertySheets, vps
from ZPublisher.Converters import type_converters
from Globals import DTMLFile, MessageDialog
from Acquisition import Implicit, aq_base
from Globals import Persistent
from cgi import escape



</t>
<t tx="ekr.20040104185913.2836">class PropertyManager(ExtensionClass.Base, ZDOM.ElementWithAttributes):
    """
    The PropertyManager mixin class provides an object with
    transparent property management. An object which wants to
    have properties should inherit from PropertyManager.

    An object may specify that it has one or more predefined
    properties, by specifying an _properties structure in its
    class::

      _properties=({'id':'title', 'type': 'string', 'mode': 'w'},
                   {'id':'color', 'type': 'string', 'mode': 'w'},
                   )

    The _properties structure is a sequence of dictionaries, where
    each dictionary represents a predefined property. Note that if a
    predefined property is defined in the _properties structure, you
    must provide an attribute with that name in your class or instance
    that contains the default value of the predefined property.

    Each entry in the _properties structure must have at least an 'id'
    and a 'type' key. The 'id' key contains the name of the property,
    and the 'type' key contains a string representing the object's type.
    The 'type' string must be one of the values: 'float', 'int', 'long',
    'string', 'lines', 'text', 'date', 'tokens', 'selection', or
    'multiple section'.

    For 'selection' and 'multiple selection' properties, there is an
    addition item in the property dictionay, 'select_variable' which
    provides the name of a property or method which returns a list of
    strings from which the selection(s) can be chosen.

    Each entry in the _properties structure may *optionally* provide a
    'mode' key, which specifies the mutability of the property. The 'mode'
    string, if present, must contain 0 or more characters from the set
    'w','d'.

    A 'w' present in the mode string indicates that the value of the
    property may be changed by the user. A 'd' indicates that the user
    can delete the property. An empty mode string indicates that the
    property and its value may be shown in property listings, but that
    it is read-only and may not be deleted.

    Entries in the _properties structure which do not have a 'mode' key
    are assumed to have the mode 'wd' (writeable and deleteable).

    To fully support property management, including the system-provided
    tabs and user interfaces for working with properties, an object which
    inherits from PropertyManager should include the following entry in
    its manage_options structure::

      {'label':'Properties', 'action':'manage_propertiesForm',}

    to ensure that a 'Properties' tab is displayed in its management
    interface. Objects that inherit from PropertyManager should also
    include the following entry in its __ac_permissions__ structure::

      ('Manage properties', ('manage_addProperty',
                             'manage_editProperties',
                             'manage_delProperties',
                             'manage_changeProperties',)),
    """
	&lt;&lt; class PropertyManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2837">manage_options=(
    {'label':'Properties', 'action':'manage_propertiesForm',
     'help':('OFSP','Properties.stx')},
    )

manage_propertiesForm=DTMLFile('dtml/properties', globals(),
                               property_extensible_schema__=1)
manage_propertyTypeForm=DTMLFile('dtml/propertyType', globals())

title=''
_properties=({'id':'title', 'type': 'string', 'mode':'w'},)
_reserved_names=()

__ac_permissions__=(
    ('Manage properties', ('manage_addProperty',
                           'manage_editProperties',
                           'manage_delProperties',
                           'manage_changeProperties',
                           'manage_propertiesForm',
                           'manage_propertyTypeForm',
                           'manage_changePropertyTypes',
                           )),
    ('Access contents information',
     ('hasProperty', 'propertyIds', 'propertyValues','propertyItems',
      'getProperty', 'getPropertyType', 'propertyMap', ''),
     ('Anonymous', 'Manager'),
     ),
    )

__propsets__=()
propertysheets=vps(DefaultPropertySheets)

</t>
<t tx="ekr.20040104185913.2838">def valid_property_id(self, id):
    if not id or id[:1]=='_' or (id[:3]=='aq_') \
       or (' ' in id) or hasattr(aq_base(self), id) or escape(id) != id:
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2839">def hasProperty(self, id):
    """Return true if object has a property 'id'"""
    for p in self._properties:
        if id==p['id']:
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.2840">def getProperty(self, id, d=None):
    """Get the property 'id', returning the optional second
       argument or None if no such property is found."""
    if self.hasProperty(id):
        return getattr(self, id)
    return d
</t>
<t tx="ekr.20040104185913.2841">def getPropertyType(self, id):
    """Get the type of property 'id', returning None if no
       such property exists"""
    for md in self._properties:
        if md['id']==id:
            return md.get('type', 'string')
    return None
</t>
<t tx="ekr.20040104185913.2842">def _wrapperCheck(self, object):
    # Raise an error if an object is wrapped.
    if hasattr(object, 'aq_base'):
        raise ValueError, 'Invalid property value: wrapped object'
    return
</t>
<t tx="ekr.20040104185913.2843">def _setPropValue(self, id, value):
    self._wrapperCheck(value)
    setattr(self,id,value)
</t>
<t tx="ekr.20040104185913.2844">def _delPropValue(self, id):
    delattr(self,id)
</t>
<t tx="ekr.20040104185913.2845">def _setProperty(self, id, value, type='string'):
    # for selection and multiple selection properties
    # the value argument indicates the select variable
    # of the property

    self._wrapperCheck(value)
    if not self.valid_property_id(id):
        raise 'Bad Request', 'Invalid or duplicate property id'

    if type in ('selection', 'multiple selection'):
        if not hasattr(self, value):
            raise 'Bad Request', 'No select variable %s' % value
        self._properties=self._properties + (
            {'id':id, 'type':type, 'select_variable':value},)
        if type=='selection':
            self._setPropValue(id, '')
        else:
            self._setPropValue(id, [])
    else:
        self._properties=self._properties+({'id':id,'type':type},)
        self._setPropValue(id, value)
</t>
<t tx="ekr.20040104185913.2846">def _updateProperty(self, id, value):
    # Update the value of an existing property. If value
    # is a string, an attempt will be made to convert
    # the value to the type of the existing property.
    self._wrapperCheck(value)
    if not self.hasProperty(id):
        raise 'Bad Request', 'The property %s does not exist' % escape(id)
    if type(value)==type(''):
        proptype=self.getPropertyType(id) or 'string'
        if type_converters.has_key(proptype):
            value=type_converters[proptype](value)
    self._setPropValue(id, value)
</t>
<t tx="ekr.20040104185913.2847">def _delProperty(self, id):
    if not self.hasProperty(id):
        raise ValueError, 'The property %s does not exist' % escape(id)
    self._delPropValue(id)
    self._properties=tuple(filter(lambda i, n=id: i['id'] != n,
                                  self._properties))
</t>
<t tx="ekr.20040104185913.2848">def propertyIds(self):
    """Return a list of property ids """
    return map(lambda i: i['id'], self._properties)
</t>
<t tx="ekr.20040104185913.2849">def propertyValues(self):
    """Return a list of actual property objects """
    return map(lambda i,s=self: getattr(s,i['id']), self._properties)
</t>
<t tx="ekr.20040104185913.2850">def propertyItems(self):
    """Return a list of (id,property) tuples """
    return map(lambda i,s=self: (i['id'],getattr(s,i['id'])),
                                self._properties)
</t>
<t tx="ekr.20040104185913.2851">def _propertyMap(self):
    """Return a tuple of mappings, giving meta-data for properties """
    return self._properties
</t>
<t tx="ekr.20040104185913.2852">def propertyMap(self):
    """
    Return a tuple of mappings, giving meta-data for properties.
    Return copies of the real definitions for security.
    """
    return tuple(map(lambda dict: dict.copy(), self._propertyMap()))
</t>
<t tx="ekr.20040104185913.2853">def propertyLabel(self, id):
    """Return a label for the given property id
    """
    return id
</t>
<t tx="ekr.20040104185913.2854">def propdict(self):
    dict={}
    for p in self._properties:
        dict[p['id']]=p
    return dict
</t>
<t tx="ekr.20040104185913.2855"># Web interface

def manage_addProperty(self, id, value, type, REQUEST=None):
    """Add a new property via the web. Sets a new property with
    the given id, type, and value."""
    if type_converters.has_key(type):
        value=type_converters[type](value)
    self._setProperty(id.strip(), value, type)
    if REQUEST is not None:
        return self.manage_propertiesForm(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2856">def manage_editProperties(self, REQUEST):
    """Edit object properties via the web.
    The purpose of this method is to change all property values,
    even those not listed in REQUEST; otherwise checkboxes that
    get turned off will be ignored.  Use manage_changeProperties()
    instead for most situations.
    """
    for prop in self._propertyMap():
        name=prop['id']
        if 'w' in prop.get('mode', 'wd'):
            if prop['type'] == 'multiple selection':
                value=REQUEST.get(name, [])
            else:
                value=REQUEST.get(name, '')
            self._updateProperty(name, value)
    if REQUEST:
        message="Saved changes."
        return self.manage_propertiesForm(self,REQUEST,
                                          manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2857">def manage_changeProperties(self, REQUEST=None, **kw):
    """Change existing object properties.

    Change object properties by passing either a mapping object
    of name:value pairs {'foo':6} or passing name=value parameters
    """
    if REQUEST is None:
        props={}
    else: props=REQUEST
    if kw:
        for name, value in kw.items():
            props[name]=value
    propdict=self.propdict()
    for name, value in props.items():
        if self.hasProperty(name):
            if not 'w' in propdict[name].get('mode', 'wd'):
                raise 'BadRequest', '%s cannot be changed' % escape(name)
            self._updateProperty(name, value)
    if REQUEST:
        message="Saved changes."
        return self.manage_propertiesForm(self,REQUEST,
                                          manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.2858"># Note - this is experimental, pending some community input.

def manage_changePropertyTypes(self, old_ids, props, REQUEST=None):
    """Replace one set of properties with another

    Delete all properties that have ids in old_ids, then add a
    property for each item in props.  Each item has a new_id,
    new_value, and new_type.  The type of new_value should match
    new_type.
    """
    err = self.manage_delProperties(old_ids)
    if err:
        if REQUEST is not None:
            return err
        return
    for prop in props:
        self._setProperty(prop.new_id, prop.new_value, prop.new_type)
    if REQUEST is not None:
        return self.manage_propertiesForm(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2859">def manage_delProperties(self, ids=None, REQUEST=None):
    """Delete one or more properties specified by 'ids'."""
    if REQUEST:
        # Bugfix for property named "ids" (Casey)
        if ids == self.getProperty('ids', None): ids = None
        ids = REQUEST.get('_ids', ids)
    if ids is None:
        return MessageDialog(
               title='No property specified',
               message='No properties were specified!',
               action ='./manage_propertiesForm',)
    propdict=self.propdict()
    nd=self._reserved_names
    for id in ids:
        if not hasattr(aq_base(self), id):
            raise 'BadRequest', (
                  'The property &lt;em&gt;%s&lt;/em&gt; does not exist' % escape(id))
        if (not 'd' in propdict[id].get('mode', 'wd')) or (id in nd):
            return MessageDialog(
            title  ='Cannot delete %s' % id,
            message='The property &lt;em&gt;%s&lt;/em&gt; cannot be deleted.' % id,
            action ='manage_propertiesForm')
        self._delProperty(id)

    if REQUEST is not None:
        return self.manage_propertiesForm(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2860">&lt;&lt; PropertySheets declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2861">&lt;&lt; copyright &gt;&gt;

"""Property sheets"""

__version__='$Revision: 1.87.6.2 $'[11:-2]

import time,  App.Management, Globals
from webdav.WriteLockInterface import WriteLockInterface
from ZPublisher.Converters import type_converters
from Globals import DTMLFile, MessageDialog
from Acquisition import Implicit, Explicit
from App.Common import rfc1123_date, iso8601_date
from webdav.common import urlbase
from ExtensionClass import Base
from Globals import Persistent
from Traversable import Traversable
from Acquisition import aq_base
from AccessControl import getSecurityManager
from webdav.common import isDavCollection
from cgi import escape

</t>
<t tx="ekr.20040104185913.2862">class View(App.Management.Tabs, Base):
    """A view of an object, typically used for management purposes

    This class provides bits of management framework needed by propertysheets
    to be used as a view on an object.
    """
	@others
</t>
<t tx="ekr.20040104185913.2863">def manage_workspace(self, URL1, RESPONSE):
    '''Implement a "management" interface
    '''
    RESPONSE.redirect(URL1+'/manage')
</t>
<t tx="ekr.20040104185913.2864">def tpURL(self): return self.getId()
</t>
<t tx="ekr.20040104185913.2865">def manage_options(self):
    """Return a manage option data structure for me instance
    """
    try: r=self.REQUEST
    except: r=None
    if r is None:
        pre='../../'
    else:
        pre=r['URL']
        for i in (1,2,3):
            l=pre.rfind('/')
            if l &gt;= 0:
                pre=pre[:l]
        pre=pre+'/'

    r=[]
    for d in self.aq_parent.aq_parent.manage_options:
        path=d['action']
        option={'label': d['label'],
                  'action': pre+path,
                  'path': '../../'+path}
        help=d.get('help')
        if help is not None:
            option['help']=help
        r.append(option)
    return r
</t>
<t tx="ekr.20040104185913.2866">def tabs_path_info(self, script, path):
    l=path.rfind('/')
    if l &gt;= 0:
        path=path[:l]
        l=path.rfind('/')
        if l &gt;= 0: path=path[:l]
    return View.inheritedAttribute('tabs_path_info')(
        self, script, path)
</t>
<t tx="ekr.20040104185913.2867">def meta_type(self):
    try: return self.aq_parent.aq_parent.meta_type
    except: return ''
</t>
<t tx="ekr.20040104185913.2868">class PropertySheet(Traversable, Persistent, Implicit):
    """A PropertySheet is a container for a set of related properties and
       metadata describing those properties. PropertySheets may or may not
       provide a web interface for managing its properties."""
	&lt;&lt; class PropertySheet declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2869">_properties=()
_extensible=1
icon='p_/Properties_icon'

__ac_permissions__=(
    ('Manage properties', ('manage_addProperty',
                           'manage_editProperties',
                           'manage_delProperties',
                           'manage_changeProperties',
                           'manage_propertiesForm',
                           )),
    ('Access contents information',
     ('xml_namespace', 'hasProperty', 'getProperty', 'getPropertyType',
      'propertyIds', 'propertyValues','propertyItems', 'propertyInfo',
      'propertyMap', ''),
     ('Anonymous', 'Manager'),
     ),
    )

__reserved_ids= ('values','items')

</t>
<t tx="ekr.20040104185913.2870">def property_extensible_schema__(self):
    """Return a flag indicating whether new properties may be
    added or removed."""
    return self._extensible
</t>
<t tx="ekr.20040104185913.2871">def __init__(self, id, md=None):
    # Create a new property set, using the given id and namespace
    # string. The namespace string should be usable as an xml name-
    # space identifier.

    if id in self.__reserved_ids:
        raise ValueError(
              "'%s' is a reserved Id (forbidden Ids are: %s) " % (
              id, self.__reserved_ids
              ))

    self.id=id
    self._md=md or {}
</t>
<t tx="ekr.20040104185913.2872">def getId(self):
    return self.id
</t>
<t tx="ekr.20040104185913.2873">def xml_namespace(self):
    # Return a namespace string usable as an xml namespace
    # for this property set.
    return self._md.get('xmlns', '')
</t>
<t tx="ekr.20040104185913.2874">def v_self(self):
    return self
</t>
<t tx="ekr.20040104185913.2875">def p_self(self):
    return self.v_self()
</t>
<t tx="ekr.20040104185913.2876">def valid_property_id(self, id):
    if not id or id[:1]=='_' or (id[:3]=='aq_') \
       or (' ' in id) or escape(id) != id:
        return 0
    return 1
</t>
<t tx="ekr.20040104185913.2877">def hasProperty(self, id):
    # Return a true value if a property exists with the given id.
    for prop in self._propertyMap():
        if id==prop['id']:
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.2878">def getProperty(self, id, default=None):
    # Return the property with the given id, returning the optional
    # second argument or None if no such property is found.
    if self.hasProperty(id):
        return getattr(self.v_self(), id)
    return default
</t>
<t tx="ekr.20040104185913.2879">def getPropertyType(self, id):
    """Get the type of property 'id', returning None if no
       such property exists"""
    pself=self.p_self()
    for md in pself._properties:
        if md['id']==id:
            return md.get('type', 'string')
    return None
</t>
<t tx="ekr.20040104185913.2880">def _wrapperCheck(self, object):
    # Raise an error if an object is wrapped.
    if hasattr(object, 'aq_base'):
        raise ValueError, 'Invalid property value: wrapped object'
    return
</t>
<t tx="ekr.20040104185913.2881">def _setProperty(self, id, value, type='string', meta=None):
    # Set a new property with the given id, value and optional type.
    # Note that different property sets may support different typing
    # systems.
    self._wrapperCheck(value)
    if not self.valid_property_id(id):
        raise 'Bad Request', 'Invalid property id, %s.' % escape(id)

    if not self.property_extensible_schema__():
        raise 'Bad Request', (
            'Properties cannot be added to this property sheet')
    pself=self.p_self()
    self=self.v_self()
    if hasattr(aq_base(self),id):
        if not (id=='title' and not self.__dict__.has_key(id)):
            raise 'Bad Request', (
                'Invalid property id, &lt;em&gt;%s&lt;/em&gt;. It is in use.' %
                    escape(id))
    if meta is None: meta={}
    prop={'id':id, 'type':type, 'meta':meta}
    pself._properties=pself._properties+(prop,)
    if type in ('selection', 'multiple selection'):
        if not value:
            raise 'Bad Request', (
                'The value given for a new selection property '
                'must be a variable name&lt;p&gt;')
        prop['select_variable']=value
        if type=='selection': value=None
        else: value=[]
    setattr(self, id, value)
</t>
<t tx="ekr.20040104185913.2882">def _updateProperty(self, id, value, meta=None):
    # Update the value of an existing property. If value is a string,
    # an attempt will be made to convert the value to the type of the
    # existing property. If a mapping containing meta-data is passed,
    # it will used to _replace_ the properties meta data.
    self._wrapperCheck(value)
    if not self.hasProperty(id):
        raise 'Bad Request', 'The property %s does not exist.' % escape(id)
    propinfo=self.propertyInfo(id)
    if not 'w' in propinfo.get('mode', 'wd'):
        raise 'Bad Request', '%s cannot be changed.' % escape(id)
    if type(value)==type(''):
        proptype=propinfo.get('type', 'string')
        if type_converters.has_key(proptype):
            value=type_converters[proptype](value)
    if meta is not None:
        props=[]
        pself=self.p_self()
        for prop in pself._properties:
            if prop['id']==id: prop['meta']=meta
            props.append(prop)
        pself._properties=tuple(props)
    setattr(self.v_self(), id, value)
</t>
<t tx="ekr.20040104185913.2883">def _delProperty(self, id):
    # Delete the property with the given id. If a property with the
    # given id does not exist, a ValueError is raised.
    if not self.hasProperty(id):
        raise 'Bad Request', 'The property %s does not exist.' % escape(id)
    vself=self.v_self()
    if hasattr(vself, '_reserved_names'):
        nd=vself._reserved_names
    else: nd=()
    if (not 'd' in self.propertyInfo(id).get('mode', 'wd')) or (id in nd):
        raise 'Bad Request', '%s cannot be deleted.' % escape(id)
    delattr(vself, id)
    pself=self.p_self()
    pself._properties=tuple(filter(lambda i, n=id: i['id'] != n,
                                   pself._properties))
</t>
<t tx="ekr.20040104185913.2884">def propertyIds(self):
    # Return a list of property ids.
    return map(lambda i: i['id'], self._propertyMap())
</t>
<t tx="ekr.20040104185913.2885">def propertyValues(self):
    # Return a list of property values.
    return map(lambda i, s=self: s.getProperty(i['id']),
               self._propertyMap())
</t>
<t tx="ekr.20040104185913.2886">def propertyItems(self):
    # Return a list of (id, property) tuples.
    return map(lambda i, s=self: (i['id'], s.getProperty(i['id'])),
               self._propertyMap())
</t>
<t tx="ekr.20040104185913.2887">def propertyInfo(self, id):
    # Return a mapping containing property meta-data
    for p in self._propertyMap():
        if p['id']==id: return p
    raise ValueError, 'The property %s does not exist.' % escape(id)
</t>
<t tx="ekr.20040104185913.2888">def _propertyMap(self):
    # Return a tuple of mappings, giving meta-data for properties.
    # Some ZClass instances dont seem to have an _properties, so
    # we have to fake it...
    return self.p_self()._properties
</t>
<t tx="ekr.20040104185913.2889">def propertyMap(self):
    # Returns a secure copy of the property definitions.
    return tuple(map(lambda dict: dict.copy(), self._propertyMap()))
</t>
<t tx="ekr.20040104185913.2890">def _propdict(self):
    dict={}
    for p in self._propertyMap():
        dict[p['id']]=p
    return dict
</t>
<t tx="ekr.20040104185913.2891">propstat='&lt;d:propstat xmlns:n="%s"&gt;\n' \
         '  &lt;d:prop&gt;\n' \
         '%s\n' \
         '  &lt;/d:prop&gt;\n' \
         '  &lt;d:status&gt;HTTP/1.1 %s&lt;/d:status&gt;\n%s' \
         '&lt;/d:propstat&gt;\n'

propdesc='  &lt;d:responsedescription&gt;\n' \
         '  %s\n' \
         '  &lt;/d:responsedescription&gt;\n'

def dav__allprop(self, propstat=propstat ):
    # DAV helper method - return one or more propstat elements
    # indicating property names and values for all properties.
    result=[]
    for item in self._propertyMap():
        name, type=item['id'], item.get('type','string')
        value=self.getProperty(name)

        if type=='tokens':
            value=' '.join(str(value))
        elif type=='lines':
            value='\n'.join(str(value))
        # check for xml property
        attrs=item.get('meta', {}).get('__xml_attrs__', None)
        if attrs is not None:
            attrs=map(lambda n: ' %s="%s"' % n, attrs.items())
            attrs=''.join(attrs)
        else:
            # Quote non-xml items here?
            attrs=''

        if hasattr(self,"dav__"+name):
            prop='  &lt;n:%s%s&gt;%s&lt;/n:%s&gt;' % (name, attrs, value, name)
        else:
            prop='  &lt;n:%s%s&gt;%s&lt;/n:%s&gt;' % (name, attrs, xml_escape(value), name)

        result.append(prop)
    if not result: return ''
    result='\n'.join(result)

    return propstat % (self.xml_namespace(), result, '200 OK', '')
</t>
<t tx="ekr.20040104185913.2892">def dav__propnames(self, propstat=propstat):
    # DAV helper method - return a propstat element indicating
    # property names for all properties in this PropertySheet.
    result=[]
    for name in self.propertyIds():
        result.append('  &lt;n:%s/&gt;' % name)
    if not result: return ''
    result='\n'.join(result)
    return propstat % (self.xml_namespace(), result, '200 OK', '')
</t>
<t tx="ekr.20040104185913.2893">def dav__propstat(self, name, result,
                  propstat=propstat, propdesc=propdesc):
    # DAV helper method - return a propstat element indicating
    # property name and value for the requested property.
    xml_id=self.xml_namespace()
    propdict=self._propdict()
    if not propdict.has_key(name):
        prop='&lt;n:%s xmlns:n="%s"/&gt;\n' % (name, xml_id)
        code='404 Not Found'
        if not result.has_key(code):
            result[code]=[prop]
        else: result[code].append(prop)
        return
    else:
        item=propdict[name]
        name, type=item['id'], item.get('type','string')
        value=self.getProperty(name)
        if type=='tokens':
            value=' '.join(str(value))
        elif type=='lines':
            value='\n'.join(str(value))
        # allow for xml properties
        attrs=item.get('meta', {}).get('__xml_attrs__', None)
        if attrs is not None:
            attrs=map(lambda n: ' %s="%s"' % n, attrs.items())
            attrs=''.join(attrs)
        else:
            # quote non-xml items here?
            attrs=''
        prop='&lt;n:%s%s xmlns:n="%s"&gt;%s&lt;/n:%s&gt;\n' % (
             name, attrs, xml_id, value, name)
        code='200 OK'
        if not result.has_key(code):
            result[code]=[prop]
        else: result[code].append(prop)
        return
</t>
<t tx="ekr.20040104185913.2894">del propstat
del propdesc


# Web interface

manage=DTMLFile('dtml/properties', globals())
def manage_propertiesForm(self, URL1):
    " "
    raise 'Redirect', URL1+'/manage'
</t>
<t tx="ekr.20040104185913.2895">def manage_addProperty(self, id, value, type, REQUEST=None):
    """Add a new property via the web. Sets a new property with
    the given id, type, and value."""
    if type_converters.has_key(type):
        value=type_converters[type](value)
    self._setProperty(id, value, type)
    if REQUEST is not None:
        return self.manage(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2896">def manage_editProperties(self, REQUEST):
    """Edit object properties via the web."""
    for prop in self._propertyMap():
        name=prop['id']
        if 'w' in prop.get('mode', 'wd'):
            value=REQUEST.get(name, '')
            self._updateProperty(name, value)
    return MessageDialog(
           title  ='Success!',
           message='Your changes have been saved',
           action ='manage')
</t>
<t tx="ekr.20040104185913.2897">def manage_changeProperties(self, REQUEST=None, **kw):
    """Change existing object properties by passing either a mapping
       object of name:value pairs {'foo':6} or passing name=value
       parameters."""
    if REQUEST is None:
        props={}
    else: props=REQUEST
    if kw:
        for name, value in kw.items():
            props[name]=value
    propdict=self._propdict()
    for name, value in props.items():
        if self.hasProperty(name):
            if not 'w' in propdict[name].get('mode', 'wd'):
                raise 'BadRequest', '%s cannot be changed' % escape(name)
            self._updateProperty(name, value)
    if REQUEST is not None:
        return MessageDialog(
            title  ='Success!',
            message='Your changes have been saved.',
            action ='manage')
</t>
<t tx="ekr.20040104185913.2898">def manage_delProperties(self, ids=None, REQUEST=None):
    """Delete one or more properties specified by 'ids'."""
    if REQUEST:
        # Bugfix for properties named "ids" (casey)
        if ids == self.getProperty('ids', None): ids = None
        ids = REQUEST.get('_ids', ids)
    if ids is None:
        return MessageDialog(
               title='No property specified',
               message='No properties were specified!',
               action ='./manage',)
    for id in ids:
        self._delProperty(id)
    if REQUEST is not None:
        return self.manage(self, REQUEST)
</t>
<t tx="ekr.20040104185913.2899">Globals.default__class_init__(PropertySheet)


class Virtual:
    """A virtual propertysheet stores it's properties in it's instance."""
	@others
</t>
<t tx="ekr.20040104185913.2900">def __init__(self):
    pass
</t>
<t tx="ekr.20040104185913.2901">def v_self(self):
    return self.aq_parent.aq_parent
</t>
<t tx="ekr.20040104185913.2902">class DefaultProperties(Virtual, PropertySheet, View):
    """The default property set mimics the behavior of old-style Zope
       properties -- it stores its property values in the instance of
       its owner."""
	&lt;&lt; class DefaultProperties declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.2903">id='default'
_md={'xmlns': 'http://www.zope.org/propsets/default'}

</t>
<t tx="ekr.20040104185913.2904">Globals.default__class_init__(DefaultProperties)


class DAVProperties(Virtual, PropertySheet, View):
    """WebDAV properties"""
	&lt;&lt; class DAVProperties declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2905">id='webdav'
_md={'xmlns': 'DAV:'}
pm=({'id':'creationdate',     'mode':'r'},
    {'id':'displayname',      'mode':'r'},
    {'id':'resourcetype',     'mode':'r'},
    {'id':'getcontenttype',   'mode':'r'},
    {'id':'getcontentlength', 'mode':'r'},
    {'id':'source',           'mode':'r'},
    {'id':'supportedlock',    'mode':'r'},
    {'id':'lockdiscovery',    'mode':'r'},
    )

</t>
<t tx="ekr.20040104185913.2906">def getProperty(self, id, default=None):
    method='dav__%s' % id
    if not hasattr(self, method):
        return default
    return getattr(self, method)()
</t>
<t tx="ekr.20040104185913.2907">def _setProperty(self, id, value, type='string', meta=None):
    raise ValueError, '%s cannot be set.' % escape(id)
</t>
<t tx="ekr.20040104185913.2908">def _updateProperty(self, id, value):
    raise ValueError, '%s cannot be updated.' % escape(id)
</t>
<t tx="ekr.20040104185913.2909">def _delProperty(self, id):
    raise ValueError, '%s cannot be deleted.' % escape(id)
</t>
<t tx="ekr.20040104185913.2910">def _propertyMap(self):
    # Only use getlastmodified if returns a value
    if hasattr(self.v_self(), '_p_mtime'):
        return self.pm + ({'id':'getlastmodified',  'mode':'r'},)
    return self.pm
</t>
<t tx="ekr.20040104185913.2911">def propertyMap(self):
    return map(lambda dict: dict.copy(), self._propertyMap())
</t>
<t tx="ekr.20040104185913.2912">def dav__creationdate(self):
    return iso8601_date(43200.0)
</t>
<t tx="ekr.20040104185913.2913">def dav__displayname(self):
    return absattr(self.v_self().id)
</t>
<t tx="ekr.20040104185913.2914">def dav__resourcetype(self):
    vself=self.v_self()
    if (isDavCollection(vself) or
        getattr(aq_base(vself), 'isAnObjectManager', None)):
        return '&lt;n:collection/&gt;'
    return ''
</t>
<t tx="ekr.20040104185913.2915">def dav__getlastmodified(self):
    return rfc1123_date(self.v_self()._p_mtime)
</t>
<t tx="ekr.20040104185913.2916">def dav__getcontenttype(self):
    vself=self.v_self()
    if hasattr(vself, 'content_type'):
        return absattr(vself.content_type)
    if hasattr(vself, 'default_content_type'):
        return absattr(vself.default_content_type)
    return ''
</t>
<t tx="ekr.20040104185913.2917">def dav__getcontentlength(self):
    vself=self.v_self()
    if hasattr(vself, 'get_size'):
        return vself.get_size()
    return ''
</t>
<t tx="ekr.20040104185913.2918">def dav__source(self):
    vself=self.v_self()
    if hasattr(vself, 'document_src'):
        url=urlbase(vself.absolute_url())
        return '\n  &lt;n:link&gt;\n' \
               '  &lt;n:src&gt;%s&lt;/n:src&gt;\n' \
               '  &lt;n:dst&gt;%s/document_src&lt;/n:dst&gt;\n' \
               '  &lt;/n:link&gt;\n  ' % (url, url)
    return ''
</t>
<t tx="ekr.20040104185913.2919">def dav__supportedlock(self):
    return '\n  &lt;n:lockentry&gt;\n' \
           '  &lt;d:lockscope&gt;&lt;d:exclusive/&gt;&lt;/d:lockscope&gt;\n' \
           '  &lt;d:locktype&gt;&lt;d:write/&gt;&lt;/d:locktype&gt;\n' \
           '  &lt;/n:lockentry&gt;\n  '
</t>
<t tx="ekr.20040104185913.2920">def dav__lockdiscovery(self):
    security = getSecurityManager()
    user = security.getUser().getId()


    vself = self.v_self()
    out = '\n'
    if WriteLockInterface.isImplementedBy(vself):
        locks = vself.wl_lockValues(killinvalids=1)
        for lock in locks:

            creator = lock.getCreator()[-1]
            if creator == user: fake=0
            else:               fake=1

            out = '%s\n%s' % (out, lock.asLockDiscoveryProperty('n',fake=fake))

        out = '%s\n' % out

    return out
</t>
<t tx="ekr.20040104185913.2921">Globals.default__class_init__(DAVProperties)


class PropertySheets(Traversable, Implicit, App.Management.Tabs):
    """A tricky container to keep property sets from polluting
       an object's direct attribute namespace."""
	&lt;&lt; class PropertySheets declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2922">id='propertysheets'

__ac_permissions__=(
    ('Manage properties', ('manage_addPropertySheet',
                           'addPropertySheet',
                           'delPropertySheet'
                           )),
    ('Access contents information',
     ('items', 'values', 'get', ''),
     ('Anonymous', 'Manager'),
     ),
    ('View management screens', ('manage',)),
    )


webdav =DAVProperties()
</t>
<t tx="ekr.20040104185913.2923">def _get_defaults(self):
    return (self.webdav,)
</t>
<t tx="ekr.20040104185913.2924">def __propsets__(self):
    propsets=self.aq_parent.__propsets__
    __traceback_info__= propsets, type(propsets)
    return self._get_defaults() + propsets
</t>
<t tx="ekr.20040104185913.2925">def __bobo_traverse__(self, REQUEST, name=None):
    for propset in self.__propsets__():
        if propset.getId()==name:
            return propset.__of__(self)
    return getattr(self, name)
</t>
<t tx="ekr.20040104185913.2926">def __getitem__(self, n):
    return self.__propsets__()[n].__of__(self)
</t>
<t tx="ekr.20040104185913.2927">def values(self):
    propsets=self.__propsets__()
    return map(lambda n, s=self: n.__of__(s), propsets)
</t>
<t tx="ekr.20040104185913.2928">def items(self):
    propsets=self.__propsets__()
    r=[]
    for n in propsets:
        if hasattr(n,'id'): id=n.id
        else: id=''
        r.append((id, n.__of__(self)))

    return r
</t>
<t tx="ekr.20040104185913.2929">def get(self, name, default=None):
    for propset in self.__propsets__():
        if propset.id==name or (hasattr(propset, 'xml_namespace') and \
                                propset.xml_namespace()==name):
            return propset.__of__(self)
    return default
</t>
<t tx="ekr.20040104185913.2930">def manage_addPropertySheet(self, id, ns):
    """ """
    md={'xmlns':ns}
    ps=PropertySheet(id, md)
    self.addPropertySheet(ps)
    return 'OK'
</t>
<t tx="ekr.20040104185913.2931">def addPropertySheet(self, propset):
    propsets=self.aq_parent.__propsets__
    propsets=propsets+(propset,)
    self.aq_parent.__propsets__=propsets
</t>
<t tx="ekr.20040104185913.2932">def delPropertySheet(self, name):
    result=[]
    for propset in self.aq_parent.__propsets__:
        if propset.getId() != name and  propset.xml_namespace() != name:
            result.append(propset)
    self.aq_parent.__propsets__=tuple(result)
</t>
<t tx="ekr.20040104185913.2933">def __len__(self):
    return len(self.__propsets__())
</t>
<t tx="ekr.20040104185913.2934">def getId(self):
    return self.id
</t>
<t tx="ekr.20040104185913.2935"># Management interface:

manage=Globals.DTMLFile('dtml/propertysheets', globals())

def manage_options(self):
    """Return a manage option data structure for me instance
    """
    try: r=self.REQUEST
    except: r=None
    if r is None:
        pre='../'
    else:
        pre=r['URL']
        for i in (1,2):
            l=pre.rfind('/')
            if l &gt;= 0:
                pre=pre[:l]
        pre=pre+'/'

    r=[]
    for d in self.aq_parent.manage_options:
        r.append({'label': d['label'], 'action': pre+d['action']})
    return r
</t>
<t tx="ekr.20040104185913.2936">def tabs_path_info(self, script, path):
    l=path.rfind('/')
    if l &gt;= 0: path=path[:l]
    return PropertySheets.inheritedAttribute('tabs_path_info')(
        self, script, path)
</t>
<t tx="ekr.20040104185913.2937">Globals.default__class_init__(PropertySheets)


class DefaultPropertySheets(PropertySheets):
    """A PropertySheets container that contains a default property
       sheet for compatibility with the arbitrary property mgmt
       design of Zope PropertyManagers."""
	&lt;&lt; class DefaultPropertySheets declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2938">default=DefaultProperties()
webdav =DAVProperties()
</t>
<t tx="ekr.20040104185913.2939">def _get_defaults(self):
    return (self.default, self.webdav)
</t>
<t tx="ekr.20040104185913.2940">Globals.default__class_init__(DefaultPropertySheets)


class FixedSchema(PropertySheet):
    """A Fixed-schema property sheet has no control over it's schema

    It gets its schema from another proprtysheet but has control over
    its value storage.

    This mix-in is used for ZClass instance proprtysheets, which store
    their data in instances, but get their schema from the
    proprtysheet managed in the ZClass.
    """
	@others
</t>
<t tx="ekr.20040104185913.2941">def __init__(self, id, base, md=None):
    FixedSchema.inheritedAttribute('__init__')(self, id, md)
    self._base=base
</t>
<t tx="ekr.20040104185913.2942">def _propertyMap(self):
    # Return a tuple of mappings, giving meta-data for properties.
    r = []
    for d in self._base._propertyMap():
        d = d.copy()
        mode = d.get('mode', 'wd')
        if 'd' in mode:
            d['mode']=filter(lambda c: c != 'd', mode)
        r.append(d)

    return tuple(r)
</t>
<t tx="ekr.20040104185913.2943">def propertyMap(self):
    return self._propertyMap()
</t>
<t tx="ekr.20040104185913.2944">def property_extensible_schema__(self):
    return 0
    return self._base._extensible
</t>
<t tx="ekr.20040104185913.2945">Globals.default__class_init__(FixedSchema)



class vps(Base):
    """Virtual Propertysheets

    The vps object implements a "computed attribute" - it ensures
    that a PropertySheets instance is returned when the propertysheets
    attribute of a PropertyManager is accessed.
    """
	@others
</t>
<t tx="ekr.20040104185913.2946">def __init__(self, c=PropertySheets):
    self.c=c
</t>
<t tx="ekr.20040104185913.2947">def __of__(self, parent):
    return self.c().__of__(parent)
</t>
<t tx="ekr.20040104185913.2948">def absattr(attr):
    if callable(attr):
        return attr()
    return attr
</t>
<t tx="ekr.20040104185913.2949">def xml_escape(v):
    """ convert any content from ISO-8859-1 to UTF-8
    The main use is to escape non-US object property values
    (e.g. containing accented characters). Also we convert "&lt;" and "&gt;"
    to entities to keep the properties XML compliant.
    """
    v = str(v)
    v = v.replace('&amp;', '&amp;amp;')
    v = v.replace('&lt;', '&amp;lt;')
    v = v.replace('&gt;', '&amp;gt;')
    return  unicode(v,"latin-1").encode("utf-8")
</t>
<t tx="ekr.20040104185913.2950">&lt;&lt; SimpleItem declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2951">&lt;&lt; copyright &gt;&gt;
'''This module implements a simple item mix-in for objects that have a
very simple (e.g. one-screen) management interface, like documents,
Aqueduct database adapters, etc.

This module can also be used as a simple template for implementing new
item types.

$Id: SimpleItem.py,v 1.105 2002/08/30 20:21:29 caseman Exp $'''
__version__='$Revision: 1.105 $'[11:-2]

import re, sys, Globals, App.Management, Acquisition, App.Undo
import AccessControl.Role, AccessControl.Owned, App.Common
from webdav.Resource import Resource
from ExtensionClass import Base
from CopySupport import CopySource
from types import InstanceType, StringType
from ComputedAttribute import ComputedAttribute
from AccessControl import getSecurityManager
from Traversable import Traversable
from Acquisition import aq_base, aq_parent, aq_inner, aq_acquire
from DocumentTemplate.ustr import ustr
from zExceptions.ExceptionFormatter import format_exception
import time
from zLOG import LOG, BLATHER

import marshal
import ZDOM

HTML=Globals.HTML
StringType=type('')

</t>
<t tx="ekr.20040104185913.2952">class Item(Base, Resource, CopySource, App.Management.Tabs, Traversable,
	&lt;&lt; class Item declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2953">ZDOM.Element,
AccessControl.Owned.Owned,
App.Undo.UndoSupport,
):
"""A common base class for simple, non-container objects."""
isPrincipiaFolderish=0
isTopLevelPrincipiaApplicationObject=0

</t>
<t tx="ekr.20040104185913.2954">def manage_afterAdd(self, item, container): pass
</t>
<t tx="ekr.20040104185913.2955">def manage_beforeDelete(self, item, container): pass
</t>
<t tx="ekr.20040104185913.2956">def manage_afterClone(self, item): pass
</t>
<t tx="ekr.20040104185913.2957"># Direct use of the 'id' attribute is deprecated - use getId()
id=''

getId__roles__=None
def getId(self):
    """Return the id of the object as a string. This method
       should be used in preference to accessing an id attribute
       of an object directly. The getId method is public."""
    name=getattr(self, 'id', None)
    if callable(name):
        return name()
    if name is not None:
        return name
    if hasattr(self, '__name__'):
        return self.__name__
    raise AttributeError, 'This object has no id'
</t>
<t tx="ekr.20040104185913.2958"># Alias id to __name__, which will make tracebacks a good bit nicer:
__name__=ComputedAttribute(lambda self: self.getId())

# Name, relative to SOFTWARE_URL of icon used to display item
# in folder listings.
icon=''

# Meta type used for selecting all objects of a given type.
meta_type='simple item'

# Default title.
title=''

# Default propertysheet info:
__propsets__=()

manage_options=(
    App.Undo.UndoSupport.manage_options
    +AccessControl.Owned.Owned.manage_options
    )

# Attributes that must be acquired
REQUEST=Acquisition.Acquired

# Allow (reluctantly) access to unprotected attributes
__allow_access_to_unprotected_subobjects__=1


def title_or_id(self):
    """
    Utility that returns the title if it is not blank and the id
    otherwise.
    """
    title=self.title
    if callable(title):
        title=title()
    if title: return title
    return self.getId()
</t>
<t tx="ekr.20040104185913.2959">def title_and_id(self):
    """
    Utility that returns the title if it is not blank and the id
    otherwise.  If the title is not blank, then the id is included
    in parens.
    """
    title=self.title
    if callable(title):
        title=title()
    id = self.getId()
    return title and ("%s (%s)" % (title,id)) or id
</t>
<t tx="ekr.20040104185913.2960">def this(self):
    # Handy way to talk to ourselves in document templates.
    return self
</t>
<t tx="ekr.20040104185913.2961">def tpURL(self):
    # My URL as used by tree tag
    return self.getId()
</t>
<t tx="ekr.20040104185913.2962">def tpValues(self):
    # My sub-objects as used by the tree tag
    return ()
</t>
<t tx="ekr.20040104185913.2963">_manage_editedDialog=Globals.DTMLFile('dtml/editedDialog', globals())
def manage_editedDialog(self, REQUEST, **args):
    return apply(self._manage_editedDialog,(self, REQUEST), args)
</t>
<t tx="ekr.20040104185913.2964">def raise_standardErrorMessage(
    self, client=None, REQUEST={},
    error_type=None, error_value=None, tb=None,
    error_tb=None, error_message='',
    tagSearch=re.compile(r'[a-zA-Z]&gt;').search,
    error_log_url=''):

    try:
        if error_type  is None: error_type =sys.exc_info()[0]
        if error_value is None: error_value=sys.exc_info()[1]

        # allow for a few different traceback options
        if tb is None and error_tb is None:
            tb=sys.exc_info()[2]
        if type(tb) is not type('') and (error_tb is None):
            error_tb = pretty_tb(error_type, error_value, tb)
        elif type(tb) is type('') and not error_tb:
            error_tb = tb

        # turn error_type into a string
        if hasattr(error_type, '__name__'):
            error_type=error_type.__name__

        if hasattr(self, '_v_eek'):
            # Stop if there is recursion.
            raise error_type, error_value, tb
        self._v_eek=1

        if str(error_type).lower() in ('redirect',):
            raise error_type, error_value, tb

        if not error_message:
            try:
                s = ustr(error_value)
            except:
                s = error_value
            try:
                match = tagSearch(s)
            except TypeError:
                match = None
            if match is not None:
                error_message=error_value

        if client is None: client=self
        if not REQUEST: REQUEST=self.aq_acquire('REQUEST')

        try:
            if hasattr(client, 'standard_error_message'):
                s=getattr(client, 'standard_error_message')
            else:
                client = client.aq_parent
                s=getattr(client, 'standard_error_message')
            kwargs = {'error_type': error_type,
                      'error_value': error_value,
                      'error_tb': error_tb,
                      'error_traceback': error_tb,
                      'error_message': error_message,
                      'error_log_url': error_log_url}

            if isinstance(s, HTML):
                v = s(client, REQUEST, **kwargs)
            elif callable(s):
                v = s(**kwargs)
            else:
                v = HTML.__call__(s, client, REQUEST, **kwargs)
        except:
            LOG('OFS', BLATHER,
                'Exception while rendering an error message',
                error=sys.exc_info())
            try:
                strv = str(error_value)
            except:
                strv = ('&lt;unprintable %s object&gt;' % 
                        str(type(error_value).__name__))
            v = strv + (
                " (Also, an error occurred while attempting "
                "to render the standard error message.)")
        raise error_type, v, tb
    finally:
        if hasattr(self, '_v_eek'): del self._v_eek
        tb=None
</t>
<t tx="ekr.20040104185913.2965">def manage(self, URL1):
    " "
    raise 'Redirect', "%s/manage_main" % URL1
</t>
<t tx="ekr.20040104185913.2966"># This keeps simple items from acquiring their parents
# objectValues, etc., when used in simple tree tags.
def objectValues(self, spec=None):
    return ()
</t>
<t tx="ekr.20040104185913.2967">objectIds=objectItems=objectValues

# FTP support methods

def manage_FTPstat(self,REQUEST):
    "psuedo stat, used by FTP for directory listings"
    from AccessControl.User import nobody
    mode=0100000

    # check read permissions
    if (hasattr(aq_base(self),'manage_FTPget') and
        hasattr(self.manage_FTPget, '__roles__')):
        try:
            if getSecurityManager().validateValue(self.manage_FTPget):
                mode=mode | 0440
        except: pass
        if nobody.allowed(self.manage_FTPget,
                          self.manage_FTPget.__roles__):
            mode=mode | 0004

    # check write permissions
    if hasattr(aq_base(self),'PUT') and hasattr(self.PUT, '__roles__'):
        try:
            if getSecurityManager().validateValue(self.PUT):
                mode=mode | 0220
        except: pass

        if nobody.allowed(self.PUT, self.PUT.__roles__):
            mode=mode | 0002

    # get size
    if hasattr(aq_base(self), 'get_size'):
        size=self.get_size()
    elif hasattr(aq_base(self),'manage_FTPget'):
        size=len(self.manage_FTPget())
    else:
        size=0
    # get modification time
    if hasattr(aq_base(self), 'bobobase_modification_time'):
        mtime=self.bobobase_modification_time().timeTime()
    else:
        mtime=time.time()
    # get owner and group
    owner=group='Zope'
    if hasattr(aq_base(self), 'get_local_roles'):
        for user, roles in self.get_local_roles():
            if 'Owner' in roles:
                owner=user
                break
    return marshal.dumps((mode,0,0,1,owner,group,size,mtime,mtime,mtime))
</t>
<t tx="ekr.20040104185913.2968">def manage_FTPlist(self,REQUEST):
    """Directory listing for FTP. In the case of non-Foldoid objects,
    the listing should contain one object, the object itself."""
    # check to see if we are being acquiring or not
    ob=self
    while 1:
        if App.Common.is_acquired(ob):
            raise ValueError('FTP List not supported on acquired objects')
        if not hasattr(ob,'aq_parent'):
            break
        ob=ob.aq_parent

    stat=marshal.loads(self.manage_FTPstat(REQUEST))
    id = self.getId()
    return marshal.dumps((id,stat))
</t>
<t tx="ekr.20040104185913.2969">def __len__(self):
    return 1
</t>
<t tx="ekr.20040104185913.2970">Globals.default__class_init__(Item)

class Item_w__name__(Item):
    """Mixin class to support common name/id functions"""
	@others
</t>
<t tx="ekr.20040104185913.2971">def title_or_id(self):
    """Utility that returns the title if it is not blank and the id
    otherwise."""
    return self.title or self.__name__
</t>
<t tx="ekr.20040104185913.2972">def title_and_id(self):
    """Utility that returns the title if it is not blank and the id
    otherwise.  If the title is not blank, then the id is included
    in parens."""
    t=self.title
    return t and ("%s (%s)" % (t,self.__name__)) or self.__name__
</t>
<t tx="ekr.20040104185913.2973">def _setId(self, id):
    self.__name__=id
</t>
<t tx="ekr.20040104185913.2974">def getPhysicalPath(self):
    '''Returns a path (an immutable sequence of strings)
    that can be used to access this object again
    later, for example in a copy/paste operation.  getPhysicalRoot()
    and getPhysicalPath() are designed to operate together.
    '''
    path = (self.__name__,)

    p = aq_parent(aq_inner(self))
    if p is not None:
        path = p.getPhysicalPath() + path

    return path
</t>
<t tx="ekr.20040104185913.2975">def pretty_tb(t, v, tb, as_html=1):
    tb = format_exception(t, v, tb, as_html=as_html)
    tb = '\n'.join(tb)
    return tb
</t>
<t tx="ekr.20040104185913.2976">class SimpleItem(Item, Globals.Persistent,
	&lt;&lt; class SimpleItem declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2977">Acquisition.Implicit,
AccessControl.Role.RoleManager,
):
# Blue-plate special, Zope Masala
"""Mix-in class combining the most common set of basic mix-ins
"""

manage_options=Item.manage_options+(
{'label':'Security',
'action':'manage_access',
'help':('OFSP', 'Security.stx')},
)

__ac_permissions__=(('View', ()),)

</t>
<t tx="ekr.20040104185913.2978">def __repr__(self):
    """Show the physical path of the object and its context if available.
    """
    try:
        path = '/'.join(self.getPhysicalPath())
    except:
        path = None
    context_path = None
    context = aq_parent(self)
    container = aq_parent(aq_inner(self))
    if aq_base(context) is not aq_base(container):
        try:
            context_path = '/'.join(context.getPhysicalPath())
        except:
            context_path = None
    res = '&lt;%s' % self.__class__.__name__
    if path:
        res += ' at %s' % path
    else:
        res += ' at 0x%x' % id(self)
    if context_path:
        res += ' used for %s' % context_path
    res += '&gt;'
    return res
</t>
<t tx="ekr.20040104185913.2979">&lt;&lt; Traversable declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2980">&lt;&lt; copyright &gt;&gt;
'''This module implements a mix-in for traversable objects.

$Id: Traversable.py,v 1.15.6.4 2003/02/26 16:48:59 caseman Exp $'''
__version__='$Revision: 1.15.6.4 $'[11:-2]


from Acquisition import Acquired, aq_inner, aq_parent, aq_base
from AccessControl import getSecurityManager
from AccessControl import Unauthorized
from AccessControl.ZopeGuards import guarded_getattr
from urllib import quote

_marker=[]
StringType=type('')

</t>
<t tx="ekr.20040104185913.2981">class Traversable:
	&lt;&lt; class Traversable declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.2982">absolute_url__roles__=None # Public
</t>
<t tx="ekr.20040104185913.2983">def absolute_url(self, relative=0):
    try:
        req = self.REQUEST
    except AttributeError:
        req = {}
    rpp = req.get('VirtualRootPhysicalPath', ('',))
    spp = self.getPhysicalPath()
    i = 0
    for name in rpp[:len(spp)]:
        if spp[i] == name:
            i = i + 1
        else:
            break
    path = map(quote, spp[i:])
    if relative:
        # This is useful for physical path relative to a VirtualRoot
        return '/'.join(path)
    return '/'.join([req['SERVER_URL']] + req._script + path)
</t>
<t tx="ekr.20040104185913.2984">getPhysicalRoot__roles__=() # Private
getPhysicalRoot=Acquired

getPhysicalPath__roles__=None # Public
def getPhysicalPath(self):
    '''Returns a path (an immutable sequence of strings)
    that can be used to access this object again
    later, for example in a copy/paste operation.  getPhysicalRoot()
    and getPhysicalPath() are designed to operate together.
    '''
    path = (self.getId(),)

    p = aq_parent(aq_inner(self))
    if p is not None:
        path = p.getPhysicalPath() + path

    return path
</t>
<t tx="ekr.20040104185913.2985">unrestrictedTraverse__roles__=() # Private
def unrestrictedTraverse(self, path, default=_marker, restricted=0):

    if not path: return self

    get=getattr
    has=hasattr
    N=None
    M=_marker

    if type(path) is StringType: path = path.split('/')
    else: path=list(path)

    REQUEST={'TraversalRequestNameStack': path}
    path.reverse()
    pop=path.pop

    if len(path) &gt; 1 and not path[0]:
        # Remove trailing slash
        path.pop(0)

    if restricted: securityManager=getSecurityManager()
    else: securityManager=N

    if not path[-1]:
        # If the path starts with an empty string, go to the root first.
        pop()
        self=self.getPhysicalRoot()
        if (restricted and not securityManager.validateValue(self)):
            raise Unauthorized, name

    try:
        object = self
        while path:
            name=pop()
            __traceback_info__ = path, name

            if name[0] == '_':
                # Never allowed in a URL.
                raise 'NotFound', name

            if name=='..':
                o=getattr(object, 'aq_parent', M)
                if o is not M:
                    if (restricted and not securityManager.validate(
                        object, object,name, o)):
                        raise Unauthorized, name
                    object=o
                    continue

            t=get(object, '__bobo_traverse__', N)
            if t is not N:
                o=t(REQUEST, name)

                if restricted:
                    container = N
                    if aq_base(o) is not o:
                        # The object is wrapped, so the acquisition
                        # context determines the container.
                        container = aq_parent(aq_inner(o))
                    elif has(o, 'im_self'):
                        container = o.im_self
                    elif (has(get(object, 'aq_base', object), name)
                          and get(object, name) == o):
                        container = object
                    if (not securityManager.validate(object,
                                                     container, name, o)):
                        raise Unauthorized, name

            else:
                if restricted:
                    try:
                        o = guarded_getattr(object, name, M)
                    except AttributeError:
                        # XXX guarded_getattr in Zope 2.5 and 2.6
                        # raises AttributeError if the user is not
                        # allowed to access an acquired attribute,
                        # even if a default is passed to guarded_getattr.
                        # Re-raising Unauthorized here only cures the
                        # symptom.  In Zope 2.7, guarded_getattr behaves
                        # correctly but the change may have broad effects.
                        raise Unauthorized, name
                else:
                    o = get(object, name, M)
                if o is M:
                    try:
                        o=object[name]
                    except AttributeError:
                        # Raise a NotFound for easier debugging
                        raise 'NotFound', name
                    if (restricted and not securityManager.validate(
                        object, object, N, o)):
                        raise Unauthorized, name

            object=o

        return object

    except:
        if default==_marker: raise
        return default
</t>
<t tx="ekr.20040104185913.2986">restrictedTraverse__roles__=None # Public
def restrictedTraverse(self, path, default=_marker):
    return self.unrestrictedTraverse(path, default, restricted=1)
</t>
<t tx="ekr.20040104185913.2987">&lt;&lt; Uninstalled declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2988">&lt;&lt; copyright &gt;&gt;
"""
Objects for packages that have been uninstalled.
"""
import  SimpleItem, Globals, Acquisition
from Acquisition import Acquired
import Persistence
from thread import allocate_lock
from zLOG import LOG, WARNING
from cgi import escape

broken_klasses={}
broken_klasses_lock = allocate_lock()

</t>
<t tx="ekr.20040104185913.2989">class BrokenClass(Acquisition.Explicit, SimpleItem.Item,
	&lt;&lt; class BrokenClass declarations &gt;&gt;
	@others

    manage=manage_main=Globals.DTMLFile('dtml/brokenEdit',globals())
    manage_workspace=manage</t>
<t tx="ekr.20040104185913.2990">Persistence.Overridable):
_p_changed=0
meta_type='Broken Because Product is Gone'
icon='p_/broken'
product_name='unknown'
id='broken'

manage_page_header = Acquired
manage_page_footer = Acquired

</t>
<t tx="ekr.20040104185913.2991">def __getstate__(self):
    raise SystemError, (
        """This object was originally created by a product that
        is no longer installed.  It cannot be updated.
        """)
</t>
<t tx="ekr.20040104185913.2992">def __getattr__(self, name):
    if name[:3]=='_p_':
        return BrokenClass.inheritedAttribute('__getattr__')(self, name)
    raise AttributeError, escape(name)
</t>
<t tx="ekr.20040104185913.2993">def Broken(self, oid, pair):
    broken_klasses_lock.acquire()
    try:
        if broken_klasses.has_key(pair):
            klass = broken_klasses[pair]
        else:
            module, klassname = pair
            d={'BrokenClass': BrokenClass}
            exec ("class %s(BrokenClass): ' '; __module__=%s"
                  % (klassname, `module`)) in d
            klass = broken_klasses[pair] = d[klassname]
            module=module.split('.')
            if len(module) &gt; 2 and module[0]=='Products':
                klass.product_name= module[1]
            klass.title=(
                'This object from the %s product '
                'is broken!' %
                klass.product_name)
            klass.info=(
                'This object\'s class was %s in module %s.' %
                (klass.__name__, klass.__module__))
            LOG('ZODB', WARNING, 'Could not import class %s '
                'from module %s' % (`klass.__name__`, `klass.__module__`))
    finally:
        broken_klasses_lock.release()
    if oid is None: return klass
    i=klass()
    i._p_oid=oid
    i._p_jar=self
    return i
</t>
<t tx="ekr.20040104185913.2994">&lt;&lt; XMLExportImport declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.2995">&lt;&lt; copyright &gt;&gt;
import Shared.DC.xml.ppml
ppml=Shared.DC.xml.ppml
from base64 import encodestring
from cStringIO import StringIO
from ZODB.referencesf import referencesf
from ZODB.ExportImport import TemporaryFile, export_end_marker

StringType=type('')

magic='&lt;?xm' # importXML(jar, file, clue)}

</t>
<t tx="ekr.20040104185913.2996">def XMLrecord(oid, len, p):
    q=ppml.ToXMLUnpickler
    f=StringIO(p)
    u=q(f)
    id=ppml.u64(oid)
    aka=encodestring(oid)[:-1]
    u.idprefix=str(id)+'.'
    p=u.load().__str__(4)
    if f.tell() &lt; len:
        p=p+u.load().__str__(4)
    String='  &lt;record id="%s" aka="%s"&gt;\n%s  &lt;/record&gt;\n' % (id, aka, p)
    return String
</t>
<t tx="ekr.20040104185913.2997">def exportXML(jar, oid, file=None):

    if file is None: file=TemporaryFile()
    elif type(file) is StringType: file=open(file,'w+b')
    write=file.write
    write('&lt;?xml version="1.0"?&gt;\012&lt;ZopeData&gt;\012')
    version=jar._version
    ref=referencesf
    oids=[oid]
    done_oids={}
    done=done_oids.has_key
    load=jar._storage.load
    while oids:
        oid=oids[0]
        del oids[0]
        if done(oid): continue
        done_oids[oid]=1
        try: p, serial = load(oid, version)
        except: pass # Ick, a broken reference
        else:
            ref(p, oids)
            write(XMLrecord(oid,len(p),p))
    write('&lt;/ZopeData&gt;\n')
    return file
</t>
<t tx="ekr.20040104185913.2998">class zopedata:
	@others
</t>
<t tx="ekr.20040104185913.2999">def __init__(self, parser, tag, attrs):
    self.file=parser.file
    write=self.file.write
    write('ZEXP')
</t>
<t tx="ekr.20040104185913.3000">def append(self, data):
    file=self.file
    write=file.write
    pos=file.tell()
    file.seek(pos)
    write(data)
</t>
<t tx="ekr.20040104185913.3001">def start_zopedata(parser, tag, data):
    return zopedata(parser, tag, data)
</t>
<t tx="ekr.20040104185913.3002">def save_zopedata(parser, tag, data):
    file=parser.file
    write=file.write
    pos=file.tell()
    file.seek(pos)
    write(export_end_marker)
</t>
<t tx="ekr.20040104185913.3003">def save_record(parser, tag, data):
    file=parser.file
    write=file.write
    pos=file.tell()
    file.seek(pos)
    a=data[1]
    if a.has_key('id'): oid=a['id']
    oid=ppml.p64(int(oid))
    v=''
    for x in data[2:]:
        v=v+x
    l=ppml.p64(len(v))
    v=oid+l+v
    return v
</t>
<t tx="ekr.20040104185913.3004">def importXML(jar, file, clue=''):
    import Shared.DC.xml.pyexpat.pyexpat
    pyexpat=Shared.DC.xml.pyexpat.pyexpat
    if type(file) is StringType:
        file=open(file)
    outfile=TemporaryFile()
    data=file.read()
    F=ppml.xmlPickler()
    F.end_handlers['record'] = save_record
    F.end_handlers['ZopeData'] = save_zopedata
    F.start_handlers['ZopeData'] = start_zopedata
    F.binary=1
    F.file=outfile
    p=pyexpat.ParserCreate()
    p.CharacterDataHandler=F.handle_data
    p.StartElementHandler=F.unknown_starttag
    p.EndElementHandler=F.unknown_endtag
    r=p.Parse(data)
    outfile.seek(0)
    return jar.importFile(outfile,clue)
</t>
<t tx="ekr.20040104185913.3005">&lt;&lt; ZDOM declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3006">&lt;&lt; copyright &gt;&gt;
"""
DOM implementation in ZOPE : Read-Only methods

All standard Zope objects support DOM to a limited extent.
"""
import Acquisition


# Node type codes
# ---------------

ELEMENT_NODE       = 1
ATTRIBUTE_NODE     = 2
TEXT_NODE          = 3
CDATA_SECTION_NODE = 4
ENTITY_REFERENCE_NODE = 5
ENTITY_NODE        = 6
PROCESSING_INSTRUCTION_NODE = 7
COMMENT_NODE       = 8
DOCUMENT_NODE      = 9
DOCUMENT_TYPE_NODE = 10
DOCUMENT_FRAGMENT_NODE = 11
NOTATION_NODE      = 12

# Exception codes
# ---------------

INDEX_SIZE_ERR              = 1
DOMSTRING_SIZE_ERR          = 2
HIERARCHY_REQUEST_ERR       = 3
WRONG_DOCUMENT_ERR          = 4
INVALID_CHARACTER_ERR       = 5
NO_DATA_ALLOWED_ERR         = 6
NO_MODIFICATION_ALLOWED_ERR = 7
NOT_FOUND_ERR               = 8
NOT_SUPPORTED_ERR           = 9
INUSE_ATTRIBUTE_ERR         = 10

# Exceptions
# ----------

</t>
<t tx="ekr.20040104185913.3007">class DOMException(Exception):
	&lt;&lt; class DOMException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3008">pass
</t>
<t tx="ekr.20040104185913.3009">class IndexSizeException(DOMException):
	&lt;&lt; class IndexSizeException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3010">code = INDEX_SIZE_ERR
</t>
<t tx="ekr.20040104185913.3011">class DOMStringSizeException(DOMException):
	&lt;&lt; class DOMStringSizeException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3012">code = DOMSTRING_SIZE_ERR
</t>
<t tx="ekr.20040104185913.3013">class HierarchyRequestException(DOMException):
	&lt;&lt; class HierarchyRequestException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3014">code = HIERARCHY_REQUEST_ERR
</t>
<t tx="ekr.20040104185913.3015">class WrongDocumentException(DOMException):
	&lt;&lt; class WrongDocumentException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3016">code = WRONG_DOCUMENT_ERR
</t>
<t tx="ekr.20040104185913.3017">class InvalidCharacterException(DOMException):
	&lt;&lt; class InvalidCharacterException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3018">code = INVALID_CHARACTER_ERR
</t>
<t tx="ekr.20040104185913.3019">class NoDataAllowedException(DOMException):
	&lt;&lt; class NoDataAllowedException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3020">code = NO_DATA_ALLOWED_ERR
</t>
<t tx="ekr.20040104185913.3021">class NoModificationAllowedException(DOMException):
	&lt;&lt; class NoModificationAllowedException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3022">code = NO_MODIFICATION_ALLOWED_ERR
</t>
<t tx="ekr.20040104185913.3023">class NotFoundException(DOMException):
	&lt;&lt; class NotFoundException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3024">code = NOT_FOUND_ERR
</t>
<t tx="ekr.20040104185913.3025">class NotSupportedException(DOMException):
	&lt;&lt; class NotSupportedException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3026">code = NOT_SUPPORTED_ERR
</t>
<t tx="ekr.20040104185913.3027">class InUseAttributeException(DOMException):
	&lt;&lt; class InUseAttributeException declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3028">code = INUSE_ATTRIBUTE_ERR

# Node classes
# ------------

</t>
<t tx="ekr.20040104185913.3029">class Node:
    """
    Node Interface
    """
	&lt;&lt; class Node declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3030">__ac_permissions__=(
    ('Access contents information',
        ('getNodeName', 'getNodeValue', 'getParentNode',
        'getChildNodes', 'getFirstChild', 'getLastChild',
        'getPreviousSibling', 'getNextSibling', 'getOwnerDocument',
        'getAttributes', 'hasChildNodes'),
    ),
)

# DOM attributes
# --------------

</t>
<t tx="ekr.20040104185913.3031">def getNodeName(self):
    """The name of this node, depending on its type"""
    return None
</t>
<t tx="ekr.20040104185913.3032">def getNodeValue(self):
    """The value of this node, depending on its type"""
    return None
</t>
<t tx="ekr.20040104185913.3033">def getParentNode(self):
    """The parent of this node.  All nodes except Document
    DocumentFragment and Attr may have a parent"""
    return None
</t>
<t tx="ekr.20040104185913.3034">def getChildNodes(self):
    """Returns a NodeList that contains all children of this node.
    If there are no children, this is a empty NodeList"""
    return NodeList()
</t>
<t tx="ekr.20040104185913.3035">def getFirstChild(self):
    """The first child of this node. If there is no such node
    this returns None."""
    return None
</t>
<t tx="ekr.20040104185913.3036">def getLastChild(self):
    """The last child of this node. If there is no such node
    this returns None."""
    return None
</t>
<t tx="ekr.20040104185913.3037">def getPreviousSibling(self):
    """The node immediately preceding this node.  If
    there is no such node, this returns None."""
    return None
</t>
<t tx="ekr.20040104185913.3038">def getNextSibling(self):
    """The node immediately preceding this node.  If
    there is no such node, this returns None."""
    return None
</t>
<t tx="ekr.20040104185913.3039">def getAttributes(self):
    """Returns a NamedNodeMap containing the attributes
    of this node (if it is an element) or None otherwise."""
    return None
</t>
<t tx="ekr.20040104185913.3040">def getOwnerDocument(self):
    """The Document object associated with this node.
    When this is a document this is None"""
    node = self
    if hasattr(node, 'aq_parent'):
        node = self.aq_parent
        return node.getOwnerDocument()
    return node
</t>
<t tx="ekr.20040104185913.3041"># DOM Methods
# -----------

def hasChildNodes(self):
    """Returns true if the node has any children, false
    if it doesn't. """
    return len(self.objectIds())
</t>
<t tx="ekr.20040104185913.3042">class Document(Acquisition.Explicit, Node):
    """
    Document Interface
    """
	&lt;&lt; class Document declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3043">__ac_permissions__=(
    ('Access contents information',
        ('getImplementation', 'getDoctype', 'getDocumentElement'),
    ),
)

# Document Methods
# ----------------

</t>
<t tx="ekr.20040104185913.3044">def getImplementation(self):
    """
    The DOMImplementation object that handles this document.
    """
    return DOMImplementation()
</t>
<t tx="ekr.20040104185913.3045">def getDoctype(self):
    """
    The Document Type Declaration associated with this document.
    For HTML documents as well as XML documents without
    a document type declaration this returns null.
    """
    return None
</t>
<t tx="ekr.20040104185913.3046">def getDocumentElement(self):
    """
    This is a convenience attribute that allows direct access to
    the child node that is the root element of the document.
    """
    return self.aq_parent
</t>
<t tx="ekr.20040104185913.3047"># Node Methods
# ------------

def getNodeName(self):
    """The name of this node, depending on its type"""
    return '#document'
</t>
<t tx="ekr.20040104185913.3048">def getNodeType(self):
    """A code representing the type of the node."""
    return DOCUMENT_NODE
</t>
<t tx="ekr.20040104185913.3049">def getOwnerDocument(self):
    """The Document object associated with this node.
    When this is a document this is None"""
    return self
</t>
<t tx="ekr.20040104185913.3050">def getChildNodes(self):
    """Returns a NodeList that contains all children of this node.
    If there are no children, this is a empty NodeList"""
    return NodeList([self.aq_parent])
</t>
<t tx="ekr.20040104185913.3051">def getFirstChild(self):
    """The first child of this node. If there is no such node
    this returns None."""
    return self.aq_parent
</t>
<t tx="ekr.20040104185913.3052">def getLastChild(self):
    """The last child of this node. If there is no such node
    this returns None."""
    return self.aq_parent
</t>
<t tx="ekr.20040104185913.3053">def hasChildNodes(self):
    """Returns true if the node has any children, false
    if it doesn't. """
    return 1
</t>
<t tx="ekr.20040104185913.3054">class DOMImplementation:
    """
    DOMImplementation Interface
    """
	&lt;&lt; class DOMImplementation declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3055">__ac_permissions__=(
    ('Access contents information',
        ('hasFeature'),
    ),
)

</t>
<t tx="ekr.20040104185913.3056">def hasFeature(self, feature, version = None):
    """
    hasFeature - Test if the DOM implementation implements a specific
    feature. Parameters: feature The package name of the feature to
    test. In Level 1, the legal values are "HTML" and "XML"
    (case-insensitive). version This is the version number of the
    package name to test. In Level 1, this is the string "1.0". If the
    version is not specified, supporting any version of the feature
    will cause the method to return true. Return Value true if the
    feature is implemented in the specified version, false otherwise.
    """
    feature=feature.lower()
    if feature == 'html': return 0
    if feature == 'xml':
        if version is None: return 1
        if version == '1.0': return 1
        return 0
</t>
<t tx="ekr.20040104185913.3057">class Element(Node):
    """
    Element interface
    """
	&lt;&lt; class Element declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3058">__ac_permissions__=(
    ('Access contents information',
        ('getTagName', 'getAttribute', 'getAttributeNode',
        'getElementsByTagName'),
    ),
)

# Element Attributes
# ------------------

</t>
<t tx="ekr.20040104185913.3059">def getTagName(self):
    """The name of the element"""
    return self.__class__.__name__
</t>
<t tx="ekr.20040104185913.3060"># Node Attributes
# ---------------

def getNodeName(self):
    """The name of this node, depending on its type"""
    return self.getTagName()
</t>
<t tx="ekr.20040104185913.3061">def getNodeType(self):
    """A code representing the type of the node."""
    return ELEMENT_NODE
</t>
<t tx="ekr.20040104185913.3062">def getParentNode(self):
    """The parent of this node.  All nodes except Document
    DocumentFragment and Attr may have a parent"""
    return getattr(self, 'aq_parent', None)
</t>
<t tx="ekr.20040104185913.3063">def getChildNodes(self):
    """Returns a NodeList that contains all children of this node.
    If there are no children, this is a empty NodeList"""
    return  NodeList(self.objectValues())
</t>
<t tx="ekr.20040104185913.3064">def getFirstChild(self):
    """The first child of this node. If there is no such node
    this returns None"""
    children = self.getChildNodes()
    if children:
        return children._data[0]
    return None
</t>
<t tx="ekr.20040104185913.3065">def getLastChild(self):
    """The last child of this node.  If there is no such node
    this returns None."""
    children = self.getChildNodes()
    if children:
        return children._data[-1]
    return None
</t>
<t tx="ekr.20040104185913.3066">def getPreviousSibling(self):
    """The node immediately preceding this node.  If
    there is no such node, this returns None."""
    if hasattr(self, 'aq_parent'):
        parent = self.aq_parent
        ids=list(parent.objectIds())
        id=self.id
        if type(id) is not type(''): id=id()
        try: index=ids.index(id)
        except: return None
        if index &lt; 1: return None
        return parent.objectValues()[index-1]
    return None
</t>
<t tx="ekr.20040104185913.3067">def getNextSibling(self):
    """The node immediately preceding this node.  If
    there is no such node, this returns None."""
    if hasattr(self, 'aq_parent'):
        parent = self.aq_parent
        ids=list(parent.objectIds())
        id=self.id
        if type(id) is not type(''): id=id()
        try: index=ids.index(id)
        except: return None
        if index &gt;= len(ids)-1: return None
        return parent.objectValues()[index+1]
    return None
</t>
<t tx="ekr.20040104185913.3068"># Element Methods
# ---------------

def getAttribute(self, name):
    """Retrieves an attribute value by name."""
    return None
</t>
<t tx="ekr.20040104185913.3069">def getAttributeNode(self, name):
    """ Retrieves an Attr node by name or None if
    there is no such attribute. """
    return None
</t>
<t tx="ekr.20040104185913.3070">def getElementsByTagName(self, tagname):
    """ Returns a NodeList of all the Elements with a given tag
    name in the order in which they would be encountered in a
    preorder traversal of the Document tree.  Parameter: tagname
    The name of the tag to match (* = all tags). Return Value: A new
    NodeList object containing all the matched Elements.
    """
    nodeList = []
    for child in self.objectValues():
        if (child.getNodeType()==ELEMENT_NODE and \
                child.getTagName()==tagname or tagname== '*'):
            nodeList.append(child)
        if hasattr(child, 'getElementsByTagName'):
            n1 = child.getElementsByTagName(tagname)
            nodeList = nodeList + n1._data
    return NodeList(nodeList)
</t>
<t tx="ekr.20040104185913.3071">class ElementWithAttributes(Element):
    """
    Elements that allow DOM access to Zope properties of type 'string'.

    Note: This sub-class should only be used by PropertyManagers
    """
	@others
</t>
<t tx="ekr.20040104185913.3072">def getAttributes(self):
    """Returns a NamedNodeMap containing the attributes
    of this node (if it is an element) or None otherwise."""
    attribs={}
    for p in self._properties:
        if p['type'] == 'string':
            name=p['id']
            attrib=Attr(name, self.getProperty(name,'')).__of__(self)
            attribs[name]=attrib
    return NamedNodeMap(attribs)
</t>
<t tx="ekr.20040104185913.3073">def getAttribute(self, name):
    """Retrieves an attribute value by name."""
    if self.getPropertyType(name) == 'string':
        return self.getProperty(name,'')
</t>
<t tx="ekr.20040104185913.3074">def getAttributeNode(self, name):
    """Retrieves an Attr node by name or None if
    there is no such attribute. """
    if self.getPropertyType(name) == 'string':
        return Attr(name, self.getProperty(name,'')).__of__(self)
    return None
</t>
<t tx="ekr.20040104185913.3075">class ElementWithTitle(Element):
    """
    Elements that allow DOM access to Zope 'title' property.

    Note: Don't use this sub-class for PropertyManagers
    """
	@others
</t>
<t tx="ekr.20040104185913.3076">def getAttributes(self):
    """Returns a NamedNodeMap containing the attributes
    of this node (if it is an element) or None otherwise."""
    title = self.getAttributeNode('title')
    if title is not None:
        return NamedNodeMap({'title':title})
    return NamedNodeMap()
</t>
<t tx="ekr.20040104185913.3077">def getAttribute(self, name):
    """Retrieves an attribute value by name."""
    if name=='title' and hasattr(self.aq_base, 'title'):
        return self.title
    return ''
</t>
<t tx="ekr.20040104185913.3078">def getAttributeNode(self, name):
    """Retrieves an Attr node by name or None if
    there is no such attribute. """
    value=self.getAttribute(name)
    if value:
        return Attr(name, value).__of__(self)
    return None
</t>
<t tx="ekr.20040104185913.3079">class Root(ElementWithAttributes):
    """
    The top-level Zope object.
    """
	@others
</t>
<t tx="ekr.20040104185913.3080">def getOwnerDocument(self):
    """
    """
    return Document().__of__(self)
</t>
<t tx="ekr.20040104185913.3081">class NodeList:
    """NodeList interface - Provides the abstraction of an ordered
    collection of nodes.

    Python extensions: can use sequence-style 'len', 'getitem', and
    'for..in' constructs.
    """
	&lt;&lt; class NodeList declarations &gt;&gt;
	@others

    __len__=getLength</t>
<t tx="ekr.20040104185913.3082"># The security machinery is not willing to treat this like a
# list just because we act like one. We need to assert that
# its ok to allow access to items in the nodelist.
__allow_access_to_unprotected_subobjects__=1

</t>
<t tx="ekr.20040104185913.3083">def __init__(self,list=None):
    self._data = list or []
</t>
<t tx="ekr.20040104185913.3084">def __getitem__(self, index):
    return self._data[index]
</t>
<t tx="ekr.20040104185913.3085">def item(self, index):
    """Returns the index-th item in the collection"""
    try: return self._data[index]
    except IndexError: return None
</t>
<t tx="ekr.20040104185913.3086">def getLength(self):
    """The length of the NodeList"""
    return len(self._data)
</t>
<t tx="ekr.20040104185913.3087">class NamedNodeMap:
    """
    NamedNodeMap interface - Is used to represent collections
    of nodes that can be accessed by name.  NamedNodeMaps are not
    maintained in any particular order.

    Python extensions: can use sequence-style 'len', 'getitem', and
    'for..in' constructs, and mapping-style 'getitem'.
    """
	&lt;&lt; class NamedNodeMap declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3088"># Tell the security machinery to allow access to items.
__allow_access_to_unprotected_subobjects__=1

</t>
<t tx="ekr.20040104185913.3089">def __init__(self, data=None):
    if data is None : data = {}
    self._data = data
</t>
<t tx="ekr.20040104185913.3090">def item(self, index):
    """Returns the index-th item in the map"""
    try: return self._data.values()[index]
    except IndexError: return None
</t>
<t tx="ekr.20040104185913.3091">def __getitem__(self, key):
    if type(key)==type(1):
        return self._data.values()[key]
    else:
        return self._data[key]
</t>
<t tx="ekr.20040104185913.3092">def getLength(self):
    """The length of the NodeList"""
    return len(self._data)
</t>
<t tx="ekr.20040104185913.3093">__len__ = getLength

def getNamedItem(self, name):
    """Retrieves a node specified by name. Parameters:
    name Name of a node to retrieve. Return Value A Node (of any
    type) with the specified name, or None if the specified name
    did not identify any node in the map.
    """
    if self._data.has_key(name):
        return self._data[name]
    return None
</t>
<t tx="ekr.20040104185913.3094">class Attr(Acquisition.Implicit, Node):
    """
    Attr interface - The Attr interface represents an attriubte in an
    Element object. Attr objects inherit the Node Interface
    """
	@others
</t>
<t tx="ekr.20040104185913.3095">def __init__(self, name, value):
    self.name = name
    self.value = value
    self.specified = 1
</t>
<t tx="ekr.20040104185913.3096">def getNodeName(self):
    """The name of this node, depending on its type"""
    return self.name
</t>
<t tx="ekr.20040104185913.3097">def getName(self):
    """Returns the name of this attribute."""
    return self.name
</t>
<t tx="ekr.20040104185913.3098">def getNodeValue(self):
    """The value of this node, depending on its type"""
    return self.value
</t>
<t tx="ekr.20040104185913.3099">def getNodeType(self):
    """A code representing the type of the node."""
    return ATTRIBUTE_NODE
</t>
<t tx="ekr.20040104185913.3100">def getSpecified(self):
    """If this attribute was explicitly given a value in the
    original document, this is true; otherwise, it is false."""
    return self.specified
</t>
<t tx="ekr.20040104185913.3101">&lt;&lt; copyright &gt;&gt;
</t>
<t tx="ekr.20040104185913.3102">&lt;&lt; content_types declarations &gt;&gt;
@others

if __name__=='__main__':
    items=mimetypes.types_map.items()
    items.sort()
    for item in items: print "%s:\t%s" % item
</t>
<t tx="ekr.20040104185913.3103">&lt;&lt; copyright &gt;&gt;
"""A utility module for content-type handling."""
__version__='$Revision: 1.18 $'[11:-2]

import re, mimetypes


find_binary=re.compile('[\0-\7]').search

</t>
<t tx="ekr.20040104185913.3104">def text_type(s):
    # Yuk. See if we can figure out the type by content.
    if (s.strip().lower()[:6] == '&lt;html&gt;' or s.find('&lt;/') &gt; 0):
        return 'text/html'

    elif s.strip().startswith('&lt;?xml'):
        return 'text/xml'

    else:
        return 'text/plain'
</t>
<t tx="ekr.20040104185913.3105"># This gives us a hook to add content types that
# aren't currently listed in the mimetypes module.
_addtypes=(
    ('.mp3', 'audio/mpeg'),
    ('.ra', 'audio/x-pn-realaudio'),
    ('.pdf', 'application/pdf'),
    ('.c', 'text/plain'),
    ('.bat', 'text/plain'),
    ('.h', 'text/plain'),
    ('.pl', 'text/plain'),
    ('.ksh', 'text/plain'),
    ('.ram', 'application/x-pn-realaudio'),
    ('.cdf', 'application-x-cdf'),
    ('.doc', 'application/msword'),
    ('.dot', 'application/msword'),
    ('.wiz', 'application/msword'),
    ('.xlb', 'application/vnd.ms-excel'),
    ('.xls', 'application/vnd.ms-excel'),
    ('.ppa', 'application/vnd.ms-powerpoint'),
    ('.ppt', 'application/vnd.ms-powerpoint'),
    ('.pps', 'application/vnd.ms-powerpoint'),
    ('.pot', 'application/vnd.ms-powerpoint'),
    ('.pwz', 'application/vnd.ms-powerpoint'),
    ('.eml',   'message/rfc822'),
    ('.nws',   'message/rfc822'),
    ('.mht',   'message/rfc822'),
    ('.mhtml', 'message/rfc822'),
    ('.css', 'text/css'),
    ('.p7c', 'application/pkcs7-mime'),
    ('.p12', 'application/x-pkcs12'),
    ('.pfx', 'application/x-pkcs12'),
    ('.js',  'application/x-javascript'),
    ('.pct', 'image/pict'),
    ('.pic', 'image/pict'),
    ('.pict', 'image/pict'),
    ('.m1v', 'video/mpeg'),
    ('.mpa', 'video/mpeg'),
    ('.vcf', 'text/x-vcard'),
    ('.xml', 'text/xml'),
    ('.xsl', 'text/xsl'),
    ('.xul', 'text/xul'),
    )
for name, val in _addtypes:
    mimetypes.types_map[name]=val

def guess_content_type(name='', body='', default=None):
    # Attempt to determine the content type (and possibly
    # content-encoding) based on an an object's name and
    # entity body.
    type, enc=mimetypes.guess_type(name)
    if type is None:
        if body:
            if find_binary(body) is not None:
                type=default or 'application/octet-stream'
            else:
                type=(default or text_type(body)
                      or 'text/x-unknown-content-type')
        else:
            type=default or 'text/x-unknown-content-type'

    return type.lower(), enc and enc.lower() or None
</t>
<t tx="ekr.20040104185913.3106">&lt;&lt; misc_ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3107">&lt;&lt; copyright &gt;&gt;

from App.ImageFile import ImageFile


</t>
<t tx="ekr.20040104185913.3108">class misc_:
	&lt;&lt; class misc_ declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3109">"Miscellaneous product information"
__roles__=None

</t>
<t tx="ekr.20040104185913.3110">class p_:
	&lt;&lt; class p_ declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3111">"Shared system information"
__roles__=None

broken=ImageFile('www/broken.gif', globals())

User_icon =ImageFile('AccessControl/www/User_icon.gif')

locked=ImageFile('www/modified.gif', globals())
lockedo=ImageFile('www/locked.gif', globals())

davlocked=ImageFile('webdav/www/davlock.gif')

pl=ImageFile('TreeDisplay/www/Plus_icon.gif')
mi=ImageFile('TreeDisplay/www/Minus_icon.gif')
rtab=ImageFile('App/www/rtab.gif')
ltab=ImageFile('App/www/ltab.gif')
sp  =ImageFile('App/www/sp.gif')
r_arrow_gif=ImageFile('www/r_arrow.gif', globals())
l_arrow_gif=ImageFile('www/l_arrow.gif', globals())

ControlPanel_icon=ImageFile('OFS/www/ControlPanel_icon.gif')
ApplicationManagement_icon=ImageFile('App/www/cpSystem.gif')
DatabaseManagement_icon=ImageFile('App/www/dbManage.gif')
VersionManagement_icon=ImageFile('App/www/vManage.gif')
DebugManager_icon=ImageFile('App/www/DebugManager_icon.gif')
InstalledProduct_icon=ImageFile('App/www/installedProduct.gif')
BrokenProduct_icon=ImageFile('App/www/brokenProduct.gif')
Product_icon=ImageFile('App/www/product.gif')
Factory_icon=ImageFile('App/www/factory.gif')
Permission_icon=ImageFile('App/www/permission.gif')
ProductFolder_icon=ImageFile('App/www/productFolder.gif')
PyPoweredSmall_Gif=ImageFile('App/www/PythonPoweredSmall.gif')

ZopeButton=ImageFile('App/www/zope_button.jpg')
ZButton=ImageFile('App/www/z_button.jpg')
zopelogo_jpg=ImageFile('App/www/zopelogo.jpg')

Properties_icon=ImageFile('OFS/www/Properties_icon.gif')
Methods_icon=ImageFile('ZClasses/methods.gif')
Propertysheets_icon=ImageFile('ZClasses/propertysheets.gif')

ProductHelp_icon=ImageFile('HelpSys/images/productHelp.gif')
HelpTopic_icon=ImageFile('HelpSys/images/helpTopic.gif')

</t>
<t tx="ekr.20040104185913.3112">class Misc_:
	&lt;&lt; class Misc_ declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3113">"Miscellaneous product information"

__roles__=None

</t>
<t tx="ekr.20040104185913.3114">def __init__(self, name, dict):
    self._d=dict
    self.__name__=name
</t>
<t tx="ekr.20040104185913.3115">def __str__(self): return self.__name__
</t>
<t tx="ekr.20040104185913.3116">def __getitem__(self, name): return self._d[name]
</t>
<t tx="ekr.20040104185913.3117">def __setitem__(self, name, v): self._d[name]=v
</t>
<t tx="ekr.20040104185913.3118">&lt;&lt; ndiff declarations &gt;&gt;
@others

if __name__ == '__main__':
    import sys
    args = sys.argv[1:]
    if "-profile" in args:
        import profile, pstats
        args.remove("-profile")
        statf = "ndiff.pro"
        profile.run("main(args)", statf)
        stats = pstats.Stats(statf)
        stats.strip_dirs().sort_stats('time').print_stats()
    else:
        main(args)
</t>
<t tx="ekr.20040104185913.3119">#! /usr/bin/env python

# Module ndiff version 1.4.0
# Released to the public domain 27-Mar-1999,
# by Tim Peters (tim_one@email.msn.com).

# Provided as-is; use at your own risk; no warranty; no promises; enjoy!

"""ndiff [-q] file1 file2
    or
ndiff (-r1 | -r2) &lt; ndiff_output &gt; file1_or_file2

Print a human-friendly file difference report to stdout.  Both inter-
and intra-line differences are noted.  In the second form, recreate file1
(-r1) or file2 (-r2) on stdout, from an ndiff report on stdin.

In the first form, if -q ("quiet") is not specified, the first two lines
of output are

-: file1
+: file2

Each remaining line begins with a two-letter code:

    "- "    line unique to file1
    "+ "    line unique to file2
    "  "    line common to both files
    "? "    line not present in either input file

Lines beginning with "? " attempt to guide the eye to intraline
differences, and were not present in either input file.  These lines can
be confusing if the source files contain tab characters.

The first file can be recovered by retaining only lines that begin with
"  " or "- ", and deleting those 2-character prefixes; use ndiff with -r1.

The second file can be recovered similarly, but by retaining only "  "
and "+ " lines; use ndiff with -r2; or, on Unix, the second file can be
recovered by piping the output through

    sed -n '/^[+ ] /s/^..//p'

See module comments for details and programmatic interface.
"""

__version__ = 1, 4, 0

# SequenceMatcher tries to compute a "human-friendly diff" between
# two sequences (chiefly picturing a file as a sequence of lines,
# and a line as a sequence of characters, here).  Unlike e.g. UNIX(tm)
# diff, the fundamental notion is the longest *contiguous* &amp; junk-free
# matching subsequence.  That's what catches peoples' eyes.  The
# Windows(tm) windiff has another interesting notion, pairing up elements
# that appear uniquely in each sequence.  That, and the method here,
# appear to yield more intuitive difference reports than does diff.  This
# method appears to be the least vulnerable to synching up on blocks
# of "junk lines", though (like blank lines in ordinary text files,
# or maybe "&lt;P&gt;" lines in HTML files).  That may be because this is
# the only method of the 3 that has a *concept* of "junk" &lt;wink&gt;.
#
# Note that ndiff makes no claim to produce a *minimal* diff.  To the
# contrary, minimal diffs are often counter-intuitive, because they
# synch up anywhere possible, sometimes accidental matches 100 pages
# apart.  Restricting synch points to contiguous matches preserves some
# notion of locality, at the occasional cost of producing a longer diff.
#
# With respect to junk, an earlier version of ndiff simply refused to
# *start* a match with a junk element.  The result was cases like this:
#     before: private Thread currentThread;
#     after:  private volatile Thread currentThread;
# If you consider whitespace to be junk, the longest contiguous match
# not starting with junk is "e Thread currentThread".  So ndiff reported
# that "e volatil" was inserted between the 't' and the 'e' in "private".
# While an accurate view, to people that's absurd.  The current version
# looks for matching blocks that are entirely junk-free, then extends the
# longest one of those as far as possible but only with matching junk.
# So now "currentThread" is matched, then extended to suck up the
# preceding blank; then "private" is matched, and extended to suck up the
# following blank; then "Thread" is matched; and finally ndiff reports
# that "volatile " was inserted before "Thread".  The only quibble
# remaining is that perhaps it was really the case that " volatile"
# was inserted after "private".  I can live with that &lt;wink&gt;.
#
# NOTE on junk:  the module-level names
#    IS_LINE_JUNK
#    IS_CHARACTER_JUNK
# can be set to any functions you like.  The first one should accept
# a single string argument, and return true iff the string is junk.
# The default is whether the regexp r"\s*#?\s*$" matches (i.e., a
# line without visible characters, except for at most one splat).
# The second should accept a string of length 1 etc.  The default is
# whether the character is a blank or tab (note: bad idea to include
# newline in this!).
#
# After setting those, you can call fcompare(f1name, f2name) with the
# names of the files you want to compare.  The difference report
# is sent to stdout.  Or you can call main(args), passing what would
# have been in sys.argv[1:] had the cmd-line form been used.

TRACE = 0

# define what "junk" means
import re

</t>
<t tx="ekr.20040104185913.3120">def IS_LINE_JUNK(line, pat=re.compile(r"\s*#?\s*$").match):
    return pat(line) is not None
</t>
<t tx="ekr.20040104185913.3121">def IS_CHARACTER_JUNK(ch, ws=" \t"):
    return ch in ws
</t>
<t tx="ekr.20040104185913.3122">del re

class SequenceMatcher:
	@others
</t>
<t tx="ekr.20040104185913.3123">def __init__(self, isjunk=None, a='', b=''):
    # Members:
    # a
    #      first sequence
    # b
    #      second sequence; differences are computed as "what do
    #      we need to do to 'a' to change it into 'b'?"
    # b2j
    #      for x in b, b2j[x] is a list of the indices (into b)
    #      at which x appears; junk elements do not appear
    # b2jhas
    #      b2j.has_key
    # fullbcount
    #      for x in b, fullbcount[x] == the number of times x
    #      appears in b; only materialized if really needed (used
    #      only for computing quick_ratio())
    # matching_blocks
    #      a list of (i, j, k) triples, where a[i:i+k] == b[j:j+k];
    #      ascending &amp; non-overlapping in i and in j; terminated by
    #      a dummy (len(a), len(b), 0) sentinel
    # opcodes
    #      a list of (tag, i1, i2, j1, j2) tuples, where tag is
    #      one of
    #          'replace'   a[i1:i2] should be replaced by b[j1:j2]
    #          'delete'    a[i1:i2] should be deleted
    #          'insert'    b[j1:j2] should be inserted
    #          'equal'     a[i1:i2] == b[j1:j2]
    # isjunk
    #      a user-supplied function taking a sequence element and
    #      returning true iff the element is "junk" -- this has
    #      subtle but helpful effects on the algorithm, which I'll
    #      get around to writing up someday &lt;0.9 wink&gt;.
    #      DON'T USE!  Only __chain_b uses this.  Use isbjunk.
    # isbjunk
    #      for x in b, isbjunk(x) == isjunk(x) but much faster;
    #      it's really the has_key method of a hidden dict.
    #      DOES NOT WORK for x in a!

    self.isjunk = isjunk
    self.a = self.b = None
    self.set_seqs(a, b)
</t>
<t tx="ekr.20040104185913.3124">def set_seqs(self, a, b):
    self.set_seq1(a)
    self.set_seq2(b)
</t>
<t tx="ekr.20040104185913.3125">def set_seq1(self, a):
    if a is self.a:
        return
    self.a = a
    self.matching_blocks = self.opcodes = None
</t>
<t tx="ekr.20040104185913.3126">def set_seq2(self, b):
    if b is self.b:
        return
    self.b = b
    self.matching_blocks = self.opcodes = None
    self.fullbcount = None
    self.__chain_b()
</t>
<t tx="ekr.20040104185913.3127"># For each element x in b, set b2j[x] to a list of the indices in
# b where x appears; the indices are in increasing order; note that
# the number of times x appears in b is len(b2j[x]) ...
# when self.isjunk is defined, junk elements don't show up in this
# map at all, which stops the central find_longest_match method
# from starting any matching block at a junk element ...
# also creates the fast isbjunk function ...
# note that this is only called when b changes; so for cross-product
# kinds of matches, it's best to call set_seq2 once, then set_seq1
# repeatedly

def __chain_b(self):
    # Because isjunk is a user-defined (not C) function, and we test
    # for junk a LOT, it's important to minimize the number of calls.
    # Before the tricks described here, __chain_b was by far the most
    # time-consuming routine in the whole module!  If anyone sees
    # Jim Roskind, thank him again for profile.py -- I never would
    # have guessed that.
    # The first trick is to build b2j ignoring the possibility
    # of junk.  I.e., we don't call isjunk at all yet.  Throwing
    # out the junk later is much cheaper than building b2j "right"
    # from the start.
    b = self.b
    self.b2j = b2j = {}
    self.b2jhas = b2jhas = b2j.has_key
    for i in xrange(len(b)):
        elt = b[i]
        if b2jhas(elt):
            b2j[elt].append(i)
        else:
            b2j[elt] = [i]

    # Now b2j.keys() contains elements uniquely, and especially when
    # the sequence is a string, that's usually a good deal smaller
    # than len(string).  The difference is the number of isjunk calls
    # saved.
    isjunk, junkdict = self.isjunk, {}
    if isjunk:
        for elt in b2j.keys():
            if isjunk(elt):
                junkdict[elt] = 1   # value irrelevant; it's a set
                del b2j[elt]

    # Now for x in b, isjunk(x) == junkdict.has_key(x), but the
    # latter is much faster.  Note too that while there may be a
    # lot of junk in the sequence, the number of *unique* junk
    # elements is probably small.  So the memory burden of keeping
    # this dict alive is likely trivial compared to the size of b2j.
    self.isbjunk = junkdict.has_key
</t>
<t tx="ekr.20040104185913.3128">def find_longest_match(self, alo, ahi, blo, bhi):
    """Find longest matching block in a[alo:ahi] and b[blo:bhi].

    If isjunk is not defined:

    Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
        alo &lt;= i &lt;= i+k &lt;= ahi
        blo &lt;= j &lt;= j+k &lt;= bhi
    and for all (i',j',k') meeting those conditions,
        k &gt;= k'
        i &lt;= i'
        and if i == i', j &lt;= j'
    In other words, of all maximal matching blocks, return one
    that starts earliest in a, and of all those maximal matching
    blocks that start earliest in a, return the one that starts
    earliest in b.

    If isjunk is defined, first the longest matching block is
    determined as above, but with the additional restriction that
    no junk element appears in the block.  Then that block is
    extended as far as possible by matching (only) junk elements on
    both sides.  So the resulting block never matches on junk except
    as identical junk happens to be adjacent to an "interesting"
    match.

    If no blocks match, return (alo, blo, 0).
    """

    # CAUTION:  stripping common prefix or suffix would be incorrect.
    # E.g.,
    #    ab
    #    acab
    # Longest matching block is "ab", but if common prefix is
    # stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
    # strip, so ends up claiming that ab is changed to acab by
    # inserting "ca" in the middle.  That's minimal but unintuitive:
    # "it's obvious" that someone inserted "ac" at the front.
    # Windiff ends up at the same place as diff, but by pairing up
    # the unique 'b's and then matching the first two 'a's.

    a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.isbjunk
    besti, bestj, bestsize = alo, blo, 0
    # find longest junk-free match
    # during an iteration of the loop, j2len[j] = length of longest
    # junk-free match ending with a[i-1] and b[j]
    j2len = {}
    nothing = []
    for i in xrange(alo, ahi):
        # look at all instances of a[i] in b; note that because
        # b2j has no junk keys, the loop is skipped if a[i] is junk
        j2lenget = j2len.get
        newj2len = {}
        for j in b2j.get(a[i], nothing):
            # a[i] matches b[j]
            if j &lt; blo:
                continue
            if j &gt;= bhi:
                break
            k = newj2len[j] = j2lenget(j-1, 0) + 1
            if k &gt; bestsize:
                besti, bestj, bestsize = i-k+1, j-k+1, k
        j2len = newj2len

    # Now that we have a wholly interesting match (albeit possibly
    # empty!), we may as well suck up the matching junk on each
    # side of it too.  Can't think of a good reason not to, and it
    # saves post-processing the (possibly considerable) expense of
    # figuring out what to do with it.  In the case of an empty
    # interesting match, this is clearly the right thing to do,
    # because no other kind of match is possible in the regions.
    while besti &gt; alo and bestj &gt; blo and \
          isbjunk(b[bestj-1]) and \
          a[besti-1] == b[bestj-1]:
        besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
    while besti+bestsize &lt; ahi and bestj+bestsize &lt; bhi and \
          isbjunk(b[bestj+bestsize]) and \
          a[besti+bestsize] == b[bestj+bestsize]:
        bestsize = bestsize + 1

    if TRACE:
        print "get_matching_blocks", alo, ahi, blo, bhi
        print "    returns", besti, bestj, bestsize
    return besti, bestj, bestsize
</t>
<t tx="ekr.20040104185913.3129">def get_matching_blocks(self):
    if self.matching_blocks is not None:
        return self.matching_blocks
    self.matching_blocks = []
    la, lb = len(self.a), len(self.b)
    self.__helper(0, la, 0, lb, self.matching_blocks)
    self.matching_blocks.append( (la, lb, 0) )
    if TRACE:
        print '*** matching blocks', self.matching_blocks
    return self.matching_blocks
</t>
<t tx="ekr.20040104185913.3130"># builds list of matching blocks covering a[alo:ahi] and
# b[blo:bhi], appending them in increasing order to answer

def __helper(self, alo, ahi, blo, bhi, answer):
    i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)
    # a[alo:i] vs b[blo:j] unknown
    # a[i:i+k] same as b[j:j+k]
    # a[i+k:ahi] vs b[j+k:bhi] unknown
    if k:
        if alo &lt; i and blo &lt; j:
            self.__helper(alo, i, blo, j, answer)
        answer.append(x)
        if i+k &lt; ahi and j+k &lt; bhi:
            self.__helper(i+k, ahi, j+k, bhi, answer)
</t>
<t tx="ekr.20040104185913.3131">def ratio(self):
    """Return a measure of the sequences' similarity (float in [0,1]).

    Where T is the total number of elements in both sequences, and
    M is the number of matches, this is 2*M / T.
    Note that this is 1 if the sequences are identical, and 0 if
    they have nothing in common.
    """

    matches = reduce(lambda sum, triple: sum + triple[-1],
                     self.get_matching_blocks(), 0)
    return 2.0 * matches / (len(self.a) + len(self.b))
</t>
<t tx="ekr.20040104185913.3132">def quick_ratio(self):
    """Return an upper bound on ratio() relatively quickly."""
    # viewing a and b as multisets, set matches to the cardinality
    # of their intersection; this counts the number of matches
    # without regard to order, so is clearly an upper bound
    if self.fullbcount is None:
        self.fullbcount = fullbcount = {}
        for elt in self.b:
            fullbcount[elt] = fullbcount.get(elt, 0) + 1
    fullbcount = self.fullbcount
    # avail[x] is the number of times x appears in 'b' less the
    # number of times we've seen it in 'a' so far ... kinda
    avail = {}
    availhas, matches = avail.has_key, 0
    for elt in self.a:
        if availhas(elt):
            numb = avail[elt]
        else:
            numb = fullbcount.get(elt, 0)
        avail[elt] = numb - 1
        if numb &gt; 0:
            matches = matches + 1
    return 2.0 * matches / (len(self.a) + len(self.b))
</t>
<t tx="ekr.20040104185913.3133">def real_quick_ratio(self):
    """Return an upper bound on ratio() very quickly"""
    la, lb = len(self.a), len(self.b)
    # can't have more matches than the number of elements in the
    # shorter sequence
    return 2.0 * min(la, lb) / (la + lb)
</t>
<t tx="ekr.20040104185913.3134">def get_opcodes(self):
    if self.opcodes is not None:
        return self.opcodes
    i = j = 0
    self.opcodes = answer = []
    for ai, bj, size in self.get_matching_blocks():
        # invariant:  we've pumped out correct diffs to change
        # a[:i] into b[:j], and the next matching block is
        # a[ai:ai+size] == b[bj:bj+size].  So we need to pump
        # out a diff to change a[i:ai] into b[j:bj], pump out
        # the matching block, and move (i,j) beyond the match
        tag = ''
        if i &lt; ai and j &lt; bj:
            tag = 'replace'
        elif i &lt; ai:
            tag = 'delete'
        elif j &lt; bj:
            tag = 'insert'
        if tag:
            answer.append( (tag, i, ai, j, bj) )
        i, j = ai+size, bj+size
        # the list of matching blocks is terminated by a
        # sentinel with size 0
        if size:
            answer.append( ('equal', ai, i, bj, j) )
    return answer
</t>
<t tx="ekr.20040104185913.3135"># meant for dumping lines
def dump(tag, x, lo, hi):
    for i in xrange(lo, hi):
        print tag, x[i],
</t>
<t tx="ekr.20040104185913.3136"># figure out which mark to stick under characters in lines that
# have changed (blank = same, - = deleted, + = inserted, ^ = replaced)
_combine = { '  ': ' ',
             '. ': '-',
             ' .': '+',
             '..': '^' }

def plain_replace(a, alo, ahi, b, blo, bhi):
    assert alo &lt; ahi and blo &lt; bhi
    # dump the shorter block first -- reduces the burden on short-term
    # memory if the blocks are of very different sizes
    if bhi - blo &lt; ahi - alo:
        dump('+', b, blo, bhi)
        dump('-', a, alo, ahi)
    else:
        dump('-', a, alo, ahi)
        dump('+', b, blo, bhi)
</t>
<t tx="ekr.20040104185913.3137"># When replacing one block of lines with another, this guy searches
# the blocks for *similar* lines; the best-matching pair (if any) is
# used as a synch point, and intraline difference marking is done on
# the similar pair.  Lots of work, but often worth it.

def fancy_replace(a, alo, ahi, b, blo, bhi):
    if TRACE:
        print '*** fancy_replace', alo, ahi, blo, bhi
        dump('&gt;', a, alo, ahi)
        dump('&lt;', b, blo, bhi)

    # don't synch up unless the lines have a similarity score of at
    # least cutoff; best_ratio tracks the best score seen so far
    best_ratio, cutoff = 0.74, 0.75
    cruncher = SequenceMatcher(IS_CHARACTER_JUNK)
    eqi, eqj = None, None   # 1st indices of equal lines (if any)

    # search for the pair that matches best without being identical
    # (identical lines must be junk lines, &amp; we don't want to synch up
    # on junk -- unless we have to)
    for j in xrange(blo, bhi):
        bj = b[j]
        cruncher.set_seq2(bj)
        for i in xrange(alo, ahi):
            ai = a[i]
            if ai == bj:
                if eqi is None:
                    eqi, eqj = i, j
                continue
            cruncher.set_seq1(ai)
            # computing similarity is expensive, so use the quick
            # upper bounds first -- have seen this speed up messy
            # compares by a factor of 3.
            # note that ratio() is only expensive to compute the first
            # time it's called on a sequence pair; the expensive part
            # of the computation is cached by cruncher
            if cruncher.real_quick_ratio() &gt; best_ratio and \
                  cruncher.quick_ratio() &gt; best_ratio and \
                  cruncher.ratio() &gt; best_ratio:
                best_ratio, best_i, best_j = cruncher.ratio(), i, j
    if best_ratio &lt; cutoff:
        # no non-identical "pretty close" pair
        if eqi is None:
            # no identical pair either -- treat it as a straight replace
            plain_replace(a, alo, ahi, b, blo, bhi)
            return
        # no close pair, but an identical pair -- synch up on that
        best_i, best_j, best_ratio = eqi, eqj, 1.0
    else:
        # there's a close pair, so forget the identical pair (if any)
        eqi = None

    # a[best_i] very similar to b[best_j]; eqi is None iff they're not
    # identical
    if TRACE:
        print '*** best_ratio', best_ratio, best_i, best_j
        dump('&gt;', a, best_i, best_i+1)
        dump('&lt;', b, best_j, best_j+1)

    # pump out diffs from before the synch point
    fancy_helper(a, alo, best_i, b, blo, best_j)

    # do intraline marking on the synch pair
    aelt, belt = a[best_i], b[best_j]
    if eqi is None:
        # pump out a '-', '+', '?' triple for the synched lines;
        atags = btags = ""
        cruncher.set_seqs(aelt, belt)
        for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():
            la, lb = ai2 - ai1, bj2 - bj1
            if tag == 'replace':
                atags = atags + '.' * la
                btags = btags + '.' * lb
            elif tag == 'delete':
                atags = atags + '.' * la
            elif tag == 'insert':
                btags = btags + '.' * lb
            elif tag == 'equal':
                atags = atags + ' ' * la
                btags = btags + ' ' * lb
            else:
                raise ValueError, 'unknown tag ' + `tag`
        la, lb = len(atags), len(btags)
        if la &lt; lb:
            atags = atags + ' ' * (lb - la)
        elif lb &lt; la:
            btags = btags + ' ' * (la - lb)
        combined = map(lambda x,y: _combine[x+y], atags, btags)
        print '-', aelt, '+', belt, '?', \
              ''.join(combined).rstrip()
    else:
        # the synch pair is identical
        print ' ', aelt,

    # pump out diffs from after the synch point
    fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi)
</t>
<t tx="ekr.20040104185913.3138">def fancy_helper(a, alo, ahi, b, blo, bhi):
    if alo &lt; ahi:
        if blo &lt; bhi:
            fancy_replace(a, alo, ahi, b, blo, bhi)
        else:
            dump('-', a, alo, ahi)
    elif blo &lt; bhi:
        dump('+', b, blo, bhi)
</t>
<t tx="ekr.20040104185913.3139">def fail(msg):
    import sys
    out = sys.stderr.write
    out(msg + "\n\n")
    out(__doc__)
    return 0
</t>
<t tx="ekr.20040104185913.3140"># open a file &amp; return the file object; gripe and return 0 if it
# couldn't be opened
def fopen(fname):
    try:
        return open(fname, 'r')
    except IOError, detail:
        return fail("couldn't open " + fname + ": " + str(detail))
</t>
<t tx="ekr.20040104185913.3141"># open two files &amp; spray the diff to stdout; return false iff a problem
def fcompare(f1name, f2name):
    f1 = fopen(f1name)
    f2 = fopen(f2name)
    if not f1 or not f2:
        return 0

    a = f1.readlines(); f1.close()
    b = f2.readlines(); f2.close()

    cruncher = SequenceMatcher(IS_LINE_JUNK, a, b)
    for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
        if tag == 'replace':
            fancy_replace(a, alo, ahi, b, blo, bhi)
        elif tag == 'delete':
            dump('-', a, alo, ahi)
        elif tag == 'insert':
            dump('+', b, blo, bhi)
        elif tag == 'equal':
            dump(' ', a, alo, ahi)
        else:
            raise ValueError, 'unknown tag ' + `tag`

    return 1
</t>
<t tx="ekr.20040104185913.3142"># crack args (sys.argv[1:] is normal) &amp; compare;
# return false iff a problem

def main(args):
    import getopt
    try:
        opts, args = getopt.getopt(args, "qr:")
    except getopt.error, detail:
        return fail(str(detail))
    noisy = 1
    qseen = rseen = 0
    for opt, val in opts:
        if opt == "-q":
            qseen = 1
            noisy = 0
        elif opt == "-r":
            rseen = 1
            whichfile = val
    if qseen and rseen:
        return fail("can't specify both -q and -r")
    if rseen:
        if args:
            return fail("no args allowed with -r option")
        if whichfile in "12":
            restore(whichfile)
            return 1
        return fail("-r value must be 1 or 2")
    if len(args) != 2:
        return fail("need 2 filename args")
    f1name, f2name = args
    if noisy:
        print '-:', f1name
        print '+:', f2name
    return fcompare(f1name, f2name)
</t>
<t tx="ekr.20040104185913.3143">def restore(which):
    import sys
    tag = {"1": "- ", "2": "+ "}[which]
    prefixes = ("  ", tag)
    for line in sys.stdin.readlines():
        if line[:2] in prefixes:
            print line[2:],
</t>
<t tx="ekr.20040104185913.3144">&lt;&lt; rPickle declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3145">&lt;&lt; copyright &gt;&gt;
"""Restricted unpickler"""

__version__='$Revision: 1.6 $'[11:-2]


import pickle

reg={}

</t>
<t tx="ekr.20040104185913.3146">class Unpickler(pickle.Unpickler):
	@others
</t>
<t tx="ekr.20040104185913.3147">def find_class(self, module, name):
    try:    return reg[(module,name)]
    except: raise SystemError, 'Class not registered'
</t>
<t tx="ekr.20040104185913.3148">def load_string(self):
    raise 'BadPickle', 'Non binstring'
</t>
<t tx="ekr.20040104185913.3149"># Public interface

from cStringIO import StringIO

def loads(s):
    """Unpickle a string"""
    return Unpickler(StringIO(s)).load()
</t>
<t tx="ekr.20040104185913.3150">def register(mod, cls, obj):
    """Register a class"""
    reg[(mod,cls)]=obj
</t>
<t tx="ekr.20040104185913.3151">def unregister(mod, cls):
    """Unregister a class"""
    del reg[(mod,cls)]
</t>
<t tx="ekr.20040104185913.3152"></t>
<t tx="ekr.20040104185913.3153"># This helps debugging.
</t>
<t tx="ekr.20040104185913.3154">&lt;&lt; testCopySupport declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.3155">import os, sys, unittest

import string, cStringIO, re
import ZODB, Acquisition
from OFS.Application import Application
from OFS.Folder import manage_addFolder
from OFS.Image import manage_addFile
from Testing.makerequest import makerequest
from webdav.common import rfc1123_date
from AccessControl import SecurityManager
from AccessControl.SecurityManagement import newSecurityManager
from AccessControl.SecurityManagement import noSecurityManager

from mimetools import Message
from multifile import MultiFile

</t>
<t tx="ekr.20040104185913.3156">class UnitTestSecurityPolicy:
    """
        Stub out the existing security policy for unit testing purposes.
    """
	&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3157">    #
    #   Standard SecurityPolicy interface
    #
</t>
<t tx="ekr.20040104185913.3158">def validate( self
            , accessed=None
            , container=None
            , name=None
            , value=None
            , context=None
            , roles=None
            , *args
            , **kw):
    return 1
</t>
<t tx="ekr.20040104185913.3159">def checkPermission( self, permission, object, context) :
    return 1
</t>
<t tx="ekr.20040104185913.3160">class UnitTestUser( Acquisition.Implicit ):
    """
        Stubbed out manager for unit testing purposes.
    """
	@others
</t>
<t tx="ekr.20040104185913.3161">def getId( self ):
    return 'unit_tester'
</t>
<t tx="ekr.20040104185913.3162">getUserName = getId

def allowed( self, object, object_roles=None ):
    return 1
</t>
<t tx="ekr.20040104185913.3163">def makeConnection():
    import ZODB
    from ZODB.DemoStorage import DemoStorage

    s = DemoStorage(quota=(1&lt;&lt;20))
    return ZODB.DB( s ).open()
</t>
<t tx="ekr.20040104185913.3164">class TestCopySupport( unittest.TestCase ):
	@others
</t>
<t tx="ekr.20040104185913.3165">def setUp( self ):

    self.connection = makeConnection()
    try:
        r = self.connection.root()
        a = Application()
        r['Application'] = a
        self.root = a
        responseOut = self.responseOut = cStringIO.StringIO()
        self.app = makerequest( self.root, stdout=responseOut )
        manage_addFolder( self.app, 'folder1' )
        manage_addFolder( self.app, 'folder2' )
        folder1 = getattr( self.app, 'folder1' )
        folder2 = getattr( self.app, 'folder2' )

        folder1.all_meta_types = folder2.all_meta_types = \
                                ( { 'name'        : 'File'
                                  , 'action'      : 'manage_addFile'
                                  , 'permission'  : 'Add images and files'
                                  }
                                ,
                                )

        manage_addFile( folder1, 'file'
                      , file='', content_type='text/plain')

        # Hack, we need a _p_mtime for the file, so we make sure that it
        # has one. We use a subtransaction, which means we can rollback
        # later and pretend we didn't touch the ZODB.
        get_transaction().commit()
    except:
        self.connection.close()
        raise
    get_transaction().begin()
    self.folder1 = getattr( self.app, 'folder1' )
    self.folder2 = getattr( self.app, 'folder2' )

    self.policy = UnitTestSecurityPolicy()
    self.oldPolicy = SecurityManager.setSecurityPolicy( self.policy )
    newSecurityManager( None, UnitTestUser().__of__( self.root ) )
</t>
<t tx="ekr.20040104185913.3166">def tearDown( self ):
    noSecurityManager()
    SecurityManager.setSecurityPolicy( self.oldPolicy )
    del self.oldPolicy
    del self.policy
    del self.folder2
    del self.folder1
    get_transaction().abort()
    self.app._p_jar.sync()
    self.connection.close()
    del self.app
    del self.responseOut
    del self.root
    del self.connection
</t>
<t tx="ekr.20040104185913.3167">def testRename( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.folder1.manage_renameObject( id='file', new_id='filex' )
    self.failIf( 'file' in self.folder1.objectIds() )
    self.failUnless( 'filex' in self.folder1.objectIds() )
</t>
<t tx="ekr.20040104185913.3168">def testCopy( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file' in self.folder2.objectIds() )
    cookie = self.folder1.manage_copyObjects( ids=('file',) )
    self.folder2.manage_pasteObjects( cookie )
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
</t>
<t tx="ekr.20040104185913.3169">def testCut( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file' in self.folder2.objectIds() )
    cookie = self.folder1.manage_cutObjects( ids=('file',) )
    self.folder2.manage_pasteObjects( cookie )
    self.failIf( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
</t>
<t tx="ekr.20040104185913.3170">def testCopyNewObject(self):
    self.failIf('newfile' in self.folder1.objectIds())
    manage_addFile(self.folder1, 'newfile',
                   file='', content_type='text/plain')
    cookie = self.folder1.manage_copyObjects(ids=('newfile',))
    self.folder2.manage_pasteObjects(cookie)
    self.failUnless('newfile' in self.folder1.objectIds())
    self.failUnless('newfile' in self.folder2.objectIds())
</t>
<t tx="ekr.20040104185913.3171">def testPasteSingleNotSameID( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file' in self.folder2.objectIds() )
    cookie = self.folder1.manage_copyObjects( ids=('file',) )
    result = self.folder2.manage_pasteObjects( cookie )
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
    self.failUnless( result == [{'id':'file', 'new_id':'file'}])
</t>
<t tx="ekr.20040104185913.3172">def testPasteSingleSameID( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file' in self.folder2.objectIds() )
    manage_addFile(self.folder2, 'file',
                   file='', content_type='text/plain')
    cookie = self.folder1.manage_copyObjects( ids=('file',) )
    result = self.folder2.manage_pasteObjects( cookie )
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
    self.failUnless( 'copy_of_file' in self.folder2.objectIds() )
    self.failUnless( result == [{'id':'file', 'new_id':'copy_of_file'}])
</t>
<t tx="ekr.20040104185913.3173">def testPasteMultiNotSameID( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file1' in self.folder1.objectIds() )
    manage_addFile(self.folder1, 'file1',
                   file='', content_type='text/plain')
    self.failIf( 'file2' in self.folder1.objectIds() )
    manage_addFile(self.folder1, 'file2',
                   file='', content_type='text/plain')
    self.failIf( 'file' in self.folder2.objectIds() )
    self.failIf( 'file1' in self.folder2.objectIds() )
    self.failIf( 'file2' in self.folder2.objectIds() )
    cookie = self.folder1.manage_copyObjects( ids=('file','file1','file2',) )
    result = self.folder2.manage_pasteObjects( cookie )
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file1' in self.folder1.objectIds() )
    self.failUnless( 'file2' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
    self.failUnless( 'file1' in self.folder2.objectIds() )
    self.failUnless( 'file2' in self.folder2.objectIds() )
    self.failUnless( result == [{'id':'file', 'new_id':'file'},
                                {'id':'file1', 'new_id':'file1'},
                                {'id':'file2', 'new_id':'file2'}])
</t>
<t tx="ekr.20040104185913.3174">def testPasteMultiSameID( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failIf( 'file1' in self.folder1.objectIds() )
    manage_addFile(self.folder1, 'file1',
                   file='', content_type='text/plain')
    self.failIf( 'file2' in self.folder1.objectIds() )
    manage_addFile(self.folder1, 'file2',
                   file='', content_type='text/plain')
    self.failIf( 'file' in self.folder2.objectIds() )
    manage_addFile(self.folder2, 'file',
                   file='', content_type='text/plain')
    self.failIf( 'file1' in self.folder2.objectIds() )
    manage_addFile(self.folder2, 'file1',
                   file='', content_type='text/plain')
    self.failIf( 'file2' in self.folder2.objectIds() )
    manage_addFile(self.folder2, 'file2',
                   file='', content_type='text/plain')
    cookie = self.folder1.manage_copyObjects( ids=('file','file1','file2',) )
    result = self.folder2.manage_pasteObjects( cookie )
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( 'file1' in self.folder1.objectIds() )
    self.failUnless( 'file2' in self.folder1.objectIds() )
    self.failUnless( 'file' in self.folder2.objectIds() )
    self.failUnless( 'file1' in self.folder2.objectIds() )
    self.failUnless( 'file2' in self.folder2.objectIds() )
    self.failUnless( 'copy_of_file' in self.folder2.objectIds() )
    self.failUnless( 'copy_of_file1' in self.folder2.objectIds() )
    self.failUnless( 'copy_of_file2' in self.folder2.objectIds() )
    self.failUnless( result == [{'id':'file', 'new_id':'copy_of_file'},
                                {'id':'file1', 'new_id':'copy_of_file1'},
                                {'id':'file2', 'new_id':'copy_of_file2'}])
</t>
<t tx="ekr.20040104185913.3175">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestCopySupport ) )
    return suite
</t>
<t tx="ekr.20040104185913.3176">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.3177">&lt;&lt; testRanges declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.3178">&lt;&lt; copyright &gt;&gt;
import os, sys, unittest

import string, random, cStringIO, time, re
import ZODB
from OFS.Application import Application
from OFS.Folder import manage_addFolder
from OFS.Image import manage_addFile
from Testing.makerequest import makerequest
from webdav.common import rfc1123_date

from mimetools import Message
from multifile import MultiFile

</t>
<t tx="ekr.20040104185913.3179">def makeConnection():
    import ZODB
    from ZODB.DemoStorage import DemoStorage

    s = DemoStorage(quota=(1&lt;&lt;20))
    return ZODB.DB( s ).open()
</t>
<t tx="ekr.20040104185913.3180">def createBigFile():
    # Create a file that is several 1&lt;&lt;16 blocks of data big, to force the
    # use of chained Pdata objects.
    # Make sure we create a file that isn't of x * 1&lt;&lt;16 length! Coll #671
    size = (1&lt;&lt;16) * 5 + 12345
    file = cStringIO.StringIO()

    def addLetter(x, add=file.write, l=string.letters,
            c=random.choice):
        add(c(l))
    filter(addLetter, range(size))

    return file
</t>
<t tx="ekr.20040104185913.3181">TESTFOLDER_NAME = 'RangesTestSuite_testFolder'
BIGFILE = createBigFile()

class TestRequestRange(unittest.TestCase):
	&lt;&lt; class TestRequestRange declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3182">    # Test case setup and teardown
</t>
<t tx="ekr.20040104185913.3183">def setUp(self):
    self.responseOut = cStringIO.StringIO()
    self.connection = makeConnection()
    try:
        r = self.connection.root()
        a = Application()
        r['Application'] = a
        self.root = a
        self.app = makerequest(self.root, stdout=self.responseOut)
        try: self.app._delObject(TESTFOLDER_NAME)
        except AttributeError: pass
        manage_addFolder(self.app, TESTFOLDER_NAME)
        folder = getattr( self.app, TESTFOLDER_NAME )

        data = string.letters
        manage_addFile( folder, 'file'
                      , file=data, content_type='text/plain')

        self.file = folder.file
        self.data = data

        # Hack, we need a _p_mtime for the file, so we make sure that it
        # has one. We use a subtransaction, which means we can rollback
        # later and pretend we didn't touch the ZODB.
        get_transaction().commit()
    except:
        self.connection.close()
        raise
</t>
<t tx="ekr.20040104185913.3184">def tearDown(self):
    try: self.app._delObject(TESTFOLDER_NAME)
    except AttributeError: pass
    get_transaction().abort()
    self.app._p_jar.sync()
    self.connection.close()
    self.app = None
    del self.app
</t>
<t tx="ekr.20040104185913.3185"># Utility methods
def uploadBigFile(self):
    self.file.manage_upload(BIGFILE)
    self.data = BIGFILE.getvalue()
</t>
<t tx="ekr.20040104185913.3186">def doGET(self, request, response):
    rv = self.file.index_html(request, response)

    # Large files are written to resposeOut directly, small ones are
    # returned from the index_html method.
    body = self.responseOut.getvalue()

    # Chop off any printed headers (only when response.write was used)
    if body:
        body = string.split(body, '\n\n', 1)[1]

    return body + rv
</t>
<t tx="ekr.20040104185913.3187">def createLastModifiedDate(self, offset=0):
    return rfc1123_date(self.file._p_mtime + offset)
</t>
<t tx="ekr.20040104185913.3188">def expectUnsatisfiable(self, range):
    req = self.app.REQUEST
    rsp = req.RESPONSE

    # Add the Range header
    req.environ['HTTP_RANGE'] = 'bytes=%s' % range

    body = self.doGET(req, rsp)

    self.failUnless(rsp.getStatus() == 416,
        'Expected a 416 status, got %s' % rsp.getStatus())

    expect_content_range = 'bytes */%d' % len(self.data)
    content_range = rsp.getHeader('content-range')
    self.failIf(content_range is None, 'No Content-Range header was set!')
    self.failUnless(content_range == expect_content_range,
        'Received incorrect Content-Range header. Expected %s, got %s' % (
            `expect_content_range`, `content_range`))

    self.failUnless(body == '', 'index_html returned %s' % `body`)
</t>
<t tx="ekr.20040104185913.3189">def expectOK(self, rangeHeader, if_range=None):
    req = self.app.REQUEST
    rsp = req.RESPONSE

    # Add headers
    req.environ['HTTP_RANGE'] = rangeHeader
    if if_range is not None:
        req.environ['HTTP_IF_RANGE'] = if_range

    body = self.doGET(req, rsp)

    self.failUnless(rsp.getStatus() == 200,
        'Expected a 200 status, got %s' % rsp.getStatus())
</t>
<t tx="ekr.20040104185913.3190">def expectSingleRange(self, range, start, end, if_range=None):
    req = self.app.REQUEST
    rsp = req.RESPONSE

    # Add headers
    req.environ['HTTP_RANGE'] = 'bytes=%s' % range
    if if_range is not None:
        req.environ['HTTP_IF_RANGE'] = if_range

    body = self.doGET(req, rsp)

    self.failUnless(rsp.getStatus() == 206,
        'Expected a 206 status, got %s' % rsp.getStatus())

    expect_content_range = 'bytes %d-%d/%d' % (
        start, end - 1, len(self.data))
    content_range = rsp.getHeader('content-range')
    self.failIf(content_range is None, 'No Content-Range header was set!')
    self.failUnless(content_range == expect_content_range,
        'Received incorrect Content-Range header. Expected %s, got %s' % (
            `expect_content_range`, `content_range`))
    self.failIf(rsp.getHeader('content-length') != str(len(body)),
        'Incorrect Content-Length is set! Expected %s, got %s.' % (
            str(len(body)), rsp.getHeader('content-length')))

    self.failUnless(body == self.data[start:end],
        'Incorrect range returned, expected %s, got %s' % (
            `self.data[start:end]`, `body`))
</t>
<t tx="ekr.20040104185913.3191">def expectMultipleRanges(self, range, sets, draft=0,
        rangeParse=re.compile('bytes\s*(\d+)-(\d+)/(\d+)')):
    req = self.app.REQUEST
    rsp = req.RESPONSE

    # Add headers
    req.environ['HTTP_RANGE'] = 'bytes=%s' % range

    if draft:
        req.environ['HTTP_REQUEST_RANGE'] = 'bytes=%s' % range

    body = self.doGET(req, rsp)

    self.failUnless(rsp.getStatus() == 206,
        'Expected a 206 status, got %s' % rsp.getStatus())
    self.failIf(rsp.getHeader('content-range'),
        'The Content-Range header should not be set!')

    ct = string.split(rsp.getHeader('content-type'), ';')[0]
    draftprefix = draft and 'x-' or ''
    self.failIf(ct != 'multipart/%sbyteranges' % draftprefix,
        "Incorrect Content-Type set. Expected 'multipart/%sbyteranges', "
        "got %s" % (draftprefix, ct))
    if rsp.getHeader('content-length'):
        self.failIf(rsp.getHeader('content-length') != str(len(body)),
            'Incorrect Content-Length is set! Expected %s, got %s.' % (
                str(len(body)), rsp.getHeader('content-length')))

    # Decode the multipart message
    bodyfile = cStringIO.StringIO('Content-Type: %s\n\n%s' % (
        rsp.getHeader('content-type'), body))
    bodymessage = Message(bodyfile)
    partfiles = MultiFile(bodyfile)
    partfiles.push(bodymessage.getparam('boundary'))

    partmessages = []
    add = partmessages.append
    while partfiles.next():
        add(Message(cStringIO.StringIO(partfiles.read())))

    # Check the different parts
    returnedRanges = []
    add = returnedRanges.append
    for part in partmessages:
        range = part['content-range']
        start, end, size = rangeParse.search(range).groups()
        start, end, size = int(start), int(end), int(size)
        end = end + 1

        self.failIf(size != len(self.data),
            'Part Content-Range header reported incorrect length. '
            'Expected %d, got %d.' % (len(self.data), size))

        part.rewindbody()
        body = part.fp.read()
        # Whotcha! Bug in MultiFile; the CRLF that is part of the boundary
        # is returned as part of the body. Note that this bug is resolved
        # in Python 2.2.
        if body[-2:] == '\r\n':
            body = body[:-2]

        self.failIf(len(body) != end - start,
            'Part (%d, %d) is of wrong length, expected %d, got %d.' % (
                start, end, end - start, len(body)))
        self.failIf(body != self.data[start:end],
            'Part (%d, %d) has incorrect data. Expected %s, got %s.' % (
                start, end, `self.data[start:end]`, `body`))

        add((start, end))

    # Copmare the ranges used with the expected range sets.
    self.failIf(returnedRanges != sets,
        'Got unexpected sets, expected %s, got %s' % (
            sets, returnedRanges))
</t>
<t tx="ekr.20040104185913.3192"># Unsatisfiable requests
def testNegativeZero(self):
    self.expectUnsatisfiable('-0')
</t>
<t tx="ekr.20040104185913.3193">def testStartBeyondLength(self):
    self.expectUnsatisfiable('1000-')
</t>
<t tx="ekr.20040104185913.3194">def testMultipleUnsatisfiable(self):
    self.expectUnsatisfiable('1000-1001,2000-,-0')
</t>
<t tx="ekr.20040104185913.3195"># Malformed Range header
def testGarbage(self):
    self.expectOK('kjhdkjhd = ew;jkj h eewh ew')
</t>
<t tx="ekr.20040104185913.3196">def testIllegalSpec(self):
    self.expectOK('notbytes=0-1000')
</t>
<t tx="ekr.20040104185913.3197"># Single ranges
def testSimpleRange(self):
    self.expectSingleRange('3-7', 3, 8)
</t>
<t tx="ekr.20040104185913.3198">def testOpenEndedRange(self):
    self.expectSingleRange('3-', 3, len(self.data))
</t>
<t tx="ekr.20040104185913.3199">def testSuffixRange(self):
    l = len(self.data)
    self.expectSingleRange('-3', l - 3, l)
</t>
<t tx="ekr.20040104185913.3200">def testWithNegativeZero(self):
    # A satisfiable and an unsatisfiable range
    self.expectSingleRange('-0,3-23', 3, 24)
</t>
<t tx="ekr.20040104185913.3201">def testEndOverflow(self):
    l = len(self.data)
    start, end = l - 10, l + 10
    range = '%d-%d' % (start, end)
    self.expectSingleRange(range, start, len(self.data))
</t>
<t tx="ekr.20040104185913.3202">def testBigFile(self):
    # Files of size 1&lt;&lt;16 are stored in linked Pdata objects. They are
    # treated seperately in the range code.
    self.uploadBigFile()
    join = 3 * (1&lt;&lt;16) # A join between two linked objects
    start = join - 1000
    end = join + 1000
    range = '%d-%d' % (start, end - 1)
    self.expectSingleRange(range, start, end)
</t>
<t tx="ekr.20040104185913.3203">def testBigFileEndOverflow(self):
    self.uploadBigFile()
    l = len(self.data)
    start, end = l - 100, l + 100
    range = '%d-%d' % (start, end)
    self.expectSingleRange(range, start, len(self.data))
</t>
<t tx="ekr.20040104185913.3204"># Multiple ranges
def testAdjacentRanges(self):
    self.expectMultipleRanges('21-25,10-20', [(21, 26), (10, 21)])
</t>
<t tx="ekr.20040104185913.3205">def testMultipleRanges(self):
    self.expectMultipleRanges('3-7,10-15', [(3, 8), (10, 16)])
</t>
<t tx="ekr.20040104185913.3206">def testMultipleRangesDraft(self):
    self.expectMultipleRanges('3-7,10-15', [(3, 8), (10, 16)], draft=1)
</t>
<t tx="ekr.20040104185913.3207">def testMultipleRangesBigFile(self):
    self.uploadBigFile()
    self.expectMultipleRanges('3-700,10-15,-10000',
        [(3, 701), (10, 16), (len(self.data) - 10000, len(self.data))])
</t>
<t tx="ekr.20040104185913.3208">def testMultipleRangesBigFileOutOfOrder(self):
    self.uploadBigFile()
    self.expectMultipleRanges('10-15,-10000,70000-80000', 
        [(10, 16), (len(self.data) - 10000, len(self.data)),
         (70000, 80001)])
</t>
<t tx="ekr.20040104185913.3209">def testMultipleRangesBigFileEndOverflow(self):
    self.uploadBigFile()
    l = len(self.data)
    start, end = l - 100, l + 100
    self.expectMultipleRanges('3-700,%s-%s' % (start, end),
        [(3, 701), (len(self.data) - 100, len(self.data))])
</t>
<t tx="ekr.20040104185913.3210"># If-Range headers
def testIllegalIfRange(self):
    # We assume that an illegal if-range is to be ignored, just like an
    # illegal if-modified since.
    self.expectSingleRange('10-25', 10, 26, if_range='garbage')
</t>
<t tx="ekr.20040104185913.3211">def testEqualIfRangeDate(self):
    self.expectSingleRange('10-25', 10, 26,
        if_range=self.createLastModifiedDate())
</t>
<t tx="ekr.20040104185913.3212">def testIsModifiedIfRangeDate(self):
    self.expectOK('21-25,10-20',
        if_range=self.createLastModifiedDate(offset=-100))
</t>
<t tx="ekr.20040104185913.3213">def testIsNotModifiedIfRangeDate(self):
    self.expectSingleRange('10-25', 10, 26,
        if_range=self.createLastModifiedDate(offset=100))
</t>
<t tx="ekr.20040104185913.3214">def testEqualIfRangeEtag(self):
    self.expectSingleRange('10-25', 10, 26,
        if_range=self.file.http__etag())
</t>
<t tx="ekr.20040104185913.3215">def testNotEqualIfRangeEtag(self):
    self.expectOK('10-25',
        if_range=self.file.http__etag() + 'bar')
</t>
<t tx="ekr.20040104185913.3216">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestRequestRange ) )
    return suite
</t>
<t tx="ekr.20040104185913.3217">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.3218">&lt;&lt; testTraverse declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.3219">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest
import string, cStringIO, re

import ZODB, Acquisition
from Acquisition import aq_base
from OFS.Application import Application
from OFS.Folder import manage_addFolder
from OFS.Image import manage_addFile
from OFS.SimpleItem import SimpleItem
from Testing.makerequest import makerequest
from AccessControl import SecurityManager, Unauthorized
from AccessControl.SecurityManagement import newSecurityManager
from AccessControl.SecurityManagement import noSecurityManager

from mimetools import Message
from multifile import MultiFile


</t>
<t tx="ekr.20040104185913.3220">class UnitTestSecurityPolicy:
    """
        Stub out the existing security policy for unit testing purposes.
    """
	&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3221">    #
    #   Standard SecurityPolicy interface
    #
</t>
<t tx="ekr.20040104185913.3222">def validate( self
            , accessed=None
            , container=None
            , name=None
            , value=None
            , context=None
            , roles=None
            , *args
            , **kw):
    return 1
</t>
<t tx="ekr.20040104185913.3223">def checkPermission( self, permission, object, context) :
    return 1
</t>
<t tx="ekr.20040104185913.3224">class CruelSecurityPolicy:
    """Denies everything
    """
	&lt;&lt; class CruelSecurityPolicy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3225">    #
    #   Standard SecurityPolicy interface
    #
</t>
<t tx="ekr.20040104185913.3226">def validate(self, accessed, container, name, value, *args):
    if aq_base(accessed) is aq_base(container):
        raise Unauthorized, name
    return 0
</t>
<t tx="ekr.20040104185913.3227">def checkPermission( self, permission, object, context) :
    return 0
</t>
<t tx="ekr.20040104185913.3228">class UnitTestUser( Acquisition.Implicit ):
    """
        Stubbed out manager for unit testing purposes.
    """
	@others
</t>
<t tx="ekr.20040104185913.3229">def getId( self ):
    return 'unit_tester'
</t>
<t tx="ekr.20040104185913.3230">getUserName = getId

def allowed( self, object, object_roles=None ):
    return 1
</t>
<t tx="ekr.20040104185913.3231">class BoboTraversable(SimpleItem):
	&lt;&lt; class BoboTraversable declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3232">__allow_access_to_unprotected_subobjects__ = 1

</t>
<t tx="ekr.20040104185913.3233">def __bobo_traverse__(self, request, name):
    if name == 'bb_subitem':
        return BoboTraversable().__of__(self)
    else:
        raise KeyError
</t>
<t tx="ekr.20040104185913.3234">def makeConnection():
    import ZODB
    from ZODB.DemoStorage import DemoStorage

    s = DemoStorage(quota=(1&lt;&lt;20))
    return ZODB.DB( s ).open()
</t>
<t tx="ekr.20040104185913.3235">class TestTraverse( unittest.TestCase ):
	@others
</t>
<t tx="ekr.20040104185913.3236">def setUp( self ):

    self.connection = makeConnection()
    try:
        r = self.connection.root()
        a = Application()
        r['Application'] = a
        self.root = a
        responseOut = self.responseOut = cStringIO.StringIO()
        self.app = makerequest( self.root, stdout=responseOut )
        manage_addFolder( self.app, 'folder1' )
        folder1 = getattr( self.app, 'folder1' )

        folder1.all_meta_types = \
                                ( { 'name'        : 'File'
                                  , 'action'      : 'manage_addFile'
                                  , 'permission'  : 'Add images and files'
                                  }
                                ,
                                )

        manage_addFile( folder1, 'file'
                      , file='', content_type='text/plain')

        # Hack, we need a _p_mtime for the file, so we make sure that it
        # has one. We use a subtransaction, which means we can rollback
        # later and pretend we didn't touch the ZODB.
        get_transaction().commit()
    except:
        self.connection.close()
        raise
    get_transaction().begin()
    self.folder1 = getattr( self.app, 'folder1' )

    self.policy = UnitTestSecurityPolicy()
    self.oldPolicy = SecurityManager.setSecurityPolicy( self.policy )
    newSecurityManager( None, UnitTestUser().__of__( self.root ) )
</t>
<t tx="ekr.20040104185913.3237">def tearDown( self ):
    noSecurityManager()
    SecurityManager.setSecurityPolicy( self.oldPolicy )
    del self.oldPolicy
    del self.policy
    del self.folder1
    get_transaction().abort()
    self.app._p_jar.sync()
    self.connection.close()
    del self.app
    del self.responseOut
    del self.root
    del self.connection
</t>
<t tx="ekr.20040104185913.3238">def testTraversePath( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( self.folder1.unrestrictedTraverse( ('', 'folder1', 'file' ) ))
    self.failUnless( self.folder1.unrestrictedTraverse( ('', 'folder1' ) ))
</t>
<t tx="ekr.20040104185913.3239">def testTraverseURLNoSlash( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( self.folder1.unrestrictedTraverse( '/folder1/file' ))
    self.failUnless( self.folder1.unrestrictedTraverse( '/folder1' ))
</t>
<t tx="ekr.20040104185913.3240">def testTraverseURLSlash( self ):
    self.failUnless( 'file' in self.folder1.objectIds() )
    self.failUnless( self.folder1.unrestrictedTraverse( '/folder1/file/' ))
    self.failUnless( self.folder1.unrestrictedTraverse( '/folder1/' ))
</t>
<t tx="ekr.20040104185913.3241">def testTraverseToNone( self ):
    self.failUnlessRaises( KeyError, self.folder1.unrestrictedTraverse, ('', 'folder1', 'file2' ) )
    self.failUnlessRaises( KeyError, self.folder1.unrestrictedTraverse,  '/folder1/file2' )
    self.failUnlessRaises( KeyError, self.folder1.unrestrictedTraverse,  '/folder1/file2/' )
</t>
<t tx="ekr.20040104185913.3242">def testTraverseThroughBoboTraverse(self):
    # Verify it's possible to use __bobo_traverse__ with the
    # Zope security policy.
    noSecurityManager()
    SecurityManager.setSecurityPolicy( self.oldPolicy )
    bb = BoboTraversable()
    self.failUnlessRaises(KeyError, bb.restrictedTraverse, 'notfound')
    bb.restrictedTraverse('bb_subitem')
</t>
<t tx="ekr.20040104185913.3243">def testAcquiredAttributeDenial(self):
    # Verify that restrictedTraverse raises the right kind of exception
    # on denial of access to an acquired attribute.  If it raises
    # AttributeError instead of Unauthorized, the user may never
    # be prompted for HTTP credentials.
    noSecurityManager()
    SecurityManager.setSecurityPolicy(CruelSecurityPolicy())
    newSecurityManager( None, UnitTestUser().__of__( self.root ) )
    self.root.stuff = 'stuff here'
    self.failUnlessRaises(Unauthorized,
                          self.root.folder1.restrictedTraverse, 'stuff')
</t>
<t tx="ekr.20040104185913.3244">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestTraverse ) )
    return suite
</t>
<t tx="ekr.20040104185913.3245">def main():
    unittest.main(defaultTest='test_suite')
</t>
<t tx="ekr.20040104185913.3246"></t>
<t tx="ekr.20040104185913.3247">&lt;&lt; copyright &gt;&gt;

"""Python implementation of persistent list.

$Id: PersistentList.py,v 1.3 2002/08/14 22:07:09 mj Exp $"""

__version__='$Revision: 1.3 $'[11:-2]

import Persistence
from UserList import UserList

class PersistentList(UserList, Persistence.Persistent):
	&lt;&lt; class PersistentList declarations &gt;&gt;
	@others</t>
<t tx="ekr.20040104185913.3250">__super_setitem = UserList.__setitem__
__super_delitem = UserList.__delitem__
__super_setslice = UserList.__setslice__
__super_delslice = UserList.__delslice__
__super_iadd = UserList.__iadd__
__super_imul = UserList.__imul__
__super_append = UserList.append
__super_insert = UserList.insert
__super_pop = UserList.pop
__super_remove = UserList.remove
__super_reverse = UserList.reverse
__super_sort = UserList.sort
__super_extend = UserList.extend</t>
<t tx="ekr.20040104185913.3251">def __setitem__(self, i, item):
    self.__super_setitem(i, item)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3252">def __delitem__(self, i):
    self.__super_delitem(i)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3253">def __setslice__(self, i, j, other):
    self.__super_setslice(i, j, other)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3254">def __delslice__(self, i, j):
    self.__super_delslice(i, j)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3255">def __iadd__(self, other):
    self.__super_iadd(other)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3256">def __imul__(self, n):
    self.__super_imul(n)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3257">def append(self, item):
    self.__super_append(item)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3258">def insert(self, i, item):
    self.__super_insert(i, item)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3259">def pop(self, i=-1):
    rtn = self.__super_pop(i)
    self._p_changed = 1
    return rtn
</t>
<t tx="ekr.20040104185913.3260">def remove(self, item):
    self.__super_remove(item)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3261">def reverse(self):
    self.__super_reverse()
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3262">def sort(self, *args):
    self.__super_sort(*args)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3263">def extend(self, other):
    self.__super_extend(other)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3264"># This works around a bug in Python 2.1.x (up to 2.1.2 at least) where the
# __cmp__ bogusly raises a RuntimeError, and because this is an extension
# class, none of the rich comparison stuff works anyway.
def __cmp__(self, other):
    return cmp(self.data, self._UserList__cast(other))
</t>
<t tx="ekr.20040104185913.3265">&lt;&lt; copyright &gt;&gt;

"""Python implementation of persistent base types

$Id: PersistentMapping.py,v 1.20 2002/08/14 22:07:09 mj Exp $"""

__version__='$Revision: 1.20 $'[11:-2]

import Persistence
from UserDict import UserDict

class PersistentMapping(UserDict, Persistence.Persistent):
    """A persistent wrapper for mapping objects.

    This class allows wrapping of mapping objects so that object
    changes are registered.  As a side effect, mapping objects may be
    subclassed.

    A subclass of PersistentMapping or any code that adds new
    attributes should not create an attribute named _container.  This
    is reserved for backwards compatibility reasons.
    """
	&lt;&lt; class PersistentMapping declarations &gt;&gt;

	@others</t>
<t tx="ekr.20040104185913.3268"># UserDict provides all of the mapping behavior.  The
# PersistentMapping class is responsible marking the persistent
# state as changed when a method actually changes the state.  At
# the mapping API evolves, we may need to add more methods here.

__super_delitem = UserDict.__delitem__
__super_setitem = UserDict.__setitem__
__super_clear = UserDict.clear
__super_update = UserDict.update
__super_setdefault = UserDict.setdefault</t>
<t tx="ekr.20040104185913.3269">def __delitem__(self, key):
    self.__super_delitem(key)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3270">def __setitem__(self, key, v):
    self.__super_setitem(key, v)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3271">def clear(self):
    self.__super_clear()
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3272">def update(self, b):
    self.__super_update(b)
    self._p_changed = 1
</t>
<t tx="ekr.20040104185913.3273">def setdefault(self, key, failobj=None):
    # We could inline all of UserDict's implementation into the
    # method here, but I'd rather not depend at all on the
    # implementation in UserDict (simple as it is).
    if not self.has_key(key):
        self._p_changed = 1
    return self.__super_setdefault(key, failobj)
</t>
<t tx="ekr.20040104185913.3274">try:
    __super_popitem = UserDict.popitem
except AttributeError:
    pass
else:
    def popitem(self):
        self._p_changed = 1
        return self.__super_popitem()
</t>
<t tx="ekr.20040104185913.3275"># If the internal representation of PersistentMapping changes,
# it causes compatibility problems for pickles generated by
# different versions of the code.  Compatibility works in both
# directions, because an application may want to share a database
# between applications using different versions of the code.

# Effectively, the original rep is part of the "API."  To provide
# full compatibility, the getstate and setstate must read and
# right objects using the old rep.

# As a result, the PersistentMapping must save and restore the
# actual internal dictionary using the name _container.

def __getstate__(self):
    state = {}
    state.update(self.__dict__)
    state['_container'] = state['data']
    del state['data']
    return state
</t>
<t tx="ekr.20040104185913.3276">def __setstate__(self, state):
    if state.has_key('_container'):
        self.data = state['_container']
        del state['_container']
    elif not state.has_key('data'):
        self.data = {}
    self.__dict__.update(state)
</t>
<t tx="ekr.20040104185913.3277">&lt;&lt; copyright &gt;&gt;

"""Provide access to Persistent and PersistentMapping

This avoids dependency on the database package name.

While obviously there is nothing in this module, the correct names are
inserted by the __init__.py in ZODB, jumpstarting the process.
"""
</t>
<t tx="ekr.20040104185913.3278">@language c

&lt;&lt; c copyright &gt;&gt;

static char cPersistence_doc_string[] = 
"Defines Persistent mixin class for persistent objects.\n"
"\n"
"$Id: cPersistence.c,v 1.62.10.3 2003/01/30 23:25:13 bwarsaw Exp $\n";

#include "cPersistence.h"

&lt;&lt; cPersistence declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.3280">struct ccobject_head_struct {
    CACHE_HEAD
};

#define ASSIGN(V,E) {PyObject *__e; __e=(E); Py_XDECREF(V); (V)=__e;}
#define UNLESS(E) if(!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E) UNLESS(V)
#define OBJECT(V) ((PyObject*)(V))

static PyObject *py_keys, *py_setstate, *py___dict__, *py_timeTime;
static PyObject *py__p_changed, *py__p_deactivate;
static PyObject *py___getattr__, *py___setattr__, *py___delattr__;

static PyObject *TimeStamp;</t>
<t tx="ekr.20040104185913.3281">#ifdef DEBUG_LOG

static PyObject *debug_log=0;
static int idebug_log=0;

static void *
call_debug(char *event, cPersistentObject *self)
{
  PyObject *r;

  /*
  printf("%s %p\n",event,self-&gt;ob_type-&gt;tp_name);
  */
  r=PyObject_CallFunction(debug_log,"s(sOi)",event,
			  self-&gt;ob_type-&gt;tp_name, self-&gt;oid,
			  self-&gt;state);
  Py_XDECREF(r);
}

#endif</t>
<t tx="ekr.20040104185913.3282">static int
init_strings(void)
{
#define INIT_STRING(S) if (! (py_ ## S = PyString_FromString(#S))) return -1;
  INIT_STRING(keys);
  INIT_STRING(setstate);
  INIT_STRING(timeTime);
  INIT_STRING(__dict__);
  INIT_STRING(_p_changed);
  INIT_STRING(_p_deactivate);
  INIT_STRING(__getattr__);
  INIT_STRING(__setattr__);
  INIT_STRING(__delattr__);
#undef INIT_STRING
  return 0;
}
</t>
<t tx="ekr.20040104185913.3283">static int
checknoargs(PyObject *args)
{
  if (!PyTuple_Check(args))
    return 0;
  if (PyTuple_GET_SIZE(args) != 0) {
    PyErr_Format(PyExc_TypeError, 
		 "function takes exactly 0 arguments (%d given)",
		 PyTuple_GET_SIZE(args));
    return 0;
  }
  return 1;
}
</t>
<t tx="ekr.20040104185913.3284">static PyObject *
callmethod(PyObject *self, PyObject *name)
{
  self=PyObject_GetAttr(self,name);
  if (self)
    ASSIGN(self,PyObject_CallObject(self,NULL));
  return self;
}
</t>
<t tx="ekr.20040104185913.3285">static PyObject *
callmethod1(PyObject *self, PyObject *name, PyObject *arg)
{
  self = PyObject_GetAttr(self, name);
  UNLESS(self) return NULL;
  name = PyTuple_New(1);
  UNLESS(name) 
    {
      Py_DECREF(self);
      return NULL;
    }
  PyTuple_SET_ITEM(name, 0, arg);
  ASSIGN(self, PyObject_CallObject(self, name));
  PyTuple_SET_ITEM(name, 0, NULL);
  Py_DECREF(name);
  return self;
}
</t>
<t tx="ekr.20040104185913.3286">static void ghostify(cPersistentObject*);

/* Load the state of the object, unghostifying it.  Upon success, return 1.
 * If an error occurred, re-ghostify the object and return 0.
 */
static int
unghostify(cPersistentObject *self)
{
    if (self-&gt;state &lt; 0 &amp;&amp; self-&gt;jar) {
        PyObject *r;

        /* XXX Is it ever possibly to not have a cache? */
        if (self-&gt;cache) {
	    CPersistentRing *home = &amp;self-&gt;cache-&gt;ring_home;
            /* Create a node in the ring for this unghostified object. */
            self-&gt;cache-&gt;non_ghost_count++;
            self-&gt;ring.next = home;
            self-&gt;ring.prev = home-&gt;prev;
	    home-&gt;prev-&gt;next = &amp;self-&gt;ring;
	    home-&gt;prev = &amp;self-&gt;ring;
            Py_INCREF(self);
        }
        self-&gt;state = cPersistent_CHANGED_STATE;
        /* Call the object's __setstate__() */
        r = callmethod1(self-&gt;jar, py_setstate, (PyObject*)self);
        if (r == NULL) {
            ghostify(self);
            return 0;
        }
        self-&gt;state = cPersistent_UPTODATE_STATE;
        Py_DECREF(r);
    }
    return 1;
}
</t>
<t tx="ekr.20040104185913.3287">staticforward PyExtensionClass Pertype;

static void
accessed(cPersistentObject *self)
{
    /* Do nothing unless the object is in a cache and not a ghost. */
    if (self-&gt;cache &amp;&amp; self-&gt;state &gt;= 0) {
	CPersistentRing *home = &amp;self-&gt;cache-&gt;ring_home;
	self-&gt;ring.prev-&gt;next = self-&gt;ring.next;
	self-&gt;ring.next-&gt;prev = self-&gt;ring.prev;
	self-&gt;ring.next = home;
	self-&gt;ring.prev = home-&gt;prev;
	home-&gt;prev-&gt;next = &amp;self-&gt;ring;
	home-&gt;prev = &amp;self-&gt;ring; 
    }
}
</t>
<t tx="ekr.20040104185913.3288">static void
ghostify(cPersistentObject *self)
{
    /* are we already a ghost? */
    if (self-&gt;state == cPersistent_GHOST_STATE)
        return;
    /* XXX is it ever possible to not have a cache? */
    if (self-&gt;cache == NULL) {
        self-&gt;state = cPersistent_GHOST_STATE;
        return;
    }
    /* if we're ghostifying an object, we better have some non-ghosts */
    assert(self-&gt;cache-&gt;non_ghost_count &gt; 0);

    self-&gt;cache-&gt;non_ghost_count--;
    self-&gt;ring.next-&gt;prev = self-&gt;ring.prev;
    self-&gt;ring.prev-&gt;next = self-&gt;ring.next;
    self-&gt;ring.prev = NULL;
    self-&gt;ring.next = NULL;
    self-&gt;state = cPersistent_GHOST_STATE;

    /* We remove the reference to the just ghosted object that the ring
     * holds.  Note that the dictionary of oids-&gt;objects has an uncounted
     * reference, so if the ring's reference was the only one, this frees
     * the ghost object.  Note further that the object's dealloc knows to
     * inform the dictionary that it is going away.
     */
    Py_DECREF(self);
}
</t>
<t tx="ekr.20040104185913.3289">static void
deallocated(cPersistentObject *self)
{
    if (self-&gt;state &gt;= 0) 
	ghostify(self);
    if (self-&gt;cache) {
	/* XXX This function shouldn't be able to fail? If not, maybe
	   it shouldn't set an exception either.
	*/
	if (cPersistenceCAPI-&gt;percachedel(self-&gt;cache, self-&gt;oid) &lt; 0)
	    PyErr_Clear(); /* I don't think this should ever happen */
    }
    Py_XDECREF(self-&gt;jar);
    Py_XDECREF(self-&gt;oid);
}
</t>
<t tx="ekr.20040104185913.3290">static int
changed(cPersistentObject *self)
{
  if ((self-&gt;state == cPersistent_UPTODATE_STATE ||
       self-&gt;state == cPersistent_STICKY_STATE)
       &amp;&amp; self-&gt;jar)
    {
	PyObject *meth, *arg, *result;
	static PyObject *s_register;

	if (s_register == NULL) 
	    s_register = PyString_InternFromString("register");
	meth = PyObject_GetAttr((PyObject *)self-&gt;jar, s_register);
	if (meth == NULL)
	    return -1;
	arg = PyTuple_New(1);
	if (arg == NULL) {
	    Py_DECREF(meth);
	    return -1;
	}
	PyTuple_SET_ITEM(arg, 0, (PyObject *)self);
	result = PyEval_CallObject(meth, arg);
	PyTuple_SET_ITEM(arg, 0, NULL);
	Py_DECREF(arg);
	Py_DECREF(meth);
	if (result == NULL)
	    return -1;
	Py_DECREF(result);

	self-&gt;state = cPersistent_CHANGED_STATE;
    }

  return 0;
}
</t>
<t tx="ekr.20040104185913.3291">static PyObject *
Per___changed__(cPersistentObject *self, PyObject *args)
{
    PyObject *v = NULL;

    if (args &amp;&amp; !PyArg_ParseTuple(args, "|O:__changed__", &amp;v)) 
	return NULL;
    if (!v) 
	return PyObject_GetAttr(OBJECT(self), py__p_changed);

    if (PyObject_IsTrue(v)) {
	if (changed(self) &lt; 0) 
	    return NULL;
    }
    else if (self-&gt;state &gt;= 0) 
	self-&gt;state = cPersistent_UPTODATE_STATE;

    Py_INCREF(Py_None);
    return Py_None;
}
</t>
<t tx="ekr.20040104185913.3292">static PyObject *
Per__p_deactivate(cPersistentObject *self, PyObject *args)
{
  PyObject *dict,*dict2=NULL;

#ifdef DEBUG_LOG
  if (idebug_log &lt; 0) call_debug("reinit",self);
#endif

  if (args &amp;&amp; !checknoargs(args))
    return NULL;

  if (self-&gt;state==cPersistent_UPTODATE_STATE &amp;&amp; self-&gt;jar &amp;&amp;
      HasInstDict(self) &amp;&amp; (dict=INSTANCE_DICT(self)))
    {
      dict2 = PyDict_Copy(dict);
      PyDict_Clear(dict);
      /* Note that we need to set to ghost state unless we are 
	 called directly. Methods that override this need to
         do the same! */
      ghostify(self);
    }

  /* need to delay releasing the last reference on instance attributes
     until after we have finished accounting for losing our state */
  if (dict2)
  {
      PyDict_Clear(dict2);
      Py_DECREF(dict2);
  }

  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.3293">@ Load the object's state if necessary and become sticky
@c

static int
Per_setstate(cPersistentObject *self)
{
    if (!unghostify(self))
        return -1;
    self-&gt;state = cPersistent_STICKY_STATE;
    return 0;
}
</t>
<t tx="ekr.20040104185913.3294">static PyObject *
Per__getstate__(cPersistentObject *self, PyObject *args)
{
    PyObject *__dict__, *d=0;

    if (!checknoargs(args))
        return NULL;

#ifdef DEBUG_LOG
    if (idebug_log &lt; 0)
        call_debug("get",self);
#endif

    if (!unghostify(self))
        return NULL;

    if (HasInstDict(self) &amp;&amp; (__dict__=INSTANCE_DICT(self))) {
        PyObject *k, *v;
        int pos;
        char *ck;
	  
        for(pos=0; PyDict_Next(__dict__, &amp;pos, &amp;k, &amp;v); ) {
            if (PyString_Check(k) &amp;&amp; (ck=PyString_AS_STRING(k)) &amp;&amp;
               (*ck=='_' &amp;&amp; ck[1]=='v' &amp;&amp; ck[2]=='_'))
	    {
                if ((d=PyDict_New()) == NULL)
                    goto err;
                
                for (pos=0; PyDict_Next(__dict__, &amp;pos, &amp;k, &amp;v); )
                    UNLESS(PyString_Check(k) &amp;&amp; (ck=PyString_AS_STRING(k)) &amp;&amp;
                           (*ck=='_' &amp;&amp; ck[1]=='v' &amp;&amp; ck[2]=='_'))
                    {
                        if (PyDict_SetItem(d,k,v) &lt; 0)
                            goto err;
                    }
                return d;
	    }
	}
    }
    else
        __dict__ = Py_None;

    Py_INCREF(__dict__);
    return __dict__;
  err:
    Py_XDECREF(d);
    return NULL;
}</t>
<t tx="ekr.20040104185913.3295">static PyObject *
Per__setstate__(cPersistentObject *self, PyObject *args)
{
  PyObject *__dict__, *v, *keys=0, *key=0, *e=0;
  int l, i;

  if (HasInstDict(self))
    {

       UNLESS(PyArg_ParseTuple(args, "O", &amp;v)) return NULL;
#ifdef DEBUG_LOG
       if (idebug_log &lt; 0) call_debug("set",self);
#endif
       if (v!=Py_None)
	 {
	   __dict__=INSTANCE_DICT(self);
	   
	   if (PyDict_Check(v))
	     {
	       for(i=0; PyDict_Next(v, &amp;i, &amp;key, &amp;e);)
		 if (PyDict_SetItem(__dict__, key, e) &lt; 0)
		   return NULL;
	     }
	   else
	     {
	       UNLESS(keys=callmethod(v,py_keys)) goto err;
	       UNLESS(-1 != (l=PyObject_Length(keys))) goto err;
	       
	       for(i=0; i &lt; l; i++)
		 {
		   UNLESS_ASSIGN(key,PySequence_GetItem(keys,i)) goto err;
		   UNLESS_ASSIGN(e,PyObject_GetItem(v,key)) goto err;
		   UNLESS(-1 != PyDict_SetItem(__dict__,key,e)) goto err;
		 }
	       
	       Py_XDECREF(key);
	       Py_XDECREF(e);
	       Py_DECREF(keys);
	     }
	 }
    }
  Py_INCREF(Py_None);
  return Py_None;
err:
  Py_XDECREF(key);
  Py_XDECREF(e);
  Py_XDECREF(keys);
  return NULL;
}</t>
<t tx="ekr.20040104185913.3296">static struct PyMethodDef Per_methods[] = {
  {"__changed__",	(PyCFunction)Per___changed__,	METH_VARARGS,
   "DEPRECATED: use self._p_changed=1"},
  {"_p_deactivate",	(PyCFunction)Per__p_deactivate,	METH_VARARGS,
   "_p_deactivate(oid) -- Deactivate the object"},
  {"__getstate__",	(PyCFunction)Per__getstate__,	METH_VARARGS,
   "__getstate__() -- Return the state of the object" },
  {"__setstate__",	(PyCFunction)Per__setstate__,	METH_VARARGS,
   "__setstate__(v) -- Restore the saved state of the object from v" },
  
  {NULL,		NULL}		/* sentinel */
};

/* ---------- */

static void
Per_dealloc(cPersistentObject *self)
{
#ifdef DEBUG_LOG
  if (idebug_log &lt; 0) call_debug("del",self);
#endif
  deallocated(self);
  Py_XDECREF(self-&gt;cache);
  Py_DECREF(self-&gt;ob_type);
  PyObject_DEL(self);
}
</t>
<t tx="ekr.20040104185913.3297">static PyObject *
orNothing(PyObject *v)
{
  if (! v) v=Py_None;
  Py_INCREF(v);
  return v;
}
</t>
<t tx="ekr.20040104185913.3298">static PyObject *
Per_getattr(cPersistentObject *self, PyObject *oname, char *name,
	 PyObject *(*getattrf)(PyObject *, PyObject*))
{
  char *n=name;

  if (n &amp;&amp; *n++=='_')
    if (*n++=='p' &amp;&amp; *n++=='_')
      {
	switch(*n++)
	  {
	  case 'o':
	    if (*n++=='i' &amp;&amp; *n++=='d' &amp;&amp; ! *n) return orNothing(self-&gt;oid);
	    break;
	  case 'j':
	    if (*n++=='a' &amp;&amp; *n++=='r' &amp;&amp; ! *n) return orNothing(self-&gt;jar);
	    break;
	  case 'c':
	    if (strcmp(n,"hanged")==0)
	      {
		if (self-&gt;state &lt; 0)
		  {
		    Py_INCREF(Py_None);
		    return Py_None;
		  }
		return PyInt_FromLong(self-&gt;state ==
				      cPersistent_CHANGED_STATE);
	      }
	    break;
	  case 's':
	    if (strcmp(n,"erial")==0)
	      return PyString_FromStringAndSize(self-&gt;serial, 8);
	    if (strcmp(n,"elf")==0) 
	      return orNothing(OBJECT(self));
	    break;
	  case 'm':
	    if (strcmp(n,"time")==0)
	      {
                  if (!unghostify(self))
                      return NULL;

		accessed(self);

		if (self-&gt;serial[7]=='\0' &amp;&amp; self-&gt;serial[6]=='\0' &amp;&amp;
		    self-&gt;serial[5]=='\0' &amp;&amp; self-&gt;serial[4]=='\0' &amp;&amp;
		    self-&gt;serial[3]=='\0' &amp;&amp; self-&gt;serial[2]=='\0' &amp;&amp;
		    self-&gt;serial[1]=='\0' &amp;&amp; self-&gt;serial[0]=='\0')
		  {
		    Py_INCREF(Py_None);
		    return Py_None;
		  }
		
		oname=PyString_FromStringAndSize(self-&gt;serial, 8);
		if (! oname) return oname;

		ASSIGN(oname, PyObject_CallFunction(TimeStamp, "O", oname));
		if (! oname) return oname;
		ASSIGN(oname, PyObject_GetAttr(oname, py_timeTime));
		if (! oname) return oname;
		ASSIGN(oname, PyObject_CallObject(oname, NULL));
		return oname;
	      }
	    break;
	  }

	return getattrf((PyObject *)self, oname);
      }
  if (! (name &amp;&amp; *name++=='_' &amp;&amp; *name++=='_' &amp;&amp;
	(strcmp(name,"dict__")==0 || strcmp(name,"class__")==0
	 || strcmp(name, "of__")==0)))
    {
        if (!unghostify(self))
            return NULL;

      accessed(self);
    }

  return getattrf((PyObject *)self, oname);
}
</t>
<t tx="ekr.20040104185913.3299">static PyObject*
Per_getattro(cPersistentObject *self, PyObject *name)
{
  char *s=NULL;
  PyObject *r;

  if (PyString_Check(name))
    UNLESS(s=PyString_AS_STRING(name)) return NULL;

  r = Per_getattr(self, name, s, PyExtensionClassCAPI-&gt;getattro);
  if (! r &amp;&amp; self-&gt;state != cPersistent_GHOST_STATE &amp;&amp;
      (((PyExtensionClass*)(self-&gt;ob_type))-&gt;class_flags 
       &amp; EXTENSIONCLASS_USERGETATTR_FLAG)
      )
    {
      PyErr_Clear();

      r=PyObject_GetAttr(OBJECT(self), py___getattr__);
      if (r) 
	{
	  ASSIGN(r, PyObject_CallFunction(r, "O", name));
	}
      else PyErr_SetObject(PyExc_AttributeError, name);
    }
 
  return r;  
}
</t>
<t tx="ekr.20040104185913.3300">static int
_setattro(cPersistentObject *self, PyObject *oname, PyObject *v,
	     int (*setattrf)(PyObject *, PyObject*, PyObject*))
{
  char *name = "";

  if (oname == NULL)
      return -1;
  if (!PyString_Check(oname)) 
      return -1;
  name = PyString_AS_STRING(oname);
  if (name == NULL)
      return -1;
	
  if (*name == '_' &amp;&amp; name[1] == 'p' &amp;&amp; name[2] == '_') {
      if (strcmp(name + 3, "oid") == 0) {
	  if (self-&gt;cache) {
	      int result;
	      if (v == NULL) {
		  PyErr_SetString(PyExc_ValueError,
				  "can not delete oid of cached object");
		  return -1;
	      }
	      if (PyObject_Cmp(self-&gt;oid, v, &amp;result) &lt; 0)
		  return -1;
	      if (result) {
		  PyErr_SetString(PyExc_ValueError,
				  "can not change oid of cached object");
		  return -1;
	      }
	  }
	  Py_XINCREF(v);
	  ASSIGN(self-&gt;oid, v);
	  return 0;
      }
      else if (strcmp(name + 3, "jar") == 0) {
	  if (self-&gt;cache &amp;&amp; self-&gt;jar) {
	      int result;
	      if (v == NULL) {
		  PyErr_SetString(PyExc_ValueError,
				  "can not delete jar of cached object");
		  return -1;
	      }
	      if (PyObject_Cmp(self-&gt;jar, v, &amp;result) &lt; 0)
		  return -1;
	      if (result) {
		  PyErr_SetString(PyExc_ValueError,
				  "can not change jar of cached object");
		  return -1;
	      }
	  }
	  Py_XINCREF(v);
	  ASSIGN(self-&gt;jar, v);
	  return 0;
      }
      else if (strcmp(name + 3, "serial") == 0) {
	  if (v) {
	      if (PyString_Check(v) &amp;&amp; PyString_GET_SIZE(v) == 8)
		  memcpy(self-&gt;serial, PyString_AS_STRING(v), 8);
	      else {
		  PyErr_SetString(PyExc_ValueError,
				  "_p_serial must be an 8-character string");
		  return -1;
	      }
	  } else 
	      memset(self-&gt;serial, 0, 8);
	  return 0;
      }
      else if (strcmp(name+3, "changed") == 0) {
	  int deactivate = 0;
	  if (!v)
	    {
	      /* delatter is used to invalidate the object
	         *even* if it has changed.
	       */
	      if (self-&gt;state != cPersistent_GHOST_STATE)
		self-&gt;state = cPersistent_UPTODATE_STATE;
	      deactivate = 1;
	    }
	  else if (v == Py_None)
	      deactivate = 1;
	  if (deactivate)
	    {
	      PyObject *res;
	      PyObject *meth = PyObject_GetAttr(OBJECT(self), 
						py__p_deactivate);
	      if (meth == NULL)
		  return -1;
	      res = PyObject_CallObject(meth, NULL);
	      if (res) {
		  Py_DECREF(res);
	      } 
	      else {
		  /* an error occured in _p_deactivate().  

		  It's not clear what we should do here.  The code is
		  obviously ignoring the exception, but it shouldn't
		  return 0 for a getattr and set an exception.  The
		  simplest change is to clear the exception, but that
		  simply masks the error. 

		  XXX We'll print an error to stderr just like
		  exceptions in __del__().  It would probably be
		  better to log it but that would be painful from C.
		  */
		  PyErr_WriteUnraisable(meth);
	      }
	      Py_DECREF(meth);
	      return 0;
	    }
	  if (PyObject_IsTrue(v)) return changed(self);
	  if (self-&gt;state &gt;= 0) self-&gt;state=cPersistent_UPTODATE_STATE;
	  return 0;
	}
    }
  else
    {
        if (!unghostify(self))
            return -1;
      
      accessed(self);

      if ((! (*name=='_' &amp;&amp; name[1]=='v' &amp;&amp; name[2]=='_'))
	 &amp;&amp; (self-&gt;state != cPersistent_CHANGED_STATE &amp;&amp; self-&gt;jar)
	 &amp;&amp; setattrf
	 )
	if (changed(self) &lt; 0) return -1;
    }

  if (setattrf)
    return setattrf((PyObject*)self,oname,v);
  
  return 1;			/* Ready for user setattr */
}
</t>
<t tx="ekr.20040104185913.3301">static int
Per_setattro(cPersistentObject *self, PyObject *oname, PyObject *v)
{
  int r;
  PyObject *m;

  if (v &amp;&amp; (((PyExtensionClass*)self-&gt;ob_type)-&gt;class_flags 
	    &amp; EXTENSIONCLASS_USERSETATTR_FLAG))
    {
      r = _setattro(self, oname, v, NULL);
      if (r &lt; 1) return r;

      m=PyObject_GetAttr(OBJECT(self), py___setattr__);
      if (m) 
	{
	  ASSIGN(m, PyObject_CallFunction(m, "OO", oname, v));
	}
      else PyErr_SetObject(PyExc_AttributeError, oname);
    }
  else if (!v &amp;&amp; (((PyExtensionClass*)self-&gt;ob_type)-&gt;class_flags 
		  &amp; EXTENSIONCLASS_USERDELATTR_FLAG)
	   )
    {
      r=_setattro(self,oname, v, NULL);
      if (r &lt; 1) return r;

      m=PyObject_GetAttr(OBJECT(self), py___delattr__);
      if (m) 
      {
	ASSIGN(m, PyObject_CallFunction(m, "O", oname));
      }
      else PyErr_SetObject(PyExc_AttributeError, oname);
    }
  else
    return _setattro(self,oname, v, PyExtensionClassCAPI-&gt;setattro);

  if (m) 
    {
      Py_DECREF(m);
      return 0;
    }
  
  return -1;
}
</t>
<t tx="ekr.20040104185913.3302">static PyExtensionClass Pertype = {
	PyObject_HEAD_INIT(NULL)
	0,				/*ob_size*/
	"Persistent",			/*tp_name*/
	sizeof(cPersistentObject),	/*tp_basicsize*/
	0,				/*tp_itemsize*/
	/* methods */
	(destructor)Per_dealloc,	/*tp_dealloc*/
	(printfunc)0,			/*tp_print*/
	(getattrfunc)0,			/*tp_getattr*/
	(setattrfunc)0,	       		/*tp_setattr*/
	(cmpfunc)0,			/*tp_compare*/
	(reprfunc)0,			/*tp_repr*/
	0,				/*tp_as_number*/
	0,				/*tp_as_sequence*/
	0,				/*tp_as_mapping*/
	(hashfunc)0,			/*tp_hash*/
	(ternaryfunc)0,			/*tp_call*/
	(reprfunc)0,			/*tp_str*/
	(getattrofunc)Per_getattro,	/*tp_getattr with object key*/
	(setattrofunc)Per_setattro,	/*tp_setattr with object key*/
	/* Space for future expansion */
	0L,0L,
        "Base class for objects that are stored in their own database records",
	METHOD_CHAIN(Per_methods),
	PERSISTENCE_FLAGS,
};

static PyExtensionClass Overridable = {
	PyObject_HEAD_INIT(NULL)
	0,				/*ob_size*/
	"Overridable",			/*tp_name*/
	sizeof(cPersistentObject),	/*tp_basicsize*/
	0,				/*tp_itemsize*/
	/* methods */
	(destructor)Per_dealloc,	/*tp_dealloc*/
	(printfunc)0,			/*tp_print*/
	(getattrfunc)0,			/*tp_getattr*/
	(setattrfunc)0,	       		/*tp_setattr*/
	(cmpfunc)0,			/*tp_compare*/
	(reprfunc)0,			/*tp_repr*/
	0,				/*tp_as_number*/
	0,				/*tp_as_sequence*/
	0,				/*tp_as_mapping*/
	(hashfunc)0,			/*tp_hash*/
	(ternaryfunc)0,			/*tp_call*/
	(reprfunc)0,			/*tp_str*/
	(getattrofunc)Per_getattro,	/*tp_getattr with object key*/
	(setattrofunc)Per_setattro,	/*tp_setattr with object key*/
	/* Space for future expansion */
	0L,0L,
        "Hacked base class used in Zope's App.Uninstalled.BrokenClass\n\n"
        "Not sure if this is still needed",
	METHOD_CHAIN(Per_methods),
	EXTENSIONCLASS_BASICNEW_FLAG | PERSISTENT_TYPE_FLAG
};

/* End of code for Persistent objects */
/* -------------------------------------------------------- */

/* List of methods defined in the module */

#ifdef DEBUG_LOG
static PyObject *
set_debug_log(PyObject *ignored, PyObject *args)
{
  Py_INCREF(args);
  ASSIGN(debug_log, args);
  if (debug_log) idebug_log=-1;
  else idebug_log=0;
  Py_INCREF(Py_None);
  return Py_None;
}
#endif
</t>
<t tx="ekr.20040104185913.3303">static struct PyMethodDef cP_methods[] = {
#ifdef DEBUG_LOG
  {"set_debug_log", (PyCFunction)set_debug_log, METH_VARARGS,
   "set_debug_log(callable) -- Provide a function to log events\n"
   "\n"
   "The function will be called with an event name and a persistent object.\n"
  },
#endif
  {NULL,		NULL}		/* sentinel */
};

/* Initialization function for the module (*must* be called initcPersistence) */

typedef int (*intfunctionwithpythonarg)(PyObject*);

static cPersistenceCAPIstruct
truecPersistenceCAPI = {
  &amp;(Pertype.methods),
  (getattrofunc)Per_getattro,	/*tp_getattr with object key*/
  (setattrofunc)Per_setattro,	/*tp_setattr with object key*/
  changed,
  accessed,
  ghostify,
  deallocated,
  (intfunctionwithpythonarg)Per_setstate,
  (pergetattr)Per_getattr,
  (persetattr)_setattro,
  NULL /* The percachedel slot is initialized in cPickleCache.c when
          the module is loaded.  It uses a function in a different
          shared library. */
};

void
initcPersistence(void)
{
  PyObject *m, *d, *s;

  s = PyString_FromString("ZODB.TimeStamp");
  if (s == NULL)
      return;
  m = PyImport_Import(s);
  if (m == NULL) {
      Py_DECREF(s);
      return;
  }
  TimeStamp = PyObject_GetAttrString(m, "TimeStamp");
  assert(TimeStamp);
  Py_DECREF(m);
  Py_DECREF(s);

  if (init_strings() &lt; 0) 
      return;

  m = Py_InitModule4("cPersistence", cP_methods, cPersistence_doc_string,
		     (PyObject*)NULL, PYTHON_API_VERSION);

  
  d = PyModule_GetDict(m);

  PyExtensionClass_Export(d, "Persistent",  Pertype);
  PyExtensionClass_Export(d, "Overridable", Overridable);

  cPersistenceCAPI = &amp;truecPersistenceCAPI;
  s = PyCObject_FromVoidPtr(cPersistenceCAPI, NULL);
  PyDict_SetItemString(d, "CAPI", s);
  Py_XDECREF(s);
}
</t>
<t tx="ekr.20040104185913.3304">@language c

&lt;&lt; copyright &gt;&gt;

&lt;&lt; documentation &gt;&gt;

static char cPickleCache_doc_string[] =
"Defines the PickleCache used by ZODB Connection objects.\n"
"\n"
"$Id: cPickleCache.c,v 1.68.10.3 2003/04/30 17:03:34 jeremy Exp $\n";

#define ASSIGN(V,E) {PyObject *__e; __e=(E); Py_XDECREF(V); (V)=__e;}
#define UNLESS(E) if(!(E))
#define UNLESS_ASSIGN(V,E) ASSIGN(V,E) UNLESS(V)
#define OBJECT(O) ((PyObject*)O)

#define DONT_USE_CPERSISTENCECAPI

&lt;&lt; cPickleCache #includes &gt;&gt;
&lt;&lt; cPickleCache declarations &gt;&gt;

@others</t>
<t tx="ekr.20040104185913.3305">#include "cPersistence.h"
#include &lt;time.h&gt;
#include &lt;stddef.h&gt;

#undef Py_FindMethod

static PyObject *py__p_oid, *py_reload, *py__p_jar, *py__p_changed;

/* Do we want 'engine noise'.... abstract debugging output useful for
   visualizing cache behavior */
#if 0
#define ENGINE_NOISE(A) printf(A)
#else
#define ENGINE_NOISE(A) ((void)A)
#endif</t>
<t tx="ekr.20040104185913.3306">/* This object is the pickle cache.  The CACHE_HEAD macro guarantees
   that layout of this struct is the same as the start of
   ccobject_head in cPersistence.c */
typedef struct {
    CACHE_HEAD
    int klass_count;                         /* count of persistent classes */
    PyObject *data;                          /* oid -&gt; object dict */
    PyObject *jar;                           /* Connection object */
    PyObject *setklassstate;                 /* ??? */
    int cache_size;                          /* target number of items in cache */

    /* Most of the time the ring contains only:
       * many nodes corresponding to persistent objects
       * one 'home' node from the cache.
    In some cases it is handy to temporarily add other types
    of node into the ring as placeholders. 'ring_lock' is a boolean
    indicating that someone has already done this. Currently this
    is only used by the garbage collection code. */

    int ring_lock;

    /* 'cache_drain_resistance' controls how quickly the cache size will drop
    when it is smaller than the configured size. A value of zero means it will
    not drop below the configured size (suitable for most caches). Otherwise,
    it will remove cache_non_ghost_count/cache_drain_resistance items from
    the cache every time (suitable for rarely used caches, such as those
    associated with Zope versions. */

    int cache_drain_resistance;

} ccobject;

static int cc_ass_sub(ccobject *self, PyObject *key, PyObject *v);</t>
<t tx="ekr.20040104185913.3307">#define IS_RING_CORRUPT(OBJ, CTX) ring_corrupt((OBJ), (CTX))
#define OBJECT_FROM_RING(SELF, HERE, CTX) \
object_from_ring((SELF), (HERE), (CTX))

static cPersistentObject *
object_from_ring(ccobject *self, CPersistentRing *here, const char *context)
{
/* Given a position in the LRU ring, return a borrowed
reference to the object at that point in the ring. The caller is
responsible for ensuring that this ring position really does
correspond to a persistent object, although the debugging
version will double-check this. */

PyObject *object;

/* given a pointer to a ring slot in a cPersistent_HEAD, we want to get
 * the pointer to the Python object that slot is embedded in.
 */
object = (PyObject *)(((char *)here) - offsetof(cPersistentObject, ring));
/* ---------------------------------------------------------------- */

/* define this for extra debugging checks, and lousy performance.
   Not really necessary in production code... disable this before
   release, providing noone has been reporting and RuntimeErrors
   that it uses to report problems.
*/

/* #define MUCH_RING_CHECKING */

#ifdef MUCH_RING_CHECKING
static int present_in_ring(ccobject *self, CPersistentRing *target);
static int ring_corrupt(ccobject *self, const char *context);

if (!PyExtensionInstance_Check(object)) {
    PyErr_Format(PyExc_RuntimeError,
     "Unexpectedly encountered non-ExtensionClass object in %s",
	     context);
    return NULL;
}
if (!(((PyExtensionClass*)(object-&gt;ob_type))-&gt;class_flags &amp; PERSISTENT_TYPE_FLAG)) {
    PyErr_Format(PyExc_RuntimeError,
     "Unexpectedly encountered non-persistent object in %s", context);
    return NULL;
}
if (((cPersistentObject*)object)-&gt;jar != self-&gt;jar) {
    PyErr_Format(PyExc_RuntimeError,
     "Unexpectedly encountered object from a different jar in %s",
	     context);
    return NULL;
}
if (((cPersistentObject *)object)-&gt;cache != (PerCache *)self) {
    PyErr_Format(PyExc_RuntimeError,
	     "Unexpectedly encountered broken ring in %s", context);
    return NULL;
}
return (cPersistentObject *)object;
}

#else /* MUCH_RING_CHECKING */

#define IS_RING_CORRUPT(OBJ, CTX) 0

#define OBJECT_FROM_RING(SELF, HERE, CTX) \
((cPersistentObject *)(((char *)here) - offsetof(cPersistentObject, ring)))

#endif</t>
<t tx="ekr.20040104185913.3308">static int
scan_gc_items(ccobject *self,int target)
{
/* This function must only be called with the ring lock held,
   because it places a non-object placeholder in the ring.
*/

cPersistentObject *object;
int error;
CPersistentRing placeholder;
CPersistentRing *here = self-&gt;ring_home.next;

#ifdef MUCH_RING_CHECKING
int safety_counter = self-&gt;cache_size * 10;
if (safety_counter &lt; 10000) 
safety_counter = 10000;
#endif

/* Scan through the ring until we either find the ring_home (i.e. start
 * of the ring, or we've ghosted enough objects to reach the target
 * size.
 */
while (1) {
    if (IS_RING_CORRUPT(self, "mid-gc")) 
    return -1;

#ifdef MUCH_RING_CHECKING
    if (!safety_counter--) {
        /* This loop has been running for a very long time.  It is
           possible that someone loaded a very large number of objects,
           and now wants us to blow them all away. However it may also
           indicate a logic error. If the loop has been running this
           long then you really have to doubt it will ever terminate.
           In the MUCH_RING_CHECKING build we prefer to raise an
           exception here
        */
        PyErr_SetString(PyExc_RuntimeError,
		    "scan_gc_items safety counter exceeded");
        return -1;
    }

    if (!present_in_ring(self, here)) {
        /* Our current working position is no longer in the ring. 
       That's bad. */ 
        PyErr_SetString(PyExc_RuntimeError,
	    "working position fell out the ring, in scan_gc_items");
        return -1;
    }
#endif

/* back to the home position. stop looking */
    if (here == &amp;self-&gt;ring_home)
        return 0;

    /* At this point we know that the ring only contains nodes
   from persistent objects, plus our own home node. We know
   this because the ring lock is held.  We can safely assume
   the current ring node is a persistent object now we know it
   is not the home */
    object = OBJECT_FROM_RING(self, here, "scan_gc_items");
    if (!object) 
    return -1;

/* we are small enough */
    if (self-&gt;non_ghost_count &lt;= target)
        return 0;
    else if (object-&gt;state == cPersistent_UPTODATE_STATE) {
        /* deactivate it. This is the main memory saver. */

        /* Add a placeholder; a dummy node in the ring.  We need
       to do this to mark our position in the ring.  It is
       possible that the PyObject_SetAttr() call below will
       invoke an __setattr__() hook in Python.  If it does,
       another thread might run; if that thread accesses a
       persistent object and moves it to the head of the ring,
       it might cause the gc scan to start working from the
       head of the list.
    */

        placeholder.next = here-&gt;next;
        placeholder.prev = here;
        here-&gt;next-&gt;prev = &amp;placeholder;
        here-&gt;next = &amp;placeholder;

        ENGINE_NOISE("G");

        /* In Python, "obj._p_changed = None" spells, ghostify */
        error = PyObject_SetAttr((PyObject *)object, py__p_changed, 
			     Py_None);


        /* unlink the placeholder */
        placeholder.next-&gt;prev = placeholder.prev;
        placeholder.prev-&gt;next = placeholder.next;

        here = placeholder.next;

        if (error)
            return -1; /* problem */
    }
    else {
        ENGINE_NOISE(".");
        here = here-&gt;next;
    }
}
}
</t>
<t tx="ekr.20040104185913.3309">static PyObject *
lockgc(ccobject *self, int target_size)
{
    /* This is thread-safe because of the GIL, and there's nothing
     * in between checking the ring_lock and acquiring it that calls back
     * into Python.
     */
    if (self-&gt;ring_lock) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    if (IS_RING_CORRUPT(self, "pre-gc")) 
	return NULL;
    ENGINE_NOISE("&lt;");
    self-&gt;ring_lock = 1;
    if (scan_gc_items(self, target_size)) {
        self-&gt;ring_lock = 0;
        return NULL;
    }
    self-&gt;ring_lock = 0;
    ENGINE_NOISE("&gt;\n");
    if (IS_RING_CORRUPT(self, "post-gc")) 
	return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}
</t>
<t tx="ekr.20040104185913.3310">static PyObject *
cc_incrgc(ccobject *self, PyObject *args)
{
    int n = 1;
    int starting_size = self-&gt;non_ghost_count;
    int target_size = self-&gt;cache_size;

    if (self-&gt;cache_drain_resistance &gt;= 1) {
        /* This cache will gradually drain down to a small size. Check
           a (small) number of objects proportional to the current size */

        int target_size_2 = (starting_size - 1 
			     - starting_size / self-&gt;cache_drain_resistance);
        if (target_size_2 &lt; target_size)
            target_size = target_size_2;
    }

    if (!PyArg_ParseTuple(args, "|i:incrgc", &amp;n)) 
	return NULL;

    return lockgc(self, target_size);
}
</t>
<t tx="ekr.20040104185913.3311">static PyObject *
cc_full_sweep(ccobject *self, PyObject *args)
{
    int dt = 0;
    if (!PyArg_ParseTuple(args, "|i:full_sweep", &amp;dt)) 
	return NULL;
    if (dt == 0)
	return lockgc(self, 0);
    else
	return cc_incrgc(self, args);
}
</t>
<t tx="ekr.20040104185913.3312">static PyObject *
cc_minimize(ccobject *self, PyObject *args)
{
    int ignored;
    if (!PyArg_ParseTuple(args, "|i:minimize", &amp;ignored)) 
	return NULL;
    return lockgc(self, 0);
}
</t>
<t tx="ekr.20040104185913.3313">static void
_invalidate(ccobject *self, PyObject *key)
{
    PyObject *v = PyDict_GetItem(self-&gt;data, key);

    if (!v)
	return;
    if (PyExtensionClass_Check(v)) {
	if (v-&gt;ob_refcnt &lt;= 1) {
	    self-&gt;klass_count--;
	    if (PyDict_DelItem(self-&gt;data, key) &lt; 0)
		PyErr_Clear();
	}
	else {
	    v = PyObject_CallFunction(self-&gt;setklassstate, "O", v);
	    if (v) 
		Py_DECREF(v);
	    else 
		PyErr_Clear();
	}
    } else {
	if (PyObject_DelAttr(v, py__p_changed) &lt; 0)
	    PyErr_Clear();
    }
}
</t>
<t tx="ekr.20040104185913.3314">static PyObject *
cc_invalidate(ccobject *self, PyObject *args)
{
  PyObject *inv, *key, *v;
  int i = 0;

  if (PyArg_ParseTuple(args, "O!", &amp;PyDict_Type, &amp;inv)) {
      while (PyDict_Next(inv, &amp;i, &amp;key, &amp;v))
	  _invalidate(self, key);
      PyDict_Clear(inv);
  }
  else {
      PyErr_Clear();
      if (!PyArg_ParseTuple(args, "O:invalidate", &amp;inv)) 
	  return NULL;
      if (PyString_Check(inv))
	  _invalidate(self, inv);
      else {
	  int l;
	  
	  PyErr_Clear();
	  l = PyObject_Length(inv);
	  if (l &lt; 0)
	      return NULL;
	  for (i=l; --i &gt;= 0; ) {
	      key = PySequence_GetItem(inv, i);
	      if (!key)
		  return NULL;
	      _invalidate(self, key);
	      Py_DECREF(key);
	  }
	  PySequence_DelSlice(inv, 0, l);
      }
  }
  
  Py_INCREF(Py_None);
  return Py_None;
}
</t>
<t tx="ekr.20040104185913.3315">static PyObject *
cc_get(ccobject *self, PyObject *args)
{
    PyObject *r, *key, *d = NULL;

    if (!PyArg_ParseTuple(args, "O|O:get", &amp;key, &amp;d)) 
	return NULL;

    r = PyDict_GetItem(self-&gt;data, key);
    if (!r) {
	if (d) {
	    r = d;
	} else {
	    PyErr_SetObject(PyExc_KeyError, key);
	    return NULL;
	}
    }

    Py_INCREF(r);
    return r;
}
</t>
<t tx="ekr.20040104185913.3316">static PyObject *
cc_klass_items(ccobject *self, PyObject *args)
{
    PyObject *l,*k,*v;
    int p = 0;

    if (!PyArg_ParseTuple(args, ":klass_items")) 
	return NULL;

    l = PyList_New(PyDict_Size(self-&gt;data));
    if (l == NULL) 
	return NULL;

    while (PyDict_Next(self-&gt;data, &amp;p, &amp;k, &amp;v)) {
        if(PyExtensionClass_Check(v)) {
	    v = Py_BuildValue("OO", k, v);
	    if (v == NULL) {
		Py_DECREF(l);
		return NULL;
	    }
	    if (PyList_Append(l, v) &lt; 0) {
		Py_DECREF(v);
		Py_DECREF(l);
		return NULL;
	    }
	    Py_DECREF(v);
        }
    }

    return l;
}
</t>
<t tx="ekr.20040104185913.3317">static PyObject *
cc_lru_items(ccobject *self, PyObject *args)
{
    PyObject *l;
    CPersistentRing *here;

    if (!PyArg_ParseTuple(args, ":lru_items")) 
	return NULL;

    if (self-&gt;ring_lock) {
	/* When the ring lock is held, we have no way of know which
	   ring nodes belong to persistent objects, and which a
	   placeholders. */
        PyErr_SetString(PyExc_ValueError,
		".lru_items() is unavailable during garbage collection");
        return NULL;
    }

    if (IS_RING_CORRUPT(self, "pre-cc_items")) 
	return NULL;

    l = PyList_New(0);
    if (l == NULL) 
	return NULL;

    here = self-&gt;ring_home.next;
    while (here != &amp;self-&gt;ring_home) {
        PyObject *v;
        cPersistentObject *object = OBJECT_FROM_RING(self, here, "cc_items");

        if (object == NULL) {
            Py_DECREF(l);
            return NULL;
        }
	v = Py_BuildValue("OO", object-&gt;oid, object);
	if (v == NULL) {
            Py_DECREF(l);
            return NULL;
	}
	if (PyList_Append(l, v) &lt; 0) {
	    Py_DECREF(v);
            Py_DECREF(l);
            return NULL;
	}
        Py_DECREF(v);
        here = here-&gt;next;
    }

    return l;
}
</t>
<t tx="ekr.20040104185913.3318">static int
cc_oid_unreferenced(ccobject *self, PyObject *oid)
{
    /* This is called by the persistent object deallocation function
       when the reference count on a persistent object reaches
       zero. We need to fix up our dictionary; its reference is now
       dangling because we stole its reference count. Be careful to
       not release the global interpreter lock until this is
       complete. */

    PyObject *v;

    v = PyDict_GetItem(self-&gt;data, oid);
    if (v == NULL) {
	PyErr_SetObject(PyExc_KeyError, oid);
	return -1;
    }

    assert(v-&gt;ob_refcnt == 0);
    /* Need to be very hairy here because a dictionary is about
       to decref an already deleted object. 
    */

#ifdef Py_TRACE_REFS
    /* This is called from the deallocation function after the
       interpreter has untracked the reference.  Track it again.
     */
    _Py_NewReference(v);
    /* Don't increment total refcount as a result of the 
       shenanigans played in this function.  The _Py_NewReference()
       call above creates artificial references to v.
    */
    _Py_RefTotal--;
    assert(v-&gt;ob_type);
#else
    Py_INCREF(v);
#endif
    assert(v-&gt;ob_refcnt == 1);
    /* Incremement the refcount again, because delitem is going to
       DECREF it.  If it's refcount reached zero again, we'd call back to
       the dealloc function that called us.
    */
    Py_INCREF(v);

    /* XXX Should we call _Py_ForgetReference() on error exit? */
    if (PyDict_DelItem(self-&gt;data, oid) &lt; 0)
	return -1;

    if (v-&gt;ob_refcnt != 1) {
        PyErr_SetString(PyExc_ValueError,
			"refcount is not 1 after removal from dict");
        return -1;
    }

    /* Undo the temporary resurrection.
       Don't DECREF the object, because this function is called from
       the object's dealloc function. If the refcnt reaches zero, it
       will all be invoked recursively.
     */
    _Py_ForgetReference(v);

    return 0;
}
</t>
<t tx="ekr.20040104185913.3319">static PyObject *
cc_ringlen(ccobject *self, PyObject *args)
{
    CPersistentRing *here;
    int c = 0;

    if (!PyArg_ParseTuple(args, ":ringlen"))
	return NULL;
    for (here = self-&gt;ring_home.next; here != &amp;self-&gt;ring_home;
	 here = here-&gt;next)
	c++;
    return PyInt_FromLong(c);
}
</t>
<t tx="ekr.20040104185913.3320">static struct PyMethodDef cc_methods[] = {
  {"lru_items", (PyCFunction)cc_lru_items, METH_VARARGS,
   "List (oid, object) pairs from the lru list, as 2-tuples.\n"
   },
  {"klass_items", (PyCFunction)cc_klass_items, METH_VARARGS,
   "List (oid, object) pairs of cached persistent classes.\n"
   },
  {"full_sweep", (PyCFunction)cc_full_sweep, METH_VARARGS,
   "full_sweep([age]) -- Perform a full sweep of the cache\n\n"
   "Supported for backwards compatibility.  If the age argument is 0,\n"
   "behaves like minimize().  Otherwise, behaves like incrgc()."
   },
  {"minimize",	(PyCFunction)cc_minimize, METH_VARARGS,
   "minimize([ignored]) -- Remove as many objects as possible\n\n"
   "Ghostify all objects that are not modified.  Takes an optional\n"
   "argument, but ignores it."
   },
  {"incrgc", (PyCFunction)cc_incrgc, METH_VARARGS,
   "incrgc([n]) -- Perform incremental garbage collection\n\n"
   "Some other implementations support an optional parameter 'n' which\n"
   "indicates a repetition count; this value is ignored.\n"},
  {"invalidate", (PyCFunction)cc_invalidate, METH_VARARGS,
   "invalidate(oids) -- invalidate one, many, or all ids"},
  {"get", (PyCFunction)cc_get, METH_VARARGS,
   "get(key [, default]) -- get an item, or a default"},
  {"ringlen", (PyCFunction)cc_ringlen, METH_VARARGS,
   "ringlen() -- Returns number of non-ghost items in cache."},
  {NULL,		NULL}		/* sentinel */
};

static void
cc_dealloc(ccobject *self)
{
  Py_XDECREF(self-&gt;data);
  Py_XDECREF(self-&gt;jar);
  Py_XDECREF(self-&gt;setklassstate);
  PyMem_DEL(self);
}
</t>
<t tx="ekr.20040104185913.3321">static PyObject *
cc_getattr(ccobject *self, char *name)
{
  PyObject *r;

  if (IS_RING_CORRUPT(self, "getattr")) 
      return NULL;

  if(*name=='c')
    {
      if(strcmp(name,"cache_age")==0)
	return PyInt_FromLong(0);   /* this cache does not use this value */
      if(strcmp(name,"cache_size")==0)
	return PyInt_FromLong(self-&gt;cache_size);
      if(strcmp(name,"cache_drain_resistance")==0)
	return PyInt_FromLong(self-&gt;cache_drain_resistance);
      if(strcmp(name,"cache_non_ghost_count")==0)
	return PyInt_FromLong(self-&gt;non_ghost_count);
      if(strcmp(name,"cache_klass_count")==0)
	return PyInt_FromLong(self-&gt;klass_count);
      if(strcmp(name,"cache_data")==0)
	{
	  /* now a copy of our data; the ring is too fragile */
	  return PyDict_Copy(self-&gt;data);
	}
    }
  if((*name=='h' &amp;&amp; strcmp(name, "has_key")==0) ||
     (*name=='i' &amp;&amp; strcmp(name, "items")==0) ||
     (*name=='k' &amp;&amp; strcmp(name, "keys")==0)
     )
    return PyObject_GetAttrString(self-&gt;data, name);

  if((r=Py_FindMethod(cc_methods, (PyObject *)self, name)))
    return r;
  PyErr_Clear();
  return PyObject_GetAttrString(self-&gt;data, name);
}
</t>
<t tx="ekr.20040104185913.3322">static int
cc_setattr(ccobject *self, char *name, PyObject *value)
{
  if(value)
    {
      int v;

      if(strcmp(name,"cache_age")==0)
	{
	  /* this cache doesnt use the age */
	  return 0;
	}

      if(strcmp(name,"cache_size")==0)
	{
	  UNLESS(PyArg_Parse(value,"i",&amp;v)) return -1;
	  self-&gt;cache_size=v;
	  return 0;
	}

      if(strcmp(name,"cache_drain_resistance")==0)
	{
	  UNLESS(PyArg_Parse(value,"i",&amp;v)) return -1;
	  self-&gt;cache_drain_resistance=v;
	  return 0;
	}
    }
  PyErr_SetString(PyExc_AttributeError, name);
  return -1;
}
</t>
<t tx="ekr.20040104185913.3323">static int
cc_length(ccobject *self)
{
    return PyObject_Length(self-&gt;data);
}
</t>
<t tx="ekr.20040104185913.3324">static PyObject *
cc_subscript(ccobject *self, PyObject *key)
{
    PyObject *r;

    if (IS_RING_CORRUPT(self, "__getitem__")) 
	return NULL;

    r = PyDict_GetItem(self-&gt;data, key);
    if (r == NULL) {
	PyErr_SetObject(PyExc_KeyError, key);
	return NULL;
    }

    Py_INCREF(r);
    return r;
}
</t>
<t tx="ekr.20040104185913.3325">static int
cc_add_item(ccobject *self, PyObject *key, PyObject *v)
{
    int result;
    PyObject *oid, *object_again, *jar;
    cPersistentObject *p;

    if (PyExtensionClass_Check(v)) {
        /* Its a persistent class, such as a ZClass. Thats ok. */
    }
    else if( PyExtensionInstance_Check(v) &amp;&amp;
             (((PyExtensionClass*)(v-&gt;ob_type))-&gt;class_flags &amp; PERSISTENT_TYPE_FLAG) &amp;&amp;
             (v-&gt;ob_type-&gt;tp_basicsize &gt;= sizeof(cPersistentObject)) ) {
        /* Its and instance of a persistent class, (ie Python classeses that
        derive from Persistence.Persistent, BTrees, etc). Thats ok. */
    }
    else {
	PyErr_SetString(PyExc_TypeError, 
			"Cache values must be persistent objects.");
	return -1;
    }

    /* Can't access v-&gt;oid directly because the object might be a
     *  persistent class.
     */
    oid = PyObject_GetAttr(v, py__p_oid);
    if (oid == NULL)
	return -1;
    if (!PyString_Check(oid)) {
        PyErr_Format(PyExc_TypeError,
                     "Cached object oid must be a string, not a %s",
		     oid-&gt;ob_type-&gt;tp_name);
	return -1;
    }
    /*  we know they are both strings.
     *  now check if they are the same string.
     */
    result = PyObject_Compare(key, oid);
    if (PyErr_Occurred()) {
	Py_DECREF(oid);
	return -1;
    } 
    Py_DECREF(oid);
    if (result) {
	PyErr_SetString(PyExc_ValueError, "Cache key does not match oid");
	return -1;
    }

    /* useful sanity check, but not strictly an invariant of this class */
    jar = PyObject_GetAttr(v, py__p_jar);
    if (jar == NULL)
        return -1;
    if (jar==Py_None) {
        Py_DECREF(jar);
        PyErr_SetString(PyExc_ValueError,
                        "Cached object jar missing");
	return -1;
    }
    Py_DECREF(jar);

    object_again = PyDict_GetItem(self-&gt;data, key);
    if (object_again) {
	if (object_again != v) {
	    PyErr_SetString(PyExc_ValueError,
		    "Can not re-register object under a different oid");
	    return -1;
	} else {
	    /* re-register under the same oid - no work needed */
	    return 0;
	}
    }

    if (PyExtensionClass_Check(v)) {
	if (PyDict_SetItem(self-&gt;data, key, v) &lt; 0) 
	    return -1;
	self-&gt;klass_count++;
	return 0;
    } else {
	PerCache *cache = ((cPersistentObject *)v)-&gt;cache;
	if (cache) {
	    if (cache != (PerCache *)self)
		/* This object is already in a different cache. */
		PyErr_SetString(PyExc_ValueError, 
				"Cache values may only be in one cache.");
	    return -1;
	} 
	/* else:
	   
	   This object is already one of ours, which is ok.  It
	   would be very strange if someone was trying to register
	   the same object under a different key. 
	*/
    }
    
    if (IS_RING_CORRUPT(self, "pre-setitem")) 
	return -1;
    if (PyDict_SetItem(self-&gt;data, key, v) &lt; 0) 
	return -1;
    /* the dict should have a borrowed reference */
    Py_DECREF(v);
    
    p = (cPersistentObject *)v;
    Py_INCREF(self);
    p-&gt;cache = (PerCache *)self;
    if (p-&gt;state &gt;= 0) {
	/* insert this non-ghost object into the ring just 
	   behind the home position. */
	self-&gt;non_ghost_count++;
	p-&gt;ring.next = &amp;self-&gt;ring_home;
	p-&gt;ring.prev =  self-&gt;ring_home.prev;
	self-&gt;ring_home.prev-&gt;next = &amp;p-&gt;ring;
	self-&gt;ring_home.prev = &amp;p-&gt;ring;
	/* this list should have a new reference to the object */
	Py_INCREF(v);
    }
    
    if (IS_RING_CORRUPT(self, "post-setitem")) 
	return -1;
    else
	return 0;
}
</t>
<t tx="ekr.20040104185913.3326">static int
cc_del_item(ccobject *self, PyObject *key)
{
    PyObject *v;
    cPersistentObject *p;

    /* unlink this item from the ring */
    if (IS_RING_CORRUPT(self, "pre-delitem")) 
	return -1;

    v = PyDict_GetItem(self-&gt;data, key);
    if (v == NULL)
	return -1;

    if (PyExtensionClass_Check(v)) {
	self-&gt;klass_count--;
    } else {
	p = (cPersistentObject *)v;
	if (p-&gt;state &gt;= 0) {
	    self-&gt;non_ghost_count--;
	    p-&gt;ring.next-&gt;prev = p-&gt;ring.prev;
	    p-&gt;ring.prev-&gt;next = p-&gt;ring.next;
	    p-&gt;ring.prev = NULL;
	    p-&gt;ring.next = NULL;
	    /* The DelItem below will account for the reference
	       held by the list. */
	} else {
	    /* This is a ghost object, so we havent kept a reference
	       count on it.  For it have stayed alive this long
	       someone else must be keeping a reference to
	       it. Therefore we need to temporarily give it back a
	       reference count before calling DelItem below */
	    Py_INCREF(v);
	}

	Py_DECREF((PyObject *)p-&gt;cache);
	p-&gt;cache = NULL;
    }

    if (PyDict_DelItem(self-&gt;data, key) &lt; 0) {
	PyErr_SetString(PyExc_RuntimeError,
			"unexpectedly couldn't remove key in cc_ass_sub");
	return -1;
    }

    if (IS_RING_CORRUPT(self, "post-delitem")) 
	return -1;

    return 0;
}
</t>
<t tx="ekr.20040104185913.3327">static int
cc_ass_sub(ccobject *self, PyObject *key, PyObject *v)
{
    if (!PyString_Check(key)) {
	PyErr_Format(PyExc_TypeError,
                     "cPickleCache key must be a string, not a %s",
		     key-&gt;ob_type-&gt;tp_name);
	return -1;
    }
    if (v)
	return cc_add_item(self, key, v);
    else
	return cc_del_item(self, key);
}
</t>
<t tx="ekr.20040104185913.3328">#ifdef MUCH_RING_CHECKING
static int 
_ring_corrupt(ccobject *self, const char *context)
{
    CPersistentRing *here = &amp;(self-&gt;ring_home);

    /* Determine the number of objects we expect to see in the ring.
     * Normally this is one for the home node plus one for each
     * non-ghost object, for which we maintain a separate total. If the
     * ring is unlocked then this value should be precise; there should
     * be no foreign nodes in the ring. If locked, it may be an
     * underestimate */
    int expected = 1 + self-&gt;non_ghost_count;

    int total = 0;
    do {
        if (++total &gt; (expected + 10))
            /* ring too big, by a large margin. This probably
             * means we are stomping through random memory. Abort
             * now, and maybe we can deliver this error message
             * before dumping core */ 
	    return 3;            
        if (!here-&gt;next)
	    return 4;                      /* various linking problems */
        if (!here-&gt;prev) 
	    return 5;
        if (!here-&gt;next-&gt;prev) 
	    return 7;
        if (!here-&gt;prev-&gt;next) 
	    return 8;
        if (here-&gt;prev-&gt;next != here) 
	    return 9;
        if (here-&gt;next-&gt;prev != here) 
	    return 10;
        if (!self-&gt;ring_lock) {
            /* If the ring is unlocked, then it must not contain
	     * objects other than persistent instances (and the home) */ 
            if (here != &amp;self-&gt;ring_home) {
                cPersistentObject *object = OBJECT_FROM_RING(self, here, 
							     context);
                if (!object) 
		    return 12;
                if (object-&gt;state == cPersistent_GHOST_STATE)
		    /* ghost objects should not be in the ring, according
                     * to the ghost storage regime. Experience shows
                     * that this error condition is likely to be caused
                     * by a race condition bug somewhere */
                    return 13;
            }
        }
        here = here-&gt;next;
    } while (here != &amp;self-&gt;ring_home);

    if (self-&gt;ring_lock) {
        if (total &lt; expected)
            /* ring is too small.
               too big is ok when locked, we have already checked it is
               not too big */ 
	    return 6;       
    } else {
        if (total != expected) 
	    return 14;     /* ring size wrong, or bad ghost accounting */
    }

    return 0;
}
</t>
<t tx="ekr.20040104185913.3329">static int 
ring_corrupt(ccobject *self, const char *context)
{
    int code = _ring_corrupt(self, context);
    if (code) {
	if (!PyErr_Occurred())
	    PyErr_Format(PyExc_RuntimeError,
			 "broken ring (code %d) in %s, size %d",
			 code, context, PyDict_Size(self-&gt;data));
        return code;
    }
    return 0;
}
</t>
<t tx="ekr.20040104185913.3330">static int
present_in_ring(ccobject *self,CPersistentRing *target)
{
    CPersistentRing *here = self-&gt;ring_home.next;
    while (1) {
        if (here == target) 
            return 1;
        if (here == &amp;self-&gt;ring_home)
            return 0; /* back to the home position, and we didnt find it */
        here = here-&gt;next;
    }
}
</t>
<t tx="ekr.20040104185913.3331">#endif /* MUCH_RING_CHECKING */

static PyMappingMethods cc_as_mapping = {
  (inquiry)cc_length,		/*mp_length*/
  (binaryfunc)cc_subscript,	/*mp_subscript*/
  (objobjargproc)cc_ass_sub,	/*mp_ass_subscript*/
};

static PyTypeObject Cctype = {
    PyObject_HEAD_INIT(NULL)
    0,				/*ob_size*/
    "cPickleCache",		/*tp_name*/
    sizeof(ccobject),		/*tp_basicsize*/
    0,				/*tp_itemsize*/
    /* methods */
    (destructor)cc_dealloc,	/*tp_dealloc*/
    (printfunc)0,		/*tp_print*/
    (getattrfunc)cc_getattr,	/*tp_getattr*/
    (setattrfunc)cc_setattr,	/*tp_setattr*/
    (cmpfunc)0,			/*tp_compare*/
    (reprfunc)0,   		/*tp_repr*/
    0,				/*tp_as_number*/
    0,				/*tp_as_sequence*/
    &amp;cc_as_mapping,		/*tp_as_mapping*/
    (hashfunc)0,		/*tp_hash*/
    (ternaryfunc)0,		/*tp_call*/
    (reprfunc)0,  		/*tp_str*/
};

static ccobject *
newccobject(PyObject *jar, int cache_size)
{
    ccobject *self;
  
    self = PyObject_NEW(ccobject, &amp;Cctype);
    if (self == NULL)
	return NULL;
    self-&gt;setklassstate = self-&gt;jar = NULL;
    self-&gt;data = PyDict_New();
    if (self-&gt;data == NULL) {
	Py_DECREF(self);
	return NULL;
    }
    self-&gt;setklassstate = PyObject_GetAttrString(jar, "setklassstate");
    if (self-&gt;setklassstate == NULL) {
	Py_DECREF(self);
	return NULL;
    }
    self-&gt;jar = jar; 
    Py_INCREF(jar);
    self-&gt;cache_size = cache_size;
    self-&gt;non_ghost_count = 0;
    self-&gt;klass_count = 0;
    self-&gt;cache_drain_resistance = 0;
    self-&gt;ring_lock = 0;
    self-&gt;ring_home.next = &amp;self-&gt;ring_home;
    self-&gt;ring_home.prev = &amp;self-&gt;ring_home;
    return self;
}
</t>
<t tx="ekr.20040104185913.3332">static PyObject *
cCM_new(PyObject *self, PyObject *args)
{
    int cache_size=100;
    PyObject *jar;

    if (!PyArg_ParseTuple(args, "O|i", &amp;jar, &amp;cache_size))
	return NULL;
    return (PyObject*)newccobject(jar, cache_size);
}
</t>
<t tx="ekr.20040104185913.3333">static struct PyMethodDef cCM_methods[] = {
  {"PickleCache", (PyCFunction)cCM_new,	METH_VARARGS, ""},
  {NULL,		NULL}		/* sentinel */
};

void
initcPickleCache(void)
{
  PyObject *m, *d;
  cPersistenceCAPIstruct *capi;

  Cctype.ob_type = &amp;PyType_Type;

  if (!ExtensionClassImported) 
      return;

  capi = (cPersistenceCAPIstruct *)PyCObject_Import("cPersistence", "CAPI");
  if (!capi)
      return;
  capi-&gt;percachedel = (percachedelfunc)cc_oid_unreferenced;

  m = Py_InitModule4("cPickleCache", cCM_methods, cPickleCache_doc_string,
		     (PyObject*)NULL, PYTHON_API_VERSION);

  py_reload = PyString_InternFromString("reload");
  py__p_jar = PyString_InternFromString("_p_jar");
  py__p_changed = PyString_InternFromString("_p_changed");
  py__p_oid = PyString_InternFromString("_p_oid");

  d = PyModule_GetDict(m);

  PyDict_SetItemString(d, "cache_variant", PyString_FromString("stiff/c"));

#ifdef MUCH_RING_CHECKING
  PyDict_SetItemString(d, "MUCH_RING_CHECKING", PyInt_FromLong(1));
#else
  PyDict_SetItemString(d, "MUCH_RING_CHECKING", PyInt_FromLong(0));
#endif
}
</t>
<t tx="ekr.20040104185913.3334"></t>
<t tx="ekr.20040104185913.3335">&lt;&lt; copyright &gt;&gt;

__ac_permissions__=()
</t>
<t tx="ekr.20040104185913.3336"></t>
<t tx="ekr.20040104185913.3337">@nocolor

External Method Changes

  External Method 1.3
  
    Features
  
     - Permissions have been updated to work with the Principia 1.2 and
       later permission-management enhancements.
  
  
  External Method 1.2
  
    Bug Fixes
  
      - TypeError exceptions in external methods were reported
	incorrectly. 
  
    Features
  
      - ExternalMethods now use standard_error_message to report errors.
  
  
  External Method 1.1
  
    This release changes the way that ExternalMethods are bound to 
    folders.  ExternalMethods now bind themselves to their acquisition
    parents, rather than to REQUEST['PARENTS'][0].  This is needed to
    make ExternalMethods useful in trees and exprs.  The 1.1 release of
    Principia is needed for this release of ExternalMethod to
    function correctly.
  

  External Method 1.0.3
  
    Bugs Fixed
  
     - A new copy of an external method was written the first time
       it was used after being loaded from the database.  In addition to
       database bloat, this could also cause strange session/locking behavior.
  
  
  External Method 1.0.2
  
    Bugs Fixed
  
      - Add permissions were not editable.
  
    Features
	
      - If an ExternalMethod takes a single argument, named self, and is
	called with no arguments, then the folder in which the method
	is accessed is passed.  This is handy when the method is called 
	from a document.
</t>
<t tx="ekr.20040104185913.3338">&lt;&lt; copyright &gt;&gt;

"""External Method Product

This product provides support for external methods, which allow
domain-specific customization of web environments.
"""
__version__='$Revision: 1.51 $'[11:-2]

&lt;&lt; ExternalMethod imports &gt;&gt;

manage_addExternalMethodForm=DTMLFile('dtml/methodAdd', globals())

@others
</t>
<t tx="ekr.20040104185913.3339">from Globals import Persistent, DTMLFile, MessageDialog, HTML
import OFS.SimpleItem, Acquisition
import AccessControl.Role, sys, os, stat, traceback
from OFS.SimpleItem import pretty_tb
from App.Extensions import getObject, getPath, FuncCode
from Globals import DevelopmentMode
from App.Management import Navigation
from ComputedAttribute import ComputedAttribute</t>
<t tx="ekr.20040104185913.3340">def manage_addExternalMethod(self, id, title, module, function, REQUEST=None):
    """Add an external method to a folder

    Un addition to the standard object-creation arguments,
    'id' and title, the following arguments are defined:

        function -- The name of the python function. This can be a
          an ordinary Python function, or a bound method.

        module -- The name of the file containing the function
          definition.

        The module normally resides in the 'Extensions'
        directory, however, the file name may have a prefix of
        'product.', indicating that it should be found in a product
        directory.

        For example, if the module is: 'ACMEWidgets.foo', then an
        attempt will first be made to use the file
        'lib/python/Products/ACMEWidgets/Extensions/foo.py'. If this
        failes, then the file 'Extensions/ACMEWidgets.foo.py' will be
        used.
    """
    id=str(id)
    title=str(title)
    module=str(module)
    function=str(function)

    i=ExternalMethod(id,title,module,function)
    self._setObject(id,i)
    if REQUEST is not None:
        return self.manage_main(self,REQUEST)
</t>
<t tx="ekr.20040104185913.3341">class ExternalMethod(OFS.SimpleItem.Item, Persistent, Acquisition.Explicit,AccessControl.Role.RoleManager, Navigation):
	&lt;&lt; class ExternalMethod declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3342">"""Web-callable functions that encapsulate external python functions.

The function is defined in an external file.  This file is treated
like a module, but is not a module.  It is not imported directly,
but is rather read and evaluated.  The file must reside in the
'Extensions' subdirectory of the Zope installation, or in an
'Extensions' subdirectory of a product directory.

Due to the way ExternalMethods are loaded, it is not *currently*
possible to use Python modules that reside in the 'Extensions'
directory.  It is possible to load modules found in the
'lib/python' directory of the Zope installation, or in
packages that are in the 'lib/python' directory.

"""

meta_type = 'External Method'

func_defaults = ComputedAttribute(lambda self: self.getFuncDefaults())
func_code = ComputedAttribute(lambda self: self.getFuncCode())

ZopeTime=Acquisition.Acquired
HelpSys=Acquisition.Acquired

manage_options=(
(
{'label':'Properties', 'action':'manage_main',
'help':('ExternalMethod','External-Method_Properties.stx')},
{'label':'Test', 'action':'',
'help':('ExternalMethod','External-Method_Try-It.stx')},
)
+OFS.SimpleItem.Item.manage_options
+AccessControl.Role.RoleManager.manage_options
)

__ac_permissions__=(
('View management screens', ('manage_main',)),
('Change External Methods', ('manage_edit',)),
('View', ('__call__','')),
)</t>
<t tx="ekr.20040104185913.3343">def __init__(self, id, title, module, function):
    self.id=id
    self.manage_edit(title, module, function)
</t>
<t tx="ekr.20040104185913.3344">manage_main=DTMLFile('dtml/methodEdit', globals())
def manage_edit(self, title, module, function, REQUEST=None):
    """Change the external method

    See the description of manage_addExternalMethod for a
    descriotion of the arguments 'module' and 'function'.

    Note that calling 'manage_edit' causes the "module" to be
    effectively reloaded.  This is useful during debugging to see
    the effects of changes, but can lead to problems of functions
    rely on shared global data.
    """
    title=str(title)
    module=str(module)
    function=str(function)

    self.title=title
    if module[-3:]=='.py': module=module[:-3]
    elif module[-4:]=='.pyc': module=module[:-4]
    self._module=module
    self._function=function
    self.getFunction(1)
    if REQUEST:
        message="External Method Uploaded."
        return self.manage_main(self,REQUEST,manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.3345">def getFunction(self, reload=0):

    f=getObject(self._module, self._function, reload)
    if hasattr(f,'im_func'): ff=f.im_func
    else: ff=f

    self._v_func_defaults  = ff.func_defaults
    self._v_func_code = FuncCode(ff,f is not ff)

    self._v_f=f

    return f
</t>
<t tx="ekr.20040104185913.3346">def reloadIfChanged(self):
    # If the file has been modified since last loaded, force a reload.
    ts=os.stat(self.filepath())[stat.ST_MTIME]
    if (not hasattr(self, '_v_last_read') or
        (ts != self._v_last_read)):
        self._v_f=self.getFunction(1)
        self._v_last_read=ts
</t>
<t tx="ekr.20040104185913.3347">if DevelopmentMode:
    # In development mode we do an automatic reload
    # if the module code changed
    def getFuncDefaults(self):
        self.reloadIfChanged()
        if not hasattr(self, '_v_func_defaults'):
            self._v_f = self.getFunction()
        return self._v_func_defaults

    def getFuncCode(self):
        self.reloadIfChanged()
        if not hasattr(self, '_v_func_code'):
            self._v_f = self.getFunction()
        return self._v_func_code
</t>
<t tx="ekr.20040104185913.3348">else:
    def getFuncDefaults(self):
        if not hasattr(self, '_v_func_defaults'):
            self._v_f = self.getFunction()
        return self._v_func_defaults

    def getFuncCode(self):
        if not hasattr(self, '_v_func_code'):
            self._v_f = self.getFunction()
        return self._v_func_code
</t>
<t tx="ekr.20040104185913.3349">def __call__(self, *args, **kw):
    """Call an ExternalMethod

    Calling an External Method is roughly equivalent to calling
    the original actual function from Python.  Positional and
    keyword parameters can be passed as usual.  Note however that
    unlike the case of a normal Python method, the "self" argument
    must be passed explicitly.  An exception to this rule is made
    if:

    - The supplied number of arguments is one less than the
      required number of arguments, and

    - The name of the function\'s first argument is 'self'.

    In this case, the URL parent of the object is supplied as the
    first argument.
    """

    filePath = self.filepath()
    if filePath==None:
        raise RuntimeError,\
            "external method could not be called " \
            "because it is None"

    if not os.path.exists(filePath):
        raise RuntimeError,\
            "external method could not be called " \
            "because the file does not exist"

    if DevelopmentMode:
        self.reloadIfChanged()

    if hasattr(self, '_v_f'):
        f=self._v_f
    else:
        f=self.getFunction()

    __traceback_info__=args, kw, self._v_func_defaults

    try: return apply(f,args,kw)
    except TypeError, v:
        tb=sys.exc_info()[2]
        try:
            if ((self._v_func_code.co_argcount-
                 len(self._v_func_defaults or ()) - 1 == len(args))
                and self._v_func_code.co_varnames[0]=='self'):
                return apply(f,(self.aq_parent.this(),)+args,kw)

            raise TypeError, v, tb
        finally: tb=None
</t>
<t tx="ekr.20040104185913.3350">def function(self): return self._function
</t>
<t tx="ekr.20040104185913.3351">def module(self): return self._module
</t>
<t tx="ekr.20040104185913.3352">def filepath(self):
    if not hasattr(self, '_v_filepath'):
        self._v_filepath=getPath('Extensions', self._module,
                                 suffixes=('','py','pyc','pyp'))
    return self._v_filepath
</t>
<t tx="ekr.20040104185913.3353">@nocolor

External Methods


  The External Method product provides support for external Python
  methods, exposing them as callable objects within the Zope 
  environment.
</t>
<t tx="ekr.20040104185913.3354">&lt;&lt; copyright &gt;&gt;

__doc__='''External Method Product Initialization
$Id: __init__.py,v 1.15 2002/08/14 22:14:10 mj Exp $'''

__version__='$Revision: 1.15 $'[11:-2]

import ExternalMethod

@others
</t>
<t tx="ekr.20040104185913.3356"># This is the new way to initialize products.  It is hoped
# that this more direct mechanism will be more understandable.

def initialize(context):

    context.registerClass(
        ExternalMethod.ExternalMethod,
        constructors=(ExternalMethod.manage_addExternalMethodForm,
                       ExternalMethod.manage_addExternalMethod),
        icon='extmethod.gif',
        )

    context.registerHelp()
    context.registerHelpTitle('Zope Help')</t>
<t tx="ekr.20040104185913.3357">External Method-1-0-0</t>
<t tx="ekr.20040104185913.3358"></t>
<t tx="ekr.20040104185913.3359">&lt;&lt; copyright &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.3361">def manage_addExternalMethod(id, title, module, function):
    """
    Add an external method to an
    'ObjectManager'.

    In addition to the standard object-creation arguments,
    'id' and title, the following arguments are defined:

      function -- The name of the python function. This can be a
        an ordinary Python function, or a bound method.

      module -- The name of the file containing the function
        definition.

    The module normally resides in the 'Extensions'
    directory, however, the file name may have a prefix of
    'product.', indicating that it should be found in a product
    directory.

    For example, if the module is: 'ACMEWidgets.foo', then an
    attempt will first be made to use the file
    'lib/python/Products/ACMEWidgets/Extensions/foo.py'. If this
    failes, then the file 'Extensions/ACMEWidgets.foo.py' will be
    used.

    """</t>
<t tx="ekr.20040104185913.3362">class ExternalMethod:
    """
    Web-callable functions that encapsulate external
    Python functions.

    The function is defined in an external file.  This file is treated
    like a module, but is not a module.  It is not imported directly,
    but is rather read and evaluated.  The file must reside in the
    'Extensions' subdirectory of the Zope installation, or in an
    'Extensions' subdirectory of a product directory.

    Due to the way ExternalMethods are loaded, it is not *currently*
    possible to import Python modules that reside in the 'Extensions'
    directory.  It is possible to import modules found in the
    'lib/python' directory of the Zope installation, or in
    packages that are in the 'lib/python' directory.

    """

	__constructor__=manage_addExternalMethod

	@others
</t>
<t tx="ekr.20040104185913.3364">def manage_edit(title, module, function, REQUEST=None):
    """
    Change the
    External Method.

    See the description of manage_addExternalMethod for a
    description of the arguments 'module' and 'function'.

    Note that calling 'manage_edit' causes the "module" to be
    effectively reloaded.  This is useful during debugging to see
    the effects of changes, but can lead to problems of functions
    rely on shared global data.

    """
</t>
<t tx="ekr.20040104185913.3365">def __call__(*args, **kw):

    """
    Call the
    External Method.

    Calling an External Method is roughly equivalent to calling
    the original actual function from Python.  Positional and
    keyword parameters can be passed as usual.  Note however that
    unlike the case of a normal Python method, the "self" argument
    must be passed explicitly.  An exception to this rule is made
    if:

    - The supplied number of arguments is one less than the
      required number of arguments, and

    - The name of the function's first argument is 'self'.

    In this case, the URL parent of the object is supplied as the
    first argument.

    """</t>
<t tx="ekr.20040104185913.3366"></t>
<t tx="ekr.20040104185913.3367">&lt;&lt; copyright &gt;&gt;

"""

$Id: __init__.py,v 1.4 2002/08/14 22:14:11 mj Exp $
"""
</t>
<t tx="ekr.20040104185913.3368">&lt;&lt; copyright &gt;&gt;

"""

Revision information:
$Id: testExternalMethod.py,v 1.5 2002/08/14 22:14:11 mj Exp $
"""

&lt;&lt; testExternalMethod imports &gt;&gt;

builtinsdict = getattr(__builtins__, '__dict__', __builtins__)

@others

if __name__=='__main__':
    main(defaultTest='test_suite')</t>
<t tx="ekr.20040104185913.3369">import math, os
from unittest import TestCase, TestSuite, main, makeSuite
import ZODB # dead goat
import Products.ExternalMethod.tests
from Products.ExternalMethod.ExternalMethod import ExternalMethod</t>
<t tx="ekr.20040104185913.3370">class Test(TestCase):
	@others
</t>
<t tx="ekr.20040104185913.3371">def setUp(self):
    self._old = builtinsdict.get('INSTANCE_HOME')
    builtinsdict['INSTANCE_HOME'] = os.path.split(
        Products.ExternalMethod.tests.__file__)[0]
</t>
<t tx="ekr.20040104185913.3372">def tearDown(self):
    if self._old is None:
        del builtinsdict['INSTANCE_HOME']
    else:
        builtinsdict['INSTANCE_HOME'] = self._old
</t>
<t tx="ekr.20040104185913.3373">def testStorage(self):
    em1 = ExternalMethod('em', 'test method', 'Test', 'testf')
    self.assertEqual(em1(4), math.sqrt(4))
    state = em1.__getstate__()
    em2 = ExternalMethod.__basicnew__()
    em2.__setstate__(state)
    self.assertEqual(em2(9), math.sqrt(9))
    self.failIf(state.has_key('func_defaults'))
</t>
<t tx="ekr.20040104185913.3374">def test_mapply(self):
    from ZPublisher.mapply import mapply

    em1 = ExternalMethod('em', 'test method', 'Test', 'testf')
    self.assertEqual(mapply(em1, (), {'arg1': 4}), math.sqrt(4))
    state = em1.__getstate__()
    em2 = ExternalMethod.__basicnew__()
    em2.__setstate__(state)
    self.assertEqual(mapply(em1, (), {'arg1': 9}), math.sqrt(9))
</t>
<t tx="ekr.20040104185913.3375">def test_suite():
    return TestSuite((
        makeSuite(Test),
        ))
</t>
<t tx="ekr.20040104185913.3376">def package_home(globals_dict):
    __name__=globals_dict['__name__']
    m=sys.modules[__name__]
    if hasattr(m,'__path__'):
        r=m.__path__[0]
    elif "." in __name__:
        r=sys.modules[__name__[:rfind(__name__,'.')]].__path__[0]
    else:
        r=__name__
    return os.path.join(os.getcwd(), r)
</t>
<t tx="ekr.20040104185913.3377"></t>
<t tx="ekr.20040104185913.3378">from math import sqrt

def testf(arg1, sqrt = sqrt):
    return sqrt(arg1)</t>
<t tx="ekr.20040104185913.3381"></t>
<t tx="ekr.20040104185913.3382">&lt;&lt; MIMETag declarations &gt;&gt;
@others




String.commands['mime'] = MIMETag
</t>
<t tx="ekr.20040104185913.3383">&lt;&lt; copyright &gt;&gt;
__rcs_id__='$Id: MIMETag.py,v 1.10 2002/08/14 22:14:27 mj Exp $'
__version__='$Revision: 1.10 $'[11:-2]

from DocumentTemplate.DT_Util import *
from DocumentTemplate.DT_String import String
from MimeWriter import MimeWriter
from cStringIO import StringIO
import mimetools

MIMEError = "MIME Tag Error"

</t>
<t tx="ekr.20040104185913.3384">class MIMETag:
    '''
    '''
	&lt;&lt; class MIMETag declarations &gt;&gt;
	@others


    __call__=render</t>
<t tx="ekr.20040104185913.3385">name='mime'
blockContinuations=('boundary',)
encode=None

</t>
<t tx="ekr.20040104185913.3386">def __init__(self, blocks):
    self.sections = []

    for tname, args, section in blocks:
        if tname == 'mime':
            args = parse_params( args
                               , type=None, type_expr=None
                               , disposition=None, disposition_expr=None
                               , encode=None, encode_expr=None
                               , name=None, name_expr=None
                               , filename=None, filename_expr=None
                               , skip_expr=None
                               , multipart=None
                               )
            self.multipart = args.get('multipart', 'mixed')
        else:
            args = parse_params( args
                               , type=None, type_expr=None
                               , disposition=None, disposition_expr=None
                               , encode=None, encode_expr=None
                               , name=None, name_expr=None
                               , filename=None, filename_expr=None
                               , skip_expr=None
                               )

        has_key=args.has_key

        if has_key('type'):
            type = args['type']
        else:
            type = 'application/octet-stream'

        if has_key('type_expr'):
            if has_key('type'):
                raise ParseError, _tm('type and type_expr given', 'mime')
            args['type_expr']=Eval(args['type_expr'])
        elif not has_key('type'):
            args['type']='application/octet-stream'

        if has_key('disposition_expr'):
            if has_key('disposition'):
                raise ParseError, _tm('disposition and disposition_expr given', 'mime')
            args['disposition_expr']=Eval(args['disposition_expr'])
        elif not has_key('disposition'):
            args['disposition']=''

        if has_key('encode_expr'):
            if has_key('encode'):
                raise ParseError, _tm('encode and encode_expr given', 'mime')
            args['encode_expr']=Eval(args['encode_expr'])
        elif not has_key('encode'):
            args['encode']='base64'

        if has_key('name_expr'):
            if has_key('name'):
                raise ParseError, _tm('name and name_expr given', 'mime')
            args['name_expr']=Eval(args['name_expr'])
        elif not has_key('name'):
            args['name']=''

        if has_key('filename_expr'):
            if has_key('filename'):
                raise ParseError, _tm('filename and filename_expr given', 'mime')
            args['filename_expr']=Eval(args['filename_expr'])
        elif not has_key('filename'):
            args['filename']=''

        if has_key('skip_expr'):
            args['skip_expr']=Eval(args['skip_expr'])

        if args['encode'] not in \
        ('base64', 'quoted-printable', 'uuencode', 'x-uuencode',
         'uue', 'x-uue', '7bit'):
            raise MIMEError, (
                'An unsupported encoding was specified in tag')

        self.sections.append((args, section.blocks))
</t>
<t tx="ekr.20040104185913.3387">def render(self, md):
    contents=[]
    IO = StringIO()
    IO.write("Mime-Version: 1.0\n")
    mw = MimeWriter(IO)
    outer = mw.startmultipartbody(self.multipart)
    for x in self.sections:
        a, b = x
        has_key=a.has_key

        if has_key('skip_expr') and a['skip_expr'].eval(md):
            continue

        inner = mw.nextpart()

        if has_key('type_expr'): t=a['type_expr'].eval(md)
        else: t=a['type']

        if has_key('disposition_expr'): d=a['disposition_expr'].eval(md)
        else: d=a['disposition']

        if has_key('encode_expr'): e=a['encode_expr'].eval(md)
        else: e=a['encode']

        if has_key('name_expr'): n=a['name_expr'].eval(md)
        else: n=a['name']

        if has_key('filename_expr'): f=a['filename_expr'].eval(md)
        else: f=a['filename']

        if d:
            if f:
                inner.addheader('Content-Disposition', '%s;\n filename="%s"' % (d, f))
            else:
                inner.addheader('Content-Disposition', d)

        inner.addheader('Content-Transfer-Encoding', e)
        if n:
            plist = [('name', n)]
        else:
            plist = []

        innerfile = inner.startbody(t, plist, 1)

        output = StringIO()
        if e == '7bit':
            innerfile.write(render_blocks(b, md))
        else:
            mimetools.encode(StringIO(render_blocks(b, md)),
                             output, e)
            output.seek(0)
            innerfile.write(output.read())

    # XXX what if self.sections is empty ??? does it matter that mw.lastpart() is called
    # right after mw.startmultipartbody() ?
    if x is self.sections[-1]:
        mw.lastpart()

    outer.seek(0)
    return outer.read()
</t>
<t tx="ekr.20040104185913.3388">The MIMETools Product

 The MIMETools product is alpha quality software.  It may not work as
 documented or at all.  If you encounter bugs in MIMETools, please
 report your problem to support@digicool.com or discuss it on the Zope 
 mailing list, zope@zope.org.

 Currently, the MIMETools product's only function is to provide the
 &lt;!--#mime--&gt; DTML tag.

 The &lt;!--#mime--&gt; tag is used to construct MIME containers.  The
 syntax of the &lt;!--#mime--&gt; tag is:


 &lt;!--#mime [type=x, disposition=y, encode=z]--&gt;

  Contents of first part

 &lt;!--#boundary [type=x, disposition=y, encode=z]--&gt; 

  Contents of second part
   
 &lt;!--#boundary [type=x, disposition=y, encode=z]--&gt; 

  Contents of nth part

 &lt;!--#/mime--&gt;


 The area of data between tags, called a block, is encoded into
 whatever is specified with the 'encode' tag attribute for that block.
 If no encoding is specified, 'base64' is defaulted.  Valid encoding
 options include 'base64', 'quoted-printable', 'uuencode',
 'x-uuencode', 'uue' and 'x-uue'.  If the 'encode' attribute is set to
 '7bit' no encoding is done on the block and the data is assumed to be
 in a valid MIME format.

 If the 'disposition' attribute is not specified for a certain block,
 then the 'Content-Disposition:' MIME header is not included in that
 block's MIME part.

 The entire MIME container, from the opening mime tag to the closing,
 has it's 'Content-Type:' MIME header set to 'multipart/mixed'.

 For example, the following DTML:

  &lt;!--#mime encode=7bit type=text/plain--&gt;
  This is the first part.
  &lt;!--#boundary encode=base64 type=text/plain--&gt;
  This is the second.
  &lt;!--#/mime--&gt;

 Is rendered to the following text:

  Content-Type: multipart/mixed;
      boundary="216.164.72.30.501.1550.923070182.795.22531"


  --216.164.72.30.501.1550.923070182.795.22531
  Content-Type: text/plain
  Content-Transfer-Encoding: 7bit

  This is the first part.

  --216.164.72.30.501.1550.923070182.795.22531
  Content-Type: text/plain
  Content-Transfer-Encoding: base64

  VGhpcyBpcyB0aGUgc2Vjb25kLgo=

  --216.164.72.30.501.1550.923070182.795.22531--


 The #mime tag is particulary handy in conjunction with the #sendmail
 tag.  This allows Zope to send attachments along with email.  Here is 
 an example:

  Create a DTML method called 'input' with the following code:

    &lt;!--#var standard_html_header--&gt;
    &lt;form method=post action="send" ENCTYPE="multipart/form-data"&gt;
    &lt;input type=file name="afile"&gt;&lt;br&gt;
    Send to:&lt;input type=textbox name="who"&gt;&lt;br&gt;
    &lt;input type=submit value="Send"&gt;
    &lt;/form&gt;
    &lt;!--#var standard_html_footer--&gt;


  Create another DTML Method called 'send' with the following code:

    &lt;!--#var standard_html_header--&gt;
    &lt;!--#sendmail smtphost=localhost --&gt;
    From: michel@digicool.com
    To: &lt;!--#var who--&gt;
    &lt;!--#mime type=text/plain encode=7bit--&gt;

    Hi &lt;!--#var who--&gt;, someone sent you this attachment.

    &lt;!--#boundary type=application/octet-stream disposition=attachment 
    encode=base64--&gt;&lt;!--#var "afile.read()"--&gt;&lt;!--#/mime--&gt;

    &lt;!--#/sendmail--&gt;

    Mail with attachment was sent.
    &lt;!--#var standard_html_footer--&gt;


  Notice that there is no blank line between the 'To:' header and the
  starting #mime tag.  If a blank line is inserted between them then
  the message will not be interpreted as multipart by the recieving mailreader.

  Also notice that there is no newline between the #boundary tag and
  the #var tag, or the end of the #var tag and the closing #mime tag.
  This is important, if you break the tags up with newlines then they
  will be encoded and included in the MIME part, which is probably not
  what you're after.

  As per the MIME spec, #mime tags may be nested within #mime tags arbitrarily.








</t>
<t tx="ekr.20040104185913.3389">&lt;&lt; copyright &gt;&gt;
__doc__='''MIMETools Product Initialization
$Id: __init__.py,v 1.3 2002/08/14 22:14:27 mj Exp $'''
__version__='$Revision: 1.3 $'[11:-2]

import MIMETag
</t>
<t tx="ekr.20040104185913.3390"></t>
<t tx="ekr.20040104185913.3391">&lt;&lt; MailHost declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3392">&lt;&lt; copyright &gt;&gt;
"""SMTP mail objects
$Id: MailHost.py,v 1.74.6.6 2003/07/07 16:12:04 andreasjung Exp $"""
__version__ = "$Revision: 1.74.6.6 $"[11:-2]

from Globals import Persistent, DTMLFile, InitializeClass
from smtplib import SMTP
from AccessControl.Role import RoleManager
from operator import truth
import Acquisition, sys, types, mimetools
import OFS.SimpleItem, re, quopri, rfc822
from cStringIO import StringIO
from AccessControl import ClassSecurityInfo
from AccessControl.Permissions import view_management_screens, \
                                      use_mailhost_services
from DateTime import DateTime

smtpError = "SMTP Error"
MailHostError = "MailHost Error"

manage_addMailHostForm=DTMLFile('dtml/addMailHost_form', globals())
</t>
<t tx="ekr.20040104185913.3393">def manage_addMailHost( self, id, title='', smtp_host='localhost'
                      , localhost='localhost', smtp_port=25
                      , timeout=1.0, REQUEST=None ):
    ' add a MailHost into the system '
    i = MailHost( id, title, smtp_host, smtp_port )   #create new mail host
    self._setObject( id,i )   #register it

    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(self.absolute_url()+'/manage_main')
</t>
<t tx="ekr.20040104185913.3394">add = manage_addMailHost

class MailBase(Acquisition.Implicit, OFS.SimpleItem.Item, RoleManager):
	&lt;&lt; class MailBase declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3395">'a mailhost...?'
meta_type='Mail Host'
manage=manage_main=DTMLFile('dtml/manageMailHost', globals())
manage_main._setName('manage_main')
index_html=None
security = ClassSecurityInfo()

timeout=1.0

manage_options=(
    (
    {'icon':'', 'label':'Edit',
     'action':'manage_main',
     'help':('MailHost','Mail-Host_Edit.stx')},
    )
    +RoleManager.manage_options
    +OFS.SimpleItem.Item.manage_options
    )


</t>
<t tx="ekr.20040104185913.3396">def __init__( self, id='', title='', smtp_host='localhost', smtp_port=25 ):
    """Initialize a new MailHost instance """
    self.id = id
    self.title = title
    self.smtp_host = str( smtp_host )
    self.smtp_port = int(smtp_port)
</t>
<t tx="ekr.20040104185913.3397"># staying for now... (backwards compatibility)
def _init(self, smtp_host, smtp_port):
    self.smtp_host=smtp_host
    self.smtp_port=smtp_port
</t>
<t tx="ekr.20040104185913.3398">security.declareProtected( 'Change configuration', 'manage_makeChanges' )
def manage_makeChanges(self,title,smtp_host,smtp_port, REQUEST=None):
    'make the changes'

    title=str(title)
    smtp_host=str(smtp_host)
    smtp_port=int(smtp_port)

    self.title=title
    self.smtp_host=smtp_host
    self.smtp_port=smtp_port
    if REQUEST is not None:
        msg = 'MailHost %s updated' % self.id
        return self.manage_main( self
                               , REQUEST
                               , manage_tabs_message=msg
                               )
</t>
<t tx="ekr.20040104185913.3399">security.declareProtected( use_mailhost_services, 'sendTemplate' )
def sendTemplate(trueself, self, messageTemplate,
                 statusTemplate=None, mto=None, mfrom=None,
                 encode=None, REQUEST=None):
    'render a mail template, then send it...'
    mtemplate = getattr(self, messageTemplate)
    messageText = mtemplate(self, trueself.REQUEST)
    messageText, mto, mfrom = _mungeHeaders( messageText, mto, mfrom)
    messageText=_encode(messageText, encode)
    self._send(mfrom, mto, messageText)

    if not statusTemplate: return "SEND OK"

    try:
        stemplate=getattr(self, statusTemplate)
        return stemplate(self, trueself.REQUEST)
    except:
        return "SEND OK"
</t>
<t tx="ekr.20040104185913.3400">security.declareProtected( use_mailhost_services, 'send' )
def send(self, messageText, mto=None, mfrom=None, subject=None,
         encode=None):

    messageText, mto, mfrom = _mungeHeaders( messageText, mto, mfrom, subject)
    messageText = _encode(messageText, encode)
    self._send(mfrom, mto, messageText)
</t>
<t tx="ekr.20040104185913.3401"># This is here for backwards compatibility only. Possibly it could
# be used to send messages at a scheduled future time, or via a mail queue?
security.declareProtected( use_mailhost_services, 'scheduledSend' )
scheduledSend = send

security.declareProtected( use_mailhost_services, 'simple_send' )
def simple_send(self, mto, mfrom, subject, body):
    body="From: %s\nTo: %s\nSubject: %s\n\n%s" % (
        mfrom, mto, subject, body)

    self._send( mfrom, mto, body )
</t>
<t tx="ekr.20040104185913.3402">security.declarePrivate( '_send' )
def _send( self, mfrom, mto, messageText ):
    """ Send the message """
    smtpserver = SMTP( self.smtp_host, int(self.smtp_port) )
    smtpserver.sendmail( mfrom, mto, messageText )
    smtpserver.quit()
</t>
<t tx="ekr.20040104185913.3403">InitializeClass( MailBase )

class MailHost(Persistent, MailBase):
	&lt;&lt; class MailHost declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3404">"persistent version"

</t>
<t tx="ekr.20040104185913.3405">def _encode(body, encode=None):
    if encode is None:
        return body
    mfile=StringIO(body)
    mo=mimetools.Message(mfile)
    if mo.getencoding() != '7bit':
        raise MailHostError, 'Message already encoded'
    newmfile=StringIO()
    newmfile.write(''.join(mo.headers))
    newmfile.write('Content-Transfer-Encoding: %s\n' % encode)
    if not mo.has_key('Mime-Version'):
        newmfile.write('Mime-Version: 1.0\n')
    newmfile.write('\n')
    mimetools.encode(mfile, newmfile, encode)
    return newmfile.getvalue()
</t>
<t tx="ekr.20040104185913.3406">def _mungeHeaders( messageText, mto=None, mfrom=None, subject=None):
    """Sets missing message headers, and deletes Bcc.
       returns fixed message, fixed mto and fixed mfrom"""
    mfile=StringIO(messageText.lstrip())
    mo=rfc822.Message(mfile)

    # Parameters given will *always* override headers in the messageText.
    # This is so that you can't override or add to subscribers by adding them to
    # the message text.
    if subject:
        mo['Subject'] = subject
    elif not mo.getheader('Subject'):
        mo['Subject'] = '[No Subject]'

    if mto:
        if isinstance(mto, types.StringType):
            mto = [rfc822.dump_address_pair(addr) for addr in rfc822.AddressList(mto) ]
        if not mo.getheader('To'):
            mo['To'] = ','.join(mto)
    else:
        mto = []
        for header in ('To', 'Cc', 'Bcc'):
            v = mo.getheader(header)
            if v:
                mto += [rfc822.dump_address_pair(addr) for addr in rfc822.AddressList(v)]
        if not mto:
            raise MailHostError, "No message recipients designated"

    if mfrom:
        mo['From'] = mfrom
    else:
        if mo.getheader('From') is None:
            raise MailHostError,"Message missing SMTP Header 'From'"
        mfrom = mo['From']

    if mo.getheader('Bcc'):
        mo.__delitem__('Bcc')

    if not mo.getheader('Date'):
        mo['Date'] = DateTime().rfc822()

    mo.rewindbody()
    finalmessage = mo
    finalmessage = mo.__str__() + '\n' + mfile.read()
    mfile.close()
    return finalmessage, mto, mfrom
</t>
<t tx="ekr.20040104185913.3407">MailHost


  The MailHost product provides support for sending email from
  within the Zope environment using MailHost objects.

  Email can optionally be encoded using Base64, Quoted-Printable
  or UUEncode encoding.
</t>
<t tx="ekr.20040104185913.3408">&lt;&lt; SendMailTag declarations &gt;&gt;
@others


String.commands['sendmail']=SendMailTag
</t>
<t tx="ekr.20040104185913.3409">&lt;&lt; copyright &gt;&gt;
__rcs_id__='$Id: SendMailTag.py,v 1.17.6.1 2003/01/14 19:15:44 regebro Exp $'
__version__='$Revision: 1.17.6.1 $'[11:-2]

from MailHost import MailBase, MailHostError
from DocumentTemplate.DT_Util import parse_params,render_blocks
from DocumentTemplate.DT_String import String
from socket import gethostname

</t>
<t tx="ekr.20040104185913.3410">class SendMailTag:
    '''the send mail tag, used like thus:

    &lt;dtml-sendmail mailhost="someMailHostID"&gt;
    to: person@their.machine.com
    from: me@mymachine.net
    subject: just called to say...

    boy howdy!
    &lt;/dtml-sendmail&gt;

    Text between the sendmail and /sendmail tags is processed
    by the MailHost machinery and delivered.  There must be at least
    one blank line seperating the headers (to/from/etc..) from the body
    of the message.

    Instead of specifying a MailHost, an smtphost may be specified
    ala 'smtphost="mail.mycompany.com" port=25' (port defaults to 25
    automatically).  Other parameters are

    * mailto -- person (or comma-seperated list of persons) to send the
    mail to.  If not specified, there **must** be a to: header in the
    message.

    * mailfrom -- person sending the mail (basically who the recipient can
    reply to).  If not specified, there **must** be a from: header in the
    message.

    * subject -- optional subject.  If not specified, there **must** be a
    subject: header in the message.

    * encode -- optional encoding. Possible values are: 'base64',
     'quoted-printable' and 'uuencode'.

    '''
	&lt;&lt; class SendMailTag declarations &gt;&gt;
	@others

    __call__=render</t>
<t tx="ekr.20040104185913.3411">name='sendmail'
blockContinuations=()
encode=None

</t>
<t tx="ekr.20040104185913.3412">def __init__(self, blocks):
    tname, args, section=blocks[0]
    args=parse_params(args, mailhost=None, mailto=None, mailfrom=None,
                      subject=None, smtphost=None, port='25',
                      encode=None)

    smtphost=None
    
    has_key=args.has_key
    if has_key('mailhost'): mailhost=args['mailhost']
    elif has_key('smtphost'): mailhost=smtphost=args['smtphost']
    elif has_key(''): mailhost=args['mailhost']=args['']
    else: raise MailHostError, 'No mailhost was specified in tag'

    for key in ('mailto', 'mailfrom', 'subject', 'port'):
        if not args.has_key(key):args[key]=''

    if has_key('encode') and args['encode'] not in \
    ('base64', 'quoted-printable', 'uuencode', 'x-uuencode',
     'uue', 'x-uue'):
        raise MailHostError, (
            'An unsupported encoding was specified in tag')

    if not smtphost:
        self.__name__=self.mailhost=mailhost
        self.smtphost=None
    else:
        self.__name__=self.smtphost=smtphost
        self.mailhost=None
    self.section=section
    self.args=args
    self.mailto=args['mailto']
    self.mailfrom=args['mailfrom']
    self.subject=None or args['subject']
    if args['port'] and type(args['port']) is type('s'):
        self.port=args['port']=int(args['port'])
    elif args['port']=='':
        self.port=args['port']=25
    else:
        self.port=args['port']
    if has_key('encode'):
        self.encode=args['encode']
    else: self.encode=None
</t>
<t tx="ekr.20040104185913.3413">def render(self, md):
    args=self.args
    has_key=args.has_key

    if self.mailhost:
        mhost=md[self.mailhost]
    elif self.smtphost:
        mhost=MailBase( smtp_host=self.smtphost, smtp_port=self.port )

    mhost.send(render_blocks(self.section.blocks, md),
               self.mailto, self.mailfrom,
               self.subject, self.encode
               )

    return ' '
</t>
<t tx="ekr.20040104185913.3414">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3415">&lt;&lt; copyright &gt;&gt;
__doc__='''MailHost Product Initialization
$Id: __init__.py,v 1.22 2002/08/14 22:14:51 mj Exp $'''
__version__='$Revision: 1.22 $'[11:-2]

import MailHost
import SendMailTag

</t>
<t tx="ekr.20040104185913.3416">def initialize(context):
    context.registerClass(
        MailHost.MailHost,
        permission='Add MailHost objects',
        constructors=(MailHost.manage_addMailHostForm,
                      MailHost.manage_addMailHost),
        icon='www/MailHost_icon.gif',
    )

    context.registerHelp()
    context.registerHelpTitle('Zope Help')
</t>
<t tx="ekr.20040104185913.3417">MailHost-1-3-0
</t>
<t tx="ekr.20040104185913.3418"></t>
<t tx="ekr.20040104185913.3419">&lt;&lt; MailHost declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3420">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3421">def manage_addMailHost(id, title='', smtp_host=None,
        localhost='localhost', smtp_port=25,
        timeout=1.0):
    """

    Add a mailhost object to an ObjectManager.

    """
</t>
<t tx="ekr.20040104185913.3422">class MailHost:
    """

    MailHost objects work as adapters to Simple Mail Transfer Protocol
    (SMTP) servers.  MailHosts are used by DTML 'sendmail' tags
    to find the proper host to deliver mail to.

    """
	&lt;&lt; class MailHost declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3423">__constructor__=manage_addMailHost

</t>
<t tx="ekr.20040104185913.3424">def send(messageText, mto=None, mfrom=None, subject=None,
         encode=None):
    """
    Sends an email message.
    The arguments are:

      messageText -- The mail message. It can either be a rfc822
      formed text with header fields, or just a body without any
      header fields. The other arguments given will override the
      header fields in the message, if they exist.

      mto -- A string or list of recipient(s) of the message.

      mfrom -- The address of the message sender.

      subject -- The subject of the message.

      encode -- The rfc822 defined encoding of the message.  The
      default of 'None' means no encoding is done.  Valid values
      are 'base64', 'quoted-printable' and 'uuencode'.

    """
</t>
<t tx="ekr.20040104185913.3425"></t>
<t tx="ekr.20040104185913.3426">&lt;&lt; testMailHost declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.3427">import os, sys, unittest

import string, cStringIO, re
import ZODB, Acquisition
from Products.MailHost.MailHost import MailHostError, _mungeHeaders

</t>
<t tx="ekr.20040104185913.3428">class TestMailHost( unittest.TestCase ):
	@others
</t>
<t tx="ekr.20040104185913.3429">def testAllHeaders( self ):
    msg = """To: recipient@domain.com
From: sender@domain.com
Subject: This is the subject

This is the message body."""
    # No additional info
    resmsg, resto, resfrom = _mungeHeaders( msg )
    self.failUnless(resto == ['recipient@domain.com'])
    self.failUnless(resfrom == 'sender@domain.com' )

    # Add duplicated info
    resmsg, resto, resfrom = _mungeHeaders( msg, 'recipient@domain.com', 'sender@domain.com', 'This is the subject' )
    self.failUnless(resto == ['recipient@domain.com'])
    self.failUnless(resfrom == 'sender@domain.com' )

    # Add extra info
    resmsg, resto, resfrom = _mungeHeaders( msg, 'recipient2@domain.com', 'sender2@domain.com', 'This is the real subject' )
    self.failUnless(resto == ['recipient2@domain.com'])
    self.failUnless(resfrom == 'sender2@domain.com' )
</t>
<t tx="ekr.20040104185913.3430">def testMissingHeaders( self ):
    msg = """X-Header: Dummy header

This is the message body."""
    # Doesn't specify to
    self.failUnlessRaises( MailHostError, _mungeHeaders, msg, mfrom='sender@domain.com' )
    # Doesn't specify from
    self.failUnlessRaises( MailHostError, _mungeHeaders, msg, mto='recipient@domain.com' )
</t>
<t tx="ekr.20040104185913.3431">def testNoHeaders( self ):
    msg = """This is the message body."""
    # Doesn't specify to
    self.failUnlessRaises( MailHostError, _mungeHeaders, msg, mfrom='sender@domain.com' )
    # Doesn't specify from
    self.failUnlessRaises( MailHostError, _mungeHeaders, msg, mto='recipient@domain.com' )
    # Specify all
    resmsg, resto, resfrom = _mungeHeaders( msg, 'recipient2@domain.com', 'sender2@domain.com', 'This is the real subject' )
    self.failUnless(resto == ['recipient2@domain.com'])
    self.failUnless(resfrom == 'sender2@domain.com' )
</t>
<t tx="ekr.20040104185913.3432">def testBCCHeader( self ):
    msg = "From: me@example.com\nBcc: many@example.com\n\nMessage text"
    # Specify only the "Bcc" header.  Useful for bulk emails.
    resmsg, resto, resfrom = _mungeHeaders(msg)
    self.failUnless(resto == ['many@example.com'])
    self.failUnless(resfrom == 'me@example.com' )
</t>
<t tx="ekr.20040104185913.3433">def testAddressParser( self ):
    msg = """To: "Name, Nick" &lt;recipient@domain.com&gt;, "Foo Bar" &lt;foo@domain.com&gt;
CC: "Web, Jack" &lt;jack@web.com&gt;
From: sender@domain.com
Subject: This is the subject

This is the message body."""
    
    # Test Address-Parser for To &amp; CC given in messageText
    
    resmsg, resto, resfrom = _mungeHeaders( msg )
    self.failUnless(resto == ['"Name, Nick" &lt;recipient@domain.com&gt;','"Foo Bar" &lt;foo@domain.com&gt;','"Web, Jack" &lt;jack@web.com&gt;'])
    self.failUnless(resfrom == 'sender@domain.com' )

    # Test Address-Parser for a given mto-string
    
    resmsg, resto, resfrom = _mungeHeaders( msg, mto= '"Public, Joe" &lt;pjoe@domain.com&gt;, "Foo Bar" &lt;foo@domain.com&gt;')

    self.failUnless(resto == ['"Public, Joe" &lt;pjoe@domain.com&gt;','"Foo Bar" &lt;foo@domain.com&gt;'])
    self.failUnless(resfrom == 'sender@domain.com' )
</t>
<t tx="ekr.20040104185913.3434">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestMailHost ) )
    return suite
</t>
<t tx="ekr.20040104185913.3435">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.3436"></t>
<t tx="ekr.20040104185913.3437">&lt;&lt; Draft declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040104185913.3438">&lt;&lt; copyright &gt;&gt;
import Globals, AccessControl.User
from Globals import Persistent
from Acquisition import Implicit
from OFS import SimpleItem

manage_addPrincipiaDraftForm=Globals.HTMLFile('dtml/draftAdd',globals())
</t>
<t tx="ekr.20040104185913.3439">def manage_addPrincipiaDraft(self, id, baseid, PATH_INFO, REQUEST=None):
    "Add a draft object"
    self._setObject(id, Draft(id, baseid, PATH_INFO))
    if REQUEST is not None: return self.manage_main(self,REQUEST)
</t>
<t tx="ekr.20040104185913.3440">class Draft(Persistent, Implicit, SimpleItem.Item):
	&lt;&lt; class Draft declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3441">"Daft objects"
_refid=''
_version='/version'
meta_type='Zope Draft'

__ac_permissions__=(
    ('Approve draft changes',
     ('manage_approve__draft__',
      'manage_Save__draft__','manage_Discard__draft__')
     ),
)

</t>
<t tx="ekr.20040104185913.3442">def __init__(self, id, baseid, PATH_INFO):
    self.id=id
    self._refid=baseid
    version=PATH_INFO
    l=version.rfind('/')
    if l &gt;= 0: version=version[:l]
    self._version="%s/%s" % (version, id)
    self.users__draft__=uf=AccessControl.User.UserFolder()
    self.__allow_groups__=uf
</t>
<t tx="ekr.20040104185913.3443">def icon(self):
    try: return getattr(self.aq_parent.aq_base,self._refid).icon
    except: return 'p_/broken'
</t>
<t tx="ekr.20040104185913.3444">def manage_options(self):
    try: return getattr(self.aq_parent.aq_base,self._refid).manage_options
    except: return ()
</t>
<t tx="ekr.20040104185913.3445">def title(self):
    return 'draft of '+self._refid
</t>
<t tx="ekr.20040104185913.3446">def title_and_id(self):
    nonempty=self.nonempty()
    if nonempty:
        return ('draft of %s (%s)'
                '&lt;/a&gt; &lt;a href="%s/users__draft__/manage_main"&gt;[Users]'
                '&lt;/a&gt; &lt;a href="%s/manage_approve__draft__"&gt;[Approve]'
                % (self._refid, self.id,
                   self.id,
                   self.id,
                   ))
    else:
        return ('draft of %s (%s)'
                '&lt;/a&gt; &lt;a href="%s/users__draft__/manage_main"&gt;[Users]'
                % (self._refid, self.id,
                   self.id,
                   ))
</t>
<t tx="ekr.20040104185913.3447">def __bobo_traverse__(self, REQUEST, name):
    if name[-9:]=='__draft__': return getattr(self, name)


    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        jar=Globals.VersionBase[self._version].jar
    else:
        # ZODB 3
        jar=db.open(self._version)
        cleanup=Cleanup()
        cleanup.__del__=jar.close
        REQUEST[Cleanup]=cleanup


    dself=getdraft(self, jar)

    ref=getattr(dself.aq_parent.aq_base,dself._refid).aq_base.__of__(dself)
    if hasattr(ref, name): return dself, ref, getattr(ref, name)
    return getattr(self, name)
</t>
<t tx="ekr.20040104185913.3448">def nonempty(self):
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        return Globals.VersionBase[self._version].nonempty()
    else:
        # ZODB 3
        return not db.versionEmpty(self._version)
</t>
<t tx="ekr.20040104185913.3449">manage_approve__draft__=Globals.HTMLFile('dtml/draftApprove', globals())

def manage_Save__draft__(self, remark, REQUEST=None):
    """Make version changes permanent"""
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        Globals.VersionBase[self._version].commit(remark)
    else:
        # ZODB 3
        s=self._version
        d=self._p_jar.getVersion()
        if d==s: d=''
        db.commitVersion(s, d)

    if REQUEST:
        REQUEST['RESPONSE'].redirect(REQUEST['URL2']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3450">def manage_Discard__draft__(self, REQUEST=None):
    'Discard changes made during the version'
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        Globals.VersionBase[self._version].abort()
    else:
        # ZODB 3
        db.abortVersion(self._version)

    if REQUEST:
        REQUEST['RESPONSE'].redirect(REQUEST['URL2']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3451">def manage_afterClone(self, item):
    self._version=''
</t>
<t tx="ekr.20040104185913.3452">def manage_afterAdd(self, item, container):
    if not self._version:
        self._version=self.absolute_url(1)
</t>
<t tx="ekr.20040104185913.3453">def manage_beforeDelete(self, item, container):
    if self.nonempty():
        raise 'Version Error', (
            'Attempt to %sdelete a non-empty version.&lt;p&gt;'
            ((self is not item) and 'indirectly ' or ''))
</t>
<t tx="ekr.20040104185913.3454">Globals.default__class_init__(Draft)

def getdraft(ob, jar):

    if hasattr(ob,'aq_parent'):
        return getdraft(ob.aq_self, jar).__of__(getdraft(ob.aq_parent, jar))

    if hasattr(ob,'_p_oid'): ob=jar[ob._p_oid]

    return ob
</t>
<t tx="ekr.20040104185913.3455">class Cleanup: pass
</t>
<t tx="ekr.20040104185913.3456">OFSP


  ODFS Providers Draft Folders and Versions.

  
</t>
<t tx="ekr.20040104185913.3457">&lt;&lt; copyright &gt;&gt;
"""Backward compatability!
"""
from Version import Version
Session=Version
</t>
<t tx="ekr.20040104185913.3458">&lt;&lt; Version declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3459">&lt;&lt; copyright &gt;&gt;
"""Version object"""

__version__='$Revision: 1.53 $'[11:-2]

import Globals, time
from AccessControl.Role import RoleManager
from Globals import MessageDialog
from Globals import Persistent
from Acquisition import Implicit
from OFS.SimpleItem import Item
from Globals import HTML
from App.Dialogs import MessageDialog
from OFS.ObjectManager import BeforeDeleteException

</t>
<t tx="ekr.20040104185913.3460">class VersionException(BeforeDeleteException): pass
</t>
<t tx="ekr.20040104185913.3461">manage_addVersionForm=Globals.DTMLFile('dtml/versionAdd', globals())

def manage_addVersion(self, id, title, REQUEST=None):
    """ """
    id=str(id)
    title=str(title)
    self=self.this()
    self._setObject(id, Version(id,title,REQUEST))
    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(self.absolute_url()+'/manage_main')
</t>
<t tx="ekr.20040104185913.3462">class Version(Persistent,Implicit,RoleManager,Item):
    """ """
	&lt;&lt; class Version declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3463">meta_type='Version'

manage_options=(
    (
    {'label':'Join/Leave', 'action':'manage_main',
     'help':('OFSP','Version_Join-Leave.stx')},
    {'label':'Save/Discard', 'action':'manage_end',
     'help':('OFSP','Version_Save-Discard.stx')},
    {'label':'Properties', 'action':'manage_editForm',
     'help':('OFSP','Version_Properties.stx')},
    )
    +RoleManager.manage_options
    +Item.manage_options
    )

__ac_permissions__=(
    ('View management screens', ('manage','manage_editForm', '')),
    ('Change Versions', ('manage_edit',)),
    ('Join/leave Versions',
     ('manage_main', 'enter','leave','leave_another')),
    ('Save/discard Version changes',
     ('manage_end', 'save','discard')),
    )

cookie=''

index_html=None # Ugh.

</t>
<t tx="ekr.20040104185913.3464">def __init__(self, id, title, REQUEST):
    self.id=id
    self.title=title
</t>
<t tx="ekr.20040104185913.3465">manage_main=Globals.DTMLFile('dtml/version', globals())
manage_end=Globals.DTMLFile('dtml/versionEnd', globals())
manage_editForm   =Globals.DTMLFile('dtml/versionEdit', globals())

def title_and_id(self):
    r=Version.inheritedAttribute('title_and_id')(self)
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        if Globals.VersionBase[self.cookie].nonempty(): return '%s *' % r
    else:
        # ZODB 3
        if not db.versionEmpty(self.cookie): return '%s *' % r

    return r
</t>
<t tx="ekr.20040104185913.3466">def manage_edit(self, title, REQUEST=None):
    """ """
    self.title=title
    if REQUEST: return MessageDialog(
                title  ='Success!',
                message='Your changes have been saved',
                action ='manage_main')
</t>
<t tx="ekr.20040104185913.3467">def enter(self, REQUEST, RESPONSE):
    """Begin working in a version"""
    RESPONSE.setCookie(
        Globals.VersionNameName, self.cookie,
        path=(REQUEST['BASEPATH1'] or '/'),
        )
    if (REQUEST.has_key('SERVER_SOFTWARE') and
        REQUEST['SERVER_SOFTWARE'][:9]=='Microsoft'):
        # IIS doesn't handle redirect headers correctly
        return MessageDialog(
            action=REQUEST['URL1']+'/manage_main',
            message=('If cookies are enabled by your browser, then '
                     'you should have joined version %s.'
                     % self.id)
            )
    return RESPONSE.redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3468">def leave(self, REQUEST, RESPONSE):
    """Temporarily stop working in a version"""
    RESPONSE.setCookie(
        Globals.VersionNameName,'No longer active',
        expires="Mon, 25-Jan-1999 23:59:59 GMT",
        path=(REQUEST['BASEPATH1'] or '/'),
        )
    if (REQUEST.has_key('SERVER_SOFTWARE') and
        REQUEST['SERVER_SOFTWARE'][:9]=='Microsoft'):
        # IIS doesn't handle redirect headers correctly
        return MessageDialog(
            action=REQUEST['URL1']+'/manage_main',
            message=('If cookies are enabled by your browser, then '
                     'you should have left version %s.'
                     % self.id)
            )
    return RESPONSE.redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3469">def leave_another(self, REQUEST, RESPONSE):
    """Leave a version that may not be the current version"""
    return self.leave(REQUEST, RESPONSE)
</t>
<t tx="ekr.20040104185913.3470">def save(self, remark, REQUEST=None):
    """Make version changes permanent"""
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        Globals.VersionBase[self.cookie].commit(remark)
    else:
        # ZODB 3
        s=self.cookie
        d=self._p_jar.getVersion()
        if d==s: d=''
        get_transaction().note(remark)
        db.commitVersion(s, d)

    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3471">def discard(self, remark='', REQUEST=None):
    'Discard changes made during the version'
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        Globals.VersionBase[self.cookie].abort()
    else:
        # ZODB 3
        get_transaction().note(remark)
        db.abortVersion(self.cookie)

    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(REQUEST['URL1']+'/manage_main')
</t>
<t tx="ekr.20040104185913.3472">def nonempty(self):
    try: db=self._p_jar.db()
    except:
        # BoboPOS 2
        return Globals.VersionBase[self.cookie].nonempty()
    else:
        # ZODB 3
        return not db.versionEmpty(self.cookie)
</t>
<t tx="ekr.20040104185913.3473"># Prevent copy/move/rename of versions. It's better that way, really.

def _canCopy(self, op=0):
    return 0
</t>
<t tx="ekr.20040104185913.3474">def manage_afterClone(self, item):
    self.cookie=''
</t>
<t tx="ekr.20040104185913.3475">def manage_afterAdd(self, item, container):
    if not self.cookie:
        # Physical path
        self.cookie='/'.join(self.getPhysicalPath())
</t>
<t tx="ekr.20040104185913.3476">def manage_beforeDelete(self, item, container):
    if self.nonempty():
        raise VersionException(
            'Attempt to %sdelete a non-empty version.&lt;br /&gt;' %
            ((self is not item) and 'indirectly ' or ''))

    try: REQUEST=self.REQUEST
    except: pass
    else:
        v=self.cookie
        if REQUEST.get(Globals.VersionNameName, '') == v:
            raise VersionException(
                'An attempt was made to delete a version, %s, or an\n'
                'object containing %s while\n working in the\n'
                'version %s.  This would lead to a &amp;quot;version\n'
                'paradox&amp;quot;.  The object containing the deleted\n'
                'object would be locked and it would be impossible\n'
                'to clear the lock by saving or discarding the\n'
                'version, because the version would no longer\n'
                'be accessable.&lt;p&gt;\n'
                % (v,v,v))
</t>
<t tx="ekr.20040104185913.3477">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3478">&lt;&lt; copyright &gt;&gt;
__doc__='''Object system core
$Id: __init__.py,v 1.37 2002/08/14 22:16:04 mj Exp $'''
__version__='$Revision: 1.37 $'[11:-2]

import Version, OFS.Image, OFS.Folder, AccessControl.User
import OFS.DTMLMethod, OFS.DTMLDocument, OFS.PropertySheets
import ZClasses.ObjectManager

from ZClasses import createZClassForBase

createZClassForBase( OFS.DTMLMethod.DTMLMethod, globals()
                   , 'ZDTMLMethod', 'DTML Method' )
createZClassForBase( OFS.DTMLDocument.DTMLDocument, globals()
                   , 'ZDTMLDocument', 'DTML Document' )
createZClassForBase( OFS.Image.Image, globals()
                   , 'ZImage', 'Image' )
createZClassForBase( OFS.Image.File, globals()
                   , 'ZFile', 'File' )
createZClassForBase( OFS.Folder.Folder, globals()
                   , 'ZFolder', 'Folder' )
createZClassForBase( AccessControl.User.UserFolder, globals()
                   , 'ZUserFolder', 'User Folder' )
createZClassForBase( AccessControl.User.User, globals()
                   , 'ZUser', 'User' )

# This is the new way to initialize products.  It is hoped
# that this more direct mechanism will be more understandable.
</t>
<t tx="ekr.20040104185913.3479">def initialize(context):

    perm='Add Documents, Images, and Files'

    context.registerClass(
        OFS.DTMLMethod.DTMLMethod,
        permission=perm,
        constructors=(OFS.DTMLMethod.addForm, OFS.DTMLMethod.addDTMLMethod,),
        icon='images/dtmlmethod.gif',
        legacy=(
            ('manage_addDocument', OFS.DTMLMethod.addDTMLMethod),
            ('manage_addDTMLMethod', OFS.DTMLMethod.addDTMLMethod),
            )
        )

    context.registerClass(
        OFS.DTMLDocument.DTMLDocument,
        permission=perm,
        constructors=(OFS.DTMLDocument.addForm,
                      OFS.DTMLDocument.addDTMLDocument),
        icon='images/dtmldoc.gif',
        legacy=(('manage_addDTMLDocument', OFS.DTMLDocument.addDTMLDocument),),
        )


    context.registerClass(
        OFS.Image.Image,
        permission=perm,
        constructors=(('imageAdd',OFS.Image.manage_addImageForm),
                      OFS.Image.manage_addImage),
        icon='images/Image_icon.gif',
        legacy=(OFS.Image.manage_addImage,),
        )


    context.registerClass(
        OFS.Image.File,
        permission=perm,
        constructors=(('fileAdd',OFS.Image.manage_addFileForm),
                      OFS.Image.manage_addFile),
        icon='images/File_icon.gif',
        legacy=(OFS.Image.manage_addFile,),
        )

    context.registerClass(
        OFS.Folder.Folder,
        constructors=(OFS.Folder.manage_addFolderForm,
                      OFS.Folder.manage_addFolder),
        icon='images/Folder_icon.gif',
        legacy=(OFS.Folder.manage_addFolder,),
        )


    context.registerClass(
        AccessControl.User.UserFolder,
        constructors=(AccessControl.User.manage_addUserFolder,),
        icon='images/UserFolder_icon.gif',
        legacy=(AccessControl.User.manage_addUserFolder,),
        )


    context.registerClass(
        Version.Version,
        constructors=(Version.manage_addVersionForm,
                      Version.manage_addVersion),
        icon='images/version.gif'
        )

    #context.registerClass(
    #    Draft.Draft,
    #    constructors=(Draft.manage_addPrincipiaDraftForm,
    #             Draft.manage_addPrincipiaDraft),
    #    icon='images/draft.gif'
    #    )

    context.registerZClass(ZClasses.ObjectManager.ZObjectManager)

    context.registerHelp()
    context.registerHelpTitle('Zope Help')
</t>
<t tx="ekr.20040104185913.3480">OFSP-1-0-0</t>
<t tx="ekr.20040104185913.3481"></t>
<t tx="ekr.20040104185913.3482">&lt;&lt; AccessControl declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3483">"""
AccessControl: Security functions and classes

  The functions and classes in this module are available to
  Python-based Scripts and Page Templates.

"""

</t>
<t tx="ekr.20040104185913.3484">def getSecurityManager():
    """
    Returns the security manager. See the 'SecurityManager' class.
    """
</t>
<t tx="ekr.20040104185913.3485">class SecurityManager:
    """
    A security manager provides methods for checking access and
    managing executable context and policies
    """
	@others
</t>
<t tx="ekr.20040104185913.3486">def validate(accessed=None, container=None, name=None, value=None,
             roles=None):
    """
    Validate access.

    Arguments:

    accessed -- the object that was being accessed

    container -- the object the value was found in

    name -- The name used to access the value

    value -- The value retrieved though the access.

    roles -- The roles of the object if already known.

    The arguments may be provided as keyword arguments. Some of
    these arguments may be omitted, however, the policy may
    reject access in some cases when arguments are omitted.  It
    is best to provide all the values possible.

    permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3487">def validateValue(self, value, roles=None):
    """
    Convenience for common case of simple value validation.

    permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3488">def checkPermission(self, permission, object):
    """
    Check whether the security context allows the given permission
    on the given object.

    permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3489">def getUser(self):
    """
    Get the current authenticated user. See the
    'AuthenticatedUser' class.

    permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3490">def calledByExecutable(self):
    """
    Return a boolean value indicating if this context was called
    by an executable.

    permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3491">&lt;&lt; AuthenticatedUser declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3492">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3493">class AuthenticatedUser:
    """
    This interface needs to be supported by objects that
    are returned by user validation and used for access control.
    """
	@others
</t>
<t tx="ekr.20040104185913.3494">def getUserName():
    """
    Return the name of a user

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3495">def has_role(roles, object=None):
    """
    Return true if the user has at least one role from a list of
    roles, optionally in the context of an object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3496">def has_permission(permission, object):
    """
    Return true if the user has a permission on an object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3497">def getRoles():
    """
    Return a list of the user's roles.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3498">def getRolesInContext(object):
    """
    Return the list of roles assigned to the user, including local
    roles assigned in context of an object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3499">def getId():
    """
    Get the ID of the user. The ID can be used from
    Python to get the user from the user's UserDatabase.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3500">def getDomains():
    """
    Return the list of domain restrictions for a user.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3501">&lt;&lt; DTMLDocument declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3502">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3503">def manage_addDocument(id, title):
    """
    Add a DTML Document to the current ObjectManager
    """
</t>
<t tx="ekr.20040104185913.3504">class DTMLDocument:
    """
    A DTML Document is a Zope object that contains and executes DTML
    code. It is useful to represent web pages.
    """
	&lt;&lt; class DTMLDocument declarations &gt;&gt;
	@others

    __constructor__=manage_addDocument</t>
<t tx="ekr.20040104185913.3505">__extends__=(
    'OFSP.ObjectManagerItem.ObjectManagerItem',
    'OFSP.PropertyManager.PropertyManager',
    )

</t>
<t tx="ekr.20040104185913.3506">def __call__(client=None, REQUEST={}, RESPONSE=None, **kw):
    """

    Calling a DTMLDocument causes the Document to interpret the DTML
    code that it contains.  The method returns the result of the
    interpretation, which can be any kind of object.

    To accomplish its task, DTML Document often needs to resolve various
    names into objects.  For example, when the code '&amp;lt;dtml-var
    spam&amp;gt;' is executed, the DTML engine tries to resolve the name
    'spam'.

    In order to resolve names, the Document must be passed a
    namespace to look them up in.  This can be done several ways:

      * By passing a 'client' object -- If the argument 'client' is
        passed, then names are looked up as attributes on the
        argument.

      * By passing a 'REQUEST' mapping -- If the argument 'REQUEST'
        is passed, then names are looked up as items on the
        argument.  If the object is not a mapping, an TypeError
        will be raised when a name lookup is attempted.

      * By passing keyword arguments -- names and their values can
        be passed as keyword arguments to the Document.

    The namespace given to a DTML Document is the composite of
    these three methods.  You can pass any number of them or none
    at all. Names are looked up first in the keyword arguments,
    then in the client, and finally in the mapping.

    A DTMLDocument implicitly pass itself as a client argument in
    addition to the specified client, so names are looked up in
    the DTMLDocument itself.

    Passing in a namespace to a DTML Document is often referred to
    as providing the Document with a *context*.

    DTML Documents can be called three ways.

    From DTML

      A DTML Document can be called from another DTML
      Method or Document::

        &lt;dtml-var standard_html_header&gt;
          &lt;dtml-var aDTMLDocument&gt;
        &lt;dtml-var standard_html_footer&gt;

      In this example, the Document 'aDTMLDocument' is being called
      from another DTML object by name.  The calling method
      passes the value 'this' as the client argument and the
      current DTML namespace as the REQUEST argument.  The above
      is identical to this following usage in a DTML Python
      expression::

        &lt;dtml-var standard_html_header&gt;
          &lt;dtml-var "aDTMLDocument(_.None, _)"&gt;
        &lt;dtml-var standard_html_footer&gt;

    From Python

      Products, External Methods, and Scripts can call a DTML
      Document in the same way as calling a DTML Document from a
      Python expression in DTML; as shown in the previous example.

    By the Publisher

      When the URL of a DTML Document is fetched from Zope, the
      DTML Document is called by the publisher.  The REQUEST
      object is passed as the second argument to the Document.

    Permission -- 'View'

    """
</t>
<t tx="ekr.20040104185913.3507">def manage_edit(data, title):
    """
    Change the DTML Document, replacing its contents with 'data'
    and
    changing its title.

    The data argument may be a file object or a string.

    Permission -- 'Change DTML Documents'
    """
</t>
<t tx="ekr.20040104185913.3508">def document_src():
    """
    Returns the unrendered source text of the DTML Document.

    Permission -- 'View management screens'
    """
</t>
<t tx="ekr.20040104185913.3509">def get_size():
    """
    Returns the size of the unrendered source text of the DTML
    Document in bytes.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3510">&lt;&lt; DTMLMethod declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3511">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3512">def manage_addDTMLMethod(id, title):
    """
    Add a DTML Method to the current ObjectManager
    """
</t>
<t tx="ekr.20040104185913.3513">class DTMLMethod:
    """
    A DTML Method is a Zope object that contains and executes DTML
    code. It can act as a template to display other objects. It can
    also hold small pieces of content which are inserted into other
    DTML Documents or DTML Methods.

    The DTML Method's id is available via the 'document_id'
    variable and the title is available via the 'document_title'
    variable.

    """
	&lt;&lt; class DTMLMethod declarations &gt;&gt;
	@others

    __constructor__ = manage_addDTMLMethod</t>
<t tx="ekr.20040104185913.3514">__extends__=('OFSP.ObjectManagerItem.ObjectManagerItem',)

</t>
<t tx="ekr.20040104185913.3515">def __call__(client=None, REQUEST={}, **kw):
    """

    Calling a DTMLMethod causes the Method to interpret the DTML
    code that it contains.  The method returns the result of the
    interpretation, which can be any kind of object.

    To accomplish its task, DTML Method often needs to resolve various
    names into objects.  For example, when the code '&amp;lt;dtml-var
    spam&amp;gt;' is executed, the DTML engine tries to resolve the name
    'spam'.

    In order to resolve names, the Method must be passed a
    namespace to look them up in.  This can be done several ways:

      * By passing a 'client' object -- If the argument 'client' is
        passed, then names are looked up as attributes on the
        argument.

      * By passing a 'REQUEST' mapping -- If the argument 'REQUEST'
        is passed, then names are looked up as items on the
        argument.  If the object is not a mapping, an TypeError
        will be raised when a name lookup is attempted.

      * By passing keyword arguments -- names and their values can
        be passed as keyword arguments to the Method.

    The namespace given to a DTML Method is the composite of
    these three methods.  You can pass any number of them or none
    at all. Names will be looked up first in the keyword argument,
    next in the client and finally in the mapping.

    Unlike DTMLDocuments, DTMLMethods do not look up names in
    their own instance dictionary.

    Passing in a namespace to a DTML Method is often referred to
    as providing the Method with a *context*.

    DTML Methods can be called three ways:

    From DTML

      A DTML Method can be called from another DTML Method or
      Document::

        &lt;dtml-var standard_html_header&gt;
          &lt;dtml-var aDTMLMethod&gt;
        &lt;dtml-var standard_html_footer&gt;

      In this example, the Method 'aDTMLMethod' is being called
      from another DTML object by name.  The calling method passes
      the value 'this' as the client argument and the current DTML
      namespace as the REQUEST argument.  The above is identical
      to this following usage in a DTML Python expression::

        &lt;dtml-var standard_html_header&gt;
          &lt;dtml-var "aDTMLMethod(_.None, _)"&gt;
        &lt;dtml-var standard_html_footer&gt;

    From Python

      Products, External Methods, and Scripts can call a DTML
      Method in the same way as calling a DTML Method from a
      Python expression in DTML; as shown in the previous example.

    By the Publisher

      When the URL of a DTML Method is fetched from Zope, the DTML
      Method is called by the publisher.  The REQUEST object is
      passed as the second argument to the Method.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3516">def manage_edit(data, title):
    """
    Change the DTML Method, replacing its contents with 'data' and
    changing its title.

    The data argument may be a file object or a string.

    Permission -- 'Change DTML Methods'
    """
</t>
<t tx="ekr.20040104185913.3517">def document_src():
    """
    Returns the unrendered source text of the DTML Method.

    Permission -- 'View management screens'
    """
</t>
<t tx="ekr.20040104185913.3518">def get_size():
    """
    Returns the size of the unrendered source text of the DTML
    Method in bytes.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3519">&lt;&lt; DateTime declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3520">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3521">class DateTime:

    """
    The DateTime object provides an interface for working with dates
    and times in various formats.  DateTime also provides methods for
    calendar operations, date and time arithmetic and formatting.

    DateTime objects represent instants in time and provide
    interfaces for controlling its representation without
    affecting the absolute value of the object.

    DateTime objects may be created from a wide variety of string
    or numeric data, or may be computed from other DateTime objects.
    DateTimes support the ability to convert their representations
    to many major timezones, as well as the ability to create a
    DateTime object in the context of a given timezone.

    DateTime objects provide partial
    numerical behavior:

      - Two date-time objects can be subtracted to obtain a time,
        in days between the two.

      - A date-time object and a positive or negative number may
        be added to obtain a new date-time object that is the given
        number of days later than the input date-time object.

      - A positive or negative number and a date-time object may
        be added to obtain a new date-time object that is the given
        number of days later than the input date-time object.

      - A positive or negative number may be subtracted from a
        date-time object to obtain a new date-time object that is
        the given number of days earlier than the input date-time
        object.

    DateTime objects may be converted to integer, long, or float
    numbers of days since January 1, 1901, using the standard int,
    long, and float functions (Compatibility Note: int, long and
    float return the number of days since 1901 in GMT rather than
    local machine timezone). DateTime objects also provide access
    to their value in a float format usable with the python time
    module, provided that the value of the object falls in the
    range of the epoch-based time module.

    A DateTime object should be considered immutable; all conversion
    and numeric operations return a new DateTime object rather than
    modify the current object.

    A DateTime object always maintains its value as an absolute
    UTC time, and is represented in the context of some timezone
    based on the arguments used to create the object. A DateTime
    object's methods return values based on the timezone context.

    Note that in all cases the local machine timezone is used for
    representation if no timezone is specified.

    DateTimes may be created with from zero to
    seven arguments.

      - If the function is called with no arguments, then the
        current date/time is returned, represented in the
        timezone of the local machine.

      - If the function is invoked with a single string argument
        which is a recognized timezone name, an object representing
        the current time is returned, represented in the specified
        timezone.

      - If the function is invoked with a single string argument
        representing a valid date/time, an object representing
        that date/time will be returned.

        As a general rule, any date-time representation that is
        recognized and unambiguous to a resident of North America is
        acceptable.(The reason for this qualification is that
        in North America, a date like: 2/1/1994 is interpreted
        as February 1, 1994, while in some parts of the world,
        it is interpreted as January 2, 1994.) A date/time
        string consists of two components, a date component and
        an optional time component, separated by one or more
        spaces. If the time component is omitted, 12:00am is
        assumed. Any recognized timezone name specified as the
        final element of the date/time string will be used for
        computing the date/time value. (If you create a DateTime
        with the string 'Mar 9, 1997 1:45pm US/Pacific', the
        value will essentially be the same as if you had captured
        time.time() at the specified date and time on a machine in
        that timezone)::

          e=DateTime("US/Eastern")
          # returns current date/time, represented in US/Eastern.

          x=DateTime("1997/3/9 1:45pm")
          # returns specified time, represented in local machine zone.

          y=DateTime("Mar 9, 1997 13:45:00")
          # y is equal to x


        The date component consists of year, month, and day
        values. The year value must be a one-, two-, or
        four-digit integer. If a one- or two-digit year is
        used, the year is assumed to be in the twentieth
        century. The month may be an integer, from 1 to 12, a
        month name, or a month abbreviation, where a period may
        optionally follow the abbreviation. The day must be an
        integer from 1 to the number of days in the month. The
        year, month, and day values may be separated by
        periods, hyphens, forward slashes, or spaces. Extra
        spaces are permitted around the delimiters. Year,
        month, and day values may be given in any order as long
        as it is possible to distinguish the components. If all
        three components are numbers that are less than 13,
        then a month-day-year ordering is assumed.

        The time component consists of hour, minute, and second
        values separated by colons.  The hour value must be an
        integer between 0 and 23 inclusively. The minute value
        must be an integer between 0 and 59 inclusively. The
        second value may be an integer value between 0 and
        59.999 inclusively. The second value or both the minute
        and second values may be omitted. The time may be
        followed by am or pm in upper or lower case, in which
        case a 12-hour clock is assumed.

      - If the DateTime function is invoked with a single
        Numeric argument, the number is assumed to be
        a floating point value such as that returned by
        time.time().

        A DateTime object is returned that represents
        the gmt value of the time.time() float represented in
        the local machine's timezone.

      - If the function is invoked with two numeric arguments,
        then the first is taken to be an integer year and the
        second argument is taken to be an offset in days from
        the beginning of the year, in the context of the local
        machine timezone.
        The date-time value returned is the given offset number of
        days from the beginning of the given year, represented in
        the timezone of the local machine. The offset may be positive
        or negative.
        Two-digit years are assumed to be in the twentieth
        century.

      - If the function is invoked with two arguments, the first
        a float representing a number of seconds past the epoch
        in gmt (such as those returned by time.time()) and the
        second a string naming a recognized timezone, a DateTime
        with a value of that gmt time will be returned, represented
        in the given timezone.::

          import time
          t=time.time()

          now_east=DateTime(t,'US/Eastern')
          # Time t represented as US/Eastern

          now_west=DateTime(t,'US/Pacific')
          # Time t represented as US/Pacific

          # now_east == now_west
          # only their representations are different



      - If the function is invoked with three or more numeric
        arguments, then the first is taken to be an integer
        year, the second is taken to be an integer month, and
        the third is taken to be an integer day. If the
        combination of values is not valid, then a
        DateTimeError is raised. Two-digit years are assumed
        to be in the twentieth century. The fourth, fifth, and
        sixth arguments specify a time in hours, minutes, and
        seconds; hours and minutes should be positive integers
        and seconds is a positive floating point value, all of
        these default to zero if not given. An optional string may
        be given as the final argument to indicate timezone (the
        effect of this is as if you had taken the value of time.time()
        at that time on a machine in the specified timezone).

    If a string argument passed to the DateTime constructor cannot be
    parsed, it will raise DateTime.SyntaxError. Invalid date, time, or
    timezone components will raise a DateTime.DateTimeError.

    The module function Timezones() will return a list of the
    timezones recognized by the DateTime module. Recognition of
    timezone names is case-insensitive.

    """
	@others
</t>
<t tx="ekr.20040104185913.3522">def timeTime():
    """
    Return the date/time as a floating-point number in UTC, in the
    format used by the python time module.  Note that it is
    possible to create date/time values with DateTime that have no
    meaningful value to the time module.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3523">def toZone(z):
    """
    Return a DateTime with the value as the current object,
    represented in the indicated timezone.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3524">def isFuture():
    """
    Return true if this object represents a date/time later than
    the time of the call

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3525">def isPast():
    """
    Return true if this object represents a date/time earlier than
    the time of the call

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3526">def isCurrentYear():
    """
    Return true if this object represents a date/time that falls
    within the current year, in the context of this object\'s
    timezone representation

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3527">def isCurrentMonth():
    """
    Return true if this object represents a date/time that falls
    within the current month, in the context of this object\'s
    timezone representation

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3528">def isCurrentDay():
    """
    Return true if this object represents a date/time that falls
    within the current day, in the context of this object\'s
    timezone representation

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3529">def isCurrentHour():
    """
    Return true if this object represents a date/time that falls
    within the current hour, in the context of this object\'s
    timezone representation

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3530">def isCurrentMinute():
    """
    Return true if this object represents a date/time that falls
    within the current minute, in the context of this object\'s
    timezone representation

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3531">def earliestTime():
    """
    Return a new DateTime object that represents the earliest
    possible time (in whole seconds) that still falls within the
    current object's day, in the object's timezone context

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3532">def latestTime():
    """
    Return a new DateTime object that represents the latest
    possible time (in whole seconds) that still falls within the
    current object's day, in the object's timezone context

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3533">def greaterThan(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time greater than the specified DateTime or time module
    style time.  Revised to give more correct results through
    comparison of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3534">def greaterThanEqualTo(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time greater than or equal to the specified DateTime or
    time module style time.  Revised to give more correct results
    through comparison of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3535">def equalTo(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time equal to the specified DateTime or time module style
    time.  Revised to give more correct results through comparison
    of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3536">def notEqualTo(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time not equal to the specified DateTime or time module
    style time.  Revised to give more correct results through
    comparison of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3537">def lessThan(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time less than the specified DateTime or time module
    style time.  Revised to give more correct results through
    comparison of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3538">def lessThanEqualTo(t):
    """
    Compare this DateTime object to another DateTime object OR a
    floating point number such as that which is returned by the
    python time module. Returns true if the object represents a
    date/time less than or equal to the specified DateTime or time
    module style time.  Revised to give more correct results
    through comparison of long integer milliseconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3539">def isLeapYear():
    """
    Return true if the current year (in the context of the
    object's timezone) is a leap year

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3540">def dayOfYear():
    """
    Return the day of the year, in context of the timezone
    representation of the object

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3541"># Component access
def parts():
    """
    Return a tuple containing the calendar year, month, day, hour,
    minute second and timezone of the object

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3542">def timezone():
    """
    Return the timezone in which the object is represented.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3543">def year():
    """
    Return the calendar year of the object

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3544">def month():
    """
    Return the month of the object as an integer

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3545">def Month():
    """
    Return the full month name

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3546">def aMonth():
    """
    Return the abbreviated month name.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3547">def Mon():
    """
    Compatibility: see aMonth

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3548">def pMonth():
    """
    Return the abbreviated (with period) month name.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3549">def Mon_():
    """
    Compatibility: see pMonth

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3550">def day():
    """
    Return the integer day

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3551">def Day():
    """
    Return the full name of the day of the week

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3552">def DayOfWeek():
    """
    Compatibility: see Day

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3553">def aDay():
    """
    Return the abbreviated name of the day of the week

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3554">def pDay():
    """
    Return the abbreviated (with period) name of the day of the
    week

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3555">def Day_():
    """
    Compatibility: see pDay

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3556">def dow():
    """
    Return the integer day of the week, where Sunday is 0

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3557">def dow_1():
    """
    Return the integer day of the week, where Sunday is 1

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3558">def h_12():
    """
    Return the 12-hour clock representation of the hour

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3559">def h_24():
    """
    Return the 24-hour clock representation of the hour

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3560">def ampm():
    """
    Return the appropriate time modifier (am or pm)

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3561">def hour():
    """
    Return the 24-hour clock representation of the hour

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3562">def minute():
    """
    Return the minute

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3563">def second():
    """
    Return the second

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3564">def millis():
    """
    Return the millisecond since the epoch in GMT.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3565">def strftime(format):
    """

    Return date time string formatted according to 'format'

    See Python's
    "time.strftime":http://www.python.org/doc/current/lib/module-time.html
    function.
    """
</t>
<t tx="ekr.20040104185913.3566"># General formats from previous DateTime
def Date():
    """
    Return the date string for the object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3567">def Time():
    """
    Return the time string for an object to the nearest second.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3568">def TimeMinutes():
    """
    Return the time string for an object not showing seconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3569">def AMPM():
    """
    Return the time string for an object to the nearest second.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3570">def AMPMMinutes():
    """
    Return the time string for an object not showing seconds.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3571">def PreciseTime():
    """
    Return the time string for the object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3572">def PreciseAMPM():
    """
    Return the time string for the object.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3573">def yy():
    """
    Return calendar year as a 2 digit string

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3574">def mm():
    """
    Return month as a 2 digit string

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3575">def dd():
    """
    Return day as a 2 digit string

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3576">def rfc822():
    """
    Return the date in RFC 822 format

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3577"># New formats
def fCommon():
    """
    Return a string representing the object's value
    in the format: March 1, 1997 1:45 pm

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3578">def fCommonZ():
    """
    Return a string representing the object's value
    in the format: March 1, 1997 1:45 pm US/Eastern

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3579">def aCommon():
    """
    Return a string representing the object's value
    in the format: Mar 1, 1997 1:45 pm

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3580">def aCommonZ():
    """
    Return a string representing the object's value
    in the format: Mar 1, 1997 1:45 pm US/Eastern

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3581">def pCommon():
    """
    Return a string representing the object's value
    in the format: Mar. 1, 1997 1:45 pm

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3582">def pCommonZ():
    """
    Return a string representing the object's value
    in the format: Mar. 1, 1997 1:45 pm US/Eastern

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3583">def ISO():
    """
    Return the object in ISO standard format

    Dates are output as: YYYY-MM-DD HH:MM:SS

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3584">def HTML4():
    """
    Return the object in the format used in the HTML4.0 specification,
    one of the standard forms in ISO8601.

    See "HTML 4.0 Specification":http://www.w3.org/TR/NOTE-datetime

    Dates are output as: YYYY-MM-DDTHH:MM:SSZ
    T, Z are literal characters.
    The time is in UTC.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3585">&lt;&lt; File declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3586">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3587">def manage_addFile(id, file='', title='', precondition='', content_type=''):
    """

    Add a new File object.

    Creates a new File object 'id' with the contents of 'file'

    """
</t>
<t tx="ekr.20040104185913.3588">class File:
    """
    A File is a Zope object that contains file content.  A File object
    can be used to upload or download file information with Zope.

    Using a File object in Zope is easy.  The most common usage is
    to display the contents of a file object in a web page.  This is
    done by simply referencing the object from DTML::

      &lt;dtml-var standard_html_header&gt;
        &lt;dtml-var FileObject&gt;
      &lt;dtml-var standard_html_footer&gt;

    A more complex example is presenting the File object for
    download by the user.  The next example displays a link to every
    File object in a folder for the user to download::

      &lt;dtml-var standard_html_header&gt;
      &lt;ul&gt;
        &lt;dtml-in "ObjectValues('File')"&gt;
          &lt;li&gt;&lt;a href="&lt;dtml-var absolute_url&gt;"&gt;&lt;dtml-var
          id&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/dtml-in&gt;
      &lt;/ul&gt;
      &lt;dtml-var standard_html_footer&gt;

    In this example, the 'absolute_url' method and 'id' are used to
    create a list of HTML hyperlinks to all of the File objects in
    the current Object Manager.

    Also see ObjectManager for details on the 'objectValues'
    method.
    """
	&lt;&lt; class File declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3589">__constructor__=manage_addFile

__extends__=(
    'OFSP.ObjectManagerItem.ObjectManagerItem',
    'OFSP.PropertyManager.PropertyManager',
    )

</t>
<t tx="ekr.20040104185913.3590">def update_data(data, content_type=None, size=None):
    """
    Updates the contents of the File with 'data'.

    The 'data' argument must be a string. If 'content_type' is not
    provided, then a content type will not be set. If size is not
    provided, the size of the file will be computed from 'data'.

    Permission -- Python only
    """
</t>
<t tx="ekr.20040104185913.3591">def getSize():
    """
    Returns the size of the file in bytes.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3592">def getContentType():
    """
    Returns the content type of the file.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3593">&lt;&lt; Folder declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3594">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3595">def manage_addFolder(id, title):
    """
    Add a Folder to the current ObjectManager

    Permission -- 'Add Folders'
    """
</t>
<t tx="ekr.20040104185913.3596">class Folder:
    """

    A Folder is a generic container object in Zope.

    Folders are the most common ObjectManager subclass in Zope.

    """
	&lt;&lt; class Folder declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3597">__extends__=(
    'OFSP.ObjectManagerItem.ObjectManagerItem',
    'OFSP.ObjectManager.ObjectManager',
    'OFSP.PropertyManager.PropertyManager',
    )

__constructor__ = manage_addFolder
</t>
<t tx="ekr.20040104185913.3598">&lt;&lt; Image declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3599">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3600">def manage_addImage(id, file, title='', precondition='', content_type=''):
    """

    Add a new Image object.

    Creates a new Image object 'id' with the contents of 'file'.

    """
</t>
<t tx="ekr.20040104185913.3601">class Image:
    """
    An Image is a Zope object that contains image content.  An Image
    object can be used to upload or download image information with
    Zope.

    Image objects have two properties the define their dimension,
    'height' and 'width'. These are calculated when the image is
    uploaded. For image types that Zope does not understand, these
    properties may be undefined.

    Using a Image object in Zope is easy.  The most common usage is
    to display the contents of an image object in a web page.  This
    is done by simply referencing the object from DTML::

      &lt;dtml-var standard_html_header&gt;
        &lt;dtml-var ImageObject&gt;
      &lt;dtml-var standard_html_footer&gt;

    This will generate an HTML IMG tag referencing the URL to the
    Image. This is equivalent to::

      &lt;dtml-var standard_html_header&gt;
        &lt;dtml-with ImageObject&gt;
          &lt;img src="&lt;dtml-var absolute_url&gt;"&gt;
        &lt;/dtml-with&gt;
      &lt;dtml-var standard_html_footer&gt;

    You can control the image display more precisely with the 'tag'
    method. For example::

      &lt;dtml-var "ImageObject.tag(border='5', align='left')"&gt;

    """
	&lt;&lt; class Image declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3602">__constructor__=manage_addImage

__extends__=('OFSP.File.File',)

</t>
<t tx="ekr.20040104185913.3603">def tag(height=None, width=None, alt=None,
        scale=0, xscale=0, yscale=0, **args):
    """
    This method returns a string which contains an HTML IMG tag
    reference to the image.

    Optionally, the 'height', 'width', 'alt', 'scale', 'xscale'
    and 'yscale' arguments can be provided which are turned into
    HTML IMG tag attributes. Note, 'height' and 'width' are
    provided by default, and 'alt' comes from the 'title'
    property.

    Keyword arguments may be provided to support other or future IMG
    tag attributes.  The one exception to this is the HTML Cascading
    Style Sheet tag 'class'.  Because the word 'class' is a reserved
    keyword in Python, you must instead use the keyword argument
    'css_class'.  This will be turned into a 'class' HTML tag attribute
    on the rendered 'img' tag.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3604">&lt;&lt; ObjectManager declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3605">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3606">class ObjectManager:
    """
    An ObjectManager contains other Zope objects. The contained
    objects are Object Manager Items.

    To create an object inside an object manager use 'manage_addProduct'::

      self.manage_addProduct['OFSP'].manage_addFolder(id, title)

    In DTML this would be::

        &lt;dtml-call "manage_addProduct['OFSP'].manage_addFolder(id, title)"&gt;

    These examples create a new Folder inside the current
    ObjectManager.

    'manage_addProduct' is a mapping that provides access to product
    constructor methods. It is indexed by product id.

    Constructor methods are registered during product initialization
    and should be documented in the API docs for each addable
    object.
    """
	@others
</t>
<t tx="ekr.20040104185913.3607">def objectIds(type=None):
    """
    This method returns a list of the ids of the contained
    objects.

    Optionally, you can pass an argument specifying what object
    meta_type(es) to restrict the results to. This argument can be
    a string specifying one meta_type, or it can be a list of
    strings to specify many.

    Example::

      &lt;dtml-in objectIds&gt;
        &lt;dtml-var sequence-item&gt;
      &lt;dtml-else&gt;
        There are no sub-objects.
      &lt;/dtml-in&gt;

    This DTML code will display all the ids of the objects
    contained in the current Object Manager.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3608">def objectValues(type=None):
    """
    This method returns a sequence of contained objects.

    Like objectItems and objectIds, it accepts one argument,
    either a string or a list to restrict the results to objects
    of a given meta_type or set of meta_types.

    Example::

      &lt;dtml-in expr="objectValues('Folder')"&gt;
        &lt;dtml-var icon&gt;
        This is the icon for the: &lt;dtml-var id&gt; Folder&lt;br&gt;.
      &lt;dtml-else&gt;
        There are no Folders.
      &lt;/dtml-in&gt;

    The results were restricted to Folders by passing a
    meta_type to 'objectValues' method.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3609">def objectItems(type=None):
    """
    This method returns a sequence of (id, object) tuples.

    Like objectValues and objectIds, it accepts one argument,
    either a string or a list to restrict the results to objects
    of a given meta_type or set of meta_types.

    Each tuple's first element is the id of an object contained in
    the Object Manager, and the second element is the object
    itself.

    Example::

      &lt;dtml-in objectItems&gt;
       id: &lt;dtml-var sequence-key&gt;,
       type: &lt;dtml-var meta_type&gt;
      &lt;dtml-else&gt;
        There are no sub-objects.
      &lt;/dtml-in&gt;

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3610">def superValues(type):
    """
    This method returns a list of objects of a given meta_type(es)
    contained in the Object Manager and all its parent Object
    Managers.

    The type argument specifies the meta_type(es). It can be a string
    specifying one meta_type, or it can be a list of strings to
    specify many.

    Permission -- Python only
    """
</t>
<t tx="ekr.20040104185913.3611">def manage_delObjects(ids):
    """
    Removes one or more children from the Object Manager. The
    'ids' argument is either a list of child ids, or a single
    child id.

    Permission -- 'Delete objects'
    """
</t>
<t tx="ekr.20040104185913.3612">def __getitem__(id):
    """
    Returns a child object given a child id. If there is no child
    with the given id, a KeyError is raised. This method makes it easy
    to refer to children that have id with file extensions. For
    example::

      page=folder['index.html']

    Note: this function only finds children; it doesn't return
    properties or other non-child attributes.

    Note: this function doesn't use acquisition to find
    children. It only returns direct children of the Object
    Manager. By contrast, using dot notation or 'getattr' will
    locate children (and other attributes) via acquisition if
    necessary.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3613">def setBrowserDefaultId(id='', acquire=0):
    """
    Sets the id of the object or method used as the default method when
    the object manager is published. If acquire is set then the default
    method id will be acquired from the parent container.

    Permission -- 'Manage folderish settings'
    """
</t>
<t tx="ekr.20040104185913.3614">def getBrowserDefaultId(acquire=0):
    """
    Returns the id of the object or method used as the default when the
    object manager is published. By default, this setting is acquired. If
    the acquire argument is true, then the return value will be acquired
    from the parent if it is not set locally. Otherwise, None is returned
    if the default id is not set on this object manager.

    Permission -- 'View'
    """
</t>
<t tx="ekr.20040104185913.3615">&lt;&lt; ObjectManagerItem declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3616">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3617">class ObjectManagerItem:
    """
    A Zope object that can be contained within an Object Manager.
    Almost all Zope objects that can be managed through the web are
    Object Manager Items.

    ObjectMangerItems have these instance
    attributes:

      'title' -- The title of the object.

        This is an optional one-line string description of the object.

      'meta_type' --  A short name for the type of the object.

        This is the name that shows up in product add list for the
        object and is used when filtering objects by type.

        This attribute is provided by the object's class and should
        not be changed directly.

      'REQUEST' -- The current web request.

        This object is acquired and should not be set.
    """
	@others
</t>
<t tx="ekr.20040104185913.3618">def getId():
    """
    Returns the object's id.

    The 'id' is the unique name of the object within its parent
    object manager. This should be a string, and can contain
    letters, digits, underscores, dashes, commas, and spaces.

    This method replaces direct access to the 'id' attribute.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3619">def title_or_id():
    """
    If the title is not blank, return it, otherwise
    return the id.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3620">def title_and_id():
    """
    If the title is not blank, the return the title
    followed by the id in parentheses. Otherwise return the id.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3621">def manage_workspace():
    """

    This is the web method that is called when a user selects an
    item in a object manager contents view or in the Zope
    Management navigation view.

    Permission -- 'View management screens'
    """
</t>
<t tx="ekr.20040104185913.3622">def this():
    """
    Return the object.

    This turns out to be handy in two situations. First, it
    provides a way to refer to an object in DTML expressions.

    The second use for this is rather deep. It provides a way to
    acquire an object without getting the full context that it was
    acquired from.  This is useful, for example, in cases where
    you are in a method of a non-item subobject of an item and you
    need to get the item outside of the context of the subobject.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3623">def absolute_url(relative=None):
    """
    Return the absolute url to the object.

    If the relative argument is provided with a true value, then
    the URL returned is relative to the site object. Note, if
    virtual hosts are being used, then the path returned is a
    logical, rather than a physical path.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3624">def getPhysicalRoot():
    """
    Returns the top-level Zope Application object.

    Permission -- Python only
    """
</t>
<t tx="ekr.20040104185913.3625">def getPhysicalPath():
    """
    Get the path of an object from the root, ignoring virtual
    hosts.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3626">def unrestrictedTraverse(path, default=None):
    """
    Return the object obtained by traversing the given path from
    the object on which the method was called. This method begins
    with "unrestricted" because (almost) no security checks are
    performed.

    If an object is not found then the 'default' argument will be
    returned.

    Permission -- Python only
    """
</t>
<t tx="ekr.20040104185913.3627">def restrictedTraverse(path, default=None):
    """
    Return the object obtained by traversing the given path from
    the object on which the method was called, performing security
    checks along the way.

    If an object is not found then the 'default' argument will be
    returned.

    Permission -- Always available
    """
</t>
<t tx="ekr.20040104185913.3628">&lt;&lt; PropertyManager declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3629">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3630">class PropertyManager:
    """
    A Property Manager object has a collection of typed attributes
    called properties. Properties can be managed through the web or
    via DTML.

    In addition to having a type, properties can be writable or
    read-only and can have default values.
    """
	@others
</t>
<t tx="ekr.20040104185913.3631">def getProperty(id, d=None):
    """
    Return the value of the property 'id'. If the property is not
    found the optional second argument or None is returned.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3632">def getPropertyType(id):
    """
    Get the type of property 'id'. Returns None if no such
    property exists.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3633">def hasProperty(id):
    """
    Returns a true value if the Property Manager has the property
    'id'. Otherwise returns a false value.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3634">def propertyIds():
    """
    Returns a list of property ids.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3635">def propertyValues():
    """
    Returns a list of property values.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3636">def propertyItems():
    """
    Return a list of (id, property) tuples.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3637">def propertyMap():
    """
    Returns a tuple of mappings, giving meta-data for properties.
    The meta-data includes 'id', 'type', and 'mode'.

    Permission -- 'Access contents information'
    """
</t>
<t tx="ekr.20040104185913.3638">&lt;&lt; PropertySheet declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3639">&lt;&lt; copyright &gt;&gt;

</t>
<t tx="ekr.20040104185913.3640">class PropertySheet:
    """

    A PropertySheet is an abstraction for organizing and working
    with a set of related properties. Conceptually it acts like a
    container for a set of related properties and meta-data describing
    those properties. A PropertySheet may or may not provide a web
    interface for managing its properties.

    """
	@others
</t>
<t tx="ekr.20040104185913.3641">def xml_namespace():
    """

    Return a namespace string usable as an xml namespace
    for this property set. This may be an empty string if
    there is no default namespace for a given property sheet
    (especially property sheets added in ZClass definitions).

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3642">def getProperty(id, d=None):
    """

    Get the property 'id', returning the optional second
    argument or None if no such property is found.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3643">def getPropertyType(id):
    """

    Get the type of property 'id'. Returns None if no such
    property exists.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3644">def hasProperty(id):
    """

    Returns true if 'self' has a property with the given 'id',
    false otherwise.

    Permission -- 'Access contents information'

    """
</t>
<t tx="ekr.20040104185913.3645">def propertyIds():
    """

    Returns a list of property ids.

    Permission --  'Access contents information'

    """
</t>
<t tx="ekr.20040104185913.3646">def propertyValues():
    """

    Returns a list of actual property values.

    Permission -- 'Access contents information'

    """
</t>
<t tx="ekr.20040104185913.3647">def propertyItems():
    """

    Return a list of (id, property) tuples.

    Permission -- 'Access contents information'

    """
</t>
<t tx="ekr.20040104185913.3648">def propertyMap():
    """

    Returns a tuple of mappings, giving meta-data for properties.

    Permssion -- Python only

    """
</t>
<t tx="ekr.20040104185913.3649">def propertyInfo():
    """

    Returns a mapping containing property meta-data.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3650">def manage_addProperty(id, value, type, REQUEST=None):
    """

    Add a new property with the given 'id', 'value' and 'type'.

    These are the
    property types:

      'boolean' -- 1 or 0.

      'date' -- A 'DateTime' value, for example '12/31/1999 15:42:52 PST'.

      'float' -- A decimal number, for example '12.4'.

      'int' -- An integer number, for example, '12'.

      'lines' -- A list of strings, one per line.

      'long' -- A long integer, for example '12232322322323232323423'.

      'string' -- A string of characters, for example 'This is a string'.

      'text' -- A multi-line string, for example a paragraph.

      'tokens' -- A list of strings separated by white space, for example
      'one two three'.

      'selection' -- A string selected by a pop-up menu.

      'multiple selection' -- A list of strings selected by a selection list.

    This method will use the passed in 'type' to try to convert
    the 'value' argument to the named type. If the given 'value'
    cannot be converted, a ValueError will be raised.

    The value given for 'selection' and 'multiple selection'
    properites may be an attribute or method name.  The attribute
    or method must return a sequence values.

    If the given 'type' is not recognized, the 'value' and 'type'
    given are simply stored blindly by the object.

    If no value is passed in for 'REQUEST', the method will return
    'None'. If a value is provided for 'REQUEST' (as it will when
    called via the web), the property management form for the
    object will be rendered and returned.

    This method may be called via the web, from DTML or from
    Python code.

    Permission -- 'Manage Properties'

    """
</t>
<t tx="ekr.20040104185913.3651">def manage_changeProperties(REQUEST=None, **kw):
    """

    Change existing object properties by passing either a mapping
    object as 'REQUEST' containing name:value pairs or by passing
    name=value keyword arguments.

    Some objects have "special" properties defined by product
    authors that cannot be changed. If you try to change one of
    these properties through this method, an error will be raised.

    Note that no type checking or conversion happens when this
    method is called, so it is the caller's responsibility to
    ensure that the updated values are of the correct type.
    *This should probably change*.

    If a value is provided for 'REQUEST' (as it will be when
    called via the web), the method will return an HTML message
    dialog. If no REQUEST is passed, the method returns 'None' on
    success.

    This method may be called via the web, from DTML or from
    Python code.

    Permission -- 'Manage Properties'

    """
</t>
<t tx="ekr.20040104185913.3652">def manage_delProperties(ids=None, REQUEST=None):
    """

    Delete one or more properties with the given 'ids'. The 'ids'
    argument should be a sequence (tuple or list) containing the
    ids of the properties to be deleted. If 'ids' is empty no
    action will be taken. If any of the properties named in 'ids'
    does not exist, an error will be raised.

    Some objects have "special" properties defined by product
    authors that cannot be deleted. If one of these properties is
    named in 'ids', an HTML error message is returned.

    If no value is passed in for 'REQUEST', the method will return
    None. If a value is provided for 'REQUEST' (as it will be when
    called via the web), the property management form for the
    object will be rendered and returned.

    This method may be called via the web, from DTML or from
    Python code.

    Permission -- 'Manage Properties'

    """
</t>
<t tx="ekr.20040104185913.3653">&lt;&lt; PropertySheets declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3654">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3655">class PropertySheets:
    """

    A PropertySheet is an abstraction for organizing and working with
    a set of related properties. Conceptually it acts like a container
    for a set of related properties and meta-data describing those
    properties. PropertySheet objects are accessed through a
    PropertySheets object that acts as a collection of PropertySheet
    instances.

    Objects that support property sheets (objects that support the
    PropertyManager interface or ZClass objects) have a
    'propertysheets' attribute (a PropertySheets instance) that is the
    collection of PropertySheet objects. The PropertySheets object
    exposes an interface much like a Python mapping, so that
    individual PropertySheet objects may be accessed via
    dictionary-style key indexing.

    """
	@others
</t>
<t tx="ekr.20040104185913.3656">def values():
    """

    Return a sequence of all of the PropertySheet objects
    in the collection.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3657">def items():
    """

    Return a sequence containing an '(id, object)' tuple for
    each PropertySheet object in the collection.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3658">def get(name, default=None):
    """

    Return the PropertySheet identified by 'name', or the value
    given in 'default' if the named PropertySheet is not found.

    Permission -- Python only

    """
</t>
<t tx="ekr.20040104185913.3659">&lt;&lt; Request declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3660">&lt;&lt; copyright &gt;&gt;



</t>
<t tx="ekr.20040104185913.3661">class Request:

    """

    The request object encapsulates all of the information regarding
    the current request in Zope.  This includes, the input headers,
    form data, server data, and cookies.

    The request object is a mapping object that represents a
    collection of variable to value mappings.  In addition, variables
    are divided into five categories:

      - Environment variables

          These variables include input headers, server data, and
          other request-related data.  The variable names are as &lt;a
          href="http://hoohoo.ncsa.uiuc.edu/cgi/env.html"&gt;specified&lt;/a&gt;
          in the &lt;a
          href="http://hoohoo.ncsa.uiuc.edu/cgi/interface.html"&gt;CGI
          specification&lt;/a&gt;

      - Form data

          These are data extracted from either a URL-encoded query
          string or body, if present.

      - Cookies

          These are the cookie data, if present.

      - Lazy Data

          These are callables which are deferred until explicitly
          referenced, at which point they are resolved (called) and
          the result stored as "other" data, ie regular request data.

          Thus, they are "lazy" data items.  An example is SESSION objects.

          Lazy data in the request may only be set by the Python
          method set_lazy(name,callable) on the REQUEST object.  This
          method is not callable from DTML or through the web.

      - Other

          Data that may be set by an application object.

    The request object may be used as a mapping object, in which case
    values will be looked up in the order: environment variables,
    other variables, form data, and then cookies.

    These special variables are set in
    the Request:

      'PARENTS' -- A list of the objects traversed to get to the
      published object. So, 'PARENTS[0]' would be the ancestor of
      the published object.

      'REQUEST' -- The Request object.

      'RESPONSE' -- The Response object.

      'PUBLISHED' -- The actual object published as a result of
      url traversal.

      'URL' -- The URL of the Request without query string.

      *URLn* -- 'URL0' is the same as 'URL'. 'URL1' is the same as
      'URL0' with the last path element removed. 'URL2' is the same
      as 'URL1' with the last element removed. Etcetera.

        For example if URL='http://localhost/foo/bar', then
        URL1='http://localhost/foo' and URL2='http://localhost'.

      *URLPATHn* -- 'URLPATH0' is the path portion of 'URL',
      'URLPATH1' is the path portion of 'URL1', and so on.

        For example if URL='http://localhost/foo/bar', then
        URLPATH1='/foo' and URLPATH2='/'.

      *BASEn* -- 'BASE0' is the URL up to but not including the Zope
      application object. 'BASE1' is the URL of the Zope application
      object. 'BASE2' is the URL of the Zope application object with
      an additional path element added in the path to the published
      object. Etcetera.

        For example if URL='http://localhost/Zope.cgi/foo/bar', then
        BASE0='http://localhost', BASE1='http://localhost/Zope.cgi',
        and BASE2='http://localhost/Zope.cgi/foo'.

      *BASEPATHn* -- 'BASEPATH0' is the path portion of 'BASE0',
      'BASEPATH1' is the path portion of 'BASE1', and so on.
      'BASEPATH1' is the externally visible path to the root Zope
      folder, equivalent to CGI's 'SCRIPT_NAME', but virtual-host aware.

        For example if URL='http://localhost/Zope.cgi/foo/bar', then
        BASEPATH0='/', BASEPATH1='/Zope.cgi', and BASEPATH2='/Zope.cgi/foo'.

    """
	@others
</t>
<t tx="ekr.20040104185913.3662">def set(name, value):
    """

    Create a new name in the REQUEST object and assign it a value.
    This name and value is stored in the 'Other' category.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3663">def get_header(name, default=None):
    """

    Return the named HTTP header, or an optional default argument
    or None if the header is not found. Note that both original
    and CGI header names without the leading 'HTTP_' are
    recognized, for example, 'Content-Type', 'CONTENT_TYPE' and
    'HTTP_CONTENT_TYPE' should all return the Content-Type header,
    if available.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3664">def has_key(key):
    """

    Returns a true value if the REQUEST object contains key,
    returns a false value otherwise.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3665">def keys():
    """

    Returns a sorted sequence of all keys in the REQUEST object.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3666">def items():
    """

    Returns a sequence of (key, value) tuples for all the keys in
    the REQUEST object.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3667">def values():
    """

    Returns a sequence of values for all the keys in the REQUEST
    object.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3668">def setServerURL(protocol=None, hostname=None, port=None):
    """

    Sets the specified elements of 'SERVER_URL', also affecting
    'URL', 'URLn', 'BASEn', and 'absolute_url()'.

    Provides virtual hosting support.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3669">def setVirtualRoot(path, hard=0):
    """

    Alters 'URL', 'URLn', 'URLPATHn', 'BASEn', 'BASEPATHn', and
    'absolute_url()' so that the current object has path 'path'.
    If 'hard' is true, 'PARENTS' is emptied.

    Provides virtual hosting support.  Intended to be called from
    publishing traversal hooks.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3670">def text():
    """
    Returns information about the request as text. This is useful
    for debugging purposes. The returned text lists form contents,
    cookies, special variables, and evironment variables.

    Permissions -- Always available
    """
</t>
<t tx="ekr.20040104185913.3671">&lt;&lt; Response declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3672">&lt;&lt; copyright &gt;&gt;


</t>
<t tx="ekr.20040104185913.3673">class Response:

    """

    The Response object represents the response to a Zope request.

    """
	@others
</t>
<t tx="ekr.20040104185913.3674">def setStatus(status, reason=None):
    '''

    Sets the HTTP status code of the response; the argument may
    either be an integer or one of the following strings:

        OK,
        Created,
        Accepted,
        NoContent,
        MovedPermanently,
        MovedTemporarily,
        NotModified,
        BadRequest,
        Unauthorized,
        Forbidden,
        NotFound,
        InternalError,
        NotImplemented,
        BadGateway,
        ServiceUnavailable

    that will be converted to the correct integer value.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3675">def setHeader(name, value):
    '''

    Sets an HTTP return header "name" with value "value", clearing
    the previous value set for the header, if one exists. If the
    literal flag is true, the case of the header name is
    preserved, otherwise word-capitalization will be performed on
    the header name on output.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3676">def addHeader(name, value):
    '''

    Set a new HTTP return header with the given value, while
    retaining any previously set headers with the same name.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3677">def setBase(base):
    """
    
    Set the base URL for the returned document. If the
    document already has a base tag, or if the base
    argument is None, no tag will be inserted.


    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3678">def appendCookie(name, value):
    '''

    Returns an HTTP header that sets a cookie on cookie-enabled
    browsers with a key "name" and value "value". If a value for the
    cookie has previously been set in the response object, the new
    value is appended to the old one separated by a colon.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3679">def expireCookie(name, **kw):
    '''

    Cause an HTTP cookie to be removed from the browser

    The response will include an HTTP header that will remove the cookie
    corresponding to "name" on the client, if one exists. This is
    accomplished by sending a new cookie with an expiration date
    that has already passed. Note that some clients require a path
    to be specified - this path must exactly match the path given
    when creating the cookie. The path can be specified as a keyword
    argument.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3680">def setCookie(name,value,**kw):
    '''

    Set an HTTP cookie on the browser

    The response will include an HTTP header that sets a cookie on
    cookie-enabled browsers with a key "name" and value
    "value". This overwrites any previously set value for the
    cookie in the Response object.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3681">def appendHeader(name, value, delimiter=","):
    '''

    Append a value to a header.

    Sets an HTTP return header "name" with value "value",
    appending it following a comma if there was a previous value
    set for the header.

    Permission -- Always available

    '''
</t>
<t tx="ekr.20040104185913.3682">def redirect(location, lock=0):
    """

    Cause a redirection without raising an error. If the "lock"
    keyword argument is passed with a true value, then the HTTP
    redirect response code will not be changed even if an error
    occurs later in request processing (after redirect() has
    been called).

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3683">def write(data):
    """
    Return data as a stream

    HTML data may be returned using a stream-oriented interface.
    This allows the browser to display partial results while
    computation of a response to proceed.

    The published object should first set any output headers or
    cookies on the response object.

    Note that published objects must not generate any errors
    after beginning stream-oriented output.

    Permission -- Always available

    """
</t>
<t tx="ekr.20040104185913.3684">@others
</t>
<t tx="ekr.20040104185913.3685">class UserFolder:
    """
    User Folder objects are containers for user objects. Programmers can
    work with collections of user objects using the API shared by User
    Folder implementations.
    """
	@others
</t>
<t tx="ekr.20040104185913.3686">def getUser(name):
    """
    Returns the user object specified by name.  If there is no
    user named 'name' in the user folder, return None.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3687">def getUsers():
    """
    Returns a sequence of all user objects which reside in the user
    folder.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3688">def getUserNames():
    """
    Returns a sequence of names of the users which reside in the user
    folder.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3689">def userFolderAddUser(name, password, roles, domains, **kw):
    """
    API method for creating a new user object. Note that not all
    user folder implementations support dynamic creation of user
    objects. Implementations that do not support dynamic creation
    of user objects will raise an error for this method.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3690">def userFolderEditUser(name, password, roles, domains, **kw):
    """
    API method for changing user object attributes. Note that not
    all user folder implementations support changing of user object
    attributes. Implementations that do not support changing of user
    object attributes will raise an error for this method.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3691">def userFolderDelUsers(names):
    """
    API method for deleting one or more user objects. Note that not
    all user folder implementations support deletion of user objects.
    Implementations that do not support deletion of user objects
    will raise an error for this method.

    Permission -- Manage users
    """
</t>
<t tx="ekr.20040104185913.3692">"""
math: Python 'math' module

  The 'math' module provides trigonometric and other math
  functions. It is a standard Python module.

  Since Zope 2.4 requires Python 2.1, make sure to consult the Python
  2.1 documentation.

  See Also

    "Python 'math'
    module":http://www.python.org/doc/current/lib/module-math.html
    documentation at Python.org
"""
</t>
<t tx="ekr.20040104185913.3693">"""
random: Python 'random' module

  The 'random' module provides pseudo-random number functions. With
  it, you can generate random numbers and select random elements from
  sequences. This module is a standard Python module.

  Since Zope 2.4 requires Python 2.1, make sure to consult the Python
  2.1 documentation.

  See Also

    "Python 'random'
    module":http://www.python.org/doc/current/lib/module-random.html
    documentation at Python.org
"""
</t>
<t tx="ekr.20040104185913.3694">&lt;&lt; sequence declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3695">"""
sequence: Sequence sorting module

  This module provides a 'sort' function for use with DTML, Page
  Templates, and Python-based Scripts.
"""

</t>
<t tx="ekr.20040104185913.3696">def sort(seq, sort):
    """
    Sort the sequence *seq* of objects by the optional sort schema
    *sort*.  *sort* is a sequence of tuples '(key, func, direction)'
    that describe the sort order.

    key -- Attribute of the object to be sorted.

    func -- Defines the compare function (optional).  Allowed values:

      "cmp" -- Standard Python comparison function

      "nocase" -- Case-insensitive comparison

      "strcoll" or "locale" -- Locale-aware string comparison

      "strcoll_nocase" or "locale_nocase" -- Locale-aware
      case-insensitive string comparison

      other -- A specified, user-defined comparison function, should
      return 1, 0, -1.

      direction -- defines the sort direction for the key (optional).
      (allowed values: "asc", "desc")

    DTML Examples

      Sort child object (using the 'objectValues' method) by id (using
      the 'getId' method), ignoring case::

        &lt;dtml-in expr="_.sequence.sort(objectValues(),
                                       (('getId', 'nocase'),))"&gt;
          &lt;dtml-var getId&gt; &lt;br&gt;
        &lt;/dtml-in&gt;

      Sort child objects by title (ignoring case) and date (from newest
      to oldest)::

        &lt;dtml-in expr="_.sequence.sort(objectValues(),
                                       (('title', 'nocase'),
                                        ('bobobase_modification_time',
                                        'cmp', 'desc')
                                       ))"&gt;
          &lt;dtml-var title&gt; &lt;dtml-var bobobase_modification_time&gt; &lt;br&gt;
        &lt;/dtml-in&gt;

    Page Template Examples

      You can use the 'sequence.sort' function in Python expressions
      to sort objects. Here's an example that mirrors the DTML example
      above::

        &lt;table tal:define="objects here/objectValues;
                           sort_on python:(('title', 'nocase', 'asc'),
                                           ('bobobase_modification_time', 'cmp', 'desc'));
                           sorted_objects python:sequence.sort(objects, sort_on)"&gt;
          &lt;tr tal:repeat="item sorted_objects"&gt;
            &lt;td tal:content="item/title"&gt;title&lt;/td&gt;
            &lt;td tal:content="item/bobobase_modification_time"&gt;
              modification date&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;

      This example iterates over a sorted list of object, drawing a
      table row for each object. The objects are sorted by title and
      modification time.

    See Also

      "Python cmp function":http://www.python.org/doc/lib/built-in-funcs.html

    """
</t>
<t tx="ekr.20040104185913.3697">"""
string: Python 'string' module

  The 'string' module provides string manipulation, conversion, and
  searching functions. It is a standard Python module.

  Since Zope 2.4 requires Python 2.1, make sure to consult the Python
  2.1 documentation.

  See Also

    "Python 'string'
    module":http://www.python.org/doc/current/lib/module-string.html
    documentation at Python.org
"""
</t>
<t tx="ekr.20040104185913.3698"></t>
<t tx="ekr.20040104185913.3699">Page Template changes

  This file contains change information for the current release. 
  Change information for previous versions can be found in the
  file HISTORY.txt.

    Version 1.5.0

      Features Added

        - Error reporting is improved, with line numbers added.

        - In the ZMI, errors are separated from the text and highlighted.

        - A template can be marked explicitly as XML or HTML by giving
        it a boolean 'is_html' property.

        - New icon, provided by Michael R. Bernstein.

      Bugs Fixed

        - The starting properties could be deleted.  This is only
        fixed for new templates.
</t>
<t tx="ekr.20040104185913.3700">&lt;&lt; Expressions declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3701">&lt;&lt; copyright &gt;&gt;

"""Page Template Expression Engine

Page Template-specific implementation of TALES, with handlers
for Python expressions, string literals, and paths.
"""

__version__='$Revision: 1.36.6.9 $'[11:-2]

import re, sys
from TALES import Engine, CompilerError, _valid_name, NAME_RE, \
     Undefined, Default, _parse_expr
from Acquisition import aq_base, aq_inner, aq_parent


_engine = None
</t>
<t tx="ekr.20040104185913.3702">def getEngine():
    global _engine
    if _engine is None:
        from PathIterator import Iterator
        _engine = Engine(Iterator)
        installHandlers(_engine)
    return _engine
</t>
<t tx="ekr.20040104185913.3703">def installHandlers(engine):
    reg = engine.registerType
    pe = PathExpr
    for pt in ('standard', 'path', 'exists', 'nocall'):
        reg(pt, pe)
    reg('string', StringExpr)
    reg('python', PythonExpr)
    reg('not', NotExpr)
    reg('defer', DeferExpr)
</t>
<t tx="ekr.20040104185913.3704">if sys.modules.has_key('Zope'):
    import AccessControl
    import AccessControl.cAccessControl
    acquisition_security_filter = AccessControl.cAccessControl.aq_validate
    from AccessControl import getSecurityManager
    from AccessControl.ZopeGuards import guarded_getattr
    try:
        from AccessControl import Unauthorized
    except ImportError:
        Unauthorized = "Unauthorized"
    if hasattr(AccessControl, 'full_read_guard'):
        from ZRPythonExpr import PythonExpr, _SecureModuleImporter, \
             call_with_ns
    else:
        from ZPythonExpr import PythonExpr, _SecureModuleImporter, \
             call_with_ns
else:
    from PythonExpr import getSecurityManager, PythonExpr
    guarded_getattr = getattr
    try:
        from zExceptions import Unauthorized
    except ImportError:
        Unauthorized = "Unauthorized"

    def acquisition_security_filter(orig, inst, name, v, real_validate):
        if real_validate(orig, inst, name, v):
            return 1
        raise Unauthorized, name

    def call_with_ns(f, ns, arg=1):
        if arg==2:
            return f(None, ns)
        else:
            return f(ns)

    class _SecureModuleImporter:
        """Simple version of the importer for use with trusted code."""
        __allow_access_to_unprotected_subobjects__ = 1
        def __getitem__(self, module):
            __import__(module)
            return sys.modules[module]
</t>
<t tx="ekr.20040104185913.3705">SecureModuleImporter = _SecureModuleImporter()

Undefs = (Undefined, AttributeError, KeyError,
          TypeError, IndexError, Unauthorized)

def render(ob, ns):
    """
    Calls the object, possibly a document template, or just returns it if
    not callable.  (From DT_Util.py)
    """
    if hasattr(ob, '__render_with_namespace__'):
        ob = call_with_ns(ob.__render_with_namespace__, ns)
    else:
        base = aq_base(ob)
        if callable(base):
            try:
                if getattr(base, 'isDocTemp', 0):
                    ob = call_with_ns(ob, ns, 2)
                else:
                    ob = ob()
            except AttributeError, n:
                if str(n) != '__call__':
                    raise
    return ob
</t>
<t tx="ekr.20040104185913.3706">class SubPathExpr:
	@others
</t>
<t tx="ekr.20040104185913.3707">def __init__(self, path):
    self._path = path = path.strip().split('/')
    self._base = base = path.pop(0)
    if not _valid_name(base):
        raise CompilerError, 'Invalid variable name "%s"' % base
    # Parse path
    self._dp = dp = []
    for i in range(len(path)):
        e = path[i]
        if e[:1] == '?' and _valid_name(e[1:]):
            dp.append((i, e[1:]))
    dp.reverse()
</t>
<t tx="ekr.20040104185913.3708">def _eval(self, econtext,
          list=list, isinstance=isinstance, StringType=type('')):
    vars = econtext.vars
    path = self._path
    if self._dp:
        path = list(path) # Copy!
        for i, varname in self._dp:
            val = vars[varname]
            if isinstance(val, StringType):
                path[i] = val
            else:
                # If the value isn't a string, assume it's a sequence
                # of path names.
                path[i:i+1] = list(val)
    __traceback_info__ = base = self._base
    if base == 'CONTEXTS':
        ob = econtext.contexts
    else:
        ob = vars[base]
    if isinstance(ob, DeferWrapper):
        ob = ob()
    if path:
        ob = restrictedTraverse(ob, path, getSecurityManager())
    return ob
</t>
<t tx="ekr.20040104185913.3709">class PathExpr:
	@others
</t>
<t tx="ekr.20040104185913.3710">def __init__(self, name, expr, engine):
    self._s = expr
    self._name = name
    self._hybrid = 0
    paths = expr.split('|')
    self._subexprs = []
    add = self._subexprs.append
    for i in range(len(paths)):
        path = paths[i].lstrip()
        if _parse_expr(path):
            # This part is the start of another expression type,
            # so glue it back together and compile it.
            add(engine.compile(('|'.join(paths[i:]).lstrip())))
            self._hybrid = 1
            break
        add(SubPathExpr(path)._eval)
</t>
<t tx="ekr.20040104185913.3711">def _exists(self, econtext):
    for expr in self._subexprs:
        try:
            expr(econtext)
        except Undefs:
            pass
        else:
            return 1
    return 0
</t>
<t tx="ekr.20040104185913.3712">def _eval(self, econtext,
          isinstance=isinstance, StringType=type(''), render=render):
    for expr in self._subexprs[:-1]:
        # Try all but the last subexpression, skipping undefined ones.
        try:
            ob = expr(econtext)
        except Undefs:
            pass
        else:
            break
    else:
        # On the last subexpression allow exceptions through, and
        # don't autocall if the expression was not a subpath.
        ob = self._subexprs[-1](econtext)
        if self._hybrid:
            return ob

    if self._name == 'nocall' or isinstance(ob, StringType):
        return ob
    # Return the rendered object
    return render(ob, econtext.vars)
</t>
<t tx="ekr.20040104185913.3713">def __call__(self, econtext):
    if self._name == 'exists':
        return self._exists(econtext)
    return self._eval(econtext)
</t>
<t tx="ekr.20040104185913.3714">def __str__(self):
    return '%s expression %s' % (self._name, `self._s`)
</t>
<t tx="ekr.20040104185913.3715">def __repr__(self):
    return '%s:%s' % (self._name, `self._s`)
</t>
<t tx="ekr.20040104185913.3716">_interp = re.compile(r'\$(%(n)s)|\${(%(n)s(?:/[^}]*)*)}' % {'n': NAME_RE})

class StringExpr:
	@others
</t>
<t tx="ekr.20040104185913.3717">def __init__(self, name, expr, engine):
    self._s = expr
    if '%' in expr:
        expr = expr.replace('%', '%%')
    self._vars = vars = []
    if '$' in expr:
        parts = []
        for exp in expr.split('$$'):
            if parts: parts.append('$')
            m = _interp.search(exp)
            while m is not None:
                parts.append(exp[:m.start()])
                parts.append('%s')
                vars.append(PathExpr('path', m.group(1) or m.group(2),
                                     engine))
                exp = exp[m.end():]
                m = _interp.search(exp)
            if '$' in exp:
                raise CompilerError, (
                    '$ must be doubled or followed by a simple path')
            parts.append(exp)
        expr = ''.join(parts)
    self._expr = expr
</t>
<t tx="ekr.20040104185913.3718">def __call__(self, econtext):
    vvals = []
    for var in self._vars:
        v = var(econtext)
        # I hope this isn't in use anymore.
        ## if isinstance(v, Exception):
        ##     raise v
        vvals.append(v)
    return self._expr % tuple(vvals)
</t>
<t tx="ekr.20040104185913.3719">def __str__(self):
    return 'string expression %s' % `self._s`
</t>
<t tx="ekr.20040104185913.3720">def __repr__(self):
    return 'string:%s' % `self._s`
</t>
<t tx="ekr.20040104185913.3721">class NotExpr:
	@others
</t>
<t tx="ekr.20040104185913.3722">def __init__(self, name, expr, compiler):
    self._s = expr = expr.lstrip()
    self._c = compiler.compile(expr)
</t>
<t tx="ekr.20040104185913.3723">def __call__(self, econtext):
    # We use the (not x) and 1 or 0 formulation to avoid changing
    # the representation of the result in Python 2.3, where the
    # result of "not" becomes an instance of bool.
    return (not econtext.evaluateBoolean(self._c)) and 1 or 0
</t>
<t tx="ekr.20040104185913.3724">def __repr__(self):
    return 'not:%s' % `self._s`
</t>
<t tx="ekr.20040104185913.3725">class DeferWrapper:
	@others
</t>
<t tx="ekr.20040104185913.3726">def __init__(self, expr, econtext):
    self._expr = expr
    self._econtext = econtext
</t>
<t tx="ekr.20040104185913.3727">def __str__(self):
    return str(self())
</t>
<t tx="ekr.20040104185913.3728">def __call__(self):
    return self._expr(self._econtext)
</t>
<t tx="ekr.20040104185913.3729">class DeferExpr:
	@others
</t>
<t tx="ekr.20040104185913.3730">def __init__(self, name, expr, compiler):
    self._s = expr = expr.lstrip()
    self._c = compiler.compile(expr)
</t>
<t tx="ekr.20040104185913.3731">def __call__(self, econtext):
    return DeferWrapper(self._c, econtext)
</t>
<t tx="ekr.20040104185913.3732">def __repr__(self):
    return 'defer:%s' % `self._s`
</t>
<t tx="ekr.20040104185913.3733">def restrictedTraverse(object, path, securityManager,
                       get=getattr, has=hasattr, N=None, M=[],
                       TupleType=type(()) ):

    REQUEST = {'path': path}
    REQUEST['TraversalRequestNameStack'] = path = path[:] # Copy!
    path.reverse()
    validate = securityManager.validate
    __traceback_info__ = REQUEST
    while path:
        name = path.pop()

        if isinstance(name, TupleType):
            object = object(*name)
            continue

        name = str(name)
        if not name or name[0] == '_':
            # Skip directly to item access
            o = object[name]
            # Check access to the item.
            if not validate(object, object, name, o):
                raise Unauthorized, name
            object = o
            continue

        if name=='..':
            o = get(object, 'aq_parent', M)
            if o is not M:
                if not validate(object, object, name, o):
                    raise Unauthorized, name
                object=o
                continue

        t=get(object, '__bobo_traverse__', N)
        if t is not N:
            o=t(REQUEST, name)

            container = None
            if aq_base(o) is not o:
                # The object is wrapped, so the acquisition
                # context determines the container.
                container = aq_parent(aq_inner(o))
            elif has(o, 'im_self'):
                container = o.im_self
            elif (has(aq_base(object), name) and get(object, name) == o):
                container = object
            if not validate(object, container, name, o):
                raise Unauthorized, name
        else:
            # Try an attribute.
            o = guarded_getattr(object, name, M)
            if o is M:
                # Try an item.
                try:
                    # XXX maybe in Python 2.2 we can just check whether
                    # the object has the attribute "__getitem__"
                    # instead of blindly catching exceptions.
                    o = object[name]
                except AttributeError, exc:
                    if str(exc).find('__getitem__') &gt;= 0:
                        # The object does not support the item interface.
                        # Try to re-raise the original attribute error.
                        # XXX I think this only happens with
                        # ExtensionClass instances.
                        guarded_getattr(object, name)
                    raise
                except TypeError, exc:
                    if str(exc).find('unsubscriptable') &gt;= 0:
                        # The object does not support the item interface.
                        # Try to re-raise the original attribute error.
                        # XXX This is sooooo ugly.
                        guarded_getattr(object, name)
                    raise
                else:
                    # Check access to the item.
                    if not validate(object, object, name, o):
                        raise Unauthorized, name
        object = o

    return object
</t>
<t tx="ekr.20040104185913.3734">&lt;&lt; GlobalTranslationService declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3735">&lt;&lt; copyright &gt;&gt;

"""Global Translation Service for providing I18n to Page Templates.

$Id: GlobalTranslationService.py,v 1.1.4.2 2002/09/24 15:39:28 efge Exp $
"""</t>
<t tx="ekr.20040104185913.3736">class DummyTranslationService:
    """Translation service that doesn't know anything about translation."""
	@others
</t>
<t tx="ekr.20040104185913.3737">def translate(self, domain, msgid, mapping=None,
              context=None, target_language=None):
    return None
</t>
<t tx="ekr.20040104185913.3738">    # XXX Not all of Zope.I18n.ITranslationService is implemented.

translationService = DummyTranslationService()

def setGlobalTranslationService(service):
    """Sets the global translation service, and returns the previous one."""
    global translationService
    old_service = translationService
    translationService = service
    return old_service
</t>
<t tx="ekr.20040104185913.3739">def getGlobalTranslationService():
    """Returns the global translation service."""
    return translationService
</t>
<t tx="ekr.20040104185913.3740">Page Template history

  This file contains change information for previous versions of
  PageTemplates. Change information for the current release can be found
  in the file CHANGES.txt.

    Version 1.4.1

      Bugs Fixed

        - Tracebacks were often truncated.

        - __bobo_traverse__ objects, such as the root, triggered
          security incorrectly when traversed.

        - If a PageTemplate was owned by a missing user, or one with
          insufficient permissions, the editing form broke.

        - PageTemplateFiles didn't bind 'user'.

        - There was no help.

    Version 1.4.0

      Features Added

        - ZPTs are now cache-enabled

        - Added property sheet to ZPT

      Bugs Fixed

        - Expressions with embedded newlines were broken

        - History comparison tried to expand macros

        - Iterator exceptions weren't converted

        - 'Unauthorized' exception couldn't be handled by on-error

    Version 1.3.3

      Features Added

        - Allow any false value in tal:repeat to act as an empty sequence.
        - manage_addPageTemplate accepts optional title and text
          arguments, and returns the new object if REQUEST is None.

      Bugs Fixed

        - The various *Python modules failed to import CompilerError.
        - Security machinery changes in Zope 2.4 broke ZRPythonExpr

    Version 1.3.2

      Features Added

        - Adopted Zope-style CHANGES.txt and HISTORY.txt
        - Improved execution performance
        - nocall: paths are back in.

      Bugs Fixed

        - TALES expressions let any string exception through, not just
          Redirect and Unauthorized.

    Version 1.3.1

      Features Added

        - Added error logging to PageTemplateFiles.
        - Refactored PythonExpr, and added support for Zope 2.4

    Version 1.3.0

      Features Added

        - New builtin variables 'default', 'user', and 'attrs'.
        - Removed path modifiers.
        - Added '|' operator for paths.
        - Tweaked parameters passed when calling DTML.
        - Expression types now have corresponding builtin functions in
          Python expressions.

    Version 1.2.1

      Bug Fixed

        - 'repeat' variable access was broken.

    Version 1.2.0

      Features Added

        - Depends on the new ZTUtils package, which adds batching and
          tree widget capabilities.
        - Path expressions now have optional path modifiers.  These
          appear in parenthesis before the path, and include 'if',
          'exists', and 'nocall'.
        - Changed nocall: and exists: expressions types into path modifiers.
        - The 'if' path modifier can cancel any TAL action.

    Version 1.1.0

      Features Added
        - Changed tests to match TAL's omitted attributes.

    Version 1.0.0

        - Various minor bugs fixed

    Version 1.0.0b1

	- All functionality described in the Project Wiki is implemented
</t>
<t tx="ekr.20040104185913.3741">&lt;&lt; PageTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3742">&lt;&lt; copyright &gt;&gt;
"""Page Template module

HTML- and XML-based template objects using TAL, TALES, and METAL.
"""

__version__='$Revision: 1.25.6.4 $'[11:-2]

import sys

from TAL.TALParser import TALParser
from TAL.HTMLTALParser import HTMLTALParser
from TAL.TALGenerator import TALGenerator
# Do not use cStringIO here!  It's not unicode aware. :(
from TAL.TALInterpreter import TALInterpreter, FasterStringIO
from Expressions import getEngine
from ExtensionClass import Base
from ComputedAttribute import ComputedAttribute


</t>
<t tx="ekr.20040104185913.3743">class PageTemplate(Base):
	&lt;&lt; class PageTemplate declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3744">"Page Templates using TAL, TALES, and METAL"

content_type = 'text/html'
expand = 0
_v_errors = ()
_v_warnings = ()
_v_program = None
_v_macros = None
_v_cooked = 0
id = '(unknown)'
_text = ''
_error_start = '&lt;!-- Page Template Diagnostics'

</t>
<t tx="ekr.20040104185913.3745">def StringIO(self):
    # Third-party products wishing to provide a full Unicode-aware
    # StringIO can do so by monkey-patching this method.
    return FasterStringIO()
</t>
<t tx="ekr.20040104185913.3746">def macros(self):
    return self.pt_macros()
</t>
<t tx="ekr.20040104185913.3747">macros = ComputedAttribute(macros, 1)

def pt_edit(self, text, content_type):
    if content_type:
        self.content_type = str(content_type)
    if hasattr(text, 'read'):
        text = text.read()
    self.write(text)
</t>
<t tx="ekr.20040104185913.3748">def pt_getContext(self):
    c = {'template': self,
         'options': {},
         'nothing': None,
         'request': None,
         'modules': ModuleImporter,
         }
    parent = getattr(self, 'aq_parent', None)
    if parent is not None:
        c['here'] = parent
        c['container'] = self.aq_inner.aq_parent
        while parent is not None:
            self = parent
            parent = getattr(self, 'aq_parent', None)
        c['root'] = self
    return c
</t>
<t tx="ekr.20040104185913.3749">def pt_render(self, source=0, extra_context={}):
    """Render this Page Template"""
    if not self._v_cooked:
        self._cook()

    __traceback_supplement__ = (PageTemplateTracebackSupplement, self)

    if self._v_errors:
        raise PTRuntimeError, 'Page Template %s has errors.' % self.id
    output = self.StringIO()
    c = self.pt_getContext()
    c.update(extra_context)

    TALInterpreter(self._v_program, self._v_macros,
                   getEngine().getContext(c),
                   output,
                   tal=not source, strictinsert=0)()
    return output.getvalue()
</t>
<t tx="ekr.20040104185913.3750">def __call__(self, *args, **kwargs):
    if not kwargs.has_key('args'):
        kwargs['args'] = args
    return self.pt_render(extra_context={'options': kwargs})
</t>
<t tx="ekr.20040104185913.3751">def pt_errors(self):
    if not self._v_cooked:
        self._cook()
    err = self._v_errors
    if err:
        return err
    if not self.expand: return
    try:
        self.pt_render(source=1)
    except:
        return ('Macro expansion failed', '%s: %s' % sys.exc_info()[:2])
</t>
<t tx="ekr.20040104185913.3752">def pt_warnings(self):
    if not self._v_cooked:
        self._cook()
    return self._v_warnings
</t>
<t tx="ekr.20040104185913.3753">def pt_macros(self):
    if not self._v_cooked:
        self._cook()
    if self._v_errors:
        __traceback_supplement__ = (PageTemplateTracebackSupplement, self)
        raise PTRuntimeError, 'Page Template %s has errors.' % self.id
    return self._v_macros
</t>
<t tx="ekr.20040104185913.3754">def pt_source_file(self):
    return None  # Unknown.
</t>
<t tx="ekr.20040104185913.3755">def write(self, text):
    assert type(text) is type('')
    if text[:len(self._error_start)] == self._error_start:
        errend = text.find('--&gt;')
        if errend &gt;= 0:
            text = text[errend + 4:]
    if self._text != text:
        self._text = text
    self._cook()
</t>
<t tx="ekr.20040104185913.3756">def read(self):
    if not self._v_cooked:
        self._cook()
    if not self._v_errors:
        if not self.expand:
            return self._text
        try:
            return self.pt_render(source=1)
        except:
            return ('%s\n Macro expansion failed\n %s\n--&gt;\n%s' %
                    (self._error_start, "%s: %s" % sys.exc_info()[:2],
                     self._text) )

    return ('%s\n %s\n--&gt;\n%s' % (self._error_start,
                                  '\n '.join(self._v_errors),
                                  self._text))
</t>
<t tx="ekr.20040104185913.3757">def _cook(self):
    """Compile the TAL and METAL statments.

    Cooking must not fail due to compilation errors in templates.
    """
    source_file = self.pt_source_file()
    if self.html():
        gen = TALGenerator(getEngine(), xml=0, source_file=source_file)
        parser = HTMLTALParser(gen)
    else:
        gen = TALGenerator(getEngine(), source_file=source_file)
        parser = TALParser(gen)

    self._v_errors = ()
    try:
        parser.parseString(self._text)
        self._v_program, self._v_macros = parser.getCode()
    except:
        self._v_errors = ["Compilation failed",
                          "%s: %s" % sys.exc_info()[:2]]
    self._v_warnings = parser.getWarnings()
    self._v_cooked = 1
</t>
<t tx="ekr.20040104185913.3758">def html(self):
    if not hasattr(getattr(self, 'aq_base', self), 'is_html'):
        return self.content_type == 'text/html'
    return self.is_html
</t>
<t tx="ekr.20040104185913.3759">class _ModuleImporter:
	@others
</t>
<t tx="ekr.20040104185913.3760">def __getitem__(self, module):
    mod = __import__(module)
    path = module.split('.')
    for name in path[1:]:
        mod = getattr(mod, name)
    return mod
</t>
<t tx="ekr.20040104185913.3761">ModuleImporter = _ModuleImporter()

class PTRuntimeError(RuntimeError):
    '''The Page Template has template errors that prevent it from rendering.'''
	&lt;&lt; class PTRuntimeError declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3762">pass


</t>
<t tx="ekr.20040104185913.3763">class PageTemplateTracebackSupplement:
	&lt;&lt; class PageTemplateTracebackSupplement declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3764">    #__implements__ = ITracebackSupplement

</t>
<t tx="ekr.20040104185913.3765">def __init__(self, pt):
    self.object = pt
    w = pt.pt_warnings()
    e = pt.pt_errors()
    if e:
        w = list(w) + list(e)
    self.warnings = w
</t>
<t tx="ekr.20040104185913.3766">&lt;&lt; PageTemplateFile declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3767">&lt;&lt; copyright &gt;&gt;
"""Filesystem Page Template module

Zope object encapsulating a Page Template from the filesystem.
"""

__version__='$Revision: 1.20.2.2 $'[11:-2]

import os, AccessControl, Acquisition, sys
from Globals import package_home, DevelopmentMode
from zLOG import LOG, ERROR, INFO
from Shared.DC.Scripts.Script import Script, BindingsUI
from Shared.DC.Scripts.Signature import FuncCode
from AccessControl import getSecurityManager
from OFS.Traversable import Traversable
from PageTemplate import PageTemplate
from Expressions import SecureModuleImporter
from ComputedAttribute import ComputedAttribute
from ExtensionClass import Base
from Acquisition import aq_parent, aq_inner

</t>
<t tx="ekr.20040104185913.3768">class PageTemplateFile(Script, PageTemplate, Traversable):
	&lt;&lt; class PageTemplateFile declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3769">"Zope wrapper for filesystem Page Template using TAL, TALES, and METAL"

meta_type = 'Page Template (File)'

func_defaults = None
func_code = FuncCode((), 0)
_need__name__=1
_v_last_read=0

_default_bindings = {'name_subpath': 'traverse_subpath'}

security = AccessControl.ClassSecurityInfo()
security.declareProtected('View management screens',
  'read', 'document_src')

</t>
<t tx="ekr.20040104185913.3770">def __init__(self, filename, _prefix=None, **kw):
    self.ZBindings_edit(self._default_bindings)
    if _prefix is None: _prefix=SOFTWARE_HOME
    elif type(_prefix) is not type(''):
        _prefix = package_home(_prefix)
    name = kw.get('__name__')
    if name:
        self._need__name__ = 0
        self.__name__ = name
    else:
        self.__name__ = os.path.splitext(os.path.split(filename)[-1])[0]
    if not os.path.splitext(filename)[1]:
        filename = filename + '.zpt'
    self.filename = os.path.join(_prefix, filename)
</t>
<t tx="ekr.20040104185913.3771">def pt_getContext(self):
    root = self.getPhysicalRoot()
    c = {'template': self,
         'here': self._getContext(),
         'container': self._getContainer(),
         'nothing': None,
         'options': {},
         'root': root,
         'request': getattr(root, 'REQUEST', None),
         'modules': SecureModuleImporter,
         }
    return c
</t>
<t tx="ekr.20040104185913.3772">def _exec(self, bound_names, args, kw):
    """Call a Page Template"""
    self._cook_check()
    if not kw.has_key('args'):
        kw['args'] = args
    bound_names['options'] = kw

    try:
        response = self.REQUEST.RESPONSE
        if not response.headers.has_key('content-type'):
            response.setHeader('content-type', self.content_type)
    except AttributeError:
        pass

    # Execute the template in a new security context.
    security=getSecurityManager()
    bound_names['user'] = security.getUser()
    security.addContext(self)
    try:
        return self.pt_render(extra_context=bound_names)
    finally:
        security.removeContext(self)
</t>
<t tx="ekr.20040104185913.3773">def pt_macros(self):
    self._cook_check()
    return PageTemplate.pt_macros(self)
</t>
<t tx="ekr.20040104185913.3774">def pt_source_file(self):
    """Returns a file name to be compiled into the TAL code."""
    return self.__name__  # Don't reveal filesystem paths
</t>
<t tx="ekr.20040104185913.3775">def _cook_check(self):
    if self._v_last_read and not DevelopmentMode:
        return
    __traceback_info__ = self.filename
    try:
        mtime = os.path.getmtime(self.filename)
    except OSError:
        mtime = 0
    if self._v_program is not None and mtime == self._v_last_read:
        return
    self.pt_edit(open(self.filename), None)
    self._cook()
    if self._v_errors:
        LOG('PageTemplateFile', ERROR, 'Error in template',
            '\n'.join(self._v_errors))
        return
    self._v_last_read = mtime
</t>
<t tx="ekr.20040104185913.3776">def document_src(self, REQUEST=None, RESPONSE=None):
    """Return expanded document source."""

    if RESPONSE is not None:
        RESPONSE.setHeader('Content-Type', 'text/plain')
    return self.read()
</t>
<t tx="ekr.20040104185913.3777">def _get__roles__(self):
    imp = getattr(aq_parent(aq_inner(self)),
                  '%s__roles__' % self.__name__)
    if hasattr(imp, '__of__'):
        return imp.__of__(self)
    return imp
</t>
<t tx="ekr.20040104185913.3778">__roles__ = ComputedAttribute(_get__roles__, 1)

def getOwner(self, info=0):
    """Gets the owner of the executable object.

    This method is required of all objects that go into
    the security context stack.  Since this object came from the
    filesystem, it is owned by no one managed by Zope.
    """
    return None
</t>
<t tx="ekr.20040104185913.3779">def __getstate__(self):
    from ZODB.POSException import StorageError
    raise StorageError, ("Instance of AntiPersistent class %s "
                         "cannot be stored." % self.__class__.__name__)
</t>
<t tx="ekr.20040104185913.3780">&lt;&lt; PathIterator declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3781">&lt;&lt; copyright &gt;&gt;

"""Path Iterator

A TALES Iterator with the ability to use first() and last() on
subpaths of elements.
"""

__version__='$Revision: 1.4 $'[11:-2]

import TALES
from Expressions import restrictedTraverse, Undefs, getSecurityManager

</t>
<t tx="ekr.20040104185913.3782">class Iterator(TALES.Iterator):
	@others
</t>
<t tx="ekr.20040104185913.3783">def __bobo_traverse__(self, REQUEST, name):
    if name in ('first', 'last'):
        path = REQUEST['TraversalRequestNameStack']
        names = list(path)
        names.reverse()
        path[:] = [tuple(names)]
    return getattr(self, name)
</t>
<t tx="ekr.20040104185913.3784">def same_part(self, name, ob1, ob2):
    if name is None:
        return ob1 == ob2
    if isinstance(name, type('')):
        name = name.split('/')
    name = filter(None, name)
    securityManager = getSecurityManager()
    try:
        ob1 = restrictedTraverse(ob1, name, securityManager)
        ob2 = restrictedTraverse(ob2, name, securityManager)
    except Undefs:
        return 0
    return ob1 == ob2
</t>
<t tx="ekr.20040104185913.3785">&lt;&lt; PythonExpr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3786">&lt;&lt; copyright &gt;&gt;

"""Generic Python Expression Handler
"""

__version__='$Revision: 1.8.6.3 $'[11:-2]

from TALES import CompilerError
from sys import exc_info

</t>
<t tx="ekr.20040104185913.3787">class getSecurityManager:
    '''Null security manager'''
	@others
    addContext = removeContext = validateValue = validate</t>
<t tx="ekr.20040104185913.3788">def validate(self, *args, **kwargs):
    return 1
</t>
<t tx="ekr.20040104185913.3789">class PythonExpr:
	@others
</t>
<t tx="ekr.20040104185913.3790">def __init__(self, name, expr, engine):
    self.expr = expr = expr.strip().replace('\n', ' ')
    try:
        d = {}
        exec 'def f():\n return %s\n' % expr.strip() in d
        self._f = d['f']
    except:
        raise CompilerError, ('Python expression error:\n'
                              '%s: %s') % exc_info()[:2]
    self._get_used_names()
</t>
<t tx="ekr.20040104185913.3791">def _get_used_names(self):
    self._f_varnames = vnames = []
    for vname in self._f.func_code.co_names:
        if vname[0] not in '$_':
            vnames.append(vname)
</t>
<t tx="ekr.20040104185913.3792">def _bind_used_names(self, econtext, _marker=[]):
    # Bind template variables
    names = {}
    vars = econtext.vars
    getType = econtext.getCompiler().getTypes().get
    for vname in self._f_varnames:
        val = vars.get(vname, _marker)
        if val is _marker:
            has = val = getType(vname)
            if has:
                val = ExprTypeProxy(vname, val, econtext)
                names[vname] = val
        else:
            names[vname] = val
    return names
</t>
<t tx="ekr.20040104185913.3793">def __call__(self, econtext):
    __traceback_info__ = self.expr
    f = self._f
    f.func_globals.update(self._bind_used_names(econtext))
    return f()
</t>
<t tx="ekr.20040104185913.3794">def __str__(self):
    return 'Python expression "%s"' % self.expr
</t>
<t tx="ekr.20040104185913.3795">def __repr__(self):
    return '&lt;PythonExpr %s&gt;' % self.expr
</t>
<t tx="ekr.20040104185913.3796">class ExprTypeProxy:
    '''Class that proxies access to an expression type handler'''
	@others
</t>
<t tx="ekr.20040104185913.3797">def __init__(self, name, handler, econtext):
    self._name = name
    self._handler = handler
    self._econtext = econtext
</t>
<t tx="ekr.20040104185913.3798">def __call__(self, text):
    return self._handler(self._name, text,
                         self._econtext.getCompiler())(self._econtext)
</t>
<t tx="ekr.20040104185913.3799">See &lt;a href="http://dev.zope.org/Wikis/DevSite/Projects/ZPT"&gt;the
ZPT project Wiki&lt;/a&gt; for more information about Page Templates, or
&lt;a href="http://www.zope.org/Members/4am/ZPT"&gt;the download page&lt;/a&gt;
for installation instructions and the most recent version of the software.

This Product requires the TAL and ZTUtils packages to be installed in
your Python path (not Products).  See the links above for more information.
</t>
<t tx="ekr.20040104185913.3800">&lt;&lt; TALES declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3801">&lt;&lt; copyright &gt;&gt;
"""TALES

An implementation of a generic TALES engine
"""

__version__='$Revision: 1.31.6.8 $'[11:-2]

import re, sys, ZTUtils
from weakref import ref
from MultiMapping import MultiMapping
from DocumentTemplate.DT_Util import ustr
from GlobalTranslationService import getGlobalTranslationService

StringType = type('')

NAME_RE = r"[a-zA-Z][a-zA-Z0-9_]*"
_parse_expr = re.compile(r"(%s):" % NAME_RE).match
_valid_name = re.compile('%s$' % NAME_RE).match

</t>
<t tx="ekr.20040104185913.3802">class TALESError(Exception):
    """Error during TALES expression evaluation"""
</t>
<t tx="ekr.20040104185913.3803">class Undefined(TALESError):
    '''Exception raised on traversal of an undefined path'''
</t>
<t tx="ekr.20040104185913.3804">class RegistrationError(Exception):
    '''TALES Type Registration Error'''
</t>
<t tx="ekr.20040104185913.3805">class CompilerError(Exception):
    '''TALES Compiler Error'''
</t>
<t tx="ekr.20040104185913.3806">class Default:
    '''Retain Default'''
</t>
<t tx="ekr.20040104185913.3807">Default = Default()

class SafeMapping(MultiMapping):
    '''Mapping with security declarations and limited method exposure.

    Since it subclasses MultiMapping, this class can be used to wrap
    one or more mapping objects.  Restricted Python code will not be
    able to mutate the SafeMapping or the wrapped mappings, but will be
    able to read any value.
    '''
	&lt;&lt; class SafeMapping declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3808">__allow_access_to_unprotected_subobjects__ = 1
push = pop = None

_push = MultiMapping.push
_pop = MultiMapping.pop


</t>
<t tx="ekr.20040104185913.3809">class Iterator(ZTUtils.Iterator):
	@others
</t>
<t tx="ekr.20040104185913.3810">def __init__(self, name, seq, context):
    ZTUtils.Iterator.__init__(self, seq)
    self.name = name
    self._context_ref = ref(context)
</t>
<t tx="ekr.20040104185913.3811">def next(self):
    if ZTUtils.Iterator.next(self):
        context = self._context_ref()
        if context is not None:
            context.setLocal(self.name, self.item)
        return 1
    return 0
</t>
<t tx="ekr.20040104185913.3812">class ErrorInfo:
    """Information about an exception passed to an on-error handler."""
	&lt;&lt; class ErrorInfo declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3813">__allow_access_to_unprotected_subobjects__ = 1

</t>
<t tx="ekr.20040104185913.3814">def __init__(self, err, position=(None, None)):
    if isinstance(err, Exception):
        self.type = err.__class__
        self.value = err
    else:
        self.type = err
        self.value = None
    self.lineno = position[0]
    self.offset = position[1]
</t>
<t tx="ekr.20040104185913.3815">class Engine:
    '''Expression Engine

    An instance of this class keeps a mutable collection of expression
    type handlers.  It can compile expression strings by delegating to
    these handlers.  It can provide an expression Context, which is
    capable of holding state and evaluating compiled expressions.
    '''
	&lt;&lt; class Engine declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3816">Iterator = Iterator

</t>
<t tx="ekr.20040104185913.3817">def __init__(self, Iterator=None):
    self.types = {}
    if Iterator is not None:
        self.Iterator = Iterator
</t>
<t tx="ekr.20040104185913.3818">def registerType(self, name, handler):
    if not _valid_name(name):
        raise RegistrationError, 'Invalid Expression type "%s".' % name
    types = self.types
    if types.has_key(name):
        raise RegistrationError, (
            'Multiple registrations for Expression type "%s".' %
            name)
    types[name] = handler
</t>
<t tx="ekr.20040104185913.3819">def getTypes(self):
    return self.types
</t>
<t tx="ekr.20040104185913.3820">def compile(self, expression):
    m = _parse_expr(expression)
    if m:
        type = m.group(1)
        expr = expression[m.end():]
    else:
        type = "standard"
        expr = expression
    try:
        handler = self.types[type]
    except KeyError:
        raise CompilerError, (
            'Unrecognized expression type "%s".' % type)
    return handler(type, expr, self)
</t>
<t tx="ekr.20040104185913.3821">def getContext(self, contexts=None, **kwcontexts):
    if contexts is not None:
        if kwcontexts:
            kwcontexts.update(contexts)
        else:
            kwcontexts = contexts
    return Context(self, kwcontexts)
</t>
<t tx="ekr.20040104185913.3822">def getCompilerError(self):
    return CompilerError
</t>
<t tx="ekr.20040104185913.3823">class Context:
    '''Expression Context

    An instance of this class holds context information that it can
    use to evaluate compiled expressions.
    '''
	&lt;&lt; class Context declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3824">_context_class = SafeMapping
position = (None, None)
source_file = None

</t>
<t tx="ekr.20040104185913.3825">def __init__(self, compiler, contexts):
    self._compiler = compiler
    self.contexts = contexts
    contexts['nothing'] = None
    contexts['default'] = Default

    self.repeat_vars = rv = {}
    # Wrap this, as it is visible to restricted code
    contexts['repeat'] = rep =  self._context_class(rv)
    contexts['loop'] = rep # alias

    self.global_vars = gv = contexts.copy()
    self.local_vars = lv = {}
    self.vars = self._context_class(gv, lv)

    # Keep track of what needs to be popped as each scope ends.
    self._scope_stack = []
</t>
<t tx="ekr.20040104185913.3826">def getCompiler(self):
    return self._compiler
</t>
<t tx="ekr.20040104185913.3827">def beginScope(self):
    self._scope_stack.append([self.local_vars.copy()])
</t>
<t tx="ekr.20040104185913.3828">def endScope(self):
    scope = self._scope_stack.pop()
    self.local_vars = lv = scope[0]
    v = self.vars
    v._pop()
    v._push(lv)
    # Pop repeat variables, if any
    i = len(scope) - 1
    while i:
        name, value = scope[i]
        if value is None:
            del self.repeat_vars[name]
        else:
            self.repeat_vars[name] = value
        i = i - 1
</t>
<t tx="ekr.20040104185913.3829">def setLocal(self, name, value):
    self.local_vars[name] = value
</t>
<t tx="ekr.20040104185913.3830">def setGlobal(self, name, value):
    self.global_vars[name] = value
</t>
<t tx="ekr.20040104185913.3831">def setRepeat(self, name, expr):
    expr = self.evaluate(expr)
    if not expr:
        return self._compiler.Iterator(name, (), self)
    it = self._compiler.Iterator(name, expr, self)
    old_value = self.repeat_vars.get(name)
    self._scope_stack[-1].append((name, old_value))
    self.repeat_vars[name] = it
    return it
</t>
<t tx="ekr.20040104185913.3832">def evaluate(self, expression,
             isinstance=isinstance, StringType=StringType):
    if isinstance(expression, StringType):
        expression = self._compiler.compile(expression)
    __traceback_supplement__ = (
        TALESTracebackSupplement, self, expression)
    return expression(self)
</t>
<t tx="ekr.20040104185913.3833">evaluateValue = evaluate
evaluateBoolean = evaluate

def evaluateText(self, expr):
    text = self.evaluate(expr)
    if text is Default or text is None:
        return text
    return ustr(text)
</t>
<t tx="ekr.20040104185913.3834">def evaluateStructure(self, expr):
    return self.evaluate(expr)
</t>
<t tx="ekr.20040104185913.3835">evaluateStructure = evaluate

def evaluateMacro(self, expr):
    # XXX Should return None or a macro definition
    return self.evaluate(expr)
</t>
<t tx="ekr.20040104185913.3836">evaluateMacro = evaluate

def createErrorInfo(self, err, position):
    return ErrorInfo(err, position)
</t>
<t tx="ekr.20040104185913.3837">def getDefault(self):
    return Default
</t>
<t tx="ekr.20040104185913.3838">def setSourceFile(self, source_file):
    self.source_file = source_file
</t>
<t tx="ekr.20040104185913.3839">def setPosition(self, position):
    self.position = position
</t>
<t tx="ekr.20040104185913.3840">def translate(self, domain, msgid, mapping=None,
              context=None, target_language=None):
    if context is None:
        context = self.contexts.get('here')
    return getGlobalTranslationService().translate(
        domain, msgid, mapping=mapping,
        context=context, target_language=target_language)
</t>
<t tx="ekr.20040104185913.3841">class TALESTracebackSupplement:
    """Implementation of ITracebackSupplement"""
	@others
</t>
<t tx="ekr.20040104185913.3842">def __init__(self, context, expression):
    self.context = context
    self.source_url = context.source_file
    self.line = context.position[0]
    self.column = context.position[1]
    self.expression = repr(expression)
</t>
<t tx="ekr.20040104185913.3843">def getInfo(self, as_html=0):
    import pprint
    data = self.context.contexts.copy()
    s = pprint.pformat(data)
    if not as_html:
        return '   - Names:\n      %s' % s.replace('\n', '\n      ')
    else:
        from cgi import escape
        return '&lt;b&gt;Names:&lt;/b&gt;&lt;pre&gt;%s&lt;/pre&gt;' % (escape(s))
</t>
<t tx="ekr.20040104185913.3844">class SimpleExpr:
    '''Simple example of an expression type handler'''
	@others
</t>
<t tx="ekr.20040104185913.3845">def __init__(self, name, expr, engine):
    self._name = name
    self._expr = expr
</t>
<t tx="ekr.20040104185913.3846">def __call__(self, econtext):
    return self._name, self._expr
</t>
<t tx="ekr.20040104185913.3847">def __repr__(self):
    return '&lt;SimpleExpr %s %s&gt;' % (self._name, `self._expr`)
</t>
<t tx="ekr.20040104185913.3848">&lt;&lt; ZPythonExpr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3849">&lt;&lt; copyright &gt;&gt;

"""Old Zope-specific Python Expression Handler

Handler for Python expressions, using the pre-Python 2.1 restriction
machinery from PythonScripts.
"""

__version__='$Revision: 1.8 $'[11:-2]

from AccessControl import getSecurityManager
from Products.PythonScripts.Guarded import _marker, \
     GuardedBlock, theGuard, safebin, WriteGuard, ReadGuard, UntupleFunction
from TALES import CompilerError

from PythonExpr import PythonExpr

</t>
<t tx="ekr.20040104185913.3850">class PythonExpr(PythonExpr):
	@others
</t>
<t tx="ekr.20040104185913.3851">def __init__(self, name, expr, engine):
    self.expr = expr = expr.strip().replace('\n', ' ')
    blk = GuardedBlock('def f():\n return \\\n %s\n' % expr)
    if blk.errors:
        raise CompilerError, ('Python expression error:\n%s' %
                              '\n'.join(blk.errors) )
    guards = {'$guard': theGuard, '$write_guard': WriteGuard,
              '$read_guard': ReadGuard, '__debug__': __debug__}
    self._f = UntupleFunction(blk.t, guards, __builtins__=safebin)
    self._get_used_names()
</t>
<t tx="ekr.20040104185913.3852">class _SecureModuleImporter:
	&lt;&lt; class _SecureModuleImporter declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3853">__allow_access_to_unprotected_subobjects__ = 1
</t>
<t tx="ekr.20040104185913.3854">def __getitem__(self, module):
    mod = safebin['__import__'](module)
    path = module.split('.')
    for name in path[1:]:
        mod = getattr(mod, name)
    return mod
</t>
<t tx="ekr.20040104185913.3855">from DocumentTemplate.DT_Util import TemplateDict, InstanceDict
def validate(accessed, container, name, value, dummy):
    return getSecurityManager().validate(accessed, container, name, value)
</t>
<t tx="ekr.20040104185913.3856">def call_with_ns(f, ns, arg=1):
    td = TemplateDict()
    td.validate = validate
    td.this = ns['here']
    td._push(ns['request'])
    td._push(InstanceDict(td.this, td))
    td._push(ns)
    try:
        if arg==2:
            return f(None, td)
        else:
            return f(td)
    finally:
        td._pop(3)
</t>
<t tx="ekr.20040104185913.3857">&lt;&lt; ZRPythonExpr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3858">&lt;&lt; copyright &gt;&gt;

"""Zope-specific Python Expression Handler

Handler for Python expressions that uses the RestrictedPython package.
"""

__version__='$Revision: 1.10 $'[11:-2]

from AccessControl import full_read_guard, full_write_guard, \
     safe_builtins, getSecurityManager
from AccessControl.ZopeGuards import guarded_getattr, guarded_getitem
from RestrictedPython import compile_restricted_eval
from TALES import CompilerError

from PythonExpr import PythonExpr

</t>
<t tx="ekr.20040104185913.3859">class PythonExpr(PythonExpr):
	&lt;&lt; class PythonExpr declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3860">_globals = {'__debug__': __debug__,
            '__builtins__': safe_builtins,
            '_getattr_': guarded_getattr,
            '_getitem_': guarded_getitem,}
</t>
<t tx="ekr.20040104185913.3861">def __init__(self, name, expr, engine):
    self.expr = expr = expr.strip().replace('\n', ' ')
    code, err, warn, use = compile_restricted_eval(expr, str(self))
    if err:
        raise CompilerError, ('Python expression error:\n%s' %
                              '\n'.join(err) )
    self._f_varnames = use.keys()
    self._code = code
</t>
<t tx="ekr.20040104185913.3862">def __call__(self, econtext):
    __traceback_info__ = self.expr
    code = self._code
    g = self._bind_used_names(econtext)
    g.update(self._globals)
    return eval(code, g, {})
</t>
<t tx="ekr.20040104185913.3863">class _SecureModuleImporter:
	&lt;&lt; class _SecureModuleImporter declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3864">__allow_access_to_unprotected_subobjects__ = 1
</t>
<t tx="ekr.20040104185913.3865">def __getitem__(self, module):
    mod = safe_builtins['__import__'](module)
    path = module.split('.')
    for name in path[1:]:
        mod = getattr(mod, name)
    return mod
</t>
<t tx="ekr.20040104185913.3866">from DocumentTemplate.DT_Util import TemplateDict, InstanceDict
from AccessControl.DTML import RestrictedDTML
class Rtd(RestrictedDTML, TemplateDict):
	&lt;&lt; class Rtd declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3867">this = None

</t>
<t tx="ekr.20040104185913.3868">def call_with_ns(f, ns, arg=1):
    td = Rtd()
    td.this = ns['here']
    td._push(ns['request'])
    td._push(InstanceDict(td.this, td))
    td._push(ns)
    try:
        if arg==2:
            return f(None, td)
        else:
            return f(td)
    finally:
        td._pop(3)
</t>
<t tx="ekr.20040104185913.3869">&lt;&lt; ZopePageTemplate declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3870">&lt;&lt; copyright &gt;&gt;
"""Zope Page Template module

Zope object encapsulating a Page Template.
"""

__version__='$Revision: 1.43.2.1 $'[11:-2]

import os, AccessControl, Acquisition, sys
from types import StringType
from Globals import DTMLFile, ImageFile, MessageDialog, package_home
from zLOG import LOG, ERROR, INFO
from OFS.SimpleItem import SimpleItem
from DateTime.DateTime import DateTime
from Shared.DC.Scripts.Script import Script, BindingsUI
from Shared.DC.Scripts.Signature import FuncCode
from AccessControl import getSecurityManager
try:
    from AccessControl import Unauthorized
except ImportError:
    Unauthorized = "Unauthorized"
from OFS.History import Historical, html_diff
from OFS.Cache import Cacheable
from OFS.Traversable import Traversable
from OFS.PropertyManager import PropertyManager
from PageTemplate import PageTemplate
from Expressions import SecureModuleImporter
from PageTemplateFile import PageTemplateFile

try:
    from webdav.Lockable import ResourceLockedError
    from webdav.WriteLockInterface import WriteLockInterface
    SUPPORTS_WEBDAV_LOCKS = 1
except ImportError:
    SUPPORTS_WEBDAV_LOCKS = 0

</t>
<t tx="ekr.20040104185913.3871">class ZopePageTemplate(Script, PageTemplate, Historical, Cacheable,
	&lt;&lt; class ZopePageTemplate declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3872">Traversable, PropertyManager):
"Zope wrapper for Page Template using TAL, TALES, and METAL"

if SUPPORTS_WEBDAV_LOCKS:
__implements__ = (WriteLockInterface,)

meta_type = 'Page Template'

func_defaults = None
func_code = FuncCode((), 0)

_default_bindings = {'name_subpath': 'traverse_subpath'}
_default_content_fn = os.path.join(package_home(globals()),
                'www', 'default.html')

manage_options = (
{'label':'Edit', 'action':'pt_editForm',
'help': ('PageTemplates', 'PageTemplate_Edit.stx')},
{'label':'Test', 'action':'ZScriptHTML_tryForm'},
) + PropertyManager.manage_options \
+ Historical.manage_options \
+ SimpleItem.manage_options \
+ Cacheable.manage_options

_properties=({'id':'title', 'type': 'string', 'mode': 'w'},
{'id':'content_type', 'type':'string', 'mode': 'w'},
{'id':'expand', 'type':'boolean', 'mode': 'w'},
)

</t>
<t tx="ekr.20040104185913.3873">def __init__(self, id, text=None, content_type=None):
    self.id = str(id)
    self.ZBindings_edit(self._default_bindings)
    if text is None:
        text = open(self._default_content_fn).read()
    self.pt_edit(text, content_type)
</t>
<t tx="ekr.20040104185913.3874">def _setPropValue(self, id, value):
    PropertyManager._setPropValue(self, id, value)
    self.ZCacheable_invalidate()
</t>
<t tx="ekr.20040104185913.3875">security = AccessControl.ClassSecurityInfo()

security.declareObjectProtected('View')
security.declareProtected('View', '__call__')

security.declareProtected('View management screens',
  'pt_editForm', 'manage_main', 'read',
  'ZScriptHTML_tryForm', 'PrincipiaSearchSource',
  'document_src', 'source.html', 'source.xml')

security.declareProtected('FTP access',
  'manage_FTPstat','manage_FTPget','manage_FTPlist')

pt_editForm = PageTemplateFile('www/ptEdit', globals(),
                               __name__='pt_editForm')
pt_editForm._owner = None
manage = manage_main = pt_editForm

security.declareProtected('Change Page Templates',
  'pt_editAction', 'pt_setTitle', 'pt_edit',
  'pt_upload', 'pt_changePrefs')
def pt_editAction(self, REQUEST, title, text, content_type, expand):
    """Change the title and document."""
    if SUPPORTS_WEBDAV_LOCKS and self.wl_isLocked():
        raise ResourceLockedError, "File is locked via WebDAV"
    self.expand=expand
    self.pt_setTitle(title)
    self.pt_edit(text, content_type)
    REQUEST.set('text', self.read()) # May not equal 'text'!
    message = "Saved changes."
    if getattr(self, '_v_warnings', None):
        message = ("&lt;strong&gt;Warning:&lt;/strong&gt; &lt;i&gt;%s&lt;/i&gt;"
                   % '&lt;br&gt;'.join(self._v_warnings))
    return self.pt_editForm(manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.3876">def pt_setTitle(self, title):
    self._setPropValue('title', str(title))
</t>
<t tx="ekr.20040104185913.3877">def pt_upload(self, REQUEST, file=''):
    """Replace the document with the text in file."""
    if SUPPORTS_WEBDAV_LOCKS and self.wl_isLocked():
        raise ResourceLockedError, "File is locked via WebDAV"

    if type(file) is not StringType:
        if not file: raise ValueError, 'File not specified'
        file = file.read()

    self.write(file)
    message = 'Saved changes.'
    return self.pt_editForm(manage_tabs_message=message)
</t>
<t tx="ekr.20040104185913.3878">def pt_changePrefs(self, REQUEST, height=None, width=None,
                   dtpref_cols='100%', dtpref_rows='20'):
    """Change editing preferences."""
    szchh = {'Taller': 1, 'Shorter': -1, None: 0}
    szchw = {'Wider': 5, 'Narrower': -5, None: 0}

    # The &lt;textarea&gt; can have dimensions expressed in percentages
    if type(width) is StringType and width.endswith('%'):
        cols = int(width[:-1])
        cols = max(cols, 25) # Min width 25%
        cols = max(cols, 100) # Max width 100%
        cols = "%d%%" % cols # Add percent sign back on
    elif type(width) is StringType and dtpref_cols.endswith('%'):
        cols = int(dtpref_cols[:-1])
        cols = max(cols + szchw.get(width, 0), 25) # Min width 25%
        cols = min(cols, 100) # Max width 100%
        cols = "%d%%" % cols # Add percent sign back on
    else: # Absolute width
        try: cols = int(width)
        except: cols = max(40, int(dtpref_cols) + szchw.get(width, 0))

    try: rows = int(height)
    except: rows = max(1, int(dtpref_rows) + szchh.get(height, 0))
    e = (DateTime('GMT') + 365).rfc822()
    setc = REQUEST['RESPONSE'].setCookie
    setc('dtpref_rows', str(rows), path='/', expires=e)
    setc('dtpref_cols', str(cols), path='/', expires=e)
    REQUEST.form.update({'dtpref_cols': cols, 'dtpref_rows': rows})
    return self.manage_main()
</t>
<t tx="ekr.20040104185913.3879">def ZScriptHTML_tryParams(self):
    """Parameters to test the script with."""
    return []
</t>
<t tx="ekr.20040104185913.3880">def manage_historyCompare(self, rev1, rev2, REQUEST,
                          historyComparisonResults=''):
    return ZopePageTemplate.inheritedAttribute(
        'manage_historyCompare')(
        self, rev1, rev2, REQUEST,
        historyComparisonResults=html_diff(rev1._text, rev2._text) )
</t>
<t tx="ekr.20040104185913.3881">def pt_getContext(self):
    root = self.getPhysicalRoot()
    c = {'template': self,
         'here': self._getContext(),
         'container': self._getContainer(),
         'nothing': None,
         'options': {},
         'root': root,
         'request': getattr(root, 'REQUEST', None),
         'modules': SecureModuleImporter,
         }
    return c
</t>
<t tx="ekr.20040104185913.3882">def write(self, text):
    self.ZCacheable_invalidate()
    ZopePageTemplate.inheritedAttribute('write')(self, text)
</t>
<t tx="ekr.20040104185913.3883">def _exec(self, bound_names, args, kw):
    """Call a Page Template"""
    if not kw.has_key('args'):
        kw['args'] = args
    bound_names['options'] = kw

    try:
        response = self.REQUEST.RESPONSE
        if not response.headers.has_key('content-type'):
            response.setHeader('content-type', self.content_type)
    except AttributeError:
        pass

    security=getSecurityManager()
    bound_names['user'] = security.getUser()

    # Retrieve the value from the cache.
    keyset = None
    if self.ZCacheable_isCachingEnabled():
        # Prepare a cache key.
        keyset = {'here': self._getContext(),
                  'bound_names': bound_names}
        result = self.ZCacheable_get(keywords=keyset)
        if result is not None:
            # Got a cached value.
            return result

    # Execute the template in a new security context.
    security.addContext(self)
    try:
        result = self.pt_render(extra_context=bound_names)
        if keyset is not None:
            # Store the result in the cache.
            self.ZCacheable_set(result, keywords=keyset)
        return result
    finally:
        security.removeContext(self)
</t>
<t tx="ekr.20040104185913.3884">security.declareProtected('Change Page Templates',
  'PUT', 'manage_FTPput', 'write',
  'manage_historyCopy',
  'manage_beforeHistoryCopy', 'manage_afterHistoryCopy')

def PUT(self, REQUEST, RESPONSE):
    """ Handle HTTP PUT requests """
    self.dav__init(REQUEST, RESPONSE)
    if SUPPORTS_WEBDAV_LOCKS:
        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)
    self.write(REQUEST.get('BODY', ''))
    RESPONSE.setStatus(204)
    return RESPONSE
</t>
<t tx="ekr.20040104185913.3885">manage_FTPput = PUT

def manage_FTPget(self):
    "Get source for FTP download"
    self.REQUEST.RESPONSE.setHeader('Content-Type', self.content_type)
    return self.read()
</t>
<t tx="ekr.20040104185913.3886">def get_size(self):
    return len(self.read())
</t>
<t tx="ekr.20040104185913.3887">getSize = get_size

def PrincipiaSearchSource(self):
    "Support for searching - the document's contents are searched."
    return self.read()
</t>
<t tx="ekr.20040104185913.3888">def document_src(self, REQUEST=None, RESPONSE=None):
    """Return expanded document source."""

    if RESPONSE is not None:
        RESPONSE.setHeader('Content-Type', 'text/plain')
    if REQUEST is not None and REQUEST.get('raw'):
        return self._text
    return self.read()
</t>
<t tx="ekr.20040104185913.3889">def om_icons(self):
    """Return a list of icon URLs to be displayed by an ObjectManager"""
    icons = ({'path': 'misc_/PageTemplates/zpt.gif',
              'alt': self.meta_type, 'title': self.meta_type},)
    if not self._v_cooked:
        self._cook()
    if self._v_errors:
        icons = icons + ({'path': 'misc_/PageTemplates/exclamation.gif',
                          'alt': 'Error',
                          'title': 'This template has an error'},)
    return icons
</t>
<t tx="ekr.20040104185913.3890">def __setstate__(self, state):
    # This is here for backward compatibility. :-(
    ZopePageTemplate.inheritedAttribute('__setstate__')(self, state)
</t>
<t tx="ekr.20040104185913.3891">def pt_source_file(self):
    """Returns a file name to be compiled into the TAL code."""
    try:
        return '/'.join(self.getPhysicalPath())
    except:
        # This page template is being compiled without an
        # acquisition context, so we don't know where it is. :-(
        return None
</t>
<t tx="ekr.20040104185913.3892">if not SUPPORTS_WEBDAV_LOCKS:
    def wl_isLocked(self):
        return 0
</t>
<t tx="ekr.20040104185913.3893">class Src(Acquisition.Explicit):
	&lt;&lt; class Src declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3894">" "

PUT = document_src = Acquisition.Acquired
index_html = None

</t>
<t tx="ekr.20040104185913.3895">def __before_publishing_traverse__(self, ob, request):
    if getattr(request, '_hacked_path', 0):
        request._hacked_path = 0
</t>
<t tx="ekr.20040104185913.3896">def __call__(self, REQUEST, RESPONSE):
    " "
    return self.document_src(REQUEST)
</t>
<t tx="ekr.20040104185913.3897">d = ZopePageTemplate.__dict__
d['source.xml'] = d['source.html'] = Src()


# Product registration and Add support
manage_addPageTemplateForm = PageTemplateFile(
    'www/ptAdd', globals(), __name__='manage_addPageTemplateForm')

from urllib import quote

def manage_addPageTemplate(self, id, title=None, text=None,
                           REQUEST=None, submit=None):
    "Add a Page Template with optional file content."

    id = str(id)
    if REQUEST is None:
        self._setObject(id, ZopePageTemplate(id, text))
        ob = getattr(self, id)
        if title:
            ob.pt_setTitle(title)
        return ob
    else:
        file = REQUEST.form.get('file')
        headers = getattr(file, 'headers', None)
        if headers is None or not file.filename:
            zpt = ZopePageTemplate(id)
        else:
            zpt = ZopePageTemplate(id, file, headers.get('content_type'))

        self._setObject(id, zpt)

        try:
            u = self.DestinationURL()
        except AttributeError:
            u = REQUEST['URL1']

        if submit == " Add and Edit ":
            u = "%s/%s" % (u, quote(id))
        REQUEST.RESPONSE.redirect(u+'/manage_main')
    return ''
</t>
<t tx="ekr.20040104185913.3898">from Products.PageTemplates import misc_
misc_['exclamation.gif'] = ImageFile('www/exclamation.gif', globals())

def initialize(context):
    context.registerClass(
        ZopePageTemplate,
        permission='Add Page Templates',
        constructors=(manage_addPageTemplateForm,
                      manage_addPageTemplate),
        icon='www/zpt.gif',
        )
    context.registerHelp()
    context.registerHelpTitle('Zope Help')
</t>
<t tx="ekr.20040104185913.3899">&lt;&lt; __init__ declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3900">&lt;&lt; copyright &gt;&gt;
__doc__='''Package wrapper for Page Templates

This wrapper allows the Page Template modules to be segregated in a
separate package.

$Id: __init__.py,v 1.4 2002/08/14 22:17:24 mj Exp $'''
__version__='$$'[11:-2]


# Placeholder for Zope Product data
misc_ = {}

</t>
<t tx="ekr.20040104185913.3901">def initialize(context):
    # Import lazily, and defer initialization to the module
    import ZopePageTemplate
    ZopePageTemplate.initialize(context)
</t>
<t tx="ekr.20040104185913.3902">PageTemplates-1-4-0
</t>
<t tx="ekr.20040104185913.3903"></t>
<t tx="ekr.20040104185913.3904">&lt;&lt; ZTUtils declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3905">"""
ZTUtils: Page Template Utilities

  The classes in this module are available from Page Templates.

"""

</t>
<t tx="ekr.20040104185913.3906">class Batch:
    """
    Batch - a section of a large sequence.

    You can use batches to break up large sequences (such as search
    results) over several pages.

    Batches provide Page Templates with similar functions as those
    built-in to '&lt;dtml-in&gt;'.

    You can access elements of a batch just as you access elements of
    a list. For example::

      &gt;&gt;&gt; b=Batch(range(100), 10)
      &gt;&gt;&gt; b[5]
      4
      &gt;&gt;&gt; b[10]
      IndexError: list index out of range

    Batches have these public attributes:

    start -- The first element number (counting from 1).

    first -- The first element index (counting from 0). Note that this
    is that same as start - 1.

    end -- The last element number (counting from 1).

    orphan -- The desired minimum batch size. This controls how
    sequences are split into batches. If a batch smaller than the
    orphan size would occur, then no split is performed, and a batch
    larger than the batch size results.

    overlap -- The number of elements that overlap between batches.

    length -- The actual length of the batch. Note that this can be
    different than size due to orphan settings.

    size -- The desired size. Note that this can be different than the
    actual length of the batch due to orphan settings.

    previous -- The previous batch or None if this is the first batch.

    next -- The next batch or None if this is the last batch.
    """
	@others
</t>
<t tx="ekr.20040104185913.3907">def __init__(self, sequence, size, start=0, end=0,
             orphan=0, overlap=0):
    """
    Creates a new batch given a sequence and a desired batch
    size.

    sequence -- The full sequence.

    size -- The desired batch size.

    start -- The index of the start of the batch (counting from 0).

    end -- The index of the end of the batch (counting from  0).

    orphan -- The desired minimum batch size. This controls how
    sequences are split into batches. If a batch smaller than the
    orphan size would occur, then no split is performed, and a
    batch larger than the batch size results.

    overlap -- The number of elements that overlap between
    batches.
    """
</t>
<t tx="ekr.20040104185913.3908"></t>
<t tx="ekr.20040104185913.3909">@others
</t>
<t tx="ekr.20040104185913.3910">def all():
    import testTALES
    return testTALES.test_suite()
</t>
<t tx="ekr.20040104185913.3911">class harness1:
	@others
</t>
<t tx="ekr.20040104185913.3912">def __init__(self):
    self.__callstack = []
</t>
<t tx="ekr.20040104185913.3913">def _assert_(self, name, *args, **kwargs):
    self.__callstack.append((name, args, kwargs))
</t>
<t tx="ekr.20040104185913.3914">def _complete_(self):
    assert len(self.__callstack) == 0, "Harness methods called"
</t>
<t tx="ekr.20040104185913.3915">def __getattr__(self, name):
    cs = self.__callstack
    assert len(cs), 'Unexpected harness method call "%s".' % name
    assert cs[0][0] == name, (
        'Harness method name "%s" called, "%s" expected.' %
        (name, cs[0][0]) )
    return self._method_
</t>
<t tx="ekr.20040104185913.3916">def _method_(self, *args, **kwargs):
    name, aargs, akwargs = self.__callstack.pop(0)
    assert aargs == args, "Harness method arguments"
    assert akwargs == kwargs, "Harness method keyword args"
</t>
<t tx="ekr.20040104185913.3917">class harness2(harness1):
	@others
</t>
<t tx="ekr.20040104185913.3918">def _assert_(self, name, result, *args, **kwargs):
    self.__callstack.append((name, result, args, kwargs))
</t>
<t tx="ekr.20040104185913.3919">def _method_(self, *args, **kwargs):
    name, result, aargs, akwargs = self.__callstack.pop(0)
    assert aargs == args, "Harness method arguments"
    assert akwargs == kwargs, "Harness method keyword args"
    return result
</t>
<t tx="ekr.20040104185913.3920">&lt;&lt; batch declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.3921">&lt;&lt; copyright &gt;&gt;

######################################################################
# Sequence batching support

import util

__allow_access_to_unprotected_subobjects__={'batch': 1}
__roles__=None


</t>
<t tx="ekr.20040104185913.3922">class batch(util.Base):
    """Create a sequence batch"""
	@others
</t>
<t tx="ekr.20040104185913.3923">def __init__(self, sequence, size, start=0, end=0,
             orphan=3, overlap=0):

    start=start+1

    start,end,sz=opt(start,end,size,orphan,sequence)

    self._last=end-1
    self._first=start-1

    self._sequence=sequence
    self._size=size
    self._start=start
    self._end=end
    self._orphan=orphan
    self._overlap=overlap
</t>
<t tx="ekr.20040104185913.3924">def previous_sequence(self): return self._first
</t>
<t tx="ekr.20040104185913.3925">def previous_sequence_end_number(self):
    start,end,spam=opt(0, self._start-1+self._overlap,
                       self._size, self._orphan, self._sequence)
    return end
</t>
<t tx="ekr.20040104185913.3926">def previous_sequence_start_number(self):
    start,end,spam=opt(0, self._start-1+self._overlap,
                       self._size, self._orphan, self._sequence)
    return start
</t>
<t tx="ekr.20040104185913.3927">def previous_sequence_end_item(self):
    start,end,spam=opt(0, self._start-1+self._overlap,
                       self._size, self._orphan, self._sequence)
    return self._sequence[end-1]
</t>
<t tx="ekr.20040104185913.3928">def previous_sequence_start_item(self):
    start,end,spam=opt(0, self._start-1+self._overlap,
                       self._size, self._orphan, self._sequence)
    return self._sequence[start-1]
</t>
<t tx="ekr.20040104185913.3929">def next_sequence_end_number(self):
    start,end,spam=opt(self._end+1-self._overlap, 0,
                       self._size, self._orphan, self._sequence)
    return end
</t>
<t tx="ekr.20040104185913.3930">def next_sequence_start_number(self):
    start,end,spam=opt(self._end+1-self._overlap, 0,
                       self._size, self._orphan, self._sequence)
    return start
</t>
<t tx="ekr.20040104185913.3931">def next_sequence_end_item(self):
    start,end,spam=opt(self._end+1-self._overlap, 0,
                       self._size, self._orphan, self._sequence)
    return self._sequence[end-1]
</t>
<t tx="ekr.20040104185913.3932">def next_sequence_start_item(self):
    start,end,spam=opt(self._end+1-self._overlap, 0,
                       self._size, self._orphan, self._sequence)
    return self._sequence[start-1]
</t>
<t tx="ekr.20040104185913.3933">def next_sequence(self):
    try: self._sequence[self._end]
    except IndexError: return 0
    else: return 1
</t>
<t tx="ekr.20040104185913.3934">def __getitem__(self, index):
    if index &gt; self._last: raise IndexError, index
    return self._sequence[index+self._first]
</t>
<t tx="ekr.20040104185913.3935">def opt(start,end,size,orphan,sequence):
    if size &lt; 1:
        if start &gt; 0 and end &gt; 0 and end &gt;= start:
            size=end+1-start
        else: size=7

    if start &gt; 0:

        try: sequence[start-1]
        except: start=len(sequence)

        if end &gt; 0:
            if end &lt; start: end=start
        else:
            end=start+size-1
            try: sequence[end+orphan-1]
            except: end=len(sequence)
    elif end &gt; 0:
        try: sequence[end-1]
        except: end=len(sequence)
        start=end+1-size
        if start - 1 &lt; orphan: start=1
    else:
        start=1
        end=start+size-1
        try: sequence[end+orphan-1]
        except: end=len(sequence)
    return start,end,size
</t>
<t tx="ekr.20040104185913.3936">&lt;&lt; run declarations &gt;&gt;
@others

if __name__ == "__main__":
    unittest.main(defaultTest='test_suite')
</t>
<t tx="ekr.20040104185913.3937">#!/usr/bin/env python
"""Run all tests."""

import unittest

</t>
<t tx="ekr.20040104185913.3938">def test_suite():
    suite = unittest.TestSuite()
    for mname in ('DTMLTests', 'HTMLTests', 'Expressions', 'TALES'):
        m = __import__('test' + mname)
        suite.addTest(m.test_suite())
    return suite
</t>
<t tx="ekr.20040104185913.3939">&lt;&lt; testDTMLTests declarations &gt;&gt;
@others

if __name__=='__main__':
    main()

</t>
<t tx="ekr.20040104185913.3940">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest

from Products.PageTemplates.tests import util
from Products.PageTemplates.PageTemplate import PageTemplate
from Acquisition import Implicit
from AccessControl import SecurityManager
from AccessControl.SecurityManagement import noSecurityManager

</t>
<t tx="ekr.20040104185913.3941">class AqPageTemplate(Implicit, PageTemplate):
	&lt;&lt; class AqPageTemplate declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3942">pass

</t>
<t tx="ekr.20040104185913.3943">class UnitTestSecurityPolicy:
    """
        Stub out the existing security policy for unit testing purposes.
    """
	&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3944">    #
    #   Standard SecurityPolicy interface
    #
</t>
<t tx="ekr.20040104185913.3945">def validate( self
            , accessed=None
            , container=None
            , name=None
            , value=None
            , context=None
            , roles=None
            , *args
            , **kw):
    return 1
</t>
<t tx="ekr.20040104185913.3946">def checkPermission( self, permission, object, context) :
    return 1
</t>
<t tx="ekr.20040104185913.3947">class DTMLTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.3948">def setUp(self):
    self.t=(AqPageTemplate())
    self.policy = UnitTestSecurityPolicy()
    self.oldPolicy = SecurityManager.setSecurityPolicy( self.policy )
    noSecurityManager()  # Use the new policy.
</t>
<t tx="ekr.20040104185913.3949">def tearDown(self):
    SecurityManager.setSecurityPolicy( self.oldPolicy )
    noSecurityManager()  # Reset to old policy.
</t>
<t tx="ekr.20040104185913.3950">def check1(self):
    """DTML test 1: if, in, and var:

    %(comment)[ blah %(comment)]
    &lt;html&gt;&lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
    %(if args)[
    &lt;dl&gt;&lt;dt&gt;The arguments to this test program were:&lt;p&gt;
    &lt;dd&gt;
    &lt;ul&gt;
    %(in args)[
      &lt;li&gt;Argument number %(num)d was %(arg)s
    %(in args)]
    &lt;/ul&gt;&lt;/dl&gt;&lt;p&gt;
    %(if args)]
    %(else args)[
    No arguments were given.&lt;p&gt;
    %(else args)]
    And thats da trooth.
    &lt;/body&gt;&lt;/html&gt;
    """

    tal = util.read_input('DTML1.html')
    self.t.write(tal)

    aa=util.argv(('one', 'two', 'three', 'cha', 'cha', 'cha'))
    o=self.t.__of__(aa)()
    expect = util.read_output('DTML1a.html')

    util.check_xml(expect, o)

    aa=util.argv(())
    o=self.t.__of__(aa)()
    expect = util.read_output('DTML1b.html')
    util.check_xml(expect, o)
</t>
<t tx="ekr.20040104185913.3951">def check3(self):
    """DTML test 3: batches and formatting:

      &lt;html&gt;&lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
      &lt;!--#if args--&gt;
        The arguments were:
        &lt;!--#in args size=size end=end--&gt;
            &lt;!--#if previous-sequence--&gt;
               (&lt;!--#var previous-sequence-start-arg--&gt;-
                &lt;!--#var previous-sequence-end-arg--&gt;)
            &lt;!--#/if previous-sequence--&gt;
            &lt;!--#if sequence-start--&gt;
               &lt;dl&gt;
            &lt;!--#/if sequence-start--&gt;
            &lt;dt&gt;&lt;!--#var sequence-arg--&gt;.&lt;/dt&gt;
            &lt;dd&gt;Argument &lt;!--#var num fmt=d--&gt; was &lt;!--#var arg--&gt;&lt;/dd&gt;
            &lt;!--#if next-sequence--&gt;
               (&lt;!--#var next-sequence-start-arg--&gt;-
                &lt;!--#var next-sequence-end-arg--&gt;)
            &lt;!--#/if next-sequence--&gt;
        &lt;!--#/in args--&gt;
        &lt;/dl&gt;
      &lt;!--#else args--&gt;
        No arguments were given.&lt;p&gt;
      &lt;!--#/if args--&gt;
      And I\'m 100% sure!
      &lt;/body&gt;&lt;/html&gt;
    """

    tal = util.read_input('DTML3.html')
    self.t.write(tal)

    aa=util.argv(('one', 'two', 'three', 'four', 'five',
                  'six', 'seven', 'eight', 'nine', 'ten',
                  'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen',
                  'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty',
                  ))
    from Products.PageTemplates.tests import batch
    o=self.t.__of__(aa)(batch=batch.batch(aa.args, 5))

    expect = util.read_output('DTML3.html')
    util.check_xml(expect, o)
</t>
<t tx="ekr.20040104185913.3952">def test_suite():
    return unittest.makeSuite(DTMLTests, 'check')
</t>
<t tx="ekr.20040104185913.3953">&lt;&lt; testExpressions declarations &gt;&gt;
@others

if __name__=='__main__':
    main()
</t>
<t tx="ekr.20040104185913.3954">import os, sys, unittest

from Products.PageTemplates import Expressions

</t>
<t tx="ekr.20040104185913.3955">class ExpressionTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.3956">def setUp(self):
    self.e = e = Expressions.getEngine()
    self.ec = e.getContext(
        one = 1,
        d = {'one': 1, 'b': 'b', '': 'blank', '_': 'under'},
        blank = '',
        )
</t>
<t tx="ekr.20040104185913.3957">def tearDown(self):
    del self.e, self.ec
</t>
<t tx="ekr.20040104185913.3958">def testCompile(self):
    '''Test expression compilation'''
    e = self.e
    for p in ('x', 'x/y', 'x/y/z'):
        e.compile(p)
    e.compile('path:a|b|c/d/e')
    e.compile('string:Fred')
    e.compile('string:A$B')
    e.compile('string:a ${x/y} b ${y/z} c')
    e.compile('python: 2 + 2')
    e.compile('python: 2 \n+\n 2\n')
</t>
<t tx="ekr.20040104185913.3959">def testSimpleEval(self):
    '''Test simple expression evaluation'''
    ec = self.ec
    assert ec.evaluate('one') == 1
    assert ec.evaluate('d/one') == 1
    assert ec.evaluate('d/b') == 'b'
</t>
<t tx="ekr.20040104185913.3960">def testEval1(self):
    '''Test advanced expression evaluation 1'''
    ec = self.ec
    assert ec.evaluate('x | nothing') is None
    assert ec.evaluate('d/') == 'blank'
    assert ec.evaluate('d/_') == 'under'
    assert ec.evaluate('d/ | nothing') == 'blank'
    assert ec.evaluate('d/?blank') == 'blank'
</t>
<t tx="ekr.20040104185913.3961">def testHybrid(self):
    '''Test hybrid path expressions'''
    ec = self.ec
    assert ec.evaluate('x | python:1+1') == 2
    assert ec.evaluate('x | python:int') == int
    assert ec.evaluate('x | string:x') == 'x'
    assert ec.evaluate('x | string:$one') == '1'
    assert ec.evaluate('x | not:exists:x')
</t>
<t tx="ekr.20040104185913.3962">def test_suite():
    return unittest.makeSuite(ExpressionTests)
</t>
<t tx="ekr.20040104185913.3963">&lt;&lt; testHTMLTests declarations &gt;&gt;
@others

if __name__=='__main__':
   main()

</t>
<t tx="ekr.20040104185913.3964">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest

from Products.PageTemplates.tests import util
from Products.PageTemplates.PageTemplate import PageTemplate
from Products.PageTemplates.GlobalTranslationService import \
     setGlobalTranslationService
from AccessControl import SecurityManager
from AccessControl.SecurityManagement import noSecurityManager

from Acquisition import Implicit
</t>
<t tx="ekr.20040104185913.3965">class AqPageTemplate(Implicit, PageTemplate):
	&lt;&lt; class AqPageTemplate declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3966">pass

</t>
<t tx="ekr.20040104185913.3967">class Folder(util.Base):
	&lt;&lt; class Folder declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.3968">pass

</t>
<t tx="ekr.20040104185913.3969">class TestTranslationService:
	@others
</t>
<t tx="ekr.20040104185913.3970">def translate(self, domain, msgid, mapping=None, *args, **kw):
    maps = []
    if mapping is not None:
        # Get a deterministic, sorted representation of dicts.
        for k, v in mapping.items():
            maps.append('%s:%s' % (`k`, `v`))
        maps.sort()
    return "[%s](%s/{%s})" % (domain, msgid, ','.join(maps))
</t>
<t tx="ekr.20040104185913.3971">class UnitTestSecurityPolicy:
    """
        Stub out the existing security policy for unit testing purposes.
    """
	&lt;&lt; class UnitTestSecurityPolicy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.3972">    #
    #   Standard SecurityPolicy interface
    #
</t>
<t tx="ekr.20040104185913.3973">def validate( self
            , accessed=None
            , container=None
            , name=None
            , value=None
            , context=None
            , roles=None
            , *args
            , **kw):
    return 1
</t>
<t tx="ekr.20040104185913.3974">def checkPermission( self, permission, object, context) :
    return 1
</t>
<t tx="ekr.20040104185913.3975">class HTMLTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.3976">def setUp(self):
    self.folder = f = Folder()
    f.laf = AqPageTemplate()
    f.t = AqPageTemplate()
    self.policy = UnitTestSecurityPolicy()
    self.oldPolicy = SecurityManager.setSecurityPolicy( self.policy )
    noSecurityManager()  # Use the new policy.
</t>
<t tx="ekr.20040104185913.3977">def tearDown(self):
    SecurityManager.setSecurityPolicy( self.oldPolicy )
    noSecurityManager()  # Reset to old policy.
</t>
<t tx="ekr.20040104185913.3978">def assert_expected(self, t, fname, *args, **kwargs):
    t.write(util.read_input(fname))
    assert not t._v_errors, 'Template errors: %s' % t._v_errors
    expect = util.read_output(fname)
    out = apply(t, args, kwargs)
    util.check_html(expect, out)
</t>
<t tx="ekr.20040104185913.3979">def assert_expected_unicode(self, t, fname, *args, **kwargs):
    t.write(util.read_input(fname))
    assert not t._v_errors, 'Template errors: %s' % t._v_errors
    expect = util.read_output(fname)
    expect = unicode(expect, 'utf8')
    out = apply(t, args, kwargs)
    util.check_html(expect, out)
</t>
<t tx="ekr.20040104185913.3980">def getProducts(self):
    return [
       {'description': 'This is the tee for those who LOVE Zope. '
        'Show your heart on your tee.',
        'price': 12.99, 'image': 'smlatee.jpg'
        },
       {'description': 'This is the tee for Jim Fulton. '
        'He\'s the Zope Pope!',
        'price': 11.99, 'image': 'smpztee.jpg'
        },
       ]
</t>
<t tx="ekr.20040104185913.3981">def check1(self):
    self.assert_expected(self.folder.laf, 'TeeShopLAF.html')
</t>
<t tx="ekr.20040104185913.3982">def check2(self):
    self.folder.laf.write(util.read_input('TeeShopLAF.html'))

    self.assert_expected(self.folder.t, 'TeeShop2.html',
                         getProducts=self.getProducts)
</t>
<t tx="ekr.20040104185913.3983">def check3(self):
    self.folder.laf.write(util.read_input('TeeShopLAF.html'))

    self.assert_expected(self.folder.t, 'TeeShop1.html',
                         getProducts=self.getProducts)
</t>
<t tx="ekr.20040104185913.3984">def checkSimpleLoop(self):
    self.assert_expected(self.folder.t, 'Loop1.html')
</t>
<t tx="ekr.20040104185913.3985">def checkFancyLoop(self):
    self.assert_expected(self.folder.t, 'Loop2.html')
</t>
<t tx="ekr.20040104185913.3986">def checkGlobalsShadowLocals(self):
    self.assert_expected(self.folder.t, 'GlobalsShadowLocals.html')
</t>
<t tx="ekr.20040104185913.3987">def checkStringExpressions(self):
    self.assert_expected(self.folder.t, 'StringExpression.html')
</t>
<t tx="ekr.20040104185913.3988">def checkReplaceWithNothing(self):
    self.assert_expected(self.folder.t, 'CheckNothing.html')
</t>
<t tx="ekr.20040104185913.3989">def checkWithXMLHeader(self):
    self.assert_expected(self.folder.t, 'CheckWithXMLHeader.html')
</t>
<t tx="ekr.20040104185913.3990">def checkNotExpression(self):
    self.assert_expected(self.folder.t, 'CheckNotExpression.html')
</t>
<t tx="ekr.20040104185913.3991">def checkPathNothing(self):
    self.assert_expected(self.folder.t, 'CheckPathNothing.html')
</t>
<t tx="ekr.20040104185913.3992">def checkPathAlt(self):
    self.assert_expected(self.folder.t, 'CheckPathAlt.html')
</t>
<t tx="ekr.20040104185913.3993">def checkBatchIteration(self):
    self.assert_expected(self.folder.t, 'CheckBatchIteration.html')
</t>
<t tx="ekr.20040104185913.3994">def checkUnicodeInserts(self):
    self.assert_expected_unicode(self.folder.t, 'CheckUnicodeInserts.html')
</t>
<t tx="ekr.20040104185913.3995">def checkI18nTranslate(self):
    self.assert_expected(self.folder.t, 'CheckI18nTranslate.html')
</t>
<t tx="ekr.20040104185913.3996">def checkI18nTranslateHooked(self):
    old_ts = setGlobalTranslationService(TestTranslationService())
    self.assert_expected(self.folder.t, 'CheckI18nTranslateHooked.html')
    setGlobalTranslationService(old_ts)
</t>
<t tx="ekr.20040104185913.3997">def test_suite():
    return unittest.makeSuite(HTMLTests, 'check')
</t>
<t tx="ekr.20040104185913.3998">&lt;&lt; testTALES declarations &gt;&gt;
@others

if __name__=='__main__':
    main()
</t>
<t tx="ekr.20040104185913.3999">import os, sys, unittest

from Products.PageTemplates import TALES
from Products.PageTemplates.tests import harness1
import string

</t>
<t tx="ekr.20040104185913.4000">class DummyUnicodeExpr:
    '''Dummy expression type handler returning unicode'''
	@others
</t>
<t tx="ekr.20040104185913.4001">def __init__(self, name, expr, engine):
    self._name = name
    self._expr = expr
</t>
<t tx="ekr.20040104185913.4002">def __call__(self, econtext):
    return unicode(self._expr, 'latin1')
</t>
<t tx="ekr.20040104185913.4003">def __repr__(self):
    return '&lt;SimpleExpr %s %s&gt;' % (self._name, `self._expr`)
</t>
<t tx="ekr.20040104185913.4004">class TALESTests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.4005">def testIterator0(self):
    '''Test sample Iterator class'''
    context = harness1()
    it = TALES.Iterator('name', (), context)
    assert not it.next(), "Empty iterator"
    context._complete_()
</t>
<t tx="ekr.20040104185913.4006">def testIterator1(self):
    '''Test sample Iterator class'''
    context = harness1()
    it = TALES.Iterator('name', (1,), context)
    context._assert_('setLocal', 'name', 1)
    assert it.next() and not it.next(), "Single-element iterator"
    context._complete_()
</t>
<t tx="ekr.20040104185913.4007">def testIterator2(self):
    '''Test sample Iterator class'''
    context = harness1()
    it = TALES.Iterator('text', 'text', context)
    for c in 'text':
        context._assert_('setLocal', 'text', c)
    for c in 'text':
        assert it.next(), "Multi-element iterator"
    assert not it.next(), "Multi-element iterator"
    context._complete_()
</t>
<t tx="ekr.20040104185913.4008">def testRegisterType(self):
    '''Test expression type registration'''
    e = TALES.Engine()
    e.registerType('simple', TALES.SimpleExpr)
    assert e.getTypes()['simple'] == TALES.SimpleExpr
</t>
<t tx="ekr.20040104185913.4009">def testRegisterTypeUnique(self):
    '''Test expression type registration uniqueness'''
    e = TALES.Engine()
    e.registerType('simple', TALES.SimpleExpr)
    try:
        e.registerType('simple', TALES.SimpleExpr)
    except TALES.RegistrationError:
        pass
    else:
        assert 0, "Duplicate registration accepted."
</t>
<t tx="ekr.20040104185913.4010">def testRegisterTypeNameConstraints(self):
    '''Test constraints on expression type names'''
    e = TALES.Engine()
    for name in '1A', 'A!', 'AB ':
        try:
            e.registerType(name, TALES.SimpleExpr)
        except TALES.RegistrationError:
            pass
        else:
            assert 0, 'Invalid type name "%s" accepted.' % name
</t>
<t tx="ekr.20040104185913.4011">def testCompile(self):
    '''Test expression compilation'''
    e = TALES.Engine()
    e.registerType('simple', TALES.SimpleExpr)
    ce = e.compile('simple:x')
    assert ce(None) == ('simple', 'x'), (
        'Improperly compiled expression %s.' % `ce`)
</t>
<t tx="ekr.20040104185913.4012">def testGetContext(self):
    '''Test Context creation'''
    TALES.Engine().getContext()
    TALES.Engine().getContext(v=1)
    TALES.Engine().getContext(x=1, y=2)
</t>
<t tx="ekr.20040104185913.4013">def getContext(self, **kws):
    e = TALES.Engine()
    e.registerType('simple', TALES.SimpleExpr)
    e.registerType('unicode', DummyUnicodeExpr)
    return apply(e.getContext, (), kws)
</t>
<t tx="ekr.20040104185913.4014">def testContext0(self):
    '''Test use of Context'''
    se = self.getContext().evaluate('simple:x')
    assert se == ('simple', 'x'), (
        'Improperly evaluated expression %s.' % `se`)
</t>
<t tx="ekr.20040104185913.4015">def testContextUnicode(self):
    '''Test evaluateText on unicode-returning expressions'''
    se = self.getContext().evaluateText('unicode:\xe9')
    self.assertEqual(se, u'\xe9')
</t>
<t tx="ekr.20040104185913.4016">def testVariables(self):
    '''Test variables'''
    ctxt = self.getContext()
    c = ctxt.vars
    ctxt.beginScope()
    ctxt.setLocal('v1', 1)
    ctxt.setLocal('v2', 2)

    assert c['v1'] == 1, 'Variable "v1"'

    ctxt.beginScope()
    ctxt.setLocal('v1', 3)
    ctxt.setGlobal('g', 1)

    assert c['v1'] == 3, 'Inner scope'
    assert c['v2'] == 2, 'Outer scope'
    assert c['g'] == 1, 'Global'

    ctxt.endScope()

    assert c['v1'] == 1, "Uncovered local"
    assert c['g'] == 1, "Global from inner scope"

    ctxt.endScope()
</t>
<t tx="ekr.20040104185913.4017">def test_suite():
    return unittest.makeSuite(TALESTests)
</t>
<t tx="ekr.20040104185913.4018">&lt;&lt; copyright &gt;&gt;

# Utility facilities to aid setting things up.

import os, sys, string, re

from ExtensionClass import Base

@others
</t>
<t tx="ekr.20040104185913.4020">class Bruce(Base):
	&lt;&lt; class Bruce declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4021">__allow_access_to_unprotected_subobjects__=1
</t>
<t tx="ekr.20040104185913.4022">def __str__(self): return 'bruce'
</t>
<t tx="ekr.20040104185913.4023">def __int__(self): return 42
</t>
<t tx="ekr.20040104185913.4024">def __float__(self): return 42.0
</t>
<t tx="ekr.20040104185913.4025">def keys(self): return ['bruce']*7
</t>
<t tx="ekr.20040104185913.4026">def values(self): return [self]*7
</t>
<t tx="ekr.20040104185913.4027">def items(self): return [('bruce',self)]*7
</t>
<t tx="ekr.20040104185913.4028">def __len__(self): return 7
</t>
<t tx="ekr.20040104185913.4029">def __getitem__(self,index):
    if (type(index) is type(1) and
        (index &lt; 0 or index &gt; 6)): raise IndexError, index
    return self
</t>
<t tx="ekr.20040104185913.4030">isDocTemp=0
def __getattr__(self,name):
    if name[:1]=='_': raise AttributeError, name
    return self
</t>
<t tx="ekr.20040104185913.4031">bruce=Bruce()

class arg(Base):
	&lt;&lt; class arg declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4032">__allow_access_to_unprotected_subobjects__=1
</t>
<t tx="ekr.20040104185913.4033">def __init__(self,nn,aa): self.num, self.arg = nn, aa
</t>
<t tx="ekr.20040104185913.4034">def __str__(self): return str(self.arg)
</t>
<t tx="ekr.20040104185913.4035">class argv(Base):
	&lt;&lt; class argv declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4036">__allow_access_to_unprotected_subobjects__=1
</t>
<t tx="ekr.20040104185913.4037">def __init__(self, argv=sys.argv[1:]):
    args=self.args=[]
    for aa in argv:
        args.append(arg(len(args)+1,aa))
</t>
<t tx="ekr.20040104185913.4038">def items(self):
    return map(lambda a: ('spam%d' % a.num, a), self.args)
</t>
<t tx="ekr.20040104185913.4039">def values(self): return self.args
</t>
<t tx="ekr.20040104185913.4040">def getPhysicalRoot(self):
    return self
</t>
<t tx="ekr.20040104185913.4041">def nicerange(lo, hi):
    if hi &lt;= lo+1:
        return str(lo+1)
    else:
        return "%d,%d" % (lo+1, hi)
</t>
<t tx="ekr.20040104185913.4042">def check_html(s1, s2):
    s1 = normalize_html(s1)
    s2 = normalize_html(s2)
    if s1!=s2:
        print
        from OFS.ndiff import SequenceMatcher, dump, IS_LINE_JUNK
        a = string.split(s1, '\n')
        b = string.split(s2, '\n')
        def add_nl(s):
            return s + '\n'
        a = map(add_nl, a)
        b = map(add_nl, b)
        cruncher=SequenceMatcher(isjunk=IS_LINE_JUNK, a=a, b=b)
        for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
            if tag == 'equal':
                continue
            print nicerange(alo, ahi) + tag[0] + nicerange(blo, bhi)
            dump('&lt;', a, alo, ahi)
            if a and b:
                print '---'
            dump('&gt;', b, blo, bhi)
    assert s1==s2, "HTML Output Changed"
</t>
<t tx="ekr.20040104185913.4043">def check_xml(s1, s2):
    s1 = normalize_xml(s1)
    s2 = normalize_xml(s2)
    assert s1==s2, "XML Output Changed"
</t>
<t tx="ekr.20040104185913.4044">def normalize_html(s):
    s = re.sub(r"[ \t]+", " ", s)
    s = re.sub(r"/&gt;", "&gt;", s)
    return s
</t>
<t tx="ekr.20040104185913.4045">def normalize_xml(s):
    s = re.sub(r"\s+", " ", s)
    s = re.sub(r"(?s)\s+&lt;", "&lt;", s)
    s = re.sub(r"(?s)&gt;\s+", "&gt;", s)
    return s
</t>
<t tx="ekr.20040104185913.4046">import Products.PageTemplates.tests
dir = os.path.dirname( Products.PageTemplates.tests.__file__)
input_dir = os.path.join(dir, 'input')
output_dir = os.path.join(dir, 'output')

def read_input(filename):
    filename = os.path.join(input_dir, filename)
    return open(filename, 'r').read()
</t>
<t tx="ekr.20040104185913.4047">def read_output(filename):
    filename = os.path.join(output_dir, filename)
    return open(filename, 'r').read()
</t>
<t tx="ekr.20040104185913.4048">@language html</t>
<t tx="ekr.20040104185913.4049">&lt;html&gt;
  &lt;body tal:define="ztu modules/ZTUtils;b python:ztu.Batch(range(10), 5)"&gt;
    &lt;p tal:repeat="n b"&gt;
      Batch 1: item=&lt;span tal:replace="n"&gt;n&lt;/span&gt;
    &lt;/p&gt;
    &lt;p tal:repeat="n b/next"&gt;
      Batch 2: item=&lt;span tal:replace="n"&gt;n&lt;/span&gt;
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4050">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p i18n:domain="foo" i18n:translate="bar"&gt;baz&lt;/p&gt;
   &lt;a href="foo" alt="alttext" i18n:attributes="alt"&gt;link&lt;/a&gt;
   &lt;p i18n:domain="dom" i18n:translate=""&gt;
     &lt;span tal:replace="string:Lomax" i18n:name="name" /&gt; was born in
     &lt;span tal:replace="string:Antarctica" i18n:name="country" /&gt;.
   &lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4051">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p i18n:domain="foo" i18n:translate="bar"&gt;baz&lt;/p&gt;
   &lt;a href="foo" alt="alttext" i18n:attributes="alt"&gt;link&lt;/a&gt;
   &lt;p i18n:domain="dom" i18n:translate=""&gt;
     &lt;span tal:replace="string:Lomax" i18n:name="name" /&gt; was born in
     &lt;span tal:replace="string:Antarctica" i18n:name="country" /&gt;.
   &lt;/p&gt;
   &lt;p i18n:translate="hmm"&gt;
     I'm &lt;span tal:replace="python:25" i18n:name="age"&gt;Age&lt;/span&gt;
   &lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4052">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div tal:content="not:python:0"&gt;&lt;/div&gt;
&lt;div tal:content="not:python:1"&gt;&lt;/div&gt;
&lt;div tal:content="not: python:1"&gt;&lt;/div&gt;
&lt;div tal:content="not:python:range(1,20)"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4053">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;title tal:content="nothing"&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4054">&lt;html&gt;
&lt;body&gt;
   &lt;div tal:define="x string:X;nil string:"&gt;
   &lt;p tal:content="x"&gt;1&lt;/p&gt;
   &lt;p tal:content="x | nil"&gt;2&lt;/p&gt;
   &lt;p tal:content="python:nil or x"&gt;3&lt;/p&gt;
   &lt;p tal:content="y/z | x"&gt;4&lt;/p&gt;
   &lt;p tal:content="y/z | string:X"&gt;4&lt;/p&gt;
   &lt;p tal:content="y/z | python:'|AXE|'[2]"&gt;4&lt;/p&gt;
   &lt;p tal:content="y/z | x | nil"&gt;5&lt;/p&gt;

   &lt;p tal:attributes="name nil"&gt;Z&lt;/p&gt;
   &lt;p tal:attributes="name y/z | nil"&gt;Z&lt;/p&gt;
   &lt;p tal:attributes="name y/z | string:"&gt;Z&lt;/p&gt;
   &lt;p tal:attributes="name y/z | python:'||'[:0]"&gt;Z&lt;/p&gt;
   &lt;p tal:attributes="name y/z | nothing"&gt;Z&lt;/p&gt;

   &lt;p tal:on-error="python:str(error.value[0])" tal:content="a/b | c/d"&gt;Z&lt;/p&gt;
   &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4055">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;title tal:content="path:nothing"&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4056">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p tal:content="python:u'e acute=\xe9'"&gt;e acute here&lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4057">&lt;?xml version="1.0" ?&gt;
&lt;html&gt;
&lt;body tal:content="string:Hello!"&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4058">&lt;html xmlns:tal="http://xml.zope.org/namespaces/tal"&gt;
  &lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
      &lt;span tal:replace="nothing"&gt; blah &lt;/span&gt;
      &lt;dl tal:condition="here/args"&gt;
        &lt;dt&gt;The arguments to this test program were:&lt;/dt&gt;
        &lt;dd&gt;
          &lt;ul&gt;
            &lt;li tal:repeat="arg here/args"&gt;
              Argument number &lt;span tal:replace="arg/num"&gt;99&lt;/span&gt;
              is &lt;span tal:replace="arg/arg"&gt;default&lt;/span&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/dd&gt;
      &lt;/dl&gt;
      &lt;p tal:condition="not:here/args"&gt;No arguments were given.&lt;/p&gt;
      And thats da trooth.
  &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4059">&lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
        &lt;div tal:condition="here/args"&gt;
          The arguments were:
          &lt;span tal:condition="options/batch/previous_sequence"&gt;
            (&lt;span
              tal:replace="options/batch/previous_sequence_start_item"
              &gt;previous start item&lt;/span&gt;-&lt;span
              tal:replace="options/batch/previous_sequence_end_item"
              &gt;previous end item&lt;/span&gt;)
          &lt;/span&gt;
          &lt;dl&gt;
            &lt;span tal:repeat="arg options/batch"&gt;
              &lt;dt&gt;&lt;span tal:replace="arg"&gt;??&lt;/span&gt;.&lt;/dt&gt;
              &lt;dd&gt;Argument &lt;span tal:define="num arg/num"
                                 tal:replace="string: $num"
                  &gt;99&lt;/span&gt; was &lt;span tal:replace="arg"
                  &gt;??&lt;/span&gt;&lt;/dd&gt;
            &lt;/span&gt;
          &lt;/dl&gt;
          &lt;span tal:condition="options/batch/next_sequence"&gt;
            (&lt;span
              tal:replace="options/batch/next_sequence_start_item"
              &gt;next start item&lt;/span&gt;-&lt;span
              tal:replace="options/batch/next_sequence_end_item"
              &gt;next end item&lt;/span&gt;)
          &lt;/span&gt;
        &lt;/div&gt;
        &lt;p tal:condition="not:here/args"&gt;
          No arguments were given.
        &lt;/p&gt;
        And I am 100% sure!
&lt;/body&gt;
</t>
<t tx="ekr.20040104185913.4060">&lt;html tal:define="global x python:1"&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;div tal:define="x python:2"&gt;
    &lt;span tal:content="x"&gt;Should be 2 here!&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;span tal:content="x"&gt;Should be 1 here!&lt;/span&gt;
  &lt;/div&gt;
  &lt;div tal:define="global x python:3"&gt;
    &lt;span tal:content="x"&gt;Should be 3 here!&lt;/span&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4061">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Loop doc&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Choose your type:&lt;/p&gt;
&lt;ul&gt;
  &lt;li tal:repeat="type python:'digital', 'analog', 'organic'"&gt;
  &lt;a href="dummy" tal:attributes="href string:/mach/$type"&gt;
  &lt;span tal:replace="repeat/type/number"&gt;1&lt;/span&gt;.
  &lt;span tal:replace="type"&gt;selection&lt;/span&gt;&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4062">&lt;html&gt;
&lt;body tal:define="objects python:[
  {'name': 'fred', 'legs': 2},
  {'name': 'wilma', 'legs': 2},
  {'name': 'dino', 'legs': 4},
]"&gt;
&lt;tal:block repeat="ob objects"&gt;
  &lt;h4 tal:condition="repeat/ob/first/legs"&gt;Legs:
    &lt;span tal:replace="ob/legs"&gt;1&lt;/span&gt;&lt;/h4&gt;
  &lt;p tal:content="ob/name"&gt;Name&lt;/p&gt;
  &lt;hr tal:condition="repeat/ob/last/legs" /&gt;
&lt;/tal:block&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4063">&lt;html&gt;
&lt;head&gt;
   &lt;title tal:content="string:Hello World!"&gt;This is the title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;tal:block on-error="string:Error:${error/value}" replace="x" /&gt;
  &lt;tal:block on-error="string:Error:${error/value}"&gt;
    &lt;p tal:content="x"&gt;p&lt;/p&gt;
  &lt;/tal:block&gt;
  &lt;div tal:replace="structure string:&amp;lt;hr /&amp;gt;"&gt;rule&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4064">&lt;html metal:use-macro="container/laf/macros/page"&gt;
&lt;head&gt;
&lt;title&gt;Zope Stuff&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;link rel="stylesheet" href="/common.css"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
  &lt;tr bgcolor="#0000CC" align="center"&gt; 
    &lt;td&gt; 
      &lt;table width="200" border="0" cellspacing="0" cellpadding="0"&gt;
        &lt;tr bgcolor="#FFFFFF"&gt; 
          &lt;td&gt;&lt;img src="/images/lside.gif" width="52" height="94"&gt;&lt;img src="/images/swlogo.gif" width="150" height="89"&gt;&lt;img src="/images/rside.gif" width="52" height="94"&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table width="300" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr align="center"&gt; 
    &lt;td width="25%" class="boldbodylist"&gt;apparel&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;mugs&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;toys&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;misc&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div metal:fill-slot="body"&gt;
&lt;table width="500" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr&gt; 
    &lt;td bgcolor="#0000CC"&gt;
      &lt;table width="100%" border="0" cellspacing="1" cellpadding="3"&gt;
        &lt;tr bgcolor="#FFFFFF" align="center"&gt; 
          &lt;td&gt;&lt;img src="/images/welcome.gif" width="293" height="28"&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"
		    tal:repeat="product options/getProducts"&gt; 
          &lt;td&gt; 
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td colspan="2" class="bodylist" height="200" valign="top"&gt;&lt;b&gt;Description: 
                  &lt;/b&gt;&lt;span tal:replace="product/description"&gt;This is the tee for those who LOVE Zope. Show your heart 
                  on your tee.&lt;/span&gt;&lt;/td&gt;
                &lt;td align="right" width="1%" rowspan="2"&gt; 
                  &lt;p&gt;&lt;img src="/images/smlatee.jpg" width="200" height="200"
				          tal:attributes="src string:/images/${product/image}"&gt;&lt;/p&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt; 
                &lt;td class="bodylist"&gt;&lt;img src="images/clear.gif" width="150" height="10"&gt;&lt;/td&gt;
                  &lt;td class="bodylist"&gt;&lt;b&gt;Price&lt;/b&gt;:&lt;span tal:replace="product/price"&gt;12.99&lt;/span&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt;
          &lt;td&gt;
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td align="center"&gt;&lt;img src="images/buttons/submit.gif" width="87" height="30"&gt;&lt;/td&gt;
                &lt;td align="center"&gt;&lt;img src="images/buttons/cancel.gif" width="87" height="30"&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;table width="100%" border="0" cellspacing="1" cellpadding="3" align="center"&gt;
  &lt;tr &gt; 
    &lt;td align="center" bgcolor="#FFFFFF" class="bodylist"&gt; Copyright © 2000 &lt;a href="http://www.4-am.com"&gt;4AM 
      Productions, Inc.&lt;/a&gt;. All rights reserved. &lt;br&gt;
      Questions or problems should be directed to &lt;a href="mailto:webmaster@teamzonline.com"&gt; 
      the webmaster&lt;/a&gt;, 254-412-0846. &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; 
    &lt;td align="center"&gt;&lt;img src="/images/zopelogos/buildzope.gif" width="54" height="54"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4065">&lt;html metal:use-macro="container/laf/macros/page"&gt;
&lt;div metal:fill-slot="body"&gt;
Body
&lt;/div&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4066">&lt;html metal:define-macro="page"&gt;
&lt;head&gt;
&lt;title&gt;Zope Stuff&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;link rel="stylesheet" href="/common.css"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
  &lt;tr bgcolor="#0000CC" align="center"&gt; 
    &lt;td&gt; 
      &lt;table width="200" border="0" cellspacing="0" cellpadding="0"&gt;
        &lt;tr bgcolor="#FFFFFF"&gt; 
          &lt;td&gt;&lt;img src="/images/lside.gif" width="52" height="94"&gt;&lt;img src="/images/swlogo.gif" width="150" height="89"&gt;&lt;img src="/images/rside.gif" width="52" height="94"&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table width="300" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr align="center"&gt; 
    &lt;td width="25%" class="boldbodylist"&gt;apparel&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;mugs&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;toys&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;misc&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div metal:define-slot="body"&gt;
&lt;table width="500" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr&gt; 
    &lt;td bgcolor="#0000CC"&gt;
      &lt;table width="100%" border="0" cellspacing="1" cellpadding="3"&gt;
        &lt;tr bgcolor="#FFFFFF" align="center"&gt; 
          &lt;td&gt;&lt;img src="/images/welcome.gif" width="293" height="28"&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt; 
          &lt;td&gt; &lt;br&gt;
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td&gt;This is the tee for those who LOVE Zope. Show your heart on 
                  your tee.&lt;/td&gt;
                &lt;td align="right" width="1%"&gt; 
                  &lt;p&gt;&lt;img src="/images/smlatee.jpg" width="200" height="200"&gt;&lt;/p&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;&lt;br&gt;
&lt;table width="100%" border="0" cellspacing="1" cellpadding="3" align="center"&gt;
  &lt;tr&gt; 
    &lt;td align="center" bgcolor="#FFFFFF" class="bodylist"&gt;
      Copyright &amp;copy; 2000 
      &lt;a href="http://www.4-am.com"&gt;4AM Productions, Inc.&lt;/a&gt;.
      All rights reserved. &lt;br&gt;
      Questions or problems should be directed to
      &lt;a href="mailto:webmaster@teamzonline.com"&gt;the webmaster&lt;/a&gt;,
      254-412-0846.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; 
    &lt;td align="center"&gt;&lt;img src="/images/zopelogos/buildzope.gif" width="54" height="54"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4067">@language html</t>
<t tx="ekr.20040104185913.4068">&lt;html&gt;
 &lt;body&gt;
 &lt;p&gt;
 Batch 1: item=0
 &lt;/p&gt;
 &lt;p&gt;
 Batch 1: item=1
 &lt;/p&gt;
 &lt;p&gt;
 Batch 1: item=2
 &lt;/p&gt;
 &lt;p&gt;
 Batch 1: item=3
 &lt;/p&gt;
 &lt;p&gt;
 Batch 1: item=4
 &lt;/p&gt;
 &lt;p&gt;
 Batch 2: item=5
 &lt;/p&gt;
 &lt;p&gt;
 Batch 2: item=6
 &lt;/p&gt;
 &lt;p&gt;
 Batch 2: item=7
 &lt;/p&gt;
 &lt;p&gt;
 Batch 2: item=8
 &lt;/p&gt;
 &lt;p&gt;
 Batch 2: item=9
 &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4069">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p&gt;baz&lt;/p&gt;
   &lt;a href="foo" alt="alttext"&gt;link&lt;/a&gt;
   &lt;p&gt;
     Lomax was born in
     Antarctica.
   &lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4070">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p&gt;[foo](bar/{})&lt;/p&gt;
   &lt;a href="foo" alt="[default](alttext/{})"&gt;link&lt;/a&gt;
   &lt;p&gt;[dom](${name} was born in ${country}./{'country':'Antarctica','name':'Lomax'})&lt;/p&gt;
   &lt;p&gt;[default](hmm/{'age':25})&lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4071">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;0&lt;/div&gt;
&lt;div&gt;0&lt;/div&gt;
&lt;div&gt;0&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4072">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4073">&lt;html&gt;
&lt;body&gt;
   &lt;div&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;
   &lt;p&gt;X&lt;/p&gt;

   &lt;p name=""&gt;Z&lt;/p&gt;
   &lt;p name=""&gt;Z&lt;/p&gt;
   &lt;p name=""&gt;Z&lt;/p&gt;
   &lt;p name=""&gt;Z&lt;/p&gt;
   &lt;p&gt;Z&lt;/p&gt;

   &lt;p&gt;c&lt;/p&gt;
   &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4074">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4075">&lt;html&gt;
&lt;body&gt;
&lt;head&gt;
   &lt;p&gt;e acute=Ã©&lt;/p&gt;
&lt;/head&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4076">&lt;?xml version="1.0" ?&gt;
&lt;html&gt;
&lt;body&gt;Hello!&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4077">&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
      
      &lt;dl&gt;
        &lt;dt&gt;The arguments to this test program were:&lt;/dt&gt;
        &lt;dd&gt;
          &lt;ul&gt;
            &lt;li&gt;
              Argument number 1
              is one
            &lt;/li&gt;&lt;li&gt;
              Argument number 2
              is two
            &lt;/li&gt;&lt;li&gt;
              Argument number 3
              is three
            &lt;/li&gt;&lt;li&gt;
              Argument number 4
              is cha
            &lt;/li&gt;&lt;li&gt;
              Argument number 5
              is cha
            &lt;/li&gt;&lt;li&gt;
              Argument number 6
              is cha
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/dd&gt;
      &lt;/dl&gt;
      
      And thats da trooth.
  &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4078">&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;      
      &lt;p&gt;No arguments were given.&lt;/p&gt;
      And thats da trooth.
  &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4079">&lt;head&gt;&lt;title&gt;Test of documentation templates&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
        &lt;div&gt;
          The arguments were:
          
          &lt;dl&gt;
            &lt;span&gt;
              &lt;dt&gt;one.&lt;/dt&gt;
              &lt;dd&gt;Argument  1 was one&lt;/dd&gt;
            &lt;/span&gt;&lt;span&gt;
              &lt;dt&gt;two.&lt;/dt&gt;
              &lt;dd&gt;Argument  2 was two&lt;/dd&gt;
            &lt;/span&gt;&lt;span&gt;
              &lt;dt&gt;three.&lt;/dt&gt;
              &lt;dd&gt;Argument  3 was three&lt;/dd&gt;
            &lt;/span&gt;&lt;span&gt;
              &lt;dt&gt;four.&lt;/dt&gt;
              &lt;dd&gt;Argument  4 was four&lt;/dd&gt;
            &lt;/span&gt;&lt;span&gt;
              &lt;dt&gt;five.&lt;/dt&gt;
              &lt;dd&gt;Argument  5 was five&lt;/dd&gt;
            &lt;/span&gt;
          &lt;/dl&gt;
          &lt;span&gt;
            (six-ten)
          &lt;/span&gt;
        &lt;/div&gt;
        
        And I am 100% sure!
&lt;/body&gt;
</t>
<t tx="ekr.20040104185913.4080">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    &lt;span&gt;2&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;span&gt;1&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;span&gt;3&lt;/span&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4081">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Loop doc&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Choose your type:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
  &lt;a href="/mach/digital"&gt;
  1.
  digital&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;a href="/mach/analog"&gt;
  2.
  analog&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;a href="/mach/organic"&gt;
  3.
  organic&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4082">&lt;html&gt;
&lt;body&gt;

 &lt;h4&gt;Legs:
 2&lt;/h4&gt;
 &lt;p&gt;fred&lt;/p&gt;
 


 
 &lt;p&gt;wilma&lt;/p&gt;
 &lt;hr &gt;


 &lt;h4&gt;Legs:
 4&lt;/h4&gt;
 &lt;p&gt;dino&lt;/p&gt;
 &lt;hr &gt;

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4083">&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Error:x
  Error:x
  &lt;hr /&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4084">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Zope Stuff&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;link rel="stylesheet" href="/common.css"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
  &lt;tr bgcolor="#0000CC" align="center"&gt; 
    &lt;td&gt; 
      &lt;table width="200" border="0" cellspacing="0" cellpadding="0"&gt;
        &lt;tr bgcolor="#FFFFFF"&gt; 
          &lt;td&gt;&lt;img src="/images/lside.gif" width="52" height="94"&gt;&lt;img src="/images/swlogo.gif" width="150" height="89"&gt;&lt;img src="/images/rside.gif" width="52" height="94"&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table width="300" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr align="center"&gt; 
    &lt;td width="25%" class="boldbodylist"&gt;apparel&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;mugs&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;toys&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;misc&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div&gt;
&lt;table width="500" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr&gt; 
    &lt;td bgcolor="#0000CC"&gt;
      &lt;table width="100%" border="0" cellspacing="1" cellpadding="3"&gt;
        &lt;tr bgcolor="#FFFFFF" align="center"&gt; 
          &lt;td&gt;&lt;img src="/images/welcome.gif" width="293" height="28"&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt; 
          &lt;td&gt; 
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td colspan="2" class="bodylist" height="200" valign="top"&gt;&lt;b&gt;Description: 
                  &lt;/b&gt;This is the tee for those who LOVE Zope. Show your heart on your tee.&lt;/td&gt;
                &lt;td align="right" width="1%" rowspan="2"&gt; 
                  &lt;p&gt;&lt;img src="/images/smlatee.jpg"
                          width="200" height="200"&gt;&lt;/p&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt; 
                &lt;td class="bodylist"&gt;&lt;img src="images/clear.gif" width="150" height="10"&gt;&lt;/td&gt;
                  &lt;td class="bodylist"&gt;&lt;b&gt;Price&lt;/b&gt;:12.99&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt; 
          &lt;td&gt; 
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td colspan="2" class="bodylist" height="200" valign="top"&gt;&lt;b&gt;Description: 
                  &lt;/b&gt;This is the tee for Jim Fulton. He's the Zope Pope!&lt;/td&gt;
                &lt;td align="right" width="1%" rowspan="2"&gt; 
                  &lt;p&gt;&lt;img src="/images/smpztee.jpg"
                          width="200" height="200"&gt;&lt;/p&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt; 
                &lt;td class="bodylist"&gt;&lt;img src="images/clear.gif" width="150" height="10"&gt;&lt;/td&gt;
                  &lt;td class="bodylist"&gt;&lt;b&gt;Price&lt;/b&gt;:11.99&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt;
          &lt;td&gt;
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td align="center"&gt;&lt;img src="images/buttons/submit.gif" width="87" height="30"&gt;&lt;/td&gt;
                &lt;td align="center"&gt;&lt;img src="images/buttons/cancel.gif" width="87" height="30"&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;&lt;br&gt;
&lt;table width="100%" border="0" cellspacing="1" cellpadding="3" align="center"&gt;
  &lt;tr&gt; 
    &lt;td align="center" bgcolor="#FFFFFF" class="bodylist"&gt;
      Copyright &amp;copy; 2000 
      &lt;a href="http://www.4-am.com"&gt;4AM Productions, Inc.&lt;/a&gt;.
      All rights reserved. &lt;br&gt;
      Questions or problems should be directed to
      &lt;a href="mailto:webmaster@teamzonline.com"&gt;the webmaster&lt;/a&gt;,
      254-412-0846.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; 
    &lt;td align="center"&gt;&lt;img src="/images/zopelogos/buildzope.gif" width="54" height="54"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4085">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Zope Stuff&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;link rel="stylesheet" href="/common.css"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
  &lt;tr bgcolor="#0000CC" align="center"&gt; 
    &lt;td&gt; 
      &lt;table width="200" border="0" cellspacing="0" cellpadding="0"&gt;
        &lt;tr bgcolor="#FFFFFF"&gt; 
          &lt;td&gt;&lt;img src="/images/lside.gif" width="52" height="94"&gt;&lt;img src="/images/swlogo.gif" width="150" height="89"&gt;&lt;img src="/images/rside.gif" width="52" height="94"&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table width="300" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr align="center"&gt; 
    &lt;td width="25%" class="boldbodylist"&gt;apparel&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;mugs&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;toys&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;misc&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div&gt;
Body
&lt;/div&gt;
&lt;br&gt;&lt;br&gt;
&lt;table width="100%" border="0" cellspacing="1" cellpadding="3" align="center"&gt;
  &lt;tr&gt; 
    &lt;td align="center" bgcolor="#FFFFFF" class="bodylist"&gt;
      Copyright &amp;copy; 2000 
      &lt;a href="http://www.4-am.com"&gt;4AM Productions, Inc.&lt;/a&gt;.
      All rights reserved. &lt;br&gt;
      Questions or problems should be directed to
      &lt;a href="mailto:webmaster@teamzonline.com"&gt;the webmaster&lt;/a&gt;,
      254-412-0846.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; 
    &lt;td align="center"&gt;&lt;img src="/images/zopelogos/buildzope.gif" width="54" height="54"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4086">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Zope Stuff&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;link rel="stylesheet" href="/common.css"&gt;
&lt;/head&gt;

&lt;body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"&gt;
&lt;table width="100%" border="0" cellspacing="0" cellpadding="0"&gt;
  &lt;tr bgcolor="#0000CC" align="center"&gt; 
    &lt;td&gt; 
      &lt;table width="200" border="0" cellspacing="0" cellpadding="0"&gt;
        &lt;tr bgcolor="#FFFFFF"&gt; 
          &lt;td&gt;&lt;img src="/images/lside.gif" width="52" height="94"&gt;&lt;img src="/images/swlogo.gif" width="150" height="89"&gt;&lt;img src="/images/rside.gif" width="52" height="94"&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table width="300" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr align="center"&gt; 
    &lt;td width="25%" class="boldbodylist"&gt;apparel&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;mugs&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;toys&lt;/td&gt;
    &lt;td width="25%" class="boldbodylist"&gt;misc&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div&gt;
&lt;table width="500" border="0" cellspacing="0" cellpadding="0" align="center"&gt;
  &lt;tr&gt; 
    &lt;td bgcolor="#0000CC"&gt;
      &lt;table width="100%" border="0" cellspacing="1" cellpadding="3"&gt;
        &lt;tr bgcolor="#FFFFFF" align="center"&gt; 
          &lt;td&gt;&lt;img src="/images/welcome.gif" width="293" height="28"&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr bgcolor="#FFFFFF" align="center" valign="top"&gt; 
          &lt;td&gt; &lt;br&gt;
            &lt;table width="100%" border="0" cellspacing="0" cellpadding="6"&gt;
              &lt;tr&gt; 
                &lt;td&gt;This is the tee for those who LOVE Zope. Show your heart on 
                  your tee.&lt;/td&gt;
                &lt;td align="right" width="1%"&gt; 
                  &lt;p&gt;&lt;img src="/images/smlatee.jpg" width="200" height="200"&gt;&lt;/p&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;&lt;br&gt;
&lt;table width="100%" border="0" cellspacing="1" cellpadding="3" align="center"&gt;
  &lt;tr&gt; 
    &lt;td align="center" bgcolor="#FFFFFF" class="bodylist"&gt;
      Copyright &amp;copy; 2000 
      &lt;a href="http://www.4-am.com"&gt;4AM Productions, Inc.&lt;/a&gt;.
      All rights reserved. &lt;br&gt;
      Questions or problems should be directed to
      &lt;a href="mailto:webmaster@teamzonline.com"&gt;the webmaster&lt;/a&gt;,
      254-412-0846.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; 
    &lt;td align="center"&gt;&lt;img src="/images/zopelogos/buildzope.gif" width="54" height="54"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4087"></t>
<t tx="ekr.20040104185913.4088">@language html

&lt;html&gt;
  &lt;head&gt;
    &lt;title tal:content="template/title"&gt;The title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    
    &lt;h2&gt;&lt;span tal:replace="here/title_or_id"&gt;content title or id&lt;/span&gt;
        &lt;span tal:condition="template/title"
              tal:replace="template/title"&gt;optional template id&lt;/span&gt;&lt;/h2&gt;

    This is Page Template &lt;em tal:content="template/id"&gt;template id&lt;/em&gt;.
  &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20040104185913.4089"></t>
<t tx="ekr.20040104185913.4090">@nocolor

Zope 2.4 introduces a new way to register customized indexes
(see PluggableIndex interface). 

Changes to Indexes:

 New package structure

  -  The indexes (TextIndex, FieldIndex, KeywordIndex, PathIndex) shipped 
     with the Zope 2.4 distribution now live in 'lib/python/Products/PluginIndexes'. 
     Every index type has now its own package containing all dependent
     modules, DTML management files...

  - modules used by all index types reside in the 'common' directory

  - all dependencies from the 'lib/python/SearchIndex' directory were removed

  - 'lib/python/SearchIndex' is deprecated and should no longer be used.
    It is kept for backward compatibility. 



 Changes to all indexes:

  - every index type implements the PluggableIndex interface

  - 'common/util.py' provides functionality for handling the 'request'
    parameter of the _apply_index() function.  _apply_index() 
    now handles old-style ZCatalog parameters, passing of Record
    instances and dictionary-like parameters. See common/util.py
    for details.


 Changes to KeywordIndex:

  - default search operator 'or' may be overridden by specifying a new one as
    'operator' (see below)

  - internal changes


 Changes to FieldIndex:

  - internal changes

 Changes for PathIndex:
 
  - new index type


 Changes to TextIndex:

  - ZMI allows to select a different vocabulary. To use a vocabulary different
    from the ZCatalogs default vocabulary 'Vocabulary' you must create a new
    Vocabulary through the ZMI of the ZCatalog. After creating the vocabulary you
    can choose the vocabulary on the ZMI management screen for the text index.

  - the default operator might be overridden by specifying a new one
    as 'operator' (see below)

  - removed direct dependency from Splitter module. Splitter is now
    acquired from used vocabulary
    
  - usage of the 'textindex_operator' is deprecated

  - lots of internal rework


Changes to Vocabulary:

  - added Splitter selection on the add formular


Changes to ZCatalog

  - Vocabulary.py moved to Products/PluginIndexes/TextIndex. A wrapper 
    for backward compatibility is in place

  - added ZCatalogIndexes.py to provide access to indexes with pluggable
    index interface

  
  Parameter passing to the ZCatalog

    Parameter passing to the ZCatalog/Catalog has been enhanced and unified
    and is now much more logical.

    - Method 1: The old way to pass a query including parameters to an index XXX
      was to specify the query as value in the request dictionary. Additional 
      parameters were passed XXX_parameter : &lt;value&gt; in the request dictionary.
      (This method is deprecated).

    - Method 2: The query and all parameters to be passed to an index XXX are
      passed as dictionary inside the request dictionary. Example:
      
        old: &lt;dtml-in myCatalog(myindex='xx yy',myindex_usage':'blabla')
        new: &lt;dtml-in myCatalog(myindex={'query':'xx yy','XXXXX':'blabla')

        Please check the indexes documentation for informations about additional 
        parameters.

    - Method 3: Inside a formular you can use Record as types for parameter passing.
      Example:

            &lt;form action=...&gt;
            &lt;input type=text name="person.query:record" value=""&gt;
            &lt;input type=hidden name="person.operator:record" value="and"&gt;
            ..&lt;/form&gt;

            and in the DTML method:

             &lt;dtml-in myCatalog(person=person)&gt;

            This example will pass both parameters as a Record instance to the index
            'person'. 

   All index types of Zope support all three methods. On the DTML level only
   method 3 type parameter should be used. 



Backward compatibility:
  
  - any existing pre-2.4 ZCatalog should work under 2.4

  - pre-2.4 indexes of a ZCatalog are marked as 'pre-2.4 Index' in the Index view of the
    ZCatalog

  - '# objects' is set to 'not available' for pre-2.4 indexes


</t>
<t tx="ekr.20040104185913.4091">&lt;&lt; copyright &gt;&gt;

&lt;&lt; __init__ imports &gt;&gt;

_indexes =  ('TextIndex',
             'KeywordIndex',
             'FieldIndex',
             'PathIndex',
             'TopicIndex',
             'DateIndex',
             'DateRangeIndex',
            )

@others

for idx in _indexes:

    exec("manage_add%sForm = %s.%s.manage_add%sForm" % (idx,idx,idx,idx))
    exec("manage_add%s     = %s.%s.manage_add%s" % (idx,idx,idx,idx))</t>
<t tx="ekr.20040104185913.4092">import common.PluggableIndex as PluggableIndex
import common.ResultList     as ResultList
import common.UnIndex        as UnIndex

import PathIndex.PathIndex
import TextIndex.TextIndex
import FieldIndex.FieldIndex
import KeywordIndex.KeywordIndex
import TopicIndex.TopicIndex
import DateIndex.DateIndex
import DateRangeIndex.DateRangeIndex</t>
<t tx="ekr.20040104185913.4093">def initialize(context):

    for idx in _indexes:

        s = "context.registerClass( \
            %s.%s.%s,\
            permission='Add Pluggable Index', \
            constructors=(manage_add%sForm,\
                          manage_add%s),\
            icon='www/index.gif',\
            visibility=None\
         )" % (idx,idx,idx,idx,idx)

        exec(s)</t>
<t tx="ekr.20040104185913.4094"></t>
<t tx="ekr.20040104185913.4095">&lt;&lt; copyright &gt;&gt;

"""$Id: DateIndex.py,v 1.7.6.2 2003/06/17 18:14:25 sidnei Exp $
"""

&lt;&lt; DateIndex imports &gt;&gt;

_marker = []

@others
</t>
<t tx="ekr.20040104185913.4096">from types import StringType, FloatType, IntType
from DateTime.DateTime import DateTime
from Products.PluginIndexes import PluggableIndex
from Products.PluginIndexes.common.UnIndex import UnIndex
from Products.PluginIndexes.common.util import parseIndexRequest
from Products.PluginIndexes.common import safe_callable

from Globals import DTMLFile
from BTrees.IOBTree import IOBTree
from BTrees.OIBTree import OIBTree
from BTrees.IIBTree import IISet, union, intersection, multiunion
import time</t>
<t tx="ekr.20040104185913.4097">class DateIndex(UnIndex):
    """ Index for Dates """
	&lt;&lt; class DateIndex declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4098">__implements__ = (PluggableIndex.PluggableIndexInterface,)

meta_type = 'DateIndex'
query_options = ['query', 'range']

manage = manage_main = DTMLFile( 'dtml/manageDateIndex', globals() )
manage_main._setName( 'manage_main' )
manage_options = ( { 'label' : 'Settings'
                   , 'action' : 'manage_main'
                   },
                 )

</t>
<t tx="ekr.20040104185913.4099">def clear( self ):
    """ Complete reset """
    self._index = IOBTree()
    self._unindex = OIBTree()
</t>
<t tx="ekr.20040104185913.4100">def index_object( self, documentId, obj, threshold=None ):
    """index an object, normalizing the indexed value to an integer

       o Normalized value has granularity of one minute.

       o Objects which have 'None' as indexed value are *omitted*,
         by design.
    """
    returnStatus = 0

    try:
        date_attr = getattr( obj, self.id )
        if safe_callable( date_attr ):
            date_attr = date_attr()

        ConvertedDate = self._convert( value=date_attr, default=_marker )
    except AttributeError:
        ConvertedDate = _marker

    oldConvertedDate = self._unindex.get( documentId, _marker )

    if ConvertedDate != oldConvertedDate:
        if oldConvertedDate is not _marker:
            self.removeForwardIndexEntry(oldConvertedDate, documentId)

        if ConvertedDate is not _marker:
            self.insertForwardIndexEntry( ConvertedDate, documentId )
            self._unindex[documentId] = ConvertedDate

        returnStatus = 1

    return returnStatus
</t>
<t tx="ekr.20040104185913.4101">def _apply_index( self, request, cid='', type=type, None=None ):
    """Apply the index to query parameters given in the argument

    Normalize the 'query' arguments into integer values at minute
    precision before querying.
    """
    record = parseIndexRequest( request, self.id, self.query_options )
    if record.keys == None:
        return None

    keys = map( self._convert, record.keys )

    index = self._index
    r = None
    opr = None

    #experimental code for specifing the operator
    operator = record.get( 'operator', self.useOperator )
    if not operator in self.operators :
        raise RuntimeError, "operator not valid: %s" % operator

    # depending on the operator we use intersection or union
    if operator=="or":
        set_func = union
    else:
        set_func = intersection

    # range parameter
    range_arg = record.get('range',None)
    if range_arg:
        opr = "range"
        opr_args = []
        if range_arg.find("min") &gt; -1:
            opr_args.append("min")
        if range_arg.find("max") &gt; -1:
            opr_args.append("max")

    if record.get('usage',None):
        # see if any usage params are sent to field
        opr = record.usage.lower().split(':')
        opr, opr_args = opr[0], opr[1:]

    if opr=="range":   # range search
        if 'min' in opr_args:
            lo = min(keys)
        else:
            lo = None

        if 'max' in opr_args:
            hi = max(keys)
        else:
            hi = None

        if hi:
            setlist = index.values(lo,hi)
        else:
            setlist = index.values(lo)

        #for k, set in setlist:
            #if type(set) is IntType:
                #set = IISet((set,))
            #r = set_func(r, set)
        # XXX: Use multiunion!
        r = multiunion(setlist)

    else: # not a range search
        for key in keys:
            set = index.get(key, None)
            if set is not None:
                if type(set) is IntType:
                    set = IISet((set,))
                r = set_func(r, set)

    if type(r) is IntType:
        r = IISet((r,))

    if r is None:
        return IISet(), (self.id,)
    else:
        return r, (self.id,)
</t>
<t tx="ekr.20040104185913.4102">def _convert( self, value, default=None ):
    """Convert Date/Time value to our internal representation"""
    # XXX: Code patched 20/May/2003 by Kiran Jonnalagadda to
    # convert dates to UTC first.
    if isinstance( value, DateTime ):
        t_tup = value.toZone('UTC').parts()
    elif type( value ) in (FloatType, IntType):
        t_tup = time.gmtime( value )
    elif type( value ) is StringType:
        t_obj = DateTime( value ).toZone('UTC')
        t_tup = t_obj.parts()
    else:
        return default

    yr = t_tup[0]
    mo = t_tup[1]
    dy = t_tup[2]
    hr = t_tup[3]
    mn = t_tup[4]

    t_val = ( ( ( ( yr * 12 + mo ) * 31 + dy ) * 24 + hr ) * 60 + mn )

    try:
        # t_val must be IntType, not LongType
        return int(t_val)
    except OverflowError:
        raise OverflowError, (
            "%s is not within the range of indexable dates (index: %s)"
            % (value, self.id))
</t>
<t tx="ekr.20040104185913.4103">manage_addDateIndexForm = DTMLFile( 'dtml/addDateIndex', globals() )

def manage_addDateIndex( self, id, REQUEST=None, RESPONSE=None, URL3=None):
    """Add a Date index"""
    return self.manage_addIndex(id, 'DateIndex', extra=None, \
                    REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)
</t>
<t tx="ekr.20040104185913.4104">@nocolor

DateIndex README

  Overview

    Normal FieldIndexes *can* be used to index values which are DateTime
    instances, but they are hideously expensive:

    o DateTime instances are *huge*, both in RAM and on disk.

    o DateTime instances maintain an absurd amount of precision, far
      beyond any reasonable search criteria for "normal" cases.

    DateIndex is a pluggable index which addresses these two issues
    as follows:

    o It normalizes the indexed value to an integer representation
      with a granularity of one minute.

    o It normalizes the 'query' value into the same form.

    o Objects which return 'None' for the index query are omitted from
      the index.
</t>
<t tx="ekr.20040104185913.4105"># Empty on purpose
</t>
<t tx="ekr.20040104185913.4106"></t>
<t tx="ekr.20040104185913.4107">&lt;&lt; copyright &gt;&gt;

import Zope
import unittest

from DateTime import DateTime
from Products.PluginIndexes.DateIndex.DateIndex import DateIndex
from types import IntType, FloatType
import time

@others

if __name__ == '__main__':
    run()</t>
<t tx="ekr.20040104185913.4109">class Dummy:
	@others
</t>
<t tx="ekr.20040104185913.4110">def __init__(self, name, date):

    self._name  = name
    self._date = date
</t>
<t tx="ekr.20040104185913.4111">def name(self):
    return self._name
</t>
<t tx="ekr.20040104185913.4112">def date(self):
    return self._date
</t>
<t tx="ekr.20040104185913.4113">def __str__(self):
    return "&lt;Dummy %s, date %s&gt;" % (self._name, str(self._date))
</t>
<t tx="ekr.20040104185913.4114">class DI_Tests(unittest.TestCase):
	@others
</t>
<t tx="ekr.20040104185913.4115">def setUp(self):
    self._values = (
        (0, Dummy('a', None)),
        (1, Dummy('b', DateTime(0))),
        (2, Dummy('c', DateTime('2002-05-08 15:16:17'))),
        (3, Dummy('d', DateTime('2032-05-08 15:16:17'))),
        (4, Dummy('e', DateTime('2062-05-08 15:16:17'))),
        (5, Dummy('e', DateTime('2062-05-08 15:16:17'))),
        (6, Dummy('f', 1072742620.0)),
        (7, Dummy('f', 1072742900)),
    )
    self._index = DateIndex('date')
    self._noop_req  = {'bar': 123}
    self._request   = {'date': DateTime(0)}
    self._min_req   = {'date': DateTime('2032-05-08 15:16:17'),
        'date_usage': 'range:min'}
    self._max_req   = {'date': DateTime('2032-05-08 15:16:17'),
        'date_usage': 'range:max'}
    self._range_req = {'date': (DateTime('2002-05-08 15:16:17'),
                                DateTime('2062-05-08 15:16:17')),
                       'date_usage': 'range:min:max'}
    self._zero_req  = {'date': 0}
    self._none_req  = {'date': None}
    self._float_req = {'date': 1072742620.0}
    self._int_req   = {'date': 1072742900}
</t>
<t tx="ekr.20040104185913.4116">def _populateIndex( self ):
    for k, v in self._values:
        self._index.index_object(k, v)
</t>
<t tx="ekr.20040104185913.4117">def _checkApply(self, req, expectedValues):
    result, used = self._index._apply_index(req)
    if hasattr(result, 'keys'):
        result = result.keys()
    self.failUnlessEqual(used, ('date',))
    self.failUnlessEqual(len(result), len(expectedValues),
        '%s | %s' % (map(None, result), expectedValues))
    for k, v in expectedValues:
        self.failUnless(k in result)
</t>
<t tx="ekr.20040104185913.4118">def _convert(self, date):
    if type(date) in (FloatType, IntType):
        yr, mo, dy, hr, mn = time.gmtime(date)[:5]
    else:
        yr, mo, dy, hr, mn = date.toZone('UTC').parts()[:5]
    return (((yr * 12 + mo) * 31 + dy) * 24 + hr) * 60 + mn
</t>
<t tx="ekr.20040104185913.4119">def test_empty(self):
    empty = self._index

    self.failUnlessEqual(len(empty), 0)
    self.failUnlessEqual(len(empty.referencedObjects()), 0)

    self.failUnless(empty.getEntryForObject(1234) is None)
    marker = []
    self.failUnless(empty.getEntryForObject(1234, marker) is marker)
    empty.unindex_object(1234) # shouldn't throw

    self.failUnless(empty.hasUniqueValuesFor('date'))
    self.failIf(empty.hasUniqueValuesFor('foo'))
    self.failUnlessEqual(len(empty.uniqueValues('date')), 0)

    self.failUnless(empty._apply_index({'zed': 12345}) is None)

    self._checkApply(self._request, [])
    self._checkApply(self._min_req, [])
    self._checkApply(self._max_req, [])
    self._checkApply(self._range_req, [])
</t>
<t tx="ekr.20040104185913.4120">def test_retrieval( self ):
    self._populateIndex()
    values = self._values
    index = self._index

    self.failUnlessEqual(len(index), len(values) - 2) # One dupe, one empty
    self.failUnlessEqual(len(index.referencedObjects()), len(values) - 1)
        # One empty

    self.failUnless(index.getEntryForObject(1234) is None)
    marker = []
    self.failUnless(index.getEntryForObject(1234, marker) is marker)
    index.unindex_object(1234) # shouldn't throw

    for k, v in values:
        if v.date():
            self.failUnlessEqual(self._index.getEntryForObject(k),
                self._convert(v.date()))

    self.failUnlessEqual(len(index.uniqueValues('date')), len(values) - 2)
    self.failUnless(index._apply_index(self._noop_req) is None)

    self._checkApply(self._request, values[1:2])
    self._checkApply(self._min_req, values[3:6])
    self._checkApply(self._max_req, values[1:4] + values[6:])
    self._checkApply(self._range_req, values[2:6] + values[6:] )
    self._checkApply(self._float_req, [values[6]] )
    self._checkApply(self._int_req, [values[7]] )
</t>
<t tx="ekr.20040104185913.4121">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( DI_Tests ) )
    return suite
</t>
<t tx="ekr.20040104185913.4122">def run():
    unittest.TextTestRunner().run(test_suite())</t>
<t tx="ekr.20040104185913.4123"></t>
<t tx="ekr.20040104185913.4124">&lt;&lt; DateRangeIndex declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.4125">&lt;&lt; copyright &gt;&gt;

"""$Id: DateRangeIndex.py,v 1.4.6.1 2003/06/17 18:14:25 sidnei Exp $
"""

import os

from Products.PluginIndexes import PluggableIndex
from Products.PluginIndexes.common.UnIndex import UnIndex
from Products.PluginIndexes.common.util import parseIndexRequest
from Products.PluginIndexes.common import safe_callable
from OFS.SimpleItem import SimpleItem

from BTrees.IOBTree import IOBTree
from BTrees.IIBTree import IISet, IITreeSet, union, intersection, multiunion

from Globals import package_home, DTMLFile, InitializeClass
from AccessControl import ClassSecurityInfo
from DateTime.DateTime import DateTime

_dtmldir = os.path.join( package_home( globals() ), 'dtml' )

VIEW_PERMISSION         = 'View'
INDEX_MGMT_PERMISSION   = 'Manage ZCatalogIndex Entries'

</t>
<t tx="ekr.20040104185913.4126">class DateRangeIndex(UnIndex):
    """
        Index a date range, such as the canonical "effective-expiration"
        range in the CMF.  Any object may return None for either the
        start or the end date:  for the start date, this should be
        the logical equivalent of "since the beginning of time";  for the
        end date, "until the end of time".

        Therefore, divide the space of indexed objects into four containers:

        - Objects which always match ( i.e., they returned None for both );

        - Objects which match after a given time ( i.e., they returned None
          for the end date );

        - Objects which match until a given time ( i.e., they returned None
          for the start date );

        - Objects which match only during a specific interval.
    """
	&lt;&lt; class DateRangeIndex declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4127">__implements__ = ( PluggableIndex.PluggableIndexInterface, )

security = ClassSecurityInfo()

meta_type = "DateRangeIndex"

manage_options= ( { 'label'     : 'Properties'
                  , 'action'    : 'manage_indexProperties'
                  }
                ,
                )

query_options = ['query']

since_field = until_field = None

</t>
<t tx="ekr.20040104185913.4128">def __init__(self, id, since_field=None, until_field=None,
        caller=None, extra=None):

    if extra:
        since_field = extra.since_field
        until_field = extra.until_field

    self._setId(id)
    self._edit(since_field, until_field)
    self.clear()
</t>
<t tx="ekr.20040104185913.4129">security.declareProtected( VIEW_PERMISSION
                         , 'getSinceField'
                         )
def getSinceField( self ):
    """
    """
    return self._since_field
</t>
<t tx="ekr.20040104185913.4130">security.declareProtected( VIEW_PERMISSION
                         , 'getUntilField'
                         )
def getUntilField( self ):
    """
    """
    return self._until_field
</t>
<t tx="ekr.20040104185913.4131">manage_indexProperties = DTMLFile( 'manageDateRangeIndex', _dtmldir )

security.declareProtected( INDEX_MGMT_PERMISSION
                         , 'manage_edit'
                         )
def manage_edit( self, since_field, until_field, REQUEST ):
    """
    """
    self._edit( since_field, until_field )
    REQUEST[ 'RESPONSE' ].redirect( '%s/manage_main'
                                    '?manage_tabs_message=Updated'
                                  % REQUEST.get('URL2')
                                  )
</t>
<t tx="ekr.20040104185913.4132">security.declarePrivate( '_edit' )
def _edit( self, since_field, until_field ):
    """
        Update the fields used to compute the range.
    """
    self._since_field = since_field
    self._until_field = until_field
</t>
<t tx="ekr.20040104185913.4133">security.declareProtected( INDEX_MGMT_PERMISSION
                         , 'clear'
                         )
def clear( self ):
    """
        Start over fresh.
    """
    self._always        = IITreeSet()
    self._since_only    = IOBTree()
    self._until_only    = IOBTree()
    self._since         = IOBTree()
    self._until         = IOBTree()
    self._unindex       = IOBTree() # 'datum' will be a tuple of date ints
</t>
<t tx="ekr.20040104185913.4134">#
#   PluggableIndexInterface implementation (XXX inherit assertions?)
#
def getEntryForObject( self, documentId, default=None ):
    """
        Get all information contained for the specific object
        identified by 'documentId'.  Return 'default' if not found.
    """
    return self._unindex.get( documentId, default )
</t>
<t tx="ekr.20040104185913.4135">def index_object( self, documentId, obj, threshold=None ):
    """
        Index an object:

         - 'documentId' is the integer ID of the document

         - 'obj' is the object to be indexed

         - ignore threshold
    """
    if self._since_field is None:
        return 0

    since = getattr( obj, self._since_field, None )
    if safe_callable( since ):
        since = since()
    since = self._convertDateTime( since )

    until = getattr( obj, self._until_field, None )
    if safe_callable( until ):
        until = until()
    until = self._convertDateTime( until )

    datum = ( since, until )

    old_datum = self._unindex.get( documentId, None )
    if datum == old_datum: # No change?  bail out!
        return 0

    if old_datum is not None:
        old_since, old_until = old_datum
        self._removeForwardIndexEntry( old_since, old_until, documentId )

    self._insertForwardIndexEntry( since, until, documentId )
    self._unindex[ documentId ] = datum

    return 1
</t>
<t tx="ekr.20040104185913.4136">def unindex_object( self, documentId ):
    """
        Remove the object corresponding to 'documentId' from the index.
    """
    datum = self._unindex.get( documentId, None )

    if datum is None:
        return

    since, until = datum

    self._removeForwardIndexEntry( since, until, documentId )
    del self._unindex[ documentId ]
</t>
<t tx="ekr.20040104185913.4137">def uniqueValues( self, name=None, withLengths=0 ):
    """
        Return a list of unique values for 'name'.

        If 'withLengths' is true, return a sequence of tuples, in
        the form '( value, length )'.
    """
    if not name in ( self._since_field, self._until_field ):
        return []

    if name == self._since_field:

        t1 = self._since
        t2 = self._since_only

    else:

        t1 = self._until
        t2 = self._until_only

    result = []
    IntType = type( 0 )

    if not withValues:

        result.extend( t1.keys() )
        result.extend( t2.keys() )

    else:

        for key in t1.keys():
            set = t1[ key ]
            if type( set ) is IntType:
                length = 1
            else:
                length = len( set )
            result.append( ( key, length) )

        for key in t2.keys():
            set = t2[ key ]
            if type( set ) is IntType:
                length = 1
            else:
                length = len( set )
            result.append( ( key, length) )

    return tuple( result )
</t>
<t tx="ekr.20040104185913.4138">def _apply_index( self, request, cid='' ):
    """
        Apply the index to query parameters given in 'request', which
        should be a mapping object.

        If the request does not contain the needed parametrs, then
        return None.

        If the request contains a parameter with the name of the
        column + "_usage", snif for information on how to handle
        applying the index.

        Otherwise return two objects.  The first object is a ResultSet
        containing the record numbers of the matching records.  The
        second object is a tuple containing the names of all data fields
        used.
    """
    record = parseIndexRequest( request, self.getId() )
    if record.keys is None:
        return None

    term        = self._convertDateTime( record.keys[0] )

    #
    #   Aggregate sets for each bucket separately, to avoid
    #   large-small union penalties.
    #
    #until_only  = IISet()
    #map( until_only.update, self._until_only.values( term ) )
    # XXX use multi-union
    until_only = multiunion( self._until_only.values( term ) )

    #since_only  = IISet()
    #map( since_only.update, self._since_only.values( None, term ) )
    # XXX use multi-union
    since_only = multiunion( self._since_only.values( None, term ) )

    #until       = IISet()
    #map( until.update, self._until.values( term ) )
    # XXX use multi-union
    until = multiunion( self._until.values( term ) )

    #since       = IISet()
    #map( since.update, self._since.values( None, term ) )
    # XXX use multi-union
    since = multiunion( self._since.values( None, term ) )

    bounded     = intersection( until, since )

    #   Merge from smallest to largest.
    #result      = union( self._always, until_only )
    result      = union( bounded, until_only )
    result      = union( result, since_only )
    #result      = union( result, bounded )
    result      = union( result, self._always )

    return result, ( self._since_field, self._until_field )
</t>
<t tx="ekr.20040104185913.4139">#
#   ZCatalog needs this, although it isn't (yet) part of the interface.
#
security.declareProtected( VIEW_PERMISSION , 'numObjects' )
def numObjects( self ):
    """
    """
    return len( self._unindex )
</t>
<t tx="ekr.20040104185913.4140">#
#   Helper functions.
#
def _insertForwardIndexEntry( self, since, until, documentId ):
    """
        Insert 'documentId' into the appropriate set based on
        'datum'.
    """
    if since is None and until is None:

        self._always.insert( documentId )

    elif since is None:

        set = self._until_only.get( until, None )
        if set is None:
            set = self._until_only[ until ] = IISet()  # XXX: Store an int?
        set.insert( documentId )

    elif until is None:

        set = self._since_only.get( since, None )
        if set is None:
            set = self._since_only[ since ] = IISet()  # XXX: Store an int?
        set.insert( documentId )

    else:

        set = self._since.get( since, None )
        if set is None:
            set = self._since[ since ] = IISet()   # XXX: Store an int?
        set.insert( documentId )

        set = self._until.get( until, None )
        if set is None:
            set = self._until[ until ] = IISet() # XXX: Store an int?
        set.insert( documentId )
</t>
<t tx="ekr.20040104185913.4141">def _removeForwardIndexEntry( self, since, until, documentId ):
    """
        Remove 'documentId' from the appropriate set based on
        'datum'.
    """
    if since is None and until is None:

        self._always.remove( documentId )

    elif since is None:

        set = self._until_only.get( until, None )
        if set is not None:

            set.remove( documentId )

            if not set:
                del self._until_only[ until ]

    elif until is None:

        set = self._since_only.get( since, None )
        if set is not None:

            set.remove( documentId )

            if not set:
                del self._since_only[ since ]

    else:

        set = self._since.get( since, None )
        if set is not None:
            set.remove( documentId )

            if not set:
                del self._since[ since ]

        set = self._until.get( until, None )
        if set is not None:
            set.remove( documentId )

            if not set:
                del self._until[ until ]
</t>
<t tx="ekr.20040104185913.4142">def _convertDateTime( self, value ):
    if value is None:
        return value
    if type( value ) == type( '' ):
        dt_obj = DateTime( value )
        value = dt_obj.millis() / 1000 / 60 # flatten to minutes
    if isinstance( value, DateTime ):
        value = value.millis() / 1000 / 60 # flatten to minutes
    return int( value )
</t>
<t tx="ekr.20040104185913.4143">InitializeClass( DateRangeIndex )

manage_addDateRangeIndexForm = DTMLFile( 'addDateRangeIndex', _dtmldir )

def manage_addDateRangeIndex(self, id, extra=None,
        REQUEST=None, RESPONSE=None, URL3=None):
    """
        Add a date range index to the catalog, using the incredibly icky
        double-indirection-which-hides-NOTHING.
    """
    return self.manage_addIndex(id, 'DateRangeIndex', extra,
        REQUEST, RESPONSE, URL3)
</t>
<t tx="ekr.20040104185913.4144">DateRangeIndex README

  Overview

    Zope applications frequently wish to perform efficient queries
    against a pair of date attributes/methods, representing a time
    interval (e.g., effective / expiration dates).  This query *can*
    be done using a pair of indexes, but this implementation is
    hideously expensive:

    o DateTime instances are *huge*, both in RAM and on disk.

    o DateTime instances maintain an absurd amount of precision, far
      beyond any reasonable search criteria for "normal" cases.

    o Results must be fetched and intersected between two indexes.

    o Handling objects which do not specify both endpoints (i.e.,
      where the interval is open or half-open) is iffy, as the
      default value needs to be coerced into a different abnormal
      value for each end to permit ordered comparison.

    o The *very* common case of the open interval (neither endpoint
      specified) should be optimized.

    DateRangeIndex is a pluggable index which addresses these issues
    as follows:

    o It groups the "open" case into a special set, '_always'.

    o It maintains separate ordered sets for each of the "half-open"
      cases.

    o It performs the expensive "intersect two range search" operation
      only on the (usually small) set of objects which provide a
      closed interval.

    o It flattens the key values into integers with granularity of
      one minute.

    o It normalizes the 'query' value into the same form.
</t>
<t tx="ekr.20040104185913.4145"># Empty on purpose
</t>
<t tx="ekr.20040104185913.4146"></t>
<t tx="ekr.20040104185913.4147">&lt;&lt; test_DateRangeIndex declarations &gt;&gt;
@others

if __name__ == '__main__':
    run()
</t>
<t tx="ekr.20040104185913.4148">&lt;&lt; copyright &gt;&gt;

import Zope
import unittest

from Products.PluginIndexes.DateRangeIndex.DateRangeIndex import DateRangeIndex

</t>
<t tx="ekr.20040104185913.4149">class Dummy:
	@others
</t>
<t tx="ekr.20040104185913.4150">def __init__( self, name, start, stop ):

    self._name  = name
    self._start = start
    self._stop  = stop
</t>
<t tx="ekr.20040104185913.4151">def name( self ):

    return self._name
</t>
<t tx="ekr.20040104185913.4152">def start( self ):

    return self._start
</t>
<t tx="ekr.20040104185913.4153">def stop( self ):

    return self._stop
</t>
<t tx="ekr.20040104185913.4154">def datum( self ):

    return ( self._start, self._stop )
</t>
<t tx="ekr.20040104185913.4155">dummies = [ Dummy( 'a', None,   None )
          , Dummy( 'b', None,   None )
          , Dummy( 'c', 0,      None )
          , Dummy( 'd', 10,     None )
          , Dummy( 'e', None,   4    )
          , Dummy( 'f', None,   11   )
          , Dummy( 'g', 0,      11   )
          , Dummy( 'h', 2,      9    )
          ]

def matchingDummies( value ):
    result = []

    for dummy in dummies:

        if ( ( dummy.start() is None or dummy.start() &lt;= value )
         and ( dummy.stop() is None or dummy.stop() &gt;= value )
           ):
            result.append( dummy )

    return result
</t>
<t tx="ekr.20040104185913.4156">class DRI_Tests( unittest.TestCase ):
	@others
</t>
<t tx="ekr.20040104185913.4157">def setUp( self ):
    pass
</t>
<t tx="ekr.20040104185913.4158">def tearDown( self ):
    pass
</t>
<t tx="ekr.20040104185913.4159">def test_empty( self ):

    empty = DateRangeIndex( 'empty' )

    assert empty.getEntryForObject( 1234 ) is None
    empty.unindex_object( 1234 ) # shouldn't throw

    assert not empty.uniqueValues( 'foo' )
    assert not empty.uniqueValues( 'foo', 1 )

    assert empty._apply_index( { 'zed' : 12345 } ) is None

    result, used = empty._apply_index( { 'empty' : 12345 } )

    assert not result
    assert used == ( None, None )
</t>
<t tx="ekr.20040104185913.4160">def test_retrieval( self ):

    work = DateRangeIndex( 'work', 'start', 'stop' )

    for i in range( len( dummies ) ):
        work.index_object( i, dummies[i] )

    for i in range( len( dummies ) ):
        assert work.getEntryForObject( i ) == dummies[i].datum()

    for value in range( -1, 15 ):

        matches = matchingDummies( value )
        results, used = work._apply_index( { 'work' : value } )
        assert used == ( 'start', 'stop' )

        assert len( matches ) == len( results ), ( '%s: %s == %s'
           % ( value, map( lambda x: x.name(), matches ), results ) )

        matches.sort( lambda x, y: cmp( x.name(), y.name() ) )

        for result, match in map( None, results, matches ):
            assert work.getEntryForObject( result ) == match.datum()
</t>
<t tx="ekr.20040104185913.4161">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( DRI_Tests ) )
    return suite
</t>
<t tx="ekr.20040104185913.4162">def run():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.4163"></t>
<t tx="ekr.20040104185913.4164">&lt;&lt; FieldIndex declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.4165">&lt;&lt; copyright &gt;&gt;

"""Simple column indices

$Id: FieldIndex.py,v 1.10 2002/08/14 22:19:29 mj Exp $
"""

from Products.PluginIndexes import PluggableIndex
from Products.PluginIndexes.common.UnIndex import UnIndex

from Globals import DTMLFile

</t>
<t tx="ekr.20040104185913.4166">class FieldIndex(UnIndex):
    """Field Indexes"""
	&lt;&lt; class FieldIndex declarations &gt;&gt;
</t>
<t tx="ekr.20040104185913.4167">__implements__ = (PluggableIndex.PluggableIndexInterface,)

meta_type="FieldIndex"

manage_options= (
    {'label': 'Settings',
     'action': 'manage_main',
     'help': ('FieldIndex','FieldIndex_Settings.stx')},
)

query_options = ["query","range"]

index_html = DTMLFile('dtml/index', globals())

manage_workspace = DTMLFile('dtml/manageFieldIndex', globals())


</t>
<t tx="ekr.20040104185913.4168">manage_addFieldIndexForm = DTMLFile('dtml/addFieldIndex', globals())

def manage_addFieldIndex(self, id, REQUEST=None, RESPONSE=None, URL3=None):
    """Add a field index"""
    return self.manage_addIndex(id, 'FieldIndex', extra=None, \
             REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)
</t>
<t tx="ekr.20040104185913.4169"># empty comment for winzip and friends
</t>
<t tx="ekr.20040104185913.4170"></t>
<t tx="ekr.20040104185913.4171">&lt;&lt; testFieldIndex declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.4172">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest

import ZODB
from Products.PluginIndexes.FieldIndex.FieldIndex import FieldIndex

</t>
<t tx="ekr.20040104185913.4173">class Dummy:
	@others

    __repr__ = __str__</t>
<t tx="ekr.20040104185913.4174">def __init__( self, foo ):
    self._foo = foo
</t>
<t tx="ekr.20040104185913.4175">def foo( self ):
    return self._foo
</t>
<t tx="ekr.20040104185913.4176">def __str__( self ):
    return '&lt;Dummy: %s&gt;' % self._foo
</t>
<t tx="ekr.20040104185913.4177">class TestCase( unittest.TestCase ):
    """
        Test FieldIndex objects.
    """
	@others
</t>
<t tx="ekr.20040104185913.4178">def setUp( self ):
    """
    """
    self._index = FieldIndex( 'foo' )
    self._marker = []
    self._values = [ ( 0, Dummy( 'a' ) )
                   , ( 1, Dummy( 'ab' ) )
                   , ( 2, Dummy( 'abc' ) )
                   , ( 3, Dummy( 'abca' ) )
                   , ( 4, Dummy( 'abcd' ) )
                   , ( 5, Dummy( 'abce' ) )
                   , ( 6, Dummy( 'abce' ) )
                   , ( 7, Dummy( 0 ) ) #  Collector #1959
                   , ( 8, Dummy(None) )]
    self._forward = {}
    self._backward = {}
    for k, v in self._values:
        self._backward[k] = v
        keys = self._forward.get( v, [] )
        self._forward[v] = keys

    self._noop_req  = { 'bar': 123 }
    self._request   = { 'foo': 'abce' }
    self._min_req   = { 'foo': 'abc'
                      , 'foo_usage': 'range:min'
                      }
    self._max_req   = { 'foo': 'abc'
                      , 'foo_usage': 'range:max'
                      }
    self._range_req = { 'foo': ( 'abc', 'abcd' )
                      , 'foo_usage': 'range:min:max'
                      }
    self._zero_req  = { 'foo': 0 }
    self._none_req  = { 'foo': None }
</t>
<t tx="ekr.20040104185913.4179">def tearDown( self ):
    """
    """
</t>
<t tx="ekr.20040104185913.4180">def _populateIndex( self ):
    for k, v in self._values:
        self._index.index_object( k, v )
</t>
<t tx="ekr.20040104185913.4181">def _checkApply( self, req, expectedValues ):
    result, used = self._index._apply_index( req )
    if hasattr(result, 'keys'):
        result = result.keys()
    assert used == ( 'foo', )
    assert len( result ) == len( expectedValues ), \
      '%s | %s' % ( map( None, result ), expectedValues )
    for k, v in expectedValues:
        assert k in result
</t>
<t tx="ekr.20040104185913.4182">def testEmpty( self ):
    "Test an empty FieldIndex."

    assert len( self._index ) == 0
    assert len( self._index.referencedObjects() ) == 0

    assert self._index.getEntryForObject( 1234 ) is None
    assert ( self._index.getEntryForObject( 1234, self._marker )
              is self._marker )
    self._index.unindex_object( 1234 ) # nothrow

    assert self._index.hasUniqueValuesFor( 'foo' )
    assert not self._index.hasUniqueValuesFor( 'bar' )
    assert len( self._index.uniqueValues( 'foo' ) ) == 0

    assert self._index._apply_index( self._noop_req ) is None
    self._checkApply( self._request, [] )
    self._checkApply( self._min_req, [] )
    self._checkApply( self._max_req, [] )
    self._checkApply( self._range_req, [] )
</t>
<t tx="ekr.20040104185913.4183">def testPopulated( self ):
    """ Test a populated FieldIndex """
    self._populateIndex()
    values = self._values

    assert len( self._index ) == len( values )-1 #'abce' is duplicate
    assert len( self._index.referencedObjects() ) == len( values )

    assert self._index.getEntryForObject( 1234 ) is None
    assert ( self._index.getEntryForObject( 1234, self._marker )
              is self._marker )
    self._index.unindex_object( 1234 ) # nothrow

    for k, v in values:
        assert self._index.getEntryForObject( k ) == v.foo()

    assert len( self._index.uniqueValues( 'foo' ) ) == len( values )-1

    assert self._index._apply_index( self._noop_req ) is None

    self._checkApply( self._request, values[ -4:-2 ] )
    self._checkApply( self._min_req, values[ 2:-2 ] )
    self._checkApply( self._max_req, values[ :3 ] + values[ -2: ] )
    self._checkApply( self._range_req, values[ 2:5 ] )
</t>
<t tx="ekr.20040104185913.4184">def testZero( self ):
    """ Make sure 0 gets indexed """
    self._populateIndex()
    values = self._values
    self._checkApply( self._zero_req, values[ -2:-1 ] )
    assert 0 in self._index.uniqueValues( 'foo' )
</t>
<t tx="ekr.20040104185913.4185">def testNone(self):
    """ make sure None gets indexed """
    self._populateIndex()
    values = self._values
    self._checkApply(self._none_req, values[-1:])
    assert None in self._index.uniqueValues('foo')
</t>
<t tx="ekr.20040104185913.4186">def testReindex( self ):
    self._populateIndex()
    result, used = self._index._apply_index( {'foo':'abc'} )
    assert list(result)==[2]
    assert self._index.keyForDocument(2)=='abc'
    d = Dummy('world')
    self._index.index_object(2,d)
    result, used = self._index._apply_index( {'foo':'world'} )
    assert list(result)==[2]
    assert self._index.keyForDocument(2)=='world'
    del d._foo
    self._index.index_object(2,d)
    result, used = self._index._apply_index( {'foo':'world'} )
    assert list(result)==[]
    try:
        should_not_be = self._index.keyForDocument(2)
    except KeyError:
        # As expected, we deleted that attribute.
        pass
    else:
        # before Collector #291 this would be 'world'
        raise ValueError(repr(should_not_be))
</t>
<t tx="ekr.20040104185913.4187">def testRange(self):
    """Test a range search"""
    index = FieldIndex( 'foo' )
    for i in range(100):
        index.index_object(i, Dummy(i%10))

    record = { 'foo' : { 'query'  : [-99, 3]
                       , 'range'  : 'min:max'
                       }
             }
    r=index._apply_index( record )

    assert tuple(r[1])==('foo',), r[1]
    r=list(r[0].keys())

    expect=[
        0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33,
        40, 41, 42, 43, 50, 51, 52, 53, 60, 61, 62, 63, 70, 71, 72, 73,
        80, 81, 82, 83, 90, 91, 92, 93
        ]

    assert r==expect, r

    #
    #   Make sure that range tests with incompatible paramters
    #   don't return empty sets.
    #
    record[ 'foo' ][ 'operator' ] = 'and'
    r2, ignore = index._apply_index( record )
    r2 = list( r2.keys() )

    assert r2 == r
</t>
<t tx="ekr.20040104185913.4188">def test_suite():
    return unittest.makeSuite( TestCase )
</t>
<t tx="ekr.20040104185913.4189">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104185913.4190"></t>
<t tx="ekr.20040104185913.4191">&lt;&lt; KeywordIndex declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040104185913.4192">&lt;&lt; copyright &gt;&gt;

from types import StringType, UnicodeType

from zLOG import LOG, ERROR
from BTrees.OOBTree import OOSet, difference

from Globals import DTMLFile
from Products.PluginIndexes import PluggableIndex

from Products.PluginIndexes.common.UnIndex import UnIndex
from Products.PluginIndexes.common import safe_callable

</t>
<t tx="ekr.20040104185913.4193">class KeywordIndex(UnIndex):
	&lt;&lt; class KeywordIndex declarations &gt;&gt;
	@others


    index_html = DTMLFile('dtml/index', globals())
    manage_workspace = DTMLFile('dtml/manageKeywordIndex', globals())</t>
<t tx="ekr.20040104185913.4194">__implements__ = (PluggableIndex.PluggableIndexInterface,)

meta_type="KeywordIndex"

manage_options= (
    {'label': 'Settings',
     'action': 'manage_main',
     'help': ('KeywordIndex','KeywordIndex_Settings.stx')},
)

query_options = ["query","operator"]


"""Like an UnIndex only it indexes sequences of items

Searches match any keyword.

This should have an _apply_index that returns a relevance score
"""

</t>
<t tx="ekr.20040104185913.4195">def index_object(self, documentId, obj, threshold=None):
    """ index an object 'obj' with integer id 'i'

    Ideally, we've been passed a sequence of some sort that we
    can iterate over. If however, we haven't, we should do something
    useful with the results. In the case of a string, this means
    indexing the entire string as a keyword."""

    # First we need to see if there's anything interesting to look at
    # self.id is the name of the index, which is also the name of the
    # attribute we're interested in.  If the attribute is callable,
    # we'll do so.

    newKeywords = self._get_object_keywords(obj)

    oldKeywords = self._unindex.get(documentId, None)

    if oldKeywords is None:
        # we've got a new document, let's not futz around.
        try:
            for kw in newKeywords:
                self.insertForwardIndexEntry(kw, documentId)
            self._unindex[documentId] = list(newKeywords)
        except TypeError:
            return 0
    else:
        # we have an existing entry for this document, and we need
        # to figure out if any of the keywords have actually changed
        if type(oldKeywords) is not OOSet:
            oldKeywords = OOSet(oldKeywords)
        newKeywords = OOSet(newKeywords)
        fdiff = difference(oldKeywords, newKeywords)
        rdiff = difference(newKeywords, oldKeywords)
        if fdiff or rdiff:
            # if we've got forward or reverse changes
            self._unindex[documentId] = list(newKeywords)
            if fdiff:
                self.unindex_objectKeywords(documentId, fdiff)
            if rdiff:
                for kw in rdiff:
                    self.insertForwardIndexEntry(kw, documentId)
    return 1
</t>
<t tx="ekr.20040104185913.4196">def _get_object_keywords(self,obj):
    newKeywords = getattr(obj, self.id, ())

    if safe_callable(newKeywords):
        newKeywords = newKeywords()

    if (isinstance(newKeywords, StringType)
        or isinstance(newKeywords, UnicodeType)): #Python 2.1 compat isinstance
        return (newKeywords,)
    else:
        unique = {}
        try:
            for k in newKeywords:
                unique[k] = None
        except TypeError:
            # Not a sequence
            return (newKeywords,)
        else:
            return unique.keys()
</t>
<t tx="ekr.20040104185913.4197">def unindex_objectKeywords(self, documentId, keywords):
    """ carefully unindex the object with integer id 'documentId'"""

    if keywords is not None:
        for kw in keywords:
            self.removeForwardIndexEntry(kw, documentId)
</t>
<t tx="ekr.20040104185913.4198">def unindex_object(self, documentId):
    """ carefully unindex the object with integer id 'documentId'"""

    keywords = self._unindex.get(documentId, None)
    self.unindex_objectKeywords(documentId, keywords)
    try:
        del self._unindex[documentId]
    except KeyError:
        LOG('UnKeywordIndex', ERROR, 'Attempt to unindex nonexistent'
            ' document id %s' % documentId)
</t>
<t tx="ekr.20040104185913.4199">manage_addKeywordIndexForm = DTMLFile('dtml/addKeywordIndex', globals())

def manage_addKeywordIndex(self, id, REQUEST=None, RESPONSE=None, URL3=None):
    """Add a keyword index"""
    return self.manage_addIndex(id, 'KeywordIndex', extra=None, \
              REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)
</t>
<t tx="ekr.20040104185913.4200"># empty comment for winzip and friends
</t>
<t tx="ekr.20040104185913.4201"></t>
<t tx="ekr.20040104185913.4202">&lt;&lt; copyright &gt;&gt;

# This file is needed to make this a package.
</t>
<t tx="ekr.20040104185913.4203">&lt;&lt; testKeywordIndex declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()

</t>
<t tx="ekr.20040104185913.4204">&lt;&lt; copyright &gt;&gt;
import os, sys, unittest, zLOG

from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex

</t>
<t tx="ekr.20040104185913.4205">class Dummy:
	@others

    __repr__ = __str__</t>
<t tx="ekr.20040104185913.4206">def __init__( self, foo ):
    self._foo = foo
</t>
<t tx="ekr.20040104185913.4207">def foo( self ):
    return self._foo
</t>
<t tx="ekr.20040104185913.4208">def __str__( self ):
    return '&lt;Dummy: %s&gt;' % self._foo
</t>
<t tx="ekr.20040104185913.4209">def sortedUnique(seq):
    unique = {}
    for i in seq:
        unique[i] = None
    unique = unique.keys()
    unique.sort()
    return unique
</t>
<t tx="ekr.20040104185913.4210">class TestKeywordIndex( unittest.TestCase ):
    """
        Test KeywordIndex objects.
    """
	&lt;&lt; class TestKeywordIndex declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040104185913.4211">_old_log_write = None

</t>
<t tx="ekr.20040104185913.4212">def setUp( self ):
    """
    """
    self._index = KeywordIndex( 'foo' )
    self._marker = []
    self._values = [ ( 0, Dummy( ['a'] ) )
                   , ( 1, Dummy( ['a','b'] ) )
                   , ( 2, Dummy( ['a','b','c'] ) )
                   , ( 3, Dummy( ['a','b','c','a'] ) )
                   , ( 4, Dummy( ['a', 'b', 'c', 'd'] ) )
                   , ( 5, Dummy( ['a', 'b', 'c', 'e'] ) )
                   , ( 6, Dummy( ['a', 'b', 'c', 'e', 'f'] ))
                   , ( 7, Dummy( [0] ) )
                   ]
    self._noop_req  = { 'bar': 123 }
    self._all_req = { 'foo': ['a'] }
    self._some_req = { 'foo': ['e'] }
    self._overlap_req = { 'foo': ['c', 'e'] }
    self._string_req = {'foo': 'a'}
    self._zero_req  = { 'foo': [0] }
</t>
<t tx="ekr.20040104185913.4213">def tearDown( self ):
    """
    """
</t>
<t tx="ekr.20040104185913.4214">def _catch_log_errors( self ):

    if self._old_log_write is not None:
        return

    def log_write(subsystem, severity, summary, detail, error,
                PROBLEM=zLOG.PROBLEM):
        if severity &gt; PROBLEM:
            assert 0, "%s(%s): %s" % (subsystem, severity, summary)

    self._old_log_write = zLOG.log_write
    zLOG.log_write = log_write
</t>
<t tx="ekr.20040104185913.4215">def _ignore_log_errors( self ):

    if self._old_log_write is None:
        return

    zLOG.log_write = self._old_log_write
    del self._old_log_write
</t>
<t tx="ekr.20040104185913.4216">def _populateIndex( self ):
    for k, v in self._values:
        self._index.index_object( k, v )
</t>
<t tx="ekr.20040104185913.4217">def _checkApply( self, req, expectedValues ):
    result, used = self._index._apply_index( req )
    assert used == ( 'foo', )
    assert len(result) == len( expectedValues ), \
      '%s | %s' % ( map( None, result ),
                    map(lambda x: x[0], expectedValues ))

    if hasattr(result, 'keys'): result=result.keys()
    for k, v in expectedValues:
        assert k in result
</t>
<t tx="ekr.20040104185913.4218">def testAddObjectWOKeywords(self):

    self._catch_log_errors()
    try:
        self._populateIndex()
        self._index.index_object(999, None)
    finally:
        self._ignore_log_errors()
</t>
<t tx="ekr.20040104185913.4219">def testEmpty( self ):
    assert len( self._index ) == 0
    assert len( self._index.referencedObjects() ) == 0

    assert self._index.getEntryForObject( 1234 ) is None
    assert ( self._index.getEntryForObject( 1234, self._marker )
              is self._marker ), self._index.getEntryForObject(1234)
    self._index.unindex_object( 1234 ) # nothrow

    assert self._index.hasUniqueValuesFor( 'foo' )
    assert not self._index.hasUniqueValuesFor( 'bar' )
    assert len( self._index.uniqueValues( 'foo' ) ) == 0

    assert self._index._apply_index( self._noop_req ) is None
    self._checkApply( self._all_req, [] )
    self._checkApply( self._some_req, [] )
    self._checkApply( self._overlap_req, [] )
    self._checkApply( self._string_req, [] )
</t>
<t tx="ekr.20040104185913.4220">def testPopulated( self ):
    self._populateIndex()
    values = self._values

    #assert len( self._index ) == len( values )
    assert len( self._index.referencedObjects() ) == len( values )

    assert self._index.getEntryForObject( 1234 ) is None
    assert ( self._index.getEntryForObject( 1234, self._marker )
              is self._marker )
    self._index.unindex_object( 1234 ) # nothrow

    for k, v in values:
        entry = self._index.getEntryForObject( k )
        entry.sort()
        kw = sortedUnique(v.foo())
        self.assertEqual(entry, kw)

    assert (len( self._index.uniqueValues( 'foo' ) ) == len( values )-1,
            len(values)-1)

    assert self._index._apply_index( self._noop_req ) is None

    self._checkApply( self._all_req, values[:-1])
    self._checkApply( self._some_req, values[ 5:7 ] )
    self._checkApply( self._overlap_req, values[2:7] )
    self._checkApply( self._string_req, values[:-1] )
</t>
<t tx="ekr.20040104185913.4221">def testZero( self ):
    self._populateIndex()
    values = self._values
    self._checkApply( self._zero_req, values[ -1: ] )
    assert 0 in self._index.uniqueValues( 'foo' )
</t>
<t tx="ekr.20040104185913.4222">def testReindexChange(self):
    self._populateIndex()
    expected = Dummy(['x', 'y'])
    self._index.index_object(6, expected)
    result, used = self._index._apply_index({'foo': ['x', 'y']})
    result=result.keys()
    assert len(result) == 1
    assert result[0] == 6
    result, used = self._index._apply_index(
        {'foo': ['a', 'b', 'c', 'e', 'f']}
        )
    result = result.keys()
    assert 6 not in result
</t>
<t tx="ekr.20040104185913.4223">def testReindexNoChange(self):
    self._populateIndex()
    expected = Dummy(['foo', 'bar'])
    self._index.index_object(8, expected)
    result, used = self._index._apply_index(
        {'foo': ['foo', 'bar']})
    result = result.keys()
    assert len(result) == 1
    assert result[0] == 8
    self._index.index_object(8, expected)
    result, used = self._index._apply_index(
        {'foo': ['foo', 'bar']})
    result = result.keys()
    assert len(result) == 1
    assert result[0] == 8
</t>
<t tx="ekr.20040104185913.4224">def testIntersectionWithRange(self):
    # Test an 'and' search, ensuring that 'range' doesn't mess it up.
    self._populateIndex()

    record = { 'foo' : { 'query'  : [ 'e', 'f' ]
                       , 'operator' : 'and'
                       }
             }
    self._checkApply( record, self._values[6:7] )

    #
    #   Make sure that 'and' tests with incompatible paramters
    #   don't return empty sets.
    #
    record[ 'foo' ][ 'range' ] = 'min:max'
    self._checkApply( record, self._values[6:7] )
</t>
<t tx="ekr.20040104185913.4225">def testDuplicateKeywords(self):
    self._catch_log_errors()
    try:
        self._index.index_object(0, Dummy(['a', 'a', 'b', 'b']))
        self._index.unindex_object(0)
    finally:
        self._ignore_log_errors()
</t>
<t tx="ekr.20040104185913.4226">def test_suite():
    suite = unittest.TestSuite()
    suite.addTest( unittest.makeSuite( TestKeywordIndex ) )
    return suite
</t>
<t tx="ekr.20040104185913.4227">def main():
    unittest.main(defaultTest='test_suite')
</t>
<t tx="ekr.20040104185913.4228"></t>
<t tx="ekr.20040104185913.4229">&lt;&lt; copyright &gt;&gt;

__version__ = '$Id: PathIndex.py,v 1.25.6.7 2003/06/17 18:14:27 sidnei Exp $'

&lt;&lt; PathIndex imports &gt;&gt;

_marker = []

@others
</t>
<t tx="ekr.20040104185913.4230">from Products.PluginIndexes import PluggableIndex
from Products.PluginIndexes.common.util import parseIndexRequest
from Products.PluginIndexes.common import safe_callable

from Globals import Persistent, DTMLFile
from Acquisition import Implicit

from BTrees.IOBTree import IOBTree
from BTrees.OOBTree import OOBTree
from BTrees.IIBTree import IITreeSet, IISet, intersection, union
from OFS.SimpleItem import SimpleItem
from zLOG import LOG, ERROR
from types import StringType, ListType, TupleType
import re, warnings</t>
<t tx="ekr.20040104185913.4231">class PathIndex(Persistent, Implicit, SimpleItem):
    """ A path index stores all path components of the physical
    path of an object:

    Internal datastructure:

    - a physical path of an object is split into its components

    - every component is kept as a  key of a OOBTree in self._indexes

    - the value is a mapping 'level of the path component' to
      'all documentIds with this path component on this level'

    """
	&lt;&lt; class PathIndex declarations &gt;&gt;
	@others


    index_html = DTMLFile('dtml/index', globals())
    manage_workspace = DTMLFile('dtml/managePathIndex', globals())</t>
<t tx="ekr.20040104185913.4232">__implements__ = (PluggableIndex.PluggableIndexInterface,)

meta_type="PathIndex"

manage_options= (
    {'label': 'Settings',
     'action': 'manage_main',
     'help': ('PathIndex','PathIndex_Settings.stx')},
)

query_options = ["query","level","operator"]


</t>
<t tx="ekr.20040104185913.4233">def __init__(self,id,caller=None):
    self.id = id

    # experimental code for specifing the operator
    self.operators = ['or','and']
    self.useOperator = 'or'

    self.clear()
</t>
<t tx="ekr.20040104185913.4234">def getId(self): return self.id
</t>
<t tx="ekr.20040104185913.4235">def clear(self):
    """ clear everything """

    self._depth   = 0
    self._index   = OOBTree()
    self._unindex = IOBTree()
</t>
<t tx="ekr.20040104185913.4236">def insertEntry(self,comp,id,level):
    """
    k is a path component (generated by splitPath() )
    v is the documentId
    level is the level of the component inside the path
    """

    if not self._index.has_key(comp):
        self._index[comp] = IOBTree()

    if not self._index[comp].has_key(level):
        self._index[comp][level] = IITreeSet()

    self._index[comp][level].insert(id)

    if level &gt; self._depth: self._depth = level
</t>
<t tx="ekr.20040104185913.4237">def index_object(self, documentId, obj ,threshold=100):
    """ hook for (Z)Catalog """

    # first we check if the object provide an attribute or
    # method to be used as hook for the PathIndex

    if hasattr(obj,self.id):
        f = getattr(obj,self.id)

        try:
            if safe_callable(f): path = f()
            else:           path = f
        except:
            return 0

        if not (isinstance(path,StringType) or
                isinstance(path,TupleType)):
            raise TypeError, "attribute/method must be/return string or tuple"

    else:

        try:
            path = obj.getPhysicalPath()
        except:
            return 0

    if type(path) in (ListType,TupleType):
        path = '/'+ '/'.join(path[1:])

    comps = self.splitPath(path,obj)

#        if obj.meta_type != 'Folder':
#            comps = comps[:-1]

    for i in range(len(comps)):
        self.insertEntry( comps[i],documentId,i)

    self._unindex[documentId] = path

    return 1
</t>
<t tx="ekr.20040104185913.4238">def unindex_object(self,documentId):
    """ hook for (Z)Catalog """

    if not self._unindex.has_key(documentId):
        LOG(self.__class__.__name__, ERROR,
            'Attempt to unindex nonexistent document'
            ' with id %s' % documentId)
        return
    
    path = self._unindex[documentId]
    comps = path.split('/')

    for level in range(len(comps[1:])):
        comp = comps[level+1]

        try:
            self._index[comp][level].remove(documentId)

            if not self._index[comp][level]:
                del self._index[comp][level]

            if not self._index[comp]:
                del self._index[comp]
        except KeyError:
            LOG(self.__class__.__name__, ERROR,
                'Attempt to unindex document'
                ' with id %s failed' % documentId)


    del self._unindex[documentId]
</t>
<t tx="ekr.20040104185913.4239">def printIndex(self):
    for k,v in self._index.items():
        print "-"*78
        print k
        for k1,v1 in v.items():
            print k1,v1,

        print
</t>
<t tx="ekr.20040104185913.4240">def splitPath(self,path,obj=None):
    """ split physical path of object. If the object has
    as function splitPath() we use this user-defined function
    to split the path
    """

    if hasattr(obj,"splitPath"):
        comps = obj.splitPath(path)
    else:
        comps = filter(lambda x: x , re.split("/",path))

    return comps
</t>
<t tx="ekr.20040104185913.4241">def search(self,path,default_level=0):
    """
    path is either a string representing a
    relative URL or a part of a relative URL or
    a tuple (path,level).

    level&gt;=0  starts searching at the given level
    level&lt;0   not implemented yet
    """

    if isinstance(path,StringType):
        level = default_level
    else:
        level = int(path[1])
        path  = path[0]

    comps = self.splitPath(path)

    if len(comps) == 0:
        return IISet(self._unindex.keys())

    if level &gt;=0:

        results = []
        for i in range(len(comps)):
            comp = comps[i]

            if not self._index.has_key(comp): return IISet()
            if not self._index[comp].has_key(level+i): return IISet()

            results.append( self._index[comp][level+i] )
        
        res = results[0]

        for i in range(1,len(results)):
            res = intersection(res,results[i])

        return res

    else:

        results = IISet()

        for level in range(0,self._depth + 1):

            ids = None
            error = 0

            for cn in range(0,len(comps)):
                comp = comps[cn]

                try:
                    ids = intersection(ids,self._index[comp][level+cn])
                except KeyError:
                    error = 1

            if error==0:
                results = union(results,ids)

        return results
</t>
<t tx="ekr.20040104185913.4242">def __len__(self):
    """ len """
    return len(self._index)
</t>
<t tx="ekr.20040104185913.4243">def numObjects(self):
    """ return the number of indexed objects"""
    return len(self._unindex)
</t>
<t tx="ekr.20040104185913.4244">def keys(self):
    """ return list of all path components """
    keys = []
    for k in self._index.keys(): keys.append(k)
    return keys
</t>
<t tx="ekr.20040104185913.4245">def values(self):
    values = []
    for k in self._index.values(): values.append(k)
    return values
</t>
<t tx="ekr.20040104185913.4246">def items(self):
    """ mapping path components : documentIds """

    items = []
    for k in self._index.items(): items.append(k)
    return items
</t>
<t tx="ekr.20040104185913.4247">def _apply_index(self, request, cid=''):
    """ hook for (Z)Catalog
    request   mapping type (usually {"path": "..." }
              additionaly a parameter "path_level" might be passed
              to specify the level (see search())

    cid      ???
    """

    record = parseIndexRequest(request,self.id,self.query_options)
    if record.keys==None: return None

    if request.has_key('%s_level' % cid):
        warnings.warn("The usage of the '%s_level' "
                      "is no longer recommended.\n"
                      "Please use a mapping object and the "
                      "'level' key to specify the operator." % cid)


    # get the level parameter
    level    = record.get("level",0)

    # experimental code for specifing the operator
    operator = record.get('operator',self.useOperator).lower()

    # depending on the operator we use intersection of union
    if operator=="or":  set_func = union
    else:               set_func = intersection

    res = None

    for k in record.keys:
        rows = self.search(k,level)
        res = set_func(res,rows)

    if res:
        return res, (self.id,)
    else:
        return IISet(), (self.id,)
</t>
<t tx="ekr.20040104185913.4248">def uniqueValues(self,name=None,withLength=0):
    """ needed to be consistent with the interface """

    return self._index.keys()
</t>
<t tx="ekr.20040104185913.4249">def getEntryForObject(self,documentId,default=_marker):
    """ Takes a document ID and returns all the information we have
    on that specific object. """

    try:
        return self._unindex[documentId]
    except:
        return None
</t>
<t tx="ekr.20040104185913.4250">manage_addPathIndexForm = DTMLFile('dtml/addPathIndex', globals())

def manage_addPathIndex(self, id, REQUEST=None, RESPONSE=None, URL3=None):
    """Add a path index"""
    return self.manage_addIndex(id, 'PathIndex', extra=None, \
                REQUEST=REQUEST, RESPONSE=RESPONSE, URL1=URL3)</t>
<t tx="ekr.20040104185913.4251">@nocolor

The purpose of a PathIndex is to index Zope objects
based on their physical path. This is very similiar
to a substring search on strings.
 
 How it works
 
   Assume we have to index an object with id=xxx and
   the physical path '/zoo/animals/africa/tiger.doc'.
 
   We split the path into its components and keep track
   of the level of every component. Inside the index we
   store pairs(component,level) and the ids of the
   documents::
 
        (component,level)     id of document
        -----------------------------------------
 
           ('zoo',0)           xxx
           ('animals',1)       xxx
           ('africa',2)        xxx
 
 
   Note that we do not store the id of the objects itself
   inside the path index.
 
 
  Searching with the PathIndex
 
   The PathIndex allows you to search for all object ids
   whose objects match a physical path query. The query
   is split into components and matched against the index.
   E.g. '/zoo/animals' will match in the example above
   but not '/zoo1/animals'. The default behaviour is to
   start matching at level 0. To start matching on another
   level on can specify an additional level parameter
   (see API)

  API
 
   'query' -- A single or list of Path component(s) to 
   be searched.

   'level' -- level to start searching (optional,default: 0). 
   If level=-1 we search through all levels.
 
   'operator' -- either 'or' or 'and' (optional, default: 'or')
 
  Example
 
    Objects with the following ids and physical path should
    be stored in the ZCatalog 'MyCAT'::
 
 
       id         physical path
     ----------------------------
 
       1          /aa/bb/aa/1.txt
       2          /aa/bb/bb/2.txt
       3          /aa/bb/cc/3.txt
       4          /bb/bb/aa/4.txt
       5          /bb/bb/bb/5.txt
       6          /bb/bb/cc/6.txt
       7          /cc/bb/aa/7.txt
       8          /cc/bb/bb/8.txt
       9          /cc/bb/cc/9.txt
 
 
 
     Query                        found ids
     -------------------------------------------
 
     query='/aa/bb',level=0        [1,2,3]
     query='/bb/bb',level=0        [4,5,6]
     query='/bb/bb',level=1        [2,5,8]
     query='/bb/bb',level=-1       [2,4,5,6,8]
     query='/xx'   ,level=-1       []

</t>
<t tx="ekr.20040104185913.4252"># empty comment for winzip and friends
</t>
<t tx="ekr.20040104185913.4253"></t>
<t tx="ekr.20040104185913.4254">&lt;&lt; copyright &gt;&gt;

import os, sys, unittest
from Products.PluginIndexes.PathIndex.PathIndex import PathIndex

@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20040104185913.4256">class Dummy:
	&lt;&lt; class Dummy declarations &gt;&gt;
	@others

    __repr__ = __str__</t>
<t tx="ekr.20040104185913.4257">meta_type="foo"
</t>
<t tx="ekr.20040104185913.4258">def __init__( self, path):
    self.path = path
</t>
<t tx="ekr.20040104185913.4259">def getPhysicalPath(self):
    return self.path.split('/')
</t>
<t tx="ekr.20040104185913.4260">def __str__( self ):
    return '&lt;Dummy: %s&gt;' % self.path
</t>
<t tx="ekr.20040104185913.4261">class TestCase( unittest.TestCase ):
    """ Test PathIndex objects """
	@others
</t>
<t tx="ekr.20040104185913.4262">def setUp(self):
    self._index = PathIndex( 'path' )
    self._values = {
      1 : Dummy("/aa/aa/aa/1.html"),
      2 : Dummy("/aa/aa/bb/2.html"),
      3 : Dummy("/aa/aa/cc/3.html"),
      4 : Dummy("/aa/bb/aa/4.html"),
      5 : Dummy("/aa/bb/bb/5.html"),
      6 : Dummy("/aa/bb/cc/6.html"),
      7 : Dummy("/aa/cc/aa/7.html"),
      8 : Dummy("/aa/cc/bb/8.html"),
      9 : Dummy("/aa/cc/cc/9.html"),
      10 : Dummy("/bb/aa/aa/10.html"),
      11 : Dummy("/bb/aa/bb/11.html"),
      12 : Dummy("/bb/aa/cc/12.html"),
      13 : Dummy("/bb/bb/aa/13.html"),
      14 : Dummy("/bb/bb/bb/14.html"),
      15 : Dummy("/bb/bb/cc/15.html"),
      16 : Dummy("/bb/cc/aa/16.html"),
      17 : Dummy("/bb/cc/bb/17.html"),
      18 : Dummy("/bb/cc/cc/18.html")
    }
</t>
<t tx="ekr.20040104185913.4263">def _populateIndex(self):
    for k, v in self._values.items():
        self._index.index_object( k, v )
</t>
<t tx="ekr.20040104185913.4264">def testEmpty(self):

    assert len( self._index ) == 0
    assert self._index.getEntryForObject( 1234 ) is None
    self._index.unindex_object( 1234 ) # nothrow
    assert self._index._apply_index( {"suxpath":"xxx"} ) is None
</t>
<t tx="ekr.20040104185913.4265">def testUnIndex(self):

    self._populateIndex()

    for k in self._values.keys():
        self._index.unindex_object(k)

    assert len(self._index._index)==0
    assert len(self._index._unindex)==0
</t>
<t tx="ekr.20040104185913.4266">def testUnIndexError(self):
    self._populateIndex()
    
    # this should not raise an error
    self._index.unindex_object(-1)

    # nor should this
    self._index._unindex[1] = "/broken/thing"
    self._index.unindex_object(1)
</t>
<t tx="ekr.20040104185913.4267">def testRoot(self):

    self._populateIndex()

    tests = [
        ("/",0, range(1,19)),
    ]

    for comp,level,results in tests:
        for path in [comp,"/"+comp,"/"+comp+"/"]:
            res = self._index._apply_index(
                                {"path":{'query':path,"level":level}})
            lst = list(res[0].keys())
            self.assertEqual(lst,results)

    for comp,level,results in tests:
        for path in [comp,"/"+comp,"/"+comp+"/"]:
            res = self._index._apply_index(
                                {"path":{'query':( (path,level),)}})
            lst = list(res[0].keys())
            self.assertEqual(lst,results)
</t>
<t tx="ekr.20040104185913.4268">def testSimpleTests(self):

    self._populateIndex()

    tests = [
        ("aa", 0, [1,2,3,4,5,6,7,8,9]),
        ("aa", 1, [1,2,3,10,11,12] ),
        ("bb", 0, [10,11,12,13,14,15,16,17,18]),
        ("bb", 1, [4,5,6,13,14,15] ),
        ("bb/cc", 0, [16,17,18] ),
        ("bb/cc", 1, [6,15] ),
        ("bb/aa", 0, [10,11,12] ),
        ("bb/aa", 1, [4,13] ),
        ("aa/cc", -1, [3,7,8,9,12] ),
        ("bb/bb", -1, [5,13,14,15] ),
        ("18.html", 3, [18] ),
        ("18.html", -1, [18] ),
        ("cc/18.html", -1, [18] ),
        ("cc/18.html", 2, [18] ),

    ]

    for comp,level,results in tests:
        for path in [comp,"/"+comp,"/"+comp+"/"]:
            res = self._index._apply_index(
                                {"path":{'query':path,"level":level}})
            lst = list(res[0].keys())
            self.assertEqual(lst,results)

    for comp,level,results in tests:
        for path in [comp,"/"+comp,"/"+comp+"/"]:
            res = self._index._apply_index(
                                {"path":{'query':( (path,level),)}})
            lst = list(res[0].keys())
            self.assertEqual(lst,results)
</t>
<t tx="ekr.20040104185913.4269">def testComplexOrTests(self):

    self._populateIndex()

    tests = [
        (['aa','bb'],1,[1,2,3,4,5,6,10,11,12,13,14,15]),
        (['aa','bb','xx'],1,[1,2,3,4,5,6,10,11,12,13,14,15]),
        ([('cc',1),('cc',2)],0,[3,6,7,8,9,12,15,16,17,18]),
    ]

    for lst ,level,results in tests:

        res = self._index._apply_index(
                        {"path":{'query':lst,"level":level,"operator":"or"}})
        lst = list(res[0].keys())
        self.assertEqual(lst,results)
</t>
<t tx="ekr.20040104185913.4270">def testComplexANDTests(self):

    self._populateIndex()

    tests = [
        (['aa','bb'],1,[]),
        ([('aa',0),('bb',1)],0,[4,5,6]),
        ([('aa',0),('cc',2)],0,[3,6,9]),
    ]

    for lst ,level,results in tests:

        res = self._index._apply_index(
                        {"path":{'query':lst,"level":level,"operator":"and"}})
        lst = list(res[0].keys())
        self.assertEqual(lst,results)
</t>
<t tx="ekr.20040104185913.4271">def test_suite():
    return unittest.makeSuite( TestCase )
</t>
<t tx="ekr.20040104185913.4272">def main():
    unittest.TextTestRunner().run(test_suite())
</t>
<t tx="ekr.20040104190843">##############################################################################
#
# Copyright (c) 2001, 2002 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE
#
##############################################################################</t>
<t tx="ekr.20040104190843.1"></t>
<t tx="ekr.20040104190843.2"></t>
<t tx="ekr.20040104192700">pat = """&lt;&lt; copyright &gt;&gt;"""

print "finding copyright..." ; print

from leoGlobals import *
c = top() ; v = c.currentVnode()
count = 0
while v:
	s = v.bodyString()
	if s.find(pat) != -1:
		count += 1
		print v.headString()
		s = s.replace(pat,"&lt;&lt; copyright &gt;&gt;")
		v.setBodyStringOrPane(s)
	v = v.threadNext()

print ; print "replaced %d instances" % count</t>
<t tx="ekr.20040104194303">@language c

/*****************************************************************************

  Copyright (c) 1996-2002 Zope Corporation and Contributors.
  All Rights Reserved.

  This software is subject to the provisions of the Zope Public License,
  Version 2.0 (ZPL).  A copy of the ZPL should accompany this distribution.
  THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
  WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
  FOR A PARTICULAR PURPOSE

 ****************************************************************************/</t>
<t tx="ekr.20040104194739">@language c

/*
 * Copyright (c) 1996-1998, Zope Corporation, Fredericksburg, VA, USA.  
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *   o Redistributions of source code must retain the above copyright
 *     notice, this list of conditions, and the disclaimer that follows.
 * 
 *   o Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions, and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 * 
 *   o Neither the name of Zope Corporation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 * 
 * 
 * THIS SOFTWARE IS PROVIDED BY DIGITAL CREATIONS AND CONTRIBUTORS *AS
 * IS* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DIGITAL
 * CREATIONS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 * 
 # 
 # If you have questions regarding this software, contact:
 #
 #   Zope Corporation
 #   info@zope.com
 #
 #   (540) 371-6909
 */</t>
<t tx="ekr.20040104194922"></t>
<t tx="ekr.20040104195608">static
PyObject *
#ifdef HAVE_STDARG_PROTOTYPES
/* VARARGS 2 */
cPickle_ErrFormat(PyObject *ErrType, char *stringformat, char *format, ...) {
#else
/* VARARGS */
cPickle_ErrFormat(va_alist) va_dcl {
#endif
  va_list va;
  PyObject *args=0, *retval=0;
#ifdef HAVE_STDARG_PROTOTYPES
  va_start(va, format);
#else
  PyObject *ErrType;
  char *stringformat, *format;
  va_start(va);
  ErrType = va_arg(va, PyObject *);
  stringformat   = va_arg(va, char *);
  format   = va_arg(va, char *);
#endif
  
  if (format) args = Py_VaBuildValue(format, va);
  va_end(va);
  if (format &amp;&amp; ! args) return NULL;
  if (stringformat &amp;&amp; !(retval=PyString_FromString(stringformat))) return NULL;

  if (retval) {
      if (args) {
          PyObject *v;
          v=PyString_Format(retval, args);
          Py_DECREF(retval);
          Py_DECREF(args);
          if (! v) return NULL;
          retval=v;
        }
    }
  else
    if (args) retval=args;
    else {
        PyErr_SetObject(ErrType,Py_None);
        return NULL;
      }
  PyErr_SetObject(ErrType,retval);
  Py_DECREF(retval);
  return NULL;
}

static int 
write_file(Picklerobject *self, char *s, int  n) {
    if (s == NULL) {
        return 0;
    }

    if ((int)fwrite(s, sizeof(char), n, self-&gt;fp) != n) {
        PyErr_SetFromErrno(PyExc_IOError);
        return -1;
    }

    return n;
}

static int 
write_cStringIO(Picklerobject *self, char *s, int  n) {
    if (s == NULL) {
        return 0;
    }

    if (PycStringIO-&gt;cwrite((PyObject *)self-&gt;file, s, n) != n) {
        return -1;
    }

    return n;
}

static int 
write_none(Picklerobject *self, char *s, int  n) {
    if (s == NULL) return 0;
    return n;
}

static int 
write_other(Picklerobject *self, char *s, int  n) {
    PyObject *py_str = 0, *junk = 0;

    if (s == NULL) {
        UNLESS (self-&gt;buf_size) return 0;
        UNLESS (py_str = 
            PyString_FromStringAndSize(self-&gt;write_buf, self-&gt;buf_size))
            return -1;
    }
    else {
        if (self-&gt;buf_size &amp;&amp; (n + self-&gt;buf_size) &gt; WRITE_BUF_SIZE) {
            if (write_other(self, NULL, 0) &lt; 0)
                return -1;
        }

        if (n &gt; WRITE_BUF_SIZE) {    
            UNLESS (py_str = 
                PyString_FromStringAndSize(s, n))
                return -1;
        }
        else {
            memcpy(self-&gt;write_buf + self-&gt;buf_size, s, n);
            self-&gt;buf_size += n;
            return n;
        }
    }

    if (self-&gt;write) {
        /* object with write method */
        ARG_TUP(self, py_str);
        if (self-&gt;arg) {
            junk = PyObject_CallObject(self-&gt;write, self-&gt;arg);
            FREE_ARG_TUP(self);
        }
        if (junk) Py_DECREF(junk);
        else return -1;
      }
    else 
      PDATA_PUSH(self-&gt;file, py_str, -1);
    
    self-&gt;buf_size = 0; 
    return n;
}


static int 
read_file(Unpicklerobject *self, char **s, int  n) {

    if (self-&gt;buf_size == 0) {
        int size;

        size = ((n &lt; 32) ? 32 : n); 
        UNLESS (self-&gt;buf = (char *)malloc(size * sizeof(char))) {
            PyErr_NoMemory();
            return -1;
        }

        self-&gt;buf_size = size;
    }
    else if (n &gt; self-&gt;buf_size) {
        UNLESS (self-&gt;buf = (char *)realloc(self-&gt;buf, n * sizeof(char))) {
            PyErr_NoMemory();
            return -1;
        }
 
        self-&gt;buf_size = n;
    }
            
    if ((int)fread(self-&gt;buf, sizeof(char), n, self-&gt;fp) != n) {  
        if (feof(self-&gt;fp)) {
            PyErr_SetNone(PyExc_EOFError);
            return -1;
        }

        PyErr_SetFromErrno(PyExc_IOError);
        return -1;
    }

    *s = self-&gt;buf;

    return n;
}


static int 
readline_file(Unpicklerobject *self, char **s) {
    int i;

    if (self-&gt;buf_size == 0) {
        UNLESS (self-&gt;buf = (char *)malloc(40 * sizeof(char))) {
            PyErr_NoMemory();
            return -1;
        }
   
        self-&gt;buf_size = 40;
    }

    i = 0;
    while (1) {
        for (; i &lt; (self-&gt;buf_size - 1); i++) {
            if (feof(self-&gt;fp) || (self-&gt;buf[i] = getc(self-&gt;fp)) == '\n') {
                self-&gt;buf[i + 1] = '\0';
                *s = self-&gt;buf;
                return i + 1;
            }
        }

        UNLESS (self-&gt;buf = (char *)realloc(self-&gt;buf, 
            (self-&gt;buf_size * 2) * sizeof(char))) {
            PyErr_NoMemory();
            return -1;
        }

        self-&gt;buf_size *= 2;
    }

}    


static int 
read_cStringIO(Unpicklerobject *self, char **s, int  n) {
    char *ptr;

    if (PycStringIO-&gt;cread((PyObject *)self-&gt;file, &amp;ptr, n) != n) {
        PyErr_SetNone(PyExc_EOFError);
        return -1;
    }

    *s = ptr;

    return n;
}


static int 
readline_cStringIO(Unpicklerobject *self, char **s) {
    int n;
    char *ptr;

    if ((n = PycStringIO-&gt;creadline((PyObject *)self-&gt;file, &amp;ptr)) &lt; 0) {
        return -1;
    }

    *s = ptr;

    return n;
}


static int 
read_other(Unpicklerobject *self, char **s, int  n) {
    PyObject *bytes, *str=0;

    UNLESS (bytes = PyInt_FromLong(n)) return -1;

    ARG_TUP(self, bytes);
    if (self-&gt;arg) {
        str = PyObject_CallObject(self-&gt;read, self-&gt;arg);
        FREE_ARG_TUP(self);
    }
    if (! str) return -1;

    Py_XDECREF(self-&gt;last_string);
    self-&gt;last_string = str;

    if (! (*s = PyString_AsString(str))) return -1;
    return n;
}


static int 
readline_other(Unpicklerobject *self, char **s) {
    PyObject *str;
    int str_size;

    UNLESS (str = PyObject_CallObject(self-&gt;readline, empty_tuple)) {
        return -1;
    }

    if ((str_size = PyString_Size(str)) &lt; 0)
      return -1;

    Py_XDECREF(self-&gt;last_string);
    self-&gt;last_string = str;

    if (! (*s = PyString_AsString(str)))
      return -1;

    return str_size;
}


static char *
pystrndup(char *s, int l) {
  char *r;
  UNLESS (r=malloc((l+1)*sizeof(char))) return (char*)PyErr_NoMemory();
  memcpy(r,s,l);
  r[l]=0;
  return r;
}


static int
get(Picklerobject *self, PyObject *id) {
    PyObject *value, *mv;
    long c_value;
    char s[30];
    int len;

    UNLESS (mv = PyDict_GetItem(self-&gt;memo, id)) {
        PyErr_SetObject(PyExc_KeyError, id);
        return -1;
      }

    UNLESS (value = PyTuple_GetItem(mv, 0))
        return -1;
        
    UNLESS (PyInt_Check(value)) {
      PyErr_SetString(PicklingError, "no int where int expected in memo");
      return -1;
    }
    c_value = PyInt_AS_LONG((PyIntObject*)value);

    if (!self-&gt;bin) {
        s[0] = GET;
        sprintf(s + 1, "%ld\n", c_value);
        len = strlen(s);
    }
    else if (Pdata_Check(self-&gt;file)) {
        if (write_other(self, NULL, 0) &lt; 0) return -1;
        PDATA_APPEND(self-&gt;file, mv, -1);
        return 0;
      }
    else {
        if (c_value &lt; 256) {
            s[0] = BINGET;
            s[1] = (int)(c_value &amp; 0xff);
            len = 2;
        }
        else {
            s[0] = LONG_BINGET;
            s[1] = (int)(c_value &amp; 0xff);
            s[2] = (int)((c_value &gt;&gt; 8)  &amp; 0xff);
            s[3] = (int)((c_value &gt;&gt; 16) &amp; 0xff);
            s[4] = (int)((c_value &gt;&gt; 24) &amp; 0xff);
            len = 5;
        }
    }

    if ((*self-&gt;write_func)(self, s, len) &lt; 0)
        return -1;

    return 0;
}
    

static int
put(Picklerobject *self, PyObject *ob) {
    if (ob-&gt;ob_refcnt &lt; 2 || self-&gt;fast)
        return 0;

    return put2(self, ob);
}

  
static int
put2(Picklerobject *self, PyObject *ob) {
    char c_str[30];
    int p, len, res = -1;
    PyObject *py_ob_id = 0, *memo_len = 0, *t = 0;

    if (self-&gt;fast) return 0;

    if ((p = PyDict_Size(self-&gt;memo)) &lt; 0)
        goto finally;

    p++;  /* Make sure memo keys are positive! */

    UNLESS (py_ob_id = PyInt_FromLong((long)ob))
        goto finally;

    UNLESS (memo_len = PyInt_FromLong(p))
        goto finally;

    UNLESS (t = PyTuple_New(2))
        goto finally;

    PyTuple_SET_ITEM(t, 0, memo_len);
    Py_INCREF(memo_len);
    PyTuple_SET_ITEM(t, 1, ob);
    Py_INCREF(ob);

    if (PyDict_SetItem(self-&gt;memo, py_ob_id, t) &lt; 0)
        goto finally;

    if (!self-&gt;bin) {
        c_str[0] = PUT;
        sprintf(c_str + 1, "%d\n", p);
        len = strlen(c_str);
    }
    else if (Pdata_Check(self-&gt;file)) {
        if (write_other(self, NULL, 0) &lt; 0) return -1;
        PDATA_APPEND(self-&gt;file, memo_len, -1);
        res=0;          /* Job well done ;) */
        goto finally;
    }
    else {
        if (p &gt;= 256) {
            c_str[0] = LONG_BINPUT;
            c_str[1] = (int)(p &amp; 0xff);
            c_str[2] = (int)((p &gt;&gt; 8)  &amp; 0xff);
            c_str[3] = (int)((p &gt;&gt; 16) &amp; 0xff);
            c_str[4] = (int)((p &gt;&gt; 24) &amp; 0xff);
            len = 5;
        }
        else {
            c_str[0] = BINPUT;
            c_str[1] = p;
            len = 2; 
        }
    }

    if ((*self-&gt;write_func)(self, c_str, len) &lt; 0)
        goto finally;

    res = 0;

finally:
    Py_XDECREF(py_ob_id);
    Py_XDECREF(memo_len);
    Py_XDECREF(t);

    return res;
}

#define PyImport_Import cPickle_Import

static PyObject *
PyImport_Import(PyObject *module_name) {
  static PyObject *silly_list=0, *__builtins___str=0, *__import___str;
  static PyObject *standard_builtins=0;
  PyObject *globals=0, *__import__=0, *__builtins__=0, *r=0;

  UNLESS (silly_list) {
      UNLESS (__import___str=PyString_FromString("__import__"))
        return NULL;
      UNLESS (__builtins___str=PyString_FromString("__builtins__"))
        return NULL;
      UNLESS (silly_list=Py_BuildValue("[s]","__doc__"))
        return NULL;
    }

  if ((globals=PyEval_GetGlobals())) {
      Py_INCREF(globals);
      UNLESS (__builtins__=PyObject_GetItem(globals,__builtins___str))
        goto err;
    }
  else {
      PyErr_Clear();

      UNLESS (standard_builtins ||
             (standard_builtins=PyImport_ImportModule("__builtin__")))
        return NULL;
      
      __builtins__=standard_builtins;
      Py_INCREF(__builtins__);
      UNLESS (globals = Py_BuildValue("{sO}", "__builtins__", __builtins__))
        goto err;
    }

  if (PyDict_Check(__builtins__)) {
    UNLESS (__import__=PyObject_GetItem(__builtins__,__import___str)) goto err;
  }
  else {
    UNLESS (__import__=PyObject_GetAttr(__builtins__,__import___str)) goto err;
  }

  UNLESS (r=PyObject_CallFunction(__import__,"OOOO",
                                 module_name, globals, globals, silly_list))
    goto err;

  Py_DECREF(globals);
  Py_DECREF(__builtins__);
  Py_DECREF(__import__);
  
  return r;
err:
  Py_XDECREF(globals);
  Py_XDECREF(__builtins__);
  Py_XDECREF(__import__);
  return NULL;
}

static PyObject *
whichmodule(PyObject *global, PyObject *global_name) {
    int i, j;
    PyObject *module = 0, *modules_dict = 0,
        *global_name_attr = 0, *name = 0;

    module = PyObject_GetAttrString(global, "__module__");
    if (module) return module;
    PyErr_Clear();

    UNLESS (modules_dict = PySys_GetObject("modules"))
        return NULL;

    i = 0;
    while ((j = PyDict_Next(modules_dict, &amp;i, &amp;name, &amp;module))) {

        if (PyObject_Compare(name, __main___str)==0) continue;
      
        UNLESS (global_name_attr = PyObject_GetAttr(module, global_name)) {
            PyErr_Clear();
            continue;
        }

        if (global_name_attr != global) {
            Py_DECREF(global_name_attr);
            continue;
        }

        Py_DECREF(global_name_attr);

        break;
    }

    /* The following implements the rule in pickle.py added in 1.5
       that used __main__ if no module is found.  I don't actually
       like this rule. jlf
     */
    if (!j) {
        j=1;
        name=__main___str;
    }

    Py_INCREF(name);
    return name;
}


static int
save_none(Picklerobject *self, PyObject *args) {
    static char none = NONE;
    if ((*self-&gt;write_func)(self, &amp;none, 1) &lt; 0)  
        return -1;

    return 0;
}

      
static int
save_int(Picklerobject *self, PyObject *args) {
    char c_str[32];
    long l = PyInt_AS_LONG((PyIntObject *)args);
    int len = 0;

    if (!self-&gt;bin
#if SIZEOF_LONG &gt; 4
        || l &gt;  0x7fffffffL
        || l &lt; -0x80000000L
#endif
       ) {
        /* Text-mode pickle, or long too big to fit in the 4-byte
         * signed BININT format:  store as a string.
         */
        c_str[0] = INT;
        sprintf(c_str + 1, "%ld\n", l);
        if ((*self-&gt;write_func)(self, c_str, strlen(c_str)) &lt; 0)
            return -1;
    }
    else {
        /* Binary pickle and l fits in a signed 4-byte int. */
        c_str[1] = (int)( l        &amp; 0xff);
        c_str[2] = (int)((l &gt;&gt; 8)  &amp; 0xff);
        c_str[3] = (int)((l &gt;&gt; 16) &amp; 0xff);
        c_str[4] = (int)((l &gt;&gt; 24) &amp; 0xff);

        if ((c_str[4] == 0) &amp;&amp; (c_str[3] == 0)) {
            if (c_str[2] == 0) {
                c_str[0] = BININT1;
                len = 2;
            }
            else {
                c_str[0] = BININT2;
                len = 3;
            }
        }
        else {
            c_str[0] = BININT;
            len = 5;
        }

        if ((*self-&gt;write_func)(self, c_str, len) &lt; 0)
            return -1;
    }

    return 0;
}


static int
save_long(Picklerobject *self, PyObject *args) {
    int size, res = -1;
    PyObject *repr = 0;

    static char l = LONG;

    UNLESS (repr = PyObject_Repr(args))
        goto finally;

    if ((size = PyString_Size(repr)) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, &amp;l, 1) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, 
        PyString_AS_STRING((PyStringObject *)repr), size) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
        goto finally;

    res = 0;

finally:
    Py_XDECREF(repr);

    return res;
}


static int
save_float(Picklerobject *self, PyObject *args) {
    double x = PyFloat_AS_DOUBLE((PyFloatObject *)args);

    if (self-&gt;bin) {
        int s, e;
        double f;
        long fhi, flo;
        char str[9], *p = str;

        *p = BINFLOAT;
        p++;

        if (x &lt; 0) {
            s = 1;
            x = -x;
        }
        else
            s = 0;

        f = frexp(x, &amp;e);

        /* Normalize f to be in the range [1.0, 2.0) */
        if (0.5 &lt;= f &amp;&amp; f &lt; 1.0) {
            f *= 2.0;
            e--;
        }
        else if (f == 0.0) {
            e = 0;
        }
        else {
            PyErr_SetString(PyExc_SystemError,
                            "frexp() result out of range");
            return -1;
        }

        if (e &gt;= 1024) {
            /* XXX 1024 itself is reserved for Inf/NaN */
            PyErr_SetString(PyExc_OverflowError,
                            "float too large to pack with d format");
            return -1;
        }
        else if (e &lt; -1022) {
            /* Gradual underflow */
            f = ldexp(f, 1022 + e);
            e = 0;
        }
        else if (!(e == 0 &amp;&amp; f == 0.0)) {
            e += 1023;
            f -= 1.0; /* Get rid of leading 1 */
        }

        /* fhi receives the high 28 bits; flo the low 24 bits (== 52 bits) */
        f *= 268435456.0; /* 2**28 */
        fhi = (long) floor(f); /* Truncate */
        f -= (double)fhi;
        f *= 16777216.0; /* 2**24 */
        flo = (long) floor(f + 0.5); /* Round */

        /* First byte */
        *p = (s&lt;&lt;7) | (e&gt;&gt;4);
        p++;

        /* Second byte */
        *p = (char) (((e&amp;0xF)&lt;&lt;4) | (fhi&gt;&gt;24));
        p++;

        /* Third byte */
        *p = (fhi&gt;&gt;16) &amp; 0xFF;
        p++;

        /* Fourth byte */
        *p = (fhi&gt;&gt;8) &amp; 0xFF;
        p++;

        /* Fifth byte */
        *p = fhi &amp; 0xFF;
        p++;

        /* Sixth byte */
        *p = (flo&gt;&gt;16) &amp; 0xFF;
        p++;

        /* Seventh byte */
        *p = (flo&gt;&gt;8) &amp; 0xFF;
        p++;

        /* Eighth byte */
        *p = flo &amp; 0xFF;

        if ((*self-&gt;write_func)(self, str, 9) &lt; 0)
            return -1;
    }
    else {
        char c_str[250];
        c_str[0] = FLOAT;
        sprintf(c_str + 1, "%.17g\n", x);

        if ((*self-&gt;write_func)(self, c_str, strlen(c_str)) &lt; 0)
            return -1;
    }

    return 0;
}


static int
save_string(Picklerobject *self, PyObject *args, int doput) {
    int size, len;
    PyObject *repr=0;

    if ((size = PyString_Size(args)) &lt; 0)
      return -1;

    if (!self-&gt;bin) {
        char *repr_str;

        static char string = STRING;

        UNLESS (repr = PyObject_Repr(args))
            return -1;

        if ((len = PyString_Size(repr)) &lt; 0)
          goto err;
        repr_str = PyString_AS_STRING((PyStringObject *)repr);

        if ((*self-&gt;write_func)(self, &amp;string, 1) &lt; 0)
            goto err;

        if ((*self-&gt;write_func)(self, repr_str, len) &lt; 0)
            goto err;

        if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
            goto err;

        Py_XDECREF(repr);
    }
    else {
        int i;
        char c_str[5];

        if ((size = PyString_Size(args)) &lt; 0)
          return -1;

        if (size &lt; 256) {
            c_str[0] = SHORT_BINSTRING;
            c_str[1] = size;
            len = 2;
        }
        else {
            c_str[0] = BINSTRING;
            for (i = 1; i &lt; 5; i++)
                c_str[i] = (int)(size &gt;&gt; ((i - 1) * 8));
            len = 5;
        }

        if ((*self-&gt;write_func)(self, c_str, len) &lt; 0)
            return -1;

        if (size &gt; 128 &amp;&amp; Pdata_Check(self-&gt;file)) {
            if (write_other(self, NULL, 0) &lt; 0) return -1;
            PDATA_APPEND(self-&gt;file, args, -1);
          }
        else {
          if ((*self-&gt;write_func)(self, 
              PyString_AS_STRING((PyStringObject *)args), size) &lt; 0)
            return -1;
        }
    }

    if (doput)
      if (put(self, args) &lt; 0)
        return -1;

    return 0;

err:
    Py_XDECREF(repr);
    return -1;
}


static int
save_tuple(Picklerobject *self, PyObject *args) {
    PyObject *element = 0, *py_tuple_id = 0;
    int len, i, has_key, res = -1;

    static char tuple = TUPLE;

    if ((*self-&gt;write_func)(self, &amp;MARKv, 1) &lt; 0)
        goto finally;

    if ((len = PyTuple_Size(args)) &lt; 0)  
        goto finally;

    for (i = 0; i &lt; len; i++) {
        UNLESS (element = PyTuple_GET_ITEM((PyTupleObject *)args, i))  
            goto finally;
    
        if (save(self, element, 0) &lt; 0)
            goto finally;
    }

    UNLESS (py_tuple_id = PyInt_FromLong((long)args))
        goto finally;

    if (len) {
        if ((has_key = cPickle_PyMapping_HasKey(self-&gt;memo, py_tuple_id)) &lt; 0)
            goto finally;

        if (has_key) {
            if (self-&gt;bin) {
                static char pop_mark = POP_MARK;
  
                if ((*self-&gt;write_func)(self, &amp;pop_mark, 1) &lt; 0)
                    goto finally;
            }
            else {
                static char pop = POP;
       
                for (i = 0; i &lt;= len; i++) {
                    if ((*self-&gt;write_func)(self, &amp;pop, 1) &lt; 0)
                        goto finally;
                } 
            }
        
            if (get(self, py_tuple_id) &lt; 0)
                goto finally;

            res = 0;
            goto finally;
        }
    }

    if ((*self-&gt;write_func)(self, &amp;tuple, 1) &lt; 0) {
        goto finally;
    }

    if (put(self, args) &lt; 0)
        goto finally;
 
    res = 0;

finally:
    Py_XDECREF(py_tuple_id);

    return res;
}

static int
save_empty_tuple(Picklerobject *self, PyObject *args) {
    static char tuple = EMPTY_TUPLE;

    return (*self-&gt;write_func)(self, &amp;tuple, 1);
}


static int
save_list(Picklerobject *self, PyObject *args) {
    PyObject *element = 0;
    int s_len, len, i, using_appends, res = -1;
    char s[3];

    static char append = APPEND, appends = APPENDS;

    if (self-&gt;bin) {
        s[0] = EMPTY_LIST;
        s_len = 1;
    } 
    else {
        s[0] = MARK;
        s[1] = LIST;
        s_len = 2;
    }

    if ((len = PyList_Size(args)) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, s, s_len) &lt; 0)
        goto finally;

    if (len == 0) {
        if (put(self, args) &lt; 0)
            goto finally;
    }
    else {
        if (put2(self, args) &lt; 0)
            goto finally;
    }

    if ((using_appends = (self-&gt;bin &amp;&amp; (len &gt; 1))))
        if ((*self-&gt;write_func)(self, &amp;MARKv, 1) &lt; 0)
            goto finally;

    for (i = 0; i &lt; len; i++) {
        UNLESS (element = PyList_GET_ITEM((PyListObject *)args, i))  
            goto finally;

        if (save(self, element, 0) &lt; 0)  
            goto finally;       

        if (!using_appends) {
            if ((*self-&gt;write_func)(self, &amp;append, 1) &lt; 0)
                goto finally;
        }
    }

    if (using_appends) {
        if ((*self-&gt;write_func)(self, &amp;appends, 1) &lt; 0)
            goto finally;
    }

    res = 0;

finally:

    return res;
}


static int
save_dict(Picklerobject *self, PyObject *args) {
    PyObject *key = 0, *value = 0;
    int i, len, res = -1, using_setitems;
    char s[3];

    static char setitem = SETITEM, setitems = SETITEMS;

    if (self-&gt;bin) {
        s[0] = EMPTY_DICT;
        len = 1;
    }
    else {
        s[0] = MARK;
        s[1] = DICT;
        len = 2;
    }

    if ((*self-&gt;write_func)(self, s, len) &lt; 0)
        goto finally;

    if ((len = PyDict_Size(args)) &lt; 0)
        goto finally;

    if (len == 0) {
        if (put(self, args) &lt; 0)
            goto finally;
    }
    else {
        if (put2(self, args) &lt; 0)
            goto finally;
    }

    if ((using_setitems = (self-&gt;bin &amp;&amp; (PyDict_Size(args) &gt; 1))))
        if ((*self-&gt;write_func)(self, &amp;MARKv, 1) &lt; 0)
            goto finally;

    i = 0;
    while (PyDict_Next(args, &amp;i, &amp;key, &amp;value)) {
        if (save(self, key, 0) &lt; 0)
            goto finally;

        if (save(self, value, 0) &lt; 0)
            goto finally;

        if (!using_setitems) {
            if ((*self-&gt;write_func)(self, &amp;setitem, 1) &lt; 0)
                goto finally;
        }
    }

    if (using_setitems) {
        if ((*self-&gt;write_func)(self, &amp;setitems, 1) &lt; 0)
            goto finally;
    }

    res = 0;

finally:

    return res;
}


static int  
save_inst(Picklerobject *self, PyObject *args) {
    PyObject *class = 0, *module = 0, *name = 0, *state = 0, 
             *getinitargs_func = 0, *getstate_func = 0, *class_args = 0;
    char *module_str, *name_str;
    int module_size, name_size, res = -1;

    static char inst = INST, obj = OBJ, build = BUILD;

    if ((*self-&gt;write_func)(self, &amp;MARKv, 1) &lt; 0)
        goto finally;

    UNLESS (class = PyObject_GetAttr(args, __class___str))
        goto finally;

    if (self-&gt;bin) {
        if (save(self, class, 0) &lt; 0)
            goto finally;
    }

    if ((getinitargs_func = PyObject_GetAttr(args, __getinitargs___str))) {
        PyObject *element = 0;
        int i, len;

        UNLESS (class_args = 
            PyObject_CallObject(getinitargs_func, empty_tuple))
            goto finally;

        if ((len = PyObject_Length(class_args)) &lt; 0)  
            goto finally;

        for (i = 0; i &lt; len; i++) {
            UNLESS (element = PySequence_GetItem(class_args, i)) 
                goto finally;

            if (save(self, element, 0) &lt; 0) {
                Py_DECREF(element);
                goto finally;
            }

            Py_DECREF(element);
        }
    }
    else {
        PyErr_Clear();
    }

    if (!self-&gt;bin) {
        UNLESS (name = ((PyClassObject *)class)-&gt;cl_name) {
            PyErr_SetString(PicklingError, "class has no name");
            goto finally;
        }

        UNLESS (module = whichmodule(class, name))
            goto finally;

        
        if ((module_size = PyString_Size(module)) &lt; 0 ||
           (name_size = PyString_Size(name)) &lt; 0)
          goto finally;

        module_str = PyString_AS_STRING((PyStringObject *)module);
        name_str   = PyString_AS_STRING((PyStringObject *)name);

        if ((*self-&gt;write_func)(self, &amp;inst, 1) &lt; 0)
            goto finally;

        if ((*self-&gt;write_func)(self, module_str, module_size) &lt; 0)
            goto finally;

        if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
            goto finally;

        if ((*self-&gt;write_func)(self, name_str, name_size) &lt; 0)
            goto finally;

        if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
            goto finally;
    }
    else if ((*self-&gt;write_func)(self, &amp;obj, 1) &lt; 0) {
        goto finally;
    }

    if ((getstate_func = PyObject_GetAttr(args, __getstate___str))) {
        UNLESS (state = PyObject_CallObject(getstate_func, empty_tuple))
            goto finally;
    }
    else {
        PyErr_Clear();

        UNLESS (state = PyObject_GetAttr(args, __dict___str)) {
            PyErr_Clear();
            res = 0;
            goto finally;
        }
    }

    if (!PyDict_Check(state)) {
        if (put2(self, args) &lt; 0)
            goto finally;
    }
    else {
        if (put(self, args) &lt; 0)
            goto finally;
    }
  
    if (save(self, state, 0) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, &amp;build, 1) &lt; 0)
        goto finally;

    res = 0;

finally:
    Py_XDECREF(module);
    Py_XDECREF(class);
    Py_XDECREF(state);
    Py_XDECREF(getinitargs_func);
    Py_XDECREF(getstate_func);
    Py_XDECREF(class_args);

    return res;
}


static int
save_global(Picklerobject *self, PyObject *args, PyObject *name) {
    PyObject *global_name = 0, *module = 0;
    char *name_str, *module_str; 
    int module_size, name_size, res = -1;

    static char global = GLOBAL;

    if (name) {
        global_name = name;
        Py_INCREF(global_name);
    }
    else {
        UNLESS (global_name = PyObject_GetAttr(args, __name___str))
            goto finally;
    }

    UNLESS (module = whichmodule(args, global_name))
        goto finally;

    if ((module_size = PyString_Size(module)) &lt; 0 ||
        (name_size = PyString_Size(global_name)) &lt; 0)
      goto finally;

    module_str = PyString_AS_STRING((PyStringObject *)module);
    name_str   = PyString_AS_STRING((PyStringObject *)global_name);

    if ((*self-&gt;write_func)(self, &amp;global, 1) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, module_str, module_size) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, name_str, name_size) &lt; 0)
        goto finally;

    if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
        goto finally;

    if (put(self, args) &lt; 0)
        goto finally;

    res = 0;

finally:
    Py_XDECREF(module);
    Py_XDECREF(global_name);

    return res;
}

static int
save_pers(Picklerobject *self, PyObject *args, PyObject *f) {
    PyObject *pid = 0;
    int size, res = -1;

    static char persid = PERSID, binpersid = BINPERSID;

    Py_INCREF(args);
    ARG_TUP(self, args);
    if (self-&gt;arg) {
        pid = PyObject_CallObject(f, self-&gt;arg);
        FREE_ARG_TUP(self);
    }
    if (! pid) return -1;

    if (pid != Py_None) {
        if (!self-&gt;bin) {
            if (!PyString_Check(pid)) {
                PyErr_SetString(PicklingError, 
                    "persistent id must be string");
                goto finally;
            }

            if ((*self-&gt;write_func)(self, &amp;persid, 1) &lt; 0)
                goto finally;

            if ((size = PyString_Size(pid)) &lt; 0)
                goto finally;

            if ((*self-&gt;write_func)(self, 
                PyString_AS_STRING((PyStringObject *)pid), size) &lt; 0)
                goto finally;

            if ((*self-&gt;write_func)(self, "\n", 1) &lt; 0)
                goto finally;
     
            res = 1;
            goto finally;
        }
        else if (save(self, pid, 1) &gt;= 0) {
            if ((*self-&gt;write_func)(self, &amp;binpersid, 1) &lt; 0)
                res = -1;
            else
                res = 1;
        }

        goto finally;              
    }

    res = 0;

finally:
    Py_XDECREF(pid);

    return res;
}


static int 
save_reduce(Picklerobject *self, PyObject *callable,
            PyObject *tup, PyObject *state, PyObject *ob) {
    static char reduce = REDUCE, build = BUILD;

    if (save(self, callable, 0) &lt; 0)
        return -1;

    if (save(self, tup, 0) &lt; 0)
        return -1;

    if ((*self-&gt;write_func)(self, &amp;reduce, 1) &lt; 0)
        return -1;

    if (ob != NULL) {
        if (state &amp;&amp; !PyDict_Check(state)) {
            if (put2(self, ob) &lt; 0)
                return -1;
        }
        else {
            if (put(self, ob) &lt; 0)
                return -1;
        }
    }
    
    if (state) {
        if (save(self, state, 0) &lt; 0)
            return -1;

        if ((*self-&gt;write_func)(self, &amp;build, 1) &lt; 0)
            return -1;
    }

    return 0;
}

static int
save(Picklerobject *self, PyObject *args, int  pers_save) {
    PyTypeObject *type;
    PyObject *py_ob_id = 0, *__reduce__ = 0, *t = 0, *arg_tup = 0,
             *callable = 0, *state = 0;
    int res = -1, tmp, size;

    if (!pers_save &amp;&amp; self-&gt;pers_func) {
        if ((tmp = save_pers(self, args, self-&gt;pers_func)) != 0) {
            res = tmp;
            goto finally;
        }
    }

    if (args == Py_None) {
        res = save_none(self, args);
        goto finally;
    }

    type = args-&gt;ob_type;

    switch (type-&gt;tp_name[0]) {
        case 'i':
            if (type == &amp;PyInt_Type) {
                res = save_int(self, args);
                goto finally;
            }
            break;

        case 'l':
            if (type == &amp;PyLong_Type) {
                res = save_long(self, args);
                goto finally;
            }
            break;

        case 'f':
            if (type == &amp;PyFloat_Type) {
                res = save_float(self, args);
                goto finally;
            }
            break;

        case 't':
            if (type == &amp;PyTuple_Type &amp;&amp; PyTuple_Size(args)==0) {
                if (self-&gt;bin) res = save_empty_tuple(self, args);
                else          res = save_tuple(self, args);
                goto finally;
            }
            break;

        case 's':
            if ((type == &amp;PyString_Type) &amp;&amp; (PyString_GET_SIZE(args) &lt; 2)) {
                res = save_string(self, args, 0);
                goto finally;
            }
    }

    if (args-&gt;ob_refcnt &gt; 1) {
        long ob_id;
        int  has_key;

        ob_id = (long)args;

        UNLESS (py_ob_id = PyInt_FromLong(ob_id))
            goto finally;

        if ((has_key = cPickle_PyMapping_HasKey(self-&gt;memo, py_ob_id)) &lt; 0)
            goto finally;

        if (has_key) {
            if (get(self, py_ob_id) &lt; 0)
                goto finally;

            res = 0;
            goto finally;
        }
    }

    switch (type-&gt;tp_name[0]) {
        case 's':
            if (type == &amp;PyString_Type) {
                res = save_string(self, args, 1);
                goto finally;
            }
            break;

        case 't':
            if (type == &amp;PyTuple_Type) {
                res = save_tuple(self, args);
                goto finally;
            }
            break;

        case 'l':
            if (type == &amp;PyList_Type) {
                res = save_list(self, args);
                goto finally;
            }
            break;

        case 'd':
            if (type == &amp;PyDict_Type) {
                res = save_dict(self, args);
                goto finally; 
            }
            break;

        case 'i':
            if (type == &amp;PyInstance_Type) {
                res = save_inst(self, args);
                goto finally;
            }
            break;

        case 'c':
            if (type == &amp;PyClass_Type) {
                res = save_global(self, args, NULL);
                goto finally;
            }
            break;

        case 'f':
            if (type == &amp;PyFunction_Type) {
                res = save_global(self, args, NULL);
                goto finally;
            }
            break;

        case 'b':
            if (type == &amp;PyCFunction_Type) {
                res = save_global(self, args, NULL);
                goto finally;
            }
    }

    if (!pers_save &amp;&amp; self-&gt;inst_pers_func) {
        if ((tmp = save_pers(self, args, self-&gt;inst_pers_func)) != 0) {
            res = tmp;
            goto finally;
        }
    }

    if ((__reduce__ = PyDict_GetItem(dispatch_table, (PyObject *)type))) {
        Py_INCREF(__reduce__);

        Py_INCREF(args);
        ARG_TUP(self, args);
        if (self-&gt;arg) {
            t = PyObject_CallObject(__reduce__, self-&gt;arg);
            FREE_ARG_TUP(self);
        }
        if (! t) goto finally;
    }        
    else {
        PyErr_Clear();

        if ((__reduce__ = PyObject_GetAttr(args, __reduce___str))) {
            UNLESS (t = PyObject_CallObject(__reduce__, empty_tuple))
                goto finally;
        }
        else {
            PyErr_Clear();
        }
    }

    if (t) {
        if (PyString_Check(t)) {
            res = save_global(self, args, t);
            goto finally;
        }
 
        if (!PyTuple_Check(t)) {
            cPickle_ErrFormat(PicklingError, "Value returned by %s must "
                "be a tuple", "O", __reduce__);
            goto finally;
        }

        size = PyTuple_Size(t);
        
        if ((size != 3) &amp;&amp; (size != 2)) {
            cPickle_ErrFormat(PicklingError, "tuple returned by %s must "     
                "contain only two or three elements", "O", __reduce__);
                goto finally;
        }
        
        callable = PyTuple_GET_ITEM(t, 0);

        arg_tup = PyTuple_GET_ITEM(t, 1);

        if (size &gt; 2) {
            state = PyTuple_GET_ITEM(t, 2);
        }

        UNLESS (PyTuple_Check(arg_tup) || arg_tup==Py_None) {
            cPickle_ErrFormat(PicklingError, "Second element of tuple "
                "returned by %s must be a tuple", "O", __reduce__);
            goto finally;
        }

        res = save_reduce(self, callable, arg_tup, state, args);
        goto finally;
    }

    PyErr_SetObject(UnpickleableError, args);

finally:
    Py_XDECREF(py_ob_id);
    Py_XDECREF(__reduce__);
    Py_XDECREF(t);
   
    return res;
}


static int
dump(Picklerobject *self, PyObject *args) {
    static char stop = STOP;

    if (save(self, args, 0) &lt; 0)
        return -1;

    if ((*self-&gt;write_func)(self, &amp;stop, 1) &lt; 0)
        return -1;

    if ((*self-&gt;write_func)(self, NULL, 0) &lt; 0)
        return -1;

    return 0;
}

static PyObject *
Pickle_clear_memo(Picklerobject *self, PyObject *args) {
  if (args &amp;&amp; ! PyArg_ParseTuple(args,"")) return NULL;
  if (self-&gt;memo) PyDict_Clear(self-&gt;memo);
  Py_INCREF(Py_None);
  return Py_None;
}

static PyObject *
Pickle_getvalue(Picklerobject *self, PyObject *args) {
  int l, i, rsize, ssize, clear=1, lm;
  long ik;
  PyObject *k, *r;
  char *s, *p, *have_get;
  Pdata *data;

  if (args &amp;&amp; ! PyArg_ParseTuple(args,"|i",&amp;clear)) return NULL;

  /* Check to make sure we are based on a list */
  if (! Pdata_Check(self-&gt;file)) {
      PyErr_SetString(PicklingError,
                      "Attempt to getvalue a non-list-based pickler");
      return NULL;
    }

  /* flush write buffer */
  if (write_other(self, NULL, 0) &lt; 0) return NULL;

  data=(Pdata*)self-&gt;file;
  l=data-&gt;length;

  /* set up an array to hold get/put status */
  if ((lm=PyDict_Size(self-&gt;memo)) &lt; 0) return NULL;
  lm++;
  if (! (have_get=malloc((lm)*sizeof(char)))) return PyErr_NoMemory();  
  memset(have_get,0,lm);

  /* Scan for gets. */
  for (rsize=0, i=l; --i &gt;= 0; ) {
      k=data-&gt;data[i];
      
      if (PyString_Check(k)) {
        rsize += PyString_GET_SIZE(k);
      }

      else if (PyInt_Check(k)) { /* put */
        ik=PyInt_AS_LONG((PyIntObject*)k);
        if (ik &gt;= lm || ik==0) {
          PyErr_SetString(PicklingError,
                          "Invalid get data");
          return NULL;
        }      
        if (have_get[ik]) { /* with matching get */
          if (ik &lt; 256) rsize += 2;
          else rsize+=5;
        }
      }

      else if (! (PyTuple_Check(k) &amp;&amp;
                  PyTuple_GET_SIZE(k) == 2 &amp;&amp;
                  PyInt_Check((k=PyTuple_GET_ITEM(k,0))))
               ) {
        PyErr_SetString(PicklingError,
                        "Unexpected data in internal list");
        return NULL;
      }

      else { /* put */
        ik=PyInt_AS_LONG((PyIntObject*)k);
        if (ik &gt;= lm || ik==0) {
          PyErr_SetString(PicklingError,
                          "Invalid get data");
          return NULL;
        }      
        have_get[ik]=1;
        if (ik &lt; 256) rsize += 2;
        else rsize+=5;
      }

    }

  /* Now generate the result */
  UNLESS (r=PyString_FromStringAndSize(NULL,rsize)) goto err;
  s=PyString_AS_STRING((PyStringObject*)r);

  for (i=0; i&lt;l; i++) {
      k=data-&gt;data[i];

      if (PyString_Check(k)) {
        ssize=PyString_GET_SIZE(k);
        if (ssize) {
            p=PyString_AS_STRING((PyStringObject*)k);
            while (--ssize &gt;= 0) *s++=*p++;
          }
      }

      else if (PyTuple_Check(k)) { /* get */
        ik=PyInt_AS_LONG((PyIntObject*)PyTuple_GET_ITEM(k,0));
        if (ik &lt; 256) {
          *s++ = BINGET;
          *s++ = (int)(ik &amp; 0xff);
        }
        else {
          *s++ = LONG_BINGET;
          *s++ = (int)(ik &amp; 0xff);
          *s++ = (int)((ik &gt;&gt; 8)  &amp; 0xff);
          *s++ = (int)((ik &gt;&gt; 16) &amp; 0xff);
          *s++ = (int)((ik &gt;&gt; 24) &amp; 0xff);
        }
      }

      else { /* put */
        ik=PyInt_AS_LONG((PyIntObject*)k);

        if (have_get[ik]) { /* with matching get */
          if (ik &lt; 256) {
            *s++ = BINPUT;
            *s++ = (int)(ik &amp; 0xff);
          }
          else {
            *s++ = LONG_BINPUT;
            *s++ = (int)(ik &amp; 0xff);
            *s++ = (int)((ik &gt;&gt; 8)  &amp; 0xff);
            *s++ = (int)((ik &gt;&gt; 16) &amp; 0xff);
            *s++ = (int)((ik &gt;&gt; 24) &amp; 0xff);
          }
        }
      }

    }

  if (clear) {
    PyDict_Clear(self-&gt;memo);
    Pdata_clear(data,0);
  }
    
  free(have_get);
  return r;
err:
  free(have_get);
  return NULL;
}

static PyObject *
Pickler_dump(Picklerobject *self, PyObject *args) {
    PyObject *ob;
    int get=0;

    UNLESS (PyArg_ParseTuple(args, "O|i", &amp;ob, &amp;get))
        return NULL;

    if (dump(self, ob) &lt; 0)
        return NULL;

    if (get) return Pickle_getvalue(self, NULL);

    Py_INCREF(self);
    return (PyObject*)self;
}


static struct PyMethodDef Pickler_methods[] = {
  {"dump",          (PyCFunction)Pickler_dump,  1,
   "dump(object) --"
   "Write an object in pickle format to the object's pickle stream\n"
  },
  {"clear_memo",  (PyCFunction)Pickle_clear_memo,  1,
   "clear_memo() -- Clear the picklers memo"},
  {"getvalue",  (PyCFunction)Pickle_getvalue,  1,
   "getvalue() -- Finish picking a list-based pickle"},
  {NULL,                NULL}           /* sentinel */
};


static Picklerobject *
newPicklerobject(PyObject *file, int bin) {
    Picklerobject *self;

    UNLESS (self = PyObject_NEW(Picklerobject, &amp;Picklertype))
        return NULL;

    self-&gt;fp = NULL;
    self-&gt;write = NULL;
    self-&gt;memo = NULL;
    self-&gt;arg = NULL;
    self-&gt;pers_func = NULL;
    self-&gt;inst_pers_func = NULL;
    self-&gt;write_buf = NULL;
    self-&gt;bin = bin;
    self-&gt;fast = 0;
    self-&gt;buf_size = 0;
    self-&gt;dispatch_table = NULL;

    if (file)
      Py_INCREF(file);
    else
      file=Pdata_New();

    self-&gt;file = file;

    UNLESS (self-&gt;memo = PyDict_New()) {
       Py_XDECREF((PyObject *)self);
       return NULL;
    }

    if (PyFile_Check(file)) {
        self-&gt;fp = PyFile_AsFile(file);
	if (self-&gt;fp == NULL) {
	    PyErr_SetString(PyExc_IOError, "output file closed");
	    return NULL;
	}
        self-&gt;write_func = write_file;
    }
    else if (PycStringIO_OutputCheck(file)) {
        self-&gt;write_func = write_cStringIO;
    }
    else if (file == Py_None) {
        self-&gt;write_func = write_none;
    }
    else {
        self-&gt;write_func = write_other;

        if (! Pdata_Check(file)) {
          UNLESS (self-&gt;write = PyObject_GetAttr(file, write_str)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "argument must have 'write' "
                            "attribute");
            goto err;
          }
        }

        UNLESS (self-&gt;write_buf = 
            (char *)malloc(WRITE_BUF_SIZE * sizeof(char))) { 
            PyErr_NoMemory();
            goto err;
        }
    }

    if (PyEval_GetRestricted()) {
        /* Restricted execution, get private tables */
        PyObject *m;

        UNLESS (m=PyImport_Import(copy_reg_str)) goto err;
        self-&gt;dispatch_table=PyObject_GetAttr(m, dispatch_table_str);
        Py_DECREF(m);
        UNLESS (self-&gt;dispatch_table) goto err;
    }
    else {
        self-&gt;dispatch_table=dispatch_table;
        Py_INCREF(dispatch_table);
    }

    return self;

err:
    Py_DECREF((PyObject *)self);
    return NULL;
}


static PyObject *
get_Pickler(PyObject *self, PyObject *args) {
    PyObject *file=NULL;
    int bin;

    bin=1;
    if (! PyArg_ParseTuple(args, "|i", &amp;bin)) {
        PyErr_Clear();
        bin=0;
        if (! PyArg_ParseTuple(args, "O|i", &amp;file, &amp;bin))
          return NULL;
      }
    return (PyObject *)newPicklerobject(file, bin);
}


static void
Pickler_dealloc(Picklerobject *self) {
    Py_XDECREF(self-&gt;write);
    Py_XDECREF(self-&gt;memo);
    Py_XDECREF(self-&gt;arg);
    Py_XDECREF(self-&gt;file);
    Py_XDECREF(self-&gt;pers_func);
    Py_XDECREF(self-&gt;inst_pers_func);
    Py_XDECREF(self-&gt;dispatch_table);

    if (self-&gt;write_buf) {    
        free(self-&gt;write_buf);
    }

    PyMem_DEL(self);
}


static PyObject *
Pickler_getattr(Picklerobject *self, char *name) {

  switch (*name) {
  case 'p':
    if (strcmp(name, "persistent_id") == 0) {
        if (!self-&gt;pers_func) {
            PyErr_SetString(PyExc_AttributeError, name);
            return NULL;
        }

        Py_INCREF(self-&gt;pers_func);
        return self-&gt;pers_func;
    }
    break;
  case 'm':
    if (strcmp(name, "memo") == 0) {
        if (!self-&gt;memo) {
            PyErr_SetString(PyExc_AttributeError, name);
            return NULL;
        }

        Py_INCREF(self-&gt;memo);
        return self-&gt;memo;
    }
    break;
  case 'P':
    if (strcmp(name, "PicklingError") == 0) {
        Py_INCREF(PicklingError);
        return PicklingError;
    }
    break;
  case 'b':
    if (strcmp(name, "binary")==0)
      return PyInt_FromLong(self-&gt;bin);
    break;
  case 'f':
    if (strcmp(name, "fast")==0)
      return PyInt_FromLong(self-&gt;fast);
    break;
  case 'g':
    if (strcmp(name, "getvalue")==0 &amp;&amp; ! Pdata_Check(self-&gt;file)) {
      PyErr_SetString(PyExc_AttributeError, name);
      return NULL;
    }
    break;
  }
  return Py_FindMethod(Pickler_methods, (PyObject *)self, name);
}


int 
Pickler_setattr(Picklerobject *self, char *name, PyObject *value) {

    if (! value) {
        PyErr_SetString(PyExc_TypeError,
                        "attribute deletion is not supported");
        return -1;
    }
  
    if (strcmp(name, "persistent_id") == 0) {
        Py_XDECREF(self-&gt;pers_func);
        self-&gt;pers_func = value;
        Py_INCREF(value);
        return 0;
    }

    if (strcmp(name, "inst_persistent_id") == 0) {
        Py_XDECREF(self-&gt;inst_pers_func);
        self-&gt;inst_pers_func = value;
        Py_INCREF(value);
        return 0;
    }

    if (strcmp(name, "memo") == 0) {
        if (! PyDict_Check(value)) {
          PyErr_SetString(PyExc_TypeError, "memo must be a dictionary");
          return -1;
        }
        Py_XDECREF(self-&gt;memo);
        self-&gt;memo = value;
        Py_INCREF(value);
        return 0;
    }

    if (strcmp(name, "binary")==0) {
        self-&gt;bin=PyObject_IsTrue(value);
        return 0;
    }

    if (strcmp(name, "fast")==0) {
        self-&gt;fast=PyObject_IsTrue(value);
        return 0;
    }

    PyErr_SetString(PyExc_AttributeError, name);
    return -1;
}


static char Picklertype__doc__[] =
"Objects that know how to pickle objects\n"
;

static PyTypeObject Picklertype = {
    PyObject_HEAD_INIT(NULL)
    0,                            /*ob_size*/
    "Pickler",                    /*tp_name*/
    sizeof(Picklerobject),                /*tp_basicsize*/
    0,                            /*tp_itemsize*/
    /* methods */
    (destructor)Pickler_dealloc,  /*tp_dealloc*/
    (printfunc)0,         /*tp_print*/
    (getattrfunc)Pickler_getattr, /*tp_getattr*/
    (setattrfunc)Pickler_setattr, /*tp_setattr*/
    (cmpfunc)0,           /*tp_compare*/
    (reprfunc)0,          /*tp_repr*/
    0,                    /*tp_as_number*/
    0,            /*tp_as_sequence*/
    0,            /*tp_as_mapping*/
    (hashfunc)0,          /*tp_hash*/
    (ternaryfunc)0,               /*tp_call*/
    (reprfunc)0,          /*tp_str*/

    /* Space for future expansion */
    0L,0L,0L,0L,
    Picklertype__doc__ /* Documentation string */
};

static PyObject *
find_class(PyObject *py_module_name, PyObject *py_global_name, PyObject *fc) {
    PyObject *global = 0, *module;

    if (fc) {
      if (fc==Py_None) {
	PyErr_SetString(UnpicklingError, 
			"Global and instance pickles are not supported.");
	return NULL;
      }
      return PyObject_CallFunction(fc, "OO", py_module_name, py_global_name);
    }

    module = PySys_GetObject("modules");
    if (module == NULL)
      return NULL;

    module = PyDict_GetItem(module, py_module_name);
    if (module == NULL) {
      module = PyImport_Import(py_module_name);
      if (!module)
          return NULL;
      global = PyObject_GetAttr(module, py_global_name);
      Py_DECREF(module);
    }
    else
      global = PyObject_GetAttr(module, py_global_name);
    if (global == NULL) {
      char buf[256 + 37];
      sprintf(buf, "Failed to import class %.128s from module %.128s",
              PyString_AS_STRING((PyStringObject*)py_global_name),
              PyString_AS_STRING((PyStringObject*)py_module_name));  
      PyErr_SetString(PyExc_SystemError, buf);
      return NULL;
    }
    return global;
}

static int
marker(Unpicklerobject *self) {
    if (self-&gt;num_marks &lt; 1) {
        PyErr_SetString(UnpicklingError, "could not find MARK");
        return -1;
    }

    return self-&gt;marks[--self-&gt;num_marks];
}

    
static int
load_none(Unpicklerobject *self) {
    PDATA_APPEND(self-&gt;stack, Py_None, -1);
    return 0;
}

static int
bad_readline() {
    PyErr_SetString(UnpicklingError, "pickle data was truncated");
    return -1;
}

static int
load_int(Unpicklerobject *self) {
    PyObject *py_int = 0;
    char *endptr, *s;
    int len, res = -1;
    long l;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (s=pystrndup(s,len)) return -1;

    errno = 0;
    l = strtol(s, &amp;endptr, 0);

    if (errno || (*endptr != '\n') || (endptr[1] != '\0')) {
        /* Hm, maybe we've got something long.  Let's try reading
           it as a Python long object. */
        errno=0;
        UNLESS (py_int=PyLong_FromString(s,&amp;endptr,0)) goto finally;

        if ((*endptr != '\n') || (endptr[1] != '\0')) {
            PyErr_SetString(PyExc_ValueError,
                            "could not convert string to int");
            goto finally;
        }
    }
    else {
        UNLESS (py_int = PyInt_FromLong(l)) goto finally;
    }

    free(s);
    PDATA_PUSH(self-&gt;stack, py_int, -1);
    return 0;

finally:
    free(s);

    return res;
}


static long 
calc_binint(char *s, int  x) {
    unsigned char c;
    int i;
    long l;

    for (i = 0, l = 0L; i &lt; x; i++) {
        c = (unsigned char)s[i];
        l |= (long)c &lt;&lt; (i * 8);
    }
#if SIZEOF_LONG &gt; 4
    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (x == 4 &amp;&amp; l &amp; (1L &lt;&lt; 31))
        l |= (~0L) &lt;&lt; 32;
#endif
    return l;
}


static int
load_binintx(Unpicklerobject *self, char *s, int  x) {
    PyObject *py_int = 0;
    long l;

    l = calc_binint(s, x);

    UNLESS (py_int = PyInt_FromLong(l))
        return -1;

    PDATA_PUSH(self-&gt;stack, py_int, -1);
    return 0;
}


static int
load_binint(Unpicklerobject *self) {
    char *s;

    if ((*self-&gt;read_func)(self, &amp;s, 4) &lt; 0)
        return -1;

    return load_binintx(self, s, 4);
}


static int
load_binint1(Unpicklerobject *self) {
    char *s;

    if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0)
        return -1;

    return load_binintx(self, s, 1);
}


static int
load_binint2(Unpicklerobject *self) {
    char *s;

    if ((*self-&gt;read_func)(self, &amp;s, 2) &lt; 0)
        return -1;

    return load_binintx(self, s, 2);
}
    
static int
load_long(Unpicklerobject *self) {
    PyObject *l = 0;
    char *end, *s;
    int len, res = -1;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (s=pystrndup(s,len)) return -1;

    UNLESS (l = PyLong_FromString(s, &amp;end, 0))
        goto finally;

    free(s);
    PDATA_PUSH(self-&gt;stack, l, -1);
    return 0;

finally:
    free(s);

    return res;
}

 
static int
load_float(Unpicklerobject *self) {
    PyObject *py_float = 0;
    char *endptr, *s;
    int len, res = -1;
    double d;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (s=pystrndup(s,len)) return -1;

    errno = 0;
    d = strtod(s, &amp;endptr);

    if (errno || (endptr[0] != '\n') || (endptr[1] != '\0')) {
        PyErr_SetString(PyExc_ValueError, 
        "could not convert string to float");
        goto finally;
    }

    UNLESS (py_float = PyFloat_FromDouble(d))
        goto finally;

    free(s);
    PDATA_PUSH(self-&gt;stack, py_float, -1);
    return 0;

finally:
    free(s);

    return res;
}

static int
load_binfloat(Unpicklerobject *self) {
    PyObject *py_float = 0;
    int s, e;
    long fhi, flo;
    double x;
    char *p;

    if ((*self-&gt;read_func)(self, &amp;p, 8) &lt; 0)
        return -1;

    /* First byte */
    s = (*p&gt;&gt;7) &amp; 1;
    e = (*p &amp; 0x7F) &lt;&lt; 4;
    p++;

    /* Second byte */
    e |= (*p&gt;&gt;4) &amp; 0xF;
    fhi = (*p &amp; 0xF) &lt;&lt; 24;
    p++;

    /* Third byte */
    fhi |= (*p &amp; 0xFF) &lt;&lt; 16;
    p++;

    /* Fourth byte */
    fhi |= (*p &amp; 0xFF) &lt;&lt; 8;
    p++;

    /* Fifth byte */
    fhi |= *p &amp; 0xFF;
    p++;

    /* Sixth byte */
    flo = (*p &amp; 0xFF) &lt;&lt; 16;
    p++;

    /* Seventh byte */
    flo |= (*p &amp; 0xFF) &lt;&lt; 8;
    p++;

    /* Eighth byte */
    flo |= *p &amp; 0xFF;

    x = (double)fhi + (double)flo / 16777216.0; /* 2**24 */
    x /= 268435456.0; /* 2**28 */

    /* XXX This sadly ignores Inf/NaN */
    if (e == 0)
        e = -1022;
    else {
        x += 1.0;
        e -= 1023;
    }
    x = ldexp(x, e);

    if (s)
        x = -x;

    UNLESS (py_float = PyFloat_FromDouble(x)) return -1;

    PDATA_PUSH(self-&gt;stack, py_float, -1);
    return 0;
}

static int
load_string(Unpicklerobject *self) {
    PyObject *str = 0;
    int len, res = -1, nslash;
    char *s, q, *p;

    static PyObject *eval_dict = 0;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (s=pystrndup(s,len)) return -1;

    /* Check for unquoted quotes (evil strings) */
    q=*s;
    if (q != '"' &amp;&amp; q != '\'') goto insecure;
    for (p=s+1, nslash=0; *p; p++) {
        if (*p==q &amp;&amp; nslash%2==0) break;
        if (*p=='\\') nslash++;
        else nslash=0;
      }
    if (*p==q)
      {
        for (p++; *p; p++) if (*p &gt; ' ') goto insecure;
      }
    else goto insecure;
    /********************************************/

    UNLESS (eval_dict)
        UNLESS (eval_dict = Py_BuildValue("{s{}}", "__builtins__"))
            goto finally;

    UNLESS (str = PyRun_String(s, Py_eval_input, eval_dict, eval_dict))
        goto finally;

    free(s);
    PDATA_PUSH(self-&gt;stack, str, -1);
    return 0;

finally:
    free(s);

    return res;
    
insecure:
    free(s);
    PyErr_SetString(PyExc_ValueError,"insecure string pickle");
    return -1;
} 


static int
load_binstring(Unpicklerobject *self) {
    PyObject *py_string = 0;
    long l;
    char *s;

    if ((*self-&gt;read_func)(self, &amp;s, 4) &lt; 0) return -1;

    l = calc_binint(s, 4);

    if ((*self-&gt;read_func)(self, &amp;s, l) &lt; 0)
        return -1;

    UNLESS (py_string = PyString_FromStringAndSize(s, l))
        return -1;

    PDATA_PUSH(self-&gt;stack, py_string, -1);
    return 0;
}


static int
load_short_binstring(Unpicklerobject *self) {
    PyObject *py_string = 0;
    unsigned char l;  
    char *s;

    if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0)
        return -1;

    l = (unsigned char)s[0];

    if ((*self-&gt;read_func)(self, &amp;s, l) &lt; 0) return -1;

    UNLESS (py_string = PyString_FromStringAndSize(s, l)) return -1;

    PDATA_PUSH(self-&gt;stack, py_string, -1);
    return 0;
} 


static int
load_tuple(Unpicklerobject *self) {
    PyObject *tup;
    int i;

    if ((i = marker(self)) &lt; 0) return -1;
    UNLESS (tup=Pdata_popTuple(self-&gt;stack, i)) return -1;
    PDATA_PUSH(self-&gt;stack, tup, -1);
    return 0;
}

static int
load_empty_tuple(Unpicklerobject *self) {
    PyObject *tup;

    UNLESS (tup=PyTuple_New(0)) return -1;
    PDATA_PUSH(self-&gt;stack, tup, -1);
    return 0;
}

static int
load_empty_list(Unpicklerobject *self) {
    PyObject *list;

    UNLESS (list=PyList_New(0)) return -1;
    PDATA_PUSH(self-&gt;stack, list, -1);
    return 0;
}

static int
load_empty_dict(Unpicklerobject *self) {
    PyObject *dict;

    UNLESS (dict=PyDict_New()) return -1;
    PDATA_PUSH(self-&gt;stack, dict, -1);
    return 0;
}


static int
load_list(Unpicklerobject *self) {
    PyObject *list = 0;
    int i;

    if ((i = marker(self)) &lt; 0) return -1;
    UNLESS (list=Pdata_popList(self-&gt;stack, i)) return -1;
    PDATA_PUSH(self-&gt;stack, list, -1);
    return 0;
}

static int
load_dict(Unpicklerobject *self) {
    PyObject *dict, *key, *value;
    int i, j, k;

    if ((i = marker(self)) &lt; 0) return -1;
    j=self-&gt;stack-&gt;length;

    UNLESS (dict = PyDict_New()) return -1;

    for (k = i+1; k &lt; j; k += 2) {
        key  =self-&gt;stack-&gt;data[k-1];
        value=self-&gt;stack-&gt;data[k  ];
        if (PyDict_SetItem(dict, key, value) &lt; 0) {
            Py_DECREF(dict);
            return -1;
        }
    }
    Pdata_clear(self-&gt;stack, i);
    PDATA_PUSH(self-&gt;stack, dict, -1);
    return 0;
}

static PyObject *
Instance_New(PyObject *cls, PyObject *args) {
  int has_key;
  PyObject *safe=0, *r=0;

  if (PyClass_Check(cls)) {
      int l;
      
      if ((l=PyObject_Length(args)) &lt; 0) goto err;
      UNLESS (l) {
          PyObject *__getinitargs__;

          UNLESS (__getinitargs__=PyObject_GetAttr(cls, __getinitargs___str)) {
              /* We have a class with no __getinitargs__, so bypass usual
                 construction  */
              PyInstanceObject *inst;

              PyErr_Clear();
              UNLESS (inst=PyObject_NEW(PyInstanceObject, &amp;PyInstance_Type))
                goto err;
              inst-&gt;in_class=(PyClassObject*)cls;
              Py_INCREF(cls);
              UNLESS (inst-&gt;in_dict=PyDict_New()) {
                Py_DECREF(inst);
                goto err;
              }

              return (PyObject *)inst;
            }
          Py_DECREF(__getinitargs__);
        }
      
      if ((r=PyInstance_New(cls, args, NULL))) return r;
      else goto err;
    }
       
  
  if ((has_key = cPickle_PyMapping_HasKey(safe_constructors, cls)) &lt; 0)
    goto err;
    
  if (!has_key)
    if (!(safe = PyObject_GetAttr(cls, __safe_for_unpickling___str)) ||
       !PyObject_IsTrue(safe)) {
      cPickle_ErrFormat(UnpicklingError,
                        "%s is not safe for unpickling", "O", cls);
      Py_XDECREF(safe);
      return NULL;
  }

  if (args==Py_None) {
      /* Special case, call cls.__basicnew__() */
      PyObject *basicnew;
      
      UNLESS (basicnew=PyObject_GetAttr(cls, __basicnew___str)) return NULL;
      r=PyObject_CallObject(basicnew, NULL);
      Py_DECREF(basicnew);
      if (r) return r;
    }

  if ((r=PyObject_CallObject(cls, args))) return r;

err:
  {
    PyObject *tp, *v, *tb;

    PyErr_Fetch(&amp;tp, &amp;v, &amp;tb);
    if ((r=Py_BuildValue("OOO",v,cls,args))) {
        Py_XDECREF(v);
        v=r;
      }
    PyErr_Restore(tp,v,tb);
  }
  return NULL;
}
  

static int
load_obj(Unpicklerobject *self) {
    PyObject *class, *tup, *obj=0;
    int i;

    if ((i = marker(self)) &lt; 0) return -1;
    UNLESS (tup=Pdata_popTuple(self-&gt;stack, i+1)) return -1;
    PDATA_POP(self-&gt;stack, class);
    if (class) {
        obj = Instance_New(class, tup);
        Py_DECREF(class);
    }
    Py_DECREF(tup);

    if (! obj) return -1;
    PDATA_PUSH(self-&gt;stack, obj, -1);
    return 0;
}


static int
load_inst(Unpicklerobject *self) {
    PyObject *tup, *class=0, *obj=0, *module_name, *class_name;
    int i, len;
    char *s;

    if ((i = marker(self)) &lt; 0) return -1;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (module_name = PyString_FromStringAndSize(s, len - 1)) return -1;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &gt;= 0) {
        if (len &lt; 2) return bad_readline();
        if ((class_name = PyString_FromStringAndSize(s, len - 1))) {
            class = find_class(module_name, class_name, self-&gt;find_class);
            Py_DECREF(class_name);
        }
    }
    Py_DECREF(module_name);

    if (! class) return -1;
      
    if ((tup=Pdata_popTuple(self-&gt;stack, i))) {
        obj = Instance_New(class, tup);
        Py_DECREF(tup);
    }
    Py_DECREF(class);

    if (! obj) return -1;

    PDATA_PUSH(self-&gt;stack, obj, -1);
    return 0;
}


static int
load_global(Unpicklerobject *self) {
    PyObject *class = 0, *module_name = 0, *class_name = 0;
    int len;
    char *s;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();
    UNLESS (module_name = PyString_FromStringAndSize(s, len - 1)) return -1;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &gt;= 0) {
        if (len &lt; 2) return bad_readline();
        if ((class_name = PyString_FromStringAndSize(s, len - 1))) {
            class = find_class(module_name, class_name, self-&gt;find_class);
            Py_DECREF(class_name);
        }
    }
    Py_DECREF(module_name);

    if (! class) return -1;
    PDATA_PUSH(self-&gt;stack, class, -1);
    return 0;
}


static int
load_persid(Unpicklerobject *self) {
    PyObject *pid = 0;
    int len;
    char *s;

    if (self-&gt;pers_func) {
        if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
	if (len &lt; 2) return bad_readline();
  
        UNLESS (pid = PyString_FromStringAndSize(s, len - 1)) return -1;

        if (PyList_Check(self-&gt;pers_func)) {
            if (PyList_Append(self-&gt;pers_func, pid) &lt; 0) {
                Py_DECREF(pid);
                return -1;
            }
        }
        else {
            ARG_TUP(self, pid);
            if (self-&gt;arg) {
                pid = PyObject_CallObject(self-&gt;pers_func, self-&gt;arg);
                FREE_ARG_TUP(self);
            }
        }

        if (! pid) return -1;

        PDATA_PUSH(self-&gt;stack, pid, -1);
        return 0;
    }
    else {
      PyErr_SetString(UnpicklingError,
                      "A load persistent id instruction was encountered,\n"
                      "but no persistent_load function was specified.");
      return -1;
    }
}

static int
load_binpersid(Unpicklerobject *self) {
    PyObject *pid = 0;

    if (self-&gt;pers_func) {
        PDATA_POP(self-&gt;stack, pid);
        if (! pid) return -1;

        if (PyList_Check(self-&gt;pers_func)) {
            if (PyList_Append(self-&gt;pers_func, pid) &lt; 0) {
                Py_DECREF(pid);
                return -1;
            }
          }
        else {
            ARG_TUP(self, pid);
            if (self-&gt;arg) {
                pid = PyObject_CallObject(self-&gt;pers_func, self-&gt;arg);
                FREE_ARG_TUP(self);
            }
            if (! pid) return -1;
        }

        PDATA_PUSH(self-&gt;stack, pid, -1);
        return 0;
    }
    else {
      PyErr_SetString(UnpicklingError,
                      "A load persistent id instruction was encountered,\n"
                      "but no persistent_load function was specified.");
      return -1;
    }
}


static int
load_pop(Unpicklerobject *self) {
    int len;

    UNLESS ((len=self-&gt;stack-&gt;length) &gt; 0) return stackUnderflow();
				
    /* Note that we split the (pickle.py) stack into two stacks, 
       an object stack and a mark stack. We have to be clever and
       pop the right one. We do this by looking at the top of the
       mark stack.
    */
    if ((self-&gt;num_marks &gt; 0) &amp;&amp; 
        (self-&gt;marks[self-&gt;num_marks - 1] == len))
        self-&gt;num_marks--;
    else { 
        len--;
        Py_DECREF(self-&gt;stack-&gt;data[len]);
	self-&gt;stack-&gt;length=len;
    }

    return 0;
}


static int
load_pop_mark(Unpicklerobject *self) {
    int i;

    if ((i = marker(self)) &lt; 0)
        return -1;

    Pdata_clear(self-&gt;stack, i);

    return 0;
}


static int
load_dup(Unpicklerobject *self) {
    PyObject *last;
    int len;

    if ((len = self-&gt;stack-&gt;length) &lt;= 0) return stackUnderflow();
    last=self-&gt;stack-&gt;data[len-1];
    Py_INCREF(last);
    PDATA_PUSH(self-&gt;stack, last, -1);
    return 0;
}


static int
load_get(Unpicklerobject *self) {
    PyObject *py_str = 0, *value = 0;
    int len;
    char *s;
    int rc;

    if ((len = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (len &lt; 2) return bad_readline();

    UNLESS (py_str = PyString_FromStringAndSize(s, len - 1)) return -1;

    value = PyDict_GetItem(self-&gt;memo, py_str);
    if (! value) {
        PyErr_SetObject(BadPickleGet, py_str);
        rc = -1;
    } else {
      PDATA_APPEND(self-&gt;stack, value, -1);
      rc = 0;
    }

    Py_DECREF(py_str);
    return rc;
}


static int
load_binget(Unpicklerobject *self) {
    PyObject *py_key = 0, *value = 0;
    unsigned char key;
    char *s;
    int rc;

    if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0) return -1;

    key = (unsigned char)s[0];
    UNLESS (py_key = PyInt_FromLong((long)key)) return -1;
    
    value = PyDict_GetItem(self-&gt;memo, py_key);
    if (! value) {
        PyErr_SetObject(BadPickleGet, py_key);
        rc = -1;
    } else {
      PDATA_APPEND(self-&gt;stack, value, -1);
      rc = 0;
    }

    Py_DECREF(py_key);
    return rc;
}


static int
load_long_binget(Unpicklerobject *self) {
    PyObject *py_key = 0, *value = 0;
    unsigned char c, *s;
    long key;
    int rc;

    if ((*self-&gt;read_func)(self, &amp;s, 4) &lt; 0) return -1;

    c = (unsigned char)s[0];
    key = (long)c;
    c = (unsigned char)s[1];
    key |= (long)c &lt;&lt; 8;
    c = (unsigned char)s[2];
    key |= (long)c &lt;&lt; 16;
    c = (unsigned char)s[3];
    key |= (long)c &lt;&lt; 24;

    UNLESS (py_key = PyInt_FromLong((long)key)) return -1;
    
    value = PyDict_GetItem(self-&gt;memo, py_key);
    if (! value) {
        PyErr_SetObject(BadPickleGet, py_key);
        rc = -1;
    } else {
      PDATA_APPEND(self-&gt;stack, value, -1);
      rc = 0;
    }

    Py_DECREF(py_key);
    return rc;
}


static int
load_put(Unpicklerobject *self) {
    PyObject *py_str = 0, *value = 0;
    int len, l;
    char *s;

    if ((l = (*self-&gt;readline_func)(self, &amp;s)) &lt; 0) return -1;
    if (l &lt; 2) return bad_readline();
    UNLESS (len=self-&gt;stack-&gt;length) return stackUnderflow();
    UNLESS (py_str = PyString_FromStringAndSize(s, l - 1)) return -1;
    value=self-&gt;stack-&gt;data[len-1];
    l=PyDict_SetItem(self-&gt;memo, py_str, value);
    Py_DECREF(py_str);
    return l;
}


static int
load_binput(Unpicklerobject *self) {
    PyObject *py_key = 0, *value = 0;
    unsigned char key, *s;
    int len;

    if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0) return -1;
    UNLESS ((len=self-&gt;stack-&gt;length) &gt; 0) return stackUnderflow();

    key = (unsigned char)s[0];

    UNLESS (py_key = PyInt_FromLong((long)key)) return -1;
    value=self-&gt;stack-&gt;data[len-1];
    len=PyDict_SetItem(self-&gt;memo, py_key, value);
    Py_DECREF(py_key);
    return len;
}


static int
load_long_binput(Unpicklerobject *self) {
    PyObject *py_key = 0, *value = 0;
    long key;
    unsigned char c, *s;
    int len;

    if ((*self-&gt;read_func)(self, &amp;s, 4) &lt; 0) return -1;
    UNLESS (len=self-&gt;stack-&gt;length) return stackUnderflow();

    c = (unsigned char)s[0];
    key = (long)c;
    c = (unsigned char)s[1];
    key |= (long)c &lt;&lt; 8;
    c = (unsigned char)s[2];
    key |= (long)c &lt;&lt; 16;
    c = (unsigned char)s[3];
    key |= (long)c &lt;&lt; 24;

    UNLESS (py_key = PyInt_FromLong(key)) return -1;
    value=self-&gt;stack-&gt;data[len-1];
    len=PyDict_SetItem(self-&gt;memo, py_key, value);
    Py_DECREF(py_key);
    return len;
}


static int 
do_append(Unpicklerobject *self, int  x) {
    PyObject *value = 0, *list = 0, *append_method = 0;
    int len, i;

    UNLESS ((len=self-&gt;stack-&gt;length) &gt;= x &amp;&amp; x &gt; 0) return stackUnderflow();
    if (len==x) return 0;       /* nothing to do */

    list=self-&gt;stack-&gt;data[x-1];

    if (PyList_Check(list)) {
        PyObject *slice;
        int list_len;
       
        slice=Pdata_popList(self-&gt;stack, x);
        list_len = PyList_GET_SIZE(list);
        i=PyList_SetSlice(list, list_len, list_len, slice);
        Py_DECREF(slice);
        return i;
    }
    else {

        UNLESS (append_method = PyObject_GetAttr(list, append_str))
            return -1;
         
        for (i = x; i &lt; len; i++) {
            PyObject *junk;

            value=self-&gt;stack-&gt;data[i];
            junk=0;
            ARG_TUP(self, value);
            if (self-&gt;arg) {
              junk = PyObject_CallObject(append_method, self-&gt;arg);
              FREE_ARG_TUP(self);
            }
            if (! junk) {
                Pdata_clear(self-&gt;stack, i+1);
                self-&gt;stack-&gt;length=x;
                Py_DECREF(append_method);
                return -1;
            }
            Py_DECREF(junk);
        }
        self-&gt;stack-&gt;length=x;
        Py_DECREF(append_method);
    }

    return 0;
}

    
static int
load_append(Unpicklerobject *self) {
    return do_append(self, self-&gt;stack-&gt;length - 1);
}


static int
load_appends(Unpicklerobject *self) {
    return do_append(self, marker(self));
}


static int
do_setitems(Unpicklerobject *self, int  x) {
    PyObject *value = 0, *key = 0, *dict = 0;
    int len, i, r=0;

    UNLESS ((len=self-&gt;stack-&gt;length) &gt;= x
            &amp;&amp; x &gt; 0) return stackUnderflow();

    dict=self-&gt;stack-&gt;data[x-1];

    for (i = x+1; i &lt; len; i += 2) {
        key  =self-&gt;stack-&gt;data[i-1];
        value=self-&gt;stack-&gt;data[i  ];
        if (PyObject_SetItem(dict, key, value) &lt; 0) {
            r=-1;
            break;
        }
    }

    Pdata_clear(self-&gt;stack, x);

    return r;
}


static int
load_setitem(Unpicklerobject *self) {
    return do_setitems(self, self-&gt;stack-&gt;length - 2);
}

static int
load_setitems(Unpicklerobject *self) {
    return do_setitems(self, marker(self));
}


static int
load_build(Unpicklerobject *self) {
    PyObject *value = 0, *inst = 0, *instdict = 0, *d_key = 0, *d_value = 0, 
             *junk = 0, *__setstate__ = 0;
    int i, r = 0;

    if (self-&gt;stack-&gt;length &lt; 2) return stackUnderflow();
    PDATA_POP(self-&gt;stack, value);
    if (! value) return -1;
    inst=self-&gt;stack-&gt;data[self-&gt;stack-&gt;length-1];

    if ((__setstate__ = PyObject_GetAttr(inst, __setstate___str))) {
        ARG_TUP(self, value);
        if (self-&gt;arg) {
            junk = PyObject_CallObject(__setstate__, self-&gt;arg);
            FREE_ARG_TUP(self);
        }
        Py_DECREF(__setstate__);
        if (! junk) return -1;
        Py_DECREF(junk);
        return 0;
    }

    PyErr_Clear();
    if ((instdict = PyObject_GetAttr(inst, __dict___str))) {
        i = 0;
        while (PyDict_Next(value, &amp;i, &amp;d_key, &amp;d_value)) {
            if (PyObject_SetItem(instdict, d_key, d_value) &lt; 0) {
                r=-1;
                break;
            }
        }
        Py_DECREF(instdict);
    }
    else r=-1;

    Py_XDECREF(value);
  
    return r;
}


static int
load_mark(Unpicklerobject *self) {
    int s;
				
    /* Note that we split the (pickle.py) stack into two stacks, an
       object stack and a mark stack. Here we push a mark onto the
       mark stack.  
    */

    if ((self-&gt;num_marks + 1) &gt;= self-&gt;marks_size) {
        s=self-&gt;marks_size+20;
        if (s &lt;= self-&gt;num_marks) s=self-&gt;num_marks + 1;
        if (self-&gt;marks == NULL)
            self-&gt;marks=(int *)malloc(s * sizeof(int));
        else
            self-&gt;marks=(int *)realloc(self-&gt;marks, s * sizeof(int));
        if (! self-&gt;marks) {
            PyErr_NoMemory();
            return -1;
        }
        self-&gt;marks_size = s;
    }

    self-&gt;marks[self-&gt;num_marks++] = self-&gt;stack-&gt;length;

    return 0;
}

static int
load_reduce(Unpicklerobject *self) {
    PyObject *callable = 0, *arg_tup = 0, *ob = 0;

    PDATA_POP(self-&gt;stack, arg_tup);
    if (! arg_tup) return -1;
    PDATA_POP(self-&gt;stack, callable);
    if (callable) {
        ob = Instance_New(callable, arg_tup);
        Py_DECREF(callable);
    }
    Py_DECREF(arg_tup);

    if (! ob) return -1;
   
    PDATA_PUSH(self-&gt;stack, ob, -1);
    return 0;
}
    
static PyObject *
load(Unpicklerobject *self) {
    PyObject *err = 0, *val = 0;
    char *s;

    self-&gt;num_marks = 0;
    if (self-&gt;stack-&gt;length) Pdata_clear(self-&gt;stack, 0);

    while (1) {
        if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0)
            break;

        switch (s[0]) {
            case NONE:
                if (load_none(self) &lt; 0)
                    break;
                continue;

            case BININT:
                 if (load_binint(self) &lt; 0)
                     break;
                 continue;

            case BININT1:
                if (load_binint1(self) &lt; 0)
                    break;
                continue;

            case BININT2:
                if (load_binint2(self) &lt; 0)
                    break;
                continue;

            case INT:
                if (load_int(self) &lt; 0)
                    break;
                continue;

            case LONG:
                if (load_long(self) &lt; 0)
                    break;
                continue;

            case FLOAT:
                if (load_float(self) &lt; 0)
                    break;
                continue;

            case BINFLOAT:
                if (load_binfloat(self) &lt; 0)
                    break;
                continue;

            case BINSTRING:
                if (load_binstring(self) &lt; 0)
                    break;
                continue;

            case SHORT_BINSTRING:
                if (load_short_binstring(self) &lt; 0)
                    break;
                continue;

            case STRING:
                if (load_string(self) &lt; 0)
                    break;
                continue;

            case EMPTY_TUPLE:
                if (load_empty_tuple(self) &lt; 0)
                    break;
                continue;

            case TUPLE:
                if (load_tuple(self) &lt; 0)
                    break;
                continue;

            case EMPTY_LIST:
                if (load_empty_list(self) &lt; 0)
                    break;
                continue;

            case LIST:
                if (load_list(self) &lt; 0)
                    break;
                continue;

            case EMPTY_DICT:
                if (load_empty_dict(self) &lt; 0)
                    break;
                continue;

            case DICT:
                if (load_dict(self) &lt; 0)
                    break;
                continue;

            case OBJ:
                if (load_obj(self) &lt; 0)
                    break;
                continue;

            case INST:
                if (load_inst(self) &lt; 0)
                    break;
                continue;

            case GLOBAL:
                if (load_global(self) &lt; 0)
                    break;
                continue;

            case APPEND:
                if (load_append(self) &lt; 0)
                    break;
                continue;

            case APPENDS:
                if (load_appends(self) &lt; 0)
                    break;
                continue;
   
            case BUILD:
                if (load_build(self) &lt; 0)
                    break;
                continue;
  
            case DUP:
                if (load_dup(self) &lt; 0)
                    break;
                continue;

            case BINGET:
                if (load_binget(self) &lt; 0)
                    break;
                continue;

            case LONG_BINGET:
                if (load_long_binget(self) &lt; 0)
                    break;
                continue;
         
            case GET:
                if (load_get(self) &lt; 0)
                    break;
                continue;

            case MARK:
                if (load_mark(self) &lt; 0)
                    break;
                continue;

            case BINPUT:
                if (load_binput(self) &lt; 0)
                    break;
                continue;

            case LONG_BINPUT:
                if (load_long_binput(self) &lt; 0)
                    break;
                continue;
         
            case PUT:
                if (load_put(self) &lt; 0)
                    break;
                continue;

            case POP:
                if (load_pop(self) &lt; 0)
                    break;
                continue;

            case POP_MARK:
                if (load_pop_mark(self) &lt; 0)
                    break;
                continue;

            case SETITEM:
                if (load_setitem(self) &lt; 0)
                    break;
                continue;

            case SETITEMS:
                if (load_setitems(self) &lt; 0)
                    break;
                continue;

            case STOP:
                break;

            case PERSID:
                if (load_persid(self) &lt; 0)
                    break;
                continue;

            case BINPERSID:
                if (load_binpersid(self) &lt; 0)
                    break;
                continue;

            case REDUCE:
                if (load_reduce(self) &lt; 0)
                    break;
                continue;

            default: 
                cPickle_ErrFormat(UnpicklingError, "invalid load key, '%s'.", 
                    "c", s[0]);
                return NULL;
        }

        break;
    }

    if ((err = PyErr_Occurred())) {
        if (err == PyExc_EOFError) {
            PyErr_SetNone(PyExc_EOFError);
        }    
        return NULL;
    }

    PDATA_POP(self-&gt;stack, val);    
    return val;
}
    

/* No-load functions to support noload, which is used to
   find persistent references. */

static int
noload_obj(Unpicklerobject *self) {
    int i;

    if ((i = marker(self)) &lt; 0) return -1;
    return Pdata_clear(self-&gt;stack, i+1);
}


static int
noload_inst(Unpicklerobject *self) {
    int i;
    char *s;

    if ((i = marker(self)) &lt; 0) return -1;
    Pdata_clear(self-&gt;stack, i);
    if ((*self-&gt;readline_func)(self, &amp;s) &lt; 0) return -1;
    if ((*self-&gt;readline_func)(self, &amp;s) &lt; 0) return -1;
    PDATA_APPEND(self-&gt;stack, Py_None,-1);
    return 0;
}

static int
noload_global(Unpicklerobject *self) {
    char *s;

    if ((*self-&gt;readline_func)(self, &amp;s) &lt; 0) return -1;
    if ((*self-&gt;readline_func)(self, &amp;s) &lt; 0) return -1;
    PDATA_APPEND(self-&gt;stack, Py_None,-1);
    return 0;
}

static int
noload_reduce(Unpicklerobject *self) {

    if (self-&gt;stack-&gt;length &lt; 2) return stackUnderflow();
    Pdata_clear(self-&gt;stack, self-&gt;stack-&gt;length-2);
    PDATA_APPEND(self-&gt;stack, Py_None,-1);
    return 0;
}

static int
noload_build(Unpicklerobject *self) {

  if (self-&gt;stack-&gt;length &lt; 1) return stackUnderflow();
  Pdata_clear(self-&gt;stack, self-&gt;stack-&gt;length-1);
  return 0;
}


static PyObject *
noload(Unpicklerobject *self) {
    PyObject *err = 0, *val = 0;
    char *s;

    self-&gt;num_marks = 0;
    Pdata_clear(self-&gt;stack, 0);

    while (1) {
        if ((*self-&gt;read_func)(self, &amp;s, 1) &lt; 0)
            break;

        switch (s[0]) {
            case NONE:
                if (load_none(self) &lt; 0)
                    break;
                continue;

            case BININT:
                 if (load_binint(self) &lt; 0)
                     break;
                 continue;

            case BININT1:
                if (load_binint1(self) &lt; 0)
                    break;
                continue;

            case BININT2:
                if (load_binint2(self) &lt; 0)
                    break;
                continue;

            case INT:
                if (load_int(self) &lt; 0)
                    break;
                continue;

            case LONG:
                if (load_long(self) &lt; 0)
                    break;
                continue;

            case FLOAT:
                if (load_float(self) &lt; 0)
                    break;
                continue;

            case BINFLOAT:
                if (load_binfloat(self) &lt; 0)
                    break;
                continue;

            case BINSTRING:
                if (load_binstring(self) &lt; 0)
                    break;
                continue;

            case SHORT_BINSTRING:
                if (load_short_binstring(self) &lt; 0)
                    break;
                continue;

            case STRING:
                if (load_string(self) &lt; 0)
                    break;
                continue;

            case EMPTY_TUPLE:
                if (load_empty_tuple(self) &lt; 0)
                    break;
                continue;

            case TUPLE:
                if (load_tuple(self) &lt; 0)
                    break;
                continue;

            case EMPTY_LIST:
                if (load_empty_list(self) &lt; 0)
                    break;
                continue;

            case LIST:
                if (load_list(self) &lt; 0)
                    break;
                continue;

            case EMPTY_DICT:
                if (load_empty_dict(self) &lt; 0)
                    break;
                continue;

            case DICT:
                if (load_dict(self) &lt; 0)
                    break;
                continue;

            case OBJ:
                if (noload_obj(self) &lt; 0)
                    break;
                continue;

            case INST:
                if (noload_inst(self) &lt; 0)
                    break;
                continue;

            case GLOBAL:
                if (noload_global(self) &lt; 0)
                    break;
                continue;

            case APPEND:
                if (load_append(self) &lt; 0)
                    break;
                continue;

            case APPENDS:
                if (load_appends(self) &lt; 0)
                    break;
                continue;
   
            case BUILD:
                if (noload_build(self) &lt; 0)
                    break;
                continue;
  
            case DUP:
                if (load_dup(self) &lt; 0)
                    break;
                continue;

            case BINGET:
                if (load_binget(self) &lt; 0)
                    break;
                continue;

            case LONG_BINGET:
                if (load_long_binget(self) &lt; 0)
                    break;
                continue;
         
            case GET:
                if (load_get(self) &lt; 0)
                    break;
                continue;

            case MARK:
                if (load_mark(self) &lt; 0)
                    break;
                continue;

            case BINPUT:
                if (load_binput(self) &lt; 0)
                    break;
                continue;

            case LONG_BINPUT:
                if (load_long_binput(self) &lt; 0)
                    break;
                continue;
         
            case PUT:
                if (load_put(self) &lt; 0)
                    break;
                continue;

            case POP:
                if (load_pop(self) &lt; 0)
                    break;
                continue;

            case POP_MARK:
                if (load_pop_mark(self) &lt; 0)
                    break;
                continue;

            case SETITEM:
                if (load_setitem(self) &lt; 0)
                    break;
                continue;

            case SETITEMS:
                if (load_setitems(self) &lt; 0)
                    break;
                continue;

            case STOP:
                break;

            case PERSID:
                if (load_persid(self) &lt; 0)
                    break;
                continue;

            case BINPERSID:
                if (load_binpersid(self) &lt; 0)
                    break;
                continue;

            case REDUCE:
                if (noload_reduce(self) &lt; 0)
                    break;
                continue;

            default: 
                cPickle_ErrFormat(UnpicklingError, "invalid load key, '%s'.", 
                    "c", s[0]);
                return NULL;
        }

        break;
    }

    if ((err = PyErr_Occurred())) {
        if (err == PyExc_EOFError) {
            PyErr_SetNone(PyExc_EOFError);
        }    
        return NULL;
    }

    PDATA_POP(self-&gt;stack, val);    
    return val;
}
    

static PyObject *
Unpickler_load(Unpicklerobject *self, PyObject *args) {
    UNLESS (PyArg_ParseTuple(args, "")) 
        return NULL;

    return load(self);
}

static PyObject *
Unpickler_noload(Unpicklerobject *self, PyObject *args) {
    UNLESS (PyArg_ParseTuple(args, "")) 
        return NULL;

    return noload(self);
}


static struct PyMethodDef Unpickler_methods[] = {
  {"load",         (PyCFunction)Unpickler_load,   1,
   "load() -- Load a pickle"
  },
  {"noload",         (PyCFunction)Unpickler_noload,   1,
   "noload() -- not load a pickle, but go through most of the motions\n"
   "\n"
   "This function can be used to read past a pickle without instantiating\n"
   "any objects or importing any modules.  It can also be used to find all\n"
   "persistent references without instantiating any objects or importing\n"
   "any modules.\n"
  },
  {NULL,              NULL}           /* sentinel */
};


static Unpicklerobject *
newUnpicklerobject(PyObject *f) {
    Unpicklerobject *self;

    UNLESS (self = PyObject_NEW(Unpicklerobject, &amp;Unpicklertype))
        return NULL;

    self-&gt;file = NULL;
    self-&gt;arg = NULL;
    self-&gt;stack = (Pdata*)Pdata_New();
    self-&gt;pers_func = NULL;
    self-&gt;last_string = NULL;
    self-&gt;marks = NULL;
    self-&gt;num_marks = 0;
    self-&gt;marks_size = 0;
    self-&gt;buf_size = 0;
    self-&gt;read = NULL;
    self-&gt;readline = NULL;
    self-&gt;safe_constructors = NULL;
    self-&gt;find_class = NULL;

    UNLESS (self-&gt;memo = PyDict_New()) {
       Py_XDECREF((PyObject *)self);
       return NULL;
    }

    Py_INCREF(f);
    self-&gt;file = f;

    /* Set read, readline based on type of f */
    if (PyFile_Check(f)) {
        self-&gt;fp = PyFile_AsFile(f);
	if (self-&gt;fp == NULL) {
	    PyErr_SetString(PyExc_IOError, "input file closed");
	    return NULL;
	}
        self-&gt;read_func = read_file;
        self-&gt;readline_func = readline_file;
    }
    else if (PycStringIO_InputCheck(f)) {
        self-&gt;fp = NULL;
        self-&gt;read_func = read_cStringIO;
        self-&gt;readline_func = readline_cStringIO;
    }
    else {

        self-&gt;fp = NULL;
        self-&gt;read_func = read_other;
        self-&gt;readline_func = readline_other;

        UNLESS ((self-&gt;readline = PyObject_GetAttr(f, readline_str)) &amp;&amp;
            (self-&gt;read = PyObject_GetAttr(f, read_str))) {
            PyErr_Clear();
            PyErr_SetString( PyExc_TypeError, "argument must have 'read' and "
                "'readline' attributes" );
            goto err;
        }
    }

    if (PyEval_GetRestricted()) {
        /* Restricted execution, get private tables */
        PyObject *m;

        UNLESS (m=PyImport_Import(copy_reg_str)) goto err;
        self-&gt;safe_constructors=PyObject_GetAttr(m, safe_constructors_str);
        Py_DECREF(m);
        UNLESS (self-&gt;safe_constructors) goto err;
    }
    else {
        self-&gt;safe_constructors=safe_constructors;
        Py_INCREF(safe_constructors);
    }

    return self;

err:
    Py_DECREF((PyObject *)self);
    return NULL;
}


static PyObject *
get_Unpickler(PyObject *self, PyObject *args) {
    PyObject *file;
  
    UNLESS (PyArg_ParseTuple(args, "O", &amp;file))
        return NULL;
    return (PyObject *)newUnpicklerobject(file);
}


static void
Unpickler_dealloc(Unpicklerobject *self) {
    Py_XDECREF(self-&gt;readline);
    Py_XDECREF(self-&gt;read);
    Py_XDECREF(self-&gt;file);
    Py_XDECREF(self-&gt;memo);
    Py_XDECREF(self-&gt;stack);
    Py_XDECREF(self-&gt;pers_func);
    Py_XDECREF(self-&gt;arg);
    Py_XDECREF(self-&gt;last_string);
    Py_XDECREF(self-&gt;safe_constructors);

    if (self-&gt;marks) {
        free(self-&gt;marks);
    }

    if (self-&gt;buf_size) {
        free(self-&gt;buf);
    }
    
    PyMem_DEL(self);
}


static PyObject *
Unpickler_getattr(Unpicklerobject *self, char *name) {
    if (!strcmp(name, "persistent_load")) {
        if (!self-&gt;pers_func) {
            PyErr_SetString(PyExc_AttributeError, name);
            return NULL;
        }

        Py_INCREF(self-&gt;pers_func);
        return self-&gt;pers_func;
    }

    if (!strcmp(name, "find_global")) {
        if (!self-&gt;find_class) {
            PyErr_SetString(PyExc_AttributeError, name);
            return NULL;
        }

        Py_INCREF(self-&gt;find_class);
        return self-&gt;find_class;
    }

    if (!strcmp(name, "memo")) {
        if (!self-&gt;memo) {
            PyErr_SetString(PyExc_AttributeError, name);
            return NULL;
        }

        Py_INCREF(self-&gt;memo);
        return self-&gt;memo;
    }

    if (!strcmp(name, "UnpicklingError")) {
        Py_INCREF(UnpicklingError);
        return UnpicklingError;
    }

    return Py_FindMethod(Unpickler_methods, (PyObject *)self, name);
}


static int
Unpickler_setattr(Unpicklerobject *self, char *name, PyObject *value) {

    if (!strcmp(name, "persistent_load")) {
        Py_XDECREF(self-&gt;pers_func);
        self-&gt;pers_func = value;
        Py_XINCREF(value);
        return 0;
    }

    if (!strcmp(name, "find_global")) {
        Py_XDECREF(self-&gt;find_class);
        self-&gt;find_class = value;
        Py_XINCREF(value);
        return 0;
    }

    if (! value) {
        PyErr_SetString(PyExc_TypeError,
                        "attribute deletion is not supported");
        return -1;
    }

    if (strcmp(name, "memo") == 0) {
        if (! PyDict_Check(value)) {
          PyErr_SetString(PyExc_TypeError, "memo must be a dictionary");
          return -1;
        }
        Py_XDECREF(self-&gt;memo);
        self-&gt;memo = value;
        Py_INCREF(value);
        return 0;
    }

    PyErr_SetString(PyExc_AttributeError, name);
    return -1;
}


static PyObject *
cpm_dump(PyObject *self, PyObject *args) {
    PyObject *ob, *file, *res = NULL;
    Picklerobject *pickler = 0;
    int bin = 0;

    UNLESS (PyArg_ParseTuple(args, "OO|i", &amp;ob, &amp;file, &amp;bin))
        goto finally;

    UNLESS (pickler = newPicklerobject(file, bin))
        goto finally;

    if (dump(pickler, ob) &lt; 0)
        goto finally;

    Py_INCREF(Py_None);
    res = Py_None;

finally:
    Py_XDECREF(pickler);

    return res;
}


static PyObject *
cpm_dumps(PyObject *self, PyObject *args) {
    PyObject *ob, *file = 0, *res = NULL;
    Picklerobject *pickler = 0;
    int bin = 0;

    UNLESS (PyArg_ParseTuple(args, "O|i", &amp;ob, &amp;bin))
        goto finally;

    UNLESS (file = PycStringIO-&gt;NewOutput(128))
        goto finally;

    UNLESS (pickler = newPicklerobject(file, bin))
        goto finally;

    if (dump(pickler, ob) &lt; 0)
        goto finally;

    res = PycStringIO-&gt;cgetvalue(file);

finally:
    Py_XDECREF(pickler);
    Py_XDECREF(file);

    return res;
}  
  

static PyObject *
cpm_load(PyObject *self, PyObject *args) {
    Unpicklerobject *unpickler = 0;
    PyObject *ob, *res = NULL;

    UNLESS (PyArg_ParseTuple(args, "O", &amp;ob))
        goto finally;

    UNLESS (unpickler = newUnpicklerobject(ob))
        goto finally;

    res = load(unpickler);

finally:
    Py_XDECREF(unpickler);

    return res;
}


static PyObject *
cpm_loads(PyObject *self, PyObject *args) {
    PyObject *ob, *file = 0, *res = NULL;
    Unpicklerobject *unpickler = 0;

    UNLESS (PyArg_ParseTuple(args, "S", &amp;ob))
        goto finally;

    UNLESS (file = PycStringIO-&gt;NewInput(ob))
        goto finally;
  
    UNLESS (unpickler = newUnpicklerobject(file))
        goto finally;

    res = load(unpickler);

finally:
    Py_XDECREF(file);
    Py_XDECREF(unpickler);

    return res;
}


static char Unpicklertype__doc__[] = 
"Objects that know how to unpickle";

static PyTypeObject Unpicklertype = {
    PyObject_HEAD_INIT(NULL)
    0,                            /*ob_size*/
    "Unpickler",                  /*tp_name*/
    sizeof(Unpicklerobject),              /*tp_basicsize*/
    0,                            /*tp_itemsize*/
    /* methods */
    (destructor)Unpickler_dealloc,        /*tp_dealloc*/
    (printfunc)0,         /*tp_print*/
    (getattrfunc)Unpickler_getattr,       /*tp_getattr*/
    (setattrfunc)Unpickler_setattr,       /*tp_setattr*/
    (cmpfunc)0,           /*tp_compare*/
    (reprfunc)0,          /*tp_repr*/
    0,                    /*tp_as_number*/
    0,            /*tp_as_sequence*/
    0,            /*tp_as_mapping*/
    (hashfunc)0,          /*tp_hash*/
    (ternaryfunc)0,               /*tp_call*/
    (reprfunc)0,          /*tp_str*/

    /* Space for future expansion */
    0L,0L,0L,0L,
    Unpicklertype__doc__ /* Documentation string */
};

static struct PyMethodDef cPickle_methods[] = {
  {"dump",         (PyCFunction)cpm_dump,         1,
   "dump(object, file, [binary]) --"
   "Write an object in pickle format to the given file\n"
   "\n"
   "If the optional argument, binary, is provided and is true, then the\n"
   "pickle will be written in binary format, which is more space and\n"
   "computationally efficient. \n"
  },
  {"dumps",        (PyCFunction)cpm_dumps,        1,
   "dumps(object, [binary]) --"
   "Return a string containing an object in pickle format\n"
   "\n"
   "If the optional argument, binary, is provided and is true, then the\n"
   "pickle will be written in binary format, which is more space and\n"
   "computationally efficient. \n"
  },
  {"load",         (PyCFunction)cpm_load,         1,
   "load(file) -- Load a pickle from the given file"},
  {"loads",        (PyCFunction)cpm_loads,        1,
   "loads(string) -- Load a pickle from the given string"},
  {"Pickler",      (PyCFunction)get_Pickler,      1,
   "Pickler(file, [binary]) -- Create a pickler\n"
   "\n"
   "If the optional argument, binary, is provided and is true, then\n"
   "pickles will be written in binary format, which is more space and\n"
   "computationally efficient. \n"
  },
  {"Unpickler",    (PyCFunction)get_Unpickler,    1,
   "Unpickler(file) -- Create an unpickler"},
  { NULL, NULL }
};

static int
init_stuff(PyObject *module, PyObject *module_dict) {
    PyObject *string, *copy_reg, *t, *r;

#define INIT_STR(S) UNLESS(S ## _str=PyString_FromString(#S)) return -1;

    INIT_STR(__class__);
    INIT_STR(__getinitargs__);
    INIT_STR(__dict__);
    INIT_STR(__getstate__);
    INIT_STR(__setstate__);
    INIT_STR(__name__);
    INIT_STR(__main__);
    INIT_STR(__reduce__);
    INIT_STR(write);
    INIT_STR(__safe_for_unpickling__);
    INIT_STR(append);
    INIT_STR(read);
    INIT_STR(readline);
    INIT_STR(copy_reg);
    INIT_STR(dispatch_table);
    INIT_STR(safe_constructors);
    INIT_STR(__basicnew__);
    UNLESS (empty_str=PyString_FromString("")) return -1;

    UNLESS (copy_reg = PyImport_ImportModule("copy_reg"))
        return -1;

    /* These next few are special because we want to use different
       ones in restricted mode. */

    UNLESS (dispatch_table = PyObject_GetAttr(copy_reg, dispatch_table_str))
        return -1;

    UNLESS (safe_constructors = PyObject_GetAttr(copy_reg,
                                                safe_constructors_str))
        return -1;

    Py_DECREF(copy_reg);

    /* Down to here ********************************** */

    UNLESS (string = PyImport_ImportModule("string"))
        return -1;

    UNLESS (atol_func = PyObject_GetAttrString(string, "atol"))
        return -1;

    Py_DECREF(string);

    UNLESS (empty_tuple = PyTuple_New(0))
        return -1;

    /* Ugh */
    UNLESS (t=PyImport_ImportModule("__builtin__")) return -1;
    if (PyDict_SetItemString(module_dict, "__builtins__", t) &lt; 0)
      return -1;

    UNLESS (t=PyDict_New()) return -1;
    UNLESS (r=PyRun_String(
       "def __init__(self, *args): self.args=args\n\n"
       "def __str__(self):\n"
       "  return self.args and ('%s' % self.args[0]) or '(what)'\n",
       Py_file_input,
       module_dict, t) ) return -1;
    Py_DECREF(r);

    UNLESS (PickleError = PyErr_NewException("cPickle.PickleError", NULL, t))
      return -1;

    Py_DECREF(t);
    

    UNLESS (PicklingError = PyErr_NewException("cPickle.PicklingError", 
					       PickleError, NULL))
      return -1;

    UNLESS (t=PyDict_New()) return -1;
    UNLESS (r=PyRun_String(
       "def __init__(self, *args): self.args=args\n\n"
       "def __str__(self):\n"
       "  a=self.args\n"
       "  a=a and type(a[0]) or '(what)'\n"
       "  return 'Cannot pickle %s objects' % a\n"
       , Py_file_input,
       module_dict, t) ) return -1;
    Py_DECREF(r);

    UNLESS (UnpickleableError = PyErr_NewException(
                "cPickle.UnpickleableError", PicklingError, t))
      return -1;

    Py_DECREF(t);

    UNLESS (UnpicklingError = PyErr_NewException("cPickle.UnpicklingError", 
   					         PickleError, NULL))
      return -1;

    if (PyDict_SetItemString(module_dict, "PickleError", 
        PickleError) &lt; 0)
        return -1;

    if (PyDict_SetItemString(module_dict, "PicklingError", 
        PicklingError) &lt; 0)
        return -1;

    if (PyDict_SetItemString(module_dict, "UnpicklingError",
        UnpicklingError) &lt; 0)
        return -1;

    if (PyDict_SetItemString(module_dict, "UnpickleableError",
        UnpickleableError) &lt; 0)
        return -1;

    UNLESS (BadPickleGet = PyString_FromString("cPickle.BadPickleGet"))
        return -1;

    if (PyDict_SetItemString(module_dict, "BadPickleGet",
        BadPickleGet) &lt; 0)
        return -1;

    PycString_IMPORT;
 
    return 0;
}

#ifndef DL_EXPORT	/* declarations for DLL import/export */
#define DL_EXPORT(RTYPE) RTYPE
#endif
DL_EXPORT(void)
initcPickle() {
    PyObject *m, *d;
    PyObject *format_version;
    PyObject *compatible_formats;

    Picklertype.ob_type = &amp;PyType_Type;
    Unpicklertype.ob_type = &amp;PyType_Type;
    PdataType.ob_type = &amp;PyType_Type;

    /* Create the module and add the functions */
    m = Py_InitModule4("cPickle", cPickle_methods,
                     cPickle_module_documentation,
                     (PyObject*)NULL,PYTHON_API_VERSION);

    /* Add some symbolic constants to the module */
    d = PyModule_GetDict(m);

    format_version = PyString_FromString("1.3");
    compatible_formats = Py_BuildValue("[sss]", "1.0", "1.1", "1.2");

    PyDict_SetItemString(d, "format_version", format_version);
    PyDict_SetItemString(d, "compatible_formats", compatible_formats);
    Py_XDECREF(format_version);
    Py_XDECREF(compatible_formats);

    init_stuff(m, d);
}
</t>
<t tx="ekr.20040104202012">_data={

'GMT':      ('GMT',      0, 1, [], '', [(0, 0, 0)],      'GMT\000'),
'GMT+0':    ('GMT+0',    0, 1, [], '', [(0, 0, 0)],      'GMT+0000\000'),
'GMT+1':    ('GMT+1',    0, 1, [], '', [(3600, 0, 0)],   'GMT+0100\000'),
'GMT+2':    ('GMT+2',    0, 1, [], '', [(7200, 0, 0)],   'GMT+0200\000'),
'GMT+3':    ('GMT+3',    0, 1, [], '', [(10800, 0, 0)],  'GMT+0300\000'),
'GMT+4':    ('GMT+4',    0, 1, [], '', [(14400, 0, 0)],  'GMT+0400\000'),
'GMT+5':    ('GMT+5',    0, 1, [], '', [(18000, 0, 0)],  'GMT+0500\000'),
'GMT+6':    ('GMT+6',    0, 1, [], '', [(21600, 0, 0)],  'GMT+0600\000'),
'GMT+7':    ('GMT+7',    0, 1, [], '', [(25200, 0, 0)],  'GMT+0700\000'),
'GMT+8':    ('GMT+8',    0, 1, [], '', [(28800, 0, 0)],  'GMT+0800\000'),
'GMT+9':    ('GMT+9',    0, 1, [], '', [(32400, 0, 0)],  'GMT+0900\000'),
'GMT+10':   ('GMT+10',   0, 1, [], '', [(36000, 0, 0)],  'GMT+1000\000'),
'GMT+11':   ('GMT+11',   0, 1, [], '', [(39600, 0, 0)],  'GMT+1100\000'),
'GMT+12':   ('GMT+12',   0, 1, [], '', [(43200, 0, 0)],  'GMT+1200\000'),
'GMT+13':   ('GMT+13',   0, 1, [], '', [(46800, 0, 0)],  'GMT+1300\000'),

'GMT-1':    ('GMT-1',    0, 1, [], '', [(-3600, 0, 0)],  'GMT-0100\000'),
'GMT-2':    ('GMT-2',    0, 1, [], '', [(-7200, 0, 0)],  'GMT-0200\000'),
'GMT-3':    ('GMT-3',    0, 1, [], '', [(-10800, 0, 0)], 'GMT-0300\000'),
'GMT-4':    ('GMT-4',    0, 1, [], '', [(-14400, 0, 0)], 'GMT-0400\000'),
'GMT-5':    ('GMT-5',    0, 1, [], '', [(-18000, 0, 0)], 'GMT-0500\000'),
'GMT-6':    ('GMT-6',    0, 1, [], '', [(-21600, 0, 0)], 'GMT-0600\000'),
'GMT-7':    ('GMT-7',    0, 1, [], '', [(-25200, 0, 0)], 'GMT-0700\000'),
'GMT-8':    ('GMT-8',    0, 1, [], '', [(-28800, 0, 0)], 'GMT-0800\000'),
'GMT-9':    ('GMT-9',    0, 1, [], '', [(-32400, 0, 0)], 'GMT-0900\000'),
'GMT-10':   ('GMT-10',   0, 1, [], '', [(-36000, 0, 0)], 'GMT-1000\000'),
'GMT-11':   ('GMT-11',   0, 1, [], '', [(-39600, 0, 0)], 'GMT-1100\000'),
'GMT-12':   ('GMT-12',   0, 1, [], '', [(-43200, 0, 0)], 'GMT-1200\000'),

'GMT+0130': ('GMT+0130', 0, 1, [], '', [(5400,  0, 0)],  'GMT+0130\000'),
'GMT+0230': ('GMT+0230', 0, 1, [], '', [(9000,  0, 0)],  'GMT+0230\000'),
'GMT+0330': ('GMT+0330', 0, 1, [], '', [(12600, 0, 0)],  'GMT+0330\000'),
'GMT+0430': ('GMT+0430', 0, 1, [], '', [(16200, 0, 0)],  'GMT+0430\000'),
'GMT+0530': ('GMT+0530', 0, 1, [], '', [(19800, 0, 0)],  'GMT+0530\000'),
'GMT+0630': ('GMT+0630', 0, 1, [], '', [(23400, 0, 0)],  'GMT+0630\000'),
'GMT+0730': ('GMT+0730', 0, 1, [], '', [(27000, 0, 0)],  'GMT+0730\000'),
'GMT+0830': ('GMT+0830', 0, 1, [], '', [(30600, 0, 0)],  'GMT+0830\000'),
'GMT+0930': ('GMT+0930', 0, 1, [], '', [(34200, 0, 0)],  'GMT+0930\000'),
'GMT+1030': ('GMT+1030', 0, 1, [], '', [(37800, 0, 0)],  'GMT+1030\000'),
'GMT+1130': ('GMT+1130', 0, 1, [], '', [(41400, 0, 0)],  'GMT+1130\000'),
'GMT+1230': ('GMT+1230', 0, 1, [], '', [(45000, 0, 0)],  'GMT+1230\000'),

'GMT-0130': ('GMT-0130', 0, 1, [], '', [(-5400,  0, 0)], 'GMT-0130\000'),
'GMT-0230': ('GMT-0230', 0, 1, [], '', [(-9000,  0, 0)], 'GMT-0230\000'),
'GMT-0330': ('GMT-0330', 0, 1, [], '', [(-12600, 0, 0)], 'GMT-0330\000'),
'GMT-0430': ('GMT-0430', 0, 1, [], '', [(-16200, 0, 0)], 'GMT-0430\000'),
'GMT-0530': ('GMT-0530', 0, 1, [], '', [(-19800, 0, 0)], 'GMT-0530\000'),
'GMT-0630': ('GMT-0630', 0, 1, [], '', [(-23400, 0, 0)], 'GMT-0630\000'),
'GMT-0730': ('GMT-0730', 0, 1, [], '', [(-27000, 0, 0)], 'GMT-0730\000'),
'GMT-0830': ('GMT-0830', 0, 1, [], '', [(-30600, 0, 0)], 'GMT-0830\000'),
'GMT-0930': ('GMT-0930', 0, 1, [], '', [(-34200, 0, 0)], 'GMT-0930\000'),
'GMT-1030': ('GMT-1030', 0, 1, [], '', [(-37800, 0, 0)], 'GMT-1030\000'),
'GMT-1130': ('GMT-1130', 0, 1, [], '', [(-41400, 0, 0)], 'GMT-1130\000'),
'GMT-1230': ('GMT-1230', 0, 1, [], '', [(-45000, 0, 0)], 'GMT-1230\000'),


'US/Indiana-Starke': ('US/Indiana-Starke', 56, 4, [-1633276800, -1615136400, -1601827200, -1583686800, -880214400, -765392400, -84384000, -68662800, -52934400, -37213200, -21484800, -5763600, 9964800, 25686000, 41414400, 57740400, 73468800, 89190000, 104918400, 120639600, 126691200, 152089200, 162374400, 183538800, 199267200, 215593200, 230716800, 247042800, 262771200, 278492400, 294220800, 309942000, 325670400, 341391600, 357120000, 372841200, 388569600, 404895600, 420019200, 436345200, 452073600, 467794800, 483523200, 499244400, 514972800, 530694000, 544608000, 562143600, 576057600, 594198000, 607507200, 625647600, 638956800, 657097200, 671011200, 688546800], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\003', [(-18000, 1, 0), (-21600, 0, 4), (-18000, 1, 8), (-18000, 0, 12)], 'CDT\000CST\000CWT\000EST\000'), 'Japan': ('Japan', 0, 1, [], '', [(32400, 0, 0)], 'JST\000'), 'Cuba': ('Cuba', 118, 2, [290581200, 308721600, 322030800, 340171200, 358318800, 371620800, 389768400, 403070400, 421218000, 434520000, 453272400, 466574400, 484722000, 498024000, 516171600, 529473600, 547621200, 560923200, 579070800, 592372800, 611125200, 623822400, 642574800, 655876800, 674024400, 687326400, 705474000, 718776000, 736923600, 750225600, 768373200, 781675200, 800427600, 813124800, 831877200, 845179200, 863326800, 876628800, 894776400, 908078400, 926226000, 939528000, 958280400, 970977600, 989730000, 1003032000, 1021179600, 1034481600, 1052629200, 1065931200, 1084078800, 1097380800, 1115528400, 1128830400, 1147582800, 1160280000, 1179032400, 1192334400, 1210482000, 1223784000, 1241931600, 1255233600, 1273381200, 1286683200, 1304830800, 1318132800, 1336885200, 1350187200, 1368334800, 1381636800, 1399784400, 1413086400, 1431234000, 1444536000, 1462683600, 1475985600, 1494738000, 1507435200, 1526187600, 1539489600, 1557637200, 1570939200, 1589086800, 1602388800, 1620536400, 1633838400, 1651986000, 1665288000, 1684040400, 1696737600, 1715490000, 1728792000, 1746939600, 1760241600, 1778389200, 1791691200, 1809838800, 1823140800, 1841893200, 1854590400, 1873342800, 1886644800, 1904792400, 1918094400, 1936242000, 1949544000, 1967691600, 1980993600, 1999141200, 2012443200, 2031195600, 2043892800, 2062645200, 2075947200, 2094094800, 2107396800, 2125544400, 2138846400], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 1, 0), (-18000, 0, 4)], 'CDT\000CST\000'), 'Singapore': ('Singapore', 0, 1, [], '', [(28800, 0, 0)], 'SST\000'), 'Chile/Continental': ('Chile/Continental', 121, 2, [245217600, 258519600, 276667200, 289969200, 308721600, 321418800, 340171200, 352868400, 371620800, 384922800, 403070400, 416372400, 434520000, 447822000, 466574400, 479271600, 498024000, 510721200, 529473600, 542170800, 560923200, 574225200, 592372800, 605674800, 623822400, 637124400, 655876800, 668574000, 687326400, 700023600, 718776000, 732078000, 750225600, 763527600, 781675200, 794977200, 813124800, 826426800, 845179200, 857876400, 876628800, 889326000, 908078400, 921380400, 939528000, 952830000, 970977600, 984279600, 1003032000, 1015729200, 1034481600, 1047178800, 1065931200, 1079233200, 1097380800, 1110682800, 1128830400, 1142132400, 1160280000, 1173582000, 1192334400, 1205031600, 1223784000, 1236481200, 1255233600, 1268535600, 1286683200, 1299985200, 1318132800, 1331434800, 1350187200, 1362884400, 1381636800, 1394334000, 1413086400, 1425783600, 1444536000, 1457838000, 1475985600, 1489287600, 1507435200, 1520737200, 1539489600, 1552186800, 1570939200, 1583636400, 1602388800, 1615690800, 1633838400, 1647140400, 1665288000, 1678590000, 1696737600, 1710039600, 1728792000, 1741489200, 1760241600, 1772938800, 1791691200, 1804993200, 1823140800, 1836442800, 1854590400, 1867892400, 1886644800, 1899342000, 1918094400, 1930791600, 1949544000, 1962846000, 1980993600, 1994295600, 2012443200, 2025745200, 2043892800, 2057194800, 2075947200, 2088644400, 2107396800, 2120094000, 2138846400], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000', [(-10800, 1, 0), (-14400, 0, 4)], 'CDT\000CST\000'), 'Brazil/West': ('Brazil/West', 101, 2, [561967200, 571640400, 593416800, 603090000, 625557600, 634539600, 656920800, 665989200, 688370400, 697438800, 719820000, 729493200, 751269600, 760942800, 782719200, 792392400, 814860000, 823842000, 846223200, 855291600, 877672800, 887432400, 909122400, 918795600, 940572000, 950245200, 972712800, 981694800, 1004076000, 1013144400, 1035525600, 1044594000, 1066975200, 1076734800, 1098424800, 1108098000, 1129874400, 1139547600, 1162015200, 1170997200, 1193378400, 1202446800, 1224828000, 1234587600, 1256277600, 1265950800, 1287727200, 1297400400, 1319176800, 1328850000, 1351231200, 1360299600, 1382680800, 1391749200, 1414130400, 1423890000, 1445580000, 1455253200, 1477029600, 1486702800, 1509170400, 1518152400, 1540533600, 1549602000, 1571983200, 1581051600, 1603432800, 1613106000, 1634882400, 1644555600, 1666332000, 1676005200, 1698472800, 1707454800, 1729836000, 1738904400, 1761285600, 1771045200, 1792735200, 1802408400, 1824184800, 1833858000, 1856325600, 1865307600, 1887688800, 1896757200, 1919138400, 1928206800, 1950588000, 1960347600, 1982037600, 1991710800, 2013487200, 2023160400, 2045628000, 2054610000, 2076991200, 2086059600, 2108440800, 2118200400, 2139890400], '\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 0, 0), (-10800, 1, 4)], 'WST\000WDT\000'), 'Mexico/BajaSur': ('Mexico/BajaSur', 0, 1, [], '', [(-25200, 0, 0)], 'MST\000'),  'Israel': ('Israel', 42, 2, [609890400, 622587600, 640735200, 653432400, 670975200, 683672400, 704239200, 716936400, 735084000, 747781200, 765324000, 778021200, 798588000, 811285200, 829432800, 842130000, 862696800, 875394000, 892936800, 905634000, 923781600, 936478800, 957045600, 969742800, 987285600, 999982800, 1018130400, 1030827600, 1051394400, 1064091600, 1082239200, 1094936400, 1114898400, 1127595600, 1145743200, 1158440400, 1176588000, 1189285200, 1209247200, 1221944400, 1240092000, 1252789200], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(10800, 1, 0), (7200, 0, 4)], 'IDT\000IST\000'),  'Canada/Newfoundland': ('Canada/Newfoundland', 138, 2, [-21493800, -5772600, 9955800, 25677000, 41405400, 57731400, 73459800, 89181000, 104909400, 120630600, 136359000, 152080200, 167808600, 183529800, 199258200, 215584200, 230707800, 247033800, 262762200, 278483400, 294211800, 309933000, 325661400, 341382600, 357111000, 372832200, 388560600, 404886600, 420010200, 436336200, 452064600, 467785800, 483514200, 499235400, 514963800, 530685000, 544599000, 562134600, 576048600, 594189000, 607498200, 625638600, 638947800, 657088200, 671002200, 688537800, 702451800, 719987400, 733901400, 752041800, 765351000, 783491400, 796800600, 814941000, 828855000, 846390600, 860304600, 877840200, 891754200, 909289800, 923203800, 941344200, 954653400, 972793800, 986103000, 1004243400, 1018157400, 1035693000, 1049607000, 1067142600, 1081056600, 1099197000, 1112506200, 1130646600, 1143955800, 1162096200, 1175405400, 1193545800, 1207459800, 1224995400, 1238909400, 1256445000, 1270359000, 1288499400, 1301808600, 1319949000, 1333258200, 1351398600, 1365312600, 1382848200, 1396762200, 1414297800, 1428211800, 1445747400, 1459661400, 1477801800, 1491111000, 1509251400, 1522560600, 1540701000, 1554615000, 1572150600, 1586064600, 1603600200, 1617514200, 1635654600, 1648963800, 1667104200, 1680413400, 1698553800, 1712467800, 1730003400, 1743917400, 1761453000, 1775367000, 1792902600, 1806816600, 1824957000, 1838266200, 1856406600, 1869715800, 1887856200, 1901770200, 1919305800, 1933219800, 1950755400, 1964669400, 1982809800, 1996119000, 2014259400, 2027568600, 2045709000, 2059018200, 2077158600, 2091072600, 2108608200, 2122522200, 2140057800], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-9000, 1, 0), (-12600, 0, 4)], 'NDT\000NST\000'), 'GB-Eire': ('GB-Eire', 241, 4, [-1697238000, -1680476400, -1664146800, -1650150000, -1633906800, -1617490800, -1601852400, -1586041200, -1570402800, -1552172400, -1538348400, -1522537200, -1507503600, -1490569200, -1473634800, -1458342000, -1441321200, -1428879600, -1410735600, -1396220400, -1379286000, -1364770800, -1347836400, -1333321200, -1316386800, -1301266800, -1284332400, -1269817200, -1252882800, -1238367600, -1221433200, -1206918000, -1189983600, -1175468400, -1158534000, -1144018800, -1127084400, -1111964400, -1095030000, -1080514800, -1063580400, -1049065200, -1032130800, -1017615600, -1000681200, -986166000, -969231600, -950482800, -942015600, -904518000, -896050800, -875487600, -864601200, -844038000, -832546800, -812588400, -798073200, -781052400, -772066800, -764809200, -748479600, -733359600, -719449200, -717030000, -706748400, -699490800, -687999600, -668041200, -654735600, -636591600, -622076400, -605746800, -590626800, -574297200, -558572400, -542242800, -527122800, -512607600, -496278000, -481158000, -464223600, -449708400, -432774000, -417654000, -401324400, -386204400, -369270000, -354754800, -337820400, -323305200, -306975600, -291855600, -276735600, -257986800, -245286000, -226537200, -213231600, -195087600, -182386800, -163638000, -150937200, -132188400, -119487600, -100738800, -88038000, -68684400, -59007600, -37238400, 57715200, 69814800, 89168400, 101264400, 120618000, 132714000, 152067600, 164163600, 183517200, 196218000, 214966800, 227667600, 246416400, 259117200, 278470800, 290566800, 309920400, 322016400, 341370000, 354675600, 372819600, 386125200, 404269200, 417574800, 435718800, 449024400, 467773200, 481078800, 499222800, 512528400, 530672400, 543978000, 562122000, 575427600, 593571600, 606877200, 625626000, 638326800, 657075600, 670381200, 688525200, 701830800, 719974800, 733280400, 751424400, 764730000, 782874000, 796179600, 814928400, 828234000, 846378000, 859683600, 877827600, 891133200, 909277200, 922582800, 940726800, 954032400, 972781200, 985482000, 1004230800, 1017536400, 1035680400, 1048986000, 1067130000, 1080435600, 1098579600, 1111885200, 1130029200, 1143334800, 1162083600, 1174784400, 1193533200, 1206838800, 1224982800, 1238288400, 1256432400, 1269738000, 1287882000, 1301187600, 1319331600, 1332637200, 1351386000, 1364691600, 1382835600, 1396141200, 1414285200, 1427590800, 1445734800, 1459040400, 1477184400, 1490490000, 1509238800, 1521939600, 1540688400, 1553994000, 1572138000, 1585443600, 1603587600, 1616893200, 1635037200, 1648342800, 1666486800, 1679792400, 1698541200, 1711846800, 1729990800, 1743296400, 1761440400, 1774746000, 1792890000, 1806195600, 1824339600, 1837645200, 1856394000, 1869094800, 1887843600, 1901149200, 1919293200, 1932598800, 1950742800, 1964048400, 1982192400, 1995498000, 2013642000, 2026947600, 2045696400, 2058397200, 2077146000, 2090451600, 2108595600, 2121901200, 2140045200], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\002\000\002\000\002\000\001\000\001\000\002\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\003\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(3600, 1, 0), (0, 0, 4), (7200, 1, 8), (3600, 0, 0)], 'BST\000GMT\000DST\000'), 'Hongkong': ('Hongkong', 0, 1, [], '', [(28800, 0, 0)], 'HKT\000'), 'Turkey': ('Turkey', 104, 2, [512517600, 528238800, 543967200, 559688400, 575416800, 591138000, 606866400, 622587600, 638316000, 654642000, 670370400, 686091600, 701820000, 717541200, 733269600, 748990800, 764719200, 780440400, 796168800, 811890000, 828223200, 843944400, 859672800, 875394000, 891122400, 906843600, 922572000, 938293200, 954021600, 969742800, 985471200, 1001797200, 1017525600, 1033246800, 1048975200, 1064696400, 1080424800, 1096146000, 1111874400, 1127595600, 1143324000, 1159045200, 1174773600, 1191099600, 1206828000, 1222549200, 1238277600, 1253998800, 1269727200, 1285448400, 1301176800, 1316898000, 1332626400, 1348952400, 1364680800, 1380402000, 1396130400, 1411851600, 1427580000, 1443301200, 1459029600, 1474750800, 1490479200, 1506200400, 1521928800, 1538254800, 1553983200, 1569704400, 1585432800, 1601154000, 1616882400, 1632603600, 1648332000, 1664053200, 1679781600, 1695502800, 1711836000, 1727557200, 1743285600, 1759006800, 1774735200, 1790456400, 1806184800, 1821906000, 1837634400, 1853355600, 1869084000, 1885410000, 1901138400, 1916859600, 1932588000, 1948309200, 1964037600, 1979758800, 1995487200, 2011208400, 2026936800, 2042658000, 2058386400, 2074712400, 2090440800, 2106162000, 2121890400, 2137611600], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(14400, 1, 0), (10800, 0, 8)], 'EET DST\000EET\000'), 'US/Samoa': ('US/Samoa', 2, 3, [-86878800, 439038000], '\001\002', [(-39600, 0, 0), (-39600, 0, 4), (-39600, 0, 8)], 'NST\000BST\000SST\000'), 'Iran': ('Iran', 100, 2, [575418600, 590535000, 606868200, 621984600, 638317800, 653434200, 670372200, 684883800, 701821800, 716938200, 733271400, 748387800, 764721000, 779837400, 796170600, 811287000, 828225000, 842736600, 859674600, 874791000, 891124200, 906240600, 922573800, 937690200, 954023400, 969139800, 985473000, 1000589400, 1017527400, 1032039000, 1048977000, 1064093400, 1080426600, 1095543000, 1111876200, 1126992600, 1143325800, 1158442200, 1174775400, 1189891800, 1206829800, 1221946200, 1238279400, 1253395800, 1269729000, 1284845400, 1301178600, 1316295000, 1332628200, 1347744600, 1364682600, 1379194200, 1396132200, 1411248600, 1427581800, 1442698200, 1459031400, 1474147800, 1490481000, 1505597400, 1521930600, 1537047000, 1553985000, 1568496600, 1585434600, 1600551000, 1616884200, 1632000600, 1648333800, 1663450200, 1679783400, 1694899800, 1711837800, 1726349400, 1743287400, 1758403800, 1774737000, 1789853400, 1806186600, 1821303000, 1837636200, 1852752600, 1869085800, 1884202200, 1901140200, 1915651800, 1932589800, 1947706200, 1964039400, 1979155800, 1995489000, 2010605400, 2026938600, 2042055000, 2058388200, 2073504600, 2090442600, 2105559000, 2121892200, 2137008600], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(16200, 1, 0), (12600, 0, 4)], 'IDT\000IST\000'), 'US/Pacific': ('US/Pacific', 148, 3, [-1633269600, -1615129200, -1601820000, -1583679600, -880207200, -765385200, -84376800, -68655600, -52927200, -37206000, -21477600, -5756400, 9972000, 25693200, 41421600, 57747600, 73476000, 89197200, 104925600, 120646800, 126698400, 152096400, 162381600, 183546000, 199274400, 215600400, 230724000, 247050000, 262778400, 278499600, 294228000, 309949200, 325677600, 341398800, 357127200, 372848400, 388576800, 404902800, 420026400, 436352400, 452080800, 467802000, 483530400, 499251600, 514980000, 530701200, 544615200, 562150800, 576064800, 594205200, 607514400, 625654800, 638964000, 657104400, 671018400, 688554000, 702468000, 720003600, 733917600, 752058000, 765367200, 783507600, 796816800, 814957200, 828871200, 846406800, 860320800, 877856400, 891770400, 909306000, 923220000, 941360400, 954669600, 972810000, 986119200, 1004259600, 1018173600, 1035709200, 1049623200, 1067158800, 1081072800, 1099213200, 1112522400, 1130662800, 1143972000, 1162112400, 1175421600, 1193562000, 1207476000, 1225011600, 1238925600, 1256461200, 1270375200, 1288515600, 1301824800, 1319965200, 1333274400, 1351414800, 1365328800, 1382864400, 1396778400, 1414314000, 1428228000, 1445763600, 1459677600, 1477818000, 1491127200, 1509267600, 1522576800, 1540717200, 1554631200, 1572166800, 1586080800, 1603616400, 1617530400, 1635670800, 1648980000, 1667120400, 1680429600, 1698570000, 1712484000, 1730019600, 1743933600, 1761469200, 1775383200, 1792918800, 1806832800, 1824973200, 1838282400, 1856422800, 1869732000, 1887872400, 1901786400, 1919322000, 1933236000, 1950771600, 1964685600, 1982826000, 1996135200, 2014275600, 2027584800, 2045725200, 2059034400, 2077174800, 2091088800, 2108624400, 2122538400, 2140074000], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-25200, 1, 0), (-28800, 0, 4), (-25200, 1, 8)], 'PDT\000PST\000PWT\000'), 'Brazil/East': ('Brazil/East', 101, 2, [561963600, 571636800, 593413200, 603086400, 625554000, 634536000, 656917200, 665985600, 688366800, 697435200, 719816400, 729489600, 751266000, 760939200, 782715600, 792388800, 814856400, 823838400, 846219600, 855288000, 877669200, 887428800, 909118800, 918792000, 940568400, 950241600, 972709200, 981691200, 1004072400, 1013140800, 1035522000, 1044590400, 1066971600, 1076731200, 1098421200, 1108094400, 1129870800, 1139544000, 1162011600, 1170993600, 1193374800, 1202443200, 1224824400, 1234584000, 1256274000, 1265947200, 1287723600, 1297396800, 1319173200, 1328846400, 1351227600, 1360296000, 1382677200, 1391745600, 1414126800, 1423886400, 1445576400, 1455249600, 1477026000, 1486699200, 1509166800, 1518148800, 1540530000, 1549598400, 1571979600, 1581048000, 1603429200, 1613102400, 1634878800, 1644552000, 1666328400, 1676001600, 1698469200, 1707451200, 1729832400, 1738900800, 1761282000, 1771041600, 1792731600, 1802404800, 1824181200, 1833854400, 1856322000, 1865304000, 1887685200, 1896753600, 1919134800, 1928203200, 1950584400, 1960344000, 1982034000, 1991707200, 2013483600, 2023156800, 2045624400, 2054606400, 2076987600, 2086056000, 2108437200, 2118196800, 2139886800], '\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-10800, 0, 0), (-7200, 1, 4)], 'EST\000EDT\000'), 'Chile/EasterIsland': ('Chile/EasterIsland', 121, 2, [245224800, 258526800, 276674400, 289976400, 308728800, 321426000, 340178400, 352875600, 371628000, 384930000, 403077600, 416379600, 434527200, 447829200, 466581600, 479278800, 498031200, 510728400, 529480800, 542178000, 560930400, 574232400, 592380000, 605682000, 623829600, 637131600, 655884000, 668581200, 687333600, 700030800, 718783200, 732085200, 750232800, 763534800, 781682400, 794984400, 813132000, 826434000, 845186400, 857883600, 876636000, 889333200, 908085600, 921387600, 939535200, 952837200, 970984800, 984286800, 1003039200, 1015736400, 1034488800, 1047186000, 1065938400, 1079240400, 1097388000, 1110690000, 1128837600, 1142139600, 1160287200, 1173589200, 1192341600, 1205038800, 1223791200, 1236488400, 1255240800, 1268542800, 1286690400, 1299992400, 1318140000, 1331442000, 1350194400, 1362891600, 1381644000, 1394341200, 1413093600, 1425790800, 1444543200, 1457845200, 1475992800, 1489294800, 1507442400, 1520744400, 1539496800, 1552194000, 1570946400, 1583643600, 1602396000, 1615698000, 1633845600, 1647147600, 1665295200, 1678597200, 1696744800, 1710046800, 1728799200, 1741496400, 1760248800, 1772946000, 1791698400, 1805000400, 1823148000, 1836450000, 1854597600, 1867899600, 1886652000, 1899349200, 1918101600, 1930798800, 1949551200, 1962853200, 1981000800, 1994302800, 2012450400, 2025752400, 2043900000, 2057202000, 2075954400, 2088651600, 2107404000, 2120101200, 2138853600], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000', [(-18000, 1, 0), (-21600, 0, 4)], 'EDT\000EST\000'), 'Brazil/DeNoronha': ('Brazil/DeNoronha', 101, 2, [561960000, 571633200, 593409600, 603082800, 625550400, 634532400, 656913600, 665982000, 688363200, 697431600, 719812800, 729486000, 751262400, 760935600, 782712000, 792385200, 814852800, 823834800, 846216000, 855284400, 877665600, 887425200, 909115200, 918788400, 940564800, 950238000, 972705600, 981687600, 1004068800, 1013137200, 1035518400, 1044586800, 1066968000, 1076727600, 1098417600, 1108090800, 1129867200, 1139540400, 1162008000, 1170990000, 1193371200, 1202439600, 1224820800, 1234580400, 1256270400, 1265943600, 1287720000, 1297393200, 1319169600, 1328842800, 1351224000, 1360292400, 1382673600, 1391742000, 1414123200, 1423882800, 1445572800, 1455246000, 1477022400, 1486695600, 1509163200, 1518145200, 1540526400, 1549594800, 1571976000, 1581044400, 1603425600, 1613098800, 1634875200, 1644548400, 1666324800, 1675998000, 1698465600, 1707447600, 1729828800, 1738897200, 1761278400, 1771038000, 1792728000, 1802401200, 1824177600, 1833850800, 1856318400, 1865300400, 1887681600, 1896750000, 1919131200, 1928199600, 1950580800, 1960340400, 1982030400, 1991703600, 2013480000, 2023153200, 2045620800, 2054602800, 2076984000, 2086052400, 2108433600, 2118193200, 2139883200], '\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-7200, 0, 0), (-3600, 1, 4)], 'FST\000FDT\000'), 'US/Aleutian': ('US/Aleutian', 149, 5, [-1633262400, -1615122000, -1601812800, -1583672400, -880200000, -765378000, -84369600, -68648400, -52920000, -37198800, -21470400, -5749200, 9979200, 25700400, 41428800, 57754800, 73483200, 89204400, 104932800, 120654000, 126705600, 152103600, 162388800, 183553200, 199281600, 215607600, 230731200, 247057200, 262785600, 278506800, 294235200, 309956400, 325684800, 341406000, 357134400, 372855600, 388584000, 404910000, 420033600, 436359600, 439034400, 452088000, 467809200, 483537600, 499258800, 514987200, 530708400, 544622400, 562158000, 576072000, 594212400, 607521600, 625662000, 638971200, 657111600, 671025600, 688561200, 702475200, 720010800, 733924800, 752065200, 765374400, 783514800, 796824000, 814964400, 828878400, 846414000, 860328000, 877863600, 891777600, 909313200, 923227200, 941367600, 954676800, 972817200, 986126400, 1004266800, 1018180800, 1035716400, 1049630400, 1067166000, 1081080000, 1099220400, 1112529600, 1130670000, 1143979200, 1162119600, 1175428800, 1193569200, 1207483200, 1225018800, 1238932800, 1256468400, 1270382400, 1288522800, 1301832000, 1319972400, 1333281600, 1351422000, 1365336000, 1382871600, 1396785600, 1414321200, 1428235200, 1445770800, 1459684800, 1477825200, 1491134400, 1509274800, 1522584000, 1540724400, 1554638400, 1572174000, 1586088000, 1603623600, 1617537600, 1635678000, 1648987200, 1667127600, 1680436800, 1698577200, 1712491200, 1730026800, 1743940800, 1761476400, 1775390400, 1792926000, 1806840000, 1824980400, 1838289600, 1856430000, 1869739200, 1887879600, 1901793600, 1919329200, 1933243200, 1950778800, 1964692800, 1982833200, 1996142400, 2014282800, 2027592000, 2045732400, 2059041600, 2077182000, 2091096000, 2108631600, 2122545600, 2140081200], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003\004\003', [(-32400, 1, 0), (-36000, 0, 5), (-32400, 1, 10), (-36000, 0, 15), (-32400, 1, 20)], 'AHDT\000AHST\000AHWT\000HAST\000HADT\000'), 'Canada/Atlantic': ('Canada/Atlantic', 138, 2, [-21492000, -5770800, 9957600, 25678800, 41407200, 57733200, 73461600, 89182800, 104911200, 120632400, 136360800, 152082000, 167810400, 183531600, 199260000, 215586000, 230709600, 247035600, 262764000, 278485200, 294213600, 309934800, 325663200, 341384400, 357112800, 372834000, 388562400, 404888400, 420012000, 436338000, 452066400, 467787600, 483516000, 499237200, 514965600, 530686800, 544600800, 562136400, 576050400, 594190800, 607500000, 625640400, 638949600, 657090000, 671004000, 688539600, 702453600, 719989200, 733903200, 752043600, 765352800, 783493200, 796802400, 814942800, 828856800, 846392400, 860306400, 877842000, 891756000, 909291600, 923205600, 941346000, 954655200, 972795600, 986104800, 1004245200, 1018159200, 1035694800, 1049608800, 1067144400, 1081058400, 1099198800, 1112508000, 1130648400, 1143957600, 1162098000, 1175407200, 1193547600, 1207461600, 1224997200, 1238911200, 1256446800, 1270360800, 1288501200, 1301810400, 1319950800, 1333260000, 1351400400, 1365314400, 1382850000, 1396764000, 1414299600, 1428213600, 1445749200, 1459663200, 1477803600, 1491112800, 1509253200, 1522562400, 1540702800, 1554616800, 1572152400, 1586066400, 1603602000, 1617516000, 1635656400, 1648965600, 1667106000, 1680415200, 1698555600, 1712469600, 1730005200, 1743919200, 1761454800, 1775368800, 1792904400, 1806818400, 1824958800, 1838268000, 1856408400, 1869717600, 1887858000, 1901772000, 1919307600, 1933221600, 1950757200, 1964671200, 1982811600, 1996120800, 2014261200, 2027570400, 2045710800, 2059020000, 2077160400, 2091074400, 2108610000, 2122524000, 2140059600], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-10800, 1, 0), (-14400, 0, 4)], 'ADT\000AST\000'), 'Mexico/General': ('Mexico/General', 0, 1, [], '', [(-21600, 0, 0)], 'CST\000'), 'Greenwich': ('Greenwich', 0, 1, [], '', [(0, 0, 0)], 'GMT\000'), 'Egypt': ('Egypt', 152, 2, [-305164800, -291949200, -273628800, -260413200, -242092800, -228877200, -210556800, -197341200, -178934400, -165718800, -147398400, -134182800, -115862400, -102646800, -84326400, -71110800, -52704000, -39488400, -21168000, -7952400, 10368000, 23583600, 41904000, 55119600, 73526400, 86742000, 105062400, 118278000, 136598400, 149814000, 168134400, 181350000, 199756800, 212972400, 231292800, 244508400, 262828800, 276044400, 294364800, 307580400, 325987200, 339202800, 420595200, 433810800, 452217600, 465433200, 483753600, 496969200, 515289600, 528505200, 546825600, 560041200, 578448000, 591663600, 609984000, 623199600, 641520000, 654735600, 673056000, 686271600, 704678400, 717894000, 736214400, 749430000, 767750400, 780966000, 799286400, 812502000, 830908800, 844124400, 862444800, 875660400, 893980800, 907196400, 925516800, 938732400, 957139200, 970354800, 988675200, 1001890800, 1020211200, 1033426800, 1051747200, 1064962800, 1083369600, 1096585200, 1114905600, 1128121200, 1146441600, 1159657200, 1177977600, 1191193200, 1209600000, 1222815600, 1241136000, 1254351600, 1272672000, 1285887600, 1304208000, 1317423600, 1335830400, 1349046000, 1367366400, 1380582000, 1398902400, 1412118000, 1430438400, 1443654000, 1462060800, 1475276400, 1493596800, 1506812400, 1525132800, 1538348400, 1556668800, 1569884400, 1588291200, 1601506800, 1619827200, 1633042800, 1651363200, 1664578800, 1682899200, 1696114800, 1714521600, 1727737200, 1746057600, 1759273200, 1777593600, 1790809200, 1809129600, 1822345200, 1840752000, 1853967600, 1872288000, 1885503600, 1903824000, 1917039600, 1935360000, 1948575600, 1966982400, 1980198000, 1998518400, 2011734000, 2030054400, 2043270000, 2061590400, 2074806000, 2093212800, 2106428400, 2124748800, 2137964400], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(10800, 1, 0), (7200, 0, 8)], 'EET DST\000EET\000'), 'US/Eastern': ('US/Eastern', 148, 3, [-1633280400, -1615140000, -1601830800, -1583690400, -880218000, -765396000, -84387600, -68666400, -52938000, -37216800, -21488400, -5767200, 9961200, 25682400, 41410800, 57736800, 73465200, 89186400, 104914800, 120636000, 126687600, 152085600, 162370800, 183535200, 199263600, 215589600, 230713200, 247039200, 262767600, 278488800, 294217200, 309938400, 325666800, 341388000, 357116400, 372837600, 388566000, 404892000, 420015600, 436341600, 452070000, 467791200, 483519600, 499240800, 514969200, 530690400, 544604400, 562140000, 576054000, 594194400, 607503600, 625644000, 638953200, 657093600, 671007600, 688543200, 702457200, 719992800, 733906800, 752047200, 765356400, 783496800, 796806000, 814946400, 828860400, 846396000, 860310000, 877845600, 891759600, 909295200, 923209200, 941349600, 954658800, 972799200, 986108400, 1004248800, 1018162800, 1035698400, 1049612400, 1067148000, 1081062000, 1099202400, 1112511600, 1130652000, 1143961200, 1162101600, 1175410800, 1193551200, 1207465200, 1225000800, 1238914800, 1256450400, 1270364400, 1288504800, 1301814000, 1319954400, 1333263600, 1351404000, 1365318000, 1382853600, 1396767600, 1414303200, 1428217200, 1445752800, 1459666800, 1477807200, 1491116400, 1509256800, 1522566000, 1540706400, 1554620400, 1572156000, 1586070000, 1603605600, 1617519600, 1635660000, 1648969200, 1667109600, 1680418800, 1698559200, 1712473200, 1730008800, 1743922800, 1761458400, 1775372400, 1792908000, 1806822000, 1824962400, 1838271600, 1856412000, 1869721200, 1887861600, 1901775600, 1919311200, 1933225200, 1950760800, 1964674800, 1982815200, 1996124400, 2014264800, 2027574000, 2045714400, 2059023600, 2077164000, 2091078000, 2108613600, 2122527600, 2140063200], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 1, 0), (-18000, 0, 4), (-14400, 1, 8)], 'EDT\000EST\000EWT\000'), 'Brazil/Acre': ('Brazil/Acre', 101, 2, [561970800, 571644000, 593420400, 603093600, 625561200, 634543200, 656924400, 665992800, 688374000, 697442400, 719823600, 729496800, 751273200, 760946400, 782722800, 792396000, 814863600, 823845600, 846226800, 855295200, 877676400, 887436000, 909126000, 918799200, 940575600, 950248800, 972716400, 981698400, 1004079600, 1013148000, 1035529200, 1044597600, 1066978800, 1076738400, 1098428400, 1108101600, 1129878000, 1139551200, 1162018800, 1171000800, 1193382000, 1202450400, 1224831600, 1234591200, 1256281200, 1265954400, 1287730800, 1297404000, 1319180400, 1328853600, 1351234800, 1360303200, 1382684400, 1391752800, 1414134000, 1423893600, 1445583600, 1455256800, 1477033200, 1486706400, 1509174000, 1518156000, 1540537200, 1549605600, 1571986800, 1581055200, 1603436400, 1613109600, 1634886000, 1644559200, 1666335600, 1676008800, 1698476400, 1707458400, 1729839600, 1738908000, 1761289200, 1771048800, 1792738800, 1802412000, 1824188400, 1833861600, 1856329200, 1865311200, 1887692400, 1896760800, 1919142000, 1928210400, 1950591600, 1960351200, 1982041200, 1991714400, 2013490800, 2023164000, 2045631600, 2054613600, 2076994800, 2086063200, 2108444400, 2118204000, 2139894000], '\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-18000, 0, 0), (-14400, 1, 4)], 'AST\000ADT\000'), 'US/Mountain': ('US/Mountain', 148, 3, [-1633273200, -1615132800, -1601823600, -1583683200, -880210800, -765388800, -84380400, -68659200, -52930800, -37209600, -21481200, -5760000, 9968400, 25689600, 41418000, 57744000, 73472400, 89193600, 104922000, 120643200, 126694800, 152092800, 162378000, 183542400, 199270800, 215596800, 230720400, 247046400, 262774800, 278496000, 294224400, 309945600, 325674000, 341395200, 357123600, 372844800, 388573200, 404899200, 420022800, 436348800, 452077200, 467798400, 483526800, 499248000, 514976400, 530697600, 544611600, 562147200, 576061200, 594201600, 607510800, 625651200, 638960400, 657100800, 671014800, 688550400, 702464400, 720000000, 733914000, 752054400, 765363600, 783504000, 796813200, 814953600, 828867600, 846403200, 860317200, 877852800, 891766800, 909302400, 923216400, 941356800, 954666000, 972806400, 986115600, 1004256000, 1018170000, 1035705600, 1049619600, 1067155200, 1081069200, 1099209600, 1112518800, 1130659200, 1143968400, 1162108800, 1175418000, 1193558400, 1207472400, 1225008000, 1238922000, 1256457600, 1270371600, 1288512000, 1301821200, 1319961600, 1333270800, 1351411200, 1365325200, 1382860800, 1396774800, 1414310400, 1428224400, 1445760000, 1459674000, 1477814400, 1491123600, 1509264000, 1522573200, 1540713600, 1554627600, 1572163200, 1586077200, 1603612800, 1617526800, 1635667200, 1648976400, 1667116800, 1680426000, 1698566400, 1712480400, 1730016000, 1743930000, 1761465600, 1775379600, 1792915200, 1806829200, 1824969600, 1838278800, 1856419200, 1869728400, 1887868800, 1901782800, 1919318400, 1933232400, 1950768000, 1964682000, 1982822400, 1996131600, 2014272000, 2027581200, 2045721600, 2059030800, 2077171200, 2091085200, 2108620800, 2122534800, 2140070400], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-21600, 1, 0), (-25200, 0, 4), (-21600, 1, 8)], 'MDT\000MST\000MWT\000'), 'US/Central': ('US/Central', 148, 3, [-1633276800, -1615136400, -1601827200, -1583686800, -880214400, -765392400, -84384000, -68662800, -52934400, -37213200, -21484800, -5763600, 9964800, 25686000, 41414400, 57740400, 73468800, 89190000, 104918400, 120639600, 126691200, 152089200, 162374400, 183538800, 199267200, 215593200, 230716800, 247042800, 262771200, 278492400, 294220800, 309942000, 325670400, 341391600, 357120000, 372841200, 388569600, 404895600, 420019200, 436345200, 452073600, 467794800, 483523200, 499244400, 514972800, 530694000, 544608000, 562143600, 576057600, 594198000, 607507200, 625647600, 638956800, 657097200, 671011200, 688546800, 702460800, 719996400, 733910400, 752050800, 765360000, 783500400, 796809600, 814950000, 828864000, 846399600, 860313600, 877849200, 891763200, 909298800, 923212800, 941353200, 954662400, 972802800, 986112000, 1004252400, 1018166400, 1035702000, 1049616000, 1067151600, 1081065600, 1099206000, 1112515200, 1130655600, 1143964800, 1162105200, 1175414400, 1193554800, 1207468800, 1225004400, 1238918400, 1256454000, 1270368000, 1288508400, 1301817600, 1319958000, 1333267200, 1351407600, 1365321600, 1382857200, 1396771200, 1414306800, 1428220800, 1445756400, 1459670400, 1477810800, 1491120000, 1509260400, 1522569600, 1540710000, 1554624000, 1572159600, 1586073600, 1603609200, 1617523200, 1635663600, 1648972800, 1667113200, 1680422400, 1698562800, 1712476800, 1730012400, 1743926400, 1761462000, 1775376000, 1792911600, 1806825600, 1824966000, 1838275200, 1856415600, 1869724800, 1887865200, 1901779200, 1919314800, 1933228800, 1950764400, 1964678400, 1982818800, 1996128000, 2014268400, 2027577600, 2045718000, 2059027200, 2077167600, 2091081600, 2108617200, 2122531200, 2140066800], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-18000, 1, 0), (-21600, 0, 4), (-18000, 1, 8)], 'CDT\000CST\000CWT\000'), 'US/Hawaii': ('US/Hawaii', 9, 4, [-1633260600, -1615120200, -1601811000, -1583670600, -1157283000, -1157200200, -880198200, -765376200, -712150200], '\000\001\000\001\000\001\002\001\003', [(-34200, 1, 0), (-37800, 0, 4), (-34200, 1, 8), (-36000, 0, 4)], 'HDT\000HST\000HWT\000'), 'US/Arizona': ('US/Arizona', 6, 3, [-1633273200, -1615132800, -1601823600, -1583683200, -880210800, -765388800], '\000\001\000\001\002\001', [(-21600, 1, 0), (-25200, 0, 4), (-21600, 1, 8)], 'MDT\000MST\000MWT\000'), 'Jamaica': ('Jamaica', 148, 3, [-1633280400, -1615140000, -1601830800, -1583690400, -880218000, -765396000, -84387600, -68666400, -52938000, -37216800, -21488400, -5767200, 9961200, 25682400, 41410800, 57736800, 73465200, 89186400, 104914800, 120636000, 126687600, 152085600, 162370800, 183535200, 199263600, 215589600, 230713200, 247039200, 262767600, 278488800, 294217200, 309938400, 325666800, 341388000, 357116400, 372837600, 388566000, 404892000, 420015600, 436341600, 452070000, 467791200, 483519600, 499240800, 514969200, 530690400, 544604400, 562140000, 576054000, 594194400, 607503600, 625644000, 638953200, 657093600, 671007600, 688543200, 702457200, 719992800, 733906800, 752047200, 765356400, 783496800, 796806000, 814946400, 828860400, 846396000, 860310000, 877845600, 891759600, 909295200, 923209200, 941349600, 954658800, 972799200, 986108400, 1004248800, 1018162800, 1035698400, 1049612400, 1067148000, 1081062000, 1099202400, 1112511600, 1130652000, 1143961200, 1162101600, 1175410800, 1193551200, 1207465200, 1225000800, 1238914800, 1256450400, 1270364400, 1288504800, 1301814000, 1319954400, 1333263600, 1351404000, 1365318000, 1382853600, 1396767600, 1414303200, 1428217200, 1445752800, 1459666800, 1477807200, 1491116400, 1509256800, 1522566000, 1540706400, 1554620400, 1572156000, 1586070000, 1603605600, 1617519600, 1635660000, 1648969200, 1667109600, 1680418800, 1698559200, 1712473200, 1730008800, 1743922800, 1761458400, 1775372400, 1792908000, 1806822000, 1824962400, 1838271600, 1856412000, 1869721200, 1887861600, 1901775600, 1919311200, 1933225200, 1950760800, 1964674800, 1982815200, 1996124400, 2014264800, 2027574000, 2045714400, 2059023600, 2077164000, 2091078000, 2108613600, 2122527600, 2140063200], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 1, 0), (-18000, 0, 4), (-14400, 1, 8)], 'EDT\000EST\000EWT\000'), 'Poland': ('Poland', 104, 2, [512524800, 528249600, 543974400, 559699200, 575424000, 591148800, 606873600, 622598400, 638323200, 654652800, 670377600, 686102400, 701827200, 717552000, 733276800, 749001600, 764726400, 780451200, 796176000, 811900800, 828230400, 843955200, 859680000, 875404800, 891129600, 906854400, 922579200, 938304000, 954028800, 969753600, 985478400, 1001808000, 1017532800, 1033257600, 1048982400, 1064707200, 1080432000, 1096156800, 1111881600, 1127606400, 1143331200, 1159056000, 1174780800, 1191110400, 1206835200, 1222560000, 1238284800, 1254009600, 1269734400, 1285459200, 1301184000, 1316908800, 1332633600, 1348963200, 1364688000, 1380412800, 1396137600, 1411862400, 1427587200, 1443312000, 1459036800, 1474761600, 1490486400, 1506211200, 1521936000, 1538265600, 1553990400, 1569715200, 1585440000, 1601164800, 1616889600, 1632614400, 1648339200, 1664064000, 1679788800, 1695513600, 1711843200, 1727568000, 1743292800, 1759017600, 1774742400, 1790467200, 1806192000, 1821916800, 1837641600, 1853366400, 1869091200, 1885420800, 1901145600, 1916870400, 1932595200, 1948320000, 1964044800, 1979769600, 1995494400, 2011219200, 2026944000, 2042668800, 2058393600, 2074723200, 2090448000, 2106172800, 2121897600, 2137622400], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(7200, 1, 0), (3600, 0, 8)], 'MET DST\000MET\000'), 'Canada/East-Saskatchewan': ('Canada/East-Saskatchewan', 0, 1, [], '', [(-21600, 0, 0)], 'CST\000'), 'US/Alaska': ('US/Alaska', 148, 3, [-1633266000, -1615125600, -1601816400, -1583676000, -880203600, -765381600, -84373200, -68652000, -52923600, -37202400, -21474000, -5752800, 9975600, 25696800, 41425200, 57751200, 73479600, 89200800, 104929200, 120650400, 126702000, 152100000, 162385200, 183549600, 199278000, 215604000, 230727600, 247053600, 262782000, 278503200, 294231600, 309952800, 325681200, 341402400, 357130800, 372852000, 388580400, 404906400, 420030000, 436356000, 452084400, 467805600, 483534000, 499255200, 514983600, 530704800, 544618800, 562154400, 576068400, 594208800, 607518000, 625658400, 638967600, 657108000, 671022000, 688557600, 702471600, 720007200, 733921200, 752061600, 765370800, 783511200, 796820400, 814960800, 828874800, 846410400, 860324400, 877860000, 891774000, 909309600, 923223600, 941364000, 954673200, 972813600, 986122800, 1004263200, 1018177200, 1035712800, 1049626800, 1067162400, 1081076400, 1099216800, 1112526000, 1130666400, 1143975600, 1162116000, 1175425200, 1193565600, 1207479600, 1225015200, 1238929200, 1256464800, 1270378800, 1288519200, 1301828400, 1319968800, 1333278000, 1351418400, 1365332400, 1382868000, 1396782000, 1414317600, 1428231600, 1445767200, 1459681200, 1477821600, 1491130800, 1509271200, 1522580400, 1540720800, 1554634800, 1572170400, 1586084400, 1603620000, 1617534000, 1635674400, 1648983600, 1667124000, 1680433200, 1698573600, 1712487600, 1730023200, 1743937200, 1761472800, 1775386800, 1792922400, 1806836400, 1824976800, 1838286000, 1856426400, 1869735600, 1887876000, 1901790000, 1919325600, 1933239600, 1950775200, 1964689200, 1982829600, 1996138800, 2014279200, 2027588400, 2045728800, 2059038000, 2077178400, 2091092400, 2108628000, 2122542000, 2140077600], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-28800, 1, 0), (-32400, 0, 5), (-28800, 1, 10)], 'AKDT\000AKST\000AKWT\000'), 'Canada/Mountain': ('Canada/Mountain', 138, 2, [-21481200, -5760000, 9968400, 25689600, 41418000, 57744000, 73472400, 89193600, 104922000, 120643200, 136371600, 152092800, 167821200, 183542400, 199270800, 215596800, 230720400, 247046400, 262774800, 278496000, 294224400, 309945600, 325674000, 341395200, 357123600, 372844800, 388573200, 404899200, 420022800, 436348800, 452077200, 467798400, 483526800, 499248000, 514976400, 530697600, 544611600, 562147200, 576061200, 594201600, 607510800, 625651200, 638960400, 657100800, 671014800, 688550400, 702464400, 720000000, 733914000, 752054400, 765363600, 783504000, 796813200, 814953600, 828867600, 846403200, 860317200, 877852800, 891766800, 909302400, 923216400, 941356800, 954666000, 972806400, 986115600, 1004256000, 1018170000, 1035705600, 1049619600, 1067155200, 1081069200, 1099209600, 1112518800, 1130659200, 1143968400, 1162108800, 1175418000, 1193558400, 1207472400, 1225008000, 1238922000, 1256457600, 1270371600, 1288512000, 1301821200, 1319961600, 1333270800, 1351411200, 1365325200, 1382860800, 1396774800, 1414310400, 1428224400, 1445760000, 1459674000, 1477814400, 1491123600, 1509264000, 1522573200, 1540713600, 1554627600, 1572163200, 1586077200, 1603612800, 1617526800, 1635667200, 1648976400, 1667116800, 1680426000, 1698566400, 1712480400, 1730016000, 1743930000, 1761465600, 1775379600, 1792915200, 1806829200, 1824969600, 1838278800, 1856419200, 1869728400, 1887868800, 1901782800, 1919318400, 1933232400, 1950768000, 1964682000, 1982822400, 1996131600, 2014272000, 2027581200, 2045721600, 2059030800, 2077171200, 2091085200, 2108620800, 2122534800, 2140070400], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-21600, 1, 0), (-25200, 0, 4)], 'MDT\000MST\000'), 'Universal': ('Universal', 0, 1, [], '', [(0, 0, 0)], 'GMT\000'), 'US/East-Indiana': ('US/East-Indiana', 6, 3, [-1633280400, -1615140000, -1601830800, -1583690400, -880218000, -765396000], '\000\001\000\001\002\001', [(-14400, 1, 0), (-18000, 0, 4), (-14400, 1, 8)], 'EDT\000EST\000EWT\000'), 'Canada/Yukon': ('Canada/Yukon', 138, 2, [-21474000, -5752800, 9975600, 25696800, 41425200, 57751200, 73479600, 89200800, 104929200, 120650400, 136378800, 152100000, 167828400, 183549600, 199278000, 215604000, 230727600, 247053600, 262782000, 278503200, 294231600, 309952800, 325681200, 341402400, 357130800, 372852000, 388580400, 404906400, 420030000, 436356000, 452084400, 467805600, 483534000, 499255200, 514983600, 530704800, 544618800, 562154400, 576068400, 594208800, 607518000, 625658400, 638967600, 657108000, 671022000, 688557600, 702471600, 720007200, 733921200, 752061600, 765370800, 783511200, 796820400, 814960800, 828874800, 846410400, 860324400, 877860000, 891774000, 909309600, 923223600, 941364000, 954673200, 972813600, 986122800, 1004263200, 1018177200, 1035712800, 1049626800, 1067162400, 1081076400, 1099216800, 1112526000, 1130666400, 1143975600, 1162116000, 1175425200, 1193565600, 1207479600, 1225015200, 1238929200, 1256464800, 1270378800, 1288519200, 1301828400, 1319968800, 1333278000, 1351418400, 1365332400, 1382868000, 1396782000, 1414317600, 1428231600, 1445767200, 1459681200, 1477821600, 1491130800, 1509271200, 1522580400, 1540720800, 1554634800, 1572170400, 1586084400, 1603620000, 1617534000, 1635674400, 1648983600, 1667124000, 1680433200, 1698573600, 1712487600, 1730023200, 1743937200, 1761472800, 1775386800, 1792922400, 1806836400, 1824976800, 1838286000, 1856426400, 1869735600, 1887876000, 1901790000, 1919325600, 1933239600, 1950775200, 1964689200, 1982829600, 1996138800, 2014279200, 2027588400, 2045728800, 2059038000, 2077178400, 2091092400, 2108628000, 2122542000, 2140077600], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-28800, 1, 0), (-32400, 0, 4)], 'YDT\000YST\000'), 'Iceland': ('Iceland', 0, 1, [], '', [(0, 0, 0)], 'WET\000'), 'Canada/Eastern': ('Canada/Eastern', 138, 2, [-21488400, -5767200, 9961200, 25682400, 41410800, 57736800, 73465200, 89186400, 104914800, 120636000, 136364400, 152085600, 167814000, 183535200, 199263600, 215589600, 230713200, 247039200, 262767600, 278488800, 294217200, 309938400, 325666800, 341388000, 357116400, 372837600, 388566000, 404892000, 420015600, 436341600, 452070000, 467791200, 483519600, 499240800, 514969200, 530690400, 544604400, 562140000, 576054000, 594194400, 607503600, 625644000, 638953200, 657093600, 671007600, 688543200, 702457200, 719992800, 733906800, 752047200, 765356400, 783496800, 796806000, 814946400, 828860400, 846396000, 860310000, 877845600, 891759600, 909295200, 923209200, 941349600, 954658800, 972799200, 986108400, 1004248800, 1018162800, 1035698400, 1049612400, 1067148000, 1081062000, 1099202400, 1112511600, 1130652000, 1143961200, 1162101600, 1175410800, 1193551200, 1207465200, 1225000800, 1238914800, 1256450400, 1270364400, 1288504800, 1301814000, 1319954400, 1333263600, 1351404000, 1365318000, 1382853600, 1396767600, 1414303200, 1428217200, 1445752800, 1459666800, 1477807200, 1491116400, 1509256800, 1522566000, 1540706400, 1554620400, 1572156000, 1586070000, 1603605600, 1617519600, 1635660000, 1648969200, 1667109600, 1680418800, 1698559200, 1712473200, 1730008800, 1743922800, 1761458400, 1775372400, 1792908000, 1806822000, 1824962400, 1838271600, 1856412000, 1869721200, 1887861600, 1901775600, 1919311200, 1933225200, 1950760800, 1964674800, 1982815200, 1996124400, 2014264800, 2027574000, 2045714400, 2059023600, 2077164000, 2091078000, 2108613600, 2122527600, 2140063200], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 1, 0), (-18000, 0, 4)], 'EDT\000EST\000'), 'Canada/Pacific': ('Canada/Pacific', 138, 2, [-21477600, -5756400, 9972000, 25693200, 41421600, 57747600, 73476000, 89197200, 104925600, 120646800, 136375200, 152096400, 167824800, 183546000, 199274400, 215600400, 230724000, 247050000, 262778400, 278499600, 294228000, 309949200, 325677600, 341398800, 357127200, 372848400, 388576800, 404902800, 420026400, 436352400, 452080800, 467802000, 483530400, 499251600, 514980000, 530701200, 544615200, 562150800, 576064800, 594205200, 607514400, 625654800, 638964000, 657104400, 671018400, 688554000, 702468000, 720003600, 733917600, 752058000, 765367200, 783507600, 796816800, 814957200, 828871200, 846406800, 860320800, 877856400, 891770400, 909306000, 923220000, 941360400, 954669600, 972810000, 986119200, 1004259600, 1018173600, 1035709200, 1049623200, 1067158800, 1081072800, 1099213200, 1112522400, 1130662800, 1143972000, 1162112400, 1175421600, 1193562000, 1207476000, 1225011600, 1238925600, 1256461200, 1270375200, 1288515600, 1301824800, 1319965200, 1333274400, 1351414800, 1365328800, 1382864400, 1396778400, 1414314000, 1428228000, 1445763600, 1459677600, 1477818000, 1491127200, 1509267600, 1522576800, 1540717200, 1554631200, 1572166800, 1586080800, 1603616400, 1617530400, 1635670800, 1648980000, 1667120400, 1680429600, 1698570000, 1712484000, 1730019600, 1743933600, 1761469200, 1775383200, 1792918800, 1806832800, 1824973200, 1838282400, 1856422800, 1869732000, 1887872400, 1901786400, 1919322000, 1933236000, 1950771600, 1964685600, 1982826000, 1996135200, 2014275600, 2027584800, 2045725200, 2059034400, 2077174800, 2091088800, 2108624400, 2122538400, 2140074000], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-25200, 1, 0), (-28800, 0, 4)], 'PDT\000PST\000'), 'Mexico/BajaNorte': ('Mexico/BajaNorte', 102, 2, [544615200, 562150800, 576064800, 594205200, 607514400, 625654800, 638964000, 657104400, 671018400, 688554000, 702468000, 720003600, 733917600, 752058000, 765367200, 783507600, 796816800, 814957200, 828871200, 846406800, 860320800, 877856400, 891770400, 909306000, 923220000, 941360400, 954669600, 972810000, 986119200, 1004259600, 1018173600, 1035709200, 1049623200, 1067158800, 1081072800, 1099213200, 1112522400, 1130662800, 1143972000, 1162112400, 1175421600, 1193562000, 1207476000, 1225011600, 1238925600, 1256461200, 1270375200, 1288515600, 1301824800, 1319965200, 1333274400, 1351414800, 1365328800, 1382864400, 1396778400, 1414314000, 1428228000, 1445763600, 1459677600, 1477818000, 1491127200, 1509267600, 1522576800, 1540717200, 1554631200, 1572166800, 1586080800, 1603616400, 1617530400, 1635670800, 1648980000, 1667120400, 1680429600, 1698570000, 1712484000, 1730019600, 1743933600, 1761469200, 1775383200, 1792918800, 1806832800, 1824973200, 1838282400, 1856422800, 1869732000, 1887872400, 1901786400, 1919322000, 1933236000, 1950771600, 1964685600, 1982826000, 1996135200, 2014275600, 2027584800, 2045725200, 2059034400, 2077174800, 2091088800, 2108624400, 2122538400, 2140074000], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-25200, 1, 0), (-28800, 0, 4)], 'PDT\000PST\000'), 'Canada/Central': ('Canada/Central', 138, 2, [-21484800, -5763600, 9964800, 25686000, 41414400, 57740400, 73468800, 89190000, 104918400, 120639600, 136368000, 152089200, 167817600, 183538800, 199267200, 215593200, 230716800, 247042800, 262771200, 278492400, 294220800, 309942000, 325670400, 341391600, 357120000, 372841200, 388569600, 404895600, 420019200, 436345200, 452073600, 467794800, 483523200, 499244400, 514972800, 530694000, 544608000, 562143600, 576057600, 594198000, 607507200, 625647600, 638956800, 657097200, 671011200, 688546800, 702460800, 719996400, 733910400, 752050800, 765360000, 783500400, 796809600, 814950000, 828864000, 846399600, 860313600, 877849200, 891763200, 909298800, 923212800, 941353200, 954662400, 972802800, 986112000, 1004252400, 1018166400, 1035702000, 1049616000, 1067151600, 1081065600, 1099206000, 1112515200, 1130655600, 1143964800, 1162105200, 1175414400, 1193554800, 1207468800, 1225004400, 1238918400, 1256454000, 1270368000, 1288508400, 1301817600, 1319958000, 1333267200, 1351407600, 1365321600, 1382857200, 1396771200, 1414306800, 1428220800, 1445756400, 1459670400, 1477810800, 1491120000, 1509260400, 1522569600, 1540710000, 1554624000, 1572159600, 1586073600, 1603609200, 1617523200, 1635663600, 1648972800, 1667113200, 1680422400, 1698562800, 1712476800, 1730012400, 1743926400, 1761462000, 1775376000, 1792911600, 1806825600, 1824966000, 1838275200, 1856415600, 1869724800, 1887865200, 1901779200, 1919314800, 1933228800, 1950764400, 1964678400, 1982818800, 1996128000, 2014268400, 2027577600, 2045718000, 2059027200, 2077167600, 2091081600, 2108617200, 2122531200, 2140066800], '\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-18000, 1, 0), (-21600, 0, 4)], 'CDT\000CST\000'), 'US/Michigan': ('US/Michigan', 138, 3, [-1633280400, -1615140000, -1601830800, -1583690400, -880218000, -765396000, -84387600, -68666400, 104914800, 120636000, 126687600, 152085600, 162370800, 183535200, 199263600, 215589600, 230713200, 247039200, 262767600, 278488800, 294217200, 309938400, 325666800, 341388000, 357116400, 372837600, 388566000, 404892000, 420015600, 436341600, 452070000, 467791200, 483519600, 499240800, 514969200, 530690400, 544604400, 562140000, 576054000, 594194400, 607503600, 625644000, 638953200, 657093600, 671007600, 688543200, 702457200, 719992800, 733906800, 752047200, 765356400, 783496800, 796806000, 814946400, 828860400, 846396000, 860310000, 877845600, 891759600, 909295200, 923209200, 941349600, 954658800, 972799200, 986108400, 1004248800, 1018162800, 1035698400, 1049612400, 1067148000, 1081062000, 1099202400, 1112511600, 1130652000, 1143961200, 1162101600, 1175410800, 1193551200, 1207465200, 1225000800, 1238914800, 1256450400, 1270364400, 1288504800, 1301814000, 1319954400, 1333263600, 1351404000, 1365318000, 1382853600, 1396767600, 1414303200, 1428217200, 1445752800, 1459666800, 1477807200, 1491116400, 1509256800, 1522566000, 1540706400, 1554620400, 1572156000, 1586070000, 1603605600, 1617519600, 1635660000, 1648969200, 1667109600, 1680418800, 1698559200, 1712473200, 1730008800, 1743922800, 1761458400, 1775372400, 1792908000, 1806822000, 1824962400, 1838271600, 1856412000, 1869721200, 1887861600, 1901775600, 1919311200, 1933225200, 1950760800, 1964674800, 1982815200, 1996124400, 2014264800, 2027574000, 2045714400, 2059023600, 2077164000, 2091078000, 2108613600, 2122527600, 2140063200], '\000\001\000\001\002\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001', [(-14400, 1, 0), (-18000, 0, 4), (-14400, 1, 8)], 'EDT\000EST\000EWT\000'),

}</t>
<t tx="ekr.20040104203230">"""
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;&lt;dtml-var title&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR="#FFFFFF"&gt;
&lt;FORM ACTION="&lt;dtml-var action&gt;" METHOD="GET" &lt;dtml-if
 target&gt;TARGET="&lt;dtml-var target&gt;"&lt;/dtml-if&gt;&gt;
&lt;TABLE BORDER="0" WIDTH="100%%" CELLPADDING="10"&gt;
&lt;TR&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;BR&gt;
  &lt;CENTER&gt;&lt;B&gt;&lt;FONT SIZE="+6" COLOR="#77003B"&gt;!&lt;/FONT&gt;&lt;/B&gt;&lt;/CENTER&gt;
  &lt;/TD&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;BR&gt;&lt;BR&gt;
  &lt;CENTER&gt;
  &lt;dtml-var message&gt;
  &lt;/CENTER&gt;
  &lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;/TD&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;CENTER&gt;
  &lt;INPUT TYPE="SUBMIT" VALUE="   Ok   "&gt;
  &lt;/CENTER&gt;
  &lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;&lt;/HTML&gt;"""</t>
<t tx="ekr.20040104204617">/*

Objects are stored under three different regimes:

Regime 1: Persistent Classes

Persistent Classes are part of ZClasses. They are stored in the
self-&gt;data dictionary, and are never garbage collected.

The klass_items() method returns a sequence of (oid,object) tuples for
every Persistent Class, which should make it possible to implement
garbage collection in Python if necessary.

Regime 2: Ghost Objects

There is no benefit to keeping a ghost object which has no external
references, therefore a weak reference scheme is used to ensure that
ghost objects are removed from memory as soon as possible, when the
last external reference is lost.

Ghost objects are stored in the self-&gt;data dictionary. Normally a
dictionary keeps a strong reference on its values, however this
reference count is 'stolen'.

This weak reference scheme leaves a dangling reference, in the
dictionary, when the last external reference is lost. To clean up this
dangling reference the persistent object dealloc function calls
self-&gt;cache-&gt;_oid_unreferenced(self-&gt;oid). The cache looks up the oid
in the dictionary, ensures it points to an object whose reference
count is zero, then removes it from the dictionary. Before removing
the object from the dictionary it must temporarily resurrect the
object in much the same way that class instances are resurrected
before their __del__ is called.

Since ghost objects are stored under a different regime to non-ghost
objects, an extra ghostify function in cPersistenceAPI replaces
self-&gt;state=GHOST_STATE assignments that were common in other
persistent classes (such as BTrees).

Regime 3: Non-Ghost Objects

Non-ghost objects are stored in two data structures: the dictionary
mapping oids to objects and a doubly-linked list that encodes the
order in which the objects were accessed.  The dictionary reference is
borrowed, as it is for ghosts.  The list reference is a new reference;
the list stores recently used objects, even if they are otherwise
unreferenced, to avoid loading the object from the database again.

The doubly-link-list nodes contain next and previous pointers linking
together the cache and all non-ghost persistent objects.

The node embedded in the cache is the home position. On every
attribute access a non-ghost object will relink itself just behind the
home position in the ring. Objects accessed least recently will
eventually find themselves positioned after the home position.

Occasionally other nodes are temporarily inserted in the ring as
position markers. The cache contains a ring_lock flag which must be
set and unset before and after doing so. Only if the flag is unset can
the cache assume that all nodes are either his own home node, or nodes
from persistent objects. This assumption is useful during the garbage
collection process.

The number of non-ghost objects is counted in self-&gt;non_ghost_count.
The garbage collection process consists of traversing the ring, and
deactivating (that is, turning into a ghost) every object until
self-&gt;non_ghost_count is down to the target size, or until it
reaches the home position again.

Note that objects in the sticky or changed states are still kept in
the ring, however they can not be deactivated. The garbage collection
process must skip such objects, rather than deactivating them.

*/</t>
<t tx="ekr.20040104205714">static char cStringIO_module_documentation[] = 
"A simple fast partial StringIO replacement.\n"
"\n"
"This module provides a simple useful replacement for\n"
"the StringIO module that is written in C.  It does not provide the\n"
"full generality of StringIO, but it provides enough for most\n"
"applications and is especially useful in conjunction with the\n"
"pickle module.\n"
"\n"
"Usage:\n"
"\n"
"  from cStringIO import StringIO\n"
"\n"
"  an_output_stream=StringIO()\n"
"  an_output_stream.write(some_stuff)\n"
"  ...\n"
"  value=an_output_stream.getvalue() # str(an_output_stream) works too!\n"
"\n"
"  an_input_stream=StringIO(a_string)\n"
"  spam=an_input_stream.readline()\n"
"  spam=an_input_stream.read(5)\n"
"  an_input_stream.seek(0)           # OK, start over\n"
"  spam=an_input_stream.read()       # and read it all\n"
"  \n"
"If someone else wants to provide a more complete implementation,\n"
"go for it. :-)  \n"
"\n"
"cStringIO.c,v 1.29 1999/06/15 14:10:27 jim Exp\n"
;</t>
<t tx="ekr.20040104213514"></t>
<t tx="ekr.20040104214040">import Acquisition, ComputedAttribute, App.PersistentExtra, os
import TreeDisplay

from App.FindHomes import INSTANCE_HOME, SOFTWARE_HOME, ZOPE_HOME
from App.Common import package_home, attrget, Dictionary
from Persistence import Persistent, PersistentMapping
from App.special_dtml import HTML, HTMLFile, DTMLFile
from App.class_init import default__class_init__, ApplicationDefaultPermissions

# Nicer alias for class initializer.
InitializeClass = default__class_init__

from App.Dialogs import MessageDialog
from App.ImageFile import ImageFile</t>
<t tx="ekr.20040104214040.1"># We import BoboPOS before importing any other application
# modules.  This is needed to assure that the right
# versions of Persistent etc get registered.
from BoboPOS import SimpleDB, TJar, SingleThreadedTransaction

import sys, os,  Globals, OFS.Application</t>
<t tx="ekr.20040104214837"># XML-RPC CLIENT LIBRARY
# $Id$
#
# an XML-RPC client interface for Python.
#
# the marshalling and response parser code can also be used to
# implement XML-RPC servers.
#
# Notes:
# this version is designed to work with Python 1.5.2 or newer.
# unicode encoding support requires at least Python 1.6.
# experimental HTTPS requires Python 2.0 built with SSL sockets.
# expat parser support requires Python 2.0 with pyexpat support.
#
# History:
# 1999-01-14 fl  Created
# 1999-01-15 fl  Changed dateTime to use localtime
# 1999-01-16 fl  Added Binary/base64 element, default to RPC2 service
# 1999-01-19 fl  Fixed array data element (from Skip Montanaro)
# 1999-01-21 fl  Fixed dateTime constructor, etc.
# 1999-02-02 fl  Added fault handling, handle empty sequences, etc.
# 1999-02-10 fl  Fixed problem with empty responses (from Skip Montanaro)
# 1999-06-20 fl  Speed improvements, pluggable parsers/transports (0.9.8)
# 2000-11-28 fl  Changed boolean to check the truth value of its argument
# 2001-02-24 fl  Added encoding/Unicode/SafeTransport patches
# 2001-02-26 fl  Added compare support to wrappers (0.9.9/1.0b1)
# 2001-03-28 fl  Make sure response tuple is a singleton
# 2001-03-29 fl  Don't require empty params element (from Nicholas Riley)
# 2001-06-10 fl  Folded in _xmlrpclib accelerator support (1.0b2)
# 2001-08-20 fl  Base xmlrpclib.Error on built-in Exception (from Paul Prescod)
# 2001-09-03 fl  Allow Transport subclass to override getparser
# 2001-09-10 fl  Lazy import of urllib, cgi, xmllib (20x import speedup)
# 2001-10-01 fl  Remove containers from memo cache when done with them
# 2001-10-01 fl  Use faster escape method (80% dumps speedup)
# 2001-10-10 sm  Allow long ints to be passed as ints if they don't overflow
# 2001-10-17 sm  test for int and long overflow (allows use on 64-bit systems)
# 2001-11-12 fl  Use repr() to marshal doubles (from Paul Felix)</t>
<t tx="ekr.20040104214837.1"># Copyright (c) 1999-2001 by Secret Labs AB.
# Copyright (c) 1999-2001 by Fredrik Lundh.
#
# info@pythonware.com
# http://www.pythonware.com
#
# --------------------------------------------------------------------
# The XML-RPC client interface is
#
# Copyright (c) 1999-2001 by Secret Labs AB
# Copyright (c) 1999-2001 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------
</t>
<t tx="ekr.20040104214837.2"># things to look into:

# TODO: support basic authentication (see robin's patch)
# TODO: fix host tuple handling in the server constructor
# TODO: let transport verify schemes
# TODO: update documentation
# TODO: authentication plugins
</t>
<t tx="ekr.20040104214837.3">"""
An XML-RPC client interface for Python.

The marshalling and response parser code can also be used to
implement XML-RPC servers.

Exported exceptions:

  Error          Base class for client errors
  ProtocolError  Indicates an HTTP protocol error
  ResponseError  Indicates a broken response package
  Fault          Indicates an XML-RPC fault package

Exported classes:

  ServerProxy    Represents a logical connection to an XML-RPC server

  Boolean        boolean wrapper to generate a "boolean" XML-RPC value
  DateTime       dateTime wrapper for an ISO 8601 string or time tuple or
                 localtime integer value to generate a "dateTime.iso8601"
                 XML-RPC value
  Binary         binary data wrapper

  SlowParser     Slow but safe standard parser (based on xmllib)
  Marshaller     Generate an XML-RPC params chunk from a Python data structure
  Unmarshaller   Unmarshal an XML-RPC response from incoming XML event message
  Transport      Handles an HTTP transaction to an XML-RPC server
  SafeTransport  Handles an HTTPS transaction to an XML-RPC server

Exported constants:

  True
  False

Exported functions:

  boolean        Convert any Python value to an XML-RPC boolean
  getparser      Create instance of the fastest available parser &amp; attach
                 to an unmarshalling object
  dumps          Convert an argument tuple or a Fault instance to an XML-RPC
                 request (or response, if the methodresponse option is used).
  loads          Convert an XML-RPC packet to unmarshalled data plus a method
                 name (None if not present).
"""
</t>
<t tx="ekr.20040104214837.4"></t>
<t tx="ekr.20040104215044">@others

WRAPPERS = DateTime, Binary, Boolean</t>
<t tx="ekr.20040104215044.1"></t>
<t tx="ekr.20040104215235"></t>
<t tx="ekr.20040104225604">print "removing leading blank lines..." ; print

from leoGlobals import *
c = top() ; v = c.currentVnode()
count = 0

while v:
	s = v.bodyString()
	i = skip_ws(s,0)
	if match(s,i,'\n'):
		count += 1
		print v.headString()
		s = s[i+1:]
		# print `s`
		v.setBodyStringOrPane(s)
		v.setDirty()
	v = v.threadNext()

print ; print "changed %d nodes" % count</t>
<t tx="ekr.20040106165012">"""
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;&lt;dtml-var title&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR="#FFFFFF"&gt;
&lt;FORM ACTION="&lt;dtml-var action&gt;" METHOD="GET" &lt;dtml-if
 target&gt;TARGET="&lt;dtml-var target&gt;"&lt;/dtml-if&gt;&gt;
&lt;TABLE BORDER="0" WIDTH="100%" CELLPADDING="10"&gt;
&lt;TR&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;BR&gt;
  &lt;CENTER&gt;&lt;B&gt;&lt;FONT SIZE="+6" COLOR="#77003B"&gt;!&lt;/FONT&gt;&lt;/B&gt;&lt;/CENTER&gt;
  &lt;/TD&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;BR&gt;&lt;BR&gt;
  &lt;CENTER&gt;
  &lt;dtml-var message&gt;
  &lt;/CENTER&gt;
  &lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;/TD&gt;
  &lt;TD VALIGN="TOP"&gt;
  &lt;CENTER&gt;
  &lt;INPUT TYPE="SUBMIT" VALUE="   Ok   "&gt;
  &lt;/CENTER&gt;
  &lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;&lt;/HTML&gt;"""
</t>
<t tx="ekr.20040106165810"></t>
<t tx="ekr.20040106165810.1"></t>
<t tx="ekr.20040106165810.2">typedef struct {
	PyObject_HEAD
} ZopeSecurityPolicy;

typedef struct {
	PyObject_HEAD
        PyObject *thread_id;
        PyObject *context;
        PyObject *policy;
        PyObject *validate;
        PyObject *checkPermission;
} SecurityManager;

typedef struct {
	PyObject_HEAD
	PyObject *__name__;
	PyObject *_p;
	PyObject *__roles__;
} PermissionRole;

typedef struct {
	PyObject_HEAD
	PyObject *_p;
	PyObject *_pa;
	PyObject *__roles__;
	PyObject *_v;
} imPermissionRole;

</t>
<t tx="ekr.20040106165810.3">static PyObject *ZopeSecurityPolicy_validate(PyObject *self, PyObject *args);
static PyObject *ZopeSecurityPolicy_checkPermission(PyObject *self,
	PyObject *args);
static void ZopeSecurityPolicy_dealloc(ZopeSecurityPolicy *self);


static PyObject *PermissionRole_init(PermissionRole *self, PyObject *args);
static PyObject *PermissionRole_of(PermissionRole *self, PyObject *args);
static void PermissionRole_dealloc(PermissionRole *self);

static PyObject *imPermissionRole_of(imPermissionRole *self, PyObject *args);
static int imPermissionRole_length(imPermissionRole *self);
static PyObject *imPermissionRole_get(imPermissionRole *self,
	int item);
static void imPermissionRole_dealloc(imPermissionRole *self);

static PyObject *rolesForPermissionOn(PyObject *self, PyObject *args);
static PyObject *module_guarded_getattr(PyObject *self, PyObject *args);
static PyObject *module_aq_validate(PyObject *self, PyObject *args);
static PyObject *c_rolesForPermissionOn(PyObject *self, PyObject *perm,
                                        PyObject *object, PyObject *deflt);

static PyObject *permissionName(PyObject *name);

static PyObject *SecurityManager_validate(SecurityManager *self, 
                                          PyObject *args);
static PyObject *SecurityManager_validateValue(SecurityManager *self,
                                               PyObject *args);
static PyObject *SecurityManager_DTMLValidate(SecurityManager *self,
                                              PyObject *args);
static PyObject *SecurityManager_checkPermission(SecurityManager *self, 
                                                 PyObject *args);
static void SecurityManager_dealloc(SecurityManager *self);
static PyObject *SecurityManager_getattro(SecurityManager *self, 
                                          PyObject *name);
static int SecurityManager_setattro(SecurityManager *self, 
                                    PyObject *name, PyObject *value);
</t>
<t tx="ekr.20040106165810.4">static PyMethodDef cAccessControl_methods[] = {
	{"rolesForPermissionOn", 
		(PyCFunction)rolesForPermissionOn,
		METH_VARARGS,
		""
	},
        {"guarded_getattr", 
		(PyCFunction)module_guarded_getattr,
		METH_VARARGS,
		""
        },               
        {"aq_validate", 
		(PyCFunction)module_aq_validate,
		METH_VARARGS,
		""
        },               
	{ NULL, NULL }
};

static char ZopeSecurityPolicy__doc__[] = "ZopeSecurityPolicy C implementation";

static PyMethodDef ZopeSecurityPolicy_methods[] = {
	{"validate",
		(PyCFunction)ZopeSecurityPolicy_validate,
		METH_VARARGS,
		""
	},
	{"checkPermission",
		(PyCFunction)ZopeSecurityPolicy_checkPermission,
		METH_VARARGS,
		""
	},
	{ NULL, NULL }
};

static PyExtensionClass ZopeSecurityPolicyType = {
	PyObject_HEAD_INIT(NULL) 0,
	"ZopeSecurityPolicy",			/* tp_name	*/
	sizeof(ZopeSecurityPolicy),		/* tp_basicsize	*/
	0,					/* tp_itemsize	*/
	/* Standard methods 	*/
	(destructor) ZopeSecurityPolicy_dealloc,/* tp_dealloc	*/
	NULL,					/* tp_print	*/
	NULL,					/* tp_getattr	*/
	NULL,					/* tp_setattr	*/
	NULL,					/* tp_compare	*/
	NULL,					/* tp_repr	*/
	/* Method suites	*/
	NULL,					/* tp_as_number	*/
	NULL,					/* tp_as_sequence*/
	NULL,					/* tp_as_mapping */
	/* More standard ops  	*/
	NULL,					/* tp_hash	*/
	NULL,					/* tp_call	*/
	NULL,					/* tp_str	*/
	NULL,					/* tp_getattro	*/
	NULL,					/* tp_setattro	*/
	/* Reserved fields	*/
	0,					/* tp_xxx3	*/
	0,					/* tp_xxx4	*/
	/* Docstring		*/
	ZopeSecurityPolicy__doc__,		/* tp_doc	*/
#ifdef COUNT_ALLOCS
	0,					/* tp_alloc	*/
	0,					/* tp_free	*/
	0,					/* tp_maxalloc	*/
	NULL,					/* tp_next	*/
#endif
	METHOD_CHAIN(ZopeSecurityPolicy_methods),/* methods	*/
	EXTENSIONCLASS_BINDABLE_FLAG,		/* flags	*/
};


static char SecurityManager__doc__[] = "ZopeSecurityPolicy C implementation";

static PyMethodDef SecurityManager_methods[] = {
	{"validate",
		(PyCFunction)SecurityManager_validate,
		METH_VARARGS,
		""
	},
	{"DTMLValidate",
		(PyCFunction)SecurityManager_DTMLValidate,
		METH_VARARGS,
		""
	},
	{"validateValue",
		(PyCFunction)SecurityManager_validateValue,
		METH_VARARGS,
		""
	},
	{"checkPermission",
		(PyCFunction)SecurityManager_checkPermission,
		METH_VARARGS,
		""
	},
	{ NULL, NULL }
};

static PyExtensionClass SecurityManagerType = {
	PyObject_HEAD_INIT(NULL) 0,
	"SecurityManager",			/* tp_name	*/
	sizeof(SecurityManager),		/* tp_basicsize	*/
	0,					/* tp_itemsize	*/
	/* Standard methods 	*/
	(destructor) SecurityManager_dealloc,/* tp_dealloc	*/
	NULL,					/* tp_print	*/
	NULL,					/* tp_getattr	*/
	NULL,					/* tp_setattr	*/
	NULL,					/* tp_compare	*/
	NULL,					/* tp_repr	*/
	/* Method suites	*/
	NULL,					/* tp_as_number	*/
	NULL,					/* tp_as_sequence*/
	NULL,					/* tp_as_mapping */
	/* More standard ops  	*/
	NULL,					/* tp_hash	*/
	NULL,					/* tp_call	*/
	NULL,					/* tp_str	*/
	(getattrofunc)SecurityManager_getattro,	/* tp_getattro	*/
	(setattrofunc)SecurityManager_setattro,	/* tp_setattro	*/
	/* Reserved fields	*/
	0,					/* tp_xxx3	*/
	0,					/* tp_xxx4	*/
	/* Docstring		*/
	SecurityManager__doc__,		/* tp_doc	*/
#ifdef COUNT_ALLOCS
	0,					/* tp_alloc	*/
	0,					/* tp_free	*/
	0,					/* tp_maxalloc	*/
	NULL,					/* tp_next	*/
#endif
	METHOD_CHAIN(SecurityManager_methods),	/* methods	*/
	0,					/* flags	*/
};


static char PermissionRole__doc__[] = "PermissionRole C implementation";

static PyMethodDef PermissionRole_methods[] = {
	{"__init__",
		(PyCFunction)PermissionRole_init,
		METH_VARARGS,
		""
	},
	{"__of__",
		(PyCFunction)PermissionRole_of,
		METH_VARARGS,
		""
	},
	{ NULL, NULL }
};

static PyExtensionClass PermissionRoleType = {
	PyObject_HEAD_INIT(NULL) 0,
	"PermissionRole",			/* tp_name	*/
	sizeof(PermissionRole),			/* tp_basicsize	*/
	0,					/* tp_itemsize	*/
	/* Standard methods 	*/
	(destructor) PermissionRole_dealloc,	/* tp_dealloc	*/
	NULL,					/* tp_print	*/
	NULL,					/* tp_getattr	*/
	NULL,					/* tp_setattr	*/
	NULL,					/* tp_compare	*/
	NULL,					/* tp_repr	*/
	/* Method suites	*/
	NULL,					/* tp_as_number	*/
	NULL,					/* tp_as_sequence*/
	NULL,					/* tp_as_mapping */
	/* More standard ops  	*/
	NULL,					/* tp_hash	*/
	NULL,					/* tp_call	*/
	NULL,					/* tp_str	*/
	NULL,					/* tp_getattro	*/
	NULL,					/* tp_setattro	*/
	/* Reserved fields	*/
	0,					/* tp_xxx3	*/
	0,					/* tp_xxx4	*/
	/* Docstring		*/
	PermissionRole__doc__,			/* tp_doc	*/
#ifdef COUNT_ALLOCS
	0,					/* tp_alloc	*/
	0,					/* tp_free	*/
	0,					/* tp_maxalloc	*/
	NULL,					/* tp_next	*/
#endif
	METHOD_CHAIN(PermissionRole_methods),	/* methods	*/
	EXTENSIONCLASS_BINDABLE_FLAG/*|
	EXTENSIONCLASS_INSTDICT_FLAG*/,		/* flags	*/
	NULL,					/* Class dict	*/
	NULL,					/* bases	*/
	NULL,					/* reserved	*/
};

static char imPermissionRole__doc__[] = "imPermissionRole C implementation";

static PyMethodDef imPermissionRole_methods[] = {
	{"__of__",
		(PyCFunction)imPermissionRole_of,
		METH_VARARGS,
		""
	},
	{ NULL, NULL }
};

static PySequenceMethods imSequenceMethods = {
	(inquiry) imPermissionRole_length,	/* sq_length	*/
	(binaryfunc) NULL,			/* sq_concat	*/
	(intargfunc) NULL,			/* sq_repeat	*/
	(intargfunc) imPermissionRole_get,	/* sq_item	*/
	(intintargfunc) NULL,			/* sq_slice	*/
	(intobjargproc)  NULL,			/* sq_ass_item	*/
	(intintobjargproc) NULL,		/* sq_ass_slice */
	(objobjproc) NULL,			/* sq_contains	*/
	(binaryfunc) NULL,			/* sq_inplace_concat */
	(intargfunc) NULL			/* sq_inplace_repeat */
};

static PyExtensionClass imPermissionRoleType = {
	PyObject_HEAD_INIT(NULL) 0,
	"imPermissionRole",			/* tp_name	*/
	sizeof(imPermissionRole),		/* tp_basicsize	*/
	0,					/* tp_itemsize	*/
	/* Standard methods 	*/
	(destructor) imPermissionRole_dealloc,	/* tp_dealloc	*/
	NULL,					/* tp_print	*/
	NULL,					/* tp_getattr	*/
	NULL,	                                /* tp_setattr	*/
	NULL,					/* tp_compare	*/
	NULL,					/* tp_repr	*/
	/* Method suites	*/
	NULL,					/* tp_as_number	*/
	&amp;imSequenceMethods,			/* tp_as_sequence*/
	NULL,			                /* tp_as_mapping */
	/* More standard ops  	*/
	NULL,					/* tp_hash	*/
	NULL,					/* tp_call	*/
	NULL,					/* tp_str	*/
	NULL,					/* tp_getattro	*/
	NULL,					/* tp_setattro	*/
	/* Reserved fields	*/
	0,					/* tp_xxx3	*/
	0,					/* tp_xxx4	*/
	/* Docstring		*/
	imPermissionRole__doc__,		/* tp_doc	*/
#ifdef COUNT_ALLOCS
	0,					/* tp_alloc	*/
	0,					/* tp_free	*/
	0,					/* tp_maxalloc	*/
	NULL,					/* tp_next	*/
#endif
	METHOD_CHAIN(imPermissionRole_methods), /* methods	*/
	EXTENSIONCLASS_BINDABLE_FLAG,		/* flags	*/
};
</t>
<t tx="ekr.20040106170026">static PyObject *Containers = NULL;
static PyObject *Unauthorized = NULL;
static PyObject *LOG = NULL;
static PyObject *PROBLEM = NULL;
static PyObject *NoSequenceFormat = NULL;
static PyObject *_what_not_even_god_should_do = NULL;
static PyObject *Anonymous = NULL;
static PyObject *AnonymousTuple = NULL;
static PyObject *imPermissionRoleObj = NULL;
static PyObject *defaultPermission = NULL;
static PyObject *__roles__ = NULL;
static PyObject *__of__ = NULL;
static PyObject *__allow_access_to_unprotected_subobjects__ = NULL;
static PyObject *stack_str = NULL;
static PyObject *user_str = NULL;
static PyObject *validate_str = NULL;
static PyObject *_proxy_roles_str = NULL;
static PyObject *allowed_str = NULL;
static PyObject *getOwner_str = NULL;
static PyObject *checkPermission_str = NULL;
static PyObject *getSecurityManager = NULL;
static PyObject *aq_validate = NULL;
static int ownerous = 1;
static int authenticated = 1;

</t>
<t tx="ekr.20040106170026.1"></t>
<t tx="ekr.20040106170833">if type(name) is StringType:
    if name.startswith('aq_') and name not in valid_aq_:
        return 0

containerbase = aq_base(container)
accessedbase = aq_base(accessed)
if accessedbase is accessed:
    # accessed is not a wrapper, so assume that the
    # value could not have been acquired.
    accessedbase = container</t>
<t tx="ekr.20040106170833.1"># We have an object without roles and we didn't get a list
# of roles passed in. Presumably, the value is some simple
# object like a string or a list.  We'll try to get roles
# from its container.
if container is None: return 0 # Bail if no container

roles=getattr(container, '__roles__', _noroles)
if roles is _noroles:
    if containerbase is container:
        # Container is not wrapped.
        roles=_noroles
        if containerbase is not accessedbase: return 0
    else:
        # Try to acquire roles
        try: roles = container.aq_acquire('__roles__')
        except AttributeError:
            roles=_noroles
            if containerbase is not accessedbase: return 0

# We need to make sure that we are allowed to
# get unprotected attributes from the container. We are
# allowed for certain simple containers and if the
# container says we can. Simple containers
# may also impose name restrictions.
p=Containers(type(container), None)
if p is None:
    p=getattr(container,
              '__allow_access_to_unprotected_subobjects__', None)

if p is not None:
    tp=type(p)
    if tp is not IntType:
        if tp is DictType:
            p=p.get(name, None)
        else:
            p=p(name, value)

if not p:
    if (containerbase is accessedbase):
        raise Unauthorized(name, value)
    else:
        return 0

if roles is _noroles: return 1

# We are going to need a security-aware object to pass
# to allowed(). We'll use the container.
value=container</t>
<t tx="ekr.20040106170833.2">try:
    if roles is None or 'Anonymous' in roles: return 1
except TypeError:
    # 'roles' isn't a sequence
    LOG('Zope Security Policy', PROBLEM, "'%s' passed as roles"
        " during validation of '%s' is not a sequence." % (
        `roles`, name))
    raise</t>
<t tx="ekr.20040106170833.3">stack=context.stack
if stack:
    eo=stack[-1]

    # If the executable had an owner, can it execute?
    if self._ownerous:
        owner=eo.getOwner()
        if (owner is not None) and not owner.allowed(value, roles):
            # We don't want someone to acquire if they can't
            # get an unacquired!
            if accessedbase is containerbase:
                raise Unauthorized(name, value)
            return 0

    # Proxy roles, which are a lot safer now.
    proxy_roles=getattr(eo, '_proxy_roles', None)
    if proxy_roles:
        for r in proxy_roles:
            if r in roles: return 1

        # Proxy roles actually limit access!
        if accessedbase is containerbase:
            raise Unauthorized(name, value)

        return 0

try:
    if self._authenticated and context.user.allowed(value, roles):
        return 1
except AttributeError: pass</t>
</tnodes>
</leo_file>
