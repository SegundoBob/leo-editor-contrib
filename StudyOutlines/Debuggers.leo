<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="1771" clone_windows="0"/>
<globals body_outline_ratio="0.633385335413">
	<global_window_position top="113" left="245" height="641" width="881"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20060523070341"><vh>Read me or suffer</vh></v>
<v t="ekr.20060521134346"><vh>Idle debugger</vh>
<v t="ekr.20060521134346.32"><vh>leo_run.py</vh>
<v t="ekr.20060521134346.33"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134346.34"><vh>virtual_event_name</vh></v>
<v t="ekr.20060521134346.35"><vh>main</vh></v>
<v t="ekr.20060521134346.36"><vh>manage_socket</vh></v>
<v t="ekr.20060521134346.37"><vh>show_socket_error</vh></v>
<v t="ekr.20060521134346.38"><vh>print_exception</vh></v>
<v t="ekr.20060521134346.39"><vh>cleanup_traceback</vh></v>
<v t="ekr.20060521134346.40"><vh>flush_stdout</vh></v>
<v t="ekr.20060521134346.41"><vh>exit</vh></v>
<v t="ekr.20060521134346.42"><vh>class MyRPCServer</vh>
<v t="ekr.20060521134346.43"><vh>handle_error</vh></v>
</v>
<v t="ekr.20060521134346.44"><vh>class MyHandler</vh>
<v t="ekr.20060521134346.45"><vh>handle</vh></v>
<v t="ekr.20060521134346.46"><vh>exithook</vh></v>
<v t="ekr.20060521134346.47"><vh>EOFhook</vh></v>
<v t="ekr.20060521134346.48"><vh>decode_interrupthook</vh></v>
</v>
<v t="ekr.20060521134346.49"><vh>class Executive</vh>
<v t="ekr.20060521134346.50"><vh>__init__</vh></v>
<v t="ekr.20060521134346.51"><vh>runcode</vh></v>
<v t="ekr.20060521134346.52"><vh>interrupt_the_server</vh></v>
<v t="ekr.20060521134346.53" a="M"><vh>leo_run.Executive.start_the_debugger</vh></v>
<v t="ekr.20060521134346.54"><vh>stop_the_debugger</vh></v>
<v t="ekr.20060521134346.55"><vh>get_the_calltip</vh></v>
<v t="ekr.20060521134346.56"><vh>stackviewer</vh></v>
</v>
</v>
<v t="ekr.20060521134346.57"><vh>leo_RemoteDebugger.py</vh>
<v t="ekr.20060521134346.58"><vh>&lt;&lt; RemoteDebugger docstring &gt;&gt;</vh></v>
<v t="ekr.20060521134346.59"><vh>wrap_frame</vh></v>
<v t="ekr.20060521134346.60"><vh>wrap_info</vh></v>
<v t="ekr.20060521134346.61"><vh>class GUIProxy</vh>
<v t="ekr.20060521134346.62"><vh>__init__</vh></v>
<v t="ekr.20060521134346.63"><vh>interaction</vh></v>
</v>
<v t="ekr.20060521134346.64"><vh>class IdbAdapter</vh>
<v t="ekr.20060521134346.65"><vh>__init__</vh></v>
<v t="ekr.20060521134346.66"><vh>Called by an IdbProxy...</vh>
<v t="ekr.20060521134346.67"><vh>set_step</vh></v>
<v t="ekr.20060521134346.68"><vh>set_quit</vh></v>
<v t="ekr.20060521134346.69"><vh>set_continue</vh></v>
<v t="ekr.20060521134346.70"><vh>set_next</vh></v>
<v t="ekr.20060521134346.71"><vh>set_return</vh></v>
<v t="ekr.20060521134346.72"><vh>get_stack</vh></v>
<v t="ekr.20060521134346.73"><vh>run</vh></v>
<v t="ekr.20060521134346.74"><vh>set_break</vh></v>
<v t="ekr.20060521134346.75"><vh>clear_break</vh></v>
<v t="ekr.20060521134346.76"><vh>clear_all_file_breaks</vh></v>
</v>
<v t="ekr.20060521134346.77"><vh>Called by a FrameProxy...</vh>
<v t="ekr.20060521134346.78"><vh>frame_attr</vh></v>
<v t="ekr.20060521134346.79"><vh>frame_globals</vh></v>
<v t="ekr.20060521134346.80"><vh>frame_locals</vh></v>
<v t="ekr.20060521134346.81"><vh>frame_code</vh></v>
</v>
<v t="ekr.20060521134346.82"><vh>Called by CodeProxy...</vh>
<v t="ekr.20060521134346.83"><vh>code_name</vh></v>
<v t="ekr.20060521134346.84"><vh>code_filename</vh></v>
</v>
<v t="ekr.20060521134346.85"><vh>called by a DictProxy...</vh>
<v t="ekr.20060521134346.86"><vh>dict_keys</vh></v>
<v t="ekr.20060521134346.87"><vh>dict_item</vh></v>
</v>
</v>
<v t="ekr.20060521134346.88"><vh>start_debugger</vh></v>
<v t="ekr.20060521134346.89"><vh>In the Leo process</vh>
<v t="ekr.20060521134346.90"><vh>class FrameProxy</vh>
<v t="ekr.20060521134346.91"><vh>__init__</vh></v>
<v t="ekr.20060521134346.92"><vh>__getattr__</vh></v>
<v t="ekr.20060521134346.93"><vh>_get_f_code</vh></v>
<v t="ekr.20060521134346.94"><vh>_get_f_globals</vh></v>
<v t="ekr.20060521134346.95"><vh>_get_f_locals</vh></v>
<v t="ekr.20060521134346.96"><vh>_get_dict_proxy</vh></v>
</v>
<v t="ekr.20060521134346.97"><vh>class CodeProxy</vh>
<v t="ekr.20060521134346.98"><vh>__init__</vh></v>
<v t="ekr.20060521134346.99"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20060521134346.100"><vh>class DictProxy</vh>
<v t="ekr.20060521134346.101"><vh>__init__</vh></v>
<v t="ekr.20060521134346.102"><vh>keys</vh></v>
<v t="ekr.20060521134346.103"><vh>__getitem__</vh></v>
<v t="ekr.20060521134346.104"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20060521134346.105"><vh>class GUIAdapter</vh>
<v t="ekr.20060521134346.106"><vh>__init__</vh></v>
<v t="ekr.20060521134346.107"><vh>interaction</vh></v>
</v>
<v t="ekr.20060521134346.108"><vh>class IdbProxy</vh>
<v t="ekr.20060521134346.109"><vh>__init__</vh></v>
<v t="ekr.20060521134346.110"><vh>call</vh></v>
<v t="ekr.20060521134346.111"><vh>run</vh></v>
<v t="ekr.20060521134346.112"><vh>get_stack</vh></v>
<v t="ekr.20060521134346.113"><vh>set_continue</vh></v>
<v t="ekr.20060521134346.114"><vh>set_step</vh></v>
<v t="ekr.20060521134346.115"><vh>set_next</vh></v>
<v t="ekr.20060521134346.116"><vh>set_return</vh></v>
<v t="ekr.20060521134346.117"><vh>set_quit</vh></v>
<v t="ekr.20060521134346.118"><vh>set_break</vh></v>
<v t="ekr.20060521134346.119"><vh>clear_break</vh></v>
<v t="ekr.20060521134346.120"><vh>clear_all_file_breaks</vh></v>
</v>
<v t="ekr.20060521134346.121"><vh>start_remote_debugger</vh></v>
<v t="ekr.20060521134346.122"><vh>close_remote_debugger</vh></v>
<v t="ekr.20060521134346.123"><vh>close_subprocess_debugger</vh></v>
<v t="ekr.20060521134346.124"><vh>restart_subprocess_debugger</vh></v>
</v>
</v>
<v t="ekr.20060521134346.125"><vh>leo_Shell.py</vh>
<v t="ekr.20060521134346.126"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134346.127"><vh>class ModifiedInterpreter</vh>
<v t="ekr.20060521134346.128"><vh>__init__</vh></v>
<v t="ekr.20060521134346.129"><vh>spawn_subprocess (sets self.rpcpid)</vh></v>
<v t="ekr.20060521134346.130"><vh>leo_Debugger.build_subprocess_arglist</vh></v>
<v t="ekr.20060521134346.131"><vh>start_subprocess</vh></v>
<v t="ekr.20060521134346.132"><vh>restart_subprocess</vh></v>
<v t="ekr.20060521134346.133"><vh>__request_interrupt</vh></v>
<v t="ekr.20060521134346.134"><vh>interrupt_subprocess</vh></v>
<v t="ekr.20060521134346.135"><vh>kill_subprocess</vh></v>
<v t="ekr.20060521134346.136"><vh>unix_terminate</vh></v>
<v t="ekr.20060521134346.137"><vh>transfer_path</vh></v>
<v t="ekr.20060521134346.138"><vh>poll_subprocess</vh></v>
<v t="ekr.20060521134346.139"><vh>setdebugger</vh></v>
<v t="ekr.20060521134346.140"><vh>getdebugger</vh></v>
<v t="ekr.20060521134346.141"><vh>open_remote_stack_viewer</vh></v>
<v t="ekr.20060521134346.142"><vh>remote_stack_viewer</vh></v>
<v t="ekr.20060521134346.143"><vh>execsource</vh></v>
<v t="ekr.20060521134346.144"><vh>execfile</vh></v>
<v t="ekr.20060521134346.145"><vh>runsource</vh></v>
<v t="ekr.20060521134346.146"><vh>stuffsource</vh></v>
<v t="ekr.20060521134346.147"><vh>prepend_syspath</vh></v>
<v t="ekr.20060521134346.148"><vh>showsyntaxerror</vh></v>
<v t="ekr.20060521134346.149"><vh>unpackerror</vh></v>
<v t="ekr.20060521134346.150"><vh>showtraceback</vh></v>
<v t="ekr.20060521134346.151"><vh>checklinecache</vh></v>
<v t="ekr.20060521134346.152"><vh>runcommand</vh></v>
<v t="ekr.20060521134346.153"><vh>runcode</vh></v>
<v t="ekr.20060521134346.154"><vh>write</vh></v>
<v t="ekr.20060521134346.155"><vh>display_port_binding_error</vh></v>
<v t="ekr.20060521134346.156"><vh>display_no_subprocess_error</vh></v>
<v t="ekr.20060521134346.157"><vh>display_executing_dialog</vh></v>
<v t="ekr.20060521134346.158"><vh>close_debugger OVERRIDE</vh></v>
</v>
<v t="ekr.20060521134346.159"><vh>class MyRPCClient</vh>
<v t="ekr.20060521134346.160"><vh>handle_EOF</vh></v>
</v>
</v>
<v t="ekr.20060521134346.161"><vh>leo_Debugger.py</vh>
<v t="ekr.20060521134346.162"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134346.163"><vh>go</vh></v>
<v t="ekr.20060521134346.164"><vh>open_debugger</vh></v>
<v t="ekr.20060521134346.165"><vh>class dummyShell</vh></v>
<v t="ekr.20060521134346.166"><vh>class Idb (used by remote debugger code)</vh>
<v t="ekr.20060521134346.167"><vh>__init__</vh></v>
<v t="ekr.20060521134346.168"><vh>user_line</vh></v>
<v t="ekr.20060521134346.169"><vh>user_exception</vh></v>
<v t="ekr.20060521134346.170"><vh>in_rpc_code</vh></v>
<v t="ekr.20060521134346.171"><vh>__frame2message</vh></v>
</v>
<v t="ekr.20060521134346.172"><vh>class StackViewer</vh>
<v t="ekr.20060521134346.173"><vh>__init__</vh></v>
<v t="ekr.20060521134346.174"><vh>load_stack</vh></v>
<v t="ekr.20060521134346.175"><vh>popup_event</vh></v>
<v t="ekr.20060521134346.176"><vh>fill_menu</vh></v>
<v t="ekr.20060521134346.177"><vh>on_select</vh></v>
<v t="ekr.20060521134346.178"><vh>on_double</vh></v>
<v t="ekr.20060521134346.179"><vh>goto_source_line</vh></v>
<v t="ekr.20060521134346.180"><vh>show_stack_frame</vh></v>
<v t="ekr.20060521134346.181"><vh>show_source</vh></v>
</v>
<v t="ekr.20060521134346.182"><vh>class NamespaceViewer</vh>
<v t="ekr.20060521134346.183"><vh>__init__</vh></v>
<v t="ekr.20060521134346.184"><vh>load_dict</vh></v>
<v t="ekr.20060521134346.185"><vh>close</vh></v>
</v>
<v t="ekr.20060521134346.186"><vh>class Debugger</vh>
<v t="ekr.20060521134346.187"><vh>Birth</vh>
<v t="ekr.20060521134346.188"><vh>__init__</vh></v>
<v t="ekr.20060521134346.189"><vh>make_gui</vh>
<v t="ekr.20060521134346.190"><vh>&lt;&lt; create the top level frame &gt;&gt;</vh></v>
<v t="ekr.20060521134346.191"><vh>&lt;&lt; create the control buttons &gt;&gt;</vh></v>
<v t="ekr.20060521134346.192"><vh>&lt;&lt; create the check boxes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060521134346.193"><vh>run</vh></v>
<v t="ekr.20060521134346.194"><vh>close</vh></v>
<v t="ekr.20060521134346.195"><vh>interaction</vh></v>
<v t="ekr.20060521134346.196"><vh>sync_source_line (used flist)</vh></v>
<v t="ekr.20060521134346.197"><vh>__frame2fileline</vh></v>
<v t="ekr.20060521134346.198"><vh>Callbacks</vh>
<v t="ekr.20060521134346.199"><vh>cont</vh></v>
<v t="ekr.20060521134346.200"><vh>step</vh></v>
<v t="ekr.20060521134346.201"><vh>next</vh></v>
<v t="ekr.20060521134346.202"><vh>ret</vh></v>
<v t="ekr.20060521134346.203"><vh>quit</vh></v>
</v>
<v t="ekr.20060521134346.204"><vh>refresh</vh>
<v t="ekr.20060521134346.205"><vh>show_stack</vh></v>
<v t="ekr.20060521134346.206"><vh>show_source</vh></v>
<v t="ekr.20060521134346.207"><vh>show_frame</vh></v>
<v t="ekr.20060521134346.208"><vh>show_locals</vh></v>
<v t="ekr.20060521134346.209"><vh>show_globals</vh></v>
<v t="ekr.20060521134346.210"><vh>show_variables</vh></v>
</v>
<v t="ekr.20060521134346.211"><vh>breakpoints</vh>
<v t="ekr.20060521134346.212"><vh>set_breakpoint_here</vh></v>
<v t="ekr.20060521134346.213"><vh>clear_breakpoint_here</vh></v>
<v t="ekr.20060521134346.214"><vh>clear_file_breaks</vh></v>
<v t="ekr.20060521134346.215"><vh>load_breakpoints</vh></v>
</v>
</v>
</v>
<v t="ekr.20060521134346.216"><vh>leo_FileList.py</vh>
<v t="ekr.20060521134346.217"><vh>class FileList</vh>
<v t="ekr.20060521134346.218"><vh>__init__</vh></v>
<v t="ekr.20060521134346.219"><vh>open</vh></v>
<v t="ekr.20060521134346.220"><vh>gotofileline</vh></v>
<v t="ekr.20060521134346.221"><vh>new</vh></v>
<v t="ekr.20060521134346.222"><vh>close_all_callback</vh></v>
<v t="ekr.20060521134346.223"><vh>close_edit</vh></v>
<v t="ekr.20060521134346.224"><vh>filename_changed_edit</vh></v>
<v t="ekr.20060521134346.225"><vh>canonize</vh></v>
</v>
<v t="ekr.20060521134346.226"><vh>_test</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1227"><vh>pgd</vh>
<v t="ekr.20060521134315.1228"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1229"><vh>Modules that do *not* import rpdb2</vh>
<v t="ekr.20060521134315.1230"><vh>breakpointviewer.py</vh>
<v t="ekr.20060521134315.1231"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1232"><vh>class Breakpoint</vh>
<v t="ekr.20060521134315.1233"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1234"><vh>get_color</vh></v>
<v t="ekr.20060521134315.1235"><vh>get_disabled_text</vh></v>
</v>
<v t="ekr.20060521134315.1236"><vh>class BreakpointViewer</vh>
<v t="ekr.20060521134315.1237"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1238"><vh>update_bp</vh></v>
<v t="ekr.20060521134315.1239"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1240"><vh>_create_actions</vh></v>
<v t="ekr.20060521134315.1241"><vh>_create_popup</vh></v>
<v t="ekr.20060521134315.1242"><vh>_get_all_index_rows</vh></v>
<v t="ekr.20060521134315.1243"><vh>_get_all_bps</vh></v>
<v t="ekr.20060521134315.1244"><vh>_set_breakpoint_enabled_status</vh></v>
<v t="ekr.20060521134315.1245"><vh>on_tree__double_clicked</vh></v>
<v t="ekr.20060521134315.1246"><vh>on_tree__right_clicked</vh></v>
<v t="ekr.20060521134315.1247"><vh>on_dis_act__activate</vh></v>
<v t="ekr.20060521134315.1248"><vh>on_en_act__activate</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1249"><vh>components.py</vh>
<v t="ekr.20060521134315.1250"><vh>class PGDSlaveDelegate</vh>
<v t="ekr.20060521134315.1251"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1252"><vh>get_session_manager</vh></v>
<v t="ekr.20060521134315.1253"><vh>update_state</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1254"><vh>hig.py</vh>
<v t="ekr.20060521134315.1255"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1256"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1257"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1258"><vh>class WidgetCostumizer</vh>
<v t="ekr.20060521134315.1259"><vh>&lt;&lt; class WidgetCostumizer declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1260"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1261"><vh>_get_next</vh></v>
<v t="ekr.20060521134315.1262"><vh>update</vh></v>
<v t="ekr.20060521134315.1263"><vh>_run</vh></v>
<v t="ekr.20060521134315.1264"><vh>bind</vh></v>
<v t="ekr.20060521134315.1265"><vh>_call</vh></v>
<v t="ekr.20060521134315.1266"><vh>__call__</vh></v>
</v>
<v t="ekr.20060521134315.1267"><vh>class SetupScrolledWindow</vh>
<v t="ekr.20060521134315.1268"><vh>_run</vh></v>
</v>
<v t="ekr.20060521134315.1269"><vh>class SetupLabel</vh>
<v t="ekr.20060521134315.1270"><vh>_run</vh></v>
</v>
<v t="ekr.20060521134315.1271"><vh>dialog_decorator</vh></v>
<v t="ekr.20060521134315.1272"><vh>class SetupDialog</vh>
<v t="ekr.20060521134315.1273"><vh>_run</vh></v>
</v>
<v t="ekr.20060521134315.1274"><vh>class SetupAlert</vh>
<v t="ekr.20060521134315.1275"><vh>class _PrimaryTextDecorator</vh>
<v t="ekr.20060521134315.1276"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1277"><vh>__call__</vh></v>
</v>
<v t="ekr.20060521134315.1278"><vh>_setup</vh></v>
<v t="ekr.20060521134315.1279"><vh>_run</vh></v>
</v>
<v t="ekr.20060521134315.1280"><vh>class SetupListAlertTemplate</vh>
<v t="ekr.20060521134315.1281"><vh>get_list_title</vh></v>
<v t="ekr.20060521134315.1282"><vh>configure_widgets</vh></v>
<v t="ekr.20060521134315.1283"><vh>create_store</vh></v>
<v t="ekr.20060521134315.1284"><vh>_setup</vh></v>
</v>
<v t="ekr.20060521134315.1285"><vh>class SetupFileListSaveAlert</vh>
<v t="ekr.20060521134315.1286"><vh>on_toggle</vh></v>
<v t="ekr.20060521134315.1287"><vh>get_list_title</vh></v>
<v t="ekr.20060521134315.1288"><vh>configure_widgets</vh></v>
<v t="ekr.20060521134315.1289"><vh>create_store</vh></v>
</v>
<v t="ekr.20060521134315.1290"><vh>class SetupListAlert</vh>
<v t="ekr.20060521134315.1291"><vh>get_list_title</vh></v>
<v t="ekr.20060521134315.1292"><vh>configure_widgets</vh></v>
<v t="ekr.20060521134315.1293"><vh>create_store</vh></v>
</v>
<v t="ekr.20060521134315.1294"><vh>class RunDialog</vh>
<v t="ekr.20060521134315.1295"><vh>_run</vh></v>
</v>
<v t="ekr.20060521134315.1296"><vh>hig_alert</vh></v>
<v t="ekr.20060521134315.1297"><vh>humanize_seconds</vh></v>
<v t="ekr.20060521134315.1298"><vh>class _TimeUpdater</vh>
<v t="ekr.20060521134315.1299"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1300"><vh>set_dialog</vh></v>
<v t="ekr.20060521134315.1301"><vh>on_response</vh></v>
<v t="ekr.20060521134315.1302"><vh>get_text</vh></v>
<v t="ekr.20060521134315.1303"><vh>on_tick</vh></v>
</v>
<v t="ekr.20060521134315.1304"><vh>save_changes</vh></v>
<v t="ekr.20060521134315.1305"><vh>list_dialog</vh></v>
<v t="ekr.20060521134315.1306"><vh>class HigProgress</vh>
<v t="ekr.20060521134315.1307"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1308"><vh>set_primary_text</vh></v>
<v t="ekr.20060521134315.1309"><vh>set_secondary_text</vh></v>
<v t="ekr.20060521134315.1310"><vh>set_progress_fraction</vh></v>
<v t="ekr.20060521134315.1311"><vh>get_progress_fraction</vh></v>
<v t="ekr.20060521134315.1312"><vh>set_progress_text</vh></v>
<v t="ekr.20060521134315.1313"><vh>set_sub_progress_text</vh></v>
<v t="ekr.20060521134315.1314"><vh>_on_close</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1315"><vh>icons.py</vh>
<v t="ekr.20060521134315.1316"><vh>set_stock_icons</vh></v>
<v t="ekr.20060521134315.1317"><vh>class Icons</vh>
<v t="ekr.20060521134315.1318"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1319"><vh>get</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1320"><vh>kiwiviews.py</vh>
<v t="ekr.20060521134315.1321"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1322"><vh>class PythonViewMixin</vh>
<v t="ekr.20060521134315.1323"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1324"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1325"><vh>add_widget</vh></v>
<v t="ekr.20060521134315.1326"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1327"><vh>set_model</vh></v>
<v t="ekr.20060521134315.1328"><vh>model_changed</vh></v>
</v>
<v t="ekr.20060521134315.1329"><vh>class PythonSlaveDelegate</vh>
<v t="ekr.20060521134315.1330"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.1331"><vh>class PythonView</vh>
<v t="ekr.20060521134315.1332"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.1333"><vh>class PythonDelegate</vh>
<v t="ekr.20060521134315.1334"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1335"><vh>main.py</vh>
<v t="ekr.20060521134315.1336"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="ekr.20060521134315.1337"><vh>class Application</vh>
<v t="ekr.20060521134315.1338"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1339"><vh>launch</vh></v>
<v t="ekr.20060521134315.1340"><vh>update_threads</vh></v>
<v t="ekr.20060521134315.1341"><vh>update_thread_broken</vh></v>
<v t="ekr.20060521134315.1342"><vh>update_no_threads</vh></v>
<v t="ekr.20060521134315.1343"><vh>update_state</vh></v>
<v t="ekr.20060521134315.1344"><vh>update_frame</vh></v>
<v t="ekr.20060521134315.1345"><vh>update_stack</vh></v>
<v t="ekr.20060521134315.1346"><vh>update_source</vh></v>
<v t="ekr.20060521134315.1347"><vh>update_namespace</vh></v>
<v t="ekr.20060521134315.1348"><vh>update_bp</vh></v>
</v>
<v t="ekr.20060521134315.1349"><vh>start</vh></v>
<v t="ekr.20060521134315.1350"><vh>embed</vh></v>
<v t="ekr.20060521134315.1351"><vh>main</vh></v>
</v>
<v t="ekr.20060521134315.1352"><vh>mainwindow.py</vh>
<v t="ekr.20060521134315.1353"><vh>&lt;&lt;imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1354"><vh>class NiceNotebook</vh>
<v t="ekr.20060521134315.1355"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.1356"><vh>pack_container</vh></v>
<v t="ekr.20060521134315.1357"><vh>class MainWindow</vh>
<v t="ekr.20060521134315.1358"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1359"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1360"><vh>on_window__delete_event</vh></v>
<v t="ekr.20060521134315.1361"><vh>on_command__activate</vh></v>
<v t="ekr.20060521134315.1362"><vh>attach_slaves</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1363"><vh>namespaceviewer.py</vh>
<v t="ekr.20060521134315.1364"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="ekr.20060521134315.1365"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1366"><vh>get_pixbuf</vh></v>
<v t="ekr.20060521134315.1367"><vh>class NamespaceItem</vh>
<v t="ekr.20060521134315.1368"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1369"><vh>get_markup</vh></v>
<v t="ekr.20060521134315.1370"><vh>get_pixbuf</vh></v>
</v>
<v t="ekr.20060521134315.1371"><vh>class NamespaceTree</vh>
<v t="ekr.20060521134315.1372"><vh>&lt;&lt; class NamespaceTree declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.1373"><vh>class NamespaceViewer</vh>
<v t="ekr.20060521134315.1374"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1375"><vh>update_namespace</vh></v>
<v t="ekr.20060521134315.1376"><vh>on_tree_view__row_expanded</vh></v>
<v t="ekr.20060521134315.1377"><vh>get_root_expr</vh></v>
</v>
<v t="ekr.20060521134315.1378"><vh>class GlobalsViewer</vh>
<v t="ekr.20060521134315.1379"><vh>get_root_expr</vh></v>
<v t="ekr.20060521134315.1380"><vh>attach_slaves</vh></v>
</v>
<v t="ekr.20060521134315.1381"><vh>class LocalsViewer</vh>
<v t="ekr.20060521134315.1382"><vh>get_root_expr</vh></v>
<v t="ekr.20060521134315.1383"><vh>attach_slaves</vh></v>
</v>
<v t="ekr.20060521134315.1384"><vh>class AllNamespaceViewer</vh>
<v t="ekr.20060521134315.1385"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1386"><vh>_create_big_label</vh></v>
<v t="ekr.20060521134315.1387"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1388"><vh>update_namespace</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1389"><vh>sanity.py</vh>
<v t="ekr.20060521134315.1390"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1391"><vh>console_exit</vh></v>
<v t="ekr.20060521134315.1392"><vh>gui_exit</vh></v>
</v>
<v t="ekr.20060521134315.1393"><vh>sourceviewer.py</vh>
<v t="ekr.20060521134315.1394"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1395"><vh>class SVBuffer</vh>
<v t="ekr.20060521134315.1396"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1397"><vh>load_from_file</vh></v>
</v>
<v t="ekr.20060521134315.1398"><vh>class SVView</vh>
<v t="ekr.20060521134315.1399"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1400"><vh>on_bp_event</vh></v>
<v t="ekr.20060521134315.1401"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.1402"><vh>set_background_color</vh></v>
<v t="ekr.20060521134315.1403"><vh>set_font_color</vh></v>
<v t="ekr.20060521134315.1404"><vh>set_font</vh></v>
</v>
<v t="ekr.20060521134315.1405"><vh>class SourceViewer</vh>
<v t="ekr.20060521134315.1406"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1407"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1408"><vh>goto</vh></v>
<v t="ekr.20060521134315.1409"><vh>_open_file</vh></v>
<v t="ekr.20060521134315.1410"><vh>create_widget</vh></v>
<v t="ekr.20060521134315.1411"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.1412"><vh>remove_breakpoint</vh></v>
<v t="ekr.20060521134315.1413"><vh>_goto_line</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1414"><vh>stackviewer.py</vh>
<v t="ekr.20060521134315.1415"><vh>&lt;&lt; imports&gt;&gt;</vh></v>
<v t="ekr.20060521134315.1416"><vh>class StackItem</vh>
<v t="ekr.20060521134315.1417"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1418"><vh>get_color</vh></v>
<v t="ekr.20060521134315.1419"><vh>get_icon</vh></v>
</v>
<v t="ekr.20060521134315.1420"><vh>class StackViewer</vh>
<v t="ekr.20060521134315.1421"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1422"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1423"><vh>update_stack</vh></v>
<v t="ekr.20060521134315.1424"><vh>select_frame</vh></v>
<v t="ekr.20060521134315.1425"><vh>on_tree__double_clicked</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1426"><vh>toolbar.py</vh>
<v t="ekr.20060521134315.1427"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="ekr.20060521134315.1428"><vh>class Toolbar</vh>
<v t="ekr.20060521134315.1429"><vh>_create_uim</vh></v>
<v t="ekr.20060521134315.1430"><vh>update_state</vh></v>
<v t="ekr.20060521134315.1431"><vh>on_reload</vh></v>
<v t="ekr.20060521134315.1432"><vh>on_step</vh></v>
<v t="ekr.20060521134315.1433"><vh>on_go</vh></v>
<v t="ekr.20060521134315.1434"><vh>on_return</vh></v>
<v t="ekr.20060521134315.1435"><vh>on_break</vh></v>
<v t="ekr.20060521134315.1436"><vh>on_next</vh></v>
<v t="ekr.20060521134315.1437"><vh>on_launch</vh></v>
<v t="ekr.20060521134315.1438"><vh>on_stop</vh></v>
<v t="ekr.20060521134315.1439"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1440"><vh>attach_slaves</vh></v>
</v>
<v t="ekr.20060521134315.1441"><vh>class StatusBar</vh>
<v t="ekr.20060521134315.1442"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1443"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1444"><vh>update_running_status</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1445"><vh>tree.py</vh>
<v t="ekr.20060521134315.1446"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1447"><vh>class TreeItem</vh>
<v t="ekr.20060521134315.1448"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1449"><vh>__get_markup</vh></v>
<v t="ekr.20060521134315.1450"><vh>__get_key</vh></v>
<v t="ekr.20060521134315.1451"><vh>__get_value</vh></v>
</v>
<v t="ekr.20060521134315.1452"><vh>class QuestionBox</vh>
<v t="ekr.20060521134315.1453"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1454"><vh>cb_toolbar_clicked</vh></v>
<v t="ekr.20060521134315.1455"><vh>question</vh></v>
</v>
<v t="ekr.20060521134315.1456"><vh>class Tree</vh>
<v t="ekr.20060521134315.1457"><vh>&lt;&lt; class Tree declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1458"><vh>do_get_property</vh></v>
<v t="ekr.20060521134315.1459"><vh>do_set_property</vh></v>
<v t="ekr.20060521134315.1460"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1461"><vh>__init_view</vh></v>
<v t="ekr.20060521134315.1462"><vh>__init_model</vh></v>
<v t="ekr.20060521134315.1463"><vh>__init_signals</vh></v>
<v t="ekr.20060521134315.1464"><vh>__init_renderers</vh></v>
<v t="ekr.20060521134315.1465"><vh>add_item</vh></v>
<v t="ekr.20060521134315.1466"><vh>__get_markup</vh></v>
<v t="ekr.20060521134315.1467"><vh>add_items</vh></v>
<v t="ekr.20060521134315.1468"><vh>clear</vh></v>
<v t="ekr.20060521134315.1469"><vh>del_item</vh></v>
<v t="ekr.20060521134315.1470"><vh>set_items</vh></v>
<v t="ekr.20060521134315.1471"><vh>question</vh></v>
<v t="ekr.20060521134315.1472"><vh>sort_by</vh></v>
<v t="ekr.20060521134315.1473"><vh>__get_model</vh></v>
<v t="ekr.20060521134315.1474"><vh>__get_view</vh></v>
<v t="ekr.20060521134315.1475"><vh>__get_selected</vh></v>
<v t="ekr.20060521134315.1476"><vh>get_selected_key</vh></v>
<v t="ekr.20060521134315.1477"><vh>set_selected</vh></v>
<v t="ekr.20060521134315.1478"><vh>__get_selected_iter</vh></v>
<v t="ekr.20060521134315.1479"><vh>__get_selected_path</vh></v>
<v t="ekr.20060521134315.1480"><vh>__get</vh></v>
<v t="ekr.20060521134315.1481"><vh>__set</vh></v>
<v t="ekr.20060521134315.1482"><vh>cb_toolbar_clicked</vh></v>
<v t="ekr.20060521134315.1483"><vh>cb_sortcombo_changed</vh></v>
<v t="ekr.20060521134315.1484"><vh>cb_sortdir_toggled</vh></v>
<v t="ekr.20060521134315.1485"><vh>__user_initiated_sort</vh></v>
</v>
<v t="ekr.20060521134315.1486"><vh>class IconTreeItem</vh>
<v t="ekr.20060521134315.1487"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1488"><vh>get_icon</vh></v>
<v t="ekr.20060521134315.1489"><vh>get_pixbuf</vh></v>
</v>
<v t="ekr.20060521134315.1490"><vh>class IconTree</vh>
<v t="ekr.20060521134315.1491"><vh>&lt;&lt; class IconTree declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1492"><vh>add_item</vh></v>
</v>
<v t="ekr.20060521134315.1493"><vh>class ToggleTree</vh>
<v t="ekr.20060521134315.1494"><vh>&lt;&lt; class ToggleTree declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1495"><vh>add_item</vh></v>
</v>
<v t="ekr.20060521134315.1496"><vh>test</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1497"><vh>Modules that *do* import rpdb2</vh>
<v t="ekr.20060521134315.1498"><vh>console.py</vh>
<v t="ekr.20060521134315.1499"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1500"><vh>class Terminal</vh>
<v t="ekr.20060521134315.1501"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1502"><vh>feed</vh></v>
</v>
<v t="ekr.20060521134315.1503"><vh>class InputTerminal</vh>
<v t="ekr.20060521134315.1504"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1505"><vh>on_terminal__commit</vh></v>
<v t="ekr.20060521134315.1506"><vh>_process_readbuf</vh></v>
</v>
<v t="ekr.20060521134315.1507"><vh>class Console</vh>
<v t="ekr.20060521134315.1508"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1509"><vh>_create_console</vh></v>
<v t="ekr.20060521134315.1510"><vh>start</vh></v>
<v t="ekr.20060521134315.1511"><vh>write</vh></v>
<v t="ekr.20060521134315.1512"><vh>feed</vh></v>
<v t="ekr.20060521134315.1513"><vh>_create_view</vh></v>
<v t="ekr.20060521134315.1514"><vh>received_line</vh></v>
<v t="ekr.20060521134315.1515"><vh>readline</vh></v>
<v t="ekr.20060521134315.1516"><vh>flush</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1517"><vh>debugsession.py (imports rpdb2)</vh>
<v t="ekr.20060521134315.1518"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1519"><vh>get_debugee_script_path</vh></v>
<v t="ekr.20060521134315.1520"><vh>class SessionManagerInternal (rpdb2.CSessionManagerInternal)</vh>
<v t="ekr.20060521134315.1521"><vh>_spawn_server</vh></v>
</v>
<v t="ekr.20060521134315.1522"><vh>class SessionManager (rpdb2.CSessionManager)</vh>
<v t="ekr.20060521134315.1523"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1524"><vh>_create_smi</vh></v>
<v t="ekr.20060521134315.1525"><vh>_create_view</vh></v>
<v t="ekr.20060521134315.1526"><vh>fork_command</vh></v>
<v t="ekr.20060521134315.1527"><vh>launch_filename</vh></v>
</v>
<v t="ekr.20060521134315.1528"><vh>class RunningOptions</vh>
<v t="ekr.20060521134315.1529"><vh>set_options</vh></v>
</v>
<v t="ekr.20060521134315.1530"><vh>connect_events</vh></v>
<v t="ekr.20060521134315.1531"><vh>start</vh></v>
<v t="ekr.20060521134315.1532"><vh>main</vh></v>
<v t="ekr.20060521134315.1533"><vh>start_as_cl</vh></v>
</v>
<v t="ekr.20060521134315.1534"><vh>threadviewer.py (imports rpdb2)</vh>
<v t="ekr.20060521134315.1535"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.1536"><vh>class ThreadItem</vh>
<v t="ekr.20060521134315.1537"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1538"><vh>get_broken_text</vh></v>
<v t="ekr.20060521134315.1539"><vh>get_pixbuf</vh></v>
</v>
<v t="ekr.20060521134315.1540"><vh>class ThreadsViewer (PGDSlaveDelegate)</vh>
<v t="ekr.20060521134315.1541"><vh>create_toplevel_widget</vh></v>
<v t="ekr.20060521134315.1542"><vh>attach_slaves</vh></v>
<v t="ekr.20060521134315.1543"><vh>update_threads</vh></v>
<v t="ekr.20060521134315.1544"><vh>broken_thread</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060521134315.368"><vh>winpdb</vh>
<v t="ekr.20060521134315.369"><vh>rpdb2.py</vh>
<v t="ekr.20060521134315.370"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20060521134315.371"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.372"><vh>Module level</vh>
<v t="ekr.20060521134315.373"><vh>start_embedded_debugger</vh>
<v t="ekr.20060521134315.374"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.375"><vh>start_embedded_debugger_interactive_password</vh></v>
<v t="ekr.20060521134315.376"><vh>settrace</vh></v>
</v>
<v t="ekr.20060521134315.377"><vh>Interfaces...</vh>
<v t="ekr.20060521134315.378"><vh>get_version</vh></v>
<v t="ekr.20060521134315.379"><vh>get_interface_compatibility_version</vh></v>
<v t="ekr.20060521134315.380"><vh>class CSimpleSessionManager</vh>
<v t="ekr.20060521134315.381"><vh>__init__</vh></v>
<v t="ekr.20060521134315.382"><vh>launch</vh></v>
<v t="ekr.20060521134315.383"><vh>request_go</vh></v>
<v t="ekr.20060521134315.384"><vh>detach</vh></v>
<v t="ekr.20060521134315.385"><vh>stop_debuggee</vh></v>
<v t="ekr.20060521134315.386"><vh>get_session_manager</vh></v>
<v t="ekr.20060521134315.387"><vh>prepare_attach</vh></v>
<v t="ekr.20060521134315.388"><vh>unhandled_exception_callback</vh></v>
<v t="ekr.20060521134315.389"><vh>script_about_to_terminate_callback</vh></v>
<v t="ekr.20060521134315.390"><vh>script_terminated_callback</vh></v>
<v t="ekr.20060521134315.391"><vh>Private methods</vh>
<v t="ekr.20060521134315.392"><vh>__state_calback</vh></v>
<v t="ekr.20060521134315.393"><vh>__termination_callback</vh></v>
<v t="ekr.20060521134315.394"><vh>__get_termination_lineno</vh></v>
</v>
</v>
<v t="ekr.20060521134315.395"><vh>class CSessionManager</vh>
<v t="ekr.20060521134315.396"><vh>__init__</vh></v>
<v t="ekr.20060521134315.397"><vh>report_exception</vh></v>
<v t="ekr.20060521134315.398"><vh>set_printer</vh></v>
<v t="ekr.20060521134315.399"><vh>register_callback</vh></v>
<v t="ekr.20060521134315.400"><vh>remove_callback</vh></v>
<v t="ekr.20060521134315.401"><vh>refresh</vh></v>
<v t="ekr.20060521134315.402"><vh>launch_nothrow</vh></v>
<v t="ekr.20060521134315.403"><vh>launch</vh></v>
<v t="ekr.20060521134315.404"><vh>attach_nothrow</vh></v>
<v t="ekr.20060521134315.405"><vh>attach</vh></v>
<v t="ekr.20060521134315.406"><vh>detach</vh></v>
<v t="ekr.20060521134315.407"><vh>request_break</vh></v>
<v t="ekr.20060521134315.408"><vh>request_go</vh></v>
<v t="ekr.20060521134315.409"><vh>request_go_breakpoint</vh></v>
<v t="ekr.20060521134315.410"><vh>request_step</vh></v>
<v t="ekr.20060521134315.411"><vh>request_next</vh></v>
<v t="ekr.20060521134315.412"><vh>request_return</vh></v>
<v t="ekr.20060521134315.413"><vh>request_jump</vh></v>
<v t="ekr.20060521134315.414"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.415"><vh>disable_breakpoint</vh></v>
<v t="ekr.20060521134315.416"><vh>enable_breakpoint</vh></v>
<v t="ekr.20060521134315.417"><vh>delete_breakpoint</vh></v>
<v t="ekr.20060521134315.418"><vh>get_breakpoints</vh></v>
<v t="ekr.20060521134315.419"><vh>save_breakpoints</vh></v>
<v t="ekr.20060521134315.420"><vh>load_breakpoints</vh></v>
<v t="ekr.20060521134315.421"><vh>get_stack</vh></v>
<v t="ekr.20060521134315.422"><vh>get_source_file</vh></v>
<v t="ekr.20060521134315.423"><vh>get_source_lines</vh></v>
<v t="ekr.20060521134315.424"><vh>set_frame_index</vh></v>
<v t="ekr.20060521134315.425"><vh>get_frame_index</vh></v>
<v t="ekr.20060521134315.426"><vh>set_analyze</vh></v>
<v t="ekr.20060521134315.427"><vh>set_host</vh></v>
<v t="ekr.20060521134315.428"><vh>get_host</vh></v>
<v t="ekr.20060521134315.429"><vh>calc_server_list</vh></v>
<v t="ekr.20060521134315.430"><vh>get_server_info</vh></v>
<v t="ekr.20060521134315.431"><vh>get_last_debuggee_name_safe</vh></v>
<v t="ekr.20060521134315.432"><vh>get_namespace</vh></v>
<v t="ekr.20060521134315.433"><vh>evaluate</vh></v>
<v t="ekr.20060521134315.434"><vh>execute</vh></v>
<v t="ekr.20060521134315.435"><vh>get_state</vh></v>
<v t="ekr.20060521134315.436"><vh>get_thread_list</vh></v>
<v t="ekr.20060521134315.437"><vh>set_thread</vh></v>
<v t="ekr.20060521134315.438"><vh>set_password</vh></v>
<v t="ekr.20060521134315.439"><vh>get_password</vh></v>
<v t="ekr.20060521134315.440"><vh>get_encryption</vh></v>
<v t="ekr.20060521134315.441"><vh>set_remote</vh></v>
<v t="ekr.20060521134315.442"><vh>get_remote</vh></v>
<v t="ekr.20060521134315.443"><vh>stop_debuggee</vh></v>
</v>
<v t="ekr.20060521134315.444"><vh>class CConsole</vh>
<v t="ekr.20060521134315.445"><vh>__init__</vh></v>
<v t="ekr.20060521134315.446"><vh>start</vh></v>
<v t="ekr.20060521134315.447"><vh>join</vh></v>
<v t="ekr.20060521134315.448"><vh>set_filename</vh></v>
</v>
</v>
<v t="ekr.20060521134315.449"><vh>Exceptions</vh>
<v t="ekr.20060521134315.450"><vh>class CException</vh>
<v t="ekr.20060521134315.451"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.452"><vh>class InvalidScopeName</vh></v>
<v t="ekr.20060521134315.453"><vh>class BadArgument</vh></v>
<v t="ekr.20060521134315.454"><vh>class ThreadNotFound</vh></v>
<v t="ekr.20060521134315.455"><vh>class NoThreads</vh></v>
<v t="ekr.20060521134315.456"><vh>class ThreadDone</vh></v>
<v t="ekr.20060521134315.457"><vh>class DebuggerNotBroken</vh></v>
<v t="ekr.20060521134315.458"><vh>class InvalidFrame</vh></v>
<v t="ekr.20060521134315.459"><vh>class NoExceptionFound</vh></v>
<v t="ekr.20060521134315.460"><vh>class CConnectionException</vh>
<v t="ekr.20060521134315.461"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.462"><vh>class BadVersion</vh>
<v t="ekr.20060521134315.463"><vh>__init__</vh></v>
<v t="ekr.20060521134315.464"><vh>__str__</vh></v>
</v>
<v t="ekr.20060521134315.465"><vh>class UnexpectedData</vh></v>
<v t="ekr.20060521134315.466"><vh>class AlreadyAttached</vh></v>
<v t="ekr.20060521134315.467"><vh>class NotAttached</vh></v>
<v t="ekr.20060521134315.468"><vh>class SpawnUnsupported</vh></v>
<v t="ekr.20060521134315.469"><vh>class UnknownServer</vh></v>
<v t="ekr.20060521134315.470"><vh>class CSecurityException</vh>
<v t="ekr.20060521134315.471"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.472"><vh>class UnsetPassword</vh></v>
<v t="ekr.20060521134315.473"><vh>class EncryptionNotSupported</vh></v>
<v t="ekr.20060521134315.474"><vh>class EncryptionExpected</vh></v>
<v t="ekr.20060521134315.475"><vh>class DecryptionFailure</vh></v>
<v t="ekr.20060521134315.476"><vh>class AuthenticationBadData</vh></v>
<v t="ekr.20060521134315.477"><vh>class AuthenticationFailure</vh></v>
<v t="ekr.20060521134315.478"><vh>class AuthenticationBadIndex</vh>
<v t="ekr.20060521134315.479"><vh>__init__</vh></v>
<v t="ekr.20060521134315.480"><vh>__str__</vh></v>
</v>
</v>
<v t="ekr.20060521134315.481"><vh>Globals</vh></v>
<v t="ekr.20060521134315.482"><vh>General utils</vh>
<v t="ekr.20060521134315.483"><vh>safe_repr</vh></v>
<v t="ekr.20060521134315.484"><vh>safe_repr_limited</vh></v>
<v t="ekr.20060521134315.485"><vh>print_debug</vh></v>
<v t="ekr.20060521134315.486"><vh>split_command_line_path_filename_args</vh></v>
<v t="ekr.20060521134315.487"><vh>split_path</vh></v>
<v t="ekr.20060521134315.488"><vh>my_abspath</vh></v>
<v t="ekr.20060521134315.489"><vh>my_abspath1</vh></v>
<v t="ekr.20060521134315.490"><vh>IsPythonSourceFile</vh></v>
<v t="ekr.20060521134315.491"><vh>FindFile</vh></v>
<v t="ekr.20060521134315.492"><vh>IsFileInPath</vh></v>
<v t="ekr.20060521134315.493"><vh>IsPrefixInEnviron</vh></v>
<v t="ekr.20060521134315.494"><vh>CalcTerminalCommand</vh></v>
<v t="ekr.20060521134315.495"><vh>winlower</vh></v>
<v t="ekr.20060521134315.496"><vh>is_blender_file</vh></v>
<v t="ekr.20060521134315.497"><vh>get_blender_source</vh></v>
<v t="ekr.20060521134315.498"><vh>get_source_line</vh></v>
<v t="ekr.20060521134315.499"><vh>CalcModuleName</vh></v>
<v t="ekr.20060521134315.500"><vh>CalcScriptName</vh></v>
<v t="ekr.20060521134315.501"><vh>_getpid</vh></v>
<v t="ekr.20060521134315.502"><vh>calcURL</vh></v>
<v t="ekr.20060521134315.503"><vh>GetSocketError</vh></v>
<v t="ekr.20060521134315.504"><vh>ControlRate</vh></v>
<v t="ekr.20060521134315.505"><vh>generate_rid</vh></v>
<v t="ekr.20060521134315.506"><vh>generate_random_char</vh></v>
<v t="ekr.20060521134315.507"><vh>generate_random_password</vh></v>
<v t="ekr.20060521134315.508"><vh>is_encryption_supported</vh></v>
<v t="ekr.20060521134315.509"><vh>calc_suffix</vh></v>
<v t="ekr.20060521134315.510"><vh>calc_prefix</vh></v>
<v t="ekr.20060521134315.511"><vh>create_rpdb_settings_folder</vh></v>
<v t="ekr.20060521134315.512"><vh>calc_pwd_file_path</vh></v>
<v t="ekr.20060521134315.513"><vh>create_pwd_file</vh></v>
<v t="ekr.20060521134315.514"><vh>read_pwd_file</vh></v>
<v t="ekr.20060521134315.515"><vh>delete_pwd_file</vh></v>
<v t="ekr.20060521134315.516"><vh>ParseLineEncoding</vh></v>
<v t="ekr.20060521134315.517"><vh>ParseEncoding</vh></v>
</v>
<v t="ekr.20060521134315.518"><vh>Crypto</vh>
<v t="ekr.20060521134315.519"><vh>fix_password</vh></v>
<v t="ekr.20060521134315.520"><vh>class CCrypto</vh>
<v t="ekr.20060521134315.521"><vh>__init__</vh></v>
<v t="ekr.20060521134315.522"><vh>set_index</vh></v>
<v t="ekr.20060521134315.523"><vh>get_max_index</vh></v>
<v t="ekr.20060521134315.524"><vh>is_encrypted</vh></v>
<v t="ekr.20060521134315.525"><vh>do_crypto</vh></v>
<v t="ekr.20060521134315.526"><vh>undo_crypto</vh></v>
<v t="ekr.20060521134315.527"><vh>__encrypt</vh></v>
<v t="ekr.20060521134315.528"><vh>__decrypt</vh></v>
<v t="ekr.20060521134315.529"><vh>__get_next_index</vh></v>
<v t="ekr.20060521134315.530"><vh>__wait_a_little</vh></v>
<v t="ekr.20060521134315.531"><vh>__verify_index</vh></v>
<v t="ekr.20060521134315.532"><vh>__auth_make</vh></v>
<v t="ekr.20060521134315.533"><vh>__auth_verify</vh></v>
</v>
</v>
<v t="ekr.20060521134315.534"><vh>Event manager</vh>
<v t="ekr.20060521134315.535"><vh>class CEvent</vh></v>
<v t="ekr.20060521134315.536"><vh>class CEventExit</vh></v>
<v t="ekr.20060521134315.537"><vh>class CEventSync</vh></v>
<v t="ekr.20060521134315.538"><vh>class CEventState</vh></v>
<v t="ekr.20060521134315.539"><vh>class CEventNamespace</vh></v>
<v t="ekr.20060521134315.540"><vh>class CEventNoThreads</vh></v>
<v t="ekr.20060521134315.541"><vh>class CEventThreads</vh></v>
<v t="ekr.20060521134315.542"><vh>class CEventThreadBroken</vh></v>
<v t="ekr.20060521134315.543"><vh>class CEventStack</vh></v>
<v t="ekr.20060521134315.544"><vh>class CEventStackFrameChange</vh></v>
<v t="ekr.20060521134315.545"><vh>class CEventStackDepth</vh></v>
<v t="ekr.20060521134315.546"><vh>class CEventBreakpoint</vh></v>
<v t="ekr.20060521134315.547"><vh>class CEventDispatcherRecord</vh>
<v t="ekr.20060521134315.548"><vh>__init__</vh></v>
<v t="ekr.20060521134315.549"><vh>is_match</vh></v>
</v>
<v t="ekr.20060521134315.550"><vh>class CEventDispatcher</vh>
<v t="ekr.20060521134315.551"><vh>__init__</vh></v>
<v t="ekr.20060521134315.552"><vh>shutdown</vh></v>
<v t="ekr.20060521134315.553"><vh>register_callback</vh></v>
<v t="ekr.20060521134315.554"><vh>remove_callback</vh></v>
<v t="ekr.20060521134315.555"><vh>fire_events</vh></v>
<v t="ekr.20060521134315.556"><vh>fire_event</vh></v>
<v t="ekr.20060521134315.557"><vh>__fire_er</vh></v>
<v t="ekr.20060521134315.558"><vh>register_chain_override</vh></v>
<v t="ekr.20060521134315.559"><vh>__register_callback_on_chain</vh></v>
<v t="ekr.20060521134315.560"><vh>__remove_dispatcher_record</vh></v>
</v>
<v t="ekr.20060521134315.561"><vh>class CEventQueue</vh>
<v t="ekr.20060521134315.562"><vh>__init__</vh></v>
<v t="ekr.20060521134315.563"><vh>shutdown</vh></v>
<v t="ekr.20060521134315.564"><vh>register_event_types</vh></v>
<v t="ekr.20060521134315.565"><vh>event_handler</vh></v>
<v t="ekr.20060521134315.566"><vh>get_event_index</vh></v>
<v t="ekr.20060521134315.567"><vh>wait_for_event</vh></v>
</v>
<v t="ekr.20060521134315.568"><vh>class CStateManager</vh>
<v t="ekr.20060521134315.569"><vh>__init__</vh></v>
<v t="ekr.20060521134315.570"><vh>shutdown</vh></v>
<v t="ekr.20060521134315.571"><vh>event_handler</vh></v>
<v t="ekr.20060521134315.572"><vh>get_state</vh></v>
<v t="ekr.20060521134315.573"><vh>__add_state</vh></v>
<v t="ekr.20060521134315.574"><vh>__remove_states</vh></v>
<v t="ekr.20060521134315.575"><vh>__calc_min_index</vh></v>
<v t="ekr.20060521134315.576"><vh>__add_waiter</vh></v>
<v t="ekr.20060521134315.577"><vh>__remove_waiter</vh></v>
<v t="ekr.20060521134315.578"><vh>__get_states</vh></v>
<v t="ekr.20060521134315.579"><vh>set_state</vh></v>
<v t="ekr.20060521134315.580"><vh>wait_for_state</vh></v>
<v t="ekr.20060521134315.581"><vh>acquire</vh></v>
<v t="ekr.20060521134315.582"><vh>release</vh></v>
</v>
</v>
<v t="ekr.20060521134315.583"><vh>Break info manager</vh>
<v t="ekr.20060521134315.584"><vh>CalcValidLines</vh></v>
<v t="ekr.20060521134315.585"><vh>class CScopeBreakInfo</vh>
<v t="ekr.20060521134315.586"><vh>__init__</vh></v>
<v t="ekr.20060521134315.587"><vh>CalcScopeLine</vh></v>
<v t="ekr.20060521134315.588"><vh>__str__</vh></v>
</v>
<v t="ekr.20060521134315.589"><vh>class CFileBreakInfo</vh>
<v t="ekr.20060521134315.590"><vh>__init__</vh></v>
<v t="ekr.20060521134315.591"><vh>__CalcSubCodesList</vh></v>
<v t="ekr.20060521134315.592"><vh>__CalcBreakInfoFromSource</vh></v>
<v t="ekr.20060521134315.593"><vh>CalcBreakInfo</vh></v>
<v t="ekr.20060521134315.594"><vh>FindScopeByLineno</vh></v>
<v t="ekr.20060521134315.595"><vh>FindScopeByName</vh></v>
</v>
<v t="ekr.20060521134315.596"><vh>class CBreakInfoManager</vh>
<v t="ekr.20060521134315.597"><vh>__init__</vh></v>
<v t="ekr.20060521134315.598"><vh>addFile</vh></v>
<v t="ekr.20060521134315.599"><vh>getFile</vh></v>
</v>
</v>
<v t="ekr.20060521134315.600"><vh>Breakpoint manager</vh>
<v t="ekr.20060521134315.601" a="E"><vh>class CBreakPoint</vh>
<v t="ekr.20060521134315.602"><vh>__init__</vh></v>
<v t="ekr.20060521134315.603"><vh>calc_enclosing_scope_name</vh></v>
<v t="ekr.20060521134315.604"><vh>enable</vh></v>
<v t="ekr.20060521134315.605"><vh>disable</vh></v>
<v t="ekr.20060521134315.606"><vh>isEnabled</vh></v>
<v t="ekr.20060521134315.607"><vh>__str__</vh></v>
</v>
<v t="ekr.20060521134315.608"><vh>class CBreakPointsManagerProxy</vh>
<v t="ekr.20060521134315.609"><vh>__init__</vh></v>
<v t="ekr.20060521134315.610"><vh>update_bp</vh>
<v t="ekr.20060521134315.611"><vh>&lt;&lt; remove breakpoint &gt;&gt;</vh></v>
<v t="ekr.20060521134315.612"><vh>&lt;&lt; disable breakpoint &gt;&gt;</vh></v>
<v t="ekr.20060521134315.613"><vh>&lt;&lt; enable breakpoint &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.614"><vh>sync</vh></v>
<v t="ekr.20060521134315.615"><vh>clear</vh></v>
<v t="ekr.20060521134315.616"><vh>get_breakpoints</vh></v>
<v t="ekr.20060521134315.617"><vh>get_breakpoint</vh></v>
</v>
<v t="ekr.20060521134315.618"><vh>class CBreakPointsManager</vh>
<v t="ekr.20060521134315.619"><vh>__init__</vh></v>
<v t="ekr.20060521134315.620"><vh>get_active_break_points_by_file</vh></v>
<v t="ekr.20060521134315.621"><vh>__calc_active_break_points_by_file</vh></v>
<v t="ekr.20060521134315.622"><vh>__remove_from_function_list</vh></v>
<v t="ekr.20060521134315.623"><vh>__add_to_function_list</vh></v>
<v t="ekr.20060521134315.624"><vh>get_breakpoint</vh></v>
<v t="ekr.20060521134315.625"><vh>del_temp_breakpoint</vh></v>
<v t="ekr.20060521134315.626"><vh>set_temp_breakpoint</vh></v>
<v t="ekr.20060521134315.627"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.628"><vh>disable_breakpoint</vh></v>
<v t="ekr.20060521134315.629"><vh>enable_breakpoint</vh></v>
<v t="ekr.20060521134315.630"><vh>delete_breakpoint</vh></v>
<v t="ekr.20060521134315.631"><vh>get_breakpoints</vh></v>
</v>
</v>
<v t="ekr.20060521134315.632"><vh>Core debugger</vh>
<v t="ekr.20060521134315.633"><vh>class CCodeContext</vh>
<v t="ekr.20060521134315.634"><vh>__init__</vh></v>
<v t="ekr.20060521134315.635"><vh>is_untraced</vh></v>
<v t="ekr.20060521134315.636"><vh>is_exception_trap_frame</vh></v>
</v>
<v t="ekr.20060521134315.637"><vh>class CDebuggerCoreThread</vh>
<v t="ekr.20060521134315.638"><vh>__init__</vh></v>
<v t="ekr.20060521134315.639"><vh>profile</vh></v>
<v t="ekr.20060521134315.640"><vh>frame_acquire</vh></v>
<v t="ekr.20060521134315.641"><vh>frame_release</vh></v>
<v t="ekr.20060521134315.642"><vh>get_frame</vh></v>
<v t="ekr.20060521134315.643"><vh>get_locals_copy</vh></v>
<v t="ekr.20060521134315.644"><vh>update_locals_copy</vh></v>
<v t="ekr.20060521134315.645"><vh>update_locals</vh></v>
<v t="ekr.20060521134315.646"><vh>__eval_breakpoint</vh></v>
<v t="ekr.20060521134315.647"><vh>set_local_trace</vh></v>
<v t="ekr.20060521134315.648"><vh>set_tracers</vh></v>
<v t="ekr.20060521134315.649"><vh>trace_dispatch_stop</vh></v>
<v t="ekr.20060521134315.650"><vh>trace_dispatch_break</vh></v>
<v t="ekr.20060521134315.651"><vh>trace_dispatch_call</vh></v>
<v t="ekr.20060521134315.652"><vh>trace_dispatch</vh></v>
<v t="ekr.20060521134315.653"><vh>trace_dispatch_trap</vh></v>
<v t="ekr.20060521134315.654"><vh>set_exc_info</vh></v>
<v t="ekr.20060521134315.655"><vh>is_breakpoint</vh></v>
</v>
<v t="ekr.20060521134315.656"><vh>class CDebuggerCore</vh>
<v t="ekr.20060521134315.657"><vh>__init__</vh></v>
<v t="ekr.20060521134315.658"><vh>__del__</vh></v>
<v t="ekr.20060521134315.659"><vh>set_request_go_timer</vh></v>
<v t="ekr.20060521134315.660"><vh>cancel_request_go_timer</vh></v>
<v t="ekr.20060521134315.661"><vh>setbreak</vh></v>
<v t="ekr.20060521134315.662"><vh>settrace</vh></v>
<v t="ekr.20060521134315.663"><vh>stoptrace</vh></v>
<v t="ekr.20060521134315.664"><vh>get_code_context</vh></v>
<v t="ekr.20060521134315.665"><vh>get_current_ctx</vh></v>
<v t="ekr.20060521134315.666"><vh>wait_for_first_thread</vh></v>
<v t="ekr.20060521134315.667"><vh>notify_first_thread</vh></v>
<v t="ekr.20060521134315.668"><vh>set_exception_trap_frame</vh></v>
<v t="ekr.20060521134315.669"><vh>trace_dispatch_init</vh></v>
<v t="ekr.20060521134315.670"><vh>set_all_tracers</vh></v>
<v t="ekr.20060521134315.671"><vh>remove_thread</vh></v>
<v t="ekr.20060521134315.672"><vh>set_break_flag</vh></v>
<v t="ekr.20060521134315.673"><vh>is_break</vh></v>
<v t="ekr.20060521134315.674"><vh>_break</vh></v>
<v t="ekr.20060521134315.675"><vh>notify_thread_broken</vh></v>
<v t="ekr.20060521134315.676"><vh>notify_namespace</vh></v>
<v t="ekr.20060521134315.677"><vh>get_state</vh></v>
<v t="ekr.20060521134315.678"><vh>verify_broken</vh></v>
<v t="ekr.20060521134315.679"><vh>get_current_filename</vh></v>
<v t="ekr.20060521134315.680"><vh>get_threads</vh></v>
<v t="ekr.20060521134315.681"><vh>set_break_dont_lock</vh></v>
<v t="ekr.20060521134315.682"><vh>request_break</vh></v>
<v t="ekr.20060521134315.683"><vh>request_go</vh></v>
<v t="ekr.20060521134315.684"><vh>request_go_breakpoint</vh></v>
<v t="ekr.20060521134315.685"><vh>request_step</vh></v>
<v t="ekr.20060521134315.686"><vh>request_next</vh></v>
<v t="ekr.20060521134315.687"><vh>request_return</vh></v>
<v t="ekr.20060521134315.688"><vh>request_jump</vh></v>
<v t="ekr.20060521134315.689"><vh>set_thread</vh></v>
</v>
<v t="ekr.20060521134315.690"><vh>class CDebuggerEngine (g_debugger is an instance of this class)</vh>
<v t="ekr.20060521134315.691"><vh>__init__</vh></v>
<v t="ekr.20060521134315.692"><vh>__del__</vh></v>
<v t="ekr.20060521134315.693"><vh>atexit</vh></v>
<v t="ekr.20060521134315.694"><vh>sync_with_events</vh></v>
<v t="ekr.20060521134315.695"><vh>wait_for_event</vh></v>
<v t="ekr.20060521134315.696"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.697"><vh>disable_breakpoint</vh></v>
<v t="ekr.20060521134315.698"><vh>enable_breakpoint</vh></v>
<v t="ekr.20060521134315.699"><vh>delete_breakpoint</vh></v>
<v t="ekr.20060521134315.700"><vh>get_breakpoints</vh></v>
<v t="ekr.20060521134315.701"><vh>send_events</vh></v>
<v t="ekr.20060521134315.702"><vh>send_stack_depth</vh></v>
<v t="ekr.20060521134315.703"><vh>send_threads_event</vh></v>
<v t="ekr.20060521134315.704"><vh>send_stack_event</vh></v>
<v t="ekr.20060521134315.705"><vh>send_namespace_event</vh></v>
<v t="ekr.20060521134315.706"><vh>send_no_threads_event</vh></v>
<v t="ekr.20060521134315.707"><vh>__get_stack</vh></v>
<v t="ekr.20060521134315.708"><vh>get_stack</vh></v>
<v t="ekr.20060521134315.709"><vh>get_source_file</vh></v>
<v t="ekr.20060521134315.710"><vh>__get_source</vh></v>
<v t="ekr.20060521134315.711"><vh>get_source_lines</vh></v>
<v t="ekr.20060521134315.712"><vh>__get_locals_globals</vh></v>
<v t="ekr.20060521134315.713"><vh>__is_verbose_attr</vh></v>
<v t="ekr.20060521134315.714"><vh>__is_property_attr</vh></v>
<v t="ekr.20060521134315.715"><vh>__calc_property_list</vh></v>
<v t="ekr.20060521134315.716"><vh>__calc_attribute_list</vh></v>
<v t="ekr.20060521134315.717"><vh>__calc_number_of_subnodes</vh></v>
<v t="ekr.20060521134315.718"><vh>__parse_type</vh></v>
<v t="ekr.20060521134315.719"><vh>__calc_subnodes</vh></v>
<v t="ekr.20060521134315.720"><vh>get_exception</vh></v>
<v t="ekr.20060521134315.721"><vh>get_namespace</vh></v>
<v t="ekr.20060521134315.722"><vh>evaluate</vh></v>
<v t="ekr.20060521134315.723"><vh>execute</vh></v>
<v t="ekr.20060521134315.724"><vh>get_thread_list</vh></v>
<v t="ekr.20060521134315.725"><vh>stop_debuggee &amp; helper</vh></v>
</v>
</v>
<v t="ekr.20060521134315.726"><vh>Rpc server</vh>
<v t="ekr.20060521134315.727"><vh>class CWorkQueue</vh>
<v t="ekr.20060521134315.728"><vh>__init__</vh></v>
<v t="ekr.20060521134315.729"><vh>shutdown</vh></v>
<v t="ekr.20060521134315.730"><vh>worker_target</vh></v>
<v t="ekr.20060521134315.731"><vh>post_work_item</vh></v>
</v>
<v t="ekr.20060521134315.732"><vh>class CUnTracedThreadingMixIn</vh>
<v t="ekr.20060521134315.733"><vh>init_work_queue</vh></v>
<v t="ekr.20060521134315.734"><vh>shutdown_work_queue</vh></v>
<v t="ekr.20060521134315.735"><vh>process_request</vh></v>
</v>
<v t="ekr.20060521134315.736"><vh>my_xmlrpclib_loads</vh></v>
<v t="ekr.20060521134315.737"><vh>class CXMLRPCServer</vh>
<v t="ekr.20060521134315.738"><vh>__marshaled_dispatch</vh></v>
</v>
<v t="ekr.20060521134315.739"><vh>class CPwdServerProxy</vh>
<v t="ekr.20060521134315.740"><vh>__init__</vh></v>
<v t="ekr.20060521134315.741"><vh>__set_encryption</vh></v>
<v t="ekr.20060521134315.742"><vh>get_encryption</vh></v>
<v t="ekr.20060521134315.743"><vh>__request</vh></v>
<v t="ekr.20060521134315.744"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20060521134315.745"><vh>class CIOServer (threading.Thread)</vh>
<v t="ekr.20060521134315.746"><vh>__init__</vh></v>
<v t="ekr.20060521134315.747"><vh>__del__</vh></v>
<v t="ekr.20060521134315.748"><vh>stop</vh></v>
<v t="ekr.20060521134315.749"><vh>export_null</vh></v>
<v t="ekr.20060521134315.750"><vh>run</vh></v>
<v t="ekr.20060521134315.751"><vh>dispatcher_method</vh></v>
<v t="ekr.20060521134315.752"><vh>__StartXMLRPCServer</vh></v>
</v>
<v t="ekr.20060521134315.753"><vh>class CServerInfo</vh>
<v t="ekr.20060521134315.754"><vh>__init__</vh></v>
<v t="ekr.20060521134315.755"><vh>__str__</vh></v>
</v>
<v t="ekr.20060521134315.756"><vh>class CDebuggeeServer (CIOServer)</vh>
<v t="ekr.20060521134315.757"><vh>__init__</vh></v>
<v t="ekr.20060521134315.758"><vh>export_server_info</vh></v>
<v t="ekr.20060521134315.759"><vh>export_sync_with_events</vh></v>
<v t="ekr.20060521134315.760"><vh>export_wait_for_event</vh></v>
<v t="ekr.20060521134315.761"><vh>export_set_breakpoint</vh></v>
<v t="ekr.20060521134315.762"><vh>export_disable_breakpoint</vh></v>
<v t="ekr.20060521134315.763"><vh>export_enable_breakpoint</vh></v>
<v t="ekr.20060521134315.764"><vh>export_delete_breakpoint</vh></v>
<v t="ekr.20060521134315.765"><vh>export_get_breakpoints</vh></v>
<v t="ekr.20060521134315.766"><vh>export_request_break</vh></v>
<v t="ekr.20060521134315.767"><vh>export_request_go</vh></v>
<v t="ekr.20060521134315.768"><vh>export_request_go_breakpoint</vh></v>
<v t="ekr.20060521134315.769"><vh>export_request_step</vh></v>
<v t="ekr.20060521134315.770"><vh>export_request_next</vh></v>
<v t="ekr.20060521134315.771"><vh>export_request_return</vh></v>
<v t="ekr.20060521134315.772"><vh>export_request_jump</vh></v>
<v t="ekr.20060521134315.773"><vh>export_get_stack</vh></v>
<v t="ekr.20060521134315.774"><vh>export_get_source_file</vh></v>
<v t="ekr.20060521134315.775"><vh>export_get_source_lines</vh></v>
<v t="ekr.20060521134315.776"><vh>export_get_thread_list</vh></v>
<v t="ekr.20060521134315.777"><vh>export_set_thread</vh></v>
<v t="ekr.20060521134315.778"><vh>export_get_namespace</vh></v>
<v t="ekr.20060521134315.779"><vh>export_evaluate</vh></v>
<v t="ekr.20060521134315.780"><vh>export_execute</vh></v>
<v t="ekr.20060521134315.781"><vh>export_stop_debuggee</vh></v>
</v>
</v>
<v t="ekr.20060521134315.782"><vh>Rpc client</vh>
<v t="ekr.20060521134315.783"><vh>class CTimeoutHTTPConnection</vh>
<v t="ekr.20060521134315.784"><vh>connect</vh></v>
</v>
<v t="ekr.20060521134315.785"><vh>class CTimeoutHTTP</vh>
<v t="ekr.20060521134315.786"><vh>&lt;&lt; class CTimeoutHTTP declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.787"><vh>class CTimeoutTransport</vh>
<v t="ekr.20060521134315.788"><vh>make_connection</vh></v>
</v>
<v t="ekr.20060521134315.789"><vh>class CSession</vh>
<v t="ekr.20060521134315.790"><vh>__init__</vh></v>
<v t="ekr.20060521134315.791"><vh>get_encryption</vh></v>
<v t="ekr.20060521134315.792"><vh>getServerInfo</vh></v>
<v t="ekr.20060521134315.793"><vh>shut_down</vh></v>
<v t="ekr.20060521134315.794"><vh>getProxy</vh></v>
<v t="ekr.20060521134315.795"><vh>Connect</vh></v>
<v t="ekr.20060521134315.796"><vh>ConnectNoThrow</vh></v>
<v t="ekr.20060521134315.797"><vh>ConnectAsync</vh></v>
<v t="ekr.20060521134315.798"><vh>isConnected</vh></v>
</v>
<v t="ekr.20060521134315.799"><vh>class CServerList</vh>
<v t="ekr.20060521134315.800"><vh>__init__</vh></v>
<v t="ekr.20060521134315.801"><vh>calcList</vh></v>
<v t="ekr.20060521134315.802"><vh>get_errors</vh></v>
<v t="ekr.20060521134315.803"><vh>findServers</vh></v>
</v>
<v t="ekr.20060521134315.804"><vh>class CSessionManagerInternal</vh>
<v t="ekr.20060521134315.805"><vh>__init__</vh></v>
<v t="ekr.20060521134315.806"><vh>__del__</vh></v>
<v t="ekr.20060521134315.807"><vh>__nul_printer</vh></v>
<v t="ekr.20060521134315.808"><vh>set_printer</vh></v>
<v t="ekr.20060521134315.809"><vh>register_callback</vh></v>
<v t="ekr.20060521134315.810"><vh>remove_callback</vh></v>
<v t="ekr.20060521134315.811"><vh>__wait_for_debuggee</vh></v>
<v t="ekr.20060521134315.812"><vh>get_encryption</vh></v>
<v t="ekr.20060521134315.813"><vh>launch_nothrow</vh></v>
<v t="ekr.20060521134315.814"><vh>launch</vh></v>
<v t="ekr.20060521134315.815"><vh>__spawn_server</vh></v>
<v t="ekr.20060521134315.816"><vh>attach_nothrow</vh></v>
<v t="ekr.20060521134315.817"><vh>attach</vh></v>
<v t="ekr.20060521134315.818"><vh>report_exception</vh></v>
<v t="ekr.20060521134315.819"><vh>__report_server_errors</vh></v>
<v t="ekr.20060521134315.820"><vh>__attach</vh></v>
<v t="ekr.20060521134315.821"><vh>__verify_unattached</vh></v>
<v t="ekr.20060521134315.822"><vh>__verify_attached</vh></v>
<v t="ekr.20060521134315.823"><vh>__is_attached</vh></v>
<v t="ekr.20060521134315.824"><vh>__verify_broken</vh></v>
<v t="ekr.20060521134315.825"><vh>refresh</vh></v>
<v t="ekr.20060521134315.826"><vh>__start_event_monitor</vh></v>
<v t="ekr.20060521134315.827"><vh>__event_monitor_proc</vh></v>
<v t="ekr.20060521134315.828"><vh>detach</vh></v>
<v t="ekr.20060521134315.829"><vh>__stop_event_monitor</vh></v>
<v t="ekr.20060521134315.830"><vh>request_break</vh></v>
<v t="ekr.20060521134315.831"><vh>request_go</vh></v>
<v t="ekr.20060521134315.832"><vh>request_go_breakpoint</vh></v>
<v t="ekr.20060521134315.833"><vh>request_step</vh></v>
<v t="ekr.20060521134315.834"><vh>request_next</vh></v>
<v t="ekr.20060521134315.835"><vh>request_return</vh></v>
<v t="ekr.20060521134315.836"><vh>request_jump</vh></v>
<v t="ekr.20060521134315.837"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.838"><vh>disable_breakpoint</vh></v>
<v t="ekr.20060521134315.839"><vh>enable_breakpoint</vh></v>
<v t="ekr.20060521134315.840"><vh>delete_breakpoint</vh></v>
<v t="ekr.20060521134315.841"><vh>get_breakpoints</vh></v>
<v t="ekr.20060521134315.842"><vh>save_breakpoints</vh></v>
<v t="ekr.20060521134315.843"><vh>load_breakpoints</vh></v>
<v t="ekr.20060521134315.844"><vh>get_stack</vh></v>
<v t="ekr.20060521134315.845"><vh>get_source_file</vh></v>
<v t="ekr.20060521134315.846"><vh>get_source_lines</vh></v>
<v t="ekr.20060521134315.847"><vh>get_thread_list</vh></v>
<v t="ekr.20060521134315.848"><vh>set_thread</vh></v>
<v t="ekr.20060521134315.849"><vh>get_namespace</vh></v>
<v t="ekr.20060521134315.850"><vh>evaluate</vh></v>
<v t="ekr.20060521134315.851"><vh>execute</vh></v>
<v t="ekr.20060521134315.852"><vh>set_host</vh></v>
<v t="ekr.20060521134315.853"><vh>get_host</vh></v>
<v t="ekr.20060521134315.854"><vh>calc_server_list</vh></v>
<v t="ekr.20060521134315.855"><vh>get_server_info</vh></v>
<v t="ekr.20060521134315.856"><vh>get_last_debuggee_name_safe</vh></v>
<v t="ekr.20060521134315.857"><vh>_reset_frame_indexes</vh></v>
<v t="ekr.20060521134315.858"><vh>reset_frame_indexes</vh></v>
<v t="ekr.20060521134315.859"><vh>set_stack_depth</vh></v>
<v t="ekr.20060521134315.860"><vh>set_frame_index</vh></v>
<v t="ekr.20060521134315.861"><vh>get_frame_index</vh></v>
<v t="ekr.20060521134315.862"><vh>set_analyze</vh></v>
<v t="ekr.20060521134315.863"><vh>getSession</vh></v>
<v t="ekr.20060521134315.864"><vh>get_state</vh></v>
<v t="ekr.20060521134315.865"><vh>set_password</vh></v>
<v t="ekr.20060521134315.866"><vh>set_random_password</vh></v>
<v t="ekr.20060521134315.867"><vh>get_password</vh></v>
<v t="ekr.20060521134315.868"><vh>set_remote</vh></v>
<v t="ekr.20060521134315.869"><vh>get_remote</vh></v>
<v t="ekr.20060521134315.870"><vh>stop_debuggee</vh></v>
</v>
<v t="ekr.20060521134315.871"><vh>class CConsoleInternal</vh>
<v t="ekr.20060521134315.872"><vh>__init__</vh></v>
<v t="ekr.20060521134315.873"><vh>set_filename</vh></v>
<v t="ekr.20060521134315.874"><vh>event_atexit</vh></v>
<v t="ekr.20060521134315.875"><vh>precmd</vh></v>
<v t="ekr.20060521134315.876"><vh>postcmd</vh></v>
<v t="ekr.20060521134315.877"><vh>run</vh></v>
<v t="ekr.20060521134315.878"><vh>__get_str_wrap</vh></v>
<v t="ekr.20060521134315.879"><vh>printer</vh></v>
<v t="ekr.20060521134315.880"><vh>print_notice</vh></v>
<v t="ekr.20060521134315.881"><vh>event_handler</vh></v>
<v t="ekr.20060521134315.882"><vh>do_launch</vh></v>
<v t="ekr.20060521134315.883"><vh>do_attach</vh></v>
<v t="ekr.20060521134315.884"><vh>__scripts</vh></v>
<v t="ekr.20060521134315.885"><vh>do_detach</vh></v>
<v t="ekr.20060521134315.886"><vh>do_host</vh></v>
<v t="ekr.20060521134315.887"><vh>do_break</vh></v>
<v t="ekr.20060521134315.888"><vh>__parse_bp_arg</vh></v>
<v t="ekr.20060521134315.889"><vh>do_go</vh></v>
<v t="ekr.20060521134315.890"><vh>do_step</vh></v>
<v t="ekr.20060521134315.891"><vh>do_next</vh></v>
<v t="ekr.20060521134315.892"><vh>do_return</vh></v>
<v t="ekr.20060521134315.893"><vh>do_jump</vh></v>
<v t="ekr.20060521134315.894"><vh>do_bp</vh></v>
<v t="ekr.20060521134315.895"><vh>do_be</vh></v>
<v t="ekr.20060521134315.896"><vh>do_bd</vh></v>
<v t="ekr.20060521134315.897"><vh>do_bc</vh></v>
<v t="ekr.20060521134315.898"><vh>do_bl</vh></v>
<v t="ekr.20060521134315.899"><vh>do_save</vh></v>
<v t="ekr.20060521134315.900"><vh>do_load</vh></v>
<v t="ekr.20060521134315.901"><vh>do_stack</vh></v>
<v t="ekr.20060521134315.902"><vh>do_list</vh></v>
<v t="ekr.20060521134315.903"><vh>do_up</vh></v>
<v t="ekr.20060521134315.904"><vh>do_down</vh></v>
<v t="ekr.20060521134315.905"><vh>do_eval</vh></v>
<v t="ekr.20060521134315.906"><vh>do_exec</vh></v>
<v t="ekr.20060521134315.907"><vh>do_thread</vh></v>
<v t="ekr.20060521134315.908"><vh>do_analyze</vh></v>
<v t="ekr.20060521134315.909"><vh>do_password</vh></v>
<v t="ekr.20060521134315.910"><vh>do_remote</vh></v>
<v t="ekr.20060521134315.911"><vh>do_stop</vh></v>
<v t="ekr.20060521134315.912"><vh>do_exit</vh></v>
<v t="ekr.20060521134315.913"><vh>do_copyright</vh></v>
<v t="ekr.20060521134315.914"><vh>do_license</vh></v>
<v t="ekr.20060521134315.915"><vh>do_help</vh></v>
<v t="ekr.20060521134315.916"><vh>Help messages</vh>
<v t="ekr.20060521134315.917"><vh>help_copyright</vh></v>
<v t="ekr.20060521134315.918"><vh>help_license</vh></v>
<v t="ekr.20060521134315.919"><vh>help_help</vh></v>
<v t="ekr.20060521134315.920"><vh>help_analyze</vh></v>
<v t="ekr.20060521134315.921"><vh>help_password</vh></v>
<v t="ekr.20060521134315.922"><vh>help_remote</vh></v>
<v t="ekr.20060521134315.923"><vh>help_stop</vh></v>
<v t="ekr.20060521134315.924"><vh>help_launch</vh></v>
<v t="ekr.20060521134315.925"><vh>help_attach</vh></v>
<v t="ekr.20060521134315.926"><vh>help_detach</vh></v>
<v t="ekr.20060521134315.927"><vh>help_break</vh></v>
<v t="ekr.20060521134315.928"><vh>help_bp</vh></v>
<v t="ekr.20060521134315.929"><vh>help_be</vh></v>
<v t="ekr.20060521134315.930"><vh>help_bd</vh></v>
<v t="ekr.20060521134315.931"><vh>help_bc</vh></v>
<v t="ekr.20060521134315.932"><vh>help_bl</vh></v>
<v t="ekr.20060521134315.933"><vh>help_load</vh></v>
<v t="ekr.20060521134315.934"><vh>help_save</vh></v>
<v t="ekr.20060521134315.935"><vh>help_go</vh></v>
<v t="ekr.20060521134315.936"><vh>help_exit</vh></v>
<v t="ekr.20060521134315.937"><vh>help_host</vh></v>
<v t="ekr.20060521134315.938"><vh>help_stack</vh></v>
<v t="ekr.20060521134315.939"><vh>help_list</vh></v>
<v t="ekr.20060521134315.940"><vh>help_thread</vh></v>
<v t="ekr.20060521134315.941"><vh>help_jump</vh></v>
<v t="ekr.20060521134315.942"><vh>help_next</vh></v>
<v t="ekr.20060521134315.943"><vh>help_step</vh></v>
<v t="ekr.20060521134315.944"><vh>help_return</vh></v>
<v t="ekr.20060521134315.945"><vh>help_up</vh></v>
<v t="ekr.20060521134315.946"><vh>help_down</vh></v>
<v t="ekr.20060521134315.947"><vh>help_eval</vh></v>
<v t="ekr.20060521134315.948"><vh>help_exec</vh></v>
</v>
</v>
</v>
<v t="ekr.20060521134315.949"><vh>main</vh>
<v t="ekr.20060521134315.950"><vh>__settrace</vh></v>
<v t="ekr.20060521134315.951"><vh>__start_embedded_debugger</vh></v>
<v t="ekr.20060521134315.952"><vh>StartServer</vh></v>
<v t="ekr.20060521134315.953"><vh>StartClient</vh></v>
<v t="ekr.20060521134315.954"><vh>PrintUsage</vh></v>
<v t="ekr.20060521134315.955"><vh>main</vh></v>
</v>
<v t="ekr.20060521134315.956"><vh>&lt;&lt; execute rpdb2.main &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.957"><vh>winpdb.py</vh>
<v t="ekr.20060521134315.958"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20060521134315.959"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20060521134315.960"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.961"><vh>&lt;&lt; constants &gt;&gt;</vh>
<v t="ekr.20060521134315.962"><vh>&lt;&lt; marker constants &gt;&gt;</vh></v>
<v t="ekr.20060521134315.963"><vh>&lt;&lt; strings &gt;&gt;</vh></v>
<v t="ekr.20060521134315.964"><vh>&lt;&lt; configuration constants &gt;&gt;</vh></v>
<v t="ekr.20060521134315.965"><vh>&lt;&lt; menu constants &gt;&gt;</vh></v>
<v t="ekr.20060521134315.966"><vh>&lt;&lt; bitmaps &gt;&gt;</vh></v>
<v t="ekr.20060521134315.967"><vh>&lt;&lt; menu definition dicts &gt;&gt;</vh></v>
<v t="ekr.20060521134315.968"><vh>&lt;&lt; about menu constants &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.969"><vh>class CJobs</vh>
<v t="ekr.20060521134315.970"><vh>__init__</vh></v>
<v t="ekr.20060521134315.971"><vh>init_jobs</vh></v>
<v t="ekr.20060521134315.972"><vh>shutdown_jobs</vh></v>
<v t="ekr.20060521134315.973"><vh>job_post</vh></v>
<v t="ekr.20060521134315.974"><vh>job_do</vh></v>
<v t="ekr.20060521134315.975"><vh>set_cursor</vh></v>
</v>
<v t="ekr.20060521134315.976"><vh>class CWinpdbApp (wx.App)</vh>
<v t="ekr.20060521134315.977"><vh>__init__</vh></v>
<v t="ekr.20060521134315.978"><vh>OnInit</vh></v>
<v t="ekr.20060521134315.979"><vh>OnExit</vh></v>
</v>
<v t="ekr.20060521134315.980"><vh>Main window &amp; its base classes</vh>
<v t="ekr.20060521134315.981"><vh>class CSettings</vh>
<v t="ekr.20060521134315.982"><vh>__init__</vh></v>
<v t="ekr.20060521134315.983"><vh>calc_path</vh></v>
<v t="ekr.20060521134315.984"><vh>create_path</vh></v>
<v t="ekr.20060521134315.985"><vh>load_settings</vh></v>
<v t="ekr.20060521134315.986"><vh>save_settings</vh></v>
<v t="ekr.20060521134315.987"><vh>__getitem__</vh></v>
<v t="ekr.20060521134315.988"><vh>__setitem__</vh></v>
</v>
<v t="ekr.20060521134315.989"><vh>class CMenuBar</vh>
<v t="ekr.20060521134315.990"><vh>__init__</vh></v>
<v t="ekr.20060521134315.991"><vh>init_menubar</vh></v>
<v t="ekr.20060521134315.992"><vh>set_menu_items_state</vh></v>
<v t="ekr.20060521134315.993"><vh>add_menu_item</vh></v>
<v t="ekr.20060521134315.994"><vh>clear_menu_items</vh></v>
</v>
<v t="ekr.20060521134315.995"><vh>class CToolBar</vh>
<v t="ekr.20060521134315.996"><vh>__init__</vh></v>
<v t="ekr.20060521134315.997"><vh>init_toolbar</vh></v>
<v t="ekr.20060521134315.998"><vh>set_toolbar_items_state</vh></v>
<v t="ekr.20060521134315.999"><vh>__gtk_enable_tool</vh></v>
<v t="ekr.20060521134315.1000"><vh>set_toggle</vh></v>
<v t="ekr.20060521134315.1001"><vh>OnToggleTool</vh></v>
</v>
<v t="ekr.20060521134315.1002"><vh>class CStatusBar</vh>
<v t="ekr.20060521134315.1003"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1004"><vh>init_statusbar</vh></v>
<v t="ekr.20060521134315.1005"><vh>set_statusbar_data</vh></v>
<v t="ekr.20060521134315.1006"><vh>set_bitmap</vh></v>
<v t="ekr.20060521134315.1007"><vh>reposition</vh></v>
<v t="ekr.20060521134315.1008"><vh>OnSize</vh></v>
<v t="ekr.20060521134315.1009"><vh>OnIdle</vh></v>
</v>
<v t="ekr.20060521134315.1010"><vh>class CMainWindow (CMenuBar, CToolBar, CStatusBar, CJobs)</vh>
<v t="ekr.20060521134315.1011"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.1012"><vh>class CWinpdbWindow (wx.Frame, CMainWindow)</vh>
<v t="ekr.20060521134315.1013"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1014"><vh>__set_sash_positions</vh></v>
<v t="ekr.20060521134315.1015"><vh>OnThreadSelected</vh></v>
<v t="ekr.20060521134315.1016"><vh>job_thread_select</vh></v>
<v t="ekr.20060521134315.1017"><vh>update_threads</vh></v>
<v t="ekr.20060521134315.1018"><vh>update_no_threads</vh></v>
<v t="ekr.20060521134315.1019"><vh>clear_all</vh></v>
<v t="ekr.20060521134315.1020"><vh>update_thread_broken</vh></v>
<v t="ekr.20060521134315.1021"><vh>update_bp</vh></v>
<v t="ekr.20060521134315.1022"><vh>toggle_breakpoint</vh></v>
<v t="ekr.20060521134315.1023"><vh>OnFrameSelected</vh></v>
<v t="ekr.20060521134315.1024"><vh>job_frame_select</vh></v>
<v t="ekr.20060521134315.1025"><vh>update_frame</vh></v>
<v t="ekr.20060521134315.1026"><vh>do_update_frame</vh></v>
<v t="ekr.20060521134315.1027"><vh>update_stack</vh></v>
<v t="ekr.20060521134315.1028"><vh>do_update_stack</vh></v>
<v t="ekr.20060521134315.1029"><vh>do_set_position</vh></v>
<v t="ekr.20060521134315.1030"><vh>do_analyze</vh></v>
<v t="ekr.20060521134315.1031"><vh>update_namespace</vh></v>
<v t="ekr.20060521134315.1032"><vh>do_filter</vh></v>
<v t="ekr.20060521134315.1033"><vh>do_notify_filename</vh></v>
<v t="ekr.20060521134315.1034"><vh>OnCloseWindow</vh></v>
<v t="ekr.20060521134315.1035"><vh>set_cursor</vh></v>
<v t="ekr.20060521134315.1036"><vh>do_none</vh></v>
<v t="ekr.20060521134315.1037"><vh>update_state</vh></v>
<v t="ekr.20060521134315.1038"><vh>callback_state</vh></v>
<v t="ekr.20060521134315.1039"><vh>do_website</vh></v>
<v t="ekr.20060521134315.1040"><vh>do_support</vh></v>
<v t="ekr.20060521134315.1041"><vh>do_docs</vh></v>
<v t="ekr.20060521134315.1042"><vh>do_updates</vh></v>
<v t="ekr.20060521134315.1043"><vh>do_license</vh></v>
<v t="ekr.20060521134315.1044"><vh>do_about</vh></v>
<v t="ekr.20060521134315.1045"><vh>do_password</vh></v>
<v t="ekr.20060521134315.1046"><vh>job_pwd</vh></v>
<v t="ekr.20060521134315.1047"><vh>do_launch</vh></v>
<v t="ekr.20060521134315.1048"><vh>job_launch</vh></v>
<v t="ekr.20060521134315.1049"><vh>do_open</vh></v>
<v t="ekr.20060521134315.1050"><vh>do_attach</vh></v>
<v t="ekr.20060521134315.1051"><vh>job_attach</vh></v>
<v t="ekr.20060521134315.1052"><vh>do_detach</vh></v>
<v t="ekr.20060521134315.1053"><vh>job_detach</vh></v>
<v t="ekr.20060521134315.1054"><vh>do_stop</vh></v>
<v t="ekr.20060521134315.1055"><vh>job_stop</vh></v>
<v t="ekr.20060521134315.1056"><vh>do_disable</vh></v>
<v t="ekr.20060521134315.1057"><vh>do_enable</vh></v>
<v t="ekr.20060521134315.1058"><vh>do_clear</vh></v>
<v t="ekr.20060521134315.1059"><vh>do_load</vh></v>
<v t="ekr.20060521134315.1060"><vh>do_save</vh></v>
<v t="ekr.20060521134315.1061"><vh>do_go</vh></v>
<v t="ekr.20060521134315.1062"><vh>do_break</vh></v>
<v t="ekr.20060521134315.1063"><vh>do_step</vh></v>
<v t="ekr.20060521134315.1064"><vh>do_next</vh></v>
<v t="ekr.20060521134315.1065"><vh>do_return</vh></v>
<v t="ekr.20060521134315.1066"><vh>do_goto</vh></v>
<v t="ekr.20060521134315.1067"><vh>do_exit</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1068" a="E"><vh>Panels &amp; related classes</vh>
<v t="ekr.20060521134315.1069"><vh>class CListCtrl (wx.ListCtrl, listmix.ListCtrlAutoWidthMixin)</vh>
<v t="ekr.20060521134315.1070"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1071"><vh>set_columns_width</vh></v>
</v>
<v t="ekr.20060521134315.1072"><vh>class CStyledViewer (stc.StyledTextCtrl)</vh>
<v t="ekr.20060521134315.1073"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1074"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1075"><vh>load_source</vh></v>
<v t="ekr.20060521134315.1076"><vh>OnKeyReleased</vh></v>
<v t="ekr.20060521134315.1077"><vh>OnKeyPressed</vh></v>
</v>
<v t="ekr.20060521134315.1078"><vh>class CSourceManager</vh>
<v t="ekr.20060521134315.1079"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1080"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1081"><vh>get_source</vh></v>
<v t="ekr.20060521134315.1082"><vh>load_source</vh></v>
<v t="ekr.20060521134315.1083"><vh>job_load_source</vh></v>
<v t="ekr.20060521134315.1084"><vh>load_error</vh></v>
</v>
<v t="ekr.20060521134315.1085"><vh>class CCaption (wx.Panel)</vh>
<v t="ekr.20060521134315.1086"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.1087"><vh>class CCaptionManager</vh>
<v t="ekr.20060521134315.1088"><vh>bind_caption</vh></v>
<v t="ekr.20060521134315.1089"><vh>OnGainFocus</vh></v>
<v t="ekr.20060521134315.1090"><vh>OnLoseFocus</vh></v>
</v>
<v t="ekr.20060521134315.1091"><vh>class CNamespacePanel (wx.Panel, CJobs)</vh>
<v t="ekr.20060521134315.1092"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1093"><vh>OnDestroyWindow</vh></v>
<v t="ekr.20060521134315.1094"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1095"><vh>set_filter</vh></v>
<v t="ekr.20060521134315.1096"><vh>bind_caption</vh></v>
<v t="ekr.20060521134315.1097"><vh>OnItemActivated</vh></v>
<v t="ekr.20060521134315.1098"><vh>OnItemToolTip</vh></v>
<v t="ekr.20060521134315.1099"><vh>OnItemCollapsing</vh></v>
<v t="ekr.20060521134315.1100"><vh>get_namespace</vh></v>
<v t="ekr.20060521134315.1101"><vh>expand_item</vh></v>
<v t="ekr.20060521134315.1102"><vh>OnItemExpanding</vh></v>
<v t="ekr.20060521134315.1103"><vh>get_children</vh></v>
<v t="ekr.20060521134315.1104"><vh>get_expression_list</vh></v>
<v t="ekr.20060521134315.1105"><vh>update_namespace</vh></v>
<v t="ekr.20060521134315.1106"><vh>post</vh></v>
<v t="ekr.20060521134315.1107"><vh>job_update_namespace</vh></v>
<v t="ekr.20060521134315.1108"><vh>do_update_namespace</vh></v>
<v t="ekr.20060521134315.1109"><vh>OnSize</vh></v>
</v>
<v t="ekr.20060521134315.1110" a="E"><vh>class CCodeViewer (wx.Panel, CJobs, CCaptionManager)</vh>
<v t="ekr.20060521134315.1111"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1112"><vh>OnDestroyWindow</vh></v>
<v t="ekr.20060521134315.1113"><vh>set_cursor</vh></v>
<v t="ekr.20060521134315.1114"><vh>on_margin_clicked</vh></v>
<v t="ekr.20060521134315.1115"><vh>get_file_lineno</vh></v>
<v t="ekr.20060521134315.1116"><vh>toggle_breakpoint</vh></v>
<v t="ekr.20060521134315.1117"><vh>__toggle_breakpoint</vh></v>
<v t="ekr.20060521134315.1118"><vh>job_set_breakpoint</vh></v>
<v t="ekr.20060521134315.1119"><vh>job_delete_breakpoint</vh></v>
<v t="ekr.20060521134315.1120"><vh>_disable</vh></v>
<v t="ekr.20060521134315.1121"><vh>_enable</vh></v>
<v t="ekr.20060521134315.1122"><vh>get_history</vh></v>
<v t="ekr.20060521134315.1123"><vh>set_history</vh></v>
<v t="ekr.20060521134315.1124"><vh>OnKeyPressed</vh></v>
<v t="ekr.20060521134315.1125"><vh>OnKeyReleased</vh></v>
<v t="ekr.20060521134315.1126"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1127"><vh>__notify_filename</vh></v>
<v t="ekr.20060521134315.1128"><vh>set_file</vh></v>
<v t="ekr.20060521134315.1129"><vh>set_position</vh></v>
<v t="ekr.20060521134315.1130"><vh>update_bp</vh></v>
<v t="ekr.20060521134315.1131"><vh>set_markers</vh></v>
</v>
<v t="ekr.20060521134315.1132"><vh>class CConsole (wx.Panel, CCaptionManager)</vh>
<v t="ekr.20060521134315.1133"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1134"><vh>set_focus</vh></v>
<v t="ekr.20060521134315.1135"><vh>set_filename</vh></v>
<v t="ekr.20060521134315.1136"><vh>set_font</vh></v>
<v t="ekr.20060521134315.1137"><vh>start</vh></v>
<v t="ekr.20060521134315.1138"><vh>stop</vh></v>
<v t="ekr.20060521134315.1139"><vh>write</vh></v>
<v t="ekr.20060521134315.1140"><vh>flush</vh></v>
<v t="ekr.20060521134315.1141"><vh>readline</vh></v>
<v t="ekr.20060521134315.1142"><vh>OnChar</vh></v>
<v t="ekr.20060521134315.1143"><vh>get_history</vh></v>
<v t="ekr.20060521134315.1144"><vh>set_history</vh></v>
</v>
<v t="ekr.20060521134315.1145"><vh>class CThreadsViewer wx.Panel, CCaptionManager)</vh>
<v t="ekr.20060521134315.1146"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1147"><vh>set_cursor</vh></v>
<v t="ekr.20060521134315.1148"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1149"><vh>_disable</vh></v>
<v t="ekr.20060521134315.1150"><vh>_enable</vh></v>
<v t="ekr.20060521134315.1151"><vh>is_selected</vh></v>
<v t="ekr.20060521134315.1152"><vh>update_thread</vh></v>
<v t="ekr.20060521134315.1153"><vh>update_threads_list</vh></v>
<v t="ekr.20060521134315.1154"><vh>OnThreadSelected</vh></v>
</v>
<v t="ekr.20060521134315.1155"><vh>class CLocals (CNamespacePanel)</vh>
<v t="ekr.20060521134315.1156"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1157"><vh>get_root_expr</vh></v>
</v>
<v t="ekr.20060521134315.1158"><vh>class CGlobals (CNamespacePanel)</vh>
<v t="ekr.20060521134315.1159"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1160"><vh>get_root_expr</vh></v>
</v>
<v t="ekr.20060521134315.1161"><vh>class CException (CNamespacePanel)</vh>
<v t="ekr.20060521134315.1162"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1163"><vh>get_root_expr</vh></v>
</v>
<v t="ekr.20060521134315.1164"><vh>class CNamespaceViewer (wx.Panel, CCaptionManager)</vh>
<v t="ekr.20060521134315.1165"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1166"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1167"><vh>_disable</vh></v>
<v t="ekr.20060521134315.1168"><vh>_enable</vh></v>
<v t="ekr.20060521134315.1169"><vh>set_filter</vh></v>
<v t="ekr.20060521134315.1170"><vh>get_local_key</vh></v>
<v t="ekr.20060521134315.1171"><vh>get_global_key</vh></v>
<v t="ekr.20060521134315.1172"><vh>update_namespace</vh></v>
</v>
<v t="ekr.20060521134315.1173"><vh>class CStackViewer (wx.Panel, CCaptionManager)</vh>
<v t="ekr.20060521134315.1174"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1175"><vh>set_cursor</vh></v>
<v t="ekr.20060521134315.1176"><vh>_clear</vh></v>
<v t="ekr.20060521134315.1177"><vh>_disable</vh></v>
<v t="ekr.20060521134315.1178"><vh>_enable</vh></v>
<v t="ekr.20060521134315.1179"><vh>is_selected</vh></v>
<v t="ekr.20060521134315.1180"><vh>update_stack_list</vh></v>
<v t="ekr.20060521134315.1181"><vh>select_frame</vh></v>
<v t="ekr.20060521134315.1182"><vh>OnFrameSelected</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1183"><vh>Dialogs</vh>
<v t="ekr.20060521134315.1184"><vh>class CHTMLDialog (wx.Dialog)</vh>
<v t="ekr.20060521134315.1185"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1186"><vh>get_html_text</vh></v>
</v>
<v t="ekr.20060521134315.1187"><vh>class CAttachDialog (wx.Dialog, CJobs)</vh>
<v t="ekr.20060521134315.1188"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1189"><vh>init2</vh></v>
<v t="ekr.20060521134315.1190"><vh>job_pwd</vh></v>
<v t="ekr.20060521134315.1191"><vh>set_cursor</vh></v>
<v t="ekr.20060521134315.1192"><vh>OnCloseWindow</vh></v>
<v t="ekr.20060521134315.1193"><vh>get_server</vh></v>
<v t="ekr.20060521134315.1194"><vh>do_refresh</vh></v>
<v t="ekr.20060521134315.1195"><vh>job_calc_scripts</vh></v>
<v t="ekr.20060521134315.1196"><vh>update_body</vh></v>
<v t="ekr.20060521134315.1197"><vh>OnItemSelected</vh></v>
<v t="ekr.20060521134315.1198"><vh>OnItemDeselected</vh></v>
<v t="ekr.20060521134315.1199"><vh>OnItemActivated</vh></v>
</v>
<v t="ekr.20060521134315.1200"><vh>class CExpressionDialog (wx.Dialog)</vh>
<v t="ekr.20060521134315.1201"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1202"><vh>OnText</vh></v>
<v t="ekr.20060521134315.1203"><vh>get_expression</vh></v>
</v>
<v t="ekr.20060521134315.1204"><vh>class CPwdDialog (wx.Dialog)</vh>
<v t="ekr.20060521134315.1205"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1206"><vh>OnText</vh></v>
<v t="ekr.20060521134315.1207"><vh>get_password</vh></v>
</v>
<v t="ekr.20060521134315.1208"><vh>class COpenDialog (wx.Dialog)</vh>
<v t="ekr.20060521134315.1209"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1210"><vh>OnText</vh></v>
<v t="ekr.20060521134315.1211"><vh>do_browse</vh></v>
<v t="ekr.20060521134315.1212"><vh>do_validate</vh></v>
<v t="ekr.20060521134315.1213"><vh>do_ok</vh></v>
<v t="ekr.20060521134315.1214"><vh>get_file_name</vh></v>
</v>
<v t="ekr.20060521134315.1215"><vh>class CLaunchDialog (wx.Dialog)</vh>
<v t="ekr.20060521134315.1216"><vh>__init__</vh></v>
<v t="ekr.20060521134315.1217"><vh>OnText</vh></v>
<v t="ekr.20060521134315.1218"><vh>do_browse</vh></v>
<v t="ekr.20060521134315.1219"><vh>do_validate</vh></v>
<v t="ekr.20060521134315.1220"><vh>do_ok</vh></v>
<v t="ekr.20060521134315.1221"><vh>get_command_line</vh></v>
</v>
</v>
<v t="ekr.20060521134315.1222"><vh>Functions</vh>
<v t="ekr.20060521134315.1223"><vh>image_from_base64</vh></v>
<v t="ekr.20060521134315.1224"><vh>StartClient</vh></v>
<v t="ekr.20060521134315.1225"><vh>main</vh></v>
<v t="ekr.20060521134315.1226"><vh>get_version</vh></v>
</v>
</v>
<v t="ekr.20060526070950"><vh>Testing whether the debugger is runnint: g_debugger</vh>
<v t="ekr.20060521134315.951"><vh>__start_embedded_debugger</vh></v>
<v t="ekr.20060521134315.952"><vh>StartServer</vh></v>
</v>
<v t="ekr.20060526070950.1" a="E"><vh>Setting a hard breakpoint:start_embedded_debugger (module-level function)</vh>
<v t="ekr.20060521134315.373"><vh>start_embedded_debugger</vh>
<v t="ekr.20060521134315.374"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.951"><vh>__start_embedded_debugger</vh></v>
</v>
</v>
<v t="ekr.20060521134315.28"><vh>Idle Reference</vh>
<v t="ekr.20060521134315.29"><vh>class PyShell(OutputWindow)</vh></v>
<v t="ekr.20060521134315.149"><vh>class FileList</vh>
<v t="ekr.20060521134315.150"><vh>class PyShellFileList (FileList)</vh></v>
</v>
<v t="ekr.20060521134315.151" a="E"><vh>EditorWindow.py</vh>
<v t="ekr.20060521134315.152"><vh>&lt;&lt; imports&gt;&gt;</vh></v>
<v t="ekr.20060521134315.153"><vh>functions</vh>
<v t="ekr.20060521134315.154"><vh>_find_module</vh></v>
<v t="ekr.20060521134315.155"><vh>index2line</vh></v>
<v t="ekr.20060521134315.156"><vh>classifyws</vh></v>
<v t="ekr.20060521134315.157"><vh>class IndentSearcher</vh>
<v t="ekr.20060521134315.158"><vh>&lt;&lt; class IndentSearcher declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.159"><vh>__init__</vh></v>
<v t="ekr.20060521134315.160"><vh>readline</vh></v>
<v t="ekr.20060521134315.161"><vh>tokeneater</vh></v>
<v t="ekr.20060521134315.162"><vh>run</vh></v>
</v>
<v t="ekr.20060521134315.163"><vh>prepstr</vh></v>
<v t="ekr.20060521134315.164"><vh>get_accelerator</vh></v>
<v t="ekr.20060521134315.165"><vh>fixwordbreaks</vh></v>
<v t="ekr.20060521134315.166"><vh>test</vh></v>
</v>
<v t="ekr.20060521134315.42"><vh>class EditorWindow</vh>
<v t="ekr.20060521134315.43"><vh>&lt;&lt; EditorWindow imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.44"><vh>__init__</vh></v>
<v t="ekr.20060521134315.45" a="E"><vh>Menu and status bar</vh>
<v t="ekr.20060521134315.46"><vh>new_callback</vh></v>
<v t="ekr.20060521134315.47"><vh>set_status_bar</vh></v>
<v t="ekr.20060521134315.48"><vh>set_line_and_column</vh></v>
<v t="ekr.20060521134315.49"><vh>createmenubar</vh></v>
<v t="ekr.20060521134315.50"><vh>postwindowsmenu</vh></v>
<v t="ekr.20060521134315.51"><vh>right_menu_event</vh></v>
<v t="ekr.20060521134315.52"><vh>make_rmenu</vh></v>
</v>
<v t="ekr.20060521134315.53"><vh>Dialogs</vh>
<v t="ekr.20060521134315.54"><vh>about_dialog</vh></v>
<v t="ekr.20060521134315.55"><vh>config_dialog</vh></v>
<v t="ekr.20060521134315.56"><vh>help_dialog</vh></v>
<v t="ekr.20060521134315.57"><vh>python_docs</vh></v>
</v>
<v t="ekr.20060521134315.58"><vh>Commands</vh>
<v t="ekr.20060521134315.59"><vh>cut</vh></v>
<v t="ekr.20060521134315.60"><vh>copy</vh></v>
<v t="ekr.20060521134315.61"><vh>paste</vh></v>
<v t="ekr.20060521134315.62"><vh>select_all</vh></v>
<v t="ekr.20060521134315.63"><vh>remove_selection</vh></v>
<v t="ekr.20060521134315.64"><vh>move_at_edge_if_selection</vh></v>
<v t="ekr.20060521134315.65"><vh>find_event</vh></v>
<v t="ekr.20060521134315.66"><vh>find_again_event</vh></v>
<v t="ekr.20060521134315.67"><vh>find_selection_event</vh></v>
<v t="ekr.20060521134315.68"><vh>find_in_files_event</vh></v>
<v t="ekr.20060521134315.69"><vh>replace_event</vh></v>
<v t="ekr.20060521134315.70"><vh>goto_line_event</vh></v>
<v t="ekr.20060521134315.71"><vh>open_module</vh></v>
<v t="ekr.20060521134315.72"><vh>open_class_browser</vh></v>
<v t="ekr.20060521134315.73"><vh>open_path_browser</vh></v>
<v t="ekr.20060521134315.74"><vh>gotoline</vh></v>
<v t="ekr.20060521134315.75"><vh>ispythonsource</vh></v>
<v t="ekr.20060521134315.76"><vh>close_hook</vh></v>
<v t="ekr.20060521134315.77"><vh>set_close_hook</vh></v>
<v t="ekr.20060521134315.78"><vh>filename_change_hook</vh></v>
</v>
<v t="ekr.20060521134315.79"><vh>Colorizer</vh>
<v t="ekr.20060521134315.80"><vh>addcolorizer</vh></v>
<v t="ekr.20060521134315.81"><vh>rmcolorizer</vh></v>
<v t="ekr.20060521134315.82"><vh>ResetColorizer</vh></v>
</v>
<v t="ekr.20060521134315.83"><vh>Config</vh>
<v t="ekr.20060521134315.84"><vh>ResetFont</vh></v>
<v t="ekr.20060521134315.85"><vh>ResetKeybindings</vh></v>
<v t="ekr.20060521134315.86"><vh>reset_help_menu_entries</vh></v>
<v t="ekr.20060521134315.87"><vh>__extra_help_callback</vh></v>
<v t="ekr.20060521134315.88"><vh>update_recent_files_list</vh></v>
<v t="ekr.20060521134315.89"><vh>__recent_file_callback</vh></v>
<v t="ekr.20060521134315.90"><vh>saved_change_hook</vh></v>
</v>
<v t="ekr.20060521134315.91"><vh>Undo</vh>
<v t="ekr.20060521134315.92"><vh>get_saved</vh></v>
<v t="ekr.20060521134315.93"><vh>set_saved</vh></v>
<v t="ekr.20060521134315.94"><vh>reset_undo</vh></v>
</v>
<v t="ekr.20060521134315.95"><vh>Getters</vh>
<v t="ekr.20060521134315.96"><vh>short_title</vh></v>
<v t="ekr.20060521134315.97"><vh>long_title</vh></v>
<v t="ekr.20060521134315.98"><vh>center_insert_event</vh></v>
<v t="ekr.20060521134315.99"><vh>center</vh></v>
<v t="ekr.20060521134315.100"><vh>getwindowlines</vh></v>
<v t="ekr.20060521134315.101"><vh>getlineno</vh></v>
<v t="ekr.20060521134315.102"><vh>get_geometry</vh></v>
</v>
<v t="ekr.20060521134315.103"><vh>Close</vh>
<v t="ekr.20060521134315.104"><vh>close_event</vh></v>
<v t="ekr.20060521134315.105"><vh>maybesave</vh></v>
<v t="ekr.20060521134315.106"><vh>close</vh></v>
<v t="ekr.20060521134315.107"><vh>_close</vh></v>
</v>
<v t="ekr.20060521134315.108"><vh>Extensions</vh>
<v t="ekr.20060521134315.109"><vh>load_extensions</vh></v>
<v t="ekr.20060521134315.110"><vh>unload_extensions</vh></v>
<v t="ekr.20060521134315.111"><vh>load_standard_extensions</vh></v>
<v t="ekr.20060521134315.112"><vh>get_standard_extension_names</vh></v>
<v t="ekr.20060521134315.113"><vh>load_extension</vh></v>
</v>
<v t="ekr.20060521134315.114"><vh>Bindings</vh>
<v t="ekr.20060521134315.115"><vh>apply_bindings</vh></v>
<v t="ekr.20060521134315.116"><vh>fill_menus</vh></v>
<v t="ekr.20060521134315.117"><vh>getvar</vh></v>
<v t="ekr.20060521134315.118"><vh>setvar</vh></v>
<v t="ekr.20060521134315.119"><vh>get_var_obj</vh></v>
<v t="ekr.20060521134315.120"><vh>is_char_in_string</vh></v>
<v t="ekr.20060521134315.121"><vh>get_selection_indices</vh></v>
<v t="ekr.20060521134315.122"><vh>get_tabwidth</vh></v>
<v t="ekr.20060521134315.123"><vh>set_tabwidth</vh></v>
<v t="ekr.20060521134315.124"><vh>config</vh></v>
</v>
<v t="ekr.20060521134315.125"><vh>Smart indent</vh>
<v t="ekr.20060521134315.126"><vh>set_indentation_params</vh></v>
<v t="ekr.20060521134315.127"><vh>smart_backspace_event</vh></v>
<v t="ekr.20060521134315.128"><vh>smart_indent_event</vh></v>
<v t="ekr.20060521134315.129"><vh>newline_and_indent_event</vh></v>
<v t="ekr.20060521134315.130"><vh>_build_char_in_string_func</vh></v>
<v t="ekr.20060521134315.131"><vh>indent_region_event</vh></v>
<v t="ekr.20060521134315.132"><vh>dedent_region_event</vh></v>
</v>
<v t="ekr.20060521134315.133"><vh>Comment</vh>
<v t="ekr.20060521134315.134"><vh>comment_region_event</vh></v>
<v t="ekr.20060521134315.135"><vh>uncomment_region_event</vh></v>
</v>
<v t="ekr.20060521134315.136"><vh>Tabiby</vh>
<v t="ekr.20060521134315.137"><vh>tabify_region_event</vh></v>
<v t="ekr.20060521134315.138"><vh>untabify_region_event</vh></v>
<v t="ekr.20060521134315.139"><vh>toggle_tabs_event</vh></v>
<v t="ekr.20060521134315.140"><vh>change_tabwidth_event</vh></v>
<v t="ekr.20060521134315.141"><vh>change_indentwidth_event</vh></v>
</v>
<v t="ekr.20060521134315.142"><vh>Utils</vh>
<v t="ekr.20060521134315.143"><vh>get_region</vh></v>
<v t="ekr.20060521134315.144"><vh>set_region</vh></v>
<v t="ekr.20060521134315.145"><vh>_make_blanks</vh></v>
<v t="ekr.20060521134315.146"><vh>reindent_to</vh></v>
<v t="ekr.20060521134315.147"><vh>_asktabwidth</vh></v>
<v t="ekr.20060521134315.148"><vh>guess_indent</vh></v>
</v>
</v>
</v>
<v t="ekr.20060521134315.167"><vh>PyShell.py</vh>
<v t="ekr.20060521134315.168"><vh>&lt;&lt; PyShell declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.169"><vh>idle_showwarning</vh></v>
<v t="ekr.20060521134315.170"><vh>idle_formatwarning</vh></v>
<v t="ekr.20060521134315.171"><vh>extended_linecache_checkcache</vh></v>
<v t="ekr.20060521134315.30"><vh>class PyShellEditorWindow (EditorWindow)</vh>
<v t="ekr.20060521134315.31"><vh>__init__</vh></v>
<v t="ekr.20060521134315.32"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.33"><vh>set_breakpoint_here</vh></v>
<v t="ekr.20060521134315.34"><vh>clear_breakpoint_here</vh></v>
<v t="ekr.20060521134315.35"><vh>clear_file_breaks</vh></v>
<v t="ekr.20060521134315.36"><vh>store_file_breaks</vh>
<v t="ekr.20060521134315.37"><vh>&lt;&lt; about store_file_breaks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.38"><vh>restore_file_breaks</vh></v>
<v t="ekr.20060521134315.39"><vh>update_breakpoints</vh></v>
<v t="ekr.20060521134315.40"><vh>ranges_to_linenumbers</vh></v>
<v t="ekr.20060521134315.41"><vh>_close</vh></v>
</v>
<v t="ekr.20060521134315.172"><vh>class PyShellFileList</vh>
<v t="ekr.20060521134315.173"><vh>&lt;&lt; class PyShellFileList declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.174"><vh>open_shell</vh></v>
</v>
<v t="ekr.20060521134315.175"><vh>class ModifiedColorDelegator</vh>
<v t="ekr.20060521134315.176"><vh>&lt;&lt; class ModifiedColorDelegator declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.177"><vh>__init__</vh></v>
<v t="ekr.20060521134315.178"><vh>recolorize_main</vh></v>
<v t="ekr.20060521134315.179"><vh>LoadTagDefs</vh></v>
</v>
<v t="ekr.20060521134315.180"><vh>class ModifiedUndoDelegator</vh>
<v t="ekr.20060521134315.181"><vh>&lt;&lt; class ModifiedUndoDelegator declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.182"><vh>insert</vh></v>
<v t="ekr.20060521134315.183"><vh>delete</vh></v>
</v>
<v t="ekr.20060521134315.184"><vh>class MyRPCClient</vh>
<v t="ekr.20060521134315.185"><vh>handle_EOF</vh></v>
</v>
<v t="ekr.20060521134315.186"><vh>class ModifiedInterpreter</vh>
<v t="ekr.20060521134315.187"><vh>__init__</vh></v>
<v t="ekr.20060521134315.188"><vh>spawn_subprocess</vh></v>
<v t="ekr.20060521134315.189"><vh>build_subprocess_arglist</vh></v>
<v t="ekr.20060521134315.190"><vh>start_subprocess</vh></v>
<v t="ekr.20060521134315.191"><vh>restart_subprocess</vh></v>
<v t="ekr.20060521134315.192"><vh>__request_interrupt</vh></v>
<v t="ekr.20060521134315.193"><vh>interrupt_subprocess</vh></v>
<v t="ekr.20060521134315.194"><vh>kill_subprocess</vh></v>
<v t="ekr.20060521134315.195"><vh>unix_terminate</vh></v>
<v t="ekr.20060521134315.196"><vh>transfer_path</vh></v>
<v t="ekr.20060521134315.197"><vh>poll_subprocess</vh></v>
<v t="ekr.20060521134315.198"><vh>setdebugger</vh></v>
<v t="ekr.20060521134315.199"><vh>getdebugger</vh></v>
<v t="ekr.20060521134315.200"><vh>open_remote_stack_viewer</vh></v>
<v t="ekr.20060521134315.201"><vh>remote_stack_viewer</vh></v>
<v t="ekr.20060521134315.202"><vh>execsource</vh></v>
<v t="ekr.20060521134315.203"><vh>execfile</vh></v>
<v t="ekr.20060521134315.204"><vh>runsource</vh></v>
<v t="ekr.20060521134315.205"><vh>stuffsource</vh></v>
<v t="ekr.20060521134315.206"><vh>prepend_syspath</vh></v>
<v t="ekr.20060521134315.207"><vh>showsyntaxerror</vh></v>
<v t="ekr.20060521134315.208"><vh>unpackerror</vh></v>
<v t="ekr.20060521134315.209"><vh>showtraceback</vh></v>
<v t="ekr.20060521134315.210"><vh>checklinecache</vh></v>
<v t="ekr.20060521134315.211"><vh>runcommand</vh></v>
<v t="ekr.20060521134315.212"><vh>runcode</vh></v>
<v t="ekr.20060521134315.213"><vh>write</vh></v>
<v t="ekr.20060521134315.214"><vh>display_port_binding_error</vh></v>
<v t="ekr.20060521134315.215"><vh>display_no_subprocess_error</vh></v>
<v t="ekr.20060521134315.216"><vh>display_executing_dialog</vh></v>
</v>
<v t="ekr.20060521134315.217"><vh>class PyShell</vh>
<v t="ekr.20060521134315.218"><vh>&lt;&lt; class PyShell declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.219"><vh>__init__</vh></v>
<v t="ekr.20060521134315.220"><vh>get_standard_extension_names</vh></v>
<v t="ekr.20060521134315.221"><vh>set_warning_stream</vh></v>
<v t="ekr.20060521134315.222"><vh>get_warning_stream</vh></v>
<v t="ekr.20060521134315.223"><vh>toggle_debugger</vh></v>
<v t="ekr.20060521134315.224"><vh>set_debugger_indicator</vh></v>
<v t="ekr.20060521134315.225"><vh>toggle_jit_stack_viewer</vh></v>
<v t="ekr.20060521134315.226"><vh>close_debugger</vh></v>
<v t="ekr.20060521134315.227"><vh>open_debugger</vh></v>
<v t="ekr.20060521134315.228"><vh>beginexecuting</vh></v>
<v t="ekr.20060521134315.229"><vh>endexecuting</vh></v>
<v t="ekr.20060521134315.230"><vh>close</vh></v>
<v t="ekr.20060521134315.231"><vh>close2</vh></v>
<v t="ekr.20060521134315.232"><vh>_close</vh></v>
<v t="ekr.20060521134315.233"><vh>ispythonsource</vh></v>
<v t="ekr.20060521134315.234"><vh>short_title</vh></v>
<v t="ekr.20060521134315.235"><vh>begin</vh></v>
<v t="ekr.20060521134315.236"><vh>readline</vh></v>
<v t="ekr.20060521134315.237"><vh>isatty</vh></v>
<v t="ekr.20060521134315.238"><vh>cancel_callback</vh></v>
<v t="ekr.20060521134315.239"><vh>eof_callback</vh></v>
<v t="ekr.20060521134315.240"><vh>home_callback</vh></v>
<v t="ekr.20060521134315.241"><vh>linefeed_callback</vh></v>
<v t="ekr.20060521134315.242"><vh>enter_callback</vh></v>
<v t="ekr.20060521134315.243"><vh>recall</vh></v>
<v t="ekr.20060521134315.244"><vh>runit</vh></v>
<v t="ekr.20060521134315.245"><vh>open_stack_viewer</vh></v>
<v t="ekr.20060521134315.246"><vh>view_restart_mark</vh></v>
<v t="ekr.20060521134315.247"><vh>restart_shell</vh></v>
<v t="ekr.20060521134315.248"><vh>showprompt</vh></v>
<v t="ekr.20060521134315.249"><vh>resetoutput</vh></v>
<v t="ekr.20060521134315.250"><vh>write</vh></v>
</v>
<v t="ekr.20060521134315.251"><vh>class PseudoFile</vh>
<v t="ekr.20060521134315.252"><vh>__init__</vh></v>
<v t="ekr.20060521134315.253"><vh>write</vh></v>
<v t="ekr.20060521134315.254"><vh>writelines</vh></v>
<v t="ekr.20060521134315.255"><vh>flush</vh></v>
<v t="ekr.20060521134315.256"><vh>isatty</vh></v>
</v>
<v t="ekr.20060521134315.257"><vh>main</vh></v>
</v>
<v t="ekr.20060521134315.304" a="E"><vh>RemoteDebugger.py</vh>
<v t="ekr.20060521134315.305"><vh>&lt;&lt; RemoteDebugger declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.306"><vh>wrap_frame</vh></v>
<v t="ekr.20060521134315.307"><vh>wrap_info</vh></v>
<v t="ekr.20060521134315.308"><vh>class GUIProxy</vh>
<v t="ekr.20060521134315.309"><vh>__init__</vh></v>
<v t="ekr.20060521134315.310"><vh>interaction</vh></v>
</v>
<v t="ekr.20060521134315.311"><vh>class IdbAdapter</vh>
<v t="ekr.20060521134315.312"><vh>__init__</vh></v>
<v t="ekr.20060521134315.313"><vh>set_step</vh></v>
<v t="ekr.20060521134315.314"><vh>set_quit</vh></v>
<v t="ekr.20060521134315.315"><vh>set_continue</vh></v>
<v t="ekr.20060521134315.316"><vh>set_next</vh></v>
<v t="ekr.20060521134315.317"><vh>set_return</vh></v>
<v t="ekr.20060521134315.318"><vh>get_stack</vh></v>
<v t="ekr.20060521134315.319"><vh>run</vh></v>
<v t="ekr.20060521134315.320"><vh>set_break</vh></v>
<v t="ekr.20060521134315.321"><vh>clear_break</vh></v>
<v t="ekr.20060521134315.322"><vh>clear_all_file_breaks</vh></v>
<v t="ekr.20060521134315.323"><vh>frame_attr</vh></v>
<v t="ekr.20060521134315.324"><vh>frame_globals</vh></v>
<v t="ekr.20060521134315.325"><vh>frame_locals</vh></v>
<v t="ekr.20060521134315.326"><vh>frame_code</vh></v>
<v t="ekr.20060521134315.327"><vh>code_name</vh></v>
<v t="ekr.20060521134315.328"><vh>code_filename</vh></v>
<v t="ekr.20060521134315.329"><vh>dict_keys</vh></v>
<v t="ekr.20060521134315.330"><vh>dict_item</vh></v>
</v>
<v t="ekr.20060521134315.331"><vh>start_debugger</vh></v>
<v t="ekr.20060521134315.332"><vh>class FrameProxy</vh>
<v t="ekr.20060521134315.333"><vh>__init__</vh></v>
<v t="ekr.20060521134315.334"><vh>__getattr__</vh></v>
<v t="ekr.20060521134315.335"><vh>_get_f_code</vh></v>
<v t="ekr.20060521134315.336"><vh>_get_f_globals</vh></v>
<v t="ekr.20060521134315.337"><vh>_get_f_locals</vh></v>
<v t="ekr.20060521134315.338"><vh>_get_dict_proxy</vh></v>
</v>
<v t="ekr.20060521134315.339"><vh>class CodeProxy</vh>
<v t="ekr.20060521134315.340"><vh>__init__</vh></v>
<v t="ekr.20060521134315.341"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20060521134315.342"><vh>class DictProxy</vh>
<v t="ekr.20060521134315.343"><vh>__init__</vh></v>
<v t="ekr.20060521134315.344"><vh>keys</vh></v>
<v t="ekr.20060521134315.345"><vh>__getitem__</vh></v>
<v t="ekr.20060521134315.346"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20060521134315.347"><vh>class GUIAdapter</vh>
<v t="ekr.20060521134315.348"><vh>__init__</vh></v>
<v t="ekr.20060521134315.349"><vh>interaction</vh></v>
</v>
<v t="ekr.20060521134315.350"><vh>class IdbProxy</vh>
<v t="ekr.20060521134315.351"><vh>__init__</vh></v>
<v t="ekr.20060521134315.352"><vh>call</vh></v>
<v t="ekr.20060521134315.353"><vh>run</vh></v>
<v t="ekr.20060521134315.354"><vh>get_stack</vh></v>
<v t="ekr.20060521134315.355"><vh>set_continue</vh></v>
<v t="ekr.20060521134315.356"><vh>set_step</vh></v>
<v t="ekr.20060521134315.357"><vh>set_next</vh></v>
<v t="ekr.20060521134315.358"><vh>set_return</vh></v>
<v t="ekr.20060521134315.359"><vh>set_quit</vh></v>
<v t="ekr.20060521134315.360"><vh>set_break</vh></v>
<v t="ekr.20060521134315.361"><vh>clear_break</vh></v>
<v t="ekr.20060521134315.362"><vh>clear_all_file_breaks</vh></v>
</v>
<v t="ekr.20060521134315.363"><vh>start_remote_debugger</vh></v>
<v t="ekr.20060521134315.364"><vh>close_remote_debugger</vh></v>
<v t="ekr.20060521134315.365"><vh>close_subprocess_debugger</vh></v>
<v t="ekr.20060521134315.366"><vh>restart_subprocess_debugger</vh></v>
</v>
<v t="ekr.20060521134315.258" a="E"><vh>Debugger.py</vh>
<v t="ekr.20060521134315.259"><vh>&lt;&lt; Debugger declarations &gt;&gt;</vh></v>
<v t="ekr.20060521134315.261"><vh>class Idb (bdb.Bdb)</vh>
<v t="ekr.20060521134315.262"><vh>__init__</vh></v>
<v t="ekr.20060521134315.263"><vh>user_line</vh></v>
<v t="ekr.20060521134315.264"><vh>user_exception</vh></v>
<v t="ekr.20060521134315.265"><vh>in_rpc_code</vh></v>
<v t="ekr.20060521134315.266"><vh>__frame2message</vh></v>
</v>
<v t="ekr.20060521134315.267" a="E"><vh>class Debugger</vh>
<v t="ekr.20060521134315.268"><vh>__init__</vh></v>
<v t="ekr.20060521134315.269"><vh>run</vh></v>
<v t="ekr.20060521134315.270"><vh>close</vh></v>
<v t="ekr.20060521134315.271"><vh>make_gui</vh></v>
<v t="ekr.20060521134315.272"><vh>interaction</vh></v>
<v t="ekr.20060521134315.273"><vh>sync_source_line</vh></v>
<v t="ekr.20060521134315.274"><vh>__frame2fileline</vh></v>
<v t="ekr.20060521134315.275"><vh>cont</vh></v>
<v t="ekr.20060521134315.276"><vh>step</vh></v>
<v t="ekr.20060521134315.277"><vh>next</vh></v>
<v t="ekr.20060521134315.278"><vh>ret</vh></v>
<v t="ekr.20060521134315.279"><vh>quit</vh></v>
<v t="ekr.20060521134315.280"><vh>show_stack</vh></v>
<v t="ekr.20060521134315.281"><vh>show_source</vh></v>
<v t="ekr.20060521134315.282"><vh>show_frame</vh></v>
<v t="ekr.20060521134315.283"><vh>show_locals</vh></v>
<v t="ekr.20060521134315.284"><vh>show_globals</vh></v>
<v t="ekr.20060521134315.285"><vh>show_variables</vh></v>
<v t="ekr.20060521134315.286"><vh>set_breakpoint_here</vh></v>
<v t="ekr.20060521134315.287"><vh>clear_breakpoint_here</vh></v>
<v t="ekr.20060521134315.288"><vh>clear_file_breaks</vh></v>
<v t="ekr.20060521134315.289"><vh>load_breakpoints</vh></v>
</v>
<v t="ekr.20060521134315.290"><vh>class StackViewer</vh>
<v t="ekr.20060521134315.291"><vh>__init__</vh></v>
<v t="ekr.20060521134315.292"><vh>load_stack</vh></v>
<v t="ekr.20060521134315.293"><vh>popup_event</vh></v>
<v t="ekr.20060521134315.294"><vh>fill_menu</vh></v>
<v t="ekr.20060521134315.295"><vh>on_select</vh></v>
<v t="ekr.20060521134315.296"><vh>on_double</vh></v>
<v t="ekr.20060521134315.297"><vh>goto_source_line</vh></v>
<v t="ekr.20060521134315.298"><vh>show_stack_frame</vh></v>
<v t="ekr.20060521134315.299"><vh>show_source</vh></v>
</v>
<v t="ekr.20060521134315.300"><vh>class NamespaceViewer</vh>
<v t="ekr.20060521134315.301"><vh>__init__</vh></v>
<v t="ekr.20060521134315.302"><vh>load_dict</vh></v>
<v t="ekr.20060521134315.303"><vh>close</vh></v>
</v>
</v>
</v>
<v t="ekr.20060521134315.3" a="V"><vh>IdleLeo (not a good idea)</vh>
<v t="ekr.20060521134315.4"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060521134315.5"><vh>&lt;&lt; to do &gt;&gt;</vh></v>
<v t="ekr.20060521134315.6"><vh>myMain</vh></v>
<v t="ekr.20060521134315.7"><vh>leoPyShellEditorWindow (PyShellEditorWindow)</vh>
<v t="ekr.20060521134315.8"><vh>ctor: leoPyShellEditorWindow </vh></v>
<v t="ekr.20060521134315.9" a="E"><vh>Copied from PyShellEditorWindow</vh>
<v t="ekr.20060521134315.10"><vh>Unused</vh>
<v t="ekr.20060521134315.11"><vh>__init__</vh></v>
</v>
<v t="ekr.20060521134315.12"><vh>set_breakpoint</vh></v>
<v t="ekr.20060521134315.13"><vh>set_breakpoint_here</vh></v>
<v t="ekr.20060521134315.14"><vh>clear_breakpoint_here</vh></v>
<v t="ekr.20060521134315.15"><vh>clear_file_breaks</vh></v>
<v t="ekr.20060521134315.16"><vh>store_file_breaks</vh>
<v t="ekr.20060521134315.17"><vh>&lt;&lt; about store_file_breaks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060521134315.18"><vh>restore_file_breaks</vh></v>
<v t="ekr.20060521134315.19"><vh>update_breakpoints</vh></v>
<v t="ekr.20060521134315.20"><vh>ranges_to_linenumbers</vh></v>
<v t="ekr.20060521134315.21"><vh>_close</vh></v>
</v>
</v>
<v t="ekr.20060521134315.22"><vh>leoPyShell (PyShell)</vh>
<v t="ekr.20060521134315.23"><vh>ctor: leoPyShell</vh></v>
<v t="ekr.20060521134315.24"><vh>begin</vh></v>
</v>
<v t="ekr.20060521134315.25" a="E"><vh>leoPyShellFileList (FileList)</vh>
<v t="ekr.20060521134315.26"><vh>ctor: leoPyShellFileList</vh></v>
<v t="ekr.20060521134315.27"><vh>open_shell</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20060521134315.3">&lt;&lt; to do &gt;&gt;
&lt;&lt; imports &gt;&gt;

@others

args = ['-d'] # Show debugger window on startup.
args = []
args = [r'c:\Python24\Lib\idlelib\EditorWindow.py'] # Edit file on startup.

if 1:
    myMain(args)
else: # Works.
    sys.argv = args
    if 0:
        # Sharing Leo's root is dangerous: killing idle kills Leo.
        # Important: I added the previousRoot arg to Idle's source code.
        idlelib.PyShell.main(previousRoot=g.app.gui.root)
    else: # Safe, and easy.
        idlelib.PyShell.main()</t>
<t tx="ekr.20060521134315.4">import idlelib.PyShell
import os
import sys
import Tkinter</t>
<t tx="ekr.20060521134315.5">@

The pyshell class overrides bindings.
</t>
<t tx="ekr.20060521134315.6"># Adapted from idlelib.PyShel.main.

def myMain(args):
    # global flist, root, use_subprocess
    if 1: # Leo continues when the Idle process dies.
        root = Tkinter.Tk(className="Idle")
        idlelib.PyShell.fixwordbreaks(root)
        root.withdraw()
    else: # Leo dies when Idle dies.
        root = g.app.gui.root

    # idlelib.PyShel.main sets these from sys.argv.
    cmd = False
    debug = True
    edit_start = True
    enable_edit = True 
    enable_shell = True
    script = False
    startup = False
    
    print '-' * 40
    
    flist = leoPyShellFileList(root)
    # flist = idlelib.PyShell.PyShellFileList(root) # works.
    
    # Set the globals.
    idlelib.PyShell.use_subprocess = True 
    idlelib.PyShell.root = root
    idlelib.PyShell.flist = flist
    
    if enable_edit:
        if not (cmd or script):
            for filename in args:
                if filename:
                    flist.open(filename)
            # if not args:
                # flist.new()
    if enable_shell:
        if not flist.open_shell():
            return # couldn't open shell
    shell = flist.pyshell
    # handle remaining options:
    if debug:
        shell.open_debugger()

    if startup:
        filename = os.environ.get("IDLESTARTUP") or \
                   os.environ.get("PYTHONSTARTUP")
        if filename and os.path.isfile(filename):
            shell.interp.execfile(filename)

    if shell and cmd or script:
        shell.interp.runcommand("""if 1:
            import sys as _sys
            _sys.argv = %r
            del _sys
            \n""" % (sys.argv,))
        if cmd:
            shell.interp.execsource(cmd)
        elif script:
            shell.interp.prepend_syspath(script)
            shell.interp.execfile(script)
            
    root.mainloop()
    # root.destroy() # This causes problems.</t>
<t tx="ekr.20060521134315.7">class leoPyShellEditorWindow (idlelib.PyShell.PyShellEditorWindow):
    
    '''An over-ride of PyShellEditorWindow intended to support Leo outlines.'''
    
    @others</t>
<t tx="ekr.20060521134315.8">def __init__ (self,*args):
    
    print 'leoPyShellEditorWindow','args...\n',g.listToString(args)
    
    if 1:
        # Init the base class.
        # Weird: somehow self has become appended to args.
        idlelib.PyShell.PyShellEditorWindow(*args)</t>
<t tx="ekr.20060521134315.9"></t>
<t tx="ekr.20060521134315.10">if 0:
    @others</t>
<t tx="ekr.20060521134315.11">def __init__(self, *args):
    
    # print 'EKR PyShellEditorWindow.__init__','args',args
    self.breakpoints = []
    EditorWindow.__init__(self, *args)
    self.text.bind("&lt; &lt;set-breakpoint-here&gt;&gt;", self.set_breakpoint_here)
    self.text.bind("&lt; &lt;clear-breakpoint-here&gt;&gt;", self.clear_breakpoint_here)
    self.text.bind("&lt; &lt;open-python-shell&gt;&gt;", self.flist.open_shell)

    self.breakpointPath = os.path.join(idleConf.GetUserCfgDir(),
                                       'breakpoints.lst')
    # whenever a file is changed, restore breakpoints
    if self.io.filename: self.restore_file_breaks()
    def filename_changed_hook(old_hook=self.io.filename_change_hook,
                              self=self):
        self.restore_file_breaks()
        old_hook()
    self.io.set_filename_change_hook(filename_changed_hook)

</t>
<t tx="ekr.20060521134315.12"># rmenu_specs = [
    # ("Set Breakpoint", "&lt; &lt;set-breakpoint-here&gt;&gt;"),
    # ("Clear Breakpoint", "&lt; &lt;clear-breakpoint-here&gt;&gt;")
# ]

def set_breakpoint(self, lineno):
    g.trace(lineno)
    text = self.text
    filename = self.io.filename
    text.tag_add("BREAK", "%d.0" % lineno, "%d.0" % (lineno+1))

    try:
        i = self.breakpoints.index(lineno)
    except ValueError:  # only add if missing, i.e. do once
        self.breakpoints.append(lineno)
    try:    # update the subprocess debugger
        debug = self.flist.pyshell.interp.debugger
        debug.set_breakpoint_here(filename, lineno)
    except: # but debugger may not be active right now....
        pass</t>
<t tx="ekr.20060521134315.13">def set_breakpoint_here(self, event=None):
    
    text = self.text
    filename = self.io.filename
    g.trace(self.io.filename)
    if not filename:
        text.bell()
        return
    lineno = int(float(text.index("insert")))
    self.set_breakpoint(lineno)
</t>
<t tx="ekr.20060521134315.14">def clear_breakpoint_here(self, event=None):
    text = self.text
    filename = self.io.filename
    if not filename:
        text.bell()
        return
    lineno = int(float(text.index("insert")))
    try:
        self.breakpoints.remove(lineno)
    except:
        pass
    text.tag_remove("BREAK", "insert linestart",\
                    "insert lineend +1char")
    try:
        debug = self.flist.pyshell.interp.debugger
        debug.clear_breakpoint_here(filename, lineno)
    except:
        pass
</t>
<t tx="ekr.20060521134315.15">def clear_file_breaks(self):
    if self.breakpoints:
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        self.breakpoints = []
        text.tag_remove("BREAK", "1.0", END)
        try:
            debug = self.flist.pyshell.interp.debugger
            debug.clear_file_breaks(filename)
        except:
            pass</t>
<t tx="ekr.20060521134315.16">def store_file_breaks(self):
    "Save breakpoints when file is saved"
    &lt;&lt; about store_file_breaks &gt;&gt;
    breaks = self.breakpoints
    filename = self.io.filename
    try:
        lines = open(self.breakpointPath,"r").readlines()
    except IOError:
        lines = []
    new_file = open(self.breakpointPath,"w")
    for line in lines:
        if not line.startswith(filename + '='):
            new_file.write(line)
    self.update_breakpoints()
    breaks = self.breakpoints
    if breaks:
        new_file.write(filename + '=' + str(breaks) + '\n')
    new_file.close()</t>
<t tx="ekr.20060521134315.17">@
XXX 13 Dec 2002 KBK Currently the file must be saved before it can be run. The
breaks are saved at that time. If we introduce a temporary file save feature the
save breaks functionality needs to be re-verified, since the breaks at the time
the temp file is created may differ from the breaks at the last permanent save
of the file. Currently, a break introduced after a save will be effective, but
not persistent. This is necessary to keep the saved breaks synched with the
saved file.

Breakpoints are set as tagged ranges in the text. Certain kinds of edits cause
these ranges to be deleted: Inserting or deleting a line just before a
breakpoint, and certain deletions prior to a breakpoint. These issues need to be
investigated and understood. It's not clear if they are Tk issues or IDLE
issues, or whether they can actually be fixed. Since a modified file has to be
saved before it is run, and since self.breakpoints (from which the subprocess
debugger is loaded) is updated during the save, the visible breaks stay synched
with the subprocess even if one of these unexpected breakpoint deletions
occurs.</t>
<t tx="ekr.20060521134315.18">def restore_file_breaks(self):

    self.text.update()   # this enables setting "BREAK" tags to be visible
    filename = self.io.filename
    if filename is None:
        return
    if os.path.isfile(self.breakpointPath):
        lines = open(self.breakpointPath,"r").readlines()
        for line in lines:
            if line.startswith(filename + '='):
                breakpoint_linenumbers = eval(line[len(filename)+1:])
                for breakpoint_linenumber in breakpoint_linenumbers:
                    self.set_breakpoint(breakpoint_linenumber)
</t>
<t tx="ekr.20060521134315.19">def update_breakpoints(self):

    "Retrieves all the breakpoints in the current window"

    text = self.text
    ranges = text.tag_ranges("BREAK")
    linenumber_list = self.ranges_to_linenumbers(ranges)
    self.breakpoints = linenumber_list
</t>
<t tx="ekr.20060521134315.20">def ranges_to_linenumbers(self, ranges):
    
    lines = []
    for index in range(0, len(ranges), 2):
        lineno = int(float(ranges[index]))
        end = int(float(ranges[index+1]))
        while lineno &lt; end:
            lines.append(lineno)
            lineno += 1
    return lines
</t>
<t tx="ekr.20060521134315.21">if 0: # XXX 13 Dec 2002 KBK Not used currently
    def saved_change_hook(self):
        "Extend base method - clear breaks if module is modified"
        if not self.get_saved():
            self.clear_file_breaks()
        EditorWindow.saved_change_hook(self)

def _close(self):
    "Extend base method - clear breaks when module is closed"
    self.clear_file_breaks()
    EditorWindow._close(self)
</t>
<t tx="ekr.20060521134315.22">class leoPyShell (idlelib.PyShell.PyShell):
    
    @others
</t>
<t tx="ekr.20060521134315.23">def __init__ (self,flist=None):
        
    # print 'leoPythonShell.__init__','flist',flist
    
    # Init the base class.
    idlelib.PyShell.PyShell.__init__(self,flist)</t>
<t tx="ekr.20060521134315.24">def begin(self):
    self.resetoutput()
    if idlelib.PyShell.use_subprocess:
        nosub = ''
        client = self.interp.start_subprocess()
        if not client:
            self.close()
            return False
    else:
        nosub = "==== No Subprocess ===="
    
    if 1: # Suppress some stuff.
        self.write("Python %s on %s\nIDLE for Leo %s      %s\n" % (
            sys.version, sys.platform,idlelib.PyShell.idlever.IDLE_VERSION, nosub))
    else:
        self.write("Python %s on %s\n%s\n%s\nIDLE %s      %s\n" %
                   (sys.version, sys.platform, self.COPYRIGHT,
                    self.firewallmessage, idlever.IDLE_VERSION, nosub))
    self.showprompt()
    import Tkinter
    Tkinter._default_root = None # 03Jan04 KBK What's this?
    return True</t>
<t tx="ekr.20060521134315.25">class leoPyShellFileList(idlelib.FileList.FileList):
    
    '''Like PyShellFileList but uses leoPytShellEditorWindows instances
    instead of the EditorWindow instances.'''

    # override FileList's class variables
    pyshell = None
    EditorWindow = leoPyShellEditorWindow

    @others</t>
<t tx="ekr.20060521134315.26">def __init__ (self,root):
        
    # print 'leoPyShellFileList.__init__ root:',root
    
    idlelib.FileList.FileList.__init__(self,root)</t>
<t tx="ekr.20060521134315.27">def open_shell(self, event=None):
    
    '''Just like PyShellFileList.open_shell but uses leoPytShellEditorWindows
    instances instead of the EditorWindow instances.'''
    
    # g.trace('leoPyShellFileList.open_shell  pyshell:',self.pyshell)

    if self.pyshell:
        self.pyshell.top.wakeup()
    else:
        self.pyshell = leoPyShell(self)
        if self.pyshell:
            if not self.pyshell.begin():
                return None
    return self.pyshell</t>
<t tx="ekr.20060521134315.28"></t>
<t tx="ekr.20060521134315.29">class PyShell(OutputWindow):

    shell_title = "Python Shell"

    # Override classes
    ColorDelegator = ModifiedColorDelegator
    UndoDelegator = ModifiedUndoDelegator

    # Override menus
    menu_specs = [
        ("file", "_File"),
        ("edit", "_Edit"),
        ("debug", "_Debug"),
        ("options", "_Options"),
        ("windows", "_Windows"),
        ("help", "_Help"),
    ]

    # New classes
    from IdleHistory import History

    def __init__(self, flist=None):
        if use_subprocess:
            ms = self.menu_specs
            if ms[2][0] != "shell":
                ms.insert(2, ("shell", "_Shell"))
        self.interp = ModifiedInterpreter(self)
        if flist is None:
            root = Tk()
            fixwordbreaks(root)
            root.withdraw()
            flist = PyShellFileList(root)
        #
        OutputWindow.__init__(self, flist, None, None)
        #
        import __builtin__
        __builtin__.quit = __builtin__.exit = "To exit, type Ctrl-D."
        #
        self.config(usetabs=1, indentwidth=8, context_use_ps1=1)
        #
        text = self.text
        text.configure(wrap="char")
        text.bind("&lt;&lt;newline-and-indent&gt;&gt;", self.enter_callback)
        text.bind("&lt;&lt;plain-newline-and-indent&gt;&gt;", self.linefeed_callback)
        text.bind("&lt;&lt;interrupt-execution&gt;&gt;", self.cancel_callback)
        text.bind("&lt;&lt;beginning-of-line&gt;&gt;", self.home_callback)
        text.bind("&lt;&lt;end-of-file&gt;&gt;", self.eof_callback)
        text.bind("&lt;&lt;open-stack-viewer&gt;&gt;", self.open_stack_viewer)
        text.bind("&lt;&lt;toggle-debugger&gt;&gt;", self.toggle_debugger)
        text.bind("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;", self.toggle_jit_stack_viewer)
        if use_subprocess:
            text.bind("&lt;&lt;view-restart&gt;&gt;", self.view_restart_mark)
            text.bind("&lt;&lt;restart-shell&gt;&gt;", self.restart_shell)
        #
        self.save_stdout = sys.stdout
        self.save_stderr = sys.stderr
        self.save_stdin = sys.stdin
        import IOBinding
        self.stdout = PseudoFile(self, "stdout", IOBinding.encoding)
        self.stderr = PseudoFile(self, "stderr", IOBinding.encoding)
        self.console = PseudoFile(self, "console", IOBinding.encoding)
        if not use_subprocess:
            sys.stdout = self.stdout
            sys.stderr = self.stderr
            sys.stdin = self
        #
        self.history = self.History(self.text)
        #
        self.pollinterval = 50  # millisec

    def get_standard_extension_names(self):
        return idleConf.GetExtensions(shell_only=True)

    reading = False
    executing = False
    canceled = False
    endoffile = False
    closing = False

    def set_warning_stream(self, stream):
        global warning_stream
        warning_stream = stream

    def get_warning_stream(self):
        return warning_stream

    def toggle_debugger(self, event=None):
        if self.executing:
            tkMessageBox.showerror("Don't debug now",
                "You can only toggle the debugger when idle",
                master=self.text)
            self.set_debugger_indicator()
            return "break"
        else:
            db = self.interp.getdebugger()
            if db:
                self.close_debugger()
            else:
                self.open_debugger()

    def set_debugger_indicator(self):
        db = self.interp.getdebugger()
        self.setvar("&lt;&lt;toggle-debugger&gt;&gt;", not not db)

    def toggle_jit_stack_viewer(self, event=None):
        pass # All we need is the variable

    def close_debugger(self):
        db = self.interp.getdebugger()
        if db:
            self.interp.setdebugger(None)
            db.close()
            if self.interp.rpcclt:
                RemoteDebugger.close_remote_debugger(self.interp.rpcclt)
            self.resetoutput()
            self.console.write("[DEBUG OFF]\n")
            sys.ps1 = "&gt;&gt;&gt; "
            self.showprompt()
        self.set_debugger_indicator()

    def open_debugger(self):
        if self.interp.rpcclt:
            dbg_gui = RemoteDebugger.start_remote_debugger(self.interp.rpcclt,
                                                           self)
        else:
            dbg_gui = Debugger.Debugger(self)
        self.interp.setdebugger(dbg_gui)
        dbg_gui.load_breakpoints()
        sys.ps1 = "[DEBUG ON]\n&gt;&gt;&gt; "
        self.showprompt()
        self.set_debugger_indicator()

    def beginexecuting(self):
        "Helper for ModifiedInterpreter"
        self.resetoutput()
        self.executing = 1

    def endexecuting(self):
        "Helper for ModifiedInterpreter"
        self.executing = 0
        self.canceled = 0
        self.showprompt()

    def close(self):
        "Extend EditorWindow.close()"
        if self.executing:
            response = tkMessageBox.askokcancel(
                "Kill?",
                "The program is still running!\n Do you want to kill it?",
                default="ok",
                parent=self.text)
            if response == False:
                return "cancel"
        self.closing = True
        # Wait for poll_subprocess() rescheduling to stop
        self.text.after(2 * self.pollinterval, self.close2)

    def close2(self):
        return EditorWindow.close(self)

    def _close(self):
        "Extend EditorWindow._close(), shut down debugger and execution server"
        self.close_debugger()
        if use_subprocess:
            self.interp.kill_subprocess()
        # Restore std streams
        sys.stdout = self.save_stdout
        sys.stderr = self.save_stderr
        sys.stdin = self.save_stdin
        # Break cycles
        self.interp = None
        self.console = None
        self.flist.pyshell = None
        self.history = None
        EditorWindow._close(self)

    def ispythonsource(self, filename):
        "Override EditorWindow method: never remove the colorizer"
        return True

    def short_title(self):
        return self.shell_title

    COPYRIGHT = \
          'Type "copyright", "credits" or "license()" for more information.'

    firewallmessage = """
    ****************************************************************
    Personal firewall software may warn about the connection IDLE
    makes to its subprocess using this computer's internal loopback
    interface.  This connection is not visible on any external
    interface and no data is sent to or received from the Internet.
    ****************************************************************
    """

    def begin(self):
        self.resetoutput()
        if use_subprocess:
            nosub = ''
            client = self.interp.start_subprocess()
            if not client:
                self.close()
                return False
        else:
            nosub = "==== No Subprocess ===="
        self.write("Python %s on %s\n%s\n%s\nIDLE %s      %s\n" %
                   (sys.version, sys.platform, self.COPYRIGHT,
                    self.firewallmessage, idlever.IDLE_VERSION, nosub))
        self.showprompt()
        import Tkinter
        Tkinter._default_root = None # 03Jan04 KBK What's this?
        return True

    def readline(self):
        save = self.reading
        try:
            self.reading = 1
            self.top.mainloop()
        finally:
            self.reading = save
        line = self.text.get("iomark", "end-1c")
        if isinstance(line, unicode):
            import IOBinding
            try:
                line = line.encode(IOBinding.encoding)
            except UnicodeError:
                pass
        self.resetoutput()
        if self.canceled:
            self.canceled = 0
            raise KeyboardInterrupt
        if self.endoffile:
            self.endoffile = 0
            return ""
        return line

    def isatty(self):
        return True

    def cancel_callback(self, event=None):
        try:
            if self.text.compare("sel.first", "!=", "sel.last"):
                return # Active selection -- always use default binding
        except:
            pass
        if not (self.executing or self.reading):
            self.resetoutput()
            self.interp.write("KeyboardInterrupt\n")
            self.showprompt()
            return "break"
        self.endoffile = 0
        self.canceled = 1
        if self.reading:
            self.top.quit()
        elif (self.executing and self.interp.rpcclt):
            if self.interp.getdebugger():
                self.interp.restart_subprocess()
            else:
                self.interp.interrupt_subprocess()
        return "break"

    def eof_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (delete next char) take over
        if not (self.text.compare("iomark", "==", "insert") and
                self.text.compare("insert", "==", "end-1c")):
            return # Let the default binding (delete next char) take over
        if not self.executing:
            self.resetoutput()
            self.close()
        else:
            self.canceled = 0
            self.endoffile = 1
            self.top.quit()
        return "break"

    def home_callback(self, event):
        if event.state != 0 and event.keysym == "Home":
            return # &lt;Modifier-Home&gt;; fall back to class binding
        if self.text.compare("iomark", "&lt;=", "insert") and \
           self.text.compare("insert linestart", "&lt;=", "iomark"):
            self.text.mark_set("insert", "iomark")
            self.text.tag_remove("sel", "1.0", "end")
            self.text.see("insert")
            return "break"

    def linefeed_callback(self, event):
        # Insert a linefeed without entering anything (still autoindented)
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        return "break"

    def enter_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (insert '\n') take over
        # If some text is selected, recall the selection
        # (but only if this before the I/O mark)
        try:
            sel = self.text.get("sel.first", "sel.last")
            if sel:
                if self.text.compare("sel.last", "&lt;=", "iomark"):
                    self.recall(sel)
                    return "break"
        except:
            pass
        # If we're strictly before the line containing iomark, recall
        # the current line, less a leading prompt, less leading or
        # trailing whitespace
        if self.text.compare("insert", "&lt;", "iomark linestart"):
            # Check if there's a relevant stdin range -- if so, use it
            prev = self.text.tag_prevrange("stdin", "insert")
            if prev and self.text.compare("insert", "&lt;", prev[1]):
                self.recall(self.text.get(prev[0], prev[1]))
                return "break"
            next = self.text.tag_nextrange("stdin", "insert")
            if next and self.text.compare("insert lineend", "&gt;=", next[0]):
                self.recall(self.text.get(next[0], next[1]))
                return "break"
            # No stdin mark -- just get the current line, less any prompt
            line = self.text.get("insert linestart", "insert lineend")
            last_line_of_prompt = sys.ps1.split('\n')[-1]
            if line.startswith(last_line_of_prompt):
                line = line[len(last_line_of_prompt):]
            self.recall(line)
            return "break"
        # If we're between the beginning of the line and the iomark, i.e.
        # in the prompt area, move to the end of the prompt
        if self.text.compare("insert", "&lt;", "iomark"):
            self.text.mark_set("insert", "iomark")
        # If we're in the current input and there's only whitespace
        # beyond the cursor, erase that whitespace first
        s = self.text.get("insert", "end-1c")
        if s and not s.strip():
            self.text.delete("insert", "end-1c")
        # If we're in the current input before its last line,
        # insert a newline right at the insert point
        if self.text.compare("insert", "&lt;", "end-1c linestart"):
            self.newline_and_indent_event(event)
            return "break"
        # We're in the last line; append a newline and submit it
        self.text.mark_set("insert", "end-1c")
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        self.text.tag_add("stdin", "iomark", "end-1c")
        self.text.update_idletasks()
        if self.reading:
            self.top.quit() # Break out of recursive mainloop() in raw_input()
        else:
            self.runit()
        return "break"

    def recall(self, s):
        if self.history:
            self.history.recall(s)

    def runit(self):
        line = self.text.get("iomark", "end-1c")
        # Strip off last newline and surrounding whitespace.
        # (To allow you to hit return twice to end a statement.)
        i = len(line)
        while i &gt; 0 and line[i-1] in " \t":
            i = i-1
        if i &gt; 0 and line[i-1] == "\n":
            i = i-1
        while i &gt; 0 and line[i-1] in " \t":
            i = i-1
        line = line[:i]
        more = self.interp.runsource(line)

    def open_stack_viewer(self, event=None):
        if self.interp.rpcclt:
            return self.interp.remote_stack_viewer()
        try:
            sys.last_traceback
        except:
            tkMessageBox.showerror("No stack trace",
                "There is no stack trace yet.\n"
                "(sys.last_traceback is not defined)",
                master=self.text)
            return
        from StackViewer import StackBrowser
        sv = StackBrowser(self.root, self.flist)

    def view_restart_mark(self, event=None):
        self.text.see("iomark")
        self.text.see("restart")

    def restart_shell(self, event=None):
        self.interp.restart_subprocess()

    def showprompt(self):
        self.resetoutput()
        try:
            s = str(sys.ps1)
        except:
            s = ""
        self.console.write(s)
        self.text.mark_set("insert", "end-1c")
        self.set_line_and_column()
        self.io.reset_undo()

    def resetoutput(self):
        source = self.text.get("iomark", "end-1c")
        if self.history:
            self.history.history_store(source)
        if self.text.get("end-2c") != "\n":
            self.text.insert("end-1c", "\n")
        self.text.mark_set("iomark", "end-1c")
        self.set_line_and_column()
        sys.stdout.softspace = 0

    def write(self, s, tags=()):
        try:
            self.text.mark_gravity("iomark", "right")
            OutputWindow.write(self, s, tags, "iomark")
            self.text.mark_gravity("iomark", "left")
        except:
            pass
        if self.canceled:
            self.canceled = 0
            if not use_subprocess:
                raise KeyboardInterrupt</t>
<t tx="ekr.20060521134315.30">"""Extend linecache.checkcache to preserve the &lt;pyshell#...&gt; entries

Rather than repeating the linecache code, patch it to save the
&lt;pyshell#...&gt; entries, call the original linecache.checkcache()
(which destroys them), and then restore the saved entries.

orig_checkcache is bound at definition time to the original
method, allowing it to be patched.

"""
cache = linecache.cache
save = {}
for filename in cache.keys():
    if filename[:1] + filename[-1:] == '&lt;&gt;':
        save[filename] = cache[filename]
orig_checkcache()
cache.update(save)

# Patch linecache.checkcache():
linecache.checkcache = extended_linecache_checkcache

class PyShellEditorWindow(EditorWindow):
	"Regular text edit window in IDLE, supports breakpoints"
	@others</t>
<t tx="ekr.20060521134315.31">def __init__(self, *args):
    
    # print 'EKR PyShellEditorWindow.__init__','args',args
    self.breakpoints = []
    EditorWindow.__init__(self, *args)
    self.text.bind("&lt;&lt;set-breakpoint-here&gt;&gt;", self.set_breakpoint_here)
    self.text.bind("&lt;&lt;clear-breakpoint-here&gt;&gt;", self.clear_breakpoint_here)
    self.text.bind("&lt;&lt;open-python-shell&gt;&gt;", self.flist.open_shell)

    self.breakpointPath = os.path.join(idleConf.GetUserCfgDir(),
                                       'breakpoints.lst')
    # whenever a file is changed, restore breakpoints
    if self.io.filename: self.restore_file_breaks()
    def filename_changed_hook(old_hook=self.io.filename_change_hook,
                              self=self):
        self.restore_file_breaks()
        old_hook()
    self.io.set_filename_change_hook(filename_changed_hook)

</t>
<t tx="ekr.20060521134315.32"># rmenu_specs = [
    # ("Set Breakpoint", "&lt; &lt;set-breakpoint-here&gt;&gt;"),
    # ("Clear Breakpoint", "&lt; &lt;clear-breakpoint-here&gt;&gt;")
# ]

def set_breakpoint(self, lineno):
    text = self.text
    filename = self.io.filename
    text.tag_add("BREAK", "%d.0" % lineno, "%d.0" % (lineno+1))
    try:
        i = self.breakpoints.index(lineno)
    except ValueError:  # only add if missing, i.e. do once
        self.breakpoints.append(lineno)
    try:    # update the subprocess debugger
        debug = self.flist.pyshell.interp.debugger
        debug.set_breakpoint_here(filename, lineno)
    except: # but debugger may not be active right now....
        pass</t>
<t tx="ekr.20060521134315.33">def set_breakpoint_here(self, event=None):
    text = self.text
    filename = self.io.filename
    if not filename:
        text.bell()
        return
    lineno = int(float(text.index("insert")))
    self.set_breakpoint(lineno)
</t>
<t tx="ekr.20060521134315.34">def clear_breakpoint_here(self, event=None):
    text = self.text
    filename = self.io.filename
    if not filename:
        text.bell()
        return
    lineno = int(float(text.index("insert")))
    try:
        self.breakpoints.remove(lineno)
    except:
        pass
    text.tag_remove("BREAK", "insert linestart",\
                    "insert lineend +1char")
    try:
        debug = self.flist.pyshell.interp.debugger
        debug.clear_breakpoint_here(filename, lineno)
    except:
        pass
</t>
<t tx="ekr.20060521134315.35">def clear_file_breaks(self):
    if self.breakpoints:
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        self.breakpoints = []
        text.tag_remove("BREAK", "1.0", END)
        try:
            debug = self.flist.pyshell.interp.debugger
            debug.clear_file_breaks(filename)
        except:
            pass</t>
<t tx="ekr.20060521134315.36">def store_file_breaks(self):
    "Save breakpoints when file is saved"
    &lt;&lt; about store_file_breaks &gt;&gt;
    breaks = self.breakpoints
    filename = self.io.filename
    try:
        lines = open(self.breakpointPath,"r").readlines()
    except IOError:
        lines = []
    new_file = open(self.breakpointPath,"w")
    for line in lines:
        if not line.startswith(filename + '='):
            new_file.write(line)
    self.update_breakpoints()
    breaks = self.breakpoints
    if breaks:
        new_file.write(filename + '=' + str(breaks) + '\n')
    new_file.close()</t>
<t tx="ekr.20060521134315.37">@
XXX 13 Dec 2002 KBK Currently the file must be saved before it can be run. The
breaks are saved at that time. If we introduce a temporary file save feature the
save breaks functionality needs to be re-verified, since the breaks at the time
the temp file is created may differ from the breaks at the last permanent save
of the file. Currently, a break introduced after a save will be effective, but
not persistent. This is necessary to keep the saved breaks synched with the
saved file.

Breakpoints are set as tagged ranges in the text. Certain kinds of edits cause
these ranges to be deleted: Inserting or deleting a line just before a
breakpoint, and certain deletions prior to a breakpoint. These issues need to be
investigated and understood. It's not clear if they are Tk issues or IDLE
issues, or whether they can actually be fixed. Since a modified file has to be
saved before it is run, and since self.breakpoints (from which the subprocess
debugger is loaded) is updated during the save, the visible breaks stay synched
with the subprocess even if one of these unexpected breakpoint deletions
occurs.</t>
<t tx="ekr.20060521134315.38">def restore_file_breaks(self):

    self.text.update()   # this enables setting "BREAK" tags to be visible
    filename = self.io.filename
    if filename is None:
        return
    if os.path.isfile(self.breakpointPath):
        lines = open(self.breakpointPath,"r").readlines()
        for line in lines:
            if line.startswith(filename + '='):
                breakpoint_linenumbers = eval(line[len(filename)+1:])
                for breakpoint_linenumber in breakpoint_linenumbers:
                    self.set_breakpoint(breakpoint_linenumber)
</t>
<t tx="ekr.20060521134315.39">def update_breakpoints(self):

    "Retrieves all the breakpoints in the current window"

    text = self.text
    ranges = text.tag_ranges("BREAK")
    linenumber_list = self.ranges_to_linenumbers(ranges)
    self.breakpoints = linenumber_list
</t>
<t tx="ekr.20060521134315.40">def ranges_to_linenumbers(self, ranges):
    
    lines = []
    for index in range(0, len(ranges), 2):
        lineno = int(float(ranges[index]))
        end = int(float(ranges[index+1]))
        while lineno &lt; end:
            lines.append(lineno)
            lineno += 1
    return lines
</t>
<t tx="ekr.20060521134315.41">if 0: # XXX 13 Dec 2002 KBK Not used currently
    def saved_change_hook(self):
        "Extend base method - clear breaks if module is modified"
        if not self.get_saved():
        self.clear_file_breaks()
        EditorWindow.saved_change_hook(self)

def _close(self):
    "Extend base method - clear breaks when module is closed"
    self.clear_file_breaks()
    EditorWindow._close(self)</t>
<t tx="ekr.20060521134315.42">class EditorWindow:
	&lt;&lt; EditorWindow imports &gt;&gt;
    help_url = None
	@others
</t>
<t tx="ekr.20060521134315.43">from Percolator import Percolator
from ColorDelegator import ColorDelegator
from UndoDelegator import UndoDelegator
from IOBinding import IOBinding
import Bindings
from Tkinter import Toplevel
from MultiStatusBar import MultiStatusBar</t>
<t tx="ekr.20060521134315.44">def __init__(self, flist=None, filename=None, key=None, root=None):
    if EditorWindow.help_url is None:
        dochome =  os.path.join(sys.prefix, 'Doc', 'index.html')
        if sys.platform.count('linux'):
            # look for html docs in a couple of standard places
            pyver = 'python-docs-' + '%s.%s.%s' % sys.version_info[:3]
            if os.path.isdir('/var/www/html/python/'):  # "python2" rpm
                dochome = '/var/www/html/python/index.html'
            else:
                basepath = '/usr/share/doc/'  # standard location
                dochome = os.path.join(basepath, pyver,
                                       'Doc', 'index.html')
        elif sys.platform[:3] == 'win':
            chmfile = os.path.join(sys.prefix, 'Doc',
                                   'Python%d%d.chm' % sys.version_info[:2])
            if os.path.isfile(chmfile):
                dochome = chmfile
        dochome = os.path.normpath(dochome)
        if os.path.isfile(dochome):
            EditorWindow.help_url = dochome
        else:
            EditorWindow.help_url = "http://www.python.org/doc/current"
    currentTheme=idleConf.CurrentTheme()
    self.flist = flist
    root = root or flist.root
    self.root = root
    self.menubar = Menu(root)
    self.top = top = WindowList.ListedToplevel(root, menu=self.menubar)
    if flist:
        self.tkinter_vars = flist.vars
        #self.top.instance_dict makes flist.inversedict avalable to
        #configDialog.py so it can access all EditorWindow instaces
        self.top.instance_dict=flist.inversedict
    else:
        self.tkinter_vars = {}  # keys: Tkinter event names
                                # values: Tkinter variable instances
    self.recent_files_path=os.path.join(idleConf.GetUserCfgDir(),
            'recent-files.lst')
    self.vbar = vbar = Scrollbar(top, name='vbar')
    self.text_frame = text_frame = Frame(top)
    self.width = idleConf.GetOption('main','EditorWindow','width')
    self.text = text = Text(text_frame, name='text', padx=5, wrap='none',
            foreground=idleConf.GetHighlight(currentTheme,
                    'normal',fgBg='fg'),
            background=idleConf.GetHighlight(currentTheme,
                    'normal',fgBg='bg'),
            highlightcolor=idleConf.GetHighlight(currentTheme,
                    'hilite',fgBg='fg'),
            highlightbackground=idleConf.GetHighlight(currentTheme,
                    'hilite',fgBg='bg'),
            insertbackground=idleConf.GetHighlight(currentTheme,
                    'cursor',fgBg='fg'),
            width=self.width,
            height=idleConf.GetOption('main','EditorWindow','height') )
    self.top.focused_widget = self.text

    self.createmenubar()
    self.apply_bindings()

    self.top.protocol("WM_DELETE_WINDOW", self.close)
    self.top.bind("&lt;&lt;close-window&gt;&gt;", self.close_event)
    text.bind("&lt;&lt;cut&gt;&gt;", self.cut)
    text.bind("&lt;&lt;copy&gt;&gt;", self.copy)
    text.bind("&lt;&lt;paste&gt;&gt;", self.paste)
    text.bind("&lt;&lt;center-insert&gt;&gt;", self.center_insert_event)
    text.bind("&lt;&lt;help&gt;&gt;", self.help_dialog)
    text.bind("&lt;&lt;python-docs&gt;&gt;", self.python_docs)
    text.bind("&lt;&lt;about-idle&gt;&gt;", self.about_dialog)
    text.bind("&lt;&lt;open-config-dialog&gt;&gt;", self.config_dialog)
    text.bind("&lt;&lt;open-module&gt;&gt;", self.open_module)
    text.bind("&lt;&lt;do-nothing&gt;&gt;", lambda event: "break")
    text.bind("&lt;&lt;select-all&gt;&gt;", self.select_all)
    text.bind("&lt;&lt;remove-selection&gt;&gt;", self.remove_selection)
    text.bind("&lt;&lt;find&gt;&gt;", self.find_event)
    text.bind("&lt;&lt;find-again&gt;&gt;", self.find_again_event)
    text.bind("&lt;&lt;find-in-files&gt;&gt;", self.find_in_files_event)
    text.bind("&lt;&lt;find-selection&gt;&gt;", self.find_selection_event)
    text.bind("&lt;&lt;replace&gt;&gt;", self.replace_event)
    text.bind("&lt;&lt;goto-line&gt;&gt;", self.goto_line_event)
    text.bind("&lt;3&gt;", self.right_menu_event)
    text.bind("&lt;&lt;smart-backspace&gt;&gt;",self.smart_backspace_event)
    text.bind("&lt;&lt;newline-and-indent&gt;&gt;",self.newline_and_indent_event)
    text.bind("&lt;&lt;smart-indent&gt;&gt;",self.smart_indent_event)
    text.bind("&lt;&lt;indent-region&gt;&gt;",self.indent_region_event)
    text.bind("&lt;&lt;dedent-region&gt;&gt;",self.dedent_region_event)
    text.bind("&lt;&lt;comment-region&gt;&gt;",self.comment_region_event)
    text.bind("&lt;&lt;uncomment-region&gt;&gt;",self.uncomment_region_event)
    text.bind("&lt;&lt;tabify-region&gt;&gt;",self.tabify_region_event)
    text.bind("&lt;&lt;untabify-region&gt;&gt;",self.untabify_region_event)
    text.bind("&lt;&lt;toggle-tabs&gt;&gt;",self.toggle_tabs_event)
    text.bind("&lt;&lt;change-indentwidth&gt;&gt;",self.change_indentwidth_event)
    text.bind("&lt;Left&gt;", self.move_at_edge_if_selection(0))
    text.bind("&lt;Right&gt;", self.move_at_edge_if_selection(1))

    if flist:
        flist.inversedict[self] = key
        if key:
            flist.dict[key] = self
        text.bind("&lt;&lt;open-new-window&gt;&gt;", self.new_callback)
        text.bind("&lt;&lt;close-all-windows&gt;&gt;", self.flist.close_all_callback)
        text.bind("&lt;&lt;open-class-browser&gt;&gt;", self.open_class_browser)
        text.bind("&lt;&lt;open-path-browser&gt;&gt;", self.open_path_browser)

    self.set_status_bar()
    vbar['command'] = text.yview
    vbar.pack(side=RIGHT, fill=Y)
    text['yscrollcommand'] = vbar.set
    fontWeight='normal'
    if idleConf.GetOption('main','EditorWindow','font-bold',type='bool'):
        fontWeight='bold'
    text.config(font=(idleConf.GetOption('main','EditorWindow','font'),
            idleConf.GetOption('main','EditorWindow','font-size'),
            fontWeight))
    text_frame.pack(side=LEFT, fill=BOTH, expand=1)
    text.pack(side=TOP, fill=BOTH, expand=1)
    text.focus_set()

    self.per = per = self.Percolator(text)
    if self.ispythonsource(filename):
        self.color = color = self.ColorDelegator()
        per.insertfilter(color)
    else:
        self.color = None

    self.undo = undo = self.UndoDelegator()
    per.insertfilter(undo)
    text.undo_block_start = undo.undo_block_start
    text.undo_block_stop = undo.undo_block_stop
    undo.set_saved_change_hook(self.saved_change_hook)

    # IOBinding implements file I/O and printing functionality
    self.io = io = self.IOBinding(self)
    io.set_filename_change_hook(self.filename_change_hook)

    # Create the recent files submenu
    self.recent_files_menu = Menu(self.menubar)
    self.menudict['file'].insert_cascade(3, label='Recent Files',
                                         underline=0,
                                         menu=self.recent_files_menu)
    self.update_recent_files_list()

    if filename:
        if os.path.exists(filename) and not os.path.isdir(filename):
            io.loadfile(filename)
        else:
            io.set_filename(filename)
    self.saved_change_hook()

    self.load_extensions()

    menu = self.menudict.get('windows')
    if menu:
        end = menu.index("end")
        if end is None:
            end = -1
        if end &gt;= 0:
            menu.add_separator()
            end = end + 1
        self.wmenu_end = end
        WindowList.register_callback(self.postwindowsmenu)

    # Some abstractions so IDLE extensions are cross-IDE
    self.askyesno = tkMessageBox.askyesno
    self.askinteger = tkSimpleDialog.askinteger
    self.showerror = tkMessageBox.showerror

    if self.extensions.has_key('AutoIndent'):
        self.extensions['AutoIndent'].set_indentation_params(
            self.ispythonsource(filename))</t>
<t tx="ekr.20060521134315.45"></t>
<t tx="ekr.20060521134315.46">def new_callback(self, event):

    dirname, basename = self.io.defaultfilename()
    self.flist.new(dirname)
    return "break"</t>
<t tx="ekr.20060521134315.47">def set_status_bar(self):
    
    self.status_bar = self.MultiStatusBar(self.top)
    self.status_bar.set_label('column', 'Col: ?', side=RIGHT)
    self.status_bar.set_label('line', 'Ln: ?', side=RIGHT)
    self.status_bar.pack(side=BOTTOM, fill=X)
    self.text.bind('&lt;KeyRelease&gt;', self.set_line_and_column)
    self.text.bind('&lt;ButtonRelease&gt;', self.set_line_and_column)
    self.text.after_idle(self.set_line_and_column)

</t>
<t tx="ekr.20060521134315.48">def set_line_and_column(self, event=None):

    line, column = self.text.index(INSERT).split('.')
    self.status_bar.set_label('column', 'Col: %s' % column)
    self.status_bar.set_label('line', 'Ln: %s' % line)
</t>
<t tx="ekr.20060521134315.49">menu_specs = [
    ("file", "_File"),
    ("edit", "_Edit"),
    ("format", "F_ormat"),
    ("run", "_Run"),
    ("options", "_Options"),
    ("windows", "_Windows"),
    ("help", "_Help"),
]

def createmenubar(self):
    mbar = self.menubar
    self.menudict = menudict = {}
    for name, label in self.menu_specs:
        underline, label = prepstr(label)
        menudict[name] = menu = Menu(mbar, name=name)
        mbar.add_cascade(label=label, menu=menu, underline=underline)
    self.fill_menus()
    self.base_helpmenu_length = self.menudict['help'].index(END)
    self.reset_help_menu_entries()
</t>
<t tx="ekr.20060521134315.50">def postwindowsmenu(self):
    
    # Only called when Windows menu exists
    menu = self.menudict['windows']
    end = menu.index("end")
    if end is None:
        end = -1
    if end &gt; self.wmenu_end:
        menu.delete(self.wmenu_end+1, end)
    WindowList.add_windows_to_menu(menu)

</t>
<t tx="ekr.20060521134315.51">rmenu = None

def right_menu_event(self, event):
    self.text.tag_remove("sel", "1.0", "end")
    self.text.mark_set("insert", "@%d,%d" % (event.x, event.y))
    if not self.rmenu:
        self.make_rmenu()
    rmenu = self.rmenu
    self.event = event
    iswin = sys.platform[:3] == 'win'
    if iswin:
        self.text.config(cursor="arrow")
    rmenu.tk_popup(event.x_root, event.y_root)
    if iswin:
        self.text.config(cursor="ibeam")
</t>
<t tx="ekr.20060521134315.52">rmenu_specs = [
    # ("Label", "&lt;&lt;virtual-event&gt;&gt;"), ...
    ("Close", "&lt;&lt;close-window&gt;&gt;"), # Example
]

def make_rmenu(self):
    rmenu = Menu(self.text, tearoff=0)
    for label, eventname in self.rmenu_specs:
        def command(text=self.text, eventname=eventname):
            text.event_generate(eventname)
        rmenu.add_command(label=label, command=command)
    self.rmenu = rmenu
</t>
<t tx="ekr.20060521134315.53"></t>
<t tx="ekr.20060521134315.54">def about_dialog(self, event=None):
    aboutDialog.AboutDialog(self.top,'About IDLE')
</t>
<t tx="ekr.20060521134315.55">def config_dialog(self, event=None):
    configDialog.ConfigDialog(self.top,'Settings')
</t>
<t tx="ekr.20060521134315.56">def help_dialog(self, event=None):
    fn=os.path.join(os.path.abspath(os.path.dirname(__file__)),'help.txt')
    textView.TextViewer(self.top,'Help',fn)
</t>
<t tx="ekr.20060521134315.57">def python_docs(self, event=None):
    if sys.platform[:3] == 'win':
        os.startfile(self.help_url)
    else:
        webbrowser.open(self.help_url)
    return "break"
</t>
<t tx="ekr.20060521134315.58"></t>
<t tx="ekr.20060521134315.59">def cut(self,event):
    self.text.event_generate("&lt;&lt;Cut&gt;&gt;")
    return "break"
</t>
<t tx="ekr.20060521134315.60">def copy(self,event):
    self.text.event_generate("&lt;&lt;Copy&gt;&gt;")
    return "break"
</t>
<t tx="ekr.20060521134315.61">def paste(self,event):
    self.text.event_generate("&lt;&lt;Paste&gt;&gt;")
    return "break"
</t>
<t tx="ekr.20060521134315.62">def select_all(self, event=None):
    self.text.tag_add("sel", "1.0", "end-1c")
    self.text.mark_set("insert", "1.0")
    self.text.see("insert")
    return "break"
</t>
<t tx="ekr.20060521134315.63">def remove_selection(self, event=None):
    self.text.tag_remove("sel", "1.0", "end")
    self.text.see("insert")
</t>
<t tx="ekr.20060521134315.64">def move_at_edge_if_selection(self, edge_index):
    """Cursor move begins at start or end of selection

    When a left/right cursor key is pressed create and return to Tkinter a
    function which causes a cursor move from the associated edge of the
    selection.

    """
    self_text_index = self.text.index
    self_text_mark_set = self.text.mark_set
    edges_table = ("sel.first+1c", "sel.last-1c")
    def move_at_edge(event):
        if (event.state &amp; 5) == 0: # no shift(==1) or control(==4) pressed
            try:
                self_text_index("sel.first")
                self_text_mark_set("insert", edges_table[edge_index])
            except TclError:
                pass
    return move_at_edge
</t>
<t tx="ekr.20060521134315.65">def find_event(self, event):
    SearchDialog.find(self.text)
    return "break"
</t>
<t tx="ekr.20060521134315.66">def find_again_event(self, event):
    SearchDialog.find_again(self.text)
    return "break"
</t>
<t tx="ekr.20060521134315.67">def find_selection_event(self, event):
    SearchDialog.find_selection(self.text)
    return "break"
</t>
<t tx="ekr.20060521134315.68">def find_in_files_event(self, event):
    GrepDialog.grep(self.text, self.io, self.flist)
    return "break"
</t>
<t tx="ekr.20060521134315.69">def replace_event(self, event):
    ReplaceDialog.replace(self.text)
    return "break"
</t>
<t tx="ekr.20060521134315.70">def goto_line_event(self, event):
    text = self.text
    lineno = tkSimpleDialog.askinteger("Goto",
            "Go to line number:",parent=text)
    if lineno is None:
        return "break"
    if lineno &lt;= 0:
        text.bell()
        return "break"
    text.mark_set("insert", "%d.0" % lineno)
    text.see("insert")
</t>
<t tx="ekr.20060521134315.71">def open_module(self, event=None):
    # XXX Shouldn't this be in IOBinding or in FileList?
    try:
        name = self.text.get("sel.first", "sel.last")
    except TclError:
        name = ""
    else:
        name = name.strip()
    name = tkSimpleDialog.askstring("Module",
             "Enter the name of a Python module\n"
             "to search on sys.path and open:",
             parent=self.text, initialvalue=name)
    if name:
        name = name.strip()
    if not name:
        return
    # XXX Ought to insert current file's directory in front of path
    try:
        (f, file, (suffix, mode, type)) = _find_module(name)
    except (NameError, ImportError), msg:
        tkMessageBox.showerror("Import error", str(msg), parent=self.text)
        return
    if type != imp.PY_SOURCE:
        tkMessageBox.showerror("Unsupported type",
            "%s is not a source module" % name, parent=self.text)
        return
    if f:
        f.close()
    if self.flist:
        self.flist.open(file)
    else:
        self.io.loadfile(file)
</t>
<t tx="ekr.20060521134315.72">def open_class_browser(self, event=None):
    filename = self.io.filename
    if not filename:
        tkMessageBox.showerror(
            "No filename",
            "This buffer has no associated filename",
            master=self.text)
        self.text.focus_set()
        return None
    head, tail = os.path.split(filename)
    base, ext = os.path.splitext(tail)
    import ClassBrowser
    ClassBrowser.ClassBrowser(self.flist, base, [head])
</t>
<t tx="ekr.20060521134315.73">def open_path_browser(self, event=None):
    import PathBrowser
    PathBrowser.PathBrowser(self.flist)
</t>
<t tx="ekr.20060521134315.74">def gotoline(self, lineno):
    if lineno is not None and lineno &gt; 0:
        self.text.mark_set("insert", "%d.0" % lineno)
        self.text.tag_remove("sel", "1.0", "end")
        self.text.tag_add("sel", "insert", "insert +1l")
        self.center()
</t>
<t tx="ekr.20060521134315.75">def ispythonsource(self, filename):
    if not filename:
        return True
    base, ext = os.path.splitext(os.path.basename(filename))
    if os.path.normcase(ext) in (".py", ".pyw"):
        return True
    try:
        f = open(filename)
        line = f.readline()
        f.close()
    except IOError:
        return False
    return line.startswith('#!') and line.find('python') &gt;= 0
</t>
<t tx="ekr.20060521134315.76">def close_hook(self):
    if self.flist:
        self.flist.close_edit(self)
</t>
<t tx="ekr.20060521134315.77">def set_close_hook(self, close_hook):
    self.close_hook = close_hook
</t>
<t tx="ekr.20060521134315.78">def filename_change_hook(self):
    if self.flist:
        self.flist.filename_changed_edit(self)
    self.saved_change_hook()
    self.top.update_windowlist_registry(self)
    if self.ispythonsource(self.io.filename):
        self.addcolorizer()
    else:
        self.rmcolorizer()
</t>
<t tx="ekr.20060521134315.79"></t>
<t tx="ekr.20060521134315.80">def addcolorizer(self):
    if self.color:
        return
    self.per.removefilter(self.undo)
    self.color = self.ColorDelegator()
    self.per.insertfilter(self.color)
    self.per.insertfilter(self.undo)
</t>
<t tx="ekr.20060521134315.81">def rmcolorizer(self):
    if not self.color:
        return
    self.per.removefilter(self.undo)
    self.per.removefilter(self.color)
    self.color = None
    self.per.insertfilter(self.undo)
</t>
<t tx="ekr.20060521134315.82">def ResetColorizer(self):
    "Update the colour theme if it is changed"
    # Called from configDialog.py
    if self.color:
        self.color = self.ColorDelegator()
        self.per.insertfilter(self.color)
    theme = idleConf.GetOption('main','Theme','name')
    self.text.config(idleConf.GetHighlight(theme, "normal"))
</t>
<t tx="ekr.20060521134315.83"></t>
<t tx="ekr.20060521134315.84">def ResetFont(self):
    "Update the text widgets' font if it is changed"
    # Called from configDialog.py
    fontWeight='normal'
    if idleConf.GetOption('main','EditorWindow','font-bold',type='bool'):
        fontWeight='bold'
    self.text.config(font=(idleConf.GetOption('main','EditorWindow','font'),
            idleConf.GetOption('main','EditorWindow','font-size'),
            fontWeight))
</t>
<t tx="ekr.20060521134315.85">def ResetKeybindings(self):
    "Update the keybindings if they are changed"
    # Called from configDialog.py
    self.Bindings.default_keydefs=idleConf.GetCurrentKeySet()
    keydefs = self.Bindings.default_keydefs
    for event, keylist in keydefs.items():
        self.text.event_delete(event)
    self.apply_bindings()
    #update menu accelerators
    menuEventDict={}
    for menu in self.Bindings.menudefs:
        menuEventDict[menu[0]]={}
        for item in menu[1]:
            if item:
                menuEventDict[menu[0]][prepstr(item[0])[1]]=item[1]
    for menubarItem in self.menudict.keys():
        menu=self.menudict[menubarItem]
        end=menu.index(END)+1
        for index in range(0,end):
            if menu.type(index)=='command':
                accel=menu.entrycget(index,'accelerator')
                if accel:
                    itemName=menu.entrycget(index,'label')
                    event=''
                    if menuEventDict.has_key(menubarItem):
                        if menuEventDict[menubarItem].has_key(itemName):
                            event=menuEventDict[menubarItem][itemName]
                    if event:
                        accel=get_accelerator(keydefs, event)
                        menu.entryconfig(index,accelerator=accel)
</t>
<t tx="ekr.20060521134315.86">def reset_help_menu_entries(self):
    "Update the additional help entries on the Help menu"
    help_list = idleConf.GetAllExtraHelpSourcesList()
    helpmenu = self.menudict['help']
    # first delete the extra help entries, if any
    helpmenu_length = helpmenu.index(END)
    if helpmenu_length &gt; self.base_helpmenu_length:
        helpmenu.delete((self.base_helpmenu_length + 1), helpmenu_length)
    # then rebuild them
    if help_list:
        helpmenu.add_separator()
        for entry in help_list:
            cmd = self.__extra_help_callback(entry[1])
            helpmenu.add_command(label=entry[0], command=cmd)
    # and update the menu dictionary
    self.menudict['help'] = helpmenu
</t>
<t tx="ekr.20060521134315.87">def __extra_help_callback(self, helpfile):
    "Create a callback with the helpfile value frozen at definition time"
    def display_extra_help(helpfile=helpfile):
        if not (helpfile.startswith('www') or helpfile.startswith('http')):
            url = os.path.normpath(helpfile)
        if sys.platform[:3] == 'win':
            os.startfile(helpfile)
        else:
            webbrowser.open(helpfile)
    return display_extra_help
</t>
<t tx="ekr.20060521134315.88">def update_recent_files_list(self, new_file=None):
    "Load and update the recent files list and menus"
    rf_list = []
    if os.path.exists(self.recent_files_path):
        rf_list_file = open(self.recent_files_path,'r')
        try:
            rf_list = rf_list_file.readlines()
        finally:
            rf_list_file.close()
    if new_file:
        new_file = os.path.abspath(new_file) + '\n'
        if new_file in rf_list:
            rf_list.remove(new_file)  # move to top
        rf_list.insert(0, new_file)
    # clean and save the recent files list
    bad_paths = []
    for path in rf_list:
        if '\0' in path or not os.path.exists(path[0:-1]):
            bad_paths.append(path)
    rf_list = [path for path in rf_list if path not in bad_paths]
    ulchars = "1234567890ABCDEFGHIJK"
    rf_list = rf_list[0:len(ulchars)]
    rf_file = open(self.recent_files_path, 'w')
    try:
        rf_file.writelines(rf_list)
    finally:
        rf_file.close()
    # for each edit window instance, construct the recent files menu
    for instance in self.top.instance_dict.keys():
        menu = instance.recent_files_menu
        menu.delete(1, END)  # clear, and rebuild:
        for i, file in zip(count(), rf_list):
            file_name = file[0:-1]  # zap \n
            callback = instance.__recent_file_callback(file_name)
            menu.add_command(label=ulchars[i] + " " + file_name,
                             command=callback,
                             underline=0)
</t>
<t tx="ekr.20060521134315.89">def __recent_file_callback(self, file_name):
    def open_recent_file(fn_closure=file_name):
        self.io.open(editFile=fn_closure)
    return open_recent_file
</t>
<t tx="ekr.20060521134315.90">def saved_change_hook(self):
    short = self.short_title()
    long = self.long_title()
    if short and long:
        title = short + " - " + long
    elif short:
        title = short
    elif long:
        title = long
    else:
        title = "Untitled"
    icon = short or long or title
    if not self.get_saved():
        title = "*%s*" % title
        icon = "*%s" % icon
    self.top.wm_title(title)
    self.top.wm_iconname(icon)
</t>
<t tx="ekr.20060521134315.91"></t>
<t tx="ekr.20060521134315.92">def get_saved(self):
    return self.undo.get_saved()
</t>
<t tx="ekr.20060521134315.93">def set_saved(self, flag):
    self.undo.set_saved(flag)
</t>
<t tx="ekr.20060521134315.94">def reset_undo(self):
    self.undo.reset_undo()
</t>
<t tx="ekr.20060521134315.95"></t>
<t tx="ekr.20060521134315.96">def short_title(self):
    filename = self.io.filename
    if filename:
        filename = os.path.basename(filename)
    return filename
</t>
<t tx="ekr.20060521134315.97">def long_title(self):
    return self.io.filename or ""
</t>
<t tx="ekr.20060521134315.98">def center_insert_event(self, event):
    self.center()
</t>
<t tx="ekr.20060521134315.99">def center(self, mark="insert"):
    text = self.text
    top, bot = self.getwindowlines()
    lineno = self.getlineno(mark)
    height = bot - top
    newtop = max(1, lineno - height//2)
    text.yview(float(newtop))
</t>
<t tx="ekr.20060521134315.100">def getwindowlines(self):
    text = self.text
    top = self.getlineno("@0,0")
    bot = self.getlineno("@0,65535")
    if top == bot and text.winfo_height() == 1:
        # Geometry manager hasn't run yet
        height = int(text['height'])
        bot = top + height - 1
    return top, bot
</t>
<t tx="ekr.20060521134315.101">def getlineno(self, mark="insert"):
    text = self.text
    return int(float(text.index(mark)))
</t>
<t tx="ekr.20060521134315.102">def get_geometry(self):
    "Return (width, height, x, y)"
    geom = self.top.wm_geometry()
    m = re.match(r"(\d+)x(\d+)\+(-?\d+)\+(-?\d+)", geom)
    tuple = (map(int, m.groups()))
    return tuple
</t>
<t tx="ekr.20060521134315.103"></t>
<t tx="ekr.20060521134315.104">def close_event(self, event):
    self.close()
</t>
<t tx="ekr.20060521134315.105">def maybesave(self):
    if self.io:
        if not self.get_saved():
            if self.top.state()!='normal':
                self.top.deiconify()
            self.top.lower()
            self.top.lift()
        return self.io.maybesave()
</t>
<t tx="ekr.20060521134315.106">def close(self):
    reply = self.maybesave()
    if reply != "cancel":
        self._close()
    return reply
</t>
<t tx="ekr.20060521134315.107">def _close(self):
    if self.io.filename:
        self.update_recent_files_list(new_file=self.io.filename)
    WindowList.unregister_callback(self.postwindowsmenu)
    if self.close_hook:
        self.close_hook()
    self.flist = None
    colorizing = 0
    self.unload_extensions()
    self.io.close(); self.io = None
    self.undo = None # XXX
    if self.color:
        colorizing = self.color.colorizing
        doh = colorizing and self.top
        self.color.close(doh) # Cancel colorization
    self.text = None
    self.tkinter_vars = None
    self.per.close(); self.per = None
    if not colorizing:
        self.top.destroy()
</t>
<t tx="ekr.20060521134315.108"></t>
<t tx="ekr.20060521134315.109">def load_extensions(self):
    self.extensions = {}
    self.load_standard_extensions()
</t>
<t tx="ekr.20060521134315.110">def unload_extensions(self):
    for ins in self.extensions.values():
        if hasattr(ins, "close"):
            ins.close()
    self.extensions = {}
</t>
<t tx="ekr.20060521134315.111">def load_standard_extensions(self):
    for name in self.get_standard_extension_names():
        try:
            self.load_extension(name)
        except:
            print "Failed to load extension", repr(name)
            import traceback
            traceback.print_exc()
</t>
<t tx="ekr.20060521134315.112">def get_standard_extension_names(self):
    return idleConf.GetExtensions(editor_only=True)
</t>
<t tx="ekr.20060521134315.113">def load_extension(self, name):
    mod = __import__(name, globals(), locals(), [])
    cls = getattr(mod, name)
    keydefs = idleConf.GetExtensionBindings(name)
    if hasattr(cls, "menudefs"):
        self.fill_menus(cls.menudefs, keydefs)
    ins = cls(self)
    self.extensions[name] = ins
    if keydefs:
        self.apply_bindings(keydefs)
        for vevent in keydefs.keys():
            methodname = vevent.replace("-", "_")
            while methodname[:1] == '&lt;':
                methodname = methodname[1:]
            while methodname[-1:] == '&gt;':
                methodname = methodname[:-1]
            methodname = methodname + "_event"
            if hasattr(ins, methodname):
                self.text.bind(vevent, getattr(ins, methodname))
    return ins
</t>
<t tx="ekr.20060521134315.114"></t>
<t tx="ekr.20060521134315.115">def apply_bindings(self, keydefs=None):
    if keydefs is None:
        keydefs = self.Bindings.default_keydefs
    text = self.text
    text.keydefs = keydefs
    for event, keylist in keydefs.items():
        if keylist:
            text.event_add(event, *keylist)
</t>
<t tx="ekr.20060521134315.116">def fill_menus(self, menudefs=None, keydefs=None):
    """Add appropriate entries to the menus and submenus

    Menus that are absent or None in self.menudict are ignored.
    """
    if menudefs is None:
        menudefs = self.Bindings.menudefs
    if keydefs is None:
        keydefs = self.Bindings.default_keydefs
    menudict = self.menudict
    text = self.text
    for mname, entrylist in menudefs:
        menu = menudict.get(mname)
        if not menu:
            continue
        for entry in entrylist:
            if not entry:
                menu.add_separator()
            else:
                label, eventname = entry
                checkbutton = (label[:1] == '!')
                if checkbutton:
                    label = label[1:]
                underline, label = prepstr(label)
                accelerator = get_accelerator(keydefs, eventname)
                def command(text=text, eventname=eventname):
                    text.event_generate(eventname)
                if checkbutton:
                    var = self.get_var_obj(eventname, BooleanVar)
                    menu.add_checkbutton(label=label, underline=underline,
                        command=command, accelerator=accelerator,
                        variable=var)
                else:
                    menu.add_command(label=label, underline=underline,
                        command=command,accelerator=accelerator)</t>
<t tx="ekr.20060521134315.117">def getvar(self, name):
    var = self.get_var_obj(name)
    if var:
        value = var.get()
        return value
    else:
        raise NameError, name
</t>
<t tx="ekr.20060521134315.118">def setvar(self, name, value, vartype=None):
    var = self.get_var_obj(name, vartype)
    if var:
        var.set(value)
    else:
        raise NameError, name
</t>
<t tx="ekr.20060521134315.119">def get_var_obj(self, name, vartype=None):
    var = self.tkinter_vars.get(name)
    if not var and vartype:
        # create a Tkinter variable object with self.text as master:
        self.tkinter_vars[name] = var = vartype(self.text)
    return var
</t>
<t tx="ekr.20060521134315.120"># Tk implementations of "virtual text methods" -- each platform
# reusing IDLE's support code needs to define these for its GUI's
# flavor of widget.

# Is character at text_index in a Python string?  Return 0 for
# "guaranteed no", true for anything else.  This info is expensive
# to compute ab initio, but is probably already known by the
# platform's colorizer.

def is_char_in_string(self, text_index):
    if self.color:
        # Return true iff colorizer hasn't (re)gotten this far
        # yet, or the character is tagged as being in a string
        return self.text.tag_prevrange("TODO", text_index) or \
               "STRING" in self.text.tag_names(text_index)
    else:
        # The colorizer is missing: assume the worst
        return 1
</t>
<t tx="ekr.20060521134315.121"># If a selection is defined in the text widget, return (start,
# end) as Tkinter text indices, otherwise return (None, None)
def get_selection_indices(self):
    try:
        first = self.text.index("sel.first")
        last = self.text.index("sel.last")
        return first, last
    except TclError:
        return None, None
</t>
<t tx="ekr.20060521134315.122"># Return the text widget's current view of what a tab stop means
# (equivalent width in spaces).

def get_tabwidth(self):
    current = self.text['tabs'] or TK_TABWIDTH_DEFAULT
    return int(current)
</t>
<t tx="ekr.20060521134315.123"># Set the text widget's current view of what a tab stop means.

def set_tabwidth(self, newtabwidth):
    text = self.text
    if self.get_tabwidth() != newtabwidth:
        pixels = text.tk.call("font", "measure", text["font"],
                              "-displayof", text.master,
                              "n" * newtabwidth)
        text.configure(tabs=pixels)
</t>
<t tx="ekr.20060521134315.124">### begin autoindent code ###

# usetabs true  -&gt; literal tab characters are used by indent and
#                  dedent cmds, possibly mixed with spaces if
#                  indentwidth is not a multiple of tabwidth
#         false -&gt; tab characters are converted to spaces by indent
#                  and dedent cmds, and ditto TAB keystrokes
# indentwidth is the number of characters per logical indent level.
# tabwidth is the display width of a literal tab character.
# CAUTION:  telling Tk to use anything other than its default
# tab setting causes it to use an entirely different tabbing algorithm,
# treating tab stops as fixed distances from the left margin.
# Nobody expects this, so for now tabwidth should never be changed.
usetabs = 0
indentwidth = 4
tabwidth = 8    # for IDLE use, must remain 8 until Tk is fixed

# If context_use_ps1 is true, parsing searches back for a ps1 line;
# else searches for a popular (if, def, ...) Python stmt.
context_use_ps1 = 0

# When searching backwards for a reliable place to begin parsing,
# first start num_context_lines[0] lines back, then
# num_context_lines[1] lines back if that didn't work, and so on.
# The last value should be huge (larger than the # of lines in a
# conceivable file).
# Making the initial values larger slows things down more often.
num_context_lines = 50, 500, 5000000

def config(self, **options):
    for key, value in options.items():
        if key == 'usetabs':
            self.usetabs = value
        elif key == 'indentwidth':
            self.indentwidth = value
        elif key == 'tabwidth':
            self.tabwidth = value
        elif key == 'context_use_ps1':
            self.context_use_ps1 = value
        else:
            raise KeyError, "bad option name: %r" % (key,)</t>
<t tx="ekr.20060521134315.125"></t>
<t tx="ekr.20060521134315.126"># If ispythonsource and guess are true, guess a good value for
# indentwidth based on file content (if possible), and if
# indentwidth != tabwidth set usetabs false.
# In any case, adjust the Text widget's view of what a tab
# character means.

def set_indentation_params(self, ispythonsource, guess=1):
    if guess and ispythonsource:
        i = self.guess_indent()
        if 2 &lt;= i &lt;= 8:
            self.indentwidth = i
        if self.indentwidth != self.tabwidth:
            self.usetabs = 0

    self.set_tabwidth(self.tabwidth)
</t>
<t tx="ekr.20060521134315.127">def smart_backspace_event(self, event):
    text = self.text
    first, last = self.get_selection_indices()
    if first and last:
        text.delete(first, last)
        text.mark_set("insert", first)
        return "break"
    # Delete whitespace left, until hitting a real char or closest
    # preceding virtual tab stop.
    chars = text.get("insert linestart", "insert")
    if chars == '':
        if text.compare("insert", "&gt;", "1.0"):
            # easy: delete preceding newline
            text.delete("insert-1c")
        else:
            text.bell()     # at start of buffer
        return "break"
    if  chars[-1] not in " \t":
        # easy: delete preceding real char
        text.delete("insert-1c")
        return "break"
    # Ick.  It may require *inserting* spaces if we back up over a
    # tab character!  This is written to be clear, not fast.
    tabwidth = self.tabwidth
    have = len(chars.expandtabs(tabwidth))
    assert have &gt; 0
    want = ((have - 1) // self.indentwidth) * self.indentwidth
    # Debug prompt is multilined....
    last_line_of_prompt = sys.ps1.split('\n')[-1]
    ncharsdeleted = 0
    while 1:
        if chars == last_line_of_prompt:
            break
        chars = chars[:-1]
        ncharsdeleted = ncharsdeleted + 1
        have = len(chars.expandtabs(tabwidth))
        if have &lt;= want or chars[-1] not in " \t":
            break
    text.undo_block_start()
    text.delete("insert-%dc" % ncharsdeleted, "insert")
    if have &lt; want:
        text.insert("insert", ' ' * (want - have))
    text.undo_block_stop()
    return "break"
</t>
<t tx="ekr.20060521134315.128">def smart_indent_event(self, event):
    # if intraline selection:
    #     delete it
    # elif multiline selection:
    #     do indent-region &amp; return
    # indent one level
    text = self.text
    first, last = self.get_selection_indices()
    text.undo_block_start()
    try:
        if first and last:
            if index2line(first) != index2line(last):
                return self.indent_region_event(event)
            text.delete(first, last)
            text.mark_set("insert", first)
        prefix = text.get("insert linestart", "insert")
        raw, effective = classifyws(prefix, self.tabwidth)
        if raw == len(prefix):
            # only whitespace to the left
            self.reindent_to(effective + self.indentwidth)
        else:
            if self.usetabs:
                pad = '\t'
            else:
                effective = len(prefix.expandtabs(self.tabwidth))
                n = self.indentwidth
                pad = ' ' * (n - effective % n)
            text.insert("insert", pad)
        text.see("insert")
        return "break"
    finally:
        text.undo_block_stop()
</t>
<t tx="ekr.20060521134315.129">def newline_and_indent_event(self, event):
    text = self.text
    first, last = self.get_selection_indices()
    text.undo_block_start()
    try:
        if first and last:
            text.delete(first, last)
            text.mark_set("insert", first)
        line = text.get("insert linestart", "insert")
        i, n = 0, len(line)
        while i &lt; n and line[i] in " \t":
            i = i+1
        if i == n:
            # the cursor is in or at leading indentation in a continuation
            # line; just inject an empty line at the start
            text.insert("insert linestart", '\n')
            return "break"
        indent = line[:i]
        # strip whitespace before insert point unless it's in the prompt
        i = 0
        last_line_of_prompt = sys.ps1.split('\n')[-1]
        while line and line[-1] in " \t" and line != last_line_of_prompt:
            line = line[:-1]
            i = i+1
        if i:
            text.delete("insert - %d chars" % i, "insert")
        # strip whitespace after insert point
        while text.get("insert") in " \t":
            text.delete("insert")
        # start new line
        text.insert("insert", '\n')

        # adjust indentation for continuations and block
        # open/close first need to find the last stmt
        lno = index2line(text.index('insert'))
        y = PyParse.Parser(self.indentwidth, self.tabwidth)
        for context in self.num_context_lines:
            startat = max(lno - context, 1)
            startatindex = repr(startat) + ".0"
            rawtext = text.get(startatindex, "insert")
            y.set_str(rawtext)
            bod = y.find_good_parse_start(
                      self.context_use_ps1,
                      self._build_char_in_string_func(startatindex))
            if bod is not None or startat == 1:
                break
        y.set_lo(bod or 0)
        c = y.get_continuation_type()
        if c != PyParse.C_NONE:
            # The current stmt hasn't ended yet.
            if c == PyParse.C_STRING:
                # inside a string; just mimic the current indent
                text.insert("insert", indent)
            elif c == PyParse.C_BRACKET:
                # line up with the first (if any) element of the
                # last open bracket structure; else indent one
                # level beyond the indent of the line with the
                # last open bracket
                self.reindent_to(y.compute_bracket_indent())
            elif c == PyParse.C_BACKSLASH:
                # if more than one line in this stmt already, just
                # mimic the current indent; else if initial line
                # has a start on an assignment stmt, indent to
                # beyond leftmost =; else to beyond first chunk of
                # non-whitespace on initial line
                if y.get_num_lines_in_stmt() &gt; 1:
                    text.insert("insert", indent)
                else:
                    self.reindent_to(y.compute_backslash_indent())
            else:
                assert 0, "bogus continuation type %r" % (c,)
            return "break"

        # This line starts a brand new stmt; indent relative to
        # indentation of initial line of closest preceding
        # interesting stmt.
        indent = y.get_base_indent_string()
        text.insert("insert", indent)
        if y.is_block_opener():
            self.smart_indent_event(event)
        elif indent and y.is_block_closer():
            self.smart_backspace_event(event)
        return "break"
    finally:
        text.see("insert")
        text.undo_block_stop()
</t>
<t tx="ekr.20060521134315.130"># Our editwin provides a is_char_in_string function that works
# with a Tk text index, but PyParse only knows about offsets into
# a string. This builds a function for PyParse that accepts an
# offset.

def _build_char_in_string_func(self, startindex):
    def inner(offset, _startindex=startindex,
              _icis=self.is_char_in_string):
        return _icis(_startindex + "+%dc" % offset)
    return inner
</t>
<t tx="ekr.20060521134315.131">def indent_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    for pos in range(len(lines)):
        line = lines[pos]
        if line:
            raw, effective = classifyws(line, self.tabwidth)
            effective = effective + self.indentwidth
            lines[pos] = self._make_blanks(effective) + line[raw:]
    self.set_region(head, tail, chars, lines)
    return "break"
</t>
<t tx="ekr.20060521134315.132">def dedent_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    for pos in range(len(lines)):
        line = lines[pos]
        if line:
            raw, effective = classifyws(line, self.tabwidth)
            effective = max(effective - self.indentwidth, 0)
            lines[pos] = self._make_blanks(effective) + line[raw:]
    self.set_region(head, tail, chars, lines)
    return "break"
</t>
<t tx="ekr.20060521134315.133"></t>
<t tx="ekr.20060521134315.134">def comment_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    for pos in range(len(lines) - 1):
        line = lines[pos]
        lines[pos] = '##' + line
    self.set_region(head, tail, chars, lines)
</t>
<t tx="ekr.20060521134315.135">def uncomment_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    for pos in range(len(lines)):
        line = lines[pos]
        if not line:
            continue
        if line[:2] == '##':
            line = line[2:]
        elif line[:1] == '#':
            line = line[1:]
        lines[pos] = line
    self.set_region(head, tail, chars, lines)
</t>
<t tx="ekr.20060521134315.136"></t>
<t tx="ekr.20060521134315.137">def tabify_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    tabwidth = self._asktabwidth()
    for pos in range(len(lines)):
        line = lines[pos]
        if line:
            raw, effective = classifyws(line, tabwidth)
            ntabs, nspaces = divmod(effective, tabwidth)
            lines[pos] = '\t' * ntabs + ' ' * nspaces + line[raw:]
    self.set_region(head, tail, chars, lines)
</t>
<t tx="ekr.20060521134315.138">def untabify_region_event(self, event):
    head, tail, chars, lines = self.get_region()
    tabwidth = self._asktabwidth()
    for pos in range(len(lines)):
        lines[pos] = lines[pos].expandtabs(tabwidth)
    self.set_region(head, tail, chars, lines)
</t>
<t tx="ekr.20060521134315.139">def toggle_tabs_event(self, event):
    if self.askyesno(
          "Toggle tabs",
          "Turn tabs " + ("on", "off")[self.usetabs] + "?",
          parent=self.text):
        self.usetabs = not self.usetabs
    return "break"
</t>
<t tx="ekr.20060521134315.140"># XXX this isn't bound to anything -- see class tabwidth comments
def change_tabwidth_event(self, event):
    new = self._asktabwidth()
    if new != self.tabwidth:
        self.tabwidth = new
        self.set_indentation_params(0, guess=0)
    return "break"
</t>
<t tx="ekr.20060521134315.141">def change_indentwidth_event(self, event):
    new = self.askinteger(
              "Indent width",
              "New indent width (2-16)",
              parent=self.text,
              initialvalue=self.indentwidth,
              minvalue=2,
              maxvalue=16)
    if new and new != self.indentwidth:
        self.indentwidth = new
    return "break"
</t>
<t tx="ekr.20060521134315.142"></t>
<t tx="ekr.20060521134315.143">def get_region(self):
    text = self.text
    first, last = self.get_selection_indices()
    if first and last:
        head = text.index(first + " linestart")
        tail = text.index(last + "-1c lineend +1c")
    else:
        head = text.index("insert linestart")
        tail = text.index("insert lineend +1c")
    chars = text.get(head, tail)
    lines = chars.split("\n")
    return head, tail, chars, lines
</t>
<t tx="ekr.20060521134315.144">def set_region(self, head, tail, chars, lines):
    text = self.text
    newchars = "\n".join(lines)
    if newchars == chars:
        text.bell()
        return
    text.tag_remove("sel", "1.0", "end")
    text.mark_set("insert", head)
    text.undo_block_start()
    text.delete(head, tail)
    text.insert(head, newchars)
    text.undo_block_stop()
    text.tag_add("sel", head, "insert")
</t>
<t tx="ekr.20060521134315.145"># Make string that displays as n leading blanks.

def _make_blanks(self, n):
    if self.usetabs:
        ntabs, nspaces = divmod(n, self.tabwidth)
        return '\t' * ntabs + ' ' * nspaces
    else:
        return ' ' * n
</t>
<t tx="ekr.20060521134315.146"># Delete from beginning of line to insert point, then reinsert
# column logical (meaning use tabs if appropriate) spaces.

def reindent_to(self, column):
    text = self.text
    text.undo_block_start()
    if text.compare("insert linestart", "!=", "insert"):
        text.delete("insert linestart", "insert")
    if column:
        text.insert("insert", self._make_blanks(column))
    text.undo_block_stop()
</t>
<t tx="ekr.20060521134315.147">def _asktabwidth(self):
    return self.askinteger(
        "Tab width",
        "Spaces per tab? (2-16)",
        parent=self.text,
        initialvalue=self.indentwidth,
        minvalue=2,
        maxvalue=16) or self.tabwidth
</t>
<t tx="ekr.20060521134315.148"># Guess indentwidth from text content.
# Return guessed indentwidth.  This should not be believed unless
# it's in a reasonable range (e.g., it will be 0 if no indented
# blocks are found).

def guess_indent(self):
    opener, indented = IndentSearcher(self.text, self.tabwidth).run()
    if opener and indented:
        raw, indentsmall = classifyws(opener, self.tabwidth)
        raw, indentlarge = classifyws(indented, self.tabwidth)
    else:
        indentsmall = indentlarge = 0
    return indentlarge - indentsmall
</t>
<t tx="ekr.20060521134315.149">class FileList:

    from EditorWindow import EditorWindow  # class variable, may be overridden
                                           # e.g. by PyShellFileList

    def __init__(self, root):
        print 'EKR: FileList.__init__ root',root
        self.root = root
        self.dict = {}
        self.inversedict = {}
        self.vars = {} # For EditorWindow.getrawvar (shared Tcl variables)

    def open(self, filename, action=None):
        assert filename
        filename = self.canonize(filename)
        if os.path.isdir(filename):
            # This can happen when bad filename is passed on command line:
            tkMessageBox.showerror(
                "File Error",
                "%r is a directory." % (filename,),
                master=self.root)
            return None
        key = os.path.normcase(filename)
        if self.dict.has_key(key):
            edit = self.dict[key]
            edit.top.wakeup()
            return edit
        if action:
            # Don't create window, perform 'action', e.g. open in same window
            return action(filename)
        else:
            return self.EditorWindow(self, filename, key)

    def gotofileline(self, filename, lineno=None):
        edit = self.open(filename)
        if edit is not None and lineno is not None:
            edit.gotoline(lineno)

    def new(self, filename=None):
        return self.EditorWindow(self, filename)

    def close_all_callback(self, event):
        for edit in self.inversedict.keys():
            reply = edit.close()
            if reply == "cancel":
                break
        return "break"

    def close_edit(self, edit):
        try:
            key = self.inversedict[edit]
        except KeyError:
            print "Don't know this EditorWindow object.  (close)"
            return
        if key:
            del self.dict[key]
        del self.inversedict[edit]
        if not self.inversedict:
            self.root.quit()

    def filename_changed_edit(self, edit):
        edit.saved_change_hook()
        try:
            key = self.inversedict[edit]
        except KeyError:
            print "Don't know this EditorWindow object.  (rename)"
            return
        filename = edit.io.filename
        if not filename:
            if key:
                del self.dict[key]
            self.inversedict[edit] = None
            return
        filename = self.canonize(filename)
        newkey = os.path.normcase(filename)
        if newkey == key:
            return
        if self.dict.has_key(newkey):
            conflict = self.dict[newkey]
            self.inversedict[conflict] = None
            tkMessageBox.showerror(
                "Name Conflict",
                "You now have multiple edit windows open for %r" % (filename,),
                master=self.root)
        self.dict[newkey] = edit
        self.inversedict[edit] = newkey
        if key:
            try:
                del self.dict[key]
            except KeyError:
                pass

    def canonize(self, filename):
        if not os.path.isabs(filename):
            try:
                pwd = os.getcwd()
            except os.error:
                pass
            else:
                filename = os.path.join(pwd, filename)
        return os.path.normpath(filename)</t>
<t tx="ekr.20060521134315.150">class PyShellFileList(FileList):
    "Extend base class: IDLE supports a shell and breakpoints"

    # override FileList's class variable, instances return PyShellEditorWindow
    # instead of EditorWindow when new edit windows are created.
    EditorWindow = PyShellEditorWindow

    pyshell = None

    def open_shell(self, event=None):
        if self.pyshell:
            self.pyshell.top.wakeup()
        else:
            self.pyshell = PyShell(self)
            if self.pyshell:
                if not self.pyshell.begin():
                    return None
        return self.pyshell</t>
<t tx="ekr.20060521134315.151">@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

# The default tab setting for a Text widget, in average-width characters.
TK_TABWIDTH_DEFAULT = 8

@others

if __name__ == '__main__':
    test()
</t>
<t tx="ekr.20060521134315.152">import sys
import os
import re
import imp
from itertools import count
from Tkinter import *
import tkSimpleDialog
import tkMessageBox

import webbrowser
import idlever
import WindowList
import SearchDialog
import GrepDialog
import ReplaceDialog
import PyParse
from configHandler import idleConf
import aboutDialog, textView, configDialog



</t>
<t tx="ekr.20060521134315.153"></t>
<t tx="ekr.20060521134315.154">def _find_module(fullname, path=None):
    """Version of imp.find_module() that handles hierarchical module names"""

    file = None
    for tgt in fullname.split('.'):
        if file is not None:
            file.close()            # close intermediate files
        (file, filename, descr) = imp.find_module(tgt, path)
        if descr[2] == imp.PY_SOURCE:
            break                   # find but not load the source file
        module = imp.load_module(tgt, file, filename, descr)
        try:
            path = module.__path__
        except AttributeError:
            raise ImportError, 'No source for module ' + module.__name__
    return file, filename, descr
</t>
<t tx="ekr.20060521134315.155"># "line.col" -&gt; line, as an int
def index2line(index):
    return int(float(index))</t>
<t tx="ekr.20060521134315.156"># Look at the leading whitespace in s.
# Return pair (# of leading ws characters,
#              effective # of leading blanks after expanding
#              tabs to width tabwidth)

def classifyws(s, tabwidth):
    raw = effective = 0
    for ch in s:
        if ch == ' ':
            raw = raw + 1
            effective = effective + 1
        elif ch == '\t':
            raw = raw + 1
            effective = (effective // tabwidth + 1) * tabwidth
        else:
            break
    return raw, effective
</t>
<t tx="ekr.20060521134315.157">
import tokenize
_tokenize = tokenize
del tokenize

class IndentSearcher:
	&lt;&lt; class IndentSearcher declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.158">    # .run() chews over the Text widget, looking for a block opener
    # and the stmt following it.  Returns a pair,
    #     (line containing block opener, line containing stmt)
    # Either or both may be None.

</t>
<t tx="ekr.20060521134315.159">def __init__(self, text, tabwidth):
    self.text = text
    self.tabwidth = tabwidth
    self.i = self.finished = 0
    self.blkopenline = self.indentedline = None
</t>
<t tx="ekr.20060521134315.160">def readline(self):
    if self.finished:
        return ""
    i = self.i = self.i + 1
    mark = repr(i) + ".0"
    if self.text.compare(mark, "&gt;=", "end"):
        return ""
    return self.text.get(mark, mark + " lineend+1c")
</t>
<t tx="ekr.20060521134315.161">def tokeneater(self, type, token, start, end, line,
               INDENT=_tokenize.INDENT,
               NAME=_tokenize.NAME,
               OPENERS=('class', 'def', 'for', 'if', 'try', 'while')):
    if self.finished:
        pass
    elif type == NAME and token in OPENERS:
        self.blkopenline = line
    elif type == INDENT and self.blkopenline:
        self.indentedline = line
        self.finished = 1
</t>
<t tx="ekr.20060521134315.162">def run(self):
    save_tabsize = _tokenize.tabsize
    _tokenize.tabsize = self.tabwidth
    try:
        try:
            _tokenize.tokenize(self.readline, self.tokeneater)
        except _tokenize.TokenError:
            # since we cut off the tokenizer early, we can trigger
            # spurious errors
            pass
    finally:
        _tokenize.tabsize = save_tabsize
    return self.blkopenline, self.indentedline</t>
<t tx="ekr.20060521134315.163">def prepstr(s):
    # Helper to extract the underscore from a string, e.g.
    # prepstr("Co_py") returns (2, "Copy").
    i = s.find('_')
    if i &gt;= 0:
        s = s[:i] + s[i+1:]
    return i, s
</t>
<t tx="ekr.20060521134315.164">keynames = {
 'bracketleft': '[',
 'bracketright': ']',
 'slash': '/',
}

def get_accelerator(keydefs, eventname):
    keylist = keydefs.get(eventname)
    if not keylist:
        return ""
    s = keylist[0]
    s = re.sub(r"-[a-z]\b", lambda m: m.group().upper(), s)
    s = re.sub(r"\b\w+\b", lambda m: keynames.get(m.group(), m.group()), s)
    s = re.sub("Key-", "", s)
    s = re.sub("Cancel","Ctrl-Break",s)   # dscherer@cmu.edu
    s = re.sub("Control-", "Ctrl-", s)
    s = re.sub("-", "+", s)
    s = re.sub("&gt;&lt;", " ", s)
    s = re.sub("&lt;", "", s)
    s = re.sub("&gt;", "", s)
    return s</t>
<t tx="ekr.20060521134315.165">def fixwordbreaks(root):
    
    # Make sure that Tk's double-click and next/previous word
    # operations use our definition of a word (i.e. an identifier)
    tk = root.tk
    tk.call('tcl_wordBreakAfter', 'a b', 0) # make sure word.tcl is loaded
    tk.call('set', 'tcl_wordchars', '[a-zA-Z0-9_]')
    tk.call('set', 'tcl_nonwordchars', '[^a-zA-Z0-9_]')

</t>
<t tx="ekr.20060521134315.166">def test():
    root = Tk()
    fixwordbreaks(root)
    root.withdraw()
    if sys.argv[1:]:
        filename = sys.argv[1]
    else:
        filename = None
    edit = EditorWindow(root=root, filename=filename)
    edit.set_close_hook(root.quit)
    root.mainloop()
    root.destroy()
</t>
<t tx="ekr.20060521134315.167">@tabwidth -4
@language python
&lt;&lt; PyShell declarations &gt;&gt;
@others

if __name__ == "__main__":
    sys.modules['PyShell'] = sys.modules['__main__']
    main()
</t>
<t tx="ekr.20060521134315.168">#! /usr/bin/env python

import os
import os.path
import sys
import string
import getopt
import re
import socket
import time
import threading
import traceback
import types
import exceptions

import linecache
from code import InteractiveInterpreter

try:
    from Tkinter import *
except ImportError:
    print&gt;&gt;sys.__stderr__, "** IDLE can't import Tkinter.  " \
                           "Your Python may not be configured for Tk. **"
    sys.exit(1)
import tkMessageBox

from EditorWindow import EditorWindow, fixwordbreaks
from FileList import FileList
from ColorDelegator import ColorDelegator
from UndoDelegator import UndoDelegator
from OutputWindow import OutputWindow
from configHandler import idleConf
import idlever

import rpc
import Debugger
import RemoteDebugger

IDENTCHARS = string.ascii_letters + string.digits + "_"
LOCALHOST = '127.0.0.1'

try:
    from signal import SIGTERM
except ImportError:
    SIGTERM = 15

# Override warnings module to write to warning_stream.  Initialize to send IDLE
# internal warnings to the console.  ScriptBinding.check_syntax() will
# temporarily redirect the stream to the shell window to display warnings when
# checking user's code.
global warning_stream
warning_stream = sys.__stderr__
try:
    import warnings
except ImportError:
    pass
else:
</t>
<t tx="ekr.20060521134315.169">def idle_showwarning(message, category, filename, lineno):
    file = warning_stream
    try:
        file.write(warnings.formatwarning(message, category, filename, lineno))
    except IOError:
        pass  ## file (probably __stderr__) is invalid, warning dropped.
</t>
<t tx="ekr.20060521134315.170">warnings.showwarning = idle_showwarning
def idle_formatwarning(message, category, filename, lineno):
    """Format warnings the IDLE way"""
    s = "\nWarning (from warnings module):\n"
    s += '  File \"%s\", line %s\n' % (filename, lineno)
    line = linecache.getline(filename, lineno).strip()
    if line:
        s += "    %s\n" % line
    s += "%s: %s\n&gt;&gt;&gt; " % (category.__name__, message)
    return s
</t>
<t tx="ekr.20060521134315.171">warnings.formatwarning = idle_formatwarning

def extended_linecache_checkcache(filename=None,
                              orig_checkcache=linecache.checkcache):
</t>
<t tx="ekr.20060521134315.172">

class PyShellFileList(FileList):
	&lt;&lt; class PyShellFileList declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.173">"Extend base class: IDLE supports a shell and breakpoints"

# override FileList's class variable, instances return PyShellEditorWindow
# instead of EditorWindow when new edit windows are created.
EditorWindow = PyShellEditorWindow

pyshell = None

</t>
<t tx="ekr.20060521134315.174">def open_shell(self, event=None):
    if self.pyshell:
        self.pyshell.top.wakeup()
    else:
        self.pyshell = PyShell(self)
        if self.pyshell:
            if not self.pyshell.begin():
                return None
    return self.pyshell
</t>
<t tx="ekr.20060521134315.175">

class ModifiedColorDelegator(ColorDelegator):
	&lt;&lt; class ModifiedColorDelegator declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.176">"Extend base class: colorizer for the shell window itself"

</t>
<t tx="ekr.20060521134315.177">def __init__(self):
    ColorDelegator.__init__(self)
    self.LoadTagDefs()
</t>
<t tx="ekr.20060521134315.178">def recolorize_main(self):
    self.tag_remove("TODO", "1.0", "iomark")
    self.tag_add("SYNC", "1.0", "iomark")
    ColorDelegator.recolorize_main(self)
</t>
<t tx="ekr.20060521134315.179">def LoadTagDefs(self):
    ColorDelegator.LoadTagDefs(self)
    theme = idleConf.GetOption('main','Theme','name')
    self.tagdefs.update({
        "stdin": {'background':None,'foreground':None},
        "stdout": idleConf.GetHighlight(theme, "stdout"),
        "stderr": idleConf.GetHighlight(theme, "stderr"),
        "console": idleConf.GetHighlight(theme, "console"),
        None: idleConf.GetHighlight(theme, "normal"),
    })
</t>
<t tx="ekr.20060521134315.180">
class ModifiedUndoDelegator(UndoDelegator):
	&lt;&lt; class ModifiedUndoDelegator declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.181">"Extend base class: forbid insert/delete before the I/O mark"

</t>
<t tx="ekr.20060521134315.182">def insert(self, index, chars, tags=None):
    try:
        if self.delegate.compare(index, "&lt;", "iomark"):
            self.delegate.bell()
            return
    except TclError:
        pass
    UndoDelegator.insert(self, index, chars, tags)
</t>
<t tx="ekr.20060521134315.183">def delete(self, index1, index2=None):
    try:
        if self.delegate.compare(index1, "&lt;", "iomark"):
            self.delegate.bell()
            return
    except TclError:
        pass
    UndoDelegator.delete(self, index1, index2)
</t>
<t tx="ekr.20060521134315.184">class MyRPCClient(rpc.RPCClient):
	@others
</t>
<t tx="ekr.20060521134315.185">def handle_EOF(self):
    "Override the base class - just re-raise EOFError"
    raise EOFError
</t>
<t tx="ekr.20060521134315.186">class ModifiedInterpreter(InteractiveInterpreter):
	@others
</t>
<t tx="ekr.20060521134315.187">def __init__(self, tkconsole):
    self.tkconsole = tkconsole
    locals = sys.modules['__main__'].__dict__
    InteractiveInterpreter.__init__(self, locals=locals)
    self.save_warnings_filters = None
    self.restarting = False
    self.subprocess_arglist = self.build_subprocess_arglist()
</t>
<t tx="ekr.20060521134315.188">port = 8833
rpcclt = None
rpcpid = None

def spawn_subprocess(self):
    args = self.subprocess_arglist
    self.rpcpid = os.spawnv(os.P_NOWAIT, sys.executable, args)
</t>
<t tx="ekr.20060521134315.189">def build_subprocess_arglist(self):
    w = ['-W' + s for s in sys.warnoptions]
    # Maybe IDLE is installed and is being accessed via sys.path,
    # or maybe it's not installed and the idle.py script is being
    # run from the IDLE source directory.
    del_exitf = idleConf.GetOption('main', 'General', 'delete-exitfunc',
                                   default=False, type='bool')
    if __name__ == 'idlelib.PyShell':
        command = "__import__('idlelib.run').run.main(%r)" % (del_exitf,)
    else:
        command = "__import__('run').main(%r)" % (del_exitf,)
    if sys.platform[:3] == 'win' and ' ' in sys.executable:
        # handle embedded space in path by quoting the argument
        decorated_exec = '"%s"' % sys.executable
    else:
        decorated_exec = sys.executable
    return [decorated_exec] + w + ["-c", command, str(self.port)]
</t>
<t tx="ekr.20060521134315.190">def start_subprocess(self):
    # spawning first avoids passing a listening socket to the subprocess
    self.spawn_subprocess()
    #time.sleep(20) # test to simulate GUI not accepting connection
    addr = (LOCALHOST, self.port)
    # Idle starts listening for connection on localhost
    for i in range(3):
        time.sleep(i)
        try:
            self.rpcclt = MyRPCClient(addr)
            break
        except socket.error, err:
            pass
    else:
        self.display_port_binding_error()
        return None
    # Accept the connection from the Python execution server
    self.rpcclt.listening_sock.settimeout(10)
    try:
        self.rpcclt.accept()
    except socket.timeout, err:
        self.display_no_subprocess_error()
        return None
    self.rpcclt.register("stdin", self.tkconsole)
    self.rpcclt.register("stdout", self.tkconsole.stdout)
    self.rpcclt.register("stderr", self.tkconsole.stderr)
    self.rpcclt.register("flist", self.tkconsole.flist)
    self.rpcclt.register("linecache", linecache)
    self.rpcclt.register("interp", self)
    self.transfer_path()
    self.poll_subprocess()
    return self.rpcclt
</t>
<t tx="ekr.20060521134315.191">def restart_subprocess(self):
    if self.restarting:
        return self.rpcclt
    self.restarting = True
    # close only the subprocess debugger
    debug = self.getdebugger()
    if debug:
        try:
            # Only close subprocess debugger, don't unregister gui_adap!
            RemoteDebugger.close_subprocess_debugger(self.rpcclt)
        except:
            pass
    # Kill subprocess, spawn a new one, accept connection.
    self.rpcclt.close()
    self.unix_terminate()
    console = self.tkconsole
    was_executing = console.executing
    console.executing = False
    self.spawn_subprocess()
    try:
        self.rpcclt.accept()
    except socket.timeout, err:
        self.display_no_subprocess_error()
        return None
    self.transfer_path()
    # annotate restart in shell window and mark it
    console.text.delete("iomark", "end-1c")
    if was_executing:
        console.write('\n')
        console.showprompt()
    halfbar = ((int(console.width) - 16) // 2) * '='
    console.write(halfbar + ' RESTART ' + halfbar)
    console.text.mark_set("restart", "end-1c")
    console.text.mark_gravity("restart", "left")
    console.showprompt()
    # restart subprocess debugger
    if debug:
        # Restarted debugger connects to current instance of debug GUI
        gui = RemoteDebugger.restart_subprocess_debugger(self.rpcclt)
        # reload remote debugger breakpoints for all PyShellEditWindows
        debug.load_breakpoints()
    self.restarting = False
    return self.rpcclt
</t>
<t tx="ekr.20060521134315.192">def __request_interrupt(self):
    self.rpcclt.remotecall("exec", "interrupt_the_server", (), {})
</t>
<t tx="ekr.20060521134315.193">def interrupt_subprocess(self):
    threading.Thread(target=self.__request_interrupt).start()
</t>
<t tx="ekr.20060521134315.194">def kill_subprocess(self):
    try:
        self.rpcclt.close()
    except AttributeError:  # no socket
        pass
    self.unix_terminate()
    self.tkconsole.executing = False
    self.rpcclt = None
</t>
<t tx="ekr.20060521134315.195">def unix_terminate(self):
    "UNIX: make sure subprocess is terminated and collect status"
    if hasattr(os, 'kill'):
        try:
            os.kill(self.rpcpid, SIGTERM)
        except OSError:
            # process already terminated:
            return
        else:
            try:
                os.waitpid(self.rpcpid, 0)
            except OSError:
                return
</t>
<t tx="ekr.20060521134315.196">def transfer_path(self):
    self.runcommand("""if 1:
    import sys as _sys
    _sys.path = %r
    del _sys
    _msg = 'Use File/Exit or your end-of-file key to quit IDLE'
    __builtins__.quit = __builtins__.exit = _msg
    del _msg
    \n""" % (sys.path,))
</t>
<t tx="ekr.20060521134315.197">active_seq = None

def poll_subprocess(self):
    clt = self.rpcclt
    if clt is None:
        return
    try:
        response = clt.pollresponse(self.active_seq, wait=0.05)
    except (EOFError, IOError, KeyboardInterrupt):
        # lost connection or subprocess terminated itself, restart
        # [the KBI is from rpc.SocketIO.handle_EOF()]
        if self.tkconsole.closing:
            return
        response = None
        self.restart_subprocess()
    if response:
        self.tkconsole.resetoutput()
        self.active_seq = None
        how, what = response
        console = self.tkconsole.console
        if how == "OK":
            if what is not None:
                print &gt;&gt;console, repr(what)
        elif how == "EXCEPTION":
            if self.tkconsole.getvar("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;"):
                self.remote_stack_viewer()
        elif how == "ERROR":
            errmsg = "PyShell.ModifiedInterpreter: Subprocess ERROR:\n"
            print &gt;&gt;sys.__stderr__, errmsg, what
            print &gt;&gt;console, errmsg, what
        # we received a response to the currently active seq number:
        self.tkconsole.endexecuting()
    # Reschedule myself
    if not self.tkconsole.closing:
        self.tkconsole.text.after(self.tkconsole.pollinterval,
                                  self.poll_subprocess)
</t>
<t tx="ekr.20060521134315.198">debugger = None

def setdebugger(self, debugger):
    self.debugger = debugger
</t>
<t tx="ekr.20060521134315.199">def getdebugger(self):
    return self.debugger
</t>
<t tx="ekr.20060521134315.200">def open_remote_stack_viewer(self):
    """Initiate the remote stack viewer from a separate thread.

    This method is called from the subprocess, and by returning from this
    method we allow the subprocess to unblock.  After a bit the shell
    requests the subprocess to open the remote stack viewer which returns a
    static object looking at the last exceptiopn.  It is queried through
    the RPC mechanism.

    """
    self.tkconsole.text.after(300, self.remote_stack_viewer)
    return
</t>
<t tx="ekr.20060521134315.201">def remote_stack_viewer(self):
    import RemoteObjectBrowser
    oid = self.rpcclt.remotequeue("exec", "stackviewer", ("flist",), {})
    if oid is None:
        self.tkconsole.root.bell()
        return
    item = RemoteObjectBrowser.StubObjectTreeItem(self.rpcclt, oid)
    from TreeWidget import ScrolledCanvas, TreeNode
    top = Toplevel(self.tkconsole.root)
    theme = idleConf.GetOption('main','Theme','name')
    background = idleConf.GetHighlight(theme, 'normal')['background']
    sc = ScrolledCanvas(top, bg=background, highlightthickness=0)
    sc.frame.pack(expand=1, fill="both")
    node = TreeNode(sc.canvas, None, item)
    node.expand()
</t>
<t tx="ekr.20060521134315.202">    # XXX Should GC the remote tree when closing the window

gid = 0

def execsource(self, source):
    "Like runsource() but assumes complete exec source"
    filename = self.stuffsource(source)
    self.execfile(filename, source)
</t>
<t tx="ekr.20060521134315.203">def execfile(self, filename, source=None):
    "Execute an existing file"
    if source is None:
        source = open(filename, "r").read()
    try:
        code = compile(source, filename, "exec")
    except (OverflowError, SyntaxError):
        self.tkconsole.resetoutput()
        tkerr = self.tkconsole.stderr
        print&gt;&gt;tkerr, '*** Error in script or command!\n'
        print&gt;&gt;tkerr, 'Traceback (most recent call last):'
        InteractiveInterpreter.showsyntaxerror(self, filename)
        self.tkconsole.showprompt()
    else:
        self.runcode(code)
</t>
<t tx="ekr.20060521134315.204">def runsource(self, source):
    "Extend base class method: Stuff the source in the line cache first"
    filename = self.stuffsource(source)
    self.more = 0
    self.save_warnings_filters = warnings.filters[:]
    warnings.filterwarnings(action="error", category=SyntaxWarning)
    if isinstance(source, types.UnicodeType):
        import IOBinding
        try:
            source = source.encode(IOBinding.encoding)
        except UnicodeError:
            self.tkconsole.resetoutput()
            self.write("Unsupported characters in input")
            return
    try:
        return InteractiveInterpreter.runsource(self, source, filename)
    finally:
        if self.save_warnings_filters is not None:
            warnings.filters[:] = self.save_warnings_filters
            self.save_warnings_filters = None
</t>
<t tx="ekr.20060521134315.205">def stuffsource(self, source):
    "Stuff source in the filename cache"
    filename = "&lt;pyshell#%d&gt;" % self.gid
    self.gid = self.gid + 1
    lines = source.split("\n")
    linecache.cache[filename] = len(source)+1, 0, lines, filename
    return filename
</t>
<t tx="ekr.20060521134315.206">def prepend_syspath(self, filename):
    "Prepend sys.path with file's directory if not already included"
    self.runcommand("""if 1:
        _filename = %r
        import sys as _sys
        from os.path import dirname as _dirname
        _dir = _dirname(_filename)
        if not _dir in _sys.path:
            _sys.path.insert(0, _dir)
        del _filename, _sys, _dirname, _dir
        \n""" % (filename,))
</t>
<t tx="ekr.20060521134315.207">def showsyntaxerror(self, filename=None):
    """Extend base class method: Add Colorizing

    Color the offending position instead of printing it and pointing at it
    with a caret.

    """
    text = self.tkconsole.text
    stuff = self.unpackerror()
    if stuff:
        msg, lineno, offset, line = stuff
        if lineno == 1:
            pos = "iomark + %d chars" % (offset-1)
        else:
            pos = "iomark linestart + %d lines + %d chars" % \
                  (lineno-1, offset-1)
        text.tag_add("ERROR", pos)
        text.see(pos)
        char = text.get(pos)
        if char and char in IDENTCHARS:
            text.tag_add("ERROR", pos + " wordstart", pos)
        self.tkconsole.resetoutput()
        self.write("SyntaxError: %s\n" % str(msg))
    else:
        self.tkconsole.resetoutput()
        InteractiveInterpreter.showsyntaxerror(self, filename)
    self.tkconsole.showprompt()
</t>
<t tx="ekr.20060521134315.208">def unpackerror(self):
    type, value, tb = sys.exc_info()
    ok = type is SyntaxError
    if ok:
        try:
            msg, (dummy_filename, lineno, offset, line) = value
            if not offset:
                offset = 0
        except:
            ok = 0
    if ok:
        return msg, lineno, offset, line
    else:
        return None
</t>
<t tx="ekr.20060521134315.209">def showtraceback(self):
    "Extend base class method to reset output properly"
    self.tkconsole.resetoutput()
    self.checklinecache()
    InteractiveInterpreter.showtraceback(self)
    if self.tkconsole.getvar("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;"):
        self.tkconsole.open_stack_viewer()
</t>
<t tx="ekr.20060521134315.210">def checklinecache(self):
    c = linecache.cache
    for key in c.keys():
        if key[:1] + key[-1:] != "&lt;&gt;":
            del c[key]
</t>
<t tx="ekr.20060521134315.211">def runcommand(self, code):
    "Run the code without invoking the debugger"
    # The code better not raise an exception!
    if self.tkconsole.executing:
        self.display_executing_dialog()
        return 0
    if self.rpcclt:
        self.rpcclt.remotequeue("exec", "runcode", (code,), {})
    else:
        exec code in self.locals
    return 1
</t>
<t tx="ekr.20060521134315.212">def runcode(self, code):
    "Override base class method"
    if self.tkconsole.executing:
        self.interp.restart_subprocess()
    self.checklinecache()
    if self.save_warnings_filters is not None:
        warnings.filters[:] = self.save_warnings_filters
        self.save_warnings_filters = None
    debugger = self.debugger
    try:
        self.tkconsole.beginexecuting()
        try:
            if not debugger and self.rpcclt is not None:
                self.active_seq = self.rpcclt.asyncqueue("exec", "runcode",
                                                        (code,), {})
            elif debugger:
                debugger.run(code, self.locals)
            else:
                exec code in self.locals
        except SystemExit:
            if tkMessageBox.askyesno(
                "Exit?",
                "Do you want to exit altogether?",
                default="yes",
                master=self.tkconsole.text):
                raise
            else:
                self.showtraceback()
        except:
            self.showtraceback()
    finally:
        if not use_subprocess:
            self.tkconsole.endexecuting()
</t>
<t tx="ekr.20060521134315.213">def write(self, s):
    "Override base class method"
    self.tkconsole.stderr.write(s)
</t>
<t tx="ekr.20060521134315.214">def display_port_binding_error(self):
    tkMessageBox.showerror(
        "Port Binding Error",
        "IDLE can't bind TCP/IP port 8833, which is necessary to "
        "communicate with its Python execution server.  Either "
        "no networking is installed on this computer or another "
        "process (another IDLE?) is using the port.  Run IDLE with the -n "
        "command line switch to start without a subprocess and refer to "
        "Help/IDLE Help 'Running without a subprocess' for further "
        "details.",
        master=self.tkconsole.text)
</t>
<t tx="ekr.20060521134315.215">def display_no_subprocess_error(self):
    tkMessageBox.showerror(
        "Subprocess Startup Error",
        "IDLE's subprocess didn't make connection.  Either IDLE can't "
        "start a subprocess or personal firewall software is blocking "
        "the connection.",
        master=self.tkconsole.text)
</t>
<t tx="ekr.20060521134315.216">def display_executing_dialog(self):
    tkMessageBox.showerror(
        "Already executing",
        "The Python Shell window is already executing a command; "
        "please wait until it is finished.",
        master=self.tkconsole.text)
</t>
<t tx="ekr.20060521134315.217">class PyShell(OutputWindow):
	&lt;&lt; class PyShell declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.218">shell_title = "Python Shell"

# Override classes
ColorDelegator = ModifiedColorDelegator
UndoDelegator = ModifiedUndoDelegator

# Override menus
menu_specs = [
    ("file", "_File"),
    ("edit", "_Edit"),
    ("debug", "_Debug"),
    ("options", "_Options"),
    ("windows", "_Windows"),
    ("help", "_Help"),
]

# New classes
from IdleHistory import History

</t>
<t tx="ekr.20060521134315.219">def __init__(self, flist=None):
    if use_subprocess:
        ms = self.menu_specs
        if ms[2][0] != "shell":
            ms.insert(2, ("shell", "_Shell"))
    self.interp = ModifiedInterpreter(self)
    if flist is None:
        root = Tk()
        fixwordbreaks(root)
        root.withdraw()
        flist = PyShellFileList(root)
    #
    OutputWindow.__init__(self, flist, None, None)
    #
    import __builtin__
    __builtin__.quit = __builtin__.exit = "To exit, type Ctrl-D."
    #
    self.config(usetabs=1, indentwidth=8, context_use_ps1=1)
    #
    text = self.text
    text.configure(wrap="char")
    text.bind("&lt;&lt;newline-and-indent&gt;&gt;", self.enter_callback)
    text.bind("&lt;&lt;plain-newline-and-indent&gt;&gt;", self.linefeed_callback)
    text.bind("&lt;&lt;interrupt-execution&gt;&gt;", self.cancel_callback)
    text.bind("&lt;&lt;beginning-of-line&gt;&gt;", self.home_callback)
    text.bind("&lt;&lt;end-of-file&gt;&gt;", self.eof_callback)
    text.bind("&lt;&lt;open-stack-viewer&gt;&gt;", self.open_stack_viewer)
    text.bind("&lt;&lt;toggle-debugger&gt;&gt;", self.toggle_debugger)
    text.bind("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;", self.toggle_jit_stack_viewer)
    if use_subprocess:
        text.bind("&lt;&lt;view-restart&gt;&gt;", self.view_restart_mark)
        text.bind("&lt;&lt;restart-shell&gt;&gt;", self.restart_shell)
    #
    self.save_stdout = sys.stdout
    self.save_stderr = sys.stderr
    self.save_stdin = sys.stdin
    import IOBinding
    self.stdout = PseudoFile(self, "stdout", IOBinding.encoding)
    self.stderr = PseudoFile(self, "stderr", IOBinding.encoding)
    self.console = PseudoFile(self, "console", IOBinding.encoding)
    if not use_subprocess:
        sys.stdout = self.stdout
        sys.stderr = self.stderr
        sys.stdin = self
    #
    self.history = self.History(self.text)
    #
    self.pollinterval = 50  # millisec
</t>
<t tx="ekr.20060521134315.220">def get_standard_extension_names(self):
    return idleConf.GetExtensions(shell_only=True)
</t>
<t tx="ekr.20060521134315.221">reading = False
executing = False
canceled = False
endoffile = False
closing = False

def set_warning_stream(self, stream):
    global warning_stream
    warning_stream = stream
</t>
<t tx="ekr.20060521134315.222">def get_warning_stream(self):
    return warning_stream
</t>
<t tx="ekr.20060521134315.223">def toggle_debugger(self, event=None):
    if self.executing:
        tkMessageBox.showerror("Don't debug now",
            "You can only toggle the debugger when idle",
            master=self.text)
        self.set_debugger_indicator()
        return "break"
    else:
        db = self.interp.getdebugger()
        if db:
            self.close_debugger()
        else:
            self.open_debugger()
</t>
<t tx="ekr.20060521134315.224">def set_debugger_indicator(self):
    db = self.interp.getdebugger()
    self.setvar("&lt;&lt;toggle-debugger&gt;&gt;", not not db)
</t>
<t tx="ekr.20060521134315.225">def toggle_jit_stack_viewer(self, event=None):
    pass # All we need is the variable
</t>
<t tx="ekr.20060521134315.226">def close_debugger(self):
    db = self.interp.getdebugger()
    if db:
        self.interp.setdebugger(None)
        db.close()
        if self.interp.rpcclt:
            RemoteDebugger.close_remote_debugger(self.interp.rpcclt)
        self.resetoutput()
        self.console.write("[DEBUG OFF]\n")
        sys.ps1 = "&gt;&gt;&gt; "
        self.showprompt()
    self.set_debugger_indicator()
</t>
<t tx="ekr.20060521134315.227">def open_debugger(self):
    if self.interp.rpcclt:
        dbg_gui = RemoteDebugger.start_remote_debugger(self.interp.rpcclt,
                                                       self)
    else:
        dbg_gui = Debugger.Debugger(self)
    self.interp.setdebugger(dbg_gui)
    dbg_gui.load_breakpoints()
    sys.ps1 = "[DEBUG ON]\n&gt;&gt;&gt; "
    self.showprompt()
    self.set_debugger_indicator()
</t>
<t tx="ekr.20060521134315.228">def beginexecuting(self):
    "Helper for ModifiedInterpreter"
    self.resetoutput()
    self.executing = 1
</t>
<t tx="ekr.20060521134315.229">def endexecuting(self):
    "Helper for ModifiedInterpreter"
    self.executing = 0
    self.canceled = 0
    self.showprompt()
</t>
<t tx="ekr.20060521134315.230">def close(self):
    "Extend EditorWindow.close()"
    if self.executing:
        response = tkMessageBox.askokcancel(
            "Kill?",
            "The program is still running!\n Do you want to kill it?",
            default="ok",
            parent=self.text)
        if response == False:
            return "cancel"
    self.closing = True
    # Wait for poll_subprocess() rescheduling to stop
    self.text.after(2 * self.pollinterval, self.close2)
</t>
<t tx="ekr.20060521134315.231">def close2(self):
    return EditorWindow.close(self)
</t>
<t tx="ekr.20060521134315.232">def _close(self):
    "Extend EditorWindow._close(), shut down debugger and execution server"
    self.close_debugger()
    if use_subprocess:
        self.interp.kill_subprocess()
    # Restore std streams
    sys.stdout = self.save_stdout
    sys.stderr = self.save_stderr
    sys.stdin = self.save_stdin
    # Break cycles
    self.interp = None
    self.console = None
    self.flist.pyshell = None
    self.history = None
    EditorWindow._close(self)
</t>
<t tx="ekr.20060521134315.233">def ispythonsource(self, filename):
    "Override EditorWindow method: never remove the colorizer"
    return True
</t>
<t tx="ekr.20060521134315.234">def short_title(self):
    return self.shell_title
</t>
<t tx="ekr.20060521134315.235">COPYRIGHT = \
      'Type "copyright", "credits" or "license()" for more information.'

firewallmessage = """
****************************************************************
Personal firewall software may warn about the connection IDLE
makes to its subprocess using this computer's internal loopback
interface.  This connection is not visible on any external
interface and no data is sent to or received from the Internet.
****************************************************************
"""

def begin(self):
    self.resetoutput()
    if use_subprocess:
        nosub = ''
        client = self.interp.start_subprocess()
        if not client:
            self.close()
            return False
    else:
        nosub = "==== No Subprocess ===="
    self.write("Python %s on %s\n%s\n%s\nIDLE %s      %s\n" %
               (sys.version, sys.platform, self.COPYRIGHT,
                self.firewallmessage, idlever.IDLE_VERSION, nosub))
    self.showprompt()
    import Tkinter
    Tkinter._default_root = None # 03Jan04 KBK What's this?
    return True
</t>
<t tx="ekr.20060521134315.236">def readline(self):
    save = self.reading
    try:
        self.reading = 1
        self.top.mainloop()
    finally:
        self.reading = save
    line = self.text.get("iomark", "end-1c")
    if isinstance(line, unicode):
        import IOBinding
        try:
            line = line.encode(IOBinding.encoding)
        except UnicodeError:
            pass
    self.resetoutput()
    if self.canceled:
        self.canceled = 0
        raise KeyboardInterrupt
    if self.endoffile:
        self.endoffile = 0
        return ""
    return line
</t>
<t tx="ekr.20060521134315.237">def isatty(self):
    return True
</t>
<t tx="ekr.20060521134315.238">def cancel_callback(self, event=None):
    try:
        if self.text.compare("sel.first", "!=", "sel.last"):
            return # Active selection -- always use default binding
    except:
        pass
    if not (self.executing or self.reading):
        self.resetoutput()
        self.interp.write("KeyboardInterrupt\n")
        self.showprompt()
        return "break"
    self.endoffile = 0
    self.canceled = 1
    if self.reading:
        self.top.quit()
    elif (self.executing and self.interp.rpcclt):
        if self.interp.getdebugger():
            self.interp.restart_subprocess()
        else:
            self.interp.interrupt_subprocess()
    return "break"
</t>
<t tx="ekr.20060521134315.239">def eof_callback(self, event):
    if self.executing and not self.reading:
        return # Let the default binding (delete next char) take over
    if not (self.text.compare("iomark", "==", "insert") and
            self.text.compare("insert", "==", "end-1c")):
        return # Let the default binding (delete next char) take over
    if not self.executing:
        self.resetoutput()
        self.close()
    else:
        self.canceled = 0
        self.endoffile = 1
        self.top.quit()
    return "break"
</t>
<t tx="ekr.20060521134315.240">def home_callback(self, event):
    if event.state != 0 and event.keysym == "Home":
        return # &lt;Modifier-Home&gt;; fall back to class binding
    if self.text.compare("iomark", "&lt;=", "insert") and \
       self.text.compare("insert linestart", "&lt;=", "iomark"):
        self.text.mark_set("insert", "iomark")
        self.text.tag_remove("sel", "1.0", "end")
        self.text.see("insert")
        return "break"
</t>
<t tx="ekr.20060521134315.241">def linefeed_callback(self, event):
    # Insert a linefeed without entering anything (still autoindented)
    if self.reading:
        self.text.insert("insert", "\n")
        self.text.see("insert")
    else:
        self.newline_and_indent_event(event)
    return "break"
</t>
<t tx="ekr.20060521134315.242">def enter_callback(self, event):
    if self.executing and not self.reading:
        return # Let the default binding (insert '\n') take over
    # If some text is selected, recall the selection
    # (but only if this before the I/O mark)
    try:
        sel = self.text.get("sel.first", "sel.last")
        if sel:
            if self.text.compare("sel.last", "&lt;=", "iomark"):
                self.recall(sel)
                return "break"
    except:
        pass
    # If we're strictly before the line containing iomark, recall
    # the current line, less a leading prompt, less leading or
    # trailing whitespace
    if self.text.compare("insert", "&lt;", "iomark linestart"):
        # Check if there's a relevant stdin range -- if so, use it
        prev = self.text.tag_prevrange("stdin", "insert")
        if prev and self.text.compare("insert", "&lt;", prev[1]):
            self.recall(self.text.get(prev[0], prev[1]))
            return "break"
        next = self.text.tag_nextrange("stdin", "insert")
        if next and self.text.compare("insert lineend", "&gt;=", next[0]):
            self.recall(self.text.get(next[0], next[1]))
            return "break"
        # No stdin mark -- just get the current line, less any prompt
        line = self.text.get("insert linestart", "insert lineend")
        last_line_of_prompt = sys.ps1.split('\n')[-1]
        if line.startswith(last_line_of_prompt):
            line = line[len(last_line_of_prompt):]
        self.recall(line)
        return "break"
    # If we're between the beginning of the line and the iomark, i.e.
    # in the prompt area, move to the end of the prompt
    if self.text.compare("insert", "&lt;", "iomark"):
        self.text.mark_set("insert", "iomark")
    # If we're in the current input and there's only whitespace
    # beyond the cursor, erase that whitespace first
    s = self.text.get("insert", "end-1c")
    if s and not s.strip():
        self.text.delete("insert", "end-1c")
    # If we're in the current input before its last line,
    # insert a newline right at the insert point
    if self.text.compare("insert", "&lt;", "end-1c linestart"):
        self.newline_and_indent_event(event)
        return "break"
    # We're in the last line; append a newline and submit it
    self.text.mark_set("insert", "end-1c")
    if self.reading:
        self.text.insert("insert", "\n")
        self.text.see("insert")
    else:
        self.newline_and_indent_event(event)
    self.text.tag_add("stdin", "iomark", "end-1c")
    self.text.update_idletasks()
    if self.reading:
        self.top.quit() # Break out of recursive mainloop() in raw_input()
    else:
        self.runit()
    return "break"
</t>
<t tx="ekr.20060521134315.243">def recall(self, s):
    if self.history:
        self.history.recall(s)
</t>
<t tx="ekr.20060521134315.244">def runit(self):
    line = self.text.get("iomark", "end-1c")
    # Strip off last newline and surrounding whitespace.
    # (To allow you to hit return twice to end a statement.)
    i = len(line)
    while i &gt; 0 and line[i-1] in " \t":
        i = i-1
    if i &gt; 0 and line[i-1] == "\n":
        i = i-1
    while i &gt; 0 and line[i-1] in " \t":
        i = i-1
    line = line[:i]
    more = self.interp.runsource(line)
</t>
<t tx="ekr.20060521134315.245">def open_stack_viewer(self, event=None):
    if self.interp.rpcclt:
        return self.interp.remote_stack_viewer()
    try:
        sys.last_traceback
    except:
        tkMessageBox.showerror("No stack trace",
            "There is no stack trace yet.\n"
            "(sys.last_traceback is not defined)",
            master=self.text)
        return
    from StackViewer import StackBrowser
    sv = StackBrowser(self.root, self.flist)
</t>
<t tx="ekr.20060521134315.246">def view_restart_mark(self, event=None):
    self.text.see("iomark")
    self.text.see("restart")
</t>
<t tx="ekr.20060521134315.247">def restart_shell(self, event=None):
    self.interp.restart_subprocess()
</t>
<t tx="ekr.20060521134315.248">def showprompt(self):
    self.resetoutput()
    try:
        s = str(sys.ps1)
    except:
        s = ""
    self.console.write(s)
    self.text.mark_set("insert", "end-1c")
    self.set_line_and_column()
    self.io.reset_undo()
</t>
<t tx="ekr.20060521134315.249">def resetoutput(self):
    source = self.text.get("iomark", "end-1c")
    if self.history:
        self.history.history_store(source)
    if self.text.get("end-2c") != "\n":
        self.text.insert("end-1c", "\n")
    self.text.mark_set("iomark", "end-1c")
    self.set_line_and_column()
    sys.stdout.softspace = 0
</t>
<t tx="ekr.20060521134315.250">def write(self, s, tags=()):
    try:
        self.text.mark_gravity("iomark", "right")
        OutputWindow.write(self, s, tags, "iomark")
        self.text.mark_gravity("iomark", "left")
    except:
        pass
    if self.canceled:
        self.canceled = 0
        if not use_subprocess:
            raise KeyboardInterrupt
</t>
<t tx="ekr.20060521134315.251">
class PseudoFile:
	@others
</t>
<t tx="ekr.20060521134315.252">def __init__(self, shell, tags, encoding=None):
    self.shell = shell
    self.tags = tags
    self.softspace = 0
    self.encoding = encoding
</t>
<t tx="ekr.20060521134315.253">def write(self, s):
    self.shell.write(s, self.tags)
</t>
<t tx="ekr.20060521134315.254">def writelines(self, l):
    map(self.write, l)
</t>
<t tx="ekr.20060521134315.255">def flush(self):
    pass
</t>
<t tx="ekr.20060521134315.256">def isatty(self):
    return True
</t>
<t tx="ekr.20060521134315.257">usage_msg = """\

USAGE: idle  [-deins] [-t title] [file]*
       idle  [-dns] [-t title] (-c cmd | -r file) [arg]*
       idle  [-dns] [-t title] - [arg]*

  -h         print this help message and exit
  -n         run IDLE without a subprocess (see Help/IDLE Help for details)

The following options will override the IDLE 'settings' configuration:

  -e         open an edit window
  -i         open a shell window

The following options imply -i and will open a shell:

  -c cmd     run the command in a shell, or
  -r file    run script from file

  -d         enable the debugger
  -s         run $IDLESTARTUP or $PYTHONSTARTUP before anything else
  -t title   set title of shell window

A default edit window will be bypassed when -c, -r, or - are used.

[arg]* are passed to the command (-c) or script (-r) in sys.argv[1:].

Examples:

idle
        Open an edit window or shell depending on IDLE's configuration.

idle foo.py foobar.py
        Edit the files, also open a shell if configured to start with shell.

idle -est "Baz" foo.py
        Run $IDLESTARTUP or $PYTHONSTARTUP, edit foo.py, and open a shell
        window with the title "Baz".

idle -c "import sys; print sys.argv" "foo"
        Open a shell window and run the command, passing "-c" in sys.argv[0]
        and "foo" in sys.argv[1].

idle -d -s -r foo.py "Hello World"
        Open a shell window, run a startup script, enable the debugger, and
        run foo.py, passing "foo.py" in sys.argv[0] and "Hello World" in
        sys.argv[1].

echo "import sys; print sys.argv" | idle - "foobar"
        Open a shell window, run the script piped in, passing '' in sys.argv[0]
        and "foobar" in sys.argv[1].
"""

def main(previousRoot = None): ### EKR
    global flist, root, use_subprocess

    use_subprocess = True
    enable_shell = False
    enable_edit = False
    debug = False
    cmd = None
    script = None
    startup = False
    try:
        sys.ps1
    except AttributeError:
        sys.ps1 = '&gt;&gt;&gt; '
    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:deihnr:st:")
    except getopt.error, msg:
        sys.stderr.write("Error: %s\n" % str(msg))
        sys.stderr.write(usage_msg)
        sys.exit(2)
    for o, a in opts:
        if o == '-c':
            cmd = a
            enable_shell = True
        if o == '-d':
            debug = True
            enable_shell = True
        if o == '-e':
            enable_edit = True
        if o == '-h':
            sys.stdout.write(usage_msg)
            sys.exit()
        if o == '-i':
            enable_shell = True
        if o == '-n':
            use_subprocess = False
        if o == '-r':
            script = a
            if os.path.isfile(script):
                pass
            else:
                print "No script file: ", script
                sys.exit()
            enable_shell = True
        if o == '-s':
            startup = True
            enable_shell = True
        if o == '-t':
            PyShell.shell_title = a
            enable_shell = True
    if args and args[0] == '-':
        cmd = sys.stdin.read()
        enable_shell = True
    # process sys.argv and sys.path:
    for i in range(len(sys.path)):
        sys.path[i] = os.path.abspath(sys.path[i])
    if args and args[0] == '-':
        sys.argv = [''] + args[1:]
    elif cmd:
        sys.argv = ['-c'] + args
    elif script:
        sys.argv = [script] + args
    elif args:
        enable_edit = True
        pathx = []
        for filename in args:
            pathx.append(os.path.dirname(filename))
        for dir in pathx:
            dir = os.path.abspath(dir)
            if not dir in sys.path:
                sys.path.insert(0, dir)
    else:
        dir = os.getcwd()
        if not dir in sys.path:
            sys.path.insert(0, dir)
    # check the IDLE settings configuration (but command line overrides)
    edit_start = idleConf.GetOption('main', 'General',
                                    'editor-on-startup', type='bool')
    enable_edit = enable_edit or edit_start
    enable_shell = enable_shell or not edit_start
    # start editor and/or shell windows:
    if previousRoot: # EKR
        root = previousRoot # EKR
    else:
        root = Tk(className="Idle")
        fixwordbreaks(root)
        root.withdraw()
    flist = PyShellFileList(root)
    if enable_edit:
        if not (cmd or script):
            for filename in args:
                flist.open(filename)
            if not args:
                flist.new()
    if enable_shell:
        if not flist.open_shell():
            return # couldn't open shell
    shell = flist.pyshell
    # handle remaining options:
    if debug:
        shell.open_debugger()
    if startup:
        filename = os.environ.get("IDLESTARTUP") or \
                   os.environ.get("PYTHONSTARTUP")
        if filename and os.path.isfile(filename):
            shell.interp.execfile(filename)
    if shell and cmd or script:
        shell.interp.runcommand("""if 1:
            import sys as _sys
            _sys.argv = %r
            del _sys
            \n""" % (sys.argv,))
        if cmd:
            shell.interp.execsource(cmd)
        elif script:
            shell.interp.prepend_syspath(script)
            shell.interp.execfile(script)
    if not previousRoot:
        root.mainloop()
        root.destroy()
</t>
<t tx="ekr.20060521134315.258">@ignore
@language python
&lt;&lt; Debugger declarations &gt;&gt;
@others
</t>
<t tx="ekr.20060521134315.259">import os
import bdb
import types
from Tkinter import *
from WindowList import ListedToplevel
from ScrolledList import ScrolledList</t>
<t tx="ekr.20060521134315.261">class Idb(bdb.Bdb):
	@others
</t>
<t tx="ekr.20060521134315.262">def __init__(self, gui):

    self.gui = gui
    bdb.Bdb.__init__(self)</t>
<t tx="ekr.20060521134315.263">def user_line(self, frame):
    
    if self.in_rpc_code(frame):
        self.set_step()
    else:
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame)</t>
<t tx="ekr.20060521134315.264">def user_exception(self, frame, info):
    
    if self.in_rpc_code(frame):
        self.set_step()
    else:
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame, info)</t>
<t tx="ekr.20060521134315.265">def in_rpc_code(self, frame):

    if frame.f_code.co_filename.count('rpc.py'):
        return True
    else:
        prev_frame = frame.f_back
        if prev_frame.f_code.co_filename.count('Debugger.py'):
            # (that test will catch both Debugger.py and RemoteDebugger.py)
            return False
        return self.in_rpc_code(prev_frame)
</t>
<t tx="ekr.20060521134315.266">def __frame2message(self, frame):

    code = frame.f_code
    filename = code.co_filename
    lineno = frame.f_lineno
    basename = os.path.basename(filename)
    message = "%s:%s" % (basename, lineno)
    if code.co_name != "?":
        message = "%s: %s()" % (message, code.co_name)
    return message
</t>
<t tx="ekr.20060521134315.267">class Debugger:

	vstack = vsource = vlocals = vglobals = None

	@others</t>
<t tx="ekr.20060521134315.268">def __init__(self, pyshell, idb=None):

    if idb is None:
        idb = Idb(self)
    self.pyshell = pyshell
    self.idb = idb
    self.frame = None
    self.make_gui()
    self.interacting = 0
    ekr_trace('Debugger.__init__: %s' % pyshell)</t>
<t tx="ekr.20060521134315.269">def run(self, *args):
    try:
        self.interacting = 1
        return self.idb.run(*args)
    finally:
        self.interacting = 0
</t>
<t tx="ekr.20060521134315.270">def close(self, event=None):
    if self.interacting:
        self.top.bell()
        return
    if self.stackviewer:
        self.stackviewer.close()
        self.stackviewer = None
    # Clean up pyshell if user clicked debugger control close widget.
    # (Causes a harmless extra cycle through close_debugger() if user
    # toggled debugger from pyshell Debug menu)
    self.pyshell.close_debugger()
    # Now close the debugger control window....
    self.top.destroy()

</t>
<t tx="ekr.20060521134315.271">def make_gui(self):
    pyshell = self.pyshell
    self.flist = pyshell.flist
    self.root = root = pyshell.root
    self.top = top = ListedToplevel(root)
    self.top.wm_title("Debug Control-24")
    self.top.wm_iconname("Debug")
    top.wm_protocol("WM_DELETE_WINDOW", self.close)
    self.top.bind("&lt;Escape&gt;", self.close)
    #
    self.bframe = bframe = Frame(top)
    self.bframe.pack(anchor="w")
    self.buttons = bl = []
    #
    self.bcont = b = Button(bframe, text="Go", command=self.cont)
    bl.append(b)
    self.bstep = b = Button(bframe, text="Step", command=self.step)
    bl.append(b)
    self.bnext = b = Button(bframe, text="Over", command=self.next)
    bl.append(b)
    self.bret = b = Button(bframe, text="Out", command=self.ret)
    bl.append(b)
    self.bret = b = Button(bframe, text="Quit", command=self.quit)
    bl.append(b)
    #
    for b in bl:
        b.configure(state="disabled")
        b.pack(side="left")
    #
    self.cframe = cframe = Frame(bframe)
    self.cframe.pack(side="left")
    #
    if not self.vstack:
        self.__class__.vstack = BooleanVar(top)
        self.vstack.set(1)
    self.bstack = Checkbutton(cframe,
        text="Stack", command=self.show_stack, variable=self.vstack)
    self.bstack.grid(row=0, column=0)
    if not self.vsource:
        self.__class__.vsource = BooleanVar(top)
    self.bsource = Checkbutton(cframe,
        text="Source", command=self.show_source, variable=self.vsource)
    self.bsource.grid(row=0, column=1)
    if not self.vlocals:
        self.__class__.vlocals = BooleanVar(top)
        self.vlocals.set(1)
    self.blocals = Checkbutton(cframe,
        text="Locals", command=self.show_locals, variable=self.vlocals)
    self.blocals.grid(row=1, column=0)
    if not self.vglobals:
        self.__class__.vglobals = BooleanVar(top)
    self.bglobals = Checkbutton(cframe,
        text="Globals", command=self.show_globals, variable=self.vglobals)
    self.bglobals.grid(row=1, column=1)
    #
    self.status = Label(top, anchor="w")
    self.status.pack(anchor="w")
    self.error = Label(top, anchor="w")
    self.error.pack(anchor="w", fill="x")
    self.errorbg = self.error.cget("background")
    #
    self.fstack = Frame(top, height=1)
    self.fstack.pack(expand=1, fill="both")
    self.flocals = Frame(top)
    self.flocals.pack(expand=1, fill="both")
    self.fglobals = Frame(top, height=1)
    self.fglobals.pack(expand=1, fill="both")
    #
    if self.vstack.get():
        self.show_stack()
    if self.vlocals.get():
        self.show_locals()
    if self.vglobals.get():
        self.show_globals()</t>
<t tx="ekr.20060521134315.272">def interaction(self, message, frame, info=None):
    self.frame = frame
    self.status.configure(text=message)
    #
    if info:
        type, value, tb = info
        try:
            m1 = type.__name__
        except AttributeError:
            m1 = "%s" % str(type)
        if value is not None:
            try:
                m1 = "%s: %s" % (m1, str(value))
            except:
                pass
        bg = "yellow"
    else:
        m1 = ""
        tb = None
        bg = self.errorbg
    self.error.configure(text=m1, background=bg)
    #
    sv = self.stackviewer
    if sv:
        stack, i = self.idb.get_stack(self.frame, tb)
        sv.load_stack(stack, i)
    #
    self.show_variables(1)
    #
    if self.vsource.get():
        self.sync_source_line()
    #
    for b in self.buttons:
        b.configure(state="normal")
    #
    self.top.wakeup()
    self.root.mainloop()
    #
    for b in self.buttons:
        b.configure(state="disabled")
    self.status.configure(text="")
    self.error.configure(text="", background=self.errorbg)
    self.frame = None
</t>
<t tx="ekr.20060521134315.273">def sync_source_line(self):
    frame = self.frame
    if not frame:
        return
    filename, lineno = self.__frame2fileline(frame)
    if filename[:1] + filename[-1:] != "&lt;&gt;" and os.path.exists(filename):
        self.flist.gotofileline(filename, lineno)
</t>
<t tx="ekr.20060521134315.274">def __frame2fileline(self, frame):
    code = frame.f_code
    filename = code.co_filename
    lineno = frame.f_lineno
    return filename, lineno
</t>
<t tx="ekr.20060521134315.275">def cont(self):
    self.idb.set_continue()
    self.root.quit()
</t>
<t tx="ekr.20060521134315.276">def step(self):
    self.idb.set_step()
    self.root.quit()
</t>
<t tx="ekr.20060521134315.277">def next(self):
    self.idb.set_next(self.frame)
    self.root.quit()
</t>
<t tx="ekr.20060521134315.278">def ret(self):
    self.idb.set_return(self.frame)
    self.root.quit()
</t>
<t tx="ekr.20060521134315.279">def quit(self):
    self.idb.set_quit()
    self.root.quit()
</t>
<t tx="ekr.20060521134315.280">stackviewer = None

def show_stack(self):
    if not self.stackviewer and self.vstack.get():
        self.stackviewer = sv = StackViewer(self.fstack, self.flist, self)
        if self.frame:
            stack, i = self.idb.get_stack(self.frame, None)
            sv.load_stack(stack, i)
    else:
        sv = self.stackviewer
        if sv and not self.vstack.get():
            self.stackviewer = None
            sv.close()
        self.fstack['height'] = 1
</t>
<t tx="ekr.20060521134315.281">def show_source(self):
    if self.vsource.get():
        self.sync_source_line()
</t>
<t tx="ekr.20060521134315.282">def show_frame(self, (frame, lineno)):
    self.frame = frame
    self.show_variables()
</t>
<t tx="ekr.20060521134315.283">localsviewer = None
globalsviewer = None

def show_locals(self):
    lv = self.localsviewer
    if self.vlocals.get():
        if not lv:
            self.localsviewer = NamespaceViewer(self.flocals, "Locals")
    else:
        if lv:
            self.localsviewer = None
            lv.close()
            self.flocals['height'] = 1
    self.show_variables()
</t>
<t tx="ekr.20060521134315.284">def show_globals(self):
    gv = self.globalsviewer
    if self.vglobals.get():
        if not gv:
            self.globalsviewer = NamespaceViewer(self.fglobals, "Globals")
    else:
        if gv:
            self.globalsviewer = None
            gv.close()
            self.fglobals['height'] = 1
    self.show_variables()
</t>
<t tx="ekr.20060521134315.285">def show_variables(self, force=0):

    lv = self.localsviewer
    gv = self.globalsviewer
    frame = self.frame
    if not frame:
        ldict = gdict = None
    else:
        ldict = frame.f_locals
        gdict = frame.f_globals
        if lv and gv and ldict is gdict:
            ldict = None
    if lv:
        lv.load_dict(ldict, force, self.pyshell.interp.rpcclt)
    if gv:
        gv.load_dict(gdict, force, self.pyshell.interp.rpcclt)
</t>
<t tx="ekr.20060521134315.286">def set_breakpoint_here(self, filename, lineno):

    self.idb.set_break(filename, lineno)</t>
<t tx="ekr.20060521134315.287">def clear_breakpoint_here(self, filename, lineno):
    self.idb.clear_break(filename, lineno)
</t>
<t tx="ekr.20060521134315.288">def clear_file_breaks(self, filename):
    self.idb.clear_all_file_breaks(filename)
</t>
<t tx="ekr.20060521134315.289">def load_breakpoints(self):
    "Load PyShellEditorWindow breakpoints into subprocess debugger"
    pyshell_edit_windows = self.pyshell.flist.inversedict.keys()
    for editwin in pyshell_edit_windows:
        filename = editwin.io.filename
        try:
            for lineno in editwin.breakpoints:
                self.set_breakpoint_here(filename, lineno)
        except AttributeError:
            continue
</t>
<t tx="ekr.20060521134315.290">
class StackViewer(ScrolledList):
	@others
</t>
<t tx="ekr.20060521134315.291">def __init__(self, master, flist, gui):
    ScrolledList.__init__(self, master, width=80)
    self.flist = flist
    self.gui = gui
    self.stack = []
</t>
<t tx="ekr.20060521134315.292">def load_stack(self, stack, index=None):
    self.stack = stack
    self.clear()
    for i in range(len(stack)):
        frame, lineno = stack[i]
        try:
            modname = frame.f_globals["__name__"]
        except:
            modname = "?"
        code = frame.f_code
        filename = code.co_filename
        funcname = code.co_name
        import linecache
        sourceline = linecache.getline(filename, lineno)
        import string
        sourceline = string.strip(sourceline)
        if funcname in ("?", "", None):
            item = "%s, line %d: %s" % (modname, lineno, sourceline)
        else:
            item = "%s.%s(), line %d: %s" % (modname, funcname,
                                             lineno, sourceline)
        if i == index:
            item = "&gt; " + item
        self.append(item)
    if index is not None:
        self.select(index)
</t>
<t tx="ekr.20060521134315.293">def popup_event(self, event):
    "override base method"
    if self.stack:
        return ScrolledList.popup_event(self, event)
</t>
<t tx="ekr.20060521134315.294">def fill_menu(self):
    "override base method"
    menu = self.menu
    menu.add_command(label="Go to source line",
                     command=self.goto_source_line)
    menu.add_command(label="Show stack frame",
                     command=self.show_stack_frame)
</t>
<t tx="ekr.20060521134315.295">def on_select(self, index):
    "override base method"
    if 0 &lt;= index &lt; len(self.stack):
        self.gui.show_frame(self.stack[index])
</t>
<t tx="ekr.20060521134315.296">def on_double(self, index):
    "override base method"
    self.show_source(index)
</t>
<t tx="ekr.20060521134315.297">def goto_source_line(self):
    index = self.listbox.index("active")
    self.show_source(index)
</t>
<t tx="ekr.20060521134315.298">def show_stack_frame(self):
    index = self.listbox.index("active")
    if 0 &lt;= index &lt; len(self.stack):
        self.gui.show_frame(self.stack[index])
</t>
<t tx="ekr.20060521134315.299">def show_source(self, index):
    if not (0 &lt;= index &lt; len(self.stack)):
        return
    frame, lineno = self.stack[index]
    code = frame.f_code
    filename = code.co_filename
    if os.path.isfile(filename):
        edit = self.flist.open(filename)
        if edit:
            edit.gotoline(lineno)
</t>
<t tx="ekr.20060521134315.300">

class NamespaceViewer:
	@others
</t>
<t tx="ekr.20060521134315.301">def __init__(self, master, title, dict=None):
    width = 0
    height = 40
    if dict:
        height = 20*len(dict) # XXX 20 == observed height of Entry widget
    self.master = master
    self.title = title
    import repr
    self.repr = repr.Repr()
    self.repr.maxstring = 60
    self.repr.maxother = 60
    self.frame = frame = Frame(master)
    self.frame.pack(expand=1, fill="both")
    self.label = Label(frame, text=title, borderwidth=2, relief="groove")
    self.label.pack(fill="x")
    self.vbar = vbar = Scrollbar(frame, name="vbar")
    vbar.pack(side="right", fill="y")
    self.canvas = canvas = Canvas(frame,
                                  height=min(300, max(40, height)),
                                  scrollregion=(0, 0, width, height))
    canvas.pack(side="left", fill="both", expand=1)
    vbar["command"] = canvas.yview
    canvas["yscrollcommand"] = vbar.set
    self.subframe = subframe = Frame(canvas)
    self.sfid = canvas.create_window(0, 0, window=subframe, anchor="nw")
    self.load_dict(dict)
</t>
<t tx="ekr.20060521134315.302">dict = -1

def load_dict(self, dict, force=0, rpc_client=None):
    if dict is self.dict and not force:
        return
    subframe = self.subframe
    frame = self.frame
    for c in subframe.children.values():
        c.destroy()
    self.dict = None
    if not dict:
        l = Label(subframe, text="None")
        l.grid(row=0, column=0)
    else:
        names = dict.keys()
        names.sort()
        row = 0
        for name in names:
            value = dict[name]
            svalue = self.repr.repr(value) # repr(value)
            # Strip extra quotes caused by calling repr on the (already)
            # repr'd value sent across the RPC interface:
            if rpc_client:
                svalue = svalue[1:-1]
            l = Label(subframe, text=name)
            l.grid(row=row, column=0, sticky="nw")
            l = Entry(subframe, width=0, borderwidth=0)
            l.insert(0, svalue)
            l.grid(row=row, column=1, sticky="nw")
            row = row+1
    self.dict = dict
    # XXX Could we use a &lt;Configure&gt; callback for the following?
    subframe.update_idletasks() # Alas!
    width = subframe.winfo_reqwidth()
    height = subframe.winfo_reqheight()
    canvas = self.canvas
    self.canvas["scrollregion"] = (0, 0, width, height)
    if height &gt; 300:
        canvas["height"] = 300
        frame.pack(expand=1)
    else:
        canvas["height"] = height
        frame.pack(expand=0)
</t>
<t tx="ekr.20060521134315.303">def close(self):
    self.frame.destroy()
</t>
<t tx="ekr.20060521134315.304">@ignore
@language python
&lt;&lt; RemoteDebugger declarations &gt;&gt;
@others
</t>
<t tx="ekr.20060521134315.305">"""Support for remote Python debugging.

Some ASCII art to describe the structure:

       IN PYTHON SUBPROCESS            #             IN IDLE PROCESS
                                       #
                                       #        oid='gui_adapter'
                 +----------+          #       +------------+          +-----+
                 | GUIProxy |----remote#call--&gt;| GUIAdapter |--calls--&gt;| GUI |
+-----+--calls--&gt;+----------+          #       +------------+          +-----+
| Idb |                                #                              /
+-----+&lt;-calls--+------------+         #        +----------+&lt;--calls-/
                | IdbAdapter |&lt;--remote#call----| IdbProxy |
                +------------+         #        +----------+
                oid='idb_adapter'      #

The purpose of the Proxy and Adapter classes is to translate certain
arguments and return values that cannot be transported through the RPC
barrier, in particular frame and traceback objects.

"""</t>
<t tx="ekr.20060521134315.306">import sys
import types
import rpc
import Debugger

debugging = 0

idb_adap_oid = "idb_adapter"
gui_adap_oid = "gui_adapter"

#=======================================
#
# In the PYTHON subprocess:

frametable = {}
dicttable = {}
codetable = {}
tracebacktable = {}

def wrap_frame(frame):
    fid = id(frame)
    frametable[fid] = frame
    return fid
</t>
<t tx="ekr.20060521134315.307">def wrap_info(info):
    "replace info[2], a traceback instance, by its ID"
    if info is None:
        return None
    else:
        traceback = info[2]
        assert isinstance(traceback, types.TracebackType)
        traceback_id = id(traceback)
        tracebacktable[traceback_id] = traceback
        modified_info = (info[0], info[1], traceback_id)
        return modified_info
</t>
<t tx="ekr.20060521134315.308">
class GUIProxy:
	@others
</t>
<t tx="ekr.20060521134315.309">def __init__(self, conn, gui_adap_oid):
    self.conn = conn
    self.oid = gui_adap_oid
</t>
<t tx="ekr.20060521134315.310">def interaction(self, message, frame, info=None):
    # calls rpc.SocketIO.remotecall() via run.MyHandler instance
    # pass frame and traceback object IDs instead of the objects themselves
    self.conn.remotecall(self.oid, "interaction",
                         (message, wrap_frame(frame), wrap_info(info)),
                         {})
</t>
<t tx="ekr.20060521134315.311">
class IdbAdapter:
	@others
</t>
<t tx="ekr.20060521134315.312">def __init__(self, idb):
    self.idb = idb
</t>
<t tx="ekr.20060521134315.313">#----------called by an IdbProxy----------

def set_step(self):
    self.idb.set_step()
</t>
<t tx="ekr.20060521134315.314">def set_quit(self):
    self.idb.set_quit()
</t>
<t tx="ekr.20060521134315.315">def set_continue(self):
    self.idb.set_continue()
</t>
<t tx="ekr.20060521134315.316">def set_next(self, fid):
    frame = frametable[fid]
    self.idb.set_next(frame)
</t>
<t tx="ekr.20060521134315.317">def set_return(self, fid):
    frame = frametable[fid]
    self.idb.set_return(frame)
</t>
<t tx="ekr.20060521134315.318">def get_stack(self, fid, tbid):
    ##print &gt;&gt;sys.__stderr__, "get_stack(%r, %r)" % (fid, tbid)
    frame = frametable[fid]
    if tbid is None:
        tb = None
    else:
        tb = tracebacktable[tbid]
    stack, i = self.idb.get_stack(frame, tb)
    ##print &gt;&gt;sys.__stderr__, "get_stack() -&gt;", stack
    stack = [(wrap_frame(frame), k) for frame, k in stack]
    ##print &gt;&gt;sys.__stderr__, "get_stack() -&gt;", stack
    return stack, i
</t>
<t tx="ekr.20060521134315.319">def run(self, cmd):
    import __main__
    self.idb.run(cmd, __main__.__dict__)
</t>
<t tx="ekr.20060521134315.320">def set_break(self, filename, lineno):
    msg = self.idb.set_break(filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134315.321">def clear_break(self, filename, lineno):
    msg = self.idb.clear_break(filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134315.322">def clear_all_file_breaks(self, filename):
    msg = self.idb.clear_all_file_breaks(filename)
    return msg
</t>
<t tx="ekr.20060521134315.323">#----------called by a FrameProxy----------

def frame_attr(self, fid, name):
    frame = frametable[fid]
    return getattr(frame, name)
</t>
<t tx="ekr.20060521134315.324">def frame_globals(self, fid):
    frame = frametable[fid]
    dict = frame.f_globals
    did = id(dict)
    dicttable[did] = dict
    return did
</t>
<t tx="ekr.20060521134315.325">def frame_locals(self, fid):
    frame = frametable[fid]
    dict = frame.f_locals
    did = id(dict)
    dicttable[did] = dict
    return did
</t>
<t tx="ekr.20060521134315.326">def frame_code(self, fid):
    frame = frametable[fid]
    code = frame.f_code
    cid = id(code)
    codetable[cid] = code
    return cid
</t>
<t tx="ekr.20060521134315.327">#----------called by a CodeProxy----------

def code_name(self, cid):
    code = codetable[cid]
    return code.co_name
</t>
<t tx="ekr.20060521134315.328">def code_filename(self, cid):
    code = codetable[cid]
    return code.co_filename
</t>
<t tx="ekr.20060521134315.329">#----------called by a DictProxy----------

def dict_keys(self, did):
    dict = dicttable[did]
    return dict.keys()
</t>
<t tx="ekr.20060521134315.330">def dict_item(self, did, key):
    dict = dicttable[did]
    value = dict[key]
    value = repr(value)
    return value
</t>
<t tx="ekr.20060521134315.331">def start_debugger(rpchandler, gui_adap_oid):
    """Start the debugger and its RPC link in the Python subprocess

    Start the subprocess side of the split debugger and set up that side of the
    RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
    objects and linking them together.  Register the IdbAdapter with the
    RPCServer to handle RPC requests from the split debugger GUI via the
    IdbProxy.

    """

    gui_proxy = GUIProxy(rpchandler, gui_adap_oid)
    idb = Debugger.Idb(gui_proxy)
    global g_idb ; g_idb = idb ### EKR
    idb_adap = IdbAdapter(idb)
    rpchandler.register(idb_adap_oid, idb_adap)
    return idb_adap_oid
</t>
<t tx="ekr.20060521134315.332">

#=======================================
#
# In the IDLE process:


class FrameProxy:
	@others
</t>
<t tx="ekr.20060521134315.333">def __init__(self, conn, fid):
    self._conn = conn
    self._fid = fid
    self._oid = "idb_adapter"
    self._dictcache = {}
</t>
<t tx="ekr.20060521134315.334">def __getattr__(self, name):
    if name[:1] == "_":
        raise AttributeError, name
    if name == "f_code":
        return self._get_f_code()
    if name == "f_globals":
        return self._get_f_globals()
    if name == "f_locals":
        return self._get_f_locals()
    return self._conn.remotecall(self._oid, "frame_attr",
                                 (self._fid, name), {})
</t>
<t tx="ekr.20060521134315.335">def _get_f_code(self):
    cid = self._conn.remotecall(self._oid, "frame_code", (self._fid,), {})
    return CodeProxy(self._conn, self._oid, cid)
</t>
<t tx="ekr.20060521134315.336">def _get_f_globals(self):
    did = self._conn.remotecall(self._oid, "frame_globals",
                                (self._fid,), {})
    return self._get_dict_proxy(did)
</t>
<t tx="ekr.20060521134315.337">def _get_f_locals(self):
    did = self._conn.remotecall(self._oid, "frame_locals",
                                (self._fid,), {})
    return self._get_dict_proxy(did)
</t>
<t tx="ekr.20060521134315.338">def _get_dict_proxy(self, did):
    if self._dictcache.has_key(did):
        return self._dictcache[did]
    dp = DictProxy(self._conn, self._oid, did)
    self._dictcache[did] = dp
    return dp
</t>
<t tx="ekr.20060521134315.339">

class CodeProxy:
	@others
</t>
<t tx="ekr.20060521134315.340">def __init__(self, conn, oid, cid):
    self._conn = conn
    self._oid = oid
    self._cid = cid
</t>
<t tx="ekr.20060521134315.341">def __getattr__(self, name):
    if name == "co_name":
        return self._conn.remotecall(self._oid, "code_name",
                                     (self._cid,), {})
    if name == "co_filename":
        return self._conn.remotecall(self._oid, "code_filename",
                                     (self._cid,), {})
</t>
<t tx="ekr.20060521134315.342">

class DictProxy:
	@others
</t>
<t tx="ekr.20060521134315.343">def __init__(self, conn, oid, did):
    self._conn = conn
    self._oid = oid
    self._did = did
</t>
<t tx="ekr.20060521134315.344">def keys(self):
    return self._conn.remotecall(self._oid, "dict_keys", (self._did,), {})
</t>
<t tx="ekr.20060521134315.345">def __getitem__(self, key):
    return self._conn.remotecall(self._oid, "dict_item",
                                 (self._did, key), {})
</t>
<t tx="ekr.20060521134315.346">def __getattr__(self, name):
    ##print &gt;&gt;sys.__stderr__, "failed DictProxy.__getattr__:", name
    raise AttributeError, name
</t>
<t tx="ekr.20060521134315.347">

class GUIAdapter:
	@others
</t>
<t tx="ekr.20060521134315.348">def __init__(self, conn, gui):
    self.conn = conn
    self.gui = gui
</t>
<t tx="ekr.20060521134315.349">def interaction(self, message, fid, modified_info):
    ##print "interaction: (%s, %s, %s)" % (message, fid, modified_info)
    frame = FrameProxy(self.conn, fid)
    self.gui.interaction(message, frame, modified_info)
</t>
<t tx="ekr.20060521134315.350">class IdbProxy:
	@others
</t>
<t tx="ekr.20060521134315.351">def __init__(self, conn, shell, oid):
    self.oid = oid
    self.conn = conn
    self.shell = shell
</t>
<t tx="ekr.20060521134315.352">def call(self, methodname, *args, **kwargs):
    ##print "**IdbProxy.call %s %s %s" % (methodname, args, kwargs)
    value = self.conn.remotecall(self.oid, methodname, args, kwargs)
    ##print "**IdbProxy.call %s returns %r" % (methodname, value)
    return value
</t>
<t tx="ekr.20060521134315.353">def run(self, cmd, locals):
    # Ignores locals on purpose!
    seq = self.conn.asyncqueue(self.oid, "run", (cmd,), {})
    self.shell.interp.active_seq = seq
</t>
<t tx="ekr.20060521134315.354">def get_stack(self, frame, tbid):
    # passing frame and traceback IDs, not the objects themselves
    stack, i = self.call("get_stack", frame._fid, tbid)
    stack = [(FrameProxy(self.conn, fid), k) for fid, k in stack]
    return stack, i
</t>
<t tx="ekr.20060521134315.355">def set_continue(self):
    self.call("set_continue")
</t>
<t tx="ekr.20060521134315.356">def set_step(self):
    self.call("set_step")
</t>
<t tx="ekr.20060521134315.357">def set_next(self, frame):
    self.call("set_next", frame._fid)
</t>
<t tx="ekr.20060521134315.358">def set_return(self, frame):
    self.call("set_return", frame._fid)
</t>
<t tx="ekr.20060521134315.359">def set_quit(self):
    self.call("set_quit")
</t>
<t tx="ekr.20060521134315.360">def set_break(self, filename, lineno):
    msg = self.call("set_break", filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134315.361">def clear_break(self, filename, lineno):
    msg = self.call("clear_break", filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134315.362">def clear_all_file_breaks(self, filename):
    msg = self.call("clear_all_file_breaks", filename)
    return msg
</t>
<t tx="ekr.20060521134315.363">def start_remote_debugger(rpcclt, pyshell):
    """Start the subprocess debugger, initialize the debugger GUI and RPC link

    Request the RPCServer start the Python subprocess debugger and link.  Set
    up the Idle side of the split debugger by instantiating the IdbProxy,
    debugger GUI, and debugger GUIAdapter objects and linking them together.

    Register the GUIAdapter with the RPCClient to handle debugger GUI
    interaction requests coming from the subprocess debugger via the GUIProxy.

    The IdbAdapter will pass execution and environment requests coming from the
    Idle debugger GUI to the subprocess debugger via the IdbProxy.

    """
    global idb_adap_oid

    ekr_trace('start_remote_debugger')

    idb_adap_oid = rpcclt.remotecall("exec", "start_the_debugger",\
                                   (gui_adap_oid,), {})
    idb_proxy = IdbProxy(rpcclt, pyshell, idb_adap_oid)
    gui = Debugger.Debugger(pyshell, idb_proxy)
    gui_adap = GUIAdapter(rpcclt, gui)
    rpcclt.register(gui_adap_oid, gui_adap)
    return gui
</t>
<t tx="ekr.20060521134315.364">def close_remote_debugger(rpcclt):
    """Shut down subprocess debugger and Idle side of debugger RPC link

    Request that the RPCServer shut down the subprocess debugger and link.
    Unregister the GUIAdapter, which will cause a GC on the Idle process
    debugger and RPC link objects.  (The second reference to the debugger GUI
    is deleted in PyShell.close_remote_debugger().)

    """
    close_subprocess_debugger(rpcclt)
    rpcclt.unregister(gui_adap_oid)
</t>
<t tx="ekr.20060521134315.365">def close_subprocess_debugger(rpcclt):
    rpcclt.remotecall("exec", "stop_the_debugger", (idb_adap_oid,), {})
</t>
<t tx="ekr.20060521134315.366">def restart_subprocess_debugger(rpcclt):
    idb_adap_oid_ret = rpcclt.remotecall("exec", "start_the_debugger",\
                                         (gui_adap_oid,), {})
    assert idb_adap_oid_ret == idb_adap_oid, 'Idb restarted with different oid'
</t>
<t tx="ekr.20060521134315.368"></t>
<t tx="ekr.20060521134315.369">@first #! /usr/bin/env python

"""
    rpdb2.py

    A remote Python debugger for Python 2.3 and Python 2.4
"""

@language python
@tabwidth -4

TIMEOUT_FIVE_MINUTES = 5 * 60.0

&lt;&lt; copyright &gt;&gt;
&lt;&lt; imports &gt;&gt;

@others

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    &lt;&lt; execute rpdb2.main &gt;&gt;</t>
<t tx="ekr.20060521134315.370">"""

    Copyright (C) 2005 Nir Aides

    This program is free software; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or any later 
    version.

    This program is distributed in the hope that it will be useful, 
    but WITHOUT ANY WARRANTY; without even the implied warranty of 
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along 
    with this program; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    
"""

COPYRIGHT_NOTICE = """Copyright (C) 2005 Nir Aides"""

LICENSE_NOTICE = """
This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2 of the License, or any later 
version.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU General Public License for more details.

A copy of the GPL with the precise terms and conditions for 
copying, distribution and modification follow:
"""

COPY_OF_THE_GPL_LICENSE = """
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. 
This License applies to any program or other work which contains a notice 
placed by the copyright holder saying it may be distributed under the terms 
of this General Public License. The "Program", below, refers to any such 
program or work, and a "work based on the Program" means either the Program 
or any derivative work under copyright law: that is to say, a work containing 
the Program or a portion of it, either verbatim or with modifications and/or 
translated into another language. (Hereinafter, translation is included 
without limitation in the term "modification".) Each licensee is addressed 
as "you".

Activities other than copying, distribution and modification are not covered 
by this License; they are outside its scope. The act of running the Program 
is not restricted, and the output from the Program is covered only if its 
contents constitute a work based on the Program (independent of having been 
made by running the Program). Whether that is true depends on what the 
Program does.

1. 
You may copy and distribute verbatim copies of the Program's source code as 
you receive it, in any medium, provided that you conspicuously and 
appropriately publish on each copy an appropriate copyright notice and 
disclaimer of warranty; keep intact all the notices that refer to this 
License and to the absence of any warranty; and give any other recipients of 
the Program a copy of this License along with the Program.

You may charge a fee for the physical act of transferring a copy, and you 
may at your option offer warranty protection in exchange for a fee.

2. 
You may modify your copy or copies of the Program or any portion of it, thus 
forming a work based on the Program, and copy and distribute such modifications 
or work under the terms of Section 1 above, provided that you also meet all 
of these conditions:

    a) You must cause the modified files to carry prominent notices stating 
    that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in whole 
    or in part contains or is derived from the Program or any part thereof, 
    to be licensed as a whole at no charge to all third parties under the 
    terms of this License.

    c) If the modified program normally reads commands interactively when 
    run, you must cause it, when started running for such interactive use in 
    the most ordinary way, to print or display an announcement including an 
    appropriate copyright notice and a notice that there is no warranty (or 
    else, saying that you provide a warranty) and that users may redistribute 
    the program under these conditions, and telling the user how to view a 
    copy of this License. (Exception: if the Program itself is interactive 
    but does not normally print such an announcement, your work based on the 
    Program is not required to print an announcement.)

These requirements apply to the modified work as a whole. If identifiable 
sections of that work are not derived from the Program, and can be reasonably 
considered independent and separate works in themselves, then this License, 
and its terms, do not apply to those sections when you distribute them as 
separate works. But when you distribute the same sections as part of a whole 
which is a work based on the Program, the distribution of the whole must be 
on the terms of this License, whose permissions for other licensees extend to 
the entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest your 
rights to work written entirely by you; rather, the intent is to exercise the 
right to control the distribution of derivative or collective works based on 
the Program.

In addition, mere aggregation of another work not based on the Program with 
the Program (or with a work based on the Program) on a volume of a storage or 
distribution medium does not bring the other work under the scope of this 
License.

3. You may copy and distribute the Program (or a work based on it, under 
Section 2) in object code or executable form under the terms of Sections 1 
and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable source 
    code, which must be distributed under the terms of Sections 1 and 2 above 
    on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three years, to 
    give any third party, for a charge no more than your cost of physically 
    performing source distribution, a complete machine-readable copy of the 
    corresponding source code, to be distributed under the terms of Sections 
    1 and 2 above on a medium customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer to 
    distribute corresponding source code. (This alternative is allowed only 
    for noncommercial distribution and only if you received the program in 
    object code or executable form with such an offer, in accord with 
    Subsection b above.)

The source code for a work means the preferred form of the work for making 
modifications to it. For an executable work, complete source code means all 
the source code for all modules it contains, plus any associated interface 
definition files, plus the scripts used to control compilation and 
installation of the executable. However, as a special exception, the source 
code distributed need not include anything that is normally distributed (in 
either source or binary form) with the major components (compiler, kernel, 
and so on) of the operating system on which the executable runs, unless that 
component itself accompanies the executable.

If distribution of executable or object code is made by offering access to 
copy from a designated place, then offering equivalent access to copy the 
source code from the same place counts as distribution of the source code, 
even though third parties are not compelled to copy the source along with 
the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as 
expressly provided under this License. Any attempt otherwise to copy, modify, 
sublicense or distribute the Program is void, and will automatically 
terminate your rights under this License. However, parties who have received 
copies, or rights, from you under this License will not have their licenses 
terminated so long as such parties remain in full compliance.

5. You are not required to accept this License, since you have not signed it. 
However, nothing else grants you permission to modify or distribute the 
Program or its derivative works. These actions are prohibited by law if you 
do not accept this License. Therefore, by modifying or distributing the 
Program (or any work based on the Program), you indicate your acceptance of 
this License to do so, and all its terms and conditions for copying, 
distributing or modifying the Program or works based on it.

6. Each time you redistribute the Program (or any work based on the Program), 
the recipient automatically receives a license from the original licensor to 
copy, distribute or modify the Program subject to these terms and conditions. 
You may not impose any further restrictions on the recipients' exercise of 
the rights granted herein. You are not responsible for enforcing compliance 
by third parties to this License.

7. If, as a consequence of a court judgment or allegation of patent 
infringement or for any other reason (not limited to patent issues), 
conditions are imposed on you (whether by court order, agreement or otherwise) 
that contradict the conditions of this License, they do not excuse you from 
the conditions of this License. If you cannot distribute so as to satisfy 
simultaneously your obligations under this License and any other pertinent 
obligations, then as a consequence you may not distribute the Program at all. 
For example, if a patent license would not permit royalty-free redistribution 
of the Program by all those who receive copies directly or indirectly through 
you, then the only way you could satisfy both it and this License would be to 
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under any 
particular circumstance, the balance of the section is intended to apply and 
the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any patents 
or other property right claims or to contest validity of any such claims; 
this section has the sole purpose of protecting the integrity of the free 
software distribution system, which is implemented by public license 
practices. Many people have made generous contributions to the wide range of 
software distributed through that system in reliance on consistent 
application of that system; it is up to the author/donor to decide if he or 
she is willing to distribute software through any other system and a licensee 
cannot impose that choice.

This section is intended to make thoroughly clear what is believed to be a 
consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain 
countries either by patents or by copyrighted interfaces, the original 
copyright holder who places the Program under this License may add an 
explicit geographical distribution limitation excluding those countries, 
so that distribution is permitted only in or among countries not thus 
excluded. In such case, this License incorporates the limitation as if 
written in the body of this License.

9. The Free Software Foundation may publish revised and/or new versions of 
the General Public License from time to time. Such new versions will be 
similar in spirit to the present version, but may differ in detail to 
address new problems or concerns.

Each version is given a distinguishing version number. If the Program 
specifies a version number of this License which applies to it and 
"any later version", you have the option of following the terms and 
conditions either of that version or of any later version published by the 
Free Software Foundation. If the Program does not specify a version number 
of this License, you may choose any version ever published by the 
Free Software Foundation.

10. If you wish to incorporate parts of the Program into other free programs 
whose distribution conditions are different, write to the author to ask for 
permission. For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this. Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR 
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE 
STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE 
PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER 
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGES.

END OF TERMS AND CONDITIONS
"""</t>
<t tx="ekr.20060521134315.371">import SimpleXMLRPCServer 
import SocketServer
import xmlrpclib
import threading
import linecache
import traceback
import compiler
import commands
import __main__
import cPickle
import httplib
import os.path
import socket
import getopt
import string
import thread
import random
import base64
import atexit
import time
import copy
import hmac
import sys
import cmd
import md5
import os

try:
    from Crypto.Cipher import DES
except ImportError:
    pass

try:
    from nt import _getfullpathname
except ImportError:
    pass</t>
<t tx="ekr.20060521134315.372"></t>
<t tx="ekr.20060521134315.373">def start_embedded_debugger(
    pwd, fAllowUnencrypted = False,
    fRemote = False,
    timeout = TIMEOUT_FIVE_MINUTES,
    fDebug = False
):
    
    &lt;&lt; docstring &gt;&gt;

    return __start_embedded_debugger(pwd, fAllowUnencrypted, fRemote, timeout, fDebug)</t>
<t tx="ekr.20060521134315.374">"""
Use 'start_embedded_debugger' to invoke the debugger engine in embedded 
scripts. put the following line as the first line in your script:

import rpdb2; rpdb2.start_embedded_debugger(pwd)

This will cause the script to freeze until a debugger console attaches.

pwd     - The password that governs security of client/server communication
fAllowUnencrypted - Allow unencrypted communications. Communication will
                    be authenticated but encrypted only if possible.
fRemote - Allow debugger consoles on remote machines to connect.
timeout - Seconds to wait for attachment before giving up. If None, 
          never give up. Once the timeout period expires, the debugee will
          resume execution.
fDebug  - debug output.

IMPORTNAT SECURITY NOTE:
USING A HARDCODED PASSWORD MAY BE UNSECURE SINCE ANYONE WITH READ
PERMISSION TO THE SCRIPT WILL BE ABLE TO READ THE PASSWORD AND CONNECT TO 
THE DEBUGGER AND DO WHATEVER THEY WISH VIA THE 'EXEC' DEBUGGER COMMAND.

It is safer to use: start_embedded_debugger_interactive_password()    
"""</t>
<t tx="ekr.20060521134315.375">def start_embedded_debugger_interactive_password (
    fAllowUnencrypted = False, fRemote = False,
    timeout = TIMEOUT_FIVE_MINUTES, fDebug = False,
    stdin = sys.stdin, stdout = sys.stdout
):

    if g_server != None:
        return

    if stdout != None:
        stdout.write('Please type password:')
        
    pwd = stdin.readline().rstrip('\n')
    
    return __start_embedded_debugger(pwd, fAllowUnencrypted, fRemote, timeout, fDebug)</t>
<t tx="ekr.20060521134315.376">def settrace():

    """
    Trace threads created with thread.start_new_thread().
    To trace, call this function from the thread target function.
    
    NOTE: The main thread and any threads created with the threading module are
    automatically traced, and there is no need to invoke this function for them. 
    """

    return __settrace()</t>
<t tx="ekr.20060521134315.377"></t>
<t tx="ekr.20060521134315.378">RPDB_VERSION = "RPDB_2_0_6"
RPDB_COMPATIBILITY_VERSION = "RPDB_2_0_6"

def get_version():
    return RPDB_VERSION</t>
<t tx="ekr.20060521134315.379">def get_interface_compatibility_version():
    return RPDB_COMPATIBILITY_VERSION
</t>
<t tx="ekr.20060521134315.380">class CSimpleSessionManager:
	@others
</t>
<t tx="ekr.20060521134315.381">def __init__(self, fAllowUnencrypted = False):
    self.__sm = CSessionManager(pwd = None, fAllowUnencrypted = fAllowUnencrypted, fRemote = False, host = LOCAL_HOST)

    self.m_fRunning = False
    self.m_termination_lineno = None
    
    event_type_dict = {CEventState: {}}
    self.__sm.register_callback(self.__state_calback, event_type_dict, fSingleUse = False)

    event_type_dict = {CEventExit: {}}
    self.__sm.register_callback(self.__termination_callback, event_type_dict, fSingleUse = False)
</t>
<t tx="ekr.20060521134315.382">def launch(self, fchdir, command_line):
    self.m_fRunning = False
    self.m_termination_lineno = None
    self.__sm.launch(fchdir, command_line)
</t>
<t tx="ekr.20060521134315.383">def request_go(self):
    self.__sm.request_go()
</t>
<t tx="ekr.20060521134315.384">def detach(self):
    self.__sm.detach()
</t>
<t tx="ekr.20060521134315.385">def stop_debuggee(self):
    self.__sm.stop_debuggee()
</t>
<t tx="ekr.20060521134315.386">def get_session_manager(self):
    return self.__sm
</t>
<t tx="ekr.20060521134315.387">def prepare_attach(self):
    pwd = self.__sm.get_password()
        
    si = self.__sm.get_server_info()
    rid = si.m_rid

    if os.name == 'posix':
        create_pwd_file(rid, pwd)
        pwd = None

    return (rid, pwd)
</t>
<t tx="ekr.20060521134315.388">#
# Override these callback to react to the related events.
#

def unhandled_exception_callback(self):
    print 'unhandled_exception_callback'
    self.request_go()
</t>
<t tx="ekr.20060521134315.389">def script_about_to_terminate_callback(self):
    print 'script_about_to_terminate_callback'
    self.request_go()
</t>
<t tx="ekr.20060521134315.390">def script_terminated_callback(self):
    print 'script_terminated_callback'
    self.detach()
</t>
<t tx="ekr.20060521134315.391"></t>
<t tx="ekr.20060521134315.392">def __state_calback(self, event):        
    if event.m_state != STATE_BROKEN:
        return
    
    if not self.m_fRunning:
        self.m_fRunning = True
        self.request_go()
        return
        
    sl = self.__sm.get_stack(tid_list = [], fAll = False)
    if len(sl) == 0:
        self.request_go()
        return

    st = sl[0]
    s = st.get(DICT_KEY_STACK, [])
    if len(s) == 0:
        self.request_go()
        return
        
    e = s[-1]
    
    lineno = e[1]
    path = e[0]
    filename = os.path.basename(e[0])

    if filename != DEBUGGER_FILENAME:
        self.unhandled_exception_callback()
        return

    if lineno != self.__get_termination_lineno(path):
        self.unhandled_exception_callback()
        return
        
    self.script_about_to_terminate_callback()
</t>
<t tx="ekr.20060521134315.393">def __termination_callback(self, event):
    self.script_terminated_callback()
</t>
<t tx="ekr.20060521134315.394">def __get_termination_lineno(self, path):
    if self.m_termination_lineno != None:
        return self.m_termination_lineno
        
    f = open(path, 'rb')
    l = f.read()
    f.close()
    _l = l.strip()
    _s = _l.split('\n')

    self.m_termination_lineno = len(_s)
    return self.m_termination_lineno
</t>
<t tx="ekr.20060521134315.395">class CSessionManager:
    """
    Interface to the session manager.
    This is the interface through which the debugger controls and communicates
    with the debuggee.
    """
	@others
</t>
<t tx="ekr.20060521134315.396">def __init__(self, pwd, fAllowUnencrypted, fRemote, host):
    self.__smi = CSessionManagerInternal(pwd, fAllowUnencrypted, fRemote, host)
</t>
<t tx="ekr.20060521134315.397">def report_exception(self, type, value, tb):
    return self.__smi.report_exception(type, value, tb)
</t>
<t tx="ekr.20060521134315.398">def set_printer(self, printer):
    return self.__smi.set_printer(printer)
</t>
<t tx="ekr.20060521134315.399">def register_callback(self, callback, event_type_dict, fSingleUse):
    return self.__smi.register_callback(callback, event_type_dict, fSingleUse)
</t>
<t tx="ekr.20060521134315.400">def remove_callback(self, callback):
    return self.__smi.remove_callback(callback)
</t>
<t tx="ekr.20060521134315.401">def refresh(self):
    return self.__smi.refresh()
</t>
<t tx="ekr.20060521134315.402">def launch_nothrow(self, fchdir, command_line):
    return self.__smi.launch_nothrow(fchdir, command_line)
</t>
<t tx="ekr.20060521134315.403">def launch(self, fchdir, command_line):
    return self.__smi.launch(fchdir, command_line)
</t>
<t tx="ekr.20060521134315.404">def attach_nothrow(self, key):
    return self.__smi.attach_nothrow(key)
</t>
<t tx="ekr.20060521134315.405">def attach(self, key, name = None):
    return self.__smi.attach(key, name)
</t>
<t tx="ekr.20060521134315.406">def detach(self):
    return self.__smi.detach()
</t>
<t tx="ekr.20060521134315.407">def request_break(self):
    return self.__smi.request_break()
</t>
<t tx="ekr.20060521134315.408">def request_go(self):
    return self.__smi.request_go()
</t>
<t tx="ekr.20060521134315.409">def request_go_breakpoint(self, filename, scope, lineno):
    return self.__smi.request_go_breakpoint(filename, scope, lineno)
</t>
<t tx="ekr.20060521134315.410">def request_step(self):
    return self.__smi.request_step()
</t>
<t tx="ekr.20060521134315.411">def request_next(self):
    return self.__smi.request_next()
</t>
<t tx="ekr.20060521134315.412">def request_return(self):
    return self.__smi.request_return()
</t>
<t tx="ekr.20060521134315.413">def request_jump(self, lineno):
    return self.__smi.request_jump(lineno)
</t>
<t tx="ekr.20060521134315.414">def set_breakpoint(self, filename, scope, lineno, fEnabled, expr):
    return self.__smi.set_breakpoint(filename, scope, lineno, fEnabled, expr)
</t>
<t tx="ekr.20060521134315.415">def disable_breakpoint(self, id_list, fAll):
    return self.__smi.disable_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.416">def enable_breakpoint(self, id_list, fAll):
    return self.__smi.enable_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.417">def delete_breakpoint(self, id_list, fAll):
    return self.__smi.delete_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.418">def get_breakpoints(self):
    return self.__smi.get_breakpoints()
</t>
<t tx="ekr.20060521134315.419">def save_breakpoints(self, _filename = ''):        
    return self.__smi.save_breakpoints()
</t>
<t tx="ekr.20060521134315.420">def load_breakpoints(self, _filename = ''):
    return self.__smi.load_breakpoints()
</t>
<t tx="ekr.20060521134315.421">def get_stack(self, tid_list, fAll):   
    return self.__smi.get_stack(tid_list, fAll)
</t>
<t tx="ekr.20060521134315.422">def get_source_file(self, filename, lineno, nlines): 
    return self.__smi.get_source_file(filename, lineno, nlines)
</t>
<t tx="ekr.20060521134315.423">def get_source_lines(self, nlines, fAll): 
    return self.__smi.get_source_lines(nlines, fAll)
</t>
<t tx="ekr.20060521134315.424">def set_frame_index(self, frame_index):
    return self.__smi.set_frame_index(frame_index)
</t>
<t tx="ekr.20060521134315.425">def get_frame_index(self):
    return self.__smi.get_frame_index()
</t>
<t tx="ekr.20060521134315.426">def set_analyze(self, fAnalyze):
    return self.__smi.set_analyze(fAnalyze)
</t>
<t tx="ekr.20060521134315.427">def set_host(self, host):
    return self.__smi.set_host(host)
</t>
<t tx="ekr.20060521134315.428">def get_host(self):
    return self.__smi.get_host()
</t>
<t tx="ekr.20060521134315.429">def calc_server_list(self):
    return self.__smi.calc_server_list()
</t>
<t tx="ekr.20060521134315.430">def get_server_info(self):    
    return self.__smi.get_server_info()
</t>
<t tx="ekr.20060521134315.431">def get_last_debuggee_name_safe(self):
    return self.__smi.get_last_debuggee_name_safe()
</t>
<t tx="ekr.20060521134315.432">def get_namespace(self, nl, fFilter):
    return self.__smi.get_namespace(nl, fFilter)
</t>
<t tx="ekr.20060521134315.433">def evaluate(self, expr):
    return self.__smi.evaluate(expr)
</t>
<t tx="ekr.20060521134315.434">def execute(self, suite):
    return self.__smi.execute(suite)
</t>
<t tx="ekr.20060521134315.435">def get_state(self):
    return self.__smi.get_state()
</t>
<t tx="ekr.20060521134315.436">def get_thread_list(self):
    return self.__smi.get_thread_list()
</t>
<t tx="ekr.20060521134315.437">def set_thread(self, tid):
    return self.__smi.set_thread(tid)
</t>
<t tx="ekr.20060521134315.438">def set_password(self, pwd):
    return self.__smi.set_password(pwd)
</t>
<t tx="ekr.20060521134315.439">def get_password(self):
    return self.__smi.get_password()
</t>
<t tx="ekr.20060521134315.440">def get_encryption(self):    
    return self.__smi.get_encryption()
</t>
<t tx="ekr.20060521134315.441">def set_remote(self, fRemote):
    return self.__smi.set_remote(fRemote)
</t>
<t tx="ekr.20060521134315.442">def get_remote(self):
    return self.__smi.get_remote()
</t>
<t tx="ekr.20060521134315.443">def stop_debuggee(self):
    return self.__smi.stop_debuggee()
</t>
<t tx="ekr.20060521134315.444">class CConsole:
    """
    Interface to a debugger console.
    """
	@others
</t>
<t tx="ekr.20060521134315.445">def __init__(self, session_manager, stdin = None, stdout = None, fSplit = False):
    self.m_ci = CConsoleInternal(session_manager, stdin, stdout, fSplit)
</t>
<t tx="ekr.20060521134315.446">def start(self):
    return self.m_ci.start()
</t>
<t tx="ekr.20060521134315.447">def join(self):
    return self.m_ci.join()
</t>
<t tx="ekr.20060521134315.448">def set_filename(self, filename):
    return self.m_ci.set_filename(filename)
</t>
<t tx="ekr.20060521134315.449"></t>
<t tx="ekr.20060521134315.450">class CException(Exception):
	@others
</t>
<t tx="ekr.20060521134315.451">def __init__(self, *args):
    Exception.__init__(self, *args)
</t>
<t tx="ekr.20060521134315.452">

    
class InvalidScopeName(CException):
    """
    Invalid scope name.
    This exception may be thrown when a request was made to set a breakpoint
    to an unknown scope.
    """
</t>
<t tx="ekr.20060521134315.453">class BadArgument(CException):
    """
    Bad Argument.
    """
</t>
<t tx="ekr.20060521134315.454">class ThreadNotFound(CException):
    """
    Thread not found.
    """
</t>
<t tx="ekr.20060521134315.455">class NoThreads(CException):
    """
    No Threads.
    """
</t>
<t tx="ekr.20060521134315.456">class ThreadDone(CException):
    """
    Thread Done.
    """
</t>
<t tx="ekr.20060521134315.457">class DebuggerNotBroken(CException):
    """
    Debugger is not broken.
    This exception is thrown when an operation that can only be performed
    while the debuggee is broken, is requested while the debuggee is running.
    """
</t>
<t tx="ekr.20060521134315.458">class InvalidFrame(CException):
    """
    Invalid Frame.
    This exception is raised if an operation is requested on a stack frame
    that does not exist.
    """
</t>
<t tx="ekr.20060521134315.459">class NoExceptionFound(CException):
    """
    No Exception Found.
    This exception is raised when exception information is requested, but no
    exception is found, or has been thrown.
    """
</t>
<t tx="ekr.20060521134315.460">class CConnectionException(CException):
	@others
</t>
<t tx="ekr.20060521134315.461">def __init__(self, *args):
    CException.__init__(self, *args)
</t>
<t tx="ekr.20060521134315.462">


class BadVersion(CConnectionException):
    """Bad Version."""
	@others
</t>
<t tx="ekr.20060521134315.463">def __init__(self, version):
    CConnectionException.__init__(self)

    self.m_version = version
</t>
<t tx="ekr.20060521134315.464">def __str__(self):
    return repr(self.m_version)
</t>
<t tx="ekr.20060521134315.465">

    
class UnexpectedData(CConnectionException):
    """Unexpected data."""
</t>
<t tx="ekr.20060521134315.466">class AlreadyAttached(CConnectionException):
    """Already Attached."""
</t>
<t tx="ekr.20060521134315.467">class NotAttached(CConnectionException):
    """Not Attached."""
</t>
<t tx="ekr.20060521134315.468">class SpawnUnsupported(CConnectionException):
    """Spawn Unsupported."""
</t>
<t tx="ekr.20060521134315.469">class UnknownServer(CConnectionException):
    """Unknown Server."""
</t>
<t tx="ekr.20060521134315.470">class CSecurityException(CConnectionException):
	@others
</t>
<t tx="ekr.20060521134315.471">def __init__(self, *args):
    CConnectionException.__init__(self, *args)
</t>
<t tx="ekr.20060521134315.472">

    
class UnsetPassword(CSecurityException):
    """Unset Password."""
</t>
<t tx="ekr.20060521134315.473">class EncryptionNotSupported(CSecurityException):
    """Encryption Not Supported."""
</t>
<t tx="ekr.20060521134315.474">class EncryptionExpected(CSecurityException):
    """Encryption Expected."""
</t>
<t tx="ekr.20060521134315.475">class DecryptionFailure(CSecurityException):
    """Decryption Failure."""
</t>
<t tx="ekr.20060521134315.476">class AuthenticationBadData(CSecurityException):
    """Authentication Bad Data."""
</t>
<t tx="ekr.20060521134315.477">class AuthenticationFailure(CSecurityException):
    """Authentication Failure."""
</t>
<t tx="ekr.20060521134315.478">class AuthenticationBadIndex(CSecurityException):
    """Authentication Bad Index."""
	@others
</t>
<t tx="ekr.20060521134315.479">def __init__(self, max_index, anchor):
    CSecurityException.__init__(self)

    self.m_max_index = max_index
    self.m_anchor = anchor
</t>
<t tx="ekr.20060521134315.480">def __str__(self):
    return repr((self.m_max_index, self.m_anchor))
</t>
<t tx="ekr.20060521134315.481"># map between OS type and relvant command to initiate a new OS console.
# entries for other OSs can be added here. 
# '%s' serves as a place holder.
#
osSpawn = {
    'nt': 'start "rpdb2 - Version ' + get_version() + ' - Debugee Console" cmd /c %s %s', 
    'nt_debug': 'start "rpdb2 - Version ' + get_version() + ' - Debugee Console" cmd /k %s %s', 
    'posix': '%s -e %s %s &amp;', 
    'mac': '%s %s',
    'screen': 'screen -t debugger_console python %s'
}

RPDBTERM = 'RPDBTERM'
COLORTERM = 'COLORTERM'
TERM = 'TERM'
KDE_PREFIX = 'KDE'
GNOME_PREFIX = 'GNOME'

KDE_DEFAULT_TERM_QUERY = "kreadconfig --file kdeglobals --group General --key TerminalApplication --default konsole"
GNOME_DEFAULT_TERM = 'gnome-terminal'
XTERM = 'xterm'
RXVT = 'rxvt'

RPDB_SETTINGS_FOLDER = '.rpdb2_settings'

IDLE_MAX_RATE = 2.0
PING_TIMEOUT = 4.0

WAIT_FOR_BREAK_TIMEOUT = 1.0

STARTUP_TIMEOUT = 3.0
STARTUP_RETRIES = 3

LOCAL_HOST = "localhost"
SERVER_PORT_RANGE_START = 51000
SERVER_PORT_RANGE_LENGTH = 20

ERROR_SOCKET_ADDRESS_IN_USE_WIN = 10048
ERROR_SOCKET_ADDRESS_IN_USE_UNIX = 98
ERROR_SOCKET_ADDRESS_IN_USE_MAC = 48

SOURCE_EVENT_CALL = 'C'
SOURCE_EVENT_LINE = 'L'
SOURCE_EVENT_RETURN = 'R'
SOURCE_EVENT_EXCEPTION = 'E'
SOURCE_STATE_UNBROKEN = '*'
SOURCE_BP_ENABLED = 'B'
SOURCE_BP_DISABLED = 'D'

SYMBOL_MARKER = '&gt;'
SYMBOL_ALL = '*'
SOURCE_MORE = '+'
SOURCE_LESS = '-'
SOURCE_ENTIRE_FILE = '^'
CONSOLE_PRINTER = '*** '
CONSOLE_WRAP_INDEX = 78
CONSOLE_PROMPT = '\n&gt; '
CONSOLE_PROMPT_ANALYZE = '\nAnalayze&gt; '
CONSOLE_INTRO = ("""RPDB - The Remote Python Debugger, version %s,
Copyright (C) 2005 Nir Aides.
Type "help", "copyright", "license" for more information.""" % (RPDB_VERSION))

PRINT_NOTICE_PROMPT = "Hit Return for more, or q (and Return) to quit:"
PRINT_NOTICE_LINES_PER_SECTION = 20

STR_NO_THREADS = "Operation failed since no traced threads were found."
STR_AUTOMATIC_LAUNCH_UNKNOWN = "RPDB doesn't know how to launch a new terminal on this platform. Please start the debuggee manually with the -d flag on a seperate console and then use the 'attach' command to attach to it."
STR_STARTUP_NOTICE = "Attaching to debuggee..."
STR_SPAWN_UNSUPPORTED = "Launch command supported on 'posix' and 'nt', systems only. Please start the debuggee manually with the -d flag on a seperate console and then use the 'attach' command to attach to it."
STR_STARTUP_SPAWN_NOTICE = "Spawning debuggee..."
STR_KILL_NOTICE = "Stopping debuggee..."
STR_STARTUP_FAILURE = "Debugee failed to start in a timely manner."
STR_OUTPUT_WARNING = "Textual output will be done at the debugee."
STR_ANALYZE_GLOBALS_WARNING = "In analyze mode the globals and locals dictionaries are read only."
STR_GLOBALS_WARNING = "Any changes made to the globals dictionay at this frame will be discarded."
STR_BREAKPOINTS_LOADED = "Breakpoints were loaded."
STR_BREAKPOINTS_SAVED = "Breakpoints were saved."
STR_BREAKPOINTS_NOT_SAVED = "Breakpoints were not saved."
STR_BREAKPOINTS_FILE_NOT_FOUND = "Breakpoints file was not found." 
STR_BAD_FILENAME = "Bad File Name."
STR_SOME_BREAKPOINTS_NOT_LOADED = "Some breakpoints were not loaded, because of an error."
STR_BAD_EXPRESSION = "Bad expression '%s'."
STR_FILE_NOT_FOUND = "File '%s' not found."
STR_EXCEPTION_NOT_FOUND = "No exception was found."
STR_SCOPE_NOT_FOUND = "Scope '%s' not found."
STR_NO_SUCH_BREAKPOINT = "Breakpoint not found."
STR_THREAD_NOT_FOUND = "Thread was not found."
STR_NO_THREADS_FOUND = "No threads were found."
STR_THREAD_NOT_BROKEN = "Thread is not broken."
STR_THREAD_FOCUS_SET = "Focus was set to chosen thread."
STR_ILEGAL_ANALYZE_MODE_ARG = "Argument is not allowed in analyze mode. Type 'help analyze' for more info."
STR_ILEGAL_ANALYZE_MODE_CMD = "Command is not allowed in analyze mode. Type 'help analyze' for more info."
STR_ANALYZE_MODE_TOGGLE = "Analyze mode was set to %s."
STR_BAD_ARGUMENT = "Bad Argument."
STR_DEBUGGEE_TERMINATED = "Debuggee has terminated."
STR_DEBUGGEE_NOT_BROKEN = "Debuggee has to be broken, to complete this command."
STR_DEBUGGER_HAS_BROKEN = "Debuggee has broken (waiting further commands)."
STR_ALREADY_ATTACHED = "Already attached. Detach from debuggee and try again."
STR_NOT_ATTACHED = "Not attached to any script. Attach to a script and try again."
STR_COMMUNICATION_FAILURE = "Failed to communicate with debugged script."
STR_BAD_VERSION = "A debuggee was found that uses incompatible version (%s) of RPDB2."
STR_BAD_VERSION2 = "While attempting to find the specified debuggee at least one debuggee was found that uses incompatible version of RPDB2."
STR_UNEXPECTED_DATA = "Unexpected data received."
STR_ACCESS_DENIED = "While attempting to find debuggee, at least one debuggee denied connection because of mismatched passwords. Please verify your password."
STR_ACCESS_DENIED2 = "Communication is denied because of un-matching passwords."
STR_ENCRYPTION_EXPECTED = "While attempting to find debuggee, at least one debuggee denied connection since it accepts encrypted connections only."
STR_ENCRYPTION_EXPECTED2 = "Debuggee will only talk over an encrypted channel."
STR_DECRYPTION_FAILURE = "Bad packet was received by the debuggee."
STR_DEBUGGEE_NO_ENCRYPTION = "Debuggee does not support encrypted mode. Either install the python-crypto package on the debuggee machine or allow unencrypted connections."
STR_RANDOM_PASSWORD = "Password has been set to a random password."
STR_PASSWORD_INPUT = "Please type a password:"
STR_PASSWORD_CONFIRM = "Password has been set."
STR_PASSWORD_NOT_SUPPORTED = "The --pwd flag is only supported on NT systems."
STR_PASSWORD_MUST_BE_SET = "A password should be set to secure debugger client-server communication."
STR_BAD_DATA = "Bad data received from debuggee."
STR_BAD_FILE_DATA = "Bad data received from file."
STR_ATTACH_FAILED = "Failed to attach"
STR_ATTACH_FAILED_NAME = "Failed to attach to '%s'."
STR_ATTACH_CRYPTO_MODE = "Debug Channel is%s encrypted."
STR_ATTACH_CRYPTO_MODE_NOT = "NOT"
STR_ATTACH_SUCCEEDED = "Successfully attached to '%s'."
STR_ATTEMPTING_TO_DETACH = "Detaching from script..."
STR_DETACH_SUCCEEDED = "Detached from script."
STR_DEBUGGEE_UNKNOWN = "Failed to find script."
STR_MULTIPLE_DEBUGGEES = "WARNING: There is more than one debuggee '%s'."
STR_HOST_UNKNOWN = "Failed to find '%s'"
STR_SOURCE_NOT_FOUND = "Failed to get source from debuggee."
STR_SCRIPTS_CONNECTING = "Connecting to '%s'..."
STR_SCRIPTS_NO_SCRIPTS = "No scripts to debug on '%s'"
STR_SCRIPTS_TO_DEBUG = """Scripts to debug on '%s':

   pid    name
--------------------------"""
STR_STACK_TRACE = """Stack trace for thread %d:

   Frame  File Name                     Line  Function                 
------------------------------------------------------------------------------""" 
STR_SOURCE_LINES = """Source lines for thread %d from file '%s':
""" 
STR_ACTIVE_THREADS = """List of active threads known to the debugger:

    No    Tid  State                 
-------------------------------""" 
STR_BREAKPOINTS_LIST = """List of breakpoints:

 Id  State     Filename          Line  Scope                Condition
-----------------------------------------------------------------------------""" 

STR_ENCRYPTION_SUPPORT_ERROR = "Encryption is not supported since the python-crypto package was not found. Either install the python-crypto package or allow unencrypted connections with the '-t' command line flag."
STR_PASSWORD_NOT_SET = 'Password is not set.'
STR_PASSWORD_SET = 'Password is set to: "%s"'
STR_ENCRYPT_MODE = 'Force encryption mode: %s'
STR_REMOTE_MODE = 'Allow remote machines mode: %s'

ENCRYPTION_ENABLED = 'encrypted'
ENCRYPTION_DISABLED = 'plain-text'

ENCRYPTION_PREFIX = 'encrypted'

STATE_ENABLED = 'enabled'
STATE_DISABLED = 'disabled'

BREAKPOINTS_FILE_EXT = '.bpl'
PYTHON_FILE_EXTENSION = '.py'
MODULE_SCOPE = '?'
SCOPE_SEP = '.'

BP_FILENAME_SEP = ':'
BP_EVAL_SEP = ','

DEBUGGER_FILENAME = 'rpdb2.py'
THREADING_FILENAME = 'threading.py'

STATE_BROKEN = 'broken'
STATE_RUNNING = 'running'

STATE_ANALYZE = 'analyze'
STATE_DETACHED = 'detached'
STATE_DETACHING = 'detaching'
STATE_SPAWNING = 'spawning'
STATE_ATTACHING = 'attaching'

DEFAULT_NUMBER_OF_LINES = 15

DICT_KEY_TID = 'tid'
DICT_KEY_STACK = 'stack'
DICT_KEY_CODE_LIST = 'code_list'
DICT_KEY_CURRENT_TID = 'current tid'
DICT_KEY_BROKEN = 'broken'
DICT_KEY_BREAKPOINTS = 'breakpoints'
DICT_KEY_LINES = 'lines'
DICT_KEY_FILENAME = 'filename'
DICT_KEY_FIRST_LINENO = 'first_lineno'
DICT_KEY_FRAME_LINENO = 'frame_lineno'
DICT_KEY_EVENT = 'event'
DICT_KEY_EXPR = 'expr'
DICT_KEY_NAME = 'name'
DICT_KEY_REPR = 'repr'
DICT_KEY_TYPE = 'type'
DICT_KEY_SUBNODES = 'subnodes'
DICT_KEY_N_SUBNODES = 'n_subnodes'
DICT_KEY_ERROR = 'error'

RPDB_EXEC_INFO = 'rpdb_exception_info'

MODE_ON = 'ON'
MODE_OFF = 'OFF'

MAX_EVENT_LIST_LENGTH = 1000

EVENT_EXCLUDE = 'exclude'
EVENT_INCLUDE = 'include'

INDEX_TABLE_SIZE = 100

DISPACHER_METHOD = 'dispatcher_method'

BASIC_TYPES_LIST = ['str', 'unicode', 'int', 'long', 'float', 'bool', 'NoneType']

XML_DATA = """&lt;?xml version='1.0'?&gt;
&lt;methodCall&gt;
&lt;methodName&gt;dispatcher_method&lt;/methodName&gt;
&lt;params&gt;
&lt;param&gt;
&lt;value&gt;&lt;string&gt;RPDB_02_00_04&lt;/string&gt;&lt;/value&gt;
&lt;/param&gt;
&lt;/params&gt;
&lt;/methodCall&gt;"""

N_WORK_QUEUE_THREADS = 15


g_server_lock = threading.RLock()
g_server = None
g_debugger = None

g_fDebug = False
g_fScreen = False

g_traceback_lock = threading.RLock()

g_blender_text = {}

</t>
<t tx="ekr.20060521134315.482"></t>
<t tx="ekr.20060521134315.483">def safe_repr(x):
    
    try:
        y = repr(x)
        return y
    except: pass

    try:
        y = str(x)
        return y
    except: pass

    return 'N/A'
</t>
<t tx="ekr.20060521134315.484">def safe_repr_limited(x):

    y = safe_repr(x)[0:128]

    if len(y) == 128:
        y += '...'

    return y
</t>
<t tx="ekr.20060521134315.485">def print_debug():

    if g_fDebug == True:
        (t, v, b) = sys.exc_info()

        try:
            g_traceback_lock.acquire()
            traceback.print_exception(t, v, b, file = sys.stderr)
            
        finally:    
            g_traceback_lock.release()</t>
<t tx="ekr.20060521134315.486">def split_command_line_path_filename_args(command_line):
    command_line = command_line.strip()
    if len(command_line) == 0:
        return ('', '', '')

    if os.path.isfile(command_line):
        (_path, _filename) = split_path(command_line)
        return (_path, _filename, '')
        
    if command_line[0] in ['"', "'"]:
        _command_line = command_line[1:]
        i = _command_line.find(command_line[0])
        if i == -1:
            (_path, filename) = split_path(_command_line)
            return (_path, filename, '')
        else:
            (_path, filename) = split_path(_command_line[: i])
            args = _command_line[i + 1:].strip()
            return (_path, filename, args)
    else:
        i = command_line.find(' ')
        if i == -1:
            (_path, filename) = split_path(command_line)
            return (_path, filename, '')
        else:
            args = command_line[i + 1:].strip()
            (_path, filename) = split_path(command_line[: i])
            return (_path, filename, args)
</t>
<t tx="ekr.20060521134315.487">def split_path(path):

    (_path, filename) = os.path.split(path)

    if (
        _path[-1:] not in [os.path.sep, os.path.altsep]) and
        (path[len(_path): len(_path) + 1] in [os.path.sep, os.path.altsep]
    ):
        _path = _path + path[len(_path): len(_path) + 1]
        
    return (_path, filename)</t>
<t tx="ekr.20060521134315.488">def my_abspath(path):

    if path[:1] == '&lt;':
        return path

    if os.name == 'nt':
        return my_abspath1(path)

    return  os.path.abspath(path)   
</t>
<t tx="ekr.20060521134315.489">def my_abspath1(path):
    
    if path:
        try:
            path = _getfullpathname(path)
        except WindowsError:
            pass
    else:
        path = os.getcwd()
        
    np = os.path.normpath(path)

    if (len(np) &gt;= 2) and (np[1:2] == ':'):
        np = np[:1].upper() + np[1:]

    return np    

</t>
<t tx="ekr.20060521134315.490">def IsPythonSourceFile(filename):

    return filename.endswith(PYTHON_FILE_EXTENSION)
</t>
<t tx="ekr.20060521134315.491">def FindFile(filename, sources_paths = [], fModules = False, fAllowAnyExt = True):
    """ 
    Expand filname to explicit path.   
    Find file looks in the following directories in this order:
    1. full path (if exists).
    2. sources_paths.
    2. current path.
    3. PYTHONPATH
    4. PATH
    """

    if filename[:1] + filename[-1:] in ['""', "''"]:
        filename = filename[1:-1]

    if fModules:
        _filename = winlower(filename)
        
        _fn = _filename.replace('\\', '.').replace('/', '.')
        for k, m in sys.modules.items():
            if _fn.endswith(winlower(k)):
                _filename = CalcScriptName(m.__file__, fAllowAnyExt = True)
                abs_path = my_abspath(_filename)
                if os.path.isfile(abs_path):
                    return abs_path
                
    if fAllowAnyExt:
        try:
            abs_path = FindFile(filename, sources_paths, fModules, fAllowAnyExt = False)
            return abs_path
        except IOError:
            pass

    _filename = CalcScriptName(filename, fAllowAnyExt)
        
    if os.path.dirname(_filename) != '':
        abs_path = my_abspath(_filename)
        if os.path.isfile(abs_path):
            return abs_path

        raise IOError

    _basename = os.path.basename(_filename)
    cwd = os.getcwd()
    path = os.environ['PATH']
    paths = sources_paths + [cwd] + sys.path + path.split(os.pathsep)
    norm_filename = os.path.normpath(_filename)
    
    for p in paths:
        f = os.path.join(p, _basename)
        if not os.path.isfile(f):
            continue

        norm_f = os.path.normpath(f)
        if norm_f.endswith(norm_filename):
            abs_path = my_abspath(f)
            return abs_path

    raise IOError
</t>
<t tx="ekr.20060521134315.492">def IsFileInPath(filename):

    if filename == '':
        return False
        
    try:
        FindFile(filename)
        return True
        
    except IOError:
        return False
</t>
<t tx="ekr.20060521134315.493">def IsPrefixInEnviron(str):
    
    for e in os.environ.keys():
        if e.startswith(str):
            return True

    return False

</t>
<t tx="ekr.20060521134315.494">def CalcTerminalCommand():
    if RPDBTERM in os.environ:
        term = os.environ[RPDBTERM]
        if IsFileInPath(term):
            return term

    if COLORTERM in os.environ:
        term = os.environ[COLORTERM]
        if IsFileInPath(term):
            return term

    if IsPrefixInEnviron(KDE_PREFIX):
        (s, term) = commands.getstatusoutput(KDE_DEFAULT_TERM_QUERY)
        if (s == 0) and IsFileInPath(term):
            return term
            
    elif IsPrefixInEnviron(GNOME_PREFIX):
        if IsFileInPath(GNOME_DEFAULT_TERM):
            return GNOME_DEFAULT_TERM
        
    if TERM in os.environ:
        term = os.environ[TERM]
        if IsFileInPath(term):
            return term

    if IsFileInPath(XTERM):
        return XTERM

    if IsFileInPath(RXVT):
        return RXVT

    raise SpawnUnsupported    
</t>
<t tx="ekr.20060521134315.495">def winlower(path):
    if os.name == 'nt':
        return path.lower()

    return path
</t>
<t tx="ekr.20060521134315.496">def is_blender_file(filename):
    if not 'Blender.Text' in sys.modules:
        return False
        
    _filename = os.path.basename(filename)

    try:
        sys.modules['Blender.Text'].get(_filename)
        return True

    except NameError:
        f = winlower(_filename)
        tlist = sys.modules['Blender.Text'].get()
        for t in tlist:
            n = winlower(t.getName())
            if n == f:
                return True
            
        return False
</t>
<t tx="ekr.20060521134315.497">def get_blender_source(filename):
    _filename = os.path.basename(filename)

    lines = g_blender_text.get(_filename, None)
    if lines != None:
        return lines
        
    f = winlower(_filename)
    lines = g_blender_text.get(f, None)
    if lines != None:
        return lines

    try:
        t = sys.modules['Blender.Text'].get(_filename)
        lines = t.asLines()
        g_blender_text[_filename] = lines
        return lines
        
    except NameError:
        f = winlower(_filename)
        tlist = sys.modules['Blender.Text'].get()

        for _t in tlist:
            n = winlower(_t.getName())
            if n == f:
                t = _t
                break
        
        lines = t.asLines()
        g_blender_text[f] = lines
        return lines
</t>
<t tx="ekr.20060521134315.498">def get_source_line(filename, lineno, fBlender):
    if fBlender:
        lines = get_blender_source(filename)

        try:
            line = lines[lineno - 1] + '\n'
            return line
            
        except IndexError:
            return '' 

    line = linecache.getline(filename, lineno) 
    return line
</t>
<t tx="ekr.20060521134315.499">def CalcModuleName(filename):
    _basename = os.path.basename(filename)
    
    if _basename[:-1].endswith(PYTHON_FILE_EXTENSION):
        module_name = _basename[:-4]
    else:    
        module_name = _basename.rstrip(PYTHON_FILE_EXTENSION)
        
    return module_name
</t>
<t tx="ekr.20060521134315.500">def CalcScriptName(filename, fAllowAnyExt = True):
    if filename.endswith(PYTHON_FILE_EXTENSION):
        return filename
        
    if filename[:-1].endswith(PYTHON_FILE_EXTENSION):
        scriptname = filename[:-1]
        return scriptname

    if fAllowAnyExt:
        return filename

    scriptname = filename + PYTHON_FILE_EXTENSION
        
    return scriptname
</t>
<t tx="ekr.20060521134315.501">def _getpid():
    try:
        return os.getpid()
    except:
        return -1
</t>
<t tx="ekr.20060521134315.502">def calcURL(host, port):
    url = "http://" + str(host) + ":" + str(port)
    return url
</t>
<t tx="ekr.20060521134315.503">def GetSocketError(e):
    if (type(e.args) != tuple) or (len(e.args) == 0):
        return -1

    return e.args[0]
</t>
<t tx="ekr.20060521134315.504">def ControlRate(t_last_call, max_rate):
    """
    Use this function to limit the rate of an operation.
    If called more often than max_rate allows, it will sleep a little.
    """
    p = 1.0 / max_rate
    t_current = time.time()
    dt = t_current - t_last_call

    if dt &lt; p:
        time.sleep(p - dt)

    return t_current
</t>
<t tx="ekr.20060521134315.505">def generate_rid():
    return repr(random.randint(1000000, 9999999))
</t>
<t tx="ekr.20060521134315.506">def generate_random_char(str):
    if str == '':
        return ''
        
    i = random.randint(0, len(str) - 1)
    return str[i]
</t>
<t tx="ekr.20060521134315.507">def generate_random_password():
    s = 'abdefghijmnpqrt' + 'ABDEFGHJLMNQRTY'
    ds = '2346789' + s
        
    pwd = generate_random_char(s)

    for i in range(0, 7):
        pwd += generate_random_char(ds)

    return pwd    
</t>
<t tx="ekr.20060521134315.508">def is_encryption_supported():
    return 'DES' in globals()
</t>
<t tx="ekr.20060521134315.509">def calc_suffix(str, n):
    if len(str) &lt;= n:
        return str

    return '...' + str[-(n - 3):]
</t>
<t tx="ekr.20060521134315.510">def calc_prefix(str, n):
    if len(str) &lt;= n:
        return str

    return str[: (n - 3)] + '...'
</t>
<t tx="ekr.20060521134315.511">def create_rpdb_settings_folder():
    if os.name != 'posix':
        return
        
    home = os.path.expanduser('~')
    rsf = os.path.join(home, RPDB_SETTINGS_FOLDER)

    if os.path.exists(rsf):
        return
        
    os.mkdir(rsf, 0x1c0)
</t>
<t tx="ekr.20060521134315.512">def calc_pwd_file_path(rid):
    home = os.path.expanduser('~')
    rsf = os.path.join(home, RPDB_SETTINGS_FOLDER)
    pwd_file_path = os.path.join(rsf, rid)
    
    return pwd_file_path
</t>
<t tx="ekr.20060521134315.513">def create_pwd_file(rid, pwd):
    if os.name != 'posix':
        return

    path = calc_pwd_file_path(rid)

    fd = os.open(path, os.O_WRONLY | os.O_CREAT, 0x180)
    
    os.write(fd, pwd)
    os.close(fd)
</t>
<t tx="ekr.20060521134315.514">def read_pwd_file(rid):
    path = calc_pwd_file_path(rid)

    p = open(path, 'r')
    pwd = p.read()
    p.close()

    return pwd
</t>
<t tx="ekr.20060521134315.515">def delete_pwd_file(rid):
    if os.name != 'posix':
        return

    path = calc_pwd_file_path(rid)

    try:
        os.remove(path)
    except:
        pass
</t>
<t tx="ekr.20060521134315.516">def ParseLineEncoding(l):
    if l.startswith('# -*- coding: '):
        e = l[len('# -*- coding: '):].split()[0]
        return e

    if l.startswith('# vim:fileencoding='):
        e = l[len('# vim:fileencoding='):].strip()
        return e

    return None    
</t>
<t tx="ekr.20060521134315.517">def ParseEncoding(txt):
    if txt.startswith('\xef\xbb\xbf'):
        return 'utf8'

    l = txt.split('\n', 2)

    e = ParseLineEncoding(l[0])
    if e != None:
        return e
        
    if len(l) == 1:
        return None 
        
    e = ParseLineEncoding(l[1])
    return e
</t>
<t tx="ekr.20060521134315.518"></t>
<t tx="ekr.20060521134315.519">def fix_password(pwd):
    if (len(pwd) &gt; 2) and ((pwd[0] + pwd[-1] == '""') or (pwd[0] + pwd[-1] == "''")):
        return pwd[1:-1]

    return pwd    
</t>
<t tx="ekr.20060521134315.520">class CCrypto:
	@others
</t>
<t tx="ekr.20060521134315.521">def __init__(self, pwd, fAllowUnencrypted, rid):
    self.m_pwd = pwd
    d = md5.new()
    d.update(pwd)
    self.m_key = d.digest()
    self.m_fAllowUnencrypted = fAllowUnencrypted
    self.m_rid = rid

    self.m_failure_lock = threading.RLock()

    self.m_lock = threading.RLock()

    self.m_index_anchor_in = random.randint(0, 1000000000)
    self.m_index_anchor_ex = 0

    self.m_index = 0
    self.m_index_table = {}
    self.m_index_table_size = INDEX_TABLE_SIZE
    self.m_max_index = 0
</t>
<t tx="ekr.20060521134315.522">def set_index(self, i, anchor):
    try:    
        self.m_lock.acquire()

        self.m_index = i
        self.m_index_anchor_ex = anchor
        
    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.523">def get_max_index(self):
    return self.m_max_index
</t>
<t tx="ekr.20060521134315.524">def is_encrypted(self, str):
    return str[: len(ENCRYPTION_PREFIX)] == ENCRYPTION_PREFIX
</t>
<t tx="ekr.20060521134315.525">def do_crypto(self, s, fEncryption):        
    _s = self.__auth_make(s)

    if not fEncryption:
        if self.m_fAllowUnencrypted:
            return _s

        raise EncryptionExpected  
        
    if not is_encryption_supported():
        raise EncryptionNotSupported

    __s = self.__encrypt(_s)
    return __s    
</t>
<t tx="ekr.20060521134315.526">def undo_crypto(self, __s, fVerifyIndex = True):
    (_s, fEncryption) = self.__decrypt(__s)            
    s = self.__auth_verify(_s, fVerifyIndex)

    return (s, fEncryption)
</t>
<t tx="ekr.20060521134315.527">def __encrypt(self, s):
    s_padded = s + '0' * (DES.block_size - (len(s) % DES.block_size))
    key_padded = (self.m_key + '0' * (DES.key_size - (len(self.m_key) % DES.key_size)))[:DES.key_size]
    iv = '0' * DES.block_size
    
    d = DES.new(key_padded, DES.MODE_CBC, iv)
    r = d.encrypt(s_padded)
    __s = base64.encodestring(r)

    return ENCRYPTION_PREFIX + __s
</t>
<t tx="ekr.20060521134315.528">def __decrypt(self, s):
    if s[: len(ENCRYPTION_PREFIX)] != ENCRYPTION_PREFIX:
        if self.m_fAllowUnencrypted:
            return (s, False)
            
        raise EncryptionExpected

    if not is_encryption_supported():
        raise EncryptionNotSupported
    
    __s = s[len(ENCRYPTION_PREFIX):]
    
    try:
        _r = base64.decodestring(__s)

        key_padded = (self.m_key + '0' * (DES.key_size - (len(self.m_key) % DES.key_size)))[:DES.key_size]
        iv = '0' * DES.block_size
        
        d = DES.new(key_padded, DES.MODE_CBC, iv)
        _s = d.decrypt(_r)

        return (_s, True)
        
    except:
        self.__wait_a_little()
        raise DecryptionFailure
</t>
<t tx="ekr.20060521134315.529">def __get_next_index(self):
    try:    
        self.m_lock.acquire()

        self.m_index += 1
        return self.m_index

    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.530">def __wait_a_little(self):
    self.m_failure_lock.acquire()
    time.sleep((1.0 + random.random()) / 2)
    self.m_failure_lock.release()
</t>
<t tx="ekr.20060521134315.531">def __verify_index(self, anchor, i, id):
    try:
        try:    
            self.m_lock.acquire()

            if anchor != self.m_index_anchor_in:
                raise AuthenticationBadIndex(self.m_max_index, self.m_index_anchor_in)

            if i &gt; self.m_max_index + INDEX_TABLE_SIZE / 2:
                raise AuthenticationBadIndex(self.m_max_index, self.m_index_anchor_in)

            _i = i % INDEX_TABLE_SIZE
            (iv, idl) = self.m_index_table.get(_i, (None, None))

            #print &gt;&gt; sys.__stderr__, i, _i, iv, self.m_max_index

            if (iv == None) or (i &gt; iv):
                iv = i
                idl = [id]
            elif (iv == i) and (not id in idl):
                idl.append(id)
            else:
                raise AuthenticationBadIndex(self.m_max_index, self.m_index_anchor_in)

            self.m_index_table[_i] = (iv, idl) 

            if i &gt; self.m_max_index:
                self.m_max_index = i

            return self.m_index

        finally:
            self.m_lock.release()
    except:        
        self.__wait_a_little()
        raise
</t>
<t tx="ekr.20060521134315.532">def __auth_make(self, s):
    i = self.__get_next_index()
    _s = cPickle.dumps((self.m_index_anchor_ex, i, self.m_rid, s))
    
    d = hmac.new(self.m_key, _s, md5)
    _d = d.digest()
    r = (_d, _s)
    __s = cPickle.dumps(r)

    return __s
</t>
<t tx="ekr.20060521134315.533">def __auth_verify(self, s, fVerifyIndex):
    try:
        r = cPickle.loads(s)
        
        (_d, _s) = r
        
        d = hmac.new(self.m_key, _s, md5)
        __d = d.digest()

        if _d != __d:
            self.__wait_a_little()
            raise AuthenticationFailure
            
        (anchor, i, id, __s) = cPickle.loads(_s)
    except AuthenticationFailure:
        raise
    except:
        self.__wait_a_little()
        raise AuthenticationBadData
        
    if fVerifyIndex:
        self.__verify_index(anchor, i, id)

    return __s
</t>
<t tx="ekr.20060521134315.534"></t>
<t tx="ekr.20060521134315.535">class CEvent:
    
	def is_match(self, arg):
        pass
</t>
<t tx="ekr.20060521134315.536">class CEventExit(CEvent):

	pass
</t>
<t tx="ekr.20060521134315.537">class CEventSync(CEvent):

	def __init__(self, fException):
        self.m_fException = fException

</t>
<t tx="ekr.20060521134315.538">class CEventState(CEvent):

	def __init__(self, state):
        self.m_state = state

    def is_match(self, arg):
        return self.m_state == arg</t>
<t tx="ekr.20060521134315.539">class CEventNamespace(CEvent):
	pass
</t>
<t tx="ekr.20060521134315.540">class CEventNoThreads(CEvent):
	pass
</t>
<t tx="ekr.20060521134315.541">class CEventThreads(CEvent):

	def __init__(self, current_thread, thread_list):
        self.m_current_thread = current_thread
        self.m_thread_list = thread_list

</t>
<t tx="ekr.20060521134315.542">class CEventThreadBroken(CEvent):

	def __init__(self, tid):
        self.m_tid = tid
</t>
<t tx="ekr.20060521134315.543">class CEventStack(CEvent):
    
	def __init__(self, stack):
        self.m_stack = stack</t>
<t tx="ekr.20060521134315.544">class CEventStackFrameChange(CEvent):
    
	def __init__(self, frame_index):
        self.m_frame_index = frame_index</t>
<t tx="ekr.20060521134315.545">class CEventStackDepth(CEvent):
	
    def __init__(self, stack_depth, stack_depth_exception):
        self.m_stack_depth = stack_depth
        self.m_stack_depth_exception = stack_depth_exception
    </t>
<t tx="ekr.20060521134315.546">class CEventBreakpoint(CEvent):
	
    DISABLE = 'disable'
    ENABLE = 'enable'
    REMOVE = 'remove'
    SET = 'set'

	def __init__(self, bp, action = SET, id_list = [], fAll = False):

        self.m_bp = copy.copy(bp)
        if self.m_bp != None:
            self.m_bp.m_code = None
        
        self.m_action = action
        self.m_id_list = id_list
        self.m_fAll = fAll</t>
<t tx="ekr.20060521134315.547">class CEventDispatcherRecord:
	@others
</t>
<t tx="ekr.20060521134315.548">def __init__(self, callback, event_type_dict, fSingleUse):
    self.m_callback = callback
    self.m_event_type_dict = event_type_dict
    self.m_fSingleUse = fSingleUse
</t>
<t tx="ekr.20060521134315.549">def is_match(self, event):

    rtl = [t for t in self.m_event_type_dict.keys() if isinstance(event, t)]
    if len(rtl) == 0:
        return False

    rt = rtl[0]    
    rte = self.m_event_type_dict[rt].get(EVENT_EXCLUDE, [])
    if len(rte) != 0:
        for e in rte:
            if event.is_match(e):
                return False
        return True  
    
    rte = self.m_event_type_dict[rt].get(EVENT_INCLUDE, [])
    if len(rte) != 0:
        for e in rte:
            if event.is_match(e):
                return True
        return False  

    return True</t>
<t tx="ekr.20060521134315.550">class CEventDispatcher:
	@others
</t>
<t tx="ekr.20060521134315.551">def __init__(self, chained_event_dispatcher = None):
    self.m_chained_event_dispatcher = chained_event_dispatcher
    self.m_chain_override_types = {}

    self.m_registrants = {}
</t>
<t tx="ekr.20060521134315.552">def shutdown():
    for er in self.m_registrants.keys():
        self.__remove_dispatcher_record(er)
</t>
<t tx="ekr.20060521134315.553">def register_callback(self, callback, event_type_dict, fSingleUse):

    er = CEventDispatcherRecord(callback, event_type_dict, fSingleUse)

    if self.m_chained_event_dispatcher != None:
        _er = self.__register_callback_on_chain(er, event_type_dict, fSingleUse)
        self.m_registrants[er] = _er
    else:
        self.m_registrants[er] = True
    
    return er
</t>
<t tx="ekr.20060521134315.554">def remove_callback(self, callback):

    erl = [er for er in self.m_registrants.keys() if er.m_callback == callback]

    for er in erl:
        self.__remove_dispatcher_record(er)
</t>
<t tx="ekr.20060521134315.555">def fire_events(self, event_list):

    for event in event_list:
        self.fire_event(event)
</t>
<t tx="ekr.20060521134315.556">def fire_event(self, event):

    for er in self.m_registrants.keys():
        self.__fire_er(event, er)
</t>
<t tx="ekr.20060521134315.557">def __fire_er(self, event, er):

    if er.is_match(event):
        try:
            er.m_callback(event)
        except: pass
            
        if er.m_fSingleUse:
            try:
                del self.m_registrants[er]
            except KeyError: pass
</t>
<t tx="ekr.20060521134315.558">def register_chain_override(self, event_type_dict):

    for t in event_type_dict.keys():
        self.m_chain_override_types[t] = True
</t>
<t tx="ekr.20060521134315.559">def __register_callback_on_chain(self, er, event_type_dict, fSingleUse):

    _event_type_dict = copy.copy(event_type_dict)
    for t in self.m_chain_override_types:
        if t in _event_type_dict:
            del _event_type_dict[t]

    if len(_event_type_dict) == 0:
        return False

    def callback(event, er = er):
        self.__fire_er(event, er)
        
    _er = self.m_chained_event_dispatcher.register_callback(callback, _event_type_dict, fSingleUse)
    return _er
</t>
<t tx="ekr.20060521134315.560">def __remove_dispatcher_record(self, er):

    try:
        if self.m_chained_event_dispatcher != None:
            _er = self.m_registrants[er]
            if _er != False:
                self.m_chained_event_dispatcher.__remove_dispatcher_record(_er)

        del self.m_registrants[er]
        
    except KeyError: pass</t>
<t tx="ekr.20060521134315.561">                


class CEventQueue:
	@others
</t>
<t tx="ekr.20060521134315.562">def __init__(self, event_dispatcher, max_event_list_length = MAX_EVENT_LIST_LENGTH):
    self.m_event_dispatcher = event_dispatcher

    self.m_event_lock = threading.Condition(threading.Lock())
    self.m_max_event_list_length = max_event_list_length
    self.m_event_list = []
    self.m_event_index = 0
</t>
<t tx="ekr.20060521134315.563">def shutdown(self):
    self.m_event_dispatcher.remove_callback(self.event_handler)
</t>
<t tx="ekr.20060521134315.564">def register_event_types(self, event_type_dict):
    self.m_event_dispatcher.register_callback(self.event_handler, event_type_dict, fSingleUse = False)
</t>
<t tx="ekr.20060521134315.565">def event_handler(self, event):
    try:
        self.m_event_lock.acquire()

        self.m_event_list.append(event)
        if len(self.m_event_list) &gt; self.m_max_event_list_length:
            self.m_event_list.pop(0)
            
        self.m_event_index += 1    
        self.m_event_lock.notifyAll()

    finally:
        self.m_event_lock.release()
</t>
<t tx="ekr.20060521134315.566">def get_event_index(self):
    return self.m_event_index
</t>
<t tx="ekr.20060521134315.567">def wait_for_event(self, timeout, event_index):
    try:
        self.m_event_lock.acquire()
        if event_index &gt;= self.m_event_index:
            self.m_event_lock.wait(timeout)

        if event_index &gt;= self.m_event_index:
            return (self.m_event_index, [])
            
        sub_event_list = self.m_event_list[event_index - self.m_event_index:]
        return (self.m_event_index, sub_event_list)
        
    finally:
        self.m_event_lock.release()
</t>
<t tx="ekr.20060521134315.568">


class CStateManager:
	@others
</t>
<t tx="ekr.20060521134315.569">def __init__(self, initial_state, event_dispatcher_output = None, event_dispatcher_input = None, event_dispatcher_sync = None):
    self.m_event_dispatcher_input = event_dispatcher_input
    self.m_event_dispatcher_output = event_dispatcher_output
    self.m_event_dispatcher_sync = event_dispatcher_sync

    if self.m_event_dispatcher_sync != None:
        event_type_dict = {CEventSync: {}}
        self.m_event_dispatcher_sync.register_callback(self.event_handler, event_type_dict, fSingleUse = False)

    if self.m_event_dispatcher_input != None:
        event_type_dict = {CEventState: {}}
        self.m_event_dispatcher_input.register_callback(self.event_handler, event_type_dict, fSingleUse = False)

        if self.m_event_dispatcher_output != None:
            self.m_event_dispatcher_output.register_chain_override(event_type_dict)

    self.m_state_lock = threading.Condition(threading.Lock())

    self.m_state_queue = []
    self.m_state_index = 0        
    self.m_waiter_list = {}
    
    self.set_state(initial_state) 
</t>
<t tx="ekr.20060521134315.570">def shutdown(self):
    if self.m_event_dispatcher_sync != None:
        self.m_event_dispatcher_sync.remove_callback(self.event_handler)

    if self.m_event_dispatcher_input != None:
        self.m_event_dispatcher_input.remove_callback(self.event_handler)
</t>
<t tx="ekr.20060521134315.571">def event_handler(self, event):
    if isinstance(event, CEventSync):
        if not event.m_fException:                
            self.set_state()

        return
        
    self.set_state(event.m_state)
</t>
<t tx="ekr.20060521134315.572">def get_state(self):
    return self.m_state_queue[-1]
</t>
<t tx="ekr.20060521134315.573">def __add_state(self, state):
    self.m_state_queue.append(state)
    self.m_state_index += 1

    self.__remove_states()
</t>
<t tx="ekr.20060521134315.574">def __remove_states(self, treshold = None):
    index = self.__calc_min_index()

    if (treshold != None) and (index &lt;= treshold):
        return
        
    _delta = 1 + self.m_state_index - index

    self.m_state_queue = self.m_state_queue[-_delta:]
</t>
<t tx="ekr.20060521134315.575">def __calc_min_index(self):
    if len(self.m_waiter_list) == 0:
        return self.m_state_index

    index_list = self.m_waiter_list.keys()
    min_index = min(index_list)

    return min_index
</t>
<t tx="ekr.20060521134315.576">def __add_waiter(self):
    index = self.m_state_index
    n = self.m_waiter_list.get(index, 0)
    self.m_waiter_list[index] = n + 1

    return index
</t>
<t tx="ekr.20060521134315.577">def __remove_waiter(self, index):
    n = self.m_waiter_list[index]
    if n == 1:
        del self.m_waiter_list[index]
        self.__remove_states(index)
    else:
        self.m_waiter_list[index] = n - 1
</t>
<t tx="ekr.20060521134315.578">def __get_states(self, index):
    _delta = 1 + self.m_state_index - index
    states = self.m_state_queue[-_delta:]
    return states
</t>
<t tx="ekr.20060521134315.579">def set_state(self, state = None, fLock = True):
    try:
        if fLock:
            self.m_state_lock.acquire()

        if state == None:
            state = self.get_state()
            
        self.__add_state(state)            

        self.m_state_lock.notifyAll()

    finally:    
        if fLock:
            self.m_state_lock.release()

    if self.m_event_dispatcher_output != None:
        event = CEventState(state)
        self.m_event_dispatcher_output.fire_event(event)
</t>
<t tx="ekr.20060521134315.580">def wait_for_state(self, state_list):
    try:
        self.m_state_lock.acquire()

        if self.get_state() in state_list:
            return self.get_state()
        
        while True:
            index = self.__add_waiter()
        
            self.m_state_lock.wait(PING_TIMEOUT)

            states = self.__get_states(index)
            self.__remove_waiter(index)

            for state in states:
                if state in state_list:
                    return state
        
    finally:
        self.m_state_lock.release()
</t>
<t tx="ekr.20060521134315.581">def acquire(self):
    self.m_state_lock.acquire()
</t>
<t tx="ekr.20060521134315.582">def release(self):
    self.m_state_lock.release()
</t>
<t tx="ekr.20060521134315.583"></t>
<t tx="ekr.20060521134315.584">def CalcValidLines(code):

    l = code.co_firstlineno
    vl = [l]
    bl = [ord(c) for c in code.co_lnotab[2::2]]
    sl = [ord(c) for c in code.co_lnotab[1::2]]

    for (bi, si) in zip(bl, sl):
        l += si
        if bi == 0: continue
        if l != vl[-1]:
            vl.append(l)

    if len(sl) &gt; 0:
        l += sl[-1]
        if l != vl[-1]:
            vl.append(l)
    
    return vl</t>
<t tx="ekr.20060521134315.585">class CScopeBreakInfo:
	@others
</t>
<t tx="ekr.20060521134315.586">def __init__(self, fqn, valid_lines):

    self.m_fqn = fqn
    self.m_first_line = valid_lines[0]
    self.m_last_line = valid_lines[-1]
    self.m_valid_lines = valid_lines
</t>
<t tx="ekr.20060521134315.587">def CalcScopeLine(self, lineno):

    rvl = copy.copy(self.m_valid_lines)
    rvl.reverse()

    for l in rvl:
        if lineno &gt;= l:
            break

    return l</t>
<t tx="ekr.20060521134315.588">def __str__(self):

    return "('" + self.m_fqn + "', " + str(self.m_valid_lines) + ')'
</t>
<t tx="ekr.20060521134315.589">        


class CFileBreakInfo:
	@others
</t>
<t tx="ekr.20060521134315.590">def __init__(self, filename):

    self.m_filename = filename
    self.m_first_line = 0
    self.m_last_line = 0
    self.m_scope_break_info = []
</t>
<t tx="ekr.20060521134315.591">def __CalcSubCodesList(self, code):

    tc = type(code)
    t = [(c.co_firstlineno, c) for c in code.co_consts if type(c) == tc]
    t.sort()
    scl = [c[1] for c in t]
    return scl
</t>
<t tx="ekr.20060521134315.592">def __CalcBreakInfoFromSource(self, source):

    _source = source.replace('\r\n', '\n') + '\n'
    code = compile(_source, self.m_filename, "exec")
    self.m_scope_break_info = []
    self.m_first_line = code.co_firstlineno
    self.m_last_line = 0
    fqn = []
    t = [code]
    
    while len(t) &gt; 0:
        c = t.pop(0)
        if type(c) == tuple:
            self.m_scope_break_info.append(CScopeBreakInfo(*c))
            fqn.pop()
            continue
        fqn = fqn + [c.co_name]  
        valid_lines = CalcValidLines(c)
        self.m_last_line = max(self.m_last_line, valid_lines[-1])
        _fqn = string.join(fqn, '.')
        si = (_fqn, valid_lines)  
        subcodeslist = self.__CalcSubCodesList(c)
        t = subcodeslist + [si] + t
</t>
<t tx="ekr.20060521134315.593">def CalcBreakInfo(self):

    if is_blender_file(self.m_filename):
        lines = get_blender_source(self.m_filename)
        source = '\n'.join(lines) + '\n'
    else:    
        f = open(self.m_filename, "r")
        source = f.read()
        f.close()
    
    self.__CalcBreakInfoFromSource(source)
</t>
<t tx="ekr.20060521134315.594">def FindScopeByLineno(self, lineno):

    lineno = max(min(lineno, self.m_last_line), self.m_first_line)
    smaller_element = None
    exact_element = None
    
    for sbi in self.m_scope_break_info:
        if lineno &gt; sbi.m_last_line:
            if (smaller_element == None) or (sbi.m_last_line &gt;= smaller_element.m_last_line):
                smaller_element = sbi
            continue

        if (lineno &gt;= sbi.m_first_line) and (lineno &lt;= sbi.m_last_line):
            exact_element = sbi
            break

    assert(exact_element != None)

    scope = exact_element
    l = exact_element.CalcScopeLine(lineno)
    
    if (smaller_element != None) and (l &lt;= smaller_element.m_last_line):
        scope = smaller_element
        l = smaller_element.CalcScopeLine(lineno)

    return (scope, l)
</t>
<t tx="ekr.20060521134315.595">def FindScopeByName(self, name, offset):
    if not name.startswith(MODULE_SCOPE):
        name = MODULE_SCOPE + SCOPE_SEP + name
        
    for sbi in self.m_scope_break_info:
        if sbi.m_fqn == name:
            l = sbi.CalcScopeLine(sbi.m_first_line + offset)
            return (sbi, l)

    raise InvalidScopeName
</t>
<t tx="ekr.20060521134315.596">    


class CBreakInfoManager:
	@others
</t>
<t tx="ekr.20060521134315.597">def __init__(self):
    self.m_file_info_dic = {}
</t>
<t tx="ekr.20060521134315.598">def addFile(self, filename):

    mbi = CFileBreakInfo(filename)
    mbi.CalcBreakInfo()
    self.m_file_info_dic[filename] = mbi
</t>
<t tx="ekr.20060521134315.599">def getFile(self, filename):

    if not filename in self.m_file_info_dic:
        self.addFile(filename)

    return self.m_file_info_dic[filename]
</t>
<t tx="ekr.20060521134315.600"></t>
<t tx="ekr.20060521134315.601">class CBreakPoint:
	@others
</t>
<t tx="ekr.20060521134315.602">def __init__(self, filename,
    scope_fqn, scope_first_line, lineno, fEnabled, expr, fTemporary = False):

    self.m_id = None
    self.m_fEnabled = fEnabled
    self.m_filename = filename
    self.m_scope_fqn = scope_fqn
    self.m_scope_name = scope_fqn.split(SCOPE_SEP)[-1]
    self.m_scope_first_line = scope_first_line
    self.m_scope_offset = lineno - scope_first_line
    self.m_lineno = lineno
    self.m_expr = expr
    self.m_code = None
    self.m_fTemporary = fTemporary

    if (expr != None) and (expr != ''):
        self.m_code = compile(expr, '', 'eval')
</t>
<t tx="ekr.20060521134315.603">def calc_enclosing_scope_name(self):

    if self.m_scope_offset != 0:
        return None
        
    if self.m_scope_fqn == MODULE_SCOPE:
        return None

    scope_name_list = self.m_scope_fqn.split(SCOPE_SEP)
    enclosing_scope_name = scope_name_list[-2]

    return enclosing_scope_name
</t>
<t tx="ekr.20060521134315.604">def enable(self):
    self.m_fEnabled = True
</t>
<t tx="ekr.20060521134315.605">def disable(self):
    self.m_fEnabled = False
</t>
<t tx="ekr.20060521134315.606">def isEnabled(self):
    return self.m_fEnabled
</t>
<t tx="ekr.20060521134315.607">def __str__(self):

    return (
        "('" + self.m_filename +
        "', '" + self.m_scope_fqn +
        "', " + str(self.m_scope_first_line) +
        ', ' + str(self.m_scope_offset) +
        ', ' + str(self.m_lineno) + ')'
    )</t>
<t tx="ekr.20060521134315.608">class CBreakPointsManagerProxy:
	@others
</t>
<t tx="ekr.20060521134315.609">def __init__(self, session_manager):

    self.m_session_manager = session_manager

    self.m_break_points_by_file = {}
    self.m_break_points_by_id = {}

    self.m_lock = threading.Lock()

    event_type_dict = {CEventBreakpoint: {}}

    self.m_session_manager.m_event_dispatcher_proxy.register_callback(
        self.update_bp, event_type_dict, fSingleUse = False)
    
    self.m_session_manager.m_event_dispatcher.register_chain_override(event_type_dict)
</t>
<t tx="ekr.20060521134315.610">def update_bp(self, event):       
    try:    
        self.m_lock.acquire()

        if event.m_fAll:
            id_list = self.m_break_points_by_id.keys()
        else:
            id_list = event.m_id_list
            
        if event.m_action == CEventBreakpoint.REMOVE:
            &lt;&lt; remove breakpoint &gt;&gt;
            return
            
        if event.m_action == CEventBreakpoint.DISABLE:
            &lt;&lt; disable breakpoint &gt;&gt;
            return

        if event.m_action == CEventBreakpoint.ENABLE:
            &lt;&lt; enable breakpoint &gt;&gt;
            return
            
        bpm = self.m_break_points_by_file.get(event.m_bp.m_filename, {})
        bpm[event.m_bp.m_lineno] = event.m_bp
        self.m_break_points_by_id[event.m_bp.m_id] = event.m_bp
        
    finally:
        self.m_lock.release()
        self.m_session_manager.m_event_dispatcher.fire_event(event)</t>
<t tx="ekr.20060521134315.611">for id in id_list:
    try:
        bp = self.m_break_points_by_id.pop(id)
        bpm = self.m_break_points_by_file[bp.m_filename]
        del bpm[bp.m_lineno]
        if len(bpm) == 0:
            del self.m_break_points_by_file[bp.m_filename]
    except KeyError: pass</t>
<t tx="ekr.20060521134315.612">for id in id_list:
    try:
        bp = self.m_break_points_by_id[id]
        bp.disable()
    except KeyError: pass</t>
<t tx="ekr.20060521134315.613">for id in id_list:
    try:
        bp = self.m_break_points_by_id[id]
        bp.enable()
    except KeyError: pass</t>
<t tx="ekr.20060521134315.614">def sync(self):
    
    try:    
        self.m_lock.acquire()
        self.m_break_points_by_file = {}
        self.m_break_points_by_id = {}
    finally:
        self.m_lock.release()

    break_points_by_id = self.m_session_manager.getSession().getProxy().get_breakpoints()

    try:    
        self.m_lock.acquire()
        self.m_break_points_by_id.update(break_points_by_id)
        for bp in self.m_break_points_by_id.values():
            bpm = self.m_break_points_by_file.get(bp.m_filename, {})
            bpm[bp.m_lineno] = bp
    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.615">def clear(self):

    try:    
        self.m_lock.acquire()
        self.m_break_points_by_file = {}
        self.m_break_points_by_id = {}
        
    finally:
        self.m_lock.release()</t>
<t tx="ekr.20060521134315.616">def get_breakpoints(self):
    
    return self.m_break_points_by_id

</t>
<t tx="ekr.20060521134315.617">def get_breakpoint(self, filename, lineno):

    bpm = self.m_break_points_by_file[filename]
    bp = bpm[lineno]
    return bp    
</t>
<t tx="ekr.20060521134315.618">class CBreakPointsManager:
	@others
</t>
<t tx="ekr.20060521134315.619">def __init__(self):

    self.m_break_info_manager = CBreakInfoManager()
    self.m_active_break_points_by_file = {}
    self.m_break_points_by_function = {}
    self.m_break_points_by_file = {}
    self.m_break_points_by_id = {}
    self.m_lock = threading.Lock()
    self.m_temp_bp = None
</t>
<t tx="ekr.20060521134315.620">def get_active_break_points_by_file(self, filename):

    _filename = winlower(filename)
    
    return self.m_active_break_points_by_file.setdefault(_filename, {})
</t>
<t tx="ekr.20060521134315.621">def __calc_active_break_points_by_file(self, filename):

    bpmpt = self.m_active_break_points_by_file.setdefault(filename, {})        
    bpmpt.clear()

    bpm = self.m_break_points_by_file.get(filename, {})
    for bp in bpm.values():
        if bp.m_fEnabled:
            bpmpt[bp.m_lineno] = bp
            
    tbp = self.m_temp_bp
    if (tbp != None) and (tbp.m_filename == filename):
        bpmpt[tbp.m_lineno] = tbp</t>
<t tx="ekr.20060521134315.622">def __remove_from_function_list(self, bp):
    
    function_name = bp.m_scope_name

    try:
        bpf = self.m_break_points_by_function[function_name]
        del bpf[bp]
        if len(bpf) == 0:
            del self.m_break_points_by_function[function_name]
    except KeyError: pass

    _function_name = bp.calc_enclosing_scope_name()
    if _function_name == None: return
        
    try:
        _bpf = self.m_break_points_by_function[_function_name]
        del _bpf[bp]
        if len(_bpf) == 0:
            del self.m_break_points_by_function[_function_name]
    except KeyError: pass

</t>
<t tx="ekr.20060521134315.623">def __add_to_function_list(self, bp):

    function_name = bp.m_scope_name

    bpf = self.m_break_points_by_function.setdefault(function_name, {})
    bpf[bp] = True 

    _function_name = bp.calc_enclosing_scope_name()
    if _function_name == None:
        return
        
    _bpf = self.m_break_points_by_function.setdefault(_function_name, {})
    _bpf[bp] = True 
</t>
<t tx="ekr.20060521134315.624">def get_breakpoint(self, filename, lineno):

    bpm = self.m_break_points_by_file[filename]
    bp = bpm[lineno]
    return bp    
</t>
<t tx="ekr.20060521134315.625">def del_temp_breakpoint(self, fLock = True):
    
    if self.m_temp_bp == None:
        return

    try:    
        if fLock: self.m_lock.acquire()
        if self.m_temp_bp == None: return

        bp = self.m_temp_bp
        self.m_temp_bp = None
        self.__remove_from_function_list(bp)
        self.__calc_active_break_points_by_file(bp.m_filename)

    finally:
        if fLock: self.m_lock.release()
</t>
<t tx="ekr.20060521134315.626">def set_temp_breakpoint(self, filename, scope, lineno):
    
    _filename = winlower(filename)
    mbi = self.m_break_info_manager.getFile(_filename)

    if scope != '':
        (s, l) = mbi.FindScopeByName(scope, lineno)
    else:
        (s, l) = mbi.FindScopeByLineno(lineno)

    bp = CBreakPoint(
        _filename, s.m_fqn, s.m_first_line, l,
        fEnabled = True, expr = '', fTemporary = True)

    try:    
        self.m_lock.acquire()
        self.del_temp_breakpoint(fLock = False) 
        self.m_temp_bp = bp
        self.__add_to_function_list(bp)
        self.__calc_active_break_points_by_file(bp.m_filename)

    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.627">def set_breakpoint(self, filename, scope, lineno, fEnabled, expr):
    
    _filename = winlower(filename)
    mbi = self.m_break_info_manager.getFile(_filename)

    if scope != '':
        (s, l) = mbi.FindScopeByName(scope, lineno)
    else:
        (s, l) = mbi.FindScopeByLineno(lineno)

    bp = CBreakPoint(_filename, s.m_fqn, s.m_first_line, l, fEnabled, expr)

    try:    
        self.m_lock.acquire()
        bpm = self.m_break_points_by_file.setdefault(_filename, {})
        
        try:
            old_bp = bpm[l]
            id = old_bp.m_id
            self.__remove_from_function_list(old_bp)
        except KeyError:
            bpids = self.m_break_points_by_id.keys()
            bpids.sort()
            id = 0
            while id &lt; len(bpids):
                if bpids[id] != id: break
                id += 1

        bp.m_id = id 
        self.m_break_points_by_id[id] = bp    
        bpm[l] = bp    
        if fEnabled:
            self.__add_to_function_list(bp)
        self.__calc_active_break_points_by_file(bp.m_filename)
        return bp    

    finally:
        self.m_lock.release()</t>
<t tx="ekr.20060521134315.628">def disable_breakpoint(self, id_list, fAll):

    try:    
        self.m_lock.acquire()

        if fAll:
            id_list = self.m_break_points_by_id.keys()

        for id in id_list:    
            try:
                bp = self.m_break_points_by_id[id]
            except KeyError:
                continue
                
            bp.disable()
            self.__remove_from_function_list(bp)
            self.__calc_active_break_points_by_file(bp.m_filename)

    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.629">def enable_breakpoint(self, id_list, fAll):

    try:    
        self.m_lock.acquire()

        if fAll:
            id_list = self.m_break_points_by_id.keys()

        for id in id_list:  
            try:
                bp = self.m_break_points_by_id[id]
            except KeyError:
                continue
                
            bp.enable()
            self.__add_to_function_list(bp)
            self.__calc_active_break_points_by_file(bp.m_filename)

    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.630">def delete_breakpoint(self, id_list, fAll):

    try:    
        self.m_lock.acquire()

        if fAll:
            id_list = self.m_break_points_by_id.keys()

        for id in id_list:    
            try:
                bp = self.m_break_points_by_id[id]
            except KeyError:
                continue
                
            filename = bp.m_filename
            lineno = bp.m_lineno

            bpm = self.m_break_points_by_file[filename]
            if bp == bpm[lineno]:
                del bpm[lineno]

            if len(bpm) == 0:
                del self.m_break_points_by_file[filename]
                
            self.__remove_from_function_list(bp)
            self.__calc_active_break_points_by_file(bp.m_filename)
                
            del self.m_break_points_by_id[id]

    finally:
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.631">def get_breakpoints(self):

    return self.m_break_points_by_id
</t>
<t tx="ekr.20060521134315.632"></t>
<t tx="ekr.20060521134315.633">class CCodeContext:

	@others
</t>
<t tx="ekr.20060521134315.634">def __init__(self, code, bp_manager):
    
    self.m_code = code
    self.m_filename = my_abspath(code.co_filename)
    self.m_basename = os.path.basename(self.m_filename)

    self.m_file_breakpoints = bp_manager.get_active_break_points_by_file(self.m_filename)

    self.m_fExceptionTrap = False

</t>
<t tx="ekr.20060521134315.635">def is_untraced(self):

    return self.m_basename in [THREADING_FILENAME, DEBUGGER_FILENAME]
</t>
<t tx="ekr.20060521134315.636">def is_exception_trap_frame(self):
    
    return self.m_basename == THREADING_FILENAME

</t>
<t tx="ekr.20060521134315.637">class CDebuggerCoreThread:
	@others
</t>
<t tx="ekr.20060521134315.638">def __init__(self, core_debugger, frame, event):

    self.m_thread_id = thread.get_ident()
    self.m_fBroken = False
    self.m_fUnhandledException = False
    
    self.m_frame = frame
    self.m_event = event
    self.m_ue_lineno = None
    self.m_uef_lineno = None
    
    self.m_code_context = core_debugger.get_code_context(frame.f_code)

    self.m_locals_copy = {}

    self.m_core = core_debugger
    self.m_bp_manager = core_debugger.m_bp_manager

    self.m_frame_lock = threading.Condition(threading.Lock())
    self.m_frame_external_references = 0
</t>
<t tx="ekr.20060521134315.639">def profile(self, frame, event, arg):
     
    if event == 'return':            
        self.m_frame = frame.f_back

        try:
            self.m_code_context = self.m_core.m_code_contexts[self.m_frame.f_code]
        except AttributeError:
            if self.m_event != 'return':
                self.m_frame = frame
                self.m_event = 'exception'
                
                self.m_uef_lineno = self.m_ue_lineno
                
                self.m_fUnhandledException = True                    
                self.m_core._break(self, frame, event, arg)
                
                self.m_uef_lineno = None 
                
                if frame in self.m_locals_copy:
                    self.update_locals()

                self.m_frame = None
            
            self.m_core.remove_thread(self.m_thread_id)
            sys.setprofile(None)
            sys.settrace(self.m_core.trace_dispatch_init)
        
        if self.m_frame_external_references == 0:
            return

        try:
            self.m_frame_lock.acquire() 

            while self.m_frame_external_references != 0:
                self.m_frame_lock.wait(1.0)

        finally:
            self.m_frame_lock.release()

</t>
<t tx="ekr.20060521134315.640">def frame_acquire(self):

    try:
        self.m_frame_lock.acquire()
        
        self.m_frame_external_references += 1
        f = self.m_frame
        if f == None:
            raise ThreadDone

        return f    

    finally:    
        self.m_frame_lock.release()
</t>
<t tx="ekr.20060521134315.641">def frame_release(self):
    
    try:
        self.m_frame_lock.acquire()
            
        self.m_frame_external_references -= 1
        if self.m_frame_external_references == 0:
            self.m_frame_lock.notify()

    finally:    
        self.m_frame_lock.release()

</t>
<t tx="ekr.20060521134315.642">def get_frame(self, base_frame, index, fException = False):

    if fException:
        tb = base_frame.f_exc_traceback
        if tb == None:
            raise NoExceptionFound
            
        while tb.tb_next != None:
            tb = tb.tb_next

        f = tb.tb_frame
    else:    
        f = base_frame
        
    while (index &gt; 0) and (f != None):
        f = f.f_back
        index -= 1

    if (index &lt; 0) or (f == None):
        raise InvalidFrame

    if (self.m_uef_lineno != None) and (f.f_back == None):
        lineno = self.m_uef_lineno
    else:    
        lineno = f.f_lineno
        
    if fException:
        tb = base_frame.f_exc_traceback
        while tb != None:
            if tb.tb_frame == f:
                lineno = tb.tb_lineno
                break
            tb = tb.tb_next

    return (f, lineno)</t>
<t tx="ekr.20060521134315.643">def get_locals_copy(self, frame_index, fException, fReadOnly):
         
    try:
        base_frame = self.frame_acquire()

        (f, lineno) = self.get_frame(base_frame, frame_index, fException)

        gc = f.f_globals

        try:
            lc = self.m_locals_copy[f][0]
        except KeyError:
            if f.f_code.co_name == '?':
                lc = gc
            else:    
                lc = copy.copy(f.f_locals)

                if not fReadOnly:
                    self.m_locals_copy[f] = (lc, copy.copy(lc))
                    self.set_local_trace(f)

        return (gc, lc)

    finally:
        f = None
        base_frame = None
        
        self.frame_release()

</t>
<t tx="ekr.20060521134315.644">def update_locals_copy(self):
    
    lct = self.m_locals_copy.get(self.m_frame, None)
    if lct == None:
        return

    (lc, base) = lct
    cr = copy.copy(self.m_frame.f_locals)
    
    sb = set(base.items())
    sc = set(cr.items())

    nsc = [k for (k, v) in sc - sb]

    for k in nsc:
        lc[k] = cr[k]

</t>
<t tx="ekr.20060521134315.645">def update_locals(self):
    
    lct = self.m_locals_copy.pop(self.m_frame, None)
    if lct == None:
        return

    self.m_frame.f_locals.update(lct[0])

</t>
<t tx="ekr.20060521134315.646">def __eval_breakpoint(self, frame, bp):

    if not bp.m_fEnabled:
        return False

    if bp.m_expr == '':
        return True

    try:
        if frame in self.m_locals_copy:
            l = self.m_locals_copy[frame][0]
            v = eval(bp.m_code, frame.f_globals, l)
        else:
            v = eval(bp.m_code, frame.f_globals, frame.f_locals)
            
        return (v != False)
    except:
        return False</t>
<t tx="ekr.20060521134315.647">def set_local_trace(self, frame):

    if not self.m_core.m_ftrace:
        frame.f_trace = self.trace_dispatch_stop
        return

    code_context = self.m_core.get_code_context(frame.f_code)

    if self.m_core.is_break(self, frame):
        frame.f_trace = self.trace_dispatch_break
    elif code_context.m_fExceptionTrap or (frame.f_back == None):    
        frame.f_trace = self.trace_dispatch_trap
    elif frame.f_code.co_name in self.m_bp_manager.m_break_points_by_function:
        frame.f_trace = self.trace_dispatch
    elif frame in self.m_locals_copy:
        frame.f_trace = self.trace_dispatch
    elif frame == self.m_core.m_return_frame:
        frame.f_trace = self.trace_dispatch
    else:    
        del frame.f_trace
</t>
<t tx="ekr.20060521134315.648">def set_tracers(self):

    try:
        try:
            f = self.frame_acquire()
            while f != None:
                self.set_local_trace(f)
                f = f.f_back
                
        except ThreadDone:
            f = None
            
    finally:      
        f = None
        self.frame_release()</t>
<t tx="ekr.20060521134315.649">def trace_dispatch_stop(self, frame, event, arg):

    if frame in self.m_locals_copy:
        self.update_locals()

    sys.settrace(None)
    sys.setprofile(None)
    return None
</t>
<t tx="ekr.20060521134315.650">def trace_dispatch_break(self, frame, event, arg):

    if event not in ['line', 'return', 'exception']:
        return frame.f_trace

    if event == 'exception':
        self.set_exc_info(arg)
        
    self.m_event = event

    if frame in self.m_locals_copy:
        self.update_locals_copy()

    self.m_core._break(self, frame, event, arg)

    if frame in self.m_locals_copy:
        self.update_locals()
        self.set_local_trace(frame)
    
    return frame.f_trace            
</t>
<t tx="ekr.20060521134315.651">def trace_dispatch_call(self, frame, event, arg):
    if not self.m_core.m_ftrace:
        return self.trace_dispatch_stop(frame, event, arg)
        
    self.m_frame = frame

    try:
        self.m_code_context = self.m_core.m_code_contexts[frame.f_code]
    except KeyError:
        self.m_code_context = self.m_core.get_code_context(frame.f_code)

    if self.m_core.m_fBreak or (self.m_core.m_step_tid == self.m_thread_id):
        self.m_event = event
        self.m_core._break(self, frame, event, arg)
        if frame in self.m_locals_copy:
            self.update_locals()
            self.set_local_trace(frame)
        return frame.f_trace

    if not frame.f_code.co_name in self.m_bp_manager.m_break_points_by_function:
        return None

    bp = self.m_code_context.m_file_breakpoints.get(frame.f_lineno, None)
    if bp != None and self.__eval_breakpoint(frame, bp): 
        self.m_event = event
        self.m_core._break(self, frame, event, arg)
        if frame in self.m_locals_copy:
            self.update_locals()
            self.set_local_trace(frame)
        return frame.f_trace     

    return self.trace_dispatch     </t>
<t tx="ekr.20060521134315.652">def trace_dispatch(self, frame, event, arg):
    if (event == 'line'):
        if frame in self.m_locals_copy:
            self.update_locals_copy()

        bp = self.m_code_context.m_file_breakpoints.get(frame.f_lineno, None)                

        if bp != None and self.__eval_breakpoint(frame, bp): 
            self.m_event = event
            self.m_core._break(self, frame, event, arg)
            
            if frame in self.m_locals_copy:
                self.update_locals()
                self.set_local_trace(frame)

        return frame.f_trace     
                    
    if event == 'return':
        if frame in self.m_locals_copy:
            self.update_locals_copy()

        if frame == self.m_core.m_return_frame:
            self.m_event = event
            self.m_core._break(self, frame, event, arg)
            
            if frame in self.m_locals_copy:
                self.update_locals()

        return None     
        
    if event == 'exception':
        if frame in self.m_locals_copy:
            self.update_locals()
            self.set_local_trace(frame)

        if frame.f_exc_traceback == None:
            (frame.f_exc_type, frame.f_exc_value, frame.f_exc_traceback) = arg

        return frame.f_trace     

    return frame.f_trace     
</t>
<t tx="ekr.20060521134315.653">def trace_dispatch_trap(self, frame, event, arg):

    self.m_event = event

    if (event == 'line'):
        if frame in self.m_locals_copy:
            self.update_locals_copy()

        bp = self.m_code_context.m_file_breakpoints.get(frame.f_lineno, None)                
        if bp != None and self.__eval_breakpoint(frame, bp): 
            self.m_core._break(self, frame, event, arg)
            
            if frame in self.m_locals_copy:
                self.update_locals()
                self.set_local_trace(frame)

        return frame.f_trace     
                    
    if event == 'return':
        if frame in self.m_locals_copy:
            self.update_locals_copy()

        if frame == self.m_core.m_return_frame:
            self.m_core._break(self, frame, event, arg)
            
            if frame in self.m_locals_copy:
                self.update_locals()

        return None     
        
    if event == 'exception':
        if self.m_code_context.m_fExceptionTrap:                
            self.set_exc_info(arg)
            
            self.m_fUnhandledException = True
            self.m_core._break(self, frame, event, arg)

            if frame in self.m_locals_copy:
                self.update_locals()
                
            return frame.f_trace

        self.m_ue_lineno = frame.f_lineno
        
        if frame in self.m_locals_copy:
            self.update_locals()
            self.set_local_trace(frame)

        if frame.f_exc_traceback == None:
            (frame.f_exc_type, frame.f_exc_value, frame.f_exc_traceback) = arg

        return frame.f_trace     

    return frame.f_trace     
</t>
<t tx="ekr.20060521134315.654">def set_exc_info(self, arg):
    
    (t, v, tb) = arg

    while tb != None:
        f = tb.tb_frame            
        f.f_exc_type = t
        f.f_exc_value = v 
        f.f_exc_traceback = tb

        tb = tb.tb_next

</t>
<t tx="ekr.20060521134315.655">def is_breakpoint(self):

    bp = self.m_code_context.m_file_breakpoints.get(self.m_frame.f_lineno, None)
    if bp != None and self.__eval_breakpoint(self.m_frame, bp):
        return True

    return False    
</t>
<t tx="ekr.20060521134315.656">class CDebuggerCore:
	@others
</t>
<t tx="ekr.20060521134315.657">def __init__(self):
    self.m_ftrace = True

    self.m_current_ctx = None 
    self.m_f_first_to_break = True
    self.m_f_break_on_init = False

    self.m_timer_embedded_giveup = None
    
    self.m_threads_lock = threading.Condition(threading.Lock())

    self.m_threads = {}

    self.m_event_dispatcher = CEventDispatcher()
    self.m_state_manager = CStateManager(STATE_RUNNING, self.m_event_dispatcher, event_dispatcher_sync = self.m_event_dispatcher)

    self.m_fBreak = False

    self.m_lastest_event = None
    self.m_step_tid = None
    self.m_next_frame = None
    self.m_return_frame = None       

    self.m_bp_manager = CBreakPointsManager()

    self.m_code_contexts = {None: None}
</t>
<t tx="ekr.20060521134315.658">def __del__(self):
    self.m_event_dispatcher.shutdown()
    self.m_state_manager.shutdown()
</t>
<t tx="ekr.20060521134315.659">def set_request_go_timer(self, timeout):
    if timeout == None:
        return
        
    _timeout = max(5.0, timeout)
    self.m_timer_embedded_giveup = threading.Timer(_timeout, self.request_go)
    self.m_timer_embedded_giveup.start()
</t>
<t tx="ekr.20060521134315.660">def cancel_request_go_timer(self):
    t = self.m_timer_embedded_giveup
    if t != None:
        self.m_timer_embedded_giveup = None
        t.cancel()
</t>
<t tx="ekr.20060521134315.661">def setbreak(self, f):

    tid = thread.get_ident()
    ctx = self.m_threads[tid]
    f.f_trace = ctx.trace_dispatch_break
    self.m_next_frame = f
</t>
<t tx="ekr.20060521134315.662">def settrace(self, f = None, f_break_on_init = True, timeout = None):

    if not self.m_ftrace:
        return 
        
    tid = thread.get_ident()
    if tid in self.m_threads:
        return

    self.set_request_go_timer(timeout)
        
    self.m_f_break_on_init = f_break_on_init
    
    threading.settrace(self.trace_dispatch_init)
    sys.settrace(self.trace_dispatch_init)

    if f != None:
        f.f_trace = self.trace_dispatch_init
</t>
<t tx="ekr.20060521134315.663">def stoptrace(self):

    threading.settrace(None)
    sys.settrace(None)
    sys.setprofile(None)
    
    self.m_ftrace = False
    self.set_all_tracers()
    self.m_threads = {}
</t>
<t tx="ekr.20060521134315.664">def get_code_context(self, code):

    try:
        return self.m_code_contexts[code]
    except KeyError:
        code_context = CCodeContext(code, self.m_bp_manager)
        return self.m_code_contexts.setdefault(code, code_context)
</t>
<t tx="ekr.20060521134315.665">def get_current_ctx(self):

    if len(self.m_threads) == 0:
        raise NoThreads

    return self.m_current_ctx 
</t>
<t tx="ekr.20060521134315.666">def wait_for_first_thread(self):

    if self.m_current_ctx != None:
        return

    try:
        self.m_threads_lock.acquire() 

        while self.m_current_ctx == None:
            self.m_threads_lock.wait(1.0)

    finally:
        self.m_threads_lock.release()
</t>
<t tx="ekr.20060521134315.667">def notify_first_thread(self):

    try:
        self.m_threads_lock.acquire()
        self.m_threads_lock.notify()
    finally:
        self.m_threads_lock.release()
</t>
<t tx="ekr.20060521134315.668">def set_exception_trap_frame(self, frame):

    while frame != None:
        code_context = self.get_code_context(frame.f_code)
        if code_context.is_exception_trap_frame():                
            code_context.m_fExceptionTrap = True
            return

        frame = frame.f_back
</t>
<t tx="ekr.20060521134315.669">def trace_dispatch_init(self, frame, event, arg):
          
    if event not in ['call', 'line', 'return']:
        return None

    code_context = self.get_code_context(frame.f_code)
    if code_context.is_untraced():
        return None
    
    self.set_exception_trap_frame(frame)

    ctx = CDebuggerCoreThread(self, frame, event)
    ctx.set_tracers()
    self.m_threads[ctx.m_thread_id] = ctx

    if len(self.m_threads) == 1:
        g_blender_text.clear()
        
        self.m_current_ctx = ctx
        self.notify_first_thread()

        if self.m_f_break_on_init:
            self.m_f_break_on_init = False
            self.request_break()

    sys.settrace(ctx.trace_dispatch_call)
    sys.setprofile(ctx.profile)
    
    if event == 'call':
        return ctx.trace_dispatch_call(frame, event, arg)
    elif hasattr(frame, 'f_trace') and (frame.f_trace != None):    
        return frame.f_trace(frame, event, arg)
    else:
        return None

</t>
<t tx="ekr.20060521134315.670">def set_all_tracers(self):

    for ctx in self.m_threads.values():
        ctx.set_tracers()
</t>
<t tx="ekr.20060521134315.671">def remove_thread(self, thread_id):

    try:
        del self.m_threads[thread_id]
        
        if self.m_current_ctx.m_thread_id == thread_id:
            self.m_current_ctx = self.m_threads.values()[0]
            
    except (KeyError, IndexError):
        pass            
</t>
<t tx="ekr.20060521134315.672">def set_break_flag(self):

    self.m_fBreak = (self.m_state_manager.get_state() == STATE_BROKEN)
</t>
<t tx="ekr.20060521134315.673">def is_break(self, ctx, frame, event = None):

    if self.m_fBreak:
        return True

    if ctx.m_fUnhandledException:
        return True
        
    if self.m_step_tid == ctx.m_thread_id:
        return True

    if self.m_next_frame == frame:
        return True

    if (self.m_return_frame == frame) and (event == 'return'):
        return True

    return False    
</t>
<t tx="ekr.20060521134315.674">def _break(self, ctx, frame, event, arg):

    if not self.is_break(ctx, frame, event) and not ctx.is_breakpoint():
        ctx.set_tracers()
        return 
        
    ctx.m_fBroken = True
    f_full_notification = False
    
    try: 
        self.m_state_manager.acquire()
        if self.m_state_manager.get_state() != STATE_BROKEN:
            self.set_break_dont_lock()
        
        if self.m_f_first_to_break or (self.m_current_ctx == ctx):                
            self.m_current_ctx = ctx
            self.m_lastest_event = event

            self.m_step_tid = None
            self.m_next_frame = None
            self.m_return_frame = None       

            self.m_bp_manager.del_temp_breakpoint()

            self.m_f_first_to_break = False
            f_full_notification = True

    finally:
        self.m_state_manager.release()

    if f_full_notification:
        self.send_events(None) 
    else:
        self.notify_thread_broken(ctx.m_thread_id)
        self.notify_namespace()

    state = self.m_state_manager.wait_for_state([STATE_RUNNING])
    
    ctx.m_fUnhandledException = False        
    ctx.m_fBroken = False 
    ctx.set_tracers()
</t>
<t tx="ekr.20060521134315.675">def notify_thread_broken(self, tid):
    
    _event = CEventThreadBroken(tid)
    self.m_event_dispatcher.fire_event(_event)

</t>
<t tx="ekr.20060521134315.676">def notify_namespace(self):
    
    _event = CEventNamespace()
    self.m_event_dispatcher.fire_event(_event)

</t>
<t tx="ekr.20060521134315.677">def get_state(self):

    return self.m_state_manager.get_state()
</t>
<t tx="ekr.20060521134315.678">def verify_broken(self):

    if self.m_state_manager.get_state() != STATE_BROKEN:
        raise DebuggerNotBroken
</t>
<t tx="ekr.20060521134315.679">def get_current_filename(self, frame_index, fException):

    ctx = self.get_current_ctx()
    
    try:
        f = None
        base_frame = ctx.frame_acquire()

        (f, frame_lineno) = ctx.get_frame(base_frame, frame_index, fException)
        frame_filename = my_abspath(f.f_code.co_filename)

        return frame_filename

    finally:
        f = None
        base_frame = None            
        ctx.frame_release()
</t>
<t tx="ekr.20060521134315.680">def get_threads(self):
    
    return self.m_threads

</t>
<t tx="ekr.20060521134315.681">def set_break_dont_lock(self):
    
    self.m_f_first_to_break = True            

    self.m_state_manager.set_state(STATE_BROKEN, fLock = False)

    self.set_break_flag()
    self.set_all_tracers()

</t>
<t tx="ekr.20060521134315.682">def request_break(self):

    if len(self.m_threads) == 0:
        self.wait_for_first_thread()
    
    try:
        self.m_state_manager.acquire()
        if self.m_state_manager.get_state() == STATE_BROKEN:
            return

        self.set_break_dont_lock()

    finally:    
        self.m_state_manager.release()

    self.send_events(None)
</t>
<t tx="ekr.20060521134315.683">def request_go(self, fLock = True):
    
    try:
        if fLock: self.m_state_manager.acquire()
            
        self.verify_broken()

        self.m_state_manager.set_state(STATE_RUNNING, fLock = False)
        self.set_break_flag()

    finally:    
        if fLock: self.m_state_manager.release()

</t>
<t tx="ekr.20060521134315.684">def request_go_breakpoint(self, filename, scope, lineno, frame_index, fException):

    try:
        self.m_state_manager.acquire()
        self.verify_broken()

        if filename in [None, '']:
            _filename = self.get_current_filename(frame_index, fException)
        elif is_blender_file(filename):
            _filename = filename
        else:
            _filename = FindFile(filename, fModules = True)

        self.m_bp_manager.set_temp_breakpoint(_filename, scope, lineno)
        self.set_all_tracers()
        self.request_go(fLock = False)

    finally:    
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.685">def request_step(self, fLock = True):
    
    try:
        if fLock: self.m_state_manager.acquire()
            
        self.verify_broken()

        try:
            ctx = self.get_current_ctx()
        except NoThreads: return
            
        self.m_step_tid = ctx.m_thread_id
        self.m_next_frame = None
        self.m_return_frame = None       
        self.request_go(fLock = False)

    finally:    
        if fLock: self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.686">def request_next(self): 

    try:
        self.m_state_manager.acquire()
        self.verify_broken()

        try:
            ctx = self.get_current_ctx()
        except NoThreads: return
            
        if self.m_lastest_event in ['return', 'exception']:
            return self.request_step(fLock = False)

        self.m_next_frame = ctx.m_frame
        self.m_return_frame = None
        self.request_go(fLock = False)

    finally:    
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.687">def request_return(self):
    
    try:
        self.m_state_manager.acquire()
        self.verify_broken()

        try:
            ctx = self.get_current_ctx()
        except NoThreads: return
            
        if self.m_lastest_event == 'return':
            return self.request_step(fLock = False)
            
        self.m_next_frame = None
        self.m_return_frame = ctx.m_frame
        self.request_go(fLock = False)

    finally:    
        self.m_state_manager.release()</t>
<t tx="ekr.20060521134315.688">def request_jump(self, lineno):
    
    try:
        self.m_state_manager.acquire()
        self.verify_broken()

        try:
            ctx = self.get_current_ctx()
        except NoThreads: return
            
        frame = ctx.m_frame
        code = frame.f_code
        valid_lines = CalcValidLines(code)
        sbi = CScopeBreakInfo('', valid_lines)
        l = sbi.CalcScopeLine(lineno)
        frame.f_lineno = l

    finally:    
        frame = None
        self.m_state_manager.release()

    self.send_events(None)</t>
<t tx="ekr.20060521134315.689">def set_thread(self, tid):

    try:
        self.m_state_manager.acquire()
        self.verify_broken()

        try:
            if (tid &gt;= 0) and (tid &lt; 100):
                _tid = self.m_threads.keys()[tid]
            else:
                _tid = tid
                
            ctx = self.m_threads[_tid]
        except (IndexError, KeyError):
            raise ThreadNotFound

        self.m_current_ctx = ctx
        self.m_lastest_event = ctx.m_event

    finally:
        self.m_state_manager.release()

    self.send_events(None) 
</t>
<t tx="ekr.20060521134315.690">class CDebuggerEngine(CDebuggerCore):
	@others
</t>
<t tx="ekr.20060521134315.691">def __init__(self):

    CDebuggerCore.__init__(self)

    event_type_dict = {
        CEventState: {}, 
        CEventStackDepth: {}, 
        CEventBreakpoint: {}, 
        CEventThreads: {},
        CEventNoThreads: {},
        CEventThreadBroken: {},
        CEventNamespace: {},
        CEventStack: {},
        CEventExit: {}
        }
    
    self.m_event_queue = CEventQueue(self.m_event_dispatcher)
    self.m_event_queue.register_event_types(event_type_dict)

    event_type_dict = {CEventSync: {}}
    self.m_event_dispatcher.register_callback(self.send_events, event_type_dict, fSingleUse = False)

    atexit.register(self.atexit)</t>
<t tx="ekr.20060521134315.692">def __del__(self):

    self.m_event_queue.shutdown()
    
    CDebuggerCore.__del__(self)
</t>
<t tx="ekr.20060521134315.693">def atexit(self):

    event = CEventExit()
    self.m_event_dispatcher.fire_event(event)
    time.sleep(1.0)
</t>
<t tx="ekr.20060521134315.694">def sync_with_events(self, fException):

    if len(self.m_threads) == 0:
        self.wait_for_first_thread()
    
    index = self.m_event_queue.get_event_index()
    event = CEventSync(fException)
    self.m_event_dispatcher.fire_event(event)
    return index
</t>
<t tx="ekr.20060521134315.695">def wait_for_event(self, timeout, nStateChange):

    self.cancel_request_go_timer()
    
    (n, sel) = self.m_event_queue.wait_for_event(timeout, nStateChange)
    return (n, sel)
</t>
<t tx="ekr.20060521134315.696">def set_breakpoint(self, filename, scope, lineno, fEnabled, expr, frame_index, fException):

    if expr != '':
        try:
            compile(expr, '', 'eval')
        except:
            raise SyntaxError

    fLock = False
    
    try:    
        if filename in [None, '']:
            self.m_state_manager.acquire()
            fLock = True
            self.verify_broken()
            _filename = self.get_current_filename(frame_index, fException)
        elif is_blender_file(filename):
            _filename = filename
        else:
            _filename = FindFile(filename, fModules = True)
            
        bp = self.m_bp_manager.set_breakpoint(_filename, scope, lineno, fEnabled, expr)
        self.set_all_tracers()

        event = CEventBreakpoint(bp)
        self.m_event_dispatcher.fire_event(event)

    finally:
        if fLock: self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.697">def disable_breakpoint(self, id_list, fAll):

    self.m_bp_manager.disable_breakpoint(id_list, fAll)
    self.set_all_tracers()

    event = CEventBreakpoint(None, CEventBreakpoint.DISABLE, id_list, fAll)
    self.m_event_dispatcher.fire_event(event)

    return 0
</t>
<t tx="ekr.20060521134315.698">def enable_breakpoint(self, id_list, fAll):

    self.m_bp_manager.enable_breakpoint(id_list, fAll)
    self.set_all_tracers()

    event = CEventBreakpoint(None, CEventBreakpoint.ENABLE, id_list, fAll)
    self.m_event_dispatcher.fire_event(event)

    return 0
</t>
<t tx="ekr.20060521134315.699">def delete_breakpoint(self, id_list, fAll):

    self.m_bp_manager.delete_breakpoint(id_list, fAll)
    self.set_all_tracers()

    event = CEventBreakpoint(None, CEventBreakpoint.REMOVE, id_list, fAll)
    self.m_event_dispatcher.fire_event(event)

    return 0
</t>
<t tx="ekr.20060521134315.700">def get_breakpoints(self):

    bpl = self.m_bp_manager.get_breakpoints()
    _items = [(id, copy.copy(bp)) for (id, bp) in bpl.items()]
    for (id, bp) in _items:
        bp.m_code = None
        
    _bpl = dict(_items)
    
    return _bpl        
</t>
<t tx="ekr.20060521134315.701">def send_events(self, event):

    if isinstance(event, CEventSync):
        fException = event.m_fException
    else:
        fException = False

    #traceback.print_stack()
    
    try:
        self.send_stack_depth()
        self.send_threads_event(fException)
        self.send_stack_event(fException)
        self.send_namespace_event()

    except NoThreads:
        self.send_no_threads_event()

    except:
        print_debug()
        raise
</t>
<t tx="ekr.20060521134315.702">def send_stack_depth(self):

    ctx = self.get_current_ctx()
    try:
        try:
            f = None
            f = ctx.frame_acquire()
        except ThreadDone: return

        try:
            g_traceback_lock.acquire()
            s = traceback.extract_stack(f)
        finally: g_traceback_lock.release()

        stack_depth = len(s)
        if f.f_exc_traceback == None:
            stack_depth_exception = None
        else:    
            try:
                g_traceback_lock.acquire()
                _s = traceback.extract_tb(f.f_exc_traceback)
            finally: g_traceback_lock.release()
            stack_depth_exception = stack_depth + len(_s) - 1

        event = CEventStackDepth(stack_depth, stack_depth_exception)
        self.m_event_dispatcher.fire_event(event)
    finally:
        f = None
        ctx.frame_release()</t>
<t tx="ekr.20060521134315.703">def send_threads_event(self, fException):

    tl = self.get_thread_list()
        
    if fException:
        ctid = tl[0]
        itl = tl[1]
        _itl = [a for a in itl if a[DICT_KEY_TID] == ctid]
        _tl = (ctid, _itl)
    else:
        _tl = tl

    event = CEventThreads(*_tl)
    self.m_event_dispatcher.fire_event(event)</t>
<t tx="ekr.20060521134315.704">def send_stack_event(self, fException):

    sl = self.get_stack([], False, fException)

    if len(sl) == 0:
        return
        
    event = CEventStack(sl[0])
    self.m_event_dispatcher.fire_event(event)
</t>
<t tx="ekr.20060521134315.705">def send_namespace_event(self):

    event = CEventNamespace()
    self.m_event_dispatcher.fire_event(event)
</t>
<t tx="ekr.20060521134315.706">def send_no_threads_event(self):

    _event = CEventNoThreads()
    self.m_event_dispatcher.fire_event(_event)
</t>
<t tx="ekr.20060521134315.707">def __get_stack(self, ctx, ctid, fException):
    tid = ctx.m_thread_id    

    try:
        try:
            f = None
            f = ctx.frame_acquire()
        except ThreadDone: return None

        _f = f
        try:
            g_traceback_lock.acquire()
            s = traceback.extract_stack(f)
        finally: g_traceback_lock.release()

        if fException: 
            if f.f_exc_traceback == None:
                raise NoExceptionFound

            _tb = f.f_exc_traceback
            while _tb.tb_next != None:
                _tb = _tb.tb_next
            _f = _tb.tb_frame    
            try:
                g_traceback_lock.acquire()
                _s = traceback.extract_tb(f.f_exc_traceback)
            finally: g_traceback_lock.release()
            s = s[:-1] + _s

        code_list = []
        while _f != None:
            rc = repr(_f.f_code).split(',')[0].split()[-1]
            code_list.insert(0, rc)
            _f = _f.f_back
    finally:
        f = None
        _f = None
        ctx.frame_release()

    #print code_list

    __s = [(my_abspath(a), b, c, d) for (a, b, c, d) in s]

    if (ctx.m_uef_lineno != None) and (len(__s) &gt; 0):
        (a, b, c, d) = __s[0]
        __s = [(a, ctx.m_uef_lineno, c, d)] + __s[1:] 
        
    r = {}
    r[DICT_KEY_STACK] = __s
    r[DICT_KEY_CODE_LIST] = code_list
    r[DICT_KEY_TID] = tid
    r[DICT_KEY_BROKEN] = ctx.m_fBroken
    r[DICT_KEY_EVENT] = ctx.m_event
    
    if tid == ctid:
        r[DICT_KEY_CURRENT_TID] = True
        
    return r</t>
<t tx="ekr.20060521134315.708">def get_stack(self, tid_list, fAll, fException):

    if fException and (fAll or (len(tid_list) != 0)):
        raise BadArgument

    ctx = self.get_current_ctx()       
    ctid = ctx.m_thread_id

    if fAll:
        ctx_list = self.get_threads().values()
    elif fException or (len(tid_list) == 0):
        ctx_list = [ctx]
    else:
        ctx_list = [self.get_threads().get(t, None) for t in tid_list]

    _sl = [self.__get_stack(ctx, ctid, fException) for ctx in ctx_list if ctx != None]
    sl = [s for s in _sl if s != None] 
    
    return sl
</t>
<t tx="ekr.20060521134315.709">def get_source_file(self, filename, lineno, nlines, frame_index, fException):

    if lineno &lt; 1:
        lineno = 1
        nlines = -1

    #if (filename != '') and not IsPythonSourceFile(filename):
    #    raise IOError  
    _lineno = lineno
    r = {}
    frame_filename = None
    
    try:
        ctx = self.get_current_ctx()
        try:
            f = None
            base_frame = None
            base_frame = ctx.frame_acquire()
            (f, frame_lineno) = ctx.get_frame(base_frame, frame_index, fException)
            frame_filename = my_abspath(f.f_code.co_filename)
        finally:
            f = None
            base_frame = None            
            ctx.frame_release()
        frame_event = [[ctx.m_event, 'call'][frame_index &gt; 0], 'exception'][fException]
    except NoThreads:
        if filename in [None, '']:
            raise

    fBlender = False
    
    if filename in [None, '']:
        __filename = frame_filename
        r[DICT_KEY_TID] = ctx.m_thread_id
    elif is_blender_file(filename):
        fBlender = True
        __filename = filename
    else:    
        __filename = FindFile(filename, fModules = True)

    _filename = winlower(__filename)    

    lines = []
    breakpoints = {}
    
    while nlines != 0:
        try:
            g_traceback_lock.acquire()
            line = get_source_line(_filename, _lineno, fBlender)
        finally:    
            g_traceback_lock.release()

        if line == '':
            break

        lines.append(line)

        try:
            bp = self.m_bp_manager.get_breakpoint(_filename, _lineno)
            breakpoints[_lineno] = [STATE_DISABLED, STATE_ENABLED][bp.isEnabled()]
        except KeyError:
            pass
            
        _lineno += 1
        nlines -= 1

    if frame_filename == _filename:
        r[DICT_KEY_FRAME_LINENO] = frame_lineno
        r[DICT_KEY_EVENT] = frame_event
        r[DICT_KEY_BROKEN] = ctx.m_fBroken
        
    r[DICT_KEY_LINES] = lines
    r[DICT_KEY_FILENAME] = _filename
    r[DICT_KEY_BREAKPOINTS] = breakpoints
    r[DICT_KEY_FIRST_LINENO] = lineno
    
    return r</t>
<t tx="ekr.20060521134315.710">def __get_source(self, ctx, nlines, frame_index, fException):
    tid = ctx.m_thread_id
    _frame_index = [0, frame_index][tid == self.m_current_ctx.m_thread_id]

    try:
        try:
            f = None
            base_frame = None
            
            base_frame = ctx.frame_acquire()
            (f, frame_lineno)  = ctx.get_frame(base_frame, _frame_index, fException)
            frame_filename = my_abspath(f.f_code.co_filename)
            
        except (ThreadDone, InvalidFrame):
            return None

    finally:
        f = None
        base_frame = None            
        ctx.frame_release()
        
    frame_event = [[ctx.m_event, 'call'][frame_index &gt; 0], 'exception'][fException]

    first_line = max(1, frame_lineno - nlines / 2)     
    _lineno = first_line

    fBlender = is_blender_file(frame_filename)
    lines = []
    breakpoints = {}
    
    while nlines != 0:
        try:
            g_traceback_lock.acquire()
            line = get_source_line(frame_filename, _lineno, fBlender)
            
        finally:    
            g_traceback_lock.release()

        if line == '':
            break

        lines.append(line)

        try:
            bp = self.m_bp_manager.get_breakpoint(frame_filename, _lineno)
            breakpoints[_lineno] = [STATE_DISABLED, STATE_ENABLED][bp.isEnabled()]
        except KeyError:
            pass
            
        _lineno += 1
        nlines -= 1

    r = {}
    
    r[DICT_KEY_FRAME_LINENO] = frame_lineno
    r[DICT_KEY_EVENT] = frame_event
    r[DICT_KEY_BROKEN] = ctx.m_fBroken
    r[DICT_KEY_TID] = tid
    r[DICT_KEY_LINES] = lines
    r[DICT_KEY_FILENAME] = frame_filename
    r[DICT_KEY_BREAKPOINTS] = breakpoints
    r[DICT_KEY_FIRST_LINENO] = first_line
    
    return r
</t>
<t tx="ekr.20060521134315.711">def get_source_lines(self, nlines, fAll, frame_index, fException):

    if fException and fAll:
        raise BadArgument
        
    if fAll:
        ctx_list = self.get_threads().values()
    else:
        ctx = self.get_current_ctx()
        ctx_list = [ctx]

    _sl = [self.__get_source(ctx, nlines, frame_index, fException) for ctx in ctx_list]
    sl = [s for s in _sl if s != None]    

    return sl
</t>
<t tx="ekr.20060521134315.712">def __get_locals_globals(self, frame_index, fException, fReadOnly = False):

    ctx = self.get_current_ctx()
    (_globals, _locals) = ctx.get_locals_copy(frame_index, fException, fReadOnly)

    return (_globals, _locals)
</t>
<t tx="ekr.20060521134315.713">def __is_verbose_attr(self, r, a):
    try:
        v = getattr(r, a)
    except AttributeError:
        return True
        
    if a == '__class__':
        if self.__parse_type(type(v)) != 'type':
            return False

        #return self.__parse_type(v) in BASIC_TYPES_LIST

    if (a == '__bases__'):
        if (type(v) == tuple) and (len(v) &gt; 0):    
            return False

    if a in ['__name__', '__file__', '__doc__']:
        return False
    
    if a.startswith('__') and a.endswith('__'):
        return True
    
    if self.__is_property_attr(r, a):
        return True
        
    t = self.__parse_type(type(v))

    if ('method' in t) and not ('builtin' in t):
        return True

    return False    
</t>
<t tx="ekr.20060521134315.714">def __is_property_attr(self, r, a):
    if a.startswith('__') and a.endswith('__'):
        return False

    try:
        v = getattr(r, a)            
    except AttributeError:
        return False
        
    t = self.__parse_type(type(v))
    
    if 'descriptor' in t:
        return True
        
    if t == 'property':
        return True
        
    return False    
</t>
<t tx="ekr.20060521134315.715">def __calc_property_list(self, r):
    pl = [a for a in r.__dict__.keys() if self.__is_property_attr(r, a)]

    for b in r.__bases__:
        if (self.__parse_type(type(b)) == 'type') and (self.__parse_type(b) == 'object'):
            continue

        pl += self.__calc_property_list(b)

    return pl    
</t>
<t tx="ekr.20060521134315.716">def __calc_attribute_list(self, r):
    if hasattr(r, '__dict__'):
        al = r.__dict__.keys()
    else:
        al = [a for a in dir(r)]

    if hasattr(r, '__class__') and not '__class__' in al:
        al = ['__class__'] + al

    if hasattr(r, '__bases__') and not '__bases__' in al:
        al = ['__bases__'] + al

    if hasattr(r, '__class__'):
        pl = self.__calc_property_list(r.__class__)
        _pl = [p for p in pl if not p in al]
        
        al += _pl

    _al = [a for a in al if hasattr(r, a)]           
    __al = [a for a in _al if not self.__is_verbose_attr(r, a)]    

    return __al
</t>
<t tx="ekr.20060521134315.717">def __calc_number_of_subnodes(self, r):
    if self.__parse_type(type(r)) in BASIC_TYPES_LIST:
        return 0
        
    if type(r) in [dict, list, tuple]:
        return len(r)

    if isinstance(r, dict):
        return len(r)

    if isinstance(r, list):
        return len(r)

    if isinstance(r, tuple):
        return len(r)

    return len(self.__calc_attribute_list(r))
</t>
<t tx="ekr.20060521134315.718">def __parse_type(self, t):
    rt = repr(t)
    st = rt.split("'")[1]
    return st
</t>
<t tx="ekr.20060521134315.719">def __calc_subnodes(self, expr, r, fForceNames, fFilter):
    snl = []
    
    if (type(r) in [list, tuple]) or isinstance(r, list) or isinstance(r, tuple):
        for i, v in enumerate(r):
            e = {}
            e[DICT_KEY_EXPR] = '%s[%d]' % (expr, i)
            e[DICT_KEY_NAME] = repr(i)
            e[DICT_KEY_REPR] = safe_repr_limited(v)
            e[DICT_KEY_TYPE] = self.__parse_type(type(v))
            e[DICT_KEY_N_SUBNODES] = self.__calc_number_of_subnodes(v)

            snl.append(e)

        return snl

    if (type(r) == dict) or isinstance(r, dict):
        for k, v in r.items():
            rt = self.__parse_type(type(v))
            if fFilter and (rt in ['function', 'module', 'classobj']):
                continue
                
            e = {}
            e[DICT_KEY_EXPR] = '%s[%s]' % (expr, repr(k))
            e[DICT_KEY_NAME] = [repr(k), k][fForceNames]
            e[DICT_KEY_REPR] = safe_repr_limited(v)
            e[DICT_KEY_TYPE] = rt
            e[DICT_KEY_N_SUBNODES] = self.__calc_number_of_subnodes(v)

            snl.append(e)

        return snl            

    al = self.__calc_attribute_list(r)
    for a in al:
        try:
            v = getattr(r, a)
        except AttributeError:
            continue
        
        e = {}
        e[DICT_KEY_EXPR] = '%s.%s' % (expr, a)
        e[DICT_KEY_NAME] = a
        e[DICT_KEY_REPR] = safe_repr_limited(v)
        e[DICT_KEY_TYPE] = self.__parse_type(type(v))
        e[DICT_KEY_N_SUBNODES] = self.__calc_number_of_subnodes(v)

        snl.append(e)

    return snl                
</t>
<t tx="ekr.20060521134315.720">def get_exception(self, frame_index, fException):
    ctx = self.get_current_ctx()

    try:
        f = None
        base_frame = None
        
        base_frame = ctx.frame_acquire()
        (f, frame_lineno) = ctx.get_frame(base_frame, frame_index, fException)

        e = {'type': f.f_exc_type, 'value': f.f_exc_value, 'traceback': f.f_exc_traceback}

        return e
        
    finally:
        f = None
        base_frame = None            
        ctx.frame_release()
</t>
<t tx="ekr.20060521134315.721">def get_namespace(self, nl, fFilter, frame_index, fException):
    try:
        (_globals, _locals) = self.__get_locals_globals(frame_index, fException, fReadOnly = True)
    except:    
        print_debug()
        raise

    rl = []
    for (expr, fExpand) in nl:
        e = {}

        try:
            __globals = _globals
            __locals = _locals
            
            if RPDB_EXEC_INFO in expr:
                rpdb_exception_info = self.get_exception(frame_index, fException)
                __globals = globals()
                __locals = locals()
                
            r = eval(expr, __globals, __locals)

            e[DICT_KEY_EXPR] = expr
            e[DICT_KEY_REPR] = safe_repr_limited(r)
            e[DICT_KEY_TYPE] = self.__parse_type(type(r))
            e[DICT_KEY_N_SUBNODES] = self.__calc_number_of_subnodes(r)

            if fExpand and (DICT_KEY_SUBNODES &gt; 0):
                fForceNames = (expr in ['globals()', 'locals()']) or (RPDB_EXEC_INFO in expr)
                _fFilter = fFilter and (expr == 'globals()')
                e[DICT_KEY_SUBNODES] = self.__calc_subnodes(expr, r, fForceNames, _fFilter)
                
        except:
            print_debug()
            e[DICT_KEY_ERROR] = repr(sys.exc_info())
        
        rl.append(e)

    return rl 
</t>
<t tx="ekr.20060521134315.722">def evaluate(self, expr, frame_index, fException):

    (_globals, _locals) = self.__get_locals_globals(frame_index, fException)

    v = ''
    w = ''
    e = ''

    try:
        r = eval(expr, _globals, _locals)
        v = safe_repr(r)
    except:
        exc_info = sys.exc_info()
        e = "%s, %s" % (str(exc_info[0]), str(exc_info[1]))

    self.notify_namespace()

    return (v, w, e)
</t>
<t tx="ekr.20060521134315.723">def execute(self, suite, frame_index, fException):

    (_globals, _locals) = self.__get_locals_globals(frame_index, fException)

    w = ''
    e = ''

    try:    
        exec suite in _globals, _locals
    except:    
        exc_info = sys.exc_info()
        e = "%s, %s" % (str(exc_info[0]), str(exc_info[1]))

    self.notify_namespace()
    
    return (w, e)
</t>
<t tx="ekr.20060521134315.724">def get_thread_list(self):

    ctx = self.get_current_ctx()
    
    if ctx == None:
        current_thread_id = -1
    else:
        current_thread_id = ctx.m_thread_id  
        
    ctx_list = self.get_threads().values()
    tl = [{DICT_KEY_TID: c.m_thread_id, DICT_KEY_BROKEN: c.m_fBroken, DICT_KEY_EVENT: c.m_event} for c in ctx_list]

    return (current_thread_id, tl)
</t>
<t tx="ekr.20060521134315.725">def stop_debuggee(self):

    self.atexit()
    threading.Thread(target = self._abort).start()

def _abort(self):

    time.sleep(1.0)
    os.abort()</t>
<t tx="ekr.20060521134315.726"></t>
<t tx="ekr.20060521134315.727">class CWorkQueue:

	@others
</t>
<t tx="ekr.20060521134315.728">def __init__(self, n_threads):

    self.m_lock = threading.Condition()
    self.m_work_items = []
    self.m_f_shutdown = False
    self.m_n_threads = 0
    
    for n in range(n_threads):
        t = threading.Thread(target = self.worker_target)
        t.setDaemon(1)
        t.start()
</t>
<t tx="ekr.20060521134315.729">def shutdown(self):

    self.m_lock.acquire()
    self.m_f_shutdown = True
    self.m_lock.notifyAll()

    while self.m_n_threads &gt; 0:
        self.m_lock.wait()
        
    self.m_lock.release()
</t>
<t tx="ekr.20060521134315.730">def worker_target(self): 

    # Turn tracing off. We don't want debugger threads traced.
    sys.settrace(None)
    sys.setprofile(None)
    try:
        self.m_lock.acquire()
        self.m_n_threads += 1

        while not self.m_f_shutdown:
            self.m_lock.wait()
            if self.m_f_shutdown:
                break
            if len(self.m_work_items) == 0:
                continue
            (target, args) = self.m_work_items.pop()
            self.m_lock.release()
            try:
                target(*args)
            except:
                print_debug()

            self.m_lock.acquire()    
        self.m_n_threads -= 1
        self.m_lock.notifyAll()
    finally:
        self.m_lock.release()</t>
<t tx="ekr.20060521134315.731">def post_work_item(self, target, args):

    try:
        self.m_lock.acquire()
        self.m_work_items.append((target, args))
        self.m_lock.notify()
    finally:
        self.m_lock.release()</t>
<t tx="ekr.20060521134315.732">                
        
            
class CUnTracedThreadingMixIn(SocketServer.ThreadingMixIn):
	@others
</t>
<t tx="ekr.20060521134315.733">def init_work_queue(self):
    self.m_work_queue = CWorkQueue(N_WORK_QUEUE_THREADS)
</t>
<t tx="ekr.20060521134315.734">def shutdown_work_queue(self):
    self.m_work_queue.shutdown()
</t>
<t tx="ekr.20060521134315.735">def process_request(self, request, client_address):
    self.m_work_queue.post_work_item(target = SocketServer.ThreadingMixIn.process_request_thread, args = (self, request, client_address))
</t>
<t tx="ekr.20060521134315.736">def my_xmlrpclib_loads(data):
    """data -&gt; unmarshalled data, method name

    Convert an XML-RPC packet to unmarshalled data plus a method
    name (None if not present).

    If the XML-RPC packet represents a fault condition, this function
    raises a Fault exception.
    """
    p, u = xmlrpclib.getparser()
    p.feed(data)
    p.close()
    return u.close(), u.getmethodname()
</t>
<t tx="ekr.20060521134315.737">


class CXMLRPCServer(CUnTracedThreadingMixIn, SimpleXMLRPCServer.SimpleXMLRPCServer):
	@others

    if sys.version_info[:2] &lt;= (2, 3):
        _marshaled_dispatch = __marshaled_dispatch</t>
<t tx="ekr.20060521134315.738">def __marshaled_dispatch(self, data, dispatch_method = None):
    """Dispatches an XML-RPC method from marshalled (XML) data.

    XML-RPC methods are dispatched from the marshalled (XML) data
    using the _dispatch method and the result is returned as
    marshalled data. For backwards compatibility, a dispatch
    function can be provided as an argument (see comment in
    SimpleXMLRPCRequestHandler.do_POST) but overriding the
    existing method through subclassing is the prefered means
    of changing method dispatch behavior.
    """

    params, method = my_xmlrpclib_loads(data)

    # generate response
    try:
        if dispatch_method is not None:
            response = dispatch_method(method, params)
        else:
            response = self._dispatch(method, params)
        # wrap response in a singleton tuple
        response = (response,)
        response = xmlrpclib.dumps(response, methodresponse=1)
    except xmlrpclib.Fault, fault:
        response = xmlrpclib.dumps(fault)
    except:
        # report exception back to server
        response = xmlrpclib.dumps(
            xmlrpclib.Fault(1, "%s:%s" % (sys.exc_type, sys.exc_value))
            )
        print_debug()

    return response
</t>
<t tx="ekr.20060521134315.739">



class CPwdServerProxy:
	@others
</t>
<t tx="ekr.20060521134315.740">def __init__(self, crypto, uri, transport = None, target_rid = 0):
    self.m_crypto = crypto       
    self.m_proxy = xmlrpclib.ServerProxy(uri, transport)

    self.m_fEncryption = is_encryption_supported()
    self.m_target_rid = target_rid

    self.m_method = getattr(self.m_proxy, DISPACHER_METHOD)
</t>
<t tx="ekr.20060521134315.741">def __set_encryption(self, fEncryption):
    self.m_fEncryption = fEncryption
</t>
<t tx="ekr.20060521134315.742">def get_encryption(self):
    return self.m_fEncryption
</t>
<t tx="ekr.20060521134315.743">def __request(self, name, params):
    while True:
        try:
            _params = self.m_crypto.do_crypto((name, params, self.m_target_rid), self.get_encryption())

            rpdb_version = get_interface_compatibility_version()

            r = self.m_method(rpdb_version + _params)

            ((max_index, _r, e), fe)= self.m_crypto.undo_crypto(r, fVerifyIndex = False)

            if e != None:
                raise e

        except AuthenticationBadIndex, e:
            self.m_crypto.set_index(e.m_max_index, e.m_anchor)
            continue

        except xmlrpclib.Fault, fault:
            if str(BadVersion) in fault.faultString:
                s = fault.faultString.split("'")
                version = ['', s[1]][len(s) &gt; 0]
                raise BadVersion(version)
            if str(EncryptionExpected) in fault.faultString:
                raise EncryptionExpected
            elif str(EncryptionNotSupported) in fault.faultString:
                if self.m_crypto.m_fAllowUnencrypted:
                    self.__set_encryption(False)
                    continue
                raise EncryptionNotSupported
            elif str(DecryptionFailure) in fault.faultString:
                raise DecryptionFailure
            elif str(AuthenticationBadData) in fault.faultString:
                raise AuthenticationBadData
            elif str(AuthenticationFailure) in fault.faultString:
                raise AuthenticationFailure
            else:
                print_debug()
                assert False 

        except xmlrpclib.ProtocolError:
            print_debug()
            raise CConnectionException
            
        return _r
</t>
<t tx="ekr.20060521134315.744">def __getattr__(self, name):
    return xmlrpclib._Method(self.__request, name)
</t>
<t tx="ekr.20060521134315.745">class CIOServer(threading.Thread):

	@others
</t>
<t tx="ekr.20060521134315.746">def __init__(self, pwd, fAllowUnencrypted, fRemote, rid):
    threading.Thread.__init__(self)

    self.m_crypto = CCrypto(pwd, fAllowUnencrypted, rid)
    
    self.m_fRemote = fRemote
    self.m_rid = rid
    
    self.m_port = None
    self.m_stop = False
    self.m_server = None
    
    self.setDaemon(True)
</t>
<t tx="ekr.20060521134315.747">def __del__(self):
    self.stop()
</t>
<t tx="ekr.20060521134315.748">def stop(self):
    if self.m_stop:
        return
        
    self.m_stop = True

    try:
        proxy = CPwdServerProxy(self.m_crypto, calcURL("localhost", self.m_port))
        proxy.null()
    except (socket.error, CException):
        pass

    self.join()

    self.m_server.shutdown_work_queue()
    self.m_server = None
</t>
<t tx="ekr.20060521134315.749">def export_null(self):
    return 0
</t>
<t tx="ekr.20060521134315.750">def run(self):
    #
    # Turn tracing off. We don't want debugger threads traced.
    #

    sys.settrace(None)
    sys.setprofile(None)
    
    (self.m_port, self.m_server) = self.__StartXMLRPCServer()

    self.m_server.init_work_queue()
    self.m_server.register_function(self.dispatcher_method)        
    
    while not self.m_stop:
        self.m_server.handle_request()
</t>
<t tx="ekr.20060521134315.751">def dispatcher_method(self, params):
    r = None
    e = None

    rpdb_version = get_interface_compatibility_version()

    if params[: len(rpdb_version)] != rpdb_version:
        raise BadVersion(get_version())

    _params = params[len(rpdb_version):]
        
    try:
        ((name, _params, target_rid), fEncryption) = self.m_crypto.undo_crypto(_params)
    except AuthenticationBadIndex, _e:
        print_debug()
        e = _e 
        fEncryption = self.m_crypto.is_encrypted(_params)                           

    if e == None:
        try:
            # We are forcing the 'export_' prefix on methods that are
            # callable through XML-RPC to prevent potential security
            # problems
            func = getattr(self, 'export_' + name)
        except AttributeError:
            raise Exception('method "%s" is not supported' % ('export_' + name, ))

        try:
            if (target_rid != 0) and (target_rid != self.m_rid):
                raise NotAttached
                
            r = func(*_params)
        except Exception, _e:
            print_debug()
            e = _e            

    max_index = self.m_crypto.get_max_index()

    _r = self.m_crypto.do_crypto((max_index, r, e), fEncryption)

    return _r
</t>
<t tx="ekr.20060521134315.752">def __StartXMLRPCServer(self):
    host = [LOCAL_HOST, ""][self.m_fRemote]
    port = SERVER_PORT_RANGE_START

    while True:
        try:
            server = CXMLRPCServer((host, port), logRequests = 0)
            
            return (port, server)
        except socket.error, e:
            if not GetSocketError(e) in [ERROR_SOCKET_ADDRESS_IN_USE_WIN, ERROR_SOCKET_ADDRESS_IN_USE_UNIX, ERROR_SOCKET_ADDRESS_IN_USE_MAC]:
                raise
                
            if port &gt;= SERVER_PORT_RANGE_START + SERVER_PORT_RANGE_LENGTH - 1:
                raise

            port += 1
            continue
</t>
<t tx="ekr.20060521134315.753">


class CServerInfo:
	@others
</t>
<t tx="ekr.20060521134315.754">def __init__(self, age, port, pid, filename, rid, state):
    self.m_age = age 
    self.m_port = port
    self.m_pid = pid
    self.m_filename = filename
    self.m_module_name = CalcModuleName(filename)
    self.m_rid = rid
    self.m_state = state
</t>
<t tx="ekr.20060521134315.755">def __str__(self):
    return 'age: %d, port: %d, pid: %d, filename: %s, rid: %s' % (self.m_age, self.m_port, self.m_pid, self.m_filename, self.m_rid)
</t>
<t tx="ekr.20060521134315.756">class CDebuggeeServer(CIOServer):
	@others
</t>
<t tx="ekr.20060521134315.757">def __init__(self, filename, debugger, pwd, fAllowUnencrypted, fRemote, rid = None):
    if rid == None:
        rid = generate_rid()
        
    CIOServer.__init__(self, pwd, fAllowUnencrypted, fRemote, rid)
    
    self.m_filename = filename
    self.m_pid = _getpid()
    self.m_time = time.time()
    self.m_debugger = debugger
    self.m_rid = rid
</t>
<t tx="ekr.20060521134315.758">def export_server_info(self):
    age = time.time() - self.m_time
    state = self.m_debugger.get_state()
    si = CServerInfo(age, self.m_port, self.m_pid, self.m_filename, self.m_rid, state)
    return si
</t>
<t tx="ekr.20060521134315.759">def export_sync_with_events(self, fException):
    ei = self.m_debugger.sync_with_events(fException)
    return ei
</t>
<t tx="ekr.20060521134315.760">def export_wait_for_event(self, timeout, nStateChange):
    (n, s) = self.m_debugger.wait_for_event(timeout, nStateChange)
    return (n, s)
</t>
<t tx="ekr.20060521134315.761">def export_set_breakpoint(self, filename, scope, lineno, fEnabled, expr, frame_index, fException):
    self.m_debugger.set_breakpoint(filename, scope, lineno, fEnabled, expr, frame_index, fException)
    return 0
</t>
<t tx="ekr.20060521134315.762">def export_disable_breakpoint(self, id_list, fAll):
    self.m_debugger.disable_breakpoint(id_list, fAll)
    return 0
</t>
<t tx="ekr.20060521134315.763">def export_enable_breakpoint(self, id_list, fAll):
    self.m_debugger.enable_breakpoint(id_list, fAll)
    return 0
</t>
<t tx="ekr.20060521134315.764">def export_delete_breakpoint(self, id_list, fAll):
    self.m_debugger.delete_breakpoint(id_list, fAll)
    return 0
</t>
<t tx="ekr.20060521134315.765">def export_get_breakpoints(self):
    bpl = self.m_debugger.get_breakpoints()
    return bpl
</t>
<t tx="ekr.20060521134315.766">def export_request_break(self):
    self.m_debugger.request_break()
    return 0
</t>
<t tx="ekr.20060521134315.767">def export_request_go(self):
    self.m_debugger.request_go()
    return 0
</t>
<t tx="ekr.20060521134315.768">def export_request_go_breakpoint(self, filename, scope, lineno, frame_index, fException):
    self.m_debugger.request_go_breakpoint(filename, scope, lineno, frame_index, fException)
    return 0
</t>
<t tx="ekr.20060521134315.769">def export_request_step(self):
    self.m_debugger.request_step()
    return 0
</t>
<t tx="ekr.20060521134315.770">def export_request_next(self):
    self.m_debugger.request_next()
    return 0
</t>
<t tx="ekr.20060521134315.771">def export_request_return(self):
    self.m_debugger.request_return()
    return 0
</t>
<t tx="ekr.20060521134315.772">def export_request_jump(self, lineno):
    self.m_debugger.request_jump(lineno)
    return 0
</t>
<t tx="ekr.20060521134315.773">def export_get_stack(self, tid_list, fAll, fException):
    r = self.m_debugger.get_stack(tid_list, fAll, fException)                 
    return r
</t>
<t tx="ekr.20060521134315.774">def export_get_source_file(self, filename, lineno, nlines, frame_index, fException): 
    r = self.m_debugger.get_source_file(filename, lineno, nlines, frame_index, fException)
    return r
</t>
<t tx="ekr.20060521134315.775">def export_get_source_lines(self, nlines, fAll, frame_index, fException): 
    r = self.m_debugger.get_source_lines(nlines, fAll, frame_index, fException)
    return r
</t>
<t tx="ekr.20060521134315.776">def export_get_thread_list(self):
    r = self.m_debugger.get_thread_list()
    return r
</t>
<t tx="ekr.20060521134315.777">def export_set_thread(self, tid):
    self.m_debugger.set_thread(tid)   
    return 0
</t>
<t tx="ekr.20060521134315.778">def export_get_namespace(self, nl, fFilter, frame_index, fException):
    r = self.m_debugger.get_namespace(nl, fFilter, frame_index, fException)
    return r
</t>
<t tx="ekr.20060521134315.779">def export_evaluate(self, expr, frame_index, fException):
    (v, w, e) = self.m_debugger.evaluate(expr, frame_index, fException)
    return (v, w, e)
</t>
<t tx="ekr.20060521134315.780">def export_execute(self, suite, frame_index, fException):
    (w, e) = self.m_debugger.execute(suite, frame_index, fException)
    return (w, e)
</t>
<t tx="ekr.20060521134315.781">def export_stop_debuggee(self):
    self.m_debugger.stop_debuggee()
    return 0
</t>
<t tx="ekr.20060521134315.782"></t>
<t tx="ekr.20060521134315.783">class CTimeoutHTTPConnection(httplib.HTTPConnection):
	@others
</t>
<t tx="ekr.20060521134315.784">def connect(self):
    """Connect to the host and port specified in __init__."""
    msg = "getaddrinfo returns an empty list"
    for res in socket.getaddrinfo(self.host, self.port, 0,
                                  socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            self.sock = socket.socket(af, socktype, proto)
            self.sock.settimeout(PING_TIMEOUT)
            if self.debuglevel &gt; 0:
                print &gt;&gt; sys.__stderr__, "connect: (%s, %s)" % (self.host, self.port)
            self.sock.connect(sa)
        except socket.error, msg:
            if self.debuglevel &gt; 0:
                print &gt;&gt; sys.__stderr__, 'connect fail:', (self.host, self.port)
            if self.sock:
                self.sock.close()
            self.sock = None
            continue
        break
    if not self.sock:
        raise socket.error, msg
</t>
<t tx="ekr.20060521134315.785">


class CTimeoutHTTP(httplib.HTTP):
	&lt;&lt; class CTimeoutHTTP declarations &gt;&gt;
</t>
<t tx="ekr.20060521134315.786">_connection_class = CTimeoutHTTPConnection


    
</t>
<t tx="ekr.20060521134315.787">class CTimeoutTransport(xmlrpclib.Transport):
	@others
</t>
<t tx="ekr.20060521134315.788">def make_connection(self, host):
    # create a HTTP connection object from a host descriptor
    host, extra_headers, x509 = self.get_host_info(host)
    return CTimeoutHTTP(host)
</t>
<t tx="ekr.20060521134315.789">
    
    
class CSession:
	@others
</t>
<t tx="ekr.20060521134315.790">def __init__(self, host, port, pwd, fAllowUnencrypted, rid):
    self.m_crypto = CCrypto(pwd, fAllowUnencrypted, rid)

    self.m_host = host
    self.m_port = port
    self.m_proxy = None
    self.m_server_info = None
    self.m_exc_info = None

    self.m_fShutDown = False
</t>
<t tx="ekr.20060521134315.791">def get_encryption(self):
    return self.m_proxy.get_encryption()
</t>
<t tx="ekr.20060521134315.792">def getServerInfo(self):
    return self.m_server_info
</t>
<t tx="ekr.20060521134315.793">def shut_down(self):
    self.m_fShutDown = True
</t>
<t tx="ekr.20060521134315.794">def getProxy(self):
    if self.m_fShutDown:
        raise NotAttached
        
    return self.m_proxy
</t>
<t tx="ekr.20060521134315.795">def Connect(self):
    server = CPwdServerProxy(self.m_crypto, calcURL(self.m_host, self.m_port), CTimeoutTransport())
    server_info = server.server_info()

    self.m_proxy = CPwdServerProxy(self.m_crypto, calcURL(self.m_host, self.m_port), target_rid = server_info.m_rid)
    self.m_server_info = server_info
</t>
<t tx="ekr.20060521134315.796">def ConnectNoThrow(self):
    try:
        self.Connect()
    except:
        #print_debug()
        self.m_exc_info = sys.exc_info() 
</t>
<t tx="ekr.20060521134315.797">def ConnectAsync(self):
    t = threading.Thread(target = self.ConnectNoThrow)
    t.setDaemon(True)
    t.start()
    return t
</t>
<t tx="ekr.20060521134315.798">def isConnected(self):
    return self.m_proxy != None
</t>
<t tx="ekr.20060521134315.799">
    

class CServerList:
	@others
</t>
<t tx="ekr.20060521134315.800">def __init__(self, host):
    self.m_host = host
    self.m_list = []
    self.m_errors = {}
</t>
<t tx="ekr.20060521134315.801">def calcList(self, pwd, rid, report_exception):
    sil = []
    sessions = []
    self.m_errors = {}

    port = SERVER_PORT_RANGE_START
    while port &lt; SERVER_PORT_RANGE_START + SERVER_PORT_RANGE_LENGTH:
        s = CSession(self.m_host, port, pwd, fAllowUnencrypted = True, rid = rid)
        t = s.ConnectAsync()
        sessions.append((s, t))

        port += 1

    for (s, t) in sessions:
        t.join()

        if (s.m_exc_info != None):
            #print &gt;&gt; sys.__stderr__, s.m_exc_info[0]
            if issubclass(s.m_exc_info[0], CException):
                _i = self.m_errors.get(s.m_exc_info[0], 0)
                self.m_errors[s.m_exc_info[0]] = _i + 1
                report_exception(*s.m_exc_info)

            continue

        si = s.getServerInfo()
        if si != None:
            sil.append((-si.m_age, si))
    
    sil.sort()
    self.m_list = [s[1] for s in sil]
    return self.m_list 
</t>
<t tx="ekr.20060521134315.802">def get_errors(self):
    return self.m_errors
</t>
<t tx="ekr.20060521134315.803">def findServers(self, key):
    fname = False

    try:
        n = int(key)
    except ValueError:   
        fname = True

    if fname:
        _s = [s for s in self.m_list if key in s.m_filename]
    else:
        _s = [s for s in self.m_list if (s.m_pid == n) or (s.m_rid == key)]

    if _s == []:
        raise UnknownServer

    return _s    
</t>
<t tx="ekr.20060521134315.804">class CSessionManagerInternal:
	@others
</t>
<t tx="ekr.20060521134315.805">def __init__(self, pwd, fAllowUnencrypted, fRemote, host):
    self.m_pwd = [pwd, None][pwd in [None, '']]
    self.m_fAllowUnencrypted = fAllowUnencrypted
    self.m_fRemote = fRemote
    self.m_rid = generate_rid()
    
    self.m_host = host
    self.m_server_list_object = CServerList(host)

    self.m_session = None
    self.m_server_info = None
    
    self.m_worker_thread = None
    self.m_worker_thread_ident = None
    self.m_fStop = False

    self.m_stack_depth = None
    self.m_stack_depth_exception = None
    self.m_frame_index = 0
    self.m_frame_index_exception = 0

    self.m_remote_event_index = 0
    self.m_event_dispatcher_proxy = CEventDispatcher()
    self.m_event_dispatcher = CEventDispatcher(self.m_event_dispatcher_proxy)
    self.m_state_manager = CStateManager(STATE_DETACHED, self.m_event_dispatcher, self.m_event_dispatcher_proxy)

    self.m_breakpoints_proxy = CBreakPointsManagerProxy(self)
    
    event_type_dict = {CEventState: {EVENT_EXCLUDE: [STATE_BROKEN, STATE_ANALYZE]}}
    self.register_callback(self.reset_frame_indexes, event_type_dict, fSingleUse = False)
    event_type_dict = {CEventStackDepth: {}}
    self.register_callback(self.set_stack_depth, event_type_dict, fSingleUse = False)
    event_type_dict = {CEventNoThreads: {}}
    self.register_callback(self._reset_frame_indexes, event_type_dict, fSingleUse = False)
    
    self.m_printer = self.__nul_printer
</t>
<t tx="ekr.20060521134315.806">def __del__(self):
    self.m_event_dispatcher_proxy.shutdown()
    self.m_event_dispatcher.shutdown()
    self.m_state_manager.shutdown()
</t>
<t tx="ekr.20060521134315.807">def __nul_printer(self, str):
    pass
</t>
<t tx="ekr.20060521134315.808">def set_printer(self, printer):
    self.m_printer = printer
</t>
<t tx="ekr.20060521134315.809">def register_callback(self, callback, event_type_dict, fSingleUse):
    return self.m_event_dispatcher.register_callback(callback, event_type_dict, fSingleUse)
</t>
<t tx="ekr.20060521134315.810">def remove_callback(self, callback):
    return self.m_event_dispatcher.remove_callback(callback)
</t>
<t tx="ekr.20060521134315.811">def __wait_for_debuggee(self, rid):
    for i in range(0,STARTUP_RETRIES):
        try:
            self.m_server_list_object.calcList(self.m_pwd, self.m_rid, self.report_exception)
            return self.m_server_list_object.findServers(rid)[0]
        except UnknownServer:
            time.sleep(STARTUP_TIMEOUT)
            continue
            
    self.m_server_list_object.calcList(self.m_pwd, self.m_rid, self.report_exception)
    return self.m_server_list_object.findServers(rid)[0]
</t>
<t tx="ekr.20060521134315.812">def get_encryption(self):
    return self.getSession().get_encryption()
</t>
<t tx="ekr.20060521134315.813">def launch_nothrow(self, fchdir, command_line):
    try:
        self.launch(fchdir, command_line)
    except:
        pass
</t>
<t tx="ekr.20060521134315.814">def launch(self, fchdir, command_line):
    self.__verify_unattached()

    if not os.name in ['posix', 'nt']:
        self.m_printer(STR_SPAWN_UNSUPPORTED)
        raise SpawnUnsupported
        
    if self.m_pwd == None:
        self.set_random_password()
        
    if command_line == '':
        raise BadArgument

    (path, filename, args) = split_command_line_path_filename_args(command_line)

    #if not IsPythonSourceFile(filename):
    #    raise IOError

    _filename = os.path.join(path, filename) 
       
    ExpandedFilename = FindFile(_filename)
    self.set_host("localhost")

    self.m_printer(STR_STARTUP_SPAWN_NOTICE)

    rid = generate_rid()

    create_pwd_file(rid, self.m_pwd)
    
    self.m_state_manager.set_state(STATE_SPAWNING)

    try:
        try:
            try:
                self.__spawn_server(fchdir, ExpandedFilename, args, rid)            
            except SpawnUnsupported:    
                self.m_printer(STR_SPAWN_UNSUPPORTED)
                raise

            try:
                server = self.__wait_for_debuggee(rid)
            except UnknownServer:
                self.m_printer(STR_STARTUP_FAILURE)
                raise
                
            self.attach(server.m_rid, server.m_filename)
        except:
            if self.m_state_manager.get_state() != STATE_DETACHED:
                self.m_state_manager.set_state(STATE_DETACHED)

            raise
    finally:
        delete_pwd_file(rid)
</t>
<t tx="ekr.20060521134315.815">def __spawn_server(self, fchdir, ExpandedFilename, args, rid):
    """
    Start an OS console to act as server.
    What it does is to start rpdb again in a new console in server only mode.
    """

    if g_fScreen:
        name = 'screen'
    else:
        try:
            import terminalcommand
            name = 'mac'
        except:
            name = os.name

    if name == 'nt' and g_fDebug:
        name = 'nt_debug'
    
    e = ['', ' --plaintext'][self.m_fAllowUnencrypted]
    r = ['', ' --remote'][self.m_fRemote]
    c = ['', ' --chdir'][fchdir]
    p = ['', ' --pwd="%s"' % (self.m_pwd, )][os.name == 'nt']
    
    debugger = os.path.abspath(__file__)
    if debugger[-1:] == 'c':
        debugger = debugger[:-1]

    debug_prints = ['', ' --debug'][g_fDebug]    
        
    options = '"%s"%s --debugee%s%s%s%s --rid=%s "%s" %s' % (debugger, debug_prints, p, e, r, c, rid, ExpandedFilename, args)

    python_exec = sys.executable
    if python_exec.endswith('w.exe'):
        python_exec = python_exec[:-5] + '.exe'

    if name == 'posix':
        terminal_command = CalcTerminalCommand()
        command = osSpawn[name] % (terminal_command, python_exec, options)
    else:    
        command = osSpawn[name] % (python_exec, options)

    if name == 'mac':
        terminalcommand.run(command)
    else:
        os.popen(command)
</t>
<t tx="ekr.20060521134315.816">def attach_nothrow(self, key):
    try:
        self.attach(key)
    except:
        pass
</t>
<t tx="ekr.20060521134315.817">def attach(self, key, name = None):
    self.__verify_unattached()

    if key == '':
        raise BadArgument

    if self.m_pwd == None:
        self.m_printer(STR_PASSWORD_MUST_BE_SET)
        raise UnsetPassword
    
    if name == None:
        name = key

    _name = name
    
    self.m_printer(STR_STARTUP_NOTICE)
    self.m_state_manager.set_state(STATE_ATTACHING)

    try:
        self.m_server_list_object.calcList(self.m_pwd, self.m_rid, self.report_exception)                
        servers = self.m_server_list_object.findServers(key)
        server = servers[0] 

        _name = server.m_filename
        
        errors = self.m_server_list_object.get_errors()
        if (server.m_rid != key) and (len(errors) &gt; 0):
            self.__report_server_errors(errors)

        self.__attach(server)
        if len(servers) &gt; 1:
            self.m_printer(STR_MULTIPLE_DEBUGGEES % (key, ))
        self.m_printer(STR_ATTACH_CRYPTO_MODE % ([' ' + STR_ATTACH_CRYPTO_MODE_NOT, ''][self.get_encryption()], ))    
        self.m_printer(STR_ATTACH_SUCCEEDED % (server.m_filename, ))
        return

    except (socket.error, CConnectionException):
        self.report_exception(*sys.exc_info())
        self.m_printer(STR_ATTACH_FAILED_NAME % (_name, ))
        self.m_state_manager.set_state(STATE_DETACHED)
        raise
    except:
        print_debug()
        assert False
</t>
<t tx="ekr.20060521134315.818">def report_exception(self, type, value, tb):
    if type == socket.error:
        self.m_printer(STR_COMMUNICATION_FAILURE)
    elif type == BadVersion:
        self.m_printer((STR_BAD_VERSION % (value.m_version, )))
    elif type == UnexpectedData:
        self.m_printer(STR_UNEXPECTED_DATA)
    elif type == AlreadyAttached:
        self.m_printer(STR_ALREADY_ATTACHED)
    elif type == NotAttached:
        self.m_printer(STR_NOT_ATTACHED)
    elif type == NoThreads:
        self.m_printer(STR_NO_THREADS)
    elif type == SpawnUnsupported:
        self.m_printer(STR_SPAWN_UNSUPPORTED)
    elif type == UnknownServer:
        self.m_printer(STR_DEBUGGEE_UNKNOWN)
    elif type == UnsetPassword:
        self.m_printer(STR_PASSWORD_MUST_BE_SET)
    elif type == EncryptionNotSupported:
        self.m_printer(STR_DEBUGGEE_NO_ENCRYPTION)
    elif type == EncryptionExpected:
        self.m_printer(STR_ENCRYPTION_EXPECTED)
    elif type == DecryptionFailure:
        self.m_printer(STR_DECRYPTION_FAILURE)
    elif type == AuthenticationBadData:
        self.m_printer(STR_ACCESS_DENIED)
    elif type == AuthenticationFailure:
        self.m_printer(STR_ACCESS_DENIED)
</t>
<t tx="ekr.20060521134315.819">def __report_server_errors(self, errors):
    for k in errors.keys():
        if k == AuthenticationBadData:
            self.m_printer(STR_ACCESS_DENIED)
        if k == AuthenticationFailure:
            self.m_printer(STR_ACCESS_DENIED)
        if k == EncryptionExpected:
            self.m_printer(STR_ENCRYPTION_EXPECTED)
        if k == BadVersion:
            self.m_printer(STR_BAD_VERSION)
</t>
<t tx="ekr.20060521134315.820">def __attach(self, server):
    self.__verify_unattached()

    session = CSession(self.m_host, server.m_port, self.m_pwd, self.m_fAllowUnencrypted, self.m_rid)
    session.Connect()

    if (session.getServerInfo().m_pid != server.m_pid) or (session.getServerInfo().m_filename != server.m_filename):
        raise UnexpectedData

    self.m_session = session
    
    self.m_server_info = self.get_server_info()

    self.refresh()
    self.__start_event_monitor()

    self.request_break()
    self.enable_breakpoint([], fAll = True)
</t>
<t tx="ekr.20060521134315.821">def __verify_unattached(self):
    if self.__is_attached():
        raise AlreadyAttached
</t>
<t tx="ekr.20060521134315.822">def __verify_attached(self):
    if not self.__is_attached():
        raise NotAttached
</t>
<t tx="ekr.20060521134315.823">def __is_attached(self):
    return (self.m_state_manager.get_state() != STATE_DETACHED) and (self.m_session != None)
</t>
<t tx="ekr.20060521134315.824">def __verify_broken(self):
    if self.m_state_manager.get_state() not in [STATE_BROKEN, STATE_ANALYZE]:
        raise DebuggerNotBroken
</t>
<t tx="ekr.20060521134315.825">def refresh(self):
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    self.m_remote_event_index = self.getSession().getProxy().sync_with_events(fAnalyzeMode)
    self.m_breakpoints_proxy.sync()
</t>
<t tx="ekr.20060521134315.826">def __start_event_monitor(self):        
    self.m_fStop = False
    self.m_worker_thread = threading.Thread(target = self.__event_monitor_proc)
    self.m_worker_thread.setDaemon(True)
    self.m_worker_thread.start()
</t>
<t tx="ekr.20060521134315.827">def __event_monitor_proc(self):
    self.m_worker_thread_ident = thread.get_ident()
    t = 0
    
    while not self.m_fStop:
        try:
            t = ControlRate(t, IDLE_MAX_RATE)
            if self.m_fStop:
                return
                
            (n, sel) = self.getSession().getProxy().wait_for_event(PING_TIMEOUT, self.m_remote_event_index)

            if True in [isinstance(e, CEventExit) for e in sel]:
                self.getSession().shut_down()
                self.m_fStop = True
            
            if n &gt; self.m_remote_event_index:
                #print &gt;&gt; sys.__stderr__, (n, sel)                      
                self.m_remote_event_index = n
                self.m_event_dispatcher_proxy.fire_events(sel)

        except CConnectionException:
            self.report_exception(*sys.exc_info())
            threading.Thread(target = self.detach).start()
            return
            
        except socket.error:
            self.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.828">            #threading.Thread(target = self.detach).start()
            #return
        
def detach(self):
    self.m_printer(STR_ATTEMPTING_TO_DETACH)

    self.m_state_manager.set_state(STATE_DETACHING)

    self.__stop_event_monitor()

    try:
        self.disable_breakpoint([], fAll = True)
        self.request_go()
    except (socket.error, CConnectionException):
        pass
    except:
        print_debug()

    self.m_state_manager.set_state(STATE_DETACHED)

    self.m_session = None

    self.m_printer(STR_DETACH_SUCCEEDED)
</t>
<t tx="ekr.20060521134315.829">def __stop_event_monitor(self):
    self.m_fStop = True
    if self.m_worker_thread != None:
        if thread.get_ident() != self.m_worker_thread_ident:  
            self.m_worker_thread.join()

        self.m_worker_thread = None
        self.m_worker_thread_ident = None
</t>
<t tx="ekr.20060521134315.830">def request_break(self):
    self.getSession().getProxy().request_break()
</t>
<t tx="ekr.20060521134315.831">def request_go(self):
    self.getSession().getProxy().request_go()
</t>
<t tx="ekr.20060521134315.832">def request_go_breakpoint(self, filename, scope, lineno):
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    self.getSession().getProxy().request_go_breakpoint(filename, scope, lineno, frame_index, fAnalyzeMode)
</t>
<t tx="ekr.20060521134315.833">def request_step(self):
    self.getSession().getProxy().request_step()
</t>
<t tx="ekr.20060521134315.834">def request_next(self):
    self.getSession().getProxy().request_next()
</t>
<t tx="ekr.20060521134315.835">def request_return(self):
    self.getSession().getProxy().request_return()
</t>
<t tx="ekr.20060521134315.836">def request_jump(self, lineno):
    self.getSession().getProxy().request_jump(lineno)
</t>
<t tx="ekr.20060521134315.837">def set_breakpoint(self, filename, scope, lineno, fEnabled, expr):

    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    self.getSession().getProxy().set_breakpoint(filename, scope, lineno, fEnabled, expr, frame_index, fAnalyzeMode)
</t>
<t tx="ekr.20060521134315.838">def disable_breakpoint(self, id_list, fAll):
    self.getSession().getProxy().disable_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.839">def enable_breakpoint(self, id_list, fAll):
    self.getSession().getProxy().enable_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.840">def delete_breakpoint(self, id_list, fAll):
    self.getSession().getProxy().delete_breakpoint(id_list, fAll)
</t>
<t tx="ekr.20060521134315.841">def get_breakpoints(self):
    self.__verify_attached()

    bpl = self.m_breakpoints_proxy.get_breakpoints()            
    return bpl
</t>
<t tx="ekr.20060521134315.842">def save_breakpoints(self, _filename = ''):        
    bpl = self.get_breakpoints()
    sbpl = cPickle.dumps(bpl)

    if _filename == '':
        filename = self.getSession().getServerInfo().m_module_name + BREAKPOINTS_FILE_EXT
    else: 
        filename = _filename + BREAKPOINTS_FILE_EXT

    if filename[:1] == '&lt;':
        return
        
    file = open(filename, 'wb')
    file.write(sbpl)
    file.close()
</t>
<t tx="ekr.20060521134315.843">def load_breakpoints(self, _filename = ''):
    self.__verify_attached()

    _e = None
    
    if _filename == '':
        filename = self.getSession().getServerInfo().m_module_name + BREAKPOINTS_FILE_EXT
    else: 
        filename = _filename + BREAKPOINTS_FILE_EXT

    file = open(filename, 'rb')
    try:
        bpl = cPickle.load(file)
        for bp in bpl.values():
            try:
                self.set_breakpoint(bp.m_filename, bp.m_scope_fqn, bp.m_scope_offset, bp.m_fEnabled, bp.m_expr)
            except (socket.error, CConnectionException), e:
                _e = e
    finally:
        file.close()

    if _e != None:
        raise _e
</t>
<t tx="ekr.20060521134315.844">def get_stack(self, tid_list, fAll):    
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 
    r = self.getSession().getProxy().get_stack(tid_list, fAll, fAnalyzeMode)
    return r
</t>
<t tx="ekr.20060521134315.845">def get_source_file(self, filename, lineno, nlines): 
    #if (filename != '') and not IsPythonSourceFile(filename):
    #    raise IOError
        
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    r = self.getSession().getProxy().get_source_file(filename, lineno, nlines, frame_index, fAnalyzeMode)
    return r        
</t>
<t tx="ekr.20060521134315.846">def get_source_lines(self, nlines, fAll): 
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    r = self.getSession().getProxy().get_source_lines(nlines, fAll, frame_index, fAnalyzeMode)
    return r
</t>
<t tx="ekr.20060521134315.847">def get_thread_list(self):
    (current_thread_id, thread_list) = self.getSession().getProxy().get_thread_list()
    return (current_thread_id, thread_list)
</t>
<t tx="ekr.20060521134315.848">def set_thread(self, tid):
    self.reset_frame_indexes(None)
    self.getSession().getProxy().set_thread(tid)
</t>
<t tx="ekr.20060521134315.849">def get_namespace(self, nl, fFilter):
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    r = self.getSession().getProxy().get_namespace(nl, fFilter, frame_index, fAnalyzeMode)
    return r
</t>
<t tx="ekr.20060521134315.850">def evaluate(self, expr):
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE) 

    (value, warning, error) = self.getSession().getProxy().evaluate(expr, frame_index, fAnalyzeMode)
    return (value, warning, error)
</t>
<t tx="ekr.20060521134315.851">def execute(self, suite):
    frame_index = self.get_frame_index()
    fAnalyzeMode = (self.m_state_manager.get_state() == STATE_ANALYZE)

    (warning, error) = self.getSession().getProxy().execute(suite, frame_index, fAnalyzeMode)
    return (warning, error)
</t>
<t tx="ekr.20060521134315.852">def set_host(self, host):
    self.__verify_unattached()
    
    socket.getaddrinfo(host, 0)        
    self.m_host = host
    self.m_server_list_object = CServerList(host)
</t>
<t tx="ekr.20060521134315.853">def get_host(self):
    return self.m_host
</t>
<t tx="ekr.20060521134315.854">def calc_server_list(self):
    if self.m_pwd == None:
        raise UnsetPassword
    
    server_list = self.m_server_list_object.calcList(self.m_pwd, self.m_rid, self.report_exception)
    errors = self.m_server_list_object.get_errors()

    return (server_list, errors)
</t>
<t tx="ekr.20060521134315.855">def get_server_info(self): 
    return self.getSession().getServerInfo()
</t>
<t tx="ekr.20060521134315.856">def get_last_debuggee_name_safe(self):
    si = self.m_server_info
    if si == None:
        return ''
    return si.m_filename    
</t>
<t tx="ekr.20060521134315.857">def _reset_frame_indexes(self, event):
    self.reset_frame_indexes(None)
</t>
<t tx="ekr.20060521134315.858">def reset_frame_indexes(self, event):
    try:
        self.m_state_manager.acquire()
        if event == None:
            self.__verify_broken()
        elif self.m_state_manager.get_state() in [STATE_BROKEN, STATE_ANALYZE]:
            return

        self.m_stack_depth = None
        self.m_stack_depth_exception = None
        self.m_frame_index = 0
        self.m_frame_index_exception = 0

    finally:
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.859">def set_stack_depth(self, event):
    try:
        self.m_state_manager.acquire()
        self.__verify_broken()

        self.m_stack_depth = event.m_stack_depth
        self.m_stack_depth_exception = event.m_stack_depth_exception
        self.m_frame_index = min(self.m_frame_index, self.m_stack_depth - 1)
        self.m_frame_index_exception = min(self.m_frame_index_exception, self.m_stack_depth_exception - 1)

    finally:
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.860">def set_frame_index(self, frame_index):
    try:
        self.m_state_manager.acquire()
        self.__verify_broken()

        if (frame_index &lt; 0) or (self.m_stack_depth == None):
            return self.get_frame_index(fLock = False)

        if self.m_state_manager.get_state() == STATE_ANALYZE:
            self.m_frame_index_exception = min(frame_index, self.m_stack_depth_exception - 1)
            si = self.m_frame_index_exception

        else:    
            self.m_frame_index = min(frame_index, self.m_stack_depth - 1)
            si = self.m_frame_index

    finally:
        self.m_state_manager.release()

    event = CEventStackFrameChange(si)
    self.m_event_dispatcher.fire_event(event)

    event = CEventNamespace()
    self.m_event_dispatcher.fire_event(event)

    return si
</t>
<t tx="ekr.20060521134315.861">def get_frame_index(self, fLock = True):
    try:
        if fLock:
            self.m_state_manager.acquire()
            
        self.__verify_attached()

        if self.m_state_manager.get_state() == STATE_ANALYZE:
            return self.m_frame_index_exception
        else:    
            return self.m_frame_index

    finally:
        if fLock:
            self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.862">def set_analyze(self, fAnalyze):
    try:
        self.m_state_manager.acquire()

        if fAnalyze and (self.m_state_manager.get_state() != STATE_BROKEN):
            raise DebuggerNotBroken
            
        if (not fAnalyze) and (self.m_state_manager.get_state() != STATE_ANALYZE):
            return
            
        state = [STATE_BROKEN, STATE_ANALYZE][fAnalyze]
        self.m_state_manager.set_state(state, fLock = False)

    finally:
        self.m_state_manager.release()

        self.refresh()
</t>
<t tx="ekr.20060521134315.863">def getSession(self):
    self.__verify_attached()

    return self.m_session
</t>
<t tx="ekr.20060521134315.864">def get_state(self):
    return self.m_state_manager.get_state()
</t>
<t tx="ekr.20060521134315.865">def set_password(self, pwd):    
    try:
        self.m_state_manager.acquire()

        self.__verify_unattached()
        
        self.m_pwd = pwd
    finally:
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.866">def set_random_password(self):
    try:
        self.m_state_manager.acquire()

        self.__verify_unattached()
        
        self.m_pwd = generate_random_password()
        self.m_printer(STR_RANDOM_PASSWORD)        

    finally:
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.867">def get_password(self):
    return self.m_pwd
</t>
<t tx="ekr.20060521134315.868">def set_remote(self, fRemote):
    try:
        self.m_state_manager.acquire()

        self.__verify_unattached()
        
        self.m_fRemote = fRemote
    finally:
        self.m_state_manager.release()
</t>
<t tx="ekr.20060521134315.869">def get_remote(self):
    return self.m_fRemote
</t>
<t tx="ekr.20060521134315.870">def stop_debuggee(self):
    self.getSession().getProxy().stop_debuggee()
</t>
<t tx="ekr.20060521134315.871">class CConsoleInternal(cmd.Cmd, threading.Thread):

	@others</t>
<t tx="ekr.20060521134315.872">def __init__(self, session_manager, stdin = None, stdout = None, fSplit = False):
    cmd.Cmd.__init__(self, stdin = stdin, stdout = stdout)
    threading.Thread.__init__(self)
    
    self.fAnalyzeMode = False
    self.fPrintBroken = True

    self.m_filename = None
    
    self.use_rawinput = [1, 0][fSplit]
    self.m_fSplit = fSplit
    self.prompt = [[CONSOLE_PROMPT, CONSOLE_PROMPT_ANALYZE][self.fAnalyzeMode], ""][fSplit]
    self.intro = CONSOLE_INTRO
    self.setDaemon(True)

    event_type_dict = {CEventState: {}}
    
    self.m_session_manager = session_manager
    self.m_session_manager.set_printer(self.printer)
    self.m_session_manager.register_callback(self.event_handler, event_type_dict, fSingleUse = False)

    event_type_dict = {CEventExit: {}}
    self.m_session_manager.register_callback(self.event_atexit, event_type_dict, fSingleUse = False)
    
    self.m_last_source_line = None
    self.m_last_nlines = DEFAULT_NUMBER_OF_LINES
    
    self.m_fAddPromptBeforeMsg = False
    self.m_eInLoop = threading.Event()
    self.cmdqueue.insert(0, '')
</t>
<t tx="ekr.20060521134315.873">def set_filename(self, filename):
    self.m_filename = filename
</t>
<t tx="ekr.20060521134315.874">def event_atexit(self, event):
    self.printer(STR_DEBUGGEE_TERMINATED)        
    self.do_detach("")
</t>
<t tx="ekr.20060521134315.875">def precmd(self, line):
    self.m_fAddPromptBeforeMsg = True
    if not self.m_eInLoop.isSet():
        self.m_eInLoop.set()

    if not line.strip():
        return line
        
    command = line.split(' ', 1)[0].split(SOURCE_MORE, 1)[0].split(SOURCE_LESS, 1)[0]
    if command not in ['list', 'l']:
        self.m_last_source_line = None
        self.m_last_nlines = DEFAULT_NUMBER_OF_LINES

    return line    
</t>
<t tx="ekr.20060521134315.876">def postcmd(self, stop, line):
    self.m_fAddPromptBeforeMsg = False

    return stop
</t>
<t tx="ekr.20060521134315.877">def run(self):
    self.cmdloop()
</t>
<t tx="ekr.20060521134315.878">def __get_str_wrap(self, str, max_len):
    if len(str) &lt;= max_len:
        return (str, '')

    s = str[: max_len]
    i = s.rfind(' ')
    if i == -1:
        return (s, str[max_len:])

    return (str[: i], str[i + 1:])    
</t>
<t tx="ekr.20060521134315.879">def printer(self, str):
    if not self.m_eInLoop.isSet():
        self.m_eInLoop.wait()

    fAPBM = self.m_fAddPromptBeforeMsg    
    prefix = ['', self.prompt.strip('\n')][fAPBM] + CONSOLE_PRINTER
    suffix = '\n' + [self.prompt.strip('\n'), ''][fAPBM]

    s = str
    while s != '':
        s, _s = self.__get_str_wrap(s, CONSOLE_WRAP_INDEX - len(prefix + suffix))
        self.stdout.write(prefix + s + suffix)
        s = _s 
</t>
<t tx="ekr.20060521134315.880">def print_notice(self, notice):
    nl = notice.split('\n')

    i = 0
    for l in nl:
        print &gt;&gt; self.stdout, l
        i += 1
        if i % PRINT_NOTICE_LINES_PER_SECTION == 0:
            print &gt;&gt; self.stdout, "\n" + PRINT_NOTICE_PROMPT,
            response = self.stdin.readline()
            if response != '\n':
                break

            print &gt;&gt; self.stdout
</t>
<t tx="ekr.20060521134315.881">def event_handler(self, event): 
    state = event.m_state
    if (state == STATE_BROKEN) and self.fPrintBroken:
        self.fPrintBroken = False
        self.printer(STR_DEBUGGER_HAS_BROKEN)
        return

    if (state != STATE_ANALYZE) and self.fAnalyzeMode:
        self.fAnalyzeMode = False
        self.prompt = [CONSOLE_PROMPT, ""][self.m_fSplit]
        self.printer(STR_ANALYZE_MODE_TOGGLE % (MODE_OFF, ))
        return
    
    if (state == STATE_ANALYZE) and not self.fAnalyzeMode:
        self.fAnalyzeMode = True
        self.prompt = [CONSOLE_PROMPT_ANALYZE, ""][self.m_fSplit]
        self.printer(STR_ANALYZE_MODE_TOGGLE % (MODE_ON, ))
        return
</t>
<t tx="ekr.20060521134315.882">def do_launch(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    if arg[:2] == '-k':
        fchdir = False
        _arg = arg[2:].strip()
    else:
        fchdir = True
        _arg = arg

    self.fPrintBroken = True

    try:
        self.m_session_manager.launch(fchdir, _arg)
        return
        
    except (socket.error, CConnectionException):
        pass
    except BadArgument:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except IOError:
        print &gt;&gt; self.stdout, 'File', arg, ' not found.'
    
    self.fPrintBroken = False
</t>
<t tx="ekr.20060521134315.883">def do_attach(self, arg):
    if arg == '':
        return self.__scripts(arg)
        
    self.fPrintBroken = True

    try:
        self.m_session_manager.attach(arg)
        return
        
    except (socket.error, CConnectionException):
        pass
    except BadArgument:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    
    self.fPrintBroken = False
</t>
<t tx="ekr.20060521134315.884">def __scripts(self, arg):
    if self.m_session_manager.get_password() == None:
        print &gt;&gt; self.stdout, STR_PASSWORD_MUST_BE_SET
        return

    host = self.m_session_manager.get_host()
    print &gt;&gt; self.stdout, STR_SCRIPTS_CONNECTING % (host, )

    try:
        (server_list, errors) = self.m_session_manager.calc_server_list()
        for k in errors.keys():
            if k == AuthenticationBadData:
                print &gt;&gt; self.stdout, STR_ACCESS_DENIED
            if k == AuthenticationFailure:
                print &gt;&gt; self.stdout, STR_ACCESS_DENIED
            if k == EncryptionExpected:
                print &gt;&gt; self.stdout, STR_ENCRYPTION_EXPECTED
            if k == BadVersion:
                print &gt;&gt; self.stdout, STR_BAD_VERSION

    except UnsetPassword:
        print &gt;&gt; self.stdout, STR_PASSWORD_MUST_BE_SET
        return

    if server_list == []:
        print &gt;&gt; self.stdout, STR_SCRIPTS_NO_SCRIPTS % (host, )
        return

    try:
        spid = self.m_session_manager.get_server_info().m_pid
    except NotAttached:
        spid = None

    print &gt;&gt; self.stdout, STR_SCRIPTS_TO_DEBUG % (host, )    
    for s in server_list:
        m = ['', SYMBOL_MARKER][spid == s.m_pid]
        print &gt;&gt; self.stdout, ' %1s %-5d  %s' % (m, s.m_pid, s.m_filename)
</t>
<t tx="ekr.20060521134315.885">def do_detach(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    self.m_session_manager.save_breakpoints()
    self.m_session_manager.detach()
</t>
<t tx="ekr.20060521134315.886">def do_host(self, arg):
    if arg == '':
        host = self.m_session_manager.get_host()
        print &gt;&gt; self.stdout, host
        return

    try:
        self.m_session_manager.set_host(arg)
    except socket.gaierror, e:
        print &gt;&gt; self.stdout, STR_HOST_UNKNOWN % (arg, )
    except AlreadyAttached:
        print &gt;&gt; self.stdout, STR_ALREADY_ATTACHED
</t>
<t tx="ekr.20060521134315.887">def do_break(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        self.m_session_manager.request_break()
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.888">do_b = do_break

def __parse_bp_arg(self, arg, fAllowExpr = True):
    _args = arg.split(BP_EVAL_SEP)

    if (len(_args) &gt; 1) and (not fAllowExpr):
        raise BadArgument
        
    if len(_args) &gt; 1:
        expr = _args[1].strip()
    else:
        expr = ''

    rf = _args[0].rfind(BP_FILENAME_SEP)
    if rf == -1:
        args = [_args[0]]
    else:
        args = [_args[0][:rf], _args[0][rf + 1:]]

    filename = ['', args[0]][len(args) &gt; 1]

    if filename in [None, '']:
        filename = self.m_filename

    try:
        lineno = int(args[-1])
        scope = ''
    except ValueError:
        lineno = 0
        scope = args[-1].strip()

    return (filename, scope, lineno, expr)
</t>
<t tx="ekr.20060521134315.889">def do_go(self, arg):
    if self.fAnalyzeMode:
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_CMD
        return

    try:
        if arg != '':
            (filename, scope, lineno, expr) = self.__parse_bp_arg(arg, fAllowExpr = False)
            self.fPrintBroken = True
            self.m_session_manager.request_go_breakpoint(filename, scope, lineno)
            return
        
        self.fPrintBroken = True
        self.m_session_manager.request_go()
        return
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except BadArgument:    
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except IOError:
        print &gt;&gt; self.stdout, STR_FILE_NOT_FOUND % (filename, )
    except InvalidScopeName:
        print &gt;&gt; self.stdout, STR_SCOPE_NOT_FOUND % (scope, )
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN

    self.fPrintBroken = False
</t>
<t tx="ekr.20060521134315.890">do_g = do_go

def do_step(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    if self.fAnalyzeMode:
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_CMD
        return

    try:
        self.m_session_manager.request_step()
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.891">do_s = do_step

def do_next(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    if self.fAnalyzeMode:
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_CMD
        return

    try:
        self.m_session_manager.request_next()
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.892">do_n = do_next

def do_return(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    if self.fAnalyzeMode:
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_CMD
        return

    try:
        self.m_session_manager.request_return()
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.893">do_r = do_return

def do_jump(self, arg):
    try:
        lineno = int(arg)
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    try:
        self.m_session_manager.request_jump(lineno)
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.894">do_j = do_jump

def do_bp(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
    
    try:
        (filename, scope, lineno, expr) = self.__parse_bp_arg(arg, fAllowExpr = True)
        self.m_session_manager.set_breakpoint(filename, scope, lineno, True, expr)
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except BadArgument:    
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except IOError:
        print &gt;&gt; self.stdout, STR_FILE_NOT_FOUND % (filename, )
    except InvalidScopeName:
        print &gt;&gt; self.stdout, STR_SCOPE_NOT_FOUND % (scope, )
    except SyntaxError:
        print &gt;&gt; self.stdout, STR_BAD_EXPRESSION % (expr, )
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.895">def do_be(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        id_list = []
        fAll = (arg == SYMBOL_ALL)
        
        if not fAll:
            sid_list = arg.split()
            id_list = [int(sid) for sid in sid_list]

        self.m_session_manager.enable_breakpoint(id_list, fAll)
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.896">def do_bd(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        id_list = []
        fAll = (arg == SYMBOL_ALL)
        
        if not fAll:
            sid_list = arg.split()
            id_list = [int(sid) for sid in sid_list]

        self.m_session_manager.disable_breakpoint(id_list, fAll)
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.897">def do_bc(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        id_list = []
        fAll = (arg == SYMBOL_ALL)
        
        if not fAll:
            sid_list = arg.split()
            id_list = [int(sid) for sid in sid_list]

        self.m_session_manager.delete_breakpoint(id_list, fAll)
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.898">def do_bl(self, arg):
    try:
        bpl = self.m_session_manager.get_breakpoints()
            
        bplk = bpl.keys()
        bplk.sort()
        
        print &gt;&gt; self.stdout, STR_BREAKPOINTS_LIST    
        for id in bplk:
            bp = bpl[id]
            state = [STATE_DISABLED, STATE_ENABLED][bp.isEnabled()]
            print &gt;&gt; self.stdout, ' %2d  %-8s  %-15s  %5d  %-19s  %s' % (id, state, calc_suffix(bp.m_filename, 15), bp.m_lineno, calc_suffix(bp.m_scope_fqn, 19), calc_prefix(bp.m_expr, 20))
            
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
</t>
<t tx="ekr.20060521134315.899">def do_save(self, arg):
    try:
        self.m_session_manager.save_breakpoints(arg)
        print &gt;&gt; self.stdout, STR_BREAKPOINTS_SAVED    
        return
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except IOError:
        print &gt;&gt; self.stdout, STR_BAD_FILENAME

    print &gt;&gt; self.stdout, STR_BREAKPOINTS_NOT_SAVED    
</t>
<t tx="ekr.20060521134315.900">def do_load(self, arg):
    try:
        self.m_session_manager.load_breakpoints(arg)
        print &gt;&gt; self.stdout, STR_BREAKPOINTS_LOADED    
        return
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except cPickle.PickleError:
        print &gt;&gt; self.stdout, STR_BAD_FILE_DATA
    except IOError:
        print &gt;&gt; self.stdout, STR_BREAKPOINTS_FILE_NOT_FOUND
</t>
<t tx="ekr.20060521134315.901">def do_stack(self, arg):
    if self.fAnalyzeMode and (arg != ''):
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_ARG
        return

    try:
        tid_list = []
        fAll = (arg == SYMBOL_ALL)
        
        if not fAll:
            sid_list = arg.split()
            tid_list = [int(sid) for sid in sid_list]
            
        sl = self.m_session_manager.get_stack(tid_list, fAll)

        if len(sl) == 0:
            print &gt;&gt; self.stdout, STR_NO_THREADS_FOUND
            return

        frame_index = self.m_session_manager.get_frame_index()

        m = None    
        for st in sl:
            s = st.get(DICT_KEY_STACK, [])
            tid = st.get(DICT_KEY_TID, 0)
            fBroken = st.get(DICT_KEY_BROKEN, False)
            fCurrent = st.get(DICT_KEY_CURRENT_TID, False)

            if m != None:
                print &gt;&gt; self.stdout
                
            print &gt;&gt; self.stdout, STR_STACK_TRACE % (tid, )    
            i = 0
            while i &lt; len(s):
                e = s[-(1 + i)]

                if not fBroken:
                    m = ['', SOURCE_STATE_UNBROKEN][i == 0]
                elif fCurrent:
                    m = ['', SYMBOL_MARKER][i == frame_index]
                else:
                    m = ['', SYMBOL_MARKER][i == 0]
                    
                print &gt;&gt; self.stdout, ' %1s %5d  %-28s  %4d  %s' % (m, i, calc_suffix(e[0], 28), e[1], calc_prefix(e[2], 20))
                i += 1
    except (socket.error, NoThreads, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except NoExceptionFound:
        print &gt;&gt; self.stdout, STR_EXCEPTION_NOT_FOUND
</t>
<t tx="ekr.20060521134315.902">do_k = do_stack

def do_list(self, arg):
    rf = arg.rfind(BP_FILENAME_SEP)
    if rf == -1:
        _filename = ''
        __args2 = arg
    else:
        _filename = arg[:rf]
        __args2 = arg[rf + 1:]
        
    _args = __args2.split(BP_EVAL_SEP)
    
    fAll = (_args[0] == SYMBOL_ALL)
    fMore = (_args[0] == SOURCE_MORE)
    fLess = (_args[0] == SOURCE_LESS)
    fEntire = (_args[0] == SOURCE_ENTIRE_FILE)
    fCurrent = (_args[0] == '')
    fLine = False
    l = 1
    
    try:
        if len(_args) &gt; 1:
            nlines = int(_args[1])
        else:
            nlines = self.m_last_nlines

        if not (fAll or fMore or fLess or fEntire or fCurrent):     
            l = int(_args[0])
            fLine = True

    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    if self.fAnalyzeMode and fAll:
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_ARG
        return

    if fMore and self.m_last_source_line:
        l = max(1, self.m_last_source_line + self.m_last_nlines / 2 + 1)
        fLine = True
    elif fLess and self.m_last_source_line:
        l = max(1, self.m_last_source_line - (self.m_last_nlines - 1) / 2 - nlines)
        fLine = True
        
    try:
        if fEntire:
            r = [self.m_session_manager.get_source_file(_filename, -1, -1)]
        elif fLine:
            r = [self.m_session_manager.get_source_file(_filename, l, nlines)]
        elif _filename != '':
            r = [self.m_session_manager.get_source_file(_filename, l, nlines)]
        else:
            r = self.m_session_manager.get_source_lines(nlines, fAll)

        if len(r) == 0:
            print &gt;&gt; self.stdout, STR_NO_THREADS_FOUND
            return

        m = None    
        for d in r:
            tid = d.get(DICT_KEY_TID, 0)
            filename = d.get(DICT_KEY_FILENAME, '')
            breakpoints = d.get(DICT_KEY_BREAKPOINTS, {})
            source_lines = d.get(DICT_KEY_LINES, [])
            first_lineno = d.get(DICT_KEY_FIRST_LINENO, 0)
            
            fBroken = d.get(DICT_KEY_BROKEN, False)
            frame_event = d.get(DICT_KEY_EVENT, '')
            frame_lineno = d.get(DICT_KEY_FRAME_LINENO, 0)
            
            if m != None:
                print &gt;&gt; self.stdout
                
            print &gt;&gt; self.stdout, STR_SOURCE_LINES % (tid, filename)    
            for i, line in enumerate(source_lines):
                lineno = first_lineno + i
                if lineno != frame_lineno:
                    m = ''
                elif not fBroken:
                    m = SOURCE_STATE_UNBROKEN + SYMBOL_MARKER
                elif frame_event == 'call':
                    m = SOURCE_EVENT_CALL + SYMBOL_MARKER
                elif frame_event == 'line':
                    m = SOURCE_EVENT_LINE + SYMBOL_MARKER
                elif frame_event == 'return':
                    m = SOURCE_EVENT_RETURN + SYMBOL_MARKER
                elif frame_event == 'exception':
                    m = SOURCE_EVENT_EXCEPTION + SYMBOL_MARKER

                if breakpoints.get(lineno, None) == STATE_ENABLED:
                    b = SOURCE_BP_ENABLED
                elif breakpoints.get(lineno, None) == STATE_DISABLED:
                    b = SOURCE_BP_DISABLED
                else:
                    b = ''
                    
                print &gt;&gt; self.stdout, ' %2s %1s %5d  %s' % (m, b, lineno, calc_prefix(line[:-1], 60))

        if fAll or fEntire:
            self.m_last_source_line = None        
        elif len(source_lines) != 0:
            self.m_last_source_line = [l + (nlines - 1) / 2, frame_lineno][l == -1]

        self.m_last_nlines = nlines
            
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except NoExceptionFound:
        print &gt;&gt; self.stdout, STR_EXCEPTION_NOT_FOUND
    except NoThreads:
        self.m_session_manager.report_exception(*sys.exc_info())
    except (InvalidFrame, IOError):
        print &gt;&gt; self.stdout, STR_SOURCE_NOT_FOUND
</t>
<t tx="ekr.20060521134315.903">do_l = do_list

def do_up(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    try:
        fi = self.m_session_manager.get_frame_index()
        self.m_session_manager.set_frame_index(fi - 1)
        
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.904">def do_down(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        fi = self.m_session_manager.get_frame_index()
        self.m_session_manager.set_frame_index(fi + 1)
        
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.905">def do_eval(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        (value, warning, error) = self.m_session_manager.evaluate(arg)
        print &gt;&gt; self.stdout, warning + ['', '\n\n'][warning != ''] + error + value
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except NoExceptionFound:
        print &gt;&gt; self.stdout, STR_EXCEPTION_NOT_FOUND
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.906">do_v = do_eval

def do_exec(self, arg):
    if arg == '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return
        
    try:
        print &gt;&gt; self.stdout, STR_OUTPUT_WARNING
        (w, e) = self.m_session_manager.execute(arg)
        print &gt;&gt; self.stdout, w + e
    except (socket.error, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except NoExceptionFound:
        print &gt;&gt; self.stdout, STR_EXCEPTION_NOT_FOUND
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.907">do_x = do_exec

def do_thread(self, arg):
    if self.fAnalyzeMode and (arg != ''):
        print &gt;&gt; self.stdout, STR_ILEGAL_ANALYZE_MODE_ARG
        return

    try:
        if arg != '':
            tid = int(arg)
            self.m_session_manager.set_thread(tid)

            print &gt;&gt; self.stdout, STR_THREAD_FOCUS_SET
            return

        (current_thread_id, tl) = self.m_session_manager.get_thread_list()

        print &gt;&gt; self.stdout, STR_ACTIVE_THREADS    
        for i, t in enumerate(tl):
            m = ['', SYMBOL_MARKER][t[DICT_KEY_TID] == current_thread_id]
            state = [STATE_RUNNING, STATE_BROKEN][t[DICT_KEY_BROKEN]]
            print &gt;&gt; self.stdout, ' %1s %3d  %5d  %s' % (m, i, t[DICT_KEY_TID], state[:10])
            
    except ValueError:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
    except (socket.error, NoThreads, CConnectionException):
        self.m_session_manager.report_exception(*sys.exc_info())
    except ThreadNotFound:
        print &gt;&gt; self.stdout, STR_THREAD_NOT_FOUND
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.908">do_t = do_thread

def do_analyze(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    try:
        self.m_session_manager.set_analyze(not self.fAnalyzeMode)
    except NotAttached:
        print &gt;&gt; self.stdout, STR_NOT_ATTACHED        
    except DebuggerNotBroken:
        print &gt;&gt; self.stdout, STR_DEBUGGEE_NOT_BROKEN
</t>
<t tx="ekr.20060521134315.909">do_a = do_analyze

def do_password(self, arg):
    if arg == '':
        pwd = self.m_session_manager.get_password()
        if pwd == None:
            print &gt;&gt; self.stdout, STR_PASSWORD_NOT_SET
        else:    
            print &gt;&gt; self.stdout, STR_PASSWORD_SET % (pwd, )
        return

    pwd = fix_password(arg)
    
    try:
        self.m_session_manager.set_password(pwd)
        print &gt;&gt; self.stdout, STR_PASSWORD_SET % (pwd, )
        return

    except AlreadyAttached:
        print &gt;&gt; self.stdout, STR_ALREADY_ATTACHED
</t>
<t tx="ekr.20060521134315.910">def do_remote(self, arg):
    if arg == '':
        fRemote = self.m_session_manager.get_remote()
        print &gt;&gt; self.stdout, STR_REMOTE_MODE % (str(fRemote), )
        return

    if arg == str(True):
        fRemote = True
    elif arg == str(False):
        fRemote = False
    else:
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    try:
        self.m_session_manager.set_remote(fRemote)
        print &gt;&gt; self.stdout, STR_REMOTE_MODE % (str(fRemote), )
        return

    except AlreadyAttached:
        print &gt;&gt; self.stdout, STR_ALREADY_ATTACHED
</t>
<t tx="ekr.20060521134315.911">def do_stop(self, arg):
    try:
        print &gt;&gt; self.stdout, STR_KILL_NOTICE
        self.m_session_manager.save_breakpoints()
        self.m_session_manager.stop_debuggee()
    except (socket.error, CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.912">def do_exit(self, arg):
    if arg != '':
        print &gt;&gt; self.stdout, STR_BAD_ARGUMENT
        return

    if self.m_session_manager.get_state() != STATE_DETACHED:    
        self.do_stop("")

    print &gt;&gt; self.stdout, ''

    return True 
</t>
<t tx="ekr.20060521134315.913">do_EOF = do_exit    

def do_copyright(self, arg):
    self.print_notice(COPYRIGHT_NOTICE)
</t>
<t tx="ekr.20060521134315.914">def do_license(self, arg):
    self.print_notice(LICENSE_NOTICE + COPY_OF_THE_GPL_LICENSE)
</t>
<t tx="ekr.20060521134315.915">def do_help(self, arg):
    cmd.Cmd.do_help(self, arg)

    if arg == '':
        help_notice = """Security:
----------------

password    - Get or set the channel password.
remote      - Get or set "allow connections from remote machines" mode.

Session Control:
-----------------

host        - Display or change host.
attach      - Display scripts or attach to a script on host.
detach      - Detach from script.
launch      - Spawn a script and attach to it.
stop        - Shutdown the debugged script.
exit        - Exit from debugger.

Debuggee Control:
-----------------

break       - Request an immediate break.
step        - Continue to the next execution line.
next        - Continue to the next execution line in the current frame.
return      - Continue until the debugger is about to return from the frame.
jump        - Jump to a line in the current scope.
go          - Continue execution.

Breakpoints Control:
--------------------

bp          - Set a break point.
bd          - Disable a breakpoint.
be          - Enable a breakpoint.
bc          - Clear (delete) a breakpoint.
bl          - List all breakpoints.
load        - Load session breakpoints.
save        - save session breakpoints.

Misc:
-----

thread      - Display threads or switch to a particular thread.
list        - List source code.
stack       - Display stack trace.
up          - Go up one frame in stack.
down        - Go down one frame in stack.
eval        - Evaluate expression in the context of the current frame.
exec        - Execute suite in the context of the current frame.
analyze     - Toggle analyze last exception mode.

License:
----------------

copyright   - Print copyright notice.
license     - Print license."""

        self.print_notice(help_notice)
</t>
<t tx="ekr.20060521134315.916"></t>
<t tx="ekr.20060521134315.917">def help_copyright(self, arg):
    print &gt;&gt; self.stdout, """copyright

Print copyright notice."""  
</t>
<t tx="ekr.20060521134315.918">def help_license(self, arg):
    print &gt;&gt; self.stdout, """license

Print license."""  
</t>
<t tx="ekr.20060521134315.919">def help_help(self):
    print &gt;&gt; self.stdout, """help &lt;cmd&gt;

Print help for command &lt;cmd&gt;.
On the other hand I guess that you already know that, don't you?"""  
</t>
<t tx="ekr.20060521134315.920">def help_analyze(self):
    print &gt;&gt; self.stdout, """analyze

(shorthand - a)

Toggle analyze last exception mode.

The following changes to the debugger behavior apply in analyze mode:
The debugger prompt changes to 'Analyze&gt;'.
'go', 'step', 'next', and 'return' are not allowed.
'thread' does not allow to change the thread focus.
'stack' allows no arguments.
'list' does not accept the '*' (all threads) argument
'stack', 'list', 'eval', 'exec', 'up', and 'down' operate on the thrown 
exception."""

help_a = help_analyze </t>
<t tx="ekr.20060521134315.921">   

def help_password(self):
    print &gt;&gt; self.stdout, """password &lt;password&gt;

Get or set the channel password.

Communication between the console and the debuggee is always authenticated and
optionally encrypted. The password (A secret known to the console and the
debuggee alone) governs both security methods. The password is never 
communicated between the two components on the communication channel.

A password is always required since unsecured communication between the 
console and the debuggee may expose your machine to attacks."""
</t>
<t tx="ekr.20060521134315.922">def help_remote(self):
    print &gt;&gt; self.stdout, """remote [True | False]

Get or set "allow connections from remote machines" mode.

When set to False: 
Newly launched debuggees will listen on localhost only. In this mode, debugger
consoles on remote machines will NOT BE able to see or attach to the debuggee.

When set to True: 
Newly launched debuggees will listen on INADDR_ANY. In this mode, debugger 
consoles on remote machines will BE able to see and attach to the debuggee."""
</t>
<t tx="ekr.20060521134315.923">def help_stop(self):
    print &gt;&gt; self.stdout, """Stop

Shutdown the debugged script."""
</t>
<t tx="ekr.20060521134315.924">def help_launch(self):
    print &gt;&gt; self.stdout, """Launch [-k] &lt;script_name&gt; [&lt;script_args&gt;]

Spawn script &lt;script_name&gt; and attach to it.

-k  Don't change the current working directory. By default the working
directory of the launched script is set to its folder."""
</t>
<t tx="ekr.20060521134315.925">def help_attach(self):
    print &gt;&gt; self.stdout, """attach [&lt;arg&gt;]

Without an argument, 'attach' prints the scripts available for debugging
on the selected host. To select a host use the 'host' command. A script is
considered available for debugging only if it is using the rpdb2 module or
has been executed by the debugger.
If the debugger is already attached to a script, a special character will
mark that script in the list.

When &lt;arg&gt; is an integer the debugger will try to attach to a script with
that pid. 
When &lt;arg&gt; is a string the debugger will try to attach to a script
with that name in the list."""  
</t>
<t tx="ekr.20060521134315.926">def help_detach(self):
    print &gt;&gt; self.stdout, """detach

Detach from the script the debugger is currently attached to. The detached
script will continue execution."""  
</t>
<t tx="ekr.20060521134315.927">def help_break(self):
    print &gt;&gt; self.stdout, """break 

(shorthand - b)

Request script to break. The 'break' command returns immdeiately but the 
break is only established when an active thread submits to the debugger 
control. If a thread is doing a system call or executing C code, this 
will happen only when it returns to do python code."""  
</t>
<t tx="ekr.20060521134315.928">help_b = help_break

def help_bp(self):
    print &gt;&gt; self.stdout, """bp [&lt;filename&gt;':'] (&lt;line&gt; | &lt;scope&gt;) [',' &lt;expr&gt;]

Set a breakpoint.

&lt;filename&gt; - either the filename or the module name. 
&lt;line&gt;     - is the line number to assign the breakpoint to.
&lt;scope&gt;    - is a "fully qualified" function name. That is, not only the 
         function name but also the class name (in case of a member 
         function), such as MyClass.MyMemberFunction.
&lt;expr&gt;     - condition to evaluate in the context of the frame. If it
         evaluates to 'True' the break point will break into the debugger.

In case the &lt;filemame&gt; is omitted, the current file is assumed. In this case 
the debuggee has to be broken.

Examples:

bp test_file.py:20
bp test_file.py:MyClass.Foo
bp 304

Type 'help break' for more information on 'broken' and non 'broken' threads."""
</t>
<t tx="ekr.20060521134315.929">def help_be(self):
    print &gt;&gt; self.stdout, """be (&lt;id_list&gt; | '*')
    
Enable breakpoints.

&lt;id_list&gt; - is a space delimited list of at least one breakpoint id
'*' - Enable all breakpoints."""
</t>
<t tx="ekr.20060521134315.930">def help_bd(self):
    print &gt;&gt; self.stdout, """bd (&lt;id_list&gt; | '*')
    
Disable breakpoints.

&lt;id_list&gt; - is a space delimited list of at least one breakpoint id
'*' - disable all breakpoints."""
</t>
<t tx="ekr.20060521134315.931">def help_bc(self):
    print &gt;&gt; self.stdout, """bc (&lt;id_list&gt; | '*')
    
Clear (delete) breakpoints.

&lt;id_list&gt; - is a space delimited list of at least one breakpoint id
'*' - clear all breakpoints."""
</t>
<t tx="ekr.20060521134315.932">def help_bl(self):
    print &gt;&gt; self.stdout, """bl

List all breakpoints, sorted by their id."""
</t>
<t tx="ekr.20060521134315.933">def help_load(self):
    print &gt;&gt; self.stdout, """load [&lt;filename&gt;]
    
Load breakpoints.

&lt;filename&gt; - optional breakpoints filename. The filename should not include
         a file extension."""
</t>
<t tx="ekr.20060521134315.934">def help_save(self):
    print &gt;&gt; self.stdout, """save [&lt;filename&gt;]
    
save breakpoints.

&lt;filename&gt; - optional breakpoints filename. The filename should not include
         a file extension."""
</t>
<t tx="ekr.20060521134315.935">def help_go(self):
    print &gt;&gt; self.stdout, """go [[&lt;filename&gt;':'] (&lt;line&gt; | &lt;scope&gt;)]

(shorthand - g)

Resume execution of a "broken" script. 
If an argument is present, continue execution until that argument is reached.

&lt;filename&gt; - is the file name which basically is the script's name without
         the '.py' extension. 
&lt;line&gt;   - is the line number to assign the breakpoint to.
&lt;scope&gt;  - is a "fully qualified" function name. That is, not only the 
       function name but also the class name (in case of a member 
       function), such as MyClass.MyMemberFunction."""
</t>
<t tx="ekr.20060521134315.936">help_g = help_go

def help_exit(self):
    print &gt;&gt; self.stdout, """exit

Exit the debugger. If the debugger is attached to a script, the debugger
will attempt to detach from the script first."""  
</t>
<t tx="ekr.20060521134315.937">help_EOF = help_exit

def help_host(self):
    print &gt;&gt; self.stdout, """host [&lt;arg&gt;]

Without an argument, 'host' prints the current selected host.
With an argument &lt;arg&gt;, 'host' attempts to resolve &lt;arg&gt; to a known ip 
address or a domain name. If it is successful, that host will become the
selected host. 
The default selected host is the local host.
Subsequent 'attach' commands will be done on the selected host. 

Type 'help attach' for more information."""  
</t>
<t tx="ekr.20060521134315.938">def help_stack(self):
    print &gt;&gt; self.stdout, """stack [&lt;tid&gt; | '*']

(shorthand - k)

Without an argument, 'stack' prints the stack trace of the focused thread.
If the thread is 'broken' a special character will mark the focused frame.

&lt;tid&gt; - print the stack of thread &lt;tid&gt; 
'*'   - print the stacks of all active threads.

Type 'help break' for more information on 'broken' and un-'broken' threads.
Type 'help up' or 'help down' for more information on focused frames."""  
</t>
<t tx="ekr.20060521134315.939">help_k = help_stack

def help_list(self):
    print &gt;&gt; self.stdout, """list [&lt;file_name&gt;:][&lt;line_no&gt; | '+' | '-' | '^' | '*'] [',' &lt;nlines&gt;]

(shorthand - l)

Without an argument, 'list' prints the source lines around the current line
of the focused thread in the focused frame. A special character sequence will 
mark the current line according to the event:

'C&gt;' - call - A function is called.
'L&gt;' - line - The interpreter is about to execute a new line of code.
'R&gt;' - return - A function is about to return.
'E&gt;' - exception - An exception has been thrown.
'*&gt;' - unbroken - The thread is running.

If a breakpoint is assigned to a line, that line will be marked with:

'B' - if the breakpoint is enabled
'D' - if the breakpoint is disabled

&lt;file_name&gt; - List source from filename    
&lt;line_no&gt;   - Print the source lines around that line number in the same file 
          of the current line.
'+'         - Print the next lines in the file.
'-'         - Print the previous lines in the file.
'^'         - Print the entire file.
'*'         - Print the source lines for each of the active threads.
&lt;nlines&gt;    - Print &lt;nlines&gt; of source

Type 'help break' for more information on 'broken' and un-'broken' threads.
Type 'help up' or 'help down' for more information on focused frames."""  
</t>
<t tx="ekr.20060521134315.940">help_l = help_list

def help_thread(self):
    print &gt;&gt; self.stdout, """thread [&lt;no&gt; | &lt;tid&gt;]

(shorthand - t)

Without an argument, 'thread' prints the list of known active threads, with
their corresponding state, which can be either 'broken' or 'running'.
A special character will mark the focused thread.

With an argument &lt;tid&gt;, 'thread' will attempt to set the debugger focus to
the thread of that tid.
With an argument &lt;no&gt;, 'thread' will attempt to set the debugger focus to 
the thread of that order in the thread list.

Type 'help break' for more information on 'broken' and non 'broken' threads."""
</t>
<t tx="ekr.20060521134315.941">help_t = help_thread

def help_jump(self):
    print &gt;&gt; self.stdout, """jump &lt;lineno&gt;

(shorthand - j)

Jump to line &lt;lineno&gt; in the current scope."""
</t>
<t tx="ekr.20060521134315.942">help_j = help_jump

def help_next(self):
    print &gt;&gt; self.stdout, """next

(shorthand - n)

Continue execution until the next line in the current function
is reached or it returns."""

help_n = help_next</t>
<t tx="ekr.20060521134315.943">

def help_step(self):
    print &gt;&gt; self.stdout, """next

(shorthand - s)

Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function)."""
</t>
<t tx="ekr.20060521134315.944">help_s = help_step    

def help_return(self):
    print &gt;&gt; self.stdout, """next

(shorthand - r)

Continue execution until the current function returns."""

help_r = help_return  </t>
<t tx="ekr.20060521134315.945">  

def help_up(self):
    print &gt;&gt; self.stdout, """up

move the debugger focus one frame up the stack of the debugged thread 
(closer to the current, most recently executed frame). Evaluation of 
expressions or execution of statements will be done at the local and global 
name spaces of the focused frame.

Type 'help eval' for more information on evaluation of expressions.
Type 'help exec' for more information on execution of statements."""
</t>
<t tx="ekr.20060521134315.946">def help_down(self):
    print &gt;&gt; self.stdout, """down

move the debugger focus one frame down the stack of the debugged thread 
(closer to the current, most recently executed frame). Evaluation of 
expressions or execution of statements will be done at the local and global 
name spaces of the focused frame.

Type 'help eval' for more information on evaluation of expressions.
Type 'help exec' for more information on execution of statements."""
</t>
<t tx="ekr.20060521134315.947">def help_eval(self):
    print &gt;&gt; self.stdout, """eval &lt;expr&gt;

(shorthand - v)

Evaluate the python expression &lt;expr&gt; under the global and local name spaces
of the currently focused frame.

Example:
'eval locals()' - will display the dictionary of the local variables.

IMPORTANT: Any changes to the global name space will be discarded unless the
focused stack frame is the top most frame.

Type 'help up' or 'help down' for more information on focused frames."""  

help_v = help_eval</t>
<t tx="ekr.20060521134315.948">

def help_exec(self):
    print &gt;&gt; self.stdout, """exec &lt;stmt&gt;

(shorthand - x)

Execute the python suite &lt;stmt&gt; under the global and local name spaces
of the currently focused frame.

Example:
'exec i += 1'

IMPORTANT: Any changes to the global name space will be discarded unless the
focused stack frame is the top most frame.

Type 'help up' or 'help down' for more information on focused frames."""

help_x = help_exec
</t>
<t tx="ekr.20060521134315.949"></t>
<t tx="ekr.20060521134315.950">def __settrace():
    if g_debugger == None:
        return
        
    f = sys._getframe(2)
    g_debugger.settrace(f, f_break_on_init = False)
</t>
<t tx="ekr.20060521134315.951">def __start_embedded_debugger(pwd, fAllowUnencrypted, fRemote, timeout, fDebug):

    global g_server
    global g_debugger
    global g_fDebug

    try:
        g_server_lock.acquire()
        
        if g_debugger != None:
            f = sys._getframe(2)
            g_debugger.setbreak(f)
            return

        g_fDebug = fDebug
        
        xmlrpclib.loads(XML_DATA)    

        if (not fAllowUnencrypted) and not is_encryption_supported():
            raise EncryptionNotSupported
        
        f = sys._getframe(2)
        filename = my_abspath(f.f_code.co_filename)
        
        g_debugger = CDebuggerEngine()

        g_server = CDebuggeeServer(filename, g_debugger, pwd, fAllowUnencrypted, fRemote)
        g_server.start()

        g_debugger.settrace(f, timeout = timeout)

    finally:
        g_server_lock.release()</t>
<t tx="ekr.20060521134315.952">def StartServer(args, fchdir, pwd, fAllowUnencrypted, fRemote, rid): 
    global g_server
    global g_debugger
    
    try:
        ExpandedFilename = FindFile(args[0])
    except IOError:
        print 'File', args[0], ' not found.'

    if fchdir:   
        #
        # Insert script directory in front of file search path
        #
        sys.path.insert(0, os.path.dirname(ExpandedFilename))
        os.chdir(os.path.dirname(ExpandedFilename))
    else:
        cwd = os.getcwd()
        if cwd not in sys.path:
            sys.path.insert(0, cwd)

    sys.argv = args

    d = {}
    d['__builtins__'] = __main__.__dict__['__builtins__']
    d['__name__'] = '__main__'
    d['__file__'] = ExpandedFilename
    d['__doc__'] = None
    
    g_debugger = CDebuggerEngine()

    g_server = CDebuggeeServer(ExpandedFilename, g_debugger, pwd, fAllowUnencrypted, fRemote, rid)
    g_server.start()

    g_debugger.settrace()

    execfile(ExpandedFilename, d, d)
    #g_debugger.stoptrace()
    #g_server.stop()</t>
<t tx="ekr.20060521134315.953">def StartClient(command_line, fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host):
    if (not fAllowUnencrypted) and not is_encryption_supported():
        print STR_ENCRYPTION_SUPPORT_ERROR
        return 2
        
    sm = CSessionManager(pwd, fAllowUnencrypted, fRemote, host)
    c = CConsole(sm)
    c.start()

    if fAttach:
        sm.attach_nothrow(command_line)
    elif command_line != '':
        sm.launch_nothrow(fchdir, command_line)
        
    c.join()
</t>
<t tx="ekr.20060521134315.954">def PrintUsage(fExtended = False):
    scriptName = os.path.basename(sys.argv[0])
    print """ %(rpdb)s [options] [&lt;script-name&gt; [&lt;script-args&gt;...]]

    Where the options can be a combination of the following:
    -h, --help      print this help.
    -d, --debugee   start debugee and break into it, without starting a 
                    debugger console. 
    -a, --attach    Attach to an already started debuggee.
    -o, --host      Specify host for attachment.
    -r, --remote    Allow debuggees to accept connections from remote machines.
    -t, --plaintext Allow unencrypted connections between debugger and 
                    debuggees.
    -p, --pwd       Password. This flag is available only on NT systems. 
                    On other systems the password will be queried interactively 
                    if it is needed.
    -s, --screen    Use the Unix screen utility when spawning the debuggee.
    -c, --chdir     Change the working directory to that of the launched 
                    script.
    --debug         Debug prints.
""" % {"rpdb": scriptName}
    
    if not fExtended:
        return
        
    print __doc__</t>
<t tx="ekr.20060521134315.955">def main(StartClient_func = StartClient):
    global g_fScreen
    global g_fDebug
    
    create_rpdb_settings_folder()

    try:
        options, args = getopt.getopt(
                            sys.argv[1:], 
                            'hdao:rtp:sc', 
                            ['help', 'debugee', 'attach', 'host=', 'remote', 'plaintext', 'pwd=', 'rid=', 'screen', 'chdir', 'debug']
                            )

    except getopt.GetoptError, e:
        print e
        return 2
        
    fWrap = False
    fAttach = False
    fSpawn = False
    fStart = False
    
    secret = None
    host = None
    pwd = None
    fchdir = False
    fRemote = False
    fAllowUnencrypted = True ### EKR: was False
    
    for o, a in options:
        if o in ['-h', '--help']:
            PrintUsage()
            return 0
        if o in ['--debug']:
            g_fDebug = True 
        if o in ['-d', '--debugee']:
            fWrap = True
        if o in ['-a', '--attach']:
            fAttach = True
        if o in ['-o', '--host']:
            host = a
        if o in ['-r', '--remote']:
            fRemote = True
        if o in ['-t', '--plaintext']:
            fAllowUnencrypted = True
        if o in ['-p', '--pwd']:
            pwd = a
        if o in ['--rid']:
            secret = a
        if o in ['-s', '--screen']:
            g_fScreen = True
        if o in ['-c', '--chdir']:
            fchdir = True
            
    

    if (pwd != None) and (os.name != 'nt'):
        print STR_PASSWORD_NOT_SUPPORTED
        return 2

    if fWrap and (len(args) == 0):
        print "--debuggee option requires a script name with optional &lt;script-arg&gt; arguments"
        return 2
        
    if fWrap and fAttach:
        print "--debuggee and --attach can not be used together."
        return 2
        
    if fAttach and (len(args) == 0):
        print "--attach option requires a script name to attach to."
        return 2
        
    if fAttach and (len(args) &gt; 1):
        print "--attach option does not accept &lt;script-arg&gt; arguments."
        return 2

    if fAttach and fRemote:
        print "--attach and --remote can not be used together."
        return 2
        
    if (host != None) and not fAttach:
        print "--host can only be used together with --attach."
        return 2

    if host == None:
        host = LOCAL_HOST    

    fSpawn = (len(args) != 0) and (not fWrap) and (not fAttach)
    fStart = (len(args) == 0)
    
    if fchdir and not (fWrap or fSpawn):
        print "-c can only be used when launching or starting a script from command line."
        return 2

    assert (fWrap + fAttach + fSpawn + fStart) == 1

    if fAttach and (os.name == 'posix'):
        try:
            int(args[0])

            pwd = read_pwd_file(args[0])
            delete_pwd_file(args[0])

        except (ValueError, IOError):
            pass
            
    if (secret != None) and (os.name == 'posix'):
        pwd = read_pwd_file(secret)
        
    if (fWrap or fAttach) and (pwd in [None, '']):
        print STR_PASSWORD_MUST_BE_SET
        
        while True:
            _pwd = raw_input(STR_PASSWORD_INPUT)
            pwd = _pwd.rstrip('\n')
            if pwd != '':
                break

        print STR_PASSWORD_CONFIRM       
                
    if fWrap or fSpawn:
        #
        # Prevent rpdb from trying to debug itself, so it doesn't blow up :)
        #
        if os.path.basename(args[0]) in [DEBUGGER_FILENAME]:
            print 'Cannot debug self.'
            return 2

        try:
            FindFile(args[0])
        except IOError:
            print STR_FILE_NOT_FOUND % (args[0], )
            return 2
            
    if fWrap:
        if (not fAllowUnencrypted) and not is_encryption_supported():
            print STR_ENCRYPTION_SUPPORT_ERROR
            return 2

        StartServer(args, fchdir, pwd, fAllowUnencrypted, fRemote, secret)
        
    elif fAttach:
        StartClient_func(args[0], fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host)
        
    elif fStart:
        StartClient_func('', fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host)
        
    else:
        if len(args) == 0:
            _args = ''
        else:
            _args = '"' + string.join(args, '" "') + '"'

        StartClient_func(_args, fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host)
   
    return 0
</t>
<t tx="ekr.20060521134315.956">import rpdb2

#
# Debuggee breaks (pauses) here
# on unhandled exceptions.
# Use analyze mode for post mortem.
# type 'help analyze' for more information.
#
ret = rpdb2.main()

#
# Debuggee breaks (pauses) here 
# before program termination.
#
sys.exit(ret)</t>
<t tx="ekr.20060521134315.957">@first #! /usr/bin/env python

&lt;&lt; docstring &gt;&gt;
&lt;&lt; copyright &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; constants &gt;&gt;

@language python
@tabwidth -4

@others

if __name__=='__main__':
    ret = main()
    sys.exit(ret)

    
    
</t>
<t tx="ekr.20060521134315.958">"""
    winpdb.py

    A GUI for rpdb2.py

    Copyright (C) 2005 Nir Aides

    This program is free software; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or any later 
    version.

    This program is distributed in the hope that it will be useful, 
    but WITHOUT ANY WARRANTY; without even the implied warranty of 
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along 
    with this program; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    
"""</t>
<t tx="ekr.20060521134315.959">ABOUT_NOTICE = """winpdb.py

A GUI for rpdb2.py

Copyright (C) 2005 Nir Aides

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2 of the License, or any later 
version.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 

See the GNU General Public License for more details."""

LICENSE_NOTICE = """
This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2 of the License, or any later 
version.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU General Public License for more details.

A copy of the GPL with the precise terms and conditions for 
copying, distribution and modification follow:
"""

COPY_OF_THE_GPL_LICENSE = """
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. 
This License applies to any program or other work which contains a notice 
placed by the copyright holder saying it may be distributed under the terms 
of this General Public License. The "Program", below, refers to any such 
program or work, and a "work based on the Program" means either the Program 
or any derivative work under copyright law: that is to say, a work containing 
the Program or a portion of it, either verbatim or with modifications and/or 
translated into another language. (Hereinafter, translation is included 
without limitation in the term "modification".) Each licensee is addressed 
as "you".

Activities other than copying, distribution and modification are not covered 
by this License; they are outside its scope. The act of running the Program 
is not restricted, and the output from the Program is covered only if its 
contents constitute a work based on the Program (independent of having been 
made by running the Program). Whether that is true depends on what the 
Program does.

1. 
You may copy and distribute verbatim copies of the Program's source code as 
you receive it, in any medium, provided that you conspicuously and 
appropriately publish on each copy an appropriate copyright notice and 
disclaimer of warranty; keep intact all the notices that refer to this 
License and to the absence of any warranty; and give any other recipients of 
the Program a copy of this License along with the Program.

You may charge a fee for the physical act of transferring a copy, and you 
may at your option offer warranty protection in exchange for a fee.

2. 
You may modify your copy or copies of the Program or any portion of it, thus 
forming a work based on the Program, and copy and distribute such modifications 
or work under the terms of Section 1 above, provided that you also meet all 
of these conditions:

    a) You must cause the modified files to carry prominent notices stating 
    that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in whole 
    or in part contains or is derived from the Program or any part thereof, 
    to be licensed as a whole at no charge to all third parties under the 
    terms of this License.

    c) If the modified program normally reads commands interactively when 
    run, you must cause it, when started running for such interactive use in 
    the most ordinary way, to print or display an announcement including an 
    appropriate copyright notice and a notice that there is no warranty (or 
    else, saying that you provide a warranty) and that users may redistribute 
    the program under these conditions, and telling the user how to view a 
    copy of this License. (Exception: if the Program itself is interactive 
    but does not normally print such an announcement, your work based on the 
    Program is not required to print an announcement.)

These requirements apply to the modified work as a whole. If identifiable 
sections of that work are not derived from the Program, and can be reasonably 
considered independent and separate works in themselves, then this License, 
and its terms, do not apply to those sections when you distribute them as 
separate works. But when you distribute the same sections as part of a whole 
which is a work based on the Program, the distribution of the whole must be 
on the terms of this License, whose permissions for other licensees extend to 
the entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest your 
rights to work written entirely by you; rather, the intent is to exercise the 
right to control the distribution of derivative or collective works based on 
the Program.

In addition, mere aggregation of another work not based on the Program with 
the Program (or with a work based on the Program) on a volume of a storage or 
distribution medium does not bring the other work under the scope of this 
License.

3. You may copy and distribute the Program (or a work based on it, under 
Section 2) in object code or executable form under the terms of Sections 1 
and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable source 
    code, which must be distributed under the terms of Sections 1 and 2 above 
    on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three years, to 
    give any third party, for a charge no more than your cost of physically 
    performing source distribution, a complete machine-readable copy of the 
    corresponding source code, to be distributed under the terms of Sections 
    1 and 2 above on a medium customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer to 
    distribute corresponding source code. (This alternative is allowed only 
    for noncommercial distribution and only if you received the program in 
    object code or executable form with such an offer, in accord with 
    Subsection b above.)

The source code for a work means the preferred form of the work for making 
modifications to it. For an executable work, complete source code means all 
the source code for all modules it contains, plus any associated interface 
definition files, plus the scripts used to control compilation and 
installation of the executable. However, as a special exception, the source 
code distributed need not include anything that is normally distributed (in 
either source or binary form) with the major components (compiler, kernel, 
and so on) of the operating system on which the executable runs, unless that 
component itself accompanies the executable.

If distribution of executable or object code is made by offering access to 
copy from a designated place, then offering equivalent access to copy the 
source code from the same place counts as distribution of the source code, 
even though third parties are not compelled to copy the source along with 
the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as 
expressly provided under this License. Any attempt otherwise to copy, modify, 
sublicense or distribute the Program is void, and will automatically 
terminate your rights under this License. However, parties who have received 
copies, or rights, from you under this License will not have their licenses 
terminated so long as such parties remain in full compliance.

5. You are not required to accept this License, since you have not signed it. 
However, nothing else grants you permission to modify or distribute the 
Program or its derivative works. These actions are prohibited by law if you 
do not accept this License. Therefore, by modifying or distributing the 
Program (or any work based on the Program), you indicate your acceptance of 
this License to do so, and all its terms and conditions for copying, 
distributing or modifying the Program or works based on it.

6. Each time you redistribute the Program (or any work based on the Program), 
the recipient automatically receives a license from the original licensor to 
copy, distribute or modify the Program subject to these terms and conditions. 
You may not impose any further restrictions on the recipients' exercise of 
the rights granted herein. You are not responsible for enforcing compliance 
by third parties to this License.

7. If, as a consequence of a court judgment or allegation of patent 
infringement or for any other reason (not limited to patent issues), 
conditions are imposed on you (whether by court order, agreement or otherwise) 
that contradict the conditions of this License, they do not excuse you from 
the conditions of this License. If you cannot distribute so as to satisfy 
simultaneously your obligations under this License and any other pertinent 
obligations, then as a consequence you may not distribute the Program at all. 
For example, if a patent license would not permit royalty-free redistribution 
of the Program by all those who receive copies directly or indirectly through 
you, then the only way you could satisfy both it and this License would be to 
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under any 
particular circumstance, the balance of the section is intended to apply and 
the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any patents 
or other property right claims or to contest validity of any such claims; 
this section has the sole purpose of protecting the integrity of the free 
software distribution system, which is implemented by public license 
practices. Many people have made generous contributions to the wide range of 
software distributed through that system in reliance on consistent 
application of that system; it is up to the author/donor to decide if he or 
she is willing to distribute software through any other system and a licensee 
cannot impose that choice.

This section is intended to make thoroughly clear what is believed to be a 
consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain 
countries either by patents or by copyrighted interfaces, the original 
copyright holder who places the Program under this License may add an 
explicit geographical distribution limitation excluding those countries, 
so that distribution is permitted only in or among countries not thus 
excluded. In such case, this License incorporates the limitation as if 
written in the body of this License.

9. The Free Software Foundation may publish revised and/or new versions of 
the General Public License from time to time. Such new versions will be 
similar in spirit to the present version, but may differ in detail to 
address new problems or concerns.

Each version is given a distinguishing version number. If the Program 
specifies a version number of this License which applies to it and 
"any later version", you have the option of following the terms and 
conditions either of that version or of any later version published by the 
Free Software Foundation. If the Program does not specify a version number 
of this License, you may choose any version ever published by the 
Free Software Foundation.

10. If you wish to incorporate parts of the Program into other free programs 
whose distribution conditions are different, write to the author to ask for 
permission. For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this. Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR 
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE 
STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE 
PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER 
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGES.

END OF TERMS AND CONDITIONS
"""</t>
<t tx="ekr.20060521134315.960">import sys

WXVER = "2.6"

STR_WXPYTHON_ERROR = """wxPython was not found.
wxPython 2.6 or higher is required to run the winpdb GUI.
You can get more information on wxPython in http://www.wxpython.org/
To use the debugger without a GUI, run rpdb2.py or _rpdb2.py"""

if 'wx' not in sys.modules:
    try:
        import wxversion   
        wxversion.ensureMinimal(WXVER)
    except ImportError:
        print STR_WXPYTHON_ERROR
        sys.exit(1)

import wx
assert wx.VERSION_STRING &gt;= WXVER
        
import wx.lib.wxpTag
import wx.gizmos
import wx.html

import wx.lib.mixins.listctrl  as  listmix
import wx.stc as stc

import webbrowser
import traceback
import cStringIO
import threading
import xmlrpclib
import cPickle
import keyword
import base64
import socket
import string
import Queue
import rpdb2
import time
import os</t>
<t tx="ekr.20060521134315.961">ENABLED = True
DISABLED = False

&lt;&lt; marker constants &gt;&gt;
&lt;&lt; strings &gt;&gt;
&lt;&lt; configuration constants &gt;&gt;
&lt;&lt; menu constants &gt;&gt;
&lt;&lt; bitmaps &gt;&gt;
&lt;&lt; menu definition dicts &gt;&gt;
&lt;&lt; about menu constants &gt;&gt;</t>
<t tx="ekr.20060521134315.962">MARKER_BREAKPOINT_ENABLED = 5
MARKER_BREAKPOINT_DISABLED = 6
MARKER_CURRENT_LINE = 7
MARKER_CURRENT_LINE_HIT = 8

MARKER_CALL = 0
MARKER_LINE = 1
MARKER_RETURN = 2
MARKER_EXCEPTION = 3
MARKER_RUNNING = 4

MARKER_LIST = [
    MARKER_BREAKPOINT_ENABLED, MARKER_BREAKPOINT_DISABLED, MARKER_CURRENT_LINE,
    MARKER_CURRENT_LINE_HIT, MARKER_CALL, MARKER_LINE, MARKER_RETURN, MARKER_EXCEPTION, MARKER_RUNNING
]</t>
<t tx="ekr.20060521134315.963">CAPTION_SOURCE = "Source"
CAPTION_CONSOLE = "Console"
CAPTION_THREADS = "Threads"
CAPTION_STACK = "Stack"
CAPTION_NAMESPACE = "Namespace"

CONSOLE_PROMPT = "\n&gt; "

MSG_WARNING_TITLE = "Warning"
MSG_ERROR_TITLE = "Error"
MSG_ERROR_HOST_TEXT = "Host '%s' not found."
MSG_ERROR_FILE_NOT_FOUND = "File not found."
MSG_ERROR_FILE_NOT_PYTHON = "Only Python files that end with '.py' are accepted."

STR_FILE_LOAD_ERROR = "Failed to load source file '%s' from debuggee."
STR_FILE_LOAD_ERROR2 = """Failed to load source file '%s' from debuggee.
You may continue to debug, but you will not see source lines from this file."""

DLG_EXPR_TITLE = "Enter Expression"
DLG_PWD_TITLE = "Password"
DLG_OPEN_TITLE = "Open Source"
DLG_LAUNCH_TITLE = "Launch"
DLG_ATTACH_TITLE = "Attach"

STATIC_EXPR = """The new expression will be evaluated at the debuggee
and its value will be set to the item."""

STATIC_PWD = """The password is used to secure communitcation between
the debugger console and the debuggee. Debuggees with
unmatching passwords will not appear in the attach
query list."""

STATIC_OPEN = """The source file entered will be fetched from the debugee."""
LABEL_EXPR = "New Expression:"
LABEL_PWD = "Set password:"
LABEL_OPEN = "File name:"
LABEL_LAUNCH_COMMAND_LINE = "Command line:"
LABEL_ATTACH_HOST = "Host:"
LABEL_CONSOLE = "Command:"
BUTTON_LAUNCH_BROWSE = "Browse"
BUTTON_ATTACH_REFRESH = "Refresh"
CHECKBOX_LAUNCH = "Set working directory to the script folder."

HLIST_HEADER_PID = "PID"
HLIST_HEADER_FILENAME = "Filename"

HLIST_HEADER_TID = "TID"
HLIST_HEADER_STATE = "State"

HLIST_HEADER_FRAME = "Frame"
HLIST_HEADER_LINENO = "Line"
HLIST_HEADER_FUNCTION = "Function"
HLIST_HEADER_PATH = "Path"

TLC_HEADER_NAME = "Name"
TLC_HEADER_REPR = "Repr"
TLC_HEADER_TYPE = "Type"

WINPDB_TITLE = "Winpdb 1.0.6"
WINPDB_VERSION = "WINPDB_1_0_6"

WINPDB_SIZE = "winpdb_size"
WINPDB_MAXIMIZE = "winpdb_maximize"
SPLITTER_1_POS = "splitter_1_pos"
SPLITTER_2_POS = "splitter_2_pos"
SPLITTER_3_POS = "splitter_3_pos"
SPLITTER_4_POS = "splitter_4_pos"

SB_LINE = "Line"
SB_COL = "Col"
SB_STATE = "State"
SB_ENCRYPTION = "Encryption"

SHOW = "Show"
VALUE = "Value"
BITMAP = "Bitmap"

PWD_TIP = "Set connection password."
LAUNCH_TIP = "Launch a new debugged script."
ATTACH_TIP = "Attach to a debugged script."
DETACH_TIP = "Detach from debugged sctipt."
STOP_TIP = "Shutdown the debugged script."
OPEN_TIP = "Open source file in the source viewer."
WEBSITE_TIP = "Open the Winpdb homepage."
SUPPORT_TIP = "Open the Winpdb support web page."
DOCS_TIP = "Open the Winpdb online documentation web page."
UPDATES_TIP = "Check for updates in the Winpdb website."
TOGGLE_TIP = "Toggle breakpoint at cursor location."
DISABLE_TIP = "Disable all breakpoints."
ENABLE_TIP = "Enable all breakpoints."
CLEAR_TIP = "Clear all breakpoints."
LOAD_TIP = "Load breakpoints from file."
SAVE_TIP = "Save breakpoints to file."

TOOLTIP_UNLOCKED = "Communication channel is authenticated but NOT encrypted."
TOOLTIP_LOCKED = "Communication channel is authenticated AND encrypted."

LICENSE_TITLE = 'License.'

STR_ERROR_INTERFACE_COMPATIBILITY = "The rpdb2 module which was found by Winpdb is of unexpected version (version expected: %s, version found: %s). Please upgrade to the latest versions of winpdb.py and rpdb2.py."</t>
<t tx="ekr.20060521134315.964">WINPDB_WILDCARD = "Python source (*.py)|*.py|All files (*.*)|*.*"

WINPDB_SIZE_MIN = (640, 480)

SETTINGS_FILENAME_EXT = ".cfg"

WINPDB_SETTINGS_PATH = "winpdb"

WINPDB_SETTINGS_FILENAME = "winpdb_settings"

WINPDB_SETTINGS_DEFAULT = {
    WINPDB_SIZE: (800, 600),
    WINPDB_MAXIMIZE: False,
    SPLITTER_1_POS: 190,
    SPLITTER_2_POS: 294,
    SPLITTER_3_POS: 382,
    SPLITTER_4_POS: 305
}

BAD_FILE_WARNING_TIMEOUT_SEC = 10.0</t>
<t tx="ekr.20060521134315.965">AC_CHAR = "\t"
AC_EXIT = "Alt-X"
AC_BREAK = "F4"
AC_GO = "F5"
AC_NEXT = "F6"
AC_STEP = "F7"
AC_GOTO = "F8"
AC_TOOGLE = "F9"
AC_RETURN = "F12"

ML_EMPTY = "&lt;empty&gt;"
ML_SEPARATOR = "&lt;separator&gt;"
ML_ROOT = "&lt;root&gt;"

ML_FILE = "&amp;File"
ML_PWD = "&amp;Password"
ML_LAUNCH = "&amp;Launch"
ML_ATTACH = "&amp;Attach"
ML_DETACH = "&amp;Detach"
ML_STOP = "&amp;Stop"
ML_OPEN = "&amp;Open Source"
ML_EXIT = "E&amp;xit" + AC_CHAR + AC_EXIT

ML_BREAKPOINTS = "&amp;Breakpoints"
ML_TOGGLE = "&amp;Toggle" + AC_CHAR + AC_TOOGLE
ML_DISABLE = "&amp;Disable All"
ML_ENABLE = "&amp;Enable All"
ML_CLEAR = "&amp;Clear All"
ML_LOAD = "&amp;Load"
ML_SAVE = "&amp;Save"

ML_CONTROL = "&amp;Control"
ML_GO = "&amp;Go" + AC_CHAR + AC_GO
ML_BREAK = "&amp;Break" + AC_CHAR + AC_BREAK
ML_STEP = "&amp;Step" + AC_CHAR + AC_STEP
ML_NEXT = "&amp;Next" + AC_CHAR + AC_NEXT
ML_RETURN = "&amp;Return" + AC_CHAR + AC_RETURN
ML_GOTO = "&amp;Run to Cursor" + AC_CHAR + AC_GOTO

ML_WINDOW = "&amp;Window"

ML_HELP = "&amp;Help"
ML_WEBSITE = "&amp;Website"
ML_SUPPORT = "&amp;Support"
ML_DOCS = "&amp;Online Docs"
ML_UPDATES = "&amp;Check for Updates"
ML_LICENSE = "&amp;License"
ML_ABOUT = "&amp;About"

TB_GO = "Go"
TB_BREAK = "Break"
TB_STEP = "Step"
TB_NEXT = "Next"
TB_RETURN = "Return"
TB_GOTO = "Run to Cursor"
TB_TOGGLE_BP = "Toggle breakpoint."
TB_FILTER = "Filter modules, classes, and functions from global namespace."
TB_EXCEPTION = "Analyze Exception."

COMMAND = "command"
TOOLTIP = "tooltip"
DATA = "data"
DATA2 = "data2"
ID = "id"
LABEL = "label"
FORMAT = "format"
KEYS = "keys"
WIDTH = "width"</t>
<t tx="ekr.20060521134315.966">TOOLBAR_BITMAP_SIZE = (23, 21)

BASE64_BREAK = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVBAMAAABfzGiYAAAAElBMVEUABwAAAIAAScCsqJn///8BAQEretZKAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0LNTlFzNXOAAABHElEQVR4AQERAe7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzMzMzMAAAAAAAAAA0RERERDAAAAAAAAAANEREREQwAAAAAAAAADRVVEREMAAAAAAAAAA0RERERDAAAAAAAAAANEVVVVQwAAAAAAAAADREREREMSASAAAAAAA0RVVVVDIQIQAAAAAANEREREQxIBIAAAAAADREVVVEMhAhAAAAAAA0RERERDEgEgAAAAAANEVVVVQyECEAAAAAADREREREMSASAAAAAAA0RERERDAAAAAAAAAAMzMzMzMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdU4VleIq9nkAAAAASUVORK5CYII="
BASE64_GO = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVBAMAAABfzGiYAAAAD1BMVEUDAAAAAICsqJn///8BAQEmZTuKAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0MJDaD5f3KAAABHElEQVR4AQERAe7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIiIiIiIAAAAAAAAAAjMzMzMyAAAAAAAAAAIzMzMzMgAQAAAAAAACNEQzMzIAEAAAAAAAAjMzMzMyABAAAAAAAAIzREREMgAQAAAAAAACMzMzMzIAEAAAAAAAAjNEREQyABAAAAAAAAIzMzMzMgAQAAAAAAACMzREQzIAEAAAAAAAAjMzMzMyABAAAAAAAAIzREREMhEREAAAAAACMzMzMzIBEQAAAAAAAjMzMzMyABAAAAAAAAIiIiIiIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkgkQCtNT0YAAAAAASUVORK5CYII="
BASE64_STEP = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVAgMAAADQjJ04AAAACVBMVEWzAAIAAIABAQHnktlqAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0MKBtqj+6zAAAAnklEQVR4AQGTAGz/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFVUAAAAAAAAAQAAAAAAAABAAAAAAACgQoAAAAACgECgAAAAAoBAoAAAAAKFVKAAAAACgVCgAAAACgBAKAAAAAKAAKAAAAACgACgAAAAAoAAoAAAAAKAAKAAAAAAoAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIZYHmtBlz3kAAAAASUVORK5CYII="
BASE64_NEXT = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVAgMAAADQjJ04AAAACVBMVEWzAAIAAIABAQHnktlqAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0MKTIxJkeeAAAAnklEQVR4AQGTAGz/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVVVAAAAABAAAEAAAAAAAAAQAAAAAKKAEAAAAAKAoBAAAAACgKAQAAAAAoChVQAAAAKAoFQAAAAKACgQAAAAAoCgAAAAAAKAoAAAAAACgKAAAAAAAoCgAAAAAACigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf7IExY7m3XoAAAAASUVORK5CYII="
BASE64_RETURN = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVAgMAAADQjJ04AAAACVBMVEWzAAIAAIABAQHnktlqAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0MKjYdZtBEAAAAnklEQVR4AQGTAGz/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVQAAAAAABABAAAAAABAAEAAAAAoSgBAAAAAoEKAQAAAAKBCgEAAAACgAoVUAAAAoAKBUAAAAoAAoEAAAACgAoAAAAAAoAKAAAAAAKACgAAAAACgAoAAAAAAKAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/t0N65RYePoAAAAASUVORK5CYII="
BASE64_GOTO = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVAgMAAADQjJ04AAAACVBMVEWzAAIAAIABAQHnktlqAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfVBQ0MKzoNy60uAAAAnklEQVR4AQGTAGz/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECgKAAAAABSgAoAAAAVVoAKAAAAAFKACgAAAABCgAoAAAAACgACgAAAAAKACgAAAAACgAoAAAAAAoAKAAAAAAKACgAAAAAAoCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATuYIySxPH7cAAAAASUVORK5CYII="
BASE64_TOGGLE_BP = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVCAYAAACt4nWrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbklEQVR42u2TwQrAMAhDjez/f9ldpGxjpGnRWwO9FPo00ZodFSjySPJFsEWEXESFR0KfFzYr4EVR9cCZA++c/iVYxS7cmV1laExQNgSAfbflBQF+WSxz5CMK7l7Fbfjovjpz+kNneS/Bi5o8atYN5nssA5y02NcAAAAASUVORK5CYII="
BASE64_LOCKED = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVCAYAAACt4nWrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVR42u2UQRLAEAxFP+NguRm5WW6WbrRjOkqorurvmHiR5ANsVeQsQSlBb2u3JHtKUBFRAApAcyK1nPU9MJGAiM4qXd6HJYHvBRTg4Zb4LwcaZgZa7rcqcaPASpzZdRfYop5zwoJnMNdz5paLBADNw2NsmhQiv7s58/u/6YmgCxhbdR19GFJ+yzjAWQAAAABJRU5ErkJggg=="
BASE64_UNLOCKED = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVCAYAAACt4nWrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR42u1TQQ7DIAyzUR8WXkb4WX7mnSqtFetCxU6rb0jYJLYBHgzAOyR36HTmkmncoYgQSZGUO0RSo7tlVtgsUGuFJEoiALQmjB4os5PvwhlLyi8D3TKBLWtLVrh3HuxJBZbBVUO+2oJFtd3GK38mmAUAuy/e2hXFEPF3k/fOZZ/ooJSp146pjj94xwuYKl+HgD9iOwAAAABJRU5ErkJggg=="

BASE64_FILTER = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVCAYAAACt4nWrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZElEQVR42u3UsQlAIQwE0Is4kvtv4Ez5hY2KmDN8xCLXiATeWQSByO3IdNc/vTxP9ZCvtZ2l2C9vvrpgYXCqwIJ3+LaAgS18WcDCDD4UnMAAkJj1ko5hYRZ3J3D3tqz+HEHkyXxoxx+Czcym0QAAAABJRU5ErkJggg=="
BASE64_EXCEPTION = "iVBORw0KGgoAAAANSUhEUgAAABcAAAAVCAYAAACt4nWrAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZklEQVR42u2UsWrCQBzGv+RKRaMgXmzPXbqESBbXUskTqIODm4/hU7j4BA4+hEhKQVyFEJDiXtsqpjWgWDQdLFdbLiTSli5+U+6f//3ug/v+B5wkkBSlSdP6/vea45jSj+C6bvmEEDCWQzKZ4nXPW2I6fcB2u4Vtl6Sj4bp+66tqFpTSwMPn8zlms2fY9o2QIwc5DgMDAKUUqpqFrlu+6P+ZqEgI4WBZBmq1JEwzjkRCguNs0G6/wnV3/IDFYo5IzjWt7zOW4+tyWUGloqDTWaLVeoFhxNBopL7sYSwnvHSh88PLM804AGAwWEP+sFIonAf2h8IPlcnsid3uJa8pihwp56Fw192BUoJ6/RGbzXFDJLTgeUv+bVkrAECxGAMhAGMEzWY6sD8054Zx5+fzVzwt1aqCUimOdFrGePyG4XCNXm/F+yeTe4xG11Ik+D7nF6E5/xykJ+Gk/umE/s/b8huv4klCvQMz8oLsLpAhfwAAAABJRU5ErkJggg=="</t>
<t tx="ekr.20060521134315.967">
STATE_SPAWNING_MENU = {ENABLED: [ML_STOP, ML_DETACH], DISABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_PWD, ML_LAUNCH, ML_ATTACH]}
STATE_ATTACHING_MENU = {ENABLED: [ML_STOP, ML_DETACH], DISABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_PWD, ML_LAUNCH, ML_ATTACH]}
STATE_BROKEN_MENU = {ENABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_STOP, ML_DETACH], DISABLED: [ML_PWD, ML_LAUNCH, ML_ATTACH]}
STATE_ANALYZE_MENU = {ENABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_STOP, ML_DETACH], DISABLED: [ML_PWD, ML_LAUNCH, ML_ATTACH]}
STATE_RUNNING_MENU = {ENABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_STOP, ML_DETACH], DISABLED: [ML_PWD, ML_LAUNCH, ML_ATTACH]}
STATE_DETACHED_MENU = {ENABLED: [ML_PWD, ML_LAUNCH, ML_ATTACH], DISABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_STOP, ML_DETACH]}
STATE_DETACHING_MENU = {ENABLED: [ML_STOP, ML_DETACH], DISABLED: [ML_GO, ML_BREAK, ML_STEP, ML_NEXT, ML_RETURN, ML_GOTO, ML_TOGGLE, ML_DISABLE, ML_ENABLE, ML_CLEAR, ML_LOAD, ML_SAVE, ML_OPEN, ML_PWD, ML_LAUNCH, ML_ATTACH]}

STATE_BROKEN_TOOLBAR = {ENABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO], DISABLED: [TB_BREAK]}
STATE_ANALYZE_TOOLBAR = {ENABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP], DISABLED: [TB_BREAK, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}
STATE_RUNNING_TOOLBAR = {ENABLED: [TB_TOGGLE_BP, TB_BREAK], DISABLED: [TB_EXCEPTION, TB_FILTER, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}
STATE_SPAWNING_TOOLBAR = {ENABLED: [], DISABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP, TB_BREAK, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}
STATE_ATTACHING_TOOLBAR = {ENABLED: [], DISABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP, TB_BREAK, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}
STATE_DETACHED_TOOLBAR = {ENABLED: [], DISABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP, TB_BREAK, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}
STATE_DETACHING_TOOLBAR = {ENABLED: [], DISABLED: [TB_EXCEPTION, TB_FILTER, TB_TOGGLE_BP, TB_BREAK, TB_GO, TB_STEP, TB_NEXT, TB_RETURN, TB_GOTO]}

STATE_MAP = {
    rpdb2.STATE_SPAWNING: (STATE_SPAWNING_MENU, STATE_SPAWNING_TOOLBAR),
    rpdb2.STATE_ATTACHING: (STATE_ATTACHING_MENU, STATE_ATTACHING_TOOLBAR),
    rpdb2.STATE_BROKEN: (STATE_BROKEN_MENU, STATE_BROKEN_TOOLBAR),
    rpdb2.STATE_ANALYZE: (STATE_ANALYZE_MENU, STATE_ANALYZE_TOOLBAR),
    rpdb2.STATE_RUNNING: (STATE_RUNNING_MENU, STATE_RUNNING_TOOLBAR),
    rpdb2.STATE_DETACHED: (STATE_DETACHED_MENU, STATE_DETACHED_TOOLBAR),    
    rpdb2.STATE_DETACHING: (STATE_DETACHING_MENU, STATE_DETACHING_TOOLBAR)    
}</t>
<t tx="ekr.20060521134315.968">
ABOUT_TITLE = 'About ' + WINPDB_TITLE

ABOUT_HTML_PREFIX = """
&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
"""

ABOUT_HTML_SUFFIX = """
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
"""

WEBSITE_URL = "http://www.digitalpeers.com/pythondebugger/"
SUPPORT_URL = "http://www.digitalpeers.com/pythondebugger/support.htm"
DOCS_URL = "http://www.digitalpeers.com/pythondebugger/docs.htm"
UPDATES_URL = "http://www.digitalpeers.com/pythondebugger/download.htm"</t>
<t tx="ekr.20060521134315.969">class CJobs:
	@others
</t>
<t tx="ekr.20060521134315.970">def __init__(self):
    self.__m_jobs_lock = threading.RLock()
    self.__m_n_expected_jobs = 0
    self.__m_f_shutdown = False
</t>
<t tx="ekr.20060521134315.971">def init_jobs(self):
    pass
</t>
<t tx="ekr.20060521134315.972">def shutdown_jobs(self):    
    self.__m_f_shutdown = True

    while 1:
        try:
            self.__m_jobs_lock.acquire()

            if self.__m_n_expected_jobs == 0:
                return

        finally:        
            self.__m_jobs_lock.release()

        time.sleep(0.1)    
</t>
<t tx="ekr.20060521134315.973">def job_post(self, job, args, callback = None):
    threading.Thread(target = self.job_do, args = (job, args, callback)).start()
</t>
<t tx="ekr.20060521134315.974">def job_do(self, job, args, callback):
    try:
        self.__m_jobs_lock.acquire()

        if self.__m_f_shutdown:
            return
        
        if self.__m_n_expected_jobs == 0:
            wx.CallAfter(self.set_cursor, wx.CURSOR_WAIT)

        self.__m_n_expected_jobs += 1

    finally:        
        self.__m_jobs_lock.release()

    try:
        r = job(*args)
        if r == None:
            r = ()
        elif type(r) != tuple:
            r = (r)
    except:
        rpdb2.print_debug()
        callback = None

    if callback != None:
        wx.CallAfter(callback, *r)
        
    try:
        self.__m_jobs_lock.acquire()
        
        self.__m_n_expected_jobs -= 1

        if self.__m_n_expected_jobs == 0:
            wx.CallAfter(self.set_cursor, wx.CURSOR_ARROW)

    finally:        
        self.__m_jobs_lock.release()
</t>
<t tx="ekr.20060521134315.975">def set_cursor(self, id):
    cursor = wx.StockCursor(id)
    self.SetCursor(cursor)        
</t>
<t tx="ekr.20060521134315.976">class CWinpdbApp(wx.App):
	@others
</t>
<t tx="ekr.20060521134315.977">def __init__(self, session_manager, fchdir, command_line, fAttach, fAllowUnencrypted):
    self.m_frame = None
    self.m_session_manager = session_manager
    self.m_fchdir = fchdir
    self.m_command_line = command_line
    self.m_fAttach = fAttach
    self.m_fAllowUnencrypted = fAllowUnencrypted
    
    self.m_settings = CSettings(WINPDB_SETTINGS_PATH, WINPDB_SETTINGS_FILENAME, WINPDB_SETTINGS_DEFAULT)

    wx.App.__init__(self, redirect = False)
</t>
<t tx="ekr.20060521134315.978">def OnInit(self):
    wx.SystemOptions.SetOptionInt("mac.window-plain-transition", 1)

    self.m_settings.load_settings()
    
    if (not self.m_fAllowUnencrypted) and not rpdb2.is_encryption_supported():
        dlg = wx.MessageDialog(None, rpdb2.STR_ENCRYPTION_SUPPORT_ERROR, MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return True
    
    self.m_frame = CWinpdbWindow(self.m_session_manager, self.m_fchdir, self.m_command_line, self.m_fAttach, self.m_settings)
    self.m_frame.Show()

    self.SetTopWindow(self.m_frame)

    return True
</t>
<t tx="ekr.20060521134315.979">def OnExit(self):
    self.m_settings.save_settings()
</t>
<t tx="ekr.20060521134315.980"></t>
<t tx="ekr.20060521134315.981">class CSettings:
	@others
</t>
<t tx="ekr.20060521134315.982">def __init__(self, path, filename, default_settings):
    self.m_path = path
    self.m_filename = filename
    self.m_dict = default_settings
</t>
<t tx="ekr.20060521134315.983">def calc_path(self):
    if os.name == 'nt' and os.environ.has_key('APPDATA'):
        app_data = os.environ['APPDATA']
        path = app_data + '\\' + self.m_path + '\\' + self.m_filename + SETTINGS_FILENAME_EXT
        return path
        
    elif os.name == 'posix':
        app_data = os.path.expanduser('~')
        path = app_data + '/.' + self.m_filename
        return path

    path = self.m_filename + SETTINGS_FILENAME_EXT        
    return path
</t>
<t tx="ekr.20060521134315.984">def create_path(self):
    if os.name != 'nt':
        return

    path = self.calc_path()    
    folder = os.path.dirname(path)
    if os.path.isdir(folder):
        return

    os.mkdir(folder)        
</t>
<t tx="ekr.20060521134315.985">def load_settings(self):
    try:
        path = self.calc_path()
        f = open(path, 'r')
    except IOError:
        return 
        
    try:
        d = cPickle.load(f)
        self.m_dict.update(d)
    finally:
        f.close()
</t>
<t tx="ekr.20060521134315.986">def save_settings(self):
    self.create_path()

    path = self.calc_path()
    f = open(path, 'w')
    try:
        cPickle.dump(self.m_dict, f)
    finally:
        f.close()
</t>
<t tx="ekr.20060521134315.987">def __getitem__(self, key):
    return self.m_dict[key]
</t>
<t tx="ekr.20060521134315.988">def __setitem__(self, key, value):
    self.m_dict[key] = value
</t>
<t tx="ekr.20060521134315.989">class CMenuBar:
	@others
</t>
<t tx="ekr.20060521134315.990">def __init__(self):
    self.m_menubar = None
    
    self.m_encapsulating_menu_items = {}
    self.m_cascades = {}
</t>
<t tx="ekr.20060521134315.991">def init_menubar(self, resource):
    self.m_menubar = wx.MenuBar()
    self.SetMenuBar(self.m_menubar)

    self.m_cascades = {ML_ROOT: self.m_menubar}
    
    k = resource.keys()
    k.sort()

    for c in k:
        s = (ML_ROOT + c).split('/')
        sc = [e for e in s if not e.isdigit()]
        for i, e in enumerate(sc[:-1]):
            if not e in self.m_cascades:
                parent_label = sc[i - 1]
                parent = self.m_cascades[parent_label]
                child = wx.Menu()

                if parent_label == ML_ROOT:
                    parent.Append(child, e)
                else:
                    parent.AppendMenu(wx.NewId(), e, child)
                    self.m_encapsulating_menu_items[e] = parent

                self.m_cascades[e] = child

        parent_label = sc[-2]
        parent = self.m_cascades[parent_label]
        item_label = sc[-1]

        if item_label == ML_EMPTY:
            continue
            
        if item_label == ML_SEPARATOR:
            parent.AppendSeparator()
            continue

        command = resource[c][COMMAND]
        tip = resource[c].get(TOOLTIP, wx.EmptyString)
        
        item = parent.Append(-1, item_label, tip)
        self.Bind(wx.EVT_MENU, command, item)

        self.m_encapsulating_menu_items[item_label] = parent 
</t>
<t tx="ekr.20060521134315.992">def set_menu_items_state(self, state_label_dict):
    for state, label_list in state_label_dict.items():
        for item_label in label_list:
            parent = self.m_encapsulating_menu_items[item_label]
            id = parent.FindItem(item_label)
            parent.Enable(id, [True, False][state == DISABLED])
</t>
<t tx="ekr.20060521134315.993">def add_menu_item(self, menu_label, item_label, command):
    parent = self.m_cascades[menu_label]
    item = parent.Append(-1, item_label)
    self.Bind(wx.EVT_MENU, command, item)
</t>
<t tx="ekr.20060521134315.994">def clear_menu_items(self, menu_label):    
    parent = self.m_cascades[menu_label]

    while parent.GetMenuItemCount() &gt; 0:
        i = parent.FindItemByPosition(0)
        parent.DeleteItem(i)
</t>
<t tx="ekr.20060521134315.995">class CToolBar:
	@others
</t>
<t tx="ekr.20060521134315.996">def __init__(self):
    self.m_toolbar = None
    self.m_items = {}
</t>
<t tx="ekr.20060521134315.997">def init_toolbar(self, resource):
    self.m_toolbar = self.CreateToolBar(wx.TB_HORIZONTAL | wx.NO_BORDER | wx.TB_FLAT | wx.TB_TEXT)
    self.m_toolbar.SetToolBitmapSize(TOOLBAR_BITMAP_SIZE)
    
    for e in resource:
        item_label = e[LABEL]

        if item_label == ML_SEPARATOR:
            self.m_toolbar.AddSeparator()
            continue

        command = e[COMMAND]
        id = wx.NewId()
        image = image_from_base64(e[DATA])
        bitmap = wx.BitmapFromImage(image)

        if DATA2 in e:
            image2 = image_from_base64(e[DATA2])
            bitmap2 = wx.BitmapFromImage(image2)
            self.m_toolbar.AddSimpleTool(id, bitmap, item_label, isToggle = True)
            self.m_items[item_label] = {ID: id, DATA: bitmap, DATA2: bitmap2}
            self.Bind(wx.EVT_TOOL, command, id = id)
            self.Bind(wx.EVT_TOOL, self.OnToggleTool, id = id)

        else:
            self.m_toolbar.AddSimpleTool(id, bitmap, item_label)
            self.m_items[item_label] = {ID: id}
            self.Bind(wx.EVT_TOOL, command, id = id)
        
    self.m_toolbar.Realize()
</t>
<t tx="ekr.20060521134315.998">def set_toolbar_items_state(self, state_label_dict):
    for state, label_list in state_label_dict.items():
        for label in label_list:
            id = self.m_items[label][ID]

            if (wx.Platform == '__WXGTK__') and (state == ENABLED):
                self.__gtk_enable_tool(id)
            else:    
                self.m_toolbar.EnableTool(id, [True, False][state == DISABLED])
</t>
<t tx="ekr.20060521134315.999">def __gtk_enable_tool(self, id):
    p = self.m_toolbar.ScreenToClient(wx.GetMousePosition())
    (x, y) = self.m_toolbar.GetSize()
    r = wx.RectS((x, y))

    if r.Inside(p):
        self.m_toolbar.WarpPointer(p.x, p.y + 2 * y)

    self.m_toolbar.EnableTool(id, True)

    if r.Inside(p):
        self.m_toolbar.WarpPointer(p.x, p.y) 
</t>
<t tx="ekr.20060521134315.1000">def set_toggle(self, label, fToggle):
    item = self.m_items[label]
    id = item[ID]
    bitmap = [item[DATA], item[DATA2]][fToggle]

    tool = self.m_toolbar.FindById(id)
    tool.SetNormalBitmap(bitmap)
    
    self.m_toolbar.ToggleTool(id, fToggle)
    
    if wx.Platform == '__WXMSW__':
        self.m_toolbar.Realize()
    else:    
        self.m_toolbar.ToggleTool(id, not fToggle);   
        self.m_toolbar.ToggleTool(id, fToggle);
</t>
<t tx="ekr.20060521134315.1001">def OnToggleTool(self, event):
    tool = self.m_toolbar.FindById(event.GetId())
    if tool == None:
        event.Skip()
        return

    label = tool.GetShortHelp()
    f = event.IsChecked()
    
    self.set_toggle(label, f)

    event.Skip()   
</t>
<t tx="ekr.20060521134315.1002">class CStatusBar:
	@others
</t>
<t tx="ekr.20060521134315.1003">def __init__(self):
    self.m_statusbar = None

    self.m_widths = []
    self.m_formats = []
    self.m_keys = []
    self.m_data = {}
    self.m_bitmaps = {}

    self.sizeChanged = False
</t>
<t tx="ekr.20060521134315.1004">def init_statusbar(self, resource):
    self.m_widths = [e[WIDTH] for e in resource]
    self.m_formats = [e.get(FORMAT, "") for e in resource]
    self.m_keys = [e.get(KEYS, []) for e in resource]
    
    self.m_statusbar = self.CreateStatusBar(1, wx.ST_SIZEGRIP)
    self.m_statusbar.SetFieldsCount(len(self.m_widths))
    self.m_statusbar.SetStatusWidths(self.m_widths)
    
    self.m_statusbar.Bind(wx.EVT_SIZE, self.OnSize)
    self.m_statusbar.Bind(wx.EVT_IDLE, self.OnIdle)
</t>
<t tx="ekr.20060521134315.1005">def set_statusbar_data(self, data):
    self.m_data.update(data)

    for i, e in enumerate(self.m_keys):
        for k in e:
            if k in data:
                if self.m_formats[i] == BITMAP:
                    self.set_bitmap(i, data[k][0], data[k][1])
                else:
                    self.m_statusbar.SetStatusText(self.m_formats[i] % self.m_data, i)
                    break
</t>
<t tx="ekr.20060521134315.1006">def set_bitmap(self, i, data, tooltip):
    if not i in self.m_bitmaps:
        if data == None:
            return
            
        image = image_from_base64(data)
        bitmap = wx.BitmapFromImage(image)
        p = wx.Panel(self.m_statusbar)
        sb = wx.StaticBitmap(p, -1, bitmap)

        self.m_bitmaps[i] = (p, sb, tooltip)
        
    else:
        if data == None:
            self.m_bitmaps[i][0].Hide()
        else:
            image = image_from_base64(data)
            bitmap = wx.BitmapFromImage(image)
            
            self.m_bitmaps[i][1].SetBitmap(bitmap)
            self.m_bitmaps[i][0].Show()

    self.reposition()    
</t>
<t tx="ekr.20060521134315.1007">def reposition(self):
    for i, (p, sb, tooltip) in self.m_bitmaps.items():
        rect = self.m_statusbar.GetFieldRect(i)
        p.SetPosition((rect.x + 2, rect.y + 2))
        s = sb.GetSize()
        sb.SetSize((s[0], rect.height - 4))
        p.SetClientSize(sb.GetSize())
        p.SetToolTip(wx.ToolTip(tooltip))
        
    self.sizeChanged = False
</t>
<t tx="ekr.20060521134315.1008">def OnSize(self, event):
    self.reposition()
    self.sizeChanged = True
</t>
<t tx="ekr.20060521134315.1009">def OnIdle(self, event):
    if self.sizeChanged:
        self.reposition()
</t>
<t tx="ekr.20060521134315.1010">class CMainWindow(CMenuBar, CToolBar, CStatusBar, CJobs):
	@others
</t>
<t tx="ekr.20060521134315.1011">def __init__(self):
    CMenuBar.__init__(self)
    CToolBar.__init__(self)
    CStatusBar.__init__(self)
    CJobs.__init__(self)
</t>
<t tx="ekr.20060521134315.1012">class CWinpdbWindow(wx.Frame, CMainWindow):
	@others
</t>
<t tx="ekr.20060521134315.1013">def __init__(self, session_manager, fchdir, command_line, fAttach, settings):
    CMainWindow.__init__(self)

    wx.Frame.__init__(self, None, -1, WINPDB_TITLE, size = settings[WINPDB_SIZE],
                      style = wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE)

    self.Maximize(settings[WINPDB_MAXIMIZE])
    
    self.m_session_manager = session_manager
    self.m_source_manager = CSourceManager(self, session_manager)

    self.m_fchdir = fchdir
    self.m_command_line = command_line
    self.m_fAttach = fAttach
    self.m_settings = settings

    self.m_last_launch = ""

    self.m_stack = None
    
    self.m_state = rpdb2.STATE_DETACHED
            
    self.SetMinSize(WINPDB_SIZE_MIN)
    self.Centre(wx.BOTH)

    self.init_jobs()
    
    menu_resource = { 
        "/0/" + ML_FILE +   "/0/" + ML_PWD: {COMMAND: self.do_password, TOOLTIP: PWD_TIP}, 
        "/0/" + ML_FILE +   "/1/" + ML_LAUNCH: {COMMAND: self.do_launch, TOOLTIP: LAUNCH_TIP}, 
        "/0/" + ML_FILE +   "/2/" + ML_ATTACH: {COMMAND: self.do_attach, TOOLTIP: ATTACH_TIP}, 
        "/0/" + ML_FILE +   "/3/" + ML_OPEN: {COMMAND: self.do_open, TOOLTIP: OPEN_TIP}, 
        "/0/" + ML_FILE +   "/4/" + ML_DETACH: {COMMAND: self.do_detach, TOOLTIP: DETACH_TIP}, 
        "/0/" + ML_FILE +   "/5/" + ML_STOP: {COMMAND: self.do_stop, TOOLTIP: STOP_TIP}, 
        "/0/" + ML_FILE +   "/6/" + ML_SEPARATOR: None, 
        "/0/" + ML_FILE +   "/7/" + ML_EXIT: {COMMAND: self.do_exit}, 
        "/1/" + ML_BREAKPOINTS + "/0/" + ML_TOGGLE: {COMMAND: self.toggle_breakpoint, TOOLTIP: TOGGLE_TIP}, 
        "/1/" + ML_BREAKPOINTS + "/1/" + ML_DISABLE: {COMMAND: self.do_disable, TOOLTIP: DISABLE_TIP}, 
        "/1/" + ML_BREAKPOINTS + "/2/" + ML_ENABLE: {COMMAND: self.do_enable, TOOLTIP: ENABLE_TIP}, 
        "/1/" + ML_BREAKPOINTS + "/3/" + ML_CLEAR: {COMMAND: self.do_clear, TOOLTIP: CLEAR_TIP}, 
        "/1/" + ML_BREAKPOINTS + "/4/" + ML_LOAD: {COMMAND: self.do_load, TOOLTIP: LOAD_TIP}, 
        "/1/" + ML_BREAKPOINTS + "/5/" + ML_SAVE: {COMMAND: self.do_save, TOOLTIP: SAVE_TIP}, 
        "/2/" + ML_CONTROL + "/0/" + ML_BREAK: {COMMAND: self.do_break}, 
        "/2/" + ML_CONTROL + "/1/" + ML_GO: {COMMAND: self.do_go}, 
        "/2/" + ML_CONTROL + "/2/" + ML_NEXT: {COMMAND: self.do_next}, 
        "/2/" + ML_CONTROL + "/3/" + ML_STEP: {COMMAND: self.do_step}, 
        "/2/" + ML_CONTROL + "/4/" + ML_GOTO: {COMMAND: self.do_goto}, 
        "/2/" + ML_CONTROL + "/5/" + ML_RETURN: {COMMAND: self.do_return}, 
        "/3/" + ML_WINDOW + "/0/" + ML_EMPTY: None,
        "/4/" + ML_HELP +   "/0/" + ML_WEBSITE: {COMMAND: self.do_website, TOOLTIP: WEBSITE_TIP}, 
        "/4/" + ML_HELP +   "/1/" + ML_SUPPORT: {COMMAND: self.do_support, TOOLTIP: SUPPORT_TIP}, 
        "/4/" + ML_HELP +   "/2/" + ML_DOCS: {COMMAND: self.do_docs, TOOLTIP: DOCS_TIP}, 
        "/4/" + ML_HELP +   "/3/" + ML_UPDATES: {COMMAND: self.do_updates, TOOLTIP: UPDATES_TIP}, 
        "/4/" + ML_HELP +   "/4/" + ML_ABOUT: {COMMAND: self.do_about}, 
        "/4/" + ML_HELP +   "/5/" + ML_LICENSE: {COMMAND: self.do_license}
    }
    
    self.init_menubar(menu_resource)
    
    toolbar_resource = [
        {LABEL: TB_GO,      DATA: BASE64_GO,    COMMAND: self.do_go},
        {LABEL: TB_BREAK,   DATA: BASE64_BREAK, COMMAND: self.do_break},
        {LABEL: ML_SEPARATOR},
        {LABEL: TB_STEP,    DATA: BASE64_STEP,  COMMAND: self.do_step},
        {LABEL: TB_NEXT,    DATA: BASE64_NEXT,  COMMAND: self.do_next},
        {LABEL: TB_RETURN,  DATA: BASE64_RETURN, COMMAND: self.do_return},
        {LABEL: TB_GOTO,    DATA: BASE64_GOTO,  COMMAND: self.do_goto},
        {LABEL: ML_SEPARATOR},
        {LABEL: TB_TOGGLE_BP, DATA: BASE64_TOGGLE_BP,  COMMAND: self.toggle_breakpoint},
        {LABEL: ML_SEPARATOR},
        {LABEL: TB_FILTER,  DATA: BASE64_FILTER, DATA2: BASE64_FILTER, COMMAND: self.do_filter},
        {LABEL: TB_EXCEPTION, DATA: BASE64_EXCEPTION, DATA2: BASE64_EXCEPTION, COMMAND: self.do_analyze}
    ]

    self.init_toolbar(toolbar_resource)

    statusbar_resource = [
        {WIDTH: -2},
        {WIDTH: -1, FORMAT: SB_STATE + ": %(" + SB_STATE + ")s", KEYS: [SB_STATE]},
        {WIDTH: -1, FORMAT: SB_LINE + ": %(" + SB_LINE + ")d " + SB_COL + ": %(" + SB_COL + ")d", KEYS: [SB_LINE, SB_COL]},
        {WIDTH: 50, FORMAT: BITMAP, KEYS: [SB_ENCRYPTION]}
    ]

    self.init_statusbar(statusbar_resource)

    self.m_splitterv = wx.SplitterWindow(self, -1, style = wx.SP_LIVE_UPDATE | wx.SP_3D)
    self.m_splitterv.SetMinimumPaneSize(100)
    self.m_splitterv.SetSashGravity(0.5)
    
    self.m_splitterh1 = wx.SplitterWindow(self.m_splitterv, -1, style = wx.SP_LIVE_UPDATE | wx.SP_3D)
    self.m_splitterh1.SetMinimumPaneSize(100)
    self.m_splitterh1.SetSashGravity(0.67)

    self.m_splitterh2 = wx.SplitterWindow(self.m_splitterh1, -1, style = wx.SP_LIVE_UPDATE | wx.SP_3D)
    self.m_splitterh2.SetMinimumPaneSize(100)
    self.m_splitterh2.SetSashGravity(0.5)
    
    self.m_namespave_viewer = CNamespaceViewer(self.m_splitterh2, style = wx.STATIC_BORDER, session_manager = self.m_session_manager)

    self.m_threads_viewer = CThreadsViewer(self.m_splitterh2, style = wx.STATIC_BORDER, select_command = self.OnThreadSelected)

    self.m_stack_viewer = CStackViewer(self.m_splitterh1, style = wx.STATIC_BORDER, select_command = self.OnFrameSelected)

    self.m_splitterh3 = wx.SplitterWindow(self.m_splitterv, -1, style = wx.SP_LIVE_UPDATE | wx.SP_3D)
    self.m_splitterh3.SetMinimumPaneSize(100)
    self.m_splitterh3.SetSashGravity(1.0)
    
    self.m_code_viewer = CCodeViewer(self.m_splitterh3, style = wx.STATIC_BORDER | wx.TAB_TRAVERSAL, session_manager = self.m_session_manager, source_manager = self.m_source_manager, notify_filename = self.do_notify_filename)
    
    self.m_console = CConsole(self.m_splitterh3, style = wx.STATIC_BORDER | wx.TAB_TRAVERSAL)
    self.job_post(self.m_console.start, (self, self.m_session_manager, self.m_fchdir, self.m_command_line, self.m_fAttach))
    
    self.m_splitterh2.SplitHorizontally(self.m_namespave_viewer, self.m_threads_viewer)
    self.m_splitterh1.SplitHorizontally(self.m_splitterh2, self.m_stack_viewer)
    self.m_splitterv.SplitVertically(self.m_splitterh1, self.m_splitterh3)
    self.m_splitterh3.SplitHorizontally(self.m_code_viewer, self.m_console)
    
    self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)

    state = self.m_session_manager.get_state()
    self.update_state(rpdb2.CEventState(state))

    event_type_dict = {rpdb2.CEventState: {}}
    self.m_session_manager.register_callback(self.update_state, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventStackFrameChange: {}}
    self.m_session_manager.register_callback(self.update_frame, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventThreads: {}}
    self.m_session_manager.register_callback(self.update_threads, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventNoThreads: {}}
    self.m_session_manager.register_callback(self.update_no_threads, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventNamespace: {}}
    self.m_session_manager.register_callback(self.update_namespace, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventThreadBroken: {}}
    self.m_session_manager.register_callback(self.update_thread_broken, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventStack: {}}
    self.m_session_manager.register_callback(self.update_stack, event_type_dict, fSingleUse = False)

    event_type_dict = {rpdb2.CEventBreakpoint: {}}
    self.m_session_manager.register_callback(self.update_bp, event_type_dict, fSingleUse = False)

    wx.CallAfter(self.__set_sash_positions)
</t>
<t tx="ekr.20060521134315.1014">#
#--------------------------------------------------
#

def __set_sash_positions(self):
    self.m_splitterh2.SetSashPosition(self.m_settings[SPLITTER_1_POS])
    self.m_splitterh1.SetSashPosition(self.m_settings[SPLITTER_2_POS])
    self.m_splitterv.SetSashPosition(self.m_settings[SPLITTER_3_POS])
    self.m_splitterh3.SetSashPosition(self.m_settings[SPLITTER_4_POS])
</t>
<t tx="ekr.20060521134315.1015">#
#----------------- Thread list logic --------------
#

def OnThreadSelected(self, tid):
    self.job_post(self.job_thread_select, (tid, ))        
</t>
<t tx="ekr.20060521134315.1016">def job_thread_select(self, tid):   
    try:
        self.m_session_manager.set_thread(tid)
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1017">def update_threads(self, event):
    wx.CallAfter(self.m_threads_viewer.update_threads_list, event.m_current_thread, event.m_thread_list)
</t>
<t tx="ekr.20060521134315.1018">def update_no_threads(self, event):
    wx.CallAfter(self.clear_all)
</t>
<t tx="ekr.20060521134315.1019">def clear_all(self):
    self.m_code_viewer._clear()
    self.m_namespave_viewer._clear()
    self.m_stack_viewer._clear()
    self.m_threads_viewer._clear()
</t>
<t tx="ekr.20060521134315.1020">def update_thread_broken(self, event):
    wx.CallAfter(self.m_threads_viewer.update_thread, event.m_tid, True)
</t>
<t tx="ekr.20060521134315.1021">#
#----------------------------------------------------
#

def update_bp(self, event):
    wx.CallAfter(self.m_code_viewer.update_bp, event)
</t>
<t tx="ekr.20060521134315.1022">def toggle_breakpoint(self, event):
    self.m_code_viewer.toggle_breakpoint()
</t>
<t tx="ekr.20060521134315.1023">#
#------------------- Frame Select Logic -------------
#

def OnFrameSelected(self, event):    
    self.job_post(self.job_frame_select, (event.m_itemIndex, ))
</t>
<t tx="ekr.20060521134315.1024">def job_frame_select(self, index):
    try:
        self.m_session_manager.set_frame_index(index)
    except (socket.error, rpdb2.CConnectionException, rpdb2.DebuggerNotBroken):
        pass
</t>
<t tx="ekr.20060521134315.1025">def update_frame(self, event):
    wx.CallAfter(self.do_update_frame, event.m_frame_index)
</t>
<t tx="ekr.20060521134315.1026">def do_update_frame(self, index):
    self.do_set_position(index)
    self.m_stack_viewer.select_frame(index)
</t>
<t tx="ekr.20060521134315.1027">#
#----------------------------------------------------------
#

def update_stack(self, event):
    self.m_stack = event.m_stack
    wx.CallAfter(self.do_update_stack, event.m_stack)
</t>
<t tx="ekr.20060521134315.1028">def do_update_stack(self, _stack):
    self.m_stack = _stack

    self.do_set_position(0)
    self.m_stack_viewer.update_stack_list(self.m_stack)
</t>
<t tx="ekr.20060521134315.1029">def do_set_position(self, index):
    s = self.m_stack[rpdb2.DICT_KEY_STACK]
    e = s[-(1 + index)]
    
    filename = e[0]
    lineno = e[1]

    fBroken = self.m_stack[rpdb2.DICT_KEY_BROKEN]
    _event = self.m_stack[rpdb2.DICT_KEY_EVENT]
    __event = ['running', ['call', _event][index == 0]][fBroken]

    self.m_code_viewer.set_position(filename, lineno, __event)
</t>
<t tx="ekr.20060521134315.1030">#
#----------------------------------------------------
#

def do_analyze(self, event):
    f = event.IsChecked()

    try:
        self.m_session_manager.set_analyze(f)
    except (socket.error, rpdb2.CConnectionException):
        pass    
</t>
<t tx="ekr.20060521134315.1031">def update_namespace(self, event):
    wx.CallAfter(self.m_namespave_viewer.update_namespace, self.m_stack)
</t>
<t tx="ekr.20060521134315.1032">def do_filter(self, event):
    f = event.IsChecked()
    self.m_namespave_viewer.set_filter(f)
    self.m_namespave_viewer.update_namespace(self.m_stack)
</t>
<t tx="ekr.20060521134315.1033">def do_notify_filename(self, filename, command):
    if command != None:
        self.add_menu_item(ML_WINDOW, filename, command)
        
    self.m_console.set_filename(filename)
</t>
<t tx="ekr.20060521134315.1034">def OnCloseWindow(self, event):
    self.m_settings[WINPDB_SIZE] = self.GetSize()
    self.m_settings[WINPDB_MAXIMIZE] = self.IsMaximized()
    self.m_settings[SPLITTER_1_POS] = self.m_splitterh2.GetSashPosition()
    self.m_settings[SPLITTER_2_POS] = self.m_splitterh1.GetSashPosition()
    self.m_settings[SPLITTER_3_POS] = self.m_splitterv.GetSashPosition()
    self.m_settings[SPLITTER_4_POS] = self.m_splitterh3.GetSashPosition()

    #print self.m_settings[SPLITTER_1_POS], self.m_settings[SPLITTER_2_POS], self.m_settings[SPLITTER_3_POS], self.m_settings[SPLITTER_4_POS] 
    
    self.m_console.stop()
    self.shutdown_jobs()
    self.Destroy()
</t>
<t tx="ekr.20060521134315.1035">def set_cursor(self, id):
    cursor = wx.StockCursor(id)
    self.SetCursor(cursor)        
    self.m_code_viewer.set_cursor(id)        
    self.m_threads_viewer.set_cursor(id)        
    self.m_stack_viewer.set_cursor(id)        
</t>
<t tx="ekr.20060521134315.1036">def do_none(self, event):
    pass
</t>
<t tx="ekr.20060521134315.1037">def update_state(self, event):
    wx.CallAfter(self.callback_state, event)
</t>
<t tx="ekr.20060521134315.1038">def callback_state(self, event):
    old_state = self.m_state
    self.m_state = event.m_state

    (menu_update_dict, toolbar_update_dict) = STATE_MAP[self.m_state]
    self.set_menu_items_state(menu_update_dict)
    self.set_toolbar_items_state(toolbar_update_dict)
    self.set_statusbar_data({SB_STATE: self.m_state.upper()}) 

    if self.m_state == rpdb2.STATE_DETACHED:
        self.set_statusbar_data({SB_ENCRYPTION: (None, None)})
        self.clear_menu_items(ML_WINDOW)
        self.m_source_manager._clear()
        self.m_code_viewer._clear()
        self.m_namespave_viewer._clear()
        self.m_stack_viewer._clear()
        self.m_threads_viewer._clear()
        self.m_console.set_focus()
        
    elif (old_state in [rpdb2.STATE_DETACHED, rpdb2.STATE_DETACHING, rpdb2.STATE_SPAWNING, rpdb2.STATE_ATTACHING]) and (self.m_state not in [rpdb2.STATE_DETACHED, rpdb2.STATE_DETACHING, rpdb2.STATE_SPAWNING, rpdb2.STATE_ATTACHING]):
        f = self.m_session_manager.get_encryption()
        data = [BASE64_UNLOCKED, BASE64_LOCKED][f] 
        tooltip = [TOOLTIP_UNLOCKED, TOOLTIP_LOCKED][f]
        self.set_statusbar_data({SB_ENCRYPTION: (data, tooltip)})

    if self.m_state == rpdb2.STATE_BROKEN:
        self.set_toggle(TB_EXCEPTION, False)
        
        #self.m_code_viewer._enable()
        self.m_namespave_viewer._enable()
        self.m_stack_viewer._enable()
        self.m_threads_viewer._enable()
        
    elif self.m_state == rpdb2.STATE_ANALYZE:
        self.set_toggle(TB_EXCEPTION, True)
        
        #self.m_code_viewer._enable()
        self.m_namespave_viewer._enable()
        self.m_stack_viewer._enable()
        self.m_threads_viewer._disable()
        self.m_console.set_focus()
        
    else:
        #self.m_code_viewer._disable()
        self.m_namespave_viewer._disable()
        self.m_stack_viewer._disable()
        self.m_threads_viewer._disable()
        self.m_console.set_focus()
</t>
<t tx="ekr.20060521134315.1039">def do_website(self, event):
    self.job_post(webbrowser.open_new, (WEBSITE_URL, ))
</t>
<t tx="ekr.20060521134315.1040">def do_support(self, event):
    self.job_post(webbrowser.open_new, (SUPPORT_URL, ))
</t>
<t tx="ekr.20060521134315.1041">def do_docs(self, event):
    self.job_post(webbrowser.open_new, (DOCS_URL, ))
</t>
<t tx="ekr.20060521134315.1042">def do_updates(self, event):
    self.job_post(webbrowser.open_new, (UPDATES_URL, ))
</t>
<t tx="ekr.20060521134315.1043">def do_license(self, event):
    about = CHTMLDialog(self, LICENSE_TITLE, LICENSE_NOTICE + COPY_OF_THE_GPL_LICENSE)
    about.ShowModal()
    about.Destroy()
</t>
<t tx="ekr.20060521134315.1044">def do_about(self, event):
    about = CHTMLDialog(self, ABOUT_TITLE, ABOUT_NOTICE)
    about.ShowModal()
    about.Destroy()
</t>
<t tx="ekr.20060521134315.1045">def do_password(self, event):
    pwd = self.m_session_manager.get_password()
    pwd_dialog = CPwdDialog(self, pwd)
    r = pwd_dialog.ShowModal()
    if r == wx.ID_OK:
        pwd = pwd_dialog.get_password()
        self.job_post(self.job_pwd, (pwd, ))
        
    pwd_dialog.Destroy()
</t>
<t tx="ekr.20060521134315.1046">def job_pwd(self, pwd):
    try:
        self.m_session_manager.set_password(pwd)
        return
        
    except rpdb2.AlreadyAttached:
        pass
</t>
<t tx="ekr.20060521134315.1047">def do_launch(self, event):
    launch_dialog = CLaunchDialog(self, self.m_last_launch)
    r = launch_dialog.ShowModal()
    if r == wx.ID_OK:
        (command_line, fchdir) = launch_dialog.get_command_line()
        self.m_last_launch = command_line
        self.job_post(self.job_launch, (fchdir, command_line, ))
        
    launch_dialog.Destroy()
</t>
<t tx="ekr.20060521134315.1048">def job_launch(self, fchdir, path):
    try:
        self.m_session_manager.launch(fchdir, path)
        return
        
    except (socket.error, rpdb2.CConnectionException):
        pass
    except rpdb2.BadArgument:
        pass
    except IOError:
        pass
</t>
<t tx="ekr.20060521134315.1049">def do_open(self, event):
    host = self.m_session_manager.get_host()
    fLocal = (host == rpdb2.LOCAL_HOST)
    open_dialog = COpenDialog(self, fLocal = False)
    r = open_dialog.ShowModal()
    if r == wx.ID_OK:
        file_name = open_dialog.get_file_name()
        self.m_code_viewer.set_file(file_name, fComplain = True)
        
    open_dialog.Destroy()
</t>
<t tx="ekr.20060521134315.1050">def do_attach(self, event):
    attach_dialog = CAttachDialog(self, self.m_session_manager)
    r = attach_dialog.ShowModal()
    if r == wx.ID_OK:
        server = attach_dialog.get_server()
        self.job_post(self.job_attach, (server, ))

    attach_dialog.Destroy()
</t>
<t tx="ekr.20060521134315.1051">def job_attach(self, server):    
    try:
        self.m_session_manager.attach(server.m_rid, server.m_filename)
        return
        
    except (socket.error, rpdb2.CConnectionException):
        pass
    except rpdb2.BadArgument:
        pass
</t>
<t tx="ekr.20060521134315.1052">def do_detach(self, event):
    self.job_post(self.job_detach, ())
</t>
<t tx="ekr.20060521134315.1053">def job_detach(self):    
    try:
        self.m_session_manager.save_breakpoints()
        self.m_session_manager.detach()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1054">def do_stop(self, event):
    self.job_post(self.job_stop, ())
</t>
<t tx="ekr.20060521134315.1055">def job_stop(self):    
    try:
        self.m_session_manager.save_breakpoints()
        self.m_session_manager.stop_debuggee()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1056">def do_disable(self, event):
    try:
        self.m_session_manager.disable_breakpoint([], fAll = True)
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1057">def do_enable(self, event):
    try:
        self.m_session_manager.enable_breakpoint([], fAll = True)
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1058">def do_clear(self, event):
    try:
        self.m_session_manager.delete_breakpoint([], fAll = True)
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1059">def do_load(self, event):
    try:
        self.m_session_manager.load_breakpoints()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1060">def do_save(self, event):
    try:
        self.m_session_manager.save_breakpoints()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1061">def do_go(self, event):
    try:
        self.m_session_manager.request_go()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1062">def do_break(self, event):
    try:
        self.m_session_manager.request_break()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1063">def do_step(self, event):
    try:
        self.m_session_manager.request_step()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1064">def do_next(self, event):
    try:
        self.m_session_manager.request_next()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1065">def do_return(self, event):
    try:
        self.m_session_manager.request_return()
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1066">def do_goto(self, event):
    (filename, lineno) = self.m_code_viewer.get_file_lineno()
    try:
        self.m_session_manager.request_go_breakpoint(filename, '', lineno)
    except (socket.error, rpdb2.CConnectionException):
        pass
</t>
<t tx="ekr.20060521134315.1067">def do_exit(self, event = None):
    self.Close()
</t>
<t tx="ekr.20060521134315.1068"></t>
<t tx="ekr.20060521134315.1069">class CListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
	@others
</t>
<t tx="ekr.20060521134315.1070">def __init__(self, *args, **kwargs):
    wx.ListCtrl.__init__(self, *args, **kwargs)
    listmix.ListCtrlAutoWidthMixin.__init__(self)
</t>
<t tx="ekr.20060521134315.1071">def set_columns_width(self):
    n = self.GetColumnCount()

    for i in range(0, n - 1):
        self.SetColumnWidth(i, wx.LIST_AUTOSIZE_USEHEADER)               

    if wx.Platform != '__WXMSW__':
        a = [self.GetColumnWidth(i) for i in range(0, n - 1)]
        
        for i in range(0, n - 1):
            self.SetColumnWidth(i, wx.LIST_AUTOSIZE)               

        b = [self.GetColumnWidth(i) for i in range(0, n - 1)]

        c = [max(i) for i in zip(a, b)]
        
        for i in range(0, n - 1):
            self.SetColumnWidth(i, c[i])
        
    self.resizeLastColumn(50)
</t>
<t tx="ekr.20060521134315.1072">class CStyledViewer(stc.StyledTextCtrl):
	@others
</t>
<t tx="ekr.20060521134315.1073">def __init__(self, *args, **kwargs):
    self.m_margin_command = kwargs.pop('margin_command', None)

    stc.StyledTextCtrl.__init__(self, *args, **kwargs)
    
    self.SetLexer(stc.STC_LEX_PYTHON)
    self.SetKeyWords(0, " ".join(keyword.kwlist))

    self.SetReadOnly(True)

    self.SetVisiblePolicy(wx.stc.STC_VISIBLE_SLOP, 7)
    self.SetViewWhiteSpace(False)
    self.SetIndentationGuides(True)
    self.SetEOLMode(stc.STC_EOL_LF)
    self.SetViewEOL(False)
    self.SetProperty("fold", "0")
    
    self.SetMarginType(0, stc.STC_MARGIN_NUMBER)
    self.SetMarginMask(0, 0x0)
    self.SetMarginWidth(0, 40)

    self.SetMarginType(1, stc.STC_MARGIN_SYMBOL)
    self.SetMarginMask(1, 0x1F)
    self.SetMarginWidth(1, 16)
    self.SetMarginSensitive(1, True)

    if self.m_margin_command != None:
        self.Bind(stc.EVT_STC_MARGINCLICK, self.m_margin_command)

    self.Bind(wx.EVT_KEY_DOWN, self.OnKeyPressed)
    self.Bind(wx.EVT_KEY_UP, self.OnKeyReleased)

    if wx.Platform == '__WXMSW__':
        self.StyleSetSpec(stc.STC_STYLE_DEFAULT, 'fore:#000000,back:#FFFFFF,face:Courier New,size:9')
    else:
        self.StyleSetSpec(stc.STC_STYLE_DEFAULT, 'fore:#000000,back:#FFFFFF,face:Courier')

    self.StyleClearAll()
    
    self.StyleSetSpec(stc.STC_STYLE_LINENUMBER, 'fore:#000000,back:#99A9C2')    
    self.StyleSetSpec(stc.STC_STYLE_BRACELIGHT, 'fore:#00009D,back:#FFFF00')
    self.StyleSetSpec(stc.STC_STYLE_BRACEBAD, 'fore:#00009D,back:#FF0000')
    self.StyleSetSpec(stc.STC_STYLE_INDENTGUIDE, "fore:#CDCDCD")
    self.StyleSetSpec(stc.STC_P_DEFAULT, 'fore:#000000')
    self.StyleSetSpec(stc.STC_P_COMMENTLINE, 'fore:#008000,back:#F0FFF0')
    self.StyleSetSpec(stc.STC_P_COMMENTBLOCK, 'fore:#008000,back:#F0FFF0')
    self.StyleSetSpec(stc.STC_P_NUMBER, 'fore:#008050')
    self.StyleSetSpec(stc.STC_P_STRING, 'fore:#800080')
    self.StyleSetSpec(stc.STC_P_CHARACTER, 'fore:#800080')
    self.StyleSetSpec(stc.STC_P_WORD, 'fore:#000080,bold')
    self.StyleSetSpec(stc.STC_P_TRIPLE, 'fore:#800080,back:#FFFFEA')
    self.StyleSetSpec(stc.STC_P_TRIPLEDOUBLE, 'fore:#800080,back:#FFFFEA')
    self.StyleSetSpec(stc.STC_P_CLASSNAME, 'fore:#0000FF,bold')
    self.StyleSetSpec(stc.STC_P_DEFNAME, 'fore:#008050,bold')
    self.StyleSetSpec(stc.STC_P_OPERATOR, 'fore:#800000,bold')
    self.StyleSetSpec(stc.STC_P_IDENTIFIER, 'fore:#000000')

    self.SetSelBackground(True, wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHT))
    self.SetSelForeground(True, wx.SystemSettings_GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT))

    self.MarkerDefine(MARKER_BREAKPOINT_ENABLED, stc.STC_MARKER_MAX, wx.BLACK, (255, 0, 0))
    self.MarkerDefine(MARKER_BREAKPOINT_DISABLED, stc.STC_MARKER_MAX, wx.BLACK, (255, 255, 128))
    self.MarkerDefine(MARKER_CURRENT_LINE, stc.STC_MARKER_MAX, wx.WHITE, (150, 150, 255))
    self.MarkerDefine(MARKER_CURRENT_LINE_HIT, stc.STC_MARKER_MAX, wx.BLACK, (215, 215, 255))

    self.MarkerDefine(MARKER_CALL, stc.STC_MARK_CHARACTER + ord('C'), wx.WHITE, "#99A9C2")
    self.MarkerDefine(MARKER_LINE, stc.STC_MARK_CHARACTER + ord('L'), wx.WHITE, "#99A9C2")
    self.MarkerDefine(MARKER_RETURN, stc.STC_MARK_CHARACTER + ord('R'), wx.WHITE, "#99A9C2")
    self.MarkerDefine(MARKER_EXCEPTION, stc.STC_MARK_CHARACTER + ord('E'), wx.WHITE, "#99A9C2")
    self.MarkerDefine(MARKER_RUNNING, stc.STC_MARK_CHARACTER + ord('*'), wx.WHITE, "#99A9C2")
</t>
<t tx="ekr.20060521134315.1074">def _clear(self):
    self.SetReadOnly(False)
    self.ClearAll()
    self.SetReadOnly(True)
</t>
<t tx="ekr.20060521134315.1075">def load_source(self, value):
    self.SetReadOnly(False)
    self.ClearAll()
    self.SetText(value)
    self.SetReadOnly(True)
    self.GotoLine(0)
    self.EmptyUndoBuffer()
    self.SetSavePoint()
</t>
<t tx="ekr.20060521134315.1076">def OnKeyReleased(self, event):
    key_code = event.KeyCode()

    if key_code == wx.WXK_CONTROL:
        self.GetParent().GetEventHandler().ProcessEvent(event)

    event.Skip()
</t>
<t tx="ekr.20060521134315.1077">def OnKeyPressed(self, event):
    key_code = event.KeyCode()

    if key_code == wx.WXK_TAB:
        forward = not event.ShiftDown()
        switch = event.ControlDown()
        if switch:
            self.GetParent().GetEventHandler().ProcessEvent(event)
            return
        
        ne = wx.NavigationKeyEvent()
        ne.SetDirection(forward)
        ne.SetCurrentFocus(self)
        ne.SetEventObject(self)
        self.GetParent().GetEventHandler().ProcessEvent(ne)
        event.Skip()
        return
        
    event.Skip()
</t>
<t tx="ekr.20060521134315.1078">class CSourceManager:
	@others
</t>
<t tx="ekr.20060521134315.1079">def __init__(self, job_manager, session_manager):
    self.m_job_manager = job_manager
    self.m_session_manager = session_manager
    self.m_files = {}

    self.m_lock = threading.RLock()
</t>
<t tx="ekr.20060521134315.1080">def _clear(self):

    self.m_files = {}
</t>
<t tx="ekr.20060521134315.1081">def get_source(self, filename):
    for k, v in self.m_files.items():
        if not filename in k:
            continue

        if v[0] == 0:        
            return (k, v[1])

        t = time.time()
        if t - v[0] &lt; BAD_FILE_WARNING_TIMEOUT_SEC:
            return (k, v[1])    

        del self.m_files[k]
        raise KeyError

    raise KeyError
</t>
<t tx="ekr.20060521134315.1082">def load_source(self, filename, callback, args, fComplain):
    
    self.m_job_manager.job_post(self.job_load_source, (filename, callback, args, fComplain))

</t>
<t tx="ekr.20060521134315.1083">def job_load_source(self, filename, callback, args, fComplain):
    try:
        r = self.m_session_manager.get_source_file(filename, -1, -1)
        _filename = r[rpdb2.DICT_KEY_FILENAME]
        source_lines = r[rpdb2.DICT_KEY_LINES]
        _source = string.join(source_lines, '')

        de = wx.GetDefaultPyEncoding()
        se = rpdb2.ParseEncoding(_source)
        if se == None:
            se = de
            
        u = _source.decode(se, 'ignore')
        source = u.encode(de, 'ignore')
        t = 0

    except (IOError, socket.error, rpdb2.CConnectionException):
        if fComplain:
            wx.CallAfter(self.load_error, filename)
            return

        _filename = filename
        source = STR_FILE_LOAD_ERROR2 % (filename, )
        t = time.time()
    
    try:    
        self.m_lock.acquire()

        fNotify = not (_filename in self.m_files)
        self.m_files[_filename] = (t, source)

    finally:
        self.m_lock.release()

    _args = (_filename, ) + args + (fNotify, )

    wx.CallAfter(callback, *_args)
</t>
<t tx="ekr.20060521134315.1084">def load_error(self, filename):
    dlg = wx.MessageDialog(None, STR_FILE_LOAD_ERROR % (filename, ), MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
    dlg.ShowModal()
    dlg.Destroy()
</t>
<t tx="ekr.20060521134315.1085">class CCaption(wx.Panel):
	@others
</t>
<t tx="ekr.20060521134315.1086">def __init__(self, *args, **kwargs):
    label = kwargs.pop("label", "")
    
    wx.Panel.__init__(self, *args, **kwargs)

    self.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_INACTIVECAPTION))
    self.SetForegroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_CAPTIONTEXT))
    
    sizerv = wx.BoxSizer(wx.VERTICAL)

    self.m_static_text = wx.StaticText(self, -1, label)
    sizerv.Add(self.m_static_text, 0, wx.EXPAND | wx.ALL, 2)

    font = self.m_static_text.GetFont()
    new_font = wx.Font(pointSize = font.GetPointSize(), family = font.GetFamily(), style = font.GetStyle(), weight = wx.BOLD, face = font.GetFaceName())
    self.m_static_text.SetFont(new_font)

    self.SetSizer(sizerv)
    sizerv.Fit(self)
</t>
<t tx="ekr.20060521134315.1087">class CCaptionManager:
	@others
</t>
<t tx="ekr.20060521134315.1088">def bind_caption(self, widget):
    widget.Bind(wx.EVT_SET_FOCUS, self.OnGainFocus)
    widget.Bind(wx.EVT_KILL_FOCUS, self.OnLoseFocus)

    self.m_n_focus = 0
</t>
<t tx="ekr.20060521134315.1089">def OnGainFocus(self, event):        
    self.m_n_focus += 1
    
    self.m_caption.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_ACTIVECAPTION))
    self.m_caption.Refresh()
    event.Skip()
</t>
<t tx="ekr.20060521134315.1090">def OnLoseFocus(self, event):
    self.m_n_focus -= 1
    if self.m_n_focus &gt; 0:
        return
        
    self.m_caption.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_INACTIVECAPTION))
    self.m_caption.Refresh()
    event.Skip()
</t>
<t tx="ekr.20060521134315.1091">class CNamespacePanel(wx.Panel, CJobs):
	@others
</t>
<t tx="ekr.20060521134315.1092">def __init__(self, *args, **kwargs):
    wx.Panel.__init__(self, *args, **kwargs)
    CJobs.__init__(self)
    
    self.init_jobs()

    self.m_lock = threading.RLock()
    self.m_jobs = []
    self.m_n_workers = 0
    
    self.m_fFilter = False
    self.m_key = None

    self.m_tree = wx.gizmos.TreeListCtrl(self, -1, style = wx.TR_HIDE_ROOT | wx.TR_DEFAULT_STYLE | wx.TR_FULL_ROW_HIGHLIGHT)

    self.m_tree.AddColumn(TLC_HEADER_NAME)
    self.m_tree.AddColumn(TLC_HEADER_TYPE)
    self.m_tree.AddColumn(TLC_HEADER_REPR)
    self.m_tree.SetColumnWidth(2, 800)
    self.m_tree.SetMainColumn(0) 
    
    self.Bind(wx.EVT_SIZE, self.OnSize)
    self.m_tree.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.OnItemExpanding)
    self.m_tree.Bind(wx.EVT_TREE_ITEM_COLLAPSING, self.OnItemCollapsing)
    self.m_tree.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.OnItemActivated)

    if wx.Platform == '__WXMSW__':
        self.m_tree.Bind(wx.EVT_TREE_ITEM_GETTOOLTIP, self.OnItemToolTip)

    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroyWindow)
</t>
<t tx="ekr.20060521134315.1093">def OnDestroyWindow(self, event):
    self.shutdown_jobs()
</t>
<t tx="ekr.20060521134315.1094">def _clear(self):
    self.m_tree.DeleteAllItems()
</t>
<t tx="ekr.20060521134315.1095">def set_filter(self, fFilter):
    self.m_fFilter = fFilter
</t>
<t tx="ekr.20060521134315.1096">def bind_caption(self, caption_manager):
    w = self.m_tree.GetMainWindow()
    caption_manager.bind_caption(w)
</t>
<t tx="ekr.20060521134315.1097">def OnItemActivated(self, event):
    item = event.GetItem()

    expr_dialog = CExpressionDialog(self)
    pos = self.GetPositionTuple()
    expr_dialog.SetPosition((pos[0] + 50, pos[1] + 50))
    r = expr_dialog.ShowModal()
    if r != wx.ID_OK:
        expr_dialog.Destroy()
        return

    expr = expr_dialog.get_expression()
    expr_dialog.Destroy()

    try:
        _expr = self.m_tree.GetPyData(item)
        _suite = "%s = %s" % (_expr, expr)
        rl = self.m_session_manager.execute(_suite)
        error = rl[1]
        if error != '':
            dlg = wx.MessageDialog(self, error, MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()
                           
    except:
        rpdb2.print_debug()

    return
</t>
<t tx="ekr.20060521134315.1098">def OnItemToolTip(self, event):
    item = event.GetItem()

    tt = self.m_tree.GetItemText(item, 2)[1:]
    event.SetToolTip(tt)
</t>
<t tx="ekr.20060521134315.1099">def OnItemCollapsing(self, event):
    item = event.GetItem()

    event.Skip()
</t>
<t tx="ekr.20060521134315.1100">def get_namespace(self, expr, _map):
    if _map != None:
        l = [e for e in _map if e.get(rpdb2.DICT_KEY_EXPR, None) == expr]
        if l == []:
            return None

        return l[0]               
        
    try:
        rl = self.m_session_manager.get_namespace([(expr, True)], self.m_fFilter)
    except:
        rpdb2.print_debug()
        return None

    if len(rl) == 0:
        return None

    _r = rl[0]
    if rpdb2.DICT_KEY_ERROR in _r:
        return None            
    
    return _r
</t>
<t tx="ekr.20060521134315.1101">def expand_item(self, item, _map = None):
    if not self.m_tree.ItemHasChildren(item):
        return
    
    if self.m_tree.IsExpanded(item):
        return

    if self.m_tree.GetChildrenCount(item) &gt; 0:
        return
        
    expr = self.m_tree.GetPyData(item)

    _r = self.get_namespace(expr, _map)
    if _r == None:
        return   

    if rpdb2.DICT_KEY_ERROR in _r:
        return
    
    if _r[rpdb2.DICT_KEY_N_SUBNODES] == 0:
        self.m_tree.SetItemHasChildren(item, False)
        return

    snl = _r[rpdb2.DICT_KEY_SUBNODES] 

    for r in snl:
        child = self.m_tree.AppendItem(item, r[rpdb2.DICT_KEY_NAME])
        self.m_tree.SetItemText(child, ' ' + r[rpdb2.DICT_KEY_REPR], 2)
        self.m_tree.SetItemText(child, ' ' + r[rpdb2.DICT_KEY_TYPE], 1)
        self.m_tree.SetItemPyData(child, r[rpdb2.DICT_KEY_EXPR])
        self.m_tree.SetItemHasChildren(child, (r[rpdb2.DICT_KEY_N_SUBNODES] &gt; 0))

    self.m_tree.Expand(item)
</t>
<t tx="ekr.20060521134315.1102">def OnItemExpanding(self, event):
    item = event.GetItem()
    self.expand_item(item)
    event.Skip()
    return
</t>
<t tx="ekr.20060521134315.1103">def get_children(self, item):
    (child, cookie) = self.m_tree.GetFirstChild(item)
    cl = []
    
    while child and child.IsOk():
        cl.append(child)
        (child, cookie) = self.m_tree.GetNextChild(item, cookie)

    return cl    
</t>
<t tx="ekr.20060521134315.1104">def get_expression_list(self):
    if self.m_tree.GetCount() == 0:
        return None

    item = self.m_tree.GetRootItem()

    s = [item]
    el = []

    while len(s) &gt; 0:
        item = s.pop(0)
        expr = self.m_tree.GetPyData(item)
        fExpand = self.m_tree.IsExpanded(item)
        if not fExpand:
            continue

        el.append((expr, True))
        items = self.get_children(item)
        s = items + s

    return el    
</t>
<t tx="ekr.20060521134315.1105">def update_namespace(self, key, el):
    old_key = self.m_key
    old_el = self.get_expression_list()

    if key == old_key:
        el = old_el

    self.m_key = key

    if el == None:
        el = [(self.get_root_expr(), True)]

    self.post(el, self.m_fFilter)

    return (old_key, old_el)
</t>
<t tx="ekr.20060521134315.1106">def post(self, el, fFilter):
    self.m_jobs.insert(0, (el, fFilter))

    if self.m_n_workers == 0:
        self.job_post(self.job_update_namespace, ())
</t>
<t tx="ekr.20060521134315.1107">def job_update_namespace(self):
    while len(self.m_jobs) &gt; 0:
        self.m_lock.acquire()
        self.m_n_workers += 1
        self.m_lock.release()
        
        try:
            del self.m_jobs[1:]
            (el, fFilter) = self.m_jobs.pop()
            rl = self.m_session_manager.get_namespace(el, fFilter)
            wx.CallAfter(self.do_update_namespace, rl)

        except (rpdb2.ThreadDone, rpdb2.NoThreads):
            wx.CallAfter(self.m_tree.DeleteAllItems)
            
        except:
            rpdb2.print_debug()

        self.m_lock.acquire()
        self.m_n_workers -= 1
        self.m_lock.release()
</t>
<t tx="ekr.20060521134315.1108">def do_update_namespace(self, rl):    
    self.m_tree.DeleteAllItems()

    root = self.m_tree.AddRoot('root')
    self.m_tree.SetItemPyData(root, self.get_root_expr())
    self.m_tree.SetItemHasChildren(root, True)

    s = [root]

    while len(s) &gt; 0:
        item = s.pop(0)
        self.expand_item(item, rl)
        
        items = self.get_children(item)
        s = items + s
</t>
<t tx="ekr.20060521134315.1109">def OnSize(self, event):
    self.m_tree.SetSize(self.GetSize())

    event.Skip()
</t>
<t tx="ekr.20060521134315.1110">class CCodeViewer(wx.Panel, CJobs, CCaptionManager):
	@others
</t>
<t tx="ekr.20060521134315.1111">def __init__(self, *args, **kwargs):
    self.m_session_manager = kwargs.pop('session_manager')
    self.m_notify_filename = kwargs.pop('notify_filename', None)
    self.m_source_manager = kwargs.pop('source_manager')
    
    wx.Panel.__init__(self, *args, **kwargs)
    CJobs.__init__(self)
    
    self.init_jobs()

    self.m_history = []
    self.m_history_index = 0

    self.m_fSwitch = False
    self.m_swiched_original = None
    
    self.m_files = {}

    self.m_cur_filename = None

    self.m_pos_filename = None
    self.m_pos_lineno = None
    self.m_pos_event = None

    self.m_breakpoint_lines = {}
    
    self.m_request_number = 0

    self.m_event2Marker = {'running': MARKER_RUNNING, 'call': MARKER_CALL, 'line': MARKER_LINE, 'return': MARKER_RETURN,  'exception': MARKER_EXCEPTION}
    
    _sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerv = wx.BoxSizer(wx.VERTICAL)
    _sizerv.Add(sizerv, 1, wx.EXPAND | wx.ALL, 3)

    self.m_caption = CCaption(self, label = CAPTION_SOURCE)
    sizerv.Add(self.m_caption, 0, wx.EXPAND | wx.ALL, 0)

    self.m_viewer = CStyledViewer(self, style = wx.TAB_TRAVERSAL, margin_command = self.on_margin_clicked)
    self.bind_caption(self.m_viewer)
    sizerv.Add(self.m_viewer, 1, wx.EXPAND | wx.ALL, 0)

    self.SetSizer(_sizerv)
    _sizerv.Fit(self)

    self.Bind(wx.EVT_KEY_DOWN, self.OnKeyPressed)
    self.Bind(wx.EVT_KEY_UP, self.OnKeyReleased)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroyWindow)
</t>
<t tx="ekr.20060521134315.1112">def OnDestroyWindow(self, event):
    self.shutdown_jobs()
</t>
<t tx="ekr.20060521134315.1113">def set_cursor(self, id):
    self.m_viewer.SetSTCCursor([stc.STC_CURSORNORMAL, stc.STC_CURSORWAIT][id == wx.CURSOR_WAIT])        
</t>
<t tx="ekr.20060521134315.1114">def on_margin_clicked(self, event):
    lineno = self.m_viewer.LineFromPosition(event.GetPosition()) + 1
    self.__toggle_breakpoint(lineno)        
    event.Skip()
</t>
<t tx="ekr.20060521134315.1115">def get_file_lineno(self):
    lineno = self.m_viewer.GetCurrentLine() + 1

    return (self.m_cur_filename, lineno)
</t>
<t tx="ekr.20060521134315.1116">def toggle_breakpoint(self):
    lineno = self.m_viewer.GetCurrentLine() + 1 
    self.__toggle_breakpoint(lineno)        
</t>
<t tx="ekr.20060521134315.1117">def __toggle_breakpoint(self, lineno):
    bpl = self.m_session_manager.get_breakpoints()
    id = self.m_breakpoint_lines.get(lineno, None)
    if id != None:
        bp = bpl.get(id, None)
        
    if (id == None) or (bp == None):
        self.job_post(self.job_set_breakpoint, (self.m_cur_filename, lineno))
        return

    self.job_post(self.job_delete_breakpoint, (id, )) 
</t>
<t tx="ekr.20060521134315.1118">def job_set_breakpoint(self, filename, lineno):
    try:
        self.m_session_manager.set_breakpoint(filename, '', lineno, True, '')
    except (socket.error, rpdb2.CConnectionException):
        pass
    except rpdb2.BadArgument:
        pass
</t>
<t tx="ekr.20060521134315.1119">def job_delete_breakpoint(self, id):
    try:
        self.m_session_manager.delete_breakpoint([id], False)
    except (socket.error, rpdb2.CConnectionException):
        pass
    except rpdb2.BadArgument:
        pass
</t>
<t tx="ekr.20060521134315.1120">def _disable(self):
    self.m_viewer.Disable()
</t>
<t tx="ekr.20060521134315.1121">def _enable(self):
    self.m_viewer.Enable()
</t>
<t tx="ekr.20060521134315.1122">def get_history(self, fBack):
    self.m_history_index = (self.m_history_index + [-1, 1][fBack]) % len(self.m_history)
    return self.m_history[self.m_history_index]
</t>
<t tx="ekr.20060521134315.1123">def set_history(self, value):
    if value in self.m_history:
        self.m_history.remove(value)
        
    self.m_history.insert(0, value)
    self.m_history = self.m_history[:50]
    
    self.m_history_index = 0
</t>
<t tx="ekr.20060521134315.1124">def OnKeyPressed(self, event):
    if len(self.m_history) &lt; 2:
        return
        
    if self.m_fSwitch == False:
        self.m_fSwitch = True
        self.m_swiched_original = self.m_cur_filename
    
    value = self.get_history(event.ShiftDown())  

    self.set_file(value, fNoHistory = True)    
</t>
<t tx="ekr.20060521134315.1125">def OnKeyReleased(self, event):
    if self.m_fSwitch == False:
        return

    if self.m_swiched_original == self.m_cur_filename:
        return
        
    self.set_history(self.m_cur_filename)
</t>
<t tx="ekr.20060521134315.1126">def _clear(self):
    self.m_history = []
    self.m_history_index = 0

    self.m_fSwitch = False
    self.m_swiched_original = None

    self.m_files = {}

    self.m_cur_filename = None

    self.m_pos_filename = None
    self.m_pos_lineno = None
    self.m_pos_event = None

    self.m_viewer._clear()        
</t>
<t tx="ekr.20060521134315.1127">def __notify_filename(self, filename, fNew):
    if self.m_notify_filename == None:
        return

    if fNew:    
        def command(event, filename = filename):
            self.set_file(filename)
    else:
        command = None

    self.m_notify_filename(filename, command)
</t>
<t tx="ekr.20060521134315.1128">def set_file(self, filename, fNoHistory = False, request_number = 0, fNotify = False, fComplain = False):
    if fNotify:
        self.__notify_filename(filename, fNew = True)

    if request_number == 0:
        self.m_request_number += 1
        request_number = self.m_request_number
    elif request_number &lt;  self.m_request_number:
        return

    if self.m_cur_filename == filename:
        return
        
    try:
        (_filename, source) = self.m_source_manager.get_source(filename)
    except KeyError:    
        self.m_source_manager.load_source(filename, self.set_file, (fNoHistory, request_number,), fComplain)
        return

    if self.m_cur_filename == _filename:
        return
        
    self.__notify_filename(filename, fNew = False)
    
    if self.m_cur_filename != None:
        self.m_files[self.m_cur_filename] = self.m_viewer.GetCurrentLine() + 1  

    lineno = self.m_files.get(_filename, 1)
    
    self.m_viewer.load_source(source)

    self.m_viewer.EnsureVisibleEnforcePolicy(lineno - 1)
    self.m_viewer.GotoLine(lineno - 1)
    
    self.m_caption.m_static_text.SetLabel(CAPTION_SOURCE + ' ' + _filename)
    
    self.m_cur_filename = _filename

    self.set_markers()

    if fNoHistory == False:
        self.set_history(self.m_cur_filename)
</t>
<t tx="ekr.20060521134315.1129">def set_position(self, filename, lineno, event, request_number = 0, fNotify = False):
    if fNotify:
        self.__notify_filename(filename, fNew = True)
    
    if request_number == 0:
        self.m_request_number += 1
        request_number = self.m_request_number
    elif request_number &lt;  self.m_request_number:
        return

    if self.m_cur_filename != filename:
        try:
            (_filename, source) = self.m_source_manager.get_source(filename)
        except KeyError:    
            self.m_source_manager.load_source(filename, self.set_position, (lineno, event, request_number), fComplain = False)
            return

        self.__notify_filename(filename, fNew = False)
        
        if self.m_cur_filename != None:
            self.m_files[self.m_cur_filename] = self.m_viewer.GetCurrentLine() + 1 

        self.m_viewer.load_source(source)

    self.m_viewer.EnsureVisibleEnforcePolicy(lineno - 1)
    self.m_viewer.GotoLine(lineno - 1)
    
    self.m_caption.m_static_text.SetLabel(CAPTION_SOURCE + ' ' + filename)
    
    self.m_cur_filename = filename

    self.m_pos_filename = filename
    self.m_pos_lineno = lineno
    self.m_pos_event = event

    self.set_markers()

    self.set_history(self.m_cur_filename)
</t>
<t tx="ekr.20060521134315.1130">def update_bp(self, event):
    if self.m_pos_filename == None:
        return

    if event.m_action == rpdb2.CEventBreakpoint.SET:
        if self.m_cur_filename == event.m_bp.m_filename:
            lineno = event.m_bp.m_lineno
            self.m_viewer.EnsureVisibleEnforcePolicy(lineno - 1)
            self.m_viewer.GotoLine(lineno - 1)            
        
    self.set_markers()
</t>
<t tx="ekr.20060521134315.1131">def set_markers(self):
    for marker in MARKER_LIST:
        self.m_viewer.MarkerDeleteAll(marker)

    if self.m_pos_filename == self.m_cur_filename:    
        self.m_viewer.MarkerAdd(self.m_pos_lineno - 1, self.m_event2Marker[self.m_pos_event])

    f_current_line = False

    bpl = self.m_session_manager.get_breakpoints()

    self.m_breakpoint_lines = {}
    
    for bp in bpl.values():
        if bp.m_filename != self.m_cur_filename:
            continue

        self.m_breakpoint_lines[bp.m_lineno] = bp.m_id
        
        if (self.m_pos_filename == self.m_cur_filename) and (bp.m_lineno == self.m_pos_lineno) and bp.m_fEnabled:
            self.m_viewer.MarkerAdd(self.m_pos_lineno - 1, MARKER_CURRENT_LINE_HIT)
            f_current_line = True
        else:
            marker = [MARKER_BREAKPOINT_DISABLED, MARKER_BREAKPOINT_ENABLED][bp.m_fEnabled]
            self.m_viewer.MarkerAdd(bp.m_lineno - 1, marker)

    if (self.m_pos_filename == self.m_cur_filename) and not f_current_line:
        self.m_viewer.MarkerAdd(self.m_pos_lineno - 1, MARKER_CURRENT_LINE)
</t>
<t tx="ekr.20060521134315.1132">class CConsole(wx.Panel, CCaptionManager):
	@others
</t>
<t tx="ekr.20060521134315.1133">def __init__(self, *args, **kwargs):
    wx.Panel.__init__(self, *args, **kwargs)

    self.m_history = ['']
    self.m_history_index = 0
    
    self.m_parent = None
    self.m_console = None

    self.m_queue = Queue.Queue()
    
    _sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerv = wx.BoxSizer(wx.VERTICAL)
    _sizerv.Add(sizerv, 1, wx.EXPAND | wx.ALL, 3)

    self.m_caption = CCaption(self, label = CAPTION_CONSOLE)
    sizerv.Add(self.m_caption, 0, wx.EXPAND | wx.ALL, 0)

    self.m_console_out = wx.TextCtrl(self, style = wx.TAB_TRAVERSAL | wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL | wx.VSCROLL)
    self.bind_caption(self.m_console_out)
    self.set_font(self.m_console_out)
    sizerv.Add(self.m_console_out, 1, wx.EXPAND | wx.ALL, 0)

    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.EXPAND | wx.ALL, 0)
    
    label = wx.StaticText(self, -1, LABEL_CONSOLE, style = wx.TAB_TRAVERSAL)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 0)

    self.m_console_in = wx.TextCtrl(self)
    self.bind_caption(self.m_console_in)
    self.set_font(self.m_console_in)
    self.m_console_in.SetFocus()
    self.m_console_in.Bind(wx.EVT_CHAR, self.OnChar)
    sizerh.Add(self.m_console_in, 1, wx.EXPAND | wx.ALL, 0)       

    self.SetSizer(_sizerv)
    _sizerv.Fit(self)
</t>
<t tx="ekr.20060521134315.1134">def set_focus(self):
    self.m_console_in.SetFocus()
</t>
<t tx="ekr.20060521134315.1135">def set_filename(self, filename):
    self.m_console.set_filename(filename)
</t>
<t tx="ekr.20060521134315.1136">def set_font(self, ctrl):
    font = ctrl.GetFont()

    if wx.Platform == '__WXMSW__':
        face = "Courier New"
        point_size = 9
    else:
        face = "Courier"
        point_size = font.GetPointSize()
        
    new_font = wx.Font(pointSize = point_size, family = font.GetFamily(), style = font.GetStyle(), weight = font.GetWeight(), face = face)
    ctrl.SetFont(new_font)
</t>
<t tx="ekr.20060521134315.1137">def start(self, parent, session_manager, fchdir, command_line, fAttach):
    self.m_parent = parent
    self.m_console = rpdb2.CConsole(session_manager, stdin = self, stdout = self, fSplit = True)
    self.m_console.start()

    if fAttach:
        session_manager.attach_nothrow(command_line)
    elif command_line != '':
        session_manager.launch_nothrow(fchdir, command_line)
</t>
<t tx="ekr.20060521134315.1138">def stop(self):
    self.m_queue.put('exit\n')
    self.m_console.join()
</t>
<t tx="ekr.20060521134315.1139">def write(self, str):
    sl = str.split('\n')
    
    _str = ''
    
    for s in sl:
        while True:
            _str += '\n' + s[:81]
            s = s[81:] 
            if len(s) == 0:
                break
        
    wx.CallAfter(self.m_console_out.write, _str[1:])    
</t>
<t tx="ekr.20060521134315.1140">def flush(self):
    pass
</t>
<t tx="ekr.20060521134315.1141">def readline(self):
    str = self.m_queue.get()
    return str
</t>
<t tx="ekr.20060521134315.1142">def OnChar(self, event):
    key = event.KeyCode()

    if key in [wx.WXK_UP, wx.WXK_DOWN]:
        value = self.m_console_in.GetValue()
        _value = self.get_history(key == wx.WXK_UP, value)
        self.m_console_in.SetValue(_value)
        self.m_console_in.SetInsertionPointEnd()
        return
        
    if key == wx.WXK_RETURN:
        value = self.m_console_in.GetValue()
        self.set_history(value)
        
        self.m_console_out.write(CONSOLE_PROMPT + value + '\n') 
        self.m_console_in.Clear()
        self.m_queue.put(value + '\n')

        if value in ['exit', 'EOF']:
            self.m_parent.do_exit()
            
        return

    event.Skip()    
</t>
<t tx="ekr.20060521134315.1143">def get_history(self, fBack, value = None):
    if (value != None) and (value != self.m_history[self.m_history_index]):
        self.m_history[0] = value
        self.m_history_index = 0
        
    self.m_history_index = (self.m_history_index + [-1, 1][fBack]) % len(self.m_history)
    return self.m_history[self.m_history_index]
</t>
<t tx="ekr.20060521134315.1144">def set_history(self, value):
    self.m_history[0] = ''
    self.m_history.insert(1, value)
    self.m_history = self.m_history[:50]
    
    self.m_history_index = 0
</t>
<t tx="ekr.20060521134315.1145">class CThreadsViewer(wx.Panel, CCaptionManager):
	@others
</t>
<t tx="ekr.20060521134315.1146">def __init__(self, *args, **kwargs):
    self.m_select_command = kwargs.pop('select_command', None)
    
    wx.Panel.__init__(self, *args, **kwargs)

    self.m_suppress_recursion = 0
    
    _sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerv = wx.BoxSizer(wx.VERTICAL)
    _sizerv.Add(sizerv, 1, wx.EXPAND | wx.ALL, 3)

    self.m_caption = CCaption(self, label = CAPTION_THREADS)
    sizerv.Add(self.m_caption, 0, wx.EXPAND | wx.ALL, 0)

    self.m_threads = CListCtrl(parent = self, style = wx.LC_REPORT | wx.LC_SINGLE_SEL)
    self.bind_caption(self.m_threads)
    self.m_threads.InsertColumn(0, HLIST_HEADER_TID)
    self.m_threads.InsertColumn(1, HLIST_HEADER_STATE)
    sizerv.Add(self.m_threads, 1, wx.EXPAND | wx.ALL, 0)

    if self.m_select_command:
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnThreadSelected, self.m_threads)
                
    self.SetSizer(_sizerv)
    _sizerv.Fit(self)
</t>
<t tx="ekr.20060521134315.1147">def set_cursor(self, id):
    cursor = wx.StockCursor(id)
    self.SetCursor(cursor)        
    self.m_threads.SetCursor(cursor)        
</t>
<t tx="ekr.20060521134315.1148">def _clear(self):
    self.m_threads.DeleteAllItems()
    self.m_threads.Disable()
</t>
<t tx="ekr.20060521134315.1149">def _disable(self):
    self.m_threads.Disable()
</t>
<t tx="ekr.20060521134315.1150">def _enable(self):
    self.m_threads.Enable()
</t>
<t tx="ekr.20060521134315.1151">def is_selected(self, index):
    return self.m_threads.IsSelected(index)
</t>
<t tx="ekr.20060521134315.1152">def update_thread(self, thread_id, fBroken):
    index = self.m_threads.FindItemData(-1, thread_id)
    if index &lt; 0:
        return -1

    self.m_threads.SetStringItem(index, 1, [rpdb2.STATE_RUNNING, rpdb2.STATE_BROKEN][fBroken])

    return index
</t>
<t tx="ekr.20060521134315.1153">def update_threads_list(self, current_thread, threads_list):
    if self.m_suppress_recursion &gt; 0:
        self.m_suppress_recursion -= 1
        return
        
    self.m_threads.DeleteAllItems()

    j = None
    for i, s in enumerate(threads_list):
        tid = s[rpdb2.DICT_KEY_TID]
        fBroken = s[rpdb2.DICT_KEY_BROKEN]
        index = self.m_threads.InsertStringItem(sys.maxint, repr(tid))
        self.m_threads.SetStringItem(index, 1, [rpdb2.STATE_RUNNING, rpdb2.STATE_BROKEN][fBroken])
        self.m_threads.SetItemData(index, tid)
        if tid == current_thread:
            j = i

    self.m_threads.set_columns_width()

    if j != None:
        self.m_suppress_recursion += 1
        self.m_threads.Select(j)
</t>
<t tx="ekr.20060521134315.1154">def OnThreadSelected(self, event):                
    if self.m_suppress_recursion == 0:
        self.m_suppress_recursion += 1
        index = event.m_itemIndex
        tid = self.m_threads.GetItemData(index)
        self.m_select_command(tid)
    else:
        self.m_suppress_recursion -= 1

    event.Skip()
</t>
<t tx="ekr.20060521134315.1155">class CLocals(CNamespacePanel):
	@others
</t>
<t tx="ekr.20060521134315.1156">def __init__(self, *args, **kwargs):
    self.m_session_manager = kwargs.pop('session_manager')

    CNamespacePanel.__init__(self, *args, **kwargs)        
</t>
<t tx="ekr.20060521134315.1157">def get_root_expr(self):
    return 'locals()'
</t>
<t tx="ekr.20060521134315.1158">class CGlobals(CNamespacePanel):
	@others
</t>
<t tx="ekr.20060521134315.1159">def __init__(self, *args, **kwargs):
    self.m_session_manager = kwargs.pop('session_manager')

    CNamespacePanel.__init__(self, *args, **kwargs)        
</t>
<t tx="ekr.20060521134315.1160">def get_root_expr(self):
    return 'globals()'
</t>
<t tx="ekr.20060521134315.1161">class CException(CNamespacePanel):
	@others
</t>
<t tx="ekr.20060521134315.1162">def __init__(self, *args, **kwargs):
    self.m_session_manager = kwargs.pop('session_manager')

    CNamespacePanel.__init__(self, *args, **kwargs)        
</t>
<t tx="ekr.20060521134315.1163">def get_root_expr(self):
    return rpdb2.RPDB_EXEC_INFO
</t>
<t tx="ekr.20060521134315.1164">class CNamespaceViewer(wx.Panel, CCaptionManager):
	@others
</t>
<t tx="ekr.20060521134315.1165">def __init__(self, *args, **kwargs):
    self.m_session_manager = kwargs.pop('session_manager')

    self.m_key_map = {}
    
    wx.Panel.__init__(self, *args, **kwargs)

    _sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerv = wx.BoxSizer(wx.VERTICAL)
    _sizerv.Add(sizerv, 1, wx.EXPAND | wx.ALL, 3)

    self.m_caption = CCaption(self, label = CAPTION_NAMESPACE)
    sizerv.Add(self.m_caption, 0, wx.EXPAND | wx.ALL, 0)

    self.m_notebook = wx.Notebook(self)

    self.m_locals = CLocals(self.m_notebook, session_manager = self.m_session_manager)
    self.m_notebook.AddPage(self.m_locals, "Locals")
    self.m_globals = CGlobals(self.m_notebook, session_manager = self.m_session_manager)
    self.m_notebook.AddPage(self.m_globals, "Globals")
    self.m_exception = CException(self.m_notebook, session_manager = self.m_session_manager)
    self.m_notebook.AddPage(self.m_exception, "Exception")

    self.bind_caption(self.m_notebook)
    self.m_locals.bind_caption(self)
    self.m_globals.bind_caption(self)
    self.m_exception.bind_caption(self)

    sizerv.Add(self.m_notebook, 1, wx.EXPAND | wx.ALL, 0)
    
    self.SetSizer(_sizerv)
    _sizerv.Fit(self)
</t>
<t tx="ekr.20060521134315.1166">def _clear(self):
    self.m_locals._clear()
    self.m_globals._clear()
    self.m_exception._clear()
</t>
<t tx="ekr.20060521134315.1167">def _disable(self):
    self.m_notebook.Disable()
    self.m_locals.Disable()
    self.m_globals.Disable()
    self.m_exception.Disable()
</t>
<t tx="ekr.20060521134315.1168">def _enable(self):
    self.m_notebook.Enable()
    self.m_locals.Enable()
    self.m_globals.Enable()
    self.m_exception.Enable()
</t>
<t tx="ekr.20060521134315.1169">def set_filter(self, fFilter):
    self.m_globals.set_filter(fFilter)
</t>
<t tx="ekr.20060521134315.1170">def get_local_key(self, _stack):
    frame_index = self.m_session_manager.get_frame_index()
    c = _stack.get(rpdb2.DICT_KEY_CODE_LIST, [])
    key = c[-(1 + frame_index)]
    return key        
</t>
<t tx="ekr.20060521134315.1171">def get_global_key(self, _stack):
    frame_index = self.m_session_manager.get_frame_index()
    s = _stack.get(rpdb2.DICT_KEY_STACK, [])
    key = s[-(1 + frame_index)][0]
    return key
</t>
<t tx="ekr.20060521134315.1172">def update_namespace(self, _stack):
    key = self.get_local_key(_stack)
    el = self.m_key_map.get(key, None)
    (key0, el0) = self.m_locals.update_namespace(key, el)
    self.m_key_map[key0] = el0
    
    key = self.get_global_key(_stack)
    el = self.m_key_map.get(key, None)
    (key1, el1) = self.m_globals.update_namespace(key, el)
    self.m_key_map[key1] = el1
    
    key = 'exception'
    el = self.m_key_map.get(key, None)
    (key1, el1) = self.m_exception.update_namespace(key, el)
    self.m_key_map[key] = el1
</t>
<t tx="ekr.20060521134315.1173">class CStackViewer(wx.Panel, CCaptionManager):
	@others
</t>
<t tx="ekr.20060521134315.1174">def __init__(self, *args, **kwargs):
    self.m_select_command = kwargs.pop('select_command', None)
    
    wx.Panel.__init__(self, *args, **kwargs)

    self.m_suppress_recursion = 0
    
    _sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerv = wx.BoxSizer(wx.VERTICAL)
    _sizerv.Add(sizerv, 1, wx.EXPAND | wx.ALL, 3)

    self.m_caption = CCaption(self, label = CAPTION_STACK)
    sizerv.Add(self.m_caption, 0, wx.EXPAND | wx.ALL, 0)

    self.m_stack = CListCtrl(parent = self, style = wx.LC_REPORT | wx.LC_SINGLE_SEL)
    self.bind_caption(self.m_stack)
    self.m_stack.InsertColumn(0, HLIST_HEADER_FRAME)
    self.m_stack.InsertColumn(1, HLIST_HEADER_FILENAME)
    self.m_stack.InsertColumn(2, HLIST_HEADER_LINENO)
    self.m_stack.InsertColumn(3, HLIST_HEADER_FUNCTION)
    self.m_stack.InsertColumn(4, HLIST_HEADER_PATH)

    sizerv.Add(self.m_stack, 1, wx.EXPAND | wx.ALL, 0)

    if self.m_select_command:
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnFrameSelected, self.m_stack)
                
    self.SetSizer(_sizerv)
    _sizerv.Fit(self)
</t>
<t tx="ekr.20060521134315.1175">def set_cursor(self, id):
    cursor = wx.StockCursor(id)
    self.SetCursor(cursor)        
    self.m_stack.SetCursor(cursor)        
</t>
<t tx="ekr.20060521134315.1176">def _clear(self):
    self.m_stack.DeleteAllItems()
</t>
<t tx="ekr.20060521134315.1177">def _disable(self):
    self.m_stack.Disable()
</t>
<t tx="ekr.20060521134315.1178">def _enable(self):
    self.m_stack.Enable()
</t>
<t tx="ekr.20060521134315.1179">def is_selected(self, index):
    return self.m_stack.IsSelected(index)
</t>
<t tx="ekr.20060521134315.1180">def update_stack_list(self, st):
    self.m_stack.DeleteAllItems()

    s = st.get(rpdb2.DICT_KEY_STACK, [])
    
    i = 0
    while i &lt; len(s):
        e = s[-(1 + i)]

        index = self.m_stack.InsertStringItem(sys.maxint, repr(i))
        self.m_stack.SetStringItem(index, 1, os.path.basename(e[0]))
        self.m_stack.SetStringItem(index, 2, repr(e[1]))
        self.m_stack.SetStringItem(index, 3, e[2])
        self.m_stack.SetStringItem(index, 4, os.path.dirname(e[0]))
        self.m_stack.SetItemData(index, i)

        i += 1
        
    self.m_stack.set_columns_width()

    self.m_suppress_recursion += 1
    self.m_stack.Select(0)
</t>
<t tx="ekr.20060521134315.1181">def select_frame(self, index):
    if self.m_suppress_recursion &gt; 0:
        self.m_suppress_recursion -= 1
        return
        
    if (index &lt; 0) or (index &gt; self.m_stack.GetItemCount()):
        return

    if self.m_stack.IsSelected(index):
        return
        
    self.m_suppress_recursion += 1
    self.m_stack.Select(index)
</t>
<t tx="ekr.20060521134315.1182">def OnFrameSelected(self, event):
    if self.m_suppress_recursion == 0:
        self.m_suppress_recursion += 1
        self.m_select_command(event)
    else:
        self.m_suppress_recursion -= 1

    event.Skip()    
</t>
<t tx="ekr.20060521134315.1183"></t>
<t tx="ekr.20060521134315.1184">class CHTMLDialog(wx.Dialog):
	@others
</t>
<t tx="ekr.20060521134315.1185">def __init__(self, parent, title, text):
    wx.Dialog.__init__(self, parent, -1, title)

    sizerv = wx.BoxSizer(wx.VERTICAL)

    self.m_html = wx.html.HtmlWindow(self, -1, size = (600, -1))
    sizerv.Add(self.m_html, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    if "gtk2" in wx.PlatformInfo:
        self.m_html.SetStandardFonts()

    self.m_html.SetPage(self.get_html_text(text))
    
    ir = self.m_html.GetInternalRepresentation()
    self.m_html.SetSize((ir.GetWidth() + 25, min(500, ir.GetHeight() + 25)))

    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    self.m_ok = wx.Button(self, wx.ID_OK)
    self.m_ok.SetDefault()
    btnsizer.AddButton(self.m_ok)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)
    self.CentreOnParent(wx.BOTH)
</t>
<t tx="ekr.20060521134315.1186">def get_html_text(self, text):
    tl = text.split('\n')
    t = '&lt;br&gt;'.join(tl)
    
    return ABOUT_HTML_PREFIX + t + ABOUT_HTML_SUFFIX
</t>
<t tx="ekr.20060521134315.1187">class CAttachDialog(wx.Dialog, CJobs):
	@others
</t>
<t tx="ekr.20060521134315.1188">def __init__(self, parent, session_manager):
    wx.Dialog.__init__(self, parent, -1, DLG_ATTACH_TITLE)
    CJobs.__init__(self)
    
    self.init_jobs()
    self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)

    self.m_session_manager = session_manager
    self.m_server_list = None
    self.m_errors = {}
    self.m_index = None
                    
    sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    label = wx.StaticText(self, -1, LABEL_ATTACH_HOST)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    host = self.m_session_manager.get_host()
    self.m_entry_host = wx.TextCtrl(self, value = host, size = (200, -1))
    sizerh.Add(self.m_entry_host, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    
    btn = wx.Button(self, label = BUTTON_ATTACH_REFRESH)
    self.Bind(wx.EVT_BUTTON, self.do_refresh, btn)
    btn.SetDefault()
    sizerh.Add(btn, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    self.m_listbox_scripts = CListCtrl(parent = self, style = wx.LC_REPORT | wx.LC_SINGLE_SEL, size = (-1, 300))
    self.m_listbox_scripts.InsertColumn(0, HLIST_HEADER_PID)
    self.m_listbox_scripts.InsertColumn(1, HLIST_HEADER_FILENAME)
    self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.m_listbox_scripts)
    self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnItemDeselected, self.m_listbox_scripts)
    self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.OnItemActivated, self.m_listbox_scripts)
    sizerv.Add(self.m_listbox_scripts, 0, wx.EXPAND | wx.ALL, 5)

    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5)

    self.m_ok = wx.Button(self, wx.ID_OK)
    self.m_ok.Disable()
    btnsizer.AddButton(self.m_ok)

    btn = wx.Button(self, wx.ID_CANCEL)
    btnsizer.AddButton(btn)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)

    wx.CallAfter(self.init2)
</t>
<t tx="ekr.20060521134315.1189">def init2(self):
    pwd = self.m_session_manager.get_password()
    if pwd != None:
        self.do_refresh()
        return

    pwd_dialog = CPwdDialog(self, pwd)
    pos = self.GetPositionTuple()
    pwd_dialog.SetPosition((pos[0] + 50, pos[1] + 50))
    r = pwd_dialog.ShowModal()
    if r == wx.ID_OK:
        pwd = pwd_dialog.get_password()
        pwd_dialog.Destroy()
        self.job_post(self.job_pwd, (pwd, ), self.do_refresh)
        return

    pwd_dialog.Destroy()
    self.Close()
    return
</t>
<t tx="ekr.20060521134315.1190">def job_pwd(self, pwd):
    try:
        self.m_session_manager.set_password(pwd)
        return
        
    except rpdb2.AlreadyAttached:
        pass
</t>
<t tx="ekr.20060521134315.1191">def set_cursor(self, id):
    cursor = wx.StockCursor(id)
    self.SetCursor(cursor)        
    self.m_listbox_scripts.SetCursor(cursor)        
</t>
<t tx="ekr.20060521134315.1192">def OnCloseWindow(self, event):
    self.shutdown_jobs()
    self.Destroy()
</t>
<t tx="ekr.20060521134315.1193">def get_server(self):
    return self.m_server_list[self.m_index]
</t>
<t tx="ekr.20060521134315.1194">def do_refresh(self, event = None):
    host = self.m_entry_host.GetValue()
    if host == '':
        host = 'localhost'
    self.job_post(self.job_calc_scripts, (host, ), self.update_body)
</t>
<t tx="ekr.20060521134315.1195">def job_calc_scripts(self, host):
    try:
        self.m_session_manager.set_host(host)
        (self.m_server_list, self.m_errors) = self.m_session_manager.calc_server_list()
        return (True, host)
        
    except UnsetPassword:
        return
    except socket.gaierror, e:
        return (False, host)
</t>
<t tx="ekr.20060521134315.1196">def update_body(self, result, host):
    if result == False:
        dlg = wx.MessageDialog(self, MSG_ERROR_HOST_TEXT % (host, ), MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()

    if len(self.m_errors) &gt; 0:
        text = ''
        for k in self.m_errors.keys():
            if k == rpdb2.AuthenticationBadData:
                text += '\n' + rpdb2.STR_ACCESS_DENIED
            if k == rpdb2.AuthenticationFailure:
                text += '\n' + rpdb2.STR_ACCESS_DENIED
            if k == rpdb2.EncryptionExpected:
                text += '\n' + rpdb2.STR_ENCRYPTION_EXPECTED
            if k == rpdb2.BadVersion:
                text += '\n' + rpdb2.STR_BAD_VERSION2

        text = text[1:]        
        
        dlg = wx.MessageDialog(self, text, MSG_WARNING_TITLE, wx.OK | wx.ICON_WARNING)
        dlg.ShowModal()
        dlg.Destroy()            
        
    self.m_ok.Disable()

    host = self.m_session_manager.get_host()
    self.m_entry_host.SetValue(host)

    self.m_listbox_scripts.DeleteAllItems()

    for i, s in enumerate(self.m_server_list):
        index = self.m_listbox_scripts.InsertStringItem(sys.maxint, repr(s.m_pid))
        self.m_listbox_scripts.SetStringItem(index, 1, s.m_filename)
        self.m_listbox_scripts.SetItemData(index, i)

    self.m_listbox_scripts.set_columns_width()
</t>
<t tx="ekr.20060521134315.1197">def OnItemSelected(self, event):
    self.m_index = event.m_itemIndex
    self.m_ok.Enable()

    event.Skip()
</t>
<t tx="ekr.20060521134315.1198">def OnItemDeselected(self, event):
    if self.m_listbox_scripts.GetSelectedItemCount() == 0:
        self.m_ok.Disable()

    event.Skip()    
</t>
<t tx="ekr.20060521134315.1199">def OnItemActivated(self, event):
    self.m_index = event.m_itemIndex

    self.EndModal(wx.ID_OK)
</t>
<t tx="ekr.20060521134315.1200">class CExpressionDialog(wx.Dialog):
	@others
</t>
<t tx="ekr.20060521134315.1201">def __init__(self, parent):
    wx.Dialog.__init__(self, parent, -1, DLG_EXPR_TITLE)
    
    sizerv = wx.BoxSizer(wx.VERTICAL)

    label = wx.StaticText(self, -1, STATIC_EXPR)
    sizerv.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    label = wx.StaticText(self, -1, LABEL_EXPR)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    self.m_entry_expr = wx.TextCtrl(self, size = (200, -1))
    self.Bind(wx.EVT_TEXT, self.OnText, self.m_entry_expr)
    sizerh.Add(self.m_entry_expr, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    
    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5)
    
    self.m_ok = wx.Button(self, wx.ID_OK)
    self.m_ok.SetDefault()
    self.m_ok.Disable()
    btnsizer.AddButton(self.m_ok)

    btn = wx.Button(self, wx.ID_CANCEL)
    btnsizer.AddButton(btn)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)        
</t>
<t tx="ekr.20060521134315.1202">def OnText(self, event):
    if event.GetString() == '':
        self.m_ok.Disable()
    else:
        self.m_ok.Enable()

    event.Skip()        
</t>
<t tx="ekr.20060521134315.1203">def get_expression(self):
    return self.m_entry_expr.GetValue()
</t>
<t tx="ekr.20060521134315.1204">class CPwdDialog(wx.Dialog):
	@others
</t>
<t tx="ekr.20060521134315.1205">def __init__(self, parent, current_password):
    wx.Dialog.__init__(self, parent, -1, DLG_PWD_TITLE)
    
    sizerv = wx.BoxSizer(wx.VERTICAL)

    label = wx.StaticText(self, -1, STATIC_PWD)
    sizerv.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    label = wx.StaticText(self, -1, LABEL_PWD)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    pwd = [current_password, ''][current_password == None]
    self.m_entry_pwd = wx.TextCtrl(self, value = pwd, size = (200, -1))
    self.Bind(wx.EVT_TEXT, self.OnText, self.m_entry_pwd)
    sizerh.Add(self.m_entry_pwd, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    
    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5)
    
    self.m_ok = wx.Button(self, wx.ID_OK)
    self.m_ok.SetDefault()
    if pwd == '':
        self.m_ok.Disable()
    btnsizer.AddButton(self.m_ok)

    btn = wx.Button(self, wx.ID_CANCEL)
    btnsizer.AddButton(btn)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)        
</t>
<t tx="ekr.20060521134315.1206">def OnText(self, event):
    if event.GetString() == '':
        self.m_ok.Disable()
    else:
        self.m_ok.Enable()

    event.Skip()        
</t>
<t tx="ekr.20060521134315.1207">def get_password(self):
    return self.m_entry_pwd.GetValue()
</t>
<t tx="ekr.20060521134315.1208">class COpenDialog(wx.Dialog):
	@others
</t>
<t tx="ekr.20060521134315.1209">def __init__(self, parent, fLocal):
    wx.Dialog.__init__(self, parent, -1, DLG_OPEN_TITLE)
    
    sizerv = wx.BoxSizer(wx.VERTICAL)

    label = wx.StaticText(self, -1, STATIC_OPEN)
    sizerv.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    label = wx.StaticText(self, -1, LABEL_OPEN)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    self.m_entry = wx.TextCtrl(self, size = (200, -1))
    self.Bind(wx.EVT_TEXT, self.OnText, self.m_entry)
    sizerh.Add(self.m_entry, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    if fLocal:
        btn = wx.Button(self, label = BUTTON_LAUNCH_BROWSE)
        self.Bind(wx.EVT_BUTTON, self.do_browse, btn)
        sizerh.Add(btn, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5)
    
    self.m_ok = wx.Button(self, wx.ID_OK)
    self.Bind(wx.EVT_BUTTON, self.do_ok, self.m_ok)
    self.m_ok.SetDefault()
    btnsizer.AddButton(self.m_ok)

    btn = wx.Button(self, wx.ID_CANCEL)
    btnsizer.AddButton(btn)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)        
</t>
<t tx="ekr.20060521134315.1210">def OnText(self, event):
    if event.GetString() == '':
        self.m_ok.Disable()
    else:
        self.m_ok.Enable()

    event.Skip()        
</t>
<t tx="ekr.20060521134315.1211">def do_browse(self, event = None):
    command_line = self.m_entry.GetValue()
    (_path, filename, args) = rpdb2.split_command_line_path_filename_args(command_line)
    _abs_path = os.path.abspath(_path)

    dlg = wx.FileDialog(self, defaultDir = _abs_path, defaultFile = filename, wildcard = WINPDB_WILDCARD, style = wx.OPEN | wx.CHANGE_DIR)
    r = dlg.ShowModal()
    if r == wx.ID_OK:
        path = dlg.GetPaths()[0]
        abs_path = os.path.abspath(path)
        if (' ' in abs_path):
            abs_path = '"' + abs_path + '"'
    else:
        abs_path = command_line

    dlg.Destroy()
    
    self.m_entry.SetValue(abs_path)
</t>
<t tx="ekr.20060521134315.1212">def do_validate(self):
    filename = self.m_entry.GetValue()
    if filename[:1] + filename[-1:] in ['""', "''"]:
        filename = filename[1:-1]

    if not rpdb2.IsPythonSourceFile(filename):
        dlg = wx.MessageDialog(self, MSG_ERROR_FILE_NOT_PYTHON, MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return False

    return True
</t>
<t tx="ekr.20060521134315.1213">def do_ok(self, event):
    f = self.do_validate()
    if not f:
        return

    event.Skip()
</t>
<t tx="ekr.20060521134315.1214">def get_file_name(self):
    return self.m_entry.GetValue()
</t>
<t tx="ekr.20060521134315.1215">class CLaunchDialog(wx.Dialog):
	@others
</t>
<t tx="ekr.20060521134315.1216">def __init__(self, parent, default_command_line = ''):
    wx.Dialog.__init__(self, parent, -1, DLG_LAUNCH_TITLE)
    
    self.m_default_command_line = default_command_line

    sizerv = wx.BoxSizer(wx.VERTICAL)
    sizerh = wx.BoxSizer(wx.HORIZONTAL)
    sizerv.Add(sizerh, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    label = wx.StaticText(self, -1, LABEL_LAUNCH_COMMAND_LINE)
    sizerh.Add(label, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    self.m_entry_commandline = wx.TextCtrl(self, value = default_command_line, size = (200, -1))
    self.Bind(wx.EVT_TEXT, self.OnText, self.m_entry_commandline)
    sizerh.Add(self.m_entry_commandline, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    
    btn = wx.Button(self, label = BUTTON_LAUNCH_BROWSE)
    self.Bind(wx.EVT_BUTTON, self.do_browse, btn)
    sizerh.Add(btn, 0, wx.ALIGN_CENTRE | wx.ALL, 5)

    self.m_cb = wx.CheckBox(self, -1, CHECKBOX_LAUNCH)
    self.m_cb.SetValue(True)
    sizerv.Add(self.m_cb, 0, wx.ALIGN_LEFT | wx.ALL, 5)
    
    btnsizer = wx.StdDialogButtonSizer()
    sizerv.Add(btnsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5)

    self.m_ok = wx.Button(self, wx.ID_OK)
    self.Bind(wx.EVT_BUTTON, self.do_ok, self.m_ok)
    self.m_ok.SetDefault()
    btnsizer.AddButton(self.m_ok)

    if default_command_line == '':
        self.m_ok.Disable()

    btn = wx.Button(self, wx.ID_CANCEL)
    btnsizer.AddButton(btn)
    btnsizer.Realize()

    self.SetSizer(sizerv)
    sizerv.Fit(self)        
</t>
<t tx="ekr.20060521134315.1217">def OnText(self, event):
    if event.GetString() == '':
        self.m_ok.Disable()
    else:
        self.m_ok.Enable()

    event.Skip()        
</t>
<t tx="ekr.20060521134315.1218">def do_browse(self, event = None):
    command_line = self.m_entry_commandline.GetValue()
    (_path, filename, args) = rpdb2.split_command_line_path_filename_args(command_line)
    _abs_path = os.path.abspath(_path)

    dlg = wx.FileDialog(self, defaultDir = _abs_path, defaultFile = filename, wildcard = WINPDB_WILDCARD, style = wx.OPEN | wx.CHANGE_DIR)
    r = dlg.ShowModal()
    if r == wx.ID_OK:
        path = dlg.GetPaths()[0]
        abs_path = os.path.abspath(path)
        if (' ' in abs_path):
            abs_path = '"' + abs_path + '"'
    else:
        abs_path = command_line

    dlg.Destroy()
    
    self.m_entry_commandline.SetValue(abs_path)
</t>
<t tx="ekr.20060521134315.1219">def do_validate(self):
    command_line = self.m_entry_commandline.GetValue()
    (_path, filename, args)  = rpdb2.split_command_line_path_filename_args(command_line)
    
    try:
        _filename = os.path.join(_path, filename)
        abs_path = rpdb2.FindFile(_filename)
    except IOError:                    
        dlg = wx.MessageDialog(self, MSG_ERROR_FILE_NOT_FOUND, MSG_ERROR_TITLE, wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return False
    
    if ' ' in abs_path:
        command_line = ('"' + abs_path + '" ' + args).strip()
    else:
        command_line = (abs_path + ' ' + args).strip()
        
    self.m_entry_commandline.SetValue(command_line)
    
    return True
</t>
<t tx="ekr.20060521134315.1220">def do_ok(self, event):
    f = self.do_validate()
    if not f:
        return

    event.Skip()
</t>
<t tx="ekr.20060521134315.1221">def get_command_line(self):
    return (self.m_entry_commandline.GetValue(), self.m_cb.GetValue())
</t>
<t tx="ekr.20060521134315.1222"></t>
<t tx="ekr.20060521134315.1223">def image_from_base64(str_b64):
    s = base64.decodestring(str_b64)
    stream = cStringIO.StringIO(s)
    image = wx.ImageFromStream(stream)

    return image</t>
<t tx="ekr.20060521134315.1224">def StartClient(command_line, fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host):

    sm = rpdb2.CSessionManager(pwd, fAllowUnencrypted, fRemote, host)
    app = CWinpdbApp(sm, fchdir, command_line, fAttach, fAllowUnencrypted)
    app.MainLoop()</t>
<t tx="ekr.20060521134315.1225">def main():

    if rpdb2.get_version() != "RPDB_2_0_6":
        print STR_ERROR_INTERFACE_COMPATIBILITY % ("RPDB_2_0_6", rpdb2.get_version())
        return
        
    return rpdb2.main(StartClient)</t>
<t tx="ekr.20060521134315.1226">def get_version():
    return WINPDB_VERSION
</t>
<t tx="ekr.20060521134315.1227"></t>
<t tx="ekr.20060521134315.1228"># vim:set shiftwidth=4 tabstop=4 expandtab textwidth=79:

# Copyright (c) 2006 Ali Afshar

#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included in
#all copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.</t>
<t tx="ekr.20060521134315.1229"></t>
<t tx="ekr.20060521134315.1230">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1231">import gtk
import gobject

from components import PGDSlaveDelegate

from tree import Tree</t>
<t tx="ekr.20060521134315.1232">class Breakpoint(object):
	@others

    disabled_text = property(get_disabled_text)
    
    color = property(get_color)</t>
<t tx="ekr.20060521134315.1233">def __init__(self, index, filename, linenumber):
    self.key = index
    self.filename = filename
    self.linenumber = linenumber
    self.enabled = True
</t>
<t tx="ekr.20060521134315.1234">def get_color(self):
    if self.enabled:
        return '#000000'
    else:
        return '#a0a0a0'
</t>
<t tx="ekr.20060521134315.1235">def get_disabled_text(self):
    if self.enabled:
        return ''
    else:
        return '(disabled)'
</t>
<t tx="ekr.20060521134315.1236">

class BreakpointViewer(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1237">def attach_slaves(self):
    self.main_window.attach_slave('breaks_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1238">def update_bp(self, action, index, indices, filename, linenumber):
    mod = self.tree.model
    if action == 'set':
        gen = self._get_all_bps([index])
        try:
            index, val = gen.next()
            val.filename = filename
            val.linenumber = linenumber
            val.reset_markup()
        except StopIteration:
            bp = Breakpoint(index, filename, linenumber)
            self.tree.add_item(bp)
            #self.app.source.set_breakpoint(index, filename, linenumber)
    elif action == 'remove':
        for i, row in self._get_all_index_rows(indices):
            val = row[1].value
            filename = val.filename
            #self.app.source.remove_breakpoint(i, filename)
            mod.remove(row.iter)
    elif action == 'disable':
        for i, value in self._get_all_bps(indices):
            value.enabled = False
            value.reset_markup()
    elif action == 'enable':
        for i, value in self._get_all_bps(indices):
            value.enabled = True
            value.reset_markup()
</t>
<t tx="ekr.20060521134315.1239">def create_toplevel_widget(self):
    vb = gtk.VBox()
    t = self.add_widget('tree', Tree())
    t.set_property('markup-format-string',
                   '&lt;b&gt;[%(key)s]&lt;/b&gt;'
                   '&lt;span color="%(color)s"&gt;'
                   '&lt;tt&gt; %(filename)s:%(linenumber)s &lt;/tt&gt;'
                   '&lt;/span&gt;&lt;i&gt;%(disabled_text)s&lt;/i&gt;')
    vb.pack_start(t)
    self._create_actions()
    return vb
</t>
<t tx="ekr.20060521134315.1240">def _create_actions(self):
    self._current = None
    self.add_widget('dis_act', gtk.Action('Disable', 'Disable',
        'Disable this breakpoint', gtk.STOCK_NO))
    self.add_widget('en_act', gtk.Action('Enable', 'Enable',
        'Enable this breakpoint', gtk.STOCK_YES))
</t>
<t tx="ekr.20060521134315.1241">def _create_popup(self, bp, event):
    self._current = bp
    if not bp: return
    menu = gtk.Menu()
    mi = self.dis_act.create_menu_item()
    menu.add(mi)
    self.dis_act.set_sensitive(bp.enabled)
    mi = self.en_act.create_menu_item()
    menu.add(mi)
    self.en_act.set_sensitive(not bp.enabled)
    menu.show_all()
    menu.popup(None, None, None, event.button, event.time)
</t>
<t tx="ekr.20060521134315.1242">def _get_all_index_rows(self, indices):
    mod = self.tree.model
    for index in indices:
        for row in mod:
            if row[0] == str(index):
                yield index, row
</t>
<t tx="ekr.20060521134315.1243">def _get_all_bps(self, indices):
    for index, row in self._get_all_index_rows(indices):
        value = row[1].value
        yield index, value
</t>
<t tx="ekr.20060521134315.1244">def _set_breakpoint_enabled_status(self, bp, enabled):
    if not enabled:
        func = self.session_manager.disable_breakpoint
    else:
        func = self.session_manager.enable_breakpoint
    gobject.idle_add(func, [bp.key], False)
</t>
<t tx="ekr.20060521134315.1245">def on_tree__double_clicked(self, tv, item):
    if item:
        val = item.value
        self._set_breakpoint_enabled_status(val, not val.enabled)
</t>
<t tx="ekr.20060521134315.1246">def on_tree__right_clicked(self, tv, item, event):
    if item is None:
        val = item
    else:
        val = item.value
    self._create_popup(val, event)
</t>
<t tx="ekr.20060521134315.1247">def on_dis_act__activate(self, action):
    print 'disabled'
    self._set_breakpoint_enabled_status(self._current, False)
</t>
<t tx="ekr.20060521134315.1248">def on_en_act__activate(self, action):
    self._set_breakpoint_enabled_status(self._current, True)
</t>
<t tx="ekr.20060521134315.1249">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

from kiwiviews import PythonSlaveDelegate

@others
</t>
<t tx="ekr.20060521134315.1250">class PGDSlaveDelegate(PythonSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1251">def __init__(self, app):
    self.app = app
    self.main_window = app.main_window
    super(PGDSlaveDelegate, self).__init__()
</t>
<t tx="ekr.20060521134315.1252">def get_session_manager(self):
    try:
        return self.app.session_manager
    except:
        return
</t>
<t tx="ekr.20060521134315.1253">session_manager = property(get_session_manager)

def update_state(self, state):
    pass
</t>
<t tx="ekr.20060521134315.1254">@first # -*- coding: utf-8 -*-

&lt;&lt; docstring &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

@language python
@tabwidth -4

@others
        
if __name__ == '__main__':
    primary_text = "Listing cool stuff"
    secondary_text = "To select more of that stuff eat alot of cheese!"
    list_title = "Your cool stuff:"
    items = ["foo", "bar"] * 10
    window_title = "Rat Demo"
    list_dialog(primary_text, secondary_text, items=items, title=window_title, list_title=list_title)

#    print save_changes(["foo"], title="goo")
#    print dialog_ok_cancel("Rat will simplify your code",
#                            ("By putting common utilities in one place all "
#                             "benefit and get nicer apps.")) 


</t>
<t tx="ekr.20060521134315.1255">__doc__ = """
The HIG module offers a set of utility functions and widgets to implement
HIG compliant interfaces.

This module defines a pipeline of costumizing widgets, it follows the simple
procedure that creating a HIG compliant application can be thought of a
work that has patterns of costumizations that act in different levels with
different widgets, we'll address them as Costumizers.

To call a dialog for asking the user to save changes on a certain file use this::

    &gt;&gt;&gt; import rat.hig
    &gt;&gt;&gt; rat.hig.save_changes(["foo.bar", "foo"], title = "Save changes?")
    (['foo.bar'], -6)

There are also utility functions for calling dialogs, like warning messages::

    &gt;&gt;&gt; rat.hig.dialog_warn("Rat will simplify your code",
    ...                  "By putting common utilities in one place makes all "
    ...                  "benefit and get nicer apps.")
    -5

Sometimes you want to manipulate the dialog before running it::

    &gt;&gt;&gt; rat.hig.dialog_warn("Rat will simplify your code",
    ...                  "By putting common utilities in one place makes all "
    ...                  "benefit and get nicer apps.", run = False)
    &lt;gtk.Dialog object(GtkDialog) at 0xb73a19b4&gt;

"""
__license__ = "MIT &lt;http://www.opensource.org/licenses/mit-license.php&gt;"
__author__ = "Tiago Cogumbreiro &lt;cogumbreiro@users.sf.net&gt;"
__copyright__ = "Copyright 2005, Tiago Cogumbreiro"
__all__ =("HigProgress", "RunDialog", "SetupDialog", "SetupLabel",
           "SetupScrolledWindow", "WidgetCostumizer", "dialog_error",
           "dialog_ok_cancel", "dialog_warn", "dialog_alert", "humanize_seconds",
           "save_changes", "hig_alert")</t>
<t tx="ekr.20060521134315.1256">import gobject
import gtk
import datetime
from gettext import gettext as _
from gettext import ngettext as N_</t>
<t tx="ekr.20060521134315.1257">dialog_error = \
    lambda primary_text, secondary_text, **kwargs:\
        hig_alert(
            primary_text,
            secondary_text,
            stock = gtk.STOCK_DIALOG_ERROR,
            buttons =(gtk.STOCK_CLOSE, gtk.RESPONSE_OK),
            **kwargs
        )

dialog_warn = \
    lambda primary_text, secondary_text, **kwargs:\
        hig_alert(
            primary_text,
            secondary_text,
            stock = gtk.STOCK_DIALOG_WARNING,
            buttons =(gtk.STOCK_CLOSE, gtk.RESPONSE_OK),
            **kwargs
        )

dialog_ok_cancel = \
    lambda primary_text, secondary_text, ok_button=gtk.STOCK_OK, run=True, **kwargs: \
        hig_alert(
            primary_text,
            secondary_text,
            stock = gtk.STOCK_DIALOG_WARNING,
            buttons =(
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                ok_button, gtk.RESPONSE_OK
            ),
            **kwargs)

dialog_info = \
    lambda primary_text, secondary_text, **kwargs:\
        hig_alert(
            primary_text,
            secondary_text,
            stock = gtk.STOCK_DIALOG_INFO,
            buttons =(gtk.STOCK_CLOSE, gtk.RESPONSE_OK),
            **kwargs
        )</t>
<t tx="ekr.20060521134315.1258">class WidgetCostumizer:
    """
    The WidgetCostumizer is a class template for defining chaining of asseblies
    of interfaces. For example you can create a dialog with this simple lines of
    code::
    
        creator.bind(SetupDialog()).bind(SetupAlert(primary_text, secondary_text, **kwargs))
        dlg = creator()
    
    The costumization of a widget is like a pipeline of filters that act on a
    certain widget and on a toplevel container.
    
    """
	&lt;&lt; class WidgetCostumizer declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.1259">_to_attrs = True
_defaults = {}
_next_values = None
_next_iter = None

</t>
<t tx="ekr.20060521134315.1260">def __init__(self, *args, **kwargs):
    self._args  = args
    self._kwargs = dict(self._defaults)
    self._kwargs.update(kwargs)
    self._next_values = []
</t>
<t tx="ekr.20060521134315.1261">def _get_next(self):
    return self._next_iter.next()
</t>
<t tx="ekr.20060521134315.1262">def update(self, **kwargs):
    self._kwargs.update(kwargs)
</t>
<t tx="ekr.20060521134315.1263">def _run(self, *args, **kwargs):
    pass
</t>
<t tx="ekr.20060521134315.1264">def bind(self, *others):
    for other in others:
        if not isinstance(other, WidgetCostumizer):
            raise TypeError("unsupported operand type(s) for +: '%s' and '%s'" %(type(self), type(other)))
        
        self._next_values.append(other)

    return self
</t>
<t tx="ekr.20060521134315.1265">def _call(self, widget, container):
    if self._to_attrs:
        for key, value in self._kwargs.iteritems():
            setattr(self, key, value)
        
    widget, container = self._run(widget, container)
    
    for costum in self._next_values:
        widget, container = costum._call(widget, container)
    
    return widget, container
</t>
<t tx="ekr.20060521134315.1266">def __call__(self, widget = None, container = None):
    """This method is only called once"""
    return self._call(widget, container)[0]
</t>
<t tx="ekr.20060521134315.1267">
class SetupScrolledWindow(WidgetCostumizer):
	@others
</t>
<t tx="ekr.20060521134315.1268">def _run(self, scrolled, container):
    assert container is None

    if scrolled is None:
        scrolled = gtk.ScrolledWindow()
    
    scrolled.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
    return scrolled, None
</t>
<t tx="ekr.20060521134315.1269">        
class SetupLabel(WidgetCostumizer):
    """
    Usage::

        lbl = SetupLabel("&lt;b&gt;foo&lt;/b&gt;")(gtk.Label())
        lbl.show()
        
    Or::
    
        lbl = SetupLabel("&lt;b&gt;foo&lt;/b&gt;")()
        lbl.show()
    
    """
	@others
</t>
<t tx="ekr.20060521134315.1270">def _run(self, lbl, container):
    assert container is None
    assert len(self._args) == 0 or len(self._args) == 1
    
    if lbl is None:
        lbl = gtk.Label()
        
    lbl.set_alignment(0, 0)
    
    if len(self._args) == 1:
        lbl.set_markup(self._args[0])
        
    lbl.set_selectable(True)
    lbl.set_line_wrap(True)
    
    return lbl, container
</t>
<t tx="ekr.20060521134315.1271">def dialog_decorator(func):
    def wrapper(self, dialog, container):
        if container is None:
            container = dialog.get_child()
        return func(self, dialog, container)
        
    return wrapper
</t>
<t tx="ekr.20060521134315.1272">
class SetupDialog(WidgetCostumizer):
	@others
    
    _run = dialog_decorator(_run)</t>
<t tx="ekr.20060521134315.1273">def _run(self, dialog, container):
    dialog.set_border_width(4)
    dialog.set_has_separator(False)
    dialog.set_title("")
    dialog.set_resizable(False)

    align = gtk.Alignment()
    align.set_padding(
        padding_top = 0,
        padding_bottom = 7,
        padding_left = 0,
        padding_right = 0
    )
    align.set_border_width(5)
    align.show()
    container.add(align)
    
    return dialog, align
</t>
<t tx="ekr.20060521134315.1274">


class SetupAlert(WidgetCostumizer):
	@others

    _run = dialog_decorator(_run)</t>
<t tx="ekr.20060521134315.1275">class _PrimaryTextDecorator:
	@others
</t>
<t tx="ekr.20060521134315.1276">def __init__(self, label):
    self.label = label
</t>
<t tx="ekr.20060521134315.1277">def __call__(self, primary_text):
    self.label.set_markup('&lt;span weight="bold" size="larger"&gt;'+primary_text+'&lt;/span&gt;')
</t>
<t tx="ekr.20060521134315.1278">_defaults = {"title": "", "stock": gtk.STOCK_DIALOG_INFO}

def _setup(self, dialog, vbox):
    pass
</t>
<t tx="ekr.20060521134315.1279">def _run(self, dialog, container):
    primary_text, secondary_text = self._args

    dialog.set_title(self.title)

    hbox = gtk.HBox(spacing = 12)
    hbox.set_border_width(0)
    hbox.show()
    container.add(hbox)
    
    img = gtk.Image()
    img.set_from_stock(self.stock, gtk.ICON_SIZE_DIALOG)
    img.set_alignment(img.get_alignment()[0], 0.0)
    img.show()
    hbox.pack_start(img, False, False)
    
    vbox = gtk.VBox(spacing = 6)
    vbox.show()
    hbox.pack_start(vbox)
    
    
    lbl = SetupLabel('&lt;span weight="bold" size="larger"&gt;'+primary_text+'&lt;/span&gt;')()
    lbl.show()
    
    
    dialog.set_primary_text = self._PrimaryTextDecorator(lbl)
    
    vbox.pack_start(lbl, False, False)

    self._setup(dialog, vbox)
    
    lbl = SetupLabel(secondary_text)()
    lbl.show()
    dialog.set_secondary_text = lbl.set_text
    vbox.pack_end(lbl, False, False)
    
    return dialog, vbox
</t>
<t tx="ekr.20060521134315.1280">


class SetupListAlertTemplate(SetupAlert):
	@others
</t>
<t tx="ekr.20060521134315.1281">def get_list_title(self):
    raise NotImplementedError
</t>
<t tx="ekr.20060521134315.1282">def configure_widgets(self, dialog, tree):
    raise NotImplementedError
</t>
<t tx="ekr.20060521134315.1283">def create_store(self):
    raise NotImplementedError
</t>
<t tx="ekr.20060521134315.1284">def _setup(self, dialog, vbox):
    store = self.create_store()
    
    title = self.get_list_title()
    
    if title is not None:
        lbl = SetupLabel(title)()
        lbl.show()
        vbox.pack_start(lbl, False, False)
    
    tree = gtk.TreeView()
    tree.set_model(store)
    tree.set_headers_visible(False)

    tree.show()
    scroll = SetupScrolledWindow()()
    scroll.add(tree)
    scroll.show()
    
    vbox.add(scroll)

    self.configure_widgets(dialog, tree)

    return dialog, vbox
</t>
<t tx="ekr.20060521134315.1285">

class SetupFileListSaveAlert(SetupListAlertTemplate):
	@others
</t>
<t tx="ekr.20060521134315.1286">def on_toggle(self, render, path, args):
    dialog, model = args
    
    tree_iter = model.get_iter(path)
    row = model[tree_iter]
    row[0] = not row[0]
    
    if row[0]:
        model.enabled_rows += 1
    else:
        model.enabled_rows -= 1

    dialog.set_response_sensitive(gtk.RESPONSE_OK, model.enabled_rows &gt; 0)
</t>
<t tx="ekr.20060521134315.1287">def get_list_title(self):
    # To translators: %s is either 'documents' or some simillar word
    return _("Select the %s you want to save") % self._kwargs["documents"] + ":"
</t>
<t tx="ekr.20060521134315.1288">def configure_widgets(self, dialog, tree):
    store = tree.get_model()
    
    r = gtk.CellRendererToggle()
    r.connect("toggled", self.on_toggle,(dialog, store))
    col = gtk.TreeViewColumn("", r, active = 0)
    tree.append_column(col)

    r = gtk.CellRendererText()
    col = gtk.TreeViewColumn("", r, text = 1)
    tree.append_column(col)

    dialog.set_data("files_store", store)
    dialog.set_response_sensitive(gtk.RESPONSE_OK, False)
</t>
<t tx="ekr.20060521134315.1289">def create_store(self):
    store = gtk.ListStore(gobject.TYPE_BOOLEAN, gobject.TYPE_STRING)
    store.enabled_rows = 0
    for filename in self._kwargs["files"]:
        store.append((False, filename))
    return store
</t>
<t tx="ekr.20060521134315.1290">        
    


class SetupListAlert(SetupListAlertTemplate):
	@others
</t>
<t tx="ekr.20060521134315.1291">def get_list_title(self):
    return self._kwargs.get("list_title", None)
</t>
<t tx="ekr.20060521134315.1292">def configure_widgets(self, dialog, tree):
    r = gtk.CellRendererText()
    col = gtk.TreeViewColumn("", r, text = 0)
    tree.append_column(col)
</t>
<t tx="ekr.20060521134315.1293">def create_store(self):
    store = gtk.ListStore(gobject.TYPE_STRING)

    for filename in self._kwargs["items"]:
        store.append((filename,))

    return store
</t>
<t tx="ekr.20060521134315.1294">    



class RunDialog(WidgetCostumizer):
    """
    This is a terminal costumizer because it swaps the gtk.Dialog recieved by
    argument for its `gtk.Dialog.run`'s result.
    """
	@others
</t>
<t tx="ekr.20060521134315.1295">def _run(self, dialog, container):
    response = dialog.run()
    dialog.destroy()
    return response, None
</t>
<t tx="ekr.20060521134315.1296">def hig_alert(primary_text, secondary_text, parent = None, flags = 0, buttons =(gtk.STOCK_OK, gtk.RESPONSE_OK), run = True, _setup_alert = SetupAlert, **kwargs):
    if parent is None and "title" not in kwargs:
        raise TypeError("When you don't define a parent you must define a title") 
    dlg = gtk.Dialog(parent = parent, flags = flags, buttons = buttons)
    costumizer = SetupDialog()
    costumizer.bind(_setup_alert(primary_text, secondary_text, **kwargs))
    if run:
        costumizer.bind(RunDialog())
    return costumizer(dlg)
</t>
<t tx="ekr.20060521134315.1297">def humanize_seconds(elapsed_seconds, use_hours = True, use_days = True):
    """
    Turns a number of seconds into to a human readable string, example
    125 seconds is: '2 minutes and 5 seconds'.
    
    @param elapsed_seconds: number of seconds you want to humanize
    @param use_hours: wether or not to render the hours(if hours &gt; 0)
    @param use_days: wether or not to render the days(if days &gt; 0)
    """
    MIN_FRACTION = 60
    HOUR_FRACTION = 60 * MIN_FRACTION
    DAY_FRACTION = 24 * HOUR_FRACTION
    
    text = []
    
    duration = elapsed_seconds
    
    if duration == 0:
        return _("0 seconds")
    
    days = duration / DAYS_FRACTION
    if use_days and days &gt; 0:
        text.append(N_("%d day", "%d days", days) % days)
        duration %= DAY_FRACTION
        
    hours = duration / HOUR_FRACTION
    if use_hours and hours &gt; 0:
        text.append(N_("%d hour", "%d hours", hours) % hours)
        duration %= HOUR_FRACTION
    
    minutes = duration / MIN_FRACTION
    if minutes &gt; 0:
        text.append(N_("%d minute", "%d minutes", minutes) % minutes)
        duration %= MIN_FRACTION

    seconds = duration % 60
    if seconds &gt; 0:
        text.append(N_("%d second", "%d seconds", seconds) % seconds)
    
    if len(text) &gt; 2:
        # To translators: this joins 3 or more time fractions
        return _(", ").join(text[:-1]) + _(" and ") + text[-1]
    else:
        # To translators: this joins 2 or 1 time fractions
        return _(" and ").join(text)
</t>
<t tx="ekr.20060521134315.1298">
class _TimeUpdater:
	@others
</t>
<t tx="ekr.20060521134315.1299">def __init__(self, initial_time):
    self.initial_time = initial_time
</t>
<t tx="ekr.20060521134315.1300">def set_dialog(self, dialog):
    self.dialog = dialog
    self.dialog.connect("response", self.on_response)
    self.source = gobject.timeout_add(500, self.on_tick)
</t>
<t tx="ekr.20060521134315.1301">def on_response(self, *args):
    gobject.source_remove(self.source)
</t>
<t tx="ekr.20060521134315.1302">def get_text(self):
    last_changes = datetime.datetime.now() - self.initial_time
    # To translators %s is the time
    secondary_text = _("If you don't save, changes from the last %s "
                       "will be permanently lost.")
    return secondary_text % humanize_seconds(last_changes.seconds)
</t>
<t tx="ekr.20060521134315.1303">def on_tick(self):
    self.dialog.set_secondary_text(self.get_text())
    return True
</t>
<t tx="ekr.20060521134315.1304">def save_changes(files, last_save=None, parent=None, document=_("document"), documents=_("documents"), **kwargs):
    """
    Shows up a Save changes dialog to a certain list of documents and returns
    a tuple with two values, the first is a list of files that are to be saved
    the second is the value of the response, which can be one of:
      - gtk.RESPONSE_OK - the user wants to save
      - gtk.RESPONSE_CANCEL - the user canceled the dialog
      - gtk.RESPONSE_CLOSE - the user wants to close without saving
      - gtk.RESPONSE_DELETE_EVENT - the user closed the window
    
    So if you want to check if the user canceled just check if the response is
    equal to gtk.RESPONSE_CANCEL or gtk.RESPONSE_DELETE_EVENT
    
    When the `elapsed_time` argument is not `None` it should be a list of the
    elapsed time since each was modified. It must be in the same order of
    the `files` argument.
    
    This function also accepts every argument that a hig_alert function accepts,
    which means it accepts `title`, etc. Note that this function overrides
    the `run` argument and sets it to True, because it's not possible for a user
    to know which files were saved since the dialog changes is structure
    depending on the arguments.
    
    Simple usage example::
        files_to_save, response = save_changes(["foo.bar"])

    @param files: a list of filenames to be saved
    @param last_save: when you only want to save one file you can optionally
        send the date of when the user saved the file most recently.
        
    @type last_save: datetime.datetime
    @param parent: the window that will be parent of this window.
    @param document: the name of the document in the singular form. Default: 'document'
    @param documents: the name of the document in the plural form. Default: 'documents'

    @param kwargs: the remaining keyword arguments are the same as used on the function
        hig_alert.
    @return: a tuple with a list of entries the user chose to save and a gtk.RESPONSE_*
        from the dialog
    """
    # Override the `run` argument
    if "run" in kwargs:
        del kwargs["run"]
    
    if len(files) == 1:
        # To translators: the first %s is 'document'(or what the user 
        # provided), the second %s is the filename, you can change the
        # order of these
        primary_text = 'Save the changes to %(document)s "%(filename)s" before closing?'
        primary_text %= {"document": document, "filename": files[0]}
        
        if last_save is None:
            secondary_text = _("If you don't save, your changes will be "
                               "permanently lost.")
        else:
            updater = _TimeUpdater(last_save)
            secondary_text = updater.get_text()

        if "title" in kwargs:
            kwargs = {"title": kwargs["title"]}
            
        dialog = hig_alert(
            primary_text,
            secondary_text,
            parent = parent,
            stock = gtk.STOCK_DIALOG_WARNING,
            buttons =(
                _("Close without saving"), gtk.RESPONSE_CLOSE,
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_SAVE, gtk.RESPONSE_OK
            ),
            run = False,
            **kwargs
        )
        
        if last_save is not None:
            updater.set_dialog(dialog)
        
        response = dialog.run()
        dialog.destroy()

        if response == gtk.RESPONSE_OK:
            return files, response
        else:
            return(), response

    else:
        # To translators, '%(total)s' is the number of documents, %(documents)s
        # is the word 'documents' or something similar. You can change the
        # order of these wildcards.
        primary_text = _("There are %(total)s %(documents)s with unsaved " 
                         "changes. Save changes before closing?") %(
            {"total": len(files), "documents": documents}
        )
        secondary_text = _("If you don't save, all your changes will be "
                           "permanently lost.")

        dlg = hig_alert(
            primary_text,
            secondary_text,
            parent = parent,
            stock = gtk.STOCK_DIALOG_WARNING,
            buttons =(
                _("Close without saving"), gtk.RESPONSE_CLOSE,
                gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_SAVE, gtk.RESPONSE_OK
            ),
            run = False,
            files = files,
            documents = documents,
            _setup_alert = SetupFileListSaveAlert,
            **kwargs
        )

        response = dlg.run()
        dlg.destroy()
        store = dlg.get_data("files_store")
        if response == gtk.RESPONSE_CLOSE:
            files =()
        else:
            files = tuple(filename for save_file, filename in store if save_file)
        return files, response
</t>
<t tx="ekr.20060521134315.1305">def list_dialog(primary_text, secondary_text, parent=None, items=(), *args, **kwargs):
    return hig_alert(
        primary_text,
        secondary_text,
        parent = parent,
        _setup_alert = SetupListAlert,
        items = items,
        **kwargs
    )
</t>
<t tx="ekr.20060521134315.1306">
class HigProgress(gtk.Window):
    """
    HigProgress returns a window that contains a number of properties to
    access what a common Progress window should have.
    """
	@others
</t>
<t tx="ekr.20060521134315.1307">def __init__(self):
    gtk.Window.__init__(self, gtk.WINDOW_TOPLEVEL)
    
    self.set_border_width(6)
    self.set_resizable(False)
    self.set_title('')
    # defaults to center location
    self.set_position(gtk.WIN_POS_CENTER)
    self.connect("delete-event", self._on_close)
    
    # main container
    main = gtk.VBox(spacing = 12)
    main.set_spacing(12)
    main.set_border_width(6)
    main.show()
    self.add(main)
    
    # primary text
    alg = gtk.Alignment()
    alg.set_padding(0, 6, 0, 0)
    alg.show()
    main.pack_start(alg, False, False)
    lbl = SetupLabel()()
    lbl.set_selectable(False)
    lbl.show()
    self._primary_label = lbl
    alg.add(lbl)
    
    # secondary text
    lbl = SetupLabel()()
    lbl.set_selectable(False)
    lbl.show()
    main.pack_start(lbl, False, False)
    self._secondary_label = lbl
    
    # Progress bar
    vbox = gtk.VBox()
    vbox.show()
    main.pack_start(vbox, False, False)
    
    prog = gtk.ProgressBar()
    prog.show()
    self._progress_bar = prog
    vbox.pack_start(prog, expand = False)
    
    lbl = SetupLabel()()
    lbl.set_selectable(False)
    lbl.show()
    self._sub_progress_label = lbl
    vbox.pack_start(lbl, False, False)
    
    # Buttons box
    bbox = gtk.HButtonBox()
    bbox.set_layout(gtk.BUTTONBOX_END)
    bbox.show()
    
    # Cancel Button
    cancel = gtk.Button(gtk.STOCK_CANCEL)
    cancel.set_use_stock(True)
    cancel.show()
    self._cancel = cancel
    bbox.add(cancel)
    main.add(bbox)
    
    # Close button, which is hidden by default
    close = gtk.Button(gtk.STOCK_CLOSE)
    close.set_use_stock(True)
    close.hide()
    bbox.add(close)
    self._close = close
</t>
<t tx="ekr.20060521134315.1308">primary_label = property(lambda self: self._primary_label)
secondary_label = property(lambda self: self._secondary_label)
progress_bar = property(lambda self: self._progress_bar)
sub_progress_label = property(lambda self: self._sub_progress_label)
cancel_button = property(lambda self: self._cancel)
close_button = property(lambda self: self._close)

def set_primary_text(self, text):
    self.primary_label.set_markup('&lt;span weight="bold" size="larger"&gt;'+text+'&lt;/span&gt;')
    self.set_title(text)
</t>
<t tx="ekr.20060521134315.1309">primary_text = property(fset = set_primary_text)
    
def set_secondary_text(self, text):
    self.secondary_label.set_markup(text)
</t>
<t tx="ekr.20060521134315.1310">secondary_text = property(fset = set_secondary_text)

def set_progress_fraction(self, fraction):
    self.progress_bar.set_fraction(fraction)
</t>
<t tx="ekr.20060521134315.1311">def get_progress_fraction(self):
    return self.progress_bar.get_fraction()
</t>
<t tx="ekr.20060521134315.1312">progress_fraction = property(get_progress_fraction, set_progress_fraction)

def set_progress_text(self, text):
    self.progress_bar.set_text(text)
</t>
<t tx="ekr.20060521134315.1313">progress_text = property(fset = set_progress_text)

def set_sub_progress_text(self, text):
    self.sub_progress_label.set_markup('&lt;i&gt;'+text+'&lt;/i&gt;')
</t>
<t tx="ekr.20060521134315.1314">sub_progress_text = property(fset = set_sub_progress_text)

def _on_close(self, *args):
    if not self.cancel_button.get_property("sensitive"):
        return True
    # click on the cancel button
    self.cancel_button.clicked()
    # let the clicked event close the window if it likes too
    return True
</t>
<t tx="ekr.20060521134315.1315">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

import os
import gtk

@others

icons = Icons()</t>
<t tx="ekr.20060521134315.1316">def set_stock_icons(st_req, st_path):
    import pkg_resources as pr
    pidareq = pr.Requirement.parse(st_req)
    icon_names = pr.resource_listdir(pidareq, st_path)
    stock_ids = set(gtk.stock_list_ids())
    iconfactory = gtk.IconFactory()
    theme = gtk.icon_theme_get_default()
    listed = theme.list_icons()
    for icon in icon_names:
        if icon.startswith('.'):
            continue
        iconname = icon.split('.', 1)[0]
        if iconname not in listed:
            iconres = '/'.join(['icons', icon])
            iconpath = pr.resource_filename(pidareq, iconres)
            pixbuf = gtk.gdk.pixbuf_new_from_file(iconpath)
            iconset = gtk.IconSet(pixbuf)
            iconfactory.add(iconname, iconset)
            gtk.icon_theme_add_builtin_icon(iconname, 24, pixbuf)
    iconfactory.add_default()
    return theme, iconfactory
</t>
<t tx="ekr.20060521134315.1317">class Icons(object):
	@others
</t>
<t tx="ekr.20060521134315.1318">def __init__(self):
    return
    self.theme, self.iconfactory = set_stock_icons('pida', 'icons')
</t>
<t tx="ekr.20060521134315.1319">def get(self, name, size=16):
    return
    return self.theme.load_icon(name, size, 0)
</t>
<t tx="ekr.20060521134315.1320">@first # -*- coding: utf-8 -*-

"""
Module for providing Python-written Kiwi-enabled views and delegates.

Background:

Sometimes it is impractical to build a component with Glade, and the classes in
this module can be used to create and attach views written in pure python.
"""

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1321">import gtk


#from kiwi.proxies import Proxy
from kiwi.ui.delegates import Delegate, SlaveDelegate
from kiwi.ui.views import SlaveView, BaseView

</t>
<t tx="ekr.20060521134315.1322">class PythonViewMixin(object):
	@others
</t>
<t tx="ekr.20060521134315.1323">def __init__(self):
    # defeat class.widgets
    self.widgets = []
    self._proxied_widgets = set()
</t>
<t tx="ekr.20060521134315.1324">def create_toplevel_widget(self):
    """Override to create and return the top level container."""
    return gtk.VBox()
</t>
<t tx="ekr.20060521134315.1325">def add_widget(self, attribute, widget, model_attribute=None):
    """Name a widget and make it available to kiwi."""
    if model_attribute is not None:
        widget.set_property('model-attribute', model_attribute)
        self._proxied_widgets.add(attribute)
    setattr(self, attribute, widget)
    # needed to get over the class variable widgets
    self.widgets.append(attribute)
    return widget
</t>
<t tx="ekr.20060521134315.1326">def attach_slaves(self):
    """Override to insert post-initialisation slave attachment."""
</t>
<t tx="ekr.20060521134315.1327">def set_model(self, model):
    """Set the model and create a proxy."""
    self.python_model = model
    self.python_proxy = Proxy(self, model=model, widgets=self._proxied_widgets)
    self.model_changed(model)
</t>
<t tx="ekr.20060521134315.1328">def model_changed(self, model):
    pass
</t>
<t tx="ekr.20060521134315.1329">
class PythonSlaveDelegate(SlaveDelegate, PythonViewMixin):
	@others
</t>
<t tx="ekr.20060521134315.1330">def __init__(self, toplevel=None, **kw):
    PythonViewMixin.__init__(self)
    if toplevel is None:
        toplevel = self.create_toplevel_widget()
    SlaveDelegate.__init__(self, toplevel=toplevel, **kw)
    self.attach_slaves()
</t>
<t tx="ekr.20060521134315.1331">        
class PythonView(BaseView, PythonViewMixin):
	@others
</t>
<t tx="ekr.20060521134315.1332">def __init__(self, toplevel=None, *args, **kw):
    PythonViewMixin.__init__(self)
    if toplevel is None:
        toplevel = self.create_toplevel_widget()
    BaseView.__init__(self, toplevel=toplevel, *args, **kw)
</t>
<t tx="ekr.20060521134315.1333">
class PythonDelegate(Delegate, PythonViewMixin):
	@others
</t>
<t tx="ekr.20060521134315.1334">def __init__(self, toplevel=None, **kw):
    PythonViewMixin.__init__(self)
    if toplevel is None:
        toplevel = self.create_toplevel_widget()
    Delegate.__init__(self, toplevel=toplevel, **kw)
    self.attach_slaves()
</t>
<t tx="ekr.20060521134315.1335">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others

if __name__ == '__main__':
    gtk.threads_init()
    main()</t>
<t tx="ekr.20060521134315.1336"># Main entry point into application so check sanity
import sanity
del sanity

import os
import sys

import gtk
import gobject, threading

import debugsession
from console import Console
from mainwindow import MainWindow
#from sourceviewer import SourceViewer
from toolbar import Toolbar, StatusBar
from threadviewer import ThreadsViewer
from breakpointviewer import BreakpointViewer
from namespaceviewer import AllNamespaceViewer, LocalsViewer, GlobalsViewer
from stackviewer import StackViewer, StackItem


</t>
<t tx="ekr.20060521134315.1337">class Application(object):
	@others
</t>
<t tx="ekr.20060521134315.1338">def __init__(self, viewfactory, options):
    self.options = options
    self.main_window = viewfactory(self)
    self.session_manager = debugsession.SessionManager(self)
    self.console = Console(self)
    self.main_window.console = self.console
    self.stack = StackViewer(self)
    #self.namespace = AllNamespaceViewer(self)
    self.threads = ThreadsViewer(self)
    #self.source = SourceViewer(self)
    self.globals = GlobalsViewer(self)
    self.locals = LocalsViewer(self)
    self.status = StatusBar(self)
    self.breaks = BreakpointViewer(self)
    self.toolbar = Toolbar(self)
    debugsession.connect_events(self)
</t>
<t tx="ekr.20060521134315.1339">def launch(self, filename):
    def _l(filename):
        import threading
        if filename is not None:
            def _t():
                self.session_manager.launch(True, filename)
            t = threading.Thread(target=_t)
            t.start()
    _l(filename)
</t>
<t tx="ekr.20060521134315.1340">    #gobject.idle_add(_l, filename)

def update_threads(self, event):
    current_thread = event.m_current_thread
    threads_list = event.m_thread_list
    def _u(threads_list, current_thread):
        self.threads.update_threads(threads_list, current_thread)
    gobject.idle_add(_u, threads_list, current_thread)
</t>
<t tx="ekr.20060521134315.1341">def update_thread_broken(self, event):
    tid = event.m_tid
    def _u(tid):
        self.threads.broken_thread(tid)
    gobject.idle_add(_u, tid)
</t>
<t tx="ekr.20060521134315.1342">def update_no_threads(self, event):
    print 'nothreads'
</t>
<t tx="ekr.20060521134315.1343">def update_state(self, event):
    state = event.m_state
    def _u(state):
        self.status.update_running_status(state)
    def _u2(state):
        self.toolbar.update_state(state)
    def _u3(state):
        self.master.update_state(state)
    gobject.idle_add(_u, state)
    gobject.idle_add(_u2, state)
    gobject.idle_add(_u3, state)
</t>
<t tx="ekr.20060521134315.1344">def update_frame(self, event):
    index = event.m_frame_index
    def _u(index):
        self.stack.select_frame(index)
    gobject.idle_add(_u, index)
    self.update_source(-index - 1)
</t>
<t tx="ekr.20060521134315.1345">def update_stack(self, event):
    stack = event.m_stack
    self._last_stack = stack
    def _u(stack):
        self.stack.update_stack(stack)
    gobject.idle_add(_u, stack)
    self.update_source(-1)
</t>
<t tx="ekr.20060521134315.1346">def update_source(self, index):
    def _u(index):
        si =StackItem(index, *self._last_stack['stack'][index])
        self.source_goto(si.filename, si.linenumber)
    gobject.idle_add(_u, index)
</t>
<t tx="ekr.20060521134315.1347">def update_namespace(self, event):
    def _u():
        self.locals.update_namespace()
        self.globals.update_namespace()
    gobject.idle_add(_u)
</t>
<t tx="ekr.20060521134315.1348">def update_bp(self, event):
    def _u(event):
        act = event.m_action
        if event.m_bp is not None:
            filename = event.m_bp.m_filename
            linenumber = event.m_bp.m_lineno
            index = event.m_bp.m_id
            indices = None
        else:
            filename = None
            linenumber = None
            index = None
            indices = event.m_id_list
        self.breaks.update_bp(act, index, indices, filename, linenumber)
        self.master.update_bp(act, index, indices, filename, linenumber)
    gobject.idle_add(_u, event)
</t>
<t tx="ekr.20060521134315.1349">def start(*args):
    options = debugsession.start(*args)
    app = Application(MainWindow, options)
    app.console.start()
    app.main_window.show_all()
    if sys.argv[1:]:
        fn = sys.argv[-1]
        if os.path.exists(fn):
            app.launch(fn)
    gtk.main()
</t>
<t tx="ekr.20060521134315.1350">def embed(parent, viewfactory, filename=None):
    def start_embedded(*args):
        options = debugsession.start(*args)
        app = Application(viewfactory, options)
        app.console.start()
        app.main_window.show_all()
        parent.app = app
        if filename:
            fn = filename
            if os.path.exists(fn):
                app.launch(fn)
    return debugsession.main(start_embedded)
</t>
<t tx="ekr.20060521134315.1351">def main():
    debugsession.main(start)
</t>
<t tx="ekr.20060521134315.1352">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1353">import gtk

from kiwiviews import PythonDelegate
from icons import icons


</t>
<t tx="ekr.20060521134315.1354">class NiceNotebook(gtk.Notebook):
	@others
</t>
<t tx="ekr.20060521134315.1355">def __init__(self):
    super(NiceNotebook, self).__init__()
    self.set_property('homogeneous', True)
</t>
<t tx="ekr.20060521134315.1356">def pack_container(mw, self):
    vbmain = gtk.VBox(spacing=6)
    tbh = self.add_widget('toolbar_holder', gtk.EventBox())
    vbmain.pack_start(tbh, expand=False)
    mw.add(vbmain)
    pb = NiceNotebook()
    vbmain.pack_start(pb)
    sh = self.add_widget('stack_holder', gtk.EventBox())
    pb.append_page(sh, tab_label=gtk.Label('Stack Viewer'))
    bh = self.add_widget('breaks_holder', gtk.EventBox())
    pb.append_page(bh, tab_label=gtk.Label('Breakpoints'))
    tv = self.add_widget('threads_holder', gtk.EventBox())
    pb.append_page(tv, tab_label=gtk.Label('Threads'))
    lv = self.add_widget('locals_holder', gtk.EventBox())
    pb.append_page(lv, tab_label=gtk.Label('locals'))
    gv = self.add_widget('globals_holder', gtk.EventBox())
    pb.append_page(gv, tab_label=gtk.Label('globals'))
    th = self.add_widget('term_holder', gtk.EventBox())
    pb.append_page(th, tab_label=gtk.Label('Console'))
    oh = self.add_widget('outterm_holder', gtk.EventBox())
    pb.append_page(oh, tab_label=gtk.Label('Output'))
    ehb = gtk.HBox(spacing=6)
    l = gtk.Label()
    l.set_markup('&lt;big&gt;&lt;b&gt;&lt;tt&gt;&amp;gt;&amp;gt;&lt;/tt&gt;&lt;/b&gt;&lt;/big&gt;')
    ehb.pack_start(l, expand=False)
    ce = self.add_widget('command', gtk.Entry())
    ehb.pack_start(ce)
    vbmain.pack_start(ehb, expand=False)
    sbh = self.add_widget('statusbar_holder', gtk.EventBox())
    vbmain.pack_start(sbh, expand=False)
</t>
<t tx="ekr.20060521134315.1357">    
class MainWindow(PythonDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1358">def __init__(self, parent, *args, **kw):
    self._parent = parent
    PythonDelegate.__init__(self, *args, **kw)
</t>
<t tx="ekr.20060521134315.1359">def create_toplevel_widget(self):
    mw = self.add_widget('window', gtk.Window())
    mw.resize(800, 600)
    icon = icons.get(gtk.STOCK_EXECUTE)
    mw.set_icon(icon)
    pack_container(mw, self)
    return mw
</t>
<t tx="ekr.20060521134315.1360">def on_window__delete_event(self, window, event):
    gtk.main_quit()
</t>
<t tx="ekr.20060521134315.1361">def on_command__activate(self, entry):
    self.console.received_line(entry.get_text())
    entry.set_text('')
</t>
<t tx="ekr.20060521134315.1362">def attach_slaves(self):
    self.command.grab_focus()
</t>
<t tx="ekr.20060521134315.1363">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1364">import gtk

import cgi

from components import PGDSlaveDelegate
from mainwindow import NiceNotebook
from tree import IconTree
from icons import icons
</t>
<t tx="ekr.20060521134315.1365">type_icons = {
    'str': icons.get('nsstring', 16),
    'type': icons.get('nsclass', 16),
    'other': icons.get('nsother', 16),
    'int': icons.get('nsint', 16),
    'float': icons.get('nsfloat', 16),
    'list': icons.get('nslist', 16),
    'tuple': icons.get('nstuple', 16),
    'dict': icons.get('nsdict', 16),
    'NoneType': icons.get('nsnone', 16),
    'module': icons.get('nsmodule', 16),
    'bool': icons.get('nsbool', 16),
    'builtin_function_or_method': icons.get('nsfunc', 16),
    'function': icons.get('nsfunc', 16)
    }

nochildren = ['NoneType', 'str', 'int', 'float', 'long', 'bool']
            
reprable = nochildren + ['dict', 'list', 'tuple']</t>
<t tx="ekr.20060521134315.1366">def get_pixbuf(nstype):
    if nstype not in type_icons:
        nstype = 'other'
    return type_icons[nstype]
</t>
<t tx="ekr.20060521134315.1367">
class NamespaceItem(object):
	@others
    pixbuf = property(get_pixbuf)</t>
<t tx="ekr.20060521134315.1368">def __init__(self, nsdict):
    self.name = nsdict['name']
    self.stype = nsdict['type']
    self.srepr = nsdict['repr']
    self.expr = nsdict['expr']
    self.n_subnodes = nsdict['n_subnodes']
    self.key = self.name
    self.is_value = False
</t>
<t tx="ekr.20060521134315.1369">def get_markup(self):
    if self.is_value:
        self.name = '.'
        mu = cgi.escape(self.srepr)
    else:
        n = cgi.escape(self.name)
        t = cgi.escape(self.stype)
        mu = ('&lt;tt&gt;&lt;b&gt;%s&lt;/b&gt;  &lt;/tt&gt;'
              '&lt;span color="#903030"&gt;&lt;i&gt;&lt;small&gt;%s&lt;/small&gt;&lt;/i&gt;&lt;/span&gt;'
              % (n, t))
        if self.stype in reprable:
            v = '&lt;tt&gt; %s&lt;/tt&gt;' % cgi.escape(self.srepr)
            mu = ''.join([mu, v])
    return mu
</t>
<t tx="ekr.20060521134315.1370">markup = property(get_markup)

def get_pixbuf(self):
    if self.is_value:
        return None
    return get_pixbuf(self.stype)
</t>
<t tx="ekr.20060521134315.1371">

class NamespaceTree(IconTree):
	&lt;&lt; class NamespaceTree declarations &gt;&gt;
</t>
<t tx="ekr.20060521134315.1372">SORT_CONTROLS = True
SORT_AVAILABLE = [('Name', 'name'),
                  ('Type', 'stype')]


</t>
<t tx="ekr.20060521134315.1373">class NamespaceViewer(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1374">def create_toplevel_widget(self):
    toplevel = gtk.VBox()
    t = self.add_widget('tree', NamespaceTree())
    t.set_property('markup-format-string', '%(markup)s')
    toplevel.pack_start(t)
    v = self.add_widget('tree_view', t.view)
    return toplevel
</t>
<t tx="ekr.20060521134315.1375">def update_namespace(self, expr=None, parent=None):
    if expr is None:
        expr = self.get_root_expr()
        parent = None
        self.tree.clear()
    el = [(expr, True)]
    filt = None
    ns = self.session_manager.get_namespace(el, filt)
    for sn in ns[0]['subnodes']:
        item = NamespaceItem(sn)
        piter = self.tree.add_item(item, parent=parent)
        if item.stype not in nochildren:
            valitem = NamespaceItem(sn)
            valitem.is_value = True
            self.tree.add_item(valitem, parent=piter)
</t>
<t tx="ekr.20060521134315.1376">def on_tree_view__row_expanded(self, tv, titer, path):
    value = self.tree.get(titer, 1).value
    if self.tree.model.iter_n_children(titer) == 1:
        self.update_namespace(value.expr, titer)
</t>
<t tx="ekr.20060521134315.1377">def get_root_expr(self):
    raise NotImplementedError
</t>
<t tx="ekr.20060521134315.1378">

class GlobalsViewer(NamespaceViewer):
	@others
</t>
<t tx="ekr.20060521134315.1379">def get_root_expr(self):
    return 'globals()'
</t>
<t tx="ekr.20060521134315.1380">def attach_slaves(self):
    self.main_window.attach_slave('globals_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1381">

class LocalsViewer(NamespaceViewer):
	@others
</t>
<t tx="ekr.20060521134315.1382">def get_root_expr(self):
    return 'locals()'
</t>
<t tx="ekr.20060521134315.1383">def attach_slaves(self):
    self.main_window.attach_slave('locals_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1384">

class AllNamespaceViewer(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1385">def create_toplevel_widget(self):
    #self.local_viewer = LocalViewer(self.app)
    #self.global_viewer = GlobalViewer(self.app)
    tl = gtk.VBox()
    nb = NiceNotebook()
    tl.pack_start(nb)
    nb.set_tab_pos(gtk.POS_TOP)
    lh = self.add_widget('globals_holder', gtk.EventBox())
    tl1 = self._create_big_label('globals()')
    nb.append_page(lh, tab_label=tl1)
    gh = self.add_widget('locals_holder', gtk.EventBox())
    tl2 = self._create_big_label('locals()')
    nb.append_page(gh, tab_label=tl2)
    return tl
</t>
<t tx="ekr.20060521134315.1386">def _create_big_label(self, text):
    l = gtk.Label(text)
    return l
</t>
<t tx="ekr.20060521134315.1387">def attach_slaves(self):
    #self.attach_slave('globals_holder', self.global_viewer)
    #self.attach_slave('locals_holder', self.local_viewer)
    #self.main_window.attach_slave('ns_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1388">def update_namespace(self):
    self.local_viewer.update_namespace()
    self.global_viewer.update_namespace()
</t>
<t tx="ekr.20060521134315.1389">@first # -*- coding: utf-8 -*-

"""
Sanity checking for PGD

This module checks for required components, and fails with a message when they
are missing. We have identified as required components:

 * PyGTK
 * Setuptools
 * Kiwi
"""

&lt;&lt; imports &gt;&gt;

@language python
@tabwidth -4

@others
</t>
<t tx="ekr.20060521134315.1390">import sys

# PyGTK
try:
    import gtk
    import gobject
    # this maybe should be somewhere else
    gtk.threads_init()
except ImportError, e:
    msg = 'Missing Dependency: PyGTK'
    msg2 = ('PyGTK 2.6 is required to run pgd. '
           'Please visit http://www.pygtk.org/.')
    console_exit(msg, msg2, e)


# Setuptools
try:
    import setuptools
    del setuptools
except ImportError, e:
    msg = 'Setuptools missing'
    msg2 = 'Setuptools is required to run pgd.'
    url = 'http://peak.telecommunity.com/DevCenter/setuptools'
    gui_exit(msg, msg2, url, e)


# Kiwi
try:
    import kiwi
    del kiwi
except ImportError, e:
    msg = 'Kiwi missing'
    msg2 = 'Kiwi is required to run pgd.'
    url = 'http://kiwi.async.br/'
    gui_exit(msg, msg2, url, e)


#GTKSourceView
try:
    from gtksourceview import SourceView
    del SourceView
except ImportError, e:
    msg = 'GTKSourceView missing'
    msg2 = 'GTKSourceView is required to view source code'
    url = 'http://ftp.gnome.org/pub/GNOME/sources/gnome-python-desktop/'
    #gui_exit(msg, msg2, url, e)


#VTE
try:
    from vte import Terminal
    del Terminal
except ImportError, e:
    msg = 'VTE missing'
    msg2 = 'The V Terminal Emulator (VTE) widget is required.'
    url = ('Please install it.\n\n'
           'FreeBSD users: unlucky, your port maintainer '
           'has hardcoded the Makefile '
           'to not make the python bindings. You can do it yourselves '
           'rather easily with a little sniff around.')
    gui_exit(msg, msg2, url, e)</t>
<t tx="ekr.20060521134315.1391">def console_exit(msg, msg2='', e=None):
    """
    Exit with a message then raise any exception that called us.
    """
    sys.stderr.write('FATAL: %s\n%s\n' % (msg, msg2))
    if e is not None:
        raise e
    sys.exit(1)
</t>
<t tx="ekr.20060521134315.1392">def gui_exit(msg, msg2, url='', e=None):
    """
    Exit with a GUI message then raise any exception that called us.
    """
    import hig
    d = hig.dialog_error(
            title='Python Graphical Debugger',
            primary_text=msg,
            secondary_text=('&lt;span color="#903030"&gt;&lt;i&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/i&gt;&lt;/span&gt;'
                            '\n\n%s' % (msg2, url))
        )
    console_exit(msg, msg2, e)
</t>
<t tx="ekr.20060521134315.1393">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others

</t>
<t tx="ekr.20060521134315.1394">import gtk
import pango
import gobject

from gtksourceview import SourceView
from gtksourceview import SourceBuffer
from gtksourceview import SourceLanguagesManager

from icons import icons
from components import PGDSlaveDelegate


</t>
<t tx="ekr.20060521134315.1395">class SVBuffer(SourceBuffer):
	@others
</t>
<t tx="ekr.20060521134315.1396">def __init__(self, filename, encoding='utf-8'):
    SourceBuffer.__init__(self)
    self.filename = filename
    self.encoding = encoding
    lm = SourceLanguagesManager()
    self.languages_manager = lm
    language = lm.get_language_from_mime_type("text/x-python")
    self.set_highlight(True)
    self.set_language(language)
</t>
<t tx="ekr.20060521134315.1397">def load_from_file(self):
    """
    Loads the contents of a file to this buffer.
    """
    fd = open(self.filename)
    try:
        self.begin_not_undoable_action()
        self.set_text("")
        data = fd.read()
        data = unicode(data, self.encoding)
        self.set_text(data)
        self.set_modified(False)
        self.place_cursor(self.get_start_iter())
        self.end_not_undoable_action()
    finally:
        fd.close()
</t>
<t tx="ekr.20060521134315.1398">

class SVView(SourceView):
	@others
</t>
<t tx="ekr.20060521134315.1399">def __init__(self, parent, filename):
    buf = SVBuffer(filename)
    SourceView.__init__(self, buf)
    self.cb = parent
    self.add_events(gtk.gdk.BUTTON_PRESS_MASK)
    self.connect('button-press-event', self.on_bp_event)
    self.set_auto_indent(True)
    self.set_show_line_numbers(True)
    self.set_show_line_markers(True)
    self.set_tabs_width(4)
    self.set_margin(80)
    self.set_show_margin(True)
    self.set_smart_home_end(True)
    self.set_highlight_current_line(True)
    self.set_insert_spaces_instead_of_tabs(True)
    self.set_marker_pixbuf('bp', icons.get('stock_breakpoint'))
    self.set_font('Monospace 9')
    buf.load_from_file()
</t>
<t tx="ekr.20060521134315.1400">def on_bp_event(self, view, event):
    buf = self.get_buffer()
    if event.window is self.get_window(gtk.TEXT_WINDOW_LEFT):
        bc = self.window_to_buffer_coords(gtk.TEXT_WINDOW_LEFT,
             event.x, event.y)
        titer, height = self.get_line_at_y(bc[1])
        eiter = titer.copy()
        eiter.forward_to_line_end()
        marks = buf.get_markers_in_region(titer, eiter)
        linenumber = titer.get_line() + 1
        filename = buf.filename
        if len(marks):
            index = int(marks[0].get_name())
            self.cb.session_manager.delete_breakpoint([index], False)
        else:
            self.cb.session_manager.set_breakpoint(filename, '', linenumber,
                                               True, '')
</t>
<t tx="ekr.20060521134315.1401">def set_breakpoint(self, index, titer):
    buf = self.get_buffer()
    buf.create_marker(str(index), 'bp', titer)
</t>
<t tx="ekr.20060521134315.1402">def set_background_color(self, color):
    self.modify_base(gtk.STATE_NORMAL, color)
</t>
<t tx="ekr.20060521134315.1403">def set_font_color(self, color):
    self.modify_text(gtk.STATE_NORMAL, color)
</t>
<t tx="ekr.20060521134315.1404">def set_font(self, fontstring):
    font_desc = pango.FontDescription(fontstring)
    if font_desc is not None:
        self.modify_font(font_desc)
</t>
<t tx="ekr.20060521134315.1405">    

class SourceViewer(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1406">def create_toplevel_widget(self):
    self._files = {}
    nb = self.add_widget('notebook', gtk.Notebook())
    nb.set_show_tabs(False)
    return nb
</t>
<t tx="ekr.20060521134315.1407">def attach_slaves(self):
    self.main_window.attach_slave('source_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1408">def goto(self, filename, linenumber):
    def _v(editor, linenumber):
        self._goto_line(editor, linenumber)
    if filename in self._files:
        def _u(filename, linenumber):
            editor, vbox = self._files[filename]
            self.notebook.set_current_page(self.notebook.page_num(vbox))
            gobject.idle_add(_v, editor, linenumber)
    else:
        def _u(filename, linenumber):
            editor, vbox = self._open_file(filename)
            self._files[filename] = (editor, vbox)
            self.notebook.set_current_page(self.notebook.page_num(vbox))
            gobject.idle_add(_v, editor, linenumber)
    gobject.idle_add(_u, filename, linenumber)
</t>
<t tx="ekr.20060521134315.1409">def _open_file(self, filename):
    vbox, editor = self.create_widget(filename)
    self.notebook.append_page(vbox)
    return editor, vbox
</t>
<t tx="ekr.20060521134315.1410">def create_widget(self, filename):
    vbox = gtk.VBox(spacing=12)
    vbox.show()
    scroller = gtk.ScrolledWindow()
    scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
    scroller.show()
    vbox.add(scroller)
    editor = SVView(self, filename)
    editor.set_name("editor")
    editor.show()
    scroller.add(editor)
    return vbox, editor
</t>
<t tx="ekr.20060521134315.1411">def set_breakpoint(self, index, filename, linenumber):
    self.goto(filename, linenumber)
    def _u(index, filename, linenumber):
        editor, vbox = self._files[filename]
        buf = editor.get_buffer()
        titer = buf.get_iter_at_line(linenumber - 1)
        editor.set_breakpoint(index, titer)
    gobject.idle_add(_u, index, filename, linenumber)
</t>
<t tx="ekr.20060521134315.1412">def remove_breakpoint(self, index, filename):
    if filename in self._files:
        editor, vbox = self._files[filename]
        buf = editor.get_buffer()
        buf.delete_marker(buf.get_marker(str(index)))
</t>
<t tx="ekr.20060521134315.1413">def _goto_line(self, editor, linenumber):
    view = editor
    buff = editor.get_buffer()
    # Get line iterator
    line_iter = buff.get_iter_at_line(linenumber - 1)
    # Move scroll to the line iterator
    view.scroll_to_iter(line_iter, 0.25)
    # Place the cursor at the begining of the line
    buff.place_cursor(line_iter)
</t>
<t tx="ekr.20060521134315.1414">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1415">import os

import gtk

from components import PGDSlaveDelegate

from tree import Tree
from icons import icons

</t>
<t tx="ekr.20060521134315.1416">class StackItem(object):
	@others

    pixbuf = property(get_icon)</t>
<t tx="ekr.20060521134315.1417">def __init__(self, index, filename, linenumber, function, line):
    self.key = index
    self.filename = filename
    self.basename = os.path.basename(filename)
    self.dirname = os.path.dirname(filename)
    self.linenumber = linenumber
    self.funcion = function
    self.line = line
    self.active=False
</t>
<t tx="ekr.20060521134315.1418">def get_color(self):
    if self.active:
        return '#000000'
    else:
        return '#909090'
</t>
<t tx="ekr.20060521134315.1419">color = property(get_color)

def get_icon(self):
    if self.active:
        return None#icons.get(gtk.STOCK_EXECUTE, 16)
    else:
        return None
</t>
<t tx="ekr.20060521134315.1420">


class StackViewer(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1421">def create_toplevel_widget(self):
    toplevel = gtk.VBox()
    t = self.add_widget('tree', Tree())
    t.set_property('markup-format-string',
                   '&lt;span color="%(color)s"&gt;'
                   '&lt;b&gt;%(basename)s:%(linenumber)s&lt;/b&gt; '
                   '&lt;i&gt;&lt;small&gt;%(dirname)s&lt;/small&gt;&lt;/i&gt;\n'
                   '&lt;tt&gt;%(line)s&lt;/tt&gt;&lt;/span&gt;')
    t.view.set_expander_column(t.view.get_column(1))
    toplevel.pack_start(t)
    return toplevel
</t>
<t tx="ekr.20060521134315.1422">def attach_slaves(self):
    self.main_window.attach_slave('stack_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1423">def update_stack(self, stack):
    self._current_tid = stack['current tid']
    self.tree.clear()
    for i, row in enumerate(stack['stack'][::-1][:-2]):
        fn, ln, fc, tl = row
        stack_item = StackItem(i, fn, ln, fc, tl)
        if i == 0:
            stack_item.active = True
        self.tree.add_item(stack_item)
</t>
<t tx="ekr.20060521134315.1424">def select_frame(self, index):
    for i, row in enumerate(self.tree.model):
        val = row[1].value
        val.active = (i == index)
        val.reset_markup()
</t>
<t tx="ekr.20060521134315.1425">def on_tree__double_clicked(self, tv, item):
    index = item.key
    self.session_manager.set_frame_index(index)
</t>
<t tx="ekr.20060521134315.1426">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1427">import gtk
import gobject

from components import PGDSlaveDelegate


</t>
<t tx="ekr.20060521134315.1428">class Toolbar(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1429">def _create_uim(self):
    self.uim = gtk.UIManager()
    self.action_group = gtk.ActionGroup('main')
    self.uim.insert_action_group(self.action_group, 0)
    self.action_group.add_actions([
        ('Step', 'dbgstep', 'Step', '&lt;Ctrl&gt;s',
         'Step the debugger', self.on_step),
        ('Go', gtk.STOCK_MEDIA_PLAY, 'Go', '&lt;Ctrl&gt;g',
         'Continue the debugger until it breaks.', self.on_go),
        ('Return', 'dbgstepout', 'Return', '&lt;Ctrl&gt;r',
        'Return', self.on_return),
        ('Break', gtk.STOCK_MEDIA_PAUSE, 'Break', '&lt;Ctrl&gt;x',
        'Break', self.on_break),
        ('Next', 'dbgnext', 'Next', '&lt;ctrl&gt;n',
         'Next', self.on_next),
         ('Launch', gtk.STOCK_OPEN, 'Launch', '&lt;ctrl&gt;o',
          'Launch a script in the debugger', self.on_launch),
        ('Stop', gtk.STOCK_STOP, 'Stop', '&lt;ctrl&gt;c',
         'Stop the execution', self.on_stop),
        ('Reload', gtk.STOCK_REFRESH, 'Reload', '&lt;ctrl&gt;r',
         'Reload the current file', self.on_reload),
        ('LaunchMenu', None, 'Execute', None, None, None),
        ('ControlMenu', None, 'Control', None, None, None),
        ])
    ui = """
            &lt;menubar&gt;
                &lt;menu action="LaunchMenu"&gt;
                    &lt;menuitem action="Launch" /&gt;
                    &lt;menuitem action="Reload" /&gt;
                    &lt;menuitem action="Stop" /&gt;
                &lt;/menu&gt;
                &lt;menu action="ControlMenu"&gt;
                    &lt;menuitem action="Step" /&gt;
                    &lt;menuitem action="Next" /&gt;
                    &lt;menuitem action="Return" /&gt;
                    &lt;separator /&gt;
                    &lt;menuitem action="Go" /&gt;
                    &lt;menuitem action="Break" /&gt;
                    
                &lt;/menu&gt;
            &lt;/menubar&gt;
            &lt;toolbar&gt;
                &lt;toolitem action="Launch" /&gt;
                &lt;toolitem action="Reload" /&gt;
                &lt;toolitem action="Stop" /&gt;
                &lt;separator /&gt;
                &lt;toolitem action="Go" /&gt;
                &lt;toolitem action="Break" /&gt;
                &lt;separator /&gt;
                &lt;toolitem action="Step" /&gt;
                &lt;toolitem action="Next" /&gt;
                &lt;toolitem action="Return" /&gt;
            &lt;/toolbar&gt;
         """
    self.uim.add_ui_from_string(ui)
    self.update_state('detached')
</t>
<t tx="ekr.20060521134315.1430">    #self.main_window.window.add_accel_group(self.uim.get_accel_group())

def update_state(self, state):
    smap = {
        'broken': ['Step', 'Next', 'Return', 'Go', 'Stop'],
        'running': ['Stop', 'Break'],
        'detached': ['Launch', 'Reload'],
        'spawning': [],
        }
    for act in self.action_group.list_actions():
        if state in smap:
            if (act.get_name() in smap[state] or
                act.get_name().endswith('Menu')):
                act.set_sensitive(True)
            else:
                act.set_sensitive(False)
</t>
<t tx="ekr.20060521134315.1431">def on_reload(self, action):
    si = self.session_manager._CSessionManager__smi.m_server_info
    if si:
        filename = si.m_filename
        self.session_manager.launch_filename(filename)
</t>
<t tx="ekr.20060521134315.1432">def on_step(self, action):
    self.session_manager.request_step()
</t>
<t tx="ekr.20060521134315.1433">def on_go(self, action):
    self.session_manager.request_go()
</t>
<t tx="ekr.20060521134315.1434">def on_return(self, action):
    self.session_manager.request_return()
</t>
<t tx="ekr.20060521134315.1435">def on_break(self, action):
    
    def _break():
        self.session_manager.request_break()
    import threading
    threading.Thread(target=_break).start()
</t>
<t tx="ekr.20060521134315.1436">def on_next(self, action):
    self.session_manager.request_next()
</t>
<t tx="ekr.20060521134315.1437">def on_launch(self, action):
    dlg = gtk.FileChooserDialog(parent=self.main_window.window,
                                title='Select script to launch',
                                buttons=(gtk.STOCK_CANCEL,
                                         gtk.RESPONSE_REJECT,
                                         gtk.STOCK_OK,
                                         gtk.RESPONSE_ACCEPT,
                                         ))
    dlg.set_action(gtk.FILE_CHOOSER_ACTION_OPEN)
    filename = None
    response = dlg.run()
    if response == gtk.RESPONSE_ACCEPT:
        filename = dlg.get_filename()
        self.session_manager.launch_filename(filename)
    dlg.destroy()
</t>
<t tx="ekr.20060521134315.1438">def on_stop(self, action):
    def _s():
        self.session_manager.save_breakpoints()
        self.session_manager.stop_debuggee()
    gobject.idle_add(_s)
</t>
<t tx="ekr.20060521134315.1439">def create_toplevel_widget(self):
    self._create_uim()
    vb = gtk.HBox()
    mb = self.uim.get_widget('/menubar')
    vb.pack_start(mb)
    tb = self.uim.get_widget('/toolbar')
    tb.set_style(gtk.TOOLBAR_ICONS)
    tb.set_icon_size(gtk.ICON_SIZE_MENU)
    vb.pack_start(tb)
    return vb
</t>
<t tx="ekr.20060521134315.1440">def attach_slaves(self):
    #self.main_window.attach_slave('toolbar_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1441">

class StatusBar(PGDSlaveDelegate):
	@others
</t>
<t tx="ekr.20060521134315.1442">def create_toplevel_widget(self):
    sb = self.add_widget('statusbar', gtk.Statusbar())
    self.running_id = sb.get_context_id('running')
    return sb
</t>
<t tx="ekr.20060521134315.1443">def attach_slaves(self):
    self.main_window.attach_slave('statusbar_holder', self)
</t>
<t tx="ekr.20060521134315.1444">def update_running_status(self, msg):
    self.statusbar.push(self.running_id, 'STATE: %s' % msg)
</t>
<t tx="ekr.20060521134315.1445">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1446"># gtk import(s)
import gtk
import gobject

from kiwi.utils import gsignal, gproperty


</t>
<t tx="ekr.20060521134315.1447">class TreeItem(object):
    """An item inside a tree-view."""
	@others
    value = property(__get_value)</t>
<t tx="ekr.20060521134315.1448">def __init__(self, key, value):
    self.__key = key
    self.__value = value
</t>
<t tx="ekr.20060521134315.1449">def __get_markup(self):
    """Return the markup for the item."""
    return self.__value
</t>
<t tx="ekr.20060521134315.1450">markup = property(__get_markup)

def __get_key(self):
    """Return the key for the treeview item."""
    return self.__key
</t>
<t tx="ekr.20060521134315.1451">key = property(__get_key)

def __get_value(self):
    """Return the value for the tree view item."""
    return self.__value
</t>
<t tx="ekr.20060521134315.1452">

    
class QuestionBox(gtk.HBox):
	@others
</t>
<t tx="ekr.20060521134315.1453">def __init__(self):
    gtk.HBox.__init__(self)
    self.__entry = gtk.Entry()
    self.pack_start(self.__entry)
    self.__toolbar = toolbar.Toolbar()
    self.pack_start(self.__toolbar)
    self.__toolbar.add_button('ok', 'apply', 'ok')
    self.__toolbar.add_button('cancel', 'cancel', 'cancel')
    self.__toolbar.connect('clicked', self.cb_toolbar_clicked)
    self.set_sensitive(False)
</t>
<t tx="ekr.20060521134315.1454">def cb_toolbar_clicked(self, toolbar, action):
    if action == 'ok':
        self.__current_callback(self.__entry.get_text())
    self.__entry.set_text('')
    self.set_sensitive(False)
</t>
<t tx="ekr.20060521134315.1455">def question(self, callback, prompt='?'):
    self.set_sensitive(True)
    self.__current_callback = callback
</t>
<t tx="ekr.20060521134315.1456">

class Tree(gtk.VBox):
    """A treeview control with niceness."""
	&lt;&lt; class Tree declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.1457">#The fields for the model.
FIELDS = (gobject.TYPE_STRING,
          gobject.TYPE_PYOBJECT,
          gobject.TYPE_STRING)

#The columns for the view.
COLUMNS = [[gtk.CellRendererText, 'markup', 2],
           [gtk.CellRendererText, '', '']]

#The signals for the widget.
__gsignals__ = {'clicked' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    (gobject.TYPE_PYOBJECT,)),
                'double-clicked' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    (gobject.TYPE_PYOBJECT,)),
                'right-clicked' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    (gobject.TYPE_PYOBJECT, gobject.TYPE_PYOBJECT)),
                'middle-clicked' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    (gobject.TYPE_PYOBJECT,)),
                'new-item' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    ()),
                'delete-item' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    ()),
                'edit-item' : (
                    gobject.SIGNAL_RUN_LAST,
                    gobject.TYPE_NONE,
                    ())}

gproperty('has-edit-box', bool, default=True)
gproperty('headers-visible', bool, default=True)
gproperty('icons-visible', bool, default=False)
gproperty('markup-format-string', str, default='%(key)s')

</t>
<t tx="ekr.20060521134315.1458">def do_get_property(self, prop):
    return self.__properties.setdefault(prop.name, prop.default_value)
</t>
<t tx="ekr.20060521134315.1459">def do_set_property(self, prop, value):
    self.__properties[prop.name] = value
</t>
<t tx="ekr.20060521134315.1460">EDIT_BUTTONS = False
EDIT_BOX = False

HEADERS_VISIBLE = False

SORT_BY = None
SORT_LIST = None
SORT_AVAILABLE = None
SORT_CONTROLS = False

def __init__(self):
    self.__init_model()
    self.__init_view()
    self.__init_signals()
    self.__properties = {}
</t>
<t tx="ekr.20060521134315.1461">def __init_view(self):
    """Load the widgets."""
    gtk.VBox.__init__(self)
    self.__sw = gtk.ScrolledWindow()
    self.pack_start(self.__sw)
    self.__sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
    self.__view = gtk.TreeView(self.__model)
    self.__view.set_rules_hint(True)
    self.__view.set_enable_search(False)
    self.__view.set_model(self.__model)
    self.__sw.add(self.__view)
    self.__view.set_headers_visible(False)
    for column in self.__init_renderers():
        self.__view.append_column(column)
    if self.SORT_CONTROLS == True:
        sb = gtk.Expander()
        self.pack_start(sb, expand=False)
        l = gtk.Label('Sort')
        sb.set_label_widget(l)
        hb = gtk.HBox()
        sb.add(hb)
        self.__sortcombo = gtk.combo_box_new_text()
        hb.pack_start(self.__sortcombo)
        if self.SORT_AVAILABLE is not None:
            self.sort_available = dict(self.SORT_AVAILABLE)
            for attr, val in self.SORT_AVAILABLE:
                self.__sortcombo.append_text(attr)
        self.__sortdir = gtk.ToggleToolButton(
                         stock_id=gtk.STOCK_SORT_DESCENDING)
        hb.pack_start(self.__sortdir, expand=False)
        self.__sortdir.set_active(True)
        self.__sortcombo.set_active(0)
        self.__sortdir.connect('toggled', self.cb_sortdir_toggled)
        self.__sortcombo.connect('changed', self.cb_sortcombo_changed)
        self.__user_initiated_sort()
    if self.EDIT_BOX == True:
        self.__editbox = QuestionBox()
        self.pack_start(self.__editbox, expand=False)
    if self.EDIT_BUTTONS == True:
        self.__toolbar = toolbar.Toolbar()
        self.__toolbar.add_button('new', 'new', 'new', True)
        self.__toolbar.add_button('delete', 'delete', 'delete', True)
        self.__toolbar.add_button('edit', 'edit', 'Edit this item.', True)
        self.__toolbar.connect('clicked', self.cb_toolbar_clicked)
        self.pack_start(self.__toolbar, expand=False)
    self.__init_signals()
    if self.SORT_BY is not None:
        self.sort_by([self.SORT_BY])
    if self.SORT_LIST is not None:
        self.sort_by(self.SORT_LIST)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1462">def __init_model(self):
    """Initialise and return the model for the data."""
    self.__model = gtk.TreeStore(*self.FIELDS)
    return self.__model
</t>
<t tx="ekr.20060521134315.1463">def __init_signals(self):
    def cb_toolbar_clicked(toolbar, action):
        if action == 'new':
            self.emit('new-item')
        elif action == 'delete':
            self.emit('delete-item')
        elif action == 'edit':
            self.emit('edit-item')
        self.__toolbar.emit_stop_by_name('clicked')
    if self.EDIT_BUTTONS == True:
        self.__toolbar.connect('clicked', cb_toolbar_clicked)
    def cb_cursor_changed(view):
        self.emit('clicked', self.selected)
        self.__view.emit_stop_by_name('cursor-changed')
    self.__view.connect('cursor-changed', cb_cursor_changed)
    def cb_row_activated(view, path, column):
        self.emit('double-clicked', self.selected)
        self.__view.emit_stop_by_name('row-activated')
    self.__view.connect_after('row-activated', cb_row_activated)
    def cb_button_press_event(source, event):
        if event.button == 3:
            pathinf = self.__view.get_path_at_pos(int(event.x), int(event.y))
            self.__view.emit_stop_by_name('button-press-event')
            if pathinf is not None:
                path, col, cellx, celly = pathinf
                ite = self.__model.get_iter(path)
                item = self.__model.get_value(ite, 1)
                self.__view.grab_focus()
                self.__view.set_cursor(path, None, 0)
                self.emit('right-clicked', item, event)
            else:
                self.emit('right-clicked', None, event)
            return True
        if event.button == 2:
            pathinf = self.__view.get_path_at_pos(int(event.x), int(event.y))
            if pathinf is not None:
                path, col, cellx, celly = pathinf
                self.__view.grab_focus()
                self.__view.set_cursor(path, None, 0)
                self.__view.emit_stop_by_name('button-press-event')
                self.emit('middle-clicked', self.selected)
                return True
    self.__view.add_events(gtk.gdk.BUTTON_PRESS_MASK)
    self.__view.connect('button-press-event', cb_button_press_event)
</t>
<t tx="ekr.20060521134315.1464">def __init_renderers(self):
    """Initialise the renderers."""
    for renderer_type, attribute, field in self.COLUMNS:
        renderer = renderer_type()
        renderer.set_property('ypad', 1)
        if attribute:
            kw = {attribute:field}
        else:
            kw = {}
        column = gtk.TreeViewColumn(attribute, renderer, **kw)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        yield column
</t>
<t tx="ekr.20060521134315.1465">def add_item(self, item, key=None, parent=None):
    """Add an item to the tree."""
    if key is None:
        key = item.key
    else:
        item.key = key
    titem = TreeItem(key, item)
    row = [key, titem, self.__get_markup(item)]
    niter = self.model.append(parent, row)
    def reset():
        self.model.set_value(niter, 2, self.get_markup(item))
    titem.reset_markup = reset
    item.reset_markup = reset
    return niter
</t>
<t tx="ekr.20060521134315.1466">def __get_markup(self, item):
    unmangled = {}
    markup_fmt = self.get_property('markup-format-string')
    for k in dir(item):
        if k in markup_fmt:
            unmangled[k] = getattr(item, k)
    markup_string = markup_fmt % unmangled
    return markup_string
</t>
<t tx="ekr.20060521134315.1467">get_markup = __get_markup

def add_items(self, items):
    """Add items to the tree."""
    for item in items:
        self.add_item(item)
</t>
<t tx="ekr.20060521134315.1468">def clear(self):
    """Clear the tree."""
    self.__model.clear()
</t>
<t tx="ekr.20060521134315.1469">def del_item(self):
    """Removes the currently selected item from the tree."""
    selected_path = self.__get_selected_path()
    if selected_path:
        self.__model.emit('row-deleted', selected_path)
</t>
<t tx="ekr.20060521134315.1470">def set_items(self, items):
    """Set the items in the tree from the item list."""
    self.clear()
    self.add_items(items)
</t>
<t tx="ekr.20060521134315.1471">def question(self, callback, prompt):
    self.__editbox.question(callback, prompt)
</t>
<t tx="ekr.20060521134315.1472">def sort_by(self, attrnames,
            sortcolid=0, columnid=1,
            direction=1):
    def comparemethod(model, iter1, iter2):
        v1 = model.get_value(iter1, columnid)
        v2 = model.get_value(iter2, columnid)
        def cmpvs(attrname, v1, v2):
            attr1 = attr2 = None
            if v1 is not None:
                attr1 = getattr(v1.value, attrname, None)
            if v2 is not None:
                attr2 = getattr(v2.value, attrname, None)
            if attr1 is None and attr2 is None:
                return 0
            elif attr1 is None:
                return 0
            elif attr2 is None:
                return 0
            else:
                return cmp(attr2, attr1)
        for attrname in attrnames + ['key']:
            compd = cmpvs(attrname, v1, v2)
            if compd != 0:
                return direction * compd
        return 0
    self.__model.set_sort_column_id(sortcolid, gtk.SORT_DESCENDING)
    self.__model.set_sort_func(sortcolid, comparemethod)
</t>
<t tx="ekr.20060521134315.1473">    #self.__view.set_model(self.__model)

def __get_model(self):
    """Return the Tree Model."""
    return self.__model
</t>
<t tx="ekr.20060521134315.1474">model = property(__get_model)

def __get_view(self):
    return self.__view
</t>
<t tx="ekr.20060521134315.1475">view = property(__get_view)

def __get_selected(self, column=1):
    """Get the selected item."""
    ite = self.__get_selected_iter()
    if ite:
        return self.__get(ite, column)
</t>
<t tx="ekr.20060521134315.1476">selected = property(__get_selected)

def get_selected_key(self):
    return self.__get_selected(0)
</t>
<t tx="ekr.20060521134315.1477">selected_key = property(get_selected_key)

def set_selected(self, key):
    """Set the selected item to the first item matching the key."""
    key = str(key)
    for row in self.model:
        if row[0] == key:
            self.__view.set_cursor(row.path)
            return True
    return False
</t>
<t tx="ekr.20060521134315.1478">def __get_selected_iter(self):
    """Get the selected Tree Model Iter."""
    path = self.__get_selected_path()
    if path:
        return self.__model.get_iter(path)
</t>
<t tx="ekr.20060521134315.1479">selected_iter = property(__get_selected_iter)
    
def __get_selected_path(self):
    """Get the selected Tree View Path."""
    return self.__view.get_cursor()[0]
</t>
<t tx="ekr.20060521134315.1480">selected_path = property(__get_selected_path)

def __get(self, niter, column):
    """Get a cell's vlue from the Tree Model."""
    return self.__model.get_value(niter, column)
</t>
<t tx="ekr.20060521134315.1481">get = __get

def __set(self, niter, column, value):
    self.__model.set_value(niter, column, value)
</t>
<t tx="ekr.20060521134315.1482">set = __set

def cb_toolbar_clicked(self, toolbar, action):
    if action == 'new':
        self.emit('new-item')
    elif action == 'edit':
        self.emit('edit-item')
    elif action == 'delete':
        self.emit('delete-item')
    toolbar.emit_stop_by_name('clicked')
</t>
<t tx="ekr.20060521134315.1483">def cb_sortcombo_changed(self, combo):
    self.__user_initiated_sort()
</t>
<t tx="ekr.20060521134315.1484">def cb_sortdir_toggled(self, toggle):
    self.__user_initiated_sort()
</t>
<t tx="ekr.20060521134315.1485">def __user_initiated_sort(self):
    text = self.__sortcombo.get_active_text()
    if self.__sortdir.get_active():
        direction = 1#gtk.SORT_DESCENDING
    else:
        direction = -1#gtk.SORT_ASCENDING
    self.sort_by([self.sort_available[text]], direction=direction)
</t>
<t tx="ekr.20060521134315.1486">
gobject.type_register(Tree)

class IconTreeItem(TreeItem):
    """I tree item with an icon."""
	@others
    pixbuf = property(get_pixbuf)</t>
<t tx="ekr.20060521134315.1487">def __init__(self, key, value, image=None, icon_filename=None):
    TreeItem.__init__(self, key, value)
    if image is not None:
        self.__image = image
    elif icon_filename is not None:
        self.__image = gtk.Image()
        self.__image.set_from_file(icon_filename)
    else:
        self.__image = gtk.Image()
</t>
<t tx="ekr.20060521134315.1488">def get_icon(self):
    return self.__image
</t>
<t tx="ekr.20060521134315.1489">icon = property(get_icon)

def get_pixbuf(self):
    return getattr(self.icon, 'get_pixbuf', lambda: self.icon)()
</t>
<t tx="ekr.20060521134315.1490">


class IconTree(Tree):
    """Tree with icons."""
	&lt;&lt; class IconTree declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.1491">FIELDS = (gobject.TYPE_STRING,
          gobject.TYPE_PYOBJECT,
          gobject.TYPE_STRING,
          gtk.gdk.Pixbuf)

COLUMNS = [[gtk.CellRendererPixbuf, 'pixbuf', 3],
           [gtk.CellRendererText, 'markup', 2]]

</t>
<t tx="ekr.20060521134315.1492">def add_item(self, item, key=None, parent=None):
    pixbuf = item.pixbuf
    if key is None:
        key = item.key
    else:
        item.key = key
    titem = TreeItem(key, item)
    row = [key, titem, self.get_markup(item), pixbuf]
    niter = self.model.append(parent, row)
    def reset():
        self.model.set_value(niter, 2, self.get_markup(item))
        self.model.set_value(niter, 3, item.pixbuf)
    titem.reset_markup = reset
    item.reset_markup = reset
    return niter
</t>
<t tx="ekr.20060521134315.1493">
class ToggleTree(Tree):
	&lt;&lt; class ToggleTree declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20060521134315.1494">FIELDS = (gobject.TYPE_STRING,
          gobject.TYPE_PYOBJECT,
          gobject.TYPE_STRING,
          gobject.TYPE_BOOLEAN)

COLUMNS = [[gtk.CellRendererText, 'markup', 2],
           [gtk.CellRendererToggle, 'active', 3] ]


</t>
<t tx="ekr.20060521134315.1495">def add_item(self, item, key=None, parent=None):
    active = item.active
    if key is None:
        key = item.key
    else:
        item.key = key
    titem = TreeItem(key, item)
    row = [key, titem, self.get_markup(item), active]
    niter = self.model.append(parent, row)
    def reset():
        self.model.set_value(niter, 2, self.get_markup(item))
        self.model.set_value(niter, 3, item.active)
    titem.reset_markup = reset
    item.reset_markup = reset
    return niter
</t>
<t tx="ekr.20060521134315.1496">def test():
    w = gtk.Window()
    v = gtk.VBox()
    w.add(v)
    t = Tree()
    v.pack_start(t)
    b = gtk.Button('foo')
    v.pack_start(b, False)
    w.show_all()

    def _clicked(button):
        t.selected.value.key = 'ali'
        t.selected.reset_markup()
    b.connect('clicked', _clicked)

    class Dummy(object):
        key = "fooood"
        name = 'mess'
    for i in range(20):
        d = Dummy()
        t.add_item(d)

    gtk.main()
</t>
<t tx="ekr.20060521134315.1497"></t>
<t tx="ekr.20060521134315.1498">@first # -*- coding: utf-8 -*- 

"""
Terminals, and command console.
"""

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1499">from Queue import Queue

import vte
import gtk
import gobject

from winpdb.rpdb2 import CConsole
from components import PGDSlaveDelegate


</t>
<t tx="ekr.20060521134315.1500">class Terminal(PGDSlaveDelegate):
    """
    Holds a terminal emulator widget
    """
	@others
</t>
<t tx="ekr.20060521134315.1501">def create_toplevel_widget(self):
    t = self.add_widget('terminal', vte.Terminal())
    t.set_size_request(0, 0)
    self._readbuf = ''
    return t
</t>
<t tx="ekr.20060521134315.1502">def feed(self, text):
    text = text.replace('\n', '\r\n')
    def _f(text):
        self.terminal.feed(text)
    gobject.idle_add(_f, text)
</t>
<t tx="ekr.20060521134315.1503">

class InputTerminal(Terminal):
    """
    Holds a terminal emulator widget you can type into
    """
	@others
</t>
<t tx="ekr.20060521134315.1504">def create_toplevel_widget(self):
    t = gtk.VBox()
    t.pack_start(super(InputTerminal, self).create_toplevel_widget())
    return t
</t>
<t tx="ekr.20060521134315.1505">def on_terminal__commit(self, term, text, length):
    self._readbuf = ''.join([self._readbuf, text])
    self.feed(text.replace('\r', '\r\n'))
    self._process_readbuf()
</t>
<t tx="ekr.20060521134315.1506">def _process_readbuf(self):
    if '\r' in self._readbuf:
        lines = self._readbuf.split('\r')
        self._readbuf = lines.pop()
        for line in lines:
            self.commiter.received_line(line)
</t>
<t tx="ekr.20060521134315.1507">

class Console(object):
    """
    The command console
    """
	@others
</t>
<t tx="ekr.20060521134315.1508">def __init__(self, app):

    self.app = app
    self.main_window = app.main_window
    self.session_manager = app.session_manager
    self._commands =Queue()
    self.console = self._create_console()
    self.delegate = self._create_view()
</t>
<t tx="ekr.20060521134315.1509">def _create_console(self):
    """
    Create and return an rpdb2 console.

    We bind the console's io to ourselves, and give it our session
    manager.
    """
    console = CConsole(self.session_manager,
                             stdin = self,
                             stdout = self,
                             fSplit = True)
    return console
</t>
<t tx="ekr.20060521134315.1510">def start(self):
    self.console.start()
</t>
<t tx="ekr.20060521134315.1511">def write(self, text):
    self.feed(text)
</t>
<t tx="ekr.20060521134315.1512">def feed(self, text):
    self.delegate.feed(text)
</t>
<t tx="ekr.20060521134315.1513">def _create_view(self):
    view = InputTerminal(self.app)
    view.commiter = self
    self.main_window.attach_slave('term_holder', view)
    return view
</t>
<t tx="ekr.20060521134315.1514">def received_line(self, line):
    line = line + '\n'
    self._commands.put(line)
</t>
<t tx="ekr.20060521134315.1515">def readline(self):
    text = self._commands.get()
    return text
</t>
<t tx="ekr.20060521134315.1516">def flush(self):
    pass
</t>
<t tx="ekr.20060521134315.1517">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others

if __name__ == '__main__':
    start_as_cl()
</t>
<t tx="ekr.20060521134315.1518">import os
import sys

from winpdb import rpdb2
from console import Terminal


</t>
<t tx="ekr.20060521134315.1519">def get_debugee_script_path():

    import pkg_resources
    req = pkg_resources.Requirement.parse('pgd')
    try:
        sfile = pkg_resources.resource_filename(req, 'pgd/winpdb/rpdb2.py')
    except pkg_resources.DistributionNotFound:
        sfile = os.path.join(
            os.path.dirname(__file__),
            'winpdb',
            'rpdb2.py')
        if sfile.endswith('c'):
            sfile = sfile[:-1]
    return sfile
</t>
<t tx="ekr.20060521134315.1520">class SessionManagerInternal(rpdb2.CSessionManagerInternal):
    
	@others

</t>
<t tx="ekr.20060521134315.1521">def _spawn_server(self, fchdir, ExpandedFilename, args, rid):
    """
    Start an OS console to act as server.
    What it does is to start rpdb again in a new console in server only mode.
    """
    debugger = get_debugee_script_path()
    baseargs = ['python', debugger, '--debugee', '--rid=%s' % rid]
    if fchdir:
        baseargs.append('--chdir')
    if self.m_fAllowUnencrypted:
        baseargs.append('--plaintext')
    if self.m_fRemote:
        baseargs.append('--remote')
    if os.name == 'nt':
        baseargs.append('--pwd=%s' % self.m_pwd)
    if 'PGD_DEBUG' in os.environ:
        baseargs.append('--debug')
    baseargs.append(ExpandedFilename)
    cmdargs = baseargs + args.split()
    python_exec = sys.executable
    self.terminal.fork_command(python_exec, cmdargs)
</t>
<t tx="ekr.20060521134315.1522">class SessionManager(rpdb2.CSessionManager):
	@others
</t>
<t tx="ekr.20060521134315.1523">def __init__(self, app):
    self.app = app
    self.options = app.options
    self.main_window = app.main_window
    self.delegate = self._create_view()
    self._CSessionManager__smi = self._create_smi()
</t>
<t tx="ekr.20060521134315.1524">def _create_smi(self):
    smi = SessionManagerInternal(
                              self.options.pwd,
                              self.options.allow_unencrypted,
                              self.options.remote,
                              self.options.host)
    smi.terminal = self
    return smi
</t>
<t tx="ekr.20060521134315.1525">def _create_view(self):
    view = Terminal(self.app)
    self.main_window.attach_slave('outterm_holder', view)
    return view
</t>
<t tx="ekr.20060521134315.1526">def fork_command(self, *args, **kw):
    self.delegate.terminal.fork_command(*args, **kw)
</t>
<t tx="ekr.20060521134315.1527">def launch_filename(self, filename):
    self.app.launch(filename)
</t>
<t tx="ekr.20060521134315.1528">class RunningOptions(object):
	@others
</t>
<t tx="ekr.20060521134315.1529">def set_options(self, command_line,
              fAttach,
              fchdir,
              pwd,
              fAllowUnencrypted,
              fRemote,
              host):
    self.command_line = command_line
    self.attach = fAttach
    self.pwd = pwd
    self.allow_unencrypted = fAllowUnencrypted
    self.remote = fRemote
    self.host = host
</t>
<t tx="ekr.20060521134315.1530">def connect_events(self):

    event_type_dict = {rpdb2.CEventState: {}}
    self.session_manager.register_callback(self.update_state, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventStackFrameChange: {}}
    self.session_manager.register_callback(self.update_frame, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventThreads: {}}
    self.session_manager.register_callback(self.update_threads, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventNoThreads: {}}
    self.session_manager.register_callback(self.update_no_threads, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventNamespace: {}}
    self.session_manager.register_callback(self.update_namespace, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventThreadBroken: {}}
    self.session_manager.register_callback(self.update_thread_broken, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventStack: {}}
    self.session_manager.register_callback(self.update_stack, event_type_dict, fSingleUse = False)
    event_type_dict = {rpdb2.CEventBreakpoint: {}}
    self.session_manager.register_callback(self.update_bp, event_type_dict, fSingleUse = False)
</t>
<t tx="ekr.20060521134315.1531">def start(command_line, fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host):

    options= RunningOptions()
    options.set_options(command_line, fAttach, fchdir, pwd, fAllowUnencrypted, fRemote, host)

    return options
</t>
<t tx="ekr.20060521134315.1532">def main(start):
    
    rpdb2.main(start)

</t>
<t tx="ekr.20060521134315.1533">def start_as_cl():

    rpdb2.main()
</t>
<t tx="ekr.20060521134315.1534">@first # -*- coding: utf-8 -*- 

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20060521134315.1535">from tree import Tree

import gtk

from components import PGDSlaveDelegate

from winpdb.rpdb2 import DICT_KEY_TID, DICT_KEY_BROKEN

</t>
<t tx="ekr.20060521134315.1536">class ThreadItem(object):

	@others</t>
<t tx="ekr.20060521134315.1537">def __init__(self, tdict):

    self.tid = tdict[DICT_KEY_TID]
    self.broken = tdict[DICT_KEY_BROKEN]
    self.is_current = False
    self.key = self.tid
</t>
<t tx="ekr.20060521134315.1538">def get_broken_text(self):
    
    if self.broken:
        return 'broken'
    else:
        return 'running'

state = property(get_broken_text)
</t>
<t tx="ekr.20060521134315.1539">def get_pixbuf(self):
    return None

pixbuf = property(get_pixbuf)</t>
<t tx="ekr.20060521134315.1540">class ThreadsViewer(PGDSlaveDelegate):

	@others
</t>
<t tx="ekr.20060521134315.1541">def create_toplevel_widget(self):

    exp = gtk.Expander()
    l = gtk.Label()
    l.set_markup('&lt;big&gt;Threads&lt;/big&gt;')
    exp.set_label_widget(l)
    exp.set_expanded(True)
    t = self.add_widget('tree', Tree())
    t.set_property('markup-format-string',
        '&lt;tt&gt;%(tid)s&lt;/tt&gt; '
        '&lt;span color="#909090"&gt;&lt;i&gt;%(state)s&lt;/i&gt;&lt;/span&gt;')
    exp.add(t)
    v = self.add_widget('tree_view', t.view)
    return exp
</t>
<t tx="ekr.20060521134315.1542">def attach_slaves(self):

    self.main_window.attach_slave('threads_holder', self)
    self.show_all()
</t>
<t tx="ekr.20060521134315.1543">def update_threads(self, threads_list, current_thread):

    self.tree.clear()
    for tdict in threads_list:
        item = ThreadItem(tdict)
        if item.tid == current_thread:
            item.is_current = True
        self.tree.add_item(item)
</t>
<t tx="ekr.20060521134315.1544">def broken_thread(self, tid):

    for row in self.tree.model:
        if row[0] == tid:
            val = row[1].value()
            val.broken = True
            val.reset_markup()</t>
<t tx="ekr.20060521134346"># An attempt to subclass Idle classes for use directly in Leo.
# Not a good idea: much better to run Idle in a separate process from Leo.</t>
<t tx="ekr.20060521134346.32"># Leo analog of idlelib/run.py

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

# Thread shared globals: Establish a queue between a subthread (which handles
# the socket) and the main thread (which runs user code), plus global
# completion and exit flags:
exit_now = False
quitting = False
no_exitfunc = None
LOCALHOST = '127.0.0.1'

@others</t>
<t tx="ekr.20060521134346.33">import leoGlobals as g

import sys
import os
import linecache
import time
import socket
import traceback
import thread
import threading
import Queue

import idlelib.CallTips as CallTips
import leo_RemoteDebugger as RemoteDebugger
import idlelib.RemoteObjectBrowser as RemoteObjectBrowser
import idlelib.StackViewer as StackViewer
import idlelib.rpc as rpc
import idlelib.IOBinding as IOBinding

import __main__

try:
    import warnings
except ImportError:
    pass
else:
    def idle_formatwarning_subproc(message, category, filename, lineno):
        """Format warnings the Leo way"""
        s = "\nWarning (from warnings module):\n"
        s += '  File \"%s\", line %s\n' % (filename, lineno)
        line = linecache.getline(filename, lineno).strip()
        if line:
            s += "    %s\n" % line
        s += "%s: %s\n" % (category.__name__, message)
        return s
        
    warnings.formatwarning = idle_formatwarning_subproc</t>
<t tx="ekr.20060521134346.34">def virtual_event_name (s):
    
    return (
        '&lt;&lt;' +
        s + '&gt;&gt;')</t>
<t tx="ekr.20060521134346.35">def main(del_exitfunc=False):

    """Start the Python execution server in a subprocess
    
    In the Python subprocess, RPCServer is instantiated with handlerclass
    MyHandler, which inherits register/unregister methods from RPCHandler via
    the mix-in class SocketIO.
    
    When the RPCServer 'server' is instantiated, the TCPServer initialization
    creates an instance of run.MyHandler and calls its handle() method.
    handle() instantiates a run.Executive object, passing it a reference to the
    MyHandler object.  That reference is saved as attribute rpchandler of the
    Executive instance.  The Executive methods have access to the reference and
    can pass it on to entities that they command
    (e.g. RemoteDebugger.Debugger.start_debugger()).  The latter, in turn, can
    call MyHandler(SocketIO) register/unregister methods via the reference to
    register and unregister themselves.
    
    """
    
    g.trace('leo_run')
    global exit_now
    global quitting
    global no_exitfunc
    no_exitfunc = del_exitfunc
    port = 8833
    #time.sleep(15) # test subprocess not responding
    if sys.argv[1:]:
        port = int(sys.argv[1])
    sys.argv[:] = [""]
    sockthread = threading.Thread(target=manage_socket,
                                  name='SockThread',
                                  args=((LOCALHOST, port),))
    sockthread.setDaemon(True)
    sockthread.start()
    while 1:
        try:
            if exit_now:
                try:
                    exit()
                except KeyboardInterrupt:
                    # exiting but got an extra KBI? Try again!
                    continue
            try:
                seq, request = rpc.request_queue.get(0)
            except Queue.Empty:
                time.sleep(0.05)
                continue
            method, args, kwargs = request
            ret = method(*args, **kwargs)
            rpc.response_queue.put((seq, ret))
        except KeyboardInterrupt:
            if quitting:
                exit_now = True
            continue
        except SystemExit:
            raise
        except:
            type, value, tb = sys.exc_info()
            try:
                print_exception()
                rpc.response_queue.put((seq, None))
            except:
                # Link didn't work, print same exception to __stderr__
                traceback.print_exception(type, value, tb, file=sys.__stderr__)
                exit()
            else:
                continue</t>
<t tx="ekr.20060521134346.36">def manage_socket(address):
    for i in range(3):
        time.sleep(i)
        try:
            server = MyRPCServer(address, MyHandler)
            break
        except socket.error, err:
            print&gt;&gt;sys.__stderr__,"Leo Subprocess: socket error: "\
                                        + err[1] + ", retrying...."
    else:
        print&gt;&gt;sys.__stderr__, "Leo Subprocess: Connection to "\
                               "Leo GUI failed, exiting."
        show_socket_error(err, address)
        global exit_now
        exit_now = True
        return
    server.handle_request() # A single request only</t>
<t tx="ekr.20060521134346.37">def show_socket_error(err, address):
    import Tkinter
    import tkMessageBox
    root = Tkinter.Tk()
    root.withdraw()
    if err[0] == 61: # connection refused
        msg = "Leo's subprocess can't connect to %s:%d.  This may be due "\
              "to your personal firewall configuration.  It is safe to "\
              "allow this internal connection because no data is visible on "\
              "external ports." % address
        tkMessageBox.showerror("Leo Subprocess Error", msg, parent=root)
    else:
        tkMessageBox.showerror("Leo Subprocess Error", "Socket Error: %s" % err[1])
    root.destroy()</t>
<t tx="ekr.20060521134346.38">def print_exception():

    import linecache
    linecache.checkcache()
    flush_stdout()
    efile = sys.stderr
    typ, val, tb = excinfo = sys.exc_info()
    sys.last_type, sys.last_value, sys.last_traceback = excinfo
    tbe = traceback.extract_tb(tb)
    print&gt;&gt;efile, '\nTraceback (most recent call last):'
    exclude = ("run.py", "rpc.py", "threading.py", "Queue.py",
               "RemoteDebugger.py", "bdb.py")
    cleanup_traceback(tbe, exclude)
    traceback.print_list(tbe, file=efile)
    lines = traceback.format_exception_only(typ, val)
    for line in lines:
        print&gt;&gt;efile, line,</t>
<t tx="ekr.20060521134346.39">def cleanup_traceback(tb, exclude):
    "Remove excluded traces from beginning/end of tb; get cached lines"
    orig_tb = tb[:]
    while tb:
        for rpcfile in exclude:
            if tb[0][0].count(rpcfile):
                break    # found an exclude, break for: and delete tb[0]
        else:
            break        # no excludes, have left RPC code, break while:
        del tb[0]
    while tb:
        for rpcfile in exclude:
            if tb[-1][0].count(rpcfile):
                break
        else:
            break
        del tb[-1]
    if len(tb) == 0:
        # exception was in Leo internals, don't prune!
        tb[:] = orig_tb[:]
        print&gt;&gt;sys.stderr, "** Leo Internal Exception: "
    rpchandler = rpc.objecttable['exec'].rpchandler
    for i in range(len(tb)):
        fn, ln, nm, line = tb[i]
        if nm == '?':
            nm = "-toplevel-"
        if not line and fn.startswith("&lt;pyshell#"):
            line = rpchandler.remotecall('linecache', 'getline',
                                              (fn, ln), {})
        tb[i] = fn, ln, nm, line</t>
<t tx="ekr.20060521134346.40">def flush_stdout():
    try:
        if sys.stdout.softspace:
            sys.stdout.softspace = 0
            sys.stdout.write("\n")
    except (AttributeError, EOFError):
        pass
    </t>
<t tx="ekr.20060521134346.41">def exit():
    """Exit subprocess, possibly after first deleting sys.exitfunc
    
    If config-main.cfg/.def 'General' 'delete-exitfunc' is True, then any
    sys.exitfunc will be removed before exiting.  (VPython support)
    
    """
    if no_exitfunc:
        del sys.exitfunc
    sys.exit(0)</t>
<t tx="ekr.20060521134346.42">class MyRPCServer(rpc.RPCServer):
    
	@others</t>
<t tx="ekr.20060521134346.43">def handle_error(self, request, client_address):
    """Override RPCServer method for Leo.

    Interrupt the MainThread and exit server if link is dropped.

    """
    global quitting
    try:
        raise
    except SystemExit:
        raise
    except EOFError:
        global exit_now
        exit_now = True
        thread.interrupt_main()
    except:
        erf = sys.__stderr__
        print&gt;&gt;erf, '\n' + '-'*40
        print&gt;&gt;erf, 'Unhandled server exception!'
        print&gt;&gt;erf, 'Thread: %s' % threading.currentThread().getName()
        print&gt;&gt;erf, 'Client Address: ', client_address
        print&gt;&gt;erf, 'Request: ', repr(request)
        traceback.print_exc(file=erf)
        print&gt;&gt;erf, '\n*** Unrecoverable, server exiting!'
        print&gt;&gt;erf, '-'*40
        quitting = True
        thread.interrupt_main()
</t>
<t tx="ekr.20060521134346.44">class MyHandler(rpc.RPCHandler):
	@others</t>
<t tx="ekr.20060521134346.45">def handle(self):
    """Override base method"""
    executive = Executive(self)
    self.register("exec", executive)
    sys.stdin = self.console = self.get_remote_proxy("stdin")
    sys.stdout = self.get_remote_proxy("stdout")
    sys.stderr = self.get_remote_proxy("stderr")
    # import IOBinding
    sys.stdin.encoding = sys.stdout.encoding = \
                         sys.stderr.encoding = IOBinding.encoding
    self.interp = self.get_remote_proxy("interp")
    rpc.RPCHandler.getresponse(self, myseq=None, wait=0.05)
</t>
<t tx="ekr.20060521134346.46">def exithook(self):
    "override SocketIO method - wait for MainThread to shut us down"
    time.sleep(10)
</t>
<t tx="ekr.20060521134346.47">def EOFhook(self):
    "Override SocketIO method - terminate wait on callback and exit thread"
    global quitting
    quitting = True
    thread.interrupt_main()
</t>
<t tx="ekr.20060521134346.48">def decode_interrupthook(self):
    "interrupt awakened thread"
    global quitting
    quitting = True
    thread.interrupt_main()
</t>
<t tx="ekr.20060521134346.49">

class Executive:
	@others
</t>
<t tx="ekr.20060521134346.50">def __init__(self, rpchandler):

    self.rpchandler = rpchandler
    self.locals = __main__.__dict__
    self.calltip = CallTips.CallTips()
</t>
<t tx="ekr.20060521134346.51">def runcode(self, code):
    
    print 'leo_run:runcode'

    try:
        self.usr_exc_info = None
        exec code in self.locals
    except:
        self.usr_exc_info = sys.exc_info()
        if quitting:
            exit()
        # even print a user code SystemExit exception, continue
        print_exception()
        jit = self.rpchandler.console.getvar(virtual_event_name('toggle-jit-stack-viewer'))
        if jit:
            self.rpchandler.interp.open_remote_stack_viewer()
    else:
        flush_stdout()
</t>
<t tx="ekr.20060521134346.52">def interrupt_the_server(self):
    
    thread.interrupt_main()

</t>
<t tx="ekr.20060521134346.53">def start_the_debugger(self, gui_adap_oid):
    
    g.trace()

    return RemoteDebugger.start_debugger(self.rpchandler, gui_adap_oid)
</t>
<t tx="ekr.20060521134346.54">def stop_the_debugger(self, idb_adap_oid):
    
    "Unregister the Idb Adapter.  Link objects and Idb then subject to GC"
    self.rpchandler.unregister(idb_adap_oid)

</t>
<t tx="ekr.20060521134346.55">def get_the_calltip(self, name):
    return self.calltip.fetch_tip(name)</t>
<t tx="ekr.20060521134346.56">def stackviewer(self, flist_oid=None):

    if self.usr_exc_info:
        typ, val, tb = self.usr_exc_info
    else:
        return None
    flist = None
    if flist_oid is not None:
        flist = self.rpchandler.get_remote_proxy(flist_oid)
    while tb and tb.tb_frame.f_globals["__name__"] in ["rpc", "run"]:
        tb = tb.tb_next
    sys.last_type = typ
    sys.last_value = val
    item = StackViewer.StackTreeItem(flist, tb)
    return RemoteObjectBrowser.remote_object_tree_item(item)</t>
<t tx="ekr.20060521134346.57">&lt;&lt; RemoteDebugger docstring &gt;&gt;

@language python
@tabwidth -4

import leo_Debugger

# This probably can not access Leo directly.

debugging = 0
idb_adap_oid = "idb_adapter"
gui_adap_oid = "gui_adapter"

LOCALHOST = '127.0.0.1'

# In the PYTHON subprocess:
frametable = {}
dicttable = {}
codetable = {}
tracebacktable = {}

@others</t>
<t tx="ekr.20060521134346.58">"""Support for remote Python debugging.

Some ASCII art to describe the structure:

       IN PYTHON SUBPROCESS          #             IN Leo PROCESS
                                     #
                                     #        oid='gui_adapter'
                 +----------+        #       +------------+          +-----+
                 | GUIProxy |--remote#call--&gt;| GUIAdapter |--calls--&gt;| GUI |
+-----+--calls--&gt;+----------+        #       +------------+          +-----+
| Idb |                               #                             /
+-----+&lt;-calls--+------------+         #      +----------+&lt;--calls-/
                | IdbAdapter |&lt;--remote#call--| IdbProxy |
                +------------+         #      +----------+
                oid='idb_adapter'      #

The purpose of the Proxy and Adapter classes is to translate certain
arguments and return values that cannot be transported through the RPC
barrier, in particular frame and traceback objects.

"""</t>
<t tx="ekr.20060521134346.59">def wrap_frame(frame):

    fid = id(frame)
    frametable[fid] = frame
    return fid
</t>
<t tx="ekr.20060521134346.60">def wrap_info(info):

    "replace info[2], a traceback instance, by its ID"
    if info is None:
        return None
    else:
        traceback = info[2]
        assert isinstance(traceback, types.TracebackType)
        traceback_id = id(traceback)
        tracebacktable[traceback_id] = traceback
        modified_info = (info[0], info[1], traceback_id)
        return modified_info
</t>
<t tx="ekr.20060521134346.61">class GUIProxy:
	@others
</t>
<t tx="ekr.20060521134346.62">def __init__(self, conn, gui_adap_oid):

    self.conn = conn
    self.oid = gui_adap_oid</t>
<t tx="ekr.20060521134346.63">def interaction(self, message, frame, info=None):
    
    '''calls rpc.SocketIO.remotecall() via run.MyHandler instance.

    passes frame and traceback object IDs instead of the objects themselves.'''
    
    print 'leoRemoteDebugger:interaction',message,frame
    
    self.conn.remotecall(
        self.oid, "interaction",
        (message, wrap_frame(frame), wrap_info(info)),
        {},
    )
</t>
<t tx="ekr.20060521134346.64">class IdbAdapter:
	@others
</t>
<t tx="ekr.20060521134346.65">def __init__(self, idb):

    self.idb = idb</t>
<t tx="ekr.20060521134346.66"></t>
<t tx="ekr.20060521134346.67">#--------------------

def set_step(self):
    self.idb.set_step()
</t>
<t tx="ekr.20060521134346.68">def set_quit(self):
    self.idb.set_quit()
</t>
<t tx="ekr.20060521134346.69">def set_continue(self):
    self.idb.set_continue()
</t>
<t tx="ekr.20060521134346.70">def set_next(self, fid):
    frame = frametable[fid]
    self.idb.set_next(frame)
</t>
<t tx="ekr.20060521134346.71">def set_return(self, fid):
    frame = frametable[fid]
    self.idb.set_return(frame)
</t>
<t tx="ekr.20060521134346.72">def get_stack(self, fid, tbid):
    ##print &gt;&gt;sys.__stderr__, "get_stack(%r, %r)" % (fid, tbid)
    frame = frametable[fid]
    if tbid is None:
        tb = None
    else:
        tb = tracebacktable[tbid]
    stack, i = self.idb.get_stack(frame, tb)
    ##print &gt;&gt;sys.__stderr__, "get_stack() -&gt;", stack
    stack = [(wrap_frame(frame), k) for frame, k in stack]
    ##print &gt;&gt;sys.__stderr__, "get_stack() -&gt;", stack
    return stack, i
</t>
<t tx="ekr.20060521134346.73">def run(self, cmd):

    self.idb.run(cmd, __main__.__dict__)</t>
<t tx="ekr.20060521134346.74">def set_break(self, filename, lineno):
    msg = self.idb.set_break(filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134346.75">def clear_break(self, filename, lineno):

    msg = self.idb.clear_break(filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134346.76">def clear_all_file_breaks(self, filename):
    msg = self.idb.clear_all_file_breaks(filename)
    return msg
</t>
<t tx="ekr.20060521134346.77"></t>
<t tx="ekr.20060521134346.78">def frame_attr(self, fid, name):

    frame = frametable[fid]
    return getattr(frame, name)
</t>
<t tx="ekr.20060521134346.79">def frame_globals(self, fid):
    frame = frametable[fid]
    dict = frame.f_globals
    did = id(dict)
    dicttable[did] = dict
    return did
</t>
<t tx="ekr.20060521134346.80">def frame_locals(self, fid):
    frame = frametable[fid]
    dict = frame.f_locals
    did = id(dict)
    dicttable[did] = dict
    return did
</t>
<t tx="ekr.20060521134346.81">def frame_code(self, fid):
    frame = frametable[fid]
    code = frame.f_code
    cid = id(code)
    codetable[cid] = code
    return cid
</t>
<t tx="ekr.20060521134346.82"></t>
<t tx="ekr.20060521134346.83">#----------called by a CodeProxy----------

def code_name(self, cid):
    code = codetable[cid]
    return code.co_name
</t>
<t tx="ekr.20060521134346.84">def code_filename(self, cid):
    code = codetable[cid]
    return code.co_filename
</t>
<t tx="ekr.20060521134346.85"></t>
<t tx="ekr.20060521134346.86">def dict_keys(self, did):
    dict = dicttable[did]
    return dict.keys()
</t>
<t tx="ekr.20060521134346.87">def dict_item(self, did, key):
    dict = dicttable[did]
    value = dict[key]
    value = repr(value)
    return value
</t>
<t tx="ekr.20060521134346.88">def start_debugger(rpchandler, gui_adap_oid):
    """Start the debugger and its RPC link in the Python subprocess

    Start the subprocess side of the split debugger and set up that side of the
    RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
    objects and linking them together.  Register the IdbAdapter with the
    RPCServer to handle RPC requests from the split debugger GUI via the
    IdbProxy.

    """
    
    print 'leo_RemoteDebugger: start_debugger'

    gui_proxy = GUIProxy(rpchandler, gui_adap_oid)
    ###idb = Debugger.Idb(gui_proxy)
    idb = leo_Debugger.Idb(gui_proxy)
    idb_adap = IdbAdapter(idb)
    rpchandler.register(idb_adap_oid, idb_adap)

    return idb_adap_oid</t>
<t tx="ekr.20060521134346.89"></t>
<t tx="ekr.20060521134346.90">class FrameProxy:
	@others
</t>
<t tx="ekr.20060521134346.91">def __init__(self, conn, fid):

    self._conn = conn
    self._fid = fid
    self._oid = "idb_adapter"
    self._dictcache = {}
</t>
<t tx="ekr.20060521134346.92">def __getattr__(self, name):
    if name[:1] == "_":
        raise AttributeError, name
    if name == "f_code":
        return self._get_f_code()
    if name == "f_globals":
        return self._get_f_globals()
    if name == "f_locals":
        return self._get_f_locals()
    return self._conn.remotecall(self._oid, "frame_attr",
                                 (self._fid, name), {})
</t>
<t tx="ekr.20060521134346.93">def _get_f_code(self):
    cid = self._conn.remotecall(self._oid, "frame_code", (self._fid,), {})
    return CodeProxy(self._conn, self._oid, cid)
</t>
<t tx="ekr.20060521134346.94">def _get_f_globals(self):
    did = self._conn.remotecall(self._oid, "frame_globals",
                                (self._fid,), {})
    return self._get_dict_proxy(did)
</t>
<t tx="ekr.20060521134346.95">def _get_f_locals(self):
    did = self._conn.remotecall(self._oid, "frame_locals",
                                (self._fid,), {})
    return self._get_dict_proxy(did)
</t>
<t tx="ekr.20060521134346.96">def _get_dict_proxy(self, did):
    if self._dictcache.has_key(did):
        return self._dictcache[did]
    dp = DictProxy(self._conn, self._oid, did)
    self._dictcache[did] = dp
    return dp
</t>
<t tx="ekr.20060521134346.97">class CodeProxy:
	@others
</t>
<t tx="ekr.20060521134346.98">def __init__(self, conn, oid, cid):

    self._conn = conn
    self._oid = oid
    self._cid = cid
</t>
<t tx="ekr.20060521134346.99">def __getattr__(self, name):
    if name == "co_name":
        return self._conn.remotecall(self._oid, "code_name",
                                     (self._cid,), {})
    if name == "co_filename":
        return self._conn.remotecall(self._oid, "code_filename",
                                     (self._cid,), {})
</t>
<t tx="ekr.20060521134346.100">class DictProxy:
	@others
</t>
<t tx="ekr.20060521134346.101">def __init__(self, conn, oid, did):

    self._conn = conn
    self._oid = oid
    self._did = did
</t>
<t tx="ekr.20060521134346.102">def keys(self):
    return self._conn.remotecall(self._oid, "dict_keys", (self._did,), {})
</t>
<t tx="ekr.20060521134346.103">def __getitem__(self, key):
    return self._conn.remotecall(self._oid, "dict_item",
                                 (self._did, key), {})
</t>
<t tx="ekr.20060521134346.104">def __getattr__(self, name):
    ##print &gt;&gt;sys.__stderr__, "failed DictProxy.__getattr__:", name
    raise AttributeError, name
</t>
<t tx="ekr.20060521134346.105">class GUIAdapter:
	@others
</t>
<t tx="ekr.20060521134346.106">def __init__(self, conn, gui):

    self.conn = conn
    self.gui = gui
</t>
<t tx="ekr.20060521134346.107">def interaction(self, message, fid, modified_info):

    ## print "interaction: (%s, %s, %s)" % (message, fid, modified_info)
    frame = FrameProxy(self.conn, fid)
    self.gui.interaction(message, frame, modified_info)</t>
<t tx="ekr.20060521134346.108">class IdbProxy:
	@others</t>
<t tx="ekr.20060521134346.109">### def __init__(self, conn, shell, oid):
    
def __init__(self, conn, interp, oid):

    self.oid = oid
    self.conn = conn
    ###self.shell = shell</t>
<t tx="ekr.20060521134346.110">def call(self, methodname, *args, **kwargs):
    ##print "**IdbProxy.call %s %s %s" % (methodname, args, kwargs)
    value = self.conn.remotecall(self.oid, methodname, args, kwargs)
    ##print "**IdbProxy.call %s returns %r" % (methodname, value)
    return value
</t>
<t tx="ekr.20060521134346.111">def run(self, cmd, locals):
    # Ignores locals on purpose!
    seq = self.conn.asyncqueue(self.oid, "run", (cmd,), {})
    ### self.shell.interp.active_seq = seq
    self.interp.active_seq = seq
</t>
<t tx="ekr.20060521134346.112">def get_stack(self, frame, tbid):
    # passing frame and traceback IDs, not the objects themselves
    stack, i = self.call("get_stack", frame._fid, tbid)
    stack = [(FrameProxy(self.conn, fid), k) for fid, k in stack]
    return stack, i
</t>
<t tx="ekr.20060521134346.113">def set_continue(self):
    self.call("set_continue")
</t>
<t tx="ekr.20060521134346.114">def set_step(self):
    self.call("set_step")
</t>
<t tx="ekr.20060521134346.115">def set_next(self, frame):
    self.call("set_next", frame._fid)
</t>
<t tx="ekr.20060521134346.116">def set_return(self, frame):
    self.call("set_return", frame._fid)
</t>
<t tx="ekr.20060521134346.117">def set_quit(self):
    self.call("set_quit")
</t>
<t tx="ekr.20060521134346.118">def set_break(self, filename, lineno):
    msg = self.call("set_break", filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134346.119">def clear_break(self, filename, lineno):
    msg = self.call("clear_break", filename, lineno)
    return msg
</t>
<t tx="ekr.20060521134346.120">def clear_all_file_breaks(self, filename):
    msg = self.call("clear_all_file_breaks", filename)
    return msg
</t>
<t tx="ekr.20060521134346.121">def start_remote_debugger (c,rpcclt,interp): ###, pyshell):
    """Start the subprocess debugger, initialize the debugger GUI and RPC link

    Request the RPCServer start the Python subprocess debugger and link.  Set
    up the Idle side of the split debugger by instantiating the IdbProxy,
    debugger GUI, and debugger GUIAdapter objects and linking them together.

    Register the GUIAdapter with the RPCClient to handle debugger GUI
    interaction requests coming from the subprocess debugger via the GUIProxy.

    The IdbAdapter will pass execution and environment requests coming from the
    Idle debugger GUI to the subprocess debugger via the IdbProxy.

    """
    global idb_adap_oid

    print 'leo_RemoteDebugger: idb_adap_oid',idb_adap_oid,'rpcclt',rpcclt

    idb_adap_oid = rpcclt.remotecall(
        "exec", "start_the_debugger",
        (gui_adap_oid,), {})
    # idb_proxy = IdbProxy(rpcclt, pyshell, idb_adap_oid)
    idb_proxy = IdbProxy(rpcclt,interp,idb_adap_oid)
    # gui = Debugger.Debugger(pyshell, idb_proxy)
    gui = leo_Debugger.Debugger(c,interp,idb_proxy)
    gui_adap = GUIAdapter(rpcclt,gui)
    rpcclt.register(gui_adap_oid,gui_adap)
    return gui</t>
<t tx="ekr.20060521134346.122">def close_remote_debugger(rpcClient):

    """Shut down subprocess debugger and Idle side of debugger RPC link

    Request that the RPCServer shut down the subprocess debugger and link.
    Unregister the GUIAdapter, which will cause a GC on the Idle process
    debugger and RPC link objects.  (The second reference to the debugger GUI
    is deleted in PyShell.close_remote_debugger().)

    """
    
    close_subprocess_debugger(rpcClient)
    rpcClient.unregister(gui_adap_oid)</t>
<t tx="ekr.20060521134346.123">def close_subprocess_debugger(rpcclt):
    
    rpcclt.remotecall(
        "exec", "stop_the_debugger",
        (idb_adap_oid,), {})

</t>
<t tx="ekr.20060521134346.124">def restart_subprocess_debugger(rpcclt):
    
    idb_adap_oid_ret = rpcclt.remotecall(
        "exec", "start_the_debugger",
        (gui_adap_oid,), {})
    
    assert idb_adap_oid_ret == idb_adap_oid, 'Idb restarted with different oid'</t>
<t tx="ekr.20060521134346.125">@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

LOCALHOST = '127.0.0.1'

@others</t>
<t tx="ekr.20060521134346.126">import leoGlobals as g

import leo_RemoteDebugger

from code import InteractiveInterpreter

import idlelib.rpc as rpc

import linecache
import os
import sys
import time</t>
<t tx="ekr.20060521134346.127">class ModifiedInterpreter(InteractiveInterpreter):

	@others</t>
<t tx="ekr.20060521134346.128">def __init__(self, tkconsole):

    self.tkconsole = tkconsole # Required by later rpc registrations.
    
    self.active_seq = None
    self.port = 8833
    self.rpcclt = None
    self.rpcpid = None
    
    locals = sys.modules['__main__'].__dict__
    InteractiveInterpreter.__init__(self, locals=locals)
    self.save_warnings_filters = None
    self.restarting = False

    self.subprocess_arglist = self.build_subprocess_arglist()</t>
<t tx="ekr.20060521134346.129">def spawn_subprocess(self):

    args = self.subprocess_arglist

    self.rpcpid = os.spawnv(os.P_NOWAIT, sys.executable, args)
    
    g.trace('os.spawnv returns rpcpid',self.rpcpid)</t>
<t tx="ekr.20060521134346.130">def build_subprocess_arglist(self):
    
    w = ['-W' + s for s in sys.warnoptions]
    # Maybe IDLE is installed and is being accessed via sys.path,
    # or maybe it's not installed and the idle.py script is being
    # run from the IDLE source directory.
    
    if 1: # EKR
        del_exitf = False
    else:
        del_exitf = idleConf.GetOption(
            'main', 'General', 'delete-exitfunc',
            default=False, type='bool')
    
    ###if __name__ == 'idlelib.PyShell':
    if 1: # Works only if leo/src is put in sys.path in sitecustomize or in the Python PATH variable.
        command = "__import__('leo_run').main(%r)" % (del_exitf,)
    elif 1: # EKR: Works using idlelib.run.  
        command = "__import__('idlelib.run').run.main(%r)" % (del_exitf,)
    else:
        command = "__import__('run').main(%r)" % (del_exitf,)
    if sys.platform[:3] == 'win' and ' ' in sys.executable:
        # handle embedded space in path by quoting the argument
        decorated_exec = '"%s"' % sys.executable
    else:
        decorated_exec = sys.executable
    
    return [decorated_exec] + w + ["-c", command, str(self.port)]</t>
<t tx="ekr.20060521134346.131">def start_subprocess(self):
    # spawning first avoids passing a listening socket to the subprocess
    self.spawn_subprocess()
    #time.sleep(20) # test to simulate GUI not accepting connection
    addr = (LOCALHOST, self.port)
    # Idle starts listening for connection on localhost
    for i in range(3):
        time.sleep(i)
        try:
            self.rpcclt = MyRPCClient(addr)
            g.trace(self.rpcclt)
            break
        except socket.error, err:
            pass
    else:
        self.display_port_binding_error()
        return None
    # Accept the connection from the Python execution server
    self.rpcclt.listening_sock.settimeout(10)
    try:
        self.rpcclt.accept()
    except socket.timeout, err:
        self.display_no_subprocess_error()
        return None
    self.rpcclt.register("stdin", self.tkconsole)
    self.rpcclt.register("stdout", self.tkconsole.stdout)
    self.rpcclt.register("stderr", self.tkconsole.stderr)
    self.rpcclt.register("flist", self.tkconsole.flist)
    self.rpcclt.register("linecache", linecache)
    self.rpcclt.register("interp", self)
    self.transfer_path()
    self.poll_subprocess()
    return self.rpcclt
</t>
<t tx="ekr.20060521134346.132">def restart_subprocess(self):
    if self.restarting:
        return self.rpcclt
    self.restarting = True
    # close only the subprocess debugger
    debug = self.getdebugger()
    if debug:
        try:
            # Only close subprocess debugger, don't unregister gui_adap!
            RemoteDebugger.close_subprocess_debugger(self.rpcclt)
        except:
            pass
    # Kill subprocess, spawn a new one, accept connection.
    self.rpcclt.close()
    self.unix_terminate()
    console = self.tkconsole
    was_executing = console.executing
    console.executing = False
    self.spawn_subprocess()
    try:
        self.rpcclt.accept()
    except socket.timeout, err:
        self.display_no_subprocess_error()
        return None
    self.transfer_path()
    # annotate restart in shell window and mark it
    console.text.delete("iomark", "end-1c")
    if was_executing:
        console.write('\n')
        console.showprompt()
    halfbar = ((int(console.width) - 16) // 2) * '='
    console.write(halfbar + ' RESTART ' + halfbar)
    console.text.mark_set("restart", "end-1c")
    console.text.mark_gravity("restart", "left")
    console.showprompt()
    # restart subprocess debugger
    if debug:
        # Restarted debugger connects to current instance of debug GUI
        gui = RemoteDebugger.restart_subprocess_debugger(self.rpcclt)
        # reload remote debugger breakpoints for all PyShellEditWindows
        debug.load_breakpoints()
    self.restarting = False
    return self.rpcclt
</t>
<t tx="ekr.20060521134346.133">def __request_interrupt(self):

    self.rpcclt.remotecall("exec", "interrupt_the_server", (), {})
</t>
<t tx="ekr.20060521134346.134">def interrupt_subprocess(self):
    threading.Thread(target=self.__request_interrupt).start()
</t>
<t tx="ekr.20060521134346.135">def kill_subprocess(self):
    
    try:
        self.rpcclt.close()
    except AttributeError:  # no socket
        pass
    self.unix_terminate()
    self.tkconsole.executing = False
    self.rpcclt = None

</t>
<t tx="ekr.20060521134346.136">def unix_terminate(self):
    "UNIX: make sure subprocess is terminated and collect status"
    if hasattr(os, 'kill'):
        try:
            os.kill(self.rpcpid, SIGTERM)
        except OSError:
            # process already terminated:
            return
        else:
            try:
                os.waitpid(self.rpcpid, 0)
            except OSError:
                return
</t>
<t tx="ekr.20060521134346.137">def transfer_path(self):
    self.runcommand("""if 1:
    import sys as _sys
    _sys.path = %r
    del _sys
    _msg = 'Use File/Exit or your end-of-file key to quit Leo'
    __builtins__.quit = __builtins__.exit = _msg
    del _msg
    \n""" % (sys.path,))
</t>
<t tx="ekr.20060521134346.138">def poll_subprocess(self):
    clt = self.rpcclt
    if clt is None:
        return
    try:
        response = clt.pollresponse(self.active_seq, wait=0.05)
    except (EOFError, IOError, KeyboardInterrupt):
        # lost connection or subprocess terminated itself, restart
        # [the KBI is from rpc.SocketIO.handle_EOF()]
        if self.tkconsole.closing:
            return
        response = None
        self.restart_subprocess()
    if response:
        self.tkconsole.resetoutput()
        self.active_seq = None
        how, what = response
        console = self.tkconsole.console
        if how == "OK":
            if what is not None:
                print &gt;&gt;console, repr(what)
        elif how == "EXCEPTION":
            if self.tkconsole.getvar(virtual_event_name('toggle-jit-stack-viewer')):
                self.remote_stack_viewer()
        elif how == "ERROR":
            errmsg = "PyShell.ModifiedInterpreter: Subprocess ERROR:\n"
            print &gt;&gt;sys.__stderr__, errmsg, what
            print &gt;&gt;console, errmsg, what
        # we received a response to the currently active seq number:
        self.tkconsole.endexecuting()
    # Reschedule myself
    if not self.tkconsole.closing:
        self.tkconsole.text.after(self.tkconsole.pollinterval,
                                  self.poll_subprocess)
</t>
<t tx="ekr.20060521134346.139">debugger = None

def setdebugger(self, debugger):
    self.debugger = debugger
</t>
<t tx="ekr.20060521134346.140">def getdebugger(self):
    return self.debugger
</t>
<t tx="ekr.20060521134346.141">def open_remote_stack_viewer(self):
    """Initiate the remote stack viewer from a separate thread.

    This method is called from the subprocess, and by returning from this
    method we allow the subprocess to unblock.  After a bit the shell
    requests the subprocess to open the remote stack viewer which returns a
    static object looking at the last exceptiopn.  It is queried through
    the RPC mechanism.

    """
    self.tkconsole.text.after(300, self.remote_stack_viewer)
    return
</t>
<t tx="ekr.20060521134346.142">def remote_stack_viewer(self):
    import RemoteObjectBrowser
    oid = self.rpcclt.remotequeue("exec", "stackviewer", ("flist",), {})
    if oid is None:
        self.tkconsole.root.bell()
        return
    item = RemoteObjectBrowser.StubObjectTreeItem(self.rpcclt, oid)
    from TreeWidget import ScrolledCanvas, TreeNode
    top = Toplevel(self.tkconsole.root)
    theme = idleConf.GetOption('main','Theme','name')
    background = idleConf.GetHighlight(theme, 'normal')['background']
    sc = ScrolledCanvas(top, bg=background, highlightthickness=0)
    sc.frame.pack(expand=1, fill="both")
    node = TreeNode(sc.canvas, None, item)
    node.expand()
</t>
<t tx="ekr.20060521134346.143">    # XXX Should GC the remote tree when closing the window

gid = 0

def execsource(self, source):
    "Like runsource() but assumes complete exec source"
    filename = self.stuffsource(source)
    self.execfile(filename, source)
</t>
<t tx="ekr.20060521134346.144">def execfile(self, filename, source=None):
    
    g.trace(filename)

    "Execute an existing file"
    if source is None:
        source = open(filename, "r").read()
    try:
        code = compile(source, filename, "exec")
    except (OverflowError, SyntaxError):
        self.tkconsole.resetoutput()
        tkerr = self.tkconsole.stderr
        print&gt;&gt;tkerr, '*** Error in script or command!\n'
        print&gt;&gt;tkerr, 'Traceback (most recent call last):'
        InteractiveInterpreter.showsyntaxerror(self, filename)
        self.tkconsole.showprompt()
    else:
        self.runcode(code)
</t>
<t tx="ekr.20060521134346.145">def runsource(self, source):
    "Extend base class method: Stuff the source in the line cache first"
    filename = self.stuffsource(source)
    self.more = 0
    self.save_warnings_filters = warnings.filters[:]
    warnings.filterwarnings(action="error", category=SyntaxWarning)
    if isinstance(source, types.UnicodeType):
        import IOBinding
        try:
            source = source.encode(IOBinding.encoding)
        except UnicodeError:
            self.tkconsole.resetoutput()
            self.write("Unsupported characters in input")
            return
    try:
        return InteractiveInterpreter.runsource(self, source, filename)
    finally:
        if self.save_warnings_filters is not None:
            warnings.filters[:] = self.save_warnings_filters
            self.save_warnings_filters = None
</t>
<t tx="ekr.20060521134346.146">def stuffsource(self, source):
    "Stuff source in the filename cache"
    filename = "&lt;pyshell#%d&gt;" % self.gid
    self.gid = self.gid + 1
    lines = source.split("\n")
    linecache.cache[filename] = len(source)+1, 0, lines, filename
    return filename
</t>
<t tx="ekr.20060521134346.147">def prepend_syspath(self, filename):
    "Prepend sys.path with file's directory if not already included"
    self.runcommand("""if 1:
        _filename = %r
        import sys as _sys
        from os.path import dirname as _dirname
        _dir = _dirname(_filename)
        if not _dir in _sys.path:
            _sys.path.insert(0, _dir)
        del _filename, _sys, _dirname, _dir
        \n""" % (filename,))
</t>
<t tx="ekr.20060521134346.148">def showsyntaxerror(self, filename=None):
    """Extend base class method: Add Colorizing

    Color the offending position instead of printing it and pointing at it
    with a caret.

    """
    text = self.tkconsole.text
    stuff = self.unpackerror()
    if stuff:
        msg, lineno, offset, line = stuff
        if lineno == 1:
            pos = "iomark + %d chars" % (offset-1)
        else:
            pos = "iomark linestart + %d lines + %d chars" % \
                  (lineno-1, offset-1)
        text.tag_add("ERROR", pos)
        text.see(pos)
        char = text.get(pos)
        if char and char in IDENTCHARS:
            text.tag_add("ERROR", pos + " wordstart", pos)
        self.tkconsole.resetoutput()
        self.write("SyntaxError: %s\n" % str(msg))
    else:
        self.tkconsole.resetoutput()
        InteractiveInterpreter.showsyntaxerror(self, filename)
    self.tkconsole.showprompt()
</t>
<t tx="ekr.20060521134346.149">def unpackerror(self):
    type, value, tb = sys.exc_info()
    ok = type is SyntaxError
    if ok:
        try:
            msg, (dummy_filename, lineno, offset, line) = value
            if not offset:
                offset = 0
        except:
            ok = 0
    if ok:
        return msg, lineno, offset, line
    else:
        return None
</t>
<t tx="ekr.20060521134346.150">def showtraceback(self):

    "Extend base class method to reset output properly"
    self.tkconsole.resetoutput()
    self.checklinecache()
    InteractiveInterpreter.showtraceback(self)
    if self.tkconsole.getvar(g.virtual_event_name('toggle-jit-stack-viewer')):
        self.tkconsole.open_stack_viewer()</t>
<t tx="ekr.20060521134346.151">def checklinecache(self):
    c = linecache.cache
    for key in c.keys():
        if key[:1] + key[-1:] != "&lt;&gt;":
            del c[key]
</t>
<t tx="ekr.20060521134346.152">def runcommand(self, code):
    "Run the code without invoking the debugger"
    # The code better not raise an exception!
    if self.tkconsole.executing:
        self.display_executing_dialog()
        return 0
    if self.rpcclt:
        self.rpcclt.remotequeue("exec", "runcode", (code,), {})
    else:
        exec code in self.locals
    return 1
</t>
<t tx="ekr.20060521134346.153">def runcode(self, code):
    "Override base class method"
    if self.tkconsole.executing:
        self.interp.restart_subprocess()
    self.checklinecache()
    if self.save_warnings_filters is not None:
        warnings.filters[:] = self.save_warnings_filters
        self.save_warnings_filters = None
    debugger = self.debugger
    try:
        self.tkconsole.beginexecuting()
        try:
            if not debugger and self.rpcclt is not None:
                self.active_seq = self.rpcclt.asyncqueue("exec", "runcode",
                                                        (code,), {})
            elif debugger:
                debugger.run(code, self.locals)
            else:
                exec code in self.locals
        except SystemExit:
            if tkMessageBox.askyesno(
                "Exit?",
                "Do you want to exit altogether?",
                default="yes",
                master=self.tkconsole.text):
                raise
            else:
                self.showtraceback()
        except:
            self.showtraceback()
    finally:
        if not use_subprocess:
            self.tkconsole.endexecuting()
</t>
<t tx="ekr.20060521134346.154">def write(self, s):
    "Override base class method"
    self.tkconsole.stderr.write(s)
</t>
<t tx="ekr.20060521134346.155">def display_port_binding_error(self):
    tkMessageBox.showerror(
        "Port Binding Error",
        "Leo can't bind TCP/IP port 8833, which is necessary to "
        "communicate with its Python execution server.  Either "
        "no networking is installed on this computer or another "
        "process (another Leo?) is using the port.  Run Leo with the -n "
        "command line switch to start without a subprocess and refer to "
        "Help/Leo Help 'Running without a subprocess' for further "
        "details.",
        master=self.tkconsole.text)
</t>
<t tx="ekr.20060521134346.156">def display_no_subprocess_error(self):
    tkMessageBox.showerror(
        "Subprocess Startup Error",
        "Leo's subprocess didn't make connection.  Either Leo can't "
        "start a subprocess or personal firewall software is blocking "
        "the connection.",
        master=self.tkconsole.text)
</t>
<t tx="ekr.20060521134346.157">def display_executing_dialog(self):
    
    if 1: ### EKR
        g.trace('Executing a command. Please wait until it is finished')
    else:
        tkMessageBox.showerror(
            "Already executing",
            "The Python Shell window is already executing a command; "
            "please wait until it is finished.",
            master=self.tkconsole.text)</t>
<t tx="ekr.20060521134346.158">def close_debugger(self):
    
    interp = self
    
    db = interp.getdebugger()
    if db:
        interp.setdebugger(None)
        db.close()
        if interp.rpcclt:
             leo_RemoteDebugger.close_remote_debugger(interp.rpcclt)
    
    if 0: # original code
        db = self.interp.getdebugger()
        if db:
            self.interp.setdebugger(None)
            db.close()
            if self.interp.rpcclt:
                RemoteDebugger.close_remote_debugger(self.interp.rpcclt)
            self.resetoutput()
            self.console.write("[DEBUG OFF]\n")
            sys.ps1 = "&gt;&gt;&gt; "
            self.showprompt()
        self.set_debugger_indicator()</t>
<t tx="ekr.20060521134346.159">class MyRPCClient(rpc.RPCClient):

	@others</t>
<t tx="ekr.20060521134346.160">def handle_EOF(self):

    "Override the base class - just re-raise EOFError"
    raise EOFError</t>
<t tx="ekr.20060521134346.161">&lt;&lt; imports &gt;&gt;

LOCALHOST = '127.0.0.1'

@others</t>
<t tx="ekr.20060521134346.162">import leoGlobals as g

import leo_FileList
import leo_run
import leo_RemoteDebugger
import leo_Shell

import idlelib.ScrolledList as ScrolledList

import bdb
import os
import socket
import sys
import time
import types

import Tkinter as Tk
import tkMessageBox

import __main__</t>
<t tx="ekr.20060521134346.163">def go (c):
    
    # From Pyshell.ctor
    interp = leo_Shell.ModifiedInterpreter(dummyShell(c))
    
    # From Pyshell.begin:
    client = interp.start_subprocess()
    g.trace('client',client,'interp',interp)
    open_debugger(c,interp.rpcclt,interp)</t>
<t tx="ekr.20060521134346.164">def open_debugger(c,rpcClient,interp):

    dbg_gui = leo_RemoteDebugger.start_remote_debugger(c,rpcClient,interp)
    interp.setdebugger(dbg_gui)
    dbg_gui.load_breakpoints()

    if 0: ### old code
        if self.interp.rpcclt:
            dbg_gui = RemoteDebugger.start_remote_debugger(self.interp.rpcclt,self)
        else:
            dbg_gui = Debugger.Debugger(self)
        self.interp.setdebugger(dbg_gui)
        dbg_gui.load_breakpoints()
        sys.ps1 = "[DEBUG ON]\n&gt;&gt;&gt; "
        self.showprompt()
        self.set_debugger_indicator()</t>
<t tx="ekr.20060521134346.165">class dummyShell:
    
    def __init__ (self,c):
        self.c = c
        self.stdout = sys.__stdout__
        self.stderr = sys.__stderr__
        self.flist = []
        self.closing = False
        self.executing = False
        self.text = Tk.Text() # Ignored completely
        self.pollinterval = 50  # millisec
        # g.trace('dummyShell')</t>
<t tx="ekr.20060521134346.166"># Important: this class is used by the remote debugger code.

class Idb(bdb.Bdb):
    
	@others
</t>
<t tx="ekr.20060521134346.167">def __init__(self, gui):

    self.gui = gui
    bdb.Bdb.__init__(self)</t>
<t tx="ekr.20060521134346.168">def user_line(self, frame):
    
    if self.in_rpc_code(frame):
        self.set_step()
    else:
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame)</t>
<t tx="ekr.20060521134346.169">def user_exception(self, frame, info):
    
    if self.in_rpc_code(frame):
        self.set_step()
    else:
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame, info)</t>
<t tx="ekr.20060521134346.170">def in_rpc_code(self, frame):

    if frame.f_code.co_filename.count('rpc.py'):
        return True
    else:
        prev_frame = frame.f_back
        if prev_frame.f_code.co_filename.count('Debugger.py'):
            # (that test will catch both Debugger.py and RemoteDebugger.py)
            return False
        return self.in_rpc_code(prev_frame)
</t>
<t tx="ekr.20060521134346.171">def __frame2message(self, frame):

    code = frame.f_code
    filename = code.co_filename
    lineno = frame.f_lineno
    basename = os.path.basename(filename)
    message = "%s:%s" % (basename, lineno)
    if code.co_name != "?":
        message = "%s: %s()" % (message, code.co_name)
    return message</t>
<t tx="ekr.20060521134346.172">class StackViewer(ScrolledList.ScrolledList):
	@others
</t>
<t tx="ekr.20060521134346.173">def __init__(self, master, flist, gui):
    
    g.trace('StackViewer: flist',flist,g.callers())
    
    ScrolledList.ScrolledList.__init__(self, master, width=80)
    self.flist = flist
    self.gui = gui
    self.stack = []</t>
<t tx="ekr.20060521134346.174">def load_stack(self, stack, index=None):
    self.stack = stack
    self.clear()
    for i in range(len(stack)):
        frame, lineno = stack[i]
        try:
            modname = frame.f_globals["__name__"]
        except:
            modname = "?"
        code = frame.f_code
        filename = code.co_filename
        funcname = code.co_name
        import linecache
        sourceline = linecache.getline(filename, lineno)
        import string
        sourceline = string.strip(sourceline)
        if funcname in ("?", "", None):
            item = "%s, line %d: %s" % (modname, lineno, sourceline)
        else:
            item = "%s.%s(), line %d: %s" % (modname, funcname,
                                             lineno, sourceline)
        if i == index:
            item = "&gt; " + item
        self.append(item)
    if index is not None:
        self.select(index)
</t>
<t tx="ekr.20060521134346.175">def popup_event(self, event):
    "override base method"
    if self.stack:
        return ScrolledList.ScrolledList.popup_event(self, event)
</t>
<t tx="ekr.20060521134346.176">def fill_menu(self):
    "override base method"
    menu = self.menu
    menu.add_command(label="Go to source line",
                     command=self.goto_source_line)
    menu.add_command(label="Show stack frame",
                     command=self.show_stack_frame)
</t>
<t tx="ekr.20060521134346.177">def on_select(self, index):
    "override base method"
    if 0 &lt;= index &lt; len(self.stack):
        self.gui.show_frame(self.stack[index])
</t>
<t tx="ekr.20060521134346.178">def on_double(self, index):
    "override base method"
    self.show_source(index)
</t>
<t tx="ekr.20060521134346.179">def goto_source_line(self):

    index = self.listbox.index("active")
    self.show_source(index)
</t>
<t tx="ekr.20060521134346.180">def show_stack_frame(self):
    index = self.listbox.index("active")
    if 0 &lt;= index &lt; len(self.stack):
        self.gui.show_frame(self.stack[index])
</t>
<t tx="ekr.20060521134346.181">def show_source(self, index):
    if not (0 &lt;= index &lt; len(self.stack)):
        return
    frame, lineno = self.stack[index]
    code = frame.f_code
    filename = code.co_filename
    if os.path.isfile(filename):
        edit = self.flist.open(filename)
        if edit:
            edit.gotoline(lineno)
</t>
<t tx="ekr.20060521134346.182">

class NamespaceViewer:
	@others
</t>
<t tx="ekr.20060521134346.183">def __init__(self, master, title, dict=None):
    
    g.trace('NamespaceViewer','dict',dict,g.callers())

    width = 0
    height = 40
    if dict:
        height = 20*len(dict) # XXX 20 == observed height of Entry widget
    self.master = master
    self.title = title
    import repr
    self.repr = repr.Repr()
    self.repr.maxstring = 60
    self.repr.maxother = 60
    self.frame = frame = Tk.Frame(master)
    self.frame.pack(expand=1, fill="both")
    self.label = Tk.Label(frame, text=title, borderwidth=2, relief="groove")
    self.label.pack(fill="x")
    self.vbar = vbar = Tk.Scrollbar(frame, name="vbar")
    vbar.pack(side="right", fill="y")
    self.canvas = canvas = Tk.Canvas(frame,
                                  height=min(300, max(40, height)),
                                  scrollregion=(0, 0, width, height))
    canvas.pack(side="left", fill="both", expand=1)
    vbar["command"] = canvas.yview
    canvas["yscrollcommand"] = vbar.set
    self.subframe = subframe = Tk.Frame(canvas)
    self.sfid = canvas.create_window(0, 0, window=subframe, anchor="nw")
    self.load_dict(dict)</t>
<t tx="ekr.20060521134346.184">dict = -1

def load_dict(self, dict, force=0, rpc_client=None):
    if dict is self.dict and not force:
        return
    subframe = self.subframe
    frame = self.frame
    for c in subframe.children.values():
        c.destroy()
    self.dict = None
    if not dict:
        l = Tk.Label(subframe, text="None")
        l.grid(row=0, column=0)
    else:
        names = dict.keys()
        names.sort()
        row = 0
        for name in names:
            value = dict[name]
            svalue = self.repr.repr(value) # repr(value)
            # Strip extra quotes caused by calling repr on the (already)
            # repr'd value sent across the RPC interface:
            if rpc_client:
                svalue = svalue[1:-1]
            l = Tk.Label(subframe, text=name)
            l.grid(row=row, column=0, sticky="nw")
            l = Entry(subframe, width=0, borderwidth=0)
            l.insert(0, svalue)
            l.grid(row=row, column=1, sticky="nw")
            row = row+1
    self.dict = dict
    # XXX Could we use a &lt;Configure&gt; callback for the following?
    subframe.update_idletasks() # Alas!
    width = subframe.winfo_reqwidth()
    height = subframe.winfo_reqheight()
    canvas = self.canvas
    self.canvas["scrollregion"] = (0, 0, width, height)
    if height &gt; 300:
        canvas["height"] = 300
        frame.pack(expand=1)
    else:
        canvas["height"] = height
        frame.pack(expand=0)

</t>
<t tx="ekr.20060521134346.185">def close(self):
    self.frame.destroy()
</t>
<t tx="ekr.20060521134346.186">class Debugger:

    vstack = vsource = vlocals = vglobals = None

    @others</t>
<t tx="ekr.20060521134346.187"></t>
<t tx="ekr.20060521134346.188">def __init__(self, c, interp, idb=None):
    
    self.c = c
    
    # Were inited as needed.
    self.globalsviewer = None
    self.interacting = 0
    self.localsviewer = None
    self.stackviewer = None

    ###self.pyshell = pyshell
    self.interp = interp
    self.idb = idb or Idb(self)
    self.frame = None
    
    ### self.flist = pyshell.flist
    self.flist = leo_FileList.FileList(c)
    self.make_gui()
    
    g.trace('Debugger',interp,self.idb)</t>
<t tx="ekr.20060521134346.189">def make_gui(self):
    
    &lt;&lt; create the top level frame &gt;&gt;
    &lt;&lt; create the control buttons &gt;&gt;
    &lt;&lt; create the check boxes &gt;&gt;
    #
    self.status = Tk.Label(top, anchor="w")
    self.status.pack(anchor="w")
    self.error = Tk.Label(top, anchor="w")
    self.error.pack(anchor="w", fill="x")
    self.errorbg = self.error.cget("background")
    #
    self.fstack = Tk.Frame(top, height=1)
    self.fstack.pack(expand=1, fill="both")
    self.flocals = Tk.Frame(top)
    self.flocals.pack(expand=1, fill="both")
    self.fglobals = Tk.Frame(top, height=1)
    self.fglobals.pack(expand=1, fill="both")
    #
    if self.vstack.get():
        self.show_stack()
    if self.vlocals.get():
        self.show_locals()
    if self.vglobals.get():
        self.show_globals()
</t>
<t tx="ekr.20060521134346.190">self.root = root = g.app.root
self.top = top = Tk.Toplevel(self.root)
top.title("Leo Debug Control")
top.wm_iconname("Debug")
top.wm_protocol("WM_DELETE_WINDOW", self.close)
# self.top.bind("&lt;Escape&gt;", self.close)</t>
<t tx="ekr.20060521134346.191">self.bframe = bframe = Tk.Frame(top)
self.bframe.pack(anchor="w")
self.buttons = bl = []
#
self.bcont = b = Tk.Button(bframe, text="Go", command=self.cont)
bl.append(b)
self.bstep = b = Tk.Button(bframe, text="Step", command=self.step)
bl.append(b)
self.bnext = b = Tk.Button(bframe, text="Over", command=self.next)
bl.append(b)
self.bret = b = Tk.Button(bframe, text="Out", command=self.ret)
bl.append(b)
self.bret = b = Tk.Button(bframe, text="Quit", command=self.quit)
bl.append(b)
#
for b in bl:
    b.configure(state="disabled")
    b.pack(side="left")</t>
<t tx="ekr.20060521134346.192">self.cframe = cframe = Tk.Frame(bframe)
self.cframe.pack(side="left")

if not self.vstack:
    self.__class__.vstack = Tk.BooleanVar(top)
    self.vstack.set(1)
self.bstack = Tk.Checkbutton(cframe,text="Stack",
    command = self.show_stack, variable = self.vstack)
self.bstack.grid(row=0,column=0)

if not self.vsource:
    self.__class__.vsource = Tk.BooleanVar(top)
self.bsource = Tk.Checkbutton(cframe,text="Source",
    command = self.show_source, variable = self.vsource)
self.bsource.grid(row=0,column=1)

if not self.vlocals:
    self.__class__.vlocals = Tk.BooleanVar(top)
    self.vlocals.set(1)
self.blocals = Tk.Checkbutton(cframe,text="Locals",
    command = self.show_locals, variable = self.vlocals)
self.blocals.grid(row=1,column=0)

if not self.vglobals:
    self.__class__.vglobals = Tk.BooleanVar(top)
self.bglobals = Tk.Checkbutton(cframe,text="Globals",
    command = self.show_globals, variable = self.vglobals)
self.bglobals.grid(row=1,column=1)</t>
<t tx="ekr.20060521134346.193">def run(self, *args):
    
    g.trace('Debugger',args)

    try:
        self.interacting = 1
        return self.idb.run(*args)
    finally:
        self.interacting = 0</t>
<t tx="ekr.20060521134346.194">def close(self, event=None):

    if self.interacting:
        self.top.bell()
    else:
        if self.stackviewer:
            self.stackviewer.close()
            self.stackviewer = None

        # Clean up pyshell if user clicked debugger control close widget.
        # (Causes a harmless extra cycle through close_debugger() if user
        # toggled debugger from pyshell Debug menu)
        ### self.pyshell.close_debugger()
        self.interp.close_debugger()
    
        # Now close the debugger control window....
        self.top.destroy()</t>
<t tx="ekr.20060521134346.195">def interaction(self, message, frame, info=None):
    
    g.trace('Debugger',message)
    self.frame = frame
    self.status.configure(text=message)

    if info:
        type, value, tb = info
        try:
            m1 = type.__name__
        except AttributeError:
            m1 = "%s" % str(type)
        if value is not None:
            try:
                m1 = "%s: %s" % (m1, str(value))
            except:
                pass
        bg = "yellow"
    else:
        m1 = ""
        tb = None
        bg = self.errorbg
    self.error.configure(text=m1, background=bg)
    #
    sv = self.stackviewer
    if sv:
        stack, i = self.idb.get_stack(self.frame, tb)
        sv.load_stack(stack, i)
    #
    self.show_variables(1)
    #
    if self.vsource.get():
        self.sync_source_line()
    #
    for b in self.buttons:
        b.configure(state="normal")
    #
    self.top.wakeup()
    self.root.mainloop()
    #
    for b in self.buttons:
        b.configure(state="disabled")
    self.status.configure(text="")
    self.error.configure(text="", background=self.errorbg)
    self.frame = None</t>
<t tx="ekr.20060521134346.196">def sync_source_line(self):
    
    frame = self.frame
    if not frame:
        return
    filename, lineno = self.__frame2fileline(frame)
    if filename[:1] + filename[-1:] != "&lt;&gt;" and os.path.exists(filename):
        g.trace(filename,lineno)
        if 0: ### Not yet
            f.gotoline(filename,lineno)
            # self.flist.gotofileline(filename, lineno)</t>
<t tx="ekr.20060521134346.197">def __frame2fileline(self, frame):
    code = frame.f_code
    filename = code.co_filename
    lineno = frame.f_lineno
    return filename, lineno
</t>
<t tx="ekr.20060521134346.198"></t>
<t tx="ekr.20060521134346.199">def cont(self):
    self.idb.set_continue()
    self.root.quit()
</t>
<t tx="ekr.20060521134346.200">def step(self):
    self.idb.set_step()
    self.root.quit()
</t>
<t tx="ekr.20060521134346.201">def next(self):
    self.idb.set_next(self.frame)
    self.root.quit()
</t>
<t tx="ekr.20060521134346.202">def ret(self):
    self.idb.set_return(self.frame)
    self.root.quit()
</t>
<t tx="ekr.20060521134346.203">def quit(self):

    self.idb.set_quit()
    self.root.quit()</t>
<t tx="ekr.20060521134346.204"></t>
<t tx="ekr.20060521134346.205">def show_stack(self):
    
    g.trace(self.stackviewer)

    if not self.stackviewer and self.vstack.get():
        self.stackviewer = sv = StackViewer(self.fstack, self.flist, self)
        if self.frame:
            stack, i = self.idb.get_stack(self.frame, None)
            sv.load_stack(stack, i)
    else:
        sv = self.stackviewer
        if sv and not self.vstack.get():
            self.stackviewer = None
            sv.close()
        self.fstack['height'] = 1
</t>
<t tx="ekr.20060521134346.206">def show_source(self):

    if self.vsource.get():
        self.sync_source_line()
</t>
<t tx="ekr.20060521134346.207">def show_frame(self, (frame, lineno)):

    self.frame = frame
    self.show_variables()
</t>
<t tx="ekr.20060521134346.208">def show_locals(self):

    lv = self.localsviewer
    if self.vlocals.get():
        if not lv:
            self.localsviewer = NamespaceViewer(self.flocals, "Locals")
    else:
        if lv:
            self.localsviewer = None
            lv.close()
            self.flocals['height'] = 1
    self.show_variables()
</t>
<t tx="ekr.20060521134346.209">def show_globals(self):
    
    gv = self.globalsviewer
    if self.vglobals.get():
        if not gv:
            self.globalsviewer = NamespaceViewer(self.fglobals, "Globals")
    else:
        if gv:
            self.globalsviewer = None
            gv.close()
            self.fglobals['height'] = 1
    self.show_variables()

</t>
<t tx="ekr.20060521134346.210">def show_variables(self, force=0):

    lv = self.localsviewer
    gv = self.globalsviewer
    frame = self.frame
    if not frame:
        ldict = gdict = None
    else:
        ldict = frame.f_locals
        gdict = frame.f_globals
        if lv and gv and ldict is gdict:
            ldict = None

    if 1:
        if lv:
            ### lv.load_dict(ldict, force, self.pyshell.interp.rpcclt)
            lv.load_dict(ldict, force, self.interp.rpcclt)
        if gv:
            ### gv.load_dict(gdict, force, self.pyshell.interp.rpcclt)
            gv.load_dict(gdict, force, self.interp.rpcclt)
</t>
<t tx="ekr.20060521134346.211"></t>
<t tx="ekr.20060521134346.212">def set_breakpoint_here(self, filename, lineno):

    self.idb.set_break(filename, lineno)</t>
<t tx="ekr.20060521134346.213">def clear_breakpoint_here(self, filename, lineno):

    self.idb.clear_break(filename, lineno)
</t>
<t tx="ekr.20060521134346.214">def clear_file_breaks(self, filename):
    
    self.idb.clear_all_file_breaks(filename)

</t>
<t tx="ekr.20060521134346.215">def load_breakpoints(self):
    
    g.trace()
    
    if 0: # "Load PyShellEditorWindow breakpoints into subprocess debugger"
        pyshell_edit_windows = self.pyshell.flist.inversedict.keys()
        for editwin in pyshell_edit_windows:
            filename = editwin.io.filename
            try:
                for lineno in editwin.breakpoints:
                    self.set_breakpoint_here(filename, lineno)
            except AttributeError:
                continue</t>
<t tx="ekr.20060521134346.216">@language python
@tabwidth -4

import leoGlobals as g

import os
# from Tkinter import *
# import tkMessageBox

@others</t>
<t tx="ekr.20060521134346.217">class FileList:
    
    '''Maintain a list of open files being handled by the IDE.
    
    For Leo, this probably should be all @file nodes.'''
    
    
    if 0:
	    from EditorWindow import EditorWindow
            # class variable, may be overridden
            # e.g. by PyShellFileList

	@others</t>
<t tx="ekr.20060521134346.218">def __init__(self, c): # was root
    
    g.trace('FileList',g.callers())
    
    self.c = c
    self.p = p = c.currentPosition()
    
    if 1:
        if p.isAnyAtFileNode():
            g.trace(p.headString())
            self.open(p)
    else:
        for p in c.allNodes_iter():
            if p.isAnyAtFileNode():
                g.trace(p.headString())
    
    if 0: # No longer needed.  All the work will be done in g.gotolline.
        self.dict = {}
        self.inversedict = {}
        self.vars = {} # For EditorWindow.getrawvar (shared Tcl variables)</t>
<t tx="ekr.20060521134346.219">def open(self, filename, action=None):
    
    assert filename
    filename = self.canonize(filename)
    if os.path.isdir(filename):
        # This can happen when bad filename is passed on command line.
        return g.es_print('%s is a directory' % (filename),color='red')
        
    key = os.path.normcase(filename)
    g.trace(key)
    return key # EKR

    if 0:
        if self.dict.has_key(key):
            edit = self.dict[key]
            edit.top.wakeup()
            return edit
        if action:
            # Don't create window, perform 'action', e.g. open in same window
            return action(filename)
        else:
            return self.EditorWindow(self, filename, key)</t>
<t tx="ekr.20060521134346.220">def gotofileline(self, filename, lineno=None):
    
    g.trace(filename,lineno)
    
    if 1: # Leo-centric code.
        filename = self.open(filename)
        if filename:
            g.trace(filename,lineno)
            # g.gotoline(lineno)
        
    else: # IDLE-centric code.
        edit = self.open(filename)
        if edit is not None and lineno is not None:
            edit.gotoline(lineno)</t>
<t tx="ekr.20060521134346.221">def new(self, filename=None):
    
    g.trace(filename)
    
    return None

    # return self.EditorWindow(self, filename)
</t>
<t tx="ekr.20060521134346.222">def close_all_callback(self, event):
    
    g.trace()
    
    if 0: # The Leo editor never closes
        for edit in self.inversedict.keys():
            reply = edit.close()
            if reply == "cancel":
                break

    return "break"</t>
<t tx="ekr.20060521134346.223">def close_edit(self, edit):
    
    g.trace(edit)
    
    if 0: # The Leo editor never quits.
        try:
            key = self.inversedict[edit]
        except KeyError:
            print "Don't know this EditorWindow object.  (close)"
            return
        if key:
            del self.dict[key]
        del self.inversedict[edit]
        if not self.inversedict:
            self.root.quit()</t>
<t tx="ekr.20060521134346.224">def filename_changed_edit(self, edit):
    
    g.trace(edit)
    
    if 0: # Probably not needed for Leo.
        edit.saved_change_hook()
        try:
            key = self.inversedict[edit]
        except KeyError:
            print "Don't know this EditorWindow object.  (rename)"
            return
        filename = edit.io.filename
        if not filename:
            if key:
                del self.dict[key]
            self.inversedict[edit] = None
            return
        filename = self.canonize(filename)
        newkey = os.path.normcase(filename)
        if newkey == key:
            return
        if self.dict.has_key(newkey):
            conflict = self.dict[newkey]
            self.inversedict[conflict] = None
            tkMessageBox.showerror(
                "Name Conflict",
                "You now have multiple edit windows open for %r" % (filename,),
                master=self.root)
        self.dict[newkey] = edit
        self.inversedict[edit] = newkey
        if key:
            try:
                del self.dict[key]
            except KeyError:
                pass
    </t>
<t tx="ekr.20060521134346.225">def canonize(self, filename):

    if not os.path.isabs(filename):
        try:
            pwd = os.getcwd()
        except os.error:
            pass
        else:
            filename = os.path.join(pwd, filename)

    return os.path.normpath(filename)
</t>
<t tx="ekr.20060521134346.226">def _test():
    
    if 0:
        from EditorWindow import fixwordbreaks
        import sys
        root = Tk()
        
        fixwordbreaks(root)
        root.withdraw()
        flist = FileList(root)
        if sys.argv[1:]:
            for filename in sys.argv[1:]:
                flist.open(filename)
        else:
            flist.new()
        if flist.inversedict:
            root.mainloop()
    </t>
<t tx="ekr.20060523070341">@nocolor

The standard disclaimer for Leo study outlines:

These sources are for **study only**. They may, or may not, correspond faithfully to the originals.</t>
<t tx="ekr.20060526070950"></t>
<t tx="ekr.20060526070950.1"></t>
</tnodes>
</leo_file>
