<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20190302133319.1"><vh>pywasm</vh>
<v t="ekr.20190302133319.2"><vh>@@clean __init__.py</vh>
<v t="ekr.20190302133319.4"><vh>class VirtualMachine</vh>
<v t="ekr.20190302133319.5"><vh>VirtualMachine.__init__</vh></v>
<v t="ekr.20190302133319.6"><vh>VirtualMachine.func_addr</vh></v>
<v t="ekr.20190302133319.7"><vh>VirtualMachine.exec</vh></v>
</v>
<v t="ekr.20190302133319.8"><vh>on_debug</vh></v>
<v t="ekr.20190302133319.9"><vh>load</vh></v>
</v>
<v t="ekr.20190302133319.10"><vh>@@clean common.py</vh>
<v t="ekr.20190302133319.11"><vh>read_count</vh></v>
<v t="ekr.20190302133319.12"><vh>read_bytes</vh></v>
</v>
<v t="ekr.20190302133319.13"><vh>@@clean execution.py</vh>
<v t="ekr.20190302133319.14"><vh>class Store</vh>
<v t="ekr.20190302133319.15"><vh>Store.__init__</vh></v>
</v>
<v t="ekr.20190302133319.16"><vh>class FunctionInstance</vh></v>
<v t="ekr.20190302133319.17"><vh>class WasmFunc(FunctionInstance)</vh>
<v t="ekr.20190302133319.18"><vh>WasmFunc.__init__</vh></v>
</v>
<v t="ekr.20190302133319.19"><vh>class HostFunc(FunctionInstance)</vh>
<v t="ekr.20190302133319.20"><vh>HostFunc.__init__</vh></v>
</v>
<v t="ekr.20190302133319.21"><vh>class TableInstance</vh>
<v t="ekr.20190302133319.22"><vh>TableInstance.__init__</vh></v>
</v>
<v t="ekr.20190302133319.23"><vh>class MemoryInstance</vh>
<v t="ekr.20190302133319.24"><vh>MemoryInstance.__init__</vh></v>
<v t="ekr.20190302133319.25"><vh>MemoryInstance.grow</vh></v>
</v>
<v t="ekr.20190302133319.26"><vh>class GlobalInstance</vh>
<v t="ekr.20190302133319.27"><vh>GlobalInstance.__init__</vh></v>
</v>
<v t="ekr.20190302133319.28"><vh>class ExportInstance</vh>
<v t="ekr.20190302133319.29"><vh>ExportInstance.__init__</vh></v>
</v>
<v t="ekr.20190302133319.30"><vh>class ExternValue</vh>
<v t="ekr.20190302133319.31"><vh>ExternValue.__init__</vh></v>
</v>
<v t="ekr.20190302133319.32"><vh>class Value</vh>
<v t="ekr.20190302133319.33"><vh>Value.__init__</vh></v>
<v t="ekr.20190302133319.34"><vh>Value.__repr__</vh></v>
<v t="ekr.20190302133319.35"><vh>Value.from_i32</vh></v>
<v t="ekr.20190302133319.36"><vh>Value.from_i64</vh></v>
<v t="ekr.20190302133319.37"><vh>Value.from_f32</vh></v>
<v t="ekr.20190302133319.38"><vh>Value.from_f64</vh></v>
</v>
<v t="ekr.20190302133319.39"><vh>class Label</vh>
<v t="ekr.20190302133319.40"><vh>Label.__init__</vh></v>
<v t="ekr.20190302133319.41"><vh>Label.__repr__</vh></v>
</v>
<v t="ekr.20190302133319.42"><vh>class Frame</vh>
<v t="ekr.20190302133319.43"><vh>Frame.__init__</vh></v>
<v t="ekr.20190302133319.44"><vh>Frame.__repr__</vh></v>
</v>
<v t="ekr.20190302133319.45"><vh>class Stack</vh>
<v t="ekr.20190302133319.46"><vh>Stack.__init__</vh></v>
<v t="ekr.20190302133319.47"><vh>Stack.__repr__</vh></v>
<v t="ekr.20190302133319.48"><vh>Stack.add</vh></v>
<v t="ekr.20190302133319.49"><vh>Stack.ext</vh></v>
<v t="ekr.20190302133319.50"><vh>Stack.pop</vh></v>
<v t="ekr.20190302133319.51"><vh>Stack.len</vh></v>
<v t="ekr.20190302133319.52"><vh>Stack.top</vh></v>
<v t="ekr.20190302133319.53"><vh>Stack.status</vh></v>
</v>
<v t="ekr.20190302133319.54"><vh>class AdministrativeInstruction</vh></v>
<v t="ekr.20190302133319.55"><vh>class BlockContext</vh></v>
<v t="ekr.20190302133319.56"><vh>class Configuration</vh></v>
<v t="ekr.20190302133319.57"><vh>class EvaluationContext</vh></v>
<v t="ekr.20190302133319.58"><vh>import_matching_limits</vh></v>
<v t="ekr.20190302133319.59"><vh>class ModuleInstance</vh>
<v t="ekr.20190302133319.60"><vh>ModuleInstance.__init__</vh></v>
<v t="ekr.20190302133319.61"><vh>ModuleInstance.instantiate</vh></v>
<v t="ekr.20190302133319.62"><vh>ModuleInstance.allocate</vh></v>
</v>
<v t="ekr.20190302133319.63"><vh>hostfunc_call</vh></v>
<v t="ekr.20190302133319.64"><vh>wasmfunc_call</vh></v>
<v t="ekr.20190302133319.65"><vh>call</vh></v>
<v t="ekr.20190302133319.66"><vh>spec_br</vh></v>
<v t="ekr.20190302133319.67"><vh>exec_expr</vh></v>
</v>
<v t="ekr.20190302133319.68"><vh>@@clean log.py</vh>
<v t="ekr.20190302133319.69"><vh>debugln</vh></v>
<v t="ekr.20190302133319.70"><vh>println</vh></v>
<v t="ekr.20190302133319.71"><vh>panicln</vh></v>
<v t="ekr.20190302133319.72"><vh>fatalln</vh></v>
</v>
<v t="ekr.20190302133319.73"><vh>@@clean num.py</vh>
<v t="ekr.20190302133319.74"><vh>int2u8</vh></v>
<v t="ekr.20190302133319.75"><vh>int2i8</vh></v>
<v t="ekr.20190302133319.76"><vh>int2u16</vh></v>
<v t="ekr.20190302133319.77"><vh>int2i16</vh></v>
<v t="ekr.20190302133319.78"><vh>int2u32</vh></v>
<v t="ekr.20190302133319.79"><vh>int2i32</vh></v>
<v t="ekr.20190302133319.80"><vh>int2u64</vh></v>
<v t="ekr.20190302133319.81"><vh>int2i64</vh></v>
<v t="ekr.20190302133319.82"><vh>i322f32</vh></v>
<v t="ekr.20190302133319.83"><vh>f322i32</vh></v>
<v t="ekr.20190302133319.84"><vh>i642f64</vh></v>
<v t="ekr.20190302133319.85"><vh>f642i64</vh></v>
<v t="ekr.20190302133319.86"><vh>class LittleEndian</vh>
<v t="ekr.20190302133319.87"><vh>LittleEndian.u8</vh></v>
<v t="ekr.20190302133319.88"><vh>LittleEndian.i8</vh></v>
<v t="ekr.20190302133319.89"><vh>LittleEndian.u16</vh></v>
<v t="ekr.20190302133319.90"><vh>LittleEndian.i16</vh></v>
<v t="ekr.20190302133319.91"><vh>LittleEndian.u32</vh></v>
<v t="ekr.20190302133319.92"><vh>LittleEndian.i32</vh></v>
<v t="ekr.20190302133319.93"><vh>LittleEndian.u64</vh></v>
<v t="ekr.20190302133319.94"><vh>LittleEndian.i64</vh></v>
<v t="ekr.20190302133319.95"><vh>LittleEndian.f32</vh></v>
<v t="ekr.20190302133319.96"><vh>LittleEndian.f64</vh></v>
<v t="ekr.20190302133319.97"><vh>LittleEndian.pack_u8</vh></v>
<v t="ekr.20190302133319.98"><vh>LittleEndian.pack_i8</vh></v>
<v t="ekr.20190302133319.99"><vh>LittleEndian.pack_u16</vh></v>
<v t="ekr.20190302133319.100"><vh>LittleEndian.pack_i16</vh></v>
<v t="ekr.20190302133319.101"><vh>LittleEndian.pack_u32</vh></v>
<v t="ekr.20190302133319.102"><vh>LittleEndian.pack_i32</vh></v>
<v t="ekr.20190302133319.103"><vh>LittleEndian.pack_u64</vh></v>
<v t="ekr.20190302133319.104"><vh>LittleEndian.pack_i64</vh></v>
<v t="ekr.20190302133319.105"><vh>LittleEndian.pack_f32</vh></v>
<v t="ekr.20190302133319.106"><vh>LittleEndian.pack_f64</vh></v>
</v>
<v t="ekr.20190302133319.107"><vh>class BigEndian</vh>
<v t="ekr.20190302133319.108"><vh>BigEndian.u8</vh></v>
<v t="ekr.20190302133319.109"><vh>BigEndian.i8</vh></v>
<v t="ekr.20190302133319.110"><vh>BigEndian.u16</vh></v>
<v t="ekr.20190302133319.111"><vh>BigEndian.i16</vh></v>
<v t="ekr.20190302133319.112"><vh>BigEndian.u32</vh></v>
<v t="ekr.20190302133319.113"><vh>BigEndian.i32</vh></v>
<v t="ekr.20190302133319.114"><vh>BigEndian.u64</vh></v>
<v t="ekr.20190302133319.115"><vh>BigEndian.i64</vh></v>
<v t="ekr.20190302133319.116"><vh>BigEndian.f32</vh></v>
<v t="ekr.20190302133319.117"><vh>BigEndian.f64</vh></v>
<v t="ekr.20190302133319.118"><vh>BigEndian.pack_u8</vh></v>
<v t="ekr.20190302133319.119"><vh>BigEndian.pack_i8</vh></v>
<v t="ekr.20190302133319.120"><vh>BigEndian.pack_u16</vh></v>
<v t="ekr.20190302133319.121"><vh>BigEndian.pack_i16</vh></v>
<v t="ekr.20190302133319.122"><vh>BigEndian.pack_u32</vh></v>
<v t="ekr.20190302133319.123"><vh>BigEndian.pack_i32</vh></v>
<v t="ekr.20190302133319.124"><vh>BigEndian.pack_u64</vh></v>
<v t="ekr.20190302133319.125"><vh>BigEndian.pack_i64</vh></v>
<v t="ekr.20190302133319.126"><vh>BigEndian.pack_f32</vh></v>
<v t="ekr.20190302133319.127"><vh>BigEndian.pack_f64</vh></v>
</v>
<v t="ekr.20190302133319.128"><vh>leb</vh></v>
<v t="ekr.20190302133319.129"><vh>rotl_u32</vh></v>
<v t="ekr.20190302133319.130"><vh>rotl_u64</vh></v>
<v t="ekr.20190302133319.131"><vh>rotr_u32</vh></v>
<v t="ekr.20190302133319.132"><vh>rotr_u64</vh></v>
<v t="ekr.20190302133319.133"><vh>idiv_s</vh></v>
<v t="ekr.20190302133319.134"><vh>irem_s</vh></v>
</v>
<v t="ekr.20190302133319.135"><vh>@@clean structure.py</vh>
<v t="ekr.20190302133319.136"><vh>class FunctionType</vh>
<v t="ekr.20190302133319.137"><vh>FunctionType.__init__</vh></v>
<v t="ekr.20190302133319.138"><vh>FunctionType.__repr__</vh></v>
<v t="ekr.20190302133319.139"><vh>FunctionType.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.140"><vh>class ResultType</vh></v>
<v t="ekr.20190302133319.141"><vh>class Limits</vh>
<v t="ekr.20190302133319.142"><vh>Limits.__init__</vh></v>
<v t="ekr.20190302133319.143"><vh>Limits.__repr__</vh></v>
<v t="ekr.20190302133319.144"><vh>Limits.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.145"><vh>class MemoryType</vh>
<v t="ekr.20190302133319.146"><vh>MemoryType.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.147"><vh>class TableType</vh>
<v t="ekr.20190302133319.148"><vh>TableType.__init__</vh></v>
<v t="ekr.20190302133319.149"><vh>TableType.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.150"><vh>class GlobalType</vh>
<v t="ekr.20190302133319.151"><vh>GlobalType.__init__</vh></v>
<v t="ekr.20190302133319.152"><vh>GlobalType.__repr__</vh></v>
<v t="ekr.20190302133319.153"><vh>GlobalType.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.154"><vh>class ExternType</vh></v>
<v t="ekr.20190302133319.155"><vh>class Instruction</vh>
<v t="ekr.20190302133319.156"><vh>Instruction.__init__</vh></v>
<v t="ekr.20190302133319.157"><vh>Instruction.__repr__</vh></v>
<v t="ekr.20190302133319.158"><vh>Instruction.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.159"><vh>class Expression</vh>
<v t="ekr.20190302133319.160"><vh>Expression.__init__</vh></v>
<v t="ekr.20190302133319.161"><vh>Expression.compose</vh></v>
<v t="ekr.20190302133319.162"><vh>Expression.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.163"><vh>class Locals</vh>
<v t="ekr.20190302133319.164"><vh>Locals.__init__</vh></v>
<v t="ekr.20190302133319.165"><vh>Locals.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.166"><vh>class Code</vh>
<v t="ekr.20190302133319.167"><vh>Code.__init__</vh></v>
<v t="ekr.20190302133319.168"><vh>Code.__repr__</vh></v>
<v t="ekr.20190302133319.169"><vh>Code.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.170"><vh>class Function</vh>
<v t="ekr.20190302133319.171"><vh>Function.__init__</vh></v>
</v>
<v t="ekr.20190302133319.172"><vh>class Table</vh>
<v t="ekr.20190302133319.173"><vh>Table.__init__</vh></v>
<v t="ekr.20190302133319.174"><vh>Table.__repr__</vh></v>
<v t="ekr.20190302133319.175"><vh>Table.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.176"><vh>class Memory</vh>
<v t="ekr.20190302133319.177"><vh>Memory.__init__</vh></v>
<v t="ekr.20190302133319.178"><vh>Memory.__repr__</vh></v>
<v t="ekr.20190302133319.179"><vh>Memory.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.180"><vh>class Global</vh>
<v t="ekr.20190302133319.181"><vh>Global.__init__</vh></v>
<v t="ekr.20190302133319.182"><vh>Global.__repr__</vh></v>
<v t="ekr.20190302133319.183"><vh>Global.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.184"><vh>class ElementSegment</vh>
<v t="ekr.20190302133319.185"><vh>ElementSegment.__init__</vh></v>
<v t="ekr.20190302133319.186"><vh>ElementSegment.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.187"><vh>class DataSegment</vh>
<v t="ekr.20190302133319.188"><vh>DataSegment.__init__</vh></v>
<v t="ekr.20190302133319.189"><vh>DataSegment.__repr__</vh></v>
<v t="ekr.20190302133319.190"><vh>DataSegment.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.191"><vh>class StartFunction</vh>
<v t="ekr.20190302133319.192"><vh>StartFunction.__init__</vh></v>
<v t="ekr.20190302133319.193"><vh>StartFunction.__repr__</vh></v>
<v t="ekr.20190302133319.194"><vh>StartFunction.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.195"><vh>class Export</vh>
<v t="ekr.20190302133319.196"><vh>Export.__init__</vh></v>
<v t="ekr.20190302133319.197"><vh>Export.__repr__</vh></v>
<v t="ekr.20190302133319.198"><vh>Export.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.199"><vh>class Import</vh>
<v t="ekr.20190302133319.200"><vh>Import.__init__</vh></v>
<v t="ekr.20190302133319.201"><vh>Import.__repr__</vh></v>
<v t="ekr.20190302133319.202"><vh>Import.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.203"><vh>class CustomSection</vh>
<v t="ekr.20190302133319.204"><vh>CustomSection.__init__</vh></v>
<v t="ekr.20190302133319.205"><vh>CustomSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.206"><vh>class TypeSection</vh>
<v t="ekr.20190302133319.207"><vh>TypeSection.__init__</vh></v>
<v t="ekr.20190302133319.208"><vh>TypeSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.209"><vh>class ImportSection</vh>
<v t="ekr.20190302133319.210"><vh>ImportSection.__init__</vh></v>
<v t="ekr.20190302133319.211"><vh>ImportSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.212"><vh>class FunctionSection</vh>
<v t="ekr.20190302133319.213"><vh>FunctionSection.__init__</vh></v>
<v t="ekr.20190302133319.214"><vh>FunctionSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.215"><vh>class TableSection</vh>
<v t="ekr.20190302133319.216"><vh>TableSection.__init__</vh></v>
<v t="ekr.20190302133319.217"><vh>TableSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.218"><vh>class MemorySection</vh>
<v t="ekr.20190302133319.219"><vh>MemorySection.__init__</vh></v>
<v t="ekr.20190302133319.220"><vh>MemorySection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.221"><vh>class GlobalSection</vh>
<v t="ekr.20190302133319.222"><vh>GlobalSection.__init__</vh></v>
<v t="ekr.20190302133319.223"><vh>GlobalSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.224"><vh>class ExportSection</vh>
<v t="ekr.20190302133319.225"><vh>ExportSection.__init__</vh></v>
<v t="ekr.20190302133319.226"><vh>ExportSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.227"><vh>class StartSection</vh>
<v t="ekr.20190302133319.228"><vh>StartSection.__init__</vh></v>
<v t="ekr.20190302133319.229"><vh>StartSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.230"><vh>class ElementSection</vh>
<v t="ekr.20190302133319.231"><vh>ElementSection.__init__</vh></v>
<v t="ekr.20190302133319.232"><vh>ElementSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.233"><vh>class CodeSection</vh>
<v t="ekr.20190302133319.234"><vh>CodeSection.__init__</vh></v>
<v t="ekr.20190302133319.235"><vh>CodeSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.236"><vh>class DataSection</vh>
<v t="ekr.20190302133319.237"><vh>DataSection.__init__</vh></v>
<v t="ekr.20190302133319.238"><vh>DataSection.from_reader</vh></v>
</v>
<v t="ekr.20190302133319.239"><vh>class Module</vh>
<v t="ekr.20190302133319.240"><vh>Module.__init__</vh></v>
<v t="ekr.20190302133319.241"><vh>Module.load</vh></v>
<v t="ekr.20190302133319.242"><vh>Module.from_reader</vh></v>
</v>
</v>
<v t="ekr.20190302133319.243"><vh>@@edit convention.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20190302133319.1"></t>
<t tx="ekr.20190302133319.10">@path C:/leo.repo/pywasm/pywasm/
from pywasm import num

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.100">@staticmethod
def pack_i16(n: i16):
    return struct.pack('&lt;h', n)

</t>
<t tx="ekr.20190302133319.101">@staticmethod
def pack_u32(n: u32):
    return struct.pack('&lt;I', n)

</t>
<t tx="ekr.20190302133319.102">@staticmethod
def pack_i32(n: i32):
    return struct.pack('&lt;i', n)

</t>
<t tx="ekr.20190302133319.103">@staticmethod
def pack_u64(n: u64):
    return struct.pack('&lt;Q', n)

</t>
<t tx="ekr.20190302133319.104">@staticmethod
def pack_i64(n: i64):
    return struct.pack('&lt;q', n)

</t>
<t tx="ekr.20190302133319.105">@staticmethod
def pack_f32(n: f32):
    return struct.pack('&lt;f', n)

</t>
<t tx="ekr.20190302133319.106">@staticmethod
def pack_f64(n: f64):
    return struct.pack('&lt;d', n)


</t>
<t tx="ekr.20190302133319.107">class BigEndian:
    @others
</t>
<t tx="ekr.20190302133319.108">@staticmethod
def u8(r: bytes):
    return struct.unpack('&gt;B', r)[0]

</t>
<t tx="ekr.20190302133319.109">@staticmethod
def i8(r: bytes):
    return struct.unpack('&gt;b', r)[0]

</t>
<t tx="ekr.20190302133319.11">def read_count(reader, maxbits=32, signed=False) -&gt; int:
    return num.leb(reader, maxbits, signed)[1]


</t>
<t tx="ekr.20190302133319.110">@staticmethod
def u16(r: bytes):
    return struct.unpack('&gt;H', r)[0]

</t>
<t tx="ekr.20190302133319.111">@staticmethod
def i16(r: bytes):
    return struct.unpack('&gt;h', r)[0]

</t>
<t tx="ekr.20190302133319.112">@staticmethod
def u32(r: bytes):
    return struct.unpack('&gt;I', r)[0]

</t>
<t tx="ekr.20190302133319.113">@staticmethod
def i32(r: bytes):
    return struct.unpack('&gt;i', r)[0]

</t>
<t tx="ekr.20190302133319.114">@staticmethod
def u64(r: bytes):
    return struct.unpack('&gt;Q', r)[0]

</t>
<t tx="ekr.20190302133319.115">@staticmethod
def i64(r: bytes):
    return struct.unpack('&gt;q', r)[0]

</t>
<t tx="ekr.20190302133319.116">@staticmethod
def f32(r: bytes):
    return struct.unpack('&gt;f', r)[0]

</t>
<t tx="ekr.20190302133319.117">@staticmethod
def f64(r: bytes):
    return struct.unpack('&gt;d', r)[0]

</t>
<t tx="ekr.20190302133319.118">@staticmethod
def pack_u8(n: u8):
    return struct.pack('&gt;B', n)

</t>
<t tx="ekr.20190302133319.119">@staticmethod
def pack_i8(n: i8):
    return struct.pack('&gt;b', n)

</t>
<t tx="ekr.20190302133319.12">def read_bytes(reader, maxbits=32, signed=False) -&gt; bytearray:
    n = read_count(reader, maxbits, signed)
    return bytearray(reader.read(n))
</t>
<t tx="ekr.20190302133319.120">@staticmethod
def pack_u16(n: u16):
    return struct.pack('&gt;H', n)

</t>
<t tx="ekr.20190302133319.121">@staticmethod
def pack_i16(n: i16):
    return struct.pack('&gt;h', n)

</t>
<t tx="ekr.20190302133319.122">@staticmethod
def pack_u32(n: u32):
    return struct.pack('&gt;I', n)

</t>
<t tx="ekr.20190302133319.123">@staticmethod
def pack_i32(n: i32):
    return struct.pack('&gt;i', n)

</t>
<t tx="ekr.20190302133319.124">@staticmethod
def pack_u64(n: u64):
    return struct.pack('&gt;Q', n)

</t>
<t tx="ekr.20190302133319.125">@staticmethod
def pack_i64(n: i64):
    return struct.pack('&gt;q', n)

</t>
<t tx="ekr.20190302133319.126">@staticmethod
def pack_f32(n: f32):
    return struct.pack('&gt;f', n)

</t>
<t tx="ekr.20190302133319.127">@staticmethod
def pack_f64(n: f64):
    return struct.pack('&gt;d', n)


</t>
<t tx="ekr.20190302133319.128">def leb(reader, maxbits=32, signed=False):
    if isinstance(reader, (bytes, bytearray)):
        reader = io.BytesIO(reader)
    r = 0
    s = 0
    b = 0
    i = 0
    a = bytearray()
    while True:
        byte = ord(reader.read(1))
        i += 1
        a.append(byte)
        r |= ((byte &amp; 0x7f) &lt;&lt; s)
        s += 7
        if (byte &amp; 0x80) == 0:
            break
        b += 1
        assert b &lt;= math.ceil(maxbits / 7.0)
    if signed and (s &lt; maxbits) and (byte &amp; 0x40):
        r |= - (1 &lt;&lt; s)
    return (i, r, a)


</t>
<t tx="ekr.20190302133319.129">def rotl_u32(x: int, k: int):
    x = int2u32(x)
    k = int2u32(k)
    n = 32
    s = k &amp; (n - 1)
    return x &lt;&lt; s | x &gt;&gt; (n - s)


</t>
<t tx="ekr.20190302133319.13">@path C:/leo.repo/pywasm/pywasm/

import math
import typing

from pywasm import convention
from pywasm import log
from pywasm import num
from pywasm import structure

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.130">def rotl_u64(x: int, k: int):
    x = int2u64(x)
    k = int2u64(k)
    n = 64
    s = k &amp; (n - 1)
    return x &lt;&lt; s | x &gt;&gt; (n - s)


</t>
<t tx="ekr.20190302133319.131">def rotr_u32(x: int, k: int):
    return rotl_u32(x, -k)


</t>
<t tx="ekr.20190302133319.132">def rotr_u64(x: int, k: int):
    return rotl_u64(x, -k)


</t>
<t tx="ekr.20190302133319.133">def idiv_s(a, b):
    return a // b if a * b &gt; 0 else (a + (-a % b)) // b


</t>
<t tx="ekr.20190302133319.134">def irem_s(a, b):
    return a % b if a * b &gt; 0 else -(-a % b)
</t>
<t tx="ekr.20190302133319.135">@path C:/leo.repo/pywasm/pywasm/
import io
import typing

from pywasm import common
from pywasm import convention
from pywasm import log
from pywasm import num

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.136">class FunctionType:
    # Function types are encoded by the byte 0x60 followed by the respective vectors of parameter and result types.
    #
    # functype ::= 0x60 t1∗:vec(valtype) t2∗:vec(valtype) ⇒ [t1∗] → [t2∗]
    @others
</t>
<t tx="ekr.20190302133319.137">def __init__(self):
    self.args: typing.List[int]
    self.rets: typing.List[int]

</t>
<t tx="ekr.20190302133319.138">def __repr__(self):
    args = [convention.valtype[i][0] for i in self.args]
    rets = [convention.valtype[i][0] for i in self.rets]
    a = ', '.join(args)
    if rets:
        b = rets[0]
        return f'({a}) -&gt; {b}'
    return f'({a})'

</t>
<t tx="ekr.20190302133319.139">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = FunctionType()
    assert ord(r.read(1)) == 0x60
    o.args = common.read_bytes(r)
    o.rets = common.read_bytes(r)
    return o


</t>
<t tx="ekr.20190302133319.14">class Store:
    # The store represents all global state that can be manipulated by WebAssembly programs. It consists of the runtime
    # representation of all instances of functions, tables, memories, and globals that have been allocated during the
    # life time of the abstract machine
    # Syntactically, the store is defined as a record listing the existing instances of each category:
    # store ::= {
    #     funcs funcinst∗
    #     tables tableinst∗
    #     mems meminst∗
    #     globals globalinst∗
    # }
    #
    # Addresses are dynamic, globally unique references to runtime objects, in contrast to indices, which are static,
    # module-local references to their original definitions. A memory address memaddr denotes the abstract address of
    # a memory instance in the store, not an offset inside a memory instance.
    @others
</t>
<t tx="ekr.20190302133319.140">class ResultType:
    # Result types classify the result of executing instructions or blocks, which is a sequence of values written with
    # brackets.
    #
    # resulttype ::= [valtype?]
    pass


</t>
<t tx="ekr.20190302133319.141">class Limits:
    # Limits are encoded with a preceding flag indicating whether a maximum is present.
    #
    # limits ::= 0x00  n:u32        ⇒ {min n,max ϵ}
    #          | 0x01  n:u32  m:u32 ⇒ {min n,max m}
    @others
</t>
<t tx="ekr.20190302133319.142">def __init__(self, minimum: int, maximum: int):
    self.minimum = minimum
    self.maximum = maximum

</t>
<t tx="ekr.20190302133319.143">def __repr__(self):
    if self.maximum:
        return f'minimum={self.minimum} maximum={self.maximum}'
    return f'minimum={self.minimum}'

</t>
<t tx="ekr.20190302133319.144">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    flag = ord(r.read(1))
    minimum = common.read_count(r)
    maximum = common.read_count(r) if flag else None
    return Limits(minimum, maximum)


</t>
<t tx="ekr.20190302133319.145">class MemoryType:
    # Memory types classify linear memories and their size range.
    #
    # memtype ::= limits
    #
    # The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of
    # page size.
    @others
</t>
<t tx="ekr.20190302133319.146">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    return Limits.from_reader(r)


</t>
<t tx="ekr.20190302133319.147">class TableType:
    # Table types classify tables over elements of element types within a size range.
    #
    # tabletype :: =limits elemtype
    # elemtype ::= funcref
    #
    # Like memories, tables are constrained by limits for their minimum and optionally maximum size. The limits are
    # given in numbers of entries. The element type funcref is the infinite union of all function types. A table of that
    # type thus contains references to functions of heterogeneous type.

    @others
</t>
<t tx="ekr.20190302133319.148">def __init__(self):
    self.limits: Limits
    self.elemtype: int

</t>
<t tx="ekr.20190302133319.149">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = TableType()
    o.elemtype = ord(r.read(1))
    o.limits = Limits.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.15">def __init__(self):
    self.funcs: typing.List[FunctionInstance] = []
    self.tables: typing.List[TableInstance] = []
    self.mems: typing.List[MemoryInstance] = []
    self.globals: typing.List[GlobalInstance] = []


</t>
<t tx="ekr.20190302133319.150">class GlobalType:
    # Global types are encoded by their value type and a flag for their
    # mutability.
    #
    # globaltype ::= t:valtype m:mut ⇒ m t
    # mut ::= 0x00 ⇒ const
    #       | 0x01 ⇒ var
    @others
</t>
<t tx="ekr.20190302133319.151">def __init__(self):
    self.valtype: int
    self.mut: bool

</t>
<t tx="ekr.20190302133319.152">def __repr__(self):
    if self.mut:
        return f'var {convention.valtype[self.valtype]}'
    return f'const {convention.valtype[self.valtype]}'

</t>
<t tx="ekr.20190302133319.153">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = GlobalType()
    o.valtype = ord(r.read(1))
    o.mut = ord(r.read(1)) == 1
    return o


</t>
<t tx="ekr.20190302133319.154">class ExternType:
    # External types classify imports and external values with their respective types.
    #
    # externtype ::= func functype | table tabletype | mem memtype | global globaltype
    pass


</t>
<t tx="ekr.20190302133319.155">class Instruction:
    # Instructions are encoded by opcodes. Each opcode is represented by a single byte, and is followed by the
    # instruction’s immediate arguments, where present. The only exception are structured control instructions,
    # which consist of several opcodes bracketing their nested instruction sequences.
    @others
</t>
<t tx="ekr.20190302133319.156">def __init__(self, code: int, immediate_arguments=None):
    self.code = code
    self.immediate_arguments = immediate_arguments

</t>
<t tx="ekr.20190302133319.157">def __repr__(self):
    if self.immediate_arguments is None:
        return f'{convention.opcodes[self.code][0]}'
    return f'{convention.opcodes[self.code][0]} {self.immediate_arguments}'

</t>
<t tx="ekr.20190302133319.158">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    code_byte = r.read(1)
    if not code_byte:
        return None
    code = ord(code_byte)
    code_size = convention.opcodes[code][1]
    if code_size == '':
        immediate_arguments = None
    elif code_size == 'u8':
        immediate_arguments = common.read_count(r, 8)
    elif code_size == 'u32':
        immediate_arguments = common.read_count(r, 32)
    elif code_size == 'i32':
        immediate_arguments = num.int2i32(common.read_count(r, 32, signed=True))
    elif code_size == 'i64':
        immediate_arguments = num.int2i64(common.read_count(r, 64, signed=True))
    elif code_size == 'f32':
        immediate_arguments = num.LittleEndian.f32(r.read(4))
    elif code_size == 'f64':
        immediate_arguments = num.LittleEndian.f64(r.read(8))
    elif code_size == 'u32,u8':
        immediate_arguments = [common.read_count(r, 32), common.read_count(r, 8)]
    elif code_size == 'u32,u32':
        immediate_arguments = [common.read_count(r, 32) for _ in range(2)]
    elif code == convention.br_table:
        n = common.read_count(r, 32)
        a = [common.read_count(r, 32) for _ in range(n)]
        b = common.read_count(r, 32)
        immediate_arguments = [a, b]
    else:
        raise Exception('pywasm: invalid code size')
    return Instruction(code, immediate_arguments)


</t>
<t tx="ekr.20190302133319.159">class Expression:
    # Function bodies, initialization values for globals, and offsets of element or data segments are given as
    # expressions, which are sequences of instructions terminated by an end marker.
    #
    # expr ::= instr∗ end
    #
    # In some places, validation restricts expressions to be constant, which limits the set of allowable instructions.
    @others
</t>
<t tx="ekr.20190302133319.16">class FunctionInstance:
    # A function instance is the runtime representation of a function. It effectively is a closure of the original
    # function over the runtime module instance of its originating module. The module instance is used to resolve
    # references to other definitions during execution of the function.
    #
    # funcinst ::= {type functype,module moduleinst,code func}
    #            | {type functype,hostcode hostfunc}
    # hostfunc ::= ...
    pass


</t>
<t tx="ekr.20190302133319.160">def __init__(self):
    self.data: typing.List[Instruction] = []
    self.composition = {}

</t>
<t tx="ekr.20190302133319.161">@classmethod
def compose(cls, data: typing.List[Instruction]):
    composition = {}
    stack = []
    for i, instr in enumerate(data):
        code = instr.code
        if code in [convention.block, convention.loop, convention.if_]:
            stack.append([i])
            continue
        if code == convention.else_:
            stack[-1].append(i)
            continue
        if code == convention.end:
            if i == len(data) - 1:
                break
            block = stack.pop()
            block.append(i)
            composition[block[0]] = block
            continue
    if data[-1].code != convention.end:
        raise Exception('pywasm: function block did not end with 0xb')
    if stack:
        raise Exception('pywasm: function ended in middle of block')
    return composition

</t>
<t tx="ekr.20190302133319.162">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Expression()
    d = 1
    while True:
        i = Instruction.from_reader(r)
        if not i:
            break
        o.data.append(i)
        if i.code in [convention.block, convention.loop, convention.if_]:
            d += 1
        if i.code == convention.end:
            d -= 1
        if d == 0:
            break
    o.composition = cls.compose(o.data)
    return o


</t>
<t tx="ekr.20190302133319.163">class Locals:
    # The locals declare a vector of mutable local variables and their types. These variables are referenced through
    # local indices in the function’s body. The index of the first local is the smallest index not referencing a
    # parameter.
    #
    # locals ::= n:u32 t:valtype ⇒ tn
    @others
</t>
<t tx="ekr.20190302133319.164">def __init__(self):
    self.n: int
    self.valtype: int

</t>
<t tx="ekr.20190302133319.165">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Locals()
    o.n = common.read_count(r, 32)
    o.valtype = ord(r.read(1))
    return o


</t>
<t tx="ekr.20190302133319.166">class Code:
    # The encoding of each code entry consists of
    #   - the u32 size of the function code in bytes
    #   - the actual function code, which in turn consists of
    #       - the declaration of locals
    #      -  the function body as an expression.
    #
    # Local declarations are compressed into a vector whose entries consist of
    #   - a u32 count
    #   - a value type.
    #
    # code ::= size:u32 code:func ⇒ code(ifsize=||func||)
    # func ::= (t∗)∗:vec(locals) e:expr ⇒ concat((t∗)∗), e∗(if|concat((t∗)∗)|&lt;232)
    # locals ::= n:u32 t:valtype ⇒ tn
    @others
</t>
<t tx="ekr.20190302133319.167">def __init__(self):
    self.locals: typing.List[int] = []
    self.expr: Expression

</t>
<t tx="ekr.20190302133319.168">def __repr__(self):
    return f'locals={self.locals}'

</t>
<t tx="ekr.20190302133319.169">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Code()
    n = common.read_count(r, 32)
    n = common.read_count(r, 32)
    for _ in range(n):
        l = Locals.from_reader(r)
        o.locals.extend([l.valtype for _ in range(l.n)])
    o.expr = Expression.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.17">class WasmFunc(FunctionInstance):
    @others
</t>
<t tx="ekr.20190302133319.170">class Function:
    # The funcs component of a module defines a vector of functions with the following structure:
    #
    # func ::= {type typeidx, locals vec(valtype), body expr}
    #
    # The type of a function declares its signature by reference to a type defined in the module. The parameters of the
    # function are referenced through 0-based local indices in the function’s body; they are mutable.
    #
    # The locals declare a vector of mutable local variables and their types. These variables are referenced through
    # local indices in the function’s body. The index of the first local is the smallest index not referencing a
    # parameter.
    #
    # The body is an instruction sequence that upon termination must produce a stack matching the function type’s
    # result type.
    #
    # Functions are referenced through function indices, starting with the smallest index not referencing
    # a function import.
    @others
</t>
<t tx="ekr.20190302133319.171">def __init__(self):
    self.typeidx: int
    self.locals: typing.List[int] = []
    self.expr: Expression


</t>
<t tx="ekr.20190302133319.172">class Table:
    # The tables component of a module defines a vector of tables described by their table type:
    #
    # table ::= {type tabletype}
    @others
</t>
<t tx="ekr.20190302133319.173">def __init__(self):
    self.tabletype: TableType

</t>
<t tx="ekr.20190302133319.174">def __repr__(self):
    return f'{convention.elemtype[self.tabletype.elemtype][0]} {self.tabletype.limits}'

</t>
<t tx="ekr.20190302133319.175">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Table()
    o.tabletype = TableType.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.176">class Memory:
    # The mems component of a module defines a vector of linear memories (or memories for short) as described by their
    # memory type:
    #
    # mem ::= {type memtype}
    @others
</t>
<t tx="ekr.20190302133319.177">def __init__(self):
    self.memtype: MemoryType

</t>
<t tx="ekr.20190302133319.178">def __repr__(self):
    return f'{self.memtype}'

</t>
<t tx="ekr.20190302133319.179">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Memory()
    o.memtype = MemoryType.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.18">def __init__(self,
             functype: structure.FunctionType,
             module: 'ModuleInstance',
             code: structure.Function
             ):
    self.functype = functype
    self.module = module
    self.code = code


</t>
<t tx="ekr.20190302133319.180">class Global:
    # The globals component of a module defines a vector of global variables (or globals for short):
    #
    # global ::= {type globaltype, init expr}
    @others
</t>
<t tx="ekr.20190302133319.181">def __init__(self):
    self.globaltype: GlobalType
    self.expr: Expression

</t>
<t tx="ekr.20190302133319.182">def __repr__(self):
    return f'{self.globaltype} expr={self.expr}&gt;'

</t>
<t tx="ekr.20190302133319.183">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Global()
    o.globaltype = GlobalType.from_reader(r)
    o.expr = Expression.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.184">class ElementSegment:
    # The initial contents of a table is uninitialized. The elem component of a module defines a vector of element
    # segments that initialize a subrange of a table, at a given offset, from a static vector of elements.
    #
    # elem ::= {table tableidx, offset expr, init vec(funcidx)}
    #
    # The offset is given by a constant expression.
    @others
</t>
<t tx="ekr.20190302133319.185">def __init__(self):
    self.tableidx: int
    self.expr: Expression
    self.init: typing.List[int]

</t>
<t tx="ekr.20190302133319.186">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = ElementSegment()
    o.tableidx = common.read_count(r, 32)
    o.expr = Expression.from_reader(r)
    n = common.read_count(r, 32)
    o.init = [common.read_count(r, 32) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.187">class DataSegment:
    # The initial contents of a memory are zero-valued bytes. The data component of a module defines a vector of data
    # segments that initialize a range of memory, at a given offset, with a static vector of bytes.
    #
    # data::={data memidx,offset expr,init vec(byte)}
    #
    # The offset is given by a constant expression.
    @others
</t>
<t tx="ekr.20190302133319.188">def __init__(self):
    self.memidx: int
    self.expr: Expression
    self.init: bytearray

</t>
<t tx="ekr.20190302133319.189">def __repr__(self):
    return self.init[:32].decode()

</t>
<t tx="ekr.20190302133319.19">class HostFunc(FunctionInstance):
    # A host function is a function expressed outside WebAssembly but passed to a module as an import. The definition
    # and behavior of host functions are outside the scope of this specification. For the purpose of this
    # specification, it is assumed that when invoked, a host function behaves non-deterministically, but within certain
    # constraints that ensure the integrity of the runtime.
    @others
</t>
<t tx="ekr.20190302133319.190">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = DataSegment()
    o.memidx = common.read_count(r, 32)
    o.expr = Expression.from_reader(r)
    o.init = bytearray(common.read_bytes(r, 32))
    return o


</t>
<t tx="ekr.20190302133319.191">class StartFunction:
    # The start component of a module declares the function index of a start function that is automatically invoked
    # when the module is instantiated, after tables and memories have been initialized.
    #
    # start ::= {func funcidx}
    @others
</t>
<t tx="ekr.20190302133319.192">def __init__(self):
    self.funcidx: int

</t>
<t tx="ekr.20190302133319.193">def __repr__(self):
    return f'StartFunction[{self.funcidx}]'

</t>
<t tx="ekr.20190302133319.194">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = StartFunction()
    o.funcidx = common.read_count(r, 32)
    return o


</t>
<t tx="ekr.20190302133319.195">class Export:
    # The exports component of a module defines a set of exports that become accessible to the host environment once
    # the module has been instantiated.
    #
    # export ::= {name name, desc exportdesc}
    # exportdesc ::= func funcidx | table tableidx | mem memidx | global globalidx
    #
    # Each export is labeled by a unique name. Exportable definitions are functions, tables, memories, and globals,
    # which are referenced through a respective descriptor.
    @others
</t>
<t tx="ekr.20190302133319.196">def __init__(self):
    self.name: str
    self.kind: int
    self.desc = None

</t>
<t tx="ekr.20190302133319.197">def __repr__(self):
    if self.kind == convention.extern_func:
        return f'{self.name} -&gt; Function[{self.desc}]'
    if self.kind == convention.extern_table:
        return f'{self.name} -&gt; Table[{self.desc}]'
    if self.kind == convention.extern_mem:
        return f'{self.name} -&gt; Memory[{self.desc}]'
    if self.kind == convention.extern_global:
        return f'{self.name} -&gt; Global[{self.desc}]'
    return f'{self.name}'

</t>
<t tx="ekr.20190302133319.198">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Export()
    o.name = common.read_bytes(r, 32).decode()
    o.kind = ord(r.read(1))
    o.desc = common.read_count(r, 32)
    return o


</t>
<t tx="ekr.20190302133319.199">class Import:
    # The imports component of a module defines a set of imports that are required for instantiation.
    #
    # import ::= {module name, name name, desc importdesc}
    # importdesc ::= func typeidx | table tabletype | mem memtype | global globaltype
    #
    # Each import is labeled by a two-level name space, consisting of a module name and a name for an entity within
    # that module. Importable definitions are functions, tables, memories, and globals. Each import is specified by a
    # descriptor with a respective type that a definition provided during instantiation is required to match. Every
    # import defines an index in the respective index space. In each index space, the indices of imports go before the
    # first index of any definition contained in the module itself.
    @others
</t>
<t tx="ekr.20190302133319.2">@path C:/leo.repo/pywasm/pywasm/
import typing

from pywasm import convention
from pywasm import execution
from pywasm import log
from pywasm import structure

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.20">def __init__(self, functype: structure.FunctionType, hostcode: typing.Callable):
    self.functype = functype
    self.hostcode = hostcode


</t>
<t tx="ekr.20190302133319.200">def __init__(self):
    self.module: str
    self.name: str
    self.kind: int
    self.desc = None

</t>
<t tx="ekr.20190302133319.201">def __repr__(self):
    if self.kind == convention.extern_func:
        return f'{self.module}.{self.name} -&gt; Function[{self.desc}]'
    if self.kind == convention.extern_table:
        return f'{self.module}.{self.name} -&gt; Table[{self.desc}]'
    if self.kind == convention.extern_mem:
        return f'{self.module}.{self.name} -&gt; Memory[{self.desc}]'
    if self.kind == convention.extern_global:
        return f'{self.module}.{self.name} -&gt; Global[{self.desc}]'
    return f'{self.module}.{self.name}'

</t>
<t tx="ekr.20190302133319.202">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = Import()
    o.module = common.read_bytes(r, 32).decode()
    o.name = common.read_bytes(r, 32).decode()
    o.kind = ord(r.read(1))
    if o.kind == convention.extern_func:
        o.desc = common.read_count(r, 32)
    elif o.kind == convention.extern_table:
        o.desc = TableType.from_reader(r)
    elif o.kind == convention.extern_mem:
        o.desc = MemoryType.from_reader(r)
    elif o.kind == convention.extern_global:
        o.desc = GlobalType.from_reader(r)
    else:
        raise Exception('pywasm: malformed')
    return o


</t>
<t tx="ekr.20190302133319.203">class CustomSection:
    # Custom sections have the id 0. They are intended to be used for debugging
    # information or third-party extensions, and are ignored by the WebAssembly
    # semantics. Their contents consist of a name further identifying the custom
    # section, followed by an uninterpreted sequence of bytes for custom use.
    #
    # customsec ::= section0(custom)
    # custom ::= name byte∗
    @others
</t>
<t tx="ekr.20190302133319.204">def __init__(self):
    self.name: str = None
    self.data: bytearray = None

</t>
<t tx="ekr.20190302133319.205">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = CustomSection()
    n = common.read_count(r, 32)
    o.name = r.read(n).decode()
    o.data = bytearray(r.read(-1))
    return o


</t>
<t tx="ekr.20190302133319.206">class TypeSection:
    # The type section has the id 1. It decodes into a vector of function
    # types that represent the types component of a module.
    #
    # typesec ::= ft∗:section1(vec(functype)) ⇒ ft∗

    @others
</t>
<t tx="ekr.20190302133319.207">def __init__(self):
    self.vec: typing.List[FunctionType] = []

</t>
<t tx="ekr.20190302133319.208">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = TypeSection()
    n = common.read_count(r, 32)
    o.vec = [FunctionType.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.209">class ImportSection:
    # The import section has the id 2. It decodes into a vector of imports
    # that represent the imports component of a module.
    #
    # importsec ::= im∗:section2(vec(import)) ⇒ im∗
    # import ::= mod:name nm:name d:importdesc ⇒ {module mod, name nm, desc d}
    # importdesc ::= 0x00 x:typeidx ⇒ func x
    #              | 0x01 tt:tabletype ⇒ table tt
    #              | 0x02 mt:memtype ⇒ mem mt
    #              | 0x03 gt:globaltype ⇒ global gt

    @others
</t>
<t tx="ekr.20190302133319.21">class TableInstance:
    # A table instance is the runtime representation of a table. It holds a vector of function elements and an optional
    # maximum size, if one was specified in the table type at the table’s definition site.
    #
    # Each function element is either empty, representing an uninitialized table entry, or a function address. Function
    # elements can be mutated through the execution of an element segment or by external means provided by the embedder.
    #
    # tableinst ::= {elem vec(funcelem), max u32?}
    # funcelem ::= funcaddr?
    #
    # It is an invariant of the semantics that the length of the element vector never exceeds the maximum size, if
    # present.
    @others
</t>
<t tx="ekr.20190302133319.210">def __init__(self):
    self.vec: typing.List[Import] = []

</t>
<t tx="ekr.20190302133319.211">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = ImportSection()
    n = common.read_count(r, 32)
    o.vec = [Import.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.212">class FunctionSection:
    # The function section has the id 3. It decodes into a vector of type
    # indices that represent the type fields of the functions in the funcs
    # component of a module. The locals and body fields of the respective
    # functions are encoded separately in the code section.
    #
    # funcsec ::= x∗:section3(vec(typeidx)) ⇒ x∗

    @others
</t>
<t tx="ekr.20190302133319.213">def __init__(self):
    self.vec: typing.List[int] = []

</t>
<t tx="ekr.20190302133319.214">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = FunctionSection()
    n = common.read_count(r, 32)
    o.vec = [common.read_count(r, 32) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.215">class TableSection:
    # The table section has the id 4. It decodes into a vector of tables that
    # represent the tables component of a module.
    #
    # tablesec ::= tab∗:section4(vec(table)) ⇒ tab∗
    # table ::= tt:tabletype ⇒ {type tt}

    @others
</t>
<t tx="ekr.20190302133319.216">def __init__(self):
    self.vec: typing.List[Table] = []

</t>
<t tx="ekr.20190302133319.217">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = TableSection()
    n = common.read_count(r, 32)
    o.vec = [Table.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.218">class MemorySection:
    # The memory section has the id 5. It decodes into a vector of memories
    # that represent the mems component of a module.
    #
    # memsec ::= mem∗:section5(vec(mem)) ⇒ mem∗
    # mem ::= mt:memtype ⇒ {type mt}

    @others
</t>
<t tx="ekr.20190302133319.219">def __init__(self):
    self.vec: typing.List[Memory] = []

</t>
<t tx="ekr.20190302133319.22">def __init__(self, elemtype: int, limits: structure.Limits):
    self.elemtype = elemtype
    self.limits = limits
    self.elem = [None for _ in range(limits.minimum)]


</t>
<t tx="ekr.20190302133319.220">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = MemorySection()
    n = common.read_count(r, 32)
    o.vec = [Memory.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.221">class GlobalSection:
    # The global section has the id 6. It decodes into a vector of globals
    # that represent the globals component of a module.
    #
    # globalsec ::= glob*:section6(vec(global)) ⇒ glob∗
    # global ::= gt:globaltype e:expr ⇒ {type gt, init e}

    @others
</t>
<t tx="ekr.20190302133319.222">def __init__(self):
    self.vec: typing.List[Global] = []

</t>
<t tx="ekr.20190302133319.223">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = GlobalSection()
    n = common.read_count(r, 32)
    o.vec = [Global.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.224">class ExportSection:
    # The export section has the id 7. It decodes into a vector of exports
    # that represent the exports component of a module.
    #
    # exportsec ::= ex∗:section7(vec(export)) ⇒ ex∗
    # export :: =nm:name d:exportdesc ⇒ {name nm, desc d}
    # exportdesc ::= 0x00 x:funcidx ⇒ func x
    #              | 0x01 x:tableidx ⇒ table x
    #              | 0x02 x:memidx ⇒ mem x
    #              | 0x03 x:globalidx⇒global x

    @others
</t>
<t tx="ekr.20190302133319.225">def __init__(self):
    self.vec: typing.List[Export] = []

</t>
<t tx="ekr.20190302133319.226">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = ExportSection()
    n = common.read_count(r, 32)
    o.vec = [Export.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.227">class StartSection:
    # The start section has the id 8. It decodes into an optional start
    # function that represents the start component of a module.
    #
    # startsec ::= st?:section8(start) ⇒ st?
    # start ::= x:funcidx ⇒ {func x}

    @others
</t>
<t tx="ekr.20190302133319.228">def __init__(self):
    self.start_function: StartFunction

</t>
<t tx="ekr.20190302133319.229">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = StartSection()
    o.start_function = StartFunction.from_reader(r)
    return o


</t>
<t tx="ekr.20190302133319.23">class MemoryInstance:
    # A memory instance is the runtime representation of a linear memory. It holds a vector of bytes and an optional
    # maximum size, if one was specified at the definition site of the memory.
    #
    # meminst ::= {data vec(byte), max u32?}
    #
    # The length of the vector always is a multiple of the WebAssembly page size, which is defined to be the constant
    # 65536 – abbreviated 64Ki. Like in a memory type, the maximum size in a memory instance is given in units of this
    # page size.
    #
    # The bytes can be mutated through memory instructions, the execution of a data segment, or by external means
    # provided by the embedder.
    #
    # It is an invariant of the semantics that the length of the byte vector, divided by page size, never exceeds the
    # maximum size, if present.
    @others
</t>
<t tx="ekr.20190302133319.230">class ElementSection:
    # The element section has the id 9. It decodes into a vector of element
    # segments that represent the elem component of a module.
    #
    # elemsec ::= seg∗:section9(vec(elem)) ⇒ seg
    # elem ::= x:tableidx e:expr y∗:vec(funcidx) ⇒ {table x, offset e, init y∗}
    @others
</t>
<t tx="ekr.20190302133319.231">def __init__(self):
    self.vec: typing.List[ElementSegment]

</t>
<t tx="ekr.20190302133319.232">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = ElementSection()
    n = common.read_count(r, 32)
    o.vec = [ElementSegment.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.233">class CodeSection:
    # The code section has the id 10. It decodes into a vector of code
    # entries that are pairs of value type vectors and expressions. They
    # represent the locals and body field of the functions in the funcs
    # component of a module. The type fields of the respective functions are
    # encoded separately in the function section.
    @others
</t>
<t tx="ekr.20190302133319.234">def __init__(self):
    self.vec: typing.List[Code] = []

</t>
<t tx="ekr.20190302133319.235">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = CodeSection()
    n = common.read_count(r, 32)
    o.vec = [Code.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.236">class DataSection:
    # The data section has the id 11. It decodes into a vector of data
    # segments that represent the data component of a module.
    #
    # datasec ::= seg∗:section11(vec(data)) ⇒ seg
    # data ::= x:memidx e:expr b∗:vec(byte) ⇒ {data x,offset e,init b∗}
    @others
</t>
<t tx="ekr.20190302133319.237">def __init__(self):
    self.vec: typing.List[DataSegment] = []

</t>
<t tx="ekr.20190302133319.238">@classmethod
def from_reader(cls, r: typing.BinaryIO):
    o = DataSection()
    n = common.read_count(r, 32)
    o.vec = [DataSegment.from_reader(r) for _ in range(n)]
    return o


</t>
<t tx="ekr.20190302133319.239">class Module:
    @others
</t>
<t tx="ekr.20190302133319.24">def __init__(self, limits: structure.Limits):
    self.limits = limits
    self.size = limits.minimum
    self.data = bytearray([0x00 for _ in range(limits.minimum * 64 * 1024)])

</t>
<t tx="ekr.20190302133319.240">def __init__(self):
    self.types: typing.List[FunctionType] = []
    self.funcs: typing.List[Function] = []
    self.tables: typing.List[Table] = []
    self.mems: typing.List[Memory] = []
    self.globals: typing.List[Global] = []
    self.elem: typing.List[ElementSegment] = []
    self.data: typing.List[DataSegment] = []
    self.start: int = None
    self.imports: typing.List[Import] = []
    self.exports: typing.List[Export] = []

</t>
<t tx="ekr.20190302133319.241">@classmethod
def load(cls, name: str) -&gt; 'Module':
    with open(name, 'rb') as f:
        return cls.from_reader(f)

</t>
<t tx="ekr.20190302133319.242">@classmethod
def from_reader(cls, r: typing.BinaryIO) -&gt; 'Module':
    if list(r.read(4)) != [0x00, 0x61, 0x73, 0x6d]:
        raise Exception('pywasm: invalid magic number')
    if list(r.read(4)) != [0x01, 0x00, 0x00, 0x00]:
        raise Exception('pywasm: invalid version')
    mod = Module()
    log.debugln('Sections:')
    log.debugln()
    while True:
        section_id_byte = r.read(1)
        if not section_id_byte:
            break
        section_id = ord(section_id_byte)
        n = common.read_count(r, 32)
        data = r.read(n)
        if len(data) != n:
            raise Exception('pywasm: invalid section size')
        if section_id == convention.custom_section:
            custom_section = CustomSection.from_reader(io.BytesIO(data))
            log.debugln(f'{convention.section[section_id][0]:&gt;9} {custom_section.name}')
        elif section_id == convention.type_section:
            type_section = TypeSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(type_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.types = type_section.vec
        elif section_id == convention.import_section:
            import_section = ImportSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(import_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.imports = import_section.vec
        elif section_id == convention.function_section:
            function_section = FunctionSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(function_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] sig={e}')
        elif section_id == convention.table_section:
            table_section = TableSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(table_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.tables = table_section.vec
        elif section_id == convention.memory_section:
            memory_section = MemorySection.from_reader(io.BytesIO(data))
            for i, e in enumerate(memory_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.mems = memory_section.vec
        elif section_id == convention.global_section:
            global_section = GlobalSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(global_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.globals = global_section.vec
        elif section_id == convention.export_section:
            export_section = ExportSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(export_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.exports = export_section.vec
        elif section_id == convention.start_section:
            start_section = StartSection.from_reader(io.BytesIO(data))
            log.debugln(f'{convention.section[section_id][0]:&gt;12} {start_section.start_function}')
            mod.start = start_section.start_function.funcidx
        elif section_id == convention.element_section:
            element_section = ElementSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(element_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.elem = element_section.vec
        elif section_id == convention.code_section:
            code_section = CodeSection.from_reader(io.BytesIO(data))

            def printex(instrs: typing.List[Instruction], prefix=0):
                for e in instrs:
                    a = f'           | {" " * prefix}{convention.opcodes[e.code][0]}'
                    if e.code in [convention.block, convention.loop, convention.if_]:
                        log.debugln(f'{a} {e.immediate_arguments}')
                        prefix += 2
                    elif e.code == convention.end:
                        log.debugln(f'{a}')
                        prefix -= 2
                    elif e.immediate_arguments is None:
                        log.debugln(f'{a}')
                    elif isinstance(e.immediate_arguments, list):
                        log.debugln(f'{a} {" ".join([str(e) for e in e.immediate_arguments])}')
                    else:
                        log.debugln(f'{a} {e.immediate_arguments}')
            for i, e in enumerate(code_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
                printex(e.expr.data)
                func = Function()
                func.typeidx = function_section.vec[i]
                func.locals = e.locals
                func.expr = e.expr
                mod.funcs.append(func)
        elif section_id == convention.data_section:
            data_section = DataSection.from_reader(io.BytesIO(data))
            for i, e in enumerate(data_section.vec):
                log.debugln(f'{convention.section[section_id][0]:&gt;9}[{i}] {e}')
            mod.data = data_section.vec
        else:
            raise Exception('pywasm: invalid section id')
    log.debugln('')
    return mod
</t>
<t tx="ekr.20190302133319.243">@language python
i32 = 0x7f
i64 = 0x7e
f32 = 0x7d
f64 = 0x7c

valtype = {
    i32: ['i32'],
    i64: ['i64'],
    f32: ['f32'],
    f64: ['f64'],
}

empty = 0x40

blocktype = {
    empty: ['empty'],
    **valtype
}

funcref = 0x70

elemtype = {
    funcref: ['funcref'],
}


opcodes = {}


def op(code, name, code_size, load_size):
    opcodes[code] = (name, code_size, load_size)
    return code


# control Instructions
unreachable = op(0x00, 'unreachable', '', 0)
nop = op(0x01, 'nop', '', 0)
block = op(0x02, 'block', 'u8', 0)
loop = op(0x03, 'loop', 'u8', 0)
if_ = op(0x04, 'if', 'u8', 0)
else_ = op(0x05, 'else', '', 0)
end = op(0x0b, 'end', '', 0)
br = op(0x0c, 'br', 'u32', 0)
br_if = op(0x0d, 'br_if', 'u32', 0)
br_table = op(0x0e, 'br_table', 'complex', 0)
return_ = op(0x0f, 'return', '', 0)
call = op(0x10, 'call', 'u32', 0)
call_indirect = op(0x11, 'call_indirect', 'u32,u8', 0)
# parametric Instructions
drop = op(0x1a, 'drop', '', 0)
select = op(0x1b, 'select', '', 0)
# variable instructions
get_local = op(0x20, 'local.get', 'u32', 0)
set_local = op(0x21, 'local.set', 'u32', 0)
tee_local = op(0x22, 'local.tee', 'u32', 0)
get_global = op(0x23, 'global.get', 'u32', 0)
set_global = op(0x24, 'global.set', 'u32', 0)
# memory instructions
i32_load = op(0x28, 'i32.load', 'u32,u32', 4)
i64_load = op(0x29, 'i64.load', 'u32,u32', 8)
f32_load = op(0x2a, 'f32.load', 'u32,u32', 4)
f64_load = op(0x2b, 'f64.load', 'u32,u32', 8)
i32_load8_s = op(0x2c, 'i32.load8_s', 'u32,u32', 1)
i32_load8_u = op(0x2d, 'i32.load8_u', 'u32,u32', 1)
i32_load16_s = op(0x2e, 'i32.load16_s', 'u32,u32', 2)
i32_load16_u = op(0x2f, 'i32.load16_u', 'u32,u32', 2)
i64_load8_s = op(0x30, 'i64.load8_s', 'u32,u32', 1)
i64_load8_u = op(0x31, 'i64.load8_u', 'u32,u32', 1)
i64_load16_s = op(0x32, 'i64.load16_s', 'u32,u32', 2)
i64_load16_u = op(0x33, 'i64.load16_u', 'u32,u32', 2)
i64_load32_s = op(0x34, 'i64.load32_s', 'u32,u32', 4)
i64_load32_u = op(0x35, 'i64.load32_u', 'u32,u32', 4)
i32_store = op(0x36, 'i32.store', 'u32,u32', 4)
i64_store = op(0x37, 'i64.store', 'u32,u32', 8)
f32_store = op(0x38, 'f32.store', 'u32,u32', 4)
f64_store = op(0x39, 'f64.store', 'u32,u32', 8)
i32_store8 = op(0x3a, 'i32.store8', 'u32,u32', 1)
i32_store16 = op(0x3b, 'i32.store16', 'u32,u32', 2)
i64_store8 = op(0x3c, 'i64.store8', 'u32,u32', 1)
i64_store16 = op(0x3d, 'i64.store16', 'u32,u32', 2)
i64_store32 = op(0x3e, 'i64.store32', 'u32,u32', 4)
current_memory = op(0x3f, 'memory.size', 'u8', 0)
grow_memory = op(0x40, 'memory.grow', 'u8', 1)
# numeric instructions
i32_const = op(0x41, 'i32.const', 'i32', 2)
i64_const = op(0x42, 'i64.const', 'i64', 1)
f32_const = op(0x43, 'f32.const', 'f32', 2)
f64_const = op(0x44, 'f64.const', 'f64', 4)
i32_eqz = op(0x45, 'i32.eqz', '', 0)
i32_eq = op(0x46, 'i32.eq', '', 0)
i32_ne = op(0x47, 'i32.ne', '', 0)
i32_lts = op(0x48, 'i32.lt_s', '', 0)
i32_ltu = op(0x49, 'i32.lt_u', '', 0)
i32_gts = op(0x4a, 'i32.gt_s', '', 0)
i32_gtu = op(0x4b, 'i32.gt_u', '', 0)
i32_les = op(0x4c, 'i32.le_s', '', 0)
i32_leu = op(0x4d, 'i32.le_u', '', 0)
i32_ges = op(0x4e, 'i32.ge_s', '', 0)
i32_geu = op(0x4f, 'i32.ge_u', '', 0)
i64_eqz = op(0x50, 'i64.eqz', '', 0)
i64_eq = op(0x51, 'i64.eq', '', 0)
i64_ne = op(0x52, 'i64.ne', '', 0)
i64_lts = op(0x53, 'i64.lt_s', '', 0)
i64_ltu = op(0x54, 'i64.lt_u', '', 0)
i64_gts = op(0x55, 'i64.gt_s', '', 0)
i64_gtu = op(0x56, 'i64.gt_u', '', 0)
i64_les = op(0x57, 'i64.le_s', '', 0)
i64_leu = op(0x58, 'i64.le_u', '', 0)
i64_ges = op(0x59, 'i64.ge_s', '', 0)
i64_geu = op(0x5a, 'i64.ge_u', '', 0)
f32_eq = op(0x5b, 'f32.eq', '', 0)
f32_ne = op(0x5c, 'f32.ne', '', 0)
f32_lt = op(0x5d, 'f32.lt', '', 0)
f32_gt = op(0x5e, 'f32.gt', '', 0)
f32_le = op(0x5f, 'f32.le', '', 0)
f32_ge = op(0x60, 'f32.ge', '', 0)
f64_eq = op(0x61, 'f64.eq', '', 0)
f64_ne = op(0x62, 'f64.ne', '', 0)
f64_lt = op(0x63, 'f64.lt', '', 0)
f64_gt = op(0x64, 'f64.gt', '', 0)
f64_le = op(0x65, 'f64.le', '', 0)
f64_ge = op(0x66, 'f64.ge', '', 0)
i32_clz = op(0x67, 'i32.clz', '', 0)
i32_ctz = op(0x68, 'i32.ctz', '', 0)
i32_popcnt = op(0x69, 'i32.popcnt', '', 0)
i32_add = op(0x6a, 'i32.add', '', 0)
i32_sub = op(0x6b, 'i32.sub', '', 0)
i32_mul = op(0x6c, 'i32.mul', '', 0)
i32_divs = op(0x6d, 'i32.div_s', '', 0)
i32_divu = op(0x6e, 'i32.div_u', '', 0)
i32_rems = op(0x6f, 'i32.rem_s', '', 0)
i32_remu = op(0x70, 'i32.rem_u', '', 0)
i32_and = op(0x71, 'i32.and', '', 0)
i32_or = op(0x72, 'i32.or', '', 0)
i32_xor = op(0x73, 'i32.xor', '', 0)
i32_shl = op(0x74, 'i32.shl', '', 0)
i32_shrs = op(0x75, 'i32.shr_s', '', 0)
i32_shru = op(0x76, 'i32.shr_u', '', 0)
i32_rotl = op(0x77, 'i32.rotl', '', 0)
i32_rotr = op(0x78, 'i32.rotr', '', 0)
i64_clz = op(0x79, 'i64.clz', '', 0)
i64_ctz = op(0x7a, 'i64.ctz', '', 0)
i64_popcnt = op(0x7b, 'i64.popcnt', '', 0)
i64_add = op(0x7c, 'i64.add', '', 0)
i64_sub = op(0x7d, 'i64.sub', '', 0)
i64_mul = op(0x7e, 'i64.mul', '', 0)
i64_divs = op(0x7f, 'i64.div_s', '', 0)
i64_divu = op(0x80, 'i64.div_u', '', 0)
i64_rems = op(0x81, 'i64.rem_s', '', 0)
i64_remu = op(0x82, 'i64.rem_u', '', 0)
i64_and = op(0x83, 'i64.and', '', 0)
i64_or = op(0x84, 'i64.or', '', 0)
i64_xor = op(0x85, 'i64.xor', '', 0)
i64_shl = op(0x86, 'i64.shl', '', 0)
i64_shrs = op(0x87, 'i64.shr_s', '', 0)
i64_shru = op(0x88, 'i64.shr_u', '', 0)
i64_rotl = op(0x89, 'i64.rotl', '', 0)
i64_rotr = op(0x8a, 'i64.rotr', '', 0)
f32_abs = op(0x8b, 'f32.abs', '', 0)
f32_neg = op(0x8c, 'f32.neg', '', 0)
f32_ceil = op(0x8d, 'f32.ceil', '', 0)
f32_floor = op(0x8e, 'f32.floor', '', 0)
f32_trunc = op(0x8f, 'f32.trunc', '', 0)
f32_nearest = op(0x90, 'f32.nearest', '', 0)
f32_sqrt = op(0x91, 'f32.sqrt', '', 0)
f32_add = op(0x92, 'f32.add', '', 0)
f32_sub = op(0x93, 'f32.sub', '', 0)
f32_mul = op(0x94, 'f32.mul', '', 0)
f32_div = op(0x95, 'f32.div', '', 0)
f32_min = op(0x96, 'f32.min', '', 0)
f32_max = op(0x97, 'f32.max', '', 0)
f32_copysign = op(0x98, 'f32.copysign', '', 0)
f64_abs = op(0x99, 'f64.abs', '', 0)
f64_neg = op(0x9a, 'f64.neg', '', 0)
f64_ceil = op(0x9b, 'f64.ceil', '', 0)
f64_floor = op(0x9c, 'f64.floor', '', 0)
f64_trunc = op(0x9d, 'f64.trunc', '', 0)
f64_nearest = op(0x9e, 'f64.nearest', '', 0)
f64_sqrt = op(0x9f, 'f64.sqrt', '', 0)
f64_add = op(0xa0, 'f64.add', '', 0)
f64_sub = op(0xa1, 'f64.sub', '', 0)
f64_mul = op(0xa2, 'f64.mul', '', 0)
f64_div = op(0xa3, 'f64.div', '', 0)
f64_min = op(0xa4, 'f64.min', '', 0)
f64_max = op(0xa5, 'f64.max', '', 0)
f64_copysign = op(0xa6, 'f64.copysign', '', 0)
i32_wrap_i64 = op(0xa7, 'i32.wrap_i64', '', 0)
i32_trunc_sf32 = op(0xa8, 'i32.trunc_f32_s', '', 0)
i32_trunc_uf32 = op(0xa9, 'i32.trunc_f32_u', '', 0)
i32_trunc_sf64 = op(0xaa, 'i32.trunc_f64_s', '', 0)
i32_trunc_uf64 = op(0xab, 'i32.trunc_f64_u', '', 0)
i64_extend_si32 = op(0xac, 'i64.extend_i32_s', '', 0)
i64_extend_ui32 = op(0xad, 'i64.extend_i32_u', '', 0)
i64_trunc_sf32 = op(0xae, 'i64.trunc_f32_s', '', 0)
i64_trunc_uf32 = op(0xaf, 'i64.trunc_f32_u', '', 0)
i64_trunc_sf64 = op(0xb0, 'i64.trunc_f64_s', '', 0)
i64_trunc_uf64 = op(0xb1, 'i64.trunc_f64_u', '', 0)
f32_convert_si32 = op(0xb2, 'f32.convert_i32_s', '', 0)
f32_convert_ui32 = op(0xb3, 'f32.convert_i32_u', '', 0)
f32_convert_si64 = op(0xb4, 'f32.convert_i64_s', '', 0)
f32_convert_ui64 = op(0xb5, 'f32.convert_i64_u', '', 0)
f32_demote_f64 = op(0xb6, 'f32.demote_f64', '', 0)
f64_convert_si32 = op(0xb7, 'f64.convert_i32_s', '', 0)
f64_convert_ui32 = op(0xb8, 'f64.convert_i32_u', '', 0)
f64_convert_si64 = op(0xb9, 'f64.convert_i64_s', '', 0)
f64_convert_ui64 = op(0xba, 'f64.convert_i64_u', '', 0)
f64_promote_f32 = op(0xbb, 'f64.promote_f32', '', 0)
i32_reinterpret_f32 = op(0xbc, 'i32.reinterpret_f32', '', 0)
i64_reinterpret_f64 = op(0xbd, 'i64.reinterpret_f64', '', 0)
f32_reinterpret_i32 = op(0xbe, 'f32.reinterpret_i32', '', 0)
f64_reinterpret_i64 = op(0xbf, 'f64.reinterpret_i64', '', 0)

custom_section = 0x00
type_section = 0x01
import_section = 0x02
function_section = 0x03
table_section = 0x04
memory_section = 0x05
global_section = 0x06
export_section = 0x07
start_section = 0x08
element_section = 0x09
code_section = 0x0a
data_section = 0x0b

section = {
    custom_section: ['Custom'],
    type_section: ['Type'],
    import_section: ['Import'],
    function_section: ['Function'],
    table_section: ['Table'],
    memory_section: ['Memory'],
    global_section: ['Global'],
    export_section: ['Export'],
    start_section: ['Start'],
    element_section: ['Element'],
    code_section: ['Code'],
    data_section: ['Data'],
}

extern_func = 0x00
extern_table = 0x01
extern_mem = 0x02
extern_global = 0x03

extern_type = {
    extern_func: ['func'],
    extern_table: ['table'],
    extern_mem: ['mem'],
    extern_global: ['global'],
}
</t>
<t tx="ekr.20190302133319.25">def grow(self, n: int):
    if self.limits.maximum and self.size + n &gt; self.limits.maximum:
        raise Exception('pywasm: out of memory limit')
    self.data.extend([0 for _ in range(n * 64 * 1024)])
    self.size += n


</t>
<t tx="ekr.20190302133319.26">class GlobalInstance:
    # A global instance is the runtime representation of a global variable. It holds an individual value and a flag
    # indicating whether it is mutable.
    #
    # globalinst ::= {value val, mut mut}
    #
    # The value of mutable globals can be mutated through variable instructions or by external means provided by the
    # embedder.
    @others
</t>
<t tx="ekr.20190302133319.27">def __init__(self, value: 'Value', mut: bool):
    self.value = value
    self.mut = mut


</t>
<t tx="ekr.20190302133319.28">class ExportInstance:
    # An export instance is the runtime representation of an export. It defines the export’s name and the associated
    # external value.
    #
    # exportinst ::= {name name, value externval}
    @others
</t>
<t tx="ekr.20190302133319.29">def __init__(self, name: str, value: 'ExternValue'):
    self.name = name
    self.value = value


</t>
<t tx="ekr.20190302133319.30">class ExternValue:
    # An external value is the runtime representation of an entity that can be imported or exported. It is an address
    # denoting either a function instance, table instance, memory instance, or global instances in the shared store.
    #
    # externval ::= func funcaddr
    #             | table tableaddr
    #             | mem memaddr
    #             | global globaladdr
    @others
</t>
<t tx="ekr.20190302133319.31">def __init__(self, extern_type: int, addr: int):
    self.extern_type = extern_type
    self.addr = addr


</t>
<t tx="ekr.20190302133319.32">class Value:
    # Values are represented by themselves.
    @others
</t>
<t tx="ekr.20190302133319.33">def __init__(self, valtype: int, n):
    self.valtype = valtype
    self.n = n

</t>
<t tx="ekr.20190302133319.34">def __repr__(self):
    return str(self.n)

</t>
<t tx="ekr.20190302133319.35">@classmethod
def from_i32(cls, n):
    return Value(convention.i32, n)

</t>
<t tx="ekr.20190302133319.36">@classmethod
def from_i64(cls, n):
    return Value(convention.i64, n)

</t>
<t tx="ekr.20190302133319.37">@classmethod
def from_f32(cls, n):
    return Value(convention.f32, n)

</t>
<t tx="ekr.20190302133319.38">@classmethod
def from_f64(cls, n):
    return Value(convention.f64, n)


</t>
<t tx="ekr.20190302133319.39">class Label:
    # Labels carry an argument arity n and their associated branch target, which is expressed syntactically as an
    # instruction sequence:
    #
    # label ::= labeln{instr∗}
    #
    # Intuitively, instr∗ is the continuation to execute when the branch is taken, in place of the original control
    # construct.
    @others
</t>
<t tx="ekr.20190302133319.4">class VirtualMachine:
    @others
</t>
<t tx="ekr.20190302133319.40">def __init__(self, arity: int, continuation: int):
    self.arity = arity
    self.continuation = continuation

</t>
<t tx="ekr.20190302133319.41">def __repr__(self):
    return '|'


</t>
<t tx="ekr.20190302133319.42">class Frame:
    # Activation frames carry the return arity of the respective function, hold the values of its locals (including
    # arguments) in the order corresponding to their static local indices, and a reference to the function’s own module
    # instance:
    #
    # activation ::= framen{frame}
    # frame ::= {locals val∗, module moduleinst}
    @others
</t>
<t tx="ekr.20190302133319.43">def __init__(self, module: 'ModuleInstance', locs: typing.List[Value], arity: int, continuation: int):
    self.module = module
    self.locals = locs
    self.arity = arity
    self.continuation = continuation

</t>
<t tx="ekr.20190302133319.44">def __repr__(self):
    return '*'


</t>
<t tx="ekr.20190302133319.45">class Stack:
    # Besides the store, most instructions interact with an implicit stack. The stack contains three kinds of entries:
    #
    # Values: the operands of instructions.
    # Labels: active structured control instructions that can be targeted by branches.
    # Activations: the call frames of active function calls.
    #
    # These entries can occur on the stack in any order during the execution of a program. Stack entries are described
    # by abstract syntax as follows.
    @others
</t>
<t tx="ekr.20190302133319.46">def __init__(self):
    self.data = []

</t>
<t tx="ekr.20190302133319.47">def __repr__(self):
    return self.data.__repr__()

</t>
<t tx="ekr.20190302133319.48">def add(self, e):
    self.data.append(e)

</t>
<t tx="ekr.20190302133319.49">def ext(self, e: typing.List):
    for i in e:
        self.add(i)

</t>
<t tx="ekr.20190302133319.5">def __init__(self, module: structure.Module, imps: typing.Dict):
    self.module = module
    self.module_instance = execution.ModuleInstance()
    self.store = execution.Store()
    externvals = []
    for e in self.module.imports:
        if e.module not in imps or e.name not in imps[e.module]:
            raise Exception(f'pywasm: global import {e.module}.{e.name} not found')
        if e.kind == convention.extern_func:
            a = execution.HostFunc(self.module.types[e.desc], imps[e.module][e.name])
            self.store.funcs.append(a)
            externvals.append(execution.ExternValue(e.kind, len(self.store.funcs) - 1))
            continue
        if e.kind == convention.extern_table:
            raise NotImplementedError
        if e.kind == convention.extern_mem:
            raise NotImplementedError
        if e.kind == convention.extern_global:
            a = execution.GlobalInstance(execution.Value(e.desc.valtype, imps[e.module][e.name]), e.desc.mut)
            self.store.globals.append(a)
            externvals.append(execution.ExternValue(e.kind, len(self.store.globals) - 1))
            continue
    self.module_instance.instantiate(self.module, self.store, externvals)

</t>
<t tx="ekr.20190302133319.50">def pop(self):
    return self.data.pop()

</t>
<t tx="ekr.20190302133319.51">def len(self):
    return len(self.data)

</t>
<t tx="ekr.20190302133319.52">def top(self):
    return self.data[-1]

</t>
<t tx="ekr.20190302133319.53">def status(self):
    for i in range(len(self.data)):
        i = -1 - i
        if isinstance(self.data[i], Label):
            return Label
        if isinstance(self.data[i], Frame):
            return Frame


</t>
<t tx="ekr.20190302133319.54">class AdministrativeInstruction:
    pass


</t>
<t tx="ekr.20190302133319.55">class BlockContext:
    pass


</t>
<t tx="ekr.20190302133319.56">class Configuration:
    # A configuration consists of the current store and an executing thread.
    #
    # A thread is a computation over instructions that operates relative to a current frame referring to the home
    # module instance that the computation runs in.
    #
    # config ::= store;thread
    # thread ::= frame;instr∗
    pass


</t>
<t tx="ekr.20190302133319.57">class EvaluationContext:
    # Finally, the following definition of evaluation context and associated structural rules enable reduction inside
    # instruction sequences and administrative forms as well as the propagation of traps.
    pass


</t>
<t tx="ekr.20190302133319.58">def import_matching_limits(limits1: structure.Limits, limits2: structure.Limits):
    n1 = limits1.minimum
    m1 = limits1.maximum
    n2 = limits2.minimum
    m2 = limits2.maximum
    if n1 &lt; n2:
        return False
    if m2 is None or (m1 != None and m2 != None and m1 &lt;= m2):
        return True
    return False


</t>
<t tx="ekr.20190302133319.59">class ModuleInstance:
    # A module instance is the runtime representation of a module. It is created by instantiating a module, and
    # collects runtime representations of all entities that are imported, defined, or exported by the module.
    #
    # moduleinst ::= {
    #     types functype∗
    #     funcaddrs funcaddr∗
    #     tableaddrs tableaddr∗
    #     memaddrs memaddr∗
    #     globaladdrs globaladdr∗
    #     exports exportinst∗
    # }
    @others
</t>
<t tx="ekr.20190302133319.6">def func_addr(self, name: str):
    for e in self.module_instance.exports:
        if e.name == name and e.value.extern_type == convention.extern_func:
            return e.value.addr
    raise Exception('pywasm: function not found')

</t>
<t tx="ekr.20190302133319.60">def __init__(self):
    self.types: typing.List[structure.FunctionType] = []
    self.funcaddrs: typing.List[int] = []
    self.tableaddrs: typing.List[int] = []
    self.memaddrs: typing.List[int] = []
    self.globaladdrs: typing.List[int] = []
    self.exports: typing.List[ExportInstance] = []

</t>
<t tx="ekr.20190302133319.61">def instantiate(
    self,
    module: structure.Module,
    store: Store,
    externvals: typing.List[ExternValue] = None,
):
    self.types = module.types
    # [TODO] If module is not valid, then panic
    # Assert: module is valid with external types classifying its imports
    for e in module.imports:
        assert e.kind in convention.extern_type
    # Assert: number m of imports is equal to the number n of provided external values
    assert len(module.imports) == len(externvals)
    # Assert: externvals matching imports of module
    for i in range(len(externvals)):
        e = externvals[i]
        assert e.extern_type in convention.extern_type
        if e.extern_type == convention.extern_func:
            a = store.funcs[e.addr]
            b = self.types[module.imports[i].desc]
            assert a.functype.args == b.args
            assert a.functype.rets == b.rets
        elif e.extern_type == convention.extern_table:
            a = store.tables[e.addr]
            b = module.imports[i].desc
            assert a.elemtype == b.elemtype
            assert import_matching_limits(b.limits, a.limits)
        elif e.extern_type == convention.extern_mem:
            a = store.mems[e.addr]
            b = module.imports[i].desc
            assert import_matching_limits(b, a)
        elif e.extern_type == convention.extern_global:
            a = store.globals[e.addr]
            b = module.imports[i].desc
            assert a.value.valtype == b.valtype
    # Let vals be the vector of global initialization values determined by module and externvaln
    auxmod = ModuleInstance()
    auxmod.globaladdrs = [e.addr for e in externvals if e.extern_type == convention.extern_global]
    stack = Stack()
    frame = Frame(auxmod, [], 1, -1)
    vals = []
    for glob in module.globals:
        stack.add(frame)
        v = exec_expr(store, frame, stack, glob.expr)[0]
        vals.append(v)
    # Allocation
    self.allocate(module, store, externvals, vals)

    frame = Frame(self, [], 1, -1)
    # For each element segment in module.elem, do:
    for e in module.elem:
        stack.add(frame)
        offset = exec_expr(store, frame, stack, e.expr)[0]
        assert offset.valtype == convention.i32
        t = store.tables[self.tableaddrs[e.tableidx]]
        for i, e in enumerate(e.init):
            t.elem[offset.n + i] = e
    # For each data segment in module.data, do:
    for e in module.data:
        stack.add(frame)
        offset = exec_expr(store, frame, stack, e.expr)[0]
        assert offset.valtype == convention.i32
        m = store.mems[self.memaddrs[e.memidx]]
        end = offset.n + len(e.init)
        assert end &lt;= len(m.data)
        m.data[offset.n: offset.n + len(e.init)] = e.init
    # If the start function module.start is not empty, invoke the function instance
    if module.start is not None:
        log.debugln(f'Running start function {module.start}:')
        call(self, module.start, store, stack)

</t>
<t tx="ekr.20190302133319.62">def allocate(
    self,
    module: structure.Module,
    store: Store,
    externvals: typing.List[ExternValue],
    vals: typing.List[Value],
):
    self.types = module.types
    # Imports
    self.funcaddrs.extend([e.addr for e in externvals if e.extern_type == convention.extern_func])
    self.tableaddrs.extend([e.addr for e in externvals if e.extern_type == convention.extern_table])
    self.memaddrs.extend([e.addr for e in externvals if e.extern_type == convention.extern_mem])
    self.globaladdrs.extend([e.addr for e in externvals if e.extern_type == convention.extern_global])
    # For each function func in module.funcs, do:
    for func in module.funcs:
        functype = self.types[func.typeidx]
        funcinst = WasmFunc(functype, self, func)
        store.funcs.append(funcinst)
        self.funcaddrs.append(len(store.funcs) - 1)
    # For each table in module.tables, do:
    for table in module.tables:
        tabletype = table.tabletype
        elemtype = tabletype.elemtype
        tableinst = TableInstance(elemtype, tabletype.limits)
        store.tables.append(tableinst)
        self.tableaddrs.append(len(store.tables) - 1)
    # For each memory module.mems, do:
    for mem in module.mems:
        meminst = MemoryInstance(mem.memtype)
        store.mems.append(meminst)
        self.memaddrs.append(len(store.mems) - 1)
    # For each global in module.globals, do:
    for i, glob in enumerate(module.globals):
        val = vals[i]
        if val.valtype != glob.globaltype.valtype:
            raise Exception('pywasm: mismatch valtype')
        globalinst = GlobalInstance(val, glob.globaltype.mut)
        store.globals.append(globalinst)
        self.globaladdrs.append(len(store.globals) - 1)
    # For each export in module.exports, do:
    for i, export in enumerate(module.exports):
        externval = ExternValue(export.kind, export.desc)
        exportinst = ExportInstance(export.name, externval)
        self.exports.append(exportinst)


</t>
<t tx="ekr.20190302133319.63">def hostfunc_call(
    _: ModuleInstance,
    address: int,
    store: Store,
    stack: Stack,
):
    f: HostFunc = store.funcs[address]
    valn = [stack.pop() for _ in f.functype.args][::-1]
    r = f.hostcode(*[e.n for e in valn])
    if r:
        stack.add(Value(f.functype.rets[0], r))


</t>
<t tx="ekr.20190302133319.64">def wasmfunc_call(
    module: ModuleInstance,
    address: int,
    store: Store,
    stack: Stack,
):
    f: WasmFunc = store.funcs[address]
    code = f.code.expr.data
    valn = [stack.pop() for _ in f.functype.args][::-1]
    val0 = []
    for e in f.code.locals:
        if e == convention.i32:
            val0.append(Value.from_i32(0))
        elif e == convention.i64:
            val0.append(Value.from_i64(0))
        elif e == convention.f32:
            val0.append(Value.from_f32(0))
        else:
            val0.append(Value.from_f64(0))
    frame = Frame(module, valn + val0, len(f.functype.rets), len(code))
    stack.add(frame)
    stack.add(Label(len(f.functype.rets), len(code)))
    # An expression is evaluated relative to a current frame pointing to its containing module instance.
    exec_expr(store, frame, stack, f.code.expr)
    # Exit
    if not isinstance(stack.data[-1 - frame.arity], Frame):
        raise Exception('pywasm: signature mismatch in call')
    del stack.data[-1 - frame.arity]
    if frame.arity &gt; 0:
        return stack.data[-frame.arity:]
    return []


</t>
<t tx="ekr.20190302133319.65">def call(
    module: ModuleInstance,
    address: int,
    store: Store,
    stack: Stack,
):
    f = store.funcs[address]
    assert len(f.functype.rets) &lt;= 1
    for i, t in enumerate(f.functype.args[::-1]):
        ia = t
        ib = stack.data[-1 - i]
        if ia != ib.valtype:
            raise Exception('pywasm: signature mismatch in call')
    if isinstance(f, WasmFunc):
        return wasmfunc_call(module, address, store, stack)
    if isinstance(f, HostFunc):
        return hostfunc_call(module, address, store, stack)
    raise KeyError


</t>
<t tx="ekr.20190302133319.66">def spec_br(l: int, stack: Stack) -&gt; int:
    # Let L be the l-th label appearing on the stack, starting from the top and counting from zero.
    L = [i for i in stack.data if isinstance(i, Label)][::-1][l]
    n = L.arity
    v = [stack.pop() for _ in range(n)][::-1]

    s = 0
    while True:
        e = stack.pop()
        if isinstance(e, Label):
            s += 1
            if s == l + 1:
                break
    stack.ext(v)
    return L.continuation - 1


</t>
<t tx="ekr.20190302133319.67">def exec_expr(
    store: Store,
    frame: Frame,
    stack: Stack,
    expr: structure.Expression,
):
    module = frame.module
    if not expr.data:
        raise Exception('pywasm: empty init expr')
    pc = -1
    while True:
        pc += 1
        if pc &gt;= len(expr.data):
            break
        i = expr.data[pc]
        log.debugln(f'{str(i):&lt;18} {stack}')
        opcode = i.code
        if opcode &gt;= convention.unreachable and opcode &lt;= convention.call_indirect:
            if opcode == convention.unreachable:
                raise Exception('pywasm: reached unreachable')
            if opcode == convention.nop:
                continue
            if opcode == convention.block:
                arity = 0 if i.immediate_arguments == convention.empty else 1
                stack.add(Label(arity, expr.composition[pc][-1] + 1))
                continue
            if opcode == convention.loop:
                stack.add(Label(0, expr.composition[pc][0]))
                continue
            if opcode == convention.if_:
                c = stack.pop().n
                arity = 0 if i.immediate_arguments == convention.empty else 1
                stack.add(Label(arity, expr.composition[pc][-1] + 1))
                if c != 0:
                    continue
                if len(expr.composition[pc]) &gt; 2:
                    pc = expr.composition[pc][1]
                    continue
                pc = expr.composition[pc][-1] - 1
                continue
            if opcode == convention.else_:
                for i in range(len(stack.data)):
                    i = -1 - i
                    e = stack.data[i]
                    if isinstance(e, Label):
                        pc = e.continuation - 1
                        del stack.data[i]
                        break
                continue
            if opcode == convention.end:
                # label{instr∗} val* end -&gt; val*
                if stack.status() == Label:
                    for i in range(len(stack.data)):
                        i = -1 - i
                        if isinstance(stack.data[i], Label):
                            del stack.data[i]
                            break
                    continue
                # frame{F} val* end -&gt; val*
                v = [stack.pop() for _ in range(frame.arity)][::-1]
                assert isinstance(stack.pop(), Frame)
                stack.ext(v)
                continue
            if opcode == convention.br:
                pc = spec_br(i.immediate_arguments, stack)
                continue
            if opcode == convention.br_if:
                if stack.pop().n == 0:
                    continue
                pc = spec_br(i.immediate_arguments, stack)
                continue
            if opcode == convention.br_table:
                a = i.immediate_arguments[0]
                l = i.immediate_arguments[1]
                c = stack.pop().n
                if c &gt;= 0 and c &lt; len(a):
                    l = a[c]
                pc = spec_br(l, stack)
                continue
            if opcode == convention.return_:
                v = [stack.pop() for _ in range(frame.arity)][::-1]
                while True:
                    e = stack.pop()
                    if isinstance(e, Frame):
                        stack.add(e)
                        break
                stack.ext(v)
                break
            if opcode == convention.call:
                call(module, module.funcaddrs[i.immediate_arguments], store, stack)
                continue
            if opcode == convention.call_indirect:
                if i.immediate_arguments[1] != 0x00:
                    raise Exception("pywasm: zero byte malformed in call_indirect")
                idx = stack.pop().n
                tab = store.tables[module.tableaddrs[0]]
                if not 0 &lt;= idx &lt; len(tab.elem):
                    raise Exception('pywasm: undefined element index')
                call(module, tab.elem[idx], store, stack)
                continue
            continue
        if opcode == convention.drop:
            stack.pop()
            continue
        if opcode == convention.select:
            cond = stack.pop().n
            a = stack.pop()
            b = stack.pop()
            if cond:
                stack.add(b)
            else:
                stack.add(a)
            continue
        if opcode == convention.get_local:
            stack.add(frame.locals[i.immediate_arguments])
            continue
        if opcode == convention.set_local:
            if i.immediate_arguments &gt;= len(frame.locals):
                frame.locals.extend(
                    [Value.from_i32(0) for _ in range(i.immediate_arguments - len(frame.locals) + 1)]
                )
            frame.locals[i.immediate_arguments] = stack.pop()
            continue
        if opcode == convention.tee_local:
            frame.locals[i.immediate_arguments] = stack.top()
            continue
        if opcode == convention.get_global:
            stack.add(store.globals[module.globaladdrs[i.immediate_arguments]].value)
            continue
        if opcode == convention.set_global:
            store.globals[module.globaladdrs[i.immediate_arguments]] = GlobalInstance(stack.pop(), True)
            continue
        if opcode &gt;= convention.i32_load and opcode &lt;= convention.grow_memory:
            m = store.mems[module.memaddrs[0]]
            if opcode &gt;= convention.i32_load and opcode &lt;= convention.i64_load32_u:
                a = stack.pop().n + i.immediate_arguments[1]
                if a + convention.opcodes[opcode][2] &gt; len(m.data):
                    raise Exception('pywasm: out of bounds memory access')
                if opcode == convention.i32_load:
                    stack.add(Value.from_i32(num.LittleEndian.i32(m.data[a:a + 4])))
                    continue
                if opcode == convention.i64_load:
                    stack.add(Value.from_i64(num.LittleEndian.i64(m.data[a:a + 8])))
                    continue
                if opcode == convention.f32_load:
                    stack.add(Value.from_f32(num.LittleEndian.f32(m.data[a:a + 4])))
                    continue
                if opcode == convention.f64_load:
                    stack.add(Value.from_f64(num.LittleEndian.f64(m.data[a:a + 8])))
                    continue
                if opcode == convention.i32_load8_s:
                    stack.add(Value.from_i32(num.LittleEndian.i8(m.data[a:a + 1])))
                    continue
                if opcode == convention.i32_load8_u:
                    stack.add(Value.from_i32(num.LittleEndian.u8(m.data[a:a + 1])))
                    continue
                if opcode == convention.i32_load16_s:
                    stack.add(Value.from_i32(num.LittleEndian.i16(m.data[a:a + 2])))
                    continue
                if opcode == convention.i32_load16_u:
                    stack.add(Value.from_i32(num.LittleEndian.u16(m.data[a:a + 2])))
                    continue
                if opcode == convention.i64_load8_s:
                    stack.add(Value.from_i64(num.LittleEndian.i8(m.data[a:a + 1])))
                    continue
                if opcode == convention.i64_load8_u:
                    stack.add(Value.from_i64(num.LittleEndian.u8(m.data[a:a + 1])))
                    continue
                if opcode == convention.i64_load16_s:
                    stack.add(Value.from_i64(num.LittleEndian.i16(m.data[a:a + 2])))
                    continue
                if opcode == convention.i64_load16_u:
                    stack.add(Value.from_i64(num.LittleEndian.u16(m.data[a:a + 2])))
                    continue
                if opcode == convention.i64_load32_s:
                    stack.add(Value.from_i64(num.LittleEndian.i32(m.data[a:a + 4])))
                    continue
                if opcode == convention.i64_load32_u:
                    stack.add(Value.from_i64(num.LittleEndian.u32(m.data[a:a + 4])))
                    continue
                continue
            if opcode &gt;= convention.i32_store and opcode &lt;= convention.i64_store32:
                v = stack.pop().n
                a = stack.pop().n + i.immediate_arguments[1]
                if a + convention.opcodes[opcode][2] &gt; len(m.data):
                    raise Exception('pywasm: out of bounds memory access')
                if opcode == convention.i32_store:
                    m.data[a:a + 4] = num.LittleEndian.pack_i32(v)
                    continue
                if opcode == convention.i64_store:
                    m.data[a:a + 8] = num.LittleEndian.pack_i64(v)
                    continue
                if opcode == convention.f32_store:
                    m.data[a:a + 4] = num.LittleEndian.pack_f32(v)
                    continue
                if opcode == convention.f64_store:
                    m.data[a:a + 8] = num.LittleEndian.pack_f64(v)
                    continue
                if opcode == convention.i32_store8:
                    m.data[a:a + 1] = num.LittleEndian.pack_i8(num.int2i8(v))
                    continue
                if opcode == convention.i32_store16:
                    m.data[a:a + 2] = num.LittleEndian.pack_i16(num.int2i16(v))
                    continue
                if opcode == convention.i64_store8:
                    m.data[a:a + 1] = num.LittleEndian.pack_i8(num.int2i8(v))
                    continue
                if opcode == convention.i64_store16:
                    m.data[a:a + 2] = num.LittleEndian.pack_i16(num.int2i16(v))
                    continue
                if opcode == convention.i64_store32:
                    m.data[a:a + 4] = num.LittleEndian.pack_i32(num.int2i32(v))
                    continue
                continue
            if opcode == convention.current_memory:
                stack.add(Value.from_i32(m.size))
                continue
            if opcode == convention.grow_memory:
                cursize = m.size
                m.grow(stack.pop().n)
                stack.add(Value.from_i32(cursize))
                continue
            continue
        if opcode &gt;= convention.i32_const and opcode &lt;= convention.f64_const:
            if opcode == convention.i32_const:
                stack.add(Value.from_i32(i.immediate_arguments))
                continue
            if opcode == convention.i64_const:
                stack.add(Value.from_i64(i.immediate_arguments))
                continue
            if opcode == convention.f32_const:
                stack.add(Value.from_f32(i.immediate_arguments))
                continue
            if opcode == convention.f64_const:
                stack.add(Value.from_f64(i.immediate_arguments))
                continue
            continue
        if opcode == convention.i32_eqz:
            stack.add(Value.from_i32(int(stack.pop().n == 0)))
            continue
        if opcode &gt;= convention.i32_eq and opcode &lt;= convention.i32_geu:
            b = stack.pop().n
            a = stack.pop().n
            if opcode == convention.i32_eq:
                stack.add(Value.from_i32(int(a == b)))
                continue
            if opcode == convention.i32_ne:
                stack.add(Value.from_i32(int(a != b)))
                continue
            if opcode == convention.i32_lts:
                stack.add(Value.from_i32(int(a &lt; b)))
                continue
            if opcode == convention.i32_ltu:
                stack.add(Value.from_i32(int(num.int2u32(a) &lt; num.int2u32(b))))
                continue
            if opcode == convention.i32_gts:
                stack.add(Value.from_i32(int(a &gt; b)))
                continue
            if opcode == convention.i32_gtu:
                stack.add(Value.from_i32(int(num.int2u32(a) &gt; num.int2u32(b))))
                continue
            if opcode == convention.i32_les:
                stack.add(Value.from_i32(int(a &lt;= b)))
                continue
            if opcode == convention.i32_leu:
                stack.add(Value.from_i32(int(num.int2u32(a) &lt;= num.int2u32(b))))
                continue
            if opcode == convention.i32_ges:
                stack.add(Value.from_i32(int(a &gt;= b)))
                continue
            if opcode == convention.i32_geu:
                stack.add(Value.from_i32(int(num.int2u32(a) &gt;= num.int2u32(b))))
                continue
            continue
        if opcode == convention.i64_eqz:
            stack.add(Value.from_i32(int(stack.pop().n == 0)))
            continue
        if opcode &gt;= convention.i64_eq and opcode &lt;= convention.i64_geu:
            b = stack.pop().n
            a = stack.pop().n
            if opcode == convention.i64_eq:
                stack.add(Value.from_i32(int(a == b)))
                continue
            if opcode == convention.i64_ne:
                stack.add(Value.from_i32(int(a != b)))
                continue
            if opcode == convention.i64_lts:
                stack.add(Value.from_i32(int(a &lt; b)))
                continue
            if opcode == convention.i64_ltu:
                stack.add(Value.from_i32(int(num.int2u64(a) &lt; num.int2u64(b))))
                continue
            if opcode == convention.i64_gts:
                stack.add(Value.from_i32(int(a &gt; b)))
                continue
            if opcode == convention.i64_gtu:
                stack.add(Value.from_i32(int(num.int2u64(a) &gt; num.int2u64(b))))
                continue
            if opcode == convention.i64_les:
                stack.add(Value.from_i32(int(a &lt;= b)))
                continue
            if opcode == convention.i64_leu:
                stack.add(Value.from_i32(int(num.int2u64(a) &lt;= num.int2u64(b))))
                continue
            if opcode == convention.i64_ges:
                stack.add(Value.from_i32(int(a &gt;= b)))
                continue
            if opcode == convention.i64_geu:
                stack.add(Value.from_i32(int(num.int2u64(a) &gt;= num.int2u64(b))))
                continue
            continue
        if opcode &gt;= convention.f32_eq and opcode &lt;= convention.f64_ge:
            b = stack.pop().n
            a = stack.pop().n
            if opcode == convention.f32_eq:
                stack.add(Value.from_i32(int(a == b)))
                continue
            if opcode == convention.f32_ne:
                stack.add(Value.from_i32(int(a != b)))
                continue
            if opcode == convention.f32_lt:
                stack.add(Value.from_i32(int(a &lt; b)))
                continue
            if opcode == convention.f32_gt:
                stack.add(Value.from_i32(int(a &gt; b)))
                continue
            if opcode == convention.f32_le:
                stack.add(Value.from_i32(int(a &lt;= b)))
                continue
            if opcode == convention.f32_ge:
                stack.add(Value.from_i32(int(a &gt;= b)))
                continue
            if opcode == convention.f64_eq:
                stack.add(Value.from_i32(int(a == b)))
                continue
            if opcode == convention.f64_ne:
                stack.add(Value.from_i32(int(a != b)))
                continue
            if opcode == convention.f64_lt:
                stack.add(Value.from_i32(int(a &lt; b)))
                continue
            if opcode == convention.f64_gt:
                stack.add(Value.from_i32(int(a &gt; b)))
                continue
            if opcode == convention.f64_le:
                stack.add(Value.from_i32(int(a &lt;= b)))
                continue
            if opcode == convention.f64_ge:
                stack.add(Value.from_i32(int(a &gt;= b)))
                continue
            continue
        if opcode &gt;= convention.i32_clz and opcode &lt;= convention.i32_popcnt:
            a = stack.pop().n
            if opcode == convention.i32_clz:
                c = 0
                while c &lt; 32 and (a &amp; 0x80000000) == 0:
                    c += 1
                    a *= 2
                stack.add(Value.from_i32(c))
                continue
            if opcode == convention.i32_ctz:
                c = 0
                while c &lt; 32 and (a % 2) == 0:
                    c += 1
                    a /= 2
                stack.add(Value.from_i32(c))
                continue
            if opcode == convention.i32_popcnt:
                c = 0
                for i in range(32):
                    if 0x1 &amp; a:
                        c += 1
                    a /= 2
                stack.add(Value.from_i32(c))
                continue
            continue
        if opcode &gt;= convention.i32_add and opcode &lt;= convention.i32_rotr:
            b = stack.pop().n
            a = stack.pop().n
            if opcode in [
                convention.i32_divs,
                convention.i32_divu,
                convention.i32_rems,
                convention.i32_remu,
            ]:
                if b == 0:
                    raise Exception('pywasm: integer divide by zero')
            if opcode == convention.i32_add:
                stack.add(Value.from_i32(num.int2i32(a + b)))
                continue
            if opcode == convention.i32_sub:
                stack.add(Value.from_i32(num.int2i32(a - b)))
                continue
            if opcode == convention.i32_mul:
                stack.add(Value.from_i32(num.int2i32(a * b)))
                continue
            if opcode == convention.i32_divs:
                if a == 0x80000000 and b == -1:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i32(num.idiv_s(a, b)))
                continue
            if opcode == convention.i32_divu:
                stack.add(Value.from_i32(num.int2i32(num.int2u32(a) // num.int2u32(b))))
                continue
            if opcode == convention.i32_rems:
                stack.add(Value.from_i32(num.irem_s(a, b)))
                continue
            if opcode == convention.i32_remu:
                stack.add(Value.from_i32(num.int2i32(num.int2u32(a) % num.int2u32(b))))
                continue
            if opcode == convention.i32_and:
                stack.add(Value.from_i32(a &amp; b))
                continue
            if opcode == convention.i32_or:
                stack.add(Value.from_i32(a | b))
                continue
            if opcode == convention.i32_xor:
                stack.add(Value.from_i32(a ^ b))
                continue
            if opcode == convention.i32_shl:
                stack.add(Value.from_i32(num.int2i32(a &lt;&lt; (b % 0x20))))
                continue
            if opcode == convention.i32_shrs:
                stack.add(Value.from_i32(a &gt;&gt; (b % 0x20)))
                continue
            if opcode == convention.i32_shru:
                stack.add(Value.from_i32(num.int2u32(a) &gt;&gt; (b % 0x20)))
                continue
            if opcode == convention.i32_rotl:
                stack.add(Value.from_i32(num.int2i32(num.rotl_u32(a, b))))
                continue
            if opcode == convention.i32_rotr:
                stack.add(Value.from_i32(num.int2i32(num.rotr_u32(a, b))))
                continue
            continue
        if opcode &gt;= convention.i64_clz and opcode &lt;= convention.i64_popcnt:
            a = stack.pop().n
            if opcode == convention.i64_clz:
                if a &lt; 0:
                    stack.add(Value.from_i32(0))
                    continue
                c = 1
                while c &lt; 63 and (a &amp; 0x4000000000000000) == 0:
                    c += 1
                    a *= 2
                stack.add(Value.from_i64(c))
                continue
            if opcode == convention.i64_ctz:
                c = 0
                while c &lt; 64 and (a % 2) == 0:
                    c += 1
                    a /= 2
                stack.add(Value.from_i64(c))
                continue
            if opcode == convention.i64_popcnt:
                c = 0
                for i in range(64):
                    if 0x1 &amp; a:
                        c += 1
                    a /= 2
                stack.add(Value.from_i64(c))
                continue
            continue
        if opcode &gt;= convention.i64_add and opcode &lt;= convention.i64_rotr:
            b = stack.pop().n
            a = stack.pop().n
            if opcode in [
                convention.i64_divs,
                convention.i64_divu,
                convention.i64_rems,
                convention.i64_remu,
            ]:
                if b == 0:
                    raise Exception('pywasm: integer divide by zero')
            if opcode == convention.i64_add:
                stack.add(Value.from_i64(num.int2i64(a + b)))
                continue
            if opcode == convention.i64_sub:
                stack.add(Value.from_i64(num.int2i64(a - b)))
                continue
            if opcode == convention.i64_mul:
                stack.add(Value.from_i64(num.int2i64(a * b)))
                continue
            if opcode == convention.i64_divs:
                stack.add(Value.from_i64(num.idiv_s(a, b)))
                continue
            if opcode == convention.i64_divu:
                stack.add(Value.from_i64(num.int2i64(num.int2u64(a) // num.int2u64(b))))
                continue
            if opcode == convention.i64_rems:
                stack.add(Value.from_i64(num.irem_s(a, b)))
            if opcode == convention.i64_remu:
                stack.add(Value.from_i64(num.int2u64(a) % num.int2u64(b)))
                continue
            if opcode == convention.i64_and:
                stack.add(Value.from_i64(a &amp; b))
                continue
            if opcode == convention.i64_or:
                stack.add(Value.from_i64(a | b))
                continue
            if opcode == convention.i64_xor:
                stack.add(Value.from_i64(a ^ b))
                continue
            if opcode == convention.i64_shl:
                stack.add(Value.from_i64(num.int2i64(a &lt;&lt; (b % 0x40))))
                continue
            if opcode == convention.i64_shrs:
                stack.add(Value.from_i64(a &gt;&gt; (b % 0x40)))
                continue
            if opcode == convention.i64_shru:
                stack.add(Value.from_i64(num.int2u64(a) &gt;&gt; (b % 0x40)))
                continue
            if opcode == convention.i64_rotl:
                stack.add(Value.from_i64(num.int2i64(num.rotl_u64(a, b))))
                continue
            if opcode == convention.i64_rotr:
                stack.add(Value.from_i64(num.int2i64(num.rotr_u64(a, b))))
                continue
            continue
        if opcode &gt;= convention.f32_abs and opcode &lt;= convention.f32_sqrt:
            a = stack.pop().n
            if opcode == convention.f32_abs:
                stack.add(Value.from_f32(abs(a)))
                continue
            if opcode == convention.f32_neg:
                stack.add(Value.from_f32(-a))
                continue
            if opcode == convention.f32_ceil:
                stack.add(Value.from_f32(math.ceil(a)))
                continue
            if opcode == convention.f32_floor:
                stack.add(Value.from_f32(math.floor(a)))
                continue
            if opcode == convention.f32_trunc:
                stack.add(Value.from_f32(math.trunc(a)))
                continue
            if opcode == convention.f32_nearest:
                ceil = math.ceil(a)
                if ceil - a &gt;= 0.5:
                    r = ceil
                else:
                    r = ceil - 1
                stack.add(Value.from_f32(r))
                continue
            if opcode == convention.f32_sqrt:
                stack.add(Value.from_f32(math.sqrt(a)))
                continue
            continue
        if opcode &gt;= convention.f32_add and opcode &lt;= convention.f32_copysign:
            b = stack.pop().n
            a = stack.pop().n
            if opcode == convention.f32_add:
                stack.add(Value.from_f32(a + b))
                continue
            if opcode == convention.f32_sub:
                stack.add(Value.from_f32(a - b))
                continue
            if opcode == convention.f32_mul:
                stack.add(Value.from_f32(a * b))
                continue
            if opcode == convention.f32_div:
                stack.add(Value.from_f32(a / b))
                continue
            if opcode == convention.f32_min:
                stack.add(Value.from_f32(min(a, b)))
                continue
            if opcode == convention.f32_max:
                stack.add(Value.from_f32(max(a, b)))
                continue
            if opcode == convention.f32_copysign:
                stack.add(Value.from_f32(math.copysign(a, b)))
                continue
            continue
        if opcode &gt;= convention.f64_abs and opcode &lt;= convention.f64_sqrt:
            a = stack.pop().n
            if opcode == convention.f64_abs:
                stack.add(Value.from_f64(abs(a)))
                continue
            if opcode == convention.f64_neg:
                stack.add(Value.from_f64(-a))
                continue
            if opcode == convention.f64_ceil:
                stack.add(Value.from_f64(math.ceil(a)))
                continue
            if opcode == convention.f64_floor:
                stack.add(Value.from_f64(math.floor(a)))
                continue
            if opcode == convention.f64_trunc:
                stack.add(Value.from_f64(math.trunc(a)))
                continue
            if opcode == convention.f64_nearest:
                ceil = math.ceil(a)
                if ceil - a &gt;= 0.5:
                    r = ceil
                else:
                    r = ceil - 1
                stack.add(Value.from_f64(r))
                continue
            if opcode == convention.f64_sqrt:
                stack.add(Value.from_f64(math.sqrt(a)))
                continue
            continue
        if opcode &gt;= convention.f64_add and opcode &lt;= convention.f64_copysign:
            b = stack.pop().n
            a = stack.pop().n
            if opcode == convention.f64_add:
                stack.add(Value.from_f64(a + b))
                continue
            if opcode == convention.f64_sub:
                stack.add(Value.from_f64(a - b))
                continue
            if opcode == convention.f64_mul:
                stack.add(Value.from_f64(a * b))
                continue
            if opcode == convention.f64_div:
                stack.add(Value.from_f64(a / b))
                continue
            if opcode == convention.f64_min:
                stack.add(Value.from_f64(min(a, b)))
                continue
            if opcode == convention.f64_max:
                stack.add(Value.from_f64(max(a, b)))
                continue
            if opcode == convention.f64_copysign:
                stack.add(Value.from_f64(math.copysign(a, b)))
                continue
            continue
        if opcode &gt;= convention.i32_wrap_i64 and opcode &lt;= convention.f64_promote_f32:
            a = stack.pop().n
            if opcode in [
                convention.i32_trunc_sf32,
                convention.i32_trunc_uf32,
                convention.i32_trunc_sf64,
                convention.i32_trunc_uf64,
                convention.i64_trunc_sf32,
                convention.i64_trunc_uf32,
                convention.i64_trunc_sf64,
                convention.i64_trunc_uf64,
            ]:
                if math.isnan(a):
                    raise Exception('pywasm: invalid conversion to integer')
            if opcode == convention.i32_wrap_i64:
                stack.add(Value.from_i32(num.int2i32(a)))
                continue
            if opcode == convention.i32_trunc_sf32:
                if a &gt; 2**31 - 1 or a &lt; -2**32:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i32(int(a)))
                continue
            if opcode == convention.i32_trunc_uf32:
                if a &gt; 2**32 - 1 or a &lt; -1:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i32(int(a)))
                continue
            if opcode == convention.i32_trunc_sf64:
                if a &gt; 2**31 - 1 or a &lt; -2**32:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i32(int(a)))
                continue
            if opcode == convention.i32_trunc_uf64:
                if a &gt; 2**32 - 1 or a &lt; -1:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i32(int(a)))
                continue
            if opcode == convention.i64_extend_si32:
                stack.add(Value.from_i64(a))
                continue
            if opcode == convention.i64_extend_ui32:
                stack.add(Value.from_i64(num.int2u32(a)))
                continue
            if opcode == convention.i64_trunc_sf32:
                if a &gt; 2**63 - 1 or a &lt; -2**63:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i64(int(a)))
                continue
            if opcode == convention.i64_trunc_uf32:
                if a &gt; 2**63 - 1 or a &lt; -1:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i64(int(a)))
                continue
            if opcode == convention.i64_trunc_sf64:
                stack.add(Value.from_i64(int(a)))
                continue
            if opcode == convention.i64_trunc_uf64:
                if a &lt; -1:
                    raise Exception('pywasm: integer overflow')
                stack.add(Value.from_i64(int(a)))
                continue
            if opcode == convention.f32_convert_si32:
                stack.add(Value.from_f32(a))
                continue
            if opcode == convention.f32_convert_ui32:
                stack.add(Value.from_f32(num.int2u32(a)))
                continue
            if opcode == convention.f32_convert_si64:
                stack.add(Value.from_f32(a))
                continue
            if opcode == convention.f32_convert_ui64:
                stack.add(Value.from_f32(num.int2u64(a)))
                continue
            if opcode == convention.f32_demote_f64:
                stack.add(Value.from_f32(a))
                continue
            if opcode == convention.f64_convert_si32:
                stack.add(Value.from_f64(a))
                continue
            if opcode == convention.f64_convert_ui32:
                stack.add(Value.from_f64(num.int2u32(a)))
                continue
            if opcode == convention.f64_convert_si64:
                stack.add(Value.from_f64(a))
                continue
            if opcode == convention.f64_convert_ui64:
                stack.add(Value.from_f64(num.int2u64(a)))
                continue
            if opcode == convention.f64_promote_f32:
                stack.add(Value.from_f64(a))
                continue
            continue
        if opcode &gt;= convention.i32_reinterpret_f32 and opcode &lt;= convention.f64_reinterpret_i64:
            a = stack.pop().n
            if opcode == convention.i32_reinterpret_f32:
                stack.add(Value.from_i32(num.f322i32(a)))
                continue
            if opcode == convention.i64_reinterpret_f64:
                stack.add(Value.from_i64(num.f642i64(a)))
                continue
            if opcode == convention.f32_reinterpret_i32:
                stack.add(Value.from_f32(num.i322f32(a)))
                continue
            if opcode == convention.f64_reinterpret_i64:
                stack.add(Value.from_f64(num.i642f64(a)))
                continue
            continue

    return stack.data[-frame.arity:]
</t>
<t tx="ekr.20190302133319.68">@path C:/leo.repo/pywasm/pywasm/
import datetime
import sys

lvl = 0

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.69">def debugln(*args):
    if lvl:
        println(*args)


</t>
<t tx="ekr.20190302133319.7">def exec(self, name: str, args: typing.List):
    func_addr = self.func_addr(name)
    func = self.store.funcs[self.module_instance.funcaddrs[func_addr]]
    for i, e in enumerate(func.functype.args):
        if e in [convention.i32, convention.i64]:
            assert isinstance(args[i], int)
        if e in [convention.f32, convention.f64]:
            assert isinstance(args[i], float)
        args[i] = execution.Value(e, args[i])
    stack = execution.Stack()
    stack.ext(args)
    frame = execution.Frame(self.module_instance, args, len(func.functype.rets), -1)
    log.debugln(f'Running function {name}({", ".join([str(e) for e in args])}):')
    r = execution.call(self.module_instance, func_addr, self.store, stack)
    if r:
        return r[0].n
    return None


\\-4.# Using the pywasm API.
\\-4.# If you have already compiled a module from another language using tools like Emscripten, or loaded and run the code
\\-4.# by Javascript yourself, the pywasm API is easy to learn.

</t>
<t tx="ekr.20190302133319.70">def println(*args):
    pre = datetime.datetime.now().strftime('%Y/%m/%d %H:%M:%S')
    print(pre, *args)


</t>
<t tx="ekr.20190302133319.71">def panicln(*args):
    println(*args)
    raise Exception(' '.join(str(e) for e in args))


</t>
<t tx="ekr.20190302133319.72">def fatalln(*args):
    println(*args)
    println('exit status 1')
    sys.exit(1)
</t>
<t tx="ekr.20190302133319.73">@path C:/leo.repo/pywasm/pywasm/
import io
import math
import struct

u8 = i8 = u16 = i16 = u32 = i32 = u64 = i64 = int
f32 = f64 = float

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190302133319.74">def int2u8(i: int) -&gt; u8:
    return i &amp; 0xff


</t>
<t tx="ekr.20190302133319.75">def int2i8(i: int) -&gt; i8:
    i = i &amp; 0xff
    if i &amp; 0x80:
        return i - 0x100
    return i


</t>
<t tx="ekr.20190302133319.76">def int2u16(i: int) -&gt; u16:
    return i &amp; 0xffff


</t>
<t tx="ekr.20190302133319.77">def int2i16(i: int) -&gt; i16:
    i = i &amp; 0xffff
    if i &amp; 0x8000:
        return i - 0x10000
    return i


</t>
<t tx="ekr.20190302133319.78">def int2u32(i: int) -&gt; u32:
    return i &amp; 0xffffffff


</t>
<t tx="ekr.20190302133319.79">def int2i32(i: int) -&gt; i32:
    i = i &amp; 0xffffffff
    if i &amp; 0x80000000:
        return i - 0x100000000
    return i


</t>
<t tx="ekr.20190302133319.8">def on_debug():
    log.lvl = 1


</t>
<t tx="ekr.20190302133319.80">def int2u64(i: int) -&gt; u64:
    return i &amp; 0xffffffffffffffff


</t>
<t tx="ekr.20190302133319.81">def int2i64(i: int) -&gt; i64:
    i = i &amp; 0xffffffffffffffff
    if i &amp; 0x8000000000000000:
        return i - 0x10000000000000000
    return i


</t>
<t tx="ekr.20190302133319.82">def i322f32(i: i32) -&gt; f32:
    i = int2i32(i)
    return struct.unpack('&lt;f', struct.pack('&lt;i', i))[0]


</t>
<t tx="ekr.20190302133319.83">def f322i32(f: f32) -&gt; i32:
    return struct.unpack('&lt;i', struct.pack('&lt;f', f))[0]


</t>
<t tx="ekr.20190302133319.84">def i642f64(i: i64) -&gt; f64:
    i = int2i64(i)
    return struct.unpack('&lt;d', struct.pack('&lt;q', i))[0]


</t>
<t tx="ekr.20190302133319.85">def f642i64(f: f64) -&gt; i64:
    return struct.unpack('&lt;q', struct.pack('&lt;d', f))[0]


</t>
<t tx="ekr.20190302133319.86">class LittleEndian:
    @others
</t>
<t tx="ekr.20190302133319.87">@staticmethod
def u8(r: bytes):
    return struct.unpack('&lt;B', r)[0]

</t>
<t tx="ekr.20190302133319.88">@staticmethod
def i8(r: bytes):
    return struct.unpack('&lt;b', r)[0]

</t>
<t tx="ekr.20190302133319.89">@staticmethod
def u16(r: bytes):
    return struct.unpack('&lt;H', r)[0]

</t>
<t tx="ekr.20190302133319.9">def load(name: str, imps: typing.Dict = None):
    imps = imps if imps else {}
    with open(name, 'rb') as f:
        module = structure.Module.from_reader(f)
        return VirtualMachine(module, imps)


Memory = execution.MemoryInstance
Value = execution.Value
Table = execution.TableInstance
Limits = structure.Limits
</t>
<t tx="ekr.20190302133319.90">@staticmethod
def i16(r: bytes):
    return struct.unpack('&lt;h', r)[0]

</t>
<t tx="ekr.20190302133319.91">@staticmethod
def u32(r: bytes):
    return struct.unpack('&lt;I', r)[0]

</t>
<t tx="ekr.20190302133319.92">@staticmethod
def i32(r: bytes):
    return struct.unpack('&lt;i', r)[0]

</t>
<t tx="ekr.20190302133319.93">@staticmethod
def u64(r: bytes):
    return struct.unpack('&lt;Q', r)[0]

</t>
<t tx="ekr.20190302133319.94">@staticmethod
def i64(r: bytes):
    return struct.unpack('&lt;q', r)[0]

</t>
<t tx="ekr.20190302133319.95">@staticmethod
def f32(r: bytes):
    return struct.unpack('&lt;f', r)[0]

</t>
<t tx="ekr.20190302133319.96">@staticmethod
def f64(r: bytes):
    return struct.unpack('&lt;d', r)[0]

</t>
<t tx="ekr.20190302133319.97">@staticmethod
def pack_u8(n: u8):
    return struct.pack('&lt;B', n)

</t>
<t tx="ekr.20190302133319.98">@staticmethod
def pack_i8(n: i8):
    return struct.pack('&lt;b', n)

</t>
<t tx="ekr.20190302133319.99">@staticmethod
def pack_u16(n: u16):
    return struct.pack('&lt;H', n)

</t>
</tnodes>
</leo_file>
