<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.312572087659">
	<global_window_position top="25" left="260" height="867" width="800"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070930045014"><vh>startup</vh>
<v t="ekr.20070930041838"><vh>@chapters</vh></v>
</v>
<v t="ekr.20070127142814.1633"><vh>raw material</vh>
<v t="ekr.20070127142814.1634"><vh>autocompleter.py</vh>
<v t="ekr.20070127142814.1635"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1636"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1637"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1638"><vh>&lt;&lt;load notes&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1639"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1640"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1641"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20070127142814.1642"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1643"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1644"><vh>watcher</vh></v>
<v t="ekr.20070127142814.1645"><vh>scanText</vh></v>
<v t="ekr.20070127142814.1646"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20070127142814.1647"><vh>scanForCallTip</vh></v>
<v t="ekr.20070127142814.1648"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20070127142814.1649"><vh>_getCleanString</vh></v>
<v t="ekr.20070127142814.1650"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20070127142814.1651"><vh>initialScan</vh></v>
<v t="ekr.20070127142814.1652"><vh>has read config file meths</vh></v>
<v t="ekr.20070127142814.1653"><vh>readConfigFile</vh></v>
<v t="ekr.20070127142814.1654"><vh>createConfigFile</vh></v>
<v t="ekr.20070127142814.1655"><vh>readLanguageFiles</vh></v>
<v t="ekr.20070127142814.1656"><vh>readOutline</vh></v>
<v t="ekr.20070127142814.1657"><vh>reducer</vh></v>
<v t="ekr.20070127142814.1658"><vh>unbind</vh></v>
<v t="ekr.20070127142814.1659"><vh>moveSelItem</vh></v>
<v t="ekr.20070127142814.1660"><vh>processKeyStroke</vh></v>
<v t="ekr.20070127142814.1661"><vh>testForUnbind</vh></v>
<v t="ekr.20070127142814.1662"><vh>processAutoBox</vh></v>
<v t="ekr.20070127142814.1663"><vh>add_item</vh></v>
<v t="ekr.20070127142814.1664"><vh>add_bindings</vh></v>
<v t="ekr.20070127142814.1665"><vh>configureAutoBox</vh></v>
<v t="ekr.20070127142814.1666"><vh>calculatePlace</vh></v>
<v t="ekr.20070127142814.1667"><vh>setLanguage</vh></v>
<v t="ekr.20070127142814.1668"><vh>newCreateControl</vh></v>
<v t="ekr.20070127142814.1669"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20070127142814.1670"><vh>onOpenWindow</vh></v>
</v>
<v t="ekr.20070127142814.1671"><vh>nodebar.py</vh>
<v t="ekr.20070127142814.1672"><vh>&lt;&lt;images&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1673"><vh>&lt;&lt;images2&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1674"><vh>&lt;&lt;version&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1675"><vh>&lt;&lt;How To Configure&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1676"><vh>determineFrame</vh></v>
<v t="ekr.20070127142814.1677"><vh>addNodeBar</vh>
<v t="ekr.20070127142814.1678"><vh>&lt;&lt; Create the help button &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1679"><vh>add</vh></v>
<v t="ekr.20070127142814.1680"><vh>addBalloon</vh></v>
<v t="ekr.20070127142814.1681"><vh>view_help</vh></v>
<v t="ekr.20070127142814.1682"><vh>configureNodebar</vh></v>
<v t="ekr.20070127142814.1683"><vh>readConfigFile</vh></v>
<v t="ekr.20070127142814.1684"><vh>if load_ok:</vh></v>
</v>
<v t="ekr.20070127142814.1685"><vh>leoNodes2.py</vh>
<v t="ekr.20070127142814.1686"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1687"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1688"><vh>class tnode</vh>
<v t="ekr.20070127142814.1689"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1690"><vh>t.__init__</vh></v>
<v t="ekr.20070127142814.1691"><vh>t.__repr__ &amp; t.__str__</vh></v>
<v t="ekr.20070127142814.1692"><vh>For undo</vh>
<v t="ekr.20070127142814.1693"><vh>t.createUndoInfo</vh></v>
<v t="ekr.20070127142814.1694"><vh>t.restoreUndoInfo</vh></v>
</v>
<v t="ekr.20070127142814.1695"><vh>Getters</vh>
<v t="ekr.20070127142814.1696"><vh>getBody</vh></v>
<v t="ekr.20070127142814.1697"><vh>hasBody</vh></v>
<v t="ekr.20070127142814.1698"><vh>Status bits</vh>
<v t="ekr.20070127142814.1699"><vh>isDirty</vh></v>
<v t="ekr.20070127142814.1700"><vh>isRichTextBit</vh></v>
<v t="ekr.20070127142814.1701"><vh>isVisited</vh></v>
<v t="ekr.20070127142814.1702"><vh>isWriteBit</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1703"><vh>Setters</vh>
<v t="ekr.20070127142814.1704"><vh>Setting body text</vh>
<v t="ekr.20070127142814.1705"><vh>setTnodeText</vh></v>
<v t="ekr.20070127142814.1706"><vh>setSelection</vh></v>
</v>
<v t="ekr.20070127142814.1707"><vh>Status bits</vh>
<v t="ekr.20070127142814.1708"><vh>clearDirty</vh></v>
<v t="ekr.20070127142814.1709"><vh>clearRichTextBit</vh></v>
<v t="ekr.20070127142814.1710"><vh>clearVisited</vh></v>
<v t="ekr.20070127142814.1711"><vh>clearWriteBit</vh></v>
<v t="ekr.20070127142814.1712"><vh>setDirty</vh></v>
<v t="ekr.20070127142814.1713"><vh>setRichTextBit</vh></v>
<v t="ekr.20070127142814.1714"><vh>setVisited</vh></v>
<v t="ekr.20070127142814.1715"><vh>setWriteBit</vh></v>
</v>
<v t="ekr.20070127142814.1716"><vh>setCloneIndex (used in 3.x)</vh></v>
<v t="ekr.20070127142814.1717"><vh>setFileIndex</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1718"><vh>class vnode</vh>
<v t="ekr.20070127142814.1719"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1720"><vh>Birth &amp; death</vh>
<v t="ekr.20070127142814.1721"><vh>v.__cmp__ (not used)</vh></v>
<v t="ekr.20070127142814.1722"><vh>v.__init__</vh>
<v t="ekr.20070127142814.1723"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1724"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="ekr.20070127142814.1725"><vh>v.dump</vh></v>
</v>
<v t="ekr.20070127142814.1726"><vh>v.Comparisons</vh>
<v t="ekr.20070127142814.1727"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20070127142814.1728"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20070127142814.1729"><vh>at...FileNodeName</vh></v>
<v t="ekr.20070127142814.1730"><vh>isAtAllNode</vh></v>
<v t="ekr.20070127142814.1731"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20070127142814.1732"><vh>isAt...FileNode</vh></v>
<v t="ekr.20070127142814.1733"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20070127142814.1734"><vh>isAtOthersNode</vh></v>
<v t="ekr.20070127142814.1735"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20070127142814.1736"><vh>Getters (vnode)</vh>
<v t="ekr.20070127142814.1737"><vh>Tree Traversal getters</vh>
<v t="ekr.20070127142814.1738"><vh>v.back</vh></v>
<v t="ekr.20070127142814.1739"><vh>v.next</vh></v>
</v>
<v t="ekr.20070127142814.1740"><vh>Children</vh>
<v t="ekr.20070127142814.1741"><vh>v.childIndex</vh></v>
<v t="ekr.20070127142814.1742"><vh>v.firstChild (changed for 4.2)</vh></v>
<v t="ekr.20070127142814.1743"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="ekr.20070127142814.1744"><vh>v.lastChild</vh></v>
<v t="ekr.20070127142814.1745"><vh>v.nthChild</vh></v>
<v t="ekr.20070127142814.1746"><vh>v.numberOfChildren (n)</vh></v>
</v>
<v t="ekr.20070127142814.1747"><vh>Status Bits</vh>
<v t="ekr.20070127142814.1748"><vh>v.isCloned (4.2)</vh></v>
<v t="ekr.20070127142814.1749"><vh>isDirty</vh></v>
<v t="ekr.20070127142814.1750"><vh>isExpanded</vh></v>
<v t="ekr.20070127142814.1751"><vh>isMarked</vh></v>
<v t="ekr.20070127142814.1752"><vh>isOrphan</vh></v>
<v t="ekr.20070127142814.1753"><vh>isSelected</vh></v>
<v t="ekr.20070127142814.1754"><vh>isTopBitSet</vh></v>
<v t="ekr.20070127142814.1755"><vh>isVisited</vh></v>
<v t="ekr.20070127142814.1756"><vh>status</vh></v>
</v>
<v t="ekr.20070127142814.1757"><vh>v.bodyString</vh></v>
<v t="ekr.20070127142814.1758"><vh>v.currentVnode (and c.currentPosition 4.2)</vh></v>
<v t="ekr.20070127142814.1759"><vh>v.findRoot (4.2)</vh></v>
<v t="ekr.20070127142814.1760"><vh>v.headString &amp; v.cleanHeadString</vh></v>
<v t="ekr.20070127142814.1761"><vh>v.directParents (new method in 4.2)</vh></v>
</v>
<v t="ekr.20070127142814.1762"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20070127142814.1763"><vh>v.insertAfter</vh></v>
<v t="ekr.20070127142814.1764"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20070127142814.1765"><vh>v.linkAfter</vh></v>
<v t="ekr.20070127142814.1766"><vh>v.linkAsNthChild</vh></v>
<v t="ekr.20070127142814.1767"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20070127142814.1768"><vh>v.moveToRoot</vh></v>
<v t="ekr.20070127142814.1769"><vh>v.unlink</vh></v>
</v>
<v t="ekr.20070127142814.1770"><vh>Setters</vh>
<v t="ekr.20070127142814.1771"><vh> v.Status bits</vh>
<v t="ekr.20070127142814.1772"><vh>clearClonedBit</vh></v>
<v t="ekr.20070127142814.1773"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="ekr.20070127142814.1774"><vh>clearMarked</vh></v>
<v t="ekr.20070127142814.1775"><vh>clearOrphan</vh></v>
<v t="ekr.20070127142814.1776"><vh>clearVisited</vh></v>
<v t="ekr.20070127142814.1777"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20070127142814.1778"><vh>initStatus</vh></v>
<v t="ekr.20070127142814.1779"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="ekr.20070127142814.1780"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20070127142814.1781"><vh>setOrphan</vh></v>
<v t="ekr.20070127142814.1782"><vh>setSelected (vnode)</vh></v>
<v t="ekr.20070127142814.1783"><vh>t.setVisited</vh></v>
</v>
<v t="ekr.20070127142814.1784"><vh>v.computeIcon &amp; setIcon</vh></v>
<v t="ekr.20070127142814.1785"><vh>v.initHeadString</vh></v>
<v t="ekr.20070127142814.1786"><vh>v.setSelection</vh></v>
<v t="ekr.20070127142814.1787"><vh>v.setTnodeText</vh></v>
<v t="ekr.20070127142814.1788"><vh>v.trimTrailingLines</vh></v>
</v>
<v t="ekr.20070127142814.1789"><vh>For undo</vh>
<v t="ekr.20070127142814.1790"><vh>v.createUndoInfo</vh></v>
<v t="ekr.20070127142814.1791"><vh>v.restoreUndoInfo</vh></v>
</v>
<v t="ekr.20070127142814.1792"><vh>v.Iterators</vh>
<v t="ekr.20070127142814.1793"><vh>self_subtree_iter</vh></v>
<v t="ekr.20070127142814.1794"><vh>unique_subtree_iter</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1795"><vh>class nodeIndices</vh>
<v t="ekr.20070127142814.1796"><vh>nodeIndices.__init__</vh></v>
<v t="ekr.20070127142814.1797"><vh>areEqual</vh></v>
<v t="ekr.20070127142814.1798"><vh>get/setDefaultId</vh></v>
<v t="ekr.20070127142814.1799"><vh>getNewIndex</vh></v>
<v t="ekr.20070127142814.1800"><vh>isGnx</vh></v>
<v t="ekr.20070127142814.1801"><vh>scanGnx</vh></v>
<v t="ekr.20070127142814.1802"><vh>setTimeStamp</vh></v>
<v t="ekr.20070127142814.1803"><vh>toString</vh></v>
</v>
<v t="ekr.20070127142814.1804"><vh>class position</vh>
<v t="ekr.20070127142814.1805"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1806"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20070127142814.1807"><vh>p.__cmp__</vh></v>
<v t="ekr.20070127142814.1808"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20070127142814.1809"><vh>p.__init__</vh></v>
<v t="ekr.20070127142814.1810"><vh>p.__nonzero__</vh></v>
<v t="ekr.20070127142814.1811"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20070127142814.1812"><vh>p.copy</vh></v>
<v t="ekr.20070127142814.1813"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20070127142814.1814"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20070127142814.1815"><vh>TreeNode</vh>
<v t="ekr.20070127142814.1816"><vh>children</vh></v>
<v t="ekr.20070127142814.1817"><vh>getAllowsChildren</vh></v>
<v t="ekr.20070127142814.1818"><vh>getChildAt</vh></v>
<v t="ekr.20070127142814.1819"><vh>getChildCount</vh></v>
<v t="ekr.20070127142814.1820"><vh>getIndex</vh></v>
<v t="ekr.20070127142814.1821"><vh>getParent</vh></v>
<v t="ekr.20070127142814.1822"><vh>isLeaf</vh></v>
</v>
<v t="ekr.20070127142814.1823"><vh>Getters</vh>
<v t="ekr.20070127142814.1824"><vh> vnode proxies</vh>
<v t="ekr.20070127142814.1825"><vh>p.Comparisons</vh></v>
<v t="ekr.20070127142814.1826"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20070127142814.1827"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20070127142814.1828"><vh>p.Status bits</vh></v>
<v t="ekr.20070127142814.1829"><vh>p.edit_text</vh></v>
<v t="ekr.20070127142814.1830"><vh>p.directParents</vh></v>
<v t="ekr.20070127142814.1831"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20070127142814.1832"><vh>children</vh>
<v t="ekr.20070127142814.1833"><vh>p.hasChildren</vh></v>
<v t="ekr.20070127142814.1834"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20070127142814.1835"><vh>p.exists</vh></v>
<v t="ekr.20070127142814.1836"><vh>p.findRoot</vh></v>
<v t="ekr.20070127142814.1837"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20070127142814.1838"><vh>p.hasX</vh>
<v t="ekr.20070127142814.1839"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20070127142814.1840"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20070127142814.1841"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20070127142814.1842"><vh>isCurrentPosition</vh></v>
<v t="ekr.20070127142814.1843"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20070127142814.1844"><vh>p.isCloned</vh></v>
<v t="ekr.20070127142814.1845"><vh>p.isRoot</vh></v>
<v t="ekr.20070127142814.1846"><vh>p.isVisible</vh></v>
<v t="ekr.20070127142814.1847"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20070127142814.1848"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20070127142814.1849"><vh>Setters</vh>
<v t="ekr.20070127142814.1850"><vh>vnode proxies</vh>
<v t="ekr.20070127142814.1851"><vh> Status bits</vh></v>
<v t="ekr.20070127142814.1852"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20070127142814.1853"><vh>p.setSelection</vh></v>
<v t="ekr.20070127142814.1854"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20070127142814.1855"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20070127142814.1856"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20070127142814.1857"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20070127142814.1858"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20070127142814.1859"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20070127142814.1860"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20070127142814.1861"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20070127142814.1862"><vh>Visited bits</vh>
<v t="ekr.20070127142814.1863"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20070127142814.1864"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20070127142814.1865"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20070127142814.1866"><vh>p.Dirty bits</vh>
<v t="ekr.20070127142814.1867"><vh>p.clearDirty</vh></v>
<v t="ekr.20070127142814.1868"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20070127142814.1869"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20070127142814.1870"><vh>p.setDirty</vh></v>
<v t="ekr.20070127142814.1871"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1872"><vh>File Conversion</vh>
<v t="ekr.20070127142814.1873"><vh>convertTreeToString</vh></v>
<v t="ekr.20070127142814.1874"><vh>moreHead</vh></v>
<v t="ekr.20070127142814.1875"><vh>moreBody</vh></v>
</v>
<v t="ekr.20070127142814.1876"><vh>p.Iterators</vh>
<v t="ekr.20070127142814.1877"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="ekr.20070127142814.1878"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20070127142814.1879"><vh>p.allNodes_iter</vh>
<v t="ekr.20070127142814.1880"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20070127142814.1881"><vh>next</vh></v>
</v>
<v t="ekr.20070127142814.1882"><vh>p.subtree_iter</vh>
<v t="ekr.20070127142814.1883"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20070127142814.1884"><vh>next</vh></v>
</v>
<v t="ekr.20070127142814.1885"><vh>p.children_iter</vh>
<v t="ekr.20070127142814.1886"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20070127142814.1887"><vh>next</vh></v>
</v>
<v t="ekr.20070127142814.1888"><vh>p.parents_iter</vh>
<v t="ekr.20070127142814.1889"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20070127142814.1890"><vh>next</vh></v>
</v>
<v t="ekr.20070127142814.1891"><vh>p.siblings_iter</vh>
<v t="ekr.20070127142814.1892"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20070127142814.1893"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1894"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20070127142814.1895"><vh>p.doDelete</vh></v>
<v t="ekr.20070127142814.1896"><vh>p.insertAfter</vh></v>
<v t="ekr.20070127142814.1897"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20070127142814.1898"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20070127142814.1899"><vh>p.moveToRoot</vh></v>
<v t="ekr.20070127142814.1900"><vh>p.clone</vh></v>
<v t="ekr.20070127142814.1901"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20070127142814.1902"><vh>p.moveAfter</vh></v>
<v t="ekr.20070127142814.1903"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20070127142814.1904"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20070127142814.1905"><vh>p.sortChildren</vh></v>
<v t="ekr.20070127142814.1906"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20070127142814.1907"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1908"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1909"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1910"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20070127142814.1911"><vh>p.moveToX</vh>
<v t="ekr.20070127142814.1912"><vh>p.moveToBack</vh></v>
<v t="ekr.20070127142814.1913"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20070127142814.1914"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20070127142814.1915"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20070127142814.1916"><vh>p.moveToNext</vh></v>
<v t="ekr.20070127142814.1917"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20070127142814.1918"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20070127142814.1919"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20070127142814.1920"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20070127142814.1921"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20070127142814.1922"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070127142814.1923"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20070127142814.1924"><vh>p.utils...</vh>
<v t="ekr.20070127142814.1925"><vh>p.vParentWithStack</vh>
<v t="ekr.20070127142814.1926"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1927"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20070127142814.1928"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20070127142814.1929"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20070127142814.1930"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1931"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20070127142814.1932"><vh>p.linkAfter</vh></v>
<v t="ekr.20070127142814.1933"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20070127142814.1934"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20070127142814.1935"><vh>p.unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142814.1936"><vh>leo2.py </vh>
<v t="ekr.20070127142814.1937"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1938"><vh>run &amp; allies</vh>
<v t="ekr.20070127142814.1939"><vh>&lt;&lt; print encoding info &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1940"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1941"><vh>isValidPython</vh></v>
<v t="ekr.20070127142814.1942"><vh>computeLoadDir</vh></v>
<v t="ekr.20070127142814.1943"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070127142814.1944"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20070127142814.1945"><vh>getBatchScript</vh></v>
</v>
<v t="ekr.20070127142814.1946"><vh>profile</vh></v>
</v>
<v t="ekr.20070127142814.1947"><vh>fastGotoNode.py</vh>
<v t="ekr.20070127142814.1948"><vh>&lt;&lt; fastGotoNode declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1949"><vh>disappear</vh></v>
<v t="ekr.20070127142814.1950"><vh>pop</vh></v>
<v t="ekr.20070127142814.1951"><vh>getSectionReferenceMenu</vh></v>
<v t="ekr.20070127142814.1952"><vh>getWindowMenu</vh></v>
<v t="ekr.20070127142814.1953"><vh>getChildrenMenu</vh></v>
<v t="ekr.20070127142814.1954"><vh>getSiblingsMenu</vh></v>
<v t="ekr.20070127142814.1955"><vh>getSiblingList</vh></v>
<v t="ekr.20070127142814.1956"><vh>getAncestorsMenu</vh></v>
<v t="ekr.20070127142814.1957"><vh>getAncestorList</vh></v>
<v t="ekr.20070127142814.1958"><vh>addLanguageMenu</vh></v>
<v t="ekr.20070127142814.1959"><vh>getMoveAMenu</vh></v>
<v t="ekr.20070127142814.1960"><vh>getMoveSMenu</vh></v>
<v t="ekr.20070127142814.1961"><vh>needsSeparator</vh></v>
<v t="ekr.20070127142814.1962"><vh>shouldBreak</vh></v>
<v t="ekr.20070127142814.1963"><vh>getDirectiveInsert</vh></v>
<v t="ekr.20070127142814.1964"><vh>getHeadlineMenu</vh></v>
<v t="ekr.20070127142814.1965"><vh>setFileDirective</vh></v>
<v t="ekr.20070127142814.1966"><vh>removeFileDirective</vh></v>
<v t="ekr.20070127142814.1967"><vh>getCleanHeadString</vh></v>
<v t="ekr.20070127142814.1968"><vh>addGL</vh></v>
<v t="ekr.20070127142814.1969"><vh>insertHeadline</vh></v>
<v t="ekr.20070127142814.1970"><vh>paster</vh></v>
<v t="ekr.20070127142814.1971"><vh>clear</vh></v>
<v t="ekr.20070127142814.1972"><vh>jumpto</vh></v>
<v t="ekr.20070127142814.1973"><vh>registerPopupMenu</vh></v>
<v t="ekr.20070127142814.1974"><vh>calculateMenuSize</vh></v>
<v t="ekr.20070127142814.1975"><vh>loadLanguages</vh></v>
</v>
<v t="ekr.20070127142814.1976"><vh>testport.py</vh></v>
<v t="ekr.20070127142814.1977"><vh>chapters.py</vh>
<v t="ekr.20070127142814.1978"><vh>&lt;&lt; chapters declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1979"><vh>class Chapter</vh>
<v t="ekr.20070127142814.1980"><vh>&lt;&lt; class Chapter declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1981"><vh>__init__</vh></v>
<v t="ekr.20070127142814.1982"><vh>_saveInfo</vh></v>
<v t="ekr.20070127142814.1983"><vh>setVariables</vh></v>
<v t="ekr.20070127142814.1984"><vh>makeCurrent</vh></v>
</v>
<v t="ekr.20070127142814.1985"><vh>newCreateControl</vh></v>
<v t="ekr.20070127142814.1986"><vh>createPanedWidget</vh></v>
<v t="ekr.20070127142814.1987"><vh>newEditorPane</vh></v>
<v t="ekr.20070127142814.1988"><vh>newCreateCanvas</vh></v>
<v t="ekr.20070127142814.1989"><vh>createBalloon</vh></v>
<v t="ekr.20070127142814.1990"><vh>createNoteBook</vh></v>
<v t="ekr.20070127142814.1991"><vh>getNameMaker</vh></v>
<v t="ekr.20070127142814.1992"><vh>newTreeinit</vh></v>
<v t="ekr.20070127142814.1993"><vh>constructTree</vh></v>
<v t="ekr.20070127142814.1994"><vh>addPage</vh></v>
<v t="ekr.20070127142814.1995"><vh>newEditor</vh></v>
<v t="ekr.20070127142814.1996"><vh>makeTabMenu</vh></v>
<v t="ekr.20070127142814.1997"><vh>getAddChapter</vh></v>
<v t="ekr.20070127142814.1998"><vh>getRemove</vh></v>
<v t="ekr.20070127142814.1999"><vh>getRename</vh></v>
<v t="ekr.20070127142814.2000"><vh>getMakeTrash</vh></v>
<v t="ekr.20070127142814.2001"><vh>getSetupMenu</vh></v>
<v t="ekr.20070127142814.2002"><vh>selectNodeForEditor</vh></v>
<v t="ekr.20070127142814.2003"><vh>activateEditor</vh></v>
<v t="ekr.20070127142814.2004"><vh>removeEditor</vh></v>
<v t="ekr.20070127142814.2005"><vh>addHeading</vh></v>
<v t="ekr.20070127142814.2006"><vh>viewIndex</vh></v>
<v t="ekr.20070127142814.2007"><vh>buildIndex</vh></v>
<v t="ekr.20070127142814.2008"><vh>regexViewIndex</vh></v>
<v t="ekr.20070127142814.2009"><vh>renumber</vh></v>
<v t="ekr.20070127142814.2010"><vh>getGoodPage</vh></v>
<v t="ekr.20070127142814.2011"><vh>checkChapterValidity</vh></v>
<v t="ekr.20070127142814.2012"><vh>getSV</vh></v>
<v t="ekr.20070127142814.2013"><vh>setTree</vh></v>
<v t="ekr.20070127142814.2014"><vh>lowerPage</vh></v>
<v t="ekr.20070127142814.2015"><vh>walkChapters</vh></v>
<v t="ekr.20070127142814.2016"><vh>newGetLeoFile</vh></v>
<v t="ekr.20070127142814.2017"><vh>newOpen</vh></v>
<v t="ekr.20070127142814.2018"><vh>openChaptersFile</vh></v>
<v t="ekr.20070127142814.2019"><vh>insertChapters</vh></v>
<v t="ekr.20070127142814.2020"><vh>newWrite_LEO_file</vh></v>
<v t="ekr.20070127142814.2021"><vh>getMakeStringIO</vh></v>
<v t="ekr.20070127142814.2022"><vh>writeChapters</vh></v>
<v t="ekr.20070127142814.2023"><vh>zipChapters</vh></v>
<v t="ekr.20070127142814.2024"><vh>newos_path_dirname</vh></v>
<v t="ekr.20070127142814.2025"><vh>newendEditLabel</vh></v>
<v t="ekr.20070127142814.2026"><vh>newselect</vh></v>
<v t="ekr.20070127142814.2027"><vh>newTrashDelete</vh></v>
<v t="ekr.20070127142814.2028"><vh>cloneToChapter</vh></v>
<v t="ekr.20070127142814.2029"><vh>moveToChapter</vh></v>
<v t="ekr.20070127142814.2030"><vh>copyToChapter</vh></v>
<v t="ekr.20070127142814.2031"><vh>makeNodeIntoChapter</vh></v>
<v t="ekr.20070127142814.2032"><vh>conversionToSimple</vh></v>
<v t="ekr.20070127142814.2033"><vh>conversionToChapters</vh></v>
<v t="ekr.20070127142814.2034"><vh>importLeoFile</vh></v>
<v t="ekr.20070127142814.2035"><vh>exportLeoFile</vh></v>
<v t="ekr.20070127142814.2036"><vh>swapChapters</vh></v>
<v t="ekr.20070127142814.2037"><vh>emptyTrash</vh></v>
<v t="ekr.20070127142814.2038"><vh>regexClone</vh></v>
<v t="ekr.20070127142814.2039"><vh>doPDFConversion</vh></v>
<v t="ekr.20070127142814.2040"><vh>_changeTreeToPDF</vh></v>
</v>
</v>
<v t="ekr.20070127142814.14"><vh>org.leo (jython shell)</vh>
<v t="ekr.20070127142814.15"><vh>@@thin ImageJPanel.java</vh></v>
<v t="ekr.20070127142814.16"><vh>@@thin JTextComponentOutputStream.java</vh></v>
<v t="ekr.20070127142814.17"><vh>shell</vh>
<v t="ekr.20070127142814.18" tnodeList="ekr.20070127142814.18"><vh>@file-nosent build.xml</vh></v>
<v t="ekr.20070127142814.19"><vh>@@thin ComboBoxTest.py</vh></v>
<v t="ekr.20070127142814.20"><vh>@@thin SplitMenuTest.py</vh></v>
<v t="ekr.20070127142814.21"><vh>@@thin JTableTst.py</vh>
<v t="ekr.20070127142814.22"><vh>&lt;&lt;double table model&gt;&gt;</vh></v>
<v t="ekr.20070127142814.23"><vh>&lt;&lt;table internals&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.24"><vh>@@thin IsolatedJythonClassLoader.java</vh></v>
<v t="ekr.20070127142814.25"><vh>@@thin DorkClassLoader.java</vh></v>
<v t="ekr.20070127142814.26"><vh>@@thin Autocompleter.java</vh>
<v t="ekr.20070127142814.27"><vh>&lt;&lt;key manipulation&gt;&gt;</vh></v>
<v t="ekr.20070127142814.28" a="M"><vh>showAutocompleter</vh></v>
<v t="ekr.20070127142814.29"><vh>autocomplete</vh></v>
<v t="ekr.20070127142814.30"><vh>hide</vh></v>
<v t="ekr.20070127142814.31"><vh>utilityBoxListener</vh></v>
</v>
<v t="ekr.20070127142814.32"><vh>@@thin Calltip.java</vh>
<v t="ekr.20070127142814.33"><vh>calltip</vh>
<v t="ekr.20070127142814.34"><vh>calltip_jconstructor</vh></v>
<v t="ekr.20070127142814.35"><vh>prettyPrintJavaMethod</vh></v>
<v t="ekr.20070127142814.36"><vh>calltip_java</vh></v>
<v t="ekr.20070127142814.37"><vh>calltip_python</vh></v>
</v>
<v t="ekr.20070127142814.38"><vh>hide</vh></v>
<v t="ekr.20070127142814.39"><vh>utilityBoxListener</vh></v>
</v>
<v t="ekr.20070127142814.40"><vh>@@thin Autoquoter.java</vh></v>
<v t="ekr.20070127142814.41"><vh>@@thin LineOutputSupresser.java</vh></v>
<v t="ekr.20070127142814.42"><vh>@@thin ObjectWildCard.java</vh></v>
<v t="ekr.20070127142814.43"><vh>@@thin SystemCommand.java</vh></v>
<v t="ekr.20070127142814.44"><vh>@@thin UnifiedHelp.java</vh></v>
<v t="ekr.20070127142814.45"><vh>@@thin JythonShell.java</vh>
<v t="ekr.20070127142814.46"><vh>JythonShell</vh></v>
<v t="ekr.20070127142814.47"><vh>exterior control/interaction</vh>
<v t="ekr.20070127142814.48"><vh>getWidget</vh></v>
<v t="ekr.20070127142814.49"><vh>widget opps</vh></v>
<v t="ekr.20070127142814.50"><vh>setVisible</vh></v>
<v t="ekr.20070127142814.51"><vh>getDelegate</vh></v>
<v t="ekr.20070127142814.52"><vh>addLineListener</vh></v>
<v t="ekr.20070127142814.53"><vh>addUtilityBoxListener</vh></v>
<v t="ekr.20070127142814.54"><vh>supressOutput</vh></v>
</v>
<v t="ekr.20070127142814.55"><vh>constructor helpers</vh>
<v t="ekr.20070127142814.56"><vh>addMenuBar</vh></v>
<v t="ekr.20070127142814.57"><vh>addKeyStrokes</vh></v>
<v t="ekr.20070127142814.58"><vh>addToInputActionMaps</vh></v>
<v t="ekr.20070127142814.59"><vh>isRegisteredKeyStroke</vh></v>
</v>
<v t="ekr.20070127142814.60"><vh>addAlias removeAlias</vh></v>
<v t="ekr.20070127142814.61"><vh>configuring methods</vh></v>
<v t="ekr.20070127142814.62"><vh>undoableEditHappened</vh></v>
<v t="ekr.20070127142814.63"><vh>execution related...</vh>
<v t="ekr.20070127142814.64"><vh>call</vh></v>
<v t="ekr.20070127142814.65"><vh>autocall</vh></v>
<v t="ekr.20070127142814.66"><vh>outputLineInfo</vh></v>
<v t="ekr.20070127142814.67"><vh>addLineToExecute</vh></v>
<v t="ekr.20070127142814.68"><vh>execute1 execute2</vh></v>
</v>
<v t="ekr.20070127142814.69"><vh>prompt related...</vh>
<v t="ekr.20070127142814.70"><vh>get_input</vh></v>
<v t="ekr.20070127142814.71"><vh>insertPrompt</vh></v>
<v t="ekr.20070127142814.72"><vh>setIndent</vh></v>
<v t="ekr.20070127142814.73"><vh>setIndent2</vh></v>
<v t="ekr.20070127142814.74"><vh>getPromptLength</vh></v>
</v>
<v t="ekr.20070127142814.75"><vh>hooks...</vh>
<v t="ekr.20070127142814.76"><vh>displayHook</vh></v>
<v t="ekr.20070127142814.77"><vh>exceptHook</vh></v>
<v t="ekr.20070127142814.78"><vh>getStackTrace</vh></v>
<v t="ekr.20070127142814.79"><vh>formatException</vh></v>
</v>
<v t="ekr.20070127142814.80"><vh>keyPressed</vh>
<v t="ekr.20070127142814.81"><vh>keyReleased</vh></v>
<v t="ekr.20070127142814.82"><vh>keyTyped</vh></v>
</v>
<v t="ekr.20070127142814.83"><vh>shell special powers...</vh>
<v t="ekr.20070127142814.84"><vh>getters</vh>
<v t="ekr.20070127142814.85"><vh>getPyObject</vh></v>
<v t="ekr.20070127142814.86"><vh>getObjectName</vh></v>
<v t="ekr.20070127142814.87"><vh>getBuiltin</vh></v>
</v>
<v t="ekr.20070127142814.88"><vh>checkForJythonReference</vh></v>
<v t="ekr.20070127142814.89"><vh>bookmarks</vh></v>
<v t="ekr.20070127142814.90"><vh>dhistory</vh></v>
<v t="ekr.20070127142814.91"><vh>directory stack</vh></v>
<v t="ekr.20070127142814.92"><vh>magic command methods..</vh>
<v t="ekr.20070127142814.93"><vh>magicCommand</vh></v>
<v t="ekr.20070127142814.94"><vh>isMagicCommand</vh></v>
<v t="ekr.20070127142814.95"><vh>createMagicCommands</vh></v>
<v t="ekr.20070127142814.96"><vh>registerMagicCommand</vh></v>
<v t="ekr.20070127142814.97"><vh>createMagicCommandFromJython</vh></v>
</v>
<v t="ekr.20070127142814.98"><vh>dynamic abbreviations</vh>
<v t="ekr.20070127142814.99"><vh>dynamicAbbreviation</vh></v>
<v t="ekr.20070127142814.100"><vh>findNextAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20070127142814.101"><vh>startOfLine endOfLine</vh></v>
<v t="ekr.20070127142814.102"><vh>colorize</vh></v>
<v t="ekr.20070127142814.103"><vh>closeUtilityBoxes</vh></v>
<v t="ekr.20070127142814.104"><vh>processScript</vh></v>
<v t="ekr.20070127142814.105"><vh>processHistoryString</vh></v>
<v t="ekr.20070127142814.106"><vh>getNextPrompt</vh></v>
<v t="ekr.20070127142814.107"><vh>setAutomagic getAutomagic</vh></v>
<v t="ekr.20070127142814.108"><vh>addLogger removeLogger</vh></v>
<v t="ekr.20070127142814.109"><vh>miscellaneous getter/setters</vh>
<v t="ekr.20070127142814.110"><vh>getShellComponent getCurrentWorkingDirectory,etc...</vh></v>
<v t="ekr.20070127142814.111"><vh>stdout stderr</vh></v>
<v t="ekr.20070127142814.112"><vh>get set OutputSpot</vh></v>
<v t="ekr.20070127142814.113"><vh>get set PdbOn</vh></v>
<v t="ekr.20070127142814.114"><vh>getWho</vh></v>
<v t="ekr.20070127142814.115"><vh>getAutocall setAutocall</vh></v>
<v t="ekr.20070127142814.116"><vh>getAutoindent setAutoindent</vh></v>
</v>
<v t="ekr.20070127142814.117"><vh>Documentations stuff..</vh>
<v t="ekr.20070127142814.118"><vh>getDocumentation</vh></v>
<v t="ekr.20070127142814.119"><vh>getKeystrokeDescriptions</vh></v>
<v t="ekr.20070127142814.120"><vh>getMagicDescriptions</vh></v>
<v t="ekr.20070127142814.121"><vh>getInteractiveDescriptions</vh></v>
<v t="ekr.20070127142814.122"><vh>getUnifiedHelp</vh></v>
</v>
<v t="ekr.20070127142814.123"><vh>menu actions</vh>
<v t="ekr.20070127142814.124"><vh>print</vh></v>
<v t="ekr.20070127142814.125"><vh>open</vh></v>
<v t="ekr.20070127142814.126"><vh>save</vh></v>
<v t="ekr.20070127142814.127"><vh>close</vh></v>
<v t="ekr.20070127142814.128"><vh>help</vh></v>
<v t="ekr.20070127142814.129"><vh>getCut</vh></v>
<v t="ekr.20070127142814.130"><vh>getPasteAsScript</vh></v>
</v>
<v t="ekr.20070127142814.131"><vh>helper classes</vh>
<v t="ekr.20070127142814.132"><vh>class JythonDelegate</vh></v>
<v t="ekr.20070127142814.133"><vh>class _SelectionReturner</vh></v>
<v t="ekr.20070127142814.134"><vh>class RemoveObjects</vh></v>
<v t="ekr.20070127142814.135"><vh>class DropFileMechanism</vh></v>
<v t="ekr.20070127142814.136"><vh>class DropFileMechanism</vh></v>
<v t="ekr.20070127142814.137"><vh>class JSColorConfigurationListener</vh>
<v t="ekr.20070127142814.138"><vh>&lt;&lt;case statement&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.139"><vh>prompts</vh></v>
</v>
<v t="ekr.20070127142814.140"><vh>main</vh></v>
</v>
<v t="ekr.20070127142814.141"><vh>@@thin MagicCommand.java</vh></v>
<v t="ekr.20070127142814.142"><vh>@@thin LineListener.java</vh></v>
<v t="ekr.20070127142814.143"><vh>@@thin LineListenerException.java</vh></v>
<v t="ekr.20070127142814.144"><vh>@@thin UtilityBoxListener.java</vh></v>
<v t="ekr.20070127142814.145"><vh>@@thin UtilityBoxEvent.java</vh></v>
<v t="ekr.20070127142814.146"><vh>@@thin PromptFormatter.java</vh></v>
<v t="ekr.20070127142814.147"><vh>@@thin Documentation.java</vh></v>
</v>
<v t="ekr.20070127142814.148"><vh>magic commands</vh>
<v t="ekr.20070127142814.149"><vh>@@thin Macro.java</vh>
<v t="ekr.20070127142814.150"><vh>&lt;&lt;class LinesExecutor&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.151"><vh>@@thin History.java</vh>
<v t="ekr.20070127142814.152"><vh>&lt;&lt;from&gt;&gt;</vh></v>
<v t="ekr.20070127142814.153"><vh>&lt;&lt;range&gt;&gt;</vh></v>
<v t="ekr.20070127142814.154"><vh>class OutputList</vh></v>
<v t="ekr.20070127142814.155"><vh>outputList</vh></v>
</v>
<v t="ekr.20070127142814.156"><vh>@@thin Debugger.java</vh></v>
<v t="ekr.20070127142814.157"><vh>@@thin Prun.java</vh>
<v t="ekr.20070127142814.158"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.159"><vh>@@thin Threads.java</vh>
<v t="ekr.20070127142814.160"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.161"><vh>@@thin XSLT.java</vh>
<v t="ekr.20070127142814.162"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.163"><vh>@@thin Serialize.java</vh>
<v t="ekr.20070127142814.164"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.165"><vh>@@thin Deserialize.java</vh>
<v t="ekr.20070127142814.166"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.167"><vh>@@thin Clean.java</vh>
<v t="ekr.20070127142814.168"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.169"><vh>@@thin Swing.java</vh>
<v t="ekr.20070127142814.170"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.171"><vh>@@thin Pwd.java</vh>
<v t="ekr.20070127142814.172"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.173"><vh>@@thin Jpidcore.java</vh></v>
<v t="ekr.20070127142814.174"><vh>@@thin Bgprocess.java</vh>
<v t="ekr.20070127142814.175"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.176"><vh>@@thin See.java</vh>
<v t="ekr.20070127142814.177"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.178"><vh>@@thin Cd.java</vh>
<v t="ekr.20070127142814.179"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.180"><vh>@@thin Dhist.java</vh>
<v t="ekr.20070127142814.181"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.182"><vh>@@thin Ps.java</vh>
<v t="ekr.20070127142814.183"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.184"><vh>@@thin Ls.java</vh>
<v t="ekr.20070127142814.185"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.186"><vh>@@thin Send.java</vh>
<v t="ekr.20070127142814.187"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.188"><vh>@@thin Wait.java</vh>
<v t="ekr.20070127142814.189"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.190"><vh>@@thin Kill.java</vh>
<v t="ekr.20070127142814.191"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.192"><vh>@@thin Clear.java</vh>
<v t="ekr.20070127142814.193"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.194"><vh>@@thin Lsmagic.java</vh>
<v t="ekr.20070127142814.195"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.196"><vh>@@thin Magic.java</vh>
<v t="ekr.20070127142814.197"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.198"><vh>@@thin Keystrokes.java</vh>
<v t="ekr.20070127142814.199"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.200"><vh>@@thin Iuse.java</vh>
<v t="ekr.20070127142814.201"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.202"><vh>@@thin Url.java</vh>
<v t="ekr.20070127142814.203"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.204"><vh>@@thin Bg.java</vh>
<v t="ekr.20070127142814.205"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.206"><vh>&lt;&lt;jobs class&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.207"><vh>@@thin Pfile.java</vh>
<v t="ekr.20070127142814.208"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.209"><vh>getfile code</vh></v>
</v>
<v t="ekr.20070127142814.210"><vh>@@thin Pdoc.java</vh>
<v t="ekr.20070127142814.211"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.212"><vh>@@thin Pinfo.java</vh>
<v t="ekr.20070127142814.213"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.214"><vh>viewObject</vh></v>
</v>
<v t="ekr.20070127142814.215"><vh>@@thin P.java</vh>
<v t="ekr.20070127142814.216"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.217"><vh>@@thin R.java</vh>
<v t="ekr.20070127142814.218"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.219"><vh>@@thin Env.java</vh>
<v t="ekr.20070127142814.220"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.221"><vh>@@thin Save.java</vh>
<v t="ekr.20070127142814.222"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.223"><vh>@@thin Who.java</vh>
<v t="ekr.20070127142814.224"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.225"><vh>@@thin Whos.java</vh>
<v t="ekr.20070127142814.226"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.227"><vh>@@thin Who_ls.java</vh>
<v t="ekr.20070127142814.228"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.229"><vh>@@thin Autocall.java</vh>
<v t="ekr.20070127142814.230"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.231"><vh>@@thin Autoindent.java</vh>
<v t="ekr.20070127142814.232"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.233"><vh>@@thin Sc.java</vh>
<v t="ekr.20070127142814.234"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.235"><vh>@@thin Sx.java</vh>
<v t="ekr.20070127142814.236"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.237"><vh>@@thin Ed.java</vh>
<v t="ekr.20070127142814.238"><vh>&lt;&lt;document listener2&gt;&gt;</vh></v>
<v t="ekr.20070127142814.239"><vh>&lt;&lt;return&gt;&gt;</vh></v>
<v t="ekr.20070127142814.240"><vh>&lt;&lt;description&gt;&gt;</vh></v>
<v t="ekr.20070127142814.241"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.242"><vh>indentating</vh></v>
<v t="ekr.20070127142814.243"><vh>registerKeyStrokeAction</vh></v>
<v t="ekr.20070127142814.244"><vh>class Help</vh></v>
<v t="ekr.20070127142814.245"><vh>class FocusRequestor</vh></v>
<v t="ekr.20070127142814.246"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20070127142814.247"><vh>@@thin Reset.java</vh>
<v t="ekr.20070127142814.248"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.249"><vh>@@thin Alias.java</vh>
<v t="ekr.20070127142814.250"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.251"><vh>@@thin Unalias.java</vh>
<v t="ekr.20070127142814.252"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.253"><vh>@@thin Rehash.java</vh>
<v t="ekr.20070127142814.254"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.255"><vh>@@thin Rehashx.java</vh>
<v t="ekr.20070127142814.256"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.257"><vh>@@thin Run.java</vh>
<v t="ekr.20070127142814.258"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.259"><vh>search</vh></v>
<v t="ekr.20070127142814.260"><vh>run</vh></v>
<v t="ekr.20070127142814.261"><vh>runDebug</vh></v>
<v t="ekr.20070127142814.262"><vh>getNumberFromSwitches</vh></v>
<v t="ekr.20070127142814.263"><vh>pdb array...</vh></v>
<v t="ekr.20070127142814.264"><vh>pdb array2</vh></v>
</v>
<v t="ekr.20070127142814.265"><vh>@@thin Bookmark.java</vh>
<v t="ekr.20070127142814.266"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.267"><vh>@@thin Dirs.java</vh>
<v t="ekr.20070127142814.268"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.269"><vh>@@thin Popd.java</vh>
<v t="ekr.20070127142814.270"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.271"><vh>@@thin Pushd.java</vh>
<v t="ekr.20070127142814.272"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.273"><vh>pushD</vh></v>
</v>
<v t="ekr.20070127142814.274"><vh>@@thin Automagic.java</vh>
<v t="ekr.20070127142814.275"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.276"><vh>@@thin Logcore.java</vh></v>
<v t="ekr.20070127142814.277"><vh>@@thin Logstart.java</vh>
<v t="ekr.20070127142814.278"><vh>&lt;&lt;command&gt;&gt;</vh></v>
<v t="ekr.20070127142814.279"><vh>static class RotateFilter</vh></v>
</v>
<v t="ekr.20070127142814.280"><vh>@@thin Logoff.java</vh>
<v t="ekr.20070127142814.281"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.282"><vh>@@thin Logon.java</vh>
<v t="ekr.20070127142814.283"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.284"><vh>@@thin Logstate.java</vh>
<v t="ekr.20070127142814.285"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.286"><vh>@@thin Runlog.java</vh>
<v t="ekr.20070127142814.287"><vh>&lt;&lt;command&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.288"><vh>magic editor</vh>
<v t="ekr.20070127142814.289"><vh>@@thin StartOfLine.java</vh></v>
<v t="ekr.20070127142814.290"><vh>@@thin EndOfLine.java</vh></v>
</v>
<v t="ekr.20070127142814.291"><vh>actions</vh>
<v t="ekr.20070127142814.292"><vh>@@thin DeleteToEndOfLine.java</vh></v>
<v t="ekr.20070127142814.293"><vh>@@thin RemoveLine.java</vh></v>
<v t="ekr.20070127142814.294"><vh>@@thin StartOfLine.java</vh></v>
<v t="ekr.20070127142814.295"><vh>@@thin EndOfLine.java</vh></v>
<v t="ekr.20070127142814.296"><vh>@@thin DynamicAbbreviation.java</vh></v>
<v t="ekr.20070127142814.297"><vh>@@thin UpDownArrows.java</vh>
<v t="ekr.20070127142814.298"><vh>&lt;&lt;body&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.299"><vh>@@thin TabCompletion.java</vh>
<v t="ekr.20070127142814.300"><vh>startCompletion</vh></v>
<v t="ekr.20070127142814.301"><vh>nextCompletion</vh></v>
<v t="ekr.20070127142814.302"><vh>insertAbbrev</vh></v>
<v t="ekr.20070127142814.303"><vh>insertTab</vh></v>
</v>
<v t="ekr.20070127142814.304"><vh>@@thin SearchInputHistory.java</vh>
<v t="ekr.20070127142814.305"><vh>&lt;&lt;process&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.306"><vh>@@thin ReverseIncrementalSearch.java</vh></v>
<v t="ekr.20070127142814.307"><vh>@@thin SupressOutput.java</vh></v>
<v t="ekr.20070127142814.308"><vh>@@thin TripleQuotes.java</vh></v>
<v t="ekr.20070127142814.309"><vh>@@thin CloseUtilityBoxes.java</vh></v>
<v t="ekr.20070127142814.310"><vh>@@thin PasteAsScript.java</vh></v>
<v t="ekr.20070127142814.311"><vh>@@thin Paste.java</vh></v>
<v t="ekr.20070127142814.312"><vh>@@thin Copy.java</vh></v>
</v>
<v t="ekr.20070127142814.313"><vh>util</vh>
<v t="ekr.20070127142814.314"><vh>@@thin StringInserter.java</vh></v>
<v t="ekr.20070127142814.315"><vh>@@thin InsertPrompt.java</vh></v>
<v t="ekr.20070127142814.316"><vh>@@thin AddLine.java</vh></v>
<v t="ekr.20070127142814.317"><vh>@@thin ScriptExecutor.java</vh></v>
<v t="ekr.20070127142814.318"><vh>@@thin JSUtilities.java</vh>
<v t="ekr.20070127142814.319"><vh>wordStart</vh></v>
</v>
<v t="ekr.20070127142814.320"><vh>@@thin CommandLineParser.java</vh></v>
<v t="ekr.20070127142814.321"><vh>@@thin CommandFinder.java</vh></v>
<v t="ekr.20070127142814.322"><vh>@@thin ProcessExecutor.java</vh></v>
<v t="ekr.20070127142814.323"><vh>@@thin Abbreviation.java</vh></v>
</v>
<v t="ekr.20070127142814.324"><vh>widget</vh>
<v t="ekr.20070127142814.325"><vh>@@thin CopyPaste.java</vh></v>
<v t="ekr.20070127142814.326"><vh>@@thin CutCopyPaste.java</vh></v>
<v t="ekr.20070127142814.327"><vh>@@thin Pager.java</vh></v>
<v t="ekr.20070127142814.328"><vh>@@thin ZoneViewEditorKit.java</vh></v>
<v t="ekr.20070127142814.329"><vh>@@thin UneditableTableModel.java</vh></v>
<v t="ekr.20070127142814.330"><vh>@@thin ImageJViewport.java</vh></v>
<v t="ekr.20070127142814.331"><vh>@@thin MessageBorder.java</vh></v>
<v t="ekr.20070127142814.332"><vh>@@thin ObjectViewer.java</vh>
<v t="ekr.20070127142814.333"><vh>titleBorder</vh></v>
<v t="ekr.20070127142814.334"><vh>setClassName</vh></v>
<v t="ekr.20070127142814.335"><vh>setBases</vh></v>
<v t="ekr.20070127142814.336"><vh>setDocString</vh></v>
<v t="ekr.20070127142814.337"><vh>setJythonAttributes</vh></v>
<v t="ekr.20070127142814.338"><vh>setJavaMethods</vh></v>
<v t="ekr.20070127142814.339"><vh>setJavaFields</vh></v>
</v>
</v>
<v t="ekr.20070127142814.340"><vh>io</vh>
<v t="ekr.20070127142814.341"><vh>@@thin JSOutputStream.java</vh></v>
<v t="ekr.20070127142814.342"><vh>@@thin PyFile2.java</vh></v>
</v>
<v t="ekr.20070127142814.343"><vh>color</vh>
<v t="ekr.20070127142814.344"><vh>@@thin JythonColorizer.java</vh>
<v t="ekr.20070127142814.345"><vh>colorization</vh>
<v t="ekr.20070127142814.346"><vh>colorize</vh></v>
<v t="ekr.20070127142814.347"><vh>findPositions</vh></v>
<v t="ekr.20070127142814.348"><vh>colorizeStrings</vh></v>
<v t="ekr.20070127142814.349"><vh>isLocal</vh></v>
<v t="ekr.20070127142814.350"><vh>isKeyword isBuiltin</vh></v>
<v t="ekr.20070127142814.351"><vh>isConvention</vh></v>
</v>
<v t="ekr.20070127142814.352"><vh>startOfLine endOfLine</vh></v>
<v t="ekr.20070127142814.353"><vh>addPosition</vh></v>
<v t="ekr.20070127142814.354"><vh>class PositionHolder</vh></v>
<v t="ekr.20070127142814.355"><vh>class PHComparator</vh></v>
<v t="ekr.20070127142814.356"><vh>clearPositions</vh></v>
</v>
<v t="ekr.20070127142814.357"><vh>@@thin ColorConfigurationListener.java</vh></v>
<v t="ekr.20070127142814.358"><vh>@@thin ColorEvent.java</vh></v>
<v t="ekr.20070127142814.359"><vh>@@thin ColorConfiguration.java</vh>
<v t="ekr.20070127142814.360"><vh>ColorConfiguration</vh></v>
<v t="ekr.20070127142814.361"><vh>registerColorConfigurationListener</vh></v>
<v t="ekr.20070127142814.362"><vh>background</vh></v>
<v t="ekr.20070127142814.363"><vh>foreground</vh></v>
<v t="ekr.20070127142814.364"><vh>prompt colors</vh></v>
<v t="ekr.20070127142814.365"><vh>out and err color</vh></v>
<v t="ekr.20070127142814.366"><vh>calltip</vh></v>
<v t="ekr.20070127142814.367"><vh>kword</vh></v>
<v t="ekr.20070127142814.368"><vh>local</vh></v>
<v t="ekr.20070127142814.369"><vh>builtin</vh></v>
<v t="ekr.20070127142814.370"><vh>convention</vh></v>
<v t="ekr.20070127142814.371"><vh>syntax color</vh></v>
<v t="ekr.20070127142814.372"><vh>string color</vh></v>
</v>
</v>
<v t="ekr.20070127142814.373"><vh>alias</vh>
<v t="ekr.20070127142814.374"><vh>@@thin Alias.java</vh></v>
<v t="ekr.20070127142814.375"><vh>@@thin AliasConverter.java</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1"><vh>Python utilities</vh>
<v t="ekr.20070127142814.2"><vh>@@thin DefCallable.py</vh></v>
<v t="ekr.20070127142814.3"><vh>@@thin CutCopyPaste.py</vh></v>
<v t="ekr.20070127142814.4"><vh>@@thin TabManager.py</vh></v>
<v t="ekr.20070127142814.5"><vh>@@thin DoNothingEntityResolver.py</vh></v>
<v t="ekr.20070127142814.6"><vh>@@thin JPanelScrollableDelegator.py</vh></v>
<v t="ekr.20070127142814.7"><vh>@@thin WeakMethod.py</vh></v>
<v t="ekr.20070127142814.8"><vh>@@thin Phaser.py</vh>
<v t="ekr.20070127142814.9"><vh>phaseIn</vh></v>
<v t="ekr.20070127142814.10"><vh>phaseOut</vh></v>
</v>
<v t="ekr.20070127142814.11"><vh>@@thin Slider.py</vh>
<v t="ekr.20070127142814.12"><vh>slideIn</vh></v>
<v t="ekr.20070127142814.13"><vh>slideOut</vh></v>
</v>
</v>
<v t="ekr.20070930211626"><vh>Java files</vh>
<v t="ekr.20070930213000" a="E"><vh>Examples</vh>
<v t="ekr.20070127142814.1631"><vh>@@file-nosent ExpandTreeExample.java</vh></v>
<v t="ekr.20070127142814.1233"><vh>@@file-nosent JListProblem.java</vh></v>
</v>
<v t="ekr.20070930213000.1"><vh>Tests</vh>
<v t="ekr.20070127142814.1625"><vh>@@file-nosent ASynthTest.java</vh></v>
</v>
<v t="ekr.20070127142814.377"><vh>@@thin AtFileConstants.java</vh></v>
<v t="ekr.20070127142814.1048"><vh>@@thin AutoPanel.java</vh></v>
<v t="ekr.20070127142814.1049"><vh>@@thin BarDrawer.java</vh></v>
<v t="ekr.20070127142814.952"><vh>@@thin Chapters.py</vh>
<v t="ekr.20070127142814.953"><vh>What are Chapters?</vh></v>
<v t="ekr.20070127142814.954"><vh>Things A Developer should know about Chapters</vh></v>
<v t="ekr.20070127142814.955"><vh>A Note about Chapters and Commanders</vh></v>
<v t="ekr.20070127142814.956"><vh>commander delegates</vh></v>
<v t="ekr.20070127142814.957"><vh>stateChanged</vh></v>
<v t="ekr.20070127142814.958"><vh>getChaptersIterator</vh></v>
<v t="ekr.20070127142814.959"><vh>markNodesForChapterization</vh></v>
<v t="ekr.20070127142814.960"><vh>utility</vh>
<v t="ekr.20070127142814.961"><vh>changeChaptersName</vh></v>
<v t="ekr.20070127142814.962"><vh>moveNodeToChapter</vh></v>
<v t="ekr.20070127142814.963"><vh>copyNodeToChapter</vh></v>
<v t="ekr.20070127142814.964"><vh>cloneNodeToChapter</vh></v>
<v t="ekr.20070127142814.965"><vh>testNode</vh></v>
<v t="ekr.20070127142814.966"><vh>swapChapters</vh></v>
<v t="ekr.20070127142814.967"><vh>mergeChapters</vh></v>
<v t="ekr.20070127142814.968"><vh>selectChapter</vh></v>
<v t="ekr.20070127142814.969"><vh>insertChapter</vh></v>
<v t="ekr.20070127142814.970"><vh>findChapterForNode</vh></v>
<v t="ekr.20070127142814.971"><vh>turnNodeIntoChapter</vh></v>
</v>
<v t="ekr.20070127142814.972"><vh>import and export</vh>
<v t="ekr.20070127142814.973"><vh>import outline</vh></v>
<v t="ekr.20070127142814.974"><vh>export outline</vh></v>
</v>
<v t="ekr.20070127142814.975"><vh>adding and removing chapters</vh>
<v t="ekr.20070127142814.976"><vh>addChapter</vh></v>
<v t="ekr.20070127142814.977"><vh>addChapterForSettingsTree</vh></v>
<v t="ekr.20070127142814.978"><vh>freshChapter</vh></v>
<v t="ekr.20070127142814.979"><vh>removeChapter</vh></v>
<v t="ekr.20070127142814.980"><vh>quietRemoveChapter</vh></v>
</v>
<v t="ekr.20070127142814.981"><vh>transforming an Outline into Chapers components</vh>
<v t="ekr.20070127142814.982"><vh>deferedChaperization</vh></v>
<v t="ekr.20070127142814.983"><vh>breakOutlineIntoChapters</vh></v>
</v>
<v t="ekr.20070127142814.984"><vh>class ChaptersPopup</vh>
<v t="ekr.20070127142814.985"><vh>mousePressed</vh></v>
<v t="ekr.20070127142814.986"><vh>class CopyNodeToChapter</vh></v>
<v t="ekr.20070127142814.987"><vh>class CloneNodeToChapter</vh></v>
<v t="ekr.20070127142814.988"><vh>class SwapChapters</vh></v>
<v t="ekr.20070127142814.989"><vh>class MergeChapters</vh></v>
</v>
<v t="ekr.20070127142814.990"><vh>Action Classes</vh>
<v t="ekr.20070127142814.991"><vh>DefAction</vh></v>
</v>
<v t="ekr.20070127142814.992"><vh>class ChapterModel</vh></v>
<v t="ekr.20070127142814.993"><vh>class Chapter</vh></v>
<v t="ekr.20070127142814.994"><vh>class SliderMessageButtons</vh></v>
<v t="ekr.20070127142814.995"><vh>IconCloser</vh></v>
<v t="ekr.20070127142814.996"><vh>iterators</vh>
<v t="ekr.20070127142814.997"><vh>chaptersIterator</vh></v>
<v t="ekr.20070127142814.998"><vh>topLevelSiblingsIterator</vh></v>
<v t="ekr.20070127142814.999"><vh>cycleThroughChapters</vh></v>
</v>
<v t="ekr.20070127142814.1000"><vh>Undo</vh>
<v t="ekr.20070127142814.1001"><vh>UndoRemoveChapter</vh></v>
<v t="ekr.20070127142814.1002"><vh>UndoChangeChapterName</vh></v>
<v t="ekr.20070127142814.1003"><vh>UndoAddChapter</vh></v>
<v t="ekr.20070127142814.1004"><vh>UndoImport</vh></v>
<v t="ekr.20070127142814.1005"><vh>UndoSwapChapters</vh></v>
</v>
</v>
<v t="ekr.20070127142814.675"><vh>@@thin ClassLoaderBase.java</vh>
<v t="ekr.20070127142814.676"><vh>&lt;&lt;JFreeReportClassLoader&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1036"><vh>@@thin CommanderSpecification.java</vh></v>
<v t="ekr.20070127142814.1039"><vh>@@thin EditorBackground.java</vh></v>
<v t="ekr.20070127142814.1040"><vh>@@thin EditorBackgroundMovie.java</vh></v>
<v t="ekr.20070127142814.1618"><vh>@@thin FakeClass.java</vh></v>
<v t="ekr.20070127142814.1037"><vh>@@thin IteratorDecorator.java</vh></v>
<v t="ekr.20070127142814.1498"><vh>@@thin JLibrary.py</vh>
<v t="ekr.20070127142814.1499"><vh>&lt;&lt; about this extension &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1500"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1501"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1502"><vh>class JLibrary_Loc</vh>
<v t="ekr.20070127142814.1503"><vh>__init__</vh></v>
<v t="ekr.20070127142814.1504"><vh>__call__</vh></v>
<v t="ekr.20070127142814.1505"><vh>sync</vh></v>
<v t="ekr.20070127142814.1506"><vh>createGui</vh></v>
<v t="ekr.20070127142814.1507"><vh>create</vh></v>
<v t="ekr.20070127142814.1508"><vh>move</vh></v>
<v t="ekr.20070127142814.1509"><vh>remove</vh></v>
<v t="ekr.20070127142814.1510"><vh>open</vh></v>
<v t="ekr.20070127142814.1511"><vh>close</vh></v>
<v t="ekr.20070127142814.1512"><vh>add</vh></v>
<v t="ekr.20070127142814.1513"><vh>valueChanged</vh></v>
<v t="ekr.20070127142814.1514"><vh>addToAltX</vh></v>
<v t="ekr.20070127142814.1515"><vh>addToKeyStrokes</vh></v>
</v>
<v t="ekr.20070127142814.1516"><vh>class JLibrary</vh>
<v t="ekr.20070127142814.1517"><vh>__init__</vh></v>
<v t="ekr.20070127142814.1518"><vh>add (unicode)</vh></v>
<v t="ekr.20070127142814.1519"><vh>remove</vh></v>
<v t="ekr.20070127142814.1520"><vh>names</vh></v>
<v t="ekr.20070127142814.1521"><vh>retrieve (unicode)</vh></v>
<v t="ekr.20070127142814.1522"><vh>getDialog</vh></v>
<v t="ekr.20070127142814.1523"><vh>addList</vh></v>
<v t="ekr.20070127142814.1524"><vh>setListContents</vh></v>
<v t="ekr.20070127142814.1525"><vh>insert</vh></v>
<v t="ekr.20070127142814.1526"><vh>delete</vh></v>
<v t="ekr.20070127142814.1527"><vh>addCurrentNode</vh></v>
</v>
<v t="ekr.20070127142814.1528"><vh>getCommands</vh></v>
</v>
<v t="ekr.20070127142814.1616"><vh>@@thin JyLeoClassloader.java</vh></v>
<v t="ekr.20070127142814.1617"><vh>@@thin JyLeoResourceClassLoader.java</vh></v>
<v t="ekr.20070127142814.1117"><vh>@@thin leoBaseAtFile.java</vh>
<v t="ekr.20070127142814.1118"><vh>properties</vh>
<v t="ekr.20070127142814.1119"><vh>indent</vh></v>
<v t="ekr.20070127142814.1120"><vh>language</vh></v>
<v t="ekr.20070127142814.1121"><vh>sentinels and toString</vh></v>
<v t="ekr.20070127142814.1122"><vh>startSentinelComment</vh></v>
<v t="ekr.20070127142814.1123"><vh>endSentinelComment</vh></v>
<v t="ekr.20070127142814.1124"><vh>outputStream</vh></v>
<v t="ekr.20070127142814.1125"><vh>output_newline</vh></v>
<v t="ekr.20070127142814.1126"><vh>targetFileName</vh></v>
<v t="ekr.20070127142814.1127"><vh>outputFileName</vh></v>
<v t="ekr.20070127142814.1128"><vh>root</vh></v>
<v t="ekr.20070127142814.1129"><vh>errors</vh></v>
<v t="ekr.20070127142814.1130"><vh>c</vh></v>
<v t="ekr.20070127142814.1131"><vh>fileChangedFlag</vh></v>
<v t="ekr.20070127142814.1132"><vh>writeAtFileNodesFlag</vh></v>
<v t="ekr.20070127142814.1133"><vh>writeDirtyAtFileNodesFlag</vh></v>
<v t="ekr.20070127142814.1134"><vh>docKind and docDirective</vh></v>
<v t="ekr.20070127142814.1135"><vh>pending</vh></v>
<v t="ekr.20070127142814.1136"><vh>page_width</vh></v>
<v t="ekr.20070127142814.1137"><vh>default_directory</vh></v>
<v t="ekr.20070127142814.1138"><vh>explictLineEnding</vh></v>
<v t="ekr.20070127142814.1139"><vh>stringOutput</vh></v>
<v t="ekr.20070127142814.1140"><vh>shortFileName</vh></v>
<v t="ekr.20070127142814.1141"><vh>outputFile</vh></v>
<v t="ekr.20070127142814.1142"><vh>inCode</vh></v>
<v t="ekr.20070127142814.1143"><vh>root_seen</vh></v>
</v>
<v t="ekr.20070127142814.1144"><vh>data from app --language_delims_dict</vh></v>
<v t="ekr.20070127142814.1145"><vh>table Map initialization</vh></v>
<v t="ekr.20070127142814.1146"><vh>abstracts</vh></v>
<v t="ekr.20070127142814.1147"><vh>isSectionName</vh></v>
<v t="ekr.20070127142814.1148"><vh>directiveKind4</vh></v>
<v t="ekr.20070127142814.1149"><vh>utilities</vh>
<v t="ekr.20070127142814.1150"><vh>set_delims_from_string</vh></v>
<v t="ekr.20070127142814.1151"><vh>set_delims_from_language</vh></v>
<v t="ekr.20070127142814.1152"><vh>is_nl is_ws</vh></v>
<v t="ekr.20070127142814.1153"><vh>skip_leading_ws_with_indent</vh></v>
</v>
<v t="ekr.20070127142814.1154"><vh>writing</vh>
<v t="ekr.20070127142814.1155"><vh>putRefLine &amp; allies</vh>
<v t="ekr.20070127142814.1156"><vh>putRefLine</vh></v>
<v t="ekr.20070127142814.1157"><vh>putRefAt</vh></v>
<v t="ekr.20070127142814.1158"><vh>putAfterLastRef</vh></v>
<v t="ekr.20070127142814.1159"><vh>putAfterMiddleef</vh></v>
</v>
<v t="ekr.20070127142814.1160"><vh>writeAll</vh>
<v t="ekr.20070127142814.1161"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1162"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1163"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1164"><vh>write</vh>
<v t="ekr.20070127142814.1165"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1166"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1167"><vh>writeOpenFile</vh>
<v t="ekr.20070127142814.1168"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20070127142814.1169"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20070127142814.1170"><vh>Writing 4,x sentinels...</vh>
<v t="ekr.20070127142814.1171"><vh>nodeSentinelText 4.x</vh>
<v t="ekr.20070127142814.1172"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1173"><vh>convertGnxToString</vh></v>
<v t="ekr.20070127142814.1174"><vh>putLeadInSentinel 4.x</vh></v>
<v t="ekr.20070127142814.1175"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20070127142814.1176"><vh>putOpenLeoSentinel 4.x</vh></v>
<v t="ekr.20070127142814.1177"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="ekr.20070127142814.1178"><vh>apply the cweb hack to s</vh></v>
</v>
<v t="ekr.20070127142814.1179"><vh>os and allies</vh>
<v t="ekr.20070127142814.1180"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="ekr.20070127142814.1181" a="M"><vh>onl &amp; onl_sent</vh></v>
<v t="ekr.20070127142814.1182"><vh>os</vh></v>
</v>
<v t="ekr.20070127142814.1183"><vh>putSentinel (applies cweb hack) 4.x</vh></v>
<v t="ekr.20070127142814.1184"><vh>putCodeLine</vh></v>
<v t="ekr.20070127142814.1185"><vh>putIndent</vh></v>
<v t="ekr.20070127142814.1186"><vh>putInitialComment</vh></v>
<v t="ekr.20070127142814.1187"><vh>writing doc lines...</vh>
<v t="ekr.20070127142814.1188"><vh>putBlankDocLine</vh></v>
<v t="ekr.20070127142814.1189"><vh>putStartDocLine</vh></v>
<v t="ekr.20070127142814.1190"><vh>putDocLine</vh>
<v t="ekr.20070127142814.1191"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1192"><vh>putEndDocLine</vh></v>
<v t="ekr.20070127142814.1193"><vh>putPending</vh></v>
<v t="ekr.20070127142814.1194"><vh>pendingToString</vh></v>
</v>
<v t="ekr.20070127142814.1195"><vh>putBody</vh>
<v t="ekr.20070127142814.1196" a="M"><vh>&lt;&lt; handle line at s[i] &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1197"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20070127142814.1198"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1199"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1200"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1201"><vh>Make sure all lines end in a newline</vh></v>
<v t="ekr.20070127142814.1202" a="M"><vh>@others</vh>
<v t="ekr.20070127142814.1203"><vh>inAtOthers</vh></v>
<v t="ekr.20070127142814.1204"><vh>putAtOthersChild</vh></v>
<v t="ekr.20070127142814.1205"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20070127142814.1206" a="M"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20070127142814.1207"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1208"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1209"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20070127142814.1210"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1211"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1212"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1213"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1214"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1215"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1216"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1217"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1218"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1219"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1220"><vh>initWriteIvars</vh>
<v t="ekr.20070127142814.1221"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1222"><vh>initCommonIvars</vh>
<v t="ekr.20070127142814.1223"><vh>&lt;&lt; set defaults for arguments and options &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1224"><vh>&lt;&lt; init common ivars &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142814.395"><vh>@@thin LeoCompoundEdit.java</vh></v>
<v t="ekr.20070127142814.1052"><vh>@@thin LeoFileReader.java</vh>
<v t="ekr.20070127142814.1053"><vh>sentinelDict</vh></v>
<v t="ekr.20070127142814.1054"><vh>dispatch</vh>
<v t="ekr.20070127142814.1055"><vh>readNormalLine</vh></v>
<v t="ekr.20070127142814.1056"><vh>readNormalLine</vh>
<v t="ekr.20070127142814.1057"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1058"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1059"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20070127142814.1060"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20070127142814.1061"><vh>readStartLeo</vh></v>
<v t="ekr.20070127142814.1062"><vh>readStartMiddle</vh></v>
<v t="ekr.20070127142814.1063"><vh>readStartNode (4.x)</vh></v>
<v t="ekr.20070127142814.1064"><vh>readStartOthers</vh></v>
<v t="ekr.20070127142814.1065"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20070127142814.1066"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20070127142814.1067"><vh>readEndLeo</vh></v>
<v t="ekr.20070127142814.1068"><vh>readEndMiddle</vh></v>
<v t="ekr.20070127142814.1069"><vh>readEndNode (4.x)</vh>
<v t="ekr.20070127142814.1070"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20070127142814.1071"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1072"><vh>readEndOthers</vh></v>
<v t="ekr.20070127142814.1073"><vh>readAfterRef</vh></v>
<v t="ekr.20070127142814.1074"><vh>readClone</vh></v>
<v t="ekr.20070127142814.1075"><vh>readComment</vh></v>
<v t="ekr.20070127142814.1076"><vh>readDelims</vh></v>
<v t="ekr.20070127142814.1077"><vh>readDirective (@@)</vh>
<v t="ekr.20070127142814.1078"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1079"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1080"><vh>readNl</vh></v>
<v t="ekr.20070127142814.1081"><vh>readNonl</vh></v>
<v t="ekr.20070127142814.1082"><vh>readRef</vh></v>
<v t="ekr.20070127142814.1083"><vh>readVerbatim</vh></v>
<v t="ekr.20070127142814.1084"><vh>readLastDocLine</vh></v>
<v t="ekr.20070127142814.1085"><vh>ignoreOldSentinel</vh></v>
</v>
<v t="ekr.20070127142814.1086"><vh>scanText4</vh></v>
<v t="ekr.20070127142814.1087"><vh>sentinelKind4</vh></v>
<v t="ekr.20070127142814.1088"><vh>sentinelKind4</vh></v>
<v t="ekr.20070127142814.1089"><vh>rtrim</vh></v>
<v t="ekr.20070127142814.1090"><vh>join</vh></v>
<v t="ekr.20070127142814.1091"><vh>readError</vh></v>
<v t="ekr.20070127142814.1092"><vh>readLine</vh></v>
<v t="ekr.20070127142814.1093"><vh>badEndSentinel, push/popSentinelStack</vh></v>
<v t="ekr.20070127142814.1094"><vh>scanHeader  (3.x and 4.x)</vh>
<v t="ekr.20070127142814.1095"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1096"><vh>parseLeoSentinel</vh>
<v t="ekr.20070127142814.1097"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1098"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1099"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1100"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1101"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1102"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1103"><vh>abstracts</vh>
<v t="ekr.20070127142814.1104"><vh>createThinChild4</vh></v>
<v t="ekr.20070127142814.1105"><vh>createImportedNode</vh></v>
<v t="ekr.20070127142814.1106"><vh>findChild4</vh></v>
</v>
<v t="ekr.20070127142814.1107"><vh>skippers</vh>
<v t="ekr.20070127142814.1108"><vh>skipIndent</vh></v>
<v t="ekr.20070127142814.1109"><vh>skip_long</vh></v>
<v t="ekr.20070127142814.1110"><vh>skipSentinelStart4</vh></v>
</v>
<v t="ekr.20070127142814.1111"><vh>utilities</vh>
<v t="ekr.20070127142814.1112"><vh>set_delims_from_string</vh></v>
<v t="ekr.20070127142814.1113"><vh>set_delims_from_language</vh></v>
<v t="ekr.20070127142814.1114"><vh>is_nl is_ws</vh></v>
<v t="ekr.20070127142814.1115"><vh>skip_leading_ws_with_indent</vh></v>
<v t="ekr.20070127142814.1116"><vh>removeLeadingWhitespace</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1007"><vh>@@thin leoHeadlineTreeCellEditor.java</vh>
<v t="ekr.20070127142814.1008"><vh>addCellEditorListener</vh></v>
<v t="ekr.20070127142814.1009"><vh>cancelCellEditing</vh></v>
<v t="ekr.20070127142814.1010"><vh>getCellEditorValue</vh></v>
<v t="ekr.20070127142814.1011"><vh>isCellEditable</vh></v>
<v t="ekr.20070127142814.1012"><vh>removeCellEditorListener</vh></v>
<v t="ekr.20070127142814.1013"><vh>shouldSelectCell</vh></v>
<v t="ekr.20070127142814.1014"><vh>stopCellEditing</vh></v>
<v t="ekr.20070127142814.1015"><vh>setBackgroundSize</vh></v>
<v t="ekr.20070127142814.1016"><vh>keyPressed</vh></v>
<v t="ekr.20070127142814.1017"><vh>getHeadline</vh></v>
<v t="ekr.20070127142814.1018"><vh>DocumentListener</vh></v>
<v t="ekr.20070127142814.1019"><vh>HeadlineListener</vh></v>
<v t="ekr.20070127142814.1020"><vh>JPanel2</vh></v>
<v t="ekr.20070127142814.1021"><vh>class HeadlineManipulator</vh>
<v t="ekr.20070127142814.1022"><vh>addForeground</vh></v>
<v t="ekr.20070127142814.1023"><vh>addBackground</vh></v>
<v t="ekr.20070127142814.1024"><vh>addFont</vh></v>
<v t="ekr.20070127142814.1025"><vh>addImage</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1006"><vh>@@thin leoIconTreeRenderer.java</vh></v>
<v t="ekr.20070127142814.1232"><vh>@@thin leoLayoutManager.java</vh></v>
<v t="ekr.20070127142814.1225"><vh>@@thin leoLNEditorKit.java</vh>
<v t="ekr.20070127142814.1226"><vh>leoLNEditorKit</vh></v>
<v t="ekr.20070127142814.1227"><vh>clone</vh></v>
<v t="ekr.20070127142814.1228"><vh>getContentType</vh></v>
<v t="ekr.20070127142814.1229"><vh>getViewFactory</vh></v>
<v t="ekr.20070127142814.1230"><vh>class LeoLNViewFactory</vh></v>
<v t="ekr.20070127142814.1231"><vh>class LeoLNView</vh></v>
</v>
<v t="ekr.20070127142814.405"><vh>@@thin leoManagedConfiguration.java</vh></v>
<v t="ekr.20070127142814.404"><vh>@@thin leoManagedConfigurationMBean.java</vh></v>
<v t="ekr.20070127142814.1042"><vh>@@thin leoRadialMenu.java</vh>
<v t="ekr.20070127142814.1043"><vh>constructor</vh></v>
<v t="ekr.20070127142814.1044"><vh>popup</vh></v>
<v t="ekr.20070127142814.1045"><vh>class mouser</vh></v>
<v t="ekr.20070127142814.1046"><vh>class RadialControl</vh>
<v t="ekr.20070127142814.1047"><vh>paint</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1050"><vh>@@thin leoTreeReloader.java</vh></v>
<v t="ekr.20070127142814.1611"><vh>@@thin LeoUtilities.java</vh>
<v t="ekr.20070127142814.1612"><vh>scanForLanguage</vh></v>
<v t="ekr.20070127142814.1613"><vh>scanForLanguageOnLine</vh></v>
<v t="ekr.20070127142814.1614"><vh>scanFor</vh></v>
<v t="ekr.20070127142814.1615"><vh>scanForAutoCompleter</vh></v>
</v>
<v t="ekr.20070127142814.394"><vh>@@thin NodeUndoerBase.java</vh></v>
<v t="ekr.20070127142814.1038"><vh>@@thin PositionIterator.java</vh></v>
<v t="ekr.20070127142814.1031"><vh>@@thin PositionJTree.java</vh></v>
<v t="ekr.20070127142814.1032"><vh>@@thin PositionJTree2.java</vh></v>
<v t="ekr.20070127142814.1030"><vh>@@thin PositionSpecification.java</vh></v>
<v t="ekr.20070127142814.396"><vh>@@thin TnodeBodyText.java</vh>
<v t="ekr.20070127142814.397"><vh>headString methods</vh></v>
</v>
<v t="ekr.20070127142814.1051"><vh>@@thin TnodeOperations.java</vh></v>
<v t="ekr.20070127142841.1"><vh>@thin leoEditorKit.java</vh></v>
<v t="ekr.20070127142841.24"><vh>@thin LeoObservable.java</vh></v>
<v t="ekr.20070127142814.1529"><vh>colorization code and editor kit code</vh>
<v t="ekr.20070127142814.1530"><vh>@@thin JyLeoColorizer.py</vh>
<v t="ekr.20070127142814.1531"><vh>colorizer</vh>
<v t="ekr.20070127142814.1532"><vh>tokenizer</vh></v>
<v t="ekr.20070127142814.1533"><vh>sortp</vh></v>
<v t="ekr.20070127142814.1534"><vh>addPosition</vh></v>
<v t="ekr.20070127142814.1535"><vh>color</vh></v>
<v t="ekr.20070127142814.1536"><vh>ispossiblecomment</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1537"><vh>@@thin JyLeoTokenizer.java</vh>
<v t="ekr.20070127142814.1538"><vh>isSpace</vh></v>
<v t="ekr.20070127142814.1539"><vh>ispossiblecomment</vh></v>
<v t="ekr.20070127142814.1540"><vh>addPosition</vh></v>
<v t="ekr.20070127142814.1541"><vh>next</vh>
<v t="ekr.20070127142814.1542"><vh>&lt;&lt;escape test&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1543"><vh>&lt;&lt;string test&gt;&gt;</vh>
<v t="ekr.20070127142814.1544"><vh>&lt;&lt;loop&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1545"><vh>&lt;&lt;section reference test&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1546"><vh>&lt;&lt;space test1&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1547"><vh>&lt;&lt;space test2&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1548"><vh>&lt;&lt;directive test&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1549"><vh>&lt;&lt;comment test&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1550"><vh>&lt;&lt;comment test2&gt;&gt;</vh>
<v t="ekr.20070127142814.1551"><vh>&lt;&lt;test1&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1552"><vh>&lt;&lt;test2&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1553"><vh>&lt;&lt;test3&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1554"><vh>&lt;&lt;alphanum test&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1555"><vh>tokenizer</vh></v>
</v>
<v t="ekr.20070127142814.1556"><vh>@@thin ColorizerRunnable.java</vh>
<v t="ekr.20070127142814.1557"><vh>tokens</vh>
<v t="ekr.20070127142814.1558"><vh>Token</vh></v>
<v t="ekr.20070127142814.1559"><vh>TokenRunnable</vh></v>
</v>
<v t="ekr.20070127142814.1560"><vh>run</vh></v>
<v t="ekr.20070127142814.1561"><vh>ispossiblecomment</vh></v>
<v t="ekr.20070127142814.1562"><vh>class IgnoreRange</vh></v>
<v t="ekr.20070127142814.1563"><vh>colorizeline</vh>
<v t="ekr.20070127142814.1564"><vh>&lt;&lt;prolog&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1565"><vh>&lt;&lt;docing&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1566"><vh>&lt;&lt;string&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1567"><vh>&lt;&lt;comment&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1568"><vh>&lt;&lt;section reference&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1569"><vh>&lt;&lt;else&gt;&gt;</vh>
<v t="ekr.20070127142814.1570"><vh>&lt;&lt;plugins&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1571"><vh>&lt;&lt;colorize positions&gt;&gt;</vh>
<v t="ekr.20070127142814.1572"><vh>&lt;&lt;iterate&gt;&gt;</vh>
<v t="ekr.20070127142814.1573"><vh>&lt;&lt;part1&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1574"><vh>&lt;&lt;part2&gt;&gt;</vh>
<v t="ekr.20070127142814.1575"><vh>&lt;&lt;handle possible doc&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1576"><vh>&lt;&lt;handle possible comment&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1577"><vh>&lt;&lt;handle string&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1578"><vh>&lt;&lt;finish coloring doc&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1579"><vh>&lt;&lt;finish coloring comment&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1580"><vh>&lt;&lt;finish coloring&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1581"><vh>python code...</vh></v>
</v>
<v t="ekr.20070127142814.1582"><vh>color</vh></v>
<v t="ekr.20070127142814.1583"><vh>isspace and isletterdigit</vh></v>
<v t="ekr.20070127142814.1584"><vh>class ImmutableAttributeSet</vh></v>
</v>
<v t="ekr.20070127142814.1585"><vh>@@thin PositionCarrier.java</vh></v>
<v t="ekr.20070127142814.1586"><vh>@@thin leoEditorKit2.java</vh>
<v t="ekr.20070127142814.1587"><vh>&lt;&lt;fold methods&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1588"><vh>&lt;&lt;create&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1589"><vh>class NoWrapBoxView</vh>
<v t="ekr.20070127142814.1590"><vh>layout</vh></v>
<v t="ekr.20070127142814.1591"><vh>modelToView</vh></v>
<v t="ekr.20070127142814.1592"><vh>getPreferredSpan</vh></v>
<v t="ekr.20070127142814.1593"><vh>getMinimumSpan</vh></v>
<v t="ekr.20070127142814.1594"><vh>getLeftInset</vh></v>
<v t="ekr.20070127142814.1595"><vh>getInsets</vh></v>
<v t="ekr.20070127142814.1596"><vh>paintNumbers</vh></v>
<v t="ekr.20070127142814.1597"><vh>paint</vh></v>
<v t="ekr.20070127142814.1598"><vh>linewraping</vh></v>
<v t="ekr.20070127142814.1599"><vh>getNextVisualPositionFrom</vh></v>
<v t="ekr.20070127142814.1600"><vh>getViewIndexAtPosition</vh></v>
<v t="ekr.20070127142814.1601"><vh>footnode stuff... might be deleted...</vh></v>
</v>
<v t="ekr.20070127142814.1602"><vh>class InvisiblesDrawingLabelView</vh></v>
<v t="ekr.20070127142814.1603"><vh>class LeoDefaultStyledDocument</vh></v>
<v t="ekr.20070127142814.1604"><vh>class FoldableParagraphView</vh></v>
<v t="ekr.20070127142814.1605"><vh>class LineNumberBorder</vh></v>
<v t="ekr.20070127142814.1606"><vh>interface ColorDeterminer</vh></v>
</v>
<v t="ekr.20070127142814.1607"><vh>@@thin leoTableViewEditorKit.java</vh>
<v t="ekr.20070127142814.1608"><vh>&lt;&lt;create&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1609"><vh>class TestTableView</vh>
<v t="ekr.20070127142814.1610"><vh>&lt;&lt;table row&gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070930212003"><vh>Python files</vh>
<v t="ekr.20070127142814.1632"><vh>@@file-nosent BlockExample.py</vh></v>
<v t="ekr.20070127142814.1628"><vh>@@file-nosent de64files.py</vh></v>
<v t="ekr.20070127142814.1619"><vh>@@file-nosent OpaqueProblem.py</vh></v>
<v t="ekr.20070127142814.1629"><vh>@@file-nosent testimport.py</vh></v>
<v t="ekr.20070127142814.1630"><vh>@@file-nosent testimport2.py</vh></v>
<v t="ekr.20070127142814.1621"><vh>@@file-nosent TestListRenderer.py</vh></v>
<v t="ekr.20070127142814.949"><vh>@@thin CommanderSupplemental.py</vh>
<v t="ekr.20070127142814.950"><vh>nodeToOutline</vh></v>
<v t="ekr.20070127142814.951"><vh>outline mungers</vh></v>
</v>
<v t="ekr.20070127142814.1620"><vh>@@thin DOMLeoFileReader.py</vh></v>
<v t="ekr.20070127142814.1033"><vh>@@thin JTree2.py</vh></v>
<v t="ekr.20070127142814.1497"><vh>@@thin KTableMaker.py</vh></v>
<v t="ekr.20070127142814.406"><vh>@@thin leoCompositeView.py</vh>
<v t="ekr.20070127142814.407"><vh>class NodeSyncher</vh></v>
<v t="ekr.20070127142814.408"><vh>def scanNode</vh></v>
<v t="ekr.20070127142814.409"><vh>def addSectionReferences</vh></v>
<v t="ekr.20070127142814.410"><vh>def addOthers</vh></v>
<v t="ekr.20070127142814.411"><vh>def divide</vh></v>
<v t="ekr.20070127142814.412"><vh>def addBorder</vh></v>
<v t="ekr.20070127142814.413"><vh>def add_remove</vh></v>
<v t="ekr.20070127142814.414"><vh>UndoableEditListener</vh></v>
</v>
<v t="ekr.20070127142814.417"><vh>@@thin leoFlashCardView.py</vh>
<v t="ekr.20070127142814.418"><vh>createGui</vh></v>
<v t="ekr.20070127142814.419"><vh>buttonActions</vh></v>
<v t="ekr.20070127142814.420"><vh>createFlashCardStack</vh></v>
<v t="ekr.20070127142814.421"><vh>checkValidActions</vh></v>
<v t="ekr.20070127142814.422"><vh>sync</vh></v>
<v t="ekr.20070127142814.423"><vh>setQuestionLabel</vh></v>
<v t="ekr.20070127142814.424"><vh>class QA</vh></v>
</v>
<v t="ekr.20070127142814.415"><vh>@@thin leoGraphView.py</vh></v>
<v t="ekr.20070127142814.1026"><vh>@@thin leoLanguageManager.py</vh>
<v t="ekr.20070127142814.1027"><vh>&lt;&lt;loadLanguage&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.398"><vh>@@thin leoManagement.py</vh>
<v t="ekr.20070127142814.399"><vh>__init__</vh></v>
<v t="ekr.20070127142814.400"><vh>addNotificationDef</vh></v>
<v t="ekr.20070127142814.401"><vh>class NotificationDef</vh></v>
<v t="ekr.20070127142814.402"><vh>addMBeanForProperty</vh></v>
<v t="ekr.20070127142814.403"><vh>class leoMC</vh></v>
</v>
<v t="ekr.20070127142814.494"><vh>@@thin leoSwingConfig.py</vh>
<v t="ekr.20070127142814.495"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070127142814.496"><vh>&lt;&lt; class parserBaseClass &gt;&gt;</vh>
<v t="ekr.20070127142814.497"><vh>&lt;&lt; parserBaseClass data &gt;&gt;</vh></v>
<v t="ekr.20070127142814.498"><vh> ctor</vh></v>
<v t="ekr.20070127142814.499"><vh>error</vh></v>
<v t="ekr.20070127142814.500"><vh>kind handlers</vh>
<v t="ekr.20070127142814.501"><vh>doBool</vh></v>
<v t="ekr.20070127142814.502"><vh>doColor</vh></v>
<v t="ekr.20070127142814.503"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20070127142814.504"><vh>doFloat</vh></v>
<v t="ekr.20070127142814.505"><vh>doFont</vh></v>
<v t="ekr.20070127142814.506"><vh>doIf</vh></v>
<v t="ekr.20070127142814.507"><vh>doIfGui</vh></v>
<v t="ekr.20070127142814.508"><vh>doIfPlatform</vh></v>
<v t="ekr.20070127142814.509"><vh>doIgnore</vh></v>
<v t="ekr.20070127142814.510"><vh>doInt</vh></v>
<v t="ekr.20070127142814.511"><vh>doInts</vh></v>
<v t="ekr.20070127142814.512"><vh>doPage</vh></v>
<v t="ekr.20070127142814.513"><vh>doRatio</vh></v>
<v t="ekr.20070127142814.514"><vh>doRecentFiles</vh></v>
<v t="ekr.20070127142814.515"><vh>doShortcut</vh></v>
<v t="ekr.20070127142814.516"><vh>doShortcuts</vh></v>
<v t="ekr.20070127142814.517"><vh>doString</vh></v>
<v t="ekr.20070127142814.518"><vh>doStrings</vh></v>
</v>
<v t="ekr.20070127142814.519"><vh>munge</vh></v>
<v t="ekr.20070127142814.520"><vh>oops</vh></v>
<v t="ekr.20070127142814.521"><vh>parsers</vh>
<v t="ekr.20070127142814.522"><vh>fontSettingNameToFontKind</vh></v>
<v t="ekr.20070127142814.523"><vh>parseFont</vh></v>
<v t="ekr.20070127142814.524"><vh>parseFontLine</vh></v>
<v t="ekr.20070127142814.525"><vh>parseHeadline</vh></v>
<v t="ekr.20070127142814.526"><vh>parseShortcutLine</vh></v>
</v>
<v t="ekr.20070127142814.527"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20070127142814.528"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20070127142814.529"><vh>traverse</vh></v>
<v t="ekr.20070127142814.530"><vh>valueError</vh></v>
<v t="ekr.20070127142814.531"><vh>visitNode (must be overwritten in subclasses)</vh></v>
</v>
<v t="ekr.20070127142814.532"><vh>class config</vh>
<v t="ekr.20070127142814.533"><vh>&lt;&lt;  baseConfig data &gt;&gt;</vh>
<v t="ekr.20070127142814.534"><vh>defaultsDict</vh></v>
<v t="ekr.20070127142814.535"><vh>define encodingIvarsDict</vh></v>
<v t="ekr.20070127142814.536"><vh>ivarsDict</vh></v>
</v>
<v t="ekr.20070127142814.537"><vh>Birth...</vh>
<v t="ekr.20070127142814.538"><vh>ctor</vh></v>
<v t="ekr.20070127142814.539"><vh>initDicts</vh></v>
<v t="ekr.20070127142814.540"><vh>initIvarsFromSettings &amp; helpers</vh>
<v t="ekr.20070127142814.541"><vh>initEncoding</vh></v>
<v t="ekr.20070127142814.542"><vh>initIvar</vh></v>
</v>
<v t="ekr.20070127142814.543"><vh>initRecentFiles</vh></v>
<v t="ekr.20070127142814.544"><vh>initSettingsFiles</vh></v>
</v>
<v t="ekr.20070127142814.545"><vh>Getters...</vh>
<v t="ekr.20070127142814.546"><vh>canonicalizeSettingName (munge)</vh></v>
<v t="ekr.20070127142814.547"><vh>config.findSettingsPosition</vh></v>
<v t="ekr.20070127142814.548"><vh>get &amp; allies</vh>
<v t="ekr.20070127142814.549"><vh>getValFromDict</vh></v>
</v>
<v t="ekr.20070127142814.550"><vh>getBool</vh></v>
<v t="ekr.20070127142814.551"><vh>getColor</vh></v>
<v t="ekr.20070127142814.552"><vh>getDirectory</vh></v>
<v t="ekr.20070127142814.553"><vh>getFloat</vh></v>
<v t="ekr.20070127142814.554"><vh>getFontFromParams (config)</vh></v>
<v t="ekr.20070127142814.555"><vh>getInt</vh></v>
<v t="ekr.20070127142814.556"><vh>getLanguage</vh></v>
<v t="ekr.20070127142814.557"><vh>getRatio</vh></v>
<v t="ekr.20070127142814.558"><vh>getRecentFiles</vh></v>
<v t="ekr.20070127142814.559"><vh>getShortcut (config)</vh></v>
<v t="ekr.20070127142814.560"><vh>getString</vh></v>
<v t="ekr.20070127142814.561"><vh>setCommandsIvars</vh></v>
<v t="ekr.20070127142814.562"><vh>settingsRoot</vh></v>
</v>
<v t="ekr.20070127142814.563"><vh>Setters</vh>
<v t="ekr.20070127142814.564"><vh>set (g.app.config)</vh></v>
<v t="ekr.20070127142814.565"><vh>setString</vh></v>
<v t="ekr.20070127142814.566"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20070127142814.567"><vh>config.appendToRecentFiles</vh></v>
</v>
<v t="ekr.20070127142814.568"><vh>Scanning @settings</vh>
<v t="ekr.20070127142814.569"><vh>openSettingsFile</vh></v>
<v t="ekr.20070127142814.570"><vh>config.readSettingsFiles</vh>
<v t="ekr.20070127142814.571"><vh>&lt;&lt; update recent files from d &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.572"><vh>readSettings</vh></v>
</v>
</v>
<v t="ekr.20070127142814.573"><vh>class settingsController</vh>
<v t="ekr.20070127142814.574"><vh> ctor</vh>
<v t="ekr.20070127142814.575"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
<v t="ekr.20070127142814.576"><vh>&lt;&lt; set background color for widgets &gt;&gt;</vh></v>
<v t="ekr.20070127142814.577"><vh>When replacing body &amp; tree panes...</vh>
<v t="ekr.20070127142814.578"><vh>&lt;&lt; replace the body pane with the outer dialog frame &gt;&gt;</vh></v>
<v t="ekr.20070127142814.579"><vh>&lt;&lt; replace tree pane with settings tree &gt;&gt;</vh></v>
<v t="ekr.20070127142814.580"><vh>&lt;&lt; add buttons and label to interior &gt;&gt;</vh></v>
<v t="ekr.20070127142814.581"><vh>&lt;&lt; add setterCanvas to interior&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.582"><vh>When using separate dialog...</vh>
<v t="ekr.20070127142814.583"><vh>&lt;&lt; create the dialog d &gt;&gt;</vh></v>
<v t="ekr.20070127142814.584"><vh>&lt;&lt; create paneFrame, a paned widget &gt;&gt;</vh></v>
<v t="ekr.20070127142814.585"><vh>&lt;&lt; create paneFrame2, a second paned widget &gt;&gt;</vh></v>
<v t="ekr.20070127142814.586"><vh>&lt;&lt; create outline and log panes in paneFrame2 &gt;&gt;</vh></v>
<v t="ekr.20070127142814.587"><vh>&lt;&lt; put setterCanvas in paneFrame's setter pane&gt;&gt;</vh></v>
<v t="ekr.20070127142814.588"><vh>&lt;&lt; put a Text widget in the comment pane &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.589"><vh>createSettingsTree &amp; helpers</vh>
<v t="ekr.20070127142814.590"><vh>&lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;</vh>
<v t="ekr.20070127142814.591"><vh>&lt;&lt; add entry for p to filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.592"><vh>rootNodeComments</vh></v>
</v>
<v t="ekr.20070127142814.593"><vh>createWidgets &amp; helpers</vh>
<v t="ekr.20070127142814.594"><vh>&lt;&lt; define creatorDispatchDict &gt;&gt;</vh></v>
<v t="ekr.20070127142814.595"><vh>createBool</vh></v>
<v t="ekr.20070127142814.596"><vh>createColor</vh>
<v t="ekr.20070127142814.597"><vh>&lt;&lt; munge val and add val to colorNamesList &gt;&gt;</vh></v>
<v t="ekr.20070127142814.598"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20070127142814.599"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.600"><vh>createComents</vh></v>
<v t="ekr.20070127142814.601"><vh>createDirectory</vh></v>
<v t="ekr.20070127142814.602"><vh>createFloat</vh></v>
<v t="ekr.20070127142814.603"><vh>createFont</vh>
<v t="ekr.20070127142814.604"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20070127142814.605"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20070127142814.606"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20070127142814.607"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20070127142814.608"><vh>&lt;&lt; define fontCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.609"><vh>createInt</vh></v>
<v t="ekr.20070127142814.610"><vh>createInts</vh></v>
<v t="ekr.20070127142814.611"><vh>createPath</vh></v>
<v t="ekr.20070127142814.612"><vh>createRatio</vh></v>
<v t="ekr.20070127142814.613"><vh>createRecentFiles</vh></v>
<v t="ekr.20070127142814.614"><vh>createShortcut</vh></v>
<v t="ekr.20070127142814.615"><vh>createShortcuts</vh></v>
<v t="ekr.20070127142814.616"><vh>createSpacerFrame</vh></v>
<v t="ekr.20070127142814.617"><vh>createString</vh></v>
<v t="ekr.20070127142814.618"><vh>createStrings</vh></v>
</v>
<v t="ekr.20070127142814.619"><vh>callbacks...</vh>
<v t="ekr.20070127142814.620"><vh>onAnyButton</vh></v>
<v t="ekr.20070127142814.621"><vh>revert</vh></v>
<v t="ekr.20070127142814.622"><vh>onPaneResize</vh></v>
<v t="ekr.20070127142814.623"><vh>handleTreeClick</vh></v>
</v>
<v t="ekr.20070127142814.624"><vh>getters...</vh>
<v t="ekr.20070127142814.625"><vh>findCorrespondingNode</vh></v>
<v t="ekr.20070127142814.626"><vh>findSettingsRoot</vh></v>
<v t="ekr.20070127142814.627"><vh>settingsPosition</vh></v>
</v>
<v t="ekr.20070127142814.628"><vh>redrawing...</vh>
<v t="ekr.20070127142814.629"><vh>updateSetter</vh></v>
<v t="ekr.20070127142814.630"><vh>updateSetterLabel</vh></v>
</v>
<v t="ekr.20070127142814.631"><vh>value handlers...</vh>
<v t="ekr.20070127142814.632"><vh>initValue</vh></v>
<v t="ekr.20070127142814.633"><vh>writeChangedVars &amp; helpers</vh>
<v t="ekr.20070127142814.634"><vh>updateConfig</vh></v>
<v t="ekr.20070127142814.635"><vh>updateOneNode &amp; helper</vh>
<v t="ekr.20070127142814.636"><vh>computeBodyFromFontDict</vh></v>
</v>
<v t="ekr.20070127142814.637"><vh>writeChangedList</vh>
<v t="ekr.20070127142814.638"><vh>&lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.639"><vh>writeChangesToFile</vh></v>
</v>
</v>
<v t="ekr.20070127142814.640"><vh>utilities...</vh>
<v t="ekr.20070127142814.641"><vh>class logClass</vh>
<v t="ekr.20070127142814.642"><vh>&lt;&lt; put s to w &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.643"><vh>center</vh></v>
<v t="ekr.20070127142814.644"><vh>settingsController.es</vh></v>
<v t="ekr.20070127142814.645"><vh>copyExpansionState</vh></v>
<v t="ekr.20070127142814.646"><vh>get_window_info</vh></v>
<v t="ekr.20070127142814.647"><vh>printChangedVars</vh></v>
<v t="ekr.20070127142814.648"><vh>printWidgets</vh></v>
</v>
</v>
<v t="ekr.20070127142814.649"><vh>class settingsDialogParserClass (parserBaseClass)</vh>
<v t="ekr.20070127142814.650"><vh>ctor</vh></v>
<v t="ekr.20070127142814.651"><vh>set</vh></v>
<v t="ekr.20070127142814.652"><vh>visitNode</vh></v>
<v t="ekr.20070127142814.653"><vh>kind handlers</vh>
<v t="ekr.20070127142814.654"><vh>doFont</vh></v>
<v t="ekr.20070127142814.655"><vh>doPage</vh></v>
<v t="ekr.20070127142814.656"><vh>doRecentFiles &amp; doBodyPaneList</vh></v>
<v t="ekr.20070127142814.657"><vh>doShortcuts</vh></v>
</v>
</v>
<v t="ekr.20070127142814.658"><vh>class settingsTree (leoTkinterTree)</vh>
<v t="ekr.20070127142814.659"><vh>ctor</vh></v>
<v t="ekr.20070127142814.660"><vh>Selecting &amp; editing...</vh>
<v t="ekr.20070127142814.661"><vh>configureTextState</vh>
<v t="ekr.20070127142814.662"><vh>setSelectColors</vh></v>
<v t="ekr.20070127142814.663"><vh>setUnselectColors</vh></v>
</v>
<v t="ekr.20070127142814.664"><vh>endEditLabel</vh></v>
<v t="ekr.20070127142814.665"><vh>editLabel</vh></v>
<v t="ekr.20070127142814.666"><vh>tree.select</vh></v>
<v t="ekr.20070127142814.667"><vh>getTextWidget</vh></v>
</v>
<v t="ekr.20070127142814.668"><vh>Event handlers...</vh>
<v t="ekr.20070127142814.669"><vh>expandAllAncestors</vh></v>
<v t="ekr.20070127142814.670"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20070127142814.671"><vh>drawTopTree</vh></v>
</v>
<v t="ekr.20070127142814.672"><vh>class settingsTreeParser (parserBaseClass)</vh>
<v t="ekr.20070127142814.673"><vh>ctor</vh></v>
<v t="ekr.20070127142814.674"><vh>visitNode</vh></v>
</v>
</v>
<v t="ekr.20070127142814.693"><vh>@@thin leoSwingHTMLView.py</vh>
<v t="ekr.20070127142814.694"><vh>viewNodeAsHtml</vh></v>
</v>
<v t="ekr.20070127142814.695"><vh>@@thin leoSwingLeoTutorial.py</vh></v>
<v t="ekr.20070127142814.805"><vh>@@thin leoSwingPluginManager.py</vh>
<v t="ekr.20070127142814.806"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20070127142814.807"><vh>&lt;&lt; define importLeoGlobals &gt;&gt;</vh></v>
<v t="ekr.20070127142814.808"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070127142814.809"><vh>&lt;&lt; todo &gt;&gt;</vh></v>
<v t="ekr.20070127142814.810"><vh>init</vh></v>
<v t="ekr.20070127142814.811"><vh>topLevelMenu</vh></v>
<v t="ekr.20070127142814.812"><vh>createPluginMenu</vh></v>
<v t="ekr.20070127142814.813"><vh>Error Classes</vh></v>
<v t="ekr.20070127142814.814"><vh>inColumns</vh></v>
<v t="ekr.20070127142814.815"><vh>Standalone Operation (no longer used)</vh>
<v t="ekr.20070127142814.816"><vh>class NameSpace</vh>
<v t="ekr.20070127142814.817"><vh>__init__</vh></v>
</v>
<v t="ekr.20070127142814.818"><vh>class BlackHole</vh>
<v t="ekr.20070127142814.819"><vh>__getattr__</vh></v>
<v t="ekr.20070127142814.820"><vh>__call__</vh></v>
</v>
<v t="ekr.20070127142814.821"><vh>class FakeLeoGlobals</vh>
<v t="ekr.20070127142814.822"><vh>__init__</vh></v>
<v t="ekr.20070127142814.823"><vh>choose</vh></v>
</v>
</v>
<v t="ekr.20070127142814.824"><vh>UI</vh>
<v t="ekr.20070127142814.825"><vh>class PluginView</vh>
<v t="ekr.20070127142814.826"><vh>&lt;&lt; class PluginView declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.827"><vh>__init__</vh></v>
<v t="ekr.20070127142814.828"><vh>showPlugin</vh></v>
<v t="ekr.20070127142814.829"><vh>def getJList</vh></v>
<v t="ekr.20070127142814.830"><vh>component listener methods</vh></v>
<v t="ekr.20070127142814.831"><vh>class EntryField</vh></v>
</v>
<v t="ekr.20070127142814.832"><vh>class PluginList</vh>
<v t="ekr.20070127142814.833"><vh>&lt;&lt; class PluginList declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.834"><vh>__init__</vh></v>
<v t="ekr.20070127142814.835"><vh>syncSize</vh></v>
<v t="ekr.20070127142814.836"><vh>onClick</vh></v>
<v t="ekr.20070127142814.837"><vh>populateList</vh></v>
<v t="ekr.20070127142814.838"><vh>getSelectedPlugin</vh></v>
<v t="ekr.20070127142814.839"><vh>setSecondFilterList</vh></v>
<v t="ekr.20070127142814.840"><vh>class Populater</vh></v>
</v>
<v t="ekr.20070127142814.841"><vh>class LocalPluginList</vh>
<v t="ekr.20070127142814.842"><vh>&lt;&lt; class LocalPluginList declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.843"><vh>class RemotePluginList</vh>
<v t="ekr.20070127142814.844"><vh>&lt;&lt; class RemotePluginList declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.845"><vh>class ManagerDialog</vh>
<v t="ekr.20070127142814.846"><vh>&lt;&lt; class ManagerDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.847"><vh>__init__</vh></v>
<v t="ekr.20070127142814.848"><vh>enablePlugin</vh></v>
<v t="ekr.20070127142814.849"><vh>disablePlugin</vh></v>
<v t="ekr.20070127142814.850"><vh>initLocalCollection</vh></v>
<v t="ekr.20070127142814.851"><vh>checkUpdates</vh></v>
<v t="ekr.20070127142814.852"><vh>installPlugin</vh></v>
<v t="ekr.20070127142814.853"><vh>viewPlugin</vh></v>
<v t="ekr.20070127142814.854"><vh>checkConflicts</vh></v>
<v t="ekr.20070127142814.855"><vh>class ButtonBox</vh></v>
<v t="ekr.20070127142814.856"><vh>class MessageBar</vh></v>
</v>
<v t="ekr.20070127142814.857"><vh>class ListReportDialog</vh>
<v t="ekr.20070127142814.858"><vh>&lt;&lt; class ListReportDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.859"><vh>__init__</vh></v>
<v t="ekr.20070127142814.860"><vh>getFilterOptions</vh></v>
<v t="ekr.20070127142814.861"><vh>populateList</vh></v>
</v>
</v>
<v t="ekr.20070127142814.862"><vh>Implementation</vh>
<v t="ekr.20070127142814.863"><vh>class Plugin</vh>
<v t="ekr.20070127142814.864"><vh>__init__</vh></v>
<v t="ekr.20070127142814.865"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.866"><vh>Must be overridden in subclasses...</vh>
<v t="ekr.20070127142814.867"><vh>getName</vh></v>
<v t="ekr.20070127142814.868"><vh>getContents</vh></v>
</v>
<v t="ekr.20070127142814.869"><vh>getNiceName</vh></v>
<v t="ekr.20070127142814.870"><vh>getDetails</vh></v>
<v t="ekr.20070127142814.871"><vh>hasPattern</vh></v>
<v t="ekr.20070127142814.872"><vh>hasImport</vh></v>
<v t="ekr.20070127142814.873"><vh>getMatch (new)</vh></v>
<v t="ekr.20070127142814.874"><vh>getPattern</vh></v>
<v t="ekr.20070127142814.875"><vh>getPatterns</vh></v>
<v t="ekr.20070127142814.876"><vh>asString</vh></v>
<v t="ekr.20070127142814.877"><vh>writeTo</vh></v>
<v t="ekr.20070127142814.878"><vh>getVersionHistory</vh></v>
<v t="ekr.20070127142814.879"><vh>getRequiredModules</vh>
<v t="ekr.20070127142814.880"><vh>&lt;&lt; Check UI toolkits &gt;&gt;</vh></v>
<v t="ekr.20070127142814.881"><vh>&lt;&lt; Check other plugins &gt;&gt;</vh></v>
<v t="ekr.20070127142814.882"><vh>&lt;&lt; Directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.883"><vh>class LocalPlugin(Plugin)</vh>
<v t="ekr.20070127142814.884"><vh>getName</vh></v>
<v t="ekr.20070127142814.885"><vh>getContents</vh></v>
</v>
<v t="ekr.20070127142814.886"><vh>class CVSPlugin</vh>
<v t="ekr.20070127142814.887"><vh>getName</vh></v>
<v t="ekr.20070127142814.888"><vh>getContents</vh></v>
<v t="ekr.20070127142814.889"><vh>getViewFilename</vh></v>
</v>
<v t="ekr.20070127142814.890"><vh>class PluginCollection</vh>
<v t="ekr.20070127142814.891"><vh>__init__</vh></v>
<v t="ekr.20070127142814.892"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.893"><vh>getAllFiles</vh></v>
<v t="ekr.20070127142814.894"><vh>sortedNames</vh></v>
<v t="ekr.20070127142814.895"><vh>setEnabledStateFrom</vh></v>
<v t="ekr.20070127142814.896"><vh>enablePlugin</vh></v>
<v t="ekr.20070127142814.897"><vh>disablePlugin</vh></v>
<v t="ekr.20070127142814.898"><vh>getConflicts</vh></v>
<v t="ekr.20070127142814.899"><vh>getGroups</vh></v>
</v>
<v t="ekr.20070127142814.900"><vh>class LocalPluginCollection</vh>
<v t="ekr.20070127142814.901"><vh>getFilesMatching</vh></v>
<v t="ekr.20070127142814.902"><vh>getAllFiles</vh></v>
</v>
<v t="ekr.20070127142814.903"><vh>class CVSPluginCollection</vh>
<v t="ekr.20070127142814.904"><vh>getFilesMatching</vh></v>
<v t="ekr.20070127142814.905"><vh>getListingPage</vh></v>
<v t="ekr.20070127142814.906"><vh>setEnabledStateFrom</vh></v>
</v>
<v t="ekr.20070127142814.907"><vh>class EnableManager</vh>
<v t="ekr.20070127142814.908"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.909"><vh>writeFile</vh></v>
<v t="ekr.20070127142814.910"><vh>parseManagerText</vh></v>
<v t="ekr.20070127142814.911"><vh>updateState</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142814.696"><vh>@@thin leoSwingPluginManager2.py</vh>
<v t="ekr.20070127142814.697"><vh>&lt;&lt; plugin_manager declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.698"><vh>init</vh></v>
<v t="ekr.20070127142814.699"><vh>topLevelMenu</vh></v>
<v t="ekr.20070127142814.700"><vh>class InvalidPlugin</vh></v>
<v t="ekr.20070127142814.701"><vh>class InvalidCollection</vh></v>
<v t="ekr.20070127142814.702"><vh>class InvalidManager</vh>
<v t="ekr.20070127142814.703"><vh>&lt;&lt; class InvalidManager declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.704"><vh>inColumns</vh></v>
<v t="ekr.20070127142814.705"><vh>class NameSpace</vh>
<v t="ekr.20070127142814.706"><vh>&lt;&lt; class NameSpace declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.707"><vh>__init__</vh></v>
</v>
<v t="ekr.20070127142814.708"><vh>class BlackHole</vh>
<v t="ekr.20070127142814.709"><vh>&lt;&lt; class BlackHole declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.710"><vh>__getattr__</vh></v>
<v t="ekr.20070127142814.711"><vh>__call__</vh></v>
</v>
<v t="ekr.20070127142814.712"><vh>class FakeLeoGlobals</vh>
<v t="ekr.20070127142814.713"><vh>&lt;&lt; class FakeLeoGlobals declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.714"><vh>__init__</vh></v>
<v t="ekr.20070127142814.715"><vh>choose</vh></v>
</v>
<v t="ekr.20070127142814.716"><vh>class PluginView</vh>
<v t="ekr.20070127142814.717"><vh>&lt;&lt; class PluginView declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.718"><vh>__init__</vh></v>
<v t="ekr.20070127142814.719"><vh>showPlugin</vh></v>
<v t="ekr.20070127142814.720"><vh>def getJList</vh></v>
<v t="ekr.20070127142814.721"><vh>component listener methods</vh></v>
<v t="ekr.20070127142814.722"><vh>class EntryField</vh></v>
</v>
<v t="ekr.20070127142814.723"><vh>class PluginList</vh>
<v t="ekr.20070127142814.724"><vh>&lt;&lt; class PluginList declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.725"><vh>__init__</vh></v>
<v t="ekr.20070127142814.726"><vh>syncSize</vh></v>
<v t="ekr.20070127142814.727"><vh>onClick</vh></v>
<v t="ekr.20070127142814.728"><vh>populateList</vh></v>
<v t="ekr.20070127142814.729"><vh>getSelectedPlugin</vh></v>
<v t="ekr.20070127142814.730"><vh>setSecondFilterList</vh></v>
<v t="ekr.20070127142814.731"><vh>class Populater</vh></v>
</v>
<v t="ekr.20070127142814.732"><vh>class LocalPluginList</vh>
<v t="ekr.20070127142814.733"><vh>&lt;&lt; class LocalPluginList declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.734"><vh>class RemotePluginList</vh>
<v t="ekr.20070127142814.735"><vh>&lt;&lt; class RemotePluginList declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.736"><vh>class ManagerDialog</vh>
<v t="ekr.20070127142814.737"><vh>&lt;&lt; class ManagerDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.738"><vh>__init__</vh></v>
<v t="ekr.20070127142814.739"><vh>enablePlugin</vh></v>
<v t="ekr.20070127142814.740"><vh>disablePlugin</vh></v>
<v t="ekr.20070127142814.741"><vh>initLocalCollection</vh></v>
<v t="ekr.20070127142814.742"><vh>checkUpdates</vh></v>
<v t="ekr.20070127142814.743"><vh>installPlugin</vh></v>
<v t="ekr.20070127142814.744"><vh>viewPlugin</vh></v>
<v t="ekr.20070127142814.745"><vh>checkConflicts</vh></v>
<v t="ekr.20070127142814.746"><vh>class ButtonBox</vh></v>
<v t="ekr.20070127142814.747"><vh>class MessageBar</vh></v>
</v>
<v t="ekr.20070127142814.748"><vh>class ListReportDialog</vh>
<v t="ekr.20070127142814.749"><vh>&lt;&lt; class ListReportDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.750"><vh>__init__</vh></v>
<v t="ekr.20070127142814.751"><vh>getFilterOptions</vh></v>
<v t="ekr.20070127142814.752"><vh>populateList</vh></v>
</v>
<v t="ekr.20070127142814.753"><vh>class Plugin</vh>
<v t="ekr.20070127142814.754"><vh>&lt;&lt; class Plugin declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.755"><vh>__init__</vh></v>
<v t="ekr.20070127142814.756"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.757"><vh>getName</vh></v>
<v t="ekr.20070127142814.758"><vh>getContents</vh></v>
<v t="ekr.20070127142814.759"><vh>getNiceName</vh></v>
<v t="ekr.20070127142814.760"><vh>getDetails</vh></v>
<v t="ekr.20070127142814.761"><vh>hasPattern</vh></v>
<v t="ekr.20070127142814.762"><vh>hasImport</vh></v>
<v t="ekr.20070127142814.763"><vh>getMatch</vh></v>
<v t="ekr.20070127142814.764"><vh>getPattern</vh></v>
<v t="ekr.20070127142814.765"><vh>getPatterns</vh></v>
<v t="ekr.20070127142814.766"><vh>asString</vh></v>
<v t="ekr.20070127142814.767"><vh>writeTo</vh></v>
<v t="ekr.20070127142814.768"><vh>getVersionHistory</vh></v>
<v t="ekr.20070127142814.769"><vh>getRequiredModules</vh></v>
</v>
<v t="ekr.20070127142814.770"><vh>class LocalPlugin</vh>
<v t="ekr.20070127142814.771"><vh>&lt;&lt; class LocalPlugin declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.772"><vh>getName</vh></v>
<v t="ekr.20070127142814.773"><vh>getContents</vh></v>
</v>
<v t="ekr.20070127142814.774"><vh>class CVSPlugin</vh>
<v t="ekr.20070127142814.775"><vh>&lt;&lt; class CVSPlugin declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.776"><vh>getName</vh></v>
<v t="ekr.20070127142814.777"><vh>getContents</vh></v>
<v t="ekr.20070127142814.778"><vh>getViewFilename</vh></v>
</v>
<v t="ekr.20070127142814.779"><vh>class PluginCollection</vh>
<v t="ekr.20070127142814.780"><vh>&lt;&lt; class PluginCollection declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.781"><vh>__init__</vh></v>
<v t="ekr.20070127142814.782"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.783"><vh>getAllFiles</vh></v>
<v t="ekr.20070127142814.784"><vh>sortedNames</vh></v>
<v t="ekr.20070127142814.785"><vh>setEnabledStateFrom</vh></v>
<v t="ekr.20070127142814.786"><vh>enablePlugin</vh></v>
<v t="ekr.20070127142814.787"><vh>disablePlugin</vh></v>
<v t="ekr.20070127142814.788"><vh>getConflicts</vh></v>
<v t="ekr.20070127142814.789"><vh>getGroups</vh></v>
</v>
<v t="ekr.20070127142814.790"><vh>class LocalPluginCollection</vh>
<v t="ekr.20070127142814.791"><vh>&lt;&lt; class LocalPluginCollection declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.792"><vh>getFilesMatching</vh></v>
<v t="ekr.20070127142814.793"><vh>getAllFiles</vh></v>
</v>
<v t="ekr.20070127142814.794"><vh>class CVSPluginCollection</vh>
<v t="ekr.20070127142814.795"><vh>&lt;&lt; class CVSPluginCollection declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.796"><vh>getFilesMatching</vh></v>
<v t="ekr.20070127142814.797"><vh>getListingPage</vh></v>
<v t="ekr.20070127142814.798"><vh>setEnabledStateFrom</vh></v>
</v>
<v t="ekr.20070127142814.799"><vh>class EnableManager</vh>
<v t="ekr.20070127142814.800"><vh>&lt;&lt; class EnableManager declarations &gt;&gt;</vh></v>
<v t="ekr.20070127142814.801"><vh>initFrom</vh></v>
<v t="ekr.20070127142814.802"><vh>writeFile</vh></v>
<v t="ekr.20070127142814.803"><vh>parseManagerText</vh></v>
<v t="ekr.20070127142814.804"><vh>updateState</vh></v>
</v>
</v>
<v t="ekr.20070127142814.677"><vh>@@thin leoSwingPrint.py</vh>
<v t="ekr.20070127142814.678"><vh>&lt;&lt;JFreeReportClassLoader&gt;&gt;</vh></v>
<v t="ekr.20070127142814.679"><vh>__init__</vh></v>
<v t="ekr.20070127142814.680"><vh>getAsMenu</vh></v>
<v t="ekr.20070127142814.681"><vh>printers</vh>
<v t="ekr.20070127142814.682"><vh>printMarkedNodes</vh></v>
<v t="ekr.20070127142814.683"><vh>printNode</vh></v>
<v t="ekr.20070127142814.684"><vh>printTreeAsIs</vh></v>
<v t="ekr.20070127142814.685"><vh>printOutlineAsMore</vh></v>
</v>
<v t="ekr.20070127142814.686"><vh>senders</vh>
<v t="ekr.20070127142814.687"><vh>sendStringToJFreeReport</vh></v>
<v t="ekr.20070127142814.688"><vh>sendStringToPrinter</vh></v>
<v t="ekr.20070127142814.689"><vh>sendByteArrayToPrinter</vh></v>
</v>
<v t="ekr.20070127142814.690"><vh>class PrintJobReporter</vh></v>
<v t="ekr.20070127142814.691"><vh>class LeoPageable</vh></v>
<v t="ekr.20070127142814.692"><vh>a simple test</vh></v>
</v>
<v t="ekr.20070127142814.426"><vh>@@thin leoSwingUndo.py</vh>
<v t="ekr.20070127142814.427"><vh>&lt;&lt;UndoBase&gt;&gt;</vh></v>
<v t="ekr.20070127142814.428"><vh>clearUndoState</vh></v>
<v t="ekr.20070127142814.429"><vh>setUndoParams</vh></v>
<v t="ekr.20070127142814.430"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20070127142814.431"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20070127142814.432"><vh>createCommonBunch</vh></v>
<v t="ekr.20070127142814.433"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20070127142814.434"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20070127142814.435"><vh>pickling</vh>
<v t="ekr.20070127142814.436"><vh>def serializeForLeoFile</vh></v>
<v t="ekr.20070127142814.437"><vh>def unserializeFromLeoFile</vh></v>
</v>
<v t="ekr.20070127142814.438"><vh>compounding</vh></v>
<v t="ekr.20070127142814.439"><vh>checkSumViolation</vh></v>
<v t="ekr.20070127142814.440"><vh>&lt;&lt;Undoable classes&gt;&gt;</vh>
<v t="ekr.20070127142814.441"><vh>UndoableEditDecorator</vh></v>
<v t="ekr.20070127142814.442"><vh>UndoableDocumentEvent</vh></v>
<v t="ekr.20070127142814.443"><vh>UndoableMoveTree</vh>
<v t="ekr.20070127142814.444"><vh>undoMoveNode</vh></v>
<v t="ekr.20070127142814.445"><vh>redoMoveNode</vh></v>
</v>
<v t="ekr.20070127142814.446"><vh>UndoableInsertNode</vh>
<v t="ekr.20070127142814.447"><vh>undoInsertNodes</vh></v>
<v t="ekr.20070127142814.448"><vh>redoInsertNodes</vh></v>
</v>
<v t="ekr.20070127142814.449"><vh>UndoableDeleteNode</vh>
<v t="ekr.20070127142814.450"><vh>redoDeleteNode</vh></v>
<v t="ekr.20070127142814.451"><vh>undoDeleteNode</vh></v>
</v>
<v t="ekr.20070127142814.452"><vh>UndoableDemote</vh>
<v t="ekr.20070127142814.453"><vh>redoDemote</vh></v>
<v t="ekr.20070127142814.454"><vh>undoDemote</vh></v>
</v>
<v t="ekr.20070127142814.455"><vh>UndoablePromote</vh>
<v t="ekr.20070127142814.456"><vh>redoPromote</vh></v>
<v t="ekr.20070127142814.457"><vh>undoPromote</vh></v>
</v>
<v t="ekr.20070127142814.458"><vh>UndoableHoist</vh>
<v t="ekr.20070127142814.459"><vh>redoHoist</vh></v>
<v t="ekr.20070127142814.460"><vh>undoHoist</vh></v>
</v>
<v t="ekr.20070127142814.461"><vh>UndoableDeHoist</vh>
<v t="ekr.20070127142814.462"><vh>redoDehoist</vh></v>
<v t="ekr.20070127142814.463"><vh>undoDehoist</vh></v>
</v>
<v t="ekr.20070127142814.464"><vh>UndoableClone</vh>
<v t="ekr.20070127142814.465"><vh>undoClone</vh></v>
<v t="ekr.20070127142814.466"><vh>redoClone</vh></v>
</v>
<v t="ekr.20070127142814.467"><vh>UndoableSortChildren</vh>
<v t="ekr.20070127142814.468"><vh>undoSortChildren</vh></v>
<v t="ekr.20070127142814.469"><vh>redoSortChildren</vh></v>
</v>
<v t="ekr.20070127142814.470"><vh>UndoableSortSiblings</vh>
<v t="ekr.20070127142814.471"><vh>undoSortSiblings</vh></v>
<v t="ekr.20070127142814.472"><vh>redoSortSiblings</vh></v>
</v>
<v t="ekr.20070127142814.473"><vh>UndoableSortTopLevel</vh>
<v t="ekr.20070127142814.474"><vh>undoSortTopLevel</vh></v>
<v t="ekr.20070127142814.475"><vh>redoSortTopLevel</vh></v>
</v>
<v t="ekr.20070127142814.476"><vh>UndoableChangeHeadline</vh>
<v t="ekr.20070127142814.477"><vh>undoChangeHeadline</vh></v>
<v t="ekr.20070127142814.478"><vh>redoChangeHeadline</vh></v>
</v>
<v t="ekr.20070127142814.479"><vh>UndoableDocumentEvent</vh></v>
<v t="ekr.20070127142814.480"><vh>UndoableCompoundEvent</vh></v>
</v>
<v t="ekr.20070127142814.481"><vh>&lt;&lt;NodeUndoer&gt;&gt;</vh>
<v t="ekr.20070127142814.482"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="ekr.20070127142814.483"><vh>visualiseUndoStack</vh>
<v t="ekr.20070127142814.484"><vh>&lt;&lt;_undoTo&gt;&gt;</vh></v>
<v t="ekr.20070127142814.485"><vh>&lt;&lt;_redoTo&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.486"><vh>buildTableData</vh></v>
<v t="ekr.20070127142814.487"><vh>setDataForTable</vh></v>
<v t="ekr.20070127142814.488"><vh>pickle and unpickle</vh></v>
<v t="ekr.20070127142814.489"><vh>checkSumViolation</vh></v>
<v t="ekr.20070127142814.490"><vh>startCompounding stopCompounding</vh></v>
<v t="ekr.20070127142814.491"><vh>infrastructure</vh>
<v t="ekr.20070127142814.492"><vh>UneditableTableModel</vh></v>
<v t="ekr.20070127142814.493"><vh>PickleProxy</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142814.378"><vh>@@thin NodeUndoer.py</vh>
<v t="ekr.20070127142814.379"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
<v t="ekr.20070127142814.380"><vh>visualiseUndoStack</vh>
<v t="ekr.20070127142814.381"><vh>&lt;&lt;_undoTo&gt;&gt;</vh></v>
<v t="ekr.20070127142814.382"><vh>&lt;&lt;_redoTo&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.383"><vh>buildTableData</vh></v>
<v t="ekr.20070127142814.384"><vh>setDataForTable</vh></v>
<v t="ekr.20070127142814.385"><vh>pickle and unpickle</vh></v>
<v t="ekr.20070127142814.386"><vh>checkSumViolation</vh></v>
<v t="ekr.20070127142814.387"><vh>startCompounding stopCompounding</vh></v>
<v t="ekr.20070127142814.388"><vh>infrastructure</vh>
<v t="ekr.20070127142814.389"><vh>UneditableTableModel</vh></v>
<v t="ekr.20070127142814.390"><vh>PickleProxy</vh></v>
</v>
<v t="ekr.20070127142814.391"><vh>UndoableProxyEvent</vh></v>
<v t="ekr.20070127142814.392"><vh>&lt;&lt;UndoableDocumentEvent&gt;&gt;</vh></v>
<v t="ekr.20070127142814.393"><vh>&lt;&lt;UndoableCompoundEvent&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.912"><vh>@@thin plugins_menu.py</vh>
<v t="ekr.20070127142814.913"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20070127142814.914"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070127142814.915"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20070127142814.916"><vh>class PluginDatabase</vh>
<v t="ekr.20070127142814.917"><vh>__init__</vh></v>
<v t="ekr.20070127142814.918"><vh>addPlugin</vh></v>
<v t="ekr.20070127142814.919"><vh>getGroups</vh></v>
<v t="ekr.20070127142814.920"><vh>setMenu</vh></v>
<v t="ekr.20070127142814.921"><vh>getMenu</vh></v>
</v>
<v t="ekr.20070127142814.922"><vh>class Plugin</vh>
<v t="ekr.20070127142814.923"><vh>__init__</vh>
<v t="ekr.20070127142814.924"><vh>&lt;&lt; Check if this can be configured &gt;&gt;</vh></v>
<v t="ekr.20070127142814.925"><vh>&lt;&lt; Check if this has an apply &gt;&gt;</vh></v>
<v t="ekr.20070127142814.926"><vh>&lt;&lt; Look for additional commands &gt;&gt;</vh></v>
<v t="ekr.20070127142814.927"><vh>&lt;&lt; Look for toplevel menu item &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.928"><vh>about</vh></v>
<v t="ekr.20070127142814.929"><vh>getNiceName</vh></v>
<v t="ekr.20070127142814.930"><vh>properties</vh></v>
</v>
<v t="ekr.20070127142814.931"><vh>class PropertiesWindow</vh>
<v t="ekr.20070127142814.932"><vh>__init__</vh>
<v t="ekr.20070127142814.933"><vh>&lt;&lt; initialize all ivars &gt;&gt;</vh></v>
<v t="ekr.20070127142814.934"><vh>&lt;&lt; create the frame from the configuration data &gt;&gt;</vh>
<v t="ekr.20070127142814.935"><vh>&lt;&lt; Create the top level and the main frame &gt;&gt;</vh></v>
<v t="ekr.20070127142814.936"><vh>&lt;&lt; Create widgets for each section and option &gt;&gt;</vh></v>
<v t="ekr.20070127142814.937"><vh>&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.938"><vh>Event Handlers</vh></v>
<v t="ekr.20070127142814.939"><vh>writeConfiguration</vh></v>
</v>
<v t="ekr.20070127142814.940"><vh>class PluginAbout</vh>
<v t="ekr.20070127142814.941"><vh>__init__</vh>
<v t="ekr.20070127142814.942"><vh>&lt;&lt; Create the contents of the about box &gt;&gt;</vh></v>
<v t="ekr.20070127142814.943"><vh>&lt;&lt; Create the close button &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070127142814.944"><vh>createPluginsMenu</vh>
<v t="ekr.20070127142814.945"><vh>&lt;&lt; sort items &gt;&gt;</vh></v>
<v t="ekr.20070127142814.946"><vh>&lt;&lt; Add group menus &gt;&gt;</vh></v>
<v t="ekr.20070127142814.947"><vh>&lt;&lt; add items to the plugins menu &gt;&gt;</vh>
<v t="ekr.20070127142814.948"><vh>&lt;&lt; Get menu location &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142814.1029"><vh>@@thin RotatableJLabel.py</vh></v>
<v t="ekr.20070127142814.1234"><vh>@@thin SwingMacs.py</vh>
<v t="ekr.20070127142814.1235"><vh>&lt;&lt; addCommand &gt;&gt;</vh></v>
<v t="ekr.20070127142814.1236"><vh>What is SwingMacs?</vh></v>
<v t="ekr.20070127142814.1237"><vh>symtable</vh></v>
<v t="ekr.20070127142814.1238"><vh>constructor: __init__</vh></v>
<v t="ekr.20070127142814.1239"><vh>management listening</vh>
<v t="ekr.20070127142814.1240"><vh>addCompleters</vh></v>
<v t="ekr.20070127142814.1241"><vh>managementListener</vh></v>
</v>
<v t="ekr.20070127142814.1242"><vh>lookForExtensions</vh></v>
<v t="ekr.20070127142814.1243"><vh>addCompleter</vh></v>
<v t="ekr.20070127142814.1244"><vh>How to write an extension( alpha doc level )</vh></v>
<v t="ekr.20070127142814.1245"><vh>helper classes</vh>
<v t="ekr.20070127142814.1246"><vh>stateManager</vh></v>
<v t="ekr.20070127142814.1247"><vh>KeyProcessor  -- KeyListener calls and newline analyzer</vh>
<v t="ekr.20070127142814.1248"><vh>__init__</vh></v>
<v t="ekr.20070127142814.1249"><vh>addCompleter</vh></v>
<v t="ekr.20070127142814.1250"><vh>removeCompleter</vh></v>
<v t="ekr.20070127142814.1251"><vh>keyReleased</vh></v>
<v t="ekr.20070127142814.1252"><vh>keyTyped</vh></v>
<v t="ekr.20070127142814.1253"><vh>keyPressed</vh>
<v t="ekr.20070127142814.1254"><vh>&lt;&lt;attempt block movement&gt;&gt;</vh>
<v t="ekr.20070127142814.1255"><vh>&lt;&lt;numpad -&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1256"><vh>&lt;&lt;numpad +&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1257"><vh>&lt;&lt;tab consumption&gt;&gt;</vh></v>
<v t="ekr.20070127142814.1258"><vh>&lt;&lt;attempt node movement&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1259"><vh>newNodeSelected</vh></v>
<v t="ekr.20070127142814.1260"><vh>insertPreviousLeadAndNewline -- for autoindentation on newline</vh>
<v t="ekr.20070127142814.1261"><vh>&lt;&lt; why is this code here? &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1262"><vh>calculateExtraSpaces</vh></v>
<v t="ekr.20070127142814.1263"><vh>swaplines</vh></v>
<v t="ekr.20070127142814.1264"><vh>mungeModifiers</vh></v>
</v>
<v t="ekr.20070127142814.1265"><vh>TagMatcher -- matches html/xml style tags</vh></v>
<v t="ekr.20070127142814.1266"><vh>TabCompleter</vh></v>
</v>
<v t="ekr.20070127142814.1267"><vh>defineStrategyObjects</vh></v>
<v t="ekr.20070127142814.1268"><vh>defineStrategiesForKeystrokes</vh></v>
<v t="ekr.20070127142814.1269"><vh>forwarding methods</vh>
<v t="ekr.20070127142814.1270"><vh>startCompounding stopCompounding</vh></v>
</v>
<v t="ekr.20070127142814.1271"><vh>addCommands</vh></v>
<v t="ekr.20070127142814.1272"><vh>masterCommand -- all processing goes through here</vh></v>
<v t="ekr.20070127142814.1273"><vh>setCommandText</vh></v>
<v t="ekr.20070127142814.1274"><vh>help</vh></v>
<v t="ekr.20070127142814.1275"><vh>help2</vh></v>
<v t="ekr.20070127142814.1276"><vh>add*Help</vh></v>
<v t="ekr.20070127142814.1277"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1278"><vh>beep</vh></v>
<v t="ekr.20070127142814.1279"><vh>determineLanguage</vh></v>
<v t="ekr.20070127142814.1280"><vh>getTabWidth</vh></v>
<v t="ekr.20070127142814.1281"><vh>eventToMinibuffer</vh></v>
<v t="ekr.20070127142814.1282"><vh>text operations</vh></v>
<v t="ekr.20070127142814.1283"><vh>word operations</vh></v>
<v t="ekr.20070127142814.1284"><vh>line operations</vh></v>
<v t="ekr.20070127142814.1285"><vh>findPre</vh></v>
<v t="ekr.20070127142814.1286"><vh>attribute and highlight operations, position operations</vh></v>
<v t="ekr.20070127142814.1287"><vh>addToKillBuffer</vh></v>
<v t="ekr.20070127142814.1288"><vh>junk</vh></v>
<v t="ekr.20070127142814.1289"><vh>getKeyStrokesForCommands</vh></v>
<v t="ekr.20070127142814.1290"><vh>configureStrategyWithKeystrokes</vh></v>
<v t="ekr.20070127142814.1291"><vh>keystroke and command Strategies</vh>
<v t="ekr.20070127142814.1292"><vh>scrolling</vh>
<v t="ekr.20070127142814.1293"><vh>scrollTree</vh></v>
<v t="ekr.20070127142814.1294"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1295"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1296"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1297"><vh>apropos</vh>
<v t="ekr.20070127142814.1298"><vh>startApropos</vh></v>
<v t="ekr.20070127142814.1299"><vh>searchForApropos</vh></v>
<v t="ekr.20070127142814.1300"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1301"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1302"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1303"><vh>editors</vh>
<v t="ekr.20070127142814.1304"><vh>switchEditor</vh></v>
<v t="ekr.20070127142814.1305"><vh>information</vh></v>
<v t="ekr.20070127142814.1306"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1307"><vh>getAltXCommands getKeystrokes</vh></v>
</v>
<v t="ekr.20070127142814.1308"><vh>incremental search</vh>
<v t="ekr.20070127142814.1309"><vh>startIncremental</vh></v>
<v t="ekr.20070127142814.1310"><vh>isForward isBackward</vh></v>
<v t="ekr.20070127142814.1311"><vh>incrementalSearch</vh></v>
<v t="ekr.20070127142814.1312"><vh>forward and backward search</vh></v>
<v t="ekr.20070127142814.1313"><vh>class deferedHighlight</vh></v>
<v t="ekr.20070127142814.1314"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1315"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1316"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1317"><vh>dynamic-abbrevs</vh>
<v t="ekr.20070127142814.1318"><vh>dynamicExpansion</vh></v>
<v t="ekr.20070127142814.1319"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20070127142814.1320"><vh>tab</vh></v>
<v t="ekr.20070127142814.1321"><vh>getDynamicList</vh></v>
<v t="ekr.20070127142814.1322"><vh>getTabList</vh></v>
<v t="ekr.20070127142814.1323"><vh>addToDynamicList</vh></v>
<v t="ekr.20070127142814.1324"><vh>clearDynamic</vh></v>
<v t="ekr.20070127142814.1325"><vh>createDynamicList</vh></v>
<v t="ekr.20070127142814.1326"><vh>valueChanged</vh></v>
<v t="ekr.20070127142814.1327"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1328"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1329"><vh>getInformation</vh></v>
</v>
<v t="ekr.20070127142814.1330"><vh>formatter</vh>
<v t="ekr.20070127142814.1331"><vh>indent-region</vh></v>
<v t="ekr.20070127142814.1332"><vh>indent-rigidly</vh></v>
<v t="ekr.20070127142814.1333"><vh>indent-relative</vh></v>
<v t="ekr.20070127142814.1334"><vh>deleteSurroundingSpaces</vh></v>
<v t="ekr.20070127142814.1335"><vh>joinLineToPrevious</vh></v>
<v t="ekr.20070127142814.1336"><vh>deleteBlankLines</vh></v>
<v t="ekr.20070127142814.1337"><vh>definePreviousLine</vh></v>
<v t="ekr.20070127142814.1338"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1339"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1340"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1341"><vh>killbuffer</vh>
<v t="ekr.20070127142814.1342"><vh>kill</vh></v>
<v t="ekr.20070127142814.1343"><vh>insertIntoKillbuffer</vh></v>
<v t="ekr.20070127142814.1344"><vh>killToEndOfLine</vh></v>
<v t="ekr.20070127142814.1345"><vh>copyRegion</vh></v>
<v t="ekr.20070127142814.1346"><vh>killRegion</vh></v>
<v t="ekr.20070127142814.1347"><vh>getRegion</vh></v>
<v t="ekr.20070127142814.1348"><vh>walkKB</vh></v>
<v t="ekr.20070127142814.1349"><vh>yank</vh></v>
<v t="ekr.20070127142814.1350"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20070127142814.1351"><vh>doesClipboardOfferNewData</vh></v>
<v t="ekr.20070127142814.1352"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1353"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1354"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1355"><vh>deleter</vh>
<v t="ekr.20070127142814.1356"><vh>deletePreviousChar</vh></v>
<v t="ekr.20070127142814.1357"><vh>deleteNextChar</vh></v>
<v t="ekr.20070127142814.1358"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1359"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1360"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1361"><vh>alt_x_handler</vh>
<v t="ekr.20070127142814.1362"><vh>createViewer</vh></v>
<v t="ekr.20070127142814.1363"><vh>getCommandHelp</vh></v>
<v t="ekr.20070127142814.1364"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1365"><vh>matchCommandWithRegex</vh></v>
<v t="ekr.20070127142814.1366"><vh>keyboardQuit</vh></v>
</v>
<v t="ekr.20070127142814.1367"><vh>ctrl_x_handler</vh>
<v t="ekr.20070127142814.1368"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1369"><vh>keyboardQuit</vh></v>
</v>
<v t="ekr.20070127142814.1370"><vh>ctrl_u handler</vh>
<v t="ekr.20070127142814.1371"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1372"><vh>keyboardQuit</vh></v>
</v>
<v t="ekr.20070127142814.1373"><vh>rectangles</vh>
<v t="ekr.20070127142814.1374"><vh>definePoints</vh></v>
<v t="ekr.20070127142814.1375"><vh>insertText</vh></v>
<v t="ekr.20070127142814.1376"><vh>open-rectangle</vh></v>
<v t="ekr.20070127142814.1377"><vh>clear-rectangle</vh></v>
<v t="ekr.20070127142814.1378"><vh>kill-rectangle</vh></v>
<v t="ekr.20070127142814.1379"><vh>yank-rectangle</vh></v>
<v t="ekr.20070127142814.1380"><vh>delete-rectangle</vh></v>
<v t="ekr.20070127142814.1381"><vh>delete-whitespace-rectangle</vh></v>
<v t="ekr.20070127142814.1382"><vh>string-rectangle</vh></v>
<v t="ekr.20070127142814.1383"><vh>string-insert-rectangle</vh></v>
<v t="ekr.20070127142814.1384"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1385"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1386"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1387"><vh>zap</vh>
<v t="ekr.20070127142814.1388"><vh>zap</vh></v>
<v t="ekr.20070127142814.1389"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1390"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1391"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1392"><vh>comment</vh>
<v t="ekr.20070127142814.1393"><vh>comment-region</vh></v>
<v t="ekr.20070127142814.1394"><vh>comment-kill</vh></v>
<v t="ekr.20070127142814.1395"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1396"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1397"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1398"><vh>movement</vh>
<v t="ekr.20070127142814.1399"><vh>beginning-of-buffer</vh></v>
<v t="ekr.20070127142814.1400"><vh>end-of-buffer</vh></v>
<v t="ekr.20070127142814.1401"><vh>beginning-of-line</vh></v>
<v t="ekr.20070127142814.1402"><vh>end-of-line</vh></v>
<v t="ekr.20070127142814.1403"><vh>goto</vh></v>
<v t="ekr.20070127142814.1404"><vh>gotoChar</vh></v>
<v t="ekr.20070127142814.1405"><vh>startOfWord</vh></v>
<v t="ekr.20070127142814.1406"><vh>endOfWord</vh></v>
<v t="ekr.20070127142814.1407"><vh>beginning of indentation</vh></v>
<v t="ekr.20070127142814.1408"><vh>isWord</vh></v>
<v t="ekr.20070127142814.1409"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1410"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1411"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1412"><vh>balanced parenthesis or sexp</vh>
<v t="ekr.20070127142814.1413"><vh>killSexpForward and Backward</vh></v>
<v t="ekr.20070127142814.1414"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1415"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1416"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1417"><vh>tags</vh>
<v t="ekr.20070127142814.1418"><vh>__defineLanguageRecognizers</vh></v>
<v t="ekr.20070127142814.1419"><vh>gotoTag</vh></v>
<v t="ekr.20070127142814.1420"><vh>alternativeDefinition</vh></v>
<v t="ekr.20070127142814.1421"><vh>popBack</vh></v>
<v t="ekr.20070127142814.1422"><vh>defineTagsTable</vh></v>
<v t="ekr.20070127142814.1423"><vh>scanForTags</vh>
<v t="ekr.20070127142814.1424"><vh>&lt;&lt;java&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1425"><vh>valueChanged</vh></v>
<v t="ekr.20070127142814.1426"><vh>run</vh></v>
<v t="ekr.20070127142814.1427"><vh>class DeferedGotoLine</vh></v>
<v t="ekr.20070127142814.1428"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1429"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1430"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1431"><vh>transpose</vh>
<v t="ekr.20070127142814.1432"><vh>transpose-lines</vh></v>
<v t="ekr.20070127142814.1433"><vh>reverse-region</vh></v>
<v t="ekr.20070127142814.1434"><vh>transpose-words</vh></v>
<v t="ekr.20070127142814.1435"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1436"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1437"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1438"><vh>capitalization</vh>
<v t="ekr.20070127142814.1439"><vh>capitalize-region</vh></v>
<v t="ekr.20070127142814.1440"><vh>upcase-region</vh></v>
<v t="ekr.20070127142814.1441"><vh>downcase-region</vh></v>
<v t="ekr.20070127142814.1442"><vh>capitalize-word</vh></v>
<v t="ekr.20070127142814.1443"><vh>upcase-word</vh></v>
<v t="ekr.20070127142814.1444"><vh>downcase-word</vh></v>
<v t="ekr.20070127142814.1445"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1446"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1447"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1448"><vh>replacement</vh>
<v t="ekr.20070127142814.1449"><vh>query-replace</vh></v>
<v t="ekr.20070127142814.1450"><vh>query-replace-regexp</vh></v>
<v t="ekr.20070127142814.1451"><vh>replace-string</vh></v>
<v t="ekr.20070127142814.1452"><vh>doReplacement</vh></v>
<v t="ekr.20070127142814.1453"><vh>replaceAll</vh></v>
<v t="ekr.20070127142814.1454"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1455"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1456"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1457"><vh>sorters</vh>
<v t="ekr.20070127142814.1458"><vh>sort-lines</vh></v>
<v t="ekr.20070127142814.1459"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1460"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1461"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1462"><vh>lines</vh>
<v t="ekr.20070127142814.1463"><vh>keep-lines</vh></v>
<v t="ekr.20070127142814.1464"><vh>flush-lines</vh></v>
<v t="ekr.20070127142814.1465"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1466"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1467"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1468"><vh>tabs</vh>
<v t="ekr.20070127142814.1469"><vh>tabify</vh></v>
<v t="ekr.20070127142814.1470"><vh>untabify</vh></v>
<v t="ekr.20070127142814.1471"><vh>getCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1472"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1473"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1474"><vh>registers</vh>
<v t="ekr.20070127142814.1475"><vh>copy-to-register</vh></v>
<v t="ekr.20070127142814.1476"><vh>insert-register</vh></v>
<v t="ekr.20070127142814.1477"><vh>append-to-register</vh></v>
<v t="ekr.20070127142814.1478"><vh>prepend-to-register</vh></v>
<v t="ekr.20070127142814.1479"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1480"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1481"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1482"><vh>selection</vh>
<v t="ekr.20070127142814.1483"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1484"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1485"><vh>information</vh></v>
</v>
<v t="ekr.20070127142814.1486"><vh>quoters</vh>
<v t="ekr.20070127142814.1487"><vh>quote</vh></v>
<v t="ekr.20070127142814.1488"><vh>getAltXCommands getKeystrokes</vh></v>
<v t="ekr.20070127142814.1489"><vh>keyboardQuit</vh></v>
<v t="ekr.20070127142814.1490"><vh>information</vh></v>
</v>
</v>
<v t="ekr.20070127142814.1491"><vh>other editor emulators</vh>
<v t="ekr.20070127142814.1492"><vh>vi_emulation</vh>
<v t="ekr.20070127142814.1493"><vh>&lt;&lt;define vi keystrokes&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142814.1494"><vh>cut</vh></v>
<v t="ekr.20070127142814.1495"><vh>deleteLine</vh></v>
<v t="ekr.20070127142814.1496"><vh>insert</vh></v>
</v>
</v>
</v>
<v t="ekr.20070930212003.1"><vh>xml files</vh>
<v t="ekr.20070127142814.1623"><vh>@@file-nosent FieryLeo.xml</vh></v>
<v t="ekr.20070127142814.1622"><vh>@@file-nosent leosynth.xml</vh></v>
<v t="ekr.20070127142814.1626"><vh>@@file-nosent asynth.xml</vh></v>
<v t="ekr.20070127142814.1624"><vh>@@file-nosent leosynth2.xml</vh></v>
<v t="ekr.20070127142814.1627"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20070127142814.1041"><vh>@@file-nosent jyleo.py</vh></v>
<v t="ekr.20070127142841.25" a="TV"><vh>@@thin swingGui.py</vh>
<v t="ekr.20070127142841.26"><vh>&lt;&lt; imports &gt;&gt;</vh>
<v t="ekr.20070127142841.27"><vh>imports from leoSwingFrame</vh></v>
<v t="ekr.20070127142841.28"><vh>imports from leoSwingGui (all comments)</vh></v>
<v t="ekr.20070127142841.29"><vh>imports from leoSwingFrame</vh></v>
<v t="ekr.20070127142841.30"><vh>imports from leoSwingMenu (all comments)</vh></v>
</v>
<v t="ekr.20070127142841.31"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20070127142841.32"><vh> init</vh></v>
<v t="ekr.20070127142841.33"><vh>class leoSplash (java.lang.Runnable)</vh></v>
<v t="ekr.20070127142841.34"><vh>class leoSwingBody</vh>
<v t="ekr.20070127142841.35"><vh>leoSwingBody.__init__</vh></v>
<v t="ekr.20070127142841.36"><vh>oops</vh></v>
<v t="ekr.20070127142841.37"><vh>leoBody.setFontFromConfig</vh></v>
<v t="ekr.20070127142841.38"><vh>DocumentListenr</vh></v>
<v t="ekr.20070127142841.39"><vh>Must be overriden in subclasses</vh>
<v t="ekr.20070127142841.40"><vh>Bounding box (Tk spelling)</vh></v>
<v t="ekr.20070127142841.41"><vh>Color tags (Tk spelling)</vh></v>
<v t="ekr.20070127142841.42"><vh>Configuration (Tk spelling)</vh></v>
<v t="ekr.20070127142841.43"><vh>Focus</vh></v>
<v t="ekr.20070127142841.44"><vh>Height &amp; width</vh></v>
<v t="ekr.20070127142841.45"><vh>Idle time...</vh></v>
<v t="ekr.20070127142841.46"><vh>Indices</vh></v>
<v t="ekr.20070127142841.47"><vh>Insert point</vh></v>
<v t="ekr.20070127142841.48"><vh>Menus</vh></v>
<v t="ekr.20070127142841.49"><vh>Selection</vh></v>
<v t="ekr.20070127142841.50"><vh>Text</vh>
<v t="ekr.20070127142841.51"><vh>delete...</vh></v>
<v t="ekr.20070127142841.52"><vh>get...</vh></v>
<v t="ekr.20070127142841.53"><vh>Insert...</vh></v>
<v t="ekr.20070127142841.54"><vh>setSelectionAreas</vh></v>
</v>
<v t="ekr.20070127142841.55"><vh>Visibility &amp; scrolling</vh></v>
</v>
<v t="ekr.20070127142841.56"><vh>Coloring</vh></v>
<v t="ekr.20070127142841.57"><vh>class Editor</vh>
<v t="ekr.20070127142841.58"><vh>class insTx</vh></v>
<v t="ekr.20070127142841.59"><vh>colorizer callback</vh>
<v t="ekr.20070127142841.60"><vh>getLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.61"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20070127142841.62"><vh>Note on Editor design</vh></v>
<v t="ekr.20070127142841.63"><vh>__init__</vh>
<v t="ekr.20070127142841.64"><vh>&lt;&lt; add EditorKit &gt;&gt;</vh></v>
<v t="ekr.20070127142841.65"><vh>&lt;&lt; add autocompleter &gt;&gt;</vh></v>
<v t="ekr.20070127142841.66"><vh>&lt;&lt; add scrollpane &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.67"><vh>helper methods and classes</vh>
<v t="ekr.20070127142841.68"><vh>constuctor methods</vh>
<v t="ekr.20070127142841.69"><vh>addMenus</vh></v>
<v t="ekr.20070127142841.70"><vh>addMinibuffer</vh></v>
<v t="ekr.20070127142841.71"><vh>addCompleters</vh></v>
<v t="ekr.20070127142841.72"><vh>initializeEditor</vh></v>
<v t="ekr.20070127142841.73"><vh>initializeEditorColors</vh></v>
<v t="ekr.20070127142841.74"><vh>initializeFont</vh></v>
<v t="ekr.20070127142841.75"><vh>initializeCaret</vh></v>
<v t="ekr.20070127142841.76"><vh>initializeLineNumbering</vh></v>
<v t="ekr.20070127142841.77"><vh>createCommanderCommander</vh></v>
</v>
<v t="ekr.20070127142841.78"><vh>config methods</vh>
<v t="ekr.20070127142841.79"><vh>configureMedia</vh></v>
<v t="ekr.20070127142841.80"><vh>setBackgroundImage</vh></v>
<v t="ekr.20070127142841.81"><vh>useAutocompleter</vh></v>
<v t="ekr.20070127142841.82"><vh>setCaret</vh></v>
<v t="ekr.20070127142841.83"><vh>setFont</vh></v>
<v t="ekr.20070127142841.84"><vh>setEditorColors</vh></v>
<v t="ekr.20070127142841.85"><vh>setLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.86"><vh>methods</vh>
<v t="ekr.20070127142841.87"><vh>sync</vh></v>
<v t="ekr.20070127142841.88"><vh>nowShowing</vh></v>
<v t="ekr.20070127142841.89"><vh>menu methods</vh>
<v t="ekr.20070127142841.90"><vh>configureGotoMenu</vh></v>
<v t="ekr.20070127142841.91"><vh>directiveMenu</vh></v>
<v t="ekr.20070127142841.92"><vh>headlineMenu</vh></v>
<v t="ekr.20070127142841.93"><vh>insertSR</vh></v>
<v t="ekr.20070127142841.94"><vh>addSR</vh></v>
<v t="ekr.20070127142841.95"><vh>addLanguageMenu</vh></v>
<v t="ekr.20070127142841.96"><vh>addInsertPath</vh></v>
<v t="ekr.20070127142841.97"><vh>addCompositeView</vh></v>
<v t="ekr.20070127142841.98"><vh>addFlashCardView</vh></v>
<v t="ekr.20070127142841.99"><vh>addFootNodeMenu</vh></v>
</v>
<v t="ekr.20070127142841.100"><vh>implementation of FocusListener interface</vh></v>
<v t="ekr.20070127142841.101"><vh>detach and retach</vh></v>
<v t="ekr.20070127142841.102"><vh>turnSelectionIntoNode</vh></v>
<v t="ekr.20070127142841.103"><vh>insertTextIntoBody</vh></v>
<v t="ekr.20070127142841.104"><vh>splitNode</vh></v>
<v t="ekr.20070127142841.105"><vh>sectionReferenceToWidget</vh></v>
<v t="ekr.20070127142841.106"><vh>chapterChanged</vh></v>
<v t="ekr.20070127142841.107"><vh>headlineChanged</vh></v>
<v t="ekr.20070127142841.108"><vh>splitting the editor</vh>
<v t="ekr.20070127142841.109"><vh>splitVertically</vh></v>
<v t="ekr.20070127142841.110"><vh>createEditor</vh></v>
</v>
</v>
<v t="ekr.20070127142841.111"><vh>helper classes</vh>
<v t="ekr.20070127142841.61"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20070127142841.59"><vh>colorizer callback</vh>
<v t="ekr.20070127142841.60"><vh>getLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.58"><vh>class insTx</vh></v>
<v t="ekr.20070127142841.112"><vh>resizer --keeps components sized right</vh></v>
<v t="ekr.20070127142841.113"><vh>resizer2</vh></v>
<v t="ekr.20070127142841.114"><vh>gonode -- actionPerformed takes user to node</vh></v>
<v t="ekr.20070127142841.115"><vh>outlinetraveler --allows the user to traverse the tree quickly</vh></v>
<v t="ekr.20070127142841.116"><vh>footnoderemover</vh></v>
<v t="ekr.20070127142841.117"><vh>keywordInserter -- allows the user to insert language keywords</vh></v>
<v t="ekr.20070127142841.118"><vh>swingmacs help</vh></v>
<v t="ekr.20070127142841.119"><vh>autocompleter help</vh></v>
<v t="ekr.20070127142841.120"><vh>class FoldProtector</vh>
<v t="ekr.20070127142841.121"><vh>DocumentFilter interface</vh></v>
<v t="ekr.20070127142841.122"><vh>moveSelectionUp</vh>
<v t="ekr.20070127142841.123"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.124"><vh>moveSelectionDown</vh>
<v t="ekr.20070127142841.125"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.126"><vh>class Fold</vh></v>
<v t="ekr.20070127142841.127"><vh>class Defolder</vh></v>
</v>
<v t="ekr.20070127142841.128"><vh>CommanderCommander</vh>
<v t="ekr.20070127142841.129"><vh>setupCommands</vh></v>
<v t="ekr.20070127142841.130"><vh>gotoNode1</vh></v>
<v t="ekr.20070127142841.131"><vh>gotoNode2</vh></v>
</v>
<v t="ekr.20070127142841.132"><vh>BracketHighlighter</vh>
<v t="ekr.20070127142841.133"><vh>__init__</vh></v>
<v t="ekr.20070127142841.134"><vh>DocumentListener interface</vh></v>
<v t="ekr.20070127142841.135"><vh>ChangeListener interface</vh></v>
<v t="ekr.20070127142841.136"><vh>findBracket</vh></v>
<v t="ekr.20070127142841.137"><vh>forwardFind</vh></v>
<v t="ekr.20070127142841.138"><vh>backwardFind</vh></v>
<v t="ekr.20070127142841.139"><vh>setBracketMatch</vh></v>
</v>
</v>
<v t="ekr.20070127142841.140"><vh>component classes</vh>
<v t="ekr.20070127142841.141"><vh>autolistener --does autocompleter work</vh>
<v t="ekr.20070127142841.142"><vh>helper classes</vh>
<v t="ekr.20070127142841.143"><vh>hider and boxListener</vh></v>
</v>
<v t="ekr.20070127142841.144"><vh>constructAutobox</vh></v>
<v t="ekr.20070127142841.145"><vh>processKeyStroke/keyPressed</vh></v>
<v t="ekr.20070127142841.146"><vh>processAutoBox</vh></v>
<v t="ekr.20070127142841.147"><vh>moveUpDown</vh></v>
<v t="ekr.20070127142841.148"><vh>testForUnbind</vh></v>
<v t="ekr.20070127142841.149"><vh>DocumentListener implementation</vh>
<v t="ekr.20070127142841.150"><vh>changedUpdate</vh></v>
<v t="ekr.20070127142841.151"><vh>insertUpdate</vh></v>
<v t="ekr.20070127142841.152"><vh>removeUpdate</vh></v>
</v>
<v t="ekr.20070127142841.153"><vh>watcher</vh></v>
<v t="ekr.20070127142841.154"><vh>scanText</vh></v>
<v t="ekr.20070127142841.155"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20070127142841.156"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20070127142841.157"><vh>_getCleanString</vh></v>
<v t="ekr.20070127142841.158"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20070127142841.159"><vh>reducer</vh></v>
<v t="ekr.20070127142841.160"><vh>determineToShow</vh></v>
<v t="ekr.20070127142841.161"><vh>startup time scanning</vh>
<v t="ekr.20070127142841.162"><vh>initialScan</vh></v>
<v t="ekr.20070127142841.163"><vh>readOutline</vh></v>
</v>
<v t="ekr.20070127142841.164"><vh>get, hide and insert AutoBox</vh>
<v t="ekr.20070127142841.165"><vh>getAutoBox</vh></v>
<v t="ekr.20070127142841.166"><vh>hideAutoBox</vh></v>
<v t="ekr.20070127142841.167"><vh>insertFromAutobox</vh></v>
</v>
</v>
<v t="ekr.20070127142841.168"><vh>Carets</vh>
<v t="ekr.20070127142841.169"><vh>UnderlinerCaret</vh></v>
<v t="ekr.20070127142841.170"><vh>SeeThroughBoxCaret</vh></v>
<v t="ekr.20070127142841.171"><vh>GhostlyLeoCaret</vh></v>
<v t="ekr.20070127142841.172"><vh>ImageCaret</vh></v>
</v>
<v t="ekr.20070127142841.173"><vh>leoJTextPane</vh></v>
<v t="ekr.20070127142841.174"><vh>leoImageJPanel</vh></v>
<v t="ekr.20070127142841.175"><vh>leoLayoutManager</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142841.176"><vh>MouseAdapter</vh>
<v t="ekr.20070127142841.177"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20070127142841.178"><vh>tabs</vh></v>
<v t="ekr.20070127142841.179"><vh>nextEditor previousEditor</vh></v>
<v t="ekr.20070127142841.180"><vh>classes: Editor and a multitude of helpers</vh>
<v t="ekr.20070127142841.57"><vh>class Editor</vh>
<v t="ekr.20070127142841.58"><vh>class insTx</vh></v>
<v t="ekr.20070127142841.59"><vh>colorizer callback</vh>
<v t="ekr.20070127142841.60"><vh>getLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.61"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20070127142841.62"><vh>Note on Editor design</vh></v>
<v t="ekr.20070127142841.63"><vh>__init__</vh>
<v t="ekr.20070127142841.64"><vh>&lt;&lt; add EditorKit &gt;&gt;</vh></v>
<v t="ekr.20070127142841.65"><vh>&lt;&lt; add autocompleter &gt;&gt;</vh></v>
<v t="ekr.20070127142841.66"><vh>&lt;&lt; add scrollpane &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.67"><vh>helper methods and classes</vh>
<v t="ekr.20070127142841.68"><vh>constuctor methods</vh>
<v t="ekr.20070127142841.69"><vh>addMenus</vh></v>
<v t="ekr.20070127142841.70"><vh>addMinibuffer</vh></v>
<v t="ekr.20070127142841.71"><vh>addCompleters</vh></v>
<v t="ekr.20070127142841.72"><vh>initializeEditor</vh></v>
<v t="ekr.20070127142841.73"><vh>initializeEditorColors</vh></v>
<v t="ekr.20070127142841.74"><vh>initializeFont</vh></v>
<v t="ekr.20070127142841.75"><vh>initializeCaret</vh></v>
<v t="ekr.20070127142841.76"><vh>initializeLineNumbering</vh></v>
<v t="ekr.20070127142841.77"><vh>createCommanderCommander</vh></v>
</v>
<v t="ekr.20070127142841.78"><vh>config methods</vh>
<v t="ekr.20070127142841.79"><vh>configureMedia</vh></v>
<v t="ekr.20070127142841.80"><vh>setBackgroundImage</vh></v>
<v t="ekr.20070127142841.81"><vh>useAutocompleter</vh></v>
<v t="ekr.20070127142841.82"><vh>setCaret</vh></v>
<v t="ekr.20070127142841.83"><vh>setFont</vh></v>
<v t="ekr.20070127142841.84"><vh>setEditorColors</vh></v>
<v t="ekr.20070127142841.85"><vh>setLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.86"><vh>methods</vh>
<v t="ekr.20070127142841.87"><vh>sync</vh></v>
<v t="ekr.20070127142841.88"><vh>nowShowing</vh></v>
<v t="ekr.20070127142841.89"><vh>menu methods</vh>
<v t="ekr.20070127142841.90"><vh>configureGotoMenu</vh></v>
<v t="ekr.20070127142841.91"><vh>directiveMenu</vh></v>
<v t="ekr.20070127142841.92"><vh>headlineMenu</vh></v>
<v t="ekr.20070127142841.93"><vh>insertSR</vh></v>
<v t="ekr.20070127142841.94"><vh>addSR</vh></v>
<v t="ekr.20070127142841.95"><vh>addLanguageMenu</vh></v>
<v t="ekr.20070127142841.96"><vh>addInsertPath</vh></v>
<v t="ekr.20070127142841.97"><vh>addCompositeView</vh></v>
<v t="ekr.20070127142841.98"><vh>addFlashCardView</vh></v>
<v t="ekr.20070127142841.99"><vh>addFootNodeMenu</vh></v>
</v>
<v t="ekr.20070127142841.100"><vh>implementation of FocusListener interface</vh></v>
<v t="ekr.20070127142841.101"><vh>detach and retach</vh></v>
<v t="ekr.20070127142841.102"><vh>turnSelectionIntoNode</vh></v>
<v t="ekr.20070127142841.103"><vh>insertTextIntoBody</vh></v>
<v t="ekr.20070127142841.104"><vh>splitNode</vh></v>
<v t="ekr.20070127142841.105"><vh>sectionReferenceToWidget</vh></v>
<v t="ekr.20070127142841.106"><vh>chapterChanged</vh></v>
<v t="ekr.20070127142841.107"><vh>headlineChanged</vh></v>
<v t="ekr.20070127142841.108"><vh>splitting the editor</vh>
<v t="ekr.20070127142841.109"><vh>splitVertically</vh></v>
<v t="ekr.20070127142841.110"><vh>createEditor</vh></v>
</v>
</v>
<v t="ekr.20070127142841.111"><vh>helper classes</vh>
<v t="ekr.20070127142841.61"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20070127142841.59"><vh>colorizer callback</vh>
<v t="ekr.20070127142841.60"><vh>getLineNumberColors</vh></v>
</v>
<v t="ekr.20070127142841.58"><vh>class insTx</vh></v>
<v t="ekr.20070127142841.112"><vh>resizer --keeps components sized right</vh></v>
<v t="ekr.20070127142841.113"><vh>resizer2</vh></v>
<v t="ekr.20070127142841.114"><vh>gonode -- actionPerformed takes user to node</vh></v>
<v t="ekr.20070127142841.115"><vh>outlinetraveler --allows the user to traverse the tree quickly</vh></v>
<v t="ekr.20070127142841.116"><vh>footnoderemover</vh></v>
<v t="ekr.20070127142841.117"><vh>keywordInserter -- allows the user to insert language keywords</vh></v>
<v t="ekr.20070127142841.118"><vh>swingmacs help</vh></v>
<v t="ekr.20070127142841.119"><vh>autocompleter help</vh></v>
<v t="ekr.20070127142841.120"><vh>class FoldProtector</vh>
<v t="ekr.20070127142841.121"><vh>DocumentFilter interface</vh></v>
<v t="ekr.20070127142841.122"><vh>moveSelectionUp</vh>
<v t="ekr.20070127142841.123"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.124"><vh>moveSelectionDown</vh>
<v t="ekr.20070127142841.125"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.126"><vh>class Fold</vh></v>
<v t="ekr.20070127142841.127"><vh>class Defolder</vh></v>
</v>
<v t="ekr.20070127142841.128"><vh>CommanderCommander</vh>
<v t="ekr.20070127142841.129"><vh>setupCommands</vh></v>
<v t="ekr.20070127142841.130"><vh>gotoNode1</vh></v>
<v t="ekr.20070127142841.131"><vh>gotoNode2</vh></v>
</v>
<v t="ekr.20070127142841.132"><vh>BracketHighlighter</vh>
<v t="ekr.20070127142841.133"><vh>__init__</vh></v>
<v t="ekr.20070127142841.134"><vh>DocumentListener interface</vh></v>
<v t="ekr.20070127142841.135"><vh>ChangeListener interface</vh></v>
<v t="ekr.20070127142841.136"><vh>findBracket</vh></v>
<v t="ekr.20070127142841.137"><vh>forwardFind</vh></v>
<v t="ekr.20070127142841.138"><vh>backwardFind</vh></v>
<v t="ekr.20070127142841.139"><vh>setBracketMatch</vh></v>
</v>
</v>
<v t="ekr.20070127142841.140"><vh>component classes</vh>
<v t="ekr.20070127142841.141"><vh>autolistener --does autocompleter work</vh>
<v t="ekr.20070127142841.142"><vh>helper classes</vh>
<v t="ekr.20070127142841.143"><vh>hider and boxListener</vh></v>
</v>
<v t="ekr.20070127142841.144"><vh>constructAutobox</vh></v>
<v t="ekr.20070127142841.145"><vh>processKeyStroke/keyPressed</vh></v>
<v t="ekr.20070127142841.146"><vh>processAutoBox</vh></v>
<v t="ekr.20070127142841.147"><vh>moveUpDown</vh></v>
<v t="ekr.20070127142841.148"><vh>testForUnbind</vh></v>
<v t="ekr.20070127142841.149"><vh>DocumentListener implementation</vh>
<v t="ekr.20070127142841.150"><vh>changedUpdate</vh></v>
<v t="ekr.20070127142841.151"><vh>insertUpdate</vh></v>
<v t="ekr.20070127142841.152"><vh>removeUpdate</vh></v>
</v>
<v t="ekr.20070127142841.153"><vh>watcher</vh></v>
<v t="ekr.20070127142841.154"><vh>scanText</vh></v>
<v t="ekr.20070127142841.155"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20070127142841.156"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20070127142841.157"><vh>_getCleanString</vh></v>
<v t="ekr.20070127142841.158"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20070127142841.159"><vh>reducer</vh></v>
<v t="ekr.20070127142841.160"><vh>determineToShow</vh></v>
<v t="ekr.20070127142841.161"><vh>startup time scanning</vh>
<v t="ekr.20070127142841.162"><vh>initialScan</vh></v>
<v t="ekr.20070127142841.163"><vh>readOutline</vh></v>
</v>
<v t="ekr.20070127142841.164"><vh>get, hide and insert AutoBox</vh>
<v t="ekr.20070127142841.165"><vh>getAutoBox</vh></v>
<v t="ekr.20070127142841.166"><vh>hideAutoBox</vh></v>
<v t="ekr.20070127142841.167"><vh>insertFromAutobox</vh></v>
</v>
</v>
<v t="ekr.20070127142841.168"><vh>Carets</vh>
<v t="ekr.20070127142841.169"><vh>UnderlinerCaret</vh></v>
<v t="ekr.20070127142841.170"><vh>SeeThroughBoxCaret</vh></v>
<v t="ekr.20070127142841.171"><vh>GhostlyLeoCaret</vh></v>
<v t="ekr.20070127142841.172"><vh>ImageCaret</vh></v>
</v>
<v t="ekr.20070127142841.173"><vh>leoJTextPane</vh></v>
<v t="ekr.20070127142841.174"><vh>leoImageJPanel</vh></v>
<v t="ekr.20070127142841.175"><vh>leoLayoutManager</vh></v>
</v>
</v>
</v>
<v t="ekr.20070127142841.176"><vh>MouseAdapter</vh>
<v t="ekr.20070127142841.177"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20070127142841.181"><vh>SimplifiedUtilityRightClick -- for adding an Editor</vh>
<v t="ekr.20070127142841.182"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20070127142841.183"><vh>class AddEditor</vh></v>
<v t="ekr.20070127142841.184"><vh>class UtilityAction</vh></v>
<v t="ekr.20070127142841.185"><vh>class InsertNode</vh></v>
</v>
<v t="ekr.20070127142841.186"><vh>UndoableEditListener</vh></v>
<v t="ekr.20070127142841.187"><vh>KeyAdapter -- for preparing undoer</vh></v>
<v t="ekr.20070127142841.188"><vh>getAllText --had to be added</vh></v>
</v>
<v t="ekr.20070127142841.189"><vh>class leoSwingFrame</vh>
<v t="ekr.20070127142841.190"><vh>  leoSwingFrame.__init__</vh></v>
<v t="ekr.20070127142841.191"><vh> Must be defined in subclasses</vh>
<v t="ekr.20070127142841.192"><vh> gui-dependent commands</vh></v>
<v t="ekr.20070127142841.193"><vh>bringToFront, deiconify, lift &amp; update</vh></v>
<v t="ekr.20070127142841.194"><vh>config stuff...</vh>
<v t="ekr.20070127142841.195"><vh>resizePanesToRatio</vh></v>
<v t="ekr.20070127142841.196"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20070127142841.197"><vh>setTopGeometry</vh></v>
<v t="ekr.20070127142841.198"><vh>get_window_info</vh></v>
</v>
</v>
<v t="ekr.20070127142841.199"><vh>finishCreate</vh>
<v t="ekr.20070127142841.200"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.201"><vh>setTabWidth</vh></v>
<v t="ekr.20070127142841.202"><vh>getTitle &amp; setTitle</vh></v>
<v t="ekr.20070127142841.203"><vh>initialRatios</vh></v>
<v t="ekr.20070127142841.204"><vh>longFileName &amp; shortFileName</vh></v>
<v t="ekr.20070127142841.205"><vh>oops</vh></v>
<v t="ekr.20070127142841.206"><vh>promptForSave</vh>
<v t="ekr.20070127142841.207"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.208"><vh>scanForTabWidth</vh>
<v t="ekr.20070127142841.209"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.210"><vh>destroySelf --had to be added</vh></v>
<v t="ekr.20070127142841.211"><vh>clearStatusLine -- had to be added</vh></v>
<v t="ekr.20070127142841.212"><vh>finishCreateForSettings</vh>
<v t="ekr.20070127142841.213"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.214"><vh>configuration methods</vh>
<v t="ekr.20070127142841.215"><vh>setSkin</vh></v>
</v>
<v t="ekr.20070127142841.216"><vh>addIconButton -- had to be added</vh></v>
<v t="ekr.20070127142841.217"><vh>toggleActivePane</vh></v>
<v t="ekr.20070127142841.218"><vh>isMenuInitialized</vh></v>
<v t="ekr.20070127142841.219"><vh>startReceiver</vh></v>
<v t="ekr.20070127142841.220"><vh>helper classes</vh>
<v t="ekr.20070127142841.221"><vh>class leoFocusTraversalPolicy</vh>
<v t="ekr.20070127142841.222"><vh>getComponentAfter</vh></v>
<v t="ekr.20070127142841.223"><vh>getComponentBefore</vh></v>
<v t="ekr.20070127142841.224"><vh>getDefaultComponent</vh></v>
<v t="ekr.20070127142841.225"><vh>getFirstComponent</vh></v>
<v t="ekr.20070127142841.226"><vh>getInitialComponent</vh></v>
<v t="ekr.20070127142841.227"><vh>getLastComponent</vh></v>
</v>
<v t="ekr.20070127142841.228"><vh>class Receiver</vh></v>
<v t="ekr.20070127142841.229"><vh>class GlassPane2</vh></v>
<v t="ekr.20070127142841.230"><vh>class NodeBar</vh>
<v t="ekr.20070127142841.231"><vh>images</vh></v>
<v t="ekr.20070127142841.232"><vh>def __init__</vh></v>
<v t="ekr.20070127142841.233"><vh>flavorsChanged</vh></v>
<v t="ekr.20070127142841.234"><vh>goto enablers</vh></v>
<v t="ekr.20070127142841.235"><vh>def createButton</vh></v>
<v t="ekr.20070127142841.236"><vh>def gotoChild</vh></v>
<v t="ekr.20070127142841.237"><vh>endUpdate</vh></v>
</v>
<v t="ekr.20070127142841.238"><vh>class WindowClosingWatcher</vh></v>
<v t="ekr.20070127142841.239"><vh>class LeoMetalTheme</vh></v>
</v>
</v>
<v t="ekr.20070127142841.240"><vh>class leoSwingGui</vh>
<v t="ekr.20070127142841.241"><vh>app.gui Birth &amp; death</vh>
<v t="ekr.20070127142841.242"><vh> leoGui.__init__</vh></v>
<v t="ekr.20070127142841.243"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20070127142841.244"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.245"><vh>stubs</vh>
<v t="ekr.20070127142841.246"><vh>createRootWindow</vh></v>
<v t="ekr.20070127142841.247"><vh>destroySelf</vh></v>
<v t="ekr.20070127142841.248"><vh>finishCreate</vh></v>
<v t="ekr.20070127142841.249"><vh>killGui</vh></v>
<v t="ekr.20070127142841.250"><vh>recreateRootWindow</vh></v>
<v t="ekr.20070127142841.251"><vh>runMainLoop</vh></v>
</v>
</v>
<v t="ekr.20070127142841.252"><vh>app.gui dialogs</vh></v>
<v t="ekr.20070127142841.253"><vh>app.gui file dialogs</vh></v>
<v t="ekr.20070127142841.254"><vh>app.gui panels</vh></v>
<v t="ekr.20070127142841.255"><vh>app.gui utils</vh>
<v t="ekr.20070127142841.256"><vh>Clipboard</vh></v>
<v t="ekr.20070127142841.257"><vh>Dialog utils</vh></v>
<v t="ekr.20070127142841.258"><vh>Font</vh></v>
<v t="ekr.20070127142841.259"><vh>Focus</vh></v>
<v t="ekr.20070127142841.260"><vh>Index</vh></v>
<v t="ekr.20070127142841.261"><vh>Idle time</vh></v>
</v>
<v t="ekr.20070127142841.262"><vh>guiName</vh></v>
<v t="ekr.20070127142841.263"><vh>oops</vh></v>
<v t="ekr.20070127142841.264"><vh>insertPoints --had to be added</vh></v>
<v t="ekr.20070127142841.265"><vh>makeIndexVisible --had to be added</vh></v>
<v t="ekr.20070127142841.266"><vh>moveIndexForward &amp; moveIndexToNextLine -- had to be added</vh></v>
<v t="ekr.20070127142841.267"><vh>addStartupTask</vh></v>
<v t="ekr.20070127142841.268"><vh>getFontFromParams</vh></v>
<v t="ekr.20070127142841.269"><vh>Look And Feel Changes</vh>
<v t="ekr.20070127142841.270"><vh>addLAFListener</vh></v>
<v t="ekr.20070127142841.271"><vh>class LAFChangeListener</vh></v>
</v>
<v t="ekr.20070127142841.272"><vh>had to be added</vh>
<v t="ekr.20070127142841.273"><vh>replaceSelectionRangeWithText</vh></v>
<v t="ekr.20070127142841.274"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20070127142841.275"><vh>compareIndices</vh></v>
<v t="ekr.20070127142841.276"><vh>getAllText</vh></v>
</v>
</v>
<v t="ekr.20070127142841.277"><vh>class leoSwingLog</vh>
<v t="ekr.20070127142841.278"><vh>leoLog.__init__</vh></v>
<v t="ekr.20070127142841.279"><vh>leoLog.configure</vh></v>
<v t="ekr.20070127142841.280"><vh>leoLog.configureBorder</vh></v>
<v t="ekr.20070127142841.281"><vh>leoLog.createControl</vh></v>
<v t="ekr.20070127142841.282"><vh>leoLog.enable &amp; disable</vh></v>
<v t="ekr.20070127142841.283"><vh>leoLog.oops</vh></v>
<v t="ekr.20070127142841.284"><vh>leoLog.setFontFromConfig</vh></v>
<v t="ekr.20070127142841.285"><vh>leoLog.onActivateLog</vh></v>
<v t="ekr.20070127142841.286"><vh>leoLog.put &amp; putnl</vh></v>
<v t="ekr.20070127142841.287"><vh>class LogControl</vh></v>
<v t="ekr.20070127142841.288"><vh>setBackgroundImage</vh></v>
<v t="ekr.20070127142841.289"><vh>leoLog setColorFromConfig</vh></v>
<v t="ekr.20070127142841.290"><vh>addTab</vh></v>
</v>
<v t="ekr.20070127142841.291"><vh>class leoSwingMenu</vh>
<v t="ekr.20070127142841.292"><vh> leoSwingMenu.__init__</vh></v>
<v t="ekr.20070127142841.293"><vh>class MenuChanger</vh></v>
<v t="ekr.20070127142841.294"><vh>print menu stuff...</vh>
<v t="ekr.20070127142841.295"><vh>defineLeoSwingPrintTable</vh></v>
<v t="ekr.20070127142841.296"><vh>createLeoSwingPrintMenu</vh></v>
<v t="ekr.20070127142841.297"><vh>createLeoSwingPrint</vh></v>
</v>
<v t="ekr.20070127142841.298"><vh>plugin menu stuff...</vh>
<v t="ekr.20070127142841.299"><vh>createPluginMenu</vh></v>
<v t="ekr.20070127142841.300"><vh>createPluginManager</vh></v>
<v t="ekr.20070127142841.301"><vh>getPluginMenu</vh></v>
</v>
<v t="ekr.20070127142841.302"><vh>JythonShell stuff</vh>
<v t="ekr.20070127142841.303"><vh>openJythonShell</vh></v>
<v t="ekr.20070127142841.304"><vh>addMenuToJythonShell</vh></v>
<v t="ekr.20070127142841.305"><vh>getInsertNodeIntoShell</vh></v>
<v t="ekr.20070127142841.306"><vh>getInsertReferenceIntoLeo</vh></v>
<v t="ekr.20070127142841.307"><vh>getRunNodeInPdb</vh></v>
<v t="ekr.20070127142841.308"><vh>fireNodeAsScript</vh></v>
<v t="ekr.20070127142841.309"><vh>class _GetReferenceName</vh></v>
</v>
<v t="ekr.20070127142841.310"><vh>addUserGuide</vh></v>
<v t="ekr.20070127142841.311"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
<v t="ekr.20070127142841.312"><vh>oops</vh></v>
<v t="ekr.20070127142841.313"><vh>Must be overridden in menu subclasses</vh>
<v t="ekr.20070127142841.314"><vh>9 Routines with Tk spellings</vh></v>
<v t="ekr.20070127142841.315"><vh>7 Routines with new spellings</vh></v>
<v t="ekr.20070127142841.316"><vh>class MenuRunnable</vh></v>
<v t="ekr.20070127142841.317"><vh>class MenuExecuteOnSelect</vh></v>
<v t="ekr.20070127142841.318"><vh>class LeoMenu</vh></v>
</v>
</v>
<v t="ekr.20070127142841.319"><vh>class leoSwingTree</vh>
<v t="ekr.20070127142841.320"><vh>  tree.__init__ (base class)</vh></v>
<v t="ekr.20070127142841.322"><vh>class posTreeModel</vh></v>
<v t="ekr.20070127142841.323"><vh>doneLoading</vh></v>
<v t="ekr.20070127142841.324"><vh>valueChanged --tree selection Event</vh></v>
<v t="ekr.20070127142841.325"><vh> Must be defined in subclasses</vh>
<v t="ekr.20070127142841.326"><vh>Drawing</vh></v>
<v t="ekr.20070127142841.327"><vh>Edit label</vh></v>
<v t="ekr.20070127142841.329"><vh>Notifications</vh></v>
<v t="ekr.20070127142841.330"><vh>Scrolling</vh></v>
<v t="ekr.20070127142841.331"><vh>Selecting</vh></v>
<v t="ekr.20070127142841.332"><vh>Tree operations</vh></v>
</v>
<v t="ekr.20070127142841.333"><vh>beginUpdate</vh></v>
<v t="ekr.20070127142841.334"><vh>endUpdate</vh></v>
<v t="ekr.20070127142841.335"><vh>Getters/Setters (tree)</vh></v>
<v t="ekr.20070127142841.336"><vh>oops</vh></v>
<v t="ekr.20070127142841.337"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20070127142841.338"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20070127142841.339"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20070127142841.340"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.341"><vh>tree.enableDrawingAfterException</vh></v>
<v t="ekr.20070127142841.342"><vh>class tcellEditor</vh></v>
<v t="ekr.20070127142841.343"><vh>class cellEditorListener</vh></v>
<v t="ekr.20070127142841.344"><vh>edit_text --had to be added</vh></v>
<v t="ekr.20070127142841.345"><vh>createAuxilaryWidgets</vh></v>
<v t="ekr.20070127142841.346"><vh>getWidget</vh></v>
<v t="ekr.20070127142841.350"><vh>configureMedia</vh></v>
<v t="ekr.20070127142841.351"><vh>setBackgroundImage</vh></v>
<v t="ekr.20070127142841.352"><vh>helper classes</vh>
<v t="ekr.20070127142841.348"><vh>class JTree2</vh></v>
<v t="ekr.20070127142841.322"><vh>class posTreeModel</vh></v>
<v t="ekr.20070127142841.342"><vh>class tcellEditor</vh></v>
<v t="ekr.20070127142841.343"><vh>class cellEditorListener</vh></v>
<v t="ekr.20070127142841.353"><vh>class EditLabelEnabler</vh></v>
<v t="ekr.20070127142841.354"><vh>class ViewControls</vh></v>
<v t="ekr.20070127142841.355"><vh>class PopupEnabler</vh></v>
<v t="ekr.20070127142841.356"><vh>class ImageSetter</vh></v>
<v t="ekr.20070127142841.357"><vh>class TreeTransferHandler</vh>
<v t="ekr.20070127142841.358"><vh>canImport</vh></v>
<v t="ekr.20070127142841.359"><vh>importData</vh></v>
<v t="ekr.20070127142841.360"><vh>importFile</vh></v>
<v t="ekr.20070127142841.361"><vh>getVisualRepresentation</vh></v>
<v t="ekr.20070127142841.362"><vh>class TreeTransferable</vh>
<v t="ekr.20070127142841.363"><vh>getTransferData</vh></v>
<v t="ekr.20070127142841.364"><vh>writeNodeToFile</vh></v>
</v>
<v t="ekr.20070127142841.365"><vh>class ImportUrls</vh></v>
<v t="ekr.20070127142841.366"><vh>class ImportFiles</vh></v>
</v>
</v>
<v t="ekr.20070127142841.367"><vh>focuslistener interface</vh></v>
<v t="ekr.20070127142841.368"><vh>image creation</vh></v>
<v t="ekr.20070127142841.369"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="ekr.20070127142841.370"><vh>setBackgroundColor</vh></v>
</v>
<v t="ekr.20070127142841.371"><vh>from DomConvertedMethods</vh>
<v t="ekr.20070127142841.372"><vh>from leoFileCommands</vh>
<v t="ekr.20070127142841.373"><vh>reading with dom...</vh>
<v t="ekr.20070127142841.374"><vh>getLeoFile2</vh>
<v t="ekr.20070127142841.375"><vh>&lt;&lt; read leo header &gt;&gt;</vh></v>
<v t="ekr.20070127142841.376"><vh>&lt;&lt; read globals &gt;&gt;</vh></v>
<v t="ekr.20070127142841.377"><vh>&lt;&lt; read prefs &gt;&gt;</vh></v>
<v t="ekr.20070127142841.378"><vh>&lt;&lt; read find panel settings &gt;&gt;</vh></v>
<v t="ekr.20070127142841.379"><vh>&lt;&lt; build tnodes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.380"><vh>&lt;&lt; build vnodes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.381"><vh>&lt;&lt; expand nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.382"><vh>getVnode2</vh></v>
</v>
<v t="ekr.20070127142841.383"><vh>writing with dom...</vh>
<v t="ekr.20070127142841.384"><vh>write_Leo_file</vh>
<v t="ekr.20070127142841.385"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.386"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20070127142841.387"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20070127142841.388"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20070127142841.389"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20070127142841.390"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20070127142841.391"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.392" a="M"><vh>putVnode2 (3.x and 4.x)</vh>
<v t="ekr.20070127142841.393" a="M"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20070127142841.394"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20070127142841.395"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.396"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
<v t="ekr.20070127142841.397"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070127142841.398"><vh>Utils</vh>
<v t="ekr.20070127142841.399"><vh>getColorInstance</vh></v>
<v t="ekr.20070127142841.400"><vh>class leoJSPFocusListener</vh></v>
<v t="ekr.20070127142841.401"><vh>class VisibleInformer</vh></v>
<v t="ekr.20070127142841.402"><vh>class GCEveryOneMinute</vh></v>
</v>
<v t="ekr.20070127142841.403"><vh>From LeoJy.leo</vh>
<v t="ekr.20070127142841.404"><vh>from leoSwingFind.py</vh>
<v t="ekr.20070127142841.405"><vh>Birth &amp; death</vh>
<v t="ekr.20070127142841.406"><vh>__init__</vh>
<v t="ekr.20070127142841.407"><vh>&lt;&lt; init the tkinter ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.408"><vh>fake TkVars --classes that look like Tk variables</vh></v>
<v t="ekr.20070127142841.409"><vh>destroySelf</vh></v>
<v t="ekr.20070127142841.410"><vh>find.createFrame</vh>
<v t="ekr.20070127142841.411"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.412"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20070127142841.413"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.414"><vh>createNodeSearchFrame</vh></v>
<v t="ekr.20070127142841.415"><vh>addAsSearchOrExclude</vh></v>
<v t="ekr.20070127142841.416"><vh>find.init</vh>
<v t="ekr.20070127142841.417"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20070127142841.418"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.419"><vh>find.set_ivars</vh></v>
<v t="ekr.20070127142841.420"><vh>find.update_ivars</vh></v>
</v>
<v t="ekr.20070127142841.421"><vh>onCloseWindow</vh></v>
<v t="ekr.20070127142841.422"><vh>bringToFront</vh></v>
<v t="ekr.20070127142841.423"><vh>selectAll</vh></v>
<v t="ekr.20070127142841.424"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20070127142841.425"><vh>search</vh></v>
<v t="ekr.20070127142841.426"><vh>findButton --had to change</vh></v>
<v t="ekr.20070127142841.427"><vh>executeSearch</vh></v>
<v t="ekr.20070127142841.428"><vh>findNextCommand</vh></v>
<v t="ekr.20070127142841.429"><vh>changeAll</vh></v>
<v t="ekr.20070127142841.430"><vh>clone and copy searching</vh>
<v t="ekr.20070127142841.431"><vh>nodeSearch</vh></v>
<v t="ekr.20070127142841.432"><vh>createContainerNode</vh></v>
</v>
<v t="ekr.20070127142841.433"><vh>class CutCopyPaste</vh></v>
<v t="ekr.20070127142841.434"><vh>class _LeoTableCellEditor</vh></v>
<v t="ekr.20070127142841.435"><vh>class _LeoTableCellRenderer</vh></v>
</v>
<v t="ekr.20070127142841.436"><vh>from leoSwingComparePanel</vh>
<v t="ekr.20070127142841.437"><vh>Birth...</vh>
<v t="ekr.20070127142841.438"><vh> tkinterComparePanel.__init__</vh>
<v t="ekr.20070127142841.439"><vh>&lt;&lt; init tkinter compare ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.440"><vh>fake Tk vars</vh></v>
<v t="ekr.20070127142841.441"><vh>class _DTM</vh></v>
<v t="ekr.20070127142841.442"><vh>finishCreate</vh></v>
<v t="ekr.20070127142841.443"><vh>createTopFrame</vh></v>
<v t="ekr.20070127142841.444"><vh>createFrame</vh>
<v t="ekr.20070127142841.445"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20070127142841.446"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20070127142841.447"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20070127142841.448"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20070127142841.449"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20070127142841.450"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20070127142841.451"><vh>setIvarsFromWidgets</vh></v>
</v>
<v t="ekr.20070127142841.452"><vh>bringToFront</vh></v>
<v t="ekr.20070127142841.453"><vh>browser</vh></v>
<v t="ekr.20070127142841.454"><vh>compare_directories (entry)</vh></v>
<v t="ekr.20070127142841.455"><vh>filecmp</vh></v>
<v t="ekr.20070127142841.456"><vh>class brwsfilter</vh></v>
<v t="ekr.20070127142841.457"><vh>Event handlers...</vh>
<v t="ekr.20070127142841.458"><vh>onBrowse...</vh></v>
<v t="ekr.20070127142841.459"><vh>onClose</vh></v>
<v t="ekr.20070127142841.460"><vh>onCompare...</vh></v>
<v t="ekr.20070127142841.461"><vh>onPrintMatchedLines</vh></v>
</v>
<v t="ekr.20070127142841.462"><vh>utils</vh>
<v t="ekr.20070127142841.463"><vh>show</vh></v>
<v t="ekr.20070127142841.464"><vh>showMismatchTable</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20070127142814.1">@path utilities</t>
<t tx="ekr.20070127142814.2">@language python

import java.util.concurrent as concurrent


class DefCallable( concurrent.Callable ):
    
    def __init__( self, method ):
        self.method = method
        
    def call( self ):
        return self.method()
        
    
    def wrappedAsFutureTask( self ):
        return concurrent.FutureTask( self )



    
    

</t>
<t tx="ekr.20070127142814.3">import java
import javax.swing as swing
import java.awt.event as aevent


class CutCopyPaste( aevent.MouseAdapter ):
    
    def __init__( self, jtp ):
        aevent.MouseAdapter.__init__( self )
        self.jtp = jtp
        self.ccp = swing.JPopupMenu()
        cut = swing.JMenuItem( "Cut" )
        cut.actionPerformed = lambda event : jtp.cut()
        self.ccp.add( cut )
        copy = swing.JMenuItem( "Copy" )
        copy.actionPerformed = lambda event : jtp.copy()
        self.ccp.add( copy )
        paste = swing.JMenuItem( "Paste" )
        paste.actionPerformed = lambda event: jtp.paste()
        self.ccp.add( paste )
        jtp.addMouseListener( self )
    
    
    def _paste( self ):
        
        dtk = java.awt.Toolkit.getDefaultToolkit()
        cb = dtk.getSystemClipboard()
        df = cb.getAvailableDataFlavors()
        for z in df:
            print z
        
       
    def mousePressed( self, event ):
        
        if event.getButton() == event.BUTTON3:
            self.summon_ccp( event )
            
    
    def summon_ccp( self, event ):
        
        self.ccp.show( event.getSource(), event.getX(), event.getY() )
</t>
<t tx="ekr.20070127142814.4">import javax.swing as swing
import java

class TabManager:
    
    def __init__( self, switch_on_add = 1 ):
        self.jtp = swing.JTabbedPane()
        self.base = swing.JPanel( java.awt.GridLayout( 1, 1 ) )
        self.count = 0
        self.components_names = java.util.WeakHashMap()
        self.switch_on_add = switch_on_add
        
    def tabsToTop( self ): self.jtp.setTabPlacement( self.jtp.TOP )
    def tabsToBottom( self ): self.jtp.setTabPlacement( self.jtp.BOTTOM )
    def tabsToRight( self ): self.jtp.setTabPlacement( self.jtp.RIGHT )
    def tabsToLeft( self ): self.jtp.setTabPlacement( self.jtp.LEFT )
        
    def getCurrentTab( self ):
        
        return self.jtp.getSelectedComponent()
        
    def select( self, component ):
        self.jtp.setSelectedComponent( component )
        
    def holdsComponent( self, component ):
        if self.components_names.containsKey( component ):
            return 1
        return 0
        
    def add( self, name, component, switch=True ):
        
        self.components_names[ component ] = name
        if self.count == 0:
            self.base.add( component )
            self.count += 1
        elif self.count == 1:
            children = self.base.getComponents()
            child = children[ 0 ]
            cname = self.components_names[ child ]
            self.jtp.addTab( cname, child )
            self.jtp.addTab( name, component )
            self.base.add( self.jtp )
            if self.switch_on_add and switch:
                self.jtp.setSelectedComponent( component )
            self.count += 1
        else:
            self.jtp.addTab( name, component )
            if self.switch_on_add:
                self.jtp.setSelectedComponent( component )
            self.count += 1
            
    def remove( self, component ):
        
        if self.count:
            parent = component.getParent()
            parent.remove( component )
            self.count -= 1
            del self.components_names[ component ]
            if self.count == 1:
                self.base.remove( self.jtp )
                nwcomponent = self.jtp.getComponentAt( 0 )
                self.base.add( nwcomponent )

            </t>
<t tx="ekr.20070127142814.5">import java.io as io
import org.xml.sax as sax


class DoNothingEntityResolver( sax.EntityResolver ): #This allows us to read XML files that have DTDs mentioned in their header area...
    def resolveEntity( self, arg1, arg2 ):
        ins = sax.InputSource()
        bais = io.ByteArrayInputStream([])
        ins.setByteStream( bais )
        sr = io.StringReader( "" )
        ins.setCharacterStream( sr )
        ins.setPublicId( arg1 )
        ins.setSystemId( arg2 )
        return ins</t>
<t tx="ekr.20070127142814.6">import javax.swing as swing
import java

class JPanelScrollableDelegator( swing.JPanel, swing.Scrollable ):
    
    def __init__( self ):
        swing.JPanel.__init__( self )
        self.delegator = None
        self.setLayout( java.awt.GridLayout( 1, 1 ) )
        
    def setDelegator( self, widget ):
        self.delegator = widget
        
    def getPreferredScrollableViewportSize( self ):
        #print "PREFFERED!"
        #return self.getParent().getSize()
        #parent = self.getParent()
        #return parent.getViewPort().getViewSize()
        #return java.awt.Dimension( 1000, 1000 )
        #return self.delegator.getSize()
        #print self.getParent().getSize()
        #print self.getParent().getPreferredSize()
        return self.delegator.getPreferredScrollableViewportSize()
        
    def getScrollableBlockIncrement( self, visibleRect, orientation, direction):
        #print "SCROLLBI!"
        return self.delegator.getScrollableBlockIncrement( visibleRect, orientation, direction )
        
    def getScrollableTracksViewportHeight( self ):
        print "SCTVH!"
        parent = self.getParent()
        print parent.getSize(), self.delegator.getSize()
        #print getVisibleRect()
        return self.delegator.getScrollableTracksViewportHeight()
        #return False
        
    def getScrollableTracksViewportWidth( self ):
        print "SCTVW"
        parent = self.getParent()
        #print getVisibleRect()
        print parent.getSize(), self.delegator.getSize()
        return self.delegator.getScrollableTracksViewportWidth()
        #return False
        
    def getScrollableUnitIncrement( self, visibleRect, orientation, direction):
        #print "GSUI!"
        return self.delegator.getScrollableUnitIncrement( visibleRect, orientation, direction )

 </t>
<t tx="ekr.20070127142814.7">@language python
import java.lang.ref as ref


class WeakMethod:
    
    def __init__( self, obj, methname ):
        
        self.obj = ref.WeakReference( obj )
        self.methname = methname
        
    def __call__( self, *args ):
        
        obj = self.obj.get()
        if not obj:
            return None
        #print obj
        try:
            meth = getattr( obj, self.methname )
        except Exception, x:
            print "NO METHOD!"
            return None
        return meth( *args )
    
        </t>
<t tx="ekr.20070127142814.8">import javax.swing as swing
import java.awt.event as aevent
import java.awt as awt
import java

class Phaser( swing.JPanel, aevent.ActionListener ):
    '''This class gradually phases a component into the gui when added.
       Also does phasing out if requested.'''
       
    def __init__( self, component ):
        swing.JPanel.__init__( self, awt.GridLayout( 1,1 ) )
        self.add( component )
        self.component = component
        self.increments = 20
        self.waitperiod = 1000/self.increments
        self.timer = swing.Timer( self.waitperiod, self )
        self.timer.start()
        self.image = None
        self.cmp_to_focus = None 
        self.phasingIn = True
        self.setOpaque( True )

    def setComponentToFocus( self, widget ):
        self.cmp_to_focus = widget 
        
    def phaseRemove( self ):
        
        myself = self
        class runner( java.lang.Runnable ):
            def run( self ):
                myself.timer = swing.Timer( myself.waitperiod, myself )
                myself.takePictureOfSelf()
                myself.setOpaque( False )
                myself.remove( myself.component )
                myself.increments = 20
                myself.timer.start()
        swing.SwingUtilities.invokeLater( runner() )
        
    def takePictureOfSelf( self ):
        psize = self.getSize()
        bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
        g = bi.createGraphics()
        self.super__paint( g )
        g.dispose()
        self.image = bi        
            
    def actionPerformed( self, event ):

        self.repaint()
            
    def paint( self, g ):
        
        if self.image == None:
            self.takePictureOfSelf()
            self.setOpaque( False )
            self.remove( self.component )
            self.timer.start()
            
        if self.increments != 0:
            if self.phasingIn:
                self.phaseIn( g )
                return
            else: 
                self.phaseOut( g )
                return
                
        if self.component.getParent() is None:
            self.add( self.component )  
            if self.cmp_to_focus:
                self.cmp_to_focus.requestFocus()      
        self.super__paint( g )
        
    @others
    



</t>
<t tx="ekr.20070127142814.9">def phaseIn( self, g ):
    
    alpha = 1.0/self.increments 
    self.increments -= 1
    if self.increments == 0:
        self.timer.stop()
        self.phasingIn = False
        self.setOpaque( True )
        self.repaint()
    ac = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )
    composite = g.getComposite()
    g.setComposite( ac )
    g.drawImage( self.image, 0, 0, None )
    g.setComposite( composite )
    return    
</t>
<t tx="ekr.20070127142814.10">def phaseOut( self, g ):
    
    
    alpha = self.increments * .05
    self.increments -= 1
    if self.increments == 0:
        self.timer.stop()
        self.phasingIn = False
        self.getParent().remove( self )
        return
    ac = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )
    composite = g.getComposite()
    g.setComposite( ac )
    g.drawImage( self.image, 0, 0, None )
    g.setComposite( composite )
    return   </t>
<t tx="ekr.20070127142814.11">import javax.swing as swing
import java.awt.event as aevent
import java.awt as awt
import java

class Slider( swing.JPanel, aevent.ActionListener ):
    '''This class slides swing components into view, can be slid in 4 directions:
       right, left, up or down.'''
    
    right = "Right";left="Left";up="Up";down="Down"
    
    def __init__( self, component, direction = right, increments = 20, animateperiod = 1000  ):
        swing.JPanel.__init__( self )
        self.setLayout( awt.GridLayout( 1,1 ) )
        self.component = component
        self.add( component )
        self.increments = increments
        self.resetincrements = increments
        self.percentage = (100/increments) * .01
        self.waitperiod = animateperiod/self.increments
        self.timer = swing.Timer( self.waitperiod, self )
        self.image = None
        self.bgimage = None
        self._parent = None
        self.direction = direction
        self.slidingIn = True
        self.cmp_to_focus = None
        self.setOpaque( True )#We have to call this, native and synth set this property to False as default!
    
    def startRemoving( self ):
        
        myself = self
        class runner( java.lang.Runnable ):
            def run( self ):
                myself.timer = swing.Timer( myself.waitperiod, myself )
                myself.takePictureOfSelf()
                myself.setOpaque( False )
                myself.remove( myself.component )
                myself.increments = myself.resetincrements
                myself.timer.start()
        swing.SwingUtilities.invokeLater( runner() )
        
    def setComponentToFocus( self, widget ):
        self.cmp_to_focus = widget

    def takePictureOfSelf( self ):
        psize = self.getSize()
        bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
        g = bi.createGraphics()
        self.super__paint( g )
        g.dispose()
        self.image = bi            
           
    def actionPerformed( self, event ):
        if self.isShowing():
            self.repaint()
        else:
            self.increments -= 1
            self.interpretIncrements()
            
    def interpretIncrements( self ):
        if self.increments == 0:
            self.timer.stop()
            self.timer = None
            if self.slidingIn:
                self.add( self.component )
                if self.cmp_to_focus:
                    self.cmp_to_focus.requestFocus()
                self.slidingIn = False
                self.setOpaque( True )
                self.repaint()
                return
            else:
                parent = self.getParent()
                if parent:
                    parent.remove( self )
                    parent.repaint()
                    return
                                
    def paint( self, g ):
        
        if self.image == None:
            self.takePictureOfSelf()
            self.remove( self.component )
            self.setOpaque( False )
            self.timer.start()
           
        if self.increments != 0:
            try:
                spot = awt.Point( 0, 0 )
                if self.slidingIn:
                    self.slideIn( g, spot )
                else:
                    self.slideOut( g, spot )   
            finally:
                self.increments -= 1
                self.interpretIncrements()
                return

        self.super__paint( g )
        
    @others
</t>
<t tx="ekr.20070127142814.12">def slideIn( self, g , spot ):
    if self.direction == self.right:
        a = self.resetincrements - self.increments
        if a == 0: a = 1
        width = int((self.image.getWidth() * self.percentage ) * a )
        height = self.image.getHeight()
        si = self.image.getSubimage( self.image.getWidth() - width , 0,  width  ,height )
        if g:
            g.drawImage( si, spot.x, spot.y, None )
    elif self.direction == self.left:
        a = self.resetincrements - self.increments
        if a == 0: a = 1
        width = int((self.image.getWidth() * self.percentage ) * a )
        height = self.image.getHeight()
        si = self.image.getSubimage( 0 , 0,  width  ,height )
        if g:
            g.drawImage( si, spot.x + ( self.image.getWidth() - width ) , spot.y, None )
    elif self.direction == self.down:
        a = self.resetincrements - self.increments
        if a == 0: a = 1
        height = int((self.image.getHeight() * self.percentage ) * a )
        width = self.image.getWidth()
        si = self.image.getSubimage( 0, self.image.getHeight() - height , width, height )
        if g:
            g.drawImage( si, spot.x, spot.y, None )
    elif self.direction == self.up:
        a = self.resetincrements - self.increments
        if a == 0: a = 1
        height = int((self.image.getHeight() * self.percentage ) * a )
        width = self.image.getWidth()
        si = self.image.getSubimage( 0, 0 , width, height )
        if g:
            g.drawImage( si, spot.x, spot.y + ( self.image.getHeight() - height ), None )       
</t>
<t tx="ekr.20070127142814.13">def slideOut( self, g , spot ):
    if self.direction == self.right:
        a = self.increments
        width = int((self.image.getWidth() * self.percentage ) * a )
        height = self.image.getHeight()
        si = self.image.getSubimage( self.image.getWidth() - width , 0,  width  ,height )
        if g:
            g.drawImage( si, spot.x, spot.y, None )
    elif self.direction == self.left:
        a = self.increments
        width = int((self.image.getWidth() * self.percentage ) * a )
        height = self.image.getHeight()
        si = self.image.getSubimage( 0 , 0,  width  ,height )
        if g:
            g.drawImage( si, spot.x + ( self.image.getWidth() - width ) , spot.y, None )
    elif self.direction == self.down:
        a = self.increments
        height = int((self.image.getHeight() * self.percentage ) * a )
        width = self.image.getWidth()
        si = self.image.getSubimage( 0, self.image.getHeight() - height , width, height )
        if g:
            g.drawImage( si, spot.x, spot.y, None )
    elif self.direction == self.up:
        a = self.increments
        height = int((self.image.getHeight() * self.percentage ) * a )
        width = self.image.getWidth()
        si = self.image.getSubimage( 0, 0 , width, height )
        if g:
            g.drawImage( si, spot.x, spot.y + ( self.image.getHeight() - height ), None )       
</t>
<t tx="ekr.20070127142814.14">@path org/leo</t>
<t tx="ekr.20070127142814.15">@language java
package org.leo;
import javax.swing.*;
import java.awt.*;

public class ImageJPanel extends JPanel{

    Image image;
    Image last_image;
    AlphaComposite alpha;
    Rectangle lastDimensions;
    
    public ImageJPanel(){
    
       super();
       alpha = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 1.0f );
       image = null;
       last_image = null;
       lastDimensions = new Rectangle( 0, 0, 0, 0 );
           
    }
    
    public void setImage( Image image ){
    
        this.image = image;
    
    }
    
    public void setAlpha( float alpha ){
    
        this.alpha = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, alpha );
    
    }


    public void paintComponent( Graphics g ){
        
        super.paintComponent( g );
        if( image != null ){
            Graphics2D g2 = (Graphics2D)g;
            Rectangle vrec = getVisibleRect();
            if( !vrec.equals( lastDimensions ) ){
            
                lastDimensions = vrec;
                last_image = image.getScaledInstance( vrec.width, vrec.height, Image.SCALE_REPLICATE );
            
            }
            Composite composite = g2.getComposite();
            g2.setComposite( alpha );
            g2.drawImage( last_image, vrec.x, vrec.y, Color.WHITE, null );
            g2.setComposite( composite );
        
        }
    
    
    
    }


}



</t>
<t tx="ekr.20070127142814.16">@language java
package org.leo;

import java.awt.EventQueue;
import javax.swing.*;
import javax.swing.text.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;

public class JTextComponentOutputStream extends OutputStream{

    public static class StringInserter implements Runnable{
    
        JTextComponent jtc;
        String s;
        public StringInserter( JTextComponent jtc, String s ){
            
            this.jtc = jtc;
            this.s = s;
        
        }
        
        public void run(){
        
          try{
            
                Document doc = jtc.getDocument();
                doc.insertString( jtc.getCaretPosition(), s, null );
            
          }
          catch( BadLocationException ble ){}        
        
        
        }
    
    
    
    }

    JTextComponent jtp;
    byte[] bout;
    boolean bonce;
	public JTextComponentOutputStream( JTextComponent jtp ){
    
        super();
        this.jtp = jtp;
        bout = new byte[ 2 ];

    }
    

    public void close(){};
    public void flush(){};
    public void write( byte[] b ){
        
        byte[] b2 = new byte[ b.length ];
        System.arraycopy( b, 0, b2, 0, b.length );
        String s = new String( b2 );
        if( EventQueue.isDispatchThread() ){
        
            try{
            
                Document doc = jtp.getDocument();
                doc.insertString( jtp.getCaretPosition(), s, null );
            
            }
            catch( BadLocationException ble ){}
        
        }
        else{
            StringInserter si = new StringInserter( jtp, s );
            try{
                SwingUtilities.invokeAndWait( si );
            }
            catch( InvocationTargetException ite ){}
            catch( InterruptedException ie ){}
        }
    
    
    }
    
    public void write( byte[] b, int start, int length ){
        
        byte[] b2 = new byte[ length ];
        System.arraycopy( b, start, b2, 0, length );
        String s = new String( b2 );
        if( EventQueue.isDispatchThread() ){
        
            try{
            
                Document doc = jtp.getDocument();
                doc.insertString( jtp.getCaretPosition(), s, null );
            
            }
            catch( BadLocationException ble ){}
        
        }
        else{
            StringInserter si = new StringInserter( jtp, s );
            try{
                SwingUtilities.invokeAndWait( si );
            }
            catch( InvocationTargetException ite ){}
            catch( InterruptedException ie ){}
        }
    
    }
    
    public void write( int b ){
        
        if( bonce ){
        
            bout[ 1 ] = (byte)b;
            if( EventQueue.isDispatchThread() ){
        
                try{
            
                    Document doc = jtp.getDocument();
                    doc.insertString( jtp.getCaretPosition(), new String( bout ), null);
            
                }
                catch( BadLocationException ble ){}
                bout = new byte[ 2 ];
                bonce = false;
        
            }
            else{
                StringInserter si = new StringInserter( jtp, new String( bout ) );
                try{
                    SwingUtilities.invokeAndWait( si );           
                }
                catch( InvocationTargetException ite ){}
                catch( InterruptedException ie ){}
                bout = new byte[ 2 ];
                bonce = false;
            }     
        
        }
        else{
        
            bout[ 0 ] = (byte)b;
            bonce = true;
        }
    
    }


}</t>
<t tx="ekr.20070127142814.17">@path org/leo/shell
</t>
<t tx="ekr.20070127142814.18">&lt;?xml version="1.0" ?&gt;
&lt;project default="main"&gt;
    &lt;target name="main" depends="compile" &gt;
        &lt;echo&gt;JythonShell built&lt;/echo&gt;
    &lt;/target&gt;
    
    &lt;target name="compile"&gt;
        &lt;echo&gt;Building shell package&lt;/echo&gt;
        &lt;javac srcdir="." listfiles="true" /&gt;
        &lt;echo&gt;Building util package&lt;/echo&gt;
        &lt;javac srcdir="./util" listfiles="true"/&gt;
        &lt;echo&gt;Building io package&lt;/echo&gt;
        &lt;javac srcdir="./io" listfiles="true" /&gt;
        &lt;echo&gt;Building magic package&lt;/echo&gt;
        &lt;javac srcdir="./magic" listfiles="true" /&gt;
        &lt;echo&gt;Building actions package&lt;/echo&gt;
        &lt;javac srcdir="./actions" listfiles="true" /&gt;
        &lt;echo&gt;Building alias package&lt;/echo&gt;
        &lt;javac srcdir="./alias" listfiles="true" /&gt;
        &lt;echo&gt;Building widget pacakge&lt;/echo&gt;
        &lt;javac srcdir="./widget" listfiles="true" /&gt;
        &lt;echo&gt;Building color package&lt;/echo&gt;
        &lt;javac srcdir="./color" listfiles="true" /&gt;
    &lt;/target&gt;

&lt;/project&gt;</t>
<t tx="ekr.20070127142814.19">import javax.swing as swing
import java.util as util
import sys
print sys.argv
print __name__
print globals()
print locals()

jf = swing.JFrame()
d = [ 'mooo', 'maaa', 'meee', 'yoooo' ]
v = util.Vector( d )
jcb = swing.JComboBox( v )
jcb.setEditable( 1 )
jf.add( jcb )

class aa( swing.AbstractAction ):
    def __init__( self ):
        swing.AbstractAction.__init__( self )
        self.count = 1
        
    def actionPerformed( self, event ):
        print self.count
        print event.getID()
        print event.getSource()
        self.count += 1
        print "-" * 5
        print event
        

jcb.addActionListener( aa() )

jf.visible = 1</t>
<t tx="ekr.20070127142814.20">import javax.swing as swing
import javax.swing.border as sborder
import java.awt as awt
import java.awt.event as aevent

class fl( aevent.MouseAdapter ):
    def __init__( self, item ):
        aevent.MouseAdapter.__init__( self )
        self.item = item
        
    def mouseEntered( self, event ):
        print "FOCUS GAING"
        self.item.setBorder( sborder.LineBorder( awt.Color.BLACK ) )
    def mouseExited( self, event ):
        print "FOCUS LOST"
        self.item.setBorder( None )
        
class Border2( sborder.Border ):
    def __init__( self ):
        pass
        
    def getBorderInsets( self, c ):
        insets = awt.Insets( 0, 15, 0, 0 )
        return insets
    def isBorderOpaque( self ): return True
    def paintBorder( self, c, g, x, y, width, height):
        
        gp = awt.GradientPaint( 0.0, 0.0, awt.Color.BLUE, 0.0, 1.0 * height, awt.Color.CYAN )
        paint = g.getPaint()
        g.setPaint( gp )
        #g.setColor( awt.Color.BLUE )
        g.fillRect( 1, 1, 13, height -2 )
        g.setPaint( paint )
        
class JMenu2( swing.JMenu ):
    def __init__( self ):
        swing.JMenu.__init__( self )
        self.widget = None
        pu = self.getPopupMenu()
        pu.setBackground( awt.Color.ORANGE )
        tborder = sborder.TitledBorder( "Yup" )
        pu.setBorder( Border2() )
        
    def setWidget( self, widget ):
        self.widget = widget
    
    def getPreferredSize( self ):
        
        ps = self.super__getPreferredSize();
        size = self.widget.getSize()
        ps.height = size.height
        return ps
       
    def getPopupMenuOrigin( self ):
        rv = self.super__getPopupMenuOrigin()
        l1 = self.widget.getLocation()
        l2 = self.getLocation()
        rv.x = rv.x - ( l2.x - l1.x ) 
        return rv
        

jf = swing.JFrame()
jmb = swing.JMenuBar()
jf.setJMenuBar( jmb )
jmb2 = swing.JMenuBar()
jb = swing.JButton( "mobers" )
jb.setBorder( None )
jb.setVerticalTextPosition( jb.BOTTOM )
print jb.getBorder()
jb.setOpaque( False )
jb.setBackground( awt.Color.ORANGE )
jmb2.add( jb )
jm = JMenu2()
jm.setBackground( awt.Color.ORANGE )
jm.setOpaque( False )
jm.setWidget( jb )
jmb2.add( jm )
jmb2.setBackground( awt.Color.ORANGE )
slayout = swing.SpringLayout()
jmb2.setLayout( slayout )
slayout.putConstraint( slayout.WEST, jb, 0, slayout.WEST, jmb2 )
slayout.putConstraint( slayout.SOUTH, jmb2, 0, slayout.SOUTH, jb )

slayout.putConstraint( slayout.WEST, jm, 0, slayout.EAST, jb )
slayout.putConstraint( slayout.NORTH, jm, 0, slayout.NORTH, jb )
slayout.putConstraint( slayout.SOUTH, jm, 0, slayout.SOUTH, jb )
slayout.putConstraint( slayout.EAST, jmb2, 0, slayout.EAST, jm )
slayout.putConstraint( slayout.NORTH, jmb2, 0, slayout.NORTH, jb )


#jmb.add( jmb2 )
jmb3 = swing.JMenuBar()
jmb3.add( jmb2 )
jf.add( jmb3 )
ii = swing.ImageIcon( "/home/brihar/jyportLeo/arrow.gif" )
ii2 = swing.ImageIcon( "/home/brihar/jyportLeo/moveup.gif" )
jb.setIcon( ii2 )
jb.setVerticalTextPosition( jb.BOTTOM ) 
jb.setHorizontalTextPosition( jb.CENTER )
jmi = swing.JMenuItem( "BORK" )
jm.add( jmi )
jm.setIcon( ii )
#jm.addMouseListener( fl( jm ) )
#jm.setFocusable( True )
#jm.setRolloverEnabled( 1 )
#jm.setFocusPainted( True )
#jm.setBorder( sborder.LineBorder( awt.Color.BLACK ) )
jm2 = swing.JMenu( "GOOD" )
jm.add( jm2 )

jf.visible = 1</t>
<t tx="ekr.20070127142814.21">import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.table as table
import java

&lt;&lt;double table model&gt;&gt;
&lt;&lt;table internals&gt;&gt;

internals = Internals()
lsl1 = ListSelectionModelDecorator( internals )
lsl2 = ListSelectionModelDecorator( internals, which = 0 )
        
class JTable2( swing.JTable ):
    def __init__( self ):
        swing.JTable.__init__( self )
        self.selectedPairs = []
    
    def isCellSelected( self, a, b ):
        
        sm1 = self.getSelectionModel()
        return sm1.internals.isSelected( a, b )
        
    def changeSelection( self, a,b,c,d ):
        
        print c,d
        sm1 = self.getSelectionModel()
        if sm1.internals.isSelected( a, b ):
            sm1.internals.removeSelection( a, b )
        else:
            sm1.internals.addSelection( a,b )
        
        
jf = swing.JFrame();
jt = JTable2()
jsp = swing.JScrollPane( jt )
jf.add( jsp )
jt.setColumnSelectionAllowed( True )
#jt.setRowSelectionAllowed( False )
a = [ [ 'a','b','c'], [ 'd','e','f'], [ 'x','x','x'], ['z','z','z'] ]
b = [ 'cat', 'dog', 'moo' ]
dtm = table.DefaultTableModel( a, b )
jt.setModel( dtm )


jt.setSelectionModel( lsl1 )
cm = jt.getColumnModel()
cm.setSelectionModel( lsl2 )
jf.pack()
jf.visible = 1

</t>
<t tx="ekr.20070127142814.22">class ListSelectionModelDecorator( swing.ListSelectionModel ):

    def __init__( self, internals, which = 1 ):
        self.internals = internals
        self.which = which

    def addListSelectionListener( self, x):
        if self.which:
            self.internals.addRowListener( x )
        else:
            self.internals.addColumnListener( x )
        
    def addSelectionInterval(self, index0, index1):
        pass
    def clearSelection( self ):
        pass 
    def getAnchorSelectionIndex( self ):
        
        if not self.internals.anchor: return -1
        if self.which:
            return self.internals.anchor[ 0 ]
        else:
            return self.internals.anchor[ 1 ]
             
    def getLeadSelectionIndex( self ):
        
        if not self.internals.lead: return -1
        if self.which:
            return self.internals.lead[ 0 ]
        else:
            return self.internals.lead[ 1 ]
        
    def getMaxSelectionIndex( self ):
        pass
    def getMinSelectionIndex( self ):
        pass
        
    def getSelectionMode( self ):
        pass
    def getValueIsAdjusting( self ):
        return False
        
    def insertIndexInterval( self, index, length, before):
        pass
    def isSelectedIndex( self, index):
        pass 
    def isSelectionEmpty( self ):
        pass 
    def removeIndexInterval( self, index0, index1):
        pass
    def removeListSelectionListener( self, x):
        if self.which:
            self.internals.removeRowListener( x )
        else:
            self.internals.removeColumnListener( x )
        
    def removeSelectionInterval( self, index0, index1):
        pass
    def setAnchorSelectionIndex( self, index):
        pass
    def setLeadSelectionIndex( self, index):
        pass
    def setSelectionInterval( self, index0, index1):
        pass
    def setSelectionMode( self, selectionMode):
        pass
        
    def setValueIsAdjusting( self, valueIsAdjusting ):
        pass

</t>
<t tx="ekr.20070127142814.23">class Internals:
    
    def __init__( self ):
        self.selections = {}
        self.rowlisteners = []
        self.columnlisteners = []
        self.lead = None
        self.anchor = None

    def addSelection( self, a, b ):
        self.selections[ (a,b ) ] = None
        self.lead = ( a, b )
        lse1 = sevent.ListSelectionEvent( self, a,a,False )
        lse2 = sevent.ListSelectionEvent( self, b,b,False ) 
        for z in self.rowlisteners:
            print z
            z.valueChanged( lse1 )
        for z in self.columnlisteners:
            print z
            z.valueChanged( lse2 ) 
        print "DONES"

    def isSelected( self, a,b ):
        x = (a,b )
        return self.selections.has_key( x )
        
    def removeSelection( self, a, b ):
        x = (a,b )
        del self.selections[ x ]
        lse1 = sevent.ListSelectionEvent( self, a,a,False )
        lse2 = sevent.ListSelectionEvent( self, b,b,False )
        for z in self.rowlisteners:
            print z
            z.valueChanged( lse1 )
        for z in self.columnlisteners:
            print z
            z.valueChanged( lse2 )
        print "DONE"
        
    def addRowListener( self, listener ):
        if listener not in self.rowlisteners:
            self.rowlisteners.append( listener )
            
    def removeRowListener( self, listener ):
        if listener in self.rowlisteners:
            self.rowlisteners.remove( listener )
            
    def addColumnListener( self, listener ):
        if listener not in self.columnlisteners:
            self.columnlisteners.append( listener )
            
    def removeColumnListener( self, listener ):
        if listener in self.columnlisteners:
            self.columnlisteners.remove( listener )
            

</t>
<t tx="ekr.20070127142814.24">@language java
package org.leo.shell;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;

public class IsolatedJythonClassLoader extends ClassLoader{

    final static Map&lt;String, byte[]&gt; classes = new HashMap&lt; String, byte[] &gt;();
    final static ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor( 1 );
    final static LinkedBlockingQueue shellqueue = new LinkedBlockingQueue();
    final private Map&lt;String, Class&gt; ld_classes = new HashMap&lt; String, Class&gt;();
    final static List&lt;File&gt; a_directories = new ArrayList&lt;File&gt;();
    
    
    public static void addToSearchPath( final File directory ){
    
        System.out.println( directory );
        a_directories.add( directory );
    
    
    }
    
    
    final static class LoadJythonTask implements Runnable{
    
        public void run(){
        
            try{
            
                final IsolatedJythonClassLoader ijcl = new IsolatedJythonClassLoader();
                final Class clazz = ijcl.loadClass( "org.leo.shell.JythonShell" );
                final Object o = clazz.newInstance();
                for( String s: force_load ){ //here we load the classes that slow down the first inputs...
                    
                    try{
                    
                        ijcl.loadClass( s );
                    
                    }
                    catch( ClassNotFoundException cnfe ){
                    
                        System.out.println( cnfe );
                    
                    }
                    
                
                
                
                }
            
                shellqueue.put( o );
            
                   
            }
            catch( Exception x ){ x.printStackTrace();}
        
        }    
    
    }
    
    public static void beginLoading(){
    
        final LoadJythonTask ljt = new LoadJythonTask();
        ses.schedule( ljt, 1000, TimeUnit.MILLISECONDS );
    
    
    }
    
    public static Object getJythonShell(){
    
        try{
            
            Object o;
            if( shellqueue.peek() != null || ses.getActiveCount() &gt; 0 )
                o = shellqueue.take();
            else{
            
                LoadJythonTask ljt = new LoadJythonTask();
                ses.execute( ljt );
                o = shellqueue.take();
                
            }
            
            
            final LoadJythonTask ljt = new LoadJythonTask();
            ses.schedule( ljt, 1000, TimeUnit.MILLISECONDS );
            return o;
            
        }
        catch( Exception x ){ x.printStackTrace();}
        return null;
    
    }
    
    
    public IsolatedJythonClassLoader(){
    
        super();
    
    }



    public final Class getIsolatedClass( final String name ){
        
        byte[] data2;
        if( classes.containsKey( name ) ){
         data2 = classes.get( name );
         
         }
        else{
            InputStream ins = getSystemResourceAsStream( name );
            if( ins == null ){
                //System.out.println( name );
                for( File f: a_directories ){
                    

                    
                    if( !f.isDirectory() ) continue;
                    String[] pieces = name.split( "\\." );
                    StringBuilder sb = new StringBuilder();
                    if( pieces.length &gt; 2 ){
                    
                        for( int i = 0; i &lt; pieces.length - 2; i++ ) sb.append( pieces[ i ] ).append( File.separatorChar );
                        int spot = pieces.length -2;
                        int spot2 = pieces.length -1;
                        sb.append( pieces[ spot ] );
                        sb.append( "." );
                        sb.append( pieces[ spot2 ] );
                    
                    }
                    else{
                    
                        for( String s: pieces ) sb.append( s );
                    
                    }
                    String nwpath = sb.toString();
                    File f2 = new File( f, nwpath );
                    //System.out.println(f2);
                    if( f2.exists() ){
                    
                        try{
                            ins = new FileInputStream( f2 );
                            break;
                        }
                        catch( FileNotFoundException fnfe ){}
                    
                    }
        
                    if( ins != null ) break;
                }
                if( ins == null ) return null;
                               
            }
            ArrayList&lt;Byte&gt; ba = new ArrayList&lt;Byte&gt;();
            try{
        
                while( true ){
            
                    int i = ins.read();
                    if( i == -1 ) break;
                    ba.add( (byte)i );
            
            
                }
        
        
            }
            catch( IOException io ){
        
                System.out.println( io );
                return null;
            
            }
            Byte[] data = ba.toArray( new Byte[]{} );
            data2 = new byte[ data.length ];
            for( int i = 0; i &lt; data.length; i ++ )
                data2[ i ] = data[ i ];
            classes.put( name, data2 );
        }
        
        final Class c = defineClass( null, data2, 0, data2.length );
        resolveClass( c );
        return c;
    
    }

    public Class loadClass( final String name ) throws ClassNotFoundException{
    
        if( ld_classes.containsKey( name ) ) return ld_classes.get( name );
        if( name.startsWith( "org.leo.shell" ) ){
        
            final Class clazz = getIsolatedClass( name + ".class" );
            if( clazz == null ) throw new ClassNotFoundException( "Could not find: " + name );
            ld_classes.put( name, clazz );
            return clazz;
        
        }
        else if( name.startsWith( "org.python" ) ){
        
            final String newname = name.replace( '.', '/' ) + ".class";
            //System.out.println(newname);
            //final String newname = name + ".class";
            final Class clazz = getIsolatedClass( newname );
            if( clazz == null ) throw new ClassNotFoundException( "Could not find: " + name );
            ld_classes.put( name, clazz );
            return clazz;
        
        
        }
        return super.loadClass( name );    
    
    }

static final String[] force_load = new String[]{
"org.python.parser.PythonGrammarConstants",
"org.python.core.parser",
"org.python.parser.CharStream",
"org.python.parser.Node",
"org.python.parser.IParserHost",
"org.python.core.FixMacReaderBug",
"org.python.core.LiteralMakerForParser",
"org.python.parser.PythonGrammar",
"org.python.parser.PythonGrammarTreeConstants",
"org.python.parser.ParseException",
"org.python.parser.PythonGrammar$LookaheadSuccess",
"org.python.parser.TokenMgrError",
"org.python.parser.ReaderCharStream",
"org.python.parser.JJTPythonGrammarState",
"org.python.parser.IntStack",
"org.python.parser.TreeBuilder",
"org.python.parser.SimpleNode",
"org.python.parser.ast.exprType",
"org.python.parser.ast.stmtType",
"org.python.parser.ast.AugAssign",
"org.python.parser.ast.operatorType",
"org.python.parser.ast.Interactive",
"org.python.parser.ast.modType",
"org.python.parser.ast.Module",
"org.python.parser.ast.Expression",
"org.python.parser.ast.Name",
"org.python.parser.ast.expr_contextType",
"org.python.parser.ast.Num",
"org.python.parser.ast.Str",
"org.python.parser.ast.Suite",
"org.python.parser.ast.Assign",
"org.python.parser.ast.Expr",
"org.python.parser.ast.Subscript",
"org.python.parser.ast.Attribute",
"org.python.parser.ast.Delete",
"org.python.parser.ast.Print",
"org.python.parser.ast.For",
"org.python.parser.ast.While",
"org.python.parser.ast.If",
"org.python.parser.ast.Pass",
"org.python.parser.ast.Break",
"org.python.parser.ast.Continue",
"org.python.parser.ast.FunctionDef",
"org.python.parser.DefaultArg",
"org.python.parser.ExtraArg",
"org.python.parser.ast.ClassDef",
"org.python.parser.ast.Return",
"org.python.parser.ast.Yield",
"org.python.parser.ast.Raise",
"org.python.parser.ast.Global",
"org.python.parser.ast.Exec",
"org.python.parser.ast.Assert",
"org.python.parser.ast.TryFinally",
"org.python.parser.ast.TryExcept",
"org.python.parser.ast.excepthandlerType",
"org.python.parser.ast.BoolOp",
"org.python.parser.ast.boolopType",
"org.python.parser.ast.Compare",
"org.python.parser.ast.cmpopType",
"org.python.parser.ast.BinOp",
"org.python.parser.ast.UnaryOp",
"org.python.parser.ast.unaryopType",
"org.python.parser.ast.Call",
"org.python.parser.ExtraArgValue",
"org.python.parser.ast.keywordType",
"org.python.parser.ast.Tuple",
"org.python.parser.ast.ListComp",
"org.python.parser.ast.List",
"org.python.parser.ast.Dict",
"org.python.parser.ast.Repr",
"org.python.parser.ast.Lambda",
"org.python.parser.ast.Ellipsis",
"org.python.parser.ast.sliceType",
"org.python.parser.ast.Index",
"org.python.parser.ast.Slice",
"org.python.parser.ast.ExtSlice",
"org.python.parser.ast.listcompType",
"org.python.parser.ast.ImportFrom",
"org.python.parser.ast.Import",
"org.python.parser.ast.aliasType",
"org.python.parser.CtxVisitor",
"org.python.parser.Visitor",
"org.python.parser.ast.VisitorBase",
"org.python.parser.ast.VisitorIF",
"org.python.parser.PythonGrammar$JJCalls",
"org.python.parser.PythonGrammarTokenManager",
"org.python.parser.Token",
"org.python.parser.IdentityNode",
"org.python.compiler.Module",
"org.python.compiler.ClassConstants",
"org.python.compiler.CompilationContext",
"org.python.compiler.Attribute",
"org.python.compiler.SourceFile",
"org.python.compiler.APIVersion",
"org.python.compiler.Constant",
"org.python.compiler.PyCodeConstant",
"org.python.compiler.PyLongConstant",
"org.python.compiler.PyStringConstant",
"org.python.compiler.PyComplexConstant",
"org.python.compiler.PyFloatConstant",
"org.python.compiler.PyIntegerConstant",
"org.python.compiler.ClassFile",
"org.python.compiler.ConstantPool",
"org.python.compiler.Future",
"org.python.compiler.ScopesCompiler",
"org.python.compiler.ScopeConstants",
"org.python.compiler.ScopeInfo",
"org.python.compiler.Code",
"org.python.compiler.Bytes",
"org.python.compiler.Method",
"org.python.compiler.CodeCompiler",
"org.python.compiler.Label",
"org.python.compiler.LineNumberTable",
"org.python.core.BytecodeLoader",
"org.python.core.Loader",
"org.python.core.BytecodeLoader2",
"org.python.core.PyFunctionTable",
"org.python.core.PyGenerator" };


}</t>
<t tx="ekr.20070127142814.25">@language java
package org.leo.shell;
import java.io.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;

public class DorkClassLoader extends ClassLoader{


    int i;
    Map&lt; String , Class &gt; haveseen;
    public DorkClassLoader(){
    
        haveseen = new HashMap&lt;String, Class&gt;();
    
    }
    
    public DorkClassLoader( ClassLoader parent ){
    
        super( parent );
        haveseen = new HashMap&lt;String, Class&gt;();
    
    }

    public Class loadClass( final String name ) throws ClassNotFoundException{
        
        if( !name.startsWith( "org.leo" ) ) return super.loadClass( name );
        System.out.println( name );
        String newname = name.replaceAll( "\\.", "/" );
        newname += ".class";
        System.out.println( newname );
        InputStream is = getResourceAsStream( newname );
        List&lt;Byte&gt; bytes = new ArrayList&lt;Byte&gt;();
        try{
            while( true ){
        
                int i = is.read();
                if( i == -1 ) break;
                bytes.add( (byte)i );
        
        
            }
        }
        catch(IOException io ){}
        byte[] barray = new byte[ bytes.size() ];
        for( int i = 0; i&lt; barray.length; i ++ )
            barray[ i ] = bytes.get( i );
  
        if( haveseen.containsKey( name ) ){
        
            DorkClassLoader dcl = new DorkClassLoader( this );
            return dcl.loadClass( name );        
        
        }      
        Class c;
        c = defineClass( name , barray, 0, barray.length );
        haveseen.put( name, c );
  
        resolveClass( c );
        return c;
    }

}</t>
<t tx="ekr.20070127142814.26">@language java
package org.leo.shell;

import org.leo.shell.color.ColorConfiguration;
import javax.swing.*;
import javax.swing.text.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import org.python.core.*;

public class Autocompleter implements KeyListener, UtilityBoxListener, Documentation{

    JTextPane _jtp;
    JList _autocompleter;
    Popup pu2;
    PopupFactory pf;
    JythonShell js;
    
    public Autocompleter( JythonShell js, JTextPane _jtp ){
        this.js = js;
        this._jtp = _jtp;
        pf = PopupFactory.getSharedInstance();
        js.getShellComponent().addKeyListener( this );
        js.addUtilityBoxListener( this );
        js.addInteractiveDocumentation( this );
    }
    
    public String getDocumentation(){
    
        return "Autocompletion:\n"+
        "Upon typing '.' the JythonShell will scan the object for attributes and "+
        "methods.  Upon finding these items a popup will appear allowing the user to select "+
        "items for completion.  To navigate the box, use the up and down arrow keys.  To choose a "+
        "completeion, press Tab.  To dismiss, press Esc\n";
    }

    public final void keyPressed( final KeyEvent event ){
        &lt;&lt;keymanipulation&gt;&gt;
    }

    public final void keyReleased( final KeyEvent event ){
        //event.consume();
    }

    public final void keyTyped( final KeyEvent event ){
        //event.consume(); 
    }

    @others
}</t>
<t tx="ekr.20070127142814.27">final char which = event.getKeyChar();
final int kc = event.getKeyCode();
String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
if( _autocompleter != null ){
    
    if( event.VK_SHIFT == kc ) return;
    if( event.VK_TAB == kc ){
        
        try{
            
            event.consume();
            final String val = (String)_autocompleter.getSelectedValue();
            pu2.hide();
            _autocompleter = null;
            final Document doc = _jtp.getDocument();
            final String line = doc.getText( js.outputspot, _jtp.getCaretPosition() - js.outputspot );
            final String[] tokens = line.split( "\\." );
            if( tokens.length &gt; 1 &amp;&amp; !line.endsWith( "." )){
                
                final int tk_len = tokens[ tokens.length - 1 ].length();
                int end = js.endOfLine();
                doc.remove( end - tk_len, tk_len );
                end = js.endOfLine();
                _jtp.setCaretPosition( end );
                    
            }
            doc.insertString( _jtp.getCaretPosition(), val, null );
            return;
            
        }
        catch( final Exception x ){
            x.printStackTrace();
            
        }
        
    }
    else if( event.VK_UP == kc || event.VK_DOWN == kc ){
        
        event.consume();
        int index = _autocompleter.getSelectedIndex();
        if( event.VK_UP == kc ) index--;
        else index++;
        _autocompleter.setSelectedIndex( index );
        _autocompleter.ensureIndexIsVisible( index );
        return;
        
        
        
    }
        
    try{
            
        if( !Character.isLetterOrDigit( which ) &amp;&amp; event.VK_BACK_SPACE != kc &amp;&amp; which != '_' ){
            
            //background.remove( _ac_frame );
            pu2.hide();
            _autocompleter = null;
            pu2 = null;
            //background.revalidate();  
            
        }
        else{
            
                
            String line = js.get_input( _jtp.getCaretPosition() ) + which;
            final String[] tokens = line.split( "\\.");
                
            if( tokens.length &gt;= 2 ){
        
                final String token = tokens[ tokens.length -1 ];
                final int next = _autocompleter.getNextMatch( token, 0, Position.Bias.Forward );
                if( next != -1 ){
                
                    _autocompleter.setSelectedIndex( next );
                    _autocompleter.ensureIndexIsVisible( next );
                    
                }
                
        
            
            
                }
            
            }
        }
            
        catch( Exception x ){
            x.printStackTrace();

        
        }
    
    
}
if( kc == event.VK_ESCAPE ) hide(); 
if( which == '.' ) autocomplete(); </t>
<t tx="ekr.20070127142814.28">public final void showAutocompleter( final Vector&lt;String&gt; v ){

    Collections.sort( v );
    int cpos = _jtp.getCaretPosition();
    Rectangle vpos = null;
    try{
    
        vpos = _jtp.modelToView( cpos );  
    
    }
    catch( Exception x ){
        
        x.printStackTrace();
        return;
    
    
    }
    if( vpos == null ) return;
    Iterator&lt;String&gt; si = v.iterator();
    while( si.hasNext() ){
    
        String s = si.next();
        if( s.trim().equals( "" ) ) si.remove(); // if we don't purge bad values, the list has a terrible visual appearance.
    
    
    }
    final JList jl = new JList( v );
    ColorConfiguration cc = js.getColorConfiguration();
    jl.setForeground( cc.getForegroundColor() );//js._fg );
    jl.setBackground( cc.getBackgroundColor() ); //js._bg );
    jl.addListSelectionListener( js._lsl );
    jl.setSelectedIndex( 0 );
    jl.setLayoutOrientation( JList.VERTICAL );
    final JScrollPane jsp = new JScrollPane( jl );
    if( v.size() &gt;= 5 ){
        jl.setVisibleRowCount( 5 );
    
    }
    else
        jl.setVisibleRowCount( v.size() );

    Dimension jlsize =  jl.getPreferredScrollableViewportSize();
    JScrollBar jsb = jsp.getVerticalScrollBar();
    Dimension jsbsize = jsb.getPreferredSize();
    jlsize.width = jlsize.width + jsbsize.width;
    jsp.setPreferredSize( jlsize ); 
    jsp.setMinimumSize( jlsize );
    jsp.setHorizontalScrollBarPolicy( jsp.HORIZONTAL_SCROLLBAR_NEVER );
    Dimension jsps = jsp.getPreferredSize();

    Point p = new Point( vpos.x, vpos.y );
    SwingUtilities.convertPointToScreen( p, _jtp );
    Rectangle vrect = js._jsp.getViewport().getVisibleRect();
    Point p2 = new Point( vrect.x + vrect.width, vrect.y + vrect.height );
    SwingUtilities.convertPointToScreen( p2, js._jsp.getViewport() );
    if( p.y &lt; p2.y/2 ){
        pu2 = pf.getPopup( _jtp, jsp, p.x , p.y + vpos.height  );
    
    }
    else{
        pu2 = pf.getPopup( _jtp, jsp, p.x, p.y - jsps.height );
        
    }
    pu2.show();
    _autocompleter = jl;
    //_ac_frame = jp;

}


</t>
<t tx="ekr.20070127142814.29">public final void autocomplete(){


    try{
    
    int start = js.startOfLine();
    int end = _jtp.getCaretPosition();
    final Document doc = _jtp.getDocument();
    String txt = doc.getText( start, end - start );
    

    final String split1[] = txt.split( "\\s" );
    String nxsplit = txt;
    if( split1.length &gt; 0 )
        nxsplit = split1[ split1.length -1 ];
    final String[] split2 = nxsplit.split( "\\." );
    
    final String nxsplit2 = nxsplit.substring( 0, nxsplit.length() -1 );
    
    PyObject po1 = js.getPyObject( split2 );
    
    //err.reset();
    //out.reset();
    if( po1 == null ) return;
    PyList pl = (PyList)po1.__dir__();
    
    //LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet();
    //Vector&lt; String &gt; atts = getAttributes( po1 ).get( "Attribute" );
    //Vector&lt; String &gt; fields = getFields( po1 ).get( "Field" );
    //Vector&lt; String &gt; methods = getMethods( po1 ).get( "Method" );

    
    //lhs.addAll( atts );
    //lhs.addAll( fields );
    //lhs.addAll( methods );
    
    
    
    final Vector&lt; String &gt; v = new Vector&lt;String&gt;();
    for( Object o: pl.toArray() )
        v.add( (String)o );
    
    //out.reset();
    //err.reset();
    //System.out.println( v );
    if( v.size() != 0 ) showAutocompleter( v );
    
    
    }
    
    
    
    catch( Exception x ){
    
        x.printStackTrace();
    
    }


}



</t>
<t tx="ekr.20070127142814.30">public void hide(){

    if( pu2 != null ){
    
        pu2.hide();
        pu2 = null;
        _autocompleter = null;
    
    }



}

public boolean isShowing(){

    return pu2 != null;


}</t>
<t tx="ekr.20070127142814.31">public void utilityBoxShown( UtilityBoxEvent ube ){




}

public void utilityBoxClose( UtilityBoxEvent ube ){

    hide();


}</t>
<t tx="ekr.20070127142814.32">@language java
package org.leo.shell;
import javax.swing.*;
import java.lang.reflect.*;
import javax.swing.text.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import org.python.core.*;


public class Calltip implements KeyListener,UtilityBoxListener{

    JythonShell js;
    PopupFactory pf;
    Popup pu;
    JTextPane _jtp;
    
    public Calltip( JythonShell js ){
    
        this.js = js;
        this._jtp = (JTextPane)js.getShellComponent();
        pf = PopupFactory.getSharedInstance();
        js.getShellComponent().addKeyListener( this );
        js.addUtilityBoxListener( this );
        
    }


    public final void keyPressed( final KeyEvent event ){
        final int kc = event.getKeyCode();
        if( kc == event.VK_BACK_SPACE &amp;&amp; pu != null ){
            int cp = _jtp.getCaretPosition(); 
            if( cp  == js.outputspot ) event.consume();
            Document doc = _jtp.getDocument();
            try{
                String s = doc.getText( cp -1, 1 );
                if( s.equals( "(" ) &amp;&amp; pu != null ){
                    hide();
                }
            }
            catch( BadLocationException ble ){}           
            return;
             
        }
        if( kc == event.VK_DELETE ) hide();
        if( kc == event.VK_ESCAPE ) hide();
        if( event.isConsumed() ) return;
        final char which = event.getKeyChar(); 
        if( which == '(' ) calltip(); 

    }


    public final void keyReleased( final KeyEvent event ){

        //event.consume();

    } 

    public final void keyTyped( final KeyEvent event ){

        //event.consume();

    } 

    @others

}</t>
<t tx="ekr.20070127142814.33">public void calltip(){

    if( pu != null ){
        
        pu.hide();
        pu = null;
        
    }

    int start = js.startOfLine();
    int end = _jtp.getCaretPosition();
    final Document doc = _jtp.getDocument();
    String txt = null;
    try{
        txt = doc.getText( start, end - start );
    }
    catch( BadLocationException ble ){ return; }

    final String split1[] = txt.split( "\\s" );
    String nxsplit = txt;
    if( split1.length &gt; 0 )
        nxsplit = split1[ split1.length -1 ];
    final String[] split2 = nxsplit.split( "\\." );
    
    //final String nxsplit2 = nxsplit.substring( 0, nxsplit.length() -1 );
    StringBuilder sb = null;
    PyObject po1 = js.getPyObject( split2 );
    if( po1 == null ){

        return;
    
    };
    
    PyObject docobj = null;
    if( po1 instanceof PyMethod ){
        PyMethod pm = (PyMethod)po1;
        PyObject po2 = pm.im_func;
        //System.out.println( po2.getClass() );
        if( po2 instanceof PyFunction ){
            
            PyFunction pf = (PyFunction)po2;
            docobj = pm;
            sb = calltip_python( pf, true );
    
        }
        else if( po2 instanceof PyReflectedFunction ){
        
            PyReflectedFunction prf = (PyReflectedFunction)po2;
            sb = calltip_java( prf, split2 );

        }
    }
    else if( po1 instanceof PyReflectedFunction ){
    
        PyReflectedFunction prf = (PyReflectedFunction)po1;
        sb = calltip_java( prf, split2 );
    
    
    }
    else if( po1 instanceof PyFunction ){
    
        PyFunction pf = (PyFunction)po1;
        docobj = pf;
        sb = calltip_python( pf, false );
    
    
    }
    else if( po1 instanceof PyJavaClass ){
    
        PyJavaClass pjc = (PyJavaClass)po1;
        Class clazz = null;
        try{
            clazz = Class.forName( pjc.__name__ );
            //System.out.println( clazz );
        }
        catch( Exception x ){ return; }
        sb = calltip_jconstructor( clazz );
        
    
    
    }
    else if( po1 instanceof PyClass ){
    
        PyClass pc = (PyClass)po1;
        String[] split3 = new String[ split2.length + 1];
        System.arraycopy( split2, 0, split3, 0 , split2.length );
        split3[ split3.length -1 ] = "__init__";
        PyObject po3 = js.getPyObject( split3 );
        if( po3 instanceof PyMethod ){
            PyMethod pm = (PyMethod)po3;
            PyFunction po2 = (PyFunction)pm.im_func;
            sb = calltip_python( po2, true );
        }
        docobj = po1;
    
    }
    StringBuilder ds = null;
    if( docobj != null ){
        try{
            
            Object o = docobj.__findattr__( "__doc__" );
            if( o != null &amp;&amp; o != Py.None ){
                ds = new StringBuilder();
                String docstring = o.toString();
                ds.append( "'''" );
                ds.append( docstring );
                ds.append( "'''" );
                if( !docstring.endsWith( "\n" ) &amp;&amp; sb != null )  ds.append( '\n' );
            
            }
        }
        catch( Exception x ){}
    }

    
    if( ( sb != null &amp;&amp; sb.length() != 0 ) || ( ds != null &amp;&amp; ds.length() != 0 ) ){
        try{
        
            Rectangle r = _jtp.modelToView( _jtp.getCaretPosition() );
            JPanel jp = new JPanel();
            jp.setBackground( Color.WHITE );
            jp.setForeground( Color.BLACK );
            JTextPane jtp = new JTextPane();
            Document doc2 = jtp.getDocument();
            if( ds != null ){
            
                SimpleAttributeSet sas = new SimpleAttributeSet();
                StyleConstants.setForeground( sas, Color.GREEN );
                doc2.insertString( 0, ds.toString(), sas );
        
        
            }
        
            if( sb != null ){
        
                SimpleAttributeSet sas = new SimpleAttributeSet();
                StyleConstants.setForeground( sas, Color.BLUE );
                doc2.insertString( jtp.getCaretPosition(), sb.toString(), sas );
        
        
            }
            jtp.setEditable( false );
            jp.add( jtp );
            Point p = new Point( r.x, r.y );
            SwingUtilities.convertPointToScreen( p, _jtp );
            pu = pf.getPopup( _jtp, jp, p.x, p.y - jp.getPreferredSize().height );
            pu.show();
        }
        catch( BadLocationException ble ){}
        
    }


}

@others</t>
<t tx="ekr.20070127142814.34">public StringBuilder calltip_jconstructor( Class clazz ){

    Constructor[] cons = clazz.getConstructors();
    StringBuilder sb = new StringBuilder();
    
    for( Constructor m: cons ){ 
        
        String name = clazz.getSimpleName();
        Class[] params = m.getParameterTypes();
        sb.append( name ).append( "( " );
        for( Class c: params ){
    
            sb.append( c.getSimpleName() );
            sb.append( ", " );
    
        }
        if( params.length != 0 ){
            int li = sb.lastIndexOf( ", " );
            if( li != -1 )
                sb.delete( li, li + 2 );
        }
        sb.append( ")" );
    
        Class[] exceptions = m.getExceptionTypes();
        if( exceptions.length &gt; 0 ) sb.append( " throws " );
        for( Class c: exceptions ) sb.append( c.getSimpleName() ).append( ", " );
        if( exceptions.length &gt; 0 ){
    
            int li = sb.lastIndexOf( ", " );
            if( li != -1 )
                sb.delete( li, li + 2 );
    
        }
        sb.append( "\n" );
    
    }
    if( sb.length() &gt; 0 )
        sb.deleteCharAt( sb.length() -1 );
    return sb;


}</t>
<t tx="ekr.20070127142814.35">public String prettyPrintJavaMethod( Method m ){


    Class returntype = m.getReturnType();
    String name = m.getName();
    Class[] params = m.getParameterTypes();
    
    StringBuilder sb = new StringBuilder();
    sb.append( returntype.getSimpleName() ).append( " " );
    sb.append( name ).append( "( " );
    for( Class c: params ){
    
        sb.append( c.getSimpleName() );
        sb.append( ", " );
    
    }
    if( params.length != 0 ){
        int li = sb.lastIndexOf( ", " );
        if( li != -1 )
            sb.delete( li, li + 2 );
    }
    sb.append( ")" );
    
    Class[] exceptions = m.getExceptionTypes();
    if( exceptions.length &gt; 0 ) sb.append( " throws " );
    for( Class c: exceptions ) sb.append( c.getSimpleName() ).append( ", " );
    if( exceptions.length &gt; 0 ){
    
        int li = sb.lastIndexOf( ", " );
        if( li != -1 )
            sb.delete( li, li + 2 );
    
    }
    return sb.toString();


}</t>
<t tx="ekr.20070127142814.36">public StringBuilder calltip_java( PyReflectedFunction prf, String[] split2 ){
    
    StringBuilder sb = new StringBuilder();
    String[] split3 = new String[ split2.length -1 ];
    System.arraycopy( split2, 0, split3, 0, split3.length );
    PyObject po3 = js.getPyObject( split3 );
    PyJavaClass pjc = null;

    if( po3 instanceof PyJavaInstance ){
        PyJavaInstance pji = (PyJavaInstance)po3;
        pjc = (PyJavaClass)pji.instclass;
    }
    else if( po3 instanceof PyJavaClass ){
    
        pjc = (PyJavaClass )po3;
    
    }
    else return null;

    Class clazz = null;
    try{
        clazz = Class.forName( pjc.__name__ );
        
    }
    catch( Exception x ){ return null; }
    Method[] ms = clazz.getMethods();
    java.util.List&lt;Method&gt; methods = new ArrayList&lt;Method&gt;();
    String methodname = split2[ split2.length -1 ];
    for( Method m: ms )if( m.getName().equals( methodname ) ) methods.add( m );
    sb = new StringBuilder();
    for( Method m: methods )
        sb.append( prettyPrintJavaMethod( m ) ).append( "\n" );
    if( sb.length() != 0 )
        sb.deleteCharAt( sb.length() -1 );
    return sb;

}</t>
<t tx="ekr.20070127142814.37">public StringBuilder calltip_python( PyFunction pf, boolean ignoreself ){

    StringBuilder sb = new StringBuilder();
    //PyFunction pf = (PyFunction)po2;
    PyTableCode ptc = (PyTableCode)pf.func_code;
    boolean sargs = ptc.args;
    boolean skwords = ptc.keywords;
    int argcount = ptc.co_argcount;
    if( sargs ) argcount++;
    if( skwords ) argcount++;
    Map&lt;Integer, StringBuilder&gt; args = new HashMap&lt; Integer, StringBuilder &gt;();
    int id = 1;
    String[] varnames = null;
    if( ignoreself &amp;&amp; ptc.co_varnames.length &gt; 0 ){
        varnames = new String[ ptc.co_varnames.length -1 ];
        System.arraycopy( ptc.co_varnames, 1, varnames, 0, varnames.length );
        argcount--;
    
    }
    else varnames = ptc.co_varnames;
    for( String s: varnames ){
        if( argcount == 0 ) break;
        argcount--;
        args.put( id, new StringBuilder( s ) );
        id++;
            
    }
    id--;
            
    StringBuilder ksb = null;
    if( skwords ){
            
        ksb = args.get( id );
        ksb.insert( 0, "**" );
        args.remove( id );
        id--;
                
    }
    StringBuilder asb = null;
    if( sargs ){
            
        asb = args.get( id );
        asb.insert( 0, "*" );
        args.remove( id );
        id--;            
        
    }
            
    java.util.List&lt;StringBuilder&gt; defaults = new ArrayList&lt;StringBuilder&gt;();
    if( pf.func_defaults != null ){
            
        java.util.List df = Arrays.asList( pf.func_defaults );
        Collections.reverse( df );
        for( Object o: df ){
                
            StringBuilder sb2 = args.get( id );
            sb2.append( "=" ).append( o.toString() );
            args.remove( id );
            id--;  
            defaults.add( sb2 );
                
        }
            
            
    }
    Collections.reverse( defaults );
            
    boolean preceding = false;
    sb.append( pf.__name__ );
    sb.append( "-&gt; " );
    sb.append( "( " );
    int size = args.size();
    for( int z = 1; z &lt;= size; z ++ ){
        preceding = true;
        StringBuilder param = args.get( z );
        sb.append( param );
        if( z != size )
            sb.append( ", " );
            
            
    }
            
    if( defaults.size() &gt; 0 )
        
        sb.append( ", " );
        for( int z = 0; z &lt;= defaults.size() -1 ; z ++ ){
            preceding = true;
            StringBuilder def = defaults.get( z );
            sb.append( def );
            if( z != defaults.size() -1 ) sb.append( ", " );
            
            
        }
    if( asb != null ){
            
        if( preceding )
            sb.append( ", " );
        sb.append( asb );
        preceding = true;
            
    }
            
    if( ksb != null ){
                
        if( preceding )
            sb.append( ", " );
        sb.append( ksb );
            
            
    }
    sb.append( " )" );
    return sb;

}</t>
<t tx="ekr.20070127142814.38">public void hide(){

    if( pu != null ){
    
        pu.hide();
        pu = null;
    
    
    }



}

public boolean isShowing(){

    return pu != null;


}</t>
<t tx="ekr.20070127142814.39">public void utilityBoxShown( UtilityBoxEvent ube ){




}

public void utilityBoxClose( UtilityBoxEvent ube ){

    hide();


}</t>
<t tx="ekr.20070127142814.40">@language java
package org.leo.shell;
import java.util.regex.*;


public class Autoquoter implements LineListener, Documentation{

    JythonShell js;
    Matcher wsp;
    Matcher pp;
    Matcher transformer;
    public Autoquoter( JythonShell js ){
    
        this.js = js;
        js.addLineListener( this );
        wsp = Pattern.compile( "\\s+" ).matcher( "" );
        pp = Pattern.compile( "\\w+\\(" ).matcher( "" );
    		transformer = Pattern.compile( "(\\w+)+" ).matcher( "" );
        js.addInteractiveDocumentation( this );
    }
    
    public String getDocumentation(){
    
        return "Autoquoting:\n"+
        "Starting an input line with a , will automatically quote "+
        "the parameters passed into a function. An example:\n"+
        "In [0]: ,print a b c\n"+
        "--&gt; print \"a\", \"b\", \"c\"\n"+
        "a b c\n";
    
    
    }

    public String lineToExecute( String line ){
    
        if( line.startsWith( "," ) ){
        
            String line2 = line.substring( 1 );
            wsp.reset( line2 );
            boolean wsm = wsp.find();
            int i1;
            if( wsm ) i1 = wsp.start();
            else i1 = -1;
            pp.reset( line2 );
            boolean pm = pp.find();
            int i2;
            if( pm ) i2 = pp.end();
            else i2 = -1;
                      
            if( i1 != -1 || i2 != -1 ){
            
                String[] pieces;
                if( ( i1 &lt; i2 &amp;&amp; i1 != -1 ) || i2 == -1 )
                    pieces = line2.split( "\\s+", 2 );
	            else
                    pieces = line2.split( "\\(", 2 );
                
                if( pieces.length == 2 ){
                
                    String piece1 = pieces[ 0 ];
                    String piece2 = pieces[ 1 ].trim();
                    if( piece2.endsWith( ")" ) ){
                        piece2 = piece2.replaceFirst( "\\s*\\)$", "" );
                        transformer.reset( piece2 );
                        piece2 = transformer.replaceAll( "\"$0\"," );
                        if( piece2.endsWith( "," ) ) piece2 = piece2.substring( 0, piece2.length() -1 );
                        line = String.format( "%1$s( %2$s )", piece1, piece2 );
                    
                    }
                    else{
                        transformer.reset( piece2 );
                        piece2 = transformer.replaceAll( "\"$0\"," ); 
                        if( piece2.endsWith( "," ) ) piece2 = piece2.substring( 0, piece2.length() -1 );
                        line = String.format( "%1$s %2$s", piece1, piece2 );
                        
                    }
                
                
                }
            
            
            }
        
        
        }
        return line;    
    
    
    }

}</t>
<t tx="ekr.20070127142814.41">@language java
package org.leo.shell;


public class LineOutputSupresser implements LineListener, Documentation{

    JythonShell js;
    public LineOutputSupresser( JythonShell js ){
    
        this.js = js;
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "Line output supression:\n"+
        "Terminating an input line with a ; will supress the output "+
        "for the execution of the line.\n";
    
    
    }

    public String lineToExecute( String line ){
    
        if( line.trim().endsWith( ";" ) ) js.supressOutput();
        return line;
    }


}</t>
<t tx="ekr.20070127142814.42">@language java
package org.leo.shell;

import org.python.core.PyList;
import org.python.core.PyObject;
import org.python.core.__builtin__;
import org.python.core.PyStringMap;
import org.python.core.PyType;
import org.python.core.PyString;
import org.python.core.PyDictionary;
import java.util.*;
import java.io.IOException;
import java.io.OutputStream;


public class ObjectWildCard implements LineListener, Documentation{

    JythonShell js;
    public ObjectWildCard( JythonShell js ){
    
        this.js = js;
        js.addLineListener( this );
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "Object Wildcards:\n"+
        "Typing ? followed by a reference or a chain of references, and ending in * " +
        "will show all matches that have reference names that start with the terminating token.\n"+
        "For example:\n"+
        "?a.b.ca*\n"+
        "if 'b' has these attributes canga, cata and casta then a list will be printed like so:\n"+
        "[ canga, cata, casta ]\n"+
        "This is a good and quick way to narrow in on specific reference names.\n"+
        "Additionaly if the user passes in a a type after the '*' will filter out those objects that do "+
        "not match the type passed in, an Example:\n"+
        "?a.b.c* str\n" +
        "will return only the attributes that start with c and are of type str\n";
    
    }

    public String lineToExecute( String line ){
        
        String[] lpieces = line.split( "\\s+" );
        if( lpieces.length == 0 ) return line;
        String type = null;
        if( lpieces.length &gt; 1 ) type = lpieces[ 1 ];
        String lpiece1 = lpieces[ 0 ];
        if( lpiece1.startsWith( "?" ) &amp;&amp; lpiece1.endsWith( "*" ) ){
            String nwline = lpiece1.substring( 1, lpiece1.length() -1 );
            String[] pieces = nwline.split( "\\." );
            String wildcard = pieces[ pieces.length -1 ];
            PyList pl= null;
            PyStringMap pm = (PyStringMap)js._pi.getLocals();
            PyDictionary pd = new PyDictionary();
            for( Object x: pm.keys() ){
                
                PyString x2 = new PyString((String)x );
                PyObject value = pm.get( x2 );
                pd.__setitem__( x2 , value );
            
            
            }
            String[] pieces2 = new String[ pieces.length -1 ];
            System.arraycopy( pieces, 0, pieces2, 0, pieces2.length );
            PyObject pybase = js.getPyObject( pieces2  );
            if( pybase != null ){
                pd = new PyDictionary();
                PyList pdir = (PyList)pybase.__dir__();
                for( Object o: pdir ){
                    try{
                        PyString s = new PyString((String)o);
                        PyObject value = __builtin__.getattr( pybase, s );
                        pd.__setitem__( s, value );
                    }
                    catch( Exception x ){ /*blasted doc attribute */}
                
                }
                
            }     
            if( pybase ==  null &amp;&amp; pieces2.length != 0 ){
                cantResolve( line );
                return null;    
            }
            
            if( type != null )
                pl = filter( pd, type );
            else
                pl = pd.keys();
            
            
            
            PyList output = new PyList();
            for( int i = 0; i &lt; pl.size(); i ++ ){
            
                String sform = pl.get( i ).toString();
                if( sform.startsWith( wildcard ) ) output.add( sform );
            
            }
            
            Collections.sort( output );
            try{
                
                OutputStream out = js.getStandardOut();
                out.write( output.toString().getBytes() );
                out.write( "\n".getBytes() );
                return null;
            
            }
            catch( IOException io ){}
            
        }
        return line;


    }
    
    public PyList filter( PyDictionary pm, String type ){
        
        PyList keep = new PyList();
        for( Object _key: pm.keys() ){
            PyString key = new PyString( (String)_key );            
            PyObject po = (PyObject)pm.get( key );
            PyType pt = __builtin__.type( po );
            if( pt.fastGetName().equals( type ) ) keep.insert( 0, key );
                    
        }
        return keep;        
    
    }
    
    private void cantResolve( String line ){
        try{
            OutputStream err = js.getStandardErr();
            err.write( ( "Can't find resolve " + line + ".\n" ).getBytes() );
        }
        catch( IOException io ){}        
    
    }

}</t>
<t tx="ekr.20070127142814.43">@language java
package org.leo.shell;

import java.util.*;
import java.io.IOException;
import java.io.OutputStream;
import org.leo.shell.util.ProcessExecutor;

public class SystemCommand implements LineListener, Documentation{

    JythonShell js;
    public SystemCommand( JythonShell js ){
    
        this.js = js;
        js.addQuietLineListener( this );
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "System access:\n"+
        "Typing ! at the command prompt followed by the system command\n" +
        "you wish to execute will start the command as a process and return\n"+
        "Typing !! is the same as typing %sx, see %sx documentation for more info\n";
    
    }

    public String lineToExecute( String line ){
        
        if( line.startsWith( "!" )){
            
            if( line.startsWith( "!!" ) ) line = line.replaceFirst( "\\!\\!|", "%sx " );//we can use a line listener here
            else{
                js.setNextPrompt( new Runnable(){ public void run(){} } );
                ProcessExecutor pe = new ProcessExecutor( js , line.substring( 1 ).trim(), js.getCurrentWorkingDirectory() );
                js.execute2( pe );
                return null;
            }
        
        
        }    
    
        return line;
    }

}</t>
<t tx="ekr.20070127142814.44">@language java
package org.leo.shell;

import org.leo.shell.widget.Pager;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;

public class UnifiedHelp implements LineListener, Documentation{

    JythonShell js;
    Pager pager;
    public UnifiedHelp( JythonShell js ){
    
        this.js = js;
        js.addLineListener( this );
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "? --&gt; Shows the documentation available about keystrokes, magic commands and interactive features.\n";
    
    }

    public String lineToExecute( String line ){
        
        if( line.trim().equals( "?" ) ){
        
            Runnable run = new Runnable(){
                public void run(){
                    String description = js.getUnifiedHelp();
                    if( !js.containsNamedWidget( "Help" ) ){
    
                        JTextComponent jtc = js.getShellComponent();
                        pager = new Pager( js, jtc.getForeground(), jtc.getBackground(), jtc.getFont() );
                        js.addWidget( pager.getBaseWidget(), "Help" );

                    }

                    pager.setText( description );
                    js.moveWidgetToFront( "Help" ); 
                    pager.requestFocus();             
                    
                }
            };
            SwingUtilities.invokeLater( run );
            return null;
        }    
    
        return line;
    }

}</t>
<t tx="ekr.20070127142814.45">@language java
package org.leo.shell;

import org.python.util.*;
import org.python.core.*;
import org.python.parser.*;

import java.awt.*;
import java.awt.dnd.*;
import java.awt.datatransfer.*; 
import java.awt.event.*;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.MalformedURLException;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.filechooser.*;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.io.*;
import javax.print.*;
import javax.print.attribute.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import javax.swing.undo.*;

import org.leo.shell.color.*;
import org.leo.shell.magic.*;
import org.leo.shell.actions.*;
import org.leo.shell.util.*;
import org.leo.shell.io.*;
import org.leo.shell.widget.*;
import org.leo.shell.alias.*;
import static org.leo.shell.color.ColorConfiguration.ColorConstant; 
import static org.leo.shell.PromptFormatter.ColoredToken;
import static org.leo.shell.UtilityBoxEvent.UBEventType;

public class JythonShell extends KeyAdapter implements UndoableEditListener, Callable&lt;Boolean&gt;, Documentation{
    
    final public InteractiveConsole _pi;
    
    Autoquoter aq;
    PasteAsScript pas;
    Paste paste;
    Copy copy;
    
    private JPanel base;
    private JPanel backingwidget;
    private CardLayout layout;
    private ImageJViewport imjvp;
    final private JTextPane _jtp;

    private JMenuBar _jmb;
    final public JScrollPane _jsp;
    private JList _autocompleter;
    private JMenuItem undo;
    private JMenuItem redo;
    
    public Set&lt;MagicCommand&gt; mcommands;
    java.util.List&lt;LineListener&gt; llisteners;//these three can alter lines for execution and for storing history, good hooks
    java.util.List&lt;LineListener&gt; qllisteners;
    java.util.List&lt;LineListener&gt; hllisteners;
    java.util.List&lt;UtilityBoxListener&gt; utilboxlisteners;
    java.util.List&lt;Documentation&gt; iudocproviders;
    final public java.util.List&lt; String &gt; lines;
    final public PyList history;
    public PyList output;
    PyList dhistory;
    PyList dstack;
    Map&lt;Integer, Object&gt; Out;
    final private Map&lt;String, Macro &gt;macros;
    final private Map&lt;String, File&gt; bookmarks;
    final private Set&lt; String &gt; abbrevs;

    final private ByteArrayInputStream in;
    public ListSelectionListener _lsl;
    ColorConfiguration colorconfig;
    SimpleAttributeSet outSet;
    SimpleAttributeSet errSet;
    boolean force_line_colorize = false;
    JythonColorizer colorizer;
    
    private File cwd;
    private Map&lt;String,org.leo.shell.alias.Alias&gt; aliasmap;
    
    private Abbreviation _lab;
    private final UndoManager udm;
    //private final UndoableEditSupport ues;
    private boolean init_done;
    private Callable closer;
    ExecutorService executor;
    ExecutorService executor2;
    public volatile boolean suspend;
    
    public LinkedBlockingQueue&lt;String&gt; standardin;
    public CyclicBarrier stdinbarrier;
    public CountDownLatch resettool;
    
    LinkedBlockingQueue&lt;String&gt; previousline;
    LinkedBlockingQueue&lt;String&gt; execute;

    int outputspot;
    int linenumber;
    volatile boolean last_more;
    
    String lastprompt;
    int lastpromptsize;
    volatile boolean pdbonexception;
    private Runnable nextprompt;    
    
    java.util.List&lt;String&gt; conventions;
    java.util.List&lt;Integer&gt; ignorekc;
    
    java.util.List&lt;String&gt; who;
    
    JSOutputStream stdout;
    JSOutputStream stderr;
    java.util.List&lt;OutputStream&gt; loggers;
    
    PromptFormatter primaryprompt;
    PromptFormatter secondaryprompt;
    PromptFormatter outputprompt;
    
    
    boolean autocall;
    boolean autoindent;
    boolean automagic;
    boolean supressing;
    String executingline;
    
    private static DataFlavor uriListFlavor;
    static{
        
        try{
            
            uriListFlavor = new DataFlavor( "text/uri-list;class=java.lang.String" );
            
        }
        catch( ClassNotFoundException cnfe ){ cnfe.printStackTrace(); }
    
    
    }    


    @others






}




</t>
<t tx="ekr.20070127142814.46">public JythonShell(){
    
    //PySystemState.initialize(System.getProperties(),
    //                             opts.properties, opts.argv);
    //PySystemState.initialize();
    PySystemState.initialize(System.getProperties(),
                                 new java.util.Properties(), new String[]{});
    _pi = new InteractiveConsole();
    PyModule mod = imp.addModule("__main__");
    _pi.setLocals(mod.__dict__);
    PyJavaInstance pji = new PyJavaInstance( this );
    PySystemState psstate = Py.getSystemState();
    PyObject dh = pji.__findattr__( "displayHook" );
    psstate.__displayhook__ = dh;
    psstate.__dict__.__setitem__("displayhook", dh );
    PyObject eh = pji.__findattr__( "exceptHook" );
    psstate.__excepthook__ = eh;
    psstate.__dict__.__setitem__( "excepthook", eh );
    _pi.exec( "import sys;import os;import shutil" );

    llisteners = new ArrayList&lt;LineListener&gt;(); 
    qllisteners = new ArrayList&lt;LineListener&gt;();
    hllisteners = new ArrayList&lt;LineListener&gt;();
    utilboxlisteners = new LinkedList&lt;UtilityBoxListener&gt;();
    iudocproviders = new ArrayList&lt;Documentation&gt;();
    
    Comparator&lt;String&gt; aliascompare = new Comparator&lt;String&gt;(){
    
        public int compare( String s1, String s2 ){
        
            return s1.compareTo( s2 );
        
        }
        
        public boolean equals( Object o ){
            if( o == null ) return false;
            if( !( o instanceof Comparator ) ) return false;
            return true;
            
        }        
    
    
    };
    aliasmap = new TreeMap&lt;String, org.leo.shell.alias.Alias&gt;( aliascompare );
    qllisteners.add( new AliasConverter( this, aliasmap ) );
    addLineListener( new LineOutputSupresser( this ) );
    
    pdbonexception = false;
    //magic power data structures and such...
    lines = new Vector&lt; String &gt;();
    
    abbrevs = new HashSet&lt; String &gt;();
    final PySystemState pss = Py.getSystemState();
    final PyStringMap psm = (PyStringMap)pss.builtins;
    final PyList pl = psm.keys();
    for( int i = 0; i &lt; pl.__len__(); i ++ )
        abbrevs.add( pl.__getitem__( i ).toString() );
        
    /*final String[] kwrds = PythonGrammarConstants.tokenImage;
    for( final String s: kwrds ){
        if( s.length() &lt;= 2 ) continue;
        abbrevs.add( s.substring( 1, s.length() -1 ) );   
    }*/
    
    bookmarks = new HashMap&lt;String,File&gt;();
    conventions = new Vector&lt;String&gt;();
    conventions.add( "self" );
    ignorekc = new ArrayList&lt;Integer&gt;();
    history = new PyList(); //new LinkedList&lt;String&gt;();
    output = new PyList();
    dhistory = new PyList();
    dstack = new PyList();
    loggers = new ArrayList&lt;OutputStream&gt;();
    Out = new HashMap&lt;Integer, Object&gt;();
    _pi.set( "Out", Out );
    _pi.set( "_oh", Out );
    _pi.set( "In", history );
    _pi.set( "_ih", history );
    _pi.set( "_dh", dhistory );
    macros = new HashMap&lt; String, Macro &gt;();
    Comparator&lt;MagicCommand&gt; mcsorter = new Comparator&lt;MagicCommand&gt;(){
    
        public int compare( MagicCommand m1, MagicCommand m2 ){
        
            return m1.getName().compareTo( m2.getName() );
        
        }
    
        public boolean equals( Object o ){ 
            if( o == null ) return false;
            if( !( o instanceof Comparator ) ) return false;
            return true;
            
        }
    
    };
    mcommands = new TreeSet&lt;MagicCommand&gt;( mcsorter );
    createMagicCommands();
    setCurrentWorkingDirectory( new File( System.getProperty( "user.dir" ) ) );
    pushDStack( getCurrentWorkingDirectory() );
    
    for( final MagicCommand mc: mcommands ) abbrevs.add( mc.getName() );
    abbrevs.add( "self" );
    
    //the concurrency tools that makes life so much easier... :)
    standardin = new LinkedBlockingQueue&lt;String&gt;();
    previousline = new LinkedBlockingQueue&lt;String&gt;();
    execute = new LinkedBlockingQueue&lt;String&gt;();
    stdinbarrier = new CyclicBarrier( 2 );
    executor = Executors.newSingleThreadExecutor();
    executor2 = Executors.newSingleThreadExecutor();
    
    
    //start building the gui 
    _jtp = new JTextPane();
    backingwidget = new JPanel();
    layout = new CardLayout();
    backingwidget.setLayout( layout );
    base = new JPanel();
    backingwidget.add( base, "Shell" );
    base.setLayout( new BorderLayout() );
    pas = new PasteAsScript( this );
    paste = new Paste( this );
    copy = new Copy( this );
    addMenuBar( base ); 
    
    setColorConfiguration( new ColorConfiguration() );
    colorizer = new JythonColorizer( _pi, _jtp, colorconfig ); 
    addKeyStrokes();
    Font f = Font.decode( "DIALOG PLAIN 15" );
    if( f != null )
        _jtp.setFont( f );

    new CopyPaste( _jtp, this );
    imjvp = new ImageJViewport();
    JScrollPane jsp = _jsp = new JScrollPane();
    jsp.setViewport( imjvp );
    jsp.setViewportView( _jtp );
    jsp.addMouseWheelListener( new RemoveObjects( this ) );
    jsp.setHorizontalScrollBarPolicy( ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER );
    base.add( jsp, BorderLayout.CENTER );    
    _jtp.setText( _pi.getDefaultBanner() + '\n' );
    _jtp.setCaretPosition( _jtp.getDocument().getLength() );
    _jtp.setDoubleBuffered( true );
    _lsl = new _SelectionReturner( _jtp );
    new UnifiedHelp( this );
    new Autocompleter( this, _jtp );
    new Calltip( this );
    new ObjectWildCard( this );
    new SystemCommand( this );
    new DropFileMechanism( this );
    aq = new Autoquoter( this );
    _jtp.addKeyListener( this );
    
    primaryprompt = new DefaultPrimaryPrompt( getColorConfiguration() );
    secondaryprompt = new DefaultSecondaryPrompt( getColorConfiguration());
    outputprompt = new DefaultOutputPrompt( getColorConfiguration() );

    stdout = new JSOutputStream( _jtp, outSet, this );
    _pi.setOut( stdout );
    stderr = new JSOutputStream( _jtp, errSet, this );
    _pi.setErr( stderr );
    in = new ByteArrayInputStream( new byte[ 100 ] );
    BufferedInputStream bis = new BufferedInputStream( in );
    PyFile pf = new PyFile2( bis, "&lt;stdin&gt;", this );
    Py.getSystemState().stdin = pf;
    Py.getSystemState().__stdin__ = pf;
    
    who = new LinkedList&lt;String&gt;();
    autocall = true;
    autoindent = true;
    automagic = true;
    executingline = "";
     
    addInteractiveDocumentation( this );
    //Add some fancy undo power...
    udm = new UndoManager();
    _jtp.getDocument().addUndoableEditListener( this );
    undo.addActionListener( new ActionListener(){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            udm.undo();    
            refreshUndoRedo();
            
        }
    
    
    } );
    redo.addActionListener( new ActionListener(){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            udm.redo();
            refreshUndoRedo();
        
        }
    
    
    
    });
    

}




</t>
<t tx="ekr.20070127142814.47">@others</t>
<t tx="ekr.20070127142814.48">public JComponent getWidget(){

    return backingwidget;

}</t>
<t tx="ekr.20070127142814.49">public void addWidget( JComponent jc, String name ){

    backingwidget.add( jc, name );


}

public void moveWidgetToFront( String name ){


    layout.show( backingwidget, name );


}

public boolean containsNamedWidget( String name ){

    for( Component c: backingwidget.getComponents() ){
        
        String s = c.getName();
        if( s != null &amp;&amp; s.equals( name ) ) return true;
        
    }
    return false;

}


public boolean containsWidget( Component comp ){

    for( Component c: backingwidget.getComponents() )
        if( c == comp ) return true;

    return false;
}

public Component getWidgetByName( String name ){

    for( Component c: backingwidget.getComponents() ){
        String s= c.getName();
        if( s != null &amp;&amp; s.equals( name ) ) return c;
        
    }
    return null;

}

</t>
<t tx="ekr.20070127142814.50">public final  void setVisible( final boolean b ){

    if( !init_done ){
        init_done = true;
        AncestorListener run = new AncestorListener(){
            public void ancestorAdded( AncestorEvent ae ){
                
                DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
                ColorConfiguration cc = getColorConfiguration();
                SimpleAttributeSet sas = new SimpleAttributeSet();
                StyleConstants.setForeground( sas, cc.getOutPromptColor() );
                SimpleAttributeSet sas2 = new SimpleAttributeSet();
                StyleConstants.setForeground( sas2, cc.getOutPromptColor().brighter() );

                try{
                    Position end = doc.getEndPosition();
                    doc.insertString( _jtp.getCaretPosition(), "JythonShell -- An enhanced Interactive Jython\n", sas );
                    _jtp.setCaretPosition( end.getOffset() -1 );
                    doc.insertString( _jtp.getCaretPosition(), "How to get help:\n", sas2 );
                    _jtp.setCaretPosition( end.getOffset() -1 );
                    doc.insertString( _jtp.getCaretPosition(), "? -&gt; unified help.\n", sas2 );
                    _jtp.setCaretPosition( end.getOffset() -1 );
                    doc.insertString( _jtp.getCaretPosition(), "%magic -&gt;  magic commands.\n", sas2 );
                    _jtp.setCaretPosition( end.getOffset() -1 );
                    doc.insertString( _jtp.getCaretPosition(), "%keystroke -&gt; keystrokes.\n", sas2 );
                    _jtp.setCaretPosition( end.getOffset() -1 );
                    doc.insertString( _jtp.getCaretPosition(), "%iuse -&gt; interactive features.\n", sas2 );
                    _jtp.setCaretPosition( end.getOffset() -1 ); //we do this intricate dance because in one embedding situation
                    //I saw that the order here got reversed!
                }
                catch( BadLocationException ble ){}
                insertPrompt( false );
                outputspot = _jtp.getCaretPosition();
                _jtp.removeAncestorListener( this );
            }
            
            public void ancestorRemoved( AncestorEvent event ){}
            public void ancestorMoved( AncestorEvent event ){}
        };
        //SwingUtilities.invokeLater( run );
        _jtp.addAncestorListener( run );
    }
    //_frame.setVisible( b );


}</t>
<t tx="ekr.20070127142814.51">public final JythonDelegate getDelegate(){

    return new JythonDelegate( this );



}</t>
<t tx="ekr.20070127142814.52">public void addLineListener( LineListener ll ){

    llisteners.add( ll );

}

public void removeLineListener( LineListener ll ){


    llisteners.remove( ll );


}

public void addQuietLineListener( LineListener ll ){

    qllisteners.add( ll );

}

public void removeQuietLineListener( LineListener ll ){

    qllisteners.remove( ll );

}

public void addHistoryLineListener( LineListener ll ){

    hllisteners.add( ll );

}

public void removeHistoryLineListener( LineListener ll ){

    hllisteners.remove( ll );

}
</t>
<t tx="ekr.20070127142814.53">public void addUtilityBoxListener( UtilityBoxListener ubl ){

    utilboxlisteners.add( ubl );

}

public void removeUtilityBoxListener( UtilityBoxListener ubl ){


    utilboxlisteners.remove( ubl );


}</t>
<t tx="ekr.20070127142814.54">public void supressOutput(){
    
    stdout.supress();stderr.supress();
    supressing = true;


}</t>
<t tx="ekr.20070127142814.55">@others
</t>
<t tx="ekr.20070127142814.56">public final void addMenuBar( final JPanel jc ){

    _jmb = new JMenuBar();
    jc.add( _jmb, BorderLayout.NORTH );
    final JMenu jm = new JMenu( "File" );
    _jmb.add( jm );
    final Action o = new AbstractAction( "Open" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            JythonShell.this.open();
        
        
        }
    
    
    };    
    jm.add( o );
    final Action s = new AbstractAction( "Save" ){
        public final void actionPerformed( final ActionEvent ae ){
        
            JythonShell.this.save();
        
        }
    };
    jm.add( s );

    jm.addSeparator();
    /*final Action p = new AbstractAction( "Print" ){
    
    
        public final void actionPerformed( final ActionEvent ae ){
        
        
            JythonShell.this.print();
        
        
        }
    
    
    
    };
    
    jm.add( p );
    jm.addSeparator();*/
    final AbstractAction x = new AbstractAction( "Close" ){
    
        public final void actionPerformed( final ActionEvent ae ){ JythonShell.this.close(); }
    
    };
    jm.add( x );
    
    final JMenu edit = new JMenu( "Edit" );
    _jmb.add( edit );
    undo = new JMenuItem( "Cant Undo" );
    undo.setEnabled( false );
    redo = new JMenuItem( "Cant Redo" );
    redo.setEnabled( false );
    edit.add( undo );
    edit.add( redo );
    edit.addSeparator();
    
    JMenuItem cpy = edit.add( copy );
    KeyStroke cw = KeyStroke.getKeyStroke( "control W" );
    cpy.setAccelerator( cw );
    
    JMenuItem pst = edit.add( paste );
    KeyStroke cy = KeyStroke.getKeyStroke( "control Y" );
    pst.setAccelerator( cy );

    JMenuItem jpas = edit.add( pas );
    KeyStroke ay = KeyStroke.getKeyStroke( "alt Y" );
    jpas.setAccelerator( ay );

    
    final JMenu help = new JMenu ( "Help" );
    _jmb.add( help );
    final AbstractAction ab = new AbstractAction( "JythonShell Help" ){
    
        public final void actionPerformed( final ActionEvent ae ){ JythonShell.this.help();}
    
    };
    JMenuItem jhelp = help.add( ab );

}


</t>
<t tx="ekr.20070127142814.57">public void addKeyStrokes(){

    KeyStroke ck = KeyStroke.getKeyStroke( "control K" );
    addToInputActionMaps( ck,"ck", new DeleteToEndOfLine( _jtp ) );
    KeyStroke delete = KeyStroke.getKeyStroke( "DELETE" );
    addToInputActionMaps( delete,"delete", new RemoveLine( this ) );
    KeyStroke start = KeyStroke.getKeyStroke( "control A" );
    addToInputActionMaps( start, "ca", new StartOfLine( this ) );
    KeyStroke end = KeyStroke.getKeyStroke( "control E" );
    addToInputActionMaps( end, "ce", new EndOfLine( this ) );
    KeyStroke da = KeyStroke.getKeyStroke(KeyEvent.VK_SLASH, InputEvent.ALT_MASK  );
    addToInputActionMaps( da, "da", new DynamicAbbreviation( this ) );
    KeyStroke up = KeyStroke.getKeyStroke( KeyEvent.VK_UP, 0 );
    KeyStroke down = KeyStroke.getKeyStroke( KeyEvent.VK_DOWN, 0 );
    UpDownArrows uda = new UpDownArrows( this );
    addToInputActionMaps( up, "up", uda.getUp() );
    addToInputActionMaps( down, "down", uda.getDown() );
    KeyStroke tab = KeyStroke.getKeyStroke( KeyEvent.VK_TAB, 0 );
    addToInputActionMaps( tab, "tab", new TabCompletion( _jtp, colorizer ) );
    SearchInputHistory sch = new SearchInputHistory( this );
    KeyStroke cp = KeyStroke.getKeyStroke( "control P" );
    addToInputActionMaps( cp, "cp", sch.getPreviousUp() );
    KeyStroke nd = KeyStroke.getKeyStroke( "control N" );
    addToInputActionMaps( nd, "cn", sch.getNextDown() );
    KeyStroke cr = KeyStroke.getKeyStroke( "control R" );
    addToInputActionMaps( cr, "cr", new ReverseIncrementalSearch( this ) );
    KeyStroke cz = KeyStroke.getKeyStroke( "control Z" );
    addToInputActionMaps( cz, "cz", new SupressOutput( this ) );
    KeyStroke ct = KeyStroke.getKeyStroke( "control T" );
    addToInputActionMaps( ct, "tc", new TripleQuotes( this ) );
    KeyStroke esc = KeyStroke.getKeyStroke( "ESCAPE" );
    addToInputActionMaps( esc, "esc", new CloseUtilityBoxes( this )) ;
    KeyStroke ay = KeyStroke.getKeyStroke( "alt Y" );
    addToInputActionMaps( ay, "ay", pas );
    KeyStroke cy = KeyStroke.getKeyStroke( "control Y" );
    addToInputActionMaps( cy, "cy", paste );
    KeyStroke cw = KeyStroke.getKeyStroke( "control W" );
    addToInputActionMaps( cw, "cw", copy );

}

</t>
<t tx="ekr.20070127142814.58">private void addToInputActionMaps( KeyStroke ks, Object object, Action action ){

    InputMap im = _jtp.getInputMap();
    ActionMap am = _jtp.getActionMap();
    im.put( ks, object );
    am.put( object, action );


}</t>
<t tx="ekr.20070127142814.59">public boolean isRegisteredKeyStroke( KeyStroke ks ){

    InputMap im = _jtp.getInputMap();
    KeyStroke[] kst = im.keys();
    for( KeyStroke k: kst )
        if( k.equals( ks ) ) return true;
    return false;


}</t>
<t tx="ekr.20070127142814.60">public void addAlias( String name, org.leo.shell.alias.Alias alias ){

    aliasmap.put( name, alias );

}

public void removeAlias( String name ){

    if( aliasmap.containsKey( name ))  aliasmap.remove( name );
    

}

public Iterator&lt;org.leo.shell.alias.Alias&gt; getAliases(){


    return aliasmap.values().iterator();

}</t>
<t tx="ekr.20070127142814.61">public void addToConventions( String word ){

    conventions.add( word );

}


public final void setBackgroundImage( Image i, float alpha ){

    imjvp.setImage( i );
    imjvp.setAlpha( alpha );
    _jtp.setOpaque( false );
    _jsp.setOpaque( false );
    _jsp.getViewport().setOpaque( false );
    _jsp.repaint();
    
}

public final void setFont( final Font f ){

    _jtp.setFont( f );

}

public final Font getFont(){

    return _jtp.getFont();


}

public void setPrimaryPrompt( PromptFormatter pf ){

    primaryprompt = pf;

}

public PromptFormatter getPrimaryPrompt(){ return primaryprompt;}

public void setSecondaryPrompt( PromptFormatter pf ){

    secondaryprompt = pf;

}

public PromptFormatter getSecondaryPrompt(){ return secondaryprompt;}

public void setOutputPrompt( PromptFormatter pf ){

    outputprompt = pf;

}

public PromptFormatter getOutputPrompt(){ return outputprompt; }


public ColorConfiguration getColorConfiguration(){

    return colorconfig;

}

public void setColorConfiguration( ColorConfiguration cc ){

    colorconfig = cc;
    _jtp.setBackground( cc.getBackgroundColor() );//_bg  );
    _jtp.setForeground( cc.getForegroundColor() );//_fg );
    _jtp.setCaretColor( cc.getForegroundColor() );//_fg );
    outSet = new SimpleAttributeSet();
    StyleConstants.setForeground( outSet, cc.getOutColor() );//_outColor );
    StyleConstants.setFirstLineIndent( outSet, 0 );
    errSet = new SimpleAttributeSet();
    StyleConstants.setForeground( errSet, cc.getErrColor() );// _errColor );
    StyleConstants.setFirstLineIndent( errSet, 0 );
    ColorConfigurationListener ccl = new JSColorConfigurationListener( this );
    cc.registerColorConfigurationListener( ccl );

}





</t>
<t tx="ekr.20070127142814.62">public void undoableEditHappened( final UndoableEditEvent ude ){

    final UndoableEdit ue = ude.getEdit();
    final String type = ue.getPresentationName();
    if( !type.equals( "style change" ) ){
    
        udm.addEdit( ue );
        refreshUndoRedo();
    
    }

}

public final void refreshUndoRedo(){

    final boolean canredo = udm.canRedo();    
    redo.setEnabled( canredo );
    if( canredo )
        redo.setText( udm.getRedoPresentationName() );
    else
        redo.setText( "Cant Redo" );
        
    final boolean canundo = udm.canUndo();
    undo.setEnabled( canundo );
    if( canundo )
        undo.setText( udm.getUndoPresentationName() );
    else
        undo.setText( "Cant Undo" );


}</t>
<t tx="ekr.20070127142814.63">@others</t>
<t tx="ekr.20070127142814.64">public final Boolean call(){

    try{
        
        Boolean more = false;
        String line = execute.take();
        String test = line;
        try{
            for( LineListener ll: llisteners.toArray( new LineListener[]{} ) ){;
                line = ll.lineToExecute( line );
                if( line == null ) return false;
            }
            if( !test.equals( line ) ) outputLineInfo( line );
            for( LineListener ll: qllisteners.toArray( new LineListener[]{} ) ){
                line = ll.lineToExecute( line );
                if( line == null ) return false;
            
            }
        }catch( LineListenerException lle ){
        
            return false;
        
        }
        
        previousline.offer( line );
        closeUtilityBoxes();
        if( !last_more &amp;&amp; line.trim().equals( "" ) ){
            return false;
        }
        try{          
    	       
            String[] pieces = line.split( "\\s+" );
            if( automagic 
                &amp;&amp; isMagicCommand( "%" + line ) 
                &amp;&amp; getPyObject( pieces[ 0 ].split( "\\." ) ) == null ) line = "%" + line;
            if( autocall ) line = autocall( line );

            boolean append_tail = last_more;
            try{
                PyStringMap po = (PyStringMap)_pi.getLocals();
                po = po.copy();
                executingline = line;
                //System.out.println( "EXECUTE:" + line );
                if( line.startsWith( "%" ) ){
                    
                    magicCommand( line );
                    last_more = false;
                
                }
                else{
                    _pi.set( "__aliasmap", aliasmap );
                    last_more = more = _pi.push( line );
                    _pi.exec( "del __aliasmap" );
                }
                
                for( OutputStream log: loggers ){
                
                    try{
                    
                        log.write( line.getBytes() );
                        log.write( "\n".getBytes() );
                    
                    }
                    catch( IOException io ){}
                
                
                }                



                PyStringMap po2 = (PyStringMap)_pi.getLocals();
                po2 = po2.copy();
                PyList keys = po.keys();
                while( keys.__len__() != 0 ){
                
                    PyObject key = keys.pop();
                    if( po2.has_key( key ) )
                        po2.__delitem__( key );
                
                }
                for( Object o: po2.keys() ){
                    String s = o.toString();
                    if( !(s.startsWith( "_" ) || s.startsWith( "_i" ) ) )
                        who.add( s );
                 
                 }
            }
            finally{
                if( append_tail ){
                
                    String tail = (String)history.remove( history.size() -1 ).toString();
                    tail = String.format( "%1$s\n%2$s", tail, line );
                    history.add( tail ); 
                
                
                }
                else{
                    try{
                        for( LineListener ll: hllisteners.toArray( new LineListener[]{} ) ){
                            line = ll.lineToExecute( line );
                            if( line == null ) break;
            
                        }
                        if( line != null ) history.add( line );
                    }
                    catch( LineListenerException lle ){}
                }
            
                int hsize = history.size();
                if( hsize &gt;= 4 ) _pi.set( "_iii", history.get( hsize - 4 ) );
                if( hsize &gt;= 3 ) _pi.set( "_ii", history.get( hsize - 3 ) );
                if( hsize &gt;= 2 ) _pi.set( "_i", history.get( hsize - 2 ) );            
                if( !more ){
                
                    String variable = String.format( "_i%1$d", linenumber );
                    _pi.set( variable, history.get( hsize -1 ) );
                    colorizer.clearPositions();
                    linenumber++;
                    stdout.liberate();stderr.liberate();supressing = false;
             
                }
            
            }
        }
        catch( Exception x ){
    
            x.printStackTrace();
            more = false;
        
        }
        return more;

    
    }
    catch( InterruptedException ie ){}

    return false;

}
</t>
<t tx="ekr.20070127142814.65">public String autocall( String line ){
    
    String[] split = line.split( "\\s+" );
    if( split.length &gt; 1 ){
        String split1 = split[ 1 ];
        char c = split1.charAt( 0 );
        if( !Character.isLetterOrDigit( c ) &amp;&amp; c != '_' ) return line;
        String[] split2 = split[ 0 ].split( "\\." );
        PyObject po = getPyObject( split2 );
        if( po != null &amp;&amp; !(po instanceof PyClass) ){
            
            boolean callable = __builtin__.callable( po );
            if( callable ){
                
                String args = line.substring( split[ 0 ].length() );
                line = String.format( "%1$s( %2$s )", split[ 0 ], args );
                outputLineInfo( line );
                
            }
            
            
        }
        else if( split2.length == 1  &amp;&amp; Py.getSystemState().builtins.__finditem__( new PyString( split2[ 0 ] ) ) != null ){
                
            po = Py.getSystemState().builtins.__finditem__( new PyString( split2[ 0 ] ) );
            boolean callable = __builtin__.callable( po );
            if( callable ){
                    
                String args = line.substring( split[ 0 ].length() );
                line = String.format( "%1$s( %2$s )", split[ 0 ], args );
	            outputLineInfo( line );
                    
            }
                
        }
    }     
    return line;
}</t>
<t tx="ekr.20070127142814.66">public void outputLineInfo( String line ){

    SimpleAttributeSet sas = new SimpleAttributeSet();
    setIndent( lastprompt, "--&gt; " , sas );
    DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
    int cp = _jtp.getCaretPosition();
    //doc.insertString( cp, "--&gt; " + line + "\n" , null);
    String totalline = "--&gt; " + line + "\n";
    colorize( totalline, totalline, cp, cp, cp + totalline.length() );
    Element e = doc.getParagraphElement( cp );
    //doc.setCharacterAttributes( cp, 4, outpSet , false );
    doc.setParagraphAttributes( e.getStartOffset() ,(e.getEndOffset() - 1 ) - e.getStartOffset(), sas , false );
    _jtp.setCaretPosition( cp + line.length() + 5 );

}</t>
<t tx="ekr.20070127142814.67">public void addLineToExecute( String line ){

    execute.add( line );


}</t>
<t tx="ekr.20070127142814.68">//execute1 is for running the JythonShell itself, this the pattern the shell follows.
public void execute1( Runnable run ){

    executor.submit( run );


}

public void execute1( Callable call ){

    executor.submit( call );

}

//execute2 is intended for a non-shell runnable or callable to execute.  Task running in execute2 can then schedule the shell to run in execute1
public void execute2( Runnable run ){

    executor2.submit( run );


}

public void execute2( Callable call ){

    executor2.submit( call );


}
</t>
<t tx="ekr.20070127142814.69">@others
</t>
<t tx="ekr.20070127142814.70">public String get_input( int spot ){

    DefaultStyledDocument sdd = (DefaultStyledDocument)_jtp.getDocument();
    Element e = Utilities.getParagraphElement( _jtp, spot );
    int start = e.getStartOffset();
    int end = e.getEndOffset() - 1;
    if( outputspot &gt; start &amp;&amp; outputspot &lt;= end ) start = outputspot;

    
    try{
        
        return sdd.getText( start, end - start );
    }
    catch( BadLocationException ble ){}
    return "";


}</t>
<t tx="ekr.20070127142814.71">public final void insertPrompt( final boolean more ){


    final SimpleAttributeSet sas2 = new SimpleAttributeSet();
    final SimpleAttributeSet indent = new SimpleAttributeSet();
    StyleConstants.setFirstLineIndent( indent, 0 );
    StyleConstants.setForeground( sas2, _jtp.getForeground() );
    PromptFormatter formatter = null;
    
    String prompt;
    final int prompt_size;
    String addwhitespace = "";
    if( more ){
        final Document doc = _jtp.getDocument();
        try{
            String previous = previousline.peek();
            if( previous != null &amp;&amp; autoindent ){

                boolean addtab = previous.trim().endsWith( ":" );
                char[] line;
                line = previousline.take().toCharArray();//pre.toCharArray();
                final StringBuilder sb = new StringBuilder();
                for( final char c: line ){
                
                    if( c != '\n' &amp;&amp; Character.isWhitespace( c ) ) sb.append( c );
                    else break;
                
                }

                
                if( addtab ) sb.append( "    " );
                addwhitespace = sb.toString();
            
                

            }  
            }
            catch( final Exception x ){
            
                x.printStackTrace();
                
            }
        
        
        prompt = secondaryprompt.getPrompt( linenumber );
        formatter = secondaryprompt;

        
        prompt_size = prompt.length();
        //StyleConstants.setForeground( sas, colorconfig.getPromptTwoColor() );//_p2c );
        //setIndent( lastprompt, prompt, indent );
        setIndent2( secondaryprompt.coloredPrompt( linenumber ), indent, lastpromptsize );
        if( autoindent ){
            prompt += addwhitespace;
            // += addwhitespace;
        }
        
    }
    else{
        
        formatter = primaryprompt;
        lastprompt = prompt = primaryprompt.getPrompt( linenumber );
        prompt_size = prompt.length();
        //StyleConstants.setForeground( sas, colorconfig.getPromptOneColor() );//_p1c );

    }
    
    try{
        
        int ospot = _jtp.getCaretPosition();
        final DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
        int cp = _jtp.getCaretPosition();
        Iterator&lt;ColoredToken&gt; promptpieces = formatter.coloredPrompt( linenumber );
        while( promptpieces.hasNext() ){
        
            ColoredToken ct = promptpieces.next();
            doc.insertString( cp, ct.data, ct.atts );
            cp += ct.data.length();
        
        
        }
        doc.insertString( cp, addwhitespace, null );
        cp = _jtp.getCaretPosition();
        int end = endOfLine();
        _jtp.setCaretPosition( end );
        doc.insertString( _jtp.getCaretPosition(), "", sas2 );
        outputspot = ospot + prompt_size;
        previousline.clear();
        doc.setParagraphAttributes( startOfLine(), 0, indent, false );
        lastpromptsize = (int)(getPromptLength( formatter.coloredPrompt( linenumber ) ) + StyleConstants.getFirstLineIndent( indent ));
    
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }      
    udm.discardAllEdits();       
    refreshUndoRedo();
    
}</t>
<t tx="ekr.20070127142814.72">public void setIndent( String one, String two, MutableAttributeSet sas ){

    Graphics g = _jtp.getGraphics();
    if( g != null ){
    
        FontMetrics fm = g.getFontMetrics();
        int width = fm.stringWidth( one );
        int width2 = fm.stringWidth( two );
        g.dispose();
        if( width &gt; width2 ){

            StyleConstants.setFirstLineIndent( sas, width - width2 );           
        
        }
    

    }

}</t>
<t tx="ekr.20070127142814.73">public void setIndent2( Iterator&lt;ColoredToken&gt; pit, MutableAttributeSet sas, int width2 ){
        
    int totalwidth = getPromptLength( pit );
    if( totalwidth &lt; width2 ){

        StyleConstants.setFirstLineIndent( sas, width2 - totalwidth );           
        
    }
    
}
</t>
<t tx="ekr.20070127142814.74">public int getPromptLength( Iterator&lt;ColoredToken&gt; pit ){

    StyledDocument sd = (StyledDocument)_jtp.getDocument();
    Graphics2D g = (Graphics2D)_jtp.getGraphics();
    if( g != null ){

        int totalwidth = 0;
        while( pit.hasNext() ){
            ColoredToken ct = pit.next();           
            Font f;
            if( ct.atts.getAttribute( StyleConstants.FontFamily ) != null 
                || ct.atts.getAttribute( StyleConstants.FontSize ) != null
                || StyleConstants.isBold( ct.atts ) || StyleConstants.isItalic( ct.atts )
                || StyleConstants.isSubscript( ct.atts ) || StyleConstants.isSuperscript( ct.atts ) ){
                
                Font dfont = _jtp.getFont();
                int size = dfont.getSize();
                if( ct.atts.getAttribute( StyleConstants.FontSize ) != null )
                    size = StyleConstants.getFontSize( ct.atts );
                if( StyleConstants.isSubscript( ct.atts ) || StyleConstants.isSuperscript( ct.atts ) )
                    size -= 2;
                    
                String family = dfont.getFamily();
                if( ct.atts.getAttribute( StyleConstants.FontFamily ) != null )
                    family = StyleConstants.getFontFamily( ct.atts );            
                
                int style = dfont.getStyle();
                if( StyleConstants.isBold( ct.atts ) )
                    style |= Font.BOLD;
                if( StyleConstants.isItalic( ct.atts ) )
                    style |= Font.ITALIC;
                
                f = new Font( family, style, size );

            }
            else f = _jtp.getFont();
            g.setFont( f );
            FontMetrics fm = g.getFontMetrics();
            int width = fm.stringWidth( ct.data );
            totalwidth += width;
        
        }
        g.dispose();
        return totalwidth;
    }
    return 0;       
}</t>
<t tx="ekr.20070127142814.75">@
These methods replace the displayHook and exceptHook of the regular interpreter.
@c
@others</t>
<t tx="ekr.20070127142814.76">public void displayHook( PyObject o ){

        if (o == Py.None)
             return;

        PySystemState sys = Py.getThreadState().systemState;
        sys.builtins.__setitem__("_", Py.None);
        PyObject orepr = o.__repr__();
        

        try{
            String ostring = outputprompt.getPrompt( linenumber );
            //_jtp.getDocument().insertString( _jtp.getCaretPosition(), ostring, outpSet );
            int cp = _jtp.getCaretPosition();
            Document doc = _jtp.getDocument();
            if( !supressing ){

                Iterator&lt;ColoredToken&gt; tokens = outputprompt.coloredPrompt( linenumber );
                while( tokens.hasNext() ){
                
                    ColoredToken ct = tokens.next();
                    doc.insertString( cp, ct.data, ct.atts );
                    cp += ct.data.length();
                
                }
                _jtp.setCaretPosition(  cp  );//_jtp.getCaretPosition() + ostring.length() );
            }
        }
        catch( BadLocationException ble ){}
        if( output.size() -1 == linenumber ){
            output.remove( linenumber );
            output.append( o );
        }
        else
            output.append( o );
        if( !supressing ) 
            Py.println( orepr );
        sys.builtins.__setitem__("_", o);
        int olength = output.size();
        if( olength &gt; 2 ) _pi.set( "___", output.get( olength - 3 ) );
        if( olength &gt; 1 ) _pi.set( "__", output.get( olength -2 ) );
        String name = String.format( "_%1$s", linenumber );
        _pi.set( name, o );
        Out.put( output.size() -1, o );
        

}</t>
<t tx="ekr.20070127142814.77">public void exceptHook(PyObject type, PyObject value, PyObject tb)//, PyObject file)
    {
        StdoutWrapper stderr = Py.stderr;

        colorizer.clearPositions();
        if (tb instanceof PyTraceback)
            stderr.print(((PyTraceback) tb).dumpStack());
        if (__builtin__.isinstance(value, (PyClass) Py.SyntaxError)) {
            stderr.println("  File \""+value.__findattr__("filename")+
                           "\", line "+value.__findattr__("lineno"));
            PyObject text = value.__findattr__("text");
            if (text != Py.None &amp;&amp; text.__len__() != 0) {
                stderr.println("\t"+text);
                String space = "\t";
                int col = ((PyInteger)value.__findattr__("offset").__int__()).getValue();
                for(int j=1; j&lt;col; j++)
                    space = space+" ";
                stderr.println(space+"^");
            }
        }

        if (value instanceof PyJavaInstance) {
            Object javaError = value.__tojava__(Throwable.class);

            if (javaError != null &amp;&amp; javaError != Py.NoConversion) {
                stderr.println(getStackTrace((Throwable)javaError));
            }
        }
        stderr.println(formatException(type, value, tb));
        if( pdbonexception )
            _pi.exec( "import pdb;pdb.pm()" );
    }
</t>
<t tx="ekr.20070127142814.78">String getStackTrace(Throwable javaError) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        javaError.printStackTrace(new PrintStream(buf));

        String str = buf.toString();
        int index = -1;
        if (index == -1)
            index = str.indexOf(
                "at org.python.core.PyReflectedConstructor.call");
        if (index == -1)
            index = str.indexOf("at org.python.core.PyReflectedMethod.call");
        if (index == -1)
            index = str.indexOf(
                "at org/python/core/PyReflectedConstructor.call");
        if (index == -1)
            index = str.indexOf("at org/python/core/PyReflectedMethod.call");

        if (index != -1)
            index = str.lastIndexOf("\n", index);

        int index0 = str.indexOf("\n");

        if (index &gt;= index0)
            str = str.substring(index0+1,index+1);

        return str;
    }</t>
<t tx="ekr.20070127142814.79">String formatException(PyObject type, PyObject value, PyObject tb) {
        StringBuffer buf = new StringBuffer();

        PyObject typeName;
        if (type instanceof PyClass) {
            buf.append(((PyClass) type).__name__);
        } else { 
            buf.append(type.__str__());
        }
        if (value != Py.None) {
            buf.append(": ");
            if (__builtin__.isinstance(value, (PyClass) Py.SyntaxError)) {
                buf.append(value.__getitem__(0).__str__());
            } else {
                buf.append(value.__str__());
            }
        }
        return buf.toString();
    }</t>
<t tx="ekr.20070127142814.80">public final void keyPressed( final KeyEvent event ){
    
    if( event.isConsumed() ) return;
    final char which = event.getKeyChar();
    final int kc = event.getKeyCode();
    String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
    if( opmodifiers.equals( "Ctrl" ) &amp;&amp; ignorekc.contains( kc ) ) return;
    if( opmodifiers.equals( "Alt" ) &amp;&amp; kc == KeyEvent.VK_P ) return;

    KeyStroke ks = KeyStroke.getKeyStrokeForEvent( event );
    if( isRegisteredKeyStroke( ks ) ) return;
    
    if( suspend ){
        event.consume();
        return;
    
    
    }
    if( outputspot &gt; _jtp.getCaretPosition() ){
    
        try{
            event.consume();
            _jtp.setCaretPosition( outputspot );
            return;
        }
        catch( IllegalArgumentException iae ){
        
            Document doc = _jtp.getDocument();
            _jtp.setCaretPosition( doc.getEndPosition().getOffset() );
            return;
        
        }
    
    
    }
    
    if( which == '\n' ){
    
        event.consume();
        closeUtilityBoxes(); 
        udm.discardAllEdits();
        refreshUndoRedo();
        final Document doc = _jtp.getDocument();
        final int cp = _jtp.getCaretPosition();
        try{
            
        String line = get_input( cp );
        _jtp.setCaretPosition( endOfLine() );
        if( opmodifiers.equals( "Ctrl" ) ){
            if( line.trim().equals( "" ) ){
            
                doc.insertString( _jtp.getCaretPosition(), "\n", null );
                line = "";
            
            }
            else{
                doc.insertString( _jtp.getCaretPosition(), ":\n", null );
                line += ":";   
            }
        }
        else
            doc.insertString( _jtp.getCaretPosition() , "\n", null );    
        final StringBuilder sb = new StringBuilder();
        for( final char c: line.toCharArray() ){
            
            if( Character.isLetterOrDigit( c ) )
                sb.append( c );
            else{
            
                abbrevs.add( sb.toString() );
                sb.delete( 0, sb.length() );
                
                }
            
            
            }
        if( sb.length() != 0 ) abbrevs.add( sb.toString() );
        lines.add( line );      
        
        if( stdinbarrier.getNumberWaiting() != 0 ){
        
            standardin.put( line );
            resettool = new CountDownLatch(1);
            stdinbarrier.await();
            resettool.await();
            resettool = null;
            stdinbarrier.reset();
            return;
        
        }
        

        execute.add( line );
        final FutureTask&lt;Boolean&gt; ft = new FutureTask&lt;Boolean&gt;( this );
        execute1( ft );
        Runnable r = new Runnable(){
        
            public void run(){
                try{

                    final boolean more = ft.get();
                    Runnable next = getNextPrompt( more );
                    SwingUtilities.invokeAndWait( next );

                }
                catch( Exception x ){}
            }
        };
        execute1( r );
        return;
        
        }
        catch( final Exception x ){
            try{

                getStandardErr().write( (x.toString()+"\n").getBytes() );
                insertPrompt( false );
            
            }
            catch( final Exception xx ){
                xx.printStackTrace();
            
            }
        
        }
    
    }
    else{
        
        try{
 
            if( kc == event.VK_BACK_SPACE ){
                if( _jtp.getCaretPosition() -1 &lt; outputspot ) event.consume();
                return; // very important to return here!
            }
            
            if( !Character.isDefined( event.getKeyChar() ) )return;
            event.consume();
            final char k = event.getKeyChar();
            int end = endOfLine();
            String line = get_input( _jtp.getCaretPosition() );
            String original_line = line;
            int cp = _jtp.getCaretPosition();
            int splitpoint = cp - outputspot;//start;
            Map&lt; Character, Character &gt; chars = new HashMap&lt; Character, Character &gt;();
            chars.put( '[', ']' );
            chars.put( '(', ')' );
            chars.put( '{', '}' );
            chars.put( '"', '"' );
            chars.put( '\'', '\'' );
            String part1 = line.substring( 0, splitpoint );
            String part2 = line.substring( splitpoint );
            String k2 = "";
            boolean backone = false;
            if( chars.containsKey( k ) ){
            
                 k2 = chars.get( k ).toString();
    
                
                }
            
            line = part1 + k + k2 + part2;
            colorize( line, k+k2, _jtp.getCaretPosition(),  outputspot, end );
            _jtp.setCaretPosition( cp + 1 );
        
        }
        catch( final Exception x ){
            //x.printStackTrace();
        
        }
    
    
    
    
    }
    


}

@others</t>
<t tx="ekr.20070127142814.81">public final void keyReleased( final KeyEvent event ){
 
    KeyStroke ks = KeyStroke.getKeyStrokeForEvent( event );
    if( isRegisteredKeyStroke( ks ) ) return;
    event.consume();

}</t>
<t tx="ekr.20070127142814.82">public final void keyTyped( final KeyEvent event ){

    KeyStroke ks = KeyStroke.getKeyStrokeForEvent( event );
    if( isRegisteredKeyStroke( ks ) ) return; 
    event.consume();


}</t>
<t tx="ekr.20070127142814.83">@others
</t>
<t tx="ekr.20070127142814.84">@others</t>
<t tx="ekr.20070127142814.85">public final PyObject getPyObject( final String[] split2 ){ // such a simple method, is so vital...

    PyObject po1 = null;
    try{
        for( String s: split2 ){
    
            if( po1 == null ){
        
                po1 = _pi.get( s );
                continue;
            
                }
            else{
        
                po1 = po1.__findattr__( new PyString( s ) );

                if( po1 == null ) break;
        
        
        
            } 
        
        }
    }catch( Exception x ){}

    return po1;
    
}</t>
<t tx="ekr.20070127142814.86">public String getObjectName( PyObject py ){

    return py.getType().fastGetName();


}</t>
<t tx="ekr.20070127142814.87">public Object getBuiltin( String name ){

    
    PySystemState pss = Py.getSystemState();
    //System.out.println( pss.builtins.getClass() );
    PyStringMap builtins = (PyStringMap)pss.builtins;
    //System.out.println( builtins );
    PyObject po = builtins.get( new PyString( name ) );
    if( po != null ){

        java.util.List&lt;Method&gt; methods = new LinkedList&lt;Method&gt;();
        Method[] dmethods = __builtin__.class.getDeclaredMethods();
        for( Method m : dmethods ){
        
            if( m.getName().equals( name ) ) methods.add( m );
        
        }
        if( methods.size() != 0 ) return methods;
        return po;

    }
    return null;

}</t>
<t tx="ekr.20070127142814.88">public void checkForJythonReference( String[] pieces ){
    
    for( int i = 0; i &lt; pieces.length; i ++ ){
            
        String s = pieces[ i ];
        if( s.startsWith( "$" ) ){
            
            String nwpiece = s.substring( 1 );
            PyObject po = getPyObject( nwpiece.split( "\\." ) );
            if( po == null ) pieces[ i ] = nwpiece;
            else pieces[ i ] = po.__repr__().toString();
            
            
        }
        
        
    }
    
}

public String checkForJythonReference( String s ){


    Pattern p = Pattern.compile( "\\${1,2}\\w+|\\$\\{.+\\}" );
    Matcher m = p.matcher( s );
    StringBuffer sb = new StringBuffer();
    while( m.find() ){
        
        int start = m.start();
        int end = m.end();
        boolean isenv = false;
        String sstring = s.substring( start, end );
        if( sstring.startsWith( "$$" ) ) isenv = true;
        sstring = sstring.substring( 1 );
        PyObject po = getPyObject( sstring.split( "\\." ) );
        if( po != null ) m.appendReplacement( sb, Matcher.quoteReplacement( po.__repr__().toString() ) );
        else if( sstring.startsWith( "{" ) &amp;&amp; sstring.endsWith( "}" ) ){
        
            String string2 = sstring.substring( 1, sstring.length() -1 );
            PyObject po2 = _pi.eval( string2 );
            if( po2 != null ) m.appendReplacement( sb, Matcher.quoteReplacement( po2.__repr__().toString() ) );
            else m.appendReplacement( sb, Matcher.quoteReplacement( sstring ) );
        
        }
        else if( isenv ){
        
            String estring = sstring.substring( 1 );
            String evar = System.getenv( estring );
            if( evar != null ) m.appendReplacement( sb, Matcher.quoteReplacement( evar ) );
            else m.appendReplacement( sb, Matcher.quoteReplacement( sstring ) );
        
        
        }
        else m.appendReplacement( sb, Matcher.quoteReplacement( sstring ) );
    
    }
    m.appendTail( sb );
    return sb.toString();

}</t>
<t tx="ekr.20070127142814.89">public void addBookmark( String bm, File directory ){

    bookmarks.put( bm, directory );


}

public File getBookmark( String bm ){

    if( bookmarks.containsKey( bm ) )
        return bookmarks.get( bm );
    return null;
    
}

public void removeBookmark( String bm ){


    if( bookmarks.containsKey( bm ) ) bookmarks.remove( bm );


}

public void clearBookmarks(){

    bookmarks.clear();

}

public Iterator&lt;Map.Entry&lt;String,File&gt;&gt; getBookmarks(){


    return bookmarks.entrySet().iterator();

}


</t>
<t tx="ekr.20070127142814.90">public PyList getDirectoryHistory(){

    return new PyList( (PyObject)dhistory );


}

public void addDirectoryToHistory( File directory ){

    dhistory.add( directory.toString() );

}

public String getDirectoryHistryEntryN( int n ){

    if( dhistory.size() &lt; Math.abs(n) ) return null;
    PyInteger pi = new PyInteger( n );
    return dhistory.__getitem__( pi ).toString();

}</t>
<t tx="ekr.20070127142814.91">public PyList getDirectoryStack(){

    return new PyList( (PyObject)dstack );

}


public String getTopOfDStack(){

    return dstack.get( 0 ).toString();

}

public String popDStack(){
    
    if( dstack.size() == 1 ) return null;
    return dstack.remove( 0 ).toString();


}


public void pushDStack( File f ){

    setCurrentWorkingDirectory( f );
    dstack.add( 0, f.toString() );


}


</t>
<t tx="ekr.20070127142814.92">@others
</t>
<t tx="ekr.20070127142814.93">public final boolean magicCommand( final String command ){

    MagicCommand handler = null;
    for( MagicCommand mc: mcommands ){
    
        if( mc.handle( command ) ){
        
            handler = mc;
            break;
        
        }
    
    
    }
    if( handler != null ) return handler.doMagicCommand( command );
    else{
        try{
            
            getStandardErr().write( "Magic Command not recognized\n".getBytes() );
        
        }
        catch( IOException io ){}
    
    }
    return true;

}</t>
<t tx="ekr.20070127142814.94">public boolean isMagicCommand( String command ){

   if( command == null ) return false;
   for( MagicCommand mc: mcommands )if( mc.handle( command ) ) return true;
   return false;

}</t>
<t tx="ekr.20070127142814.95">private void createMagicCommands(){

    Class[] commands = new Class[]{
    
        Macro.class, History.class, Debugger.class, Prun.class, Threads.class,
        XSLT.class, Serialize.class, Deserialize.class, Clean.class, Swing.class,
        Pwd.class, See.class, Cd.class, Ps.class, Ls.class, Send.class, Wait.class,
        Kill.class, Clear.class, Lsmagic.class, Magic.class, Url.class, Bg.class, Pfile.class,
        Pdoc.class, Pinfo.class, P.class, R.class, Env.class, Save.class, Who.class, Whos.class,
        Autocall.class, Autoindent.class, Sc.class, Sx.class, Who_ls.class, Ed.class, Reset.class,
        org.leo.shell.magic.Alias.class, Rehash.class, Rehashx.class, Unalias.class, Run.class,
        Keystrokes.class, Bookmark.class, Dhist.class, Dirs.class, Popd.class, Pushd.class,
        Automagic.class, Logstart.class, Logoff.class, Logon.class, Logstate.class, Bgprocess.class,
        Runlog.class, Iuse.class
    
    };

    for( Class z: commands ){
        try{
            MagicCommand mc = (MagicCommand)z.newInstance();
            registerMagicCommand( mc );
        }
        catch( InstantiationException ie ){}
        catch( IllegalAccessException iae ){}
    
    }


}</t>
<t tx="ekr.20070127142814.96">public void registerMagicCommand( MagicCommand mc ){
    
    if( mc == null ) return;
    mc.setJythonShell( this );
    mcommands.add( mc );

}

public void unregisterMagicCommand( MagicCommand mc ){

    if( mc == null ) return;
    mcommands.remove( mc );

}</t>
<t tx="ekr.20070127142814.97">public MagicCommand createMagicCommandFromJython( String name, String code ){

    try{   
        StringBuilder sb = new StringBuilder();
        sb.append( "import org.leo.shell.MagicCommand as MagicCommand\n" ).append( code );
        code = sb.toString();
        byte[] data = code.getBytes();
        ByteArrayInputStream bais = new ByteArrayInputStream( data );
        PyObject po = imp.createFromSource( name, bais, code );
        PyClass mcommand = (PyClass) __builtin__.getattr( po, new PyString( name )  );
        PyObject instance =  mcommand.__call__( new PyObject[]{}, new String[]{} );
        MagicCommand mc = (MagicCommand)Py.tojava( instance, MagicCommand.class );
        mc.setJythonShell( this );
        return mc;
    }
    catch( Exception x ){}
    return null;

}</t>
<t tx="ekr.20070127142814.98">@others
</t>
<t tx="ekr.20070127142814.99">public final void dynamicAbbreviation(){

    //int start = startOfLine();
    int end = _jtp.getCaretPosition();
    final Document doc = _jtp.getDocument();

    try{
    String line = doc.getText( outputspot, end - outputspot );
    

    final String[] pieces = line.split( "[^\\w^%]");//"\\W" );
    final String current;
    if( pieces.length &gt; 0 ) current = pieces[ pieces.length -1 ];
    else
        current = line;
    
    
    String astart = current;
    if( _lab != null &amp;&amp; _lab.current.equals( current ) &amp;&amp; ( _lab.spos == end - current.length() ) ){
    

        astart = _lab.start;
    
    
    }
    
    final String nabbrev = findNextAbbreviation( astart, current );
        
    if( nabbrev != null ){
            _lab = new Abbreviation( astart, nabbrev, end - current.length() );
            String nline;
            if( line.length() != current.length() ){
            
                nline = line.substring( 0, line.length() - current.length() );
                
                }
            else
                nline = "";
                
            nline = nline + nabbrev;
            doc.remove( outputspot, end - outputspot );
            colorize( nline, nline, outputspot, outputspot, end );
        
        }
    
    }
    catch( final Exception x ){
    
        x.printStackTrace();

    }

}
</t>
<t tx="ekr.20070127142814.100">public final String findNextAbbreviation( final String start, final String current ){

    final LinkedList&lt;String&gt; llist = new LinkedList&lt;String&gt;();
    for( final String s: abbrevs ){
    
        if( s.startsWith( start ) ) llist.add( s );
        
    }
      
    if( llist.size() &gt; 0 ){
    
        final int index = llist.indexOf( current );
        final int size = llist.size();
        if( index == -1 ||  ( index == size -1 ) )
            return llist.get( 0 );
        else{
        
            return llist.get( index + 1 );
        
        
        
        }         
         
        
        }
    else return null;


}</t>
<t tx="ekr.20070127142814.101">public final int startOfLine(){

    
    try{
        
        Element e = Utilities.getParagraphElement( _jtp, _jtp.getCaretPosition() );
        return e.getStartOffset();
        
    
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }
    
    return 0;

}



public int endOfLine(){

    try{

            
        Element e = Utilities.getParagraphElement( _jtp, _jtp.getCaretPosition() );
        return e.getEndOffset() -1;
    
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }
    return 0;


}

</t>
<t tx="ekr.20070127142814.102">public final void colorize( final String line, final String insert, final int insertspot, final int start, final int end ){

    colorizer.colorize( line, insert, insertspot, start, end );

}
</t>
<t tx="ekr.20070127142814.103">public void closeUtilityBoxes(){

    UtilityBoxEvent ube = new UtilityBoxEvent( this, UBEventType.Close );
    for( UtilityBoxListener ubl: utilboxlisteners.toArray( new UtilityBoxListener[]{} ) )
        ubl.utilityBoxClose( ube );


}</t>
<t tx="ekr.20070127142814.104">public final FutureTask&lt;Boolean&gt; processScript( final java.util.List&lt;String&gt; script ){

    //admittedly, we could do this from any method, but this just makes it easier to use. :)
    _jtp.setCaretPosition( getOutputSpot() );
    ScriptExecutor se = new ScriptExecutor( this, script );
    return se.submit();
   
}



</t>
<t tx="ekr.20070127142814.105">public java.util.List&lt;String&gt; processHistoryString( String hstring ){

    String[] pieces = hstring.split( "\\s+" );
    LinkedList&lt;String&gt; hitems = new LinkedList&lt;String&gt;();
    for( String chunk: pieces ){
        try{
            int isslice = chunk.indexOf( ":" );
            if( isslice != -1 ){
                
                String part1 = chunk.substring( 0, isslice );
                String part2 = chunk.substring( isslice + 1 );
                int s1 = Integer.valueOf( part1 );
                int s2 = Integer.valueOf( part2 );
                java.util.List&lt;String&gt; subhistory = history.subList( s1, s2 );
                for( String s: subhistory ) hitems.add( s );
                
        
            }         
            else{
            
                int lspot = Integer.valueOf( chunk );
                String line = history.get( lspot ).toString();
                hitems.add( line );
            
            
            }
        }
        catch( NumberFormatException nfe ){}
        catch( IndexOutOfBoundsException iobe ){}
    }
    
    return hitems;
}</t>
<t tx="ekr.20070127142814.106">public synchronized Runnable getNextPrompt( boolean more ){

    if( nextprompt == null ){
    
        return new InsertPrompt( this, more );
        
    
    }
    Runnable run = nextprompt;
    nextprompt = null;
    return run;


}


public synchronized void setNextPrompt( Runnable run ){

    nextprompt = run;


}</t>
<t tx="ekr.20070127142814.107">public void setAutomagic( boolean status ){

    automagic = status;

}

public boolean getAutomagic(){

    return automagic;

}</t>
<t tx="ekr.20070127142814.108">public void addLogger( OutputStream log ){

    loggers.add( log );

}

public void removeLogger( OutputStream log ){

    if( loggers.contains( log ) ) loggers.remove( log );


}</t>
<t tx="ekr.20070127142814.109">@others
</t>
<t tx="ekr.20070127142814.110">public JTextComponent getShellComponent(){


    return _jtp;
    

}

public File getCurrentWorkingDirectory(){

    return cwd;


}

public void setCurrentWorkingDirectory( File f ){

    cwd = f;
    addDirectoryToHistory( f );

}
</t>
<t tx="ekr.20070127142814.111">public OutputStream getStandardOut(){

    return stdout;


}

public OutputStream getStandardErr(){


    return stderr;

}</t>
<t tx="ekr.20070127142814.112">public int getOutputSpot(){

    return outputspot;

}

public void setOutputSpot( int spot ){

    outputspot = spot;

}</t>
<t tx="ekr.20070127142814.113">public void setPdbOnException( boolean on ){

    pdbonexception = on;


}

public boolean getPdbOnException(){


    return pdbonexception;


}</t>
<t tx="ekr.20070127142814.114">public java.util.List&lt;String&gt; getWho(){

    return who;


}</t>
<t tx="ekr.20070127142814.115">public boolean getAutocall(){

    return autocall;

}

public void setAutocall( boolean value ){

    autocall = value;

}</t>
<t tx="ekr.20070127142814.116">public void setAutoindent( boolean value ){

    autoindent = value;

}

public boolean getAutoindent(){

    return autoindent;

}</t>
<t tx="ekr.20070127142814.117"></t>
<t tx="ekr.20070127142814.118">public String getDocumentation(){

    String separator = "---------------\n";
    String draggin = "Draging Files into The Shell:\n"+
    "This has the happy effect of executing the contents of "+
    "the file as a script.  Drag away!\n\n";


    String input = "Input caching system:\n"+
    "The JythonShell offers numbered prompts (In/Out) with input and output caching. All input is saved and can be retrieved as variables (besides the usual arrow key recall). The following GLOBAL variables always exist (so don t overwrite them!): _i: stores previous input. _ii: next previous. _iii: next-next previous. _ih : a list of all input _ih[n] is the input from line n and this list is aliased to the global variable In. If you overwrite In with a variable of your own, you can remake the assignment to the internal list with a simple  In=_ih . Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt; being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;] == In[&lt;n&gt;]. For example, what you typed at prompt 14 is available as _i14, _ih[14] and In[14].\n" +
    "This allows you to easily cut and paste multi line interactive prompts by printing them out: they print like a clean string, without prompt characters. You can also manipulate them like regular variables (they are strings), modify or exec them (typing  exec _i9  will re-execute the contents of input prompt 9,  exec In[9:14]+In[18]  will re-execute lines 9 through 13 and line 18). You can also re-execute multiple lines of input easily by using the magic %macro function (which automates the process and allows re-execution without having to type  exec  every time). The macro system also allows you to re-execute previous lines which include magic function calls (which require special processing).  A history function %hist allows you to see any part of your input history by printing a range of the _i variables.\n\n";
    
    
    String output = "Output caching system:\n"+
    "For output that is returned from actions, a system similar to the input cache exists but using _ instead of _i. Only actions that produce a result (NOT assignments, for example) are cached. If you are familiar with Mathematica, JythonShell's _ variables behave exactly like Mathematica s % variables. The following GLOBAL variables always exist (so don t overwrite them!): _ (a single underscore) : stores previous output, like Python s default interpreter. __ (two underscores): next previous. ___ (three underscores): next-next previous. Additionally, global variables named _&lt;n&gt; are dynamically created (&lt;n&gt; being the prompt counter), such that the result of output &lt;n&gt; is always available as _&lt;n&gt; (don t use the angle brackets, just the number, e.g. _21). These global variables are all stored in a global dictionary (not a list, since it only has entries for lines which returned a result) available under the names _oh and Out (similar to _ih and In). So the output from line 12 can be obtained as _12, Out[12] or _oh[12]. If you accidentally overwrite the Out variable you can recover it by typing  Out=_oh  at the prompt.\n\n";
    
    
    String dhist = "Directory history:\n"+
    "Your history of visited directories is kept in the global list _dh, and the magic %cd command can be used to go to any entry in that list. The %dhist command allows you to view this history.\n\n";
    
    StringBuilder sb = new StringBuilder();
    sb.append( draggin );
    sb.append( separator );
    sb.append( input );
    sb.append( separator );
    sb.append( output );
    sb.append( separator );
    sb.append( dhist );
    return sb.toString();

}</t>
<t tx="ekr.20070127142814.119">public String getKeystrokeDescriptions(){
    
    StringBuilder sb = new StringBuilder();
    final String keystrokes = "Keystrokes:\n"+
    "-------------\n"+ 
    "Enter -- this processes the current line from the prompt to the end,\n regardless of where the cursor is at\n"+
    "Ctrl Enter -- This keystroke has two meanings:\n" +
    "1. process the current line with a ':' appended to the end of it,\n regardless of where the cursor is at.\nThis is the behavior if there is character data on the line\n" +
    "2. If the line is pure whitespace, then the line is interpreted as a '' string with a length of 0.\n\n";
    
    sb.append( keystrokes ); 
    
    InputMap im = _jtp.getInputMap();
    ActionMap am = _jtp.getActionMap();
    Map&lt;String,String&gt; docs = new HashMap&lt;String,String&gt;();
    for( KeyStroke ks: im.keys() ){
    
        Object value = im.get( ks );
        ActionListener al = (ActionListener)am.get( value );
        if( al instanceof Documentation ){
        
            Documentation doc = (Documentation)al;
            String description = doc.getDocumentation();
            String keystroke = String.format( "%1$s %2$s", 
                                              KeyEvent.getKeyModifiersText( ks.getModifiers() ),
                                              KeyEvent.getKeyText( ks.getKeyCode() ) ).trim();
            docs.put( keystroke, description );
         
         }
    
    }
    java.util.List&lt;String&gt; keys = new ArrayList&lt;String&gt;( docs.keySet() );
    Collections.sort( keys );
    for( String s: keys ){
    
        sb.append( s );
        sb.append( " ---&gt; " );
        sb.append( docs.get( s ) ); 
        sb.append( "\n" );       
    
    }

    return sb.toString();

}</t>
<t tx="ekr.20070127142814.120">public String getMagicDescriptions(){

    StringBuilder sb = new StringBuilder();
    for( MagicCommand mc: mcommands ){
        sb.append( mc.getName() ).append( "\n" );
        String description = mc.getDescription();
        if( description.endsWith( "\n" ) &amp;&amp; !description.endsWith( "\n\n" ) ) description += "\n";
        else if( !description.endsWith( "\n\n" ) ) description += "\n\n";
        sb.append( description );
        sb.append( "------------------\n" );

    }
    sb.append( "\n" );
    return sb.toString();


}</t>
<t tx="ekr.20070127142814.121">public String getInteractiveDescriptions(){

    StringBuilder sb = new StringBuilder();
    sb.append( "Shell Interactive Use:\n" );
    char[] c = new char[ 15 ];
    Arrays.fill( c, '-' );
    String separator = new String( c );
    for( Documentation doc: iudocproviders ){
        sb.append( separator ).append( "\n" );
        String dstring = doc.getDocumentation();
        sb.append( dstring );
        if( dstring.endsWith( "\n\n" ) );
        else if( dstring.endsWith( "\n" ) ) sb.append( "\n" );
        else sb.append( "\n\n" );
    
    
    }
    return sb.toString();

}

public void addInteractiveDocumentation( Documentation doc ){

    iudocproviders.add( doc );

}</t>
<t tx="ekr.20070127142814.122">public String getUnifiedHelp(){

    final StringBuilder sb = new StringBuilder(); 
    
    sb.append( getKeystrokeDescriptions() );    
    sb.append( getInteractiveDescriptions() );

    final String magic = "Magic Commands:\n"+
    "----------------\n" +
    "Entering one of the following commands will cause its\n"+
    "corresponding command to execute:\n\n";
    sb.append( magic );
    sb.append( getMagicDescriptions() );

    
    final String note = "A Note on JPIDs and the CWD:\n"+
    "-----------------------------\n"+
    "JPIDs are not PIDs of the OS.  They are a system by which the JythonShell\n"+
    "can keep track of Processes created by it, and means by which the user can\n"+
    "manipulate those Processes.\n\n"+
    "The CWD does not indicate what the process is working in.  It is intended to function\n"+
    "with the Magic Commands.  This system does not interoperate with java.io.File or Jython\n"+
    "open.  To achieve interopability the user should use the magic command of the form:\n"+
    "%cwd reference\n"+
    "This will place a java.io.File in the reference.  The File instance is a copy of the CWD\n"+
    "File and will allow the user to open, write, create, close streams and such in the JythonShell's\n"+
    "CWD\n";
    
    sb.append( note );
    return sb.toString();
    
}
</t>
<t tx="ekr.20070127142814.123"></t>
<t tx="ekr.20070127142814.124">public final void print(){

    final String data = _jtp.getText();
    final HashDocAttributeSet hatt = new HashDocAttributeSet();
    final SimpleDoc sdoc = new SimpleDoc(  data , DocFlavor.STRING.TEXT_PLAIN , hatt );
    final PrintService[] pservices = PrintServiceLookup.lookupPrintServices( DocFlavor.STRING.TEXT_PLAIN , hatt );
    
    if( pservices.length != 0 ){
    
        final HashPrintRequestAttributeSet hpattset = new HashPrintRequestAttributeSet();
        final PrintService ps = ServiceUI.printDialog( null, 50, 50, pservices, pservices[ 0 ], DocFlavor.STRING.TEXT_PLAIN, hpattset );
        if( ps != null ){
            
            final DocPrintJob dpj = ps.createPrintJob();
            //dpj.addPrintJobListener( self.PrintJobReporter() )
            try{
            
                dpj.print( sdoc, hpattset );
            }
            catch( final Exception x ){
                
                x.printStackTrace();
            
            }
            
            }

        }


}</t>
<t tx="ekr.20070127142814.125">public final void open(){

    final JFileChooser jfc = new JFileChooser();
    javax.swing.filechooser.FileFilter pff = new javax.swing.filechooser.FileFilter(){
    
        public boolean accept( File f ){
        
            String name = f.getName();
            if( name.endsWith( ".py" ) ) return true;
            else if( f.isDirectory() ) return true;
            return false;
        
        }
    
        public String getDescription(){ return ".py files"; };
    
    };
    jfc.setFileFilter( pff );
    if( jfc.APPROVE_OPTION  ==jfc.showOpenDialog( base ) ){
    
        try{
        
            final File f = jfc.getSelectedFile();
            final FileReader fr = new FileReader( f );
            final BufferedReader br = new BufferedReader( fr );
            final Vector&lt;String&gt; execute = new Vector&lt;String&gt;();
            while( true ){
            
                String data = br.readLine();
            
                if( data == null ) break;
                if( data.startsWith( "&gt;&gt;&gt;" ) || data.startsWith( "..." ) )
                    data = data.substring( 3 );
                execute.add( data );
                
            }     
            br.close();    
            processScript( execute );
             
        }
        catch( final Exception x ){
            
            x.printStackTrace();
        
        }
       
    
    }





}
</t>
<t tx="ekr.20070127142814.126">public final void save(){


    final JFileChooser jfc = new JFileChooser();
    if( jfc.APPROVE_OPTION  ==jfc.showSaveDialog( base ) ){
    
        try{
            final File f = jfc.getSelectedFile();
            final PrintWriter pw = new PrintWriter( f );
            for( final String data: lines ){
            
                pw.println( data );
                
                }
            pw.close();
        }
        catch( final Exception x ){
            
            x.printStackTrace();
        
        }
    
    
    
    }



}</t>
<t tx="ekr.20070127142814.127">public final void close(){

    //_frame.setVisible( false );
    //_frame.dispose();
    try{
        if( closer != null ) closer.call();
    }
    catch( Exception x ){}

}

public final void setCloser( Callable call ){

    closer = call;


}</t>
<t tx="ekr.20070127142814.128">public final void help(){

    final JFrame jf = new JFrame();
    jf.setTitle( "JythonShell Help" );
    jf.setLayout( new BorderLayout() );
    jf.setDefaultCloseOperation( jf.DISPOSE_ON_CLOSE );
    jf.setSize( base.getSize() );
    jf.setLocation( base.getLocation() );
    final JTextArea jta = new JTextArea();
    jta.setLineWrap( true );
    jta.setEditable( false );
    jta.setForeground( colorconfig.getForegroundColor() );//_fg );
    jta.setBackground( colorconfig.getBackgroundColor() );//_bg );
    jta.setFont( _jtp.getFont() );    
    jta.setText( getUnifiedHelp() );
    jta.setCaretPosition( 0 );
    final JScrollPane jsp = new JScrollPane( jta );
    jsp.setHorizontalScrollBarPolicy( jsp.HORIZONTAL_SCROLLBAR_NEVER );
    jf.add( jsp, BorderLayout.CENTER );
    final JPanel jp = new JPanel();
    final AbstractAction clz = new AbstractAction( "Close "){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            jf.setVisible( false );
            jf.dispose();
        
        }
    
    
    };
    final JButton close = new JButton( clz );
    jp.add( close );
    jf.add( jp, BorderLayout.SOUTH );
    jf.setVisible( true );


}</t>
<t tx="ekr.20070127142814.129">@
public final Action getCut(){

    final Action cut = new AbstractAction( "Cut" ){
        public final void actionPerformed( final ActionEvent ae ){
            _jtp.cut();
        }
    };


    return cut;
}</t>
<t tx="ekr.20070127142814.130">public Action getPasteAsScript(){ return pas;}</t>
<t tx="ekr.20070127142814.131">@others
</t>
<t tx="ekr.20070127142814.132">public final static class JythonDelegate{

    final JythonShell _js;

    public JythonDelegate( final JythonShell js ){
    
        _js = js;
    
    
    }

    public final void addToMenu( final JComponent jm ){
        
        final int count = _js._jmb.getComponentCount();
        _js._jmb.add( jm, count -1 );
    
    
    }
    
    
    public final void processAsScript( final java.util.List&lt;String&gt; data ){
    
        _js.processScript( data );
    
    
    }
    
    public final void requestFocusInWindow(){
    
    
        _js._jtp.requestFocusInWindow();
    
    
    }
    
    public final void remove( final int pos ){
    
        try{
    
            _js._jtp.getDocument().remove( pos, 1 );
            
        }
        catch( BadLocationException ble ){}
    
    }
    
    public final void setReference( Object ref, Object data ){
    
    
        _js._pi.set( ref.toString(), data );
    
    
    }
    
    public final Object getReference( final String ref ){
    
        return _js.getPyObject( ref.split( "\\." ) );
    
    
    }

    public final int insertWidget( final JComponent jc ){
    
        final Document doc = _js._jtp.getDocument();
        int remove_pos = 0;
        try{
        
            final SimpleAttributeSet sas = new SimpleAttributeSet();
            StyleConstants.setComponent( sas, jc );
            doc.insertString( _js._jtp.getCaretPosition(), "\n", sas );
            remove_pos = _js._jtp.getCaretPosition();
            doc.insertString( remove_pos, "\n", sas );
            _js.insertPrompt( false );
        
        }
        catch( BadLocationException ble ){
        
        }
        
        return remove_pos;
    
    } 


}</t>
<t tx="ekr.20070127142814.133">public final static class _SelectionReturner implements ListSelectionListener{

    private final JTextPane _jtp;

    public _SelectionReturner( final JTextPane jtp ){
    
        _jtp = jtp;
    
    }

    public final void valueChanged( final ListSelectionEvent lse ){
    
    
        _jtp.requestFocusInWindow();
    
    
    }



}</t>
<t tx="ekr.20070127142814.134">public static class RemoveObjects implements MouseWheelListener{

    JythonShell js;
    
    public RemoveObjects( JythonShell js ){
    
        this.js = js;
    
    }

    public void mouseWheelMoved( MouseWheelEvent me ){
    
        js.closeUtilityBoxes();
    
    }


}
</t>
<t tx="ekr.20070127142814.135">@
public static class DropFileMechanism extends DropTargetAdapter{

    JythonShell js;
    public DropFileMechanism( JythonShell js ){
        super();
        this.js = js;
        DropTarget dt = new DropTarget( js.getShellComponent(), this );
        dt.setDefaultActions( DnDConstants.ACTION_COPY );
    }

    public void drop( DropTargetDropEvent dte ){
        boolean gotData = false;
        try{
            dte.acceptDrop( DnDConstants.ACTION_COPY );
            Transferable trans = dte.getTransferable();
            if( trans.isDataFlavorSupported( DataFlavor.javaFileListFlavor ) ){
                try{
                    java.util.List&lt;File&gt; files = (java.util.List&lt;File&gt;)trans.getTransferData( DataFlavor.javaFileListFlavor );
                    for( File f: files ){
                        FileInputStream fis = new FileInputStream( f );
                        BufferedReader br = new BufferedReader( new InputStreamReader( fis ) );
                        LinkedList&lt;String&gt; script = new LinkedList&lt;String&gt;();
                        String s = null;
                        while( ( s = br.readLine() ) != null ) script.add( s );
                        br.close();
                        js.processScript( script );
                    }
                    gotData = true;
                }
                catch( UnsupportedFlavorException ufe ){}
                catch( IOException io ){}
                return;
            }
            else if ( trans.isDataFlavorSupported( DataFlavor.stringFlavor )){
                try{
                    String s = (String)trans.getTransferData( DataFlavor.stringFlavor );
                    URL url = new URL( s );
                    InputStream is = url.openStream();
                    BufferedReader br = new BufferedReader( new InputStreamReader( is ) );
                    String line = null;
                    LinkedList&lt;String&gt; script = new LinkedList&lt;String&gt;();
                    while( ( line = br.readLine() ) != null ){
                        script.add( line );
                    }
                    br.close();
                    gotData = true;
                    js.processScript( script );
                }
                catch( UnsupportedFlavorException ufe ){}
                catch( MalformedURLException mue ){}
                catch( IOException io ){}
                }
            }
            finally{
                dte.dropComplete( gotData );
                js.getShellComponent().requestFocus();
            }
        return;

    }


}</t>
<t tx="ekr.20070127142814.136">public static class DropFileMechanism extends TransferHandler{

    JythonShell js;
    TransferHandler delegate;
    public DropFileMechanism( JythonShell js ){
        super();
        this.js = js;
        JTextComponent sc = js.getShellComponent();
        delegate = sc.getTransferHandler();
        sc.setTransferHandler( this );
        
    
    
    }
    
    @Override
    public void exportToClipboard( JComponent comp, Clipboard clipboard, int action ){
    
    
        delegate.exportToClipboard( comp, clipboard, action );
    
    }
    
    @Override
    public boolean canImport( JComponent c, DataFlavor[] transfers ){
    
        for( DataFlavor df: transfers ){

            if( df.isFlavorTextType() ) return true;
            else if( df.isFlavorJavaFileListType() ) return true;
            
        }
        return false;
    
    }
    
    @Override
    public boolean importData( JComponent c, Transferable trans ){
        
        boolean gotData = false;
        DataFlavor[] flavors = trans.getTransferDataFlavors();
        boolean ok = false;
        for( DataFlavor flavor: flavors ){
        
            if( flavor.isFlavorJavaFileListType() ){
                ok = true;
                break;
            }
            else if( flavor.equals( uriListFlavor ) ){
                ok = true;
                break;
            
            }
        
        }
        if( !ok ) return delegate.importData( c, trans );
        try{
            if( trans.isDataFlavorSupported( DataFlavor.javaFileListFlavor ) ){
            
                try{
                    java.util.List&lt;File&gt; files = (java.util.List&lt;File&gt;)trans.getTransferData( DataFlavor.javaFileListFlavor );
                    for( File f: files ){
                    
                        FileInputStream fis = new FileInputStream( f );
                        BufferedReader br = new BufferedReader( new InputStreamReader( fis ) );
                        LinkedList&lt;String&gt; script = new LinkedList&lt;String&gt;();
                        String s = null;
                        while( ( s = br.readLine() ) != null ) script.add( s );
                        br.close();
                        js.processScript( script );
                       
                    
                    }
                    gotData = true;
                }
                catch( UnsupportedFlavorException ufe ){}
                catch( IOException io ){}
        
            }
            else if ( trans.isDataFlavorSupported( uriListFlavor )){
                
                
                try{
                    String s = (String)trans.getTransferData( DataFlavor.stringFlavor );
                    URL url = new URL( s );
                    InputStream is = url.openStream();
                    BufferedReader br = new BufferedReader( new InputStreamReader( is ) );
                    String line = null;
                    LinkedList&lt;String&gt; script = new LinkedList&lt;String&gt;();
                    while( ( line = br.readLine() ) != null ){
                
                        script.add( line );
                    
                
                    }
                    br.close();
                    gotData = true;
                    js.processScript( script );
            
                }
                catch( UnsupportedFlavorException ufe ){ ufe.printStackTrace(); }
                catch( MalformedURLException mue ){ mue.printStackTrace();} 
                catch( IOException io ){ io.printStackTrace(); }
                }
            }
            finally{
            
                //dte.dropComplete( gotData );
            
            }
            return gotData;

    }


}</t>
<t tx="ekr.20070127142814.137">public static class JSColorConfigurationListener implements ColorConfigurationListener{

    JythonShell js;
    public JSColorConfigurationListener( JythonShell js ){
    
        this.js = js;
    
    }
    
    public void colorChanged( ColorEvent ce ){
    
        ColorConfiguration cc = (ColorConfiguration)ce.getSource();
        if( cc == js.colorconfig ){
        
            ColorConstant constant = ce.getColorConstant();
            switch( constant ){
            
            
                &lt;&lt;case statement&gt;&gt;
            
            
            
            
            }

        
        }
    
        
    
    }



}</t>
<t tx="ekr.20070127142814.138">case Background:
    js._jtp.setBackground( cc.getBackgroundColor() );
    break;
case Foreground:
    js._jtp.setForeground( cc.getForegroundColor() );
    js._jtp.setCaretColor( cc.getForegroundColor() );
    break;
case Out:
    SimpleAttributeSet outSet = new SimpleAttributeSet();
    StyleConstants.setForeground( outSet, cc.getOutColor() );
    StyleConstants.setFirstLineIndent( outSet, 0 );
    js.outSet = outSet;
    break;
case Error:
    SimpleAttributeSet errSet = new SimpleAttributeSet();
    StyleConstants.setForeground( errSet, cc.getErrColor() );
    StyleConstants.setFirstLineIndent( errSet, 0 );
    js.errSet = errSet;</t>
<t tx="ekr.20070127142814.139">public static class DefaultPrimaryPrompt extends PromptFormatter implements ColorConfigurationListener{
    
    ColoredToken ct1;
    ColoredToken ct2;
    SimpleAttributeSet ncolor;
    public DefaultPrimaryPrompt( ColorConfiguration cc ){
    
        super( cc );
        configure();
        cc.registerColorConfigurationListener( this ); 
    
    }
    
    private void configure(){
    
        ColorConfiguration cc = getColorConfiguration();
        SimpleAttributeSet sas = new SimpleAttributeSet();
        StyleConstants.setForeground( sas, cc.getPromptOneColor() );
        ct1 = new ColoredToken( "In [", sas );
        ct2 = new ColoredToken( "]: ", sas );
        ncolor = new SimpleAttributeSet();
        StyleConstants.setForeground( ncolor, cc.getPromptOneNumberColor() );    
    
    
    }
    
    public void colorChanged( ColorEvent ce ){
    
        switch( ce.getColorConstant() ){
        
            case Promptone:
                configure();
                break;
            case Promptonenumber:
                configure();
                break;
        
        
        }
    
    
    }

    public Iterator&lt;ColoredToken&gt; coloredPrompt( int linenumber ){
    
        String number = String.valueOf( linenumber );
        ArrayList&lt;ColoredToken&gt; al = new ArrayList&lt;ColoredToken&gt;( 3 );
        al.add( ct1 );
        ColoredToken ctnum = new ColoredToken( number, ncolor );
        al.add( ctnum );
        al.add( ct2 );
        return al.iterator();
    
    
    }

    public String getPrompt( int linenumber ){
        
        return String.format( "In [%1$d]: ", linenumber );

    }
    

}

public static class DefaultSecondaryPrompt extends PromptFormatter implements ColorConfigurationListener{


    ColoredToken ct1;
    java.util.List&lt;ColoredToken&gt; cprompts;
    public DefaultSecondaryPrompt( ColorConfiguration cc ){
    
        super( cc );
        configure();
        cc.registerColorConfigurationListener( this );
        
    }
    
    private void configure(){
        
        ColorConfiguration cc = getColorConfiguration();
        SimpleAttributeSet sas = new SimpleAttributeSet();
        StyleConstants.setForeground( sas, cc.getPromptTwoColor() );
        ct1 = new ColoredToken( "...: ", sas );
        cprompts = new ArrayList&lt;ColoredToken&gt;(1);
        cprompts.add( ct1 );        
    
    }

    public void colorChanged( ColorEvent ce ){
    
        switch( ce.getColorConstant() ){
        
            case Prompttwo:
                configure();
                break;
        
        }    
    
    
    } 

    public Iterator&lt;ColoredToken&gt; coloredPrompt( int linenumber ){
    
        return cprompts.iterator();
    
    
    }


    public String getPrompt( int linenumber ){
    
        return "...: ";
    
    }
    
    
}


public static class DefaultOutputPrompt extends PromptFormatter implements ColorConfigurationListener{

    ColoredToken ct1;
    ColoredToken ct2;
    SimpleAttributeSet ncolor;
    public DefaultOutputPrompt( ColorConfiguration cc ){
    
        super( cc );
        configure();
        cc.registerColorConfigurationListener( this ); 
    
    }
    
    private void configure(){
    
        ColorConfiguration cc = getColorConfiguration();
        SimpleAttributeSet sas = new SimpleAttributeSet();
        StyleConstants.setForeground( sas, cc.getOutPromptColor() );
        ct1 = new ColoredToken( "Out [", sas );
        ct2 = new ColoredToken( "]: ", sas );
        ncolor = new SimpleAttributeSet();
        StyleConstants.setForeground( ncolor, cc.getOutPromptNumberColor() );    
    
    
    
    }

    public void colorChanged( ColorEvent ce ){
    
        switch( ce.getColorConstant() ){
        
            case Outprompt:
                configure();
                break;
            case Outpromptnumber:
                configure();
                break;
        
        
        }    
        
    
    }

    public Iterator&lt;ColoredToken&gt; coloredPrompt( int linenumber ){
    
        String number = String.valueOf( linenumber );
        ArrayList&lt;ColoredToken&gt; al = new ArrayList&lt;ColoredToken&gt;( 3 );
        al.add( ct1 );
        ColoredToken ctnum = new ColoredToken( number, ncolor );
        al.add( ctnum );
        al.add( ct2 ); 
        return al.iterator();
    
    
    }

    public String getPrompt( int linenumber ){

        return String.format( "Out [%1$d]: ", linenumber );
       
    }
    

}</t>
<t tx="ekr.20070127142814.140">public static final void main( final String[] args ){

    Runnable start = new Runnable(){
    
        public void run(){
            JythonShell js = new JythonShell();
            js.setVisible( true );
            JComponent base = js.getWidget();
            final JFrame jf = new JFrame();
            jf.add( base );
            jf.setDefaultCloseOperation( jf.DISPOSE_ON_CLOSE );
            jf.setTitle( "Jython Shell" );
            jf.setSize( new Dimension( 500, 500 ) );
            Callable close = new Callable(){
    
                public Object call(){
        
                    jf.setVisible( false );
                    jf.dispose();
                    System.exit( 0 );
                    return null;
        
                }
    
            };
            js.setCloser( close );
            if( args.length != 0 ){
    
                String imagelocation = args[ 0 ];
                ImageIcon ii = new ImageIcon( imagelocation );
                js.setBackgroundImage( ii.getImage(), 1.0f );

            }
            jf.setVisible( true );
            
        }
    };
    System.setProperty( "swing.boldMetal", "false" );
    SwingUtilities.invokeLater( start );
}
//this is a demonstration of a Jython magic command, doesn't do anything useful
private static String mockmcommand = "class z( MagicCommand ):\n"+
"    def setJythonShell( self, js ):\n"+
"        self.js = js\n"+
"    def getName( self ): return '%fullscreen'\n"+
"    def getDescription( self ): return '%fullscreen --&gt; turns shell into fullscreen mode, this is not a core mc, but a demonstration of a Jython written magic command.'\n"+
"    def handle( self, command ): return command.strip() == \"%fullscreen\"\n"+
"    def doMagicCommand( self, command ):\n"+
"        import java.awt as awt\n"+
"        import javax.swing as swing\n"+
"        import org.leo.shell.util.InsertPrompt as InsertPrompt\n"+
"        ge = awt.GraphicsEnvironment.getLocalGraphicsEnvironment()\n"+
"        gd = ge.getDefaultScreenDevice()\n"+
"        if gd.isFullScreenSupported():\n"+
"            window = swing.JWindow()\n"+
"            window.add( self.js.getWidget() )\n"+
"            #window.setIgnoreRepaint( True )\n"+
"            gd.setFullScreenWindow( window )\n"+
"            self.js.getShellComponent().requestFocus()\n"+
"        else:\n"+
"            print 'Full screen mode not supported\\\n'\n"+
"        ip = InsertPrompt( self.js, False )\n"+
"        swing.SwingUtilities.invokeLater( ip )\n";

</t>
<t tx="ekr.20070127142814.141">@language java
package org.leo.shell;


public interface MagicCommand{


    public void setJythonShell( JythonShell shell );
    public boolean handle( String command );
    public boolean doMagicCommand( String command );
    public String getName();
    public String getDescription();



}</t>
<t tx="ekr.20070127142814.142">@language java
package org.leo.shell;

public interface LineListener{

    public String lineToExecute( String line ) throws LineListenerException;
    
}</t>
<t tx="ekr.20070127142814.143">@language java
package org.leo.shell;


public class LineListenerException extends Exception{

    
    public LineListenerException( String message ){
    
        super( message );
    
    }


}</t>
<t tx="ekr.20070127142814.144">@language java
package org.leo.shell;

public interface UtilityBoxListener{

    public void utilityBoxShown( UtilityBoxEvent ube );
    public void utilityBoxClose( UtilityBoxEvent ube );

}</t>
<t tx="ekr.20070127142814.145">@language java
package org.leo.shell;

import java.util.EventObject;

public class UtilityBoxEvent extends EventObject{

    public static enum UBEventType{
    
        Shown, Close
    
    
    }
    
    UBEventType ubet;
    public UtilityBoxEvent( Object source, UBEventType ubet ){
    
        super( source );
        this.ubet = ubet;
    
    }

    public UBEventType getEventType(){ return ubet; }


}</t>
<t tx="ekr.20070127142814.146">@language java
package org.leo.shell;

import java.util.*;
import java.awt.Font;
import javax.swing.text.AttributeSet;
import org.leo.shell.color.ColorConfiguration;

public abstract class PromptFormatter{

    public static class ColoredToken{
    
        public String data;
        public AttributeSet atts;
        public ColoredToken( String data, AttributeSet atts ){
        
            this.data = data;
            this.atts = atts;
        
        
        }
        
    
    }
    
    ColorConfiguration cc;
    public PromptFormatter( ColorConfiguration cc ){
    
        this.cc = cc;
    
    }
    public ColorConfiguration getColorConfiguration(){ return cc; }
    public abstract String getPrompt( int linenumber );
    public abstract Iterator&lt;ColoredToken&gt; coloredPrompt( int linenumber );


}</t>
<t tx="ekr.20070127142814.147">@language java
package org.leo.shell;


public interface Documentation{


    public String getDocumentation();



}</t>
<t tx="ekr.20070127142814.148">@path org/leo/shell/magic</t>
<t tx="ekr.20070127142814.149">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.LineListener;
import org.leo.shell.MagicCommand;
import java.io.IOException;
import java.io.OutputStream;
import java.util.*;
import java.lang.ref.*;
import org.python.core.*;


public class Macro implements MagicCommand,LineListener{

    JythonShell js;
    Map&lt;String, LinesExecutor&gt; macros;
    //ReferenceQueue&lt;LinesExecutor&gt; ref;
    
    public Macro(){
    
        macros = new HashMap&lt;String, LinesExecutor&gt;();
        //ref = new ReferenceQueue&lt;LinesExecutor&gt;();
    
    }
    
    public String getName(){ return "%macro"; }
    
    
    public String getDescription(){
    
        return "%macro --&gt; this defines a macro that can be executed by using the name given:\n" +
        "An example:\n"+
        "%macro macex 9:10 11 12:13 4\n"+
        "This creates a macro called macex and puts line 9-10, 11 12-13 and 4 from the history into it\n" +
        "Hence entering macex and typing enter will cause those lines to rexecute.\n"+
        "To see the contents of the macro type: print macroname\n" +
        "This will print out the macro's contents.\n" +
        "To remove a macro: del macroname\n\n";
    
    }
    
    public String lineToExecute( String line ){
    
        String test = line.trim();
        if( macros.containsKey( test ) ){
        
         LinesExecutor le = macros.get( test );
         Object o = js._pi.get( test );
         if( o == le )
            return String.format( "%1$s()", test );
        else macros.remove( test );

         }
        return line;
    
    }
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addLineListener( this );
    
    }


    public boolean handle( String command ){
    
        return command.startsWith( "%macro" );
    
    }


    public boolean doMagicCommand( String command ){
        
        List&lt;String&gt; history = js.history;
        String[] chunks = command.split( "\\s+" );
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            if( chunks.length &lt; 3 ){
    
                String message = "%macro requires form: %macro macroname n1:n2 n3:n4 ... n5 n6\n";
                err.write( message.getBytes() );
                return false;    
    
            }
            String macro = chunks[ 1 ];
            StringBuilder sb = new StringBuilder();
            for( int i = 2; i &lt; chunks.length; i ++ ) sb.append( chunks[ i ] ).append( " " );
            java.util.List&lt;String&gt; maclines = js.processHistoryString( sb.toString() );
            LinesExecutor le = new LinesExecutor( macro, maclines , js );
            macros.put( macro, le );
            js._pi.set( macro, le );
            
        }
        catch( IOException io ){}
        return false;

    }

    &lt;&lt;class LinesExecutor&gt;&gt;

}
</t>
<t tx="ekr.20070127142814.150">public static class LinesExecutor extends PyObject{

    String name;
    java.util.List&lt;String&gt; contents;
    JythonShell js;
    public LinesExecutor( String name, java.util.List&lt;String&gt; contents, JythonShell js ){
    
        this.name = name;
        this.contents = contents;
        this.js = js;
    
    }




    
    public PyString __str__(){
    
        StringBuilder sb = new StringBuilder();
        for( String s: contents ) sb.append( s ).append( "\n" );
        return new PyString( sb.toString() );
    
    }
    

    public PyObject __call__(){
        
        for( String s: contents ){
             if( s.startsWith( "%" ) ){
             
                js.magicCommand( s );
             
             }
             else js._pi.exec( s );
        
        }
        return Py.None;
    
    }

}</t>
<t tx="ekr.20070127142814.151">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.InsertPrompt;
import java.util.*;
import javax.swing.SwingUtilities;
import java.io.OutputStream;
import java.io.IOException;


public class History implements MagicCommand{

    JythonShell js;
    public History(){
    
    
    
    }
    
    public String getName(){ return "%hist"; }
    public String getDescription(){
    
    
        return "%hist --&gt; this has 3 forms and actions:\n" +
        "   %hist [ -n ]  --&gt; this prints the total history or the last 40 items in it.\n" +
        "   %hist [ -n ] n1 --&gt; this prints the last n1 items in the history.\n" +
        "   %hist [ -n ] n1 n2 --&gt; this prints the items from index n1 to index n2.\n" +
        "   -n signifies that line numbers should not be printed out\n\n";
    
    } 
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }

    public boolean handle( String command ){
    
        return ( command.startsWith( "%hist " ) || command.trim().equals( "%hist" ) );
    
    
    }

    public boolean doMagicCommand( String command ){
    
    List&lt;String&gt; history = js.history;
    boolean option_n = false;
    int index = command.indexOf( "-n" );
    OutputStream out = js.getStandardOut();
    OutputStream err = js.getStandardErr();
    try{
        if( index != -1 ){
    
            String test = command.substring( 0, index );
            test = test.trim();
            if( test.equals( "%hist" ) ){
        
                option_n = true;
                command = command.replaceFirst( "\\-n", "" );
        
            }
      
    
        }
        String[] pieces = command.trim().split( "\\s+" );
        if( pieces.length == 2 ){ 
    
            &lt;&lt;from&gt;&gt;
    
        }
        if( pieces.length == 3 ){
            
                &lt;&lt;range&gt;&gt;
        }   
        if( pieces.length == 1 ){
    
            java.util.List&lt;String&gt; range = null;
            int start = 0;
            if ( history.size() &lt; 40 ){
            range = new ArrayList&lt;String&gt;();
            range.addAll( history );
            }
            else{
                range = history.subList( history.size() - 40, history.size() );
                start = history.size() - 40;    
        
            }
            outputList( range, !option_n, start );
            //InsertPrompt ip = new InsertPrompt( js, false );
            //java.util.List&lt;Runnable&gt; runners = new ArrayList&lt;Runnable&gt;();
            //runners.add( ip );
            //OutputList ol = new OutputList( range, start, js.getStandardOut(), !option_n, runners );
            //js.execute1( ol );
            return false;
    
        }

        err.write( ("Invalid Form For %hist:\n" +
                        "%hist [ -n ] \n" +
                        "%hist [ -n ] n1 \n" +
                        "%hist [ -n ] n1 n2 \n").getBytes() );
        //js.insertPrompt( false );
        return false;
    }
    catch( IOException io ){ return false; }

}

public boolean isNumber( String data ){

    for( char c: data.toCharArray() ){
        if( !Character.isDigit( c ) ) return false;   
    
    }
    return true;   
    
    
    
    }

    @others


}</t>
<t tx="ekr.20070127142814.152">final String number1 = pieces[ 1 ];

if( isNumber( number1 ) ){

    int amount = Integer.valueOf( number1 );
    if( amount &gt; history.size() ){
    
        String message = String.format( "Illegal Request: History size is %1$d request size is %2$d\n" , history.size(), amount );
        err.write( message.getBytes() );
        //js.badMagicCommand( message );
	       //js.insertPrompt( false );
        return false;
    
    }
    java.util.List&lt;String&gt; range = new ArrayList&lt;String&gt;( amount );
    int start = ( history.size() - amount );
    ListIterator&lt;String&gt; li = history.listIterator( start );
    while( li.hasNext() ) range.add( li.next() );
    //InsertPrompt ip = new InsertPrompt( js, false );
    outputList( range, !option_n , start );
    //java.util.List&lt;Runnable&gt; runners = new ArrayList&lt;Runnable&gt;();
    //runners.add( ip );
    //OutputList ol = new OutputList( range, start , js.getStandardOut(), !option_n,  runners );
    //js.execute1( ol );
    return false;

}
else{

    String message = "First parameter must be a number\n";
    err.write( message.getBytes() );
    //js.badMagicCommand( message );
    //js.insertPrompt( false );
    return false;

}</t>
<t tx="ekr.20070127142814.153">final String number1 = pieces[ 1 ]; 
final String number2 = pieces[ 2 ];
if( isNumber( number1 ) &amp;&amp; isNumber( number2 ) ){
                
    int start = Integer.valueOf( number1 );
    int end = Integer.valueOf( number2 );
    if( end &gt; history.size() + 1 ) {
    
        String message = String.format( "Illegal Request: History size is %1$d request size is %2$d\n" , history.size(), end );
        //js.badMagicCommand( message );
	    //js.insertPrompt( false );
        err.write( message.getBytes() );
        return false;
    
    
    }
    java.util.List&lt;String&gt; range = history.subList( start, end );
    outputList( range, !option_n, start );
    //InsertPrompt ip = new InsertPrompt( js, false );
    //java.util.List&lt;Runnable&gt; runners = new ArrayList&lt;Runnable&gt;();
    //runners.add( ip );
    //OutputList ol = new OutputList( range, start, js.getStandardOut(), !option_n, runners );
    //js.execute1( ol );
    return false;
         
}
else{
    
    boolean n1 = isNumber( number1 );
    boolean n2 = isNumber( number2 );
    String message;
    if( !n1 &amp;&amp; !n2 ) message = "Both parameters must be numbers\n";
    else if( !n1 ) message = "Parameter one must be a number\n";
    else message = "Parameter two must be a number\n";
    err.write( message.getBytes() );
    //js.badMagicCommand( message );
    //js.insertPrompt( false );
    return false;

}
        
</t>
<t tx="ekr.20070127142814.154">public static class OutputList implements Runnable{

    java.util.List&lt;String&gt; range;
    java.util.List&lt;Runnable&gt; tailactions;
    int start;
    OutputStream stdout;
    boolean linenumbering;
    public OutputList( java.util.List&lt;String&gt; l, int start, OutputStream out, boolean linenumbering, java.util.List&lt;Runnable&gt; tailactions ){
     
        range = l;
        this.start = start;        
        this.tailactions = tailactions;
        stdout = out;
        this.linenumbering = linenumbering;
    }        
        
    public void run(){

        for( int i = 0; i &lt; range.size(); i ++){
            String s = range.get( i );
            String s2 = "";
            if( linenumbering )
                s2 = String.format( "%1$d: %2$s\n", start++, s );
            else
                s2 = String.format( "%1$s\n", s );
            try{
                stdout.write( s2.getBytes() );
            }
            catch( IOException io ){}
 
        }
        for( Runnable runner: tailactions )
            SwingUtilities.invokeLater( runner );
    }  
}</t>
<t tx="ekr.20070127142814.155">private void outputList( java.util.List&lt;String&gt; range, boolean linenumbering, int start ) throws IOException{

    OutputStream stdout = js.getStandardOut();
    for( int i = 0; i &lt; range.size(); i ++){
        String s = range.get( i );
        String s2 = "";
        if( linenumbering )
            s2 = String.format( "%1$d: %2$s\n", start++, s );
        else
            s2 = String.format( "%1$s\n", s );
        stdout.write( s2.getBytes() );

 
    }

}</t>
<t tx="ekr.20070127142814.156">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.InsertPrompt;
import java.io.*;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;
import javax.swing.text.Document;
import javax.swing.text.BadLocationException;
import java.util.concurrent.FutureTask;

public class Debugger implements MagicCommand{

    JythonShell js;
    public Debugger(){
    
    
    
    }
    
    public String getName(){
    
        return "%pdb";
    
    }
    public String getDescription(){
    
        return "%pdb -- three forms:\n"+
               "%pdb --&gt; this starts up the Pdb debugger\n"+
               "%pdb filename --&gt; this runs the file under Pdb in the shell\n"+
               "%pdb [on|1|off|0 ] --&gt; this turns automatic startup of Pdb on an exception on and off:\n"+
               "    %pdb on  --&gt; now on\n"+
               "    %pdb off --&gt; now off\n" +
               "    %pdb 1 --&gt; now on\n" +
               "    %pdb 0 --&gt; now off\n\n";
    
    } 

    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    
    }

    public boolean handle( String command ){
    
        return command.startsWith( "%pdb" ); 
    
    
    }
    
    public boolean doMagicCommand( String command ){
        if( command.trim().equals( "%pdb" ) ){
            js.addLineToExecute( "import pdb" );
            js.addLineToExecute( "pdb.set_trace()" );
        }
        else if( command.split( "\\s+" ).length == 2 ){
        
            String[] tokens = command.split( "\\s+" );
            String onoff = tokens[ 1 ];
            if( onoff.equals( "on" ) || onoff.equals( "1" ) ){
        
                js.setPdbOnException( true );
                return true;
        
            } 
            else if ( onoff.equals( "off" ) || onoff.equals( "0" ) ){
        
                js.setPdbOnException( false );
                return true;
        
            }
            final File f = new File( tokens[ 1 ] );
            if( f.exists() ){
        
                try{
                    FileInputStream fis = new FileInputStream( f );
                    String prolog = "import pdb;pdb.set_trace()\n";
                    ByteArrayInputStream bais = new ByteArrayInputStream( prolog.getBytes() );
                    final SequenceInputStream sis = new SequenceInputStream( bais, fis );
                    Runnable run = new Runnable(){
                
                        public void run(){ 
                        
                            js._pi.execfile( sis, f.getName() );
                            InsertPrompt ip = new InsertPrompt( js, false );
                            try{
                                SwingUtilities.invokeAndWait( ip );
                            }
                            catch( Exception x ){}
                        }
            
                    };
                
                    js.execute2( run );
                    return false;
                }
                catch( IOException io ){}
                return true;
            }
            else{
            
                JTextComponent jtc = js.getShellComponent();
                Document doc = jtc.getDocument();
                try{
                    doc.insertString( jtc.getCaretPosition(), f.getName() + " does not exist\n", null );
                }
                catch( BadLocationException ble ){}
                return true;
         
            }
    
        }
        else
            return true;
    
        class StartPdb implements Runnable{
    
            public void run(){
            
                js.execute1( js );
                FutureTask&lt;Boolean&gt; more = new FutureTask&lt;Boolean&gt;( js );
                js.execute1( more );
                try{
                    more.get();
                    InsertPrompt ip = new InsertPrompt( js, false );
                    SwingUtilities.invokeAndWait( ip );
                
                }
                catch( Exception x ){}
            }
        }
        js.execute2( new StartPdb() );
        return false;

    }
}</t>
<t tx="ekr.20070127142814.157">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.InsertPrompt;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutionException;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;


public class Prun implements MagicCommand{

    JythonShell js;
    
    public String getName(){ return "%prun"; }
    public String getDescription(){
    
        return "%prun -- executes a statement entered on the same line in the profile module:\n %profile statement \n\n"; 
    
    } 

    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }


    public boolean handle( String command ){
    
        return command.startsWith( "%prun " );
    
    
    }
    
    public boolean doMagicCommand( String command ){
    
        &lt;&lt;command&gt;&gt;
    
    
    }



}</t>
<t tx="ekr.20070127142814.158">    String line = command.substring( 5 ).trim();
    String nwcommand = "import profile;profile.run('"+line +"')";
    js.addLineToExecute( nwcommand );
    class StartProfile implements Runnable{
    
        public void run(){
            
            FutureTask&lt;Boolean&gt; more = new FutureTask&lt;Boolean&gt;( js );
            js.execute1( more );
            InsertPrompt ip = new InsertPrompt( js, false );
            try{
                more.get();
                SwingUtilities.invokeAndWait( ip );
            }
            catch( InterruptedException ie ){}
            catch( InvocationTargetException ite ){}
            catch( ExecutionException ee ){}
        }
    }
    js.execute2( new StartProfile() );
    return false;</t>
<t tx="ekr.20070127142814.159">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.util.*;
import javax.swing.*;
import java.awt.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.table.*;



public class Threads implements MagicCommand{


    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%threads"; }
    public String getDescription(){
    
        return "%threads -- shows the threads running and the state they are in.  Selecting a thread results in\n"+
    "the stack of the thread being shown.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.equals( "%threads" );
    
    }
    
    
    public boolean doMagicCommand( String command ) {
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }




}</t>
<t tx="ekr.20070127142814.160">    final Map&lt; Thread, StackTraceElement[] &gt; m = Thread.getAllStackTraces(); 
    
    Set&lt;Thread&gt; s = m.keySet();
    final Vector&lt; Vector&gt; v = new Vector&lt; Vector &gt;();
    final Map&lt;String, Thread&gt; stmap = new HashMap&lt;String, Thread&gt;();
    for( final Thread td: s ){
    
        Vector&lt;String&gt; t = new Vector&lt;String&gt;();
        t.add( td.toString() );
        stmap.put( td.toString(), td );
        t.add( td.getState().toString() );
        v.add( t );
    
    
    }
    
    Vector&lt;String&gt; names = new Vector&lt; String &gt;();
    names.add( "Thread" );
    names.add( "State" );
    final JPanel jp = new JPanel();
    jp.setLayout( new BorderLayout() );
    DefaultTableModel dtm = new DefaultTableModel( v, names );
    final JTable threads = new JTable( dtm );
    threads.setSelectionMode( ListSelectionModel.SINGLE_SELECTION );
    int height = threads.getRowHeight();
    int nwheight = height * 6;
    JScrollPane jsp1 = new JScrollPane( threads );
    jp.add( jsp1, BorderLayout.NORTH );
    Dimension nsize = jsp1.getPreferredSize();
    nsize.height = nwheight;
    jsp1.setPreferredSize( nsize );
    DefaultTableModel fake = new DefaultTableModel();
    fake.addColumn( "Stack" , new Object[]{} );
    final JTable stack = new JTable( fake );
    stack.setSelectionMode( ListSelectionModel.SINGLE_SELECTION );
    JScrollPane jsp2 = new JScrollPane( stack );
    JPanel jp2 = new JPanel( new BorderLayout() );
    jp2.add( jsp2, BorderLayout.CENTER );
    jsp2.setPreferredSize( nsize );
    jp.add( jp2 , BorderLayout.SOUTH );
    
    ListSelectionListener lsl = new ListSelectionListener(){
    
        public final void valueChanged( final ListSelectionEvent lse ){
        
            int index = lse.getFirstIndex();
            Vector&lt;String&gt; thread = v.get( index );
            String thread_name = thread.get( 0 );
            Thread _thread = stmap.get( thread_name );
            StackTraceElement[] ste = _thread.getStackTrace();
            DefaultTableModel dtm = new DefaultTableModel();
            dtm.addColumn( "Stack", ste );    
            stack.setModel( dtm );
        
        }
        
    
    };
    threads.getSelectionModel().addListSelectionListener( lsl );
    
    Runnable inserttable = new Runnable(){
    
        public void run(){
            try{
                SimpleAttributeSet sas = new SimpleAttributeSet();
                StyleConstants.setComponent( sas, jp );
                JTextComponent jtc = js.getShellComponent();
                Document doc = jtc.getDocument();
                doc.insertString( jtc.getCaretPosition(), "\n", sas );   
            }
            catch( BadLocationException ble ){}
        }
    };
    SwingUtilities.invokeLater( inserttable );
</t>
<t tx="ekr.20070127142814.161">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import org.python.core.*;
import java.io.*;

public class XSLT implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }

    public String getName(){ return "%xslt"; }
    public String getDescription(){
    
        return "%xslt reference1 reference2 reference3 -- this allows the user to transform reference2 with the\n"+
    "stylesheet in reference1 putting the result in reference3.\n\n"; 
    
    } 
    
    public boolean handle( String command ){
    
        return command.startsWith( "%xslt" );
    
    }
    
    
    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }



}
</t>
<t tx="ekr.20070127142814.162">    String[] tokens = command.split( "\\s" );
    
    if( tokens.length &lt; 4 ) return true;
    
    PyObject source = js.getPyObject( tokens[ 1 ].split( "\\." ) );
    PyObject xml = js.getPyObject( tokens[ 2 ].split( "\\." ) );
    if( source == null || xml == null ) return true;
    
    StringReader sr = new StringReader( source.toString() ); 
    StreamSource ss = new StreamSource( sr );
    StringReader sr2 = new StringReader( xml.toString() );
    StreamSource ss2 = new StreamSource( sr2 );

    try{
    
        TransformerFactory tf = TransformerFactory.newInstance();
    
        Transformer t = tf.newTransformer( ss );
    
        StringWriter sw = new StringWriter();
        StreamResult sresult = new StreamResult( sw );
    
        t.transform( ss2, sresult );
    
        String data = sw.toString();
        js._pi.set( tokens[ 3 ] , data );
    
    }
    catch( TransformerConfigurationException tce ){
    
        tce.printStackTrace();
    
    }
    catch( TransformerException te ){
    
    
        te.printStackTrace();
    
    }</t>
<t tx="ekr.20070127142814.163">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.python.core.*;
import java.io.*;
import javax.swing.text.*;
import javax.swing.*;


public class Serialize implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%serialize"; }
    public String getDescription(){
    
        return "%serialize reference -- this will save the Object referenced by reference as a serialized Object.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%serialize" );
    
    }

    public boolean doMagicCommand( String command ){
    
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.164">
    String process_message = null;
    try{
    
        final String[] tokens = command.split( "\\s" );
        if( tokens.length &lt; 2 ){
        
            err.write( "Need a reference for %serialize\n".getBytes() );
            return true;
        
        
        }
        final String reference = tokens[ 1 ];
        final PyObject po = js.getPyObject( reference.split( "\\." ) );
        if( po == null ){
        
            err.write( "Not a valid reference\n".getBytes() );
            return true;
        
        }
        final Object o;
        boolean pure_java = false;
        if( po instanceof PyJavaInstance ){
        
            o = Py.tojava( po, Class.forName( js.getObjectName( po ) ) ); //po.__class__.__name__ ) );
            pure_java = true;
            
        }
        else
            o = po;
            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
            final ObjectOutputStream oos = new ObjectOutputStream( baos );
            oos.writeObject( o );
            final byte[] ser_object = baos.toByteArray();
            oos.close();
            
            final JFileChooser jfc = new JFileChooser( js.getCurrentWorkingDirectory() );
            final int approve = jfc.showSaveDialog( js.getShellComponent() );
            if( approve == jfc.APPROVE_OPTION ){
            
                File f = jfc.getSelectedFile();
                final String name = f.getName();
                if( !name.endsWith( ".ser" ) ){
                
                    f = new File( f.getParentFile(), name + ".ser" );
                
                }
                final FileOutputStream fos = new FileOutputStream( f );
                final BufferedOutputStream bos = new BufferedOutputStream( fos );
                bos.write( ser_object );
                bos.close();

            final String type = pure_java? "Java":"Python"; 
            out.write( String.format( "Serialized %s as %s Object\n" , reference, type ).getBytes() );  
        
        }
    
    
    
    }
    catch( final IOException io ){
    
        process_message = "Problem writing Object out";
    
    }
    catch( final ClassNotFoundException cnfe ){
    
        process_message = "Could not find Class to do serialization";
    
    }

    if( process_message != null ){
    
        err.write( process_message.getBytes() );
        
    
    }</t>
<t tx="ekr.20070127142814.165">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.python.core.*;
import org.python.util.*;
import java.io.*;
import javax.swing.text.*;
import javax.swing.*;


public class Deserialize implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%deserialize"; }
    public String getDescription(){
    
        return "%deserialize reference -- this will allow the user to deserialize an Object stored on disk into\n"+
    "the reference.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%deserialize" );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.166">
    
    try{
    
        final String[] tokens = command.split( "\\s" );
        if( tokens.length &lt; 2 ){
            
            err.write( "%deserialize requires a reference".getBytes() );
            return true;
        }
        
        final String reference = tokens[ 1 ];
        final JFileChooser jfc = new JFileChooser( js.getCurrentWorkingDirectory() );
        final int approve = jfc.showOpenDialog( js.getShellComponent() );
        if( approve == jfc.APPROVE_OPTION ){
        
            final File f = jfc.getSelectedFile();
            final FileInputStream fis = new FileInputStream( f );
            final ObjectInputStream ois = new PythonObjectInputStream( fis );
            final Object o = ois.readObject();
            js._pi.set( reference , o );
            out.write( String.format( "%s has been set to %s\n", reference, o ).getBytes() );
        
        }
    
    
    
    }
    catch( final ClassNotFoundException cnfe ){
        
        cnfe.printStackTrace();
        err.write( (cnfe + "\n" ).getBytes() );
        //visualException( cnfe.toString() );
    
    }
</t>
<t tx="ekr.20070127142814.167">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.io.*;


public class Clean implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%clean"; }
    public String getDescription(){
    
        return "%clean - this will destroy all JPIDs\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.equals( "%clean" );
    
    }

    public boolean doMagicCommand( String command ){
    
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.168">for( final Process p: Jpidcore.processes.values() ){
        
    p.destroy();
        
        
}

out.write( String.format( "%s Processes destroyed\n", Jpidcore.processes.size() ).getBytes() );
Jpidcore.processes.clear();




</t>
<t tx="ekr.20070127142814.169">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.*;
import javax.swing.*;
import java.io.*;


public class Swing implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){
    
        return "%swing";
    
    }
    public String getDescription(){
    
        return "%swing reference -- this will place the reference into the editor if the reference\n"+
    "is a JComponent subclass.  Useful for quick gazing of what a Swing component looks like.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%swing" );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.170">final String[] tokens = command.split( "\\s+" );
if( tokens.length  &lt; 2 ){
        
    err.write( "Need a reference for %swing\n".getBytes());
    return true;
        
        
}
final String reference = tokens[ 1 ];
Object o = null;
try{
        
    o = js._pi.get( reference, JComponent.class );
        
}
catch( final  NullPointerException x ){}
catch( final Exception e ){
        
    o = "Exception";
        
}
if( o == null ){
        
    err.write( "Reference refers to nothing\n".getBytes() );
    return true;
        
}
else if( !(o instanceof JComponent) ){
        
    err.write( "Reference not a JComponent\n".getBytes() );
    return true;
            
}

final Object o2 = o;
Runnable run = new Runnable(){
        
    public void run(){
        
        JTextComponent jtc = js.getShellComponent();
        final Document doc = jtc.getDocument();
        final int pos = jtc.getCaretPosition();            
        final SimpleAttributeSet sas = new SimpleAttributeSet();
        StyleConstants.setComponent( sas, (JComponent)o2 );
        try{
            doc.insertString( pos, "\n", sas );
        }
        catch( BadLocationException ble ){}
    }
            
};
SwingUtilities.invokeLater( run );
    
</t>
<t tx="ekr.20070127142814.171">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.io.*;


public class Pwd implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%pwd"; }
    public String getDescription(){
    
        return "%pwd - this shows the Jython Shells current working directory\n"+
    "Following the %pwd with a reference will set the reference to a\n"+
    "java.io.File instance, which represents the current directory\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%pwd " ) || command.trim().equals( "%pwd" ); 
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.172">OutputStream out = js.getStandardOut();
try{
    File cwd = js.getCurrentWorkingDirectory();
    final String[] tokens = command.split( "\\s+" );
    if( tokens.length &gt; 1 ){
            
        final String reference = tokens[ 1 ];
        js._pi.set( reference, new File( cwd.getAbsolutePath() ) );
        return true;
        
        
    }
    else out.write( (cwd.getAbsolutePath()+"\n" ).getBytes() );


}
catch( final IOException io ){
        
        io.printStackTrace();

}
</t>
<t tx="ekr.20070127142814.173">@language java
package org.leo.shell.magic;
import java.util.*;

public class Jpidcore{

    static Map&lt;Process,ProcessBuilder&gt; pbuilders = new HashMap&lt;Process, ProcessBuilder&gt;();
    static Map&lt;Integer,Process&gt; processes = new HashMap&lt;Integer,Process&gt;();

}</t>
<t tx="ekr.20070127142814.174">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.CommandFinder;
import org.leo.shell.util.CommandLineParser;
import java.io.*;
import java.util.List;


public class Bgprocess implements MagicCommand{

    JythonShell js;
    int process_counter;
    public Bgprocess(){
    
        process_counter = 0;
    
    }
    
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }

    public String getName(){ return "%bgprocess"; }
    public String getDescription(){
    
        return "%bgprocess command args --&gt; this will run a system process in the background.\n"+
               "It can be identified and interacted with via the JPID that is returned upon complention of the magic command.\n"+
               "See: %see,%kill,%ps,%clean, %wait and %send for magic commands to interact with the JPID.\n\n";
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%bgprocess " );  
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.175">String[] pieces = command.split( "\\s+", 2 );
pieces[ 1 ] = js.checkForJythonReference( pieces[ 1 ] );
List&lt;String&gt; slpieces = CommandLineParser.parseCommandLine( pieces[ 1 ] );
String[] lpieces = slpieces.toArray( new String[]{} );
File cwd = js.getCurrentWorkingDirectory();
lpieces[ 0 ] = CommandFinder.findCommand( lpieces[ 0 ], cwd );
final ProcessBuilder pb = new ProcessBuilder( lpieces );
pb.directory( cwd );
final Process p = pb.start();
process_counter++;
Jpidcore.processes.put( process_counter, p );
Jpidcore.pbuilders.put( p, pb );
out.write( ( "JPID: " + process_counter + "\n" ).getBytes() );</t>
<t tx="ekr.20070127142814.176">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.*;
import java.io.*;
import java.awt.*;
import javax.swing.*;


public class See implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }

    public String getName(){ return "%see"; }
    public String getDescription(){
    
        return "%see n - this will show any output JPID n has collected.\n"+
    "Placing a reference name after the JPID will place the output in the reference\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%see" );  
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.177">final String[] tokens = command.split( "\\s+" );
if( tokens.length &lt; 2 ){
            
    err.write( "%see requires and argument\n".getBytes() );
    return true;
                    
}
final String pid = tokens[ 1 ];
final Integer i;
try{
    i = Integer.valueOf( pid );
}
catch( NumberFormatException nfe ){
        
    err.write( "%see requires a valid JPID\n".getBytes() );
    return true;
        
        
}
if( Jpidcore.processes.containsKey( i ) ){
            
    final Process p = Jpidcore.processes.get( i );
    try{
        final InputStream is = p.getInputStream();
        final int available = is.available();
        if( available == 0 ){
                
            out.write( ("JPID " + i + " has no output\n" ).getBytes());
                
        }
        else{
                
            final byte[] b = new byte[ available ];
            is.read( b );
            final String input = new String( b );
            if( tokens.length &gt; 2 ){
                    
                final String reference = tokens[ 2 ];
                js._pi.set( reference, input );
                return true;
                
            }
            else{
                
                Runnable run = new Runnable(){
                    
                    public void run(){
                        
                        JTextComponent jtc = js.getShellComponent();
                        final Document doc = jtc.getDocument();
                        final int pos = jtc.getCaretPosition();
                        final JTextArea see_widget = new JTextArea();
                        see_widget.setText( input );
                        see_widget.setCaretPosition( 0 );
                        final FontMetrics fm = see_widget.getFontMetrics( see_widget.getFont() );
                        final Dimension size = see_widget.getPreferredSize();
                        size.height = fm.getHeight() * 5;
                        final JScrollPane jsp = new JScrollPane( see_widget );
                        jsp.setPreferredSize( size );
                        final SimpleAttributeSet sas = new SimpleAttributeSet();
                        StyleConstants.setComponent( sas, jsp );
                        try{
                            doc.insertString( pos, "\n", sas );
                        }
                        catch( BadLocationException ble ){}
                    }
                };
                SwingUtilities.invokeLater( run );
                return true;
                
            } 
        }
    }catch( IOException io ){}
           
        try{
                    
            final int status = p.exitValue();
            out.write( ("JPID " + i +" exited with value of " + status  + "\n").getBytes());
            Jpidcore.processes.remove( i );
                    
        }
        catch( final IllegalThreadStateException itse ){
                    
            out.write(( "JPID " + i +" still active\n").getBytes() );  
                    
        }
                
        return true;

}
else{
            
    err.write( ( pid + " not valid JPID\n" ).getBytes() );
    return true;
            
}



</t>
<t tx="ekr.20070127142814.178">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.io.*;

public class Cd implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%cd"; }
    public String getDescription(){
    
        return "%cd  - this will change the Jython Shells current working directory\n"+ 
    ".. signifies going to the parent, and absolute path will change the\n"+
    "directory to the path and a relative path will change to the path\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%cd " ); 
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.179">
    OutputStream out = js.getStandardOut();
    OutputStream err = js.getStandardErr();
    try{
    
        final String[] tokens = command.split( "\\s+" );
        if( tokens.length &lt; 2 ){
            
            //doc.insertString( pos, "%cd requires a directory to operate\n", null );
            err.write( "%cd requires a directory or bookmark to operate\n".getBytes() );
            
            
        }
        else{
        
            final String path = tokens[ 1 ];
            File cwd = js.getCurrentWorkingDirectory();
            if( path.equals( ".." ) ){
                cwd = cwd.getParentFile();
                js.setCurrentWorkingDirectory( cwd );
                
                }
            else if( path.equals( "-b" ) ){
            
                if( tokens.length == 3 ){
                
                    String bmstring = tokens[ 2 ];
                    File bmark = js.getBookmark( bmstring );
                    if( bmark.exists() &amp;&amp; bmark.isDirectory() ){
                    
                        cwd = bmark;
                        js.setCurrentWorkingDirectory( bmark );
                    
                    }
                    else{
                    
                        if( !bmark.exists() ) err.write( "Bookmark's directory does not exist.\n".getBytes() );
                        else err.write( "Bookmark is not a directory\n".getBytes() );
                        return true;
                    
                    }
                
                
                }
                else{
                    
                    err.write( "-b switch requires a bookmark name.\n".getBytes() );
                    return true;
                
                }
            
            }
            else if( path.matches( "\\-\\d+" ) ){
            
                String digits = path.substring( 1 );
                int histnum = Integer.valueOf( digits );
                String directory = js.getDirectoryHistryEntryN( histnum );
                if( directory != null ){
                
                    File f = new File( directory );
                    if( f.exists() &amp;&amp; f.isDirectory() ){
                    
                        js.setCurrentWorkingDirectory( f );
                        cwd = f;
                    
                    
                    }
                    else{
                    
                        err.write( "The requested directory does not exist in history.\n".getBytes() );
                        return true;
                    
                    }
                
                
                
                }
                else{
                
                    err.write( "The requested directory does not exist in history.\n".getBytes() );
                    return true;
                
                }
            
            
            }
            else if ( path.equals( "-:" ) ){
            
                String directory = js.getDirectoryHistryEntryN( -1 );
                if( directory != null ){
                
                    File f = new File( directory );
                    if( f.exists() &amp;&amp; f.isDirectory() ){
                    
                        js.setCurrentWorkingDirectory( f );
                        cwd = f;
                    
                    
                    }
                    else{
                    
                        err.write( "The requested directory does not exist in history.\n".getBytes() );
                        return true;
                    
                    }
                }
            
            
            }
            else{
                
                final File ndir;
                if( path.startsWith( "/" ) )
                    ndir = new File( path );
                else
                    ndir = new File( cwd, path );
                    
                if( ndir.exists() &amp;&amp; ndir.isDirectory() ){
                    js.setCurrentWorkingDirectory( ndir );
                    cwd = ndir;
                    
                    }
                else{
                    
                    File bmark = js.getBookmark( path );
                    if( bmark != null ){
                    
                        js.setCurrentWorkingDirectory( bmark );
                        cwd = bmark;
                    
                    }
                    else{
                        //doc.insertString( pos, ndir.getAbsolutePath() + " not valid directory\n", null );
                        err.write( (ndir.getAbsolutePath() + " not valid directory\n").getBytes() );
                        return true; 
                    }
                        
                }
            }
            
            //doc.insertString( pos, "CWD is now: " + cwd.getAbsolutePath() + "\n" , null );
            out.write( ("CWD is now: " + cwd.getAbsolutePath() + "\n").getBytes() );

        }
    }
    //catch( final BadLocationException ble ){
    //    ble.printStackTrace();
        //visualException( ble.toString() );

    //}
    catch( IOException io ){}

</t>
<t tx="ekr.20070127142814.180">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.python.core.*;
import java.io.*;


public class Dhist implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%dhist"; }
    public String getDescription(){
        
        return "%dhist: Print your history of visited directories. %dhist -&gt; print full history %dhist n -&gt; print last n entries only %dhist n1 n2 -&gt; print entries between n1 and n2 (n2 not included) This history is automatically maintained by the %cd command, and always available as the global list variable _dh. You can use %cd -&lt;n&gt; to go to directory number &lt;n&gt;.\n\n";   

    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%dhist " ) || command.trim().equals( "%dhist" ); 
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.181">

PyList dhistory = js.getDirectoryHistory();
String[] pieces = command.split( "\\s+" );
OutputStream out = js.getStandardOut();
String format = "%1$d: %2$s\n";
StringBuilder sb = new StringBuilder();
sb.append( "Directory history (kept in _dh)\n" );
try{
    if( pieces.length == 1 ){

        for( int i = 0; i &lt; dhistory.size(); i++ ){
    
            String item = dhistory.get( i ).toString();
            sb.append( String.format( format, i, item ) );    
    
        }
        out.write( sb.toString().getBytes() );
    }
    else if ( pieces.length == 2 ){
    
        int from = Integer.valueOf( pieces[ 1 ] );
        int back = dhistory.size() - from;
        PyList slice = (PyList)dhistory.__getslice__( new PyInteger( back ), new PyInteger( dhistory.size() ), new PyInteger( 1 ) );
        for( int i = 0; i &lt; slice.size(); i++, back++ ){
    
            String item = slice.get( i ).toString();
            sb.append( String.format( format, back, item ) );    
    
        }
        out.write( sb.toString().getBytes() );
        return true;
    
    }
    else if( pieces.length == 3 ){
    
        int start = Integer.valueOf( pieces[ 1 ] );
        int end = Integer.valueOf( pieces[ 2 ] );
        PyList slice = (PyList)dhistory.__getslice__( new PyInteger( start ), new PyInteger( end ), new PyInteger( 1 ) );
        for( int i = 0; i &lt; slice.size(); i++, start++ ){
    
            String item = slice.get( i ).toString();
            sb.append( String.format( format, start, item ) );    
    
        }
        out.write( sb.toString().getBytes() );
        return true;        
    
    
    
    
    }


}
catch( IOException io ){}</t>
<t tx="ekr.20070127142814.182">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.*;
import java.io.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.table.*;
import java.util.*;

public class Ps implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%ps"; }
    public String getDescription(){
    
        return "%ps - this will print out all JPID's the JythonShell has collected.\n" +
    "Placing a reference name after %ps will put a java Set of Processes in the reference:\n"+
    "%ps a   #a now holds a Set of Processes\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%ps" );  
    
    }

    public boolean doMagicCommand( String cmd ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch(IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.183">final DefaultTableModel dtm = new DefaultTableModel();
final Vector&lt; String &gt; jpid = new Vector&lt; String &gt;();
final Vector&lt; String &gt; command = new Vector&lt; String &gt;();
final Vector&lt; String &gt; status = new Vector&lt; String &gt;();
if( Jpidcore.processes.size() == 0 ){
        
    err.write( "No JPIDs To View\n".getBytes() );
    return true;
        
}
final String[] tokens = cmd.split( "\\s+" );
if( tokens.length &gt;= 2 ){
        
    final String reference = tokens[ 1 ];
    js._pi.set( reference, Jpidcore.processes.values() );
    return true;
            
}
for( final Integer i: Jpidcore.processes.keySet() ){
        
    final Process p = Jpidcore.processes.get( i );
    final ProcessBuilder pb = Jpidcore.pbuilders.get( p );
    jpid.add( i.toString() );
    final java.util.List&lt; String &gt; l = pb.command();
    final StringBuilder sb = new StringBuilder();
    for( final String s: l )
        sb.append( s ).append( " " );
    command.add( sb.toString() );
    try{
        final Integer ev = p.exitValue();
        status.add( "Exited with: " + ev );
            
    }
    catch( final IllegalThreadStateException itse ){
                
        status.add( "Active" );
            
    }
        
        
}

dtm.addColumn( "JPID", jpid );
dtm.addColumn( "Command", command );
dtm.addColumn( "Status", status );
final JTable table = new JTable( dtm );
final int height = table.getRowHeight();
final Dimension d = table.getPreferredSize();
d.height = height * 5;
final JScrollPane jsp = new JScrollPane( table );
jsp.setPreferredSize( d );
final SimpleAttributeSet sas = new SimpleAttributeSet();
StyleConstants.setComponent( sas, jsp );
Runnable run = new Runnable(){

    public void run(){
    
        try{
            JTextComponent jtc = js.getShellComponent();
            final Document doc = jtc.getDocument();
            final int pos = jtc.getCaretPosition();
            doc.insertString( pos, "\n", sas );
        
        }
        catch( final BadLocationException ble ){
            ble.printStackTrace();
        }
    }
};
SwingUtilities.invokeLater( run );
</t>
<t tx="ekr.20070127142814.184">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.widget.UneditableTableModel;
import javax.swing.text.*;
import java.io.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.table.*;
import java.util.*;

public class Ls implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%ls"; }
    public String getDescription(){
    
        return "%ls - this will show the contents of the current working directory\n"+
    "Placing a reference name after %ls will put a java array of File instances\n\n"+
    "in the reference: %ls a #a now holds a java array of File instances\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return ( command.startsWith( "%ls " ) || command.trim().equals( "%ls" ) );
    
    }

    public boolean doMagicCommand( final String command ){
    
        Runnable run = new Runnable(){
            public void run(){
                &lt;&lt;command&gt;&gt;
            }
        };
        SwingUtilities.invokeLater( run );
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.185">JTextComponent jtc = js.getShellComponent();
final Document doc = jtc.getDocument();
final int pos = jtc.getCaretPosition();
try{
        
    File cwd = js.getCurrentWorkingDirectory();
    final String[] tokens = command.split( "\\s+" );
    if( tokens.length &gt;= 2 ){
        
        final File[] files = cwd.listFiles();
        final String reference = tokens[ 1 ];
        js._pi.set( reference, files );
        return;
        
        
    }
        
    final String[] names = cwd.list();
    final Map&lt; String, File &gt; fm = new HashMap&lt; String, File &gt;();
    for( final File f: cwd.listFiles() ){
        
        fm.put( f.getName(), f );
            
    }
    Arrays.sort( names );
    final Vector&lt; String &gt; files = new Vector&lt; String &gt;();
    final Vector&lt; String &gt; type = new Vector&lt; String &gt;();
    final Vector&lt; Long &gt; length = new Vector&lt; Long&gt;();
    final Vector&lt; Date &gt; modified = new Vector&lt; Date &gt;();
    final Vector&lt; Boolean&gt; read = new Vector&lt; Boolean &gt;();
    final Vector&lt; Boolean&gt; write = new Vector&lt; Boolean &gt;();   
    for( final String name: names ){
        
        final File f = fm.get( name );
        files.add( name );
        if( f.isFile() )
            type.add( "File" );
        else if( f.isDirectory() )
            type.add( "Directory" );
        else if( f.isHidden() )
            type.add( "Hidden" );
        else 
            type.add( "Unknown" );
        
        length.add( f.length() );
        modified.add( new Date( f.lastModified() ) );
        read.add( f.canRead() );
        write.add( f.canWrite() );
            
    }
        
        
    final DefaultTableModel dtm = new UneditableTableModel();
    dtm.addColumn( "File", names );
    dtm.addColumn( "Type", type );
    dtm.addColumn( "Size", length );
    dtm.addColumn( "Modified", modified );
    dtm.addColumn( "Read", read );
    dtm.addColumn( "Write", write );
        
    final JTable jt = new JTable( dtm );
    jt.setAutoResizeMode( jt.AUTO_RESIZE_OFF );
    final int height = jt.getRowHeight();
    final Dimension size = jt.getPreferredSize();
    size.height = height * 6;
    final JScrollPane jsp = new JScrollPane( jt );
    jsp.setPreferredSize( size );
    final SimpleAttributeSet sas = new SimpleAttributeSet();
    StyleConstants.setComponent( sas, jsp );
    doc.insertString( pos, "\n" , sas );
    
}
catch( final BadLocationException ble ){
    
    ble.printStackTrace();
    //visualException( ble.toString() );
}</t>
<t tx="ekr.20070127142814.186">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
//import javax.swing.text.*;
import java.io.*;
import org.python.core.*;
//import java.awt.*;
//import javax.swing.*;
//import javax.swing.table.*;
//import java.util.*;

public class Send implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%send"; }
    public String getDescription(){
    
        return "%send n reference - this will send the JPID n as input the data in the Jython reference.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%send" );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.187">final String[] tokens = command.split( "\\s+" );
if( tokens.length &lt; 3 ){
        
    err.write( "%send requires a JPID and a Jython reference\n".getBytes() );
    return true;
        
        
}    
final Integer i;
try{
        
    i = Integer.valueOf( tokens[ 1 ] );
            
}
catch( NumberFormatException nfe ){
        
    err.write( (tokens[ 1 ] + " is not a number\n").getBytes() );
    return true;
        
}
if( !Jpidcore.processes.containsKey( i )){
        
    err.write( (i + " is not a valid JPID\n").getBytes() );
    return true;
        
}

final Process p = Jpidcore.processes.get( i );
final PyObject po = js._pi.get( tokens[ 2 ] );
final OutputStream os = p.getOutputStream();
final String s = po.toString();
os.write( s.getBytes() );
//p.destroy();
//processes.remove( i );
out.write( ("JPID " + i + " has been sent " + tokens[ 2 ] + "\n").getBytes() );
return true;
</t>
<t tx="ekr.20070127142814.188">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.io.*;
import org.python.core.*;

public class Wait implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%wait"; }
    public String getDescription(){
    
        return "%wait n - this will cause the JythonShell to suspend until JPID n has finished.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%wait " );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.189">try{
    
    final String[] tokens = command.split( "\\s+" );
    if( tokens.length &lt; 2 ){
        
        err.write( "%wait requires a JPID\n".getBytes() );
        return true;
        
        
    }    
    final Integer i;
    try{
        
        i = Integer.valueOf( tokens[ 1 ] );
        
    }
    catch( NumberFormatException nfe ){
        
        err.write( ( tokens[ 1 ] + " is not a number\n" ).getBytes() );
        return true;
            
    }
    if( !Jpidcore.processes.containsKey( i ) ){
        
        err.write( (i + " is not a valid JPID\n").getBytes() );
        return true;
        
        
    }
    
    final Process p = Jpidcore.processes.get( i );
    p.waitFor();
    Jpidcore.processes.remove( i );
    out.write( ("JPID " + i + " has finished\n").getBytes() );
    return true;
        
}

catch( final InterruptedException ie ){
    ie.printStackTrace();
    
}</t>
<t tx="ekr.20070127142814.190">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.*;
import java.io.*;
import org.python.core.*;
//import java.awt.*;
//import javax.swing.*;
//import javax.swing.table.*;
//import java.util.*;

public class Kill implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%kill"; }
    public String getDescription(){
    
        return "%kill n - this will cause JPID n to be destroyed.\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%kill" );
    
    }

    public boolean doMagicCommand( String command ){
    
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.191">final String[] tokens = command.split( "\\s+" );
if( tokens.length &lt; 2 ){
    err.write( "%kill requires a JPID\n".getBytes() );
    return true;
}    
final Integer i;
try{
        
    i = Integer.valueOf( tokens[ 1 ] );
            
}
catch( NumberFormatException nfe ){
        
    err.write( ( tokens[ 1 ] + " is not a number\n").getBytes() );
    return true;
        
}
if( !Jpidcore.processes.containsKey( i ) ){
        
    err.write( ( i + " is not a valid JPID\n").getBytes() );
    return false;
          
}
final Process p = Jpidcore.processes.get( i );
p.destroy();
Jpidcore.processes.remove( i );
out.write( ( "JPID " + i + " has been removed\n" ).getBytes() );
</t>
<t tx="ekr.20070127142814.192">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.JTextComponent;
import javax.swing.SwingUtilities;

public class Clear implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%clear"; }
    public String getDescription(){
    
        return "%clear -- this clears the shell of all text and starts over with a fresh prompt\n\n"; 
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%clear" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }



}</t>
<t tx="ekr.20070127142814.193">Runnable run = new Runnable(){

    public void run(){
        JTextComponent jtc = js.getShellComponent();
        jtc.setText( "" );
        js.setVisible( true );
    }
};
SwingUtilities.invokeLater( run );</t>
<t tx="ekr.20070127142814.194">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import java.io.OutputStream;
import java.io.IOException;

public class Lsmagic implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%lsmagic"; }
    public String getDescription(){
    
        return "%lsmagic --&gt; returns the current available set of magic commands\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%lsmagic" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
    
    }



}</t>
<t tx="ekr.20070127142814.195">StringBuilder sb = new StringBuilder();
for( MagicCommand mc: js.mcommands )
    sb.append( mc.getName() ).append( " " );

sb.append( "\n" );
OutputStream out = js.getStandardOut();
try{
    out.write( "Available magic commands:\n".getBytes() );
    out.write( sb.toString().getBytes() );
}
catch( IOException io ){}
return true;</t>
<t tx="ekr.20070127142814.196">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.widget.Pager;
import javax.swing.text.JTextComponent;
import javax.swing.SwingUtilities;
import java.io.IOException;
import java.io.OutputStream;


public class Magic implements MagicCommand{

    JythonShell js;
    Pager pager;
    
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%magic"; }
    public String getDescription(){
    
        return "%magic --&gt; invoke like so:\n"+
        "%magic --&gt; this prints out the description of the magic commands\n" +
        "%magic %magiccommandname\n" +
        "And the usuage/description of the specific magic command will be printed out\n\n";
    
    } 

    public boolean handle( String command ){
    
        return (command.startsWith( "%magic " ) || command.trim().equals( "%magic" ) );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
        
    }



}</t>
<t tx="ekr.20070127142814.197">String[] chunks = command.split( "\\s+" );
if( chunks.length == 1 ){

    String description = js.getMagicDescriptions();
    if( !js.containsNamedWidget( "Magic" ) ){
    
        JTextComponent jc = js.getShellComponent();
        pager = new Pager( js, jc.getForeground(), jc.getBackground(), jc.getFont() );
        js.addWidget( pager.getBaseWidget(), "Magic" );
        
    }
    pager.setText( description );
    js.moveWidgetToFront( "Magic" );
    pager.requestFocus();    
    return true;
}
else if( chunks.length == 2 ){

    String name = chunks[ 1 ];
    MagicCommand target = null;
    for( MagicCommand mc: js.mcommands ){
    
        if( mc.getName().equals( name ) ){
            target = mc;
            break;        
        }
    
    }
    if( target != null ){
        
        String description = target.getDescription();
        out.write( description.getBytes() );   
    }
    else err.write( "Magic command not found\n".getBytes() );


}
else err.write( "Bad format for %magic\n".getBytes() );
</t>
<t tx="ekr.20070127142814.198">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.widget.Pager;
import javax.swing.text.JTextComponent;
import javax.swing.SwingUtilities;



public class Keystrokes implements MagicCommand{

    JythonShell js;
    Pager pager;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%keystrokes"; }
    public String getDescription(){
    
        return "%keystrokes --&gt; displays JythonShell keystrokes and what they do in a pager.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.equals( "%keystrokes" );
    
    }

    public boolean doMagicCommand( String command ){
    
        Runnable run = new Runnable(){
            public void run(){
                &lt;&lt;command&gt;&gt;
            }
        };
        SwingUtilities.invokeLater( run );
        return true;
    }



}</t>
<t tx="ekr.20070127142814.199">String description = js.getKeystrokeDescriptions();
if( !js.containsNamedWidget( "Keystrokes" ) ){
    
    JTextComponent jtc = js.getShellComponent();
    pager = new Pager( js, jtc.getForeground(), jtc.getBackground(), jtc.getFont() );
    js.addWidget( pager.getBaseWidget(), "Keystrokes" );

}

pager.setText( description );
js.moveWidgetToFront( "Keystrokes" ); 
pager.requestFocus(); 
 

</t>
<t tx="ekr.20070127142814.200">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.widget.Pager;
import javax.swing.text.JTextComponent;
import javax.swing.SwingUtilities;

public class Iuse implements MagicCommand{

    JythonShell js;
    Pager pager;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%iuse"; }
    public String getDescription(){
    
        return "%iuse --&gt; displays JythonShell interactive features in a pager.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.equals( "%iuse" );
    
    }

    public boolean doMagicCommand( String command ){
    
        Runnable run = new Runnable(){
            public void run(){
                &lt;&lt;command&gt;&gt;
            }
        };
        SwingUtilities.invokeLater( run );
        return true;
    }



}</t>
<t tx="ekr.20070127142814.201">String description = js.getInteractiveDescriptions();
if( !js.containsNamedWidget( "Interactive Use" ) ){
    
    JTextComponent jc = js.getShellComponent();
    pager = new Pager( js, jc.getForeground(), jc.getBackground(), jc.getFont() );
    js.addWidget( pager.getBaseWidget(), "Interactive Use" );

}

pager.setText( description );
js.moveWidgetToFront( "Interactive Use" );   
pager.requestFocus();

</t>
<t tx="ekr.20070127142814.202">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import javax.swing.text.*;
import java.nio.*;
import java.io.*;
import org.python.util.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;

public class Url implements MagicCommand{

    JythonShell js;
    ExecutorService executor;
    public Url(){
    
        executor = Executors.newCachedThreadPool();
    
    }
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%url"; }
    public String getDescription(){
    
        return "%url --&gt; loads data from a url into a reference.\n" + 
                "Usage:\n"+
                "%url ref http://python.org\n" + 
                "This will take the data at 'http://python.org' and place it in ref\n\n";
    
    } 

    public boolean handle( String command ){
    
        return (command.startsWith( "%url " ) );
    
    }

    public boolean doMagicCommand( String command ){
    
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    }

    public static class Downloader implements Runnable{
    
        PythonInterpreter pi;
        String reference;
        String url;
        public Downloader( String url, String reference, PythonInterpreter pi ){
        
            this.url = url;
            this.reference = reference;
            this.pi = pi;
            pi.set( reference, "Not finished loading...." );
        
        
        }
    
        public void run(){
    
            try{    
                
                URL location = new URL( url );
                InputStream ins = location.openStream();
                long total = 0l;
                byte[] data = new byte[ 1024 ];
                ArrayList&lt;byte[]&gt; barrays = new ArrayList&lt;byte[]&gt;();
                while( true ){
                
                    int amount = ins.read( data );
                    if( amount == -1 ) break;
                    total += amount;
                    byte[] data2 = new byte[ amount ];
                    System.arraycopy( data, 0, data2, 0, data2.length );
                    barrays.add( data2 );
                
                }
                ByteBuffer bb = ByteBuffer.allocate( (int)total );
                for( byte[] ba: barrays ) bb.put( ba );
                bb.position( 0 );                
                pi.set( reference, bb );
    
            }
            catch( MalformedURLException mue ){
                
                pi.set( reference, mue );
                
                
            }
            catch( IOException io ){
            
                pi.set( reference, io );
            
            }
        
        }
    
    
    
    }

}</t>
<t tx="ekr.20070127142814.203">String[] parts = command.split( "\\s+" );
if( parts.length != 3 ) err.write( "Bad %url form, needs 2 parameters".getBytes() );
else{
    Downloader download = new Downloader( parts[ 2 ], parts[ 1 ], js._pi );
    executor.submit( download );
}</t>
<t tx="ekr.20070127142814.204">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.*;
import java.util.concurrent.*;
import javax.swing.text.*;
import java.io.IOException;
import java.io.OutputStream;
import org.python.core.*;
import org.python.util.*;
import java.awt.*;
import javax.swing.*;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

public class Bg implements MagicCommand{

    JythonShell js;
    Jobs jobs;
    
    
    public void setJythonShell( JythonShell shell ){
    
        jobs = new Jobs( shell );
        js = shell;
        js._pi.set( "jobs", jobs );
    
    }
    
    public String getName(){ return "%bg"; }
    public String getDescription(){
        return "%bg --&gt; this magic command takes a method/function and runs it in a background thread.\n"+
        "For example:\n"+
        "%bg doit()\n"+
        "This executes doit in a thread.  The status of the operation can be seen by looking at the jobs object:\n"+
        "jobs.status()  #--&gt; this prints out the status of the jobs.\n"+
        "Alternatively you can access the status like so:\n"+
        "jobs[ jobnumber ].result\n"+
        "jobnumber is printed out when the method/function is about to execute.\n"+
        "The result will be the return value of the method/function or it will tell you the job isn't finished yet.\n\n";
        
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%bg " );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    }

    &lt;&lt;jobs class&gt;&gt;

    public static class Job implements Runnable{
    
        InteractiveInterpreter pi;
        String job;
        int jn;
        StringInserter si;
        InsertPrompt ip;
        PyDictionary rv;
        String startmessage;
        PyInteger pjn;
        public Job( InteractiveInterpreter pi, String job, int jn , StringInserter si , InsertPrompt ip){
        
            this.pi = pi;
            this.job = job;
            this.jn = jn;
            this.si = si;
            this.ip = ip;
            rv = new PyDictionary();
            startmessage = "Not Finished Executing...";
            pjn = new PyInteger( jn );
            rv.__setitem__( pjn , new PyString( startmessage ) );
        }
        
        public String toString(){
        
            return String.format( "Job number %1$d", jn );
        
        }
        
        public String getResult(){
        
            return rv.__getitem__( pjn ).toString();
        
        }
    
        public void run(){
        
            try{
                
                try{
                    if( si != null ) SwingUtilities.invokeAndWait( si );
                    if( ip != null ) SwingUtilities.invokeAndWait( ip );
                }
                catch( InvocationTargetException ite ){}
                String executejob = String.format( "rv[ %1$d ] = %2$s", jn, job );
                PyDictionary pd = new PyDictionary();
                pd.__setitem__( new PyString( "rv" ), rv );
                Py.exec(Py.compile_flags( executejob, "&lt;string&gt;", "exec", null), pd, pi.getLocals() );
                if( rv.__getitem__( pjn ).toString().equals( startmessage ) )
                    rv.__setitem__( pjn, new PyString( "Finished Execution, no return value" ) );

            }
            catch( Exception x ){
            
                x.printStackTrace();
            
            }
        }
    
    
    
    }

}

</t>
<t tx="ekr.20070127142814.205">String line = command.substring( "%bg".length() );
line= line.trim();
String message = String.format( "\nJob Number %1$d has started...\n", jobs.getNextJobNumber() );
SimpleAttributeSet sas = new SimpleAttributeSet();
StyleConstants.setForeground( sas, Color.GREEN );
StringInserter si = new StringInserter( message, (JTextPane)js.getShellComponent(), sas ,js );
InsertPrompt ip = new InsertPrompt( js, false );
Job job = new Job( js._pi, line, jobs.getNextJobNumber() , si, ip );
jobs.submit( job );
</t>
<t tx="ekr.20070127142814.206">public static class Jobs{

    Map&lt;Integer, Job&gt; jobs;
    ExecutorService es;
    int jobnumber;
    JythonShell js;
    public Jobs( JythonShell js ){
    
        this.js = js;
        jobs = new LinkedHashMap&lt; Integer, Job&gt;();
        es = Executors.newCachedThreadPool(); 
        int jobnumber = 0;
    }

    public int getNextJobNumber(){
    
        return jobnumber;
        
    }
    
    public String toString(){
        
        return "jobs object";
    
    }

    public void status(){
    
        StringBuilder sb = new StringBuilder();
        for( Integer i: jobs.keySet() ){
        
            Job job = jobs.get( i );
            String status = job.getResult();
            sb.append( i ).append( ": " ).append( status );
            if( ! status.endsWith( "\n" ) ) sb.append( "\n" );
        
        
        }
        
        OutputStream out = js.getStandardOut();
        try{
            out.write( sb.toString().getBytes() );
        }
        catch( IOException io ){}
    
    
    }

    public Object __getitem__( int jobnumber ){
    
        return jobs.get( jobnumber );
    
    
    }


    
    public void submit( Job job ){
        
        jobs.put( jobnumber, job );
        es.submit( job );
        jobnumber++;
    
    }


}</t>
<t tx="ekr.20070127142814.207">@language java
package org.leo.shell.magic;
import org.leo.shell.color.ColorConfiguration;
import org.leo.shell.color.JythonColorizer;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.widget.CutCopyPaste;
import org.leo.shell.widget.MessageBorder;
import javax.swing.text.*; 
import org.python.core.*;
import org.python.util.*; 
import java.io.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Pfile implements MagicCommand{

    JythonShell js;
    JTextPane pager;
    JScrollPane jsp;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%pfile"; }
    public String getDescription(){
    
        return "%pfile --&gt; attempts to locate the source file of the passed in object\n" +
               "and displays the contents of the source in the shell.\n"+
               "Usage:\n" +
               "%pfile obj\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%pfile " );
    
    }

    public boolean doMagicCommand( final String command ){
    
        Runnable run = new Runnable(){
            public void run(){
                &lt;&lt;command&gt;&gt;
            }
        };
        SwingUtilities.invokeLater( run );
        return true;
    
    }

    @others

}
</t>
<t tx="ekr.20070127142814.208">final String[] parts = command.split( "\\s+" );
if( parts.length == 2 ){

    String template = "____rv = getfile( %1$s )\n";
    String code = String.format( template, parts[ 1 ] );
    js._pi.exec( getfile );
    js._pi.exec( code );
    PyObject rv = js._pi.get( "____rv" );
    js._pi.exec( "del ____rv" );

    if( rv != Py.None ){
        
        StringBuilder sb = new StringBuilder();
        try{
            String path = rv.toString();
            RandomAccessFile raf = new RandomAccessFile( path, "r" );
            while( true ){
            
                String line = raf.readLine();
                if( line == null ) break;
                sb.append( line ).append( "\n" );
            
            
            }
            raf.close();
        }
        catch( FileNotFoundException fnfe ){}
        catch( IOException io ){}
        if( sb.length() != 0 ){
            
            JythonColorizer jcolorizer = null;
            if( !js.containsNamedWidget( "Pager" ) ){
                pager = new JTextPane();
                ColorConfiguration cc = js.getColorConfiguration();
                pager.setForeground( cc.getForegroundColor() );
                pager.setCaretColor( cc.getForegroundColor() );
                pager.setBackground( cc.getBackgroundColor() );
                jcolorizer = new JythonColorizer( js._pi, pager, js.getColorConfiguration() );
                pager.putClientProperty( "jcolorizer", jcolorizer );
                new CutCopyPaste( pager );
                jsp = new JScrollPane( pager );
                MessageBorder b = new MessageBorder( "Control-q to return to the Shell." );
                jsp.setViewportBorder( b );
                js.addWidget( jsp, "Pager" );
                Action a = new AbstractAction(){
                
                    public void actionPerformed( ActionEvent ae ){
                    
                        js.moveWidgetToFront( "Shell" );
                        js.getShellComponent().requestFocus();
                    
                    }
                
                };
                KeyStroke ks = KeyStroke.getKeyStroke( "control Q" );
                InputMap im = pager.getInputMap();
                ActionMap am = pager.getActionMap();
                im.put( ks, "cq" );
                am.put( "cq", a );
            }
            else{
                
                pager.setText( "" );
                jcolorizer = (JythonColorizer)pager.getClientProperty( "jcolorizer" );;
            
            }
            
            String text = sb.toString();
            pager.setText( text );
            jcolorizer.colorize( text, "", 0, 0, text.length() );
            pager.setCaretPosition( 0 );
            js.moveWidgetToFront( "Pager" );
            pager.requestFocus();
            
        }
        else{
        
        
        }
    }
    
}
</t>
<t tx="ekr.20070127142814.209">static final String getfile = "import types\n"+
"import sys\n"+
"def ismethod(object):\n"+
"    return isinstance(object, types.MethodType)\n"+
"def ismodule(object):\n"+
"    return isinstance(object, types.ModuleType)\n"+
"def isclass(object):\n"+
"    return isinstance(object, types.ClassType) or hasattr(object, '__bases__')\n"+
"def isfunction(object):\n"+
"    return isinstance(object, types.FunctionType)\n"+
"def istraceback(object):\n"+
"    return isinstance(object, types.TracebackType)\n"+
"def isframe(object):\n"+
"    return isinstance(object, types.FrameType)\n"+
"def iscode(object):\n"+
"    return isinstance(object, types.CodeType)\n" +
"def getfile(object):\n"+
"    if ismodule(object):\n"+
"        if hasattr(object, '__file__'):\n"+
"            return object.__file__\n"+
"        raise TypeError('arg is a built-in module')\n"+
"    if isclass(object):\n"+
"        object = sys.modules.get(object.__module__)\n"+
"        if hasattr(object, '__file__'):\n"+
"            return object.__file__\n"+
"        raise TypeError('arg is a built-in class')\n"+
"    if ismethod(object):\n"+
"        object = object.im_func\n"+
"    if isfunction(object):\n"+
"        object = object.func_code\n"+
"    if istraceback(object):\n"+
"        object = object.tb_frame\n"+
"    if isframe(object):\n"+
"        object = object.f_code\n"+
"    if iscode(object):\n"+
"        return object.co_filename\n"+
"    raise TypeError('arg is not a module, class, method, '\n"+
"                    'function, traceback, frame, or code object')\n";</t>
<t tx="ekr.20070127142814.210">@language java
package org.leo.shell.magic;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.python.core.*; 
import java.io.IOException;
import java.io.OutputStream;

public class Pdoc implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%pdoc"; }
    public String getDescription(){
    
        return "%pdoc --&gt; prints out the doc string of the passed in object if one can be found,\n"+
               "otherwise does nothing.\n"+
               "usage:\n"+
               "%pdoc ref  # could be a module, a method, an object, etcc...\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%pdoc " );
    
    }

    public boolean doMagicCommand( String command ){
    
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }

    @others

}</t>
<t tx="ekr.20070127142814.211">String[] pieces = command.split( "\\s+" );
if( pieces.length == 2 ){

    PyObject po = js.getPyObject( pieces[ 1 ].split( "\\." ) );
    if( po != null ){
        
        PyString psdoc = new PyString( "__doc__" );
        if( !__builtin__.hasattr( po, psdoc ) ) return true;
        PyObject doc = __builtin__.getattr( po, psdoc );
        if( doc != null ){

            String dstring = doc.toString();
            if( !dstring.endsWith( "\n" ) ) dstring += "\n";
            out.write( dstring.getBytes() );

        
        }
    
    
    
    }


}</t>
<t tx="ekr.20070127142814.212">@language java
package org.leo.shell.magic;

import org.leo.shell.Documentation;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.LineListener;
import org.leo.shell.util.InsertPrompt;
import javax.swing.SwingUtilities;
import org.python.core.*;
import java.awt.*;
import javax.swing.text.*;
import java.util.*;

public class Pinfo implements MagicCommand,LineListener, Documentation{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addQuietLineListener( this );
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
                
        return "Object Introspection:\n" +
        "Typing the reference name followed by a ? will create\n"+
        "a Object View which gives the user a variety of information\n"+
        "about the Object in question. Example:\n" +
        "a = 'meoooowwww'\n"+
        "a? #Upon Enter, a Panel will appear below showing Object information\n\n";    
        
    }

    public String lineToExecute( String line ){
    
        if( line.endsWith( "?" ) ){
            
            final String vline = line.substring( 0, line.length() -1 );
            Runnable run = new Runnable(){
            
                public void run(){
                    viewObject( vline );
                    js.insertPrompt( false );
                }
            };
            js.setNextPrompt( run );
            return null;
        }
        
        return line;
        
    }
    
    public String getName(){ return "%pinfo"; }
    public String getDescription(){
    
        return "%pinfo --&gt; an alias for the ? object viewer syntax.\n"+
               "Usage:\n"+
               "%pinfo ref\n"+
               "If ref is valid, a widget containing info on the reference will appear.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%pinfo " );
    
    }

    public boolean doMagicCommand( final String command ){
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }

    @others

}</t>
<t tx="ekr.20070127142814.213">final String[] pieces = command.split( "\\s+", 2 );


if( pieces.length == 2 ){

    Runnable run = new Runnable(){
        public void run(){
            viewObject( pieces[ 1 ] );
            InsertPrompt ip = new InsertPrompt( js, false );
            SwingUtilities.invokeLater( ip );
        }
    };
    js.setNextPrompt( run );
}
</t>
<t tx="ekr.20070127142814.214">public void viewObject( String line ){
    
    final JTextComponent _jtp = js.getShellComponent();
    final String[] tokens = line.split( "\\." );
    final PyObject py = js.getPyObject( tokens );
    final Document doc = _jtp.getDocument();
    if( py == null ){
    
        try{

            js.getStandardErr().write( ("No reference recognized for: " + line + "\n").getBytes() );
        }
        catch( final Exception x ){
            //x.printStackTrace();
        
        }
    
    }
    else{
    
        PyList pl = null;
        try{
            pl = (PyList)py.__dir__();
        }
        catch( Exception x ){
        
            pl = new PyList();
        
        }    
        Map&lt;String, Vector&lt;String&gt;&gt; methods = new LinkedHashMap&lt; String, Vector&lt; String &gt; &gt;();
        Vector&lt;String&gt; mname = new Vector&lt;String&gt;();
        methods.put( "Name", mname );
        Map&lt;String, Vector&lt;String&gt;&gt; attributes = new LinkedHashMap&lt; String, Vector&lt; String &gt; &gt;();
        Vector&lt;String&gt; aname = new Vector&lt;String&gt;();
        Vector&lt;String&gt; avalue = new Vector&lt;String&gt;();
        attributes.put( "Name", aname );
        attributes.put( "Value", avalue );
        PyObject ftype = PyType.fromClass( PyFunction.class );
        PyObject mtype = PyType.fromClass( PyMethod.class );
        PyObject rftype = PyType.fromClass( PyReflectedFunction.class );
        PyObject pbtype = PyType.fromClass( PyBuiltinFunction.class );
            for( Object oo: pl ){
                String sr = oo.toString();
                if( sr.equals( "__doc__" ) ) continue;
                PyString ps = new PyString( sr );
                try{
                    if( __builtin__.hasattr( py, ps ) ){
                        PyObject po = py.__findattr__( ps );
                        if( __builtin__.isinstance( po, rftype )|| 
                            __builtin__.isinstance( po, ftype )||
                            __builtin__.isinstance( po, mtype )||
                            __builtin__.isinstance( po, pbtype )) mname.add( ps.toString() );
                        else{
                        
                            aname.add( ps.toString() );
                            PyObject clazz = __builtin__.getattr( po, new PyString( "__class__" ) );
                            PyObject name = __builtin__.getattr( clazz, new PyString( "__name__" ) );
                            avalue.add( name.toString() );
                                    
                        }
                    }
                }
                catch( Exception x ){}
            }


        Object docs = null;
        PyString pydoc = new PyString( "__doc__" );
        try{
            if( __builtin__.hasattr( py, pydoc ) )
                docs = __builtin__.getattr( py, pydoc );
        }
        catch( Exception x ){}
            
        try{
        
            final org.leo.shell.widget.ObjectViewer ov = new org.leo.shell.widget.ObjectViewer();
            String oname = js.getObjectName( py );
            try{
                
                PyObject clazz = __builtin__.getattr( py, new PyString( "__class__" ) );
                Object o = __builtin__.getattr( clazz , new PyString( "__name__" ) ); 
                oname = o.toString();
            
            }
            catch( Exception x ){}
            ov.setClassName( oname );
            if( docs != null )
                ov.setDocString( docs.toString() );
            else
                ov.setDocString( "None" );
            
            ov.setJythonAttributes( attributes);
            ov.setJavaMethods( methods );

            
            try{
                PyObject clazz = __builtin__.getattr( py, new PyString( "__class__" ) );
                PyObject __bases__ = __builtin__.getattr( clazz, new PyString( "__bases__" ) );
                PyTuple ptbases = (PyTuple)__bases__;
                Vector&lt;String&gt; bases = new Vector&lt;String&gt;();
                for( int i = 0; i &lt; ptbases.size(); i++  ){
                    PyObject c = ptbases.__getitem__( i );
                    Object name = __builtin__.getattr( c, new PyString( "__name__" ) );
                    bases.add( name.toString() );
                }
                ov.setBases( bases );
            }
            catch( Exception x ){}
            final Dimension ovps = ov.getPreferredSize();
            final Rectangle psjtp = _jtp.getVisibleRect();
            ovps.width = psjtp.width;
            ov.setMaximumSize( ovps );
            final SimpleAttributeSet sas = new SimpleAttributeSet();
            StyleConstants.setComponent( sas, ov );
            doc.insertString( _jtp.getCaretPosition(), "\n" , sas );
            return;
            
        
        }
        catch( final Exception x ){ 
            //x.printStackTrace();
        
        }
    
    }


}

</t>
<t tx="ekr.20070127142814.215">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;

public class P implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%p"; }
    public String getDescription(){
    
        return "%p --&gt; a shortcut for 'print'\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%p " );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }


}</t>
<t tx="ekr.20070127142814.216">String newcommand = command.replaceFirst( "\\%p", "print" );
js._pi.exec( newcommand );
</t>
<t tx="ekr.20070127142814.217">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.LineListener;
import javax.swing.SwingUtilities;
import org.python.core.PyInteger;
import org.python.core.PyString;

public class R implements MagicCommand, LineListener{
    
    String replacement;
    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addHistoryLineListener( this );
    
    }
    
    public String lineToExecute( String line ){
    
        if( replacement != null ){
            line = replacement;
            replacement = null;
        }
        return line;
        
    }
    
    public String getName(){ return "%r"; }
    public String getDescription(){
    
        return "%r --&gt; repeat last input.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%r" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }


}</t>
<t tx="ekr.20070127142814.218">if( js.history.size() != 0 ){
    Object o = js.history.__getitem__( -1 );
    final String s = o.toString();
    if( s.startsWith( "%" ) )js.magicCommand( s );
    else js._pi.push( s );
    replacement = s;
    
}
</t>
<t tx="ekr.20070127142814.219">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.leo.shell.widget.CutCopyPaste; 
import java.util.*;
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;
import javax.swing.text.*;
import javax.swing.tree.TreePath;

public class Env implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%env"; }
    public String getDescription(){
    
        return "%env --&gt; List environment variables.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%env" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.220">final Map&lt;String,String&gt; env = System.getenv();
Vector&lt;String&gt; keys = new Vector&lt;String&gt;( env.keySet() );

JTree jtree = new JTree( keys );
JScrollPane jsp = new JScrollPane( jtree );
final JTextPane jtp = new JTextPane();
new CutCopyPaste( jtp );
JScrollPane jsp2 = new JScrollPane( jtp );
JPanel container = new JPanel( new GridLayout( 1,2 ) );
container.add( jsp ); container.add( jsp2 );
TreeSelectionListener tsl = new TreeSelectionListener(){

    public void valueChanged(TreeSelectionEvent e){
    
        TreePath tp = e.getPath();
        Object o = tp.getLastPathComponent();
        String value = env.get( o.toString() );
        jtp.setText( value );
    
    }

};
jtree.addTreeSelectionListener( tsl );
final SimpleAttributeSet sas = new SimpleAttributeSet();
StyleConstants.setComponent( sas, container );
final JTextComponent jtc = js.getShellComponent();
Graphics g = jtc.getGraphics();
FontMetrics fm = g.getFontMetrics();
int height = fm.getHeight();
g.dispose();
Dimension psize = container.getPreferredSize();
psize.height = height * 10;
container.setPreferredSize( psize );
final Document doc = jtc.getDocument();
Runnable run = new Runnable(){

    public void run(){
        try{

            doc.insertString( jtc.getCaretPosition(), "\n", sas );

        }
        catch( BadLocationException ble ){}
    }
};
SwingUtilities.invokeLater( run );




</t>
<t tx="ekr.20070127142814.221">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.leo.shell.widget.CutCopyPaste; 
import java.util.*;
import java.io.*;
import javax.swing.text.*;
import javax.swing.*;

public class Save implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%save"; }
    public String getDescription(){
    
        return "%save filename n1:n2 n3:n4 ... n5 .. n6 ... This function uses the same syntax as %macro for line extraction, but instead of creating a macro it saves the resulting string to the filename you specify. It adds a  .py  extension to the file if you don t do so yourself, and it asks for confirmation before overwriting existing files.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%save " );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.222">List&lt;String&gt; history = js.history;
String[] chunks = command.split( "\\s+" , 3 );
if( chunks.length != 3 ){
    String message = "%save requires form: %save macroname n1:n2 n3:n4 ... n5 n6\n";
    err.write( message.getBytes() );
    return false;

}

String fname = chunks[ 1 ];
java.util.List&lt;String&gt; savelines = js.processHistoryString( chunks[ 2 ] );

if( savelines.size() != 0 ){

    JTextComponent jtc = js.getShellComponent();
    Document doc = jtc.getDocument();

    try{
        File cwd = js.getCurrentWorkingDirectory();
        if( !fname.endsWith( ".py" ) ) fname += ".py";
        File filespot = new File( cwd, fname );
        if( filespot.exists() ){
        
           String message = String.format( "%1$s exists, do you wish to Overwrite?", filespot.getName() );
           int result =  JOptionPane.showConfirmDialog( jtc, message, "Overwrite?", JOptionPane.YES_NO_OPTION );
           if( result == JOptionPane.NO_OPTION ){
           
                return true;
           
           }
        
        }
        FileOutputStream fos = new FileOutputStream( filespot );
        for( String s: savelines ){
            
            fos.write( s.getBytes() );
            if( !s.endsWith( "\n" ) ) fos.write( "\n".getBytes() );
        }
        fos.close();
        String message = String.format( "%1$s saved\n", filespot );
        out.write( message.getBytes() );
            

    }
    catch( IOException io ){ err.write( io.toString().getBytes() ); };
    

}</t>
<t tx="ekr.20070127142814.223">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.util.*;
import java.io.*;
import org.python.core.*;


public class Who implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%who"; }
    public String getDescription(){
    
        return "%who --&gt; this command prints out a list of identifiers that have been defined interactively\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%who" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.224">

List&lt;String&gt; who = js.getWho();
Collections.sort( who );
StringBuilder sb = new StringBuilder();
Iterator&lt;String&gt; it = who.iterator();
while( it.hasNext() ){

    try{
        String s = it.next();
        Object o = js._pi.get( s );
        if( o == null || o == Py.None ) it.remove();
        else sb.append( s ).append( " " );
    }
    catch( Exception x ){
    
        it.remove();
    
    }

}
sb.append( "\n" );
OutputStream os = js.getStandardOut();
try{
    os.write( sb.toString().getBytes() );
}
catch( IOException io ){}
</t>
<t tx="ekr.20070127142814.225">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.awt.Dimension;
import java.util.*;
import javax.swing.text.*;
import javax.swing.table.*;
import javax.swing.*;
import org.python.core.*;


public class Whos implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%whos"; }
    public String getDescription(){
    
        return "%whos --&gt; this command prints out a table of identifiers that have been defined interactively\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%whos" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.226">

List&lt;String&gt; who = js.getWho();
Collections.sort( who );
final JTextComponent jtc = js.getShellComponent();
final Document doc = jtc.getDocument();
Vector&lt;String&gt; name = new Vector&lt;String&gt;();
Vector&lt;String&gt; type = new Vector&lt;String&gt;();
Vector&lt;String&gt; repr = new Vector&lt;String&gt;();
Iterator&lt;String&gt; names = who.iterator();
while( names.hasNext() ){

    String name2 = names.next();
    try{
        PyObject po = js._pi.get( name2 );
        if( po == null || po == Py.None ) names.remove();
        else{
        
            Object o = __builtin__.getattr( __builtin__.type( po ), new PyString( "__name__" ) );
            Object o2 =  __builtin__.repr( po );
            name.add( name2 ); type.add( o.toString() ); repr.add( o2.toString() );
        
        
        } 

    }
    catch( Exception x ){}

}
DefaultTableModel dtm = new DefaultTableModel();
dtm.addColumn( "Variable", name );
dtm.addColumn( "Type", type );
dtm.addColumn( "Data/Info", repr );
JTable jt = new JTable( dtm );
JScrollPane jsp = new JScrollPane( jt );
int height = jt.getRowHeight() * 5;
Dimension d = jsp.getPreferredSize();
d.height = height;
jsp.setPreferredSize( d );
final SimpleAttributeSet sas = new SimpleAttributeSet();
StyleConstants.setComponent( sas, jsp );

Runnable run = new Runnable(){

    public void run(){
        try{
            doc.insertString( jtc.getCaretPosition(), "\n", sas );
        }
        catch(BadLocationException ble ){}
    }
};
SwingUtilities.invokeLater( run );</t>
<t tx="ekr.20070127142814.227">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.leo.shell.util.InsertPrompt;
import java.util.*;
import org.python.core.*;


public class Who_ls implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%who_ls"; }
    public String getDescription(){
    
        return "%who_ls: Return a sorted list of all interactive variables. If arguments are given, only variables of types matching these arguments are returned.\n"+
        "Usage examples:\n"+
        "%who_ls\n"+
        "%who_ls str int  #this prints out variables whose type is str and int\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%who_ls" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }


}</t>
<t tx="ekr.20070127142814.228">String[] pieces = command.split( "\\s+" );
String[] stypes = new String[ pieces.length -1 ];
System.arraycopy( pieces, 1, stypes, 0, stypes.length );
java.util.List&lt;String&gt; types = Arrays.asList( stypes );

List&lt;String&gt; who = js.getWho();
Collections.sort( who );
PyList rv = new PyList();
Iterator&lt;String&gt; it = who.iterator();
while( it.hasNext() ){

    try{
        String s = it.next();
        PyObject o = js._pi.get( s );
        if( types.size() != 0 &amp;&amp; o != null ){
        
            Object o2 = __builtin__.getattr( __builtin__.type( o ), new PyString( "__name__" ) );
            String s2 = o2.toString();
            if( types.contains( s2 ) ) rv.add( o );
        
        
        }
        else if ( o != null ) rv.add( o );
        if( o == null ) it.remove();
        
    }
    catch( Exception x ){
    
        it.remove();
    
    }

}
rv.sort();
PyObject repr = __builtin__.repr( rv );
String execute = repr.toString();
js._pi.push( execute );


</t>
<t tx="ekr.20070127142814.229">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import org.leo.shell.MagicCommand; 
import java.io.IOException;
import java.io.OutputStream;


public class Autocall implements MagicCommand,Documentation{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "Autocalling:\n"+
        "Autocalling will provide parenthesis when calling a function. So for example:"+
        "dir a\n"+
        "becomes:\n"+
        "dir( a )\n"+
        "This feature is toggled on and off with the %autocall magic command\n";    
    
    }
    
    public String getName(){ return "%autocall"; }
    public String getDescription(){
    
        return "%autocall --&gt; toggles autocalling of and on\n"+
                "Autocalling is the ability to do something like this:\n"+
                "dir a\n"+
                "Instead of dir( a ).\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%autocall" );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.230">boolean autocall = js.getAutocall();
autocall = autocall? false: true;
js.setAutocall( autocall );
String message = String.format( "Automatic calling is: %1$s\n", autocall? "On": "Off" );
out.write( message.getBytes() );</t>
<t tx="ekr.20070127142814.231">@language java
package org.leo.shell.magic;

import org.leo.shell.Documentation;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.IOException;
import java.io.OutputStream;


public class Autoindent implements MagicCommand, Documentation{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "Autoindenting:\n"+
        "Autoindenting will indent your next line if the user types "+
        "enter and the line terminates with a ':'.\n"+
        "Toggled on and off with the %autoindent magic command\n";
        
    }
    
    public String getName(){ return "%autoindent"; }
    public String getDescription(){
    
        return "%autoindent --&gt; toggles autoindenting of and on\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%autoindent" );
    
    }

    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }


}
</t>
<t tx="ekr.20070127142814.232">boolean autoindent = js.getAutoindent();
autoindent = autoindent? false: true;
js.setAutoindent( autoindent );
String message = String.format( "Automatic indentation is: %1$s\n", autoindent? "On": "Off" );
out.write( message.getBytes() );</t>
<t tx="ekr.20070127142814.233">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.*;
import java.io.*;
import java.util.List;
import org.python.core.PyList;

public class Sc implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%sc"; }
    public String getDescription(){
    
        return "Shell capture - execute a shell command and capture its output. %sc [options] varname=command\n will run the given command and will then update the user s interactive namespace with a variable called varname, containing the value of the call. Your command can contain shell wildcards, pipes, etc.\nThe  =  sign in the syntax is mandatory, and the variable name you supply must follow Python s standard conventions for valid names.\nOptions:\n -l: list output. Split the output on newlines into a list before assigning it to the given variable. By default the output is stored as a single string.\n -v: verbose. Print the contents of the variable.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%sc" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }
    
    public boolean badFormat(){
    
        OutputStream os = js.getStandardErr();
        try{
        
            os.write( "Bad format, no command executed\n".getBytes() );
        
        }
        catch( IOException io ){}
        return true;    
    
    }


}</t>
<t tx="ekr.20070127142814.234">String[] pieces = command.split( "\\s+", 2 );
if( pieces.length == 2 ){

    String piece2 = pieces[ 1 ];
    boolean list = false;
    boolean verbose = false;
    String[] testpiece = piece2.split( "\\s+" );
    if( testpiece.length &gt; 2 ){
        
        if( testpiece[ 0 ].equals( "-l" ) || testpiece[ 1 ].equals( "-l" ) ){
        
            list = true;
            piece2 = piece2.replaceFirst( "\\-l", "" );
        }
        if( testpiece[ 0 ].equals( "-v" ) || testpiece[ 1 ].equals( "-v" ) ){
        
            verbose = true;
            piece2 = piece2.replaceFirst( "\\-v", "" );
        }
    
    }
    final String[] pieces2 = piece2.split( "\\s*=\\s*", 2 );
    if( pieces2.length == 2 ){
        
        pieces2[ 1 ] = js.checkForJythonReference( pieces2[ 1 ] );
        List&lt;String&gt; slpieces = CommandLineParser.parseCommandLine( pieces2[ 1 ] );
        String[] lpieces = slpieces.toArray( new String[]{} );
        lpieces[ 0 ] = CommandFinder.findCommand( lpieces[ 0 ], js.getCurrentWorkingDirectory() );
        final ProcessBuilder pb = new ProcessBuilder( lpieces );
        pb.redirectErrorStream( true );
        pb.directory( js.getCurrentWorkingDirectory() );
        final StringBuilder sb = new StringBuilder();
        final boolean fverbose = verbose; final boolean flist = list;
        Runnable run = new Runnable(){
        
            public void run(){
                try{
                    Process process = pb.start();
                    InputStream is = process.getInputStream();
                    BufferedReader br = new BufferedReader( new InputStreamReader( is ) );
                    String data = null;
                    while( ( data = br.readLine() ) != null ) sb.append( data ).append( "\n" );
            
                } 
                catch( IOException io ){}
                Object stash;
                if( flist ){
            
            
                    PyList pl = new PyList();
                    for( String s: sb.toString().split( "\n" ) )
                        pl.add( s ); 
                    stash = pl;
        
                }
                else stash = sb.toString();

                js._pi.set( pieces2[ 0 ].trim(), stash );
                if( fverbose ){
        
                    String execline = String.format( "print %1$s", pieces2[ 0 ] );
                    js.addLineToExecute( execline );
                    js.execute1( js );
        
        
                }
                InsertPrompt ip = new InsertPrompt( js, false );
                js.execute1( ip );
            }
        };
        js.execute2( run );
        
    }
    else return badFormat();

}
else return badFormat();</t>
<t tx="ekr.20070127142814.235">@language java
package org.leo.shell.magic;

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.*;
import java.util.regex.Pattern;
import java.io.*;
import java.util.concurrent.*;
import java.util.List;
import org.python.core.PyList;

public class Sx implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%sx"; }
    public String getDescription(){ 
    
        return "%sx --&gt; will run the given command using commands.getoutput(), and return the result formatted as a list (split on  ). Since the output is returned , it will be stored in ipython s regular output cache Out[N] and in the   N  automatic variables.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%sx" );
    
    }

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }


}</t>
<t tx="ekr.20070127142814.236">String nwcommand = command.replaceFirst( Pattern.quote( "%sx" ), "" ).trim();
nwcommand = js.checkForJythonReference( nwcommand );
List&lt;String&gt; cmdline = CommandLineParser.parseCommandLine( nwcommand );
String[] pieces = cmdline.toArray( new String[]{} );
pieces[ 0 ] = CommandFinder.findCommand( pieces[ 0 ], js.getCurrentWorkingDirectory() );
final ProcessBuilder pb = new ProcessBuilder( pieces );
pb.redirectErrorStream( true );
pb.directory( js.getCurrentWorkingDirectory() );
final PyList output = new PyList();
Runnable run = new Runnable(){

    public void run(){
        try{
            Process process = pb.start();
            InputStream is = process.getInputStream();
            BufferedReader br = new BufferedReader( new InputStreamReader( is ) );
            String data = null;
            while( ( data = br.readLine() ) != null ) output.add( data );
            br.close();

        }
        catch( IOException io ){}

        js._pi.set( "_", output );
        js._pi.push( "_" );

    }
};
FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;( run, "Ok" );
js.execute2( ft );
try{
    ft.get();
}
catch( ExecutionException ee ){}
catch( InterruptedException ie ){}</t>
<t tx="ekr.20070127142814.237">@language java
package org.leo.shell.magic;


import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.actions.*;
import org.leo.shell.util.InsertPrompt;
import org.leo.shell.color.JythonColorizer;
import org.leo.shell.magic.editor.*;
import org.leo.shell.widget.MessageBorder;
import org.python.core.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutionException;
import javax.swing.*;
//import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.*;

public class Ed implements MagicCommand{

    JythonShell js;
    LinkedList&lt;String&gt; previous;
    
    public Ed(){
    
        previous = new LinkedList&lt;String&gt;();
    
    }
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public static class JTextPane2 extends JTextPane{
    
        JythonColorizer jc;
        public JTextPane2(){
        
            getDocument().addDocumentListener( new DocumentListener2() );
        
        }

        public void setJythonColorizer( JythonColorizer jc ){
        
            this.jc = jc;
        
        }
        
        &lt;&lt;document listener2&gt;&gt;
    }
    
    &lt;&lt;return&gt;&gt;
    
    public String getName(){ return "%ed/%edit"; }
    public String getDescription(){ 
    
	    &lt;&lt;description&gt;&gt;
    
    } 

    public boolean handle( String command ){
        
        command = command.trim();
        return command.startsWith( "%ed" ) || command.startsWith( "%edit" );
    
    }

    public boolean doMagicCommand( final String command ){
    
        Runnable run = new Runnable(){
            public void run(){
                &lt;&lt;command&gt;&gt;
            }
        };
        SwingUtilities.invokeLater( run );
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.238">public class DocumentListener2 implements DocumentListener, Runnable{
            
    boolean colortoend;
            
    public void insertUpdate( DocumentEvent de ){
            
        AbstractDocument doc = (AbstractDocument)de.getDocument();
        String what = "";
        try{
                
            what = doc.getText( de.getOffset(), de.getLength() );
                
        }
        catch( BadLocationException ble ){}
        if( what.equals( "'" ) || what.equals( "\"" ) || what.equals( "#" ) ){
                
            Element e = doc.getParagraphElement( de.getOffset() );
            Element end = doc.getParagraphElement( de.getLength() );
            if( e!=end) colortoend = true;
                
        }
        SwingUtilities.invokeLater( this );
        if( what.equals( "\n" ) ){
                
            Element e = doc.getParagraphElement( de.getOffset() );
            try{
                    
                String line = doc.getText( e.getStartOffset(), ( e.getEndOffset() - 1) - e.getStartOffset() );
                Indenter indent = new Indenter( doc, e.getEndOffset(), line );
                SwingUtilities.invokeLater( indent );
                    
            }
            catch( BadLocationException ble ){}
                
                
        }
            
    }
    public void removeUpdate( DocumentEvent de ){ 
            
        Document doc = de.getDocument();
        try{
            String text = doc.getText( de.getOffset(), de.getLength() );
            if( text.equals( "\"" ) || text.equals( "'" ) || text.equals( "#" ) ) colortoend = true;
        }
        catch( BadLocationException ble ){}
        SwingUtilities.invokeLater( this );
            
    }
            
    public void changedUpdate( DocumentEvent de ){}
            
    public void run(){
                
        boolean colortoend = this.colortoend;
        this.colortoend = false;
        Document doc = getDocument();
        int start = JTextPane2.this.jc.startOfLine();
        int end = JTextPane2.this.jc.endOfLine();
        if( colortoend ){
            end = doc.getLength();   
        }
        String line = "";
        try{
            line = doc.getText( start, end - start );
        }
        catch( BadLocationException ble ){}
        JTextPane2.this.jc.colorize( line, "", getCaretPosition(),  start, end );
        
    }
            

        
}
</t>
<t tx="ekr.20070127142814.239">public static class Return extends AbstractAction{
    
    JythonShell js;
    JTextPane jtp; 
    boolean execute;
    LinkedList&lt;String&gt; previous;
        
    public Return( JythonShell js, JTextPane jtp, LinkedList&lt;String&gt; previous ){
        
        this.js = js;
        this.jtp = jtp;
        execute = true;
        this.previous = previous;
    
    }
    
    public void setExecute( boolean value ){
        
        execute = value;
        
    }
        
    public void actionPerformed( ActionEvent ae ){
        
        //Container con = parent.getParent();
        //con.remove( parent );
        //JComponent widget = js.getWidget();
        //con.add( widget );
        //con.validate();
        //widget.repaint();
        js.moveWidgetToFront( "Shell" );
        String text = jtp.getText();
        previous.add( text );
        String[] lines = text.split( "\n" );
        java.util.List&lt;String&gt; script = Arrays.asList( lines );
        final FutureTask&lt;Boolean&gt; ft;
        if( execute )
            ft = js.processScript( script );
        else ft = null;
            
        final JTextComponent jtc = js.getShellComponent();
        jtc.requestFocus();
        String mungedline = text.replace( "\\", "\\\\" );
        mungedline = mungedline.replace( "\n", "\\n" );
        final String mungedline2 = mungedline.replace( "'", "\\'" );
        Runnable run = new Runnable(){
            
            public void run(){

                Runnable run2 = new Runnable(){
                    
                    public void run(){
                        try{
                            ft.get();
                        }catch( InterruptedException ie ){
                            
                            return;//something bad has happened, let us not do anything more destructive
                        }
                        catch( ExecutionException ee ){
                            
                            return;//same as above...
                            
                        }
                        Document doc = jtc.getDocument();
                        try{
                            int cp = jtc.getCaretPosition();
                            doc.insertString( cp, "\n", null );
                            jtc.setCaretPosition( cp + 1 );
                        
                        }
                        catch( BadLocationException ble ){ ble.printStackTrace();}
                        js.addLineToExecute( "'" + mungedline2 + "'" );
                        js.execute1( js );
                        InsertPrompt ip = new InsertPrompt( js, false );
                        js.execute1( ip );
                    }
                };
                SwingUtilities.invokeLater( run2 );
            }
            
        };
        js.execute2( run );
    }
        
}</t>
<t tx="ekr.20070127142814.240">return "%ed: Alias to %edit.\n"+
"%edit: Bring up an editor and execute the resulting code.\n"+
"Usage: %edit [options] [args]\n"+
"%edit runs JythonShell's editor.\n"+

"This command allows you to conveniently edit multi-line code right in your JythonShell session.\n"+ 
"If called without arguments, %edit opens up an empty editor with a temporary file and will execute the contents of this file when you close it (don t forget to save it!).\n"+
"Options:\n"+
"-p: this will call the editor with the same data as the previous time it was used, regardless of how long ago (in your current session) it was.\n"+
"-x: do not execute the edited code immediately upon exit. This is mainly useful if you are editing programs which need to be called with command line arguments, which you can then do using %run.\n"+
"Arguments:\n"+
"If arguments are given, the following possibilites exist:\n"+
"- The arguments are numbers or pairs of colon-separated numbers (like 1 4:8 9). These are interpreted as lines of previous input to be loaded into the editor. The syntax is the same of the %macro command.\n"+
"- If the argument doesn t start with a number, it is evaluated as a variable and its contents loaded into the editor. You can thus edit any string which contains python code (including the result of previous edits).\n\n"; 
</t>
<t tx="ekr.20070127142814.241">boolean execute = true;
boolean setprevious = false;

String[] pieces = command.split( "\\s+" );
int i = 0;
if( pieces.length &gt; 1 ){

    String test1 = pieces[ 1 ];
    if( test1.equals( "-x" ) ){ execute = false;i++;}
    if( test1.equals( "-p" ) ){ setprevious = true;i++;}
    
    if( pieces.length &gt;= 3 ){
    
        String test2 = pieces[ 2 ];
        if( test2.equals( "-x" ) ){ execute = false;i++;}
        if( test2.equals( "-p" ) ){ setprevious = true;i++;}    
    
    }


}

java.util.List&lt;String&gt; hlist = null;
if( pieces.length &gt; i + 1 &amp;&amp; Character.isDigit( pieces[ i + 1 ].charAt( 0 ) ) ){

    StringBuilder sb = new StringBuilder();
    for( ; i &lt; pieces.length; i++ ) sb.append( pieces[ i ] ).append( " " );
    if( sb.length() &gt; 0 )
        hlist = js.processHistoryString( sb.toString() );

}
else if( pieces.length &gt; i + 1 ){

    PyObject po = js.getPyObject( pieces[ i +1 ].split( "\\." ) );
    if( po instanceof PyString ){
    
        String s = po.toString();
        String[] ppieces = s.split( "\n" );
        hlist = Arrays.asList( ppieces );
    
    
    }
}


try{

    JTextPane2 jtp = null;
    JythonColorizer jcolor = null;
    if( js.containsNamedWidget( "Editor" ) ){
        JScrollPane jsp = (JScrollPane)js.getWidgetByName( "Editor");
        jtp = (JTextPane2)jsp.getViewport().getView();
        jtp.setText( "" );
        jcolor = (JythonColorizer)jtp.getClientProperty( "jcolorizer" );
        js.moveWidgetToFront( "Editor" );
    }
    else{
        jtp = new JTextPane2();
        jtp.addAncestorListener( new FocusRequestor() );
        JTextComponent jtc = js.getShellComponent();
        jtp.setForeground( jtc.getForeground() );
        jtp.setBackground( jtc.getBackground() );
        jtp.setCaretColor( jtc.getCaretColor() );
        jtp.setFont( jtc.getFont() );
        jcolor = new JythonColorizer( js._pi, jtp, js.getColorConfiguration() );
        jtp.putClientProperty( "jcolorizer", jcolor );
        jtp.setJythonColorizer( jcolor );
        JScrollPane jsp = new JScrollPane( jtp );
        jsp.setName( "Editor" );
        String message = "Type Control-h to view Editor keystrokes.";
        jsp.setViewportBorder( new MessageBorder( message ) );
        JComponent jc = js.getWidget();
    
        KeyStroke tab = KeyStroke.getKeyStroke( KeyEvent.VK_TAB, 0 );
        registerKeyStrokeAction( jtp, tab, "tab", new TabCompletion( jtp, jcolor ) ); 
        Return ret = new Return( js, jtp, previous );
        ret.setExecute( execute );
        KeyStroke cq = KeyStroke.getKeyStroke( "control Q" );
        registerKeyStrokeAction( jtp, cq, "cq", ret );
        KeyStroke eol = KeyStroke.getKeyStroke( "control K" );
        registerKeyStrokeAction( jtp, eol, "ck", new DeleteToEndOfLine( jtp ) );
        KeyStroke ca = KeyStroke.getKeyStroke( "control A" );
        registerKeyStrokeAction( jtp, ca, "ca", new org.leo.shell.magic.editor.StartOfLine() );
        KeyStroke ce = KeyStroke.getKeyStroke( "control E" );
        registerKeyStrokeAction( jtp, ce, "ce", new org.leo.shell.magic.editor.EndOfLine() );
        KeyStroke cc = KeyStroke.getKeyStroke( "control C" );
        registerKeyStrokeAction( jtp, cc, "cc", TransferHandler.getCopyAction() );
        KeyStroke cx = KeyStroke.getKeyStroke( "control X" );
        registerKeyStrokeAction( jtp, cx, "cx", TransferHandler.getCutAction() );
        KeyStroke cp = KeyStroke.getKeyStroke( "control P" );
        registerKeyStrokeAction( jtp, cp, "cp", TransferHandler.getPasteAction() );
        Action flip = new AbstractAction(){
            public void actionPerformed( ActionEvent ae ){ js.moveWidgetToFront( "Help" );}
        };
        KeyStroke ch = KeyStroke.getKeyStroke( "control H" );
        registerKeyStrokeAction( jtp, ch, "ch", flip );
        js.addWidget( jsp, "Editor" );
        js.moveWidgetToFront( "Editor" );
    }
    
    if( setprevious &amp;&amp; previous.size() &gt; 0 ){
        String last = previous.getLast();
        jtp.setText( last );
        jcolor.colorize( last, "", 0, 0, last.length() );
    }
    else if ( hlist != null ){
    
        StringBuilder sb = new StringBuilder();
        for( String s: hlist ) sb.append( s ).append( "\n" );
        String text = sb.toString();
        jtp.setText( text );
        jcolor.colorize( text, "", 0, 0, text.length() );
  
    }

    if( !js.containsNamedWidget( "Help" ) ){
        Action flip2 = new AbstractAction(){
            public void actionPerformed( ActionEvent ae ){ js.moveWidgetToFront( "Editor" );}
        };
        Help help = new Help( flip2, jtp );
        JComponent hwidget = help.getWidget();
        hwidget.setName( "Help" );
        js.addWidget( hwidget, "Help" );
    }
    
    jtp.requestFocus();
    
}
catch( Exception x ){
    x.printStackTrace();

}
</t>
<t tx="ekr.20070127142814.242">public static class Indenter implements Runnable{

    Document doc;
    int spot;
    String previous;
    public Indenter( Document doc, int spot, String previous ){
    
        this.doc = doc;
        this.spot = spot;
        this.previous = previous;
        
    }
    
    public void run(){
    
        boolean addtab = previous.trim().endsWith( ":" );
        char[] line = previous.toCharArray();
        final StringBuilder sb = new StringBuilder();
        for( final char c: line ){
                
            if( c != '\n' &amp;&amp; Character.isWhitespace( c ) ) sb.append( c );
            else break;
                
        }

                
        if( addtab ) sb.append( "    " );
        String addwhitespace = sb.toString();
        try{
            
            doc.insertString( spot, addwhitespace, null );
        
        }
        catch( BadLocationException ble ){}
        
    }
}</t>
<t tx="ekr.20070127142814.243">public void registerKeyStrokeAction( JTextComponent jtc, KeyStroke ks, Object object, Action action ){

    InputMap im = jtc.getInputMap();
    ActionMap am = jtc.getActionMap();
    im.put( ks, object );
    am.put( object, action );

}</t>
<t tx="ekr.20070127142814.244">public static class Help{

    JTextPane help;
    JScrollPane jsp;
    
    public Help( Action end, JTextComponent reference ){
    
        help = new JTextPane();
        help.setForeground( reference.getForeground() );
        help.setBackground( reference.getBackground() );
        help.setFont( reference.getFont() );
        help.addAncestorListener( new FocusRequestor() );
        help.setEditable( false );
        KeyStroke cq = KeyStroke.getKeyStroke( "control Q" );
        InputMap im = help.getInputMap();
        ActionMap am = help.getActionMap();
        im.put( cq, "cq" );
        am.put( "cq", end );
        jsp = new JScrollPane( help );
        jsp.setViewportBorder( new MessageBorder( "Control-q to return to the Editor." ) );
        addHelpText();
    }

    public JComponent getWidget(){ return jsp; }

    private void addHelpText(){
        
        StringBuilder sb = new StringBuilder();
        String[] keystrokes = new String[]{
            "Control-a --&gt; move position to beginning of line.",
            "Control-e --&gt; move position to end of line.",
            "Control-k --&gt; remove text from position to end of line.",
            "Control-c --&gt; copies selection to clipboard.",
            "Control-x --&gt; cuts selection to clipboard.",
            "Control-p --&gt; pastes clipboard to editor.",
            "Control-q --&gt; quit editor, return to shell.",
            "Tab --&gt; either completes the current word as a python keyword or adds 4 spaces."
        };
        for( String s: keystrokes ) sb.append( s ).append( "\n" );
        help.setText( sb.toString() );
        help.setCaretPosition( 0 );
        
    }



}</t>
<t tx="ekr.20070127142814.245">public static class FocusRequestor implements AncestorListener{

    public void ancestorRemoved(AncestorEvent event){}
    public void 	ancestorMoved(AncestorEvent event){}
    public void ancestorAdded( AncestorEvent ae ){
        
        JComponent component = ae.getComponent();
        component.requestFocus();

    }

}</t>
<t tx="ekr.20070127142814.246">@
"def ismethod(object):\n"+
"    return isinstance(object, types.MethodType)\n"+
"def ismodule(object):\n"+
"    return isinstance(object, types.ModuleType)\n"+
"def isclass(object):\n"+
"    return isinstance(object, types.ClassType) or hasattr(object, '__bases__')\n"+
"def isfunction(object):\n"+
"    return isinstance(object, types.FunctionType)\n"+
"def istraceback(object):\n"+
"    return isinstance(object, types.TracebackType)\n"+
"def isframe(object):\n"+
"    return isinstance(object, types.FrameType)\n"+
"def iscode(object):\n"+
"    return isinstance(object, types.CodeType)\n" +
def findsource(object):
    file = getsourcefile(object) or getfile(object)
    lines = linecache.getlines(file)
    if not lines:
        raise IOError('could not get source code')

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^\s*class\s*' + name + r'\b')
        for i in range(len(lines)):
            if pat.match(lines[i]): return lines, i
        else:
            raise IOError('could not find class definition')

    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise IOError('could not find function definition')
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^(\s*def\s)|(.*\slambda(:|\s))|^(\s*@)')
        while lnum &gt; 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise IOError('could not find code object')</t>
<t tx="ekr.20070127142814.247">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.leo.shell.util.StringInserter;
import java.util.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.text.*;
import javax.swing.*;
import org.python.util.PythonInterpreter;
import java.io.IOException;
import java.io.OutputStream;


public class Reset extends KeyAdapter implements MagicCommand{

    JythonShell js;
    boolean listening;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        listening = false;
    
    }
    
    public String getName(){ return "%reset"; }
    public String getDescription(){
    
        return "%reset: Resets the namespace by removing all names defined by the user.\n"+
               "Input/Output history are left around in case you need them.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%reset" );
    
    }
    public void keyTyped( KeyEvent ke ){ ke.consume(); }
    public void keyReleased( KeyEvent ke ){ ke.consume(); }
    public void keyPressed( KeyEvent ke ){
        
        ke.consume();
        JTextComponent jtc = js.getShellComponent();
        String modifiers = ke.getKeyModifiersText( ke.getModifiers() );
        String text = ke.getKeyText( ke.getKeyCode() );
        boolean removed = false;
        try{

            if( !modifiers.equals( "" ) || !text.equals( "Y" ) );
            else{
                
                List&lt;String&gt; who = js.getWho(); 
                for( String s: who ){
                    
                    String command = String.format( "del %1$s", s );
                    js._pi.exec( command );
                
                }
                who.clear();
                removed = true;
            
            } 
            
            Document doc = jtc.getDocument();
            try{
                
                String trail = "";
                if( !removed ) trail = "Nothing done.";
                String message = String.format( "\n%1$s\n", trail  );
                doc.insertString( jtc.getCaretPosition(), message , null );
            
            }
            catch( BadLocationException ble ){}
            js.insertPrompt( false );
        
        
        
        }
        catch( Exception x ){
        
        
        
        }
        finally{
        
            jtc.removeKeyListener( this );
        
        }
    
    
    }
    

    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return false;
    
    }


}
</t>
<t tx="ekr.20070127142814.248">
final Runnable run = new Runnable(){
    public void run(){
        
        JTextPane jtp = (JTextPane)js.getShellComponent();
        String message = "Once deleted, variables cannot be recovered. Proceed (y/n)? ";
        try{

            OutputStream out = js.getStandardOut();
            out.write( message.getBytes() );
            
        }
        catch( IOException io ){ io.printStackTrace(); }
        listening = true;
        jtp.addKeyListener( Reset.this );
        
    }
};

js.setNextPrompt( run );
</t>
<t tx="ekr.20070127142814.249">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.CommandFinder;
import java.io.*;
import java.util.*;
import java.util.regex.Pattern;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.text.*;
import javax.swing.*;

public class Alias implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%alias"; }
    public String getDescription(){
    
        return "%alias: Define an alias for a system command.\n"+
               "%alias alias name cmd  defines  alias name  as an alias for  cmd  Then, typing  alias name params  will execute the system command  cmd params  (from your underlying operating system).\n"+
               "Aliases have lower precedence than magic functions and Python normal variables, so if  foo  is both a Python variable and an alias, the alias can not be executed until  del foo  removes the Python variable.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%alias" ) || command.trim().equals( "%alias" );
    
    }


    public boolean doMagicCommand( String command ){
    
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.250">
String[] args = command.split( "\\s+", 2 );
if( args.length == 1 ){
    
    String format = "%1$-20s %2$s\n";
    StringBuilder sb = new StringBuilder();
    sb.append( String.format( format, "Alias", "System Command" ) );
    char[] c = new char[ sb.length() - 1 ];
    Arrays.fill( c, '-' );
    sb.append( c ).append( "\n" );
    Iterator&lt;org.leo.shell.alias.Alias&gt; aliases = js.getAliases();
    while( aliases.hasNext() ){
        org.leo.shell.alias.Alias alias = aliases.next();
        sb.append( String.format( format, alias.getAliasName(), alias.getName() ) );
    
    }
    sb.append( c ).append( "\n" );
    out.write( sb.toString().getBytes() );

}
else if( args.length == 2 ){

    String[] pieces2 = args[ 1 ].split( "\\s+", 2 );
    boolean created = false;
    if( pieces2.length == 2 ){
    
        String aliasname = pieces2[ 0 ];
        String[] cpieces = pieces2[ 1 ].split( "\\s+", 2 );
        String targetcommand = cpieces[ 0 ];
        String path = CommandFinder.findCommand( targetcommand, js.getCurrentWorkingDirectory() );
        if( path != null ){
            
            File cfile = new File( path );
            if( cfile.exists() &amp;&amp; cfile.isFile() ){
                org.leo.shell.alias.Alias alias = new org.leo.shell.alias.Alias( aliasname, cfile.getAbsolutePath(), js );
                js.addAlias( aliasname, alias ); 
                created = true;
                
            }
            
            
        }
          

    }
    
    if( created ) out.write( "Alias created.\n".getBytes() );
    else out.write( "Could not create alias.\n".getBytes() );
}</t>
<t tx="ekr.20070127142814.251">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 


public class Unalias implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%unalias"; }
    public String getDescription(){
    
        return "%unalias: Remove an alias\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%unalias" );
    
    }


    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.252">String[] pieces = command.split( "\\s+" );
if( pieces.length == 2 ){

    js.removeAlias( pieces[ 1 ] );


}</t>
<t tx="ekr.20070127142814.253">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.File;
import java.util.*; 
import java.util.regex.Pattern;


public class Rehash implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%rehash"; }
    public String getDescription(){
    
        return "%rehash: Update the alias table with all entries in $PATH. This version does no checks on execute permissions or whether the contents of $PATH are truly files (instead of directories or something else).\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%rehash" );
    
    }


    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.254">String path = System.getenv( "PATH" );
String psep = System.getProperty( "path.separator" );
String[] paths = path.split( Pattern.quote(psep) );
//build up system aliases
for( String p: paths ){
    
    File f = new File( p );
    if( f.exists() &amp;&amp; f.isDirectory() ){
    
            File[] files = f.listFiles();
            for( File f2: files ){
        
                org.leo.shell.alias.Alias alias = new org.leo.shell.alias.Alias( f2.getName(), f2.getAbsolutePath(), js );
                js.addAlias( alias.getAliasName(), alias );
                
            }
    
    }
}</t>
<t tx="ekr.20070127142814.255">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.File;
import java.util.*; 
import java.util.regex.Pattern;


public class Rehashx implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%rehashx"; }
    public String getDescription(){
    
        return "%rehashx: Update the alias table with all executable files in $PATH. This version explicitly checks that every entry in $PATH is a file, so it is slower than %rehash.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%rehashx" );
    
    }


    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.256">String path = System.getenv( "PATH" );
String psep = System.getProperty( "path.separator" );
String[] paths = path.split( Pattern.quote(psep) );
//build up system aliases
for( String p: paths ){
    
    File f = new File( p );
    if( f.exists() &amp;&amp; f.isDirectory() ){
    
            File[] files = f.listFiles();
            for( File f2: files ){
                if( f2.isFile() ){
                    org.leo.shell.alias.Alias alias = new org.leo.shell.alias.Alias( f2.getName(), f2.getAbsolutePath(), js );
                    js.addAlias( alias.getAliasName(), alias );
                }
            }
    
    }
}</t>
<t tx="ekr.20070127142814.257">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.python.core.*;
import java.io.*;
import java.util.*; 
import java.util.regex.Pattern;
import javax.swing.SwingUtilities;


public class Run implements MagicCommand{

    JythonShell js;
    boolean listening;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        listening = false;
    
    }
    
    public String getName(){ return "%run"; }
    public String getDescription(){
    
        return "%run: Run the named file inside the JythonShell as a program.\n"+
                "Usuage:\n"+
                "%run [-n -i -t [-N&lt;N&gt;] -d [-b&lt;N&gt;] -p [profile options]] file [args]\n"+
                "Options:\n"+
                " -n: name is NOT set to   main  , but to the running file s name without extension (as python does under import). This allows running scripts and reloading the definitions in them without calling code protected by an   if name ==   main     clause.\n"+
                "-i: run the file in JythonShell's namespace instead of an empty one. This is useful if you are experimenting with code written in a text editor which depends on variables defined interactively.\n"+
                "-t: print timing information at the end of the run.  If -t is given, an additional -N&lt;N&gt; option can be given, where &lt;N&gt; must be an integer indicating how many times you want the script to run. The final timing report will include total and per run results.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%run " );
    
    }


    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.258">
String[] spieces = command.split( "\\s+" );
LinkedList&lt;String&gt; switches = new LinkedList&lt;String&gt;();
for( int i = 0; i &lt; spieces.length; i ++ ){

    if( i == 0 ) continue;
    String cloption = spieces[ i ];
    if( !cloption.startsWith( "-" ) ) break;
    switches.add( cloption );
    command = command.replaceFirst( "\\" + cloption, "" );
}

String[] pieces = command.split( "\\s+", 3 );
if( pieces.length &gt;= 2 ){
    
    String fname = pieces[ 1 ];
    if( !fname.endsWith( ".py" ) ) fname += ".py";
    File test = new File( fname );
    if( !test.exists() ){
    
        String[] path = fname.split( "\\." );
        StringBuilder sb = new StringBuilder();
        for( int i = 0; i &lt; path.length - 1; i ++ ){
        
            sb.append( path[ i ] ).append( "/" );
        
        }
        if( sb.charAt( sb.length() -1 ) == '/' ) sb.deleteCharAt( sb.length() -1 );
        sb.append( ".py" );
        fname = search( sb.toString() );
        if( fname == null ) return true;
    
    }

    List&lt;String&gt; pyswitches;
    if( pieces.length == 3 )
        pyswitches = org.leo.shell.util.CommandLineParser.parseCommandLine( pieces[ 2 ] );
    else pyswitches = new ArrayList();
    

    PyDictionary locals = new PyDictionary();
    if( switches.contains( "-i" ) ) locals.update( js._pi.getLocals() );


    PyString __name__ = new PyString( "__name__" );
    if( switches.contains( "-n" )){
        
        String lname = pieces[ 1 ];
        if( lname.endsWith( ".py" ) ) lname = lname.replaceFirst( "\\.py$", "" );
        locals.__setitem__( __name__, new PyString( lname ) );
    
    }
    else locals.__setitem__( __name__ , new PyString( "__main__" ) );
    
    long time = 0l;
    int iterations = 1;
    boolean timeit = false;
    if( switches.contains( "-t" ) ) timeit = true;
    if( timeit ){
    
        Integer i = getNumberFromSwitches( switches, "-N" );
        if( i != null ) iterations = i;
    
    }
    
    boolean debug = false;
    int lineno = -1;
    if( switches.contains( "-d" ) ) debug = true;
    if( debug ){
        
        Integer i = getNumberFromSwitches( switches, "-b" );
        if( i != null ) lineno = i;
        runDebug( fname, lineno );
        return false;
    
    }
    
    boolean profile = switches.contains( "-p" );
    for( int i = 0; i &lt; iterations; i++ ){
    
        long start = System.currentTimeMillis();
        run( fname, pyswitches, locals, profile );
        long end = System.currentTimeMillis();
        time += ( end - start );

    }
    if( timeit ){
    
        OutputStream stdout = js.getStandardOut();
        String message = String.format( "Time: %1$d with %1$d iterations\n", time, iterations );
        try{
        
            stdout.write( message.getBytes() );
        
        }
        catch( IOException io ){}
    
    }
}
</t>
<t tx="ekr.20070127142814.259">public String search( String file ){

    String classpath = System.getenv( "CLASSPATH" );
    String sep = System.getProperty( "path.separator" );
    String[] paths = classpath.split( Pattern.quote( sep ) );
    for( String path: paths ){
    
        File test = new File( path, file );
        if( test.exists() ) return test.getAbsolutePath();
    
    
    }
    
    return null;
}</t>
<t tx="ekr.20070127142814.260">public void run( String fname, List&lt;String&gt; switches, PyDictionary locals, boolean profile  ){
    
    js._pi.exec( "import sys" );
    PyObject sys = js._pi.get( "sys" );
    PyList sysargv = (PyList)__builtin__.getattr( sys, new PyString( "argv" ) );
    PyList pl = new PyList( (PyObject)sysargv );
    sysargv.clear();
    sysargv.add( fname );
    sysargv.addAll( switches );
    if( profile ){
    
        String arg_str = String.format( "arg_str = 'execfile( \\'%1$s\\',{})'", fname ); 
        String[] pstrings = new String[]{
        
        "import profile",
        "prof = profile.Profile()",
        arg_str,
        "try:",
        "   prof = prof.runctx( arg_str, locals(), locals() )",
        "except SystemExit:",
        "   sys_exit = '''*** SystemExit exception caught in code being profiled.'''",
        "prof.print_stats()",
        };
        StringBuilder sb = new StringBuilder();
        for( String s: pstrings ) sb.append( s ).append( "\n" );
        js._pi.exec( sb.toString() );
    
    }
    else
        __builtin__.execfile_flags( fname, locals, locals, null );
    PyObject localmap = js._pi.getLocals();
    ((PyStringMap)localmap).update( locals );
    sysargv.clear();
    sysargv.addAll( pl );

}
</t>
<t tx="ekr.20070127142814.261">public void runDebug( final String fname, final int breakpoint ){
    
    class Runner implements Runnable{
    
        public void run(){
        
            StringBuilder sb = new StringBuilder();
            sb.append( "filename = '" + fname + "'" ).append( "\n" );
            String[] realpdb;
            if( breakpoint != -1 ){
                sb.append( String.format( "bp = %1$d", breakpoint ) ).append( "\n" );
                realpdb = pdb;   
            }
            else realpdb = pdb2;
            for( String s: realpdb )
                    sb.append( s ).append( "\n" );

            
            String command = sb.toString();
            ByteArrayInputStream bais = new ByteArrayInputStream( command.getBytes() );
            js._pi.execfile( bais, fname );
            org.leo.shell.util.InsertPrompt ip = new org.leo.shell.util.InsertPrompt( js, false );
            SwingUtilities.invokeLater( ip );
        
        }    
    
    
    
    }
    js.execute1( new Runner() );


}
</t>
<t tx="ekr.20070127142814.262">public Integer getNumberFromSwitches( List&lt;String&gt; switches, String swname ){


    for( String s: switches ){
        
        if( s.startsWith( swname ) ){
            
            try{
                String number = s.substring( 2 );
                return Integer.valueOf( number );
            }
            catch( Exception x ){}
            
        }
        
    }

    return null;

}</t>
<t tx="ekr.20070127142814.263">private static String[] pdb = new String[]{
"import pdb;import bdb",
"deb = pdb.Pdb()",
"bdb.Breakpoint.next = 1",
"bdb.Breakpoint.bplist = {}",
"bdb.Breakpoint.bpbynumber = [None]",
"maxtries = 10",
//"bp = %1$d",//int(opts.get('b',[1])[0])",
"checkline = deb.checkline(filename,bp)",
"ok = True",
"if not checkline:",
"    for bp in range(bp+1,bp+maxtries+1):",
"        if deb.checkline(filename,bp):",
"            break",
"            ok = True",
"        else:",
"            msg = ('I failed to find a valid line to set '",
"                                   'a breakpoint '",
"                                   'after trying up to line: %s. '",
"                                   'Please set a valid breakpoint manually '",
"                                   'with the -b option.' % bp)",
"            #error(msg)",
"            #return",
"            ok = False",
"if ok:",
"   deb.do_break('%s:%s' % (filename,bp))",
"   print 'NOTE: Enter \\'c\\' at the'",
"   print '(Pdb) prompt to start your script.'",
"   deb.run('execfile(\\'%s\\')' % filename,{})"};</t>
<t tx="ekr.20070127142814.264">private static String[] pdb2 = new String[]{
"import pdb",
"deb = pdb.Pdb()",
"deb.run('execfile(\\'%s\\')' % filename,{})"};</t>
<t tx="ekr.20070127142814.265">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
//import org.python.core.*;
import java.io.*;
import java.util.*; 
//import java.util.regex.Pattern; 
//import javax.swing.SwingUtilities;


public class Bookmark implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%bookmark"; }
    public String getDescription(){
    
        return "%bookmark &lt;name&gt; - set bookmark to current dir %bookmark &lt;name&gt; &lt;dir&gt; - set bookmark to &lt;dir&gt; %bookmark -l - list all bookmarks %bookmark -d &lt;name&gt; - remove bookmark %bookmark -r - remove all bookmarks You can later on access a bookmarked folder with: %cd -b &lt;name&gt; or simply  %cd &lt;name&gt;  if there is no directory called &lt;name&gt; AND there is such a bookmark defined.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().startsWith( "%bookmark " );
    
    }


    public boolean doMagicCommand( String command ){
    
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.266">
String[] args = command.split( "\\s+" );
OutputStream out = js.getStandardOut();
OutputStream err = js.getStandardErr();
try{
    if( args.length &gt; 1 ){

        if( args.length == 2 ){
    
            if( args[ 1 ].equals( "-l" )){
        
                Iterator&lt;Map.Entry&lt;String,File&gt;&gt; bmarks = js.getBookmarks();
                String format = "%1$s : %2$s\n";
                StringBuilder sb = new StringBuilder();
                sb.append( "Bookmarks:\n" );
                while( bmarks.hasNext() ){
            
                    Map.Entry&lt;String,File&gt; bm = bmarks.next();
                    String sfbmark = String.format( format, bm.getKey(), bm.getValue() );
                    sb.append( sfbmark );
            
                }
                out.write( sb.toString().getBytes() );

        
            }
            else if( args[ 1 ].equals( "-r" ) ){
        
                js.clearBookmarks();
                out.write( "Bookmarks have been cleared.\n".getBytes() );
        
            }
            else{
        
                File cwd = js.getCurrentWorkingDirectory();
                js.addBookmark( args[ 1 ], cwd );
                String message = String.format( "Bookmark %1$s has been added.\n", args[ 1 ] );
                out.write( message.getBytes() );
    
            }
    
        }
        else if( args.length == 3 ){
    
            String arg1 = args[ 1 ];
            String arg2 = args[ 2 ];
            if( arg1.equals( "-d" ) ){
            
                js.removeBookmark( arg2 );
                String message = String.format( "Bookmark %1$s has been removed.\n", arg2 );
                out.write( message.getBytes() );
        
            }
            else{
        
                File f = new File( arg2 );
                if( f.exists() &amp;&amp; f.isDirectory() ){
            
                    js.addBookmark( arg1, f );
                    String message = String.format( "Bookmark %1$s has been added\n", arg1 );
                    out.write( message.getBytes() );

                }
                else{
            
                    if( !f.exists() ){
                    
                        String message = String.format( "Directory %1$s does not exist.\n", arg2 );
                        err.write( message.getBytes() );
                    
                    
                    }
                    else{
                        
                       String message = String.format( "%1$s is not a directory.\n", arg2 );
                       err.write( message.getBytes() ); 
                        
                    
                    }
                     
            
            }
        
        }
    
    
    
    }



    }
    else err.write( "%bookmark requires arguments, none given.\n".getBytes() );
    
}
catch( IOException io ){}//we do this like this, because there are soo many times it can happen!!!</t>
<t tx="ekr.20070127142814.267">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.python.core.PyList;


public class Dirs implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%dirs"; }
    public String getDescription(){
    
        return "%dirs: Return the current directory stack.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%dirs" );
    
    }


    public boolean doMagicCommand( String command ){
    
        &lt;&lt;command&gt;&gt;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.268">
PyList dstack = js.getDirectoryStack();
js._pi.set( "_", dstack );
js._pi.push( "_" );
return false;</t>
<t tx="ekr.20070127142814.269">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;

public class Popd implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%popd"; }
    public String getDescription(){
    
        return "%popd: Change to directory popped o  the top of the stack.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%popd" );
    
    }


    public boolean doMagicCommand( String command ){
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.270">OutputStream out = js.getStandardOut();
OutputStream err = js.getStandardErr();
try{

    String directory = js.popDStack();
    if( directory == null ){
    
        err.write( "Can't pop the directory stack\n".getBytes() );
        return true;
    
    }
    directory = js.getTopOfDStack();
    File f = new File( directory );
    if( f.exists() &amp;&amp; f.isDirectory() ){

        js.setCurrentWorkingDirectory( f );
        String message = "Current working directory is now %1$s\n";
        out.write( String.format( message, f ).getBytes() );

    }
    else{
        
        if( !f.exists() )
            err.write( "Directory returned from the stack, does not exits\n".getBytes() );
        else
            err.write( "Item returned from the stack is not a directory\n".getBytes() );
    }
}
catch( IOException io ){}</t>
<t tx="ekr.20070127142814.271">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;

public class Pushd implements MagicCommand{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%pushd"; }
    public String getDescription(){
    
        return "%pushd: Place the passed in directory on stack and change directory to it. Usage: %pushd [ dirname ] %pushd with no arguments does a %pushd to your home directory.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%pushd" ) || command.startsWith( "%pushd " );
    
    }


    public boolean doMagicCommand( String command ){
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.272">OutputStream out = js.getStandardOut();
OutputStream err = js.getStandardErr();
try{

    String[] pieces = command.split( "\\s+" );
    if( pieces.length == 1 ){
        
        String home = System.getenv( "HOME" );
        if( home != null ){
            File fhome = new File( home );
            if( pushD( fhome ) ){
            
                return true;
                
            }
            else{
            
                if( !fhome.exists() ) err.write( "HOME environment variable invalid\n".getBytes() );
                else err.write( "HOME environment variable does not point to a directory\n".getBytes() );
                return true;
                
            }
        }
        else{
            
            err.write( "HOME environment variable does not exists, can't switch to HOME\n".getBytes() );
            return true;
        
        }
    
    }
    else if( pieces.length == 2 ){
    
        String nwdirectory = pieces[ 1 ];
        File f = new File( nwdirectory );
        if( pushD( f ) ){
            
            return true;
        
        }
        else{
        
            if( !f.exists() ) err.write( (nwdirectory + " does not exist\n").getBytes() );
            else err.write( (nwdirectory + " is not a directory.\n").getBytes() );
            return true;
        
        }
    
    
    
    
    
    }
    else{
    
        err.write( "Command does not follow proper format\n".getBytes() );
        return true;
    
    }



}
catch( IOException io ){}</t>
<t tx="ekr.20070127142814.273">private boolean pushD( File f ){
    
    OutputStream out = js.getStandardOut();
    try{
        if( f.exists() &amp;&amp; f.isDirectory() ){
            
            File cwd = js.getCurrentWorkingDirectory();
            if( cwd.equals( f ) ){
                
                out.write( "Already there!\n".getBytes() );
                return true;
            
            
            }
            js.pushDStack( f );
            String message = "%1$s is now the Current Working Directory\n";
            out.write( String.format( message, f ).getBytes() );
            return true;
        }
        else return false;
    }
    catch( IOException io ){ return false; }
    
}</t>
<t tx="ekr.20070127142814.274">@language java
package org.leo.shell.magic; 

import org.leo.shell.Documentation;
import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;

public class Automagic implements MagicCommand, Documentation{

    JythonShell js;
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
        js.addInteractiveDocumentation( this );
    
    }
    
    public String getDocumentation(){
    
        return "Automagic:\n"+
        "Automagic is simply being able to call magic commands without the '%' character.\n"+
        "This is toggled on and off with the %automagic magic command.\n";
    }
    
    public String getName(){ return "%automagic"; }
    public String getDescription(){
    
        return "%automagic: Make magic functions callable without having to type the initial %. Toggles on/o  (when o , you must call it as %automagic, of course). Note that magic functions have lowest priority, so if there s a variable whose name collides with that of a magic fn, automagic won t work for that function (you get the variable instead). However, if you delete the variable (del var), the previously shadowed magic function becomes visible to automagic again.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%automagic" );
    
    }


    public boolean doMagicCommand( String command ){
    
        &lt;&lt;command&gt;&gt;
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.275">OutputStream out = js.getStandardOut();
try{
    
    boolean status = js.getAutomagic();
    if( status ){
    
        js.setAutomagic( false );
        out.write( "Automagic is OFF, % prefix IS needed for magic functions.\n".getBytes() );
    
    }
    else{
        
        js.setAutomagic( true );
        out.write( "Automagic is ON, % prefix NOT needed for magic functions.\n".getBytes() );
    
    
    }

}
catch( IOException io ){}</t>
<t tx="ekr.20070127142814.276">@language java
package org.leo.shell.magic;

import java.util.*;
import java.io.OutputStream;


public class Logcore{

    static boolean logging = false;
    static Map&lt;String, OutputStream&gt; logstreams = new HashMap&lt;String, OutputStream&gt;();
    
}</t>
<t tx="ekr.20070127142814.277">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import org.python.core.PyList;
import java.io.*;
import java.nio.channels.*;
import java.util.*;

public class Logstart implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%logstart"; }
    public String getDescription(){
    
        return "%logstart: Start logging anywhere in a session. %logstart [log name [log mode]] If no name is given, it defaults to a file named  jythonshell.log  in your current directory, in  rotate  mode (see below).  %logstart name  saves to file  name  in  backup  mode. It saves your history up to that point and then continues logging. %logstart takes a second optional parameter: logging mode. This can be one of (note that the modes are given unquoted): over: overwrite existing log. backup: rename (if exists) to name and start name. append: well, that says it. rotate: create rotating logs name.1 , name.2 , etc.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%logstart " ) || command.trim().equals( "%logstart" );
    
    }


    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.278">String[] pieces = command.split( "\\s+" );
File log;
final String nwlog;
List&lt;String&gt; options = new ArrayList&lt;String&gt;( 4 );
String[] soptions = new String[]{ "over", "backup", "append", "rotate" };
Collections.addAll( options, soptions );
String option = "backup";
if( pieces.length &gt;= 2 &amp;&amp; !options.contains( pieces[ 1 ] ) ){

    File cwd = js.getCurrentWorkingDirectory();
    nwlog = pieces[ 1 ];
    log = new File( cwd, nwlog );
    if( pieces.length == 3 &amp;&amp; options.contains( pieces[ 2 ] ) ) option = pieces[ 2 ];

}
else{
    
    File directory = js.getCurrentWorkingDirectory();
    log = new File( directory, "jythonshell.log" );
    nwlog = "jythonshell.log";
    if( pieces.length == 2 &amp;&amp; options.contains( pieces[ 1 ] ) ) option = pieces[ 1 ];
    
}

if( option.equals( "backup" ) ){
    
    String absolutepath = log.getAbsolutePath();
    File rnfile = new File( log.getAbsolutePath() + "~" );
    if( log.exists() &amp;&amp; log.isFile() ) log.renameTo( rnfile );
    log = new File( absolutepath );


}
else if ( option.equals( "over" ) ){

    if( log.exists() &amp;&amp; log.isFile() ) log.delete();

}
else if ( option.equals( "rotate" ) &amp;&amp; log.exists() &amp;&amp; log.isFile() ){

     File parent = log.getParentFile();
    	File[] files = parent.listFiles( new RotateFilter( log.getName() ) );
     int number = 0;
     for( File f: files ){
     
        String name = f.getName();
        if( name.endsWith( "~" ) ){
        
            name = name.substring( 0, name.length() -1 );
            String[] npieces = name.split( "\\." );
            String pnum = npieces[ npieces.length -1 ];
            try{
            
                int i = Integer.valueOf( pnum );
                if( i &gt; number ) number = i;
            
            }
            catch( NumberFormatException nfe ){}
        
        }
     
     }
     String absolutepath = log.getAbsolutePath();
     String rotatename = "%1$s.%2$d~";
     rotatename = String.format( rotatename, absolutepath, ++number );
     File changeTo = new File( rotatename );
     log.renameTo( changeTo );
     log = new File( absolutepath );


}


final OutputStream os;
if( option.equals( "append" ) ){
    
    RandomAccessFile raf = new RandomAccessFile( log, "rw" );
    FileChannel fc = raf.getChannel();
    fc.position( log.length() );
    os = Channels.newOutputStream( fc );

}
else os = new FileOutputStream( log );

Logcore.logstreams.put( nwlog, os );
js.addLogger( os );
Logcore.logging = true;

PyList history = js.history;
for( int i = 0; i &lt; history.size(); i++ ){
    
    os.write( history.get( i ).toString().getBytes() );
    os.write( "\n".getBytes() );
    
}
out.write( ("Logging has started, log is located at: " + log.getAbsolutePath() + "\n" ).getBytes() );


</t>
<t tx="ekr.20070127142814.279">public static class RotateFilter implements FilenameFilter{

    String prefix;
    public RotateFilter( String prefix ){
    
        this.prefix = prefix;
    
    }
    
    public boolean accept( File parent, String name ){
    
        if( name.startsWith( prefix ) ) return true;
        return false;
    
    }

}</t>
<t tx="ekr.20070127142814.280">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;
import java.util.Collection;

public class Logoff implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%logoff"; }
    public String getDescription(){
    
        return "%logoff: Temporarily stop logging. You must have previously started logging.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%logoff" );
    
    }


    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.281">if( Logcore.logstreams.size() == 0 ){

    err.write( "Logging has not started, nothing to turn off.\n".getBytes() );


}
else if( Logcore.logging == false ){

    err.write( "Logging has been suspended, nothing to turn off.\n".getBytes() );

}
else{

    Collection&lt;OutputStream&gt; streams = Logcore.logstreams.values();
    for( OutputStream os: streams )
        js.removeLogger( os );
    Logcore.logging = false;
    out.write( "Loggin has been suspended\n".getBytes() );

}

</t>
<t tx="ekr.20070127142814.282">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;
import java.util.Collection;

public class Logon implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%logon"; }
    public String getDescription(){
    
        return "%logon: Restart logging. This function is for restarting logging which you ve temporarily stopped with %logoff. For starting logging for the first time, you must use the %logstart function, which allows you to specify an optional log filename.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%logon" );
    
    }


    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.283">if( Logcore.logstreams.size() == 0 ){

    err.write( "Logging has not been started, use Logstart.\n".getBytes() );

}
else if( Logcore.logging == true ){

    err.write( "Logging already occuring, operation can't restore anything.\n".getBytes() );

}
else{

    Collection&lt;OutputStream&gt; streams = Logcore.logstreams.values();
    for( OutputStream os: streams )
        js.addLogger( os );
        
    Logcore.logging = true;
    out.write( "Logging has been resumed.\n".getBytes() );


}

</t>
<t tx="ekr.20070127142814.284">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand; 
import java.io.*;

public class Logstate implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%logstate"; }
    public String getDescription(){
    
        return "%logstate: Print the status of the logging system.\n\n";
    
    } 

    public boolean handle( String command ){
    
        return command.trim().equals( "%logstate" );
    
    }


    public boolean doMagicCommand( String command ){
        
        OutputStream out = js.getStandardOut();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.285">if( Logcore.logstreams.size() == 0 )out.write( "Logging has not been activated.\n".getBytes() );
else if( Logcore.logging == true )out.write( "Logging has been activated and is On.\n".getBytes() );
else out.write( "Logging has been activated and is Off.\n".getBytes() );
</t>
<t tx="ekr.20070127142814.286">@language java
package org.leo.shell.magic; 

import org.leo.shell.JythonShell;
import org.leo.shell.MagicCommand;
import org.leo.shell.util.InsertPrompt; 
import java.io.*;
import java.util.*;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ExecutionException;
import javax.swing.SwingUtilities;

public class Runlog implements MagicCommand{

    JythonShell js;
    
    public void setJythonShell( JythonShell shell ){
    
        js = shell;
    
    }
    
    public String getName(){ return "%runlog"; }
    public String getDescription(){
    
        return "%runlog: Run files as logs. Usage: %runlog file1 file2 ... Run the named files (treating them as log files) in sequence inside the interpreter, and return to the prompt. This is much slower than %run because each line is executed in a try/except block, but it allows running files with syntax errors in them.\\n";
    
    } 

    public boolean handle( String command ){
    
        return command.startsWith( "%runlog " );
    
    }


    public boolean doMagicCommand( String command ){
        
        final OutputStream out = js.getStandardOut();
        final OutputStream err = js.getStandardErr();
        try{
            &lt;&lt;command&gt;&gt;
        }
        catch( IOException io ){}
        return true;
    
    }
    
    @others

}</t>
<t tx="ekr.20070127142814.287">final String[] pieces = command.split( "\\s+" );
if( pieces.length == 1 ){

    err.write( "%runlog requires at least 1 argument, a file to run.  No file given.\n".getBytes() );
    return true;

}

Runnable run = new Runnable(){

    public void run(){
        boolean more = false;
        for( int i = 1; i &lt; pieces.length; i++ ){
        
            try{
                String file = pieces[ i ];
                String ftoexecute = null;
                File f = new File( file );
                File f2 = new File( js.getCurrentWorkingDirectory(), file );
                if( f.exists() &amp;&amp; f.isFile() ) ftoexecute = f.getAbsolutePath();
                else if( f2.exists() &amp;&amp; f2.isFile() ) ftoexecute = f2.getAbsolutePath();
                else{
        
                    err.write( ( "Could not find " + file + ". Continuing execution.\n" ).getBytes() );
                    continue;
    
                }
    
                FileInputStream fis = new FileInputStream( new File( ftoexecute ) );
                BufferedReader br = new BufferedReader( new InputStreamReader( fis ) );
                String line = null;
                out.write( ( "Executing File: " + file + "\n" ).getBytes() );
                while( ( line = br.readLine() ) != null ){
                    try{
                        
                        js.addLineToExecute( line );
                        FutureTask&lt;Boolean&gt; ft = new FutureTask&lt;Boolean&gt;( js );
                        js.execute1( ft );
                        more = ft.get();
                    }
                    catch( Exception x ){
        
                        err.write( ( "Problem executing: " + line + "\n" ).getBytes() );
        
                    }
                }
            }catch( IOException io ){}

            }
            InsertPrompt ip = new InsertPrompt( js, more );
            SwingUtilities.invokeLater( ip );
        }
    };

Runnable noprompt = new Runnable(){ public void run(){} };

js.setNextPrompt( noprompt );
js.execute2( run );</t>
<t tx="ekr.20070127142814.288">@path org/leo/shell/magic/editor
</t>
<t tx="ekr.20070127142814.289">@language java

package org.leo.shell.magic.editor;

import javax.swing.AbstractAction;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class StartOfLine extends AbstractAction{


    public void actionPerformed( ActionEvent ae ){
    
        try{
            JTextComponent jtc = (JTextComponent)ae.getSource();
            int spot = Utilities.getRowStart( jtc, jtc.getCaretPosition() );
            jtc.setCaretPosition( spot );
        }
        catch( BadLocationException ble ){}    
    
    
    }


}</t>
<t tx="ekr.20070127142814.290">@language java

package org.leo.shell.magic.editor;

import javax.swing.AbstractAction;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class EndOfLine extends AbstractAction{


    public void actionPerformed( ActionEvent ae ){
    
        try{
            JTextComponent jtc = (JTextComponent)ae.getSource();
            int spot = Utilities.getRowEnd( jtc, jtc.getCaretPosition() );
            jtc.setCaretPosition( spot );
        }
        catch( BadLocationException ble ){}    
    
    
    }


}</t>
<t tx="ekr.20070127142814.291">@path org/leo/shell/actions</t>
<t tx="ekr.20070127142814.292">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class DeleteToEndOfLine extends AbstractAction implements Documentation{

    JTextPane jtp;
    public DeleteToEndOfLine( JTextPane jtp ){
    
        this.jtp = jtp;
    
    }

    public String getDocumentation(){
    
        return "Removes all text from current position to end of the line.\n";
    
    }


    public void actionPerformed( ActionEvent ae ){

        final AbstractDocument doc = (AbstractDocument)jtp.getDocument();
        final int cp = jtp.getCaretPosition();
        Element p = doc.getParagraphElement( cp );
        int end = p.getEndOffset();
        try{
            doc.remove( cp, ( end -1 ) - cp );
        }
        catch( BadLocationException ble ){}
    
    }




}</t>
<t tx="ekr.20070127142814.293">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation; 
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class RemoveLine extends AbstractAction implements Documentation{

    JTextPane jtp;
    JythonShell js;
    public RemoveLine( JythonShell js ){
    
        this.jtp = (JTextPane)js.getShellComponent();
        this.js = js;
    
    }
    
    public String getDocumentation(){
    
        return "Removes all text from the prompt to the end of the line.\n";
    
    }
    
    public void actionPerformed( ActionEvent ae ){

        //event.consume();
        final AbstractDocument doc = (AbstractDocument)jtp.getDocument();
        final int cp = jtp.getCaretPosition();
        Element p = doc.getParagraphElement( cp );
        int end = p.getEndOffset() -1;
        try{
            doc.remove( js.getOutputSpot(), end - js.getOutputSpot() );
        }
        catch( BadLocationException ble ){}
    
    }




}</t>
<t tx="ekr.20070127142814.294">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class StartOfLine extends AbstractAction implements Documentation{

    JTextPane jtp;
    JythonShell js;
    public StartOfLine( JythonShell js ){
    
        this.jtp = (JTextPane)js.getShellComponent();
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "Moves current position to the end of the prompt.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){


        final int start = js.getOutputSpot();
        jtp.setCaretPosition( start );
 
    
    }




}</t>
<t tx="ekr.20070127142814.295">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation; 
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class EndOfLine extends AbstractAction implements Documentation{

    JTextPane jtp;
    JythonShell js;
    public EndOfLine( JythonShell js ){
    
        this.jtp = (JTextPane)js.getShellComponent();
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "Moves current position to the end of the line.\n";
    
    }


    public void actionPerformed( ActionEvent ae ){

        
        final int end = js.endOfLine();
        jtp.setCaretPosition( end );
 
    
    }




}</t>
<t tx="ekr.20070127142814.296">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation; 
import javax.swing.*;
import java.awt.event.ActionEvent;


public class DynamicAbbreviation extends AbstractAction implements Documentation{


    JythonShell js;
    public DynamicAbbreviation( JythonShell js ){
    
        this.js = js;
    
    }
    
    public String getDocumentation(){
    
        return "Dynamic Abbreviations:\n" +
        "-----------------------\n" +
        "Executing will dynamically expand a prefix to matching\n"+
        "words already entered within the interpreter.  For example:\n"+
        "cactus\n"+
        "cac( keystroke ) will expand cac to cactus.\n" +
        "This will cycle through all matches to cac within the buffer upon repeated execution.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        
        js.dynamicAbbreviation();
 
    
    }




}</t>
<t tx="ekr.20070127142814.297">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;


public class UpDownArrows{


    JythonShell js;
    JTextPane jtp;
    int pos;
    int lastsize;
    public UpDownArrows( JythonShell js ){
    
        this.js = js;
        this.jtp = (JTextPane)js.getShellComponent();
        pos = 0;
        lastsize = 0;
    }
    
    private static abstract class DocumentedAction extends AbstractAction implements Documentation{
    
    
    }
    
    public Action getUp(){
    
        return new DocumentedAction(){
        
            public String getDocumentation(){
            
                return "This moves the current line up one item in the history\n" +
                       "By moving, this means the current line is replaced with history item\n";
            
            }
        
            public void actionPerformed( ActionEvent ae ){
            
                processEvent( ae, "Up" );
            
            }
        
        
        };
    
    
    
    }
    
    public Action getDown(){
    
        return new DocumentedAction(){
        
            public String getDocumentation(){
            
                return "This moves the current line down one item in the history\n" +
                       "By moving, this means the current line is replaced with history item\n";
            
            }
        
            public void actionPerformed( ActionEvent ae ){
            
                processEvent( ae, "Down" );
            
            }
        
        
        };
    
    
    
    }


    public void processEvent( ActionEvent event, String which ){

        
        &lt;&lt;body&gt;&gt;
 
    
    }




}</t>
<t tx="ekr.20070127142814.298">if( js.lines.size() != 0 ){

    final int size = js.lines.size();
    if( size != lastsize ) pos = size -1;
    lastsize = size;
    boolean blank = false;
    String line = js.lines.get( pos );
    if( which.equals( "Up" ) ){
         
        if( pos == 0 ) pos = size - 1;
        else
            pos--;
            
        
    }
    else{
            
        if( pos == size - 1 ) pos = 0;
        else
            pos++;
        
        
    }
    final Document doc = jtp.getDocument();
        
    try{
        
        final int end = js.endOfLine();
        doc.remove( js.getOutputSpot(), end - js.getOutputSpot() );
        js.colorize( line, line, js.getOutputSpot(), js.getOutputSpot(), end );
            //pos++;
            
    }
    catch( Exception x ){
        x.printStackTrace();
        
    }
    
    
}</t>
<t tx="ekr.20070127142814.299">@language java
package org.leo.shell.actions;

import org.leo.shell.Documentation;
import org.leo.shell.util.Abbreviation;
import org.leo.shell.util.JSUtilities;
import org.leo.shell.color.JythonColorizer;
import org.python.core.*;
import org.python.parser.*;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent;
import java.util.*;

public class TabCompletion extends AbstractAction implements Documentation{


    JTextPane jtc;
    //JythonShell js;
    JythonColorizer jc;
    Abbreviation la;
    Set&lt;String&gt; abbrevs;
    LinkedList&lt;String&gt; cabbrevs;
    public TabCompletion( JTextPane jtc, JythonColorizer jc ){
    
        //this.js = js;
        this.jtc = jtc;
        this.jc = jc;
        la = null;
        abbrevs = new HashSet&lt;String&gt;();
        cabbrevs = new LinkedList&lt;String&gt;();
        final PySystemState pss = Py.getSystemState();
        final PyStringMap psm = (PyStringMap)pss.builtins;
        final PyList pl = psm.keys();
        for( int i = 0; i &lt; pl.__len__(); i ++ )
            abbrevs.add( pl.__getitem__( i ).toString() );
        final String[] kwrds = PythonGrammarConstants.tokenImage;
        for( String s: kwrds ){
            
            s = s.replaceAll( "\\\"", "" );
            if( s.length() == 0 ) continue;
            char c1 = s.charAt( 0 );
            if( Character.isLetter( c1 ) ) abbrevs.add( s );
        
        } 
        abbrevs.add( "__init__" );
        abbrevs.add( "self" );
        
    }
    
    
    public String getDocumentation(){
    
        return "Executing this keystroke will attempt to complete the current word " +
        "against the available python keywords and conventions.  So for example:\n" +
        "cl(Keystroke)\n"+
        "becomes:\n"+
        "class\n" +
        "or:\n" +
        "__i(Keystroke)\n"+
        "becomes:\n" +
        "__init__\n" +
        "If a completion cannot be found, 4 spaces are inserted instead.\n";
    
    }
    
    public void actionPerformed( ActionEvent ae ){

        String word = JSUtilities.getWordStart( jtc );
        int index = JSUtilities.getWordStartIndex( jtc );
        if( word.trim().equals( "" ) ){
             insertTab();
             return;
        }
        if( la != null ){
        
            if( la.spos == index &amp;&amp; word.startsWith( la.start ) ){
                
                if( cabbrevs.size() != 0 )
                    nextCompletion( index, la.start );
                else
                    startCompletion( index, la.start );
                
            }
            else startCompletion( index, word );
        
        }
        else startCompletion( index ,word );
    
    }


    @others
}</t>
<t tx="ekr.20070127142814.300">private void startCompletion( int spos, String word ){

    cabbrevs.clear();
    for( String s: abbrevs ){
        
        if( s.startsWith( word ) ) cabbrevs.add( s );
    
    }
    
    if( cabbrevs.size() != 0 ){
        Collections.sort( cabbrevs );
        String aword = cabbrevs.removeFirst();
        la = new Abbreviation( word, aword, spos );
        insertAbbrev( la );
    }
    else{
    
        la = null;
        insertTab();
    
    }

}

</t>
<t tx="ekr.20070127142814.301">public void nextCompletion( int spos, String word ){

    String aword = cabbrevs.removeFirst();
    la = new Abbreviation( word, aword, spos );
    insertAbbrev( la );

}</t>
<t tx="ekr.20070127142814.302">private void insertAbbrev( Abbreviation la ){

    try{

        DefaultStyledDocument dsd = (DefaultStyledDocument)jtc.getDocument();
        String cword = JSUtilities.getWordStart( jtc );
        int start = JSUtilities.getWordStartIndex( jtc );
        dsd.replace( start, cword.length(), la.current, null );
        if( jc != null )
            jc.colorize( la.current, "", start, start, start + cword.length() );
    
    }
    catch( BadLocationException ble ){}

}</t>
<t tx="ekr.20070127142814.303">private void insertTab(){

    Document doc = jtc.getDocument();
    try{
        doc.insertString( jtc.getCaretPosition(), "    ", null );
    }
    catch( BadLocationException ble ){}

}</t>
<t tx="ekr.20070127142814.304">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;
import java.util.*;
import org.python.core.*;


public class SearchInputHistory extends KeyAdapter{


    JythonShell js;
    int spot;
    String current;
    public SearchInputHistory( JythonShell js ){
    
        this.js = js;
        js.getShellComponent().addKeyListener( this );
        int spot = -1;
        current = null;
    }
    
    public String getDocumentation(){
    
        return "Opens a search prompt. Begin typing and the system searches your history for lines that contain what you ve typed so far, completing as much as it can.";  
    
    }
    
    public void keyPressed( KeyEvent event ){
    
        String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
        if( !opmodifiers.equals( "" ) ) return;
        spot = -1;
        current = null;
    
    }
    
    private static abstract class DocumentedAction extends AbstractAction implements Documentation{}
    
    
    public Action getPreviousUp(){
    
        return new DocumentedAction(){
        
            public String getDocumentation(){
            
                return "Start typing, and then use this keystroke to search upwards through only the history items that match what you ve typed so far. If you use this keystroke at a blank prompt, they just behave like normal arrow keys.\n";
            
            
            }
        
            public void actionPerformed( ActionEvent ae ){
            
                processRequest( ae, "Up" );
            
            }
        
        
        
        };
    
    
    }
    
    public Action getNextDown(){
    
        return new DocumentedAction(){

            public String getDocumentation(){
            
                return "Start typing, and then use this keystroke to search downwards only through the history items that match what you ve typed so far. If you use this keystroke at a blank prompt, they just behave like normal arrow keys.\n";
            
            
            }
        
            public void actionPerformed( ActionEvent ae ){
            
                processRequest( ae, "Down" );
            
            }
        
        
        };
    
    
    }
    
    
    public void processRequest( ActionEvent ae, String which ){
    
        &lt;&lt;process&gt;&gt;
    
    
    }


}
</t>
<t tx="ekr.20070127142814.305">JTextComponent jtc = js.getShellComponent();
AbstractDocument doc = (AbstractDocument)jtc.getDocument();
int outputspot = js.getOutputSpot();
int cp = jtc.getCaretPosition();
String input = js.get_input( cp );
Element e = doc.getParagraphElement( cp );
if( input.trim().equals( "" ) ) return;
PyList history = js.history;
if( history.size() == 0 ) return;
if( which.equals( "Up" ) ){
    
    if( current != null &amp;&amp; input.startsWith( current ) ){
    
        ListIterator li = history.listIterator( spot );
        while( li.hasPrevious() ){
            
            spot = li.previousIndex();
            String previous = (String)li.previous();
            if( previous.equals( input ) ) continue; 
            if( previous.startsWith( current ) ){
                try{
                    doc.remove( outputspot, e.getEndOffset() - outputspot -1 );
                    js.colorize( previous, previous, outputspot, outputspot, outputspot + previous.length() ); 
                }
                catch( BadLocationException ble ){}
                return;                      
            }
        
        }
    
    }
    else{
    
        current = input;
        ListIterator li = history.listIterator( history.size() );
        while( li.hasPrevious() ){
        
            spot = li.previousIndex();
            String previous = (String)li.previous();
            if( previous.equals( input ) ) continue;
            if( previous.startsWith( current ) ){
                
                try{
                    doc.remove( outputspot, e.getEndOffset() - outputspot -1 );
                    js.colorize( previous, previous, outputspot, outputspot, outputspot + previous.length() );
                }
                catch( BadLocationException ble ){ ble.printStackTrace(); }
                return;
            
            }
        }
    }

}
else{
    if( current != null &amp;&amp; input.startsWith( current ) ){
    
        ListIterator li = history.listIterator( spot );
        while( li.hasNext() ){ 
            
            spot = li.nextIndex();
            String next = (String)li.next();
            if( next.equals( input ) ) continue;
            if( next.startsWith( current ) ){
                try{
                    doc.remove( outputspot, e.getEndOffset() - outputspot -1 );
                    js.colorize( next, next, outputspot, outputspot, outputspot + next.length() ); 
                }
                catch( BadLocationException ble ){}
                return;                      
            }
        
        }
    
    }
    else{
    
        current = input;
        ListIterator li = history.listIterator();
        while( li.hasNext() ){
        
            spot = li.nextIndex();
            String next = (String)li.next();
            if( next.equals( input ) ) continue; 
            if( next.startsWith( current ) ){
                
                try{
                    doc.remove( outputspot, e.getEndOffset() - outputspot -1 );
                    js.colorize( next, next, outputspot, outputspot, outputspot + next.length() );
                }
                catch( BadLocationException ble ){ ble.printStackTrace(); }
                return;
            
            }
        }
    }

}</t>
<t tx="ekr.20070127142814.306">@language java
package org.leo.shell.actions;

import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;
import java.util.*;
import org.python.core.*;
import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;

public class ReverseIncrementalSearch extends AbstractAction implements KeyListener, Documentation{


    JythonShell js;
    String prelude;
    String prompt;
    boolean searching;
    StringBuilder typed;
    String complete;
    int lastindex;
    public ReverseIncrementalSearch( JythonShell js ){
    
        this.js = js;
        js.getShellComponent().addKeyListener( this );
        prelude = "(reverse-i-search)";
        prompt = "%1$s'%2$s':%3$s";
        searching = false;
        typed = null;
        complete = null;
        lastindex = -1;
    }
    
    public String getDocumentation(){
    
        return "Opens a search prompt. Begin typing and the system searches your history for lines that contain what you ve typed so far, completing as much as it can.\n";
       
    }
    
    
    public void keyPressed( KeyEvent event ){
        
        String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
        if( searching ){
            
            JTextComponent jtc = js.getShellComponent();
            AbstractDocument doc = (AbstractDocument)jtc.getDocument();
            Element pe = doc.getParagraphElement( jtc.getCaretPosition() );
            char c = event.getKeyChar();
            String ktext = KeyEvent.getKeyText( event.getKeyCode() );
            if( opmodifiers.startsWith( "Ctrl" ) || opmodifiers.startsWith( "Alt" ) ) return;
            if( ktext.equals( "Shift" ) ) return;
            if( event.isActionKey() ) return;
            event.consume();
            if( ( Character.isWhitespace( c ) || Character.isLetterOrDigit( c ) ) &amp;&amp; c != '\n' ){
                    typed.append( c );
                    try{
                        doc.remove( pe.getStartOffset(), (pe.getEndOffset() -1) - pe.getStartOffset() );
                        String tstring = typed.toString();
                        complete = "";
                        if( !tstring.trim().equals( "" ) ){
                        
                            PyList history = js.history;
                            ListIterator li = history.listIterator( lastindex );
                            while( li.hasPrevious() ){
                                
                                int pi = li.previousIndex();
                                String previous = (String)li.previous();
                                if( previous.indexOf( tstring ) != -1 &amp;&amp; !previous.equals( complete ) ){
                                    
                                    lastindex = pi;
                                    complete = previous;
                                    break;
                                
                                }
                                    
                            
                            }
                        
                        
                        }
                        String iline = String.format( prompt, prelude, tstring, complete );
                        doc.insertString( pe.getStartOffset(), iline, null );
                        jtc.setCaretPosition( pe.getStartOffset() + prelude.length() + typed.length() + 1 );          
                    }
                    catch( BadLocationException ble ){}
            
        
                }
                else{
                
                    try{
                        doc.remove( pe.getStartOffset(), (pe.getEndOffset() -1) - pe.getStartOffset() );
                        js.insertPrompt( false );
                        int outputspot = js.getOutputSpot();
                        js.colorize( complete, complete, outputspot, outputspot, outputspot + complete.length() );
                        searching = false;
                    
                    }
                    catch( BadLocationException ble ){}
                
                
                
                }
            }

    }
    
    
    public void keyReleased( KeyEvent event){

        String ktext = KeyEvent.getKeyText( event.getKeyCode() );
        String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
        if( opmodifiers.startsWith( "Ctrl" ) || opmodifiers.startsWith( "Alt" ) ) return;
        if( ktext.equals( "Shift" ) ) return;
        if( searching ) event.consume();
    
    }
    
    public void keyTyped( KeyEvent event ){

        String opmodifiers = event.getKeyModifiersText( event.getModifiers() );
        String ktext = KeyEvent.getKeyText( event.getKeyCode() );
        if( opmodifiers.startsWith( "Ctrl" ) || opmodifiers.startsWith( "Alt" ) ) return;
        if( ktext.equals( "Shift" ) ) return;          
        if( searching ) event.consume();
    
    }

    public void actionPerformed( ActionEvent ae ){
        
        if( searching ){
          
                PyList history = js.history;
                ListIterator li = history.listIterator( lastindex  );
                String lastcomplete = complete;
                String tstring = typed.toString();
                while( li.hasPrevious() ){
                    
                    int pi = li.previousIndex();
                    String previous = (String)li.previous();
                    if( previous.indexOf( tstring ) != -1  &amp;&amp; !previous.equals( complete )){
                        
                        lastindex = pi;
                        complete = previous;
                        break;
                                
                    }
                                    
                            
                }
            if( !lastcomplete.equals( complete ) ){
                try{
                        JTextComponent jtc = js.getShellComponent();
                        AbstractDocument doc = (AbstractDocument)jtc.getDocument();
                        Element pe = doc.getParagraphElement( jtc.getCaretPosition() );
                        String iline = String.format( prompt, prelude, tstring, complete );
                        doc.remove( pe.getStartOffset(), (pe.getEndOffset() -1 ) - pe.getStartOffset() );
                        doc.insertString( pe.getStartOffset(), iline, null );
                        jtc.setCaretPosition( pe.getStartOffset() + prelude.length() + typed.length() + 1 ); 
                                 
                }
                catch( BadLocationException ble ){}            
            
            
            }
            return;
                   
        }
        searching = true;
        typed = new StringBuilder();
        JTextComponent jtc = js.getShellComponent();
        AbstractDocument doc = (AbstractDocument)jtc.getDocument();
        Element pe = doc.getParagraphElement( jtc.getCaretPosition() );
        String line = js.get_input( jtc.getCaretPosition() );
        typed.append( line );
        try{
            doc.remove( pe.getStartOffset(), (pe.getEndOffset() -1) - pe.getStartOffset() );
            String tstring = typed.toString();
            complete = "";
            PyList history = js.history;
            lastindex = history.size();
            if( !tstring.trim().equals( "" ) ){

                ListIterator li = history.listIterator( history.size() );
                while( li.hasPrevious() ){
                    
                    int pi = li.previousIndex();       
                    String previous = (String)li.previous();
                    if( previous.indexOf( tstring ) != -1  &amp;&amp; !previous.equals( complete )){
                        
                        lastindex = pi;      
                        complete = previous;
                        break;
                                
                    }
                                    
                            
                }
                        
                        
            }
            String iline = String.format( prompt, prelude, tstring, complete );
            doc.insertString( pe.getStartOffset(), iline, null );
            jtc.setCaretPosition( pe.getStartOffset() + prelude.length() + typed.length() + 1 );
        }
        catch(BadLocationException ble ){
            ble.printStackTrace();
            searching = false;
        }
    }


}
</t>
<t tx="ekr.20070127142814.307">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent; 


public class SupressOutput extends AbstractAction implements Documentation{


    JythonShell js;
    public SupressOutput( JythonShell js ){
    
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This suppresses the current output for the duration of the execution statement.\n" +
               "This is useful in cases where there is a tremendous amout of output occuring and the user decides that he no longer wishes to see all of it.\n" +
               "For gigantic outputs, this can be a shell saver.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        js.supressOutput();
    
    }

}</t>
<t tx="ekr.20070127142814.308">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent; 


public class TripleQuotes extends AbstractAction implements Documentation{


    JythonShell js;
    public TripleQuotes( JythonShell js ){
    
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This places triple quotes around the text on the current line.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        JTextComponent jtc = js.getShellComponent();
        Document doc = jtc.getDocument();
        
        int outputspot = js.getOutputSpot();
        Element e = Utilities.getParagraphElement( jtc, outputspot );
        int end = e.getEndOffset();
        try{
    
            int wordstart = Utilities.getNextWord( jtc, outputspot -1 );
            if( wordstart &gt;= end ) return;
            doc.insertString( wordstart, "'''", null );
            doc.insertString( e.getEndOffset() -1 , "'''", null ); 
            //final String line, final String insert, final int insertspot, final int start, final int end 
            js.colorize( js.get_input( outputspot ), "", outputspot, outputspot, e.getEndOffset() );
    }
    catch( BadLocationException ble ){}


    
    }

}</t>
<t tx="ekr.20070127142814.309">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.ActionEvent; 


public class CloseUtilityBoxes extends AbstractAction implements Documentation{


    JythonShell js;
    public CloseUtilityBoxes( JythonShell js ){
    
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This closes utility boxes like the autocompleter or calltips help.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        js.closeUtilityBoxes();

    
    }

}</t>
<t tx="ekr.20070127142814.310">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.AbstractAction;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Clipboard;
import java.awt.Toolkit;
import java.util.List;
import java.util.Arrays;
import java.awt.event.ActionEvent; 


public class PasteAsScript extends AbstractAction implements Documentation{


    JythonShell js;
    public PasteAsScript( JythonShell js ){
        
        super( "Paste As Script" );
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This pastes the clipboard's contents as a script into the shell.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        try{
                
            final Clipboard system = Toolkit.getDefaultToolkit().getSystemClipboard();
            final String data = (String)system.getData( DataFlavor.stringFlavor );
            final String[] lines = data.split( "\n" );
            final java.util.List&lt;String&gt; script = Arrays.asList( lines );
            js.processScript( script );
                    
        }
        catch( final Exception x ){}

    
    }

}</t>
<t tx="ekr.20070127142814.311">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent; 


public class Paste extends AbstractAction implements Documentation{


    JythonShell js;
    public Paste( JythonShell js ){
        
        super( "Paste" );
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This pastes the clipboard's contents into the shell.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        js.getShellComponent().paste();
    
    }

}</t>
<t tx="ekr.20070127142814.312">@language java
package org.leo.shell.actions;

import org.leo.shell.JythonShell;
import org.leo.shell.Documentation;
import javax.swing.AbstractAction;
import java.awt.event.ActionEvent; 


public class Copy extends AbstractAction implements Documentation{


    JythonShell js;
    public Copy( JythonShell js ){
        
        super( "Copy" );
        this.js = js;
    
    }

    public String getDocumentation(){
    
        return "This copies the shell's current selection.\n";
    
    }

    public void actionPerformed( ActionEvent ae ){

        js.getShellComponent().copy();
    
    }

}</t>
<t tx="ekr.20070127142814.313">@path org/leo/shell/util
</t>
<t tx="ekr.20070127142814.314">@language java
package org.leo.shell.util;

import org.leo.shell.JythonShell; 
import javax.swing.*;
import javax.swing.text.*;


public class StringInserter implements Runnable{
    
        String sb;
        JTextPane jtp;
        SimpleAttributeSet sas;
        JythonShell js;
        
        public StringInserter( String sb, JTextPane jtp, SimpleAttributeSet sas, JythonShell js ){
        
            this.sb = sb;
            this.jtp = jtp;
            this.sas = sas;
            this.js = js;
        
        }
    
        public void run(){
        
            try{
                int spot = jtp.getCaretPosition();
                DefaultStyledDocument doc = (DefaultStyledDocument)jtp.getDocument();
                doc.insertString( spot, sb, sas );
                //js.outputspot = spot + sb.length();
                js.setOutputSpot( spot + sb.length() );
                doc.setParagraphAttributes( spot , 0, sas, false );
                
            }
            catch( BadLocationException ble ){}
        
        
        
        }
        
    
    }</t>
<t tx="ekr.20070127142814.315">@language java
package org.leo.shell.util;

import org.leo.shell.JythonShell;

public class InsertPrompt implements Runnable{

    JythonShell js;
    boolean more;
    public InsertPrompt( JythonShell js, boolean more ){
    
        this.js = js;
        this.more = more;
    
    }

    public void run(){ js.insertPrompt( more ); }



}</t>
<t tx="ekr.20070127142814.316">@language java
package org.leo.shell.util;

import org.leo.shell.JythonShell;
import javax.swing.JTextPane;
import javax.swing.text.*;

public class AddLine implements Runnable{

    JythonShell js;
    String line;
    boolean colorize;
    public AddLine( JythonShell js, String line, boolean colorize ){
    
        this.js = js;
        this.line = line;
        this.colorize = colorize;
    }

    public void run(){
    
        JTextComponent jtc = js.getShellComponent();
        Document doc = jtc.getDocument();
        try{

            int outputspot = js.getOutputSpot();
            doc.insertString( outputspot, line, null );
            if( colorize ){
                
                Element e = Utilities.getParagraphElement( jtc, outputspot );
                js.colorize( line, "", outputspot, outputspot, e.getEndOffset() );
            
            }
        }
        catch( BadLocationException ble ){}
        
    }



}</t>
<t tx="ekr.20070127142814.317">@language java
package org.leo.shell.util;

import org.leo.shell.JythonShell;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.*;

public class ScriptExecutor implements Callable&lt;Boolean&gt;{

    List&lt;String&gt; script;
    JythonShell js;
    public ScriptExecutor( JythonShell js, List&lt;String&gt; script ){
    
        this.script = script;
        this.js = js;
    
    } 
    
    public FutureTask&lt;Boolean&gt; submit(){
        //this method should be called to submit the ScriptExecutor, it ensures that it is on the right queue
        //no need to deadlock if accidentaly misused...
        FutureTask&lt;Boolean&gt; ft = new FutureTask&lt;Boolean&gt;( this );
        js.execute2( ft );
        return ft;
    
    }
    
    public Boolean call(){
    
        js.setAutoindent( false );
        try{
            for( String s: script ){
                
                String s2 = s;
                if( s2.startsWith( "&gt;&gt;&gt;" ) || s2.startsWith( "..." ) )
                    s2 = s2.substring( 3 );        
                js.addLineToExecute( s2 );
                if( !s.endsWith( "\n" ) ) s += '\n';
                AddLine al = new AddLine( js, s, true );
                SwingUtilities.invokeAndWait( al );
                FutureTask&lt;Boolean&gt; rv = new FutureTask&lt;Boolean&gt;( js );
                js.execute1( rv );
                final boolean more = rv.get();
                InsertPrompt ip = new InsertPrompt( js, more );
                SwingUtilities.invokeAndWait( ip );                    
            }
        }
        catch( Exception x ){ return false;}               
        finally{
            js.setAutoindent( true );
        }
        return true;
    }
    
}
</t>
<t tx="ekr.20070127142814.318">@language java
package org.leo.shell.util;

import javax.swing.*;
import javax.swing.text.*;

public class JSUtilities{


    @others





}</t>
<t tx="ekr.20070127142814.319">static public String getWordStart( JTextPane _jtp ){

    int cp = _jtp.getCaretPosition();
    DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
    Element p = doc.getParagraphElement( cp );
    try{
        String line = doc.getText( p.getStartOffset(), cp - p.getStartOffset() );
        StringBuilder sb = new StringBuilder( line );
        sb.reverse();
        StringBuilder word = new StringBuilder();
        for( final char c: sb.toString().toCharArray() ){
    
            if( !Character.isLetterOrDigit( c ) &amp;&amp; c != '_' ) break;
            word.append( c );
    
        }    
        word.reverse();
        return word.toString();
    }
    catch( BadLocationException ble ){}
    return "";
    
}

static public int getWordStartIndex( JTextPane _jtp ){

    int cp = _jtp.getCaretPosition();
    DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
    Element p = doc.getParagraphElement( cp );
    try{
        String line = doc.getText( p.getStartOffset(), cp - p.getStartOffset() );
        StringBuilder sb = new StringBuilder( line );
        sb.reverse();
        for( final char c: sb.toString().toCharArray() ){
    
            if( !Character.isLetterOrDigit( c ) &amp;&amp; c != '_' ) break;
            cp--;
    
        }    
        return cp;
    }
    catch( BadLocationException ble ){}
    return -1;
    
}</t>
<t tx="ekr.20070127142814.320">@language java
package org.leo.shell.util;
import java.util.*;

public class CommandLineParser{


    public static List&lt;String&gt; parseCommandLine( String line ){
    
        List&lt;String&gt; args = new LinkedList&lt;String&gt;();
        boolean stringing = false;
        char schar = '\'';
        StringBuilder sb = new StringBuilder();
        for( char c: line.toCharArray() ){
            if( stringing ){
            
                sb.append( c );
                if( c == schar ){
                
                    stringing = false;
                    if( sb.length() &gt; 2 ){
                    
                        sb.deleteCharAt( 0 );
                        sb.deleteCharAt( sb.length() -1 );
                    
                    }
                    args.add( sb.toString() );                
                    sb = new StringBuilder();
                    
                } 
                continue;
            
            }
            if( Character.isWhitespace( c ) ){
            
                if( sb.length() != 0 ){
                
                    args.add( sb.toString() );
                    sb = new StringBuilder();
                    continue;
                
                }
            
            }
            sb.append( c );
            if( c == '"' || c == '\'' ){
             schar = c;
             stringing = true;
            }
        }
        if( sb.length() &gt; 0 ) args.add( sb.toString() );    
        return args;
    
    
    }



}</t>
<t tx="ekr.20070127142814.321">@language java
package org.leo.shell.util;

import java.io.File;
import java.util.regex.Pattern;

public class CommandFinder{


    public static String findCommand( String command, File cwd ){
        
        
        File firsttest = new File( cwd, command );
        if( firsttest.exists() &amp;&amp; firsttest.isFile() ) return firsttest.getAbsolutePath();
        File secondtest = new File( command );
        if( secondtest.exists() &amp;&amp; secondtest.isFile() ) return secondtest.getAbsolutePath();
        String path = System.getenv( "PATH" );
        String[] paths = path.split( Pattern.quote( System.getProperty( "path.separator" ) ) );
        String cmdpath = null;
        breakhere:
        for( String apath: paths ){
        
            File f = new File( apath, command );
            if( f.exists() &amp;&amp; f.isFile()){
            
                cmdpath = f.getAbsolutePath();
                break breakhere;
            
            }       
        
        }    
        
        return cmdpath;
    
    }



}</t>
<t tx="ekr.20070127142814.322">@language java
package org.leo.shell.util;

import javax.swing.SwingUtilities;
import java.util.LinkedList;
import java.util.List;
import java.io.*;
import java.util.regex.Pattern;
import org.leo.shell.JythonShell;
import org.leo.shell.util.InsertPrompt;
import org.python.core.PyObject;


public class ProcessExecutor implements Runnable{


    JythonShell js;
    String command;
    File wdirectory;
    public ProcessExecutor( JythonShell js, String command, File wdirectory ){
    
        this.js = js;
        this.command = command;
        this.wdirectory = wdirectory;
    }
    

    public void run(){
        
        command = js.checkForJythonReference( command );
        List&lt;String&gt; cllist = CommandLineParser.parseCommandLine( command );
        String[] pieces = cllist.toArray( new String[]{} );
        String cmdpath = CommandFinder.findCommand( pieces[ 0 ], js.getCurrentWorkingDirectory() );
        OutputStream os = js.getStandardOut();
        if( cmdpath != null ){
            
            LinkedList&lt;String&gt; cmd = new LinkedList&lt;String&gt;();
            cmd.add( cmdpath );
            if( pieces.length &gt; 1 )
                for( int i = 1; i &lt; pieces.length; i++ ) cmd.add( pieces[ i ] );
            
            ProcessBuilder pb = new ProcessBuilder( cmd );
            pb.redirectErrorStream( true );
            pb.directory( wdirectory );
            try{
                Process process = pb.start();
                InputStream is = process.getInputStream();
                BufferedReader br = new BufferedReader( new InputStreamReader( is ) );
                String output = null;
                while( ( output = br.readLine() ) != null ){
                     os.write( output.getBytes() );
                     os.write( "\n".getBytes() );
                }
            }
            catch( IOException io ){ io.printStackTrace();}
        
        }
        else{
        
            try{
                String message = String.format( "Can't find command '%1$s' on PATH, no execution.\n", pieces[ 0 ] );
                os.write( message.getBytes() );
                
            }
            catch( IOException io ){}
        
        
        }
    
        InsertPrompt ip = new InsertPrompt( js, false );
        SwingUtilities.invokeLater( ip );
    
    }




}</t>
<t tx="ekr.20070127142814.323">@language java
package org.leo.shell.util; 

public final class Abbreviation{

    public final String start;
    public final String current;
    public final int spos;

    public Abbreviation( final String start, final String current, final int spos ){
    
        this.start = start;
        this.current = current;
        this.spos = spos;
    
    
    }



}</t>
<t tx="ekr.20070127142814.324">@path org/leo/shell/widget</t>
<t tx="ekr.20070127142814.325">@language java
package org.leo.shell.widget;

import org.leo.shell.JythonShell;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;

public class CopyPaste extends MouseAdapter{

    final JTextPane _jtp;
    final JPopupMenu _jpm;
    final JythonShell _js; 
    public CopyPaste( final JTextPane jtp, final JythonShell js ){
        super();
        _jtp = jtp;
        _js = js;
        _jpm = createPopup();
        _jtp.addMouseListener( this );
    
    }

    public final JPopupMenu createPopup(){
    
        final JPopupMenu jpm = new JPopupMenu();
        final AbstractAction copy = new AbstractAction( "Copy" ){
        
            public final void actionPerformed( final ActionEvent ae ){
            
                CopyPaste.this._jtp.copy();
            
            }
        
        
        };
        jpm.add( copy );
        final AbstractAction paste = new AbstractAction( "Paste" ){
        
            public final void actionPerformed( final ActionEvent ae ){
            
                CopyPaste.this._jtp.paste();
            
            }
        
        
        };      
        jpm.add( paste );
        
        final Action pasteasscript = _js.getPasteAsScript();
        jpm.add( pasteasscript );
        final AbstractAction select = new AbstractAction( "Select All" ){
        
            public final void actionPerformed( final ActionEvent ae ){
            
                CopyPaste.this._jtp.selectAll();
            
            }
        
        
        };      
        jpm.add( select );        
        return jpm;
    
    
    }

    public final void mousePressed( final MouseEvent me ){
    
        if( me.getButton() == me.BUTTON3 ){
        
            _jpm.show( me.getComponent(), me.getX(), me.getY() );
        
        
        }
    
    
    
    }


}
</t>
<t tx="ekr.20070127142814.326">@language java
package org.leo.shell.widget;

import java.awt.event.*;
import javax.swing.AbstractAction;
import javax.swing.JMenu;
import javax.swing.JPopupMenu;
import javax.swing.text.JTextComponent;

public class CutCopyPaste extends MouseAdapter{

    final JTextComponent jtc;
    public CutCopyPaste( JTextComponent jtc ){
    
        this.jtc = jtc;
        jtc.addMouseListener( this );
    
    
    }

    public void mousePressed( MouseEvent me ){
    
    
        if( me.getButton() == me.BUTTON3 ){
        
            JMenu jm = new JMenu();
            AbstractAction cut = new AbstractAction( "Cut" ){
            
                public void actionPerformed( ActionEvent ae ){
                
                    jtc.cut();
                
                }
            
            };
            AbstractAction copy = new AbstractAction( "Copy" ){
            
                public void actionPerformed( ActionEvent ae ){
                
                    jtc.copy();
                
                }
            
            
            };
            AbstractAction paste = new AbstractAction( "Paste" ){
            
                public void actionPerformed( ActionEvent ae ){
                    
                    jtc.paste();
                
                }
            
            
            };
            jm.add( cut );
            jm.add( copy );
            jm.add( paste );
            JPopupMenu jpm = jm.getPopupMenu();
            jpm.show( jtc, me.getX(), me.getY() );
        
        }
    
    
    
    }



}
</t>
<t tx="ekr.20070127142814.327">@language java
package org.leo.shell.widget;  

import org.leo.shell.JythonShell;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import javax.swing.*;

public class Pager{

    JTextPane jtp;
    JScrollPane jsp;
    JythonShell js;
    
    public Pager( final JythonShell js, Color foreground, Color background, Font f ){
  
        this.js = js;
        jtp = new JTextPane();
        jtp.setForeground( foreground );
        jtp.setBackground( background );
        jtp.setCaretColor( foreground );
        jtp.setFont( f );
        jsp = new JScrollPane( jtp );
        MessageBorder mb = new MessageBorder( "Control-q to return to the Shell." );
        jsp.setViewportBorder( mb );
        Action a = new AbstractAction(){
        
            public void actionPerformed( ActionEvent ae ){ 
                js.moveWidgetToFront( "Shell" );
                js.getShellComponent().requestFocus();
            }
        
        };
        KeyStroke ks = KeyStroke.getKeyStroke( "control Q" );
        InputMap im = jtp.getInputMap();
        ActionMap am = jtp.getActionMap();
        im.put( ks, "cq" );
        am.put( "cq", a );
        
    }
    
    public void setText( String s ){
    
        jtp.setText( s );
        jtp.setCaretPosition( 0 );
    
    }
    
    public void requestFocus(){ jtp.requestFocus(); }    

    public JComponent getBaseWidget(){ return jsp; }
        
}
</t>
<t tx="ekr.20070127142814.328">@language java;
package org.leo.shell.widget;

import java.awt.Dimension;
import javax.swing.*;
import javax.swing.text.*;


public class ZoneViewEditorKit extends StyledEditorKit{

    ViewFactory vf;
    
    public ViewFactory getViewFactory(){
        
        if( vf == null ) vf = new ZoneViewFactory();
        return vf;

    }


    public static class ZoneViewFactory implements ViewFactory{


        public View create( Element elem ){
    
            String kind = elem.getName();
	        if (kind != null) {
		    if (kind.equals(AbstractDocument.ContentElementName)) {
                    return new LabelView(elem);
		    } else if (kind.equals(AbstractDocument.ParagraphElementName)) {
		        return new ParagraphView(elem);
		    } else if (kind.equals(AbstractDocument.SectionElementName)) {
		        //return new BoxView(elem, View.Y_AXIS);
                ZoneView zv = new ZoneView( elem, View.Y_AXIS );
                return zv;
		    } else if (kind.equals(StyleConstants.ComponentElementName)) {
		        return new ComponentView(elem);
		    } else if (kind.equals(StyleConstants.IconElementName)) {
		        return new IconView(elem);
		}
	    }
	
	    // default to text display
        return new LabelView(elem);    
    
  
    }


}

    public static void main( String[] args ){
    
        Runnable run = new Runnable(){
        
        public void run(){
            JTextPane jtp = new JTextPane();
            jtp.setEditorKit( new ZoneViewEditorKit() );
            JScrollPane jsp = new JScrollPane( jtp );
            JFrame jf = new JFrame();
            jf.add( jsp );
            jf.setSize( new Dimension( 500, 500 ) );
            jf.setVisible( true );
            //jtp.setEditorKit( new ZoneViewEditorKit() );
            }
        };
        SwingUtilities.invokeLater( run );
    
    }

}</t>
<t tx="ekr.20070127142814.329">@language java
package org.leo.shell.widget;

import javax.swing.table.DefaultTableModel;

/* a relatively silly thing to have a class for*/
public class UneditableTableModel extends DefaultTableModel{


    public UneditableTableModel(){
        super();
    
    
    }
    
    public final boolean isCellEditable( final int row, final int column ){
    
        return false;
    
    
    }



}</t>
<t tx="ekr.20070127142814.330">@language java
package org.leo.shell.widget;

import javax.swing.*;
import java.awt.*;

public class ImageJViewport extends JViewport{

    Image image;
    Image last_image;
    AlphaComposite alpha;
    Rectangle lastDimensions;
    
    public ImageJViewport(){
    
       super();
       alpha = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 1.0f );
       image = null;
       last_image = null;
       lastDimensions = new Rectangle( 0, 0, 0, 0 );
       setScrollMode( BLIT_SCROLL_MODE );
           
    }
    
    public void setImage( Image image ){
    
        this.image = image;
    
    }
    
    public void setAlpha( float alpha ){
    
        this.alpha = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, alpha );
    
    }


    public void paintComponent( Graphics g ){
        
        //super.paintComponent( g );
        if( image != null ){
            Graphics2D g2 = (Graphics2D)g;
            Rectangle vrec = getVisibleRect();
            if( !vrec.equals( lastDimensions ) ){
            
                lastDimensions = vrec;
                last_image = image.getScaledInstance( vrec.width, vrec.height, Image.SCALE_REPLICATE );
            
            }
            Composite composite = g2.getComposite();
            g2.setComposite( alpha );
            g2.drawImage( last_image, vrec.x, vrec.y, Color.WHITE, null );
            g2.setComposite( composite );
            return;
        
        }
        super.paintComponent( g );
    
    
    }


}
</t>
<t tx="ekr.20070127142814.331">@language java
package org.leo.shell.widget;

import java.awt.*;
import javax.swing.border.Border;

public class MessageBorder implements Border{

    Insets ins;
    String message;
    public MessageBorder( String message ){
    
        this.message = message;
    
    }    


    public Insets getBorderInsets( Component c ){
    
        if( ins == null ){
            Graphics g = c.getGraphics();
            FontMetrics fm = g.getFontMetrics();
            int height = fm.getHeight();
            g.dispose();
            ins = new Insets( 0, 0, height, 0 ); 
        }
        return ins;
    }
    
    public boolean isBorderOpaque(){ return true; }


    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height){
    
        g.setColor( Color.WHITE );
        g.fillRect( 0, y + height - ins.bottom, width, y + height );
        g.setColor( c.getForeground() );
        FontMetrics fm = g.getFontMetrics();
        g.drawString( message , 0, y + height - fm.getDescent() );
    
    }

}</t>
<t tx="ekr.20070127142814.332">@language java
package org.leo.shell.widget;

import java.awt.*;
import javax.swing.*;
import javax.swing.table.*;
import javax.swing.border.*;
import javax.swing.text.*;
import java.util.Map;
import java.util.Vector;

public class ObjectViewer extends JPanel{ 

    final JTextField clazz;
    final JTextArea doc_string;
    final JTable bases;
    final JTable attributes;
    final JTable methods;
    //final JTable fields;

    public ObjectViewer(){
    
        super();
        //setLayout( new GridLayout( 1, 3 ) );
        setLayout( new BorderLayout() );
        //Box container = Box.createVerticalBox();
        //add( container );
        //setBackground( Color.BLACK );
        //final SpringLayout sl = new SpringLayout();
        //setLayout( sl );
        clazz = new JTextField();
        clazz.setEditable( false );
        titleBorder( "Class:", clazz );
        //JPanel jp1 = new JPanel();
        //jp1.add( clazz );
        add( clazz, BorderLayout.NORTH );
        //sl.putConstraint( sl.NORTH, clazz, 0, sl.NORTH, this );
        //sl.putConstraint( sl.WEST, clazz, 0, sl.WEST, this );
        //sl.putConstraint( sl.EAST, clazz, 0, sl.EAST, this );
        
        JPanel dandb = new JPanel( new GridLayout( 1, 2 ) );
        doc_string = new JTextArea();
        //dandb.add( doc_string );
        doc_string.setEditable( false );
        JScrollPane djsp = new JScrollPane( doc_string );
        dandb.add( djsp );
        titleBorder( "DocString:", djsp );
        bases = new JTable();
        bases.setTableHeader( null );
        JScrollPane bjsp = new JScrollPane( bases );
        titleBorder( "Base Classes:", bjsp );
        dandb.add( bjsp );
        add( dandb, BorderLayout.CENTER );
        //sl.putConstraint( sl.NORTH, djsp ,5, sl.SOUTH, clazz );
        //sl.putConstraint( sl.WEST, djsp , 0, sl.WEST, this );
        //sl.putConstraint( sl.EAST, djsp , 0, sl.EAST, this );
        
        //final JPanel lists = new JPanel( new FlowLayout() );
        final JTabbedPane jtp = new JTabbedPane();
        //lists.setOpaque( false );
        add( jtp, BorderLayout.SOUTH );
        attributes = new JTable();
        Dimension size = jtp.getPreferredSize();
        size.height = attributes.getRowHeight() * 5;
        dandb.setPreferredSize( size );
        //jtp.setPreferredSize( size );
        JScrollPane ajs = new JScrollPane( attributes );
        ajs.setPreferredSize( size );
        jtp.add( "Attributes", ajs );
        //fields = new JTable();
        //JScrollPane fjs = new JScrollPane( fields );
        //fjs.setPreferredSize( size );
        //jtp.add( "Java Fields", fjs );
        methods = new JTable();
        //methods.setAutoResizeMode( methods.AUTO_RESIZE_OFF );
        JScrollPane mjs = new JScrollPane( methods );
        mjs.setPreferredSize( size );
        jtp.add( "Methods/Functions", mjs );
    
    
    }


    @others



}</t>
<t tx="ekr.20070127142814.333">private final void titleBorder( final String title, final JComponent jc ){

    final Border b = jc.getBorder();
    final TitledBorder tb = new TitledBorder( b );
    tb.setTitle( title );
    jc.setBorder( tb );


}</t>
<t tx="ekr.20070127142814.334">public final void setClassName( final String name ){

    clazz.setText( name );


}</t>
<t tx="ekr.20070127142814.335">public final void setBases( final Vector bses ){

    DefaultTableModel dtm = new UneditableTableModel();
    dtm.addColumn( "Bases", bses );
    bases.setModel( dtm );



}</t>
<t tx="ekr.20070127142814.336">public final void setDocString( final String doc ){

    doc_string.setText( doc );
    doc_string.setCaretPosition( 0 );


}</t>
<t tx="ekr.20070127142814.337">public final void setJythonAttributes( final Map&lt; String, Vector&lt;String&gt; &gt; columns ){

    //attributes.setListData( atts );
    DefaultTableModel dtm = new UneditableTableModel( );
    for( String key: columns.keySet() )
        dtm.addColumn( key, columns.get( key ) );
    attributes.setModel( dtm );


}</t>
<t tx="ekr.20070127142814.338">public final void setJavaMethods( final Map&lt; String, Vector&lt;String&gt;&gt; columns ){

    //methods.setListData( meths );
    final DefaultTableModel dtm = new UneditableTableModel();
    for( String key: columns.keySet() )
        dtm.addColumn( key, columns.get( key ) );
    methods.setModel( dtm );
    methods.doLayout();


}</t>
<t tx="ekr.20070127142814.339">public final void setJavaFields( final Map&lt; String, Vector&lt;String&gt;&gt; columns ){

    //fields.setListData( field );
     final DefaultTableModel dtm = new UneditableTableModel();
     for( String key: columns.keySet() )
        dtm.addColumn( key, columns.get( key ) );
     //fields.setModel( dtm );

}</t>
<t tx="ekr.20070127142814.340">@path org/leo/shell/io
</t>
<t tx="ekr.20070127142814.341">@language java
package org.leo.shell.io;

import org.leo.shell.JythonShell; 
import org.leo.shell.util.StringInserter;
import java.awt.EventQueue;
import javax.swing.*;
import javax.swing.text.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;

public class JSOutputStream extends OutputStream{

    JTextPane jtp;
    SimpleAttributeSet sas;
    JythonShell js;
    byte[] bout;
    boolean bonce;
    boolean supress;
	public JSOutputStream( JTextPane jtp, SimpleAttributeSet sas, JythonShell js ){
    
        super();
        this.jtp = jtp;
        this.js = js;
        this.sas = sas;
        bout = new byte[ 2 ];
        supress = false;
    }
    
    public void supress(){ supress = true;}
    public void liberate(){ supress = false;}
    public void close(){};
    public void flush(){};
    public void write( byte[] b ){
        
        if( supress ) return;
        byte[] b2 = new byte[ b.length ];
        System.arraycopy( b, 0, b2, 0, b.length );
        String s = new String( b2 );
        if( EventQueue.isDispatchThread() ){
        
            try{
            
                Document doc = jtp.getDocument();
                doc.insertString( jtp.getCaretPosition(), s, sas );
            
            }
            catch( BadLocationException ble ){}
        
        }
        else{
            StringInserter si = new StringInserter( s, jtp, sas, js );
            try{
                SwingUtilities.invokeAndWait( si );
            }
            catch( InvocationTargetException ite ){}
            catch( InterruptedException ie ){}
        }
    
    
    }
    
    public void write( byte[] b, int start, int length ){
        
        if( supress ) return;
        byte[] b2 = new byte[ length ];
        System.arraycopy( b, start, b2, 0, length );
        String s = new String( b2 );
        if( EventQueue.isDispatchThread() ){
        
            try{
            
                Document doc = jtp.getDocument();
                doc.insertString( jtp.getCaretPosition(), s, sas );
            
            }
            catch( BadLocationException ble ){}
        
        }
        else{
            StringInserter si = new StringInserter( s, jtp, sas, js );
            try{
                SwingUtilities.invokeAndWait( si );
            }
            catch( InvocationTargetException ite ){}
            catch( InterruptedException ie ){}
        }
    
    }
    
    public void write( int b ){
        
        if( supress) return;
        if( bonce ){
        
            bout[ 1 ] = (byte)b;
            if( EventQueue.isDispatchThread() ){
        
                try{
            
                    Document doc = jtp.getDocument();
                    doc.insertString( jtp.getCaretPosition(), new String( bout ), sas );
            
                }
                catch( BadLocationException ble ){}
                bout = new byte[ 2 ];
                bonce = false;
        
            }
            else{
                StringInserter si = new StringInserter( new String( bout ), jtp, sas, js );
                try{
                    SwingUtilities.invokeAndWait( si );           
                }
                catch( InvocationTargetException ite ){}
                catch( InterruptedException ie ){}
                bout = new byte[ 2 ];
                bonce = false;
            }     
        
        }
        else{
        
            bout[ 0 ] = (byte)b;
            bonce = true;
        }
    
    }


}</t>
<t tx="ekr.20070127142814.342">@language java
package org.leo.shell.io;

import org.leo.shell.JythonShell;
import java.io.*;
import org.python.core.*;



public final class PyFile2 extends PyFile{

    final JythonShell js;
    
    public PyFile2( final InputStream is, final String a, final JythonShell js ){
        super( is, a );
        this.js = js;
        
        }
        
        
    public String readline(){
    

          try{

            js.stdinbarrier.await();
            //if( js.stdinbarrier.getNumberWaiting() == 0 )
            //    js.stdinbarrier.reset();
            String s = js.standardin.take();
            js.resettool.countDown();
            return s;
            
          }
          catch( InterruptedException ie ){ ie.printStackTrace();}
          catch(Exception x ){ x.printStackTrace(); }
          
          return null;
    
    
    }





}

</t>
<t tx="ekr.20070127142814.343">@path org/leo/shell/color
</t>
<t tx="ekr.20070127142814.344">@language java
package org.leo.shell.color;

import org.python.core.*;
import org.python.util.*;
import org.python.parser.*;
import java.awt.*;
import java.util.*;
import javax.swing.*;
import javax.swing.text.*;


public class JythonColorizer{

    PythonInterpreter _pi;
    JTextPane _jtp;
    boolean colorizing;
    char char_in_charge = 0; 
    java.util.List&lt;String&gt; conventions; 
    ColorConfiguration colorconfig;
    
    LinkedList&lt;PositionHolder&gt; positions; 
    
    public JythonColorizer( PythonInterpreter _pi, JTextPane _jtp, ColorConfiguration cc ){
    
        this._pi = _pi;
        this._jtp = _jtp;
        colorizing = false;
        conventions = new Vector&lt;String&gt;();
        conventions.add( "self" );
        positions = new LinkedList&lt;PositionHolder&gt;();
        colorconfig = cc;
        
    }



    @others


}

</t>
<t tx="ekr.20070127142814.345">@others</t>
<t tx="ekr.20070127142814.346">public final void colorize( final String line, final String insert, final int insertspot, final int start, final int end ){

    try{

        final char[] data = line.toCharArray();
        int spot = 0;
        final StringBuilder buffer = new StringBuilder();
        final StyledDocument doc = (StyledDocument)_jtp.getDocument();
        int eol = endOfLine();
        doc.insertString( insertspot, insert , null );
        
        
        for( final char c: data ){
    
            if( !Character.isLetter( c ) ){
        
                final String test = buffer.toString();
                boolean local = isLocal( test );
                boolean kword = isKeyword( test );
                boolean builtin = isBuiltin( test );
                boolean convention = isConvention( test );
            
                if( local || kword || builtin||convention ){
            
                    try{
                
                        final SimpleAttributeSet sas = new SimpleAttributeSet();
                        if( local )
                            StyleConstants.setForeground( sas, colorconfig.getLocalColor() );//_local );
                        else if( kword )
                            StyleConstants.setForeground( sas, colorconfig.getKeywordColor() );//_kword );
                        else if( builtin )
                            StyleConstants.setForeground( sas, colorconfig.getBuiltinColor() );//_builtin );
                        else if( convention )
                            StyleConstants.setForeground( sas, colorconfig.getConventionColor() );//_convention );
                        
                        
                        //doc.insertString( start + spot - buffer.length(), buffer.toString(), sas );
                        doc.setCharacterAttributes( start+ spot - buffer.length(), buffer.length(), sas, true );
                        SimpleAttributeSet sas2 = new SimpleAttributeSet();
                        if( !Character.isWhitespace( c ) ){
            
                            //sas2 = new SimpleAttributeSet();
                            StyleConstants.setForeground( sas2, colorconfig.getSyntaxColor() );// _synColor );
                        }
                        doc.setCharacterAttributes( start+ spot , 1, sas2, true );
                        //doc.insertString( start + spot , String.valueOf( c ), sas2 );
                        buffer.delete( 0, buffer.length() );
                        spot++;
                        continue;
                
                    }
                    catch( final Exception x ){
                        x.printStackTrace();
                
                    }
                
            
            
            }
            
            SimpleAttributeSet sas3 = new SimpleAttributeSet();
            //doc.insertString( start + spot - buffer.length(), buffer.toString(), null );
            doc.setCharacterAttributes( start+ spot - buffer.length(), buffer.length(), sas3, true );
            SimpleAttributeSet sas = new SimpleAttributeSet();
            if( !Character.isWhitespace( c ) ){
            
                //sas = new SimpleAttributeSet();
                StyleConstants.setForeground( sas, Color.RED );
            }
            doc.setCharacterAttributes( start+ spot, 1, sas, true );
            //doc.insertString( start + spot, String.valueOf( c ), sas );
            spot++;
            buffer.delete( 0, buffer.length() );
            
            
            //buffer.append( c );
            continue;
        
        
        }

        else buffer.append( c );
        spot++;
    
    }

    if( buffer.length() != 0 ){
        
        final String test = buffer.toString();
        boolean local = isLocal( test );
        boolean kword = isKeyword( test );
        boolean builtin = isBuiltin( test );
        boolean convention = isConvention( test );
        SimpleAttributeSet sas = new SimpleAttributeSet();
        if( local || kword || builtin||convention ){
        
            //sas =  new SimpleAttributeSet();
            if( local )
                StyleConstants.setForeground( sas, colorconfig.getLocalColor() );//_local );
            else if( kword )
                StyleConstants.setForeground( sas, colorconfig.getKeywordColor() );// _kword );
            else if( builtin )
                StyleConstants.setForeground( sas, colorconfig.getBuiltinColor() );//_builtin );
            else if( convention )
                StyleConstants.setForeground( sas, colorconfig.getConventionColor() );// _convention );
        
        
        }
        //doc.insertString( start + ( spot - buffer.length() ), buffer.toString(), sas );
        doc.setCharacterAttributes( start+ ( spot - buffer.length() ), buffer.length(), sas, true );
       } 
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }
    try{
        Document doc = _jtp.getDocument();
        Element e = Utilities.getParagraphElement( _jtp, end );
        findPositions( start, doc.getText( start, e.getEndOffset() - start ) );
        try{
            colorizeStrings( start , e.getEndOffset() );
        }
        catch( Exception x ){ x.printStackTrace(); }
    }
    catch( BadLocationException ble ){}
}


</t>
<t tx="ekr.20070127142814.347">public void findPositions( int spot, String line ){

    DefaultStyledDocument dsd = (DefaultStyledDocument)_jtp.getDocument();
    for( char c: line.toCharArray() ){
    
        if( c == '\'' || c == '"'|| c == '#' ) addPosition( spot, c );
        spot++;

    }


}</t>
<t tx="ekr.20070127142814.348">public void colorizeStrings( int colorizefrom, int colorizeto ){

    SimpleAttributeSet sas = new SimpleAttributeSet();
    StyleConstants.setForeground( sas, colorconfig.getStringColor() );
    SimpleAttributeSet comment = new SimpleAttributeSet();
    StyleConstants.setForeground( comment, Color.RED.brighter() );
    StyleConstants.setItalic( comment, true );
    DefaultStyledDocument doc = (DefaultStyledDocument)_jtp.getDocument();
    Iterator&lt;PositionHolder&gt; pi = positions.iterator();
    while( pi.hasNext() ){
    
        PositionHolder ph = pi.next();
        if( !ph.isValid( doc ) ) pi.remove();
    
    }

    PHComparator phc = new PHComparator();
    Collections.sort( positions, phc );
    Set&lt;PositionHolder&gt; pcs = phc.getPurgeCandidates();
    Map&lt;PositionHolder, Object&gt; seen = new HashMap&lt;PositionHolder, Object&gt;();
    for( PositionHolder ph: pcs ){
        
        if( seen.containsKey( ph ) ){
         positions.remove( ph );
        }
        else seen.put( ph, null );
    
    }
    
    
    boolean colorizing = false;
    PositionHolder phic = null;
    int ignoreto = -1;
    for( PositionHolder pos: positions ){
    
        int spot = pos.p.getOffset();
        if(!colorizing &amp;&amp; ( ignoreto != -1? spot &gt; ignoreto: true) ){
        
            colorizing = true;
            phic = pos;
            if( phic.c.equals( "#" ) ){
            
                int ignorefrom = phic.p.getOffset();
                Element e = doc.getParagraphElement( ignorefrom );
                ignoreto = e.getEndOffset();
                doc.setCharacterAttributes( ignorefrom, ignoreto - ignorefrom, comment, true );
                colorizing = false;
                phic = null;
            
            
            }
            else ignoreto = -1;
            continue;
        
        
        }
        else if( ignoreto != -1 &amp;&amp;  spot &lt; ignoreto ) continue;
        else ignoreto = -1;
        
        if( pos.c.equals( phic.c )) {
        
            int start = phic.p.getOffset();
            int end = pos.p.getOffset();
            if( start &lt; colorizefrom ) start = colorizefrom;
            if( end &gt; colorizeto ) end = colorizeto;
            doc.setCharacterAttributes( start, end + 1 - start , sas, false );  
            colorizing = false;
            phic = null;
        
        
        }
    
    
    }
    if( colorizing ){
    
        int start = phic.p.getOffset();
        int end = doc.getLength();
        if( start &lt; colorizefrom ) start = colorizefrom;
        if( end &gt; colorizeto ) end = colorizeto;
        doc.setCharacterAttributes( start, end - start , sas, false );
    
    
    }

}</t>
<t tx="ekr.20070127142814.349">public final boolean isLocal( final String text ){

    try{
    
        final Object o = _pi.get( text );
        if( o == null ) return false;
        return true;
    
    
    }
    catch( final Exception x ){
        
        x.printStackTrace();
    
    }
    
    return false;





}</t>
<t tx="ekr.20070127142814.350">public final boolean isKeyword( final String kword ){


    final String[] kwrds = PythonGrammarConstants.tokenImage;
    final String kword2 = "\""+kword+"\"";
    for( final String s: kwrds ){
    
        if( s.equals( kword2 ) ) return true;
        
        }
    return false;
    
}

public final boolean isBuiltin( final String kword ){
        
    PySystemState pss = Py.getSystemState();
    PyStringMap psm = (PyStringMap)pss.builtins;
    return psm.has_key( new PyString( kword ) );

}</t>
<t tx="ekr.20070127142814.351">public boolean isConvention( String word ){

    return conventions.contains( word );


}</t>
<t tx="ekr.20070127142814.352">public final int startOfLine(){

    
    try{
        
        Element e = Utilities.getParagraphElement( _jtp, _jtp.getCaretPosition() );
        return e.getStartOffset();
        
    
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }
    
    return 0;

}



public int endOfLine(){

    try{

            
        Element e = Utilities.getParagraphElement( _jtp, _jtp.getCaretPosition() );
        return e.getEndOffset() -1;
    
    }
    catch( final Exception x ){
        x.printStackTrace();
    
    }
    return 0;


}

</t>
<t tx="ekr.20070127142814.353">public void addPosition( int i, char c ){

    Document doc = _jtp.getDocument();
    try{
        Position p = doc.createPosition( i );
        PositionHolder ph = new PositionHolder( p, c );
        if( !positions.contains( ph ) )
            positions.add( ph );
    }
    catch( BadLocationException ble ){}
}</t>
<t tx="ekr.20070127142814.354">public static class PositionHolder{

    
    final Position p;
    final String c;
    public PositionHolder( Position p, char c ){
    
        this.p = p;
        this.c = String.valueOf( c );
    
    }
    
    @Override
    public int hashCode(){
    
        int i = 17;
        i = 37 * i + c.hashCode();
        i = 37 * i + p.getOffset();
        return i;
    
    }
    
    @Override
    public boolean equals( Object o ){
    
        if( o == null ) return false;
        if( !( o instanceof PositionHolder ))  return false;
        
        PositionHolder ph = (PositionHolder)o;
        return c.equals( ph.c ) &amp;&amp; p.getOffset() == ph.p.getOffset();
    
    
    }

    public boolean isValid( Document doc ){
    
        try{
        
            String c2 = doc.getText( p.getOffset(), 1 );
            if( c.equals( c2 ) ) return true;
            else return false;
        
        
        }
        catch( BadLocationException ble ){
        
            return false;
        
        }
    
    
    }


}</t>
<t tx="ekr.20070127142814.355">public static class PHComparator implements Comparator&lt;PositionHolder&gt;{

    Map&lt;PositionHolder, Object&gt; purgecandidates;
    public PHComparator(){
    
        purgecandidates = new IdentityHashMap&lt;PositionHolder, Object &gt;();
    
    }

    public int compare( PositionHolder ph1, PositionHolder ph2 ){
    
        int spot1 = ph1.p.getOffset();
        int spot2 = ph2.p.getOffset();
        if( spot1 &gt; spot2 ) return 1;
        if( spot1 &lt; spot2 ) return -1;
        purgecandidates.put( ph1, null );
        purgecandidates.put( ph2, null );
        return 0;
    
    
    }

    public Set&lt;PositionHolder&gt; getPurgeCandidates(){
    
        return purgecandidates.keySet();
    
    }

    public boolean equals( Object o ){
    
        if( o == null ) return false;
        if( !(o instanceof PHComparator) ) return false;
        return true;
    
    }


}</t>
<t tx="ekr.20070127142814.356">public void clearPositions(){

    positions.clear();

}</t>
<t tx="ekr.20070127142814.357">@language java
package org.leo.shell.color;


public interface ColorConfigurationListener{


    public void colorChanged( ColorEvent ce );



}</t>
<t tx="ekr.20070127142814.358">@language java
package org.leo.shell.color; 

import java.util.EventObject;
import static org.leo.shell.color.ColorConfiguration.ColorConstant;

public class ColorEvent extends EventObject{

    
    ColorConstant constant;
    public ColorEvent( Object source, ColorConstant colorconstant ){
    
        super( source );
        constant = colorconstant;
    
    }

    public ColorConstant getColorConstant(){ return constant;}

}</t>
<t tx="ekr.20070127142814.359">@language java
package org.leo.shell.color;

import java.awt.Color;
import java.util.LinkedList;

public class ColorConfiguration{

    public static enum ColorConstant{
    
        Background, Foreground, Promptone,
        Promptonenumber, Prompttwo, Out, Error,
        Outprompt, Outpromptnumber, Popupbackground,
        Popupdoc, Popupcalltip, Keyword, Local, Builtin,
        Convention, Syntax, String
        
    }

    Color _bg;
    Color _fg;
    Color _p1c;
    Color _p1nc;
    Color _p2c;
    Color _outColor;
    Color _errColor;
    Color _outPrompt;
    Color _outPromptNumber;
    Color _popupbg;
    Color _popupdoc;
    Color _popupct;
    Color _kword;
    Color _local;
    Color _builtin;
    Color _convention;
    Color _synColor;
    Color _stringColor;
    LinkedList&lt;ColorConfigurationListener&gt; listeners;
    
    @others

}</t>
<t tx="ekr.20070127142814.360">public ColorConfiguration(){
    
    //defaults time!!!
    _bg = Color.BLACK;
    _fg = Color.WHITE;
    _p1c = Color.RED;
    _p1nc = Color.PINK;
    _p2c = Color.GREEN;
    _outColor = Color.WHITE;
    _errColor = Color.RED;
    _outPrompt = Color.decode( "#218429" );
    _outPromptNumber = Color.GREEN;
    _kword = Color.decode( "#299C39" );
    _local = Color.ORANGE;
    _builtin = Color.CYAN;
    _convention = Color.decode( "#087B7B" );
    _synColor = Color.RED; 
    _stringColor = Color.YELLOW;
    
    listeners = new LinkedList&lt;ColorConfigurationListener&gt;();
    
}</t>
<t tx="ekr.20070127142814.361">public void registerColorConfigurationListener( ColorConfigurationListener ccl ){

    listeners.add( ccl );


}


public void removeColorConfigurationListener( ColorConfigurationListener ccl ){

    if( listeners.contains( ccl ) )
        listeners.remove( ccl );

}

private void fireColorConfigurationEvent( ColorConstant cc ){

    ColorEvent ce = new ColorEvent( this, cc );
    for( ColorConfigurationListener ccl: listeners )
        ccl.colorChanged( ce );

}</t>
<t tx="ekr.20070127142814.362">public Color getBackgroundColor(){
    
    return _bg;
    
}
    
public void setBackgroundColor( Color bg ){
    
    _bg = bg;
    fireColorConfigurationEvent( ColorConstant.Background );
    
}</t>
<t tx="ekr.20070127142814.363">public Color getForegroundColor(){


    return _fg;


}

public void setForegroundColor( Color fg ){


    _fg = fg;
    fireColorConfigurationEvent( ColorConstant.Foreground );

}</t>
<t tx="ekr.20070127142814.364">public Color getPromptOneColor(){

    return _p1c;


}

public void setPromptOneColor( Color p1c ){

    _p1c = p1c;
    fireColorConfigurationEvent( ColorConstant.Promptone );

}

public Color getPromptOneNumberColor(){


    return _p1nc;

}

public void setPromptOneNumberColor( Color p1nc ){

    _p1nc = p1nc;
    fireColorConfigurationEvent( ColorConstant.Promptonenumber );

}

public Color getPromptTwoColor(){

    return _p2c;

}

public void setPromptTwoColor( Color p2c ){


    _p2c = p2c;
    fireColorConfigurationEvent( ColorConstant.Prompttwo );

}

public Color getOutPromptColor(){

    return _outPrompt;


}

public void setOutPromptColor( Color outPrompt ){


    _outPrompt = outPrompt;
    fireColorConfigurationEvent( ColorConstant.Outprompt );


}

public Color getOutPromptNumberColor(){

    return _outPromptNumber;

}

public void setOutPromptNumberColor( Color outPromptNumberColor ){

    _outPromptNumber = outPromptNumberColor;
    fireColorConfigurationEvent( ColorConstant.Outpromptnumber );


}




</t>
<t tx="ekr.20070127142814.365">public Color getOutColor(){

    return _outColor;

}

public void setOutColor( Color outColor ){

    _outColor = outColor;
    fireColorConfigurationEvent( ColorConstant.Out );

}

public Color getErrColor(){


    return _errColor;

}

public void setErrColor( Color errColor ){

 _errColor = errColor;   
 fireColorConfigurationEvent( ColorConstant.Error );

}
</t>
<t tx="ekr.20070127142814.366">public Color getCalltipBackground(){

    return _popupbg;


}

public void setCalltipBackground( Color popupbg ){

    _popupbg = popupbg;
    fireColorConfigurationEvent( ColorConstant.Popupbackground );

}

public Color getCalltipDocColor(){

    return _popupdoc;

}

public void setCalltipDocColor( Color popupdoc ){

    _popupdoc = popupdoc;
    fireColorConfigurationEvent( ColorConstant.Popupdoc );

}

public Color getCalltipColor(){

    return _popupct;

}


public void setCalltipColor( Color popupct ){


    _popupct = popupct;
    fireColorConfigurationEvent( ColorConstant.Popupcalltip );

}</t>
<t tx="ekr.20070127142814.367">public Color getKeywordColor(){

    return _kword;

}

public void setKeywordColor( Color kword ){

    _kword = kword;
    fireColorConfigurationEvent( ColorConstant.Keyword );

}</t>
<t tx="ekr.20070127142814.368">public Color getLocalColor(){

    return _local;

}

public void setLocalColor( Color local ){

    _local = local;
    fireColorConfigurationEvent( ColorConstant.Local );

}</t>
<t tx="ekr.20070127142814.369">public Color getBuiltinColor(){

    return _builtin;

}

public void setBuiltinColor( Color builtin ){

    _builtin = builtin;
    fireColorConfigurationEvent( ColorConstant.Builtin );

}</t>
<t tx="ekr.20070127142814.370">public Color getConventionColor(){

    return _convention;

}

public void setConventionColor( Color convention ){

    _convention = convention;
    fireColorConfigurationEvent( ColorConstant.Convention );

}</t>
<t tx="ekr.20070127142814.371">public Color getSyntaxColor(){

    return _synColor;

}

public void setSyntaxColor( Color syntax ){

    _synColor = syntax;
    fireColorConfigurationEvent( ColorConstant.Syntax );

}</t>
<t tx="ekr.20070127142814.372">public Color getStringColor(){

    return _stringColor;

}

public void setStringColor( Color string ){

    _stringColor = string;
    fireColorConfigurationEvent( ColorConstant.String );

}</t>
<t tx="ekr.20070127142814.373">@path org/leo/shell/alias
</t>
<t tx="ekr.20070127142814.374">@language java
package org.leo.shell.alias;

import org.leo.shell.JythonShell;
import org.python.core.*;
import java.io.*;
import java.util.*;

public class Alias{

    String path;
    ProcessBuilder pb;
    JythonShell js;
    String name;
    String aliasname;
    public Alias( String aliasname, String commandpath, JythonShell js ){
        
        this.aliasname = aliasname;
        path = commandpath;
        pb = new ProcessBuilder();
        this.js = js;
        name = null;
    }
    
    public String getAliasName(){
    
        return aliasname;
    
    }
    
    public String getName(){
    
        if( name == null ){
            File f = new File( path );
            name = f.getName();
        }
        return name;
    }

    public Object __call__( PyObject ... args ){
    
        OutputStream stdout = js.getStandardOut();
        LinkedList&lt;String&gt; execute = new LinkedList&lt;String&gt;();
        execute.add( getName() );
        for( PyObject po: args ){
            String arg = po.toString();
            if( arg.equals( "" ) ) continue;
            execute.add( arg );
        }
        pb = pb.command( execute );
        try{
            Process p = pb.start();
            BufferedReader br = new BufferedReader( new InputStreamReader( p.getInputStream() ) );
            while( true ){
            
                String output = br.readLine();
                if( output == null ) break;
                stdout.write( output.getBytes() );
                stdout.write( "\n".getBytes() );
           
            }
        }
        catch( IOException io ){}
        catch( Exception x ){}
        return null;
    }

} 
</t>
<t tx="ekr.20070127142814.375">@language java
package org.leo.shell.alias;

import org.leo.shell.LineListener;
import org.leo.shell.JythonShell;
import org.python.core.*;
import java.util.Map;
import java.util.regex.*;

public class AliasConverter implements LineListener{

    Map&lt;String,Alias&gt; aliasmap;
    Matcher match;
    JythonShell js;
    public AliasConverter( JythonShell js, Map&lt;String,Alias&gt; aliasmap ){
    
        this.aliasmap = aliasmap;
        match = Pattern.compile( "\\w+" ).matcher( "" );
        this.js = js;
        
    }
    
    public String lineToExecute( String line ){
        
    
        if( js.isMagicCommand( line ) ) return line;
        match.reset( line );
        if(!match.find() ) return line;
        int start = match.start();
        int end = match.end();
        String piece = line.substring( start, end );
        if( js.getPyObject( new String[]{ piece } ) != null ) return line;
        boolean ok = true;
        PySystemState pss = Py.getSystemState();
        PyStringMap psm = (PyStringMap)pss.builtins;
        if( js._pi.get( piece ) != null ) ok = false;
        else if( psm.has_key( new PyString( piece ) ) ) ok = false;
        
        if( aliasmap.containsKey( piece ) &amp;&amp; ok ){
        
            String beginstring = line.substring( 0, start );
            String endpiece = line.substring( end );
            String[] pieces = endpiece.trim().split( "\\s+" );
            StringBuilder sb = new StringBuilder();
            for( String s: pieces ){
            
                if( ( s.startsWith( "$" ) &amp;&amp; s.length() &gt; 1 ) &amp;&amp; ! s.startsWith( "$$" )) sb.append( s.substring( 1 ) ).append( ',' );
                else if( s.startsWith( "$$" ) ){
                
                    String s2 = s.replaceFirst( "\\$\\$", "" );
                    String senv = System.getenv( s2 );
                    sb.append( "'" ).append( senv ).append( "'" ).append( ',' );
                
                }
                else
                    sb.append( '"' ).append( s ).append( '"' ).append( ',' );
            
            
            }
            if( sb.charAt( sb.length() -1 ) == ',' ) sb.deleteCharAt( sb.length() -1 );
            line = String.format( "%1$s__aliasmap[ '%2$s' ]( %3$s )", beginstring, piece, sb.toString() );
        
        }
        return line;
        
        
    }

}
</t>
<t tx="ekr.20070127142814.377">@language java
package jconstants;

public enum AtFileConstants{

noDirective,
allDirective,
docDirective,
atDirective,
codeDirective,
cDirective,
othersDirective,
miscDirective,
rawDirective,    
endRawDirective,    
noSentinel,
endAt,
endBody,   
endDoc,
endLeo,
endNode,
endOthers,
startAt,
startBody,
startDoc,
startLeo,
startNode,
startOthers,
startComment,
startDelims,
startDirective,
startRef,
startVerbatim,
startVerbatimAfterRef,
endAll,
endMiddle,
startAll,
startMiddle,
startAfterRef,
startClone,
startNl,
startNonl
};</t>
<t tx="ekr.20070127142814.378">&lt;&lt;imports&gt;&gt;
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo ):
        '''c -&gt; a commander
           umenu -&gt; a JMenuItem that is the 'undo' action
           rmenu -&gt; a JMenuItem that is the 'redo' action
           gtnu -&gt; a JMenuItem that is the 'goto next undo' action
           gtnr -&gt; a JMenuItem that is the 'goto next redo' action
           vunstack -&gt; a JMenuItem that is the 'visualise undo stack' action
           clearundo -&gt; a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        wm1 = WeakMethod( self, "serializeForLeoFile" ); wm2 = WeakMethod( self, "unserializeFromLeoFile" )
        wm3 = WeakMethod( self, "checkSumViolation" )
        leoPlugins.registerHandler( "write-leo-file-data", wm1 )
        leoPlugins.registerHandler( "read-leo-file-data", wm2 )
        leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
        
    
    def setNode( self, p ):
        
        #print "SETTING NODE!!! %s" % t
        #print "FILEINDEX %s" % t.fileIndex
        #java.lang.Thread.dumpStack()
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            #print "CONTAINTS %s" % t
            ua = self.undoers[ v ]
            print "--!!!!!!-- %s" % v
            print ua.__class__
            if ua.__class__ == leoSwingUndo.UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                print "UNPICKLING!!!!!"
                ua = cPickle.loads( ua )
                print "UNPICKLED Is now %s %s" % ( ua, len( ua.undostack ) )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                amd5 = md5.md5( t.bodyString )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    print "DISCARDED EDITSS!!!!"
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            print "V not in Undoers %s" % v
            #print v.vid
            self.umanager = leoSwingUndo.UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return

    @others
    

                    
&lt;&lt;UndoableDocumentEvent&gt;&gt;
&lt;&lt;UndoableCompoundEvent&gt;&gt;




</t>
<t tx="ekr.20070127142814.379">import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
import javax.swing.event as sevent
import java.io as io
import jarray
import md5
import org.python.util as putil
import NodeUndoerBase
import LeoCompoundEdit
import leoGlobals as g
import zlib
import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
from utilities.WeakMethod import WeakMethod</t>
<t tx="ekr.20070127142814.380">def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    &lt;&lt;_undoTo&gt;&gt;
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    &lt;&lt;_redoTo&gt;&gt;
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
</t>
<t tx="ekr.20070127142814.381">def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
</t>
<t tx="ekr.20070127142814.382">def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
</t>
<t tx="ekr.20070127142814.383">def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


</t>
<t tx="ekr.20070127142814.384">def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
        
    </t>
<t tx="ekr.20070127142814.385">def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == leoSwingUndo.UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        #print "A connection %s %s" % ( z, leoNodes.vid_vnode[ z ] )
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
</t>
<t tx="ekr.20070127142814.386">def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )</t>
<t tx="ekr.20070127142814.387">def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    #print "COMPOUND is %s" % compound
    self.__addUndo( compound )
    self.setMenu()
</t>
<t tx="ekr.20070127142814.388">@others</t>
<t tx="ekr.20070127142814.389">class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
</t>
<t tx="ekr.20070127142814.390">class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
      
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
</t>
<t tx="ekr.20070127142814.391">class UndoableProxyEvent( sundo.UndoableEdit ):

       
    def __init__( self, event, owner, master , c):
        
        self.event = event
        self.owner = owner
        self.master = master
        self.c = c
        self.cp = c.currentPosition().copy()
        self._can_undo = event.canUndo()
        self._can_redo = event.canRedo()
        self.can_undo = self._can_undo
        self.can_redo = self._can_redo
        self.dieable = 0
        self.ignore = 0
        
    
    def __canRedo( self ):
        return self._can_redo == self.event.canRedo()
        
    def __canUndo( self ):
        return self._can_undo == self.event.canUndo()
            
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        #if self.__canUndo():
        return self.can_redo
        #else:
        #    return self.event.canRedo()
        
    def canUndo( self ):
        #if self.__canRedo():
        return self.can_undo
        #else:
        #    return self.event.canUndo()
        
    def isAlive( self ):
        return self.can_redo or self.can_undo
    
    def invalidate( self ):
        self.c.undoer.killFromEvent( self )
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #edits = self.owner.getEdits()
        #spot = edits.indexOf( self.event )
        #self.owner.trimEdits( spot, edits.size() )
    
        
    def getPresentationName( self ):
        return self.event.getPresentationName()
        
    def getRedoPresentationName( self ):
        
        if self.__canRedo():
            return self.event.getRedoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getRedoPresentationName()
        else:
            return "Dead %s" % self.event.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        
        if self.__canUndo():
            return self.event.getUndoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getUndoPresentationName()
        else:
            return "Dead %s" % self.event.getUndoPresentationName()
        
        
    def isSignificant( self ):
        return 1
    
    def sync( self ):
        self._can_redo = self.event.canRedo()
        self._can_undo = self.event.canUndo()
        
    def redo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_redo = 0
        self.can_undo = 1
        if self.__canRedo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.redo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
            
        
    def undo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_undo = 0
        self.can_redo = 1
        if self.__canUndo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.undo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
        
    def replaceEdit( self, edit ):
        return 0
        

</t>
<t tx="ekr.20070127142814.392">class UndoableDocumentEvent3:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "" ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
    
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #if die_listeners.has_key( self ):
        #    dlistener = die_listeners[ self ]
        #    if dlistener.dieable:
        #        print "WHACKING %s" % dlistener
        #        dlistener.invalidate()
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )                
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            print 'undoing spot %s %s %s' % ( self.spot, self.length, self.txt )
            doc.remove( self.spot, self.length )
            print 'undone %s' % self
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


</t>
<t tx="ekr.20070127142814.393">class UndoableCompoundEvent3:
    
    def __init__( self, pname ):
        #self.ce = sundo.CompoundEdit()
        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        #return self.ce.canUndo()
        
    def canRedo( self ):
        return self.can_redo
        #return self.ce.canRedo()
        
    def undo( self ):
        for z in self.undostack:
            print z
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        self.undostack.reverse()
        for z in self.undostack:
            print z
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        

    
    def die( self ):
        pass
        #return self.ce.die()
        
    def end( self ):
        pass
        #return self.ce.end()
        
        

            
        

</t>
<t tx="ekr.20070127142814.394">@language java

import javax.swing.undo.*;
import java.io.*;
import java.util.Vector;

public class NodeUndoerBase extends UndoManager{

    public int indexOfNextAdd = 0;
    
    public int getNextIndex(){
        return indexOfNextAdd;
    }
    
    public void setNextIndex( int i ){
        indexOfNextAdd = i;
    }
    
    public final Vector&lt;UndoableEdit&gt; getEdits(){
        return edits;
    }
    
            
    public UndoableEdit editToBeUndone(){
        return super.editToBeUndone();
    }
    
    public UndoableEdit editToBeRedone(){
        return super.editToBeRedone();
    }
    
    public void redoTo( final UndoableEdit ue ){
        super.redoTo( ue );
    }
    
    public void undoTo( final UndoableEdit ue ){
    
        super.undoTo( ue );
    
    }
    
    public void trimEdits( int from, int to ){
        super.trimEdits( from, to );
    }
    
    public final byte[] serializeSelf(){
        try{
            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
            final ObjectOutputStream oos = new ObjectOutputStream( baos );
            oos.writeObject( this );
            oos.close();
            byte[] b = baos.toByteArray();
            return b;
        }
        catch( final IOException ioe ){
            System.out.println( ioe );
            ioe.printStackTrace();
            return new byte[]{};
        }
    }
}</t>
<t tx="ekr.20070127142814.395">@language java

import javax.swing.undo.*;
import java.util.Vector;

public class LeoCompoundEdit extends CompoundEdit{

    String __name;

    public LeoCompoundEdit( String name ){
    
        __name = name;
    
    
    }
    
    public String getPresentationName(){
    
        return __name;
    
    }

    public String getRedoPresentationName(){
    
        return "Redo " + __name;
    
    }

    public String getUndoPresentationName(){
    
        return "Undo " + __name;
    
    }
    
    public final Vector&lt;UndoableEdit&gt; getEdits(){
    
        return edits;
    
    
    }


}</t>
<t tx="ekr.20070127142814.396">@language java
import java.util.*;

public final class TnodeBodyText{

    final public StringBuilder _body;
    public String _headString;
    //private int accesses = 0;
    public TnodeBodyText( final String body ){
    
        _body = new StringBuilder();
        _body.append( body );
    
    }

    public final void delete( final int start, final int end ){ 
    
        _body.delete( start, end ); 
        final int length = _body.length();
        if( length &lt; _body.capacity()/2 )
            _body.trimToSize();
    
    }
    public final void deleteCharAt( final int index ){ 
    
        _body.deleteCharAt( index ); 
        
    }
    
    public final void insert( final int index, final String x ){
    
        _body.insert( index, x );
        
     
     }
    public final String toString(){ 
        
        //accesses++;
        //System.out.println( accesses );
        //if( accesses &gt; 400 )
        //    Thread.currentThread().dumpStack();
        return _body.toString();
         
    }
    public void setText( final Object o ){
        
        _body.setLength( 0 );
        _body.append( o );
    
    }
    
    public final int length(){
    
        return _body.length();
    
    
    }
    
    
    @others
    
}</t>
<t tx="ekr.20070127142814.397">public final String getHeadString(){

    //accesses++;
    //System.out.println( "getting hs " + accesses );
    return _headString;

}

public final void setHeadString( final String head ){

    _headString = head;


}</t>
<t tx="ekr.20070127142814.398">@language python

import javax.management as jmanage
import leoManagedConfiguration
import leoManagedConfigurationMBean


class leoManagement:
       '''leoManagement is the mechanism by which behaviors
       can be modified at runtime.  It is seperate from
       configuration in that configuration can alter behaviors
       but configuration is not the sole alterer of behaviors'''
       
       
       @others
       
</t>
<t tx="ekr.20070127142814.399">def __init__( self ):
    
    self.mbserver = jmanage.MBeanServerFactory.createMBeanServer()
    
</t>
<t tx="ekr.20070127142814.400">def addNotificationDef( self, name, method ):
    
    nd = self.NotificationDef( method )
    on = jmanage.ObjectName( "MBean", "name", name )
    self.mbserver.addNotificationListener( on, nd, None, None )
    

</t>
<t tx="ekr.20070127142814.401">class NotificationDef( jmanage.NotificationListener ):
    
    def __init__( self, method ):
        self.method = method
        
    def handleNotification( self, notification, handback ):
        self.method( notification, handback )
        
</t>
<t tx="ekr.20070127142814.402">def addMBeanForConfig( self, name, value ):
    
    if not name: return
    if name.find( ":" ):
        names = name.split( ":" )
        name = ' '.join( names )
        
    impl = leoManagedConfiguration( name, str( value ) )
    on = jmanage.ObjectName(  "MBean", "name", name )
    if not self.mbserver.isRegistered( on ):
        self.mbserver.registerMBean( impl, on )
    else:
        print on
         


</t>
<t tx="ekr.20070127142814.403">class leoMC( leoManagedConfigurationMBean , jmanage.NotificationBroadcasterSupport ):
    
    def __init__( self, name, value ):
        jmanage.NotificationBroadcasterSupport.__init__( self )
        self._name = name
        self._value = value
            
    def setValue( self, value ):
        self._value = value
        
    def getValue( self ):
        return self._value
        
    def getName( self ):
        return self._name
        
    def setName( self, name ):
        self._name = name
        
    def createMBeanInfo( self ):
        
        import jarray
        mmbai = jarray.zeros( 2, jmanage.modelmbean.ModelMBeanAttributeInfo )
        mmbai[ 0 ] = jmanage.modelmbean.ModelMBeanAttributeInfo( "Value", "java.lang.String", "what is the value", 1, 1, 0 )
        mmbai[ 1 ] = jmanage.modelmbean.ModelMBeanAttributeInfo( "Name", "java.lang.String", "what is the name", 1,1, 0 )
        
        mmboi = jarray.zeros( 0, jmanage.modelmbean.ModelMBeanOperationInfo )
        mmbci = jarray.zeros( 0, jmanage.modelmbean.ModelMBeanConstructorInfo )
        mmis = jmanage.modelmbean.ModelMBeanInfoSupport( str( self.__class__ ), 'support', mmbai, mmbci, mmboi, None )
        return mmis</t>
<t tx="ekr.20070127142814.404">@language java


public interface leoManagedConfigurationMBean{


    public void setName( String name ); 
    public String getName();
    public void setValue( String value );
    public String getValue();


}</t>
<t tx="ekr.20070127142814.405">@language java

import javax.management.*;


public class leoManagedConfiguration extends NotificationBroadcasterSupport implements leoManagedConfigurationMBean{

    String _name;
    String _value;
    long sn;
    
    public leoManagedConfiguration( String name, String value ){
    
        _name = name;
        _value = value;
        sn = 0;
    }
    
    public String getName(){ return _name; }
    public void setName( String name ){ _name = name; }
    public String getValue(){ return _value; }
    public void setValue( String value ){
    
        _value = value;
        Notification notify = new Notification( "config change", this , sn++ );
        sendNotification( notify );
     
    }



}</t>
<t tx="ekr.20070127142814.406">@language python

import java
import javax.swing as swing
import javax.swing.text as text
import javax.swing.event as sevent
import java.util.regex as regex
import leoSwingUndo
import SwingMacs 
import leoPlugins
import time
from utilities.WeakMethod import WeakMethod



class CompositeView( java.awt.event.FocusListener, sevent.UndoableEditListener ):
    '''A Class that takes a node and formats the subtree of the
    current node into a recursive widget, composed of editors within
    editors, within editors, within editors, etc... '''
    
    def __init__( self, c , parent = None ):
        
        self.c = c
        self.parent = parent
        p = c.currentPosition()
        self.p = p
        self.ignore_insert = 0
        self.pattern = pattern = java.util.regex.Pattern.compile( "&lt;"+"&lt;" + "[^&lt;&gt;]*" + "&gt;"+"&gt;" )
        
        self.jtp = jtp = swing.JTextPane()
        #self.jtp.addFocusListener( self )
        jtf = swing.JTextField()
        mlabel = swing.JLabel()
        jp = swing.JPanel( java.awt.BorderLayout() )
        jp.add( mlabel, java.awt.BorderLayout.WEST )
        jp.add( jtf, java.awt.BorderLayout.CENTER)
        
        self.swingmacs = SwingMacs.SwingMacs( jtp, jtf, mlabel, p.c )
        self.swingmacs.kcb.addTabForColon( 1 )
        self._nodesyncher = self.NodeSyncher( p.copy(), jtp, self.swingmacs, self )
        doc = jtp.getDocument()      
        doc.addDocumentListener( self._nodesyncher )  
        bt = p.bodyString()
        if bt == "":
            bt = " "
            p.v.t._bodyString.insert( 0, bt )
        self._nodesyncher.ignore = 1
        self.ignore_insert = 1
        jtp.setText( bt )
        self._nodesyncher.ignore = 0
        #s = time.time()
        self.scanNode( p, jtp )
        self.ignore_insert = 0
        #s2 = time.time()
        #print "Time was %s" %( s2 - s )
        jtp.setCaretPosition( 0 )
        jsp = swing.JScrollPane( jtp )
        if parent:
            parent.add( jsp )
            parent.add( jp, java.awt.BorderLayout.SOUTH )
        else:
            jf = swing.JFrame()
            cp = jf.getContentPane()
            cp.setLayout( java.awt.BorderLayout() )
            cp.add( jsp )
            #jtf = swing.JTextField()
            cp.add( jp, java.awt.BorderLayout.SOUTH )
            jf.pack()
            jf.visible = 1
        
        wm1 = WeakMethod( self, "sync" )
        leoPlugins.registerHandler( "select1" , wm1 )
    
    def focusGained( self, event ):
        return
        self.p = p = self.c.currentPosition()
        bs = self.jtp.getText()
        #bs2 = p.bodyString()
        bs2 = p.v.t.bodyString
        if not bs == bs2:
            if bs2 == "":
                bs2 = " "
                p.v.t._bodyString.insert( 0, bs2 )
            self._nodesyncher.ignore = 1
            doc = self.jtp.getDocument()
            self.jtp.setText( bs2 )
            self._nodesyncher.ignore = 0 
            #self.jtp.setText( bs2 )
            #s = time.time()
            self.scanNode( p, self.jtp )
            #s2 = time.time()
            self.jtp.setCaretPosition( 0 )
            #print "fg Time was %s" % ( s2 - s )
        
    def focusLost( self, event ):
        pass
    
    def sync( self , arg = None, arg2 = None ,force = 0, *args):
        
        if not self.jtp.isShowing() and not force:
            return
        
        self.c.frame.body._current_editor = self.jtp
        p = self.c.currentPosition()
        self._nodesyncher.p = p
        self.p = p
        jtp = self.jtp
        bt = p.bodyString()
        if bt == "":
            bt = " "
        #doc = jtp.getDocument()
        #doc.remove( 0, doc.getLength() )
        
        self._nodesyncher.ignore = 1
        jtp.setText( bt )       
        self.scanNode( p, jtp )        
        jtp.setCaretPosition( 0 )
        self._nodesyncher.ignore = 0
        
                          
    @others
            
        
        
            </t>
<t tx="ekr.20070127142814.407">class NodeSyncher( swing.event.DocumentListener, java.awt.event.FocusListener ):
    
    def __init__( self, p, widget, swingmacs, cv ):
        self.p = p
        self.widget = widget
        self.swingmacs = swingmacs
        widget.addFocusListener( self )
        self.cv = cv
        self.ignore = 0
        #widget.getDocument().addUndoableEditListener( cv )
        
    def changedUpdate( self, event ):
        pass
    
    def insertUpdate( self, event ):
        
        self.sync( event )
        
    def removeUpdate( self, event ):
    
        self.sync( event, which = 0 )

    def sync( self, event, which = 1 ):
        
        if self.ignore:
            return
    
        doc = event.getDocument()
        t = self.p.v.t
        offset = event.getOffset()
        length = event.getLength()
        c = self.p.c
        if which:
            txt = doc.getText( offset, length )
            print "ADDING TO TNODE!"
            t._bodyString.insert( offset, txt )
            dec_edit = leoSwingUndo.UndoableDocumentEvent( c, event, txt, p = self.p )
            c.undoer.addUndo( dec_edit )
        else:
            print "REMOVING FROM TNODE!"
            txt = t.bodyString[ offset : offset + length ]
            t._bodyString.delete( offset, offset + length )
            dec_edit = leoSwingUndo.UndoableDocumentEvent( c, event, txt, p = self.p )
            c.undoer.addUndo( dec_edit )
        
        
    def focusGained( self, event ):
        
        self.swingmacs.editor = self.widget
        self.p.c.frame.body._current_editor = self.widget
        
    
    def focusLost( self, event ):
        pass</t>
<t tx="ekr.20070127142814.408">def scanNode( self, p, jtp  ):

    others, sections = self.divide( p.children_iter( copy = True ) )    
    rejects = self.addSectionReferences( p, jtp, sections )
    others.extend( rejects )
    self.addOthers( p, jtp, others )


            

           

</t>
<t tx="ekr.20070127142814.409">def addSectionReferences( self, parent, editor, sec_references ):
    
    pstring = parent.bodyString()
    rejects = []
    for z in sec_references:
        hs = z.headString().strip()
        spot = pstring.find( hs )
        if spot != -1:
            jp = swing.JPanel( java.awt.BorderLayout() )
            jp.setOpaque( 0 )
            jb = swing.JCheckBox()
            jb.setToolTipText( "hide/show" )
            jb.setOpaque( 0 )
            jb.setSelected( 1 )
            jp.add( jb, java.awt.BorderLayout.NORTH )
            jtp = swing.JTextPane()
            jp.add( jtp )
            jb.actionPerformed = lambda event, jtp = jtp, jp = jp: self.add_remove( jtp, jp )
            jtp.addKeyListener( self.swingmacs.kcb )
            doc = jtp.getDocument()
            jtp.setText( z.bodyString() )
            doc.addDocumentListener( self.NodeSyncher( z.copy(), jtp, self.swingmacs, self ) )
            self.addBorder( jp, z.headString() )
            #jtp.setText( z.bodyString() )
            self.scanNode( z, jtp )
            sas = text.SimpleAttributeSet()
            text.StyleConstants.setComponent( sas, jp )
            doc = editor.getDocument()
            doc.setCharacterAttributes( spot, len( hs ), sas, 1 )
            #self.scanNode( z, jtp )
        else:
            rejects.append( z )
    return rejects</t>
<t tx="ekr.20070127142814.410">def addOthers( self, parent, editor, others ):
    
    if others:
        bs = parent.bodyString()
        spot = bs.find( "@" + "others" )
        whitespace = 0
        if spot == -1 and bs.strip() == "":
            spot = 0
            #if len( bs ) == 0:
            #    bs = " "
            #    #editor.setText( bs )
            whitespace =1
                        
        if spot != -1:
            opanel = swing.JPanel( java.awt.BorderLayout() )
            jp = swing.Box.createVerticalBox()
            jp.setOpaque( 0 )
            opanel.setOpaque( 0 )
            jcb = swing.JCheckBox( "@others" )
            jcb.setToolTipText( "hide/show" )
            jcb.setOpaque( 0 )
            jcb.setSelected( 1 )
            opanel.add( jcb, java.awt.BorderLayout.NORTH )
            opanel.add( jp )
            jcb.actionPerformed = lambda event, jp = jp, opanel = opanel: self.add_remove( jp, opanel )
            sas = text.SimpleAttributeSet()
            text.StyleConstants.setComponent( sas, opanel )
            #doc = editor.getDocument()
            #if not whitespace:
            #    doc.setCharacterAttributes( spot, 7, sas, 1 )
            #else:
            #    doc.setCharacterAttributes( spot, 1, sas , 1 )
            for z in others:
                jp2 = swing.JPanel( java.awt.BorderLayout() )
                jp2.setOpaque( 0 )
                jb = swing.JCheckBox()
                jb.setToolTipText( "hide/show" )
                jb.setOpaque( 0 )
                jb.setSelected( 1 )
                jp2.add( jb, java.awt.BorderLayout.NORTH )
                tp = swing.JTextPane()
                jb.actionPerformed = lambda event, tp = tp, jp2 = jp2: self.add_remove( tp, jp2 )    
                jp2.add( tp )
                tp.addKeyListener( self.swingmacs.kcb )
                bs = z.bodyString()
                if bs == "":
                    bs = " "
                    p.v.t._bodyString.insert( 0, bs )
                tp.setText( bs )
                doc = tp.getDocument()            
                doc.addDocumentListener( self.NodeSyncher( z.copy(), tp, self.swingmacs, self ) )
                self.addBorder( jp2, z.headString() )
                bs = z.bodyString()
                jp.add( jp2 )
                self.scanNode( z, tp )
            
            doc = editor.getDocument()
            if not whitespace:
                doc.setCharacterAttributes( spot, 7, sas, 1 )
            else:
                doc.setCharacterAttributes( spot, 1, sas , 1 )
</t>
<t tx="ekr.20070127142814.411">def divide( self, children_iterator ):
    
    others = []
    sections = []
    for z in children_iterator:
        hs = z.headString()
        matcher = self.pattern.matcher( java.lang.String( hs ) )
        if matcher.matches():
                sections.append( z )
        else:
            others.append( z )
        
    
    return others, sections</t>
<t tx="ekr.20070127142814.412">def addBorder( self, widget, title ):
    
    lborder = swing.border.LineBorder( java.awt.Color.RED )
    tborder = swing.border.TitledBorder( lborder, title )
    widget.setBorder( tborder )    
</t>
<t tx="ekr.20070127142814.413">def add_remove( self, widget1, widget2 ):
    '''this method enables the code folding'''
    if widget1.getParent() == None:
        widget2.add( widget1 )
    else:
        widget2.remove( widget1 )</t>
<t tx="ekr.20070127142814.414">def undoableEditHappened( self, event ):
    
    if self.ignore_insert: return
    c = self.c
    cp = c.currentPosition().copy()
    edit = event.getEdit()
    #dec_edit = leoSwingUndo.UndoableEditDecorator( c, cp, edit )
    #c.undoer.addUndo( dec_edit )
    
    #undoType = "undo_edit_class"
    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
</t>
<t tx="ekr.20070127142814.415">@language python

import org.jgraph as jg
import org.jgraph.graph as graph
import javax.swing as swing
import java

class leoGraphView:
    
    def __init__( self, c ):
    
        self.cp = c.currentPosition().copy()
        self.cs = graph.ConnectionSet()    
        self.dgm = graph.DefaultGraphModel()
        parent  = self.walkChildren()
        self.dgm.insert( parent , java.util.Hashtable(), self.cs, None, None )
        jf = swing.JFrame()
        jg1 = jg.JGraph( self.dgm )
        jg1.setSize( 1000, 1000 )
        print jg1.getSize()
        print "BENDABLE %s" % jg1.isBendable()
        jg1.setDragEnabled( 0 )
        jsp = swing.JScrollPane( jg1 )
        jf.add( jsp )
        jf.visible = 1
    
    def walkChildren( self ):
        
        items = []
        parents = {}
        cp = self.cp
        cs = self.cs
        parent = graph.DefaultGraphCell( cp.headString() )
        p1 = graph.DefaultPort( "" )
        atts = p1.getAttributes()
        print graph.GraphConstants.getLabelPosition( atts )
        #graph.GraphConstants.setLabelPosition( atts, java.awt.Point( 500, 500 ) )
        graph.GraphConstants.setBounds( atts, java.awt.Rectangle( 500, 500, 100, 100 ) )
        p1.changeAttributes( atts ) 
        parents[ cp ] = p1
        parent.add( p1 )
        items.append( parent )
        for z in cp.subtree_iter( copy = True ):
            child = graph.DefaultGraphCell( z.headString() )
            p2 = graph.DefaultPort( "" )
            atts = p2.getAttributes()
            graph.GraphConstants.setDisconnectable( atts, 0 )
            p2.changeAttributes( atts )
            parents[ z ] = p2
            _parent = z.getParent()
            #print child
            #print _parent
            #print parents
            p3 = parents[ _parent ]
            child.add( p2 )
            edge = graph.DefaultEdge( str( z.childIndex() ) )
            atts = edge.getAttributes()
            graph.GraphConstants.setLineStyle( atts, graph.GraphConstants.STYLE_BEZIER )
            graph.GraphConstants.setAutoSize( atts, 1 )
            graph.GraphConstants.setLineEnd( atts, graph.GraphConstants.ARROW_CLASSIC )
            edge.changeAttributes( atts )
            cs.connect( edge, p2, p3 )
            items.extend( [ child, edge ] ) 
         
        #return parent    
        return items    </t>
<t tx="ekr.20070127142814.417">@language python

import javax.swing as swing
import java
import leoPlugins
from utilities.WeakMethod import WeakMethod

class FlashCardView:
    '''A class that takes a node and turns its children into flashcards.
       It processes the nodes like so: even numbered children are questions,
       odd numbered children are answers.  If there is a question without an answer
       it does not get added to the FlashCard stack.  Each node-question-answer,
       has its tree written into one text body.  Hence if there are complicated
       structures of text that are best stored in tree form, the user can do so''' 
    
    def __init__( self, c , frame):
        
        self.c = c
        self.parent = frame
        self.gui = self.createGui()
        frame.add( self.gui )
        self.cards = self.createFlashCardStack()
        if self.cards:
            self.current_card = self.cards[ 0 ]
            self.question( None )
        else:
            self.current_card =  self.QA( "", "" )
            
        self.checkValidActions()
        wm1 = WeakMethod( self, "sync" )
        leoPlugins.registerHandler( "select1" , wm1  )
    
    @others

</t>
<t tx="ekr.20070127142814.418">def createGui( self ):
    
    jp = swing.JPanel( java.awt.BorderLayout() )
    self.jtp = jtp = swing.JEditorPane( "text/html", "" , editable = 0 )
    self.jsp = jsp = swing.JScrollPane( jtp )
    jb = self.jsp.getBorder()
    self.tb = tb = swing.border.TitledBorder( jb )
    self.tb2 = tb2 = swing.border.TitledBorder( tb, "", tb.CENTER, tb.BOTTOM )
    self.jsp.setBorder( self.tb2 )
    jp.add( jsp )
    jp2 = swing.JPanel()
    
    self.label = swing.JLabel()    
    self._question = question = swing.JButton( "Question" )
    question.actionPerformed = self.question
    self._answer = answer = swing.JButton( "Answer" )
    answer.actionPerformed = self.answer
    self._back = back = swing.JButton( "Back" )
    back.actionPerformed = self.back
    self._next = next = swing.JButton( "Next" )
    next.actionPerformed = self.next
    for z in ( question, answer, back, next ):
        jp2.add( z )
        
    jp.add( jp2, java.awt.BorderLayout.SOUTH )
    return jp
</t>
<t tx="ekr.20070127142814.419">def question( self, event ):
    
    txt = self.current_card.q
    self.jtp.setText( txt )
    self.jtp.setCaretPosition( 0 ) 
    self.checkValidActions()
    self.setQuestionLabel()

def answer( self, event ):
    
    txt = self.current_card.a
    self.jtp.setText( txt )
    self.jtp.setCaretPosition( 0 )
    self.checkValidActions()
    self.setAnswerLabel()

def back( self, event ):
    
    i = self.cards.index( self.current_card )
    i = i -1
    self.current_card = self.cards[ i ]
    #self.checkValidActions()
    self.question( event )

def next( self, event ):
    
    i = self.cards.index( self.current_card )
    i = i + 1
    self.current_card = self.cards[ i ]
    self.question( event )
</t>
<t tx="ekr.20070127142814.420">def createFlashCardStack( self ):
    
    c = self.c
    cp = c.currentPosition()
    self.tb.setTitle( cp.headString() )
    stack = []
    at = c.atFileCommands
    for z in cp.children_iter( copy = 1 ):
        at.write(z.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = "&lt;pre&gt;%s&lt;/pre&gt;" % at.stringOutput
        stack.append( data )

    stack2 = []
    stack.reverse()
    if not ( len( stack ) &gt;= 2 ) : return stack2 
    for z in xrange( len( stack )/2 ):
        question = stack.pop()
        answer = stack.pop()
        stack2.append( self.QA( question, answer ) )
    
    return stack2
    
        </t>
<t tx="ekr.20070127142814.421">def checkValidActions( self ):
    
    if self.cards:
        io = self.cards.index( self.current_card )
        cl = len( self.cards )
        if io == 0:
            self._back.setEnabled( 0 )
        else:
            self._back.setEnabled( 1 )
        
        if io == cl - 1:
            self._next.setEnabled( 0 )
        else:
            self._next.setEnabled( 1 )
            
        self._question.setEnabled( 1 )
        self._answer.setEnabled( 1 )
        
    
    else:
        for z in ( self._question, self._answer, self._back, self._next ):
            z.setEnabled( 0 )
    </t>
<t tx="ekr.20070127142814.422">def sync( self, arg = None, arg2 = None, force = 0, *args ):
    
    
    if not self.jtp.isShowing() and not force:
            return
          
    self.cards = self.createFlashCardStack()
    if self.cards:
        self.current_card = self.cards[ 0 ]
    self.checkValidActions()
    self.question( None )
    self.gui.repaint()</t>
<t tx="ekr.20070127142814.423">def setQuestionLabel( self ):
    
    if not self.cards:
        self.tb2.setTitle( "" )
    else:
        i = self.cards.index( self.current_card ) + 1
        if self.tb2.getTitle() == "":
            self.jsp.revalidate()
        self.tb2.setTitle( "Question #%s of %s" %( i, len( self.cards ) ) )
    self.jsp.repaint()
    
def setAnswerLabel( self ):
    
    if not self.cards:
        self.tb2.setTitle( "" )
    else:
        i = self.cards.index( self.current_card ) +1
        if self.tb2.getTitle() == "":
            self.jsp.revalidate()
        self.tb2.setTitle( "Answer #%s of %s" %( i, len( self.cards ) ) )
    self.jsp.repaint()</t>
<t tx="ekr.20070127142814.424">class QA:
    
    def __init__( self, q, a ):
        self.q = q
        self.a = a</t>
<t tx="ekr.20070127142814.426">import javax.swing.undo as undo
import javax.swing.event as sevent
#import NodeUndoerBase
import leoGlobals as g
import leoPlugins
import leoNodes
import zlib
import binascii
import pickle
import base64
from utilities.WeakMethod import WeakMethod    


&lt;&lt;UndoBase&gt;&gt;
    

class leoSwingUndo( UndoBase ):
    '''A simplified refactored leoUndo, that is based off of the javax.swing.undo package.
       A user who wishes to add a new Undo to the UndoManager must:
           a. subclass javax.swing.undo.UndoableEdit
           b. add it to the leoSwingUndo instance through addUndo
           
       Most, if not all, of the Undoable classes take their methods from leoUndo.
       If there is an existing UndoableEdit that you want to plug into the undo manager
       wrap it in an UndoableEditDecorator and add it.'''
    
    def __init__( self, c ):
        
        #self._um = NUB2()#NodeUndoerBase()
        UndoBase.__init__( self )
        amount = str( g.app.config.getString( c, "undo_stack_size" ) )
        #if amount == "*":
        #    self._um.setLimit( java.lang.Integer.MAX_VALUE )
        #elif amount.isdigit():
        #    self._um.setLimit( int( amount ) )
        self.c = c
        self.checksums_ok = 1
        self.checksum_violations = []
        self.ignore_additions = 0
        self.compound = None
        #self.undostack = []
        #self.undopointer = 0
        self.redoMenuLabel = "Can't Redo"
        self.undoMenuLabel = "Can't Undo"
        self.which_undoer ={
        
            "Move Right": UndoableMoveTree,
            "Move Left": UndoableMoveTree,
            "Move Up": UndoableMoveTree,
            "Move Down": UndoableMoveTree,
            "Drag": UndoableMoveTree,      
            "Insert Node": UndoableInsertNode,
            "Paste Node": UndoableInsertNode,
            "Delete Node": UndoableDeleteNode,
            "Cut Node": UndoableDeleteNode,
            "Demote": UndoableDemote,
            "Premote": UndoablePromote,
            "Hoist": UndoableHoist,
            "De-Hoist" : UndoableDeHoist,
            "Clone Node": UndoableClone,
            "Sort Children": UndoableSortChildren,
            "Sort Siblings": UndoableSortSiblings,
            "Sort Top Level": UndoableSortTopLevel,
            
        }
        
        config = g.app.config
        if config.getBool( c, "store_central_undo" ):
            self.remove_ude = config.getBool( c, "use_text_undo" )
            wm1 = WeakMethod( self, "serializeForLeoFile" )
            wm2 = WeakMethod( self, "unserializeForLeoFile" )
            wm3 = WeakMethod( self, "checkSumViolation" )
            leoPlugins.registerHandler( "write-leo-file-data", wm1 )
            leoPlugins.registerHandler( "read-leo-file-data", wm2 )
            leoPlugins.registerHandler( "checksum-violation", wm3 )
        
    def addUndo( self, undo ):
        
        if not self.ignore_additions:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
                        
            UndoBase.addUndo( self, undo )
            #self._um.addEdit( undo )
            #if self.undostack:
            #    #self.undostack = self.undostack[ self.undopointer : len( self.undostack  ) -1 ]
            #    self.undostack = self.undostack[ : self.undopointer ]
            #self.undostack.append( undo )
            #self.undopointer = len( self.undostack  )
            #self.undostack.append( undo )
            #self.undopointer += 1
        self.setMenu()
        

        
    def undo( self ):
        
        self.ignore_additions = 1
        UndoBase.undo( self )
        #self._um.undo()
        #i = self.undopointer
        #if i &gt; 0:
        #    i -= 1
        #    self.undostack[ i ].undo()
        #    self.undopointer -= 1
        self.ignore_additions = 0
        self.setMenu()
        
    def redo( self ):
        
        self.ignore_additions = 1
        UndoBase.redo( self )
        #self._um.redo()
        #self.undostack[ self.undopointer ].redo()
        #self.undopointer += 1
        self.ignore_additions = 0
        self.setMenu()
        
    def grabLabels( self ):
        
        #self.redoMenuLabel = self._um.getRedoPresentationName()
        #self.undoMenuLabel = self._um.getUndoPresentationName()
        self.undoMenuLabel = self.getUndoPresentationName()
        self.redoMenuLabel = self.getRedoPresentationName()


        
    def killFromEvent( self, event ):
        
        edits = self._um.getEdits()
        i = edits.indexOf( event )
        if i != -1:
            self._um.trimEdits( i, edits.size() -1 )
            self.setMenu()
    
    def setMenu( self, forceupdate = 0 ):
        
        if not hasattr( self.c, 'frame' ): return
        u = self ; frame = u.c.frame
        if not self.c.frame.menu: return
        menu = self.c.frame.menu.getMenu( "Edit" )
        #nredolabel = self._um.getRedoPresentationName()
        nredolabel = self.getRedoPresentationName()
        if ( nredolabel != self.redoMenuLabel ) or forceupdate:
            enabled = self.canRedo()
            #frame.menu.setMenuLabel( menu, self.redoMenuLabel, nredolabel, enabled = enabled  )
            frame.menu.redoMenu.setText( nredolabel ); frame.menu.redoMenu.setEnabled( enabled )
        #nundolabel = self._um.getUndoPresentationName()
        nundolabel = self.getUndoPresentationName()
        if ( nundolabel != self.undoMenuLabel ) or forceupdate:
            enabled = self.canUndo()
            #frame.menu.setMenuLabel( menu, self.undoMenuLabel, nundolabel, enabled = enabled  )
            frame.menu.undoMenu.setText( nundolabel ); frame.menu.undoMenu.setEnabled( enabled )
        
        self.grabLabels()

        
    @others
    

&lt;&lt;Undoable classes&gt;&gt;

&lt;&lt;Node Undoer&gt;&gt;







</t>
<t tx="ekr.20070127142814.427">class UndoBase:
    
    def __init__( self ):
        self.undostack = []
        self.undopointer = 0
    
    def setEditor( self, editor ):
        for z in self.undostack:
            if hasattr( z, "setEditor" ):
                z.setEditor( editor )
       
    def discardAllEdits( self ):
        self.undostack = []
        self.undopointer = 0
        
        
    def getEdits( self ):
        return util.ArrayList( self.undostack )
        
    def undoTo( self, edit ):
        
        l = util.ArrayList( self.undostack )
        iof = l.indexOf( edit )
        amount = self.undopointer - iof
        for z in xrange( amount ):
            self.undo()
            
    def redoTo( self, edit ):   
        
        l = util.ArrayList( self.undostack )
        iof = l.indexOf( edit )
        amount = iof - self.undopointer
        for z in xrange( amount + 1 ):
            self.redo()
        
    def addUndo( self, undo ):
        
        if self.undostack:
            self.undostack = self.undostack[ : self.undopointer ]
        self.undostack.append( undo )
        self.undopointer = len( self.undostack  )
    
    def editToBeUndone( self ):
    
        i = self.undopointer
        if i &gt; 0:
            i -= 1
            e = self.undostack[ i ]
            return e
        return None
        
    def editToBeRedone( self ):
        
        i = self.undopointer
        c = len( self.undostack  )
        if i &lt; c:
            e = self.undostack[ i ]
            return e
        return None
        
    def canUndo( self ):
        
        e = self.editToBeUndone()
        if e:
            return e.canUndo()
        return 0
        
    def canRedo( self ):
        
        e = self.editToBeRedone()
        if e:
            return e.canRedo()
        return 0

    def undo( self ):
        
        i = self.undopointer
        if i &gt; 0:
            i -= 1
            self.undostack[ i ].undo()
            self.undopointer -= 1

        
    def redo( self ):

        self.undostack[ self.undopointer ].redo()
        self.undopointer += 1
        

    def getUndoPresentationName( self ):
        
        e = self.editToBeUndone()
        if e:
            return e.getUndoPresentationName()
        return "Can't Undo"
        
    def getRedoPresentationName( self ):
        
        e = self.editToBeRedone()
        if e:
            return e.getRedoPresentationName()
        return "Can't Redo"


</t>
<t tx="ekr.20070127142814.428">def clearUndoState( self ):
    
    #self._um.discardAllEdits()
    self.undostack = []
    self.undopointer = 0
    self.setMenu()
    
</t>
<t tx="ekr.20070127142814.429">def setUndoParams( self, *args, **kwords ):
    
    if self.ignore_additions: return
    which = args[ 0 ]
    if which in self.which_undoer:
        undoable_edit = self.which_undoer[ which ](  self.c, args, kwords )
        self.addUndo( undoable_edit )
    
</t>
<t tx="ekr.20070127142814.430">def beforeClearRecentFiles (self):
    
    u = self ; p = u.c.currentPosition()
    
    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch</t>
<t tx="ekr.20070127142814.431">def afterClearRecentFiles (self,bunch):
    
    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]
    
    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles
    
    # Push the bunch, not a dict.
    #u.bead += 1
    #u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    #u.setUndoTypes()

    return bunch</t>
<t tx="ekr.20070127142814.432">def createCommonBunch (self,p):
    
    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''
    
    u = self ; c = u.c ; body = c.frame.body
    
    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = body.getTextSelection(),
        p = p.copy(),
    )</t>
<t tx="ekr.20070127142814.433">def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20070127142814.434">def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:] 
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20070127142814.435">@others
</t>
<t tx="ekr.20070127142814.436">def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        udata = ( self.undopointer, self.undostack )
        store.addData( "undostack", udata )
        
</t>
<t tx="ekr.20070127142814.437">def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "undostack" )
            if udata:
                self.undopointer = udata[ 0 ]
                self.undostack = udata[ 1 ]
                if self.remove_ude:
                    to_remove = []
                    rmv_amount = 0
                    for z in xrange( len( self.undostack ) ):
                        uevent = self.undostack[ z ]
                        if uevent.__class__ == UndoableDocumentEvent:
                            to_remove.append( uevent )
                            if self.undopointer &gt;= z:
                                rmv_amount += 1
                    self.undopointer -= rmv_amount
                    for z in to_remove:
                        self.undostack.remove( z )
                                
                for z in self.undostack:
                    if z.__class__ not in ( UndoableDocumentEvent, UndoableCompoundEvent ):
                        z.c = self.c
                    commanders[ z ] = self.c
                    if z.__class__ == UndoableCompoundEvent:
                        for x in z.undostack:
                            commanders[ x ] = self.c
         
                self.setMenu()
                g.es( "Undo Manager restored..." )
        except Exception, x:
            self.undostack = []
            self.undopointer = 0
            self.setMenu()
            g.es( "Resetting the Undo Manager..." )
            
    if not self.checksums_ok:
        g.es( "Undo Manager not restored because of file changes in: %s" % " ,".join( self.checksum_violations ) )
        self.checksums_ok = 1
        self.checksum_violations = []
            

</t>
<t tx="ekr.20070127142814.438">def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name, p = self.c.currentPosition().copy() )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    self.addUndo( compound )
    self.setMenu()</t>
<t tx="ekr.20070127142814.439">def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )</t>
<t tx="ekr.20070127142814.440">@others
</t>
<t tx="ekr.20070127142814.441">class UndoableEditDecorator( undo.UndoableEdit ):
    
    def __init__( self, c, pos, ue ):
        
        self.c = c
        self.pos = pos.copy()
        self.ue = ue
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.ue.canRedo()
        
    def canUndo( self ):
        return self.ue.canUndo()
        
    def die( self ):
        self.ue.die()
        
    def getPresentatioName( self ):
        return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        return self.ue.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        return self.ue.getUndoPresentationName()
        
    def isSignificant( self ):
        return self.ue.isSignificant()
        
    def redo( self ):
        
        c = self.c
        cp = c.currentPosition()
        if cp != self.pos:
            c.beginUpdate()
            c.selectPosition( self.pos )
            c.endUpdate()
        self.ue.redo()
        
    def undo( self ):
        
        c = self.c
        cp = c.currentPosition()
        if cp != self.pos:        
            c.beginUpdate()
            c.selectPosition( self.pos )
            c.endUpdate()
        self.ue.undo()
        
    def replaceEdit( self, edit ):
        return 0

</t>
<t tx="ekr.20070127142814.442">class UndoableDocumentEvent( undo.UndoableEdit ):
    
    def __init__( self,c, event, txt = "", ustack = () ):
        
        self.c = c
        #if p:
        #    self.pos = p.copy()
        #else:      
        #    self.pos = c.currentPosition().copy()
        #self.event = event
        if not ustack:
            self.spot = event.getOffset()
            self.length = event.getLength()
            self.txt = txt
        else:
            self.spot = ustack[ 0 ]
            self.length = ustack[ 1 ]
            self.txt = ustack[ 2 ]
            
        self.can_undo = 1
        self.can_redo = 0
        if txt.isspace():
           name_txt = "%s whitespaces" % len( txt )
        else:
           name_txt = txt
        
        if not ustack:
            if event.getType() == sevent.DocumentEvent.EventType.INSERT:
                self.etype = "insert"
            elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
                self.etype = "remove"
        else:
            self.etype = ustack[ 3 ]
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
            
    def getAsTuple( self ):
        return ( self.spot, self.length, self.txt, self.etype ) 
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        #cp = self.c.currentPosition()
        #if cp != self.pos:
        #    self.c.selectPosition( self.pos.copy() )
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        #cp = self.c.currentPosition()
        #if cp != self.pos:
        #    self.c.selectPosition( self.pos.copy() )
        #self.undoEvent()
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        doc = self.c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        
        doc = self.c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.remove( self.spot, self.length )
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

</t>
<t tx="ekr.20070127142814.443">class UndoableMoveTree( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.oldParent = kwords[ 'oldParent' ]
        if self.oldParent:
            self.oldParent = self.oldParent.copy()
        else:
            self.oldParent = None
        self.oldN = kwords[ 'oldN' ]
        self.oldBack = kwords[ 'oldBack' ]
        if self.oldBack:
            self.oldBack = self.oldBack.copy()
        else:
            self.oldBack = None
            
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]
        self.parent = self.p.getParent()
        if self.parent:
            self.parent = self.parent.copy()
        else:
            self.parent = None
        self.back = self.p.getBack()
        if self.back:
            self.back = self.back.copy()
        else:
            self.back = None
        self.n = self.p.childIndex()
        
        self.can_undo = 1
        self.can_redo = 0
        
    
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2
        
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        if not self.can_redo: return
        self.redoMoveNode()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        if not self.can_undo: return
        self.undoMoveNode()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        

        
    @others
</t>
<t tx="ekr.20070127142814.444">def undoMoveNode (self):
    
    u = self ; c = u.c
    
    # g.trace("oldParent",u.oldParent)
    c.beginUpdate()
    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition() # Bug fix: 4/9/04
        u.p.moveToRoot(oldRoot)

    c.selectVnode(u.p.copy())
    c.endUpdate()
    #c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.445">def redoMoveNode (self):
    
    u = self ; c = u.c
    
    c.beginUpdate()
    # g.trace(u.p)
    if u.parent:
        u.p.moveToNthChildOf(u.parent,u.n)
    elif u.back:
        u.p.moveAfter(u.back)
    else:
        oldRoot = c.rootPosition() # Bug fix: 4/9/04
        u.p.moveToRoot(oldRoot)

    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )
</t>
<t tx="ekr.20070127142814.446">class UndoableInsertNode( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.select = kwords.get( 'select', None )
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]
        self.parent = self.p.getParent()
        if self.parent:
            self.parent = self.parent.copy()
        else:
            self.parent = None
        self.back = self.p.getBack()
        if self.back:
            self.back = self.back.copy()
        else:
            self.back = None
        self.n = self.p.childIndex()
        

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):

        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoInsertNodes()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoInsertNodes()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
        
        
    @others
</t>
<t tx="ekr.20070127142814.447">def undoInsertNodes (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p)
    c.deleteOutline()
    #if u.select:
    #    c.selectVnode(u.select)
    c.endUpdate()
    if u.select:
        c.selectPosition( u.select.copy() )</t>
<t tx="ekr.20070127142814.448">def redoInsertNodes (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.449">class UndoableDeleteNode( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        
        self.select = kwords[ 'select' ]
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]
        self.parent = self.p.getParent()
        if self.parent:
            self.parent = self.parent.copy()
        else:
            self.parent = None
        self.back = self.p.getBack()
        if self.back:
            self.back = self.back.copy()
        else:
            self.back = None
        self.n = self.p.childIndex()
        
        self.can_undo = 1
        self.can_redo = 0

    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoDeleteNode()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoDeleteNode()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.450">def redoDeleteNode (self):
    
    u = self ; c = u.c
    
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.deleteOutline()
    c.endUpdate()</t>
<t tx="ekr.20070127142814.451">@ Deleting a clone is _not_ the same as undoing a clone:
the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    c.beginUpdate()
    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.452">class UndoableDemote( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        
        self.lastChild = kwords[ 'lastChild' ].copy()
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
            
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoDemote()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoDemote()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.453">def redoDemote (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.demote()
    c.endUpdate()</t>
<t tx="ekr.20070127142814.454">def undoDemote (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    p   = u.p.copy()
    ins = u.p.copy()
    last = u.lastChild
    assert(p.hasFirstChild)
    child = p.firstChild()
    
    # Do not undemote children up to last.
    # Do not use an iterator here.
    if last:
        while child and child != last:
            child = child.next()
        if child:
            child = child.next()

    while child:
        next = child.next()
        child.moveAfter(ins)
        ins = child
        child = next
    #c.selectVnode(p)
    c.endUpdate()
    c.selectPosition( p.copy() )</t>
<t tx="ekr.20070127142814.455">class UndoablePromote( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        
        self.lastChild = kwords[ 'lastChild' ].copy()
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoPromote()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoPromote()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.456">def redoPromote (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.promote()
    c.endUpdate()
    

</t>
<t tx="ekr.20070127142814.457"># Undoes the previous promote operation.
def undoPromote (self):
    
    u = self ; c = u.c
    next = u.p.next()
    last = u.lastChild
    assert(next)
    c.beginUpdate()
    while next: # don't use an iterator here.
        p2 = next
        next = p2.next()
        n = u.p.numberOfChildren()
        p2.moveToNthChildOf(u.p,n)
        if p2 == last: break
    #c.selectVnode(u.p) 
    c.endUpdate()
    c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.458">class UndoableHoist( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoHoist()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoHoist()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.459">def redoHoist (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.hoist()
    u.updateSetChangedFlag = False
    c.endUpdate()
    


</t>
<t tx="ekr.20070127142814.460">def undoHoist (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.dehoist()
    u.updateSetChangedFlag = False
    c.endUpdate()
    
    
</t>
<t tx="ekr.20070127142814.461">class UndoableDeHoist( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoDehoist()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoDehoist()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.462">def redoDehoist (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.dehoist()
    u.updateSetChangedFlag = False
    c.endUpdate()


</t>
<t tx="ekr.20070127142814.463">def undoDehoist (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.hoist()
    u.updateSetChangedFlag = False
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.464">class UndoableClone( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        p = args[ 1 ].copy()
        self.p = p.copy()
        self.back = p.getBack()
        if self.back:
            self.back = self.back.copy()
        else:
            self.back = None
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentatioName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s for %s" % ( self.name, self.p.v.t.headString )
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoClone()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoClone()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.465">def undoClone (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p)
    c.deleteOutline()
    #c.selectVnode(u.back)
    c.endUpdate()
    c.selectPosition( u.back.copy() )</t>
<t tx="ekr.20070127142814.466">def redoClone (self):
    
    u = self ; c = u.c
    
    c.beginUpdate()
    if u.back:
        u.p.linkAfter(u.back)
    elif u.parent:
        u.p.linkAsNthChild(u.parent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)

    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )
</t>
<t tx="ekr.20070127142814.467">class UndoableSortChildren( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.sort = kwords[ 'sort' ]
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentationName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoSortChildren()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoSortChildren()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.468">def undoSortChildren (self):

    u = self ; c = u.c
    assert(u.p)
    c.beginUpdate()
    c.endEditing()
    index = 0
    for child in u.sort:
        child.moveToNthChildOf(u.p,index)
        index += 1
    c.endUpdate()</t>
<t tx="ekr.20070127142814.469">def redoSortChildren (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.sortChildren()
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.470">class UndoableSortSiblings( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.sort = kwords[ 'sort' ]
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentationName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoSortSiblings()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoSortSiblings()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.471">def undoSortSiblings (self):
    
    u = self ; c = u.c

    parent = u.p.parent()
    assert(u.p and parent)
    c.beginUpdate()
    c.endEditing()
    index = 0
    for sib in u.sort:
        sib.moveToNthChildOf(parent,index)
        index += 1
    parent.setDirty()
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.472">def redoSortSiblings (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.sortSiblings()
    c.endUpdate()
    #c.selectPosition( u.p.copy() )

</t>
<t tx="ekr.20070127142814.473">class UndoableSortTopLevel( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.sort = kwords[ 'sort' ]
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentationName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoSortTopLevel()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoSortTopLevel()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.474">def undoSortTopLevel (self):
    
    u = self ; c = u.c
    root = c.rootPosition()
    c.beginUpdate()
    c.endEditing()
    v = u.sort[0]
    v.moveToRoot(oldRoot=root)
    for next in u.sort[1:]:
        next.moveAfter(v)
        v = next
        
    #u.p = None # don't mark u.p dirty
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.475">def redoSortTopLevel (self):
    
    u = self ; c = u.c
    c.beginUpdate()
    c.selectVnode(u.p.copy())
    c.sortTopLevel()
    #u.p = None # don't mark u.p dirty
    c.endUpdate()
    #c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.476">class UndoableChangeHeadline( undo.UndoableEdit ):
    
    def __init__( self, c, args, kwords ):
        
        self.c = c        
        self.p = args[ 1 ].copy()
        self.sort = kwords[ 'sort' ]
        self.name = args[ 0 ]

        
        self.can_undo = 1
        self.can_redo = 0
        
    def __getstate__( self ):
        
        d2 = {}
        d2.update( self.__dict__ )
        del d2[ 'c' ]
        return d2 
        
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        #return self.ue.canRedo()
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):
        
        self.can_undo = self.can_redo = 0
        #self.ue.die()
        
    def getPresentationName( self ):
        return self.name 
        #return self.ue.getPresentationName()
        
    def getRedoPresentationName( self ):
        #return self.ue.getRedoPresentationName()
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        #return self.ue.getUndoPresentationName()
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        #return self.ue.isSignificant()
        
    def redo( self ):
        
        self.redoChangeHeadline()
        self.can_redo = 0
        self.can_undo = 1
        
    def undo( self ):
        
        self.undoChangeHeadline()
        self.can_undo = 0
        self.can_redo = 1
        
    def replaceEdit( self, edit ):
        return 0
        
    @others</t>
<t tx="ekr.20070127142814.477">def undoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.oldText)
    c.beginUpdate()
    u.p.setHeadStringOrHeadline(u.oldText)
    
    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )

    </t>
<t tx="ekr.20070127142814.478">def redoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.newText)
    c.beginUpdate()
    u.p.setHeadStringOrHeadline(u.newText)
    
    #c.selectVnode(u.p)
    c.endUpdate()
    c.selectPosition( u.p.copy() )</t>
<t tx="ekr.20070127142814.479">class UndoableDocumentEvent:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "", p = None ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt
        self.p = p

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
        
        self.editor = None
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
    
    def setEditor( self, editor ):
        self.editor = editor
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        if self.p:
            c.selectPosition( self.p.copy() )
        doc = self.editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )
        if self.p:
            c.selectPosition( self.p.copy() )                
        doc = self.editor.getDocument()
        if self.etype == "insert":
            doc.remove( self.spot, self.length )
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


</t>
<t tx="ekr.20070127142814.480">class UndoableCompoundEvent:
    
    def __init__( self, pname, p = None ):

        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        self.p = p
    
    def setEditor( self, editor ):
        for z in self.undostack:
            if hasattr( z, "setEditor" ):
                z.setEditor( editor )
       
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        
    def canRedo( self ):
        return self.can_redo
        
    def undo( self ):
        
        if self.p:
            self.p.c.selectPosition( self.p.copy() )
        for z in self.undostack:
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        if self.p:
            self.p.c.selectPosition( self.p.copy() )
        self.undostack.reverse()
        for z in self.undostack:
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        
    def getEdits( self ):
        return self.undostack
    
    def die( self ):
        
        self.undostack = None
        
    def end( self ):
        pass

        
        

            
        


</t>
<t tx="ekr.20070127142814.481">&lt;&lt;imports&gt;&gt;
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo, editor ):
        '''c -&gt; a commander
           umenu -&gt; a JMenuItem that is the 'undo' action
           rmenu -&gt; a JMenuItem that is the 'redo' action
           gtnu -&gt; a JMenuItem that is the 'goto next undo' action
           gtnr -&gt; a JMenuItem that is the 'goto next redo' action
           vunstack -&gt; a JMenuItem that is the 'visualise undo stack' action
           clearundo -&gt; a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        self.editor = editor
        config = g.app.config
        if config.getBool( c, "store_text_undos" ): 
            wm1 = WeakMethod( self, "serializeForLeoFile" )
            wm2 = WeakMethod( self, "unserializeForLeoFile" )
            wm3 = WeakMethod( self, "checkSumViolation" )
            leoPlugins.registerHandler( "write-leo-file-data", wm1 )
            leoPlugins.registerHandler( "read-leo-file-data", wm2 )
            leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.setEditor( self.editor )
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.setEditor( self.editor )
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
    
    def checkSumNode( self, t ):
        
        amd5 = md5.md5( t.bodyString )
        hdigest = amd5.hexdigest()
        self.checksums[ t ] = hdigest
        return hdigest
                   
    
    def setNode( self, p ):
        
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            ua = self.undoers[ v ]
            if ua.__class__ == UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                ua = cPickle.loads( ua )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                #amd5 = md5.md5( t.bodyString )
                hexdigest = self.checkSumNode( t )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            #print v.vid
            self.umanager = UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.editor.setCaretPosition( spot )
            return

    @others
    






</t>
<t tx="ekr.20070127142814.482">import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
#import javax.swing.event as sevent
#import java.io as io
import jarray
import md5
#import org.python.util as putil
#import NodeUndoerBase
#import LeoCompoundEdit
import leoGlobals as g
import zlib
#import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
</t>
<t tx="ekr.20070127142814.483">def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    &lt;&lt;_undoTo&gt;&gt;
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    &lt;&lt;_redoTo&gt;&gt;
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
</t>
<t tx="ekr.20070127142814.484">def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
</t>
<t tx="ekr.20070127142814.485">def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
</t>
<t tx="ekr.20070127142814.486">def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == UndoableCompoundEvent: #LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


</t>
<t tx="ekr.20070127142814.487">def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
        
    </t>
<t tx="ekr.20070127142814.488">def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
</t>
<t tx="ekr.20070127142814.489">def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )</t>
<t tx="ekr.20070127142814.490">def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    self.__addUndo( compound )
    self.setMenu()
</t>
<t tx="ekr.20070127142814.491">@others</t>
<t tx="ekr.20070127142814.492">class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
</t>
<t tx="ekr.20070127142814.493">class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
</t>
<t tx="ekr.20070127142814.494">@language python
@tabwidth -4   
@pagewidth 80  

&lt;&lt; imports &gt;&gt;

&lt;&lt; class parserBaseClass &gt;&gt;

@others</t>
<t tx="ekr.20070127142814.495">import leoGlobals as g
import leoGui

if 1: # Used by settings controller.
    import leoNodes
    #import leoTkinterColorPanels
    #import leoTkinterTree

    #Pmw = g.importExtension("Pmw",pluginName="leoConfig.py",verbose=False)

    #import Tkinter as Tk
    #import tkColorChooser
    #import tkFont
    import leoSwingFrame

import sys</t>
<t tx="ekr.20070127142814.496">class parserBaseClass:
    
    """The base class for settings parsers."""
    
    &lt;&lt; parserBaseClass data &gt;&gt;
    
    @others</t>
<t tx="ekr.20070127142814.497"># These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'font','if','ifgui','ifplatform','ignore','page',
    'recentfiles','settings','shortcuts']

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}</t>
<t tx="ekr.20070127142814.498">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'recentfiles':  self.doRecentFiles,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20070127142814.499">def error (self,s):

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")</t>
<t tx="ekr.20070127142814.500"></t>
<t tx="ekr.20070127142814.501">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20070127142814.502">def doColor (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)</t>
<t tx="ekr.20070127142814.503">def doDirectory (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory</t>
<t tx="ekr.20070127142814.504">def doFloat (self,p,kind,name,val):
    
    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20070127142814.505">def doFont (self,p,kind,name,val):
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)</t>
<t tx="ekr.20070127142814.506">def doIf(self,p,kind,name,val):

    g.trace("'if' not supported yet")
    return None</t>
<t tx="ekr.20070127142814.507">def doIfGui (self,p,kind,name,val):

    if g.app.gui == name:
        return None
    else:
        return "skip"</t>
<t tx="ekr.20070127142814.508">def doIfPlatform (self,p,kind,name,val):

    if sys.platform == name:
        return None
    else:
        return "skip"</t>
<t tx="ekr.20070127142814.509">def doIgnore(self,p,kind,name,val):

    return "skip"</t>
<t tx="ekr.20070127142814.510">def doInt (self,p,kind,name,val):
    
    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20070127142814.511">def doInts (self,p,kind,name,val):

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,kind,name,val)
    
        name = name[j+1:].strip()
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)</t>
<t tx="ekr.20070127142814.512">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.</t>
<t tx="ekr.20070127142814.513">def doRatio (self,p,kind,name,val):
    
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)</t>
<t tx="ekr.20070127142814.514">def doRecentFiles (self,p,kind,name,val):
    
    s = p.bodyString().strip()
    if s:
        lines = g.splitLines(s)
        self.set(p,"recent-files","recent-files",lines)</t>
<t tx="ekr.20070127142814.515">def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20070127142814.516">def doShortcuts(self,p,kind,name,val):
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)</t>
<t tx="ekr.20070127142814.517">def doString (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20070127142814.518">def doStrings (self,p,kind,name,val):
    
    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]

        name = name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)</t>
<t tx="ekr.20070127142814.519">def munge(self,s):
    
    return g.app.config.canonicalizeSettingName(s)</t>
<t tx="ekr.20070127142814.520">def oops (self):
    
    print ("parserBaseClass oops:",
        g.callerName(2),
        "must be overridden in subclass")

</t>
<t tx="ekr.20070127142814.521"></t>
<t tx="ekr.20070127142814.522">def fontSettingNameToFontKind (self,name):
    
    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None</t>
<t tx="ekr.20070127142814.523">def parseFont (self,p):
    
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(p,line,d)
        
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
        
    return d</t>
<t tx="ekr.20070127142814.524">def parseFontLine (self,p,line,d):
    
    s = line.strip()
    if not s: return
    
    try:
        s = str(s)
    except UnicodeError:
        pass
    
    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip() ; val = s[i+1:].strip()

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.</t>
<t tx="ekr.20070127142814.525">def parseHeadline (self,s):
    
    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i]
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:]
            else:
                name = s[i:j]
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val</t>
<t tx="ekr.20070127142814.526">def parseShortcutLine (self,s):
    
    """Return the kind of @settings node indicated by p's headline."""
    
    kind = name = val = None

    i = g.skip_id(s,0)
    name = s[0:i]
    if name:
        i = g.skip_ws(s,i)
        if g.match(s,i,'='):
            i = g.skip_ws(s,i+1)
            val = s[i:]

    # g.trace("%30s %s" %(name,val))
    return name,val</t>
<t tx="ekr.20070127142814.527"># p used in subclasses, not here.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())</t>
<t tx="ekr.20070127142814.528">def setShortcut (self,name,val):
    
    # g.trace(name,val)
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",val)</t>
<t tx="ekr.20070127142814.529">def traverse (self):
    
    c = self.c
    
    p = g.app.config.settingsRoot(c)
    if not p:
        return None

    self.settingsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        if result == "skip":
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
            
    return self.settingsDict</t>
<t tx="ekr.20070127142814.530">def valueError (self,p,kind,name,val):
    
    """Give an error: val is not valid for kind."""
    
    self.error("%s is not a valid %s for %s" % (val,kind,name))</t>
<t tx="ekr.20070127142814.531">def visitNode (self,p):
    
    self.oops()</t>
<t tx="ekr.20070127142814.532">class baseConfig:
    """The base class for Leo's configuration handler."""
    &lt;&lt; baseConfig data &gt;&gt;
    @others
    
class config (baseConfig):
    """A class to manage configuration settings."""
    pass</t>
<t tx="ekr.20070127142814.533">@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.</t>
<t tx="ekr.20070127142814.534">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)</t>
<t tx="ekr.20070127142814.535">encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","unicode-encoding","utf-8"),
    ("new_leo_file_encoding","unicode-encoding","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","unicode-encoding",None),
        # Defaults to None so it doesn't override better defaults.
)</t>
<t tx="ekr.20070127142814.536"># Each of these settings sets the ivar with the same name.
ivarsDict = {'_hash':'ivarsDict'}

if 0: # From c.__init__
    # Global options
    c.tangle_batch_flag = False
    c.untangle_batch_flag = False
    # Default Tangle options
    c.tangle_directory = ""
    c.use_header_flag = False
    c.output_doc_flag = False
    # Default Target Language
    c.target_language = "python" # Required if leoConfig.txt does not exist.

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",False),
        # Should never be True here!
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)</t>
<t tx="ekr.20070127142814.537"></t>
<t tx="ekr.20070127142814.538">def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()</t>
<t tx="ekr.20070127142814.539">def initDicts (self):
    
    # Only the settings parser needs to search all dicts.
    self.dictList = [self.defaultsDict]

    for key,kind,val in self.defaultsData:
        self.defaultsDict[self.munge(key)] = g.Bunch(
            setting=key,kind=kind,val=val,tag='defaults')
        
    for key,kind,val in self.ivarsData:
        self.ivarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,val=val,tag='ivars')

    for key,kind,val in self.encodingIvarsData:
        self.encodingIvarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,encoding=val,tag='encodings')</t>
<t tx="ekr.20070127142814.540">def initIvarsFromSettings (self):
    
    for ivar in self.encodingIvarsDict.keys():
        if ivar != '_hash':
            self.initEncoding(ivar)
        
    for ivar in self.ivarsDict.keys():
        if ivar != '_hash':
            self.initIvar(ivar)</t>
<t tx="ekr.20070127142814.541">def initEncoding (self,key):
    
    '''Init g.app.config encoding ivars during initialization.'''
    
    bunch = self.encodingIvarsDict.get(key)
    encoding = bunch.encoding
    ivar = bunch.ivar

    if ivar:
        # g.trace(ivar,encoding)
        setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (ivar,encoding))</t>
<t tx="ekr.20070127142814.542">def initIvar(self,key):
    
    '''Init g.app.config ivars during initialization.
    
    This does NOT init the corresponding commander ivars.
    
    Such initing must be done in setIvarsFromSettings.'''
    
    bunch = self.ivarsDict.get(key)
    ivar = bunch.ivar # The actual name of the ivar.
    val = bunch.val

    # g.trace(ivar,val)
    setattr(self,ivar,val)</t>
<t tx="ekr.20070127142814.543">def initRecentFiles (self):

    self.recentFiles = []</t>
<t tx="ekr.20070127142814.544">def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile"""

    dirs = [] # Directories that have already been searched.
    
    for ivar,theDir in (
        ("globalConfigFile",g.app.globalConfigDir),
        ("homeFile",g.app.homeDir),
    ):

        if theDir not in dirs:
            dirs.append(theDir)
            path = g.os_path_join(theDir,"leoSettings.leo")
            if g.os_path_exists(path):
                setattr(self,ivar,path)
            else:
                setattr(self,ivar,None)
             
    if 0:   
        g.trace("globalConfigFile",g.app.globalConfigDir)
        g.trace("homeFile",g.app.homeDir)</t>
<t tx="ekr.20070127142814.545"></t>
<t tx="ekr.20070127142814.546">def canonicalizeSettingName (self,name):
    
    if name is None:
        return None

    #name = name.lower() #Jython problems
    #for ch in ('-','_',' ','\n'):
    #    name = name.replace(ch,'')
        
    return g.choose(name,name,None)
    
munge = canonicalizeSettingName</t>
<t tx="ekr.20070127142814.547">def findSettingsPosition (self,c,setting):
    
    """Return the position for the setting in the @settings tree for c."""
    
    munge = self.munge
    
    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()
        
    setting = munge(setting)
        
    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()
    
    return c.nullPosition()</t>
<t tx="ekr.20070127142814.548">def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        pass
        #d = self.localOptionsDict.get(c.hash())
        #if d:
        #    val,found = self.getValFromDict(d,setting,kind,found)
        #    if val is not None:
        #        # g.trace(c.hash(),setting,val)
        #        return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            #  g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found and self.inited:
            g.trace("Not found:",setting)

    return None</t>
<t tx="ekr.20070127142814.549">def getValFromDict (self,d,setting,requestedType,found):

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,data)
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found</t>
<t tx="ekr.20070127142814.550">def getBool (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    val = self.get(c,setting,"bool")
    
    if val in (True,False):
        return val
    else:
        return None</t>
<t tx="ekr.20070127142814.551">def getColor (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    return self.get(c,setting,"color")</t>
<t tx="ekr.20070127142814.552">def getDirectory (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None</t>
<t tx="ekr.20070127142814.553">def getFloat (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None</t>
<t tx="ekr.20070127142814.554">def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="&lt;unknown&gt;"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)</t>
<t tx="ekr.20070127142814.555">def getInt (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None</t>
<t tx="ekr.20070127142814.556">def getLanguage (self,c,setting):
    
    """Return the setting whose value should be a language known to Leo."""
    
    language = self.getString(c,setting)
    
    return language</t>
<t tx="ekr.20070127142814.557">def getRatio (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None</t>
<t tx="ekr.20070127142814.558">def getRecentFiles (self,c):
    
    # Must get c's recent files.
    return self.recentFiles</t>
<t tx="ekr.20070127142814.559">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    rawKey = key.replace('&amp;','') # Allow '&amp;' in names.
    val = self.get(c,rawKey,"shortcut")
    if val is None:
         return rawKey,None
    else:
        # g.trace(key,val)
        return rawKey,val</t>
<t tx="ekr.20070127142814.560">def getString (self,c,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""

    return self.get(c,setting,"string")</t>
<t tx="ekr.20070127142814.561"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    data = (
        ("default_tangle_directory","tangle_directory","directory"),
        ("default_target_language","target_language","language"),
        ("output_doc_chunks","output_doc_flag","bool"),
        ("page_width","page_width","int"),
        ("run_tangle_done.py","tangle_batch_flag","bool"),
        ("run_untangle_done.py","untangle_batch_flag","bool"),
        ("tab_width","tab_width","int"),
        ("tangle_outputs_header","use_header_flag","bool"),
    )
    
    for setting,ivar,theType in data:
        val = g.app.config.get(c,setting,theType)
        if val is None:
            if not hasattr(c,setting):
                setattr(c,setting,None)
        else:
            setattr(c,setting,val)</t>
<t tx="ekr.20070127142814.562">def settingsRoot (self,c):

    for p in c.allNodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()</t>
<t tx="ekr.20070127142814.563"></t>
<t tx="ekr.20070127142814.564">def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','&lt;no hash: %s&gt;' % c.hash())
        g.trace(dkind,setting,kind,val)</t>
<t tx="ekr.20070127142814.565">def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)</t>
<t tx="ekr.20070127142814.566">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)</t>
<t tx="ekr.20070127142814.567">def appendToRecentFiles (self,files):
    
    for theFile in files:
        if theFile in self.recentFiles:
            self.recentFiles.remove(theFile)
        # g.trace(theFile)
        self.recentFiles.append(theFile)</t>
<t tx="ekr.20070127142814.568"></t>
<t tx="ekr.20070127142814.569">def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    frame.c.fileCommands.open(theFile,path,readAtFileNodesFlag=False) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return c</t>
<t tx="ekr.20070127142814.570">def readSettingsFiles (self,fileName,verbose=True):
    
    munge = self.munge ; seen = []
    
    # Init settings from leoSettings.leo files.
    for path,setOptionsFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                # A print statement here is clearest.
                print "reading settings in %s" % path
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                # g.trace(c)
                if d:
                    theHash = c.hash()
                    d['_hash'] = theHash
                    # g.trace('*****',hash)
                    if setOptionsFlag:
                        self.localOptionsDict[theHash] = d
                        &lt;&lt; update recent files from d &gt;&gt;
                    else:
                        self.localOptionsList.insert(0,d)
                else:
                    g.es("No @settings tree in %s",color="red")
                g.app.destroyWindow(c.frame)

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20070127142814.571">for key in d.keys():
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files..."
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)</t>
<t tx="ekr.20070127142814.572"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.mFileName)
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d</t>
<t tx="ekr.20070127142814.573">class settingsController:
    
    @others</t>
<t tx="ekr.20070127142814.574">def __init__ (self,c,replaceBody=True):

    &lt;&lt; init ivars &gt;&gt;
    
    # Do this after defining ivars to keep pychecker happy.
    if not Pmw:
        g.trace("Setting dialog requires Pmw",color='blue')
        return

    self._settingsPosition = p = self.createSettingsTree()
    self.parser = settingsDialogParserClass(c,p,self)

    &lt;&lt; set background color for widgets &gt;&gt;
    c.disableCommandsMessage = 'All commands disabled while settings dialog is open'
    if self.replaceBody:
        &lt;&lt; replace the body pane with the outer dialog frame &gt;&gt;
        &lt;&lt; replace tree pane with settings tree &gt;&gt;
        &lt;&lt; add buttons and label to interior &gt;&gt;
        &lt;&lt; add setterCanvas to interior &gt;&gt;
        self.log = g.app.log
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
    else:
        &lt;&lt; create the dialog d &gt;&gt;
        &lt;&lt; create paneFrame, a paned widget &gt;&gt;
        &lt;&lt; create paneFrame2, a second paned widget &gt;&gt;
        &lt;&lt; create outline and log panes in paneFrame2 &gt;&gt;
        &lt;&lt; put setterCanvas in paneFrame's setter pane&gt;&gt;
        &lt;&lt; put a Text widget in the comment pane &gt;&gt;
        self.log = self.logClass(self.logText)
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
        self.center()
        if self.modal: d.activate()</t>
<t tx="ekr.20070127142814.575">self._settingsPosition = None
self.alterComments = None # position for which to alter comments.
self.alteredCommentsString = None
self.c = c
self.buttonNames = ('OK', 'Cancel','Apply','Revert')
self.colorSettingDict = {} # Contains entries for all changed colors.
self.commentWidget = None
self.commonBackground = None
self.dialog = None
self.initValueDict = {} # Initial value of settings in present pane.
self.fileValueDict = {} # Values of settings written to file.
self.filesInfoDict = {} # Info about all settings file in the settings outline.
    # Keys are positions, values are dicts giving info for a setting file.
self.fontRefs = {} # A dict to retain references to fonts.
self.modal = False
self.old_p = c.currentPosition()
self.old_root = c.rootPosition()
self.p = None # Used to revert settings.
self.panes = {}
self.parser = None
self.replaceBody = replaceBody
self.sc = None
self.setterLabel = None
self.suppressComments = None # position for which to suppress comments.
self.title = title = "Settings for %s" % g.shortFileName(c.fileName())
self.top = None
self.tree = None</t>
<t tx="ekr.20070127142814.576">if 0:
    # Get the color from the background color of the body text widget.
    commonBackground = c.frame.body.bodyCtrl.cget('background')
    
else:
    # 'LightSteelBlue1' # too blue.
    # 'gray80' # too dark.
    # 'gray90' # Possible: very light.
    # '#f2fdff' # Same as log window.  Too cute.
    
    commonBackground = 'gray90'
    
self.commonBackground = commonBackground</t>
<t tx="ekr.20070127142814.577"></t>
<t tx="ekr.20070127142814.578">body = c.frame.component('body')
packer = body.getPacker()
unpacker = body.getUnpacker()

# The new frame must be a child of splitter1Frame.
parentFrame = c.frame.component('splitter1Frame').getFrame()
self.top = interior = Tk.Frame(parentFrame,background=commonBackground)

c.frame.componentClass(c,'settingDialogFrame',interior,self,packer,unpacker)
c.frame.replaceBodyPaneWithComponent('settingDialogFrame')</t>
<t tx="ekr.20070127142814.579">tree = c.frame.component('tree')

# The new frame must be a child of splitter2Frame.
splitter2Frame = c.frame.component('splitter2Frame').getFrame()

# Create a Pmw scrolled canvas.
scrolledTreeCanvas = Pmw.ScrolledCanvas(splitter2Frame,
    hscrollmode='none',borderframe=3)

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Set canvas.name ivar for chapters.py plugin.
# This must be a tab number.  The number '1' should work well enough.
treeCanvas.name = '1'

# Create the settingsTree component.
c.frame.componentClass(c,'settingsTree',scrolledTreeCanvas,self,
    tree.getPacker(),tree.getUnpacker())

c.frame.replaceTreePaneWithComponent('settingsTree')

self.tree = settingsTree(c,c.frame,treeCanvas,self)
self.tree.setColorFromConfig()</t>
<t tx="ekr.20070127142814.580"># Put the label on the same line as the buttons.
labelButtonFrame = Tk.Frame(interior,background=commonBackground)
labelButtonFrame.pack(side='top',expand=0,fill='x',pady=4)
buttonFrame = Tk.Frame(labelButtonFrame,background=commonBackground)
buttonFrame.pack(side='left',padx=10)
labelFrame = Tk.Frame(labelButtonFrame,background=commonBackground)
labelFrame.pack(side='left')
self.setterLabel = label = Tk.Label(labelFrame,anchor='w',background=commonBackground)
label.pack(side='right')

w = 6
for name in self.buttonNames:
    w = max(w,len(name))

for name in self.buttonNames:

    def buttonCallback(name=name):
        self.onAnyButton(name)

    b = Tk.Button(buttonFrame,text=name,command=buttonCallback,width=w)
    b.pack(side='left',padx=4)</t>
<t tx="ekr.20070127142814.581">self.sc = sc = Pmw.ScrolledCanvas(interior,
    hscrollmode='dynamic',vscrollmode='dynamic',
    canvas_background = commonBackground,
    borderframe=1,
    # A fixed size here works best.
    # Pmw does not handle the changes to the canvas very well.
    usehullsize = 1,
    hull_height = 400,
    hull_width = 800,
)

sc.pack(side='top',expand=1,fill="both")</t>
<t tx="ekr.20070127142814.582"></t>
<t tx="ekr.20070127142814.583">self.dialog = d = Pmw.Dialog(
    c.frame.top,
    title=title,
    buttons=self.buttonNames,
    # It's too upsetting to have a dialog go away on a return key.
    # defaultbutton = 'OK',
    command = self.onAnyButton
)

self.top = hull = d.component('hull')
hull.minsize(800,800)

interior = d.interior()

if 0: # Do immediately
    g.app.gui.attachLeoIcon(hull)
else: # Do at idle time.
    def setIcont(top=hull):
        g.app.gui.attachLeoIcon(top)
    hull.after_idle(setIcont)</t>
<t tx="ekr.20070127142814.584">self.paneFrame = paneFrame = Pmw.PanedWidget(interior,
    separatorthickness = 4, # default is 2
    handlesize = 8, # default is 8
    command = self.onPaneResize
)
paneFrame.pack(expand = 1, fill='both')

for name,minsize,size,label,isSetterLabel in (
    ("splitter2",50,300,None,False),
    ("setter",50,300,"",False),
    ("comments",50,200,None,False),
):
    self.panes[name] = pane = paneFrame.add(name,min=minsize,size=size)
    if label is not None:
        label = label = Tk.Label(pane,text=label,background=commonBackground)
        label.pack(side = 'top', expand = 0)
        if isSetterLabel:
            self.setterLabel = label

# Set the colors of the separator and handle.
for i in (1,2):
    bar = paneFrame.component('separator-%d' % i)
    bar.configure(background='LightSteelBlue2')
    handle = paneFrame.component('handle-%d' % i)
    handle.configure(background='SteelBlue2')

# g.printDict(self.panes)</t>
<t tx="ekr.20070127142814.585">splitter2 = self.panes.get('splitter2')

self.paneFrame2 = paneFrame2 = Pmw.PanedWidget(splitter2,
    separatorthickness = 4, # default is 2
    handlesize = 8, # default is 8
    orient='horizontal',
    command = self.onPaneResize
)
paneFrame2.pack(expand = 1, fill='both')

for name,minsize,size, in (
    ('outline',50,500),
    ('log',50,300),
):
    self.panes[name] = pane = paneFrame2.add(name,min=minsize,size=size)
    
# Set the colors of the separator and handle.
i = 1
bar = paneFrame2.component('separator-%d' % i)
bar.configure(background='LightSteelBlue2')
handle = paneFrame2.component('handle-%d' % i)
handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20070127142814.586">outline = self.panes.get('outline')

# Create the widget.
self.scrolledTreeCanvas = scrolledTreeCanvas = Pmw.ScrolledCanvas(outline,
    hscrollmode='none',borderframe=3)
    
# Configure the canvas component.
scrolledTreeCanvas.pack(side='top',expand=1,fill="both")

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Create the tree.
self.tree = tree = settingsTree(c,c.frame,treeCanvas,self)

logPane = self.panes.get('log')
self.logText = logText = Tk.Text(logPane)
logText.pack(expand=1,fill="both")</t>
<t tx="ekr.20070127142814.587"># Create the widget in the 'setter' pane.
setter = self.panes.get('setter')

self.sc = sc = Pmw.ScrolledCanvas(setter,
    hscrollmode='none',vscrollmode='dynamic',
    labelpos = 'n',label_text = '')
    
sc.pack(side='top',expand=1,fill="both")

setterCanvas = sc.component('canvas')
self.setterLabel = sc.component('label')

# setterCanvas.configure(background='LightSteelBlue1')</t>
<t tx="ekr.20070127142814.588">commentFrame = self.paneFrame.pane('comments')

self.commentWidget = commentWidget = Pmw.ScrolledText(commentFrame)
commentWidget.pack(expand=1,fill="both")

self.commentText = text = commentWidget.component('text')

background = commentFrame.cget('background')
text.configure(background=background,borderwidth=0)</t>
<t tx="ekr.20070127142814.589">def createSettingsTree (self):
    
    """Create a tree of vnodes representing all settings."""
    
    createSummaryNode = True # Dithering whether to do this.
    createEmptyNodes = False

    c = self.c ; config = g.app.config
    root_p = None ; last_p = None
    for kind,path,otherFileFlag in (
        ("Global",config.globalConfigFile,True),
        ("Home",config.homeFile,True),
        ("Local",c.fileName(),False),
    ):
        if path:
            if otherFileFlag: c2 = config.openSettingsFile(path)
            else: c2 = c
            root2 = g.app.config.settingsRoot(c2)
        else:
            root2 = None
        if root2 or createEmptyNodes:
            &lt;&lt; create a node p for kind &amp; root2 &gt;&gt;
    root_p.expand()
    return root_p</t>
<t tx="ekr.20070127142814.590">if not root_p:
    t = leoNodes.tnode()
    root_v = leoNodes.vnode(c,t) # Using c2 --&gt; oops: nullTree.
    root_p = leoNodes.position(root_v,[])
    if createSummaryNode:
        root_p.initHeadString("All settings")
        root_p.scriptSetBodyString(self.rootNodeComments())
        p = root_p.insertAsLastChild()
    else:
        p = root_p.copy()
else:
    p = last_p.insertAfter()

if root2:
    root2.copyTreeFromSelfTo(p)  # replace p by root2.

self.copyExpansionState(root2,p)
p.expand() # Always expand the top-level node

&lt;&lt; add entry for p to filesInfoDict &gt;&gt;

path2 = g.choose(otherFileFlag,path,g.shortFileName(path))
p.initHeadString("%s settings: %s" % (kind,path2))
last_p = p</t>
<t tx="ekr.20070127142814.591">self.filesInfoDict[p] = {
    'c': c2,
    'changes': [],
    'p': p.copy(),
    'path': path,
    'isLocal':  not otherFileFlag,
}</t>
<t tx="ekr.20070127142814.592">def rootNodeComments(self):
    
    c = self.c ; fileName = g.shortFileName(c.mFileName)
    
    s = """This tree shows Leo's global and home settings, as well as the local settings in %s."""\
        % (fileName)
    
    return s</t>
<t tx="ekr.20070127142814.593">def createWidgets (self,widgets,parent,p):
    
    munge = g.app.config.munge

    &lt;&lt; define creatorDispatchDict &gt;&gt;
    
    # self.printWidgets(widgets)
    
    self.h = 0 # Offset from top of pane for first widget.
    self.createSpacerFrame(parent,size=15)
    
    self.createComments(parent,p)
            
    for data in widgets:
        p,kind,name,vals = data
        if kind.startswith('ints'):
            self.createInts(parent,p,kind,name,vals)
        if kind.startswith('strings'):
            self.createStrings(parent,p,kind,name,vals)
        else:
            f = creatorDispatchDict.get(munge(kind))
            if f is not None:
                try:
                    f(parent,p,kind,name,vals)
                except TypeError:
                    g.es_exception()
                    g.trace("***No handler***",kind)</t>
<t tx="ekr.20070127142814.594">creatorDispatchDict = {
    'bool':         self.createBool,
    'color':        self.createColor,
    'directory':    self.createDirectory,
    'font':         self.createFont,
    'int':          self.createInt,
    'ints':         self.createInts,
    'float':        self.createFloat,
    'path':         self.createPath,
    'ratio':        self.createRatio,
    'recentfiles':  self.createRecentFiles,
    'shortcut':     self.createShortcut,
    'shortcuts':    self.createShortcuts,
    'string':       self.createString,
    'strings':      self.createStrings,
}</t>
<t tx="ekr.20070127142814.595">def createBool (self,parent,p,kind,name,val):
    
    val = g.choose(val.lower()=='true',1,0)

    # Inits the checkbutton widget. 
    var = Tk.IntVar()
    var.set(val)

    def boolCallback():
        val2 = g.choose(var.get(),True,False)
        # g.trace(name,val2)
        return val2
    
    val = g.choose(val,True,False)
    self.initValue(p,name,kind,val,boolCallback)

    box = Tk.Checkbutton(parent,text=name,variable=var,background=self.commonBackground)

    self.sc.create_window(10,self.h,anchor='w',window=box)
    self.h += 30</t>
<t tx="ekr.20070127142814.596">def createColor (self,parent,p,kind,name,val):
    
    munge = g.app.config.munge
    noColor = "&lt;no color&gt;"
    colorNamesList = list(leoTkinterColorPanels.colorNamesList)
    
    f = Tk.Frame(parent,background=self.commonBackground) # No need to pack.
    &lt;&lt; munge val and add val to colorNamesList &gt;&gt;
    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;
    Tk.Label(f,text=name,background=self.commonBackground).pack(side='left')
    
    self.colorSettingDict [munge(name)] = val

    def getColorCallback ():
        return self.colorSettingDict.get(munge(name))

    self.initValue(p,name,kind,val,getColorCallback)

    self.sc.create_window(15,self.h+8,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.597">if val in ("None",None): val = noColor
val = str(val) # Get rid of unicode.

if noColor in colorNamesList:
    colorNamesList.remove(val)
if val is not noColor and val not in colorNamesList:
     colorNamesList.append(val)
colorNamesList.sort()
colorNamesList.insert(0,noColor)

initVal = val
if val is noColor: val = None</t>
<t tx="ekr.20070127142814.598">colorBox = Pmw.ComboBox(f,scrolledlist_items=colorNamesList)
colorBox.selectitem(initVal)
colorBox.pack(side="left",padx=2)

color = g.choose(val is None,f.cget('background'),val)
colorSample = Tk.Button(f,width=8,background=color)
colorSample.pack(side='left',padx=2)

def colorCallback (newName):
    # g.trace(repr(newName))
    if not newName or newName.lower() in ('none','&lt;none&gt;','&lt;no color&gt;'):
        self.colorSettingDict[munge(name)] = None
        color = f.cget('background')
        colorSample.configure(background=color)
    else:
        try:
            colorSample.configure(background=newName)
            self.colorSettingDict[munge(name)] = g.choose(newName is noColor,None,newName)
        except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20070127142814.599">def pickerCallback (color=val):

    rgb,val = tkColorChooser.askcolor(parent=parent,color=color)
    if rgb or val:
        # g.trace(rgb,val)
        self.colorSettingDict[munge(name)] = val
        colorSample.configure(background=val,activebackground=val,text=val)

b = Tk.Button(f,text="Color Picker...",command=pickerCallback,background=self.commonBackground)
b.pack(side="left")</t>
<t tx="ekr.20070127142814.600">def createComments (self,parent,p):
    
    bg = self.commonBackground

    s = p.bodyString().strip()
    if not s:
        return
    
    f = Tk.Frame(parent,background=bg) # No need to pack.
    
    if 0: # atoi problem.
        group = Pmw.Group(f,tag_text='comments',hull_background = bg)
        group.pack(side='left',padx=6,pady=6)
        label = Tkinter.Label(group.interior(),text=s)
        label.pack(padx=2,pady=2,expand=1,fill='both')
    else:
        scrolled_text = Pmw.ScrolledText(f,
            labelpos = 'ew',label_text='comments',
            hull_background=bg,
            hull_bd=2,hull_relief='groove',
            hull_padx=6,hull_pady=6,
            text_background=bg,
            text_padx=6,text_pady=6,
            text_bd=2,text_relief='sunken',
            label_background=bg,
            text_height=5,text_width=80)
        scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
        t = scrolled_text.component('text')
        t.insert('end',s)
        t.configure(state='disabled')
        hull=scrolled_text.component('hull')
        

    item = self.sc.create_window(10-2,self.h,anchor='w',window=f)
    # bbox=hull.bbox() ; print bbox # (0,0,0,0)
    
    self.h += 70</t>
<t tx="ekr.20070127142814.601">def createDirectory (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20070127142814.602">def createFloat (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent,background=bg)
    Tk.Entry(f,textvariable=var,background=bg).pack(side='left')
    Tk.Label(f,text=name,background=self.bg).pack(side='left')
    
    def floatCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,floatCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.603">def createFont (self,parent,p,kind,fontName,val):
    
    """Create a font picker.  val is a dict containing the specified values."""
    bg = self.commonBackground
    d = val ; widgets = {}
    munge = g.app.config.munge
    f = Tk.Frame(parent,background=bg) # No need to pack.
    self.alterComments = p.copy()
    self.alteredCommentsString = d.get('comments')
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    Tk.Label(f,text=fontName,background=bg).pack(side='left')
    &lt;&lt; define fontCallback &gt;&gt;

    familyBox.configure(selectioncommand=fontCallback)
    slantBox.configure(selectioncommand=fontCallback)
    weightBox.configure(selectioncommand=fontCallback)

    self.initValue(p,munge(fontName),'font',d,fontCallback)

    self.sc.create_window(15,self.h,anchor='w',window = f)
    self.h += 30</t>
<t tx="ekr.20070127142814.604">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

data = d.get('family')
initialitem = 0
if data:
    name2,val = data
    if val and val in names:
        initialitem = names.index(val)

familyBox = Pmw.ComboBox(f,
    labelpos="we",label_text='Family:',
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(initialitem)
familyBox.pack(side="left",padx=2)</t>
<t tx="ekr.20070127142814.605">Tk.Label(f,text="Size:",background=bg).pack(side="left")

sizeEntry = Tk.Entry(f,width=4)
sizeEntry.pack(side="left")

data = d.get('size')
if data:
    kind,val = data
    if val not in (None,'None','none'):
        try:
            n = int(val)
            sizeEntry.insert('end',val)
        except ValueError:
            s = "invalid size: %s" % val
            print s ; self.es(s,color="blue")</t>
<t tx="ekr.20070127142814.606">initialitem = 0
values = ['&lt;None&gt;','normal','bold']
data = d.get('weight')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

weightBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Weight:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

weightBox.selectitem(initialitem)
weightBox.pack(side="left",padx=2)</t>
<t tx="ekr.20070127142814.607">initialitem = 0
values=['&lt;None&gt;','roman','italic']
data = d.get('slant')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

slantBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Slant:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

slantBox.selectitem(initialitem)
slantBox.pack(side="left",padx=2)</t>
<t tx="ekr.20070127142814.608">def fontCallback(*args,**keys):
    
    d2 = d.copy() # The update logic must compare distinct dicts.
    
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:   val = sizeEntry.get().strip()
        if not val or  val.lower() in ('none','&lt;none&gt;',): val = None

        data = d.get(key)
        name,oldval = data
        d2[key] = name,val
    
    return d2</t>
<t tx="ekr.20070127142814.609">def createInt (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')

    def intCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
    
    self.initValue(p,name,kind,val,intCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.610">def createInts (self,parent,p,kind,name,val):
    
    # g.trace(repr(kind),repr(name),val)
    
    bg = self.commonBackground
    
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 &lt; i &lt; j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'&lt;none&gt;')
    
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent)

    intsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background=bg,
        scrolledlist_items=items)

    intsBox.selectitem(initialitem)
    intsBox.pack(side="left",padx=2)
    
    def intsCallback():
        val2 = intsBox.get()
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val

    self.initValue(p,name,kind,val,intsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.611">def createPath (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20070127142814.612">def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return g.choose(0.0 &lt;= val2 &lt;= 1.0,val2,val)
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.613">def createRecentFiles (self,parent,p,kind,name,vals):
    
    bg = self.commonBackground
    
    s = p.bodyString()
    lines = g.splitLines(s)
    
    f = Tk.Frame(parent)
    
    recentFilesBox = Pmw.ComboBox(f,
        labelpos="ew",label_text='recent files',
        label_background = bg,
        scrolledlist_items=lines)

    if lines:
        recentFilesBox.selectitem(0)
    recentFilesBox.pack(side="left")
    
    # Increase the width of the entry field.
    entryfield = recentFilesBox.component('entryfield')
    entry = entryfield.component('entry')
    entry.configure(width=70)

    def recentFilesCallback():
        files = recentFilesBox.get(0,'end')
        files = [theFile.strip() for theFile in files if theFile.strip()]
        return files

    self.initValue(p,name,kind,vals,recentFilesCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
                
    self.suppressComments = p.copy()</t>
<t tx="ekr.20070127142814.614">def createShortcut (self,parent,p,kind,name,val):
    
    g.trace(name,val)
    
    if name:
        self.createString(parent,p,kind,name,val)</t>
<t tx="ekr.20070127142814.615">def createShortcuts (self,parent,p,kind,name,vals):
    
    s = p.bodyString()
    lines = g.splitLines(s)
    
    for line in lines:
        if not g.match(line.strip(),0,'#'):
            name,val = self.parser.parseShortcutLine(line)
            if name:
                self.createString(parent,p,kind,name,val)

    self.suppressComments = p.copy()</t>
<t tx="ekr.20070127142814.616">def createSpacerFrame (self,parent,size=10):
    
    f = Tk.Frame(parent)
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += size</t>
<t tx="ekr.20070127142814.617">def createString (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    if val in (None,'None'): val = ""
    
    # Inits the Entry widget.
    var = Tk.StringVar()
    var.set(val)
    
    f = Tk.Frame(parent) # No need to pack.
    Tk.Entry(f,textvariable=var,width=40).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def stringCallback():
        val = var.get()
        # g.trace(name,val)
        return val

    self.initValue(p,name,kind,val,stringCallback)
    
    self.sc.create_window(15,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.618">def createStrings (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # g.trace(repr(kind),repr(name),val)
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 &lt; i &lt; j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'&lt;none&gt;')
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent,background=bg)

    stringsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background = bg,
        scrolledlist_items=items)

    stringsBox.selectitem(initialitem)
    stringsBox.pack(side="left",padx=2)
    
    def stringsCallback():
        return stringsBox.get()

    self.initValue(p,name,kind,val,stringsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30</t>
<t tx="ekr.20070127142814.619"></t>
<t tx="ekr.20070127142814.620">def onAnyButton(self,name):
    
    c = self.c
    endDialog = name in (None,"OK","Cancel")
    
    # g.trace(name)
    
    dispatchDict = {
        "Apply":    self.writeChangedVars,
        "Cancel":   None, # Do nothing.
        "OK":       self.writeChangedVars,
        "Revert":   self.revert,
    }
    
    f = dispatchDict.get(name)
    if f: f()
        
    if self.replaceBody:
        if endDialog:
            c.frame.replaceTreePaneWithComponent('tree')
            c.frame.replaceBodyPaneWithComponent('body')
            c.disableCommandsMessage = '' # Re-enable all commands.
    else:
        if endDialog:
            self.dialog.destroy()
            c.disableCommandsMessage = '' # Re-enable all commands.
        else:
            self.dialog.withdraw()
            self.dialog.deiconify()</t>
<t tx="ekr.20070127142814.621">def revert (self):
    
    """Restores written vars to initial value and re-inits all widgets."""
    
    iDict = self.initValueDict
    fDict = self.fileValueDict
    munge = g.app.config.munge
    
    changedList = []
    for key in fDict.keys():

        fData = fDict.get(key)
        fp,fname,fkind,fval,getValueCallback = fData
        
        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData

        assert(ip==fp and iname==fname and ikind==fkind)
        # print "revert",key,"ival",ival,"fval",fval
        
        if ival != fval:
            # print "revert %10s -&gt; %10s %s" % (str(fval),str(ival),fname)
            self.fileValueDict [munge(iname)] = ip,iname,ikind,ival,getValueCallback
            changedList.append((ip,iname,ikind,fval,ival),)

    self.updateSetter(self.p,updateDicts=False)
    self.writeChangedList(changedList,"revert")
    self.updateSetter(self.p) # Redraw the widgets in the pane.</t>
<t tx="ekr.20070127142814.622">def onPaneResize (self,sizes=None):

    self.sc.resizescrollregion()</t>
<t tx="ekr.20070127142814.623">def onTreeClick (self,p):
    
    self.p = p.copy()
    self.updateSetter(p)</t>
<t tx="ekr.20070127142814.624"></t>
<t tx="ekr.20070127142814.625">def findCorrespondingNode (self,root1,root2,p1):
    
    """Return the node corresponding to p1 (in root1) in the root2's tree."""
    
    if p1 == root1: return root2
    
    # Go up tree 1, computing child indices.
    childIndices = []
    for p in p1.self_and_parents_iter():
        #g.trace(p)
        if p == root1: break
        childIndices.append(p.childIndex())
        
    childIndices.reverse()
    #g.trace(childIndices)
    
    # Go down tree 2, moving to the n'th child.
    p2 = root2.copy()
    for n in childIndices:
        #g.trace(p2)
        p2.moveToNthChild(n)

    # g.trace(p2)
    return p2</t>
<t tx="ekr.20070127142814.626">def findSettingsRoot (self,p):
    
    first_p = p.copy()
    
    # Get the list of root positions.
    roots = self.filesInfoDict.keys()

    for p in p.self_and_parents_iter():
        for root in roots:
            if p == root:
                # g.trace("root of %s is %s" % (first_p.headString(),p.headString()))
                return root # Used as key.  Must NOT return a copy.
                
    g.trace("Can't happen: %s has no root node" % (first_p.headString()))
    return None</t>
<t tx="ekr.20070127142814.627">def settingsPosition (self):
    
    return self._settingsPosition.copy()</t>
<t tx="ekr.20070127142814.628"></t>
<t tx="ekr.20070127142814.629">def updateSetter (self,p,updateDicts=True):
    
    """Create a setter pane for position p."""
    
    sc = self.sc ; interior = sc.interior()
    
    if updateDicts:
        self.fileValueDict = {}
        self.initValueDict = {}
        self.colorSettingDict = {}
    
    # Destroy the previous widgets
    for w in interior.winfo_children():
        w.destroy()

    # Visit the node, and possibly its subtree, looking for widgets to create.
    self.parser.widgets = []
    self.parser.visitNode(p)
    if self.parser.widgets:
        self.createWidgets(self.parser.widgets,interior,p)
        
    self.sc.resizescrollregion()
    self.sc.yview('moveto',0)
    self.updateSetterLabel(p)</t>
<t tx="ekr.20070127142814.630">def updateSetterLabel (self,p):
    
    if self.setterLabel:

        h = p.headString().strip() or ''

        for name in ('@page','@font','@ignore','@'):
            if g.match(h,0,name):
                h = h[len(name):].strip()
                i = h.find('=')
                if i &gt; -1:
                    h = h[:i].strip()
                break

        self.setterLabel.configure(text=h)
        return h
        
    else:
        return None</t>
<t tx="ekr.20070127142814.631">@ These keep track of the original and changed values of all items in the present setter pane.</t>
<t tx="ekr.20070127142814.632">def initValue (self,p,name,kind,val,getValueCallback):
    
    munge = g.app.config.munge
    
    # g.trace(name,kind,val)
    
    self.initValueDict [munge(name)] = (p,name,kind,val,getValueCallback)</t>
<t tx="ekr.20070127142814.633">def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '&lt;none&gt;'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
                print s ; g.es(s,color='blue')
            else:
                s = "write  %10s -&gt; %10s %s" % (str(oldVal),str(newVal),iname)
                print s ; g.es(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")</t>
<t tx="ekr.20070127142814.634">def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        elif munge(name) == "recentfiles":
            c.setRecentFiles(val)
        else:
            g.app.config.set(c,name,kind,val)</t>
<t tx="ekr.20070127142814.635">def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root 1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1).copy()
    c1 = root1.c
    
    # Root is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    # g.trace(root2.c.mFileName)
    p2 = self.findCorrespondingNode(root1,root2,p1)
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in",root2.c.mFileName)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind in ('shortcuts','recentfiles'):
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(p,val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))</t>
<t tx="ekr.20070127142814.636">def computeBodyFromFontDict(self,p,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'&lt;none&gt;'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body</t>
<t tx="ekr.20070127142814.637">def writeChangedList (self,changedList,tag):
    
    if not changedList: return
    
    filesInfoDict = self.filesInfoDict
    if 0:
        &lt;&lt; dump all the dicts in filesInfoDict &gt;&gt;

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -&gt; %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # isLocal = rootDict.get('isLocal')
        if changes:
            self.writeChangesToFile(c,changes,path)
            self.updateConfig(c,changes)
        d['changes'] = []</t>
<t tx="ekr.20070127142814.638">for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print</t>
<t tx="ekr.20070127142814.639">def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)

    if c.mFileName:
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.mFileName)
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."</t>
<t tx="ekr.20070127142814.640"></t>
<t tx="ekr.20070127142814.641">class logClass:
    
    def __init__ (self,textWidget):
        self.textWidget = textWidget
        self.colorTags = []
        
    def put(self,s,color=None):
        w = self.textWidget
        &lt;&lt; put s to w &gt;&gt;
        
    def putnl (self):
        w = self.textWidget
        if sys.platform == "darwin": print
        w.insert("end",'\n')
        w.see("end")
        w.update_idletasks()</t>
<t tx="ekr.20070127142814.642">if type(s) == type(u""):
    s = g.toEncodedString(s,g.app.tkEncoding)
    
if sys.platform == "darwin": print s,

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        w.tag_config("black",foreground="black")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see("end")
w.update_idletasks()</t>
<t tx="ekr.20070127142814.643">def center(self):
    
    top = self.top

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info()
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20070127142814.644">def es(self,*args,**keys):
    
    old_log = g.app.log
    g.app.log = self.log
    g.es(*args,**keys)
    g.app.log = old_log</t>
<t tx="ekr.20070127142814.645">def copyExpansionState(self,p1,p2):
 
    # Don't depend on p.nodeAfterTree, etc.
    if p1.isExpanded():
        # g.trace("p1",p1)
        # g.trace("p2",p2)
        p2.expand()
        child1 = p1.firstChild()
        child2 = p2.firstChild()
        while child1:
            self.copyExpansionState(child1,child2)
            child1 = child1.next()
            child2 = child2.next()</t>
<t tx="ekr.20070127142814.646"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self):
    
    top = self.top
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = geom.split('+')
    w,h = dim.split('x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20070127142814.647">def printChangedVars (self):

    d = self.initValueDict
    
    for key in d.keys():
        
        data = d.get(key)
        p,name,kind,val,getValueCallback = data
        newVal = getValueCallback()
        
        if val != newVal:
            print "%10s -&gt; %10s %s" % (str(val),str(newVal),name)</t>
<t tx="ekr.20070127142814.648">def printWidgets (self,widgets):

    print '-'*20

    for data in widgets:
        p,kind,name,vals = data
        if type(vals) == type([]):
            print "%s %s..." % (name,kind)
            for val in vals:
                print val
        else:
            print "%45s %8s %s" % (name,kind,vals)</t>
<t tx="ekr.20070127142814.649">class settingsDialogParserClass (parserBaseClass):
    
    '''A class that traverses the settings tree creating
    a list of widgets to show in the settings dialog.'''
    
    @others
</t>
<t tx="ekr.20070127142814.650">def __init__ (self,c,p,dialogController):
    
    # There is no need to call the base class ctor.
    
    self.c = c
    self.root = p.copy()
    self.widgets = [] # A list of widgets to create in the setter pane.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.set,
        'color':        self.set,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        None,
        'ifplatform':   None,
        'ignore':       None,
        'int':          self.set,
        'ints':         self.doInts,
        'float':        self.set,
        'font':         self.doFont,
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.set,
        'recentfiles':  self.doRecentFiles,
        'shortcut':     None,
        'shortcuts':    self.doShortcuts,
        'string':       self.set,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20070127142814.651">def set (self,p,kind,name,val):
    
    self.widgets.append((p.copy(),kind,name,val),)</t>
<t tx="ekr.20070127142814.652">def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind))
    if f is not None:
        try:
            f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind</t>
<t tx="ekr.20070127142814.653"># Most of the work is done by base class methods.</t>
<t tx="ekr.20070127142814.654">def doFont (self,p,kind,name,val):

    d = self.parseFont(p)
    # g.trace("\n\nfont dict...\n%s" % g.dictToString(d))
    self.set(p,kind,name,d)</t>
<t tx="ekr.20070127142814.655">def doPage(self,p,kind,name,val):
    
    """Create a widget for each setting in the subtree."""

    for p in p.subtree_iter():
        self.visitNode(p)</t>
<t tx="ekr.20070127142814.656">def doBodyPaneList (self,p,kind,name,val):

    s = p.bodyString()
    lines = g.splitLines(s)

    vals = []
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            vals.append(line)
                
    self.set(p,kind,name,vals)

doRecentFiles = doBodyPaneList
</t>
<t tx="ekr.20070127142814.657">def doShortcuts(self,p,kind,name,val):

    s = p.bodyString()
    lines = g.splitLines(s)

    vals = []
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            if val is not None:
                vals.append((name,val),)
                
    self.set(p,kind,name,vals)</t>
<t tx="ekr.20070127142814.658">#class settingsTree (leoTkinterTree.leoTkinterTree):
class settingsTree( leoSwingFrame.leoSwingTree ):

    @others</t>
<t tx="ekr.20070127142814.659">def __init__(self,c,frame,canvas,controller):
    
    # Init the base class.
    leoTkinterTree.leoTkinterTree.__init__(self,c,frame,canvas)
    
    self.controller = controller
    self.old_p = None</t>
<t tx="ekr.20070127142814.660"># This code is different because this class has a different current position.

</t>
<t tx="ekr.20070127142814.661">def configureTextState (self,p):
    
    if p:
        t = self.getTextWidget(p)
        if t:
            if p.isCurrentPosition():
                self.setSelectColors(t)
            else:
                self.setUnselectColors(t)</t>
<t tx="ekr.20070127142814.662">def setSelectColors (self,textWidget): 
    
    c = self.c

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'white'

    try:
        textWidget.configure(state="disabled",
        highlightthickness=0,fg=fg,bg=bg,
        selectforeground=fg,selectbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20070127142814.663">def setUnselectColors (self,textWidget): 
    
    c = self.c
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'

    try:
        textWidget.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20070127142814.664">def endEditLabel (self):
    
    pass # Editing is not allowed.</t>
<t tx="ekr.20070127142814.665">def editLabel (self,p):
    
    pass # Editing is not allowed.</t>
<t tx="ekr.20070127142814.666">def select (self,p,updateBeadList=True):

    old_p = self.old_p

    # Unselect the old
    if old_p:
        t = self.getTextWidget(old_p)
        if t: self.setUnselectColors(t)

    # Select the new
    t = self.getTextWidget(p)
    if t: self.setSelectColors(t)
    
    # N.B. Do not change the commander's notion of the present position.
    self.old_p = p

    self.controller.onTreeClick(p)</t>
<t tx="ekr.20070127142814.667">def getTextWidget (self,p):
    
    # The data is create in newText.
    data = self.visibleText.get(p.v)
    if data:
        data = data[0] # A list of one element.
        # g.trace(len(data),data)
        p2,t,theId = data
        return t
    else:
        return None</t>
<t tx="ekr.20070127142814.668"></t>
<t tx="ekr.20070127142814.669">def expandAllAncestors (self,p):
    
    # This would be harmful because p is always c.currentPosition().

    return False # redraw_flag</t>
<t tx="ekr.20070127142814.670">def onClickBoxClick (self,event):
    
    tree = self

    p = self.eventToPosition(event)
    if not p: return

    # g.trace(p.isExpanded(),p.headString())

    if p.isExpanded(): p.contract()
    else:              p.expand()

    tree.active = True
    tree.redraw()
    tree.select(p)</t>
<t tx="ekr.20070127142814.671">def drawTopTree (self):
    
    """Draw the settings tree, i.e., the tree rooted at self.controller.settingsPosition()."""
    
    c = self.c ; canvas = self.canvas
    p = self.controller.settingsPosition()
    self.redrawing = True
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    self.prevPositions = g.app.positions
    
    # Draw only the settings tree
    self.drawTree(p,self.root_left,self.root_top,0,0)

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.
    self.redrawing = False</t>
<t tx="ekr.20070127142814.672">class settingsTreeParser (parserBaseClass):
    
    '''A class that inits settings found in an @settings tree.
    
    Used by read settings logic.'''
    
    @others</t>
<t tx="ekr.20070127142814.673">def __init__ (self,c):

    # Init the base class.
    parserBaseClass.__init__(self,c)</t>
<t tx="ekr.20070127142814.674">def visitNode (self,p):
    
    """Init any settings found in node p."""
    
    # g.trace(p.headString())
    
    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind == "settings":
        pass
    elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all data types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
    elif name:
        # self.error("unknown type %s for setting %s" % (kind,name))
        # Just assume the type is a string.
        self.set(p,kind,name,val)</t>
<t tx="ekr.20070127142814.675">@language java
import java.io.*;
import java.util.jar.*;
import java.util.*;
import java.net.*;

public class ClassLoaderBase extends ClassLoader{

    List&lt;JarFile&gt; jars;
    Map&lt;String,String&gt; resources;
    List&lt;String&gt; searchpaths;
    
    public ClassLoaderBase(){
        jars = new ArrayList&lt;JarFile&gt;();
        searchpaths = new ArrayList&lt;String&gt;();
        resources = new HashMap&lt;String,String&gt;();
    }

    public void resolve( Class c ){
        resolveClass( c );
    }

    public Class findLoadedClass2( String name ){
        return findLoadedClass( name );
    }
    
    public Class getClassFromResource( String name ){
    
        List&lt;Byte&gt; data = new ArrayList&lt;Byte&gt;();
        try{
            //System.out.println( name );
            //System.out.println( resources.get( name ) );
            InputStream ins = getResourceAsStream( name );
            //System.out.println( ins );
            while( true ){
                    
                    int i = ins.read();
                    if( i == -1 ) break;
                    byte b = (byte)i;
                    data.add( b );
                }
                ins.close(); 
        }
        catch( IOException io ){ return null;}
        byte[] bdata = new byte[ data.size() ];
        for( int i = 0; i &lt; bdata.length; i ++ ) bdata[ i ] = data.get( i );
        Class c = defineClass( name, bdata, 0, bdata.length );
        return c;
    }    

    public Class loadClass( String name ) throws ClassNotFoundException{
        
        //System.out.println( "LOADING:" + name );
        Class c = findLoadedClass( name );
        if( c != null ) return c;
        //System.out.println( "TRYING RESOURCE!" );
        if( resources.containsKey( name ) ){
             c = getClassFromResource( name );
             if( c != null ) return c;
        }
        //System.out.println( "TRYING JAR!" );
        c = getClassFromJar( name );
        if( c != null ) return c;
        //System.out.println( "LODING FROM SUPER!" );
        return super.loadClass( name );
    }
    
    public void addResource( String name, String location ){
        resources.put( name, location );
    
    }
    
    @Override
    public URL getResource( String name ){
        //System.out.println( "URRRLLLLLLL GETTTING RESOURCE!!!!:" + name );
        if( resources.containsKey( name ) ){
            File f = new File( resources.get( name ) );
            try{
                return f.toURL();
            }
            catch( MalformedURLException mue ){}
        }
        for( String s: searchpaths ){
        
            File f = new File( s );
            String[] children = f.list();
            for( String child: children ){
                if( child.equals( name ) ){
                    try{
                        File target = new File( f, name );
                        return target.toURL();
                    }
                    catch( MalformedURLException mue ){}
                }
            }
        }
        for( JarFile jf: jars ){
            
            JarEntry je = jf.getJarEntry( name );
            if( je != null ){
             //System.out.println( "A HIT!@!!!!" );
             String jurl = "jar:file:" + jf.getName() + "!/" + name;
             //System.out.println( jurl );
             try{
                return new URL( jurl );
             }
             catch( MalformedURLException mue ){  return null;}
             
             }
        }
        //System.out.println( "I DID NOT FIND " + name );
        URL rv = super.getResource( name );
        //System.out.println( "I DID FIND THIS: " + rv );
        return rv;
    }
    
    @Override
    public InputStream getResourceAsStream( String name ){
        
        if( name == null ) return null;
        //System.out.println( "GETTING RESOURCE!!!" + name );
        if( resources.containsKey( name ) ){
        
            try{
                File f = new File( resources.get( name ) );
                FileInputStream fis = new FileInputStream( f );
                return fis;
            }
            catch( FileNotFoundException fnfe ){ System.out.println( fnfe );}
        
        }
        for( String s: searchpaths ){
        
            //System.out.println( s );
            File f = new File( s );
            String[] children = f.list();
            for( String child: children ){
                if( child.equals( name ) ){
                    try{
                        File target = new File( f, name );
                        FileInputStream fis = new FileInputStream( target );
                        return fis;
                    }
                    catch( FileNotFoundException fnfe ){}
                }
            }
        }
        for( JarFile jf: jars ){
            
            JarEntry je = jf.getJarEntry( name );
            if( je != null ){
                
                try{
                    InputStream ins = jf.getInputStream( je );
                    return ins;
                }
                catch( IOException io ){}
            
            
            }
        
        
        }
        //System.out.println( "I DID NOT FIND " + name );
        return super.getResourceAsStream( name );
    
    
    }
    
    public void addSearchPath( String path ){
    
        searchpaths.add( path );
    
    
    }
    
    public Class getClassFromJar( String name ){
        

        String[] path = name.split( "\\." );
        StringBuilder sb = new StringBuilder();
        for( String s: path ){
        
            sb.append( s ).append( '/' );
        
        }

        sb.deleteCharAt( sb.length() - 1 );
        sb.append( ".class" );
        String newpath = sb.toString();
        //System.out.println( "LOOKING FOR:" + newpath );
        JarFile jf = null;
        JarEntry je = null;
        for( JarFile j: jars ){
            je = j.getJarEntry( newpath );
            if( je != null ){
            
                jf = j;
                break;
            
            
            }
        
        
        }
        if( je != null ){
            
            List&lt;Byte&gt; data = new ArrayList&lt;Byte&gt;();
            //System.out.println( "SIZE : " + je.getSize() );
            try{
                InputStream ins = jf.getInputStream( je );
                while( true ){
                    
                    int i = ins.read();
                    if( i == -1 ) break;
                    byte b = (byte)i;
                    data.add( b );
                
                }
                ins.close();
        
            }
            catch(IOException io ){}
            //System.out.println( data.size() );
            byte[] bdata = new byte[ data.size() ];
            for( int i = 0; i &lt; bdata.length; i ++ ) bdata[ i ] = data.get( i );
            //System.out.println( "FOUND:" + newpath );
            //System.out.println( "PREPARING TO LOAD:" + name );
            if( name.startsWith( "org.xml.sax" ) ){
                //System.out.println( "RETURNING NULL!" );
                return null;
                
            }
            Class c = defineClass( name, bdata, 0, bdata.length );
            return c;
        
        }
        
        
       return null; 
    
    }
    
    public void addJar( String name ){
    
        File f = new File( name );
        if( f.exists() &amp;&amp; !f.isDirectory() ){
            try{
                jars.add( new JarFile( f ) );
            }
            catch(IOException io ){ System.out.println( io );}
        }
    
    }


}
/*

&lt;&lt;JFreeReportClassLoader&gt;&gt;
*/
</t>
<t tx="ekr.20070127142814.676">import ClassLoaderBase
class JFreeReportClassLoader( ClassLoaderBase ):
    
    def __init__( self ):
        jlang.ClassLoader.__init__( self )
        self.jars = []
        self.loaded = {}
        
    def walkAndAdd( self, path ):
        
        import os.path
        os.path.walk( path, self.callback, path )
    
    def callback( self, arg, dirpath, namelist ):
        print arg
        print dirpath
        print namelist
        print "PATH %s " % dirpath[ len( arg ): ]
        path = dirpath[ len( arg ): ]
        if path.startswith( "/jfreereport" ):
            print "ADDING!!!"
            for z in namelist:
                if z.endswith( ".jar" ):
                    self.addJar( "%s/%s" % ( dirpath, z ) )
        
    
    def addJar( self, jarfile ):
        print jarfile
        f = io.File( jarfile )
        if f.exists() and not f.isDirectory():
            self.jars.append( jar.JarFile( f ) )
    
    def getClassFromJar( self, classname, resolve = False ):
        
        #print "RESOLVE? %s" % resolve
        if self.loaded.has_key( classname ): return self.loaded[ classname ]
        
        path = classname.split( "." )
        name =  '/'.join( path ) +".class"
        #print name
        for z in self.jars:
            #print z
            je = z.getJarEntry( name )
            if je:
                jar = z
                break
            
        if je:
            #print "JE HIT!!!"
            ins = jar.getInputStream( je )
            data = []
            while 1:
                byte = ins.read()
                if byte == -1: break
                data.append( jlang.Integer( byte ).byteValue() )
            import jarray
            bdata = jarray.array( data, 'b' )
            print "Defining %s" % classname
            clazz = self.defineClass(  classname, bdata, 0, len( bdata ) )
            #print "PAST DEFINE!"
            self.loaded[ classname ] = clazz
            if resolve:
                #print "RESOLVING!"
                self.resolveClass( clazz )
            print "Returning %s " % clazz 
            return clazz
        return None
    
    def resolveClass( self, clazz ):
        self.super__resolveClass( clazz )
    
    def defineClass( self, *args ):
        return self.super__defineClass( *args )   
        
    def loadClass( self, *name ):
        
        #print name
        clazz = self.findLoadedClass2( name[ 0 ] )
        if clazz: return clazz
        if self.loaded.has_key( name[ 0 ] ): return self.loaded[ name[ 0 ] ]
        clazz = self.getClassFromJar( *name )
        #print "CLASSSS!!! %s" % clazz
        if clazz:
            self.loaded[ name[ 0 ] ] = clazz 
            return clazz
        else:
            #print "DOING A SUPER CALL! %s" % name[ 0 ]
            return self.super__loadClass( *name )
            

</t>
<t tx="ekr.20070127142814.677">import javax.print as jprint
import javax.print.attribute as jatt
import javax.print.event as jevent
import javax.swing as swing
import java.lang as jlang
import java.io as io
import java.util as util
import java.util.jar as jar
import java
import javax.imageio as imio
import javax.imageio.stream as imstream
import leoGlobals as g
from utilities.DefCallable import DefCallable
jfree_ok = 0
jfree_loaded = 0
try:
    pass
    #import org.jfree.report as jreport
    #import org.jfree.report.modules.gui.base as jbase
    #import org.jfree.report.elementfactory.TextFieldElementFactory as factory
    #import org.jfree.ui.FloatDimension as FloatDimension
    #jfree_ok = 1
    
except:
    pass

    
&lt;&lt;JFreeReportClassLoader&gt;&gt;
try:
    jfcl = JFreeReportClassLoader()
    f = io.File( g.app.loadDir )
    pf = f.getParent()
    jf = io.File( pf, "jars" )
    jfcl.walkAndAdd( jf.getAbsolutePath() )

    def loadJFreeReport():
        rv = { "JFreeReportBoot": "org.jfree.report.JFreeReportBoot",
                "JFreeReport": "org.jfree.report.JFreeReport",
                "factory": "org.jfree.report.elementfactory.TextFieldElementFactory",
                "FloatDimension" : "org.jfree.ui.FloatDimension",
                "ElementAlignment" : "org.jfree.report.ElementAlignment",
                "PreviewFrame" : "org.jfree.report.modules.gui.base.PreviewFrame" }
                
        for z in rv.keys():
            clazz = jfcl.loadClass( rv[ z ] )
            jfcl.resolve( clazz )
            rv[ z ] = clazz

        JFreeReportBoot = rv[ "JFreeReportBoot" ]
        instance = JFreeReportBoot.getInstance()
        instance.start()
        return rv

    dc = DefCallable( loadJFreeReport )
    ft = dc.wrappedAsFutureTask()
    nwthread = jlang.Thread( ft )
    nwthread.setContextClassLoader( jfcl )
    nwthread.start()
    rv = ft.get()
    globals().update( rv )
    jfree_ok = 1 
except java.lang.Exception, x:
    jfree_ok = 0

class leoSwingPrint:
    '''a class that prints Outline data'''
    
    @others</t>
<t tx="ekr.20070127142814.678">import ClassLoaderBase
class JFreeReportClassLoader( ClassLoaderBase ):
    
    def __init__( self ):
        jlang.ClassLoader.__init__( self )
        self.jars = []
        self.loaded = {}
        
    def walkAndAdd( self, path ):
        
        import os.path
        os.path.walk( path, self.callback, path )
    
    def callback( self, arg, dirpath, namelist ):

        path = dirpath[ len( arg ): ]
        if path.startswith( "/jfreereport" ):
            for z in namelist:
                if z.endswith( ".jar" ):
                    self.addJar( "%s/%s" % ( dirpath, z ) )
                    
        
    
            


</t>
<t tx="ekr.20070127142814.679">def __init__( self, c ):
    
    self.c = c
    
</t>
<t tx="ekr.20070127142814.680">def getAsMenu( self ):
    
    disabled_text = "Disabled --&gt; JFreeReport not loaded"
    main = swing.JMenu( "Printing and Exporting" )
    jmi = swing.JMenuItem( "Print/Export Node" )
    jmi.actionPerformed = self.printNode
    jmi.setToolTipText( "Writes out Node and Subnodes into one Document" )
    if not jfree_ok:
        jmi.setEnabled( 0 )
        jmi.setToolTipText( disabled_text )
    main.add( jmi )
    jmi = swing.JMenuItem( "Print/Export Outline As More" )
    jmi.actionPerformed = self.printOutlineAsMore
    jmi.setToolTipText( "Writes out Outline in More format" )
    if not jfree_ok:
        jmi.setEnabled( 0 )
        jmi.setToolTipText( disabled_text )
    main.add( jmi )
    jmi = swing.JMenuItem( "Print Tree As Is" )
    jmi.actionPerformed = self.printTreeAsIs
    jmi.setToolTipText( "Prints out an Image of the Outline" )
    main.add( jmi )
    return main</t>
<t tx="ekr.20070127142814.681">@
These nodes create the data that is sent
to the sender methods
@c

@others
</t>
<t tx="ekr.20070127142814.682">def printMarkedNodes( self, type = jprint.DocFlavor.STRING.TEXT_PLAIN ):
    
    marked_nodes = []
    
    c = self.c
    rp = c.rootPosition()
    for z in rp.allNodes_iter( copy = True ):
        if z.isMarked():
            marked_nodes.append( z )
            
            
    strings = []
    at = c.atFileCommands
    c.fileCommands.assignFileIndices()
    for z in marked_nodes:
        at.write(z.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
        strings.append( data )
        
    
    ndata = '\n'.join( strings )
    self.sendStringToPrinter( ndata , type = type )
    

</t>
<t tx="ekr.20070127142814.683">def printNode( self, type= None  ):
    
    c = self.c
    cp = c.currentPosition()
    
    at = c.atFileCommands 
    c.fileCommands.assignFileIndices()
    at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)

    data = at.stringOutput
    return self.sendStringToJFreeReport( cp.headString(), data )
    



    
    


</t>
<t tx="ekr.20070127142814.684">def printTreeAsIs( self , *args ):
    
    jtree = self.c.frame.tree.jtree
    jsize = jtree.getSize()
    
    bi = java.awt.image.BufferedImage( jsize.width, jsize.height, java.awt.image.BufferedImage.TYPE_3BYTE_BGR )
    graphics = bi.getGraphics()
    jtree.paint( graphics )
    graphics.dispose()
    
    
    baos = java.io.ByteArrayOutputStream()
    ifos = imstream.MemoryCacheImageOutputStream( baos )
    #ifos = imstream.FileImageOutputStream( java.io.File( "tree.jpeg" ) )
    writers = imio.ImageIO.getImageWritersBySuffix( "jpeg" )
    writer = None
    for z in writers:
        writer = z
        break
        
    writer.setOutput( ifos )
    writer.write( bi )
    jtree.repaint()
    #ifos.close()
    ba = baos.toByteArray()
    ifos.close()
    self.sendByteArrayToPrinter( ba )
    
    
    

</t>
<t tx="ekr.20070127142814.685">def printOutlineAsMore( self, *args ):

    p = self.c.rootPosition()
    nodes = []
    for v in p.allNodes_iter( copy = True): 
        head = v.moreHead( 0 )
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        s += body
        nodes.append( s )
        
    
    wholestring = '\n'.join( nodes )
    #self.sendStringToPrinter( wholestring )
    self.sendStringToJFreeReport( "", wholestring )
    
    </t>
<t tx="ekr.20070127142814.686">@
These nodes send different types of data to the printer,
if they can find one that works for the type
@c

@others
</t>
<t tx="ekr.20070127142814.687">def sendStringToJFreeReport( self, title, data ):
    
    if not jfree_ok:
        swing.JOptionPane.showMessageDialog( "JyLeo could not load JFreeReport.  Printing Aborted" )
        return
    
    dtm = swing.table.DefaultTableModel()
    dtm.addColumn( "Data" )
    for z in data.split( '\n' ):
        dtm.addRow( [ z, ] )
           
    jfr = JFreeReport()
    tf = factory() #.TextFieldElementFactory()
    tf.setName( "t1" )
    tf.setAbsolutePosition( java.awt.geom.Point2D.Float(0, 0));
    pd = jfr.getPageDefinition()
    tf.setMinimumSize( FloatDimension( pd.getWidth() , 12));
    tf.setColor(java.awt.Color.black);
    tf.setHorizontalAlignment(ElementAlignment.LEFT);
    tf.setVerticalAlignment( ElementAlignment.MIDDLE);
    tf.setFieldname("Data")
    element = tf.createElement()
    element.setDynamicContent( 1 )
    jfr.getItemBand().addElement( element )
    jfr.setName( title )
    jfr.setData( dtm )
    cthread = jlang.Thread.currentThread()
    ccl = cthread.getContextClassLoader()
    cthread.setContextClassLoader( jfcl )
    pf = PreviewFrame( jfr )
    pf.pack()
    g.app.gui.center_dialog( pf )
    pf.setExtendedState( pf.MAXIMIZED_BOTH )
    pf.setVisible( 1 )
    cthread.setContextClassLoader( ccl )
    return    



</t>
<t tx="ekr.20070127142814.688">def sendStringToPrinter( self, data , type = jprint.DocFlavor.BYTE_ARRAY.TEXT_PLAIN_HOST ):
    
    hatt = jatt.HashDocAttributeSet()
    type = jprint.DocFlavor.INPUT_STREAM.AUTOSENSE
    bais = java.io.ByteArrayInputStream( jlang.String( data ).getBytes( "US-ASCII" ) )
    sdoc = jprint.SimpleDoc( bais, type , hatt )
    pservices = jprint.PrintServiceLookup.lookupPrintServices( type , hatt )
    print pservices
    
    if pservices:
        hpattset = jatt.HashPrintRequestAttributeSet()
        ps = jprint.ServiceUI.printDialog( None, 50, 50, pservices, pservices[ 0 ], type , hpattset )
        if ps:
            dpj = ps.createPrintJob()
            dpj.addPrintJobListener( self.PrintJobReporter() )
            try:
                dpj.print( sdoc, hpattset )
            except jlang.Exception, x:
                g.es( "Could not execute print job", color='red' )
    else:
        g.es( "Could not find printer for type %s" % type, color='red' )</t>
<t tx="ekr.20070127142814.689">def sendByteArrayToPrinter( self, data, type = jprint.DocFlavor.BYTE_ARRAY.JPEG ):
    
    hatt = jatt.HashDocAttributeSet()
    sdoc = jprint.SimpleDoc( data , type , hatt )
    pservices = jprint.PrintServiceLookup.lookupPrintServices( type , hatt )
    
    if pservices:
        hpattset = jatt.HashPrintRequestAttributeSet()
        ps = jprint.ServiceUI.printDialog( None, 50, 50, pservices, pservices[ 0 ], type, hpattset )
        if ps:
            dpj = ps.createPrintJob()
            dpj.addPrintJobListener( self.PrintJobReporter() )
            try:
                dpj.print( sdoc, hpattset )
            except jlang.Exception, x:
                g.es( "Could not execute print job", color='red' )    
                
    else:
        g.es( "Could not find printer for type %s" % type, color = 'red' )
</t>
<t tx="ekr.20070127142814.690">class PrintJobReporter( jevent.PrintJobListener ):
    '''A Class that reports on how well a Print Job is doing'''
    def __init__( self ):
        pass
        #jevent.PrintJobListener.__init__( self )
            
            
    def printDataTransferCompleted( self, pje):
    
        g.es( "Printing has started...", color='blue' )
        
    def printJobCanceled( self, pje):
        
        g.es( "Printing has been canceled", color='red' )
        
    def printJobCompleted( self, pje):
        
        g.es( "Printing has completed", color='blue' )
        
    def printJobFailed( self, pje):
        
        g.es( "Printing has failed", color='red' )
        
    def printJobNoMoreEvents( self, pje):
        pass
        #g.es( "No more events" )
        
    def printJobRequiresAttention( self, pje):
        
        g.es( "Print job requires attention", color='red' )
        
</t>
<t tx="ekr.20070127142814.691">@
class LeoPageable( jprint.Pageable, jprint.Printable ):
    def __init__( self, page_data, font ):
        self._page_data = page_data
        self._font = font
    def getNumberOfPages( self ):
        return self.UNKNOWN_NUMBER_OF_PAGES
    def getPageFormat( self, i ):
        return jprint.PageFormat.PORTRAIT
    def getPrintable( self, i ):
        return self

    def print( self, graphics, pageFormat,pageIndex):
        graphics.translate( pageFormat.getImageableX(), pageFormat.getImageableY() )
        graphics.setFont( self._font )
        fm = graphics.getFontMetrics()
        height = fm.getHeight()
        iheight = pageFormat.getImageableHeight()
        lines_per_page = iheight/height
        nstart = 0
        for z in self._page_data:
            g.drawString( jlang.String( z ), 0, nstart )
            nstart += 1
            if nstart == lines_per_page:
                return
</t>
<t tx="ekr.20070127142814.692">@
This code will show what the 'default' service provides in terms of printing

import javax.print as pr
ps1 = pr.PrintServiceLookup
ds = ps1.lookupDefaultPrintService()
ds.getSupportedDocFlavors()
</t>
<t tx="ekr.20070127142814.693">import htmllib
import formatter
import javax.swing as swing
import java
import urllib

ACTIVATED = swing.event.HyperlinkEvent.EventType.ACTIVATED
ENTERED = swing.event.HyperlinkEvent.EventType.ENTERED
EXITED = swing.event.HyperlinkEvent.EventType.EXITED

class HtmlBrowserWindow( swing.JFrame ):
    
    def __init__( self, urlString="" ):
        swing.JFrame.__init__( self, title = "HTML Browser", size = ( 800, 600 ) )
        self.contentPane.layout = java.awt.BorderLayout()
        self.contentPane.add( self.buildTopPane( urlString ), java.awt.BorderLayout.NORTH )
        self.htmlPane = swing.JEditorPane( "text/html", "" , editable = 0, hyperlinkUpdate = self.followHyperlink,
                        size = (400, 400 ) )
        self.contentPane.add( swing.JScrollPane( self.htmlPane ), java.awt.BorderLayout.CENTER )
        self.status = swing.JLabel( " ", preferredSize=(500,20) )
        self.contentPane.add( self.status, java.awt.BorderLayout.SOUTH )
        print self.htmlPane.getContentType()
        print self.htmlPane.getDocument()
        
    def buildTopPane( self, startUrl ):
        label = swing.JLabel( "Go To" )
        self.field = swing.JTextField( preferredSize = (500, 20 ),
                    text=startUrl, actionPerformed=self.goToUrl )
        button = swing.JButton( "Go", size=(100,100),
                            actionPerformed=self.goToUrl )
        topPane = swing.JPanel()
        topPane.add( label )
        topPane.add( self.field )
        topPane.add( button )
        return topPane
        
    def goToUrl( self, event ):
        self.htmlPane.setPage( self.field.text )
        doc = self.htmlPane.getDocument()
        print doc.getStyleSheet()
        
    def followHyperlink( self, hlEvent ):
        if hlEvent.eventType == ACTIVATED:
                self.htmlPane.setPage( hlEvent.URL )
        elif hlEvent.eventType == ENTERED:
                self.status.text = hlEvent.URL.toString()
        elif hlEvent.eventType == EXITED:
            self.status.text = " "
    
    @others
        
if __name__== "__main__":
        import sys
        print sys.argv[ 1 ]
        HtmlBrowserWindow( sys.argv[ 1 ] ).show()
        </t>
<t tx="ekr.20070127142814.694">def viewNodeAsHtml( self, c ):
    
    #c = self.c
    cp = c.currentPosition()
    
    at = c.atFileCommands 

    at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)

    data = at.stringOutput 
    self.htmlPane.setText( data )
    self.show()

</t>
<t tx="ekr.20070127142814.695">import javax.swing as swing
import java
import java.net as net
import javax.swing.text as stext
import javax.swing.text.html as html
import javax.swing.text.html.parser as phtml
import javax.xml.parsers as jparse
import javax.xml.transform as transform
import javax.xml.transform.dom as tdom
import javax.xml.transform.stream as stream
import java.io as io
import leoGlobals as g
from utilities.DoNothingEntityResolver import DoNothingEntityResolver

ACTIVATED = swing.event.HyperlinkEvent.EventType.ACTIVATED
ENTERED = swing.event.HyperlinkEvent.EventType.ENTERED
EXITED = swing.event.HyperlinkEvent.EventType.EXITED 


        
class leoSwingLeoTutorial:
    
    def __init__( self ):
        
        self.cached_pages = {}
        self.seen_elements =[]
        self.entered = []
        dbf = jparse.DocumentBuilderFactory.newInstance()        
        dbf.setValidating( 0 )
        dbf.setIgnoringComments( 1 )
        self.documentBuilder = dbf.newDocumentBuilder()
        self.documentBuilder.setEntityResolver( DoNothingEntityResolver() )
        self.htmlPane = swing.JEditorPane( "text/html", "" , editable = 0, hyperlinkUpdate = self.followHyperlink )
        self.jsp = swing.JScrollPane( self.htmlPane )
        self.html_dir = g.os_path_join( g.app.loadDir ,"..","doc","html", "leo_TOC.html" )
        self.fakeDoc = html.HTMLDocument()
        ifile = io.File( self.html_dir )
        self.homeUrl = url = ifile.getCanonicalFile().toURL()
        self.setPage( url )

        
    def getWidget( self ):
        return self.jsp
        
    def goHome( self ):
        url = self.homeUrl
        the_file = url.getFile()
        self.htmlPane.setDocument( self.cached_pages[ the_file ] )
        
    def setPage( self, url ):
        
        ref = url.getRef()
        protocol = url.getProtocol()
        the_file = url.getFile()
        
        
        if protocol != "file" or the_file.endswith( "front.html" ):
            url = self.homeUrl
            the_file = url.getFile()
            
        if self.cached_pages.has_key( the_file ):
            if self.htmlPane.getDocument() != self.cached_pages[ the_file ]: # or ref:
                #self.htmlPane.setDocument( self.fakeDoc )
                self.htmlPane.setDocument( self.cached_pages[ the_file ] )
        else:
            
            try:
                doc = self.documentBuilder.parse( url.getContent() )
            except java.lang.Exception, x:
                x.printStackTrace()
                return self.goHome()
                
            style = doc.getElementsByTagName( "style" )
            style_list = []
            for x in xrange( style.length ):
                node = style.item( x )
                style_list.append( node )
            for x2 in style_list:
                parent = x2.getParentNode()
                parent.removeChild( x2 )


            meta = doc.getElementsByTagName( "meta" )
            meta_list = []
            for x3 in xrange( meta.length ):
                mnode = meta.item( x3 )
                meta_list.append( mnode )
            for x4 in meta_list:
                parent = x4.getParentNode()
                parent.removeChild( x4 )
                
                
                
            trans = transform.TransformerFactory.newInstance().newTransformer()
            dsource = tdom.DOMSource( doc )
            sw = io.StringWriter()
            sr = stream.StreamResult( sw )
            trans.transform( dsource, sr )
            ekit = self.htmlPane.getEditorKit().clone()
            s = sw.toString()
            spot = s.find( "\n" )
            s = s[ spot: ] # remove the xml prolog... 
            sr = io.StringReader( s )
            hdoc = ekit.createDefaultDocument()            
            hdoc.setBase( url )
            try:
                ekit.read( sr, hdoc, 0 )
            except java.lang.Exception, x:
                x.printStackTrace()
                return self.goHome()
            
            self.cached_pages[ the_file ] = hdoc
            self.htmlPane.setDocument( hdoc )
    
        if ref:
            self.htmlPane.scrollToReference( ref )    
        
    def colorizeHyperlinks( self ):
        '''do to the fact that exited, entered and activated dont execute in the 
           order that is needed we must keep track of what has happened to which element
           and colorize the elements based off of their history'''
        for z in self.entered:
            doc = z.getDocument()
            start = z.getStartOffset()
            end = z.getEndOffset()
            sas = stext.SimpleAttributeSet()
            if z in self.seen_elements:
                stext.StyleConstants.setForeground( sas, java.awt.Color.RED )
            else:
                stext.StyleConstants.setForeground( sas, java.awt.Color.BLUE )
            doc.setCharacterAttributes( start, end - start, sas , 0 )
            #doc.setParagraphAttributes( start, end - start, sas , 0 )
        self.entered = []
        
    def followHyperlink( self, hlEvent ):
        aset = element = hlEvent.getSourceElement()
        doc = element.getDocument()
        start = element.getStartOffset()
        end = element.getEndOffset()
        
        if hlEvent.eventType == ACTIVATED:
            url = hlEvent.URL    
            self.seen_elements.append( element )
            self.colorizeHyperlinks()
            self.setPage( url )             
        elif hlEvent.eventType == ENTERED:
            self.colorizeHyperlinks()
            self.entered.append( element )
            aset = stext.SimpleAttributeSet()
            stext.StyleConstants.setForeground( aset, java.awt.Color.GREEN )
            doc.setCharacterAttributes( start, end - start, aset, 0 )
            #doc.setParagraphAttributes( start, end - start, aset, 0 )
        elif hlEvent.eventType == EXITED:
            self.colorizeHyperlinks()
</t>
<t tx="ekr.20070127142814.696">@language python
&lt;&lt; plugin_manager declarations &gt;&gt;
@others


if __name__ == "__main__":  
    standalone = 1
    g = FakeLeoGlobals()
    topLevelMenu()
        
</t>
<t tx="ekr.20070127142814.697">"""
A plugin to manage Leo's Plugins:

- Enables and disables plugins.
- Shows plugin details.
- Checks for conflicting hook handlers.
- Checks for and updates plugins from the web.
"""

"""
A leoSwing component to manage Leo's Plugins.
Based off of plugin_manager plugin( built off of ).
"""

__version__ = "0.10"
__plugin_name__ = "Plugin Manager"
__plugin_priority__ = 10000
__plugin_requires__ = ["plugin_menu"]
__plugin_group__ = "Core"


# 
# 0.1 Paul Paterson:
#     - Initial version
# 
# 0.2 EKR:
#     - The check for .ini files looks for the actual x.ini file.
#       (This required that spellpyx uses spellpyx.ini rather than 
# mod_spelling.ini.)
#     - Minor stylistic changes.
# 0.4 EKR:
#     - Added USE_PRIORITY switch.
#       Priority is non-functional, and isn't needed.
#       Leo loads plugins in the order in which they appear in 
# pluginsManager.txt.
#       Furthermore, this plugin preserves that order.
# 0.5 EKR:
#     - Make sure to do nothing if Pmw is not defined.
# 0.6 Paul Paterson:
#     - Fixed incorrect detection of version if single quotes used
#     - Now always detects a file as a plugin (previously only did this if it 
# imported leoPlugins)
#     - Fixed incorrect detection of handlers if single quotes used
#     - Fixed incorrect detection of multiple handlers in a single line.
# 0.7 EKR:
#     - Grrrrrrrrrr.  The Sets module is not defined in Python 2.2.
#       This must be replaced.  This is too important a plugin for it not to 
# work everywhere.
#     - Added better import tests, and message when import fails.
#     - Added an init method, although a simple raise would also work.
# 0.8 EKR:
#     - Well, that was easy.  Put sets.py from Python 2.4 in extensions 
# folder.
#     - Use g.importExtension rather than import to get sets module.
# 0.9 Paul Paterson:
#     - Remove the "not referenced" status. All plugins are not active or 
# inactive.
#     - Changed the list view to have the status at the end of the line
#     - Changed format of list view to be fixed font so that it looks cleaner
#     - Also changed format of conflict list view
#     - If a file contains "__not_a_plugin__ = True" then it will be omitted 
# from the list
#     - Now looks for and reports the __plugin_group__ in the view and list
#     - Can now filter the plugins by their __plugin__group__
#     - Set __plugin_group__ to "Core"
#     - Renamed active/inactive to on/off as this works better with the groups
#     - Added version history display to plugin view
# 
# 0.10 Paul Paterson:
#     - Changed the names in the plugin list view to remove at_, mod_ and 
# capitalized
#     - Remove dblClick event from plugin list - it wasn't doing anything
#     - Can now be run stand-alone to aid in debugging problems
# 


#
# If these don't import then your Python install is hosed anyway so we don't
# protect the import statements
import fnmatch
import os
import re
import sha
import sys
import urllib
import threading
#import webbrowser
import traceback
import java

#
# Try to import Leo - if this doesn't work then we are stand-alone
try:
    import leoGlobals as g
    import leoPlugins
    import java.lang.String as jstring
    import javax.swing as swing
    import java.awt as awt
    import javax.swing.border as sborder
    import java.awt.event as aevent
    import javax.swing.event as sevent
    import javax.swing.table as stable
    import java.util.HashSet as hset
    import jarray
    ok = True
    standalone = False
except ImportError, ie:
    print ie


"""

Todo list:

- getting subset of plugins from CVS
- categorize plugins
- filter on categories
- size of plugin
- add required plugins to conflict check
- help for nomenclature

Done

- restore list top position when updating plugin list 
- proper view of remote file (colourized code)
- __requires__ list for plugins
- show __requires__
- proper dialog to show conflict list and error list from CVS

"""


USE_PRIORITY = False # True: show non-functional priority field.


</t>
<t tx="ekr.20070127142814.698">def init():
    
    # Ok for unit testing: adds menu.
    if ok:
        g.plugin_signon(__name__)

    return ok
</t>
<t tx="ekr.20070127142814.699"># This is called from plugins_menu plugin.
# It should only be defined if the extension has been registered.

def topLevelMenu():
    
    """Manage the plugins"""
    dlg = ManagerDialog()
</t>
<t tx="ekr.20070127142814.700">class InvalidPlugin(Exception):
    """The plugin is invalid"""
</t>
<t tx="ekr.20070127142814.701">class InvalidCollection(Exception):
    """The plugin collection is invalid"""
</t>
<t tx="ekr.20070127142814.702">class InvalidManager(Exception):
    """The enable manager is invalid"""
	&lt;&lt; class InvalidManager declarations &gt;&gt;
</t>
<t tx="ekr.20070127142814.703">

</t>
<t tx="ekr.20070127142814.704">def inColumns(data, columnwidths):
    """Return the items of data with the specified column widths
    
    The list of widths should be one less than the list of data, eg
        inColumns((10,20,30), (5,5))
    """
    format = ""
    for col in columnwidths:
        format += "%%-%ds" % col
    format += "%s"
    #
    return format % data
</t>
<t tx="ekr.20070127142814.705">class NameSpace:
    """Just an object to dump properties in"""
	&lt;&lt; class NameSpace declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.706">
</t>
<t tx="ekr.20070127142814.707">def __init__(self, **kw):
    self.__dict__.update(kw)
</t>
<t tx="ekr.20070127142814.708">
class BlackHole:
    """Try to call a method on this and it will just dissapear into the void!"""
	&lt;&lt; class BlackHole declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.709">
</t>
<t tx="ekr.20070127142814.710">def __getattr__(self, name):
    """Return a black hole!"""
    return BlackHole()
</t>
<t tx="ekr.20070127142814.711">
def __call__(self, *args, **kw):
    """Call this .... """
    return None
</t>
<t tx="ekr.20070127142814.712">
class FakeLeoGlobals:
    """A class to represent leoGlobals when were are running in standalone mode"""
	&lt;&lt; class FakeLeoGlobals declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.713"></t>
<t tx="ekr.20070127142814.714">def __init__(self):
    """Initialize the fake object"""
    self.app = NameSpace()
    #self.app.root = Tk.Tk()
    self.app.root = swing.JFrame()
    self.app.gui = BlackHole()  
    import leoSwingPluginManager
    __file__ = leoSwingPluginManager.__file__
    self.app.loadDir = os.path.join(os.path.split(__file__)[0], "..", "src")

    self.Bunch = NameSpace
    
    for name in dir(os.path):
        setattr(self, "os_path_%s" % name, getattr(os.path, name))
</t>
<t tx="ekr.20070127142814.715">
def choose(self, cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20070127142814.716">
class PluginView( swing.JPanel, aevent.ComponentListener ):
    """Frame to display a plugin's information"""
	&lt;&lt; class PluginView declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.717">
</t>
<t tx="ekr.20070127142814.718">def __init__(self, parent, *args, **kw):
    """Initialize the view"""
    #Tk.Frame.__init__(self, parent, *args, **kw)
    swing.JPanel.__init__( self )
    self.addComponentListener( self )
    sl = swing.SpringLayout()
    self.setLayout( sl )

    
    name_label = swing.JLabel( "Name:" )
    self.add( name_label )
    self.name2 = self.EntryField( labelpos = 'w', label_text='Name:' )
    self.add( self.name2 )
    
    sl.putConstraint( sl.NORTH, self.name2, 0, sl.NORTH, self )
    sl.putConstraint( sl.WEST, self.name2, 0, sl.EAST, name_label )
    sl.putConstraint( sl.NORTH, name_label, 0, sl.NORTH, self )
    sl.putConstraint( sl.EAST, self, self.name2.getPreferredSize().width, sl.EAST, self.name2 )
    
    version_label = swing.JLabel( "Version:" )
    self.add( version_label )
    self.version = self.EntryField( labelpos = 'w', label_text='Version:' )
    self.add( self.version )
    sl.putConstraint( sl.NORTH, self.version, 0, sl.SOUTH, self.name2 )
    sl.putConstraint( sl.WEST, self.version, 0, sl.EAST, version_label )
    sl.putConstraint( sl.NORTH, version_label, 0, sl.SOUTH, self.name2 )
    
    status_label = swing.JLabel( "Status:" )
    self.add( status_label )
    self.status = self.EntryField( labelpos='w', label_text='Status:' )
    self.add( self.status )
    sl.putConstraint( sl.NORTH, self.status, 0, sl.SOUTH, self.version )
    sl.putConstraint( sl.WEST, self.status, 0 , sl.EAST, status_label )
    sl.putConstraint( sl.NORTH, status_label, 0, sl.SOUTH, self.version )
    
    group_label = swing.JLabel( "Group:" )
    self.add( group_label )
    self.group = self.EntryField( labelpos='w', label_text='Group:' )
    self.add( self.group )
    sl.putConstraint( sl.NORTH, self.group, 0, sl.SOUTH, self.status)
    sl.putConstraint( sl.WEST, self.group, 0, sl.EAST, group_label )
    sl.putConstraint( sl.NORTH, group_label, 0, sl.SOUTH, self.status )


    fn_group = swing.JLabel( "Filename:")
    self.add( fn_group )
    self.filename = self.EntryField( labelpos = 'w', label_text='Filename:' )
    self.add( self.filename )
    sl.putConstraint( sl.NORTH, self.filename, 0, sl.SOUTH, self.group)
    sl.putConstraint( sl.WEST, self.filename, 0, sl.EAST, fn_group )
    sl.putConstraint( sl.NORTH, fn_group, 0, sl.SOUTH, self.group )

    
    ini_group = swing.JLabel( "Has INI:" )
    self.add( ini_group )
    self.has_ini = self.EntryField( labelpos = 'w', label_text='Has INI:' )
    self.add( self.has_ini )
    sl.putConstraint( sl.NORTH, self.has_ini, 0, sl.SOUTH, self.filename )
    sl.putConstraint( sl.WEST, self.has_ini, 0, sl.EAST, ini_group )
    sl.putConstraint( sl.NORTH, ini_group, 0, sl.SOUTH, self.filename )
    

    htl_group = swing.JLabel( "Has top level:" )
    self.add( htl_group )
    self.has_toplevel = self.EntryField( labelpos='w', label_text='Has top level:' )
    self.add( self.has_toplevel )
    sl.putConstraint( sl.NORTH, self.has_toplevel, 0, sl.SOUTH, self.has_ini )
    sl.putConstraint( sl.WEST, self.has_toplevel, 0, sl.EAST, htl_group )
    sl.putConstraint( sl.NORTH, htl_group, 0, sl.SOUTH, self.has_ini )
    #sl.putConstraint( sl.EAST, htl_group, 0, sl.EAST, self.has_toplevel )
    
    sl.putConstraint( sl.EAST, name_label ,0 ,sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, version_label ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, status_label ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, group_label  ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, fn_group  ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, ini_group  ,0, sl.EAST, htl_group )

    if USE_PRIORITY:
        #self.priority = Pmw.EntryField(self.top,
        #    labelpos = 'w',
        #    label_text = 'Priority:',
        #)
        
        #self.priority.pack(side="top", fill="x", expand=0)
        self.priority = self.EntryField( eftop, labelpos = 'w', label_text='Priority:' )
    
    
    self.text_panel = swing.JTabbedPane()
    self.add( self.text_panel ) #, awt.BorderLayout.CENTER )
    sl.putConstraint( sl.NORTH, self.text_panel, 5, sl.SOUTH, self.has_toplevel )
    sl.putConstraint( sl.EAST, self.text_panel, 5, sl.EAST, self )
    sl.putConstraint( sl.WEST, self.text_panel, 5, sl.WEST, self )
    
    description_panel = swing.JPanel()
    description_panel.setLayout( awt.GridLayout( 1, 1 ) )
    self.text_panel.addTab( 'Description', description_panel )
    version_panel = remote_list_page = swing.JPanel()
    version_panel.setLayout( awt.GridLayout( 1, 1 ) )
    self.text_panel.addTab( 'Version History', version_panel )
    tp_dimen = awt.Dimension( 200, 200 )
    self.text_panel.setPreferredSize( tp_dimen )
    self.text_panel.setMinimumSize( tp_dimen )
    self.text_panel.setMaximumSize( tp_dimen )

    self.description = swing.JTextArea()
    self.description.setEditable( False )
    #self.description.setLineWrap( True )
    view = swing.JScrollPane( self.description )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugin Description" )
    view.setBorder( tborder )
    
    description_panel.add( view )

    self.version_history = swing.JTextArea()
    self.version_history.setEditable( False )
    #self.version_history.setLineWrap( True )
    view = swing.JScrollPane( self.version_history )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugin History" )
    view.setBorder( tborder )
    version_panel.add( view )        
    
    

    self.jlists = swing.JPanel( awt.GridLayout( 1, 3 ) )    
    lav1 = self.getJList( "Commands" )
    self.commands = lav1[ 0 ]
    self.jlists.add( lav1[ 1 ] )


    lav2 = self.getJList( "Hooks" )
    self.handlers = lav2[ 0 ]
    self.jlists.add( lav2[ 1 ] )
    
    lav3 = self.getJList( "Requires" )
    self.requires = lav3[ 0 ]
    self.jlists.add( lav3[ 1 ] )
    
    self.add( self.jlists )
    sl.putConstraint( sl.NORTH, self.jlists, 5, sl.SOUTH, self.text_panel )
    sl.putConstraint( sl.EAST, self.jlists, 5, sl.EAST, self )
    sl.putConstraint( sl.WEST, self.jlists, 5, sl.WEST, self )
    sl.putConstraint( sl.SOUTH, self, 20, sl.SOUTH, self.jlists )

    
@    
    if USE_PRIORITY:
        Pmw.alignlabels([
            self.name, self.version, self.status, self.group,
            self.filename, self.has_ini, self.has_toplevel,
            self.priority,
        ])
    else:
         Pmw.alignlabels([
            self.name, self.version, self.status, self.group,
            self.filename, self.has_ini, self.has_toplevel,
        ])
@c
    </t>
<t tx="ekr.20070127142814.719">
def showPlugin(self, plugin):
    """Show a plugin"""
    self.name2.setentry(plugin.name)
    self.version.setentry(plugin.version)
    self.group.setentry(plugin.group)
    self.filename.setentry(g.os_path_abspath(plugin.filename)) # EKR
    self.status.setentry(plugin.enabled)
    self.has_ini.setentry(
        g.choose(plugin.has_config,"Yes","No"))
    self.has_toplevel.setentry(
        g.choose(plugin.has_toplevel,"Yes","No"))
    if USE_PRIORITY:
        self.priority.setentry(plugin.priority)
    
    self.description.setText( plugin.description.strip() )
    self.description.setCaretPosition( 0 )
    self.version_history.setText( plugin.versions.strip() )
    self.version_history.setCaretPosition( 0 )
    #self.description.settext(plugin.description.strip())
    #self.version_history.settext(plugin.versions.strip())
    self.commands.setlist(plugin.commands)
    self.handlers.setlist(plugin.handlers)
    self.requires.setlist(plugin.requires)
    </t>
<t tx="ekr.20070127142814.720">class PVList( swing.JList ):
    
    def __init__( self ):
        swing.JList.__init__( self )
        self.setVisibleRowCount( 5 )
        #g = self.getGraphics()
        #fm = g.getFontMetrics()
        #width = fm.stringWidth( 'xxxxxxxxxx' )
        #self.setFixedCellWidth( width )
        
    def setlist( self, items ):
        
        
        import java.util.HashSet
        if items.__class__ == java.util.HashSet:
            self.setListData( items.toArray() )
        else:
            self.setListData( items )

def getJList( self, title ):

    jlist =  self.PVList()
    view = swing.JScrollPane( jlist )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( title )
    view.setBorder( tborder )
    return jlist, view
</t>
<t tx="ekr.20070127142814.721">def componentResized( self, event ):
    pass
    #sz = self.getSize()
    #sz.height = sz.height/3
    #self.text_panel.setPreferredSize( sz )
    #self.text_panel.setMaximumSize( sz )
    #self.jlists.setMaximumSize( sz )
    #self.jlists.setPreferredSize( sz )
    
def componentHidden( self, event ):
    pass
    
def componentMoved( self, event ):
    pass
    
def componentShown( self, event ):
    pass</t>
<t tx="ekr.20070127142814.722">class EntryField( swing.JTextField ):
    
    def __init__( self, labelpos = 'west', label_text= "" ):
        
        #swing.JPanel.__init__( self )
        swing.JTextField.__init__( self, 15 )
        self.entry = self
        self.setMaximumSize( self.getPreferredSize() )
        self.setMinimumSize( self.getPreferredSize() )
        
        

    def setentry( self, data ):
        self.entry.setText( data )
        self.entry.setCaretPosition( 0 )</t>
<t tx="ekr.20070127142814.723">
class PluginList( swing.JPanel, sevent.ListSelectionListener ):
    """Frame to display a list of plugins"""
	&lt;&lt; class PluginList declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.724">filter_options = []
title = "List"
secondtitle = "Groups"


</t>
<t tx="ekr.20070127142814.725">def __init__(self, parent, plugin_view, plugins ): #, *args, **kw):
    """Initialize the list"""
    
    swing.JPanel.__init__( self )
    sl = swing.SpringLayout()
    self.setLayout( sl )

    self.box = swing.JList()
    self.box.addListSelectionListener( self )
    self.box.setVisibleRowCount( 5 )
    view = swing.JScrollPane( self.box )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugins" )
    view.setBorder( tborder )
    self.add( view )
    sl.putConstraint( sl.NORTH, view, 5, sl.NORTH, self )


    import java.lang.Object as jobject
    
    cl = swing.SpringLayout()
    c1 = swing.JPanel( cl )
    c1.setBorder( sborder.LineBorder.createBlackLineBorder() )
    label1 = swing.JLabel( self.title )
    c1.add( label1 )
    cl.putConstraint( cl.NORTH, label1, 0, cl.NORTH, c1 )
    
    self.filter = swing.JComboBox( self.filter_options )
    self.filter.addActionListener( self.Populater( self ) )                     

    c1.add( self.filter )
    cl.putConstraint( cl.NORTH, self.filter, 0, cl.SOUTH, label1 )
    cl.putConstraint( cl.SOUTH, c1, 0, cl.SOUTH, self.filter )
    cl.putConstraint( cl.EAST, c1, 0, cl.EAST, label1 )
    nsize = self.syncSize( label1.getPreferredSize(), self.filter.getPreferredSize() )
    label1.setPreferredSize( nsize )
    self.filter.setPreferredSize( nsize )
    
    self.add( c1 )
    sl.putConstraint( sl.NORTH, c1, 5, sl.SOUTH, view )
    sl.putConstraint( sl.WEST, c1, 5, sl.WEST, self )                       


    cl = swing.SpringLayout()
    c2 = swing.JPanel( cl )
    c2.setBorder( sborder.LineBorder.createBlackLineBorder() )
    label2 = swing.JLabel( self.secondtitle )
    c2.add( label2 )
    cl.putConstraint( cl.NORTH, label2, 0, cl.NORTH, c2 )
    
    self.secondfilter = swing.JComboBox( [ 'All',] )
    self.secondfilter.addActionListener( self.Populater( self ) )
    c2.add( self.secondfilter )
    nsize = self.syncSize( label2.getPreferredSize(), self.secondfilter.getPreferredSize() )
    label2.setPreferredSize( nsize )
    self.secondfilter.setPreferredSize( nsize )
    
    cl.putConstraint( sl.NORTH, self.secondfilter, 0, sl.SOUTH, label2 )
    cl.putConstraint( sl.SOUTH, c2, 0, cl.SOUTH, self.secondfilter )
    cl.putConstraint( sl.EAST, c2, 5, cl.EAST, label2 )
    
    self.add( c2 )
    sl.putConstraint( sl.NORTH, c2, 5, sl.SOUTH, view )
    sl.putConstraint( sl.WEST, c2, 5, sl.EAST, c1 )
    sl.putConstraint( sl.SOUTH, self, 5, sl.SOUTH, c1 )
    sl.putConstraint( sl.EAST, self, 5, sl.EAST, view )
    
    self.plugin_view = plugin_view
    self.plugins = plugins


</t>
<t tx="ekr.20070127142814.726">def syncSize( self, s1, s2 ):
    
    nsize = awt.Dimension( 0, 0 )
    if s1.width &gt; s2.width:
        nsize.width = s1.width
    else:
        nsize.width = s2.width
        
        
    if s1.height &gt; s2.height:
        nsize.height = s1.height
    else:
        nsize.height = s2.height
        
    return nsize</t>
<t tx="ekr.20070127142814.727">
def onClick(self):
    self.valueChanged( None )

def valueChanged( self, event ):
    """Select an item in the list"""
    #sels = self.box.getcurselection()
    sels = self.box.getSelectedValue()
    #if len(sels) == 0:
    #    pass
    #else:
    if sels == None: pass
    else:
        self.plugin_view.showPlugin( self.local_dict[ sels ] ) #self.local_dict[sels[0]])
        self.plugin_view.description.invalidate()
        self.plugin_view.version_history.invalidate()
        self.repaint()
        #self.invalidate()</t>
<t tx="ekr.20070127142814.728">
def populateList(self, filter=None):
    """Populate the plugin list"""
    if not self.plugins:
        #self.box.setlist([])
        self.box.setListData( [] )
        return
    #if filter is None:
    #filter = self.filter.getcurselection()
    values = self.filter.getSelectedItem()
    filter = values
    #secondfilter = self.secondfilter.getcurselection()
    values = self.secondfilter.getSelectedItem()
    secondfilter = values
    #
    # Get old selection so that we can restore it    
    #current_text = self.box.getcurselection()
    current_text = self.box.getSelectedValue()
    if current_text:
        #current_index = self.listitems.index(current_text[0])
        current_index = self.listitems.index( current_text )
    #
    # Show the list
    #self.local_dict = dict([(self.plugins[name].asString(), self.plugins[name])
    #                            for name in self.plugins])
    self.local_dict = {}
    lddata = [(self.plugins[name].asString(), self.plugins[name]) for name in self.plugins]
    for z in lddata:
        self.local_dict[ z[ 0 ] ] = z[ 1 ]
        
    self.listitems = [self.plugins[name].asString() 
                        for name in self.plugins.sortedNames()
                        if filter in ("All", self.plugins[name].enabled) 
                        and secondfilter in ("All", self.plugins[name].group)]
    #self.box.setlist(self.listitems)   
    self.box.setListData( self.listitems ) 
    #
    if current_text:
        try:
            self.box.setSelectedValue( ( self.listitems[ current_index ], ), 1 )
            #self.box.setvalue((self.listitems[current_index],))
            #self.box.component("listbox").see(current_index)
        except IndexError:
            pass # Sometimes the list is just different!
        else:
            self.onClick()

</t>
<t tx="ekr.20070127142814.729">
def getSelectedPlugin(self):
    """Return the selected plugin"""
    #sels = self.box.getcurselection()
    
    sels = self.box.getSelectedValue()
    if sels == None: return None
    #if len(sels) == 0:
    #    return None
    else:
        #return self.local_dict[sels[0]]
        return self.local_dict[ sels ]</t>
<t tx="ekr.20070127142814.730">
def setSecondFilterList(self, list_items):
    """Set the items to use in the second filter list"""
    #self.secondfilter.setitems(list_items)
    sf = self.secondfilter
    #sf.setOptions( list_items )
    sf.removeAllItems()
    for z in list_items:
        sf.addItem( z )
        
</t>
<t tx="ekr.20070127142814.731">class Populater( aevent.ActionListener ):
    
    def __init__( self, pl ):
        
        self.pl = pl
        
    def actionPerformed( self, event ):
        
        self.pl.populateList()</t>
<t tx="ekr.20070127142814.732">
class LocalPluginList(PluginList):
    """A list showing plugins based on the local file system"""
	&lt;&lt; class LocalPluginList declarations &gt;&gt;
</t>
<t tx="ekr.20070127142814.733">title = "Locally Installed Plugins"
filter_options = ['All', 'On', 'Off']

</t>
<t tx="ekr.20070127142814.734">class RemotePluginList(PluginList):
    """A list showing plugins based on a remote file system"""
	&lt;&lt; class RemotePluginList declarations &gt;&gt;
</t>
<t tx="ekr.20070127142814.735">title = "Plugins on CVS"
filter_options = ['All', 'Up to date', 'Update available', 'Changed', 'Not installed']

</t>
<t tx="ekr.20070127142814.736">class ManagerDialog:
    """The dialog to show manager functions"""
	&lt;&lt; class ManagerDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.737">
</t>
<t tx="ekr.20070127142814.738">def __init__(self):
    """Initialise the dialog"""
    
    
    root = g.app.root
    if standalone:
        self.top = top = root
    else:
        self.top = top = swing.JFrame()
    
    sl = swing.SpringLayout()
    cpane = top.getContentPane()
    cpane.setLayout( sl )
    g.app.gui.attachLeoIcon(self.top)
    top.setTitle( "Plugin Manager" )
       
    self.initLocalCollection()
   
    sl2 = swing.SpringLayout()
    self.frame = frame = swing.JPanel( sl2 )
    top.add( self.frame )
    sl.putConstraint( sl.NORTH, frame, 5, sl.NORTH, cpane )
      
    self.plugin_view = PluginView( cpane )
    cpane.add( self.plugin_view )
    sl.putConstraint( sl.NORTH, self.plugin_view, 5, sl.NORTH, cpane )
    sl.putConstraint( sl.WEST, self.plugin_view, 5, sl.EAST, frame )
    sl.putConstraint( sl.SOUTH, cpane, 5, sl.SOUTH, self.plugin_view )
    sl.putConstraint( sl.EAST, cpane, 5, sl.EAST, self.plugin_view )
        
    self.notebook = notebook = swing.JTabbedPane()
    frame.add( notebook, awt.BorderLayout.WEST )
    sl2.putConstraint( sl2.NORTH, notebook, 5, sl2.NORTH, frame )
    sl2.putConstraint( sl2.SOUTH, frame, 5, sl2.SOUTH, notebook )
    sl2.putConstraint( sl2.EAST, frame, 5, sl2.EAST, notebook )
    
    sl3 = swing.SpringLayout()
    self.local_list_page = local_list_page = swing.JPanel( sl3 )
    notebook.addTab( 'Installed Plugins', local_list_page )
    
    sl4 = swing.SpringLayout()
    self.remote_list_page = remote_list_page = swing.JPanel( sl4 ) 
    notebook.addTab( 'CVS Plugins', remote_list_page )
       
    self.plugin_list = LocalPluginList(local_list_page, self.plugin_view , self.local ) 
    local_list_page.add( self.plugin_list )
    sl3.putConstraint( sl3.NORTH, self.plugin_list, 5, sl3.NORTH, local_list_page )
    
    self.remote_plugin_list = RemotePluginList(remote_list_page, self.plugin_view , None )
    remote_list_page.add( self.remote_plugin_list )
    sl4.putConstraint( sl4.NORTH, self.remote_plugin_list, 5, sl4.NORTH, remote_list_page )
    
    self.plugin_list.setSecondFilterList(["All"] + self.local.getGroups())
    
    self.buttonBox = self.ButtonBox( )
    bpanel = self.buttonBox.getContainer()
    local_list_page.add( bpanel )
    sl3.putConstraint( sl3.NORTH, bpanel ,5, sl3.SOUTH, self.remote_plugin_list )
    sl3.putConstraint( sl3.SOUTH, local_list_page, 5, sl3.SOUTH, bpanel )
    sl3.putConstraint( sl3.EAST, local_list_page, 5, sl3.EAST, bpanel )
        
    self.buttonBox.add( 'Enable', command = self.enablePlugin )
    self.buttonBox.add( 'Disable', command = self.disablePlugin )
    self.buttonBox.add( 'Updates', command = self.checkUpdates )
    self.buttonBox.add( 'Conflicts', command = self.checkConflicts )
    
    self.buttonBox = self.ButtonBox( )
    bpanel = self.buttonBox.getContainer()
    remote_list_page.add( bpanel )
    sl4.putConstraint( sl4.NORTH, bpanel, 5, sl4.SOUTH, self.remote_plugin_list )
    sl4.putConstraint( sl4.SOUTH, remote_list_page, 5, sl4.SOUTH, bpanel )
    sl4.putConstraint( sl4.EAST, remote_list_page, 5, sl4.EAST, bpanel )
    
    # Add some buttons to the ButtonBox.
    self.buttonBox.add('Install', command = self.installPlugin)
    self.buttonBox.add('View', command = self.viewPlugin)
    self.buttonBox.add('Updates', command = self.checkUpdates)
        
    self.messagebar = self.MessageBar()
    cpane.add( self.messagebar )
    sl.putConstraint( sl.NORTH, self.messagebar, 5, sl.SOUTH, frame )
    sl.putConstraint( sl.WEST, self.messagebar, 5, sl.WEST, cpane )
    sl.putConstraint( sl.EAST, self.messagebar, 0, sl.EAST, frame )
    
    close_button = swing.JButton( "Close" )
    close_button.actionPerformed = lambda event: top.dispose()
    cpane.add( close_button )
    sl.putConstraint( sl.NORTH, close_button, 5, sl.SOUTH, self.messagebar )
          
    self.plugin_list.populateList("All")
    

    
    if standalone:
        top.setDefaultCloseOperation( top.EXIT_ON_CLOSE )
        
    else:
        top.setDefaultCloseOperation( top.DISPOSE_ON_CLOSE )
    top.pack()
    screen_size = awt.Toolkit.getDefaultToolkit().getScreenSize()
    center_x = screen_size.width/2
    center_y = screen_size.height/2
    
    md_size = top.getSize()
    center_x = center_x -( md_size.width/2 )
    center_y = center_y -( md_size.height/2 )
    top.setLocation( center_x, center_y )
    top.visible = 1
    

</t>
<t tx="ekr.20070127142814.739">
def enablePlugin(self):
    """Enable a plugin"""
    plugin = self.plugin_list.getSelectedPlugin()
    if not plugin: return
    
    self.local.enablePlugin(plugin,self.enable)
    self.plugin_list.populateList()
</t>
<t tx="ekr.20070127142814.740">
def disablePlugin(self):
    """Disable a plugin"""
    plugin = self.plugin_list.getSelectedPlugin()
    if not plugin: return
    
    self.local.disablePlugin(plugin,self.enable)
    self.plugin_list.populateList()
</t>
<t tx="ekr.20070127142814.741">
def initLocalCollection(self):
    """Initialize the local plugin collection"""

    # Get the local plugins information
    self.local = LocalPluginCollection()
    
    self.local.initFrom(g.os_path_join( g.app.loadDir,"..","plugins"))

    # Get the active status of the plugins
    self.enable = EnableManager()
    self.enable.initFrom(g.os_path_join( g.app.loadDir,"..","plugins"))
    self.local.setEnabledStateFrom(self.enable)
</t>
<t tx="ekr.20070127142814.742">
def checkUpdates(self):
    """Check for updates"""
    url = r"cvs.sourceforge.net/viewcvs.py/leo/leo/plugins"
    self.status_message = "Searching for plugin list"
    self.messagebar.message("busy", "Searching for plugin list")
    
    def callbackPrint(text):
        """A callback to send status information"""
        self.remote_plugin_list.populateList() 
        self.messagebar.message("busy", text)
        #self.top.update()
    
    self.remote = CVSPluginCollection()
    self.remote_plugin_list.plugins = self.remote
    try: 
        errors = self.remote.initFrom(url,callbackPrint)    
    except Exception, err:
        
        #dialog = Pmw.MessageDialog(self.top,
        #    title = 'CVS Error',
        #    defaultbutton = 0,
        #    message_text = 'Error retrieving CVS plugin information: %s' % err)
        #dialog.iconname('CVS')      
        #dialog.activate()
        dialog = swing.JOptionPane.showMessageDialog(  self.top,
                                                      "Error retrieving CVS plugin information:\n %s" % err,
                                                      'CVS Error',
                                                      swing.JOptionPane.ERROR_MESSAGE )
    
    else:
        if errors:
            
            
            dialog = ListReportDialog('CVS File Errors',
                                      'Errors',
                                      ["%s - %s" % item for item in errors],
                                      500)
            
        
    self.messagebar.resetmessages('busy')        
    self.remote.setEnabledStateFrom(self.local)
    self.remote_plugin_list.populateList()   
    self.remote_plugin_list.setSecondFilterList(["All"] + self.remote.getGroups()) 
</t>
<t tx="ekr.20070127142814.743">
def installPlugin(self):
    """Install the selected plugin"""

    # Write the file
    plugin = self.remote_plugin_list.getSelectedPlugin()        
    if not plugin: return

    self.messagebar.message("busy", "Writing file")
    
    plugin.writeTo(g.os_path_join( g.app.loadDir,"..","plugins"))
    self.messagebar.message("busy", "Scanning local plugins") 
    # Go and check local filesystem for all plugins   
    self.initLocalCollection()
    # View is still pointing to the old list, so switch it now
    self.plugin_list.plugins = self.local
    self.plugin_list.populateList()
    plugin.enabled = "Up to date"
    # Update the current list too
    self.remote_plugin_list.populateList()
    self.messagebar.resetmessages('busy')
</t>
<t tx="ekr.20070127142814.744">
def viewPlugin(self):
    """View the selected plugin in a web browser"""
    plugin = self.remote_plugin_list.getSelectedPlugin()
    if plugin:
        webbrowser.open(plugin.getViewFilename())
</t>
<t tx="ekr.20070127142814.745">#@nonl

def checkConflicts(self):
    """Check for plugin conflicts"""
    plugin = self.plugin_list.getSelectedPlugin() 
    if not plugin:
        return 
    conflicts = self.local.getConflicts(plugin)
    if not conflicts:
        #dialog = Pmw.MessageDialog(self.top,
        #    title = 'No conflicts',
        #    defaultbutton = 0,
        #    message_text = 'There are no conflicts for %s.' % plugin.name)
        #dialog.iconname('Conflicts')
        #dialog.activate()
        swing.JOptionPane.showMessageDialog( self.top,
                                            "There are no conflicts for %s" % plugin.name,
                                            "No conflicts",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
                                            
    else:
        dialog = ListReportDialog(
            'Potential Conflicts for %s' % plugin.name,
            'Conflicts',
            [inColumns(item, [30]) for item in conflicts],
            400)

</t>
<t tx="ekr.20070127142814.746">class ButtonBox:
    
    def __init__( self ): #, gbl, gbc ):
        
        #gbc.gridy = gbc.RELATIVE
        self.bgroup = swing.ButtonGroup()
        self.panel = swing.Box.createHorizontalBox()
        #gbl.setConstraints( self.panel, gbc )
        #parent.add( self.panel )
        
    def getContainer( self ):
        return self.panel
        
    def add( self, name, command = None ):
        
        jbutton = swing.JButton( name )
        jbutton.actionPerformed = self.createCallback( command )
        self.bgroup.add( jbutton )
        self.panel.add( jbutton )

    def createCallback( self, command ):
        
        return lambda event: command()</t>
<t tx="ekr.20070127142814.747">class MessageBar( swing.JProgressBar ):
    
    def __init__( self ):
        
        swing.JProgressBar.__init__( self )
        self.messagebar = self
        self.messagebar.setStringPainted( 1 )
        self.messagebar.setString( "" )
        border = self.messagebar.getBorder()
        tborder = sborder.TitledBorder( border, 'Status:', sborder.TitledBorder.DEFAULT_JUSTIFICATION, sborder.TitledBorder.LEFT )
        self.messagebar.setBorder( tborder )
        ps = self.getPreferredSize()
        ps.width = ps.width * 2
        self.setPreferredSize( ps )
      
    
    
    def message( self, a, b ):
        
        if a == 'busy':
            self.messagebar.setString( b )
            self.messagebar.setIndeterminate( 1 )
            
    def resetmessages( self , a):
        
        self.messagebar.setString( "" )
        self.messagebar.setIndeterminate( 0 )
        
</t>
<t tx="ekr.20070127142814.748">
class ListReportDialog:
    """Shows a list of items to report to the user
    
    The list is a list of strings. It is assumed that the
    strings are of the format 'abc - xyz' and this control
    presents a filter list based on the list of distinct 
    values for abc.
    
    """
	&lt;&lt; class ListReportDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.749"></t>
<t tx="ekr.20070127142814.750">def __init__(self, title, name, list_data, width=300):
    """Initialize the dialog"""
    

    root = g.app.root
    #self.top = top = Tk.Toplevel(root)
    #g.app.gui.attachLeoIcon(self.top)
    #top.title(title)
    
    self.top = top = swing.JDialog()
    top.title( title )
    
    #self.frame = frame = Tk.Frame(top)
    #frame.pack(side="top", fill='both', expand=1, padx=5, pady=5)
    self.frame = frame = swing.JPanel()
    top.add( frame )
    
    
    filter_options = self.getFilterOptions(list_data)
    self.list_data = list_data
    self.list_data.sort()
    
@    
    self.box = Pmw.ScrolledListBox(frame,
            labelpos='nw',
            label_text=name,
            listbox_height = 6,
            usehullsize = 1,
            hull_width = width,
            hull_height = 200,
            items = list_data,
    )
    self.box.pack(side="bottom", fill='both', expand=1)
    self.box.component("listbox").configure(font=("Courier", 10))
@c
    self.box = swing.JList()
    view = swing.JScrollPane( self.box )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( name )
    view.setBorder( tborder )
    frame.add( view )
    
    
    #self.filter = Pmw.OptionMenu(frame,
    #        labelpos = 'w',
    #        label_text = 'Filter:',
    #        items = filter_options,
    #        menubutton_width = 16,
    #        command=self.populateList,
    #)    
    
    #self.filter.pack(side="top")
    
    self.filter = swing.JOptionPane( 'Filter:',
                                     swing.JOptionPane.PLAIN_MESSAGE,
                                     swing.JOptionPane.DEFAULT_OPTION,
                                     None,
                                     filter_options )
                                    
    
    frame.add( self.filter )
    
        
    #top.grab_set() # Make the dialog a modal dialog.
    #top.focus_force() # Get all keystrokes.
    #root.wait_window(top)
</t>
<t tx="ekr.20070127142814.751">
def getFilterOptions(self, list_data):
    """Return a list of filter items"""
    splitter = re.compile("\s{3,}")
    names = sets.Set()
    for item in list_data:
        names.add(splitter.split(item)[1].strip())
    name_list = list(names)
    name_list.sort()
    return ["All"] + name_list
</t>
<t tx="ekr.20070127142814.752">
def populateList(self, filter):
    """Populate the list"""

    # Get old selection so that we can restore it    
    current_text = self.box.getcurselection()
    if current_text:
        current_index = self.list_data.index(current_text[0])

    listitems = [item for item in self.list_data
        if item.endswith("   %s" % filter) or filter == "All"]

    self.box.setlist(listitems)    

    if current_text:
        try:
            self.box.setvalue((listitems[current_index],))
            self.box.component("listbox").see(current_index)
        except IndexError:
            pass # Sometimes the list is just different!
</t>
<t tx="ekr.20070127142814.753">
class Plugin:   
    """Represents a single plugin instance"""
	&lt;&lt; class Plugin declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.754">
max_name_width = 30
max_group_width = 10


</t>
<t tx="ekr.20070127142814.755">def __init__(self):
    """Initialize the plugin"""
    self.filename = None
    self.name = None
    self.is_plugin = False
    self.version = None
    self.description = ''
    self.handlers = []
    self.commands = []
    self.has_config = False
    self.can_read = False
    self.hash = None
    self.enabled = "Unknown"
    self.priority = None
    self.has_toplevel = False
    self.requires = []
    self.group = None
    self.versions = ''
</t>
<t tx="ekr.20070127142814.756">
def initFrom(self, location):
    """Initialize the plugin from the specified location"""

    # Initial properties
    self.filename = location
    self.name = self.getName(location)
    self.nicename = self.getNiceName(self.name)

    # Get the contents of the file
    try:
        text = self.getContents()
        self.getDetails(text)
    except InvalidPlugin, err:
        print 'InvalidPlugin',str(err)
        self.description = str(err)
    except:
        g.es('Unexpected exception in initFrom')
        g.es_exception()
</t>
<t tx="ekr.20070127142814.757">
def getName(self, location):

    """Determine the plugin name from the location"""

    raise NotImplementedError("Must Override")
</t>
<t tx="ekr.20070127142814.758">
def getContents(self):

    """Return the contents of the file"""

    raise NotImplementedError("Must override")    
</t>
<t tx="ekr.20070127142814.759">
def getNiceName(self, name):
    """Return a nice version of the plugin name
    
    Historically some plugins had "at_" and "mod_" prefixes to their
    name which makes the name look a little ugly in the lists. There is
    no real reason why the majority of users need to know the underlying
    name so here we create a nice readable version.
    
    """
    lname = name.lower()
    if lname.startswith("at_"):
        name = name[3:]
    elif lname.startswith("mod_"):
        name = name[4:]
    return name.capitalize()
</t>
<t tx="ekr.20070127142814.760">
def getDetails(self, text):
    """Get the details of the plugin
    
    We look for
        __version__
        hooks
        config
        commands
    """
    # The following line tried to detect plugins by looking 
    # for self.hasImport(text, "leoPlugins") - now we assume all .py are plugins
    self.is_plugin = not self.hasPattern(text, '__not_a_plugin__\s*=\s*True(?!")')
    self.version = self.getPattern(text, r'__version__\s*=\s*[\'"](.*?)[\'"]', "-")
    self.group = self.getPattern(text, r'__plugin_group__\s*=\s*[\'"](.*?)[\'"]', "-")
    # Allow both single and double triple-quoted strings.
    match1 = self.getMatch(text, r'"""(.*?)"""')
    match2 = self.getMatch(text, r"'''(.*?)'''")
    pat1 = match1 and match1.group(1)
    pat2 = match2 and match2.group(1)
    if pat1 and pat2:
        # Take the first pattern that appears.
        self.description = g.choose(match1.start() &lt; match2.start(),pat1,pat2)
    else:
        # Take whatever.
        self.description = pat1 or pat2 or 'Unknown'
    # g.trace('%4d %s' % (len(self.description),self.name))
    #self.commands = sets.Set(self.getPatterns(text, "def cmd_(\w*?)\("))
    cpats = self.getPatterns(text, "def cmd_(\w*?)\(")
    self.commands = hset()            #hset( self.getPatterns(text, "def cmd_(\w*?)\("))
    for z in cpats: self.commands.add( z )
    # Get a list of the handlers
    handler_list = self.getPattern(text, r'registerHandler\((.*?)\)')
    if handler_list:
        cpats = self.getPatterns(handler_list, r'["\'](.*?)["\']')
        self.handlers = hset()#sets.Set(self.getPatterns(handler_list, r'["\'](.*?)["\']'))
        for z in cpats: self.handlers.add( z )
    else:
        self.handlers = hset()
    # Look for the matching .ini file.
    pd = java.io.File( g.__file__ ).getParentFile()
    ini_file_name = g.os_path_join(
        g.app.loadDir,"..","plugins",
        self.getName(self.filename)+".ini")
    ini_file_name = g.os_path_abspath(ini_file_name)
    self.has_config = g.os_path_exists(ini_file_name)
    self.hash = sha.sha(text).hexdigest()
    self.can_read = True
    if USE_PRIORITY:
        self.priority = self.getPattern(text, r'__plugin_priority__\s*=\s*(.*?)$', "-")
    self.has_toplevel = self.hasPattern(text, "def topLevelMenu")
    self.getVersionHistory(text)
</t>
<t tx="ekr.20070127142814.761">
def hasPattern(self, text, pattern):
    
    """Return True if the text contains the pattern"""

    return self.getPattern(text, pattern) is not None
</t>
<t tx="ekr.20070127142814.762">
def hasImport(self, text, module_name):

    """Return True if the text includes an import of the module"""
    if self.hasPattern(text, "import %s" % module_name):
        return True

    if self.hasPattern(text, "from %s import" % module_name):
        return True

    return False
</t>
<t tx="ekr.20070127142814.763">
def getMatch(self, text, pattern):

    """Return a single match for the specified pattern in the text"""
    
    return re.search(pattern,text,re.MULTILINE + re.DOTALL)
</t>
<t tx="ekr.20070127142814.764">
def getPattern(self, text, pattern, default=None):

    """Return a single match for the specified pattern in the text or the default"""

    matches = self.getPatterns(text, pattern)
    if matches:
        return matches[0]
    else:
        return default
</t>
<t tx="ekr.20070127142814.765">
def getPatterns(self, text, pattern):

    """Return all matches of the pattern in the text"""

    exp = re.compile(pattern, re.MULTILINE + re.DOTALL)

    return exp.findall(text)
</t>
<t tx="ekr.20070127142814.766">
def asString(self, detail=False):
    
    """Return a string representation"""

    if not detail:
        if self.version &lt;&gt; "-":
            body = "%(nicename)s (v%(version)s)" % self.__dict__
        else:
            body = "%(nicename)s" % self.__dict__                        
        return inColumns((body, self.group, self.enabled), [self.max_name_width, self.max_group_width])
    else:
        return (
            "Name: %(nicename)s\n"
            "Version: %(version)s\n"
            "Active: %(enabled)s\n"
            "File: %(filename)s\n"
            "\n"
            "Description:\n%(description)s\n\n"
            "Has config file: %(has_config)s\n"
            "Commands: %(commands)s\n"
            "Handlers: %(handlers)s\n" % self.__dict__
        )
</t>
<t tx="ekr.20070127142814.767">
def writeTo(self, location):

    """Write this plugin to the file location"""

    filename = os.path.join(location, "%s.py" % self.name)
    try:
        f = file(filename, "w")
    except (IOError, OSError), err:
        raise InvalidPlugin(
            "Unable to open plugin file '%s': %s" % (filename, err))
    try:
        try:
            f.write(self.text)
        finally:
            f.close()
    except Exception, err:
        raise InvalidPlugin(
            "Unable to write plugin file '%s': %s" % (filename, err))
</t>
<t tx="ekr.20070127142814.768">
def getVersionHistory(self, text):
    """Try to extract the version history of this plugin
    
    This is all guesswork! We look for a Leo node called "Version history"
    or one called "Change log". If we find it then we assume that the contents
    are the version history.
    
    This only works if the plugin was developed in Leo as a @thin file.
    
    """
    #if self.group == "Core":
    #    import pdb; pdb.set_trace()
    extractor =r'.*\+node\S+?\&lt;\&lt; %s \&gt;\&gt;.*?\#\@\+at(.*)\#\@\-at.*\-node.*?\&lt;\&lt; %s \&gt;\&gt;.*'
    for name in ("version history", "change log"):
        searcher = re.compile(extractor % (name, name), re.DOTALL+re.M)
        match = searcher.match(text)
        if match:
            version_text = match.groups()[0]
            self.versions = version_text.replace("#", "")
            return
</t>
<t tx="ekr.20070127142814.769">
def getRequiredModules(self, plugin_collection):
    """Determine which modules are also required by this plugin
    
    We check for,
     - importing Tk and PMW
     - other plugins which are imported (using plugin_collection)
     - a __plugin_requires__ definition
     
    """
    requires = []
    
    if self.hasImport(self.text, "Tkinter"):
        requires.append("Tkinter")
        
    if self.hasImport(self.text, "Pmw"):
        requires.append("Pmw")

    
    imports = self.getPatterns(self.text, "import (\w+)") + \
              self.getPatterns(self.text, "from (\w+) import")
              
    for module_name in imports:
        if module_name in plugin_collection and module_name &lt;&gt; self.name:
            requires.append(module_name)
            
  
    
    directive_text = self.getPattern(self.text, r'__plugin_requires__\s*=\s*(.*?)$', "[]")
    
    try:
        directive = eval(directive_text)
    except:
        g.es("__plugin_requires__ not understood for %s: '%s'" % (
                self.name, directive_text))    
    else: 
        import java.lang.String as st
        if isinstance(directive, ( st )):
            requires.append(directive)
        else:
            requires.extend(directive)

    self.requires = hset() #sets.Set(requires)
    for z in requires:
        self.requires.add( z )</t>
<t tx="ekr.20070127142814.770">
class LocalPlugin(Plugin):
    """A plugin on the local file system"""
	&lt;&lt; class LocalPlugin declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.771">
</t>
<t tx="ekr.20070127142814.772">def getName(self, location):

    """Determine the plugin name from the location"""
    
    # return os.path.split(os.path.splitext(location)[0])[1]
    head,ext = g.os_path_splitext(location)
    path,name = g.os_path_split(head)
    return name
</t>
<t tx="ekr.20070127142814.773">
def getContents(self):

    """Return the contents of the file"""
    
    # g.trace('local')

    try:
        f = file(self.filename, "r")
    except (IOError, OSError), err:
        s = "Unable to open plugin file '%s': %s" % (self.name, err)
        print s
        raise InvalidPlugin(s)
    try:
        try:
            self.text = text = f.read()
        finally:
            f.close()
    except Exception, err:
        s = "Unable to read plugin file '%s': %s" % (self.name, err)
        print s
        raise InvalidPlugin(s)              
    return text
</t>
<t tx="ekr.20070127142814.774">
class CVSPlugin(Plugin):
    """A plugin on CVS"""
	&lt;&lt; class CVSPlugin declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.775">
</t>
<t tx="ekr.20070127142814.776">def getName(self, location):
    """Determine the plugin name from the location"""

    return re.match("(.*)/(.*?)\.py\?", location).groups()[1]
</t>
<t tx="ekr.20070127142814.777">def getContents(self):

    """Return the contents of the file"""
    
    # g.trace('cvs')

    # Connect to CVS
    try:
        url = urllib.urlopen(self.filename)
    except Exception, err:
        raise InvalidPlugin("Could not get connection to CVS: %s" % err)

    # Get the page with file content
    try:
        try:
            self.text = text = url.read()
        finally:
            url.close()
    except Exception, err:
        raise InvalidPlugin("Could not read file '%s' from CVS: %s" % (self.filename, err))
        
    return text        
</t>
<t tx="ekr.20070127142814.778">
def getViewFilename(self):
    
    """Return the url to view the file"""

    return self.filename.replace(r"/*checkout*", "") + "&amp;view=markup"
</t>
<t tx="ekr.20070127142814.779">import java.util.HashMap as hmap
class PluginCollection( hmap ):

    """Represents a collection of plugins"""
	&lt;&lt; class PluginCollection declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.780">plugin_class = None

</t>
<t tx="ekr.20070127142814.781">def __init__(self):
    """Initialize the plugin collection"""
</t>
<t tx="ekr.20070127142814.782">
def initFrom(self, location, callback=None):
    """Initialize the collection from the filesystem location.
    Returns a list of errors that occured.
    """
    if callback: callback("Looking for list of plugins")
    errors = []
    plugin_files = self.getFilesMatching(location)  
    for plugin_file in plugin_files:
        if callback: callback("Processing %s" % plugin_file)    
        plugin = self.plugin_class()
        # Get details
        try:
            plugin.initFrom(plugin_file)
        except Exception, err:
            errors.append((plugin_file, err))
        # Store anything that looks like a plugin
        if plugin.is_plugin:
            self[plugin.name] = plugin

    # Now we have to go back through and check for dependencies
    # We cannot do this up front because we need to know the names
    # of other plugins to detect the dependencies
    for plugin in self.values():
        plugin.getRequiredModules(self)

    return errors
</t>
<t tx="ekr.20070127142814.783">
def getAllFiles(self, location):
    
    """Return all the files in the location"""

    raise NotImplementedError("Must override")    
</t>
<t tx="ekr.20070127142814.784">
def sortedNames(self):

    """Return a list of the plugin names sorted alphabetically
    
    We use decorate, sort, undecorate to sort by the nice name!
    
    """

    names = [(item.nicename, item.name) for item in self.values()]
    names.sort()
    return [name[1] for name in names]
</t>
<t tx="ekr.20070127142814.785">
def setEnabledStateFrom(self, enabler):

    """Set the enabled state of each plugin using the enabler object"""
    for name in self:
        if name in enabler.actives:
            self[name].enabled = "On"
        else:
            self[name].enabled = "Off" 
</t>
<t tx="ekr.20070127142814.786">
def enablePlugin(self, plugin, enabler):
    """Enable a plugin"""
    plugin.enabled = "On"
    enabler.updateState(plugin)
</t>
<t tx="ekr.20070127142814.787">
def disablePlugin(self, plugin, enabler):
    """Enable a plugin"""
    plugin.enabled = "Off"
    enabler.updateState(plugin)
</t>
<t tx="ekr.20070127142814.788">
def getConflicts(self, plugin):

    """Find conflicting hook handlers for this plugin"""

    conflicts = []
    for this_plugin in self.values():
        if this_plugin.name &lt;&gt; plugin.name:
            intersection = [ x for x in plugin.handlers if x in this_plugin.handlers ]
            #for conflict in plugin.handlers.intersection(this_plugin.handlers): -- intersection does not exist
            for conflict in intersection:
                conflicts.append((this_plugin.name, conflict))

    return conflicts
</t>
<t tx="ekr.20070127142814.789">
def getGroups(self):
    """Return a list of the Plugin group names"""
    #groups = list(sets.Set([plugin.group for plugin in self.values()]))
    pg = [ plugin.group for plugin in self.values() ]
    groups = []
    for z in pg:
        if z not in groups:
            groups.append( z )
            
    groups.sort()
    return groups

</t>
<t tx="ekr.20070127142814.790">
class LocalPluginCollection(PluginCollection):
    """Represents a plugin collection based on the local file system"""
	&lt;&lt; class LocalPluginCollection declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.791">plugin_class = LocalPlugin


</t>
<t tx="ekr.20070127142814.792">def getFilesMatching(self, location):

    """Return all the files matching the pattern"""

    return [filename for filename in self.getAllFiles(location)
                if fnmatch.fnmatch(filename, "*.py")]
</t>
<t tx="ekr.20070127142814.793">
def getAllFiles(self, location):

    """Return all the files in the location"""

    return [os.path.join(location, filename) for filename in os.listdir(location)]
</t>
<t tx="ekr.20070127142814.794">
class CVSPluginCollection(PluginCollection):

    """Represents a plugin collection based located in a CVS repository"""
	&lt;&lt; class CVSPluginCollection declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.795">plugin_class = CVSPlugin


</t>
<t tx="ekr.20070127142814.796">def getFilesMatching(self, location):
    """Return all the files in the location"""
    #
    # Find files
    text = self.getListingPage(location)
    cvs_host, _, cvs_location = location.split("/", 2)
    filename = re.compile(r'href="/viewcvs.py/(%s)/(.*?\.py\?rev=.*?)\&amp;view=auto"' % cvs_location)
    return [r"http://%s/viewcvs.py/*checkout*/%s/%s" % (cvs_host, item[0], item[1])
                for item in filename.findall(text)]
</t>
<t tx="ekr.20070127142814.797">
def getListingPage(self, location):
    """Return the HTML page with files listed"""
    #
    # Connect to CVS
    try:
        url = urllib.urlopen(r"http://%s" % location)
    except Exception, err:
        raise InvalidCollection("Could not get connection to CVS: %s" % err)
    #
    # Get the page with files listed
    try:
        try:
            text = url.read()
        finally:
            url.close()
    except Exception, err:
        raise InvalidCollection("Could not read from CVS: %s" % err)
    return text    
</t>
<t tx="ekr.20070127142814.798">
def setEnabledStateFrom(self, collection):
    """Set the enabled state based on another collection"""
    for plugin in self.values():
        try:
            local_version = collection[plugin.name]
        except KeyError:
            plugin.enabled = "Not installed"
        else:
            if local_version.version &lt; plugin.version:
                plugin.enabled = "Update available"
            elif local_version.hash &lt;&gt; plugin.hash:
                plugin.enabled = "Changed"
            else:
                plugin.enabled = "Up to date"
</t>
<t tx="ekr.20070127142814.799">
class EnableManager:

    """Manages the enabled/disabled status of plugins"""
	&lt;&lt; class EnableManager declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.800">
</t>
<t tx="ekr.20070127142814.801">def initFrom(self, location):
    """Initialize the manager from a folder"""
    manager_filename = os.path.join(location, "pluginsManager.txt")

    # Get the text of the plugin manager file
    try:
        f = file(manager_filename, "r")
    except (IOError, OSError), err:
        raise InvalidManager("Unable to open plugin manager file '%s': %s" % 
                                (manager_filename, err))
    try:
        try:
            self.text = text = f.read()
        finally:
            f.close()
    except Exception, err:
        raise InvalidManager("Unable to read manager file '%s': %s" % 
                                (manager_filename, err))              
    self.parseManagerText(text)
</t>
<t tx="ekr.20070127142814.802">
def writeFile(self, location):
    """Initialize the manager from a folder"""
    manager_filename = os.path.join(location, "pluginsManager.txt")

    # Get the text of the plugin manager file
    try:
        f = file(manager_filename, "w")
    except (IOError, OSError), err:
        raise InvalidManager("Unable to open plugin manager file '%s': %s" % 
                                (manager_filename, err))
    try:
        try:
            f.write(self.text)
        finally:
            f.close()
    except Exception, err:
        raise InvalidManager("Unable to write manager file '%s': %s" % 
                                (manager_filename, err))              
    self.parseManagerText(self.text)
</t>
<t tx="ekr.20070127142814.803">
def parseManagerText(self, text):
    """Parse the text in the manager file"""

    # Regular expressions for scanning the file
    find_active = re.compile(r"^\s*(\w+)\.py", re.MULTILINE)
    find_inactive = re.compile(r"^\s*#\s*(\w+)\.py", re.MULTILINE)
    find_manager = re.compile(r"^\s*plugin_manager\.py", re.MULTILINE)

    if 1: # Put the first match in the starts dict.
        starts = {}
        for kind,iter in (
            ('on',find_active.finditer(text)),
            ('off',find_inactive.finditer(text)),
        ):
            for match in iter:
                name = match.groups()[0]
                start = match.start()
                if start != -1:
                    bunch = starts.get(name)
                    if not bunch or bunch.start &gt; start:
                      starts[name] = g.Bunch(
                        kind=kind,name=name,start=start,match=match)
                    
        #self.actives = dict(
        #    [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='on'] )
        x = [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='on']
        self.actives = {}
        for z in x:
            self.actives[ z[ 0 ] ] = z[ 1 ]
            
        #self.inactives = dict(
        #    [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='off'] )
        x = [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='off']
        self.inactives = {}
        for z in x:
            self.inactives[ z[ 0 ] ] = z[ 1 ]
            
        if 0: # debugging.
            starts2 = [(bunch.start,bunch.name,bunch.kind) for bunch in starts.values()]
            starts2.sort()
            g.trace(g.listToString(starts2,tag='starts2 list'))
            g.trace(g.dictToString(self.actives,tag='Active Plugins'))
                  
    else: # Original code.
        # Get active plugin defintions
        self.actives = dict([(match.groups()[0], match) 
            for match in find_active.finditer(text)])
    
        # Get inactive plugin definitions
        self.inactives = dict([(match.groups()[0], match) 
            for match in find_inactive.finditer(text)])

    # List of all plugins
    self.all = {}
    self.all.update(self.actives)
    self.all.update(self.inactives)

    # Locaction of the plugin_manager.py plugin - this is where
    # we add additional files
    print "LOCATE!! %s" % text
    self.manager = find_manager.search(text)
    print "sm is %s" % self.manager
</t>
<t tx="ekr.20070127142814.804">
def updateState(self, plugin):
    """Update the state for the given plugin"""
    # Get the filename for the new entry
    if plugin.enabled == "On":
        newentry = "%s.py" % plugin.name
    else:
        newentry = "#%s.py" % plugin.name 

    print plugin.name
    print self.all
    if plugin.name in self.all:
        # Plugin exists in the management file
        item = self.all[plugin.name]
        # TODO: Unicode issues with the following line??
        self.text = "%s%s%s" % (
            self.text[:item.start()],
            str(newentry),
            self.text[item.end():])      
    else:
        # Plugin doesn't exist - add it at a suitale place
        print self.text
        #self.text = "%s%s\n%s" % (
        #    self.text[:self.manager.start()],
        #    str(newentry),
        #    self.text[self.manager.start():])
        self.text = "%s%s" %( self.text, str( newentry ) )
    
    self.writeFile(g.os_path_join( g.app.loadDir,"..","plugins"))
</t>
<t tx="ekr.20070127142814.805">"""
A plugin to manage Leo's Plugins:

- Enables and disables plugins.
- Shows plugin details.
- Checks for conflicting hook handlers.
- Checks for and updates plugins from the web.
"""

__version__ = "0.14"
__plugin_name__ = "Plugin Manager"
__plugin_priority__ = 10000
__plugin_requires__ = ["plugin_menu"]
__plugin_group__ = "Core"

&lt;&lt; version history &gt;&gt;
&lt;&lt; define importLeoGlobals &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; todo &gt;&gt;

USE_PRIORITY = False # True: show non-functional priority field.

@others

if __name__ == "__main__":
    if ok:
        g.createStandAloneApp(pluginName=__name__)
        topLevelMenu()</t>
<t tx="ekr.20070127142814.806">@

0.1 Paul Paterson:
    - Initial version

0.2 EKR:
    - The check for .ini files looks for the actual x.ini file.
      (This required that spellpyx uses spellpyx.ini rather than mod_spelling.ini.)
    - Minor stylistic changes.
0.4 EKR:
    - Added USE_PRIORITY switch.
      Priority is non-functional, and isn't needed.
      Leo loads plugins in the order in which they appear in pluginsManager.txt.
      Furthermore, this plugin preserves that order.
0.5 EKR:
    - Make sure to do nothing if Pmw is not defined.
0.6 Paul Paterson:
    - Fixed incorrect detection of version if single quotes used
    - Now always detects a file as a plugin (previously only did this if it imported leoPlugins)
    - Fixed incorrect detection of handlers if single quotes used
    - Fixed incorrect detection of multiple handlers in a single line.
0.7 EKR:
    - Grrrrrrrrrr.  The Sets module is not defined in Python 2.2.
      This must be replaced.  This is too important a plugin for it not to work everywhere.
    - Added better import tests, and message when import fails.
    - Added an init method, although a simple raise would also work.
0.8 EKR:
    - Well, that was easy.  Put sets.py from Python 2.4 in extensions folder.
    - Use g.importExtension rather than import to get sets module.
0.9 Paul Paterson:
    - Remove the "not referenced" status. All plugins are not active or inactive.
    - Changed the list view to have the status at the end of the line
    - Changed format of list view to be fixed font so that it looks cleaner
    - Also changed format of conflict list view
    - If a file contains "__not_a_plugin__ = True" then it will be omitted from the list
    - Now looks for and reports the __plugin_group__ in the view and list
    - Can now filter the plugins by their __plugin__group__
    - Set __plugin_group__ to "Core"
    - Renamed active/inactive to on/off as this works better with the groups
    - Added version history display to plugin view
0.10 Paul Paterson:
    - Changed the names in the plugin list view to remove at_, mod_ and capitalized
    - Remove dblClick event from plugin list - it wasn't doing anything
    - Can now be run stand-alone to aid in debugging problems
0.11 EKR:
    - Use stand-alone leoGlobals module to simplify code.
0.12 EKR:
    - Folded in some minor changes from Paul to support AutoTrees plugin.
0.13 Paul Paterson
    - Fixed path in installPlugin that ignore the local_paths setting
    - Generalized code to support LeoUpdate plugin.
0.14 EKR:
    - Several methods now return if get.keywords('c') is None.
      This may fix some startup bugs, or not.</t>
<t tx="ekr.20070127142814.807">def importLeoGlobals():
    
    '''
    Try to import leoGlobals from the leo/src directory, assuming that
    the script using this function is in a subdirectory of the leo directory.
    '''
    
    plugins_path = os.path.abspath(
        os.path.join(os.path.dirname(__file__),'..','src'))
    
    if plugins_path in sys.path:
        return None
    else:
        sys.path.append(plugins_path)
        try:
            import leoGlobals as g
            return g
        except ImportError:
            print 'can not import leoGlobals from %s' % (plugins_path)
            return None</t>
<t tx="ekr.20070127142814.808">#
# If these don't import then your Python install is hosed anyway so we don't
# protect the import statements
import fnmatch
import os
import re
import sha
import sys
import urllib
import threading
import traceback

try:
    import leoGlobals as g
    standalone = False
except ImportError:
    standalone = True
    g = importLeoGlobals()

ok = g is not None
if ok:
    try:
        #Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
        #Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
        #sets = g.importExtension('sets',  pluginName=__name__,verbose=True)
        import sets
        import leoPlugins
        import java
        import java.lang.String as jstring
        import javax.swing as swing
        import java.awt as awt
        import javax.swing.border as sborder
        import java.awt.event as aevent
        import javax.swing.event as sevent
        import javax.swing.table as stable
        import jarray
    except Exception:
        import sys
        s = 'plugins_manager.py: %s: %s' % (sys.exc_type,sys.exc_value)
        print s ; g.es(s,color='blue')
        ok = False</t>
<t tx="ekr.20070127142814.809">"""

Todo list:

- getting subset of plugins from CVS
- categorize plugins
- filter on categories
- size of plugin
- add required plugins to conflict check
- help for nomenclature

Done

- restore list top position when updating plugin list 
- proper view of remote file (colourized code)
- __requires__ list for plugins
- show __requires__
- proper dialog to show conflict list and error list from CVS

"""</t>
<t tx="ekr.20070127142814.810">def init():
    
    # Ok for unit testing: adds menu.
    if ok:
        g.plugin_signon(__name__)

    return ok</t>
<t tx="ekr.20070127142814.811"># This is called from plugins_menu plugin.
# It should only be defined if the extension has been registered.

def topLevelMenu():
    
    """Manage the plugins"""
    dlg = ManagerDialog()</t>
<t tx="ekr.20070127142814.812">def createPluginsMenu():
    
    plugins = swing.JMenu( "Plugins" )
    jmi = swing.JMenuItem( "View Plugin Manager" )
    jmi.actionPerformed = lambda event: ManagerDialog()
    plugins.add( jmi )
    plugins.addSeparator()
    def createAbout( module = None):
        
        doc = ""
        if hasattr( module, "__doc__" ):
            doc = module.__doc__
        
        version = "Version ?"
        if hasattr( module, "__version__" ):
            version = "Version %s" % module.__version__
        
        jd = swing.JDialog()
        jd.setTitle( "About %s" % module.__name__ )
        jp = swing.JPanel( java.awt.BorderLayout() )
        jlabel = swing.JLabel( version, swing.SwingConstants.CENTER )
        jp.add( jlabel, java.awt.BorderLayout.NORTH )
        jtp = swing.JTextPane()
        jtp.setText( doc )
        jtp.setCaretPosition( 0 )
        jtp.setEditable( 0 )
        jsp = swing.JScrollPane( jtp )
        tk = java.awt.Toolkit.getDefaultToolkit()
        ss = tk.getScreenSize()
        ss.width = ss.width/ 2
        ss.height = ss.height / 2
        jsp.setPreferredSize( ss )
        jp.add( jsp )
        cpanel = swing.JPanel()
        close = swing.JButton( "Close" )
        close.actionPerformed = lambda event: jd.dispose()
        cpanel.add( close )
        jp.add( cpanel, java.awt.BorderLayout.SOUTH )
        jd.add( jp )
        jd.pack()
        g.app.gui.center_dialog( jd )
        jd.visible = 1
        
    import leoPlugins
    for z in leoPlugins.loadedModules:
        mod = leoPlugins.loadedModules[ z ]
        jmi = swing.JMenuItem( z )
        jmi.actionPerformed = lambda event, mod = mod: createAbout( module = mod )
        plugins.add( jmi )

    
    
    
    return plugins
    
</t>
<t tx="ekr.20070127142814.813">class InvalidPlugin(Exception):
    """The plugin is invalid"""
    
class InvalidCollection(Exception):
    """The plugin collection is invalid"""
    
class InvalidManager(Exception):
    """The enable manager is invalid"""
</t>
<t tx="ekr.20070127142814.814">
def inColumns(data, columnwidths):
    """Return the items of data with the specified column widths
    
    The list of widths should be one less than the list of data, eg
        inColumns((10,20,30), (5,5))
    """
    format = ""
    for col in columnwidths:
        format += "%%-%ds" % col
    format += "%s"
    #
    return format % data
</t>
<t tx="ekr.20070127142814.815">if 0:
    @others</t>
<t tx="ekr.20070127142814.816">class NameSpace:
    """Just an object to dump properties in"""
    
    @others</t>
<t tx="ekr.20070127142814.817">def __init__(self, **kw):
    self.__dict__.update(kw)</t>
<t tx="ekr.20070127142814.818">class BlackHole:
    """Try to call a method on this and it will just dissapear into the void!"""
    
    @others</t>
<t tx="ekr.20070127142814.819">def __getattr__(self, name):
    """Return a black hole!"""
    return BlackHole()</t>
<t tx="ekr.20070127142814.820">def __call__(self, *args, **kw):
    """Call this .... """
    return None</t>
<t tx="ekr.20070127142814.821">class FakeLeoGlobals:
    """A class to represent leoGlobals when were are running in standalone mode"""
    
    @others</t>
<t tx="ekr.20070127142814.822">def __init__(self):
    """Initialize the fake object"""
    self.app = NameSpace()
    self.app.root = Tk.Tk()
    self.app.gui = BlackHole()  
    self.app.loadDir = os.path.join(os.path.split(__file__)[0], "..", "src")

    self.Bunch = NameSpace
    
    for name in dir(os.path):
        setattr(self, "os_path_%s" % name, getattr(os.path, name))
    </t>
<t tx="ekr.20070127142814.823">def choose(self, cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b</t>
<t tx="ekr.20070127142814.824"></t>
<t tx="ekr.20070127142814.825">
class PluginView( swing.JPanel, aevent.ComponentListener ):
    """Frame to display a plugin's information"""
	&lt;&lt; class PluginView declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.826">
</t>
<t tx="ekr.20070127142814.827">def __init__(self, parent, *args, **kw):
    """Initialize the view"""
    #Tk.Frame.__init__(self, parent, *args, **kw)
    swing.JPanel.__init__( self )
    self.addComponentListener( self )
    sl = swing.SpringLayout()
    self.setLayout( sl )

    
    name_label = swing.JLabel( "Name:" )
    self.add( name_label )
    self.name2 = self.EntryField( labelpos = 'w', label_text='Name:' )
    self.add( self.name2 )
    
    sl.putConstraint( sl.NORTH, self.name2, 0, sl.NORTH, self )
    sl.putConstraint( sl.WEST, self.name2, 0, sl.EAST, name_label )
    sl.putConstraint( sl.NORTH, name_label, 0, sl.NORTH, self )
    sl.putConstraint( sl.EAST, self, self.name2.getPreferredSize().width, sl.EAST, self.name2 )
    
    version_label = swing.JLabel( "Version:" )
    self.add( version_label )
    self.version = self.EntryField( labelpos = 'w', label_text='Version:' )
    self.add( self.version )
    sl.putConstraint( sl.NORTH, self.version, 0, sl.SOUTH, self.name2 )
    sl.putConstraint( sl.WEST, self.version, 0, sl.EAST, version_label )
    sl.putConstraint( sl.NORTH, version_label, 0, sl.SOUTH, self.name2 )
    
    status_label = swing.JLabel( "Status:" )
    self.add( status_label )
    self.status = self.EntryField( labelpos='w', label_text='Status:' )
    self.add( self.status )
    sl.putConstraint( sl.NORTH, self.status, 0, sl.SOUTH, self.version )
    sl.putConstraint( sl.WEST, self.status, 0 , sl.EAST, status_label )
    sl.putConstraint( sl.NORTH, status_label, 0, sl.SOUTH, self.version )
    
    group_label = swing.JLabel( "Group:" )
    self.add( group_label )
    self.group = self.EntryField( labelpos='w', label_text='Group:' )
    self.add( self.group )
    sl.putConstraint( sl.NORTH, self.group, 0, sl.SOUTH, self.status)
    sl.putConstraint( sl.WEST, self.group, 0, sl.EAST, group_label )
    sl.putConstraint( sl.NORTH, group_label, 0, sl.SOUTH, self.status )


    fn_group = swing.JLabel( "Filename:")
    self.add( fn_group )
    self.filename = self.EntryField( labelpos = 'w', label_text='Filename:' )
    self.add( self.filename )
    sl.putConstraint( sl.NORTH, self.filename, 0, sl.SOUTH, self.group)
    sl.putConstraint( sl.WEST, self.filename, 0, sl.EAST, fn_group )
    sl.putConstraint( sl.NORTH, fn_group, 0, sl.SOUTH, self.group )

    
    ini_group = swing.JLabel( "Has INI:" )
    self.add( ini_group )
    self.has_ini = self.EntryField( labelpos = 'w', label_text='Has INI:' )
    self.add( self.has_ini )
    sl.putConstraint( sl.NORTH, self.has_ini, 0, sl.SOUTH, self.filename )
    sl.putConstraint( sl.WEST, self.has_ini, 0, sl.EAST, ini_group )
    sl.putConstraint( sl.NORTH, ini_group, 0, sl.SOUTH, self.filename )
    

    htl_group = swing.JLabel( "Has top level:" )
    self.add( htl_group )
    self.has_toplevel = self.EntryField( labelpos='w', label_text='Has top level:' )
    self.add( self.has_toplevel )
    sl.putConstraint( sl.NORTH, self.has_toplevel, 0, sl.SOUTH, self.has_ini )
    sl.putConstraint( sl.WEST, self.has_toplevel, 0, sl.EAST, htl_group )
    sl.putConstraint( sl.NORTH, htl_group, 0, sl.SOUTH, self.has_ini )
    #sl.putConstraint( sl.EAST, htl_group, 0, sl.EAST, self.has_toplevel )
    
    sl.putConstraint( sl.EAST, name_label ,0 ,sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, version_label ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, status_label ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, group_label  ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, fn_group  ,0, sl.EAST, htl_group )
    sl.putConstraint( sl.EAST, ini_group  ,0, sl.EAST, htl_group )

    if USE_PRIORITY:
        #self.priority = Pmw.EntryField(self.top,
        #    labelpos = 'w',
        #    label_text = 'Priority:',
        #)
        
        #self.priority.pack(side="top", fill="x", expand=0)
        self.priority = self.EntryField( eftop, labelpos = 'w', label_text='Priority:' )
    
    
    self.text_panel = swing.JTabbedPane()
    self.add( self.text_panel ) #, awt.BorderLayout.CENTER )
    sl.putConstraint( sl.NORTH, self.text_panel, 5, sl.SOUTH, self.has_toplevel )
    sl.putConstraint( sl.EAST, self.text_panel, 5, sl.EAST, self )
    sl.putConstraint( sl.WEST, self.text_panel, 5, sl.WEST, self )
    
    description_panel = swing.JPanel()
    description_panel.setLayout( awt.GridLayout( 1, 1 ) )
    self.text_panel.addTab( 'Description', description_panel )
    version_panel = remote_list_page = swing.JPanel()
    version_panel.setLayout( awt.GridLayout( 1, 1 ) )
    self.text_panel.addTab( 'Version History', version_panel )
    tp_dimen = awt.Dimension( 200, 200 )
    self.text_panel.setPreferredSize( tp_dimen )
    self.text_panel.setMinimumSize( tp_dimen )
    self.text_panel.setMaximumSize( tp_dimen )

    self.description = swing.JTextArea()
    self.description.setEditable( False )
    #self.description.setLineWrap( True )
    view = swing.JScrollPane( self.description )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugin Description" )
    view.setBorder( tborder )
    
    description_panel.add( view )

    self.version_history = swing.JTextArea()
    self.version_history.setEditable( False )
    #self.version_history.setLineWrap( True )
    view = swing.JScrollPane( self.version_history )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugin History" )
    view.setBorder( tborder )
    version_panel.add( view )        
    
    

    self.jlists = swing.JPanel( awt.GridLayout( 1, 3 ) )    
    lav1 = self.getJList( "Commands" )
    self.commands = lav1[ 0 ]
    self.jlists.add( lav1[ 1 ] )


    lav2 = self.getJList( "Hooks" )
    self.handlers = lav2[ 0 ]
    self.jlists.add( lav2[ 1 ] )
    
    lav3 = self.getJList( "Requires" )
    self.requires = lav3[ 0 ]
    self.jlists.add( lav3[ 1 ] )
    
    self.add( self.jlists )
    sl.putConstraint( sl.NORTH, self.jlists, 5, sl.SOUTH, self.text_panel )
    sl.putConstraint( sl.EAST, self.jlists, 5, sl.EAST, self )
    sl.putConstraint( sl.WEST, self.jlists, 5, sl.WEST, self )
    sl.putConstraint( sl.SOUTH, self, 20, sl.SOUTH, self.jlists )

    
@    
    if USE_PRIORITY:
        Pmw.alignlabels([
            self.name, self.version, self.status, self.group,
            self.filename, self.has_ini, self.has_toplevel,
            self.priority,
        ])
    else:
         Pmw.alignlabels([
            self.name, self.version, self.status, self.group,
            self.filename, self.has_ini, self.has_toplevel,
        ])
@c
    </t>
<t tx="ekr.20070127142814.828">
def showPlugin(self, plugin):
    """Show a plugin"""
    self.name2.setentry(plugin.name)
    self.version.setentry(plugin.version)
    self.group.setentry(plugin.group)
    self.filename.setentry(g.os_path_abspath(plugin.filename)) # EKR
    self.status.setentry(plugin.enabled)
    self.has_ini.setentry(
        g.choose(plugin.has_config,"Yes","No"))
    self.has_toplevel.setentry(
        g.choose(plugin.has_toplevel,"Yes","No"))
    if USE_PRIORITY:
        self.priority.setentry(plugin.priority)
    
    self.description.setText( plugin.description.strip() )
    self.description.setCaretPosition( 0 )
    self.version_history.setText( plugin.versions.strip() )
    self.version_history.setCaretPosition( 0 )
    #self.description.settext(plugin.description.strip())
    #self.version_history.settext(plugin.versions.strip())
    self.commands.setlist(plugin.commands)
    self.handlers.setlist(plugin.handlers)
    self.requires.setlist(plugin.requires)
    </t>
<t tx="ekr.20070127142814.829">class PVList( swing.JList ):
    
    def __init__( self ):
        swing.JList.__init__( self )
        self.setVisibleRowCount( 5 )
        #g = self.getGraphics()
        #fm = g.getFontMetrics()
        #width = fm.stringWidth( 'xxxxxxxxxx' )
        #self.setFixedCellWidth( width )
        
    def setlist( self, items ):
        
        
        import java.util.HashSet
        items2 = java.util.HashSet( items )
        self.setListData( items2.toArray() )
        #if items.__class__ == java.util.HashSet:
        #    self.setListData( items.toArray() )
        #else:
        #    self.setListData( items )

def getJList( self, title ):

    jlist =  self.PVList()
    view = swing.JScrollPane( jlist )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( title )
    view.setBorder( tborder )
    return jlist, view
</t>
<t tx="ekr.20070127142814.830">def componentResized( self, event ):
    pass
    #sz = self.getSize()
    #sz.height = sz.height/3
    #self.text_panel.setPreferredSize( sz )
    #self.text_panel.setMaximumSize( sz )
    #self.jlists.setMaximumSize( sz )
    #self.jlists.setPreferredSize( sz )
    
def componentHidden( self, event ):
    pass
    
def componentMoved( self, event ):
    pass
    
def componentShown( self, event ):
    pass</t>
<t tx="ekr.20070127142814.831">class EntryField( swing.JTextField ):
    
    def __init__( self, labelpos = 'west', label_text= "" ):
        
        #swing.JPanel.__init__( self )
        swing.JTextField.__init__( self, 15 )
        self.entry = self
        self.setMaximumSize( self.getPreferredSize() )
        self.setMinimumSize( self.getPreferredSize() )
        
        

    def setentry( self, data ):
        self.entry.setText( data )
        self.entry.setCaretPosition( 0 )</t>
<t tx="ekr.20070127142814.832">
class PluginList( swing.JPanel, sevent.ListSelectionListener ):
    """Frame to display a list of plugins"""
	&lt;&lt; class PluginList declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.833">filter_options = []
title = "List"
secondtitle = "Groups"


</t>
<t tx="ekr.20070127142814.834">def __init__(self, parent, plugin_view, plugins ): #, *args, **kw):
    """Initialize the list"""
    
    swing.JPanel.__init__( self )
    sl = swing.SpringLayout()
    self.setLayout( sl )

    self.box = swing.JList()
    self.box.addListSelectionListener( self )
    self.box.setVisibleRowCount( 5 )
    view = swing.JScrollPane( self.box )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Plugins" )
    view.setBorder( tborder )
    self.add( view )
    sl.putConstraint( sl.NORTH, view, 5, sl.NORTH, self )


    import java.lang.Object as jobject
    
    cl = swing.SpringLayout()
    c1 = swing.JPanel( cl )
    c1.setBorder( sborder.LineBorder.createBlackLineBorder() )
    label1 = swing.JLabel( self.title )
    c1.add( label1 )
    cl.putConstraint( cl.NORTH, label1, 0, cl.NORTH, c1 )
    
    self.filter = swing.JComboBox( self.filter_options )
    self.filter.addActionListener( self.Populater( self ) )                     

    c1.add( self.filter )
    cl.putConstraint( cl.NORTH, self.filter, 0, cl.SOUTH, label1 )
    cl.putConstraint( cl.SOUTH, c1, 0, cl.SOUTH, self.filter )
    cl.putConstraint( cl.EAST, c1, 0, cl.EAST, label1 )
    nsize = self.syncSize( label1.getPreferredSize(), self.filter.getPreferredSize() )
    label1.setPreferredSize( nsize )
    self.filter.setPreferredSize( nsize )
    
    self.add( c1 )
    sl.putConstraint( sl.NORTH, c1, 5, sl.SOUTH, view )
    sl.putConstraint( sl.WEST, c1, 5, sl.WEST, self )                       


    cl = swing.SpringLayout()
    c2 = swing.JPanel( cl )
    c2.setBorder( sborder.LineBorder.createBlackLineBorder() )
    label2 = swing.JLabel( self.secondtitle )
    c2.add( label2 )
    cl.putConstraint( cl.NORTH, label2, 0, cl.NORTH, c2 )
    
    self.secondfilter = swing.JComboBox( [ 'All',] )
    self.secondfilter.addActionListener( self.Populater( self ) )
    c2.add( self.secondfilter )
    nsize = self.syncSize( label2.getPreferredSize(), self.secondfilter.getPreferredSize() )
    label2.setPreferredSize( nsize )
    self.secondfilter.setPreferredSize( nsize )
    
    cl.putConstraint( sl.NORTH, self.secondfilter, 0, sl.SOUTH, label2 )
    cl.putConstraint( sl.SOUTH, c2, 0, cl.SOUTH, self.secondfilter )
    cl.putConstraint( sl.EAST, c2, 5, cl.EAST, label2 )
    
    self.add( c2 )
    sl.putConstraint( sl.NORTH, c2, 5, sl.SOUTH, view )
    sl.putConstraint( sl.WEST, c2, 5, sl.EAST, c1 )
    sl.putConstraint( sl.SOUTH, self, 5, sl.SOUTH, c1 )
    sl.putConstraint( sl.EAST, self, 5, sl.EAST, view )
    
    self.plugin_view = plugin_view
    self.plugins = plugins


</t>
<t tx="ekr.20070127142814.835">def syncSize( self, s1, s2 ):
    
    nsize = awt.Dimension( 0, 0 )
    if s1.width &gt; s2.width:
        nsize.width = s1.width
    else:
        nsize.width = s2.width
        
        
    if s1.height &gt; s2.height:
        nsize.height = s1.height
    else:
        nsize.height = s2.height
        
    return nsize</t>
<t tx="ekr.20070127142814.836">
def onClick(self):
    self.valueChanged( None )

def valueChanged( self, event ):
    """Select an item in the list"""
    #sels = self.box.getcurselection()
    sels = self.box.getSelectedValue()
    #if len(sels) == 0:
    #    pass
    #else:
    if sels == None: pass
    else:
        self.plugin_view.showPlugin( self.local_dict[ sels ] ) #self.local_dict[sels[0]])
        self.plugin_view.description.invalidate()
        self.plugin_view.version_history.invalidate()
        self.repaint()
        #self.invalidate()</t>
<t tx="ekr.20070127142814.837">
def populateList(self, filter=None):
    """Populate the plugin list"""
    if not self.plugins:
        #self.box.setlist([])
        self.box.setListData( [] )
        return
    #if filter is None:
    #filter = self.filter.getcurselection()
    values = self.filter.getSelectedItem()
    filter = values
    #secondfilter = self.secondfilter.getcurselection()
    values = self.secondfilter.getSelectedItem()
    secondfilter = values
    #
    # Get old selection so that we can restore it    
    #current_text = self.box.getcurselection()
    current_text = self.box.getSelectedValue()
    if current_text:
        #current_index = self.listitems.index(current_text[0])
        current_index = self.listitems.index( current_text )
    #
    # Show the list
    #self.local_dict = dict([(self.plugins[name].asString(), self.plugins[name])
    #                            for name in self.plugins])
    self.local_dict = {}
    lddata = [(self.plugins[name].asString(), self.plugins[name]) for name in self.plugins]
    for z in lddata:
        self.local_dict[ z[ 0 ] ] = z[ 1 ]
        
    self.listitems = [self.plugins[name].asString() 
                        for name in self.plugins.sortedNames()
                        if filter in ("All", self.plugins[name].enabled) 
                        and secondfilter in ("All", self.plugins[name].group)]
    #self.box.setlist(self.listitems)   
    self.box.setListData( self.listitems ) 
    #
    if current_text:
        try:
            self.box.setSelectedValue( ( self.listitems[ current_index ], ), 1 )
            #self.box.setvalue((self.listitems[current_index],))
            #self.box.component("listbox").see(current_index)
        except IndexError:
            pass # Sometimes the list is just different!
        else:
            self.onClick()

</t>
<t tx="ekr.20070127142814.838">
def getSelectedPlugin(self):
    """Return the selected plugin"""
    #sels = self.box.getcurselection()
    
    sels = self.box.getSelectedValue()
    if sels == None: return None
    #if len(sels) == 0:
    #    return None
    else:
        #return self.local_dict[sels[0]]
        return self.local_dict[ sels ]</t>
<t tx="ekr.20070127142814.839">
def setSecondFilterList(self, list_items):
    """Set the items to use in the second filter list"""
    #self.secondfilter.setitems(list_items)
    sf = self.secondfilter
    #sf.setOptions( list_items )
    sf.removeAllItems()
    for z in list_items:
        sf.addItem( z )
        
</t>
<t tx="ekr.20070127142814.840">class Populater( aevent.ActionListener ):
    
    def __init__( self, pl ):
        
        self.pl = pl
        
    def actionPerformed( self, event ):
        
        self.pl.populateList()</t>
<t tx="ekr.20070127142814.841">
class LocalPluginList(PluginList):
    """A list showing plugins based on the local file system"""
	&lt;&lt; class LocalPluginList declarations &gt;&gt;
</t>
<t tx="ekr.20070127142814.842">title = "Locally Installed Plugins"
filter_options = ['All', 'On', 'Off']

</t>
<t tx="ekr.20070127142814.843">class RemotePluginList(PluginList):
    """A list showing plugins based on a remote file system"""
	&lt;&lt; class RemotePluginList declarations &gt;&gt;
</t>
<t tx="ekr.20070127142814.844">title = "Plugins on CVS"
filter_options = ['All', 'Up to date', 'Update available', 'Changed', 'Not installed']

</t>
<t tx="ekr.20070127142814.845">class ManagerDialog:
    """The dialog to show manager functions"""
	&lt;&lt; class ManagerDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.846">
</t>
<t tx="ekr.20070127142814.847">def __init__(self):
    """Initialise the dialog"""
    
    
    root = g.app.root
    if standalone:
        self.top = top = root
    else:
        self.top = top = swing.JFrame()
    
    sl = swing.SpringLayout()
    cpane = top.getContentPane()
    cpane.setLayout( sl )
    g.app.gui.attachLeoIcon(self.top)
    top.setTitle( "Plugin Manager" )
       
    self.initLocalCollection()
   
    sl2 = swing.SpringLayout()
    self.frame = frame = swing.JPanel( sl2 )
    top.add( self.frame )
    sl.putConstraint( sl.NORTH, frame, 5, sl.NORTH, cpane )
      
    self.plugin_view = PluginView( cpane )
    cpane.add( self.plugin_view )
    sl.putConstraint( sl.NORTH, self.plugin_view, 5, sl.NORTH, cpane )
    sl.putConstraint( sl.WEST, self.plugin_view, 5, sl.EAST, frame )
    sl.putConstraint( sl.SOUTH, cpane, 5, sl.SOUTH, self.plugin_view )
    sl.putConstraint( sl.EAST, cpane, 5, sl.EAST, self.plugin_view )
        
    self.notebook = notebook = swing.JTabbedPane()
    frame.add( notebook, awt.BorderLayout.WEST )
    sl2.putConstraint( sl2.NORTH, notebook, 5, sl2.NORTH, frame )
    sl2.putConstraint( sl2.SOUTH, frame, 5, sl2.SOUTH, notebook )
    sl2.putConstraint( sl2.EAST, frame, 5, sl2.EAST, notebook )
    
    sl3 = swing.SpringLayout()
    self.local_list_page = local_list_page = swing.JPanel( sl3 )
    notebook.addTab( 'Installed Plugins', local_list_page )
    
    sl4 = swing.SpringLayout()
    self.remote_list_page = remote_list_page = swing.JPanel( sl4 ) 
    notebook.addTab( 'CVS Plugins', remote_list_page )
       
    self.plugin_list = LocalPluginList(local_list_page, self.plugin_view , self.local ) 
    local_list_page.add( self.plugin_list )
    sl3.putConstraint( sl3.NORTH, self.plugin_list, 5, sl3.NORTH, local_list_page )
    
    self.remote_plugin_list = RemotePluginList(remote_list_page, self.plugin_view , None )
    remote_list_page.add( self.remote_plugin_list )
    sl4.putConstraint( sl4.NORTH, self.remote_plugin_list, 5, sl4.NORTH, remote_list_page )
    
    self.plugin_list.setSecondFilterList(["All"] + self.local.getGroups())
    
    self.buttonBox = self.ButtonBox( )
    bpanel = self.buttonBox.getContainer()
    local_list_page.add( bpanel )
    sl3.putConstraint( sl3.NORTH, bpanel ,5, sl3.SOUTH, self.remote_plugin_list )
    sl3.putConstraint( sl3.SOUTH, local_list_page, 5, sl3.SOUTH, bpanel )
    sl3.putConstraint( sl3.EAST, local_list_page, 5, sl3.EAST, bpanel )
        
    self.buttonBox.add( 'Enable', command = self.enablePlugin )
    self.buttonBox.add( 'Disable', command = self.disablePlugin )
    self.buttonBox.add( 'Updates', command = self.checkUpdates )
    self.buttonBox.add( 'Conflicts', command = self.checkConflicts )
    
    self.buttonBox = self.ButtonBox( )
    bpanel = self.buttonBox.getContainer()
    remote_list_page.add( bpanel )
    sl4.putConstraint( sl4.NORTH, bpanel, 5, sl4.SOUTH, self.remote_plugin_list )
    sl4.putConstraint( sl4.SOUTH, remote_list_page, 5, sl4.SOUTH, bpanel )
    sl4.putConstraint( sl4.EAST, remote_list_page, 5, sl4.EAST, bpanel )
    
    # Add some buttons to the ButtonBox.
    self.buttonBox.add('Install', command = self.installPlugin)
    self.buttonBox.add('View', command = self.viewPlugin)
    self.buttonBox.add('Updates', command = self.checkUpdates)
        
    self.messagebar = self.MessageBar()
    cpane.add( self.messagebar )
    sl.putConstraint( sl.NORTH, self.messagebar, 5, sl.SOUTH, frame )
    sl.putConstraint( sl.WEST, self.messagebar, 5, sl.WEST, cpane )
    sl.putConstraint( sl.EAST, self.messagebar, 0, sl.EAST, frame )
    
    close_button = swing.JButton( "Close" )
    close_button.actionPerformed = lambda event: top.dispose()
    cpane.add( close_button )
    sl.putConstraint( sl.NORTH, close_button, 5, sl.SOUTH, self.messagebar )
          
    self.plugin_list.populateList("All")
    

    
    if standalone:
        top.setDefaultCloseOperation( top.EXIT_ON_CLOSE )
        
    else:
        top.setDefaultCloseOperation( top.DISPOSE_ON_CLOSE )
    top.pack()
    screen_size = awt.Toolkit.getDefaultToolkit().getScreenSize()
    center_x = screen_size.width/2
    center_y = screen_size.height/2
    
    md_size = top.getSize()
    center_x = center_x -( md_size.width/2 )
    center_y = center_y -( md_size.height/2 )
    top.setLocation( center_x, center_y )
    top.visible = 1
    

</t>
<t tx="ekr.20070127142814.848">
def enablePlugin(self):
    """Enable a plugin"""
    plugin = self.plugin_list.getSelectedPlugin()
    if not plugin: return
    
    self.local.enablePlugin(plugin,self.enable)
    self.plugin_list.populateList()
</t>
<t tx="ekr.20070127142814.849">
def disablePlugin(self):
    """Disable a plugin"""
    plugin = self.plugin_list.getSelectedPlugin()
    if not plugin: return
    
    self.local.disablePlugin(plugin,self.enable)
    self.plugin_list.populateList()
</t>
<t tx="ekr.20070127142814.850">
def initLocalCollection(self):
    """Initialize the local plugin collection"""

    # Get the local plugins information
    self.local = LocalPluginCollection()
    
    self.local.initFrom(g.os_path_join( g.app.loadDir,"..","plugins"))

    # Get the active status of the plugins
    self.enable = EnableManager()
    self.enable.initFrom(g.os_path_join( g.app.loadDir,"..","plugins"))
    self.local.setEnabledStateFrom(self.enable)
</t>
<t tx="ekr.20070127142814.851">
def checkUpdates(self):
    """Check for updates"""
    url = r"cvs.sourceforge.net/viewcvs.py/leo/leo/plugins"
    self.status_message = "Searching for plugin list"
    self.messagebar.message("busy", "Searching for plugin list")
    
    def callbackPrint(text):
        """A callback to send status information"""
        self.remote_plugin_list.populateList() 
        self.messagebar.message("busy", text)
        #self.top.update()
    
    self.remote = CVSPluginCollection()
    self.remote_plugin_list.plugins = self.remote
    try: 
        errors = self.remote.initFrom(url,callbackPrint)    
    except Exception, err:
        
        #dialog = Pmw.MessageDialog(self.top,
        #    title = 'CVS Error',
        #    defaultbutton = 0,
        #    message_text = 'Error retrieving CVS plugin information: %s' % err)
        #dialog.iconname('CVS')      
        #dialog.activate()
        dialog = swing.JOptionPane.showMessageDialog(  self.top,
                                                      "Error retrieving CVS plugin information:\n %s" % err,
                                                      'CVS Error',
                                                      swing.JOptionPane.ERROR_MESSAGE )
    
    else:
        if errors:
            
            
            dialog = ListReportDialog('CVS File Errors',
                                      'Errors',
                                      ["%s - %s" % item for item in errors],
                                      500)
            
        
    self.messagebar.resetmessages('busy')        
    self.remote.setEnabledStateFrom(self.local)
    self.remote_plugin_list.populateList()   
    self.remote_plugin_list.setSecondFilterList(["All"] + self.remote.getGroups()) 
</t>
<t tx="ekr.20070127142814.852">
def installPlugin(self):
    """Install the selected plugin"""

    # Write the file
    plugin = self.remote_plugin_list.getSelectedPlugin()        
    if not plugin: return

    self.messagebar.message("busy", "Writing file")
    
    plugin.writeTo(g.os_path_join( g.app.loadDir,"..","plugins"))
    self.messagebar.message("busy", "Scanning local plugins") 
    # Go and check local filesystem for all plugins   
    self.initLocalCollection()
    # View is still pointing to the old list, so switch it now
    self.plugin_list.plugins = self.local
    self.plugin_list.populateList()
    plugin.enabled = "Up to date"
    # Update the current list too
    self.remote_plugin_list.populateList()
    self.messagebar.resetmessages('busy')
</t>
<t tx="ekr.20070127142814.853">
def viewPlugin(self):
    """View the selected plugin in a web browser"""
    plugin = self.remote_plugin_list.getSelectedPlugin()
    if plugin:
        webbrowser.open(plugin.getViewFilename())
</t>
<t tx="ekr.20070127142814.854">#@nonl

def checkConflicts(self):
    """Check for plugin conflicts"""
    plugin = self.plugin_list.getSelectedPlugin() 
    if not plugin:
        return 
    conflicts = self.local.getConflicts(plugin)
    if not conflicts:
        #dialog = Pmw.MessageDialog(self.top,
        #    title = 'No conflicts',
        #    defaultbutton = 0,
        #    message_text = 'There are no conflicts for %s.' % plugin.name)
        #dialog.iconname('Conflicts')
        #dialog.activate()
        swing.JOptionPane.showMessageDialog( self.top,
                                            "There are no conflicts for %s" % plugin.name,
                                            "No conflicts",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
                                            
    else:
        dialog = ListReportDialog(
            'Potential Conflicts for %s' % plugin.name,
            'Conflicts',
            [inColumns(item, [30]) for item in conflicts],
            400)

</t>
<t tx="ekr.20070127142814.855">class ButtonBox:
    
    def __init__( self ): #, gbl, gbc ):
        
        #gbc.gridy = gbc.RELATIVE
        self.bgroup = swing.ButtonGroup()
        self.panel = swing.Box.createHorizontalBox()
        #gbl.setConstraints( self.panel, gbc )
        #parent.add( self.panel )
        
    def getContainer( self ):
        return self.panel
        
    def add( self, name, command = None ):
        
        jbutton = swing.JButton( name )
        jbutton.actionPerformed = self.createCallback( command )
        self.bgroup.add( jbutton )
        self.panel.add( jbutton )

    def createCallback( self, command ):
        
        return lambda event: command()</t>
<t tx="ekr.20070127142814.856">class MessageBar( swing.JProgressBar ):
    
    def __init__( self ):
        
        swing.JProgressBar.__init__( self )
        self.messagebar = self
        self.messagebar.setStringPainted( 1 )
        self.messagebar.setString( "" )
        border = self.messagebar.getBorder()
        tborder = sborder.TitledBorder( border, 'Status:', sborder.TitledBorder.DEFAULT_JUSTIFICATION, sborder.TitledBorder.LEFT )
        self.messagebar.setBorder( tborder )
        ps = self.getPreferredSize()
        ps.width = ps.width * 2
        self.setPreferredSize( ps )
      
    
    
    def message( self, a, b ):
        
        if a == 'busy':
            self.messagebar.setString( b )
            self.messagebar.setIndeterminate( 1 )
            
    def resetmessages( self , a):
        
        self.messagebar.setString( "" )
        self.messagebar.setIndeterminate( 0 )
        
</t>
<t tx="ekr.20070127142814.857">
class ListReportDialog:
    """Shows a list of items to report to the user
    
    The list is a list of strings. It is assumed that the
    strings are of the format 'abc - xyz' and this control
    presents a filter list based on the list of distinct 
    values for abc.
    
    """
	&lt;&lt; class ListReportDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.858"></t>
<t tx="ekr.20070127142814.859">def __init__(self, title, name, list_data, width=300):
    """Initialize the dialog"""
    

    root = g.app.root
    #self.top = top = Tk.Toplevel(root)
    #g.app.gui.attachLeoIcon(self.top)
    #top.title(title)
    
    self.top = top = swing.JDialog()
    top.title( title )
    
    #self.frame = frame = Tk.Frame(top)
    #frame.pack(side="top", fill='both', expand=1, padx=5, pady=5)
    self.frame = frame = swing.JPanel()
    top.add( frame )
    
    
    filter_options = self.getFilterOptions(list_data)
    self.list_data = list_data
    self.list_data.sort()
    
@    
    self.box = Pmw.ScrolledListBox(frame,
            labelpos='nw',
            label_text=name,
            listbox_height = 6,
            usehullsize = 1,
            hull_width = width,
            hull_height = 200,
            items = list_data,
    )
    self.box.pack(side="bottom", fill='both', expand=1)
    self.box.component("listbox").configure(font=("Courier", 10))
@c
    self.box = swing.JList()
    view = swing.JScrollPane( self.box )
    border = view.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( name )
    view.setBorder( tborder )
    frame.add( view )
    
    
    #self.filter = Pmw.OptionMenu(frame,
    #        labelpos = 'w',
    #        label_text = 'Filter:',
    #        items = filter_options,
    #        menubutton_width = 16,
    #        command=self.populateList,
    #)    
    
    #self.filter.pack(side="top")
    
    self.filter = swing.JOptionPane( 'Filter:',
                                     swing.JOptionPane.PLAIN_MESSAGE,
                                     swing.JOptionPane.DEFAULT_OPTION,
                                     None,
                                     filter_options )
                                    
    
    frame.add( self.filter )
    
        
    #top.grab_set() # Make the dialog a modal dialog.
    #top.focus_force() # Get all keystrokes.
    #root.wait_window(top)
</t>
<t tx="ekr.20070127142814.860">
def getFilterOptions(self, list_data):
    """Return a list of filter items"""
    splitter = re.compile("\s{3,}")
    names = sets.Set()
    for item in list_data:
        names.add(splitter.split(item)[1].strip())
    name_list = list(names)
    name_list.sort()
    return ["All"] + name_list
</t>
<t tx="ekr.20070127142814.861">
def populateList(self, filter):
    """Populate the list"""

    # Get old selection so that we can restore it    
    current_text = self.box.getcurselection()
    if current_text:
        current_index = self.list_data.index(current_text[0])

    listitems = [item for item in self.list_data
        if item.endswith("   %s" % filter) or filter == "All"]

    self.box.setlist(listitems)    

    if current_text:
        try:
            self.box.setvalue((listitems[current_index],))
            self.box.component("listbox").see(current_index)
        except IndexError:
            pass # Sometimes the list is just different!
</t>
<t tx="ekr.20070127142814.862"></t>
<t tx="ekr.20070127142814.863">class Plugin:   
    """Represents a single plugin instance"""
    
    # Class properties.
    max_name_width = 30
    max_group_width = 10
    
    @others</t>
<t tx="ekr.20070127142814.864">def __init__(self):
    """Initialize the plugin"""
    self.filename = None
    self.name = None
    self.is_plugin = False
    self.version = None
    self.description = ''
    self.handlers = []
    self.commands = []
    self.has_config = False
    self.can_read = False
    self.hash = None
    self.enabled = "Unknown"
    self.priority = None
    self.has_toplevel = False
    self.requires = []
    self.group = None
    self.versions = ''
    self.contents_valid = False
    </t>
<t tx="ekr.20070127142814.865">def initFrom(self, location):
    """Initialize the plugin from the specified location"""

    # Initial properties
    self.filename = location
    self.name = self.getName(location)
    self.nicename = self.getNiceName(self.name)

    # Get the contents of the file
    try:
        text = self.getContents()
        self.getDetails(text)
    except InvalidPlugin, err:
        print 'InvalidPlugin',str(err)
        self.description = str(err)
    except:
        g.es('Unexpected exception in initFrom')
        g.es_exception()</t>
<t tx="ekr.20070127142814.866"></t>
<t tx="ekr.20070127142814.867">def getName(self, location):

    """Determine the plugin name from the location"""

    raise NotImplementedError("Must Override")
</t>
<t tx="ekr.20070127142814.868">def getContents(self):

    """Return the contents of the file"""

    raise NotImplementedError("Must override")    
    </t>
<t tx="ekr.20070127142814.869">def getNiceName(self, name):
    """Return a nice version of the plugin name
    
    Historically some plugins had "at_" and "mod_" prefixes to their
    name which makes the name look a little ugly in the lists. There is
    no real reason why the majority of users need to know the underlying
    name so here we create a nice readable version.
    
    """
    lname = name.lower()
    if lname.startswith("at_"):
        name = name[3:]
    elif lname.startswith("mod_"):
        name = name[4:]
    return name.capitalize()
</t>
<t tx="ekr.20070127142814.870">def getDetails(self, text):
    """Get the details of the plugin
    
    We look for
        __version__
        hooks
        config
        commands
    """
    # The following line tried to detect plugins by looking 
    # for self.hasImport(text, "leoPlugins") - now we assume all .py are plugins
    self.is_plugin = not self.hasPattern(text, '__not_a_plugin__\s*=\s*True(?!")')
    self.version = self.getPattern(text, r'__version__\s*=\s*[\'"](.*?)[\'"]', "-")
    self.group = self.getPattern(text, r'__plugin_group__\s*=\s*[\'"](.*?)[\'"]', "-")
    # Allow both single and double triple-quoted strings.
    match1 = self.getMatch(text, r'"""(.*?)"""')
    match2 = self.getMatch(text, r"'''(.*?)'''")
    pat1 = match1 and match1.group(1)
    pat2 = match2 and match2.group(1)
    if pat1 and pat2:
        # Take the first pattern that appears.
        self.description = g.choose(match1.start() &lt; match2.start(),pat1,pat2)
    else:
        # Take whatever.
        self.description = pat1 or pat2 or 'Unknown'
    # g.trace('%4d %s' % (len(self.description),self.name))
    self.commands = sets.Set(self.getPatterns(text, "def cmd_(\w*?)\("))
    # Get a list of the handlers
    handler_list = self.getPattern(text, r'registerHandler\((.*?)\)')
    if handler_list:
        self.handlers = sets.Set(self.getPatterns(handler_list, r'["\'](.*?)["\']'))
    else:
        self.handlers = sets.Set()
    # Look for the matching .ini file.
    ini_file_name = g.os_path_join(
        g.app.loadDir,"..","plugins",
        self.getName(self.filename)+".ini")
    ini_file_name = g.os_path_abspath(ini_file_name)
    self.has_config = g.os_path_exists(ini_file_name)
    self.hash = sha.sha(text).hexdigest()
    self.can_read = True
    if USE_PRIORITY:
        self.priority = self.getPattern(text, r'__plugin_priority__\s*=\s*(.*?)$', "-")
    self.has_toplevel = self.hasPattern(text, "def topLevelMenu")
    self.getVersionHistory(text)</t>
<t tx="ekr.20070127142814.871">def hasPattern(self, text, pattern):
    
    """Return True if the text contains the pattern"""

    return self.getPattern(text, pattern) is not None</t>
<t tx="ekr.20070127142814.872">def hasImport(self, text, module_name):

    """Return True if the text includes an import of the module"""
    if self.hasPattern(text, "import %s" % module_name):
        return True

    if self.hasPattern(text, "from %s import" % module_name):
        return True

    return False</t>
<t tx="ekr.20070127142814.873">def getMatch(self, text, pattern):

    """Return a single match for the specified pattern in the text"""
    
    return re.search(pattern,text,re.MULTILINE + re.DOTALL)</t>
<t tx="ekr.20070127142814.874">def getPattern(self, text, pattern, default=None):

    """Return a single match for the specified pattern in the text or the default"""

    matches = self.getPatterns(text, pattern)
    if matches:
        return matches[0]
    else:
        return default</t>
<t tx="ekr.20070127142814.875">def getPatterns(self, text, pattern):

    """Return all matches of the pattern in the text"""

    exp = re.compile(pattern, re.MULTILINE + re.DOTALL)

    return exp.findall(text)</t>
<t tx="ekr.20070127142814.876">def asString(self, detail=False):
    
    """Return a string representation"""

    if not detail:
        if self.version &lt;&gt; "-":
            body = "%(nicename)s (v%(version)s)" % self.__dict__
        else:
            body = "%(nicename)s" % self.__dict__                        
        return inColumns((body, self.group, self.enabled), [self.max_name_width, self.max_group_width])
    else:
        return (
            "Name: %(nicename)s\n"
            "Version: %(version)s\n"
            "Active: %(enabled)s\n"
            "File: %(filename)s\n"
            "\n"
            "Description:\n%(description)s\n\n"
            "Has config file: %(has_config)s\n"
            "Commands: %(commands)s\n"
            "Handlers: %(handlers)s\n" % self.__dict__
        )</t>
<t tx="ekr.20070127142814.877">def writeTo(self, location):

    """Write this plugin to the file location"""

    # Don't write if contents are invalid
    if not self.contents_valid:
        return 
        
    filename = os.path.join(location, "%s.py" % self.name)
    try:
        f = file(filename, "w")
    except (IOError, OSError), err:
        raise InvalidPlugin(
            "Unable to open plugin file '%s': %s" % (filename, err))
    try:
        try:
            f.write(self.text)
        finally:
            f.close()
    except Exception, err:
        raise InvalidPlugin(
            "Unable to write plugin file '%s': %s" % (filename, err))
</t>
<t tx="ekr.20070127142814.878">def getVersionHistory(self, text):
    """Try to extract the version history of this plugin
    
    This is all guesswork! We look for a Leo node called "Version history"
    or one called "Change log". If we find it then we assume that the contents
    are the version history.
    
    This only works if the plugin was developed in Leo as a @thin file.
    
    """
    #if self.group == "Core":
    #    import pdb; pdb.set_trace()
    extractor =r'.*\+node\S+?\&lt;\&lt; %s \&gt;\&gt;.*?\#\@\+at(.*)\#\@\-at.*\-node.*?\&lt;\&lt; %s \&gt;\&gt;.*'
    for name in ("version history", "change log"):
        searcher = re.compile(extractor % (name, name), re.DOTALL+re.M)
        match = searcher.match(text)
        if match:
            version_text = match.groups()[0]
            self.versions = version_text.replace("#", "")
            return
    </t>
<t tx="ekr.20070127142814.879">def getRequiredModules(self, plugin_collection):
    """Determine which modules are also required by this plugin
    
    We check for,
     - importing Tk and PMW
     - other plugins which are imported (using plugin_collection)
     - a __plugin_requires__ definition
     
    """
    requires = []
    &lt;&lt; Check UI toolkits &gt;&gt;
    &lt;&lt; Check other plugins &gt;&gt;
    &lt;&lt; Directives &gt;&gt;
    self.requires = sets.Set(requires)</t>
<t tx="ekr.20070127142814.880"># Check for UI toolkits
if self.hasImport(self.text, "Tkinter"):
    requires.append("Tkinter")
    
if self.hasImport(self.text, "Pmw"):
    requires.append("Pmw")</t>
<t tx="ekr.20070127142814.881"># Check for importing other plugin files

imports = self.getPatterns(self.text, "import (\w+)") + \
          self.getPatterns(self.text, "from (\w+) import")
          
for module_name in imports:
    if module_name in plugin_collection and module_name &lt;&gt; self.name:
        requires.append(module_name)
        </t>
<t tx="ekr.20070127142814.882"># Look for __plugin_requires__ directive

directive_text = self.getPattern(self.text, r'__plugin_requires__\s*=\s*(.*?)$', "[]")

try:
    directive = eval(directive_text)
except:
    g.es("__plugin_requires__ not understood for %s: '%s'" % (
            self.name, directive_text))    
else: 
    if isinstance(directive, (str, unicode)):
        requires.append(directive)
    else:
        requires.extend(directive)</t>
<t tx="ekr.20070127142814.883">class LocalPlugin(Plugin):
    """A plugin on the local file system"""
    
    @others</t>
<t tx="ekr.20070127142814.884">def getName(self, location):

    """Determine the plugin name from the location"""
    
    # return os.path.split(os.path.splitext(location)[0])[1]
    head,ext = g.os_path_splitext(location)
    path,name = g.os_path_split(head)
    return name</t>
<t tx="ekr.20070127142814.885">def getContents(self):

    """Return the contents of the file"""
    
    self.contents_valid = False

    try:
        f = file(self.filename, "r")
    except (IOError, OSError), err:
        s = "Unable to open plugin file '%s': %s" % (self.name, err)
        print s
        raise InvalidPlugin(s)
    try:
        try:
            self.text = text = f.read()
        finally:
            f.close()
    except Exception, err:
        s = "Unable to read plugin file '%s': %s" % (self.name, err)
        print s
        raise InvalidPlugin(s)              
    
    self.contents_valid = True
    
    return text
    
    
</t>
<t tx="ekr.20070127142814.886">class CVSPlugin(Plugin):
     """A plugin on CVS"""
     
     @others</t>
<t tx="ekr.20070127142814.887">def getName(self, location):

    """Determine the plugin name from the location"""

    return re.match("(.*)/(.*?)\.py\?", location).groups()[1]</t>
<t tx="ekr.20070127142814.888">def getContents(self):

    """Return the contents of the file"""
    
    self.contents_valid = False

    # Connect to CVS
    try:
        url = urllib.urlopen(self.filename)
    except Exception, err:
        raise InvalidPlugin("Could not get connection to CVS: %s" % err)

    # Get the page with file content
    try:
        try:
            self.text = text = url.read()
        finally:
            url.close()
    except Exception, err:
        raise InvalidPlugin("Could not read file '%s' from CVS: %s" % (self.filename, err))
        
    self.contents_valid = True
    
    return text        </t>
<t tx="ekr.20070127142814.889">def getViewFilename(self):
    
    """Return the url to view the file"""

    return self.filename.replace(r"/*checkout*", "") + "&amp;view=markup"
</t>
<t tx="ekr.20070127142814.890">class PluginCollection(dict):

    """Represents a collection of plugins"""
    
    plugin_class = None
    
    @others
</t>
<t tx="ekr.20070127142814.891">def __init__(self):
    """Initialize the plugin collection"""
</t>
<t tx="ekr.20070127142814.892">def initFrom(self, location, callback=None):
    """Initialize the collection from the filesystem location.
    Returns a list of errors that occured.
    """
    if callback: callback("Looking for list of files")
    errors = []
    plugin_files = self.getFilesMatching(location)  
    for plugin_file in plugin_files:
        if callback: callback("Processing %s" % plugin_file)    
        plugin = self.plugin_class()
        # Get details
        try:
            plugin.initFrom(plugin_file)
        except Exception, err:
            errors.append((plugin_file, err))
        # Store anything that looks like a plugin
        if plugin.is_plugin:
            self[plugin.name] = plugin

    # Now we have to go back through and check for dependencies
    # We cannot do this up front because we need to know the names
    # of other plugins to detect the dependencies
    for plugin in self.values():
        plugin.getRequiredModules(self)

    return errors
</t>
<t tx="ekr.20070127142814.893">def getAllFiles(self, location):
    
    """Return all the files in the location"""

    raise NotImplementedError("Must override")    
</t>
<t tx="ekr.20070127142814.894">def sortedNames(self):

    """Return a list of the plugin names sorted alphabetically
    
    We use decorate, sort, undecorate to sort by the nice name!
    
    """

    names = [(item.nicename, item.name) for item in self.values()]
    names.sort()
    return [name[1] for name in names]
</t>
<t tx="ekr.20070127142814.895">def setEnabledStateFrom(self, enabler):

    """Set the enabled state of each plugin using the enabler object"""
    for name in self:
        if name in enabler.actives:
            self[name].enabled = "On"
        else:
            self[name].enabled = "Off" 
</t>
<t tx="ekr.20070127142814.896">def enablePlugin(self, plugin, enabler):
    """Enable a plugin"""
    plugin.enabled = "On"
    enabler.updateState(plugin)</t>
<t tx="ekr.20070127142814.897">def disablePlugin(self, plugin, enabler):
    """Enable a plugin"""
    plugin.enabled = "Off"
    enabler.updateState(plugin)</t>
<t tx="ekr.20070127142814.898">def getConflicts(self, plugin):

    """Find conflicting hook handlers for this plugin"""

    conflicts = []
    for this_plugin in self.values():
        # g.trace(plugin.handlers,this_plugin.handlers)
        if this_plugin.name &lt;&gt; plugin.name:
            for conflict in plugin.handlers.intersection(this_plugin.handlers):
                conflicts.append((this_plugin.name, conflict))

    return conflicts
        </t>
<t tx="ekr.20070127142814.899">def getGroups(self):
    """Return a list of the Plugin group names"""
    groups = list(sets.Set([plugin.group for plugin in self.values()]))
    groups.sort()
    return groups</t>
<t tx="ekr.20070127142814.900">class LocalPluginCollection(PluginCollection):
    """Represents a plugin collection based on the local file system"""
    
    plugin_class = LocalPlugin
    
    @others
</t>
<t tx="ekr.20070127142814.901">def getFilesMatching(self, location):

    """Return all the files matching the pattern"""

    return [filename for filename in self.getAllFiles(location)
                if fnmatch.fnmatch(filename, "*.py")]</t>
<t tx="ekr.20070127142814.902">def getAllFiles(self, location):

    """Return all the files in the location"""

    return [os.path.join(location, filename) for filename in os.listdir(location)]</t>
<t tx="ekr.20070127142814.903">class CVSPluginCollection(PluginCollection):

    """Represents a plugin collection based located in a CVS repository"""
    
    plugin_class = CVSPlugin
    
    @others
</t>
<t tx="ekr.20070127142814.904">def getFilesMatching(self, location):
    """Return all the files in the location"""
    #
    # Find files
    text = self.getListingPage(location)
    cvs_host, _, cvs_location = location.split("/", 2)
    filename = re.compile(r'href="/viewcvs.py/(%s)/(.*?\.py\?rev=.*?)\&amp;view=auto"' % cvs_location)
    return [r"http://%s/viewcvs.py/*checkout*/%s/%s" % (cvs_host, item[0], item[1])
                for item in filename.findall(text)]
</t>
<t tx="ekr.20070127142814.905">def getListingPage(self, location):
    """Return the HTML page with files listed"""
    #
    # Connect to CVS
    try:
        url = urllib.urlopen(r"http://%s" % location)
    except Exception, err:
        raise InvalidCollection("Could not get connection to CVS: %s" % err)
    #
    # Get the page with files listed
    try:
        try:
            text = url.read()
        finally:
            url.close()
    except Exception, err:
        raise InvalidCollection("Could not read from CVS: %s" % err)
    return text    </t>
<t tx="ekr.20070127142814.906">def setEnabledStateFrom(self, collection):
    """Set the enabled state based on another collection"""
    for plugin in self.values():
        try:
            local_version = collection[plugin.name]
        except KeyError:
            plugin.enabled = "Not installed"
        else:
            if local_version.version &lt; plugin.version:
                plugin.enabled = "Update available"
            elif local_version.hash &lt;&gt; plugin.hash:
                plugin.enabled = "Changed"
            else:
                plugin.enabled = "Up to date"
</t>
<t tx="ekr.20070127142814.907">class EnableManager:

    """Manages the enabled/disabled status of plugins"""
    
    @others</t>
<t tx="ekr.20070127142814.908">def initFrom(self, location):
    """Initialize the manager from a folder"""
    manager_filename = os.path.join(location, "pluginsManager.txt")
    self.location = location

    # Get the text of the plugin manager file
    try:
        f = file(manager_filename, "r")
    except (IOError, OSError), err:
        raise InvalidManager("Unable to open plugin manager file '%s': %s" % 
                                (manager_filename, err))
    try:
        try:
            self.text = text = f.read()
        finally:
            f.close()
    except Exception, err:
        raise InvalidManager("Unable to read manager file '%s': %s" % 
                                (manager_filename, err))              
    self.parseManagerText(text)</t>
<t tx="ekr.20070127142814.909">def writeFile(self, location):
    """Initialize the manager from a folder"""
    manager_filename = os.path.join(location, "pluginsManager.txt")

    # Get the text of the plugin manager file
    try:
        f = file(manager_filename, "w")
    except (IOError, OSError), err:
        raise InvalidManager("Unable to open plugin manager file '%s': %s" % 
                                (manager_filename, err))
    try:
        try:
            f.write(self.text)
        finally:
            f.close()
    except Exception, err:
        raise InvalidManager("Unable to write manager file '%s': %s" % 
                                (manager_filename, err))              
    self.parseManagerText(self.text)</t>
<t tx="ekr.20070127142814.910">def parseManagerText(self, text):
    """Parse the text in the manager file"""

    # Regular expressions for scanning the file
    find_active = re.compile(r"^\s*(\w+)\.py", re.MULTILINE)
    find_inactive = re.compile(r"^\s*#\s*(\w+)\.py", re.MULTILINE)
    find_manager = re.compile(r"^\s*plugin_manager\.py", re.MULTILINE)

    if 1: # Put the first match in the starts dict.
        starts = {}
        for kind,iter in (
            ('on',find_active.finditer(text)),
            ('off',find_inactive.finditer(text)),
        ):
            for match in iter:
                name = match.groups()[0]
                start = match.start()
                if start != -1:
                    bunch = starts.get(name)
                    if not bunch or bunch.start &gt; start:
                      starts[name] = g.Bunch(
                        kind=kind,name=name,start=start,match=match)
                    
        self.actives = dict(
            [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='on'])
            
        self.inactives = dict(
            [(bunch.name,bunch.match) for bunch in starts.values() if bunch.kind=='off'])
            
        if 0: # debugging.
            starts2 = [(bunch.start,bunch.name,bunch.kind) for bunch in starts.values()]
            starts2.sort()
            g.trace(g.listToString(starts2,tag='starts2 list'))
            g.trace(g.dictToString(self.actives,tag='Active Plugins'))
                  
    else: # Original code.
        # Get active plugin defintions
        self.actives = dict([(match.groups()[0], match) 
            for match in find_active.finditer(text)])
    
        # Get inactive plugin definitions
        self.inactives = dict([(match.groups()[0], match) 
            for match in find_inactive.finditer(text)])

    # List of all plugins
    self.all = {}
    self.all.update(self.actives)
    self.all.update(self.inactives)

    # Locaction of the plugin_manager.py plugin - this is where
    # we add additional files
    self.manager = find_manager.search(text)</t>
<t tx="ekr.20070127142814.911">def updateState(self, plugin):
    """Update the state for the given plugin"""
    # Get the filename for the new entry
    if plugin.enabled == "On":
        newentry = "%s.py" % plugin.name
    else:
        newentry = "#%s.py" % plugin.name 

    if plugin.name in self.all:
        # Plugin exists in the management file
        item = self.all[plugin.name]
        # TODO: Unicode issues with the following line??
        self.text = "%s%s%s" % (
            self.text[:item.start()],
            str(newentry),
            self.text[item.end():])      
    else:
        # Plugin doesn't exist - add it at a suitale place
        self.text = "%s%s\n%s" % (
            self.text[:self.manager.start()],
            str(newentry),
            self.text[self.manager.start():])

    self.writeFile(self.location)</t>
<t tx="ekr.20070127142814.912">&lt;&lt; docstring &gt;&gt;

# Written by Paul A. Paterson.  Revised by Edward K. Ream.
# To do: add Revert button to each dialog.
# Changed over to Swing by BH

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;
__version__ = "1.8"
&lt;&lt; version history &gt;&gt;

__plugin_name__ = "Plugins Menu"
__plugin_priority__ = -100
__plugin_group__ = "Core"

@others

if not g.app.unitTesting: # Register the handlers...

    #if g.app.gui is None:
    #    g.app.createTkGui(__file__)

    #if g.app.gui.guiName() == "tkinter":
    if 1:
        leoPlugins.registerHandler("create-optional-menus",createPluginsMenu)
        g.plugin_signon(__name__)</t>
<t tx="ekr.20070127142814.913">'''Create a Plugins menu

Adds an item to the plugin menu for each active plugin. Selecting
this menu item will bring up a short About dialog with the details of the
plugin.

Plugins can create additional menu items by defining functions named
"cmd_XZY". These will apear in a sub menu. 

If the plugin requires an INI file then a configure menu item will be
created which will show an INI file editor. the plugin can define an
"applyConfiguration" function, which will be called when the configuration 
changes.

Plugins can also define a top level function to be called instead of
the default "About" dialog by defining a "topLevelMenu" function in
the plugin. This function will be called when the user clicks on the
plugin name in the plugins menu, but only if the plugin was loaded
properly and registered with g.plugin_signon.

Plugins can define their name by setting the __plugin_name__ property.

Plugins can also attempt to select the order they will apear in the menu
by defining a __plugin_prioriy__. The menu will be created with the
highest priority items first. This behaviour is not guaranteed since
other plugins can define any priority. This priority does not affect
the order of calling handlers.

To change the order select a number outside the range 0-200 since this
range is used internally for sorting alphabetically.
'''</t>
<t tx="ekr.20070127142814.914">import leoGlobals as g
import leoPlugins

#Tk = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
import javax.swing as swing
import java
import ConfigParser
import glob
import os
import sys</t>
<t tx="ekr.20070127142814.915">@

1.4 EKR:
    - Check at runtime to make sure that the plugin has been loaded before calling topLevelMenu function.

1.5 EKR:
    - Check for ImportError directly in Plugin.__init__.
      Alas, this can not report import problems without more work.
      This _really_ should be done, but it will have to wait.
      As a workaround, plugins_manager.py now has an init method and reports its own import problems.

1.6 Paul Paterson:
    - Add support for plugin groups. Each group gets its own sub menu now
    - Set __plugin_group__ to "Core"
1.7 EKR:
    - Set default version in Plugin.__init__ so plugins without version still appear in plugin menu.

1.8 Paul Paterson:
    - Changed the names in the plugin menu to remove at_, mod_ and capitalized</t>
<t tx="ekr.20070127142814.916">class _PluginDatabase:
    """Stores information on Plugins"""
    
    @others
    
PluginDatabase = _PluginDatabase()</t>
<t tx="ekr.20070127142814.917">def __init__(self):
    """Initialize"""
    self.plugins_by_group = {}
    self.groups_by_plugin = {}
    self.menus = {}</t>
<t tx="ekr.20070127142814.918">def addPlugin(self, item, group):
    """Add a plugin"""
    self.plugins_by_group.setdefault(group, []).append(item)
    self.groups_by_plugin[item] = group</t>
<t tx="ekr.20070127142814.919">def getGroups(self):
    """Return a list of groups"""
    groups = self.plugins_by_group.keys()
    groups.sort()
    return groups</t>
<t tx="ekr.20070127142814.920">def setMenu(self, name, menu):
    """Store the menu for this group"""
    self.menus[name] = menu</t>
<t tx="ekr.20070127142814.921">def getMenu(self, item):
    """Get the menu for a particular item"""
    try:
        return self.menus[item.group]
    except KeyError:
        return self.menus["Default"]</t>
<t tx="ekr.20070127142814.922">class PlugIn:

    """A class to hold information about one plugin"""

    @others
    
</t>
<t tx="ekr.20070127142814.923">def __init__(self, filename):

    """Initialize the plug-in"""

    # Import the file to find out some interesting stuff
    # Do not use the imp module: we only want to import these files once!
    self.mod = self.doc = self.version = None
    self.filename = g.os_path_abspath(filename)
    try:
        self.mod = __import__(g.os_path_splitext(g.os_path_basename(filename))[0])
        if not self.mod: return
        #
        self.group = getattr(self.mod, "__plugin_group__", None)
        if self.group:
            PluginDatabase.addPlugin(self, self.group)
        # g.trace('Plugin',self.mod)
        try:
            name = self.mod.__plugin_name__
        except AttributeError:
            name = self.mod.__name__
        self.name = self.getNiceName(name)
        try:
            self.priority = self.mod.__plugin_priority__
        except AttributeError:
            self.priority = 200 - ord(self.name[0])
        #
        self.doc = self.mod.__doc__
        self.version = self.mod.__dict__.get("__version__","&lt;unknown&gt;") # EKR: 3/17/05
        # if self.version: print self.version,g.shortFileName(filename)
    except ImportError:
        # s = 'Can not import %s in plugins_menu plugin' % g.shortFileName(filename)
        # print s ; g.es(s,color='blue')
        return
    except Exception:
        s = 'Unexpected exception in plugins_menu plugin importing %s' % filename
        print s ; g.es(s,color='red')
        return

    &lt;&lt; Check if this can be configured &gt;&gt;
    &lt;&lt; Check if this has an apply &gt;&gt;
    &lt;&lt; Look for additional commands &gt;&gt;
    &lt;&lt; Look for toplevel menu item &gt;&gt;</t>
<t tx="ekr.20070127142814.924"># Look for a configuration file
self.configfilename = "%s.ini" % os.path.splitext(filename)[0]
self.hasconfig = os.path.isfile(self.configfilename)
</t>
<t tx="ekr.20070127142814.925">@ Look for an apply function ("applyConfiguration") in the module.

This is used to apply changes in configuration from the properties window
@c

self.hasapply = hasattr(self.mod, "applyConfiguration")
</t>
<t tx="ekr.20070127142814.926">@ Additional commands can be added to the plugin menu by having functions in the module called "cmd_whatever". These are added to the main menu and will be called when clicked
@c

self.othercmds = {}

for item in self.mod.__dict__.keys():
    if item.startswith("cmd_"):
        self.othercmds[item[4:]] = self.mod.__dict__[item]
</t>
<t tx="ekr.20070127142814.927">@ Check to see if there is a toplevel menu item - this will be used instead of the default About
@c

try:
    self.hastoplevel = self.mod.__dict__["topLevelMenu"]
except KeyError:
    self.hastoplevel = False</t>
<t tx="ekr.20070127142814.928">def about(self,event=None):
    
    """Put up an "about" dialog for this plugin"""

    PluginAbout(self.name, self.version, self.doc)</t>
<t tx="ekr.20070127142814.929">def getNiceName(self, name):
    """Return a nice version of the plugin name
    
    Historically some plugins had "at_" and "mod_" prefixes to their
    name which makes the name look a little ugly in the lists. There is
    no real reason why the majority of users need to know the underlying
    name so here we create a nice readable version.
    
    """
    lname = name.lower()
    if lname.startswith("at_"):
        name = name[3:]
    elif lname.startswith("mod_"):
        name = name[4:]
    return name.capitalize()
</t>
<t tx="ekr.20070127142814.930">def properties(self, event=None):
    
    """Create a modal properties dialog for this plugin"""

    PropertiesWindow(self.configfilename, self)</t>
<t tx="ekr.20070127142814.931">class PropertiesWindow:

    """A class to create and run a Properties dialog for a plugin"""

    @others</t>
<t tx="ekr.20070127142814.932">def __init__(self, filename, plugin):

    """Initialize the property window"""
    
    &lt;&lt; initialize all ivars &gt;&gt;
    &lt;&lt; create the frame from the configuration data &gt;&gt;</t>
<t tx="ekr.20070127142814.933"># config stuff.
config = ConfigParser.ConfigParser()
config.read(filename)
self.filename = filename
self.config = config
self.plugin = plugin

# self.entries is a list of tuples (section, option, e),
# where section and options are strings and e is a Tk.Entry widget.
# This list is used by writeConfiguration to write all settings.
self.entries = []
</t>
<t tx="ekr.20070127142814.934">root = g.app.root

&lt;&lt; Create the top level and the main frame &gt;&gt;
&lt;&lt; Create widgets for each section and option &gt;&gt;
&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;

g.app.gui.center_dialog(top) # Do this after packing.
top.grab_set() # Make the dialog a modal dialog.
top.focus_force() # Get all keystrokes.
root.wait_window(top)</t>
<t tx="ekr.20070127142814.935">#self.top = top = Tk.Toplevel(root)
self.top = top = swing.JFrame()
cpane = top.getContentPane()
cpane.setLayout( java.awt.BorderLayout() )
g.app.gui.attachLeoIcon(self.top)
#top.title("Properties of "+ plugin.name)
top.title = "Properties of " + plugin.name
#top.resizable(0,0) # neither height or width is resizable.
    
#self.frame = frame = Tk.Frame(top)
self.frame = frame = swing.JPanel( java.awt.BorderLayout() )
top.add( frame )
#frame.pack(side="top")</t>
<t tx="ekr.20070127142814.936"># Create all the entry boxes on the screen to allow the user to edit the properties
sections = config.sections()
sections.sort()
for section in sections:
    # Create a frame for the section.
    #f = Tk.Frame(top, relief="groove",bd=2)
    f = swing.JPanel( java.awt.BorderLayout() )
    top.add( f, java.awt.BorderLayout.NORTH )
    #f.pack(side="top",padx=5,pady=5)
    #Tk.Label(f, text=section.capitalize()).pack(side="top")

    l = swing.JLabel( section.capitalize() )
    f.add( l, java.awt.BorderLayout.NORTH )
    # Create an inner frame for the options.
    #b = Tk.Frame(f)
    #b.pack(side="top",padx=2,pady=2)
    b = swing.JPanel()
    f.add( b, java.awt.BorderLayout.SOUTH )
    # Create a Tk.Label and Tk.Entry for each option.
    options = config.options(section)
    options.sort()
    row = 0
    for option in options:
        #e = Tk.Entry(b)
        e = swing.JTextField( config.get( section, option ) )
        b.add( e )
        #e.insert(0, unicode(config.get(section,option))) # 6/8/04
        #Tk.Label(b, text=option).grid(row=row, column=0, sticky="e", pady=4)
        #e.grid(row=row, column=1, sticky="ew", pady = 4)
        label = swing.JLabel( option )
        b.add( label )
        row += 1
        self.entries.append((section, option, e))
</t>
<t tx="ekr.20070127142814.937">#box = Tk.Frame(top, borderwidth=5)
#box.pack(side="bottom")
box = swing.JPanel()
top.add( box, java.awt.BorderLayout.SOUTH )

list = [("OK",self.onOk),("Cancel",top.destroy)]
if plugin.hasapply:
    list.append(("Apply",self.onApply),)

for text,f in list:
    #Tk.Button(box,text=text,width=6,command=f).pack(side="left",padx=5)
    _but = swing.JButton( text )
    box.add( _but )</t>
<t tx="ekr.20070127142814.938">def onApply(self):
    
    """Event handler for Apply button"""
    self.writeConfiguration()
    self.plugin.mod.applyConfiguration(self.config)

def onOk(self):

    """Event handler for Ok button"""
    self.writeConfiguration()
    self.top.destroy()</t>
<t tx="ekr.20070127142814.939">def writeConfiguration(self):
    
    """Write the configuration to disk"""

    # Set values back into the config item.
    for section, option, entry in self.entries:
        s = entry.get()
        s = g.toEncodedString(s,"ascii",reportErrors=True) # Config params had better be ascii.
        self.config.set(section,option,s)

    # Write out to the file.
    f = open(self.filename, "w")
    self.config.write(f)
    f.close()</t>
<t tx="ekr.20070127142814.940">class PluginAbout:
    
    """A class to create and run an About Plugin dialog"""
    
    @others
</t>
<t tx="ekr.20070127142814.941">def __init__(self, name, version, about):
    
    """# Create and run a modal dialog giving the name,
    version and description of a plugin.
    """

    root = g.app.root
    self.top = top = swing.JDialog()
    #self.top = top = Tk.Toplevel(root)
    #g.app.gui.attachLeoIcon(self.top)
    #top.title("About " + name)
    top.title = "About " + name
    #top.resizable(0,0) # neither height or width is resizable.
    
    #frame = Tk.Frame(top)
    #frame.pack(side="top")
    frame = swing.JPanel()
    top.add( frame )
    &lt;&lt; Create the contents of the about box &gt;&gt;
    &lt;&lt; Create the close button &gt;&gt;
    
    g.app.gui.center_dialog(top) # Do this after packing.
    #top.grab_set() # Make the dialog a modal dialog.
    #top.focus_force() # Get all keystrokes.
    #root.wait_window(top)</t>
<t tx="ekr.20070127142814.942">#Tk.Label(frame, text="Version " + version).pack()

#Tk.Label(frame, text=about, borderwidth=10,justify="left").pack()

l1 = swing.JLabel( "Version " + version )
frame.add( l1 )

l2 = swing.JLabel( about )
frame.add( l2 )</t>
<t tx="ekr.20070127142814.943">#buttonbox = Tk.Frame(top, borderwidth=5)
#buttonbox.pack(side="bottom")
buttonbox = swing.JPanel()
top.add( buttonbox, java.awt.BorderLayout.SOUTH )

#self.button = Tk.Button(buttonbox, text="Close", command=top.destroy)
#self.button.pack(side="bottom")

self.button = swing.JButton( "Close" )
self.button.actionPerformed = lambda event: top.dispose()
buttonbox.add( self.button )</t>
<t tx="ekr.20070127142814.944">def createPluginsMenu (tag,keywords):

    c = keywords.get("c")
    if not c: return

    old_path = sys.path[:] # Make a _copy_ of the path.

    path = os.path.join(g.app.loadDir,"..","plugins")
    #sys.path = path
    
    if os.path.exists(path):
        # Create a list of all active plugins.
        files = glob.glob(os.path.join(path,"*.py"))
        files.sort()
        plugins = [PlugIn(file) for file in files]
        items = [(p.name,p) for p in plugins if p.version]
        if items:
            &lt;&lt; Sort items &gt;&gt;
            c.pluginsMenu = pluginMenu = c.frame.menu.createNewMenu("&amp;Plugins")
            PluginDatabase.setMenu("Default", pluginMenu)
            &lt;&lt; Add group menus &gt;&gt;
            &lt;&lt; add items to the plugins menu &gt;&gt;
            
    sys.path = old_path</t>
<t tx="ekr.20070127142814.945">dec = [(item[1].priority, item) for item in items]
dec.sort()
dec.reverse()
items = [item[1] for item in dec]</t>
<t tx="ekr.20070127142814.946">for group_name in PluginDatabase.getGroups():
    PluginDatabase.setMenu(group_name, c.frame.menu.createNewMenu(group_name, "&amp;Plugins"))
</t>
<t tx="ekr.20070127142814.947">for name,p in items:
    if p.hastoplevel:
        # Check at runtime to see if the plugin has actually been loaded.
        # This prevents us from calling hasTopLevel() on unloaded plugins.
        def callback(p=p):
            path,name = g.os_path_split(p.filename)
            name,ext = g.os_path_splitext(name)
            # g.trace(name,g.app.loadedPlugins)
            if name in g.app.loadedPlugins:
                p.hastoplevel()
            else:
                p.about()
        table = ((p.name, None, callback),)
        c.frame.menu.createMenuEntries(PluginDatabase.getMenu(p), table)
    elif p.hasconfig or p.othercmds:
        &lt;&lt; Get menu location &gt;&gt;
        m = c.frame.menu.createNewMenu(p.name, menu_location)
        table = [("About...", None, p.about)]
        if p.hasconfig:
            table.append(("Properties...", None, p.properties))
        if p.othercmds:
            table.append(("-", None, None))
            items = [(cmd,None,fn) for cmd,fn in p.othercmds.iteritems()]
            items.sort()
            table.extend(items)
        c.frame.menu.createMenuEntries(m, table)
    else:
        table = ((p.name, None, p.about),)
        c.frame.menu.createMenuEntries(PluginDatabase.getMenu(p), table)</t>
<t tx="ekr.20070127142814.948">if p.group:
    menu_location = p.group
else:
    menu_location = "&amp;Plugins"
</t>
<t tx="ekr.20070127142814.949">@language python
import leoGlobals as g

class CommanderSupplemental:
    
    def __init__( self, c ):
        self.c = c
    
    @others</t>
<t tx="ekr.20070127142814.950">def nodeToOutline( self ):
    
    c = self.c
    cp = c.currentPosition()
    limport = c.importCommands
    language = g.scanForAtLanguage( self.c, cp ) 
    langdict = {
        "c": limport.scanCText,
        "c++" : limport.scanCText,
        "lisp": limport.scanCText,
        "forth": limport.scanForthText,
        "java": lambda s,v : limport.scanJavaText(s,v, True),
        "pascal": limport.scanPascalText,
        "python": limport.scanPythonText,
        "php": limport.scanPHPText,
    
    
    
    }
    
    mungers = {
    
        'java': self._mungeJavaOutline,
        'python': self._mungePythonOutline,
    
    
    }
    
    if langdict.has_key( language ):
        c.beginUpdate()
        np = cp.insertAfter()
        hs = cp.headString()
        limport.tab_width = limport.getTabWidth()
        limport.methodName = cp.headString()
        #limport.root_Line = "@file"
        bs = cp.bodyString()
        bslines = bs.split( "\n" )
        nwlines = []
        for z in bslines:
            if z.strip() == "@others":
                pass
            else:
                nwlines.append( z )
        
        bs = '\n'.join( nwlines )
        langdict[ language ]( bs, np )
        if mungers.has_key( language ):
            mungers[ language ]( cp, np )
        c.endUpdate()
        </t>
<t tx="ekr.20070127142814.951">def _mungeJavaOutline( self,old_p, new_p ):
    
    hs = old_p.headString()
    child1 = new_p.getNthChild( 0 )
    child1.setHeadString( hs )
    child1.moveAfter( old_p )
    children = []
    for z in old_p.children_iter( copy = True ):
        children.append( z )
                
    for z in children:
        z.moveToLastChildOf( child1 )
        
    old_p.doDelete( child1 )
    new_p.doDelete( child1 )


def _mungePythonOutline( self, old_p, new_p ):
    pass</t>
<t tx="ekr.20070127142814.952">from __future__ import generators
import java
import java.awt as awt
import java.awt.event as aevent
import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.tree as stree
import java.util.concurrent.locks as locks
import leoNodes
import leoGlobals as g
import leoSwingUndo
import javax.swing.undo as undo
from utilities.DefCallable import DefCallable
from utilities.Phaser import Phaser
from utilities.Slider import Slider
from leoSwingFrame import leoSwingTree


class Chapters( sevent.ChangeListener ):
    
    def __init__( self, c ):
        
        self.c = c
        self.book = None
        path = g.os_path_join( g.app.loadDir,"..","Icons", "x.png" )
        self.icon = swing.ImageIcon( path )
        self.popup = self.ChaptersPopup( self )
        self.chapters = {}
        self.trees_chapters = {}
        self.current_chapter = self.Chapter()
        self.chapterlist = []
        #let's skip adding the first chapter
        #self.chapterlist.append( self.current_chapter )
        self.current_chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
        self.updateLock = locks.ReentrantLock() #this increase by 1 for each lock call. -1 for each unlock.  If it becomes 0, the lock is released
        self.chaptersIterationBlocked = 0
        self.chaptersundoer = undo.UndoManager()
        self.chaptersPromptingForRemove = False
        
    
    def getChapter( self ):
        return self.current_chapter
    
    def startPromptingForRemove( self ):
        self.chaptersPromptingForRemove = True
        
    def stopPromptingForRemove( self ):
        self.chaptersPromptingForRemove = False
    
    def isPromptingForRemove( self ):
        return self.chaptersPromptingForRemove
    
    
    
    def disablePopup( self ):
        self.popup.disable()
        
    def enablePopup( self ):
        self.popup.enable()
    
    def beginUpdate( self ):
        self.updateLock.lock()
        
    def endUpdate( self ):
        self.updateLock.unlock()
    
    def getWidget( self ):
        if self.book is None: # We defer creating until here because otherwise the book variable might miss a L&amp;F change
            self.book = swing.JTabbedPane()
            self.book.addMouseListener( self.popup )
            ssm = self.book.getModel()
            ssm.addChangeListener( self )
        return self.book
        
    def getSelectedChapter( self ):
        return self.current_chapter
    
    def getSelectedChapterWidget( self ):
        
        return self.book.getSelectedComponent()
    
    @others
    
</t>
<t tx="ekr.20070127142814.953">@
Chapters simply put are multiple Outlines within the Leo instance.  The definition doesn't stop there though since having more than one Outline defines an interaction model between these Outlines.  It is better to think of it like so:
    An Outline is composed of at least 1 Chapter.
    A writen Outline with multiple Chapters should be indistinguishable from an Outline with one Chapter.  The only mark is that the roots will have a uA marking them as belonging to a specific Chapter.
    So at read time, the Outline is read in then broken into its separate Chapters.
    At write time, the Outline is reconstituted as one Outline during output.  The reunification is only realised on disk.  Internally we use magic unfication iterators that give the write process a sense that it is writing one outline.  These special iterators mean that there is a low impact upon the write code.  Much of it has stayed the same except that it now uses a different iterator.
</t>
<t tx="ekr.20070127142814.954">@
Observation 1: Do not start a beginUpdate in one chapter and finish it with a endUpdate in another chapter.  You will lose your ability to work with the outline/chapter where the beginUpdate started.  I have seen this happen, so let this be a warning to you.  I guess a protective fix against this would be to keep track of which chapter an endUpdate belongs to.  Hence doing a beginUpdate in one chapter followed by and endUpdate in another chapter would target the first chapter.  Im unsure if this would work, but it is a thought that may make the implementation more robust.

Observation 2: root positions should not become stale.  Since we aggresively copy everytime the root or current position is asked for from the chapter, the main copy should never change unless it is explicitly set.

Observation 3: Sliders and Phasers work better than dialogs with Chapters.  Ive found it disruptive when working with Chapters to suddenly have a dialog pop up grabbing my attention away from the Chapter Im working on.  Hence Ive moved informational and querying of the user primarily to Sliders.  Not only does it attach a question or notification to a Chapter better it also is very nice animation to observe.  Keeping our focus on the Chapter in question is essential!

Observation 4: We use the doHook mechanism to notify listeners that the current chapter has changed.  This makes it easy to monitor the changing of chapters, but the devloper must ensure that the chapter belongs to the chapters instance he is interested in.  Hence the commander is passed in as well.  If you are interested in the a specific Chapters instance the Commander should be enough to discern which chapters the chapter belongs to.  See the Node "A Note about Chapters and Commanders".





</t>
<t tx="ekr.20070127142814.955">@
Chapters Swing takes the lessons learned from past Chapters plugins and simplifies the implementation by making the Chapters instance the provider of the root, current and top positions.  The Command is no longer in charge of this and will delegate the:
    getCurrentPosition() # or is it c.currentPosition()? :D
    getTopPosition()
    getRootPosition()

to the Chapters instance.  Each Commander now has a Chapters instance upon instantiation.

Also setting the variables will be delegated to the Chapters instance, which in turn delegates to a Chapter instance.

Hence we can keep the Commander interface and just restructure the internals and Chapters are now available.</t>
<t tx="ekr.20070127142814.956">def setRootPosition( self, p ):
    
    #if self.loading: return
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setRootPosition( p )
    #self.roots[ self.current_chapter ] = p


def getRootPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getRootPosition()
    return None   
    #return self.roots[ self.current_chapter ].copy()
    #rv = self.roots.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
    
    
def setCurrentPosition( self, p ):
    
    #if self.loading: return    
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setCurrentPosition( p )   
    #self.currentPositions[ self.current_chapter ] = p
        
    
def getCurrentPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getCurrentPosition()
    return None
        
    #return self.currentPositions[ self.current_chapter ].copy()
    #rv = self.currentPositions.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
    
    

</t>
<t tx="ekr.20070127142814.957">def stateChanged( self, event ):
    
    c = self.c
    try:
        self.beginUpdate()
        index = self.book.getSelectedIndex()
        component = self.book.getComponentAt( index )
        chapter = self.chapters[ component ]
        c.frame.tree = chapter.tree
        self.current_chapter = chapter
        #chapter.tree.jtree.treeDidChange()
        c.beginUpdate()
        c.endUpdate()
        #c.selectPosition( chapter.getCurrentPosition() )
        self.current_chapter.undoer.setMenu( forceupdate = 1 )
        g.doHook( "chapter-changed", c = self.c, chapter = chapter )
    finally:
        self.endUpdate()
        
    #if chapter.root:
    #    chapter.root.linkAsRoot( None )

@   
    oldchapter = self.current_chapter
    index = self.book.getSelectedIndex()
    title = self.book.getTitleAt( index )
    self.current_chapter = title
    nwroot = self.chapters[ title ]
    oldroot = self.c.rootPosition().copy()
    self.chapters[ oldchapter ] = oldroot
    c.beginUpdate()
    c.setRootPosition( nwroot.copy() )
    c.endUpdate()


</t>
<t tx="ekr.20070127142814.958">def iterateOverChapters( self ):
    
    for x in self.chaptersIterator():
        print x
        
    

</t>
<t tx="ekr.20070127142814.959">def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name
                         

                

</t>
<t tx="ekr.20070127142814.960"></t>
<t tx="ekr.20070127142814.961">def changeChaptersName( self ):
       
    chapter = self.current_chapter
    if chapter.isMessaging(): return
    chapter.startMessaging()
    jp = swing.JPanel( java.awt.BorderLayout() )
    slider = Slider( jp, direction = Slider.down )
    #phaser = Phaser( jp )
    nlabel = swing.JLabel( "Chapter Name:" )
    jp.add( nlabel, java.awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    slider.setComponentToFocus( jtf )
    #phaser.setComponentToFocus( jtf )
    jtf.setText( str( chapter.name ) )
    jp.add( jtf )
    top = self.c.frame.top
    def closeAndChange():
        chapter.doneMessaging()
        nw_name = jtf.getText()
        book = self.book
        index = book.getSelectedIndex()
        old_name= book.getTitleAt( index ) 
        book.setTitleAt( index, nw_name )
        self.chaptersundoer.addEdit( self.UndoChangeChapterName( self, chapter, old_name, nw_name ) )
        chapter.name = nw_name
        slider.startRemoving()
        #phaser.phaseRemove()
    
    class aa( swing.AbstractAction ):
        def __init__( self, *args ):
            swing.AbstractAction.__init__( self, *args )
        
        def actionPerformed( self, ae ):
            closeAndChange()
    ks = swing.KeyStroke.getKeyStroke( "ENTER" )
    if ks:
        am = jtf.getActionMap()
        im = jtf.getInputMap()
        im.put( ks, "enter" )
        am.put( "enter", aa() )
    jp2 = swing.JPanel() 
    jb = swing.JButton( "Ok" )
    jb.actionPerformed = lambda event : closeAndChange()
    jp2.add( jb )
    jp.add( jp2, java.awt.BorderLayout.SOUTH )
    tree = self.c.frame.tree
    jtree = tree.jtree
    bg = jtree.getBackground()
    fg = jtree.getForeground()
    jp.setBackground( bg )
    jp.setForeground( fg )
    nlabel.setForeground( fg )
    jp2.setBackground( bg )
    jp2.setForeground( fg )
    lb = swing.border.LineBorder( fg )
    jp.setBorder( lb )
    main_widget = tree.getWidget()
    vrect = tree.jspane.getViewportBorderBounds()
    height = slider.getPreferredSize().height
    #height = phaser.getPreferredSize().height
    vrect.height = height
    slider.setBounds( vrect )
    #phaser.setBounds( vrect )
    gp = main_widget.getGlassPane()
    gp.setVisible( True )
    gp.add( slider )
    #gp.add( phaser )



</t>
<t tx="ekr.20070127142814.962">def moveNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
        
    if cpos.isRoot():
        testroot = cpos.copy()
        testroot.moveToNext()
        if not testroot:
            return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        return
    
    try:    
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        pos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        pos.linkAfter( cpos )
        c.endUpdate()
    

        self.current_chapter = current
        c.frame.tree = current.tree
    finally:
        self.endUpdate()

</t>
<t tx="ekr.20070127142814.963">def copyNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.copyTreeAfter()    
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    #parent = cpos.getParent()    
    #if parent:
    #    ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    #else:
    #    ok = 1
        
    #if not ok:
    #    return
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
        c.endUpdate()
        self.current_chapter = current
        c.frame.tree = current.tree
        current.undoer.setMenu( forceupdate = 1 )
    finally:
        self.endUpdate()
</t>
<t tx="ekr.20070127142814.964">def cloneNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.clone( pos.copy() )
        
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( nwpos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        nwpos.unlink()
        c.beginUpdate()
        c.endUpdate()
        return
    
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
    finally:
        c.endUpdate()
    

    self.current_chapter = current
    c.frame.tree = current.tree
    self.endUpdate()
    current.undoer.setMenu( forceupdate = 1 )</t>
<t tx="ekr.20070127142814.965">def testNode( self ):
    
    chapter = self.current_chapter
    pos = chapter.getCurrentPosition()
    
    print pos
    for ancestor in pos.self_and_parents_iter(): #copy = 1):
        print ancestor, ancestor.isCloned()</t>
<t tx="ekr.20070127142814.966">def swapChapters( self, chapter1, chapter2, undo = True ):

    try:    
        self.beginUpdate()
        widget1 = chapter1.tree.getWidget()
        widget2 = chapter2.tree.getWidget()
        index1 = self.book.indexOfComponent( widget1 )
        index2 = self.book.indexOfComponent( widget2 )
        jp = swing.JPanel() #place holder, keeps order
        self.book.setComponentAt( index1, jp )
        self.book.setComponentAt( index2, widget1 )
        self.book.setComponentAt( index1, widget2 )
        self.book.setTitleAt( index1, chapter2.name )
        self.book.setTitleAt( index2, chapter1.name )
        i1 = self.chapterlist.index( chapter1 )
        i2 = self.chapterlist.index( chapter2 )
        self.chapterlist[ i1 ] = chapter2
        self.chapterlist[ i2 ] = chapter1
        self.current_chapter = chapter2
        self.c.frame.tree = chapter2.tree
        self.c.beginUpdate()
        self.c.endUpdate()
        if undo:
            self.chaptersundoer.addEdit( self.UndoSwapChapters( self, chapter1, chapter2 )) 
    finally:
        self.endUpdate()
    
    </t>
<t tx="ekr.20070127142814.967">def mergeChapters( self, chapter1, chapter2 ):

	try:    
        self.beginUpdate()
    
        rp = chapter2.getRootPosition()
        nodes = []
        for z in rp.self_and_siblings_iter( copy = True ):
            nodes.append( z )
    
        for z in nodes:
            z.unlink()
        
        rp2 = chapter1.getRootPosition()
        for z in rp2.self_and_siblings_iter( copy = True ):
            pass   
        base = z.copy()

    
        self.c.beginUpdate()
    
        for z in nodes:
            z.linkAfter( base )
            base = z.copy()
        
        self.quietRemoveChapter( chapter2 )
        self.c.endUpdate()    
    finally:
        self.endUpdate()</t>
<t tx="ekr.20070127142814.968">def selectChapter( self, chapter ):
    
    widget = chapter.tree.getWidget()
    index = self.book.indexOfComponent( widget )
    if index != -1:
        self.book.setSelectedComponent( widget )
    </t>
<t tx="ekr.20070127142814.969">def insertChapter( self, chapter ):
    
    self.chapterlist.append( chapter )
    tree = chapter.tree 
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()   
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( chapter.name, ic, widget )

</t>
<t tx="ekr.20070127142814.970">def findChapterForNode( self, p ):
    
    for n in xrange( self.book.getTabCount() ):
        widget = self.book.getComponentAt( n )
        chapter = self.chapters[ widget ]
        rp = chapter.getRootPosition()
        for z in rp.fromSelfAllNodes_iter( copy = True ):
            if z == p: return chapter
        
    return None</t>
<t tx="ekr.20070127142814.971">def turnNodeIntoChapter( self ):
    
    cp = self.current_chapter.getCurrentPosition()
    if cp.isRoot():
        testroot = cp.copy()
        testroot.moveToNext()
        if not testroot:
            return
    self.c.beginUpdate()
    cp.unlink()
    rp = self.current_chapter.getRootPosition()
    self.current_chapter.setCurrentPosition( rp )
    self.c.endUpdate()
    self.freshChapter( p = cp )</t>
<t tx="ekr.20070127142814.972">@others
</t>
<t tx="ekr.20070127142814.973">def importOutline( self ):
    
    fc = swing.JFileChooser()
    fc.showOpenDialog( None )
    sfile = fc.getSelectedFile()
    if sfile:
        self.loadFileAsChapter( sfile.getAbsolutePath() )
    
def loadFileAsChapter( self, fname ):
    
    c = self.c
    targetfile = java.io.File( fname )
    if not targetfile.exists() or targetfile.isDirectory():
        return
    
    mungedname = targetfile.getName()
    if mungedname.endswith( ".leo") : mungedname = mungedname[ : -4 ]
    def run():
        self.freshChapter( name = mungedname, edit = False, undo = False )
        
    dc = DefCallable( run )
    ft = dc.wrappedAsFutureTask()
    if java.awt.EventQueue.isDispatchThread():
        ft.run()
    else:
        swing.SwingUtilities.invokeAndWait( ft )
    
    edit = sel.UndoImport( self, self.current_chapter )
    self.chaptersundoer.addEdit( edit )
    c.frame.disableResizing()
    p = c.fileCommands.getLeoFileAsOutline( fname )
    c.frame.enableResizing()
    oldir = c.frame.openDirectory
    parent = targetfile.getParentFile()
    c.frame.openDirectory = parent.getAbsolutePath()
    c.atFileCommands.readAll( c.rootPosition().copy() ,partialFlag=False)
    c.frame.openDirectory= oldir
    self.deferedChapterization( c.rootPosition(), selectchapter = self.getSelectedChapterWidget(), edit = edit )
    


</t>
<t tx="ekr.20070127142814.974">def exportOutline( self ):
    
    self.chaptersIterationBlocked = 1
    self.beginUpdate()
    fc = swing.JFileChooser()
    fc.showSaveDialog( None )
    sfile = fc.getSelectedFile()
    if not sfile:
        g.es( "No file name entered." )
        return
    fileName = fc.getName( sfile )
    if not fileName.endswith( ".leo" ):
        fileName = "%s.leo" % fileName
    self.c.fileCommands.write_Leo_file( fileName, True )
    self.chaptersIterationBlocked = 0
    self.endUpdate()
    g.es( "Done Exporting %s as %s" % ( self.current_chapter.name, fileName ) )</t>
<t tx="ekr.20070127142814.975">@others
</t>
<t tx="ekr.20070127142814.976">def addChapter( self, name, p = None ):
    

    c = self.c
    chapter = self.Chapter()
    self.chapterlist.append( chapter )
    chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #self.current_chapter = current
    cm = self.ChapterModel( c , chapter) #, p )
    tree = leoSwingTree( frame = c.frame, model = cm, chapter= chapter )
    tree.createAuxilaryWidgets()
    #self.c.frame.tree = tree
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( name, ic, widget )

    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree



</t>
<t tx="ekr.20070127142814.977">def addChapterForSettingsTree( self, name, p = None , controller = None):
    
    c = self.c
    chapter = self.current_chapter
    #chapter = self.Chapter()
    #chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #c.chapters.current_chapter = chapter
    #chapter = self.current_chapter
    cm = self.ChapterModel( c , chapter)
    import leoConfig
    tree = leoConfig.settingsTree( frame = c.frame, model = cm, chapter = chapter, controller = controller )
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    self.book = self.getWidget()
    self.book.addTab( name, widget )
    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree




</t>
<t tx="ekr.20070127142814.978">def freshChapter( self, p = None, name = None, edit = True, undo = True ):
    
    c = self.c
    if not p:
        t = leoNodes.tnode( headString = "NewHeadline" )
        v = leoNodes.vnode( c, t )
        p = leoNodes.position( v, [] )
    if not name:
        name = "New Chapter"
    tree = self.addChapter( name, p = p )                    
    chapter = self.trees_chapters[ tree ]
    if undo:
        self.chaptersundoer.addEdit( self.UndoAddChapter( self, chapter ) ) 
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        p.linkAsRoot( None )
        #self.current_chapter = current 
        widget = tree.getWidget()
        self.book.setSelectedComponent( widget )   
    finally:
        self.endUpdate()
    tree.loaded = 1
    if edit:
        self.c.editPosition( p.copy() )</t>
<t tx="ekr.20070127142814.979">def removeChapter( self, chapter = None, undo = True ):

    tree = self.c.frame.tree
    vrect = tree.jspane.getViewportBorderBounds()
    main_widget = tree.getWidget()
    gp = main_widget.getGlassPane()
    bgc = tree.jtree.getBackground()
    fgc = tree.jtree.getForeground() 
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    fg = self.book.getForegroundAt( index )
    bg = self.book.getBackgroundAt( index )
    if chapter.isMessaging() or self.isPromptingForRemove(): return
    chapter.startMessaging()
    self.startPromptingForRemove()
    self.book.setForegroundAt( index, bg )
    self.book.setBackgroundAt( index, fg )
    if self.book.getTabCount() == 1:
        def ok( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
        buttons = ( ( "Ok", ok ), )
        sa = self.SliderMessageButtons( "Can't remove the only Chapter", buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )
        return
    else:
        message = "Do you want to remove Chapter: %s ?" % chapter.name
        def yes( component = component, chapter = chapter ):
            self.book.remove( component )
            chapter.doneMessaging()
            self.chapterlist.remove( chapter )
            tree = chapter.tree 
            del self.trees_chapters[ tree ]
            del self.chapters[ component ]
            self.chaptersundoer.addEdit( self.UndoRemoveChapter( self, chapter ) )
            try:
                index = self.book.getSelectedIndex()
                component = self.book.getComponentAt( index )
                #self.chapters[ widget ] = chapter
                chapter = self.chapters[ component ]
                self.beginUpdate()
                self.current_chapter = chapter
                self.c.frame.tree = chapter.tree
            finally:
                self.endUpdate()
            self.stopPromptingForRemove()            
            g.doHook( "chapter-removed", c = self.c, chapter = chapter )
            
        def no( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
            
        buttons = ( ( "Yes", yes ), ( "No", no ) )
        sa = self.SliderMessageButtons( message, buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )            
           
@    
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    rv = swing.JOptionPane.showConfirmDialog( None,
                                             "Do you want to remove Chapter: %s" % chapter.name,
                                             "Remove a Chapter?",
swing.JOptionPane.YES_NO_OPTION )
    if rv == swing.JOptionPane.NO_OPTION: return


    self.book.removeTabAt( index ) #removing does not fire a change event
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    self.chapterlist.remove( chapter )
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        self.c.frame.tree = chapter.tree
    finally:
        self.endUpdate()
    g.doHook( "chapter-removed", c = self.c, chapter = chapter )
</t>
<t tx="ekr.20070127142814.980">def quietRemoveChapter( self, chapter ):
    
    tree = chapter.tree
    component = tree.getWidget()
    self.book.remove( component )
    self.chapterlist.remove( chapter )
    del self.trees_chapters[ tree ]
    del self.chapters[ component ]    
</t>
<t tx="ekr.20070127142814.981">@others
</t>
<t tx="ekr.20070127142814.982">def deferedChapterization( self, pos, selectchapter = None, edit = None ):
    
    x = lambda : self.breakOutlineIntoChapters( pos, selectchapter, edit )
    dc = DefCallable( x )
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater( ft )
</t>
<t tx="ekr.20070127142814.983">def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )
    
    
    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name
                   

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()


</t>
<t tx="ekr.20070127142814.984">class ChaptersPopup( aevent.MouseAdapter ):
    
    def __init__( self, chapters ):
        aevent.MouseAdapter.__init__( self )
        self.chapters = chapters
        self.copyNodeToChapter = self.CopyNodeToChapter( chapters )
        self.cloneNodeToChapter = self.CloneNodeToChapter( chapters )
        self.swapChapters = self.SwapChapters( chapters )
        self.mergeChapters = self.MergeChapters( chapters )
        self.enabled = True
        
    def disable( self ):
        self.enabled = False
        
    def enable( self ):
        self.enabled = True
        
    @others</t>
<t tx="ekr.20070127142814.985">def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1 and self.enabled:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
            DefAction = self.chapters.DefAction        
            popup = swing.JPopupMenu()            
            popup.add( DefAction( "Add Chapter", self.chapters.freshChapter ) ) 
            #popup.add( DefAction( "Remove Chapter", self.chapters.removeChapter ) )
            #popup.add( DefAction( "ITERATE!", self.chapters.iterateOverChapters ) ) 
            popup.add( DefAction( "Edit Chapters Name", self.chapters.changeChaptersName ) )
            popup.addSeparator()
            popup.add( self.copyNodeToChapter.getWidget() )
            popup.add( self.cloneNodeToChapter.getWidget() )
            popup.add( self.swapChapters.getWidget() )
            popup.add( self.mergeChapters.getWidget() )
            popup.add( DefAction( "Copy Node Into Chapter", self.chapters.turnNodeIntoChapter ) )
            #popup.add( DefAction( "Test NODE", self.chapters.testNode ) )
            popup.addSeparator()
            menu = swing.JMenu( "Import/Export" )
            popup.add( menu )
            menu.add( DefAction( "Import Outline", self.chapters.importOutline ) )
            menu.add( DefAction( "Export Chapter as Outline", self.chapters.exportOutline ) )
            popup.addSeparator()
            undoer = self.chapters.chaptersundoer
            utext = undoer.getUndoPresentationName()
            item = popup.add( DefAction( utext, undoer.undo ) )
            if not undoer.canUndo():
                item.setEnabled( False )
                
            rtext = undoer.getRedoPresentationName()
            item = popup.add( DefAction( rtext, undoer.redo ) )
            if not undoer.canRedo():
                item.setEnabled( False )    
                              
            source = mE.getSource()                
            popup.show( source, x, y )
</t>
<t tx="ekr.20070127142814.986">class CopyNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Copy Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.copyNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20070127142814.987">class CloneNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Clone Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.cloneNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20070127142814.988">class SwapChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Swap Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            swapchap = lambda event,  chapter = z: self.chapters.swapChapters( current, chapter )
            jmi.actionPerformed = swapchap
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20070127142814.989">class MergeChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Merge Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mergechapters = lambda event,  chapter = z: self.chapters.mergeChapters( current, chapter )
            jmi.actionPerformed = mergechapters
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20070127142814.990">@others
</t>
<t tx="ekr.20070127142814.991">class DefAction( swing.AbstractAction ):
    
    def __init__( self, name, function ):
        swing.AbstractAction.__init__( self, name )
        self.function = function
    
    def actionPerformed( self, event ):
        self.function()</t>
<t tx="ekr.20070127142814.992">class ChapterModel( stree.TreeModel, java.lang.Runnable ):
    
    
    
    def __init__( self, c , chapter ):#, proot ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c, chapter ) # , proot )
        self._rTreePath = stree.TreePath( self._root ) 
        self.chapter = chapter
        self.drunning = 0

        
    def getChapter( self ):
        return self.chapter

    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):
        
        
        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            #for z in self.c.rootPosition().allNodes_iter( copy = True ):
            for z in self._root.getRootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )
        
        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in list( self.tmlisteners ):
            z.treeStructureChanged( e )

            
    def dRun( self ):
        self.drunning = 1
        swing.SwingUtilities.invokeLater( self )
            
    def run( self ):
        
        try:
            import jarray
            a = jarray.zeros( 1, stree.TreeNode )
            a[ 0 ] = self._root
            e = sevent.TreeModelEvent( self._root, a )
            for z in list( self.tmlisteners ):
                z.treeStructureChanged( e )
            if self.chapter.tree.jtree:
                self.chapter.tree.jtree.fireTreeExpanded( self._rTreePath )
                cp = self.chapter.getCurrentPosition()
                cpp = self.getPathToRoot( cp )
                self.chapter.tree.jtree.setSelectionPath( cpp )
        finally:
            self.drunning = 0
    
    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )
        
    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )
    
    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()
        
    def getChildCount( self, parent ):
        
        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0
        
    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()


    
    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )
        
    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True
            
            
    def getPathToRoot( self, node, masterlist = None ):
        
        path = []
        #if not node:
        #    node = self.c.rootPosition()
        stopat = None
        if self.chapter.hoistStack:
            bunch = self.chapter.hoistStack[ -1 ]
            stopat = bunch.p.copy()
            
        while node and node.level() != 0:
            path.append( node.copy() )
            if node == stopat: break
            node = node.getParent()
            if masterlist:
                if node in masterlist:
                    masterlist.remove( node )
        else:
            path.append( node.copy() )
        
        path.append( self._root )  
        path.reverse()
        tp = stree.TreePath( path )
        return tp
            
    class _rootN( stree.TreeNode ):
        
        def __init__( self, c, chapter ):#, proot ):
            self.c = c
            self.chapter = chapter
            self.v = None # These are for comparisons with positions, we must pretend to be a position
            self.stack = None
            
            #self.chapters = c.chapters
            #self.proot = proot
        def expand( self ): pass
        def contract( self ): pass
        
        def getChildIndex( self ):
            return -1
        
        def getRootPosition( self ):
            rp = self.chapter.getRootPosition()
            return rp

        
        def getChildAt(self, childIndex):
            rp = self.getRootPosition() #self.c.rootPosition()                
            #if len( self.c.hoistStack ) != 0: #Hoist Code
            if len( self.chapter.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ].p.copy()
                rp = self.chapter.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       
        
        def getChildCount( self ):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 1
            #if len( self.c.hoistStack ) != 0:
            #    return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i
        
        def getParent( self ):
            return None
            
        def getIndex( self, node):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1
            
        def getAllowsChildren( self ):
            return True
            
        def isLeaf( self ):
            return False
            
        def equal( self, x ):
            if self is x: return True
            else: return False
            
        def equals( self, x ):
            if self is x: return True
            else:
                return False
            
        def copy( self ):
            return self
            
        def bodyString( self ):
            return ""
            
        def headString( self ):
            return ""
            
        def children( self ):
            
            class _enum( util.Enumeration ):
                
                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None
                
                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False
                    
                def nextElement( self ):
                    
                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            return _enum( rp.siblings_iter( copy = True ) )
            #return _enum( self.c.rootPosition.siblings_iter( copy = True ) )        
        

    
       





</t>
<t tx="ekr.20070127142814.993">class Chapter:
    
    def __init__( self ):
        
        self.root = None
        self.currentPosition = None
        self.tree = None
        self.name = None
        self.hoistStack = []
        self.undoer = None
        self.messaging = False
        
    def startMessaging( self ):
        self.messaging = True
    
    def isMessaging( self ):
        return self.messaging
        
    def doneMessaging( self ):
        self.messaging = False
        
    def isValid( self ):
        widget = self.tree.getWidget()
        if widget.getParent(): return True
        else:
            return False    
        
    def setUndoer( self, undoer ):
        self.undoer = undoer
        
    def getUndoer( self ):
        return self.undoer
        
    def getName( self ):
        return self.name
        
    def setName( self, name ):
        self.name = name
        
    
    def getTree( self ):
        return self.tree
        
    def setTree( self, tree ):
        self.tree = tree
    
    def setRootPosition( self, p ):
    
        if p:
            p = p.copy()
        self.root = p


    def getRootPosition( self ):
        
        p = self.root
        if p:
            p = p.copy()
        return p
    
    
    def setCurrentPosition( self, p ):
        
        if p:
            p = p.copy()        
        self.currentPosition = p
        
    
    def getCurrentPosition( self ):
        
        p = self.currentPosition
        if p:
            p = p.copy()
        return p
          
</t>
<t tx="ekr.20070127142814.994">class SliderMessageButtons( sevent.AncestorListener ):
    '''A class that manages creates a message with 0 to N buttons for
       the user to select.  After selecting the button, the slider is removed.
       After removal the function corresponding to the button is fired'''
       
    def __init__( self, message, buttons = (), direction = Slider.down, bgc = None, fgc = None ):
        
        self.backingpanel = swing.JPanel( awt.BorderLayout() )
        self.slider = Slider( self.backingpanel, direction )
        if fgc:
            lb = swing.border.LineBorder( fgc )
            self.backingpanel.setBorder( lb )
        else:
            lb = swing.border.LineBorder( self.backingpanel.getForeground() )
            self.backingpanel.setBorder( lb )
        jl = swing.JLabel( message )
        jl.setHorizontalAlignment( swing.SwingConstants.CENTER )
        self.backingpanel.add( jl )
        jp2 = swing.JPanel()
        self.func = None
        for z in buttons:
            label = z[ 0 ]
            func = z[ 1 ]
            b = swing.JButton( label )
            b.actionPerformed = lambda event, func = func: self.__removeCall( func )
            jp2.add( b )

        self.backingpanel.add( jp2, awt.BorderLayout.SOUTH )
        self.slider.setSize( self.slider.getPreferredSize() )
        if not fgc is None:
            self.backingpanel.setForeground( fgc )
            jp2.setForeground( fgc )
            jl.setForeground( fgc )
        if not bgc is None:
            self.backingpanel.setBackground( bgc )
            jp2.setBackground( bgc )
            jl.setBackground( bgc )
        
    def __removeCall( self, func ):
        self.slider.addAncestorListener( self )
        self.slider.startRemoving()
        self.func = func
        
    def ancestorAdded( self, event):
        pass
        
    def ancestorMoved( self, event ):
        pass
        
    def ancestorRemoved( self, event ):
        if not self.func is None:
            self.func()
        
    def getSlider( self ):
        return self.slider

</t>
<t tx="ekr.20070127142814.995">class IconCloser( swing.Icon, aevent.MouseAdapter ):
    
    def __init__( self, iicon, callback ):
        
        aevent.MouseAdapter.__init__( self )
        self.iicon = iicon
        self.component = None
        self.x = None
        self.y = None
        self.callback = callback
        
    def mousePressed( self, event ):
        
        if event.getButton() == event.BUTTON1:
            x = event.getX(); y = event.getY()
            rec = awt.Rectangle( self.x, self.y, self.iicon.getIconWidth(), self.iicon.getIconHeight() )
            if rec.contains( x,y ):
                self.component.removeMouseListener( self )
                self.component = None
                dc = DefCallable(self.callback)
                swing.SwingUtilities.invokeLater(dc.wrappedAsFutureTask())
        
    def getIconHeight( self ):
        
        return self.iicon.getIconHeight()
        
    def getIconWidth( self ):
        
        return self.iicon.getIconWidth()
        
    def paintIcon( self, jc, g, x, y ):
        
        if self.component == None:
            self.component = jc
            jc.addMouseListener( self )
        self.x = x
        self.y = y
        self.iicon.paintIcon( jc, g, x ,y )
        </t>
<t tx="ekr.20070127142814.996">@others
</t>
<t tx="ekr.20070127142814.997">def chaptersIterator( self ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.fromSelfAllNodes_iter( copy = True ):
                yield z
    else:
        
        for z in self.c.allNodes_iter( copy = 1 ):
            yield z            

                
</t>
<t tx="ekr.20070127142814.998">def topLevelSiblingsIterator( self, ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.self_and_siblings_iter( copy = True ):
                yield z
    else:
        rp = self.c.rootPosition()
        for z in rp.self_and_siblings_iter( copy = True ):
            yield z
            
</t>
<t tx="ekr.20070127142814.999">def cycleThroughChapters( self, swap = 1 ):

    if not self.chaptersIterationBlocked:
        current = self.current_chapter
        if swap: self.beginUpdate()
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            if swap:    
                self.current_chapter = chapter
            yield chapter
    
        self.current_chapter = current
        if swap: self.endUpdate()
    else:
        yield self.current_chapter
    
</t>
<t tx="ekr.20070127142814.1000">@others</t>
<t tx="ekr.20070127142814.1001">class UndoRemoveChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Remove Chapter %s" % self.chapter.name
    def getRedoPresentationName( self ): return "Redo Removing %s" % self.chapter.name
    def getUndoPresentationName( self ): return "Undo Removing %s" % self.chapter.name
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = True
    
</t>
<t tx="ekr.20070127142814.1002">class UndoChangeChapterName( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter, name1, name2 ):
        self.chapters = chapters
        self.chapter = chapter
        self.name1 = name1
        self.name2 = name2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Changing Chapter Name From %s to %s" % ( self.name1, self.name2 )
    def getRedoPresentationName( self ): return "Redo Changing Name From %s to %s" %  ( self.name1, self.name2 )
    def getUndoPresentationName( self ): return "Undo Changing Name From %s to %s" % ( self.name1, self.name2 )
    def isSignificant( self ): return True
    def redo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name2 )
        self.chapter.name = self.name2
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name1 )
        self.chapter.name = self.name1
        self.undone = True
</t>
<t tx="ekr.20070127142814.1003">class UndoAddChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Add Chapter"
    def getRedoPresentationName( self ): return "Redo Add Chapter"
    def getUndoPresentationName( self ): return "Undo Add Chapter"
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = True
    
</t>
<t tx="ekr.20070127142814.1004">class UndoImport( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter_list = []
        self.chapter_list.append( chapter )
        self.undone = False
    
    def addChapter( self, chapter ):
        self.chapter_list.append( chapter )
           
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Import Outline"
    def getRedoPresentationName( self ): return "Redo Import Outline"
    def getUndoPresentationName( self ): return "Undo Import Outline"
    def isSignificant( self ): return True
    def redo( self ):
        
        for z in self.chapter_list:
            self.chapters.insertChapter( z )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        for z in self.chapter_list:
            self.chapters.quietRemoveChapter( z )
        self.undone = True
    
</t>
<t tx="ekr.20070127142814.1005">class UndoSwapChapters( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter1, chapter2 ):
        self.chapters = chapters
        self.chapter1 = chapter1
        self.chapter2 = chapter2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Swap Chapters %s , %s" % ( self.chapter1.name, self.chapter2.name )
    def getRedoPresentationName( self ): return "Redo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def getUndoPresentationName( self ): return "Undo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = True
    
</t>
<t tx="ekr.20070127142814.1006">@language java
import java.awt.*;
import java.awt.event.FocusListener;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.text.*;
import java.util.concurrent.*;
import java.util.*;


public final class leoIconTreeRenderer extends DefaultTreeCellRenderer{

    final Object _root;
    final JLabel _rootComponent;
    static public ImageIcon[] _icons;
    final Color _fg;
    final Color _bg;
    final JTextPane _jta;
    final JTextField _jtf;
    final DefaultStyledDocument doc;
    final JLabel _jl;
    //final Box _box;
    final JPanel _jp;
    JLabel dl;
    boolean do_directive_color;
    boolean do_brackets_color;
    Color directive_color;
    Color brackets_color;
    final Map directives;
    final Font normal_font;
    //Exchanger&lt;String&gt; go;
    
    JPanel _jp2;
    JLabel _image;
    JLabel _image2;
    JLabel _comments;
    
    Icon comment;
    
    public leoIconTreeRenderer( final Object root,
                                final ImageIcon[] icons, 
                                final Color fg, 
                                final Color bg,
                                boolean do_brackets,
                                Color brackets_color,
                                boolean do_directives,
                                Color directive_color,
                                Map directives ){ 
    
        _root = root;
        do_brackets_color = do_brackets;
        this.brackets_color = brackets_color;
        do_directive_color = do_directives;
        this.directive_color = directive_color;
        this.directives = directives;
        _icons = icons;
        _rootComponent = new JLabel();
        _fg = fg;
        _bg = bg;
        _jta = new JTextPane();
        _jta.setOpaque( false );
        _comments = new JLabel();
        normal_font = _jta.getFont();
        _jtf = new JTextField();
        _jtf.setOpaque( false );
        _jl = new JLabel();
        _jl.setOpaque( false );
        FlowLayout fl = new FlowLayout();
        fl.setVgap( 1 );
        fl.setHgap( 0 );
        _jp = new JPanel( fl );
        _jp.add( _jl );
        _jp.add( _comments );
        _jp.add( _jta );
        //_jp.add( _comments );
        _jp.setOpaque( false );
        doc = new DefaultStyledDocument();
        _jta.setDocument( doc );
        
        FlowLayout fl2 = new FlowLayout();
        _jp2 = new JPanel( fl2 );
        fl2.setVgap( 0 );
        fl2.setHgap( 0 );
        _image = new JLabel();
        _image2 = new JLabel();

        _jp2.add( _image );
        _jp2.add( _image2 );
        //_jp.add( _comments );
        _jp2.setOpaque( false );
        //go = new Exchanger&lt;String&gt;();
        //Thread t = new Thread( this );
        //t.setDaemon( true );
        //t.start();
    
    }
    
    public void setCommentIcon( Icon ci ){
    
        comment = ci;
    
    }
    
    public Icon getCommentIcon(){
    
        return comment;
    
    }
    
    public void addFocusListener( FocusListener fl ){
    
        super.addFocusListener( fl );
        _jta.addFocusListener( fl );
        _jp2.addFocusListener( fl );
    
    
    }
    
    public static class JPanel2 extends JPanel{
    
        public JPanel2( LayoutManager lm ){
        
            super( lm );
        
        }
        
        public void paint( Graphics g ){
            
            Graphics2D g2 = (Graphics2D)g;
            g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
            g2.setRenderingHint( RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON );
            super.paint( g2  );
        
        
        }
    
    
    }    

    public final Component getTreeCellRendererComponent( final JTree tree, final Object value, 
                                                         final boolean sel, final boolean expanded,
                                                         final boolean leaf, final int row,
                                                         final boolean hasFocus ){
        Color bg = null;
        Color fg = null;  
                      
        boolean bold = false;
        boolean italic = false;                                               
                                                         
        if( value == _root ) return _rootComponent;
        else{
        
            final PositionSpecification p = (PositionSpecification)value;
            final int icon = p.computeIconFromV();
            ImageIcon current = _icons[ icon ];
            ImageIcon current2 = p.getIcon();
            //if( p.tnodeHasUA( "__commentaries" ) )
            //    _comments.setIcon( comment );
            //else
             //   _comments.setIcon( null );
            
            if( current2 != null ){
             
             current = current2;
             
             
             }
            
            _jl.setIcon( current );
            setClosedIcon( current );
            setOpenIcon( current );
            setLeafIcon( current );
            
            ImageIcon ii = p.getImage();
            if( ii != null ){
            
            
                _image.setIcon( current );
                _image2.setIcon( ii );
                return _jp2;
            
            
            
            }
            
            try{
            
                SimpleAttributeSet sas = new SimpleAttributeSet();
                
                if( !sel ){
                
                    bg = p.getBackground();
                    if( bg == null ) bg = _bg;
                    _jta.setBackground( bg );
                    fg = p.getForeground();
                    if( fg == null ) fg = _fg;
                    _jta.setForeground( fg );
                
                }
                else{
                
                    _jta.setForeground( _jta.getSelectedTextColor() );
                    _jta.setBackground( _jta.getSelectionColor() );
                
                
                
                }
                
                StyleConstants.setBackground( sas, _jta.getBackground() );
                StyleConstants.setForeground( sas, _jta.getForeground() );
                
                
                if( p.getUnderline() )
                    StyleConstants.setUnderline( sas, true );
                if( p.getStrikeThrough() )
                    StyleConstants.setStrikeThrough( sas, true );
                if( p.getItalic() ){
                    
                    italic = true;
                    StyleConstants.setItalic( sas, true );
                    
                    }
                if( p.getBold() ){
                    bold = true;
                    StyleConstants.setBold( sas, true );
                    
                }
                Font f;
                if( ( f= p.getFont() ) != null ){
                
                    _jta.setFont( f );
                    _jtf.setFont( f );
                
                
                }
                else{
                
                    //_jta.setFont( normal_font );
                    //_jtf.setFont( normal_font );
                    _jta.setFont( getFont() );
                    _jtf.setFont( getFont() );
                
                
                
                }
                
                
                SimpleAttributeSet sas2 = new SimpleAttributeSet( sas );
                //System.out.println( value.getClass() );
                PositionSpecification ps = (PositionSpecification)value;
                TnodeBodyText tnt = ps.getTnodeBodyText();
                String headline = tnt.getHeadString(); //value.toString();
                //String headline = value.toString();
                String check = headline.trim();
                String start = "";
                String end = "";
                
                //go.exchange( null );
                //go.exchange( null );
                if( do_brackets_color &amp;&amp; check.startsWith( "&lt;"+ "&lt;" ) &amp;&amp; check.endsWith( "&gt;" +"&gt;" ) ){
                
                    int i = headline.indexOf( "&lt;" + "&lt;" );
                    int i2 = headline.lastIndexOf( "&gt;" + "&gt;" );
                    start = headline.substring( 0, i + 2 );
                    end = headline.substring( i2 );
                    headline = headline.substring( i + 2, i2 );
                    StyleConstants.setForeground( sas2, brackets_color );
                
                
                }
                else if ( do_directive_color ){
                
                    final String[] tokens = check.split( "\\s" );
                    if( directives.containsKey( tokens[ 0 ] ) ){
                    
                        int i = headline.indexOf( tokens[ 0 ] );
                        int len = tokens[ 0 ].length();
                        start = headline.substring( 0, i + len );
                        headline = headline.substring( i + len );
                        StyleConstants.setForeground( sas2, directive_color );
                    
                    
                    }
                              
                
                }
                
                //final Thread cwriter = doc.getCurrentWriter2();
                //final Thread current = Thread.currentThread();
                //if( cwriter != null ) return this;

                doc.remove( 0, doc.getLength() );
                doc.insertString( 0, start, sas2 );
                doc.insertString( _jta.getCaretPosition() , headline, sas );
                doc.insertString( _jta.getCaretPosition(), end, sas2 );
                    
            
                
            }
            catch( Exception x ){
            
                System.out.println( x );
               // x.printStackTrace();
            
            }
        

        
                
        
        }                                                     
        
        //Component c = super.getTreeCellRendererComponent( tree, value, sel, expanded, leaf, row, hasFocus );                                       //setBackgroundNonSelectionColor( bg );
        //setForeground( fg );
        
        //_jp.setSize( _jta.getPreferredSize() );
        _jtf.setText( _jta.getText() );
        Dimension ps = _jtf.getPreferredSize();
        Dimension ps2 = _jta.getPreferredSize();
        ps2.height = ps.height;
        Font f = _jta.getFont();
        int which = 0;
        if( bold )
            which |= f.BOLD;
        if( italic )
            which |= f.ITALIC;
        if( which != 0 ) f = f.deriveFont( which );
            
        FontMetrics fm = _jta.getFontMetrics( f );
        ps2.width =  fm.stringWidth( _jta.getText() ) + _jta.getMargin().left + _jta.getMargin().right; 
        _jta.setPreferredSize( ps2 );
        //_jta.revalidate();
        
        //System.out.println( ps2 );
        //System.out.println( tree.getRowHeight()) ;
        //if( tree.getRowHeight() &lt; ps2.height )
        //     tree.setRowHeight( ps2.height );
        //_jta.setMinimumSize( ps2 );
        
        
        return _jp;
        //return c;        
                                                         
                                                         
                                                         
    }

    @others


}



@
class lsrender( stree.DefaultTreeCellRenderer ):
    def __init__( self, c ):
        stree.DefaultTreeCellRenderer.__init__( self )
        self.c = c
        self.images = {}
        for z in xrange( 16 ):
            num = z
            if num &lt; 10:
                num = "0%s" % num
            self.images[ z ] = swing.ImageIcon( "../Icons/box%s.GIF" % num )

        self.openN = swing.ImageIcon( "../Icons/minusnode.GIF" )
        self.closedN = swing.ImageIcon( "../Icons/plusnode.GIF" )
        self._rootComponent = swing.JLabel()
        self.normalcolor = awt.Color.WHITE
        self.curColor = self.getBackgroundSelectionColor()
        #self.null = swing.JLabel()
    def getTreeCellRendererComponent( self, tree, value, sel, expanded, leaf, row, hasFocus ):
        #if value.__class__ == leoNodes.position and value.v != None :
        #if hasattr( value, 'v' ) and len( self.c.hoistStack ) != 0:
        #    hN = self.c.hoistStack[ -1 ][ 0 ].copy()
        #    if hN == value: row = 0
        #    elif not hN.isAncestorOf( value ):
        #         value = self.null
        #         return None
        #         #return self.null
        if hasattr( value, "v" ):# and value != self.null:
            icon = value.v.computeIcon()
            image = self.images[ icon ]
            self.setOpenIcon( image )
            self.setClosedIcon( image )
            self.setLeafIcon( image )
            #self.setSelectedIcon( image )
            cp = value.c.currentPosition()
            if cp == value:
                self.setBackgroundNonSelectionColor( self.curColor )
            else:
                self.setBackgroundNonSelectionColor( self.normalcolor )
        else:
            return self._rootComponent
        tcr = stree.DefaultTreeCellRenderer.getTreeCellRendererComponent( self, tree, value, sel, expanded, leaf, row, hasFocus )
        return tcr



</t>
<t tx="ekr.20070127142814.1007">@language java

import javax.swing.plaf.*;
import javax.swing.tree.*;
import javax.swing.text.*;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.EventObject;
import javax.swing.event.*;
import java.util.*;
import java.io.*;



public final class leoHeadlineTreeCellEditor extends KeyAdapter implements TreeCellEditor, DocumentListener{

    public final JTextField _jta;
    private final JLabel _jb;
    private final JPanel _bg;
    private final CommanderSpecification _cs;
    private final Color _ef;
    private final Color _eb;
    private final java.util.List&lt; CellEditorListener &gt; _listeners;
    private final Icon _icon;
    private final JLabel _left;
    private Font _font;
    JTree tree;
    Dimension startsize;
    

    
    public leoHeadlineTreeCellEditor( CommanderSpecification cs ,
                                      final Color edit_foreground,
                                      final Color edit_background, 
                                      Icon icon ){
    
        _cs = cs;
        _ef = edit_foreground;
        _eb = edit_background;
        _icon = icon;
        //SpringLayout sl = new SpringLayout();
        FlowLayout fl = new FlowLayout( FlowLayout.LEFT, 0, 0 );
        _bg = new JPanel( fl );
        _left = new JLabel();
        _bg.add( _left );
        //sl.putConstraint( sl.NORTH, _left, 0, sl.NORTH, _bg );
        //sl.putConstraint( sl.WEST, _left, 0, sl.WEST, _bg );        
        _jb =  new JLabel();
        if( _icon != null ){
        
         _jb.setIcon( _icon );
         _jb.setOpaque( false );
         _bg.setOpaque( false );
         
        }
        else
            _jb.setText( "E" );
        _jb.setToolTipText( "Configure The Headline" );
        _bg.add( _jb );
        //sl.putConstraint( sl.NORTH, _jb, 0, sl.NORTH, _bg );
        //sl.putConstraint( sl.WEST, _jb, 0, sl.EAST, _left );
        
        _jta = new JTextField2();
        _jta.addKeyListener( this );
        _jta.getDocument().addDocumentListener( this );
        _jb.addMouseListener( new HeadlineListener( _jta, cs ) );
        _bg.add( _jta );
        //sl.putConstraint( sl.NORTH, _jta, 0, sl.NORTH, _bg );
        //sl.putConstraint( sl.WEST, _jta, 0, sl.EAST, _jb );
        //sl.putConstraint( sl.SOUTH, _jb, 0, sl.SOUTH, _jta );
        //sl.putConstraint( sl.SOUTH, _bg, 0, sl.SOUTH, _jta );
        //sl.putConstraint( sl.EAST, _bg, 0, sl.EAST, _jta );
        _listeners = new Vector&lt; CellEditorListener &gt;();
    
    }

public final void requestFocusInWindow(){


    _jta.requestFocusInWindow();


}

public final void setFont( Font f ){


    _font = f;


}


public final void setFocusTraversalPolicy( final FocusTraversalPolicy ftp ){

    _jta.setFocusTraversalPolicy( ftp );


}


public final Component getTreeCellEditorComponent(final JTree tree,
                                     final Object value,
                                     final boolean isSelected,
                                     final boolean expanded,
                                     final boolean leaf,
                                     final int row){
                                     
            this.tree = tree;
            startsize = tree.getPreferredSize();    
            final PositionSpecification ps = _cs.currentPosition();
            //System.out.println( value );
            //System.out.println( ps );
            final Color foreground = ps.getForeground();
            final Color background = ps.getBackground();
            final int icon = ps.computeIconFromV();  
    
            Icon i = ps.getIcon();
            if( i == null )
                i = leoIconTreeRenderer._icons[ icon ];
            _left.setIcon( i );
            Font f;
            if( ( f = ps.getFont() ) != null )
                _jta.setFont( f );
            else     
                _jta.setFont( _font );         
            _jta.setText( value.toString() );
            //_jta.setMaximumSize( _jta.getPreferredSize() );
            //_jta.setMinimumSize( _jta.getPreferredSize() );
            _jta.setForeground( _ef );
            _jta.setBackground( _eb );
            if( foreground != null )
                _jta.setForeground( foreground );
            if( background != null ) 
                _jta.setBackground( background );
            
            //setBackgroundSize();
            //_bg.invalidate();
            final Runnable run = new Runnable(){
            
                public final void run(){ resetSize(); }
            
            
            };

            //_bg.setSize( _bg.getPreferredSize() );
            SwingUtilities.invokeLater( run );
            return _bg;                  
                                
                                     
                                     }


    @others
    



}


</t>
<t tx="ekr.20070127142814.1008">public final void addCellEditorListener( final CellEditorListener l){

    _listeners.add( l );

}</t>
<t tx="ekr.20070127142814.1009">public final void cancelCellEditing(){
    
    tree.setPreferredSize( null );
    final ChangeEvent ce = new ChangeEvent( this );
    for( final CellEditorListener cel: _listeners )
        cel.editingCanceled( ce );


}</t>
<t tx="ekr.20070127142814.1010">public final Object getCellEditorValue(){


    return _jta.getText();


}</t>
<t tx="ekr.20070127142814.1011">public final boolean isCellEditable( final EventObject event ){

    return true;


}</t>
<t tx="ekr.20070127142814.1012">public final void removeCellEditorListener( final CellEditorListener cel ){

    _listeners.remove( cel );


}</t>
<t tx="ekr.20070127142814.1013">public final boolean shouldSelectCell( final EventObject eo ){

    return true;


}</t>
<t tx="ekr.20070127142814.1014">public final boolean stopCellEditing(){

    tree.setPreferredSize( null );
    final ChangeEvent ce = new ChangeEvent( this );
    for( final CellEditorListener cel: _listeners )
        cel.editingStopped( ce );
    _cs.beginUpdate();
    _cs.endUpdate();
    return true;

}</t>
<t tx="ekr.20070127142814.1015">private final void setBackgroundSize(){
    
    final Dimension size = _jta.getPreferredSize();
    final Dimension lsize = _jb.getPreferredSize();
    size.width = size.width + lsize.width;
    //System.out.println( size );
    //System.out.println( "SIZE " + _jta.getSize() );
    _bg.setPreferredSize( size );
    _bg.setMinimumSize( size );

}</t>
<t tx="ekr.20070127142814.1016">public final  void keyPressed( final KeyEvent event ){

    final char k = event.getKeyChar();
    if( k == '\n' ){
    
        event.consume();
        stopCellEditing();
        return;
    
    
    }

    final JTextField source = (JTextField)event.getSource();
    Dimension size = source.getSize();
	Rectangle vrect1 = tree.getVisibleRect();
    int x = source.getX();
    Point dp = SwingUtilities.convertPoint( source, x, 0, tree );
    int totalw = dp.x + size.width;
    Dimension d= tree.getSize();
    ComponentUI ui = tree.getUI();
    Dimension uips = ui.getPreferredSize( tree );
    if( d.width &lt; totalw ){
        d.width = totalw;
        d.height = uips.height;
        tree.setPreferredSize( d );
        tree.treeDidChange();
        
    }
    else if( vrect1.width &gt; totalw ){
        
        if( tree.isPreferredSizeSet() ){
            tree.setPreferredSize( null );
            tree.treeDidChange();
        }
    
    }
    final DefaultCaret dc = (DefaultCaret)source.getCaret();
    final Point p = dc.getMagicCaretPosition();
    if( p != null ){
        
        final Point p2 = SwingUtilities.convertPoint( source, p, tree );
        final Rectangle r = new Rectangle( p2.x - 5, p2.y, (int)dc.getWidth() + 5, (int)dc.getHeight() );
        Rectangle vrect2 = tree.getVisibleRect();
        class Scroller implements Runnable{
        
            public void run(){

                tree.scrollRectToVisible( r );
            }
        
        }
        if( !vrect2.contains( r ) ){
            Runnable run = new Scroller();
            SwingUtilities.invokeLater( run );
        
        }
    }

}</t>
<t tx="ekr.20070127142814.1017">public String getHeadline(){

    return _jta.getText();


}</t>
<t tx="ekr.20070127142814.1018">public final void	changedUpdate( final DocumentEvent e){



}


public final void insertUpdate( final DocumentEvent e){

    resetSize();

}


public final void removeUpdate( final DocumentEvent e ){

    resetSize();

}


private final void resetSize(){

    //final Container parent = _bg;//_bg.getParent();
    //if( parent == null ) return;

    _bg.doLayout(); //essential call to calculate the new size, otherwise psize does not reflect the text change...
    final Dimension size = _bg.getPreferredSize();
    _bg.setSize( size );
    //size.width += _jb.getPreferredSize().width;
    //final Insets i = _jta.getInsets();
    //size.width += i.right + i.left + 5;
    //_bg.invalidate();
    //parent.setSize( size );
    //parent.invalidate(); //mark it as invalid...
    //parent.getParent().validate();// so the JTree will recompute it at validation time...
    _bg.revalidate();

}  </t>
<t tx="ekr.20070127142814.1019">public static final class HeadlineListener extends MouseAdapter{

    final JTextComponent _jtc;
    final CommanderSpecification _cs;
    public HeadlineListener( final JTextComponent jtc, CommanderSpecification cs ){
        super();
        _jtc = jtc;
        _cs = cs;
        
    }

    public void mousePressed( final MouseEvent me ){
    
        if( me.getButton() == me.BUTTON1 ){
        
            final HeadlineManipulator hm = new HeadlineManipulator( _cs, _jtc );
        
        
        }
    
    
    
    }

    @others


}
</t>
<t tx="ekr.20070127142814.1020">    
    public static class JPanel2 extends JPanel{
        
        public JPanel2( LayoutManager2 lm2 ){
        
            super( lm2 );
        
        }
        
    
        public void paintChildren2( Graphics g ){
        
            Graphics2D g2 = (Graphics2D)g;
            AffineTransform transform = g2.getTransform();
            if( transform.getScaleX() != 2.0f ) g2.scale( 2.0, 2.0 );
            super.paintChildren( g2 );
            g2.setTransform( transform );
        
        
        
        }
        

        
        public void paintComponent2( Graphics g ){
            //Thread.currentThread().dumpStack();
            Graphics2D g2 = (Graphics2D)g;
            AffineTransform transform = g2.getTransform();
            if( transform.getScaleX() != 2.0f ) g2.scale( 2.0, 2.0 );
            super.paintComponent( g2 );
            g2.setTransform( transform );
        
        
        
        }
    
    
    }
        
    
    public static class JTextField2 extends JTextField{
        
        
        protected Graphics getComponentGraphics2( Graphics g ){
        
            Graphics2D g2 = (Graphics2D)super.getComponentGraphics( g );
            Rectangle r = g2.getClip().getBounds();
            //g2.translate( r.x * 2, r.y * 2 );
            g2.scale( 2.0f, 2.0f );
            //System.out.println( "GCG!" );
            return g2;
        
        }    
      
        public void paintImmediately2( Rectangle r ){
        
            System.out.println( "PM NOW!!!" ); 
            RepaintManager2 rm2 = (RepaintManager2)RepaintManager.currentManager( this );
            rm2.scale();
            super.paintImmediately( r );
        
        }
        
    
        public void paintImmediately2( int x, int y, int w, int h ){
            
            if( true ) return;
            System.out.println( "PM NOW2!!!!" );  
            RepaintManager rm2 = (RepaintManager2)RepaintManager.currentManager( this );
            //x = x * 2;
            //y = y * 2;
            w = w * 2;
            h = h * 2;
            Component jc = this;
            while( !(jc.getParent() instanceof Window) ){
            
                jc = jc.getParent();
            
            }
            System.out.println( jc );
            Image i = rm2.getVolatileOffscreenBuffer( jc, w, h);
            Graphics2D g = (Graphics2D)i.getGraphics();
            g.scale( 2.0, 2.0 );
            paint( g );
            Graphics g2 = getGraphics();
            g2.drawImage( i, x * 2, y * 2, null );
            //rm2.scale();       
            //super.paintImmediately( x,y,w,h );
        
        }

        public void paintComponent2( Graphics g ){
        
            //System.out.println( getParent().getParent() );
            Graphics2D g2 = (Graphics2D)g;
            System.out.println( "JTF!!! " + g2.getTransform().getScaleX() );
            //g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
            //g2.setRenderingHint( RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON );
            AffineTransform t = g2.getTransform();
            if( t.getScaleX() != 2.0 )
                g2.scale( 2.0, 2.0 );
            super.paintComponent( g2  );
            g2.setTransform( t );
            Thread.currentThread().dumpStack();
        
        }
    
    
    }    </t>
<t tx="ekr.20070127142814.1021">public final static class HeadlineManipulator{

    final CommanderSpecification _cs;
    final PositionSpecification _ps;
    final JFrame _top;
    final JTabbedPane _jtp;
    final JTextComponent _jtc;
    byte[] _data;
    
    public HeadlineManipulator( final CommanderSpecification cs, final JTextComponent jtc ){
    
        super();
        _jtc = jtc;
        _cs = cs;
        _ps = _cs.currentPosition();
        _top = new JFrame();
        _jtp = new JTabbedPane();
        _top.add( _jtp );
        _top.setDefaultCloseOperation( WindowConstants.DISPOSE_ON_CLOSE );
        _top.setTitle( "Configure Headline: " + _ps );
        addForeground();
        addBackground();
        addFont();
        addImage();
        final AbstractAction aa = new AbstractAction( "Close" ){
        
            public final void actionPerformed( final ActionEvent ae ){
            
                _top.setVisible( false );
                _top.dispose();
                _jtc.requestFocusInWindow();
            
            }
        
        
        };
        final JButton close = new JButton( aa );
        JPanel bottom = new JPanel();
        bottom.add( close );
        _top.add( bottom, BorderLayout.SOUTH );
        
        _top.pack();
        final Dimension psize = _top.getPreferredSize();
        final Dimension ssize = Toolkit.getDefaultToolkit().getScreenSize();
        int h_x = ssize.width/2;
        int h_y = ssize.height/2;
        h_x = h_x - psize.width/2;
        h_y = h_y - psize.height/2;
        _top.setLocation( h_x, h_y );
        _top.setVisible( true );
    
    
    }

    @others






}



</t>
<t tx="ekr.20070127142814.1022">private final void addForeground(){

    final JPanel panel = new JPanel( new BorderLayout() );
    final JColorChooser _foreground = new JColorChooser( _jtc.getForeground() );
    panel.add( _foreground, BorderLayout.CENTER );
    final JPanel panel2 = new JPanel( new FlowLayout() );
    panel.add( panel2, BorderLayout.SOUTH );
    final AbstractAction aa = new AbstractAction( "Set Foreground Color" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setForeground( _foreground.getColor() );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        }   
    
    };
    final JButton set_color = new JButton( aa );
    panel2.add( set_color );
    final AbstractAction aa2 = new AbstractAction( "Clear Foreground Color" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setForeground( null );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        }
    
    
    };
    final JButton clear_foreground = new JButton( aa2 );
    panel2.add( clear_foreground );
    
    
    _jtp.addTab( "Foreground", panel );
    

}</t>
<t tx="ekr.20070127142814.1023">private final void addBackground(){

    final JPanel panel = new JPanel( new BorderLayout() );
    final JColorChooser _background = new JColorChooser( _jtc.getForeground() );
    _jtp.addTab( "Background", _background );
    panel.add( _background, BorderLayout.CENTER );
    final JPanel panel2 = new JPanel( new FlowLayout() );
    panel.add( panel2, BorderLayout.SOUTH );
    final AbstractAction aa = new AbstractAction( "Set Background Color" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setBackground( _background.getColor() );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        
        }   
    
    };
    final JButton set_color = new JButton( aa );
    panel2.add( set_color );
    final AbstractAction aa2 = new AbstractAction( "Clear Background Color" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setBackground( null );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        }
    
    
    };
    final JButton clear_foreground = new JButton( aa2 );
    panel2.add( clear_foreground );
    
    
    _jtp.addTab( "Background", panel );

}</t>
<t tx="ekr.20070127142814.1024">private final void addFont(){

    final SpringLayout sl = new SpringLayout();
    final JPanel fonts = new JPanel( sl );
    _jtp.addTab( "Font", fonts );
    final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
    final String[] name = ge.getAvailableFontFamilyNames();
    final Object[] names = new Object[ name.length ];
    System.arraycopy( name, 0, names, 0, name.length );
            
    final Font cfont = _ps.getFont();
    final JList jl = new JList( names );
    jl.setSelectionMode( ListSelectionModel.SINGLE_SELECTION );
    if( cfont != null )
        jl.setSelectedValue( cfont.getName() , true );
    else
        jl.setSelectedIndex( 0 );
    final JScrollPane jsp  = new JScrollPane( jl );
    final Border b = jsp.getBorder();
    final TitledBorder tb = new TitledBorder( b );
    tb.setTitle( "Fonts" );
    jsp.setBorder( tb );
    fonts.add( jsp );
    sl.putConstraint( sl.NORTH, jsp, 5, sl.NORTH, fonts );
    sl.putConstraint( sl.WEST, jsp, 5, sl.WEST, fonts );
    sl.putConstraint( sl.EAST, fonts, 5, sl.EAST, jsp );
            
            
    final KeyAdapter ka = new KeyAdapter(){        
            
        public void keyPressed( final KeyEvent event ){
                
            final char c = event.getKeyChar();
            if( !Character.isDigit( c ) ) event.consume();    
                
        }
                
        public final void keyReleased( final KeyEvent event ){
                
            final char c = event.getKeyChar();
            if( !Character.isDigit( c ) ) event.consume();     
                
        }
                
        public final void keyTyped( final KeyEvent event ){
                
            final char c = event.getKeyChar();
            if( !Character.isDigit( c ) ) event.consume();
                     
        }
            
            
    };
    final JSpinner size = new JSpinner( new SpinnerNumberModel( 0, 0, Integer.MAX_VALUE, 1 ) );
    JSpinner.NumberEditor ne = new JSpinner.NumberEditor( size );
    size.setEditor( ne );
    if( cfont != null ) size.setValue( cfont.getSize() );
    Border b2 = size.getBorder();
    TitledBorder tb2 = new TitledBorder( b2 );
    tb2.setTitle( "Size" );
    size.setBorder( tb2 );
    ne.getTextField().addKeyListener( ka );
    size.setMaximumSize( size.getPreferredSize() );
    fonts.add( size );
    sl.putConstraint( sl.NORTH, size, 5, sl.SOUTH, jsp );
    
    JPanel buttons2 = new JPanel( new GridLayout( 2, 2 ) );
    final JCheckBox bold = new JCheckBox( "Bold" );
    if( _ps.getBold() ) bold.setSelected( true );
    buttons2.add( bold );
    final JCheckBox italic = new JCheckBox( "Italic" );
    if( _ps.getItalic() ) italic.setSelected( true );
    buttons2.add( italic );
    final JCheckBox underline = new JCheckBox( "underline" );
    if( _ps.getUnderline() ) underline.setSelected( true );
    buttons2.add( underline );
    final JCheckBox strikethrough = new JCheckBox( "strikethrough" );
    if( _ps.getStrikeThrough() ) strikethrough.setSelected( true );
    buttons2.add( strikethrough );
    fonts.add( buttons2 );
    sl.putConstraint( sl.NORTH, buttons2, 5, sl.SOUTH, jsp );
    sl.putConstraint( sl.WEST, buttons2, 5, sl.EAST, size );
    
         
    String characters = "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ1234567890";
    final JTextField preview = new JTextField( characters );
    preview.setBackground( Color.WHITE );
    preview.setForeground( Color.BLACK );
    JScrollPane presp = new JScrollPane( preview );
    Border b3 = presp.getBorder();
    TitledBorder tb3 = new TitledBorder( b3 );
    tb3.setTitle( "Font preview" );
    presp.setBorder( tb3 );
    fonts.add( presp );
    sl.putConstraint( sl.NORTH, presp, 5, sl.SOUTH, size );
    sl.putConstraint( sl.EAST, presp, 5, sl.EAST, fonts );
    sl.putConstraint( sl.WEST, presp, 5, sl.WEST, fonts );
    final ListSelectionListener lsl = new ListSelectionListener(){        
            
        public void valueChanged( final ListSelectionEvent lse ){
                
            String family = (String)jl.getSelectedValue();
            int sz = (Integer)size.getValue();
            Font f = Font.decode( family + "-" + sz );
            preview.setFont( f );
                
                
        }
            
            
    };
    ChangeListener cl = new ChangeListener(){ 
    
        public void stateChanged( ChangeEvent ce ){ 
                lsl.valueChanged( null ); 
                
                }
    };
    jl.addListSelectionListener( lsl );
    size.addChangeListener( cl );
    
    JPanel buttons = new JPanel( new FlowLayout() );     
    final AbstractAction aa = new AbstractAction( "Set Font" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setUnderline( underline.isSelected() );
            _ps.setStrikeThrough( strikethrough.isSelected() );
            _ps.setItalic( italic.isSelected() );
            _ps.setBold( bold.isSelected() );
            String font = (String )jl.getSelectedValue();
            int sz = (Integer)size.getValue();
            final Font f = Font.decode( font + "-" + sz );
            _ps.setFont( f );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        }
    
    
    };
    JButton set_font = new JButton( aa );
    buttons.add( set_font );
    
    final AbstractAction aa2 = new AbstractAction( "Clear Font" ){
    
        public final void actionPerformed( final ActionEvent ae ){
        
            _ps.setBold( false );
            _ps.setItalic( false );
            _ps.setStrikeThrough( false );
            _ps.setUnderline( false );
            _ps.setFont( null );
            _cs.beginUpdate();
            _cs.endUpdate();
        
        }
    
    
    
    };
    
    JButton clear_font = new JButton( aa2 );
    buttons.add( clear_font );
    
    fonts.add( buttons );
    sl.putConstraint( sl.NORTH, buttons, 5, sl.SOUTH, presp );
    sl.putConstraint( sl.SOUTH, fonts, 5, sl.SOUTH, buttons );
             

}
</t>
<t tx="ekr.20070127142814.1025">private final void addImage(){

    final JPanel image = new JPanel();
    _jtp.addTab( "Image", image );
    final SpringLayout sl2 = new SpringLayout();
    image.setLayout( sl2 );
    final JTextField jtf3 = new JTextField( 30 );
    final Border b4 = jtf3.getBorder();
    final TitledBorder tb4 = new TitledBorder( b4 );
    tb4.setTitle( "Path to Image:" );
    jtf3.setBorder( tb4 );
    final JLabel _image = new JLabel();
    jtf3.setMaximumSize( jtf3.getPreferredSize() );
            
    image.add( jtf3 );
    sl2.putConstraint( sl2.NORTH, jtf3, 5, sl2.NORTH, image );
    sl2.putConstraint( sl2.WEST, jtf3, 5, sl2.WEST, image );        
    final AbstractAction aa3 = new AbstractAction( "Browse" ){
            
        public final void actionPerformed( final ActionEvent ae ){
                
            final JFileChooser jfc = new JFileChooser();
            final int result = jfc.showOpenDialog( _top.getContentPane() );
            if( result == jfc.APPROVE_OPTION ){
                    
                try{
                        
                    final File path = jfc.getSelectedFile();
                    final String abpath = path.getAbsolutePath();
                    jtf3.setText( abpath );
                    final FileInputStream fis = new FileInputStream( path );
                    long len = path.length();
                    _data = new byte[ (int)len ];
                    int start = 0;
                    while( len != 0 ){
                            
                        final int amount = fis.read( _data, start, (int)(len - start) );
                        start += amount;
                        len -= amount;
                        
                        }
                        
                        
                    //ImageIcon ii = new ImageIcon( data );
                    //data = data;
                    _image.setIcon( new ImageIcon( _data ) );

                }
                catch( final IOException io ){}
                    
                    
                    }
                }            
            
    };
            final JButton jb3 = new JButton( aa3 );
            image.add( jb3 );
            sl2.putConstraint( sl2.NORTH, jb3, 5, sl2.NORTH, image );
            sl2.putConstraint( sl2.WEST, jb3, 0, sl2.EAST, jtf3 );
            sl2.putConstraint( sl2.EAST, image, 5, sl2.EAST, jb3 );
            
            final JPanel _iholder = new JPanel();
            _iholder.add( _image );
            final JScrollPane jsp3 = new JScrollPane( _iholder );
            final Border b5 = jsp3.getBorder();
            final TitledBorder tb5 = new TitledBorder( b5 );
            tb5.setTitle( "Image Preview" );
            jsp3.setBorder( tb5 );
            image.add( jsp3 );
            sl2.putConstraint( sl2.NORTH, jsp3 , 5, sl2.SOUTH, jtf3 );
            sl2.putConstraint( sl2.EAST, jsp3, 5, sl2.EAST, image );
            sl2.putConstraint( sl2.WEST, jsp3, 5, sl2.WEST, image );
            
            final AbstractAction a4 = new AbstractAction( "Add Image" ){
            
                public final void actionPerformed( final ActionEvent ae ){
                
                    //ImageIcon i = (ImageIcon)_image.getIcon();
                    if( _data != null ){
                        
                           _ps.setImage( _data );    
                           _cs.beginUpdate();
                           _cs.endUpdate();
                        
                        }    
                
                
                }
            
            
            };
            final JButton add_image = new JButton( a4 );
            image.add( add_image );
            sl2.putConstraint( sl2.NORTH, add_image,5 , sl2.SOUTH, jsp3 );
            sl2.putConstraint( sl2.SOUTH, image, 5, sl2.SOUTH, add_image );
            final AbstractAction a5 = new AbstractAction( "Remove Current Image" ){
            
                public final void actionPerformed( final ActionEvent ae ){
                
                    _ps.setImage( null );
                    _cs.beginUpdate();
                    _cs.endUpdate();
                
                }
            
            
            
            };
    final JButton rci = new JButton( a5 );
    image.add( rci );
    sl2.putConstraint( sl2.NORTH, rci ,5 , sl2.SOUTH, jsp3 );
    sl2.putConstraint( sl2.WEST, rci, 5, sl2.EAST, add_image ); 
            




}</t>
<t tx="ekr.20070127142814.1026">import leoGlobals as g
import os
import org.xml.sax as sax
import javax.xml.parsers as jparse
import java
import java.util as util
import java.util.regex as jregex
import java.awt as awt
import java.io as io
import javax.swing.text as stext
import copy


leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ] 


class __LanguageBundle:
    def __init__( self ):
        for z in dir( LanguageManager ):
            if not callable( getattr( LanguageManager, z ) ):
                setattr( self , z,  getattr( LanguageManager, z ) )
        


language_in_effect = {}
class LanguageManager:
    
    initialised = 0
    languages_in_effect = {}
    #language_data = {}
    comment_cache = {}
    indenters = {}
    #_underline = None
    _undefinedSectionNameColor = None
    _sectionNameColor = None
    _stringColor = None
    _commentColor = None
    _docColor = None
    _invisibleBlock = None
    _invisibleDot = None
    _which_invisible = None
    _punctuationColor = None
    _drawrectangle = None
    _rectanglecolor = None
    _numericcolor = None
    
    def getLanguageBundle( clazz, c ):
        
        if not clazz.initialised:
            clazz.scanLanguageFiles( c )
            clazz.initialised = 1
                    
        return __LanguageBundle()
        
    getLanguageBundle = classmethod( getLanguageBundle )
    
    def scanLanguageFiles( clazz, c ):
        
        from leoSwingFrame import getColorInstance
        createAttributeSet = clazz.createAttributeSet
        config = g.app.config
        underline = config.getBool( c, "underline_undefined_section_names" )
        color = config.getColor( c, "undefined_section_name_color" )
        clazz._undefinedSectionNameColor = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        font = config.getFontFromParams( c, "undsectionnamefont_text_font_family", "undsectionnamefont_text_font_size", None, "undsectionnamefont_text_font_weight" )
        LanguageManager.setFont( clazz._undefinedSectionNameColor, font )
        if underline:
            stext.StyleConstants.setUnderline( clazz._undefinedSectionNameColor, True )
        color = config.getColor( c, "section_name_color" )
        clazz._sectionNameColor  = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        font = config.getFontFromParams( c, "sectionnamefont_text_font_family", "sectionnamefont_text_font_size", None, "sectionnamefont_text_font_weight" )
        LanguageManager.setFont( clazz._sectionNameColor, font )
        color = config.getColor( c, "string_color" )
        clazz._stringColor = createAttributeSet( getColorInstance( color, awt.Color.GREEN ) )
        font = config.getFontFromParams( c, "stringfont_text_font_family", "stringfont_text_font_size", None, "stringfont_text_font_weight" )
        LanguageManager.setFont( clazz._stringColor, font )
        color = config.getColor( c, "comment_color" )
        clazz._commentColor = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        font = config.getFontFromParams( c, "commentfont_text_font_family", "commentfont_text_font_size", None, "commentfont_text_font_weight" )
        LanguageManager.setFont( clazz._commentColor, font )
        color = config.getColor( c, "doc_part_color" )
        clazz._docColor = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        font = config.getFontFromParams( c, "docpartfont_text_font_family", "docpartfont_text_font_size", None, "docpartfont_text_font_weight" )
        LanguageManager.setFont( clazz._docColor, font )
        color = config.getColor( c, "invisibles_block_color" )
        clazz._invisibleBlock =  getColorInstance( color, awt.Color.YELLOW ) 
        color = config.getColor( c, "invisibles_dot_color" )
        clazz._invisibleDot =  getColorInstance( color, awt.Color.RED ) 
        clazz._which_invisible = config.getString( c, "invisibles_type" );
        clazz._which_invisible = g.choose( clazz._which_invisible == 'block', 1, 0 )
        color = config.getColor( c, "punctuation_color" )
        clazz._punctuationColor = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        clazz._drawrectangle = config.getBool( c, 'draw_rectangle' )
        color = config.getColor( c, "rectangle_color" )
        clazz._rectanglecolor = getColorInstance( color, awt.Color.YELLOW ) 
        #self._stringColor = awt.Color.GREEN
        color = config.getColor( c, "folded_foreground_color" )
        clazz._ffColor = getColorInstance( color, awt.Color.RED )
        color = config.getColor( c, "folded_background_color" )
        clazz._fbColor = getColorInstance( color, awt.Color.YELLOW )
        color = config.getColor( c, "footnode_background_color" )
        clazz._fnbgColor = getColorInstance( color, awt.Color.GRAY )
        color = config.getColor( c, "footnode_foreground_color" )
        clazz._fnfgColor = getColorInstance( color, awt.Color.BLACK )
        color = config.getColor( c, "numeric_color" )
        clazz._numericcolor = createAttributeSet( getColorInstance( color, awt.Color.RED ) )
        font = config.getFontFromParams( c, "numeric_text_font_family", "numeric_text_font_size", None, "numeric_text_font_weight" )
        LanguageManager.setFont( clazz._numericcolor, font )        
        clazz.plain_keywords = java.util.HashMap()
        clazz.plain_keywords2 = []
        return
        
        color = config.getColor( c, "directive_color" )
        drkgrn = java.lang.Integer.decode( "#299C39" )
        dir_color = createAttributeSet( getColorInstance( color, awt.Color( drkgrn ) ) )
        font = config.getFontFromParams( c, "directivefont_text_font_family", "directivefont_text_font_size", None, "directivefont_text_font_weight" )
        LanguageManager.setFont( dir_color, font )

            
        color = config.getColor( c, "keyword_color" )
        kw_color = createAttributeSet( getColorInstance( color, awt.Color.BLUE ) )
        
        color = config.getColor( c, "section_name_brackets_color" )
        snb_color = createAttributeSet( getColorInstance( color, awt.Color.BLUE ) )

        #font = config.getFontFromParams( c, "body_text_font_family", "body_text_font_size", None, "body_text_font_weight")
        color1 = config.getColor( c, "keyword_color1" )
        kw_color1 = createAttributeSet( getColorInstance( color1, awt.Color.BLUE ) )
        font = config.getFontFromParams( c, "keywordfont1_text_font_family", "keywordfont1_text_font_size", None, "keywordfont1_text_font_weight" )
        LanguageManager.setFont( kw_color1, font )
        color2 = config.getColor( c, "keyword_color2" )
        kw_color2 = createAttributeSet( getColorInstance( color2, awt.Color.ORANGE ) )
        font = config.getFontFromParams( c, "keyword2_text_font_family", "keyword2_text_font_size", None, "keyword2_text_font_weight" )
        LanguageManager.setFont( kw_color2, font )
        color3 = config.getColor( c, "keyword_color3" )
        kw_color3 = createAttributeSet( getColorInstance( color3, awt.Color.GREEN ) )
        font = config.getFontFromParams( c, "keyword3_text_font_family", "keyword3_text_font_size", None, "keyword3_text_font_weight" )
        LanguageManager.setFont( kw_color3, font )
        literal2 = config.getColor( c, "literal_color2" )
        literal_color2 = createAttributeSet( getColorInstance( literal2, awt.Color.YELLOW ) )
        font = config.getFontFromParams( c, "literal2_text_font_family", "literal2_text_font_size", None, "literal2_text_font_weight" )
        LanguageManager.setFont( literal_color2, font )
        function = config.getColor( c, "function_color" )
        function_color = createAttributeSet( getColorInstance( function, awt.Color.YELLOW ) )
        font = config.getFontFromParams( c, "function_text_font_family", "function_text_font_size", None, "function_text_font_weight" )
        LanguageManager.setFont( function_color, font )
        convention = config.getColor( c, "convention_color" )
        convention_color = createAttributeSet( getColorInstance( convention, awt.Color.CYAN ) )
        font = config.getFontFromParams( c, "convention_text_font_family", "convention_text_font_size", None, "convention_text_font_weight" )
        LanguageManager.setFont( convention_color, font )
        operator = config.getColor( c, "operator_color" )
        operator_color = createAttributeSet( getColorInstance( operator, awt.Color.BLACK ) )
        font = config.getFontFromParams( c, "operator_text_font_family", "operator_text_font_size", None, "operator_text_font_weight" )
        LanguageManager.setFont( operator_color, font )
        return
        path = os.path.join(g.app.loadDir,'../','modes')
        path = os.path.normpath(path)
        dbf = jparse.DocumentBuilderFactory.newInstance()
        dbf.setIgnoringComments( 1 )
        dbf.setValidating( 0 )
        #print dbf.isValidating()
        #dbf.setValidating( 0 )
        #print dbf.getSchema()
        #print dbf.isNamespaceAware()
        #print dbf.isExpandEntityReferences()
        #print dbf.isXIncludeAware()
        #dbf.setExpandEntityReferences( 0 )
        #java.lang.Thread.currentThread().sleep( 2000 )
        db = dbf.newDocumentBuilder()
        #print db.isValidating()
        #java.lang.Thread.currentThread().sleep( 2000 )
    
        
        m_directory = java.io.File( path )
        files = m_directory.listFiles()
        for z in files:
            if str(z).endswith( ".xml" ):
                try:
                    doc = db.parse( z )
                except java.lang.Exception, x:
                    print x
                    continue
                
                lname = z.getName()[ : -4 ]
                de = doc.getDocumentElement()
                cn = de.getChildNodes()
                kw1 = de.getElementsByTagName( "KEYWORD1" )
                kw2 = de.getElementsByTagName( "KEYWORD2" )
                kw3 = de.getElementsByTagName( "KEYWORD3" )
                func = de.getElementsByTagName( "FUNCTION" )
                lit = de.getElementsByTagName( "LITERAL2" )
                conv = de.getElementsByTagName( "CONVENTION" )
                seq = de.getElementsByTagName( "SEQ" )
                props = de.getElementsByTagName( "PROPERTY" )
                hm = util.HashMap()
                #clazz.language_data[ lname ] = hm
                
                lineComment = startComment = endComment = None
                for prop in xrange( props.length ):
                    property = props.item( prop )
                    name = property.getAttribute( "NAME" )
                    if name == "lineComment":
                        lineComment = property.getAttribute( "VALUE" )
                    elif name == "commentStart":
                        startComment = property.getAttribute( "VALUE" )
                    elif name == "commentEnd":
                        endComment = property.getAttribute( "VALUE" )
                    elif name == "indentNextLine":
                        value = property.getAttribute( "VALUE" )
                        pat = jregex.Pattern.compile( value )
                        clazz.indenters[ lname ] = pat.matcher( "" )
                clazz.comment_cache[ lname ] = [ lineComment, startComment, endComment ]
                
                #operators = util.HashMap()
                for y in xrange( seq.length ):
                    item = seq.item( y )
                    if item.getAttribute( "TYPE" ) == "OPERATOR":
                        #print item.getTextContent()
                        hm.put( item.getTextContent(), operator_color )
                #hm.put( "__operators", operators )
                        
                sname = z.getName()[ : -4 ] + "_keywords"
                sname2 = sname + "2"
                s2_list = []
                setattr( clazz, sname, hm )
                setattr( clazz, sname2, s2_list )
                color_data = ( ( kw1, kw_color1 ), (kw2, kw_color2 ), 
                               ( kw3, kw_color3 ), ( func, function_color ), 
                               ( lit, literal_color2 ), ( conv, convention_color ) )
                for y in color_data:
                    for yl in xrange( y[ 0 ].length ):
                        item = y[ 0 ].item( yl )
                        hm.put( item.getTextContent(), y[ 1 ] )
                        s2_list.append( item.getTextContent() )
                         
                for y in leoKeywords:
                    hm.put( y, dir_color )
                    
                hm.put( '&lt;&lt;', snb_color )
                hm.put( '&gt;&gt;', snb_color )
                
    scanLanguageFiles = classmethod( scanLanguageFiles )
    
    &lt;&lt;loadLanguage&gt;&gt;
    
    def createAttributeSet( color ):
        sas = stext.SimpleAttributeSet()
        stext.StyleConstants.setForeground( sas, color )
        return sas
    
    createAttributeSet = staticmethod( createAttributeSet )
    
    def setFont( sas, font ):
        
        stext.StyleConstants.setFontFamily( sas, font.getFamily() )
        stext.StyleConstants.setFontSize( sas, font.getSize() )
        if font.isBold():
            stext.StyleConstants.setBold( sas, True )
        if font.isItalic():
            stext.StyleConstants.setItalic( sas, True )
    
    setFont = staticmethod( setFont )
    
    def setLanguageInEffect( c, language ):
        language_in_effect[ c ] = language
        
    setLanguageInEffect = staticmethod( setLanguageInEffect )
    
    def getLanguageInEffect( c ):
        if language_in_effect.has_key( c ):
            return language_in_effect[ c ]
        return None
        
    getLanguageInEffect = staticmethod( getLanguageInEffect )
    
                  

</t>
<t tx="ekr.20070127142814.1027">def loadLanguage( clazz, c, language ):
    
    if hasattr( clazz, language ):
        return getattr( clazz, language )
    from leoSwingFrame import getColorInstance
    config = g.app.config
    createAttributeSet = clazz.createAttributeSet
    try:
        hm = java.util.HashMap()
        #settattr( clazz, language, hm )
        color = config.getColor( c, "directive_color" )
        drkgrn = java.lang.Integer.decode( "#299C39" )
        dir_color = createAttributeSet( getColorInstance( color, awt.Color( drkgrn ) ) )
        font = config.getFontFromParams( c, "directivefont_text_font_family", "directivefont_text_font_size", None, "directivefont_text_font_weight" )
        LanguageManager.setFont( dir_color, font )
            
        color = config.getColor( c, "keyword_color" )
        kw_color = createAttributeSet( getColorInstance( color, awt.Color.BLUE ) )
        
        color = config.getColor( c, "section_name_brackets_color" )
        snb_color = createAttributeSet( getColorInstance( color, awt.Color.BLUE ) )

        #font = config.getFontFromParams( c, "body_text_font_family", "body_text_font_size", None, "body_text_font_weight")
        color1 = config.getColor( c, "keyword_color1" )
        kw_color1 = createAttributeSet( getColorInstance( color1, awt.Color.BLUE ) )
        font = config.getFontFromParams( c, "keywordfont1_text_font_family", "keywordfont1_text_font_size", None, "keywordfont1_text_font_weight" )
        LanguageManager.setFont( kw_color1, font )
        color2 = config.getColor( c, "keyword_color2" )
        kw_color2 = createAttributeSet( getColorInstance( color2, awt.Color.ORANGE ) )
        font = config.getFontFromParams( c, "keyword2_text_font_family", "keyword2_text_font_size", None, "keyword2_text_font_weight" )
        LanguageManager.setFont( kw_color2, font )
        color3 = config.getColor( c, "keyword_color3" )
        kw_color3 = createAttributeSet( getColorInstance( color3, awt.Color.GREEN ) )
        font = config.getFontFromParams( c, "keyword3_text_font_family", "keyword3_text_font_size", None, "keyword3_text_font_weight" )
        LanguageManager.setFont( kw_color3, font )
        literal2 = config.getColor( c, "literal_color2" )
        literal_color2 = createAttributeSet( getColorInstance( literal2, awt.Color.YELLOW ) )
        font = config.getFontFromParams( c, "literal2_text_font_family", "literal2_text_font_size", None, "literal2_text_font_weight" )
        LanguageManager.setFont( literal_color2, font )
        function = config.getColor( c, "function_color" )
        function_color = createAttributeSet( getColorInstance( function, awt.Color.YELLOW ) )
        font = config.getFontFromParams( c, "function_text_font_family", "function_text_font_size", None, "function_text_font_weight" )
        LanguageManager.setFont( function_color, font )
        convention = config.getColor( c, "convention_color" )
        convention_color = createAttributeSet( getColorInstance( convention, awt.Color.CYAN ) )
        font = config.getFontFromParams( c, "convention_text_font_family", "convention_text_font_size", None, "convention_text_font_weight" )
        LanguageManager.setFont( convention_color, font )
        operator = config.getColor( c, "operator_color" )
        operator_color = createAttributeSet( getColorInstance( operator, awt.Color.BLACK ) )
        font = config.getFontFromParams( c, "operator_text_font_family", "operator_text_font_size", None, "operator_text_font_weight" )
        LanguageManager.setFont( operator_color, font )
    
        for y in leoKeywords:
            hm.put( y, dir_color )                    
        hm.put( '&lt;&lt;', snb_color )
        hm.put( '&gt;&gt;', snb_color )

    
    
        path = os.path.join(g.app.loadDir,'../','modes')
        path = os.path.normpath(path)
        dbf = jparse.DocumentBuilderFactory.newInstance()
        dbf.setIgnoringComments( 1 )
        dbf.setValidating( 0 )    
        m_directory = java.io.File( path )
        lfile = java.io.File( m_directory, "%s.xml" % language )
        if not lfile.exists(): return hm
        try:
            db = dbf.newDocumentBuilder()
            doc = db.parse( lfile )
        except java.lang.Exception, x:
            print x
            return hm
              
        lname = language
        de = doc.getDocumentElement()
        cn = de.getChildNodes()
        kw1 = de.getElementsByTagName( "KEYWORD1" )
        kw2 = de.getElementsByTagName( "KEYWORD2" )
        kw3 = de.getElementsByTagName( "KEYWORD3" )
        func = de.getElementsByTagName( "FUNCTION" )
        lit = de.getElementsByTagName( "LITERAL2" )
        conv = de.getElementsByTagName( "CONVENTION" )
        seq = de.getElementsByTagName( "SEQ" )
        props = de.getElementsByTagName( "PROPERTY" )
        #clazz.language_data[ lname ] = hm 
        ltokens = []
        for lt in ( kw1, kw2, kw3, func ):
            for n in xrange( lt.length ):
                item = lt.item( n )
                ltokens.append( item.getTextContent() )
        setattr( clazz, "%s_tokens" % lname, ltokens )          
        lineComment = startComment = endComment = None
        for prop in xrange( props.length ):
            property = props.item( prop )
            name = property.getAttribute( "NAME" )
            if name == "lineComment":
                lineComment = property.getAttribute( "VALUE" )
            elif name == "commentStart":
                startComment = property.getAttribute( "VALUE" )
            elif name == "commentEnd":
                endComment = property.getAttribute( "VALUE" )
            elif name == "indentNextLine":
                value = property.getAttribute( "VALUE" )
                pat = jregex.Pattern.compile( value )
                clazz.indenters[ lname ] = pat.matcher( "" )
        
        clazz.comment_cache[ lname ] = [ lineComment, startComment, endComment ]
                
        #operators = util.HashMap()
        for y in xrange( seq.length ):
            item = seq.item( y )
            if item.getAttribute( "TYPE" ) == "OPERATOR":
                hm.put( item.getTextContent(), operator_color )                  
        sname = language + "_keywords"
        sname2 = sname + "2"
        s2_list = []
        color_data = ( ( kw1, kw_color1 ), (kw2, kw_color2 ), 
                    ( kw3, kw_color3 ), ( func, function_color ), 
                    ( lit, literal_color2 ), ( conv, convention_color ) )
        for y in color_data:
            for yl in xrange( y[ 0 ].length ):
                item = y[ 0 ].item( yl )
                hm.put( item.getTextContent(), y[ 1 ] )
                s2_list.append( item.getTextContent() )
                         
    finally:
        setattr( clazz, language, hm )
        return hm


loadLanguage = classmethod( loadLanguage )
</t>
<t tx="ekr.20070127142814.1029">import javax.swing as swing
import java


class RotatableJLabel( swing.JLabel ):
    
    def __init__( self, t ):
        self._rotate = False
        swing.JLabel.__init__( self, t )
    
    
    def rotateIt( self ):
        if self._rotate: self.rotate = False
        else:
            self._rotate = True            
    
    def getPreferredSize( self ):
        
        psize = self.super__getPreferredSize()
        if self._rotate:
            w = psize.width
            h = psize.height
            psize.height = w
            psize.width= h
        return psize
    
    def paintComponent( self, g ):
        
        transform = g.getTransform()
        if self._rotate:
            radians = java.lang.Math.toRadians( 90.0 )
            print radians
            print java.lang.Math.toRadians( -90.0 )
            g.rotate( radians )
            g.setColor( self.getForeground() )
            g.setRenderingHint( java.awt.RenderingHints.KEY_TEXT_ANTIALIASING, java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON )
            #g.drawString( self.getText(), 1, -1 )
            fm = g.getFontMetrics()
            x = 1
            for z in self.getText():
                print z
                size = fm.stringWidth( z )
                #print size, fm.getHeight()
                bi = java.awt.image.BufferedImage(  size, fm.getHeight()  , java.awt.image.BufferedImage.TYPE_INT_RGB )
                g2 = bi.getGraphics()
                #g2.rotate( radians )
                g2.setColor( java.awt.Color.GREEN )
                g2.fillRect( 0, 0, bi.getHeight(), bi.getWidth() )
                #g2.setColor( self.getForeground() )
                #g2.drawString( z, 0, size )
                #g2.rotate( radians )
                #g2.setColor( self.getForeground() )
                #g2.drawString( z, 0, 0 )
                #g.rotate( -radians, x, 1 )
                #g.drawString( z, x, 0 )
                g.drawImage( bi, x, -bi.getHeight() , None )
                x += size
        self.super__paintComponent( g )
        g.setTransform( transform )
        
        
        
if __name__ == "__main__":
    
    jf = swing.JFrame()
    jp = swing.JPanel()
    jf.add( jp )
    rjl = RotatableJLabel( "MOOOOO Is Goood For you!!!!!!" )
    jp.add( rjl )
    jf.visible = 1
    rjl.rotateIt()
    lm = swing.border.LineBorder( java.awt.Color.RED )
    #rjl.setBorder( lm )
        
        
        </t>
<t tx="ekr.20070127142814.1030">@language java
import java.util.Iterator;
import java.awt.Color;
import java.awt.Font;
import javax.swing.ImageIcon;
//import org.python.core.*;

public interface PositionSpecification{ 

        //------drawn from Position
        public int level();
        public PositionSpecification getParent();
        public PositionSpecification copy();
        public boolean isCurrentPosition();
        public void expand();
        public void contract();
        public boolean isAtIgnoreNode();
        public boolean isExpanded();
        public boolean isVisited();
        public boolean isDirty();
        public int childIndex();
        public void setVisited();
        public boolean isRoot();
        public String headString();
        public String bodyString();
        public TnodeBodyText getTnodeBodyText();
        public void clearAllVisitedInTree(); //# Clear both vnode and tnode bits.
        public void clearVisitedInTree();
        public boolean setDirty(); ///this one will teach you to ignore whats returned ! :D
        public void clearDirty();
        public void setOrphan();
        public void clearOrphan();
        public boolean isOrphan();
        public String atFileNodeName();
        public String atNoSentFileNodeName();
        public String atThinFileNodeName();
        public String anyAtFileNodeName();
        public boolean equal( PositionSpecification p );
        public Object getT();
        public PositionSpecification moveToThreadNext();
        public PositionSpecification moveToNodeAfterTree();
        public PositionSpecification nodeAfterTree();
        
        public boolean isAtNorefFileNode();
        public boolean isAtAsisFileNode();
        public boolean isAnyAtFileNode();
        public boolean isAtNoSentFileNode();
        public boolean isAtThinFileNode();
        public boolean isAtFileNode();
        
        //------added to Position
        public Iterator&lt;PositionSpecification&gt; getParentIterator();
        public Iterator&lt;PositionSpecification&gt; getChildrenIterator();
        public Iterator&lt;PositionSpecification&gt; getSelfAndSubtreeIterator();
        public Iterator&lt;PositionSpecification&gt; getSelfAndParentsIterator();
        public void setWriteBit();
        public void setTVisited();
        public Object[] getTFileIndex();
        public Object acquireV();
        public int computeIconFromV();
        public void clearTTnodeList();
        public void g_es( String data );
        public boolean isValid();
        public Object get_T();
        public Object get_V();
        public Object get_Stack();
        //---- added to Colorize headlines
        public void setForeground( Color c );
        public void setBackground( Color c );
        public Color getBackground();
        public Color getForeground();
        public void setStrikeThrough( boolean torf );
        public boolean getStrikeThrough();
        public void setUnderline( boolean torf );
        public boolean getUnderline();
        public void setItalic( boolean torf );
        public boolean getItalic();
        public void setBold( boolean torf );
        public boolean getBold();
        public void setFont( Font f );
        public Font getFont();
        public void setImage( byte[] data );
        public ImageIcon getImage();
        public void setIcon( byte[] data );
        public ImageIcon getIcon();
        public boolean tnodeHasUA( String name );
        
        public PositionSpecification moveToParent();
        public PositionSpecification moveToFirstChild();
        public PositionSpecification moveToNext();
        public boolean hasNext();
        public boolean hasFirstChild();
        public boolean equals( Object o );
        
}


</t>
<t tx="ekr.20070127142814.1031">@language java
import java.util.*;
import javax.swing.*;
import javax.swing.tree.*;

public abstract class PositionJTree extends JTree{


    public PositionJTree( TreeModel tm ){
    
        super( tm );
    
    
    }
    
    public TreePath getPathToRoot( Object o ){ return null; }
    public abstract PositionSpecification getRootPosition();//{ return null; }
    public void clearToggledPaths(){ super.clearToggledPaths(); }

    public Enumeration&lt;TreePath&gt; getExpandedDescendants( final TreePath path ){
    
        Object o = path.getLastPathComponent();
        PositionSpecification p;
        if( o instanceof PositionSpecification )
            p = ((PositionSpecification)o).copy();
        else
            p = getRootPosition();
            
        final Vector&lt;TreePath&gt; paths = new Vector();
        PositionSpecification stop_p = p.copy();
        while( p != null &amp;&amp; p.isValid() ){
        
            final boolean expanded = p.isExpanded();
            if( expanded ){
            
                final TreePath npath = getPathToRoot( p.copy() );
                paths.add( npath );
                //setExpandedState( npath, true );
            
            
            
            }
        
        
            if( expanded ){
                if( p.hasFirstChild() ) p.moveToFirstChild();
                else if( p.isValid() &amp;&amp; p.hasNext() ) p.moveToNext();
                else{
                
                    while( p != null &amp;&amp; p.isValid() ){
                    
                        p.moveToParent();
                        if( p.equals( stop_p ) &amp;&amp;  !p.isRoot() ){
                        
                            p = null; break;
                        
                        
                        }
                        else if( p.isValid() &amp;&amp; p.hasNext() ){
                        
                            p.moveToNext(); break;
                        
                        
                        }
                        else if ( !p.isValid() ) break;
                    
                    }
                
                    
                    }
                
                }
                else{
                
                    if( p.hasNext() ) p.moveToNext();
                    else{
                    
                        while( p != null &amp;&amp; p.isValid() ){
                        
                            p.moveToParent();
                            if( p.equals( stop_p ) &amp;&amp;  !p.isRoot() ){
                        
                                p = null; break;
                        
                        
                            }
                            if( p.isValid() &amp;&amp; p.hasNext() ){
                            
                                p.moveToNext(); break;
                            
                            }
                            else if( !p.isValid() ) break;
                        
                        
                        }                    
                    
                    }                
                
                }
            }
        class PRunner implements Runnable{
        
            public void run(){
            
                for( final TreePath tp: paths )
                    PositionJTree.this.setExpandedState( tp, true );
            
            
            }
        
        
        }
        
        SwingUtilities.invokeLater( new PRunner() );
        System.out.println( paths.hashCode() );
        return paths.elements();
        }
    }

@
    def getExpandedDescendants( self, path ):
        #print "EXPANDING DESCENDEDNS!"
        #print path
        lc = path.getLastPathComponent()
        paths = java.util.Vector()
        #p_paths = {}
        #if lc != self.posTM._root:
        #    p_paths[ lc ] = path
        if 1: #lc == self.posTM._root:
            if lc == self.posTM._root:
                p = self.posTM.chapter.getRootPosition()
                cp = self.posTM.chapter.getCurrentPosition()
            else:
                p = lc.copy()
            #ends = java.util.HashSet()
            ct = 0
            #print "P is %s" % p
            stop_p = p.copy()
            while p:
                ct +=1
                #print p
                expanded = p.isExpanded()
                if expanded:
                    #ends.add( p.copy() )
                    #print _p
                    #print p_paths
                    #else:
                    npath = self.posTM.getPathToRoot( p.copy() )
                    #npath = p_path.pathByAddingChild( p.copy() )#stree.TreePath( p_path, p.copy() )
                    #p_paths[ p.copy() ] = npath
                    paths.add( npath )
                    #self.expandPath( npath )
                    self.setExpandedState( npath, True )
                    #print "two"
                    #print npath.getPath()
                if expanded:
                    if p.v.t._firstChild:
                        p.moveToFirstChild()
                    elif p and p.v._next:
                        p.moveToNext()
                    else:
                        while p:
                            p.moveToParent()
                            if p == stop_p and not p.isRoot():
                                p = None
                                break
                            if p and p.v._next:
                                p.moveToNext()
                                break
                            elif not p: break
                else:
                    if p.v._next:
                        p.moveToNext()
                    else:
                        while p:
                            p.moveToParent()
                            if p == stop_p and not p.isRoot():
                                p = None
                                break
                            if p and p.v._next:
                                p.moveToNext()
                                break
                            elif not p: break
        #print paths
        return paths.elements()





</t>
<t tx="ekr.20070127142814.1032">@language java
import java.util.*;
import javax.swing.*;
import javax.swing.tree.*;

public abstract class PositionJTree2 extends JTree{


    public PositionJTree2( TreeModel tm ){
    
        super( tm );
    
    
    }
    
    public TreePath getPathToRoot( Object o ){ return null; }
    public abstract PositionSpecification getRootPosition();
    
    public Enumeration&lt;TreePath&gt; getExpandedDescendants( final TreePath path ){
        
        System.out.println( "BOOODAA!" );
        getRootPosition();
        return null;
    
    }    



    
    }





</t>
<t tx="ekr.20070127142814.1033">import PositionJTree2

#import PositionJTree
class JTree2( PositionJTree2 ):
    
    def __init__( self, model ):
        #self.posTM = model
        #print dir( self )
        PositionJTree2.__init__( self, model )
        
    def getRootPosition( self ):
        return self.posTM.chapter.getRootPosition()
        
    def getPathToRoot( self, node ):
        return self.posTM.getPathToRoot( node )
        

if __name__ == "__main__":
    import javax.swing.tree as tree
    dmn = tree.DefaultMutableTreeNode( "x" )
    dnt = tree.DefaultTreeModel( dmn )
    jt = JTree2( dnt )

@
class JTree2( swing.JTree ):
    def __init__( self, model ):
        self.posTM = model
        swing.JTree.__init__( self, model )
        #tml2 = self.createTreeModelListener2()
        #model.addTreeModelListener( tml2 )
        #self.posTM = model
    def hasBeenExpanded2( self, path ):
        print "has Expanded?"
        lc = path.getLastPathComponent()
        if lc == self.posTM._root:
            print lc
            return False
        else:
            print lc, lc.isExpanded()
            return not lc.isExpanded()
        #print "hasExpanded"
        #print path
        return self.super__hasBeenExpanded( path )

    def isExpanded2( self, path ):
        print "isExpanded"
        print path
        lc = path.getLastPathComponent()
        if lc == self.posTM._root:
            print lc
            return False
        else:
            print lc, lc.isExpanded()
            return not lc.isExpanded()
        return self.super__isExpanded( path )
        #lc = path.getLastPathComponent()
        #if lc == self.posTM._root: return True
        #else: return lc.isExpanded()
    def removeDescendantToggledPaths2( self, data ):
        pass
    def isCollapsed2( self, data ):
        print "COLLAPSED!"
        return self.super__isCollapsed( data )
    def getExpandedDescendants( self, path ):
        #print "EXPANDING DESCENDEDNS!"
        #print path
        lc = path.getLastPathComponent()
        paths = java.util.Vector()
        #p_paths = {}
        #if lc != self.posTM._root:
        #    p_paths[ lc ] = path
        if 1: #lc == self.posTM._root:
            if lc == self.posTM._root:
                p = self.posTM.chapter.getRootPosition()
                cp = self.posTM.chapter.getCurrentPosition()
            else:
                p = lc.copy()
            #ends = java.util.HashSet()
            ct = 0
            #print "P is %s" % p
            stop_p = p.copy()
            while p:
                ct +=1
                #print p
                expanded = p.isExpanded()
                if expanded:
                    #ends.add( p.copy() )
                    #print _p
                    #print p_paths
                    #else:
                    npath = self.posTM.getPathToRoot( p.copy() )
                    #npath = p_path.pathByAddingChild( p.copy() )#stree.TreePath( p_path, p.copy() )
                    #p_paths[ p.copy() ] = npath
                    paths.add( npath )
                    #self.expandPath( npath )
                    self.setExpandedState( npath, True )
                    #print "two"
                    #print npath.getPath()
                if expanded:
                    if p.v.t._firstChild:
                        p.moveToFirstChild()
                    elif p and p.v._next:
                        p.moveToNext()
                    else:
                        while p:
                            p.moveToParent()
                            if p == stop_p and not p.isRoot():
                                p = None
                                break
                            if p and p.v._next:
                                p.moveToNext()
                                break
                            elif not p: break
                else:
                    if p.v._next:
                        p.moveToNext()
                    else:
                        while p:
                            p.moveToParent()
                            if p == stop_p and not p.isRoot():
                                p = None
                                break
                            if p and p.v._next:
                                p.moveToNext()
                                break
                            elif not p: break
        #print paths
        return paths.elements()
    def createTreeModelListener2( self ):
        class st( sevent.TreeModelListener ):
            def __init__( self, tree, posTM ):
                self.stree = tree
                self.posTM = posTM
                print "I AM A TREE LISTENER! %s" % tree
                print self.stree
            def treeNodesChanged(TreeModelEvent, e): pass
            def treeNodesInserted(TreeModelEvent, e): pass
            def treeNodesRemoved( self , e): pass
            def treeStructureChanged( self , e):
                try:
                    print "ST STRUCTURE CHANGED!!!"
                    #root = e.getTreePath()
                    #if not root: return
                    p = self.posTM.chapter.getRootPosition()
                    cp = self.posTM.chapter.getCurrentPosition()
                    ends = java.util.HashSet()
                    ct = 0
                    while p:
                        ct +=1
                        #print p
                        expanded = p.isExpanded()
                        if expanded:
                            ends.add( p.copy() )
                        if expanded:
                            if p.v.t._firstChild:
                                p.moveToFirstChild()
                            elif p and p.v._next:
                                p.moveToNext()
                            else:
                                while p:
                                    p.moveToParent()
                                    if p and p.v._next:
                                        p.moveToNext()
                                        break
                                    elif not p: break
                        else:
                            if p.v._next:
                                p.moveToNext()
                            else:
                                while p:
                                    p.moveToParent()
                                    if p and p.v._next:
                                        p.moveToNext()
                                        break
                                    elif not p: break

                    print "TOTAL ITERATIONS WERE %s" % ct
                    print ends
                    #def zoo():
                    haveseen = {}
                    for z in ends:
                        path = self.posTM.getPathToRoot( z )
                        #data = path.get
                        #print path
                        #print "EXPAND %s" % path
                        self.stree.fireTreeExpanded( path )
                    spath = self.posTM.getPathToRoot( cp )
                    self.stree.setSelectionPath( spath )
                    self.stree.scrollPathToVisible( spath )
                except java.lang.Exception, x:
                    print x
                    print "STRUCTURE EXCEPTION!"
        return st( self, self.posTM )
    #def isVisible( self, data ):
    #    print "VISIBLE"
    #    return self.super__isVisible( data )</t>
<t tx="ekr.20070127142814.1036">@language java
import java.util.Map;


public interface CommanderSpecification{


    public PositionSpecification currentPosition();
    public PositionSpecification rootPosition(); 
    public PositionSpecification nullPosition();
    
    //--had to be added
    
    public Integer acquirePage_width();
    public Integer acquireTab_width();
    public String acquireTarget_language();
    public String acquireDefault_derived_file_encoding();
    public String acquireOutputNewline();
    public String acquireOs_path_dirname( String name );
    public Boolean g_os_path_isabs( String dir );
    public Boolean g_os_path_exists( String dir );
    public String g_makeAllNonExistentDirectories( String dir );
    public Map g_get_directives_dict( String s );
    public String g_getBaseDirectory();
    public String g_os_path_join( String base, String path );
    public String g_scanAtEncodingDirective( String s, Map theDict );
    public String g_scanAtLineendingDirective( String s, Map theDict);
    public Integer g_scanAtPagewidthDirective( String s,Map theDict, boolean issue_error_flag);
    public Integer g_scanAtTabwidthDirective( String s,Map theDict, boolean issue_error_flag);
    public Object g_fileLikeObject();
    public Boolean g_isValidEncoding( String encoding );
    public String[] g_set_language( String language, Integer k );
    public void g_trace();
    public Boolean hasFrame();
    public String acquireTangle_directory();
    public String acquireFrOpenDirectory();
    public String acquireOpenDirectory();
    public void beginUpdate();
    public void endUpdate();
    public void setChanged( Boolean changed );
    public void setChanged2( Boolean changed );





}</t>
<t tx="ekr.20070127142814.1037">@language java

import java.util.Iterator;


public final class IteratorDecorator implements Iterator{

    final PositionIterator _it;
    Object _nx;
    
    public IteratorDecorator( final PositionIterator pi ){
    
    
        _it = pi;
        try{
        
            _nx = pi.next();
        
        }
        catch( final Exception x ){
        
            _nx = null;
        
        }
    
    }

    public final boolean hasNext(){
    
        if( _nx == null ) return false;
        return true;
    
    }

    public final Object next(){
    
        final Object nx = _nx;
        try{
        
            _nx = _it.next();
        
        }
        catch( final Exception x ){
        
            _nx = null;
        
        }
        return nx;
    
    
    }

    public final void remove(){
    
        throw new UnsupportedOperationException();
    
    }

}



@
class iteratorDecorator( java.util.Iterator ): #this at one time when defined inside a method created a pathological memory leak.
        def __init__( self, it ):
            self._it = it
            try:
                self._nx = it.next()
            except:
                self._nx = None
        def hasNext( self ):
            if self._nx is None: return False
            else: return True
        def next( self ):
            nx = self._nx
            try:
                self._nx = self._it.next()
            except:
                self._nx = None
            return nx</t>
<t tx="ekr.20070127142814.1038">@language java

public interface PositionIterator{

    public Object next();

}</t>
<t tx="ekr.20070127142814.1039">@language java

import javax.swing.JComponent;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.ImageCapabilities;
import java.awt.AlphaComposite;
import java.awt.image.VolatileImage;



public final class EditorBackground extends JComponent{

    VolatileImage _image;
    Image _backup;
    AlphaComposite _ac;
    int _height;
    int _width;

    public EditorBackground( final Image image, final int width, final int height, float alpha ){
    
        super();
        /* _height = height;
        _width = width;
        GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
        GraphicsConfiguration gc = gd.getDefaultConfiguration();
        _image = gc.createCompatibleVolatileImage( _width, _height );
        //ImageCapabilities ic = _image.getCapabilities();
        //System.out.println( "TRUE VOLATILE " + ic.isTrueVolatile() );
        ///System.out.println( "Is ACCELERATED " + ic.isAccelerated() );
        _backup = image;
        //_ac = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, .2f );
        if( alpha &gt; 1.0f ) alpha = 1.0f;
        _ac = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, alpha );
        renderVI();*/
        setBackground( image, width, height, alpha );
    
    }
    
    public void setBackground( final Image image, final int width, final int height, float alpha ){
    
        _height = height;
        _width = width;
        GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
        GraphicsConfiguration gc = gd.getDefaultConfiguration();
        _image = gc.createCompatibleVolatileImage( _width, _height );
        //ImageCapabilities ic = _image.getCapabilities();
        //System.out.println( "TRUE VOLATILE " + ic.isTrueVolatile() );
        ///System.out.println( "Is ACCELERATED " + ic.isAccelerated() );
        _backup = image;
        //_ac = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, .2f );
        if( alpha &gt; 1.0f ) alpha = 1.0f;
        _ac = AlphaComposite.getInstance( AlphaComposite.SRC_OVER, alpha );
        renderVI();    
    
    
    
    }

    public final void paint( final Graphics g ){
    
        final Graphics2D g2 = (Graphics2D)g;
        final Dimension size = getSize();
        //g2.setComposite( _ac );
        if( _image.contentsLost() ){
        
            final Graphics2D g2d = _image.createGraphics();
            final int result = _image.validate( g2d.getDeviceConfiguration() );
            if( result != _image.IMAGE_RESTORED ) renderVI();
            g2d.dispose();
        
        }
        g2.drawImage( _image, 0, 0, size.width, size.height , null);
            
    
    }

    private final void renderVI(){
    
        //System.out.println( "G2D is " + _image );    
        final Graphics2D g2d = _image.createGraphics();
        g2d.setComposite( _ac );
        g2d.drawImage( _backup, 0, 0, _width, _height , null );
        g2d.dispose();
    
    
    }

}</t>
<t tx="ekr.20070127142814.1040">@language java
import javax.swing.*;
import javax.media.*;
import javax.media.format.*;
import javax.media.control.*;
import javax.media.protocol.*;
import javax.media.bean.playerbean.*;
import java.awt.*;
import java.net.*;
import java.io.*;
import java.util.List;
import java.util.LinkedList;


public final class EditorBackgroundMovie extends JPanel implements ControllerListener{

    Player p;
    MediaPlayer mp;
    GridBagConstraints gbc;
    GridBagLayout gbl;
    final JPanel background;
    final java.util.List&lt; JMenuBar &gt; menus; 
    boolean loadok;
    boolean realized;
    
    
    public static void main( String[] args ){
    
        JFrame jf = new JFrame();
        JPanel jp = new JPanel();
        jf.add( jp );
        EditorBackgroundMovie ebm = new EditorBackgroundMovie( args[ 0 ], jp );
        jf.pack();
        jf.setVisible( true );
    
    
    }
    
    public EditorBackgroundMovie( final String moviepath, final JPanel parent ){
    
        super();
        menus = new LinkedList&lt; JMenuBar&gt;();
        background = parent;
        try{
        
            //background = parent;
            Manager.setHint( Manager.LIGHTWEIGHT_RENDERER, Boolean.TRUE );
            Manager.setHint( Manager.CACHING, Boolean.TRUE );
            gbl = new GridBagLayout();
            parent.setLayout( gbl );
            gbc = new GridBagConstraints();
            gbc.weightx = 1;
            gbc.weighty = 1;
            gbc.fill = 1;
            File f = new File( moviepath );
            if( f.exists() ){
                DataSource ds = Manager.createDataSource( f.toURL() );
                p = Manager.createPlayer( ds );
                mp = new MediaPlayer();
                mp.setPlayer( p );
                mp.setPlaybackLoop( true );
                mp.setFixedAspectRatio( false );
                //mp.setControlPanelVisible( true );
                
                mp.addControllerListener( this );
                mp.realize();
                loadok = true;
                
            }
        
        }
        catch( Exception x ){
            x.printStackTrace();
            loadok = false;
        }
    
    }


    public final void stop(){
    
        mp.stop();
    
    } 
    
    
    public final void start(){
        mp.setPlaybackLoop( true );
        mp.start();
    
    }
    
    public final boolean isRunning(){
    
        final int state = mp.getState();
        if( state == mp.Started ) return true;
        return false;
    
    
    }
    
    public final boolean loadOk(){
    
    
        return loadok;
    
    }
    
    public final void setVolume( final String volume ){
    
        final String oldlevel = mp.getVolumeLevel();
        try{
            mp.setVolumeLevel( volume );
            }
        catch( Exception x ){
        
            mp.setVolumeLevel( oldlevel );
        
        }
        
    
    }
    
    public final int getVolume(){
    
        String vl = mp.getVolumeLevel();
        if( vl == null ) vl = "0";
        return Integer.valueOf( vl ).intValue();
    
    
    
    }
    
    public Component getControlPanelComponent(){
    
    
        return mp.getControlPanelComponent();
    
    
    }
    
    public final void addControllerToMenu( JMenuBar j ){
    
        if( realized )
            j.add( mp.getControlPanelComponent() );
        else
            menus.add( j );
    
    
    }

     public final void controllerUpdate( ControllerEvent e ){
    
    
        if( e instanceof RealizeCompleteEvent ){
        
            Component c = mp.getVisualComponent();
            gbl.setConstraints( c, gbc );
            background.add( c );
            mp.start();
            Component cpc = mp.getControlPanelComponent();
            realized = true;
            for( JMenuBar j: menus )
                j.add( cpc );
        
        
        }
    
    
    
    
    }

 


}
</t>
<t tx="ekr.20070127142814.1041">@encoding utf-8 

'''This jython script is supposed to build the environment up for
JyLeos execution.  It needs to be run in the parent directory of the
src, Icons, skins, skinimages directories.  Otherwise its useless.
For example:
jython ~ahome/jyleo/jyleo.py aleofile.leo
On linux I have this thing wrapped as a simple shell script so I can
just
type "jyleo" and it will execute this script and open the file passed
in.  On XP I have a simple shortcut that executes jython with this
file as an argument.
IMPORTANT NOTE:
jython2.2a1 compiles the __file__ attribute into the class file generated.
Hence any execution of jyleo.py will use that static data.  If this distribution
is taken to another system it is imperative that the jyleo.py and leo.py class files
are removed--&gt; do not remove the .py files, just the class files which should be 2.'''

import java.lang.System as System
import java.lang.String as String
import java.lang.ProcessBuilder as ProcessBuilder
import java.io as io 
import os
import __calculate_fs_location
import java.util.HashMap as hmap 

pathsep = os.pathsep

if __name__ == '__main__':

   cp = System.getProperty( "java.class.path" )
   phome = System.getProperty( "python.home" )
   if phome:
      print "python.home is defined at %s" % phome
   else:
      print "python.home not found, aborting startup..."
      print "check that jython is being started correctly..."
      System.exit( 0 )
   
   op_system = System.getProperty( "os.name" )
   print "OS detected is %s" % op_system
   op_system = op_system.lower()
   if op_system.startswith( "win" ):
      jy_command = "jython.bat"
   else:
      jy_command = "jython"
   
   print "jython execution command is defined as %s" % jy_command
   cmdfile = io.File( phome, jy_command )
   if not cmdfile.exists():
      print "can't find jython command, exiting..."
      System.exit( 0 )
      
   cmdpath = cmdfile.getAbsolutePath()           
   f = io.File( __calculate_fs_location.__file__ ).getParentFile()


   files = f.listFiles()

   directories = []
   for z in files:
       if z.isDirectory():
           directories.append( z )

   addons = ( 'Icons', 'src', 'skins', 'skinimages' )
   paths = []
   pathtoleo = None
   for z in directories:
       if z.getName() in addons:
	  paths.append( z.getAbsolutePath() )
	  if z.getName() ==  "src" :
	     sfiles = z.listFiles()
	     for src in sfiles:
		    if src.getName() ==  "leo.py" :
		        pathtoleo= src.getAbsolutePath()
		    
   if pathtoleo == None:
      print "leo.py not found. Exiting"
      System.exit( 0 )
		    		    
   npaths = pathsep.join( paths )
   cp2 = '%s%s%s' % ( cp, pathsep, npaths )
   def visit( args, directory, files, cp = cp ):
      global cp2
      fdirectory = io.File( directory )
      dname = fdirectory.getName()
      if dname.startswith( "freemind" ) or dname.startswith( ".freemind" ):
         print "freemind appears to be installed in opt directory at %s" % directory
      elif dname.startswith( "jfreereport" ):
         print "jfreereport appears to be installed in opt directory at %s" % directory
      for z in files:
         if z.endswith( ".jar" ):
            f = io.File( directory, z )
            cp2 = "%s%s%s" % ( cp2, pathsep, f.getAbsolutePath() )
            f = None
       
   print "Setting up environment..."
   optfile = io.File( f, "opt" )
   if optfile.exists():
      print '-' * 20
      print "Looking in opt directory..."
      os.path.walk(  optfile.getAbsolutePath(), visit, None )
      print '-' * 20
   else:
      print "opt directory does not exists, printing and mindmap systems will not function..."
  
   command = [ String( cmdpath ), pathtoleo ]
   import sys
   if len( sys.argv ) &gt; 1:
      command.extend( sys.argv[ 1: ] )
   leobuilder = ProcessBuilder( command )
   env = leobuilder.environment()
   
   h2 = hmap()
   h2.put( "CLASSPATH", cp2 )
   env.putAll( h2 )
   print "CLASSPATH is pointing at these entities:"
   paths = cp2.split( pathsep )
   for z in paths:
       print z
       
   p = None
   try:
      p = leobuilder.start()
      ev = p.exitValue()
   except:
      print "Starting jyleo..."
      System.exit( 1 )
   print "jyleo did not startup..."
   System.exit( 0 )
</t>
<t tx="ekr.20070127142814.1042">@language java

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class leoRadialMenu extends JPanel{

    JComponent parent;
    Mouser mouser;
    @others









}
</t>
<t tx="ekr.20070127142814.1043">public leoRadialMenu( JComponent parent ){

    super();
    setOpaque( false );
    this.parent = parent;
    mouser = new Mouser( this );
    parent.addMouseListener( mouser );
    setSize( 400, 400 );
    add( new RadialControl( "MOUSE" ) );
    //setSize( 400, 400 );
    
    
}</t>
<t tx="ekr.20070127142814.1044">public void popup( int x, int y){

    Container tla = parent.getTopLevelAncestor();
    System.out.println( tla );
    JFrame jf = (JFrame)tla;
    JLayeredPane jlp = jf.getLayeredPane();
    jlp.add( this, JLayeredPane.POPUP_LAYER );
    this.setLocation( x, y );
    jlp.moveToFront( this );

}


</t>
<t tx="ekr.20070127142814.1045">private class Mouser extends MouseAdapter{

leoRadialMenu parent;

public Mouser( leoRadialMenu parent ){

    this.parent = parent;



}


public void mousePressed( MouseEvent mE ){

    Component source = mE.getComponent();
    Container tla = parent.getTopLevelAncestor();
    MouseEvent mE2 = SwingUtilities.convertMouseEvent( source, mE, tla );
    parent.popup( mE2.getX(), mE2.getY());


}




}
</t>
<t tx="ekr.20070127142814.1046">class RadialControl extends JComponent{


    private String _text;
    public RadialControl( String text ){
        super();
        _text = text;
        setSize( 200, 200 );
        setPreferredSize( new Dimension( 200, 200 ) );
    
    }

    @others





}</t>
<t tx="ekr.20070127142814.1047">public void paint( Graphics g ){

    Graphics2D g2 = (Graphics2D)g;
    System.out.println( g.getClip() );
    FontMetrics fm = g.getFontMetrics();
    g2.setColor( Color.RED );
    int width = SwingUtilities.computeStringWidth( fm, _text );
    Ellipse2D.Double e2d = new Ellipse2D.Double( 0, 0, width, width );
    PathIterator pi = e2d.getPathIterator( null );
    double[] points = new double[ 6 ];
    while( !pi.isDone() ){
    
        System.out.println( pi.currentSegment( points ) );
        String data = String.format( "Spot %e, %e, (x,y )   %e, %e ( h,w )", points[ 0 ], points[ 1 ], points[ 2 ], points[ 3 ] );
        System.out.println( data );
        pi.next();
    
    }
    g2.draw( e2d );
    g2.drawString( _text, 0, width/2 );
    System.out.println( "PAINTING!!!" );




}
</t>
<t tx="ekr.20070127142814.1048">@language java

import javax.swing.*;

public class AutoPanel extends JPanel{

}</t>
<t tx="ekr.20070127142814.1049">@language java
import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;    
import javax.swing.text.*;
import java.util.*;
import java.util.concurrent.*;  


public final class BarDrawer implements Runnable, ChangeListener{


    final JLayeredPane _jlp;
    final JTextPane _jtp;
    final Color _bg;
    Rectangle _lastcoords, _oldcoords, _editor_rec;
    final ConcurrentLinkedQueue&lt;Rectangle&gt; _painter;
    
    public BarDrawer( final JLayeredPane jlp, final JTextPane jtp ){
    
        _jlp = jlp;
        _jtp = jtp;
        
        int ti = java.lang.Integer.decode( "#FFFFC6" );
        Color c = new Color( ti );
        _bg = new Color( c.getRed(), c.getGreen(), c.getBlue(), 50 ); 
        
        _lastcoords = null;
        _oldcoords = null;  
        _editor_rec = null;
        _painter = new ConcurrentLinkedQueue&lt; Rectangle &gt;();
    
    }
    
    public void run(){
    
        try{
        
        _jtp.paintImmediately( _painter.poll() );            
        final Graphics2D g = (Graphics2D)_jlp.getGraphics();
        g.setRenderingHint( RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED );
        g.setRenderingHint( RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_DISABLE );
        g.setColor( _bg );
        //final Rectangle rect = _painter.poll();
        g.fill( _painter.poll() );

        }
        catch( Exception x ){
        
            //not sure what to do at this point, not a critical error.
        
        }
       
    
    }
    
    public void stateChanged( final ChangeEvent ce ){
            
        try{

            
            final int pos = _jtp.getCaretPosition();
            final int start = Utilities.getRowStart( _jtp , pos );
            _oldcoords = _editor_rec;
            _editor_rec = _jtp.modelToView( start );

            final Rectangle lpane_rec = SwingUtilities.convertRectangle( _jtp, _editor_rec, _jlp );
            final Dimension size = _jtp.getPreferredSize();
            _lastcoords = new Rectangle( lpane_rec.x , lpane_rec.y, size.width, lpane_rec.height );
            
            if( _oldcoords != null )
                _oldcoords.width = _lastcoords.width; //the oldcords need to be reset so the whole line will be redrawn.
                _painter.offer( _oldcoords );
                _painter.offer( _lastcoords );
                EventQueue.invokeLater( this );
                  
            
        }
        catch( Exception x ){}  
    
    
    
    
    }



}
</t>
<t tx="ekr.20070127142814.1050">@language java
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.event.*;
import java.util.List; 
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.Enumeration;
import java.util.Comparator;
import java.util.Arrays;

public final class leoTreeReloader implements Runnable{

    private final JTree _jtree;
    private final TreeModel _model;
    private final List&lt; TreeModelListener &gt; _listeners; 
    private Enumeration&lt;TreePath&gt; _snapshot;
    private TreePath _current;
    private Set _paths;
    private final TreeExpansionTracker _tet;
    private final PositionComparator _pc;
    private final Object _rootNode;
    private final Map&lt;PositionSpecification, Object&gt; _haveseen;
    
    
    public leoTreeReloader( final JTree jtree, List&lt; TreeModelListener &gt; listeners, Object rootNode ){
    
        _jtree = jtree;
        _tet = new TreeExpansionTracker();
        _jtree.addTreeExpansionListener( _tet );
        _model = jtree.getModel();
        _listeners = listeners;
        _pc = new PositionComparator();
        _rootNode = rootNode;
        _haveseen = new HashMap&lt; PositionSpecification, Object &gt;();

    
    }



    private final void createTreeNodes( final PositionSpecification[] in, final Set&lt;TreePath&gt; out ){    
 
        _haveseen.clear();
        for( final PositionSpecification node: in ){

            if( _haveseen.containsKey( node ) ) continue;
            if( node.isExpanded() == false ){ //we check for this here since positions can lie if there are no children in it, 
                                             //and we fix our state
            
                _tet._expanded.remove( node );
                continue;
            
            }
            Object[] a = getObjectArrayToBuildTreePath( node.level(), _rootNode, node.copy() );
            int i = a.length - 2;
            final Iterator&lt; PositionSpecification &gt; pi = node.getParentIterator();
            while( pi.hasNext() ){
                final PositionSpecification parent = pi.next();
                
                if( !parent.isExpanded() ){
                
                    a = null;
                    break;
                
                
                }
                _haveseen.put( parent, null );
                a[ i ] = parent.copy();
                i--;

            }
            if( a != null ) out.add( new TreePath( a ) );
        
        
        }
        /*haveseen = {} # java.util.HashMap()
        for node in data:
            if haveseen.has_key( node ): # in haveseen:
                continue
            a = leoTreeReloader.getObjectArrayToBuildTreePath( node.level(), self._root, node.copy() );
            i = len( a ) - 2
            for z in node.parents_iter( copy = True):
                if not z.isExpanded():
                    a = None
                    break
                haveseen[ z ] =  None 
                a[ i ] = z
                i = i - 1
                
            if a != None:
                out.add( stree.TreePath( a ) )
        return out*/
        
        }
    
    public final static Object[] getObjectArrayToBuildTreePath( final int level, final Object root, final Object end ){
    
        
        final Object[] oa =  new Object[ level + 2 ];
        oa[ 0 ] = root;
        oa[ oa.length -1 ] = end;
        return oa; 
    
    }
    
    private final class PositionComparator implements Comparator&lt; PositionSpecification &gt;{
    
    
        public final int compare( final PositionSpecification a, final PositionSpecification b ){
        
            final int a1 = a.level();
            final int b1 = b.level();
            if( a1 == b1 ) return 0;
            else if( a1 &lt; b1 ) return 1;
            else return -1;        
        
        }
    
    
    }



    
    public final void setCurrentPosition( final TreePath tp ){
    
        //if( !_enabled ) return;
        _current = tp;
    
    }
    
    public final void executeChange(){
    
        final Object root = _model.getRoot();
        final TreeModelEvent tme = new TreeModelEvent( root, new TreePath( root ) );
        for( final TreeModelListener tml: _listeners ){
        
            tml.treeStructureChanged( tme );
        
        
        }    
    
    }
    

    
    public final void run(){

        final Object root = _model.getRoot();
        final TreeModelEvent tme = new TreeModelEvent( root, new TreePath( root ) );
        for( final TreeModelListener tml: _listeners ){
        
            tml.treeStructureChanged( tme );
        
        
        }  
        
        
        final Set&lt; TreePath&gt; paths = new java.util.HashSet&lt;TreePath&gt;();
        final PositionSpecification[] pi =  _tet._expanded.toArray( new PositionSpecification[ _tet._expanded.size() ]  );
        Arrays.sort( pi, _pc );

        createTreeNodes( pi, paths );
        //_cptr.calculatePathToRoot( pi , paths );
        for( final TreePath tp: paths ){
            try{
                _jtree.expandPath( tp );
            }
            catch( Exception x ){
            
                }
    
        }


       if( _current != null ){
       
            _jtree.setSelectionPath( _current );
            _jtree.scrollPathToVisible( _current );
            
            }
        
    
    }

    public void expand( final PositionSpecification pos ){
    
        final TreePath tp = new TreePath( pos );
        final TreeExpansionEvent tee = new TreeExpansionEvent( this, tp );
        _tet.treeExpanded( tee );
    
    }
    
    public void collapse( final PositionSpecification pos ){
        
        if( _tet._expanded.contains( pos ) )
            _tet._expanded.remove( pos );
    
    }
    
    public void addExpandedSet( Set&lt;PositionSpecification&gt; positions ){
    
        _tet._expanded.addAll( positions );
    
    }
    
    private final class TreeExpansionTracker implements TreeExpansionListener{
    
    
        final Set&lt;PositionSpecification&gt; _expanded;
    
        public TreeExpansionTracker(){
        
            _expanded = new HashSet&lt;PositionSpecification&gt;(); //new HashSet();
        
        
        }
    
        public void treeCollapsed( final TreeExpansionEvent tee ){
        
            final TreePath tp = tee.getPath();
            Object x = tp.getLastPathComponent();
            if( x instanceof PositionSpecification ){
            final PositionSpecification o = (PositionSpecification)x; //tp.getLastPathComponent();
            //if( _expanded.contains( o ) ) return;
            //synchronized( _expanded )
            o.contract();
            _expanded.remove( o );
            }
        
        }
        
        public void treeExpanded( final TreeExpansionEvent tee ){
        
            final TreePath tp = tee.getPath();
            Object x = tp.getLastPathComponent();
            if( x instanceof PositionSpecification ){
            final PositionSpecification o = (PositionSpecification)x;//tp.getLastPathComponent();
            //if( _expanded.contains( o ) ) _expanded.remove( o );
            //synchronized( _expanded )
            o.expand();
            _expanded.add( o );
            }
        
        
        }
    
    
    
    
    }


}</t>
<t tx="ekr.20070127142814.1051">@language java



public interface TnodeOperations{



    public void setVisited( Object t );
    public String getTempBodyString( Object t );
    public void setTempBodyString( Object t, String s );
    public boolean hasTempBodyString( Object t );
    public void setDirty( Object t );
    public String getBody( Object t );
    public boolean hasBody( Object t );
    public void insert( Object t, int spot, String s );
    public Object getT( Object v );
    public String getHeadString( Object t );


}</t>
<t tx="ekr.20070127142814.1052">@language java

import java.io.*;
import java.nio.*;
import java.util.*;
import jconstants.AtFileConstants;
import static jconstants.AtFileConstants.*;
import static java.lang.System.err;
//import static java.lang.System.out;
import static java.lang.Math.*;

public abstract class LeoFileReader{

    
    public String _filename;
    public int cloneSibCount;
    public boolean done;
    public boolean inCode;
    public int indent;
    public int tab_width;
    public List&lt;String&gt; lastLines;
    public String leadingWs = "";
    public PositionSpecification root;
    public boolean rootSeen;
    public boolean updateWarningGiven;
    public boolean thinFile;
    public boolean importing;
    public boolean root_seen;
    public boolean raw;
    public List&lt; AtFileConstants &gt; endSentinelStack;
    public List&lt; String &gt; out;
    public List&lt; List&lt; String &gt; &gt; outStack;
    public List&lt; String &gt; docOut;
    public List&lt; String &gt; pending;
    public List&lt; Integer &gt; indentStack;
    public Object t;
    public List tStack;
    public Object lastThinNode;
    public List&lt; Object &gt; thinNodeStack;
    public int errors;
    
    public RandomAccessFile raFile;
    public CommanderSpecification c;
    public TnodeOperations t_op;
    
    public String startSentinelComment = "";
    public String endSentinelComment ="";
    public String encoding;
    
    public List _forcedGnxPositionList;
    
    public LeoFileReader( String filename, CommanderSpecification cs, TnodeOperations to ){
    
        _filename = filename;
        lastLines = new ArrayList&lt; String &gt;();
        endSentinelStack = new ArrayList&lt; AtFileConstants &gt;();
        out = new ArrayList&lt; String &gt;();
        outStack = new ArrayList&lt; List&lt; String &gt; &gt;();
        docOut = new ArrayList&lt; String &gt;();
        pending = new ArrayList&lt; String &gt;();
        indentStack = new ArrayList&lt; Integer &gt;();
        tStack = new ArrayList();
        thinNodeStack = new ArrayList&lt; Object &gt;();
        _forcedGnxPositionList = new ArrayList();
        c = cs;
        t_op = to;
        try{
            raFile = new RandomAccessFile( filename, "r" );
        }
        catch( FileNotFoundException fnfe ){
        
            System.out.println( fnfe );
        
        }
        
@
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]
@c    
    
    }

    
    @others




}</t>
<t tx="ekr.20070127142814.1053">public static final Map&lt; String, AtFileConstants &gt; sentinelDict = new HashMap&lt; String, AtFileConstants &gt;();
static{
    sentinelDict.put( "@comment", startComment );
    sentinelDict.put( "@delims", startDelims );
    sentinelDict.put( "@verbatim", startVerbatim );
    sentinelDict.put( "@verbatimAfterRef", startVerbatimAfterRef );
    sentinelDict.put( "@afterref", startAfterRef );
    sentinelDict.put( "@clone", startClone );
    sentinelDict.put( "@nl", startNl );
    sentinelDict.put( "@nonl", startNonl );
    sentinelDict.put( "@+body", startBody ); sentinelDict.put( "@-body", endBody );
    sentinelDict.put( "@+all", startAll ); sentinelDict.put( "@-all", endAll );
    sentinelDict.put( "@+at", startAt ); sentinelDict.put( "@-at", endAt) ;
    sentinelDict.put( "@+doc", startDoc ); sentinelDict.put( "@-doc", endDoc);
    sentinelDict.put( "@+leo", startLeo ); sentinelDict.put( "@-leo", endLeo );
    sentinelDict.put( "@+middle", startMiddle ); sentinelDict.put( "@-middle", endMiddle );
    sentinelDict.put( "@+node", startNode ); sentinelDict.put( "@-node", endNode );
    sentinelDict.put( "@+others", startOthers); sentinelDict.put( "@-others", endOthers );
}

@
sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}</t>
<t tx="ekr.20070127142814.1054">public void dispatch( AtFileConstants kind, String s, int i ){

    switch( kind ){


        case noSentinel:
            readNormalLine( s, i );
            break;
        case startAll:
            readStartAll( s, i );
            break;
        case startAt:
            readStartAt( s, i );
            break;
        case startDoc:
            readStartDoc( s, i );
            break;
        case startLeo:
            readStartLeo( s, i );
            break;
        case startMiddle:
            readStartMiddle( s, i );
            break;
        case startNode:
            readStartNode( s, i, -1 );
            break;
        case startOthers:
            readStartOthers( s, i );
            break;
        case endAll:
            readEndAll( s, i );
            break;
        case endAt:
            readEndAt( s, i );
            break;
        case endDoc:
            readEndDoc( s, i );
            break;
        case endLeo:
            readEndLeo( s, i );
            break;
        case endMiddle:
            readEndMiddle( s, i );
            break;
        case endNode:
            readEndNode( s, i, false );
            break;
        case endOthers:
            readEndOthers( s, i );
            break;
        case startAfterRef:
            readAfterRef( s, i );
            break;
        case startClone:
            readClone( s, i );
            break;
        case startComment:
            readComment( s, i );
            break;
        case startDelims:
            readDelims( s, i );
            break;
        case startDirective:
            readDirective( s, i );
            break;
        case startNl:
            readNl( s, i );
            break;
        case startNonl:
            readNonl( s, i );
            break;
        case startRef:
            readRef( s, i );
            break;
        case startVerbatim:
            readVerbatim( s, i );
            break;
        case endBody:
            ignoreOldSentinel( s,i );
            break;
        case startBody:
            ignoreOldSentinel( s, i );
            break;
        case startVerbatimAfterRef:
            ignoreOldSentinel( s, i );
            break;
    }

}

@others


@
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20070127142814.1055">public void readNormalLine( String s, int i ){
    
    //System.out.println( "READ NORMAL LINE!: " + inCode );
    if( inCode ){
    
        if( !raw ){
        
            s = removeLeadingWhitespace( s, indent, tab_width );
        
        }
        //System.out.println("OUT ADDING:" + s );
        out.add( s );
    }
    else{
    
        if( endSentinelComment.length() == 0 )
            i = skip_ws( s, 0 );
        if( match( s, i, startSentinelComment ) ){
        
            i += startSentinelComment.length();
            if( match( s, i, " " ) ) i += 1;
        
        }
        else i = skipIndent( s, 0, indent );
        
        //System.out.println( "S is:'" + s + "'" );
        //System.out.println( "I is :" + i );
        //System.out.println( i + " " + "'" + s + "'" + " " + s.length() );
        String line = s.substring( i, s.length() - 1 );
        if( line.equals( line.trim() ) )
            docOut.add( line + '\n' );
        else
            docOut.add( line );    
        //System.out.println( "DOC OUT NOW:" + docOut );
    }

}</t>
<t tx="ekr.20070127142814.1056">@
def readNormalLine (self,s,i):

    at = self
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
@c
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20070127142814.1057">@
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20070127142814.1058">@
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20070127142814.1059">public void readStartAll( String s, int i ){

    int j = skip_ws( s, i );
    String leadingWs = s.substring( i, j );
    //;if( leadingWs.length() &gt; 0 )
    out.add( leadingWs + "@all\n" );
    endSentinelStack.add( endAll );

}


@
def readStartAll (self,s,i):
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20070127142814.1060">public void readStartAt( String s, int i ){

    i += 3; int j = skip_ws( s, i ); String ws = s.substring( i,j );
    docOut = new ArrayList&lt; String &gt;();
    docOut.add( '@' + ws + '\n' );
    //System.out.println( "docOut now:" + docOut );
    inCode = false;
    endSentinelStack.add( endAt );


}


@
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
@c

public void readStartDoc( String s, int i ){

    i += 4; int j = skip_ws( s, i ); String ws = s.substring( i, j );
    docOut = new ArrayList&lt; String &gt;();
    docOut.add( '@' + ws + '\n' );
    //System.out.println( "DOC OUT" + docOut );
    inCode = false;
    endSentinelStack.add( endDoc );

}



@    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
@c


public int skipToEndSentinel( String s, int i ){

    String end = endSentinelComment;
    if( end.length() &gt; 0 ){
    
        int j = s.indexOf( end, i );
        if( j == -1 ) return skip_to_end_of_line( s, i );
        else return j;
    
    }
    else return skip_to_end_of_line( s, i );

}


@
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20070127142814.1061">public void readStartLeo( String s, int i ){




}


@
def readStartLeo (self,s,i):
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20070127142814.1062">public void readStartMiddle( String s, int i ){


    readStartNode( s, i, 1 );// true );


}


@
def readStartMiddle (self,s,i):
    """Read an @+middle sentinel."""
    at = self
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20070127142814.1063">public void readStartNode( String s, int i, int middle ){
    
    //System.out.println( "I starts at " + i + " Middle is " + middle + " " + s.length() );
    //System.out.println( s.substring( i ) );
    if( middle != -1 ){
    
        i += 8;
    
    }
    else i += 6;

    String gnx = null;

    if( thinFile ){
        //System.out.println( "I is " + i + " S is:" + s );
        int j = s.indexOf( ':', i );
        //System.out.println( "J is " + j );
        if( j == -1 ){
        
            readError( "Expecting gnx in @+node sentinel" );
            return;
        
        }
        else{
            
            gnx = s.substring( i, j );
            i = j + 1;
        
        }
    
    }

    String headline;
    if( endSentinelComment.length() == 0 ){
    
        headline = rtrim( s.substring( i, s.length() - 1 ) );        
        
    }
    else{
        
        //System.out.println( "END SentinelCOmment is:" + endSentinelComment );
        int k = s.lastIndexOf( endSentinelComment, i );
        if( k == -1 ) k = s.length();
        //System.out.println( "K is " + k + " I is " + i );
        headline = rtrim( s.substring( i, k ) );
        
    
    }
    
    if( startSentinelComment.charAt( startSentinelComment.length() - 1 ) == '@' )
        headline = headline.replace( "@@", "@" );
@    
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
@c    

    if( ! root_seen ){
    
        root_seen = true;
@
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
@c    
    }
    
    int[] data = skip_leading_ws_with_indent( s, 0 , tab_width );
    i = data[ 0 ];
    int newIndent = data[ 1 ];
    indentStack.add( indent ); indent = newIndent;
    //System.out.println( i + " i and INDENT IS NOW: " + indent );
    outStack.add( out ); out = new ArrayList&lt; String &gt;();
    tStack.add( t );
    
    if( importing ){
    
        PositionSpecification p = createImportedNode( root, c, headline );
        t = p.get_T();
    
    }
    else if( thinFile ){
        
        //System.out.println( lastThinNode );
        thinNodeStack.add( lastThinNode );
        //System.out.println( "PRE CTC4!" );
        lastThinNode =  createThinChild4( gnx, headline );
        //System.out.println( lastThinNode );
        t = t_op.getT( lastThinNode );//lastThinNode.get_T();
    
    }
    else t = findChild4( headline );
    
    
    endSentinelStack.add( endNode );
    
}


@
def readStartNode (self,s,i,middle=False):
    """Read an @+node or @+middle sentinel."""
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20070127142814.1064">public void readStartOthers( String s, int i ){


    int j = skip_ws( s, i );
    //System.out.println( "I is " + i + " J is " + j + " For:" + s + " " + s.length() );
    String leadingWs = s.substring( i, j );
    if( leadingWs.length() &gt; 0 );
    else;
    
    out.add( leadingWs + "@others\n" );
    endSentinelStack.add( endOthers );


}



@
def readStartOthers (self,s,i):
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20070127142814.1065">public void readEndAll( String s, int i ) {

    popSentinelStack( endAll );

}


@
def readEndAll (self,s,i):
    """Read an @-all sentinel."""
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20070127142814.1066">public void readEndAt( String s, int i ){

    readLastDocLine( "@" );
    popSentinelStack( endAt );
    inCode = true;



}


@
def readEndAt (self,s,i):
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
@c

public void readEndDoc( String s, int i ){


    readLastDocLine( "@doc" );
    popSentinelStack( endDoc );
    inCode = true;


}



@        
def readEndDoc (self,s,i):
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20070127142814.1067">public void readEndLeo( String s, int i ){

    while( true ){
    
        //s = readLine( inputFile );
        s = readLine();
        if( s == null ) s = "";
        if( s.length() == 0 ) break;
        lastLines.add( s );
    
    }
    
    done = true;

}

@
def readEndLeo (self,s,i):
    """Read an @-leo sentinel."""
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20070127142814.1068">public void readEndMiddle( String s, int i ){


    readEndNode( s, i , true );


}


@
def readEndMiddle (self,s,i):
    """Read an @-middle sentinel."""
    at = self
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20070127142814.1069">public void readEndNode( String s, int i, boolean middle ){

    raw = false;
    //System.out.println( "Out is " + out );
    s = join( "", out );

    if( importing )    
        t_op.insert( t, 0, s );//t._bodyString.insert( 0, s );
    else if( middle );
    else{
        
        String old;
        boolean _hasBody = t_op.hasBody( t );
        boolean _hasTempBody = t_op.hasTempBodyString( t );
        String _body = t_op.getBody( t );
        if( _hasTempBody &amp;&amp; !s.equals( t_op.getTempBodyString( t ) )) //t.getTempBodyString() ) )
            old = t_op.getTempBodyString( t ); //old = t.getTempBodyString();
        else if( _hasBody &amp;&amp; !s.equals( _body ) )
            old = _body; //t_op.getBody( t );//old = t.getBody();
        else
            old = "";
            
        if( old.length() &gt; 0 &amp;&amp; t != root.get_T() ){
        
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        
        
        }
        //System.out.println( "SETTING TEMP FOR " + t_op.getHeadString( t ) );
        t_op.setTempBodyString( t, s ); //t.setTempBodyString( s );
        
    }
    
    t_op.setVisited( t ); //t.setVisited();
    indent = indentStack.remove( outStack.size() -1 );
    out = outStack.remove( outStack.size() -1 );
    t = tStack.remove( tStack.size() - 1 );
    if( thinFile &amp;&amp; !importing ) lastThinNode = thinNodeStack.remove( thinNodeStack.size() - 1 );
    
    
    popSentinelStack( endNode );
    
    
}


@
def readEndNode (self,s,i,middle=False):
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = at.c
    # End raw mode.
    at.raw = False
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle:
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        #if at.t.headString == "NewHeadline2": raise Exception()
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20070127142814.1070">
 &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
@
if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
@c
if( !updateWarningGiven ) updateWarningGiven = true;
t_op.setDirty( t );//t.setDirty();
c.setChanged2( true );</t>
<t tx="ekr.20070127142814.1071">@

# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20070127142814.1072">public void readEndOthers( String s, int i ){


    popSentinelStack( endOthers );

}


@
def readEndOthers (self,s,i):
    """Read an @-others sentinel."""
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20070127142814.1073">public void readAfterRef( String s, int i ){

    //s = readLine( inputFile );
    s = readLine();
    out.add( s );

}

@
def  readAfterRef (self,s,i):
    """Read an @afterref sentinel."""
    at = self
    assert(g.match(s,i,"afterref"))
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20070127142814.1074">public void readClone( String s, int i ){

    String tag = "clone";
    i = skip_ws( s, i + tag.length() );
    Integer[] data = skip_long( s, i );
    Integer junk = data[ 0 ];
    Integer val = data[ 1 ];
    
    if( val == null ) readError( "Invalid count in @clone sentinel" );
    else cloneSibCount = val;

}

@
def readClone (self,s,i):
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20070127142814.1075">public void readComment( String s, int i ){



}

@
def readComment (self,s,i):
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20070127142814.1076">public void readDelims( String s, int i ){

    int i0 = i - 1;
    i = skip_ws( s, i -1 + 7 );

    int j = i;
    while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) ) i += 1;
    
    if( j &lt; i ){
        
        startSentinelComment = s.substring( j, i );
        j = i = skip_ws( s, i );
        while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) ) i += 1;
        
        String end = j &lt; i? s.substring( j, i ): "";
        int i2 = skip_ws( s, i );
        if( end.equals( endSentinelComment ) &amp;&amp; ( i2 &gt;= s.length() || is_nl( s, i2 ) ) ){
        
            endSentinelComment = "";
            String line = s.substring( i0, j );
            line = rtrim ( line );
            out.add( line + '\n' );       
        
        }
        else{
        
            endSentinelComment = end;
            String line = s.substring( i0, i );
            line = rtrim( line );
            out.add( line + '\n' );
                
        }
    
    }
    else{
    
        readError( "Bad @delims" );
        out.add( "@delims" );
    
    }

}


@
def readDelims (self,s,i):
    """Read an @delims sentinel."""
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20070127142814.1077">public void readDirective( String s, int i ){


    if( match_word( s,i, "@raw" ) ) raw = true;
    else if( match_word( s, i, "@end_raw" ) ) raw = false;
    
    String e = endSentinelComment;
    String s2 = s.substring( i );
    if( e.length() &gt; 0 ){
    
        int k = s.lastIndexOf( e, i );
        if( k != -1 ) s2 = s.substring( i, k ) + '\n';
    
    
    }
    
    String start = startSentinelComment;
    if( start.length() &gt; 0 &amp;&amp; start.charAt( start.length() -1 ) != '@' )
        s2 = s2.replace( "@@", "@" );
        
    
    out.add( s2 );

}

&lt;&lt; handle @language &gt;&gt;
&lt;&lt; handle @comment &gt;&gt;
@
def readDirective (self,s,i):
    """Read an @@sentinel."""
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    # g.trace(g.get_line(s,i))
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20070127142814.1078">@
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20070127142814.1079">@
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20070127142814.1080">public void readNl( String s, int i ){

    if( inCode ) out.add( "\n" );
    else docOut.add( "\n" );


}

@
def readNl (self,s,i):
    """Handle an @nonl sentinel."""
    at = self
    assert(g.match(s,i,"nl"))
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20070127142814.1081">public void readNonl( String s, int i ){


    if( inCode ){
        String s2 = s;
        s = join( "", out );
        //System.out.println( s.substring( i, i + 4 ) );
        //System.out.println( s );
        if( s.length() &gt; 0 &amp;&amp; s.charAt( s.length() - 1 ) == '\n' ){
        
            out = new ArrayList();
            out.add( s.substring( 0, s.length() -1 ) );
        
        }
        else{
            System.out.println( s.charAt( s.length() -1 ) );
            System.out.println( s );
            System.out.println( s2 );
            readError( "unexpected @nonl directive in code part");
    
        }
    }
    else{
    
        s = join( "" , pending );
        if( s.length() &gt; 0 ){
        
            if( s.length() &gt; 0 &amp;&amp; s.charAt( s.length() - 1 ) == '\n' ){
            
                pending = new ArrayList&lt;String&gt;();
                pending.add( s.substring( 0, s.length() - 1 ) );
            
            
            }
            else readError( "unexpected @nonl directive in pending doc part"); 
        
        
        
        }
        else{
        
            s = join( "", docOut );
            if( s.length() &gt; 0 &amp;&amp; s.charAt( s.length() - 1 ) == '\n' ){
            
                docOut = new ArrayList&lt; String &gt;();
                docOut.add( s.substring( 0, s.length() - 1 ) );  
            
            
            }
            else readError( "unexpected @nonl directive in doc part"); 
        
        }
    
    
    }


}


@
def readNonl (self,s,i):
    """Handle an @nonl sentinel."""
    at = self
    assert(g.match(s,i,"nonl"))
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20070127142814.1082">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

public void readRef( String s, int i ){

    int j = skip_ws( s, i );
    
    String line;
    if( endSentinelComment.length() == 0 ) line = s.substring( i, s.length() -1 ) ;
    else{
        
        int k = s.indexOf( endSentinelComment, i );
        line = s.substring( i, k );
        
    }
    
    String start = startSentinelComment;
    if( start.length() &gt; 0 &amp;&amp; start.charAt( start.length() -1 ) != '@' )
        line = line.replace( "@@", "@" );

    //System.out.println( "LINErEf:" + line );
    out.add( line );
    //System.out.println( "REF OUT:" + out );

}


@
def readRef (self,s,i):
    """Handle an @&lt;&lt; sentinel."""
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20070127142814.1083">public void readVerbatim( String s, int i ){

    //s = readLine( inputFile );
    s = readLine();
    i = skipIndent( s, 0, indent );
    out.add( s.substring( i ) );

}


@
def readVerbatim (self,s,i):
    """Read an @verbatim sentinel."""
    at = self
    assert(g.match(s,i,"verbatim"))
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20070127142814.1084">public void readLastDocLine( String tag ){

    String end = endSentinelComment;
    String start = startSentinelComment;
    String s = join( "", docOut );
    //System.out.println( "S:" + s );
    if( match( s, 0, tag ) )
        s = s.substring( tag.length() );
    else
        readError( "Missing start of doc part");
    
    //System.out.println( "END:" + end );
    //System.out.println( "START:" + start );
    //System.out.println( "RLDL HERE 1" ); 
    if( end.length() &gt; 0 ){
    
        if( s.charAt( 0 ) == '\n' )  s = s.substring( 1 );
    
        if( match( s, 0, start ) ) s = s.substring( start.length() );
        else{
            readError("Missing start of doc part");
            return;
        
        }
        //System.out.println( " RLDL HERE -5" );
        if( s.charAt( s.length() -1 ) == '\n' ) s = s.substring( 0, s.length() -1 );
        
        if( s.endsWith( end ) )
            s = s.substring( 0, s.lastIndexOf( end ) );
        else{
        
            readError("Missing close block comment");
            return;
        
        
        }
    
    }
    //System.out.println( "RLDL HERE 12" ); 
    out.add( tag + s );
    docOut = new ArrayList&lt; String &gt;();    

}


@
def readLastDocLine (self,tag):
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []</t>
<t tx="ekr.20070127142814.1085">public void ignoreOldSentinel( String s, int i ){



}



@
def  ignoreOldSentinel (self,s,i):
    """Ignore an 3.x sentinel."""
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20070127142814.1086">public List&lt;String&gt; scanText4( File theFile, String fileName, PositionSpecification p ){

@
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]
@c
    //System.out.println( "P is " + p );
    //System.out.println( "INCode was " + inCode );
    done = false;
    cloneSibCount = 0;
    inCode = true;
    indent = 0;
    leadingWs = "";
    out = new ArrayList&lt; String &gt;();
    outStack = new ArrayList&lt; List&lt;String &gt; &gt;();
    endSentinelStack = new ArrayList&lt; AtFileConstants &gt;(); endSentinelStack.add( endLeo );
    t = p.get_T(); tStack = new ArrayList();
    lastThinNode = p.get_V(); 
    thinNodeStack = new ArrayList();
    thinNodeStack.add( p.get_V() );
    
    
    while( errors == 0 &amp;&amp; !done ){
    
        //String s = readLine( theFile );
        //System.out.println( "PRE READ!" );
        String s = readLine();
        if( s == null ){
            //System.out.println( "DONE READING!" );
            s = "";
        
        }
        if( s.length() == 0 ) break;
        AtFileConstants kind = sentinelKind4( s );
        int i;
        if( kind == noSentinel ) i = 0;
        else i = skipSentinelStart4(s,0);
        //System.out.println( "S:" + s );
        //System.out.println( "DISPATCHING " + kind );
        dispatch( kind, s, i );
        //System.out.println( "DONE DISPATCHING " + kind );        
        
        }
        
        //System.out.println( "FINISHED SCANTEXT4!" );
        return lastLines;
    }
</t>
<t tx="ekr.20070127142814.1087">@
def sentinelKind4(self,s):
    """Return the kind of sentinel at s."""
    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')
    # 4.0: Look ahead for @[ws]@others and @[ws]&lt;&lt;
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j &gt; i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"&lt;&lt;"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@&lt;&lt;"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) &gt; 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel</t>
<t tx="ekr.20070127142814.1088">public AtFileConstants sentinelKind4( String s ){

    char[] ca = s.toCharArray();
    
    int i = skip_ws( s, 0 );

    if( s.substring( i ).startsWith( startSentinelComment ) )
        i += startSentinelComment.length();
    else
        return AtFileConstants.noSentinel;
    
    String start = startSentinelComment;
    int sl = start.length();
    if( sl &gt; 0 &amp;&amp; start.charAt( sl - 1 ) == '@' )
        s = s.substring( 0, i ) + s.substring( i ).replace( "@@", "@" );
        
    int j;
    if( match( s, i , "@" ) ){
    
        j = skip_ws( s, i + 1 );
        if( j &gt; i + 1 ){
        
            if( match( s, j, "@+others" ) ) return AtFileConstants.startOthers;
            else if( match( s, j, "&lt;&lt;" ) ) return AtFileConstants.startRef;
            else return AtFileConstants.noSentinel;
        
        
        }  
    }
    
    if( match( s, i , "@&lt;&lt;" ) ) return AtFileConstants.startRef;
    if( match( s, i, "@@" ) ) return AtFileConstants.startDirective;
    if( !match( s, i , "@" ) ) return AtFileConstants.noSentinel;
    
    j = i;
    i += 1;
    
    if( match( s, i, "+" ) || match( s, i, "-" ) ) i += 1;
    //if g.match(s,i,'+') or g.match(s,i,'-'):
    //    i += 1
    
    //i = g.skip_c_id(s,i) 
    i = skip_c_id( s, i );
    String key = s.substring( j, i );
    if( sentinelDict.containsKey( key ) ) return sentinelDict.get( key );
    else
        return AtFileConstants.noSentinel;

}







</t>
<t tx="ekr.20070127142814.1089">public String rtrim( String s ){

    StringBuilder sb = new StringBuilder( s );
    sb.reverse();
    String trim = sb.toString();
    for( char ch: trim.toCharArray() ){
        
        if( Character.isWhitespace( ch ) ) sb.deleteCharAt( 0 );
        else break;
        
    }
    sb.reverse();
    return sb.toString();


}</t>
<t tx="ekr.20070127142814.1090">public String join( String joinstring, List&lt;String&gt; l ){

    StringBuilder sb = new StringBuilder();
    for( String s: l ){
    
        sb.append( s ).append( joinstring );
    
    }

    int lind = sb.lastIndexOf( joinstring );
    sb.delete( lind, sb.length() );
    return sb.toString();

}</t>
<t tx="ekr.20070127142814.1091">public void readError( String error ){


    err.println( error );


}</t>
<t tx="ekr.20070127142814.1092">public String readLine(){

    String line = null;
    try{
        
        if( raFile == null )
            System.out.println( "RAFILE is " + raFile );
        line = raFile.readLine();
        if( line != null ) line = line + '\n';
        //System.out.println( "LINE:" + line );
        else line = "";
        
    }
    catch( IOException io ){}
    
    return line;


}</t>
<t tx="ekr.20070127142814.1093">public void popSentinelStack( AtFileConstants expectedKind ){

    if( endSentinelStack.size() &gt; 0 &amp;&amp; endSentinelStack.get( endSentinelStack.size() - 1 ) == expectedKind )
        endSentinelStack.remove( endSentinelStack.size() -1 );
    else
        badEndSentinel( expectedKind );


}

public void badEndSentinel( AtFileConstants expectedKind ){


    readError( "Bad Sentinel, was expecting " + expectedKind );


}

@
def badEndSentinel (self,expectedKind):
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
def popSentinelStack (self,expectedKind):
    """Pop an entry from endSentinelStack and check it."""
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20070127142814.1094">public Object[] scanHeader( String fileName ){


    List&lt; String &gt; firstLines = new ArrayList&lt; String &gt;();
    String tag = "@+leo";
    boolean valid = true; boolean new_df = false; boolean isThinDerivedFile = false;
@
s = at.readLine(theFile)
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
n = len(s)
valid = n &gt; 0
@c
    String s = readLine();
    while( s.length() &gt; 0 ){
    
        int j = s.indexOf( tag );
        if( j != -1 ) break;
        firstLines.add( s );
        s = readLine();
    
    
    
    }
    int n = s.length();
    valid = n &gt; 0;
    String start = "", end = "";
    if( valid ){
    
        Object[] rv = parseLeoSentinel( s );
        valid = (Boolean)rv[ 0 ];
        new_df = (Boolean)rv[ 1 ];
        start = (String)rv[ 2 ];
        end = (String)rv[ 3 ];
        isThinDerivedFile = (Boolean)rv[ 4 ];
    
    
    }
    if( valid ){
    
        startSentinelComment = start;
        endSentinelComment = end;
    
    }
    else
        err.println("Bad @+leo sentinel in " + fileName);
        
    return new Object[]{ firstLines, new_df, isThinDerivedFile };
}

&lt;&lt; skip any non @+leo lines &gt;&gt;
@
def scanHeader(self,theFile,fileName):
    """Scan the @+leo sentinel.
    Sets self.encoding, and self.start/endSentinelComment.
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in " + fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile</t>
<t tx="ekr.20070127142814.1095">@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c
@
s = at.readLine(theFile)
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20070127142814.1096">public Object[] parseLeoSentinel( String s ){


    boolean new_df = false; boolean valid = true; int n = s.length();
    boolean isThinDerivedFile = false;
    String encoding_tag = "-encoding=";
    String version_tag = "-ver=";
    String tag = "@+leo";
    String thin_tag = "-thin";
    String start= ""; String end = "";
    
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    return new Object[]{ valid, new_df, start, end, isThinDerivedFile };

}

@
def parseLeoSentinel (self,s):
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    return valid,new_df,start,end,isThinDerivedFile</t>
<t tx="ekr.20070127142814.1097">int i, j;
i = j = skip_ws( s, 0 );
while( i &lt; n &amp;&amp; ! match( s, i , tag ) &amp;&amp; !is_nl( s, i ) ) i += 1;

if( j&lt; i ) start = s.substring( j, i );
else valid = false;


@
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    start = s[j:i]
else:
    valid = False</t>
<t tx="ekr.20070127142814.1098">@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c


if( match( s, i , tag ) ) i += tag.length();
else valid = false;


@
if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False</t>
<t tx="ekr.20070127142814.1099">new_df = match( s,i, version_tag );
if( new_df ){

    i += version_tag.length();
    j = i;
    while( i &lt; s.length() &amp;&amp; ! is_nl( s, i ) &amp;&amp; s.charAt( i ) != '-' ) i += 1;


    if( j &lt; i );
    else valid = false;

}

@
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i &lt; len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j &lt; i:
        pass # version = s[j:i]
    else:
        valid = False
</t>
<t tx="ekr.20070127142814.1100">if( match( s, i, thin_tag ) ){

    i += tag.length();
    isThinDerivedFile = true;


}


@
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True</t>
<t tx="ekr.20070127142814.1101">this.encoding = c.acquireDefault_derived_file_encoding();
String encoding = null;

if( match( s, i, encoding_tag ) ){

    i += encoding_tag.length();
    j = s.indexOf( ",.", i );
    if( j &gt; -1 ) i = j + 1;
    else{
    
        j = s.indexOf( ".", i );
        if( j &gt; -1 ){
        
            encoding = s.substring( i, j );
            i = j + 1;
        
        
        }    
        else encoding = null;
    
    }

    if( encoding != null ){
    
        if( c.g_isValidEncoding( encoding ) ) this.encoding = encoding;
        else err.println( "bad encoding in derived file:" + encoding );
    
    
    }
    else valid = false;

}


@
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j &gt; -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 1 # 6/8/04
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j &gt; -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
</t>
<t tx="ekr.20070127142814.1102">i = j = skip_ws( s, i );
while( i &lt; n &amp;&amp; ! is_ws( s.charAt( i ) ) &amp;&amp; ! is_nl( s, i ) ) i += 1;

//System.out.println( "J " + j + " I " + i );
end = s.substring( j, i );


@
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]</t>
<t tx="ekr.20070127142814.1103"></t>
<t tx="ekr.20070127142814.1104">public abstract Object createThinChild4( String gnxString, String headline );


@
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #print "GNX is %s" % ( gnx, )
    #print "GNXSTRING IS %s" % gnxString
    if len( self._forcedGnxPositionList ) != 0 and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
    if 0:
        g.trace("last",last,last.t.fileIndex)
g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20070127142814.1105">public abstract PositionSpecification createImportedNode( PositionSpecification root, CommanderSpecification c, String headline );

@
def createImportedNode (self,root,c,headline):
    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p</t>
<t tx="ekr.20070127142814.1106">public abstract Object findChild4( String headline );



@
def findChild4 (self,headline):
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t</t>
<t tx="ekr.20070127142814.1107">@others
</t>
<t tx="ekr.20070127142814.1108">public int skipIndent( String s, int i, int width ){

    int ws = 0; int n = s.length();
    while( i &lt; n &amp;&amp; ws &lt; width ){
    
        if( s.charAt( i ) == '\t' ) ws += ( abs( tab_width ) - ( ws % abs( tab_width ) ) );
        else if( s.charAt( i ) == ' ' ) ws += 1;
        else break;
        i += 1;
    
    
    }

    return i;




}

@
def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i &lt; n and ws &lt; width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i</t>
<t tx="ekr.20070127142814.1109">public Integer[] skip_long( String s, int i ){

    int val = 0;
    i = skip_ws( s, i );
    int n = s.length();
    char _cai = s.charAt( i );
    if( i &gt; n || ( _cai != '+' || _cai != '-' || !Character.isDigit( _cai ) ) )
        return new Integer[]{ i, null };
        
    int j = i;
    if( _cai == '+' || _cai == '-' ) i +=1;
    while( i &lt; n &amp;&amp; Character.isDigit( s.charAt( i ) ) ) i += 1;
    try{
        
        val = Integer.valueOf( s.substring( j, i ) );
        return new Integer[]{ i, val };
    
    }
    catch( Exception x ){
    
        return new Integer[]{ i, null };
    
    }
    
}


@
def skip_long(s,i):
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i &lt; n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20070127142814.1110">public int skipSentinelStart4( String s, int i ){

    String start = startSentinelComment;
    i = skip_ws( s, i );
    i += start.length();
    i = skip_ws( s, i );
    return i + 1;


}


@
def skipSentinelStart4(self,s,i):
    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)&gt;0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i &lt; len(s) and s[i] == '@')
    return i + 1
</t>
<t tx="ekr.20070127142814.1111">private final int skip_ws( final String s, final int i ){

    final char[] cs = s.toCharArray();
    int ri = i;
    for( ; ri &lt; cs.length; ri ++ )
        if( cs[ ri ] == '\t' || cs[ ri ] == ' ' )
            continue;
        else
            break;
    return ri;
    


}

public final int skip_line( final String s, final int i ){

    final int where = s.indexOf( '\n', i );
    if( where == -1 ) return s.length();
    else
        return where + 1;


}

@
def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
@c

private final boolean match( final String s, final int i, final String pattern ){

    final int plength = pattern.length();
    if ( i + plength &gt; s.length() ) return false;
    
    final String sub = s.substring( i, i + plength );
    return sub.equals( pattern );


}

@
def match(s,i,pattern):
    #print 'pattern is: %s' % pattern
    #s2 = s[ i: i + len( pattern ) ]
    #print '%s , %s, %s, %s, %s' %( pattern, s2, s2 == pattern , len( s2 ), len( pattern ))
    #print s[ i: i + len( pattern ) ] == s
    #print jsys.currentTimeMillis()
    return s and pattern and s[ i: i + len( pattern ) ] == pattern
@c

private final boolean match_word( final String s, int i, final String pattern ){

    //if( pattern.equals( "@others" ) ) System.out.println( "LOOKING FOR OTHERS in: " + s + " at  " + i );
    if( pattern == null ) return false;
    final int j = pattern.length();
    //final int slen = s.length();
    //final int ij = i + j;
    //if( i + j &gt;= s.length() ) return true;
    //if( i + j &gt;= s.length() ) return true;
    if( j == 0 ) return false;
    if( s.substring( i ).startsWith( pattern ) ) return true;
    else
        return false;
    //if( slen &lt; ij )
    //    if( ! s.substring( i ).equals( pattern ) ) return false;
    //else
    //    if( !s.substring( i, ij ).equals( pattern ) ) return false;
    //if( ij &gt;= slen ) return true;
    //final char c = s.charAt( i + j );
    //return !( Character.isLetterOrDigit( c ) || c ==  '_' );


}

@
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s[ i: i + j ] != pattern:
        return False
    #if string.find(s,pattern,i,i+j) != i:
    #    return False
    if i+j &gt;= len(s):
        return True
    c = s[i+j]
    return not( c.isalnum() or c == '_' )
    #return not (c in string.ascii_letters or c in string.digits or c == '_')
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None
@c

public int find_on_line( final String s, final int i, final String pattern ){


    int nw = s.substring( i ).indexOf( '\n' );
    if( nw == -1 ) nw = s.length();
    final int k = s.substring( i, nw ).indexOf( pattern );
    return k;




}

@
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
@c
public int skip_to_end_of_line( final String s, int i ){

    i = s.indexOf( '\n', i );
    if( i == -1 ) return s.length();
    else return i;



}

@
def skip_c_id(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
@c

public int skip_c_id( final String s, int i ){

    final int n = s.length();
    while( i &lt; n ){
    
        final char c = s.charAt( i );
        if( Character.isLetterOrDigit( c ) || c == '_' ) i += 1;
        else break;
    
    
    }

    return i;

}

@others
</t>
<t tx="ekr.20070127142814.1112">public String[] set_delims_from_string( final String s ){

    final String tag = "@comment";
    int i = 0;
    if( match_word( s, i, tag ) )
        i += tag.length();
    
    int count = 0;
    final String[] delims = new String[ 3 ];
    
    while( count &lt; 3 &amp;&amp; i &lt; s.length() ){
    
        int j = i = skip_ws( s, i );
        while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) )
             i += 1;
        if( j == i ) break;
        delims[ count ] = s.substring( j, i );
        count++;
    
    }
    
    if( count == 2 ){
        delims[2] = delims[1];
        delims[1] = delims[0];
        delims[0] = null;
    
    
    }

    for( int x = 0; x &lt; 3; x ++ ){
    
        if( delims[ x ] != null ){
        
            //delims[i] = string.replace(delims[i],"__",'\n') 
            //delims[i] = string.replace(delims[i],'_',' ')
            delims[ x ] =  delims[ x ].replace( "__", "\n" );
            delims[ x ] =  delims[ x ].replace( "_", " " );
        
        }
    
    
    
    }
    return delims;

}

@
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n')
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20070127142814.1113">

public String[] set_delims_from_language( final String language ){

    final String val = leoBaseAtFile.language_delims_dict.get( language );
    if( val != null ){
        final String[] delims = set_delims_from_string( val );
        if( delims[ 1 ] != null &amp;&amp; delims[ 2 ] == null )
            return new String[]{ null, delims[ 0 ], delims[ 1 ] };
        else
            return delims;
    
    
    }
    else
        return new String[ 3 ];

}

@
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made

</t>
<t tx="ekr.20070127142814.1114">@
def is_ws(c):

    return c == '\t' or c == ' '
@c

public boolean is_ws( final char c ){


    return c == '\t' || c == ' ';


}

@
def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')
@c

public boolean is_nl( final String s, final int i ){
    

    return i &lt; s.length() &amp;&amp; ( s.charAt( i ) == '\n' || s.charAt( i ) == '\r' );



}


@
def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
@c

public int skip_nl( final String s, final int i ){

    if( match( s, i, "\r\n" ) ) return i + 2;
    else if ( match( s, i, "\n" ) || match( s, i, "\r" ) ) return i + 1;
    else return i;


}</t>
<t tx="ekr.20070127142814.1115">public int[] skip_leading_ws_with_indent( final String s, int i, final int tab_width ){

    int count = 0; final int n = s.length();
    while( i &lt; n ){
    
        final char ch = s.charAt( i );
        if( ch == ' ' ){
        
            count += 1;
            i += 1;
        
        }
        else if( ch == '\t' ){
        
            count += (abs(tab_width ) - ( count % abs( tab_width ) ) );
            i += 1;
        
        
        }
        else break;
    
    
    
    }
    return new int[]{ i, count };


}



@
def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent),
    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count</t>
<t tx="ekr.20070127142814.1116">public String removeLeadingWhitespace( String s, int first_ws, int tab_width ){

    int j = 0; int ws = 0;
    //System.out.println( "FIRST_WS is " + first_ws );
    final char[] ca = s.toCharArray();
    for( final char ch: ca ){
        if( ws &gt;= first_ws ) break;
        else if( ch == ' ' ){
        
            j += 1;
            ws += 1;
        
        
        }
        else if( ch == '\t' ){
            j += 1;
            ws += (abs( tab_width ) - ( ws % abs( tab_width ) ) );
        
        }
        else break;
    
    }
    if( j &gt; 0 ) s = s.substring( j );
    return s;


}




@
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j &gt; 0:
        s = s[j:]
    return s</t>
<t tx="ekr.20070127142814.1117">@language java

import java.util.*;
import java.io.*;
import static java.lang.System.out;
import static java.lang.String.format;  
import static java.lang.Math.*;

public abstract class leoBaseAtFile{           
private int loopcounter;
private StringBuilder _sb;
private String _language;
private boolean _sentinels;
private boolean _toString;
private boolean _raw;
private boolean _thinFile;
private boolean _fileChangedFlag;
private boolean _writeAtFileNodesFlag;
private boolean _writeDirtyAtFileNodesFlag;
private Boolean _explicitLineEnding;
private Boolean _inCode;
private Boolean _root_seen;

private String _targetFileName;  
private String _outputFileName;
private String _default_directory;
private String _startSentinelComment;
private String _endSentinelComment;
private String _leadingWs;
private String _encoding;
private String _stringOutput;
private String _shortFileName;
private Integer _docKind;
private Integer _docDirective;
private Integer _page_width;
private List&lt; String &gt; _pending;
private int _indent;
private Integer _tabWidth;
private int _errors;
private String _output_newline = "\n";
private OutputStream _outputStream;
private Object _outputFile;
private PositionSpecification _root;
private CommanderSpecification _c;

static final Map&lt; String, String &gt; language_delims_dict = new HashMap&lt; String, String &gt;();
static final Map&lt; String, Integer &gt; table = new HashMap&lt; String, Integer &gt;();
public final static int noDirective		   =  1;
public final static int allDirective    =  2;
public final static int docDirective	   =  3;
public final static int atDirective		   =  4;
public final static int codeDirective	  =  5;
public final static int cDirective		    =  6;
public final static int othersDirective	=  7;
public final static int miscDirective	  =  8;
public final static int rawDirective    =  9;
public final static int endRawDirective = 10;    

public final static String[] leoKeywords = {
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" };


    /*public void setOutputFileX( String name ){  

        _sb = new StringBuilder();


    }*/




    /*public String getData(){


        return _sb.toString();

    }*/
    


    
    @others


}</t>
<t tx="ekr.20070127142814.1118"></t>
<t tx="ekr.20070127142814.1119">


    
    public void setIndent( final int i ){
    
        _indent = i;
    
    }
    
    public int getIndent(){
    
    
        return _indent;
    
    }
    
    public void setRaw( final boolean b ){
    
        _raw = b;
    
    }
    
    public boolean getRaw(){
    
    
        return _raw;
    
    }
    
    public void setThinFile( final boolean b ){
    
        _thinFile = b;
    
    }
    
    public boolean getThinFile(){
    
        return _thinFile;
    
    }
    
    public void setLeadingWs( final String s ){
    
        _leadingWs = s;
    
    }
    
    public String getLeadingWs(){
    
        return _leadingWs;
    
    }
    
    public void setEncoding( final String s ){
    
        _encoding = s;
    
    
    }
    
    public String getEncoding(){
    
    
        return _encoding;
    
    }
    
    public void setTab_width( final Integer w ){
    
        if( w == null )
            _tabWidth = 0;
        else
            _tabWidth = w;
    
    }
    
    public Integer getTab_width(){
    
        return _tabWidth;
    
    
    }</t>
<t tx="ekr.20070127142814.1120">public void setLanguage( final String s ){
    
    _language = s;
    
}
    
public String getLanguage(){ return _language; }</t>
<t tx="ekr.20070127142814.1121">public final void setSentinels( final boolean sentinel ){
    
    _sentinels = sentinel;
    
    
}
    
public final boolean getSentinels(){
    
    return _sentinels;
    
}


public final void setToString( final boolean ts ){
    
    _toString = ts;
    
    
}
    
public final boolean getToString(){
    
    return _toString;
    
}</t>
<t tx="ekr.20070127142814.1122">public void setStartSentinelComment( final String s ){
    
    _startSentinelComment = s;
    
}
    
public String getStartSentinelComment(){
    
    return _startSentinelComment;
    
}</t>
<t tx="ekr.20070127142814.1123">public void setEndSentinelComment( final String s ){
    
    _endSentinelComment = s;
    
}
    
public String getEndSentinelComment(){
    
    return _endSentinelComment;
    
    }</t>
<t tx="ekr.20070127142814.1124">public void setOutputStream( OutputStream os ){

    _outputStream = os;


}

public OutputStream getOutputStream(){


    return _outputStream;


}</t>
<t tx="ekr.20070127142814.1125">public void setOutput_newline( final String s ){

    _output_newline = s;


}

public String getOutput_newline(){


    return _output_newline;

}</t>
<t tx="ekr.20070127142814.1126">public final void setTargetFileName( final String name ){

    _targetFileName = name;


}

public String getTargetFileName(){


    return _targetFileName;


}</t>
<t tx="ekr.20070127142814.1127">public final void setOutputFileName( final String name ){

    _outputFileName = name;


}

public final String getOutputFileName(){


    return _outputFileName;


}</t>
<t tx="ekr.20070127142814.1128">public void setRoot( PositionSpecification root ){

    _root = root.copy();

}


public PositionSpecification getRoot(){


    return _root.copy();


}</t>
<t tx="ekr.20070127142814.1129">public final int getErrors(){

    return _errors;

}


public final void setErrors( int err ){


    _errors = err;


}</t>
<t tx="ekr.20070127142814.1130">public final void setC( final CommanderSpecification c ){


    _c = c;



}


public final CommanderSpecification getC(){

    return _c;
    

}</t>
<t tx="ekr.20070127142814.1131">public final void setFileChangedFlag( final boolean changed ){

    _fileChangedFlag = changed;


}

public final boolean getFileChangedFlag(){

    return _fileChangedFlag;


}</t>
<t tx="ekr.20070127142814.1132">public final void setWriteAtFileNodesFlag( final boolean flag ){


    _writeAtFileNodesFlag = flag;

}

public final boolean getWriteAtFileNodesFlag(){


    return _writeAtFileNodesFlag;


}</t>
<t tx="ekr.20070127142814.1133">public final void setWriteDirtyAtFileNodesFlag( final boolean flag ){


    _writeDirtyAtFileNodesFlag = flag;


}


public final boolean getWriteDirtyAtFileNodesFlag(){

    return _writeDirtyAtFileNodesFlag;


}</t>
<t tx="ekr.20070127142814.1134">public final void setDocKind( final Integer kind ){

    _docKind = kind;


}

public final Integer getDocKind(){

    return _docKind;


}

public final void setDocDirective( final Integer directive ){

    _docDirective = directive;


}

public final Integer getDocDirective(){

    return _docDirective;


}</t>
<t tx="ekr.20070127142814.1135">public final void setPending( final List&lt; String &gt; pending ){

    //if( pending == null ) _pending = null;
    //else
    //    _pending = new ArrayList&lt; String &gt;();
    //    Collections.addAll( _pending, pending );
    _pending = pending;



}


public final List&lt; String &gt; getPending(){


    return  _pending;



}</t>
<t tx="ekr.20070127142814.1136">public final void setPage_width( final Integer width ){


    _page_width = width;


}


public final Integer getPage_width(){



    return _page_width;



}</t>
<t tx="ekr.20070127142814.1137">public final void setDefault_directory( final String dir ){


    _default_directory = dir;


}


public final String getDefault_directory(){



    return _default_directory;



}</t>
<t tx="ekr.20070127142814.1138">public final void setExplicitLineEnding( final Boolean flag ){


    _explicitLineEnding = flag;


}

public final Boolean getExplicitLineEnding(){


    return _explicitLineEnding;


}</t>
<t tx="ekr.20070127142814.1139">public final void setStringOutput( final String data ){

    _stringOutput = data;


}

public final String getStringOutput(){


    return _stringOutput;


}</t>
<t tx="ekr.20070127142814.1140">public final void setShortFileName( final String name ){

    _shortFileName = name;


}


public final String getShortFileName(){


    return _shortFileName;


}</t>
<t tx="ekr.20070127142814.1141">public final void setOutputFile( final Object of ){

    _outputFile = of;


}

public final Object getOutputFile(){


    return _outputFile;


}</t>
<t tx="ekr.20070127142814.1142">public final void setInCode( final Boolean flag ){


    _inCode = flag;



}

public final Boolean getInCode(){


    return _inCode;


}</t>
<t tx="ekr.20070127142814.1143">public final void setRoot_seen( final Boolean flag ){


    _root_seen = flag;


}

public final Boolean getRoot_seen(){


    return _root_seen;



}</t>
<t tx="ekr.20070127142814.1144">
//static Map&lt; String, String &gt; language_delims_dict = new HashMap&lt; String, String &gt;();

static{
final Map&lt; String, String &gt; ldd = language_delims_dict;

ldd.put("ada" , "--" );
ldd.put( "actionscript" , "// /* */" ); ///#jason 2003-07-03
ldd.put( "c" , "// /* */" ); // # C, C++ or objective C.
ldd.put( "csharp" , "// /* */" ); //,	# C#
ldd.put( "css" , "/* */" ); //, # 4/1/04
ldd.put( "cweb" , "@q@ @&gt;" ); //, # Use the "cweb hack"
ldd.put( "elisp" , ";" );
ldd.put( "forth" , "\\_ _(_ _)" ); //, # Use the "REM hack"
ldd.put( "fortran" , "C" );
ldd.put( "fortran90" , "!" );
ldd.put( "html" , "&lt;!-- --&gt;" );
ldd.put( "java" , "// /* */" );
ldd.put( "latex" , "%" );
ldd.put( "pascal" , "// { }" );
ldd.put( "perl" , "#" );
ldd.put( "perlpod" , "# __=pod__ __=cut__"); //, # 9/25/02: The perlpod hack.
ldd.put( "php" , "//" ); //
ldd.put( "plain" , "#" ); //, # We must pick something.
ldd.put( "python" , "#" );
ldd.put( "rapidq" , "'" );//, # fil 2004-march-11
ldd.put( "rebol" , ";" ); //,  # jason 2003-07-03
ldd.put( "shell" , "#" ); //,  # shell scripts
ldd.put( "tcltk" , "#" );
ldd.put( "unknown" , "#" );// # Set when @comment is seen.
}
@
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.</t>
<t tx="ekr.20070127142814.1145">static{
    //Map&lt; String, Integer &gt; table = new HashMap&lt; String, Integer &gt;();
    table.put( "@all", allDirective );
    table.put( "@c", cDirective );
    table.put( "@code", codeDirective );
    table.put( "@doc", docDirective );
    table.put( "@end_raw", endRawDirective );
    table.put( "@others", othersDirective );
    table.put( "@raw", rawDirective );
    
}</t>
<t tx="ekr.20070127142814.1146">//public abstract void onl();
//public abstract void putIndent( int indent );
//public abstract void os( String s );
//public abstract void putEndDocLine();
//public abstract void putDocLine( String s, int i );
public abstract void putStartDocLine( String s, int i, int kind );
//public abstract int putDirective( String s, int i ); //let this one be a lesson, understande the return types!
public abstract void putAtAllLine( String s, int i, PositionSpecification p );
//public abstract void putAtOthersLine( String s, int i, PositionSpecification p );
public abstract void writeError( String s );
public abstract void putInitialComment();
public abstract void putOpenNodeSentinel( PositionSpecification p,boolean inAtAll, boolean inAtOthers, boolean middle );// inAtAll=False,inAtOthers=False,middle=False) );
//def putCloseNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
public abstract void putCloseNodeSentinel( PositionSpecification p, boolean inAtAll, boolean inAtOthers, boolean middle );
public abstract int[] scanForClonedSibs( Object v );
public abstract void closeWriteFile();
public abstract boolean replaceTargetFileIfDifferent();
public abstract boolean openFileForWriting( PositionSpecification root, String fileName, boolean toString );
//def putAfterLastRef (self,s,start,delta):
//public abstract void putAfterLastRef( String s, int start, int delta );
//def putAfterMiddleRef (self,s,start,end,delta):
//public abstract void putAfterMiddleRef( String s, int start, int end, int delta );
//def initWriteIvars(self,root,targetFileName,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
//public abstract void initWriteIvars( PositionSpecification root, String targetFileName, boolean nosentinels, boolean thinFile, boolean scriptWrite, boolean toString );
public abstract void exception( String message );
public abstract void error( String error );
public abstract void writeException();
public abstract void writeException( PositionSpecification root );
public abstract void asisWrite( PositionSpecification root, boolean toString );
public abstract void norefWrite( PositionSpecification root, boolean toString );
public abstract void warnAboutOrphandAndIgnoredNodes();
//public abstract void putPending( boolean split );
//public abstract void initCommonIvars();</t>
<t tx="ekr.20070127142814.1147">public final Object[] isSectionName( final String s, final int i ){

    final Object[] rvalues = new Object[]{ false, -1 };
    if( ! match( s, i, "&lt;&lt;" ) ) return rvalues;
        
    final int j = find_on_line( s, i , "&gt;&gt;" );
    if( j != -1 ){
    
        rvalues[ 0 ] = true; rvalues[ 1 ] = i + 2;
        return rvalues;
    
    }
    else return rvalues;
}



public final Object[] findSectionName( String s, final int i ){

    final int end = s.indexOf( '\n', i );
    final int n1;
    final int n2;
    if( end == -1 ){
    
        n1 = s.indexOf( "&lt;&lt;", i );
        n2 = s.indexOf( "&gt;&gt;", i );
    
    
    }
    else{
    
        s = s.substring( 0, end );
        n1 = s.indexOf( "&lt;&lt;", i );
        n2 = s.indexOf( "&gt;&gt;", i );

    
    
    }

    final boolean b = ( -1 &lt; n1 ) &amp;&amp;  ( n1 &lt; n2 );
    return new Object[]{ b, n1, n2 };

}
@
def findSectionName(self,s,i):
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    return -1 &lt; n1 &lt; n2, n1, n2

@
# returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"&lt;&lt;"):
        return False, -1
    i = g.find_on_line(s,i,"&gt;&gt;")
    if i:
        return True, i + 2
    else:
        return False, -1</t>
<t tx="ekr.20070127142814.1148">public final int directiveKind4( final String s, final int i ){

    final int ri = i;

    /*if( i &lt; 0 ){
    
        ri = s.length() + i;
    
    
    }
    else
        ri = i; */
    try{
    final int n = s.length();
    if( ri &gt;= n || s.charAt( ri ) != '@' ){
    
        final int j = skip_ws( s, ri );
        if( match_word( s, j, "@others" ) )
            return othersDirective;
        else if( match_word( s, j, "@all" ) )
            return allDirective;
        else
            return noDirective;
    
    
    
    }

    final String partial_s = s.substring( ri );
    if( ri + 1 &gt; n || partial_s.startsWith( "@ " ) || partial_s.startsWith( "@\t" ) || partial_s.startsWith( "@\n" ) ){
        return _language.equals( "cweb" )? noDirective: atDirective;
    
    }
    
    if( _language != null &amp;&amp; _language.equals( "cweb" ) &amp;&amp; ( match_word( s, ri, "@c" ) || ri+1 &gt;=n || ! Character.isLetter( s.charAt( ri + 1 ) ) ) )
        return noDirective;
        
        

    
    /*Map&lt; String, Integer &gt; table = new HashMap&lt; String, Integer &gt;();
    table.put( "@all", allDirective );
    table.put( "@c", cDirective );
    table.put( "@code", codeDirective );
    table.put( "@doc", docDirective );
    table.put( "@end_raw", endRawDirective );
    table.put( "@others", othersDirective );
    table.put( "@raw", rawDirective );*/ 

    for( String name: table.keySet() ){
        if( match_word( s, ri,  name ) ) return table.get( name );
    
    
    }

    for( String name: leoKeywords ){
        if( match_word( s, ri, name ) ) return miscDirective;
    
    }

    return noDirective;
    }
    catch( Exception x ){ x.printStackTrace(); }
    
    return 0;


}


@

def directiveKind4(self,s,i):
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 &gt;= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            at.noDirective,at.atDirective)

    # @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1&gt;= n or s[i+1] not in string.ascii_letters):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective</t>
<t tx="ekr.20070127142814.1149">private final int skip_ws( final String s, final int i ){

    final char[] cs = s.toCharArray();
    int ri = i;
    for( ; ri &lt; cs.length; ri ++ )
        if( cs[ ri ] == '\t' || cs[ ri ] == ' ' )
            continue;
        else
            break;
    return ri;
    


}

public final int skip_line( final String s, final int i ){

    final int where = s.indexOf( '\n', i );
    if( where == -1 ) return s.length();
    else
        return where + 1;


}

@
def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
@c

private final boolean match( final String s, final int i, final String pattern ){

    final int plength = pattern.length();
    if ( i + plength &gt; s.length() ) return false;
    
    final String sub = s.substring( i, i + plength );
    return sub.equals( pattern );


}

@
def match(s,i,pattern):
    #print 'pattern is: %s' % pattern
    #s2 = s[ i: i + len( pattern ) ]
    #print '%s , %s, %s, %s, %s' %( pattern, s2, s2 == pattern , len( s2 ), len( pattern ))
    #print s[ i: i + len( pattern ) ] == s
    #print jsys.currentTimeMillis()
    return s and pattern and s[ i: i + len( pattern ) ] == pattern
@c

private final boolean match_word( final String s, int i, final String pattern ){

    if( pattern == null ) return false;
    final int j = pattern.length();
    //final int slen = s.length();
    //final int ij = i + j;
    //if( i + j &gt;= s.length() ) return true;
    //if( i + j &gt;= s.length() ) return true;
    if( j == 0 ) return false;
    if( s.substring( i ).startsWith( pattern ) ) return true;
    else
        return false;
    //if( slen &lt; ij )
    //    if( ! s.substring( i ).equals( pattern ) ) return false;
    //else
    //    if( !s.substring( i, ij ).equals( pattern ) ) return false;
    //if( ij &gt;= slen ) return true;
    //final char c = s.charAt( i + j );
    //return !( Character.isLetterOrDigit( c ) || c ==  '_' );


}

@
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s[ i: i + j ] != pattern:
        return False
    #if string.find(s,pattern,i,i+j) != i:
    #    return False
    if i+j &gt;= len(s):
        return True
    c = s[i+j]
    return not( c.isalnum() or c == '_' )
    #return not (c in string.ascii_letters or c in string.digits or c == '_')
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None
@c

public int find_on_line( final String s, final int i, final String pattern ){


    int nw = s.substring( i ).indexOf( '\n' );
    if( nw == -1 ) nw = s.length();
    final int k = s.substring( i, nw ).indexOf( pattern );
    return k;




}

@
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
@c
public int skip_to_end_of_line( final String s, int i ){

    i = s.indexOf( '\n', i );
    if( i == -1 ) return s.length();
    else return i;



}

@
def skip_c_id(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
@c

public int skip_c_id( final String s, int i ){

    final int n = s.length();
    while( i &lt; n ){
    
        final char c = s.charAt( i );
        if( Character.isLetterOrDigit( c ) || c == '_' ) i += 1;
        else break;
    
    
    }

    return i;

}

@others
</t>
<t tx="ekr.20070127142814.1150">public String[] set_delims_from_string( final String s ){

    final String tag = "@comment";
    int i = 0;
    if( match_word( s, i, tag ) )
        i += tag.length();
    
    int count = 0;
    final String[] delims = new String[ 3 ];
    
    while( count &lt; 3 &amp;&amp; i &lt; s.length() ){
    
        int j = i = skip_ws( s, i );
        while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) )
             i += 1;
        if( j == i ) break;
        delims[ count ] = s.substring( j, i );
        count++;
    
    }
    
    if( count == 2 ){
        delims[2] = delims[1];
        delims[1] = delims[0];
        delims[0] = null;
    
    
    }

    for( int x = 0; x &lt; 3; x ++ ){
    
        if( delims[ x ] != null ){
        
            //delims[i] = string.replace(delims[i],"__",'\n') 
            //delims[i] = string.replace(delims[i],'_',' ')
            delims[ x ] =  delims[ x ].replace( "__", "\n" );
            delims[ x ] =  delims[ x ].replace( "_", " " );
        
        }
    
    
    
    }
    return delims;

}

@
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n')
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20070127142814.1151">

public String[] set_delims_from_language( final String language ){

    final String val = leoBaseAtFile.language_delims_dict.get( language );
    if( val != null ){
        final String[] delims = set_delims_from_string( val );
        if( delims[ 1 ] != null &amp;&amp; delims[ 2 ] == null )
            return new String[]{ null, delims[ 0 ], delims[ 1 ] };
        else
            return delims;
    
    
    }
    else
        return new String[ 3 ];

}

@
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made

</t>
<t tx="ekr.20070127142814.1152">@
def is_ws(c):

    return c == '\t' or c == ' '
@c

public boolean is_ws( final char c ){


    return c == '\t' || c == ' ';


}

@
def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')
@c

public boolean is_nl( final String s, final int i ){

    //return i &lt; s.length() &amp;&amp; ( s.indexOf( i ) == '\n' || s.indexOf( i ) == '\r' );
    return i &lt; s.length() &amp;&amp; ( s.charAt( i ) == '\n' || s.charAt( i ) == '\r' );


}


@
def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
@c

public int skip_nl( final String s, final int i ){

    if( match( s, i, "\r\n" ) ) return i + 2;
    else if ( match( s, i, "\n" ) || match( s, i, "\r" ) ) return i + 1;
    else return i;


}</t>
<t tx="ekr.20070127142814.1153">public int[] skip_leading_ws_with_indent( final String s, int i, final int tab_width ){

    int count = 0; final int n = s.length();
    while( i &lt; n ){
    
        final char ch = s.charAt( i );
        if( ch == ' ' ){
        
            count += 1;
            i += 1;
        
        }
        else if( ch == '\t' ){
        
            count += (abs(tab_width ) - ( count % abs( tab_width ) ) );
            i += 1;
        
        
        }
        else break;
    
    
    
    }
    return new int[]{ i, count };


}



@
def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent),
    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count</t>
<t tx="ekr.20070127142814.1154">@others</t>
<t tx="ekr.20070127142814.1155"></t>
<t tx="ekr.20070127142814.1156">//public abstract void putRefLine( String s, int i, int n1, int n2, Object p );

public final void putRefLine( final String s, int i, int n1, int n2, final PositionSpecification p ){


    final Integer delta = putRefAt( s, i, n1, n2, p, null );
    if( delta == null ) return;
    
    while( true ){
    
        i = n2 + 2;
        final Object[] data = findSectionName( s, i );
        boolean hasRef = (Boolean)data[ 0 ]; n1 = (Integer)data[ 1 ]; n2 = (Integer)data[ 2 ];
        if( hasRef ){
    
            putAfterMiddleRef( s, i, n1, delta );
            putRefAt( s, n1, n1, n2, p, delta );
        
        }
        else break;
    
    
    }
    
    putAfterLastRef( s, i, delta );


}
@
def putRefLine(self,s,i,n1,n2,p):
    """Put a line containing one or more references."""
    at = self
    # Compute delta only once.
    #print 'ref0'
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    #print 'ref01'
    if delta is None: return # 11/23/03
    while 1:
        #print 'refing1'
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    #print 'refing2'
    self.putAfterLastRef(s,i,delta)
</t>
<t tx="ekr.20070127142814.1157">public abstract Integer putRefAt( String s, int i, int n1, int n2, Object p, Integer delta );
@
def putRefAt (self,s,i,n1,n2,p,delta):
    """Put a reference at s[n1:n2+2] from p."""
    at = self ; name = s[n1:n2+2]
    #print 'putRefAt1'
    ref = g.findReference(name,p)
    #print 'putRefAt2'
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while not parent == p: #changed from: parent != p
            inBetween.append(parent)
            parent = parent.parent()
    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    at.indent -= delta
    return delta</t>
<t tx="ekr.20070127142814.1158">public final void putAfterLastRef( final String s,final int start, final int delta ){


    final int j = skip_ws( s, start );
    if( j &lt; s.length() &amp;&amp; s.charAt( j ) != '\n' ){
    
        final int end = skip_line( s, start );
        final String after = s.substring( start, end );
        _indent += delta;
        putSentinel( "@afterref" );
        os( after );
        if( _sentinels &amp;&amp; !after.equals( "" ) &amp;&amp; after.charAt( after.length() - 1 ) != '\n' )
            onl();
        _indent -= delta;
    
    
    }
    else{
    
        _indent += delta;
        putSentinel( "@nl" );
        _indent -= delta;
    
    
    
    }



}

@
def putAfterLastRef (self,s,start,delta):
    """Handle whatever follows the last ref of a line."""
    at = self
    j = g.skip_ws(s,start)
    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta</t>
<t tx="ekr.20070127142814.1159">public final void putAfterMiddleRef( final String s, final int start, final int end, final int delta ){


    if( start &lt; end ){
    
        final String after = s.substring( start, end );
        _indent += delta;
        putSentinel( "@afterref" );
        os( after );
        putSentinel( "@nonl" );
        _indent -= delta;
    
    
    
    
    }



}

@
def putAfterMiddleRef (self,s,start,end,delta):
    """Handle whatever follows a ref that is not the last ref of a line."""
    at = self
    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta</t>
<t tx="ekr.20070127142814.1160">public boolean writeAll( boolean writeAtFileNodesFlag, boolean writeDirtyAtFileNodesFlag, boolean toString ){
    final List&lt;Object&gt; writtenFiles = new ArrayList&lt;Object&gt;();
    final CommanderSpecification c = _c;
    boolean mustAutoSave = false;
    try{
    PositionSpecification p;
    PositionSpecification after;
    if( _writeAtFileNodesFlag ){
    
        p = c.currentPosition();
        after = p.nodeAfterTree();
    
    
    }
    else{
    
        p = c.rootPosition();
        after = c.nullPosition();
    
    
    
    }
@
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False
    #print 'in Writing All'
    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()
@c
    &lt;&lt; Clear all orphan bits &gt;&gt;
@
    while p and not p == after: #changed from:  p != after
        #print p.v.t.headString
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
@c
    while( p.isValid() &amp;&amp; ! p.equal( after ) ){

        if( p.isAnyAtFileNode() || p.isAtIgnoreNode() ){
            &lt;&lt; handle v's tree &gt;&gt;

            p.moveToNodeAfterTree();
        }
        else
            p.moveToThreadNext();

    }

    &lt;&lt; say the command is finished &gt;&gt;
    
@
    #print 'after writing all'
    print "Root is %s and it has %s" % ( self.root, len(self.root.stack ) )
    self.root = None
    return mustAutoSave
@c
    }
    catch( Exception x ){
    
        x.printStackTrace();
    
    }
    
    return mustAutoSave;    
    
}</t>
<t tx="ekr.20070127142814.1161">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
@    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
@c
final Iterator&lt;PositionSpecification&gt; ssi = p.getSelfAndSubtreeIterator();
while( ssi.hasNext() ){

    final PositionSpecification next = ssi.next();
    next.clearOrphan();



}</t>
<t tx="ekr.20070127142814.1162">if( p.isDirty() || _writeAtFileNodesFlag || writtenFiles.contains( p.get_T() ) ){


    _fileChangedFlag = false;
    boolean autoSave = false;
    if( p.isAtAsisFileNode() ){
    
        asisWrite( p, toString );
        writtenFiles.add( p.get_T() );
        autoSave = true;
    
    }
    else if( p.isAtIgnoreNode() );
    else if( p.isAtNorefFileNode() ){
    
        norefWrite( p, toString );
        writtenFiles.add( p.get_T() );
        autoSave = true;
    
    }
    else if(  p.isAtNoSentFileNode() ){
    
        write( p, true, false, false, toString );
        writtenFiles.add( p.get_T() );
    
    }
    else if( p.isAtThinFileNode() ){
    
        write( p, false, true, false, toString );
        writtenFiles.add( p.get_T() );
    
    
    }
    else if( p.isAtFileNode() ){
    
        write( p, false, false, false, toString );
        writtenFiles.add( p.get_T() );
        autoSave = true;
    }

    if( _fileChangedFlag &amp;&amp; autoSave ) mustAutoSave = true;

}


@
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False
    #print 'writing p: %s' % p.v.t.headString
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        #print 'at Thin'
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True</t>
<t tx="ekr.20070127142814.1163">if( _writeAtFileNodesFlag || _writeDirtyAtFileNodesFlag ){

    if( writtenFiles.size() &gt; 0 )
        p.g_es( "finished" );
    else if( _writeAtFileNodesFlag )
        p.g_es( "no @file nodes in the selected tree" );
    else
        p.g_es( "no dirty @file nodes" );





}

@
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")</t>
<t tx="ekr.20070127142814.1164">public void write( final PositionSpecification root, final boolean nosentinels, 
                   final boolean thinFile, final boolean scriptWrite, 
                   final boolean toString ){

try{
if( toString )
    _targetFileName = "&lt;string-file&gt;";
else if( nosentinels )
    _targetFileName = root.atNoSentFileNodeName();
else if( thinFile )
    _targetFileName = root.atThinFileNodeName();
else
    _targetFileName = root.atFileNodeName();

    initWriteIvars(root,_targetFileName, nosentinels, thinFile, scriptWrite, toString);

    if( !openFileForWriting(root,_targetFileName,toString) )
        return;
        
    try{

        writeOpenFile(root,nosentinels,toString);
        if( toString ){
            closeWriteFile();
            //# Major bug: failure to clear this wipes out headlines!
            //# Minor bug: sometimes this causes slight problems...
            //at.root.v.t.tnodeList = [] 
            _root.clearTTnodeList();
        }
        else{

            closeWriteFile();
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
            
            }
    
    
    }
    catch( Exception x ){

        x.printStackTrace();
        if( toString ){
        
            exception( "exception preprocessing script" );
            root.clearTTnodeList();
        
        
        
        }
        else{
            x.printStackTrace();
            writeException();
            
            }
    
    
    
    
    
    }
    }
    catch( Exception x ){ x.printStackTrace(); }

}

@
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    """Write a 4.x derived file."""
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
@c
    &lt;&lt; set at.targetFileName &gt;&gt;
@
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    #print 'pre openFileForWriting'
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        #print 'pre writeOpenFile'
at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.

</t>
<t tx="ekr.20070127142814.1165">if( _errors &gt; 0 || _root.isOrphan() ){

    root.setOrphan();
    root.setDirty();
    //os.remove( _outputFileName )
    new File( _outputFileName ).delete();
    root.g_es( "Not written: " + _outputFileName );    


}
else{

    root.clearOrphan();
    root.clearDirty();
    replaceTargetFileIfDifferent();


}
@
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20070127142814.1166">@
if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()</t>
<t tx="ekr.20070127142814.1167">public void writeOpenFile( final PositionSpecification root, final boolean nosentinels, final boolean toString ){

    root.clearAllVisitedInTree(); //# Clear both vnode and tnode bits.
    root.clearVisitedInTree();
@   
    s = root.v.t.bodyString
    tag = "@first"
    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)
@c

    final String s = root.bodyString();
    String tag = "@first";
    int i = 0;
    while( match( s, i, tag ) ){
    
        i += tag.length();
        i = skip_ws( s, i );
        final int j = i;
        i = skip_to_end_of_line( s, i );
        String line = s.substring( j, i );
        os( line ); onl();
        i = skip_nl( s, i );
    
    
    
    }
    
    putOpenLeoSentinel("@+leo-ver=4");
    putInitialComment();
    putOpenNodeSentinel(root, false, false, false );
    putBody(root, true, false);
    putCloseNodeSentinel(root, false, false, false );
    putSentinel("@-leo");
    root.setVisited();

@
tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        at.os(line[i:])
@c
tag = "@last";
final List&lt; String &gt; lines = new ArrayList&lt;String&gt;();
StringBuilder sb = new StringBuilder();
final char[] data = s.toCharArray();
for( final char c: data ){

    sb.append( c );
    if( c== '\n' ){
        lines.add( sb.toString() );
        sb = new StringBuilder();
    
    
    }


}
if( !lines.contains( sb.toString() ) ) lines.add( sb.toString() );
int n = lines.size(); 
int j = n -1; int k = j;

while( j &gt;= 0 ){

    final String line = lines.get( j );
    if( match( line, 0, tag ) ) j -= 1;
    else if( line.trim().equals( "" ) ) j -= 1;
    else break;
    /*while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break*/




}

for( final String line: lines.subList( j + 1, k + 1 ) ){

    if( match( line, 0, tag ) ){
    
        i = tag.length(); i = skip_ws( line, i );
        os( line.substring( i ) );
    
    
    }
}
/*for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        at.os(line[i:])*/




@
# New in 4.3: must be inited before calling this method.

def writeOpenFile(self,root,nosentinels=False,toString=False):

    """Do all writes except asis writes."""
    at = self ; c = at.c
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()
@c
    &lt;&lt; put all @first lines in root &gt;&gt;
@
    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
@c
    &lt;&lt; put all @last lines in root &gt;&gt;

    if( !toString &amp;&amp; !nosentinels)
        warnAboutOrphandAndIgnoredNodes();
        
    }</t>
<t tx="ekr.20070127142814.1168">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c
@
s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.os(line) ; at.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20070127142814.1169">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c
@
tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        at.os(line[i:])</t>
<t tx="ekr.20070127142814.1170"></t>
<t tx="ekr.20070127142814.1171">public final String nodeSentinelText( final PositionSpecification p ){


    String h = p.headString();
    final String start = _startSentinelComment;
    final String end = _endSentinelComment;
    if( end != null &amp;&amp; end.length() &gt; 0 ){
    
        h = h.replace( start, "" );
        h = h.replace( end, "" );
    
    
    }
    
    if( _thinFile ){
        final String gnx = convertGnxToString( p.getTFileIndex() );
        return String.format( "%s:%s", gnx, h );
        
    }
    else return h;


}
@
def nodeSentinelText(self,p):
    """Return the text of a @+node or @-node sentinel for p."""
    at = self ; h = p.headString()
@c
    &lt;&lt; remove comment delims from h if necessary &gt;&gt;
 
@ 
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h</t>
<t tx="ekr.20070127142814.1172">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

@
start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) &gt; 0:
    h = h.replace(start,"")
    h = h.replace(end,"")</t>
<t tx="ekr.20070127142814.1173">public final String convertGnxToString( final Object[] index ){

    final Object theId = index[ 0 ];
    final Object t = index[ 1 ];
    final Object n = index[ 2 ];
    
    if( n == null ) return String.format( "%s.%s", theId, t );
    else return String.format( "%s.%s.%s", theId, t, n );



}


@
def toString (self,index,removeDefaultId=False):
    """Convert a gnx (a tuple) to its string representation"""

    theId,t,n = index

    if removeDefaultId and theId == self.defaultId:
        theId = ""

    if not n: # None or ""
        return "%s.%s" % (theId,t)
    else:
        return "%s.%s.%d" % (theId,t,n)</t>
<t tx="ekr.20070127142814.1174">public final void putLeadInSentinel( final String s, final int i, final int j, final int delta ){

    _leadingWs = "";
    if( i == j ) return;
    int k = skip_ws( s, i );
    if( j == k ) _leadingWs = s.substring( i, j );
    else{
@
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently
@c    
        putIndent( _indent );
        os( s.substring( i, j ) );
        _indent += delta;
        putSentinel( "@nonl" );
        _indent -= delta;   
        
    
    }
    


}

@
def putLeadInSentinel (self,s,i,j,delta):
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.</t>
<t tx="ekr.20070127142814.1175">

@
def putCloseNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    at = self
    s = self.nodeSentinelText(p)
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)</t>
<t tx="ekr.20070127142814.1176">public final void putOpenLeoSentinel( String s ){


    if( ! _sentinels ) return;
    
    if( _thinFile ) s += "-thin"; 
    
    final String encoding = _encoding.toLowerCase();
    if( !encoding.equals("utf-8") )
        s =  format( "%s-encoding=%s,.", s, encoding );
    
    putSentinel( s );  


}

@
def putOpenLeoSentinel(self,s):
    """Write @+leo sentinel."""

    at = self
    if not at.sentinels:
        return # Handle @nosentinelsfile.
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    at.putSentinel(s)</t>
<t tx="ekr.20070127142814.1177">@
def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    """Write @+node sentinel for p."""
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
    # g.trace(at.thinFile,p)
    s = at.nodeSentinelText(p)
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        at.root.v.t.tnodeList.append(p.v.t)</t>
<t tx="ekr.20070127142814.1178">@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c
@
start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]</t>
<t tx="ekr.20070127142814.1179">// Note:  self.outputFile may be either a fileLikeObject or a real file.

</t>
<t tx="ekr.20070127142814.1180">public final void oblank(){

    os( " " );


}

public final void oblanks( final int n ){

    final int ab = abs( n );
    final char[] c = new char[ ab ];
    Arrays.fill( c, ' ' );
    final String blanks = new String( c );
    os( blanks );


}

public final void otabs( final int n ){

    final int ab = abs( n );
    final char[] c = new char[ ab ];
    Arrays.fill( c, '\t' );
    final String tabs = new String( c );
    os( tabs );

}

@
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
def otabs(self,n):
    self.os('\t' * abs(n))</t>
<t tx="ekr.20070127142814.1181">public final void onl(){


    os( _output_newline );


}

public final void onl_sent(){   

    if( _sentinels )
        onl();


}

@
def onl(self):
    """Write a newline to the output stream."""

    self.os(self.output_newline)
def onl_sent(self):
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()</t>
<t tx="ekr.20070127142814.1182">public abstract void os( final String s );
@
public void os( final String s ){


    try{
        System.out.println( "IM HERE SOMEHOW?" );
        if( s != null &amp;&amp; _outputStream != null ){
            final byte[] encoded_s = s.getBytes( _encoding );
            _outputStream.write( encoded_s );
        }
    }
    catch( final Exception x ){

        x.printStackTrace();
    }




}


@
def os (self,s):
    """Write a string to the output stream.
    All output produced by leoAtFile module goes here."""
    at = self
    if s and at.outputFile:
        try:
            #print at.encoding
            #print java.lang.System.currentTimeMillis()
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
            #at.outputFile.append( s )
            #print java.lang.System.currentTimeMillis()
        except:
            at.exception("exception writing:" + s)</t>
<t tx="ekr.20070127142814.1183">public final void putSentinel( String s ){

    if( !_sentinels ) return;
    
    putIndent( _indent );
    os( _startSentinelComment );
    final String start = _startSentinelComment;
    //if start and start[-1] == '@':
    //assert(s and s[0]=='@
    final int slen = start.length();

    
    if( start != null &amp;&amp; slen &gt; 0 &amp;&amp; start.charAt( slen - 1 ) == '@' ){
        
        s = s.replace( "@", "@@" ).substring( 1 );
        
    }
        //s = s.replace('@','@@')[1:]
    
    os( s ); //dont misinterpret the comments to bellow that the code belongs in the above if
    if( _endSentinelComment != null )
        os( _endSentinelComment );
    onl();

    

}


@
# This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."
    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    &lt;&lt; apply the cweb hack to s &gt;&gt;
@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.


start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
</t>
<t tx="ekr.20070127142814.1184">public final void putCodeLine( final String s, final int i ){

    final int k = skip_ws( s, i );
    if( match( s, k , _startSentinelComment + '@' ) )
        putSentinel( "@verbatim" );
    
    final int j = skip_line( s, i );
    final String line = s.substring( i, j );
    
    if( !line.equals( "" ) &amp;&amp; !_raw )
        putIndent( _indent );
    
    final int line_length = line.length();  
    
    if( line_length &gt; 0 &amp;&amp; line.substring( line_length - 1 ).equals( "\n" ) ){
    
        os( line.substring( 0, line_length -1 ) );
        onl();
    
    
    }
    else{ 

    
            os( line );
            
            
            }


}
@
def putCodeLine (self,s,i):
    """Put a normal code line."""
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)</t>
<t tx="ekr.20070127142814.1185">public final void putIndent( final int n ){

    if( n != 0 ){
    
        final int w = _tabWidth;
        if( w &gt; 1 ){
        
            final int q = n/w;
            final int r = n%w;
            otabs( q );
            oblanks( r );
        
        }
        else oblanks( n );
        
    
    
    }



}


@
def putIndent(self,n):
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w &gt; 1:
            q,r = divmod(n,w)
            self.otabs(q)
            self.oblanks(r)
        else:
            self.oblanks(n)</t>
<t tx="ekr.20070127142814.1186">@
def putInitialComment (self):
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)&gt; 0:
                self.putSentinel("@comment " + line)</t>
<t tx="ekr.20070127142814.1187"></t>
<t tx="ekr.20070127142814.1188">public final void putBlankDocLine(){


    putPending( false );
    if( _endSentinelComment == null || _endSentinelComment.equals( "" ) ){
    
        putIndent( _indent );    
        os( _startSentinelComment );
        oblank();
    
    
    
    }
    onl();


}

@
def putBlankDocLine (self):
    at = self
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()</t>
<t tx="ekr.20070127142814.1189">@
def putStartDocLine (self,s,i,kind):
    """Write the start of a doc part."""
    at = self ; at.docKind = kind
    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)</t>
<t tx="ekr.20070127142814.1190">public final void putDocLine( String s, int i ){

    final int j = skip_line( s, i );
    s = s.substring( i, j );
    
    final int leading;
    if( _endSentinelComment != null &amp;&amp; !_endSentinelComment.equals( "" ) )
        leading = _indent;
    else
        leading = _indent + _startSentinelComment.length() + 1;
        
    if( s.length() == 0 || s.charAt( 0 ) == '\n' ){
    
        putBlankDocLine();
        
        }
    else{
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
        
        }

}
@
def putDocLine (self,s,i):
    """Handle one line of a doc part.
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:

        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20070127142814.1191">i = 0;
while( i &lt; s.length() ){


    int word1 = i;
    final int word2 = i = skip_ws( s, i );
    while( i &lt; s.length() &amp;&amp; ( s.charAt( i ) != ' ' || s.charAt( i ) != '\t' ) )
        i += 1;
        
    final int word3 = i = skip_ws( s, i );
    final String _pstring = pendingToString();
    if( ( leading + word3 - word1 + _pstring.length() ) &gt;= _page_width ){
    
        if( _pending != null &amp;&amp; _pending.size() != 0 ){
            putPending( true );
            _pending.clear();
            _pending.add( s.substring( word2, word3 ) );
            
        }
        else{
        
            _pending.clear();
            _pending.add( s.substring( word2, word3 ) );
        
        
        
        }
    
    
    
    }
    else _pending.add( s.substring( word1, word3 ) );



}
putPending( false );



@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c
@
i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
# Output the remaining line: no more is left.
at.putPending(split=False)
</t>
<t tx="ekr.20070127142814.1192">public final void putEndDocLine(){


    putPending( false );
    if( _endSentinelComment != null &amp;&amp; !_endSentinelComment.equals( "" ) ){
    
        putIndent( _indent );
        os( _endSentinelComment );
        onl();
    
    
    }
    
    final String sentinel = _docKind == docDirective ? "@-doc": "@-at";
    putSentinel( sentinel );

}
@
def putEndDocLine (self):
    """Write the conclusion of a doc part."""
    at = self
    at.putPending(split=False)
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)</t>
<t tx="ekr.20070127142814.1193">public final void putPending( final boolean split ){

    try{
    StringBuilder s = new StringBuilder();
    for( final String ps: _pending )
        s.append( ps );
     
    _pending.clear();
    
    final int slen = s.length();
    if( slen != 0 &amp;&amp; s.charAt( slen -1 ) == '\n' ){        
        
        //s = s.setLength( 0 );
        //s.append( '\n' );
        s = s.deleteCharAt( slen -1 );
        //s = (StringBuilder)s.subSequence( 0, slen - 1 );
        
        }
        
        
        
        
    s.insert( 0 , '1' ); //so we can trim()
    String s2 = s.toString();
    if( ! split ){
        s2 = s2.trim();
        s2 = s2.substring( 1 );
        if( s2.equals( "" ) ){
            return;
            
            
        }
        
        }
    
    
    putIndent( _indent );
    if( _endSentinelComment == null || _endSentinelComment.equals( "" ) ){
    
        os( _startSentinelComment );
        oblank();
    
    
    }
    
    os( s2 );
    onl();
    }
    catch( Exception x ){
    
        x.printStackTrace();
    
    }


}

@
def putPending (self,split):
    """Write the pending part of a doc part.
    We retain trailing whitespace iff the split flag is True."""
    at = self ; s = ''.join(at.pending) ; at.pending = []
    # g.trace("split",s)
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()</t>
<t tx="ekr.20070127142814.1194">private final String pendingToString(){

    final StringBuilder sb = new StringBuilder();
    for( final String s: _pending )
        sb.append( s );
        
    
    return sb.toString();




}</t>
<t tx="ekr.20070127142814.1195">/*public void putBody( PositionSpecification p ){

    putBody( p, 1, 0 );

}*/

public void putBody( final PositionSpecification p, final boolean putCloseSentinel, final boolean oneNodeOnly ){

    try{

    final leoBaseAtFile at = this;
    final StringBuilder _s = new StringBuilder( p.bodyString() );
    int slength = _s.length();
    p.setTVisited();
    p.setVisited();
    if( !_thinFile ){
    
        p.setWriteBit();
        
        }
    boolean inCode = true;
    
    /*if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl*/
    boolean trailingNewlineFlag = false;
    if( slength &gt; 0 ){
    
        trailingNewlineFlag = slength &gt; 0 &amp;&amp; _s.charAt( slength -1 ) == '\n'? true: false;
        if( _sentinels &amp;&amp; !trailingNewlineFlag ) //s = s + '\n';
                _s.append( '\n' );
    }
    else trailingNewlineFlag = true;


    int i = 0;
    //int lc = loopcounter;
    final String s = _s.toString();
    final int slen2 = s.length();
    while( i &lt; slen2 ){ //s.length() ){
    
        int next_i = skip_line( s, i );
        int kind = directiveKind4( s, i );
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i;
    
    }

    if( !inCode ) putEndDocLine();
    if( _sentinels &amp;&amp; !trailingNewlineFlag ) putSentinel( "@nonl" );
    }
    catch( Throwable x ){
        
    
        x.printStackTrace();
        //if( loopcounter &gt;= 140 )System.exit( 0 );
    
    }

}

@

# oneNodeOnly is no longer used.

def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return
    inCode = True
    #print 'putBody1'
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0

    while i &lt; len(s):
        #print len( s ), i, self.targetFileName, p.v.t.headString
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")

</t>
<t tx="ekr.20070127142814.1196">if( kind == noDirective ){

    if( ! oneNodeOnly ){
        if( inCode ){
        
            final Object[] data = findSectionName( s, i );
            final boolean hasRef = (Boolean)data[ 0 ];
            final int n1 = (Integer)data[ 1 ];
            final int n2 = (Integer)data[ 2 ];
            if( hasRef &amp;&amp; !_raw )
                putRefLine( s, i, n1, n2, p );
            else
                putCodeLine( s, i );
            
        
        }
        else putDocLine( s, i );
    
    
    
    }
 /*   if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)*/


}
else if ( kind == docDirective || kind == atDirective ){

    if( !inCode ) putEndDocLine();
    putStartDocLine(  s, i, kind );
    inCode = false;


    /*assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine()
    at.putStartDocLine(s,i,kind)
    inCode = False*/



}
else if( kind == cDirective || kind == codeDirective ){
    
    if( !inCode ) putEndDocLine();
    putDirective( s, i );
    inCode = true;
    
    /*# Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine()
    at.putDirective(s,i)
    inCode = True*/




}
else if( kind == allDirective ){

    if( !oneNodeOnly ){
    
        if( inCode ) putAtAllLine( s, i , p );
        else putDocLine( s, i );
    
    
    
    }
        
        /*
        if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)*/


}
else if( kind == othersDirective ){

    if( ! oneNodeOnly ){
    
        if( inCode ) putAtOthersLine( s, i, p );
        else putDocLine( s, i );
    
    
    
    }
    /*if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)*/

}
else if( kind == rawDirective ){


    _raw = true;
    putSentinel( "@@raw" );
   /* at.raw = True
    at.putSentinel("@@raw") */


}
else if( kind == endRawDirective ){

    _raw = false;
    putSentinel( "@@end_raw" );
    i = skip_line( s, i );
    /*at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)*/


}
else if( kind == miscDirective ){

    putDirective( s, i );
   //at.putDirective(s,i)

}
else{
    
    assert( false );
    
    }


@
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine()
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine()
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.</t>
<t tx="ekr.20070127142814.1197">@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first &amp; @last directives.
@c


public final int putDirective( final String s, int i ){

    final String tag = "@delims";
    //final StringBuilder s2 = new StringBuilder( s );
    final int k = i;
    int j = skip_to_end_of_line( s, i );
    final String directive = s.substring( i, j );
    if( match_word( s, k, "@delims" ) ){
    
        &lt;&lt; handle @delims &gt;&gt;
    
    }
    else if( match_word( s, k, "@language" ) ){
    
        &lt;&lt; handle @language &gt;&gt;
    
    }
    else if( match_word( s, k, "@comment" ) ){
    
        &lt;&lt; handle @comment &gt;&gt;
    
    }
    else if( match_word( s, k, "@last" ) ) putSentinel( "@@last" );
    else if( match_word( s, k, "@first" ) ) putSentinel( "@@first" );
    else putSentinel( '@' + directive );
    i = skip_line( s, k );
    

@
def putDirective(self,s,i):
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]
    if g.match_word(s,k,"@delims"):

        &lt;&lt; handle @delims &gt;&gt;

    elif g.match_word(s,k,"@language"):

        &lt;&lt; handle @language &gt;&gt;

    elif g.match_word(s,k,"@comment"):

        &lt;&lt; handle @comment &gt;&gt;

    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)
    i = g.skip_line(s,k)
    return i
@c

    return i;   
    
}
</t>
<t tx="ekr.20070127142814.1198">while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) )
    i += 1;
    
if( j &lt; i ){

    _startSentinelComment = s.substring( j, i );
    j = i = skip_ws( s, i );
    while( i &lt; s.length() &amp;&amp; !is_ws( s.charAt( i ) ) &amp;&amp; !is_nl( s, i ) )
        i += 1;
    _endSentinelComment = j&lt;i ? s.substring( j, i ): "";

}
else writeError( "Bad @delims directive" );


@
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")</t>
<t tx="ekr.20070127142814.1199">putSentinel( '@' + directive );

i = k + "@language".length();
i = skip_ws( s, i );
j = skip_c_id( s, i );
final String language = s.substring( i, j );

final String[] delims = set_delims_from_language( language );
final String delim1 = delims[ 0 ]; final String delim2 = delims[ 1 ]; final String delim3 = delims[ 2 ];

if( delim1 != null ){
    _startSentinelComment = delim1;
    _endSentinelComment = "";


}
else if( delim2 != null &amp;&amp; delim3 != null ){
    
    _startSentinelComment = delim2;
    _endSentinelComment = delim3;


}
else{
    
   //line = get_line( s, i );


}



@
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")</t>
<t tx="ekr.20070127142814.1200">putSentinel( '@' + directive );
j = skip_line( s, i );
final String line = s.substring( i, j  );
final String[] delims = set_delims_from_string( line );
final String delim1 = delims[ 0 ]; final String delim2 = delims[ 1 ]; final String delim3 = delims[ 2 ];

if( delim1 != null ){

    _startSentinelComment = delim1;
    _endSentinelComment = null;


}
else if ( delim2 != null &amp;&amp; delim3 != null ){

    _startSentinelComment = delim2;
    _endSentinelComment = delim3;

}
else{



}


@
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")</t>
<t tx="ekr.20070127142814.1201">@
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="ekr.20070127142814.1202"></t>
<t tx="ekr.20070127142814.1203">public final boolean inAtOthers( final PositionSpecification p ){

    if( p.isVisited() ) return false;

    final String h = p.headString(); final int i = skip_ws( h, 0 );
    final Object[] data = isSectionName( h, i );
    final boolean isSection = (Boolean)data[ 0 ];
    if( isSection )
        return false;
    if( p.isAtIgnoreNode() )
        return false;
    else
        return true;

}


@
def inAtOthers(self,p):
    """Returns True if p should be included in the expansion of the at-others directive
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True</t>
<t tx="ekr.20070127142814.1204">public final void putAtOthersChild( final PositionSpecification p ){

    final int[] data = scanForClonedSibs( p.acquireV() );
    final int clonedSibs = data[ 0 ];
    final int thisClonedSibIndex = data[ 1 ];
    if( clonedSibs &gt; 1 &amp;&amp; thisClonedSibIndex == 1 )
        writeError( "Cloned siblings are not valid in @thin trees" );
        
    putOpenNodeSentinel( p, false, true, false );
    putBody( p, true, false );
    final Iterator&lt; PositionSpecification &gt; ci = p.getChildrenIterator();
    while( ci.hasNext() ){
        final PositionSpecification child = ci.next();
        if( inAtOthers( child ) )
            putAtOthersChild( child );
    
    
    
    }
    putCloseNodeSentinel( p, false, true, false );


}


@
def putAtOthersChild(self,p):
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p)
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
    at.putCloseNodeSentinel(p,inAtOthers=True)
</t>
<t tx="ekr.20070127142814.1205">public final void putAtOthersLine( final String s, final int i, final PositionSpecification p ){


    final int[] data = skip_leading_ws_with_indent( s, i , _tabWidth );
    final int j = data[ 0 ];
    final int delta = data[ 1 ];
    
    putLeadInSentinel( s, i, j, delta );
    
    _indent += delta;
    if( _leadingWs != null &amp;&amp; !_leadingWs.equals( "" ) ){

        putSentinel( "@" + _leadingWs + "@+others" );
        
        }
    else{
    
        putSentinel( "@+others" );
        
        }
        
    final Iterator&lt; PositionSpecification &gt; ci = p.getChildrenIterator();
    while( ci.hasNext() ){
    
        final PositionSpecification child = ci.next();
        if( inAtOthers( child ) )
            putAtOthersChild( child );
    
    
    }
    
    putSentinel( "@-others" );
    _indent -= delta;


}

@
def putAtOthersLine (self,s,i,p):
    """Put the expansion of @others."""
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta</t>
<t tx="ekr.20070127142814.1206">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c
@
def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
@c
public void scanAllDirectives( PositionSpecification p, boolean scripting, boolean importing, boolean reading ){

    
    CommanderSpecification c = _c;
    String path = null;
    String base = null;
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    Map old = new HashMap();
    Iterator&lt; PositionSpecification &gt; pi = p.getSelfAndParentsIterator();

@
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
@c

    while( pi.hasNext() ){
        
        p = pi.next();
        final String s = p.bodyString();
        Map theDict = c.g_get_directives_dict( s );
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.putAll(theDict);
        
        
        }
@
        old.update(theDict)
@c
    &lt;&lt; Set current directory &gt;&gt;
@
    if not importing and not reading:
@c
      //  # 5/19/04: don't override comment delims when reading!
    if( !importing &amp;&amp; !reading )
        &lt;&lt; Set comment strings from delims &gt;&gt;
     
}</t>
<t tx="ekr.20070127142814.1207">_page_width = c.acquirePage_width();
_tabWidth = c.acquireTab_width();

_default_directory = null;
String[] delims = set_delims_from_language( c.acquireTarget_language() );
String delim1 = delims[ 0 ]; String delim2 = delims[ 1 ]; String delim3 = delims[ 2 ];
_language = c.acquireTarget_language();
_encoding = c.acquireDefault_derived_file_encoding();
_output_newline = c.acquireOutputNewline();


@
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # 4/24/03: initialize from config settings.</t>
<t tx="ekr.20070127142814.1208">final String name = p.anyAtFileNodeName();
String theDir = name != null? c.acquireOs_path_dirname( name ) : null;

if( theDir != null &amp;&amp; theDir.length() &gt; 0 &amp;&amp; c.g_os_path_isabs( theDir ) ){
    
    if( c.g_os_path_exists( theDir ) )
        _default_directory = theDir;
    else{
        _default_directory = c.g_makeAllNonExistentDirectories( theDir );
        if( _default_directory == null )
            error( "Directory \"" + theDir + "\" does not exist" );


    }

}


@
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"" + theDir + "\" does not exist")</t>
<t tx="ekr.20070127142814.1209">if( _default_directory == null &amp;&amp; !old.containsKey( "path" ) &amp;&amp; theDict.containsKey( "path" ) ){


    final Integer k = (Integer)theDict.get( "path" );
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if( path != null &amp;&amp; path.length() &gt; 0 ){
    
        base = c.g_getBaseDirectory();
        
        path = c.g_os_path_join( base, path );
        
        if( c.g_os_path_isabs( path ) ){
            &lt;&lt; handle absolute path &gt;&gt;
        }
        else{
        
            error("ignoring bad @path: " + path);
        
        }
    
    
    
    
    }
    else error("ignoring empty @path");





}

@
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")</t>
<t tx="ekr.20070127142814.1210">int j, i;
j = i = k + "@path".length();
i = skip_to_end_of_line( s, i );
path = s.substring( j, i ).trim();

//final int r_len = remove.length();
//while( s.startsWith( remove ) )
//    s = s.substring( r_len );
//while( s.endsWith( remove ) )
//    s = s.substring( 0, s.length() - r_len );
//path = s;



final int pend = path.length() - 1;
if( path.length() &gt; 2 &amp;&amp; (
     ( path.charAt( 0 ) == '&lt;' &amp;&amp; path.charAt( pend ) == '&gt;' ) ||
    ( path.charAt( 0 ) == '"' &amp;&amp; path.charAt( pend ) == '"' ) ) )
        path = path.substring( 1 , pend );
path = path.trim();

@
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)</t>
<t tx="ekr.20070127142814.1211">if( c.g_os_path_exists( path ) )
    _default_directory = path;
else{

    _default_directory = c.g_makeAllNonExistentDirectories( path );
    if( _default_directory == null )
        error( "invalid @path: " + path );



}
@
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
</t>
<t tx="ekr.20070127142814.1212">if( ! old.containsKey( "encoding" ) &amp;&amp; theDict.containsKey( "encoding" ) ){


    final String e = c.g_scanAtEncodingDirective( s, theDict );
    if( e != null )
        _encoding = e;


}

@
if not old.has_key("encoding") and theDict.has_key("encoding"):
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e</t>
<t tx="ekr.20070127142814.1213">if( old.containsKey( "comment" ) || old.containsKey( "language" ) );
else if( theDict.containsKey( "comment" ) ){

    final Integer k = (Integer)theDict.get( "comment" );
    delims = set_delims_from_string( s.substring( k ) );
    delim1 = delims[ 0 ]; delim2 = delims[ 1 ]; delim3 = delims[ 2 ];
    
}
else if( theDict.containsKey( "language" ) ){

    final Integer k = (Integer)theDict.get( "language" );
    delims = c.g_set_language(  s, k ); //s.substring( k ) );
    _language = delims[ 0 ]; delim1 = delims[ 1 ]; delim2 = delims[ 2 ]; delim3 = delims[ 3 ];


}



@
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20070127142814.1214">if( theDict.containsKey( "header" ) &amp;&amp; theDict.containsKey( "noheader" ) )
    p.g_es( "conflicting @header and @noheader directives");

@
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")</t>
<t tx="ekr.20070127142814.1215">if( !old.containsKey( "lineending" ) &amp;&amp; theDict.containsKey( "lineending" ) ){


    final String lineending = c.g_scanAtLineendingDirective(s,theDict);
    if( lineending != null ){
    
        _explicitLineEnding = true;
        _output_newline = lineending;
    
    
    } 




}
@
if not old.has_key("lineending") and theDict.has_key("lineending"):
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20070127142814.1216">if( theDict.containsKey( "pagewidth" ) &amp;&amp; ! old.containsKey( "pagewidth" ) ){

    final Integer w = c.g_scanAtPagewidthDirective(s,theDict,true);
    if( w!= null &amp;&amp; w &gt; 0 )
        _page_width = w;


}
@
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w</t>
<t tx="ekr.20070127142814.1217">if( theDict.containsKey( "tabwidth" ) &amp;&amp; ! old.containsKey( "tabwidth" ) ){

    final Integer w = c.g_scanAtTabwidthDirective( s, theDict, true );
    if( w != null &amp;&amp; w != 0 )
        _tabWidth = w;



}

@
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

</t>
<t tx="ekr.20070127142814.1218">if( c.hasFrame() &amp;&amp; _default_directory == null ){

    base = c.g_getBaseDirectory();
    final String[] directories = new String[]{ c.acquireTangle_directory(), c.acquireFrOpenDirectory(), c.acquireOpenDirectory() };
    for( String theDir2: directories ){
        theDir = theDir2;
        if( theDir != null &amp;&amp; theDir.length() &gt; 0 ){
            theDir = c.g_os_path_join( base, theDir );
            if( c.g_os_path_isabs( theDir ) ){
                if( c.g_os_path_exists( theDir ) ){
                     _default_directory = theDir; 
                     break;
                
                }
                else _default_directory = c.g_makeAllNonExistentDirectories( theDir );
            
            
            
            
            }
        
        
        
        
        
        }
    
    
    }

}

if( _default_directory == null &amp;&amp; !scripting &amp;&amp; !importing ){


    c.g_trace();
    error("No absolute directory specified anywhere.");
    _default_directory = "";    




}

@
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20070127142814.1219">if( scripting ){

    delims = set_delims_from_language( "python" );
    delim1 = delims[ 0 ]; delim2 = delims[ 1 ]; delim3 = delims[ 2 ];
    _language = "python";


}

if( delim1 != null ){

    _startSentinelComment = delim1;
    _endSentinelComment = "";


}
else if ( delim2 != null &amp;&amp; delim3 != null ){

    _startSentinelComment = delim2;
    _endSentinelComment = delim3;
    

}
else{

    p.g_es( "Unknown language: using Python comment delimiters" );
    final String o1 = String.format( "c.target_language: %s", c.acquireTarget_language() );
    p.g_es( o1 );
    final String o2 = String.format( "delim1,delim2,delim3: %s %s %s",delim1,delim2,delim3);
    p.g_es( o2 );
    _startSentinelComment = "#"; ///# This should never happen!
    _endSentinelComment = "";



}
@
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))</t>
<t tx="ekr.20070127142814.1220">@
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False):
    print 'initing write vars'
    self.initCommonIvars()
@c
public void initWriteIvars( final PositionSpecification root, final String targetFileName,
                            final boolean nosentinels,final boolean thinFile,final boolean scriptWrite,
                            final boolean toString ){
                            
    initCommonIvars();
    &lt;&lt; init ivars for writing &gt;&gt;
    scanAllDirectives( root, false ,false,false );
    if( scriptWrite ){
    
        _startSentinelComment = "#";
        _endSentinelComment = null;
    
    
    }
    
    _targetFileName = targetFileName;
    _sentinels = ! nosentinels;
    _thinFile = thinFile;
    _toString = toString;
    _root = root;   
    

    if( _errors == 0 ) //by having this line be _errors != 0, this caused major write bugs with any @ besides @file-thin!
        _root.clearTTnodeList();
    
    
    
    }
    
@
    self.scanAllDirectives(root)
    if scriptWrite:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    # Bug fix: 12/31/04: Init all other ivars even if there is an error.
    if not self.errors:
        self.root.v.t.tnodeList = []</t>
<t tx="ekr.20070127142814.1221">_docKind = null;
_explicitLineEnding = false;
_fileChangedFlag = false;
_shortFileName = "";
_thinFile = false;

if( toString ){

    _outputFile = _c.g_fileLikeObject();
    _stringOutput = "";
    _targetFileName = _outputFileName = "&lt;string-file&gt;";
    //self.outputFile = g.fileLikeObject()
    //self.stringOutput = ""
    //self.targetFileName = self.outputFileName = "&lt;string-file&gt;"



}
else{

    _outputFile = null; // # The temporary output file.
    _stringOutput = null;
    _targetFileName = _outputFileName = "";




}


@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c
@
self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""</t>
<t tx="ekr.20070127142814.1222">@
def initCommonIvars (self):
    """Init ivars common to both reading and writing.
    The defaults set here may be changed later."""
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    c = self.c
    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict
@c
public final void initCommonIvars(){

    final CommanderSpecification c = _c;
    &lt;&lt; set defaults for arguments and options &gt;&gt;
    &lt;&lt; init common ivars &gt;&gt;
    
    
}</t>
<t tx="ekr.20070127142814.1223">_output_newline = c.acquireOutputNewline();     //c.getOutputNewline();

_encoding = c.acquireDefault_derived_file_encoding();
_endSentinelComment = "";
_startSentinelComment = "";

_default_directory = null;
_page_width = null;
_tabWidth = null;
_language = null;


@
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None</t>
<t tx="ekr.20070127142814.1224">_errors = 0;
_inCode = true;
_indent = 0;
_pending = new ArrayList();
_raw = false;
_root = null;
_root_seen = false;
_toString = false;

@
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = util.ArrayList() #[]
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.</t>
<t tx="ekr.20070127142814.1225">@language java

import javax.swing.text.*; 
import java.awt.font.*;    
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*; 
import javax.swing.plaf.basic.*;


public class leoLNEditorKit extends StyledEditorKit{

    ViewFactory vf;
    JTextPane _jtp;
    @others



}</t>
<t tx="ekr.20070127142814.1226">public leoLNEditorKit( JTextPane jtp ){


    vf = this.new LeoLNViewFactory( jtp );
    _jtp = jtp;


}

</t>
<t tx="ekr.20070127142814.1227">public Object clone(){

    Object lek = new leoLNEditorKit( _jtp );
    return lek;


}</t>
<t tx="ekr.20070127142814.1228">public String getContentType(){

    return "text/leo";



} </t>
<t tx="ekr.20070127142814.1229">public ViewFactory getViewFactory(){


    return vf;


} </t>
<t tx="ekr.20070127142814.1230">class LeoLNViewFactory implements ViewFactory{

    
    JTextPane _jtp;
    public LeoLNViewFactory( JTextPane jtp ){
    
        _jtp = jtp;
    
    }

    public View create( Element element ){
    
    
        return new LeoLNView( element, _jtp );
    
    }




}</t>
<t tx="ekr.20070127142814.1231">public static class LeoLNView extends WrappedPlainView{

    int start_x;
    int start_y;
    boolean initialized = false;
    java.util.List&lt; Segment&gt; _segments;
    JTextPane _jtp;
    
    public LeoLNView( Element elem, JTextPane jtp ){

        super( elem );
        _segments = new ArrayList&lt; Segment &gt;();
        _jtp = jtp;
        //ii = new ImageIcon( "../Icons/Leosplash.GIF" );

    }
    
    public int getTabSize(){
    
        return 1;
    }
    
    public void paint( Graphics g, Shape r ){
    
        if( ! initialized )
            super.paint( g, r );
        else
            paintAll( g );
    
    
    }
    
    private void paintAll( Graphics g ){
    
        try{

        g.setColor( Color.RED );
        Document doc = getDocument();
        String txt = doc.getText( 0, doc.getLength() );
        char[] count = txt.toCharArray();
        int ncount = 1;
        int pos = _jtp.getCaretPosition();
        Rectangle cspot = _jtp.modelToView( pos );

        for( char x: count )
            if( x == '\n' ) ncount++;
        
     
        int size = _segments.size();
        if( ncount &gt; size ){
        
            int add = ncount - size;
            while( add != 0 ){
            
                size++;
                String num = size + "\n";
                char[] nc = num.toCharArray();
                _segments.add( new Segment( nc, 0, nc.length ) );
                add--;
            
            }
            
        
        }
        /*Segment[] segs = new Segment[ ncount ];
        for( int i = 0, n = 1; i &lt; ncount; i ++ , n ++ ){
            
            String num = n + "\n";
            char[] nc = num.toCharArray();
            segs[ i ] = new Segment( nc, 0, nc.length );
        //    System.out.println( "ADDING SEGMENT " + segs[ i ] );
        
        
        }*/
        int num = 1;
        int offset = 0;
        for( Segment s: _segments ){

            Utilities.drawTabbedText( s, start_x, start_y * num , g, null, offset );
            offset += s.array.length;
            if( num == ncount ) break;
            num++;
        
        }        
        
        
        
        }
        catch( Exception x ){ }
    
    
    
    
    }
    
    public int drawUnselectedText( Graphics g, int x, int y, int p0, int p1 ) throws BadLocationException{
    
        //Image i = ii.getImage();   //for future enhancement-- the user will be able to specify an image background.
        //g.drawImage( i, 0, 0, Color.WHITE, null );
        //super.paint( g, r );
        if( !initialized ){
        
            initialized = true;
            start_x = x;
            start_y = y;
        
        
        }
        g.setColor( Color.RED );
        Document doc = getDocument();
        String txt = doc.getText( 0, p1 );
        String[] split = txt.split( "\n" );
        System.out.println( "P1 is " + p0 + "P2 " + p1 );
        String n = split.length+"\n";
        char[] c = n.toCharArray();
        //char[] c = new char[]{ '1','\n' };
        Segment s = new Segment( c, 0, c.length );
        System.out.println( "Y   IS  " + y );
        y = start_y * split.length;
        int x2 = Utilities.drawTabbedText( s, start_x, y, g, null, p0 );
        //System.out.println( "FONT SIZE IS " + g.getFont().getSize() );
        //Graphics2D g2 = (Graphics2D)g;
        //Font f = g.getFont();
        //LineMetrics lm = f.getLineMetrics( "1234567890", g2.getFontRenderContext() );
        //System.out.println( "LINE HEIGHT IS " + lm.getHeight() + " " + lm.getAscent() + " " + lm.getDescent() );
        //Document doc = getDocument();
        //String txt = doc.getText( 0, doc.getLength() );
        //System.out.println( "y is " + y + " x is " + x );
        //System.out.println( doc.getText( p0, p1 - p0 ) );
        //String[] data = txt.split( "\n" );
        //System.out.println( data.length );
        //List segments = new Vector( data.length );
        //Segment[] segs = new Segment[ data.length ];
        //for( int i = 0, n = 1; i &lt; data.length; i ++ , n ++ ){
        //    
        //    String num = n + "\n";
        //    char[] nc = num.toCharArray();
        //    segs[ i ] = new Segment( nc, 0, nc.length );
        //    System.out.println( "ADDING SEGMENT " + segs[ i ] );
        
        
        //}
        //int x = 0;
        //int offset = 0;
        //for( Segment s: segs ){
        

       //     x = Utilities.drawTabbedText( s, x, y , g, null, offset );
        //    offset += s.array.length;
        //    System.out.println( "X is   " + x );
        
       // }
        

        return x;
    
    }

   /** public int drawUnselectedText( Graphics g, int x, int y, int p0, int p1 ) throws BadLocationException{


        Document doc = getDocument();
        int len = p1 - p0;
        String txt = doc.getText( p0, len );
        System.out.println( txt );
        
        return x;

    }*/
    
    
    /**private int drawToken( Token t , Graphics g, int x, int y, int mark, Map&lt; String, Color&gt; ctokens ){
    
         int location =  Utilities.drawTabbedText( t._s ,x,y ,g, this, mark );
        g.setColor( c );
        return location;
    
    }*/




}
</t>
<t tx="ekr.20070127142814.1232">@language java

import java.awt.*;   


public class leoLayoutManager extends FlowLayout{

Component _special; 

public leoLayoutManager( Component special ){
    super();
    _special = special;


}


public void	layoutContainer(Container parent){

    Point p = _special.getLocation();
    super.layoutContainer( parent );
    _special.setLocation( p );



}






}</t>
<t tx="ekr.20070127142814.1233">@language java
import javax.swing.*;
import java.awt.*;


public class JListProblem{



    public static void main( String[] args ){
    
        PopupFactory pf = PopupFactory.getSharedInstance();
        Object[] data1 =  new Object[]{ " ", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data2 = new Object[]{ "Im not blank", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data3 =  new Object[]{ "", "OOOOoo", "Greeeniesss", "vooodooo", "#%&amp;*1!", "Milk", "moles" };
        Object[] data4 =  new Object[]{ "OOOOoo", "", "Greeeniesss", "vooodooo", "", "#%&amp;*1!", "Milk", "moles", "" };
        JList jl1 = new JList( data1 );
        jl1.setVisibleRowCount( 5 );
        JScrollPane jsp1 = new JScrollPane( jl1 );
        Popup pu = pf.getPopup( null, jsp1, 10, 10);
        pu.show();
        
        JList jl2 = new JList( data2 );
        jl2.setVisibleRowCount( 5 );
        JScrollPane jsp2 = new JScrollPane( jl2 );
        Point ss = jsp1.getLocation();
        SwingUtilities.convertPointToScreen( ss, jsp1 );
        Popup pu2 = pf.getPopup( null, jsp2, ss.x + jsp1.getSize().width + 10, 10 ); 
        pu2.show();
    
        JList jl3 = new JList( data3 );
        jl3.setVisibleRowCount( 5 );
        JScrollPane jsp3 = new JScrollPane( jl3 );
        Point ss2 = jsp2.getLocation();
        SwingUtilities.convertPointToScreen( ss2, jsp2 );
        Popup pu3 = pf.getPopup( null, jsp3, ss2.x + jsp2.getSize().width + 10, 10 );
        pu3.show();

        JList jl4 = new JList( data4 );
        jl4.setVisibleRowCount( 5 );
        JScrollPane jsp4 = new JScrollPane( jl4 );
        Point ss3 = jsp3.getLocation();
        SwingUtilities.convertPointToScreen( ss2, jsp3 );
        Popup pu4 = pf.getPopup( null, jsp4, ss2.x + jsp3.getSize().width + 10, 10 );
        pu4.show();
    
    
    }




}</t>
<t tx="ekr.20070127142814.1234">from __future__ import generators
import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.text as stext
import java.awt.event as aevent
import java.util.regex as regex
import java.awt as awt
import java.lang 
import java.io
import string    
import re 
import copy
import leoGlobals as g
from utilities.DefCallable import DefCallable
from utilities.Slider import Slider
from utilities.WeakMethod import WeakMethod
import weakref
import leoLanguageManager
import LeoUtilities



True =1
False = 0
extensions = None

&lt;&lt; addCommand &gt;&gt;

class BaseCommand:
    pass 
    
class Information:
    def __init__( self, name, doc ):
        self.name = name
        self.doc = doc
        self.subinfos = []
        
    def addInformation( self, info ):
        self.subinfos.append( info )
        
    def infoToString( self ):
        
        format = "%s\n\t%s\n"
        strings = []
        first = format % ( self.name, self.doc )
        strings.append( first )
        for z in self.subinfos:
            n = format % ( z.name, z.doc )
            strings.append( n )
        return "".join( strings )
        

class SwingMacs:
    '''A class that adds Emac derived commands and keystrokes to a JTextPane'''    
        
        
    @others
    
    
        
        
</t>
<t tx="ekr.20070127142814.1235">def addCommand(  name, command ):
    commandsFromPlugins[ name ] = command
    

</t>
<t tx="ekr.20070127142814.1236">@
The answer is simple: SwingMacs is a component of the jython Leo port.  It is derived from the CPython
Leo plugins temacs and usetemacs.  Though it would be wonderful just to use those plugins, they
were targeted at the Tk and its Text widget( hence the 't' in temacs ).  The two technologies are different enough to warrent
a new implementation.  Though as much reuse as possible is going to be attempted.  The implementation strategy is:
    1. Copy and Paste a node from temacs into SwingMacs.
    2. Analyze the node and begin the transition to Java/Jython/Swing.
Tags being absent from the JTextPane leads to the emulation of Tags through character Attributes.  The main
SwingMacs Emacs object shall contain these tag emulator methods.  The developer should not have to think in Attributes
when implementing a method that needs the simplicity of tags.  He will be able to use the SwingMacs virtual tag
methods -- tags whose only existence is in a concept.


@c</t>
<t tx="ekr.20070127142814.1237">symtable ={
'home':'home',
'shift end':'1',
'shift right':'6',
'shift shift':'?',
'tab':'tab',
'num lock':'num lock',
'shift semicolon':':',
'shift comma':'&lt;',
'f9':'f9',
'f8':'f8',
'minus':'-',
'f7':'f7',
'f6':'f6',
'f5':'f5',
'f4':'f4',
'f3':'f3',
'f2':'f2',
'f1':'f1',
'enter':'enter',
'shift page down':'3',
'down':'?',
'semicolon':';',
'numpad /':'/',
'caps lock':'?',
'numpad -':'numpad -',
'numpad +':'numpad +',
'numpad *':'numpad *',
'shift back slash':'|',
'scroll lock':'?',
'back slash':'\\',
'begin':'?',
'shift back quote':'~',
'equals':'=',
'back quote':'`',
'page down':'page down',
'z':'z',
'y':'y',
'x':'x',
'insert':'?',
'shift close bracket':'}',
'w':'w',
'v':'v',
'print screen':'print screen',
'u':'u',
't':'t',
'shift slash':'?',
's':'s',
'r':'r',
'q':'q',
'p':'p',
'o':'o',
'shift quote':'"',
'n':'n',
'up':'up',
'm':'m',
'l':'l',
'k':'k',
'j':'j',
'i':'i',
'end':'end',
'h':'h',
'g':'g',
'f':'f',
'e':'e',
'd':'d',
'c':'c',
'b':'b',
'shift home':'7',
'a':'a',
'left':'left',
'shift 9':'(',
'shift 8':'*',
'shift 7':'&amp;',
'shift 6':'^',
'shift 5':'%',
'shift 4':'$',
'shift 3':'#',
'shift 2':'@',
'right':'right',
'shift 1':'!',
'shift open bracket':'{',
'shift 0':')',
'pause':'pause',
'f12':'f12',
'f11':'f11',
'period':'.',
'f10':'f10',
'space':'space',
'comma':',',
'shift equals':'+',
'shift minus':'_',
'9':'9',
'8':'8',
'shift down':'2',
'7':'7',
'6':'6',
'5':'5',
'shift backspace':'backspace',
'4':'4',
'3':'3',
'2':'2',
'1':'1',
'0':'0',
'shift up':'8',
'page up':'page up',
'shift begin':'5',
'backspace':'backspace',
'delete':'delete',
'open bracket':'[',
'shift period':'&gt;',
'slash':'/',
'escape':'escape',
'shift page up':'9',
'quote':"'",
'close bracket':']',
'shift left':'4',
}
</t>
<t tx="ekr.20070127142814.1238">def __init__( self, editor, minibuffer, commandlabel, c , extracommands = None ):
    global extensions
    if extensions == None:
        x = self.lookForExtensions()
        extensions = x
        
    self.editor = editor
    self.minibuffer = minibuffer
    self.commandlabel = commandlabel
    self.c = c
    #self.modeStrategies = []
    self.kbdquit_command = None
    self.defineStrategyObjects()
    self.defineStrategiesForKeystrokes()
    
    self.kcb = self.KeyProcessor( self )
    self.editor.addKeyListener( self.kcb )
    #if g.app.config.getBool( c, "complete_tags" ):
    tm = self.TagMatcher( self )
    self.editor.addKeyListener( tm )
    
    self._stateManager = self.stateManager( self )
    self._stateManager2 = self.stateManager( self )
    self.command_help = []
    self.keystroke_help = []
    self.addCompleters()
    self.block_moving = 0
    

        </t>
<t tx="ekr.20070127142814.1239">@others
</t>
<t tx="ekr.20070127142814.1240">def addCompleters( self ):
    
    manager = g.app.config.manager
    wm1 = WeakMethod( self, "managementListener" )
    manager.addNotificationDef( "complete-&lt;", wm1 )
    manager.addNotificationDef( "complete-(", wm1 )
    manager.addNotificationDef( "complete-[", wm1 )
    manager.addNotificationDef( "complete-{", wm1 )
    manager.addNotificationDef( "complete-'", wm1 )
    manager.addNotificationDef( 'complete-"', wm1 ) 

@
    if config.getBool( self.c, "complete-&lt;" ):
        self.swingmacs.addCompleter( "&lt;", "&gt;" )
    if config.getBool( self.c, "complete-(" ):
        self.swingmacs.addCompleter( "(", ")" )
    if config.getBool( self.c, "complete-[" ):
        self.swingmacs.addCompleter( "[", "]" )
    if config.getBool( self.c, "complete-{"):
        self.swingmacs.addCompleter( "{", "}" )
    if config.getBool( self.c, "complete-'" ):
        self.swingmacs.addCompleter( "'", "'" )
    if config.getBool( self.c, 'complete-"' ):
        self.swingmacs.addCompleter( '"', '"' )
    if config.getBool( self.c, "add_tab_for-:" ):
        self.swingmacs.addTabForColon( True )
</t>
<t tx="ekr.20070127142814.1241">def managementListener( self, notification= None, handback = None ):
    
    source = notification.getSource().toString()
    source = source.lstrip( "MBean:name=" )
    use = g.app.config.getBool( self.c, source )
    completer = source[ -1 ]
    if use:
        completions = {
            '(': ')',
            '{': '}',
            '&lt;': '&gt;',
            '[':']',
            '"': '"',
            "'" : "'",        
        }
        self.kcb.addCompleter( completer, completions[ completer ] )
    else:
        self.kcb.removeCompleter( completer )
        
</t>
<t tx="ekr.20070127142814.1242">def lookForExtensions( self ):

    import sys   
    
    path,file = g.os_path_split( g.app.loadDir )
    try:    
        tlevel = java.io.File( path )
        directories = tlevel.listFiles()
        exts = []
        for z in directories:
            if z.isDirectory() and z.getName() == 'swingmacs_exts':
            
                sys.path.append( z.getAbsolutePath() )
                files = z.listFiles()
                for z1 in files:
                    if z1.isFile() and z1.getName().endswith( '.py' ):
                        exts.append( z1 ) 
            
                break
    finally:
        pass
            
    
    mods = []
    for z in exts:
        try:
            name = z.getName()
            name = name[ : -3 ]
            mod = __import__( name )
            mods.append( mod )
            
        finally:
            pass
            
    return mods        
        
        
        
              
    </t>
<t tx="ekr.20070127142814.1243">def addCompleter( self, ch, ch2 ):
    self.kcb.addCompleter( ch, ch2 )
    

def addTabForColon( self, torf ):
    self.kcb.addTabForColon( torf )</t>
<t tx="ekr.20070127142814.1244">@
An extension is defined like so:
1. a function called:
    getCommands()
returns a dictionary of command names and command classes, an example:
    return {  "j-library": JLibrary_Loc }
this in turn causes an instance of the command class to be instatiated.
Instantiation involves passing the emacs instance to the command via
the costructor

    returned_dict[ "akey" ]( self )   #self is the emacs instance

the instance is then asked for new commands via a call to its 'addToAltX' method,
which returns a list of commands:
    return [ 'zoom-to-home', 'release-window' ]
after this the command is queried to see if it has an 'addToKeyStrokes' method.  If so
it is called.  This is to return keystrokes that activate the command:
    return [ 'Ctrl W', ]
all commands and keystrokes that are bound to the command object result in a call to
its __call__ method which should be defined like so:
    def __call__( self, event, command ):
        ....code....

</t>
<t tx="ekr.20070127142814.1245">@others</t>
<t tx="ekr.20070127142814.1246">class stateManager:
    
    def __init__( self, emacs):
        self.state = None
        self.emacs = emacs
        
        
    def hasState( self ):
        return self.state
        
    def setState( self, state ):
        self.state = state
        
    def filterTo( self, event, command ):
        #return self.emacs.strategyObjects[ self.state ]( event, command )
        return self.state( event, command )
        
    def clear( self ):
        self.state = None
        
        </t>
<t tx="ekr.20070127142814.1247">class KeyProcessor( aevent.KeyListener ):

    @others
</t>
<t tx="ekr.20070127142814.1248">def __init__( self, emacs ):
    self.emacs = emacs
    self.kRconsume = False
    self.kTconsume = False
    self.completers = {}
    self.tab_for_colon = False  
    self.tab_width = g.app.config.getInt( emacs.c, "tab_width" )
    import leoPlugins
    wm1 = WeakMethod( self, "newNodeSelected" )
    leoPlugins.registerHandler( "select1", wm1 )
    self.block_moving = 0
    </t>
<t tx="ekr.20070127142814.1249">def addCompleter( self, ch, ch2 ):
    self.completers[ ch ] = ch2

def addTabForColon( self, torf ):
    self.tab_for_colon = torf
    </t>
<t tx="ekr.20070127142814.1250">def removeCompleter( self, ch ):
    del self.completers[ ch ]
</t>
<t tx="ekr.20070127142814.1251">def keyReleased( self,event ):
    if self.kRconsume:
        self.kRconsume = False
        event.consume()</t>
<t tx="ekr.20070127142814.1252">def keyTyped( self, event ):
    if self.kTconsume:
        self.kTconsume = False
        event.consume()</t>
<t tx="ekr.20070127142814.1253">def keyPressed( self, event ):
     
    modifiers = event.getModifiers()
    mtxt = event.getKeyModifiersText(modifiers)
    mtxt = self.mungeModifiers(mtxt)
    ktxt = event.getKeyText(event.getKeyCode())
    if ktxt:
        ktxt = ktxt.lower()
        if event.isShiftDown():
            ktxt = "shift %s" % ktxt
        if SwingMacs.symtable.has_key(ktxt):
            ktxt = SwingMacs.symtable[ktxt]
    kc = event.getKeyChar()
    if mtxt == ktxt:
        command = mtxt
    else:
        command = '%s %s' % (mtxt, ktxt)
        command = command.strip()
    command = command.lower()
    #print "command '%s'" % command
    consume = self.emacs.masterCommand( event, command )
    #print "Consume %s %s" %( command, consume )
    if consume: #this blocks the event from going elsewhere, like the DocumentModel
        self.kTconsume = True
        self.kRconsume = True
        event.consume()
        return
    else:
        self.kTconsume = self.kRconsume = False
    
    kc = event.getKeyChar()
    
    stxt = self.emacs.editor.getSelectedText()
    if stxt:
        &lt;&lt;attempt block movement&gt;&gt;
    
    self.emacs.block_moving = -1
    editor = self.emacs.editor
    if self.tab_for_colon and kc == '\n':
        event.consume()
        self.insertPreviousLeadAndNewline()
        
    if self.completers.has_key( kc ):
        editor = self.emacs.editor
        doc = editor.getDocument()
        pos = editor.getCaretPosition()
        try:
        
            pc = doc.getText( pos -1, 1 )
            if pc in ( '"', "'" ): return
        
        except:
            pass
        event.consume()
        self.kTconsume = True
        self.kRconsume = True
        ac = self.completers[ kc ]
        #editor = self.emacs.editor
        if kc in ( "'", '"' ):
            doc.insertString( pos, '%s%s' % ( kc, ac ), None )
            editor.setCaretPosition( pos + 1 )
        else:
            doc.insertString( pos, '%s  %s' %( kc, ac ), None )
            editor.setCaretPosition( pos + 2 )
        if hasattr( self.emacs.c.frame.body.editor, "autocompleter"):
            self.emacs.c.frame.body.editor.autocompleter.hideAutoBox() 
        return

    &lt;&lt;tab consumption&gt;&gt;
    
    &lt;&lt;attempt node movement&gt;&gt;
    

</t>
<t tx="ekr.20070127142814.1254">if java.lang.Character.isWhitespace( kc ) and kc != '\n':
    if kc == '\t' and self.tab_width == -4:
        kc = " " * 4
    txt = stxt.split( "\n" )
    ntxt = []
    for z in txt:
        ntxt.append( "%s%s" % ( kc, z ) )
    ntxt = "\n".join( ntxt )
    start = self.emacs.editor.getSelectionStart()
    self.emacs.block_moving = start
    self.emacs.startCompounding( "Block Move Forward" )
    self.emacs.editor.replaceSelection( ntxt )
    self.emacs.stopCompounding()
    #self.emacs.block_moving = 0
    event.consume()
    self.kTconsume = self.kRconsume = True
    self.emacs.editor.select( start, start + len( ntxt ) )
    return
elif command == "delete":
    event.consume(); self.kTconsume = self.kRconsume = True
    self.emacs.editor.replaceSelection( "" )
    self.emacs.keyboardQuit()
    return
elif command == "backspace":
    txt = stxt.split( "\n" )
    ok = 1
    for z in txt:
        if not z or not java.lang.Character.isWhitespace( z[ 0 ] ):
            ok = 0
            break
            
    event.consume()
    self.kTconsume = self.kRconsume = True
    if ok:
        ntxt = []
        for z in txt:
            ntxt.append( z[ 1 : ] )
        ntxt = "\n".join( ntxt )
        start = self.emacs.editor.getSelectionStart()
        self.emacs.block_moving = start
        self.emacs.startCompounding( "Block Move Back" )
        self.emacs.editor.replaceSelection( ntxt )
        self.emacs.stopCompounding()
        #self.emacs.block_moving = 0
        self.emacs.editor.select( start, start + len( ntxt ) )
    return
&lt;&lt;numpad -&gt;&gt;
&lt;&lt;numpad +&gt;&gt;
</t>
<t tx="ekr.20070127142814.1255">elif command == "numpad -":
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    doc = editor.getDocument()
    e = doc.getParagraphElement( start )
    rstart = e.getStartOffset()
    self.kTconsume = self.kRconsume = True
    event.consume()
    if rstart == 0:
        c = self.emacs.c
        cp = c.currentPosition()
        p = cp.copy()
        p = p.threadBack()
        if p:
            caretp = editor.getCaretPosition()
            cstart = True
            if caretp == end: cstart = False
            self.emacs.startCompounding( "Block Move Up" )
            self.emacs.block_moving = -2
            editor.replaceSelection( "" )
            self.emacs.stopCompounding()
            bs = p.bodyString()
            if bs.endswith( "\n" ):
                nbs = "%s%s" %( bs, stxt )
                spot = len( bs )
            else:
                nbs = "%s\n%s" % ( bs, stxt )
                spot = len( bs ) + 1
            c.selectPosition( p )
            doc = editor.getDocument()
            self.emacs.startCompounding( "Block Move" )
            dlen = doc.getLength()
            if bs.endswith( "\n" ):
                doc.insertString( doc.getLength(), stxt, None )
            else:
                stxt = "%s%s" % ( "\n", stxt )
                doc.insertString( doc.getLength(), stxt , None )
            self.emacs.block_moving = 0
            estart = doc.getParagraphElement( dlen + 1)
            eend = doc.getParagraphElement( dlen + len( stxt ) )
            if cstart:
                editor.setCaretPosition( eend.getEndOffset() - 1 )
                editor.moveCaretPosition( estart.getStartOffset() )
            else:
                editor.setCaretPosition( estart.getStartOffset() )
                editor.moveCaretPosition( eend.getEndOffset() -1 )
            self.emacs.stopCompounding() 
        return
    self.emacs.startCompounding( "Block Move Up" )
    self.emacs.block_moving = -2
    foldprotection = self.emacs.c.frame.body.editor.foldprotection
    foldprotection.moveSelectionUp()
    self.emacs.block_moving = 0
    self.emacs.stopCompounding()
    return</t>
<t tx="ekr.20070127142814.1256">elif command == "numpad +":
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    self.kTconsume = self.kRconsume = True
    event.consume()
    doc = editor.getDocument()
    e = doc.getParagraphElement( end )
    ep = doc.getEndPosition()
    if e.getEndOffset() == ep.getOffset():
        c = self.emacs.c
        cp = c.currentPosition() 
        p = cp.copy()
        p = p.threadNext()
        if p:
            caretp = editor.getCaretPosition()
            cstart = True
            if caretp == end:
                cstart = False
            self.emacs.startCompounding( "Block Move Down" )
            self.emacs.block_moving = -2
            editor.replaceSelection( "" )
            self.emacs.stopCompounding()
            bs = p.bodyString()
            spot = 0
            c.selectPosition( p )
            doc = editor.getDocument()
            self.emacs.startCompounding( "Block Move" )
            if bs.startswith( "\n" ):
                doc.insertString( 0, stxt, None )
            else:
                stxt = "%s\n" % stxt
                doc.insertString( 0, stxt, None ) 
            self.emacs.block_moving = 0
            eend = doc.getParagraphElement( len( stxt ) )
            if cstart:
                editor.setCaretPosition( eend.getEndOffset() - 1 )
                editor.moveCaretPosition( 0 )
            else:
                editor.setCaretPosition( 0 )
                editor.moveCaretPosition( eend.getEndOffset() -1 )
            self.emacs.stopCompounding()
        return

    self.emacs.startCompounding( "Block Move Down" )
    self.emacs.block_moving = -2
    foldprotection = self.emacs.c.frame.body.editor.foldprotection
    foldprotection.moveSelectionDown()
    self.emacs.block_moving = 0
    self.emacs.stopCompounding()

    return</t>
<t tx="ekr.20070127142814.1257">if kc == '\t' and self.tab_width == -4:
    self.kTconsume = True
    self.kRconsume = True
    event.consume()
    editor = self.emacs.editor
    doc = editor.getDocument()
    pos = editor.getCaretPosition()
    try:
        
        doc.insertString( pos, " " * 4, None )
        return
        
    except:
        pass</t>
<t tx="ekr.20070127142814.1258">@
if command in ( "Up", "Down" ):
    cp = self.emacs.editor.getCaretPosition()
    doc = self.emacs.editor.getDocument()
    if command == "Up":
        e = doc.getParagraphElement( cp )
        rs = e.getStartOffset()
        if rs == 0:
            curp = self.emacs.c.currentPosition().copy()
            p = curp.threadBack()
            if p:
                self.kTconsume = self.kRconsume = True
                event.consume()
                self.emacs.c.selectPosition( p )
                self.emacs.editor.setCaretPosition( doc.getLength() )
    else:
        e = doc.getParagraphElement( cp )
        e2 = doc.getEndPosition()
        if e.getEndOffset() == e2.getOffset():
            curp = self.emacs.c.currentPosition().copy()
            p = curp.threadNext()
            if p:
                self.kTconsume = self.kRconsume = True
                event.consume()
                self.emacs.c.selectPosition( p )
                self.emacs.editor.setCaretPosition( 0 )
</t>
<t tx="ekr.20070127142814.1259">def newNodeSelected( self, *args ):
    
    if not self.block_moving:
        self.emacs.block_moving = -1</t>
<t tx="ekr.20070127142814.1260">def insertPreviousLeadAndNewline( self ):
    &lt;&lt; why is this code here? &gt;&gt;
    
    editor = self.emacs.editor
    doc = editor.getDocument()
    pos = editor.getCaretPosition()
    #start_text = doc.getText( 0, pos )
    paragraph = doc.getParagraphElement( pos )
    start = paragraph.getStartOffset()
    #end = paragraph.getEndOffset()
    #ind = start_text.rfind( '\n' )
    start_text = doc.getText( start, pos - start ) # end - start )
    #ind = start_text.rfind( '\n' )
    ind = 0

    if ind &gt; 0:
        line = start_text[ ind: ].strip( '\n' )
    else:
        line = start_text.strip( '\n' )
    
    i = len( line.lstrip() )
    
    if i == 0:
            instring = line
    else:
        instring = line[ : -i ]

    #instring = '\n%s' % instring
    #spaces = self.calculateExtraSpaces( line.lstrip() )
    #instring = "\n%s%s" %( spaces, instring )
    instring = '\n%s' % instring
    #printspaces
    #instring = "%s%s" %( spaces, instring )
    c = self.emacs.c
    #cp = c.currentPosition().copy()
    #language = g.scanForAtLanguage( c, cp )
    LanguageManager = leoLanguageManager.LanguageManager
    language = LanguageManager.getLanguageInEffect( c )
    if LanguageManager.indenters.has_key( language ):
        matcher = LanguageManager.indenters[ language ]
        #matcher = g.indenters[ language ]
        matcher.reset( line )
        if matcher.matches():
            if self.tab_width == -4:
                instring += " " * 4
            else:
                instring += "\t"
    doc.insertString( pos, instring, None )
</t>
<t tx="ekr.20070127142814.1261">'''
Originally this was in the leoSwingBody class.  This seemed right, it is core functionaliy.  But
In light of SwingMacs I reconsidered where it should go.  Temacs was a plugin, SwingMacs is core.
SwingMacs is responsible for processing key presses and such, consuming them if they are not to get
to the DocumentModel.  By placing this method in leoSwingBody, the Key processing responsibilities get
spread out.  Hence it makes more sense to move this method here, the responsibilites stay clearer.
'''</t>
<t tx="ekr.20070127142814.1262">def calculateExtraSpaces( self, line ):
    
    
    endsWithColon = False
    hasUncompleteBracket = False
    
    count1 = 0
    for z in line:
        if z == '[':
            count += 1
        elif z == ']':
            count -= 1
            
    
    count2 = 0
    last2 = None
    ll = len( line ) -1
    while ll &gt;= 0:
        char = line[ ll ]
        if char == '(':
            count2 += 1
            last2 = ll
        elif char == ')':
            count2 -= 1
            
        ll -= 1
            
            
    if count2 &gt; 0:
        nwline = line[ : last2 ]
        ws = []
        for z in nwline:
            if z.isspace():
                ws.append( z )
            else:
                ws.append( ' ' )
        
    
        return ''.join( ws )
        
    
    return ''    
        
        
    
    
    


</t>
<t tx="ekr.20070127142814.1263">def swaplines( self, line1s, line1e, line2s, line2e ):
    
    editor = self.emacs.c.frame.body.editor
 
    
    doc = editor.editor.getDocument()
    pos1s = doc.createPosition( line1s )
    pos1e = doc.createPosition( line1e -1 )
    line1 = doc.getText( line1s, ( line1e - line1s ) -1 )
    
    pos2s = doc.createPosition( line2s )
    pos2e = doc.createPosition( line2e -1 )
    line2 = doc.getText( line2s, ( line2e - line2s ) -1 )

    doc.replace( pos2s.getOffset(), pos2e.getOffset() - pos2s.getOffset(), line1, None )
    doc.replace( pos1s.getOffset(), pos1e.getOffset() - pos1s.getOffset(), line2, None )
    
    #print pos2s.getOffset(), pos1s.getOffset()

    
    </t>
<t tx="ekr.20070127142814.1264">def mungeModifiers(self, text):
    
    pieces = text.split("+")
    nwpieces = []
    for z in pieces:
        nz = z.lower()
        if nz != "shift":
            nwpieces.append(nz)
    
    nwpieces.sort()
    return " ".join(nwpieces)</t>
<t tx="ekr.20070127142814.1265">class TagMatcher( aevent.KeyAdapter ):
    
    def __init__( self, emacs ):
        aevent.KeyAdapter.__init__( self )
        self.emacs = emacs 
        self.configureMatching()
        wm1 = WeakMethod( self, "configureMatching" )
        g.app.config.manager.addNotificationDef( "complete_tags", wm1 )
        
    def configureMatching( self, notification = None, handback = None ):
        
        on = g.app.config.getBool( self.emacs.c, "complete_tags" )
        self.on = on
    
    def keyPressed( self, event ):
    
        if self.on and event.getKeyChar() == "&gt;":
            
            editor = self.emacs.editor
            pos = editor.getCaretPosition()
            #start = stext.Utilities.getRowStart( editor, pos )
            paragraph = editor.getDocument().getParagraphElement( pos )
            start = paragraph.getStartOffset()
            doc = editor.getDocument()
            txt = doc.getText( start, pos - start )
        
            txt = list( txt )
            txt.reverse()
            matchone = 0
            matchtwo = 0
            data = []
            if txt:
                if txt[ 0 ] == "/": return
            else:
                return
                
            for z in txt:    
                if z == "&lt;" and not matchone:
                    matchone = 1
                    data.append( z )
                    continue
                elif z == "&lt;" and matchone:
                    matchtwo = 1
                    break
                elif matchone:
                    break
                if not matchone:
                    data.append( z )
            
            if not data: return
            elif len( data ) == 1 and data[ 0 ] == "&lt;": return
            elif len( data ) &gt; 1 and not data[ -2 ].isalpha(): return
            
            if matchone and not matchtwo:
            
                data.reverse()
                data.insert( 1, "/" )
                element = ''.join( data )
                pieces = element.split()
                endelement = "%s%s" % (  pieces[ 0 ], "&gt;" )
                doc.insertString( pos, endelement , None )
                editor.setCaretPosition( pos )
                

</t>
<t tx="ekr.20070127142814.1266">class TabCompleter:

    def __init__( self, data ):
        self.data = data
        self.current = None
        self.current_iter = None
    
    def getCompletionList( self ):
        if self.current:
            return list( self.current )
        return []
    
    def reset( self ):
        self.current = None
        
    def extend( self, data ):
        for z in data:
            if z in self.data: continue
            self.data.append( z )
        
    def lookFor( self, txt ):
        
        nwdata = []
        for z in self.data:
            if z.startswith( txt ):
                nwdata.append( z )
                
        if len( nwdata ) &gt; 0:
            nwdata.sort()
            self.current = nwdata 
            self.current_iter = iter( nwdata )
            return True
        else:
            return False

    def getNext( self ):
        
        try:
            return self.current_iter.next()        
        except:
            
            self.current_iter = iter( self.current )
            return self.getNext()
    
            
</t>
<t tx="ekr.20070127142814.1267">def defineStrategyObjects( self ):

@        
    self.strategyObjects = {
    'incremental': self.incremental( self ),
    'dynamic-abbrev' : self.dynamicabbrevs( self ),
    'formatter' : self.formatter( self ),
    'killbuffer': self.killbuffer( self ),
    'deleter': self.deleter( self ),
     #'xcommand': self.alt_x_handler( self ),
    'rectangles': self.rectangles( self ),
    'zap': self.zap( self ),
    'comment': self.comment( self ),
    'movement': self.movement( self ),
    'transpose': self.transpose( self ),
    'capitalization': self.capitalization( self ),
    'replacement': self.replacement( self ),
    'sorters': self.sorters( self ),
    'lines': self.lines( self ),
    'tabs': self.tabs( self ),
    'registers': self.registers( self ),
    'selection': self.selection( self ),
    'completion': self.symbolcompletion( self ),
    'sexps': self.balanced_parentheses( self ),
    'tags': self.tags( self ),
    }
@c
    self.strategyObjects = []
    for z in dir( self ):

        item = getattr( self, z )
        if hasattr( item, "__bases__" ):
            if BaseCommand in item.__bases__:
                self.strategyObjects.append( item( self ) )
    
    self.ax = ax = self.alt_x_handler( self )
    self.strategyObjects.append( ax )
    self.strategyObjects.append( self.ctrl_x_handler( self ) )
    self.strategyObjects.append( self.ctrl_u_handler( self ) )
    kbdquit = self.getKeyStrokeForCommand( "keyboard-quit" )
    if kbdquit [ 0 ]:
        self.kbdquit_command = kbdquit[ 0 ]

    #self.strategyObjects[ 'xcommand' ] = self.alt_x_handler( self )
    #self.strategyObjects[ 'ctrlx' ] = self.ctrl_x_handler( self )
    #self.strategyObjects[ 'ctrlu' ] = self.ctrl_u_handler( self )
    
    for z in extensions:
        try:
            add = z.getCommands()
            continue
            for z in add.keys():
                try:
                    sO = add[ z ]( self )
                    self.strategyObjects[ z ] = sO
                    ncommands = sO.addToAltX()
                    for z in ncommands:
                        self.strategyObjects[ 'xcommand' ].commands[ z ] = sO
                finally:
                    pass
        finally:
            pass    

    #self.strategyObjects[ 'xcommand' ].createTabCompleter()
    ax.createTabCompleter()







</t>
<t tx="ekr.20070127142814.1268">def defineStrategiesForKeystrokes( self ):
        
    self.callbacks = {}
    for z in self.strategyObjects:
        if hasattr( z, "getKeystrokes" ):
            kstrokes = z.getKeystrokes()
            for ks in kstrokes:
                self.callbacks[ ks ] = z
    
    return
    
    cmds = self.strategyObjects
    callbacks = {
        
        'Ctrl S': cmds[ 'incremental' ],
        'Ctrl R': cmds[ 'incremental' ],
        'Alt Slash': cmds[ 'dynamic-abbrev' ],
        'Ctrl+Alt Slash': cmds[ 'dynamic-abbrev' ],
        'Ctrl+Alt Back Slash': cmds[ 'formatter' ],
        'Alt Back Slash': cmds[ 'formatter' ],
        'Alt+Shift 6': cmds[ 'formatter' ],
        'Ctrl K': cmds[ 'killbuffer' ],
        'Alt Y': cmds[ 'killbuffer' ],
        'Ctrl Y': cmds[ 'killbuffer' ],
        'Ctrl W': cmds[ 'killbuffer' ],
        'Alt W': cmds[ 'killbuffer' ],
        'Delete': cmds[ 'deleter' ],
        'Ctrl D': cmds[ 'deleter' ],
        'Alt X': cmds[ 'xcommand' ],
        'Alt+Shift Period': cmds[ 'movement' ],
        'Alt+Shift Comma': cmds[ 'movement' ],
        'Ctrl Left': cmds[ 'movement'],
        'Ctrl Right': cmds[ 'movement'],
        'Alt M': cmds[ 'movement' ],
        'Ctrl A': cmds[ 'movement' ],
        'Ctrl E': cmds[ 'movement' ],
        'Alt Z': cmds[ 'zap' ],
        'Ctrl Space': cmds[ 'selection' ],
        'Ctrl X': cmds[ 'ctrlx' ],
        'Alt T': cmds[ 'transpose' ],
        'Ctrl+Alt I': cmds[ 'completion' ],
        'Ctrl+Alt F': cmds[ 'sexps' ],
        'Ctrl+Alt B': cmds[ 'sexps' ],
        'Ctrl+Alt K': cmds[ 'sexps' ],
        'Ctrl+Alt Delete': cmds[ 'sexps' ],
        'Alt Period': cmds[ 'tags' ],
        'Alt+Shift 8': cmds[ 'tags' ],
        'Ctrl U': cmds[ 'ctrlu' ],
        
        }
        
    for z in cmds.keys():
        sO = cmds[ z ]
        if hasattr( sO, 'addToKeyStrokes' ):
            nstrokes = sO.addToKeyStrokes()
            if nstrokes:
                for z in nstrokes.keys():
                    callbacks[ z ] = nstrokes[ z ]
        
    self.callbacks = callbacks
    



</t>
<t tx="ekr.20070127142814.1269">@others
</t>
<t tx="ekr.20070127142814.1270">def startCompounding( self, identifier ):
    
    if self.c.frame.body.editor._node_undoer:
        self.c.frame.body.editor._node_undoer.startCompounding( identifier )
    else:
        self.c.undoer.startCompounding( identifier )
    
def stopCompounding( self ):
    
    if self.c.frame.body.editor._node_undoer:
        self.c.frame.body.editor._node_undoer.stopCompounding()
    else:
        self.c.undoer.stopCompounding()</t>
<t tx="ekr.20070127142814.1271">def addCommands( self, command, commands ):
    
    #xcommand = self.strategyObjects[ 'xcommand' ]
    xcommand = self.ax
    for z in commands:
        xcommand.commands[ z ] = command
        xcommand.keys.append( z )
        
        
    #self.strategyObjects[ command.getName() ] = command
    self.strategyObjects.append( command )
    
        
    



</t>
<t tx="ekr.20070127142814.1272">def masterCommand( self, event, command ):
    '''All processing goes through here.  'consume' is a flag to the
       KeyProcessor instance indicating if it should stop the event from
       propagating by consuming the event'''
        
        
    consume = False
    if command == self.kbdquit_command:
        return self.keyboardQuit( event )
    #if command == 'Ctrl G':
    #    return self.keyboardQuit( event )
      
    if self._stateManager.hasState():
        return self._stateManager.filterTo( event, command )
                
    if self.callbacks.has_key( command ):
        consume = self.callbacks[ command ]( event, command )
        
    if self._stateManager2.hasState():
        self._stateManager2.filterTo( event, command )
    
        
    return consume</t>
<t tx="ekr.20070127142814.1273">def setCommandText( self, txt ):
    
    self.commandlabel.setText( txt )
    
</t>
<t tx="ekr.20070127142814.1274">def getHelp2( self ):
    
    helptext ='''
    
    keystrokes:
    
    keyboard quit:
        Ctrl-g: quits any current command. 
    
    selecting:
        Ctrl-Spacebar : starts selecting.  To stop Ctrl-g.  In select mode, where you move the cursor
        is where the selection goes to.
        Ctrl-Spacebar on a selected region will Fold the text.  To Unfold
        a fold hit Ctrl-Spacebar when the cursor is on the fold.
        
        Also, when selected you can perform selective movement.  What this means is that by pressing
        keypad - or + you can move the selected block up( - ) or down( + ).  Entering a space will push
        the block forward one space. Backspace moves it back one space. Tab moves it forward tab width.
    
    kill and yanking:
        Ctrl-k : kills to end of line and inserts data into killbuffer
        Ctrl-w: kills region and inserts data into killbuffer
        Alt-w: copys region and inserts data into killbuffer   
        Ctrl-y: inserts first item in the killbuffer
        Alt-y: inserts next item in the killbuffer; allows the user to cycle 
           through the killbuffer, selecting the desired 'killed' text.
           
           
    deleting:    
        Ctrl-d: deletes next character.
        Delete: deletes previous character.
    
    
    dynamic abbreviations:
        Alt-/ : cycles through all words that match the starting word, which is used as a prefix.
        Ctrl-Alt-/ : takes current word, using it as a prefix and finds the common 
                    prefix among the matching prefix words. 'ea' with the words ( eat,
                    eats, eater ) will become 'eat' upon execution of this command.
        Tab : takes the current word, using it as a prefix and tries to match it against the current
              language in effect.  So if we were in python:
                  yi(Tab)
                  becomes:
                  yield
                    
    symbol completion:
        Alt Ctrl I : takes the start of the current word and completes it if it matches a keyword
                     of the current language in effect.  The user can cycle through the matches if there
                     are multiple matches.  For example:
                         d( Alt Ctrl I )
                         del
                         del( Alt Ctrl I )
                         def
                 
                 
    incremental search:
        Ctrl-s : starts incremental search forward
        Ctrl-r : starts incremental search backward
    
    
    formating:
        Ctrl-Alt-\ : takes the current selection and formats each line so that it has the same indentation
                 as the first line in the selection.
        Alt-\: deletes the surrounding whitespace
        Alt-^: joins line to previous line. 
        
    transposing:
        Alt-t: marks a word for moving.  2nd execution on word, trades positions of 1rst word with 2nd word. 
                 
    movement:
        Alt-&lt; (less then sign ): move to the beginning of buffer
        Alt-&gt; (greater then sign ): move to the end of the buffer
        Ctrl a: move to the beginning of line
        Ctrl e: move to end of the line
        Alt m: move to the end of the indentation on the current line.
        
    balanced parentheses or sexps:
        Ctrl Alt f: moves forward to matching parentheses.
        Ctrl Alt b: moves backwards to matching parentheses 
        Ctrl Alt k: kills the sexp forward. Can subsequently be yanked
        Ctrl Alt Delete: kills the sexp backward. Can subsequently be yanked
    
    
    zapping:
        Alt-z: zaps to the character specified by the user.
    
    Ctrl x: This keystroke prepares SwingMacs for another keystroke.  These are:
        Ctrl o: This deletes blanklines surrounding the current line. 
        
    tags:
        tags are definitions of language constructs.  Language specific tags:
            Python: def and class
            Java: class and methods
            
        keystrokes:
            Alt-. : queries the user for the tag they wish to goto.  If Enter is typed
                    the current word is used for the tag
            Ctrl-U Alt-. : goes to the next definition of a tag.  Useful if there are multiple
                           definitions for a tag.
            Alt-* : pops the buffer/node back to the last place Alt-. and friends were executed.
                    This can be executed multiple times, if Alt-. was executed multiple times,
                    taking the user back to where he started jumping.
    
    
    '''
    
    addstring = "\n".join( self.keystroke_help )
    
    helptext += addstring
    
    return helptext

</t>
<t tx="ekr.20070127142814.1275">def getHelp( self ):
    
    strokes = []
    commands = self.ax.commands
    haveseen = []
    for z in commands.keys():
        command = commands[ z ]
        if command in haveseen: continue
        haveseen.append( command )
        if hasattr( command, "getKeyStrokeInfo" ):
            ksi = command.getKeyStrokeInfo()
            istring = ksi.infoToString()
            strokes.append( istring )
    
    strokes.sort()
    return "\n".join( strokes )
</t>
<t tx="ekr.20070127142814.1276">def addCommandHelp( self, chelp ):

    self.command_help.append( chelp )
    
def addKeyStrokeHelp( self, kshelp ):
    
    self.keystroke_help.append( kshelp )</t>
<t tx="ekr.20070127142814.1277">def keyboardQuit( self, event=None ):
    
    self._stateManager.clear()
    self._stateManager2.clear()
    self.minibuffer.setText( '' )
    self.clearHighlights()
    sa = stext.SimpleAttributeSet()
    sa.addAttribute( 'dy-ab', 'dy-ab' )
    sa.addAttribute( 'kb', 'kb' )
    self.clearAttributes( sa )
    self.setCommandText( "" )
    for z in self.strategyObjects:
        if hasattr( z, "keyboardQuit" ):
            z.keyboardQuit()
            
    
    cp = self.editor.getCaretPosition()
    self.editor.setCaretPosition( cp )
    return True
</t>
<t tx="ekr.20070127142814.1278">def beep( self ):
    
    tk = awt.Toolkit.getDefaultToolkit()
    tk.beep()
    
</t>
<t tx="ekr.20070127142814.1279">def determineLanguage( self ):
    
    pos = self.c.currentPosition()
    #language = g.scanForAtLanguage( self.c, pos )
    language = LeoUtilities.scanForLanguage( pos )
    return language
    
</t>
<t tx="ekr.20070127142814.1280">def getTabWidth( self ):
    
    return abs( self.c.tab_width )</t>
<t tx="ekr.20070127142814.1281">def eventToMinibuffer( self, event ):

    code = event.getKeyCode()
    code = event.getKeyText( code )
    txt = self.minibuffer.getText()
    if code == 'Backspace':
        txt = txt[ : -1 ]
    else:
        char = event.getKeyChar()
        if java.lang.Character.isDefined( char ):
            txt = '%s%s' %( txt, char )
    self.minibuffer.setText( txt )
    return txt
    
def setMinibufferText( self, txt ):
    self.minibuffer.setText( txt )

def getMinibufferText( self ):
    return self.minibuffer.getText()
    
</t>
<t tx="ekr.20070127142814.1282">def getText( self ):
    
    doc = self.editor.getDocument()
    txt = doc.getText( 0, doc.getLength() )
    return txt
    
    
def getTextSlice( self, frm, to ):
    
    txt = self.getText()
    return txt[ frm: to ]
    
    
def replaceText( self, frm, to, txt ):
    
    try:
        doc = self.editor.getStyledDocument()
        doc.replace( frm, to - frm, txt, None )
    except java.lang.Exception, x:
        print x

def insertText(self, pos, txt):
    try:
        doc = self.editor.getStyledDocument()
        doc.insertString( pos, txt, None)
    except java.lang.Exception,x:
        print x
</t>
<t tx="ekr.20070127142814.1283">def getWordStart( self ):
    
    pos = self.editor.getCaretPosition()
    #start = stext.Utilities.getWordStart( self.editor, pos ) --this method acts screwy
    doc = self.editor.getStyledDocument()
    e = doc.getParagraphElement( pos )
    txt = doc.getText( e.getStartOffset(), pos - e.getStartOffset() )
    tlist = list( txt )
    tlist.reverse()
    wrd = []
    for z in tlist:
        if not z.isalnum() and z != "_":
            break
        else: wrd.insert( 0, z )
    if not wrd: return None
    else: return "".join( wrd )
    
@
    txt = doc.getText( 0, pos )
    txtlines = txt.splitlines()
    try:
        line = txtlines[ -1 ]
        chunks = line.split()
        c2 = []
        for z in chunks[ : ]:
            [ c2.append( x ) for x in z.split( '.' ) ]
        chunks = c2
        word = chunks[ -1 ]
        for z in xrange( len( word ) ):
            w = word[ z ]
            if w.isalnum() or w=='_': break
        word = word[ z: ]
    except:
        return None
    return word
@c
    
def getWordStartIndex( self, i = None ):
    
    pos = self.editor.getCaretPosition()
    doc = self.editor.getStyledDocument()
    e = doc.getParagraphElement( pos )
    txt = doc.getText( e.getStartOffset(), pos - e.getStartOffset() )
    tlist = list( txt )
    tlist.reverse()
    z = 0
    for z in xrange( len( tlist ) ):
        pos -= 1 #moving back one...
        if tlist[ z ] not in ( '_', '-' ) and ( tlist[ z ].isspace() or not tlist[ z ].isalnum() ):
            pos += 1 #we have gone too far, move back one place and get out of the loop
            break
    return pos
    #return pos - z
    #start = stext.Utilities.getWordStart( self.editor, pos ) ---this method acts screwy, thats why Im not using it.
    
    
def getWordEndIndex( self, i = None ):
    pos = self.editor.getCaretPosition()
    doc = self.editor.getStyledDocument()
    e = doc.getParagraphElement( pos )
    txt = doc.getText( pos, e.getEndOffset() - pos )
    z = 0
    for z in xrange( len( txt ) ):
        l = txt[z]
        if l != '_' and ( l.isspace() or not l.isalnum() ):
            break
    

    return pos + z
    

</t>
<t tx="ekr.20070127142814.1284">def getPreviousLine( self, pos ):
    
    #lines and rows are two different things!!!!!
    editor = self.editor
    #txt = editor.getText()
    #ntxt = txt[ : pos ]
    #ntxt = ntxt.split( "\n" )
    #if len( ntxt ) &lt; 2:
    #    return None
    #line = ntxt[ -2 ]
    #spot = pos - ( len( line ) + len( ntxt[ -1 ] ) )
    #return ( spot, line )
    
    
    #if txt[ pos ] != '\n':
    #    start = txt.rfind( '\n', 0, pos )
    #else:
    #    start = pos
    #if start &lt; 0:
    #    return None
    #start = start - 1
    #nstart = txt.rfind( '\n', 0, start )
    #if nstart == -1:
    #    nstart = 0
    #else:
    #    nstart += 1
    #doc = editor.getDocument()
    #txt = doc.getText( nstart, start - nstart )
    cparagraph = stext.Utilities.getParagraphElement( editor, pos )
    start = cparagraph.getStartOffset()
    #start = stext.Utilities.getRowStart( editor, pos )
    if start &lt;= 0:
        return None
    
    start = start - 1
    paragraph = stext.Utilities.getParagraphElement( editor, start )
    nstart = paragraph.getStartOffset()
    #nstart = stext.Utilities.getRowStart( editor, start )
    doc = editor.getDocument()
    txt = doc.getText( nstart, start - nstart )
    return ( nstart, txt )
    
#    editor = self.emacs.editor
#    pos = editor.getCaretPosition()
#    if pos != -1:
#        
#        txt = editor.getText()
#        start = txt.rfind( '\n', 0, pos )
#        if start == -1: start = 0
#        else:
#            if start != 0:
#                start = txt.rfind( '\n', 0, start )
#                if start == -1: start = 0
#                else: 
#                    start += 1
#        
#        end = txt.find( '\n', pos )
#        if end == -1: end = len( txt )
    
    
def getNextLine( self, pos ):
    editor = self.editor
    doc = editor.getDocument()
    #end = stext.Utilities.getRowEnd( editor, pos )
    cparagraph = stext.Utilities.getParagraphElement( editor, pos )
    end = cparagraph.getEndOffset()
    #txt = editor.getText()
    #end = txt.find( '\n', pos )
    if  ( end -1 ) &gt;= doc.getLength() or end == -1:
        return None
    #end = end + 1
    #nend = txt.find( '\n', end )
    #if nend == -1:
    #    nend = doc.getLength()
    paragraph = stext.Utilities.getParagraphElement( editor, end )
    nend = paragraph.getEndOffset()

    txt = doc.getText( paragraph.getStartOffset(), paragraph.getEndOffset() - paragraph.getStartOffset() )
    if txt:
        if txt[ -1 ] == '\n':
            txt = txt[ : -1 ]
    #print "END is \n%s\nEND" % txt
    return ( paragraph.getStartOffset(), txt ) </t>
<t tx="ekr.20070127142814.1285">def findPre( self, a, b ):
    st = ''
    for z in a:
        st1 = st + z
        if b.startswith( st1 ):
            st = st1
        else:
            return st
    return st  
</t>
<t tx="ekr.20070127142814.1286">def getAttributeRanges( self, name ):
    
    dsd = self.editor.getStyledDocument()
    alen = dsd.getLength()
    range = []
    for z in xrange( alen ):
        element = dsd.getCharacterElement( z )
        as = element.getAttributes()
        if as.containsAttribute( name, name ):
            range.append( z )
            
    return range
    
    
    
def addAttributeToRange( self, name, value, offset, length, color = None ):
    
    
    dsd = self.editor.getStyledDocument()
    sa = stext.SimpleAttributeSet()
    sa.addAttribute( name, value )
    dsd.setCharacterAttributes( offset, length, sa, True )
    if color != None:
        self.addHighlight( offset, length+offset, color )

def clearAttributes( self, attrset ):
    dsd = self.editor.getStyledDocument()
    alen = dsd.getLength()
    for z in xrange( alen ):
        element = dsd.getCharacterElement( z )
        as = element.getAttributes()
        if as.containsAttributes( attrset ):
            mas = stext.SimpleAttributeSet() #We have to make a clean one and copy the data into it!  The one returned is immutable
            mas.addAttributes( as )
            mas.removeAttributes( attrset ) #we remove the tag from here.
            amount = as.getEndOffset() - as.getStartOffset() #very important to do it like this, giving each character an attribute caused colorization problems/doing the whole thing at once seems to have cleared those problems up.
            dsd.setCharacterAttributes( z, amount, mas, True )            
    
def clearAttribute( self, name ):
    dsd = self.editor.getStyledDocument()
    alen = dsd.getLength()
    for z in xrange( alen ):
        element = dsd.getCharacterElement( z )
        as = element.getAttributes()
        if as.containsAttribute( name, name ):
            mas = stext.SimpleAttributeSet() #We have to make a clean one and copy the data into it!  The one returned is immutable
            mas.addAttributes( as )
            mas.removeAttribute( name ) #we remove the tag from here.
            amount = as.getEndOffset() - as.getStartOffset() #very important to do it like this, giving each character an attribute caused colorization problems
            dsd.setCharacterAttributes( z, amount, mas, True )
    
def clearHighlights( self ):
    
    self.editor.getHighlighter().removeAllHighlights()    
    

def addHighlight( self, start, end, color ):
    
    highlighter = self.editor.getHighlighter()
    painter = stext.DefaultHighlighter.DefaultHighlightPainter( color )
    highlighter.addHighlight( start, end, painter )
    
def getHighlights( self ):
    
    highlighter = self.editor.getHighlighter()
    return highlighter.getHighlights()
    
    
def removeTextWithAttribute( self, name ):
    
    arange = self.getAttributeRanges( name )
    dsd = self.editor.getStyledDocument()
    alen = len( arange )
    if alen:
        dsd.remove( arange[ 0 ], alen )
    
def insertTextWithAttribute( self, txt, name ):
    
    sa = stext.SimpleAttributeSet()
    sa.addAttribute( name, name )
    pos = self.editor.getCaretPosition()
    dsd = self.editor.getStyledDocument()
    dsd.insertString( pos, txt, sa )


def insertTextGetPositions( self, txt ):
    
    pos = self.editor.getCaretPosition()
    doc = self.editor.getDocument()
    doc.insertString( pos, txt, None )
    p1 = doc.createPosition( pos )
    p2 = doc.createPosition( pos + len( txt ) )
    return ( p1, p2, txt )
    
    
def removeTextWithPositions( self, pos1, pos2 ):
    
    try:
        doc = self.editor.getDocument()
        doc.remove( pos1.getOffset(), pos2.getOffset() - pos1.getOffset() )   
    except:
        pass
    
def isPositionRangeValid( self, pos1, pos2, txt ):
               
    try:        
        doc = self.editor.getDocument()
        txt2 = doc.getText( pos1.getOffset(), pos2.getOffset() - pos1.getOffset() )
        return txt == txt2
    except:
        pass
    
    return False
</t>
<t tx="ekr.20070127142814.1287">def addToKillbuffer( self, text ):
    
    #self.strategyObjects[ 'killbuffer' ].insertIntoKillbuffer( text )
    for z in self.strategyObjects:
        if z.__class__.__name__ == 'killbuffer':
            z.insertIntoKillbuffer( text )
            return
            


</t>
<t tx="ekr.20070127142814.1288">        
    
        
        

         

         
         
        
        
        
        
        


        


</t>
<t tx="ekr.20070127142814.1289">def getKeyStrokesForCommands( self, commands ):
    

    rdict = {}
    for z in commands:
        kstroke = self.getKeyStrokeForCommand( z )
        if kstroke[ 0 ]:
            rdict[ kstroke[ 0 ] ] = kstroke[ 1 ]
    return rdict
    

def getKeyStrokeForCommand( self, command ):
    
    c = self.c
    rv = g.app.config.getShortcut( c, command )
    rv = list(rv)
    if rv[ 1 ]:
        try:
            rv[1] = rv[1].lower()
            ftoken = rv[ 1 ].split()
            rv2 = ftoken[ 0 ].split( "-" )
            for z in xrange( len(rv2)):
                rv2[z] = rv2[z].strip()
            nwlist = rv2[ : -1 ]
            nwlist.sort()
            nwlist.append( rv2[ -1 ] )   
            nwtxt = " ".join( nwlist )
            return ( nwtxt, command )
        except Exception, x:
            #print x
            pass
    return ( None , None )
    

</t>
<t tx="ekr.20070127142814.1290">def configureStrategyWithKeystrokes(self, strategy, kstrokes, cmddict ):
    
    strategy.kstrokes_info = {}
    for z in kstrokes.keys():
        cmd = kstrokes[ z ]
        cmddict[ z ] = cmddict[ cmd ]
        strategy.kstrokes_info[ z ] = strategy.info_structures[ cmd ]
    strategy.kstuple = tuple( kstrokes.keys() )      
</t>
<t tx="ekr.20070127142814.1291">@
This node organizes the classes that implement a rough cut of the Strategy pattern for the keystrokes.
Each recognized keystroke goes to the masterCommand, but the masterCommand just decides on the code that
should be executed, in this case it delegates the call to a Strategy object that decides upon what methods
to process the key stroke.  This has these benefits:
1. State is broken further from the container Object( Emacs ).
2. Changes to the processing methods no longer has global consequences.  It is conceivable that a different Strategy could
be swapped in by configuration or some other means.  All a strategy has to do is implement the __call__ operator to have
the event and keystroke passed into it.

This design is based off of the lessons learned in the temacs plugin for CPython Leo.  Its evolution followed this pattern:
1. It started as a flat function based module.  Though a useful learning experiment this grew too large and became
    hard to think about.  Changes were becoming difficult.
2. At this point it became apparent that more structure was needed.  It was refactored( in Refactoring this is a 'Big Refactoring')
into a class, with some helper classes.  This eased the ability to reason about and modify the code.
3. After working with this big class, it became apparent again that a further restructuring was needed.  The idea of breaking
the methods that were grouped under one rubric into further classes arose; the Strategy pattern seemed to be what was called for.
And here we are in SwingMacs making the first cut at this new decomposed design for the Jython port.


@c




@others</t>
<t tx="ekr.20070127142814.1292">class scrolling( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands = {
            'scroll-tree-mode': self.scrollTree
        }
        self.defineInfoStructures()
        self.ctuple = tuple( self.commands.keys() )
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)    
            
    def __call__( self, event, command ):
        
        return self.commands[command](command)
        
    @others</t>
<t tx="ekr.20070127142814.1293">def scrollTree( self, command ):
    
    self.emacs._stateManager.setState( self )  
    self.emacs.setCommandText( "Scrolling Tree Mode" )
    self.emacs.setMinibufferText( "" )
    tree = self.emacs.c.frame.tree
    if command == "up":
        tree.scrollUp()
        self.emacs.setMinibufferText( command )
    elif command == "down":
        tree.scrollDown()
        self.emacs.setMinibufferText( command )
    elif command == "right":
        tree.scrollRight()
        self.emacs.setMinibufferText( command )
    elif command == "left":
        tree.scrollLeft()
        self.emacs.setMinibufferText( command )
    return True</t>
<t tx="ekr.20070127142814.1294">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
    

</t>
<t tx="ekr.20070127142814.1295">def keyboardQuit( self ):
    pass
</t>
<t tx="ekr.20070127142814.1296">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Scrolling", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( "scroll-tree-mode", "in scroll-tree-mode the tree can be scrolled by typing the up, down, left, and right arrow keys.  All other keys are ignored." ), ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

    </t>
<t tx="ekr.20070127142814.1297">class apropos( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.prompt = "Apropos symbol(regexp):"
        self.mode = 0
        c = self.emacs.c
        fg = g.app.config.getColor( c, 'body_text_foreground_color' )
        bg = g.app.config.getColor( c, 'body_text_background_color' )
        sc = g.app.config.getColor( c, 'body_selection_color' )
        stc = g.app.config.getColor( c, 'body_text_selected_color' )
        from leoSwingFrame import getColorInstance
        self.fg = getColorInstance( fg, awt.Color.GRAY )
        self.bg = getColorInstance( bg, awt.Color.WHITE )
        self.sc = getColorInstance( sc, awt.Color.GREEN )
        self.stc = getColorInstance( stc, awt.Color.WHITE )
        self.defineInfoStructures()
    
    def __call__( self, event, command ):
        
        if not self.mode:
            self.startApropos()
            return True
        else:
            if command == 'Enter':
                self.searchForApropos()
                return self.emacs.keyboardQuit( event )
            else:
                self.emacs.eventToMinibuffer( event )
                return True
        
    @others

</t>
<t tx="ekr.20070127142814.1298">def startApropos( self ):
    self.mode = 1
    self.emacs._stateManager.setState( self )  
    self.emacs.setCommandText( self.prompt )
    self.emacs.setMinibufferText( "" )
    
</t>
<t tx="ekr.20070127142814.1299">def searchForApropos( self ):
    
    stxt = self.emacs.getMinibufferText()
    ax = self.emacs.ax
    commands = ax.getAltXCommands()
    infolist = []
    haveseen = []
    regex1 = regex.Pattern.compile( stxt ).matcher( "" )
    regex2 = regex.Pattern.compile( stxt ).matcher( "" )
    for z in commands.keys():
        item = commands[ z ]
        if item in haveseen: continue
        if hasattr( item , "getInformation" ):
            haveseen.append( item )
            infodict = item.getInformation()
            for z2 in infodict.keys():
                info = infodict[ z2 ]
                name = info.name
                doc = info.doc
                regex1.reset( name ); regex2.reset( doc )
                if regex1.find() or regex2.find():
                    infolist.append( "%s\n\t%s\n" % ( name, doc ) )    
    
    infolist.sort()
    istring = "\n".join( infolist )
    jtp = swing.JTextPane()
    jtp.setForeground( self.fg )
    jtp.setBackground( self.bg )
    jtp.setSelectedTextColor( self.stc )
    jtp.setSelectionColor( self.sc )
    jtp.setEditable( False )
    jtp.setText( istring )
    jtp.setCaretPosition( 0 )
    jsp = swing.JScrollPane( jtp )
    jb = swing.JButton( "x" )
    jb.setToolTipText( "Press to Close Apropos" )
    jb.setBorder( None )
    jp = swing.JPanel( awt.BorderLayout() )
    jp.add( jsp )
    jp.add( jb, awt.BorderLayout.WEST )
    log = self.emacs.c.frame.log
    log.addTab( "Apropos", jp )
    log.selectTab( jp )
    def close( event ):
        log.removeTab( jp )
    jb.actionPerformed = close
    
    

</t>
<t tx="ekr.20070127142814.1300">def getAltXCommands( self ):
    return ( 'apropos', )
    
    
def getKeystrokes( self ):
    return ()
    
    

</t>
<t tx="ekr.20070127142814.1301">def keyboardQuit( self ):
    self.mode = 0
</t>
<t tx="ekr.20070127142814.1302">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
@
def getKeyStrokeInfo( self ):
    sum = Information( "",  "" )
    for z in self.kstrokes_info:
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    return sum
@c    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Apropos", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( "apropos", "show all commands that match the regex passed in.  Matching occurs either in the command name or in the command description.  For example with the 'apropos' command it would match on the command and in the text when searched with 'apro'." ), ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

    </t>
<t tx="ekr.20070127142814.1303">class editors( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands = {
            'switch-editor' : self.switchEditor
        }
        self.defineInfoStructures()
    
    def __call__( self, event, command ):
        
        rval = self.commands[ command ]()        
        self.emacs.keyboardQuit( event )
        return rval        
        
    @others</t>
<t tx="ekr.20070127142814.1304">def switchEditor( self ):

    c = self.emacs.c
    c.frame.body.nextEditor()
    return True</t>
<t tx="ekr.20070127142814.1305">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Editors", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( "switch-editor", 'go to next editor.' ), ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

    </t>
<t tx="ekr.20070127142814.1306">def keyboardQuit( self ):
    self.mode = 0
</t>
<t tx="ekr.20070127142814.1307">def getAltXCommands( self ):
    return ( 'switch-editor', )
    
    
def getKeystrokes( self ):
    return ()
    
    

</t>
<t tx="ekr.20070127142814.1308">class incremental( BaseCommand ):
    
    def __init__( self, emacs ):

        self.emacs = emacs
        self.defineInfoStructures()
        self.iway = None
        i = java.lang.Integer.decode( '#63c6de' )
        self.highlight = awt.Color( i )
        self.commands = { 
        
            "isearch-forward": self.startIncrementalForward,
            "isearch-backward": self.startIncrementalBackward 
        
        }
        self.ctuple = tuple( self.commands.keys() )
        
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)    
        self.barrier_reached = False
        
    
    def __call__( self, event, command ):
        
        component = event.getSource()
        stxt = component.getText()
        pos = component.getCaretPosition()
        if self.commands.has_key( command ):
            self.commands[ command ]( command )
            if not self.emacs.minibuffer.getText():
                return True
        elif command == 'Enter':
            return self.emacs.keyboardQuit( event )
        else:
            self.setMiniBuffer( event )
        

        if event.getKeyChar() == aevent.KeyEvent.CHAR_UNDEFINED :
            return True
        
        if not self.barrier_reached or self.commands.has_key( command ):
            dc = DefCallable( lambda : self.incrementalSearch( event , command, stxt, pos) )
            swing.SwingUtilities.invokeLater( dc.wrappedAsFutureTask() )  
        return True
        
    def setMiniBuffer( self, event ):
        self.emacs.eventToMinibuffer( event )
        
    @others
        



</t>
<t tx="ekr.20070127142814.1309">def startIncrementalForward( self, command ):

    self.iway = 'forward'
    self.emacs._stateManager.setState( self )  
    self.emacs.setCommandText( "I-Search:" )
    
def startIncrementalBackward( self, command ):
    
    self.iway = 'backward'
    self.emacs._stateManager.setState( self )  
    self.emacs.setCommandText( "I-Search:" )
    
</t>
<t tx="ekr.20070127142814.1310">def isForward( self, command ):

    return self.__testMethod( self.startIncrementalForward, command )
        

def isBackward( self, command ):
    
    return self.__testMethod(  self.startIncrementalBackward, command )
        
        
def __testMethod( self, method, command ):
            
    if self.commands.has_key( command ):
        method2 = self.commands[ command ]
        if method == method2: return True
        return False
    else:
        return False

    </t>
<t tx="ekr.20070127142814.1311">def incrementalSearch( self, event, command, stxt, pos ):
        
    self.emacs.clearHighlights()
    txt = self.emacs.minibuffer.getText()
    c = self.emacs.c
    source = event.getSource()
    if self.iway == 'forward':
        if not self.isForward( command ) and pos &gt;= len( txt ): #this enables the user to enter text and have the search move forward a bit, not a whole token
            pos = pos - len( txt )
        i = self.forwardSearch( pos, txt, stxt )
        if i != -1:
            pos = pos + i + len( txt )
        else: #prepare to check next node, or check next node
            if not self.barrier_reached:
                self.barrier_reached = True
                self.emacs.setCommandText( "Reached End of Node. isearch-forward to continue search." )
                return True
            cp = c.currentPosition()
            if self.barrier_reached:
                self.barrier_reached = False
                cp = c.currentPosition()
                i = -1
                tn = cp.threadNext()
                if tn:
                    c.frame.tree.select( tn )
                    i = self.forwardSearch( 0, txt, tn.bodyString() )
                    if i != -1:
                        pos = i + len( txt )
    else:
        if not self.isBackward( command ) and ( pos + len( txt ) ) &lt;= len( stxt ): #This enables the user to enter text and have the search move backwards a bit not a whole search
            pos = pos + len( txt )
        i = self.backwardSearch( pos, txt, stxt )
        if i != -1:
            pos = i
        else: #start from the back again
            if not self.barrier_reached:
                self.barrier_reached = True
                self.emacs.setCommandText( "Reached Top Of Node, isearch-backward to continue search." )
                return True
            if self.barrier_reached:
                self.barrier_reached = False
                cp = c.currentPosition()
                tb = cp.threadBack()
                if tb:
                    c.frame.tree.select( tb )
                    bs = tb.bodyString()
                    i = self.backwardSearch( len( bs ), txt, bs )
                    if i != -1:
                        pos = i

    if i == -1: 
        self.emacs.setCommandText( "Failed I-Search:" )
        return True
    dhl = self.deferedHighlight( source, pos, self.iway, self.highlight, len( txt ), self.emacs )   
    swing.SwingUtilities.invokeLater( dhl )  
    self.emacs.setCommandText( "I-Search:" )
    return True


</t>
<t tx="ekr.20070127142814.1312">def forwardSearch( self, pos, txt, stxt ):
    
    _stxt = stxt[ pos : ]
    return _stxt.find( txt )
    

def backwardSearch( self, pos, txt, stxt ):
    
    end = len( stxt ) - pos
    if end != 0:
        stxt = stxt[ : -end ]
    return stxt.rfind( txt )</t>
<t tx="ekr.20070127142814.1313">class deferedHighlight( java.lang.Runnable ):
    
    def __init__( self, source, pos, iway, highlight, length, emacs ):
        self.source = source
        self.pos = pos
        self.iway = iway
        self.highlight = highlight
        self.length = length
        self.emacs = emacs
        
        
        
    def run( self ):
        source = self.source; pos = self.pos
        source.setCaretPosition( pos )
        if self.iway == 'forward':
            start = pos - self.length
            self.emacs.addHighlight( start, start + self.length, self.highlight ) 
        else:
            self.emacs.addHighlight( pos, pos + self.length, self.highlight )
</t>
<t tx="ekr.20070127142814.1314">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1315">def keyboardQuit( self ):
    self.barrier_reached = False</t>
<t tx="ekr.20070127142814.1316">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Incremental Search", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum
    
def getKeyStrokeInfo( self ):
   
    sum = Information( "",  "" )
    for z in self.kstrokes_info: 
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    
    return sum
    

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( "isearch-forward", "starts forward incremental search" ), 
               ( "isearch-backward", "starts backward incremental search" ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

    </t>
<t tx="ekr.20070127142814.1317">class dynamicabbrevs( BaseCommand ):
    
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.dynaregex = re.compile( r'[%s%s\-_]+' %( string.ascii_letters, string.digits ) ) #for dynamic abbreviations
        self.searchtext = None
        self.returnlist = []
        self.tlist = []
        self.ind = 0 #last spot wordindex returned
        self.dynamiclist = java.util.TreeSet()
        self.added_languages = []
        self.positions = None
        self.tpositions = None
        self.createDynamicList()
        import leoPlugins
        wm1 = WeakMethod( self, "valueChanged" )
        leoPlugins.registerHandler( "select1", wm1 )
        self.commands = {
            "dabbrev-expand": self.dynamicExpansion,
            "dabbrev-completion": self.dynamicExpansion2,
            "keyword-complete": self.tab
        }
        
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)        
        
    def __call__( self, event, command ):
        
        return self.commands[command](event)

        
    @others

</t>
<t tx="ekr.20070127142814.1318">def dynamicExpansion( self, event ):#, store = {'rlist': [], 'stext': ''} ):
    
    word = self.emacs.getWordStart()
    ind = self.emacs.getWordStartIndex()
    
    if not word:
        self.clearDynamic()
        return   
    elif word and self.searchtext == None:
        self.searchtext = word
        self.ind = ind
    elif not word.startswith( self.searchtext ) or self.ind != ind:

        self.clearDynamic()
        self.searchtext = word
        self.ind = ind

    
    if self.positions and self.emacs.isPositionRangeValid( *self.positions ): #indicates that expansion has started
        self.emacs.removeTextWithPositions( self.positions[ 0 ], self.positions[ 1 ] )
        if self.returnlist:
            txt = self.returnlist.pop()
            self.positions = self.emacs.insertTextGetPositions( txt )
        else:
            self.getDynamicList( self.searchtext, self.returnlist )#rebuild
            if self.returnlist:
                txt = self.returnlist.pop()
                self.positions = self.emacs.insertTextGetPositions( txt )
            #self.emacs.insertTextWithAttribute( txt, tag )
            #self.emacs.insertTextWithAttribute( self.searchtext , tag )
        return   
    elif self.searchtext:
        self.returnlist = []
        self.getDynamicList( self.searchtext, self.returnlist )
        if self.returnlist:
            start = self.emacs.getWordStartIndex()
            ntxt = self.returnlist.pop()
            self.emacs.replaceText( start, start + len( word ), "" )
            self.positions = self.emacs.insertTextGetPositions( ntxt )
            #self.emacs.addAttributeToRange( tag, tag, start, len( ntxt ) )
            



</t>
<t tx="ekr.20070127142814.1319">def dynamicExpansion2( self, event ):
    
    i = self.emacs.getWordStartIndex()
    i2 = self.emacs.getWordEndIndex() 
    txt = self.emacs.getTextSlice( i, i2 )
    rlist = []
    self.getDynamicList( txt, rlist )
    if txt in rlist:
        rlist.remove(txt)
    dEstring = reduce( self.emacs.findPre, rlist )
    try:
        if dEstring:
            self.emacs.replaceText( i, i2, dEstring )        
    except java.lang.Exception, x:
        print x</t>
<t tx="ekr.20070127142814.1320">def tab( self, event ):
    
    word = self.emacs.getWordStart()
    ind = self.emacs.getWordStartIndex()
    
    if not word:
        self.clearTab()
        return False  
    elif word and self.searchtext == None:
        self.searchtext = word
        self.ind = ind
    elif not word.startswith( self.searchtext ) or self.ind != ind:

        self.clearTab()
        self.searchtext = word
        self.ind = ind

    
    if self.tpositions and self.emacs.isPositionRangeValid( *self.tpositions ): #indicates that expansion has started
        self.emacs.removeTextWithPositions( self.tpositions[ 0 ], self.tpositions[ 1 ] )
        if self.tlist:
            txt = self.tlist.pop()
            self.tpositions = self.emacs.insertTextGetPositions( txt )
        else:
            self.getTabList( self.searchtext, self.tlist )#rebuild
            if self.tlist:
                txt = self.tlist.pop()
                self.tpositions = self.emacs.insertTextGetPositions( txt )
            else:
                return False
        return True  
    elif self.searchtext:
        self.tlist = []
        self.getTabList( self.searchtext, self.tlist )
        if self.tlist:
            start = self.emacs.getWordStartIndex()
            ntxt = self.tlist.pop()
            self.emacs.replaceText( start, start + len( word ), "" )
            self.tpositions = self.emacs.insertTextGetPositions( ntxt )
            return True
        else:
            return False

</t>
<t tx="ekr.20070127142814.1321">def getDynamicList( self, txt , rlist ):

     ttext = self.emacs.getText()   
     self.addToDynamicList( ttext )
@
     import LeoUtilities
     language = LeoUtilities.scanForLanguage( self.emacs.c.currentPosition() )
     if language not in self.added_languages:
        import leoLanguageManager
        if hasattr( leoLanguageManager.LanguageManager, language ):
            tokens = getattr( leoLanguageManager.LanguageManager, language )
            for z in tokens.keySet():
                self.dynamiclist.add( z )
            self.added_languages.append( language )
@c
                
     started = 0
     for z in self.dynamiclist:
        if z.startswith( txt ):
             if not started:
                 started = 1
             rlist.append( z )
             continue
        if started:
            break
            
     def cmplen( a,b ):
        if len( a ) &lt; len( b ): return 1
        elif len( a ) &gt; len( b ): return -1
        return 0 
     rlist.sort( cmplen )
     if rlist:
        rlist.insert( 0, rlist.pop() )
     return rlist

@
     ttext = self.emacs.getText()
     items = self.dynaregex.findall( ttext ) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith( txt ) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append( word )
             else:
                 rlist.remove( word )
                 rlist.append( word )


</t>
<t tx="ekr.20070127142814.1322">def getTabList( self, txt , rlist ):


     editor = self.emacs.c.frame.body.editor
     cdeterminer = editor.cdeterminer
     tokens = cdeterminer.getColoredTokens()
     for z in tokens.keySet():
        if( z.startswith( txt ) ):
            rlist.append( z )          
                
     
     if rlist:      
        def cmplen( a,b ):
            if len( a ) &lt; len( b ): return 1
            elif len( a ) &gt; len( b ): return -1
            return 0 
        rlist.sort( cmplen )
     return rlist




</t>
<t tx="ekr.20070127142814.1323">def addToDynamicList( self, ttext ):

    items = self.dynaregex.findall( ttext )
    for z in items:
        self.dynamiclist.add( z )</t>
<t tx="ekr.20070127142814.1324">def clearDynamic( self ):

    self.returnlist = []
    self.searchtext = None
    self.ind = None
    self.positions = None

def clearTab( self ):
    self.tlist = []
    self.searchtext = None
    self.ind = None
    self.tpositions = None
    


</t>
<t tx="ekr.20070127142814.1325">def createDynamicList( self ):
    
    c = self.emacs.c
    class _buildDynamicList:
        
        def __init__( self, c, da ):
            self.c = c
            self.da = da
            
        def __call__( self ):
            
            rp = self.c.rootPosition().copy()
            for z in rp.allNodes_iter( copy = 1 ):
                btx = z.bodyString()
                items = self.da.dynaregex.findall( btx )
                self.da.dynamiclist.addAll( items )
            #path,file = g.os_path_split(g.app.loadDir) 
            g.es( "dynamic list built: dynamic abbreviations online" )
            
    
    dc = DefCallable( _buildDynamicList( c, self ) )
    c.frame.gui.addStartupTask( dc.wrappedAsFutureTask() )
    

</t>
<t tx="ekr.20070127142814.1326">def valueChanged( self, *args ):
    
    values = args[ 1 ]
    o_p = values[ "old_p" ]
    if hasattr( o_p, 'v' ) and o_p.v:
        self.addToDynamicList( o_p.bodyString() )
    

</t>
<t tx="ekr.20070127142814.1327">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple

@
def getCommands( self ):
    return ()
def getKeystrokes( self ):
    return ( 'alt slash' ,'alt ctrl slash', 'tab' )

</t>
<t tx="ekr.20070127142814.1328">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1329">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    
def getKeyStrokeInfo( self ):
   
    sum = Information( "",  "" )
    for z in self.kstrokes_info: 
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    
    return sum
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Dynamic Abbreviations", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ("dabbrev-expand", "Expand the word in the editor before point as a dynamic abbrev, by searching in the abbrev list for words starting with that abbreviation."),
               ("dabbrev-completion", "Complete the word before point as a dynamic abbrev.  This completes to the common prefix of all possible matches."),
               ("keyword-complete", "Completes the word against the current languages keywords and conventions."),):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info </t>
<t tx="ekr.20070127142814.1330">class formatter( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands = {
        
        'indent-region': self.indentRegionToFirstLine,
        'indent-rigidly': self.indentRigidly,  
        'indent-relative': self.indentRelative,
        'delete-blank-lines': self.deleteBlankLines,
        'delete-horizontal-space': self.deleteSurroundingSpaces,
        'delete-indentation': self.joinLineToPrevious,
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        
        rval = self.commands[ command ]()        
        self.emacs.keyboardQuit( event )
        return rval
                
    @others

</t>
<t tx="ekr.20070127142814.1331">def indentRegionToFirstLine( self ):
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start != end:
        sstart = stext.Utilities.getRowStart( editor, start )
        send = stext.Utilities.getRowEnd( editor, end )
        doc = editor.getStyledDocument()
        txt = doc.getText( sstart, send - sstart )
        lines = txt.splitlines()
        firstline = lines[ 0 ]
        ws_start = []
        for z in firstline:
            if z.isspace():
                ws_start.append( z )
            else:
                break
                
        ws_segment = ''.join( ws_start )
        nwlines = [ firstline, ]
        for x in lines[ 1: ]:
            x_nws = x.lstrip()
            x_new = '%s%s' % ( ws_segment, x_nws )
            nwlines.append( x_new )
            
        new_txt = '\n'.join( nwlines )
        pos = editor.getCaretPosition()
        try:
            self.emacs.startCompounding( "Indent Region" ) 
            doc.replace( sstart, send - sstart, new_txt, None )
        finally:
            self.emacs.stopCompounding()
    return True
        
            

</t>
<t tx="ekr.20070127142814.1332">def indentRigidly( self ):
    
    editor = self.emacs.editor
    txt = editor.getSelectedText()
    if txt == None: return True
    
    txtlines = txt.splitlines( True )
    ntxtlines = []
    for z in txtlines:
        
        nline = '\t%s' % z
        ntxtlines.append( nline )
        
    
    ntxt = ''.join( ntxtlines )
    pos = editor.getCaretPosition()
    try:
        self.emacs.startCompounding( "Indent Rigidly" )
        editor.replaceSelection( ntxt )
    finally:
        self.emacs.stopCompounding()
    editor.setCaretPosition( pos )
    return True
    
</t>
<t tx="ekr.20070127142814.1333">def indentRelative( self ):

    editor = self.emacs.editor
    sd = editor.getStyledDocument()
    pos = editor.getCaretPosition()
    
    txt = editor.getText()
    
    
    plstart, plend = self.definePreviousLine()
    
    if plstart == -1 or plend == -1:
        sd.insertString( pos, '\t', None )
        return True         
       

    ltxt = txt[ plstart: plend ]

    
    find = txt.rfind( '\n', 0, pos )
    find += 1
    rlpos = pos - find
    
    if rlpos &gt; ( len( ltxt ) -1 ):
        sd.insertString( pos, '\t', None )
        return True
        
    addon = []
    for z in ltxt[ : rlpos ]:
        if z.isspace():
            addon.append( z )
        else:
            addon.append( ' ' )
            
    add = ''.join( addon )
    
    if ltxt[ rlpos ].isspace():
        addon = []
        for z in ltxt[ rlpos: ]:
            if z.isspace():
                addon.append( z )
            else:
                break
        add = add + ''.join( addon )
    else:
        addon = []
        for z in ltxt[ rlpos: ]:
            if z.isspace(): break
            else:
                addon.append( ' ' )
        
        add = add + ''.join( addon )
        rlpos += len( addon )
        addon = []
        for z in ltxt[ rlpos: ]:
            if z.isspace():
                addon.append( z )
            else:
                break
        add = add + ''.join( addon )
    try:
        self.emacs.startCompounding( "Indent Relative" )
        if txt[ find: pos ].isspace():               
            sd.replace( find, pos - find, '' , None )
            sd.insertString( find, add, None )
        else:
            atext = txt[ find: pos ]
            atext = atext.rstrip()
            atext = atext + add[ len( atext ) -1 : ]
            sd.replace( find, pos - find, '', None )
            sd.insertString( find, atext, None )
    finally:
        self.emacs.stopCompounding()
         
    return True
                       
        
    
    

</t>
<t tx="ekr.20070127142814.1334">def deleteSurroundingSpaces( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()    
    if pos != -1:
        
        start = stext.Utilities.getRowStart( editor, pos )
        end = stext.Utilities.getRowEnd( editor, pos )
        doc = editor.getDocument()
        txt = doc.getText( start, end - start )
        rpos = pos - start
        part1 = txt[ : rpos ]
        part1 = part1.rstrip()
        part2 = txt[ rpos: ]
        part2 = part2.lstrip()
        doc.replace( start, end - start, "%s%s" %( part1, part2 ), None )
        editor.setCaretPosition( start + len( part1 ) )
</t>
<t tx="ekr.20070127142814.1335">def joinLineToPrevious( self ):
    
    plstart, plend = self.definePreviousLine()
    if plstart == -1 or plend == -1:
        return
        
    editor = self.emacs.editor
    pos = editor.getCaretPosition() 
    if pos != -1:
        
        doc = editor.getDocument()
        start = stext.Utilities.getRowStart( editor, pos )
        end = stext.Utilities.getRowEnd( editor, pos )
        txt = doc.getText( start, end - start )
        txt = ' %s' % txt.lstrip()
        doc.remove( start, end - start )
        doc.insertString( plend, txt, None )
        editor.setCaretPosition( plend )
        


</t>
<t tx="ekr.20070127142814.1336">def deleteBlankLines( self ):

    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        doc = editor.getDocument()
        start = stext.Utilities.getRowStart( editor, pos )
        end = stext.Utilities.getRowEnd( editor, pos )
        txt = doc.getText( 0, doc.getLength() )
        cline = txt[ start: end ] + '\n'
        
        first = txt[ : start ]
        lines = first.splitlines( 1 )
        lines.reverse()
        #line = lines[ 0 ]
        #del lines[ 0 ]
        #line = lines.pop()
        cpos_minus = 0
        if cline.isspace():
            for z in xrange( len( lines )):
                if lines[ 0 ].isspace() or lines[ 0 ] == "":                    
                    cpos_minus += len( lines[ 0 ] )
                    del lines[ 0 ]
                else:
                    break
        lines.reverse()
        #lines.append( line )
        
        
        end = txt[ end: ]
        lines2 = end.splitlines( 1 )
        #line = lines2[ 0 ]
        #del lines2[ 0 ]
        for z in xrange( len( lines2 ) ):
            if lines2[ 0 ].isspace() or lines2[ 0 ] == "":
                #lines2.pop()
                del lines2[ 0 ]
            else:
                break
        #lines2.insert( 0, line )
        fpart = ''.join( lines )
        spart = ''.join( lines2 )
        nwtext = '%s%s%s' %( fpart, cline, spart )
        doc.replace( 0, doc.getLength(), nwtext, None )
        editor.setCaretPosition( pos - cpos_minus )
        return True
        
        
            

</t>
<t tx="ekr.20070127142814.1337">def definePreviousLine( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    
    txt = editor.getText()
    find = txt.rfind( '\n', 0, pos )
    if find == -1:
        return -1, -1
    else:
        find2 = txt.rfind( '\n', 0, find )
        if ( find2 - 1 ) == find:
            return -1, -1
        elif find2 == -1:
            find2 = 0
        else:
            find2 += 1    

    return find2, find</t>
<t tx="ekr.20070127142814.1338">def getAltXCommands( self ):
    
    return self.ctuple
    
def getCtrlXCommands( self ):   
    return ( 'Ctrl O' , )
    
def getKeystrokes( self ):
    
    return self.kstuple


    
</t>
<t tx="ekr.20070127142814.1339">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1340">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    
def getKeyStrokeInfo( self ):
   
    sum = Information( "",  "" )
    for z in self.kstrokes_info: 
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    
    return sum
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Indenting", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( 'indent-region', 'indents region to the indentation of the first line in the region.' ),
               ( 'indent-rigidly', 'indents region by a tab.' ),
               ( 'indent-relative', '''indents by these rules:
        1. If no previous line, indents by a tab
        2. If a previous line, will indent to the first word of that line.  This process
        continues from word to word on the previous line.''' ),
               ( 'delete-blank-lines', "delete blank lines around the current line"),
               ( 'delete-horizontal-space', "delete spaces and tabs around the point"),
               ( 'delete-indentation', 'Join two lines by deleting the intervening newline, along with any indentation following it') ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 
        


    </t>
<t tx="ekr.20070127142814.1341">class killbuffer( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.killbuffer = []
        self.cliptext = None
        self.defineInfoStructures()
        self.commands = {
          'kill-line' : self.killToEndOfLine,
          'yank': self.yank,
          'yank-pop': self.walkKB,
          'kill-region': self.killRegion,
          'kill-ring-save': self.copyRegion,
        
        }
        
        self.ctuple = tuple( self.commands.keys() ) 
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)        
    
        #for killbuffer
        self.last_clipboard = None
        self.kbiterator = self.iterateKillBuffer()
        self.reset = False
        self.lastKBSpot = None
        self.lastRange = None
        
        
    def __call__( self, event, command ):
        
        self.commands[ command ]()
        self.emacs.keyboardQuit( event )
        return True    
        
    @others

</t>
<t tx="ekr.20070127142814.1342">def kill( self, frm, end ):
    
    editor = self.emacs.editor
    doc = editor.getStyledDocument()
    if frm != end:
        txt = doc.getText( frm, end - frm )
        doc.replace( frm, end - frm, "", None )
        self.insertIntoKillbuffer( txt )
        g.app.gui.replaceClipboardWith( txt )
    else:
        if frm != doc.getLength():
            doc.replace( frm, 1, "", None )</t>
<t tx="ekr.20070127142814.1343">def insertIntoKillbuffer( self, txt ):
    
    self.killbuffer.insert( 0, txt )
    self.reset = True</t>
<t tx="ekr.20070127142814.1344">def killToEndOfLine( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    end = stext.Utilities.getRowEnd( editor, pos )
    try:
        self.emacs.startCompounding( "Kill To End Of Line" )
        self.kill( pos, end  )    
    finally:
        self.emacs.stopCompounding()
    return True
    

</t>
<t tx="ekr.20070127142814.1345">def copyRegion( self ):

    region = self.getRegion()
    if region:
        editor = self.emacs.editor
        doc = editor.getStyledDocument()
        start = region[ 0 ]
        end = region[ 1 ]
        txt = doc.getText( start, end-start )
        self.insertIntoKillbuffer( txt )
    return True
</t>
<t tx="ekr.20070127142814.1346">def killRegion( self ):
    
    region = self.getRegion()
    if region:
        try:
            self.emacs.startCompounding( "Kill Region" )
            self.kill( *region )
        finally:
            self.emacs.stopCompounding()
    return True</t>
<t tx="ekr.20070127142814.1347">def getRegion( self ):

    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if end == start: return None
    else:
        return start, end    
</t>
<t tx="ekr.20070127142814.1348">def walkKB( self ):

    pos = self.emacs.editor.getCaretPosition()
    if pos != self.lastKBSpot:
        self.lastRange = None
    self.lastKBSpot = pos
    clip_text = self.doesClipboardOfferNewData() #  self.getClipboard()     
    if self.killbuffer or clip_text:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()   
            if self.lastRange:
                self.emacs.replaceText( self.lastRange[0], self.lastRange[1], txt)
                self.lastRange = (self.lastRange[ 0 ], self.lastRange[0] + len(txt))
            else:
                self.emacs.insertText(pos, txt)
                self.lastRange = (pos, pos + len(txt))
            self.emacs.editor.setCaretPosition( pos )

            
    return True

</t>
<t tx="ekr.20070127142814.1349">def yank( self ):
    return self.walkKB()</t>
<t tx="ekr.20070127142814.1350">def iterateKillBuffer( self ):

    while 1:
        if self.killbuffer:
            self.last_clipboard = None
            for z in self.killbuffer:
                if self.reset:
                    self.reset = False
                    break        
                yield z
                

        
            
</t>
<t tx="ekr.20070127142814.1351">def doesClipboardOfferNewData( self  ):
    
    ctxt = None
    try:
        #ctxt = tbuffer.selection_get( selection='CLIPBOARD' )
        ctxt = g.app.gui.getTextFromClipboard()
        if ctxt != self.last_clipboard or not self.killbuffer:
            self.last_clipboard = ctxt
            if self.killbuffer and self.killbuffer[ 0 ] == ctxt:
                return None
            return ctxt
        else:
            return None
        
    except:
        return None
        
    return None</t>
<t tx="ekr.20070127142814.1352">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ): 
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1353">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1354">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Killing and Yanking", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum
    
def getKeyStrokeInfo( self ):
   
    sum = Information( "",  "" )
    for z in self.kstrokes_info: 
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    
    return sum
    

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( "kill-line", "kills to the end of the line and appends to killbuffer" ), 
               ( "kill-region", "kills the current selection and appends to killbuffer" ),
               ( "kill-ring-save", "copies the current selection and appends to killbuffer"),
               ( "yank", "yanks from the killbuffer and inserts"),
               ( "yank-pop", "yanks from the killbuffer and allows the repeated yanking"), ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

</t>
<t tx="ekr.20070127142814.1355">class deleter( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands = {
            'delete-char': self.deleteNextChar,
            'delete-backward-char': self.deletePreviousChar,        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        self.commands[ command ]()

            
    @others
</t>
<t tx="ekr.20070127142814.1356">def deletePreviousChar( self ):
    
    editor = self.emacs.editor
    sstart = editor.getSelectionStart()
    send = editor.getSelectionEnd()
    if sstart != send: return False
    pos = editor.getCaretPosition()
    if pos != 0:
        doc = editor.getStyledDocument()
        spos = pos -1
        doc.replace( spos, 1 , "", None )
    return True</t>
<t tx="ekr.20070127142814.1357">def deleteNextChar( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    doc = editor.getStyledDocument()
    if pos != doc.getLength():
        doc.replace( pos, 1 , "", None )
    return True
</t>
<t tx="ekr.20070127142814.1358">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1359">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1360">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):

    
    header = '''--------'''   
    sum = Information( "Deleting", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'delete-char', "delete next character" ),
               ( 'delete-backward-char', 'delete previous character') ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    
    
</t>
<t tx="ekr.20070127142814.1361">class alt_x_handler:
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.defineCommands()
        self.last_command = None
        self.keys = []
        self.createViewer()
    
    def getAltXCommands( self ):
        return copy.copy( self.commands )
        
    def defineCommands( self ):
        
        sO = self.emacs.strategyObjects
        self.commands = {}
        for z in sO:
            if hasattr( z, "getAltXCommands" ):
                commands = z.getAltXCommands()
                for x in commands:
                    self.commands[ x ] = z
                    
        
        
    def createTabCompleter( self ):
        self.keys = self.commands.keys()
        self.tbCompleter = self.emacs.TabCompleter( self.keys )
       
    def __call__( self, event, command ):
        
        if command == 'alt x':
            self.tbCompleter.reset()
            self.last_command = None
            self.emacs._stateManager.setState( self ) 
            self.emacs.setCommandText( "alt-x:" )
            return True
        
        if command == 'tab':
            
            txt = self.emacs.minibuffer.getText()
            if self.last_command == None or not txt.startswith( self.last_command ):
                txt = self.emacs.minibuffer.getText()
                fnd = self.tbCompleter.lookFor( txt )
                if fnd:
                    clist = self.tbCompleter.getCompletionList()
                    clist.append( "\n" )
                    lasstring = "\n".join( clist ) 
                    self.viewer.setText( lasstring )
                    self.viewer.setCaretPosition( 0 )
                    if self.jsp.getParent() is None:
                        c = self.emacs.c
                        log = c.frame.log
                        log.addTab( "Completions", self.jsp )
                        log.selectTab( self.jsp )
                    self.last_command = txt
                    next = self.tbCompleter.getNext()
                    i = self.viewer.getText().find( next + "\n" )
                    if i != -1:
                        try:
                            doc = self.viewer.getDocument()
                            doc.setCharacterAttributes( 0, doc.getLength(), self.sas2, True )
                            doc.setCharacterAttributes( i, len( next ), self.sas, True )
                            doc.setParagraphAttributes( 0, doc.getLength(), self.alignment, True )
                            self.viewer.setCaretPosition( i )
                        except java.lang.Exception, x:
                            x.printStackTrace()

                    self.emacs.minibuffer.setText( next )
            else :
                next = self.tbCompleter.getNext()
                i = self.viewer.getText().find( next + "\n" )
                if i != -1:
                    try:
                        doc = self.viewer.getDocument()
                        doc.setCharacterAttributes( 0, doc.getLength(), self.sas2, True )
                        doc.setCharacterAttributes( i, len( next ), self.sas, True )
                        self.viewer.setCaretPosition( i )
                    except java.lang.Exception, x:
                        x.printStackTrace()
                self.emacs.minibuffer.setText( next )
            return True
        
        if command == 'enter':
            self.detachViewer()
            return self.execute( event, command )
        else:
            self.emacs.eventToMinibuffer( event )
            return True    
    
    def execute( self, event, command ):
        
        txt = self.emacs.minibuffer.getText()
        if self.commands.has_key( txt ):
            return self.commands[ txt ]( event, txt )
        else:
            self.emacs.keyboardQuit( event )
            self.emacs.setCommandText( "Command Not Defined" )
     

    @others
    












</t>
<t tx="ekr.20070127142814.1362">def createViewer( self ):
    
    self.viewer = swing.JTextPane()
    c = self.emacs.c
    fg = g.app.config.getColor( c, 'body_text_foreground_color' )
    bg = g.app.config.getColor( c, 'body_text_background_color' )
    sc = g.app.config.getColor( c, 'body_selection_color' )
    stc = g.app.config.getColor( c, 'body_text_selected_color' )
    from leoSwingFrame import getColorInstance
    fg = getColorInstance( fg, awt.Color.GRAY )
    bg = getColorInstance( bg, awt.Color.WHITE )
    sc = getColorInstance( sc, awt.Color.GREEN )
    stc = getColorInstance( stc, awt.Color.WHITE )
    self.viewer.setBackground( bg ); self.viewer.setForeground( fg );
    self.alignment = stext.SimpleAttributeSet()
    stext.StyleConstants.setAlignment( self.alignment, stext.StyleConstants.ALIGN_CENTER )
    self.sas = stext.SimpleAttributeSet()
    stext.StyleConstants.setForeground( self.sas, stc )
    stext.StyleConstants.setBackground( self.sas, sc )
    self.sas2 = stext.SimpleAttributeSet()
    self.viewer.setEditable( False )
    self.jsp = swing.JScrollPane( self.viewer )    

</t>
<t tx="ekr.20070127142814.1363">def getCommandHelp( self ):
    
    commands = [ "Commands are accessed by the Alt-X keystroke.  This will put the system in command mode.",
                 "The user can type in the name of the command in the minibuffer and execute it with an Enter keypress.",
                "",    
                "A shortcut to accessing commands is to type a prefix of the command in the minibuffer and hit Tab.",
                "",
                "For example:",
                "op(Tab press )",
                "could become:",
                "open-rectangle",
                "",
                "the user then just has to type Enter and the open-rectangle command is executed.  Also by repeatedly",
                "typing Tab the user will cycle through all commands that start with the entered prefix.  So if there",
                "were 5 commands, for example, that started with 'op' the user could cycle through them and choose the",
                "one that he wanted to execute.\n\n" ] #I don't use triple quotes here, well because it does not do what I envision in Leo
    commands = "\n".join( commands ) 


    help = {}
    haveseen = []
    for z in self.commands.keys():
        command = self.commands[ z ]
        if command in haveseen: continue
        haveseen.append( command )
        if hasattr( command, "getSummaryInfo" ):
            sinfo = command.getSummaryInfo()
            help[ sinfo.name ] = sinfo.infoToString()
    
    helpkeys = help.keys()
    helpkeys.sort()
    hlist = []
    for z in helpkeys:
        hlist.append( help[ z ] )
    hlist.append( "\n" )
    hstring = "\n".join( hlist )     
    more_help = '\n'.join( self.emacs.command_help )
    commands += hstring
    commands += more_help
    return commands


</t>
<t tx="ekr.20070127142814.1364">def getCommands( self ):
    return ()
    
    
def getKeystrokes( self ):
    
    return  ( 'alt x', )
    
</t>
<t tx="ekr.20070127142814.1365">def matchCommandWithString( self, regex ):
    
    rlist = []
    for z in self.commands.keys():
        if z.startswith( regex ):
            rlist.append( z )
            
    return rlist</t>
<t tx="ekr.20070127142814.1366">def keyboardQuit( self ):
    self.detachViewer()

def detachViewer( self ):   
    if not self.jsp.getParent() is None:
        c = self.emacs.c
        log = c.frame.log
        log.removeTab( self.jsp )</t>
<t tx="ekr.20070127142814.1367">class ctrl_x_handler:
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.defineCommands()
        self.last_command = None
        self.keys = []
        
    def defineCommands( self ):
        
        self.commands = {}
        sO = self.emacs.strategyObjects
        for z in sO:
            if hasattr( z, "getCtrlXCommands" ):
                cmds = z.getCtrlXCommands()
                for x in cmds:
                    self.commands[ x ] = z
        
        return
        #sO = self.emacs.strategyObjects
        #self.commands = {
        #
        #    'Ctrl O': sO[ 'formatter' ],
        #    
        #    
        #    }
        
    def __call__( self, event, command ):
        
        if command == 'Ctrl X':
            #self.tbCompleter.reset()
            self.last_command = None
            self.emacs._stateManager.setState( self ) 
            self.emacs.setCommandText( "Ctrl-x:" )
            return True
            
        if command in self.commands:
            return self.commands[ command ]( event, command )
            
    @others
    
</t>
<t tx="ekr.20070127142814.1368">def getCommands( self ):
    return ()
    
    
def getKeystrokes( self ):
    
    return  ( 'Ctrl X', )
    
</t>
<t tx="ekr.20070127142814.1369">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1370">class ctrl_u_handler:
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.defineCommands()
        self.last_command = None
        self.keys = []
        
    def defineCommands( self ):
        
        self.commands = {}
        sO = self.emacs.strategyObjects
        for z in sO:
            if hasattr( z, "getCtrlUCommands" ):
                cmds = z.getCtrlUCommands()
                for x in cmds:
                    self.commands[ x ] = z
        
        return
        
        
        sO = self.emacs.strategyObjects
        self.commands = {
        
            'Alt Period': sO[ 'tags' ],
            
            
            }
        
    def __call__( self, event, command ):
        
        if command == 'Ctrl U':
            #self.tbCompleter.reset()
            self.last_command = None
            self.emacs._stateManager.setState( self ) 
            self.emacs.setCommandText( "Ctrl-u:" )
            return True
            
        if command in self.commands:
            return self.commands[ command ]( event, "Ctrl U %s" % command )
            
    @others</t>
<t tx="ekr.20070127142814.1371">def getCommands( self ):
    return ()
    
    
def getKeystrokes( self ):
    
    return  ( 'Ctrl U', )
    
</t>
<t tx="ekr.20070127142814.1372">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1373">class rectangles( BaseCommand ):
    
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands = {
        
        'open-rectangle': self.openRectangle,
        'delete-rectangle': self.deleteRectangle,
        'clear-rectangle': self.clearRectangle,
        'delete-whitespace-rectangle': self.deleteWhiteSpaceRectangle,
        'string-insert-rectangle': self.stringInsertRectangle,
        'string-rectangle': self.stringRectangle,
        'kill-rectangle': self.killRectangle,
        'yank-rectangle': self.yankRectangle,
        
        }
        
        self.mode = None
        #emacs.modeStrategies.append( self )
        self.last_killed_rectangle = None
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)     
        
    def __call__( self, event, command ):
        
        if self.mode:
            if command == 'Enter':
                if self.mode == 1:
                    self.stringInsertRectangle()
                    return self.emacs.keyboardQuit( event )
                elif self.mode == 2:
                    self.stringRectangle()
                    return self.emacs.keyboardQuit( event )
            else:
                return  self.emacs.eventToMinibuffer( event )
        
        if command in self.commands:
            quit = self.commands[ command ]()
            if quit:
                return self.emacs.keyboardQuit( event )
            else: return True
        
    @others
        





</t>
<t tx="ekr.20070127142814.1374">def definePoints( self, start, end ):

    txt = self.emacs.editor.getText()
    rl_start = txt.rfind( '\n', 0, start )
    if rl_start == -1: rl_start = 0
    else: 
        rl_start = rl_start + 1
        
    pos = start - rl_start
        
    rl_end = txt.rfind( '\n', 0, end )
    if rl_end == -1: rl_end = 0
    else:
        rl_end = rl_end + 1  
        
    pos2 = end - rl_end
    
    return pos, pos2, rl_start, rl_end
       
    

</t>
<t tx="ekr.20070127142814.1375">def insertText( self, rl_start, end, ntxt ):
 
    sd = self.emacs.editor.getStyledDocument()
    sd.remove( rl_start, end - rl_start )
    sd.insertString( rl_start, ntxt, None ) 
    return True </t>
<t tx="ekr.20070127142814.1376">def openRectangle( self ):
        
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )  
        txt = txt[ rl_start: end ]
    
        
        insert = ' ' * ( pos2  - pos )

        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                nwline = '%s%s%s' %( z[ :pos ], insert, z[ pos : ] )
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        try:
            self.emacs.startCompounding( "Open Rectangle" ) 
            rv = self.insertText( rl_start, end, ntxt )
        finally:
            self.emacs.stopCompounding()
        return rv
</t>
<t tx="ekr.20070127142814.1377">def clearRectangle( self ):
    
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
    
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
    
        replace = ' ' * ( pos2  - pos )
        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                nwline = '%s%s%s' %( z[ :pos ], replace, z[ pos2 : ] )
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        
        try:
            self.emacs.startCompounding( "Clear Rectangle" ) 
            rv = self.insertText( rl_start, end, txt )
        finally:
            self.emacs.stopCompounding()
        return rv
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )     
        #return True </t>
<t tx="ekr.20070127142814.1378">def killRectangle( self ):
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
        
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
    

        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        oldlines = []
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
                oldlines.append( z )
            else:
                nwline = '%s%s' %( z[ :pos ], z[ pos2 : ] )
                ntxtlines.append( nwline )
                oldlines.append( z[ pos: pos2 ] )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )
        self.last_killed_rectangle = oldlines 
        try:
            self.emacs.startCompounding( "Kill Rectangle" ) 
            rv = self.insertText( rl_start, end, ntxt )   
        finally:
            self.emacs.stopCompounding()
        return rv
        #return True </t>
<t tx="ekr.20070127142814.1379">def yankRectangle( self ):
    
    if self.last_killed_rectangle == None: return True
    
    editor = self.emacs.editor
    start = editor.getCaretPosition()
    
    if start &gt; -1:
        self.emacs.startCompounding( "Yank Rectangle" )
        txt = editor.getText()
        
        rl_start = txt.rfind( '\n', 0, start )
        if rl_start == -1: rl_start = 0
        else: 
            rl_start = rl_start + 1
            
        
        pos = start - rl_start
        
        sd = editor.getStyledDocument()
        start2 = rl_start
        for itext in self.last_killed_rectangle:
            
            if sd.getLength() &lt; start2:
                sd.insertString( sd.getLength(), '%s%s' %( itext, '\n' ), None )
                start2 += len( itext ) + 1
            else:
                if( sd.getText( start2 , 1 ) == '\n' ):
                    sd.insertString( start2, itext, None )
                    nspot = start2 + len( itext )
                else:
                    sd.insertString( start2 + pos, itext, None )
                    nspot = start2 + pos + len( itext )
      
                ftxt = sd.getText( 0, sd.getLength() )
                where = ftxt.find( '\n', nspot )
                if where == -1:
                    sd.insertString( sd.getLength(), '\n', None )
                    start2 = sd.getLength() + 1
                else:
                    start2 = where + 1   
            
        self.emacs.stopCompounding()
        return True     

</t>
<t tx="ekr.20070127142814.1380">def deleteRectangle( self ):
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
        
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
    

        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                nwline = '%s%s' %( z[ :pos ], z[ pos2 : ] )
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )     
        #return True
        try:
            self.emacs.startCompounding( "Delete Rectangle" ) 
            rv = self.insertText( rl_start, end, ntxt )
        finally:
            self.emacs.stopCompounding()
        return rv

        </t>
<t tx="ekr.20070127142814.1381">def deleteWhiteSpaceRectangle( self ):
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
        
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                if z[ pos ].isspace():
                    space_text = z[ pos: pos2 ]
                    space_text = space_text.lstrip()
                    nwline = '%s%s%s' % ( z[ :pos ], space_text, z[ pos2 : ] )
                else:
                    nwline = z
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        try:
            self.emacs.startCompounding( "Delete Whitespace Rectangle" ) 
            rv = self.insertText( tl_start, end, ntxt )
        finally:
            self.emacs.stopCompounding()
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )      
        #return True</t>
<t tx="ekr.20070127142814.1382">def stringRectangle( self ):
    
    if self.mode == None:
        self.mode = 2
        self.emacs.setCommandText( "string-rectangle" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return False
        
        
    self.mode = None
    string_txt = self.emacs.minibuffer.getText()
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
    
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                nwline = '%s%s%s' % ( z[ :pos ], string_txt , z[ pos2 : ] )
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        
        try:
            self.emacs.startCompounding( "String Rectangle" ) 
            rv = self.insertText( rl_start, end, ntxt )
        finally:
            self.emacs.stopCompounding()
        return rv
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )         
        #return True 
    
</t>
<t tx="ekr.20070127142814.1383">def stringInsertRectangle( self ):
    
    if self.mode == None:
        self.mode = 1
        self.emacs.setCommandText( "string-insert-rectangle" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return False
        
        
    self.mode = None
    string_txt = self.emacs.minibuffer.getText()
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return True
    if start &gt; -1:
        
        txt = editor.getText()
        
        pos, pos2, rl_start, rl_end = self.definePoints( start, end )
        txt = txt[ rl_start: end ]
        txtline = txt.split( '\n' )

        ntxtlines = [  ]
        for z in txtline[ : ]:
            if( len( z ) - 1 ) &lt; pos:
                ntxtlines.append( z )
            else:
                nwline = '%s%s%s' % ( z[ :pos ], string_txt , z[ pos : ] )
                ntxtlines.append( nwline )
        
        if txt[ -1 ] == '\n': ntxtlines.append( '\n' )            
        ntxt = '\n'.join( ntxtlines ) 
        try:
            self.emacs.startCompounding( "String Insert Rectangle" ) 
            rv = self.insertText( rl_start, end, ntxt )
        finally:
            self.emacs.stopCompounding()
        return rv
        #sd = editor.getStyledDocument()
        #sd.remove( rl_start, end - rl_start )
        #sd.insertString( rl_start, ntxt, None )         
        #return True 
</t>
<t tx="ekr.20070127142814.1384">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple
    

</t>
<t tx="ekr.20070127142814.1385">def keyboardQuit( self ):
    self.mode = None</t>
<t tx="ekr.20070127142814.1386">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):

    
    header = '''--------
A Rectangle is defined by connecting 4 parallel points derived from
the begining of the selction and the end of the selction.
    
These commands operate on Rectangles:'''   
    sum = Information( "Rectangles", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'open-rectangle', 'inserts a whitespace equal to the rectangles width into each rectangle line.' ),
                ( 'clear-rectangle', 'wipes out character content within the rectangle and replaces it with whitespace.' ),
                ( 'delete-rectangle', 'removes characters within the rectangle.'),
                ( 'kill-rectangle', 'removes characters within the rectangle and stores the data in the kill rectangle'),
                ( 'yank-rectangle', 'inserts the data last stored by the kill-rectangle command' ),
                ( 'delete-whitespace-rectangle', 'removes whitespace from the begining of each line in the rectangle.'),
                ( 'string-rectangle', 'replaces each section of the rectangle with a user specified string.' ),
                ( 'string-insert-rectangle', 'inserts a user specified string into each section of the rectangle.' ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    
    
</t>
<t tx="ekr.20070127142814.1387">class zap( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.mode = None
        self.commands = {
         
            'zap-to-char': self.zap
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        if self.mode == None:
            
            self.mode = 1
            self.emacs._stateManager.setState( self )
            self.emacs.setCommandText( "Zap To Character:" )
            self.emacs.minibuffer.setText( "" )
            return True
            
        if command == 'Enter':
            c = self.emacs.minibuffer.getText()
            if len( c ) &gt; 1:
                self.emacs.keyboardQuit( event )
                self.emacs.setCommandText( "Text longer than one Character" )
                return True
            
            self.zap( c )
            return self.emacs.keyboardQuit( event )
        
        else:
            kc = event.getKeyChar()
            if java.lang.Character.isDefined( kc ):
                message = self.zap( kc )
                self.emacs.keyboardQuit( event )
                if message:
                    self.emacs.setCommandText( message )
                return True
            else:
                return True
            
            
    @others
    
</t>
<t tx="ekr.20070127142814.1388">def zap( self, c ):
    
    editor = self.emacs.editor
    doc = editor.getStyledDocument()
    pos = editor.getCaretPosition()
    txt = editor.getText( pos, ( doc.getLength() - 1 ) - pos  )
    ind = txt.find( c )
    if ind == -1:
        self.emacs.beep()
        return "Search Failed: '%s'" % c
    else:
        try:
            self.emacs.startCompounding( "Zap To %s" % c )
            doc.remove( pos, ind + 1 )
        finally:
            self.emacs.stopCompounding()</t>
<t tx="ekr.20070127142814.1389">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple 
    
</t>
<t tx="ekr.20070127142814.1390">def keyboardQuit( self ):
    self.mode = None</t>
<t tx="ekr.20070127142814.1391">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------
    Zapping queries for a character from the current caret position.  If it finds the character,
    all data between the caret and including that character is removed.'''    
    sum = Information( "Zapping", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
    
    
    self.info_structures = {}
    ztc = 'zaps to the specified character.'
    zti = Information( "zap-to-char" , ztc )
    self.info_structures[ "zap-to-char" ] = zti</t>
<t tx="ekr.20070127142814.1392">class comment( BaseCommand ):

    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands ={
        
            'comment-region': self.commentRegion,
            'comment-kill': self.commentKill,
                
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        
        message = self.commands[ command ]()
        if message:
            self.emacs.keyboardQuit( event )
            self.emacs.setCommandText( message )
            self.emacs.beep()
            return True
        else:
            return self.emacs.keyboardQuit( event )
            
        
    @others
    

</t>
<t tx="ekr.20070127142814.1393">def commentRegion( self ):
    
    language = self.emacs.determineLanguage()
    delim1,delim2, delim3 = g.set_delims_from_language( language )
    
    editor = self.emacs.editor
    sel = editor.getSelectedText()
    if sel == None: return
    
    lines = sel.splitlines( True )
    nwlines = []
    for z in lines:
        
        if z.find( delim1 ) != -1:
            nwline = z.replace( delim1, "" )
            nwlines.append( nwline )
        else:
            z2 = z.lstrip()
            ins = ( len( z ) - len( z2 ) )
            if ins == -1: ins = 0
            nwline = '%s%s%s' %( z[ : ins ], delim1, z[ ins: ] )
            nwlines.append( nwline )
        
    
    nwtext = ''.join( nwlines )
    try:
        self.emacs.startCompounding( "Comment Region" )
        editor.replaceSelection( nwtext )
    finally:
        self.emacs.stopCompounding()

</t>
<t tx="ekr.20070127142814.1394">def commentKill( self ):
    
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos == -1: return "Invalid Caret position"
    else:
        txt = editor.getText()
        i = txt.rfind( '\n', 0, pos )
        if i == -1: i = 0
        else: i += 1
        
        i2 = txt.find( '\n', pos )
        if i2 == -1: i2 = len( txt )
        
        line = txt[ i: i2 ]
        language = self.emacs.determineLanguage()
        delim1,delim2, delim3 = g.set_delims_from_language( language )
        
        where = line.find( delim1 )
        if where == -1: return "No comment found"
        
        else:
            nline = line[ :where ]
            
            sdoc = editor.getStyledDocument()
            try:
                self.emacs.startCompounding( "Comment Kill" )
                sdoc.replace( i, len( line ), nline, None )
            finally:
                self.emacs.stopCompounding()
            if ( pos - i ) &lt; where: editor.setCaretPosition( pos )
            return
        
            
    
</t>
<t tx="ekr.20070127142814.1395">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1396">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1397">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Comments", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    crc = 'comments the selected region with the comment character for the current language.  If a line within the region is commented, it will remove the comments instead of commenting.'
    cr = Information( "comment-region" , crc )
    self.info_structures[ "comment-region" ] = cr
    
    crc2 = "removes the comment on the current line" 
    cr2 = Information( "comment-kill", crc2 )
    self.info_structures[ "comment-kill" ] = cr2
    
    
</t>
<t tx="ekr.20070127142814.1398">class movement( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands = {
        
            'beginning-of-buffer': self.beginningOfBuffer,
            'end-of-buffer': self.endOfBuffer,
            'beginning-of-line': self.beginningOfLine,
            'end-of-line': self.endOfLine,
            'start-of-word': self.startOfWord,
            'end-of-word': self.endOfWord,
            'goto-line': self.goto,
            'goto-char': self.gotoChar,
            'move-to-indent-start': self.moveToIndentStart
            
        
        }
        self.defineInfoStructures()
        self.ctuple = tuple( self.commands.keys() )       
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)               
        self.mode = None

        
    def __call__( self, event, command ):
        
        if self.mode:
            
            if command == 'Enter':
                if self.mode == 1:
                    message = self.goto()
                else:
                    message = self.gotoChar()
                    
                if message:
                    self.emacs.keyboardQuit( event )
                    self.emacs.setCommandText( message )
                    self.emacs.beep()
                    return True
                else:
                    return self.emacs.keyboardQuit( event )
                
            else:
                return self.emacs.eventToMinibuffer( event )
        self.commands[ command ]()
        return True
        
    
    @others


</t>
<t tx="ekr.20070127142814.1399">def beginningOfBuffer( self ):

    editor = self.emacs.editor
    editor.setCaretPosition( 0 )
    

</t>
<t tx="ekr.20070127142814.1400">def endOfBuffer( self ):
    
    editor = self.emacs.editor
    sdoc = editor.getStyledDocument()
    editor.setCaretPosition( sdoc.getLength() -1 )
    

</t>
<t tx="ekr.20070127142814.1401">def beginningOfLine( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        txt = editor.getText()
        where = txt.rfind( '\n', 0, pos )
        if where == -1: where = 0
        else: where +=1
        #print stext.Utilities.getRowStart( editor, pos )
        #print where
        #spot = stext.Utilities.getRowStart( editor, pos )
        paragraph = stext.Utilities.getParagraphElement( editor, pos )
        spot = paragraph.getStartOffset()
        editor.setCaretPosition( spot )
        
        #editor.setCaretPosition( where )

</t>
<t tx="ekr.20070127142814.1402">def endOfLine( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        #txt = editor.getText()
        #where = txt.find( '\n', pos )
        #if where == -1: where = len( txt )
        #elif where != 0:
        #    where -= 1
        #print stext.Utilities.getRowEnd( editor, pos )
        #print where
        spot = stext.Utilities.getRowEnd( editor, pos )
        doc = editor.getDocument()
        txt = doc.getText( pos, spot - pos )
        ltxt = list( txt )
        ltxt.reverse()
        z = 0
        for z in xrange( len( ltxt ) ):
            if not ltxt[ z ].isspace(): break
            
        if z != len( ltxt ): spot -= z
        else: spot -= 1
        #if spot &lt; 0: return
        #paragraph = stext.Utilities.getParagraphElement( editor, pos )
        #spot = paragraph.getEndOffset()
        #if spot &gt; 0:
        #    spot = spot - 1
        #print spot
        #prvword = stext.Utilities.getPreviousWord( editor, spot )
        #text =
        #print prvword
        #espot = stext.Utilities.getNextWord( editor, prvword )
        editor.setCaretPosition( spot )
        
        #editor.setCaretPosition( where )
        
</t>
<t tx="ekr.20070127142814.1403">def goto( self ):
    
    if self.mode == None:
        self.mode = 1
        self.emacs._stateManager.setState( self )
        self.emacs.minibuffer.setText( "" )
        self.emacs.setCommandText( "Goto Line:" )
        return True
        
        
        
    line = self.emacs.minibuffer.getText()
    if not line.isdigit(): 
        return "Is Not a Number"
       
    line = int( line )
    editor = self.emacs.editor
    
    txt = editor.getText()
    txtlines = txt.splitlines( True )
    if len( txtlines ) &lt; line:
        editor.setCaretPosition( len( txt ) )
    else:
        txtlines = txtlines[ : line ]
        length =  len( ''.join( txtlines ) )
        editor.setCaretPosition( length - len( txtlines[ -1 ] ) )
    
    
</t>
<t tx="ekr.20070127142814.1404">def gotoChar( self ):
    
    if self.mode == None:
        self.mode = 2
        self.emacs._stateManager.setState( self )
        self.emacs.minibuffer.setText( "" )
        self.emacs.setCommandText( "Goto Char:" )
        return True
        
    line = self.emacs.minibuffer.getText()
    if not line.isdigit(): 
        return "Is Not a Number"
        
        
    number = int( line )
    editor = self.emacs.editor
    ltxt = len( editor.getText() )
    if ltxt &lt; number:
        editor.setCaretPosition( ltxt )
    else:
        editor.setCaretPosition( number )
        

    
</t>
<t tx="ekr.20070127142814.1405">def startOfWord( self):
    
    doc = self.emacs.editor.getDocument()
    cpos = self.emacs.editor.getCaretPosition()
    txt = doc.getText( 0, cpos )
    txt = list( txt)
    txt.reverse()
    if len( txt) == 0: return
    i = 0
    if not self.isWordCharacter( txt[ 0 ]):
        for z in txt:
            if not self.isWordCharacter( z ):
                i += 1
            else:
                break
    
    for z in txt[ i: ]:
        if not self.isWordCharacter( z ):
            break
        else:
            i += 1

    cpos -= i
    self.emacs.editor.setCaretPosition( cpos )
    
</t>
<t tx="ekr.20070127142814.1406">def endOfWord( self ):
    
    doc = self.emacs.editor.getDocument()
    cpos = self.emacs.editor.getCaretPosition()
    txt = doc.getText( cpos, doc.getLength() - cpos )
    txt = list( txt)
    #txt.reverse()
    if len( txt) == 0: return
    i = 0
    if not self.isWordCharacter( txt[ 0 ]):
        for z in txt:
            if not self.isWordCharacter( z ):
                i += 1
            else:
                break
    
    for z in txt[ i: ]:
        if not self.isWordCharacter( z ):
            break
        else:
            i += 1

    cpos += i
    self.emacs.editor.setCaretPosition( cpos )
   </t>
<t tx="ekr.20070127142814.1407">def moveToIndentStart( self ):

    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        #txt = editor.getText()
        start = stext.Utilities.getRowStart( editor, pos )
        end = stext.Utilities.getRowEnd( editor, pos )
        doc = editor.getDocument()
        txt = doc.getText( start, end - start )
        add = 0
        for z in txt:
            if not z.isspace():
                break
            else:
                add +=1
                        
        editor.setCaretPosition( start + add )    
</t>
<t tx="ekr.20070127142814.1408">def isWordCharacter( self, c ):
    
    if c in string.ascii_letters:
        return True
    elif c in string.digits:
        return True
    elif c in ( "_"):
        return True
    return False</t>
<t tx="ekr.20070127142814.1409">def getAltXCommands( self ):    
    return self.ctuple
    
def getKeystrokes( self ):
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1410">def keyboardQuit( self ):
    
    self.mode = None</t>
<t tx="ekr.20070127142814.1411">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Movement", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    crc = 'moves the caret to the line specified by the user.'
    cr = Information( "goto-line" , crc )
    self.info_structures[ "goto-line" ] = cr
    
    crc2 = "moves the caret to the character specified by the user."
    cr2 = Information( "goto-char", crc2 )
    self.info_structures[ "goto-char" ] = cr2
    
    crc3 = "moves the caret to the beginning of the buffer"
    cr3 = Information( "beginning-of-buffer", crc3)
    self.info_structures[ "beginning-of-buffer" ] = cr3
    
    crc4 = "moves the caret to the end of the buffer"
    cr4 = Information( "end-of-buffer", crc4)
    self.info_structures["end-of-buffer"] = cr4
    
    crc5  = "moves the caret to the start of the line"
    cr5 = Information("beginning-of-line", crc5)
    self.info_structures["beginning-of-line"] = cr5
    
    crc6 = "moves the caret to the end of the line"
    cr6 = Information("end-of-line", crc6)
    self.info_structures["end-of-line"] = cr6
    
    crc7 = "moves the caret to the start of the word"
    cr7 = Information("start-of-word", crc7)
    self.info_structures["start-of-word"] = cr7
    
    crc8 = "moves the caret to the end of the word"
    cr8 = Information("end-of-word",crc8)
    self.info_structures["end-of-word"] = cr8
    
    crc9 = "moves the caret to the start of indentation"
    cr9 = Information("move-to-indent-start",crc9)
    self.info_structures["move-to-indent-start"] = cr9
    

</t>
<t tx="ekr.20070127142814.1412">class balanced_parentheses( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.sexps = {
        
            '(': ')',
            ')':'(',
            '[':']',
            ']':'[',
            '&lt;':'&gt;',
            '&gt;':'&lt;',
            '{':'}',
            '}':'{',
        
        
        
        }
        
        self.forwards = ( "(", "&lt;", "{", "[" )
        self.backwards = ( ")", "&gt;", "}", "]" )
        self.commands = {
            "forward-sexp" : self.forwardSexp,
            "backward-sexp": self.backwardSexp,
            "kill-sexp": self.killSexpForward,
            "backward-kill-sexp": self.killSexpBackward
        
        
        }
        self.defineInfoStructures()
        self.ctuple = tuple( self.commands.keys() )       
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)         
        
    def __call__( self, event , command ):
        
        self.commands[ command ]()
        return True
        
        
    
    def forwardSexp( self ):
        
        editor = self.emacs.editor
        doc = editor.getDocument()
        cp = editor.getCaretPosition()
        if cp + 1 == doc.getLength(): return
        txt = doc.getText( cp, doc.getLength() - cp )
        sp = txt[ 0 ]
        if sp not in self.forwards or len( txt ) == 1: return
        matcher = self.sexps[ sp ]
        i = 1
        i2 = 0
        for z in txt[ 1: ]:
            i2 += 1
            if z == sp:
                i += 1
                continue
            elif z == matcher:
                i -= 1
            if i == 0: break
        if i == 0:
            editor.setCaretPosition( cp + i2 )
    
    def backwardSexp( self ):
        
        editor = self.emacs.editor
        doc = editor.getDocument()
        cp = editor.getCaretPosition()
        txt = doc.getText( 0, cp + 1 )
        sexp = txt[ -1 ]
        if sexp not in self.backwards or len( txt ) == 1: return
        matcher = self.sexps[ sexp ]
        i = 1
        i2 = 0
        t2 = list( txt )
        t2.reverse()
        for z in t2[ 1: ]:
            i2 += 1
            if z == sexp:
                i += 1
                continue
            elif z == matcher:
                i -= 1
            if i == 0:
                break
        
        if i == 0:
            editor.setCaretPosition( cp - i2 )
 
    @others</t>
<t tx="ekr.20070127142814.1413">def killSexpForward( self ):
    
    editor = self.emacs.editor
    doc = editor.getDocument()
    cp = editor.getCaretPosition()
    self.forwardSexp()
    cp2 = editor.getCaretPosition()
    if cp != cp2:
        txt = doc.getText( cp, ( cp2 - cp ) + 1 )
        self.emacs.addToKillbuffer( txt )
        try:
            self.emacs.startCompounding( "Kill Sexp Forwards" )
            doc.remove( cp, ( cp2 - cp ) + 1)
        finally:
            self.emacs.stopCompounding()
        
def killSexpBackward( self ):
    
    editor = self.emacs.editor
    doc = editor.getDocument()
    cp = editor.getCaretPosition()
    self.backwardSexp()
    cp2 = editor.getCaretPosition()
    if cp != cp2:
        txt = doc.getText( cp2, ( cp - cp2 ) + 1)
        self.emacs.addToKillbuffer( txt )
        try:
            self.emacs.startCompounding( "Kill Sexp Backwards" )
            doc.remove( cp2, ( cp - cp2 ) + 1)
        finally:
            self.emacs.stopCompounding()
</t>
<t tx="ekr.20070127142814.1414">def getAltXCommands( self ):    
    return self.ctuple 
    
def getKeystrokes( self ):
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1415">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1416">def getInformationAbout( self, name ): 
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Capitalization", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ("forward-sexp", "Move forward over a balanced expression"),
               ("backward-sexp", "Move backward over a balanced expression"),
               ("kill-sexp", "Kill balanced expression forward"),
               ("backward-kill-sexp", "Kill balanced expression backward")
              ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
        </t>
<t tx="ekr.20070127142814.1417">class tags( java.lang.Runnable, BaseCommand ):
    
    #tags_table = {}
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        #self.emacs.c.frame.tree.jtree.addTreeSelectionListener( self )
        self.last_tag = None
        self.pop_back = []
        self.positions = []
        self.tag_table = {}
        self.last_command = None
        self.__defineLanguageRecognizers()
        self.__defineLanguageMatchers()
        self.xs = java.util.concurrent.Executors.newSingleThreadScheduledExecutor()
        import leoPlugins
        wm1 = WeakMethod( self, "valueChanged" )
        leoPlugins.registerHandler( "select1", wm1 )
        self.mode = None
        #emacs.modeStrategies.append( self )
        self.commands = {
        
            "find-tag": self.gotoTag,
            "find-alternative-tag": self.alternativeDefinition,
            "pop-tag-mark": self.popBack,
        
        
        }
        
        self.tab_completer = self.emacs.TabCompleter( [] )
        dc = DefCallable( self.defineTagsTable )
        g.app.gui.addStartupTask( dc )
        self.defineInfoStructures()
        self.ctuple = tuple( self.commands.keys() )       
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)  
    
    def __defineLanguageMatchers( self ):
        
        reg1 = java.util.regex.Pattern.compile( java.lang.String( "^\s*(def\s+\w+\s*)" ) )
        reg2 = java.util.regex.Pattern.compile( java.lang.String(  "^\s*(class\s+\w+\s*)" ) )
        self.python_matchers = ( reg1.matcher( java.lang.String( "" ) ), reg2.matcher( java.lang.String( "" ) ) )
        
    
    def __call__( self, event, command ):
        
        if self.mode:
            if command == 'Enter':
                self.gotoTag()
                return self.emacs.keyboardQuit( event )
            elif command == 'Tab':
            
                txt = self.emacs.minibuffer.getText()
                if self.last_command == None or not txt.startswith( self.last_command ):
                    txt = self.emacs.minibuffer.getText()                
                    fnd = self.tab_completer.lookFor( txt )
                    if fnd:
                        self.last_command = txt
                        self.emacs.minibuffer.setText( self.tab_completer.getNext() )
                else :
                    self.emacs.minibuffer.setText( self.tab_completer.getNext() )
                return True
            else:
                return self.emacs.eventToMinibuffer( event )   
        
        rv = self.commands[ command ]()
        self.tab_completer.reset()
        self.last_command = None
        if rv:
            self.emacs.keyboardQuit( event )
        return True
        
        
    @others
    




</t>
<t tx="ekr.20070127142814.1418">def __defineLanguageRecognizers( self ):
    
    sstring = java.lang.String( "" )
    pattern = regex.Pattern.compile( "(class|interface)\s*(\w+)" )
    self.java_class = pattern.matcher( sstring )
    pattern = regex.Pattern.compile( "((public|private|protected)\s+)?(final\s+)?(static\s+)?(new\s+){0}\w+\s*(\w+)\s*\\(" )
    self.java_method = pattern.matcher( sstring )</t>
<t tx="ekr.20070127142814.1419">def gotoTag( self ):
    
    if self.mode == None:
        self.emacs.setCommandText( "Goto tag:" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )    
        self.mode = 1
        return
        
    if self.mode == 1:
        
        tag = self.emacs.minibuffer.getText()
        if not tag:
            wsi = self.emacs.getWordStartIndex()
            wse = self.emacs.getWordEndIndex()
            tag = self.emacs.getTextSlice( wsi, wse )
        if tag in self.tag_table:
            td = self.tag_table[ tag ]
            self.last_tag = ( tag, td[ 0 ] )
            p = td[ 0 ][ -1 ]
            c = self.emacs.c
            cp = c.currentPosition()
            self.pop_back.append( cp.copy() )
            c.beginUpdate()
            c.selectPosition( p.copy() )
            c.endUpdate()
            dgl = self.DeferedGotoLine( self.emacs.c, p, td[ 0 ][ 0 ] )
            dc = DefCallable( dgl )
            ft = dc.wrappedAsFutureTask()
            java.awt.EventQueue.invokeLater( ft )
            #self.emacs.keyboardQuit( event )
            return True
        else:
            g.es( "Could not find definition for %s" % tag )
            #self.emacs.keyboardQuit( event)
            return True

</t>
<t tx="ekr.20070127142814.1420">def alternativeDefinition( self ):
    
    if self.last_tag:
        
        tag , td = self.last_tag
        tags = self.tag_table[ tag ]
        i = tags.index( td )
        if i + 1 == len( tags ):
            i = 0
        else:
            i += 1
        
        td = tags[ i ]
        self.last_tag = ( tag, td )
        p = td[ -1 ]
        c = self.emacs.c
        cp = c.currentPosition()
        self.pop_back.append( cp.copy() )
        c.beginUpdate()
        c.selectPosition( p.copy() )
        c.endUpdate()
        dgl = self.DeferedGotoLine( self.emacs.c, p, td[ 0 ] )
        dc = DefCallable( dgl )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )
        #self.emacs.keyboardQuit( event )
        return True


</t>
<t tx="ekr.20070127142814.1421">def popBack( self ):

    if self.pop_back:
        p = self.pop_back.pop()
        c = self.emacs.c
        c.beginUpdate()
        c.selectPosition( p )
        c.endUpdate()
    
   

</t>
<t tx="ekr.20070127142814.1422">def defineTagsTable( self ):

    c = self.emacs.c
    cp = c.rootPosition()
    for z in cp.allNodes_iter( copy = True ):
        tags = self.scanForTags( z )
        if tags:
            for x in tags:
                if self.tag_table.has_key( x[ 1 ] ):
                    self.tag_table[ x[ 1 ] ].append( x )
                else:                    
                    self.tag_table[ x[ 1 ] ] = []
                    self.tag_table[ x[ 1 ] ].append( x )
                    
    self.tab_completer.extend( self.tag_table.keys() ) 
    g.es( "tag table built" )
    self.xs.scheduleAtFixedRate( self, 30000, 30000, java.util.concurrent.TimeUnit.MILLISECONDS ) 
</t>
<t tx="ekr.20070127142814.1423">def scanForTags( self, p ):
    #print "SCANNING FOR TAGS!"
    #language = g.scanForAtLanguage( self.emacs.c, p )
    language = LeoUtilities.scanForLanguage( p )
    if language == None: language = 'python'
    if language == 'python':
        tags = []
        try:
            #reg1 = "^\s*(def\s+\w+\s*)"
            #reg2 = "^\s*(class\s+\w+\s*)"
            #regs = ( reg1, reg2 )
            tnt = p.v.t._bodyString
            matches = LeoUtilities.scanFor( self.python_matchers , tnt )
            #print matches
            for z in matches:
                tags.append( ( z[ 0 ], z[ 1 ], p ) )
            #bs = p.bodyString()
            #data = bs.split( '\n' )
            # tags = []
            #for z in data:
            #    txt = z.lstrip()
            #    txtpieces = txt.split()
            #    if len( txtpieces )&gt; 1 and txtpieces[ 0 ] in ( "class", "def" ):
            #        ntxt = txtpieces[ 1 ]
            #        i1 = ntxt.find( "(" )
            #        i2 = ntxt.find( ":" )
            #        if i1 != -1: 
            #            ntxt = ntxt[ : i1 ]
            #        elif i2 != -1:
            #            ntxt = ntxt[ : i2 ]
            #        
            #        tags.append( ( txt, ntxt, p ) )
        except Exception, x:
            print x
        except java.lang.Exception, r:
            print r            
             
        return tags
    elif language == 'java':
        &lt;&lt;java&gt;&gt;
    else:
        return None

</t>
<t tx="ekr.20070127142814.1424">bs = p.bodyString()
data = bs.split( '\n' )
tags = []
for z in data:
    #regex looking for methods
    #regular scan for looking for class and interface
    #class interface takes precedence over methods
    try:
        stxt = z.lstrip()
        txt = java.lang.String( stxt )
        self.java_class.reset( txt )
        self.java_method.reset( txt )
        start = end = -1
        if self.java_class.find():
            gc = self.java_class.groupCount()
            ntxt = self.java_class.group( gc )
        elif self.java_method.find():
            gc = self.java_method.groupCount()
            ntxt = self.java_method.group( gc )
        else:
            gc = 0
        
        if gc:
            tags.append( (stxt, ntxt, p ) ) 
    except Exception, x:
        print x


return tags</t>
<t tx="ekr.20070127142814.1425">def valueChanged( self, *args ):
    
    values = args[ 1 ]
    self.positions.append( values[ 'new_p' ].copy() )
</t>
<t tx="ekr.20070127142814.1426">def run( self ):
    
    cp = self.emacs.c.currentPosition().copy()
    if cp not in self.positions:
        self.positions.append( cp )
        
    for z in self.positions:
        tags = self.scanForTags( z )
        if tags:
            for x in tags:   
                if self.tag_table.has_key( x[ 1 ] ):
                    self.tag_table[ x[ 1 ] ].append( x ) 
                else:
                    self.tag_table[ x[ 1 ] ] = []
                    self.tag_table[ x[ 1 ] ].append( x )
                self.tab_completer.extend( x[ 1 ] )
                    
    self.positions = []

</t>
<t tx="ekr.20070127142814.1427">class DeferedGotoLine:
    
    def __init__( self, c, pos, tag ):
        self.c = c
        self.pos = pos
        self.tag = tag
        
    def __call__( self ):
        
        bs = self.pos.bodyString()
        where = bs.find( self.tag )
        if where != -1:
            self.c.frame.body.editor.editor.setCaretPosition( where )
            
        
</t>
<t tx="ekr.20070127142814.1428">def getAltXCommands( self ):    
    return self.ctuple 
    
def getKeystrokes( self ):
    return self.kstuple
    
def getCtrlUCommands( self ):
    return ( 'Alt Period', )
    
    

</t>
<t tx="ekr.20070127142814.1429">def keyboardQuit( self ):
    
    self.mode = None</t>
<t tx="ekr.20070127142814.1430">def getInformationAbout( self, name ): 
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = 'Tags are locations within the outline where definitions of methods are located.\n'    
    sum = Information( "Tags", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ("find-tag", "find first definition of tag"),
               ("find-alternative-tag", "find next alternate definition of last tag specified"),
               ("pop-tag-mark", "pop back to where you previously invoked M-. and friends")
              ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
        
        
</t>
<t tx="ekr.20070127142814.1431">class transpose( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands = {
        
            'transpose-lines': self.transposeLines,
            'reverse-region': self.reverseRegion,
            'transpose-words': self.transposeWords,
        
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
    
        if not self.commands[ command ]():
            return self.emacs.keyboardQuit( event )  
        return True
        
        
    @others
    

</t>
<t tx="ekr.20070127142814.1432">def transposeLines( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        txt = editor.getText()
        start = txt.rfind( '\n', 0, pos )
        if start == -1: start = 0
        else:
            if start != 0:
                start = txt.rfind( '\n', 0, start )
                if start == -1: start = 0
                else: 
                    start += 1
        
        end = txt.find( '\n', pos )
        if end == -1: end = len( txt )
           
    
        lines = txt[ start: end ]
        lines_split = lines.split( '\n' )
        if not len( lines_split ) == 2: return
        l1, l2 = lines_split[ 0 ], lines_split[ 1 ]
        
        nwlines = '%s\n%s' %( l2, l1 )
        sdoc = editor.getStyledDocument()
        try:
            self.emacs.startCompounding( "Transpose Lines" )
            sdoc.replace( start, len( lines ), nwlines, None )
        finally:
            self.emacs.stopCompounding()
        
        
        
        
</t>
<t tx="ekr.20070127142814.1433">def reverseRegion( self ):
    
    editor = self.emacs.editor
    txt = editor.getSelectedText()
    if txt == None: return
    txtlines = txt.splitlines( True )
    txtlines.reverse()
    if not txt.endswith( '\n' ):
        txtlines[ 0 ] = '%s\n' % txtlines[ 0 ]
    ntxt = ''.join( txtlines )
    try:
        self.emacs.startCompounding( "Reverse Region" )
        editor.replaceSelection( ntxt )
    finally:
        self.emacs.stopCompounding()
</t>
<t tx="ekr.20070127142814.1434">def transposeWords( self ):
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    if pos != -1:
        
        ranges = self.emacs.getAttributeRanges( "trans-word" )
        if ranges:
            start = self.emacs.getWordStartIndex()
            end = self.emacs.getWordEndIndex()
            doc = editor.getDocument()
            w1 = doc.getText( start, end - start )
            w2 = doc.getText( ranges[ 0 ], ranges[ -1 ] - ranges[ 0 ] )
            doc.replace( ranges[ 0 ], ranges[ -1 ] - ranges[ 0 ], w1, None )
            start = self.emacs.getWordStartIndex()
            end = self.emacs.getWordEndIndex()
            try:
                self.emacs.startCompounding( "Transpose Words" )
                doc.replace( start, end - start, w2, None )
            finally:
                self.emacs.stopCompounding()
            self.emacs.clearAttribute( "trans-word" )
            return
        
        else:
            start = self.emacs.getWordStartIndex()
            end = self.emacs.getWordEndIndex()
            self.emacs.addAttributeToRange( 'trans-word', "trans-word" , start, end-start, color = java.awt.Color.YELLOW )

        return True
</t>
<t tx="ekr.20070127142814.1435">def getAltXCommands( self ):
    return self.ctuple   
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1436">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1437">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Transposition", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
    
    self.info_structures = {}
    crc = 'swaps the current line with the line above it.'
    cr = Information( "transpose-lines" , crc )
    self.info_structures[ "transpose-lines" ] = cr
    
    crc2 = "takes region and reverses the ordering of the lines, last becomes first, first last."
    cr2 = Information( "reverse-region", crc2 )
    self.info_structures[ "reverse-region" ] = cr2
    
    crc3 = "takes two words and transposes them."
    cr3 = Information("transpose-words", crc3)
    self.info_structures["transpose-words"] = cr3

    
    
</t>
<t tx="ekr.20070127142814.1438">class capitalization( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands ={
        
            'capitalize-region': self.capitalizeRegion,
            'upcase-region': self.upcaseRegion,
            'downcase-region': self.downcaseRegion,
            'capitalize-word': self.capitalizeWord,
            'downcase-word': self.downcaseWord,
            'upcase-word': self.upcaseWord,
        
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        message = self.commands[ command ]()
        if message:
            self.emacs.keyboardQuit( event )
            self.emacs.setCommandText( message )
            self.emacs.beep()
            return True
            
        return self.emacs.keyboardQuit( event )
        

    @others</t>
<t tx="ekr.20070127142814.1439">def capitalizeRegion( self ):

    editor = self.emacs.editor
    stext = editor.getSelectedText()
    if stext == None:
        return "Region not selected"
        
    ntext = []
    lc = ' '
    for z in stext:
        if lc.isspace():
            z2 = z.capitalize()
            ntext.append( z2 )
        else:
            ntext.append( z )
        lc = z
        
    ntext = ''.join( ntext )
    try:
        self.emacs.startCompounding( "Capitalize Region" )
        editor.replaceSelection( ntext )
    finally:
        self.emacs.stopCompounding()
</t>
<t tx="ekr.20070127142814.1440">def upcaseRegion( self ):
    
    editor = self.emacs.editor
    stext = editor.getSelectedText()
    if stext == None:
        return "Region not selected"
        
    ntext = stext.upper()
    try:
        self.emacs.startCompounding( "Upcase Region" )
        editor.replaceSelection( ntext )
    finally:
        self.emacs.stopCompounding()
    

</t>
<t tx="ekr.20070127142814.1441">def downcaseRegion( self ):

    editor = self.emacs.editor
    stext = editor.getSelectedText()
    if stext == None:
        return "Region not selected"
        
    ntext = stext.lower()
    try:
        self.emacs.startCompounding( "Downcase Region" )
        editor.replaceSelection( ntext )
    finally:
        self.emacs.stopCompounding()
</t>
<t tx="ekr.20070127142814.1442">def capitalizeWord( self ):
    
    start, end = self.emacs.getWordStartIndex(), self.emacs.getWordEndIndex()
    
    if start != -1:
        
        sdoc = self.emacs.editor.getStyledDocument()
        txt = sdoc.getText( start, end - start )
        txt = txt.capitalize()
        pos = self.emacs.editor.getCaretPosition()
        try:
            self.emacs.startCompounding( "Capitalize Word" )
            sdoc.replace( start, len( txt ), txt, None )  
        finally:
            self.emacs.stopCompounding()
        self.emacs.editor.setCaretPosition( pos )

        </t>
<t tx="ekr.20070127142814.1443">def upcaseWord( self ):
    
    start, end = self.emacs.getWordStartIndex(), self.emacs.getWordEndIndex()
    
    if start != -1:
        
        sdoc = self.emacs.editor.getStyledDocument()
        txt = sdoc.getText( start, end - start )
        txt = txt.upper()
        pos = self.emacs.editor.getCaretPosition()
        try:
            self.emacs.startCompounding( "Upcase Word" )
            sdoc.replace( start, len( txt ), txt, None )
        finally:
            self.emacs.stopCompounding()
        self.emacs.editor.setCaretPosition( pos )
    
</t>
<t tx="ekr.20070127142814.1444">def downcaseWord( self ):

    start, end = self.emacs.getWordStartIndex(), self.emacs.getWordEndIndex()
    
    if start != -1:
        
        sdoc = self.emacs.editor.getStyledDocument()
        txt = sdoc.getText( start, end - start )
        txt = txt.lower()
        pos = self.emacs.editor.getCaretPosition()
        try:
            self.emacs.startCompounding( "Downcase Word" )
            sdoc.replace( start, len( txt ), txt, None )
        finally:
            self.emacs.stopCompounding()
        self.emacs.editor.setCaretPosition( pos )
    
</t>
<t tx="ekr.20070127142814.1445">def getAltXCommands( self ):
    return self.ctuple  
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1446">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1447">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Capitalization", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'upcase-region' ,'Upper cases all the text in the selection.' ),
                ( 'downcase-region', 'Lower cases all the text in the selection.' ),
                ( 'capitalize-region', 'Capitalizes all the text in the selection.' ),
                ( 'upcase-word', 'Upper cases the current word.' ),
                ( 'downcase-word', 'Lower cases the current word.' ),
                ('capitalize-word', 'Capitalizes the current word.' ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    

    
    
</t>
<t tx="ekr.20070127142814.1448">class replacement( BaseCommand ):
    import java.util.regex as regex
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands = {
        
            'query-replace': self.queryReplace,
            'query-replace-regexp': self.queryReplaceRegexp,
            'replace-string': self.replaceString,
            
        
        }
        self.mode = None
        self.submode = None
        
        self.search = None
        self.replacement = None
        self.compoundname = None
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
        
    def __call__( self, event, command ):
        
        if self.mode:
            if self.mode in( 1, 2 ):
                qcommand = g.choose( self.mode == 1, self.queryReplace, self.queryReplaceRegexp )
                if self.submode in( 1, 2 ):
                    if command == 'Enter':
                        return qcommand()
                    else:
                        return self.emacs.eventToMinibuffer( event )   
                if self.submode == 3:
                    message = self.doReplacement( event )
                    if message == None:
                        message = qcommand()
                    if message not in( True, False ) and message:
                        self.emacs.keyboardQuit( event )
                        self.emacs.minibuffer.setText( "" )
                        self.emacs.setCommandText( message )
                        return True
                    return True
            elif self.mode == 3:
                if command == 'Enter':
                    message = self.replaceString()
                    if message not in ( True, False ) and message:
                        self.emacs.keyboardQuit( event )
                        self.emacs.minibuffer.setText( "" )
                        self.emacs.setCommandText( message )
                        return True
                    else: return True
                else:
                    return self.emacs.eventToMinibuffer( event )
        
        return self.commands[ command ]()
        
        
    @others
    




</t>
<t tx="ekr.20070127142814.1449">def queryReplace( self ):
    self.compoundname = "Query Replace"
    if self.mode == None:
        self.mode = 1
        self.submode = 1
        self.emacs.setCommandText( "Query For:" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return True
    
    if self.submode == 1:
        
        self.search = self.emacs.minibuffer.getText()
        self.emacs.minibuffer.setText( "" )
        self.emacs.setCommandText( "Replace With:" )
        self.submode = 2
        return True
        
    if self.submode == 2:
        
        self.replacement = self.emacs.minibuffer.getText()
        self.emacs.minibuffer.setText( "" )
        self.submode = 3
        
        
    if self.submode == 3:
        
        editor = self.emacs.editor
        pos = editor.getCaretPosition()
        txt = editor.getText()
        where = txt.find( self.search, pos )
        if where == -1:
            editor.setCaretPosition( editor.getSelectionEnd() )
            return "No more matches found"
        else:
            editor.setSelectionStart( where )
            editor.setSelectionEnd( where + len( self.search ) )
            self.emacs.setCommandText( "Replace %s with %s ? y/n(! replaces all)" %( self.search, self.replacement ) )
            return True
            
        

</t>
<t tx="ekr.20070127142814.1450">def queryReplaceRegexp( self ):
    self.compoundname = "Query Replace Regexp"
    if self.mode == None:
        self.mode = 2
        self.submode = 1
        self.emacs.setCommandText( "Query For:" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return True
    
    if self.submode == 1:
        
        search = self.emacs.minibuffer.getText()
        import java.util.regex
        self.search = java.util.regex.Pattern.compile( search )
        self.emacs.minibuffer.setText( "" )
        self.emacs.setCommandText( "Replace With:" )
        self.submode = 2
        return True
        
    if self.submode == 2:
        
        self.replacement = self.emacs.minibuffer.getText()
        self.emacs.minibuffer.setText( "" )
        self.submode = 3
        
        
    if self.submode == 3:
        
        editor = self.emacs.editor
        pos = editor.getCaretPosition()
        txt = editor.getText()
        
        import java.lang.String
        match = self.search.matcher( java.lang.String( txt[ pos: ] ) )
        found = match.find()
        if found:
            start = match.start()
            end = match.end()
        else:
            start = end = -1
        if start == -1:
            editor.setCaretPosition( editor.getSelectionEnd() )
            return "No more matches found"
        else:
            editor.setSelectionStart( pos + start )
            editor.setSelectionEnd( pos + end )
            self.emacs.setCommandText( "Replace %s with %s ? y/n(! replaces all)" %( editor.getSelectedText(), self.replacement ) )
            return True
    
</t>
<t tx="ekr.20070127142814.1451">def replaceString( self ):

    if self.mode == None:
        self.mode = 3
        self.submode = 1
        self.emacs.setCommandText( "Replace String:" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return True
    
    if self.submode == 1:
        
        self.search = self.emacs.minibuffer.getText()
        self.emacs.minibuffer.setText( "" )
        self.emacs.setCommandText( "Replace %s With:" % self.search )
        self.submode = 2
        return True    
        
    if self.submode == 2:
        
        replacement = self.emacs.minibuffer.getText()
        editor = self.emacs.editor
        pos = editor.getCaretPosition()
        txt = editor.getText()[ pos: ]
        amount = txt.count( self.search )
        ntxt = txt.replace( self.search, replacement )
        sd = editor.getStyledDocument()
        try:
            self.emacs.startCompounding( "Replace String" )
            sd.replace( pos, len( txt ), ntxt, None )
        finally:
            self.emacs.stopCompounding()
        editor.setCaretPosition( pos )
        return "%s occurances of %s replaced with %s" %( amount, self.search, replacement )
        
    

</t>
<t tx="ekr.20070127142814.1452">def doReplacement( self, event ):
    
    
    kc = event.getKeyChar()
    
    if not java.lang.Character.isDefined( kc ): return False
    elif kc == 'y':
        try:
            self.emacs.startCompounding( self.compoundname )
            self.emacs.editor.replaceSelection( self.replacement )
        finally:
            self.emacs.stopCompounding()
    elif kc =='!':
        return self.replaceAll()
        
    else:
        pass</t>
<t tx="ekr.20070127142814.1453">def replaceAll( self ):
    
    editor = self.emacs.editor
    spos = editor.getSelectionStart()
    editor.setCaretPosition( spos )
    cp = editor.getCaretPosition()
    txt = editor.getText()[ cp : ]
    sd = editor.getStyledDocument()
    
    if self.mode == 1:
        amount = txt.count( self.search )
        ntxt = txt.replace( self.search, self.replacement )
        try:
            self.emacs.startCompounding( self.compoundname )
            sd.replace( cp, len( txt ), ntxt, None )
        finally:
            self.emacs.stopCompounding()
        editor.setCaretPosition( spos )
        return '%s instances of %s replaced with %s' %( amount, self.search, self.replacement )
    else:
        import java.lang.String
        txt_s = java.lang.String( txt )
        scount = txt.count( self.replacement )
        #natxt = self.search.split( txt_s )
        #print "natxt len is %s" % len( natxt )
        matcher = self.search.matcher( txt_s )
        ntxt = matcher.replaceAll( self.replacement )
        ncount = ntxt.count( self.replacement )
        #ntxt = self.replacement.join( natxt )
        try:
            self.emacs.startCompounding( self.compoundname )
            sd.replace( cp, len( txt ), ntxt, None )
        finally:
            self.emacs.stopCompounding()
        editor.setCaretPosition( spos )
        return '%s instances of %s replaced with %s' %( ncount - scount, self.search.pattern(), self.replacement )
        
        
        
</t>
<t tx="ekr.20070127142814.1454">def getAltXCommands( self ):
    return self.ctuple 
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1455">def keyboardQuit( self ):
    
    self.mode = None</t>
<t tx="ekr.20070127142814.1456">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '''--------
SwingMacs has several different query and replace commands.  Each asks the user
for a search string/pattern and text to replace matches with.  Each has different
levels of interactivity.'''       
    sum = Information( "Querying and Replacing", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
    

    self.info_structures = {}
    for z in ( ( 'query-replace' , 'asks the user for a string to match and a string to replace.  Is asked for each individual word if replacement is desired. "!" replaces all.' ),
                ( 'query-replace-regexp', 'asks the user for a regular expression to match and a string to replace.  Is asked for each individual word if replacement is desired. "!" replaces all.  The regular expressions are executed from the java.util.regex package, see details in javadoc.'),
                ( 'replace-string', 'asks user for a string to match and a replacement string.  Upon execution all matches are replaced.' ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    

    
    
</t>
<t tx="ekr.20070127142814.1457">class sorters( BaseCommand ):
    
    def __init__( self, emacs ):
        self.emacs = emacs
        self.commands ={
        
            'sort-lines': self.sortLines
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
    def __call__( self, event, command ):
        
        self.commands[ command ]()
        return self.emacs.keyboardQuit( event )
        
    @others
    
</t>
<t tx="ekr.20070127142814.1458">def sortLines( self ):
    
    editor = self.emacs.editor
    txt = editor.getSelectedText()
    if txt == None: return
    txtlines = txt.splitlines()
    txtlines.sort()
    ntxt = '\n'.join( txtlines )
    if txt[ -1 ] == '\n': ntxt = '%s\n' % ntxt
    try:
        self.emacs.startCompounding( "Sort Lines" )
        editor.replaceSelection( ntxt )
    finally:
        self.emacs.stopCompounding()

</t>
<t tx="ekr.20070127142814.1459">def getAltXCommands( self ):
    return self.ctuple 
    
    
def getKeystrokes( self ):   
    return self.kstuple
</t>
<t tx="ekr.20070127142814.1460">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1461">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Sorting", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    cr = Information( "sort-lines" , 'sorts the selected lines of text.' )
    self.info_structures[ "sort-lines" ] = cr
    
    
    
</t>
<t tx="ekr.20070127142814.1462">class lines( BaseCommand ):
    import java.util.regex as regexp
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.mode = None
        self.commands= {
        
            'keep-lines': self.keepLines,
            'flush-lines': self.flushLines,
        
        
        }
        self.defineInfoStructures()
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
        
    def __call__( self, event, command ):
        
        if self.mode:
            if self.mode in ( 1, 2 ):
                if command == 'Enter':
                    if self.mode == 1:
                        self.keepLines()
                    else:
                        self.flushLines()
                    self.emacs.keyboardQuit( event )
                    return True
                else:
                    return self.emacs.eventToMinibuffer( event )
            
        
        return self.commands[ command ]()
        
        
    @others
    


</t>
<t tx="ekr.20070127142814.1463">def keepLines( self ):
    import java.util.regex as regexp
    if self.mode == None:
        self.mode = 1
        self.emacs.setCommandText( "Keep lines( containing match for regexp ):" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return True
    
    

    pattern = self.emacs.minibuffer.getText()
    regex = regexp.Pattern.compile( java.lang.String( pattern ) )
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    txt = editor.getText()
    start = txt.rfind( '\n', 0, pos )
    if start == -1: start = 0
    else: start += 1
    
    
    ntxt = txt[ start: ]
    ntxt_lines = ntxt.splitlines( True )

    matcher = regex.matcher( java.lang.String( ntxt_lines[ 0 ] ) )
    keepers = []
    for z in ntxt_lines:
        matcher.reset( java.lang.String( z ) )
        found = matcher.find()
        if found: keepers.append( z )
        
        
    keeptxt = ''.join( keepers )
    
    sdoc = editor.getStyledDocument()
    try:
        self.emacs.startCompounding( "Keep Lines" )
        sdoc.replace( start, len( ntxt ), keeptxt, None )
    finally:
        self.emacs.stopCompounding()
    if ( sdoc.getLength() - 1 ) &gt;= pos:
        editor.setCaretPosition( pos )
    
        
        


</t>
<t tx="ekr.20070127142814.1464">def flushLines( self ):

    import java.util.regex as regexp
    if self.mode == None:
        self.mode = 2
        self.emacs.setCommandText( "Flush lines( containing match for regexp ):" )
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        return True
    
    

    pattern = self.emacs.minibuffer.getText()
    regex = regexp.Pattern.compile( java.lang.String( pattern ) )
    
    editor = self.emacs.editor
    pos = editor.getCaretPosition()
    txt = editor.getText()
    start = txt.rfind( '\n', 0, pos )
    if start == -1: start = 0
    else: start += 1
    
    
    ntxt = txt[ start: ]
    ntxt_lines = ntxt.splitlines( True )

    matcher = regex.matcher( java.lang.String( ntxt_lines[ 0 ] ) )
    keepers = []
    for z in ntxt_lines:
        matcher.reset( java.lang.String( z ) )
        found = matcher.find()
        if found: continue
        keepers.append( z )
        
        
    keeptxt = ''.join( keepers )
    
    sdoc = editor.getStyledDocument()
    try:
        self.emacs.startCompounding( "Flush Lines" )
        sdoc.replace( start, len( ntxt ), keeptxt, None )
    finally:
        self.emacs.stopCompounding()
    if ( sdoc.getLength() - 1 ) &gt;= pos:
        editor.setCaretPosition( pos )
    
</t>
<t tx="ekr.20070127142814.1465">def getAltXCommands( self ):
    return self.ctuple 
    
    
def getKeystrokes( self ):   
    return self.kstuple 
    
</t>
<t tx="ekr.20070127142814.1466">def keyboardQuit( self ):
    self.mode = None</t>
<t tx="ekr.20070127142814.1467">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):
    
    header = '--------\n'    
    sum = Information( "Lines", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'flush-lines', 'removes lines that match a regular expression. The regular expressions are executed from the java.util.regex package, see details in javadoc.' ),
               ( 'keep-lines', 'keeps lines that match a regular expression.  Same regular expression details as flush-lines.' ) ):
        
        cr = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = cr
    
    
    
</t>
<t tx="ekr.20070127142814.1468">class tabs( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.commands ={
        
            'tabify': self.tabify,
            'untabify': self.untabify,
        
        
        
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands) 
        
    def __call__( self, event, command ):
        
        
        rval = self.commands[ command ]()
        self.emacs.keyboardQuit( event )
        return rval
        
    @others
    
</t>
<t tx="ekr.20070127142814.1469">def tabify( self ):

    #tw = self.emacs.getTabWidth()
    editor = self.emacs.editor
    txt = editor.getSelectedText()
    if txt == None: return True
    
    #space_replace = ' ' * tw
    ntxt = txt.replace( ' ', '\t' )
    pos = editor.getCaretPosition()
    try:
        self.emacs.startCompounding( "Tabify" )
        editor.replaceSelection( ntxt )
    finally:
        self.emacs.stopCompounding()
    editor.setCaretPosition( pos )
    return True
    
    


</t>
<t tx="ekr.20070127142814.1470">def untabify( self ):
    
    #tw = self.emacs.getTabWidth()
    editor = self.emacs.editor
    txt = editor.getSelectedText()
    if txt == None: return True
    
    #space_replace = ' ' * tw
    ntxt = txt.replace( '\t', ' ' )
    pos = editor.getCaretPosition()
    try:
        self.emacs.startCompounding( "Untabify" )
        editor.replaceSelection( ntxt )
    finally:
        self.emacs.stopCompounding()
    editor.setCaretPosition( pos )
    return True
    
</t>
<t tx="ekr.20070127142814.1471">def getAltXCommands( self ):
    return self.ctuple 
    
    
def getKeystrokes( self ):   
    return self.kstuple 
    
</t>
<t tx="ekr.20070127142814.1472">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1473">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):

    
    header = '--------\n'    
    sum = Information( "Tabs", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'tabify', 'changes spaces in selected region into tabs.'),
               ( 'untabify', 'changes tabs in selected region into spaces.' ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    
    
</t>
<t tx="ekr.20070127142814.1474">class registers( BaseCommand ):
    
    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.mode = None
        self.submode = None
        #emacs.modeStrategies.append( self )
        self.registers = {}
        self.commands = {
        
            'copy-to-register': self.copyToRegister,
            'insert-register': self.insertRegister,
            'append-to-register': self.appendToRegister,
            'prepend-to-register': self.prependToRegister,
            
        
        }
        self.mode_command ={
        
            1: self.copyToRegister,
            3: self.appendToRegister,
            4: self.prependToRegister,
        
        
        
        }
        self.defineInfoStructures()
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands) 
        
    def __call__( self, event, command ):

        if self.mode:
            if self.mode in ( 1, 3, 4 ):
                self.emacs.eventToMinibuffer( event )
                message =   self.mode_command[ self.mode ]()           #self.copyToRegister()
                if message not in ( True, False ) and message:
                    self.emacs.keyboardQuit( event )
                    self.emacs.setCommandText( message )
                    return True
                else:
                    return self.emacs.keyboardQuit( event )
            elif self.mode == 2:
                self.emacs.eventToMinibuffer( event )
                message = self.insertRegister()
                if message not in( True, False ) and message:
                    self.emacs.keyboardQuit( event )
                    self.emacs.setCommandText( message )
                    return True
                return self.emacs.keyboardQuit( event )
        
        return self.commands[ command ]()
        
    @others
    

</t>
<t tx="ekr.20070127142814.1475">def copyToRegister( self ):
 
    if self.mode == None:
        
        self.mode = 1
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        self.emacs.setCommandText( "Copy To Which Register( a-z )?" )
        return True
        
        
    register = self.emacs.minibuffer.getText()
    self.emacs.minibuffer.setText( "" )
    if not java.lang.Character.isLetter( register ):
        return 'Character is not a Letter'
        
    register = register.lower()
    txt = self.emacs.editor.getSelectedText()
    if txt == None:
        return 'Region not defined'
        
    self.registers[ register ] = txt
    self.emacs.editor.setCaretPosition( self.emacs.editor.getCaretPosition() )
    
        
    

</t>
<t tx="ekr.20070127142814.1476">def insertRegister( self ):
 
    if self.mode == None:
        
        self.mode = 2
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        self.emacs.setCommandText( "Insert From Which Register( a-z )?" )
        return True
        
        
    
    
    register = self.emacs.minibuffer.getText()
    if not java.lang.Character.isLetter( register ):
        return 'Character is not a Letter'
        
    register = register.lower()
    if not self.registers.has_key( register ):
        return 'Register %s empty' % register
        
    data = self.registers[ register ]
    sdoc = self.emacs.editor.getStyledDocument()
    sdoc.insertString( self.emacs.editor.getCaretPosition(), data, None )

        
    
    
</t>
<t tx="ekr.20070127142814.1477">def appendToRegister( self ):

    if self.mode == None:
        
        self.mode = 3
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        self.emacs.setCommandText( "Append To Which Register( a-z )?" )
        return True
        
        
    register = self.emacs.minibuffer.getText()
    self.emacs.minibuffer.setText( "" )
    if not java.lang.Character.isLetter( register ):
        return 'Character is not a Letter'
        
    register = register.lower()
    txt = self.emacs.editor.getSelectedText()
    if txt == None:
        return 'Region not defined'
        
    if self.registers.has_key( register ):
        data = self.registers[ register ]
        ndata = '%s%s' %( data, txt )
        self.registers[ register ] = ndata
    else:
        self.registers[ register ] = txt
        
    self.emacs.editor.setCaretPosition( self.emacs.editor.getCaretPosition() )
    
</t>
<t tx="ekr.20070127142814.1478">def prependToRegister( self ):

    if self.mode == None:
        
        self.mode = 4
        self.emacs.minibuffer.setText( "" )
        self.emacs._stateManager.setState( self )
        self.emacs.setCommandText( "Prepend To Which Register( a-z )?" )
        return True
        
        
    register = self.emacs.minibuffer.getText()
    self.emacs.minibuffer.setText( "" )
    if not java.lang.Character.isLetter( register ):
        return 'Character is not a Letter'
        
    register = register.lower()
    txt = self.emacs.editor.getSelectedText()
    if txt == None:
        return 'Region not defined'
        
    if self.registers.has_key( register ):
        data = self.registers[ register ]
        ndata = '%s%s' %( txt, data )
        self.registers[ register ] = ndata
    else:
        self.registers[ register ] = txt
        
    self.emacs.editor.setCaretPosition( self.emacs.editor.getCaretPosition() )
    
    

</t>
<t tx="ekr.20070127142814.1479">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ):   
    return self.kstuple 
</t>
<t tx="ekr.20070127142814.1480">def keyboardQuit( self ):
    self.mode = None</t>
<t tx="ekr.20070127142814.1481">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):

    
    header = '''--------
Registers are places, defined by the letters a-z, where the user can store data temporarily.  There are a variety of register commands:'''   
    sum = Information( "Registers", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( 'copy-to-register', 'copy the selected text to a register specified by the user.' ),
                ( 'append-to-register', 'copy the selected text to the end of a register.' ),
                ( 'prepend-to-register', 'copy the selected text to the beginning of a register.' ),
                ( 'insert-register', 'insert a register into the current buffer.' ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    
    
</t>
<t tx="ekr.20070127142814.1482">class selection( sevent.DocumentListener, BaseCommand ):

    def __init__( self, emacs ):
        
        self.emacs = emacs
        self.emacs.editor.getDocument().addDocumentListener( self )
        self.start = None
        self.commands = {
            "set-mark-command": self.startSelection      
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands) 
        
        
    def __call__( self, event, command ):
        
        
        if self.commands.has_key( command ):
            return self.commands[ command ]()
        elif self.emacs._stateManager2.hasState() == self:
            if not java.lang.Character.isWhitespace( event.getKeyChar() ) and command not in ("Backspace", "F" ):
                self.select()
            
        
    def startSelection( self ):
        
        self.start = self.emacs.editor.getCaretPosition()
        sstart = self.emacs.editor.getSelectionStart()
        send = self.emacs.editor.getSelectionEnd()
        foldprotection = self.emacs.c.frame.body.editor.foldprotection
        fold = foldprotection.getFold( self.start, self.start )
        if fold:
            foldprotection.removeFold( fold )
            return
        elif sstart != send:
            foldprotection.foldSelection()
            return self.emacs.keyboardQuit()
        self.emacs._stateManager2.setState( self )
        return True
    
    def executeSelection( self ):

        if self.start == -2: pass
        elif self.start != -1:
            editor = self.emacs.editor
            cp = editor.getCaretPosition()
            editor.setCaretPosition( self.start )
            editor.moveCaretPosition( cp )
        else:
            self.emacs.keyboardQuit()    
    
        
    def select( self ):
        dc = DefCallable( self.executeSelection )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )
        
    def changedUpdate( self, event ):
        pass
        
    def insertUpdate( self, event ):
        pass
        
    def removeUpdate( self, event ):
        
        if self.emacs.block_moving == -1:
            self.start = -1 
        else:
            self.start = self.emacs.block_moving
              
    
    @others
    

</t>
<t tx="ekr.20070127142814.1483">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ):   
    return self.kstuple
    
</t>
<t tx="ekr.20070127142814.1484">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1485">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    
def getKeyStrokeInfo( self ):
   
    sum = Information( "",  "" )
    for z in self.kstrokes_info: 
        item = self.kstrokes_info[ z ]
        info = Information( z, item.doc )
        sum.addInformation( info )
    
    return sum
    

def getSummaryInfo( self ):
    
    header = '''--------'''    
    sum = Information( "Marking", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):
       
    self.info_structures = {}
    for z in ( ( 'set-mark-command', 'sets the mark where the cursor is at, subsequent movement via keyboard selects text' ),):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info 

    </t>
<t tx="ekr.20070127142814.1486">class quoters( BaseCommand ):

    def __init__( self, emacs ):
        

        self.emacs = emacs
        self.commands = {
        
            "single-quote-selection": self.singleQuote,
            "double-quote-selection": self.doubleQuote,
            "tripled-quote-selection": self.tripledQuote,
            "triples-quote-selection": self.triplesQuote,
        
            
        }
        self.ctuple = tuple(self.commands.keys())
        self.defineInfoStructures()
        kstrokes = emacs.getKeyStrokesForCommands( self.commands.keys() )
        emacs.configureStrategyWithKeystrokes(self, kstrokes, self.commands)
        
        
    def __call__( self, event, command ):
        
        
        if self.commands.has_key( command ):
            return self.commands[ command ]()


    @others
</t>
<t tx="ekr.20070127142814.1487">def singleQuote( self ):
    return self.quote( "'" )
    
def doubleQuote( self ):
    return self.quote( '"' )
    
def tripledQuote( self ):
    return self.quote( '"""' )

def triplesQuote( self ):
    return self.quote( "'''" )


def quote( self, token ):
    
    editor = self.emacs.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end: return
    doc = editor.getDocument()
    txt = doc.getText( start, end - start )
    try:
        self.emacs.startCompounding( "Quote with %s" % token )
        editor.replaceSelection( "%s%s%s" %( token, txt, token ) )
    finally:
        self.emacs.stopCompounding()
    self.emacs.keyboardQuit()</t>
<t tx="ekr.20070127142814.1488">def getAltXCommands( self ):
    return self.ctuple
    
    
def getKeystrokes( self ):   
    return self.kstuple
</t>
<t tx="ekr.20070127142814.1489">def keyboardQuit( self ):
    pass</t>
<t tx="ekr.20070127142814.1490">def getInformationAbout( self, name ):
    
    if self.info_structures.has_key( name ):
        return self.info_structures[ name ]
    return None
    
    
def getInformation( self ):
    
    return copy.copy( self.info_structures )
    

def getSummaryInfo( self ):

    
    header = '--------\n'   
    sum = Information( "Quoters", header )
    for z in self.info_structures:
        item = self.info_structures[ z ]
        sum.addInformation( item )
    
    return sum

def defineInfoStructures( self ):

    self.info_structures = {}
    for z in ( ( "single-quote-selection" , "places single quotes around the selection." ),
               ( "double-quote-selection", "places double quotes around the selection." ),
               ( "tripled-quote-selection",  'places triple " around the selection.' ),
               ("triples-quote-selection", "places triple ' around the selection." ) ):
        info = Information( z[ 0 ], z[ 1 ] )
        self.info_structures[ z[ 0 ] ] = info
    
    
</t>
<t tx="ekr.20070127142814.1491">@others
</t>
<t tx="ekr.20070127142814.1492">class vi_emulation:
    
    def __init__( self, c ):
        self.c = c
        self.mode = None
        
        &lt;&lt;define vi keystrokes&gt;&gt;
        
    def __call__( self, event, command ):
        
        
        if self.mode:
            return self.mode( event, command )
        return self.vi_keystrokes[ command ]( event, command )</t>
<t tx="ekr.20070127142814.1493">self.vi_keystrokes = {

    'dd': self.deleteLine,
    'i': self.insert,






}</t>
<t tx="ekr.20070127142814.1494">def cut( self, event ):
    pass</t>
<t tx="ekr.20070127142814.1495">def deleteLine( self, event, command ):
    pass
    
</t>
<t tx="ekr.20070127142814.1496">def insert( self, event, command ):
    pass</t>
<t tx="ekr.20070127142814.1497">import javax.swing as swing
import java.awt as awt
import java.awt.event as aevent
import java

jf = swing.JFrame()
jtp = swing.JTextPane()
jf.add(jtp)

items = {}

class listener(aevent.KeyAdapter):
    
    def __init__( self ):
        aevent.KeyAdapter.__init__(self)
        
    def keyPressed(self, event):
        
        kcode = event.getKeyCode()
        ktext = event.getKeyText(kcode)
        char = event.getKeyChar()
        if( event.isShiftDown() ):
            ktext = "shift %s" % ktext
        ktext = ktext.lower()
        items[ ktext ] = char
        
jtp.addKeyListener( listener())

jb = swing.JButton( "Close")
jf.add( jb, awt.BorderLayout.SOUTH)
def dooit(event):
    f = open( "table.txt", "w")
    for z in items.keys():
        print z
        f.write( "'%s':'%s'\n" % ( z, items[z] ) )
    f.close()
    java.lang.System.exit(0)

jb.actionPerformed = dooit
jf.pack()
jf.visible = 1
        </t>
<t tx="ekr.20070127142814.1498">"""A SwingMacs extension to store Leo trees in dumbdbm files."""

&lt;&lt; about this extension &gt;&gt;

__version__ = ".1"

&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;

haveseen = util.WeakHashMap() #   weakref.WeakKeyDictionary()


@others

</t>
<t tx="ekr.20070127142814.1499">@

Note: there isnt such a thing as an anydbm file: it's whatever the anydbm module
uses).

Under Outline, there is an option called 'Open Library'. This will open an PMW
dialog with a list of the trees that you have saved. You can insert trees stored
in the library, remove them and add trees to the library. Be aware of unicode,
any characters outside of the ascii set gets turned into a ?. I found this
problem in storing some trees from ed's Leo outline. Id like it to be able to
store unicode, but that may require a more specific db background, than anydbm.
Also note, that your library files may not be OS independent. If your python
distribution does not have the backing db on another machine, it will not be
able to open your library.

This should help people develop templates that they want to reuse between Leo
projects.  For example, Id like a template of many Java interfaces to be easily
accessable.  This solves my problem I think.
</t>
<t tx="ekr.20070127142814.1500">@

0.1: created out of concepts in Library plugin
</t>
<t tx="ekr.20070127142814.1501">import leoGlobals as g
import SwingMacs 

import dumbdbm
import javax.swing as swing
import javax.swing.event as sevent
import java.awt as awt
import java.util as util
import zlib
import java.util.zip as zipo
import java.io 
#import weakref

#Tk   = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
#mw  = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
#zlib = g.importExtension("zlib",   pluginName=__name__,verbose=True)</t>
<t tx="ekr.20070127142814.1502">class JLibrary_Loc( sevent.ListSelectionListener ):
    
    @others
    
</t>
<t tx="ekr.20070127142814.1503">def __init__( self, emacs  ):
    
    self.emacs = emacs
    path,file = g.os_path_split( g.app.loadDir)
    path = g.os_path_join(path,"swingmacs_exts","lib_locations.txt") 
    self.path = path
    llfile = java.io.File( path )
    data = []
    if llfile.exists():
        fos = java.io.FileInputStream( llfile )
        isr = java.io.InputStreamReader( fos )
        brd = java.io.BufferedReader( isr )
        
        while 1:
            line = brd.readLine()
            if line == None:
                break
            else:
                data.append( line )
                
    else:
        llfile.createNewFile()

    
    self.libraries = {}
    for z in data:
        nl = z.split( '=' )
        if len( nl ) == 2:
            name, location = nl
            self.libraries[ name ] = location
            
    
    self.jd = None

</t>
<t tx="ekr.20070127142814.1504">def __call__( self, event, command ):
    
    
    self.emacs.keyboardQuit( event )
    if self.jd == None:
        self.createGui()
    #data = self.db.keys()
    #data.sort()
    data = self.libraries.keys()
    data.sort()
    dlm = swing.DefaultListModel()
    for z in data:
        dlm.addElement( z )
    self.libs.setModel( dlm )
    if len( data ) != 0:
        self.libs.setSelectedIndex( 0 )
    
    jd = self.jd 
    jd.validate()
    jd.pack()
    x, y = g.app.gui._calculateCenteredPosition( jd )
    jd.setLocation( x, y )
    jd.show()
    return True
    
    


</t>
<t tx="ekr.20070127142814.1505">def sync( self ):
    
    try:
        lib_loc = java.io.File( '%s.tmp' % self.path )
        pwriter = java.io.PrintWriter( lib_loc )
    
        for z in self.libraries:
        
            line = '%s=%s' %( z, self.libraries[ z ] )
            pwriter.println( line )
        
    
        pwriter.close()
        lib_loc.renameTo( java.io.File( self.path ) )
    finally:
        pass
        
        
    data = self.libraries.keys()
    data.sort()
    dlm = swing.DefaultListModel()
    for z in data:
        dlm.addElement( z )
    self.libs.setModel( dlm )
    if len( data ) != 0:
        self.libs.setSelectedIndex( 0 ) 
        
    
        </t>
<t tx="ekr.20070127142814.1506">def createGui( self ):
    
    
    self.jd = jd = swing.JDialog()
    self.jd.setName( "Leodialog" )
    jd.setTitle( "Libraries" )
    jdc = jd.getContentPane()
    self.libs = lib = swing.JList()
    self.libs.setName( "Autolist" )
    lib.setVisibleRowCount( 5 )
    view = swing.JScrollPane( lib )
    jdc.add( view, awt.BorderLayout.NORTH )
    create = swing.JButton( "Create" )
    create.actionPerformed = self.create
    add = swing.JButton( "Add" )
    add.actionPerformed = self.add 
    move = swing.JButton( "Move" )
    move.actionPerformed = self.move
    remove = swing.JButton( "Remove" )
    remove.actionPerformed = self.remove
    _open = swing.JButton( "Open" )
    _open.actionPerformed = self.open 
    close = swing.JButton( "Close" )
    close.actionPerformed = self.close
    
    topjp = swing.JPanel()
    topjp.setLayout( awt.GridLayout( 2, 1 ) )
    jdc.add( topjp, awt.BorderLayout.SOUTH )
    
    self.message = swing.JTextField()
    mp = swing.JPanel()
    gbl = awt.GridBagLayout()
    mp.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.weightx = 1.0
    gbc.weighty = 1.0
    gbc.fill = 1
    gbl.setConstraints( self.message, gbc )
    mp.add( self.message )
    
    topjp.add( mp )# , awt.BorderLayout.NORTH )
    
    jp = swing.JPanel()
    jp.setLayout( awt.GridLayout( 1, 6 ) )
    jp.add( create )
    jp.add( add )
    jp.add( move )
    jp.add( remove )
    jp.add( _open )
    jp.add( close )
    topjp.add( jp )#, awt.BorderLayout.SOUTH ) 

</t>
<t tx="ekr.20070127142814.1507">def create( self, *args ):
    
    fc = swing.JFileChooser()
    fc.showDialog( self.jd, "Create" )
    
    path = fc.getSelectedFile()
    if path:
        if not path.isDirectory():
            if not path.exists():
                apath = path.getAbsolutePath()   
                             
                if not apath.endswith( ".zip" ):
                    apath = '%s.zip' % apath
                
                try:    
                    nfile = java.io.File( apath )
                    fs = java.io.FileOutputStream( nfile )
                    zfos = java.util.zip.ZipOutputStream( fs )
                    zfos.putNextEntry( java.util.zip.ZipEntry( "" ) )
                    zfos.setLevel( 9 )
                    zfos.finish()
                    zfos.close()
                
                    
                    storepath = nfile.getName().rstrip( '.zip' )
                    self.libraries[ storepath ] = apath
                    self.sync()
                    self.message.setText( "%s Creation Successful" % storepath )
                except java.lang.Exception, x:
                    x.printStackTrace()
                    self.message.setText( "Could not create %s" % apath )
                     

</t>
<t tx="ekr.20070127142814.1508">def move( self, *args ):
    
    svalue = self.libs.getSelectedValue()
    if svalue != None:
        
        jfc = swing.JFileChooser()
        jfc.setSelectedFile( java.io.File( self.libraries[ svalue ] ) )
        jfc.showDialog( self.jd, "Move %s To" % svalue )
        sfile = jfc.getSelectedFile()
        if sfile == None:
            sfile = jfc.getCurrentDirectory()
        
        print sfile   
        if sfile != None:
            try:
                if sfile.isDirectory():
                    tobemoved = java.io.File( self.libraries[ svalue ] )
                    name = tobemoved.getName()
                    nlocation = java.io.File( sfile, name )
                    tobemoved.renameTo( nlocation )
                    self.libraries[ svalue ] = nlocation.getAbsolutePath()
                    self.sync()
                    self.message.setText( "Moved %s Ok" % svalue )
                    
                else: 
                
            
                    tobemoved = java.io.File( self.libraries[ svalue ] )
                    del self.libraries[ svalue ]
                    tobemoved.renameTo( sfile )
                    name = sfile.getName()
                    name = name.rstrip( '.zip' )
                    self.libraries[ name ] = sfile.getAbsolutePath()
                    self.sync()
                    self.message.setText( "Moved %s Ok" % svalue )
                
            except:
                self.message.setText( "Problems Moving %s" % svalue )       
</t>
<t tx="ekr.20070127142814.1509">def remove( self, *args ):
    
    jlist = self.libs
    sv = jlist.getSelectedValue()
    model = jlist.getModel()
    model.removeElement( sv )
    
    del self.libraries[ sv ]
    self.sync()
    self.message.setText( "Removed %s from path store" % sv )
    
    





</t>
<t tx="ekr.20070127142814.1510">def open( self, *args ):

    val = self.libs.getSelectedValue()
    path = self.libraries[ val ]
    if not path.endswith( '.zip' ):
        path = '%s.zip' % path
        
    exists = java.io.File( path )
    if exists.exists():
        
        jl = JLibrary( self.emacs.c, path )
        jl.getDialog()
    



</t>
<t tx="ekr.20070127142814.1511">def close( self, *args ):
    
    self.jd.hide()</t>
<t tx="ekr.20070127142814.1512">def add( self, *args ):

    jfc = swing.JFileChooser()
    jfc.showOpenDialog( self.jd )
    
    
    addto = jfc.getSelectedFile()
    if addto != None and addto.isFile():
        
        try:
            ziptest = java.util.zip.ZipFile( addto )
            name = addto.getName()
            if name.endswith( '.zip' ):
                name = name.rstrip( '.zip' )
            
            self.libraries[ name ] = addto.getAbsolutePath()
            self.sync()
            self.message.setText( "Added %s Ok" % name )
        
        except:
            self.message.setText( "Could not add %s" % addto.getName() )
            
            
        

</t>
<t tx="ekr.20070127142814.1513">def valueChanged( self, event ):
    
    val = self.libs.getSelectedValue()
    if val != None:
        message = self.libraries[ val ]
    else:
        message = ""
        
    self.setToolTipText( message )
    </t>
<t tx="ekr.20070127142814.1514">def addToAltX( self ):
    
    return [ 'j-library', ]</t>
<t tx="ekr.20070127142814.1515">def addToKeyStrokes( self ):
    return None</t>
<t tx="ekr.20070127142814.1516">class JLibrary:
    '''This class presents an interface through which a Libray can be used.
    It alsoprovides a gui dialog to interact with the Library.'''
    openlibs = {}
    
    @others</t>
<t tx="ekr.20070127142814.1517">def __init__( self, c, path):
    
    self.c = c
    self.path = path
    
    self.db = java.io.File( path )
    self.size = self.db.length()
    
    
    
    
    # Set self.db.
    #if JLibrary.openlibs.has_key( path ):
    #    self.db = JLibrary.openlibs[ path ]
    #elif g.os_path_exists( path ):
    #    self.db = dumbdbm.open( path, "rw" )
    #    JLibrary.openlibs[ path ] = self.db
    #else:
    #    self.db = dumbdbm.open( path, "c" ) 
    #    JLibrary.openlibs[ path ] = self.db

</t>
<t tx="ekr.20070127142814.1518">def add( self, name, data ):
    

   
    zf = java.util.zip.ZipFile( self.db )
    entries = zf.entries()
    data_list = []
    sname = str( name )
    for z in entries:
        if z.getName() == sname: continue
        z2 = java.util.zip.ZipEntry( z.getName() )
        ins = zf.getInputStream( z )
        data2 = []
        while 1:
            i = ins.read()
            if i == -1: break
            else: data2.append( i )
        data_list.append( ( z2, data2 ) )
        
    zf.close()
    
   
    #fos = java.io.FileOutputStream( self.db )
    bos = java.io.ByteArrayOutputStream()
    zos = java.util.zip.ZipOutputStream( bos )
    zos.setLevel( 9 )

    for z in data_list:
        zos.putNextEntry( z[ 0 ] )
        zos.write( z[ 1 ], 0, len( z[ 1 ] ) )
        zos.closeEntry()
        
        
    nze = java.util.zip.ZipEntry( name )
    zos.putNextEntry( nze )
    bytes = data.getBytes()
    zos.write( bytes, 0, len( bytes ) )
    zos.closeEntry()
    zos.finish()
    
    barray = bos.toByteArray()
    zos.close()
   
    #fos = java.io.FileOutputStream( self.db )
    #fos.write( barray, 0, len( barray ) )
     
    try:
        
        tmpfile = java.io.File( '%s.tmp' % self.db.getAbsolutePath() )
        fos = java.io.FileOutputStream( tmpfile )
        fos.write( barray, 0, len( barray ) )
        fos.close()   
        tmpfile.renameTo( self.db )
        self.db = java.io.File( self.db.getAbsolutePath() )
        
    finally:
        pass
    
    
  

</t>
<t tx="ekr.20070127142814.1519">def remove( self, name ):
    
    #del self.db[ name ]
    #self.db.sync()
    zf = java.util.zip.ZipFile( self.db )
    entries = zf.entries()
    
    zentries = []
    for z in entries:
        if z.hashCode() ==  name.hashCode(): 
            continue
        z2 = java.util.zip.ZipEntry( z.getName() )
        istream = zf.getInputStream( z )
        bytes = []
        while 1:
            data = istream.read()
            if data == -1: break
            else: bytes.append( data )
        
        zentries.append( ( z2, bytes ) )
     
    zf.close()   
    #entries2 = zf.entries()
    bos = java.io.ByteArrayOutputStream()
    zos = java.util.zip.ZipOutputStream( bos )
    for z in zentries:
        zos.putNextEntry( z[ 0 ] )
        zos.write( z[ 1 ] )
        zos.closeEntry()
    
    zos.finish()
    ba = bos.toByteArray()
    try:
        tmpfile = java.io.File( '%s.tmp' % self.db.getAbsolutePath() )
        fos = java.io.FileOutputStream( tmpfile )
        fos.write( ba, 0, len( ba ) )
        fos.close()   
        zos.close()
        tmpfile.renameTo( self.db )
        self.db = java.io.File( self.db.getAbsolutePath() )
        
    finally:
        pass
        
    

</t>
<t tx="ekr.20070127142814.1520">def names( self ):

    zf = java.util.zip.ZipFile( self.db )
    entries = zf.entries()
    rlist = []
    for z in entries:
        rlist.append( z )
        
    rlist.sort()
    return rlist
    

</t>
<t tx="ekr.20070127142814.1521">def retrieve( self, name ):
    

    zf = java.util.zip.ZipFile( self.db )
    ins = zf.getInputStream( name )
    bytes = []
    while 1:
        data = ins.read()
        if data == -1: break
        else: bytes.append( data )
        
    

    return str( java.lang.String( bytes ) )
    
@
    data = self.db[ name ]
    #print "'%s'" % data
    print len( data )
    data = java.lang.String( data )
    barray = data.getBytes()
    bais = java.io.ByteArrayInputStream( barray )
    inflater = java.util.zip.Inflater()
    iis = java.util.zip.InflaterInputStream( bais, inflater )
    #isr = java.io.InputStreamReader( iis )
    #br = java.io.BufferedReader( isr )
    bytes = []
    try:
        while 1:
            ndata = iis.read()
            if ndata == -1: break
            else: bytes.append( ndata )
    finally:
        print len( bytes )
    return str( java.lang.String( bytes ) )
    #data = zlib.decompress( data )
    # return unicode( data )
    #return g.toUnicode(data,"utf-8",reportErrors=True)




</t>
<t tx="ekr.20070127142814.1522">def getDialog( self ):
    
    
    
    self.dialog = swing.JDialog()
    self.dialog.setName( "Leodialog" )
    self.dialog.setTitle( self.path )
    self.dialog.getContentPane().setOpaque( False )
    #pass
    b = swing.JButton( "Close" )
    self.dialog.add( b, awt.BorderLayout.SOUTH )
    b.actionPerformed = lambda *args: self.dialog.dispose()
    self.addList( self.dialog )
    self.dialog.pack()
    x, y = g.app.gui._calculateCenteredPosition( self.dialog )
    self.dialog.setLocation( x, y )
    self.dialog.visible = 1
    
    #self.dialog = Pmw.Dialog( buttons = ( 'Close' ,) , title =  self.path)
    #butbox = self.dialog.component( 'buttonbox' )
    #close = butbox.button( 0 )
    #close.configure( foreground = 'blue', background = 'white' )
    #hull = self.dialog.component( 'hull' )
    #sh = hull.winfo_screenheight()/4 
    #sw = hull.winfo_screenwidth()/4
    #hull.geometry( str( 325 )+"x"+str( 325 )+"+"+str(sw)+"+"+str(sh) )   
    #frame = Tk.Frame( hull)
    #frame.pack( fill = 'both', expand = 1 )
    #self.addList( frame )

</t>
<t tx="ekr.20070127142814.1523">def addList( self, frame ):
    
    self.lbox = swing.JList()
    self.lbox.setName( "Autolist" )
    view = swing.JScrollPane( self.lbox )
    self.lbox.setVisibleRowCount( 5 )
    frame.add( view )
    self.setListContents()
    jp = swing.JPanel()
    jp.setLayout( awt.GridLayout( 3, 1 ) )
    frame.add( jp, awt.BorderLayout.EAST )
    
    for z in (  ( "Insert into outline", self.insert ),
                ( "Remove from list" , self.delete ),
                ( "Add Current Node to list", self.addCurrentNode ), ):
        jb = swing.JButton( z[ 0 ] )
        jb.actionPerformed = z[ 1 ]
        jp.add( jb )

@
    self.lbox = Pmw.ScrolledListBox( frame )
    lb = self.lbox.component( 'listbox' )
    lb.configure( background = 'white', foreground = 'blue' )
    self.setListContents()
    self.lbox.pack( side = 'left' )
    frame2 = Tk.Frame( frame )
    frame2.pack( side = 'right' )
    insert = Tk.Button( frame2, text = 'Insert into outline' )
    insert.configure( background = 'white', foreground = 'blue' )
    insert.configure( command = self.insert )
    insert.pack()
    remove = Tk.Button( frame2, text = 'Remove from list' )
    remove.configure( background = 'white', foreground = 'blue' )
    remove.configure( command = self.delete )
    remove.pack()
    add = Tk.Button( frame2, text = 'Add Current Node to list' )
    add.configure( background = 'white', foreground = 'blue' )
    add.configure( command = self.addCurrentNode )
    add.pack()
</t>
<t tx="ekr.20070127142814.1524">def setListContents( self ):
    
    items = self.names()
    #items.sort()
    mod = swing.DefaultListModel()
    slvalue = self.lbox.getSelectedValue()
    for z in items:
        mod.addElement( z )
    self.lbox.setModel( mod )
    self.dialog.pack()
    if slvalue != None and slvalue in items:
        self.lbox.setSelectedValue( slvalue )
    else:
        if len( items ) &gt; 0:
            self.lbox.setSelectedIndex( 0 )
    
    #self.lbox.setlist( items )

</t>
<t tx="ekr.20070127142814.1525">def insert( self, *args ):
    
    c = self.c
    item = self.lbox.getSelectedValue()
    s = self.retrieve( item )
    g.app.gui.replaceClipboardWith(s)
    self.c.pasteOutline()

</t>
<t tx="ekr.20070127142814.1526">def delete( self, *args ):
    
    c = self.c
    #item = self.lbox.getvalue()
    item = self.lbox.getSelectedValue()
    #if len( item ) == 0: return
    #item = item[ 0 ]
    self.remove( item )
    self.setListContents()
</t>
<t tx="ekr.20070127142814.1527">def addCurrentNode( self, *args ):
    
    c = self.c 
    p = c.currentPosition()
    hs = java.lang.String( p.headString())
    s =  java.lang.String( c.fileCommands.putLeoOutline() )
    self.add( hs, s )
    self.setListContents()
</t>
<t tx="ekr.20070127142814.1528">def getCommands():
    
    return {
    
        'j-list' : JLibrary_Loc
    
    
    
    
    }</t>
<t tx="ekr.20070127142814.1529">@others</t>
<t tx="ekr.20070127142814.1530">from __future__ import generators
import javax.swing as swing
import javax.swing.text as stext
import javax.swing.event as sevent
import java.util.concurrent as concurrent
import java.lang as jlang
import java
import string
import ColorizerRunnable
import weakref

class JyLeoColorizer( sevent.DocumentListener ):
    
    def __init__( self, editor, cdeterminer ):
        self.editor = weakref.proxy( editor )
        self.queue = concurrent.LinkedBlockingQueue()
        self.watch = 1
        self.clr = ColorizerRunnable( editor, cdeterminer, self.queue )
        cthread = jlang.Thread( self.clr ) #This thread does all the colorization for us
        cthread.setDaemon( True )
        cthread.setName( "Colorizer Thread" )
        cthread.start()
        editor.getDocument().addDocumentListener( self )
    
    def fullrecolorize( self ):
        doc = self.editor.getDocument()
        self.clr.positions.clear()
        try:
            self.watch = 0
            self.queue.offer( ( 0, doc.getLength(), None ) )
        finally:
            self.watch = 1
        
    def recolorizenow( self ):
        doc = self.editor.getDocument()
        self.queue.clear()
        self.clr.positions.clear()
        try:
            try:
                self.clr.colorizeline(  0, doc.getLength(), None )
            except java.lang.Exception, x:
                x.printStackTrace()
        finally:
            self.watch = 1
        
    def ignoreEvents( self ):
        self.watch = 0
        
    def watchEvents( self ):
        self.watch = 1
    
    def insertUpdate( self, event ):
        
        if self.watch:
            self.queue.offer( ( event.getOffset(), event.getLength(), event.getType() ) )
        
    def removeUpdate( self, event ):
        if self.watch:
            self.queue.offer( ( event.getOffset(), event.getLength(), event.getType() ) )
        
    def changedUpdate( self, event ):
        pass
    
    @others
    
</t>
<t tx="ekr.20070127142814.1531">class colorizer( jlang.Runnable ):
        
    def __init__( self, queue, editor, cdeterminer ):
        #JyLeoColorizerBase.__init__( self, editor, cdeterminer, queue )
        self.queue = queue
        self.editor = editor
        self.cdeterminer = cdeterminer
        self.positions = []
        self.runn = 0
@    
    def run( self ):
        while 1:
            try:
                spots = []
                i = self.queue.take()
                spots.append( i )
                if self.queue.size():
                    self.queue.drainTo( spots )
                    spot1 = i[ 0 ]
                    length = i[ 1 ]
                    event = i[ 2 ]
                    for z in spots[ 1: ]:
                        if z[ 0 ] &lt; spot1:
                            spot1 = z[ 0 ]
                        else:
                            add = z[ 0 ] - spot1
                            add += z[ 1 ]
                            length += add
                    i = ( spot1, length, event )

                self.colorizeline( i )

            except java.lang.Exception, x:
                print x
                x.printStackTrace()
@c            
            
    def colorizeline2( self, spots ):
                

        dtype = spots[ 2 ]
        begin = spots[ 0 ]

        ctokens = self.cdeterminer.getColoredTokens()
        e = stext.Utilities.getParagraphElement( self.editor, begin )
        e2 = stext.Utilities.getParagraphElement( self.editor, spots[ 0 ] + spots[ 1 ] )
        start = e.getStartOffset()
        end = e2.getEndOffset()
        doc = self.editor.getDocument()
        line = doc.getText( start, end - start )
        w_atts = []
        sr1 = "&lt;" + "&lt;"
        sr2 = "&gt;" + "&gt;"
        sec_refs = doc._srs
        comments = self.cdeterminer.getCommentTokens()
        docing = False
        prevtoken = "\n"
        #for z in self.tokenize( line, start ):
        #( String data, int beginspot, String[] commenttokens, Document doc, List&lt;PyTuple&gt; positions )  
@  
        for z in JyLeoTokenizer( line, start, comments, doc, self.positions ):
            #print "'%s'" % z
            if docing:
                if z != "@c":
                    w_atts.append( ( z, "p" ) )
                else:
                    docing = False
            if z.startswith( '"' ) or z.startswith( "'" ):
                w_atts.append( (  z , "p" ) )
            elif self.iscomment( z, comments ):
                w_atts.append( ( z, "p" ) )
            elif z.startswith( sr1 ) and z.endswith( sr2 ):
                guts = z[ 2: -2 ]
                outer = ctokens.get( "&lt;" + "&lt;" )
                if sec_refs.containsKey( guts ):
                    scolor = self.cdeterminer.getSectionReferenceColor()
                else:
                    scolor = self.cdeterminer.getUndefinedSectionReferenceColor()
                w_atts.append( ( sr1, outer ) )
                w_atts.append( ( guts, scolor ) )
                w_atts.append( ( sr2, outer ) )
            else:
                if z.isspace() or not ctokens.containsKey( z ):
                    if z in string.punctuation:
                        w_atts.append( ( z, self.cdeterminer.getPunctuationColor() ) )
                    elif z.isspace():
                        w_atts.append(( z, "p" ))
                    elif z.isnumeric():
                        nsas = stext.SimpleAttributeSet()
                        stext.StyleConstants.setForeground( nsas, java.awt.Color.ORANGE )
                        w_atts.append( ( z, nsas ) )
                    else:
                        w_atts.append( ( z, None ) )
                else:
                    w_atts.append( ( z, ctokens.get( z ) ) )
                    if z == "@" and prevtoken.endswith( "\n" ): docing = True
            prevtoken = z
@c                 
        
        self.super__colorizeline( *spots )
        sas = stext.SimpleAttributeSet()
        stext.StyleConstants.setForeground( sas, java.awt.Color.BLUE )
        self.color( start, w_atts, doc, sas )
        
        #self.positions.sort( self.sortp )
        copyofp = copy.copy( self.positions )
        #print copyofp.__class__
        copyofp.sort( self.sortp )
        scolor = self.cdeterminer.getStringColor()
        scolor2 = self.cdeterminer.getDocColor()
        coloring = None
        colorstart = -1
        #print self.positions
        offsets = []
        comments = self.cdeterminer.getCommentTokens()
        commentcolor = self.cdeterminer.getCommentColor()
        #copyofp = copy.copy( self.positions )

        

        ignore1 = ignore2 = -1
        #print copyofp
        for z in copyofp:
            try:
                offset = z[ 0 ].getOffset()
                if offset &gt; end and not coloring: 
                    #print "RETURNING!!!!!"
                    return
                item = doc.getText( z[ 0 ].getOffset(), 1 )
                if item != z[ 1 ]:
                    self.positions.remove( z )
                    if z[ 0 ].getOffset() == spots[ 0 ] and dtype == sevent.DocumentEvent.EventType.REMOVE:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None )) 
                    continue
                if z[ 0 ].getOffset() in offsets:
                    self.positions.remove( z )
                    if dtype == sevent.DocumentEvent.EventType.REMOVE and z[ 0 ].getOffset() == spots[ 0 ]:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None )) 
                    continue
                offsets.append( z[ 0 ].getOffset() )
            except java.lang.Exception, x:
                self.positions.remove( z )
                continue
                
            if not coloring:
                coloring = z[ 1 ]
                colorstart = z[ 0 ].getOffset()
                if colorstart &gt; ignore1 and colorstart &lt; ignore2:
                    #print "IGNORING %s" % coloring
                    coloring = None
                    continue
                if coloring == '@':
                    end2 = stext.Utilities.getWordEnd( self.editor, colorstart + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, colorstart )
                    txt = doc.getText( colorstart , end2 - colorstart )
                    if txt.strip() not in ( "@", ) or start2 != colorstart:
                        coloring = None
                        if dtype == sevent.DocumentEvent.EventType.INSERT and colorstart + 1 == spots[ 0 ]:
                            return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )
                elif coloring and self.ispossiblecomment( coloring, comments ):
                    l1 = len( comments[ 0 ] )
                    txt = doc.getText( colorstart, l1 )
                    if txt == comments[ 0 ]:
                        e = stext.Utilities.getParagraphElement( self.editor, colorstart )
                        end2 = e.getEndOffset()
                        doc.setCharacterAttributes( colorstart, end2 - colorstart, commentcolor, 1 )
                        ignore1 = colorstart;ignore2 = end2
                        coloring = None
                    elif txt == comments[ 1 ]:
                        pass
                    else:
                        coloring = None
                continue
            if coloring in ( "'", '"' ):
                if z[ 1 ] == coloring:
                    eoffset = z[ 0 ].getOffset()
                    emarker = stext.Utilities.getRowEnd( self.editor, eoffset )
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( eoffset )
                    if cs.getAttributes().isEqual( scolor )\
                    and ce.getAttributes().isEqual( scolor )\
                    and ( begin &lt; colorstart or begin &gt; emarker ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, eoffset + 1  - colorstart, scolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and eoffset == spots[ 0 ]:
                        return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )
            elif coloring in( "@", ):
                try:
                    offset = z[ 0 ].getOffset()
                    end2 = stext.Utilities.getWordEnd( self.editor, offset + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, offset )
                    if start2 == offset:
                        txt = doc.getText( start2 , end2 - start2 )
                        if txt.strip() in ("@c", ):
                            cs = doc.getCharacterElement( colorstart + 1 )
                            ce = doc.getCharacterElement( offset )
                            if cs.getAttributes().isEqual( scolor2 )\
                            and ce.getAttributes().isEqual( scolor2 )\
                            and ( begin &lt; colorstart or begin &gt; end2 ):
                                pass
                            else:
                                doc.setCharacterAttributes( colorstart + 1, offset - colorstart -1, scolor2, 1 )
                            coloring = None
                            if dtype == sevent.DocumentEvent.EventType.INSERT and start2 + 1 == spots[ 0 ]:
                                return self.colorizeline( ( start2, doc.getLength() - start2, None ) )
                except java.lang.Exception, x:
                    pass 
            elif coloring and self.ispossiblecomment( coloring, comments ):
                
                cend = comments[ 2 ]
                offset = z[ 0 ].getOffset()
                txt = doc.getText( offset, len( cend ) )
                if txt == cend:
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( offset + len( cend ) )
                    if cs.getAttributes().isEqual( commentcolor )\
                    and ce.getAttributes().isEqual( commentcolor )\
                    and ( begin &lt; colorstart or begin &gt; offset ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, (offset + len( cend ) ) -colorstart, commentcolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and ( offset &lt;= spots[ 0 ] and offset + len( cend ) &gt;= spots[ 0 ] ):
                        return self.colorizeline( ( offset, doc.getLength() - offset, None ) )
                
                    
        if coloring:
            if coloring in ( "'", '"' ):
                pass
            elif coloring == "@":
                colorstart += 1 
                scolor = scolor2
            else:
                scolor = commentcolor    
            doc.setCharacterAttributes( colorstart, doc.getLength() - colorstart, scolor, 1 )

        
    @others
        
        
</t>
<t tx="ekr.20070127142814.1532">def tokenize( self, data, beginspot):
                
    cword = ""
    spot = -1
    beginspot -= 1
    ignore = False
    doc = self.editor.getDocument()
    ctokens = self.cdeterminer.getCommentTokens()
    #print ctokens
    escaping = False
    for x in xrange( len(data) ):
        spot += 1
        beginspot += 1
        if spot &gt;= len( data ): break
        z = data[ spot ]
        #print z, cword
        if z == "\\" or escaping:
            #print "ESCAPE!!! %s" % cword
            if escaping:
                cword += z
                yield cword
                cword = ""
                escaping = False
                continue
            else:
                escaping = True
                cword += z
                continue
        if z in ( "@", '"',"'" ):
            self.addPosition( beginspot, z, doc )  
        if z in ( '"', "'" ):
            yield cword
            cword = ""
            dspot = spot + 1
            while 1:
                #print "DSPOTIN!!!"
                i = data.find( z, dspot )
                if i != -1:
                    if data[ i -1 ] == "\\":
                        dspot = i + 1
                        if dspot &gt;= len( data ):
                            i == -1
                            break
                        continue
                    else: break
                else: break
            if i == -1:
                yield data[ spot: ]
                ignore = True
                break
            else:
                rv = data[ spot : i + 1 ]
                self.addPosition( beginspot + len( rv ) -1, z, doc )
                yield rv
                cword = ""
                spot += len( rv ) - 1
                beginspot += len( rv ) -1
                continue
        elif z == '&lt;':
            if spot &lt; len( data ):
                    
                i = data.find( "&lt;&lt;", spot  )
                if i !=  spot:
                    yield cword
                    yield z
                    cword = ""
                    continue
                else:
                    i2 = data.find( "&gt;&gt;", spot )
                    if i2 == -1:
                        yield cword
                        yield z
                        cword = ""
                        continue
                    else:
                        rv = data[ i: i2 + 2 ]
                        yield cword
                        yield rv
                        spot += len( rv ) - 1
                        beginspot += len( rv ) - 1
                        cword = ""
                        continue
        elif cword.isspace() and not z.isspace():
            yield cword
            cword = ""
        elif z.isspace() and cword.isspace():
            pass
        elif z == '@' and cword == '':
            pass
        elif self.ispossiblecomment( cword, ctokens ) and self.ispossiblecomment( z , ctokens ):
            pass
        elif cword in ctokens and not self.ispossiblecomment( z, ctokens ):
            if cword == ctokens[ 0 ]:
                i = data.find( "\n", spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i]
                
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1 
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1               
                yield cword
                cword = ""
                continue
            if cword == ctokens[ 1 ]:
                i = data.find( ctokens[ 2 ], spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i + len( ctokens[ 2 ] ) ]
                    
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                if i != -1:
                    self.addPosition( i , ctokens[ 2 ][ 0 ], doc )
                
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1 
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1     
                yield cword
                cword = ""
                continue
            self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
            cword = ""
        elif not z.isalnum():
            yield cword
            if not self.ispossiblecomment( z, ctokens ):
                yield z
                cword = ""
                continue
            else:
                cword = ""
                
            
        cword += z
        
    if not ignore:       
        yield cword   
</t>
<t tx="ekr.20070127142814.1533">def sortp( self, a, b ):
    offset1 = a[ 0 ].getOffset()
    offset2 = b[ 0 ].getOffset()
    if offset1 &gt; offset2: return 1
    elif offset1 &lt; offset2: return -1
    return 0</t>
<t tx="ekr.20070127142814.1534">def addPosition( self, i, c, doc ):
    ok = True
    #oset = z[ 0 ].getOffset()
    #start = java.lang.System.currentTimeMillis()
    for z in copy.copy( self.positions ):
        oset = z[ 0 ].getOffset()
        c2 = z[ 1 ]
        if i == oset and c2 == c:
            ok = False
            break
        elif i == oset and c2 != c:
            self.positions.remove( z )
    if ok:
        data2 = ( doc.createPosition( i ), c )
        self.positions.append( data2 )
        
    #end = java.lang.System.currentTimeMillis()
    #print "pos add: %s" % ( end - start )</t>
<t tx="ekr.20070127142814.1535">def color2( self, spot, c_atts, doc, bsas ):

    for z in c_atts:
        size = len( z[ 0 ] )
        #print "COLOR:'%s', %s, '%s', %s" % (z[ 0 ], self.spot, self.doc.getText( self.spot, size ) , size )
        sas = z[ 1 ]
        if not sas: sas = bsas
        try:
            cs = doc.getCharacterElement( spot )
            ce = doc.getCharacterElement( spot + size -1 )
            if sas != "p" and not ( cs.getAttributes().isEqual( sas ) and ce.getAttributes().isEqual( sas ) ):
                doc.setCharacterAttributes( spot, size, sas , 1 )
            #else:
            #    print "pass %s" % sas
        except java.lang.Exception:
            pass
        spot += size</t>
<t tx="ekr.20070127142814.1536">def ispossiblecomment( self, word, comments ):
    
    #print word, comments
    for z in comments:
        if z:
            if z.startswith( word ): return True
        
    return False
    
def iscomment( self, word, comments ):
    
    for z in comments:
        if z:
            if word.startswith( z ): return True

    return False</t>
<t tx="ekr.20070127142814.1537">@language java
import java.util.*;
import javax.swing.text.*;
import java.util.regex.*;
//import org.python.core.*;

public class JyLeoTokenizer implements Iterator&lt; String &gt;, Iterable&lt;String&gt;{

    String data;
    char[] cdata;
    int beginspot;
    int spot;
    StringBuilder cword;
    String[] commenttokens;
    List&lt;String&gt; yieldproxy;
    List&lt;PositionCarrier&gt; positions;
    Document doc;
    boolean escaping;
    Matcher matcher;
    
    public JyLeoTokenizer( String data, int beginspot, String[] commenttokens, Document doc, List&lt;PositionCarrier&gt; positions ){
    

        this.data = data;
        cdata = data.toCharArray();
        this.beginspot = beginspot -1;
        this.spot = -1;
        this.cword = new StringBuilder();
        this.commenttokens =  commenttokens; //new String[ commenttokens.length ];
        escaping = false;
        yieldproxy = new LinkedList&lt;String&gt;();
        this.doc = doc;
        this.positions = positions;
        Pattern p = Pattern.compile( "\\s+[^\\s]+" );
        matcher = p.matcher( "" );
        
    }
    
    public Iterator&lt;String&gt; iterator(){ return this; }
    
    public boolean hasNext(){
    
        return ( yieldproxy.size() != 0 || spot + 1 &lt; data.length() );
    
    }
    
    public void remove(){}

    @others


}</t>
<t tx="ekr.20070127142814.1538">public boolean isSpace( StringBuilder sb ){
    
    if( sb.length() == 0 ) return false;
    for( int i = 0; i &lt; sb.length(); i++ )
        if( !Character.isWhitespace( sb.charAt( i ) ) ) return false; 

    return true;


}</t>
<t tx="ekr.20070127142814.1539">public boolean ispossiblecomment( StringBuilder word ){ 

    if( word.length() == 0 ) return false;
    String word2 = word.toString();
    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.startsWith( word2 ) ) return true;
    
    }
return false; 
@
    for z in comments:
        if z:
            if z.startswith( word ): return True
    return False
@c

}
public boolean ispossiblecomment( char c ){ 

    String word2 = Character.toString( c );
    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.startsWith( word2 ) ) return true;
    
    }
    return false; 


}

public boolean commentcontains( String word ){

    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.equals( word ) ) return true;
    
    }
    return false;

}</t>
<t tx="ekr.20070127142814.1540">public void addPosition( int i, char c ){

    boolean ok = true;
    List&lt;PositionCarrier&gt; positions2 = new ArrayList&lt;PositionCarrier&gt;();
    positions2.addAll( positions );
    for( PositionCarrier p: positions2 ){
    
        int offset = p.pos.getOffset();
        char c2 = p.c.charAt( 0 );
        if( i == offset &amp;&amp; c2 == c ){
            ok = false;
            break;
        
        
        }
        else if( i == offset &amp;&amp; c != c2 ){
            //System.out.println( "REMOVING " + o + "for " + i + " " + c );
             positions.remove( p );
             
        }
    
    }
    if( ok ){
    
        try{
            
            Position pos = doc.createPosition( i );
            PositionCarrier pc = new PositionCarrier( pos , Character.toString( c ) );
            positions.add( pc );
            //System.out.println( "POSITIONS NOW:" + positions );
            
        }
        catch( BadLocationException ble ){}
        
    
    }


}
@
    ok = True
    #oset = z[ 0 ].getOffset()
    #start = java.lang.System.currentTimeMillis()
    for z in copy.copy( self.positions ):
        oset = z[ 0 ].getOffset()
        c2 = z[ 1 ]
        if i == oset and c2 == c:
            ok = False
            break
        elif i == oset and c2 != c:
            self.positions.remove( z )
    if ok:
        data2 = ( doc.createPosition( i ), c )
        self.positions.append( data2 )

</t>
<t tx="ekr.20070127142814.1541">public String next(){

    while( spot + 1 &lt; cdata.length || yieldproxy.size() != 0 ){
        if( yieldproxy.size() != 0 ){
        
            return yieldproxy.remove( 0 );
            
        }
        spot += 1;
        beginspot += 1;
        //System.out.println( "CWORD:" + cword );
        char z = cdata[ spot ];
        &lt;&lt;escape test&gt;&gt;
        if( z == '@' || z == '"' || z == '\'' )
            addPosition( beginspot, z );
        &lt;&lt;string test&gt;&gt;
        &lt;&lt;section reference test&gt;&gt;
        &lt;&lt;space test1&gt;&gt;
        &lt;&lt;space test2&gt;&gt;
        &lt;&lt;directive test&gt;&gt;
        &lt;&lt;comment test&gt;&gt;
        &lt;&lt;comment test2&gt;&gt;
        &lt;&lt;alphanum test&gt;&gt;
        
        cword.append( z );
        //System.out.println( "CWORD END:" + cword );
    }

    return cword.toString();

}


</t>
<t tx="ekr.20070127142814.1542">if( z == '\\' || escaping ){
    
    if( escaping ){
        
        cword.append( z );
        String rv = cword.toString();
        cword = new StringBuilder();
        escaping = false;
        return rv;
            
        
    }
    else{
        
        cword.append( z );
        escaping = true;
        continue;
    
    }
        
}</t>
<t tx="ekr.20070127142814.1543">if( z == '"' || z == '\'' ){

    yieldproxy.add( cword.toString() );
    cword = new StringBuilder();
    
    int dspot = spot + 1;
    int i = -1;
    &lt;&lt;loop&gt;&gt;
    if( i == -1 ){
        
        //int ospot = spot;
        //spot = cdata.length;
        //return data.substring( ospot );
        yieldproxy.add( Character.toString( z ) );
        continue;
    
    
    }
    else{
    
        String rv2 = data.substring( spot, i + 1 );
        addPosition( beginspot + rv2.length() -1, z );
        cword = new StringBuilder();
        spot += rv2.length() - 1;
        beginspot += rv2.length() -1;
        yieldproxy.add( rv2 );
        continue;
    
    }

}

@
        if z in ( '"', "'" ):
            yield cword
            cword = ""
            dspot = spot + 1
            while 1:
                #print "DSPOTIN!!!"
                i = data.find( z, dspot )
                if i != -1:
                    if data[ i -1 ] == "\\":
                        dspot = i + 1
                        if dspot &gt;= len( data ):
                            i == -1
                            break
                        continue
                    else: break
                else: break
            if i == -1:
                yield data[ spot: ]
                ignore = True
                break
            else:
                rv = data[ spot : i + 1 ]
                self.addPosition( beginspot + len( rv ) -1, z, doc )
                yield rv
                cword = ""
                spot += len( rv ) - 1
                beginspot += len( rv ) -1
                continue


</t>
<t tx="ekr.20070127142814.1544">while( true ){
    
    i = data.indexOf( z, dspot );
    if( i != -1 ){
        
        if( cdata[ i -1 ] == '\\' ){
                
            dspot += 1;
            if( dspot &gt; cdata.length ) break;
            continue;
            
        }
        else break;
        
        
    }
    else break;    
    
}</t>
<t tx="ekr.20070127142814.1545">else if( z == '&lt;' ){

    if( spot + 1 &lt; cdata.length ){
    
        char test = cdata[ spot + 1 ];
        int i;
        if( test == '&lt;' )
            i = spot;
        else
            i = -1;
        //int i = data.indexOf( "&lt;&lt;", spot );
        if( i != spot ){
            
            String rv = cword.toString();
            cword = new StringBuilder();
            yieldproxy.add( Character.toString( z ) );
            return rv;      
        
        }
        else{
            
            int i2 = data.indexOf( "&gt;&gt;", spot );
            int i3 = data.indexOf( "\n", spot );
            if( i2 == -1 || i3 &lt; i2 ){
                
                String rv = cword.toString();
                cword = new StringBuilder();
                yieldproxy.add( Character.toString( z ) );
                return rv;
            
            
            
            }
            else{
            
                String rv = data.substring( i, i2 + 2 );
                yieldproxy.add( rv );
                spot +=  rv.length() - 1;
                beginspot += rv.length() - 1;
                String rv2 = cword.toString();
                cword = new StringBuilder();
                return rv2;
            
            
            }
        
        
        }
    
    
    
    
    }









}

</t>
<t tx="ekr.20070127142814.1546">else if( isSpace( cword ) &amp;&amp; !Character.isWhitespace( z ) ){

    String rv = cword.toString();
    cword = new StringBuilder();
    cword.append( z );
    return rv;


}</t>
<t tx="ekr.20070127142814.1547">else if( Character.isWhitespace( z ) &amp;&amp; isSpace( cword ) );</t>
<t tx="ekr.20070127142814.1548">else if( z == '@' &amp;&amp; cword.length() == 0 );// System.out.println( "DIRECTIVE!!!" );
/*else if( cword.length() == 1 &amp;&amp; cword.charAt( 0 ) == '@' &amp;&amp; Character.isWhitespace( z ) ){


    int i = data.indexOf( "@c", spot );
    if( i != -1 ){
        
        int atspot = i - spot;
        addPosition( beginspot + atspot, '@' );
        cword.append( z );
        cword.append( data.substring( spot + 1, i + 2 ) );
        String rv = cword.toString();
        cword = new StringBuilder();
        int add = ( i + 2 ) - spot;
        spot += add;
        beginspot += add;
        return rv;    
    
    
    }

    cword.append( z );
    cword.append( data.substring( spot + 1 ) );
    String rv = cword.toString();
    cword = new StringBuilder();
    spot = cdata.length;
    return rv;

}*/</t>
<t tx="ekr.20070127142814.1549">else if( ispossiblecomment( cword ) &amp;&amp; ispossiblecomment( z ) );</t>
<t tx="ekr.20070127142814.1550">else if( commentcontains( cword.toString() ) ){

    String cwstring = cword.toString();
    &lt;&lt;test1&gt;&gt;
    &lt;&lt;test2&gt;&gt;
    &lt;&lt;test3&gt;&gt;

}</t>
<t tx="ekr.20070127142814.1551">if( cwstring.equals( commenttokens[ 0 ] ) ){
    
    int i = data.indexOf( '\n', spot );
    String addon;
    if( i == -1 )
        addon = data.substring( spot );
    else
        addon = data.substring( spot, i );
        
    addPosition( beginspot - cword.length(), cword.charAt( 0 ) );
    cword.append( addon );
    if( i == -1 ) beginspot = cdata.length + 1;
    else{
        beginspot += addon.length() - 1;
        spot += addon.length() -1; 
        
    }
    String rv = cword.toString();
    cword = new StringBuilder();
    return rv;
    
}

@

                i = data.find( "\n", spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i]
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1
                yield cword
                cword = ""
                continue</t>
<t tx="ekr.20070127142814.1552">else if( cwstring.equals( commenttokens[ 1 ] ) ){

    int i = data.indexOf( commenttokens[ 2 ], spot );
    String addon;
    if( i == -1 ) addon = data.substring( spot );
    else addon = data.substring( spot, i + commenttokens[ 2 ].length() );
    addPosition( beginspot - cword.length(), cword.charAt( 0 ) );
    if( i != -1 ) addPosition( i +( beginspot - spot ), commenttokens[ 2 ].charAt( 0 ) );
    
    cword.append( addon );
    if( i == -1 ) spot = beginspot = cdata.length +1;
    else{
    
        int addi = ( i - spot ) + commenttokens[ 2 ].length() -1;
        beginspot += addi;
        spot += addi;
    
    
    }
    String rv = cword.toString();
    cword = new StringBuilder();
    return rv;


}

@
i = data.find( ctokens[ 2 ], spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i + len( ctokens[ 2 ] ) ]
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                if i != -1:
                    self.addPosition( i , ctokens[ 2 ][ 0 ], doc )
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1
                yield cword
                cword = ""
                continue</t>
<t tx="ekr.20070127142814.1553">else if( cwstring.equals( commenttokens[ 2 ] ) ){

    addPosition( beginspot - commenttokens[ 2 ].length(), cwstring.charAt( 0 ) );
    cword = new StringBuilder();
    cword.append( z );
    return cwstring;

}</t>
<t tx="ekr.20070127142814.1554">else if( !Character.isLetterOrDigit( z ) ){

    String rv = cword.toString();
    if( (rv + z).equals( "@image " ) ){
    
        int endofline = data.indexOf( "\n", spot );
        String nwline = data.substring( spot , endofline );
        matcher.reset( nwline );
        if( matcher.find() ){
            //System.out.println( "FIND!!!!" );
            nwline = nwline.substring( matcher.start(), matcher.end() );
            //System.out.println( nwline );
        
        }
        rv +=  nwline;
        //System.out.println( "RV is:'" + rv + "'" );
        beginspot += nwline.length() -1;
        spot += nwline.length() -1;
        cword = new StringBuilder();
        return rv;
    
    }
    else if( (rv + z).equals( "@plugin " ) ){
    
        int endofline = data.indexOf( "\n", spot );
        String nwline = data.substring( spot , endofline );
        rv += nwline;
        beginspot += nwline.length() -1;
        spot += nwline.length() -1;
        cword = new StringBuilder();
        return rv;
    
    
    
    
    }
    cword = new StringBuilder();
    if( !ispossiblecomment( z ) ){
        yieldproxy.add( Character.toString( z )) ;
    
    }
    else cword.append( z );
    return rv;


}
</t>
<t tx="ekr.20070127142814.1555">@
def tokenize( self, data, beginspot):
    cword = ""
    spot = -1
    beginspot -= 1
    ignore = False
    doc = self.editor.getDocument()
    ctokens = self.cdeterminer.getCommentTokens()
    #print ctokens
    escaping = False
    for x in xrange( len(data) ):
        spot += 1
        beginspot += 1
        if spot &gt;= len( data ): break
        z = data[ spot ]
        #print z, cword
        if z == "\\" or escaping:
            #print "ESCAPE!!! %s" % cword
            if escaping:
                cword += z
                yield cword
                cword = ""
                escaping = False
                continue
            else:
                escaping = True
                cword += z
                continue
        if z in ( "@", '"',"'" ):
            self.addPosition( beginspot, z, doc )
        if z in ( '"', "'" ):
            yield cword
            cword = ""
            dspot = spot + 1
            while 1:
                #print "DSPOTIN!!!"
                i = data.find( z, dspot )
                if i != -1:
                    if data[ i -1 ] == "\\":
                        dspot = i + 1
                        if dspot &gt;= len( data ):
                            i == -1
                            break
                        continue
                    else: break
                else: break
            if i == -1:
                yield data[ spot: ]
                ignore = True
                break
            else:
                rv = data[ spot : i + 1 ]
                self.addPosition( beginspot + len( rv ) -1, z, doc )
                yield rv
                cword = ""
                spot += len( rv ) - 1
                beginspot += len( rv ) -1
                continue
        elif z == '&lt;':
            if spot &lt; len( data ):
                i = data.find( "&lt;&lt;", spot  )
                if i !=  spot:
                    yield cword
                    yield z
                    cword = ""
                    continue
                else:
                    i2 = data.find( "&gt;&gt;", spot )
                    if i2 == -1:
                        yield cword
                        yield z
                        cword = ""
                        continue
                    else:
                        rv = data[ i: i2 + 2 ]
                        yield cword
                        yield rv
                        spot += len( rv ) - 1
                        beginspot += len( rv ) - 1
                        cword = ""
                        continue
        elif cword.isspace() and not z.isspace():
            yield cword
            cword = ""
        elif z.isspace() and cword.isspace():
            pass
        elif z == '@' and cword == '':
            pass
        elif self.ispossiblecomment( cword, ctokens ) and self.ispossiblecomment( z , ctokens ):
            pass
        elif cword in ctokens and not self.ispossiblecomment( z, ctokens ):
            if cword == ctokens[ 0 ]:
                i = data.find( "\n", spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i]
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1
                yield cword
                cword = ""
                continue
            if cword == ctokens[ 1 ]:
                i = data.find( ctokens[ 2 ], spot )
                addon = ""
                if i == -1:
                    addon = data[ spot: ]
                else:
                    addon = data[ spot:i + len( ctokens[ 2 ] ) ]
                self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
                if i != -1:
                    self.addPosition( i , ctokens[ 2 ][ 0 ], doc )
                cword += addon
                if i == -1:
                    beginspot = len( data ) + 1
                else:
                    beginspot += len( addon ) -1
                    spot += len( addon ) -1
                yield cword
                cword = ""
                continue
            self.addPosition( ( beginspot - len( cword ) ), cword[ 0 ], doc )
            cword = ""
        elif not z.isalnum():
            yield cword
            if not self.ispossiblecomment( z, ctokens ):
                yield z
                cword = ""
                continue
            else:
                cword = ""
        cword += z
    if not ignore:
        yield cword
</t>
<t tx="ekr.20070127142814.1556">@language java
import java.util.*;
import java.io.File;

import java.awt.*;
import java.lang.reflect.InvocationTargetException;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import java.util.concurrent.*;


public class ColorizerRunnable implements Runnable{


    final JTextPane editor;
    final leoEditorKit2.ColorDeterminer cdeterminer;
    final public LinkedList&lt;PositionCarrier&gt; positions;
    final LinkedBlockingQueue&lt;java.util.List&gt; queue;
    final Comparator&lt;PositionCarrier&gt; compare;
    String[] commenttokens;
    static final String sr1 = "&lt;" + "&lt;";
    static final String sr2 = "&gt;" + "&gt;";
    Map&lt;String,Icon&gt; icons;
    Map&lt;String,JComponent&gt; plugins;

    public ColorizerRunnable( JTextPane editor, leoEditorKit2.ColorDeterminer cdeterminer, LinkedBlockingQueue&lt;java.util.List&gt; queue ){
    
        super();
        this.editor = editor;
        this.cdeterminer = cdeterminer;
        this.queue = queue;
        this.positions = new LinkedList&lt;PositionCarrier&gt;();
        compare = new PosComparator();
        icons = new HashMap&lt;String,Icon&gt;();
        plugins = new HashMap&lt;String,JComponent&gt;();
        //JPanel jp = new JPanel();
        //JScrollPane jsp = new JScrollPane( new JTree() );
        //jp.add( jsp );
        //EditorBackgroundMovie ebm = new EditorBackgroundMovie( "/home/brihar/Movies/BladeRunner/BR_DC.mpeg", jp );
        //plugins.put( "testplugin", jp );
        
    }
    
    static class PosComparator implements Comparator&lt;PositionCarrier&gt;{
    
        public int compare( PositionCarrier p1, PositionCarrier p2 ){
        
            int ip1 = p1.pos.getOffset();
            int ip2 = p2.pos.getOffset();
            if( ip1 &lt; ip2 ) return -1;
            else if ( ip1 &gt; ip2 ) return 1;
            return 0;
        
        
        }
    
        public boolean equals( Object o ){ return false; }
    
    }


    @others


}</t>
<t tx="ekr.20070127142814.1557">@others
</t>
<t tx="ekr.20070127142814.1558">static class Token{
    
    String data;
    AttributeSet sas;
    boolean ignore;
    Token( String data, AttributeSet sas ){
    
        this.data = data;
        this.sas = sas;
        ignore = false;
    }
        
    Token( String data ){
        
        this.data = data;
        ignore = true;
            
    }
        
    public boolean ignore(){ return ignore; }
        
        
    public String toString(){
        
        return data + ", " + sas + "\n";
        
    }
}</t>
<t tx="ekr.20070127142814.1559">class TokenRunnable extends Token implements Runnable{
    
    DefaultStyledDocument doc;
    int location;
    public TokenRunnable(  String data, AttributeSet set ){
        
        super( data, set );
        
    }
        
    public void setDocument( DefaultStyledDocument doc ){
        
        this.doc = doc;
        
    }
        
    public void setLocation( int location ){
        
        this.location = location;
        
    }
    
    public void run(){
        
        try{
            
            doc.replace( location, data.length(), data, sas );
        }
        catch( BadLocationException ble ){}
        
    }
    
}</t>
<t tx="ekr.20070127142814.1560">public void run(){

    while( true ){
    
    
        try{
        
            java.util.List l = queue.take();
            //System.out.println( l );
            //if( queue.size() &gt; 0 ) System.out.println( queue.size() );
            colorizeline( (Integer)l.get( 0 ), (Integer)l.get( 1 ), l.get( 2 ) );
        
        }
        catch( Exception x ){}
    
    
    }





}

@
        while 1:
            try:
                spots = []
                i = self.queue.take()
                spots.append( i )
                if self.queue.size():
                    self.queue.drainTo( spots )
                    spot1 = i[ 0 ]
                    length = i[ 1 ]
                    event = i[ 2 ]
                    for z in spots[ 1: ]:
                        if z[ 0 ] &lt; spot1:
                            spot1 = z[ 0 ]
                        else:
                            add = z[ 0 ] - spot1
                            add += z[ 1 ]
                            length += add
                    i = ( spot1, length, event )

                self.colorizeline( i )

            except java.lang.Exception, x:
                print x
                x.printStackTrace()</t>
<t tx="ekr.20070127142814.1561">public boolean ispossiblecomment( String word ){ 

    if( word.length() == 0 ) return false;
    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.startsWith( word ) ) return true;
    
    }
return false; 
@
    for z in comments:
        if z:
            if z.startswith( word ): return True
    return False
@c

}
public boolean ispossiblecomment( char c ){ 

    String word2 = Character.toString( c );
    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.startsWith( word2 ) ) return true;
    
    }
    return false; 


}

public boolean commentcontains( String word ){

    for( String s: commenttokens ){
        if( s == null ) return false;
        if( s.equals( word ) ) return true;
    
    }
    return false;

}</t>
<t tx="ekr.20070127142814.1562">public static class IgnoreRange{

    int start;
    int end;
    public IgnoreRange( int start, int end ){
    
        this.start = start;
        this.end = end;
        
    
    }
    
    public boolean spotafter( int spot ){
    
        return spot &gt;= end;
    
    
    }
    
    public boolean spotbefore( int spot ){
    
        return spot &lt; start;
    
    }
    
    public boolean spotignore( int spot ){
    
        if( spot &gt;= start &amp;&amp; spot &lt;= end ) return true;
        return false;
    
    }


}</t>
<t tx="ekr.20070127142814.1563">public void colorizeline( int begin, int length, Object type ){


    &lt;&lt;prolog&gt;&gt;
    JyLeoTokenizer jlt = new JyLeoTokenizer( line, start, commenttokens, doc, positions );
    for( String z: jlt ){
        //System.out.println("'" + z + "'" );
        &lt;&lt;docing&gt;&gt;
        &lt;&lt;string&gt;&gt;
        &lt;&lt;comment&gt;&gt;
        &lt;&lt;section reference&gt;&gt;
        &lt;&lt;else&gt;&gt;
    
    
        prevtoken = z; 
    
    
    }

    SimpleAttributeSet sas = new SimpleAttributeSet();
    StyleConstants.setForeground( sas, editor.getForeground() );
    //System.out.println( w_atts );
    if( positions.size() &gt; 0 ){
        Collections.sort( positions, compare );
        Iterator&lt;PositionCarrier&gt; pi = positions.iterator();
        while( pi.hasNext() ){
            PositionCarrier pc = pi.next();
            boolean ok = pc.isValid( doc );
            if( !ok ){
            
                pi.remove();
                int offset = pc.pos.getOffset();
                if( offset == begin &amp;&amp; type == DocumentEvent.EventType.REMOVE ){
        
                    Element re = doc.getParagraphElement( begin );
                    int start2 = re.getStartOffset();
                    colorizeline( start2, doc.getLength() - start2, null );
                    return;
        
                }
            
            }
            
        }     
        
    }
    int offset1 = -1;
    int offset2 = -1;
    int blength = begin + length;
    boolean ignorecolor = false;
    int ignorenum = -1;
    &lt;&lt;colorize positions&gt;&gt;
    //System.out.println( "IGNORE? " + ignorecolor );
    if( !ignorecolor ) color( start, w_atts, (leoEditorKit2.LeoDefaultStyledDocument)doc, sas, ignorenum );
        



}
@
for z in JyLeoTokenizer( line, start, comments, doc, self.positions ):
            #print "'%s'" % z
            if docing:
                if z != "@c":
                    w_atts.append( ( z, "p" ) )
                else:
                    docing = False
            if z.startswith( '"' ) or z.startswith( "'" ):
                w_atts.append( (  z , "p" ) )
            elif self.iscomment( z, comments ):
                w_atts.append( ( z, "p" ) )
            elif z.startswith( sr1 ) and z.endswith( sr2 ):
                guts = z[ 2: -2 ]
                outer = ctokens.get( "&lt;" + "&lt;" )
                if sec_refs.containsKey( guts ):
                    scolor = self.cdeterminer.getSectionReferenceColor()
                else:
                    scolor = self.cdeterminer.getUndefinedSectionReferenceColor()
                w_atts.append( ( sr1, outer ) )
                w_atts.append( ( guts, scolor ) )
                w_atts.append( ( sr2, outer ) )
            else:
                if z.isspace() or not ctokens.containsKey( z ):
                    if z in string.punctuation:
                        w_atts.append( ( z, self.cdeterminer.getPunctuationColor() ) )
                    elif z.isspace():
                        w_atts.append(( z, "p" ))
                    elif z.isnumeric():
                        nsas = stext.SimpleAttributeSet()
                        stext.StyleConstants.setForeground( nsas, java.awt.Color.ORANGE )
                        w_atts.append( ( z, nsas ) )
                    else:
                        w_atts.append( ( z, None ) )
                else:
                    w_atts.append( ( z, ctokens.get( z ) ) )
                    if z == "@" and prevtoken.endswith( "\n" ): docing = True
            prevtoken = z
</t>
<t tx="ekr.20070127142814.1564">    final leoEditorKit2.LeoDefaultStyledDocument doc = (leoEditorKit2.LeoDefaultStyledDocument)editor.getDocument();
    Map&lt;String,AttributeSet&gt; ctokens = cdeterminer.getColoredTokens();
    Element e = doc.getParagraphElement( begin );
    Element e2 = doc.getParagraphElement( begin + length );
    final int start = e.getStartOffset();
    final int end = e2.getEndOffset();
    String line = "";
    try{
        line = doc.getText( start, end - start );
    }
    catch( BadLocationException ble ){ return; }
    java.util.List&lt;Token&gt; w_atts = new ArrayList&lt;Token&gt;();
    //String sr1 = "&lt;" + "&lt;";
    //String sr2 = "&gt;" + "&gt;";
    final Map sec_refs = doc._srs;
    commenttokens = cdeterminer.getCommentTokens();
    boolean docing = false;
    String prevtoken = "\n";


@
        dtype = spots[ 2 ]
        begin = spots[ 0 ]
        ctokens = self.cdeterminer.getColoredTokens()
        e = stext.Utilities.getParagraphElement( self.editor, begin )
        e2 = stext.Utilities.getParagraphElement( self.editor, spots[ 0 ] + spots[ 1 ] )
        start = e.getStartOffset()
        end = e2.getEndOffset()
        doc = self.editor.getDocument()
        line = doc.getText( start, end - start )
        w_atts = []
        sr1 = "&lt;" + "&lt;"
        sr2 = "&gt;" + "&gt;"
        sec_refs = doc._srs
        comments = self.cdeterminer.getCommentTokens()
        docing = False
        prevtoken = "\n"</t>
<t tx="ekr.20070127142814.1565">if( docing ){
    
    w_atts.add( new Token( z ) );
    if( z.equals( "@c" ) ) docing = false;
    prevtoken = z;
    continue;

}



@
            if docing:
                if z != "@c":
                    w_atts.append( ( z, "p" ) )
                else:
                    docing = False</t>
<t tx="ekr.20070127142814.1566">if( z.startsWith ( "\"" ) || z.startsWith( "'" ) )
    w_atts.add( new Token( z ) );

@
            if z.startswith( '"' ) or z.startswith( "'" ):
                w_atts.append( (  z , "p" ) )</t>
<t tx="ekr.20070127142814.1567">else if( iscomment( z, commenttokens ) ) w_atts.add( new Token( z  ) );

@
            elif self.iscomment( z, comments ):
                w_atts.append( ( z, "p" ) )</t>
<t tx="ekr.20070127142814.1568">else if( z.startsWith( sr1 ) &amp;&amp; z.endsWith( sr2 ) ){

    String guts = z.substring( 2, z.length() - 2 );
    AttributeSet outer = ctokens.get( "&lt;" + "&lt;" );
    AttributeSet scolor;
    if( sec_refs.containsKey( guts ) )
        scolor = cdeterminer.getSectionReferenceColor();
    else
        scolor = cdeterminer.getUndefinedSectionReferenceColor();

    w_atts.add( new Token( sr1, outer ) );
    w_atts.add( new Token( guts, scolor ) );
    w_atts.add( new Token( sr2, outer ) );


}


@
            elif z.startswith( sr1 ) and z.endswith( sr2 ):
                guts = z[ 2: -2 ]
                outer = ctokens.get( "&lt;" + "&lt;" )
                if sec_refs.containsKey( guts ):
                    scolor = self.cdeterminer.getSectionReferenceColor()
                else:
                    scolor = self.cdeterminer.getUndefinedSectionReferenceColor()
                w_atts.append( ( sr1, outer ) )
                w_atts.append( ( guts, scolor ) )
                w_atts.append( ( sr2, outer ) )</t>
<t tx="ekr.20070127142814.1569">else{

    if( isspace( z ) || ! ctokens.containsKey( z ) ){
        if( z.startsWith( "@image " ) ){
            SimpleAttributeSet sas = new SimpleAttributeSet();
            String[] pieces = z.split( "\\s+" );
            if( pieces.length &gt;= 2 ){
            
                String path = pieces[ 1 ];
                File test = new File( path );
                if( !icons.containsKey( path ) &amp;&amp; test.exists() &amp;&amp; test.isFile() ){
                    
                    try{
                      
                        ImageIcon ii = new ImageIcon( path );
                        icons.put( path, ii );
 
                    }
                    catch( Exception x ){ x.printStackTrace(); }
                
                }
                if( icons.containsKey( path ) ){
                
                    StyleConstants.setIcon( sas, icons.get( path ) );
                
                }
            
            
            }
            Token itoken = new TokenRunnable( z, sas );
            w_atts.add( itoken );
        
        }
        &lt;&lt;plugins&gt;&gt;
        else if( !isletterdigit( z ) ) w_atts.add( new Token( z, cdeterminer.getPunctuationColor() ) );
        else if( isspace( z ) ) w_atts.add( new Token( z  )); 
        else if( isnumeric( z ) ) w_atts.add( new Token( z, cdeterminer.getNumericColor() ) );
        else w_atts.add( new Token( z, null ) );
    
    
    }
    else{
    
        w_atts.add( new Token( z, ctokens.get( z ) ) );
        if( z.equals( "@" ) &amp;&amp; prevtoken.equals( "\n" ) ) docing = true;
        
        }


}


@
            else:
                if z.isspace() or not ctokens.containsKey( z ):
                    if z in string.punctuation:
                        w_atts.append( ( z, self.cdeterminer.getPunctuationColor() ) )
                    elif z.isspace():
                        w_atts.append(( z, "p" ))
                    elif z.isnumeric():
                        nsas = stext.SimpleAttributeSet()
                        stext.StyleConstants.setForeground( nsas, java.awt.Color.ORANGE )
                        w_atts.append( ( z, nsas ) )
                    else:
                        w_atts.append( ( z, None ) )
                else:
                    w_atts.append( ( z, ctokens.get( z ) ) )
                    if z == "@" and prevtoken.endswith( "\n" ): docing = True
</t>
<t tx="ekr.20070127142814.1570">else if( z.startsWith( "@plugin " ) ){
    SimpleAttributeSet sas = new SimpleAttributeSet();
    String[] pieces = z.split( "\\s+" );
    if( pieces.length &gt;= 2 ){
            
        String plugin = pieces[ 1 ];
     
        if( plugins.containsKey( plugin ) ){
            
            StyleConstants.setComponent( sas, plugins.get( plugin ) );
                
        }
    
    }
    Token itoken = new TokenRunnable( z, sas );
    w_atts.add( itoken );
        
}</t>
<t tx="ekr.20070127142814.1571">//if( positions.size() == 0 ) return;
//System.out.println( positions );
AttributeSet scolor = cdeterminer.getStringColor();
AttributeSet scolor2 = cdeterminer.getDocColor();
AttributeSet commentcolor = cdeterminer.getCommentColor();
String coloring = null;
int colorstart = -1;
int ignore1 = -1;
int ignore2 = -1;
java.util.List&lt;Integer&gt; offsets = new ArrayList&lt;Integer&gt;();
&lt;&lt;iterate&gt;&gt;</t>
<t tx="ekr.20070127142814.1572">for( PositionCarrier z: positions ){

    //System.out.println( z );
    &lt;&lt;part1&gt;&gt;
    &lt;&lt;part2&gt;&gt;


}
&lt;&lt;finish coloring&gt;&gt;</t>
<t tx="ekr.20070127142814.1573">try{

    int offset = z.pos.getOffset();
    if( offset &gt; end &amp;&amp; coloring == null ) break;
    //String item = doc.getText( offset, 1 );
    /*if( !z.isValid( doc ) ){
        positions.remove( z );
        if( offset == begin &amp;&amp; type == DocumentEvent.EventType.REMOVE ){
        
            int start2 = Utilities.getRowStart( editor, begin );
            colorizeline( start2, doc.getLength() - start2, null );
            return;
        
        }
        continue;
    
    }*/
    if( offsets.contains( offset ) ){
        positions.remove( z );
        if( offset == begin &amp;&amp; type == DocumentEvent.EventType.REMOVE ){
            Element er = doc.getParagraphElement( begin );
            int start2 = er.getStartOffset();
            colorizeline( start2, doc.getLength() - start2, null );
            return;       
        }
        continue;
    
    }
    offsets.add( offset );


}
catch( Exception x ){ 
    positions.remove( z ); 
    continue;    
}


@
            try:
                offset = z[ 0 ].getOffset()
                if offset &gt; end and not coloring:
                    #print "RETURNING!!!!!"
                    return
                item = doc.getText( z[ 0 ].getOffset(), 1 )
                if item != z[ 1 ]:
                    self.positions.remove( z )
                    if z[ 0 ].getOffset() == spots[ 0 ] and dtype == sevent.DocumentEvent.EventType.REMOVE:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None ))
                    continue
                if z[ 0 ].getOffset() in offsets:
                    self.positions.remove( z )
                    if dtype == sevent.DocumentEvent.EventType.REMOVE and z[ 0 ].getOffset() == spots[ 0 ]:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None ))
                    continue
                offsets.append( z[ 0 ].getOffset() )
            except java.lang.Exception, x:
                self.positions.remove( z )
                continue</t>
<t tx="ekr.20070127142814.1574">if( coloring == null ){

    coloring = z.c;
    colorstart = z.pos.getOffset();
    if( colorstart &gt; ignore1 &amp;&amp; colorstart &lt; ignore2 ){
        coloring = null;
        continue;
    
    }
    

    &lt;&lt;handle possible doc&gt;&gt;
    &lt;&lt;handle possible comment&gt;&gt;
    continue;
}
&lt;&lt;handle string&gt;&gt;
&lt;&lt;finish coloring doc&gt;&gt;
&lt;&lt;finish coloring comment&gt;&gt;


</t>
<t tx="ekr.20070127142814.1575">//System.out.println( "COLRING2:" + coloring );
if( coloring.equals( "@" ) ){

    try{
        //int end2 = Utilities.getWordEnd( editor, colorstart + 1 );
        Element wend = doc.getParagraphElement( colorstart + 1 );
        String test = doc.getText( colorstart + 1, wend.getEndOffset() - ( colorstart + 1 ) );
        String[] tokens = test.split( "\\s", 2 );
        int end2 = colorstart + 1 + tokens[ 0 ].length();
        Element para = doc.getParagraphElement( colorstart );
        int start2 = para.getStartOffset();
        String txt = doc.getText( colorstart, end2 - colorstart ).trim();
        //System.out.println( "TEXT IS:" + txt );
        if( !txt.equals( "@" ) || start2 != colorstart ){
            coloring = null;
            //System.out.println ("NO COLORING!!" + txt );
            if( colorstart + 1 == begin &amp;&amp; type == DocumentEvent.EventType.REMOVE ){
                colorizeline(  colorstart, doc.getLength() - colorstart, null );
                return;
        
            }
    
    
        }
    }
    catch( BadLocationException ble ){}

}

@
if coloring == '@':
                    end2 = stext.Utilities.getWordEnd( self.editor, colorstart + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, colorstart )
                    txt = doc.getText( colorstart , end2 - colorstart )
                    if txt.strip() not in ( "@", ) or start2 != colorstart:
                        coloring = None
                        if dtype == sevent.DocumentEvent.EventType.INSERT and colorstart + 1 == spots[ 0 ]:
                            return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )</t>
<t tx="ekr.20070127142814.1576">else if( coloring != null &amp;&amp; ispossiblecomment( coloring ) ){
    
    try{   
        int l1 = commenttokens[ 0 ].length();
        String txt = doc.getText( colorstart, l1 );
        if( txt.equals( commenttokens[ 0 ] ) ){
    
            Element pe = doc.getParagraphElement( colorstart );
            int end2 = pe.getEndOffset();
            doc.setCharacterAttributes( colorstart, end2 - colorstart, commentcolor, true );
            if( begin &gt;= colorstart &amp;&amp; blength &lt;= end2 ) ignorecolor = true;
            ignore1 = colorstart; ignore2 = end2;
            coloring = null;
    
    
        }
        else if ( txt.equals( commenttokens[ 1 ] )  );
        else coloring = null;
    }
    catch( BadLocationException ble ){ return; }

}



@
elif coloring and self.ispossiblecomment( coloring, comments ):
                    l1 = len( comments[ 0 ] )
                    txt = doc.getText( colorstart, l1 )
                    if txt == comments[ 0 ]:
                        e = stext.Utilities.getParagraphElement( self.editor, colorstart )
                        end2 = e.getEndOffset()
                        doc.setCharacterAttributes( colorstart, end2 - colorstart, commentcolor, 1 )
                        ignore1 = colorstart;ignore2 = end2
                        coloring = None
                    elif txt == comments[ 1 ]:
                        pass
                    else:
                        coloring = None</t>
<t tx="ekr.20070127142814.1577">if( coloring.equals( "\"" ) || coloring.equals( "'" ) ){

    if( z.c.equals( coloring ) ){

            //System.out.println( "HANDLING COLORING!!" );
            int eoffset = z.pos.getOffset();
            int emarker = doc.getParagraphElement( eoffset ).getEndOffset();
            Element cs = doc.getCharacterElement( colorstart );
            Element ce = doc.getCharacterElement( eoffset );
            //try{
            //System.out.println( doc.getText( colorstart, eoffset + 1 - colorstart ) );
            //}
            //catch( BadLocationException ble ){}
            if( cs.getAttributes().isEqual( scolor ) &amp;&amp; ce.getAttributes().isEqual( scolor ) &amp;&amp;
                ( blength &lt; colorstart || begin &gt; emarker ));
            else doc.setCharacterAttributes( colorstart, eoffset + 1 - colorstart, scolor, true );
            if( begin &gt;= colorstart &amp;&amp; blength &lt;= eoffset ) ignorecolor = true;
            if( eoffset &lt; begin &amp;&amp; begin &lt; emarker ) ignorenum = eoffset;
            coloring = null;
            if( eoffset == begin &amp;&amp; type == DocumentEvent.EventType.INSERT ){
                colorizeline( colorstart, doc.getLength() - colorstart, null );
                return;
        
            }

    
    }

}


@
            if coloring in ( "'", '"' ):
                if z[ 1 ] == coloring:
                    eoffset = z[ 0 ].getOffset()
                    emarker = stext.Utilities.getRowEnd( self.editor, eoffset )
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( eoffset )
                    if cs.getAttributes().isEqual( scolor )\
                    and ce.getAttributes().isEqual( scolor )\
                    and ( begin &lt; colorstart or begin &gt; emarker ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, eoffset + 1  - colorstart, scolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and eoffset == spots[ 0 ]:
                        return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )</t>
<t tx="ekr.20070127142814.1578">else if( coloring.equals( "@" ) ){

    try{
    
        int offset = z.pos.getOffset();
        //int end2 = Utilities.getWordEnd( editor, offset + 1 );
        Element para = doc.getParagraphElement( offset );
        int start2 = para.getStartOffset();
        String text = doc.getText( start2, para.getEndOffset() - start2 );
        String[] linesplit = text.split( "\\s", 2 );
        int end2 = start2 + linesplit[ 0 ].length();
        if( start2 == offset ){
            String txt = doc.getText( start2, end2 - start2 ).trim();
            if( txt.equals( "@c" ) ){
                
                Element cs = doc.getCharacterElement( colorstart + 1 );
                Element ce = doc.getCharacterElement( offset -1 );
                if( begin &gt;= colorstart &amp;&amp; blength &lt;= end2 ) ignorecolor = true;
                if( cs.getAttributes().isEqual( scolor2 ) &amp;&amp; ce.getAttributes().isEqual( scolor2 ) &amp;&amp;
                    ( blength &lt; colorstart || begin &gt; end2 ) );
                else{
                    
                    if( colorstart &lt; begin ){ 
                        Element pg = doc.getParagraphElement( begin );
                        if( type == DocumentEvent.EventType.INSERT ){
                            int starto = pg.getStartOffset();
                            int endo = pg.getEndOffset();
                            doc.setCharacterAttributes( starto, endo - starto , scolor2, true );

                        }
                        else{
                    
                            int starto = pg.getStartOffset();
                            doc.setCharacterAttributes( starto, ce.getStartOffset() - starto, scolor2, true );
                            
                        }
                    }
                    else{
                     doc.setCharacterAttributes( cs.getStartOffset(), ce.getEndOffset() - cs.getStartOffset(), scolor2, true );
                     
                    }
                    if( ctokens.containsKey( txt ) ){
                        AttributeSet dsas = ctokens.get( txt );
                        doc.setCharacterAttributes( offset, 2, dsas, true );
                        doc.setCharacterAttributes( colorstart, 1, dsas, true );
                    }
                }
                coloring = null;
                if( start2 + 1 == begin &amp;&amp; type == DocumentEvent.EventType.INSERT ){
                    colorizeline(  start2, doc.getLength() - start2, null );
                    return;
            
                }
            }
        
        
        
        
        }
    
    
    
    }
    catch( BadLocationException ble ){}




}



@
elif coloring in( "@", ):
                try:
                    offset = z[ 0 ].getOffset()
                    end2 = stext.Utilities.getWordEnd( self.editor, offset + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, offset )
                    if start2 == offset:
                        txt = doc.getText( start2 , end2 - start2 )
                        if txt.strip() in ("@c", ):
                            cs = doc.getCharacterElement( colorstart + 1 )
                            ce = doc.getCharacterElement( offset )
                            if cs.getAttributes().isEqual( scolor2 )\
                            and ce.getAttributes().isEqual( scolor2 )\
                            and ( begin &lt; colorstart or begin &gt; end2 ):
                                pass
                            else:
                                doc.setCharacterAttributes( colorstart + 1, offset - colorstart -1, scolor2, 1 )
                            coloring = None
                            if dtype == sevent.DocumentEvent.EventType.INSERT and start2 + 1 == spots[ 0 ]:
                                return self.colorizeline( ( start2, doc.getLength() - start2, None ) )
                except java.lang.Exception, x:
                    pass</t>
<t tx="ekr.20070127142814.1579">else if( coloring != null &amp;&amp; ispossiblecomment( coloring ) ){

    try{
        String cend = commenttokens[ 2 ];
        int offset = z.pos.getOffset();
        String txt = doc.getText( offset, cend.length() );
        //System.out.println( txt );
        if( txt.equals( cend ) ){
    
            Element cs = doc.getCharacterElement( colorstart );
            Element ce = doc.getCharacterElement( offset + cend.length() );
            if( begin &gt;= colorstart &amp;&amp; blength &lt;= offset ) ignorecolor = true;
            if( cs.getAttributes().isEqual( commentcolor ) &amp;&amp; ce.getAttributes().isEqual( commentcolor ) &amp;&amp;
                ( blength &lt; colorstart || begin &gt; offset ) );
            else
                doc.setCharacterAttributes( colorstart, ( offset + cend.length() ) -colorstart, commentcolor, true );
            coloring = null;
            if( ( offset &lt;= begin &amp;&amp; offset + cend.length() &gt;= begin ) &amp;&amp; type == DocumentEvent.EventType.INSERT ){
                colorizeline( offset, doc.getLength() - offset, null );
                return;
        
            }
    
        }
    }
    catch( BadLocationException ble ){ return; }


}




@
elif coloring and self.ispossiblecomment( coloring, comments ):
                cend = comments[ 2 ]
                offset = z[ 0 ].getOffset()
                txt = doc.getText( offset, len( cend ) )
                if txt == cend:
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( offset + len( cend ) )
                    if cs.getAttributes().isEqual( commentcolor )\
                    and ce.getAttributes().isEqual( commentcolor )\
                    and ( begin &lt; colorstart or begin &gt; offset ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, (offset + len( cend ) ) -colorstart, commentcolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and ( offset &lt;= spots[ 0 ] and offset + len( cend ) &gt;= spots[ 0 ] ):
                        return self.colorizeline( ( offset, doc.getLength() - offset, None ) )
</t>
<t tx="ekr.20070127142814.1580">if( coloring != null ){

    if( coloring.equals( "\"" ) || coloring.equals( "'" ) );
    else if( coloring.equals( "@" ) ){
        
        colorstart += 1;
        scolor = scolor2;
    
    
    }
    else scolor = commentcolor;
    doc.setCharacterAttributes( colorstart, doc.getLength() - colorstart, scolor, true );
    if( colorstart &lt;= begin ) ignorecolor = true;

}</t>
<t tx="ekr.20070127142814.1581">@
        copyofp = copy.copy( self.positions )
        #print copyofp.__class__
        copyofp.sort( self.sortp )
        scolor = self.cdeterminer.getStringColor()
        scolor2 = self.cdeterminer.getDocColor()
        coloring = None
        colorstart = -1
        #print self.positions
        offsets = []
        comments = self.cdeterminer.getCommentTokens()
        commentcolor = self.cdeterminer.getCommentColor()
        #copyofp = copy.copy( self.positions )


        ignore1 = ignore2 = -1
        #print copyofp
        for z in copyofp:
            try:
                offset = z[ 0 ].getOffset()
                if offset &gt; end and not coloring:
                    #print "RETURNING!!!!!"
                    return
                item = doc.getText( z[ 0 ].getOffset(), 1 )
                if item != z[ 1 ]:
                    self.positions.remove( z )
                    if z[ 0 ].getOffset() == spots[ 0 ] and dtype == sevent.DocumentEvent.EventType.REMOVE:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None ))
                    continue
                if z[ 0 ].getOffset() in offsets:
                    self.positions.remove( z )
                    if dtype == sevent.DocumentEvent.EventType.REMOVE and z[ 0 ].getOffset() == spots[ 0 ]:
                        start = stext.Utilities.getRowStart( self.editor, spots[ 0 ] )
                        return self.colorizeline( ( start, doc.getLength() - start, None ))
                    continue
                offsets.append( z[ 0 ].getOffset() )
            except java.lang.Exception, x:
                self.positions.remove( z )
                continue
            if not coloring:
                coloring = z[ 1 ]
                colorstart = z[ 0 ].getOffset()
                if colorstart &gt; ignore1 and colorstart &lt; ignore2:
                    #print "IGNORING %s" % coloring
                    coloring = None
                    continue
                if coloring == '@':
                    end2 = stext.Utilities.getWordEnd( self.editor, colorstart + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, colorstart )
                    txt = doc.getText( colorstart , end2 - colorstart )
                    if txt.strip() not in ( "@", ) or start2 != colorstart:
                        coloring = None
                        if dtype == sevent.DocumentEvent.EventType.INSERT and colorstart + 1 == spots[ 0 ]:
                            return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )
                elif coloring and self.ispossiblecomment( coloring, comments ):
                    l1 = len( comments[ 0 ] )
                    txt = doc.getText( colorstart, l1 )
                    if txt == comments[ 0 ]:
                        e = stext.Utilities.getParagraphElement( self.editor, colorstart )
                        end2 = e.getEndOffset()
                        doc.setCharacterAttributes( colorstart, end2 - colorstart, commentcolor, 1 )
                        ignore1 = colorstart;ignore2 = end2
                        coloring = None
                    elif txt == comments[ 1 ]:
                        pass
                    else:
                        coloring = None
                continue
            if coloring in ( "'", '"' ):
                if z[ 1 ] == coloring:
                    eoffset = z[ 0 ].getOffset()
                    emarker = stext.Utilities.getRowEnd( self.editor, eoffset )
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( eoffset )
                    if cs.getAttributes().isEqual( scolor )\
                    and ce.getAttributes().isEqual( scolor )\
                    and ( begin &lt; colorstart or begin &gt; emarker ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, eoffset + 1  - colorstart, scolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and eoffset == spots[ 0 ]:
                        return self.colorizeline( ( colorstart, doc.getLength() - colorstart, None ) )
            elif coloring in( "@", ):
                try:
                    offset = z[ 0 ].getOffset()
                    end2 = stext.Utilities.getWordEnd( self.editor, offset + 1 )
                    start2 = stext.Utilities.getRowStart( self.editor, offset )
                    if start2 == offset:
                        txt = doc.getText( start2 , end2 - start2 )
                        if txt.strip() in ("@c", ):
                            cs = doc.getCharacterElement( colorstart + 1 )
                            ce = doc.getCharacterElement( offset )
                            if cs.getAttributes().isEqual( scolor2 )\
                            and ce.getAttributes().isEqual( scolor2 )\
                            and ( begin &lt; colorstart or begin &gt; end2 ):
                                pass
                            else:
                                doc.setCharacterAttributes( colorstart + 1, offset - colorstart -1, scolor2, 1 )
                            coloring = None
                            if dtype == sevent.DocumentEvent.EventType.INSERT and start2 + 1 == spots[ 0 ]:
                                return self.colorizeline( ( start2, doc.getLength() - start2, None ) )
                except java.lang.Exception, x:
                    pass
            elif coloring and self.ispossiblecomment( coloring, comments ):
                cend = comments[ 2 ]
                offset = z[ 0 ].getOffset()
                txt = doc.getText( offset, len( cend ) )
                if txt == cend:
                    cs = doc.getCharacterElement( colorstart )
                    ce = doc.getCharacterElement( offset + len( cend ) )
                    if cs.getAttributes().isEqual( commentcolor )\
                    and ce.getAttributes().isEqual( commentcolor )\
                    and ( begin &lt; colorstart or begin &gt; offset ):
                        pass
                    else:
                        doc.setCharacterAttributes( colorstart, (offset + len( cend ) ) -colorstart, commentcolor, 1 )
                    coloring = None
                    if dtype == sevent.DocumentEvent.EventType.INSERT and ( offset &lt;= spots[ 0 ] and offset + len( cend ) &gt;= spots[ 0 ] ):
                        return self.colorizeline( ( offset, doc.getLength() - offset, None ) )
        if coloring:
            if coloring in ( "'", '"' ):
                pass
            elif coloring == "@":
                colorstart += 1
                scolor = scolor2
            else:
                scolor = commentcolor
            doc.setCharacterAttributes( colorstart, doc.getLength() - colorstart, scolor, 1 )</t>
<t tx="ekr.20070127142814.1582">public void color( int spot, java.util.List&lt;Token&gt; c_atts, final leoEditorKit2.LeoDefaultStyledDocument doc, AttributeSet bsas, int ignore ){
    
    for( Token z: c_atts ){
        final int size = z.data.length();
        if( !z.ignore() &amp;&amp; spot &gt; ignore ){
            final AttributeSet sas;
            if( z.sas != null ) sas = z.sas;
            else sas = bsas;
            Element cs = doc.getCharacterElement( spot );
            Element ce = doc.getCharacterElement( spot + size -1 );
            if( !(cs.getAttributes().isEqual( sas ) &amp;&amp; ce.getAttributes().isEqual( sas ) ) ){

                if( z instanceof TokenRunnable ){
                
                    TokenRunnable tr = (TokenRunnable)z;
                    tr.setLocation( spot );
                    tr.setDocument( doc );
                    try{
                        if( EventQueue.isDispatchThread() ) tr.run();
                        else
                            SwingUtilities.invokeAndWait( tr );
                    }
                    catch( InterruptedException ie ){}
                    catch( InvocationTargetException ie ){}
                    
                }
                else doc.setCharacterAttributes( spot, size, sas, true );

            }
        
        }
        spot += size;
    
    
    }





}





@
def color( self, spot, c_atts, doc, bsas ):

    for z in c_atts:
        size = len( z[ 0 ] )
        #print "COLOR:'%s', %s, '%s', %s" % (z[ 0 ], self.spot, self.doc.getText( self.spot, size ) , size )
        sas = z[ 1 ]
        if not sas: sas = bsas
        try:
            cs = doc.getCharacterElement( spot )
            ce = doc.getCharacterElement( spot + size -1 )
            if sas != "p" and not ( cs.getAttributes().isEqual( sas ) and ce.getAttributes().isEqual( sas ) ):
                doc.setCharacterAttributes( spot, size, sas , 1 )
            #else:
            #    print "pass %s" % sas
        except java.lang.Exception:
            pass
        spot += size
</t>
<t tx="ekr.20070127142814.1583">public boolean isspace( String s ){

    for( char c: s.toCharArray() ){
    
        if( !Character.isWhitespace( c ) ) return false;
    
    
    }

    return true;

}

public boolean isnumeric( String s ){

    for( char c: s.toCharArray() ){
    
        if( !Character.isDigit( c ) ) return false;
    
    
    }

    return true;



}


public boolean isletterdigit( String s ){

    for( char c: s.toCharArray() ){
    
        if( Character.isLetterOrDigit( c ) || Character.isWhitespace( c ) ) continue;
        return false;
    
    }

    return true;



}

public boolean iscomment( String word, String[] comments ){

    for( String s: comments ){
        
        if( s == null ) return false;
        else if( word.startsWith( s ) ) return true;
    
    }

    return false;

}</t>
<t tx="ekr.20070127142814.1584">@
public static class ImmutableAttributeSet implements AttributeSet{

    AttributeSet guts;
    public ImmutableAttributeSet( AttributeSet guts ){
        this.guts = guts;
    }
	public boolean containsAttribute(Object name, Object value){
        return guts.containsAttribute( name, value );
    }
    public boolean containsAttributes(AttributeSet attributes){
        return guts.containsAttributes( attributes );
    }





}</t>
<t tx="ekr.20070127142814.1585">@language java
import javax.swing.text.*;


public class PositionCarrier{
    public Position pos;
    public String c;
    public PositionCarrier( Position pos, String c ){
    
        this.pos = pos;
        this.c = c;
    
    
    }
    
    public String toString(){
    
        return pos + ", " + c;
    
    }
    
    public boolean equals( Object o ){
    
        if( o == null || !(o instanceof PositionCarrier) ) return false;
        PositionCarrier pc = (PositionCarrier)o;
        return pos.getOffset() == pc.pos.getOffset() &amp;&amp; c.equals( pc.c );
    
    }
    
    public boolean isValid( Document doc ){
    
        try{
            String text = doc.getText( pos.getOffset(), 1 );
            return text.equals( c );      
        }
        catch( BadLocationException ble ){}
        return false;
    
    }




}</t>
<t tx="ekr.20070127142814.1586">@language java
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.*;
import java.lang.ref.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.awt.image.*;
import static java.lang.System.*;

public class leoEditorKit2 extends StyledEditorKit{

    
    public leoEditorKit2( JTextPane jtp, ColorDeterminer cd, ImageIcon ii ){
    
        super();
        vf = new StyledViewFactory2( jtp, cd, ii );
    
    }
    
    
    public void setLineWrap( boolean wrap ){
    
        vf.setLineWrap( wrap );
    
    }
    
    public boolean getLineWrap(){
    
        return vf.getLineWrap();
    
    
    }
    
    public Border getBorder(){
    
        LineNumberBorder lnb = new LineNumberBorder( vf.root );
        vf.root.border = lnb;
        return lnb;
    
    }
    
    public Document createDefaultDocument(){
    
        return new LeoDefaultStyledDocument();
    
    }
    
    
    public void fold( Element e ){
    
        vf.fold( e );
    
    }
    
    public void unfold( Element e ){
    
        vf.unfold( e );
    
    }
    
    public void unfold( Position p1, Position p2 ){
    
        vf.unfold( p1, p2 );
    
    
    }
    
    
    public void defoldViews(){
    
        vf.defoldViews();
    
    }
    
    public void fold( Position p1, Position p2 ){
    
        vf.fold( p1, p2 );
    
    }

    public void topfold( Element e ){
    
        vf.topfold( e );
    
    }
    
    public void relayout(){
    
        vf.relayout();
        
    
    }
    
    public boolean isFolded( int x, int y ){
    
        return vf.isFolded( x, y );
    
    }
    
    public int getFoldIconX(){
    
        return vf.getFoldIconX();
    
    }
    
    
    public void showInvisibles( boolean show ){
    
        vf.showInvisibles( show );
    
    }
    
    
    static StyledViewFactory2 vf;// = new StyledViewFactory2();

    public ViewFactory getViewFactory(){
    
        return vf;
    
    }
static class StyledViewFactory2 implements ViewFactory {

        JTextPane jtp;
        ColorDeterminer cd;
        NoWrapBoxView root;
        ImageIcon ii;
        public StyledViewFactory2( JTextPane jtp, ColorDeterminer cd, ImageIcon ii ){
        
            super();
            this.jtp = jtp;
            this.cd = cd;
            this.ii = ii;
        
        }
        
        &lt;&lt;fold methods&gt;&gt;
        
        public void setLineWrap( boolean wrap ){
        
            root.setLineWrap( wrap );
        
        
        }
        
        public boolean getLineWrap(){
        
        
            return root.getLineWrap();
            
        
        }
        
        
        public void showInvisibles( boolean show ){
        
            root.show_invisibles = show;
        
        
        }
        
        public void relayout(){
        
            if( root != null ){
                 root.layoutChanged( View.Y_AXIS );
                 root.layoutChanged( View.X_AXIS );
                 jtp.repaint();    
                
            }
        
        }
        
        
        &lt;&lt;create&gt;&gt;
    
        

}

    @others
    
    
}</t>
<t tx="ekr.20070127142814.1587">public int getFoldIconX(){
        
    return ii.getIconWidth() + root.getLeftInset();
        
        
}

public void fold( Element e ){ 
    
    root.resetLineNumbers();
    int i = root.getViewIndexAtPosition( e.getStartOffset() );
    FoldableParagraphView pv = (FoldableParagraphView)root.getView( i );
    pv.fold();
        
        
}
        
public void unfold( Element e ){
    
    root.resetLineNumbers();
    int i = root.getViewIndexAtPosition( e.getStartOffset() );
    FoldableParagraphView pv = (FoldableParagraphView)root.getView( i );
    pv.unfold();   
        
}
        
public void defoldViews(){
    
    root.resetLineNumbers();
    for( int i = 0; i &lt; root.getViewCount(); i++ ){
            
        View v = root.getView( i );
        if( v instanceof FoldableParagraphView ){
                
            FoldableParagraphView pv = (FoldableParagraphView)v;
            pv.unfold();
                
        }
    }
}
        
public void unfold( Position p1, Position p2 ){
        
    DefaultStyledDocument dsd = (DefaultStyledDocument)jtp.getDocument();
    Element start = dsd.getParagraphElement( p1.getOffset() );
    Element end = dsd.getParagraphElement( p2.getOffset() );
    ElementIterator ei = new ElementIterator( dsd );
    boolean unfolding = false;
    while( true ){
        
        Element e = ei.next();
        if( e == start ) unfolding = true;
        if( unfolding &amp;&amp; e.getClass() == start.getClass() ) unfold( e );
        if( e == end ) break;
        
    }
    relayout();
        
}
        
public void fold( Position p1, Position p2 ){
    
    DefaultStyledDocument dsd = (DefaultStyledDocument)jtp.getDocument();
    Element start = dsd.getParagraphElement( p1.getOffset() );
    Element end = dsd.getParagraphElement( p2.getOffset() );
    ElementIterator ei = new ElementIterator( dsd );
    boolean unfolding = false;
    while( true ){
        
        Element e = ei.next();
        if( e == start ) unfolding = true;
        if( unfolding &amp;&amp; e.getClass() == start.getClass() ){
                 
        if( e == start ) topfold(e);
        else fold( e );
                    
                
    }
    if( e == end ) break;
        
    }
    relayout();        
        
        
        
}
        
public void topfold( Element e ){

	root.resetLineNumbers();
    int i = root.getViewIndexAtPosition( e.getStartOffset() );
    FoldableParagraphView pv = (FoldableParagraphView)root.getView( i );
    pv.topfold();
    //WeakReference&lt;ParagraphView2&gt; wr = new WeakReference&lt;ParagraphView2&gt;( pv );
    //folded.add( wr );       
        
        
}
        
public boolean isFolded( int x, int y ){
        
    if( root == null ) return false;
    int spot = jtp.viewToModel( new Point( x, y ) );
    int i = root.getViewIndex( spot, Position.Bias.Forward );
    View v = root.getView( i );
    if( v instanceof FoldableParagraphView ){
            
    FoldableParagraphView pv2 = (FoldableParagraphView)v;
    return pv2.isTopFolded();
            
            
    }
    return false;
        
}</t>
<t tx="ekr.20070127142814.1588">public View create(Element elem) {

    String kind = elem.getName();
	if (kind != null) {
	
        if (kind.equals(AbstractDocument.ContentElementName)) {
            return new InvisiblesDrawingLabelView( elem, cd, root );
		} else if (kind.equals(AbstractDocument.ParagraphElementName)) {
                FoldableParagraphView rv = new FoldableParagraphView( elem, ii, cd, root );
                return rv;
		} else if (kind.equals(AbstractDocument.SectionElementName)) {
            return ( root = new NoWrapBoxView( elem, View.Y_AXIS, jtp, cd, ii ) );
		} else if (kind.equals(StyleConstants.ComponentElementName)) {
		    return new ComponentView(elem);
		} else if (kind.equals(StyleConstants.IconElementName)) {

            return new IconView(elem);
		}
	    }
	
	    // default to text display
        return new InvisiblesDrawingLabelView(elem, cd, root);

	}
</t>
<t tx="ekr.20070127142814.1589">static class NoWrapBoxView extends BoxView{

    JTextPane jtp; 
    boolean useln;
    Color fg;
    Color bg;
    Color cl;
    ColorDeterminer cd;
    public boolean show_invisibles;
    public boolean wrap;
    LineNumberBorder border;
    BufferedImage bi;
    ImageIcon ii;
    boolean dump;
    public int lnlstart, lnlend, lnlpos, lnlpos2;
    Rectangle lastvisible_rect;
    
    public NoWrapBoxView( Element elem, int axis, JTextPane jtp, ColorDeterminer cd, ImageIcon ii){
    
        super( elem, axis );
        this.jtp = jtp;
        useln = cd.useLineNumbers();
        fg = cd.getLineNumberForeground();
        bg = cd.getLineNumberBackground();
        cl = cd.getCurrentLineNumberForeground();
        this.cd = cd;
        wrap = true;
        this.ii = ii;
        bi = new BufferedImage( 10, 10, BufferedImage.TYPE_INT_RGB );
        lastvisible_rect = new Rectangle( 0,0,0,0 );
        
    }
    
    public void resetLineNumbers(){
    
        lnlstart = lnlend = lnlpos = lnlpos2 = -1;
    
    
    }

    @others

    

}
</t>
<t tx="ekr.20070127142814.1590">
public void layout2( int width, int height ){
    
    if( wrap ){
      final Rectangle vrec = jtp.getVisibleRect();
      super.layout( vrec.width , height );
      
    }
    else super.layout( width, height );

    
}
</t>
<t tx="ekr.20070127142814.1591">public Shape modelToView(int p0, Position.Bias b0, int p1, Position.Bias b1, Shape a) throws BadLocationException{

    return super.modelToView( p0, b0, p1, b1, a );

}  

public Shape modelToView( int p0, Shape a, Position.Bias bias ) throws BadLocationException{

    Shape s = super.modelToView( p0, a, bias );
    int vi = getViewIndex( p0, Position.Bias.Forward );
    View view = getView( vi );
    if( view instanceof FoldableParagraphView ){
        FoldableParagraphView fpv = (FoldableParagraphView)view;
        if( fpv.isFolded() ){
    
            int height = (int)fpv.getPreferredSpan( Y_AXIS );
            int width = (int)fpv.getPreferredSpan( X_AXIS );
            //eturn new Rectangle( 0, 0, width, height );
            Rectangle bounds = s.getBounds();
            if( wrap ){
                Rectangle visrect = jtp.getVisibleRect();
                bounds.width= visrect.width;
        
            }
            else bounds.width= width;
            bounds.height = height;
            return bounds;
    
        }
    }

    return s;
}


public Shape getChildAllocation( int pos , Shape a ){

    //System.out.println( "GETCA!" );
   // int vi = getViewIndex( pos, Position.Bias.Forward );
   // FoldableParagraphView fpv = (FoldableParagraphView)getView( vi );
   // if( fpv.isFolded() ){
    
  //      int height = (int)fpv.getPreferredSpan( Y_AXIS );
   //     int width = (int)fpv.getPreferredSpan( X_AXIS );
   //     return new Rectangle( 0, 0, width, height );
    
   // }
    return super.getChildAllocation( pos, a );

}</t>
<t tx="ekr.20070127142814.1592">@Override
public float getPreferredSpan( int axis ){

    float rv = super.getPreferredSpan( axis );
    return rv;

}</t>
<t tx="ekr.20070127142814.1593">@Override
public float getMinimumSpan( int axis ){

    if( wrap ) return super.getMinimumSpan( axis );
    return getPreferredSpan( axis );


}</t>
<t tx="ekr.20070127142814.1594">@Override
public short getLeftInset(){
    
    return super.getLeftInset();
    
}</t>
<t tx="ekr.20070127142814.1595">public Insets getInsets(){

    try{
        int vc = getViewCount();
        Graphics g = getGraphics();
        FontMetrics fm = g.getFontMetrics();
        String s = Integer.toString( vc );
        int swidth = (fm.stringWidth( s ) + 1);
        g.dispose();
        Insets ins = new Insets( 0, swidth  ,0 , 0 );
        return ins;
    }
    catch( Exception x ){}
    return new Insets( 0, 0, 0, 0 );

}</t>
<t tx="ekr.20070127142814.1596">public void paintNumbers(  Graphics g10 , int width , JComponent translation , boolean force ){
        
        Rectangle r2 = jtp.getVisibleRect();
        if( !force &amp;&amp; !r2.equals( lastvisible_rect ) ) force = true;
        lastvisible_rect = r2;
        Insets insets = jtp.getInsets();
        int insetadd = insets.top + insets.bottom;
        int boxheight = r2.height + insetadd;
        int vstart = -1; int vend = -1; int vindex = -1; 
        if( width != bi.getWidth() || boxheight != bi.getHeight() ){
            
            bi = new BufferedImage( width, boxheight , BufferedImage.TYPE_INT_RGB );
            
        }
        Graphics2D g = (Graphics2D)bi.getGraphics();
        g.setFont( jtp.getFont() );
        try{
        
            g.setColor( bg );
            g.fillRect( 0, 0, width , boxheight  );
            Rectangle vRect = new Rectangle( r2 );
            vRect.x = 0;
        
            final int start = jtp.viewToModel( new Point( vRect.x, vRect.y ) );
            int end;
            try{
                end = jtp.viewToModel( new Point( vRect.x, vRect.y + vRect.height ) );
            }
            catch( Exception x ){
                
                end = getViewCount();
        
            }

            vstart = getViewIndexAtPosition( start );
            vend = getViewIndexAtPosition( end ) + 1;


            int cp = jtp.getCaretPosition();
            vindex = getViewIndex( cp , Position.Bias.Forward );
            int vindex2 = getView( vindex ).getViewIndex( cp, Position.Bias.Forward );
            boolean reset = false;
            try{
                if( !force ){
                    //AbstractDocument doc = (AbstractDocument )jtp.getDocument();
                    //Element e = doc.getParagraphElement( cp );
                    if( vindex == lnlpos &amp;&amp; vindex2 == lnlpos2 &amp;&amp; vstart == lnlstart &amp;&amp; vend == lnlend ){

                         return;
                    }
                    else{ force = true; reset = true;}
                }
            }
            finally{
                if( reset ){
                    lnlpos = vindex; lnlpos2 = vindex2; lnlstart = vstart; lnlend = vend;      
                } 
                
            }
            
            
            
            Rectangle cr = new Rectangle( 0, 0 , 0, 0 );
            try{
                cr = modelToView( cp, cr, Position.Bias.Forward ).getBounds();
            }
            catch( BadLocationException ble ){}
            //final ParagraphView cparagraph = (ParagraphView)getViewAtPoint( cr.x, cr.y, new Rectangle( 0,0,0,0 ) );
            final View cparagraph = getViewAtPoint( cr.x, cr.y, new Rectangle( 0,0,0,0 )) ;
            final int cindex = cparagraph.getViewIndex( cp, Position.Bias.Forward );
            
            cr = SwingUtilities.convertRectangle( jtp, cr, translation );
            int y1 = cr.y;
            int y2 = cr.y + cr.height;
    
            int amount = vend - vstart;
            int y = vRect.y;
            g.setColor( fg );
            g.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
            FontMetrics fm = g.getFontMetrics();
            int height = fm.getHeight();
            for( int i = 0; i &lt; amount; i++ ){
            
                Rectangle alot = new Rectangle( 0, 0, 0, 0 );
                Shape s3 = getChildAllocation( vstart, alot );
                Rectangle spot = s3.getBounds();
                //FoldableParagraphView pv = (FoldableParagraphView)getViewAtPoint( spot.x, spot.y, new Rectangle( 0,0,0,0 ) );
                View pv = getViewAtPoint( spot.x, spot.y, new Rectangle( 0,0,0,0 ) );
                final int iterateby = pv.getViewCount() - 1;
                spot = SwingUtilities.convertRectangle( jtp, spot, translation );
                int yspot = spot.y + height;
                if( spot.width != 0 &amp;&amp; spot.height != 0 ){
                
                    if( vindex != vstart || ( spot.y &lt; y1 || spot.y &gt; y2 ) )
                        g.drawString( Integer.toString( vstart + 1) ,1 , yspot );
                    else{
                
                        g.setColor( cl );
                        g.drawString( Integer.toString( vstart + 1) , 1 , yspot );
                        g.setColor( fg );
                
                    }   
                    
                    
                }
                if( iterateby &gt; 0 &amp;&amp; !( pv instanceof FoldableParagraphView &amp;&amp; !((FoldableParagraphView)pv).isFolded()) ){
                    boolean cview = pv == cparagraph;
                    for( int j = 1; j &lt;= iterateby; j++ ){
                        
                        Shape dotspot = pv.getChildAllocation( j, new Rectangle( 0, 0,0,0 ) );
                        Rectangle bounds = dotspot.getBounds();
                        yspot += bounds.height;
                        if( cview &amp;&amp; cindex == j ){
                            
                            g.setColor( cl );
                            g.drawString( ".", 1, yspot );
                            g.setColor( fg );
                        
                    
                        }
                        else
                            g.drawString( ".", 1, yspot );                
                
                    }
            
            
                }
                vstart++;
        
            }

    }
    finally{
        if( force )
            g10.drawImage( bi, 0, 0, null );

    }


}</t>
<t tx="ekr.20070127142814.1597">    @Override
    public void paint( Graphics g, Shape r ){ 
    
        //Thread.currentThread().dumpStack();
        super.paint( g, r );
        int sstart = jtp.getSelectionStart();
        int send = jtp.getSelectionEnd();
        if( sstart != send &amp;&amp; cd.drawrectangle() ){ //visual rectangles..., not too hard to do :)
        
        	   try{
                Rectangle start = new Rectangle( 0, 0 , 0 , 0 );
                start = modelToView( sstart, start, Position.Bias.Forward ).getBounds();
                Rectangle end = new Rectangle( 0, 0, 0 , 0 );
                end = modelToView( send, end, Position.Bias.Forward ).getBounds();
                g.setColor( cd.getRectangleColor() );
                g.drawRect( start.x + 3, start.y + 3, end.x - start.x, (( end.y + end.height ) - start.y ) - 3 );
            }
            catch( BadLocationException ble ){}
        
        
        }
        if( border != null ){
             border.paint();
             //border.paintNow();
             //Graphics g2 = border.getGraphics();
             //g2.setClip( g.getClip() );
             //Graphics g2 = g.create();
             //Insets s = getInsets();
             //g2.translate( -s.left, 0 );
             //g2.setClip( g.getClip() );
             //paintNumbers( g.getClip().getBounds(), g2 );
             
        }
        if(useln) return;
        g.setColor( bg );
        JTextComponent jtp = (JTextComponent)getContainer();
        Rectangle r2 = g.getClip().getBounds();///jtp.getVisibleRect();
        ///Rectangle r3 = jtp.getVisibleRect()
        g.fillRect( 0, r2.y, getLeftInset(), r2.height );
        Rectangle vRect = r2;
        //vRect = g.getClip().getBounds();
        final int start = jtp.viewToModel( new Point( vRect.x, vRect.y ) );
        final int end = jtp.viewToModel( new Point( vRect.x, vRect.y + vRect.height ) );

        int vstart = getViewIndexAtPosition( start );
        final int vend = getViewIndexAtPosition( end ) + 1;


        int cp = jtp.getCaretPosition();
        int vindex = getViewIndex( cp , Position.Bias.Forward );
        Rectangle cr = new Rectangle( 0, 0 , 0, 0 );
        try{
            cr = modelToView( cp, cr, Position.Bias.Forward ).getBounds();
        }
        catch( BadLocationException ble ){}
        int y1 = cr.y;
        int y2 = cr.y + cr.height;
    
        int amount = vend - vstart;
        int y = vRect.y;
        g.setColor( fg );
        g.setFont( getContainer().getFont() );
        Graphics2D g2 = (Graphics2D)g;
        g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
        FontMetrics fm = g.getFontMetrics();
        int height = fm.getHeight();
        for( int i = 0; i &lt; amount; i++ ){
            
            Rectangle alot = new Rectangle( 0, 0, 0, 0 );
            Shape s3 = getChildAllocation( vstart, alot );
            Rectangle spot = s3.getBounds();
            int divide = spot.height/height;
            int yspot = spot.y + height;
            if( spot.width != 0 &amp;&amp; spot.height != 0 ){
                
                if( vindex != vstart || ( yspot &lt; y1 || yspot &gt; y2 ) )
                    g.drawString( Integer.toString( vstart + 1) ,1 , yspot );
                else{
                
                    g.setColor( cl );
                    g.drawString( Integer.toString( vstart + 1) ,1 , yspot );
                    g.setColor( fg );
                
                }   
            
            }
            if( divide &gt; 1 ){

                int add = spot.height/divide;
                for( int j = 0; j &lt; divide -1; j++ ){
                
                    yspot += add;
                    if( yspot &gt;= y1 &amp;&amp; yspot &lt;= y2 ){
                        g.setColor( cl );
                        g.drawString( ".", 0, yspot );
                        g.setColor( fg );
                        
                    
                    }
                    else
                        g.drawString( ".", 0, yspot );                
                
                }
            
            
            }
            vstart++;
        
        }
        /*
        Dimension d = jtp.getSize();
        short bottom = getBottomInset();
        Rectangle size = new Rectangle( 0, 0, d.width, d.height );
        size.y = size.height - bottom;
        size.height = bottom;
        Rectangle bounds = g.getClip().getBounds();
        if( !size.intersects( bounds ) || !hasFootNode() ) return;
        g.setColor( cd.getFootNodeBackgroundColor() );
        g.fillRect( size.x, size.y, size.width, size.height );
        g.setColor( Color.BLACK );
        g.drawLine( size.x, size.y, size.x + size.width, size.y );
        String footnode = getFootNodeString();
        g.setColor( cd.getFootNodeForegroundColor() );
        int x = 0; int y3 = size.y + fm.getHeight();
        for( char c: footnode.toCharArray() ){
            
            if ( c == '\t' ){
            
                g.drawString( "    ", x, y3 );
                x += fm.stringWidth( "    " );
            
            
            }
            else{
                g.drawString( Character.toString( c ), x, y3 );
                x += fm.stringWidth( Character.toString( c ) );
            
            }
            if( x &gt;= size.width || c == '\n' ){
            
                x = 0;
                y3 += fm.getHeight();
            
            }
        
        
        } */

    
    }
</t>
<t tx="ekr.20070127142814.1598">public void setLineWrap( boolean wrap ){

    this.wrap = wrap;
    int amount = getViewCount();
    for( int i = 0; i &lt; amount; i ++ ){
    
        View v = getView( i );
        preferenceChanged( v, true, true );
    
    
    }
    
    layoutChanged( View.Y_AXIS );
    layoutChanged( View.X_AXIS ); 
    jtp.repaint();    
                

}

public boolean getLineWrap(){ return wrap; }
</t>
<t tx="ekr.20070127142814.1599">    @Override
    public int getNextVisualPositionFrom( int pos,
                                     Position.Bias b, 
                                     Shape a,
                                     int direction,
                                     Position.Bias[] biasRet)
                               throws BadLocationException{
        
                              
        while( true ){  
                      
            pos = super.getNextVisualPositionFrom( pos, b, a, direction, biasRet );
            View v =getView( getViewIndexAtPosition( pos ) );
            if( v instanceof FoldableParagraphView ){
                FoldableParagraphView pv2 = (FoldableParagraphView)v;
                if( !pv2.isFolded() || pv2.isTopFolded() || pos == -1 )
                    return pos;
                    
            }
            else return pos;
        
        }                     
        
    
    }</t>
<t tx="ekr.20070127142814.1600">    @Override
    public int getViewIndexAtPosition( int ind ){
    
        return super.getViewIndexAtPosition( ind );
    
    } </t>
<t tx="ekr.20070127142814.1601">
 
    public boolean hasFootNode(){  return cd.hasFootNodes(); }
    public String getFootNodeString(){ return cd.getFootNodes(); }
    
    public int calculateStringHeight( String data, FontMetrics fm ){
        
        int x = 0; int y = 0;
        int width = (int)getContainer().getSize().getWidth();
        //System.out.println( getContainer().getSize() );
        //System.out.println( jtp.getSize() );
        if( width == 0 ) return 0;
        //System.out.println( "WIDTH " + width );
        for( char c: data.toCharArray() ){
        
            //g.drawString( Character.toString( c ), x, y );
            if( c == '\t' )
                x += fm.stringWidth( "    " );
            else
                x += fm.stringWidth( Character.toString( c ) );
            if( x &gt;= width || c == '\n' ){
            
                x = 0;
                y += fm.getHeight();
                //System.out.println( "Y now:" + y );
            
            }
        
        
        }    
        //System.out.println( "RETURNING " + y );
        return y + fm.getHeight();
    
    
    }    </t>
<t tx="ekr.20070127142814.1602">static class InvisiblesDrawingLabelView extends LabelView implements InvisiblesObserver{

    ColorDeterminer cd; 
    boolean showrectangles;
    NoWrapBoxView root;
    public InvisiblesDrawingLabelView( Element elem , ColorDeterminer cd, NoWrapBoxView root){
    
        super( elem );
        this.cd = cd;
        this.root = root;
        //cd.addInvisiblesObserver( this );
        
    
    }
    
    public void setInvisiblesState( boolean state ){
    
        showrectangles = state;
    
    }
    
    
    
    
    


    public float getPreferredSpan( int axis ){
    
        if( axis == View.X_AXIS ){
        
            TabExpander ex = getTabExpander();
            if( ex == null ){
            
                ex = ( TabExpander)this.getParent().getParent();
                getTabbedSpan( 0, ex );
            
            
            }
        
        
        
        
        }
                return super.getPreferredSpan( axis );
    
    }

        public void paint( Graphics g, Shape r ){
        
            super.paint( g, r );
            if( !root.show_invisibles ) return;
            //if( true )return;
            int start = getStartOffset();
            int end = getEndOffset();
            String txt = null;
            try{
            
                txt = getDocument().getText( start, end - start );
            
            }
            catch( Exception x ){}
            if( txt == null ) return;
            GlyphPainter gp = getGlyphPainter();
            for( char c: txt.toCharArray() ){
                //System.out.println( c );
                if( Character.isWhitespace( c ) &amp;&amp; c != '\n' ){
                
                    try{
                        Rectangle s2 = (Rectangle)gp.modelToView( this, start, Position.Bias.Forward, r );
                        final FontMetrics fm = g.getFontMetrics();
                        Segment s = new Segment( new char[]{ c }, 0, 1 );
                        final int add = Utilities.getTabbedTextWidth( s, fm, s2.x, getTabExpander(), start );
                        final int which_invisible = cd.whichInvisible(); 
                        if( which_invisible == 1 ){
                            g.setColor( cd.getInvisiblesBlock() );
                            g.fillRect( s2.x, s2.y, add, s2.height ); 
                        }
                        else{
                            g.setColor( cd.getInvisiblesDot() );
                            g.drawOval( s2.x, (int)(s2.y + ( s2.height -1 - add )) , add, add );                        
                        
                        }
                    }
                    catch( BadLocationException ble ){}
                
                }
                
                start++;
            
            }
            
        }
}     </t>
<t tx="ekr.20070127142814.1603">public static final class LeoDefaultStyledDocument extends DefaultStyledDocument{

    private PositionSpecification _ps;
    private final String begin = "&lt;&lt;";
    private final String end = "&gt;&gt;";
    public final Map&lt;String,Object&gt; _srs;

    public LeoDefaultStyledDocument(){
    
        super();
        _srs = new HashMap&lt; String, Object &gt;();
    
    
    }

    public final void setPosition( final PositionSpecification p ){
    
        _ps = p;
        setSectionReferences();
    
    }

    public final PositionSpecification getPosition(){
    
    
        return _ps;
    
    
    }
    
    
    private final void setSectionReferences(){
    
        final Iterator&lt;PositionSpecification&gt; i = _ps.getChildrenIterator();
        final java.util.List&lt;String&gt; srs = new Vector&lt;String&gt;();
        _srs.clear();
        while( i.hasNext() ){
        
            final PositionSpecification p = i.next();
            final String hS = p.headString().trim();
            final int hSlen = hS.length() -2;
            
            if( hS.startsWith( begin ) &amp;&amp; hS.endsWith( end ) ) _srs.put( hS.substring( 2, hSlen ) , null );
        
        
        
        
        }
    
    
    }



}
</t>
<t tx="ekr.20070127142814.1604">
static public class FoldableParagraphView extends ParagraphView{

    boolean folded;
    boolean topfolded;
    ImageIcon ii;
    ColorDeterminer cd;
    NoWrapBoxView root;
    Image image;
    public FoldableParagraphView( Element e, ImageIcon ii, ColorDeterminer cd , NoWrapBoxView root){
        super( e );
        folded = false;
        topfolded = false;
        this.ii = ii;
        this.cd = cd;
        this.root = root;
        image = null;
    }
    
    
    public void setImage( Image image ){
    
        this.image = image;
    
    }
    
    public void fold(){ 
        folded = true; 
        topfolded = false;   
        root.preferenceChanged( this, true, true ); 
    }
    public void unfold(){ 
        folded = false;  
        topfolded = false;
        root.preferenceChanged( this, true, true );
         }
         
    public void topfold(){ 
                        
        topfolded = true; 
        root.preferenceChanged( this, true, true );
    
    }
    public boolean isFolded() { return folded || topfolded; }
    public boolean isTopFolded(){ return topfolded; }
    

    @Override
    public void paint( Graphics g, Shape r ){
    
        if( topfolded ){
            
                Rectangle r2 = r.getBounds();
                JComponent jc = (JComponent)getContainer();
                ((Graphics2D)g).setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
                g.setColor( cd.getFoldedBackgroundColor() );
                g.setFont( jc.getFont() );
                String data = "";
                try{
                    Document doc = getDocument();
                    Element e = getElement();
                    int start = e.getStartOffset();
                    int end = e.getEndOffset();
                    data = doc.getText( start, end - start );

                }
                catch( BadLocationException ble ){}
                Insets ins = jc.getInsets();
                g.fillRect( 0, r2.y, jc.getSize().width, r2.height );
                g.drawImage( ii.getImage(), ins.left , r2.y , null ); 
                g.setColor( cd.getFoldedForegroundColor() );
                g.drawString( data + "...", ii.getIconWidth() + ins.left , r2.y + ii.getIconHeight() );
                return;
        }
        else if( folded ) return;
        else if( image != null ){
            
            g.drawImage( image, 0, 0, null );
            return;
        
        
        }
        super.paint( g, r );
    
    
    }

    @Override
    public float getMinimumSpan( int axis ){
        
        if( topfolded ){
         
         if( axis == X_AXIS ) return super.getMinimumSpan( axis ); //getFoldedWidth();
         return ii.getIconHeight();
         
        }
        else if( folded ){
            
            if( axis == X_AXIS ) return 0.0f;     
            return 0.0f;
        
        
        }
        else if( image != null ){
        
            if( axis == X_AXIS ) return image.getWidth( null );
            return image.getHeight( null );
        
        }
        return super.getMinimumSpan( axis );
    
    }

    @Override
    public float getMaximumSpan( int axis ){
    
        if( topfolded ){
         
            if( axis == X_AXIS ) return super.getMaximumSpan( axis ); //return getFoldedWidth();  
         return ii.getIconHeight();
         
        }
        else if( folded ){
        
            if( axis == X_AXIS ) return 0.0f;        
            return 0.0f;
        
        
        }
        return super.getMaximumSpan( axis );
    
    
    }
    
    @Override
    public float getPreferredSpan( int axis ){
    
        if( topfolded ){
            if( axis == X_AXIS ) return super.getPreferredSpan( axis ); //return getFoldedWidth();      
         return ii.getIconHeight();
        }
        else if( folded ){
        
            if( axis == X_AXIS ) return 0.0f;         
            return 0.0f;
        
        
        }
        return super.getPreferredSpan( axis );
    
    
    }
    
    /*@Override
    public void changedUpdate( DocumentEvent de, Shape a, ViewFactory vf ){
    
        Document doc = de.getDocument();
        System.out.println( getElement() );
        DocumentEvent.ElementChange ec = de.getChange( getElement() );
        System.out.println( ec );
        try{
        
            System.out.println( "FPVCHANGE:" + doc.getText( de.getOffset(), de.getLength() ) );
            
        }
        catch( BadLocationException ble ){}
    
        super.changedUpdate( de, a, vf );
    }*/

}
</t>
<t tx="ekr.20070127142814.1605">public static class LineNumberBorder implements Border{

    NoWrapBoxView nwbv;
    JComponent jc;
    public Insets i;
    
    public LineNumberBorder( NoWrapBoxView nwbv ){
    
        this.nwbv = nwbv;
    
    
    }
    
    public void paint(){

        Graphics g = null;
        try{
            g = jc.getGraphics();
            nwbv.paintNumbers( g, i.left, jc, false );

        }
        catch(Exception x ){ x.printStackTrace();}
        finally{
        
            if( g != null ) g.dispose();
        
        }
    
    
    
    }

    public Insets getBorderInsets( Component c ){
    
        if( c == null );
            this.jc =(JComponent)c;
        
        i = nwbv.getInsets();
        return i;
    
    
    
    }


    public boolean isBorderOpaque(){ return true; }

    
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height){
        
    
        try{

            Insets i = getBorderInsets( c );
            nwbv.paintNumbers( g , i.left , jc, true );
        }
        catch( Exception ex ){}
    
    
    }

}</t>
<t tx="ekr.20070127142814.1606">public static interface ColorDeterminer{

    public Map&lt;String, AttributeSet &gt; getColoredTokens();
    public boolean underline();
    public AttributeSet getUndefinedSectionReferenceColor();
    public AttributeSet getSectionReferenceColor();
    public AttributeSet getStringColor();
    public AttributeSet getCommentColor();
    public AttributeSet getDocColor();
    public AttributeSet getNumericColor();
    public String[] getCommentTokens();
    public Color getInvisiblesBlock();
    public Color getInvisiblesDot();
    public boolean showInvisibles();
    public int whichInvisible();
    public AttributeSet getPunctuationColor();
    public boolean drawrectangle();
    public Color getRectangleColor();
    public Color getFoldedBackgroundColor();
    public Color getFoldedForegroundColor();
    public boolean useLineNumbers();
    public Color getLineNumberForeground();
    public Color getCurrentLineNumberForeground();
    public Color getLineNumberBackground();
    public Color getFootNodeBackgroundColor();
    public Color getFootNodeForegroundColor();
    public boolean hasFootNodes();
    public String getFootNodes();
    
} 

public static interface InvisiblesObserver{

    public void setInvisiblesState( boolean state );

}


</t>
<t tx="ekr.20070127142814.1607">@language java
import javax.swing.*;
import javax.swing.text.*;
import java.lang.ref.*;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

public class leoTableViewEditorKit extends StyledEditorKit{

    
    public leoTableViewEditorKit(){
    
        super();
        vf = new StyledViewFactory2();
    
    }
    
    
    
    static StyledViewFactory2 vf;// = new StyledViewFactory2();

    public ViewFactory getViewFactory(){
    
        return vf;
    
    }
    
    static class StyledViewFactory2 implements ViewFactory {

        TestTableView ttv;
        public StyledViewFactory2(){
        
            super();

        }
        
      
        
        &lt;&lt;create&gt;&gt;
    
    }
    
    @others
    
    public static void main( String[] args ){
    
        JTextPane jtp = new JTextPane();
        JScrollPane jsp = new JScrollPane( jtp );
        leoTableViewEditorKit ltvek = new leoTableViewEditorKit();
        jtp.setEditorKit( ltvek );
        Document doc = jtp.getDocument();
        try{
            doc.insertString( 0, "Mooo OOOOrrrr GOOOO\n", null );
            doc.insertString( 0, "Mooo OOOOxx GOOOO\n", null );
            doc.insertString( 0, "Mooo OOOObbb GOOOO\n", null );
            
        }
        catch( BadLocationException ble ){}
        JFrame jf = new JFrame();
        jf.add( jsp );
        jf.pack();
        jf.setVisible( true );
    
    
    
    
    
    }
    
}</t>
<t tx="ekr.20070127142814.1608">public View create(Element elem) {

    String kind = elem.getName();
	if (kind != null) {
	
        if (kind.equals(AbstractDocument.ContentElementName)) {
            return new LabelView( elem );
		} else if (kind.equals(AbstractDocument.ParagraphElementName)) {
                //ParagraphView rv = new ParagraphView( elem );
                return ttv.createTableRow( elem );
                //return rv;
		} else if (kind.equals(AbstractDocument.SectionElementName)) {
            return ( ttv = new TestTableView( elem ) );
		} else if (kind.equals(StyleConstants.ComponentElementName)) {
		    return new ComponentView(elem);
		} else if (kind.equals(StyleConstants.IconElementName)) {
		    return new IconView(elem);
		}
	    }
	
	    // default to text display
        return new LabelView(elem );

	}
</t>
<t tx="ekr.20070127142814.1609">public static class TestTableView extends TableView{

    public TestTableView( Element e ){
    
        super( e );
    
    }
    
    //@Override
    //public void layout( int width , int height ){
    
    //    Rectangle vrec = ((JComponent)getContainer()).getVisibleRect(); 
        //System.out.println( vrec );
        //System.out.println( width + " " + height );
    //    super.layout( vrec.width, height );
    
   // }
    
    &lt;&lt;table row&gt;&gt;

    public TableView.TableRow createTableRow( Element e ){
        
        System.out.println( "TABLE ROW!" );
        return new TableRow2( e );
        //return super.createTableRow( e );
    
    }
    
    public void layoutColumns( int targetSpan,
                             int[] offsets,
                             int[] spans,
                             SizeRequirements[] reqs){
        
        System.out.println( "TARGETSPAN:" + targetSpan );
        System.out.println( "SPANSDIVIDE:" + targetSpan/spans.length );                     
        super.layoutColumns( targetSpan, offsets, spans, reqs );
                             
                             
    }


}</t>
<t tx="ekr.20070127142814.1610">public class TableRow2 extends TableView.TableRow{


    public TableRow2( Element e ){
        super( e );
    
    
    
    }

    public void layoutMajorAxis( int targetspan, int axis, int[] offsets, int[] spans ){
        
        System.out.println( "MAJOR AXIS!!! "  + offsets.length + " " + spans.length  + " " + getViewCount());
        
        //offsets[ 0 ] = 0;
        //spans[ 0 ] = targetspan;
        super.layoutMajorAxis( targetspan, axis, offsets, spans );
    
    }

    public void layoutMinorAxis( int targetspan, int axis, int[] offsets, int[] spans ){
        
        System.out.println( "MinOR AXIS!!! "  + offsets.length + " " + spans.length + " " + getViewCount() );
        //offsets[ 0 ] = 0;
        //spans[ 0 ] = targetspan;
        super.layoutMinorAxis( targetspan, axis, offsets, spans );
    
    }



}</t>
<t tx="ekr.20070127142814.1611">@language java

import java.util.regex.*;
import java.util.Vector;
import java.util.Iterator;
import javax.swing.text.*;

public final class LeoUtilities{


    static final Pattern language = Pattern.compile( "^@language\\s+(\\w+)" );
    static final Matcher language_matcher = language.matcher( "" );
    static final Pattern auto = Pattern.compile( "(\\w+)\\.(\\w+)" );
    static final Matcher auto_matcher = auto.matcher( "" );

    @others
    




}</t>
<t tx="ekr.20070127142814.1612">public final static String scanForLanguage( final PositionSpecification ps ){

    final Iterator&lt;PositionSpecification&gt; it =  ps.getSelfAndParentsIterator();
    while( it.hasNext()){
    
        final PositionSpecification ps2 = it.next();
        final StringBuilder body = ps2.getTnodeBodyText()._body;
        language_matcher.reset( body );
        if( language_matcher.find() )
            return language_matcher.group( 1 );
    
    
    }

    return "python";
    

}</t>
<t tx="ekr.20070127142814.1613">public final static String scanForLanguageOnLine( final JTextComponent jtc ){


    try{
    
        if( ! jtc.isShowing() ) return null;
        final int cp = jtc.getCaretPosition();
        if( cp &lt; 0 ) return null;
        final AbstractDocument doc = (AbstractDocument)jtc.getDocument();
        //final int start  = Utilities.getRowStart( jtc, cp );
        //final int end = Utilities.getRowEnd( jtc, cp );
        Element e = doc.getParagraphElement( cp );
        final int start = e.getStartOffset();
        final int end = e.getEndOffset();
        if( start == end ) return null;
        final String txt = doc.getText( start, end - start );
        if( txt.length() == 0 ) return null;
        if( txt.charAt( 0 ) != '@' ) return null;
        if( !txt.startsWith( "@language" ) ) return null;
        final String scantext = txt.substring( 9 ).trim();
        final char[] ca = scantext.toCharArray();
        final StringBuilder sb = new StringBuilder( ca.length );
        for( final char c: ca ){
        
            if( Character.isWhitespace( c ) ) break;
            sb.append( c );
        
        }
        
        return sb.toString();
        
    
    }
    catch( Exception ble ){}
    return null;



}</t>
<t tx="ekr.20070127142814.1614">public final static Vector&lt;String[]&gt; scanFor( final Matcher[] matchers, final TnodeBodyText tnt ){

    Vector&lt;String[]&gt; found = new Vector&lt; String[] &gt;();
    
    final StringBuilder sb = tnt._body;
    for( Matcher m : matchers ){
    
        m.reset( sb );
        while( m.find()){
        
            String[] f = new String[]{ m.group( 0 ), m.group( 1 ) };
            found.add( f );
        
        
        }
            
    
    
    
    }
    
    return found;
    
    
}</t>
<t tx="ekr.20070127142814.1615">public final static Vector&lt; String[] &gt; scanForAutoCompleter( final TnodeBodyText tnt ){


    final Vector&lt; String[] &gt; found = new Vector&lt; String[] &gt;();
    final StringBuilder sb = tnt._body;
    auto_matcher.reset( sb );
    while( auto_matcher.find() ){
    
        final String[] f = new String[]{ auto_matcher.group( 1 ), auto_matcher.group( 2 ) };
        found.add( f );
    
    }

    return found;

}
</t>
<t tx="ekr.20070127142814.1616">@language java
import java.util.*;
import java.util.jar.*;
import java.io.*;



public class JyLeoClassloader extends ClassLoader{

    Map&lt;String,String&gt; resources;

    public JyLeoClassloader(){
    
        super();
        resources = new HashMap&lt;String,String&gt;();
    
    }
    
    public void addJar( String name ){
    
        try{
            JarFile jf = new JarFile( name );
            Enumeration&lt;JarEntry&gt; contents = jf.entries();
            while( contents.hasMoreElements() ){
        
                JarEntry je = contents.nextElement();
                resources.put( je.getName(), name );
        
        
            }
        }
        catch( IOException io ){}
    
    }

    public void addResource( String name, String location ){
    
        resources.put( name, location );
       
    
    }


    public InputStream getResourceAsStream( String name ){
    
        if( resources.containsKey( name ) ){
        
            String resourcepath = resources.get( name );
            if( resourcepath.endsWith( ".jar" ) ){
            
                try{
                    File f = new File( resourcepath );
                    JarFile jf = new JarFile( f );
                    JarEntry je = jf.getJarEntry( name );
                    return jf.getInputStream( je );
                }
                catch( Exception x ){}
                 byte[] b = new byte[ 0 ];
                return new ByteArrayInputStream( b );
            
            }
            else{
            
                try{
                
                    FileInputStream fis = new FileInputStream( resourcepath );
                    return fis;
                }
                catch( FileNotFoundException fnfe ){}
                catch( IOException io ){}
                
                byte[] b = new byte[ 0 ];
                return new ByteArrayInputStream( b );
            
            
            
            
            }
        
        }
        else return super.getResourceAsStream( name );
    
    
    }

    public byte[] getResourceAsByteArray( String name ){
    
        InputStream is = getResourceAsStream( name );
        List&lt;Byte&gt; data = new ArrayList&lt;Byte&gt;();
        try{
            byte d = (byte)is.read();
            while( d != -1 ){
        
                data.add( d );
                d = (byte)is.read();
        
        
            }
        }
        catch( IOException io ){}
        byte[] b =  new byte[ data.size() ];
        System.arraycopy( data.toArray( new Byte[]{} ), 0, b, 0, b.length );
        return b;
    }

    public Class loadClass( final String name ) throws ClassNotFoundException{
    
        String[] testname = name.split( "." );
        StringBuilder sb = new StringBuilder();
        for( int i = 0; i &lt; testname.length - 1; i ++ ){
        
            sb.append( testname[ i ] );
            if( i != testname.length - 1 ) sb.append( '.' );
        
        
        }
        String newname = sb.toString();
        
        if( resources.containsKey( newname ) ){
            
            byte[] data = getResourceAsByteArray( newname );
            Class c = defineClass( name, data, 0, data.length );
            resolveClass( c );
            return c;
        
        }

        return super.loadClass( name );    
    
    }



}</t>
<t tx="ekr.20070127142814.1617">@language java
import java.io.*;
import java.util.*;
import java.net.MalformedURLException;
import java.net.URL;

public class JyLeoResourceClassLoader extends ClassLoader{

    File rdirectory;
    File fclassdirectory;
    
    String fakeclassname = "FakeClass";
    Class fakeclass;

    static class FakeClass{}
    
    
    public JyLeoResourceClassLoader( File rdirectory, File fclassdirectory ){
    
        this.rdirectory = rdirectory;
        this.fclassdirectory = fclassdirectory;
    
    }
    
    public URL getResource( String name ){
    
        File f = new File( rdirectory, name );
        if( f.exists() ){
        
            try{
                return f.toURL();
            }
            catch( MalformedURLException mur ){}
         
        
        }
        return super.getResource( name );
    
    
    }
    
    public InputStream getResourceAsStream( String name ){
    
    
        File f = new File( rdirectory, name );
        if( f.exists() ){
        
            try{
            
                FileInputStream fis = new FileInputStream( f );
                return fis;
            
            }
            catch( FileNotFoundException fnfe ){}
        
        
        }
    
        return super.getResourceAsStream( name );
    
    }

    public Class getFakeClass(){
    
        File fclass = new File( fclassdirectory, "FakeClass.class" );
        List&lt;Byte&gt; data = new ArrayList&lt;Byte&gt;();
        try{
        
            FileInputStream fis = new FileInputStream( fclass );
            byte d = (byte)fis.read();
            while( d != -1 ){
        
                data.add( d );
                d = (byte)fis.read();
        
        
            }
        }
        catch( FileNotFoundException fnfe ){}
        catch( IOException io ){}
        byte[] b =  new byte[ data.size() ];
        for( int i = 0; i &lt; data.size(); i++ ){
        
            b[ i ] = data.get( i );
        
        }
        fakeclass = defineClass( fakeclassname, b, 0, b.length );
        resolveClass( fakeclass );
        return fakeclass;
    
    }



}</t>
<t tx="ekr.20070127142814.1618">@language java

public class FakeClass{

}</t>
<t tx="ekr.20070127142814.1619">import javax.swing as swing
import java.awt as awt
import sys


if __name__ == "__main__": 
    
    if len( sys.argv ) &gt; 1:
        uim = swing.UIManager
        nlf = uim.getSystemLookAndFeelClassName()
        uim.setLookAndFeel( nlf )
    else:
        pass
        
        
    jf = swing.JFrame()
    cp1 = jf.contentPane
    cp1.setBackground( awt.Color.RED )
    cp = swing.JPanel( awt.GridLayout( 2, 2 ))
    cp.setOpaque( 0) 
    cp1.add( cp )
    jt = swing.JTree()
    jt.setOpaque( 0 )
    cp.add( jt )
    jta = swing.JTextArea()
    jta.setText( "JTextArea" )
    jta.setOpaque( 0 )
    cp.add( jta )
    jtp = swing.JTextPane()
    jtp.setText( "JTextPane" )
    jtp.setOpaque( 0 )
    cp.add( jtp )
    jb = swing.JButton( "See Me" )
    jb.setOpaque( 0 )
    cp.add( jb )
    jf.pack()
    jf.visible = 1
    </t>
<t tx="ekr.20070127142814.1620">import javax.xml.parsers as jparse
import java.io as io



def read( filename ):
    
    dbf = jparse.DocumentBuilderFactory.newInstance()
    db = dbf.newDocumentBuilder()
    fis = io.FileInputStream( filename )
    doc = db.parse( fis )
    fis.close()
    doc.normalizeDocument()
    leo_file = doc.getDocumentElement()
    print leo_file
    print "-------"
    #de.normalizeDocument()
    print "-------"
    cnodes = leo_file.getChildNodes()
    nodes = {}
    for z in xrange( cnodes.length ):
        node = cnodes.item( z )
        print node
        nodes[ node.getNodeName() ] = node
        
    
    tnodes = nodes[ 'tnodes' ]
    tchildren = tnodes.getChildNodes()
    tnodes2 = {}
    for z in xrange( tchildren.length ):
        tnode = tchildren.item( z )
        if tnode.getNodeName() == 't':
            #print tnode
            print tnode.getTextContent()
            atts = tnode.getAttributes()
            print atts.getNamedItem( "tx" ).getTextContent()
            tx = atts.getNamedItem( "tx" ).getTextContent()
            tnodes2[ tx ] = tnode.getTextContent()
    
    print tnodes2
    
    #do vnodes
    
    vnodes = nodes[ 'vnodes' ]
    vchildren = vnodes.getChildNodes()
    for z in xrange( vchildren.length ):
        #print vchildren.item( z )
        item = vchildren.item( z )
        if item.getNodeName() == 'v':
            recursiveWalkV( item, tnodes2 )
            

def recursiveWalkV( v, tnodes2 ):
    
    clist = v.getChildNodes()
    atts = v.getAttributes()
    print "atts is %s" % atts
    print "V t is %s" % atts.getNamedItem( "t" ).getTextContent()
    print "Tnodes2 has %s" % tnodes2.has_key( atts.getNamedItem( "t" ).getTextContent() )
    for z in xrange( clist.length ):
        node = clist.item( z )
        if node.getNodeName() == "vh":
            print "vh is %s" % node.getTextContent()
        elif node.getNodeName() == "v":
            print "DESCENT!"
            recursiveWalkV( node, tnodes2 )
        
        

if __name__ == "__main__":
    import sys
    arg2 = sys.argv[ 1 ]
    read( arg2 )</t>
<t tx="ekr.20070127142814.1621">import javax.swing as swing
import java

class LR2( swing.ListCellRenderer ):
    def __init__( self ):
        self.component = swing.JLabel()
        self.component.setText( "&lt;html&gt;" )
        
    def getListCellRendererComponent( self, list, value, index, isSelected, cellHasFocus):
        
        self.component.setText( value )
        return self.component
        
        
jl = swing.JList()
jl.setCellRenderer( LR2() )
rs = java.lang.ClassLoader.getSystemClassLoader().findResource( "back.gif" )
data = [ "&lt;html&gt;&lt;img src='%s'&gt;Hi!" % rs, "&lt;html&gt;&lt;img src='%s'&gt;MEOW" % rs ]

jl.setListData( data )
jsp = swing.JScrollPane( jl )
jl2 = swing.JLabel()
jl2.setText( data[ 0 ] )
jf = swing.JFrame()
jf.add( jsp )
jf.add( jl2, java.awt.BorderLayout.SOUTH )
jf.pack()
jf.visible = 1



</t>
<t tx="ekr.20070127142814.1622">&lt;synth&gt;

&lt;style id='tiger_background' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' key='TEXT_FOREGROUND' /&gt; 
        &lt;color value='WHITE' key='TEXT_BACKGROUND' /&gt;
        
        &lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;  
        &lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='desktopPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        imagePainter path='/oranger.gif' method='rootPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;

    &lt;opaque value='false' /&gt;
&lt;/style&gt;


&lt;style id ="font_base" &gt;
    &lt;font name="Arial" size='16' /&gt;
&lt;/style&gt;

&lt;style id="base" clone='font_base' &gt;
    &lt;state&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="WHITE" type='BACKGROUND' /&gt;
        &lt;color value="RED" type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='tb' clone='base' &gt;
    &lt;state&gt;
    &lt;imageIcon id='handle' path='/Leoapp2.GIF' /&gt;
    &lt;!-- I had to look at the source for SynthToolBarUI to figure this one out, handleIcon is mentioned in the property table --&gt;
    &lt;property key='ToolBar.handleIcon' value='handle' /&gt;
    &lt;property key='ToolBar.separatorSize' type='dimension' value='0 0 0 0' /&gt;

    &lt;/state&gt;
    &lt;imagePainter path='/yellow.gif' method='toolBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='splitpane' &gt;
    &lt;state&gt;
    &lt;!-- imagePainter path='/rednoise.gif' method='splitPaneDividerBackground' sourceInsets='5 5 5 5'  paintCenter='true'  stretch='false' --&gt;
    &lt;property key='SplitPane.size' type='integer' value='20' /&gt;
    &lt;property key='SplitPane.oneTouchButtonSize' type='integer' value='16' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iftb' &gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='RED' type='TEXT_BACKGROUND' /&gt;
         &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED' &gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    
    &lt;opaque value='true' /&gt;
    &lt;imageIcon id='collapses' path='/orangerbar.gif' /&gt;
    &lt;imageIcon id='co2' path='/orange.gif' /&gt;
    &lt;imageIcon id='system' path='/Leoapp2.GIF' /&gt;
    &lt;imageIcon id='minimize' path='/minimize.gif' /&gt;
    &lt;imageIcon id='maximize' path='/maximize.gif' /&gt;
    &lt;imageIcon id='close' path='/close.gif' /&gt;
    &lt;imageIcon id='shrink' path='/shrink.gif' /&gt;
    &lt;property key='InternalFrameTitlePane.iconifyIcon' value='minimize' /&gt;
    &lt;property key='InternalFrameTitlePane.maximizeIcon' value='maximize' /&gt;
    &lt;property key='InternalFrameTitlePane.minimizeIcon' value='shrink' /&gt;
    &lt;property key='InternalFrameTitlePane.closeIcon' value='close' /&gt;
    &lt;property key='InternalFrame.icon' value='system' /&gt; 
    &lt;insets top='1' bottom='1' right='1' left='1' /&gt;

&lt;/style&gt;

&lt;style id='dticon' &gt;
    &lt;opaque value='true' /&gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='desktopIconBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='texts' clone='font_base' &gt;
    &lt;opaque value='true' /&gt;
    &lt;state&gt;
    &lt;/state&gt;
    
    
&lt;/style&gt;

&lt;style id='menus' clone='base' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' type="TEXT_FOREGROUND" /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;imageIcon id='mI' path='/Leoapp2.GIF' /&gt;
        &lt;property key='Menu.arrowIcon' value='mI' /&gt;
        &lt;opaque value='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='popupMenuBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/yellow.gif' method='menuBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
        &lt;state value='FOCUSED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='button'&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;insets top='5' left='5' right='5' bottom='5' /&gt;
        &lt;imagePainter path='/yellow.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;imagePainter path='/Weirdness.gif' method='buttonBorder' sourceInsets='3 3 3 3' paintCenter='false' destinationInsets='1 1 1 1' /&gt;
        &lt;property key='Button.contentAreaFilled' type='boolean' value='true' /&gt;
        &lt;object id='ins' class='java.awt.Insets' &gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
        &lt;/object&gt;
    &lt;property key='Button.margin' value='ins' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;imagePainter path='/Weirdness.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='ab'&gt;
    &lt;object class='java.lang.Integer' id='size'&gt;
        &lt;int&gt;30&lt;/int&gt;
    &lt;/object&gt;
    &lt;property key='ArrowButton.size' value='size'/&gt;
&lt;/style&gt;

&lt;style id='jlist' clone='base'&gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='ORANGE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/oranger.gif' method='listBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
    &lt;opaque value='true' /&gt;
    &lt;property key='List.rendererUseListColors' type='boolean' value='true' /&gt;
&lt;/style&gt;

&lt;style id='mbbackground' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sbar' &gt;
    

    &lt;imagePainter path='/uparrow.gif' method='arrowButtonForeground' direction='north' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/downarrow.gif' method='arrowButtonForeground' direction='south' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/rightarrow.gif' method='arrowButtonForeground' direction='east' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/leftarrow.gif' method='arrowButtonForeground' direction='west' sourceInsets='1 1 1 1' paintCenter='true' /&gt;

&lt;/style&gt;

&lt;style id='sbar2' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type="FOREGROUND" /&gt;
        &lt;color value='BLUE' type="BACKGROUND" /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/yellow.gif' method='scrollBarThumbBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarTrackBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='jtf' clone='base' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/orangerbar.gif' method='textFieldBorder' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;color value="WHITE" type="BACKGROUND" /&gt;
        &lt;color value="RED" type="FOREGROUND" /&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value="WHITE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="RED" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="RED" type='BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;insets top='3' bottom='3' right='3' left='3' /&gt;
&lt;/style&gt;

&lt;style id='tree'&gt;
    &lt;state&gt;
        
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED'&gt;
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;object id='reds' class='java.awt.Color' &gt;
        &lt;int&gt;255&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
    &lt;/object&gt;
    &lt;!-- its important to set this default property or the current node will not be colored --&gt;
    &lt;defaultsProperty key='Tree.selectionBackground' value='reds' /&gt;
    &lt;imageIcon id='collapse' path='/plusnode.gif' /&gt;
    &lt;imageIcon id='expand' path='/minusnode.gif' /&gt;
    
    &lt;object class='java.lang.Integer' id='rci'&gt;
        &lt;int&gt;7&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Integer' id='lci'&gt;
        &lt;int&gt;15&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Boolean' id='scrolls' &gt;
        &lt;boolean&gt;true&lt;/boolean&gt;
    &lt;/object&gt;
    &lt;property key='Tree.collapsedIcon' value='collapse' /&gt;
    &lt;property key='Tree.expandedIcon' value='expand' /&gt;
    &lt;property key='Tree.rightChildIndent' value='lci' /&gt;
    &lt;property key='Tree.leftChildIndent' value='rci' /&gt;
    &lt;property key='Tree.scrollsHorizontallyAndVertically' value='scrolls' /&gt;
&lt;/style&gt;

&lt;style id='treecell'&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND'/&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iconrenderer' &gt;
    &lt;state value='SELECTED' &gt;
        &lt;imagePainter path='/orangerbar.gif' method='labelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='jlabel' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;opaque value='false' /&gt;
&lt;/style&gt;

&lt;style id='tabbedpanetab' &gt;
    &lt;insets top='2' bottom='2' right='2' left='2' /&gt;
    &lt;imagePainter method='tabbedPaneTabBorder' path='/yellow.gif' sourceInsets='1 1 0 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='radios' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='unsel' path='/unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='MOUSE_OVER and SELECTED' &gt;
        &lt;imageIcon id='sel2' path='/focused_sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='sel' path='/sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='unsel2' path='/focused_unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;


&lt;style id='ckboxes' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='cunsel' path='/unsel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='SELECTED and MOUSE_OVER' &gt;
        &lt;imageIcon id='csel2' path='/sel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='csel' path='/unsel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='cunsel2' path='/sel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='leodialog' &gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
&lt;/style&gt;

&lt;style id='comboboxes' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='filechoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='fileChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='colorchoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='colorChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='optionpanes' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='optionPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sliders' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/yellow.gif' method='sliderThumbBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/yellow.gif' method='sliderTrackBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/orangerbar.gif' method='sliderThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'colorchooser_dialog'&gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id = 'settingsview' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method = 'panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;bind style='font_base' type='region' key='.*' /&gt;
&lt;bind style='tiger_background' type='region' key='MenuBar' /&gt;
&lt;bind style='tiger_background' type='region' key='ToolBar' /&gt;
&lt;bind style='tiger_background' type='region' key='SplitPane' /&gt;
&lt;bind style='tiger_background' type='region' key='DesktopPane' /&gt;
&lt;bind style='tiger_background' type='region' key='RootPane' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrame' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrameTitlePane' /&gt;
&lt;bind style='dticon' type='region' key='DesktopIcon' /&gt;
&lt;bind style="base" type="region" key="PANEL" /&gt;
&lt;!-- Note: colorchoosers dialogs contentPane are given the name cc_dialog --&gt;
&lt;bind style="colorchooser_dialog" type='name' key='cc_dialog' /&gt;
&lt;bind style='menus' type='region' key='Menu' /&gt;
&lt;bind style='menus' type='region' key='MenuItem' /&gt;
&lt;bind style='menus' type='region' key='MenuBar'  /&gt;
&lt;bind style='menus' type='region' key='MenuItemAccelerator' /&gt;
&lt;bind style='menus' type='region' key='PopupMenu' /&gt;
&lt;bind style='comboboxes' type='region' key='ComboBox' /&gt;
&lt;bind style='comboboxes' type='region' key='List' /&gt;
&lt;bind style='jtf' type='region' key='TextField' /&gt;
&lt;bind style='sbar' type='region' key='ArrowButton' /&gt;
&lt;bind style='button' type='region' key='BUTTON' /&gt;
&lt;!-- bind style="texts" type="region" key="TEXTPANE" --&gt;
&lt;bind style='texts' type='name' key='Log' /&gt;
&lt;bind style='texts' type='name' key='Editor'/&gt;
&lt;bind style="texts" type="region" key="TEXTAREA" /&gt;
&lt;bind style='tree' type='region' key='TREE' /&gt;
&lt;bind style='treecell' type='region' key='TREECELL' /&gt;
&lt;bind style='treecell' type='name' key='Tree.cellEditor' /&gt;
&lt;bind style='jlabel' type='region' key='Label' /&gt;
&lt;bind style='tb' type='region' key='TOOLBAR' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpanedivider' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpane' /&gt;
&lt;!-- note: the autocompleter list has been given the name Autolist --&gt;
&lt;bind style='jlist' type='name' key='Autolist'/&gt;
&lt;!-- note: the minibuffers background panel has been given the name Minibufferbackgrond --&gt;
&lt;bind style='mbbackground' type='name' key='Minibufferbackground' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBAR' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTRACK' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTHUMB' /&gt;
&lt;bind style='tabbedpanetab' type='region' key='TabbedPaneTab' /&gt;
&lt;bind style='radios' type='region' key='RadioButton' /&gt;
&lt;bind style='ckboxes' type='region' key='CheckBox' /&gt;
&lt;bind style='leodialog' type='name' key='Leodialog' /&gt;
&lt;bind style='iconrenderer' type='name' key='IconTreeRenderer' /&gt;
&lt;bind style='filechoosers' type='region' key='FileChooser' /&gt;
&lt;bind style='colorchoosers' type='region' key='ColorChooser' /&gt;
&lt;bind style='optionpanes' type='region' key='OptionPane' /&gt;
&lt;bind style='sliders' type='region' key='SliderThumb' /&gt;
&lt;bind style='sliders' type='region' key='SliderTrack' /&gt;
&lt;!-- the settingsview is for the view pane in the settings frame --&gt;
&lt;bind style='settingsview' type='name' key='SettingsView' /&gt;

&lt;/synth&gt;</t>
<t tx="ekr.20070127142814.1623">&lt;synth&gt;

&lt;style id='tiger_background' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' key='TEXT_FOREGROUND' /&gt; 
        &lt;color value='WHITE' key='TEXT_BACKGROUND' /&gt;
        
        &lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;  
        &lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='desktopPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='rootPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='tableBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;

    &lt;opaque value='false' /&gt;
&lt;/style&gt;


&lt;style id ="font_base" &gt;
    &lt;font name="Arial" size='16' /&gt;
&lt;/style&gt;

&lt;style id="base" clone='font_base' &gt;
    &lt;state&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="WHITE" type='BACKGROUND' /&gt;
        &lt;color value="RED" type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='tb' clone='base' &gt;
    &lt;state&gt;
    &lt;imageIcon id='handle' path='/Leoapp2.GIF' /&gt;
    &lt;!-- I had to look at the source for SynthToolBarUI to figure this one out, handleIcon is mentioned in the property table --&gt;
    &lt;property key='ToolBar.handleIcon' value='handle' /&gt;
    &lt;property key='ToolBar.separatorSize' type='dimension' value='0 0 0 0' /&gt;

    &lt;/state&gt;
    &lt;imagePainter path='/black.gif' method='toolBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='splitpane' &gt;
    &lt;state&gt;

    &lt;property key='SplitPane.size' type='integer' value='20' /&gt;
    &lt;property key='SplitPane.oneTouchButtonSize' type='integer' value='16' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iftb' &gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='RED' type='TEXT_BACKGROUND' /&gt;
         &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED' &gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='internalFrameTitlePaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
    
    &lt;opaque value='true' /&gt;
    &lt;imageIcon id='collapses' path='/orangerbar.gif' /&gt;
    &lt;imageIcon id='co2' path='/orange.gif' /&gt;
    &lt;imageIcon id='system' path='/Leoapp2.GIF' /&gt;
    &lt;imageIcon id='minimize' path='/minimize.gif' /&gt;
    &lt;imageIcon id='maximize' path='/maximize.gif' /&gt;
    &lt;imageIcon id='close' path='/close.gif' /&gt;
    &lt;imageIcon id='shrink' path='/shrink.gif' /&gt;
    &lt;property key='InternalFrameTitlePane.iconifyIcon' value='minimize' /&gt;
    &lt;property key='InternalFrameTitlePane.maximizeIcon' value='maximize' /&gt;
    &lt;property key='InternalFrameTitlePane.minimizeIcon' value='shrink' /&gt;
    &lt;property key='InternalFrameTitlePane.closeIcon' value='close' /&gt;
    &lt;property key='InternalFrame.icon' value='system' /&gt; 
    &lt;insets top='1' bottom='1' right='1' left='1' /&gt;

&lt;/style&gt;

&lt;style id='dticon' &gt;
    &lt;opaque value='true' /&gt;
    &lt;font name="Arial" size="16" /&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/orangerbar.gif' method='desktopIconBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='texts' clone='font_base' &gt;
    &lt;opaque value='true' /&gt;
    &lt;state&gt;
    &lt;/state&gt;
    
    
&lt;/style&gt;

&lt;style id='menus' clone='base' &gt;

    &lt;state&gt;
        &lt;color value='WHITE' type="TEXT_FOREGROUND" /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;imageIcon id='mI' path='/Leoapp2.GIF' /&gt;
        &lt;property key='Menu.arrowIcon' value='mI' /&gt;
        &lt;opaque value='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='popupMenuBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
        &lt;imagePainter path='/black.gif' method='menuBarBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
        &lt;state value='FOCUSED' &gt;
        &lt;color value ='WHITE' type="TEXT_BACKGROUND" /&gt;
        &lt;color value ='BLUE' type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='button'&gt;
    &lt;state&gt;
        &lt;color value='WHITE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='BLUE' type='BACKGROUND' /&gt;
        &lt;insets top='5' left='5' right='5' bottom='5' /&gt;
        &lt;imagePainter path='/black.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;imagePainter path='/black.gif' method='buttonBorder' sourceInsets='3 3 3 3' paintCenter='false' destinationInsets='1 1 1 1' /&gt;
        &lt;property key='Button.contentAreaFilled' type='boolean' value='true' /&gt;
        &lt;object id='ins' class='java.awt.Insets' &gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
            &lt;int&gt;5&lt;/int&gt;
        &lt;/object&gt;
    &lt;property key='Button.margin' value='ins' /&gt;
    &lt;/state&gt;
    &lt;state value='MOUSE_OVER' &gt;
        &lt;imagePainter path='/white.gif' method='buttonBackground' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='ab'&gt;
    &lt;object class='java.lang.Integer' id='size'&gt;
        &lt;int&gt;30&lt;/int&gt;
    &lt;/object&gt;
    &lt;property key='ArrowButton.size' value='size'/&gt;
&lt;/style&gt;

&lt;style id='jlist' clone='base'&gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='ORANGE' type='TEXT_BACKGROUND' /&gt;
        &lt;imagePainter path='/oranger.gif' method='listBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
    &lt;opaque value='true' /&gt;
    &lt;property key='List.rendererUseListColors' type='boolean' value='true' /&gt;
&lt;/style&gt;

&lt;style id='mbbackground' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sbar' &gt;
    

    &lt;imagePainter path='/uparrow.gif' method='arrowButtonForeground' direction='north' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/downarrow.gif' method='arrowButtonForeground' direction='south' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/rightarrow.gif' method='arrowButtonForeground' direction='east' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;imagePainter path='/leftarrow.gif' method='arrowButtonForeground' direction='west' sourceInsets='1 1 1 1' paintCenter='true' /&gt;

&lt;/style&gt;

&lt;style id='sbar2' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type="FOREGROUND" /&gt;
        &lt;color value='BLUE' type="BACKGROUND" /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/black.gif' method='scrollBarThumbBorder' sourceInsets='1 1 1 1' paintCenter='false' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarTrackBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollBarBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
        &lt;imagePainter path='/oranger.gif' method='scrollPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;


&lt;style id='jtf' clone='base' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/orangerbar.gif' method='textFieldBorder' sourceInsets='3 3 3 3' paintCenter='false' /&gt;
        &lt;color value="WHITE" type="BACKGROUND" /&gt;
        &lt;color value="RED" type="FOREGROUND" /&gt;
        &lt;color value="BLUE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="WHITE" type="TEXT_BACKGROUND" /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value="WHITE" type="TEXT_FOREGROUND" /&gt;
        &lt;color value="RED" type="TEXT_BACKGROUND" /&gt;
        &lt;color value="RED" type='BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;insets top='3' bottom='3' right='3' left='3' /&gt;
&lt;/style&gt;

&lt;style id='tree'&gt;
    &lt;state&gt;
        
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='FOCUSED'&gt;
        &lt;color value='RED' type="TEXT_BACKGROUND" /&gt;
        &lt;color value="BLUE" type='TEXT_FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
    &lt;/state&gt;
    &lt;object id='reds' class='java.awt.Color' &gt;
        &lt;int&gt;255&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
        &lt;int&gt;0&lt;/int&gt;
    &lt;/object&gt;
    &lt;!-- its important to set this default property or the current node will not be colored --&gt;
    &lt;defaultsProperty key='Tree.selectionBackground' value='reds' /&gt;
    &lt;imageIcon id='collapse' path='/plusnode.gif' /&gt;
    &lt;imageIcon id='expand' path='/minusnode.gif' /&gt;
    
    &lt;object class='java.lang.Integer' id='rci'&gt;
        &lt;int&gt;7&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Integer' id='lci'&gt;
        &lt;int&gt;15&lt;/int&gt;
    &lt;/object&gt;
    &lt;object class='java.lang.Boolean' id='scrolls' &gt;
        &lt;boolean&gt;true&lt;/boolean&gt;
    &lt;/object&gt;
    &lt;property key='Tree.collapsedIcon' value='collapse' /&gt;
    &lt;property key='Tree.expandedIcon' value='expand' /&gt;
    &lt;property key='Tree.rightChildIndent' value='lci' /&gt;
    &lt;property key='Tree.leftChildIndent' value='rci' /&gt;
    &lt;property key='Tree.scrollsHorizontallyAndVertically' value='scrolls' /&gt;
&lt;/style&gt;

&lt;style id='treecell'&gt;
    &lt;state value='SELECTED' &gt;
        &lt;color value='RED' type='FOREGROUND' /&gt;
        &lt;color value='RED' type='BACKGROUND'/&gt;
        &lt;color value='RED' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
        
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='iconrenderer' &gt;
    &lt;state value='SELECTED' &gt;
        &lt;imagePainter path='/orangerbar.gif' method='labelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='jlabel' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='TEXT_FOREGROUND' /&gt;
        &lt;color value='WHITE' type='TEXT_BACKGROUND' /&gt;
    &lt;/state&gt;
    &lt;opaque value='false' /&gt;
&lt;/style&gt;

&lt;style id='tabbedpanetab' &gt;
    &lt;insets top='2' bottom='2' right='2' left='2' /&gt;
    &lt;imagePainter method='tabbedPaneTabBorder' path='/black.gif' sourceInsets='1 1 0 1' paintCenter='false' /&gt;
&lt;/style&gt;

&lt;style id='radios' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='unsel' path='/unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='MOUSE_OVER and SELECTED' &gt;
        &lt;imageIcon id='sel2' path='/focused_sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='sel' path='/sel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='sel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='unsel2' path='/focused_unsel_radio.gif' /&gt;
        &lt;property key='RadioButton.icon' value='unsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;


&lt;style id='ckboxes' clone='base' &gt;

    &lt;state&gt;
        &lt;imageIcon id='cunsel' path='/unsel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel' /&gt;
        &lt;color value='WHITE' type='FOREGROUND' /&gt;
    &lt;/state&gt;

    &lt;state value='SELECTED and MOUSE_OVER' &gt;
        &lt;imageIcon id='csel2' path='/sel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel2' /&gt;
    &lt;/state&gt;
        &lt;state value='SELECTED' &gt;
        &lt;imageIcon id='csel' path='/unsel_checkbox_ch.gif' /&gt;
        &lt;property key='CheckBox.icon' value='csel' /&gt;
    &lt;/state&gt;
&lt;state value='MOUSE_OVER' &gt;
        &lt;imageIcon id='cunsel2' path='/sel_checkbox.gif' /&gt;
        &lt;property key='CheckBox.icon' value='cunsel2' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id='leodialog' &gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
&lt;/style&gt;

&lt;style id='comboboxes' clone='base' &gt;
    &lt;state&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='filechoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='fileChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='colorchoosers' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='colorChooserBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='optionpanes' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='optionPaneBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id='sliders' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/black.gif' method='sliderThumbBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/black.gif' method='sliderTrackBorder' sourceInsets='1 1 1 1' paintCenter='false'/&gt;
        &lt;imagePainter path='/orangerbar.gif' method='sliderThumbBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'colorchooser_dialog'&gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;

&lt;/style&gt;

&lt;style id = 'settingsview' &gt;
    &lt;state&gt;
        &lt;imagePainter path='/oranger.gif' method = 'panelBackground' sourceInsets='1 1 1 1' paintCenter='true' /&gt;
    &lt;/state&gt;
&lt;/style&gt;

&lt;style id = 'table' &gt;
    &lt;state&gt;
    
    &lt;color value='BLUE' type='FOREGROUND' /&gt;
        &lt;color value='WHITE' type='BACKGROUND' /&gt;
    
    &lt;/state&gt;
&lt;/style&gt;

&lt;bind style='font_base' type='region' key='.*' /&gt;
&lt;bind style='tiger_background' type='region' key='MenuBar' /&gt;
&lt;bind style='tiger_background' type='region' key='ToolBar' /&gt;
&lt;bind style='tiger_background' type='region' key='SplitPane' /&gt;
&lt;bind style='tiger_background' type='region' key='DesktopPane' /&gt;
&lt;bind style='tiger_background' type='region' key='RootPane' /&gt;
&lt;bind style='table' type='region' key='Table'/&gt;
&lt;bind style='iftb' type='region' key='InternalFrame' /&gt;
&lt;bind style='iftb' type='region' key='InternalFrameTitlePane' /&gt;
&lt;bind style='dticon' type='region' key='DesktopIcon' /&gt;
&lt;bind style="base" type="region" key="PANEL" /&gt;
&lt;!-- Note: colorchoosers dialogs contentPane are given the name cc_dialog --&gt;
&lt;bind style="colorchooser_dialog" type='name' key='cc_dialog' /&gt;
&lt;bind style='menus' type='region' key='Menu' /&gt;
&lt;bind style='menus' type='region' key='MenuItem' /&gt;
&lt;bind style='menus' type='region' key='MenuBar'  /&gt;
&lt;bind style='menus' type='region' key='MenuItemAccelerator' /&gt;
&lt;bind style='menus' type='region' key='PopupMenu' /&gt;
&lt;bind style='comboboxes' type='region' key='ComboBox' /&gt;
&lt;bind style='comboboxes' type='region' key='List' /&gt;
&lt;bind style='jtf' type='region' key='TextField' /&gt;
&lt;bind style='sbar' type='region' key='ArrowButton' /&gt;
&lt;bind style='button' type='region' key='BUTTON' /&gt;
&lt;!-- bind style="texts" type="region" key="TEXTPANE" --&gt;
&lt;bind style='texts' type='name' key='Log' /&gt;
&lt;bind style='texts' type='name' key='Editor'/&gt;
&lt;bind style="texts" type="region" key="TEXTAREA" /&gt;
&lt;bind style='tree' type='region' key='TREE' /&gt;
&lt;bind style='treecell' type='region' key='TREECELL' /&gt;
&lt;bind style='treecell' type='name' key='Tree.cellEditor' /&gt;
&lt;bind style='jlabel' type='region' key='Label' /&gt;
&lt;bind style='tb' type='region' key='TOOLBAR' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpanedivider' /&gt;
&lt;bind style='splitpane' type='region' key='Splitpane' /&gt;
&lt;!-- note: the autocompleter list has been given the name Autolist --&gt;
&lt;bind style='jlist' type='name' key='Autolist'/&gt;
&lt;!-- note: the minibuffers background panel has been given the name Minibufferbackgrond --&gt;
&lt;bind style='mbbackground' type='name' key='Minibufferbackground' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBAR' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTRACK' /&gt;
&lt;bind style='sbar2' type='region' key='SCROLLBARTHUMB' /&gt;
&lt;bind style='tabbedpanetab' type='region' key='TabbedPaneTab' /&gt;
&lt;bind style='radios' type='region' key='RadioButton' /&gt;
&lt;bind style='ckboxes' type='region' key='CheckBox' /&gt;
&lt;bind style='leodialog' type='name' key='Leodialog' /&gt;
&lt;bind style='iconrenderer' type='name' key='IconTreeRenderer' /&gt;
&lt;bind style='filechoosers' type='region' key='FileChooser' /&gt;
&lt;bind style='colorchoosers' type='region' key='ColorChooser' /&gt;
&lt;bind style='optionpanes' type='region' key='OptionPane' /&gt;
&lt;bind style='sliders' type='region' key='SliderThumb' /&gt;
&lt;bind style='sliders' type='region' key='SliderTrack' /&gt;
&lt;!-- the settingsview is for the view pane in the settings frame --&gt;
&lt;bind style='settingsview' type='name' key='SettingsView' /&gt;

&lt;/synth&gt;</t>
<t tx="ekr.20070127142814.1624">&lt;synth&gt;


&lt;style id='burt'&gt;

    &lt;state&gt;
        &lt;color value='RED' type='BACKGROUND' /&gt;
        &lt;color value='BLUE' type='FOREGROUND' /&gt;

    &lt;/state&gt;

&lt;/style&gt;


&lt;bind style='burt' type='region' key='TextPane' /&gt;


&lt;/synth&gt;</t>
<t tx="ekr.20070127142814.1625">@language java
import javax.swing.*;
import javax.swing.text.*;
import javax.swing.plaf.synth.*;
import java.awt.*; 
import java.io.*;

public class ASynthTest{

/*
How To use Notes:
ASynthTest is invoked like so:
java ASynthTest

You can pass a filename as the first argument and it will use that as the synth file.  It uses
the Class.getResourceAsStream method to open the file, so make sure the file is on the Classpath.
By default the class looks for a file called 'testsynth.xml'.  If it cant find it, the file will
be created in the current working directory and populated with synth data.

To specify which type of JTextComponent you wish to use, pass a number following the file name( if
there is no special file to use, type 'pass' as the first argument.  A numeric argument determines the
type of JTextComponent to use( default is a JTextPane ):
0 - JTextPane
1 - JTextArea
2 - JTextField

Experiences on Linux:
1. When the background is set by Synth, overiding that value appears to have no effect.  The new
background color only shows through if a window is placed over the top of the frame and then moved
away.
2. Foreground color does seem to be changed.



*/
    public static void main( String[] args ){
    
        
        File test = new File( "testsynth.xml" );
        if( !test.exists() )
            createTestsynthFile();
            
        final String synthfile;
        if( args.length &gt; 0 &amp;&amp; !args[ 0 ].equals( "pass" ) )
            synthfile = '/' + args[ 0 ];
        else
            synthfile = "/testsynth.xml";
            
            
        final SynthLookAndFeel slaf = new SynthLookAndFeel();
        try{
            Class clzz = slaf.getClass();
            InputStream is = clzz.getResourceAsStream( synthfile );

            if( is == null ){
            
                String message = String.format( "Synth File: %s , could not be loaded", synthfile );
                throw new IllegalArgumentException( message );
         
         
            }
            slaf.load( is, clzz );
            UIManager.setLookAndFeel( slaf );
            
         }
         catch( Exception x ){
         
            x.printStackTrace();
            System.exit( 0 );
         
         
         }
    
        
        JFrame top = new JFrame();
        top.setTitle( "Synth and JTextComponent Test" );
        top.setDefaultCloseOperation( top.EXIT_ON_CLOSE );
        top.setSize( 400, 400 );
        
        //Set JTextComponent
        JTextComponent jtc;
        if( args.length &gt; 1 ){
            
            String arg2 = args[ 1 ];
            int which = 0;
            try{
            
                which = Integer.valueOf( arg2 );
            
            
            }
            catch( NumberFormatException nfe ){
            
                nfe.printStackTrace();
                
            
            
            }
            switch( which ){
            
                case 0:
                  jtc = new JTextPane();
                  break;
                case 1:
                  jtc = new JTextArea();
                  break;
                case 2:
                  jtc = new JTextField();
                  break; 
                case 4:
                    jtc = new JTextPane2();
                    break;
                 
                default:
                  jtc = new JTextPane();
            
            
            
            }
        
        
        
        }
        else  jtc = new JTextPane();
        
        top.add( jtc );
        top.setVisible( true );
        
        System.out.println( "-----Outputing Synth set values-----" );
        String foreground = String.format( "Foreground color is %s", jtc.getForeground() );
        String background = String.format( "Background color is %s", jtc.getBackground() );
        String opaque = String.format( "Opaque value is %s", jtc.isOpaque() );
        for( String s: new String[]{ foreground, background, opaque } )
            System.out.println( s );
            
            
        jtc.setBackground( Color.BLUE );
        jtc.setForeground( Color.GREEN );
        jtc.setOpaque( true );
        
        System.out.println( "-----Outputing reset values-------" );
        foreground = String.format( "Foreground color is %s", jtc.getForeground() );
        background = String.format( "Background color is %s", jtc.getBackground() );
        opaque = String.format( "Opaque value is %s", jtc.isOpaque() );
        for( String s: new String[]{ foreground, background, opaque } )
            System.out.println( s );
        
    
    
    
    }


    private static void createTestsynthFile(){
    
        try{
            File tsf = new File( "testsynth.xml" );
            FileOutputStream fos = new FileOutputStream( tsf );
            PrintWriter pw  = new PrintWriter( fos );
            pw.println( getTestsynthData() );
            pw.close();
            System.out.println( String.format( "Created textsynth.xml in %s", tsf.getCanonicalPath() ) );
        }
        catch( Exception x ){
        
            x.printStackTrace();
            System.out.println( "Could not create testsynth.xml, moving on..." );
        
        
        }
    
    
    
    }
    
    private static String getTestsynthData(){
    
        String data ="&lt;synth&gt;\n"
        +"&lt;style id='test'&gt;\n"
        +"&lt;state&gt;\n"
        +"   &lt;color value='RED' type='BACKGROUND' /&gt;\n"
        +"   &lt;color value='BLUE' type='FOREGROUND' /&gt;\n"
        +"&lt;/state&gt;\n"
        +"&lt;/style&gt;\n"
        +"&lt;bind style='test' type='region' key='TextPane' /&gt;\n"
        +"&lt;bind style='test' type='region' key='TextArea' /&gt;\n"
        +"&lt;bind style='test' type='region' key='TextField' /&gt;\n"
        +"&lt;/synth&gt;";
    
        return data;
    
    
    
    }


    public static class JTextPane2 extends JTextPane{
    
        volatile int _background_changes = 1;
    
        public JTextPane2(){
        
            super();
           // _background_changes = 0;
        
        
        
        }
    
        public void setBackground( Color c ){
            
            System.out.println( "Color passed in is " + c );
            System.out.println( "-----Current BG Color Value is " + getBackground() );
        
            System.out.println( "----------This is Stack Trace-----------" );
            Thread.dumpStack(); 
            System.out.println( "----------This is End of Stack Trace---------" );
            super.setBackground( c );
            System.out.println( "-----Changed BG Color Value is " + getBackground() );
  
        
        }
    
    
    }



}</t>
<t tx="ekr.20070127142814.1626">&lt;synth&gt;

&lt;style id='all'&gt;
    &lt;state&gt;
        &lt;opaque value='false' /&gt;
    &lt;/state&gt;
    
&lt;/style&gt;


&lt;style id='jp'&gt;
    &lt;state&gt;
    &lt;opaque value='true' /&gt;
    &lt;imagePainter path='/oranger.gif' method='panelBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
       
    &lt;/state&gt;
    
&lt;/style&gt;

&lt;bind style='all' type='region' key='.*' /&gt;
&lt;bind style='jp' type='region' key='panel' /&gt;

&lt;/synth&gt;</t>
<t tx="ekr.20070127142814.1627">&lt;imagePainter path='/oranger.gif' method='buttonBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='toolBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='splitPaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/orangerbar.gif' method='menuBarBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;   
&lt;imagePainter path='/oranger.gif' method='internalFrameBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;
&lt;imagePainter path='/oranger.gif' method='internalFrameTitlePaneBackground' sourceInsets='10 10 10 10' paintCenter='true' stretch='true' /&gt;




    &lt;defaultProperty key='InternalFrameTitlePane.closeButton' value='buba' /&gt; 
    &lt;property key='InternalFrameTitlePane.iconifyButton' value='co2' /&gt; 
    &lt;property key='InternalFrameTitlePane.maximizeButton' value='collapses' /&gt; 
    &lt;property key='InternalFrameTitlePane.minimizeButton' value='collapses' /&gt;    
       &lt;property key='InternalFrame.icon' value='collapses' /&gt;
       
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet ekr_stylesheet?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="1" max_tnode_index="1"/&gt;
&lt;vnodes&gt;
&lt;v t="zorcanda!.20050419181658" a="TV"&gt;&lt;vh&gt;printOutlineAsMore&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="zorcanda!.20050419181658"&gt;def printOutlineAsMore( self, *args ):

    p = self.c.rootPosition()
    nodes = []
    for v in p.allNodes_iter( copy = True): 
        head = v.moreHead( 0 )
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        s += body
        nodes.append( s )
        
    
    wholestring = '\n'.join( nodes )
    #self.sendStringToPrinter( wholestring )
    self.sendStringToJFreeReport( "", wholestring )
    
    &lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="ekr.20070127142814.1628">import base64



nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''
nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''
nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''
noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''
clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''
copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''
cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''
paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''
insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''
demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''
promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''
pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''
hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''
dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''
question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''
sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''
sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''
delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''
moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''
movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''
moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''
moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''

fd = { "nodeup.gif":nodeup, "nodedown.gif": nodedown, "nodeleft.gif":nodeleft, 
       "noderight.gif": noderight, "clone.gif": clone, "copy.gif": copy, "paste.gif": paste,
       "insert.gif": insert, "demote.gif": demote, "promote.gif": promote, "pasteclone.gif": pasteclone,
       "hoist.gif": hoist, "dehoist.gif": dehoist, 
       "question.gif": question, "sortchildren.gif": sortchildren, 
       "sortsiblings.gif": sortsiblings, "delete.gif": delete, "moveup.gif": moveup, 
        "movedown.gif": movedown, "moveleft.gif": moveleft, "moveright.gif": moveright }

for z in fd.keys():
    f = open( z, "w" )
    data = fd[ z ]
    bin = base64.decodestring( data )
    f.write( bin )
    f.close()
     

</t>
<t tx="ekr.20070127142814.1629">import testimport2

class testimporta:
    pass
    
class testimporta2( testimporta ):
    pass
    
class testimporta3( testimporta2 ):
    pass
    
print "2 %s" % dir( testimport2 )</t>
<t tx="ekr.20070127142814.1630">import testimport


class testimporta:
    pass
    
class testimport2a( testimporta ):
    pass
    
class testimport3a( testimport2a ):
    pass
    
    
print dir( testimport )</t>
<t tx="ekr.20070127142814.1631">@language java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import java.util.*;

public class ExpandTreeExample extends JTree{

    public boolean use_normal_expansion_methods;
    static Vector&lt;TreePath&gt; tps = new Vector&lt;TreePath&gt;();

    public ExpandTreeExample( TreeModel tm ){
    
        super( tm );
        use_normal_expansion_methods = false;
    }


    public void setUseNormalExpansionMethods( boolean use ){
    
        use_normal_expansion_methods = use;
    
    
    }

    //These 2 methods seem to only return information that is tracked internally, 
    //they don't affect whether a tree node is expanded or not on reload,
    //but they affect whether or not a node is expanded when clicked on.
    @Override
    public boolean isExpanded( TreePath tp ){
    
        //if( use_normal_expansion_methods )
            return super.isExpanded( tp );
    
        //System.out.println( "isExpanded " + tp );
        //uncomment to see how they expand the tree but also give a nasty flicker/flash when doing so
        //setExpandedState( tp, true );
        
        //In my application it would be nifty if I could query the data passed in and see if it was expanded.
        //This I can do, but it doesn't do what I expect if I just return the 'true' or 'false'.
        //return true; //just returning true all the time seems to interfere with Mouse click expansion/collapse
    
    }

    @Override
    public boolean hasBeenExpanded( TreePath tp ){ 
        
        //if( use_normal_expansion_methods )
        return super.hasBeenExpanded( tp );
        //System.out.println( "hasBeenExpanded " + tp );
        //uncomment to see how they expand the tree but also give a nasty flicker/flash when doing so
        //setExpandedState( tp, true );
        //return true; //just returning true all the time seems to interfere with Mouse click expansion/collapse
    
    }


    @Override
    public Enumeration&lt; TreePath &gt; getExpandedDescendants( TreePath tp ){
        
        //java.lang.Thread.currentThread().dumpStack();
        System.out.println( tp );
        return tps.elements();
        //return super.getExpandedDescendants( tp );
    
    
    }
    /* Since the previous 2 methods, don't quite do what I want I have to have a component that imposes the expanded state
       after each reload.  Ideally for my app, it would be great to not have to impose it.  Maybe a simple scheme where the
       model could implement a "NodeExpansionModel" that has a method:
       public boolean pathExpanded( TreePath tp )  --&gt; this return true if the path is expanded, false otherwise
       or/and
       public boolean nodeExpanded( Object node ) --&gt; this returns true if the node identified by 'node' is expanded or not.
       
       then the JTree could just query the "NodeExpansionModel" when reloaded to determine which nodes are expanded or not.
       For my app this would be great in that the nodes contain information about their expansion state:
       p.isExpanded() #--&gt; p is a Position in my app, it is the front end class for the 'node'
       
       when the JTree is reloaded, I currently have to iterate over my structure and then build a TreePath for each expanded node.
       This TreePath, in turn is passed to 'fireTreeExpanded' of the JTree instance.
       
       My simple thesis, again, is that it would be a nice improvement if the JTree did the work of deciding if a node is expanded
       or not, via querying some model.  Maybe the method to add the model would be:
       setNodeExpansionModel( NodeExpansionModel model )
       if the NodeExpansionModel isn't set, then you could just use the current behavior when reloading--&gt; which is not to
       expand anything */
       
       
    
    
    public static void main( String[] args ){
    
        JFrame jf = new JFrame();
        jf.getContentPane().setLayout( new BorderLayout() );
        final DefaultMutableTreeNode dmtn = new DefaultMutableTreeNode( "Using Overrides" );
        for( int i = 0; i &lt; 5; i++ ){
            DefaultMutableTreeNode dmtn2 = new DefaultMutableTreeNode( i );
            dmtn.add( dmtn2 );
            for( int i2 = 0; i2 &lt; 5; i2++ ){
             DefaultMutableTreeNode dmtn3 = new DefaultMutableTreeNode( i + "" + i2 );  
             dmtn2.add( dmtn3 );
             DefaultMutableTreeNode[] path = new DefaultMutableTreeNode[]{ dmtn, dmtn2, dmtn3 };
             tps.add( new TreePath( path ) );
             
             }
        
        }
        
        final DefaultTreeModel dtm = new DefaultTreeModel( dmtn );
        final ExpandTreeExample jt = new ExpandTreeExample( dtm );
        JScrollPane jsp = new JScrollPane( jt );
        jf.add( jsp );
        JButton jb = new JButton( new AbstractAction( "Reload" ){
        
        
            public void actionPerformed( ActionEvent ae ){
                
                System.out.println( "PRE RELOAD" );
                dtm.reload();
                TreePath tp = new TreePath( dmtn );
                //jt.fireTreeExpanded( tp );
                //jt.firePropertyChange( jt.TREE_MODEL_PROPERTY, dtm, dtm );
                //jt.expandPath( tp );
                //jt.setModel( null );
                //jt.setModel( dtm );
                //jt.updateUI();
                System.out.println( "POST RELOAD" );
            
            }
        
        
        
        });
        jb.setToolTipText( "Press Me To Reload The TreeModel" );
        JButton jb2 = new JButton( new AbstractAction( "Toggle Normal Expansion Methods" ){
        
            public void actionPerformed( ActionEvent ae ){
            
                if( jt.use_normal_expansion_methods ){
                    dmtn.setUserObject( "Using Overrides" );
                    System.out.println( "Setting Overrides to False" );
                    jt.setUseNormalExpansionMethods( false );
                }
                else{
                    
                    dmtn.setUserObject( "Not Using Overrides" );
                    System.out.println( "Setting Use Normal Methods" );
                    jt.setUseNormalExpansionMethods( true );
                    
                }
            dtm.reload();
            
            
            }
        
        
        
        });
        jb2.setToolTipText( "Press Me to Toggle Back to Normal JTree Expansion Methods" );
        JPanel jp = new JPanel();
        jp.add( jb );
        jp.add( jb2 );
        jf.add( jp, BorderLayout.SOUTH );
        jf.pack();
        jf.setVisible( true );
    
    
    
    
    
    }


}</t>
<t tx="ekr.20070127142814.1632">import javax.swing as swing
import javax.swing.text as stext
import javax.swing.event as sevent
import java.awt.event as aevent

jf = swing.JFrame()
jtp = swing.JTextPane()
jsp = swing.JScrollPane( jtp )
jf.add( jsp )

class doc1( sevent.DocumentListener ):
    
    
    def removeUpdate( self, event ):
        
        print stext.Utilities.getRowStart( jtp, event.getOffset() )
        
    def changeUpdate( self, event ):
        #print event
        pass
        
    def insertUpdate( self, event ):
        #print event
        pass
        
class kp( aevent.KeyAdapter ):
    
    def __init__( self ):
        aevent.KeyAdapter.__init__( self )
            
    def keyPressed( self, event ):
        
        #event.consume()
        kc = event.getKeyChar()
        print kc
        if kc == 'x':
            event.consume()
            cp = jtp.getCaretPosition()
            rs = stext.Utilities.getRowStart( jtp, cp )
            re = stext.Utilities.getRowEnd( jtp, cp )
            rs1 = stext.Utilities.getRowStart( jtp, re + 1 )
            re1 = stext.Utilities.getRowEnd( jtp, re + 1 )
            doc = jtp.getDocument()
            line1 = doc.getText( rs, re - rs )
            line2 = doc.getText( rs1, re1- rs1 )
            doc.replace( rs1, re1 - rs1, line1, None )
            doc.replace( rs, re - rs, line2, None )
            
            
        
jtp.getDocument().addDocumentListener( doc1() )
jtp.addKeyListener( kp() )
jf.size = ( 400, 400 )
jf.visible = 1
</t>
<t tx="ekr.20070127142814.1633"></t>
<t tx="ekr.20070127142814.1634"> 
 """
autocompletion and calltips plugin.  Special characters:

. summons the autocompletion.  
( summons the calltips
Escape closes either box.
Ctrl selects an item.
alt-up_arrow, alt-down_arrow moves up or down in the list.  The mouse will work for this as well.
This plugin scans the complete outline at startup..

You many enable or disable features in autocomplete.ini( see configuration section ).
"""

@language python 
@tabwidth-4

&lt;&lt;imports&gt;&gt;
__version__ = ".72"
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;load notes&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;
useauto = 1 #These two global determine if the autocompleter and calltip systems are used.  Default is on.
usecall = 1
&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others

if Pmw and Tk and weakref:

    leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
    leoPlugins.registerHandler(('start2','open2'),initialScan)   
    g.plugin_signon(__name__)
    

</t>
<t tx="ekr.20070127142814.1635">import leoGlobals as g 
import leoPlugins 
import leoTkinterFrame 

import leoColor 
import ConfigParser 
import os
import os.path  

import re 
import sets 
import string 
import threading 

try:
    import Pmw 
except ImportError:
    Pmw = g.cantImport("Pmw",__name__)

try:
    import Tkinter as Tk 
except ImportError:
    Tk = g.cantImport("Tk",__name__)
    
try:
    import weakref 
except ImportError:
    weakref = g.cantImport("weakref",__name__)</t>
<t tx="ekr.20070127142814.1636">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
 .71
    investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
    1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
    2. There is a global flag indicating whether the config file needs to be read again.
    3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
    4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
    5. Moved createConfig part out of thread.
    problems seems centered on Windows/IO/Threading.
 .72
    The thesis and experiments to confirm the problem identified in .71 appear completely wrong.  I could not recreate
    threading+writeIO staling on XP at all.  Windows 98 didnt even work.  But after commenting out g.es calls it did work.
    My new target for the problem is now focused on keeping g.es calls out of the initialScan thread.  This will just entail
    moving all the reading and writing of the config and language files out of the thread.</t>
<t tx="ekr.20070127142814.1637">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20070127142814.1638">@ 

switching to the placer appears to have gotten rid of this dependency

--no longer true---
Autocompleter needs to be loaded before Chapters/chapters or the autobox and the calltip label do
not appear in the correct place.
--no longer true---


@c 
</t>
<t tx="ekr.20070127142814.1639">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the
new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information


context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode


</t>
<t tx="ekr.20070127142814.1640">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.

</t>
<t tx="ekr.20070127142814.1641">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20070127142814.1642">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory= set ):# factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
   
</t>
<t tx="ekr.20070127142814.1643">#This section defines patterns for calltip recognition.  The autocompleter does not use regexes.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats['python'] = re.compile(r'def\s+%s' % end)

pats['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % ( space, space, end ) )
    
pats['perl'] = re.compile(r'sub\s+%s' % end)

pats['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' %( space, end ))

pats['c'] = re.compile(r'\w+%s%s' % ( space ,end ))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits+string.letters+r 

ripout = string.punctuation+string.whitespace+'\n'
ripout = ripout.replace('_','')

okchars ={}
for z in string.ascii_letters:
    okchars[z] = z 
okchars['_'] = '_'</t>
<t tx="ekr.20070127142814.1644">watchitems = ( '.',')' )
txt_template = '%s%s%s'
def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    global lang 
    if event.char.isspace() or event.char in watchitems:
        bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        if event.char.isspace():
            if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
            if bCtrl.get( 'insert -1c wordstart -1c') != '.': return
            
        c = bCtrl.commander
        lang = c.frame.body.getColorizer().language 
        txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
                             event.char, 
                             bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet

        scanText(txt)
    
</t>
<t tx="ekr.20070127142814.1645">def scanText (txt):
    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)
</t>
<t tx="ekr.20070127142814.1646">def scanForAutoCompleter (txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!</t>
<t tx="ekr.20070127142814.1647">def scanForCallTip (txt):
    '''this function scans text for calltip info'''
    pat2 = pats['python']
    if lang!=None:
        if pats.has_key(lang):
            pat2 = pats[lang]
    g2 = pat2.findall(txt)
    if g2:
        for z in g2:
            if isinstance(z,tuple):
                z = z[0]
            pieces2 = z.split('(')
            pieces2[0] = pieces2[0].split()[-1]
            a, b = pieces2[0], pieces2[1]
            calltips[ lang ][ a ].add( z ) #we are using the experimental DictSet here, usage removed all of the commented code. notice we have cut all this down to one line of code!
            #if calltips.has_key(lang):
            #    if calltips[lang].has_key(a):
            #        calltips[lang][a].add(z)
            #    else:
            #        calltips[lang][a] = sets.Set([z]) 
            #else:
            #    calltips[lang] ={}
            #    calltips[lang][a] = sets.Set([z])        </t>
<t tx="ekr.20070127142814.1648">def makeAutocompletionList (a,b,glist):
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 
</t>
<t tx="ekr.20070127142814.1649">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20070127142814.1650">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20070127142814.1651">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")or keywords.get("new_c")
    if haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()


</t>
<t tx="ekr.20070127142814.1652">#These functions determine if the config and language files have been read or not.  No need to read it more than once.
def hasReadConfig():
    return configfilesread
    

def setReadConfig():
    global configfilesread
    configfilesread = True
</t>
<t tx="ekr.20070127142814.1653">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20070127142814.1654">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20070127142814.1655">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20070127142814.1656">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20070127142814.1657">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20070127142814.1658">def unbind ( context ):
    '''This method turns everything off and removes the calltip and autobox from the canvas.'''
    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map( context.unbind, ( "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;" , "&lt;Alt_R&gt;" ) )
        context.unbind_all( '&lt;Button&gt;' )
        context.update_idletasks()</t>
<t tx="ekr.20070127142814.1659">def moveSelItem (event, context ):
    '''This def moves the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:

        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20070127142814.1660">def processKeyStroke (event,context ,body):
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return
    if not context.on or event.keysym in ( "??", "Shift_L","Shift_R" ):
        return None 
    #if event.keysym=='Escape':
    #    #turn everything off
    #    unbind( c )
    #    return None 
    #if c.which and event.keysym in('parenright','Control_L','Control_R'):
    #    unbind( c )
    #    c.on = False 
    elif testForUnbind( event, context ): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        unbind( context )
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    elif context.which==1:
        #no need to add text if its calltip time.
        return None 
    ind = body.index('insert-1c wordstart')
    pat = body.get(ind,'insert')+event.char 
    pat = pat.lstrip('.')

    autobox = context.autobox
    ww = list( autobox.get( 0, 'end' ) )
    lis = reducer(ww,pat)
    if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    i = ww.index(lis[0])

    autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    autobox.select_set( i )
    autobox.see( i )
    return 'break'</t>
<t tx="ekr.20070127142814.1661">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20070127142814.1662">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20070127142814.1663">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20070127142814.1664">def add_bindings( context, body ):
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )

</t>
<t tx="ekr.20070127142814.1665">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20070127142814.1666">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20070127142814.1667">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20070127142814.1668">def newCreateControl (self,frame,parentFrame):
    '''This def is a decoration of the createControl def.  We set up the ancestory of the control so we can draw
       Widgets over the Text editor without disturbing the text.'''
    #creating background
    #We have moved to using the placer, this is simpler to use and more efficient.  We have to decorate the Tk.Text
    #widget with a constructor that creates an intermediate Frame for the Text to be placed instead of packed.  Had no
    #idea that the placer could do this so nicely.  With a couple changes in 3 places, we are using the placer!
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init( self, master, *args, **kwords ):
        
        context = Tk.Frame( master ) #This is what we need to put in before the text to make place work.
        orig_init( self, context, *args, **kwords )
    
    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame, parentFrame )#orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init
    
    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack( expand = 1, fill = 'both', after = frame.bodyBar )  #We have to add it to the environment, since we pass on it in the __init__   
    body.place( relwidth = 1.0, relheight = 1.0 )
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets( context )
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler( event, context= context, body = body ): 
        processKeyStroke( event, context, body )
    def addItemHandler( event, context = context, body = body, colorizer = frame.body ): 
        add_item( event, context, body, colorizer.getColorizer() )
                
    for z in ( watcher, processKeyStrokeHandler, addItemHandler ):
        context.bind( "&lt;Key&gt;", z, '+' )
    
    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr( context, 'autobox' ):
        ignore.append(  context.autobox.component( 'listbox' ) )
        ignore.append( context.autobox.component( 'vertscrollbar' ) )
    def do_unbind( event ):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''            
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind( context )

    context.do_unbind = do_unbind
    
    #This part protects this plugin from others that use Alt-Up, Alt-Down, an example being temacs.py
    #The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt( event ):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ( '&lt;Alt-Up&gt;', '&lt;Alt-Down&gt;' ): context.block_alt.bind( z, block_alt ) 
    
    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append( context.bindtags()[ 0 ] )
    ctags.append( context.block_alt.bindtags()[ 0 ] )
    ctags.extend( body.bindtags() ) 
    body.bindtags( tuple( ctags ))
    
    return body  







</t>
<t tx="ekr.20070127142814.1669">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []
    
    if useauto:
        context.autobox = Pmw.ScrolledListBox( context ,hscrollmode='none',
                                         listbox_selectbackground='#FFE7C6',
                                         listbox_selectforeground='blue',
                                         listbox_background='white',
                                         listbox_foreground='blue',
                                         vertscrollbar_background='#FFE7C6',
                                         vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',
                         foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):#This def makes removing the autobox or calltip label easy.  No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()
    context.clean_editor = clean_editor

</t>
<t tx="ekr.20070127142814.1670">def onOpenWindow ():
    #what does this do?
    c = keywords.get("c")or keywords.get("new_c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20070127142814.1671">'''nodebar adds buttons at the bottom of the tree canvas.
The buttons correspond to commands found in the Outline commands.
It is intended to speed up a new users ability to use the outline.  
Experienced users may find value in being able to quickly execute commands they do not use very often'''
import leoGlobals as g
import leoPlugins
     
load_ok=True
try:
    import Pmw
    import weakref
    import Tkinter as Tk
    import ConfigParser
    import os.path
except Exception, x:
    g.es( 'Could not load because of %s' % x )
    load_ok = False
    
&lt;&lt;images&gt;&gt;
&lt;&lt;images2&gt;&gt;

&lt;&lt;version&gt;&gt;

&lt;&lt;How To Configure&gt;&gt;

@others</t>
<t tx="ekr.20070127142814.1672">
nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''

nodeupPI = Tk.PhotoImage( data = nodeup )

nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''

nodedownPI = Tk.PhotoImage( data = nodedown )

nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''

nodeleftPI = Tk.PhotoImage( data = nodeleft )

noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''

noderightPI = Tk.PhotoImage( data = noderight )

clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''

clonePI = Tk.PhotoImage( data = clone )


copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''

copyPI = Tk.PhotoImage( data = copy )

cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''

cutPI = Tk.PhotoImage( data = cut )


paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''

pastePI = Tk.PhotoImage( data = paste )


insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''

insertPI = Tk.PhotoImage( data = insert )

demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''

demotePI = Tk.PhotoImage( data = demote )

promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''

promotePI = Tk.PhotoImage( data = promote )

pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''

pasteclonePI = Tk.PhotoImage( data = pasteclone )

hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''

hoistPI = Tk.PhotoImage( data = hoist )

dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''

dehoistPI = Tk.PhotoImage( data = dehoist )

question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''

sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''

sortchildrenPI = Tk.PhotoImage( data = sortchildren )

sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''

sortsiblingsPI = Tk.PhotoImage( data = sortsiblings )

questionPI = Tk.PhotoImage( data = question )

delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''

deletePI = Tk.PhotoImage( data = delete )

</t>
<t tx="ekr.20070127142814.1673">moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''

moveupPI = Tk.PhotoImage( data = moveup )

movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''

movedownPI = Tk.PhotoImage( data = movedown )

moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''

moveleftPI = Tk.PhotoImage( data = moveleft )

moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''

moverightPI = Tk.PhotoImage( data = moveright )</t>
<t tx="ekr.20070127142814.1674">@


.1 made initial icons

.15 eliminated most of the letter icons, made them node based icons.

.2 EKR:
    - Fixed hang when help dialog selected.
    - Write help string to status area on mouse over.
    - Added test for if g.app.gui.guiName() == "tkinter"

.25 added movement arrows.  These contrast with the move node arrows by being empty and on the other side of the nodebar.  A user may be able to do all the manipulations he needs of the outline at this point.  Note:  the bar is of such a size we may need to add some kind of scrolling mechanism.  Not sure if I like the hoist and dehoist icons yet. ????

--tried out scrollbar idea, what a terrible idea.  The user is just going to have to have a big enough screen to use it. :D

.3 Added balloon help.  Should help new users.  Added .config file machinery</t>
<t tx="ekr.20070127142814.1675">@

1rst there needs to be a config file in the plugins directory called nodebar.ini

in this file there needs to be a section with this headline:
[ nodebar ]


under this headline there needs to be these two options
position
usehelp


----
position should be set to 1 of 3 values:
position=1
position=2
position=3

1, means add the nodebar to the icon area of Leo( this is the default )
2, means add the nodebar underneath the tree area
3, means add the nodebar underneath the editor area

-----
usehelp should be set to either 0 or 1:
usehelp=0
usehelp=1

0, means do not use balloon help when the arrow goes over the nodebar( this is the default )
1, means use the balloon help when the arrow goes over the nodebar

------

qhelp should be set to either 0 or 1

0, means that there will not be a question mark help button in the nodebar
1, means that there will be a question mark help button in the nodebar
------

nodebar will create a .ini file for the user if there isn't one already.

If there are problems in the .ini file, nodebar should sail on using the default values.</t>
<t tx="ekr.20070127142814.1676">def determineFrame( c ):
    '''Returns the area in Leo where the user wants the nodebar.  Default to are 1'''
    cpos = config[ pos ]
    
    if cpos == '2':
        frame = c.frame.split2Pane1
    elif cpos == '3':
        frame = c.frame.split1Pane2
    elif cpos == '4':
        frame = Tk.Toplevel()
        frame.title( 'nodebar' )
    else: #Should be area 1.  If its something else we use area 1.
        frame = c.frame.iconFrame 

    return frame</t>
<t tx="ekr.20070127142814.1677">haveseen = weakref.WeakKeyDictionary()
def addNodeBar( tag, keywords ):
    '''Add nodebar to new frame'''
    c = keywords.get( 'c' ) or keywords.get( 'new_c' )
    if not c:
        return
    if haveseen.has_key( c ):
        return
    haveseen[ c ] = None
    
    frame = determineFrame( c )
    mbox = Tk.Frame( frame )
    mbox.pack( side = 'bottom' , fill = 'x' )
    for z in frame.children.values():
        mbox.pack_configure( before = z )
        
    def goToChild( c = c ):
        
        pos = c.currentPosition()
        if pos.hasChildren():
            c.selectPosition( pos.nthChild( 0 ) )
            
    bcommands = ( 
                  ( c.moveOutlineUp, nodeupPI, 'Move Node Up' ),
                  ( c.moveOutlineDown, nodedownPI , 'Move Node Down' ),
                  ( c.moveOutlineLeft, nodeleftPI , 'Move Node Left' ),
                  ( c.moveOutlineRight, noderightPI, 'Move Node Right' ),
                  ( c.clone, clonePI , 'Clone Node' ),
                  ( c.copyOutline, copyPI, 'Copy Node' ),
                  ( c.cutOutline, cutPI, 'Cut Node' ),
                  ( c.deleteOutline, deletePI, 'Delete Node' ),
                  ( c.pasteOutline, pastePI , 'Paste Node' ),
                  ( c.pasteOutlineRetainingClones, pasteclonePI, 'Paste Retaining Clones' ),
                  ( c.insertHeadline, insertPI, 'Insert Node' ),
                  ( c.demote, demotePI, 'Demote' ),
                  ( c.promote, promotePI , 'Promote' ) ,
                  ( c.hoist, hoistPI, 'Hoist'),
                  ( c.dehoist, dehoistPI, 'De-Hoist' ),
                  ( c.sortChildren, sortchildrenPI, 'Sort Children' ),
                  ( c.sortSiblings, sortsiblingsPI, 'Sort Siblings' ),
                  ( c.goToPrevSibling, moveupPI, 'Goto Previous Sibling' ),
                  ( c.goToNextSibling, movedownPI, 'Goto Next Sibling' ),
                  ( c.goToParent, moveleftPI, 'Goto Parent' ),
                  ( goToChild, moverightPI, 'Goto Child' ),
                  )
    for i, z in enumerate( bcommands ):
        add( c, mbox ,i, *z )       
    
    if config[ qhelp ] != '0': 
        &lt;&lt; Create the help button &gt;&gt;












</t>
<t tx="ekr.20070127142814.1678">ques = Tk.Button( mbox, image = questionPI, 
    command = lambda c = c, items = bcommands: view_help(c,items) )    
ques.grid( column = i + 1, row = 1 ) 

if int( config[ help ] ):
    addBalloon( mbox, ques, "Help" )

def callback(event,c=c ):
    c.frame.clearStatusLine()
    c.frame.putStatusLine("Open Help Dialog")

ques.bind("&lt;Enter&gt;",callback, '+' )</t>
<t tx="ekr.20070127142814.1679">def add( c, frame, column, command, image, text ):
    '''Add a button to the nodebar'''
    b = Tk.Button( frame, command = command , image = image )
    b[ 'width' ] = image[ 'width' ]
    b[ 'height' ] = image[ 'height' ]
    b[ 'padx' ] = 0
    b[ 'pady' ] = 0
    b.grid( column = column , row = 1)
    if int( config[ help ] ):
        addBalloon( frame, b, text )
    
    def callback(event,c=c,s=text):
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s)
    
    b.bind("&lt;Enter&gt;",callback, '+' )</t>
<t tx="ekr.20070127142814.1680">balloons = {}
def addBalloon( frame, widget, text ):
    '''Help ballon is added to a frame and text is bound to a specific widget'''
    if not balloons.has_key( frame ):
        balloons[ frame ] = Pmw.Balloon( frame )
    
    
    balloon = balloons[ frame ]
    balloon.bind( widget, text )</t>
<t tx="ekr.20070127142814.1681">def view_help( c, items ):
    '''Opens the Help dialog up for the user to view'''
    dialog = Pmw.Dialog( c.frame.top, title = 'Button Help' )
    sf = Pmw.ScrolledFrame( dialog.interior() )
    
    sf.pack()
    sfi = sf.interior()
    
    for z in items:
        lw = Pmw.LabeledWidget( sfi , labelpos = 'e', label_text = z[ 2 ] )
        l = Tk.Button( lw.interior() , image = z[ 1 ] )
        lw.pack()
        l.pack()
        
    dialog.activate()

</t>
<t tx="ekr.20070127142814.1682">config = {}
pos = 'position'
help = 'usehelp'
qhelp = 'qhelp'
config[ pos ] = '1' #The default is to put the bar in the icon area
config[ help ] = '1' #The default is to see the help buttons
def configureNodebar():
    '''nodebar reads what the config file has in it and sets global state'''
    nbar = 'nodebar'
    cparser = readConfigFile()
    if not cparser: return None
    for z in cparser.sections():
        if z.strip() == nbar:
            nbar = z
            break
    if cparser.has_section( nbar ):
        if cparser.has_option( nbar, pos ):
            p = cparser.get( nbar, pos )
            if p.isdigit():
                config[ pos ] = p
            else:
                g.es( "Bad value in nodebar.ini: %s" % p, color= 'red' )
                g.es( "Was expecting a digit", color = 'red' )
        for z in ( help, qhelp ):
            if cparser.has_option( nbar, z ):
                p = cparser.get( nbar, z )
                if p.isdigit():
                    config[ z ] = p
                else:
                    g.es( "Bad value in nodebar.ini: %s" % p, color= 'red' )
                    g.es( "Was expecting a digit", color = 'red' )
            
                





</t>
<t tx="ekr.20070127142814.1683">def readConfigFile ():

    #reads the nodebar config file in.
    pth = os.path.split(g.app.loadDir)   
    aini = pth[0]+r"/plugins/nodebar.ini"
    if not os.path.exists(aini):
        try:
            cf = file( aini, 'w' )#creates config file for user, how nice.
            data='''
[ nodebar ]
position=1
usehelp=1
qhelp=1
            '''
            cf.write( data )
            cf.close()
            g.es( "Added nodebar.ini to plugin directory", color='blue' )
        except Exception, x:
            g.es( "Could not create nodebar.init because of : %s" % x, color='red' )
            return None
    try:
        cp = ConfigParser.ConfigParser()
        cp.read(aini)
        return cp
    except Exception, x:
        g.es( "Could not read nodebar.ini because of : %s "%x, color='red' )
        return None
    

</t>
<t tx="ekr.20070127142814.1684">if load_ok:
    
    configureNodebar()
    if g.app.gui is None: 
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        leoPlugins.registerHandler( ('start2' , 'open2', "new") , addNodeBar )
        __version__ = '.5'
        g.plugin_signon( __name__ )
 
    
</t>
<t tx="ekr.20070127142814.1685">@language python
@tabwidth -4     

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from __future__ import generators # To make the code work in Python 2.2.

import leoGlobals as g

if g.app.config.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import string
import time
import java.util.Iterator as Iterator
import javax.swing.tree as stree
True = 1
False = 0

@others</t>
<t tx="ekr.20070127142814.1686">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="ekr.20070127142814.1687">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
    + a' (1)
    + a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
    + a'
        + b
    + a'
        + b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
    + a'
        + b' (1)
        + b' (2)
    + a'
        + b' (1)
        + b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then converts each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="ekr.20070127142814.1688">class baseTnode:
    """The base class of the tnode class."""
    &lt;&lt; tnode constants &gt;&gt;
    @others
    
class tnode (baseTnode):
    """A class that implements tnodes."""
    pass</t>
<t tx="ekr.20070127142814.1689">dirtyBit    =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  =	0x04
writeBit    = 0x08 # Set: write the tnode.</t>
<t tx="ekr.20070127142814.1690"># All params have defaults, so t = tnode() is valid.

def __init__ (self,bodyString=None,headString=None):

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self.headString = g.toUnicode(headString,g.app.tkEncoding)
    self.bodyString = g.toUnicode(bodyString,g.app.tkEncoding)
    
    self.vnodeList = [] # List of all vnodes pointing to this tnode.
    self._firstChild = None</t>
<t tx="ekr.20070127142814.1691">def __repr__ (self):
    
    return "&lt;tnode %d&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="ekr.20070127142814.1692"></t>
<t tx="ekr.20070127142814.1693">def createUndoInfo (self,copyLinks=True):
    
    """Create a dict containing all info needed to recreate a vnode."""
    
    t = self ; d = {}
    
    # Essential fields.
    d ["t"] = t
    d ["headString"] = t.headString
    d ["bodyString"] = t.bodyString
    d ["vnodeList"]  = t.vnodeList[:]
    d ["statusBits"] = t.statusBits
    d ["firstChild"] = t._firstChild

    try: d ["unknownAttributes"] = t.unknownAttributes
    except: pass
    
    if 0: # These neve change, so no need to save/restore them.
        # In fact, it would be wrong to undo changes made to them!
        d ["cloneIndex"]  = t.cloneIndex
        d ["fileIndex"]  = t.fileIndex

    if 0: # probably not needed for undo.
        d ["insertSpot"]      = t.insertSpot
        d ["scrollBarSpot"]   = t.scrollBarSpot
        d ["selectionLength"] = t.selectionLength
        d ["selectionStart"]  = t.selectionStart

    return d
</t>
<t tx="ekr.20070127142814.1694">def restoreUndoInfo (self,d):
    
    t = d ["t"] ; assert(t == self)

    t.headString  = d ["headString"]
    t.bodyString  = d ["bodyString"]
    t.vnodeList   = d ["vnodeList"]
    t.statusBits  = d ["statusBits"]
    t._firstChild = d ["firstChild"]

    try:
        t.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="ekr.20070127142814.1695"></t>
<t tx="ekr.20070127142814.1696">def getBody (self):

    return self.bodyString</t>
<t tx="ekr.20070127142814.1697">def hasBody (self):

    return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="ekr.20070127142814.1698"></t>
<t tx="ekr.20070127142814.1699">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="ekr.20070127142814.1700">def isRichTextBit (self):

    return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="ekr.20070127142814.1701">def isVisited (self):

    return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="ekr.20070127142814.1702">def isWriteBit (self):

    return (self.statusBits &amp; self.writeBit) != 0</t>
<t tx="ekr.20070127142814.1703"></t>
<t tx="ekr.20070127142814.1704"></t>
<t tx="ekr.20070127142814.1705"># This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    """Set the body text of a tnode to the given string."""
    
    s = g.toUnicode(s,encoding,reportErrors=True)
    
    if 0: # DANGEROUS:  This automatically converts everything when reading files.

        option = g.app.config.trailing_body_newlines
        
        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()

    self.bodyString = s</t>
<t tx="ekr.20070127142814.1706">def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length</t>
<t tx="ekr.20070127142814.1707"></t>
<t tx="ekr.20070127142814.1708">def clearDirty (self):

    self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="ekr.20070127142814.1709">def clearRichTextBit (self):

    self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="ekr.20070127142814.1710">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="ekr.20070127142814.1711">def clearWriteBit (self):

    self.statusBits &amp;= ~ self.writeBit</t>
<t tx="ekr.20070127142814.1712">def setDirty (self):

    self.statusBits |= self.dirtyBit</t>
<t tx="ekr.20070127142814.1713">def setRichTextBit (self):

    self.statusBits |= self.richTextBit</t>
<t tx="ekr.20070127142814.1714">def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20070127142814.1715">def setWriteBit (self):

    self.statusBits |= self.writeBit</t>
<t tx="ekr.20070127142814.1716">def setCloneIndex (self, index):

    self.cloneIndex = index</t>
<t tx="ekr.20070127142814.1717">def setFileIndex (self, index):

    self.fileIndex = index</t>
<t tx="ekr.20070127142814.1718">class baseVnode:
    """The base class of the vnode class."""
    &lt;&lt; vnode constants &gt;&gt;
    @others
    
class vnode (baseVnode):
    """A class that implements vnodes."""
    pass</t>
<t tx="ekr.20070127142814.1719"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # True: vnode has clone mark.

# not used	 = 0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit	  = 0x08 # True: vnode is marked
orphanBit	  = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
topBit		    = 0x40 # True: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit	 = 0x100
</t>
<t tx="ekr.20070127142814.1720"></t>
<t tx="ekr.20070127142814.1721">if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1</t>
<t tx="ekr.20070127142814.1722">def __init__ (self,c,t):

    assert(t)
    &lt;&lt; initialize vnode data members &gt;&gt;</t>
<t tx="ekr.20070127142814.1723">self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None</t>
<t tx="ekr.20070127142814.1724">def __repr__ (self):
    
    if self.t:
        return "&lt;vnode %d:'%s'&gt;" % (id(self),self.cleanHeadString())
    else:
        return "&lt;vnode %d:NULL tnode&gt;" % (id(self))
        
__str__ = __repr__</t>
<t tx="ekr.20070127142814.1725">def dumpLink (self,link):
    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v</t>
<t tx="ekr.20070127142814.1726"></t>
<t tx="ekr.20070127142814.1727">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="ekr.20070127142814.1728">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="ekr.20070127142814.1729"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="ekr.20070127142814.1730">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="ekr.20070127142814.1731">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="ekr.20070127142814.1732">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="ekr.20070127142814.1733">def isAtIgnoreNode (self):  

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="ekr.20070127142814.1734">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="ekr.20070127142814.1735">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="ekr.20070127142814.1736"></t>
<t tx="ekr.20070127142814.1737"></t>
<t tx="ekr.20070127142814.1738"># Compatibility routine for scripts

def back (self):

    return self._back</t>
<t tx="ekr.20070127142814.1739"># Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next</t>
<t tx="ekr.20070127142814.1740"></t>
<t tx="ekr.20070127142814.1741">def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n</t>
<t tx="ekr.20070127142814.1742">def firstChild (self):
    
    return self.t._firstChild</t>
<t tx="ekr.20070127142814.1743">def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren</t>
<t tx="ekr.20070127142814.1744">def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child</t>
<t tx="ekr.20070127142814.1745"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n &gt; 0 and child:
        n -= 1
        child = child.next()
    return child</t>
<t tx="ekr.20070127142814.1746">def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n</t>
<t tx="ekr.20070127142814.1747"></t>
<t tx="ekr.20070127142814.1748">def isCloned (self):
    
    return len(self.t.vnodeList) &gt; 1</t>
<t tx="ekr.20070127142814.1749">def isDirty (self):

    return self.t.isDirty()</t>
<t tx="ekr.20070127142814.1750">def isExpanded (self):

    return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="ekr.20070127142814.1751">def isMarked (self):

    return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="ekr.20070127142814.1752">def isOrphan (self):

    return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="ekr.20070127142814.1753">def isSelected (self):

    return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="ekr.20070127142814.1754">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="ekr.20070127142814.1755">def isVisited (self):

    return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="ekr.20070127142814.1756">def status (self):

    return self.statusBits</t>
<t tx="ekr.20070127142814.1757"># Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "Leo internal error: not unicode:" + repr(self.t.bodyString)
        print s ; g.es(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
</t>
<t tx="ekr.20070127142814.1758">def currentPosition (self):
    return self.c.currentPosition()
        
def currentVnode (self):
    return self.c.currentVnode()</t>
<t tx="ekr.20070127142814.1759">def findRoot (self):
    
    return self.c.rootPosition()</t>
<t tx="ekr.20070127142814.1760">def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        print s ; g.es(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'</t>
<t tx="ekr.20070127142814.1761">def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []</t>
<t tx="ekr.20070127142814.1762"># These remain in 4.2: the file read logic calls these before creating positions.</t>
<t tx="ekr.20070127142814.1763">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAfter(self)

    return v</t>
<t tx="ekr.20070127142814.1764">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAsNthChild(self,n)

    return v</t>
<t tx="ekr.20070127142814.1765">def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
</t>
<t tx="ekr.20070127142814.1766">def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v</t>
<t tx="ekr.20070127142814.1767">def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self ; c = v.c

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v

    newRoot = position(v,[])
    c.setRootPosition(newRoot)</t>
<t tx="ekr.20070127142814.1768">def moveToRoot (self,oldRoot=None):

    """Moves the receiver to the root position"""

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v</t>
<t tx="ekr.20070127142814.1769">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self ; c = v.c

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
    
    # Special case the root.
    if v == c.rootPosition().v: # 3/11/04
        assert(v._next)
        newRoot = position(v._next,[])
        c.setRootPosition(newRoot)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="ekr.20070127142814.1770"></t>
<t tx="ekr.20070127142814.1771"></t>
<t tx="ekr.20070127142814.1772">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20070127142814.1773">def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    g.trace()
    v = self ; c = v.c
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons</t>
<t tx="ekr.20070127142814.1774">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20070127142814.1775">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="ekr.20070127142814.1776">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="ekr.20070127142814.1777">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

def expand(self):

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="ekr.20070127142814.1778">def initStatus (self, status):

    self.statusBits = status</t>
<t tx="ekr.20070127142814.1779">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="ekr.20070127142814.1780">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20070127142814.1781">def setOrphan (self):

    self.statusBits |= self.orphanBit</t>
<t tx="ekr.20070127142814.1782"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit</t>
<t tx="ekr.20070127142814.1783"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit</t>
<t tx="ekr.20070127142814.1784">def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20070127142814.1785">def initHeadString (self,s,encoding="utf-8"):
    
    v = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s</t>
<t tx="ekr.20070127142814.1786">def setSelection (self, start, length):

    self.t.setSelection ( start, length )</t>
<t tx="ekr.20070127142814.1787">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)</t>
<t tx="ekr.20070127142814.1788">def trimTrailingLines (self):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    v = self
    body = v.bodyString()
    # g.trace(body)
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        v.setBodyStringOrPane(body)
        # Don't set the dirty bit: it would just be annoying.
</t>
<t tx="ekr.20070127142814.1789"></t>
<t tx="ekr.20070127142814.1790">def createUndoInfo (self):
    
    """Create a dict containing all info needed to recreate a vnode for undo."""
    
    v = self ; d = {}
    
    # Copy all ivars.
    d ["v"] = v
    d ["statusBits"] = v.statusBits
    d ["parent"] = v._parent
    d ["next"] = v._next
    d ["back"] = v._back
    # The tnode never changes so there is no need to save it here.
    
    try: d ["unknownAttributes"] = v.unknownAttributes
    except: pass

    return d</t>
<t tx="ekr.20070127142814.1791">def restoreUndoInfo (self,d):
    
    """Restore all ivars saved in dict d."""
    
    v = d ["v"] ; assert(v == self)

    v.statusBits = d ["statusBits"]
    v._parent    = d ["parent"] 
    v._next      = d ["next"] 
    v._back      = d ["back"]
    
    try:
        v.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass</t>
<t tx="ekr.20070127142814.1792"></t>
<t tx="ekr.20070127142814.1793">def subtree_iter(self):

    """Return all nodes of self's tree in outline order."""
    
    v = self
         
    if v:
        yield v
        child = v.t._firstChild
        while child:
            for v1 in child.subtree_iter():
                yield v1
            child = child.next()
            
self_and_subtree_iter = subtree_iter</t>
<t tx="ekr.20070127142814.1794">def unique_subtree_iter(self,marks=None):

    """Return all vnodes in self's tree, discarding duplicates """
    
    v = self
    if marks == None: marks = {}
    
    
    if v and v not in marks:
        marks[v] = v
        yield v
        if v.t._firstChild:
            for v1 in v.t._firstChild.unique_subtree_iter(marks):
                yield v1
        v = v._next
        while v:
            for v in v.unique_subtree_iter(marks):
                yield v
            v = v._next
            
self_and_unique_subtree_iter = unique_subtree_iter</t>
<t tx="ekr.20070127142814.1795"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices:
    
    """A class to implement global node indices (gnx's)."""
    
    @others
</t>
<t tx="ekr.20070127142814.1796">def __init__ (self):
    
    """ctor for nodeIndices class"""

    self.userId = g.app.leoID # 5/1/03: This never changes.
    self.defaultId = g.app.leoID # This probably will change.
    self.lastIndex = None
    self.timeString = None</t>
<t tx="ekr.20070127142814.1797">def areEqual (self,gnx1,gnx2):
    
    """Return True if all fields of gnx1 and gnx2 are equal"""

    # works whatever the format of gnx1 and gnx2.
    # This should never throw an exception.
    return gnx1 == gnx2
    
    id1,time1,n1 = gnx1
    id2,time2,n2 = gnx2
    # g.trace(id1==id2 and time1==time2 and n1==n2,gnx1,gnx2)
    return id1==id2 and time1==time2 and n1==n2</t>
<t tx="ekr.20070127142814.1798"># These are used by the fileCommands read/write code.

def getDefaultId (self):
    
    """Return the id to be used by default in all gnx's"""
    return self.defaultId
    
def setDefaultId (self,id):
    
    """Set the id to be used by default in all gnx's"""
    self.defaultId = id
</t>
<t tx="ekr.20070127142814.1799">def getNewIndex (self):
    
    """Create a new gnx using self.timeString and self.lastIndex"""
    
    id = self.userId # Bug fix 5/1/03: always use the user's id for new ids!
    t = self.timeString
    assert(t)
    n = None

    # Set n if id and time match the previous index.
    last = self.lastIndex
    if last:
        lastId,lastTime,lastN = last
        if id==lastId and t==lastTime:
            if lastN == None: n = 1
            else: n = lastN + 1

    d = (id,t,n)
    self.lastIndex = d
    # g.trace(d)
    return d</t>
<t tx="ekr.20070127142814.1800">def isGnx (self,gnx):
    try:
        id,t,n = gnx
        return t != None
    except:
        return False</t>
<t tx="ekr.20070127142814.1801">def scanGnx (self,s,i):
    
    """Create a gnx from its string representation"""
    
    if type(s) not in (type(""),type(u"")):
        g.es("scanGnx: unexpected index type:",type(s),s,color="red")
        return None,None,None
        
    s = s.strip()

    id,t,n = None,None,None
    i,id = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if id == None or len(id) == 0:
        id = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except: pass

    return id,t,n</t>
<t tx="ekr.20070127142814.1802">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())</t>
<t tx="ekr.20070127142814.1803">def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    id,t,n = index

    if removeDefaultId and id == self.defaultId:
        id = ""

    if not n: # None or ""
        return "%s.%s" % (id,t)
    else:
        return "%s.%s.%d" % (id,t,n)</t>
<t tx="ekr.20070127142814.1804"># Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position( stree.TreeNode ):
    
    """A class representing a position in a traversal of a tree containing shared tnodes."""

    &lt;&lt; about the position class &gt;&gt;
    
    @others
</t>
<t tx="ekr.20070127142814.1805">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="ekr.20070127142814.1806"></t>
<t tx="ekr.20070127142814.1807">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="ekr.20070127142814.1808">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        elif attr=="__del__":
            # This works around a Python 2.2 wierdness.
            return AttributeError # Silently ignore this.
        else:
            # Only called when normal lookup fails.
            print "unknown position attribute:",attr
            import traceback ; traceback.print_stack()
            raise AttributeError</t>
<t tx="ekr.20070127142814.1809">def __init__ (self,v,stack,trace=True):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="ekr.20070127142814.1810">@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None</t>
<t tx="ekr.20070127142814.1811">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="ekr.20070127142814.1812"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    #if g.app.tracePositions:
    #    g.trace("%-25s %-25s %s" % (
    #        g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)</t>
<t tx="ekr.20070127142814.1813">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="ekr.20070127142814.1814">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition() ; root = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert p.equal(p.copy()) is True
    &gt;&gt;&gt; assert p.equal(root) is False
    &gt;&gt;&gt; assert g.app.positions == n + 1
    &gt;&gt;&gt; 
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
__eq__ = equal
#def __hash__( self ):
#    print "HASHING"
#    return self.hashCode()

def __ne__( self, x ): #wont work without
    if self is x: return False
    else: return True
    
#def __ne__( self, x ):
#    print 'NE executing for %s' % self
#    return True
    
def toString( self ):

    try:
        return self.headString()
    except:
        return ""
        
    




</t>
<t tx="ekr.20070127142814.1815">@others</t>
<t tx="ekr.20070127142814.1816">def children( self ):
    
    class _en( util.Enumeration ):
        
        def __init__( self, iter ):
            self.iter = iter
            try:
                self.next = iter.next()
            except:
                pass
        
        def hasMoreElements( self ):
            if self.next: return True
            else:
                return False
            
        def nextElement( self ):
            
            try:
                print "CHILD:"
                print self.next
                nx = self.next
                self.next = self.iter.next()
            finally:
                return nx
                   
    return _en( self.children_iter() )</t>
<t tx="ekr.20070127142814.1817">def getAllowsChildren( self ):
    return True
    
</t>
<t tx="ekr.20070127142814.1818">def getChildAt( self, n ):
    print 'getChildAt'
    return self.getNthChild( n )
    
</t>
<t tx="ekr.20070127142814.1819">def getChildCount( self ):
    print 'getChildCount'
    try:
        return self.numberOfChildren()
    except:
        return 0
    
</t>
<t tx="ekr.20070127142814.1820">def getIndex( self, item ):
    print 'getIndex'
    i = 0
    for z in self.children_iter():
        if z == item:
            return i
        i = i + 1
    return -1    </t>
<t tx="ekr.20070127142814.1821">#def getParent( self ): 'already defined later'
#    print 'PARENT'
#    return self._parent
    

</t>
<t tx="ekr.20070127142814.1822">def isLeaf( self ):
    print 'isLeaf'
    try:
        if self.numberOfChildren() &gt; 0: return True
        else:
            return False
    except:
        return True
    
    
        
</t>
<t tx="ekr.20070127142814.1823"></t>
<t tx="ekr.20070127142814.1824"></t>
<t tx="ekr.20070127142814.1825">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20070127142814.1826">def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)</t>
<t tx="ekr.20070127142814.1827">def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
</t>
<t tx="ekr.20070127142814.1828">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()</t>
<t tx="ekr.20070127142814.1829">def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)</t>
<t tx="ekr.20070127142814.1830">def directParents (self):
    
    return self.v.directParents()
</t>
<t tx="ekr.20070127142814.1831">def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n</t>
<t tx="ekr.20070127142814.1832"></t>
<t tx="ekr.20070127142814.1833">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="ekr.20070127142814.1834">def numberOfChildren (self):
    
    return self.v.numberOfChildren()
</t>
<t tx="ekr.20070127142814.1835">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()
    
    # This code must be fast.
    root = c.rootPosition()
    while p:
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False</t>
<t tx="ekr.20070127142814.1836">def findRoot (self):
    
    return self.c.frame.rootPosition()</t>
<t tx="ekr.20070127142814.1837"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self):
    #try:
    rt = self.copy().moveToParent() 
	#    return rt
    #except:
    #return self.c.frame.tree.posTM._root
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="ekr.20070127142814.1838">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="ekr.20070127142814.1839">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20070127142814.1840">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20070127142814.1841"></t>
<t tx="ekr.20070127142814.1842">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="ekr.20070127142814.1843">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="ekr.20070127142814.1844">def isCloned (self):
    
    return len(self.v.t.vnodeList) &gt; 1</t>
<t tx="ekr.20070127142814.1845">def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()</t>
<t tx="ekr.20070127142814.1846">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="ekr.20070127142814.1847">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20070127142814.1848">def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level += 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level</t>
<t tx="ekr.20070127142814.1849"></t>
<t tx="ekr.20070127142814.1850"></t>
<t tx="ekr.20070127142814.1851"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    g.doHook("clear-mark",c=self.c,p=self)
    return self.v.clearMarked()

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
    
def setMarked (self):
    g.doHook("set-mark",c=self.c,p=self)
    return self.v.setMarked()

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="ekr.20070127142814.1852">def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20070127142814.1853">def setSelection (self,start,length):

    return self.v.setSelection(start,length)</t>
<t tx="ekr.20070127142814.1854">def trimTrailingLines (self):

    return self.v.trimTrailingLines()</t>
<t tx="ekr.20070127142814.1855">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)</t>
<t tx="ekr.20070127142814.1856"></t>
<t tx="ekr.20070127142814.1857">def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)</t>
<t tx="ekr.20070127142814.1858">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20070127142814.1859">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20070127142814.1860">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20070127142814.1861">def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)</t>
<t tx="ekr.20070127142814.1862"></t>
<t tx="ekr.20070127142814.1863"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="ekr.20070127142814.1864"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20070127142814.1865">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="ekr.20070127142814.1866"></t>
<t tx="ekr.20070127142814.1867">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20070127142814.1868">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20070127142814.1869">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count += 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed</t>
<t tx="ekr.20070127142814.1870"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20070127142814.1871">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20070127142814.1872">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20070127142814.1873">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20070127142814.1874">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20070127142814.1875">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="ekr.20070127142814.1876">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20070127142814.1877">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="ekr.20070127142814.1878">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="ekr.20070127142814.1879">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20070127142814.1880">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20070127142814.1881">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20070127142814.1882">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20070127142814.1883">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20070127142814.1884">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20070127142814.1885">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20070127142814.1886">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20070127142814.1887">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20070127142814.1888">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20070127142814.1889">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20070127142814.1890">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20070127142814.1891">class siblings_iter_class:

    """Returns a list of siblings of a position."""  

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20070127142814.1892">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20070127142814.1893">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20070127142814.1894"></t>
<t tx="ekr.20070127142814.1895">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="ekr.20070127142814.1896">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20070127142814.1897">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20070127142814.1898">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="ekr.20070127142814.1899">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="ekr.20070127142814.1900">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="ekr.20070127142814.1901"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20070127142814.1902">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="ekr.20070127142814.1903">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="ekr.20070127142814.1904">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20070127142814.1905">def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index += 1</t>
<t tx="ekr.20070127142814.1906"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="ekr.20070127142814.1907">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="ekr.20070127142814.1908">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20070127142814.1909">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20070127142814.1910">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="ekr.20070127142814.1911">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20070127142814.1912">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="ekr.20070127142814.1913">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="ekr.20070127142814.1914">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="ekr.20070127142814.1915">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="ekr.20070127142814.1916">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="ekr.20070127142814.1917">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20070127142814.1918">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="ekr.20070127142814.1919">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    # if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)
            
    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p

</t>
<t tx="ekr.20070127142814.1920">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="ekr.20070127142814.1921">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="ekr.20070127142814.1922">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="ekr.20070127142814.1923">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="ekr.20070127142814.1924"></t>
<t tx="ekr.20070127142814.1925"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="ekr.20070127142814.1926">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20070127142814.1927">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="ekr.20070127142814.1928">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20070127142814.1929">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="ekr.20070127142814.1930">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20070127142814.1931"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="ekr.20070127142814.1932">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="ekr.20070127142814.1933">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20070127142814.1934">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="ekr.20070127142814.1935">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
</t>
<t tx="ekr.20070127142814.1936">@first #! /usr/bin/env python

"""Entry point for Leo in Python."""   

@language python     
@tabwidth -4

&lt;&lt; Import pychecker &gt;&gt;

# Suppress import errors.
# This module must do strange things with imports.
__pychecker__ = '--no-import --no-reimportself --no-reimport '

# Warning: do not import any Leo modules here!
# Doing so would make g.app invalid in the imported files.
import os
import string
import sys
True = 1
False = 0

@others

if __name__ == "__main__":
    if len(sys.argv) &gt; 1:
        if sys.platform=="win32": # Windows
            fileName = string.join(sys.argv[1:],' ')
        else:
            fileName = sys.argv[1]
        run(fileName)
    else:
        run()



</t>
<t tx="ekr.20070127142814.1937">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass</t>
<t tx="ekr.20070127142814.1938">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    if not isValidPython(): return
    # Import leoGlobals, but do NOT set g.
    import leoGlobals
    # Create the application object.
    import leoApp ; leoGlobals.app = leoApp.LeoApp()
    g = leoGlobals ; assert(g.app) # NOW we can set g.
    g.app.loadDir = computeLoadDir() # Depends on g.app.tkEncoding: uses utf-8 for now.
    import leoConfig
    g.app.config = leoConfig.config()
    g.app.setEncoding() # 10/20/03: do this earlier
    script = getBatchScript()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    else:
        &lt;&lt; print encoding info &gt;&gt;
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    #if g.app.gui == "swing" :
    #    g.app.createSwingGui()
    if g.app.gui == None:
        #g.app.createTkGui()
        g.app.createSwingGui()
    if g.app.use_gnx:
        if not g.app.leoID: g.app.setLeoID() # Forces the user to set g.app.leoID.
        import leoNodes
        g.app.nodeIndices = leoNodes.nodeIndices()
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    &lt;&lt; start psycho &gt;&gt;
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    v = c.currentVnode()
    #g.doHook("start2",c=c,v=v,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    g.app.gui.runMainLoop()
    

</t>
<t tx="ekr.20070127142814.1939">g.es("leoConfig.txt encoding: " + g.app.config.config_encoding, color="blue")

if 0: # This is just confusing for users.
    g.es("Text encoding: " + g.app.tkEncoding, color="blue")</t>
<t tx="ekr.20070127142814.1940">if g.app.config.use_psyco:
    try:
        import psyco
        if 0:
            file = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",file,color="blue")
            psyco.log(file)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="ekr.20070127142814.1941">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except Exception, x:
        print message
        return 0
    try:
        ok = True
        return ok
    except:
        print "exception getting Python version"
        import traceback ; traceback.print_exc()
        return False</t>
<t tx="ekr.20070127142814.1942">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding)
    
    try:
        import leo
        path = g.os_path_abspath(leo.__file__)

        if sys.platform=="win32": # "mbcs" exists only on Windows.
            path = g.toUnicode(path,"mbcs")
        elif sys.platform=="dawwin":
            path = g.toUnicode(path,"utf-8")
        else:
            path = g.toUnicode(path,g.app.tkEncoding)

        if path:
            loadDir = g.os_path_dirname(path)
        else:
            loadDir = None
        if not loadDir:
            loadDir = g.os_path_abspath(os.getcwd())
            print "Using emergency loadDir:",repr(loadDir)

        encoding = g.choose(sys.platform=="dawwin","utf-8",g.app.tkEncoding) # 11/18/03
        loadDir = g.toUnicode(loadDir,encoding) # 10/20/03
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None</t>
<t tx="ekr.20070127142814.1943">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(g.app.tkEncoding,fileName)
    
    # Try to create a frame for the file.
    if fileName:
        fileName = g.os_path_join(os.getcwd(),fileName)
        fileName = g.os_path_normpath(fileName)
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a new frame &amp; indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    
    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20070127142814.1944">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20070127142814.1945">def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name: return None	
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script</t>
<t tx="ekr.20070127142814.1946">@ To gather statistics, do the following in a Python window, not idle:

    import leo
    leo.profile()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile ():
    
    """Gather and print statistics about Leo"""

    import profile, pstats
    
    name = "c:/prog/test/leoProfile.txt"
    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('cum','file','name')
    p.print_stats()</t>
<t tx="ekr.20070127142814.1947">
@language python
&lt;&lt; fastGotoNode declarations &gt;&gt;
@others
            
   


if 1:
    calculateMenuSize()
    registerHandler( ('start2' , 'open2', 'new') , registerPopupMenu )
    __version__ = ".99"
    plugin_signon(__name__)
    pth = os.path.split( app.loadDir )
    lkpm = pth[ 0 ] + r"/plugins/fgn.fgn" 
    if os.path.exists( lkpm ):
        loadLanguages( lkpm )


















</t>
<t tx="ekr.20070127142814.1948">''' A Leo plugin that adds quick Utility commands through a pop-up menu.  To summon Menu,
Control - Space must be typed. To Unsummon, Right Click.  It offers 3 main feature sets:
1. Movement.  If a node has ancestors,siblings or children a menu option will appear offering the
user the ability to jump to the node from the current node.  This is an improvement over moving one node at a time with the keyboard commands. 2. Inserting text.  These menus offer the current language keywords, the directives the body recognizes and any @file type headline directives.  It offers the new user easy access to the different directives and ways to write a file. 3. Moving Nodes( experimental feature ).  You can quickly move a node to its parent's parent or after a sibling, if they exist.'''
from leoPlugins import *
from leoGlobals import *  
from leoNodes import *  
import Tkinter
import tkFileDialog
import os 


</t>
<t tx="ekr.20070127142814.1949">smenu = Tkinter.Menu( tearoff = 0, activeforeground = 'blue' , activebackground = 'white')   
maxmenu = 0
menus = []



def disappear( event , c):
    smenu.unpost()
    smenu.unbind_all("&lt;Button-3&gt;") 
    c.frame.body.bodyCtrl.focus_set()
</t>
<t tx="ekr.20070127142814.1950">lastwidg = None
def pop( event , c ):
    clear()    
    needs_sep = needsSeparator( smenu )
    
    def addMenu( label , menu ):
        menus.append( menu )
        needs_sep.next()
        smenu.add_cascade( label = label, menu = menu )
        menu.configure( activeforeground = 'blue', activebackground = 'white' )
        def em( event ): 
            smenu.focus_set()
        menu.bind( '&lt;Expose&gt;', em ) 

    smenu.bind('&lt;Left&gt;', lambda event, c = c: disappear( event, c ) )
 
              
    ancmenu = getAncestorsMenu( smenu, c )
    if ancmenu:
        addMenu( 'Ancestors', ancmenu )
        
    sibmenu = getSiblingsMenu( smenu, c )
    if sibmenu:
        addMenu( 'Siblings', sibmenu )
        
    chimenu = getChildrenMenu( smenu, c )
    if chimenu:
        addMenu( 'Children', chimenu )
         
    winmenu = getWindowMenu( smenu, c )
    if winmenu:
        addMenu( 'Windows', winmenu )
                
    srmenu = getSectionReferenceMenu( smenu, c ) 
    if srmenu:
        addMenu( 'Insert '+ '&lt;' +'&lt; '+'&gt;'+'&gt;' , srmenu ) 
    
    menu , language = addLanguageMenu( smenu , c )
    if menu:
        addMenu( language, menu )
         
    dimenu = getDirectiveInsert( smenu, c )
    addMenu( 'Directives', dimenu ) 
    
    hmenu = getHeadlineMenu( smenu, c )
    addMenu( 'Headline', hmenu )
    
    mvamenu = getMoveAMenu( smenu, c )
    if mvamenu: addMenu( "Mv_Ancestor", mvamenu )
    
    mvsmenu = getMoveSMenu( smenu, c )
    if mvsmenu: addMenu( "Mv_Sibling", mvsmenu )
    

    smenu.bind_all("&lt;Button-3&gt;", lambda event, c = c :disappear( event, c )  ) 
    smenu.post( event.x_root , event.y_root)
    smenu.focus_set()
     
</t>
<t tx="ekr.20070127142814.1951">def getSectionReferenceMenu( pmenu, c ):
    pos = c.currentPosition()
    nc = pos.numberOfChildren()
    import re
    reg = re.compile( "^&lt;"+"&lt;.+?&gt;"+"&gt;$")
    srefs = []
    for z in xrange( nc ):
        chi = pos.nthChild( z )
        hl = chi.headString()
        if reg.match( hl ):
            srefs.append( hl )
    
    srmenu = None       
    if len( srefs ):
        srefs.sort() 
        srmenu = Tkinter.Menu( pmenu, tearoff= 0 )
        sb = shouldBreak()
        for z in srefs:
            srmenu.add_command( 
                label = z , 
                command = lambda label = z ,c = c :
                paster( label , c , ''), columnbreak = sb.next() )
                
    return srmenu
</t>
<t tx="ekr.20070127142814.1952">def getWindowMenu( pmenu , c ):
    import copy
    wl = copy.copy( windows() )
    wl.remove( c.frame )
    winmenu = None
    if len( wl ) != 0:
        winmenu = Tkinter.Menu( pmenu, tearoff = 0 )
        def bTF( frame ):
            frame.bringToFront()
            app.setLog( frame.log )
            frame.bodyCtrl.focus_set()
            clear()
        sb = shouldBreak()
        for z in wl:
            winmenu.add_command( 
                label = z.getTitle(), 
                command = lambda frame = z: bTF( frame ) , 
                columnbreak = sb.next() )
    return winmenu
</t>
<t tx="ekr.20070127142814.1953">def getChildrenMenu( pmenu, c ):
    pos = c.currentPosition()
    nchildren = pos.numberOfChildren()
    chimenu = None
    if nchildren &gt; 0 :
        chimenu = Tkinter.Menu( pmenu, tearoff = 0 ) 
        sb = shouldBreak() 
        childnames = []
        children = {}
        for z in xrange( pos.numberOfChildren() ):
            child = pos.nthChild( z )
            hs = child.headString()
            childnames.append( hs )
            children[ hs ] = child
        childnames.sort()
        def adder( a ):
            hs = a
            child = children[ hs ]
            chimenu.add_command( 
                label = hs , 
                command = lambda pos = child, c = c:
                jumpto(pos , c ) , 
                columnbreak = sb.next() )
        map( adder, childnames )        
    return chimenu
</t>
<t tx="ekr.20070127142814.1954">def getSiblingsMenu( pmenu, c ):
    siblings = []
    pos = c.currentPosition()
    siblings = getSiblingList( pos)
    sibmenu = None
    def sorSibs( a, b ):
        if a.headString() &gt; b.headString() : return 1
        elif a.headString() &lt; b.headString() : return -1
        return 0
    siblings.sort( sorSibs )
    if len( siblings ) != 0:        
        sibmenu = Tkinter.Menu(pmenu, tearoff = 0)  
        sb = shouldBreak()
        for z in siblings:
            hs = z.headString()
            sibmenu.add_command( 
                label = hs , 
                command = lambda pos = z, c = c:
                jumpto( pos, c ) , 
                columnbreak = sb.next() )
                
    return sibmenu    
</t>
<t tx="ekr.20070127142814.1955">def getSiblingList( pos ):
    
    siblings = []
    pnod = pos.back()
    while pnod:
        siblings.append( pnod )
        pnod = pnod.back()
    siblings.reverse()
    nnod = pos.next()
    while nnod:
        siblings.append( nnod )
        nnod = nnod.next()
    return siblings</t>
<t tx="ekr.20070127142814.1956">def getAncestorsMenu( pmenu, c ):
        ancmenu = None
        alist = getAncestorList( c.currentPosition() )
        if alist:
            ancmenu = Tkinter.Menu( pmenu, tearoff = 0 )
            sb = shouldBreak()
            for z in alist:
                hs = z.headString()
                ancmenu.add_command( 
                    label = hs , 
                    command = lambda  parent = z, c = c: 
                    jumpto( parent , c ), 
                    columnbreak = sb.next() )

        return ancmenu
</t>
<t tx="ekr.20070127142814.1957">def getAncestorList( p ):
    
    alist = []
    parent = p.parent()
    while parent:
        alist.append( parent )        
        parent = parent.parent()
    return alist</t>
<t tx="ekr.20070127142814.1958">def addLanguageMenu( pmenu , c , haveseen = {}):
    colorizer = c.frame.body.getColorizer()
    if colorizer.language:
        if not haveseen.has_key( colorizer.language ): 
            lk = colorizer.language + '_keywords'
            kwords = list( getattr( colorizer , lk ) )
            if langdict.has_key( colorizer.language ):
                l = langdict[ colorizer.language ]
                for z in l:
                    kwords.append( z )
                kwords.sort()
        else:
            kwords = haveseen[ colorizer.language ] 
        lmenu = Tkinter.Menu( pmenu, tearoff = 0 ) 
        sb = shouldBreak()
        for z in kwords:
            lmenu.add_command( 
                label = z , 
                command = lambda keyword = z , c = c : 
                paster( keyword , c ) ,
                columnbreak = sb.next() )
                
        return lmenu , colorizer.language
    else: return None , None
</t>
<t tx="ekr.20070127142814.1959">def getMoveAMenu( pmenu, c ):
    
    mvmenu = None

    def mvchild( p, p2 , c = c ):
        c.beginUpdate()
        p.moveToNthChildOf( p2, 0 )
        c.endUpdate()
        
    pos = c.currentPosition()
    alist = getAncestorList( pos )
    if alist: alist.pop( 0 )
    if alist:
        mvmenu = Tkinter.Menu( pmenu, tearoff = 0 )
        sb = shouldBreak()
        for z in alist:    
            hs = z.headString()
            mvmenu.add_command( 
                label = hs , 
                command = lambda p = pos, p2 = z: 
                mvchild( p, p2 ),
                columnbreak = sb.next() )
    return mvmenu
</t>
<t tx="ekr.20070127142814.1960">def getMoveSMenu( pmenu , c):
    
    smenu = None
    pos = c.currentPosition()
    sibs = getSiblingList( pos )
    bk = pos.back()
    if bk: sibs.remove( bk )
    def mafter( p, p2, c = c ):
        c.beginUpdate()
        p.moveAfter( p2 )
        c.endUpdate()
    if sibs:
        smenu = Tkinter.Menu( pmenu, tearoff = 0 )
        sb = shouldBreak()
        for z in sibs:
            smenu.add_command( label = z.headString(), 
                            command = lambda p = pos, p2 = z: mafter( p, p2 ),
                            columnbreak = sb.next() ) 

    return smenu</t>
<t tx="ekr.20070127142814.1961">def needsSeparator( menu ):
    yield None
    while 1:
        menu.add_separator()
        yield None
</t>
<t tx="ekr.20070127142814.1962">def shouldBreak():
    i = 0
    while 1:
        i += 1
        if i == maxmenu:
            i = 0
            yield True
        else: yield False
</t>
<t tx="ekr.20070127142814.1963">def getDirectiveInsert( pm, c , directives = [], directives2= []):
    m = Tkinter.Menu( pm, tearoff = 0 )
    sb = shouldBreak()
    if len( directives ) == 0:
        import leoColor 
        for z in leoColor.leoKeywords:
            directives.append( z )
        directives.sort()                                      
    for z in directives:
       m.add_command( 
          label = z , 
          columnbreak = sb.next(),  
          command = lambda label = z, c = c: 
          paster( label , c ) )

    return m
</t>
<t tx="ekr.20070127142814.1964">def getHeadlineMenu( pmenu, c ):
    
    pos = c.currentPosition()
    v = pos.v
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    names.sort()
    hmenu = Tkinter.Menu( pmenu , tearoff = 0)
    hmenu.add_command( 
        label = 'add &lt;'+'&lt;'+'&gt;'+'&gt;', 
        command = lambda c = c: addGL( c ) )
    hmenu.add_separator()
    for z in names:
        hmenu.add_command( label = z, 
                            command = lambda c = c, d = z , nm = names:
                                setFileDirective( c, d, nm ) )
    hmenu.add_separator()
    hmenu.add_command( label = 'remove @', command = lambda c = c, nm = names:
                                            removeFileDirective( c, nm ) )
    return hmenu

</t>
<t tx="ekr.20070127142814.1965">def setFileDirective( c , directive, names ):
    
    pos = c.currentPosition()
    hS = pos.headString()
    hS = getCleanHeadString( hS, names )
    hS = directive + " " + hS
    c.beginUpdate()
    pos.setHeadString( hS )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()
    
   

</t>
<t tx="ekr.20070127142814.1966">def removeFileDirective( c , names ):

    pos = c.currentPosition()
    hS = pos.headString()
    hS = getCleanHeadString( hS , names )
    c.beginUpdate()
    pos.setHeadString( hS )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.1967">def getCleanHeadString( hS, names ):

    def sT( a, b ):
        if len( a ) &gt; len( b ): return -1
        if len( a ) &lt; len( b ): return 1
        return 0
    names = list( names )
    names.sort( sT )
    for z in names:
        hS2 = hS.lstrip()
        if hS2.startswith( z ):
            hS = hS2.lstrip( z )
            hS = hS.lstrip()
            return hS
    return hS</t>
<t tx="ekr.20070127142814.1968">def addGL( c ):
    vnode = c.currentVnode()
    hs = vnode.headString()
    nhs = "&lt;"+"&lt;" + hs + "&gt;"+"&gt;"
    c.beginUpdate()
    vnode.setHeadString( nhs )
    c.frame.body.bodyCtrl.focus_set()  
    c.frame.body.bodyCtrl.update_idletasks() 
    c.endUpdate()

</t>
<t tx="ekr.20070127142814.1969">def insertHeadline( directive , c ):
    vnode = c.currentVnode()
    hs = vnode.headString()
    nhs = directive + " " + hs
    c.beginUpdate()
    vnode.setHeadString( nhs )
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.1970">def paster( directive , c ,  end = ' ' ):
    bdy = c.frame.body
    c.beginUpdate()
    bdy.insertAtInsertPoint( directive + end)
    bdy.onBodyChanged( c.currentVnode() , None ) 
    bdy.bodyCtrl.focus_set()  
    bdy.bodyCtrl.update_idletasks() 
    c.endUpdate()                        
    bdy.bodyCtrl.focus_set()</t>
<t tx="ekr.20070127142814.1971">def clear():
    global menus
    smenu.delete( 0 , Tkinter.END )
    for z in menus:
        z.destroy()
    menus = []
</t>
<t tx="ekr.20070127142814.1972">def jumpto( vnode, c):    
    smenu.unpost()
    c.beginUpdate()
    c.frame.tree.expandAllAncestors( vnode )
    c.selectVnode( vnode )
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.1973">def registerPopupMenu( tag, keywords):
    c = top()
    def popper( event , c = c ):
        pop( event, c )
    c.frame.top.bind( binder , popper)
</t>
<t tx="ekr.20070127142814.1974">def calculateMenuSize():
    global maxmenu
    x = Tkinter.Menu()
    h = ( x.winfo_screenheight() *.90 ) / 25
    maxmenu = int( h )
    x.destroy()
</t>
<t tx="ekr.20070127142814.1975">langdict = {}  
binder = '&lt;Control-space&gt;' 
def loadLanguages( lkpm):
    global binder
    import ConfigParser
    cp = ConfigParser.ConfigParser()
    cp.read( lkpm )
    which = ''
    sec = cp.sections()
    for z in sec:
        if z.strip() == 'language':
            which = z
            break
    if cp.has_section( which ):
        op = cp.options( which )
        for z in op:
            z2 = cp.get( which, z ).split(',')
            z2 = [ x.strip() for x in z2 ]
            langdict[ z ] = z2
    for z in sec:
        if z.strip() == 'fgnconfig':
            which2 = z
            break
    if cp.has_section( which2 ):
        op2 = cp.options( which2 )
        for z2 in op2:
            if z2.strip() == 'binder':
                binder = cp.get( which2, z2 )
                break
</t>
<t tx="ekr.20070127142814.1976">import org.jgraph.graph as gr
import javax.swing as sw
import org.jgraph as jg
import java.util as util
import org.jgraph.graph.GraphConstants as GraphConstants
import java.awt as awt


class z( gr.DefaultGraphCell ):
    
    i = 0
    def __init__( self ):
        gr.DefaultGraphCell.__init__( self, "CATAMANGA" )
        self.i2 = self.i
        z.i = z.i + 1
        
    def toString( self ):
        return "ZZZZZ%s!" % self.i2 


def getGraph():
    
    import jarray
    fl = jarray.zeros( 2, 'f' )
    fl[ 0 ] = 3
    fl[ 1 ] = 3
    roots = util.ArrayList()
    cs = gr.ConnectionSet()
    amap = util.HashMap()
    implementStyle = gr.AttributeMap();
    GraphConstants.setLineBegin(implementStyle, GraphConstants.ARROW_TECHNICAL)
    GraphConstants.setBeginSize(implementStyle, 10)
    GraphConstants.setDashPattern(implementStyle, fl )
    GraphConstants.setFont(implementStyle, GraphConstants.DEFAULTFONT.deriveFont(10))
    #e = gr.DefaultEdge( "YEAH" )
    #amap.put( e, implementStyle )
    rt = z()
    roots.add( rt )
    for x in xrange( 10 ):
        #e = gr.DefaultEdge()
        #rt.addEdge( e )
        #rt.add( e )
        z2 = z()
        as1 = gr.AttributeMap()
        gr.GraphConstants.setBounds( as1, awt.Rectangle( x * 50, 50 * x, 50, 50 ) )
        e = gr.DefaultEdge( "YEAH" )
        cs.connect( e, rt, z2 )
        amap.put( e, implementStyle )
        amap.put( z2, as1 )
        roots.add( z2 )
        #rt.add( z2 )
        #e.setTarget( z2 )
        #e.add( z2 )
        #z2.setAnchor( rt )
        
    return roots.toArray() , cs, amap
    
    
def mkGraph():
    tl = sw.JFrame()
    grp = getGraph()
    #rts = util.ArrayList()
    #rts.add( grp )
    dmod = gr.DefaultGraphModel()
    dmod.insert( grp[ 0 ], grp[ 2 ] , grp[ 1 ], None , None  )
    #dmod = gr.DefaultGraphModel( rts, gr.AttributeMap() )
    j = jg.JGraph( dmod )
    tl.getContentPane().add( j )
    tl.visible = 1
    
    

mkGraph()
    
    </t>
<t tx="ekr.20070127142814.1977">@language python
&lt;&lt; chapters declarations &gt;&gt;
@others
#@nonl
#@-node:mork.20040926105355.43:_changeTreeToPDF
#@-others
#@nonl
#@-node:mork.20040930091624.1:PDF
#@-others
    
ol_select = leoTkinterTree.leoTkinterTree.select

if Pmw and not g.app.unitTesting: # Not for unit testing:  modifies core classes.
    if g.app.gui is None: 
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        #@        &lt;&lt; override various methods &gt;&gt;
        #@+node:ekr.20041103054545:&lt;&lt; override various methods &gt;&gt;
        leoTkinterFrame.leoTkinterFrame.createCanvas = newCreateCanvas
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl
        
        leoTkinterTree.leoTkinterTree.select = newselect
        leoTkinterTree.leoTkinterTree.endEditLabel = newendEditLabel
        leoTkinterTree.leoTkinterTree.__init__ = newTreeinit
        
        g.os_path_dirname = newos_path_dirname
        
        leoFileCommands.fileCommands.write_LEO_file = newWrite_LEO_file
        leoFileCommands.fileCommands.write_Leo_file = newWrite_LEO_file
        leoFileCommands.fileCommands.getLeoFile = newGetLeoFile
        leoFileCommands.fileCommands.open = newOpen
        
        if hasattr( leoNodes.vnode, 'doDelete' ):
            leoNodes.vnode.doDelete = newTrashDelete
        else:
            leoNodes.position.doDelete = newTrashDelete
        #@nonl
        #@-node:ekr.20041103054545:&lt;&lt; override various methods &gt;&gt;
        #@nl
        g.plugin_signon( __name__ )
#@nonl
#@-node:mork.20040926105355.1:@thin chapters.py
#@-leo
</t>
<t tx="ekr.20070127142814.1978">#@+leo-ver=4-thin
#@+node:mork.20040926105355.1:@thin chapters.py
#@&lt;&lt;docstring&gt;&gt;
#@+node:ekr.20041109123143:&lt;&lt;docstring&gt;&gt;
'''This plugin creates separate outlines called "chapters" within a single .leo file.  Clones work between Chapters.

Requires Python Mega Widgets and Leo 4.2 or above.

Numbered tabs at the top of the body pane represent each chapter.  Right clicking the tab will show a popup menu containing commands.  These commands allow you to:
    
- insert and delete chapters.
- add names to chapters.
- split the body pane to create multiple "editors".
- create a "trash barrel that hold all deleted nodes.
- import and export outlines and chapters.
- create a pdf file from your chapters (requires reportlab toolkit at http://www.reportlab.org).
- and more...
 
Warnings:
    
- This plugin makes substantial changes to Leo's core.
- Outlines containing multiple chapters are stored as a zipped file that can only be read when this plugin has been enabled.
'''
#@nonl
#@-node:ekr.20041109123143:&lt;&lt;docstring&gt;&gt;
#@nl

# To do:  Find/Change does not appear to work.

#@@language python
#@@tabwidth -4

__version__ = "0.66"
#@&lt;&lt; version history &gt;&gt;
#@+node:ekr.20041103051117:&lt;&lt; version history &gt;&gt;
#@@killcolor
#@+at
# 
# v .2
# 
# 1. Trash. If there is a Chapter in the Leo project called 'Trash' all 
# deleted nodes are deposited there. Then when deleted in the 'Trash' chapter 
# it is finally removed. There is an option to quickly add a Trash barrel in 
# the menu.
# 2. Menu moved from Outline to being summoned by right clicking on a chapter 
# tab or in the area of the tabs.
# 3. Swapping Chapters. Swap one Chapter for another one.
# 4. Conversion ops. Take one Outline and turn each node into a Chapter. The 
# convers operation is also there, take each top level node in each Chapter 
# and add it to one Chapter.
# 5. Import/Export. You are now able to load leo files as Chapters. This 
# means, for example, that if you have 5 Outlines that you would like to bind 
# together as one Leo file but keep their separateness you can now import 
# those 5 Outlines into there own Chapters. You can also Export a single 
# Chapter into it's own separate Leo file.
# 6. Search and Clone. This functionality is very similar to the Filtered 
# Hoist concept. You decide which Chapter you want your search results to 
# appear in and a dialog will pop up. You can enter simple text or a more 
# complex regular expression and the function will search all the outlines and 
# create a node with the results as children.
# 7. Editors now have headlines indicating what Chapters and what node are 
# being worked on.
# 
# v .6 EKR: Based on version .5 by Leo User.
# 
# - Added g. before all functions in leoGlobals.py.
# - Right clicking on Chapter tab crashes.
# 
# .61 fixed up a couple of spots.
# 
# .62 EKR: Restored conditional call to g.app.createTkGui(__file__) in startup 
# code.
# 
# .63 EKR: Added long docstring.
# 
# .64 fixed cloneWalk and PDF Convertor.
# 
# .65 EKR: added new keyword args to newGetLeoFile and newOpen.
#     - This is needed because of changes to the corresponding method's in 
# Leo's core.
# 
# .66 EKR: use notebooks.get(c) throughout.
#     - c may not exist during unit testing.  Not a complete fix, not tested!
#@-at
#@nonl
#@-node:ekr.20041103051117:&lt;&lt; version history &gt;&gt;
#@nl
#@&lt;&lt; imports &gt;&gt;
#@+node:ekr.20041103050629:&lt;&lt; imports &gt;&gt;
import leoGlobals as g

import leoColor
import leoCommands
import leoFileCommands
import leoFrame
import leoNodes
import leoPlugins
import leoTkinterFrame
import leoTkinterMenu
import leoTkinterTree

Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
   
from leoTkinterFrame import leoTkinterLog
from leoTkinterFrame import leoTkinterBody

import os
import string
import sys
import time
import zipfile
#@nonl
#@-node:ekr.20041103050629:&lt;&lt; imports &gt;&gt;
#@nl
#@&lt;&lt; globals &gt;&gt;
#@+node:mork.20040926105355.2:&lt;&lt; globals &gt;&gt;
chapters = {}
notebooks = {}
frames = {}
iscStringIO = False
twidgets = {}
pbodies = {}

#@-node:mork.20040926105355.2:&lt;&lt; globals &gt;&gt;
#@nl

# Solve problems with string.atoi...
import string
string.atoi = int

#@+others
#@+node:mork.20040927092626:class Chapter
</t>
<t tx="ekr.20070127142814.1979">class Chapter:
    '''The fundamental abstraction in the Chapters plugin.
       It enables the tracking of Chapters tree information.'''
	&lt;&lt; class Chapter declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20070127142814.1980">    #@    @+others
    #@+node:ekr.20041103051228:__init__
</t>
<t tx="ekr.20070127142814.1981">def __init__( self, c, tree, frame, canvas ):
        
    self.c = c
    self.tree = tree
    self.frame = frame
    self.canvas = canvas
    self.treeBar = frame.treeBar

    if hasattr( c, 'cChapter' ):
        tn = leoNodes.tnode( '', 'New Headline' )
        vn = leoNodes.vnode( c, tn )
        pos = leoNodes.position( vn, [] )
        self.cp = pos
        self.rp = pos
        self.tp = pos
    else:
        c.cChapter = self
        self.cp = c._currentPosition
        self.tp = c._topPosition
        self.rp = c._rootPosition
</t>
<t tx="ekr.20070127142814.1982">#@nonl
#@-node:ekr.20041103051228:__init__
#@+node:ekr.20041103051228.1:_saveInfo
def _saveInfo( self ):
    
    self.cp = self.c._currentPosition.copy()
    self.rp = self.c._rootPosition.copy()
    self.tp = self.c._topPosition.copy()
</t>
<t tx="ekr.20070127142814.1983">#@nonl
#@-node:ekr.20041103051228.1:_saveInfo
#@+node:ekr.20041103051228.2:setVariables
def setVariables( self ):
    
    c = self.c
    frame = self.frame
    frame.tree = self.tree
    frame.canvas = self.canvas
    frame.treeBar = self.treeBar
    c._currentPosition = self.cp
    c._rootPosition = self.rp
    c._topPosition = self.tp
</t>
<t tx="ekr.20070127142814.1984">#@-node:ekr.20041103051228.2:setVariables
#@+node:ekr.20041103051228.3:makeCurrent
def makeCurrent( self ):
    
    c = self.c
    c.cChapter._saveInfo()
    c.cChapter = self
    self.setVariables()
    c.redraw()
    self.canvas.update_idletasks()
</t>
<t tx="ekr.20070127142814.1985">    #@nonl
    #@-node:ekr.20041103051228.3:makeCurrent
    #@-others
#@nonl
#@-node:mork.20040927092626:class Chapter
#@+node:mork.20040930090735:Creating widgets...
#@+at
# This category deals with creating widgets and any support functions for 
# doing so.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.21:newCreateControl
cControl = leoTkinterFrame.leoTkinterBody.createControl

def newCreateControl( self, frame, parentFrame  ):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if c not in pbodies:
        parentFrame = createPanedWidget( parentFrame, c )
    pbody = pbodies[ c ]
    l, r =addHeading( parentFrame )
    ctrl = cControl( self, frame , parentFrame ) 
    ctrl.bind( "&lt;FocusIn&gt;", lambda event, body = frame.body : getGoodPage( event, body ), '+' )
    i = 1.0 / len( pbody.panes() )
    for z in pbody.panes():
        pbody.configurepane( z , size = i )
    pbody.updatelayout()
    frame.body.l =l
    frame.body.r =r 
    frame.body.editorName = editorNames[ parentFrame ]
    if frame not in twidgets:
        twidgets[ frame ] = []
    twidgets[ frame ].append( frame.body )
    l.configure( textvariable = getSV( notebook.getcurselection(), c ) )
    return ctrl
</t>
<t tx="ekr.20070127142814.1986">#@-node:mork.20040926105355.21:newCreateControl
#@+node:mork.20040929110556:createPanedWidget
def createPanedWidget( parentFrame, c ):
    #constructs a new panedwidget for a frame
    pbody = Pmw.PanedWidget( parentFrame , orient = 'horizontal' )
    pbody.pack( expand = 1 , fill = 'both')
    pbodies[ c ] = pbody
    parentFrame = newEditorPane( c )
    return parentFrame
</t>
<t tx="ekr.20070127142814.1987">#@nonl
#@-node:mork.20040929110556:createPanedWidget
#@+node:mork.20040926105355.22:newEditorPane
editorNames = {}

def newEditorPane( c ):
    names = pbodies[ c ].panes()
    if names:
        name  = str( int(names[ -1 ]) + 1 )
    else:
        name = '1'
    zpane = pbodies[ c ].add( name )
    editorNames[ zpane ] = name
    return zpane
</t>
<t tx="ekr.20070127142814.1988">#@-node:mork.20040926105355.22:newEditorPane
#@+node:mork.20040926105355.23:newCreateCanvas
def newCreateCanvas( self, parentFrame, createCanvas = leoTkinterFrame.leoTkinterFrame.createCanvas ):
    c = self.c
    
    if c not in frames:
        frames[ c ] = self
        notebook = createNoteBook( c, parentFrame )
    else:
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        
    pname = notebook.nameMaker.next()
    page = notebook.add( pname )
    indx = notebook.index( pname )
    tab = notebook.tab( indx )
    if indx == 0:
        tab.configure( background = 'grey', foreground = 'white' )
    canvas = createCanvas( self, page )
    
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event : hull.tmenu.post( event.x_root , event.y_root ) )
    sv = Tk.StringVar()
    page.sv = sv
    createBalloon( tab, sv )
    canvas.name = pname
    
    g.trace(repr(canvas.name),canvas)

    return canvas
</t>
<t tx="ekr.20070127142814.1989">#@nonl
#@-node:mork.20040926105355.23:newCreateCanvas
#@+node:mork.20040929120442:createBalloon
def createBalloon( tab, sv ):
    #creates a balloon for a widget
    balloon = Pmw.Balloon( tab , initwait = 100 )
    balloon.bind( tab , '' )
    hull = balloon.component( 'hull' )
    def blockExpose( event ):
        if sv.get() == '':
             hull.withdraw()
    hull.bind( '&lt;Expose&gt;', blockExpose, '+' )
    balloon._label.configure( textvariable = sv )
</t>
<t tx="ekr.20070127142814.1990">#@nonl
#@-node:mork.20040929120442:createBalloon
#@+node:mork.20040929102107:createNoteBook
def createNoteBook( c, parentFrame ):
    #constructs a NoteBook widget for a frame
    notebooks[ c ] = notebook = Pmw.NoteBook( parentFrame, borderwidth = 1, pagemargin = 0)
    hull = notebook.component( 'hull' ) 
    makeTabMenu( hull, notebook, c )
    notebook.configure( raisecommand = lambda name, notebook = notebook : setTree( name , notebook ) )
    notebook.configure( lowercommand = lambda name, notebook = notebook: lowerPage( name, notebook ) )
    notebook.pack( fill = 'both' , expand = 1)
    notebook.nameMaker = getNameMaker( notebook )
    return notebook
</t>
<t tx="ekr.20070127142814.1991">#@nonl
#@-node:mork.20040929102107:createNoteBook
#@+node:mork.20040929093051:getNameMaker
def getNameMaker( notebook ):
    #creates a numbering mechanism for tabs
    def nameMaker():
        i = 0
        while 1:
            if len( notebook.pagenames() ) == 0: i = 0
            i += 1
            yield str( i )
            
    return nameMaker()
</t>
<t tx="ekr.20070127142814.1992">#@nonl
#@-node:mork.20040929093051:getNameMaker
#@+node:mork.20040926105355.24:newTreeinit
def newTreeinit( self, c,frame,canvas, oinit = leoTkinterTree.leoTkinterTree.__init__ ):
    
    g.trace(canvas)

    sv = getSV( canvas.name, c )
    oinit( self, c, frame, canvas )
    self.chapter = chapters[ sv ] = Chapter( c, self , frame, canvas )
</t>
<t tx="ekr.20070127142814.1993">#@-node:mork.20040926105355.24:newTreeinit
#@+node:mork.20040926105355.25:constructTree
def constructTree( frame , notebook, name ):
    
    canvas = treeBar = tree = None
    if frame.canvas:
        canvas = frame.canvas
        treeBar = frame.treeBar
        tree = frame.tree
    sv = Tk.StringVar()
    sv.set( name )
    canvas = frame.createCanvas( None )
    frame.canvas =  canvas
    frame.tree = leoTkinterTree.leoTkinterTree( frame.c ,frame, frame.canvas)
    frame.tree.setColorFromConfig()
    indx = notebook.index( notebook.pagenames()[ -1 ] )
    tab = notebook.tab( indx )
    tnum = str( len( notebook.pagenames() ) ) 
    tab.configure( text = tnum )
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event ,hull = hull: hull.tmenu.post( event.x_root , event.y_root ) )
    return tree , notebook.page( notebook.pagenames()[ - 1 ] )
</t>
<t tx="ekr.20070127142814.1994">#@-node:mork.20040926105355.25:constructTree
#@+node:mork.20040926105355.26:addPage
def addPage( c , name = None ):

    frame = frames[ c ]
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if name == None : name = str( len( notebook.pagenames() ) + 1 )
    o_chapter = c.cChapter
    otree, page  = constructTree( frame, notebook, name )
    c.cChapter.makeCurrent()
    o_chapter.makeCurrent()
    return page
</t>
<t tx="ekr.20070127142814.1995">#@-node:mork.20040926105355.26:addPage
#@+node:mork.20040926105355.35:newEditor
def newEditor( c ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    frame = frames[ c ]
    pbody = pbodies[ c ]
    zpane = newEditorPane( c )
    af = leoTkinterBody( frame, zpane )
    c.frame.bodyCtrl = af.bodyCtrl
    af.setFontFromConfig()
    af.createBindings( frame )
    af.bodyCtrl.focus_set()
    cname = notebook.getcurselection()
    af.l.configure( textvariable = getSV(cname , c ) )
    af.r.configure( text = c.currentVnode().headString() )
</t>
<t tx="ekr.20070127142814.1996">#@-node:mork.20040926105355.35:newEditor
#@-others
#@nonl
#@-node:mork.20040930090735:Creating widgets...
#@+node:mork.20040930091319:tab menu stuff
#@+at
# Tab menu and factory functions for the tab menu creation process.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.41:makeTabMenu
def makeTabMenu( widget, notebook, c ):
    #creates the Menu that appears
    tmenu = Tk.Menu( widget, tearoff = 0 )
    widget.bind( '&lt;Button-3&gt;' , lambda event : tmenu.post( event.x_root , event.y_root ) )
    widget.tmenu = tmenu
    tmenu.add_command( command = tmenu.unpost )
    tmenu.add_separator()
    ac = getAddChapter( c, notebook )
    tmenu.add_command( label = 'Add Chapter', command = ac )
    rmenu = Tk.Menu( tmenu , tearoff = 0 )    
    remove = getRemove( notebook, c, rmenu )
    rmenu.configure( postcommand = remove )        
    tmenu.add_cascade( menu = rmenu, label = "Remove Chapter" )
    rename = getRename( notebook )
    tmenu.add_command( label = "Add/Change Title" , command = rename )
    opmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = opmenu , label = 'Node-Chapter Ops' )
    cmenu = Tk.Menu( opmenu, tearoff = 0 )
    movmenu = Tk.Menu( opmenu, tearoff = 0 )
    copymenu = Tk.Menu( opmenu, tearoff = 0 )
    swapmenu = Tk.Menu( opmenu, tearoff = 0 )
    searchmenu = Tk.Menu( opmenu, tearoff = 0 )
    opmenu.add_cascade( menu = cmenu, label = 'Clone To Chapter' )
    opmenu.add_cascade( menu = movmenu, label = 'Move To Chapter' )
    opmenu.add_cascade( menu = copymenu, label = 'Copy To Chapter' )
    opmenu.add_cascade( menu = swapmenu, label = 'Swap With Chapter' )
    opmenu.add_cascade( menu = searchmenu, label = 'Search and Clone To' )
    opmenu.add_command( label ="Make Node Into Chapter", command = lambda c=c:  makeNodeIntoChapter( c ) )
    mkTrash = getMakeTrash( notebook )
    opmenu.add_command( label = "Add Trash Barrel", command =
    lambda c = c : mkTrash( c ))
    opmenu.add_command( label = 'Empty Trash Barrel', command =
    lambda notebook = notebooks.get(c), c = c: emptyTrash( notebook, c ) )
    setupMenu = getSetupMenu( c, notebook )
    cmenu.configure(
        postcommand = lambda menu = cmenu, command = cloneToChapter : setupMenu( menu, command ) )
    movmenu.configure(
        postcommand = lambda menu = movmenu, command = moveToChapter : setupMenu( menu, command ) )
    copymenu.configure(
        postcommand = lambda menu = copymenu, command = copyToChapter : setupMenu( menu, command ) ) 
    swapmenu.configure( postcommand = 
    lambda menu = swapmenu, command = swapChapters : setupMenu( menu, command ) )
    searchmenu.configure( postcommand = lambda menu = searchmenu,
    command = regexClone: setupMenu( menu, command, all = True ) )
    edmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = "Editor", menu = edmenu )
    edmenu.add_command( label = "Add Editor" , command = lambda c =c : newEditor( c ) ) 
    edmenu.add_command( label = "Remove Editor", command = lambda c = c : removeEditor( c ) )
    conmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = conmenu, label = 'Conversion' )
    conmenu.add_command(
        label = "Convert To Simple Outline",
        command = lambda c =c : conversionToSimple( c ) )
    conmenu.add_command(
        label = "Convert Simple Outline into Chapters",
        command = lambda c= c : conversionToChapters( c ) )
    iemenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade(label = 'Import/Export', menu = iemenu )
    iemenu.add_command( label = "Import Leo File ", command = lambda c = c: importLeoFile(c ) )
    iemenu.add_command( label = "Export Chapter To Leo File", command = lambda c =c : exportLeoFile( c ) )
    indmen = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = 'Index', menu = indmen )
    indmen.add_command( label = 'Make Index', command = lambda c =c : viewIndex( c ) )
    indmen.add_command( label = 'Make Regex Index', command = lambda c =c : regexViewIndex( c ) ) 
    try:
        import reportlab
        tmenu.add_command( label = 'Convert To PDF', command = lambda c = c: doPDFConversion( c ) )
    except Exception: 
        g.es( "no reportlab" )
</t>
<t tx="ekr.20070127142814.1997">#@nonl
#@-node:mork.20040926105355.41:makeTabMenu
#@+node:mork.20040930091319.1:function factories
#@+others
#@+node:mork.20040928224349:getAddChapter
def getAddChapter( c , notebook ):
    #a function that makes a function to add chapters  
    def ac( c = c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        cname = notebook.getcurselection()
        addPage( c )        
        renumber( notebook)
    
    return ac
</t>
<t tx="ekr.20070127142814.1998">#@nonl
#@-node:mork.20040928224349:getAddChapter
#@+node:mork.20040928223221:getRemove
def getRemove( notebook, c , rmenu ):
    #a function that makes a function to remove chapters
    def remove():
        rmenu.delete( 0 , Tk.END )
        pn = notebook.pagenames()
        for i, z in enumerate( pn ):
            i = i + 1
            def rmz( name = z):
                if len( notebook.pagenames() ) == 1: return
                sv = getSV( name )
                chapter = chapters[ sv ]
                tree = chapter.tree
                vnd = chapter.rp
                cvnd = c.cChapter.cp
                c.beginUpdate()
                otree = c.cChapter.tree
                c.frame.tree = tree
                if vnd:
                    v = vnd                    
                    nnd = vnd.next()
                    if nnd == None:
                        nnd = vnd.insertAfter()
                        vnd = None
                    v.doDelete( nnd )
                c.frame.tree = otree
                c.endUpdate()
                notebook.delete( name )
                if tree != otree:
                    c.selectPosition( cvnd )
                if tree == otree:
                    pnames = notebook.pagenames()
                    notebook.selectpage( pnames[ 0 ] )
                    c.selectPosition( c.currentPosition() )
                    c.beginUpdate()
                    c.endUpdate()
                renumber( notebook )
            rmenu.add_command( label = str( i ) , command = rmz )  
              
    return remove
</t>
<t tx="ekr.20070127142814.1999">#@-node:mork.20040928223221:getRemove
#@+node:mork.20040928223738:getRename
def getRename( notebook ):
    #a function that makes a function to rename chapters
    def rename( rnframes = {} ):
        name = notebook.getcurselection()
        frame = notebook.page( notebook.index( name ) )
        fr = frames[ g.top() ]
        if not rnframes.has_key( frame ):
            f = rnframes[ frame ] = Tk.Frame( frame )
            e = Tk.Entry( f , background = 'white', textvariable = frame.sv )
            b = Tk.Button( f , text = "Close" ) 
            e.pack( side = 'left' )
            b.pack( side = 'right' )
            def change():
                f.pack_forget()
            b.configure( command = change )
        else:
            f = rnframes[ frame ]
            if f.winfo_viewable() : return None
        fr.canvas.pack_forget()
        f.pack( side = 'bottom' )
        fr.canvas.pack( fill = 'both', expand = 1 )

    return rename
</t>
<t tx="ekr.20070127142814.2000">#@nonl
#@-node:mork.20040928223738:getRename
#@+node:mork.20040928224049:getMakeTrash
def getMakeTrash( notebook ):
    #a function that makes a function to add a trash chapters
    def mkTrash( c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        addPage( c, 'Trash' )
        pnames = notebook.pagenames()
        sv = getSV( pnames[ - 1 ], c )
        sv.set( 'Trash' )
        renumber( notebook )
    
    return mkTrash    
</t>
<t tx="ekr.20070127142814.2001">#@-node:mork.20040928224049:getMakeTrash
#@+node:mork.20040928224621:getSetupMenu
def getSetupMenu( c, notebook ):
    #a function that makes a function to populate a menu
    def setupMenu( menu , command , all = False):
        menu.delete( 0 , Tk.END )
        current = notebook.getcurselection()
        for i, z in  enumerate( notebook.pagenames() ):
            i = i + 1
            if z == current and not all: continue
            menu.add_command( label = str( i ) , command = lambda c = c , name = z : command( c, name ) )
            
    return setupMenu
</t>
<t tx="ekr.20070127142814.2002">#@nonl
#@-node:mork.20040928224621:getSetupMenu
#@-others
#@nonl
#@-node:mork.20040930091319.1:function factories
#@-others
#@nonl
#@-node:mork.20040930091319:tab menu stuff
#@+node:mork.20040930092346:Multi-Editor stuff
#@+others
#@+node:mork.20040929104527:selectNodeForEditor
def selectNodeForEditor( c, body ):
    #sets the node for the new editor
    if not hasattr( body, 'lastNode' ):
        body.lastNode = c.currentPosition()

    if body.lastNode == c.currentPosition(): return    
    elif body.lastNode.exists( c ):
        c.selectPosition( body.lastNode )
    else:
        c.selectPosition( c.rootPosition() )

    body.lastNode = c.currentPosition()    
</t>
<t tx="ekr.20070127142814.2003">#@nonl
#@-node:mork.20040929104527:selectNodeForEditor
#@+node:mork.20040929105638:activateEditor
def activateEditor( body ):
    #performs functions that brings editor on line
    body.r.configure( text = body.lastNode.headString() )
    ip = body.lastNode.t.insertSpot
    txt = body.lastNode.bodyString()
    body.deleteAllText()
    body.insertAtEnd( txt )
    if ip : body.setInsertionPoint( ip )
    body.colorizer.colorize( body.lastNode )
    body.bodyCtrl.update_idletasks()
</t>
<t tx="ekr.20070127142814.2004">#@nonl
#@-node:mork.20040929105638:activateEditor
#@+node:mork.20040926105355.36:removeEditor
def removeEditor( c ):
    pbody = pbodies[ c ]
    if len( pbody.panes() ) == 1: return None
    body = c.frame.body
    pbody.delete( body.editorName )
    pbody.updatelayout()
    panes = pbody.panes()
    twidgets[ c.frame ].remove( body )
    nBody = twidgets[ c.frame ][ 0 ] 
    nBody.bodyCtrl.focus_set()
    nBody.bodyCtrl.update_idletasks()
</t>
<t tx="ekr.20070127142814.2005">#@-node:mork.20040926105355.36:removeEditor
#@+node:mork.20040926105355.44:addHeading
def addHeading( pane ):
    f = Tk.Frame( pane )
    f.pack( side = 'top' )
    l = Tk.Label( f )
    l.pack( side = 'left' )
    r = Tk.Label( f )
    r.pack( side = 'right' )
    return l , r
</t>
<t tx="ekr.20070127142814.2006">#@-node:mork.20040926105355.44:addHeading
#@-others
#@nonl
#@-node:mork.20040930092346:Multi-Editor stuff
#@+node:mork.20040930090547:Indexing
#@+at
# Indexing is complementary to find, it provides a gui Index of nodes.  In 
# comparison to regular find which bounces you around the tree, you can 
# preview the node before you go to it.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.3:viewIndex
def viewIndex( c , nodes = None, tle = '' ):
    if nodes == None:
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
    def aN( a ):
        n = a[ 0 ].headString()
        return n, a[ 0 ], a[ 1 ]
    nodes = map( aN, nodes )
    nodes.sort()
    tl = Tk.Toplevel()
    import time    
    title = "%s Index of %s created at %s" % ( tle, c.frame.shortFileName(), time.ctime())
    tl.title( title )
    f = Tk.Frame( tl )
    f.pack( side = 'bottom' )
    l = Tk.Label( f, text = 'ScrollTo:' )
    e = Tk.Entry( f , bg = 'white', fg = 'blue')
    l.pack( side = 'left' )
    e.pack( side ='left' )
    b = Tk.Button( f, text = 'Close' )
    b.pack( side = 'left' )
    def rm( tl = tl ):
        tl.withdraw()
        tl.destroy()
    b.configure( command = rm )
    sve = Tk.StringVar()
    e.configure( textvariable = sve )
    ms = tl.maxsize()
    tl.geometry( '%sx%s+0+0' % (ms[ 0 ], (ms[ 1 ]/4 )*3 ))
    sc = Pmw.ScrolledCanvas( tl , vscrollmode = 'static', hscrollmode = 'static', 
    usehullsize = 1, borderframe = 1, hull_width = ms[ 0 ], hull_height = (ms[ 1 ]/4 )*3 )
    sc.pack()
    can = sc.interior()
    can.configure( background = 'white' )
    bal = Pmw.Balloon( can )
    
    tags = {}
    #ltag = None
    buildIndex( nodes , c, can, tl, bal, tags)            
    sc.resizescrollregion()
    def scTo( event , nodes = nodes, sve = sve , can = can , tags = tags):
        t = sve.get()
        if event.keysym == 'BackSpace':
            t = t[ : -1 ]
        else:
            t = t + event.char
        if t == '': return
        for z in nodes:
            if z[ 0 ].startswith( t ) and tags.has_key( z[ 1 ] ):
                tg = tags[ z[ 1 ] ]
                eh = can.bbox( ltag )[ 1 ]
                eh = (eh *1.0)/100
                bh = can.bbox( tg )[ 1 ]
                ncor = (bh/ eh) * .01 
                can.yview( 'moveto' , ncor)
                return

    e.bind( '&lt;Key&gt;', scTo )
    e.focus_set()
</t>
<t tx="ekr.20070127142814.2007">#@-node:mork.20040926105355.3:viewIndex
#@+node:mork.20040929121409:buildIndex
def buildIndex( nodes , c , can, tl, bal, tags):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import tkFont
    f = tkFont.Font()
    f.configure( size = -20 )
    ltag = None
    for i,z in enumerate(nodes):
        tg = 'abc' + str( i ) 
        parent = z[ 1 ].parent()
        if parent: parent = parent.headString()
        else:
            parent = 'No Parent'
        sv = getSV( z[ 2 ] )
        if sv.get(): sv = ' - ' + sv.get()
        else: sv = ''
        
        tab = notebook.tab( z[ 2 ] )
        tv = tab.cget( 'text' )
        isClone = z[ 1 ].isCloned()
        if isClone:
            clone = ' (Clone) '
        else:
            clone =''
        txt = '%s  , parent: %s , chapter: %s%s%s' %( z[ 0 ], parent, tv, sv, clone)
        ltag = tags[ z[1] ] = can.create_text( 20, i * 20 + 20, text = txt, fill = 'blue', font = f , anchor = Tk.W, tag = tg )
        bs = z[ 1 ].bodyString()
        if bs.strip() != '':
            bal.tagbind( can, tg, bs)
        def goto( event, z = z , c = c, tl = tl):
            notebook = notebooks.get(c)
            if not notebook: return # For unit testing
            notebook.selectpage( z[ 2 ] )
            c.selectVnode( z[ 1 ] )
            c.frame.outerFrame.update_idletasks()
            c.frame.outerFrame.event_generate( '&lt;Button-1&gt;' )
            c.frame.bringToFront()
            return 'break'
        def colorRd( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'red' )
        def colorBl( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'blue' )
        can.tag_bind( tg, '&lt;Button-1&gt;', goto )
        can.tag_bind( tg, '&lt;Enter&gt;', colorRd, '+' )
        can.tag_bind( tg, '&lt;Leave&gt;', colorBl, '+' )    
</t>
<t tx="ekr.20070127142814.2008">#@-node:mork.20040929121409:buildIndex
#@+node:mork.20040926105355.4:regexViewIndex
def regexViewIndex( c ):
    
    def regexWalk( result, entry, widget ):
        txt = entry.get()
        widget.deactivate()        
        widget.destroy()
        if result == 'Cancel': return None
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
        import re
        regex = re.compile( txt )
        def search( nd, regex = regex ):
            return regex.search( nd[ 0 ].bodyString() )
        nodes = filter( search , nodes )
        viewIndex( c, nodes , 'Regex( %s )'%txt )
        return

    sd = Pmw.PromptDialog( c.frame.top,
    title = 'Regex Index',
    buttons = ( 'Search', 'Cancel' ),
    command =regexWalk )
    entry = sd.component( 'entry' )
    sd.configure( command = 
        lambda result, entry = entry, widget = sd:
            regexWalk( result, entry, widget ) )      
    sd.activate(  geometry = 'centerscreenalways' )   
</t>
<t tx="ekr.20070127142814.2009">#@-node:mork.20040926105355.4:regexViewIndex
#@-others
#@-node:mork.20040930090547:Indexing
#@+node:mork.20040930094729:Chapter-Notebook ops
#@+others
#@+node:mork.20040926105355.5:renumber
def renumber( notebook ):
    pagenames = notebook.pagenames()
    for i , z in enumerate(pagenames):
        i = i +1
        tab = notebook.tab( z )
        tab.configure( text = str( i ) )
</t>
<t tx="ekr.20070127142814.2010">#@-node:mork.20040926105355.5:renumber
#@+node:mork.20040926105355.6:getGoodPage
def getGoodPage( event , body ):
    global focusing
    c = body.c 
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    body.frame.body = body
    body.frame.bodyCtrl = body.bodyCtrl
    if not hasattr( body, 'lastChapter' ):
        body.lastChapter = notebook.getcurselection()
    page = checkChapterValidity( body.lastChapter, c )
    if page != notebook.getcurselection():
        body.lastChapter = page
        notebook.selectpage( page )
    selectNodeForEditor( c, body )         
    activateEditor( body )
</t>
<t tx="ekr.20070127142814.2011">#@nonl
#@-node:mork.20040926105355.6:getGoodPage
#@+node:mork.20040926105355.7:checkChapterValidity
def checkChapterValidity( name , c):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    try:
        notebook.index( name )
    except:
        return notebook.getcurselection()            
    return name
</t>
<t tx="ekr.20070127142814.2012">#@-node:mork.20040926105355.7:checkChapterValidity
#@+node:mork.20040926105355.20:getSV
def getSV( name, c = None ):
    #returns a Tk StrinVar that is a primary identifier
    if not c : c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    index = notebook.index( name )
    page = notebook.page( index )
    return page.sv
</t>
<t tx="ekr.20070127142814.2013">#@-node:mork.20040926105355.20:getSV
#@+node:mork.20040926105355.27:setTree
def setTree( name , notebook , c = None ):

    if not c: 
        c = g.top()
        if not c: return None
    pindex = notebook.index( name )
    page = notebook.page( pindex )
    if not hasattr( page, 'sv' ) : return None
    sv = page.sv
    chapter = chapters[ sv ]
    chapter.makeCurrent()
    frame = c.frame
    frame.body.lastChapter = name
    frame.body.lastNode = chapter.cp
    frame.body.l.configure( textvariable = sv )
    tab = notebook.tab( pindex )
    tab.configure( background = 'grey', foreground = 'white' )
    activateEditor( frame.body )
</t>
<t tx="ekr.20070127142814.2014">#@-node:mork.20040926105355.27:setTree
#@+node:mork.20040929084846:lowerPage
def lowerPage( name, notebook):
    # a function that sets a lowered tabs color
    pindex = notebook.index( name )
    tab = notebook.tab( pindex )
    tab.configure( background = 'lightgrey', foreground = 'black' )
</t>
<t tx="ekr.20070127142814.2015">#@nonl
#@-node:mork.20040929084846:lowerPage
#@+node:mork.20040926105355.40:walkChapters
def walkChapters( c = None, ignorelist = [], chapname = False):
    # a generator that allows one to walk the chapters as one big tree
    if c == None : c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    for z in pagenames:
        sv = getSV( z , c)
        chapter = chapters[ sv ]
        v = chapter.rp
        while v:
            if chapname:
                if v not in ignorelist: yield v, z
            else:
                if v not in ignorelist:  yield v
            v = v.threadNext()
</t>
<t tx="ekr.20070127142814.2016">#@-node:mork.20040926105355.40:walkChapters
#@-others
#@nonl
#@-node:mork.20040930094729:Chapter-Notebook ops
#@+node:mork.20040930091035:opening and closing
#@+at
# This category is for opening and closing of Leo files.  We need to decorate 
# and be tricky here, since a Chapters leo file is a zip file.  These 
# functions are easy to break in my experience. :)
#@-at
#@@c
#@+others
#@+node:mork.20040930091035.1:opening
#@+others
#@+node:mork.20040926105355.28:newGetLeoFile
oldGetLeoFile =  leoFileCommands.fileCommands.getLeoFile

def newGetLeoFile(self, fileName,readAtFileNodesFlag=True ):
    if iscStringIO:
        def dontSetReadOnly( self, name, value ):
            if name == 'read_only': return
            elif name == 'tnodesDict': return
            else:
                self.__dict__[ name ] = value
        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly
    rt = oldGetLeoFile(self,fileName,readAtFileNodesFlag)
    if iscStringIO:
        del self.__class__.__setattr__       
    return rt
</t>
<t tx="ekr.20070127142814.2017">#@nonl
#@-node:mork.20040926105355.28:newGetLeoFile
#@+node:mork.20040926105355.29:newOpen
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag)
</t>
<t tx="ekr.20070127142814.2018">#@nonl
#@-node:mork.20040926105355.29:newOpen
#@+node:mork.20040926105355.9:openChaptersFile
def openChaptersFile( fileName ):
    zf = zipfile.ZipFile( fileName )
    import cStringIO
    file = cStringIO.StringIO()
    name = zf.namelist()
    csfiles = [ [], [] ]
    for x in name :
        zi = zf.getinfo( x )
        csfiles[ 0 ].append( zi.comment )
        cs = cStringIO.StringIO()
        csfiles[ 1 ].append( cs )           
        cs.write( zf.read( x ) )
        cs.seek( 0 )          
    zf.close()
    csfiles = zip( csfiles[ 0 ], csfiles[ 1 ] )
    return csfiles
</t>
<t tx="ekr.20070127142814.2019">#@-node:mork.20040926105355.9:openChaptersFile
#@+node:mork.20040926105355.8:insertChapters
def insertChapters( chapters, frame, c ):
     notebook = notebooks.get(c)
     if not notebook: return # For unit testing
     pagenames = notebook.pagenames()
     for num, tup  in enumerate( chapters ):
            x, y = tup
            if num &gt; 0:
                sv = addPage( c, x ).sv
                notebook.nextpage()
                cselection = notebook.getcurselection()
            else:
                cselection = notebook.getcurselection()
                sv = getSV( cselection , c )
            sv.set( x )
            next = cselection
            setTree( next , notebook, c )
            frame.c.fileCommands.open( y, sv.get() )
            if num == 0:
                flipto = cselection
     setTree( flipto, notebook, c )
     c.frame.canvas.update_idletasks()
</t>
<t tx="ekr.20070127142814.2020">#@nonl
#@-node:mork.20040926105355.8:insertChapters
#@-others
#@nonl
#@-node:mork.20040930091035.1:opening
#@+node:mork.20040930091035.2:closing
#@+others
#@+node:mork.20040926105355.30:newWrite_LEO_file
def newWrite_LEO_file( self,fileName,outlineOnlyFlag, singleChapter = False):
    
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    at = c.atFileCommands
    if len( pagenames ) &gt; 1 and not singleChapter:        
        chapList = []
        self.__class__.__setattr__ =  getMakeStringIO( chapList )
        rv = writeChapters( self, fileName, pagenames, c , outlineOnlyFlag )
        if rv:
            zipChapters( fileName, pagenames, c, chapList )
        del self.__class__.__setattr__         
    else:
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )

    return rv
</t>
<t tx="ekr.20070127142814.2021">#@-node:mork.20040926105355.30:newWrite_LEO_file
#@+node:mork.20040929092231:getMakeStringIO
def getMakeStringIO( chapList ):
    #insures data is put in a StringIO instance
    def makeStringIO( self, name, value , cList = chapList):
        if name == 'outputFile' and value != None:
            import StringIO
            cS = StringIO.StringIO()
            cS.close = lambda : None
            self.__dict__[ name ] = cS
            cList.append( cS )
        elif name == 'outputFile' and value == None:
            self.__dict__[ name ] = None
        else:
            self.__dict__[ name ] = value 
            
    return makeStringIO
</t>
<t tx="ekr.20070127142814.2022">#@nonl
#@-node:mork.20040929092231:getMakeStringIO
#@+node:mork.20040929090525:writeChapters
def writeChapters( self, fileName, pagenames, c , outlineOnlyFlag):
    #goes over Chapters and puts info in StringIO instances
    for z in pagenames:
        sv = getSV( z, c )
        chapter = chapters[ sv ]
        chapter.setVariables()
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )    
    c.cChapter.setVariables()
    return rv
</t>
<t tx="ekr.20070127142814.2023">#@nonl
#@-node:mork.20040929090525:writeChapters
#@+node:mork.20040929090525.1:zipChapters
def zipChapters( fileName, pagenames, c, chapList ):
    #takes list of StringIO instances and zips them to a file
    zf = zipfile.ZipFile( fileName, 'w',  zipfile.ZIP_DEFLATED )
    for x ,fname in enumerate( pagenames ):
        sv = getSV( fname, c )
        zif = zipfile.ZipInfo( str( x ) )
        zif.comment = sv.get()
        zif.compress_type = zipfile.ZIP_DEFLATED
        chapList[ x ].seek( 0 )
        zf.writestr( zif ,chapList[ x ].read() )
    zf.close()
</t>
<t tx="ekr.20070127142814.2024">#@nonl
#@-node:mork.20040929090525.1:zipChapters
#@-others
#@nonl
#@-node:mork.20040930091035.2:closing
#@-others
#@nonl
#@-node:mork.20040930091035:opening and closing
#@+node:mork.20040930091624:decorated Leo functions
#@+at
# I prefer decorating Leo functions as opposed to patching them.  Patching 
# them leads to long term incompatibilites with Leo and the plugin.  Though 
# this happens anyway with code evolution/changes, this makes it worse.  Thats 
# my experience with it. :)
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.34:newos_path_dirname
olos_pat_dirname  = g.os_path_dirname
def newos_path_dirname( path, encoding = None ):
    if iscStringIO:
        c = g.top()
        return os.path.dirname( c.mFileName )
    else:
        return olos_pat_dirname( path, encoding )
</t>
<t tx="ekr.20070127142814.2025">#@-node:mork.20040926105355.34:newos_path_dirname
#@+node:mork.20040926105355.45:newendEditLabel
olEditLabel = leoTkinterTree.leoTkinterTree.endEditLabel
def newendEditLabel( self ):
    
    c = self.c
    rv = olEditLabel( self )
    v = c.currentPosition()
    if v and hasattr( c.frame.body, 'r'): 
        hS = v.headString()
        if hS:
            c.frame.body.r.configure( text = v.headString() )
    return rv
</t>
<t tx="ekr.20070127142814.2026">#@-node:mork.20040926105355.45:newendEditLabel
#@+node:mork.20040926105355.52:newselect
def newselect (self, v , updateBeadList = True):
    
    self.frame.body.lastNode = v
    notebook = notebooks.get(v.c)
    if not notebook: return # For unit testing
    self.frame.body.lastChapter = notebook.getcurselection()
    rv = ol_select( self , v, updateBeadList )
    if hasattr( v.c.frame.body, 'r' ):
        v.c.frame.body.r.configure( text = v.headString() )
    return rv
</t>
<t tx="ekr.20070127142814.2027">#@nonl
#@-node:mork.20040926105355.52:newselect
#@+node:mork.20040926105355.49:newTrashDelete
if hasattr( leoNodes.vnode, 'doDelete' ):
    olDelete = leoNodes.vnode.doDelete
else:
    olDelete = leoNodes.position.doDelete
def newTrashDelete(  self, newVnode):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    pagenames = [ getSV( x, c ).get().upper() for x in pagenames ]
    nbnam = notebook.getcurselection()
    if nbnam != None:
        name = getSV( notebook.getcurselection() , c ).get().upper()
    else: name = 'TRASH'
    tsh = 'TRASH'
    if name != tsh and tsh in pagenames:
        index = pagenames.index( tsh )
        trchapter = chapters[ getSV( index, c ) ]
        trashnode = trchapter.rp
        trchapter.setVariables()
        self.moveAfter( trashnode )
        c.cChapter.setVariables()
        c.selectVnode( newVnode )        
        return self
    olDelete( self, newVnode )
</t>
<t tx="ekr.20070127142814.2028">#@-node:mork.20040926105355.49:newTrashDelete
#@-others
#@nonl
#@-node:mork.20040930091624:decorated Leo functions
#@+node:mork.20040930091759:operation( node ) to Chapter
#@+others
#@+node:mork.20040926105355.31:cloneToChapter
if hasattr( leoFileCommands.fileCommands, 'write_LEO_file' ):
    olWrite_LEO_file = leoFileCommands.fileCommands.write_LEO_file
else:
    olWrite_LEO_file = leoFileCommands.fileCommands.write_Leo_file
    

def cloneToChapter( c , name ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    c.beginUpdate()
    vnd = c.currentPosition()
    clo = vnd.clone( vnd )
    clChapter = chapters[ page.sv ]
    vndm = clChapter.cp
    clo.unlink()
    clo.linkAfter(vndm)
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.2029">#@-node:mork.20040926105355.31:cloneToChapter
#@+node:mork.20040926105355.32:moveToChapter
def moveToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    mvChapter = chapters[ page.sv ]
    c.beginUpdate()
    vnd = c.currentVnode()
    if  not vnd.parent() and not vnd.back() :
        c.endUpdate()
        return None
    vndm = mvChapter.cp
    vnd.unlink()
    vnd.linkAfter(vndm)
    c.endUpdate()
    c.selectVnode( c.rootVnode() )
</t>
<t tx="ekr.20070127142814.2030">#@-node:mork.20040926105355.32:moveToChapter
#@+node:mork.20040926105355.33:copyToChapter
def copyToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    cpChapter = chapters[ page.sv ]
    c.beginUpdate()
    s = c.fileCommands.putLeoOutline()
    v = c.fileCommands.getLeoOutline( s )
    cpChapter.setVariables()
    mvnd = cpChapter.cp
    v.moveAfter( mvnd )
    c.cChapter.setVariables()
    c.endUpdate()
</t>
<t tx="ekr.20070127142814.2031">#@-node:mork.20040926105355.33:copyToChapter
#@+node:mork.20040926105355.39:makeNodeIntoChapter
def makeNodeIntoChapter( c, vnd = None ):
    renum = vnd
    if vnd == None:
        vnd = c.currentPosition()
    if vnd == c.rootPosition() and vnd.next() == None:
        return
    nxt = vnd.next()
    if nxt:
        vnd.doDelete( nxt )
        
    page = addPage( c )
    mnChapter = chapters[ page.sv ]
    c.beginUpdate()
    oChapter = c.cChapter
    mnChapter.makeCurrent()
    root = mnChapter.rp
    vnd.moveAfter( root )
    c.setRootPosition( vnd )
    oChapter.makeCurrent()
    c.endUpdate()
    if not renum:
        notebook = notebooks.get(c)
        if notebook: # For unit testing
            renumber(notebook)
    c.selectPosition( oChapter.rp )
</t>
<t tx="ekr.20070127142814.2032">#@-node:mork.20040926105355.39:makeNodeIntoChapter
#@-others
#@nonl
#@-node:mork.20040930091759:operation( node ) to Chapter
#@+node:mork.20040930092027:conversions
#@+others
#@+node:mork.20040926105355.37:conversionToSimple
def conversionToSimple( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        n = vnd.next()
        if n == None:
            break
        else:
            vnd = n
    pagenames = notebook.pagenames()
    current = notebook.getcurselection()
    pagenames.remove( current )
    c.beginUpdate()
    for z in pagenames:
        index = notebook.index( z )
        page = notebook.page( index )
        chapter = chapters[ page.sv ]
        rvNode = chapter.rp
        while 1:
            nxt = rvNode.next()
            rvNode.moveAfter( vnd )
            if nxt: rvNode = nxt
            else:
                vnd = rvNode 
                break
        notebook.delete( z )
    c.endUpdate()
    renumber( notebook )       
</t>
<t tx="ekr.20070127142814.2033">#@-node:mork.20040926105355.37:conversionToSimple
#@+node:mork.20040926105355.38:conversionToChapters
def conversionToChapters( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        nxt = vnd.next()
        if nxt:
            makeNodeIntoChapter(c , nxt )
        else:
            break
    setTree( notebook.pagenames()[ 0 ], notebook , c )     
</t>
<t tx="ekr.20070127142814.2034">#@-node:mork.20040926105355.38:conversionToChapters
#@-others
#@nonl
#@-node:mork.20040930092027:conversions
#@+node:mork.20040930092027.1:import/export
#@+at
# Import a Leo file as a Chapter(s).  Export a Chapter as a single Leo file.  
# Kinda handy.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.47:importLeoFile
def importLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.askopenfilename()
    if name:
        page = addPage( c , name )
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing       
        notebook.selectpage( notebook.pagenames()[ - 1 ] )
        c.fileCommands.open( file( name, 'r' ), name )
        c.cChapter.makeCurrent()
        renumber( notebook )
</t>
<t tx="ekr.20070127142814.2035">#@-node:mork.20040926105355.47:importLeoFile
#@+node:mork.20040926105355.48:exportLeoFile
def exportLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.asksaveasfilename()
    if name:
        if not name.endswith('.leo' ):
            name += '.leo'
        c.fileCommands.write_LEO_file( name, False, singleChapter = True )
</t>
<t tx="ekr.20070127142814.2036">#@-node:mork.20040926105355.48:exportLeoFile
#@-others
#@nonl
#@-node:mork.20040930092027.1:import/export
#@+node:mork.20040930092207:functions without classification
#@+at
# couldn't think of any parent node to group these under.
#@-at
#@@c
#@+others
#@+node:mork.20040926105355.46:swapChapters
def swapChapters( c, name ):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    cselection = notebook.getcurselection()
    tab1 = notebook.tab( cselection )
    tab2 = notebook.tab( name )
    tval1 = tab1.cget( 'text' )
    tval2 = tab2.cget( 'text' )
    tv1 = getSV( cselection, c )
    tv2 = getSV( name, c )
    chap1 = c.cChapter
    chap2 = chapters[ tv2 ]
    rp, tp, cp = chap2.rp, chap2.tp, chap2.cp
    chap2.rp, chap2.tp, chap2.cp = chap1.rp, chap1.tp, chap1.cp
    chap1.rp, chap1.tp, chap1.cp = rp, tp, cp
    chap1.setVariables()
    c.redraw()
    chap1.canvas.update_idletasks()
  
    val1 = tv1.get()
    val2 = tv2.get()
    if  val2.isdigit() :
        tv1.set( notebook.index( cselection ) + 1 ) 
    else: tv1.set( val2 )
    if val1.isdigit() :
        tv2.set( notebook.index( name ) + 1 )
    else: tv2.set( val1 )
</t>
<t tx="ekr.20070127142814.2037">#@-node:mork.20040926105355.46:swapChapters
#@+node:mork.20040926105355.50:emptyTrash
def emptyTrash( notebook  , c):
    pagenames = notebook.pagenames()
    pagenames = [ getSV( x, c ) for x in pagenames ]
    for z in pagenames:
        if z.get().upper() == 'TRASH':
            trChapter = chapters[ z ]
            rvND = trChapter.rp
            c.beginUpdate()
            trChapter.setVariables()
            nRt = rvND.insertAfter()
            nRt.moveToRoot()
            trChapter.rp = c.rootPosition()
            trChapter.cp = c.currentPosition()
            trChapter.tp = c.topPosition()
            c.cChapter.setVariables()
            c.endUpdate( False )
            if c.cChapter == trChapter:
                c.selectPosition( nRt )
                c.redraw()
                trChapter.canvas.update_idletasks()
            return
</t>
<t tx="ekr.20070127142814.2038">#@-node:mork.20040926105355.50:emptyTrash
#@+node:mork.20040926105355.51:regexClone
def regexClone( c , name ):
    if c == None: c = g.top()
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    sv = getSV( name, c )
    chapter = chapters[ sv ]
    
    def cloneWalk( result , entry, widget, c = c):
        txt = entry.get()
        widget.deactivate()        
        widget.destroy()
        if result == 'Cancel': return None
        import re
        regex = re.compile( txt )
        rt = chapter.cp
        chapter.setVariables()
        stnode = leoNodes.tnode( '', txt )
        snode = leoNodes.vnode( c, stnode)
        snode = leoNodes.position( snode, [] )
        snode.moveAfter( rt )
        ignorelist = [ snode ]
        it = walkChapters( c , ignorelist = ignorelist)
        for z in it:
            f = regex.search( z.bodyString() )
            if f:
                clone = z.clone( z )
                i = snode.numberOfChildren()
                clone.moveToNthChildOf( snode, i)
                ignorelist.append( clone )
                
        c.cChapter.setVariables()
        notebook.selectpage( name )
        c.selectVnode( snode )
        snode.expand()
        c.beginUpdate()
        c.endUpdate()
                
    sd = Pmw.PromptDialog( c.frame.top,
    title = 'Search and Clone',
    buttons = ( 'Search', 'Cancel' ),
    command =cloneWalk )
    entry = sd.component( 'entry' )
    sd.configure( command = 
        lambda result, entry = entry, widget = sd:
            cloneWalk( result, entry, widget ) )      
    sd.activate(  geometry = 'centerscreenalways' ) 
</t>
<t tx="ekr.20070127142814.2039">#@-node:mork.20040926105355.51:regexClone
#@-others
#@nonl
#@-node:mork.20040930092207:functions without classification
#@+node:mork.20040930091624.1:PDF
# Requires reportlab toolkit at http://www.reportlab.org

#@+others
#@+node:mork.20040926105355.42:doPDFConversion
def doPDFConversion( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import cStringIO
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer 
    from reportlab.lib.styles import getSampleStyleSheet 
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    PAGE_HEIGHT = defaultPageSize[ 1 ]
    PAGE_WIDTH = defaultPageSize[ 0 ]
    maxlen = 100
    styles = getSampleStyleSheet()
    pinfo = c.frame.shortFileName()
    pinfo1 = pinfo.rstrip( '.leo' )
    cs = cStringIO.StringIO()
    doc = SimpleDocTemplate( cs , showBoundary = 1)
    Story = [Spacer(1,2*inch)] 
    pagenames = notebook.pagenames()   
    cChapter = c.cChapter
    for n,z in enumerate( pagenames ):
        
        n = n + 1
        sv = getSV( z , c)
        chapter = chapters[ sv ]
        chapter.setVariables()
        p = chapter.rp
        if p:
            _changeTreeToPDF( sv.get(), n, p , c, Story, styles, maxlen)
    
    def otherPages( canvas, doc , pageinfo = pinfo):
    
        canvas.saveState()
        canvas.setFont('Times-Roman',9) 
        canvas.drawString(inch, 0.75 * inch, "Page %d %s" % (doc.page, pageinfo)) 
        canvas.restoreState()
    
    cChapter.setVariables()# This sets the nodes back to the cChapter, if we didnt the makeCurrent would point to the wrong positions
    cChapter.makeCurrent()
    doc.build(Story,  onLaterPages = otherPages)
    f = open( '%s.pdf' % pinfo1, 'w' )
    cs.seek( 0 )
    f.write( cs.read() )
    f.close()
    cs.close()
</t>
<t tx="ekr.20070127142814.2040">#@nonl
#@-node:mork.20040926105355.42:doPDFConversion
#@+node:mork.20040926105355.43:_changeTreeToPDF
def _changeTreeToPDF( name, num, p, c, Story, styles , maxlen):
    
    import copy
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer, PageBreak, XPreformatted
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    enc = c.importCommands.encoding
    hstyle = styles[ 'title' ]
    Story.append( Paragraph( 'Chapter %s: %s' % ( num, name), hstyle ) )
    style = styles[ 'Normal' ]
    g.trace(p)
    for v in p.allNodes_iter(): #self_and_subtree_iter doesn't seem to work here????  Switched to allNodes_iter
    # while v:
        head = v.moreHead( 0 )
        head = g.toEncodedString(head,enc,reportErrors=True) 
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            body = g.toEncodedString(body,enc, reportErrors=True)
            s = s + body
            s = s.split( '\n' )
            s2 = []
            for z in s:
                if len( z ) &lt; maxlen:
                    s2.append( z )
                else:
                    while 1:
                        s2.append( z[ : maxlen ] )
                        if len( z[ maxlen: ] ) &gt; maxlen:
                            z = z[ maxlen: ]
                        else:
                            s2.append( z[ maxlen: ] )
                            break
            s = '\n'.join( s2 )
            s = s.replace( '&amp;' ,'&amp;amp;' )
            s = s.replace( '&lt;', '&amp;lt;' )
            s = s.replace( '&gt;', '&amp;gt;' )
            s = s.replace( '"', '&amp;quot;' )
            s = s.replace( "`", '&amp;apos;' )
            Story.append( XPreformatted( s, style ) )
            Story.append( Spacer( 1, 0.2 * inch ) )
        #v = v.threadNext() 
    Story.append( PageBreak() )
</t>
<t tx="ekr.20070127142841.25">@first # -*- coding: utf-8 -*-

"""A plugin to use swing as Leo's gui."""

@language python
@tabwidth -4

__version__ = '0.01'

try:
    &lt;&lt; imports &gt;&gt;
    import_ok = True
except Exception:
    g.es('Can not init swingGui plugin')
    g.es_exception()
    import_ok = False
    
&lt;&lt; version history &gt;&gt;

False = 0
True = 1

@others
</t>
<t tx="ekr.20070127142841.26">import leoGlobals as g

import leoFrame
import leoGui
import leoMenu
import leoPlugins

import java.io as io
import org.leo.shell.IsolatedJythonClassLoader as ijcl ###

ld = io.File(g.app.loadDir)
ijcl.addToSearchPath(ld)
ijcl.beginLoading()

import base64
import copy
import string
import sys

import java

import java.awt as awt
import java.awt.datatransfer as datatransfer
import java.awt.event as aevent

import javax.imageio as imageio

import java.io as io

import java.lang
import java.lang.Exception
import java.lang.System as jsys

import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.event as sevent
import javax.swing.plaf.synth as synth
import javax.swing.text as stext  
import javax.swing.tree as stree
import javax.swing.undo as undo

import java.text as text

import java.util as util #
import java.util.concurrent as concurrent
import java.util.concurrent.atomic as atomic
import java.util.concurrent.locks as locks
import java.util.regex as jregex

# import pdb
from utilities.DefCallable import DefCallable
from utilities.TabManager import TabManager
from utilities.WeakMethod import WeakMethod

if 0: # Not ready yet: these should be in this file.
    import leoEditorKit2
    import EditorBackground
    import SwingMacs
    #import string
    #import leoPlugins
    #import base64
    import leoIconTreeRenderer
    import leoHeadlineTreeCellEditor
    import jarray
    import LeoUtilities
    #import copy
    import leoLanguageManager
    import PositionSpecification

if 0:
    @others
    pass</t>
<t tx="ekr.20070127142841.27">#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   
         
#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java
#import java.awt as awt
# import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent
# import java.io as io
# import java.lang
#import java.lang.Exception
#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
#import copy
import leoLanguageManager
import PositionSpecification</t>
<t tx="ekr.20070127142841.28">#import leoGlobals as g
#import leoFrame # for null gui.        
#import leoGui

#from utilities.DefCallable import DefCallable

#import java

#import java.awt as awt
#import java.awt.datatransfer as dtfr 
#import java.awt.event as aevent

#import java.io

#import java.lang.System as jsys

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent

#import java.text as text
</t>
<t tx="ekr.20070127142841.29">#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   
         
#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java

#import java.awt as awt
#import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent

#import java.io as io

#import java.lang
#import java.lang.Exception

#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
import copy
import leoLanguageManager
import PositionSpecification</t>
<t tx="ekr.20070127142841.30">#import leoGlobals as g

#import java.io as io
#import org.leo.shell.IsolatedJythonClassLoader as ijcl

#ld = io.File( g.app.loadDir )
#ijcl.addToSearchPath( ld )
#ijcl.beginLoading()
  
#import string
#import sys
#import leoMenu

#import java

#import java.awt as awt
#import java.awt.event as aevent
#import java.lang

#import javax.swing as swing  
#import javax.swing.border as sborder 
#import javax.swing.event as sevent
#import javax.swing.tree as stree  

# import pdb
# from utilities.DefCallable import DefCallable</t>
<t tx="ekr.20070127142841.31">@nocolor
@

0.001 EKR Initial code based on LeoJy2 version 1-11-06.</t>
<t tx="ekr.20070127142841.32">def init ():
    
    global import_ok
    if not import_ok: return False
    
    if g.app.gui:
        g.es('Can not install swingGui plugin: %s gui already active' % (g.app.gui.guiName()),color='red')
        return False

    splash = LeoSplash()
    java.awt.EventQueue.invokeAndWait(splash)

    gct = GCEveryOneMinute()
    gct.start()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)

    return True</t>
<t tx="ekr.20070127142841.33">class LeoSplash ( java.lang.Runnable ):
    
    def run( self ):
        self.splash = splash = swing.JWindow()
        splash.setAlwaysOnTop( 1 )
        cpane = splash.getContentPane()
        rp = splash.getRootPane()
        tb = sborder.TitledBorder( "Leo" )
        tb.setTitleJustification( tb.CENTER )
        rp.setBorder( tb )
        splash.setBackground( awt.Color.ORANGE )
        dimension = awt.Dimension( 400, 400 )
        splash.setPreferredSize( dimension )
        splash.setSize( 400, 400 )
        
        sicon = g.os_path_join( g.app.loadDir ,"..","Icons","Leosplash.GIF")
        #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
        ii = swing.ImageIcon( sicon )
        image = swing.JLabel( ii )
        image.setBackground( awt.Color.ORANGE )
        cpane.add( image )
        self.splashlabel = splashlabel = swing.JLabel( "Leo Starting...." )
        splashlabel.setBackground( awt.Color.ORANGE )
        splashlabel.setForeground( awt.Color.BLUE )
        cpane.add( splashlabel, awt.BorderLayout.SOUTH )
        w, h = self._calculateCenteredPosition( splash )
        splash.setLocation( w, h )
        splash.visible = True
        
    def _calculateCenteredPosition( self, widget ):

        size = widget.getPreferredSize()
        height = size.height/2
        width = size.width/2
        h,w = self._getScreenPositionForDialog()
        height = h - height
        width = w - width
        return width, height
        
    def _getScreenPositionForDialog( self ):

        #tk = self.c.frame.top.getToolkit()
        tk = awt.Toolkit.getDefaultToolkit()
        dim = tk.getScreenSize()
        h = dim.height/2
        w = dim.width/2
        return h, w   
        
    def setText( self, text ):  
        self.splashlabel.setText( text )
    
    def hide( self ):
        self.splash.visible = 0
        
    def toBack( self ):
        if self.splash.visible:
            self.splash.toBack()
    
    def toFront( self ):
        if self.splash.visible:
            self.splash.setAlwaysOnTop( 1 )
            self.splash.toFront()
    
    def isVisible( self ):
        return self.splash.visible
</t>
<t tx="ekr.20070127142841.34">class leoSwingBody (sevent.DocumentListener,aevent.KeyAdapter,sevent.UndoableEditListener):

    """The base class for the body pane in Leo windows."""

    @others</t>
<t tx="ekr.20070127142841.35">def __init__ (self,frame,parentFrame):
    
    self.editors = []
    self.ignore_insert = 0
    self.frame = frame
    self.c = c = frame.c
    self.forceFullRecolorFlag = False
    frame.body = self
    # May be overridden i
    #leoFrame.leoBody.__init__( self, frame, parentFrame )
    self.parentFrame = parentFrame
    self._current_editor = None
    self._undo_manager = None
    self.jdp = jdp = swing.JDesktopPane()
    self.jdp.addMouseListener( self.SimplifiedUtilityRightClick( self ) )
    #class AddEditor( event.MouseAdapter ):
    #    def __init__( self ):
    #        event.MouseAdapter.__init__( self )
    #    
    #    def mouse
            
        
    #self.mAdapter = leoSwingBody.UtilityRightClick( frame.c ) 
    #self.jdp.addMouseListener( self.mAdapter )
    self.editor = leoSwingBody.Editor( jdp, frame.c, self )
    #self.tabed_pane = swing.JTabbedPane()
    self.tab_manager = TabManager()
    self.tab_manager.add( "Editors", jdp )
    g.doHook( "body_pane_added", c = self.c, tabmanager = self.tab_manager )
    parentFrame.bottomComponent = self.tab_manager.base
    self.editor.frame.setMaximum( True )
    self.oldText = ""
    self.oldSel = ""
    self.oldYview = None
    self.ch = None
    
    #self.frame = frame
    #self.c = c = frame.c
    #self.forceFullRecolorFlag = False
    #frame.body = self
    
    # May be overridden in subclasses...
    #self.bodyCtrl = self
    
    # Must be overridden in subclasses...
    #self.colorizer = None
</t>
<t tx="ekr.20070127142841.36">def oops (self):
    
    g.trace("leoBody oops:", g.callerName(2), "should be overridden in subclass")</t>
<t tx="ekr.20070127142841.37">def setFontFromConfig (self):
    
    self.oops()</t>
<t tx="ekr.20070127142841.38">@
These methods, implementing DocumentListener, keeps the document and position data in sync.
And also adds to the undoer.
@c

def insertUpdate( self, event):
    
    #doc = event.getDocument()
    #txt = doc.getText( event.getOffset(), event.getLength() )       
    self._syncText( event )

    
    
def removeUpdate( self, event):
    self._syncText( event, which = 0 )
    
def changedUpdate( self, event ):
    pass #this does Attribute changes
    


def _syncText( self, event, which = 1 ):
    
    if self.ignore_insert: return
    c = self.c 
    doc = event.getDocument()
    #From here to
    oldText = self.oldText
    oldSel = self.oldSel 
    oldYview = self.oldYview 
    ch = self.ch
    #Here, these are set in the KeyAdapter node
    
    newSel = c.frame.body.getTextSelection()
    #length = doc.getLength()
    #newText = doc.getText( 0 , length )
    p = c.currentPosition().copy()

    undoType='Typing'
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        event.consume()
        return
        
    pos = c.currentPosition()
    #pos.setTnodeText( newText )
    t = pos.v.t
    offset = event.getOffset()
    length = event.getLength()
    if which:
        txt = doc.getText( offset, length )
        t._bodyString.insert( offset, txt )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c , event, txt )
        #c.undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()
    else:
        #offset = offset - length
        txt = t.bodyString[ offset: offset + length ]
        t._bodyString.delete( offset, offset + length )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c, event, txt )
        #c.undoer.addUndo( dec_edit )
        #c.frame.body.editor._node_undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()
        
    if not pos.isDirty():
        pos.setDirty()
        c.setChanged( True )  
    
    #for z in self.editor.synchers:
    #    z.sync()
        
    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)   
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType) 
    







</t>
<t tx="ekr.20070127142841.39">def createBindings (self,frame):
    self.oops()

def createControl (self,frame,parentFrame):
    self.oops()
    
def initialRatios (self):
    self.oops()
    
def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    pass
    
def setBodyFontFromConfig (self):
    self.oops()
    
</t>
<t tx="ekr.20070127142841.40">def bbox(self,index):

    self.oops()</t>
<t tx="ekr.20070127142841.41">def tag_add (self,tagName,index1,index2):

    self.oops()

def tag_bind (self,tagName,event,callback):

    self.oops()

def tag_configure (self,colorName,**keys):

    self.oops()

def tag_delete(self,tagName):

    self.oops()

def tag_remove (self,tagName,index1,index2):
    self.oops()</t>
<t tx="ekr.20070127142841.42">def cget(self,*args,**keys):
    
    self.oops()
    
def configure (self,*args,**keys):
    
    self.oops()</t>
<t tx="ekr.20070127142841.43">def hasFocus (self):
    
    return self.editor.editor.hasFocus()
    
def setFocus (self):
    
    df = DefCallable( self.editor.editor.requestFocusInWindow )
    ft = java.util.concurrent.FutureTask( df )
    java.awt.EventQueue.invokeLater( ft )
    
def focus_get( self ):
    
    return self</t>
<t tx="ekr.20070127142841.44">def getBodyPaneHeight (self):
    
    return self.editor.editor.getSize().height

def getBodyPaneWidth (self):
    
    return self.editor.editor.getSize().width </t>
<t tx="ekr.20070127142841.45">def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.oops()</t>
<t tx="ekr.20070127142841.46">def adjustIndex (self,index,offset):
    
    return index + offset
    
def compareIndices(self,i,rel,j):

    if j == 'end' or j == '1.0':
        if j == 'end':
            j = self.editor.editor.getDocument().getLength()
        elif j == '1.0':
            j = 0
                 
    if rel == '&lt;=':
        return i &lt;= j
    
def convertRowColumnToIndex (self,row,column):
    
    self.oops()
    
def convertIndexToRowColumn (self,index):
    
    self.oops()
    
def getImageIndex (self,image):
    
    self.oops()</t>
<t tx="ekr.20070127142841.47">def getBeforeInsertionPoint (self):
    
    editor = self.editor.editor
    pos = editor.getCaretPosition()
    if pos == 0:
        return 0
    else:
        return pos - 1

def getInsertionPoint (self):

    return self.editor.editor.getCaretPosition()
    
def getCharAtInsertPoint (self):
    
    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if dlen == pos:
        return " "
    else:
        return doc.getText( pos, 1 )

def getCharBeforeInsertPoint (self):
    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if pos == 0:
        return " "
    else:
        return doc.getText( pos - 1, 1 )
    
def makeInsertPointVisible (self):
    pass #this doesn't seem to be a relevant method at this point
    
def setInsertionPoint (self,index):
    
    self.editor.editor.setCaretPosition( index )

def setInsertionPointToEnd (self):
    
    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setCaretPosition( doc.getLength() )
    
def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number
    
    txt = self.editor.editor.getText()
    lines = txt.splitlines( True )
    n = 0
    for z in xrange( lineNumber ):
        n += len( lines[ z ] )
       
    self.editor.editor.setCaretPosition( n )
    </t>
<t tx="ekr.20070127142841.48">def bind (self,*args,**keys):
    
    #self.oops()
    pass
</t>
<t tx="ekr.20070127142841.49">def deleteTextSelection (self):

    editor = self.editor.editor
    editor.replaceSelection( "" )
    
def getSelectedText (self):

    editor = self.editor.editor
    return editor.getSelectedText()
    
def getTextSelection (self):
    
    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    return start, end
    
def hasTextSelection (self):
    
    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start != end: return True
    else: return False
    
def selectAllText (self):

    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setSelectionStart( 0 )
    editor.setSelectionEnd( doc.getLength() )
    
def setTextSelection (self,i,j=None):
    
    if i is None:
        i, j = 0, 0
    elif i != None and j != None:
        pass
    else:
        i,j = i
    editor = self.editor.editor
    g.app.gui.setTextSelection( editor, i, j )</t>
<t tx="ekr.20070127142841.50"></t>
<t tx="ekr.20070127142841.51">def deleteAllText(self):
    
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace( 0, doc.getLength(), "", None )

def deleteCharacter (self,index):
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace( index, 1, "", None )
    
    
def deleteLastChar (self):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.replace( sdoc.getLength() - 1, 1, "", None )
    
    
def deleteLine (self,lineNumber): # zero based line number.

    
    editor = self.editor.editor
    txt = editor.getText()
    lines = txt.splitlines( True )
    start = lines[ : lineNumber ]
    end = lines[ lineNumber + 1 : ]
    start.extend( end )
    ntxt = ''.join( start )
    sdoc = editor.getStyledDocument()
    sdoc.replace( 0, sdoc.getLength(), "", None )
    sdoc.insertString( 0, ntxt, None )
    
def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    #self.oops()
    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines( True )
    start = txtlines[ : line1 ]
    middle = [ '\n', ]
    end = txtlines[ line1 + numberOfLines : ]
    start.extend( middle )
    start.extend( end )
    
    ntxt = ''.join( start )
    sdoc = editor.getStyledDocument()
    try:
        sdoc.replace( 0, sdoc.getLength(), ntxt , None )
        
    except java.lang.Exception, x:
        x.printStackTrace()
        
    
    
    
def deleteRange (self,index1,index2):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.remove( index1, index2 -index1 )
    
</t>
<t tx="ekr.20070127142841.52">def getAllText (self):
    
    editor = self.editor.editor
    doc = editor.getDocument()
    return doc.getText()
    
def getCharAtIndex (self,index):
    
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText( index, 1 )
    
def getInsertLines (self):
    self.oops()
    return None,None,None
    
def getSelectionAreas (self):
    self.oops()
    return None,None,None
    
def getSelectionLines (self):
    #self.oops()
    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end:
        start = stext.Utilities.getRowStart( editor, start )
        end = stext.Utilities.getRowEnd( editor, start )
        if start == -1: start = 0
        if end == -1: end = 0
    
    before = editor.getText( 0, start )
    sel = editor.getText( start, end - start )
    after = editor.getText( end, len( editor.getText() ) - end )
    return before, sel, after
    
    
    
def getTextRange (self,index1,index2):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText( index1, index2 -index1 )
    
</t>
<t tx="ekr.20070127142841.53">def insertAtInsertPoint (self,s):
    
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    pos = editor.getCaretPosition()
    sdoc.insertString( pos, s, None )
    editor.setCaretPosition( pos + len( s ) )
    
def insertAtEnd (self,s):
    
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    length = sdoc.getLength()
    sdoc.insertString( length - 1, s, None )
    editor.setCaretPosition( length -1 + len( s ))
    
def insertAtStartOfLine (self,lineNumber,s):
    
    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines( True )
    lines = txtlines[ : lineNumber ]
    where = ''.join( lines )
    spot = len( where )
    sdoc = editor.getStyledDocument()
    sdoc.insertString( spot, s, None )
    editor.setCaretPosition( spot + len( s ) )
    
</t>
<t tx="ekr.20070127142841.54">def setSelectionAreas (self,before,sel,after):

    
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.remove( 0, doc.getLength() )
    if before:
        doc.insertString( 0, before, None )
    sel_start = doc.getLength()
    
    if sel:
        doc.insertString( doc.getLength(), sel, None )
    sel_end = doc.getLength()
    
    if after:
        if after[ -1 ] == '\n':
            after = after[ : -1 ]
        doc.insertString( doc.getLength(), after, None )
        
    g.app.gui.setTextSelection( self.editor.editor, sel_start, sel_end )
    
    return sel_start, sel_end
</t>
<t tx="ekr.20070127142841.55">def makeIndexVisible (self,index):
    pass
    
def setFirstVisibleIndex (self,index):
    pass
    
def getYScrollPosition (self):
    
    editor = self.editor.editor
    try:
        cpos = editor.getCaretPosition()
        rec = editor.modelToView( cpos )
        return rec.y 
    except:
        return 0
    
def setYScrollPosition (self,scrollPosition):
    #self.oops()
    #print "Y Scroll is %s" % scrollPosition
    pass   

def scrollUp (self):
    self.oops()
    
def scrollDown (self):
    self.oops()</t>
<t tx="ekr.20070127142841.56"># It's weird to have the tree class be responsible for coloring the body pane!

def getColorizer(self):
    
    return self.colorizer

def recolor_now(self,p,incremental=False):
    
    self.editor.editor.repaint()
    #self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):
    
    pass 
    #self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):
    
    pass
    #if 0: # Do immediately
    #    self.colorizer.colorize(p.copy(),incremental)
    #else: # Do at idle time
    #    self.colorizer.schedule(p.copy(),incremental)
    
def updateSyntaxColorer(self,p):
    pass
    #return self.colorizer.updateSyntaxColorer(p.copy())</t>
<t tx="ekr.20070127142841.57">class Editor( aevent.FocusListener ):
    
    ipath = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp2.GIF")
    icon = swing.ImageIcon( "../Icons/Leoapp2.GIF" )
    icon = swing.ImageIcon( ipath ) 
    #ifile = java.io.File( ipath )
    #iimage = imageio.ImageIO.read( ifile ) 

    @others
                    

        
        

</t>
<t tx="ekr.20070127142841.58">class InsertTextIntoBody( swing.AbstractAction ):
    
    def __init__( self, c, txt ):
        swing.AbstractAction.__init__( self, txt )
        self.txt = txt
        self.c = c
        
    def actionPerformed( self, event ):
        
        editor = self.c.frame.body.editor.editor 
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString( pos, self.txt, None )
        
        
        
class SetHeadline( InsertTextIntoBody ):
    
    def __init__( self, c,txt ):
        leoSwingBody.Editor.InsertTextIntoBody.__init__( self, c, txt )
        
    def actionPerformed( self, event ):
    
        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" %( self.txt, hS )
        cp.setHeadString( newHeadString )
        
        
class SetHeadlineToSelection( InsertTextIntoBody  ):
    def __init__( self, c, txt ):
        leoSwingBody.Editor.InsertTextIntoBody.__init__( self, c, txt )
        
    def actionPerformed( self, event ):
        
        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString( txt )
        
        
        
class rmvSymbol( swing.AbstractAction ):
    def __init__( self, c, symbol ):
        swing.AbstractAction.__init__( self, "remove %s" % symbol )
        self.c = c
        self.symbol = symbol
        
    def actionPerformed( self, event ):
        
        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith( self.symbol ):
            hS = hS.split()
            hS = hS[ 1: ]
            hS = " ".join( hS )
            cp.setHeadString( hS )
            


class inSRMenuListener( sevent.MenuListener ):

    def __init__( self, menu, c ):
        self.menu = menu
        self.c = c   
                
    def menuCanceled( self, event ):
        pass
                
    def menuDeselected( self, event ):
        pass
                
    def menuSelected( self, event ):
        
        menu = self.menu       
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith( "&lt;%s" % '&lt;' ) and hS.endswith( "&gt;%s" % "&gt;" ):
                menu.add( InsertTextIntoBody( self.c, hS ) )    

</t>
<t tx="ekr.20070127142841.59">class ColorKeywordsProvider( leoEditorKit2.ColorDeterminer, sevent.DocumentListener ):
         
    def __init__( self, c ):
        

        lb = leoLanguageManager.LanguageManager.getLanguageBundle( c )
        for z in dir( lb ):
            if not callable( getattr( lb, z ) ):
                setattr( self, z, getattr( lb, z ) )
                
        self.c = c    
        self.last_p = None 
        self.last_language = None   
        self.editor = None    
        self.error_map = util.HashMap()
        fg, bg, cl = self.getLineNumberColors()
        self.line_fg = fg; self.line_bg = bg; self.line_cl = cl
        self.queue = concurrent.LinkedBlockingQueue()
        self.c.invisibleWatchers.append( self )
        return

                      
    def getOperators( self ):
        return util.HashMap()
                  
            
    def getColoredTokens( self ):
                
                
        cp = self.c.currentPosition().copy()
        if cp != self.last_p:
            #language = g.scanForAtLanguage( self.c, cp )
            language = LeoUtilities.scanForLanguage( cp )
            self.last_p = cp
            self.last_language = language
        else:
            language = self.last_language
            
        leoLanguageManager.LanguageManager.setLanguageInEffect( self.c, language )
        
        if language == None:
            language = "python"
        if hasattr( self, "%s_keywords" % language ):
            return getattr( self, "%s_keywords" % language )
        else:
            hm = leoLanguageManager.LanguageManager.loadLanguage( self.c, language )
            setattr( self, "%s_keywords" % language, hm )
            return hm

        
    def getCommentTokens( self ):
        
        cp = self.c.currentPosition().copy()
        if cp != self.last_p:
            #language = g.scanForAtLanguage( self.c, cp )
            language = LeoUtilities.scanForLanguage( cp )
            self.last_p = cp
            self.last_language = language
        else:
            language = self.last_language
        if self.comment_cache.has_key( language ):
            return self.comment_cache[ language ]
        else:
            rv = g.set_delims_from_language( language )
            rv = jarray.array( rv, java.lang.String )
            self.comment_cache[ language ] = rv
            return rv
        #delim1,delim2, delim3 = g.set_delims_from_language( language )
        #return [ delim1, delim2, delim3 ]
             
    def underline( self ):
        return self._underline
    
    def getNumericColor( self ):
        return self._numericcolor
        
    def getUndefinedSectionReferenceColor( self ):
        return self._undefinedSectionNameColor
        
    def getSectionReferenceColor( self ):
        return self._sectionNameColor        

    def getStringColor( self ):
        return self._stringColor
        
    def getCommentColor( self ):
        return self._commentColor
     
    def getDocColor( self ):
        return self._docColor 
        
    def notify( self ):
        self.c.frame.body.editor.ekit.showInvisibles( self.c.showInvisibles )
    
    def showInvisibles( self ):
        return self.c.showInvisibles 
       
    def getInvisiblesBlock( self ):
        return self._invisibleBlock
    
    def getInvisiblesDot( self ):
        return self._invisibleDot
        
    def whichInvisible( self ):
        return self._which_invisible
        
    def getPunctuationColor( self ):
        return self._punctuationColor
        
    def getFoldedBackgroundColor( self ):
        return self._fbColor
        
    def getFoldedForegroundColor( self ):
        return self._ffColor

    

    def drawrectangle( self ):
        return self._drawrectangle
        
    def getRectangleColor( self ):
        return self._rectanglecolor
        
    def setEditor( self, editor ):
        self.editor = editor
        doc = editor.getDocument()
        doc.addDocumentListener( self )
        
        
    def insertUpdate( self, event):
        self.checkForLanguageChange( event )
    
    def removeUpdate( self, event):
        self.checkForLanguageChange( event )

        
    def checkForLanguageChange( self, event ):
        
        language = LeoUtilities.scanForLanguageOnLine( self.editor )
        if language:
            #if not hasattr( self, "%s_keywords" % language ):
            if self.last_language != language:
                #self.editor.repaint()
                self.last_language = language
                jlc = self.c.frame.body.editor.jlc
                jlc.fullrecolorize()

    
    
    def changedUpdate( self, event ):
        pass #this does Attribute changes
    
    
    def useLineNumbers( self ):
        return g.app.config.getBool( self.c, "use_line_numbering" )
        
    def getLineNumberForeground( self ):
        return self.line_fg
        
    def getCurrentLineNumberForeground( self ):
        return self.line_cl
        
    def getLineNumberBackground( self ):
        return self.line_bg
    
    #public boolean useLineNumbers();
    #public Color getLineNumberForeground();
    #public Color getCurrentLineNumberForeground();
    #public Color getLineNumberBackground();
    def getFootNodeBackgroundColor( self ):
        return self._fnbgColor
        
    def getFootNodeForegroundColor( self ):
        return self._fnfgColor
    
    
    def hasFootNodes( self ):
        
        cp = self.c.currentPosition()
        t = cp.v.t
        if hasattr( t, "unknownAttributes" ):
            uas = t.unknownAttributes
            if uas.has_key( "footnodes" ):
                fn = uas[ "footnodes" ]
                if fn: return True
        return False
        
    def getFootNodes( self ):
        
        cp = self.c.currentPosition()
        t = cp.v.t
        if hasattr( t, "unknownAttributes" ):
            uas = t.unknownAttributes
            if uas.has_key( "footnodes" ):
                fn = uas[ "footnodes" ]
                sb = java.lang.StringBuilder()
                for z in fn:
                    sb.append( z[ 0 ] ).append( " : " ).append( z[ 1 ] )
                    if not z[ 1 ].endswith ( "\n" ): sb.append( "\n" )
                return sb.toString()
        return ""
    
    @others
    

</t>
<t tx="ekr.20070127142841.60">def getLineNumberColors( self ):
    
    c = self.c

    bg = g.app.config.getColor( c, "line_number_background" )
    fg = g.app.config.getColor( c, "line_number_foreground" )
    cl = g.app.config.getColor( c, "line_number_current" )
    try:
        bg = getColorInstance( bg )
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance( fg )
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance( cl )
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW    
    return fg, bg, cl


            
</t>
<t tx="ekr.20070127142841.61">class RecentVisitsMenuListener( sevent.MenuListener ):

    def __init__( self, menu, c, recent ):
        self.menu = menu
        self.c = c   
        self.recent = recent
                
    def menuCanceled( self, event ):
        pass
                
    def menuDeselected( self, event ):
        pass
                
    def menuSelected( self, event ):
        
        menu = self.menu       
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add( goNode( z, self.c ) )
          </t>
<t tx="ekr.20070127142841.62">@
The key to making:
    1. Autocompleter
    2. Line numbers
    3. Any any future floaters
work is in the use of the JLayeredPane.  The JLayeredPane is made for floating widgets on top of one another.


This allows the autocompleter to appear on top of the JTextPane when needed.  It also allows
the easy placement of the Line number label to the left.

The line number label was tried as a JTextPane to start with, this gave us numbers parralel to the editor.
But this seemed to introduce a scroll bug that became apparent when the editor had a large volume of lines in it.  My
assumption is that this was because of some event the Caret for the line number editor was executing when its contents
changed.  By moving to a Label that is drawn on my a method in the LeoView class this problem no longer presented itself,
mainly because a JLabel doesnt have a Cursor.  If that was the source of the problem.

The viewport is secretly tied to the JTextPane by a specialised jython JLayeredPane that returns the preferred size of the
JTextPane instead of itself.  This causes the JScrollPane to actually scroll with the editor.

To calculate the coordinates of a floater you need to do the minimum:
1. Translate the viewports visible rectangle into the JLayeredPanes coord system.
    2. Translate the JTextPane into the JLayeredPanes coord system.
    3. Do calculations based off of those two pieces of information.


@c
</t>
<t tx="ekr.20070127142841.63">def __init__( self, parent, c , body, x = 0, y = 0):
        
    self.c = c
    self.body = body
    wr = java.lang.ref.WeakReference( self )
    self.body.editors.append( wr )
    self.synchers = []
    self._parent = parent 
    self.frame = swing.JInternalFrame( "", 1, 1, 1, 1, 
                                      size = ( 400, 400 ) )
    self.frame.setFocusTraversalPolicy( c.frame.ftp )
    self._attached = True
              
    cpane = self.frame.getContentPane()
    self.tab_manager = TabManager()
    self.tab_manager.tabsToBottom()
    self.visible_informer = VisibleInformer( self.tab_manager.jtp )
    cpane.add( self.tab_manager.base, java.awt.BorderLayout.CENTER )
    self.editorlomanager = self.leoLayoutManager()
    self.epane = swing.JPanel()
    self.epane.setLayout( self.editorlomanager )
    self.frame.setFrameIcon( leoSwingBody.Editor.icon )
        
    self.initializeEditor()        
    self.initializeFont()
    &lt;&lt; add EditorKit&gt;&gt;
    
    #self.editor.addFocusListener( self.tFocusListener())
    self.editor.addMouseListener( leoSwingBody.UtilityRightClick( c , detach_retach = True, editor = self ) )
    self.addMinibuffer()
    self.swingmacs = SwingMacs.SwingMacs( self.editor, self.minibuffer, self.minilabel, c )
    c.frame.isMenuInitialized( self.createCommanderCommander )
    
    #self.swingmacs.addCommands( commandercommander, commandercommander.getCommands() )
    self.addCompleters()
    self.addMenus()    
    
    self.brackethighlighter = self.BracketHighlighter( self.editor, c ) # initializeCaret needs this to work
    self.initializeCaret()
                    

    self.editor.setName( "Editor" )

    self.editor.getDocument().addDocumentListener( body )
    self.editor.addKeyListener( body )
    &lt;&lt; add autocompleter &gt;&gt;
    &lt;&lt; add scrollpane &gt;&gt;


    self.configureMedia()
    self.editor.addFocusListener( self )
    self.frame.setLocation( x, y )
    parent.add( self.frame, swing.JLayeredPane.DEFAULT_LAYER )
    self.initializeEditorColors()
    self.frame.visible = 1
    self.lastPosition = None
    self.chapter = None
    wm1 = WeakMethod( self, "chapterChanged" )
    wm2 = WeakMethod( self, "headlineChanged" )
    leoPlugins.registerHandler( "chapter-changed", wm1 )
    leoPlugins.registerHandler( "chapter-removed", wm1 )
    leoPlugins.registerHandler( "headline-editing-finished", wm2 )
    
    bd = self.ekit.getBorder()
    vpb = self.view.getViewportBorder()
    if vpb:
        bd = sborder.CompoundBorder( bd, vpb )
    self.view.setViewportBorder( bd )
    self.sync()
    self.chapter = c.chapters.current_chapter
    g.doHook( "editor-created", editor = self )

    
    
    



</t>
<t tx="ekr.20070127142841.64">self.cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider( self.c )
self.cdeterminer = weakref.proxy( cdeterminer )
#use_line_numbers = g.app.config.getBool( c, "use_line_numbering" )  
use_line_numbers = 0 
if use_line_numbers:
    pass
    #self.initializeLineNumbering()
else:
    self.numbers = None
    
#self.ekit = leoEditorKit( cdeterminer, self.numbers )
import leoEditorKit2
self.ekit = leoEditorKit2( self.editor, cdeterminer, leoSwingBody.Editor.icon )
self.editor.setEditorKit( self.ekit )
#self.editor.setDocument( ekit.createDefaultDocument() )
cdeterminer.setEditor( self.editor )
import JyLeoColorizer
self.jlc = JyLeoColorizer.JyLeoColorizer( self.editor, cdeterminer )
self.foldprotection = self.FoldProtector( self.editor, self.ekit )
self.editor.getDocument().setDocumentFilter( self.foldprotection )
#self.editor.getDocument().addUndoableEditListener( self.body )

</t>
<t tx="ekr.20070127142841.65">self.autocompleter = self.autolistener( self )
self.editor.getDocument().addDocumentListener( self.autocompleter )
self.editor.addKeyListener( self.autocompleter )
g.app.config.manager.addNotificationDef( "use_autocompleter", self.useAutocompleter )
self.useAutocompleter()

    

</t>
<t tx="ekr.20070127142841.66">spc = swing.ScrollPaneConstants
#self.view = swing.JScrollPane( layeredpane )
self.view = swing.JScrollPane( self.editor )
self.editorlomanager.jscrollpane = self.view
self.editor.addFocusListener( leoJSPFocusListener( self.view, self.c  ) )
self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER )
self._vport = vport = self.view.getViewport()
vport.addComponentListener( self.resizer2( self.editorlomanager ) )
vport.setScrollMode( vport.BLIT_SCROLL_MODE ) #fastest, removes alot of the flicker I saw
mwl = self.view.getMouseWheelListeners()[ 0 ]
self.editor.addMouseWheelListener( mwl )
self.frame.addMouseWheelListener( mwl )
self.epane.add( self.view )
#jtp.add( "Editor", self.epane )
self.tab_manager.add( "Editor", self.epane )
self.visible_informer.addCallback( self.epane, self.nowShowing )
#jtp.add( "Editor", self.view )
#cpane.add( self.view )</t>
<t tx="ekr.20070127142841.67">@others</t>
<t tx="ekr.20070127142841.68">@
Just some methods the constructor calls to build the gui components.

@c



@others</t>
<t tx="ekr.20070127142841.69">def addMenus( self ):
    
    self.menu = swing.JMenuBar()
    self.frame.setJMenuBar( self.menu )
    self.gotoMenu = gm = swing.JMenu( "Goto" )
    recmen = swing.JMenu( "Recent" )
    self.recent = []
    recmen.addMenuListener( leoSwingBody.Editor.RecentVisitsMenuListener( recmen, self.c, self.recent ) )
    gm.add( recmen )
    self.menu.add( gm ) 
    self.configureGotoMenu( gm )

    self.bodyMenu = body = swing.JMenu( "Body" )
    self.menu.add( body )
    directives = swing.JMenu( "Directives" )
    self.directiveMenu( directives )
    #self.menu.add( directives )
    body.add( directives )
    self.addLanguageMenu( body )
    headline = swing.JMenu( "Headline" )
    self.headlineMenu( headline )
    self.menu.add( headline )
    isSR = swing.JMenu( "Insert&lt;%s%s&gt;" % ('&lt;','&gt;' ) )
    self.insertSR( isSR )
    body.add( isSR )

    
    insPath = swing.JMenuItem( "Insert @path With File Dialog" )
    self.addInsertPath( insPath )
    body.add( insPath )
    
    #self.addFootNodeMenu( body )
    
    config = g.app.config
    wrap = config.getBool( self.c, "body_pane_wraps" )
    self.ekit.setLineWrap( wrap )
    wrapmenuitem = swing.JCheckBoxMenuItem( "Wrap Lines" )
    wrapmenuitem.setState( wrap )
    def wrapcommand( event ):
        source = event.getSource()
        wrap = source.getState()
        self.ekit.setLineWrap( wrap )
        if wrap:
            self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER )
        else: self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED )
            
    wrapmenuitem.actionPerformed = wrapcommand
    body.add( wrapmenuitem )
    if config.getBool( self.c, "use_text_undo" ):
        umenu = swing.JMenuItem( "" )
        rmenu = swing.JMenuItem( "" )
        gtnu = swing.JMenuItem( "Goto Next Undo Spot" )
        gtnr = swing.JMenuItem( "Goto Next Redo Spot" )
        vunstack = swing.JMenuItem( "Visualise Undo Stack" )
        clear_undo = swing.JMenuItem( "Clear Undo" )
        self._node_undoer = leoSwingUndo.NodeUndoer( self.c, umenu, rmenu, gtnu, gtnr, vunstack, clear_undo, self.editor )
        #print self._node_undoer
        body.addSeparator()
        body.add( umenu )
        body.add( rmenu )
        body.addSeparator()
        body.add( gtnu )
        body.add( gtnr )
        body.addSeparator()
        body.add( vunstack )
        body.add( clear_undo )
    else:
        self._node_undoer = None
    
    self.viewMenu = vmenu = swing.JMenu( "Views" )
    self.menu.add( vmenu )
    jmi = swing.JCheckBoxMenuItem( "CompositeView" )
    vmenu.add( jmi )
    jmi.actionPerformed = self.addCompositeView 
    
    
    self.helpmenu = swing.JMenu( "Help" )
    self.menu.add( self.helpmenu )
    self.helpmenu.add( self.smacs_help( self.c, self.swingmacs, "Keystrokes" ) )
    self.helpmenu.add( self.smacs_help( self.c, self.swingmacs, "Commands" ) )
    self.helpmenu.add( self.autocompleter_help() )
    if hasattr( self.body, 'ebm' ):
        ccomp = self.body.ebm.getControlPanelComponent()
        self.menu.add( ccomp )


</t>
<t tx="ekr.20070127142841.70">def addMinibuffer( self ):

    self.minilabel = swing.JLabel()
    self.minibuffer = minibuffer = swing.JTextField( 15 )
    frame = swing.JPanel()
    frame.setLayout( swing.BoxLayout( frame, swing.BoxLayout.X_AXIS ) )
    frame.add( self.minilabel )
    frame.add( minibuffer )
    frame.setName( "Minibufferbackground" )
    self.epane.add( frame )# awt.BorderLayout.SOUTH )
    self.editorlomanager.minibuffer = frame
    #cpane = self.frame.getContentPane()
    #cpane.add( frame, awt.BorderLayout.SOUTH )
</t>
<t tx="ekr.20070127142841.71">def addCompleters( self ):
    
    config = g.app.config
    if config.getBool( self.c, "complete-&lt;" ):
        self.swingmacs.addCompleter( "&lt;", "&gt;" )
    if config.getBool( self.c, "complete-(" ):
        self.swingmacs.addCompleter( "(", ")" )
    if config.getBool( self.c, "complete-[" ):
        self.swingmacs.addCompleter( "[", "]" )
    if config.getBool( self.c, "complete-{"):
        self.swingmacs.addCompleter( "{", "}" )
    if config.getBool( self.c, "complete-'" ):
        self.swingmacs.addCompleter( "'", "'" )
    if config.getBool( self.c, 'complete-"' ):
        self.swingmacs.addCompleter( '"', '"' )
    if config.getBool( self.c, "add_tab_for-:" ):
        self.swingmacs.addTabForColon( True )
        
    
        
        
</t>
<t tx="ekr.20070127142841.72">def initializeEditor( self ):
    

    self.editor = self.leoJTextPane( self.c )
    self.editor.setLineColor()
    self.body._current_editor = self.editor
    manager = g.app.config.manager
    wm1 = WeakMethod( self.editor, "setLineColor" )
    manager.addNotificationDef( "highlight_current_line", wm1 )
    manager.addNotificationDef( "current_line_highlight_color", wm1 )
</t>
<t tx="ekr.20070127142841.73">def initializeEditorColors( self ):
    
    self.setEditorColors()
    manager = g.app.config.manager
    wm1 = WeakMethod( self, "setEditorColors" )
    manager.addNotificationDef( 'body_text_foreground_color', wm1 )
    manager.addNotificationDef( 'body_text_background_color', wm1 )
    manager.addNotificationDef( 'body_selection_color', wm1 )
    manager.addNotificationDef( 'body_text_selected_color', wm1 )


</t>
<t tx="ekr.20070127142841.74">def initializeFont( self ):
    
    self.setFont()
    manager = g.app.config.manager
    wm1 = WeakMethod( self, "setFont" )
    manager.addNotificationDef( "body_text_font_family", wm1 )
    manager.addNotificationDef( "body_text_font_size", wm1 )
    manager.addNotificationDef( "body_text_font_weight", wm1 )    

</t>
<t tx="ekr.20070127142841.75">def initializeCaret( self ):
    
    self.setCaret()
    wm1 = WeakMethod( self, "setCaret" )
    g.app.config.manager.addNotificationDef( "which_caret", wm1 )
   
</t>
<t tx="ekr.20070127142841.76">def initializeLineNumbering( self ):
    
    fg, bg, cl = self.getLineNumberColors()
    #self.numbers = leoEditorKit.LeoNumberLabel( bg, fg, cl )
    manager = g.app.config.manager
    wm1 = WeakMethod( self, "setLineNumberColors" )
    manager.addNotificationDef( "line_number_background", wm1 )
    manager.addNotificationDef( "line_number_foreground", wm1 )
    manager.addNotificationDef( "line_number_current", wm1 )    

</t>
<t tx="ekr.20070127142841.77">def createCommanderCommander( self, menu ):
    
    commandercommander = self.CommanderCommander( self.c, self.swingmacs, menu )
    self.swingmacs.addCommands( commandercommander, commandercommander.getAltXCommands() )</t>
<t tx="ekr.20070127142841.78">@others
</t>
<t tx="ekr.20070127142841.79">def configureMedia( self ):
    
    c = self.c 
    use_background = g.app.config.getBool( c, "use_media_background" )    
    if use_background:
        try:
            background_which = g.app.config.getString( c, "media_background_type" )
            if background_which=='image':
                self.setBackgroundImage()
            elif background_which=='movie':
                movie = g.app.config.getString( c, "movie_location@as-filedialog" )
                if movie:
                    self.background = swing.JPanel()
                    self.background.setOpaque( False )
                    import EditorBackgroundMovie
                    ebm = EditorBackgroundMovie( movie, self.background )
                    if ebm.loadOk():
                        self.epane.add( self.background )
                        self.editorlomanager.media = self.background
                        #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
                        #self._vport.addChangeListener( self._resizer )
                        self.editor.setOpaque( False )
                        vport = self.view.getViewport()
                        vport.setOpaque( False )
                        self.view.setOpaque( False )
                        self.ebm = ebm
                        #print self.epm
                        ebm.addControllerToMenu( self.menu )
                    else: self.background = None
        finally:
            if not hasattr( self, 'background' ): 
                self.background = None
    else:
        self.background = None
</t>
<t tx="ekr.20070127142841.80">def setBackgroundImage( self, notification = None, handback = None ):
    
    c = self.c
    alpha = g.app.config.getFloat( c, "background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            if not hasattr( self, 'background' ): 
                self.background = EditorBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
                self.epane.add( self.background )
                
            #    self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #    self._vport.addChangeListener( self._resizer )
            self.editor.setOpaque( False )
            vport = self.view.getViewport()
            vport.setOpaque( False )
            self.view.setOpaque( False )
            #self.epane.setBackedWidget( self.view.getViewport() )
            #self.epane.setImage( bimage )
            #self.epane.setAlpha( alpha )
            self.editorlomanager.media = self.background
            g.app.config.manager.addNotificationDef( "background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "image_location@as-filedialog", self.setBackgroundImage )
                  
            #else:
            #    #self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    #self.background.repaint()


</t>
<t tx="ekr.20070127142841.81">def useAutocompleter( self, notification = None, handback = None ):

    use = g.app.config.getBool( self.c, "use_autocompleter" )
    if use:  
        self.autocompleter.on = 1
    else:
        self.autocompleter.on = 0
        self.autocompleter.hideAutoBox()</t>
<t tx="ekr.20070127142841.82">def setCaret( self, notification = None, handback = None ):
    c = self.c
    if g.app.config.getString( c, "which_caret" ):
        caret = g.app.config.getString( c, "which_caret" )
        carets= { 'Box': (self.SeeThroughBoxCaret, 'box_color' ),
                  'Underliner': ( self.UnderlinerCaret, 'underliner_color' ),
                  'GhostlyLeo': ( self.GhostlyLeoCaret , None ),
                  'ImageCaret': ( self.ImageCaret, None ),
                  '&lt;none&gt;': (stext.DefaultCaret, None ) }

        if caret == 'ImageCaret':
            try:
                path_to_image = g.app.config.getString( c, "path_to_caret_image@as-filedialog" )
                ifile = java.io.File( path_to_image )
                cimage = imageio.ImageIO.read( ifile )
                #cicon = swing.ImageIcon( path_to_image )
                self.editor.setCaret( carets[ caret ]( cimage ) )
            except java.lang.Exception, x:
                x.printStackTrace()
                g.es( "Could not load image for caret" )
        else:
            caret, color = carets[ caret ]
            args = None
            if color:
                color = g.app.config.getColor( c, color )
                color = getColorInstance( color )
                args = ( color )
                self.editor.setCaret( caret( color ) ) 
            else:
                self.editor.setCaret( caret() )    
    self.editor.getCaret().addChangeListener( self.brackethighlighter )
</t>
<t tx="ekr.20070127142841.83">def setFont( self, notification = None, handback = None ):
    
    config = g.app.config
    c = self.c  
    family = config.get( c, "body_text_font_family", "family" )
    size = config.get( c, "body_text_font_size", "size" )
    weight = config.get( c, "body_text_font_weight", "weight" )
    slant = None
    font = config.getFontFromParams( c, "body_text_font_family", "body_text_font_size", None, "body_text_font_weight")
    if font:
        self.editor.setFont( font )</t>
<t tx="ekr.20070127142841.84">def setEditorColors( self, notification = None, handback = None ):
    
    c = self.c

    fg = g.app.config.getColor( c, 'body_text_foreground_color' )
    bg = g.app.config.getColor( c, 'body_text_background_color' )
    sc = g.app.config.getColor( c, 'body_selection_color' )
    stc = g.app.config.getColor( c, 'body_text_selected_color' )
    
    fg = getColorInstance( fg, awt.Color.GRAY )
    bg = getColorInstance( bg, awt.Color.WHITE )
    sc = getColorInstance( sc, awt.Color.GREEN )
    stc = getColorInstance( stc, awt.Color.WHITE )

    self.editor.setForeground( fg )
    self.editor.setBackground( bg )
    self.editor.setSelectionColor( sc )
    self.editor.setSelectedTextColor( stc )


</t>
<t tx="ekr.20070127142841.85">def getLineNumberColors( self ):
    
    c = self.c

    bg = g.app.config.getColor( c, "line_number_background" )
    fg = g.app.config.getColor( c, "line_number_foreground" )
    cl = g.app.config.getColor( c, "line_number_current" )
    try:
        bg = getColorInstance( bg )
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance( fg )
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance( cl )
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW    
    return fg, bg, cl

def setLineNumberColors( self, notification = None, background = None ):  
    
    fg, bg, cl = self.getLineNumberColors()      
    if self.numbers:
        self.numbers.setBackground( bg )
        self.numbers.setForeground( fg )
        self.numbers.setCurrent( cl )
            
</t>
<t tx="ekr.20070127142841.86">@others</t>
<t tx="ekr.20070127142841.87">def sync( self, pos=None ):
      
    try:
        if pos == None:
            pos = self.c.currentPosition()

        if pos in self.recent:
            self.recent.remove( pos )
        else:
            if len( self.recent ) == 10:
                self.recent.pop()
        self.recent.insert( 0, pos )
                    
        if self.lastPosition:
            self.foldprotection.cacheFolds( self.lastPosition.v.t )
        self.lastPosition = pos.copy()
        hs = pos.headString()
        bs = pos.bodyString()
        #self.editor.setText( bs )
        doc = self.editor.getDocument()
        doc.setPosition( pos )
        #doc.sync( bs )
        body = self.c.frame.body
        try:
            body.ignore_insert = 1
            self.jlc.ignoreEvents()
            self.foldprotection.clearFolds()
            self.foldprotection.defoldViews()
            doc.remove( 0,  doc.getLength() )
            doc.insertString( 0, bs, None )
            self.frame.setTitle( hs )
            self.jlc.recolorizenow()
            self.foldprotection.restoreFolds( pos.v.t )
            if hasattr( self, '_node_undoer' ):
                self._node_undoer.setNode( pos )
        finally:
            self.jlc.watchEvents()
            body.ignore_insert = 0
    except Exception, x:
        pass
        #x.printStackTrace()
     
</t>
<t tx="ekr.20070127142841.88">def nowShowing( self ):
    
    self.body._current_editor = self.editor 
    self.sync()
    </t>
<t tx="ekr.20070127142841.89">@others</t>
<t tx="ekr.20070127142841.90">def configureGotoMenu( self, menu ):                    
    oltraveler = leoSwingBody.Editor.outlinetraveler( menu , self.c )
    menu.addMenuListener( oltraveler )</t>
<t tx="ekr.20070127142841.91">def directiveMenu( self, menu ):
        
    import leoColor
    directives = []
    for z in leoColor.leoKeywords:
        directives.append( z )
    directives.sort()
    InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
    for z in directives:
        menu.add( InsertTextIntoBody( self.c, z ) ) 
        
</t>
<t tx="ekr.20070127142841.92">def headlineMenu( self, menu ):
        
    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode( self.c, tnode )
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    names.sort()
    SetHeadline = leoSwingBody.Editor.SetHeadline
    self.addSR( menu )
    for z in names: 
        menu.add( SetHeadline( self.c, z ) )    
                
    rmvSymbol = leoSwingBody.Editor.rmvSymbol
    rS = rmvSymbol( self.c, '@' )
    menu.add( rS )
    SetHeadlineToSelection = leoSwingBody.Editor.SetHeadlineToSelection
    sTaction = SetHeadlineToSelection( self.c, "Set Headline to Selection" )
    menu.add( sTaction )
    
</t>
<t tx="ekr.20070127142841.93">def insertSR( self, menu ):
        
    inSRMenuListener = leoSwingBody.Editor.inSRMenuListener
    menu.addMenuListener( inSRMenuListener(  menu, self.c ) )</t>
<t tx="ekr.20070127142841.94">def addSR( self, menu ):
        
    class aa( swing.AbstractAction ):
            
        def __init__( self, c ):
            swing.AbstractAction.__init__( self, 'toggle &lt;%s%s&gt;' %( '&lt;','&gt;' ) )
            self.c = c
                
        def actionPerformed( self, event ):
            cp = self.c.currentPosition()
            hs = cp.headString()
            hs = hs.strip()
            if hs.startswith( '&lt;%s'%'&lt;' ) and hs.endswith( '&gt;%s' %'&gt;' ):
                hs = hs[ 2: ]
                hs = hs[ : -2 ]
            else:
                hs = '&lt;%s%s%s&gt;' %( '&lt;', hs,'&gt;' )
            
            self.c.beginUpdate()
            cp.setHeadString( hs )
            self.c.endUpdate()    
        
    menu.add( aa( self.c ) )      </t>
<t tx="ekr.20070127142841.95">def addLanguageMenu( self, pmenu ):
    pass
@
    lmenu = swing.JMenu( "language" )
    kI = self.keywordInserter( lmenu, self.c )
    lmenu.addMenuListener( kI )
    pmenu.add( lmenu )
    lS = self.languageSetter( kI )
    pmenu.addMenuListener( lS )

</t>
<t tx="ekr.20070127142841.96">def addInsertPath( self, menu ):
    
    def __insertHeadline( event ):
        
        jfc = swing.JFileChooser()
        jfc.setFileSelectionMode( jfc.DIRECTORIES_ONLY )
        jfc.setDialogTitle( "Select Directory for %s%s" % ( "@", "path" ) )
        jfc.setApproveButtonText( "Select" )
        result = jfc.showOpenDialog( self.c.frame.top )
        if result == jfc.APPROVE_OPTION:
            sfile = jfc.getSelectedFile()
            self.c.frame.body.insertAtInsertPoint( "%s %s" % ( "@path", sfile.getAbsolutePath() ) )
            
    
    menu.actionPerformed = __insertHeadline
    

</t>
<t tx="ekr.20070127142841.97">def addCompositeView( self, event ):
    
    if not hasattr( self, 'lcv' ):
        import leoCompositeView
        jpanel = swing.JPanel( awt.BorderLayout() )
        #self.jtab.addTab( "CompositeView", jpanel )
        #self.jtab.setSelectedComponent( jpanel )
        self.tab_manager.add( "CompositeView", jpanel )
        self.lcv = lcv = leoCompositeView.CompositeView( self.c , jpanel )
        self.visible_informer.addCallback( jpanel, lambda : lcv.sync( force = 1 ) )
        self.body._current_editor = self.lcv.jtp
    else:
        parent = self.lcv.parent
        #if self.jtab.indexOfComponent( parent ) == -1:
        if not self.tab_manager.holdsComponent( parent ):

            self.tab_manager.add( "CompositeView", parent )
            #self.jtab.addTab( "CompositeView", parent )
            #self.jtab.setSelectedComponent( parent )
        else:
            #self.jtab.remove( parent )
            self.tab_manager.remove( parent )
            </t>
<t tx="ekr.20070127142841.98">def addFlashCardView( self, event ):
    
    import leoFlashCardView
    if not hasattr( self, 'fcv' ):
        jpanel = swing.JPanel( awt.BorderLayout() )
        self.jtab.addTab( "FlashCardView", jpanel )
        self.jtab.setSelectedComponent( jpanel )
        self.fcv = fcv = leoFlashCardView.FlashCardView( self.c , jpanel )
        self.visible_informer.addCallback( jpanel, lambda : fcv.sync( force = 1 ) )
    else:
        parent = self.fcv.parent
        if self.jtab.indexOfComponent( parent ) == -1:
            self.jtab.addTab( "FlashCardView", parent )
            self.jtab.setSelectedComponent( parent )
        else:
            self.jtab.remove( parent )
</t>
<t tx="ekr.20070127142841.99">def addFootNodeMenu( self, menu ):
    
    menu.addSeparator()
    addfn = swing.JMenuItem( "Add FootNode" )
    menu.add( addfn )
    rmvfn = swing.JMenu( "Remove FootNode" )
    menu.add( rmvfn )
    fnoderemover = self.footnoderemover( rmvfn, self.c )
    rmvfn.addMenuListener( fnoderemover )
    
    def addFootNode( event, c ):
        
        pos = c.currentPosition()
        t = pos.v.t
        if not hasattr( t, "unknownAttributes" ):
            uas = t.unknownAttributes = {}
            fn = []
            uas[ "footnodes" ] = fn
        else:
            uas = t.unknownAttributes
            if uas.has_key( "footnodes" ):
                fn = uas[ "footnodes" ]
            else:
                fn = []
                uas[ "footnodes" ] = fn
                
        jd = swing.JDialog()
        jd.title = "Add a FootNode"
        cpane = jd.getContentPane()
        cpane.setLayout( awt.BorderLayout() )
        jtf = swing.JTextField()
        tborder1 = sborder.TitledBorder( "Title" )
        jtf.setBorder( tborder1 )
        cpane.add( jtf, awt.BorderLayout.NORTH )
        jta = swing.JTextArea()
        jsp = swing.JScrollPane( jta )
        tborder2 = sborder.TitledBorder( "FootNode" )
        jsp.setBorder( tborder2 )
        cpane.add( jsp )
        jp = swing.JPanel()
        b1 = swing.JButton( "Cancel" )
        b1.actionPerformed = lambda event, jd = jd: jd.dispose()
        jp.add( b1 )
        b2 = swing.JButton( "Ok" )
        def ok( event, fn, jtf, jta, jd , c = c):
            headline = jtf.getText()
            body = jta.getText()
            fn.append( ( headline, body ) )
            c.frame.body.editor.ekit.relayout()
            jd.dispose()
        b2.actionPerformed = lambda event, fn = fn, jtf = jtf, jta = jta, jd = jd, c = c: ok( event, fn, jtf, jta, jd,c  )    
        jp.add( b2 )
        cpane.add( jp, awt.BorderLayout.SOUTH )
        jd.size = ( 250, 250 )
        jd.preferredSize = ( 250, 250 )
        #jd.pack()
        g.app.gui.center_dialog( jd )
        jd.show()
    addfn.actionPerformed = lambda event, c = self.c: addFootNode( event, c )

        
        
        
        
        
</t>
<t tx="ekr.20070127142841.100">def focusGained( self, fe ):
        
    lasteditor = self.body.editor
    self.body.editor = self
    if self.lastPosition:
        if lasteditor != self:
            if self.chapter.isValid():
                cc = self.c.chapters.getChapter()
                if self.chapter != cc:
                    self.c.chapters.selectChapter( self.chapter )
                
                try:    
                    self.c.beginUpdate() #This part if not done right can cause weird tree sync issues
                    lp = self.lastPosition
                    self.lastPosition = None
                    self.c.frame.tree.select( lp )
                finally:
                    self.c.endUpdate()
            else:
                self.sync()

    if hasattr( self, '_node_undoer' ):
        self._node_undoer.setMenu()
        
def focusLost( self, fe ):
    
    self.chapter = self.c.chapters.getChapter()
    if hasattr( self, '_node_undoer' ):
        if self.lastPosition:
            self._node_undoer.checkSumNode( self.lastPosition.v.t )
</t>
<t tx="ekr.20070127142841.101">def detach( self, event = None ):
    
    self._parent2 = jf = swing.JFrame()
    bounds = self.frame.getBounds()
    self._parent.remove( self.frame )
    jf.getContentPane().add( self.frame )
    jf.setBounds( bounds )
    km = self.editor.getKeymap()
    k_and_a = self.c.frame.menu.keystrokes_and_actions
    for z in k_and_a.keys():
        action = k_and_a[ z ]
        km.addActionForKeyStroke( z, action )
    self._attached = False
    jf.visible = 1
    self._parent.validate()
    self._parent.repaint()


def retach( self, event = None ):
    
    parent = self._parent2
    self._parent2 = None
    parent.remove( self.frame )
    self._parent.add( self.frame )
    parent.dispose()
    parent.visible = 0
    self._attached = True
    self._parent.validate()
    self._parent.repaint()
    self.frame.validate()
    self.frame.repaint()
    
    

</t>
<t tx="ekr.20070127142841.102">def turnSelectionIntoNode( self ):
    
    editor = self.editor
    txt = editor.getSelectedText()
    if txt == None: return
    spot = txt.find( '\n' )
    headline = txt[ :spot]
    editor.replaceSelection( "" )
    c = self.c
    c.beginUpdate()
    cp = c.currentPosition()
    np = cp.insertAsLastChild()
    np.setHeadString( headline )
    np.setBodyStringOrPane( txt )
    c.endUpdate()</t>
<t tx="ekr.20070127142841.103">def insertTextIntoBody( self, txt ):
    
    cpos = self.editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart( self.editor, cpos )
    doc = self.editor.getStyledDocument()
    txt2 = doc.getText( start, cpos - start )
    start_text = []
    for z in txt2:
        if z.isspace():
            start_text.append( z )
        else:
            start_text.append( ' ' )
    
    indent = ''.join( start_text )
    
    lines = txt.split( '\n' )
    if len( lines ) &gt; 1:
        for z in xrange( len( lines ) - 1 ):
            line = lines[ z + 1 ]
            nwline = "%s%s" %( indent, line )
            lines[ z + 1 ] = nwline
    itext = '\n'.join( lines )
    doc.insertString( cpos, itext, None )
    
    
            
               

</t>
<t tx="ekr.20070127142841.104">def splitNode( self ):
    
    c = self.c
    editor = self.editor
    cpos = editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart( editor, cpos )
    doc = editor.getDocument()
    nn_txt = doc.getText( start, doc.getLength() - start ) 
    doc.remove( start, doc.getLength() - start )
    c.beginUpdate()
    cp = c.currentPosition()
    nn = cp.insertAfter()
    nn.setBodyStringOrPane( nn_txt )
    c.selectPosition( nn )
    c.endUpdate()
    
    dc = DefCallable( lambda : c.frame.tree.editLabel( nn ) )
    ft = java.util.concurrent.FutureTask( dc )
    java.awt.EventQueue.invokeLater( ft )
</t>
<t tx="ekr.20070127142841.105">def sectionReferenceToWidget( self ):
    
    c = self.c 
    cp = c.currentPosition()
    bs = cp.bodyString()
    pattern = java.util.regex.Pattern.compile( "&lt;"+"&lt;" +"[^&lt;&gt;]*&gt;"+"&gt;" )
    
    children = {}
    for z in cp.children_iter( copy = True ):
        children[ z.headString() ] = z
    
    
    matcher = pattern.matcher( java.lang.String( bs ) )
    results =[]
    while matcher.find():
        result = matcher.toMatchResult()
        results.append( result )
    
    doc = self.editor.getDocument()
    for z in results:
        begin = z.start()
        end = z.end()
        sr = bs[ begin: end ]
@
        if sr in children:
            jtp = swing.JTextArea()
            child = children[ sr ]
            jtp.setText( child.bodyString() )
            jb = swing.JButton( "Mooo" )
            mas = swing.text.SimpleAttributeSet()
            swing.text.StyleConstants.setComponent( mas, jb )
            swing.text.StyleConstants.setForeground( mas, java.awt.Color.RED )
            doc.setCharacterAttributes( begin, end - begin, mas, 1 )
            doc.insertString( 0, "\n", mas )
@c
            
    
    
    
</t>
<t tx="ekr.20070127142841.106">def chapterChanged( self, tag, *args, **kwords ):
    
    try:
        chapter = args[ 0 ][ 'chapter' ]
        if tag == "chapter-changed":
            if self.c.frame.body.editor is self:
                cp = chapter.getCurrentPosition(); rp = chapter.getRootPosition()
                if cp or rp:
                    self.sync()
        elif tag == "chapter-removed":
            if self.c.frame.body.editor is self:
                self.sync()
    except java.lang.Exception, x:
        pass
</t>
<t tx="ekr.20070127142841.107">def headlineChanged( self, tag, *args, **kwords ):

    p = args[ 0 ][ 'p' ]
    if self.lastPosition == p:
        self.frame.setTitle( p.headString() )

</t>
<t tx="ekr.20070127142841.108">@others
</t>
<t tx="ekr.20070127142841.109">def splitVertically( self, event ):
    
    widget = self.editor
    parent = widget.getParent()
    
</t>
<t tx="ekr.20070127142841.110">def createEditor( self ):
    
    editor = self.leoJTextPane( self.c )
    editor.setLineColor()
    manager = g.app.config.manager
    manager.addNotificationDef( "highlight_current_line", editor.setLineColor )
    manager.addNotificationDef( "current_line_highlight_color", editor.setLineColor )
    cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider( self.c )

    use_line_numbers = g.app.config.getBool( c, "use_line_numbering" )
    if use_line_numbers:
        #self.initializeLineNumbering()
        fg, bg, cl = self.getLineNumberColors()
        numbers = leoEditorKit.LeoNumberLabel( bg, fg, cl )
        #manager = g.app.config.manager
        #manager.addNotificationDef( "line_number_background", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_foreground", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_current", self.setLineNumberColors )
    else:
        numbers = None
    
    ekit = leoEditorKit( cdeterminer, numbers )
    editor.setEditorKit( ekit )
    cdeterminer.setEditor( editor )
    editor.getDocument().addUndoableEditListener( self.body ) 
    editor.addMouseListener( leoSwingBody.UtilityRightClick( c , detach_retach = True, editor = self ) ) 
       
    return editor</t>
<t tx="ekr.20070127142841.111">@
In general these are subclasses of java gui listeners.

In CPython and Tk you would be using callbacks most of the time, a def or a lambda.
@c



@others</t>
<t tx="ekr.20070127142841.112">@
class resizer( aevent.ComponentAdapter, sevent.ChangeListener ):
    '''This class keeps the Editor size in sync with the JLayeredPane.
       It also sets where the line numbers go and where, if present,
       a background image goes.'''
    def __init__( self, editor, side = 'Left' ):
        self.editor = editor
        self.viewPort = self.editor.view.getViewport()
        self.vsbar = self.editor.view.getVerticalScrollBar()
        self.side = side
    def componentResized( self, event ):
        source = event.getSource()
        size = source.getSize()
        editor = self.editor.editor
        esize = editor.getSize()
        editor = self.editor.editor
        visRect = self.viewPort.getViewRect() #was once getVisibleRect, bad choice...
        if self.editor.numbers:
            numbers = self.editor.numbers
            lnsize = numbers.getSize()
            if lnsize.width == 0: lnsize.width = 30
            nswidth = size.width - lnsize.width
            nvwidth = visRect.width - lnsize.width
            if esize.height != size.height or esize.width not in( nvwidth, nswidth ):
                if visRect.width &gt; 0:
                    size.width = nvwidth
                else:
                    size.width = nswidth
                editor.setSize( size )
                if self.side == 'Left':
                    editor.setLocation( lnsize.width, 0 )
                else:
                    editor.setLocation( 0, 0 )
                    numbers.setLocation( size.width, 0 )
            numsize = numbers.getSize()
            nlocation = numbers.getLocation()
            esize = editor.getSize()
            edheight = esize.height
            edwidth = esize.width
            lnsize.height = edheight
            if numsize.height &lt; lnsize.height:
                numbers.setSize( lnsize )
                if self.side == 'Left':
                    numbers.setLocation( 0, 0 )
                else:
                    numbers.setLocation( edwidth, 0 )
        else:
            self.editor.editor.setSize( size )
            self.editor.editor.setLocation( 0, 0 )
        if self.editor.background:
            self.stateChanged( None )


    def stateChanged( self, event ):
        editor = self.editor.editor
        background = self.editor.background
        #visRect = editor.getVisibleRect()
        visRect = self.viewPort.getViewRect()
        x = editor.getX()
        minus = x
        if x == 0 and self.editor.numbers != None:
            minus = self.editor.numbers.getSize().width
        background.setSize( visRect.width - minus, visRect.height )
        background.setLocation( x , visRect.y )
        self.editor.layeredpane.moveToBack( background )</t>
<t tx="ekr.20070127142841.113">class resizer2( aevent.ComponentAdapter ):
    
    def __init__( self, layoutmanager ):
        aevent.ComponentAdapter.__init__( self )
        self.layoutmanager = layoutmanager
        
    def componentResized( self, event ):        
        self.layoutmanager.layoutMedia()</t>
<t tx="ekr.20070127142841.114">class goNode( swing.AbstractAction ):
    def __init__( self, pos, c ):
        swing.AbstractAction.__init__( self, pos.headString() )
        self.pos = pos.copy()
        self.c = c
                
    def actionPerformed( self, event ):
                
        self.c.frame.tree.select( self.pos )</t>
<t tx="ekr.20070127142841.115">class outlinetraveler( sevent.MenuListener ):
            
    def __init__( self, menu, c ):
        self.menu = menu
        self.c = c   
                
    def menuCanceled( self, event ):
        pass
                
    def menuDeselected( self, event ):
        pass
                
    def menuSelected( self, event ):
                 
        count = self.menu.getMenuComponentCount()
        for z in xrange( 1 , count ):
            self.menu.remove( 1 )
                
        cp = self.c.currentPosition()
        self._addMenu( "Parents", self.menu, cp.parents_iter(), cp )
        self._addMenu( "Siblings", self.menu, cp.siblings_iter(), cp )
        self._addMenu( "Children", self.menu, cp.children_iter(), cp )
            
    def _addMenu( self, name, menu, iterator, cp ):
                
        goNode = leoSwingBody.Editor.goNode
        gmenu = swing.JMenu( name )
        shouldAdd = True
        for z in iterator:
            if shouldAdd:
                if not cp == z:
                    shouldAdd = False
                    menu.add( gmenu )
            if not cp == z:
                gmenu.add( goNode( z, self.c ) )
            else:
                gmenu.addSeparator()
                        
</t>
<t tx="ekr.20070127142841.116">class footnoderemover( sevent.MenuListener ):
            
    def __init__( self, menu, c ):
            self.menu = menu
            self.c = c   
                
    def menuCanceled( self, event ):
        pass
                
    def menuDeselected( self, event ):
        pass
                
    def menuSelected( self, event ):
                 
        self.menu.removeAll()
        #count = self.menu.getMenuComponentCount()
        #for z in xrange( 1 , count ):
        #    self.menu.remove( 1 )
                
        pos = self.c.currentPosition()
        t = pos.v.t
        if hasattr( t, "unknownAttributes" ):
            uas = t.unknownAttributes
            if uas.has_key( "footnodes" ):
                footnodes = uas[ "footnodes" ]
                def rmv( item, footnodes = footnodes, c = self.c ):
                    footnodes.remove( item )
                    c.frame.body.editor.ekit.relayout()
                    
                for x in xrange( len( footnodes ) ):
                    fnood = footnodes[ x ]
                    jmi = swing.JMenuItem( fnood[ 0 ] )
                    jmi.actionPerformed = lambda event, item = fnood: rmv( item )
                    self.menu.add( jmi )       
                            
</t>
<t tx="ekr.20070127142841.117">@
class keywordInserter( sevent.MenuListener ):
    def __init__( self, menu, c ):
        self.menu = menu
        self.c = c
        self.lastlanguage = None
    def setLanguageName( self ):
        cp = self.c.currentPosition()
        self.language = language = g.scanForAtLanguage( self.c, cp )
        self.menu.setText( language )
    def menuCanceled( self, event ):
        pass
    def menuDeselected( self, event ):
        pass
    def menuSelected( self, event ):
        #cp = self.c.currentPosition()
        #language = g.scanForAtLanguage( self.c, cp )
        language = self.language
        if language == self.lastlanguage: return
        self.lastlanguage = language
        print dir( leoLanguageManager.LanguageManager )
        if language == None:
            m = leoLanguageManager.LanguageManager.python_tokens
        else:
            m = getattr( leoLanguageManager.LanguageManager, "%s_tokens" % language )

        m.sort()
        self.menu.removeAll()
        for z in m:
            self._addInserter( z )
    def _addInserter( self, name  ):
        self.menu.add( leoSwingBody.Editor.InsertTextIntoBody( self.c, name ) )

class languageSetter( sevent.MenuListener ):
    def __init__( self, kWI ):
        self._kWI = kWI
    def menuCanceled( self, event ):
        pass
    def menuDeselected( self, event ):
        pass
    def menuSelected( self, event ):
        self._kWI.setLanguageName()
</t>
<t tx="ekr.20070127142841.118">class smacs_help( swing.AbstractAction ):
         
    class clz( swing.AbstractAction ):
        def __init__( self, tl ):
            swing.AbstractAction.__init__( self, "Close" )
            self.tl = tl
            
            
        def actionPerformed( self, event ):
            self.tl.visible = 0
            self.tl.dispose()         
   
    def __init__( self, c, emacs, which ):
        
        if which == 'Keystrokes':
            swing.AbstractAction.__init__( self, "Emacs Keystrokes" )
        else:
            swing.AbstractAction.__init__( self, "Emacs Commands" )
           
        self.emacs = weakref.proxy( emacs )
        self.which = which
        fg = g.app.config.getColor( c, 'body_text_foreground_color' )
        bg = g.app.config.getColor( c, 'body_text_background_color' )
        sc = g.app.config.getColor( c, 'body_selection_color' )
        stc = g.app.config.getColor( c, 'body_text_selected_color' )
    
        self.fg = getColorInstance( fg, awt.Color.GRAY )
        self.bg = getColorInstance( bg, awt.Color.WHITE )
        self.sc = getColorInstance( sc, awt.Color.GREEN )
        self.stc = getColorInstance( stc, awt.Color.WHITE )
                
    def actionPerformed( self, event ):
        
        tl = swing.JFrame( title = self.which )
        ta = swing.JTextArea()
        ta.setForeground( self.fg )
        ta.setBackground( self.bg )
        ta.setSelectionColor( self.sc )
        ta.setSelectedTextColor( self.stc )
        ta.setEditable( False )
        ta.setLineWrap( True )
        sp = swing.JScrollPane( ta )
        tl.getContentPane().add( sp )
        if self.which == 'Keystrokes':
            ta.setText( self.emacs.getHelp() )
        else:
            
            ta.setText( self.emacs.ax.getCommandHelp() )
        gui = g.app.gui
        
        
        cbutt = swing.JButton( self.clz( tl ) )
        tl.getContentPane().add( cbutt, awt.BorderLayout.SOUTH )
        tkit = awt.Toolkit.getDefaultToolkit()
        size = tkit.getScreenSize()
        tl.setSize( size.width/2, size.height/2 )
        tl.setPreferredSize( tl.getSize() )
        x, y = g.app.gui._calculateCenteredPosition( tl )
        tl.setLocation( x, y )
        ta.setCaretPosition( 0 )
        tl.visible = 1
    

        </t>
<t tx="ekr.20070127142841.119">class autocompleter_help( swing.AbstractAction ):
            
    def __init__( self ):
        swing.AbstractAction.__init__( self, "How to use the Autocompleter" )
        
    def getText( self ):
        
        htext = '''
        The Autcompleter appears upon typing of the '.' character.  Upon
        typing this character an in memory database is searched for the matching prefix.
        For example:
            object.toString  appears in a node.
            Typing 'object.' will bring the autocompleter box up with 'toString' as an option.
                       
            Keystrokes that manipulate the autobox:
            Ctrl - this inserts the currently selected word
            Alt-Up, Alt-Down - these move the selection up and down.
            Esc - desummons the autobox
                   
        The autobox will select the best prefix you have typed so far.  To extend the last example:
        typing 'to' will select 'toString'.  It will not enter the text until the user types 'Ctrl'
        or selects an item with the mouse.'''
                   
        return htext
                
    def actionPerformed( self, event ):
        tl = swing.JFrame( title = 'Autocompleter Help' )
        ta = swing.JTextArea()
        ta.setEditable( False )
        sp = swing.JScrollPane( ta )
        tl.getContentPane().add( sp )
        #ta.setText( self.emacs.getHelp() )
        ta.setText( self.getText() )
        gui = g.app.gui
        tl.setSize( 600, 400 )
        spot = gui._calculateCenteredPosition( tl )
        tl.setLocation( spot[ 0 ], spot[ 1 ] )
        class clz( swing.AbstractAction ):
            def __init__( self ):
                swing.AbstractAction.__init__( self, "Close" )
            def actionPerformed( self, event ):
                tl.visible = 0
                tl.dispose()
        cbutt = swing.JButton( clz() )
        tl.getContentPane().add( cbutt, awt.BorderLayout.SOUTH )
        tl.visible = 1</t>
<t tx="ekr.20070127142841.120">class FoldProtector( stext.DocumentFilter ):
    
    cachedfolds = {}
    
    def __init__( self , editor, ekit):
        stext.DocumentFilter.__init__( self )
        self.folds = []
        self.ekit = ekit
        self.editor = editor
        self.doc = editor.getDocument()
        self.editor.addMouseListener( self.Defolder( self )) 
        
    def cacheFolds( self, t ):
        if self.folds:
            for z in self.folds:
                z.persist( self.doc )
            self.cachedfolds[ t ] = self.folds
    
    def defoldViews( self ):
        self.ekit.defoldViews()    
        
    def restoreFolds( self, t ):
        if self.cachedfolds.has_key( t ):
            self.folds = self.cachedfolds[ t ]
            doc = self.editor.getDocument()
            for x in xrange( len(self.folds )):
                z = self.folds[ x ]
                if z.restore( doc ):
                    self.foldWithoutAdding( z.pos1, z.pos2 )
                else:
                    self.folds.remove( z )
                    g.es( "Removing Fold(%s,%s), no longer valid" %( z.pos1, z.pos2 ), color = "red" )
        else:
            self.folds = []
        
    def foldSelection( self ):
        
        start = self.editor.getSelectionStart()
        end = self.editor.getSelectionEnd()
        if start == end: return
        if start &gt; end:
            s1 = start
            start = end
            end = s1
        cp = self.editor.getCaretPosition()
        self.editor.setCaretPosition( cp )
        self.editor.moveCaretPosition( cp )
        paragraph1 = stext.Utilities.getParagraphElement( self.editor, start )
        paragraph2 = stext.Utilities.getParagraphElement( self.editor, end )
        self.fold( paragraph1.getStartOffset(), paragraph2.getEndOffset() -1  )
    
        
    def fold( self, start, end ):    
    
        fold = self.addFold( start, end, self.editor )
        self.ekit.fold( fold.pos1, fold.pos2 )
        start = fold.pos1.getOffset(); end = fold.pos2.getOffset()
        for z in copy.copy( self.folds ):
            if z == fold: continue
            test1 = z.pos1.getOffset()
            test2 = z.pos2.getOffset()
            if start &lt;= test1 and end &gt; test1:
                self.folds.remove( z ) #the folds are now the same
            
        
    def foldWithoutAdding( self, pos1, pos2 ):
        self.ekit.fold( pos1, pos2 )
    
    def areLinesInFold( self, start, end ):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 &lt;= start and end2 &gt;= end: return True
        return False
        
    def doLinesIntersectFold( self, start, end ):
        
        doc = self.doc
        s = doc.getParagraphElement( start )
        e = doc.getParagraphElement( end )
        for z in self.folds:
            p1 = doc.getParagraphElement( z.pos1.getOffset() )
            p2 = doc.getParagraphElement( z.pos2.getOffset() )
            while p1 != p2:
                if p1 == e or p1 == s: return True
                p1 = doc.getParagraphElement( p1.getEndOffset()) 
            else:
                if p1 == e or p1 == s: return True
        return False
        
    def areLinesSurroundingFold( self, start, end ):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start &lt;= start2 and end &gt;= end2: return True
        return False
    
    def getFold( self, start, end ):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 &lt;= start and end2 &gt;= end: return z
        return None
       
    def isFolded( self, x, y ):
        return self.ekit.isFolded( x, y )
        
    def isXInIconArea( self, x ):
        
        i = self.ekit.getFoldIconX()
        if i &gt;= x: return True
        return False
    
    def removeFold( self, fold ):
        self.unfold( fold.pos1, fold.pos2 )
        self.folds.remove( fold )
    
    def unfold( self, pos1, pos2 ):
        self.ekit.unfold( pos1, pos2 )
        
    def unfoldSpot( self, x, y ):
        
        i = self.editor.viewToModel( awt.Point( x, y ) )
        for x in xrange( len( self.folds ) ):
            z = self.folds[ x ]
            if i &gt;= z.pos1.getOffset() and i &lt;= z.pos2.getOffset():
                self.unfold( z.pos1, z.pos2 )
                self.folds.remove( z )
                break
    
    def addFold( self, start, end, editor ):
        
        doc = editor.getDocument()
        pos1 = doc.createPosition( start )
        pos2 = doc.createPosition( end )
        fold = self.Fold( pos1, pos2 )
        self.folds.append( fold )
        return fold
        
    def clearFolds( self ):
        self.folds = []            
            
        
    @others
        
                
            
        
        
            </t>
<t tx="ekr.20070127142841.121">def insertString( self, fb, offset, data, attr):
        
    if self.folds:
        for x in xrange( len( self.folds ) ):
            z = self.folds[ x ]
            if not z.isInsertLegal( offset, fb.getDocument() ):
                return
                       
    fb.insertString( offset, data, attr )
        
def remove( self, fb, offset, length):
        
    if self.folds:
        for z in self.folds:
            if not z.isRemoveLegal( offset, length , fb.getDocument() ):
                return        
    fb.remove( offset, length )
        
def replace( self, fb, offset, length, text, attrs):
        
    if self.folds:
        for x in xrange( len( self.folds ) ):
            z = self.folds[ x ]
            if not z.isRemoveLegal( offset, length, fb.getDocument() ):
                return
    fb.replace( offset, length, text, attrs )</t>
<t tx="ekr.20070127142841.122">def moveSelectionUp( self ):
    
    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd() 
    if( self.areLinesSurroundingFold( start, end ) or self.doLinesIntersectFold( start, end ) ): return
    if start &gt; end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement( start )
    p2 = doc.getParagraphElement( end )
    above = doc.getParagraphElement( p1.getStartOffset() -1 )
    &lt;&lt;move partial selection&gt;&gt;
        
    if( self.areLinesInFold( above.getStartOffset(), above.getEndOffset() -1 ) ):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold( above.getStartOffset(), above.getEndOffset() -1 )
        self.removeFold( fold )
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText( start, end - start )
        txt2 = doc.getText( fstart, fend - fstart )
        if txt2.endswith( "\n" ): txt2 = txt2[ : -1 ]
        doc.remove( fstart, end - fstart )
        nwtxt = "%s\n%s" %( txt, txt2 )
        doc.insertString( fstart, nwtxt, None )
        self.fold( fstart + len( txt ) +1 , end )
        para = doc.getParagraphElement( fstart )
        para2 = doc.getParagraphElement( fstart + len( txt ) )
        if cpstart:
            self.editor.setCaretPosition( para2.getEndOffset() -1 )
            self.editor.moveCaretPosition( para.getStartOffset() )       
        else:
            self.editor.setCaretPosition( para.getStartOffset() )
            self.editor.moveCaretPosition( para2.getEndOffset() -1 ) 
        
    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText( start, end  - start )
        sstart = above.getStartOffset()
        txt2 = doc.getText( sstart, above.getEndOffset() - sstart )
        if txt2.endswith( "\n" ): txt2 = txt2[ : - 1 ]
        doc.remove( sstart, end - sstart)
        txt3 = "%s\n%s" % ( txt, txt2 )
        doc.insertString( sstart, txt3, None )
        para = doc.getParagraphElement( sstart )
        para2 = doc.getParagraphElement( sstart + len( txt ) )
        if cpstart:
            self.editor.setCaretPosition( para2.getEndOffset() -1 )
            self.editor.moveCaretPosition( para.getStartOffset() )       
        else:
            self.editor.setCaretPosition( para.getStartOffset() )
            self.editor.moveCaretPosition( para2.getEndOffset() -1 ) 


</t>
<t tx="ekr.20070127142841.123">if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText( start, end - start )
    if not txt.endswith( "\n" ): txt = txt + "\n"
    self.editor.replaceSelection( "" )
    pstart = p1.getStartOffset()
    doc.insertString( p1.getStartOffset() , txt, None )
    para = doc.getParagraphElement( pstart )
    para2 = doc.getParagraphElement( pstart + len( txt ) -1 )
    if cpstart:
        self.editor.setCaretPosition( para2.getEndOffset() -1 )
        self.editor.moveCaretPosition( para.getStartOffset() )       
    else:
        self.editor.setCaretPosition( para.getStartOffset() )
        self.editor.moveCaretPosition( para2.getEndOffset() -1 )      
    return</t>
<t tx="ekr.20070127142841.124">def moveSelectionDown( self ):

    start = self.editor.getSelectionStart() 
    end = self.editor.getSelectionEnd()
    if( self.areLinesSurroundingFold( start, end ) or self.doLinesIntersectFold( start, end ) ): return
    if start &gt; end:
        s1 = start
        start = end
        end = start 
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement( start )
    p2 = doc.getParagraphElement( end )
    below = doc.getParagraphElement( p2.getEndOffset() )
    &lt;&lt;move partial selection&gt;&gt;
    if( self.areLinesInFold( below.getStartOffset(), below.getEndOffset() ) ):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold( below.getStartOffset(), below.getEndOffset() )
        self.removeFold( fold )
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText( start, end - start )
        txt2 = doc.getText( fstart, fend - fstart )
        if txt2.endswith( "\n" ): txt2 = txt2[ : -1 ]
        doc.remove( start, (fold.pos2.getOffset() - start ) )
        nwtxt = "%s\n%s" %( txt2, txt )
        doc.insertString( start, nwtxt, None )
        self.fold( start , start + len( txt2 ) )
        para = doc.getParagraphElement( start + len( txt2 ) + 1 )
        para2 = doc.getParagraphElement( start + len( txt2 ) + 1 + len( txt ) )
        if cpstart:
            self.editor.setCaretPosition( para2.getEndOffset() - 1 )
            self.editor.moveCaretPosition( para.getStartOffset() )       
        else:
            self.editor.setCaretPosition( para.getStartOffset() )
            self.editor.moveCaretPosition( para2.getEndOffset() -1 )            
    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText( start, end  - start )
        sstart = below.getStartOffset()
        txt2 = doc.getText( sstart, below.getEndOffset() - sstart )
        if txt2.endswith( "\n" ): txt2 = txt2[ : -1 ]
        doc.remove( start, ( below.getEndOffset() - start )-1)
        txt3 = "%s\n%s" % ( txt2, txt )
        doc.insertString( start, txt3, None )
        para = doc.getParagraphElement( start + len( txt2 ) + 1 )
        para2 = doc.getParagraphElement( start + len( txt2 ) + 1 + len( txt ) )
        if cpstart:
            self.editor.setCaretPosition( para2.getEndOffset() -1 )
            self.editor.moveCaretPosition( para.getStartOffset() )       
        else:
            self.editor.setCaretPosition( para.getStartOffset() )
            self.editor.moveCaretPosition( para2.getEndOffset() -1 )</t>
<t tx="ekr.20070127142841.125">if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText( start, end - start )
    if not txt.endswith( "\n" ): txt = txt + "\n"
    self.editor.replaceSelection( "" )
    pend = p2.getEndOffset()
    doc.insertString( p2.getEndOffset() , txt, None )
    para = doc.getParagraphElement( pend + 1 )
    para2 = doc.getParagraphElement( pend + len( txt ) -1 )
    if cpstart:
        self.editor.setCaretPosition( para2.getEndOffset() -1 )
        self.editor.moveCaretPosition( para.getStartOffset() )       
    else:
        self.editor.setCaretPosition( para.getStartOffset() )
        self.editor.moveCaretPosition( para2.getEndOffset() -1 )
        
    return</t>
<t tx="ekr.20070127142841.126">class Fold:
    def __init__( self, pos1, pos2 ):
        self.pos1 = pos1
        self.pos2 = pos2
        self.text = None
            
    def persist( self, doc ):
        self.pos1 = self.pos1.getOffset()
        self.pos2 = self.pos2.getOffset()
        self.text = doc.getText( self.pos1, self.pos2 - self.pos1 )
            
    def restore( self, doc ):
        p1,p2 = self.pos1, self.pos2
        if doc.getLength() &lt; p2:
            return False
        self.pos1 = doc.createPosition( self.pos1 )
        self.pos2 = doc.createPosition( self.pos2 )
        pelement1 = doc.getParagraphElement( p1 )
        pelement2 = doc.getParagraphElement( p2 )
        if pelement1.getStartOffset() != p1 or pelement2.getEndOffset() -1 != p2:
            return False
        testtext = doc.getText( p1, p2 - p1 )
        text = self.text; self.text = None
        return text == testtext
            
    def isInsertLegal( self, offset, doc ):
        
        e = doc.getParagraphElement( offset )
        p1 = doc.getParagraphElement( self.pos1.getOffset() )
        p2 = doc.getParagraphElement( self.pos2.getOffset() )
        if p1 == e or p2 == e: return False
        while p1 != p2:
            if p1 == e: return False
            p1 = doc.getParagraphElement( p1.getEndOffset()) 
        else:
            if p1 == e: return False
        return True
            
    def isRemoveLegal( self, offset, length, doc ):
        
        p1 = doc.getParagraphElement( self.pos1.getOffset() )
        p2 = doc.getParagraphElement( self.pos2.getOffset() )       
        start = doc.getParagraphElement( offset )
        end = doc.getParagraphElement( offset + length )
        if start == p1 or start == p2: return False
        if end == p1 or end == p2: return False
        while start != end:
            if start == p1 or start == p2: return False
            start = doc.getParagraphElement( start.getEndOffset() )
        else:
            if start == p1 or start == p2: return False
                    
        return True
</t>
<t tx="ekr.20070127142841.127">class Defolder( aevent.MouseAdapter ):
    def __init__( self, fp ):
        aevent.MouseAdapter.__init__( self )
        self.fp = fp
            
    def mouseClicked( self, event ):
            
        x = event.getX()
        y = event.getY()
        if event.getButton() == event.BUTTON1:
            if self.fp.isFolded( x, y ) and self.fp.isXInIconArea( x ):
                self.fp.unfoldSpot( x, y )</t>
<t tx="ekr.20070127142841.128">class CommanderCommander:
    
    def __init__( self, c , emacs, menu ):
        
        self.c = c
        self.emacs = weakref.proxy( emacs )
        f = c.frame 
        self.nodes = {}
        self.mode = 0
        self.tab_completer = None
        self.last_command = None
        self.name = "CommanderCommander"
        self.setupCommands( menu )
        self.addHelp()
        
    
    def getAltXCommands( self ):
        return self.commands.keys()
        
    def __call__( self, event ,command ):
        
        if self.mode == 1:
            if command == 'Enter':
                self.gotoNode2( event )
                self.last_command = None
                #self.emacs.keyboardQuit( event )
                return True
            elif command == 'Tab' and self.tab_completer:
            
                txt = self.emacs.minibuffer.getText()
                if self.last_command == None or not txt.startswith( self.last_command ):
                    txt = self.emacs.minibuffer.getText()
                    fnd = self.tab_completer.lookFor( txt )
                    if fnd:
                        self.last_command = txt
                        self.emacs.minibuffer.setText( self.tab_completer.getNext() )
                else :
                    self.emacs.minibuffer.setText( self.tab_completer.getNext() )
                return True
            else:
                self.emacs.eventToMinibuffer( event )
                return True
            
        quit = self.commands[ command ]()
        if quit == None:
            self.emacs.keyboardQuit( event )
        return True
        
    def getName( self ):
        return self.name
    
    @others
    
</t>
<t tx="ekr.20070127142841.129">def setupCommands( self, menu ):
    
    c = self.c
    f = c.frame
    self.commands = menu.names_and_commands
    self.commands[ "goto node" ] = self.gotoNode1
    


def addHelp( self ):
    
    addhelp =  [ 'Menu Commands:',
                 '-----------------',
    		         'You can execute any Menu command by entering its text',
                 'in the minibuffer.  For example:',
                 'Alt-x',
                 'Open Python Window',
                 '',
                 'will open a Python Window.  See Menus for complete list.',
                 '',
                 '',
                 'Additional Commands:',
                 '---------------------',
                 'These are Leo based commands.',
                 '',
                 'goto node --- will ask the user for which node to goto',
                 'and will take the user to it.' ] #we don't do triple strings because it doesn't format right because of Leo output
    addhelp = "\n".join( addhelp )
    self.emacs.addCommandHelp( addhelp )</t>
<t tx="ekr.20070127142841.130">def gotoNode1( self ):
        
    self.nodes = {}
    cp = self.c.currentPosition()
    for z in cp.allNodes_iter( copy = True ):
        hs = z.headString()
        if self.nodes.has_key( hs ):
            self.nodes[ hs ].append( z )
        else:
            self.nodes[ hs ] = [ z, ]
    self.tab_completer = self.emacs.TabCompleter( self.nodes.keys() )
           
    self.emacs.setCommandText( "Goto Which Node:" )
    self.emacs.minibuffer.setText( "" )
    self.emacs._stateManager.setState( self )
    self.mode = 1
    return True</t>
<t tx="ekr.20070127142841.131">def gotoNode2( self , event ):
        
    self.mode = 0
    self.tab_completer = None
    node = self.emacs.minibuffer.getText()
    self.emacs.keyboardQuit( event )
    if self.nodes.has_key( node ):
        c = self.c
        c.beginUpdate()
        nlist = self.nodes[ node ]
        if len( nlist ) &gt; 1:
            jf = swing.JDialog()
            jf.setLayout( awt.BorderLayout() )
            jf.setModal( True )
            jf.title = "Choose a Node"
            table = swing.JTable()
            table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
            table.setAutoResizeMode( table.AUTO_RESIZE_OFF )
            class kl( aevent.KeyAdapter ):
                def keyPressed( self, event ):
                    if event.getKeyCode() == event.VK_ENTER:
                        jf.dispose()
            
            table.addKeyListener( kl() )
            jsp = swing.JScrollPane( table )
            jf.add( jsp, awt.BorderLayout.CENTER )
            dtm = table.getModel()
            dtm.addColumn( "Node" )
            dtm.addColumn( "Level" )
            dtm.addColumn( "Parents" )
            longest_parents = "Parents"
            for z in nlist:
                row = []
                row.append( z.headString() )
                row.append( z.level() )
                ps = ""
                p = z.getParent()
                while p:
                    ps = "%s --&gt;%s" %( p.headString(), ps )
                    p = p.getParent()
                row.append( ps )
                if len( ps ) &gt; len( longest_parents) : longest_parents = ps
                dtm.addRow( row )
            
            table.setColumnSelectionAllowed( False )
            table.setRowSelectionInterval( 0, 0 )
            cm = table.getColumn( "Node" )
            fm = table.getFontMetrics( table.getFont() )
            w = fm.stringWidth( z.headString() )
            cm.setPreferredWidth( w )
            
            cm = table.getColumn( "Level" )
            w = fm.stringWidth( "Level" )
            cm.setPreferredWidth( w )
            
            cm = table.getColumn( "Parents" )
            w = fm.stringWidth( longest_parents )
            cm.setPreferredWidth( w )
            
            
            height = table.getRowHeight()
            size = jsp.getPreferredSize()
            size.height = height * 6
            jsp.setPreferredSize( size )    
            cb = swing.JButton( "Select" )
            cb.actionPerformed = lambda event: jf.dispose()
            p = swing.JPanel()
            p.add( cb )
            jf.add( p , awt.BorderLayout.SOUTH )
            jf.pack()
            g.app.gui.center_dialog( jf )
            jf.show()
            sr = table.getSelectedRow()
            if sr != -1:
                c.selectPosition( nlist[ sr ] )
            
            
        else:
            c.selectPosition( nlist[ 0 ] )
        c.endUpdate()
    else:
        self.emacs.setCommandText( "%s does not exits" % node )      
    self.nodes = {}     </t>
<t tx="ekr.20070127142841.132">class BracketHighlighter( sevent.ChangeListener, sevent.DocumentListener ):
    
    @others
    
        

</t>
<t tx="ekr.20070127142841.133">def __init__( self, editor, c ): #, color ):

    self._jtc = editor
    self.c = c
    self._jtc.getDocument().addDocumentListener( self )
    self.highlight_painter = None #stext.DefaultHighlighter.DefaultHighlightPainter( color )
    self.highlighting = False
    self.tag = None
    self.iFind = False
    self.matchers = { '{' : ( '{', '}' ),
                          '}' : ( '{', '}' ),
                          '(' : ( '(', ')' ),
                          ')' : ( '(', ')' ),
                          '[' : ( '[', ']' ),
                          ']' : ( '[', ']' ),
                          '&lt;' : ( '&lt;', '&gt;' ),
                          '&gt;' : ( '&lt;', '&gt;' ),
                          }
                          
    self._nomatch = ( None, None )
    self.match_bracket = 0
    self.setBracketMatch()
    manager = g.app.config.manager
    wm1 = WeakMethod( self, "setBracketMatch" )
    manager.addNotificationDef( "highlight_brackets", wm1 )
    manager.addNotificationDef( "highlight_brackets_color", wm1 )
    

</t>
<t tx="ekr.20070127142841.134">def changedUpdate( self, event ):
    pass
        
def insertUpdate( self, event ):
        
    doc = event.getDocument()
    len = event.getLength()
    where = event.getOffset()
    self.findBracket( where, doc, doc.getLength() )
    self.iFind = True
        
def removeUpdate( self, event ):
    pass  </t>
<t tx="ekr.20070127142841.135">def stateChanged( self, event ):
        
    jtc = self._jtc
    dot = jtc.getCaretPosition()
    doc = jtc.getDocument()
    dlen = doc.getLength()
    self.findBracket( dot, doc, dlen )</t>
<t tx="ekr.20070127142841.136">def findBracket( self, dot, doc, dlen ):
    
    if not self.match_bracket: return
    jtc = self._jtc
    highlighter = jtc.getHighlighter()
    if self.iFind:
        self.iFind = False
        return
    if self.highlighting:
        highlighter.removeHighlight( self.tag )
        self.highlighting = False
            
    if dot &gt;= dlen:
        return
    else:
        c = doc.getText( dot, 1 )
        first, last = self.matchers.get( c, self._nomatch )
        if not first: return
        if c == first:
            txt = jtc.getText()
            i = self.forwardFind( txt[ dot: ], first, last ) #we must include the first bracket for the find functions
            if i != -1:
                self.tag = highlighter.addHighlight( dot + i, dot + i + 1, self.highlight_painter )
                self.highlighting = True
        elif c == last:
                
            txt = jtc.getText( 0, dot + 1 )#we must include the first bracket for the find functions
            i = self.backwardFind( txt, first, last  )
            if i != -1:
                self.tag = highlighter.addHighlight( i, i +1, self.highlight_painter )
                self.highlighting = True
</t>
<t tx="ekr.20070127142841.137">def forwardFind( self, txt, first, last ):
        
    fbc = 0
    for z in xrange( len( txt ) ):
        c = txt[ z ]
        if c == first:
            fbc += 1
            continue
        elif c == last:
            if fbc:
                fbc -=1
            if not fbc:
                return z
                    
    return -1</t>
<t tx="ekr.20070127142841.138">def backwardFind( self, txt, first, last ):
        
    fbc = 0
    tlen = len( txt )
    tnum = tlen - 1
    for z in xrange( tlen ):
        c = txt[ tnum ]        
        if c == last:
            fbc +=1
        elif c == first:
            if fbc:
                fbc -= 1
            if not fbc:            
                return tnum
        tnum -= 1
    return -1    </t>
<t tx="ekr.20070127142841.139">def setBracketMatch( self, notification=None, handback = None ):

    c = self.c
    if g.app.config.getBool( c, "highlight_brackets" ):
        col = g.app.config.getColor( c, "highlight_brackets_color" )
        color = getColorInstance( col , awt.Color.GREEN )
        self.highlight_painter = stext.DefaultHighlighter.DefaultHighlightPainter( color )
        self.match_bracket = 1
    else:
        self.match_bracket = 0
    </t>
<t tx="ekr.20070127142841.140"></t>
<t tx="ekr.20070127142841.141">class autolistener( sevent.DocumentListener, aevent.KeyAdapter ):
    
    watchwords = {}
    
    def __init__( self, editor ):
        self.watchwords = leoSwingBody.Editor.autolistener.watchwords
        self.watchitems = ( '.',')' )
        self.txt_template = '%s%s%s'
        okchars ={}
        for z in string.ascii_letters:
            okchars[z] = z 
        okchars['_'] = '_'
        self.okchars = okchars
        self.editor = editor
        self.jeditor = editor.editor
        self.popup = None
        #self.layeredpane = editor.layeredpane
        self.haveseen = {}
        #self.autobox = None
        self.constructAutobox()
        self.on = 0
        wm1 = WeakMethod( self, "initialScan" )
        leoPlugins.registerHandler(('start2','open2'), wm1 )         
    
    
    @others
        
</t>
<t tx="ekr.20070127142841.142">@others</t>
<t tx="ekr.20070127142841.143">class inserter( aevent.MouseAdapter ):
    
    def __init__( self, autolistener ):
        self.autolistener = autolistener
        
    def mouseReleased( self, event ):
        self.autolistener.insertFromAutoBox()
        
        
class hider( aevent.MouseWheelListener ):
    
    def __init__( self, autolistener ):
        self.autolistener = autolistener
        
    def mouseWheelMoved( self, event ):
        if self.autolistener.autobase.isShowing():
            self.autolistener.hideAutoBox()


</t>
<t tx="ekr.20070127142841.144">def constructAutobox( self ):
    
    #import AutoPanel
    jp = swing.JPanel()
    #jp = AutoPanel()
    gbl = awt.GridBagLayout()
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    jp.setLayout( gbl )
    jlist = swing.JList( swing.DefaultListModel() )
    jlist.setName( "Autolist" )
    jlist.setFont( self.editor.editor.getFont() )
    self.jsp = jsp = swing.JScrollPane( jlist )
    gbl.setConstraints( jsp, gbc )
    jp.add( jsp )
    self.autobox = jlist 
    self.autobase = jp   
    self.autobox.addMouseListener( self.inserter( self ) )
    self.jeditor.addMouseWheelListener( self.hider( self ) )

</t>
<t tx="ekr.20070127142841.145">def keyPressed( self, event ): #aka key process keyStroke
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return
    
    if not self.on: return
    if not self.autobase.isShowing(): return #isVisible just determines if the thing should be visible, not if it is.  isShowing does.
    
    
    modifiers = event.getModifiers()
    mtxt = event.getKeyModifiersText( modifiers )
    ktxt = event.getKeyText( event.getKeyCode() )
    keysym = '%s %s' %( mtxt, ktxt )
    keysym = keysym.strip()
    if keysym == "shift" :
        return
        
    elif keysym == "Backspace":
        pos = self.jeditor.getCaretPosition()
        doc = self.jeditor.getDocument()
        if pos != 0:
            c = doc.getText( pos - 1, 1 )
            if c == '.':
                return self.hideAutoBox()


    elif self.testForUnbind( keysym ): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        #unbind( context )
        self.hideAutoBox()
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    #elif context.which==1:
    #    #no need to add text if its calltip time.
    #    return None 
    #ind = body.index('insert-1c wordstart')
    #pat = body.get(ind,'insert')+event.char 
    #pat = pat.lstrip('.')
    doc = self.jeditor.getDocument()
    pos = self.jeditor.getCaretPosition()
    try:
        txt = doc.getText( 0, pos )
    except:
        return
    txt_lines = txt.splitlines()
    
    if len( txt_lines ) &gt; 1:
        txt_line = txt_lines[ -1 ]
    else:
        txt_line = txt_lines[ 0 ]
    pat = txt_line.split( '.' )
    if len( pat ) &gt; 1:
        pat = pat[ -1 ]
    else:
        pat = pat[ 0 ]
    
    #print keysym
    if keysym == 'Ctrl Ctrl':
       return self.processAutoBox( event, pat )
     
    if keysym in ( "Alt Up", "Alt Down" ):
        event.consume()
        return self.moveUpDown( keysym )
    
    kchar = event.getKeyChar()
    if kchar == event.CHAR_UNDEFINED: return
    else:
        pat = pat + kchar
    autobox = self.autobox
    lm = autobox.getModel()
    ww = []
    index = None
    for z in xrange( lm.getSize() ):
        item = lm.getElementAt( z )
        if item.startswith( pat ):
                index = z
                break
        #ww.append( lm.getElementAt( z ) )

    #autobox = context.autobox
    #ww = list( autobox.get( 0, 'end' ) )
    #lis = self.reducer(ww,pat)
    #if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    #i = ww.index(lis[0])

    #lm.clear()
    #autobox.setListData( lis )
    if index != None:
        autobox.clearSelection()
        autobox.setSelectedIndex( index )
        autobox.ensureIndexIsVisible( index )
        
    #autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    #autobox.select_set( i )
    #autobox.see( i )
    #return 'break'

</t>
<t tx="ekr.20070127142841.146">def processAutoBox(self, event, pat ):
    '''This method processes the selection from the autobox.'''
    #if event.keysym in("Alt_L","Alt_R"):
    #    return None 

    #a = context.autobox.getvalue()
    a = self.autobox.getSelectedValue()
    #if len(a)==0:return None 
    if not a: self.hideAutoBox()
    try:
        #a = a[0]
        #ind = body.index('insert-1c wordstart')
        #pat = body.get(ind,'insert')
        #pat = pat.lstrip('.')

        if a.startswith(pat): a = a[len(pat):]
        doc = self.jeditor.getDocument()
        doc.insertString( self.jeditor.getCaretPosition(), a , None )
        self.hideAutoBox()
        #self.editor.insert 
        #body.insert('insert',a)
        #body.event_generate("&lt;Key&gt;")
        #body.update_idletasks()
    except java.lang.Exception, x:
        x.printStackTrace()
        #self.editor.hideAutoBox()
        #unbind( context )
</t>
<t tx="ekr.20070127142841.147">def moveUpDown( self, code ):
    
    autobox = self.autobox
    i = autobox.getSelectedIndex()
    if code == 'Alt Up':
        i2 = i -1
    else:
        i2 = i + 1
    
    lm = autobox.getModel()
    if i2 &lt; 0 or i2 + 1 &gt; lm.getSize():
        return
    else:
        autobox.setSelectedIndex( i2 )
        autobox.ensureIndexIsVisible( i2 )</t>
<t tx="ekr.20070127142841.148">def testForUnbind( self, keysym  ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''
      
    if keysym in ('parenright','parenleft', 'Escape', 'Space', 'Enter', 'Tab', 'Up', 'Down' ) or keysym.isspace():
        return True
    #elif not context.which and event.char in ripout:
    #    return True
    return False
</t>
<t tx="ekr.20070127142841.149">@others</t>
<t tx="ekr.20070127142841.150">def changedUpdate( self, event ):
    pass
        
</t>
<t tx="ekr.20070127142841.151">def insertUpdate( self, event ):
    
    if not self.on: return
    doc = event.getDocument()
    change = doc.getText( event.getOffset(), event.getLength() )
    if change=='.':
        self.watcher( event )
        
        

</t>
<t tx="ekr.20070127142841.152">def removeUpdate( self, event ):
    '''originally I wanted to do a remove of the autobox on a backspace of '.' but this couldnt be detected adequately
    and had to be put in the Key handling code of the autocompleter.'''
    pass
        
</t>
<t tx="ekr.20070127142841.153">watchitems = ( '.',')' )
txt_template = '%s%s%s'
def watcher ( self, event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    #global lang 
    doc = event.getDocument()
    txt = doc.getText( event.getOffset(), event.getLength() )
    if txt.isspace() or txt in self.watchitems:
        #bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        #if event.char.isspace():
        #    if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
        #    if bCtrl.get( 'insert -1c wordstart -1c') != '.': return
            
        #c = bCtrl.commander
        #lang = c.frame.body.getColorizer().language 
        #txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
        #                     event.char, 
        #                     bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet
        txt =  doc.getText( 0, doc.getLength() ) 
        self.scanText(txt)
        self.determineToShow( event )
    
</t>
<t tx="ekr.20070127142841.154">def scanText ( self, txt):
    '''This function guides what gets scanned.'''

    #if useauto:
    self.scanForAutoCompleter(txt)
    #if usecall:
    #    scanForCallTip(txt)
</t>
<t tx="ekr.20070127142841.155">def scanForAutoCompleter ( self, txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b: self.makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            if self.watchwords.has_key(a):
                self.watchwords[a][ b ] = None
            else:
                self.watchwords[ a ] = { b: None }
                #watchwords[a] = sets.Set([b])
                #watchwords[ a ] = util.Hash
            #watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!</t>
<t tx="ekr.20070127142841.156">def makeAutocompletionList ( self, a,b,glist):
    '''A helper function for autocompletion'''
    a1 = self._reverseFindWhitespace(a)
    if a1:
        b2 = self._getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 
</t>
<t tx="ekr.20070127142841.157">def _getCleanString ( self, s ):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    #for n, l in enumerate(s):
    for n in xrange( len( s ) ):
        l = s[ n ]
        if l in self.okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20070127142841.158">def _reverseFindWhitespace ( self, s):
    '''A helper for autocompletion scan'''
    #for n, l in enumerate(s):
    for n in xrange( len( s ) ):
        l = s[ n ]
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20070127142841.159">def reducer ( self, lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20070127142841.160">def determineToShow( self, event ):
    
    doc = event.getDocument()
    txt = doc.getText( 0, event.getOffset() )
    txt_list = txt.splitlines()
    if not txt_list: return
    txt_line = txt_list[ - 1 ]
    txt_splitdots = txt_line.split( '.' )[ -1 ]
    txt_final = txt_splitdots.split()
    if txt_final:
        txt_final = txt_final[ -1 ]
    if txt_final and self.watchwords.has_key( txt_final ):
        completers = self.watchwords[ txt_final ].keys()
        completers.sort()
        self.getAutoBox( completers )
    
</t>
<t tx="ekr.20070127142841.161">@others</t>
<t tx="ekr.20070127142841.162">def initialScan ( self, tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")or keywords.get("new_c")
    haveseen = self.haveseen 
    if haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    #pth = os.path.split(g.app.loadDir)  
    #aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    #if not os.path.exists(aini):
    #    createConfigFile( aini )
    #try:
    #    if not hasReadConfig():
    #        if os.path.exists(aini):
    #            readConfigFile(aini) 
    #
    #        bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
    #        readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    #finally:
    #    setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.
    #_self = self
    #class scanner( java.lang.Thread ):          
    #def run( self ):
    #    _self.readOutline( c )
    #    #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
    #    #readOutline( c )
    
    dc = DefCallable( lambda : self.readOutline( c ) )
    g.app.gui.addStartupTask( dc )
    


</t>
<t tx="ekr.20070127142841.163">def readOutline ( self, c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    #global lang
    #if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
    #    import chapters 
    #    it = chapters.walkChapters()
    #     for x in it:
    #        lang = None 
    #        setLanguage(x)
    #        scanText(x.bodyString())
    #else:
    for z in c.rootPosition().allNodes_iter( copy = True):
        #self.scanText( z.bodyString() )
        rvalues = LeoUtilities.scanForAutoCompleter( z.v.t._bodyString )
        if rvalues:
            for z in rvalues:
                a,b = z
                if self.watchwords.has_key(a):
                    self.watchwords[a][ b ] = None
                else:
                    self.watchwords[ a ] = { b: None }

        
        
    g.es( "Autocompleter ready" )
</t>
<t tx="ekr.20070127142841.164">@others</t>
<t tx="ekr.20070127142841.165">def getAutoBox( self, completers ):
        
    jlist = self.autobox
    jp = self.autobase
    if len( completers ) &lt; 5:
        jlist.setVisibleRowCount( len( completers ) )
    else:
        jlist.setVisibleRowCount( 5 )
    
    model = jlist.getModel()
    model.removeAllElements() #by working with the model we dont burn a new object each time.
    for z in completers:
        model.addElement( z )
    jlist.setSelectedIndex( 0 )
    jlist.ensureIndexIsVisible( 0 )
    jlist.setValueIsAdjusting( True )

    
    cur = self.jeditor.getCaretPosition()
    pos = self.jeditor.modelToView( cur )    
    size = self.editor.view.getViewport().getViewRect()
    pos = swing.SwingUtilities.convertRectangle( self.jeditor, pos, self.editor.epane )
    size.x = 0; size.y = 0;


    jlist.setSize( jlist.getPreferredSize() )#the discrepency between the two was causing weird drawing bugs.  This appears to have rectified it.
    #Its very important that the setSize call happens before the self.jsp.getPreferredSize call, or it may not calculate right.
    jsps = self.jsp.getPreferredSize()
    jp.setSize( jsps )  
    rx = ry = 0
    if pos.x &gt; (size.x + size.height)/2:
        rx = pos.x - jsps.width
    else: rx = pos.x
    
    if pos.y &gt; ( size.y + size.height )/2:
        ry = pos.y - jsps.height
    else: ry = pos.y + pos.height
    
    point = awt.Point( rx, ry )
    swing.SwingUtilities.convertPointToScreen( point, self.editor.view.getViewport() )
    popupfactory = swing.PopupFactory().getSharedInstance()
    self.popup = popup = popupfactory.getPopup( self.editor.editor, jp, point.x, point.y )
    popup.show()






</t>
<t tx="ekr.20070127142841.166">def hideAutoBox( self ):

    if self.popup:
        self.popup.hide();self.popup = None


</t>
<t tx="ekr.20070127142841.167">def insertFromAutoBox( self ):
            
    autobox = self.autobox
    value = autobox.getSelectedValue()
    pos = self.jeditor.getCaretPosition()
    self.jeditor.getDocument().insertString( pos, value, None )
    self.hideAutoBox()</t>
<t tx="ekr.20070127142841.168"></t>
<t tx="ekr.20070127142841.169">class UnderlinerCaret( stext.DefaultCaret ):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__( self, color ):
        stext.DefaultCaret.__init__( self )
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #self._bg = awt.Color.RED
        self._bg = color
        #self._bg = awt.Color( c.getRed(), c.getGreen(), c.getBlue(), 50 ); 
        self.setBlinkRate( 0 ) #no blinking please

        
    def paint( self, g ):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView( pos )

        if( self.x != view.x or self.y != view.y ): 
            self.super__repaint()
            self.x = view.x
            self.y = view.y 
            self.width = self.calculateCharacterWidth( g ) + 1 #Its important to be a little wider
            self.height = view.height + 1                      #And a little taller than the box, or redraws will leave traces
            

        if self.isVisible():
            g.setColor( self._bg )
            #g.fillRect( self.x, self.y, self.width - 1, view.height )
            g.drawLine( self.x  , self.y + self.height - 1, self.x + self.width - 1, self.y + self.height - 1 )
        self.setMagicCaretPosition( awt.Point( self.x, self.y ) )
        
    def calculateCharacterWidth( self, g ):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        fm = g.getFontMetrics()
        
        pos = com.getCaretPosition()
        len = com.getDocument().getLength()
        if pos &gt;= len:
            c = ' '
        else:
            c = com.getText( pos, 1 )
        if java.lang.Character.isWhitespace( c ): c = ' '
        
        return swing.SwingUtilities.computeStringWidth( fm, c )
        

        
        
        
    def damage( self, r ):
        
        if r == None: return
        
        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView( pos )
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth( graphics ) + 1
        graphics.dispose()
        self.height = view.height + 1;
        self.super__repaint()
        self.setMagicCaretPosition( awt.Point( self.x, self.y ) )</t>
<t tx="ekr.20070127142841.170">class SeeThroughBoxCaret( stext.DefaultCaret ):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__( self, color ):
        stext.DefaultCaret.__init__( self )
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #c = awt.Color.RED
        self._bg = awt.Color( color.getRed(), color.getGreen(), color.getBlue(), 50 ); 
        self.setBlinkRate( 0 ) #no blinking please

        
    def paint( self, g ):
        
        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView( pos )
        if( self.x != view.x or self.y != view.y ): 
            self.super__repaint()
            self.x = view.x
            self.y = view.y 
            self.width = self.calculateCharacterWidth( g ) + 1 #Its important to be a little wider
            self.height = view.height + 1                      #And a little taller than the box, or redraws will leave traces
            

        if self.isVisible():
            g.setColor( self._bg )
            g.fillRect( self.x, self.y, self.width - 1, view.height)

        self.setMagicCaretPosition( awt.Point( self.x, self.y ) )
        
    def calculateCharacterWidth( self, g ):
        '''This method allows the see-through box to have the same width as the character'''

        if not g: return 0
        com = self.super__getComponent()
        doc = com.getDocument()
        pos = com.getCaretPosition()
        len = doc.getLength()
        if pos &gt;= len:
            c = ' '
        else:
            c = com.getText( pos, 1 )
        
        e = doc.getCharacterElement( pos ) 
        atts = e.getAttributes()
        f = doc.getFont( atts )
        if f:
            g.setFont( f )
        fm = g.getFontMetrics()
        
        if java.lang.Character.isWhitespace( c ): c = ' '
        
        return swing.SwingUtilities.computeStringWidth( fm, c )
        

        
        
        
    def damage( self, r ):
        
        if r == None: return
        
        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView( pos )
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth( graphics ) + 1
        if graphics:
            graphics.dispose()
        self.height = view.height + 1;
        self.super__repaint()
        self.setMagicCaretPosition( awt.Point( self.x, self.y ) )
        
</t>
<t tx="ekr.20070127142841.171">import java.awt.image as aim
class GhostlyLeoCaret( stext.DefaultCaret ):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__( self ):
        stext.DefaultCaret.__init__( self )
        
        self.setBlinkRate( 0 ) #no blinking please
        self._image = leoSwingBody.Editor.icon.getImage()
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1
        self._ac = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, .2 )
        self._bgc = None
    
        
    def paint( self, g ):

        com = self.super__getComponent()
        if self._bgc == None:
            self._bgc == g.getColor()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView( pos )

        if( self.x != view.x or self.y != view.y ): 
            self.super__repaint()
            self.x = view.x
            self.y = view.y      
            self.width = self._im_width
            self.height = self._im_height               
            

        if self.isVisible():

            if not self.isWhiteSpace( g ):
                g.setComposite( self._ac )
            g.drawImage( self._image, self.x, self.y, self._bgc, None )
        self.setMagicCaretPosition( awt.Point(  self.x, self.y ) )
        
    def isWhiteSpace( self, g ):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        v1 = com.viewToModel( awt.Point( self.x, self.y ) )
        v2 = com.viewToModel( awt.Point( self.x + self.width, self.y ) )
        vlen = v2 - v1
        len = com.getDocument().getLength()
        if v1 &gt;= len:
            c = ' '
        else:
            c = com.getText( v1, vlen )
        if c.isspace() or c =='' : c = ' '
        return c == ' '
        

        
        
        
    def damage( self, r ):
        
        if r == None: return
        
        self.x = r.x
        self.y = r.y
        self.height = self._im_height
        self.width = self._im_width
        self.super__repaint()
        self.setMagicCaretPosition( awt.Point(self.x, self.y) )
</t>
<t tx="ekr.20070127142841.172">class ImageCaret( GhostlyLeoCaret ):
    
    def __init__( self, image ):
        leoSwingBody.Editor.GhostlyLeoCaret.__init__( self )
        self._image = image
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1
        
    
</t>
<t tx="ekr.20070127142841.173">class leoJTextPane( swing.JTextPane):
        
    def __init__( self, c ):
        swing.JTextPane.__init__( self )
        self.c = c
        self.last_rec = None
        self._bg = None
        
    def setLineColor( self, notification = None, handback = None ):
        
        c = self.c
        if g.app.config.getBool( c, "highlight_current_line" ):
            hc = g.app.config.getColor( c, "current_line_highlight_color" )
            color = getColorInstance( hc, awt.Color.ORANGE )
            self._bg = awt.Color( color.getRed(), color.getGreen(), color.getBlue(), 50 )
        else:
            self._bg = None 
            self._last_rec = None
        self.repaint()
    
@        
    def paintComponent( self , graphics ):
        if 0:
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = awt.Color.RED
            c2 = awt.Color.GREEN
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint( vrect.x, vrect.y, c1, vrect.x + vrect.width, vrect.y + vrect.height, c2 )
            graphics.setPaint( gp )
            graphics.fillRect( vrect.x, vrect.y, vrect.width, vrect.height )
            graphics.setPaint( paint )
@c

    def paintComponent( self , graphics ):
                    
        self.super__paintComponent( graphics )
        if self._bg:
            cpos = self.getCaretPosition()#from here
            try:
                rec = self.modelToView( cpos )
            except java.lang.Exception, x:
                x.printStackTrace()
                return
            sz = self.getVisibleRect()
            rec = awt.Rectangle( sz.x, rec.y, sz.width, rec.height )#to here: these calculate the colored background. 
            if self.last_rec and not self.last_rec.equals( rec ): #its not the same spot we must repaint!
                if self.last_rec.width &lt; rec.width:
                    self.last_rec.width = rec.width
                self.repaint( self.last_rec )
    
        
            c = graphics.getClip()
            rintersect = rec.intersects( c )
            if not rec.equals( self.last_rec ) or rintersect:
                if self.last_rec:
                    if rec.y != self.last_rec.y or rec.height != self.last_rec.height:
                        rintersect = 0
                if rintersect:
                    graphics.setColor( self._bg ) #if we intersect we only repaint a small portion. This reduces flicker.
                    graphics.fill( rec )
                else:
                    g2 = self.getGraphics()
                    g2.setColor( self._bg ) #if we dont we repaint all of it.
                    g2.fill( rec )
                    g2.dispose()
        
        
            self.last_rec = rec

        
</t>
<t tx="ekr.20070127142841.174">class leoImageJPanel( swing.JPanel ):
    
    def __init__( self, layoutmanager):
        swing.JPanel.__init__( self, layoutmanager )
        self.image = None
        self.backedWidget = None
        self.last_image = None
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 ) 
        self.lastDimensions = awt.Rectangle( 0, 0, 0, 0 )
        
    def setBackedWidget( self, widget ):
        self.backedWidget = widget
        
    def setImage( self, image ):
        self.image = image
        
    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha ) 
        
    def paintComponent( self, graphics ):
        
        self.super__paintComponent( graphics )
        if self.backedWidget and self.image:
            vrec = self.backedWidget.getVisibleRect()
            rec2 = swing.SwingUtilities.convertRectangle( self.backedWidget, vrec, self )
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( rec2.width, rec2.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )
            graphics.drawImage( self.last_image, rec2.x, rec2.y, awt.Color.WHITE, None )
            graphics.setComposite( composite )
        </t>
<t tx="ekr.20070127142841.175">class leoLayoutManager( awt.LayoutManager ):
    
    
    def __init__( self ):
        self.jscrollpane = None
        self.minibuffer = None
        self.media = None
        
        
        
    def addLayoutComponent( self, name, component ):
        pass
        
    
    def layoutContainer( self, container ):

        size = container.getSize()
        if self.minibuffer:
            mbpsize = self.minibuffer.getPreferredSize()
        else:
            mbpsize = awt.Rectangle( 0, 0, 0, 0 )
        
        if self.jscrollpane:
            self.jscrollpane.setBounds( 0, 0, size.width, size.height - mbpsize.height )
            if self.minibuffer:
                self.minibuffer.setBounds( 0, size.height - mbpsize.height, size.width, mbpsize.height )
            
        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds( vr )
            
    def layoutMedia( self ):
        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds( vr )        
    
    def minimumLayoutSize( self, container ):       
        return container.getMinimumSize()
        
    
    def preferredLayoutSize( self, container ):
        return container.getPreferredSize()
        
        
    def removeLayoutComponent( self, container ):
        pass        
            </t>
<t tx="ekr.20070127142841.176">class UtilityRightClick( aevent.MouseAdapter ):
    
    
    def __init__( self, c, detach_retach = False, editor = None ):
        aevent.MouseAdapter.__init__( self )
        self.c = c
        self.editor = weakref.proxy( editor )
        self._detach_retach = detach_retach
    
    
    @others
                        
                        
</t>
<t tx="ekr.20070127142841.177">def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
            
            
            popup = swing.JPopupMenu()


            UtilityAction = leoSwingBody.UtilityAction
            AddEditor = leoSwingBody.AddEditor
            InsertNode = leoSwingBody.InsertNode            
            frame = self.c.frame
            for z in ( ( "Cut", self.editor.editor.cut ), ( "Copy", self.editor.editor.copy ), 
                        ( "Paste", self.editor.editor.paste ), # frame.OnPaste ), 
                        ( "Delete", self.c.delete  ),
                        ):
                popup.add( UtilityAction( z[ 0 ], z[ 1 ] ) )
            
            
            popup.addSeparator()
            popup.add( UtilityAction( "Turn Selection Into Node", self.editor.turnSelectionIntoNode ))
            inmenu = swing.JMenu( "Insert Node Into Body" )
            inmenu.addMenuListener( InsertNode( inmenu, self.c, UtilityAction ) )
            popup.add( inmenu )
            
            popup.add( UtilityAction( "Split Node", frame.body.editor.splitNode ) )
              
            if( mE.getComponent() == self.editor ):
                popup.add( UtilityAction( "Select All", self.editor.selectAll ) )
                
            popup.addSeparator()  
            body = frame.body
            popup.add( AddEditor( body , x, y ) )
            popup.addSeparator()               
            if self._detach_retach:
                if self.editor._attached:
                    s = "Detach Editor"
                    act = self.editor.detach
                else:
                    s = "Retach Editor"
                    act = self.editor.retach 
                ji = swing.JMenuItem( s )
                ji.actionPerformed =  act
                popup.add( ji )
            
            
            folded = self.editor.foldprotection.isFolded( x, y )
            if self.editor.editor.getSelectionStart() != self.editor.editor.getSelectionEnd() or folded:
                popup.addSeparator()
                if not folded:
                    jmi = swing.JMenuItem( "Fold Selection" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection: fp.foldSelection()
                else:
                    jmi = swing.JMenuItem( "Unfold Fold" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection, x = x, y= y: fp.unfoldSpot( x, y )
                
                popup.add( jmi )
                
                
            source = mE.getSource()    
            popup.show( source, x, y )</t>
<t tx="ekr.20070127142841.178">def addTab( self, name, widget ):
    
    self.tab_manager.add( name, widget )
    
    

def removeTab( self, widget ):
    
    self.tab_manager.remove( widget )
        
    </t>
<t tx="ekr.20070127142841.179">def nextEditor( self, reverse = False ):
    
    editor = self.editor
    next = False
    editors = list( self.editors )
    if reverse:
        editors.reverse()
    for z in editors:
        z = z.get()
        if next:
            tl = z.editor.getTopLevelAncestor()
            tl.toFront()
            z.editor.requestFocus()
            return
        if z == editor: next = True
    if next:
        for z in editors:
            z = z.get()
            if z:
                tl = z.editor.getTopLevelAncestor()
                tl.toFront()
                z.editor.requestFocus()
                return

    
def previousEditor( self ):
    self.nextEditor( reverse = True )

   
</t>
<t tx="ekr.20070127142841.180">@others</t>
<t tx="ekr.20070127142841.181">class SimplifiedUtilityRightClick( aevent.MouseAdapter ):
    
    
    def __init__( self, body ):
        aevent.MouseAdapter.__init__( self )
        self.body = body

    
    
    @others
                        
                        
</t>
<t tx="ekr.20070127142841.182">def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
                       
            popup = swing.JPopupMenu()
            AddEditor = leoSwingBody.AddEditor
            popup.add( AddEditor( self.body , x, y ) )                
            source = mE.getSource()                
            popup.show( source, x, y )</t>
<t tx="ekr.20070127142841.183">class AddEditor( swing.AbstractAction ):
                    
    def __init__( self, body, x,y ):
        swing.AbstractAction.__init__( self, "Add Editor" )
        self.body = body
        self.x = x
        self.y = y
                        
    def actionPerformed( self, event ):
        leoSwingBody.Editor( self.body.jdp , self.body.c, self.body , x = self.x, y = self.y )</t>
<t tx="ekr.20070127142841.184">class UtilityAction( swing.AbstractAction ):
    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command
                        
    def actionPerformed( self, event ):
        self.command()</t>
<t tx="ekr.20070127142841.185">class InsertNode( sevent.MenuListener ):

    def __init__( self, menu, c, utilityaction ):
        self.menu = menu
        self.c = c
        self.UtilityAction = utilityaction
        #self.insert = insert
                
    def menuCanceled( self, event ):
        pass
                
    def menuDeselected( self, event ):
        pass
                
    def menuSelected( self, event ):
        
        menu = self.menu       
        menu.removeAll()
        cp = self.c.currentPosition()
        for z in cp.children_iter( copy = True ):
            action = lambda node = z: self.insertNode( node )
            ua = self.UtilityAction( z.headString(), action )
            menu.add( ua )

    def insertNode( self, node ):
        
        c = self.c
        at = c.atFileCommands
        at.write(node.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
        c.frame.body.editor.insertTextIntoBody( data )
        c.beginUpdate()
        cpos = c.currentPosition()
        node.doDelete( cpos )
        c.endUpdate()
               



</t>
<t tx="ekr.20070127142841.186">def undoableEditHappened( self, event ):
    
    if self.ignore_insert: return
    c = self.c
    cp = c.currentPosition().copy()
    edit = event.getEdit()
    #dec_edit = leoSwingUndo.UndoableEditDecorator( c, cp, edit )
    #c.undoer.addUndo( dec_edit )
    
    #undoType = "undo_edit_class"
    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
</t>
<t tx="ekr.20070127142841.187">def keyPressed( self, event ):
    
    editor = self.editor.editor
    self.oldText = editor.getText()
    self.oldSel = editor.getSelectedText()
    self.ch = event.getKeyChar()
    cpos = editor.getCaretPosition()
    rec = editor.modelToView( cpos )
    self.oldYview = rec.y 
</t>
<t tx="ekr.20070127142841.188">def getAllText( self ):
    
    return self.editor.editor.getText()</t>
<t tx="ekr.20070127142841.189">class leoSwingFrame ( leoFrame.leoFrame ):     
    
    """The base class for all Leo windows."""
    
    instances = 0
    
    @others</t>
<t tx="ekr.20070127142841.190">def __init__ (self, gui ):
    
    leoFrame.leoFrame.__init__( self, gui )
    self.gui = gui
    #import RepaintManager2
    #rpm2 = RepaintManager2()
    #swing.RepaintManager.setCurrentManager( rpm2 )
    # Objects attached to this frame.
    self.menu = None
    self.keys = None
    self.colorPanel = None 
    self.fontPanel = None 
    self.prefsPanel = None
    self.comparePanel = None 
    self.title = ""
    self._menu_init_callbacks = []
    self.receiver = None
    self.canresize = True
    
    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    #if g.app.config.getBool( self.c, "lock_open_files" ):
    #    receiver = self.Receiver( self, self.c )
    #    thread = java.lang.Thread( receiver )
    #    thread.setDaemon( True )
    #    thread.start()
        
    #self.c = None # Must be created by subclasses.
    #self.title = None # Must be created by subclasses.
    
    # Objects attached to this frame.
    #self.menu = None
    #self.keys = None
    #self.colorPanel = None 
    #self.fontPanel = None 
    #self.prefsPanel = None
    #self.comparePanel = None

    # Gui-independent data
    #self.es_newlines = 0 # newline count for this log stream
    #self.openDirectory = ""
    #self.saved=False # True if ever saved
    #self.splitVerticalFlag,self.ratio, self.secondary_ratio = self.initialRatios()
    #self.startupWindow=False # True if initially opened window
    #self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.

    # Colors of log pane.
    #self.statusColorTags = [] # list of color names used as tags in status window.

    # Previous row and column shown in the status area.
    #self.lastStatusRow = self.lastStatusCol = 0
    #self.tab_width = 0 # The tab width in effect in this pane.</t>
<t tx="ekr.20070127142841.191"></t>
<t tx="ekr.20070127142841.192"># In the Edit menu...
def OnCopy  (self,event=None): self.OnCopyFromMenu()
def OnCut   (self,event=None): self.OnCutFromMenu()
def OnPaste (self,event=None): self.OnPasteFromMenu()

def OnCutFromMenu  (self):
    self.OnCopyFromMenu()
    self.body.editor.editor.replaceSelection( "" ) 
    
def OnCopyFromMenu (self):
    
    gui = g.app.gui
    editor = self.body.editor.editor
    txt = editor.getSelectedText()
    gui.replaceClipboardWith( txt )
    
def OnPasteFromMenu (self):
    
    txt = g.app.gui.getTextFromClipboard()
    editor = self.body.editor.editor
    document = self.body.editor.editor.getStyledDocument()
    if txt:
        pos = editor.getCaretPosition()
        document.insertString( pos, txt, None )
    

def abortEditLabelCommand (self):
    
    self.c.frame.tree.jtree.cancelEditing()
    
def endEditLabelCommand (self):   
    self.c.frame.tree.endEditLabel()
    
def insertHeadlineTime (self):    
    time = self.c.getTime( body = False )
    cp = self.c.currentPosition()
    hs = cp.headString()
    nhs = '%s %s' %( time, hs )
    cp.setHeadString( nhs )
    
    
# In the Window menu...
def cascade(self):              self.oops()
def equalSizedPanes(self):
    self.jsp2.setDividerLocation( .5 )
    
def hideLogWindow (self):       self.oops()
def minimizeAll(self):
    
    self.top.setState( self.top.ICONIFIED )   
    
def resizeToScreen(self):
    
    tk = self.top.getToolkit()
    ss = tk.getScreenSize()
    self.top.setBounds( 0, 0, ss.width, ss.height )
    
def toggleActivePane(self):     self.oops()


def toggleSplitDirection(self):
    
    self._toggle( self.jsp1 )
    self._toggle( self.jsp2 )
    self.jsp2.setDividerLocation( .50 )
    self.jsp1.setDividerLocation( .75 )
    
def _toggle( self, jsp ):
    
    orient = jsp.getOrientation()
    if orient == jsp.HORIZONTAL_SPLIT:
        jsp.setOrientation( jsp.VERTICAL_SPLIT )
    else:
        jsp.setOrientation( jsp.HORIZONTAL_SPLIT )
        
     
        

# In help menu...
def leoHelp (self): self.oops()

</t>
<t tx="ekr.20070127142841.193">def bringToFront (self):
    
    self.top.toFront()

def deiconify (self):
    
    self.top.setVisible( True )
    
def lift (self):
    
    self.top.toFront()
    
def update (self):
    
    self.top.repaint()
    
</t>
<t tx="ekr.20070127142841.194"></t>
<t tx="ekr.20070127142841.195">def resizePanesToRatio (self,ratio,secondary_ratio):
        
    def resize():
        self.jsp1.setDividerLocation( ratio )
        self.jsp2.setDividerLocation( secondary_ratio ) 
    
    dc = DefCallable( resize )
    java.awt.EventQueue.invokeLater( java.util.concurrent.FutureTask( dc ) )
    </t>
<t tx="ekr.20070127142841.196">def setInitialWindowGeometry (self):
    """Set the position and size of the frame to config params."""
    #config = g.app.config
    c = self.c 
    h = c.config.getInt("initial_window_height")
    w = c.config.getInt("initial_window_width")
    x = c.config.getInt("initial_window_left")
    y = c.config.getInt("initial_window_top")
    
    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)

    #was:
    #h = config.getIntWindowPref("initial_window_height")
    #w = config.getIntWindowPref("initial_window_width")
    #x = config.getIntWindowPref("initial_window_left")
    #y = config.getIntWindowPref("initial_window_top")
    #if h and w and x and y:
    #    self.setTopGeometry(w,h,x,y)</t>
<t tx="ekr.20070127142841.197">def setTopGeometry (self,w,h,x,y,adjustSize=True):
   
    if self.canresize: 
        self.top.setBounds( x, y, w, h )    
    
    
def disableResizing( self ):
    
    self.canresize = False
    
def enableResizing( self ):
    
    self.canresize = True</t>
<t tx="ekr.20070127142841.198">def get_window_info( self ):
    
    bounds = self.top.getBounds()
    return ( bounds.width, bounds.height, bounds.x, bounds.y )
</t>
<t tx="ekr.20070127142841.199">def finishCreate(self,c):

    self.c = c
    self.setSkin()
    #swing.plaf.metal.MetalLookAndFeel.setCurrentTheme( self.LeoMetalTheme( self.c ) )
    wm1 = WeakMethod( self, "setSkin" )
    g.app.config.manager.addNotificationDef( "type_of_skin", wm1 )
    self.top = swing.JFrame() #Must add close question
    self.gp2 = self.GlassPane2()
    self.top.setGlassPane( self.gp2 )
    self.top.addWindowListener( self.WindowClosingWatcher( self ) )
        
    self.ftp = self.leoFocusTraversalPolicy( c )
    self.top.setFocusTraversalPolicy( self.ftp )
    #if g.app.config.getBool( self.c, "lock_open_files" ) and self.c.mFileName != "":
    #    self.startReceiver()

    g.app.gui.addLAFListener( self.top )
    #self.setSkin()
    #g.app.config.manager.addNotificationDef( "type_of_skin", self.setSkin )

           
    ic = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp.GIF")
    ifile = io.File( ic )
    if ifile.exists():
        try:
            icimage = imageio.ImageIO.read( ifile )
            self.top.setIconImage( icimage )
        except java.lang.Exception, x:
            pass
    self.top.setDefaultCloseOperation( swing.JFrame.DO_NOTHING_ON_CLOSE )
    self.setTitle( c.mFileName )
    pf = self.top.getContentPane()

    self.jcp = self.top.getContentPane()
    self.toolbar = swing.JPanel( java.awt.BorderLayout() ) #swing.JToolBar()
    #self.toolbar.setFloatable( False )
    nodebar = swing.JToolBar()
    self.NodeBar( c, nodebar )
    nodebar.setFloatable( True )
    self.toolbar.add( nodebar, java.awt.BorderLayout.NORTH )
    self.toolbar2 = swing.JToolBar()
    #g.doHook( "toolbar2-in-place", c = self.c , toolbar = self.toolbar2 )
    self.toolbar.add( self.toolbar2, java.awt.BorderLayout.SOUTH )
    
    self.jsp1 = swing.JSplitPane()
    self.jsp1.continuousLayout = True
    
    #pf.add( self.jif3 )
    self.jsp2 = swing.JSplitPane( swing.JSplitPane.VERTICAL_SPLIT, True )
    self.jsp2.topComponent = self.jsp1
    #self.jtab = swing.JTabbedPane()
    #self.tree_tabs = TabManager()
    #self.jsp1.leftComponent = self.tree_tabs.base #self.jtab
    self.jcp.add( self.jsp2 , awt.BorderLayout.CENTER )
    self.top.add( self.toolbar, awt.BorderLayout.NORTH )
    #self.jif.getContentPane().add( self.jtab )
    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    self.jsp1.leftComponent = self.c.chapters.getWidget()
    #self.tree = leoSwingTree(frame=self)
    self.tree = self.c.chapters.addChapter( "New Chapter", p = c.rootPosition() )
    #self.jsp1.leftComponent = self.tree.getWidget()
    self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    #self.menu.createMenuBar( self )
    self.body = leoSwingBody(frame=self,parentFrame=self.jsp2 )
    self.log  = leoSwingLog (frame=self,parentFrame=self.jsp1 )
    import leoSwingFind
    self.findPanel = leoSwingFind.leoSwingFind( c )
    g.app.log = self.log 
    self.bodyCtrl = self.body.editor.editor
    
    tk = self.top.getToolkit()
    size = tk.getScreenSize()
    self.top.bounds = ( 0, 0, size.width , size.height )
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )
    self.jsp1.setOneTouchExpandable( True )
    self.jsp2.setOneTouchExpandable( True )
    &lt;&lt; create the first tree node &gt;&gt;
    #self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    self.menu.createMenuBar( self )
    #self.top.visible = True
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )
    
    g.app.windowList.append( self )
    c.initVersion()
    c.signOnWithVersion()
    self.menuInitialized()
    placement = g.app.config.getString( c, 'tree_editor_placement' )
    if placement == "Top/Bottom":
        pass
    else:
        self.toggleSplitDirection()



</t>
<t tx="ekr.20070127142841.200">import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")
c.beginUpdate()
p.moveToRoot()
#c.beginUpdate()
#c.selectVnode(p)
c.selectPosition( p )
#c.redraw()
#c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)


</t>
<t tx="ekr.20070127142841.201">def setTabWidth (self,w):
    
    # Subclasses may override this to affect drawing.
    self.tab_width = w</t>
<t tx="ekr.20070127142841.202">def getTitle (self):
    return self.title
    
def setTitle (self,title):
    self.top.title = title</t>
<t tx="ekr.20070127142841.203">def initialRatios (self):

    config = g.app.config

    s = config.getWindowPref("initial_splitter_orientation")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = config.getFloatWindowPref("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = config.getFloatWindowPref("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # print r,r2
    return verticalFlag,r,r2</t>
<t tx="ekr.20070127142841.204">def longFileName (self):

    return self.c.mFileName
    
def shortFileName (self):

    return g.shortFileName(self.c.mFileName)</t>
<t tx="ekr.20070127142841.205">def oops(self):
    
    print "leoFrame oops:", g.callerName(2), "should be overridden in subclass"
</t>
<t tx="ekr.20070127142841.206">def promptForSave (self):
    
    """Prompt the user to save changes.
    
    Return True if the user vetos the quit or save operation."""
    
    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting, "quitting?", "closing?")
    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))    
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.</t>
<t tx="ekr.20070127142841.207"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")</t>
<t tx="ekr.20070127142841.208"># Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; set w and break on @tabwidth &gt;&gt;

    c.frame.setTabWidth(w)</t>
<t tx="ekr.20070127142841.209">if dict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break</t>
<t tx="ekr.20070127142841.210">def destroySelf( self ):
    
    self.top.setVisible( False )
    self.top.dispose()
    self.top = None
    
</t>
<t tx="ekr.20070127142841.211">def clearStatusLine( self ):
    pass
    
def putStatusLine( self, s, **kwords ):
    pass</t>
<t tx="ekr.20070127142841.212">def finishCreateForSettings(self,c, controller ):

    self.c = c
    self.top = swing.JFrame()
    self.ftp = self.leoFocusTraversalPolicy( c )
    self.top.setFocusTraversalPolicy( self.ftp )
    self.top.setTitle( "Leo Settings" )
    
    ic = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp.GIF")
    ifile = java.io.File( ic )
    if ifile.exists():
        iimage = imageio.ImageIO.read( ifile )
        self.top.setIconImage( iimage )
    self.top.setDefaultCloseOperation( swing.JFrame.EXIT_ON_CLOSE )
    self.setTitle( c.mFileName )
    pf = self.top.getContentPane()
    gbl = awt.GridBagLayout()
    pf.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.weightx = 1
    gbc.weighty = 1
    gbc.fill = 1
    

    self.jcp = self.top.getContentPane()    
    self.jsp1 = swing.JSplitPane( swing.JSplitPane.VERTICAL_SPLIT )
    gbl.setConstraints( self.jsp1, gbc )
    self.jsp1.continuousLayout = True
    pf.add( self.jsp1 )
    self.jtab = self.c.chapters.getWidget()
    c.chapters.disablePopup()
    self.jsp1.leftComponent = self.jtab
    self.jsp1.rightComponent = swing.JPanel()
    self.tree = c.chapters.addChapterForSettingsTree( "Settings", p = c.rootPosition(), controller = controller )
    self.tree.jtree.setEditable( False )
    class fkBody:
        
        class ed:
            def __init__( self ):
                self.editor = swing.JTextPane()
                
            def sync( self, *args ):
                pass
        
        def __init__( self ):
            self.editor =  self.ed()
        
        def setFocus( self ):
            pass
            
        def setSelectionAreas( self, *args):
            pass
            
        def setTextSelection( self, *args ):
            pass
            
        def recolor( self, *args ):
            pass
            
        def setColorFromConfig( self, *args ):
            pass
            
    self.body = fkBody()
    self.jsp1.setOneTouchExpandable( True )
    &lt;&lt; create the first tree node &gt;&gt;
    self.jsp1.setDividerLocation( .5 )
    g.app.windowList.append( self )
    c.initVersion()
    c.signOnWithVersion()
    self.tree.jtree.setDragEnabled( False )

        
</t>
<t tx="ekr.20070127142841.213">import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")
c.beginUpdate()
p.moveToRoot()
#c.beginUpdate()
#c.selectVnode(p)
c.selectPosition( p )
#c.redraw()
#c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)


</t>
<t tx="ekr.20070127142841.214">@others
</t>
<t tx="ekr.20070127142841.215">def setSkin( self, notification = None, handback = None ):
    
    c = self.c 
    toskin = g.app.config.getString( c, 'type_of_skin' )
    if toskin == 'native':
        
        nlafname = swing.UIManager.getSystemLookAndFeelClassName()
        if nlafname:
            import java.lang.Class
            nlaf = java.lang.Class.forName( nlafname ).newInstance()
            swing.UIManager.setLookAndFeel( nlaf )
    elif toskin == 'synth':
        try:
            slaf = synth.SynthLookAndFeel()
            sname = g.app.config.getString( c, 'custom_skin' )
            ldir1 = io.File( g.app.loadDir )
            ldir2 = ldir1.getParent()
            ldir3 = io.File( ldir2, "skins" )
            ldir4 = io.File( ldir2, "skinimages" )
            synthfile = io.File( ldir3, sname )
            fis = io.FileInputStream( synthfile )
            import JyLeoResourceClassLoader as jlrc
            cloader = jlrc( ldir4, ldir1 )
            clazz = cloader.getFakeClass()
            slaf.load( fis, clazz )
            swing.UIManager.setLookAndFeel( slaf )
        except java.lang.Exception, x:
            x.printStackTrace()
            g.es( "Could not load custom skin" )
    else:
        swing.UIManager.setLookAndFeel( "javax.swing.plaf.metal.MetalLookAndFeel" )
        
    
                

</t>
<t tx="ekr.20070127142841.216">def addIconButton( self, *args, **kwords ):
    
    toolbar = self.toolbar2
    text = kwords[ 'text' ]
    button = swing.JButton( text )
    toolbar.add( button )
    return button
</t>
<t tx="ekr.20070127142841.217">def toggleActivePane( self ):
    
    kfm = awt.KeyboardFocusManager.getCurrentKeyboardFocusManager()
    kfm.focusNextComponent()
    
    
    
</t>
<t tx="ekr.20070127142841.218">def isMenuInitialized( self, callback ):
     
    if self.menu != None:
        callback( self.menu )
    else:
        self._menu_init_callbacks.append( callback )
        
        
def menuInitialized( self ):
    
    for z in self._menu_init_callbacks:
        z( self.menu )
    
    self._menu_init_callbacks=[]</t>
<t tx="ekr.20070127142841.219">def startReceiver( self ):
    
    import java
    self.receiver = receiver = self.Receiver( self, self.c )
    thread = java.lang.Thread( receiver )
    thread.setDaemon( True )
    thread.start()     

def hasReceiver( self ):
    
    if self.receiver:
        return True
    else:
        return False</t>
<t tx="ekr.20070127142841.220">@others
</t>
<t tx="ekr.20070127142841.221">class leoFocusTraversalPolicy( awt.FocusTraversalPolicy ):
    """This class implements the Traversale Policy for a Leo instance,
    Ctrl-T moves from widget to widget.  The Policy moves the Widgets like so:
    Editor --&gt; Tree --&gt; Log --&gt; (Back to Editor)"""
    
    def __init__( self, c ):
        awt.FocusTraversalPolicy.__init__( self )
        self.c = c
        
    @others
    
</t>
<t tx="ekr.20070127142841.222">def getComponentAfter( self, aContainer, aComponent):

    try:
        c = self.c
        if str( c.frame.tree.__class__ ) == "leoConfig.settingsTree":
            return c.frame.tree.jtree
            
        editor = c.frame.body.editor.editor
        logCtrl = c.frame.log.getCurrentTab()
        tree = c.frame.tree.jtree
        tree_editor = c.frame.tree.tcEdi.editor._jta
     
        if aComponent == editor:
            return tree
        elif aComponent == tree:
        
            return logCtrl
        
        elif aComponent == tree_editor:
            return logCtrl
        
        else:
            return editor
    except java.lang.Exception, x:
        x.printStackTrace()
        return editor  
    
</t>
<t tx="ekr.20070127142841.223">def getComponentBefore( self, aContainer, aComponent):

    logCtrl = self.c.frame.log.getCurrentTab()
    editor = self.c.frame.body.editor.editor
    tree = self.c.frame.tree.jtree
    tree_editor = self.c.frame.tree.tcEdi.editor._jta
    
    if aComponent == editor:
        return logCtrl
    elif aComponent == tree:
        return editor
        
    elif aComponent == tree_editor:
        return editor
    else:
        return tree
        
</t>
<t tx="ekr.20070127142841.224">def getDefaultComponent( self, container ):
    
    return self.c.frame.body.editor.editor
    
</t>
<t tx="ekr.20070127142841.225">def getFirstComponent( self, aContainer):
    
    return self.c.frame.body.editor.editor</t>
<t tx="ekr.20070127142841.226">def getInitialComponent( self, window):
    
    return self.c.frame.body.editor.editor
    
     

</t>
<t tx="ekr.20070127142841.227">def getLastComponent( self, aContainer):

    return self.c.frame.log.getCurrentTab()
    
</t>
<t tx="ekr.20070127142841.228">class Receiver( java.lang.Runnable ):
    '''A Class that receives UDP packets, and will bring the frame
       parameter to the front if the packet contains the open file name
       of the Commander instance passed in'''
    
    def __init__( self, frame, c ):
        self.frame = frame
        self.c = c
        
        
    def run( self ):
        
        s = java.lang.String( self.c.mFileName )
        random = java.util.Random( s.hashCode() )
        i = 0
        while i &lt;= 2000:
            i = random.nextInt( 65535 + 1 )
        
        ia = java.net.InetAddress.getByName( "127.0.0.1" )
        mcs = java.net.DatagramSocket( i , ia )
        
        import jarray
        s = java.lang.String( self.c.mFileName )
        bytes = s.getBytes()
        
        while 1:
            
            try:
                array = jarray.zeros( len( bytes ), 'b' )
                dgp = java.net.DatagramPacket( array, len( bytes ))
                dgp.setPort(i)
                dgp.setAddress( ia )
                mcs.receive( dgp )
                nexts = java.lang.String( dgp.getData() )
                
                if nexts.equals( s ):
                    self.frame.top.setVisible( True )
                    self.frame.top.setState( self.frame.top.NORMAL )
                    self.frame.top.toFront()
                    self.frame.body.editor.editor.requestFocusInWindow()
                    
                    
                    
            except java.lang.Exception, x:
                x.printStackTrace()
            </t>
<t tx="ekr.20070127142841.229">class GlassPane2( swing.JPanel ):
    
    def __init__( self ):
        swing.JPanel.__init__( self )
        self.setOpaque( False )
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, float(0.5) )
        self.image = None
        self.setLayout( None )
        
        
    def setImage( self, image ):
        self.image = image
        if image:
            self.setVisible( True )
        else: self.setVisible( False )
        
    
    def phaseIn( self, widget ):
        
        psize = widget.getPreferredSize()
        self.add( widget )
        bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
        g = bi.createGraphics()
        widget.paint( g )
        self.remove( widget )
        g.dispose()
        self.setVisible( True )
        self.Phaser( widget, bi, self )
        
    class Phaser( aevent.ActionListener ):
        def __init__( self, widget, image, parent ):
            self.widget = widget
            self.parent = parent
            self.image = image
            self.increments = 20
            self.waitperiod = 1000/self.increments
            self.timer = swing.Timer( self.waitperiod, self )
            self.timer.start()
            
        def actionPerformed( self, event ):

            alpha = 1.0/self.increments
            g = self.parent.getGraphics()
            spot = self.widget.getLocation()
            ac = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )
            g.setComposite( ac )
            g.drawImage( self.image, spot.x, spot.y, None )
            g.dispose()
            self.increments -= 1
            if self.increments == 0:
                self.timer.stop()
                self.parent.add( self.widget )
                self.parent.revalidate()
       
    def paintComponent2( self, g ):
        
        if not self.image: return
        
        composite = g.getComposite()
        mpi = awt.MouseInfo.getPointerInfo()
        location = mpi.getLocation()
        swing.SwingUtilities.convertPointFromScreen( location, self )
        g.setComposite( self.alpha )
        g.drawImage( self.image, location.x, location.y, None )
        g.setComposite( composite )
        


</t>
<t tx="ekr.20070127142841.230">import java.awt.datatransfer as dtfr
class NodeBar( dtfr.FlavorListener, java.lang.Runnable ):
    '''This class creates a toolbar that offers the user the ability to manipulate nodes
        with a button press.'''
    
    @others
    
</t>
<t tx="ekr.20070127142841.231">@
nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''
nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''
nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''
noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''
clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''
copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''
cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''
paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''
insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''
demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''
promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''
pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''
hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''
dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''
question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''
sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''
sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''
delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''
moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''
movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''
moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''
moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''
@c



</t>
<t tx="ekr.20070127142841.232">def __init__( self, c, toolbar ):
    
    self.c = c
    bcommands = ( 
                  ( c.moveOutlineUp, "nodeup.gif", 'Move Node Up', c.canMoveOutlineUp ),
                  ( c.moveOutlineDown, "nodedown.gif" , 'Move Node Down', c.canMoveOutlineDown ),
                  ( c.moveOutlineLeft, "nodeleft.gif" , 'Move Node Left' , c.canMoveOutlineLeft),
                  ( c.moveOutlineRight, "noderight.gif", 'Move Node Right', c.canMoveOutlineRight ),
                  ( c.clone, "clone.gif" , 'Clone Node', c.canClone ),
                  ( c.copyOutline, "copy.gif", 'Copy Node', 0 ),
                  ( c.cutOutline, "cut.gif", 'Cut Node', c.canCutOutline ),
                  ( c.deleteOutline, "delete.gif", 'Delete Node', c.canDeleteHeadline ),
                  ( c.pasteOutline, "paste.gif" , 'Paste Node', c.canPasteOutline ),
                  ( c.pasteOutlineRetainingClones, "pasteclone.gif", 'Paste Retaining Clones', c.canPasteOutline ),
                  ( c.insertHeadline, "insert.gif", 'Insert Node', 0 ),
                  ( c.demote, "demote.gif", 'Demote', c.canDemote ),
                  ( c.promote, "promote.gif" , 'Promote', c.canPromote ) ,
                  ( c.hoist, "hoist.gif", 'Hoist', c.canHoist),
                  ( c.dehoist, "dehoist.gif", 'De-Hoist', c.canDehoist ),
                  ( c.sortChildren, "sortchildren.gif", 'Sort Children', c.canSortChildren ),
                  ( c.sortSiblings, "sortsiblings.gif", 'Sort Siblings', c.canSortSiblings ),
                  ( c.goToPrevSibling, "moveup.gif", 'Goto Previous Sibling', self.canGotoPreviousSibling ),
                  ( c.goToNextSibling, "movedown.gif", 'Goto Next Sibling', self.canGotoNextSibling ),
                  ( c.goToParent, "moveleft.gif", 'Goto Parent', self.canGotoParent ),
                  ( self.goToChild, "moveright.gif", 'Goto Child', self.canGotoChild ),
                  )
    
    self.buttons_enabled = {}             
    for z in bcommands:
        button = self.createButton( z[ 1 ] )
        button.setToolTipText( z[ 2 ] )
        button.actionPerformed = self.getCallback( z[ 0 ] )
        if z[ 3 ]: self.buttons_enabled[ button ] = z[ 3 ]
        toolbar.add( button )
    
    wm1 = WeakMethod( self, "endUpdate" )
    leoPlugins.registerHandler( "select1", wm1 )  
    leoPlugins.registerHandler( "chapter-changed", wm1 )
    leoPlugins.registerHandler( "chapter-removed", wm1 )      
    leoPlugins.registerHandler( "hoist-executed", wm1 )
    leoPlugins.registerHandler( "dehoist-executed", wm1 )
    #--&gt; disable for now, this seems to flaky behavorialy, but the idea is good
    #tk = java.awt.Toolkit.getDefaultToolkit()
    #clipboard = tk.getSystemClipboard()
    #clipboard.addFlavorListener( self )
    self.runs = 0
    
def getCallback( self, command ):
    
    def callback(self,event =None, c= self.c):
        command()

        
    return callback

</t>
<t tx="ekr.20070127142841.233">def flavorsChanged( self, event ):
    
    #print event
    #print event.getSource()
    cb = event.getSource()
    #print cb.getName()
    #import java.awt.datatransfer as dtfr
    #print cb.getData( dtfr.DataFlavor.stringFlavor )
    #print cb.getAvailableDataFlavors()
    self.endUpdate( "flavor-change", { 'c' : self.c } )</t>
<t tx="ekr.20070127142841.234">def canGotoParent( self ):
    
    cp = self.c.currentPosition()
    if not cp: return False
    parent = cp.getParent()
    if parent:
        return True
    return False
    
    
def canGotoChild( self ):
    
    cp = self.c.currentPosition()
    if not cp: return False
    nc = cp.numberOfChildren()
    if nc != 0: return True
    return False
    
def canGotoPreviousSibling( self ):
    
    cp = self.c.currentPosition()
    if not cp: return False
    psibling = cp.moveToBack()
    if psibling:
        return True
    return False
    
def canGotoNextSibling( self ):
    
    cp = self.c.currentPosition()
    if not cp: return False
    nsibling = cp.moveToNext()
    if nsibling:
        return True
    return False</t>
<t tx="ekr.20070127142841.235">def createButton( self, name ):
    
    #bytes = java.lang.String( base64.decodestring( data ) ).getBytes()
    
    path = g.os_path_join( g.app.loadDir,"..","Icons/nodebar",name)
    ii = swing.ImageIcon( path )
    jb = swing.JButton( ii )
    #size = awt.Dimension( ii.getIconWidth(), ii.getIconHeight() )
    return jb
    
</t>
<t tx="ekr.20070127142841.236">def goToChild( self ):
        
    pos = self.c.currentPosition()
    if pos.hasChildren():
        self.c.beginUpdate()
        self.c.selectPosition( pos.nthChild( 0 ) )
        self.c.endUpdate()</t>
<t tx="ekr.20070127142841.237">def endUpdate( self, tag, *args, **kwords ):
    
    c = args[ 0 ][ 'c' ]
    #print tag
    if c == self.c:
        swing.SwingUtilities.invokeLater( self )
    else:
        print "C %s not == to %s" % ( c, self.c )


def run( self ):
    
    try:
        #print "RUN NUMBER %s" % self.runs
        self.runs += 1
        for z in self.buttons_enabled:
            button = z
            callback = self.buttons_enabled[ z ]
            #print callback
            if callback():
                button.setEnabled( 1 )
            else:
                button.setEnabled( 0 )
    except:
        print "BOOM!!"
            
</t>
<t tx="ekr.20070127142841.238">class WindowClosingWatcher( aevent.WindowAdapter ):
    
    def __init__( self, frame ):
        aevent.WindowAdapter.__init__( self )
        self.frame = frame
        
    def windowClosing( self, event ):
        
        g.app.closeLeoWindow( self.frame )
        if len( g.app.windowList ) == 0:
            java.lang.System.exit( 0 )</t>
<t tx="ekr.20070127142841.239">class LeoMetalTheme( swing.plaf.metal.DefaultMetalTheme ):
    
    def __init__( self, c ):
        
        swing.plaf.metal.DefaultMetalTheme.__init__( self )
        self.c = c
        self.p1 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        self.p3 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        self.p2 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        self.s1 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        self.s2 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        self.s3 = swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
        print self.p1, self.p2, self.p3, self.s1, self.s2, self.s3
        
    def getName( self ):
        return "LeoMetalTheme"
        
    def getControlTextFont2( self ):
        pass
    
    def getMenuTextFont2( self ):
        pass
        
    def getPrimary1( self ):
        print 'p1'
        return self.p1
        
    def getPrimary2( self ):
        print 'p2'
        return self.p2
        
    def getPrimary3( self ):
        print 'p3'
        return self.p3
        
    def getSecondary1( self ):
        print "s1"
        return self.s1
        
    def getSecondary2( self ):
        print "s2"
        return self.s2
        
    def getSecondary3( self ):
        print "s3"
        return self.s3
    
    def getBlack2( self ):
        print "BLACK"
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
    def getMenuBackground( self ):
        print "GMB"
        return self.getWhite()
    
    def getMenuForeground( self ):
        print "MFG"
        return self.getBlack()
        
    def getMenuSelectedForeground( self ):
        print "MSFG!"
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
    def getMenuSelectedBackground( self ):
        print "MSBG"
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
    
    def getPrimaryControl( self ):
        print "PCONTROL"
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
    
    def getControl( self ):
        print "CONTROL"
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
    def getControlHighlight( self ):
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
    def getPrimaryControlHighlight( self ):
        return swing.plaf.ColorUIResource( awt.Color.YELLOW )
        
    def getSystemTextColor( self ):
        return swing.plaf.ColorUIResource( awt.Color.WHITE )
       
    def getSubTextFont2( self ):
        pass
        
    def getSystemTextFont2( self ):
        pass
        
    def getUserTextFont2( self ):
        pass
        
    def getWindowTitleFont2( self ):
        pass
    
        
        </t>
<t tx="ekr.20070127142841.240">class leoSwingGui:

    @others
</t>
<t tx="ekr.20070127142841.241"></t>
<t tx="ekr.20070127142841.242">def __init__ (self):
    
    # g.trace("leoGui",guiName)
    #leoGui.leoGui.__init__( self, "swing" )
    self.leoIcon = None
    self.mGuiName = "swing"
    self.mainLoop = None
    self.root = None
    self.utils = None
    self.isNullGui = False
    self.ex = java.util.concurrent.Executors.newSingleThreadScheduledExecutor()
    self.startup_tasks = java.util.ArrayList()
    self.laflistener = self.LAFChangeListener()
    swing.UIManager.addPropertyChangeListener( self.laflistener )
</t>
<t tx="ekr.20070127142841.243">def newLeoCommanderAndFrame(self,fileName, updateRecentFiles = True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;
@
    if not splashseen:
        #self.splash = splash = swing.JWindow()
        #splash.setBackground( awt.Color.ORANGE )
        #dimension = awt.Dimension( 500, 500 )
        #splash.setPreferredSize( dimension )
        #splash.setSize( 500, 500 )
        #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
        #image = swing.JLabel( ii )
        #image.setBackground( awt.Color.ORANGE )
        #splash.add( image )
        #self.splashlabel = swing.JLabel( "BORKERS ar fUN" )
        #splash.add( self.splashlabel, awt.BorderLayout.SOUTH )
        w, h = self._calculateCenteredPosition( splash )
        splash.setLocation( w, h )
        splash.visible = True
@c
    # Create an unfinished frame to pass to the commanders.
    class Create( java.util.concurrent.Callable ):
        
        def call( self ):
            frame = g.app.gui.createLeoFrame(title)
            c = leoCommands.Commands( frame, fileName )
            frame.finishCreate( c )
            return c, frame
    
    creator = java.util.concurrent.FutureTask( Create() )
    java.awt.EventQueue.invokeAndWait( creator )
    c, frame = creator.get()
    self.c = c       
    # Create the commander and its subcommanders.
    #self.c = c = leoCommands.Commands(frame,fileName)
    
    # Finish creating the frame
    
    
    
    #frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    #c.undoer.clearUndoState() # Menus must exist at this point.
    
    #c.updateRecentFiles(fileName) # 12/01/03
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    g.doHook("after-create-leo-frame",c=c)
    return c,frame</t>
<t tx="ekr.20070127142841.244"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

</t>
<t tx="ekr.20070127142841.245"></t>
<t tx="ekr.20070127142841.246">def createRootWindow(self):

    """Create the hidden root window for the gui.
    
    Nothing needs to be done if the root window need not exist."""

    jf = swing.JFrame()
    return jf
    
    
</t>
<t tx="ekr.20070127142841.247">def destroySelf (self):

    #self.oops()
    pass</t>
<t tx="ekr.20070127142841.248">def finishCreate (self):

    """Do any remaining chores after the root window has been created."""
    #pass
    #self.c.frame.setTitle( self.c.mFileName )
    pass
    
    
</t>
<t tx="ekr.20070127142841.249">def killGui(self,exitFlag=True):

    """Destroy the gui.
    
    The entire Leo application should terminate if exitFlag is True."""

    pass</t>
<t tx="ekr.20070127142841.250">def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    pass</t>
<t tx="ekr.20070127142841.251">def runMainLoop(self):
    """Run the gui's main loop."""
    
    def rml():
        self.c.frame.tree.doneLoading()
        self.c.frame.top.visible = True
        self.c.frame.jsp1.setDividerLocation( .75 )
        self.c.frame.jsp2.setDividerLocation( .5 )
        self.c.selectPosition( self.c.currentPosition() )
        self.c.frame.body.editor.editor.setCaretPosition( 0 ) #otherwise the caret is at the end, yuck.
        dc = DefCallable( self.ex.shutdown )
        self.startup_tasks.add( dc )
        for z in self.startup_tasks:
            self.ex.submit( z )
        
        def hide():
            splash.hide()
        dc = DefCallable( hide )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )

    dc = DefCallable( rml )
    ft = dc.wrappedAsFutureTask()    
    java.awt.EventQueue.invokeLater( ft )
    </t>
<t tx="ekr.20070127142841.252">def runAboutLeoDialog(self,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    dialog = self._getDialog( "About Leo" )
    cpane = dialog.getContentPane()
    data = "%s\n%s\n\n%s\n\n%s" % ( version, theCopyright, url, email )
    jtc = swing.JTextArea()
    jtc.setText( data )
    jtc.setEditable( False )
    dialog.add( jtc )
    class cl_act( swing.AbstractAction ):
        def __init__( self, dialog ):
            swing.AbstractAction.__init__( self, "Close" )
            self.dialog = dialog
        
        def actionPerformed( self, aE ):
            self.dialog.dispose()
    button = swing.JButton( cl_act( dialog ) )
    jbp = swing.JPanel()
    jbp.add( button )
    dialog.add( jbp, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.visible = 1
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs login name is a good choice.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.") 
        
    dialog = swing.JDialog()
    dialog.title = "Create a Leo ID"
    dialog.modal = 1
    cpane = dialog.getContentPane()
    jta = swing.JTextArea()
    jta.setText( message )
    jta.editable = 0
    cpane.add( jta, awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    jp = swing.JPanel()
    jp.setBorder( sborder.TitledBorder( "Your ID:" ) )
    gbl = awt.GridBagLayout()
    jp.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx =1
    gbc.weighty = 1
    gbl.setConstraints( jtf, gbc )
    jp.add( jtf )
    cpane.add( jp, awt.BorderLayout.CENTER )
    class _OK( swing.AbstractAction ):
        def __init__( self ):
            swing.AbstractAction.__init__( self, "OK" )
            
        def actionPerformed( self, ae ):
            dialog.dispose()
    jb = swing.JButton( _OK()  )
    
    jb.setEnabled( False )
    jpanel2 = swing.JPanel()
    jpanel2.add(jb )
    cpane.add( jpanel2, awt.BorderLayout.SOUTH )
    class _Enabler( sevent.DocumentListener ):
        
        def __init__( self ):
            pass
            
        def changedUpdate( self, de ):
            pass
            
        def insertUpdate( self, de ):
            
            l = de.getDocument().getLength()
            if l &gt;= 3: jb.setEnabled( True )
            
        def removeUpdate( self, de ):
            
            l = de.getDocument().getLength()
            if l &lt;3: jb.setEnabled( False )
    jtf.getDocument().addDocumentListener( _Enabler() )       
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    splash.toBack()
    dialog.visible = 1
    g.app.leoID = jtf.getText()
    splash.toFront()

def runAskOkDialog(self,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,title,message):
    """Create and run askOkCancelNumber dialog ."""
    dialog = self._getDialog( title )
    cpane = dialog.getContentPane()
    holder = swing.JPanel()
    gbl = awt.GridBagLayout()
    holder.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx = 1
    gbc.weighty = 1
    jtf = swing.JTextField()
    gbl.setConstraints( jtf, gbc )
    holder.add( jtf )
    tborder = sborder.TitledBorder( message )
    holder.setBorder( tborder )
    cpane.add( holder )
    class _Search( swing.AbstractAction ):
        source = None
        def __init__( self, dialog, message ):
            swing.AbstractAction.__init__( self, message )
            self.dialog= dialog
            self.message = message
            
        def actionPerformed( self, ae ):
            _Search.source = ae.getSource()
            self.dialog.dispose()
    
    jb = swing.JButton( _Search( dialog, "Ok" ) )
    jb2 = swing.JButton( _Search( dialog, "Cancel" ) )
    class _Enter( aevent.ActionListener ):
        def __init__( self, ok_but ):
            self.ok_but = ok_but
            
        def actionPerformed( self, aE ):
            _Search.source = self.ok_but
            dialog.dispose()
            
    jtf.addActionListener( _Enter( jb ) )
    class _AcceptOnlyNumbers( aevent.KeyAdapter ):
        
        def __init__( self  ):
            aevent.KeyAdapter.__init__( self )
            self.consume = False
            
        def keyPressed( self, ke ):
            
            kc = ke.getKeyCode()
            if kc in ( ke.VK_ENTER, ke.VK_BACK_SPACE ): return
            c = ke.getKeyChar()
            if not java.lang.Character.isDigit( c ):
                self.consume = True 
                ke.consume()
            
        def keyReleased( self, ke ):
            if self.consume:
                self.consume = False
                ke.consume()
                
        def keyTyped( self, ke ):
            if self.consume:
                ke.consume()
            
    jtf.addKeyListener( _AcceptOnlyNumbers() )
    bottom = swing.JPanel()
    bottom.add( jb, awt.BorderLayout.WEST )
    bottom.add( jb2, awt.BorderLayout.EAST )
    cpane.add( bottom, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if _Search.source is jb:
        return int( jtf.getText() )
    else:
        return -1

def runAskYesNoDialog(self,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""

    dialog = self._getDialog( title )
    class yno( swing.AbstractAction ):
        
        source = None
        def __init__( self, dialog, name ):
            swing.AbstractAction.__init__( self, name )
            self.dialog = dialog
            
        def actionPerformed( self, aE ):
            yno.source = aE.getSource()
            self.dialog.dispose()
            
    cpane = dialog.getContentPane()
    cpane.add( swing.JLabel( message ), awt.BorderLayout.NORTH )
    jp = swing.JPanel()
    cpane.add( jp, awt.BorderLayout.SOUTH )
    
    yes = swing.JButton( yno( dialog, yesMessage ) )
    no = swing.JButton( yno( dialog, noMessage ) )
    cancel = swing.JButton( yno( dialog, "Cancel" ) )
    jp.add( yes )
    jp.add( no )
    jp.add( cancel )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if yno.source is yes:
        return 'yes'
    elif yno.source is no:
        return 'no'
    elif yno.source is cancel:
        return "cancel"
    else:
        if defaultButton == 'Yes': return 'yes'
        else: return 'cancel'
        
def _getDialog( self, title ):
    
    jdialog = swing.JDialog( self.c.frame.top, title, True )
    jdialog.getContentPane().setName( "Leodialog" )
    return jdialog
    
def _getScreenPositionForDialog( self ):

    #tk = self.c.frame.top.getToolkit()
    tk = awt.Toolkit.getDefaultToolkit()
    dim = tk.getScreenSize()
    h = dim.height/2
    w = dim.width/2
    return h, w
    
def _calculateCenteredPosition( self, widget ):

    size = widget.getPreferredSize()
    height = size.height/2
    width = size.width/2
    h,w = self._getScreenPositionForDialog()
    height = h - height
    width = w - width
    return width, height

    
        
    </t>
<t tx="ekr.20070127142841.253">class FileTypesFilter( swing.filechooser.FileFilter ):
    def __init__( self, filetypes ):
        swing.filechooser.FileFilter.__init__( self )
        self.filetypes = filetypes
        
    def accept( self, fvar ):
        name = fvar.getName()
        ftype = self.filetypes[ 1 ]
        ftype = ftype.strip( "*" )
        if name.endswith( ftype ): return True
        return False
    
    def getDescription( self ):
        return self.filetypes[ 0 ]


def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    import os
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showOpenDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if multiple:
            st = ( st , )
        return st
    

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""
    import os
    #self.oops()
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showSaveDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if not st.endswith( defaultextension ):
            st = st + defaultextension
        return st</t>
<t tx="ekr.20070127142841.254">def createColorPanel(self,c):
    """Create Color panel."""
    self.oops()
    
def createComparePanel(self,c):
    """Create Compare panel."""
    import leoSwingComparePanel
    return leoSwingComparePanel.leoSwingComparePanel( c )
    
    
def createFindPanel(self):
    """Create a hidden Find panel."""
    self.oops()

def createFontPanel(self,c):
    """Create a Font panel."""
    self.oops()
    
def createLeoFrame(self,title):
    """Create a new Leo frame."""
    import leoSwingFrame
    lsf = leoSwingFrame.leoSwingFrame( self )
    return lsf
    
def createPrefsPanel(self,c):
    """Create a Prefs panel."""
    return swing.JFrame()
</t>
<t tx="ekr.20070127142841.255">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.</t>
<t tx="ekr.20070127142841.256">class cBoardOwner( dtfr.ClipboardOwner ):


    def lostOwnership( self, clipboard, contents ):
        pass
        
        

class LeoTransferable( dtfr.Transferable ): 
    '''This class exists primarily so that the system can detect when a valid
       leoxml tree has been placed in the system clipboard.  It enables the enabling/disabling
       of "paste node"'''
    def __init__( self, data, dataflavor ):
        
        self.data = data
        self.dataflavors = [ dtfr.DataFlavor.stringFlavor ]
        if dataflavor:
            self.dataflavors.append( dtfr.DataFlavor( dataflavor ) )
        self.dataflavor = dataflavor
    
    def getTransferData( self, dflavor ):
        
        if dflavor.getRepresentationClass() == java.lang.String:
            return java.lang.String( self.data )
        elif dflavor.getRepresentationClass() == java.io.InputStream:
            ba = java.lang.String( self.data ).getBytes()
            return java.io.ByteArrayInputStream( ba )
    
    def getTransferDataFlavors( self ):
        return self.dataflavors 
        
    def isDataFlavorSupported( self, flavor ):
        
        if flavor == dtfr.DataFlavor.stringFlavor: return True
        elif str( flavor.getMimeType() ) == self.dataflavor: return True
        return False    


def replaceClipboardWith (self,s, dflavor = None):
    
    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    cBO = self.cBoardOwner()
    #ss = dtfr.StringSelection( s )
    ss = self.LeoTransferable( s, dflavor )
    cp.setContents( ss, cBO )
    

def getTextFromClipboard (self):
    
    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    contents = cp.getContents( self )
    dflavor = dtfr.DataFlavor.selectBestTextFlavor( contents.getTransferDataFlavors() )
    if not dflavor:
        return None
    reader = dflavor.getReaderForText( contents )
    breader = java.io.BufferedReader( reader )
    txt = []
    try:
        while 1:
            stxt = breader.readLine()
            if stxt != None:
                txt.append( stxt )
            else:
                return '\n'.join( txt )
    except:
        return '\n'.join( txt )


    
    
</t>
<t tx="ekr.20070127142841.257">def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""
    
    sicon = g.os_path_join( g.app.loadDir,"..","Icons","Leoapp.GIF")
    #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
    ii = swing.ImageIcon( sicon )
    window.setIconImage( ii.getImage() )
    
def center_dialog(self,dialog):
    """Center a dialog."""
    spot = self._calculateCenteredPosition( dialog )
    dialog.setLocation( spot[ 0 ], spot[ 1 ] )
        
def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""
    
    w = swing.JPanel()
    parent.add( w )
    if caption:
        border = w.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( caption )
        w.setBorder( tborder )
    
    sl = swing.SpringLayout()
    w.setLayout( sl )
    f = swing.JPanel()
    w.add( f )
    sl.putConstraint( sl.NORTH, f, 5, sl.NORTH, w )
    sl.putConstraint( sl.WEST, f, 5, sl.WEST, w )
    sl.putConstraint( sl.SOUTH, w, 5, sl.SOUTH, f )
    sl.putConstraint( sl.EAST, w, 5, sl.EAST, f )
    
    return w, f
    
    
def get_window_info (self,window):
    """Return the window information."""
    self.oops()

</t>
<t tx="ekr.20070127142841.258">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    pass
    # self.oops()</t>
<t tx="ekr.20070127142841.259">def get_focus(self,frame):

    """Return the widget that has focus, or the body widget if None."""

    self.oops()
        
def set_focus(self,commander,widget):

    """Set the focus of the widget in the given commander if it needs to be changed."""

    widget.requestFocusInWindow()</t>
<t tx="ekr.20070127142841.260">def firstIndex (self):

    self.oops()
    
def lastIndex (self):

    self.oops()
    
def moveIndexForward(self,t,index,n):

    self.oops()
    
def moveIndexToNextLine(self,t,index):

    self.oops()</t>
<t tx="ekr.20070127142841.261">def setIdleTimeHook (self,idleTimeHookHandler,*args,**keys):
    
    pass # Not an error.
    
def setIdleTimeHookAfterDelay (self,delay,idleTimeHookHandler,*args,**keys):
    
   pass # Not an error.
</t>
<t tx="ekr.20070127142841.262">def guiName(self):
    
    try:
        return self.mGuiName
    except:
        return "invalid gui name"</t>
<t tx="ekr.20070127142841.263">def oops (self):
    
    print "leoGui oops", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20070127142841.264">def getInsertPoint( self, t ):
    
    return t.getCaretPosition()
    
    
def setInsertPoint( self, t, pos ):
    #pass
    #return t.setCaretPosition( pos )
    t.setCaretPosition( pos )
    
def getSelectionRange( self, t ):
    
    s = t.getSelectedText()
    s = "%s" % s
    return s
    
def setTextSelection( self, t, start, end ):
    
    t.setSelectionStart( start )
    t.setSelectionEnd( end )
    
def setSelectionRange(  self, t, n1, n2 ):
    return g.app.gui.setTextSelection( t, n1, n2 )
    
    
def getTextSelection( self, t ):
    
    
    return ( t.getSelectionStart(), t.getSelectionEnd() )</t>
<t tx="ekr.20070127142841.265">def makeIndexVisible(self,t,index):

    print t
    print index
    #return t.see(index) </t>
<t tx="ekr.20070127142841.266">def moveIndexForward(self,t,index,n):
    
    t = self.c.frame.body.editor.editor 
    #print index
    #print n
    #print t
    t.setCaretPosition( index[ 1 ] )
    #newpos = t.index("%s+%dc" % (index,n))
    if len( t.getText() ) &lt;= ( index[ 1 ] ): return None
    else:
        return index[ 1 ]
    #return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):
    pass
    #newpos = t.index("%s linestart + 1lines" % (index))
    
    #return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20070127142841.267">def addStartupTask( self, task ):
    '''Adds a task to the collection of tasks that are
       executed upon startup'''
    
    self.startup_tasks.add( task )
    </t>
<t tx="ekr.20070127142841.268">def getFontFromParams( self, family,size,slant,weight):
    
    #print family, size, slant, weight
    
    if size in ( 'None', None ):
        size = 12
    else:
        size = int( size )
        
    if weight in ( 'None', None):
        weight = awt.Font.PLAIN
    else:
        weight = weight
        weights = weight.split( "and" )
        nweight = None
        for z in weights:
            z = z.strip()
            #print z
            if not hasattr( awt.Font, z ): continue
            w2 = getattr( awt.Font, z )
            if nweight:
                nweight = nweight|w2
            else:
                nweight = w2
        weight = nweight
        
    if family in ( 'None', None ):
        family = 'Helvetica'
    else:
        #family = family[ 1 ]
        pass
        
    #print family, size, slant, weight    
    f = awt.Font( family, weight, size )
    return f    
    
</t>
<t tx="ekr.20070127142841.269">@others
</t>
<t tx="ekr.20070127142841.270">def addLAFListener( self, component ):
    self.laflistener.addComponent( component )
    
</t>
<t tx="ekr.20070127142841.271">class LAFChangeListener( java.beans.PropertyChangeListener ):
    
    def __init__( self ):
        self.changers = []
        
    
    def addComponent( self, component ):
        ref = java.lang.ref.WeakReference( component )
        self.changers.append( ref )
        
    def propertyChange( self, event ):
        if event.getPropertyName() == 'lookAndFeel':
            for z in self.changers:
                component = z.get()
                if component:
                    swing.SwingUtilities.updateComponentTreeUI( component )</t>
<t tx="ekr.20070127142841.272">@others
</t>
<t tx="ekr.20070127142841.273">def replaceSelectionRangeWithText( self, t, start, end, change ):
    

    if t:
        doc = t.getDocument()
        doc.replace( start, end - start, change, None )
    

</t>
<t tx="ekr.20070127142841.274">def setSelectionRangeWithLength( self, t, start, length ):
    
    
    if t:
        t.setSelectionStart( start )
        t.setSelectionEnd( start + length )
</t>
<t tx="ekr.20070127142841.275">def compareIndices( self, st, pos, which, pos2 ):
    
    if which == '&gt;':
        
        return int( pos ) &gt; int( pos2 )
        
    elif which == '&lt;':
        
        return int( pos ) &lt; int( pos2 )
    
</t>
<t tx="ekr.20070127142841.276">def getAllText( self,st ):
    
    print st
    doc = st.getDocument()
    return doc.getText( 0, doc.getLength() )</t>
<t tx="ekr.20070127142841.277">class leoSwingLog:
    
    @others</t>
<t tx="ekr.20070127142841.278">def __init__ (self,frame,parentFrame):
    
    self._font = None
    self.jta = None
    #leoFrame.leoLog.__init__( self, frame, parentFrame )
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()
    
    #self.c = frame.c
    self._font = None
    
    manager = g.app.config.manager
    for z in ( "log_pane_background_color", "log_text_foreground_color", "log_text_background_color" ):
        manager.addNotificationDef( z, self.setColorFromConfig )
    for z in ( "log_text_font_family", "log_text_font_size" ,  "log_text_font_weight" ):
        manager.addNotificationDef( z, self.setFontFromConfig )


</t>
<t tx="ekr.20070127142841.279">def configure (self,*args,**keys):
    
    self.oops()</t>
<t tx="ekr.20070127142841.280">def configureBorder(self,border):
    
    self.oops()
</t>
<t tx="ekr.20070127142841.281">def createControl (self,parentFrame):
    
    self.tab_manager = TabManager( switch_on_add = 0 )
    self.tab_manager.tabsToBottom()
    self._jtp = jtp = self.tab_manager.base
            
    self.logCtrl = logCtrl = self.jta = self.LogControl()
    self.logCtrl.setFocusable( True );
    logCtrl.setName( "Log" )
    import utilities.CutCopyPaste as CCP
    CCP.CutCopyPaste( logCtrl )
    self.setColorFromConfig()
    
    if self._font:
        logCtrl.setFont( self._font )
    self.jsp = swing.JScrollPane( logCtrl )

    self.tab_manager.add( "Log", self.jsp )
    logCtrl.addFocusListener( leoJSPFocusListener( self.jsp, self.c ) )
    parentFrame.rightComponent = jtp
    self.setBackgroundImage()
    g.doHook( "leoswinglogcreated", c = self.c, log = self )
    



</t>
<t tx="ekr.20070127142841.282">def enable (self,enabled=True):
    
    self.enabled = enabled
    
def disable (self):
    
    self.enabled = False
</t>
<t tx="ekr.20070127142841.283">def oops (self):
    
    print "leoLog oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20070127142841.284">def setFontFromConfig (self, notification = None, handback = None):
    
    logCtrl = self.jta ; config = g.app.config

    font = config.getFontFromParams( self.c,
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        config.defaultLogFontSize)
    
    if font:
        #awt_font = awt.Font.decode( font )
        self._font = font
        if logCtrl:
            logCtrl.setFont( font )

          

        

</t>
<t tx="ekr.20070127142841.285">def onActivateLog (self,event=None):

    try:
        g.app.setLog(self,"OnActivateLog")
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20070127142841.286"># All output to the log stream eventually comes here.

def put (self,s,color=None):
    
    if self.jta:
        pos = self.jta.getCaretPosition()
        document = self.jta.getStyledDocument()
        attrset = None

        if color:
            if hasattr( awt.Color, color ):
                attrcolor = getattr( awt.Color, color )
                attrset = stext.SimpleAttributeSet()
                stext.StyleConstants.setForeground( attrset, attrcolor  )
        
        document.insertString( document.getLength(), s, attrset )
        npos = document.getLength() - len( s )
        self.jta.setCaretPosition( npos )
    else:
        g.app.logWaiting.append( ( s , color ) )
    
    if leoSwingGui.splash.isVisible():
        leoSwingGui.splash.setText( s )


def putnl (self):

    if self.jta:
        doc = self.jta.getStyledDocument()
        doc.insertString( doc.getLength(), "\n", None )
    else:
        g.app.logWaiting.append( '\n' )

    

    
    </t>
<t tx="ekr.20070127142841.287">class LogControl( swing.JTextPane ):
    
    def __init__( self, *args ):
        swing.JTextPane.__init__( self, *args )
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 )
        self.lastDimensions = awt.Rectangle( 0,0,0,0 )
        self.image = None
        self.last_image= None
        
        
    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )
        
    
    def setImage( self, image ):
        self.image = image
        
        
    def paintComponent( self, graphics ):
        
        #self.super__paintComponent( graphics )
        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )
            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite )       
        self.super__paintComponent( graphics )
        
        </t>
<t tx="ekr.20070127142841.288">def setBackgroundImage( self, notification = None, handback = None ):
    
    c = self.c
    

    use_background = g.app.config.getBool( c, "log_use_background_image" )    
    if not use_background:
        return
        
    alpha = g.app.config.getFloat( c, "log_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "log_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            #if not hasattr( self, 'background' ): 
            #self.background = EditorBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #self.logBackPane.add( self.background )
            #self.jsp.getViewport().addChangeListener( self.resizer( self.jsp, self.logBackPane ) )
            #self._vport.addChangeListener( self._resizer )
            #self.editor.setOpaque( False )
            #self.jtree.setOpaque( False )
            #self.jpanel.setOpaque( False )
            #self.jspane.setOpaque( False )
            #self.jspane.getViewport().setOpaque( False )
            #self.logCtrl.setOpaque( False )
            #self.jsp.getViewport().setOpaque( False )
            #self.jsp.setOpaque( False )
            self.logCtrl.setOpaque( False )
            self.logCtrl.setImage( bimage )
            self.logCtrl.setAlpha( alpha )
            g.app.config.manager.addNotificationDef( "log_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "log_image_location@as-filedialog", self.setBackgroundImage )
                  
            #else:
            #    self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    self.background.repaint()



</t>
<t tx="ekr.20070127142841.289">def setColorFromConfig( self, notification = None, handback = None ):
    
    logCtrl = self.jta
    if logCtrl:
        color = g.app.config.getColor( self.c , "log_pane_background_color" )
        logCtrl.setBackground( getColorInstance( color, awt.Color.WHITE ) )
        color = g.app.config.getColor( self.c, "log_text_foreground_color" )
        logCtrl.setForeground( getColorInstance( color, awt.Color.GRAY ) ) 
        color = g.app.config.getColor( self.c, "log_text_background_color" )
        logCtrl.setSelectionColor( getColorInstance( color, awt.Color.GREEN ) )

</t>
<t tx="ekr.20070127142841.290">def addTab( self, name, component ):
    
    self.tab_manager.add( name, component )
    

def selectTab( self, component ):
    self.tab_manager.select( component )
   
def removeTab( self, component ):
    
    self.tab_manager.remove( component )
    

def getCurrentTab( self ):
    
    ctab = self.tab_manager.getCurrentTab()
    if ctab is None:
        return self.jta
    else:
        size = ctab.getSize()
        x = size.width/2
        y = size.height/2
        component = swing.SwingUtilities.getDeepestComponentAt( ctab, x, y )
        return component
</t>
<t tx="ekr.20070127142841.291">class leoSwingMenu( leoMenu.leoMenu ):


    @others</t>
<t tx="ekr.20070127142841.292">def __init__ (self,frame):
    
    ld = io.File( g.app.loadDir )
    ijcl.addToSearchPath( ld )
    ijcl.beginLoading()
    self.font = frame.top.getFont()
    self.executor = java.util.concurrent.Executors.newCachedThreadPool()
    self.queue = java.util.concurrent.LinkedBlockingQueue()
    self.menu_changer = self.MenuChanger( self.queue )
    self.names_and_commands = {}
    self.keystrokes_and_actions = {}
    leoMenu.leoMenu.__init__( self, frame )
    #self.createLeoSwingPrint()
    #self.defineLeoSwingPrintTable()
    #self.addCommanderSupplemental()
    
    

    
    



</t>
<t tx="ekr.20070127142841.293">class MenuChanger( java.lang.Runnable, java.util.concurrent.Callable ):
    
    def __init__( self, queue ):
        self.queue = queue
        
    def run( self ):
        
        ft = java.util.concurrent.FutureTask( self )
        java.awt.EventQueue.invokeLater( ft )
        
    
    def call( self ):
        
        menu , name , label, enabled = self.queue.take() 
        target = None
        for z in menu.getMenuComponents():
            if hasattr( z, "getText" ) and z.getText() == name:
                target = z
                break
        
        
        if target:
            target.setText( label )
            target.setEnabled( enabled )
        </t>
<t tx="ekr.20070127142841.294">
</t>
<t tx="ekr.20070127142841.295">def defineLeoSwingPrintTable( self ):
    
    self.printNodeTable= (
    
    ( "Print Current Node" , None, lambda event: self.lsp.printNode() ),
    ( "Print Current Node as HTML", None, lambda event: self.lsp.printNode( type = "HTML" ) ),
    ( "Print Marked Nodes", None, lambda event:  self.lsp.printMarkedNodes() ),
    ( "Print Marked Nodes as HTML", None, lambda event: self.lsp.printNode( type ="HTML" ) ),
    
    )
    
    for z in self.printNodeTable:
        self.names_and_commands[ z[ 0 ] ] = z[ 2 ]
    </t>
<t tx="ekr.20070127142841.296">def createLeoSwingPrintMenu( self ):
    
    fmenu = self.getMenu( "File" )
    
    components = fmenu.getMenuComponents()
    
    x = 0
    for z in components:
        
        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1
        
    
    spot = x + 1
    
    pmenu = swing.JMenu( "Printing" )
    
    pnodes = swing.JMenu( "Print Nodes" )
    pmenu.add( pnodes )
    for z in self.printNodeTable:
        item = swing.JMenuItem( z[ 0 ] )
        item.actionPerformed = z[ 2 ]
        pnodes.add( item )
        
    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( pmenu, spot + 1 )
    
    print_tree = swing.JMenuItem( "Print Tree As Is" )
    print_tree.actionPerformed = self.lsp.printTreeAsIs
    pmenu.add( print_tree )
    self.names_and_commands[ "Print Tree As Is" ] = self.lsp.printTreeAsIs
    print_as_more = swing.JMenuItem( "Print Outline in More Format" )
    print_as_more.actionPerformed = self.lsp.printOutlineAsMore
    self.names_and_commands[ "Print Outline in More Formet" ] = self.lsp.printOutlineAsMore
    pmenu.add( print_as_more )
    
    
    
    
    

           

    


</t>
<t tx="ekr.20070127142841.297">def createLeoSwingPrint( self ):
    
    c = self.c
    import leoSwingPrint
    lsp = leoSwingPrint.leoSwingPrint( c )
    menu = lsp.getAsMenu()
    
    fmenu = self.getMenu( "File" )
    
    components = fmenu.getMenuComponents()
    
    x = 0
    for z in components:
        
        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1
        
    
    spot = x + 1
    
        
    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( menu, spot + 1 )
    

</t>
<t tx="ekr.20070127142841.298"></t>
<t tx="ekr.20070127142841.299">def createPluginMenu( self ):
    
    top = self.getMenu( 'top' )
    oline = self.getMenu( 'Outline' )
    ind = top.getComponentIndex( oline ) + 1
    import leoSwingPluginManager
    self.plugin_menu = pmenu = leoSwingPluginManager.createPluginsMenu()
    #self.plugin_menu = pmenu = swing.JMenu( "Plugins" )
    top.add( pmenu, ind )
    #cpm = swing.JMenuItem( "Plugin Manager" )
    #cpm.actionPerformed = self.createPluginManager
    #pmenu.add( cpm )
    #pmenu.addSeparator()
    
    
    #self.names_and_commands[ "Plugin Manager" ] = self.createPluginManager
    

</t>
<t tx="ekr.20070127142841.300">def createPluginManager( self, event ):
    
    import leoSwingPluginManager as lspm
    lspm.topLevelMenu()
    
</t>
<t tx="ekr.20070127142841.301">def getPluginMenu( self ):
    
    return self.plugin_menu
</t>
<t tx="ekr.20070127142841.302">
</t>
<t tx="ekr.20070127142841.303">def openJythonShell( self ):
    
    js = ijcl.getJythonShell()
    jd = js.getDelegate()
    config = g.app.config
    c = self.c
    
    import leoSwingFrame
    getColorInstance = leoSwingFrame.getColorInstance 
    
    colorconfig = js.getColorConfiguration()
    color = config.getColor( c, "jyshell_background" )
    colorconfig.setBackgroundColor( getColorInstance( color, awt.Color.WHITE ) )
    
    color = config.getColor( c, "jyshell_foreground" )
    colorconfig.setForegroundColor( getColorInstance( color, awt.Color.GRAY ) )
    
    color = config.getColor( c, "jyshell_keyword" )
    colorconfig.setKeywordColor( getColorInstance( color, awt.Color.GREEN ) )
    
    color = config.getColor( c, "jyshell_local" )
    colorconfig.setLocalColor( getColorInstance( color, awt.Color.ORANGE ) )
    
    color = config.getColor( c, "jyshell_ps1color" )
    colorconfig.setPromptOneColor( getColorInstance( color, awt.Color.BLUE ) )
    
    color = config.getColor( c, "jyshell_ps2color" )
    colorconfig.setPromptTwoColor( getColorInstance( color, awt.Color.GREEN ) )
    
    color = config.getColor( c, "jyshell_syntax" )
    colorconfig.setSyntaxColor( getColorInstance( color, awt.Color.RED ) )
    
    color = config.getColor( c, "jyshell_output" )
    colorconfig.setOutColor( getColorInstance( color, awt.Color.GRAY ) )
    
    color = config.getColor( c, "jyshell_error" )
    colorconfig.setErrColor( getColorInstance( color, awt.Color.RED ) )
    
    family = config.get( c, "jyshell_text_font_family", "family" )
    size = config.get( c, "jyshell_text_font_size", "size" )
    weight = config.get( c, "jyshell_text_font_weight", "weight" )
    slant = None
    font = config.getFontFromParams( c, "jyshell_text_font_family", "jyshell_text_font_size", None, "jyshell_text_font_weight")
    
    use_bgimage = g.app.config.getBool( c, "jyshell_background_image" )
    if use_bgimage:
        
        image_location = g.app.config.getString( c, "jyshell_image_location@as-filedialog" )
        test_if_exists = java.io.File( image_location )
        if test_if_exists.exists():
            ii = swing.ImageIcon( image_location )
            alpha = g.app.config.getFloat( c, "jyshell_background_alpha" )
            js.setBackgroundImage( ii.getImage(), float( alpha ) )
        
    if font:
        js.setFont( font )
        
    js.setVisible( True )
    widget = js.getWidget()
    log = self.c.frame.log    
    self.addMenuToJythonShell( js )
    log.addTab( "JythonShell", widget )
    log.selectTab( widget )
    
    
</t>
<t tx="ekr.20070127142841.304">def addMenuToJythonShell( self, js ):
    
    c = self.c
    jd = js.getDelegate()
    jmenu = swing.JMenu( "Leo" )
    jd.addToMenu( jmenu )
    
    e = swing.JMenuItem( "Execute Node As Script" )  
    e.actionPerformed = lambda event, jd = jd: self.fireNodeAsScript( event, jd )
    jmenu.add( e )
    
    p = swing.JMenuItem( "Run Node in Pdb" )
    p.actionPerformed = self.getRunNodeInPdb( c, jd )
    jmenu.add( p )
    
    captext = "Capture Shell Input In Node"
    totext = "Turn Off Shell Input Capture"
    sc = swing.JMenuItem( captext )
    import org.leo.JTextComponentOutputStream as jtcos
    class logcontrol:
        def __init__( self, menu ):
            self.menu = menu
            self.loging = False
            self.ostream = jtcos( c.frame.body.editor.editor )
            
        def __call__( self, event ):  
            menu = self.menu
            loging = self.loging
            if not loging:
                js.addLogger( self.ostream )
                menu.setText( totext )
                self.loging = True
            else:
                js.removeLogger( self.ostream )
                menu.setText( captext )
                self.loging = False
            
    sc.actionPerformed = logcontrol( sc )           
    jmenu.add( sc )
    
    d = swing.JMenuItem( "Detach Shell" )
    class detacher( java.util.concurrent.Callable ):
        
        def __init__( self, menu ):
            self.menu = menu
            self.embeded = True
            js.setCloser( self )
        
        def call( self ):
            
            if self.embeded:
                log = c.frame.log
                widget = js.getWidget()
                log.removeTab( widget )
            else:
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();
          
        def __call__( self, event ):
            d = self.menu
            text = d.getText()
            if( text == "Detach Shell" ):
                d.setText( "Retach Shell" )
                jf = swing.JFrame( "JythonShell" )
                widget = js.getWidget()
                log = c.frame.log 
                log.removeTab( widget )
                jf.add( widget )
                jf.setSize( 500, 500 )
                jf.visible = 1
                self.embeded = False
            else:
                d.setText( "Detach Shell" )
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();
                log = c.frame.log
                log.addTab( "JythonShell", widget  )
                log.selectTab( widget ) 
                self.embeded = True
                     
    d.actionPerformed = detacher( d )
    jmenu.add( d )    
    
    
    </t>
<t tx="ekr.20070127142841.305">def getInsertNodeIntoShell( self, c, jd ):
    
    jm = swing.JMenuItem( "Write Node Into Shell as Reference" )
    def writeNode( event ):
        
        cp = c.currentPosition()
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
        
        jtf = self._GetReferenceName( jd, data )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()
        
        
    
    jm.actionPerformed = writeNode
    return jm
</t>
<t tx="ekr.20070127142841.306">def getInsertReferenceIntoLeo( self, jd ):
    
    jmi = swing.JMenuItem( "Insert Reference As Node" )
    
    def action( event ):
        
        jtf = self._GetReferenceAsObject( jd, self.c )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()

    jmi.actionPerformed = action
    return jmi</t>
<t tx="ekr.20070127142841.307">def getRunNodeInPdb( self, c, jd ):
    
    def runInPdb( event ):
        
        cp = c.currentPosition()
        name = cp.headString()
        name = name.split()[ 0 ]
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
                
        f = java.io.File.createTempFile( "leopdbrun", None )
        pw = java.io.PrintWriter( f )
        pw.println( "import pdb" )
        pw.println( "pdb.set_trace()" )
        for z in data.split( "\n" ):
            pw.println( z )            
        pw.close()
        f.deleteOnExit()       
        l = java.util.Vector()
        l.add( "execfile( '%s', globals(), locals())" % f.getAbsolutePath() )
        jd.processAsScript( l )
        

    return runInPdb      
</t>
<t tx="ekr.20070127142841.308">def fireNodeAsScript( self, event, jd ):

    c = self.c        
    cp = c.currentPosition()    
    at = c.atFileCommands 
    c.fileCommands.assignFileIndices()
    at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
    data = at.stringOutput.split( '\n' ) 


    l = java.util.Vector()
    for z in data:
        l.add( java.lang.String( z ) )
            
    jd.processAsScript( l )</t>
<t tx="ekr.20070127142841.309">class _GetReferenceName( swing.JTextField, aevent.KeyListener ):
    
    
    def __init__( self, jd, data ):
        swing.JTextField.__init__( self )
        self.jd = jd
        self.data = data
        border = self.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( "Choose Reference Name:" )
        self.setBorder( tborder )
        self.addKeyListener( self )
        self.rmv_spot = None
    
    def keyPressed( self, event ):
        
        kc = event.getKeyChar();
        if kc == '\n':
            self.execute()
        elif java.lang.Character.isWhitespace( kc ):
            event.consume
            
    def execute( self ):
        
        self.jd.setReference( self.getText(), self.data )
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot)
        self.jd.requestFocusInWindow()
        
    def keyTyped( self, event ):
        
        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()
        
    def keyReleased( self, event ):
        
        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()
            
            
class _GetReferenceAsObject( _GetReferenceName ):
    
    def __init__( self, jd, c ):
        leoSwingMenu._GetReferenceName.__init__( self, jd, None )
        self.c = c
        border = self.getBorder()
        border.setTitle( "Which Reference To Insert:" )
        
        
    def execute( self ):
        
        ref = self.jd.getReference( self.getText() )
        if ref:
            self.c.beginUpdate()
            pos = self.c.currentPosition()
            npos = pos.insertAfter()
            npos.setHeadString( "Reference: %s" % self.getText() )
            npos.setTnodeText( str( ref ) )
            self.c.endUpdate()
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot )
                  </t>
<t tx="ekr.20070127142841.310">def addUserGuide( self ):
    
    help = self.getMenu( 'Help' )
    c = self.c
    help.addSeparator()
    jmi = swing.JCheckBoxMenuItem( "View User Guide" )
    widgets = []
    def showUserGuide( event ):
        if jmi.getState() and not widgets:
            import leoSwingLeoTutorial
            lswlt = leoSwingLeoTutorial.leoSwingLeoTutorial()
            widget = lswlt.getWidget()
            widgets.append( widget )
            c.frame.body.addTab( "User Guide", widget )
        elif jmi.getState() and widgets:
            widget = widgets[ 0 ]
            c.frame.body.addTab( "User Guide", widget )
        else:
            widget = widgets[ 0 ]
            c.frame.body.removeTab( widget )
        
    
    jmi.actionPerformed = showUserGuide
    help.add( jmi )
</t>
<t tx="ekr.20070127142841.311">def createRecentFilesMenuItems (self):
    
    c = self.c ; frame = c.frame
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    if len( recentFilesMenu.getMenuComponents() ) != 0:
        deferable = lambda :self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
        if not swing.SwingUtilities.isEventDispatchThread():
            dc = DefCallable( deferable )
            ft = dc.wrappedAsFutureTask()
            swing.SwingUtilities.invokeAndWait( ft )
        else:
            deferable()
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name): # 12/9/03
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1</t>
<t tx="ekr.20070127142841.312">def oops (self):

    print "leoMenu oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20070127142841.313"></t>
<t tx="ekr.20070127142841.314">def add_cascade (self,parent,label,menu,underline):
    
    menu.setText( label )
    
def add_command (self,menu,**keys):
    
    if keys[ 'label' ] == "Open Python Window":
        keys[ 'command' ] = self.openJythonShell
    
    self.names_and_commands[ keys[ 'label' ] ] = keys[ 'command' ]
              
    action = self.MenuRunnable( keys[ 'label' ], keys[ 'command' ], self.c, self.executor )
    jmenu = swing.JMenuItem( action )
    if keys.has_key( 'accelerator' ) and keys[ 'accelerator' ]:
        accel = keys[ 'accelerator' ]
        acc_list = accel.split( '+' )
        changeTo = { 'Alt': 'alt', 'Shift':'shift', #translation table
                     'Ctrl':'ctrl', 'UpArrow':'UP', 'DnArrow':'DOWN',
                     '-':'MINUS', '+':'PLUS', '=':'EQUALS',
                     '[':'typed [', ']':'typed ]', '{':'typed {',
                     '}':'typed }', 'Esc':'ESCAPE', '.':'typed .',
                      "`":"typed `", "BkSp":"BACK_SPACE"} #SEE java.awt.event.KeyEvent for further translations
        chg_list = []
        for z in acc_list:
            if z in changeTo:
                chg_list.append( changeTo[ z ] )
            else:
                chg_list.append( z )
        accelerator = " ".join( chg_list )
        ks = swing.KeyStroke.getKeyStroke( accelerator )
        if ks:
            self.keystrokes_and_actions[ ks ] = action
            jmenu.setAccelerator( ks )
        else:
            pass
    menu.add( jmenu )
    label = keys[ 'label' ]
    return jmenu
    
def add_separator(self,menu):
    menu.addSeparator()
    
def bind (self,bind_shortcut,callback):
    #self.oops() 
    pass

def delete (self,menu,realItemName):
    self.oops()
    
def delete_range (self,menu,n1,n2):


    items = menu.getMenuComponents()
    n3 = n1
    components = []
    while 1:
        if n3 == n2:
            break
        item = menu.getMenuComponent( n3 )
        components.append( item )
        n3 += 1
    
    for z in components:
        menu.remove( z )
        

def destroy (self,menu):
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0):
    jm = swing.JMenu( "1" )
    #jm = self.LeoMenu( "1" )
    parent.add( jm )
    #jm.setFont( self.font)
    return jm</t>
<t tx="ekr.20070127142841.315">def createMenuBar (self,frame):

    top = frame.top
    self.defineMenuTables()
    topMenu = swing.JMenuBar()
    top.setJMenuBar( topMenu )
    topMenu.setFont( self.font )
    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()
    self.createLeoSwingPrint()
    self.createPluginMenu()
    self.addUserGuide()
    
def createOpenWithMenuFromTable (self,table):
    self.oops()

def defineMenuCallback(self,command,name):
    return command
    
def defineOpenWithMenuCallback(self,command):
    self.oops()
    
def disableMenu (self,menu,name):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( False )
    
def enableMenu (self,menu,name,val):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( bool( val ) )
    
def setMenuLabel (self,menu,name,label,underline=-1, enabled = 1):
   
    item = ( menu, name, label, enabled )
    self.queue.offer( item )
    self.executor.submit( self.menu_changer )
    </t>
<t tx="ekr.20070127142841.316">class MenuRunnable( swing.AbstractAction, java.lang.Runnable): 
        
    def __init__( self, name, command, c , executor):
        swing.AbstractAction.__init__( self, name )
        self.command = command
        self.c = c
        self.name = name
        self.executor = executor
        
    def run( self ):
        self.c.doCommand( self.command, self.name ) #command()
                
    def actionPerformed( self, aE ):

        #print self.command
        #if self.name == 'Save':
        self.executor.submit( self )
                
        #else:        
        #    se</t>
<t tx="ekr.20070127142841.317">class MenuExecuteOnSelect( sevent.MenuListener ):
    
    def __init__( self, method ):
        self.method = method
        
    def menuSelected( self, me ):
        self.method()
        
    def menuCanceled( self, me ):
        pass
        
    def menuDeselected( self, me ):
        pass</t>
<t tx="ekr.20070127142841.318">class LeoMenu( swing.JMenu ):
    
    def __init__( self, *args ):
        swing.JMenu.__init__( self, *args )
    
    def add( self, *items ):
        if hasattr( items[ 0 ], "setFont" ):
            items[ 0 ].setFont( self.getFont() )
        return self.super__add( *items )
        
</t>
<t tx="ekr.20070127142841.319"># This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoSwingTree( sevent.TreeSelectionListener, java.lang.Runnable, aevent.FocusListener ):   
    
    """The base class for the outline pane in Leo windows."""

    positions = java.util.WeakHashMap() #For storing where a node has last been edited
    icons = jarray.zeros( 16, swing.ImageIcon )
    for z in xrange( 16 ):
        num = '%s' % z
        if z &lt; 10: num = '%s%s' %( 0, num )
        ipath = g.os_path_join( g.app.loadDir,"..","Icons","box%s.GIF" % num )
        icons[ z ] = swing.ImageIcon( ipath )
        
    commenticon = swing.ImageIcon( g.os_path_join( g.app.loadDir, "..", "Icons", "Cloud24.gif" ) )

# for( int i = 0; i &lt; _icons.length; i++ ){
            # String num = String.valueOf( i );
            # if( i &lt; 10 ) num = "0" + num;
# _icons[ i ] = new ImageIcon( String.format( "../Icons/box%s.GIF" , num ) );
    # }

    @others</t>
<t tx="ekr.20070127142841.320">def __init__ (self,frame, model = None, chapter = None ):
    
    #leoFrame.leoTree.__init__( self, frame )
    self.frame = frame
    self.c = c = frame.c

    # "public" ivars: correspond to setters &amp; getters.
    self._editPosition = None

    # Controlling redraws
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.chapter = chapter
    self.loaded = False
    self._op = None
    self.skip_reload = 0
    self.view_controls = self.ViewControls()
    self.center = center = self.view_controls.addControl( "Outline", lambda : 1, None, checkmark = 1 )


    
    if model:
        self.posTM = model
    else:
        self.posTM = self.posTreeModel( self.c )
    self.jtree = jtree = self.JTree2( self.posTM )
    jtree.setFocusable( True )
    jtree.setRowHeight( -1 )#ensures that the renderer component's size is used
    self.setBackgroundColor()
    #self.setFontFromConfig()
    g.app.config.manager.addNotificationDef( "outline_pane_background_color", self.setBackgroundColor )
    config = g.app.config
    color = g.app.config.getColor( self.c, "headline_text_unselected_foreground_color" )
    tfg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_unselected_background_color" )
    tbg = getColorInstance( color, awt.Color.WHITE )
    do_brackets = config.getBool( self.c, "headline_do_bracket_color" )
    color = config.getColor( self.c, "headline_bracket_color" )
    bracket_color = getColorInstance( color, awt.Color.BLUE )
    do_directives = config.getBool( self.c, "headline_do_directive_color" )
    color = config.getColor( self.c, "headline_directive_color" )
    directive_color = getColorInstance( color, awt.Color.GREEN )
    
    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode( self.c, tnode )
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    hmap = java.util.HashMap()
    for z in names: hmap.put( z, None )
   
    self.renderer = leoIconTreeRenderer( self.posTM._root, self.icons,
                                         tfg, tbg,
                                         do_brackets, bracket_color,
                                         do_directives, directive_color,
                                         hmap
                                         )
                                         
    self.renderer.setCommentIcon( self.commenticon )
    xxx = lambda : self.jtree.setCellRenderer( self.renderer )
    dc = DefCallable( xxx )
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater( ft )
    self.setFontFromConfig()
    self.renderer.setFont( self.jtree.getFont() )
    
    color = g.app.config.getColor( self.c, "headline_text_editing_foreground_color" )
    tefg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_editing_background_color" )
    tebg = getColorInstance( color, awt.Color.WHITE )
    self.headlineEditor = leoHeadlineTreeCellEditor( self.c, tefg, tebg, leoSwingBody.Editor.icon )
    self.headlineEditor.setFont( self.jtree.getFont() )
    self.tcEdi = tcllEditor = self.tcellEditor( jtree, self.renderer, 
                                                self.headlineEditor,
                                                self.c )
    tcllEditor.addCellEditorListener( self.cellEditorListener( self.c ) )
    jtree.setCellEditor( tcllEditor )
    jtree.setRootVisible( False )
    jtree.setShowsRootHandles( True )
    jtree.getSelectionModel().setSelectionMode( stree.DefaultTreeSelectionModel.SINGLE_TREE_SELECTION )
    jtree.setScrollsOnExpand( True )

    self.jtree = jtree
    jtree.setTransferHandler( self.TreeTransferHandler( self.c, jtree ) )
    jtree.setDragEnabled( True ) 
    jtree.addTreeSelectionListener( self )
    jtree.editable = True
    self.jspane = swing.JScrollPane()
    #self.jspane.setViewport( JViewPort2() )
    
    #self.jspane = self.ZoomJSP()#swing.JScrollPane()
    #self.jspane.setViewport( self.ZoomView() )
    self.jspane.setViewportView( self.jtree )
    #self.jspane.getViewport().setOpaque( False )
    #self.jspane.setBackground( self.jtree.getBackground() )
    center.add( self.jspane )
    jtree.addFocusListener( leoJSPFocusListener( self.jspane, self.c ) )
    self.main_widget = parentpanel = swing.JRootPane()# swing.JPanel( awt.BorderLayout() )
    base = self.view_controls.getBase()
    parentpanel.getContentPane().add( base )
    parentpanel.getGlassPane().setLayout( None )
    

@
    zoom = swing.JMenu( "Zoom" )
    def setScale( scale, jtree = jtree ): #zoomer = zoomer, jtree = jtree ):
        double = java.lang.Double( scale )
        sval = double.doubleValue()/100
        #zoomer.setScale( sval )
        jtree.setScale( sval )
    buttongroup = swing.ButtonGroup()
    for z in ( 25, 50, 75, 100, 150, 200, 300, 400 ):
        jmi = swing.JCheckBoxMenuItem( str( z ) + "%" )
        zoom.add( jmi )
        buttongroup.add( jmi )
        if z == 100: jmi.setState( True )
        jmi.actionPerformed = lambda event, scale = z: setScale( scale )
    jmb.add( zoom )
@c
    
    self.current = self.jspane
    cpane = frame.jsp1

    self._dragging = False
    self._editPosition = None


    self.reloading = False
    self.paths = False
    self.settingPosition = False
    self.lastHoistStackLength = 0
    self.configureMedia()
    g.doHook("swingtreecreated", tree = self, view_controls = self.view_controls, c = self.c) 
    



</t>
<t tx="ekr.20070127142841.322">class posTreeModel( stree.TreeModel, java.lang.Runnable ):
    
    def __init__( self, c ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c )
        self._rTreePath = stree.TreePath( self._root )       


    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):
        
        
        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            for z in self.c.rootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )
        
        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in self.tmlisteners:
            z.treeStructureChanged( e )
            

    
    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )
        
    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )
    
    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()
        
    def getChildCount( self, parent ):
        
        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0
        
    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()


    
    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )
        
    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True
            
    def getPathToRoot( self, node ):
        
        path = []
        #if not node:
        #    node = self.c.rootPosition()
            
        while node and node.level() != 0:
            path.append( node.copy() )
            node = node.getParent()
        else:
            path.append( node.copy() )
            path.append( self._root )
            
        path.reverse()
        tp = stree.TreePath( path )
        return tp
            
    class _rootN( stree.TreeNode ):
        
        def __init__( self, c ):
            self.c = c
        
        def getChildAt(self, childIndex):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0: #Hoist Code
                rp = self.c.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       
        
        def getChildCount( self ):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i
        
        def getParent( self ):
            return None
            
        def getIndex( self, node):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ][ 0 ].copy()
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1
            
        def getAllowsChildren( self ):
            return True
            
        def isLeaf( self ):
            return False
            
        def equal( self, x ):
            if self is x: return True
            else: return False
            
        def equals( self, x ):
            if self is x: return True
            else:
                return False
            
        def copy( self ):
            return self
            
        def bodyString( self ):
            return ""
            
        def headString( self ):
            return ""
            
        def children( self ):
            
            class _enum( util.Enumeration ):
                
                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None
                
                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False
                    
                def nextElement( self ):
                    
                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            return _enum( self.c.rootPosition.siblings_iter( copy = True ) )        
        

    
       





</t>
<t tx="ekr.20070127142841.323">def doneLoading( self ):
    
    self.loaded = True
    c = self.c
    #awt.EventQueue.invokeLater( self.__reloader( self.posTM, self.tree_reloader ) )
    #swing.SwingUtilities.invokeLater( self.tree_reloader )
    #g.es( "Expanding tree( last startup operation )..." )
    c.frame.body.editor.sync()
    #c.frame.body.editor.cdertminer.last_p = None
    c.frame.body.jdp.repaint()
    

class __reloader( java.lang.Runnable ):
    
    def __init__( self, model , tree_reloader ):
        self.model = model
        self.tree_reloader = tree_reloader
        
    def run( self ):
        self.model.reload( full_reload = False );
        self.tree_reloader.run()
        #awt.EventQueue.invokeLater( self.tree_reloader ) </t>
<t tx="ekr.20070127142841.324">def valueChanged( self, event ):
    
    path = event.getPath()
    o = path.getLastPathComponent()
    #if not self.c.currentPosition().equal( o ):
    if not self.chapter.getCurrentPosition().equal( o ):
        self.settingPosition = True
        #cp = self.c.currentPosition()
        cp = self.chapter.getCurrentPosition()
        #if hasattr( cp ,'v' ):
        #    leoSwingTree.positions.put( cp.v, self.c.frame.body.editor.editor.getCaretPosition() )
        #self.c.setCurrentPosition( o )
        self.select( o )
        #self.frame.body.editor.sync()
        self.settingPosition = False
        #if hasattr( o, 'v' ) and leoSwingTree.positions.containsKey( o.v ):
        #    spot = leoSwingTree.positions.get( o.v )
        #    editor = self.c.frame.body.editor
        #    doc = editor.editor.getStyledDocument()
        #    if doc.getLength() &lt; spot: return
        #    
        #    editor.editor.setCaretPosition( spot )
        #    rec = editor.editor.modelToView( spot )
        #    if rec:
        #        editor.view.getViewport().scrollRectToVisible( rec )
        #else:
        #    self.c.frame.body.editor.editor.setCaretPosition( 0 )</t>
<t tx="ekr.20070127142841.325"></t>
<t tx="ekr.20070127142841.326">def drawIcon(self,v,x=None,y=None):
    self.oops()


def _redraw( self, event = None ):
    pass

def redraw(self,event=None): # May be bound to an event.
    
    if len( self.c.hoistStack ) or self.lastHoistStackLength: #This ensures the correct Hoisted part of the tree is displayed
        if self.lastHoistStackLength != len( self.c.hoistStack ):
            self.lastHoistStackLength = len( self.c.hoistStack )
            #self.posTM.reload()
            #swing.SwingUtilities.invokeLater( self.tree_reloader )

    #self.jtree.repaint()
    self.jtree.repaint( 10 )
    

def _redraw_now( self, scroll = False ):
    pass

def redraw_now(self, scroll = False):
    self.jtree.repaint()
    
def redrawAfterException (self):
    self.redraw()
    
def alterationInTreeNodes( self ):
    #self.jtree.getParent().revalidate()
    #self.posTM.reload( full_reload = True )
    self.beginUpdate()
    self.endUpdate()
    
def nodeDidChange( self, pos ):
    self.jtree.treeDidChange()

    

    

</t>
<t tx="ekr.20070127142841.327">def editLabel(self,v):

  if self.loaded: #If the system isnt loaded this can result in a different root than what is in the Leo File!.
    self._EditLabelEnabler.setNodeToEdit( v )
  if self.updateCount == 0:
      self._EditLabelEnabler.addToEventQueue()


        
def endEditLabel(self):

    if self.jtree.isEditing():
        dc = DefCallable( self.__stopediting )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )
        #self.jtree.stopEditing()

def __stopediting( self ): 
    self.jtree.stopEditing()
    g.doHook( "headline-editing-finished", p = self.chapter.getCurrentPosition(), chapter = self.chapter )

def setNormalLabelState(self,v):
    pass</t>
<t tx="ekr.20070127142841.329"># These should all be internal to the tkinter.frame class.

def OnActivateHeadline(self,v):
    self.oops()
    
def onHeadChanged(self,v):
    self.oops()

def OnHeadlineKey(self,v,event):
    self.oops()

def idle_head_key(self,v,ch=None):
    self.oops()</t>
<t tx="ekr.20070127142841.330">def scrollTo(self,v):
    self.oops()
    
def scrollRight( self, increment = 0 ):
    
    sbar = self.jspane.getHorizontalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value &gt; max:
        value = max
    sbar.setValue( value )
    
def scrollLeft( self, increment = 0 ):
    sbar = self.jspane.getHorizontalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value &lt; min:
        value = min
    sbar.setValue( value )
    
def scrollUp( self, increment = 0 ):
    
    sbar = self.jspane.getVerticalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value &lt; min:
        value = min
    sbar.setValue( value )

def scrollDown( self, increment = 0 ):
    
    sbar = self.jspane.getVerticalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value &gt; max:
        value = max
    sbar.setValue( value )    

def idle_scrollTo(self,v):
    
    self.oops()



</t>
<t tx="ekr.20070127142841.331">def select(self,p,updateBeadList=True):
    
    c = self.c
    jtree = self.jtree
    editor = c.frame.body.editor.editor
    
    cpy = p.copy()
    tp = self.posTM.getPathToRoot( cpy )
    if tp.getPath():
        jtree.setSelectionPath( tp )
        jtree.scrollPathToVisible( tp )

    #old_p = c.currentPosition()
    old_p = self.chapter.getCurrentPosition()
    if hasattr( old_p ,'v' ):
        leoSwingTree.positions.put( old_p.v, editor.getCaretPosition() )
    
    #c.setCurrentPosition( cpy )
    self.chapter.setCurrentPosition( cpy )
    if c.frame.body.editor.lastPosition == cpy:
        g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
        return
        
    c.frame.body.editor.sync( pos = cpy)
    
    if hasattr( cpy, 'v' ) and leoSwingTree.positions.containsKey( cpy.v ):
        
        spot = leoSwingTree.positions.get( cpy.v )
        doc = editor.getStyledDocument()
        if doc.getLength() &lt; spot: return
        
        editor.setCaretPosition( spot )
        try:
            rec = editor.modelToView( spot )
            if rec:
                c.frame.body.editor.view.getViewport().scrollRectToVisible( rec )
        except: #the darn thing blows up here if not enough of the editor is showing...
            pass
    else:
        editor.setCaretPosition( 0 )
    
    g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
    </t>
<t tx="ekr.20070127142841.332">def expandAllAncestors(self,p):
    

    tp = self.posTM.getPathToRoot( p.copy() )
    self.jtree.expandPath( tp )
    </t>
<t tx="ekr.20070127142841.333">def beginUpdate (self):
    
    self.updateCount += 1
    self.endEditLabel()
    if not self.settingPosition:
        self.paths = True</t>
<t tx="ekr.20070127142841.334">def endUpdate (self,flag=True ):

    #print java.lang.Thread.currentThread() , self.updateCount
    #try:
    assert(self.updateCount &gt; 0)
    self.updateCount -= 1

    # g.trace(self.updateCount)
    #if flag and self.updateCount == 0:
    #    self.redraw()
    if self.paths:
        self.reloading = True
        #posTM = self.posTM
        #c = self.c
        if not self.skip_reload and self.updateCount == 0:
            #cp = c.currentPosition().copy()
            #cp = self.chapter.getCurrentPosition().copy()
            self.posTM.dRun()
            #tp = self.posTM.getPathToRoot( cp )
            #self.tree_reloader.setCurrentPosition( tp )
            #swing.SwingUtilities.invokeLater( self.tree_reloader )               
            self._op = None
            self.paths = False
            self.reloading = False
            if hasattr( self, "_EditLabelEnabler" ):
                self._EditLabelEnabler.addToEventQueue()
            
</t>
<t tx="ekr.20070127142841.335">def dragging(self):
    return self._dragging

def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition
    
def setDragging(self,flag):
    self._dragging = flag

def setEditPosition(self,p):
    self._editPosition = p</t>
<t tx="ekr.20070127142841.336">def oops(self):
    
    print "leoTree oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20070127142841.337">def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = v.headString().strip()
    if g.match_word(s,0,"@url"):
        if not g.doHook("@url1",c=c,v=v):
            url = s[4:].strip()
            &lt;&lt; stop the url after any whitespace &gt;&gt;
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,v=v)</t>
<t tx="ekr.20070127142841.338"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        g.es("ignoring characters after space in url:"+url[i:])
        g.es("use %20 instead of spaces")
    url = url[:i]
</t>
<t tx="ekr.20070127142841.339">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20070127142841.340">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

</t>
<t tx="ekr.20070127142841.341">def enableDrawingAfterException (self):
    pass</t>
<t tx="ekr.20070127142841.342">class tcellEditor( stree.DefaultTreeCellEditor ): #so the tree will start editing on 1 click!
    
    def __init__( self , jtree, renderer, editor, c ):
        stree.DefaultTreeCellEditor.__init__( self, jtree, renderer , editor )
        self.editor = editor
        self.editor.setFocusTraversalPolicy( c.frame.ftp )
        self.timer = None
        self.c = c
        self.tree = jtree

    def getTreeCellEditorComponent(self, tree, value, isSelected, expanded, leaf, row):
        return self.editor.getTreeCellEditorComponent( tree, value, isSelected, expanded, leaf, row )     

    def requestFocusInWindow( self ):
        self.editor.requestFocusInWindow()

    def shouldStartEditingTimer( self, event ):
    
        if event.getClickCount() &gt;= 1 and self.inHitRegion( event.getX(), event.getY() ):
            #self.tree.stopEditing() 
            return True
        else:
            return False
            
    def canEditImmediately( self, event ):
        
        if event == None or event.getClickCount() == 2:
            return True
        else:
            return False

    def startEditingTimer( self ):
        
        #self.htext = None
        if self.timer == None:
            self.timer = swing.Timer( 10, self )
            self.timer.setRepeats( False )
        self.timer.start()

    #def cancelCellEditing( self ):
    #
    #    self.super__cancelCellEditing()
    #cp = self.c.currentPosition()
    #htext = self.tree.getCellEditor().getCellEditorValue()
    #cp.setHeadString(  )
    #self.htext = None

    #def prepareForEditing( self ):
    #    
    #    self.super__prepareForEditing()
    #cp = self.c.currentPosition()
    #self.htext = cp.headString()

</t>
<t tx="ekr.20070127142841.343">class cellEditorListener( sevent.CellEditorListener, java.lang.Runnable ):
    
    def __init__( self, c ):
        self.c = c
        
    def editingCanceled( self, event ): 
        #Called when the headline edit has been aborted, do nothing... results in headline reverting.
        pass
        #self.sync( event )
        
    def editingStopped( self, event ):
        self.sync( event )
        
    def run( self ):
        
        self.c.frame.body.editor.editor.requestFocusInWindow()
        
        
    def sync( self , event ):
        
        source = event.getSource()
        value = source.getCellEditorValue()
        cp = self.c.currentPosition()
        cp.setHeadString( value )
        awt.EventQueue.invokeLater( self )
</t>
<t tx="ekr.20070127142841.344">def edit_text( self, p ):
    
    return self.c.frame.body.editor.editor
    
</t>
<t tx="ekr.20070127142841.345">def createAuxilaryWidgets( self ):
    
    parentpanel = self.main_widget
    jtree = self.jtree
    c = self.c
    jmb = swing.JMenuBar()
    self.view_controls.setMenuBar( jmb )
    parentpanel.add( jmb, java.awt.BorderLayout.NORTH )    
    pue = self.PopupEnabler( c )
    jtree.addMouseListener( pue )
    self._EditLabelEnabler = self.EditLabelEnabler( self.jtree , self.headlineEditor)
    jtree.addFocusListener( self )
</t>
<t tx="ekr.20070127142841.346">def getWidget( self ):
    
    return self.main_widget
    
</t>
<t tx="ekr.20070127142841.348">class JTree2( swing.JTree ):
    
    def __init__( self, model ):
        self.posTM = model
        swing.JTree.__init__( self, model )
        self.lastDimensions = awt.Rectangle( 0, 0,0,0 )
        self.last_image = None
        self.image = None
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 ) 
        #self.setOpaque( False )
        self.canPaint = True
        

    def setImage( self, image ):
        self.image = image
        
    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )
        

        
    def paintComponent( self, graphics ):
        
        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )

            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite ) 
@
        else:
            #clip = graphics.getClip();
            #bounds = clip.getBounds()
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = color.brighter()
            c2 = color.darker()
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint( vrect.x, vrect.y, c1, vrect.x + vrect.width, vrect.y + vrect.height, c2, True )
            graphics.setPaint( gp )
            graphics.fillRect( vrect.x, vrect.y, vrect.width, vrect.height )
            graphics.setPaint( paint )
@c       
        self.super__paintComponent( graphics )#comes last, or no tree!!!

     
        
    def isExpanded( self, path ):
        
        if path.__class__ != stree.TreePath:
            path = self.getPathForRow( path )
            
        lc = path.getLastPathComponent()
        if lc == self.posTM._root:
            return True
        else:
            return lc.isExpanded()
    
    def setExpandedState( self, path, boolean ):
        
        if boolean:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillExpand( path )
            except:
                return
            lc.expand()
            self.fireTreeExpanded( path )
        else:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillCollapse( path )
            except:
                return
            lc.contract()
            self.fireTreeCollapsed( path )
        
    
    def getExpandedDescendants( self, path ):
        

        lc = path.getLastPathComponent()
        paths = java.util.Vector()
        expanders = []
        
        if lc == self.posTM._root:
            p = self.posTM.chapter.getRootPosition()
            cp = self.posTM.chapter.getCurrentPosition()
        else:
            p = lc.copy()
        rp = self.posTM.chapter.getRootPosition()
        stop_p = p.copy()
        
        while p:                
            expanded = p.isExpanded()
            #if p == stop_p and p != rp: expanded = True
            #elif stop_p == rp and not self.posTM.drunning: expanded = True
            #elif self.posTM.drunning and p == rp:
            #    expanded = True
            
            if expanded:
                expanders.append( p.copy() )
                        
            if expanded:
                if p.v.t._firstChild:
                    p.moveToFirstChild()
                elif p and p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break
            else:
                if p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break
        
        expanders.sort( self.sortNodes )
        while expanders:
            z = expanders.pop()
            path = self.posTM.getPathToRoot( z.copy(), masterlist = expanders )
            paths.add( path )
        return paths.elements()
    

    def sortNodes( self, node1, node2 ):
        
        l1 = node2.level()
        l2 = node2.level()
        if l1 &gt; l2: return 1
        elif l1 &lt; l2: return -1
        else: return 0


</t>
<t tx="ekr.20070127142841.350">def configureMedia( self ):
    
    c = self.c 
    use_background = g.app.config.getBool( c, "tree_use_background_image" )    
    if use_background:
        self.setBackgroundImage()
</t>
<t tx="ekr.20070127142841.351">def setBackgroundImage( self, notification = None, handback = None ):
    
    c = self.c
    alpha = g.app.config.getFloat( c, "tree_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "tree_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            self.jtree.setImage( bimage )
            self.jtree.setAlpha( alpha )
            self.jtree.setOpaque( False )
            g.app.config.manager.addNotificationDef( "tree_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "tree_image_location@as-filedialog", self.setBackgroundImage )



</t>
<t tx="ekr.20070127142841.352">@others
</t>
<t tx="ekr.20070127142841.353">class EditLabelEnabler( java.lang.Runnable ):
    '''This class enables a label to be edited within the context of
       beginUpdate and endUpdate.  Doing the operation between these two
       calls resulted in NullPointer Exceptins to be thrown.  This does the work
       safely after those calls have been made, actually this is how it is used
       in endUpate, not with the EditLabelEnabler.  It is a policy on top of this
       classes mechanism'''
       
    def __init__( self, jtree, headlineEditor ):
        
        self._jtree = jtree
        self.headlineEditor = headlineEditor
        #We use an AtomicReference to ensure that the node is fresh.
        #We use 2 Semaphores so we can correctly time the execution of an insert
        #and the beginning of a label edit.  Without this we can move too quickly 
        #and produce  NullPointerExceptions, or something like that.
        self.edit_v = atomic.AtomicReference()
        self.semaphore = concurrent.Semaphore( 1 ) 
        self.add_to_queue = concurrent.Semaphore( 1 )
        
        
    def setNodeToEdit( self, node ):
        
        if node:
            self.semaphore.acquire()
            self.edit_v.set( node.copy() )
            self.semaphore.release()
        
    def addToEventQueue( self ):
        #java.lang.Thread.dumpStack()
        if self.edit_v.get() and self.add_to_queue.availablePermits():
            self.add_to_queue.acquire()
            awt.EventQueue.invokeLater( self )
            
    
    def run( self ):
        
        self.semaphore.acquire()
        posTM = self._jtree.getModel()
        ev = self.edit_v.getAndSet( None )
        self.semaphore.release()
        ptr = posTM.getPathToRoot( ev )
        #self.edit_v = None
        #self._jtree.requestFocusInWindow()
        self._jtree.startEditingAtPath( ptr )
        self.headlineEditor.requestFocusInWindow()
        self.add_to_queue.release()
        
        
</t>
<t tx="ekr.20070127142841.354">class ViewControls:
    
    def __init__( self ):
        self.menu = swing.JMenu( "Views" )
        self.bgroup = swing.ButtonGroup()
        self.layout = java.awt.CardLayout()
        self.base = swing.JPanel( self.layout )
        self.methods = {}
        self.detacher = None
        self.menu_bar = None
        self.count = 0
        
    def setMenuBar( self, bar ):
        self.menu_bar = bar
        if self.count &gt; 1:
            self.menu_bar.add( self.menu, 0 )
    
    def getMenu( self ):
        return self.menu
        
    def getBase( self ):
        return self.base
        
    def addControl( self, name, attachmethod, detachmethod, checkmark = 0 ):
        
        jmi = swing.JCheckBoxMenuItem( name )
        if checkmark:
            jmi.setSelected( 1 )
        self.methods[ name ] = ( attachmethod, detachmethod )
        jmi.actionPerformed = lambda event: self.__action(  name  )
        self.bgroup.add( jmi )
        self.menu.add( jmi )
        nwbase = swing.JPanel()
        nwbase.setLayout( awt.GridLayout( 1,1 )) 
        self.base.add( nwbase, name )
        if self.menu_bar and ( self.count &gt; 1 and self.menu.getParent() == None ):
            self.menu_bar.add( self.menu, 0 )
        self.count += 1
        return nwbase
    
    def __action( self, name ):
        
        if self.detacher: self.detacher()
        attach, detach = self.methods[ name ]
        self.layout.show( self.base, name )
        attach()
        self.detacher = detach
        

</t>
<t tx="ekr.20070127142841.355">class PopupEnabler( aevent.MouseAdapter ):
    
    def __init__( self, c ):
        aevent.MouseAdapter.__init__( self )
        self.node = None
        self.c = c
        #self.cursor = None
        #self.imagesetter = leoSwingTree.ImageSetter( c.frame.gp2, c )
        
    def mouseDragged( self, event ):
        self.c.frame.gp2.repaint()
        
    def mouseMoved( self, event ):
        pass
    
    def mousePressed( self, mevent ):
        
        button = mevent.getButton()
@
        if button == mevent.BUTTON1:
            tree = mevent.getSource()
            path = tree.getPathForLocation( mevent.x, mevent.y )
            if path:
                row = tree.getRowForLocation( mevent.x, mevent.y )
                self.node = path.getLastPathComponent().copy()
                bi2 = self.c.frame.tree.getRendererImageOfNode( self.node )
                self.cursor = tree.getCursor()
                ncursor = awt.Cursor.getPredefinedCursor( awt.Cursor.HAND_CURSOR )
                #tk = awt.Toolkit.getDefaultToolkit()
                #ccursor = tk.createCustomCursor( bi2, awt.Point(0,0 ), "ccursor" )
                self.imagesetter.setTargets( bi2, ncursor, path )
                swing.SwingUtilities.invokeLater( self.imagesetter )
@c
        if button == mevent.BUTTON3:
            self.showMenu( mevent )
@        
    def mouseReleased2( self, mevent ):
        tree = mevent.getSource()
        path = tree.getPathForLocation( mevent.x, mevent.y )
        updatestarted = False
        self.imagesetter.reset()
        try:
            if path and self.node:
                endpoint = path.getLastPathComponent().copy()
                if self.node.v.t != endpoint.v.t and not self.node.isAncestorOf( endpoint ):
                    try:
                        self.c.beginUpdate()
                        updatestarted = True
                    except:
                        pass
                    if endpoint.numberOfChildren():
                        self.c.dragToNthChildOf(self.node,endpoint,0)
                    else:
                        self.c.dragAfter(self.node,endpoint)
        finally:
            self.node = None
            if self.cursor:
                tree.setCursor( self.cursor )
                self.cursor = None
            if updatestarted:
                updatestarted = False
                self.c.endUpdate()
@c
         
    def showMenu( self, event ):
        
        popup = swing.JPopupMenu()
        class aa( swing.AbstractAction ):
            def __init__( self, name, command ):
                swing.AbstractAction.__init__( self, name )
                self.command = command
                
            def actionPerformed( self, event ):
                self.command()
        
        c = self.c
        commandlist = (  
                        ( "Read @file Nodes", c.readAtFileNodes, 0 ),
                        ( "Write @file Nodes", c.fileCommands.writeAtFileNodes, 0 ), 
                        (),
                        ( "Tangle", c.tangle, 0 ),
                        ( "Untangle", c.untangle, 0 ),
                        (),
                        ("Toggle Angle Brackets", c.toggleAngleBrackets, 0 ),
                        (),
                        ( "Cut Node", c.cutOutline, c.canCutOutline ),
                         (  "Copy Node", c.copyOutline, 0 ),
                         ( "Paste Node", c.pasteOutline, c.canPasteOutline ),
                         ( "Delete Node", c.deleteOutline, c.canDeleteHeadline ),
                         (),
                         ( "Insert Node", c.insertHeadline, 0 ),
                         ( "Clone Node", c.clone, 0 ),
                         ( "Sort Children", c.sortChildren, c.canSortChildren ),
                         ( "Sort Siblings", c.sortSiblings, c.canSortSiblings ),
                         (),
                         ( "Contract Parent", c.contractParent, c.canContractParent ),
                         )
                         
        for z in commandlist:
            if len(z) == 0:
                popup.addSeparator()
            else:
                if z[ 2 ]:
                    ok = z[ 2 ]()
                else:
                    ok = True
                if ok:
                    popup.add( aa( z[ 0 ], z[ 1 ] ) )
                         
                         
                         
        
        x = event.getX()
        y = event.getY()
        popup.show( event.getSource(), x, y )

</t>
<t tx="ekr.20070127142841.356">class ImageSetter( java.lang.Runnable, aevent.MouseMotionListener  ):
    def __init__( self , gp2, c, jtree):
        self.image = None
        self.gp2 = gp2
        self.c = c
        self.path = None
        jtree.addMouseMotionListener( self )
        
    def mouseDragged( self, event ):
        if self.image:
            self.gp2.repaint()
            
    def mouseMoved( self, event ):
        pass
            
    def setImage( self, image ):
        self.image = image
        
            
    def setPath( self, path ):
        self.path = path
        
    def setTargets( self, image , path ):
        self.image = image
        self.path = path
            
    def reset( self ):
        self.gp2.setImage( None ); self.gp2.setCursor( None )
        self.image  = self.path = None
                    
    def run( self ):
            
        if self.image:# and self.cursor:
            tree = self.c.frame.tree.jtree
            epath = tree.getEditingPath()
            spath = tree.getSelectionPath()
            if not self.path.equals( epath ):
                self.gp2.setImage( self.image )
                #self.gp2.setCursor( self.cursor )
            else:
                self.reset()
</t>
<t tx="ekr.20070127142841.357">class TreeTransferHandler( swing.TransferHandler ):
    
    transferservice = java.util.concurrent.Executors.newSingleThreadExecutor()
    
    def __init__( self, c, jtree ):
        swing.TransferHandler.__init__( self )
        self.flavors = []
        DataFlavor = datatransfer.DataFlavor
        self.flavors.append( DataFlavor.javaFileListFlavor )
        self.uri = DataFlavor( "text/uri-list;class=java.lang.String" )
        self.smarker = DataFlavor( "text/internal-transfer;class=java.lang.String" )
        self.pspecflavor = DataFlavor( DataFlavor.javaJVMLocalObjectMimeType, 
                                       "class=%s" % PositionSpecification, 
                                       PositionSpecification.getClassLoader() ) #We use this one or the system can't find the PS class!
        self.flavors.append( self.uri )
        self.c = c
        self.jtree = jtree
        
    def createTransferable( self, jc ):
        pi = awt.MouseInfo.getPointerInfo()
        spot = pi.getLocation()
        swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
        path = self.jtree.getPathForLocation( spot.x, spot.y )
        rv = self.TreeTransferable( self.c, list( self.flavors ) )
        if path:
            p = path.getLastPathComponent().copy()
            rv.setPosition( p, self.pspecflavor )
            bi2 = self.c.frame.tree.getRendererImageOfNode( p.copy() ) 
        else:
            rv.addDataFlavor( self.smarker )
        return rv
        
    def getSourceActions( self, jc ):
        return self.COPY_OR_MOVE
        
    @others
    
</t>
<t tx="ekr.20070127142841.358">def canImport( self, jc, df ):
    
    for z in df:
        if z.equals( self.smarker ): return False
    
    for z in df:
        if z.isFlavorJavaFileListType(): return True
        elif z.equals( self.uri ): return True
        elif z.equals( self.pspecflavor ): return True
        
    return False</t>
<t tx="ekr.20070127142841.359">def importData( self, jc, trans ):
    
    c = self.c
    try:
        if trans.isDataFlavorSupported( self.pspecflavor ):
            pi = awt.MouseInfo.getPointerInfo()
            spot = pi.getLocation()
            swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
            path = self.jtree.getPathForLocation( spot.x, spot.y )
            if path:
                node = trans.getTransferData( self.pspecflavor )
                endpoint = path.getLastPathComponent().copy()
                if node.v.t != endpoint.v.t and not node.isAncestorOf( endpoint ):
                    try:
                        c.beginUpdate()
                        if endpoint.numberOfChildren(): 
                            self.c.dragToNthChildOf( node,endpoint,0)
                        else:
                            self.c.dragAfter( node,endpoint)
                    finally:
                        c.endUpdate()
            return True
        elif trans.isDataFlavorSupported( datatransfer.DataFlavor.javaFileListFlavor ):
            files = trans.getTransferData( datatransfer.DataFlavor.javaFileListFlavor )
            ifiles = self.ImportFiles( files, self )
            self.transferservice.submit( ifiles )
            return True
        elif trans.isDataFlavorSupported( self.uri ):
            uri = trans.getTransferData( self.uri )
            iurls = self.ImportUrls( uri, self )
            self.transferservice.submit( iurls )
            return True
    finally:
        pass
        
    return False</t>
<t tx="ekr.20070127142841.360">def importFile( self, filename ):
    
    c = self.c
    at = c.atFileCommands
    io = java.io
    filename = java.net.URLDecoder.decode( filename, "UTF-8" )
    if filename.endswith( ".leo" ):
        try:
            c.chapters.loadFileAsChapter( filename )
        except:
            g.es( "Error loading %s" % filename )            
    else:
        isDerived = False
        thin = False
        try:
            theFile = open(filename,'rb')
            firstLines , readNew, thin = at.scanHeader(theFile,filename)
            isDerived = ( readNew or thin )
            theFile.close()
        except IOError:
            g.es( "Could not import %s" % filename )
            return
        if isDerived:
            c.importCommands.importDerivedFiles( c.currentPosition().copy(), [ filename, ] )
        else:
            c.importCommands.importFilesCommand( [ filename, ], "@file" )
        try:
            nwname = io.File( filename ).getName()
            if nwname:
                cp = c.currentPosition()
                cp.setHeadStringOrHeadline( nwname )
                    
        except:
            pass

</t>
<t tx="ekr.20070127142841.361">def getVisualRepresentation( self, transf ):

    tree = self.c.frame.tree
    icon = tree.getRendererImageOfNode( self.c.currentPosition() )
    return icon</t>
<t tx="ekr.20070127142841.362">class TreeTransferable( datatransfer.Transferable ):
    
    def __init__( self, c, flavors ):
        self.c = c
        self.flavors = flavors
        self.uri = datatransfer.DataFlavor( "text/uri-list;class=java.lang.String" )
        self.position = None
        self.pflavor = None
        self.writen = False
        self.nwfile = None
    
    def addDataFlavor( self, flavor ):
        self.flavors.append( flavor )
    
    def setPosition( self, position, flavor ):
        self.position = position
        self.pflavor = flavor
        self.flavors.append( flavor )
    
    def getTransferDataFlavors( self ):
        return self.flavors 
        
    def isDataFlavorSupported( self, flavor ):
        
        for z in self.flavors:
            if flavor.equals( z ): return True
        return False
        
    @others
</t>
<t tx="ekr.20070127142841.363">def getTransferData( self, df ):
    
    if df.equals( datatransfer.DataFlavor.javaFileListFlavor ):
        rv = util.ArrayList()
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.written = True
            
        rv.add( self.nwfile )
        return rv
    elif df.equals( self.uri ):
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.writen = True
            
        rv = self.nwfile.toURI().toString()
        return rv
    elif self.pflavor and df.equals( self.pflavor ):
        return self.position
    else:
        raise datatransfer.UnsupportedFlavorException( df )</t>
<t tx="ekr.20070127142841.364">def writeNodeToFile( self, tmpfile ):
        
    c = self.c
    cp = c.currentPosition()
    at = c.atFileCommands
    c.fileCommands.assignFileIndices()
    fn = cp.v.anyAtFileNodeName()
    if fn:
        nosentinels = cp.v.atNoSentinelsFileNodeName()
        if nosentinels: nosentinels = True
        else: nosentinels = False
        thinFile = cp.v.atThinFileNodeName()
        if thinFile: thinFile = True
        else: thinFile = False
        at.write( cp.copy(), thinFile = thinFile, nosentinels = nosentinels, toString = True, scriptWrite = False )
    else:
        at.write( cp.copy(), thinFile = True, toString = True, scriptWrite = False )
    data = at.stringOutput 
    ps = None
    io = java.io
    encoding = "UTF-8"
    try:
        try:
            fos = io.FileOutputStream( tmpfile )
            ps = io.PrintWriter( io.OutputStreamWriter( fos ) ) 
            for z in data.split( "\n" ):
                ps.println( z )
            ps.close()
            ps = None
            frd = io.FileReader( tmpfile )
            encoding = frd.getEncoding()
            frd.close()
            frd = None       
        except io.IOException, io:
            io.printStackTrace()
    finally:
        if ps: ps.close()
        if frd: frd.close()
    hstring = cp.headString()
    if cp.v.anyAtFileNodeName():
        hstring = cp.v.anyAtFileNodeName()
    language = LeoUtilities.scanForLanguage( cp.copy() ) 
    if g.app.language_extension_dict.has_key( language ):
        ext = g.app.language_extension_dict[ language ]
    else:
        ext = language
    
    import binascii
    hstring = list( hstring )
    for i in xrange( len( hstring ) ):
        ch = hstring[ i ]
        if not ch.isalnum() and not ch.isspace() and ch not in ( "." ):
            hstring[ i ] = binascii.hexlify( ch )
            
    hstring = "".join( hstring )
    
    if not hstring.endswith( ext ):
        nwname = "%s.%s" %( hstring, ext )
    else:
        nwname = hstring
    nwname = java.net.URLEncoder.encode( nwname, encoding )
    pdirectory = tmpfile.getParent()
    try:
        if fn:
            fn2 = io.File( fn )
            nwfile = io.File( pdirectory, fn2.getName() )
        else:
            nwfile = io.File( pdirectory, nwname )
    except io.IOException, ix:
        ix.printStackTrace()
    tmpfile.renameTo( nwfile )
    nwfile.deleteOnExit()
    return nwfile
</t>
<t tx="ekr.20070127142841.365">class ImportUrls( java.lang.Runnable ):
    
    def __init__( self, uri, tth ):
        self.uri = uri
        self.tth = tth
        
    def run( self ):
        uris = self.uri.split( "\r\n" )
        for z in uris:
            try:
                if z:
                    f = java.net.URL( z ).getFile()
                    self.tth.importFile( f )
            except java.lang.Exception, x:
                x.printStackTrace()
</t>
<t tx="ekr.20070127142841.366">class ImportFiles( java.lang.Runnable ):
    
    def __init__( self, files, tth ):
        self.files = files
        self.tth = tth
        
    def run( self ):
        
        for z in self.files:
            try:
                fname = z.getAbsolutePath()
                if fname:
                    self.tth.importFile( fname )
            except java.lang.Exception, x:
                x.printStackTrace()
</t>
<t tx="ekr.20070127142841.367">def focusGained( self, event ):

    if self.jtree.isEditing():
        self.jtree.getCellEditor().requestFocusInWindow()
    
def focusLost( self, event ):
    pass
</t>
<t tx="ekr.20070127142841.368">def getEditorImageOfNode( self, p ):
    
    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path )
    comp = self.tcEdi.getTreeCellEditorComponent( self.jtree, p, p.isCurrentPosition(), p.isExpanded(), p.numberOfChildren(), row )
    return self.__createImage( comp )    
    
    
    
def getRendererImageOfNode( self, p ):

    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path ) 
    comp = self.renderer.getTreeCellRendererComponent( self.jtree, p, p.isCurrentPosition(), 
                                                       p.isExpanded(), p.numberOfChildren(), row, True ) 
    return self.__createImage( comp )
    
def __createImage( self, component ):
    
    psize = component.getPreferredSize()
    bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
    g = bi.createGraphics()

    #jw = swing.JWindow()
    #jw.toBack()
    #mpi = awt.MouseInfo.getPointerInfo()
    #location = mpi.getLocation()
    #jw.setLocation( location )
    #jw.add( component )
    #jw.setSize( psize )
    opaque = component.isOpaque()
    background = component.getBackground()
    component.setOpaque( True )
    component.setBackground( awt.Color.WHITE )
    #jw.visible = 1
    self.jtree.add( component )
    component.setSize( component.getPreferredSize() ) #this appears to work better then making a short lived window
    component.paint( g ) 
    self.jtree.remove( component )
    #jw.visible = 0
    component.setOpaque( opaque )
    component.setBackground( background )
    #jw.dispose()
    g.dispose()
    return bi          
    
    
    
</t>
<t tx="ekr.20070127142841.369">def getFont (self):

    return self.font
        
# Called by leoFontPanel.
def setFont(self,font=None, fontName=None):
    
    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        #self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
    print "SETTING FONT!!!!"
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    
    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")
    
    
    #    font = config.getFontFromParams( self.c,
    #    "log_text_font_family", "log_text_font_size",
    #    "log_text_font_slant",  "log_text_font_weight",
    #    config.defaultLogFontSize)
    
    #font2 = c.config.getFontFromParams( self.c,
    #    "headline_text_font_family", "headline_text_font_size",
    #    "headline_text_font_slant",  "headline_text_font_weight",
    #    c.config.defaultTreeFontSize )#, tag = "tree")
    
    
    #self.setFont(font)
    self.jtree.setFont( font )</t>
<t tx="ekr.20070127142841.370">def setBackgroundColor (self, notification = None, handback = None ):
    
    c = self.c

    color = c.config.getColor("outline_pane_background_color")
    bg = getColorInstance( color, awt.Color.WHITE )

    try:
        #self.canvas.configure(bg=bg)
        self.jtree.setBackground( bg )
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()</t>
<t tx="ekr.20070127142841.371">if 0:
    @others</t>
<t tx="ekr.20070127142841.372">@others
</t>
<t tx="ekr.20070127142841.373">@others
</t>
<t tx="ekr.20070127142841.374">def getLeoFile( self,fileName,readAtFileNodesFlag=True ):
    
    c = self.c
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    leoNodes.vid_vnode = {}
    import javax.xml.parsers as jparse
    import java.io as io
    import java
    start = java.lang.System.currentTimeMillis()
    c.loading = True
    try:
        dbf = jparse.DocumentBuilderFactory.newInstance()
        db = dbf.newDocumentBuilder()
        fis = io.FileInputStream( fileName )
        doc = db.parse( fis )
        fis.close()
        doc.normalizeDocument()
        leo_file = doc.getDocumentElement()
        #print leo_file.getTextContent()
        cnodes = leo_file.getChildNodes()
        elements = {}
        for z in xrange( cnodes.length ):
            element = cnodes.item( z )
            elements[ element.getNodeName() ] = element
        
        #c.beginUpdate() 
        &lt;&lt; read leo header &gt;&gt;
        &lt;&lt; read globals &gt;&gt;
        &lt;&lt; read prefs &gt;&gt;
        &lt;&lt; read find panel settings &gt;&gt;
        &lt;&lt; build tnodes &gt;&gt;
        &lt;&lt; build vnodes &gt;&gt;

        current = self.convertStackToPosition(self.currentVnodeStack)
        if current:
            c.setCurrentPosition(current)
        else:
            # g.trace(self.currentVnodeStack)
            c.setCurrentPosition(c.rootPosition())
    
        # At present this is useless: the drawing code doesn't set the top position properly.
        top = self.convertStackToPosition(self.topVnodeStack)
        if top:
            c.setTopPosition(top)
        
        #if elements.has_key( "data" ):
        #    g.doHook( "read-leo-file-data", c=c, delement = elements[ 'data' ], doc = doc )
        ok = 1
        self.ratio = 1.5
    except java.lang.Exception, x:
        print x
        print "WHATDA!!!"
        ok = 0
        self.ratio = 1.5
        pass
    
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        print c.rootPosition()
        c.setCurrentPosition(c.rootPosition())
        
    if elements.has_key( "data" ):
        g.doHook( "read-leo-file-data", c=c, delement = elements[ 'data' ], doc = doc )

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    &lt;&lt; expand nodes &gt;&gt;
    end = java.lang.System.currentTimeMillis()
    print "TOTAL TIME %s" % ( end - start )
    print "READ FOR %s" % fileName
    return ok, self.ratio

</t>
<t tx="ekr.20070127142841.375">self.maxTnodeIndex = 0
self.numberOfTnodes = 0
leo_header = elements[ 'leo_header' ]
if leo_header.hasAttribute( "file_format" ): self.fileFormatNumber = int( leo_header.getAttribute( "file_format" ) )
if leo_header.hasAttribute( "tnodes" ): self.numberOfTnodes = int( leo_header.getAttribute( "tnodes" ) )
if leo_header.hasAttribute( "max_tnode_index" ): self.maxTnodeIndex = int( leo_header.getAttribute( "max_tnode_index" ) )
#if leo_header.hasAttribute( "clone_windows" ): pass

</t>
<t tx="ekr.20070127142841.376">globals = elements[ 'globals' ]
self.ratio = None
y,x,h,w = None, None, None, None
if globals.hasAttribute( "body_outline_ratio" ):
    self.ratio = float( globals.getAttribute( "body_outline_ratio" ) )

gwp = globals.getElementsByTagName( "global_window_position" )
if gwp.length:
    gwp = gwp.item( 0 )
    w = int( gwp.getAttribute( "width" ) )
    h = int( gwp.getAttribute( "height" ) )
    x = int( gwp.getAttribute( "left" ) )
    y = int( gwp.getAttribute( "top" ) )



if self.ratio == None: self.ratio = 0.5
if y == None: y,x,h,w = 50,50,500,700
self.frame.setTopGeometry(w,h,x,y)
self.frame.deiconify()
self.frame.lift()
self.frame.update()

</t>
<t tx="ekr.20070127142841.377"></t>
<t tx="ekr.20070127142841.378">fp_element = elements[ 'find_panel_settings' ]



@
    if self.getOpenTag("&lt;find_panel_settings"):
        return # &lt;find_panel_settings/&gt; seen.
    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag("&gt;"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only &lt;find_string&gt; or &lt;find_string/&gt;
    if self.getOpenTag("&lt;find_string&gt;"):
        pass
    else:
        self.getEscapedString() ; self.getTag("&lt;/find_string&gt;")
    # Allow only &lt;change_string&gt; or &lt;change_string/&gt;
    if self.getOpenTag("&lt;change_string&gt;"):
        pass
    else:
        self.getEscapedString() ; self.getTag("&lt;/change_string&gt;")
    self.getTag("&lt;/find_panel_settings&gt;")</t>
<t tx="ekr.20070127142841.379">tnodes_element = elements[ 'tnodes' ]
tchildren = tnodes_element.getElementsByTagName( "t" )
tnodes = {}
for z in xrange( tchildren.length ):
    tnode_element = tchildren.item( z )
    tx = tnode_element.getAttribute( "tx" )
    atnode = self.newTnode( tx )
    atnode.bodyString = tnode_element.getTextContent()
    tatts = tnode_element.getAttributes()
    tatts.removeNamedItem( "tx" )
    if tatts.length:
        atnode.unknownAttributes = {}
        for z2 in xrange( tatts.length ):
            tatt = tatts.item( z2 )
            tname = tatt.getNodeName()
            val = tatt.getNodeValue()
            try:
                binString = binascii.unhexlify(val)
                val2 = pickle.loads(binString)
                atnode.unknownAttributes[ tname ] = val2
            except:
                atnode.unknownAttributes[ tname ] = val
                

</t>
<t tx="ekr.20070127142841.380">vnodes_elements = elements[ 'vnodes' ]
cnodes = vnodes_elements.getChildNodes()
vnodes = []
for z in xrange( cnodes.length ):
    item = cnodes.item( z )
    if item.getNodeName() == "v":
        vnodes.append( item )
    
back = parent = None # This routine _must_ work on vnodes!
self.currentVnodeStack = []
self.topVnodeStack = []

for _vnode in vnodes:
    vh = _vnode.getElementsByTagName( "vh" )
    append1 = len(self.currentVnodeStack) == 0
    append2 = len(self.topVnodeStack) == 0
    back = self.getVnode2(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2, node = _vnode)
</t>
<t tx="ekr.20070127142841.381">marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    #print gnx
    t = self.tnodesDict.get(gnx)
    if t: 
        expanded[t]=t

expandset = java.util.HashSet()
#print "EXPANDING!!!"
for p in c.all_positions_iter():
    #if marks.get(p.v.t):
    #    p.v.initMarkedBit()
    #    #expandset.add( p.copy() )
    #    # This was the problem: was p.setMark.
    #    # There was a big performance bug in the mark hook in the Node Navigator plugin.
    if p.isExpanded(): #CHANGED: added since there are 2 mechanisms in place
        expandset.add( p.copy() )
        #print "ADD1 %s" % p
        #    #apparently there are 2 mechanisms in place to expand a position-vnode-tnode
        #    #One happens in the getVnode method, actually both happen, one is done via a method
        #    #call the other is done by inclusion in a list.  Quite maddening! :D
        #    tree = self.c.frame.tree
        #    if hasattr( tree, 'tree_reloader' ):
        #        tree.tree_reloader.expand( p.copy() )
    if expanded.get(p.v.t):
        #tree = self.c.frame.tree
        #if hasattr( tree, 'tree_reloader' ):
        #    tree.tree_reloader.expand( p.copy() ) #CHANGED: so the tree will register outlines already open
        p.expand()
        #print "ADD2 %s" % p
        expandset.add( p.copy() )
if hasattr( c.frame.tree, "tree_reloader" ):
    c.frame.tree.tree_reloader.addExpandedSet( expandset )
            </t>
<t tx="ekr.20070127142841.382">def getVnode2( self,parent,back,skip,appendToCurrentStack,appendToTopStack, node ): #node is the &lt;v&gt; element.
    
    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    
    #if node.hasAttribute( "C" ): pass
    #if node.hasAttribute( "D" ): pass
    if node.hasAttribute( "E" ): setExpanded = True
    if node.hasAttribute( "M" ): setMarked = True
    if node.hasAttribute( "O" ): setOrphan = True
    if node.hasAttribute( "T" ): setTop = True
    if node.hasAttribute( "V" ): setCurrent = True

    
    nl = node.getElementsByTagName( "vh" )
    vh = nl.item( 0 )
    headline = vh.getTextContent()    
    tref = node.getAttribute( "t" )
    vid = tref
    #if node.hasAttribute( "vid" ):
    #    vid = node.getAttribute( "vid" )
 
    if skip:
        v = self.getExistingVnode(tref,headline)
        if vid:
            v.vid = vid
            leoNodes.vid_vnode[ vid ] = v
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if vid:
            v.vid = vid
            leoNodes.vid_vnode[ vid ] = v
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
    
    if v:
        atts = node.getAttributes()
        v.unknownAttributes = {}
        for x in xrange( atts.length ):
            item = atts.item( x )
            name = item.getNodeName()
            if name == 'vid' or name == 't': continue
            value = item.getNodeValue()
            try:
                binString = binascii.unhexlify(value)
                val2 = pickle.loads(binString)
                v.unknownAttributes[ name ] = val2
            except:
                v.unknownAttributes[ name ] = value
            
    
    
    if setCurrent:
        self.currentVnodeStack = [v]

    if setTop:
        self.topVnodeStack = [v]
    
    if setExpanded:
        v.initExpandedBit()
    
    if setMarked:
        v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

    if setOrphan:
        v.setOrphan()       
            
    parent = v ; back = None
    nchildren = node.getChildNodes()
    for z in xrange( nchildren.length ):
        #while self.matchTag("&lt;v"):
        child = nchildren.item( z )
        if child.getNodeName() == "v":
            append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
            append2 = appendToTopStack and len(self.topVnodeStack) == 0
            back = self.getVnode2(parent,back,skip,
                appendToCurrentStack=append1,appendToTopStack=append2, node = child)
            
    if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
        #g.trace("append current",v)
        self.currentVnodeStack.append(v)
    
    if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
        #g.trace("append top",v)
        self.topVnodeStack.append(v)
        
    return v


</t>
<t tx="ekr.20070127142841.383">@
In write_Leo_file, I believe the main change is in the 'put the .lef file' node.  Its really one long section that was a series of calls to methods in leoFileCommands.

putVnode2... a converted putVnode
@c



@others
</t>
<t tx="ekr.20070127142841.384">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)  
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        #theActualFile.write(self.outputFile.getvalue())
        theActualFile.write( data )
        theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete backup file &gt;&gt;
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20070127142841.385">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20070127142841.386"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20070127142841.387"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20070127142841.388">import javax.xml.parsers as jparse

dbf = jparse.DocumentBuilderFactory.newInstance()
db = dbf.newDocumentBuilder()
doc = db.newDocument()
def nl( element, doc = doc, indent = 0 ):
    if indent:
        wsi = " " * indent
    else:
        wsi = ""
    tn = doc.createTextNode( "\n%s" % wsi  )
    element.appendChild( tn )
    
#de = doc.getDocumentElement()
#nl( de )
leo_file = doc.createElement( "leo_file" )
#nl( doc )
doc.appendChild( leo_file )
nl( leo_file, indent = 4 )

tnodes = 0 ; clone_windows = 0 
header = doc.createElement( "leo_header" )
leo_file.appendChild( header )
nl( leo_file )
header.setAttribute( "file_format", "2" )
header.setAttribute( "tnodes", str( tnodes ) )
header.setAttribute( "max_tnode_index", str( self.maxTnodeIndex ) )
header.setAttribute( "clone_windows", str( clone_windows ) )


globals = doc.createElement( "globals" )
nl( globals )
nl( leo_file, indent = 4 )
leo_file.appendChild( globals )
globals.setAttribute( "body_outline_ratio", str( c.frame.ratio ) )

global_window_position = doc.createElement( "global_window_position" )
globals.appendChild( global_window_position )
width,height,left,top = c.frame.get_window_info()
global_window_position.setAttribute( "top", str( top ) )
global_window_position.setAttribute( "left", str( left ) )
global_window_position.setAttribute( "height", str( height ) )
global_window_position.setAttribute( "width", str( width ) )

nl( globals )
top = left = height = width = 0 # no longer used
global_log_window_position = doc.createElement( "global_log_window_position" )
globals.appendChild( global_log_window_position )
global_log_window_position.setAttribute( "top", str( top ) )
global_log_window_position.setAttribute( "left", str( left ) )
global_log_window_position.setAttribute( "height", str( height ) )
global_log_window_position.setAttribute( "width", str( width ) )

preferences = doc.createElement( "preferences" )
nl( leo_file )
leo_file.appendChild( preferences )

find_panel_settings = doc.createElement( "find_panel_settings" )
nl( leo_file )
leo_file.appendChild( find_panel_settings )
data = doc.createElement( "data" ) #here the general data area where Im putting the pickled undo manager is created
nl( leo_file )
leo_file.appendChild( data )


c.clearAllVisited()
vnodes = doc.createElement( "vnodes" )
nl( leo_file )
leo_file.appendChild( vnodes )
nl( leo_file )
self.currentPosition = c.currentPosition() 
self.topPosition     = c.topPosition()
for p in c.rootPosition().self_and_siblings_iter():
    self.putVnode2( p, ignored = False, doc = doc, vnode = vnodes )
    


tnodes_element = doc.createElement( "tnodes" )
nl( leo_file )
leo_file.appendChild( tnodes_element )
nl( leo_file )
if self.usingClipboard: # write the current tree.
    theIter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    theIter = c.allNodes_iter()
    
tnodes = {}

for p in theIter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        #self.putTnode(t)
        t_element = doc.createElement( "t" )
        nl( tnodes_element )
        tnodes_element.appendChild( t_element )
        gnx = g.app.nodeIndices.toString(t.fileIndex)
        t_element.setAttribute( "tx", gnx )
        if t.bodyString:
            t_element.setTextContent( self.xmlEscape( t.bodyString ) )
        if hasattr( t, 'unknownAttributes' ):
            uAs = t.unknownAttributes
            for key in uAs.keys():
                val = uAs[ key ]
                try:
                    if hasattr( val, 'getPickleProxy' ):
                        val = val.getPickleProxy()
                    try:
                        # Protocol argument is new in Python 2.3
                        # Use protocol 1 for compatibility with bin.
                        s = pickle.dumps(val,protocol=1)
                    except TypeError:
                        s = pickle.dumps(val,bin=True)
                    #key,binascii.hexlify(s)
                    t_element.setAttribute( key, binascii.hexlify( s ) )
                except:
                    g.es("ignoring non-pickleable attribute %s in %s" % (key, t ),color="blue")

nl( tnodes_element )

g.doHook( "write-leo-file-data", c = c, delement = data, doc = doc ) #I notify listeners so they can add data to the &lt;data&gt; element... should it be hidden behind a class?
            
import javax.xml.transform as transform
import javax.xml.transform.dom as tdom
import java.io as io
import javax.xml.transform.stream as sresult
tf = transform.TransformerFactory.newInstance()
trans = tf.newTransformer()
tsource = tdom.DOMSource( doc )
sw = io.StringWriter()
sr = sresult.StreamResult( sw )
trans.transform( tsource, sr )
data = sw.toString()



@
if self.usingClipboard: # write the current tree.
    theIter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    theIter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in theIter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)




@
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()


</t>
<t tx="ekr.20070127142841.389">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20070127142841.390">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20070127142841.391">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20070127142841.392">def putVnode2 (self,p,ignored, doc, vnode ): #doc is the document from which we create elements for the doc.  'doc' probably should be just an attribute of the leoFileCommands instance.  vnode is the 'v' element, its passed so we can append to it.

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    if 0: # Wrong: must check all parents.
        ignored = ignored or p.isAtIgnoreNode()
    else:
        for p2 in p.self_and_parents_iter():
            if p2.isAtIgnoreNode():
                isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)


    v_element = doc.createElement( "v" )
    v_element.setAttribute( "vid", v.vid )
    indent = " " * p.level()
    if p.isRoot():
        ws = doc.createTextNode( "\n" )
    elif p.level() == 0:
        ws = None
    else:
        ws = doc.createTextNode( "\n%s" % indent )
    if ws:
        vnode.appendChild( ws )
    vnode.appendChild( v_element )
    ws = vnode.getPreviousSibling()
    ws = ws.cloneNode( 0 )
    vnode.appendChild( ws )
    #ws = doc.createTextNode( "\n%s" % indent )
    #vnode.appendChild( ws )
    #fc.put("&lt;v")
    &lt;&lt; Put tnode index &gt;&gt;
    &lt;&lt; Put attribute bits &gt;&gt;
    &lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;
    #fc.put("&gt;")
    &lt;&lt; Write the head text &gt;&gt;

    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            #fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode2(p,ignored, doc, v_element )
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()
            

    #fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="ekr.20070127142841.393">if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    #fc.put(" t=") ; fc.put_in_dquotes(gnx)
    v_element.setAttribute( "t", gnx )
    v.vid = gnx
    leoNodes.vid_vnode[ gnx ] = v #we set the vid for the node in the vid_node dic, this may not need to happen here, but has to happen in the read
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")</t>
<t tx="ekr.20070127142841.394">attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

#if attr: fc.put(' a="%s"' % attr)
if attr:
    v_element.setAttribute( "a", attr )</t>
<t tx="ekr.20070127142841.395"># I haven't converted this part... shouldn't be too tough

@
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)</t>
<t tx="ekr.20070127142841.396">headString = p.v.headString()

if headString:
    vh = doc.createElement( "vh" )
    indent = " " * ( p.level() + 1 )
    ws = doc.createTextNode( "\n%s" % indent )
    v_element.appendChild( ws )
    v_element.appendChild( vh )
    vh.setTextContent( headString )
    if p.numberOfChildren() == 0:
        ws = doc.createTextNode( "\n%s" % indent[ : -1 ] )
        v_element.appendChild( ws )
        
    #fc.put("&lt;vh&gt;")
    #fc.putEscapedString(headString)
    #fc.put("&lt;/vh&gt;")
</t>
<t tx="ekr.20070127142841.397">if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")</t>
<t tx="ekr.20070127142841.398"></t>
<t tx="ekr.20070127142841.399">def getColorInstance( val, OnNone=None ):
    
    if hasattr( awt.Color, val ):
        return getattr( awt.Color, val )
    else:
        try:
            l = java.lang.Long.parseLong( val, 16 )
            l2 = java.lang.Long( l )
            color = awt.Color.decode( "%s" % l2.intValue() )
            return color
            
        except java.lang.Exception, x:
            #print 'WHATDA!!!!  %s' % x
            pass
    
    return OnNone</t>
<t tx="ekr.20070127142841.400">class leoJSPFocusListener( aevent.FocusListener ):
    '''A Class that changes the border of a focused JViewPort'''
    
    _listeners = {}
    
    def __init__( self, jsp, c ):
        self.jsp = jsp
        self.c = c
        color = g.app.config.getColor( c, "component_focused_bordor_color" )
        self.fcolor = getColorInstance( color, awt.Color.RED )
        color = g.app.config.getColor( c, "component_unfocused_bordor_color" )
        self.ucolor = getColorInstance( color, awt.Color.GREEN )
        
        self.border = self.LineBorder2( self.ucolor )
        jsp.setViewportBorder( self.border )
        if not leoJSPFocusListener._listeners.has_key( c ):
            group =  leoJSPFocusListener._listeners[ c ] = []
        else:
            group = leoJSPFocusListener._listeners[ c ]
        group.append( self )

    def focusGained( self, event ):
        
        self.border.setColor( self.fcolor )
        self.jsp.repaint()
        group = leoJSPFocusListener._listeners[ self.c ] 
        for x in group:
            if x == self: continue
            else:
                x.border.setColor( self.ucolor )
                x.jsp.repaint()
    
    def focusLost( self, event ):
        pass 
        
        
    class LineBorder2( sborder.LineBorder ):
        
        def __init__( self, color ):
            sborder.LineBorder.__init__( self, color )
            self.color = color
            
            
        def setColor( self, color ):
            self.color = color
            
            
        def paintBorder( self, c, g, x,y,w,h ):
            
            g.setColor( self.color )
            g.drawRect( x, y, w -1, h -1 )
            </t>
<t tx="ekr.20070127142841.401">class VisibleInformer( sevent.ChangeListener ):
    '''A class that allows a change in the tab of a tabbed pane to
       be used as a notification to registered callbacks.'''
       
    def __init__( self, tabbedpane ):
        self.tabbedpane = tabbedpane #should be a JTabbedPane, or at least a component that has:
                                     #getSelectedComponent and an addChangeListener method
        tabbedpane.addChangeListener( self )
        self.callbacks = {}
        
    def addCallback( self, component, callback ):
        self.callbacks[ component ] = callback
        
    def stateChanged( self, event ):
        
        component = self.tabbedpane.getSelectedComponent()
        if self.callbacks.has_key( component ):
            self.callbacks[ component ]()    
    </t>
<t tx="ekr.20070127142841.402">class GCEveryOneMinute( java.lang.Thread ):
    
    def __init__( self ):
        java.lang.Thread.__init__( self )
        
    def run( self ):
        
        while 1:
            java.lang.System.gc()
            self.sleep( 60000 )</t>
<t tx="ekr.20070127142841.403"></t>
<t tx="ekr.20070127142841.404">import leoGlobals as g 
import leoFind  
import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.table as stable
import javax.swing.event as sevent
import java.util.HashSet as hset
import java.awt as awt   
import java.awt.event as aevent
import java.lang


class leoSwingFind (leoFind.leoFind ):

    """A class that implements Leo's tkinter find dialog."""

    @others</t>
<t tx="ekr.20070127142841.405"></t>
<t tx="ekr.20070127142841.406">def __init__(self,c, title="Find/Change",resizeable=False ):
    
    # Init the base classes...

    leoFind.leoFind.__init__(self, c)
    self.title = title
    g.app.findFrame = self
    #leoTkinterDialog.leoTkinterDialog.__init__(self,title,resizeable)

    &lt;&lt; init the tkinter ivars &gt;&gt;
    self.c = c
    #self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.lasPos = None
    self.reverse_flag = False
    self.selection = False
    
</t>
<t tx="ekr.20070127142841.407">self.dict = {}
  


for key in self.intKeys:
    self.dict[key] = self.fakeIntTkVar()

for key in self.newStringKeys:
    self.dict[key] = self.fakeStringTkVar()
    
#self.s_text = Tk.Text() # Used by find.search()
self.s_text = "HI" #AssertionError without</t>
<t tx="ekr.20070127142841.408">class fakeStringTkVar:
    
    def __init__( self ):

        self.sb = ""
    
    def get( self ):
        return self.sb
        
    def set( self, value ):  

        self.sb = value
        
class fakeIntTkVar:
    
    def __init__( self ):
        self.val = 0
        
    def get( self ):
        return self.val
        
    def set( self, value ):
        self.val = value</t>
<t tx="ekr.20070127142841.409">def destroySelf (self):
    
    self.top.destroy()</t>
<t tx="ekr.20070127142841.410">def createFrame (self):

    # Create the find panel...
    #outer = Tk.Frame(self.frame,relief="groove",bd=2)
    #outer.pack(padx=2,pady=2)
    self.top = swing.JFrame()
    g.app.gui.addLAFListener( self.top )
    #self.top.setDefaultCloseOperation( swing.JFrame.EXIT_ON_CLOSE )
    self.top.title = self.title
    jtab = swing.JTabbedPane()
    self.top.add( jtab )
    cpane = swing.JPanel()
    jtab.addTab( "regular search", cpane )
    clnsearch = swing.JPanel()
    clnsearch.setName( "Leodialog" )
    jtab.addTab( "node search", clnsearch )
    #cpane = outer.getContentPane()
    cpane.setName( "Leodialog" )
    cpane.setLayout( awt.GridLayout( 3, 1 ) )

    
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;
    
    self.createNodeSearchFrame( clnsearch )
    #self.top.setSize( 500, 500 )
    self.top.pack()
    size = self.top.getSize()
    size.width = size.width + 50
    self.top.setSize( size )
    splitpane.setDividerLocation( .5 )
    #outer.visible = True
    
    #for widget in (self.find_text, self.change_text):
    #    widget.bind ("&lt;1&gt;",  self.resetWrap)
    #    widget.bind("&lt;Key&gt;", self.resetWrap)
    #    widget.bind("&lt;Control-a&gt;",self.selectAll)
    #    #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    #for widget in (outer, self.find_text, self.change_text):
    #    widget.bind("&lt;Key-Return&gt;", self.findButton)
    #    widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)
    
    #self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)


</t>
<t tx="ekr.20070127142841.411">#fc = Tk.Frame(outer, bd="1m")
#fc.pack(anchor="n", fill="x", expand=1)
findPanel = self.findPanel = swing.JTextArea()
self.CutCopyPaste( findPanel )
fspane = swing.JScrollPane( findPanel )

self.changePanel = changePanel = swing.JTextArea()
self.CutCopyPaste( changePanel )
cpane2 = swing.JScrollPane( changePanel )
splitpane = swing.JSplitPane( swing.JSplitPane.VERTICAL_SPLIT, fspane, cpane2 )
splitpane.setDividerLocation( .5 )
#outer.getContentPane().add( splitpane )
cpane.add( splitpane )
#outer.pack()


# Removed unused height/width params: using fractions causes problems in some locales!
#fpane = Tk.Frame(fc, bd=1)
#cpane = Tk.Frame(fc, bd=1)

#fpane.pack(anchor="n", expand=1, fill="x")
#cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
#flab = Tk.Label(fpane, width=8, text="Find:")
#clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
#self.find_text   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
#3self.change_text = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

#fBar = Tk.Scrollbar(fpane,name='findBar')
#cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
#for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
#    txt['yscrollcommand'] = bar.set
#    bar['command'] = txt.yview
#    bar.pack(side="right", fill="y")

#flab.pack(side="left")
#clab.pack(side="left")
#ctxt.pack(side="right", expand=1, fill="both")
#ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="ekr.20070127142841.412">#columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
#columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.
columnsFrame = swing.JPanel()
columnsFrame.setLayout( swing.BoxLayout( columnsFrame, swing.BoxLayout.X_AXIS ) )
cpane.add( columnsFrame, awt.BorderLayout.SOUTH )

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []; buttonGroups = []
for i in xrange(numberOfColumns):
    #columns.append(Tk.Frame(columnsFrame,bd=1))
    jp = swing.JPanel()
    jp.setLayout( swing.BoxLayout( jp, swing.BoxLayout.Y_AXIS ) )
    columns.append( jp )
    radioLists.append([])
    checkLists.append([])
    buttonGroups.append( swing.ButtonGroup() )

for i in xrange(numberOfColumns):
    columnsFrame.add( columns[ i ] )
    #columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
    (self.dict["radio-find-type"],"Plain Search","plain-search"),  
    (self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"Script Search","script-search")]
checkLists[0] = [
    ("Script Change",self.dict["script_change"])]
checkLists[1] = [
    ("Whole Word",  self.dict["whole_word"]),
    ("Ignore Case", self.dict["ignore_case"]),
    ("Wrap Around", self.dict["wrap"]),
    ("Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only","selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search Headline Text", self.dict["search_headline"]),
    ("Search Body Text",     self.dict["search_body"]),
    ("Mark Finds",           self.dict["mark_finds"]),
    ("Mark Changes",         self.dict["mark_changes"])]
    
    
class rAction( swing.AbstractAction ):
    
    def __init__( self, name, var , val ):
        swing.AbstractAction.__init__( self, name )
        self.name = name
        self.var = var
        self.val = val
        
    def actionPerformed( self, aE ):
        self.var.set( self.val )
        
class jcbAction( swing.AbstractAction ):
    
    def __init__( self, name, var ):
        swing.AbstractAction.__init__( self, name )
        self.var = var
        
    def actionPerformed( self, ae ):
    
        val = self.var.get()
        if val:
            self.var.set( 0 )
        else:
            self.var.set( 1 )

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        aa = rAction( name, var, val )
        but = swing.JRadioButton( aa )
        columns[ i ].add( but )
        buttonGroups[ i ].add( but )
        #box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
        #box.pack(fill="x")
        #box.bind("&lt;1&gt;", self.resetWrap)
        #if val == None: box.configure(state="disabled")
    for name, var in checkLists[i]:
        cbut = swing.JCheckBox( jcbAction( name, var ) )
        columns[ i ].add( cbut )
        #box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
        #box.pack(fill="x")
        #box.bind("&lt;1&gt;", self.resetWrap)
        #if var is None: box.configure(state="disabled")

for z in buttonGroups:
    
    elements = z.getElements()
    for x in elements:
        x.setSelected( True )
        break
</t>
<t tx="ekr.20070127142841.413"># Create the button panes
secondGroup = swing.JPanel()
secondGroup.setLayout( awt.GridLayout( 2, 3 , 10, 10 ) )
cpane.add( secondGroup )
#buttons  = Tk.Frame(outer,bd=1)
#buttons2 = Tk.Frame(outer,bd=1)
#buttons.pack (anchor="n",expand=1,fill="x")
#buttons2.pack(anchor="n",expand=1,fill="x")
class commandAA( swing.AbstractAction ):
    
    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command
        
    def actionPerformed( self, aE ):
        self.command()


# Create the first row of buttons
#findButton=Tk.Button(buttons,width=8,text="Find",bd=4,command=self.findButton) # The default.
#contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
#findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)
findButton = swing.JButton( commandAA( "Find", self.findButton ) )
contextBox = swing.JCheckBox( "Show Context" )
findAllButton = swing.JButton( commandAA( "Find All", self.findAllButton ) )
secondGroup.add( findButton )
secondGroup.add( contextBox )
secondGroup.add( findAllButton )

#findButton.pack   (pady="1p",padx="25p",side="left")
#contextBox.pack   (pady="1p",           side="left",expand=1)
#findAllButton.pack(pady="1p",padx="25p",side="right",fill="x",)

# Create the second row of buttons
#changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
#changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
#changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)
changeButton = swing.JButton( commandAA( "Change", self.changeButton ) )
changeFindButton = swing.JButton( commandAA( "Change, Then Find", self.changeThenFindButton ) )
changeAllButton = swing.JButton( commandAA( "Change All", self.changeAllButton ) )
secondGroup.add( changeButton )
secondGroup.add( changeFindButton )
secondGroup.add( changeAllButton )

#changeButton.pack    (pady="1p",padx="25p",side="left")
#changeFindButton.pack(pady="1p",           side="left",expand=1)
#changeAllButton.pack (pady="1p",padx="25p",side="right")</t>
<t tx="ekr.20070127142841.414">def createNodeSearchFrame( self, clnpanel ):
    
    clnpanel.setLayout( awt.BorderLayout() )
    oclnpanel = clnpanel
    clnpanel = swing.Box.createHorizontalBox()
    oclnpanel.add( clnpanel, awt.BorderLayout.CENTER )
    
    
    jta = swing.JTextArea()
    self.CutCopyPaste( jta )
    tp = swing.JPanel( awt.GridLayout( 1, 1 ))
    self.nstext = jta
    sp = swing.JScrollPane( jta )

    border = sp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Base Text" )
    sp.setBorder( tborder )
    tp.add( sp )
    clnpanel.add( tp )
    
    
    bpanel = swing.JPanel()
    spl = swing.SpringLayout()
    bpanel.setLayout( spl )  
    executebox = swing.Box.createHorizontalBox()
    border = executebox.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searching" )
    executebox.setBorder( tborder )
    bpanel.add( executebox )
    spl.putConstraint( spl.NORTH, executebox, 5, spl.NORTH, bpanel )
    clnsearch = swing.JButton( "Clone Search" )
    clnsearch.actionPerformed = self.nodeSearch
    executebox.add( clnsearch )
    #spl.putConstraint( spl.NORTH, clnsearch, 5, spl.NORTH, bpanel )
    cpysearch = swing.JButton( "Copy Search" )
    cpysearch.actionPerformed = lambda event: self.nodeSearch( event, type='copy' ) 
    #bpanel.add( cpysearch )
    #spl.putConstraint( spl.NORTH, cpysearch, 5, spl.SOUTH, clnsearch )
    executebox.add( cpysearch )
    
    self.all_searches = rb1 = swing.JCheckBox( "Match Searches" )
    mtext = """Selecting causes the search system to only recognize a node if all searches match"""
    rb1.setToolTipText( mtext ) 
    bpanel.add( rb1 )
    spl.putConstraint( spl.NORTH, rb1, 5, spl.NORTH, bpanel )
    spl.putConstraint( spl.WEST, rb1, 5, spl.EAST, executebox )
    
    
    self.all_filters = rb2 = swing.JCheckBox( "Match Filters" )
    mtext = """Selecting causes the filter system to only filter out a node if all searches match"""
    rb2.setToolTipText( mtext )
    bpanel.add( rb2 )
    spl.putConstraint( spl.NORTH, rb2, 5, spl.SOUTH, rb1 )
    spl.putConstraint( spl.WEST, rb2, 5, spl.EAST, executebox )
    
    spl2 = swing.SpringLayout()
    sandf = swing.JPanel( spl2 )
    sandf.setPreferredSize( awt.Dimension( 275, 85 ) )
    border = sandf.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Derive Searches and Filters" )
    sandf.setBorder( tborder )
    bpanel.add( sandf )
    spl.putConstraint( spl.NORTH, sandf, 5, spl.SOUTH, executebox )
    
    b1 = swing.JButton( "+ as Search" )
    b1.setActionCommand( "search" )
    b1.actionPerformed = self.addAsSearchOrExclude
    b2 = swing.JButton( "+ as Filter" )
    b2.setActionCommand( "filter" )
    b2.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b1 ); sandf.add( b2 )
    spl2.putConstraint( spl2.NORTH, b1, 5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.NORTH, b2, 5, spl2.SOUTH, b1 )
    b3 = swing.JButton( "+ as Regex-Search" )
    b3.setActionCommand( "regex-search" )
    b3.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b3 )
    spl2.putConstraint( spl2.NORTH, b3,5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.WEST, b3,5, spl2.EAST, b1 )
    #spl2.putConstraint( spl2.EAST, b3, 5, spl2.EAST, executebox )
    b4 = swing.JButton( "+ as Regex-Filter" )
    b4.setActionCommand( "regex-filter" )
    b4.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b4 )
    spl2.putConstraint( spl2.NORTH, b4, 5, spl2.SOUTH, b1 )
    spl2.putConstraint( spl2.WEST, b4, 5, spl2.EAST, b2 )
    clear = swing.JButton( "Clear Text" )
    def clear_txt( event, text = jta ):
        
        jta.setText( "" )
    clear.actionPerformed = clear_txt
    bpanel.add( clear )
    spl.putConstraint( spl.NORTH, clear, 5, spl.SOUTH, sandf )
    
    
    clnpanel.add( bpanel )
    tp.setPreferredSize( awt.Dimension( 200, 100 ) )
    clnpanel.setPreferredSize( awt.Dimension( 200, 100 )) 
    
    class dtm2( stable.DefaultTableModel ):
        
        def __int__( self ):
            stable.DefaultTableModel.__init__( self )
            
        def isCellEditable( self, a, b ):
            if b == 1:
                return False
            return True
        
    self.dtm = dtm = dtm2()
    dtm.addColumn( "Text" )
    dtm.addColumn( "Type" )
    jp = swing.JPanel( awt.BorderLayout() )
    self.table = jt = swing.JTable( dtm )
    jt.getColumn( "Text" ).setCellEditor( self._LeoTableCellEditor() )
    jt.getColumn( "Text" ).setCellRenderer( self._LeoTableCellRenderer() )
    
    rmv = swing.JButton( "Remove" )
    def rmv_row( event, jt = jt, dtm = dtm ):
        
        row = jt.getSelectedRow()
        if row != -1:
            dtm.removeRow( row )
        
    rmv.actionPerformed = rmv_row
    rmva = swing.JButton( "Clear" )
    def rmv_all( event, jt = jt, dtm = dtm ):
        
        rc = dtm.getRowCount()
        for z in xrange( rc ):
            dtm.removeRow( 0 )       
        
    rmva.actionPerformed = rmv_all   
    rmvp = swing.Box.createVerticalBox()
    rmvp.add( rmv )
    rmvp.add( rmva )
    jp.add( rmvp, awt.BorderLayout.EAST )
    jtsp = swing.JScrollPane( jt )
    border = jtsp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searchers and Filters" )
    jtsp.setBorder( tborder )
    jp.add( jtsp )

    jp.setPreferredSize( clnpanel.getPreferredSize() )
    oclnpanel.add( jp, awt.BorderLayout.SOUTH )
    </t>
<t tx="ekr.20070127142841.415">def addAsSearchOrExclude( self, event ):
    
    source = event.getSource()
    ac = source.getActionCommand()
    
    doc = self.nstext.getDocument()
    txt = doc.getText( 0, doc.getLength() )
    
    self.dtm.addRow( ( java.lang.String( txt ), ac ) )</t>
<t tx="ekr.20070127142841.416">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        val = getattr(c, key + "_flag")
        val = g.choose(val,1,0) # 2/1/04: work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20070127142841.417">self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)</t>
<t tx="ekr.20070127142841.418">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20070127142841.419">def update_ivars2 (self ): #was called set_ivars
    
    # N.B.: separate c.ivars are much more convenient than a dict.
    c = self.c
    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(c, key + "_flag", val)
        # g.trace(key,val)

    # Set ivars from radio buttons. 10/2/01: convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    c.pattern_match_flag = g.choose(find_type == "pattern-search",1,0)
    c.script_search_flag = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    c.suboutline_only_flag = g.choose(search_scope == "suboutline-only",1,0)
    c.node_only_flag       = g.choose(search_scope == "node-only",1,0)
    c.selection_only_flag  = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    #s = self.find_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.find_text = s
    s = self.findPanel.getText()
    c.find_text = s

    #s = self.change_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.change_text = s
    s = self.changePanel.getText()
    c.change_text = s</t>
<t tx="ekr.20070127142841.420">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0) 
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03
    
    self.reverse_flag = self.dict[ 'reverse' ].get()

    #s = self.find_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.findPanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.find_text = s

    #s = self.change_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.changePanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20070127142841.421">def onCloseWindow(self,event=None):

    self.top.dispose()
    self.top = None</t>
<t tx="ekr.20070127142841.422">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = g.top() ; #t = self.find_text ; 
    gui = g.app.gui
    t = self.findPanel
    width, height = gui._calculateCenteredPosition( self.top )
    self.top.setLocation( width, height )        
    #self.top.withdraw() # Helps bring the window to the front.
    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1

    gui.set_focus(c,t)
    gui.setTextSelection (t, 0, len( t.getText() )) # Thanks Rich.
</t>
<t tx="ekr.20070127142841.423">def selectAll (self,event=None):

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.</t>
<t tx="ekr.20070127142841.424">def gui_search (self,t,*args,**keys):
    nocase = keys[ 'nocase' ]
    backwards = keys[ 'backwards' ]
    regexp = keys[ 'regexp' ]
    stopindex = keys[ 'stopindex' ]
    
    if self.pattern_match:
        import java.util.regex as reg
        flags = 0
        if not regexp:
            flags = flags|reg.Pattern.LITERAL
        if nocase:
            flags = flags|reg.Pattern.CASE_INSENSITIVE
        flags = java.lang.Integer( flags )
    
        pat = args[ 0 ]
        pat = reg.Pattern.compile( pat, flags.intValue() )
        match = pat.matcher( java.lang.String( t ) )
        if stopindex:
            match = match.region( 0, stopindex )
        
        if backwards:
            start = -1
            end = -1
            while match.find():
                start = match.start()
                end = match.end()
            return start, end
        else:
            found = match.find()
            if found:
                return ( match.start(), match.end() )
            else: return None, None
    else:
        if backwards:
            where = t.rfind( args[ 0 ] )
            if where != -1:
                return where, where + len( args[ 0 ] )
            else:
                return None, None
        else:
            match = java.lang.String( t ).indexOf( args[ 0 ] )
            if match != -1:
                return match, match + len( args[ 0 ] )
            else:
                return None, None
    #return t.search(*args,**keys)

def init_s_ctrl (self,s):
    c = self.c ; #t = self.s_text	
    return c.frame.body.editor.editor
    #t.delete("1.0","end")
    #t.insert("end",s)
    #t.mark_set("insert",g.choose(c.reverse_flag,"end","1.0"))
    #return t
</t>
<t tx="ekr.20070127142841.425">def search (self):

    """Searches the present headline or body text for c.find_text and returns True if found.

    c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search."""
    
    __pychecker__ = '--no-implicitreturns' # Suppress bad warning.

    self.p = self.c.currentPosition()
    c = self.c ; p = self.p 
    self.v = p
    se = 0
    index = 0
    stopindex = 0
    editor = self.c.frame.body.editor.editor
    caret_pos = editor.getCaretPosition()
    doc = editor.getDocument()

    if self.selection:
        txt = editor.getSelectedText()
    else:
        if self.reverse_flag:
            txt = doc.getText( 0, caret_pos )
        else:
            txt = doc.getText( caret_pos, doc.getLength() - caret_pos )
    #xt = editor.getText( caret_pos, len( txt ) )
    find_text = self.findPanel.getText()
    pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)
                    
    notin = ( None, -1 )        
    if self.node_only: 
        if pos[ 0 ] in notin and pos[ 1 ] in notin:
            return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
    if self.selection:
        if pos[ 0 ] in notin and pos[ 1 ] in notin: return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
    
    if pos[ 0 ] in notin and pos[ 1 ] in notin:
        #if self.suboutline_only:
        #    iterator = self.p.children_iter()
        #else:
        #    iterator = self.p.allNodes_iter()
        #    for z in iterator:
        #        if z == p: break
        
        self.v = z = self.selectNextVnode()
        while z:
            #if z == p: continue
            txt = z.bodyString()
            pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)
            if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
                c.beginUpdate()
                c.selectPosition( z )
                c.endUpdate()
                return pos
            else:
                self.v = z = self.selectNextVnode()     
    else:
        if self.reverse_flag:
            npos = pos[ 1 ], pos[ 0 ]
        else:
            npos = pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
        return npos
    
    return None, None        
    
@
    if self.lasPos and self.lasPos == v:
        ed = self.c.frame.body.editor.editor
        se = ed.getCaretPosition()
        t = ed.getText()
        t = t[ se: ]
        #t = ed.getText( se, len( ed.getText() ) - se  )
    else:
        t = v.bodyString()
        self.lasPos = v.copy()
    gui = g.app.gui

    assert(c and v)
    if c.selection_only_flag: # 11/9/03
        index,stopindex = self.selStart, self.selEnd
        # g.trace(index,stopindex,v)
        if index == stopindex:
            return None, None
    else:
        #index = gui.getInsertPoint(t)
        index = v.v.t.insertSpot
        stopindex = g.choose(c.reverse_flag,gui.firstIndex(),gui.lastIndex())
    sub_iter = self.v.allNodes_iter( copy = True )
    sub_iter.first = self.v.copy()
    for z in sub_iter:
        if self.lasPos and self.lasPos == z:
            ed = self.c.frame.body.editor.editor
            se = ed.getCaretPosition()
            t = ed.getText()
            t = t[ se: ]
        else:
            se = 0
            t = z.bodyString()
        try:
            pos = self.gui_search(t,c.find_text,index,
                stopindex=stopindex,backwards=c.reverse_flag,
                regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
        except:
            g.es_exception(full=False)
            self.errors += 1
            return None, None
        if not pos:
            continue

        t = self.c.frame.body.editor.editor
        self.c.beginUpdate()
        self.c.frame.tree.select( z )
        self.c.endUpdate()
        t.requestFocusInWindow()
        t.select( pos[ 0 ] + se  , pos[ 1 ] + se )
        return pos[ 0 ] + se, pos[ 1 ] + se

</t>
<t tx="ekr.20070127142841.426">def findButton( self ):
    
    self.setup_button()
    self.executeSearch()
@
    pos = self.search()
    if pos[ 0 ] and pos[ 1 ]:
        editor = self.c.frame.body.editor.editor
        editor.select( pos[ 0 ], pos[ 1 ] )
        #editor.setSelectionStart( pos[ 0 ] )
        #editor.setSelectionEnd( pos[ 1 ] )
        if len(self.change_text ) != 0:
            editor.replaceSelection( self.change_text )

</t>
<t tx="ekr.20070127142841.427">def executeSearch( self ):
    
    pos = self.search()
    if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
        editor = self.c.frame.body.editor.editor
        editor.setCaretPosition( pos[ 0 ] )
        editor.moveCaretPosition( pos[ 1 ] )
        
        if self.mark_finds:
            
            cp = self.c.currentPosition()
            cp.setMarked()
            self.c.frame.tree.redraw()
            
</t>
<t tx="ekr.20070127142841.428">def findNextCommand( self, c ):
    
    self.executeSearch()</t>
<t tx="ekr.20070127142841.429">def changeAll( self ):
    
    cp = self.c.currentPosition().copy()
    
    fdoc = self.findPanel.getDocument()
    cdoc = self.changePanel.getDocument()
    ftxt = self.findPanel.getText( 0, fdoc.getLength() )
    ctxt = self.changePanel.getText( 0, cdoc.getLength() )
    if self.pattern_match:
        import java.util.regex as reg
        pattern = reg.Pattern.compile( ftxt )
        matcher = pattern.matcher( java.lang.String( "" ) )
    for z in cp.allNodes_iter( copy = True ):

        changed = False
        txt = z.bodyString()
        if self.pattern_match:
            matcher.reset( java.lang.String( txt ) )
            ntxt = matcher.replaceAll( java.lang.String( ctxt ) )
        else:
            ntxt = txt.replace( ftxt, ctxt )
                
        if txt != ntxt: changed = True
        if changed:
            z.setBodyStringOrPane( ntxt )
            if self.mark_changes:
                z.setMarked()
                
    self.c.frame.tree.redraw()
            

</t>
<t tx="ekr.20070127142841.430"></t>
<t tx="ekr.20070127142841.431">def nodeSearch( self, event, type = 'clone' ):
    
    all_searches = self.all_searches.isSelected()
    all_filters = self.all_filters.isSelected()
    dvector = self.dtm.getDataVector()
    if dvector.size() == 0: return
    search = []
    rsearch = []
    filter = []
    rfilter = []
    addto = { 'search': search, 'regex-search': rsearch,
              'filter': filter, 'regex-filter': rfilter }
    for z in dvector:
        addto[ z[ 1 ] ].append( z[ 0 ] )

    bstring = 'Used All Searches: %s   Used All Filters: %s' %( all_searches, all_filters )
    bstring = bstring + '\n\nsearches: \n%s' % '\n'.join( search )
    bstring = bstring + '\n\nregex-searches: \n%s' % '\n'.join( rsearch )
    bstring = bstring + '\n\nfilters: \n%s' % '\n'.join( filter )
    bstring = bstring + '\n\nregex-filters: \n%s' % '\n'.join( rfilter )
    bstring = bstring + '\n\n@' + 'others'

    import java.util.regex as reg        
    for z in xrange( len( rfilter ) ):
        pat = reg.Pattern.compile( rfilter[ z ] )
        matcher = pat.matcher( java.lang.String( "" )) 
        rfilter[ z ] = matcher
        
    for z in xrange( len( rsearch ) ):
        pat = reg.Pattern.compile( rsearch[ z ] )
        matcher = pat.matcher( java.lang.String( "" ) )
        rsearch[ z ] = matcher
    




    
    c = self.c
    cp = self.c.currentPosition()
    if not cp.isValid(): return
    c.beginUpdate()
    if type == 'clone':
        chstring = "Clone Search Results:"
    else:
        chstring = "Copy Search Results:"
    container = self.createContainerNode( chstring, bstring )
    haveseen = {}
    haveseen[ container ] = None
    for z in cp.allNodes_iter( copy = True ):
        if z in haveseen: continue
        else:
            haveseen[ z ] = None
        
        if z.getParent() == container: continue
        elif z == container: continue
        bstring = z.bodyString()
        hstring = z.headString()
        found = False

        searchmatches = hset()
        if not found:
            for z2 in search:
                if bstring.find( z2 ) != -1:
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    searchmatches.add( False )
                    break
        
       
        if not found or ( all_searches and False not in searchmatches ):
            for z2 in rsearch:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    break    
        
        filtermatches = hset()
        if found:
            for z2 in filter:
                if bstring.find( z2 ) != -1:
                    filtermatches.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches.add( False )
                    break
            

        
        filtermatches2 = hset()       
        if found:
            for z2 in rfilter:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    filtermatches2.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches2.add( False )
                    break
            
        if all_filters and filtermatches.size() != 0 and filtermatches2.size() != 0 and  (
         ( False not in filtermatches ) and ( False not in filtermatches2 ) ):
            found = False
            
        if found:
            if type == 'clone':
                cln = z.clone( z )
                cln.moveToLastChildOf( container )
            else:
                pos = container.insertAsLastChild()
                cln = z.copyTreeFromSelfTo( pos )
          
    c.frame.tree.tree_reloader.expand( container )
    c.selectPosition( container )  
    c.endUpdate()     
</t>
<t tx="ekr.20070127142841.432">def createContainerNode( self, hs, bs ):
    
    c = self.c
    cp = c.currentPosition()
    np = cp.insertAfter()
    np.v.t.headString = hs
    np.v.t.bodyString = bs
    return np</t>
<t tx="ekr.20070127142841.433">class CutCopyPaste( aevent.MouseAdapter ):
    
    def __init__( self, jtcomponent ):
        
        self.jtcomponent = jtcomponent
        self.popup = popup = swing.JPopupMenu()
        i1 = swing.JMenuItem( "Cut" )
        i1.actionPerformed = lambda event: jtcomponent.cut()
        popup.add( i1 )
        i2 = swing.JMenuItem( "Copy" )
        i2.actionPerformed = lambda event: jtcomponent.copy()
        popup.add( i2 )
        i3 = swing.JMenuItem( "Paste" )
        i3.actionPerformed = lambda event: jtcomponent.paste()
        popup.add( i3 )
        i4 = swing.JMenuItem( "Select All" )
        i4.actionPerformed = lambda event: jtcomponent.selectAll()
        popup.add( i4 )
        jtcomponent.addMouseListener( self )
    
    def mousePressed( self, mevent ):
        
        if mevent.getButton() == mevent.BUTTON3:
            self.popup.show( self.jtcomponent, mevent.getX(), mevent.getY() )
        
</t>
<t tx="ekr.20070127142841.434">class _LeoTableCellEditor( swing.AbstractCellEditor, stable.TableCellEditor ):

    def __init__( self ):
        swing.AbstractCellEditor.__init__( self )  
        self._row = None      
        self._rowh = None   
        self._table = None    
        self.to_be_reset = []
        self.lsners = []
        
    class _deselector( sevent.PopupMenuListener ):
        
        def __init__( self, ced ):
            self.ced = ced
            
        def popupMenuCanceled( self, e):
            self.ced.fireEditingStopped()
            
        def popupMenuWillBecomeInvisible( self, e):
            self.ced.fireEditingStopped()
            
        def popupMenuWillBecomeVisible( self, e):
            pass  
    
    class _lcr( swing.DefaultListCellRenderer ):
        
        def __init__( self , data):
            swing.DefaultListCellRenderer.__init__( self )
            self.data = data
            
        def getListCellRendererComponent( self, list, value, index, isSelected, cellHasFocus):
            
            jta = swing.JTextArea()
            jta.setLineWrap( True )
            jta.setText( self.data ) 
            return jta
            
    def getTableCellEditorComponent( self, table, value, isSelected, row, column):
        

            values = value.split( '\n' )
            self._value = value
            jcb = swing.JComboBox( ( values[ 0 ], ) )
            jcb.addPopupMenuListener( self._deselector( self ) )
            jcb.setEditable( False )
            jcb.setRenderer( self._lcr( value ) )
            if len( values ) &gt; 5:
                jcb.setMaximumRowCount( 0 )
            else:
                jcb.setMaximumRowCount( 1 )
            if isSelected:
                jcb.setForeground( table.getSelectionForeground() )
                jcb.setBackground( table.getSelectionBackground() )
            else:
                jcb.setForeground( table.getForeground() )
                jcb.setBackground( table.getBackground() )
            return jcb

            
    def removeCellEditorListener( self, arg ):
        
        self.lsners.remove( arg )
        
    def addCellEditorListener( self, arg ):
        
        self.lsners.append( arg )

    def fireEditingStopped( self ):
        
        ce = sevent.ChangeEvent( self )
        for z in self.lsners:
            z.editingStopped( ce )
        
    def isCellEditable( self, evobj ):
        return True
        
    def shouldSelectCell( self, evobj ):

        return True
        
    def getCellEditorValue( self ):
        return self._value
        
        
    def stopCellEditing( self ):
        
        self.fireEditingStopped()
        return True
        
</t>
<t tx="ekr.20070127142841.435">class _LeoTableCellRenderer( stable.DefaultTableCellRenderer ):
    
    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )
        
    def getTableCellRendererComponent( self, table, value, isSelected, hasFocus, row, column):
        
        jcb = swing.JComboBox( ( value.split( '\n' )[ 0 ], ) )
        if isSelected:
            jcb.setForeground( table.getSelectionForeground() )
            jcb.setBackground( table.getSelectionBackground() )
        else:
            jcb.setForeground( table.getForeground() )
            jcb.setBackground( table.getBackground() )
            
        return jcb
         

</t>
<t tx="ekr.20070127142841.436">@language python  
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoCompare
import javax.swing as swing
import java.awt as awt
import java.awt.event as aevent
import java
import javax.swing.border as sborder
import javax.swing.table as stable


class leoSwingComparePanel (leoCompare.leoCompare):
    
    """A class that creates Leo's compare panel."""

    @others</t>
<t tx="ekr.20070127142841.437"></t>
<t tx="ekr.20070127142841.438">def __init__ (self,c):
    
    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    #leoTkinterDialog.leoTkinterDialog.__init__(self,"Compare files and directories",resizeable=False)
    self.c = c

    &lt;&lt; init tkinter compare ivars &gt;&gt;
    
    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None
    self._dtm = self._DTM( [  "","Mismatches", ], 0 )
    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"
    
    self.createTopFrame()
    self.createFrame()
</t>
<t tx="ekr.20070127142841.439"># Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []
    
# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = self.IntVar()

# These all correspond to ivars in leoCompare	
self.appendOutputVar             = self.IntVar()

self.ignoreBlankLinesVar         = self.IntVar()
self.ignoreFirstLine1Var         = self.IntVar()
self.ignoreFirstLine2Var         = self.IntVar()
self.ignoreInteriorWhitespaceVar = self.IntVar()
self.ignoreLeadingWhitespaceVar  = self.IntVar()
self.ignoreSentinelLinesVar      = self.IntVar()

self.limitToExtensionVar         = self.IntVar()
self.makeWhitespaceVisibleVar    = self.IntVar()

self.printBothMatchesVar         = self.IntVar()
self.printMatchesVar             = self.IntVar()
self.printMismatchesVar          = self.IntVar()
self.printTrailingMismatchesVar  = self.IntVar()
self.stopAfterMismatchVar        = self.IntVar()</t>
<t tx="ekr.20070127142841.440">class IntVar:
    
    def __init__( self ):
        
        self._val = 0
        
    def get( self ):
        return self._val
        
    def set( self, val ):
        self._val = val
</t>
<t tx="ekr.20070127142841.441">class _DTM( stable.DefaultTableModel ):
    
    def __init__( self, *args ):
        stable.DefaultTableModel.__init__( self, *args )
        
    def isCellEditable( self, row, column ):
        return False
        
</t>
<t tx="ekr.20070127142841.442"># Initialize ivars from config parameters.

def finishCreate (self):
    
    c = self.c
    
    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):
            
        name = c.config.getString(option)
        if name and len(name) &gt; 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)
            
    name = c.config.getString("output_file")
    b = g.choose(name and len(name) &gt; 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)
    
    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)
    
    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        #e.delete(0,"end")
        e.setText( ext )
        #e.insert(0,ext)
        
    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)
    
    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)
    
    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)
    
    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)
    
    n = c.config.getInt("limit_count")
    b = n and n &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.setText( str( n ) )
        #e.delete(0,"end")
        #e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)
    
    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)
        
        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)
        
        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)
        
        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="ekr.20070127142841.443">def createTopFrame( self ):
    
    self.frame = self.top = swing.JDialog()
    g.app.gui.addLAFListener( self.frame )
    self.top.title = "Compare files and directories"</t>
<t tx="ekr.20070127142841.444">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;


    top.pack()
    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()</t>
<t tx="ekr.20070127142841.445">#outer = Tk.Frame(self.frame, bd=2,relief="groove")
#outer.pack(pady=4)

sl = swing.SpringLayout()
outer = self.top.getContentPane() #swing.JPanel()
outer.setLayout( sl )
#self.frame.add( outer )

#row1 = Tk.Frame(outer)
#row1.pack(pady=4)
row1 = swing.JPanel( awt.GridLayout( 3, 4 ) )
outer.add( row1 )
sl.putConstraint( sl.NORTH, row1, 5, sl.NORTH, outer )


row4 = swing.JPanel()
outer.add( row4 )
sl.putConstraint( sl.NORTH, row4, 5, sl.SOUTH, row1 )


sl2 = swing.SpringLayout()
options =  swing.JPanel( sl2 )#swing.Box.createHorizontalBox() #swing.JPanel( sl2 );

outer.add( options )
sl.putConstraint( sl.NORTH, options, 5, sl.SOUTH, row4 )

#ws = Tk.Frame(options)
#ws.pack(side="left",padx=4)
ws = swing.JPanel()
ws.setLayout( awt.GridLayout( 1, 1 ) )
options.add( ws )
sl2.putConstraint( sl2.NORTH, ws, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, ws, 5, sl2.WEST, options )

pr = swing.JPanel()
pr.setLayout( awt.GridLayout( 1, 1 ) )
options.add( pr )
sl2.putConstraint( sl2.NORTH, pr, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, pr, 10, sl2.EAST, ws )
sl2.putConstraint( sl2.SOUTH, options, 5, sl2.SOUTH, pr )
sl2.putConstraint( sl2.EAST, options, 5, sl2.EAST, pr )

lower = swing.JPanel()
outer.add( lower )
sl.putConstraint( sl.NORTH, lower, 5, sl.SOUTH, options )
sl.putConstraint( sl.EAST, lower, 0, sl.EAST, options )

sl.putConstraint( sl.SOUTH, outer, 5, sl.SOUTH, lower )
sl.putConstraint( sl.EAST, outer, 5, sl.EAST, row1 )
</t>
<t tx="ekr.20070127142841.446">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row1,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row1,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    #lab = Tk.Label(row,anchor="e",text=text,width=13)
    #lab.pack(side="left",padx=4)
    lab = swing.JLabel( text )
    row.add( lab )
    
    #e = Tk.Entry(row)
    #e.pack(side="left",padx=2)
    e = swing.JTextField( 15 )
    row.add( e )
    self.browseEntries.append(e)
    
    #b = Tk.Button(row,text="browse...",command=command)
    #b.pack(side="left",padx=6)
    b = swing.JButton( "browse..." )
    b.actionPerformed = lambda event, command = command: command()
    row.add( b )

    #b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    #b.pack(side="left")
    b = swing.JCheckBox( text2 )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    row.add( b )</t>
<t tx="ekr.20070127142841.447">#b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
#    text="Limit directory compares to type:")
#b.pack(side="left",padx=4)
b = swing.JCheckBox( "Limit directory compares to type:" )
b.actionPerformed = lambda event, b=b, var=self.limitToExtensionVar: var.set( b.getModel().isSelected() )
row4.add( b )


#self.extensionEntry = e = Tk.Entry(row4,width=6)
#e.pack(side="left",padx=2)
self.extensionEntry = e = swing.JTextField(5)
row4.add( e )

#b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
#    text="Append output to output file")
#b.pack(side="left",padx=4)

b = swing.JCheckBox( "Append output to outputfile" )
b.actionPerformed = lambda event, b = b, var = self.appendOutputVar: var.set( b.getModel().isSelected() )
row4.add( b )
</t>
<t tx="ekr.20070127142841.448">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")


f.setLayout( awt.GridLayout( 5, 1 ) )
  
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w")
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )


</t>
<t tx="ekr.20070127142841.449">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")
f.setLayout( awt.GridLayout( 5, 1 ) )

#row = Tk.Frame(f)
#row.pack(expand=1,fill="x")
row = swing.JPanel()
sl3 = swing.SpringLayout()
row.setLayout( sl3 )
f.add( row )
pwidth = 0


#b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
#b.pack(side="left",anchor="w")
b = swing.JCheckBox( "Stop after" )
b.actionPerformed = lambda event, var = self.stopAfterMismatchVar, b = b: var.set( b.getModel().isSelected() )
row.add( b )
sl3.putConstraint( sl3.NORTH, b, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, b, 1, sl3.WEST, row )

#self.countEntry = e = Tk.Entry(row,width=4)
#e.pack(side="left",padx=2)
#e.insert(01,"1")
self.countEntry = e = swing.JTextField(5)
row.add( e )
sl3.putConstraint( sl3.NORTH, e, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, e, 1, sl3.EAST, b )

#lab = Tk.Label(row,text="mismatches")
#lab.pack(side="left",padx=2)
lab = swing.JLabel( "mismatches" )
row.add( lab )
sl3.putConstraint( sl3.NORTH, lab, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, lab, 1, sl3.EAST, e )
sl3.putConstraint( sl3.SOUTH, row, 1, sl3.SOUTH, e )
sl3.putConstraint( sl3.EAST, row, 1, sl3.EAST, lab )




for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w",padx=padx)
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )
    self.printButtons.append(b)



# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
#b.configure(command=self.onPrintMatchedLines)

#spacer = Tk.Frame(f)
#spacer.pack(padx="1i")</t>
<t tx="ekr.20070127142841.450">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    #b = Tk.Button(lower,text=text,command=command,width=18)
    #b.pack(side="left",padx=6)
    b = swing.JButton( text )
    b.actionPerformed = lambda event, command=command: command()
    lower.add( b )

</t>
<t tx="ekr.20070127142841.451">def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.getText()
    
    e = self.browseEntries[1]
    self.fileName2 = e.getText()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
    
    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.getText()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        #self._dtm.setRowCount( 0 )
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.getText()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None
        
    self.appendOutput = self.appendOutputVar.get()
    
    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
    
    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()
    
    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False
    
    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0</t>
<t tx="ekr.20070127142841.452">def bringToFront(self):
    
    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1
    self.top.toFront()
    
    </t>
<t tx="ekr.20070127142841.453">def browser (self,n):
    
    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]


    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None
    
    fc = swing.JFileChooser( parent )
    fc.setDialogTitle( "Choose compare file" + n )
    
    
    haveseen = {}
    for z in types:
        if z[ 0 ] in haveseen:
            haveseen[ z[ 0 ] ].extend( z[1] )
        else:
            bf = self.brwsfilter( z )
            fc.addChoosableFileFilter( bf )
            haveseen[ z[ 0 ] ] = bf
        
    result = fc.showOpenDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None
        
    #fileName = tkFileDialog.askopenfilename(
    #    title="Choose compare file" + n,
    #    filetypes=types,
    #    defaultextension=".txt")
        
    if fileName and len(fileName) &gt; 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None
        
    return fileName</t>
<t tx="ekr.20070127142841.454"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)
    
    if dir1 == dir2:
        self.show("Directory names are identical.\nPlease pick distinct directories.")
        return
        
    try:
        list1 = os.listdir(dir1)
    except:
        self.show("invalid directory:" + dir1)
        return
    try:
        list2 = os.listdir(dir2)
    except:
        self.show("invalid directory:" + dir2)
        return
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok:
        return

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and fail lists.
    yes = [] ; no = [] ; fail = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                _file1 = java.io.File( name1 )
                _file2 = java.io.File( name2 )
                if _file1.length() == _file2.length():
                    val = self._filecmp( name1, name2 )                    
                else:
                    val = False
                #val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                fail.append(f1)
        else:
            fail.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found ------",fail)):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None</t>
<t tx="ekr.20070127142841.455">def filecmp (self,f1,f2):

    #val = filecmp.cmp(f1,f2)
    val = self._filecmp( f1, f2 )
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val
    
    
def _filecmp( self, f1, f2 ):
    
    _file1 = java.io.File( f1 )
    _file2 = java.io.File( f2 )
    _fc1 = java.io.FileInputStream( _file1 ).getChannel()
    _fc2 = java.io.FileInputStream( _file2 ).getChannel()
    _bb1 = java.nio.ByteBuffer.allocateDirect( _fi1e1.length() )
    _bb2 = java.nio.ByteBuffer.allocateDirect( _file2.length() )
    _fc1.read( _bb1 )
    _fc2.read( _bb2 )
    _fc1.close(); _fc2.close()
    _bb1.position( 0 ); _bb2.position( 0 )
    c_result = _bb1.compareTo( _bb2 )
    if c_result == 0:
        val = True
    else:
        val = False
        
    return val</t>
<t tx="ekr.20070127142841.456">import javax.swing.filechooser as ff
class brwsfilter( ff.FileFilter ):
        
    def __init__( self, items ):
        self.items = items
        self.filters = []
        self.extend( items[ 1 ] )
            
    def accept( self, fvar ):
        name = fvar.getName()
        for ending in self.filters:
            if name.endswith( ending ): return True
            
        return False
        
    def extend( self, item ):
        self.filters.append( item.strip( '*' ) )
           
    def getDescription( self ):
        return self.items[ 0 ]</t>
<t tx="ekr.20070127142841.457"></t>
<t tx="ekr.20070127142841.458">def onBrowse1 (self):
    
    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()
    
def onBrowse2 (self):
    
    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()
    
def onBrowse3 (self): # Get the name of the output file.

    #fileName = tkFileDialog.asksaveasfilename(
    #    initialfile = self.defaultOutputFileName,
    #    title="Set output file",
    #    filetypes=[("Text files", "*.txt")],
    #    defaultextension=".txt")
    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None
    
    fc = swing.JFileChooser( parent )
    result = fc.showSaveDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None
    
        
    if fileName and len(fileName) &gt; 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)</t>
<t tx="ekr.20070127142841.459">def onClose (self):
    
    self.top.withdraw()</t>
<t tx="ekr.20070127142841.460">def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_directories(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() &gt; 0:
        self.showMismatchTable()

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_files(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() &gt; 0:
        self.showMismatchTable()</t>
<t tx="ekr.20070127142841.461">def onPrintMatchedLines (self):
    
    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)</t>
<t tx="ekr.20070127142841.462"></t>
<t tx="ekr.20070127142841.463">def show (self,s):
    
    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.c:
        #g.es(s)
        self._dtm.addRow( [ self._dtm.getRowCount() + 1 ,s ] )
    else:
        print s
        print</t>
<t tx="ekr.20070127142841.464">def showMismatchTable( self ):
    
    jf = swing.JFrame()
    
    jf.setDefaultCloseOperation( jf.DISPOSE_ON_CLOSE )
    cp = jf.getContentPane()
    cp.setLayout( awt.BorderLayout() )
    jt = swing.JTable( self._dtm )
    jt.setAutoResizeMode( jt.AUTO_RESIZE_ALL_COLUMNS )
    drend = self._dftcr()
    jt.setDefaultRenderer( java.lang.Object, drend )
    count = self._dtm.getRowCount()
    tmp_label = swing.JLabel( java.lang.String.valueOf( count ) )
    psize = tmp_label.getPreferredSize()
    column = jt.getColumn( "" )
    column.setPreferredWidth( psize.width + 10 )
    column.setMaxWidth( psize.width + 10 )
    sp = swing.JScrollPane( jt )
    sp.addComponentListener( drend )
    cp.add( sp, awt.BorderLayout.CENTER )
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event: jf.dispose()
    cp.add( jb, awt.BorderLayout.SOUTH )
    jf.pack()
    g.app.gui.center_dialog( jf )
    jf.visible = 1
    
class _dftcr( stable.DefaultTableCellRenderer, aevent.ComponentListener ):
    
    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )
        self._component = swing.JTextArea()
        self._component.setLineWrap( True )
        self._label = swing.JTextField()
        self._label.setMargin( awt.Insets( 0, 0, 0, 0 ) )
        
        
    def getTableCellRendererComponent( self, table, value,isSelected, hasFocus, row, column):
    
        if column == 1:
            vrect = table.getVisibleRect()
            self._component.setText( value )
            size = self._component.getSize()
            size.width = vrect.width
            self._component.setSize( size )
            if isSelected:
                self._component.setForeground( table.getSelectionForeground() )
                self._component.setBackground( table.getSelectionBackground() )
            else:
                self._component.setForeground( table.getForeground()) 
                self._component.setBackground( table.getBackground() )
            
            table.setRowHeight( row, self._component.getPreferredSize().height )
            return self._component
        else:
            
            row = java.lang.String.valueOf( row + 1 )
            self._label.setText( row )
            if isSelected:
                self._label.setForeground( table.getSelectionForeground() )
                self._label.setBackground( table.getSelectionBackground() )
            else:
                self._label.setForeground( table.getForeground()) 
                self._label.setBackground( table.getBackground() ) 
            return self._label
        
    def componentHidden( self, event ):
        pass
        
    def componentMoved( self, event ):
        pass
        
    def componentResized( self, event ):
        
        pass
        #source = event.getSource()
        #vrect = source.getVisibleRect()
        #model = source.getModel()
        #csize = self._component.getSize()
        #csize.width = vrect.width
        #print self._component.getPreferredSize()
        #print self._component.getSize()
        #for z in xrange( model.getRowCount() ):
        #    value = model.getValueAt( z, 0 )
        #    self._component.setText( value )
        #    print self._component.getPreferredSize()
        #    print self._component.getSize()
        #    source.setRowHeight( z, self._component.getPreferredSize().height )
            
            
        
        
    def componentShown( self, event ):
    
        event.getSource().repaint()</t>
<t tx="ekr.20070930041838"></t>
<t tx="ekr.20070930045014"></t>
<t tx="ekr.20070930211626"></t>
<t tx="ekr.20070930212003"></t>
<t tx="ekr.20070930212003.1"></t>
<t tx="ekr.20070930213000"></t>
<t tx="ekr.20070930213000.1"></t>
</tnodes>
</leo_file>
