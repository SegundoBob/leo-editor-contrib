<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.45" body_secondary_ratio="0.65">
	<global_window_position top="76" left="410" height="952" width="1202"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20120404123906.7255"><vh>Recursive create @auto nodes</vh>
<v t="ekr.20120404123906.7256"><vh>cleanEmptyDirs &amp; helper</vh>
<v t="ekr.20120404123906.7257"><vh>isEmpty</vh></v>
</v>
<v t="ekr.20120404123906.7258"><vh>computeFiles</vh></v>
<v t="ekr.20120404123906.7259"><vh>createLastChildOf</vh></v>
<v t="ekr.20120404123906.7260"><vh>importDir</vh></v>
<v t="ekr.20120404123906.7261"><vh>importFiles (top-level)</vh></v>
</v>
<v t="ekr.20120404123906.7262"><vh>@path C:/leo.repo/julia/src</vh>
<v t="ekr.20120404123906.7263"><vh>.h files</vh>
<v t="ekr.20120404123906.7264"><vh>builtin_proto.h</vh>
<v t="ekr.20120404123906.7265"><vh>builtin_proto declarations</vh></v>
</v>
<v t="ekr.20120404123906.7266"><vh>jltypes_internal.h</vh>
<v t="ekr.20120404123906.7267"><vh>jltypes_internal declarations</vh></v>
</v>
<v t="ekr.20120404123906.7268"><vh>julia.h</vh>
<v t="ekr.20120404123906.7269"><vh>julia declarations</vh></v>
<v t="ekr.20120404123906.7270"><vh>jl_value_t</vh></v>
<v t="ekr.20120404123906.7271"><vh>jl_lambda_info_t;</vh></v>
<v t="ekr.20120404123906.7272"><vh>jl_is_array_type</vh></v>
<v t="ekr.20120404123906.7273"><vh>jl_is_array</vh></v>
<v t="ekr.20120404123906.7274"><vh>jl_is_box</vh></v>
<v t="ekr.20120404123906.7275"><vh>jl_is_cpointer_type</vh></v>
<v t="ekr.20120404123906.7276"><vh>jl_is_seq_type</vh></v>
<v t="ekr.20120404123906.7277"><vh>jl_is_ntuple_type</vh></v>
<v t="ekr.20120404123906.7278"><vh>jl_is_nontuple_type</vh></v>
<v t="ekr.20120404123906.7279"><vh>jl_is_type_type</vh></v>
<v t="ekr.20120404123906.7280"><vh>// type info accessors</vh></v>
<v t="ekr.20120404123906.7281"><vh>int</vh></v>
<v t="ekr.20120404123906.7282"><vh>jl_vinfo_assigned</vh></v>
<v t="ekr.20120404123906.7283"><vh>jl_vinfo_assigned_inner</vh></v>
<v t="ekr.20120404123906.7284"><vh>// for writing julia functions in C</vh></v>
<v t="ekr.20120404123906.7285"><vh>jl_apply</vh></v>
<v t="ekr.20120404123906.7286"><vh>#define JL_NARGS(fname, min, max)                               \</vh></v>
<v t="ekr.20120404123906.7287"><vh>alloc_2w</vh></v>
<v t="ekr.20120404123906.7288"><vh>alloc_3w</vh></v>
<v t="ekr.20120404123906.7289"><vh>alloc_4w</vh></v>
<v t="ekr.20120404123906.7290"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7291"><vh>jl_eh_restore_state</vh></v>
</v>
</v>
<v t="ekr.20120404123906.7292"><vh>.jl files</vh>
<v t="ekr.20120404123906.7293"><vh>boot.jl</vh></v>
</v>
<v t="ekr.20120404123906.7294"><vh>.scm files</vh>
<v t="ekr.20120404123906.7295"><vh>bin2hex.scm</vh></v>
<v t="ekr.20120404123906.7296"><vh>jlfrontend.scm</vh></v>
<v t="ekr.20120404123906.7297"><vh>julia-syntax.scm</vh></v>
<v t="ekr.20120404123906.7298"><vh>julia-parser.scm</vh></v>
<v t="ekr.20120404123906.7299"><vh>match.scm</vh></v>
<v t="ekr.20120404123906.7300"><vh>mk_julia_flisp_boot.scm</vh></v>
</v>
<v t="ekr.20120404123906.7301"><vh>.cpp files</vh>
<v t="ekr.20120404123906.7302"><vh>ccall.cpp</vh>
<v t="ekr.20120404123906.7303"><vh>ccall declarations</vh></v>
<v t="ekr.20120404123906.7304"><vh>save_arg_area_loc</vh></v>
<v t="ekr.20120404123906.7305"><vh>restore_arg_area_loc</vh></v>
<v t="ekr.20120404123906.7306"><vh>alloc_temp_arg_space</vh></v>
<v t="ekr.20120404123906.7307"><vh>alloc_temp_arg_copy</vh></v>
<v t="ekr.20120404123906.7308"><vh>// this is a run-time function</vh></v>
<v t="ekr.20120404123906.7309"><vh>jl_value_to_pointer</vh></v>
<v t="ekr.20120404123906.7310"><vh>julia_to_native</vh></v>
<v t="ekr.20120404123906.7311"><vh>// ccall(pointer, rettype, (argtypes...), args...)</vh></v>
<v t="ekr.20120404123906.7312"><vh>emit_ccall</vh></v>
</v>
<v t="ekr.20120404123906.7313"><vh>cgutils.cpp</vh>
<v t="ekr.20120404123906.7314"><vh>cgutils declarations</vh></v>
<v t="ekr.20120404123906.7315"><vh>stringConst</vh></v>
<v t="ekr.20120404123906.7316"><vh>// --- emitting pointers directly into code ---</vh></v>
<v t="ekr.20120404123906.7317"><vh>literal_pointer_val</vh></v>
<v t="ekr.20120404123906.7318"><vh>literal_pointer_val</vh></v>
<v t="ekr.20120404123906.7319"><vh>literal_pointer_val</vh></v>
<v t="ekr.20120404123906.7320"><vh>// --- generating various error checks ---</vh></v>
<v t="ekr.20120404123906.7321"><vh>emit_typeof</vh></v>
<v t="ekr.20120404123906.7322"><vh>emit_error</vh></v>
<v t="ekr.20120404123906.7323"><vh>error_unless</vh></v>
<v t="ekr.20120404123906.7324"><vh>call_error_func_unless</vh></v>
<v t="ekr.20120404123906.7325"><vh>null_pointer_check</vh></v>
<v t="ekr.20120404123906.7326"><vh>static Value *boxed(Value *v);</vh></v>
<v t="ekr.20120404123906.7327"><vh>emit_type_error</vh></v>
<v t="ekr.20120404123906.7328"><vh>emit_typecheck</vh></v>
<v t="ekr.20120404123906.7329"><vh>emit_bounds_check</vh></v>
<v t="ekr.20120404123906.7330"><vh>emit_func_check</vh></v>
<v t="ekr.20120404123906.7331"><vh>// --- loading and storing the Nth word in an object ---</vh></v>
<v t="ekr.20120404123906.7332"><vh>emit_nthptr_addr</vh></v>
<v t="ekr.20120404123906.7333"><vh>emit_nthptr_addr</vh></v>
<v t="ekr.20120404123906.7334"><vh>emit_nthptr</vh></v>
<v t="ekr.20120404123906.7335"><vh>emit_nthptr</vh></v>
<v t="ekr.20120404123906.7336"><vh>// --- convert boolean value to julia ---</vh></v>
<v t="ekr.20120404123906.7337"><vh>julia_bool</vh></v>
<v t="ekr.20120404123906.7338"><vh>// --- get the inferred type of an AST node ---</vh></v>
<v t="ekr.20120404123906.7339"><vh>expr_type</vh></v>
<v t="ekr.20120404123906.7340"><vh>// --- accessing the representations of built-in data types ---</vh></v>
<v t="ekr.20120404123906.7341"><vh>emit_tuplelen</vh></v>
<v t="ekr.20120404123906.7342"><vh>// emit length of vararg tuple</vh></v>
<v t="ekr.20120404123906.7343"><vh>emit_n_varargs</vh></v>
<v t="ekr.20120404123906.7344"><vh>emit_arraysize</vh></v>
<v t="ekr.20120404123906.7345"><vh>emit_arraysize</vh></v>
<v t="ekr.20120404123906.7346"><vh>emit_arraylen</vh></v>
<v t="ekr.20120404123906.7347"><vh>emit_arrayptr</vh></v>
<v t="ekr.20120404123906.7348"><vh>bitstype_pointer</vh></v>
<v t="ekr.20120404123906.7349"><vh>// --- scheme for tagging llvm values with julia types using metadata ---</vh></v>
<v t="ekr.20120404123906.7350"><vh>jl_type_to_typeid</vh></v>
<v t="ekr.20120404123906.7351"><vh>jl_typeid_to_type</vh></v>
<v t="ekr.20120404123906.7352"><vh>has_julia_type</vh></v>
<v t="ekr.20120404123906.7353"><vh>julia_type_of_without_metadata</vh></v>
<v t="ekr.20120404123906.7354"><vh>julia_type_of</vh></v>
<v t="ekr.20120404123906.7355"><vh>NoOpCast</vh></v>
<v t="ekr.20120404123906.7356"><vh>mark_julia_type</vh></v>
<v t="ekr.20120404123906.7357"><vh>mark_julia_type</vh></v>
<v t="ekr.20120404123906.7358"><vh>// --- propagate julia type from value a to b. returns b. ---</vh></v>
<v t="ekr.20120404123906.7359"><vh>tpropagate</vh></v>
<v t="ekr.20120404123906.7360"><vh>// --- mapping between julia and llvm types ---</vh></v>
<v t="ekr.20120404123906.7361"><vh>julia_type_to_llvm</vh></v>
<v t="ekr.20120404123906.7362"><vh>// NOTE: llvm cannot express all julia types (for example unsigned),</vh></v>
<v t="ekr.20120404123906.7363"><vh>llvm_type_to_julia</vh></v>
<v t="ekr.20120404123906.7364"><vh>// --- boxing ---</vh></v>
<v t="ekr.20120404123906.7365"><vh>boxed</vh></v>
</v>
<v t="ekr.20120404123906.7366"><vh>codegen.cpp</vh>
<v t="ekr.20120404123906.7367"><vh>codegen declarations</vh></v>
<v t="ekr.20120404123906.7368"><vh>getGlobalContext</vh></v>
<v t="ekr.20120404123906.7369"><vh>jl_generate_fptr</vh></v>
<v t="ekr.20120404123906.7370"><vh>jl_compile</vh></v>
<v t="ekr.20120404123906.7371"><vh>jl_delete_function</vh></v>
<v t="ekr.20120404123906.7372"><vh>// information about the context of a piece of code: its enclosing</vh></v>
<v t="ekr.20120404123906.7373"><vh>is_constant</vh></v>
<v t="ekr.20120404123906.7374"><vh>symbol_eq</vh></v>
<v t="ekr.20120404123906.7375"><vh>// --- gc root counting ---</vh></v>
<v t="ekr.20120404123906.7376"><vh>expr_is_symbol</vh></v>
<v t="ekr.20120404123906.7377"><vh>// some analysis. determine max needed "evaluation stack" space for</vh></v>
<v t="ekr.20120404123906.7378"><vh>max_arg_depth</vh></v>
<v t="ekr.20120404123906.7379"><vh>make_gcroot</vh></v>
<v t="ekr.20120404123906.7380"><vh>// --- lambda ---</vh></v>
<v t="ekr.20120404123906.7381"><vh>jl_add_linfo_root</vh></v>
<v t="ekr.20120404123906.7382"><vh>emit_lambda_closure</vh></v>
<v t="ekr.20120404123906.7383"><vh>// --- generating function calls ---</vh></v>
<v t="ekr.20120404123906.7384"><vh>call_arg_types</vh></v>
<v t="ekr.20120404123906.7385"><vh>extern "C" jl_function_t *jl_get_specialization(jl_function_t *f, jl_tuple_t *types);</vh></v>
<v t="ekr.20120404123906.7386"><vh>emit_known_call</vh></v>
<v t="ekr.20120404123906.7387"><vh>emit_call</vh></v>
<v t="ekr.20120404123906.7388"><vh>// --- accessing and assigning variables ---</vh></v>
<v t="ekr.20120404123906.7389"><vh>isBoxed</vh></v>
<v t="ekr.20120404123906.7390"><vh>// yields a jl_value_t** giving the binding location of a variable</vh></v>
<v t="ekr.20120404123906.7391"><vh>var_binding_pointer</vh></v>
<v t="ekr.20120404123906.7392"><vh>is_var_closed</vh></v>
<v t="ekr.20120404123906.7393"><vh>is_global</vh></v>
<v t="ekr.20120404123906.7394"><vh>emit_checked_var</vh></v>
<v t="ekr.20120404123906.7395"><vh>emit_var</vh></v>
<v t="ekr.20120404123906.7396"><vh>emit_assignment</vh></v>
<v t="ekr.20120404123906.7397"><vh>// --- convert expression to code ---</vh></v>
<v t="ekr.20120404123906.7398"><vh>emit_expr</vh></v>
<v t="ekr.20120404123906.7399"><vh>// --- allocating local variables ---</vh></v>
<v t="ekr.20120404123906.7400"><vh>store_unboxed_p</vh></v>
<v t="ekr.20120404123906.7401"><vh>alloc_local</vh></v>
<v t="ekr.20120404123906.7402"><vh>// --- generate function bodies ---</vh></v>
<v t="ekr.20120404123906.7403"><vh>emit_function</vh></v>
<v t="ekr.20120404123906.7404"><vh>// --- initialization ---</vh></v>
<v t="ekr.20120404123906.7405"><vh>global_to_llvm</vh></v>
<v t="ekr.20120404123906.7406"><vh>jlfunc_to_llvm</vh></v>
<v t="ekr.20120404123906.7407"><vh>jl_new_box</vh></v>
<v t="ekr.20120404123906.7408"><vh>init_julia_llvm_env</vh></v>
<v t="ekr.20120404123906.7409"><vh>jl_init_codegen</vh></v>
</v>
<v t="ekr.20120404123906.7410"><vh>debuginfo.cpp</vh>
<v t="ekr.20120404123906.7411"><vh>debuginfo declarations</vh></v>
<v t="ekr.20120404123906.7412"><vh>getFunctionInfo</vh></v>
</v>
<v t="ekr.20120404123906.7413"><vh>intrinsics.cpp</vh>
<v t="ekr.20120404123906.7414"><vh>intrinsics declarations</vh></v>
<v t="ekr.20120404123906.7415"><vh>#include "ccall.cpp"</vh></v>
<v t="ekr.20120404123906.7416"><vh>FT</vh></v>
<v t="ekr.20120404123906.7417"><vh>// reinterpret-cast to float</vh></v>
<v t="ekr.20120404123906.7418"><vh>FP</vh></v>
<v t="ekr.20120404123906.7419"><vh>// convert float type to same-size int type</vh></v>
<v t="ekr.20120404123906.7420"><vh>INTT</vh></v>
<v t="ekr.20120404123906.7421"><vh>// reinterpret-cast to int</vh></v>
<v t="ekr.20120404123906.7422"><vh>INT</vh></v>
<v t="ekr.20120404123906.7423"><vh>uint_cnvt</vh></v>
<v t="ekr.20120404123906.7424"><vh>emit_unboxed</vh></v>
<v t="ekr.20120404123906.7425"><vh>// emit code to unpack a raw value from a box</vh></v>
<v t="ekr.20120404123906.7426"><vh>emit_unbox</vh></v>
<v t="ekr.20120404123906.7427"><vh>// unbox trying to determine type automatically</vh></v>
<v t="ekr.20120404123906.7428"><vh>auto_unbox</vh></v>
<v t="ekr.20120404123906.7429"><vh>// unbox using user-specified type</vh></v>
<v t="ekr.20120404123906.7430"><vh>generic_unbox</vh></v>
<v t="ekr.20120404123906.7431"><vh>generic_box</vh></v>
<v t="ekr.20120404123906.7432"><vh>generic_trunc</vh></v>
<v t="ekr.20120404123906.7433"><vh>generic_zext</vh></v>
<v t="ekr.20120404123906.7434"><vh>#define HANDLE(intr,n)                                                  \</vh></v>
<v t="ekr.20120404123906.7435"><vh>emit_intrinsic</vh></v>
<v t="ekr.20120404123906.7436"><vh>#undef HANDLE</vh></v>
<v t="ekr.20120404123906.7437"><vh>boxfunc_llvm</vh></v>
<v t="ekr.20120404123906.7438"><vh>ft1arg</vh></v>
<v t="ekr.20120404123906.7439"><vh>ft2arg</vh></v>
<v t="ekr.20120404123906.7440"><vh>#define BOX_F(ct,jl_ct)                                                       \</vh></v>
<v t="ekr.20120404123906.7441"><vh>add_intrinsic</vh></v>
<v t="ekr.20120404123906.7442"><vh>#define ADD_I(name) add_intrinsic(#name, name)</vh></v>
<v t="ekr.20120404123906.7443"><vh>jl_init_intrinsic_functions</vh></v>
</v>
</v>
<v t="ekr.20120404123906.7444"><vh>.c files</vh>
<v t="ekr.20120404123906.7445"><vh>alloc.c</vh>
<v t="ekr.20120404123906.7446"><vh>alloc declarations</vh></v>
<v t="ekr.20120404123906.7447"><vh>jl_new_struct</vh></v>
<v t="ekr.20120404123906.7448"><vh>jl_new_struct_uninit</vh></v>
<v t="ekr.20120404123906.7449"><vh>jl_new_structt</vh></v>
<v t="ekr.20120404123906.7450"><vh>jl_tuple</vh></v>
<v t="ekr.20120404123906.7451"><vh>jl_tuple1</vh></v>
<v t="ekr.20120404123906.7452"><vh>jl_tuple2</vh></v>
<v t="ekr.20120404123906.7453"><vh>jl_alloc_tuple_uninit</vh></v>
<v t="ekr.20120404123906.7454"><vh>jl_alloc_tuple</vh></v>
<v t="ekr.20120404123906.7455"><vh>jl_tuple_append</vh></v>
<v t="ekr.20120404123906.7456"><vh>jl_tuple_fill</vh></v>
<v t="ekr.20120404123906.7457"><vh>jl_new_closure</vh></v>
<v t="ekr.20120404123906.7458"><vh>jl_new_lambda_info</vh></v>
<v t="ekr.20120404123906.7459"><vh>// symbols --------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7460"><vh>mk_symbol</vh></v>
<v t="ekr.20120404123906.7461"><vh>unmark_symbols_</vh></v>
<v t="ekr.20120404123906.7462"><vh>jl_unmark_symbols</vh></v>
<v t="ekr.20120404123906.7463"><vh>symtab_lookup</vh></v>
<v t="ekr.20120404123906.7464"><vh>jl_symbol</vh></v>
<v t="ekr.20120404123906.7465"><vh>jl_symbol_n</vh></v>
<v t="ekr.20120404123906.7466"><vh>jl_get_root_symbol</vh></v>
<v t="ekr.20120404123906.7467"><vh>static uint32_t gs_ctr = 0;  // TODO: per-thread</vh></v>
<v t="ekr.20120404123906.7468"><vh>jl_get_gs_ctr</vh></v>
<v t="ekr.20120404123906.7469"><vh>jl_set_gs_ctr</vh></v>
<v t="ekr.20120404123906.7470"><vh>jl_gensym</vh></v>
<v t="ekr.20120404123906.7471"><vh>// allocating types -----------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7472"><vh>jl_new_typename</vh></v>
<v t="ekr.20120404123906.7473"><vh>unbind_tvars</vh></v>
<v t="ekr.20120404123906.7474"><vh>jl_new_tagtype</vh></v>
<v t="ekr.20120404123906.7475"><vh>jl_function_t *jl_instantiate_method(jl_function_t *f, jl_tuple_t *sp);</vh></v>
<v t="ekr.20120404123906.7476"><vh>jl_add_constructors</vh></v>
<v t="ekr.20120404123906.7477"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7478"><vh>jl_new_struct_type</vh></v>
<v t="ekr.20120404123906.7479"><vh>extern int jl_boot_file_loaded;</vh></v>
<v t="ekr.20120404123906.7480"><vh>jl_new_bitstype</vh></v>
<v t="ekr.20120404123906.7481"><vh>jl_new_uniontype</vh></v>
<v t="ekr.20120404123906.7482"><vh>// type constructor -----------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7483"><vh>jl_new_type_ctor</vh></v>
<v t="ekr.20120404123906.7484"><vh>// bits constructors ----------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7485"><vh>BOXN_FUNC</vh></v>
<v t="ekr.20120404123906.7486"><vh>UNBOX_FUNC</vh></v>
<v t="ekr.20120404123906.7487"><vh>BOX_FUNC</vh></v>
<v t="ekr.20120404123906.7488"><vh>#define UIBOX_FUNC(typ,c_type,nw)               \</vh></v>
<v t="ekr.20120404123906.7489"><vh>SIBOX_FUNC</vh></v>
<v t="ekr.20120404123906.7490"><vh>static jl_value_t *boxed_uint8_cache[256];</vh></v>
<v t="ekr.20120404123906.7491"><vh>jl_box_uint8</vh></v>
<v t="ekr.20120404123906.7492"><vh>jl_init_int32_int64_cache</vh></v>
<v t="ekr.20120404123906.7493"><vh>jl_init_box_caches</vh></v>
<v t="ekr.20120404123906.7494"><vh>#ifdef JL_GC_MARKSWEEP</vh></v>
<v t="ekr.20120404123906.7495"><vh>jl_mark_box_caches</vh></v>
<v t="ekr.20120404123906.7496"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7497"><vh>jl_box_bool</vh></v>
<v t="ekr.20120404123906.7498"><vh>// Expr constructor for internal use ------------------------------------------</vh></v>
<v t="ekr.20120404123906.7499"><vh>jl_exprn</vh></v>
<v t="ekr.20120404123906.7500"><vh>// this constructor has to be built-in for bootstrapping, because we can't</vh></v>
<v t="ekr.20120404123906.7501"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7502"><vh>JL_CALLABLE</vh></v>
</v>
<v t="ekr.20120404123906.7503"><vh>array.c</vh>
<v t="ekr.20120404123906.7504"><vh>/*</vh></v>
<v t="ekr.20120404123906.7505"><vh>_new_array</vh></v>
<v t="ekr.20120404123906.7506"><vh>jl_reshape_array</vh></v>
<v t="ekr.20120404123906.7507"><vh>jl_new_array_</vh></v>
<v t="ekr.20120404123906.7508"><vh>jl_new_array</vh></v>
<v t="ekr.20120404123906.7509"><vh>jl_alloc_array_1d</vh></v>
<v t="ekr.20120404123906.7510"><vh>jl_alloc_array_2d</vh></v>
<v t="ekr.20120404123906.7511"><vh>jl_alloc_array_3d</vh></v>
<v t="ekr.20120404123906.7512"><vh>jl_pchar_to_array</vh></v>
<v t="ekr.20120404123906.7513"><vh>jl_array_to_string</vh></v>
<v t="ekr.20120404123906.7514"><vh>jl_pchar_to_string</vh></v>
<v t="ekr.20120404123906.7515"><vh>jl_cstr_to_string</vh></v>
<v t="ekr.20120404123906.7516"><vh>jl_alloc_cell_1d</vh></v>
<v t="ekr.20120404123906.7517"><vh>// array primitives -----------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7518"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7519"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7520"><vh>new_scalar</vh></v>
<v t="ekr.20120404123906.7521"><vh>typedef struct {</vh></v>
<v t="ekr.20120404123906.7522"><vh>jl_arrayref</vh></v>
<v t="ekr.20120404123906.7523"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7524"><vh>jl_arrayset</vh></v>
<v t="ekr.20120404123906.7525"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7526"><vh>array_new_buffer</vh></v>
<v t="ekr.20120404123906.7527"><vh>jl_array_grow_end</vh></v>
<v t="ekr.20120404123906.7528"><vh>jl_array_del_end</vh></v>
<v t="ekr.20120404123906.7529"><vh>jl_array_grow_beg</vh></v>
<v t="ekr.20120404123906.7530"><vh>jl_array_del_beg</vh></v>
<v t="ekr.20120404123906.7531"><vh>jl_cell_1d_push</vh></v>
</v>
<v t="ekr.20120404123906.7532"><vh>ast.c</vh>
<v t="ekr.20120404123906.7533"><vh>ast declarations</vh></v>
<v t="ekr.20120404123906.7534"><vh>jl_lisp_prompt</vh></v>
<v t="ekr.20120404123906.7535"><vh>fl_defined_julia_global</vh></v>
<v t="ekr.20120404123906.7536"><vh>fl_invoke_julia_macro</vh></v>
<v t="ekr.20120404123906.7537"><vh>static builtinspec_t julia_flisp_ast_ext[] = {</vh></v>
<v t="ekr.20120404123906.7538"><vh>jl_init_frontend</vh></v>
<v t="ekr.20120404123906.7539"><vh>scmsym_to_julia</vh></v>
<v t="ekr.20120404123906.7540"><vh>static jl_value_t *scm_to_julia_(value_t e);</vh></v>
<v t="ekr.20120404123906.7541"><vh>full_list</vh></v>
<v t="ekr.20120404123906.7542"><vh>full_list_of_lists</vh></v>
<v t="ekr.20120404123906.7543"><vh>scm_to_julia</vh></v>
<v t="ekr.20120404123906.7544"><vh>scm_to_julia_</vh></v>
<v t="ekr.20120404123906.7545"><vh>array_to_list</vh></v>
<v t="ekr.20120404123906.7546"><vh>julia_to_scm</vh></v>
<v t="ekr.20120404123906.7547"><vh>// this is used to parse a line of repl input</vh></v>
<v t="ekr.20120404123906.7548"><vh>jl_parse_input_line</vh></v>
<v t="ekr.20120404123906.7549"><vh>// this is for parsing one expression out of a string, keeping track of</vh></v>
<v t="ekr.20120404123906.7550"><vh>jl_parse_string</vh></v>
<v t="ekr.20120404123906.7551"><vh>jl_parse_file</vh></v>
<v t="ekr.20120404123906.7552"><vh>jl_load_file_string</vh></v>
<v t="ekr.20120404123906.7553"><vh>// returns either an expression or a thunk</vh></v>
<v t="ekr.20120404123906.7554"><vh>jl_expand</vh></v>
<v t="ekr.20120404123906.7555"><vh>// wrap expr in a thunk AST</vh></v>
<v t="ekr.20120404123906.7556"><vh>jl_wrap_expr</vh></v>
<v t="ekr.20120404123906.7557"><vh>// syntax tree accessors</vh></v>
<v t="ekr.20120404123906.7558"><vh>jl_lam_args</vh></v>
<v t="ekr.20120404123906.7559"><vh>// get array of local var symbols</vh></v>
<v t="ekr.20120404123906.7560"><vh>jl_lam_locals</vh></v>
<v t="ekr.20120404123906.7561"><vh>// get array of var info records</vh></v>
<v t="ekr.20120404123906.7562"><vh>jl_lam_vinfo</vh></v>
<v t="ekr.20120404123906.7563"><vh>// get array of var info records for captured vars</vh></v>
<v t="ekr.20120404123906.7564"><vh>jl_lam_capt</vh></v>
<v t="ekr.20120404123906.7565"><vh>// get array of body forms</vh></v>
<v t="ekr.20120404123906.7566"><vh>jl_lam_body</vh></v>
<v t="ekr.20120404123906.7567"><vh>jl_decl_var</vh></v>
<v t="ekr.20120404123906.7568"><vh>jl_is_rest_arg</vh></v>
<v t="ekr.20120404123906.7569"><vh>copy_ast</vh></v>
<v t="ekr.20120404123906.7570"><vh>// TODO: eval decl types for arguments of non-generic functions</vh></v>
<v t="ekr.20120404123906.7571"><vh>eval_decl_types</vh></v>
<v t="ekr.20120404123906.7572"><vh>jl_tuple_tvars_to_symbols</vh></v>
<v t="ekr.20120404123906.7573"><vh>// given a new lambda_info with static parameter values, make a copy</vh></v>
<v t="ekr.20120404123906.7574"><vh>jl_prepare_ast</vh></v>
</v>
<v t="ekr.20120404123906.7575"><vh>builtins.c</vh>
<v t="ekr.20120404123906.7576"><vh>builtins declarations</vh></v>
<v t="ekr.20120404123906.7577"><vh>jl_error</vh></v>
<v t="ekr.20120404123906.7578"><vh>jl_errorf</vh></v>
<v t="ekr.20120404123906.7579"><vh>jl_too_few_args</vh></v>
<v t="ekr.20120404123906.7580"><vh>jl_too_many_args</vh></v>
<v t="ekr.20120404123906.7581"><vh>jl_type_error_rt</vh></v>
<v t="ekr.20120404123906.7582"><vh>jl_type_error</vh></v>
<v t="ekr.20120404123906.7583"><vh>jl_undef_ref_error</vh></v>
<v t="ekr.20120404123906.7584"><vh>jl_divide_by_zero_error</vh></v>
<v t="ekr.20120404123906.7585"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7586"><vh>jl_enter_handler</vh></v>
<v t="ekr.20120404123906.7587"><vh>jl_pop_handler</vh></v>
<v t="ekr.20120404123906.7588"><vh>// primitives -----------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7589"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7590"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7591"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7592"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7593"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7594"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7595"><vh>static jl_function_t *jl_append_any_func;</vh></v>
<v t="ekr.20120404123906.7596"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7597"><vh>// eval -----------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7598"><vh>jl_eval_module_expr</vh></v>
<v t="ekr.20120404123906.7599"><vh>is_intrinsic</vh></v>
<v t="ekr.20120404123906.7600"><vh>has_intrinsics</vh></v>
<v t="ekr.20120404123906.7601"><vh>// heuristic for whether a top-level input should be evaluated with</vh></v>
<v t="ekr.20120404123906.7602"><vh>eval_with_compiler_p</vh></v>
<v t="ekr.20120404123906.7603"><vh>extern int jl_in_inference;</vh></v>
<v t="ekr.20120404123906.7604"><vh>jl_toplevel_eval_flex</vh></v>
<v t="ekr.20120404123906.7605"><vh>jl_toplevel_eval</vh></v>
<v t="ekr.20120404123906.7606"><vh>int asprintf(char **strp, const char *fmt, ...);</vh></v>
<v t="ekr.20120404123906.7607"><vh>jl_load_file_expr</vh></v>
<v t="ekr.20120404123906.7608"><vh>// fpath needs to be freed if != fname</vh></v>
<v t="ekr.20120404123906.7609"><vh>jl_find_file_in_path</vh></v>
<v t="ekr.20120404123906.7610"><vh>jl_load</vh></v>
<v t="ekr.20120404123906.7611"><vh>jl_load_</vh></v>
<v t="ekr.20120404123906.7612"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7613"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7614"><vh>// tuples ---------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7615"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7616"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7617"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7618"><vh>// structs --------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7619"><vh>field_offset</vh></v>
<v t="ekr.20120404123906.7620"><vh>jl_field_offset</vh></v>
<v t="ekr.20120404123906.7621"><vh>nth_field</vh></v>
<v t="ekr.20120404123906.7622"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7623"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7624"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7625"><vh>// conversion -----------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7626"><vh>convert</vh></v>
<v t="ekr.20120404123906.7627"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7628"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7629"><vh>jl_symbol_name</vh></v>
<v t="ekr.20120404123906.7630"><vh>jl_array_ptr</vh></v>
<v t="ekr.20120404123906.7631"><vh>// printing -------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7632"><vh>jl_print_array_uint8</vh></v>
<v t="ekr.20120404123906.7633"><vh>jl_print_symbol</vh></v>
<v t="ekr.20120404123906.7634"><vh>// for bootstrap</vh></v>
<v t="ekr.20120404123906.7635"><vh>jl_print_int64</vh></v>
<v t="ekr.20120404123906.7636"><vh>jl_strtod</vh></v>
<v t="ekr.20120404123906.7637"><vh>jl_strtof</vh></v>
<v t="ekr.20120404123906.7638"><vh>// showing --------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7639"><vh>jl_show</vh></v>
<v t="ekr.20120404123906.7640"><vh>// comma_one prints a comma for 1 element, e.g. "(x,)"</vh></v>
<v t="ekr.20120404123906.7641"><vh>jl_show_tuple</vh></v>
<v t="ekr.20120404123906.7642"><vh>show_function</vh></v>
<v t="ekr.20120404123906.7643"><vh>show_type</vh></v>
<v t="ekr.20120404123906.7644"><vh>jl_show_any</vh></v>
<v t="ekr.20120404123906.7645"><vh>// internal functions ---------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7646"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7647"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7648"><vh>check_supertype</vh></v>
<v t="ekr.20120404123906.7649"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7650"><vh>void jl_add_constructors(jl_struct_type_t *t);</vh></v>
<v t="ekr.20120404123906.7651"><vh>check_type_tuple</vh></v>
<v t="ekr.20120404123906.7652"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7653"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7654"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7655"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7656"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7657"><vh>extern int jl_boot_file_loaded;</vh></v>
<v t="ekr.20120404123906.7658"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7659"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7660"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7661"><vh>// method definition ----------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7662"><vh>jl_method_def</vh></v>
<v t="ekr.20120404123906.7663"><vh>// generic function reflection ------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7664"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7665"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7666"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7667"><vh>// eq hash table --------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7668"><vh>jl_hash_symbol</vh></v>
<v t="ekr.20120404123906.7669"><vh>jl_uid</vh></v>
<v t="ekr.20120404123906.7670"><vh>// init -----------------------------------------------------------------------</vh></v>
<v t="ekr.20120404123906.7671"><vh>add_builtin</vh></v>
<v t="ekr.20120404123906.7672"><vh>add_builtin_func</vh></v>
<v t="ekr.20120404123906.7673"><vh>jl_init_primitives</vh></v>
</v>
<v t="ekr.20120404123906.7674"><vh>dlload.c</vh>
<v t="ekr.20120404123906.7675"><vh>dlload declarations</vh></v>
<v t="ekr.20120404123906.7676"><vh>jl_load_dynamic_library</vh></v>
<v t="ekr.20120404123906.7677"><vh>jl_dlsym</vh></v>
</v>
<v t="ekr.20120404123906.7678"><vh>dump.c</vh>
<v t="ekr.20120404123906.7679"><vh>dump declarations</vh></v>
<v t="ekr.20120404123906.7680"><vh>#define write_uint8(s, n) ios_putc((n), (s))</vh></v>
<v t="ekr.20120404123906.7681"><vh>write_int32</vh></v>
<v t="ekr.20120404123906.7682"><vh>read_int32</vh></v>
<v t="ekr.20120404123906.7683"><vh>write_uint16</vh></v>
<v t="ekr.20120404123906.7684"><vh>read_uint16</vh></v>
<v t="ekr.20120404123906.7685"><vh>writetag</vh></v>
<v t="ekr.20120404123906.7686"><vh>write_as_tag</vh></v>
<v t="ekr.20120404123906.7687"><vh>// --- serialize ---</vh></v>
<v t="ekr.20120404123906.7688"><vh>jl_serialize_fptr</vh></v>
<v t="ekr.20120404123906.7689"><vh>jl_serialize_tag_type</vh></v>
<v t="ekr.20120404123906.7690"><vh>jl_serialize_module</vh></v>
<v t="ekr.20120404123906.7691"><vh>is_ast_node</vh></v>
<v t="ekr.20120404123906.7692"><vh>literal_val_id</vh></v>
<v t="ekr.20120404123906.7693"><vh>jl_serialize_value_</vh></v>
<v t="ekr.20120404123906.7694"><vh>htable_t *jl_gc_get_finalizer_table();</vh></v>
<v t="ekr.20120404123906.7695"><vh>jl_deserialize_fptr</vh></v>
<v t="ekr.20120404123906.7696"><vh>jl_deserialize_tag_type</vh></v>
<v t="ekr.20120404123906.7697"><vh>jl_deserialize_value</vh></v>
<v t="ekr.20120404123906.7698"><vh>/*</vh></v>
<v t="ekr.20120404123906.7699"><vh>jl_save_system_image</vh></v>
<v t="ekr.20120404123906.7700"><vh>extern jl_function_t *jl_typeinf_func;</vh></v>
<v t="ekr.20120404123906.7701"><vh>jl_restore_system_image</vh></v>
<v t="ekr.20120404123906.7702"><vh>jl_compress_ast</vh></v>
<v t="ekr.20120404123906.7703"><vh>jl_uncompress_ast</vh></v>
<v t="ekr.20120404123906.7704"><vh>// --- init ---</vh></v>
<v t="ekr.20120404123906.7705"><vh>jl_init_serializer</vh></v>
</v>
<v t="ekr.20120404123906.7706"><vh>gc.c</vh>
<v t="ekr.20120404123906.7707"><vh>gc declarations</vh></v>
<v t="ekr.20120404123906.7708"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7709"><vh>jl_gc_n_preserved_values</vh></v>
<v t="ekr.20120404123906.7710"><vh>jl_gc_preserve</vh></v>
<v t="ekr.20120404123906.7711"><vh>jl_gc_unpreserve</vh></v>
<v t="ekr.20120404123906.7712"><vh>jl_gc_new_weakref</vh></v>
<v t="ekr.20120404123906.7713"><vh>sweep_weak_refs</vh></v>
<v t="ekr.20120404123906.7714"><vh>schedule_finalization</vh></v>
<v t="ekr.20120404123906.7715"><vh>run_finalizers</vh></v>
<v t="ekr.20120404123906.7716"><vh>jl_gc_add_finalizer</vh></v>
<v t="ekr.20120404123906.7717"><vh>jl_gc_get_finalizer_table</vh></v>
<v t="ekr.20120404123906.7718"><vh>szclass</vh></v>
<v t="ekr.20120404123906.7719"><vh>alloc_big</vh></v>
<v t="ekr.20120404123906.7720"><vh>jl_gc_acquire_buffer</vh></v>
<v t="ekr.20120404123906.7721"><vh>#define bigval_word0(v) (((uptrint_t*)(&amp;((bigval_t*)(v))-&gt;_data[0]))[0])</vh></v>
<v t="ekr.20120404123906.7722"><vh>sweep_big</vh></v>
<v t="ekr.20120404123906.7723"><vh>add_page</vh></v>
<v t="ekr.20120404123906.7724"><vh>pool_alloc</vh></v>
<v t="ekr.20120404123906.7725"><vh>sweep_pool</vh></v>
<v t="ekr.20120404123906.7726"><vh>extern void jl_unmark_symbols(void);</vh></v>
<v t="ekr.20120404123906.7727"><vh>gc_sweep</vh></v>
<v t="ekr.20120404123906.7728"><vh>#define GC_Markval(v) gc_markval_((jl_value_t*)(v))</vh></v>
<v t="ekr.20120404123906.7729"><vh>jl_gc_markval</vh></v>
<v t="ekr.20120404123906.7730"><vh>gc_mark_stack</vh></v>
<v t="ekr.20120404123906.7731"><vh>gc_mark_module</vh></v>
<v t="ekr.20120404123906.7732"><vh>#define gc_typeof(v) ((jl_value_t*)(((uptrint_t)jl_typeof(v))&amp;~1UL))</vh></v>
<v t="ekr.20120404123906.7733"><vh>gc_markval_</vh></v>
<v t="ekr.20120404123906.7734"><vh>void jl_mark_box_caches(void);</vh></v>
<v t="ekr.20120404123906.7735"><vh>gc_mark</vh></v>
<v t="ekr.20120404123906.7736"><vh>static int is_gc_enabled = 0;</vh></v>
<v t="ekr.20120404123906.7737"><vh>jl_gc_enable</vh></v>
<v t="ekr.20120404123906.7738"><vh>jl_gc_disable</vh></v>
<v t="ekr.20120404123906.7739"><vh>jl_gc_is_enabled</vh></v>
<v t="ekr.20120404123906.7740"><vh>jl_gc_ephemeral_on</vh></v>
<v t="ekr.20120404123906.7741"><vh>jl_gc_ephemeral_off</vh></v>
<v t="ekr.20120404123906.7742"><vh>#if defined(MEMPROFILE)</vh></v>
<v t="ekr.20120404123906.7743"><vh>print_obj_profile</vh></v>
<v t="ekr.20120404123906.7744"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7745"><vh>jl_gc_collect</vh></v>
<v t="ekr.20120404123906.7746"><vh>allocb</vh></v>
<v t="ekr.20120404123906.7747"><vh>allocobj</vh></v>
<v t="ekr.20120404123906.7748"><vh>alloc_2w</vh></v>
<v t="ekr.20120404123906.7749"><vh>alloc_3w</vh></v>
<v t="ekr.20120404123906.7750"><vh>alloc_4w</vh></v>
<v t="ekr.20120404123906.7751"><vh>jl_gc_init</vh></v>
<v t="ekr.20120404123906.7752"><vh>#if defined(MEMPROFILE)</vh></v>
<v t="ekr.20120404123906.7753"><vh>pool_stats</vh></v>
<v t="ekr.20120404123906.7754"><vh>all_pool_stats</vh></v>
<v t="ekr.20120404123906.7755"><vh>big_obj_stats</vh></v>
</v>
<v t="ekr.20120404123906.7756"><vh>gf.c</vh>
<v t="ekr.20120404123906.7757"><vh>/*</vh></v>
<v t="ekr.20120404123906.7758"><vh>new_method_table</vh></v>
<v t="ekr.20120404123906.7759"><vh>cache_match_by_type</vh></v>
<v t="ekr.20120404123906.7760"><vh>cache_match</vh></v>
<v t="ekr.20120404123906.7761"><vh>/*</vh></v>
<v t="ekr.20120404123906.7762"><vh>jl_method_table_assoc_exact_by_type</vh></v>
<v t="ekr.20120404123906.7763"><vh>jl_method_table_assoc_exact</vh></v>
<v t="ekr.20120404123906.7764"><vh>// return a new lambda-info that has some extra static parameters</vh></v>
<v t="ekr.20120404123906.7765"><vh>jl_add_static_parameters</vh></v>
<v t="ekr.20120404123906.7766"><vh>JL_CALLABLE(jl_trampoline);</vh></v>
<v t="ekr.20120404123906.7767"><vh>jl_instantiate_method</vh></v>
<v t="ekr.20120404123906.7768"><vh>// make a new method that calls the generated code from the given linfo</vh></v>
<v t="ekr.20120404123906.7769"><vh>jl_reinstantiate_method</vh></v>
<v t="ekr.20120404123906.7770"><vh>static</vh></v>
<v t="ekr.20120404123906.7771"><vh>jl_method_cache_insert</vh></v>
<v t="ekr.20120404123906.7772"><vh>extern jl_function_t *jl_typeinf_func;</vh></v>
<v t="ekr.20120404123906.7773"><vh>print_sig</vh></v>
<v t="ekr.20120404123906.7774"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7775"><vh>nth_slot_type</vh></v>
<v t="ekr.20120404123906.7776"><vh>very_general_type</vh></v>
<v t="ekr.20120404123906.7777"><vh>static jl_value_t *ml_matches(jl_methlist_t *ml, jl_value_t *type,</vh></v>
<v t="ekr.20120404123906.7778"><vh>jl_type_infer</vh></v>
<v t="ekr.20120404123906.7779"><vh>tuple_all_Any</vh></v>
<v t="ekr.20120404123906.7780"><vh>cache_method</vh></v>
<v t="ekr.20120404123906.7781"><vh>lookup_match</vh></v>
<v t="ekr.20120404123906.7782"><vh>jl_mt_assoc_by_type</vh></v>
<v t="ekr.20120404123906.7783"><vh>jl_tag_type_t *jl_wrap_Type(jl_value_t *t);</vh></v>
<v t="ekr.20120404123906.7784"><vh>sigs_eq</vh></v>
<v t="ekr.20120404123906.7785"><vh>jl_args_morespecific</vh></v>
<v t="ekr.20120404123906.7786"><vh>is_va_tuple</vh></v>
<v t="ekr.20120404123906.7787"><vh>/*</vh></v>
<v t="ekr.20120404123906.7788"><vh>check_ambiguous</vh></v>
<v t="ekr.20120404123906.7789"><vh>has_unions</vh></v>
<v t="ekr.20120404123906.7790"><vh>jl_method_list_insert</vh></v>
<v t="ekr.20120404123906.7791"><vh>remove_conflicting</vh></v>
<v t="ekr.20120404123906.7792"><vh>jl_method_table_insert</vh></v>
<v t="ekr.20120404123906.7793"><vh>jl_no_method_error</vh></v>
<v t="ekr.20120404123906.7794"><vh>//#define JL_TRACE</vh></v>
<v t="ekr.20120404123906.7795"><vh>type_summary</vh></v>
<v t="ekr.20120404123906.7796"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7797"><vh>arg_type_tuple</vh></v>
<v t="ekr.20120404123906.7798"><vh>jl_method_lookup_by_type</vh></v>
<v t="ekr.20120404123906.7799"><vh>jl_method_lookup</vh></v>
<v t="ekr.20120404123906.7800"><vh>// compile-time method lookup</vh></v>
<v t="ekr.20120404123906.7801"><vh>jl_get_specialization</vh></v>
<v t="ekr.20120404123906.7802"><vh>jl_compile_hint</vh></v>
<v t="ekr.20120404123906.7803"><vh>#ifdef JL_TRACE</vh></v>
<v t="ekr.20120404123906.7804"><vh>enable_trace</vh></v>
<v t="ekr.20120404123906.7805"><vh>#endif</vh></v>
<v t="ekr.20120404123906.7806"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.7807"><vh>// invoke()</vh></v>
<v t="ekr.20120404123906.7808"><vh>jl_gf_invoke</vh></v>
<v t="ekr.20120404123906.7809"><vh>print_methlist</vh></v>
<v t="ekr.20120404123906.7810"><vh>jl_show_method_table</vh></v>
<v t="ekr.20120404123906.7811"><vh>jl_initialize_generic_function</vh></v>
<v t="ekr.20120404123906.7812"><vh>jl_new_generic_function</vh></v>
<v t="ekr.20120404123906.7813"><vh>jl_add_method</vh></v>
<v t="ekr.20120404123906.7814"><vh>jl_match_method</vh></v>
<v t="ekr.20120404123906.7815"><vh>match_method</vh></v>
<v t="ekr.20120404123906.7816"><vh>// returns linked tuples (argtypes, static_params, lambdainfo, cloenv, next)</vh></v>
<v t="ekr.20120404123906.7817"><vh>ml_matches</vh></v>
<v t="ekr.20120404123906.7818"><vh>void jl_add_constructors(jl_struct_type_t *t);</vh></v>
<v t="ekr.20120404123906.7819"><vh>jl_matching_methods</vh></v>
<v t="ekr.20120404123906.7820"><vh>jl_is_builtin</vh></v>
</v>
<v t="ekr.20120404123906.7821"><vh>h2j.cpp</vh>
<v t="ekr.20120404123906.7822"><vh>h2j declarations</vh></v>
<v t="ekr.20120404123906.7823"><vh>main</vh></v>
</v>
<v t="ekr.20120404123906.7824"><vh>init.c</vh>
<v t="ekr.20120404123906.7825"><vh>init declarations</vh></v>
<v t="ekr.20120404123906.7826"><vh>jl_find_stack_bottom</vh></v>
<v t="ekr.20120404123906.7827"><vh>fpe_handler</vh></v>
<v t="ekr.20120404123906.7828"><vh>segv_handler</vh></v>
<v t="ekr.20120404123906.7829"><vh>sigset_t sset;</vh></v>
<v t="ekr.20120404123906.7830"><vh>sigint_handler</vh></v>
<v t="ekr.20120404123906.7831"><vh>void jl_get_builtin_hooks(void);</vh></v>
<v t="ekr.20120404123906.7832"><vh>julia_init</vh></v>
<v t="ekr.20120404123906.7833"><vh>jl_install_sigint_handler</vh></v>
<v t="ekr.20120404123906.7834"><vh>julia_trampoline</vh></v>
<v t="ekr.20120404123906.7835"><vh>jl_function_t *jl_typeinf_func=NULL;</vh></v>
<v t="ekr.20120404123906.7836"><vh>jl_enable_inference</vh></v>
<v t="ekr.20120404123906.7837"><vh>core</vh></v>
<v t="ekr.20120404123906.7838"><vh>basemod</vh></v>
<v t="ekr.20120404123906.7839"><vh>jl_function_t *jl_method_missing_func=NULL;</vh></v>
<v t="ekr.20120404123906.7840"><vh>jl_get_builtin_hooks</vh></v>
<v t="ekr.20120404123906.7841"><vh>jl_get_system_hooks</vh></v>
</v>
<v t="ekr.20120404123906.7842"><vh>interpreter.c</vh>
<v t="ekr.20120404123906.7843"><vh>interpreter declarations</vh></v>
<v t="ekr.20120404123906.7844"><vh>jl_interpret_toplevel_expr</vh></v>
<v t="ekr.20120404123906.7845"><vh>jl_interpret_toplevel_expr_with</vh></v>
<v t="ekr.20120404123906.7846"><vh>jl_interpret_toplevel_expr_in</vh></v>
<v t="ekr.20120404123906.7847"><vh>do_call</vh></v>
<v t="ekr.20120404123906.7848"><vh>jl_eval_global_var</vh></v>
<v t="ekr.20120404123906.7849"><vh>eval</vh></v>
<v t="ekr.20120404123906.7850"><vh>label_idx</vh></v>
<v t="ekr.20120404123906.7851"><vh>eval_body</vh></v>
<v t="ekr.20120404123906.7852"><vh>jl_interpret_toplevel_thunk_with</vh></v>
<v t="ekr.20120404123906.7853"><vh>jl_interpret_toplevel_thunk</vh></v>
</v>
<v t="ekr.20120404123906.8063"><vh>jltypes.c</vh>
<v t="ekr.20120404123906.8064"><vh>jltypes declarations</vh></v>
<v t="ekr.20120404123906.8065"><vh>type properties and predicates</vh>
<v t="ekr.20120404123906.8066"><vh>jl_is_type</vh></v>
<v t="ekr.20120404123906.8067"><vh>jl_has_typevars_</vh></v>
<v t="ekr.20120404123906.8068"><vh>jl_has_typevars</vh></v>
<v t="ekr.20120404123906.8069"><vh>jl_is_leaf_type (dllexport)</vh></v>
<v t="ekr.20120404123906.8070"><vh>jl_full_type</vh></v>
</v>
<v t="ekr.20120404123906.8072"><vh>type union</vh>
<v t="ekr.20120404123906.8073"><vh>count_union_components</vh></v>
<v t="ekr.20120404123906.8074"><vh>flatten_type_union</vh></v>
<v t="ekr.20120404123906.8075"><vh>union_elt_morespecific</vh></v>
<v t="ekr.20120404123906.8076"><vh>jl_compute_type_union (dllexport)</vh></v>
<v t="ekr.20120404123906.8077"><vh>jl_type_union</vh></v>
</v>
<v t="ekr.20120404123906.8078"><vh>type intersection</vh>
<v t="ekr.20120404123906.8079"><vh>extend &amp; helper</vh>
<v t="ekr.20120404123906.8080"><vh>extend_</vh></v>
</v>
<v t="ekr.20120404123906.8139"><vh>** constraint satisfaction algorithm</vh>
<v t="ekr.20120404123906.8153"><vh>is_btv</vh></v>
<v t="ekr.20120404123906.8140"><vh>jl_type_intersect &amp; helpers</vh>
<v t="ekr.20120404123906.8141"><vh>intersect_union</vh></v>
<v t="ekr.20120404123906.8142"><vh>tuple_intersect_size</vh></v>
<v t="ekr.20120404123906.8143"><vh>intersect_tuple</vh></v>
<v t="ekr.20120404123906.8144"><vh>intersect_tag</vh></v>
<v t="ekr.20120404123906.8145"><vh>intersect_typevar</vh></v>
</v>
<v t="ekr.20120404123906.8146"><vh>jl_type_intersection</vh>
<v t="ekr.20120404123906.8147"><vh>jl_type_intersection_matching</vh>
<v t="ekr.20120404123906.8148"><vh>solve_tvar_constraints</vh>
<v t="ekr.20120404123906.8149"><vh>tvar_lookup</vh></v>
</v>
</v>
</v>
<v t="ekr.20120404123906.8150"><vh>meet</vh>
<v t="ekr.20120404123906.8151"><vh>meet_tvar</vh></v>
<v t="ekr.20120404123906.8152"><vh>meet_tvars</vh></v>
</v>
<v t="ekr.20120404123906.8154"><vh>Not used</vh>
<v t="ekr.20120404123906.8155"><vh>type_summary</vh></v>
<v t="ekr.20120404123906.8156"><vh>print_env</vh></v>
</v>
</v>
</v>
<v t="ekr.20120404123906.8100"><vh>type instantiation and cache</vh>
<v t="ekr.20120404123906.8101"><vh>extensionally_same_type</vh></v>
<v t="ekr.20120404123906.8102"><vh>type_eqv_</vh></v>
<v t="ekr.20120404123906.8103"><vh>jl_types_equal</vh></v>
<v t="ekr.20120404123906.8104"><vh>type_le_generic</vh></v>
<v t="ekr.20120404123906.8105"><vh>jl_types_equal_generic</vh></v>
<v t="ekr.20120404123906.8106"><vh>jl_apply_type_</vh></v>
<v t="ekr.20120404123906.8107"><vh>jl_apply_type</vh></v>
<v t="ekr.20120404123906.8108"><vh>lookup_type</vh></v>
<v t="ekr.20120404123906.8109"><vh>t_uid_ctr</vh></v>
<v t="ekr.20120404123906.8110"><vh>jl_get_t_uid_ctr</vh></v>
<v t="ekr.20120404123906.8111"><vh>jl_set_t_uid_ctr</vh></v>
<v t="ekr.20120404123906.8112"><vh>jl_assign_type_uid</vh></v>
<v t="ekr.20120404123906.8113"><vh>cache_type_</vh></v>
<v t="ekr.20120404123906.8114"><vh>jl_cache_type_</vh></v>
<v t="ekr.20120404123906.8115"><vh>jl_f_tuple &amp; jl_f_ctor_trampoline</vh></v>
<v t="ekr.20120404123906.8116"><vh>inst_type_w_</vh></v>
<v t="ekr.20120404123906.8117"><vh>jl_instantiate_type_with</vh></v>
<v t="ekr.20120404123906.8118"><vh>jl_wrap_Type</vh></v>
<v t="ekr.20120404123906.8119"><vh>jl_reinstantiate_inner_types</vh></v>
<v t="ekr.20120404123906.8120"><vh>jl_subtype_le</vh></v>
<v t="ekr.20120404123906.8121"><vh>jl_tuple_subtype_</vh></v>
<v t="ekr.20120404123906.8122"><vh>jl_tuple_subtype</vh></v>
<v t="ekr.20120404123906.8123"><vh>tuple_all_subtype</vh></v>
<v t="ekr.20120404123906.8124"><vh>jl_subtype_le</vh></v>
<v t="ekr.20120404123906.8125"><vh>jl_subtype</vh></v>
<v t="ekr.20120404123906.8126"><vh>jl_subtype_invariant</vh></v>
<v t="ekr.20120404123906.8127"><vh>jl_type_morespecific</vh></v>
<v t="ekr.20120404123906.8128"><vh>type_match</vh></v>
<v t="ekr.20120404123906.8129"><vh>tuple_match</vh></v>
<v t="ekr.20120404123906.8130"><vh>type_match_</vh></v>
<v t="ekr.20120404123906.8131"><vh>jl_type_match_</vh></v>
<v t="ekr.20120404123906.8132"><vh>jl_type_match</vh></v>
<v t="ekr.20120404123906.8133"><vh>jl_type_match_morespecific</vh></v>
</v>
<v t="ekr.20120404123906.8134"><vh>initialization</vh>
<v t="ekr.20120404123906.8135"><vh>jl_new_typevar</vh></v>
<v t="ekr.20120404123906.8136"><vh>tvar</vh></v>
<v t="ekr.20120404123906.8137"><vh>extern void jl_init_int32_int64_cache(void);</vh></v>
<v t="ekr.20120404123906.8138"><vh>jl_init_types</vh></v>
</v>
</v>
<v t="ekr.20120404123906.7930"><vh>module.c</vh>
<v t="ekr.20120404123906.7931"><vh>module declarations</vh></v>
<v t="ekr.20120404123906.7932"><vh>jl_new_module</vh></v>
<v t="ekr.20120404123906.7933"><vh>// get binding for assignment</vh></v>
<v t="ekr.20120404123906.7934"><vh>jl_get_binding_wr</vh></v>
<v t="ekr.20120404123906.7935"><vh>// get binding for reading. might return NULL for unbound.</vh></v>
<v t="ekr.20120404123906.7936"><vh>jl_get_binding</vh></v>
<v t="ekr.20120404123906.7937"><vh>jl_boundp</vh></v>
<v t="ekr.20120404123906.7938"><vh>jl_get_global</vh></v>
<v t="ekr.20120404123906.7939"><vh>jl_set_global</vh></v>
<v t="ekr.20120404123906.7940"><vh>jl_set_const</vh></v>
<v t="ekr.20120404123906.7941"><vh>jl_is_const</vh></v>
<v t="ekr.20120404123906.7942"><vh>jl_checked_assignment</vh></v>
<v t="ekr.20120404123906.7943"><vh>jl_declare_constant</vh></v>
<v t="ekr.20120404123906.7944"><vh>jl_module_t *jl_add_module(jl_module_t *m, jl_module_t *child);</vh></v>
<v t="ekr.20120404123906.7945"><vh>jl_get_expander</vh></v>
<v t="ekr.20120404123906.7946"><vh>jl_set_expander</vh></v>
<v t="ekr.20120404123906.7947"><vh>jl_get_current_module</vh></v>
<v t="ekr.20120404123906.7948"><vh>jl_set_current_module</vh></v>
</v>
<v t="ekr.20120404123906.7949"><vh>newobj_internal.h</vh>
<v t="ekr.20120404123906.7950"><vh>#ifndef NEWOBJ_INTERNAL_H</vh></v>
<v t="ekr.20120404123906.7951"><vh>newobj</vh></v>
</v>
<v t="ekr.20120404123906.7952"><vh>sys.c</vh>
<v t="ekr.20120404123906.7953"><vh>/*</vh></v>
<v t="ekr.20120404123906.7954"><vh>jl__not__used__</vh></v>
<v t="ekr.20120404123906.7955"><vh>jl_sizeof_fd_set</vh></v>
<v t="ekr.20120404123906.7956"><vh>jl_sizeof_timeval</vh></v>
<v t="ekr.20120404123906.7957"><vh>jl_set_timeval</vh></v>
<v t="ekr.20120404123906.7958"><vh>jl_fd_clr</vh></v>
<v t="ekr.20120404123906.7959"><vh>jl_fd_isset</vh></v>
<v t="ekr.20120404123906.7960"><vh>jl_fd_set</vh></v>
<v t="ekr.20120404123906.7961"><vh>jl_fd_zero</vh></v>
<v t="ekr.20120404123906.7962"><vh>jl_getutf8</vh></v>
<v t="ekr.20120404123906.7963"><vh>jl_ios_size</vh></v>
<v t="ekr.20120404123906.7964"><vh>jl_sizeof_off_t</vh></v>
<v t="ekr.20120404123906.7965"><vh>jl_ios_fd</vh></v>
<v t="ekr.20120404123906.7966"><vh>jl_nb_available</vh></v>
<v t="ekr.20120404123906.7967"><vh>// --- io constructors ---</vh></v>
<v t="ekr.20120404123906.7968"><vh>jl_sizeof_ios_t</vh></v>
<v t="ekr.20120404123906.7969"><vh>// hack to expose ios_stdout to julia. we could create a new iostream pointing</vh></v>
<v t="ekr.20120404123906.7970"><vh>jl_stdout_stream</vh></v>
<v t="ekr.20120404123906.7971"><vh>// --- current output stream ---</vh></v>
<v t="ekr.20120404123906.7972"><vh>jl_current_output_stream_obj</vh></v>
<v t="ekr.20120404123906.7973"><vh>jl_current_output_stream</vh></v>
<v t="ekr.20120404123906.7974"><vh>jl_set_current_output_stream_obj</vh></v>
<v t="ekr.20120404123906.7975"><vh>// --- buffer manipulation ---</vh></v>
<v t="ekr.20120404123906.7976"><vh>jl_takebuf_array</vh></v>
<v t="ekr.20120404123906.7977"><vh>jl_takebuf_string</vh></v>
<v t="ekr.20120404123906.7978"><vh>jl_readuntil</vh></v>
<v t="ekr.20120404123906.7979"><vh>// -- syscall utilities --</vh></v>
<v t="ekr.20120404123906.7980"><vh>jl_errno</vh></v>
<v t="ekr.20120404123906.7981"><vh>jl_strerror</vh></v>
<v t="ekr.20120404123906.7982"><vh>// -- iterating the environment --</vh></v>
<v t="ekr.20120404123906.7983"><vh>jl_environ</vh></v>
<v t="ekr.20120404123906.7984"><vh>// -- child process status --</vh></v>
<v t="ekr.20120404123906.7985"><vh>jl_process_exited</vh></v>
<v t="ekr.20120404123906.7986"><vh>jl_process_signaled</vh></v>
<v t="ekr.20120404123906.7987"><vh>jl_process_stopped</vh></v>
<v t="ekr.20120404123906.7988"><vh>jl_process_exit_status</vh></v>
<v t="ekr.20120404123906.7989"><vh>jl_process_term_signal</vh></v>
<v t="ekr.20120404123906.7990"><vh>jl_process_stop_signal</vh></v>
<v t="ekr.20120404123906.7991"><vh>// -- access to std filehandles --</vh></v>
<v t="ekr.20120404123906.7992"><vh>jl_stdin</vh></v>
<v t="ekr.20120404123906.7993"><vh>jl_stdout</vh></v>
<v t="ekr.20120404123906.7994"><vh>jl_stderr</vh></v>
<v t="ekr.20120404123906.7995"><vh>// -- I/O thread --</vh></v>
<v t="ekr.20120404123906.7996"><vh>run_io_thr</vh></v>
<v t="ekr.20120404123906.7997"><vh>jl_buf_mutex_lock</vh></v>
<v t="ekr.20120404123906.7998"><vh>jl_buf_mutex_unlock</vh></v>
<v t="ekr.20120404123906.7999"><vh>jl_enq_send_req</vh></v>
<v t="ekr.20120404123906.8000"><vh>jl_start_io_thread</vh></v>
</v>
<v t="ekr.20120404123906.8001"><vh>table.c</vh>
<v t="ekr.20120404123906.8002"><vh>table declarations</vh></v>
<v t="ekr.20120404123906.8003"><vh>jl_idtable_rehash</vh></v>
<v t="ekr.20120404123906.8004"><vh>jl_table_lookup_bp</vh></v>
<v t="ekr.20120404123906.8005"><vh>/* returns bp if key is in hash, otherwise NULL */</vh></v>
<v t="ekr.20120404123906.8006"><vh>jl_table_peek_bp</vh></v>
<v t="ekr.20120404123906.8007"><vh>jl_eqtable_put</vh></v>
<v t="ekr.20120404123906.8008"><vh>jl_eqtable_get</vh></v>
<v t="ekr.20120404123906.8009"><vh>jl_eqtable_del</vh></v>
<v t="ekr.20120404123906.8010"><vh>jl_eqtable_next</vh></v>
</v>
<v t="ekr.20120404123906.8011"><vh>task.c</vh>
<v t="ekr.20120404123906.8012"><vh>task declarations</vh></v>
<v t="ekr.20120404123906.8013"><vh>boundhigh</vh></v>
<v t="ekr.20120404123906.8014"><vh>probe</vh></v>
<v t="ekr.20120404123906.8015"><vh>boundlow</vh></v>
<v t="ekr.20120404123906.8016"><vh>// we need this function to exist so we can measure its stack frame!</vh></v>
<v t="ekr.20120404123906.8017"><vh>fill</vh></v>
<v t="ekr.20120404123906.8018"><vh>_infer_direction_from</vh></v>
<v t="ekr.20120404123906.8019"><vh>_infer_stack_direction</vh></v>
<v t="ekr.20120404123906.8020"><vh>static int mangle_pointers;</vh></v>
<v t="ekr.20120404123906.8021"><vh>_probe_arch</vh></v>
<v t="ekr.20120404123906.8022"><vh>/* end probing code */</vh></v>
<v t="ekr.20120404123906.8023"><vh>save_stack</vh></v>
<v t="ekr.20120404123906.8024"><vh>restore_stack</vh></v>
<v t="ekr.20120404123906.8025"><vh>switch_stack</vh></v>
<v t="ekr.20120404123906.8026"><vh>jl_switch_stack</vh></v>
<v t="ekr.20120404123906.8027"><vh>#endif</vh></v>
<v t="ekr.20120404123906.8028"><vh>ctx_switch</vh></v>
<v t="ekr.20120404123906.8029"><vh>switchto</vh></v>
<v t="ekr.20120404123906.8030"><vh>#ifndef COPY_STACKS</vh></v>
<v t="ekr.20120404123906.8031"><vh>ptr_mangle</vh></v>
<v t="ekr.20120404123906.8032"><vh>ptr_demangle</vh></v>
<v t="ekr.20120404123906.8033"><vh>#elif defined(__x86_64__)</vh></v>
<v t="ekr.20120404123906.8034"><vh>ptr_mangle</vh></v>
<v t="ekr.20120404123906.8035"><vh>ptr_demangle</vh></v>
<v t="ekr.20120404123906.8036"><vh>#endif</vh></v>
<v t="ekr.20120404123906.8037"><vh>rebase_state</vh></v>
<v t="ekr.20120404123906.8038"><vh>#endif /* !COPY_STACKS */</vh></v>
<v t="ekr.20120404123906.8039"><vh>jl_switchto</vh></v>
<v t="ekr.20120404123906.8040"><vh>finish_task</vh></v>
<v t="ekr.20120404123906.8041"><vh>start_task</vh></v>
<v t="ekr.20120404123906.8042"><vh>#ifndef COPY_STACKS</vh></v>
<v t="ekr.20120404123906.8043"><vh>init_task</vh></v>
<v t="ekr.20120404123906.8044"><vh>#endif</vh></v>
<v t="ekr.20120404123906.8045"><vh>push_frame_info_from_ip</vh></v>
<v t="ekr.20120404123906.8046"><vh>#if defined(__APPLE__)</vh></v>
<v t="ekr.20120404123906.8047"><vh>build_backtrace</vh></v>
<v t="ekr.20120404123906.8048"><vh>#else</vh></v>
<v t="ekr.20120404123906.8049"><vh>build_backtrace</vh></v>
<v t="ekr.20120404123906.8050"><vh>#endif</vh></v>
<v t="ekr.20120404123906.8051"><vh>jl_register_toplevel_eh</vh></v>
<v t="ekr.20120404123906.8052"><vh>// yield to exception handler</vh></v>
<v t="ekr.20120404123906.8053"><vh>jl_raise</vh></v>
<v t="ekr.20120404123906.8054"><vh>jl_new_task</vh></v>
<v t="ekr.20120404123906.8055"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.8056"><vh>#define JL_MIN_STACK     (4096*sizeof(void*))</vh></v>
<v t="ekr.20120404123906.8057"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.8058"><vh>JL_CALLABLE</vh></v>
<v t="ekr.20120404123906.8059"><vh>jl_get_current_task</vh></v>
<v t="ekr.20120404123906.8060"><vh>jl_function_t *jl_unprotect_stack_func;</vh></v>
<v t="ekr.20120404123906.8061"><vh>jl_init_tasks</vh></v>
</v>
<v t="ekr.20120404123906.8062"><vh>utils.scm</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20120404123906.7255" str_leo_pos="1">import os

@others

types = ('.c','.cpp','expmap','.h','.jl','.scm',)
theDir =  r'C:\leo.repo\julia\src'
recursive = False

if  g.os_path_exists(theDir):
    importFiles(theDir,types,recursive)
    g.es("done",color="blue")
else:
    g.es("directory does not exist: " + theDir)
</t>
<t tx="ekr.20120404123906.7256">def cleanEmptyDirs(root):
    
    '''Remove all @path nodes not containing any @auto nodes.'''
    p = root.copy()
    while p:
        if p.h.startswith('@path') and isEmpty(p):
            next = p.nodeAfterTree()
            p.doDelete()
            p = next
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20120404123906.7257">def isEmpty(p):
    
    for p in p.subtree():
        if p.h.startswith('@auto'):
            return False
    else:
        return True
</t>
<t tx="ekr.20120404123906.7258">def computeFiles (theDir,recursive):
    
    '''Compute the lists of all directories and files to be added.'''
    
    dirs,files = [],[]
    for f in os.listdir(theDir):
        path = g.os_path_join(theDir,f)
        if g.os_path_isfile(path):
            name, ext = g.os_path_splitext(f)
            if not types or ext in types:
                files.append(path)
        elif recursive:
            dirs.append(path)
        
    return dirs,files
</t>
<t tx="ekr.20120404123906.7259">def createLastChildOf (p,headline):

    child = p.insertAsLastChild()
    child.h = headline.replace('\\','/')
    return child
</t>
<t tx="ekr.20120404123906.7260">def importDir (theDir,types,recursive,root,level=0):

    # g.es("theDir: " + theDir,color="blue")

    dirs,files = computeFiles(theDir,recursive)
    if not dirs and not files: return
    
    path_part = g.choose(level==0,theDir,g.os_path_basename(theDir))
    root = createLastChildOf(root,'@path %s' % (path_part))
    c.selectPosition(root)
    
    for fn in files:
        p2 = createLastChildOf(root,'@auto %s' % (
            g.shortFileName(fn)))
            
    # dirs.sort()
    for theDir in sorted(dirs):
        importDir(theDir,types,recursive,root,level+1)
</t>
<t tx="ekr.20120404123906.7261">def importFiles (theDir,type=None,recursive=False):
    
    root = c.p.insertAfter()
    root.h = "imported files"
    try:
        importDir (theDir,type,recursive,root)
        cleanEmptyDirs(root)
        c.contractAllHeadlines()
        c.selectPosition(root)
        root.expand()
        for p in root.subtree():
            p.clearDirty() # Important: don't write automatically.
        c.redraw()
    except Exception:
        g.es("exception in importFiles script")
        g.es_exception()
    
</t>
<t tx="ekr.20120404123906.7262"></t>
<t tx="ekr.20120404123906.7263"></t>
<t tx="ekr.20120404123906.7264">@language c
@tabwidth -4
@others
#endif
</t>
<t tx="ekr.20120404123906.7265">#ifndef BUILTIN_PROTO_H
#define BUILTIN_PROTO_H

// declarations for julia-callable builtin functions

JL_CALLABLE(jl_f_new_expr);
JL_CALLABLE(jl_f_new_box);
JL_CALLABLE(jl_f_throw);
JL_CALLABLE(jl_f_is);
JL_CALLABLE(jl_f_no_function);
JL_CALLABLE(jl_f_typeof);
JL_CALLABLE(jl_f_subtype);
JL_CALLABLE(jl_f_isa);
JL_CALLABLE(jl_f_typeassert);
JL_CALLABLE(jl_f_apply);
JL_CALLABLE(jl_f_top_eval);
JL_CALLABLE(jl_f_isbound);
JL_CALLABLE(jl_f_tuple);
JL_CALLABLE(jl_f_tupleref);
JL_CALLABLE(jl_f_tuplelen);
JL_CALLABLE(jl_f_get_field);
JL_CALLABLE(jl_f_set_field);
JL_CALLABLE(jl_f_field_type);
JL_CALLABLE(jl_f_arraylen);
JL_CALLABLE(jl_f_arrayref);
JL_CALLABLE(jl_f_arrayset);
JL_CALLABLE(jl_f_arraysize);
JL_CALLABLE(jl_f_instantiate_type);
JL_CALLABLE(jl_f_convert_default);
JL_CALLABLE(jl_f_convert_tuple);
JL_CALLABLE(jl_trampoline);
JL_CALLABLE(jl_f_new_struct_type);
JL_CALLABLE(jl_f_new_struct_fields);
JL_CALLABLE(jl_f_new_type_constructor);
JL_CALLABLE(jl_f_new_tag_type);
JL_CALLABLE(jl_f_new_tag_type_super);
JL_CALLABLE(jl_f_new_bits_type);
JL_CALLABLE(jl_f_def_macro);
JL_CALLABLE(jl_f_typevar);
JL_CALLABLE(jl_f_union);
JL_CALLABLE(jl_f_methodexists);
JL_CALLABLE(jl_f_applicable);
JL_CALLABLE(jl_f_invoke);
JL_CALLABLE(jl_apply_generic);
JL_CALLABLE(jl_unprotect_stack);
JL_CALLABLE(jl_f_task);
JL_CALLABLE(jl_f_yieldto);
JL_CALLABLE(jl_f_ctor_trampoline);

</t>
<t tx="ekr.20120404123906.7266">@language c
@tabwidth -4
@others
#endif
</t>
<t tx="ekr.20120404123906.7267">#ifndef JLTYPES_INTERNAL_H
#define JLTYPES_INTERNAL_H

void jl_cache_type_(jl_tag_type_t *type);

int  jl_get_t_uid_ctr(void);
void jl_set_t_uid_ctr(int i);
uint32_t jl_get_gs_ctr(void);
void jl_set_gs_ctr(uint32_t ctr);

</t>
<t tx="ekr.20120404123906.7268">@language c
@tabwidth -4
@others

DLLEXPORT void jl_enter_handler(jl_savestate_t *ss, jmp_buf *handlr);
DLLEXPORT void jl_pop_handler(int n);

#define JL_TRY                                                          \
    int i__tr, i__ca; jl_savestate_t __ss; jmp_buf __handlr;            \
    jl_enter_handler(&amp;__ss, &amp;__handlr);                                 \
    if (!setjmp(__handlr))                                              \
        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&amp;__ss))

#define JL_EH_POP() jl_eh_restore_state(&amp;__ss)

#define JL_CATCH                                                \
    else                                                        \
        for (i__ca=1, jl_current_task-&gt;state.err = 0,           \
             jl_eh_restore_state(&amp;__ss); i__ca; i__ca=0)

#endif
@ignore</t>
<t tx="ekr.20120404123906.7269">#ifndef JULIA_H
#define JULIA_H

#include "libsupport.h"

#define JL_GC_MARKSWEEP

#include "htable.h"
#include "arraylist.h"
#include &lt;setjmp.h&gt;

#define JL_STRUCT_TYPE \
    struct _jl_type_t *type;

typedef struct _jl_value_t {
    JL_STRUCT_TYPE
} jl_value_t;

typedef struct _jl_sym_t {
    JL_STRUCT_TYPE
    struct _jl_sym_t *left;
    struct _jl_sym_t *right;
    uptrint_t hash;    // precomputed hash value
    union {
        char name[1];
        void *_pad;    // ensure field aligned to pointer size
    };
} jl_sym_t;

typedef struct {
    JL_STRUCT_TYPE
    size_t length;
    jl_value_t *data[1];
} jl_tuple_t;

typedef struct {
    JL_STRUCT_TYPE
    size_t length;
    jl_value_t *data[2];
} jl_tuple2_t;

// how much space we're willing to waste if an array outgrows its
// original object
#define ARRAY_INLINE_NBYTES (1024*sizeof(void*))

typedef struct {
    JL_STRUCT_TYPE
    void *data;
    size_t length;
    unsigned short ndims:15;
    unsigned short reshaped:1;
    uint16_t elsize;
    uint32_t offset;  // for 1-d only. does not need to get big.
    size_t nrows;
    union {
        // 1d
        size_t maxsize;
        // Nd
        size_t ncols;
    };
    union {
        char _space[1];
        void *_pad;
    };
} jl_array_t;

typedef struct _jl_type_t {
    JL_STRUCT_TYPE
} jl_type_t;

</t>
<t tx="ekr.20120404123906.7270">typedef jl_value_t *(*jl_fptr_t)(jl_value_t*, jl_value_t**, uint32_t);

typedef struct _jl_lambda_info_t {
    JL_STRUCT_TYPE
    // this holds the static data for a function:
    // a syntax tree, static parameters, and (if it has been compiled)
    // a function pointer.
    // this is the stuff that's shared among different instantiations
    // (different environments) of a closure.
    jl_value_t *ast;
    // sparams is a tuple (symbol, value, symbol, value, ...)
    jl_tuple_t *sparams;
    jl_value_t *tfunc;
    jl_sym_t *name;  // for error reporting
    jl_array_t *roots;  // pointers in generated code
    jl_value_t *specTypes;  // argument types this is specialized for
    // a slower-but-works version of this function as a fallback
    struct _jl_function_t *unspecialized;
    // pairlist of all lambda infos with code generated from this one
    jl_array_t *specializations;
    jl_value_t *inferred;
    jl_value_t *file;
    jl_value_t *line;
    struct _jl_module_t *module;

    // hidden fields:
    jl_fptr_t fptr;
    void *functionObject;
    // flag telling if inference is running on this function
    // used to avoid infinite recursion
    uptrint_t inInference : 1;
    uptrint_t inCompile : 1;
} </t>
<t tx="ekr.20120404123906.7271">jl_lambda_info_t;

#define LAMBDA_INFO_NW (NWORDS(sizeof(jl_lambda_info_t))-1)

#define JL_FUNC_FIELDS                          \
   jl_fptr_t fptr;                             \
   jl_value_t *env;                            \
   jl_lambda_info_t *linfo;

typedef struct _jl_function_t {
   JL_STRUCT_TYPE
   JL_FUNC_FIELDS
} jl_function_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_tuple_t *parameters;
   jl_type_t *body;
} jl_typector_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_sym_t *name;
   // if this is the name of a parametric type, this field points to the
   // original type.
   // a type alias, for example, might make a type constructor that is
   // not the original.
   jl_value_t *primary;
   jl_tuple_t *cache;
} jl_typename_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_tuple_t *types;
} jl_uniontype_t;

typedef struct _jl_tag_type_t {
   JL_STRUCT_TYPE
   JL_FUNC_FIELDS
   jl_typename_t *name;
   struct _jl_tag_type_t *super;
   jl_tuple_t *parameters;
} jl_tag_type_t;

typedef struct {
   JL_STRUCT_TYPE
   JL_FUNC_FIELDS
   jl_typename_t *name;
   jl_tag_type_t *super;
   jl_tuple_t *parameters;
   jl_tuple_t *names;
   jl_tuple_t *types;
   // to create a set of constructors for this sort of type
   jl_value_t *ctor_factory;
   jl_value_t *instance;  // for singletons
   // hidden fields:
   uptrint_t uid;
} jl_struct_type_t;

typedef struct {
   JL_STRUCT_TYPE
   JL_FUNC_FIELDS
   jl_typename_t *name;
   jl_tag_type_t *super;
   jl_tuple_t *parameters;
   jl_value_t *bnbits;
   // hidden fields:
   size_t nbits;
   uptrint_t uid;
} jl_bits_type_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_sym_t *name;
   jl_value_t *lb;   // lower bound
   jl_value_t *ub;   // upper bound
   uptrint_t bound;  // part of a constraint environment
} jl_tvar_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_value_t *value;
} jl_weakref_t;

typedef struct {
   // not first-class
   jl_sym_t *name;
   jl_value_t *value;
   jl_type_t *type;
   int constp:1;
   int exportp:1;
} jl_binding_t;

typedef struct _jl_module_t {
   JL_STRUCT_TYPE
   jl_sym_t *name;
   htable_t bindings;
   htable_t macros;
   arraylist_t imports;
} jl_module_t;

typedef struct _jl_methlist_t {
   JL_STRUCT_TYPE
   jl_tuple_t *sig;
   jl_value_t *va;
   jl_tuple_t *tvars;
   jl_function_t *func;
   // cache of specializations of this method for invoke(), i.e.
   // cases where this method was called even though it was not necessarily
   // the most specific for the argument types.
   struct _jl_methtable_t *invokes;
   // TODO: pointer from specialized to original method
   //jl_function_t *orig_method;
   struct _jl_methlist_t *next;
} jl_methlist_t;

//#define JL_GF_PROFILE

typedef struct _jl_methtable_t {
   JL_STRUCT_TYPE
   jl_sym_t *name;
   jl_methlist_t *defs;
   jl_methlist_t *cache;
   jl_array_t *cache_arg1;
   jl_array_t *cache_targ;
   jl_value_t *max_args;  // max # of non-vararg arguments in a signature
#ifdef JL_GF_PROFILE
   int ncalls;
#endif
} jl_methtable_t;

typedef struct {
   JL_STRUCT_TYPE
   jl_sym_t *head;
   jl_array_t *args;
   jl_value_t *etype;
} jl_expr_t;

extern jl_tag_type_t *jl_any_type;
extern jl_tag_type_t *jl_type_type;
extern jl_tvar_t     *jl_typetype_tvar;
extern jl_tag_type_t *jl_typetype_type;
extern jl_value_t    *jl_ANY_flag;
extern jl_tag_type_t *jl_undef_type;
extern jl_struct_type_t *jl_typename_type;
extern jl_struct_type_t *jl_typector_type;
extern jl_struct_type_t *jl_sym_type;
extern jl_struct_type_t *jl_symbol_type;
extern jl_tuple_t *jl_tuple_type;
extern jl_tag_type_t *jl_ntuple_type;
extern jl_typename_t *jl_ntuple_typename;
extern jl_struct_type_t *jl_tvar_type;
extern jl_struct_type_t *jl_task_type;

extern jl_struct_type_t *jl_union_kind;
extern jl_struct_type_t *jl_tag_kind;
extern jl_struct_type_t *jl_tag_type_type;
extern DLLEXPORT jl_struct_type_t *jl_struct_kind;
extern jl_struct_type_t *jl_bits_kind;

extern jl_type_t *jl_bottom_type;
extern jl_value_t *jl_top_type;
extern jl_struct_type_t *jl_lambda_info_type;
extern jl_struct_type_t *jl_module_type;
extern jl_tag_type_t *jl_seq_type;
extern jl_struct_type_t *jl_function_type;
extern jl_tag_type_t *jl_abstractarray_type;
extern jl_struct_type_t *jl_array_type;
extern jl_typename_t *jl_array_typename;
extern jl_struct_type_t *jl_weakref_type;
extern jl_struct_type_t *jl_ascii_string_type;
extern jl_struct_type_t *jl_utf8_string_type;
extern jl_struct_type_t *jl_errorexception_type;
extern jl_struct_type_t *jl_typeerror_type;
extern jl_struct_type_t *jl_loaderror_type;
extern jl_struct_type_t *jl_backtrace_type;
extern jl_value_t *jl_stackovf_exception;
extern jl_value_t *jl_memory_exception;
extern jl_value_t *jl_divbyzero_exception;
extern jl_value_t *jl_undefref_exception;
extern jl_value_t *jl_interrupt_exception;
extern jl_value_t *jl_an_empty_cell;

extern jl_struct_type_t *jl_box_type;
extern jl_type_t *jl_box_any_type;
extern jl_typename_t *jl_box_typename;

extern jl_bits_type_t *jl_bool_type;
extern jl_bits_type_t *jl_char_type;
extern jl_bits_type_t *jl_int8_type;
extern jl_bits_type_t *jl_uint8_type;
extern jl_bits_type_t *jl_int16_type;
extern jl_bits_type_t *jl_uint16_type;
extern jl_bits_type_t *jl_int32_type;
extern jl_bits_type_t *jl_uint32_type;
extern jl_bits_type_t *jl_int64_type;
extern jl_bits_type_t *jl_uint64_type;
extern jl_bits_type_t *jl_float32_type;
extern jl_bits_type_t *jl_float64_type;

extern jl_bits_type_t *jl_pointer_type;

extern jl_type_t *jl_array_uint8_type;
extern jl_type_t *jl_array_any_type;
extern DLLEXPORT jl_struct_type_t *jl_expr_type;
extern jl_struct_type_t *jl_symbolnode_type;
extern jl_struct_type_t *jl_linenumbernode_type;
extern jl_struct_type_t *jl_labelnode_type;
extern jl_struct_type_t *jl_gotonode_type;
extern jl_struct_type_t *jl_quotenode_type;
extern jl_struct_type_t *jl_topnode_type;
extern jl_bits_type_t *jl_intrinsic_type;
extern jl_struct_type_t *jl_methtable_type;
extern jl_struct_type_t *jl_method_type;
extern jl_struct_type_t *jl_task_type;

extern jl_tuple_t *jl_null;
extern jl_value_t *jl_true;
extern jl_value_t *jl_false;
DLLEXPORT extern jl_value_t *jl_nothing;

extern jl_function_t *jl_method_missing_func;
extern jl_function_t *jl_unprotect_stack_func;

extern void *jl_dl_handle;

// some important symbols
extern jl_sym_t *call_sym;
extern jl_sym_t *call1_sym;
extern jl_sym_t *dots_sym;
extern jl_sym_t *quote_sym;
extern jl_sym_t *top_sym;
extern jl_sym_t *line_sym;
extern jl_sym_t *multivalue_sym;
extern DLLEXPORT jl_sym_t *jl_continue_sym;
extern jl_sym_t *error_sym;   extern jl_sym_t *amp_sym;
extern jl_sym_t *module_sym;  extern jl_sym_t *colons_sym;
extern jl_sym_t *goto_sym;    extern jl_sym_t *goto_ifnot_sym;
extern jl_sym_t *label_sym;   extern jl_sym_t *return_sym;
extern jl_sym_t *lambda_sym;  extern jl_sym_t *assign_sym;
extern jl_sym_t *null_sym;    extern jl_sym_t *body_sym;
extern jl_sym_t *macro_sym;   extern jl_sym_t *method_sym;
extern jl_sym_t *enter_sym;   extern jl_sym_t *leave_sym;
extern jl_sym_t *exc_sym;     extern jl_sym_t *new_sym;
extern jl_sym_t *static_typeof_sym;
extern jl_sym_t *const_sym;   extern jl_sym_t *thunk_sym;
extern jl_sym_t *anonymous_sym;  extern jl_sym_t *underscore_sym;

#ifdef __LP64__
#define NWORDS(sz) (((sz)+7)&gt;&gt;3)
#else
#define NWORDS(sz) (((sz)+3)&gt;&gt;2)
#endif

#ifdef JL_GC_MARKSWEEP
void *allocb(size_t sz);
void *allocobj(size_t sz);
#else
#define allocb(nb)    malloc(nb)
#define allocobj(nb)  malloc(nb)
#endif

#define jl_tupleref(t,i) (((jl_value_t**)(t))[2+(i)])
#define jl_tupleset(t,i,x) ((((jl_value_t**)(t))[2+(i)])=(x))
#define jl_t0(t) jl_tupleref(t,0)
#define jl_t1(t) jl_tupleref(t,1)

#define jl_cellref(a,i) (((jl_value_t**)((jl_array_t*)a)-&gt;data)[(i)])
#define jl_cellset(a,i,x) ((((jl_value_t**)((jl_array_t*)a)-&gt;data)[(i)])=((jl_value_t*)(x)))

#define jl_exprarg(e,n) jl_cellref(((jl_expr_t*)(e))-&gt;args,n)

#define jl_fieldref(s,i) (((jl_value_t**)(s))[1+(i)])

#define jl_symbolnode_sym(s) ((jl_sym_t*)jl_fieldref(s,0))
#define jl_symbolnode_type(s) (jl_fieldref(s,1))
#define jl_linenode_line(x) jl_unbox_long(jl_fieldref(x,0))
#define jl_labelnode_label(x) jl_unbox_long(jl_fieldref(x,0))
#define jl_gotonode_label(x) jl_unbox_long(jl_fieldref(x,0))

#define jl_tparam0(t) jl_tupleref(((jl_tag_type_t*)(t))-&gt;parameters, 0)
#define jl_tparam1(t) jl_tupleref(((jl_tag_type_t*)(t))-&gt;parameters, 1)

#define jl_typeof(v) (((jl_value_t*)(v))-&gt;type)
#define jl_typeis(v,t) (jl_typeof(v)==(jl_type_t*)(t))

#define jl_is_null(v)        (((jl_value_t*)(v)) == ((jl_value_t*)jl_null))
#define jl_is_tuple(v)       jl_typeis(v,jl_tuple_type)
#define jl_is_tag_type(v)    jl_typeis(v,jl_tag_kind)
#define jl_is_some_tag_type(v) (jl_is_tag_type(v)||jl_is_struct_type(v)||jl_is_bits_type(v))
#define jl_is_bits_type(v)   jl_typeis(v,jl_bits_kind)
#define jl_bitstype_nbits(t) (((jl_bits_type_t*)t)-&gt;nbits)
#define jl_is_struct_type(v) jl_typeis(v,jl_struct_kind)
#define jl_is_union_type(v)  jl_typeis(v,jl_union_kind)
#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)
#define jl_is_typector(v)    jl_typeis(v,jl_typector_type)
#define jl_is_TypeConstructor(v)    jl_typeis(v,jl_typector_type)
#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)
#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)
#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)
#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)
#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)
#define jl_is_float32(v)     jl_typeis(v,jl_float32_type)
#define jl_is_float64(v)     jl_typeis(v,jl_float64_type)
#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)
#define jl_is_symbol(v)      jl_typeis(v,jl_sym_type)
#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)
#define jl_is_symbolnode(v)  jl_typeis(v,jl_symbolnode_type)
#define jl_is_labelnode(v)   jl_typeis(v,jl_labelnode_type)
#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)
#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)
#define jl_is_topnode(v)     jl_typeis(v,jl_topnode_type)
#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)
#define jl_is_lambda_info(v) jl_typeis(v,jl_lambda_info_type)
#define jl_is_module(v)      jl_typeis(v,jl_module_type)
#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)
#define jl_is_task(v)        jl_typeis(v,jl_task_type)
#define jl_is_func(v)        (jl_typeis(v,jl_function_type) || jl_is_struct_type(v))
#define jl_is_function(v)    jl_is_func(v)
#define jl_is_ascii_string(v) jl_typeis(v,jl_ascii_string_type)
#define jl_is_utf8_string(v) jl_typeis(v,jl_utf8_string_type)
#define jl_is_byte_string(v) (jl_is_ascii_string(v) || jl_is_utf8_string(v))
#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))
#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))
#define jl_is_gf(f)          (((jl_function_t*)(f))-&gt;fptr==jl_apply_generic)

#define jl_array_len(a)   (((jl_array_t*)(a))-&gt;length)
#define jl_array_data(a)  ((void*)((jl_array_t*)(a))-&gt;data)
#define jl_array_dim(a,i) ((&amp;((jl_array_t*)(a))-&gt;nrows)[i])
#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)-&gt;ndims))
#define jl_cell_data(a)   ((jl_value_t**)((jl_array_t*)a)-&gt;data)
#define jl_string_data(s) ((char*)((jl_array_t*)((jl_value_t**)(s))[1])-&gt;data)

#define jl_gf_mtable(f) ((jl_methtable_t*)((jl_function_t*)(f))-&gt;env)
#define jl_gf_name(f)   (jl_gf_mtable(f)-&gt;name)

// get a pointer to the data in a value of bits type
#define jl_bits_data(v) (&amp;((void**)(v))[1])

</t>
<t tx="ekr.20120404123906.7272">static inline int jl_is_array_type(void *t)
{
    return (jl_is_struct_type(t) &amp;&amp;
            ((jl_struct_type_t*)(t))-&gt;name == jl_array_typename);
}
</t>
<t tx="ekr.20120404123906.7273">
static inline int jl_is_array(void *v)
{
    jl_type_t *t = jl_typeof(v);
    return jl_is_array_type(t);
}
</t>
<t tx="ekr.20120404123906.7274">
static inline int jl_is_box(void *v)
{
    jl_type_t *t = jl_typeof(v);
    return (jl_is_struct_type(t) &amp;&amp;
            ((jl_struct_type_t*)(t))-&gt;name == jl_box_typename);
}
</t>
<t tx="ekr.20120404123906.7275">
static inline int jl_is_cpointer_type(void *t)
{
    return (jl_is_bits_type(t) &amp;&amp;
            ((jl_bits_type_t*)(t))-&gt;name == jl_pointer_type-&gt;name);
}
</t>
<t tx="ekr.20120404123906.7276">
static inline int jl_is_seq_type(jl_value_t *v)
{
    return (jl_is_tag_type(v) &amp;&amp;
            ((jl_tag_type_t*)(v))-&gt;name == jl_seq_type-&gt;name);
}
</t>
<t tx="ekr.20120404123906.7277">
static inline int jl_is_ntuple_type(jl_value_t *v)
{
    return (jl_is_tag_type(v) &amp;&amp;
            ((jl_tag_type_t*)v)-&gt;name == jl_ntuple_typename);
}
</t>
<t tx="ekr.20120404123906.7278">
static inline int jl_is_nontuple_type(jl_value_t *v)
{
    return (jl_typeis(v, jl_union_kind) ||
            jl_typeis(v, jl_struct_kind) ||
            jl_typeis(v, jl_tag_kind) ||
            jl_typeis(v, jl_bits_kind) ||
            jl_typeis(v, jl_typector_type));
}
</t>
<t tx="ekr.20120404123906.7279">
static inline int jl_is_type_type(jl_value_t *v)
{
    return (jl_is_tag_type(v) &amp;&amp;
            ((jl_tag_type_t*)(v))-&gt;name == jl_type_type-&gt;name);
}
</t>
<t tx="ekr.20120404123906.7280">
// type info accessors
jl_value_t *jl_full_type(jl_value_t *v);
size_t jl_field_offset(jl_struct_type_t *t, jl_sym_t *fld);

// type predicates
int jl_is_type(jl_value_t *v);
DLLEXPORT int jl_is_leaf_type(jl_value_t *v);
int jl_has_typevars(jl_value_t *v);
int jl_tuple_subtype(jl_value_t **child, size_t cl,
                     jl_value_t **parent, size_t pl, int ta, int morespecific);
int jl_subtype(jl_value_t *a, jl_value_t *b, int ta);
int jl_type_morespecific(jl_value_t *a, jl_value_t *b, int ta);
int jl_subtype_invariant(jl_value_t *a, jl_value_t *b, int ta);
DLLEXPORT jl_value_t *jl_type_match(jl_value_t *a, jl_value_t *b);
jl_value_t *jl_type_match_morespecific(jl_value_t *a, jl_value_t *b);
DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);
int jl_types_equal_generic(jl_value_t *a, jl_value_t *b);
jl_value_t *jl_type_union(jl_tuple_t *types);
jl_value_t *jl_type_intersection_matching(jl_value_t *a, jl_value_t *b,
                                          jl_tuple_t **penv, jl_tuple_t *tvars);
DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);
int jl_args_morespecific(jl_value_t *a, jl_value_t *b);

// type constructors
jl_typename_t *jl_new_typename(jl_sym_t *name);
jl_tvar_t *jl_new_typevar(jl_sym_t *name,jl_value_t *lb,jl_value_t *ub);
jl_typector_t *jl_new_type_ctor(jl_tuple_t *params, jl_type_t *body);
jl_value_t *jl_apply_type(jl_value_t *tc, jl_tuple_t *params);
jl_value_t *jl_apply_type_(jl_value_t *tc, jl_value_t **params, size_t n);
jl_type_t *jl_instantiate_type_with(jl_type_t *t, jl_value_t **env, size_t n);
jl_uniontype_t *jl_new_uniontype(jl_tuple_t *types);
jl_tag_type_t *jl_new_tagtype(jl_value_t *name, jl_tag_type_t *super,
                              jl_tuple_t *parameters);
jl_struct_type_t *jl_new_struct_type(jl_sym_t *name, jl_tag_type_t *super,
                                     jl_tuple_t *parameters,
                                     jl_tuple_t *fnames, jl_tuple_t *ftypes);
jl_bits_type_t *jl_new_bitstype(jl_value_t *name, jl_tag_type_t *super,
                                jl_tuple_t *parameters, size_t nbits);
jl_tag_type_t *jl_wrap_Type(jl_value_t *t);  // x -&gt; Type{x}

// constructors
DLLEXPORT jl_value_t *jl_new_struct(jl_struct_type_t *type, ...);
DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_struct_type_t *type);
DLLEXPORT jl_value_t *jl_new_structt(jl_struct_type_t *type, jl_tuple_t *t);
jl_function_t *jl_new_closure(jl_fptr_t proc, jl_value_t *env,
                              jl_lambda_info_t *li);
jl_lambda_info_t *jl_new_lambda_info(jl_value_t *ast, jl_tuple_t *sparams);
jl_tuple_t *jl_tuple(size_t n, ...);
jl_tuple_t *jl_tuple1(void *a);
jl_tuple_t *jl_tuple2(void *a, void *b);
jl_tuple_t *jl_alloc_tuple(size_t n);
jl_tuple_t *jl_alloc_tuple_uninit(size_t n);
jl_tuple_t *jl_tuple_append(jl_tuple_t *a, jl_tuple_t *b);
jl_tuple_t *jl_tuple_fill(size_t n, jl_value_t *v);
DLLEXPORT jl_sym_t *jl_symbol(const char *str);
DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, int32_t len);
DLLEXPORT jl_sym_t *jl_gensym(void);
jl_sym_t *jl_get_root_symbol(void);
jl_expr_t *jl_exprn(jl_sym_t *head, size_t n);
jl_function_t *jl_new_generic_function(jl_sym_t *name);
void jl_initialize_generic_function(jl_function_t *f, jl_sym_t *name);
void jl_add_method(jl_function_t *gf, jl_tuple_t *types, jl_function_t *meth,
                   jl_tuple_t *tvars);
jl_value_t *jl_method_def(jl_sym_t *name, jl_value_t **bp, jl_binding_t *bnd,
                          jl_tuple_t *argtypes, jl_function_t *f,
                          jl_tuple_t *tvars);
jl_value_t *jl_box_bool(int8_t x);
jl_value_t *jl_box_int8(int32_t x);
jl_value_t *jl_box_uint8(uint32_t x);
jl_value_t *jl_box_int16(int16_t x);
jl_value_t *jl_box_uint16(uint16_t x);
DLLEXPORT jl_value_t *jl_box_int32(int32_t x);
jl_value_t *jl_box_uint32(uint32_t x);
jl_value_t *jl_box_char(uint32_t x);
jl_value_t *jl_box_int64(int64_t x);
jl_value_t *jl_box_uint64(uint64_t x);
jl_value_t *jl_box_float32(float x);
jl_value_t *jl_box_float64(double x);
jl_value_t *jl_box8 (jl_bits_type_t *t, int8_t  x);
jl_value_t *jl_box16(jl_bits_type_t *t, int16_t x);
jl_value_t *jl_box32(jl_bits_type_t *t, int32_t x);
jl_value_t *jl_box64(jl_bits_type_t *t, int64_t x);
int8_t jl_unbox_bool(jl_value_t *v);
int8_t jl_unbox_int8(jl_value_t *v);
uint8_t jl_unbox_uint8(jl_value_t *v);
int16_t jl_unbox_int16(jl_value_t *v);
uint16_t jl_unbox_uint16(jl_value_t *v);
int32_t jl_unbox_int32(jl_value_t *v);
uint32_t jl_unbox_uint32(jl_value_t *v);
int64_t jl_unbox_int64(jl_value_t *v);
uint64_t jl_unbox_uint64(jl_value_t *v);
float jl_unbox_float32(jl_value_t *v);
double jl_unbox_float64(jl_value_t *v);

#ifdef __LP64__
#define jl_box_long(x)   jl_box_int64(x)
#define jl_unbox_long(x) jl_unbox_int64(x)
#define jl_is_long(x)    jl_is_int64(x)
#define jl_long_type     jl_int64_type
#else
#define jl_box_long(x)   jl_box_int32(x)
#define jl_unbox_long(x) jl_unbox_int32(x)
#define jl_is_long(x)    jl_is_int32(x)
#define jl_long_type     jl_int32_type
#endif

// arrays
DLLEXPORT jl_array_t *jl_new_array(jl_type_t *atype, jl_tuple_t *dims);
DLLEXPORT jl_array_t *jl_new_arrayv(jl_type_t *atype, ...);
jl_array_t *jl_new_array_(jl_type_t *atype, uint32_t ndims, size_t *dims);
DLLEXPORT jl_array_t *jl_reshape_array(jl_type_t *atype, jl_array_t *data,
                                       jl_tuple_t *dims);
DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_type_t *atype, size_t nr);
DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_type_t *atype, size_t nr, size_t nc);
DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_type_t *atype, size_t nr, size_t nc,
                                        size_t z);
DLLEXPORT jl_array_t *jl_pchar_to_array(char *str, size_t len);
DLLEXPORT jl_value_t *jl_pchar_to_string(char *str, size_t len);
DLLEXPORT jl_value_t *jl_cstr_to_string(char *str);
DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);
DLLEXPORT jl_array_t *jl_alloc_cell_1d(size_t n);
DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed
DLLEXPORT void jl_arrayset(jl_array_t *a, size_t i, jl_value_t *v);  // 0-indexed
DLLEXPORT void *jl_array_ptr(jl_array_t *a);
DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);
DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);
DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);
DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);
void jl_cell_1d_push(jl_array_t *a, jl_value_t *item);

// system information
DLLEXPORT int jl_errno(void);
DLLEXPORT jl_value_t *jl_strerror(int errnum);

// environment entries
DLLEXPORT jl_value_t *jl_environ(int i);

// child process status
DLLEXPORT int jl_process_exited(int status);
DLLEXPORT int jl_process_signaled(int status);
DLLEXPORT int jl_process_stopped(int status);

DLLEXPORT int jl_process_exit_status(int status);
DLLEXPORT int jl_process_term_signal(int status);
DLLEXPORT int jl_process_stop_signal(int status);

// access to std filehandles
DLLEXPORT int jl_stdin(void);
DLLEXPORT int jl_stdout(void);
DLLEXPORT int jl_stderr(void);

// exceptions
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
void jl_too_few_args(const char *fname, int min);
void jl_too_many_args(const char *fname, int max);
void jl_type_error(const char *fname, jl_value_t *expected, jl_value_t *got);
void jl_type_error_rt(const char *fname, const char *context,
                      jl_value_t *ty, jl_value_t *got);
jl_value_t *jl_no_method_error(jl_function_t *f, jl_value_t **args, size_t na);
void jl_undef_ref_error(void);
void jl_divide_by_zero_error(void);

// initialization functions
DLLEXPORT void julia_init(char *imageFile);
DLLEXPORT
</t>
<t tx="ekr.20120404123906.7281">int julia_trampoline(int argc, char *argv[], int (*pmain)(int ac,char *av[]));
void jl_init_types(void);
void jl_init_box_caches(void);
void jl_init_frontend(void);
void jl_init_primitives(void);
void jl_init_codegen(void);
void jl_init_intrinsic_functions(void);
void jl_init_tasks(void *stack, size_t ssize);
void jl_init_serializer(void);

void jl_save_system_image(char *fname, char *startscriptname);
void jl_restore_system_image(char *fname);

// front end interface
DLLEXPORT jl_value_t *jl_parse_input_line(const char *str);
jl_value_t *jl_parse_file(const char *fname);
DLLEXPORT void jl_load_file_string(const char *text);
jl_value_t *jl_expand(jl_value_t *expr);
jl_lambda_info_t *jl_wrap_expr(jl_value_t *expr);

// some useful functions
DLLEXPORT void jl_show(jl_value_t *v);
void jl_show_tuple(jl_tuple_t *t, char opn, char cls, int comma_one);

// modules
extern jl_module_t *jl_core_module;
extern DLLEXPORT jl_module_t *jl_base_module;
extern jl_module_t *jl_current_module;
jl_module_t *jl_new_module(jl_sym_t *name);
// get binding for reading
jl_binding_t *jl_get_binding(jl_module_t *m, jl_sym_t *var);
// get binding for assignment
jl_binding_t *jl_get_binding_wr(jl_module_t *m, jl_sym_t *var);
DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);
DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);
DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m, jl_sym_t *var);
DLLEXPORT void jl_set_global(jl_module_t *m, jl_sym_t *var, jl_value_t *val);
DLLEXPORT void jl_set_const(jl_module_t *m, jl_sym_t *var, jl_value_t *val);
void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs);
void jl_declare_constant(jl_binding_t *b);
jl_module_t *jl_add_module(jl_module_t *m, jl_module_t *child);
jl_module_t *jl_get_module(jl_module_t *m, jl_sym_t *name);
jl_module_t *jl_import_module(jl_module_t *to, jl_module_t *from);
jl_function_t *jl_get_expander(jl_module_t *m, jl_sym_t *macroname);
void jl_set_expander(jl_module_t *m, jl_sym_t *macroname, jl_function_t *f);

// external libraries
DLLEXPORT void *jl_load_dynamic_library(char *fname);
DLLEXPORT void *jl_dlsym(void *handle, char *symbol);

// compiler
void jl_compile(jl_function_t *f);
void jl_generate_fptr(jl_function_t *f);
void jl_delete_function(jl_lambda_info_t *li);
DLLEXPORT jl_value_t *jl_toplevel_eval(jl_value_t *v);
jl_value_t *jl_eval_global_var(jl_module_t *m, jl_sym_t *e);
char *jl_find_file_in_path(const char *fname);
DLLEXPORT void jl_load(const char *fname);
void jl_load_file_expr(char *fname, jl_value_t *ast);
jl_value_t *jl_interpret_toplevel_thunk(jl_lambda_info_t *lam);
jl_value_t *jl_interpret_toplevel_expr(jl_value_t *e);
jl_value_t *jl_interpret_toplevel_expr_with(jl_value_t *e,
                                            jl_value_t **locals, size_t nl);
jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,
                                          jl_value_t **locals, size_t nl);
void jl_type_infer(jl_lambda_info_t *li, jl_tuple_t *argtypes,
                   jl_lambda_info_t *def);

DLLEXPORT void jl_show_method_table(jl_function_t *gf);
jl_lambda_info_t *jl_add_static_parameters(jl_lambda_info_t *l, jl_tuple_t *sp);
jl_function_t *jl_method_lookup_by_type(jl_methtable_t *mt, jl_tuple_t *types,
                                        int cache);
jl_function_t *jl_method_lookup(jl_methtable_t *mt, jl_value_t **args, size_t nargs, int cache);
jl_value_t *jl_gf_invoke(jl_function_t *gf, jl_tuple_t *types,
                         jl_value_t **args, size_t nargs);

// AST access
jl_array_t *jl_lam_args(jl_expr_t *l);
jl_array_t *jl_lam_locals(jl_expr_t *l);
jl_array_t *jl_lam_vinfo(jl_expr_t *l);
jl_array_t *jl_lam_capt(jl_expr_t *l);
jl_expr_t *jl_lam_body(jl_expr_t *l);
jl_sym_t *jl_decl_var(jl_value_t *ex);
DLLEXPORT int jl_is_rest_arg(jl_value_t *ex);

jl_value_t *jl_prepare_ast(jl_lambda_info_t *li, jl_tuple_t *sparams);

jl_value_t *jl_compress_ast(jl_lambda_info_t *li, jl_value_t *ast);
jl_value_t *jl_uncompress_ast(jl_tuple_t *data);

static inline int jl_vinfo_capt(jl_array_t *vi)
{
    return (jl_unbox_long(jl_cellref(vi,2))&amp;1)!=0;
}
</t>
<t tx="ekr.20120404123906.7282">
static inline int jl_vinfo_assigned(jl_array_t *vi)
{
    return (jl_unbox_long(jl_cellref(vi,2))&amp;2)!=0;
}
</t>
<t tx="ekr.20120404123906.7283">
static inline int jl_vinfo_assigned_inner(jl_array_t *vi)
{
    return (jl_unbox_long(jl_cellref(vi,2))&amp;4)!=0;
}
</t>
<t tx="ekr.20120404123906.7284">
// for writing julia functions in C
#define JL_CALLABLE(name) \
    jl_value_t *name(jl_value_t *F, jl_value_t **args, uint32_t nargs)

</t>
<t tx="ekr.20120404123906.7285">static inline
jl_value_t *jl_apply(jl_function_t *f, jl_value_t **args, uint32_t nargs)
{
    return f-&gt;fptr((jl_value_t*)f, args, nargs);
}
</t>
<t tx="ekr.20120404123906.7286">
#define JL_NARGS(fname, min, max)                               \
    if (nargs &lt; min) jl_too_few_args(#fname, min);              \
    else if (nargs &gt; max) jl_too_many_args(#fname, max);

#define JL_NARGSV(fname, min)                           \
    if (nargs &lt; min) jl_too_few_args(#fname, min);

#define JL_TYPECHK(fname, type, v)                                      \
    if (!jl_is_##type(v)) {                                             \
        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v));      \
    }

// gc

#ifdef JL_GC_MARKSWEEP
typedef struct _jl_gcframe_t {
    jl_value_t ***roots;
    size_t nroots;
    int indirect;
    struct _jl_gcframe_t *prev;
} jl_gcframe_t;

// NOTE: it is the caller's responsibility to make sure arguments are
// rooted. foo(f(), g()) will not work, and foo can't do anything about it,
// so the caller must do
// jl_value_t *x, *y; JL_GC_PUSH(&amp;x, &amp;y);
// x = f(); y = g(); foo(x, y)

extern DLLEXPORT jl_gcframe_t *jl_pgcstack;

#define JL_GC_PUSH(...)                                                 \
  void *__gc_rts[] = {__VA_ARGS__};                                     \
  jl_gcframe_t __gc_stkf_ = { (jl_value_t***)__gc_rts, VA_NARG(__VA_ARGS__), \
                              1, jl_pgcstack };                         \
  jl_pgcstack = &amp;__gc_stkf_;

#define JL_GC_PUSHARGS(rts,n)                           \
  jl_gcframe_t __gc_stkf2_ = { (jl_value_t***)rts, (n),  \
                               0, jl_pgcstack };         \
  jl_pgcstack = &amp;__gc_stkf2_;

#define JL_GC_POP() (jl_pgcstack = jl_pgcstack-&gt;prev)

void jl_gc_init(void);
void jl_gc_markval(jl_value_t *v);
DLLEXPORT void jl_gc_enable(void);
DLLEXPORT void jl_gc_disable(void);
DLLEXPORT int jl_gc_is_enabled(void);
void jl_gc_ephemeral_on(void);
void jl_gc_ephemeral_off(void);
DLLEXPORT void jl_gc_collect(void);
void jl_gc_preserve(jl_value_t *v);
void jl_gc_unpreserve(void);
int jl_gc_n_preserved_values(void);
DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);
jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);
#define jl_gc_setmark(v) (((uptrint_t*)(v))[-1]|=1)
void jl_gc_acquire_buffer(void *b);
void *alloc_2w(void);
void *alloc_3w(void);
void *alloc_4w(void);

#else

#define JL_GC_PUSH(...) ;
#define JL_GC_PUSHARGS(rts,n) ;
#define JL_GC_POP()

#define jl_gc_preserve(v) ((void)(v))
#define jl_gc_unpreserve()
#define jl_gc_n_preserved_values() (0)

</t>
<t tx="ekr.20120404123906.7287">static inline void *alloc_2w() { return allocobj(2*sizeof(void*)); }
</t>
<t tx="ekr.20120404123906.7288">static inline void *alloc_3w() { return allocobj(3*sizeof(void*)); }
</t>
<t tx="ekr.20120404123906.7289">static inline void *alloc_4w() { return allocobj(4*sizeof(void*)); }
</t>
<t tx="ekr.20120404123906.7290">#endif

// asynch signal handling

#include &lt;signal.h&gt;

DLLEXPORT extern volatile sig_atomic_t jl_signal_pending;
DLLEXPORT extern volatile sig_atomic_t jl_defer_signal;

#define JL_SIGATOMIC_BEGIN() (jl_defer_signal++)
#define JL_SIGATOMIC_END()                                      \
    do {                                                        \
        jl_defer_signal--;                                      \
        if (jl_defer_signal == 0 &amp;&amp; jl_signal_pending != 0)     \
            raise(jl_signal_pending);                           \
    } while(0)

// tasks and exceptions

// context that needs to be restored around a try block
typedef struct _jl_savestate_t {
    // eh_task is who I yield to for exception handling
    struct _jl_task_t *eh_task;
    // eh_ctx is where I go to handle an exception yielded to me
    jmp_buf *eh_ctx;
    ptrint_t err : 1;
    ptrint_t bt : 1;  // whether exceptions caught here build a backtrace
    jl_value_t *ostream_obj;
    ios_t *current_output_stream;
#ifdef JL_GC_MARKSWEEP
    jl_gcframe_t *gcstack;
#endif
    struct _jl_savestate_t *prev;
} jl_savestate_t;

typedef struct _jl_task_t {
    JL_STRUCT_TYPE
    struct _jl_task_t *on_exit;
    jl_value_t *tls;
    jl_value_t *done;
    jmp_buf ctx;
    union {
        void *stackbase;
        void *stack;
    };
    jmp_buf base_ctx;
    size_t bufsz;
    void *stkbuf;
    size_t ssize;
    jl_function_t *start;
    jl_value_t *result;
    // exception state and per-task dynamic parameters
    jl_savestate_t state;
} jl_task_t;

extern DLLEXPORT jl_task_t * volatile jl_current_task;
extern DLLEXPORT jl_task_t *jl_root_task;
extern DLLEXPORT jl_value_t *jl_exception_in_transit;

jl_task_t *jl_new_task(jl_function_t *start, size_t ssize);
jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg);
DLLEXPORT void jl_raise(jl_value_t *e);
DLLEXPORT void jl_register_toplevel_eh(void);

DLLEXPORT jl_value_t *jl_current_output_stream_obj(void);
DLLEXPORT ios_t *jl_current_output_stream(void);
DLLEXPORT void jl_set_current_output_stream_obj(jl_value_t *v);

DLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s);
DLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s);
DLLEXPORT jl_array_t *jl_readuntil(ios_t *s, uint8_t delim);

</t>
<t tx="ekr.20120404123906.7291">static inline void jl_eh_restore_state(jl_savestate_t *ss)
{
    JL_SIGATOMIC_BEGIN();
    jl_current_task-&gt;state.eh_task = ss-&gt;eh_task;
    jl_current_task-&gt;state.eh_ctx = ss-&gt;eh_ctx;
    jl_current_task-&gt;state.bt = ss-&gt;bt;
    jl_current_task-&gt;state.ostream_obj = ss-&gt;ostream_obj;
    jl_current_task-&gt;state.current_output_stream = ss-&gt;current_output_stream;
    jl_current_task-&gt;state.prev = ss-&gt;prev;
#ifdef JL_GC_MARKSWEEP
    jl_pgcstack = ss-&gt;gcstack;
#endif
    JL_SIGATOMIC_END();
}
</t>
<t tx="ekr.20120404123906.7292"></t>
<t tx="ekr.20120404123906.7293">@language unknown_language
# commented-out definitions are implemented in C

#abstract Any &lt;: Any
#abstract Type{T}

#abstract ...{T}
#Tuple = (Any...)

#type Symbol
#    #opaque
#end

#type TypeName
#    name::Symbol
#end

#type AbstractKind &lt;: Type
#    name::TypeName
#    super::Type
#    parameters::Tuple
#end

#type CompositeKind &lt;: AbstractKind
#    #name::TypeName
#    #super::Type
#    #parameters::Tuple
#    names::Tuple
#    types::Tuple
#end

#type BitsKind &lt;: AbstractKind
#    #name::TypeName
#    #super::Type
#    #parameters::Tuple
#end

#type FuncKind &lt;: Type
#    from::Type
#    to::Type
#end

#type UnionKind &lt;: Type
#    types::Tuple
#end

#None = Union()

#type TypeVar
#    name::Symbol
#    lb::Type
#    ub::Type
#end

#type TypeConstructor
#    parameters::Tuple
#    body
#end

#abstract AbstractArray{T,N}

#type Array{T,N} &lt;: AbstractArray{T,N}
#end

#type Module
#    name::Symbol
#end

#type LambdaStaticData
#    ast::Expr
#    sparams::Tuple
#    tfunc
#    name::Symbol
#    specializations
#    inferred
#    file::Symbol
#    line::Int
#    module::Module
#end

#type Box{T}
#    contents::T
#end

#bitstype {32|64} Ptr{T}

# types for the front end

#type Expr
#    head::Symbol
#    args::Array{Any,1}
#    typ::Any
#end

#type LineNumberNode
#    line::Int
#end

#type LabelNode
#    label::Int
#end

#type GotoNode
#    label::Int
#end

#type QuoteNode
#    value
#end

#type TopNode
#    name::Symbol
#end

# type Task
#     parent::Task
#     tls::Any
#     done::Bool
# end

type Nothing; end
const nothing = Nothing()

abstract Number
abstract Real     &lt;: Number
abstract Float    &lt;: Real
abstract Integer  &lt;: Real
abstract Signed   &lt;: Integer
abstract Unsigned &lt;: Integer

bitstype 32 Float32 &lt;: Float
bitstype 64 Float64 &lt;: Float

bitstype 8  Bool &lt;: Integer
bitstype 32 Char &lt;: Integer

bitstype 8  Int8   &lt;: Signed
bitstype 8  Uint8  &lt;: Unsigned
bitstype 16 Int16  &lt;: Signed
bitstype 16 Uint16 &lt;: Unsigned
bitstype 32 Int32  &lt;: Signed
bitstype 32 Uint32 &lt;: Unsigned
bitstype 64 Int64  &lt;: Signed
bitstype 64 Uint64 &lt;: Unsigned

if is(Int,Int64)
    typealias Uint Uint64
    const unboxwd = unbox64
    const boxsint = boxsi64
    const boxuint = boxui64
else
    typealias Uint Uint32
    const unboxwd = unbox32
    const boxsint = boxsi32
    const boxuint = boxui32
end

abstract Exception

type BoundsError        &lt;: Exception end
type DivideByZeroError  &lt;: Exception end
type MemoryError        &lt;: Exception end
type IOError            &lt;: Exception end
type StackOverflowError &lt;: Exception end
type EOFError           &lt;: Exception end
type UndefRefError      &lt;: Exception end
type InterruptException &lt;: Exception end

abstract String
abstract DirectIndexString &lt;: String

abstract Associative

# simple convert for use by constructors of types in Core
convert(T, x) = convert_default(T, x, convert)

type SymbolNode
    name::Symbol
    typ
    SymbolNode(name::Symbol, t::ANY) = new(name, t)
end

type WeakRef
    value
    WeakRef() = WeakRef(nothing)
    WeakRef(v::ANY) = ccall(:jl_gc_new_weakref, WeakRef, (Any,), v)
end

type ASCIIString &lt;: DirectIndexString
    data::Array{Uint8,1}
end

type UTF8String &lt;: String
    data::Array{Uint8,1}
end

typealias ByteString Union(ASCIIString,UTF8String)

include(fname::ByteString) = ccall(:jl_load_, Void, (Any,), fname)
</t>
<t tx="ekr.20120404123906.7294">@language lisp
</t>
<t tx="ekr.20120404123906.7295">(define (read-u8) (io.read *input-stream* 'uint8))
(define modulo mod)
(define display princ)
(let loop ((b (read-u8))
	   (i 0))
  (if (not (eof-object? b))
      (begin
	(if (&gt; i 0)
	    (display ", "))
	(display "0x") (display (number-&gt;string b 16))
	(if (= 0 (modulo (+ 1 i) 16))
	    (newline))
	(loop (read-u8) (+ 1 i)))))
(newline)
</t>
<t tx="ekr.20120404123906.7296">(load "./flisp/aliases.scm")
(load "utils.scm")
(load "match.scm")
(load "julia-parser.scm")
(load "julia-syntax.scm")

;; exception handler for parser. turns known errors into special expressions,
;; and prevents throwing an exception past a C caller.
(define (parser-wrap thk)
  (with-exception-catcher
   (lambda (e)
     (if (and (pair? e) (eq? (car e) 'error))
	 (let ((msg (cadr e))
	       (pfx "incomplete:"))
	   (if (and (&gt;= (string-length msg) (string-length pfx))
		    (equal? pfx
			    (substring msg 0 (string-length pfx))))
	       `(continue ,msg)
	       `(error ,msg)))
	 (begin
	   (newline)
	   (display "unexpected error: ")
	   (prn e)
	   (print-stack-trace (stacktrace))
	   #f)))
   thk))

;; assigned variables except those marked local or inside inner functions
(define (find-possible-globals e)
  (cond ((atom? e)   '())
	((quoted? e) '())
	(else (case (car e)
		((=)            (list (decl-var (cadr e))))
		((lambda)       '())
		((local local!) '())
		((break-block)  (find-possible-globals (caddr e)))
		(else
		 (delete-duplicates
		  (apply append!
			 (map find-possible-globals (cdr e)))))))))

;; this is overwritten when we run in actual julia
(define (defined-julia-global v) #f)

;; find variables that should be forced to be global in a toplevel expr
(define (toplevel-expr-globals e)
  (delete-duplicates
   (append
    ;; vars assigned at the outer level
    (filter (lambda (x) (not (gensym? x))) (find-assigned-vars e '()))
    ;; vars assigned anywhere, if they have been defined as global
    (filter defined-julia-global (find-possible-globals e)))))

;; return a lambda expression representing a thunk for a top-level expression
(define (expand-toplevel-expr- e)
  (if (or (boolean? e) (eof-object? e) (and (pair? e) (eq? (car e) 'line)))
      e
      (let* ((ex (julia-expand0 e))
	     (gv (toplevel-expr-globals ex))
	     (th (julia-expand1
		  `(lambda ()
		     (scope-block
		      (block ,@(map (lambda (v) `(global ,v)) gv)
			     ,ex))))))
	(if (null? (car (caddr th)))
	    ;; if no locals, return just body of function
	    (cadddr th)
	    `(thunk ,th)))))

;; (body (= v _) (return v)) =&gt; (= v _)
(define (simple-assignment? e)
  (and (length= e 3) (eq? (car e) 'body)
       (pair? (cadr e)) (eq? (caadr e) '=) (symbol? (cadadr e))
       (eq? (cadr (caddr e)) (cadadr e))))

(define (lambda-ex? e)
  (and (pair? e) (eq? (car e) 'lambda)))

(define (expand-toplevel-expr e)
  (let ((ex (expand-toplevel-expr- e)))
    (cond ((simple-assignment? ex)  (cadr ex))
	  ((and (length= ex 2) (eq? (car ex) 'body)
		(not (lambda-ex? (cadadr ex))))
	   ;; (body (return x)) =&gt; x
	   ;; if x is not a lambda expr, so we don't think it is a thunk
	   ;; to be called immediately.
	   (cadadr ex))
	  (else ex))))

(define (has-macrocalls? e)
  (or (and (pair? e) (eq? (car e) 'macrocall))
      (and (not (and (pair? e) (eq? (car e) 'quote)))
	   (any has-macrocalls? e))))

;; expand expression right after parsing if it's OK to do so
(define (pre-expand-toplevel-expr e)
  (if (or (and (pair? e) (eq? (car e) 'module))
	  (has-macrocalls? e))
      e
      (parser-wrap (lambda ()
		     (expand-toplevel-expr e)))))

(define (jl-parse-one-string s pos0 greedy)
  (set! current-filename 'string)
  (let ((inp (open-input-string s)))
    (io.seek inp pos0)
    (let ((expr
	   (parser-wrap (lambda ()
			  (if greedy
			      (julia-parse inp)
			      (julia-parse inp parse-atom))))))
      (cons expr (io.pos inp)))))

(define (jl-parse-string s)
  (set! current-filename 'prompt)
  (parser-wrap (lambda ()
		 (let* ((inp  (make-token-stream (open-input-string s)))
			(expr (julia-parse inp)))
		   (if (not (eof-object? (julia-parse inp)))
		       (error "extra input after end of expression")
		       (pre-expand-toplevel-expr expr))))))

(define (jl-parse-named-stream name stream)
  (parser-wrap (lambda ()
		 (cons 'file (map pre-expand-toplevel-expr
				  (julia-parse-stream name stream))))))

;; parse file-in-a-string
(define (jl-parse-string-stream str)
  (jl-parse-named-stream "string" (open-input-string str)))

(define (jl-parse-file s)
  (let ((infile (open-input-file s)))
    (begin0
     (jl-parse-named-stream s infile)
     (io.close infile))))

; expand a piece of raw surface syntax to an executable thunk
(define (jl-expand-to-thunk expr)
  (parser-wrap (lambda ()
		 (expand-toplevel-expr expr))))

; run whole frontend on a string. useful for testing.
(define (fe str)
  (expand-toplevel-expr (julia-parse str)))
</t>
<t tx="ekr.20120404123906.7297">@killcolor

(define (quoted? e) (memq (car e) '(quote top line break)))

(define (lam:args x) (cadr x))
(define (lam:vars x) (llist-vars (lam:args x)))
(define (lam:vinfo x) (caddr x))
(define (lam:body x) (cadddr x))

; convert x =&gt; (x), (tuple x y) =&gt; (x y)
; used to normalize function signatures like "x-&gt;y" and "function +(a,b)"
(define (fsig-to-lambda-list arglist)
  (if (pair? arglist)
      (if (eq? (car arglist) 'tuple)
	  (cdr arglist)
	  arglist)
      (if (symbol? arglist)
	  (list arglist)
	  arglist)))

(define (arg-name v)
  (cond ((and (symbol? v) (not (eq? v 'true)) (not (eq? v 'false)))
	 v)
	((not (pair? v))
	 (error (string "malformed function arguments " v)))
	(else
	 (case (car v)
	   ((...)         (decl-var (cadr v)))
	   ((= keyword)   (decl-var (caddr v)))
	   ((|::|)        (decl-var v))
	   (else (error (string "malformed function argument " v)))))))

; convert a lambda list into a list of just symbols
(define (llist-vars lst)
  (map arg-name lst))

(define (arg-type v)
  (cond ((symbol? v)  'Any)
	((not (pair? v))
	 (error (string "malformed function arguments " v)))
	(else
	 (case (car v)
	   ((...)         `(... ,(decl-type (cadr v))))
	   ((= keyword)   (decl-type (caddr v)))
	   ((|::|)        (decl-type v))
	   (else (error
		  (string "malformed function arguments " v)))))))

; get just argument types
(define (llist-types lst)
  (map arg-type lst))

(define (decl? e)
  (and (pair? e) (eq? (car e) '|::|)))

; get the variable name part of a declaration, x::int =&gt; x
(define (decl-var v)
  (if (decl? v) (cadr v) v))

(define (decl-type v)
  (if (decl? v) (caddr v) 'Any))

(define (sym-dot? e)
  (and (length= e 3) (eq? (car e) '|.|)
       (symbol? (cadr e))))

; make an expression safe for multiple evaluation
; for example a[f(x)] =&gt; (temp=f(x); a[temp])
; retuns a pair (expr . assignments)
; where 'assignments' is a list of needed assignment statements
(define (remove-argument-side-effects e)
  (let ((a '()))
    (if (not (pair? e))
	(cons e '())
	(cons (map (lambda (x)
		     (if (and (pair? x) (not (quoted? x))
			      (not (sym-dot? x)))
			 (let ((g (gensy)))
			   (if (or (eq? (car x) '...) (eq? (car x) '&amp;))
			       (if (and (pair? (cadr x))
					(not (quoted? (cadr x))))
				   (begin (set! a (cons `(= ,g ,(cadr x)) a))
					  `(,(car x) ,g))
				   x)
			       (begin (set! a (cons `(= ,g ,x) a))
				      g)))
			 x))
		   e)
	      (reverse a)))))

(define (expand-update-operator op lhs rhs)
  (let ((e (remove-argument-side-effects lhs)))
    `(block ,@(cdr e)
	    (= ,(car e) (call ,op ,(car e) ,rhs)))))

; (a &gt; b &gt; c) =&gt; (call &amp; (call &gt; a b) (call &gt; b c))
(define (expand-compare-chain e)
  (if (length&gt; e 3)
      (let ((arg2 (caddr e)))
	(if (pair? arg2)
	    (let ((g (gensy)))
	      `(call &amp; (call ,(cadr e) ,(car e) (= ,g ,arg2))
		     ,(expand-compare-chain (cons g (cdddr e)))))
	    `(call &amp; (call ,(cadr e) ,(car e) ,arg2)
		   ,(expand-compare-chain (cddr e)))))
      `(call ,(cadr e) ,(car e) ,(caddr e))))

(define (end-val a n tuples s)
  (if s
      `(call (top numel) ,a)
      (if (null? tuples)
	  `(call (top size) ,a ,n)
	  `(call (top size) ,a (call (top +) ,(- n (length tuples))
				     ,@(map (lambda (t)
					      `(call (top length) ,t))
					    tuples))))))

; replace end inside ex with (call (top size) a n)
; affects only the closest ref expression, so doesn't go inside nested refs
(define (replace-end ex a n tuples s)
  (cond ((eq? ex 'end)                (end-val a n tuples s))
	((or (atom? ex) (quoted? ex)) ex)
	((eq? (car ex) 'ref)
	 ;; inside ref only replace within the first argument
	 (list* 'ref (replace-end (cadr ex) a n tuples s)
		(cddr ex)))
	(else
	 (cons (car ex)
	       (map (lambda (x) (replace-end x a n tuples s))
		    (cdr ex))))))

; translate index x from colons to ranges
(define (expand-index-colon x)
  (cond ((eq? x ':) `(call (top colon) 1 end))
	((and (pair? x)
	      (eq? (car x) ':))
	 (cond ((length= x 3)
		(if (eq? (caddr x) ':)
		    ;; (: a :) a:
		    `(call (top colon) ,(cadr x) end)
		    ;; (: a b)
		    `(call (top colon) ,(cadr x) ,(caddr x))))
	       ((length= x 4)
		(if (eq? (cadddr x) ':)
		    ;; (: a b :) a:b:
		    `(call (top colon) ,(cadr x) ,(caddr x) end)
		    ;; (: a b c)
		    `(call (top colon) ,@(cdr x))))
	       (else x)))
	(else x)))

(define (process-indexes a i)
  (process-indexes- a i (length= i 1)))

;; : inside indexing means 1:end
;; a:b and a:b:c are ranges instead of calls to colon
;; expand end to size(a,n), or numel(a) if it is the only index
;; a = array being indexed, i = list of indexes
;; s = (length i) equals 1
;; returns (values index-list stmts) where stmts are statements that need
;; to execute first.
(define (process-indexes- a i s)
  (let loop ((lst i)
	     (n   1)
	     (stmts '())
	     (tuples '())
	     (ret '()))
    (if (null? lst)
	(values (reverse ret) (reverse stmts))
	(let ((idx (car lst)))
	  (if (and (pair? idx) (eq? (car idx) '...))
	      (if (symbol? (cadr idx))
		  (loop (cdr lst) (+ n 1)
			stmts
			(cons (cadr idx) tuples)
			(cons `(... ,(replace-end (cadr idx) a n tuples s))
			      ret))
		  (let ((g (gensy)))
		    (loop (cdr lst) (+ n 1)
			  (cons `(= ,g ,(replace-end (cadr idx) a n tuples s))
				stmts)
			  (cons g tuples)
			  (cons `(... ,g) ret))))
	      (loop (cdr lst) (+ n 1)
		    stmts tuples
		    (cons (replace-end (expand-index-colon idx) a n tuples s)
			  ret)))))))

(define (make-decl n t) `(|::| ,n ,t))

(define (function-expr argl body)
  (let ((t (llist-types argl))
	(n (llist-vars argl)))
    (let ((argl (map make-decl n t)))
      `(lambda ,argl
	 (scope-block ,body)))))

;; GF method does not need to keep decl expressions on lambda args
;; except for rest arg
(define (method-lambda-expr argl body)
  (let ((argl (map (lambda (x)
		     (if (and (pair? x) (eq? (car x) '...))
			 (make-decl (arg-name x) (arg-type x))
			 (arg-name x)))
		   argl)))
    `(lambda ,argl
       (scope-block ,body))))

(define (symbols-&gt;typevars sl upperbounds)
  (if (null? upperbounds)
      (map (lambda (x)    `(call (top typevar) ',x)) sl)
      (map (lambda (x ub) `(call (top typevar) ',x ,ub)) sl upperbounds)))

(define (sparam-name-bounds sparams names bounds)
  (cond ((null? sparams)
	 (values (reverse names) (reverse bounds)))
	((symbol? (car sparams))
	 (sparam-name-bounds (cdr sparams) (cons (car sparams) names)
			     (cons '(top Any) bounds)))
	((and (length= (car sparams) 4)
	      (eq? (caar sparams) 'comparison)
	      (eq? (caddar sparams) '|&lt;:|)
	      (symbol? (cadar sparams)))
	 (sparam-name-bounds (cdr sparams) (cons (cadr (car sparams)) names)
			     (cons (cadddr (car sparams)) bounds)))
	(else
	 (error "malformed type parameter list"))))

(define (method-def-expr name sparams argl body)
  (if (not (symbol? name))
      (error (string "invalid method name " name)))
  (let* ((argl  (fsig-to-lambda-list argl))
	 (types (llist-types argl))
	 (body  (method-lambda-expr argl body)))
    (if (null? sparams)
	`(method ,name (tuple ,@types) ,body (tuple))
	(receive
	 (names bounds) (sparam-name-bounds sparams '() '())
	 (let ((f (gensy)))
	   `(call (lambda (,@names ,f)
		    (method ,name (tuple ,@types) ,f (tuple ,@names)))
		  ,@(symbols-&gt;typevars names bounds)
		  ,body))))))

(define (struct-def-expr name params super fields)
  (receive
   (params bounds) (sparam-name-bounds params '() '())
   (struct-def-expr- name params bounds super (flatten-blocks fields))))

(define (default-inner-ctor name field-names field-types)
  `(function (call ,name
		   ,@(map make-decl field-names field-types))
	     (block
	      (call new ,@field-names))))

(define (default-outer-ctor name field-names field-types params bounds)
  `(function (call (curly ,name
			  ,@(map (lambda (p b) `(comparison ,p &lt;: ,b))
				 params bounds))
		   ,@(map make-decl field-names field-types))
	     (block
	      (call (curly ,name ,@params) ,@field-names))))

(define (new-call Texpr args field-names)
  (cond ((&gt; (length args) (length field-names))
	 `(call (top error) "new: too many arguments"))
	((null? args)
	 `(new ,Texpr))
	(else
	 (let ((g (gensy)))
	   `(block (= ,g (new ,Texpr))
		   ,@(map (lambda (fld val) `(= (|.| ,g (quote ,fld)) ,val))
			  (list-head field-names (length args)) args)
		   ,g)))))

(define (rewrite-ctor ctor Tname params field-names)
  (define (ctor-body body)
    `(block ;; make type name global
            (global ,Tname)
	    ,(pattern-replace (pattern-set
			       (pattern-lambda
				(call (-/ new) . args)
				(new-call (if (null? params)
					      Tname
					      `(curly ,Tname ,@params))
					  args
					  field-names)))
			      body)))
  (let ((ctor2
	 (pattern-replace
	  (pattern-set
	   (pattern-lambda (function (call name . sig) body)
			   `(function ,(cadr __) ,(ctor-body body)))
	   (pattern-lambda (= (call name . sig) body)
			   `(= ,(cadr __) ,(ctor-body body)))
	   (pattern-lambda (function (call (curly name . p) . sig) body)
			   `(function ,(cadr __) ,(ctor-body body)))
	   (pattern-lambda (= (call (curly name . p) . sig) body)
			   `(= ,(cadr __) ,(ctor-body body))))
	  ctor)))
    ctor2))

;; remove line numbers and nested blocks
(define (flatten-blocks e)
  (if (atom? e)
      e
      (apply append!
	     (map (lambda (x)
		    (cond ((atom? x) (list x))
			  ((eq? (car x) 'line) '())
			  ((eq? (car x) 'block) (cdr (flatten-blocks x)))
			  (else (list x))))
		  e))))

(define (struct-def-expr- name params bounds super fields)
  (receive
   (fields defs) (separate (lambda (x) (or (symbol? x) (decl? x)))
			   fields)
   (let* ((field-names (map decl-var fields))
	  (field-types (map decl-type fields))
	  (defs2 (if (null? defs)
		     (list (default-inner-ctor name field-names field-types))
		     defs)))
     (if (null? params)
	 `(block
	   (const ,name)
	   (= ,name
	      (scope-block
	       (block
		(local ,name)
		(= ,name
		   (call (top new_struct_type)
			 (quote ,name)
			 (tuple ,@params)
			 (tuple ,@(map (lambda (x) `',x) field-names))
			 (null)))
		(call (top new_struct_fields)
		      ,name ,super (tuple ,@field-types))
		,name)))
	   (scope-block
	    (block
	     ,@(map (lambda (c)
		      (rewrite-ctor c name '() field-names))
		    defs2)))
	   (null))
	 ;; parametric case
	 `(block
	   (const ,name)
	   (= ,name
	   (call
	    (lambda (,@params)
	      (scope-block
	      (block
	       (local ,name)
	       (= ,name
		  (call (top new_struct_type)
			(quote ,name)
			(tuple ,@params)
			(tuple ,@(map (lambda (x) `',x) field-names))
			(lambda (,name)
			  (scope-block
			   ;; don't capture params; in here they are static
			   ;; parameters
			   (block
			    (global ,@params)
			    ,@(map (lambda (c)
				     (rewrite-ctor c name params field-names))
				   defs2)
			    ,name)))))
	       (call (top new_struct_fields)
		     ,name ,super (tuple ,@field-types))
	       ,name)))
	    ,@(symbols-&gt;typevars params bounds)))
	   ,@(if (null? defs)
		 `(,(default-outer-ctor name field-names field-types
		      params bounds))
		 '())
	   (null))))))

(define (abstract-type-def-expr name params super)
  (receive
   (params bounds)
   (sparam-name-bounds params '() '())
   `(block
     (const ,name)
     (= ,name
	(call
	 (lambda ,params
	   (scope-block
	    (block
	     (local ,name)
	     (= ,name
		(call (top new_tag_type)
		      (quote ,name) (tuple ,@params)))
	     (call (top new_tag_type_super) ,name ,super)
	     ,name)))
	 ,@(symbols-&gt;typevars params bounds)))
     (null))))

(define (bits-def-expr n name params super)
  (receive
   (params bounds)
   (sparam-name-bounds params '() '())
   `(block
     (const ,name)
     (= ,name
	(call
	 (lambda ,params
	   (scope-block
	    (block
	     (local ,name)
	     (= ,name
		(call (top new_bits_type)
		      (quote ,name) (tuple ,@params) ,n))
	     (call (top new_tag_type_super) ,name ,super)
	     ,name)))
	 ,@(symbols-&gt;typevars params bounds)))
     (null))))

; take apart a type signature, e.g. T{X} &lt;: S{Y}
(define (analyze-type-sig ex)
  (or ((pattern-lambda (-- name (-s))
		       (values name '() 'Any)) ex)
      ((pattern-lambda (curly (-- name (-s)) . params)
		       (values name params 'Any)) ex)
      ((pattern-lambda (comparison (-- name (-s)) (-/ |&lt;:|) super)
		       (values name '() super)) ex)
      ((pattern-lambda (comparison (curly (-- name (-s)) . params)
				   (-/ |&lt;:|) super)
		       (values name params super)) ex)
      (error "invalid type signature")))

;; insert calls to convert() in ccall, and pull out expressions that might
;; need to be rooted before conversion.
(define (lower-ccall name RT atypes args)
  (define (ccall-conversion T x)
    (cond ((eq? T 'Any)  x)
	  ((and (pair? x) (eq? (car x) '&amp;))
	   `(&amp; (call (top ptr_arg_convert) ,T ,(cadr x))))
	  (else
	   `(call (top convert) ,T ,x))))
  (define (argument-root a)
    ;; something to keep rooted for this argument
    (cond ((and (pair? a) (eq? (car a) '&amp;))
	   (argument-root (cadr a)))
	  ((and (pair? a) (sym-dot? a))
	   (cadr a))
	  ((symbol? a)  a)
	  (else         0)))
  (let loop ((F atypes)  ;; formals
	     (A args)    ;; actuals
	     (stmts '()) ;; initializers
	     (C '()))    ;; converted
    (if (or (null? F) (null? A))
	`(block
	  ,.(reverse! stmts)
	  (call (top ccall) ,name ,RT (tuple ,@atypes) ,.(reverse! C)
		,@A))
	(let* ((a     (car A))
	       (isseq (and (pair? (car F)) (eq? (caar F) '...)))
	       (ty    (if isseq (cadar F) (car F)))
	       (rt (if (eq? ty 'Any)
		       0
		       (argument-root a)))
	       (ca (cond ((eq? ty 'Any)
			  a)
			 ((and (pair? a) (eq? (car a) '&amp;))
			  (if (and (pair? (cadr a)) (not (sym-dot? (cadr a))))
			      (let ((g (gensy)))
				(begin
				  (set! stmts (cons `(= ,g ,(cadr a)) stmts))
				  `(&amp; ,g)))
			      a))
			 ((and (pair? a) (not (sym-dot? a)) (not (quoted? a)))
			  (let ((g (gensy)))
			    (begin
			      (set! stmts (cons `(= ,g ,a) stmts))
			      g)))
			 (else
			  a))))
	  (loop (if isseq F (cdr F)) (cdr A) stmts
		(list* rt (ccall-conversion ty ca) C))))))

; patterns that introduce lambdas
(define binding-form-patterns
  (pattern-set
   ;; function with static parameters
   (pattern-lambda (function (call (curly name . sparams) . argl) body)
		   (method-def-expr name sparams argl body))

   ;; function definition
   (pattern-lambda (function (call name . argl) body)
		   (method-def-expr name '() argl body))

   (pattern-lambda (function (tuple . args) body)
		   `(-&gt; (tuple ,@args) ,body))

   ;; expression form function definition
   (pattern-lambda (= (call (curly name . sparams) . argl) body)
		   `(function (call (curly ,name . ,sparams) . ,argl) ,body))
   (pattern-lambda (= (call name . argl) body)
		   `(function (call ,name ,@argl) ,body))

   ;; anonymous function
   (pattern-lambda (-&gt; a b)
		   (let ((a (if (and (pair? a)
				     (eq? (car a) 'tuple))
				(cdr a)
				(list a))))
		     (function-expr a
				    `(block
				      ,@(map (lambda (d)
					       `(= ,(cadr d)
						   (typeassert ,@(cdr d))))
					     (filter decl? a))
				      ,b))))

   ;; let
   (pattern-lambda (let ex . binds)
		   (let loop ((binds binds)
			      (args  ())
			      (inits ())
			      (locls ())
			      (stmts ()))
		     (if (null? binds)
			 `(call (-&gt; (tuple ,@args)
				    (block ,@(if (null? locls)
						 '()
						 `((local ,@locls)))
					   ,@stmts
					   ,ex))
				,@inits)
			 (cond
			  ((or (symbol? (car binds)) (decl? (car binds)))
			   ;; just symbol -&gt; add local
			   (loop (cdr binds) args inits
				 (cons (car binds) locls)
				 stmts))
			  ((and (length= (car binds) 3)
				(eq? (caar binds) '=))
			   ;; some kind of assignment
			   (cond
			    ((or (symbol? (cadar binds))
				 (decl?   (cadar binds)))
			     ;; a=b -&gt; add argument
			     (loop (cdr binds)
				   (cons (cadar binds) args)
				   (cons (caddar binds) inits)
				   locls stmts))
				   #;(cons (cadar binds) locls)
				   #;(cons `(= ,(decl-var (cadar binds))
					     ,(caddar binds))
					 stmts);))
			    ((and (pair? (cadar binds))
				  (eq? (caadar binds) 'call))
			     ;; f()=c
			     (let ((asgn (cadr (julia-expand0 (car binds)))))
			       (loop (cdr binds) args inits
				     (cons (cadr asgn) locls)
				     (cons asgn stmts))))
			    (else (error "invalid let syntax"))))
			  (else (error "invalid let syntax"))))))

   ;; macro definition
   (pattern-lambda (macro (call name . argl) body)
		   `(call (top def_macro) (quote ,name)
			  (-&gt; (tuple ,@argl) ,body)))

   ;; type definition
   (pattern-lambda (type sig (block . fields))
		   (receive (name params super) (analyze-type-sig sig)
			    (struct-def-expr name params super fields)))

   (pattern-lambda (try tryblk var catchblk)
		   (if (symbol? var)
		       `(trycatch (scope-block ,tryblk)
				  (scope-block
				   (block (= ,var (the_exception))
					  ,catchblk)))
		       `(trycatch (scope-block ,tryblk)
				  (scope-block ,catchblk))))

   )) ; binding-form-patterns

; local x, y=2, z =&gt; local x;local y;local z;y = 2
(define (expand-decls what binds)
  (if (not (list? binds))
      (error (string "invalid " what " declaration")))
  (let loop ((b       binds)
	     (vars    '())
	     (assigns '()))
    (if (null? b)
	(if (and (null? assigns)
		 (length= vars 1))
	    `(,what ,(car vars))
	    `(block
	      ,@(map (lambda (x) `(,what ,x)) vars)
	      ,@(reverse assigns)))
	(let ((x (car b)))
	  (cond ((and (pair? x) (memq (car x) assignment-ops))
		 (loop (cdr b)
		       (cons (cadr x) vars)
		       (cons `(,(car x) ,(decl-var (cadr x)) ,(caddr x))
			     assigns)))
		((and (pair? x) (eq? (car x) '|::|))
		 (loop (cdr b)
		       (cons (decl-var x) vars)
		       (cons x assigns)))
		((symbol? x)
		 (loop (cdr b) (cons x vars) assigns))
		(else
		 (error (string "invalid syntax in " what " declaration"))))))))

(define (make-assignment l r) `(= ,l ,r))
(define (assignment? e) (and (pair? e) (eq? (car e) '=)))

(define (const-check-symbol s)
  (if (not (symbol? s))
      (error "expected identifier after const")
      s))

(define (qualified-const-expr binds __)
  (let ((vs (map (lambda (b)
		   (if (assignment? b)
		       (const-check-symbol (decl-var (cadr b)))
		       (error "expected assignment after const")))
		 binds)))
    `(block ,@(map (lambda (v) `(const ,v)) vs)
	    ,(cadr __))))

;; convert (lhss...) = (tuple ...) to assignments, eliminating the tuple
(define (tuple-to-assignments lhss x)
  (let ((temps (map (lambda (x) (gensy)) (cdr x))))
    `(block
      ,@(map make-assignment temps (cdr x))
      ,@(map make-assignment lhss temps)
      (unnecessary-tuple (tuple ,@temps)))))

;; convert (lhss...) = x to tuple indexing, handling the general case
(define (lower-tuple-assignment lhss x)
  (let ((t (gensy)))
    `(block
      (multiple_value)
      (= ,t ,x)
      ,@(let loop ((lhs lhss)
		   (i   1))
	  (if (null? lhs) '((null))
	      (cons `(= ,(car lhs)
			(call (top tupleref) ,t ,i))
		    (loop (cdr lhs)
			  (+ i 1)))))
      ,t)))

(define patterns
  (pattern-set
   (pattern-lambda (block)
		   `(block (null)))

   (pattern-lambda (|.| a b)
		   `(call (top getfield) ,a ,b))

   (pattern-lambda (= (|.| a b) rhs)
		   (let ((aa (if (atom? a) a (gensy)))
			 (bb (if (or (atom? b) (quoted? b)) b (gensy))))
		     `(block
		       ,@(if (eq? aa a) '() `((= ,aa ,a)))
		       ,@(if (eq? bb b) '() `((= ,bb ,b)))
		       (call (top _setfield) ,aa ,bb
			     (call (top convert)
				   (call (top fieldtype) ,aa ,bb)
				   ,rhs)))))

   (pattern-lambda (abstract sig)
		   (receive (name params super) (analyze-type-sig sig)
			    (abstract-type-def-expr name params super)))

   (pattern-lambda (bitstype n sig)
		   (receive (name params super) (analyze-type-sig sig)
			    (bits-def-expr n name params super)))

   ; typealias is an assignment; should be const when that exists
   (pattern-lambda (typealias (-- name (-s)) type-ex)
		   `(const (= ,name ,type-ex)))
   (pattern-lambda (typealias (curly (-- name (-s)) . params) type-ex)
		   (receive
		    (params bounds)
		    (sparam-name-bounds params '() '())
		    `(call (lambda ,params
			     (const
			      (= ,name (call (top new_type_constructor)
					     (tuple ,@params) ,type-ex))))
			   ,@(symbols-&gt;typevars params bounds))))

   (pattern-lambda (comparison . chain) (expand-compare-chain chain))

   ;; multiple value assignment
   (pattern-lambda (= (tuple . lhss) x)
		   (if (and (pair? x) (pair? lhss) (eq? (car x) 'tuple)
			    (length= lhss (length (cdr x))))
		       ;; (a, b, ...) = (x, y, ...)
		       (tuple-to-assignments lhss x)
		       ;; (a, b, ...) = other
		       (lower-tuple-assignment lhss x)))

   (pattern-lambda (= (ref a . idxs) rhs)
		   (let* ((reuse (and (pair? a)
				      (contains (lambda (x)
						  (or (eq? x 'end)
						      (and (pair? x)
							   (eq? (car x) ':))))
						idxs)))
			  (arr   (if reuse (gensy) a))
			  (stmts (if reuse `((= ,arr ,a)) '())))
		     (let* ((rrhs (and (pair? rhs) (not (quoted? rhs))))
			    (r    (if rrhs (gensy) rhs))
			    (rini (if rrhs `((= ,r ,rhs)) '())))
		       (receive
			(new-idxs stuff) (process-indexes arr idxs)
			`(block
			  ,@stmts
			  ,@stuff
			  ,@rini
			  (call (top assign) ,arr ,r ,@new-idxs)
			  ,r)))))

   (pattern-lambda (ref a . idxs)
		   (let* ((reuse (and (pair? a)
				      (contains (lambda (x)
						  (or (eq? x 'end)
						      (and (pair? x)
							   (eq? (car x) ':))))
						idxs)))
			  (arr   (if reuse (gensy) a))
			  (stmts (if reuse `((= ,arr ,a)) '())))
		     (receive
		      (new-idxs stuff) (process-indexes arr idxs)
		      `(block
			,@(append stmts stuff)
			(call (top ref) ,arr ,@new-idxs)))))

   (pattern-lambda (curly type . elts)
		   `(call (top apply_type) ,type ,@elts))

   ; call with splat
   (pattern-lambda (call f ... (... _) ...)
		   (let ((argl (cddr __)))
		     ; wrap sequences of non-... arguments in tuple()
		     (define (tuple-wrap a run)
		       (if (null? a)
			   (if (null? run) '()
			       (list `(call (top tuple) ,@(reverse run))))
			   (let ((x (car a)))
			     (if (and (length= x 2)
				      (eq? (car x) '...))
				 (if (null? run)
				     (list* (cadr x)
					    (tuple-wrap (cdr a) '()))
				     (list* `(call (top tuple) ,@(reverse run))
					    (cadr x)
					    (tuple-wrap (cdr a) '())))
				 (tuple-wrap (cdr a) (cons x run))))))
		     `(call apply ,f ,@(tuple-wrap argl '()))))

   ; tuple syntax (a, b...)
   ; note, directly inside tuple ... means sequence type
   (pattern-lambda (tuple . args)
		   `(call (top tuple)
			  ,@(map (lambda (x)
				   (if (and (length= x 2)
					    (eq? (car x) '...))
				       `(curly ... ,(cadr x))
				       x))
				 args)))

   (pattern-lambda (... a) `(curly ... ,a))

   ;; cell array syntax
   (pattern-lambda (cell1d . args)
		   (cond ((any (lambda (e) (and (length= e 3)
						(eq? (car e) '=&gt;)))
			       args)
			  (if (not (every (lambda (e) (and (length= e 3)
							   (eq? (car e) '=&gt;)))
					  args))
			      (error "invalid hash table literal")
			      `(call (top hashtable)
				     (tuple ,@(map cadr  args))
				     (tuple ,@(map caddr args)))))
			 ((any (lambda (e) (and (pair? e) (eq? (car e) '...)))
			       args)
			  `(call (top cell_1d) ,@args))
			 (else
			  (let ((name (gensy)))
			    `(block (= ,name (call (top Array) (top Any)
						   ,(length args)))
				    ,@(map (lambda (i elt)
					     `(call (top arrayset) ,name
						    ,(+ 1 i)
						    ,elt))
					   (iota (length args))
					   args)
				    ,name)))))

   (pattern-lambda (cell2d nr nc . args)
		   (if (any (lambda (e) (and (pair? e) (eq? (car e) '...)))
			    args)
		       `(call (top cell_2d) ,nr ,nc ,@args)
		       (let ((name (gensy)))
			 `(block (= ,name (call (top Array) (top Any)
						,nr ,nc))
				 ,@(map (lambda (i elt)
					  `(call (top arrayset) ,name ,(+ 1 i)
						 ,elt))
					(iota (* nr nc))
					args)
				 ,name))))

   ;; expand anything but "local x" with one symbol
   ;; local x,y,z =&gt; local x;local y;local z
   (pattern-lambda (local (-s)) __)
   (pattern-lambda (local . binds)
		   (expand-decls 'local binds))

   ;; global x,y,z =&gt; global x;global y;global z
   (pattern-lambda (global (-s)) __)
   (pattern-lambda (global . binds)
		   (expand-decls 'global binds))

   ; x::T = rhs =&gt; x::T; x = rhs
   (pattern-lambda (= (|::| x T) rhs)
		   (let ((e (remove-argument-side-effects x)))
		     `(block ,@(cdr e)
			     (|::| ,(car e) ,T)
			     (= ,(car e) ,rhs))))

   ; &lt;expr&gt;::T =&gt; typeassert(expr, T)
   (pattern-lambda (|::| (-- expr (-^ (-s))) T)
		   `(call (top typeassert) ,expr ,T))

   ;; constant definition
   (pattern-lambda (const (= lhs rhs))
		   `(block (const ,(const-check-symbol (decl-var lhs)))
			   (= ,lhs ,rhs)))
   (pattern-lambda (const (global . binds))
		   (qualified-const-expr binds __))
   (pattern-lambda (const (local . binds))
		   (qualified-const-expr binds __))

   ;; incorrect multiple return syntax [a, b, ...] = foo
   (pattern-lambda (= (vcat . args) rhs)
		   (error "use \"(a, b) = ...\" to assign multiple values"))

   ; adding break/continue support to while loop
   (pattern-lambda (while cnd body)
		   `(scope-block
		     (break-block loop-exit
				  (_while ,cnd
					  (break-block loop-cont
						       ,body)))))

   (pattern-lambda (break) '(break loop-exit))
   (pattern-lambda (continue) '(break loop-cont))

   ;; for loops

   (pattern-lambda
    (for (= var (: a b)) body)
    (begin
      (if (not (symbol? var))
	  (error "invalid for loop syntax: expected symbol"))
      (let ((cnt (gensy))
	    (lim (if (number? b) b (gensy))))
	`(scope-block
	  (block
	   (= ,cnt ,a)
	   ,@(if (eq? lim b) '() `((= ,lim ,b)))
	   (break-block loop-exit
			(_while (call &lt;= ,cnt ,lim)
				(block
				 (= ,var ,cnt)
				 (break-block loop-cont
					      ,body)
				 (= ,cnt (call (top convert)
					       (call (top typeof) ,cnt)
					       (call + 1 ,cnt)))))))))))

   ; for loop over arbitrary vectors
   (pattern-lambda
    (for (= i X) body)
    (let ((coll  (gensy))
	  (state (gensy)))
      `(scope-block
	(block (= ,coll ,X)
	       (= ,state (call (top start) ,coll))
	       (while (call (top !) (call (top done) ,coll ,state))
		      (block
		       (= (tuple ,i ,state) (call (top next) ,coll ,state))
		       ,body))))))

   ; update operators
   (pattern-lambda (+= a b)     (expand-update-operator '+ a b))
   (pattern-lambda (-= a b)     (expand-update-operator '- a b))
   (pattern-lambda (*= a b)     (expand-update-operator '* a b))
   (pattern-lambda (.*= a b)    (expand-update-operator '.* a b))
   (pattern-lambda (/= a b)     (expand-update-operator '/ a b))
   (pattern-lambda (./= a b)    (expand-update-operator './ a b))
   (pattern-lambda (//= a b)    (expand-update-operator '// a b))
   (pattern-lambda (.//= a b)   (expand-update-operator '.// a b))
   (pattern-lambda (|\\=| a b)  (expand-update-operator '|\\| a b))
   (pattern-lambda (|.\\=| a b) (expand-update-operator '|.\\| a b))
   (pattern-lambda (^= a b)     (expand-update-operator '^ a b))
   (pattern-lambda (.^= a b)    (expand-update-operator '.^ a b))
   (pattern-lambda (%= a b)     (expand-update-operator '% a b))
   (pattern-lambda (|\|=| a b)  (expand-update-operator '|\|| a b))
   (pattern-lambda (&amp;= a b)     (expand-update-operator '&amp; a b))
   (pattern-lambda ($= a b)     (expand-update-operator '$ a b))
   (pattern-lambda (&lt;&lt;= a b)    (expand-update-operator '&lt;&lt; a b))
   (pattern-lambda (&gt;&gt;= a b)    (expand-update-operator '&gt;&gt; a b))
   (pattern-lambda (&gt;&gt;&gt;= a b)   (expand-update-operator '&gt;&gt;&gt; a b))

   (pattern-lambda (: a (-/ :))     (error "invalid ':' outside indexing"))
   (pattern-lambda (: a b (-/ :))   (error "invalid ':' outside indexing"))
   (pattern-lambda (: (: b (-/ :))) (error "invalid ':' outside indexing"))
   (pattern-lambda (: (: b c))      (error "invalid ':' outside indexing"))
   (pattern-lambda (: c)            (error "invalid ':' outside indexing"))

   (pattern-lambda (: a b c)
		   `(call (top colon) ,a ,b ,c))

   (pattern-lambda (: a b)
		   `(call (top colon) ,a ,b))

   ;; hcat, vcat
   (pattern-lambda (hcat . a)
		   `(call (top hcat) ,@a))

   (pattern-lambda (vcat . a)
		   `(call (top vcat) ,@a))

   ;; transpose operator
   (pattern-lambda (|'| a) `(call ctranspose ,a))
   (pattern-lambda (|.'| a) `(call transpose ,a))

   ;; transposed multiply
   (pattern-lambda (call (-/ *) (|'| a) b)
		   `(call aCb ,a ,b))

   (pattern-lambda (call (-/ *) a (|'| b))
		   `(call abC ,a ,b))

   (pattern-lambda (call (-/ *) (|'| a) (|'| b))
		   `(call aCbC ,a ,b))

   (pattern-lambda (call (-/ *) (|.'| a) b)
		   `(call aTb ,a ,b))

   (pattern-lambda (call (-/ *) a (|.'| b))
		   `(call abT ,a ,b))

   (pattern-lambda (call (-/ *) (|.'| a) (|.'| b))
		   `(call aTbT ,a ,b))

   (pattern-lambda (ccall name RT (tuple . argtypes) . args)
		   (lower-ccall name RT argtypes args))

   )) ; patterns

; patterns that verify all syntactic sugar was well-formed
; if any sugary forms remain after the above patterns, it means the
; patterns didn't match, which implies a syntax error.
(define check-desugared
  (pattern-set
   (pattern-lambda (function . any)
		   (error "invalid function definition"))

   (pattern-lambda (for . any)
		   (error "invalid for loop syntax"))

   (pattern-lambda (type . any)
		   (error "invalid type definition"))

   (pattern-lambda (typealias . any)
		   (error "invalid typealias statement"))

   (pattern-lambda (macro . any)
		   (error "macros must be defined at the top level"))

   ))

;; Comprehensions

(define (lower-nd-comprehension expr ranges)
  (let ((result    (gensy))
	(ri        (gensy))
	(oneresult (gensy)))
    ;; evaluate one expression to figure out type and size
    ;; compute just one value by inserting a break inside loops
    (define (evaluate-one ranges)
      (if (null? ranges)
	  `(= ,oneresult ,expr)
	  (if (eq? (car ranges) `:)
	      (evaluate-one (cdr ranges))
	      `(for ,(car ranges)
		    (block ,(evaluate-one (cdr ranges))
			   (break)) ))))

    ;; compute the dimensions of the result
    (define (compute-dims ranges oneresult-dim)
      (if (null? ranges)
	  (list)
	  (if (eq? (car ranges) `:)
	      (cons `(call size ,oneresult ,oneresult-dim)
		    (compute-dims (cdr ranges) (+ oneresult-dim 1)))
	      (cons `(call length ,(caddr (car ranges)))
		    (compute-dims (cdr ranges) oneresult-dim)) )))

    ;; construct loops to cycle over all dimensions of an n-d comprehension
    (define (construct-loops ranges iters oneresult-dim)
      (if (null? ranges)
	  (if (null? iters)
	      `(block (call (top assign) ,result ,expr ,ri)
		      (+= ,ri 1))
	      `(block (call (top assign) ,result (ref ,expr ,@(reverse iters)) ,ri)
		      (+= ,ri 1)) )
	  (if (eq? (car ranges) `:)
	      (let ((i (gensy)))
		`(for (= ,i (: 1 (call size ,oneresult ,oneresult-dim)))
		      ,(construct-loops (cdr ranges) (cons i iters) (+ oneresult-dim 1)) ))
	      `(for ,(car ranges)
		    ,(construct-loops (cdr ranges) iters oneresult-dim) ))))

    ;; Evaluate the comprehension
    `(scope-block
      (block 
       (= ,oneresult (tuple))
       ,(evaluate-one ranges)
       (= ,result (call _jl_comprehension_zeros ,oneresult ,@(compute-dims ranges 1) ))
       (= ,ri 1)
       ,(construct-loops (reverse ranges) (list) 1)
       ,result ))))

(define lower-comprehensions
  (pattern-set

   (pattern-lambda
    (comprehension expr . ranges)
    (if (any (lambda (x) (eq? x ':)) ranges)
	(lower-nd-comprehension expr ranges)
    (let ((result    (gensy))
	  (ri        (gensy))
	  (oneresult (gensy))
	  (rv        (map (lambda (x) (gensy)) ranges)))

      ;; get the first value in a range
      (define (first-val range)
	`(call (top tupleref)
	       (call (top next) ,range (call (top start) ,range)) 1))

      ;; evaluate one expression to figure out type and size
      (define (evaluate-one ranges)
	`(block
	  ,@(map (lambda (r)
		   ;; r is (= var range)
		   `(= ,(cadr r) ,(first-val (caddr r))))
		 ranges)
	  (= ,oneresult ,expr)
	  ,oneresult))

      ;; compute the dimensions of the result
      (define (compute-dims ranges)
	(map (lambda (r) `(call length ,(caddr r)))
	     ranges))

      ;; construct loops to cycle over all dimensions of an n-d comprehension
      (define (construct-loops ranges)
        (if (null? ranges)
	    `(block (call (top assign) ,result ,expr ,ri)
		    (+= ,ri 1))
	    `(for ,(car ranges)
		  ,(construct-loops (cdr ranges)))))

      ;; Evaluate the comprehension
      (let ((loopranges
	     (map (lambda (r v) `(= ,(cadr r) ,v)) ranges rv)))
	`(scope-block
	  (block
	   (local ,oneresult)
	   ,@(map (lambda (r) `(local ,(cadr r))) ranges)
	   ,@(map (lambda (v r) `(= ,v ,(caddr r))) rv ranges)
	   ;; the evaluate-one code is used by type inference but does not run
	   (if (call (top !) true) ,(evaluate-one loopranges))
	   (= ,result (call (top Array)
			    (static_typeof ,oneresult)
			    ,@(compute-dims loopranges)))
	   (= ,ri 1)
	   ,(construct-loops (reverse loopranges))
	   ,result))))))

   ;; cell array comprehensions
   (pattern-lambda
    (cell-comprehension expr . ranges)
    (let ( (result (gensy))
	   (ri (gensy))
	   (rs (map (lambda (x) (gensy)) ranges)) )

      ;; compute the dimensions of the result
      (define (compute-dims ranges)
	(if (null? ranges)
	    (list)
	    (cons `(call (top length) ,(car ranges))
		  (compute-dims (cdr ranges)))))

      ;; construct loops to cycle over all dimensions of an n-d comprehension
      (define (construct-loops ranges rs)
        (if (null? ranges)
	    `(block (call (top assign) ,result ,expr ,ri)
		    (+= ,ri 1))
	    `(for (= ,(cadr (car ranges)) ,(car rs))
		  ,(construct-loops (cdr ranges) (cdr rs)))))

      ;; Evaluate the comprehension
      `(scope-block
	(block 
	 ,@(map make-assignment rs (map caddr ranges))
	 (= ,result (call (top Array) (top Any) ,@(compute-dims rs)))
	 (= ,ri 1)
	 ,(construct-loops (reverse ranges) (reverse rs))
	 ,result))))

)) ;; lower-comprehensions


; (op (op a b) c) =&gt; (a b c) etc.
(define (flatten-op op e)
  (if (not (pair? e)) e
      (apply append
	     (map (lambda (x)
		    (if (and (pair? x) (eq? (car x) op))
			(flatten-op op x)
			(list x)))
		  (cdr e)))))

(define (expand-and e)
  (let ((e (flatten-op '&amp;&amp; e)))
    (let loop ((tail e))
      (if (null? tail)
	  'true
	  (if (null? (cdr tail))
	      (car tail)
	      `(if ,(car tail)
		   ,(loop (cdr tail))
		   false))))))

(define (expand-or e)
  (let ((e (flatten-op '|\|\|| e)))
    (let loop ((tail e))
      (if (null? tail)
	  'false
	  (if (null? (cdr tail))
	      (car tail)
	      (if (symbol? (car tail))
		  `(if ,(car tail) ,(car tail)
		       ,(loop (cdr tail)))
		  (let ((g (gensy)))
		    `(block (= ,g ,(car tail))
			    (if ,g ,g
				,(loop (cdr tail)))))))))))

; conversion to "linear flow form"
;
; This pass removes control flow constructs from value position.
; A "control flow construct" is anything that would require a branch.
;  (block ... (value-expr ... control-expr ...) ...) =&gt;
;  (block ... (= var control-expr) (value-expr ... var ...) ...)
; except the assignment is incorporated into control-expr, so that
; control exprs only occur in statement position.
;
; The conversion works by passing around the intended destination of
; the value being computed: #f for statement position, #t for value position,
; or a symbol if the value needs to be assigned to a particular variable.
; This is the "dest" argument to to-lff.
;
; This also keeps track of tail position, and converts the code so that
; everything in tail position is returned explicitly.
;
; The result is that every expression whose value is needed is either
; a function argument, an assignment RHS, or returned explicitly.
; In this form, expressions can be analyzed freely without fear of
; intervening branches. Similarly, control flow can be analyzed without
; worrying about implicit value locations (the "evaluation stack").
(define (to-LFF e)
  (define (to-blk r)
    (if (length= r 1)
	(car r)
	(cons 'block (reverse r))))
  (define (blk-tail r)
    (reverse r))
  ; to-lff returns (new-ex . stmts) where stmts is a list of statements that
  ; must run before new-ex is valid.
  ;
  ; If the input expression needed to be removed from its original context,
  ; like the 'if' in "1+if(a,b,c)", then new-ex is a symbol holding the
  ; result of the expression.
  ;
  ; If dest is a symbol or #f, new-ex can be a statement.
  ;
  ; We essentially maintain a stack of control-flow constructs that need to be
  ; run in statement position as we walk around an expression. If we hit
  ; statement context, we can dump the control-flow stuff there.
  ; This expression walk is entirely within the "else" clause of the giant
  ; case expression. Everything else deals with special forms.
  (define (to-lff e dest tail)
    (if (or (not (pair? e)) (memq (car e) '(quote top line))
	    (equal? e '(null)))
	(cond ((symbol? dest) (cons `(= ,dest ,e) '()))
	      (dest (cons (if tail `(return ,e) e)
			  '()))
	      (else (cons e '())))

	(case (car e)
	  ((=)
	   (if (or (not (symbol? (cadr e)))
		   (eq? (cadr e) 'true)
		   (eq? (cadr e) 'false))
	       (error (string "invalid assignment lvalue " (cadr e)))
	       (let ((r (to-lff (caddr e) (cadr e) #f)))
		 (cond ((symbol? dest)
			(cons `(block ,(car r)
				      (= ,dest ,(cadr e)))
			      (cdr r)))
		       (dest
			(cons (if tail `(return ,(cadr e)) (cadr e)) r))
		       (else r)))))

	  ((if)
	   (cond ((or tail (eq? dest #f) (symbol? dest))
		  (let ((r (to-lff (cadr e) #t #f)))
		    (cons `(if
			    ,(car r)
			    ,(to-blk (to-lff (caddr e) dest tail))
			    ,(if (length= e 4)
				 (to-blk (to-lff (cadddr e) dest tail))
				 (to-blk (to-lff '(null)  dest tail))))
			  (cdr r))))
		 (else (let ((g (gensy)))
			 (cons g
			       (cons `(local! ,g) (to-lff e g #f)))))))

	  ((trycatch)
	   (cond (tail
		  (let ((g (gensy)))
		    (to-lff `(block (local! ,g)
				    (= ,g ,e)
				    (return ,g))
			    #f #f)))
		 ((eq? dest #t)
		  (let ((g (gensy)))
		    (cons g
			  (cons `(local! ,g) (to-lff e g #f)))))
		 (else
		  (cons `(trycatch ,(to-blk (to-lff (cadr e) dest tail))
				   ,(to-blk (to-lff (caddr e) dest tail)))
			()))))

	  ((&amp;&amp;)
	   (to-lff (expand-and e) dest tail))
	  ((|\|\||)
	   (to-lff (expand-or e) dest tail))

	  ((block)
	   (if (length= e 2)
	       (to-lff (cadr e) dest tail)
	       (let* ((g (gensy))
		      (stmts
		       (let loop ((tl (cdr e)))
			 (if (null? tl) '()
			     (if (null? (cdr tl))
				 (cond ((or tail (eq? dest #f) (symbol? dest))
					(blk-tail (to-lff (car tl) dest tail)))
				       (else
					(blk-tail (to-lff (car tl) g tail))))
				 (cons (to-blk (to-lff (car tl) #f #f))
				       (loop (cdr tl))))))))
		 (if (and (eq? dest #t) (not tail))
		     (cons g (reverse stmts))
		     (if (and tail (null? stmts))
			 (cons '(return (null))
			       '())
			 (cons (cons 'block stmts)
			       '()))))))

	  ((return)
	   (if (and dest (not tail))
	       (error "misplaced return statement")
	       (to-lff (cadr e) #t #t)))

	  ((_while) (cond ((eq? dest #t)
			   (cons (if tail '(return (null)) '(null))
				 (to-lff e #f #f)))
			  (else
			   (let* ((r (to-lff (cadr e) #t #f))
				  (w (cons `(_while ,(car r)
					      ,(to-blk
						(append
						 (cdr r)
						 (to-lff (caddr e) #f #f))))
					   (cdr r))))
			     (if (symbol? dest)
				 (cons `(= ,dest (null)) w)
				 w)))))

	  ((break-block)
	   (let ((r (to-lff (caddr e) dest tail)))
	     (if dest
		 (cons (car r)
		       (list `(break-block ,(cadr e) ,(to-blk (cdr r)))))
		 (cons `(break-block ,(cadr e) ,(car r))
		       (cdr r)))))

	  ((scope-block)
	   (if (and dest (not tail))
	       (let* ((g (gensy))
		      (r (to-lff (cadr e) g tail)))
		 (cons (car (to-lff g dest tail))
		       ; tricky: need to introduce a new local outside the
		       ; scope-block so the scope-block's value can propagate
		       ; out. otherwise the value could be inaccessible due
		       ; to being wrapped inside a scope.
		       `((scope-block ,(to-blk r))
			 (local! ,g))))
	       (let ((r (to-lff (cadr e) dest tail)))
		 (cons `(scope-block ,(to-blk r))
		       '()))))

	  ;; move the break to the list of preceding statements. value is
	  ;; null but this will never be observed.
	  ((break) (cons '(null) (list e)))

	  ((lambda)
	   (let ((l `(lambda ,(cadr e)
		       ,(to-blk (to-lff (caddr e) #t #t)))))
	     (if (symbol? dest)
		 (cons `(= ,dest ,l) '())
		 (cons (if tail `(return ,l) l) '()))))

	  ((local global)
	   (if (symbol? dest)
	       (error (string "misplaced " (car e) " declaration")))
	   (cons (to-blk (to-lff '(null) dest tail))
		 (list e)))

	  ((|::|)
	   (if dest
	       ;; convert to typeassert or decl based on whether it's in
	       ;; value or statement position.
	       (to-lff `(typeassert ,@(cdr e)) dest tail)
	       (to-lff `(decl ,@(cdr e)) dest tail)))

	  ((unnecessary-tuple)
	   (if dest
	       (to-lff (cadr e) dest tail)
	       ;; remove if not in value position
	       (to-lff '(null) dest tail)))

	  (else
	   (let ((r (map (lambda (arg) (to-lff arg #t #f))
			 (cdr e))))
	     (cond ((symbol? dest)
		    (cons `(= ,dest ,(cons (car e) (map car r)))
			  (apply append (map cdr r))))
		   (else
		    (let ((ex (cons (car e) (map car r))))
		      (cons (if tail `(return ,ex) ex)
			    (apply append (map cdr r)))))))))))
  (to-blk (to-lff e #t #t)))
#|
future issue:
right now scope blocks need to be inside functions:

&gt; (julia-expand '(block (call + 1 (scope-block (block (= a b) c)))))
(block (scope-block (local a) (local #:g13) (block (= a b) (= #:g13 c)))
       (return (call + 1 #:g13)))

&gt; (julia-expand '(scope-block (call + 1 (scope-block (block (= a b) c)))))
(scope-block
 (local #:g15)
 (block (scope-block (local a) (block (= a b) (= #:g15 c)))
	(return (call + 1 #:g15))))

The first one gave something broken, but the second case works.
So far only the second case can actually occur.
|#

(define (declared-global-vars e)
  (if (or (not (pair? e)) (quoted? e))
      '()
      (case (car e)
	((lambda scope-block)  '())
	((global)  (cdr e))
	(else
	 (apply append (map declared-global-vars e))))))

(define (check-dups locals)
  (if (and (pair? locals) (pair? (cdr locals)))
      (or (and (memq (car locals) (cdr locals))
	       (error (string "local " (car locals) " declared twice")))
	  (check-dups (cdr locals))))
  locals)

(define (find-assigned-vars e env)
  (if (or (not (pair? e)) (quoted? e))
      '()
      (case (car e)
	((lambda scope-block)  '())
	((= method)
	 (let ((v (decl-var (cadr e))))
	   (if (memq v env)
	       '()
	       (list v))))
	(else
	 (apply append! (map (lambda (x) (find-assigned-vars x env))
			     e))))))

(define (find-local-decls e env)
  (if (or (not (pair? e)) (quoted? e))
      '()
      (case (car e)
	((lambda scope-block)  '())
	((local)  (list (decl-var (cadr e))))
	(else
	 (apply append! (map (lambda (x) (find-local-decls x env))
			     e))))))

(define (find-local!-decls e env)
  (if (or (not (pair? e)) (quoted? e))
      '()
      (case (car e)
	((lambda scope-block)  '())
	((local!)  (list (decl-var (cadr e))))
	(else
	 (apply append! (map (lambda (x) (find-local!-decls x env))
			     e))))))

(define (find-locals e env)
  (delete-duplicates
   (append! (check-dups (find-local-decls e env))
	    (find-local!-decls e env)
	    (find-assigned-vars e env))))

;; local variable identification
;; convert (scope-block x) to `(scope-block ,@locals ,x)
;; where locals is a list of (local x) expressions, derived from two sources:
;; 1. (local x) expressions inside this scope-block and lambda
;; 2. variables assigned inside this scope-block that don't exist in outer
;;    scopes
(define (add-local-decls e env)
  (if (or (not (pair? e)) (quoted? e)) e
      (cond ((eq? (car e) 'lambda)
	     (let* ((env (append (lam:vars e) env))
		    (body (add-local-decls (caddr e) env)))
	       (list 'lambda (cadr e) body)))
	    
	    ((eq? (car e) 'scope-block)
	     (let* ((glob (declared-global-vars (cadr e)))
		    (vars (find-locals
			   ;; being declared global prevents a variable
			   ;; assignment from introducing a local
			   (cadr e) (append env glob)))
		    (body (add-local-decls (cadr e) (append vars glob env))))
	       `(scope-block ,@(map (lambda (v) `(local ,v))
				    vars)
			     ,body)))
	    (else
	     ;; form (local! x) adds a local to a normal (non-scope) block
	     (let ((newenv (append (declared-local!-vars e) env)))
	       (map (lambda (x)
		      (add-local-decls x newenv))
		    e))))))

(define (identify-locals e) (add-local-decls e '()))

(define (declared-local-vars e)
  (map (lambda (x) (decl-var (cadr x)))
       (filter (lambda (x)
		 (and (pair? x)
		      (or (eq? (car x) 'local)
			  (eq? (car x) 'local!))))
	       (cdr e))))
(define (declared-local!-vars e)
  (map cadr
       (filter (lambda (x)
		 (and (pair? x)
		      (eq? (car x) 'local!)))
	       (cdr e))))

(define (without alst remove)
  (cond ((null? alst)               '())
	((null? remove)             alst)
	((memq (caar alst) remove)  (without (cdr alst) remove))
	(else                       (cons (car alst)
					  (without (cdr alst) remove)))))

; e - expression
; renames - assoc list of (oldname . newname)
; this works on any tree format after identify-locals
(define (rename-vars e renames)
  (cond ((null? renames)  e)
	((symbol? e)      (lookup e renames e))
	((not (pair? e))  e)
	((quoted? e)      e)
	(else
	 (let (; remove vars bound by current expr from rename list
	       (new-renames (without renames
				     (case (car e)
				       ((lambda)      (lam:vars e))
				       ((scope-block) (declared-local-vars e))
				       (else '())))))
	   (cons (car e)
		 (map (lambda (x)
			(rename-vars x new-renames))
		      (cdr e)))))))

;; all vars used in e outside x
(define (vars-used-outside e x)
  (cond ((symbol? e) (list e))
	((or (atom? e) (quoted? e)) '())
	((eq? e x) '())
	((eq? (car e) 'lambda)
	 (diff (free-vars (lam:body e))
	       (lambda-all-vars e)))
	(else (unique
	       (apply nconc
		      (map (lambda (e) (vars-used-outside e x)) (cdr e)))))))

(define (flatten-lambda-scopes e)
  (cond ((or (atom? e) (quoted? e)) e)
	((eq? (car e) 'lambda) (flatten-scopes e))
	(else (map flatten-lambda-scopes e))))

;; remove (scope-block) and (local), convert lambdas to the form
;; (lambda (argname...) (locals var...) body)
(define (flatten-scopes e)
  (define scope-block-vars '())
  (define (remove-scope-blocks e context usedv)
    (cond ((or (atom? e) (quoted? e)) e)
	  ((eq? (car e) 'lambda) e)
	  ((eq? (car e) 'scope-block)
	   (let ((vars (declared-local-vars e))
		 (body (car (last-pair e))))
	     (let* ((outer    (append usedv (vars-used-outside context e)))
		    ;; only rename conflicted vars
		    (to-ren   (filter (lambda (v) (memq v outer)) vars))
		    (newnames (map (lambda (x) (gensy)) to-ren))
		    (bod      (rename-vars (remove-scope-blocks body e outer)
					   (map cons to-ren newnames))))
	       (set! scope-block-vars (nconc newnames scope-block-vars))
	       (set! scope-block-vars (nconc (diff vars to-ren)
					     scope-block-vars))
	       bod)))
	  (else (map (lambda (e) (remove-scope-blocks e context usedv))
		     e))))
  
  (cond ((not (pair? e))   e)
	((quoted? e)       e)
	((eq? (car e)      'lambda)
	 (let* ((argnames  (lam:vars e))
		(body      (caddr e))
		(body2     (flatten-lambda-scopes body))
		(r-s-b     (remove-scope-blocks body2 body2 argnames)))
	   (for-each (lambda (v)
		       (if (memq v argnames)
			   (error (string "local " v
					  " conflicts with argument"))))
		     (declared-local-vars body))
	   `(lambda ,(cadr e)
	      (locals ,@scope-block-vars)
	      ,r-s-b)))
	(else (map (lambda (x) (if (not (pair? x)) x
				   (flatten-scopes x)))
		   e))))

(define (make-var-info name) (list name 'Any 0))
(define vinfo:name car)
(define vinfo:type cadr)
(define (vinfo:capt v) (&lt; 0 (logand (caddr v) 1)))
(define (vinfo:const v) (&lt; 0 (logand (caddr v) 8)))
(define (vinfo:set-type! v t) (set-car! (cdr v) t))
;; record whether var is captured
(define (vinfo:set-capt! v c) (set-car! (cddr v)
					(if c
					    (logior (caddr v) 1)
					    (logand (caddr v) -2))))
;; whether var is assigned
(define (vinfo:set-asgn! v a) (set-car! (cddr v)
					(if a
					    (logior (caddr v) 2)
					    (logand (caddr v) -3))))
;; whether var is assigned by an inner function
(define (vinfo:set-iasg! v a) (set-car! (cddr v)
					(if a
					    (logior (caddr v) 4)
					    (logand (caddr v) -5))))
;; whether var is const
(define (vinfo:set-const! v a) (set-car! (cddr v)
					 (if a
					     (logior (caddr v) 8)
					     (logand (caddr v) -9))))

(define var-info-for assq)

(define (lambda-all-vars e)
  (append (lam:vars e)
	  (cdr (caddr e))))

(define (free-vars e)
  (cond ((symbol? e) (list e))
	((or (atom? e) (quoted? e)) '())
	((eq? (car e) 'lambda)
	 (diff (free-vars (lam:body e))
	       (lambda-all-vars e)))
	(else (unique (apply nconc (map free-vars (cdr e)))))))

; convert each lambda's (locals ...) to
;   ((localvars...) var-info-lst captured-var-infos)
; where var-info-lst is a list of var-info records
(define (analyze-vars e env captvars)
  (cond ((or (atom? e) (quoted? e)) e)
	((eq? (car e) '=)
	 (let ((vi (var-info-for (cadr e) env)))
	   (if vi
	       (begin
		 (vinfo:set-asgn! vi #t)
		 (if (assq (car vi) captvars)
		     (vinfo:set-iasg! vi #t)))))
	 `(= ,(cadr e) ,(analyze-vars (caddr e) env captvars)))
	((or (eq? (car e) 'local) (eq? (car e) 'local!))
	 '(null))
	((eq? (car e) 'typeassert)
	 ;(let ((vi (var-info-for (cadr e) env)))
	 ;  (if vi
	 ;      (begin (vinfo:set-type! vi (caddr e))
	 ;             (cadr e))
	 `(call (top typeassert) ,(cadr e) ,(caddr e)))
	((or (eq? (car e) 'decl) (eq? (car e) '|::|))
	 ; handle var::T declaration by storing the type in the var-info
	 ; record. for non-symbols or globals, emit a type assertion.
	 (let ((vi (var-info-for (cadr e) env)))
	   (if vi
	       (begin (vinfo:set-type! vi (caddr e))
		      '(null))
	       `(call (top typeassert) ,(cadr e) ,(caddr e)))))
	((eq? (car e) 'lambda)
	 (letrec ((args (lam:args e))
		  (locl (cdr (caddr e)))
		  (allv (nconc (map arg-name args) locl))
		  (fv   (diff (free-vars (lam:body e)) allv))
		  (glo  (declared-global-vars (lam:body e)))
		  ; make var-info records for vars introduced by this lambda
		  (vi   (nconc
			 (map (lambda (decl) (make-var-info (decl-var decl)))
			      args)
			 (map make-var-info locl)))
		  ; captured vars: vars from the environment that occur
		  ; in our set of free variables (fv).
		  (cv    (filter (lambda (v) (and (memq (vinfo:name v) fv)
						  (not (memq
							(vinfo:name v) glo))))
				 env))
		  (bod   (analyze-vars
			  (lam:body e)
			  (append vi
				  ; new environment: add our vars
				  (filter (lambda (v)
					    (and
					     (not (memq (vinfo:name v) allv))
					     (not (memq (vinfo:name v) glo))))
					  env))
			  cv)))
	   ; mark all the vars we capture as captured
	   (for-each (lambda (v) (vinfo:set-capt! v #t))
		     cv)
	   `(lambda ,args
	      (,(cdaddr e) ,vi ,cv)
	      ,bod)))
	((eq? (car e) 'localize)
	 ;; special feature for @spawn that wraps a piece of code in a "let"
	 ;; binding each free variable.
	 (let ((env-vars (map vinfo:name env))
	       (localize-vars (cddr e)))
	   (let ((vs (filter
		      (lambda (v) (or (memq v localize-vars)
				      (memq v env-vars)))
		      (free-vars (cadr e)))))
	     (analyze-vars
	      `(call (lambda ,vs ,(caddr (cadr e)) ,(cadddr (cadr e)))
		     ,@vs)
	      env captvars))))
	((eq? (car e) 'method)
	 (let ((vi (var-info-for (cadr e) env)))
	   (if vi
	       (begin
		 (vinfo:set-asgn! vi #t)
		 (if (assq (car vi) captvars)
		     (vinfo:set-iasg! vi #t)))))
	 `(method ,(cadr e)
		  ,(analyze-vars (caddr  e) env captvars)
		  ,(analyze-vars (cadddr e) env captvars)
		  ,(cadddr (cdr e))))
	(else (cons (car e)
		    (map (lambda (x) (analyze-vars x env captvars))
			 (cdr e))))))

(define (analyze-variables e) (analyze-vars e '() '()))

; remove if, _while, block, break-block, and break
; replaced with goto and gotoifnot
; TODO: remove type-assignment-affecting expressions from conditional branch.
;       needed because there's no program location after the condition
;       is evaluated but before the branch's successors.
;       pulling a complex condition out to a temporary variable creates
;       such a location (the assignment to the variable).
(define (goto-form e)
  (let ((code '())
	(ip   0)
	(label-counter 0)
	(handler-level 0))
    (define (emit c)
      (set! code (cons c code))
      (set! ip (+ ip 1)))
    (define (make-label)
      (begin0 label-counter
	      (set! label-counter (+ 1 label-counter))))
    (define (mark-label l) (emit `(label ,l)))
    (define (make&amp;mark-label)
      (if (and (pair? code) (pair? (car code)) (eq? (caar code) 'label))
	  ;; use current label if there is one
	  (cadr (car code))
	  (let ((l (make-label)))
	    (mark-label l)
	    l)))
    (define (compile e break-labels vi)
      (if (or (not (pair? e)) (equal? e '(null)))
	  ; atom has no effect, but keep symbols for undefined-var checking
	  (if (symbol? e) (emit e) #f)
	  (case (car e)
	    ((call)  (emit (goto-form e)))
	    ((=)     (let ((vt (vinfo:type
				(or (var-info-for (cadr e) vi) '(#f Any)))))
		       (if (not (eq? vt 'Any))
			   (emit `(= ,(cadr e) (call (top convert) ,vt
						     ,(goto-form (caddr e)))))
			   (emit `(= ,(cadr e) ,(goto-form (caddr e)))))))
	    ((if) (let ((test     `(gotoifnot ,(goto-form (cadr e)) _))
			(end-jump `(goto _))
			(tail     (and (pair? (caddr e))
				       (eq? (car (caddr e)) 'return))))
		    (emit test)
		    (compile (caddr e) break-labels vi)
		    (if (and (not tail)
			     (not (equal? (cadddr e) '(null))))
			(emit end-jump))
		    (set-car! (cddr test) (make&amp;mark-label))
		    (compile (cadddr e) break-labels vi)
		    (if (not tail)
			(set-car! (cdr end-jump) (make&amp;mark-label)))))
	    ((block) (for-each (lambda (x) (compile x break-labels vi))
			       (cdr e)))
	    ((_while) (let ((topl (make&amp;mark-label))
			    (endl (make-label)))
			(emit `(gotoifnot ,(goto-form (cadr e)) ,endl))
			(compile (caddr e) break-labels vi)
			(emit `(goto ,topl))
			(mark-label endl)))
	    ((break-block) (let ((endl (make-label)))
			     (compile (caddr e)
				      (cons (list (cadr e) endl handler-level)
					    break-labels)
				      vi)
			     (mark-label endl)))
	    ((break) (let ((labl (assq (cadr e) break-labels)))
		       (if (not labl)
			   (error "break or continue outside loop")
			   (begin
			     (if (&gt; handler-level (caddr labl))
				 (emit `(leave
					 ,(- handler-level (caddr labl)))))
			     (emit `(goto ,(cadr labl)))))))
	    ((return) (begin
			(if (&gt; handler-level 0)
			    (emit `(leave ,handler-level)))
			(emit (goto-form e))))
	    ;; exception handlers are lowered using
	    ;; (enter L) - push handler with catch block at label L
	    ;; (leave n) - pop N exception handlers
	    ;; (the_exception) - get the thrown object
	    ((trycatch)
	     (let ((catch (make-label))
		   (endl  (make-label)))
	       (emit `(enter ,catch))
	       (set! handler-level (+ handler-level 1))
	       (compile (cadr e) break-labels vi)
	       (set! handler-level (- handler-level 1))
	       (emit `(leave 1))
	       (emit `(goto ,endl))
	       (mark-label catch)
	       (emit `(leave 1))
	       (compile (caddr e) break-labels vi)
	       (mark-label endl)))

	    ((global) #f)  ; remove global declarations
	    (else  (emit (goto-form e))))))
    (cond ((or (not (pair? e)) (quoted? e)) e)
	  ((eq? (car e) 'lambda)
	   (compile (cadddr e) '() (append (cadr (caddr e))
					   (caddr (caddr e))))
	   `(lambda ,(cadr e) ,(caddr e)
		    ,(cons 'body (reverse! code))))
	  (else (cons (car e)
		      (map goto-form (cdr e)))))))

(define (to-goto-form e)
  (goto-form e))

(define (expand-backquote e)
  (cond ((or (eq? e 'true) (eq? e 'false))  e)
	((symbol? e)          `(quote ,e))
        ((not (pair? e))      e)
	((eq? (car e) '$)     (cadr e))
	((and (eq? (car e) 'quote) (pair? (cadr e)))
	 (expand-backquote (expand-backquote (cadr e))))
	((not (any (lambda (x)
		     (match '($ (tuple (... x))) x))
		   e))
	 `(call (top expr) ,@(map expand-backquote e)))
	(else
	 (let loop ((p (cdr e)) (q '()))
	   (if (null? p)
	       (let ((forms (reverse q)))
		 `(call (top expr) ,(expand-backquote (car e))
			(call (top append) ,@forms)))
	       ; look for splice inside backquote, e.g. (a,$(x...),b)
	       (if (match '($ (tuple (... x))) (car p))
		   (loop (cdr p)
			 (cons (cadr (cadadr (car p))) q))
		   (loop (cdr p)
			 (cons `(cell1d ,(expand-backquote (car p)))
			       q))))))))

(define (julia-expand-macros e)
  (cond ((not (pair? e))     e)
	((and (eq? (car e) 'quote) (pair? (cadr e)))
	 ;; backquote is essentially a built-in macro at the moment
	 (julia-expand-macros (expand-backquote (cadr e))))
	((eq? (car e) 'macrocall)
	 ;; expand macro
	 (let ((form
		(apply invoke-julia-macro (cadr e) (cddr e))))
	   (if (not form)
	       (error (string "macro " (cadr e) " not defined")))
	   (if (equal? form '(error))
	       (error (string "error expanding macro " (cadr e))))
	   (julia-expand-macros form)))
	(else
	 (map julia-expand-macros e))))

(define (julia-expand1 ex)
  (to-goto-form
   (analyze-variables
    (flatten-scopes
     (identify-locals ex)))))

(define (julia-expand0 ex)
  (reset-gensyms)
  (to-LFF
   (pattern-expand patterns
    (pattern-expand lower-comprehensions
     (pattern-expand binding-form-patterns
      (julia-expand-macros ex))))))

(define (julia-expand ex)
  (julia-expand1 (julia-expand0 ex)))
</t>
<t tx="ekr.20120404123906.7298">@killcolor

(define ops-by-prec
@verbatim
  '#((= := += -= *= /= //= .//= .*= ./= |\\=| |.\\=| ^= .^= %= |\|=| &amp;= $= =&gt; &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=)
     (?)
     (|\|\||)
     (&amp;&amp;)
     ; note: there are some strange-looking things in here because
     ; the way the lexer works, every prefix of an operator must also
     ; be an operator.
     (&lt;- -- --&gt;)
     (&gt; &lt; &gt;= &lt;= == != |.&gt;| |.&lt;| |.&gt;=| |.&lt;=| |.==| |.!=| |.=| |.!| |&lt;:| |&gt;:|)
     (: ..)
     (+ - |\|| $)
@verbatim
     (&lt;&lt; &gt;&gt; &gt;&gt;&gt;)
     (* / |./| % &amp; |.*| |\\| |.\\|)
     (// .//)
     (^ |.^|)
     (|::|)
     (|.|)))

(define-macro (prec-ops n) `(aref ops-by-prec ,n))

(define normal-ops (vector.map identity ops-by-prec))
(define no-pipe-ops (vector.map identity ops-by-prec))
(vector-set! no-pipe-ops 7 '(+ - $))
(define range-colon-enabled #t)
; in space-sensitive mode "x -y" is 2 expressions, not a subtraction
(define space-sensitive #f)
; treat 'end' like a normal symbol instead of a reserved word
(define end-symbol #f)
(define current-filename 'none)

(define-macro (with-normal-ops . body)
  `(with-bindings ((ops-by-prec normal-ops)
		   (range-colon-enabled #t)
		   (space-sensitive #f))
		  ,@body))

(define-macro (without-bitor . body)
  `(with-bindings ((ops-by-prec no-pipe-ops))
		  ,@body))

(define-macro (without-range-colon . body)
  `(with-bindings ((range-colon-enabled #f))
		  ,@body))

(define-macro (with-space-sensitive . body)
  `(with-bindings ((space-sensitive #t))
		  ,@body))

(define-macro (with-end-symbol . body)
  `(with-bindings ((end-symbol #t))
		  ,@body))

(define assignment-ops (prec-ops 0))

(define (assignment? e)
  (and (pair? e) (eq? (car e) '=)))

(define unary-ops '(+ - ! ~ $ &amp; |&lt;:| |&gt;:|))

; operators that are both unary and binary
(define unary-and-binary-ops '(+ - $ &amp;))

; operators that are special forms, not function names
(define syntactic-operators
  '(= := += -= *= /= //= .//= .*= ./= |\\=| |.\\=| ^= .^= %= |\|=| &amp;= $= =&gt;
@verbatim
      &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= -&gt; --&gt; |\|\|| &amp;&amp; : |::| |.|))
(define syntactic-unary-operators '($ &amp;))

(define reserved-words '(begin while if for try return break continue
			 function macro quote let local global const
			 abstract typealias type bitstype
			 module import export ccall))

(define (syntactic-op? op) (memq op syntactic-operators))
(define (syntactic-unary-op? op) (memq op syntactic-unary-operators))

(define trans-op (string-&gt;symbol ".'"))
(define ctrans-op (string-&gt;symbol "'"))
(define vararg-op (string-&gt;symbol "..."))

(define operators (list* '~ '! '-&gt; ctrans-op trans-op vararg-op
			 (delete-duplicates
			  (apply append (vector-&gt;list ops-by-prec)))))

(define op-chars
  (list-&gt;string
   (delete-duplicates
    (apply append
	   (map string-&gt;list (map symbol-&gt;string operators))))))

; --- lexer ---

(define special-char?
  (let ((chrs (string-&gt;list "()[]{},;\"`@")))
    (lambda (c) (memv c chrs))))
(define (newline? c) (eqv? c #\newline))
(define (identifier-char? c) (or (and (char&gt;=? c #\A)
				      (char&lt;=? c #\Z))
				 (and (char&gt;=? c #\a)
				      (char&lt;=? c #\z))
				 (and (char&gt;=? c #\0)
				      (char&lt;=? c #\9))
				 (char&gt;=? c #\uA1)
				 (eqv? c #\_)))
;; characters that can be in an operator
(define (opchar? c) (string.find op-chars c))
;; characters that can follow . in an operator
(define (dot-opchar? c) (and (char? c) (string.find "*^/\\" c)))
(define (operator? c) (memq c operators))

(define (skip-to-eol port)
  (let ((c (peek-char port)))
    (cond ((eof-object? c)    c)
	  ((eqv? c #\newline) c)
	  (else               (read-char port)
			      (skip-to-eol port)))))

(define (read-operator port c)
  (read-char port)
  (if (and (eqv? c #\*) (eqv? (peek-char port) #\*))
      (error "use ^ instead of **"))
  (if (or (eof-object? (peek-char port)) (not (opchar? (peek-char port))))
      (symbol (string c)) ; 1-char operator
      (let loop ((str (string c))
		 (c   (peek-char port)))
	(if (and (not (eof-object? c)) (opchar? c))
	    (let ((newop (string str c)))
	      (if (operator? (string-&gt;symbol newop))
		  (begin (read-char port)
			 (loop newop (peek-char port)))
		  (string-&gt;symbol str)))
	    (string-&gt;symbol str)))))

(define (accum-tok-eager c pred port)
  (let loop ((str '())
	     (c c))
    (if (and (not (eof-object? c)) (pred c))
	(begin (read-char port)
	       (loop (cons c str) (peek-char port)))
	(list-&gt;string (reverse str)))))

(define (char-hex? c)
  (or (char-numeric? c)
      (and (&gt;= c #\a) (&lt;= c #\f))
      (and (&gt;= c #\A) (&lt;= c #\F))))

(define (read-number port . leadingdot)
  (let ((str  (open-output-string))
	(pred char-numeric?))
    (define (allow ch)
      (let ((c (peek-char port)))
	(and (eqv? c ch)
	     (begin (write-char (read-char port) str) #t))))
    (define (disallow-dot)
      (if (eqv? (peek-char port) #\.)
	  (begin (read-char port)
		 (if (dot-opchar? (peek-char port))
		     (io.ungetc port #\.)
		     (error (string "invalid numeric constant "
				    (get-output-string str) #\.))))))
    (define (read-digs)
      (let ((d (accum-tok-eager (peek-char port) pred port)))
	(and (not (equal? d ""))
	     (not (eof-object? d))
	     (display d str)
	     #t)))
    (if (pair? leadingdot)
	(write-char #\. str)
	(if (eqv? (peek-char port) #\0)
	    (begin (write-char (read-char port) str)
		   (if (allow #\x)
		       (set! pred char-hex?)))
	    (allow #\.)))
    (read-digs)
    (if (eqv? (peek-char port) #\.)
	(begin (read-char port)
	       (if (dot-opchar? (peek-char port))
		   (io.ungetc port #\.)
		   (begin (write-char #\. str)
			  (read-digs)
			  (disallow-dot)))))
    (let ((c (peek-char port)))
      (if (or (eqv? c #\e) (eqv? c #\E))
	  (begin (read-char port)
		 (let ((d (peek-char port)))
		   (if (and (not (eof-object? d))
			    (or (char-numeric? d) (eqv? d #\+) (eqv? d #\-)))
		       (begin (write-char c str)
			      (write-char (read-char port) str)
			      (read-digs)
			      (disallow-dot))
		       (io.ungetc port c))))))
    (let* ((s (get-output-string str))
	   (n (string-&gt;number s (if (eq? pred char-hex?) 16 10))))
      (if n
	  (if (eq? pred char-hex?)
	      (sized-uint-literal n s)
	      (if (and (integer? n) (&gt; n 9223372036854775807))
	          (error (string "invalid numeric constant " s))
	          n))
	  (error (string "invalid numeric constant " s))))))

(define (sized-uint-literal n s)
  (let ((l (length s)))
    (cond ((&lt; l 5)  (uint8  n))
	  ((&lt; l 7)  (uint16 n))
	  ((&lt; l 11) (uint32 n))
	  (else     (uint64 n)))))

(define (skip-ws-and-comments port)
  (skip-ws port #t)
  (if (eqv? (peek-char port) #\#)
      (begin (skip-to-eol port)
	     (skip-ws-and-comments port)))
  #t)

(define (next-token port s)
  (aset! s 2 (eq? (skip-ws port #f) #t))
  (let ((c (peek-char port)))
    (cond ((or (eof-object? c) (newline? c))  (read-char port))

	  ((special-char? c)    (read-char port))

	  ((char-numeric? c)    (read-number port))
	  
	  ((eqv? c #\#)         (skip-to-eol port) (next-token port s))
	  
	  ; . is difficult to handle; it could start a number or operator
	  ((and (eqv? c #\.)
		(let ((c (read-char port))
		      (nextc (peek-char port)))
		  (cond ((eof-object? nextc)
			 '|.|)
			((char-numeric? nextc)
			 (read-number port c))
			((opchar? nextc)
			 (string-&gt;symbol
			  (string-append (string c)
					 (symbol-&gt;string
					  (read-operator port nextc)))))
			(else '|.|)))))
	  
	  ((opchar? c)  (read-operator port c))

	  ((identifier-char? c) (accum-julia-symbol c port))

	  #;((eqv? c #\")
	   (with-exception-catcher
	    (lambda (e)
	      (error "invalid string literal"))
	    (lambda () (read port))))

	  (else (error (string "invalid character " (read-char port)))))))

; --- parser ---

(define (make-token-stream s) (vector #f s #t #f))
(define-macro (ts:port s)       `(aref ,s 1))
(define-macro (ts:last-tok s)   `(aref ,s 0))
(define-macro (ts:set-tok! s t) `(aset! ,s 0 ,t))
(define-macro (ts:space? s)     `(aref ,s 2))
(define-macro (ts:pbtok s)      `(aref ,s 3))
(define (ts:put-back! s t)
  (if (ts:pbtok s)
      (error "too many pushed-back tokens (internal error)")
      (aset! s 3 t)))

(define (peek-token s)
  (or (ts:pbtok s)
      (ts:last-tok s)
      (begin (ts:set-tok! s (next-token (ts:port s) s))
	     (ts:last-tok s))))

(define (require-token s)
  (let ((t (or (ts:pbtok s) (ts:last-tok s) (next-token (ts:port s) s))))
    (if (eof-object? t)
	(error "incomplete: premature end of input")
	(if (newline? t)
	    (begin (take-token s)
		   (require-token s))
	    (begin (if (not (ts:pbtok s)) (ts:set-tok! s t))
		   t)))))

(define (take-token s)
  (or
   (begin0 (ts:pbtok s)
	   (aset! s 3 #f))
   (begin0 (ts:last-tok s)
	   (ts:set-tok! s #f))))

; parse left-to-right binary operator
; produces structures like (+ (+ (+ 2 3) 4) 5)
(define (parse-LtoR s down ops)
  (let loop ((ex (down s)))
    (let ((t (peek-token s)))
      (if (not (memq t ops))
	  ex
	  (begin (take-token s)
		 (if (syntactic-op? t)
		     (loop (list t ex (down s)))
		     (loop (list 'call t ex (down s)))))))))

; parse right-to-left binary operator
; produces structures like (= a (= b (= c d)))
(define (parse-RtoL s down ops)
  (let ((ex (down s)))
    (let ((t (peek-token s)))
      (if (not (memq t ops))
	  ex
	  (begin (take-token s)
		 (if (syntactic-op? t)
		     (list t ex (parse-RtoL s down ops))
		     (list 'call t ex (parse-RtoL s down ops))))))))

(define (parse-cond s)
  (let ((ex (parse-or s)))
    (if (not (eq? (peek-token s) '?))
	ex
	(begin (take-token s)
	       (let ((then (without-range-colon (parse-eq* s))))
		 (if (not (eq? (take-token s) ':))
		     (error "colon expected in ? expression")
		     (list 'if ex then (parse-cond s))))))))

(define (invalid-initial-token? tok)
  (or (eof-object? tok)
      (memv tok '(#\) #\] #\} else elseif catch))))

(define (line-number-node s)
  `(line ,(input-port-line (ts:port s))))

(define (line-number-filename-node s)
  `(line ,(input-port-line (ts:port s)) ,current-filename))

;; insert line/file for short-form function defs, otherwise leave alone
(define (short-form-function-loc ex lno)
  (if (and (pair? ex)
	   (eq? (car ex) '=)
	   (pair? (cadr ex))
	   (eq? (caadr ex) 'call))
      `(= ,(cadr ex) (block (line ,lno ,current-filename) ,(caddr ex)))
      ex))

; parse a@b@c@... as (@ a b c ...) for some operator @
; op: the operator to look for
; head: the expression head to yield in the result, e.g. "a;b" =&gt; (block a b)
; closers: a list of tokens that will stop the process
;          however, this doesn't consume the closing token, just looks at it
; allow-empty: if true will ignore runs of the operator, like a@@@@b
; ow, my eyes!!
(define (parse-Nary s down op head closers allow-empty)
  (if (invalid-initial-token? (require-token s))
      (error (string "unexpected " (peek-token s))))
  (if (memv (require-token s) closers)
      (list head)  ; empty block
      (let loop ((ex
                  ;; in allow-empty mode skip leading runs of operator
		  (if (and allow-empty (eqv? (require-token s) op))
		      '()
		      (if (eqv? op #\newline)
			  (let ((loc (line-number-node s)))
			    ;; note: line-number must happen before (down s)
			    (list (down s) loc))
			  (list (down s)))))
		 (first? #t))
	(let ((t (peek-token s)))
	  (if (not (eqv? t op))
	      (if (or (null? ex) (pair? (cdr ex)) (not first?))
	          ; () =&gt; (head)
	          ; (ex2 ex1) =&gt; (head ex1 ex2)
	          ; (ex1) ** if operator appeared =&gt; (head ex1) (handles "x;")
		  (cons head (reverse ex))
	          ; (ex1) =&gt; ex1
		  (car ex))
	      (begin (take-token s)
		     ; allow input to end with the operator, as in a;b;
		     (if (or (eof-object? (peek-token s))
			     (memv (peek-token s) closers)
			     (and allow-empty
				  (eqv? (peek-token s) op)))
			 (loop ex #f)
			 (if (eqv? op #\newline)
			     (let ((loc (line-number-node s)))
			       (loop (list* (down s) loc ex) #f))
			     (loop (cons (down s) ex) #f)))))))))

; colon is strange; 3 arguments with 2 colons yields one call:
; 1:2   =&gt; (: 1 2)
; 1:2:3 =&gt; (: 1 2 3)
; 1:    =&gt; (: 1 :)
; 1:2:  =&gt; (: 1 2 :)
;; not enabled:
;;; :2    =&gt; (: 2)
;;; :1:2  =&gt; (: (: 1 2))
;;; :1:   =&gt; (: (: 1 :))
; a simple state machine is up to the task.
; we will leave : expressions as a syntax form, not a call to ':',
; so they can be processed by syntax passes.
(define (parse-range s)
  (if (not range-colon-enabled)
      (return (parse-expr s)))
  (let loop ((ex (parse-expr s))
	     (first? #t))
    (let* ((t   (peek-token s))
	   (spc (ts:space? s)))
      (if (not (eq? t ':))
	  ex
	  (begin (take-token s)
		 (if (and space-sensitive spc
			  (or (peek-token s) #t) (not (ts:space? s)))
		     ;; "a :b" in space sensitive mode
		     (begin (ts:put-back! s ':)
			    ex)
		     (let ((argument
			    (if (closing-token? (peek-token s))
				':  ; missing last argument
				(parse-expr s))))
		       (if first?
			   (loop (list t ex argument) #f)
			   (loop (append ex (list argument)) #t)))))))))

; the principal non-terminals follow, in increasing precedence order

(define (parse-block s) (parse-Nary s parse-block-stmts #\newline 'block
				    '(end else elseif catch) #t))
(define (parse-block-stmts s) (parse-Nary s parse-eq #\; 'block
					  '(end else elseif catch #\newline)
					  #t))
(define (parse-stmts s) (parse-Nary s parse-eq    #\; 'block '(#\newline) #t))

(define (parse-eq s)
  (let ((lno (input-port-line (ts:port s))))
    (short-form-function-loc
     (parse-RtoL s parse-comma (prec-ops 0)) lno)))
; parse-eq* is used where commas are special, for example in an argument list
(define (parse-eq* s)   (parse-RtoL s parse-cond  (prec-ops 0)))
; parse-comma is needed for commas outside parens, for example a = b,c
(define (parse-comma s) (parse-Nary s parse-cond  #\, 'tuple '( #\) ) #f))
(define (parse-or s)    (parse-LtoR s parse-and   (prec-ops 2)))
(define (parse-and s)   (parse-LtoR s parse-arrow (prec-ops 3)))
(define (parse-arrow s) (parse-RtoL s parse-ineq  (prec-ops 4)))
(define (parse-ineq s)  (parse-comparison s (prec-ops 5)))

; parse left to right, combining chains of certain operators into 1 call
; e.g. a+b+c =&gt; (call + a b c)
(define (parse-expr s)
  (let ((ops (prec-ops 7)))
    (let loop ((ex       (parse-shift s))
	       (chain-op #f))
      (let* ((t   (peek-token s))
	     (spc (ts:space? s)))
	(if (not (memq t ops))
	    ex
	    (begin
	      (take-token s)
	      (cond ((and space-sensitive spc (memq t unary-and-binary-ops)
			  (or (peek-token s) #t) (not (ts:space? s)))
		     ;; here we have "x -y"
		     (ts:put-back! s t)
		     ex)
		    ((eq? t chain-op)
		     (loop (append ex (list (parse-shift s)))
			   chain-op))
		    (else
		     (loop (list 'call t ex (parse-shift s))
			   (and (eq? t '+) t))))))))))

(define (parse-shift s) (parse-LtoR s parse-term (prec-ops 8)))

; given an expression and the next token, is there a juxtaposition
; operator between them?
(define (juxtapose? expr t)
  (and (not (operator? t))
       (not (operator? expr))
       (not (memq t reserved-words))
       (not (closing-token? t))
       (not (newline? t))
       (or (number? expr)
	   (not (memv t '(#\( #\[ #\{))))))

(define (parse-term s)
  (let ((ops (prec-ops 9)))
    (let loop ((ex       (parse-rational s))
	       (chain-op #f))
      (let ((t (peek-token s)))
	(cond ((and (juxtapose? ex t)
		    (not (ts:space? s)))
	       (if (eq? chain-op '*)
		   (loop (append ex (list (parse-rational s)))
			 chain-op)
		   (loop (list 'call '* ex (parse-rational s))
			 '*)))
	      ((not (memq t ops))
	       ex)
	      ((eq? t chain-op)
	       (begin (take-token s)
		      (loop (append ex (list (parse-rational s)))
			    chain-op)))
	      (else
	       (begin (take-token s)
		      (loop (list 'call t ex (parse-rational s))
			    (and (eq? t '*) t)))))))))

(define (parse-comparison s ops)
  (let loop ((ex (parse-range s))
	     (first #t))
    (let ((t (peek-token s)))
      (if (not (memq t ops))
	  ex
	  (begin (take-token s)
		 (if first
		     (loop (list 'comparison ex t (parse-range s)) #f)
		     (loop (append ex (list t (parse-range s))) #f)))))))

; flag an error for tokens that cannot begin an expression
(define (closing-token? tok)
  (or (eof-object? tok)
      (and (eq? tok 'end) (not end-symbol))
      (memv tok '(#\, #\) #\] #\} #\; else elseif catch))))

(define (parse-unary s)
  (let ((t (require-token s)))
    (if (closing-token? t)
	(error (string "unexpected " t)))
    (cond ((memq t unary-ops)
	   (let ((op (take-token s))
		 (next (peek-token s)))
	     (cond ((closing-token? next)
		    op)  ; return operator by itself, as in (+)
		   ((syntactic-unary-op? op)
		    (list op (parse-unary s)))
		   ((eqv? next #\{)  ;; this case is +{T}(x::T) = ...
		    (ts:put-back! s op)
		    (parse-factor s))
		   (else
		    (let ((arg (parse-unary s)))
		      (if (and (pair? arg)
			       (eq? (car arg) 'tuple))
			  (list* 'call op (cdr arg))
			  (list  'call op arg)))))))
	  ((eq? t '|::|)
	   ;; allow ::T, omitting argument name
	   (take-token s)
	   `(|::| ,(gensym) ,(parse-call s)))
	  (else
	   (parse-factor s)))))

; handle ^, .^, and postfix ...
(define (parse-factor-h s down ops)
  (let ((ex (down s)))
    (let ((t (peek-token s)))
      (cond ((eq? t '...)
	     (take-token s)
	     (list '... ex))
	    ((not (memq t ops))
	     ex)
	    (else
	     (list 'call
		   (take-token s) ex (parse-factor-h s parse-unary ops)))))))

(define (parse-rational s) (parse-LtoR s parse-unary (prec-ops 10)))

; -2^3 is parsed as -(2^3), so call parse-decl for the first argument,
; and parse-unary from then on (to handle 2^-3)
(define (parse-factor s)
  (parse-factor-h s parse-decl (prec-ops 11)))

(define (parse-decl s) (parse-LtoR s parse-call (prec-ops 12)))

; parse function call, indexing, dot, and transpose expressions
; also handles looking for syntactic reserved words
(define (parse-call s)
  (let ((ex (parse-atom s)))
    (if (memq ex reserved-words)
	(parse-resword s ex)
	(let loop ((ex ex))
	  (let ((t (peek-token s)))
	    (if (or (and space-sensitive (ts:space? s)
			 (memv t '(#\( #\[ #\{ |'| #\")))
		    (and (number? ex)  ;; 2(...) is multiply, not call
			 (eqv? t #\()))
		ex
		(case t
		  ((#\( )   (take-token s)
		   (loop (list* 'call ex (parse-arglist s #\) ))))
		  ((#\[ )   (take-token s)
	           ; ref is syntax, so we can distinguish
	           ; a[i] = x  from
	           ; ref(a,i) = x
		   (loop (list* 'ref ex
				(with-end-symbol
				 (parse-arglist s #\] )))))
		  ((|.|)
		   (take-token s)
		   (if (eqv? (peek-token s) #\()
		       (loop `(|.| ,ex ,(parse-atom s)))
		       (loop `(|.| ,ex (quote ,(parse-atom s))))))
		  ((|.'| |'|) (take-token s)
		   (loop (list t ex)))
		  ((#\{ )   (take-token s)
		   (loop (list* 'curly ex (parse-arglist s #\} ))))
		  ((#\")
		   (if (and (symbol? ex) (not (operator? ex))
			    (not (ts:space? s)))
		       ;; custom prefixed string literals, x"s" =&gt; @x_str "s"
		       (let ((str (begin (take-token s)
					 (parse-string-literal s)))
			     (macname (symbol (string ex '_str))))
			 (if (and (symbol? (peek-token s)) (not (ts:space? s)))
			     ;; string literal suffix, "s"x
			     (loop `(macrocall ,macname ,(car str)
					       ,(string (take-token s))))
			     (loop `(macrocall ,macname ,(car str)))))
		       ex))
		  ((-&gt;)  (take-token s)
		   ;; -&gt; is unusual: it binds tightly on the left and
		   ;; loosely on the right.
		   (list '-&gt; ex (parse-eq* s)))
		  (else ex))))))))

;(define (parse-dot s)  (parse-LtoR s parse-atom (prec-ops 13)))

; parse expressions or blocks introduced by syntactic reserved words
(define (parse-resword s word)
  (define current-line (input-port-line (ts:port s)))
  (define (expect-end s)
    (let ((t (peek-token s)))
      (if (eq? t 'end)
	  (take-token s)
	  (error (string "incomplete: " word " at "
			 current-filename ":" current-line
			 " requires end")))))
  (with-normal-ops
  (case word
    ((begin)  (begin0 (parse-block s)
		      (expect-end s)))
    ((quote)  (begin0 (list 'quote (parse-block s))
		      (expect-end s)))
    ((while)  (begin0 (list 'while (parse-cond s) (parse-block s))
		      (expect-end s)))
    ((for)
     (let* ((ranges (parse-comma-separated-iters s))
	    (body   (parse-block s)))
       (expect-end s)
       (let nest ((r ranges))
	 (if (null? r)
	     body
	     `(for ,(car r) ,(nest (cdr r)))))))
    ((if)
     (let* ((test (parse-cond s))
	    (then (if (memq (require-token s) '(else elseif))
		      '(block)
		      (parse-block s)))
	    (nxt  (require-token s)))
       (take-token s)
       (case nxt
	 ((end)     (list 'if test then))
	 ((elseif)  (list 'if test then (parse-resword s 'if)))
	 ((else)    (list 'if test then (parse-resword s 'begin)))
	 (else      (error (string "unexpected " nxt))))))
    ((let)
     (let* ((binds (if (eqv? (peek-token s) #\newline)
		       (begin (take-token s)
			      '())
		       (parse-comma-separated-assignments s)))
	    (ex    (parse-block s)))
       (expect-end s)
       `(let ,ex ,@binds)))
    ((global local)
     (let* ((const (and (eq? (peek-token s) 'const)
			(take-token s)))
	    (expr  (cons word (parse-comma-separated-assignments s))))
       (if const
	   `(const ,expr)
	   expr)))
    ((function)
     (let* ((paren (eqv? (require-token s) #\())
	    (sig   (parse-call s))
	    (def   (if (symbol? sig)
		       (if paren
			   ;; in "function (x)" the (x) is a tuple
			   `(tuple ,sig)
			   ;; function foo  =&gt;  syntax error
			   (error "expected ( in function definition"))
		       (if (not (and (pair? sig)
				     (or (eq? (car sig) 'call)
					 (eq? (car sig) 'tuple))))
			   (error "expected ( in function definition")
			   sig)))
	    (loc   (begin (skip-ws-and-comments (ts:port s))
			  (line-number-filename-node s)))
	    (body  (parse-block s)))
       (expect-end s)
       (if (and (length&gt; body 1)
		(pair? (cadr body))
		(eq? (caadr body) 'line))
	   (set-car! (cdr body) loc))
       (list word def body)))
    ((macro)
     (let ((sig (parse-call s)))
       (begin0 (list word sig (parse-block s))
	       (expect-end s))))
    ((abstract)
     (list 'abstract (parse-ineq s)))
    ((type)
     (let ((sig (parse-ineq s)))
       (begin0 (list word sig (parse-block s))
	       (expect-end s))))
    ((bitstype)
     (list 'bitstype (parse-atom s) (parse-ineq s)))
    ((typealias)
     (let ((lhs (parse-call s)))
       (if (and (pair? lhs) (eq? (car lhs) 'call))
	   ;; typealias X (...) is tuple type alias, not call
	   (list 'typealias (cadr lhs) (cons 'tuple (cddr lhs)))
	   (list 'typealias lhs (parse-arrow s)))))
    ((try)
     (let* ((try-block (if (eq? (require-token s) 'catch)
			   '(block)
			   (parse-block s)))
	    (nxt       (require-token s)))
       (take-token s)
       (case nxt
	 ((end)   (list 'try try-block #f '(block)))
	 ((catch) (let* ((var
			  (if (eqv? (peek-token s) #\newline)
			      #f
			      (parse-atom s)))
			 (catch-block (parse-block s)))
		    (expect-end s)
		    (list 'try try-block var catch-block)))
	 (else    (error (string "unexpected " nxt))))))
    ((return)          (let ((t (peek-token s)))
			 (if (or (eqv? t #\newline) (closing-token? t))
			     (list 'return '(null))
			     (list 'return (parse-eq s)))))
    ((break continue)  (list word))
    ((const)
     (let ((assgn (parse-eq s)))
       (if (not (and (pair? assgn)
		     (or (eq? (car assgn) '=)
			 (eq? (car assgn) 'global)
			 (eq? (car assgn) 'local))))
	   (error "expected assignment after const")
	   `(const ,assgn))))
    ((module)
     (let ((name (parse-atom s)))
       (if (not (symbol? name))
	   (error (string "invalid module name " name)))
       (begin0 (list word name (parse-block s))
	       (expect-end s))))
    ((ccall)
     (if (not (eqv? (peek-token s) #\())
	 (error "expected ( after ccall"))
     (take-token s)
     (let ((al (parse-arglist s #\) )))
       (if (not (and (pair? (caddr al)) (eq? (caaddr al) 'tuple)))
	   (error "ccall argument types must be a tuple; try (T,)"))
       (cons 'ccall al)))
    (else (error "unhandled reserved word")))))

; parse comma-separated assignments, like "i=1:n,j=1:m,..."
(define (parse-comma-separated-assignments s)
  (let loop ((ranges '()))
    (let ((r (parse-eq* s)))
      (case (peek-token s)
	((#\,)  (take-token s) (loop (cons r ranges)))
	(else   (reverse! (cons r ranges)))))))

; as above, but allows both "i=r" and "i in r"
(define (parse-comma-separated-iters s)
  (let loop ((ranges '()))
    (let ((r (parse-eq* s)))
      (let ((r (cond ((and (pair? r) (eq? (car r) '=))
		      r)
		     ((eq? r ':)
		      r)
		     ((eq? (peek-token s) 'in)
		      (begin (take-token s)
			     `(= ,r ,(parse-eq* s))))
		     (else
		      (error "invalid iteration specification")))))
	(case (peek-token s)
	  ((#\,)  (take-token s) (loop (cons r ranges)))
	  (else   (reverse! (cons r ranges))))))))

(define (parse-space-separated-exprs s)
  (let ((inside-vec space-sensitive))
    (with-space-sensitive
     (let loop ((exprs '()))
       (if (or (closing-token? (peek-token s))
	       (newline? (peek-token s))
	       (and inside-vec (eq? (peek-token s) '|\||)))
	   (reverse! exprs)
	   (let ((e (parse-eq s)))
	     (case (peek-token s)
	       ((#\newline)   (reverse! (cons e exprs)))
	       (else          (loop (cons e exprs))))))))))

; handle function call argument list, or any comma-delimited list.
; . an extra comma at the end is allowed
; . expressions after a ; are enclosed in (parameters ...)
; . an expression followed by ... becomes (... x)
(define (parse-arglist s closer)
  (with-normal-ops (parse-arglist- s closer)))
(define (parse-arglist- s closer)
  (let loop ((lst '()))
    (let ((t (require-token s)))
      (if (equal? t closer)
	  (begin (take-token s)
		 (reverse lst))
	  (if (equal? t #\;)
	      (begin (take-token s)
		     (if (equal? (peek-token s) closer)
			 ;; allow f(a, b; )
			 (begin (take-token s)
				(reverse lst))
			 (reverse (cons (cons 'parameters (loop '()))
					lst))))
	      (let* ((nxt (parse-eq* s))
		     (c (require-token s)))
		(if (assignment? nxt)
		    (error "assignment in function calls not allowed"))
		(cond ((eqv? c #\,)
		       (begin (take-token s) (loop (cons nxt lst))))
		      ((eqv? c #\;)          (loop (cons nxt lst)))
		      ((equal? c closer)     (loop (cons nxt lst)))
		      ;; newline character isn't detectable here
		      #;((eqv? c #\newline)
		       (error "unexpected line break in argument list"))
		      ((memv c '(#\] #\}))
		       (error (string "unexpected " c
				      " in argument list")))
		      (else
		       (error "missing comma or ) in argument list")))))))))

; parse [] concatenation expressions and {} cell expressions
(define (parse-vcat s first closer)
  (let loop ((lst '())
	     (nxt first))
    (let ((t (require-token s)))
      (if (eqv? t closer)
	  (begin (take-token s)
		 (cons 'vcat (reverse (cons nxt lst))))
	  (case t
	    ((#\,)
	     (take-token s)
	     (if (eqv? (require-token s) closer)
		 ;; allow ending with ,
		 (begin (take-token s)
			(cons 'vcat (reverse (cons nxt lst))))
		 (loop (cons nxt lst) (parse-eq* s))))
	    ((#\;)
	     (error "unexpected semicolon in array expression"))
	    ((#\] #\})
	     (error (string "unexpected " t)))
	    (else
	     (error "missing separator in array expression")))))))

(define (cat-to-hvcat closer e)
  (if (and
       (eqv? closer #\])
       (eq? (car e) 'vcat)
       (any (lambda (x) (and (pair? x) (eq? (car x) 'hcat))) (cdr e)))
      ;; convert nested hcat inside vcat to hvcat
      (let ((rows (map (lambda (x)
			 (if (and (pair? x) (eq? (car x) 'hcat))
			     (cdr x)
			     (list x)))
		       (cdr e))))
	`(call (top hvcat)
	       (tuple ,@(map length rows))
	       ,@(apply nconc rows)))
      e))

(define (parse-matrix s first closer)
  (define (fix head v) (cons head (reverse v)))
  (define (update-outer v outer)
    (cond ((null? v)       outer)
	  ((null? (cdr v)) (cons (car v) outer))
	  (else            (cons (fix 'hcat v) outer))))
  (let loop ((vec   (list first))
	     (outer '()))
    (let ((t  (if (eqv? (peek-token s) #\newline)
		  #\newline
		  (require-token s))))
      (if (eqv? t closer)
	  (begin (take-token s)
		 (cat-to-hvcat
		  closer
		  (if (pair? outer)
		      (fix 'vcat (update-outer vec outer))
		      (if (or (null? vec) (null? (cdr vec)))
			  (fix 'vcat vec)     ; [x]   =&gt; (vcat x)
			  (fix 'hcat vec))))) ; [x y] =&gt; (hcat x y)
	  (case t
	    ((#\; #\newline)
	     (take-token s) (loop '() (update-outer vec outer)))
	    ((#\,)
	     (error "unexpected comma in matrix expression"))
	    ((#\] #\})
	     (error (string "unexpected " t)))
	    (else
	     (loop (cons (parse-eq* s) vec) outer)))))))

(define (parse-cat s closer)
  (with-normal-ops
   (with-space-sensitive
    (parse-cat- s closer))))
(define (parse-cat- s closer)
  (if (eqv? (require-token s) closer)
      (begin (take-token s)
	     (list 'vcat))  ; [] =&gt; (vcat)
      (let ((first (without-bitor (parse-eq* s))))
	(case (peek-token s)
	  ;; dispatch to array syntax, comprehension, or matrix syntax
	  ((#\,)
	   (parse-vcat s first closer))
	  ((|\||)
	   (take-token s)
	   (let ((r (parse-comma-separated-iters s)))
	     (if (not (eqv? (require-token s) closer))
		 (error (string "expected " closer))
		 (take-token s))
	     `(comprehension ,first ,@r)))
	  (else
	   (parse-matrix s first closer))))))

; for sequenced evaluation inside expressions: e.g. (a;b, c;d)
(define (parse-stmts-within-expr s)
  (parse-Nary s parse-eq* #\; 'block '(#\, #\) ) #t))

(define (parse-tuple s first)
  (let loop ((lst '())
	     (nxt first))
    (if (assignment? nxt)
	(error "invalid syntax in tuple"))
    (let ((t (require-token s)))
      (case t
	((#\))
	 (take-token s)
	 (cons 'tuple (reverse (cons nxt lst))))
	((#\,)
	 (take-token s)
	 (if (eqv? (require-token s) #\))
	     ;; allow ending with ,
	     (begin (take-token s)
		    (cons 'tuple (reverse (cons nxt lst))))
	     (loop (cons nxt lst) (parse-eq* s))))
	((#\;)
	 (error "unexpected semicolon in tuple"))
	#;((#\newline)
	 (error "unexpected line break in tuple"))
	((#\] #\})
	 (error (string "unexpected " t " in tuple")))
	(else
	 (error "missing separator in tuple"))))))

(define (not-eof-2 c)
  (if (eof-object? c)
      (error "incomplete: invalid ` syntax")
      c))

(define (parse-backquote s)
  (let ((b (open-output-string))
	(p (ts:port s)))
    (let loop ((c (read-char p)))
      (if (eqv? c #\`)
	  #t
	  (begin (if (eqv? c #\\)
		     (let ((nextch (read-char p)))
		       (if (eqv? nextch #\`)
			   (write-char nextch b)
			   (begin (write-char #\\ b)
				  (write-char (not-eof-2 nextch) b))))
		     (write-char (not-eof-2 c) b))
		 (loop (read-char p)))))
    (let ((str (io.tostring! b)))
      `(macrocall cmd ,str))))

(define (not-eof-3 c)
  (if (eof-object? c)
      (error "incomplete: invalid string syntax")
      c))

; reads a raw string literal with no processing.
; quote can be escaped with \, but the \ is left in place.
; returns ("str" . b), b is a boolean telling whether interpolation is used
(define (parse-string-literal s)
  (let ((b (open-output-string))
	(p (ts:port s))
	(interpolate #f))
    (let loop ((c (read-char p)))
      (if (eqv? c #\")
	  #t
	  (begin (if (eqv? c #\\)
		     (let ((nextch (read-char p)))
		       (begin (write-char #\\ b)
			      (write-char (not-eof-3 nextch) b)))
		     (begin
		       (if (eqv? c #\$)
			   (set! interpolate #t))
		       (write-char (not-eof-3 c) b)))
		 (loop (read-char p)))))
    (cons (io.tostring! b) interpolate)))

(define (not-eof-1 c)
  (if (eof-object? c)
      (error "incomplete: invalid character literal")
      c))

(define (unescape-string s)
  (with-exception-catcher
   (lambda (e) (error "invalid escape sequence"))
   (lambda ()
     ;; process escape sequences using lisp read
     (read (open-input-string (string #\" s #\"))))))

; parse numbers, identifiers, parenthesized expressions, lists, vectors, etc.
(define (parse-atom s)
  (let ((t (require-token s)))
    (cond ((or (string? t) (number? t)) (take-token s))

	  ;; char literal
	  ((eq? t '|'|)
	   (take-token s)
	   (let ((firstch (read-char (ts:port s))))
	     (if (eqv? firstch #\')
	      (error "invalid character literal")
	      (if (and (not (eqv? firstch #\\))
		       (not (eof-object? firstch))
		       (eqv? (peek-char (ts:port s)) #\'))
	       ;; easy case: 1 character, no \
	       (begin (read-char (ts:port s)) firstch)
	       (let ((b (open-output-string)))
		 (let loop ((c firstch))
		   (if (eqv? c #\')
		       #t
		       (begin (write-char (not-eof-1 c) b)
			      (if (eqv? c #\\)
				  (write-char
				   (not-eof-1 (read-char (ts:port s))) b))
			      (loop (read-char (ts:port s))))))
		 (let ((str (unescape-string (io.tostring! b))))
		   (if (= (length str) 1)
		       ;; one byte, e.g. '\xff'. maybe not valid UTF-8, but we
		       ;; want to use the raw value as a codepoint in this case.
		       (wchar (aref str 0))
		       (if (or (not (= (string-length str) 1))
			       (not (string.isutf8 str)))
			   (error "invalid character literal")
			   (string.char str 0)))))))))

	  ;; symbol/expression quote
	  ((eq? t ':)
	   (take-token s)
	   (if (closing-token? (peek-token s))
	       ':
	       (let ((ex (parse-atom s)))
		 (list 'quote ex))))

	  ;; identifier
	  ((symbol? t) (take-token s))

	  ;; parens or tuple
	  ((eqv? t #\( )
	   (take-token s)
	   (with-normal-ops
	   (if (eqv? (require-token s) #\) )
	       ;; empty tuple ()
	       (begin (take-token s) '(tuple))
	       ;; here we parse the first subexpression separately, so
	       ;; we can look for a comma to see if it's a tuple. this lets us
	       ;; distinguish (x) from (x,)
	       (let* ((ex (parse-eq* s))
		      (t (require-token s)))
		 (cond ((eqv? t #\) )
			(take-token s)
			;; value in parentheses (x)
			(if (and (pair? ex) (eq? (car ex) '...))
			    `(tuple ,ex)
			    ex))
		       ((eqv? t #\, )
			;; tuple (x,) (x,y) (x...) etc.
			(parse-tuple s ex))
		       ((eqv? t #\;)
			;; parenthesized block (a;b;c)
			(take-token s)
			(let* ((blk (parse-stmts-within-expr s))
			       (tok (require-token s)))
			  (if (eqv? tok #\,)
			      (error "unexpected comma in statement block"))
			  (if (not (eqv? tok #\)))
			      (error "missing separator in statement block"))
			  (take-token s)
			  `(block ,ex ,blk)))
		       #;((eqv? t #\newline)
			(error "unexpected line break in tuple"))
		       ((memv t '(#\] #\}))
			(error (string "unexpected " t " in tuple")))
		       (else
			(error "missing separator in tuple")))))))

	  ;; cell expression
	  ((eqv? t #\{ )
	   (take-token s)
	   (if (eqv? (require-token s) #\})
	       (begin (take-token s) '(cell1d))
	       (let ((vex (parse-cat s #\})))
		 (cond ((eq? (car vex) 'comprehension)
			(cons 'cell-comprehension (cdr vex)))
		       ((eq? (car vex) 'hcat)
			`(cell2d 1 ,(length (cdr vex)) ,@(cdr vex)))
		       (else  ; (vcat ...)
			(if (and (pair? (cadr vex)) (eq? (caadr vex) 'hcat))
			    (let ((nr (length (cdr vex)))
				  (nc (length (cdadr vex))))
			      ;; make sure all rows are the same length
			      (if (not (every
					(lambda (x)
					  (and (pair? x)
					       (eq? (car x) 'hcat)
					       (length= (cdr x) nc)))
					(cddr vex)))
				  (error "inconsistent shape in cell expression"))
			      `(cell2d ,nr ,nc
				       ,@(apply append
						;; transpose to storage order
						(apply map list
						       (map cdr (cdr vex))))))
			    (if (any (lambda (x) (and (pair? x)
						      (eq? (car x) 'hcat)))
				     (cddr vex))
				(error "inconsistent shape in cell expression")
				`(cell1d ,@(cdr vex)))))))))

	  ;; cat expression
	  ((eqv? t #\[ )
	   (take-token s)
	   (parse-cat s #\]))

	  ;; string literal
	  ((eqv? t #\")
	   (take-token s)
	   (let ((ps (parse-string-literal s)))
	     (if (cdr ps)
		 `(macrocall str ,(car ps))
		 (let ((str (unescape-string (car ps))))
		   (if (not (string.isutf8 str))
		       (error "invalid UTF-8 sequence"))
		   str))))

	  ;; macro call
	  ((eqv? t #\@)
	   (take-token s)
	   (let ((head (parse-atom s)))
	     (if (not (symbol? head))
		 (error (string "invalid macro use @" head)))
	     `(macrocall ,head ,@(parse-space-separated-exprs s))))

	  ;; command syntax
	  ((eqv? t #\`)
	   (take-token s)
	   (parse-backquote s))

	  (else (take-token s)))))

; --- main entry point ---

; can optionally specify which grammar production to parse.
; default is parse-stmts.
(define (julia-parse s . production)
  (cond ((string? s)
	 (apply julia-parse (make-token-stream (open-input-string s))
		production))
	((port? s)
	 (apply julia-parse (make-token-stream s) production))
	((eof-object? s)
	 s)
	(else
	 ; as a special case, allow early end of input if there is
	 ; nothing left but whitespace
	 (skip-ws-and-comments (ts:port s))
	 (if (eqv? (peek-token s) #\newline) (take-token s))
	 (let ((t (peek-token s)))
	   (if (eof-object? t)
	       t
	       ((if (null? production) parse-stmts (car production))
		s))))))

(define (check-end-of-input s)
  (skip-ws-and-comments (ts:port s))
  (if (eqv? (peek-token s) #\newline) (take-token s))
  (if (not (eof-object? (peek-token s)))
      (error (string "extra input after end of expression: "
		     (peek-token s)))))

(define (julia-parse-stream filename stream)
  (set! current-filename (symbol filename))
  (let ((s (make-token-stream stream)))
    (with-exception-catcher
     (lambda (e)
       (if (and (pair? e) (eq? (car e) 'error))
	   (let ((msg (cadr e)))
	     (raise `(error ,(string msg " at " filename ":" 
				     (input-port-line (ts:port s))))))
	   (raise e)))
     (lambda ()
       (skip-ws-and-comments (ts:port s))
       (let ((linen (input-port-line (ts:port s))))
	 (let loop ((lines '())
		    (linen linen)
		    (curr  (julia-parse s)))
	   (if (eof-object? curr)
	       (reverse lines)
	       (begin
		 (skip-ws-and-comments (ts:port s))
		 (let ((nl (input-port-line (ts:port s))))
		   (loop (list* curr `(line ,linen) lines)
			 nl
			 (julia-parse s)))))))))))
</t>
<t tx="ekr.20120404123906.7299">; tree regular expression pattern matching
; by Jeff Bezanson

; list of special pattern symbols that cannot be variable names
(define metasymbols '(_ ...))

; expression tree pattern matching
; matches expr against pattern p and returns an assoc list
;    ((var . expr) (var . expr) ...)
; mapping variables to captured subexpressions, or #f if no match.
; when a match succeeds, __ is always bound to the whole matched expression.
;
; p is an expression in the following pattern language:
;
; _       match anything, not captured
; &lt;func&gt;  any scheme function; matches if (func expr) returns #t
; &lt;var&gt;   match anything and capture as &lt;var&gt;.
;         future occurrences of &lt;var&gt; in the pattern must match the same thing.
; (head &lt;p1&gt; &lt;p2&gt; etc)   match an s-expr with 'head' matched literally,
;                        and the rest of the subpatterns matched recursively.
; (-/ &lt;ex&gt;)  match &lt;ex&gt; literally
; (-^ &lt;p&gt;)   complement of pattern &lt;p&gt;
; (-- &lt;var&gt; &lt;p&gt;)  match &lt;p&gt; and capture as &lt;var&gt; if match succeeds
; (-s)       match any symbol
; (&lt;pat...&gt; . &lt;var&gt;) match prefix and bind tail to &lt;var&gt;
;
; regular match constructs:
; ...                 match any number of anything
; (-$ &lt;p1&gt; &lt;p2&gt; etc)  match any of subpatterns &lt;p1&gt;, &lt;p2&gt;, etc
; (-* &lt;p&gt;)            match any number of &lt;p&gt;
; (-? &lt;p&gt;)            match 0 or 1 of &lt;p&gt;
; (-+ &lt;p&gt;)            match at least 1 of &lt;p&gt;
; all of these can be wrapped in (-- var   ) for capturing purposes
; This is NP-complete. Be careful.
;
(define (match- p expr state)
  (cond ((symbol? p)
	 (cond ((eq? p '_) state)
	       (else
		(let ((capt (assq p state)))
		  (if capt
		      (and (equal? expr (cdr capt)) state)
		      (cons (cons p expr) state))))))
	
	((procedure? p)
	 (and (p expr) state))
	
	((pair? p)
	 (cond ((eq? (car p) '-/)
		(and (equal? (cadr p) expr)             state))
	       ((eq? (car p) '-^)
		(and (not (match- (cadr p) expr state)) state))
	       ((eq? (car p) '--)
		(and (match- (caddr p) expr state)
		     (cons (cons (cadr p) expr) state)))
	       ((eq? (car p) '-$)  ; greedy alternation for toplevel pattern
		(match-alt (cdr p) '() (list expr) state #f 1))
	       ((eq? (car p) '-s)
		(and (symbol? expr) state))
	       (else
		(and (pair? expr)
		     (equal? (car p) (car expr))
		     (match-seq (cdr p) (cdr expr) state (length
							  (cdr expr)))))))
	
	(else
	 (and (equal? p expr) state))))

; match an alternation
(define (match-alt alt prest expr state var L)
  (if (null? alt) #f  ; no alternatives left
      (let ((subma (match- (car alt) (car expr) state)))
	(or (and subma
		 (match-seq prest (cdr expr)
			    (if var
				(cons (cons var (car expr))
				      subma)
				subma)
			    (- L 1)))
	    (match-alt (cdr alt) prest expr state var L)))))

; match generalized kleene star (try consuming min to max)
(define (match-star- p prest expr state var min max L sofar)
  (cond ; case 0: impossible to match
   ((&gt; min max) #f)
   ; case 1: only allowed to match 0 subexpressions
   ((= max 0) (match-seq prest expr
                         (if var (cons (cons var (reverse sofar)) state)
			     state)
                         L))
   ; case 2: must match at least 1
   ((&gt; min 0)
    (let ((subma (match- p (car expr) state)))
      (and subma
	   (match-star- p prest (cdr expr) subma var (- min 1) (- max 1) (- L 1)
			(cons (car expr) sofar)))))
   ; otherwise, must match either 0 or between 1 and max subexpressions
   (else
    (or (match-star- p prest expr state var 0 0   L sofar)
        (match-star- p prest expr state var 1 max L sofar)))))
(define (match-star p prest expr state var min max L) 
  (match-star- p prest expr state var min max L '()))

; match sequences of expressions
(define (match-seq p expr state L)
  (cond ((not state) #f)
	((symbol? p) (cons (cons p expr) state))
	((null? p) (if (null? expr) state #f))
	(else
	 (let ((subp (car p))
	       (var  #f))
	   (if (and (pair? subp)
		    (eq? (car subp) '--))
	       (begin (set! var (cadr subp))
                      (set! subp (caddr subp)))
	       #f)
	   (let ((head (if (pair? subp) (car subp) '())))
	     (cond ((eq? subp '...)
		    (match-star '_ (cdr p) expr state var 0 L L))
		   ((eq? head '-*)
		    (match-star (cadr subp) (cdr p) expr state var 0 L L))
		   ((eq? head '-+)
		    (match-star (cadr subp) (cdr p) expr state var 1 L L))
		   ((eq? head '-?)
		    (match-star (cadr subp) (cdr p) expr state var 0 1 L))
		   ((eq? head '-$)
		    (match-alt (cdr subp) (cdr p) expr state var L))
		   (else
		    (and (pair? expr)
			 (match-seq (cdr p) (cdr expr)
				    (match- (car p) (car expr) state)
				    (- L 1))))))))))

(define (match p expr) (match- p expr (list (cons '__ expr))))

; try to transform expr using a pattern-lambda from plist
; returns the new expression, or expr if no matches
(define (apply-patterns plist expr)
  (cond ((vector? plist)
	 (if (pair? expr)
	     (let* ((relevant (table-ref (vector-ref plist 1) (car expr) '()))
		    (enew     (apply-patterns relevant expr)))
	       (if (eq? enew expr)
		   (apply-patterns (vector-ref plist 2) expr)
		   enew))
	     (apply-patterns (vector-ref plist 2) expr)))
        ((null? plist) expr)
	(else
	 (let ((enew ((car plist) expr)))
	   (if (not enew)
	       (apply-patterns (cdr plist) expr)
	       enew)))))

; top-down fixed-point macroexpansion. this is a typical algorithm,
; but it may leave some structure that matches a pattern unexpanded.
; the advantage is that non-terminating cases cannot arise as a result
; of expression composition. in other words, if the outer loop terminates
; on all inputs for a given set of patterns, then the whole algorithm
; terminates. pattern sets that violate this should be easier to detect,
; for example
; (pattern-lambda (/ 2 3) '(/ 3 2)), (pattern-lambda (/ 3 2) '(/ 2 3))
(define (pattern-expand plist expr)
  (if (or (not (pair? expr)) (eq? (car expr) 'quote))
      expr
      (let ((enew (apply-patterns plist expr)))
	(if (eq? enew expr)
            ; expr didn't change; move to subexpressions
	    (map (lambda (subex)
		   (if (not (pair? subex))
		       subex
		       (pattern-expand plist subex)))
		 expr)
	    ; expr changed; iterate
	    (pattern-expand plist enew)))))

;; finds and replaces pattern matches with their expansions
;; one pass, does not expand recursively
(define (pattern-replace plist expr)
  (if (or (not (pair? expr)) (eq? (car expr) 'quote))
      expr
      (let ((enew (apply-patterns plist expr)))
	(if (eq? enew expr)
            ;; expr didn't change; move to subexpressions
	    (map (lambda (subex)
		   (if (not (pair? subex))
		       subex
		       (pattern-replace plist subex)))
		 expr)
	    enew))))

(define-macro (pattern-set . pats)
  ; (pattern-lambda (x ...) ...) =&gt; x
  (define (pl-head p) (car (cadr p)))
  (receive
   (pls others) (separate (lambda (x)
			    (and (pair? x) (length= x 3)
				 (eq? (car x) 'pattern-lambda)
				 (pair? (cadr x))))
			  pats)
   (let ((heads (delete-duplicates (map pl-head pls)))
	 (ht    (gensym)))
     `(let ((,ht (make-table)))
	,@(map (lambda (h)
		 `(table-set! ,ht ',h (list
				       ,@(filter (lambda (p)
						   (eq? (pl-head p) h))
						 pls))))
	       heads)
	(vector 'pattern-set ,ht (list ,@others))))))

(define (plambda-expansion pat expr expander args)
  (let ((m (match pat expr)))
    (if m
	(apply expander (map (lambda (var) (cdr (or (assq var m) '(0 . #f))))
			     args))
	#f)))

(define-macro (pattern-lambda pat body)
  ; given a pattern p, return the list of capturing variables it uses
  (define (patargs- p)
    (cond ((and (symbol? p)
		(not (memq p '(_ ...))))
	   (list p))
	  
	  ((pair? p)
	   (if (eq? (car p) '-/)
	       '()
	       (unique (apply append (map patargs- (to-proper (cdr p)))))))
	  
	  (else '())))
  (define (patargs p)
    (cons '__ (patargs- p)))
  (let* ((args (patargs pat))
         (expander `(lambda ,args ,body)))
    `(lambda (__ex__)
       (plambda-expansion ',pat __ex__ ,expander ',args))))
</t>
<t tx="ekr.20120404123906.7300">(load "jlfrontend.scm")
(make-system-image "julia_flisp.boot")
</t>
<t tx="ekr.20120404123906.7301"></t>
<t tx="ekr.20120404123906.7302">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7303">// --- the ccall intrinsic ---

static Function *value_to_pointer_func;

// TODO: per-thread
static char *temp_arg_area;
static const uint32_t arg_area_sz = 4196;
static uint32_t arg_area_loc;
#define N_TEMP_ARG_BLOCKS 1024
static void *temp_arg_blocks[N_TEMP_ARG_BLOCKS];
static uint32_t arg_block_n = 0;
static Function *save_arg_area_loc_func;
static Function *restore_arg_area_loc_func;

</t>
<t tx="ekr.20120404123906.7304">static uint64_t save_arg_area_loc()
{
    return (((uint64_t)arg_block_n)&lt;&lt;32) | ((uint64_t)arg_area_loc);
}
</t>
<t tx="ekr.20120404123906.7305">
static void restore_arg_area_loc(uint64_t l)
{
    arg_area_loc = l&amp;0xffffffff;
    uint32_t ab = l&gt;&gt;32;
    while (arg_block_n &gt; ab) {
        arg_block_n--;
        free(temp_arg_blocks[arg_block_n]);
    }
}
</t>
<t tx="ekr.20120404123906.7306">
static void *alloc_temp_arg_space(uint32_t sz)
{
    void *p;
    if (arg_area_loc+sz &gt; arg_area_sz) {
#ifdef JL_GC_MARKSWEEP
        if (arg_block_n &gt;= N_TEMP_ARG_BLOCKS)
            jl_error("ccall: out of temporary argument space");
        p = malloc(sz);
        temp_arg_blocks[arg_block_n++] = p;
#else
        p = allocb(sz);
#endif
    }
    else {
        p = &amp;temp_arg_area[arg_area_loc];
        arg_area_loc += sz;
    }
    return p;
}
</t>
<t tx="ekr.20120404123906.7307">
static void *alloc_temp_arg_copy(void *obj, uint32_t sz)
{
    void *p = alloc_temp_arg_space(sz);
    memcpy(p, obj, sz);
    return p;
}
</t>
<t tx="ekr.20120404123906.7308">
// this is a run-time function
// warning: cannot allocate memory except using alloc_temp_arg_space
</t>
<t tx="ekr.20120404123906.7309">extern "C" void *jl_value_to_pointer(jl_value_t *jt, jl_value_t *v, int argn)
{
    if ((jl_value_t*)jl_typeof(v) == jt) {
        assert(jl_is_bits_type(jt));
        size_t osz = jl_bitstype_nbits(jt)/8;
        return alloc_temp_arg_copy(jl_bits_data(v), osz);
    }
    if (((jl_value_t*)jl_uint8_type == jt ||
         (jl_value_t*)jl_int8_type == jt) &amp;&amp; jl_is_byte_string(v)) {
        return jl_string_data(v);
    }
    if (jl_is_array(v)) {
        if (jl_tparam0(jl_typeof(v)) == jt || jt==(jl_value_t*)jl_bottom_type)
            return ((jl_array_t*)v)-&gt;data;
        if (jl_is_cpointer_type(jt)) {
            jl_array_t *ar = (jl_array_t*)v;
            void **temp=(void**)alloc_temp_arg_space(ar-&gt;length*sizeof(void*));
            size_t i;
            for(i=0; i &lt; ar-&gt;length; i++) {
                temp[i] = jl_value_to_pointer(jl_tparam0(jt),
                                              jl_arrayref(ar, i), argn);
            }
            return temp;
        }
    }
    std::map&lt;int, std::string&gt;::iterator it = argNumberStrings.find(argn);
    if (it == argNumberStrings.end()) {
        std::stringstream msg;
        msg &lt;&lt; "argument ";
        msg &lt;&lt; argn;
        argNumberStrings[argn] = msg.str();
        it = argNumberStrings.find(argn);
    }
    jl_value_t *targ=NULL, *pty=NULL;
    JL_GC_PUSH(&amp;targ, &amp;pty);
    targ = (jl_value_t*)jl_tuple1(jt);
    pty = (jl_value_t*)jl_apply_type((jl_value_t*)jl_pointer_type,
                                     (jl_tuple_t*)targ);
    jl_type_error_rt("ccall", (*it).second.c_str(), pty, v);
    // doesn't return
    return (jl_value_t*)jl_null;
}
</t>
<t tx="ekr.20120404123906.7310">
static Value *julia_to_native(Type *ty, jl_value_t *jt, Value *jv,
                              jl_value_t *argex, bool addressOf,
                              int argn, jl_codectx_t *ctx)
{
    Type *vt = jv-&gt;getType();
    if (ty == jl_pvalue_llvmt) {
        return boxed(jv);
    }
    else if (ty == vt &amp;&amp; !addressOf) {
        return jv;
    }
    else if (vt != jl_pvalue_llvmt) {
        // argument value is unboxed
        if (addressOf) {
            if (ty-&gt;isPointerTy() &amp;&amp; ty-&gt;getContainedType(0)==vt) {
                // pass the address of an alloca'd thing, not a box
                // since those are immutable.
                Value *slot = builder.CreateAlloca(vt);
                builder.CreateStore(jv, slot);
                return builder.CreateBitCast(slot, ty);
            }
        }
        else if ((vt-&gt;isIntegerTy() &amp;&amp; ty-&gt;isIntegerTy()) ||
                 (vt-&gt;isFloatingPointTy() &amp;&amp; ty-&gt;isFloatingPointTy()) ||
                 (vt-&gt;isPointerTy() &amp;&amp; ty-&gt;isPointerTy())) {
            if (vt-&gt;getPrimitiveSizeInBits() ==
                ty-&gt;getPrimitiveSizeInBits()) {
                return builder.CreateBitCast(jv, ty);
            }
        }
        // error. box for error handling.
        jv = boxed(jv);
    }
    else if (jl_is_cpointer_type(jt) &amp;&amp; addressOf) {
        jl_value_t *aty = expr_type(argex, ctx);
        if (jl_is_array_type(aty) &amp;&amp;
            (jl_tparam0(jt) == jl_tparam0(aty) ||
             jl_tparam0(jt) == (jl_value_t*)jl_bottom_type)) {
            // array to pointer
            return builder.CreateBitCast(emit_arrayptr(jv), ty);
        }
        Value *p = builder.CreateCall3(value_to_pointer_func,
                                       literal_pointer_val(jl_tparam0(jt)), jv,
                                       ConstantInt::get(T_int32, argn));
        assert(ty-&gt;isPointerTy());
        return builder.CreateBitCast(p, ty);
    }
    // TODO: error for &amp; with non-pointer argument type
    assert(jl_is_bits_type(jt));
    std::stringstream msg;
    msg &lt;&lt; "ccall argument ";
    msg &lt;&lt; argn;
    emit_typecheck(jv, jt, msg.str(), ctx);
    Value *p = bitstype_pointer(jv);
    return builder.CreateLoad(builder.CreateBitCast(p,
                                                    PointerType::get(ty,0)),
                              false);
}
</t>
<t tx="ekr.20120404123906.7311">
// ccall(pointer, rettype, (argtypes...), args...)
</t>
<t tx="ekr.20120404123906.7312">static Value *emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)
{
    JL_NARGSV(ccall, 3);
    jl_value_t *ptr=NULL, *rt=NULL, *at=NULL;
    JL_GC_PUSH(&amp;ptr, &amp;rt, &amp;at);
    ptr = jl_interpret_toplevel_expr_in(ctx-&gt;module, args[1],
                                        &amp;jl_tupleref(ctx-&gt;sp,0),
                                        ctx-&gt;sp-&gt;length/2);
    rt  = jl_interpret_toplevel_expr_in(ctx-&gt;module, args[2],
                                        &amp;jl_tupleref(ctx-&gt;sp,0),
                                        ctx-&gt;sp-&gt;length/2);
    if (jl_is_tuple(rt)) {
        std::string msg = "in " + ctx-&gt;funcName +
            ": ccall: missing return type";
        jl_error(msg.c_str());
    }
    at  = jl_interpret_toplevel_expr_in(ctx-&gt;module, args[3],
                                        &amp;jl_tupleref(ctx-&gt;sp,0),
                                        ctx-&gt;sp-&gt;length/2);
    void *fptr;
    if (jl_is_symbol(ptr)) {
        // just symbol, default to JuliaDLHandle
        fptr = jl_dlsym(jl_dl_handle, ((jl_sym_t*)ptr)-&gt;name);
    }
    else {
        JL_TYPECHK(ccall, pointer, ptr);
        fptr = *(void**)jl_bits_data(ptr);
    }
    JL_TYPECHK(ccall, type, rt);
    JL_TYPECHK(ccall, tuple, at);
    JL_TYPECHK(ccall, type, at);
    jl_tuple_t *tt = (jl_tuple_t*)at;
    std::vector&lt;Type *&gt; fargt(0);
    std::vector&lt;Type *&gt; fargt_sig(0);
    Type *lrt = julia_type_to_llvm(rt, ctx);
    if (lrt == NULL) {
        JL_GC_POP();
        return literal_pointer_val(jl_nothing);
    }
    size_t i;
    bool haspointers = false;
    bool isVa = false;
    for(i=0; i &lt; tt-&gt;length; i++) {
        jl_value_t *tti = jl_tupleref(tt,i);
        if (jl_is_seq_type(tti)) {
            isVa = true;
            tti = jl_tparam0(tti);
        }
        Type *t = julia_type_to_llvm(tti, ctx);
        if (t == NULL) {
            JL_GC_POP();
            return literal_pointer_val(jl_nothing);
        }
        fargt.push_back(t);
        if (!isVa)
            fargt_sig.push_back(t);
    }
    if ((!isVa &amp;&amp; tt-&gt;length  != (nargs-2)/2) ||
        ( isVa &amp;&amp; tt-&gt;length-1 &gt; (nargs-2)/2))
        jl_error("ccall: wrong number of arguments to C function");

    // some special functions
    if (fptr == &amp;jl_array_ptr) {
        Value *ary = emit_expr(args[4], ctx, true);
        JL_GC_POP();
        return mark_julia_type(builder.CreateBitCast(emit_arrayptr(ary),T_pint8),
                               rt);
    }

    // see if there are &amp; arguments
    for(i=4; i &lt; nargs+1; i+=2) {
        jl_value_t *argi = args[i];
        if (jl_is_expr(argi) &amp;&amp; ((jl_expr_t*)argi)-&gt;head == amp_sym) {
            haspointers = true;
            break;
        }
    }

    // make LLVM function object for the target
    Function *llvmf =
        Function::Create(FunctionType::get(lrt, fargt_sig, isVa),
                         Function::ExternalLinkage,
                         "ccall_", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(llvmf, fptr);

    // save temp argument area stack pointer
    Value *saveloc=NULL;
    Value *stacksave=NULL;
    if (haspointers) {
        // TODO: inline this
        saveloc = builder.CreateCall(save_arg_area_loc_func);
        stacksave =
            builder.CreateCall(Intrinsic::getDeclaration(jl_Module,
                                                         Intrinsic::stacksave));
    }

    // emit arguments
    Value *argvals[(nargs-3)/2];
    int last_depth = ctx-&gt;argDepth;
    int nargty = tt-&gt;length;
    for(i=4; i &lt; nargs+1; i+=2) {
        int ai = (i-4)/2;
        jl_value_t *argi = args[i];
        bool addressOf = false;
        if (jl_is_expr(argi) &amp;&amp; ((jl_expr_t*)argi)-&gt;head == amp_sym) {
            addressOf = true;
            argi = jl_exprarg(argi,0);
        }
        Value *arg = emit_expr(argi, ctx, true);
        Type *largty;
        jl_value_t *jargty;
        if (isVa &amp;&amp; ai &gt;= nargty-1) {
            largty = fargt[nargty-1];
            jargty = jl_tparam0(jl_tupleref(tt,nargty-1));
        }
        else {
            largty = fargt[ai];
            jargty = jl_tupleref(tt,ai);
        }
        /*
#ifdef JL_GC_MARKSWEEP
        // make sure args are rooted
        if (largty-&gt;isPointerTy() &amp;&amp;
            (largty == jl_pvalue_llvmt ||
             !jl_is_bits_type(expr_type(args[i], ctx)))) {
            make_gcroot(boxed(arg), ctx);
        }
#endif
        */
        argvals[ai] = julia_to_native(largty, jargty, arg, argi, addressOf,
                                      ai+1, ctx);
    }
    // the actual call
    Value *result = builder.CreateCall(llvmf,
                                       ArrayRef&lt;Value*&gt;(&amp;argvals[0],(nargs-3)/2));

    // restore temp argument area stack pointer
    if (haspointers) {
        assert(saveloc != NULL);
        builder.CreateCall(restore_arg_area_loc_func, saveloc);
        assert(stacksave != NULL);
        builder.CreateCall(Intrinsic::getDeclaration(jl_Module,
                                                     Intrinsic::stackrestore),
                           stacksave);
    }
    ctx-&gt;argDepth = last_depth;

    JL_GC_POP();
    if (lrt == T_void)
        return literal_pointer_val((jl_value_t*)jl_nothing);
    return mark_julia_type(result, rt);
}
</t>
<t tx="ekr.20120404123906.7313">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7314">// utility procedures used in code generation

// --- string constants ---

static std::map&lt;const std::string, GlobalVariable*&gt; stringConstants;

</t>
<t tx="ekr.20120404123906.7315">static GlobalVariable *stringConst(const std::string &amp;txt)
{
    GlobalVariable *gv = stringConstants[txt];
    static int strno = 0;
    if (gv == NULL) {
        std::stringstream ssno;
        std::string vname;
        ssno &lt;&lt; strno;
        vname += "_j_str";
        vname += ssno.str();
        gv = new GlobalVariable(*jl_Module,
                                ArrayType::get(T_int8, txt.length()+1),
                                true,
                                GlobalVariable::ExternalLinkage,
                                ConstantArray::get(getGlobalContext(),
                                                   txt.c_str()),
                                vname);
        stringConstants[txt] = gv;
        strno++;
    }
    return gv;
}
</t>
<t tx="ekr.20120404123906.7316">
// --- emitting pointers directly into code ---

</t>
<t tx="ekr.20120404123906.7317">static Value *literal_pointer_val(void *p, Type *t)
{
#ifdef __LP64__
    return ConstantExpr::getIntToPtr(ConstantInt::get(T_int64, (uint64_t)p),
                                     t);
#else
    return ConstantExpr::getIntToPtr(ConstantInt::get(T_int32, (uint32_t)p),
                                     t);
#endif
}
</t>
<t tx="ekr.20120404123906.7318">
static Value *literal_pointer_val(jl_value_t *p)
{
    return literal_pointer_val(p, jl_pvalue_llvmt);
}
</t>
<t tx="ekr.20120404123906.7319">
static Value *literal_pointer_val(void *p)
{
    return literal_pointer_val(p, T_pint8);
}
</t>
<t tx="ekr.20120404123906.7320">
// --- generating various error checks ---

static jl_value_t *llvm_type_to_julia(Type *t, bool err=true);

</t>
<t tx="ekr.20120404123906.7321">static Value *emit_typeof(Value *p)
{
    // given p, a jl_value_t*, compute its type tag
    if (p-&gt;getType() == jl_pvalue_llvmt) {
        Value *tt = builder.CreateBitCast(p, jl_ppvalue_llvmt);
        tt = builder.
            CreateLoad(builder.CreateGEP(tt,ConstantInt::get(T_int32,0)),
                       false);
        return tt;
    }
    return literal_pointer_val(llvm_type_to_julia(p-&gt;getType()));
}
</t>
<t tx="ekr.20120404123906.7322">
static void emit_error(const std::string &amp;txt, jl_codectx_t *ctx)
{
    std::string txt2 = "in " + ctx-&gt;funcName + ": " + txt;
    Value *zeros[2] = { ConstantInt::get(T_int32, 0),
                        ConstantInt::get(T_int32, 0) };
    builder.CreateCall(jlerror_func,
                       builder.CreateGEP(stringConst(txt2),
                                         ArrayRef&lt;Value*&gt;(zeros)));
}
</t>
<t tx="ekr.20120404123906.7323">
static void error_unless(Value *cond, const std::string &amp;msg, jl_codectx_t *ctx)
{
    BasicBlock *failBB = BasicBlock::Create(getGlobalContext(),"fail",ctx-&gt;f);
    BasicBlock *passBB = BasicBlock::Create(getGlobalContext(),"pass");
    builder.CreateCondBr(cond, passBB, failBB);
    builder.SetInsertPoint(failBB);
    emit_error(msg, ctx);
    builder.CreateBr(passBB);
    ctx-&gt;f-&gt;getBasicBlockList().push_back(passBB);
    builder.SetInsertPoint(passBB);
}
</t>
<t tx="ekr.20120404123906.7324">
static void call_error_func_unless(Value *cond, Function *errfunc,
                                   jl_codectx_t *ctx)
{
    BasicBlock *failBB = BasicBlock::Create(getGlobalContext(),"fail",ctx-&gt;f);
    BasicBlock *passBB = BasicBlock::Create(getGlobalContext(),"pass");
    builder.CreateCondBr(cond, passBB, failBB);
    builder.SetInsertPoint(failBB);
    builder.CreateCall(errfunc);
    builder.CreateBr(passBB);
    ctx-&gt;f-&gt;getBasicBlockList().push_back(passBB);
    builder.SetInsertPoint(passBB);
}
</t>
<t tx="ekr.20120404123906.7325">
static void null_pointer_check(Value *v, jl_codectx_t *ctx)
{
    call_error_func_unless(builder.CreateICmpNE(v, V_null),
                           jluniniterror_func, ctx);
}
</t>
<t tx="ekr.20120404123906.7326">
static Value *boxed(Value *v);

</t>
<t tx="ekr.20120404123906.7327">static void emit_type_error(Value *x, jl_value_t *type, const std::string &amp;msg,
                            jl_codectx_t *ctx)
{
    Value *zeros[2] = { ConstantInt::get(T_int32, 0),
                        ConstantInt::get(T_int32, 0) };
    Value *fname_val = builder.CreateGEP(stringConst(ctx-&gt;funcName),
                                         ArrayRef&lt;Value*&gt;(zeros));
    Value *msg_val = builder.CreateGEP(stringConst(msg),
                                       ArrayRef&lt;Value*&gt;(zeros));
    builder.CreateCall4(jltypeerror_func,
                        fname_val, msg_val,
                        literal_pointer_val(type), boxed(x));
}
</t>
<t tx="ekr.20120404123906.7328">
static void emit_typecheck(Value *x, jl_value_t *type, const std::string &amp;msg,
                           jl_codectx_t *ctx)
{
    Value *istype =
        builder.CreateICmpEQ(emit_typeof(x), literal_pointer_val(type));
    BasicBlock *failBB = BasicBlock::Create(getGlobalContext(),"fail",ctx-&gt;f);
    BasicBlock *passBB = BasicBlock::Create(getGlobalContext(),"pass");
    builder.CreateCondBr(istype, passBB, failBB);
    builder.SetInsertPoint(failBB);

    emit_type_error(x, type, msg, ctx);

    builder.CreateBr(passBB);
    ctx-&gt;f-&gt;getBasicBlockList().push_back(passBB);
    builder.SetInsertPoint(passBB);
}
</t>
<t tx="ekr.20120404123906.7329">
static Value *emit_bounds_check(Value *i, Value *len, const std::string &amp;msg,
                                jl_codectx_t *ctx)
{
    Value *im1 = builder.CreateSub(i, ConstantInt::get(T_size, 1));
    Value *ok = builder.CreateICmpULT(im1, len);
    error_unless(ok, msg, ctx);
    return im1;
}
</t>
<t tx="ekr.20120404123906.7330">
static void emit_func_check(Value *x, jl_codectx_t *ctx)
{
    Value *xty = emit_typeof(x);
    Value *isfunc =
        builder.
        CreateOr(builder.
                 CreateICmpEQ(xty,
                              literal_pointer_val((jl_value_t*)jl_function_type)),
                 builder.
                 CreateICmpEQ(xty,
                              literal_pointer_val((jl_value_t*)jl_struct_kind)));
    BasicBlock *elseBB1 = BasicBlock::Create(getGlobalContext(),"notf", ctx-&gt;f);
    BasicBlock *mergeBB1 = BasicBlock::Create(getGlobalContext(),"isf");
    builder.CreateCondBr(isfunc, mergeBB1, elseBB1);

    builder.SetInsertPoint(elseBB1);
    emit_type_error(x, (jl_value_t*)jl_function_type, "apply", ctx);

    builder.CreateBr(mergeBB1);
    ctx-&gt;f-&gt;getBasicBlockList().push_back(mergeBB1);
    builder.SetInsertPoint(mergeBB1);
}
</t>
<t tx="ekr.20120404123906.7331">
// --- loading and storing the Nth word in an object ---

</t>
<t tx="ekr.20120404123906.7332">static Value *emit_nthptr_addr(Value *v, size_t n)
{
    return builder.CreateGEP(builder.CreateBitCast(v, jl_ppvalue_llvmt),
                             ConstantInt::get(T_int32, n));
}
</t>
<t tx="ekr.20120404123906.7333">
static Value *emit_nthptr_addr(Value *v, Value *idx)
{
    return builder.CreateGEP(builder.CreateBitCast(v, jl_ppvalue_llvmt), idx);
}
</t>
<t tx="ekr.20120404123906.7334">
static Value *emit_nthptr(Value *v, size_t n)
{
    // p = (jl_value_t**)v; p[n]
    Value *vptr = emit_nthptr_addr(v, n);
    return builder.CreateLoad(vptr, false);
}
</t>
<t tx="ekr.20120404123906.7335">
static Value *emit_nthptr(Value *v, Value *idx)
{
    // p = (jl_value_t**)v; p[n]
    Value *vptr = emit_nthptr_addr(v, idx);
    return builder.CreateLoad(vptr, false);
}
</t>
<t tx="ekr.20120404123906.7336">
// --- convert boolean value to julia ---

</t>
<t tx="ekr.20120404123906.7337">static Value *julia_bool(Value *cond)
{
    return builder.CreateSelect(cond,
                                literal_pointer_val(jl_true),
                                literal_pointer_val(jl_false));
}
</t>
<t tx="ekr.20120404123906.7338">
// --- get the inferred type of an AST node ---

</t>
<t tx="ekr.20120404123906.7339">static jl_value_t *expr_type(jl_value_t *e, jl_codectx_t *ctx)
{
    if (jl_is_expr(e))
        return ((jl_expr_t*)e)-&gt;etype;
    if (jl_is_symbolnode(e))
        return jl_symbolnode_type(e);
    if (jl_is_quotenode(e))
        return (jl_value_t*)jl_typeof(jl_fieldref(e,0));
    if (jl_is_symbol(e))
        return (jl_value_t*)jl_any_type;
    if (jl_is_lambda_info(e))
        return (jl_value_t*)jl_function_type;
    if (jl_is_topnode(e)) {
        jl_binding_t *b = jl_get_binding(ctx-&gt;module,
                                         (jl_sym_t*)jl_fieldref(e,0));
        if (!b || !b-&gt;value)
            return jl_top_type;
        if (b-&gt;constp)
            e = b-&gt;value;
        else
            return (jl_value_t*)jl_any_type;
    }
    if (jl_is_some_tag_type(e))
        return (jl_value_t*)jl_wrap_Type(e);
    return (jl_value_t*)jl_typeof(e);
}
</t>
<t tx="ekr.20120404123906.7340">
// --- accessing the representations of built-in data types ---

</t>
<t tx="ekr.20120404123906.7341">static Value *emit_tuplelen(Value *t)
{
    Value *lenbits = emit_nthptr(t, 1);
#ifdef __LP64__
    return builder.CreatePtrToInt(lenbits, T_int64);
#else
    return builder.CreatePtrToInt(lenbits, T_int32);
#endif
}
</t>
<t tx="ekr.20120404123906.7342">
// emit length of vararg tuple
</t>
<t tx="ekr.20120404123906.7343">static Value *emit_n_varargs(jl_codectx_t *ctx)
{
    int nreq = ctx-&gt;nReqArgs;
    Value *valen = builder.CreateSub((Value*)ctx-&gt;argCount,
                                     ConstantInt::get(T_int32, nreq));
#ifdef __LP64__
    return builder.CreateSExt(valen, T_int64);
#else
    return valen;
#endif
}
</t>
<t tx="ekr.20120404123906.7344">
static Value *emit_arraysize(Value *t, Value *dim)
{
#ifdef __LP64__
    int o = 3;
#else
    int o = 4;
#endif
    Value *dbits =
        emit_nthptr(t, builder.CreateAdd(dim,
                                         ConstantInt::get(dim-&gt;getType(), o)));
    return builder.CreatePtrToInt(dbits, T_size);
}
</t>
<t tx="ekr.20120404123906.7345">
static Value *emit_arraysize(Value *t, int dim)
{
    return emit_arraysize(t, ConstantInt::get(T_int32, dim));
}
</t>
<t tx="ekr.20120404123906.7346">
static Value *emit_arraylen(Value *t)
{
    Value *lenbits = emit_nthptr(t, 2);
    return builder.CreatePtrToInt(lenbits, T_size);
}
</t>
<t tx="ekr.20120404123906.7347">
static Value *emit_arrayptr(Value *t)
{
    return emit_nthptr(t, 1);
}
</t>
<t tx="ekr.20120404123906.7348">
static Value *bitstype_pointer(Value *x)
{
    return builder.CreateGEP(builder.CreateBitCast(x, jl_ppvalue_llvmt),
                             ConstantInt::get(T_int32, 1));
}
</t>
<t tx="ekr.20120404123906.7349">
// --- scheme for tagging llvm values with julia types using metadata ---

static std::map&lt;int, jl_value_t*&gt; typeIdToType;
static std::map&lt;jl_value_t*, int&gt; typeToTypeId;
static int cur_type_id = 1;

</t>
<t tx="ekr.20120404123906.7350">static int jl_type_to_typeid(jl_value_t *t)
{
    std::map&lt;jl_value_t*, int&gt;::iterator it = typeToTypeId.find(t);
    if (it == typeToTypeId.end()) {
        int mine = cur_type_id++;
        if (mine &gt; 65025)
            jl_error("unexpected error: too many bits types");
        typeToTypeId[t] = mine;
        typeIdToType[mine] = t;
        return mine;
    }
    return (*it).second;
}
</t>
<t tx="ekr.20120404123906.7351">
static jl_value_t *jl_typeid_to_type(int i)
{
    std::map&lt;int, jl_value_t*&gt;::iterator it = typeIdToType.find(i);
    if (it == typeIdToType.end()) {
        jl_error("unexpected error: invalid type id");
    }
    return (*it).second;
}
</t>
<t tx="ekr.20120404123906.7352">
static bool has_julia_type(Value *v)
{
    return ((dyn_cast&lt;Instruction&gt;(v) != NULL) &amp;&amp;
            ((Instruction*)v)-&gt;getMetadata("julia_type")!=NULL);
}
</t>
<t tx="ekr.20120404123906.7353">
static jl_value_t *julia_type_of_without_metadata(Value *v, bool err=true)
{
    if (dyn_cast&lt;AllocaInst&gt;(v) != NULL ||
        dyn_cast&lt;GetElementPtrInst&gt;(v) != NULL) {
        // an alloca always has llvm type pointer
        return llvm_type_to_julia(v-&gt;getType()-&gt;getContainedType(0), err);
    }
    return llvm_type_to_julia(v-&gt;getType(), err);
}
</t>
<t tx="ekr.20120404123906.7354">
static jl_value_t *julia_type_of(Value *v)
{
    MDNode *mdn;
    if (dyn_cast&lt;Instruction&gt;(v) == NULL ||
        (mdn = ((Instruction*)v)-&gt;getMetadata("julia_type")) == NULL) {
        return julia_type_of_without_metadata(v, true);
    }
    MDString *md = (MDString*)mdn-&gt;getOperand(0);
    const char *vts = md-&gt;getString().data();
    int id = (vts[0]-1) + (vts[1]-1)*255;
    return jl_typeid_to_type(id);
}
</t>
<t tx="ekr.20120404123906.7355">
static Value *NoOpCast(Value *v)
{
    v = CastInst::Create(Instruction::BitCast, v, v-&gt;getType());
    builder.Insert((Instruction*)v);
    return v;
}
</t>
<t tx="ekr.20120404123906.7356">
static Value *mark_julia_type(Value *v, jl_value_t *jt)
{
    if (jt == (jl_value_t*)jl_any_type)
        return v;
    if (has_julia_type(v) &amp;&amp; julia_type_of(v) == jt)
        return v;
    if (julia_type_of_without_metadata(v,false) == jt)
        return NoOpCast(v);
    if (dyn_cast&lt;Instruction&gt;(v) == NULL)
        v = NoOpCast(v);
    assert(dyn_cast&lt;Instruction&gt;(v));
    char name[3];
    int id = jl_type_to_typeid(jt);
    // store id as base-255 to avoid NUL
    name[0] = (id%255)+1;
    name[1] = (id/255)+1;
    name[2] = '\0';
    MDString *md = MDString::get(jl_LLVMContext, name);
    MDNode *mdn = MDNode::get(jl_LLVMContext, ArrayRef&lt;Value*&gt;(md));
    ((Instruction*)v)-&gt;setMetadata("julia_type", mdn);
    return v;
}
</t>
<t tx="ekr.20120404123906.7357">
static Value *mark_julia_type(Value *v, jl_bits_type_t *jt)
{
    return mark_julia_type(v, (jl_value_t*)jt);
}
</t>
<t tx="ekr.20120404123906.7358">
// --- propagate julia type from value a to b. returns b. ---

</t>
<t tx="ekr.20120404123906.7359">static Value *tpropagate(Value *a, Value *b)
{
    if (has_julia_type(a))
        return mark_julia_type(b, julia_type_of(a));
    return b;
}
</t>
<t tx="ekr.20120404123906.7360">
// --- mapping between julia and llvm types ---

</t>
<t tx="ekr.20120404123906.7361">static Type *julia_type_to_llvm(jl_value_t *jt, jl_codectx_t *ctx)
{
    if (jt == (jl_value_t*)jl_bool_type) return T_int1;
    if (jt == (jl_value_t*)jl_float32_type) return T_float32;
    if (jt == (jl_value_t*)jl_float64_type) return T_float64;
    //if (jt == (jl_value_t*)jl_null) return T_void;
    if (jl_is_bits_type(jt) &amp;&amp; jl_is_cpointer_type(jt)) {
        Type *lt = julia_type_to_llvm(jl_tparam0(jt), ctx);
        if (lt == NULL)
            return NULL;
        if (lt == T_void)
            lt = T_int8;
        return PointerType::get(lt, 0);
    }
    if (jl_is_bits_type(jt)) {
        int nb = jl_bitstype_nbits(jt);
        if (nb == 8)  return T_int8;
        if (nb == 16) return T_int16;
        if (nb == 32) return T_int32;
        if (nb == 64) return T_int64;
        else          return Type::getIntNTy(getGlobalContext(), nb);
    }
    if (jt == (jl_value_t*)jl_bottom_type) return T_void;
    //if (jt == (jl_value_t*)jl_any_type)
    //    return jl_pvalue_llvmt;
    return jl_pvalue_llvmt;
    //emit_type_error(literal_pointer_val(jt), (jl_value_t*)jl_bits_kind,
    //                "conversion to native type", ctx);
    //return NULL;
}
</t>
<t tx="ekr.20120404123906.7362">
// NOTE: llvm cannot express all julia types (for example unsigned),
// so this is an approximation. it's only correct if the associated LLVM
// value is not tagged with our value name hack.
// boxed(v) below gets the correct type.
</t>
<t tx="ekr.20120404123906.7363">static jl_value_t *llvm_type_to_julia(Type *t, bool throw_error)
{
    if (t == T_int1)  return (jl_value_t*)jl_bool_type;
    if (t == T_int8)  return (jl_value_t*)jl_int8_type;
    if (t == T_int16) return (jl_value_t*)jl_int16_type;
    if (t == T_int32) return (jl_value_t*)jl_int32_type;
    if (t == T_int64) return (jl_value_t*)jl_int64_type;
    if (t == T_float32) return (jl_value_t*)jl_float32_type;
    if (t == T_float64) return (jl_value_t*)jl_float64_type;
    if (t == T_void) return (jl_value_t*)jl_bottom_type;
    if (t == jl_pvalue_llvmt)
        return (jl_value_t*)jl_any_type;
    if (t-&gt;isPointerTy()) {
        jl_value_t *elty = llvm_type_to_julia(t-&gt;getContainedType(0),
                                              throw_error);
        if (elty != NULL) {
            return (jl_value_t*)jl_apply_type((jl_value_t*)jl_pointer_type,
                                              jl_tuple1(elty));
        }
    }
    if (throw_error) {
        jl_error("cannot convert type to a julia type");
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7364">
// --- boxing ---

// this is used to wrap values for generic contexts, where a
// dynamically-typed value is required (e.g. argument to unknown function).
// if it's already a pointer it's left alone.
</t>
<t tx="ekr.20120404123906.7365">static Value *boxed(Value *v)
{
    Type *t = v-&gt;getType();
    if (t == jl_pvalue_llvmt)
        return v;
    if (t == T_void)
        return literal_pointer_val((jl_value_t*)jl_nothing);
    if (t == T_int1) return julia_bool(v);
    jl_value_t *jt = julia_type_of(v);
    jl_bits_type_t *jb = (jl_bits_type_t*)jt;
    if (jb == jl_int8_type)
        return builder.CreateCall(box_int8_func,
                                  builder.CreateSExt(v, T_int32));
    if (jb == jl_int16_type) return builder.CreateCall(box_int16_func, v);
    if (jb == jl_int32_type) return builder.CreateCall(box_int32_func, v);
    if (jb == jl_int64_type) return builder.CreateCall(box_int64_func, v);
    if (jb == jl_float32_type) return builder.CreateCall(box_float32_func, v);
    if (jb == jl_float64_type) return builder.CreateCall(box_float64_func, v);
    if (jb == jl_uint8_type)
        return builder.CreateCall(box_uint8_func,
                                  builder.CreateZExt(v, T_int32));
    if (jb == jl_uint16_type) return builder.CreateCall(box_uint16_func, v);
    if (jb == jl_uint32_type) return builder.CreateCall(box_uint32_func, v);
    if (jb == jl_uint64_type) return builder.CreateCall(box_uint64_func, v);
    if (jb == jl_char_type)   return builder.CreateCall(box_char_func, v);
    // TODO: skip the call for constant arguments
    if (jl_is_bits_type(jt)) {
        if (v-&gt;getType()-&gt;isPointerTy()) {
            v = builder.CreatePtrToInt(v, T_size);
        }
        int nb = jl_bitstype_nbits(jt);
        if (nb == 8)
            return builder.CreateCall2(box8_func,  literal_pointer_val(jt), v);
        if (nb == 16)
            return builder.CreateCall2(box16_func, literal_pointer_val(jt), v);
        if (nb == 32)
            return builder.CreateCall2(box32_func, literal_pointer_val(jt), v);
        if (nb == 64)
            return builder.CreateCall2(box64_func, literal_pointer_val(jt), v);
        size_t sz = sizeof(void*) + (nb+7)/8;
        Value *newv = builder.CreateCall(jlallocobj_func,
                                         ConstantInt::get(T_size, sz));
        builder.CreateStore(literal_pointer_val(jt),
                            builder.CreateBitCast(newv, jl_ppvalue_llvmt));
        builder.CreateStore(v,
                            builder.CreateBitCast(bitstype_pointer(newv),
                                                  PointerType::get(t,0)));
        // TODO: make sure this is rooted. I think it is.
        return builder.CreateBitCast(newv, jl_pvalue_llvmt);
    }
    assert("Don't know how to box this type" &amp;&amp; false);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7366">@language c
@tabwidth -4
@others

/*
maybe this reads the dwarf info for a MachineFunction:

MCContext &amp;mc = Details.MF-&gt;getContext()
DenseMap&lt;const MCSection*,MCLineSection*&gt; &amp;secs = mc.getMCLineSectionOrder();
std::vector&lt;const MCSection*&gt; &amp;sec2line = mc.getMCLineSections();
MCLineSection *line = sec2line[secs[0]];
const MCLineEntryCollection *lec = line-&gt;getMCLineEntries();
MCLineEntryCollection::iterator it = lec-&gt;begin();

addr = (*it).getLabel()-&gt;getVariableValue()
line = (*it).getLine()
*/
</t>
<t tx="ekr.20120404123906.7367">#include "llvm/DerivedTypes.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/JIT.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/Intrinsics.h"
#include "llvm/PassManager.h"
#include "llvm/Analysis/Verifier.h"
#include "llvm/Analysis/DebugInfo.h"
#include "llvm/Analysis/DIBuilder.h"
#include "llvm/Target/TargetData.h"
#include "llvm/Target/TargetOptions.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Support/IRBuilder.h"
#include "llvm/Support/TargetSelect.h"
#include &lt;setjmp.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#ifdef DEBUG
#undef NDEBUG
#endif
#include &lt;cassert&gt;
using namespace llvm;

extern "C" {
#include "julia.h"
#include "builtin_proto.h"
}

#define CONDITION_REQUIRES_BOOL

// llvm state
static LLVMContext &amp;jl_LLVMContext = getGlobalContext();
</t>
<t tx="ekr.20120404123906.7368">static IRBuilder&lt;&gt; builder(getGlobalContext());
static bool nested_compile=false;
static Module *jl_Module;
static ExecutionEngine *jl_ExecutionEngine;
static DIBuilder *dbuilder;
static std::map&lt;int, std::string&gt; argNumberStrings;
static FunctionPassManager *FPM;

// types
static Type *jl_value_llvmt;
static Type *jl_pvalue_llvmt;
static Type *jl_ppvalue_llvmt;
static FunctionType *jl_func_sig;
static Type *jl_fptr_llvmt;
static Type *T_int1;
static Type *T_int8;
static Type *T_pint8;
static Type *T_uint8;
static Type *T_int16;
static Type *T_pint16;
static Type *T_uint16;
static Type *T_int32;
static Type *T_pint32;
static Type *T_uint32;
static Type *T_int64;
static Type *T_pint64;
static Type *T_uint64;
static Type *T_char;
static Type *T_size;
static Type *T_psize;
static Type *T_float32;
static Type *T_pfloat32;
static Type *T_float64;
static Type *T_pfloat64;
static Type *T_void;
#ifdef JL_GC_MARKSWEEP
static Type *T_gcframe;
#endif

// constants
static Value *V_null;

// global vars
static GlobalVariable *jltrue_var;
static GlobalVariable *jlfalse_var;
static GlobalVariable *jlnull_var;
static GlobalVariable *jlfloat32temp_var;
#ifdef JL_GC_MARKSWEEP
static GlobalVariable *jlpgcstack_var;
#endif
static GlobalVariable *jlexc_var;

// important functions
static Function *jlnew_func;
static Function *jlraise_func;
static Function *jlerror_func;
static Function *jluniniterror_func;
static Function *jldiverror_func;
static Function *jltypeerror_func;
static Function *jlcheckassign_func;
static Function *jldeclareconst_func;
static Function *jltuple_func;
static Function *jlntuple_func;
static Function *jlapplygeneric_func;
static Function *jlbox_func;
static Function *jlclosure_func;
static Function *jlmethod_func;
static Function *jlenter_func;
static Function *jlleave_func;
static Function *jlallocobj_func;
static Function *setjmp_func;
static Function *box_int8_func;
static Function *box_uint8_func;
static Function *box_int16_func;
static Function *box_uint16_func;
static Function *box_int32_func;
static Function *box_char_func;
static Function *box_uint32_func;
static Function *box_int64_func;
static Function *box_uint64_func;
static Function *box_float32_func;
static Function *box_float64_func;
static Function *box8_func;
static Function *box16_func;
static Function *box32_func;
static Function *box64_func;

/*
  stuff to fix up:
  - function/var name (un)mangling
  - experiment with llvm optimization passes, option to disable them
  - varargs and ... optimizations

  future:
  - try using fastcc to get tail calls
*/

// --- entry point ---

static void emit_function(jl_lambda_info_t *lam, Function *f);
//static int n_compile=0;
static Function *to_function(jl_lambda_info_t *li)
{
    JL_SIGATOMIC_BEGIN();
    Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage,
                                   li-&gt;name-&gt;name, jl_Module);
    assert(!li-&gt;inInference);
    li-&gt;functionObject = (void*)f;
    BasicBlock *old = nested_compile ? builder.GetInsertBlock() : NULL;
    DebugLoc olddl = builder.getCurrentDebugLocation();
    bool last_n_c = nested_compile;
    nested_compile = true;
    emit_function(li, f);
    nested_compile = last_n_c;
    FPM-&gt;run(*f);
    //n_compile++;
    // print out the function's LLVM code
    //ios_printf(ios_stderr, "%s:%d\n",
    //           ((jl_sym_t*)li-&gt;file)-&gt;name, jl_unbox_long(li-&gt;line));
    //f-&gt;dump();
    //verifyFunction(*f);
    if (old != NULL) {
        builder.SetInsertPoint(old);
        builder.SetCurrentDebugLocation(olddl);
    }
    JL_SIGATOMIC_END();
    return f;
}
</t>
<t tx="ekr.20120404123906.7369">
extern "C" void jl_generate_fptr(jl_function_t *f)
{
    // objective: assign li-&gt;fptr
    jl_lambda_info_t *li = f-&gt;linfo;
    assert(li-&gt;functionObject);
    Function *llvmf = (Function*)li-&gt;functionObject;
    if (li-&gt;fptr == &amp;jl_trampoline) {
        JL_SIGATOMIC_BEGIN();
        li-&gt;fptr = (jl_fptr_t)jl_ExecutionEngine-&gt;getPointerToFunction(llvmf);
        JL_SIGATOMIC_END();
        llvmf-&gt;deleteBody();
    }
    f-&gt;fptr = li-&gt;fptr;
}
</t>
<t tx="ekr.20120404123906.7370">
extern "C" void jl_compile(jl_function_t *f)
{
    jl_lambda_info_t *li = f-&gt;linfo;
    if (li-&gt;functionObject == NULL) {
        // objective: assign li-&gt;functionObject
        li-&gt;inCompile = 1;
        (void)to_function(li);
        li-&gt;inCompile = 0;
    }
}
</t>
<t tx="ekr.20120404123906.7371">
extern "C" void jl_delete_function(jl_lambda_info_t *li)
{
    // NOTE: this is not safe; there might be closures using this code.
    Function *llvmf = (Function*)li-&gt;functionObject;
    if (llvmf) {
        delete llvmf;
        li-&gt;functionObject = NULL;
        li-&gt;fptr = &amp;jl_trampoline;
    }
}
</t>
<t tx="ekr.20120404123906.7372">
// information about the context of a piece of code: its enclosing
// function and module, and visible local variables and labels.
typedef struct {
    Function *f;
    std::map&lt;std::string, Value*&gt; *vars;
    std::map&lt;std::string, Value*&gt; *arguments;
    std::map&lt;std::string, int&gt; *closureEnv;
    std::map&lt;std::string, bool&gt; *isAssigned;
    std::map&lt;std::string, bool&gt; *isCaptured;
    std::map&lt;std::string, bool&gt; *escapes;
    std::map&lt;std::string, jl_value_t*&gt; *declTypes;
    std::map&lt;int, BasicBlock*&gt; *labels;
    std::map&lt;int, Value*&gt; *savestates;
    std::map&lt;int, Value*&gt; *jmpbufs;
    jl_module_t *module;
    jl_expr_t *ast;
    jl_tuple_t *sp;
    jl_lambda_info_t *linfo;
    Value *envArg;
    const Argument *argArray;
    const Argument *argCount;
    AllocaInst *argTemp;
    int argDepth;
    //int maxDepth;
    int argSpace;
    std::string funcName;
    jl_sym_t *vaName;  // name of vararg argument
    bool vaStack;      // varargs stack-allocated
    int nReqArgs;
} jl_codectx_t;

static Value *emit_expr(jl_value_t *expr, jl_codectx_t *ctx, bool value);
static int is_global(jl_sym_t *s, jl_codectx_t *ctx);
static void make_gcroot(Value *v, jl_codectx_t *ctx);

// --- utilities ---

#include "cgutils.cpp"
#include "debuginfo.cpp"

// --- code gen for intrinsic functions ---

#include "intrinsics.cpp"

// --- constant determination ---

</t>
<t tx="ekr.20120404123906.7373">static bool is_constant(jl_value_t *ex, jl_codectx_t *ctx, bool sparams=true)
{
    if (jl_is_symbolnode(ex))
        ex = (jl_value_t*)jl_symbolnode_sym(ex);
    if (jl_is_symbol(ex)) {
        jl_sym_t *sym = (jl_sym_t*)ex;
        if (is_global(sym, ctx)) {
            size_t i;
            if (sparams) {
                for(i=0; i &lt; ctx-&gt;sp-&gt;length; i+=2) {
                    if (sym == (jl_sym_t*)jl_tupleref(ctx-&gt;sp, i)) {
                        // static parameter
                        return true;
                    }
                }
            }
            if (jl_is_const(ctx-&gt;module, sym))
                return true;
        }
        return false;
    }
    if (jl_is_topnode(ex)) {
        jl_binding_t *b = jl_get_binding(ctx-&gt;module,
                                         (jl_sym_t*)jl_fieldref(ex,0));
        if (b &amp;&amp; b-&gt;constp &amp;&amp; b-&gt;value)
            return true;
    }
    if (jl_is_quotenode(ex))
        return true;
    if (!jl_is_expr(ex) &amp;&amp; !jl_is_lambda_info(ex))
        return true;
    return false;
}
</t>
<t tx="ekr.20120404123906.7374">
static bool symbol_eq(jl_value_t *e, jl_sym_t *sym)
{
    return ((jl_is_symbol(e) &amp;&amp; ((jl_sym_t*)e)==sym) ||
            (jl_is_symbolnode(e) &amp;&amp; jl_symbolnode_sym(e)==sym) ||
            (jl_is_topnode(e) &amp;&amp; ((jl_sym_t*)jl_fieldref(e,0))==sym));
}
</t>
<t tx="ekr.20120404123906.7375">
// --- gc root counting ---

</t>
<t tx="ekr.20120404123906.7376">static bool expr_is_symbol(jl_value_t *e)
{
    return (jl_is_symbol(e) || jl_is_symbolnode(e) || jl_is_topnode(e));
}
</t>
<t tx="ekr.20120404123906.7377">
// some analysis. determine max needed "evaluation stack" space for
// gc-rooting function arguments.
// also a very simple, conservative escape analysis that is sufficient for
// eliding allocation of varargs tuples.
// "esc" means "in escaping context"
</t>
<t tx="ekr.20120404123906.7378">static void max_arg_depth(jl_value_t *expr, int32_t *max, int32_t *sp,
                          bool esc, jl_codectx_t *ctx)
{
    if (jl_is_expr(expr)) {
        esc = true;
        jl_expr_t *e = (jl_expr_t*)expr;
        size_t i;
        if (e-&gt;head == call_sym || e-&gt;head == call1_sym) {
            int alen = e-&gt;args-&gt;length;
            int lastsp = *sp;
            jl_value_t *f = jl_exprarg(e,0);
            if (expr_is_symbol(f)) {
                if (is_constant(f, ctx, false)) {
                    jl_value_t *fv =
                        jl_interpret_toplevel_expr_in(ctx-&gt;module, f, NULL, 0);
                    if (jl_typeis(fv, jl_intrinsic_type)) {
                        esc = false;
                        JL_I::intrinsic fi = (JL_I::intrinsic)jl_unbox_int32(fv);
                        if (fi != JL_I::ccall) {
                            // here we need space for each argument, but
                            // not for each of their results
                            for(i=1; i &lt; (size_t)alen; i++) {
                                max_arg_depth(jl_exprarg(e,i), max, sp, esc, ctx);
                            }
                            return;
                        }
                        else {
                            esc = true;
                            // first 3 arguments are static
                            for(i=4; i &lt; (size_t)alen; i++) {
                                max_arg_depth(jl_exprarg(e,i), max, sp, esc, ctx);
                            }
                            return;
                        }
                    }
                    else if (jl_is_function(fv)) {
                        jl_function_t *ff = (jl_function_t*)fv;
                        if (ff-&gt;fptr == jl_f_tuplelen ||
                            ff-&gt;fptr == jl_f_tupleref) {
                            esc = false;
                        }
                    }
                }
            }
            else if (jl_is_expr(f) || jl_is_lambda_info(f)) {
                max_arg_depth(f, max, sp, esc, ctx);
                (*sp)++;
                if (*sp &gt; *max) *max = *sp;
            }

            for(i=1; i &lt; (size_t)alen; i++) {
                max_arg_depth(jl_exprarg(e,i), max, sp, esc, ctx);
                (*sp)++;
                if (*sp &gt; *max) *max = *sp;
            }
            (*sp) = lastsp;
        }
        else if (e-&gt;head == method_sym) {
            max_arg_depth(jl_exprarg(e,1), max, sp, esc, ctx);
            (*sp)++;
            if (*sp &gt; *max) *max = *sp;
            max_arg_depth(jl_exprarg(e,2), max, sp, esc, ctx);
            (*sp)++;
            if (*sp &gt; *max) *max = *sp;
            max_arg_depth(jl_exprarg(e,3), max, sp, esc, ctx);
            (*sp)++;
            if (*sp &gt; *max) *max = *sp;
            (*sp)-=2;
        }
        else {
            for(i=0; i &lt; e-&gt;args-&gt;length; i++) {
                max_arg_depth(jl_exprarg(e,i), max, sp, esc, ctx);
            }
        }
    }
    else if (jl_is_lambda_info(expr)) {
        if (1 &gt; *max) *max = 1;
    }
    else if (jl_is_symbolnode(expr)) {
        expr = (jl_value_t*)jl_symbolnode_sym(expr);
    }
    if (jl_is_symbol(expr)) {
        char *vname = ((jl_sym_t*)expr)-&gt;name;
        if (ctx-&gt;escapes-&gt;find(vname) != ctx-&gt;escapes-&gt;end()) {
            bool did_escape = (*ctx-&gt;escapes)[vname];
            (*ctx-&gt;escapes)[vname] = did_escape || esc;
        }
    }
}
</t>
<t tx="ekr.20120404123906.7379">
static void make_gcroot(Value *v, jl_codectx_t *ctx)
{
    assert(ctx-&gt;argDepth &lt; ctx-&gt;argSpace);
    Value *froot = builder.CreateGEP(ctx-&gt;argTemp,
                                     ConstantInt::get(T_int32,
                                                      ctx-&gt;argDepth));
    builder.CreateStore(v, froot);
    ctx-&gt;argDepth++;
    //if (ctx-&gt;argDepth &gt; ctx-&gt;maxDepth)
    //    ctx-&gt;maxDepth = ctx-&gt;argDepth;
}
</t>
<t tx="ekr.20120404123906.7380">
// --- lambda ---

extern "C" jl_value_t *jl_uncompress_ast(jl_tuple_t *data);

</t>
<t tx="ekr.20120404123906.7381">static void jl_add_linfo_root(jl_lambda_info_t *li, jl_value_t *val)
{
    if (li-&gt;roots == NULL) {
        li-&gt;roots = jl_alloc_cell_1d(1);
        jl_cellset(li-&gt;roots, 0, val);
    }
    else {
        for(size_t i=0; i &lt; li-&gt;roots-&gt;length; i++) {
            if (jl_arrayref(li-&gt;roots,i) == val)
                return;
        }
        jl_cell_1d_push(li-&gt;roots, val);
    }
}
</t>
<t tx="ekr.20120404123906.7382">
static Value *emit_lambda_closure(jl_value_t *expr, jl_codectx_t *ctx)
{
    assert(jl_is_lambda_info(expr));
    size_t i;
    jl_value_t *ast = ((jl_lambda_info_t*)expr)-&gt;ast;
    jl_array_t *capt = jl_lam_capt((jl_expr_t*)ast);
    if (capt-&gt;length == 0) {
        // no captured vars; lift
        jl_value_t *fun =
            (jl_value_t*)jl_new_closure(NULL, (jl_value_t*)jl_null,
                                        (jl_lambda_info_t*)expr);
        jl_add_linfo_root(ctx-&gt;linfo, fun);
        return literal_pointer_val(fun);
    }

    Value *captured[1+capt-&gt;length];
    captured[0] = ConstantInt::get(T_size, capt-&gt;length);
    for(i=0; i &lt; capt-&gt;length; i++) {
        Value *val;
        jl_array_t *vi = (jl_array_t*)jl_cellref(capt, i);
        assert(jl_is_array(vi));
        jl_sym_t *s = (jl_sym_t*)jl_cellref(vi,0);
        assert(jl_is_symbol(s));
        std::map&lt;std::string,int&gt;::iterator it = ctx-&gt;closureEnv-&gt;find(s-&gt;name);
        if (it != ctx-&gt;closureEnv-&gt;end()) {
            int idx = (*it).second;
            val = emit_nthptr((Value*)ctx-&gt;envArg, idx+2);
        }
        else {
            Value *l = (*ctx-&gt;vars)[s-&gt;name];
            assert(l != NULL);
            val = builder.CreateLoad(l, false);
        }
        captured[i+1] = val;
    }
    Value *env_tuple;
    env_tuple = builder.CreateCall(jlntuple_func,
                                   ArrayRef&lt;Value*&gt;(&amp;captured[0],
                                                    1+capt-&gt;length));
    make_gcroot(env_tuple, ctx);
    Value *result = builder.CreateCall3(jlclosure_func,
                                        Constant::getNullValue(T_pint8),
                                        env_tuple, literal_pointer_val(expr));
    ctx-&gt;argDepth--;
    return result;
}
</t>
<t tx="ekr.20120404123906.7383">
// --- generating function calls ---

</t>
<t tx="ekr.20120404123906.7384">static jl_tuple_t *call_arg_types(jl_value_t **args, size_t n, jl_codectx_t *ctx)
{
    jl_tuple_t *t = jl_alloc_tuple(n);
    JL_GC_PUSH(&amp;t);
    size_t i;
    for(i=0; i &lt; n; i++) {
        jl_value_t *ty = expr_type(args[i], ctx);
        if (!jl_is_leaf_type(ty)) {
            t = NULL;
            break;
        }
        jl_tupleset(t, i, ty);
    }
    JL_GC_POP();
    return t;
}
</t>
<t tx="ekr.20120404123906.7385">
extern "C" jl_function_t *jl_get_specialization(jl_function_t *f, jl_tuple_t *types);

</t>
<t tx="ekr.20120404123906.7386">static Value *emit_known_call(jl_value_t *ff, jl_value_t **args, size_t nargs,
                              jl_codectx_t *ctx,
                              Value **theFptr, Value **theF,
                              jl_value_t *expr)
{
    if (jl_typeis(ff, jl_intrinsic_type)) {
        return emit_intrinsic((intrinsic)*(uint32_t*)jl_bits_data(ff),
                              args, nargs, ctx);
    }
    if (!jl_is_func(ff)) {
        return NULL;
    }
    jl_value_t *rt1=NULL, *rt2=NULL, *rt3=NULL;
    JL_GC_PUSH(&amp;rt1, &amp;rt2, &amp;rt3);
    jl_function_t *f = (jl_function_t*)ff;
    if (f-&gt;fptr == &amp;jl_apply_generic) {
        *theFptr = jlapplygeneric_func;
        *theF = literal_pointer_val((jl_value_t*)f);
        if (ctx-&gt;linfo-&gt;specTypes != NULL) {
            jl_tuple_t *aty = call_arg_types(&amp;args[1], nargs, ctx);
            rt1 = (jl_value_t*)aty;
            // attempt compile-time specialization for inferred types
            if (aty != NULL) {
                /*
                  if (trace) {
                      ios_printf(ios_stdout, "call %s%s\n",
                      jl_print_to_string(args[0]),
                      jl_print_to_string((jl_value_t*)aty));
                  }
                */
                f = jl_get_specialization(f, aty);
                if (f != NULL) {
                    assert(f-&gt;linfo-&gt;functionObject != NULL);
                    *theFptr = (Value*)f-&gt;linfo-&gt;functionObject;
                    *theF = literal_pointer_val((jl_value_t*)f);
                }
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_is &amp;&amp; nargs==2) {
        jl_value_t *rt1 = expr_type(args[1], ctx);
        jl_value_t *rt2  = expr_type(args[2], ctx);
        if (jl_is_type_type(rt1) &amp;&amp; jl_is_type_type(rt2) &amp;&amp;
            !jl_is_typevar(jl_tparam0(rt1)) &amp;&amp;
            !jl_is_typevar(jl_tparam0(rt2)) &amp;&amp;
            is_constant(args[1], ctx) &amp;&amp; is_constant(args[2], ctx)) {
            JL_GC_POP();
            if (jl_tparam0(rt1) == jl_tparam0(rt2))
                return ConstantInt::get(T_int1, 1);
            return ConstantInt::get(T_int1, 0);
        }
        JL_GC_POP();
        Value *arg1 = boxed(emit_expr(args[1], ctx, true));
        Value *arg2 = boxed(emit_expr(args[2], ctx, true));
        return builder.CreateICmpEQ(arg1, arg2);
    }
    else if (f-&gt;fptr == &amp;jl_f_typeof &amp;&amp; nargs==1) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        if (!jl_is_typevar(aty) &amp;&amp; aty != (jl_value_t*)jl_any_type &amp;&amp;
            jl_type_intersection(aty,(jl_value_t*)jl_tuple_type)==(jl_value_t*)jl_bottom_type) {
            if (jl_is_leaf_type(aty)) {
                if (jl_is_type_type(aty))
                    aty = (jl_value_t*)jl_typeof(jl_tparam0(aty));
                JL_GC_POP();
                return literal_pointer_val(aty);
            }
            Value *arg1 = boxed(emit_expr(args[1], ctx, true));
            JL_GC_POP();
            return emit_nthptr(arg1, (size_t)0);
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_typeassert &amp;&amp; nargs==2) {
        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;
        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;
        if (jl_is_type_type(ty) &amp;&amp; !jl_is_typevar(jl_tparam0(ty))) {
            jl_value_t *tp0 = jl_tparam0(ty);
            if (jl_subtype(arg, tp0, 0)) {
                JL_GC_POP();
                return emit_expr(args[1], ctx, true);
            }
            if (!jl_is_tuple(tp0) &amp;&amp; jl_is_leaf_type(tp0)) {
                Value *arg1 = emit_expr(args[1], ctx, true);
                emit_typecheck(arg1, tp0, "typeassert", ctx);
                JL_GC_POP();
                return arg1;
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_isa &amp;&amp; nargs==2) {
        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;
        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;
        if (jl_is_type_type(ty) &amp;&amp; !jl_is_typevar(jl_tparam0(ty))) {
            jl_value_t *tp0 = jl_tparam0(ty);
            if (jl_subtype(arg, tp0, 0)) {
                JL_GC_POP();
                return ConstantInt::get(T_int1,1);
            }
            if (!jl_is_tuple(tp0) &amp;&amp; jl_is_leaf_type(tp0) &amp;&amp;
                !jl_is_type_type(tp0)) {
                if (jl_is_leaf_type(arg)) {
                    JL_GC_POP();
                    return ConstantInt::get(T_int1,0);
                }
                Value *arg1 = emit_expr(args[1], ctx, true);
                JL_GC_POP();
                return builder.CreateICmpEQ(emit_typeof(arg1),
                                            literal_pointer_val(tp0));
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_tuplelen &amp;&amp; nargs==1) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        if (jl_is_tuple(aty)) {
            if (symbol_eq(args[1], ctx-&gt;vaName) &amp;&amp;
                !(*ctx-&gt;isAssigned)[ctx-&gt;vaName-&gt;name]) {
                JL_GC_POP();
                return emit_n_varargs(ctx);
            }
            else {
                Value *arg1 = emit_expr(args[1], ctx, true);
                JL_GC_POP();
                return emit_tuplelen(arg1);
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_tupleref &amp;&amp; nargs==2) {
        jl_value_t *tty = expr_type(args[1], ctx); rt1 = tty;
        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;
        if (jl_is_tuple(tty) &amp;&amp; ity==(jl_value_t*)jl_long_type) {
            if (ctx-&gt;vaStack &amp;&amp; symbol_eq(args[1], ctx-&gt;vaName)) {
                Value *valen = emit_n_varargs(ctx);
                Value *idx = emit_unbox(T_size, T_psize,
                                        emit_unboxed(args[2], ctx));
                idx = emit_bounds_check(idx, valen,
                                        "tupleref: index out of range", ctx);
                idx = builder.CreateAdd(idx, ConstantInt::get(T_size, ctx-&gt;nReqArgs));
                JL_GC_POP();
                return builder.
                    CreateLoad(builder.CreateGEP((Value*)ctx-&gt;argArray,idx),false);
            }
            Value *arg1 = emit_expr(args[1], ctx, true);
            if (jl_is_long(args[2])) {
                uint32_t idx = (uint32_t)jl_unbox_long(args[2]);
                if (idx &gt; 0 &amp;&amp;
                    (idx &lt; ((jl_tuple_t*)tty)-&gt;length ||
                     (idx == ((jl_tuple_t*)tty)-&gt;length &amp;&amp;
                      !jl_is_seq_type(jl_tupleref(tty,
                                                  ((jl_tuple_t*)tty)-&gt;length-1))))) {
                    // known to be in bounds
                    JL_GC_POP();
                    return emit_nthptr(arg1, idx+1);
                }
            }
            Value *tlen = emit_tuplelen(arg1);
            Value *idx = emit_unbox(T_size, T_psize,
                                    emit_unboxed(args[2], ctx));
            emit_bounds_check(idx, tlen,
                              "tupleref: index out of range", ctx);
            JL_GC_POP();
            return emit_nthptr(arg1,
                               builder.CreateAdd(idx, ConstantInt::get(T_size,1)));
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_tuple) {
        if (nargs == 0) {
            JL_GC_POP();
            return literal_pointer_val((jl_value_t*)jl_null);
        }
        size_t i;
        for(i=0; i &lt; nargs; i++) {
            if (!jl_is_bits_type(jl_typeof(args[i+1])))
                break;
        }
        if (i &gt;= nargs) {
            // all arguments immutable; can be statically evaluated
            rt1 = (jl_value_t*)jl_alloc_tuple_uninit(nargs);
            for(i=0; i &lt; nargs; i++) {
                jl_tupleset(rt1, i, args[i+1]);
            }
            jl_add_linfo_root(ctx-&gt;linfo, rt1);
            JL_GC_POP();
            return literal_pointer_val(rt1);
        }

        int last_depth = ctx-&gt;argDepth;
        // we only get a GC root per-argument, so we can't allocate the
        // tuple before evaluating one argument. so eval the first argument
        // first, then do hand-over-hand to track the tuple.
        Value *arg1 = boxed(emit_expr(args[1], ctx, true));
        make_gcroot(arg1, ctx);
        Value *tup =
            builder.CreateBitCast
            (builder.CreateCall(jlallocobj_func,
                                ConstantInt::get(T_size,
                                                 sizeof(void*)*(nargs+2))),
             jl_pvalue_llvmt);
        builder.CreateStore(arg1, emit_nthptr_addr(tup, 2));
        ctx-&gt;argDepth--;
        make_gcroot(tup, ctx);
        builder.CreateStore(literal_pointer_val((jl_value_t*)jl_tuple_type),
                            emit_nthptr_addr(tup, (size_t)0));
        builder.CreateStore(literal_pointer_val((jl_value_t*)nargs),
                            emit_nthptr_addr(tup, (size_t)1));
        for(i=1; i &lt; nargs; i++) {
            builder.CreateStore(V_null,
                                emit_nthptr_addr(tup, i+2));
        }
        for(i=1; i &lt; nargs; i++) {
            builder.CreateStore(boxed(emit_expr(args[i+1], ctx, true)),
                                emit_nthptr_addr(tup, i+2));
        }
        ctx-&gt;argDepth = last_depth;
        JL_GC_POP();
        return tup;
    }
    else if (f-&gt;fptr == &amp;jl_f_throw &amp;&amp; nargs==1) {
        Value *arg1 = boxed(emit_expr(args[1], ctx, true));
        JL_GC_POP();
        return builder.CreateCall(jlraise_func, arg1);
    }
    else if (f-&gt;fptr == &amp;jl_f_arraylen &amp;&amp; nargs==1) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        if (jl_is_array_type(aty)) {
            // todo: also allow e.g. Union of several array types
            Value *arg1 = emit_expr(args[1], ctx, true);
            JL_GC_POP();
            return emit_arraylen(arg1);
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_arraysize &amp;&amp; nargs==2) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;
        if (jl_is_array_type(aty) &amp;&amp; ity == (jl_value_t*)jl_long_type) {
            jl_value_t *ndp = jl_tparam1(aty);
            if (jl_is_long(ndp)) {
                Value *ary = emit_expr(args[1], ctx, true);
                size_t ndims = jl_unbox_long(ndp);
                if (jl_is_long(args[2])) {
                    uint32_t idx = (uint32_t)jl_unbox_long(args[2]);
                    if (idx &gt; 0 &amp;&amp; idx &lt;= ndims) {
                        JL_GC_POP();
                        return emit_arraysize(ary, idx);
                    }
                    else if (idx &gt; ndims) {
                        JL_GC_POP();
                        return ConstantInt::get(T_size, 1);
                    }
                }
                else {
                    Value *idx = emit_unbox(T_size, T_psize,
                                            emit_unboxed(args[2], ctx));
                    error_unless(builder.CreateICmpSGT(idx,
                                                      ConstantInt::get(T_size,0)),
                                 "arraysize: dimension out of range", ctx);
                    BasicBlock *outBB = BasicBlock::Create(getGlobalContext(),"outofrange",ctx-&gt;f);
                    BasicBlock *inBB = BasicBlock::Create(getGlobalContext(),"inrange");
                    BasicBlock *ansBB = BasicBlock::Create(getGlobalContext(),"arraysize");
                    builder.CreateCondBr(builder.CreateICmpSLE(idx,
                                                              ConstantInt::get(T_size, ndims)),
                                         inBB, outBB);
                    builder.SetInsertPoint(outBB);
                    Value *v_one = ConstantInt::get(T_size, 1);
                    builder.CreateBr(ansBB);
                    ctx-&gt;f-&gt;getBasicBlockList().push_back(inBB);
                    builder.SetInsertPoint(inBB);
                    Value *v_sz = emit_arraysize(ary, idx);
                    builder.CreateBr(ansBB);
                    ctx-&gt;f-&gt;getBasicBlockList().push_back(ansBB);
                    builder.SetInsertPoint(ansBB);
                    PHINode *result = builder.CreatePHI(T_size, 2);
                    result-&gt;addIncoming(v_one, outBB);
                    result-&gt;addIncoming(v_sz, inBB);
                    JL_GC_POP();
                    return result;
                }
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_arrayref &amp;&amp; nargs==2) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;
        if (jl_is_array_type(aty) &amp;&amp; ity == (jl_value_t*)jl_long_type) {
            jl_value_t *ety = jl_tparam0(aty);
            if (!jl_is_typevar(ety)) {
                if (!jl_is_bits_type(ety)) {
                    ety = (jl_value_t*)jl_any_type;
                }
                Value *ary = emit_expr(args[1], ctx, true);
                Type *elty = julia_type_to_llvm(ety, ctx);
                assert(elty != NULL);
                bool isbool=false;
                if (elty==T_int1) { elty = T_int8; isbool=true; }
                Value *data =
                    builder.CreateBitCast(emit_arrayptr(ary),
                                          PointerType::get(elty, 0));
                Value *alen = emit_arraylen(ary);
                Value *idx = emit_unbox(T_size, T_psize,
                                        emit_unboxed(args[2], ctx));
                Value *im1 =
                    emit_bounds_check(idx, alen,
                                      "arrayref: index out of range", ctx);
                Value *elt=builder.CreateLoad(builder.CreateGEP(data, im1),
                                              false);
                if (ety == (jl_value_t*)jl_any_type) {
                    null_pointer_check(elt, ctx);
                }
                JL_GC_POP();
                if (isbool)
                    return builder.CreateTrunc(elt, T_int1);
                return mark_julia_type(elt, ety);
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_arrayset &amp;&amp; nargs==3) {
        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;
        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;
        jl_value_t *vty = expr_type(args[3], ctx); rt3 = vty;
        if (jl_is_array_type(aty) &amp;&amp;
            ity == (jl_value_t*)jl_long_type) {
            jl_value_t *ety = jl_tparam0(aty);
            if (!jl_is_typevar(ety) &amp;&amp; jl_subtype(vty, ety, 0)) {
                if (!jl_is_bits_type(ety)) {
                    ety = (jl_value_t*)jl_any_type;
                }
                Value *ary = emit_expr(args[1], ctx, true);
                Type *elty = julia_type_to_llvm(ety, ctx);
                assert(elty != NULL);
                if (elty==T_int1) { elty = T_int8; }
                Value *data =
                    builder.CreateBitCast(emit_arrayptr(ary),
                                          PointerType::get(elty, 0));
                Value *alen = emit_arraylen(ary);
                Value *idx = emit_unbox(T_size, T_psize,
                                        emit_unboxed(args[2], ctx));
                Value *rhs;
                if (jl_is_bits_type(ety)) {
                    rhs = emit_unbox(elty, PointerType::get(elty,0),
                                     emit_unboxed(args[3], ctx));
                }
                else {
                    rhs = boxed(emit_expr(args[3], ctx, true));
                }
                Value *im1 =
                    emit_bounds_check(idx, alen,
                                      "arrayset: index out of range", ctx);
                builder.CreateStore(rhs, builder.CreateGEP(data, im1));
                JL_GC_POP();
                return ary;
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_get_field &amp;&amp; nargs==2) {
        jl_struct_type_t *sty = (jl_struct_type_t*)expr_type(args[1], ctx);
        rt1 = (jl_value_t*)sty;
        if (jl_is_struct_type(sty) &amp;&amp; jl_is_quotenode(args[2]) &amp;&amp;
            jl_is_symbol(jl_fieldref(args[2],0))) {
            size_t offs = jl_field_offset(sty,
                                          (jl_sym_t*)jl_fieldref(args[2],0));
            if (offs != (size_t)-1) {
                Value *strct = emit_expr(args[1], ctx, true);
                Value *fld = emit_nthptr(strct, offs+1);
                null_pointer_check(fld, ctx);
                JL_GC_POP();
                return fld;
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_set_field &amp;&amp; nargs==3) {
        jl_struct_type_t *sty = (jl_struct_type_t*)expr_type(args[1], ctx);
        rt1 = (jl_value_t*)sty;
        if (jl_is_struct_type(sty) &amp;&amp; jl_is_quotenode(args[2]) &amp;&amp;
            jl_is_symbol(jl_fieldref(args[2],0))) {
            size_t offs = jl_field_offset(sty,
                                          (jl_sym_t*)jl_fieldref(args[2],0));
            if (offs != (size_t)-1) {
                jl_value_t *ft = jl_tupleref(sty-&gt;types, offs);
                jl_value_t *rhst = expr_type(args[3], ctx);
                rt2 = rhst;
                if (jl_subtype(rhst, ft, 0)) {
                    Value *strct = emit_expr(args[1], ctx, true);
                    Value *rhs = boxed(emit_expr(args[3], ctx, true));
                    Value *addr = emit_nthptr_addr(strct, offs+1);
                    builder.CreateStore(rhs, addr);
                    JL_GC_POP();
                    return rhs;
                }
            }
        }
    }
    else if (f-&gt;fptr == &amp;jl_f_instantiate_type &amp;&amp; nargs &gt; 0) {
        size_t i;
        for(i=1; i &lt;= nargs; i++) {
            if (!is_constant(args[i], ctx))
                break;
        }
        if (i &gt; nargs) {
            jl_value_t *ty =
                jl_interpret_toplevel_expr_in(ctx-&gt;module, expr,
                                              &amp;jl_tupleref(ctx-&gt;sp,0),
                                              ctx-&gt;sp-&gt;length/2);
            if (jl_is_leaf_type(ty)) {
                JL_GC_POP();
                return literal_pointer_val(ty);
            }
        }
    }
    // TODO: other known builtins
    JL_GC_POP();
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7387">
static Value *emit_call(jl_value_t **args, size_t arglen, jl_codectx_t *ctx,
                        jl_value_t *expr)
{
    size_t nargs = arglen-1;
    Value *theFptr=NULL, *theF=NULL;
    jl_binding_t *b=NULL;
    jl_value_t *a0 = args[0];
    jl_value_t *a00 = args[0];
    jl_value_t *hdtype;
    bool headIsGlobal = false;

    if (jl_is_symbolnode(a0)) {
        a0 = (jl_value_t*)jl_symbolnode_sym(a0);
    }
    if (jl_is_symbol(a0) &amp;&amp; is_global((jl_sym_t*)a0, ctx) &amp;&amp;
        jl_boundp(ctx-&gt;module, (jl_sym_t*)a0)) {
        b = jl_get_binding(ctx-&gt;module, (jl_sym_t*)a0);
        if (!b || !b-&gt;constp)
            b = NULL;
    }
    if (jl_is_topnode(a0)) {
        headIsGlobal = true;
        // (top x) is also global
        b = jl_get_binding(ctx-&gt;module, (jl_sym_t*)jl_fieldref(a0,0));
        if (!b || b-&gt;value==NULL || !b-&gt;constp)
            b = NULL;
    }
    jl_value_t *f = NULL;
    if (b != NULL) {
        // head is a constant global
        f = b-&gt;value;
    }
    else if (jl_is_func(a0)) {
        f = a0;
    }
    if (f != NULL) {
        Value *result = emit_known_call(f, args, nargs, ctx, &amp;theFptr, &amp;theF,
                                        expr);
        if (result != NULL) return result;
    }
    int last_depth = ctx-&gt;argDepth;
    hdtype = expr_type(a00, ctx);
    if (theFptr == NULL) {
        Value *theFunc = emit_expr(args[0], ctx, true);
        if (theFunc-&gt;getType() != jl_pvalue_llvmt || jl_is_tuple(hdtype)) {
            // we know it's not a function
            emit_type_error(theFunc, (jl_value_t*)jl_function_type, "apply", ctx);
            ctx-&gt;argDepth = last_depth;
            return V_null;
        }
#ifdef JL_GC_MARKSWEEP
        if (!headIsGlobal &amp;&amp; (jl_is_expr(a0) || jl_is_lambda_info(a0))) {
            make_gcroot(boxed(theFunc), ctx);
        }
#endif
        if (hdtype!=(jl_value_t*)jl_function_type &amp;&amp;
            hdtype!=(jl_value_t*)jl_struct_kind &amp;&amp;
            !(jl_is_type_type(hdtype) &amp;&amp;
              jl_is_struct_type(jl_tparam0(hdtype)))) {
            emit_func_check(theFunc, ctx);
        }
        // extract pieces of the function object
        // TODO: try extractelement instead
        theFptr = builder.CreateBitCast(emit_nthptr(theFunc, 1), jl_fptr_llvmt);
        theF = theFunc;
    }
    // emit arguments
    size_t i;
    int argStart = ctx-&gt;argDepth;
    for(i=0; i &lt; nargs; i++) {
        Value *anArg = emit_expr(args[i+1], ctx, true);
        // put into argument space
        make_gcroot(boxed(anArg), ctx);
    }

    // call
    Value *myargs;
    if (ctx-&gt;argTemp != NULL) {
        myargs = builder.CreateGEP(ctx-&gt;argTemp,
                                   ConstantInt::get(T_int32, argStart));
    }
    else {
        myargs = Constant::getNullValue(jl_ppvalue_llvmt);
    }
    Value *result = builder.CreateCall3(theFptr, theF, myargs,
                                        ConstantInt::get(T_int32,nargs));

    ctx-&gt;argDepth = last_depth;
    return result;
}
</t>
<t tx="ekr.20120404123906.7388">
// --- accessing and assigning variables ---

</t>
<t tx="ekr.20120404123906.7389">static bool isBoxed(char *varname, jl_codectx_t *ctx)
{
    return (*ctx-&gt;isAssigned)[varname] &amp;&amp; (*ctx-&gt;isCaptured)[varname];
}
</t>
<t tx="ekr.20120404123906.7390">
// yields a jl_value_t** giving the binding location of a variable
</t>
<t tx="ekr.20120404123906.7391">static Value *var_binding_pointer(jl_sym_t *s, jl_binding_t **pbnd,
                                  bool assign, jl_codectx_t *ctx)
{
    if (jl_is_symbolnode(s))
        s = jl_symbolnode_sym(s);
    assert(jl_is_symbol(s));
    std::map&lt;std::string,int&gt;::iterator it = ctx-&gt;closureEnv-&gt;find(s-&gt;name);
    if (it != ctx-&gt;closureEnv-&gt;end()) {
        int idx = (*it).second;
        if (isBoxed(s-&gt;name, ctx)) {
            return emit_nthptr_addr(emit_nthptr((Value*)ctx-&gt;envArg, idx+2), 1);
        }
        return emit_nthptr_addr((Value*)ctx-&gt;envArg, idx+2);
    }
    Value *l = (*ctx-&gt;vars)[s-&gt;name];
    if (l != NULL) {
        if (isBoxed(s-&gt;name, ctx)) {
            return emit_nthptr_addr(builder.CreateLoad(l,false), 1);
        }
        return l;
    }
    jl_binding_t *b=NULL;
    if (!assign)
        b = jl_get_binding(ctx-&gt;module, s);
    // if b is NULL, this might be a global that is not set yet but will be,
    // so get a pointer for writing even when not assigning.
    if (assign || b==NULL)
        b = jl_get_binding_wr(ctx-&gt;module, s);
    if (pbnd) *pbnd = b;
    return literal_pointer_val(&amp;b-&gt;value, jl_ppvalue_llvmt);
}
</t>
<t tx="ekr.20120404123906.7392">
static int is_var_closed(jl_sym_t *s, jl_codectx_t *ctx)
{
    std::map&lt;std::string,int&gt;::iterator it = ctx-&gt;closureEnv-&gt;find(s-&gt;name);
    return (it != ctx-&gt;closureEnv-&gt;end());
}
</t>
<t tx="ekr.20120404123906.7393">
static int is_global(jl_sym_t *s, jl_codectx_t *ctx)
{
    std::map&lt;std::string,int&gt;::iterator it = ctx-&gt;closureEnv-&gt;find(s-&gt;name);
    if (it != ctx-&gt;closureEnv-&gt;end())
        return false;
    return ((*ctx-&gt;vars)[s-&gt;name] == NULL);
}
</t>
<t tx="ekr.20120404123906.7394">
static Value *emit_checked_var(Value *bp, const char *name, jl_codectx_t *ctx)
{
    Value *v = tpropagate(bp, builder.CreateLoad(bp, false));
    Value *ok = builder.CreateICmpNE(v, V_null);
    BasicBlock *err = BasicBlock::Create(getGlobalContext(), "err", ctx-&gt;f);
    BasicBlock *ifok = BasicBlock::Create(getGlobalContext(), "ok");
    builder.CreateCondBr(ok, ifok, err);
    builder.SetInsertPoint(err);
    std::string msg;
    msg += std::string(name);
    msg += " not defined";
    emit_error(msg, ctx);
    builder.CreateBr(ifok);
    ctx-&gt;f-&gt;getBasicBlockList().push_back(ifok);
    builder.SetInsertPoint(ifok);
    return v;
}
</t>
<t tx="ekr.20120404123906.7395">
static Value *emit_var(jl_sym_t *sym, jl_value_t *ty, jl_codectx_t *ctx)
{
    // variable
    bool isglobal = is_global(sym, ctx);
    if (isglobal) {
        size_t i;
        // look for static parameter
        for(i=0; i &lt; ctx-&gt;sp-&gt;length; i+=2) {
            assert(jl_is_symbol(jl_tupleref(ctx-&gt;sp, i)));
            if (sym == (jl_sym_t*)jl_tupleref(ctx-&gt;sp, i)) {
                return literal_pointer_val(jl_tupleref(ctx-&gt;sp, i+1));
            }
        }
    }
    Value *bp = var_binding_pointer(sym, NULL, false, ctx);
    Value *arg = (*ctx-&gt;arguments)[sym-&gt;name];
    // arguments are always defined
    if (arg != NULL ||
        (!is_var_closed(sym, ctx) &amp;&amp;
         !jl_subtype((jl_value_t*)jl_undef_type, ty, 0))) {
        return tpropagate(bp, builder.CreateLoad(bp, false));
    }
    return emit_checked_var(bp, sym-&gt;name, ctx);
}
</t>
<t tx="ekr.20120404123906.7396">
static void emit_assignment(jl_value_t *l, jl_value_t *r, jl_codectx_t *ctx)
{
    jl_sym_t *s = NULL;
    if (jl_is_symbol(l))
        s = (jl_sym_t*)l;
    else if (jl_is_symbolnode(l))
        s = jl_symbolnode_sym(l);
    else
        assert(false);
    jl_binding_t *bnd=NULL;
    Value *bp = var_binding_pointer(s, &amp;bnd, true, ctx);
    if (bnd) {
        builder.CreateCall2(jlcheckassign_func,
                            literal_pointer_val((void*)bnd),
                            boxed(emit_expr(r, ctx, true)));
    }
    else {
        Type *vt = bp-&gt;getType();
        if (vt-&gt;isPointerTy() &amp;&amp; vt-&gt;getContainedType(0)!=jl_pvalue_llvmt)
            builder.CreateStore(emit_unbox(vt-&gt;getContainedType(0), vt,
                                           emit_unboxed(r, ctx)),
                                bp);
        else
            builder.CreateStore(boxed(emit_expr(r, ctx, true)), bp);
    }
}
</t>
<t tx="ekr.20120404123906.7397">
// --- convert expression to code ---

</t>
<t tx="ekr.20120404123906.7398">static Value *emit_expr(jl_value_t *expr, jl_codectx_t *ctx, bool value)
{
    if (jl_is_symbol(expr)) {
        if (!value) return NULL;
        return emit_var((jl_sym_t*)expr, (jl_value_t*)jl_undef_type, ctx);
    }
    if (jl_is_symbolnode(expr)) {
        if (!value) return NULL;
        return emit_var(jl_symbolnode_sym(expr), jl_symbolnode_type(expr), ctx);
    }
    else if (jl_is_labelnode(expr)) {
        assert(!value);
        int labelname = jl_labelnode_label(expr);
        BasicBlock *bb = (*ctx-&gt;labels)[labelname];
        assert(bb);
        if (builder.GetInsertBlock()-&gt;getTerminator() == NULL) {
            builder.CreateBr(bb); // all BasicBlocks must exit explicitly
        }
        ctx-&gt;f-&gt;getBasicBlockList().push_back(bb);
        builder.SetInsertPoint(bb);
        return NULL;
    }
    else if (jl_is_linenode(expr)) {
        return NULL;
    }
    else if (jl_is_quotenode(expr)) {
        jl_value_t *jv = jl_fieldref(expr,0);
        assert(jl_is_symbol(jv));
        return literal_pointer_val(jv);
    }
    else if (jl_is_gotonode(expr)) {
        assert(!value);
        if (builder.GetInsertBlock()-&gt;getTerminator() == NULL) {
            int labelname = jl_gotonode_label(expr);
            BasicBlock *bb = (*ctx-&gt;labels)[labelname];
            assert(bb);
            builder.CreateBr(bb);
            BasicBlock *after = BasicBlock::Create(getGlobalContext(), 
                                                   "br", ctx-&gt;f);
            builder.SetInsertPoint(after);
        }
        return NULL;
    }
    else if (jl_is_topnode(expr)) {
        jl_sym_t *var = (jl_sym_t*)jl_fieldref(expr,0);
        jl_value_t *etype = expr_type(expr, ctx);
        jl_binding_t *b = jl_get_binding(ctx-&gt;module, var);
        if (b == NULL)
            b = jl_get_binding_wr(ctx-&gt;module, var);
        Value *bp = literal_pointer_val(&amp;b-&gt;value, jl_ppvalue_llvmt);
        if ((b-&gt;constp &amp;&amp; b-&gt;value!=NULL) ||
            (etype!=(jl_value_t*)jl_any_type &amp;&amp;
             !jl_subtype((jl_value_t*)jl_undef_type, etype, 0))) {
            return builder.CreateLoad(bp, false);
        }
        return emit_checked_var(bp, var-&gt;name, ctx);
    }
    if (!jl_is_expr(expr)) {
        // numeric literals
        int needroot = 0;
        if (jl_is_int32(expr)) {
            needroot = !((uint32_t)(jl_unbox_int32(expr)+512) &lt; 1024);
        }
        else if (jl_is_int64(expr)) {
            needroot = !((uint64_t)(jl_unbox_int64(expr)+512) &lt; 1024);
        }
        else if (jl_is_lambda_info(expr)) {
            return emit_lambda_closure(expr, ctx);
        }
        else if (jl_is_tuple(expr)) {
            needroot = 1;
        }
        if (needroot) {
            jl_add_linfo_root(ctx-&gt;linfo, expr);
        }
        return literal_pointer_val(expr);
    }
    jl_expr_t *ex = (jl_expr_t*)expr;
    jl_value_t **args = &amp;jl_cellref(ex-&gt;args,0);
    // this is object-disoriented.
    // however, this is a good way to do it because it should *not* be easy
    // to add new node types.
    if (ex-&gt;head == goto_ifnot_sym) {
        assert(!value);
        jl_value_t *cond = args[0];
        int labelname = jl_unbox_long(args[1]);
        Value *condV = emit_expr(cond, ctx, true);
#ifdef CONDITION_REQUIRES_BOOL
        if (expr_type(cond, ctx) != (jl_value_t*)jl_bool_type &amp;&amp;
            condV-&gt;getType() != T_int1) {
            emit_typecheck(condV, (jl_value_t*)jl_bool_type, "if", ctx);
        }
#endif
        Value *isfalse;
        if (condV-&gt;getType() == T_int1) {
            isfalse = builder.CreateXor(condV, ConstantInt::get(T_int1,1));
        }
        else if (condV-&gt;getType() == jl_pvalue_llvmt) {
            isfalse =
                builder.CreateICmpEQ(condV, literal_pointer_val(jl_false));
        }
        else {
            // not a boolean
            isfalse = ConstantInt::get(T_int1,0);
        }
        BasicBlock *ifso = BasicBlock::Create(getGlobalContext(), "if", ctx-&gt;f);
        BasicBlock *ifnot = (*ctx-&gt;labels)[labelname];
        assert(ifnot);
        builder.CreateCondBr(isfalse, ifnot, ifso);
        builder.SetInsertPoint(ifso);
    }

    else if (ex-&gt;head == call_sym || ex-&gt;head == call1_sym) {
        return emit_call(args, ex-&gt;args-&gt;length, ctx, (jl_value_t*)ex);
    }

    else if (ex-&gt;head == assign_sym) {
        emit_assignment(args[0], args[1], ctx);
        if (value) {
            return literal_pointer_val((jl_value_t*)jl_nothing);
        }
    }
    else if (ex-&gt;head == method_sym) {
        jl_value_t *mn;
        if (jl_is_symbolnode(args[0])) {
            mn = (jl_value_t*)jl_symbolnode_sym(args[0]);
        }
        else {
            mn = args[0];
        }
        assert(jl_is_symbol(mn));
        int last_depth = ctx-&gt;argDepth;
        Value *name = literal_pointer_val(mn);
        jl_binding_t *bnd = NULL;
        Value *bp = var_binding_pointer((jl_sym_t*)mn, &amp;bnd, true, ctx);
        Value *a1 = emit_expr(args[1], ctx, true);
        make_gcroot(boxed(a1), ctx);
        Value *a2 = emit_expr(args[2], ctx, true);
        make_gcroot(boxed(a2), ctx);
        Value *a3 = emit_expr(args[3], ctx, true);
        make_gcroot(boxed(a3), ctx);
        Value *mdargs[6] = { name, bp, literal_pointer_val((void*)bnd),
                             a1, a2, a3 };
        builder.CreateCall(jlmethod_func, ArrayRef&lt;Value*&gt;(&amp;mdargs[0], 6));
        ctx-&gt;argDepth = last_depth;
        return literal_pointer_val((jl_value_t*)jl_nothing);
    }
    else if (ex-&gt;head == const_sym) {
        jl_sym_t *sym = (jl_sym_t*)args[0];
        jl_binding_t *bnd = NULL;
        (void)var_binding_pointer(sym, &amp;bnd, true, ctx);
        if (bnd) {
            builder.CreateCall(jldeclareconst_func,
                               literal_pointer_val((void*)bnd));
        }
    }

    else if (ex-&gt;head == null_sym) {
        return literal_pointer_val((jl_value_t*)jl_nothing);
    }
    else if (ex-&gt;head == static_typeof_sym) {
        jl_value_t *extype = expr_type((jl_value_t*)ex, ctx);
        if (jl_is_type_type(extype)) {
            extype = jl_tparam0(extype);
            if (jl_is_typevar(extype))
                extype = ((jl_tvar_t*)extype)-&gt;ub;
        }
        else {
            extype = (jl_value_t*)jl_any_type;
        }
        return literal_pointer_val(extype);
    }
    else if (ex-&gt;head == new_sym) {
        jl_value_t *ty = expr_type(args[0], ctx);
        if (jl_is_type_type(ty) &amp;&amp;
            jl_is_struct_type(jl_tparam0(ty)) &amp;&amp;
            jl_is_leaf_type(jl_tparam0(ty))) {
            ty = jl_tparam0(ty);
            size_t nf = ((jl_struct_type_t*)ty)-&gt;names-&gt;length;
            if (nf &gt; 0) {
                Value *strct =
                    builder.CreateBitCast
                    (builder.CreateCall(jlallocobj_func,
                                        ConstantInt::get(T_size,
                                                         sizeof(void*)*(nf+1))),
                     jl_pvalue_llvmt);
                builder.CreateStore(literal_pointer_val((jl_value_t*)ty),
                                    emit_nthptr_addr(strct, (size_t)0));
                for(size_t i=0; i &lt; nf; i++) {
                    builder.CreateStore(V_null,
                                        emit_nthptr_addr(strct, i+1));
                }
                return strct;
            }
            else {
                // 0 fields, singleton
                return literal_pointer_val
                    (jl_new_struct_uninit((jl_struct_type_t*)ty));
            }
        }
        Value *typ = emit_expr(args[0], ctx, true);
        return builder.CreateCall(jlnew_func, typ);
    }
    else if (ex-&gt;head == exc_sym) {
        return builder.CreateLoad(jlexc_var, true);
    }
    else if (ex-&gt;head == leave_sym) {
        assert(jl_is_long(args[0]));
        builder.CreateCall(jlleave_func,
                           ConstantInt::get(T_int32, jl_unbox_long(args[0])));
    }
    else if (ex-&gt;head == enter_sym) {
        assert(jl_is_long(args[0]));
        int labl = jl_unbox_long(args[0]);
        Value *jbuf = builder.CreateGEP((*ctx-&gt;jmpbufs)[labl],
                                        ConstantInt::get(T_int32,0));
        builder.CreateCall2(jlenter_func,
                            builder.CreateGEP((*ctx-&gt;savestates)[labl],
                                              ConstantInt::get(T_int32,0)),
                            jbuf);
        Value *sj = builder.CreateCall(setjmp_func, jbuf);
        Value *isz = builder.CreateICmpEQ(sj, ConstantInt::get(T_int32,0));
        BasicBlock *tryblk = BasicBlock::Create(getGlobalContext(), "try",
                                                ctx-&gt;f);
        BasicBlock *handlr = (*ctx-&gt;labels)[labl];
        assert(handlr);
        builder.CreateCondBr(isz, tryblk, handlr);
        builder.SetInsertPoint(tryblk);
    }
    if (!strcmp(ex-&gt;head-&gt;name, "$")) {
        jl_error("syntax error: prefix $ outside of quote block");
    }
    if (value) {
        jl_errorf("unsupported expression type %s", ex-&gt;head-&gt;name);
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7399">
// --- allocating local variables ---

</t>
<t tx="ekr.20120404123906.7400">static bool store_unboxed_p(char *name, jl_codectx_t *ctx)
{
    jl_value_t *jt = (*ctx-&gt;declTypes)[name];
    // only store a variable unboxed if type inference has run, which
    // checks that the variable is not referenced undefined.
    return (ctx-&gt;linfo-&gt;inferred==jl_true &amp;&amp; jl_is_bits_type(jt) &amp;&amp;
            jl_is_leaf_type(jt) &amp;&amp;
            // don't unbox intrinsics, since inference depends on their having
            // stable addresses for table lookup.
            jt != (jl_value_t*)jl_intrinsic_type &amp;&amp; !(*ctx-&gt;isCaptured)[name]);
}
</t>
<t tx="ekr.20120404123906.7401">
static AllocaInst *alloc_local(char *name, jl_codectx_t *ctx)
{
    jl_value_t *jt = (*ctx-&gt;declTypes)[name];
    Type *vtype=NULL;
    if (store_unboxed_p(name, ctx))
        vtype = julia_type_to_llvm(jt, ctx);
    if (vtype == NULL)
        vtype = jl_pvalue_llvmt;
    AllocaInst *lv = builder.CreateAlloca(vtype, 0, name);
    if (vtype != jl_pvalue_llvmt)
        mark_julia_type(lv, jt);
    (*ctx-&gt;vars)[name] = lv;
    return lv;
}
</t>
<t tx="ekr.20120404123906.7402">
// --- generate function bodies ---

extern char *jl_stack_lo;

extern "C" jl_tuple_t *jl_tuple_tvars_to_symbols(jl_tuple_t *t);

//static int total_roots=0;
//static int used_roots=0;
//static int n_elim=0;

</t>
<t tx="ekr.20120404123906.7403">static void emit_function(jl_lambda_info_t *lam, Function *f)
{
    jl_expr_t *ast = (jl_expr_t*)lam-&gt;ast;
    jl_tuple_t *sparams = NULL;
    JL_GC_PUSH(&amp;ast, &amp;sparams);
    if (jl_is_tuple(ast)) {
        ast = (jl_expr_t*)jl_uncompress_ast((jl_tuple_t*)ast);
    }
    assert(jl_is_expr(ast));
    sparams = jl_tuple_tvars_to_symbols(lam-&gt;sparams);
    //jl_print((jl_value_t*)ast);
    //ios_printf(ios_stdout, "\n");
    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, "top", f);
    builder.SetInsertPoint(b0);
    std::map&lt;std::string, Value*&gt; localVars;
    std::map&lt;std::string, Value*&gt; argumentMap;
    std::map&lt;std::string, int&gt; closureEnv;
    std::map&lt;std::string, bool&gt; isAssigned;
    std::map&lt;std::string, bool&gt; isCaptured;
    std::map&lt;std::string, bool&gt; escapes;
    std::map&lt;std::string, jl_value_t*&gt; declTypes;
    std::map&lt;int, BasicBlock*&gt; labels;
    std::map&lt;int, Value*&gt; savestates;
    std::map&lt;int, Value*&gt; jmpbufs;
    jl_array_t *largs = jl_lam_args(ast);
    jl_array_t *lvars = jl_lam_locals(ast);
    Function::arg_iterator AI = f-&gt;arg_begin();
    const Argument &amp;fArg = *AI++;
    const Argument &amp;argArray = *AI++;
    const Argument &amp;argCount = *AI++;
    jl_codectx_t ctx;
    ctx.f = f;
    ctx.vars = &amp;localVars;
    ctx.arguments = &amp;argumentMap;
    ctx.closureEnv = &amp;closureEnv;
    ctx.isAssigned = &amp;isAssigned;
    ctx.isCaptured = &amp;isCaptured;
    ctx.escapes = &amp;escapes;
    ctx.declTypes = &amp;declTypes;
    ctx.labels = &amp;labels;
    ctx.savestates = &amp;savestates;
    ctx.jmpbufs = &amp;jmpbufs;
    ctx.module = lam-&gt;module;
    ctx.ast = ast;
    ctx.sp = sparams;
    ctx.linfo = lam;
    ctx.argArray = &amp;argArray;
    ctx.argCount = &amp;argCount;
    ctx.funcName = lam-&gt;name-&gt;name;
    ctx.vaName = NULL;
    ctx.vaStack = false;

    // look for initial (line num filename) node
    jl_array_t *stmts = jl_lam_body(ast)-&gt;args;
    jl_value_t *stmt = jl_cellref(stmts,0);
    std::string filename = "no file";
    int lno = -1;
    if (jl_is_linenode(stmt)) {
        lno = jl_linenode_line(stmt);
    }
    else if (jl_is_expr(stmt) &amp;&amp; ((jl_expr_t*)stmt)-&gt;head == line_sym) {
        lno = jl_unbox_long(jl_exprarg(stmt, 0));
        if (((jl_expr_t*)stmt)-&gt;args-&gt;length &gt; 1) {
            assert(jl_is_symbol(jl_exprarg(stmt, 1)));
            filename = ((jl_sym_t*)jl_exprarg(stmt, 1))-&gt;name;
        }
    }
    
    dbuilder-&gt;createCompileUnit(0, filename, ".", "julia", true, "", 0);
    llvm::DIArray EltTypeArray = dbuilder-&gt;getOrCreateArray(ArrayRef&lt;Value*&gt;());
    DIFile fil = dbuilder-&gt;createFile(filename, ".");
    DISubprogram SP =
        dbuilder-&gt;createFunction((DIDescriptor)dbuilder-&gt;getCU(),
                                 lam-&gt;name-&gt;name,
                                 lam-&gt;name-&gt;name,
                                 fil,
                                 0,
                                 dbuilder-&gt;createSubroutineType(fil,EltTypeArray),
                                 false, true,
                                 0, true, f);
    
    // set initial line number
    builder.SetCurrentDebugLocation(DebugLoc::get(lno, 0, (MDNode*)SP, NULL));
    
    /*
    // check for stack overflow (the slower way)
    Value *cur_sp =
        builder.CreateCall(Intrinsic::getDeclaration(jl_Module,
                                                     Intrinsic::frameaddress),
                           ConstantInt::get(T_int32, 0));
    Value *sp_ok =
        builder.CreateICmpUGT(cur_sp,
                              ConstantInt::get(T_size,
                                               (uptrint_t)jl_stack_lo));
    error_unless(sp_ok, "stack overflow", &amp;ctx);
    */
    // process var-info lists to see what vars are captured, need boxing
    size_t nreq = largs-&gt;length;
    int va = 0;
    if (nreq &gt; 0 &amp;&amp; jl_is_rest_arg(jl_cellref(largs,nreq-1))) {
        nreq--;
        va = 1;
        ctx.vaName = jl_decl_var(jl_cellref(largs,nreq));
    }
    ctx.nReqArgs = nreq;

    jl_array_t *vinfos = jl_lam_vinfo(ast);
    size_t i;
    for(i=0; i &lt; vinfos-&gt;length; i++) {
        jl_array_t *vi = (jl_array_t*)jl_cellref(vinfos, i);
        assert(jl_is_array(vi));
        char *vname = ((jl_sym_t*)jl_cellref(vi,0))-&gt;name;
        isAssigned[vname] = (jl_vinfo_assigned(vi)!=0);
        bool iscapt = (jl_vinfo_capt(vi)!=0);
        isCaptured[vname] = iscapt;
        escapes[vname] = iscapt;
        declTypes[vname] = jl_cellref(vi,1);
    }
    vinfos = jl_lam_capt(ast);
    for(i=0; i &lt; vinfos-&gt;length; i++) {
        jl_array_t *vi = (jl_array_t*)jl_cellref(vinfos, i);
        assert(jl_is_array(vi));
        char *vname = ((jl_sym_t*)jl_cellref(vi,0))-&gt;name;
        closureEnv[vname] = i;
        isAssigned[vname] = (jl_vinfo_assigned(vi)!=0);
        isCaptured[vname] = true;
        escapes[vname] = true;
        declTypes[vname] = jl_cellref(vi,1);
    }

    int n_roots = 0;
    // allocate local variables
    // must be first for the mem2reg pass to work
    for(i=0; i &lt; largs-&gt;length; i++) {
        char *argname = jl_decl_var(jl_cellref(largs,i))-&gt;name;
        if (store_unboxed_p(argname, &amp;ctx)) {
            AllocaInst *lv = alloc_local(argname, &amp;ctx);
            argumentMap[argname] = lv;
        }
        else if (isAssigned[argname] || (va &amp;&amp; i==largs-&gt;length-1)) {
            n_roots++;
        }
    }
    for(i=0; i &lt; lvars-&gt;length; i++) {
        char *argname = ((jl_sym_t*)jl_cellref(lvars,i))-&gt;name;
        if (store_unboxed_p(argname, &amp;ctx)) {
            alloc_local(argname, &amp;ctx);
        }
        else {
            n_roots++;
        }
    }

    // fetch env out of function object if we need it
    if (vinfos-&gt;length &gt; 0) {
        ctx.envArg = emit_nthptr((Value*)&amp;fArg, 2);
    }

    int32_t argdepth=0, vsp=0;
    max_arg_depth((jl_value_t*)ast, &amp;argdepth, &amp;vsp, true, &amp;ctx);
    n_roots += argdepth;
    //total_roots += n_roots;
    ctx.argDepth = 0;
    //ctx.maxDepth = 0;
    ctx.argSpace = argdepth;
#ifdef JL_GC_MARKSWEEP
    AllocaInst *gcframe = NULL;
#endif
    if (n_roots &gt; 0) {
        ctx.argTemp = builder.CreateAlloca(jl_pvalue_llvmt,
                                           ConstantInt::get(T_int32, n_roots));
#ifdef JL_GC_MARKSWEEP
        // create gc frame
        gcframe = builder.CreateAlloca(T_gcframe, 0);
        builder.CreateStore(builder.CreateBitCast(ctx.argTemp,
                                                  PointerType::get(jl_ppvalue_llvmt,0)),
                            builder.CreateConstGEP2_32(gcframe, 0, 0));
        builder.CreateStore(ConstantInt::get(T_size, n_roots),
                            builder.CreateConstGEP2_32(gcframe, 0, 1));
        builder.CreateStore(ConstantInt::get(T_int32, 0),
                            builder.CreateConstGEP2_32(gcframe, 0, 2));
        builder.CreateStore(builder.CreateLoad(jlpgcstack_var, false),
                            builder.CreateConstGEP2_32(gcframe, 0, 3));
        builder.CreateStore(gcframe, jlpgcstack_var, false);
        // initialize stack roots to null
        for(i=0; i &lt; (size_t)n_roots; i++) {
            Value *argTempi = builder.CreateConstGEP1_32(ctx.argTemp,i);
            builder.CreateStore(V_null, argTempi);
        }
#endif
    }
    else {
        ctx.argTemp = NULL;
        //n_elim++;
    }

    // get pointers for locals stored in the gc frame array (argTemp)
    int varnum = argdepth;
    for(i=0; i &lt; largs-&gt;length; i++) {
        char *argname = jl_decl_var(jl_cellref(largs,i))-&gt;name;
        if (store_unboxed_p(argname, &amp;ctx)) {
        }
        else if (isAssigned[argname] || (va &amp;&amp; i==largs-&gt;length-1)) {
            Value *av = builder.CreateConstGEP1_32(ctx.argTemp,varnum);
            varnum++;
            localVars[argname] = av;
            argumentMap[argname] = av;
        }
    }
    for(i=0; i &lt; lvars-&gt;length; i++) {
        char *argname = ((jl_sym_t*)jl_cellref(lvars,i))-&gt;name;
        if (store_unboxed_p(argname, &amp;ctx)) {
        }
        else {
            Value *lv = builder.CreateConstGEP1_32(ctx.argTemp,varnum);
            varnum++;
            localVars[argname] = lv;
        }
    }
    assert(varnum == n_roots);

    // create boxes for boxed locals
    for(i=0; i &lt; lvars-&gt;length; i++) {
        char *argname = ((jl_sym_t*)jl_cellref(lvars,i))-&gt;name;
        if (isBoxed(argname, &amp;ctx)) {
            Value *lv = localVars[argname];
            builder.CreateStore(builder.CreateCall(jlbox_func, V_null), lv);
        }
    }

    // allocate space for exception handler contexts
    for(i=0; i &lt; stmts-&gt;length; i++) {
        jl_value_t *stmt = jl_cellref(stmts,i);
        if (jl_is_expr(stmt) &amp;&amp; ((jl_expr_t*)stmt)-&gt;head == enter_sym) {
            int labl = jl_unbox_long(jl_exprarg(stmt,0));
            Value *svst =
                builder.CreateAlloca(T_int8,
                                     ConstantInt::get(T_int32,
                                                      sizeof(jl_savestate_t)));
            Value *jmpb =
                builder.CreateAlloca(T_int8,
                                     ConstantInt::get(T_int32,
                                                      sizeof(jmp_buf)));
            savestates[labl] = svst;
            jmpbufs[labl] = jmpb;
        }
    }

    // check arg count
    if (ctx.linfo-&gt;specTypes == NULL) {
        if (va) {
            Value *enough =
                builder.CreateICmpUGE((Value*)&amp;argCount,
                                      ConstantInt::get(T_int32, nreq));
            BasicBlock *elseBB =
                BasicBlock::Create(getGlobalContext(), "else", f);
            BasicBlock *mergeBB =
                BasicBlock::Create(getGlobalContext(), "ifcont");
            builder.CreateCondBr(enough, mergeBB, elseBB);
            builder.SetInsertPoint(elseBB);
            emit_error("too few arguments", &amp;ctx);
            builder.CreateBr(mergeBB);
            f-&gt;getBasicBlockList().push_back(mergeBB);
            builder.SetInsertPoint(mergeBB);
        }
        else {
            Value *enough =
                builder.CreateICmpEQ((Value*)&amp;argCount,
                                     ConstantInt::get(T_int32, nreq));
            BasicBlock *elseBB =
                BasicBlock::Create(getGlobalContext(), "else", f);
            BasicBlock *mergeBB =
                BasicBlock::Create(getGlobalContext(), "ifcont");
            builder.CreateCondBr(enough, mergeBB, elseBB);
            builder.SetInsertPoint(elseBB);
            emit_error("wrong number of arguments", &amp;ctx);
            builder.CreateBr(mergeBB);
            f-&gt;getBasicBlockList().push_back(mergeBB);
            builder.SetInsertPoint(mergeBB);
        }
    }

    // move args into local variables
    for(i=0; i &lt; nreq; i++) {
        char *argname = jl_decl_var(jl_cellref(largs,i))-&gt;name;
        Value *argPtr = builder.CreateGEP((Value*)&amp;argArray,
                                          ConstantInt::get(T_int32, i));
        Value *lv = localVars[argname];
        if (lv == NULL) {
            // if this argument hasn't been given space yet, we've decided
            // to leave it in the input argument array.
            localVars[argname] = argPtr;
            argumentMap[argname] = argPtr;
        }
        else {
            LoadInst *theArg = builder.CreateLoad(argPtr, false);
            if (isBoxed(argname, &amp;ctx))
                builder.CreateStore(builder.CreateCall(jlbox_func, theArg), lv);
            else if (dyn_cast&lt;GetElementPtrInst&gt;(lv) != NULL)
                builder.CreateStore(theArg, lv);
            else
                builder.CreateStore(emit_unbox(dyn_cast&lt;AllocaInst&gt;(lv)-&gt;getAllocatedType(),
                                               lv-&gt;getType(),
                                               theArg),
                                    lv);
        }
    }
    // allocate rest argument if necessary
    if (va) {
        if (!escapes[ctx.vaName-&gt;name] &amp;&amp; !isAssigned[ctx.vaName-&gt;name]) {
            ctx.vaStack = true;
        }
        else {
            // restarg = jl_f_tuple(NULL, &amp;args[nreq], nargs-nreq)
            Value *restTuple =
                builder.CreateCall3(jltuple_func, V_null,
                                    builder.CreateGEP((Value*)&amp;argArray,
                                                      ConstantInt::get(T_int32,nreq)),
                                    builder.CreateSub((Value*)&amp;argCount,
                                                      ConstantInt::get(T_int32,nreq)));
            char *argname = ctx.vaName-&gt;name;
            Value *lv = localVars[argname];
            if (isBoxed(argname, &amp;ctx))
                builder.CreateStore(builder.CreateCall(jlbox_func, restTuple), lv);
            else
                builder.CreateStore(restTuple, lv);
        }
    }

    // associate labels with basic blocks so forward jumps can be resolved
    BasicBlock *prev=NULL;
    for(i=0; i &lt; stmts-&gt;length; i++) {
        jl_value_t *ex = jl_cellref(stmts,i);
        if (jl_is_labelnode(ex)) {
            int lname = jl_labelnode_label(ex);
            if (prev != NULL) {
                // fuse consecutive labels
                labels[lname] = prev;
            }
            else {
                prev = BasicBlock::Create(getGlobalContext(), "L");
                labels[lname] = prev;
            }
        }
        else {
            prev = NULL;
        }
    }
    // compile body statements
    bool prevlabel = false;
    for(i=0; i &lt; stmts-&gt;length; i++) {
        jl_value_t *stmt = jl_cellref(stmts,i);
        if (jl_is_linenode(stmt)) {
            int lno = jl_linenode_line(stmt);
            builder.SetCurrentDebugLocation(DebugLoc::get(lno, 1, (MDNode*)SP,
                                                          NULL));
        }
        else if (jl_is_expr(stmt) &amp;&amp; ((jl_expr_t*)stmt)-&gt;head == line_sym) {
            int lno = jl_unbox_long(jl_exprarg(stmt, 0));
            builder.SetCurrentDebugLocation(DebugLoc::get(lno, 1, (MDNode*)SP,
                                                          NULL));
        }
        if (jl_is_labelnode(stmt)) {
            if (prevlabel) continue;
            prevlabel = true;
        }
        else {
            prevlabel = false;
        }
        if (jl_is_expr(stmt) &amp;&amp; ((jl_expr_t*)stmt)-&gt;head == return_sym) {
            jl_expr_t *ex = (jl_expr_t*)stmt;
            Value *retval = boxed(emit_expr(jl_exprarg(ex,0), &amp;ctx, true));
#ifdef JL_GC_MARKSWEEP
            // JL_GC_POP();
            if (n_roots &gt; 0) {
                builder.CreateStore(builder.CreateLoad(builder.CreateConstGEP2_32(gcframe, 0, 3), false),
                                    jlpgcstack_var);
            }
#endif
            builder.CreateRet(retval);
            if (i != stmts-&gt;length-1) {
                BasicBlock *bb =
                    BasicBlock::Create(getGlobalContext(), "ret", ctx.f);
                builder.SetInsertPoint(bb);
            }
        }
        else {
            (void)emit_expr(stmt, &amp;ctx, false);
        }
    }
    // sometimes we have dangling labels after the end
    if (builder.GetInsertBlock()-&gt;getTerminator() == NULL) {
        builder.CreateRet(V_null);
    }
    //used_roots += ctx.maxDepth;
    JL_GC_POP();
}
</t>
<t tx="ekr.20120404123906.7404">
// --- initialization ---

</t>
<t tx="ekr.20120404123906.7405">static GlobalVariable *global_to_llvm(const std::string &amp;cname, void *addr)
{
    GlobalVariable *gv =
        new GlobalVariable(*jl_Module, jl_pvalue_llvmt,
                           true, GlobalVariable::ExternalLinkage,
                           NULL, cname);
    jl_ExecutionEngine-&gt;addGlobalMapping(gv, addr);
    return gv;
}
</t>
<t tx="ekr.20120404123906.7406">
static Function *jlfunc_to_llvm(const std::string &amp;cname, void *addr)
{
    Function *f =
        Function::Create(jl_func_sig, Function::ExternalLinkage,
                         cname, jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(f, addr);
    return f;
}
</t>
<t tx="ekr.20120404123906.7407">
extern "C" jl_value_t *jl_new_box(jl_value_t *v)
{
    jl_value_t *box = (jl_value_t*)alloc_2w();
    box-&gt;type = jl_box_any_type;
    ((jl_value_t**)box)[1] = v;
    return box;
}
</t>
<t tx="ekr.20120404123906.7408">
static void init_julia_llvm_env(Module *m)
{
    T_int1  = Type::getInt1Ty(getGlobalContext());
    T_int8  = Type::getInt8Ty(getGlobalContext());
    T_pint8 = PointerType::get(T_int8, 0);
    T_int16 = Type::getInt16Ty(getGlobalContext());
    T_pint16 = PointerType::get(T_int16, 0);
    T_int32 = Type::getInt32Ty(getGlobalContext());
    T_char = Type::getInt32Ty(getGlobalContext());
    T_pint32 = PointerType::get(T_int32, 0);
    T_int64 = Type::getInt64Ty(getGlobalContext());
    T_pint64 = PointerType::get(T_int64, 0);
    T_uint8 = T_int8;   T_uint16 = T_int16;
    T_uint32 = T_int32; T_uint64 = T_int64;
#ifdef __LP64__
    T_size = T_uint64;
#else
    T_size = T_uint32;
#endif
    T_psize = PointerType::get(T_size, 0);
    T_float32 = Type::getFloatTy(getGlobalContext());
    T_pfloat32 = PointerType::get(T_float32, 0);
    T_float64 = Type::getDoubleTy(getGlobalContext());
    T_pfloat64 = PointerType::get(T_float64, 0);
    T_void = Type::getVoidTy(jl_LLVMContext);

    // add needed base definitions to our LLVM environment
    StructType *valueSt = StructType::create(getGlobalContext(), "jl_value_t");
    Type *valueStructElts[1] = { PointerType::getUnqual(valueSt) };
    ArrayRef&lt;Type*&gt; vselts(valueStructElts);
    valueSt-&gt;setBody(vselts);
    jl_value_llvmt = valueSt;

    jl_pvalue_llvmt = PointerType::get(jl_value_llvmt, 0);
    jl_ppvalue_llvmt = PointerType::get(jl_pvalue_llvmt, 0);
    V_null = Constant::getNullValue(jl_pvalue_llvmt);
    std::vector&lt;Type*&gt; ftargs(0);
    ftargs.push_back(jl_pvalue_llvmt);
    ftargs.push_back(jl_ppvalue_llvmt);
    ftargs.push_back(T_int32);
    jl_func_sig = FunctionType::get(jl_pvalue_llvmt, ftargs, false);
    assert(jl_func_sig != NULL);
    jl_fptr_llvmt = PointerType::get(jl_func_sig, 0);

#ifdef JL_GC_MARKSWEEP
    StructType *gcfst = StructType::create(getGlobalContext(), "jl_gcframe_t");
    Type *gcframeStructElts[4] = {
        PointerType::get(jl_ppvalue_llvmt,0),
        T_size,
        T_int32,
        PointerType::getUnqual(gcfst) };
    gcfst-&gt;setBody(ArrayRef&lt;Type*&gt;(gcframeStructElts, 4));
    T_gcframe = gcfst;

    jlpgcstack_var =
        new GlobalVariable(*jl_Module, PointerType::get(T_gcframe,0),
                           true, GlobalVariable::ExternalLinkage,
                           NULL, "jl_pgcstack");
    jl_ExecutionEngine-&gt;addGlobalMapping(jlpgcstack_var, (void*)&amp;jl_pgcstack);
#endif

    jltrue_var = global_to_llvm("jl_true", (void*)&amp;jl_true);
    jlfalse_var = global_to_llvm("jl_false", (void*)&amp;jl_false);
    jlnull_var = global_to_llvm("jl_null", (void*)&amp;jl_null);
    jlexc_var = global_to_llvm("jl_exception_in_transit",
                               (void*)&amp;jl_exception_in_transit);
    jlfloat32temp_var =
        new GlobalVariable(*jl_Module, T_float32,
                           false, GlobalVariable::PrivateLinkage,
                           ConstantFP::get(T_float32,0.0), "jl_float32_temp");

    std::vector&lt;Type*&gt; args1(0);
    args1.push_back(T_pint8);
    jlerror_func =
        Function::Create(FunctionType::get(T_void, args1, false),
                         Function::ExternalLinkage,
                         "jl_error", jl_Module);
    jlerror_func-&gt;setDoesNotReturn();
    jl_ExecutionEngine-&gt;addGlobalMapping(jlerror_func, (void*)&amp;jl_error);

    std::vector&lt;Type*&gt; args1_(0);
    args1_.push_back(jl_pvalue_llvmt);
    jlraise_func =
        Function::Create(FunctionType::get(T_void, args1_, false),
                         Function::ExternalLinkage,
                         "jl_raise", jl_Module);
    jlraise_func-&gt;setDoesNotReturn();
    jl_ExecutionEngine-&gt;addGlobalMapping(jlraise_func, (void*)&amp;jl_raise);

    jlnew_func =
        Function::Create(FunctionType::get(jl_pvalue_llvmt, args1_, false),
                         Function::ExternalLinkage,
                         "jl_new_struct_uninit", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlnew_func,
                                         (void*)&amp;jl_new_struct_uninit);

    std::vector&lt;Type*&gt; empty_args(0);
    jluniniterror_func =
        Function::Create(FunctionType::get(T_void, empty_args, false),
                         Function::ExternalLinkage,
                         "jl_undef_ref_error", jl_Module);
    jluniniterror_func-&gt;setDoesNotReturn();
    jl_ExecutionEngine-&gt;addGlobalMapping(jluniniterror_func,
                                         (void*)&amp;jl_undef_ref_error);

    jldiverror_func =
        Function::Create(FunctionType::get(T_void, empty_args, false),
                         Function::ExternalLinkage,
                         "jl_divide_by_zero_error", jl_Module);
    jldiverror_func-&gt;setDoesNotReturn();
    jl_ExecutionEngine-&gt;addGlobalMapping(jldiverror_func,
                                         (void*)&amp;jl_divide_by_zero_error);

    setjmp_func =
        Function::Create(FunctionType::get(T_int32, args1, false),
                         Function::ExternalLinkage, "_setjmp", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(setjmp_func, (void*)&amp;_setjmp);

    std::vector&lt;Type*&gt; te_args(0);
    te_args.push_back(T_pint8);
    te_args.push_back(T_pint8);
    te_args.push_back(jl_pvalue_llvmt);
    te_args.push_back(jl_pvalue_llvmt);
    jltypeerror_func =
        Function::Create(FunctionType::get(T_void, te_args, false),
                         Function::ExternalLinkage,
                         "jl_type_error_rt", jl_Module);
    jltypeerror_func-&gt;setDoesNotReturn();
    jl_ExecutionEngine-&gt;addGlobalMapping(jltypeerror_func,
                                         (void*)&amp;jl_type_error_rt);

    std::vector&lt;Type *&gt; args_2ptrs(0);
    args_2ptrs.push_back(T_pint8);
    args_2ptrs.push_back(jl_pvalue_llvmt);
    jlcheckassign_func =
        Function::Create(FunctionType::get(T_void, args_2ptrs, false),
                         Function::ExternalLinkage,
                         "jl_checked_assignment", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlcheckassign_func,
                                         (void*)&amp;jl_checked_assignment);

    std::vector&lt;Type *&gt; args_1ptr(0);
    args_1ptr.push_back(T_pint8);
    jldeclareconst_func =
        Function::Create(FunctionType::get(T_void, args_1ptr, false),
                         Function::ExternalLinkage,
                         "jl_declare_constant", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jldeclareconst_func,
                                         (void*)&amp;jl_declare_constant);

    jltuple_func = jlfunc_to_llvm("jl_f_tuple", (void*)*jl_f_tuple);
    jlapplygeneric_func =
        jlfunc_to_llvm("jl_apply_generic", (void*)*jl_apply_generic);

    std::vector&lt;Type*&gt; args3(0);
    args3.push_back(jl_pvalue_llvmt);
    jlbox_func =
        Function::Create(FunctionType::get(jl_pvalue_llvmt, args3, false),
                         Function::ExternalLinkage,
                         "jl_new_box", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlbox_func, (void*)&amp;jl_new_box);

    std::vector&lt;Type*&gt; args4(0);
    args4.push_back(T_pint8);
    args4.push_back(jl_pvalue_llvmt);
    args4.push_back(jl_pvalue_llvmt);
    jlclosure_func =
        Function::Create(FunctionType::get(jl_pvalue_llvmt, args4, false),
                         Function::ExternalLinkage,
                         "jl_new_closure", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlclosure_func,
                                         (void*)&amp;jl_new_closure);

    std::vector&lt;Type*&gt; args5(0);
    args5.push_back(T_size);
    jlntuple_func =
        Function::Create(FunctionType::get(jl_pvalue_llvmt, args5, true),
                         Function::ExternalLinkage,
                         "jl_tuple", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlntuple_func, (void*)&amp;jl_tuple);

    std::vector&lt;Type*&gt; mdargs(0);
    mdargs.push_back(jl_pvalue_llvmt);
    mdargs.push_back(jl_ppvalue_llvmt);
    mdargs.push_back(T_pint8);
    mdargs.push_back(jl_pvalue_llvmt);
    mdargs.push_back(jl_pvalue_llvmt);
    mdargs.push_back(jl_pvalue_llvmt);
    jlmethod_func =
        Function::Create(FunctionType::get(jl_pvalue_llvmt, mdargs, false),
                         Function::ExternalLinkage,
                         "jl_method_def", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlmethod_func, (void*)&amp;jl_method_def);

    std::vector&lt;Type*&gt; ehargs(0);
    ehargs.push_back(T_pint8);
    ehargs.push_back(T_pint8);
    jlenter_func =
        Function::Create(FunctionType::get(T_void, ehargs, false),
                         Function::ExternalLinkage,
                         "jl_enter_handler", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlenter_func, (void*)&amp;jl_enter_handler);

    std::vector&lt;Type*&gt; lhargs(0);
    lhargs.push_back(T_int32);
    jlleave_func =
        Function::Create(FunctionType::get(T_void, lhargs, false),
                         Function::ExternalLinkage,
                         "jl_pop_handler", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlleave_func, (void*)&amp;jl_pop_handler);

    std::vector&lt;Type*&gt; aoargs(0);
    aoargs.push_back(T_size);
    jlallocobj_func =
        Function::Create(FunctionType::get(T_pint8, aoargs, false),
                         Function::ExternalLinkage,
                         "allocobj", jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(jlallocobj_func, (void*)&amp;allocobj);

    // set up optimization passes
    FPM = new FunctionPassManager(jl_Module);
    FPM-&gt;add(new TargetData(*jl_ExecutionEngine-&gt;getTargetData()));
    
    // list of passes from vmkit
    FPM-&gt;add(createCFGSimplificationPass()); // Clean up disgusting code
    FPM-&gt;add(createPromoteMemoryToRegisterPass());// Kill useless allocas
    
    FPM-&gt;add(createInstructionCombiningPass()); // Cleanup for scalarrepl.
    FPM-&gt;add(createScalarReplAggregatesPass()); // Break up aggregate allocas
    FPM-&gt;add(createInstructionCombiningPass()); // Cleanup for scalarrepl.
    FPM-&gt;add(createJumpThreadingPass());        // Thread jumps.
    FPM-&gt;add(createCFGSimplificationPass());    // Merge &amp; remove BBs
    //FPM-&gt;add(createInstructionCombiningPass()); // Combine silly seq's
    
    //FPM-&gt;add(createCFGSimplificationPass());    // Merge &amp; remove BBs
    FPM-&gt;add(createReassociatePass());          // Reassociate expressions
    //FPM-&gt;add(createEarlyCSEPass()); //// ****
    //FPM-&gt;add(createLoopIdiomPass()); //// ****
    FPM-&gt;add(createLoopRotatePass());           // Rotate loops.
    FPM-&gt;add(createLICMPass());                 // Hoist loop invariants
    FPM-&gt;add(createLoopUnswitchPass());         // Unswitch loops.
    FPM-&gt;add(createInstructionCombiningPass()); 
    FPM-&gt;add(createIndVarSimplifyPass());       // Canonicalize indvars
    //FPM-&gt;add(createLoopDeletionPass());         // Delete dead loops
    FPM-&gt;add(createLoopUnrollPass());           // Unroll small loops
    //FPM-&gt;add(createLoopStrengthReducePass());   // (jwb added)
    
    FPM-&gt;add(createInstructionCombiningPass()); // Clean up after the unroller
    FPM-&gt;add(createGVNPass());                  // Remove redundancies
    //FPM-&gt;add(createMemCpyOptPass());            // Remove memcpy / form memset  
    FPM-&gt;add(createSCCPPass());                 // Constant prop with SCCP
    
    // Run instcombine after redundancy elimination to exploit opportunities
    // opened up by them.
    //FPM-&gt;add(createSinkingPass()); ////////////// ****
    //FPM-&gt;add(createInstructionSimplifierPass());///////// ****
    FPM-&gt;add(createInstructionCombiningPass());
    FPM-&gt;add(createJumpThreadingPass());         // Thread jumps
    FPM-&gt;add(createDeadStoreEliminationPass());  // Delete dead stores
    FPM-&gt;add(createAggressiveDCEPass());         // Delete dead instructions
    FPM-&gt;add(createCFGSimplificationPass());     // Merge &amp; remove BBs

    FPM-&gt;doInitialization();
}
</t>
<t tx="ekr.20120404123906.7409">
extern "C" void jl_init_codegen(void)
{
#ifdef DEBUG
    llvm::JITEmitDebugInfo = true;
#endif
    llvm::NoFramePointerElim = true;
    llvm::NoFramePointerElimNonLeaf = true;

    InitializeNativeTarget();
    jl_Module = new Module("julia", jl_LLVMContext);
    jl_ExecutionEngine =
        EngineBuilder(jl_Module).setEngineKind(EngineKind::JIT).create();
    dbuilder = new DIBuilder(*jl_Module);

    init_julia_llvm_env(jl_Module);

    jl_jit_events = new JuliaJITEventListener();
    jl_ExecutionEngine-&gt;RegisterJITEventListener(jl_jit_events);

    BOX_F(int8,int32);  BOX_F(uint8,uint32);
    BOX_F(int16,int16); BOX_F(uint16,uint16);
    BOX_F(int32,int32); BOX_F(uint32,uint32);
    BOX_F(int64,int64); BOX_F(uint64,uint64);
    BOX_F(float32,float32); BOX_F(float64,float64);
    BOX_F(char,char);

    box8_func  = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int8),
                              "jl_box8", (void*)*jl_box8);
    box16_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int16),
                              "jl_box16", (void*)*jl_box16);
    box32_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int32),
                              "jl_box32", (void*)*jl_box32);
    box64_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int64),
                              "jl_box64", (void*)*jl_box64);

    std::vector&lt;Type*&gt; toptrargs(0);
    toptrargs.push_back(jl_pvalue_llvmt);
    toptrargs.push_back(jl_pvalue_llvmt);
    toptrargs.push_back(T_int32);
    value_to_pointer_func =
        Function::Create(FunctionType::get(T_pint8, toptrargs, false),
                         Function::ExternalLinkage, "jl_value_to_pointer",
                         jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(value_to_pointer_func,
                                         (void*)&amp;jl_value_to_pointer);

    temp_arg_area = (char*)malloc(arg_area_sz);
    arg_area_loc = 0;

    std::vector&lt;Type*&gt; noargs(0);
    save_arg_area_loc_func =
        Function::Create(FunctionType::get(T_uint64, noargs, false),
                         Function::ExternalLinkage, "save_arg_area_loc",
                         jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(save_arg_area_loc_func,
                                         (void*)&amp;save_arg_area_loc);

    restore_arg_area_loc_func =
        Function::Create(ft1arg(T_void, T_uint64),
                         Function::ExternalLinkage, "restore_arg_area_loc",
                         jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(restore_arg_area_loc_func,
                                         (void*)&amp;restore_arg_area_loc);
}
</t>
<t tx="ekr.20120404123906.7410">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7411">// --- storing and accessing source location metadata ---

struct FuncInfo{
    const Function* func;
    size_t lengthAdr;
    std::vector&lt;JITEvent_EmittedFunctionDetails::LineStart&gt; lines;
};

class JuliaJITEventListener: public JITEventListener
{
    std::map&lt;size_t, FuncInfo&gt; info;
    
public:	
    JuliaJITEventListener(){}
    virtual ~JuliaJITEventListener() {}
    
    virtual void NotifyFunctionEmitted(const Function &amp;F, void *Code,
                                       size_t Size, const EmittedFunctionDetails &amp;Details)
    {
        FuncInfo tmp = {&amp;F, Size, Details.LineStarts};
        info[(size_t)(Code)] = tmp;
    }
    
    std::map&lt;size_t, FuncInfo&gt; getMap()
    {
        return info;
    }
};

JuliaJITEventListener *jl_jit_events;

extern "C" void getFunctionInfo(const char **name, int *line, const char **filename,size_t pointer);

</t>
<t tx="ekr.20120404123906.7412">void getFunctionInfo(const char **name, int *line, const char **filename, size_t pointer)
{
    std::map&lt;size_t, FuncInfo&gt; info = jl_jit_events-&gt;getMap();
    *name = NULL;
    *line = -1;
    *filename = "no file";
    for (std::map&lt;size_t, FuncInfo&gt;::iterator it= info.begin(); it!= info.end(); it++) {
        if ((*it).first &lt;= pointer) {
            if ((size_t)(*it).first + (*it).second.lengthAdr &gt;= pointer) {
                *name = &amp;(*(*it).second.func).getNameStr()[0];
                
                if ((*it).second.lines.size() == 0) {
                    continue;
                }
                
                std::vector&lt;JITEvent_EmittedFunctionDetails::LineStart&gt;::iterator vit = (*it).second.lines.begin();
                JITEvent_EmittedFunctionDetails::LineStart prev = *vit;

                DISubprogram debugscope =
                    DISubprogram(prev.Loc.getScope((*it).second.func-&gt;getContext()));
                *filename = debugscope.getFilename().data();
                // the DISubprogram has the un-mangled name, so use that if
                // available.
                *name = debugscope.getName().data();
                
                vit++;
                
                while (vit != (*it).second.lines.end()) {
                    if (pointer &lt;= (*vit).Address) {
                        *line = prev.Loc.getLine();
                        break;
                    }
                    prev = *vit;
                    vit++;
                }
                if (*line == -1) {
                    *line = prev.Loc.getLine();
                }
                
                break;
            }
        }
    }
}
</t>
<t tx="ekr.20120404123906.7413">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7414">namespace JL_I {
    enum intrinsic {
        // wrap and unwrap
        boxui8=0, boxsi8, boxui16, boxsi16, boxui32, boxsi32, boxui64, boxsi64,
        boxf32, boxf64, box,
        unbox8, unbox16, unbox32, unbox64, unbox,
        // arithmetic
        neg_int, add_int, sub_int, mul_int,
        sdiv_int, udiv_int, srem_int, urem_int,
        neg_float, add_float, sub_float, mul_float, div_float, rem_float,
        // comparison
        eq_int,  ne_int,
        slt_int, ult_int,
        sle_int, ule_int,
        eq_float, ne_float,
        lt_float, le_float,
        eqfsi64, eqfui64,
        ltfsi64, ltfui64,
        lefsi64, lefui64,
        ltsif64, ltuif64,
        lesif64, leuif64,
        fpiseq32, fpiseq64,
        fpislt32, fpislt64,
        // bitwise operators
        and_int, or_int, xor_int, not_int, shl_int, lshr_int, ashr_int,
        bswap_int, ctpop_int, ctlz_int, cttz_int,
        // conversion
        sext16, zext16, sext32, zext32, sext64, zext64, zext_int,
        trunc8, trunc16, trunc32, trunc64, trunc_int,
        fptoui32, fptosi32, fptoui64, fptosi64, 
        fpsiround32, fpsiround64, fpuiround32, fpuiround64,
        uitofp32, sitofp32, uitofp64, sitofp64,
        fptrunc32, fpext64,
        // functions
        abs_float32, abs_float64,
        copysign_float32, copysign_float64,
        flipsign_int32, flipsign_int64,
        // c interface
        ccall,
    };
};

using namespace JL_I;

</t>
<t tx="ekr.20120404123906.7415">#include "ccall.cpp"

/*
  low-level intrinsics design:
  functions like add_int expect unboxed values of matching bit-length.
  every operation that can return an unboxed value does so.
  this maximizes opportunities for composing functions without
    unnecessary boxing.
  this means that box and unbox functions might do nothing except change
    the type tag of a value.
  boxing is delayed until absolutely necessary, and handled at the point
    where the box is needed.
*/

// convert int type to same-size float type
</t>
<t tx="ekr.20120404123906.7416">static Type *FT(Type *t)
{
    if (t-&gt;isFloatingPointTy())
        return t;
    if (t == T_int32) return T_float32;
    assert(t == T_int64);
    return T_float64;
}
</t>
<t tx="ekr.20120404123906.7417">
// reinterpret-cast to float
</t>
<t tx="ekr.20120404123906.7418">static Value *FP(Value *v)
{
    if (v-&gt;getType()-&gt;isFloatingPointTy())
        return v;
    return builder.CreateBitCast(v, FT(v-&gt;getType()));
}
</t>
<t tx="ekr.20120404123906.7419">
// convert float type to same-size int type
</t>
<t tx="ekr.20120404123906.7420">static Type *INTT(Type *t)
{
    if (t-&gt;isIntegerTy())
        return t;
    if (t-&gt;isPointerTy())
        return T_size;
    if (t == T_float32) return T_int32;
    assert(t == T_float64);
    return T_int64;
}
</t>
<t tx="ekr.20120404123906.7421">
// reinterpret-cast to int
</t>
<t tx="ekr.20120404123906.7422">static Value *INT(Value *v)
{
    Type *t = v-&gt;getType();
    if (t-&gt;isIntegerTy())
        return v;
    if (t-&gt;isPointerTy())
        return builder.CreatePtrToInt(v, INTT(t));
    return builder.CreateBitCast(v, INTT(t));
}
</t>
<t tx="ekr.20120404123906.7423">
static Value *uint_cnvt(Type *to, Value *x)
{
    Type *t = x-&gt;getType();
    if (t == to) return x;
    if (to-&gt;getPrimitiveSizeInBits() &lt; x-&gt;getType()-&gt;getPrimitiveSizeInBits())
        return builder.CreateTrunc(x, to);
    return builder.CreateZExt(x, to);
}
</t>
<t tx="ekr.20120404123906.7424">
static Value *emit_unboxed(jl_value_t *e, jl_codectx_t *ctx)
{
    if (jl_is_int32(e)) {
        return ConstantInt::get(T_int32, jl_unbox_int32(e));
    }
    else if (jl_is_int64(e)) {
        return ConstantInt::get(T_int64, jl_unbox_int64(e));
    }
    else if (jl_is_uint64(e)) {
        return mark_julia_type(ConstantInt::get(T_int64,
                                                (int64_t)jl_unbox_uint64(e)),
                               jl_uint64_type);
    }
    else if (jl_is_float64(e)) {
        return ConstantFP::get(T_float64, jl_unbox_float64(e));
    }
    else if (e == jl_true) {
        return ConstantInt::get(T_int1, 1);
    }
    else if (e == jl_false) {
        return ConstantInt::get(T_int1, 0);
    }
    else if (jl_is_bits_type(jl_typeof(e))) {
        jl_bits_type_t *bt = (jl_bits_type_t*)jl_typeof(e);
        int nb = jl_bitstype_nbits(bt);
        if (nb == 8)
            return mark_julia_type(ConstantInt::get(T_int8,
                                                    jl_unbox_int8(e)),
                                   (jl_value_t*)bt);
        if (nb == 16)
            return mark_julia_type(ConstantInt::get(T_int16,
                                                    jl_unbox_int16(e)),
                                   (jl_value_t*)bt);
        if (nb == 32)
            return mark_julia_type(ConstantInt::get(T_int32,
                                                    jl_unbox_int32(e)),
                                   (jl_value_t*)bt);
        if (nb == 64)
            return mark_julia_type(ConstantInt::get(T_int64,
                                                    jl_unbox_int64(e)),
                                   (jl_value_t*)bt);
        // TODO: bigger sizes
    }
    return emit_expr(e, ctx, true);
}
</t>
<t tx="ekr.20120404123906.7425">
// emit code to unpack a raw value from a box
</t>
<t tx="ekr.20120404123906.7426">static Value *emit_unbox(Type *to, Type *pto, Value *x)
{
    if (x-&gt;getType() != jl_pvalue_llvmt) {
        // bools are stored internally as int8 (for now), so we need to make
        // unbox8(x::Bool) work.
        if (x-&gt;getType() == T_int1 &amp;&amp; to == T_int8)
            return builder.CreateZExt(x, T_int8);
        if (x-&gt;getType()-&gt;isPointerTy() &amp;&amp; !to-&gt;isPointerTy())
            return builder.CreatePtrToInt(x, to);
        return x;
    }
    Value *p = bitstype_pointer(x);
    if (to == T_int1) {
        // bools stored as int8, so an extra Trunc is needed to get an int1
        return builder.CreateTrunc(builder.
                                   CreateLoad(builder.
                                              CreateBitCast(p, T_pint8), false),
                                   T_int1);
    }
    return builder.CreateLoad(builder.CreateBitCast(p, pto), false);
}
</t>
<t tx="ekr.20120404123906.7427">
// unbox trying to determine type automatically
</t>
<t tx="ekr.20120404123906.7428">static Value *auto_unbox(jl_value_t *x, jl_codectx_t *ctx)
{
    Value *v = emit_unboxed(x, ctx);
    if (v-&gt;getType() != jl_pvalue_llvmt) {
        if (v-&gt;getType() == T_int1)
            return builder.CreateZExt(v, T_int8);
        return INT(v);
    }
    jl_value_t *bt = expr_type(x, ctx);
    if (!jl_is_bits_type(bt)) {
        if (jl_is_symbol(x)) {
            bt = (*ctx-&gt;declTypes)[((jl_sym_t*)x)-&gt;name];
            if (bt == NULL || !jl_is_bits_type(bt)) {
                jl_error("auto_unbox: unable to determine argument type");
            }
        }
    }
    unsigned int nb = jl_bitstype_nbits(bt);
    Type *to = IntegerType::get(jl_LLVMContext, nb);
    return emit_unbox(to, PointerType::get(to, 0), v);
}
</t>
<t tx="ekr.20120404123906.7429">
// unbox using user-specified type
</t>
<t tx="ekr.20120404123906.7430">static Value *generic_unbox(jl_value_t *targ, jl_value_t *x, jl_codectx_t *ctx)
{
    jl_value_t *bt =
        jl_interpret_toplevel_expr_in(ctx-&gt;module, targ,
                                      &amp;jl_tupleref(ctx-&gt;sp,0),
                                      ctx-&gt;sp-&gt;length/2);
    if (!jl_is_bits_type(bt))
        jl_error("unbox: expected bits type as first argument");
    unsigned int nb = jl_bitstype_nbits(bt);
    Type *to = IntegerType::get(jl_LLVMContext, nb);
    return emit_unbox(to, PointerType::get(to, 0), emit_unboxed(x, ctx));
}
</t>
<t tx="ekr.20120404123906.7431">
static Value *generic_box(jl_value_t *targ, jl_value_t *x, jl_codectx_t *ctx)
{
    jl_value_t *bt =
        jl_interpret_toplevel_expr_in(ctx-&gt;module, targ,
                                      &amp;jl_tupleref(ctx-&gt;sp,0),
                                      ctx-&gt;sp-&gt;length/2);
    if (!jl_is_bits_type(bt))
        jl_error("box: expected bits type as first argument");
    unsigned int nb = jl_bitstype_nbits(bt);
    Value *vx = auto_unbox(x, ctx);
    if (vx-&gt;getType()-&gt;getPrimitiveSizeInBits() != nb)
        jl_errorf("box: expected argument with %d bits", nb);
    Type *llvmt = julia_type_to_llvm(bt, ctx);
    if (llvmt == NULL) {
        return literal_pointer_val(jl_nothing);
    }
    if (vx-&gt;getType() != llvmt) {
        if (vx-&gt;getType()-&gt;isPointerTy() &amp;&amp; !llvmt-&gt;isPointerTy()) {
            vx = builder.CreatePtrToInt(vx, llvmt);
        }
        else if (!vx-&gt;getType()-&gt;isPointerTy() &amp;&amp; llvmt-&gt;isPointerTy()) {
            vx = builder.CreateIntToPtr(vx, llvmt);
        }
        else {
            if (llvmt == T_int1)
                vx = builder.CreateTrunc(vx, llvmt);
            else
                vx = builder.CreateBitCast(vx, llvmt);
        }
    }
    return mark_julia_type(vx, bt);
}
</t>
<t tx="ekr.20120404123906.7432">
static Value *generic_trunc(jl_value_t *targ, jl_value_t *x, jl_codectx_t *ctx)
{
    jl_value_t *bt =
        jl_interpret_toplevel_expr_in(ctx-&gt;module, targ,
                                      &amp;jl_tupleref(ctx-&gt;sp,0),
                                      ctx-&gt;sp-&gt;length/2);
    if (!jl_is_bits_type(bt))
        jl_error("trunc_int: expected bits type as first argument");
    unsigned int nb = jl_bitstype_nbits(bt);
    Type *to = IntegerType::get(jl_LLVMContext, nb);
    return builder.CreateTrunc(INT(auto_unbox(x,ctx)), to);
}
</t>
<t tx="ekr.20120404123906.7433">
static Value *generic_zext(jl_value_t *targ, jl_value_t *x, jl_codectx_t *ctx)
{
    jl_value_t *bt =
        jl_interpret_toplevel_expr_in(ctx-&gt;module, targ,
                                      &amp;jl_tupleref(ctx-&gt;sp,0),
                                      ctx-&gt;sp-&gt;length/2);
    if (!jl_is_bits_type(bt))
        jl_error("zext_int: expected bits type as first argument");
    unsigned int nb = jl_bitstype_nbits(bt);
    Type *to = IntegerType::get(jl_LLVMContext, nb);
    return builder.CreateZExt(INT(auto_unbox(x,ctx)), to);
}
</t>
<t tx="ekr.20120404123906.7434">
#define HANDLE(intr,n)                                                  \
    case intr: if (nargs!=n) jl_error(#intr": wrong number of arguments");

</t>
<t tx="ekr.20120404123906.7435">static Value *emit_intrinsic(intrinsic f, jl_value_t **args, size_t nargs,
                             jl_codectx_t *ctx)
{
    if (f == ccall) return emit_ccall(args, nargs, ctx);
    if (f == box) {
        if (nargs!=2)
            jl_error("box: wrong number of arguments");
        return generic_box(args[1], args[2], ctx);
    }
    if (f == unbox) {
        if (nargs!=2)
            jl_error("unbox: wrong number of arguments");
        return generic_unbox(args[1], args[2], ctx);
    }
    if (f == trunc_int) {
        if (nargs!=2)
            jl_error("trunc_int: wrong number of arguments");
        return generic_trunc(args[1], args[2], ctx);
    }
    if (f == zext_int) {
        if (nargs!=2)
            jl_error("zext_int: wrong number of arguments");
        return generic_zext(args[1], args[2], ctx);
    }
    switch (f) {
        HANDLE(unbox8,1)
            return emit_unbox(T_int8, T_pint8, emit_unboxed(args[1],ctx));
        HANDLE(unbox16,1)
            return emit_unbox(T_int16, T_pint16, emit_unboxed(args[1],ctx));
        HANDLE(unbox32,1)
            return emit_unbox(T_int32, T_pint32, emit_unboxed(args[1],ctx));
        HANDLE(unbox64,1)
            return emit_unbox(T_int64, T_pint64, emit_unboxed(args[1],ctx));
    default: ;
    }
    if (nargs &lt; 1) jl_error("invalid intrinsic call");
    Value *x = auto_unbox(args[1], ctx);
    Value *y = NULL;
    if (nargs&gt;1) {
        y = auto_unbox(args[2], ctx);
    }
    Type *t = x-&gt;getType();
    Value *fy;
    Value *den;
    switch (f) {
    HANDLE(boxui8,1)
        if (t != T_int8) x = builder.CreateBitCast(x, T_int8);
        return mark_julia_type(x, jl_uint8_type);
    HANDLE(boxsi8,1)
        if (t != T_int8) x = builder.CreateBitCast(x, T_int8);
        return mark_julia_type(x, jl_int8_type);
    HANDLE(boxui16,1)
        if (t != T_int16) x = builder.CreateBitCast(x, T_int16);
        return mark_julia_type(x, jl_uint16_type);
    HANDLE(boxsi16,1)
        if (t != T_int16) x = builder.CreateBitCast(x, T_int16);
        return mark_julia_type(x, jl_int16_type);
    HANDLE(boxui32,1)
        if (t != T_int32) x = builder.CreateBitCast(x, T_int32);
        return mark_julia_type(x, jl_uint32_type);
    HANDLE(boxsi32,1)
        if (t != T_int32) x = builder.CreateBitCast(x, T_int32);
        return mark_julia_type(x, jl_int32_type);
    HANDLE(boxui64,1)
        if (t != T_int64) x = builder.CreateBitCast(x, T_int64);
        return mark_julia_type(x, jl_uint64_type);
    HANDLE(boxsi64,1)
        if (t != T_int64) x = builder.CreateBitCast(x, T_int64);
        return mark_julia_type(x, jl_int64_type);
    HANDLE(boxf32,1)
        if (t != T_float32) x = builder.CreateBitCast(x, T_float32);
        return mark_julia_type(x, jl_float32_type);
    HANDLE(boxf64,1)
        if (t != T_float64) x = builder.CreateBitCast(x, T_float64);
        return mark_julia_type(x, jl_float64_type);

    HANDLE(neg_int,1) return builder.CreateSub(ConstantInt::get(t, 0), INT(x));
    HANDLE(add_int,2) return builder.CreateAdd(INT(x), INT(y));
    HANDLE(sub_int,2) return builder.CreateSub(INT(x), INT(y));
    HANDLE(mul_int,2) return builder.CreateMul(INT(x), INT(y));
    HANDLE(sdiv_int,2)
        den = INT(y);
        call_error_func_unless(builder.CreateICmpNE(den,
                                                    ConstantInt::get(t,0)),
                               jldiverror_func, ctx);
        return builder.CreateSDiv(INT(x), den);
    HANDLE(udiv_int,2)
        den = INT(y);
        call_error_func_unless(builder.CreateICmpNE(den,
                                                    ConstantInt::get(t,0)),
                               jldiverror_func, ctx);
        return builder.CreateUDiv(INT(x), den);

    HANDLE(srem_int,2) return builder.CreateSRem(INT(x), INT(y));
    HANDLE(urem_int,2) return builder.CreateURem(INT(x), INT(y));

    HANDLE(neg_float,1) return builder.CreateFMul(ConstantFP::get(FT(t), -1.0), FP(x));
    HANDLE(add_float,2) return builder.CreateFAdd(FP(x), FP(y));
    HANDLE(sub_float,2) return builder.CreateFSub(FP(x), FP(y));
    HANDLE(mul_float,2) return builder.CreateFMul(FP(x), FP(y));
    HANDLE(div_float,2) return builder.CreateFDiv(FP(x), FP(y));
    HANDLE(rem_float,2) return builder.CreateFRem(FP(x), FP(y));

    HANDLE(eq_int,2)  return builder.CreateICmpEQ(INT(x), INT(y));
    HANDLE(ne_int,2)  return builder.CreateICmpNE(INT(x), INT(y));
    HANDLE(slt_int,2) return builder.CreateICmpSLT(INT(x), INT(y));
    HANDLE(ult_int,2) return builder.CreateICmpULT(INT(x), INT(y));
    HANDLE(sle_int,2) return builder.CreateICmpSLE(INT(x), INT(y));
    HANDLE(ule_int,2) return builder.CreateICmpULE(INT(x), INT(y));

    HANDLE(eq_float,2) return builder.CreateFCmpOEQ(FP(x), FP(y));
    HANDLE(ne_float,2) return builder.CreateFCmpUNE(FP(x), FP(y));
    HANDLE(lt_float,2) return builder.CreateFCmpOLT(FP(x), FP(y));
    HANDLE(le_float,2) return builder.CreateFCmpOLE(FP(x), FP(y));

    HANDLE(eqfsi64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateAnd(
            builder.CreateFCmpOEQ(x, builder.CreateSIToFP(fy, T_float64)),
            builder.CreateICmpEQ(
                fy, builder.CreateFPToSI(
                    builder.CreateSIToFP(fy, T_float64),
                    T_int64
                )
            )
        );
    }
    HANDLE(eqfui64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateAnd(
            builder.CreateFCmpOEQ(x, builder.CreateUIToFP(fy, T_float64)),
            builder.CreateICmpEQ(
                fy, builder.CreateFPToUI(
                    builder.CreateUIToFP(fy, T_float64),
                    T_int64
                )
            )
        );
    }
    HANDLE(ltfsi64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(x, builder.CreateSIToFP(fy, T_float64)),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(x, builder.CreateSIToFP(fy, T_float64)),
                builder.CreateICmpSGT(
                    fy, builder.CreateFPToSI(
                        builder.CreateSIToFP(fy, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(ltfui64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(x, builder.CreateUIToFP(fy, T_float64)),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(x, builder.CreateUIToFP(fy, T_float64)),
                builder.CreateICmpUGT(
                    fy, builder.CreateFPToUI(
                        builder.CreateUIToFP(fy, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(lefsi64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(x, builder.CreateSIToFP(fy, T_float64)),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(x, builder.CreateSIToFP(fy, T_float64)),
                builder.CreateICmpSGE(
                    fy, builder.CreateFPToSI(
                        builder.CreateSIToFP(fy, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(lefui64,2) {
        x = FP(x);
        fy = INT(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(x, builder.CreateUIToFP(fy, T_float64)),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(x, builder.CreateUIToFP(fy, T_float64)),
                builder.CreateICmpUGE(
                    fy, builder.CreateFPToUI(
                        builder.CreateUIToFP(fy, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(ltsif64,2) {
        x = INT(x);
        fy = FP(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(builder.CreateSIToFP(x, T_float64), fy),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(builder.CreateSIToFP(x, T_float64), fy),
                builder.CreateICmpSLT(
                    x, builder.CreateFPToSI(
                        builder.CreateSIToFP(x, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(ltuif64,2) {
        x = INT(x);
        fy = FP(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(builder.CreateUIToFP(x, T_float64), fy),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(builder.CreateUIToFP(x, T_float64), fy),
                builder.CreateICmpULT(
                    x, builder.CreateFPToUI(
                        builder.CreateUIToFP(x, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(lesif64,2) {
        x = INT(x);
        fy = FP(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(builder.CreateSIToFP(x, T_float64), fy),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(builder.CreateSIToFP(x, T_float64), fy),
                builder.CreateICmpSLE(
                    x, builder.CreateFPToSI(
                        builder.CreateSIToFP(x, T_float64),
                        T_int64
                    )
                )
            )
        );
    }
    HANDLE(leuif64,2) {
        x = INT(x);
        fy = FP(y);
        return builder.CreateOr(
            builder.CreateFCmpOLT(builder.CreateUIToFP(x, T_float64), fy),
            builder.CreateAnd(
                builder.CreateFCmpOEQ(builder.CreateUIToFP(x, T_float64), fy),
                builder.CreateICmpULE(
                    x, builder.CreateFPToUI(
                        builder.CreateUIToFP(x, T_float64),
                        T_int64
                    )
                )
            )
        );
    }

    HANDLE(fpiseq32,2) {
        x = FP(x);
        fy = FP(y);
        Value *xi = builder.CreateBitCast(x,  T_int32);
        Value *yi = builder.CreateBitCast(fy, T_int32);
        return builder.CreateOr(
            builder.CreateAnd(
                builder.CreateFCmpUNO(x, x),
                builder.CreateFCmpUNO(fy, fy)
            ),
            builder.CreateAnd(
                builder.CreateICmpEQ(xi, yi),
                builder.CreateFCmpORD(x, fy)
            )
        );
    }
    HANDLE(fpiseq64,2) {
        x = FP(x);
        fy = FP(y);
        Value *xi = builder.CreateBitCast(x,  T_int64);
        Value *yi = builder.CreateBitCast(fy, T_int64);
        return builder.CreateOr(
            builder.CreateAnd(
                builder.CreateFCmpUNO(x, x),
                builder.CreateFCmpUNO(fy, fy)
            ),
            builder.CreateAnd(
                builder.CreateICmpEQ(xi, yi),
                builder.CreateFCmpORD(x, fy)
            )
        );
    }
    HANDLE(fpislt32,2) {
        x = FP(x);
        fy = FP(y);
        Value *xi = builder.CreateBitCast(x,  T_int32);
        Value *yi = builder.CreateBitCast(fy, T_int32);
        return builder.CreateOr(
            builder.CreateAnd(
                builder.CreateFCmpORD(x, x),
                builder.CreateFCmpUNO(fy, fy)
            ),
            builder.CreateAnd(
                builder.CreateFCmpORD(x, fy),
                builder.CreateOr(
                    builder.CreateAnd(
                        builder.CreateICmpSGE(xi, ConstantInt::get(T_int32, 0)),
                        builder.CreateICmpSLT(xi, yi)
                    ),
                    builder.CreateAnd(
                        builder.CreateICmpSLT(xi, ConstantInt::get(T_int32, 0)),
                        builder.CreateICmpUGT(xi, yi)
                    )
                )
            )
        );
    }
    HANDLE(fpislt64,2) {
        x = FP(x);
        fy = FP(y);
        Value *xi = builder.CreateBitCast(x,  T_int64);
        Value *yi = builder.CreateBitCast(fy, T_int64);
        return builder.CreateOr(
            builder.CreateAnd(
                builder.CreateFCmpORD(x, x),
                builder.CreateFCmpUNO(fy, fy)
            ),
            builder.CreateAnd(
                builder.CreateFCmpORD(x, fy),
                builder.CreateOr(
                    builder.CreateAnd(
                        builder.CreateICmpSGE(xi, ConstantInt::get(T_int64, 0)),
                        builder.CreateICmpSLT(xi, yi)
                    ),
                    builder.CreateAnd(
                        builder.CreateICmpSLT(xi, ConstantInt::get(T_int64, 0)),
                        builder.CreateICmpUGT(xi, yi)
                    )
                )
            )
        );
    }

    HANDLE(and_int,2) return builder.CreateAnd(INT(x), INT(y));
    HANDLE(or_int,2)  return builder.CreateOr(INT(x), INT(y));
    HANDLE(xor_int,2) return builder.CreateXor(INT(x), INT(y));
    HANDLE(not_int,1) return builder.CreateXor(INT(x), ConstantInt::get(t, -1));
    HANDLE(shl_int,2) return builder.CreateShl(INT(x), uint_cnvt(t,INT(y)));
    HANDLE(lshr_int,2) return builder.CreateLShr(INT(x), uint_cnvt(t,INT(y)));
    HANDLE(ashr_int,2) return builder.CreateAShr(INT(x), uint_cnvt(t,INT(y)));
    HANDLE(bswap_int,1)
        x = INT(x);
        return builder.CreateCall(
            Intrinsic::getDeclaration(jl_Module, Intrinsic::bswap,
                                      ArrayRef&lt;Type*&gt;(x-&gt;getType())), x);
    HANDLE(ctpop_int,1)
        x = INT(x);
        return builder.CreateCall(
            Intrinsic::getDeclaration(jl_Module, Intrinsic::ctpop,
                                      ArrayRef&lt;Type*&gt;(x-&gt;getType())), x);
    HANDLE(ctlz_int,1)
        x = INT(x);
        return builder.CreateCall(
            Intrinsic::getDeclaration(jl_Module, Intrinsic::ctlz,
                                      ArrayRef&lt;Type*&gt;(x-&gt;getType())), x);
    HANDLE(cttz_int,1)
        x = INT(x);
        return builder.CreateCall(
            Intrinsic::getDeclaration(jl_Module, Intrinsic::cttz,
                                      ArrayRef&lt;Type*&gt;(x-&gt;getType())), x);

    HANDLE(sext16,1) return builder.CreateSExt(INT(x), T_int16);
    HANDLE(zext16,1) return builder.CreateZExt(INT(x), T_int16);
    HANDLE(sext32,1) return builder.CreateSExt(INT(x), T_int32);
    HANDLE(zext32,1) return builder.CreateZExt(INT(x), T_int32);
    HANDLE(sext64,1) return builder.CreateSExt(INT(x), T_int64);
    HANDLE(zext64,1) return builder.CreateZExt(INT(x), T_int64);
    HANDLE(trunc8,1) return builder.CreateTrunc(INT(x), T_int8);
    HANDLE(trunc16,1) return builder.CreateTrunc(INT(x), T_int16);
    HANDLE(trunc32,1) return builder.CreateTrunc(INT(x), T_int32);
    HANDLE(trunc64,1) return builder.CreateTrunc(INT(x), T_int64);
    HANDLE(fptoui32,1) return builder.CreateFPToUI(FP(x), T_int32);
    HANDLE(fptosi32,1) return builder.CreateFPToSI(FP(x), T_int32);
    HANDLE(fptoui64,1) return builder.CreateFPToUI(FP(x), T_int64);
    HANDLE(fptosi64,1) return builder.CreateFPToSI(FP(x), T_int64);
    HANDLE(fpsiround32,1)
    HANDLE(fpuiround32,1)
    {
        // itrunc(x + copysign(0.5,x))
        Value *bits = INT(x);
        // values with exponent &gt;= nbits are already integers, and this
        // rounding method doesn't always give the right answer there.
        Value *expo = builder.CreateAShr(bits, ConstantInt::get(T_int32,23));
        expo = builder.CreateAnd(expo, ConstantInt::get(T_int32,0xff));
        Value *isint = builder.CreateICmpSGE(expo,
                                             ConstantInt::get(T_int32,127+23));
        Value *half = builder.CreateBitCast(ConstantFP::get(T_float32, 0.5),
                                            T_int32);
        Value *signedhalf =
            builder.CreateOr(half,
                             builder.CreateAnd(bits,
                                               ConstantInt::get(T_int32,
                                                                BIT31)));
        Value *sum = builder.CreateFAdd(FP(x),
                                        builder.CreateBitCast(signedhalf,
                                                              T_float32));
        if (f == fpuiround32) {
            return builder.CreateSelect(isint,
                                        builder.CreateFPToUI(FP(x), T_int32),
                                        builder.CreateFPToUI(sum, T_int32));
        }
        else {
            return builder.CreateSelect(isint,
                                        builder.CreateFPToSI(FP(x), T_int32),
                                        builder.CreateFPToSI(sum, T_int32));
        }
    }
    HANDLE(fpsiround64,1)
    HANDLE(fpuiround64,1)
    {
        Value *bits = INT(x);
        Value *expo = builder.CreateAShr(bits, ConstantInt::get(T_int64,52));
        expo = builder.CreateAnd(expo, ConstantInt::get(T_int64,0x7ff));
        Value *isint = builder.CreateICmpSGE(expo,
                                             ConstantInt::get(T_int64,1023+52));
        Value *half = builder.CreateBitCast(ConstantFP::get(T_float64, 0.5),
                                            T_int64);
        Value *signedhalf =
            builder.CreateOr(half,
                             builder.CreateAnd(bits,
                                               ConstantInt::get(T_int64,
                                                                BIT63)));
        Value *sum = builder.CreateFAdd(FP(x),
                                        builder.CreateBitCast(signedhalf,
                                                              T_float64));
        if (f == fpuiround64) {
            return builder.CreateSelect(isint,
                                        builder.CreateFPToUI(FP(x), T_int64),
                                        builder.CreateFPToUI(sum, T_int64));
        }
        else {
            return builder.CreateSelect(isint,
                                        builder.CreateFPToSI(FP(x), T_int64),
                                        builder.CreateFPToSI(sum, T_int64));
        }
    }
    HANDLE(uitofp32,1)  return builder.CreateUIToFP(INT(x), T_float32);
    HANDLE(sitofp32,1)  return builder.CreateSIToFP(INT(x), T_float32);
    HANDLE(uitofp64,1)  return builder.CreateUIToFP(INT(x), T_float64);
    HANDLE(sitofp64,1)  return builder.CreateSIToFP(INT(x), T_float64);
    HANDLE(fptrunc32,1) return builder.CreateFPTrunc(FP(x), T_float32);
    HANDLE(fpext64,1)
        // when extending a float32 to a float64, we need to force
        // rounding to single precision first. the reason is that it's
        // fine to keep working in extended precision as long as it's
        // understood that everything is implicitly rounded to 23 bits,
        // but if we start looking at more bits we need to actually do the
        // rounding first instead of carrying around incorrect low bits.
        builder.CreateStore(FP(x), jlfloat32temp_var, true);
        return builder.CreateFPExt(builder.CreateLoad(jlfloat32temp_var, true),
                                   T_float64);

    HANDLE(abs_float32,1)
    {
        Value *bits = builder.CreateBitCast(FP(x), T_int32);
        Value *absbits = builder.CreateAnd(bits,
                                           ConstantInt::get(T_int32, ~BIT31));
        return builder.CreateBitCast(absbits, T_float32);
    }
    HANDLE(abs_float64,1)
    {
        Value *bits = builder.CreateBitCast(FP(x), T_int64);
        Value *absbits = builder.CreateAnd(bits,
                                           ConstantInt::get(T_int64, ~BIT63));
        return builder.CreateBitCast(absbits, T_float64);
    }
    HANDLE(copysign_float32,2)
    {
        fy = FP(y);
        Value *bits = builder.CreateBitCast(FP(x), T_int32);
        Value *sbits = builder.CreateBitCast(fy, T_int32);
        Value *rbits =
            builder.CreateOr(builder.CreateAnd(bits,
                                               ConstantInt::get(T_int32,
                                                                ~BIT31)),
                             builder.CreateAnd(sbits,
                                               ConstantInt::get(T_int32,
                                                                BIT31)));
        return builder.CreateBitCast(rbits, T_float32);
    }
    HANDLE(copysign_float64,2)
    {
        fy = FP(y);
        Value *bits = builder.CreateBitCast(FP(x), T_int64);
        Value *sbits = builder.CreateBitCast(fy, T_int64);
        Value *rbits =
            builder.CreateOr(builder.CreateAnd(bits,
                                               ConstantInt::get(T_int64,
                                                                ~BIT63)),
                             builder.CreateAnd(sbits,
                                               ConstantInt::get(T_int64,
                                                                BIT63)));
        return builder.CreateBitCast(rbits, T_float64);
    }
    HANDLE(flipsign_int32,2)
    {
        x = INT(x);
        fy = INT(y);
        ConstantInt *cx = dyn_cast&lt;ConstantInt&gt;(x);
        ConstantInt *cy = dyn_cast&lt;ConstantInt&gt;(fy);
        if (cx &amp;&amp; cy) {
            int32_t ix = cx-&gt;getSExtValue();
            int32_t iy = cy-&gt;getSExtValue();
            return ConstantInt::get(T_int32, iy &gt;= 0 ? ix : -ix);
        }
        if (cy) {
            int32_t iy = cy-&gt;getSExtValue();
            return iy &gt;= 0 ? x : builder.CreateSub(ConstantInt::get(T_int32,0), x);
        }
        Value *tmp = builder.CreateAShr(fy, ConstantInt::get(T_int32,31));
        return builder.CreateXor(builder.CreateAdd(x,tmp),tmp);
    }
    HANDLE(flipsign_int64,2)
    {
        x = INT(x);
        fy = INT(y);
        ConstantInt *cx = dyn_cast&lt;ConstantInt&gt;(x);
        ConstantInt *cy = dyn_cast&lt;ConstantInt&gt;(fy);
        if (cx &amp;&amp; cy) {
            int64_t ix = cx-&gt;getSExtValue();
            int64_t iy = cy-&gt;getSExtValue();
            return ConstantInt::get(T_int64, iy &gt;= 0 ? ix : -ix);
        }
        if (cy) {
            int64_t iy = cy-&gt;getSExtValue();
            return iy &gt;= 0 ? x : builder.CreateSub(ConstantInt::get(T_int64,0), x);
        }
        Value *tmp = builder.CreateAShr(fy, ConstantInt::get(T_int64,63));
        return builder.CreateXor(builder.CreateAdd(x,tmp),tmp);
    }
    default:
        assert(false);
    }
    assert(false);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7436">
#undef HANDLE

</t>
<t tx="ekr.20120404123906.7437">static Function *boxfunc_llvm(FunctionType *ft, const std::string &amp;cname,
                              void *addr)
{
    Function *f =
        Function::Create(ft, Function::ExternalLinkage, cname, jl_Module);
    jl_ExecutionEngine-&gt;addGlobalMapping(f, addr);
    return f;
}
</t>
<t tx="ekr.20120404123906.7438">
static FunctionType *ft1arg(Type *ret, Type *arg)
{
    std::vector&lt;Type*&gt; args1(0);
    args1.push_back(arg);
    return FunctionType::get(ret, args1, false);
}
</t>
<t tx="ekr.20120404123906.7439">
static FunctionType *ft2arg(Type *ret, Type *arg1, Type *arg2)
{
    std::vector&lt;Type*&gt; args2(0);
    args2.push_back(arg1);
    args2.push_back(arg2);
    return FunctionType::get(ret, args2, false);
}
</t>
<t tx="ekr.20120404123906.7440">
#define BOX_F(ct,jl_ct)                                                       \
    box_##ct##_func = boxfunc_llvm(ft1arg(jl_pvalue_llvmt, T_##jl_ct),     \
                                   "jl_box_"#ct, (void*)&amp;jl_box_##ct);

</t>
<t tx="ekr.20120404123906.7441">static void add_intrinsic(const std::string &amp;name, intrinsic f)
{
    jl_value_t *i = jl_box32(jl_intrinsic_type, (int32_t)f);
    jl_set_const(jl_core_module, jl_symbol((char*)name.c_str()), i);
}
</t>
<t tx="ekr.20120404123906.7442">
#define ADD_I(name) add_intrinsic(#name, name)

</t>
<t tx="ekr.20120404123906.7443">extern "C" void jl_init_intrinsic_functions(void)
{
    ADD_I(boxui8); ADD_I(boxsi8); ADD_I(boxui16); ADD_I(boxsi16);
    ADD_I(boxui32); ADD_I(boxsi32); ADD_I(boxui64); ADD_I(boxsi64);
    ADD_I(boxf32); ADD_I(boxf64); ADD_I(box); ADD_I(unbox);
    ADD_I(unbox8); ADD_I(unbox16); ADD_I(unbox32); ADD_I(unbox64);
    ADD_I(neg_int); ADD_I(add_int); ADD_I(sub_int); ADD_I(mul_int);
    ADD_I(sdiv_int); ADD_I(udiv_int); ADD_I(srem_int); ADD_I(urem_int);
    ADD_I(neg_float); ADD_I(add_float); ADD_I(sub_float); ADD_I(mul_float);
    ADD_I(div_float); ADD_I(rem_float);
    ADD_I(eq_int); ADD_I(ne_int);
    ADD_I(slt_int); ADD_I(ult_int);
    ADD_I(sle_int); ADD_I(ule_int);
    ADD_I(eq_float); ADD_I(ne_float);
    ADD_I(lt_float); ADD_I(le_float);
    ADD_I(eqfsi64); ADD_I(eqfui64);
    ADD_I(ltfsi64); ADD_I(ltfui64);
    ADD_I(lefsi64); ADD_I(lefui64);
    ADD_I(ltsif64); ADD_I(ltuif64);
    ADD_I(lesif64); ADD_I(leuif64);
    ADD_I(fpiseq32); ADD_I(fpiseq64);
    ADD_I(fpislt32); ADD_I(fpislt64);
    ADD_I(and_int); ADD_I(or_int); ADD_I(xor_int); ADD_I(not_int);
    ADD_I(shl_int); ADD_I(lshr_int); ADD_I(ashr_int); ADD_I(bswap_int);
    ADD_I(ctpop_int); ADD_I(ctlz_int); ADD_I(cttz_int);
    ADD_I(sext16); ADD_I(zext16); ADD_I(sext32); ADD_I(zext32);
    ADD_I(sext64); ADD_I(zext64); ADD_I(zext_int);
    ADD_I(trunc8); ADD_I(trunc16); ADD_I(trunc32); ADD_I(trunc64);
    ADD_I(trunc_int);
    ADD_I(fptoui32); ADD_I(fptosi32); ADD_I(fptoui64); ADD_I(fptosi64);
    ADD_I(fpsiround32); ADD_I(fpsiround64);
    ADD_I(fpuiround32); ADD_I(fpuiround64);
    ADD_I(uitofp32); ADD_I(sitofp32); ADD_I(uitofp64); ADD_I(sitofp64);
    ADD_I(fptrunc32); ADD_I(fpext64);
    ADD_I(abs_float32); ADD_I(abs_float64);
    ADD_I(copysign_float32); ADD_I(copysign_float64);
    ADD_I(flipsign_int32); ADD_I(flipsign_int64);
    ADD_I(ccall);
}
</t>
<t tx="ekr.20120404123906.7444"></t>
<t tx="ekr.20120404123906.7445">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7446">/*
  object constructors
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "newobj_internal.h"
#include "builtin_proto.h"

jl_value_t *jl_true;
jl_value_t *jl_false;

jl_tag_type_t *jl_undef_type;
jl_tvar_t     *jl_typetype_tvar;
jl_tag_type_t *jl_typetype_type;
jl_value_t    *jl_ANY_flag;
jl_struct_type_t *jl_function_type;
jl_struct_type_t *jl_box_type;
jl_type_t *jl_box_any_type;
jl_typename_t *jl_box_typename;

jl_struct_type_t *jl_typector_type;

jl_struct_type_t *jl_array_type;
jl_typename_t *jl_array_typename;
jl_type_t *jl_array_uint8_type;
jl_type_t *jl_array_any_type;
jl_struct_type_t *jl_weakref_type;
jl_struct_type_t *jl_ascii_string_type;
jl_struct_type_t *jl_utf8_string_type;
jl_struct_type_t *jl_expr_type;
jl_struct_type_t *jl_symbolnode_type;
jl_struct_type_t *jl_linenumbernode_type;
jl_struct_type_t *jl_labelnode_type;
jl_struct_type_t *jl_gotonode_type;
jl_struct_type_t *jl_quotenode_type;
jl_struct_type_t *jl_topnode_type;
jl_bits_type_t *jl_intrinsic_type;
jl_struct_type_t *jl_methtable_type;
jl_struct_type_t *jl_method_type;
jl_struct_type_t *jl_lambda_info_type;
jl_struct_type_t *jl_module_type;
jl_struct_type_t *jl_errorexception_type=NULL;
jl_struct_type_t *jl_typeerror_type;
jl_struct_type_t *jl_loaderror_type;
jl_struct_type_t *jl_backtrace_type;
jl_bits_type_t *jl_pointer_type;
jl_value_t *jl_an_empty_cell=NULL;
jl_value_t *jl_stackovf_exception;
jl_value_t *jl_divbyzero_exception;
jl_value_t *jl_undefref_exception;
jl_value_t *jl_interrupt_exception;
jl_value_t *jl_memory_exception;

jl_sym_t *call_sym;    jl_sym_t *dots_sym;
jl_sym_t *call1_sym;   jl_sym_t *module_sym;
jl_sym_t *quote_sym;   jl_sym_t *amp_sym;
jl_sym_t *top_sym;     jl_sym_t *colons_sym;
jl_sym_t *line_sym;    jl_sym_t *jl_continue_sym;
// head symbols for each expression type
jl_sym_t *goto_sym;    jl_sym_t *goto_ifnot_sym;
jl_sym_t *label_sym;   jl_sym_t *return_sym;
jl_sym_t *lambda_sym;  jl_sym_t *assign_sym;
jl_sym_t *null_sym;    jl_sym_t *body_sym;
jl_sym_t *macro_sym;   jl_sym_t *method_sym;
jl_sym_t *enter_sym;   jl_sym_t *leave_sym;
jl_sym_t *exc_sym;     jl_sym_t *error_sym;
jl_sym_t *static_typeof_sym;
jl_sym_t *new_sym;     jl_sym_t *multivalue_sym;
jl_sym_t *const_sym;   jl_sym_t *thunk_sym;
jl_sym_t *anonymous_sym;  jl_sym_t *underscore_sym;

</t>
<t tx="ekr.20120404123906.7447">DLLEXPORT jl_value_t *jl_new_struct(jl_struct_type_t *type, ...)
{
    if (type-&gt;instance != NULL) return type-&gt;instance;
    va_list args;
    size_t nf = type-&gt;names-&gt;length;
    size_t i;
    va_start(args, type);
    jl_value_t *jv = newobj((jl_type_t*)type, nf);
    for(i=0; i &lt; nf; i++) {
        ((jl_value_t**)jv)[i+1] = va_arg(args, jl_value_t*);
    }
    if (nf == 0) type-&gt;instance = jv;
    va_end(args);
    return jv;
}
</t>
<t tx="ekr.20120404123906.7448">
DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_struct_type_t *type)
{
    if (type-&gt;instance != NULL) return type-&gt;instance;
    size_t nf = type-&gt;names-&gt;length;
    size_t i;
    jl_value_t *jv = newobj((jl_type_t*)type, nf);
    for(i=0; i &lt; nf; i++) {
        ((jl_value_t**)jv)[i+1] = NULL;
    }
    if (nf == 0) type-&gt;instance = jv;
    return jv;
}
</t>
<t tx="ekr.20120404123906.7449">
DLLEXPORT jl_value_t *jl_new_structt(jl_struct_type_t *type, jl_tuple_t *t)
{
    assert(type-&gt;names-&gt;length == t-&gt;length);
    jl_value_t *jv = jl_new_struct_uninit(type);
    for(size_t i=0; i &lt; t-&gt;length; i++) {
        ((jl_value_t**)jv)[i+1] = jl_tupleref(t, i);
    }
    return jv;
}
</t>
<t tx="ekr.20120404123906.7450">
jl_tuple_t *jl_tuple(size_t n, ...)
{
    va_list args;
    size_t i;
    if (n == 0) return jl_null;
    va_start(args, n);
    jl_tuple_t *jv = (jl_tuple_t*)newobj((jl_type_t*)jl_tuple_type, n+1);
    jv-&gt;length = n;
    for(i=0; i &lt; n; i++) {
        jl_tupleset(jv, i, va_arg(args, jl_value_t*));
    }
    va_end(args);
    return jv;
}
</t>
<t tx="ekr.20120404123906.7451">
jl_tuple_t *jl_tuple1(void *a)
{
    jl_tuple_t *t = (jl_tuple_t*)alloc_3w();
    t-&gt;type = (jl_type_t*)jl_tuple_type;
    t-&gt;length = 1;
    jl_tupleset(t, 0, a);
    return t;
}
</t>
<t tx="ekr.20120404123906.7452">
jl_tuple_t *jl_tuple2(void *a, void *b)
{
    jl_tuple_t *t = (jl_tuple_t*)alloc_4w();
    t-&gt;type = (jl_type_t*)jl_tuple_type;
    t-&gt;length = 2;
    jl_tupleset(t, 0, a);
    jl_tupleset(t, 1, b);
    return t;
}
</t>
<t tx="ekr.20120404123906.7453">
jl_tuple_t *jl_alloc_tuple_uninit(size_t n)
{
    if (n == 0) return jl_null;
    jl_tuple_t *jv = (jl_tuple_t*)newobj((jl_type_t*)jl_tuple_type, n+1);
    jv-&gt;length = n;
    return jv;
}
</t>
<t tx="ekr.20120404123906.7454">
jl_tuple_t *jl_alloc_tuple(size_t n)
{
    if (n == 0) return jl_null;
    jl_tuple_t *jv = jl_alloc_tuple_uninit(n);
    size_t i;
    for(i=0; i &lt; n; i++) {
        jl_tupleset(jv, i, NULL);
    }
    return jv;
}
</t>
<t tx="ekr.20120404123906.7455">
jl_tuple_t *jl_tuple_append(jl_tuple_t *a, jl_tuple_t *b)
{
    jl_tuple_t *c = jl_alloc_tuple_uninit(a-&gt;length + b-&gt;length);
    size_t i=0, j;
    for(j=0; j &lt; a-&gt;length; j++) {
        jl_tupleset(c, i, jl_tupleref(a,j));
        i++;
    }
    for(j=0; j &lt; b-&gt;length; j++) {
        jl_tupleset(c, i, jl_tupleref(b,j));
        i++;
    }
    return c;
}
</t>
<t tx="ekr.20120404123906.7456">
jl_tuple_t *jl_tuple_fill(size_t n, jl_value_t *v)
{
    if (n==0) return jl_null;
    jl_tuple_t *tup = jl_alloc_tuple_uninit(n);
    size_t i;
    for(i=0; i &lt; n; i++) {
        jl_tupleset(tup, i, v);
    }
    return tup;
}
</t>
<t tx="ekr.20120404123906.7457">
DLLEXPORT jl_function_t *jl_new_closure(jl_fptr_t fptr, jl_value_t *env,
                                        jl_lambda_info_t *linfo)
{
    jl_function_t *f = (jl_function_t*)alloc_4w();
    f-&gt;type = (jl_type_t*)jl_function_type;
    f-&gt;fptr = (fptr!=NULL ? fptr : linfo-&gt;fptr);
    f-&gt;env = env;
    f-&gt;linfo = linfo;
    return f;
}
</t>
<t tx="ekr.20120404123906.7458">
DLLEXPORT
jl_lambda_info_t *jl_new_lambda_info(jl_value_t *ast, jl_tuple_t *sparams)
{
    jl_lambda_info_t *li =
        (jl_lambda_info_t*)newobj((jl_type_t*)jl_lambda_info_type,
                                  LAMBDA_INFO_NW);
    li-&gt;ast = ast;
    li-&gt;file = (jl_value_t*)null_sym;
    li-&gt;line = jl_box_long(0);
    if (ast != NULL &amp;&amp; jl_is_expr(ast)) {
        jl_expr_t *body1 = (jl_expr_t*)jl_exprarg(jl_lam_body((jl_expr_t*)ast),0);
        if (jl_is_expr(body1) &amp;&amp; ((jl_expr_t*)body1)-&gt;head == line_sym) {
            li-&gt;file = jl_exprarg(body1, 1);
            li-&gt;line = jl_exprarg(body1, 0);
        }
    }
    li-&gt;module = jl_current_module;
    li-&gt;sparams = sparams;
    li-&gt;tfunc = (jl_value_t*)jl_null;
    li-&gt;fptr = &amp;jl_trampoline;
    li-&gt;roots = NULL;
    li-&gt;functionObject = NULL;
    li-&gt;specTypes = NULL;
    li-&gt;inferred = jl_false;
    li-&gt;inInference = 0;
    li-&gt;inCompile = 0;
    li-&gt;unspecialized = NULL;
    li-&gt;specializations = NULL;
    li-&gt;name = anonymous_sym;
    return li;
}
</t>
<t tx="ekr.20120404123906.7459">
// symbols --------------------------------------------------------------------

static jl_sym_t *symtab = NULL;

</t>
<t tx="ekr.20120404123906.7460">static jl_sym_t *mk_symbol(const char *str)
{
    jl_sym_t *sym;
    size_t len = strlen(str);

    sym = (jl_sym_t*)malloc(sizeof(jl_sym_t)-sizeof(void*) + len + 1);
    sym-&gt;type = (jl_type_t*)jl_sym_type;
    sym-&gt;left = sym-&gt;right = NULL;
#ifdef __LP64__
    sym-&gt;hash = memhash(str, len)^0xAAAAAAAAAAAAAAAAL;
#else
    sym-&gt;hash = memhash32(str, len)^0xAAAAAAAA;
#endif
    strcpy(&amp;sym-&gt;name[0], str);
    return sym;
}
</t>
<t tx="ekr.20120404123906.7461">
static void unmark_symbols_(jl_sym_t *root)
{
    while (root != NULL) {
        root-&gt;type = (jl_type_t*)(((uptrint_t)root-&gt;type)&amp;~1UL);
        unmark_symbols_(root-&gt;left);
        root = root-&gt;right;
    }
}
</t>
<t tx="ekr.20120404123906.7462">
void jl_unmark_symbols(void) { unmark_symbols_(symtab); }
</t>
<t tx="ekr.20120404123906.7463">
static jl_sym_t **symtab_lookup(jl_sym_t **ptree, const char *str)
{
    int x;

    while(*ptree != NULL) {
        x = strcmp(str, (*ptree)-&gt;name);
        if (x == 0)
            return ptree;
        if (x &lt; 0)
            ptree = &amp;(*ptree)-&gt;left;
        else
            ptree = &amp;(*ptree)-&gt;right;
    }
    return ptree;
}
</t>
<t tx="ekr.20120404123906.7464">
jl_sym_t *jl_symbol(const char *str)
{
    jl_sym_t **pnode;

    pnode = symtab_lookup(&amp;symtab, str);
    if (*pnode == NULL)
        *pnode = mk_symbol(str);
    return *pnode;
}
</t>
<t tx="ekr.20120404123906.7465">
DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, int32_t len)
{
    char name[len+1];
    memcpy(name, str, len);
    name[len] = '\0';
    return jl_symbol(name);
}
</t>
<t tx="ekr.20120404123906.7466">
DLLEXPORT jl_sym_t *jl_get_root_symbol() { return symtab; }
</t>
<t tx="ekr.20120404123906.7467">
static uint32_t gs_ctr = 0;  // TODO: per-thread
</t>
<t tx="ekr.20120404123906.7468">uint32_t jl_get_gs_ctr(void) { return gs_ctr; }
</t>
<t tx="ekr.20120404123906.7469">void jl_set_gs_ctr(uint32_t ctr) { gs_ctr = ctr; }
</t>
<t tx="ekr.20120404123906.7470">
DLLEXPORT jl_sym_t *jl_gensym(void)
{
    static char name[16];
    char *n;
    n = uint2str(&amp;name[2], sizeof(name)-2, gs_ctr, 10);
    *(--n) = '#'; *(--n) = '#';
    gs_ctr++;
    return jl_symbol(n);
}
</t>
<t tx="ekr.20120404123906.7471">
// allocating types -----------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7472">jl_typename_t *jl_new_typename(jl_sym_t *name)
{
    jl_typename_t *tn=(jl_typename_t*)newobj((jl_type_t*)jl_typename_type, 3);
    tn-&gt;name = name;
    tn-&gt;primary = NULL;
    tn-&gt;cache = jl_null;
    return tn;
}
</t>
<t tx="ekr.20120404123906.7473">
static void unbind_tvars(jl_tuple_t *parameters)
{
    size_t i;
    for(i=0; i &lt; parameters-&gt;length; i++) {
        jl_tvar_t *tv = (jl_tvar_t*)jl_tupleref(parameters, i);
        if (jl_is_typevar(tv))
            tv-&gt;bound = 0;
    }
}
</t>
<t tx="ekr.20120404123906.7474">
jl_tag_type_t *jl_new_tagtype(jl_value_t *name, jl_tag_type_t *super,
                              jl_tuple_t *parameters)
{
    jl_typename_t *tn=NULL;
    JL_GC_PUSH(&amp;tn);

    if (jl_is_typename(name))
        tn = (jl_typename_t*)name;
    else
        tn = jl_new_typename((jl_sym_t*)name);
    jl_tag_type_t *t = (jl_tag_type_t*)newobj((jl_type_t*)jl_tag_kind,
                                              TAG_TYPE_NW);
    t-&gt;name = tn;
    t-&gt;super = super;
    unbind_tvars(parameters);
    t-&gt;parameters = parameters;
    t-&gt;fptr = NULL;
    t-&gt;env = NULL;
    t-&gt;linfo = NULL;
    if (t-&gt;name-&gt;primary == NULL)
        t-&gt;name-&gt;primary = (jl_value_t*)t;
    JL_GC_POP();
    return t;
}
</t>
<t tx="ekr.20120404123906.7475">
jl_function_t *jl_instantiate_method(jl_function_t *f, jl_tuple_t *sp);

</t>
<t tx="ekr.20120404123906.7476">void jl_add_constructors(jl_struct_type_t *t)
{
    if (t-&gt;name == jl_array_typename) {
        t-&gt;fptr = jl_f_no_function;
        return;
    }

    jl_initialize_generic_function((jl_function_t*)t, t-&gt;name-&gt;name);

    if (t-&gt;ctor_factory == (jl_value_t*)jl_nothing ||
        t-&gt;ctor_factory == (jl_value_t*)jl_null) {
        assert(t-&gt;parameters-&gt;length == 0);
    }
    else {
        assert(t-&gt;parameters-&gt;length &gt; 0);
        if (t != (jl_struct_type_t*)t-&gt;name-&gt;primary) {
            // instantiating
            assert(jl_is_function(t-&gt;ctor_factory));
            
            // add type's static parameters to the ctor factory
            size_t np = t-&gt;parameters-&gt;length;
            jl_tuple_t *sparams = jl_alloc_tuple_uninit(np*2);
            jl_function_t *cfactory = NULL;
            JL_GC_PUSH(&amp;sparams, &amp;cfactory);
            size_t i;
            for(i=0; i &lt; np; i++) {
                jl_tupleset(sparams, i*2+0,
                            jl_tupleref(((jl_struct_type_t*)t-&gt;name-&gt;primary)-&gt;parameters, i));
                jl_tupleset(sparams, i*2+1,
                            jl_tupleref(t-&gt;parameters, i));
            }
            cfactory = jl_instantiate_method((jl_function_t*)t-&gt;ctor_factory,
                                             sparams);
            cfactory-&gt;linfo-&gt;ast = jl_prepare_ast(cfactory-&gt;linfo,
                                                  cfactory-&gt;linfo-&gt;sparams);
            
            // call user-defined constructor factory on (type,)
            jl_value_t *cfargs[1] = { (jl_value_t*)t };
            jl_apply(cfactory, cfargs, 1);
            JL_GC_POP();
        }
    }
}
</t>
<t tx="ekr.20120404123906.7477">
JL_CALLABLE(jl_f_ctor_trampoline)
{
    jl_add_constructors((jl_struct_type_t*)F);
    return jl_apply((jl_function_t*)F, args, nargs);
}
</t>
<t tx="ekr.20120404123906.7478">
jl_struct_type_t *jl_new_struct_type(jl_sym_t *name, jl_tag_type_t *super,
                                     jl_tuple_t *parameters,
                                     jl_tuple_t *fnames, jl_tuple_t *ftypes)
{
    jl_typename_t *tn = jl_new_typename(name);
    JL_GC_PUSH(&amp;tn);
    jl_struct_type_t *t = (jl_struct_type_t*)newobj((jl_type_t*)jl_struct_kind,
                                                    STRUCT_TYPE_NW);
    t-&gt;name = tn;
    t-&gt;name-&gt;primary = (jl_value_t*)t;
    t-&gt;super = super;
    unbind_tvars(parameters);
    t-&gt;parameters = parameters;
    t-&gt;names = fnames;
    t-&gt;types = ftypes;
    t-&gt;fptr = jl_f_ctor_trampoline;
    t-&gt;env = (jl_value_t*)t;
    t-&gt;linfo = NULL;
    t-&gt;ctor_factory = (jl_value_t*)jl_null;
    t-&gt;instance = NULL;
    if (!jl_is_leaf_type((jl_value_t*)t))
        t-&gt;uid = 0;
    else
        t-&gt;uid = jl_assign_type_uid();
    JL_GC_POP();
    return t;
}
</t>
<t tx="ekr.20120404123906.7479">
extern int jl_boot_file_loaded;

</t>
<t tx="ekr.20120404123906.7480">jl_bits_type_t *jl_new_bitstype(jl_value_t *name, jl_tag_type_t *super,
                                jl_tuple_t *parameters, size_t nbits)
{
    jl_bits_type_t *t=NULL;
    jl_typename_t *tn=NULL;
    JL_GC_PUSH(&amp;t, &amp;tn);

    if (!jl_boot_file_loaded &amp;&amp; jl_is_symbol(name)) {
        // hack to avoid making two versions of basic types needed
        // during bootstrapping
        if (!strcmp(((jl_sym_t*)name)-&gt;name, "Int32"))
            t = jl_int32_type;
        else if (!strcmp(((jl_sym_t*)name)-&gt;name, "Int64"))
            t = jl_int64_type;
        else if (!strcmp(((jl_sym_t*)name)-&gt;name, "Bool"))
            t = jl_bool_type;
    }
    int makenew = (t==NULL);
    if (makenew) {
        t = (jl_bits_type_t*)newobj((jl_type_t*)jl_bits_kind, BITS_TYPE_NW);
        if (jl_is_typename(name))
            tn = (jl_typename_t*)name;
        else
            tn = jl_new_typename((jl_sym_t*)name);
        t-&gt;name = tn;
    }
    t-&gt;super = super;
    unbind_tvars(parameters);
    t-&gt;parameters = parameters;
    if (jl_int32_type != NULL)
        t-&gt;bnbits = jl_box_int32(nbits);
    else
        t-&gt;bnbits = (jl_value_t*)jl_null;
    t-&gt;nbits = nbits;
    if (!jl_is_leaf_type((jl_value_t*)t))
        t-&gt;uid = 0;
    else if (makenew)
        t-&gt;uid = jl_assign_type_uid();
    t-&gt;fptr = NULL;
    t-&gt;env = NULL;
    t-&gt;linfo = NULL;
    if (t-&gt;name-&gt;primary == NULL)
        t-&gt;name-&gt;primary = (jl_value_t*)t;
    JL_GC_POP();
    return t;
}
</t>
<t tx="ekr.20120404123906.7481">
jl_uniontype_t *jl_new_uniontype(jl_tuple_t *types)
{
    jl_uniontype_t *t = (jl_uniontype_t*)newobj((jl_type_t*)jl_union_kind, 1);
    // don't make unions of 1 type; Union(T)==T
    assert(types-&gt;length != 1);
    t-&gt;types = types;
    return t;
}
</t>
<t tx="ekr.20120404123906.7482">
// type constructor -----------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7483">jl_typector_t *jl_new_type_ctor(jl_tuple_t *params, jl_type_t *body)
{
    jl_typector_t *tc = (jl_typector_t*)newobj((jl_type_t*)jl_typector_type,2);
    unbind_tvars(params);
    tc-&gt;parameters = params;
    tc-&gt;body = body;
    return (jl_typector_t*)tc;
}
</t>
<t tx="ekr.20120404123906.7484">
// bits constructors ----------------------------------------------------------

#define BOXN_FUNC(nb,nw)                                        \
jl_value_t *jl_box##nb(jl_bits_type_t *t, int##nb##_t x)        \
{                                                               \
    assert(jl_is_bits_type(t));                                 \
    assert(jl_bitstype_nbits(t)/8 == sizeof(x));                \
    jl_value_t *v = alloc_##nw##w();                            \
    v-&gt;type = (jl_type_t*)t;                                    \
    *(int##nb##_t*)jl_bits_data(v) = x;                         \
    return v;                                                   \
}
</t>
<t tx="ekr.20120404123906.7485">BOXN_FUNC(8,  2)
BOXN_FUNC(16, 2)
BOXN_FUNC(32, 2)
#ifdef __LP64__
BOXN_FUNC(64, 2)
#else
BOXN_FUNC(64, 3)
#endif

#define UNBOX_FUNC(j_type,c_type)                                       \
c_type jl_unbox_##j_type(jl_value_t *v)                                 \
{                                                                       \
    assert(jl_is_bits_type(jl_typeof(v)));                              \
    assert(jl_bitstype_nbits(jl_typeof(v))/8 == sizeof(c_type));        \
    return *(c_type*)jl_bits_data(v);                                   \
}
</t>
<t tx="ekr.20120404123906.7486">UNBOX_FUNC(int8,   int8_t)
UNBOX_FUNC(uint8,  uint8_t)
UNBOX_FUNC(int16,  int16_t)
UNBOX_FUNC(uint16, uint16_t)
UNBOX_FUNC(int32,  int32_t)
UNBOX_FUNC(uint32, uint32_t)
UNBOX_FUNC(int64,  int64_t)
UNBOX_FUNC(uint64, uint64_t)
UNBOX_FUNC(bool,   int8_t)
UNBOX_FUNC(float32, float)
UNBOX_FUNC(float64, double)

#define BOX_FUNC(typ,c_type,pfx,nw)             \
jl_value_t *pfx##_##typ(c_type x)               \
{                                               \
    jl_value_t *v = alloc_##nw##w();            \
    v-&gt;type = (jl_type_t*)jl_##typ##_type;      \
    *(c_type*)jl_bits_data(v) = x;              \
    return v;                                   \
}
</t>
<t tx="ekr.20120404123906.7487">BOX_FUNC(float32, float,  jl_box, 2)
#ifdef __LP64__
BOX_FUNC(float64, double, jl_box, 2)
#else
BOX_FUNC(float64, double, jl_box, 3)
#endif

#define NBOX_C 1024

#define SIBOX_FUNC(typ,c_type,nw)                       \
static jl_value_t *boxed_##typ##_cache[NBOX_C];         \
jl_value_t *jl_box_##typ(c_type x)                      \
{                                                       \
    c_type idx = x+NBOX_C/2;                            \
    if ((u##c_type)idx &lt; (u##c_type)NBOX_C)             \
        return boxed_##typ##_cache[idx];                \
    jl_value_t *v = alloc_##nw##w();                    \
    v-&gt;type = (jl_type_t*)jl_##typ##_type;              \
    *(c_type*)jl_bits_data(v) = x;                      \
    return v;                                           \
}
</t>
<t tx="ekr.20120404123906.7488">#define UIBOX_FUNC(typ,c_type,nw)               \
static jl_value_t *boxed_##typ##_cache[NBOX_C]; \
jl_value_t *jl_box_##typ(c_type x)              \
{                                               \
    if (x &lt; NBOX_C)                             \
        return boxed_##typ##_cache[x];          \
    jl_value_t *v = alloc_##nw##w();            \
    v-&gt;type = (jl_type_t*)jl_##typ##_type;      \
    *(c_type*)jl_bits_data(v) = x;              \
    return v;                                   \
}
</t>
<t tx="ekr.20120404123906.7489">SIBOX_FUNC(int16,  int16_t, 2)
SIBOX_FUNC(int32,  int32_t, 2)
UIBOX_FUNC(uint16, uint16_t, 2)
UIBOX_FUNC(uint32, uint32_t, 2)
UIBOX_FUNC(char,   uint32_t, 2)
#ifdef __LP64__
SIBOX_FUNC(int64,  int64_t, 2)
UIBOX_FUNC(uint64, uint64_t, 2)
#else
SIBOX_FUNC(int64,  int64_t, 3)
UIBOX_FUNC(uint64, uint64_t, 3)
#endif

static jl_value_t *boxed_int8_cache[256];
jl_value_t *jl_box_int8(int32_t x)
{
    return boxed_int8_cache[(uint8_t)x];
}
</t>
<t tx="ekr.20120404123906.7490">static jl_value_t *boxed_uint8_cache[256];
</t>
<t tx="ekr.20120404123906.7491">jl_value_t *jl_box_uint8(uint32_t x)
{
    return boxed_uint8_cache[(uint8_t)x];
}
</t>
<t tx="ekr.20120404123906.7492">
void jl_init_int32_int64_cache(void)
{
    int64_t i;
    for(i=0; i &lt; NBOX_C; i++) {
        boxed_int32_cache[i]  = jl_box32(jl_int32_type, i-NBOX_C/2);
        boxed_int64_cache[i]  = jl_box64(jl_int64_type, i-NBOX_C/2);
    }
}
</t>
<t tx="ekr.20120404123906.7493">
void jl_init_box_caches(void)
{
    int64_t i;
    for(i=0; i &lt; 256; i++) {
        boxed_int8_cache[i]  = jl_box8(jl_int8_type, i);
        boxed_uint8_cache[i] = jl_box8(jl_uint8_type, i);
    }
    for(i=0; i &lt; NBOX_C; i++) {
        boxed_int16_cache[i]  = jl_box16(jl_int16_type, i-NBOX_C/2);
        boxed_uint16_cache[i] = jl_box16(jl_uint16_type, i);
        boxed_uint32_cache[i] = jl_box32(jl_uint32_type, i);
        boxed_char_cache[i]   = jl_box32(jl_char_type, i);
        boxed_uint64_cache[i] = jl_box64(jl_uint64_type, i);
    }
}
</t>
<t tx="ekr.20120404123906.7494">
#ifdef JL_GC_MARKSWEEP
</t>
<t tx="ekr.20120404123906.7495">void jl_mark_box_caches(void)
{
    int64_t i;
    for(i=0; i &lt; 256; i++) {
        jl_gc_markval(boxed_int8_cache[i]);
        jl_gc_markval(boxed_uint8_cache[i]);
    }
    for(i=0; i &lt; NBOX_C; i++) {
        jl_gc_markval(boxed_int16_cache[i]);
        jl_gc_markval(boxed_int32_cache[i]);
        jl_gc_markval(boxed_int64_cache[i]);
        jl_gc_markval(boxed_uint16_cache[i]);
        jl_gc_markval(boxed_uint32_cache[i]);
        jl_gc_markval(boxed_char_cache[i]);
        jl_gc_markval(boxed_uint64_cache[i]);
    }
}
</t>
<t tx="ekr.20120404123906.7496">#endif

</t>
<t tx="ekr.20120404123906.7497">jl_value_t *jl_box_bool(int8_t x)
{
    if (x)
        return jl_true;
    return jl_false;
}
</t>
<t tx="ekr.20120404123906.7498">
// Expr constructor for internal use ------------------------------------------

</t>
<t tx="ekr.20120404123906.7499">jl_expr_t *jl_exprn(jl_sym_t *head, size_t n)
{
    jl_array_t *ar = n==0 ? (jl_array_t*)jl_an_empty_cell : jl_alloc_cell_1d(n);
    JL_GC_PUSH(&amp;ar);
    jl_expr_t *ex = (jl_expr_t*)alloc_4w();
    ex-&gt;type = (jl_type_t*)jl_expr_type;
    ex-&gt;head = head;
    ex-&gt;args = ar;
    ex-&gt;etype = (jl_value_t*)jl_any_type;
    JL_GC_POP();
    return ex;
}
</t>
<t tx="ekr.20120404123906.7500">
// this constructor has to be built-in for bootstrapping, because we can't
// do anything without being able to make Exprs.
</t>
<t tx="ekr.20120404123906.7501">JL_CALLABLE(jl_f_new_expr)
{
    JL_NARGS(Expr, 3, 3);
    JL_TYPECHK(Expr, symbol, args[0]);
    if (!jl_typeis(args[1], (jl_value_t*)jl_array_any_type)) {
        jl_type_error("Expr", (jl_value_t*)jl_array_any_type, args[1]);
    }
    jl_expr_t *ex = (jl_expr_t*)alloc_4w();
    ex-&gt;type = (jl_type_t*)jl_expr_type;
    ex-&gt;head = (jl_sym_t*)args[0];
    ex-&gt;args = (jl_array_t*)args[1];
    ex-&gt;etype = args[2];
    return (jl_value_t*)ex;
}
</t>
<t tx="ekr.20120404123906.7502">
JL_CALLABLE(jl_f_new_box)
{
    JL_NARGS(Box, 1, 1);
    jl_value_t *box = (jl_value_t*)alloc_2w();
    box-&gt;type = jl_box_any_type;
    ((jl_value_t**)box)[1] = args[0];
    return box;
}
</t>
<t tx="ekr.20120404123906.7503">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7504">/*
  array constructors and primitives
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"

// array constructors ---------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7505">static jl_array_t *_new_array(jl_type_t *atype,
                              uint32_t ndims, size_t *dims)
{
    size_t i, tot, nel=1;
    int isunboxed=0, elsz;
    void *data;
    jl_array_t *a;

    for(i=0; i &lt; ndims; i++) {
        nel *= dims[i];
    }
    jl_type_t *el_type = (jl_type_t*)jl_tparam0(atype);

    isunboxed = jl_is_bits_type(el_type);
    if (isunboxed) {
        elsz = jl_bitstype_nbits(el_type)/8;
        tot = elsz * nel;
        if (elsz == 1) {
            // hidden 0 terminator for all byte arrays
            tot++;
        }
    }
    else {
        elsz = sizeof(void*);
        tot = sizeof(void*) * nel;
    }

    int ndimwords = (ndims &gt; 2 ? (ndims-2) : 0);
#ifndef __LP64__
    // on 32-bit, ndimwords must be odd to preserve 8-byte alignment
    ndimwords += (~ndimwords)&amp;1;
#endif
    if (tot &lt;= ARRAY_INLINE_NBYTES) {
        a = allocobj(sizeof(jl_array_t) + tot + (ndimwords-1)*sizeof(size_t));
        a-&gt;type = atype;
        data = (&amp;a-&gt;_space[0] + ndimwords*sizeof(size_t));
        if (tot &gt; 0 &amp;&amp; !isunboxed) {
            memset(data, 0, tot);
        }
    }
    else {
        a = allocobj(sizeof(jl_array_t) + (ndimwords-1)*sizeof(size_t));
        JL_GC_PUSH(&amp;a);
        a-&gt;type = atype;
        // temporarily initialize to make gc-safe
        a-&gt;data = NULL;
        a-&gt;length = 0;
        a-&gt;reshaped = 0;
        data = allocb(tot);
        if (!isunboxed)
            memset(data, 0, tot);
        JL_GC_POP();
    }

    a-&gt;data = data;
    if (elsz == 1) ((char*)data)[tot-1] = '\0';
    a-&gt;length = nel;
    a-&gt;ndims = ndims;
    a-&gt;reshaped = 0;
    a-&gt;elsize = elsz;
    if (ndims == 1) {
        a-&gt;nrows = nel;
        a-&gt;maxsize = nel;
        a-&gt;offset = 0;
    }
    else {
        size_t *adims = &amp;a-&gt;nrows;
        for(i=0; i &lt; ndims; i++)
            adims[i] = dims[i];
    }
    
    return a;
}
</t>
<t tx="ekr.20120404123906.7506">
jl_array_t *jl_reshape_array(jl_type_t *atype, jl_array_t *data,
                             jl_tuple_t *dims)
{
    size_t i;
    jl_array_t *a;
    size_t ndims = dims-&gt;length;

    int ndimwords = (ndims &gt; 2 ? (ndims-2) : 0);
#ifndef __LP64__
    // on 32-bit, ndimwords must be odd to preserve 8-byte alignment
    ndimwords += (~ndimwords)&amp;1;
#endif
    a = allocobj(sizeof(jl_array_t) + ndimwords*sizeof(size_t));
    a-&gt;type = atype;
    *((jl_array_t**)(&amp;a-&gt;_space[0] + ndimwords*sizeof(size_t))) = data;
    a-&gt;data = data-&gt;data;
    a-&gt;length = data-&gt;length;
    a-&gt;elsize = data-&gt;elsize;
    a-&gt;ndims = ndims;
    a-&gt;reshaped = 1;

    if (ndims == 1) {
        a-&gt;nrows = a-&gt;length;
        a-&gt;maxsize = a-&gt;length;
        a-&gt;offset = 0;
    }
    else {
        size_t *adims = &amp;a-&gt;nrows;
        for(i=0; i &lt; ndims; i++) {
            adims[i] = jl_unbox_long(jl_tupleref(dims, i));
        }
    }
    
    return a;
}
</t>
<t tx="ekr.20120404123906.7507">
jl_array_t *jl_new_array_(jl_type_t *atype, uint32_t ndims, size_t *dims)
{
    return _new_array(atype, ndims, dims);
}
</t>
<t tx="ekr.20120404123906.7508">
jl_array_t *jl_new_array(jl_type_t *atype, jl_tuple_t *dims)
{
    size_t ndims = dims-&gt;length;
    size_t *adims = alloca(ndims*sizeof(size_t));
    size_t i;
    for(i=0; i &lt; ndims; i++)
        adims[i] = jl_unbox_long(jl_tupleref(dims,i));
    return _new_array(atype, ndims, adims);
}
</t>
<t tx="ekr.20120404123906.7509">
jl_array_t *jl_alloc_array_1d(jl_type_t *atype, size_t nr)
{
    return _new_array(atype, 1, &amp;nr);
}
</t>
<t tx="ekr.20120404123906.7510">
jl_array_t *jl_alloc_array_2d(jl_type_t *atype, size_t nr, size_t nc)
{
    size_t d[2] = {nr, nc};
    return _new_array(atype, 2, &amp;d[0]);
}
</t>
<t tx="ekr.20120404123906.7511">
jl_array_t *jl_alloc_array_3d(jl_type_t *atype, size_t nr, size_t nc, size_t z)
{
    size_t d[3] = {nr, nc, z};
    return _new_array(atype, 3, &amp;d[0]);
}
</t>
<t tx="ekr.20120404123906.7512">
jl_array_t *jl_pchar_to_array(char *str, size_t len)
{
    jl_array_t *a = jl_alloc_array_1d(jl_array_uint8_type, len);
    memcpy(a-&gt;data, str, len);
    return a;
}
</t>
<t tx="ekr.20120404123906.7513">
jl_value_t *jl_array_to_string(jl_array_t *a)
{
    // TODO: check type of array?
    jl_struct_type_t* string_type = u8_isvalid(a-&gt;data, a-&gt;length) == 1 ? // ASCII
        jl_ascii_string_type : jl_utf8_string_type;
    return jl_apply((jl_function_t*)string_type, (jl_value_t**)&amp;a, 1);
}
</t>
<t tx="ekr.20120404123906.7514">
jl_value_t *jl_pchar_to_string(char *str, size_t len)
{
    jl_array_t *a = jl_pchar_to_array(str, len);
    JL_GC_PUSH(&amp;a);
    jl_value_t *s = jl_array_to_string(a);
    JL_GC_POP();
    return s;
}
</t>
<t tx="ekr.20120404123906.7515">
jl_value_t *jl_cstr_to_string(char *str)
{
    return jl_pchar_to_string(str, strlen(str));
}
</t>
<t tx="ekr.20120404123906.7516">
jl_array_t *jl_alloc_cell_1d(size_t n)
{
    return jl_alloc_array_1d(jl_array_any_type, n);
}
</t>
<t tx="ekr.20120404123906.7517">
// array primitives -----------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7518">JL_CALLABLE(jl_f_arraylen)
{
    JL_NARGS(arraylen, 1, 1);
    JL_TYPECHK(arraylen, array, args[0]);
    return jl_box_long(((jl_array_t*)args[0])-&gt;length);
}
</t>
<t tx="ekr.20120404123906.7519">
JL_CALLABLE(jl_f_arraysize)
{
    JL_TYPECHK(arraysize, array, args[0]);
    jl_array_t *a = (jl_array_t*)args[0];
    size_t nd = jl_array_ndims(a);
    if (nargs == 2) {
        JL_TYPECHK(arraysize, long, args[1]);
        int dno = jl_unbox_long(args[1]);
        if (dno &lt; 1)
            jl_error("arraysize: dimension out of range");
        if (dno &gt; nd)
            return jl_box_long(1);
        return jl_box_long((&amp;a-&gt;nrows)[dno-1]);
    }
    else {
        JL_NARGS(arraysize, 1, 1);
    }
    jl_tuple_t *d = jl_alloc_tuple(nd);
    JL_GC_PUSH(&amp;d);
    size_t i;
    for(i=0; i &lt; nd; i++)
        jl_tupleset(d, i, jl_box_long(jl_array_dim(a,i)));
    JL_GC_POP();
    return (jl_value_t*)d;
}
</t>
<t tx="ekr.20120404123906.7520">
static jl_value_t *new_scalar(jl_bits_type_t *bt)
{
    size_t nb = jl_bitstype_nbits(bt)/8;
    jl_value_t *v = 
        (jl_value_t*)allocobj((NWORDS(LLT_ALIGN(nb,sizeof(void*)))+1)*
                              sizeof(void*));
    v-&gt;type = (jl_type_t*)bt;
    return v;
}
</t>
<t tx="ekr.20120404123906.7521">
typedef struct {
    int64_t a;
    int64_t b;
} bits128_t;

</t>
<t tx="ekr.20120404123906.7522">jl_value_t *jl_arrayref(jl_array_t *a, size_t i)
{
    jl_type_t *el_type = (jl_type_t*)jl_tparam0(jl_typeof(a));
    jl_value_t *elt;
    if (jl_is_bits_type(el_type)) {
        if (el_type == (jl_type_t*)jl_bool_type) {
            if (((int8_t*)a-&gt;data)[i] != 0)
                return jl_true;
            return jl_false;
        }
        elt = new_scalar((jl_bits_type_t*)el_type);
        size_t nb = a-&gt;elsize;
        switch (nb) {
        case 1:
            *(int8_t*)jl_bits_data(elt)  = ((int8_t*)a-&gt;data)[i];  break;
        case 2:
            *(int16_t*)jl_bits_data(elt) = ((int16_t*)a-&gt;data)[i]; break;
        case 4:
            *(int32_t*)jl_bits_data(elt) = ((int32_t*)a-&gt;data)[i]; break;
        case 8:
            *(int64_t*)jl_bits_data(elt) = ((int64_t*)a-&gt;data)[i]; break;
        case 16:
            *(bits128_t*)jl_bits_data(elt) = ((bits128_t*)a-&gt;data)[i]; break;
        default:
            memcpy(jl_bits_data(elt), &amp;((char*)a-&gt;data)[i*nb], nb);
        }
    }
    else {
        elt = ((jl_value_t**)a-&gt;data)[i];
        if (elt == NULL) {
            jl_undef_ref_error();
        }
    }
    return elt;
}
</t>
<t tx="ekr.20120404123906.7523">
JL_CALLABLE(jl_f_arrayref)
{
    JL_NARGS(arrayref, 2, 2);
    JL_TYPECHK(arrayref, array, args[0]);
    JL_TYPECHK(arrayref, long, args[1]);
    jl_array_t *a = (jl_array_t*)args[0];
    size_t i = jl_unbox_long(args[1])-1;
    if (i &gt;= a-&gt;length) {
        jl_errorf("ref array[%d]: index out of range", i+1);
    }
    return jl_arrayref(a, i);
}
</t>
<t tx="ekr.20120404123906.7524">
void jl_arrayset(jl_array_t *a, size_t i, jl_value_t *rhs)
{
    jl_value_t *el_type = jl_tparam0(jl_typeof(a));
    if (el_type != (jl_value_t*)jl_any_type) {
        if (!jl_subtype(rhs, el_type, 1))
            jl_type_error("arrayset", el_type, rhs);
    }
    if (jl_is_bits_type(el_type)) {
        size_t nb = a-&gt;elsize;
        switch (nb) {
        case 1:
            ((int8_t*)a-&gt;data)[i]  = *(int8_t*)jl_bits_data(rhs);  break;
        case 2:
            ((int16_t*)a-&gt;data)[i] = *(int16_t*)jl_bits_data(rhs); break;
        case 4:
            ((int32_t*)a-&gt;data)[i] = *(int32_t*)jl_bits_data(rhs); break;
        case 8:
            ((int64_t*)a-&gt;data)[i] = *(int64_t*)jl_bits_data(rhs); break;
        case 16:
            ((bits128_t*)a-&gt;data)[i] = *(bits128_t*)jl_bits_data(rhs); break;
        default:
            memcpy(&amp;((char*)a-&gt;data)[i*nb], jl_bits_data(rhs), nb);
        }
    }
    else {
        ((jl_value_t**)a-&gt;data)[i] = rhs;
    }
}
</t>
<t tx="ekr.20120404123906.7525">
JL_CALLABLE(jl_f_arrayset)
{
    JL_NARGS(arrayset, 3, 3);
    JL_TYPECHK(arrayset, array, args[0]);
    JL_TYPECHK(arrayset, long, args[1]);
    jl_array_t *b = (jl_array_t*)args[0];
    size_t i = jl_unbox_long(args[1])-1;
    if (i &gt;= b-&gt;length) {
        jl_errorf("assign array[%d]: index out of range", i+1);
    }
    jl_arrayset(b, i, args[2]);
    return args[0];
}
</t>
<t tx="ekr.20120404123906.7526">
static void *array_new_buffer(jl_array_t *a, size_t newlen)
{
    size_t nbytes = newlen * a-&gt;elsize;
    if (a-&gt;elsize == 1) {
        nbytes++;
    }
    int isunboxed = jl_is_bits_type(jl_tparam0(jl_typeof(a)));
    char *newdata = allocb(nbytes);
    if (!isunboxed)
        memset(newdata, 0, nbytes);
    if (a-&gt;elsize == 1) newdata[nbytes-1] = '\0';
    return newdata;
}
</t>
<t tx="ekr.20120404123906.7527">
void jl_array_grow_end(jl_array_t *a, size_t inc)
{
    // optimized for the case of only growing and shrinking at the end
    size_t alen = a-&gt;length;
    if ((alen + inc) &gt; a-&gt;maxsize - a-&gt;offset) {
        size_t newlen = a-&gt;maxsize==0 ? (inc&lt;4?4:inc) : a-&gt;maxsize*2;
        while ((alen + inc) &gt; newlen - a-&gt;offset)
            newlen *= 2;
        char *newdata = array_new_buffer(a, newlen);
        size_t es = a-&gt;elsize;
        newdata += (a-&gt;offset*es);
        size_t anb = alen*es;
        memcpy(newdata, (char*)a-&gt;data, anb);
        if (es == 1) {
            memset(newdata + anb, 0, (newlen-a-&gt;offset-alen)*es);
        }
        a-&gt;maxsize = newlen;
        a-&gt;data = newdata;
    }
    a-&gt;length += inc; a-&gt;nrows += inc;
}
</t>
<t tx="ekr.20120404123906.7528">
void jl_array_del_end(jl_array_t *a, size_t dec)
{
    if (dec &gt; a-&gt;length)
        jl_error("array_del_end: index out of range");
    memset((char*)a-&gt;data + (a-&gt;length-dec)*a-&gt;elsize, 0, dec*a-&gt;elsize);
    a-&gt;length -= dec; a-&gt;nrows -= dec;
}
</t>
<t tx="ekr.20120404123906.7529">
void jl_array_grow_beg(jl_array_t *a, size_t inc)
{
    // designed to handle the case of growing and shrinking at both ends
    if (inc == 0)
        return;
    size_t es = a-&gt;elsize;
    size_t nb = inc*es;
    if (a-&gt;offset &gt;= inc) {
        a-&gt;data = (char*)a-&gt;data - nb;
        a-&gt;offset -= inc;
    }
    else {
        size_t alen = a-&gt;length;
        size_t anb = alen*es;
        char *newdata;
        if (inc &gt; (a-&gt;maxsize-alen)/2 - (a-&gt;maxsize-alen)/20) {
            size_t newlen = a-&gt;maxsize==0 ? 2*inc : a-&gt;maxsize*2;
            while (alen+2*inc &gt; newlen-a-&gt;offset)
                newlen *= 2;
            newdata = array_new_buffer(a, newlen);
            size_t center = (newlen - (alen + inc))/2;
            newdata += (center*es);
            a-&gt;maxsize = newlen;
            a-&gt;offset = center;
        }
        else {
            size_t center = (a-&gt;maxsize - (alen + inc))/2;
            newdata = (char*)a-&gt;data - es*a-&gt;offset + es*center;
            a-&gt;offset = center;
        }
        memmove(&amp;newdata[nb], a-&gt;data, anb);
        a-&gt;data = newdata;
    }
    a-&gt;length += inc; a-&gt;nrows += inc;
}
</t>
<t tx="ekr.20120404123906.7530">
void jl_array_del_beg(jl_array_t *a, size_t dec)
{
    if (dec == 0)
        return;
    if (dec &gt; a-&gt;length)
        jl_error("array_del_beg: index out of range");
    size_t es = a-&gt;elsize;
    size_t nb = dec*es;
    memset(a-&gt;data, 0, nb);
    size_t offset = a-&gt;offset;
    offset += dec;
    a-&gt;data = (char*)a-&gt;data + nb;
    a-&gt;length -= dec; a-&gt;nrows -= dec;

    // make sure offset doesn't grow forever due to deleting at beginning
    // and growing at end
    size_t newoffs = offset;
    if (offset &gt;= 13*a-&gt;maxsize/20) {
        newoffs = 17*(a-&gt;maxsize - a-&gt;length)/100;
    }
#ifdef __LP64__
    while (newoffs &gt; (size_t)((uint32_t)-1)) {
        newoffs = newoffs/2;
    }
#endif
    if (newoffs != offset) {
        size_t anb = a-&gt;length*es;
        size_t delta = (offset - newoffs)*es;
        a-&gt;data = (char*)a-&gt;data - delta;
        memmove(a-&gt;data, (char*)a-&gt;data + delta, anb);
    }
    a-&gt;offset = newoffs;
}
</t>
<t tx="ekr.20120404123906.7531">
void jl_cell_1d_push(jl_array_t *a, jl_value_t *item)
{
    assert(jl_typeis(a, jl_array_any_type));
    jl_array_grow_end(a, 1);
    jl_cellset(a, a-&gt;length-1, item);
}
</t>
<t tx="ekr.20120404123906.7532">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7533">/*
  AST
  interface to front-end, obtains and translates syntax trees
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "flisp.h"

static char flisp_system_image[] = {
#include "julia_flisp.boot.inc"
};

extern fltype_t *iostreamtype;

static jl_value_t *scm_to_julia(value_t e);
static value_t julia_to_scm(jl_value_t *v);

</t>
<t tx="ekr.20120404123906.7534">DLLEXPORT void jl_lisp_prompt(void)
{
    fl_applyn(1, symbol_value(symbol("__start")), fl_cons(FL_NIL,FL_NIL));
}
</t>
<t tx="ekr.20120404123906.7535">
value_t fl_defined_julia_global(value_t *args, uint32_t nargs)
{
    argcount("defined-julia-global", nargs, 1);
    (void)tosymbol(args[0], "defined-julia-global");
    char *name = symbol_name(args[0]);
    return jl_boundp(jl_current_module, jl_symbol(name)) ? FL_T : FL_F;
}
</t>
<t tx="ekr.20120404123906.7536">
value_t fl_invoke_julia_macro(value_t *args, uint32_t nargs)
{
    if (nargs &lt; 1)
        argcount("invoke-julia-macro", nargs, 1);
    (void)tosymbol(args[0], "invoke-julia-macro");
    jl_sym_t *name = jl_symbol(symbol_name(args[0]));
    jl_function_t *f = jl_get_expander(jl_current_module, name);
    if (f == NULL)
        return FL_F;
    jl_value_t **margs;
    int na = nargs-1;
    if (na &gt; 0)
        margs = alloca(na * sizeof(jl_value_t*));
    else
        margs = NULL;
    int i;
    for(i=0; i &lt; na; i++) margs[i] = NULL;
    JL_GC_PUSHARGS(margs, na);
    for(i=0; i &lt; na; i++) margs[i] = scm_to_julia(args[i+1]);
    jl_value_t *result;

    JL_TRY {
        result = jl_apply(f, margs, na);
    }
    JL_CATCH {
        JL_GC_POP();
        jl_show(jl_exception_in_transit);
        ios_putc('\n', jl_current_output_stream());
        return fl_cons(symbol("error"), FL_NIL);
    }
    // protect result from GC, otherwise it could be freed during future
    // macro expansions, since it will be referenced only from scheme and
    // not julia.
    // all calls to invoke-julia-macro happen under a single call to jl_expand,
    // so the preserved value stack is popped there.
    jl_gc_preserve(result);
    value_t scm = julia_to_scm(result);
    JL_GC_POP();
    return scm;
}
</t>
<t tx="ekr.20120404123906.7537">
static builtinspec_t julia_flisp_ast_ext[] = {
    { "defined-julia-global", fl_defined_julia_global },
    { "invoke-julia-macro", fl_invoke_julia_macro },
    { NULL, NULL }
};

static fltype_t *jvtype;

</t>
<t tx="ekr.20120404123906.7538">void jl_init_frontend(void)
{
    fl_init(2*512*1024);
    value_t img = cvalue(iostreamtype, sizeof(ios_t));
    ios_t *pi = value2c(ios_t*, img);
    ios_static_buffer(pi, flisp_system_image, sizeof(flisp_system_image));
    
    if (fl_load_system_image(img)) {
        ios_printf(ios_stderr, "fatal error loading system image\n");
        exit(1);
    }

    fl_applyn(0, symbol_value(symbol("__init_globals")));

    jvtype = define_opaque_type(symbol("julia_value"), sizeof(void*),
                                NULL, NULL);

    assign_global_builtins(julia_flisp_ast_ext);
}
</t>
<t tx="ekr.20120404123906.7539">
static jl_sym_t *scmsym_to_julia(value_t s)
{
    assert(issymbol(s));
    if (fl_isgensym(s)) {
        static char gsname[16];
        char *n = uint2str(&amp;gsname[1], sizeof(gsname)-1,
                           ((gensym_t*)ptr(s))-&gt;id, 10);
        *(--n) = '#';
        return jl_symbol(n);
    }
    return jl_symbol(symbol_name(s));
}
</t>
<t tx="ekr.20120404123906.7540">
static jl_value_t *scm_to_julia_(value_t e);

</t>
<t tx="ekr.20120404123906.7541">static jl_value_t *full_list(value_t e)
{
    size_t ln = llength(e);
    if (ln == 0) return jl_an_empty_cell;
    jl_array_t *ar = jl_alloc_cell_1d(ln);
    size_t i=0;
    while (iscons(e)) {
        jl_cellset(ar, i, scm_to_julia_(car_(e)));
        e = cdr_(e);
        i++;
    }
    return (jl_value_t*)ar;
}
</t>
<t tx="ekr.20120404123906.7542">
static jl_value_t *full_list_of_lists(value_t e)
{
    size_t ln = llength(e);
    if (ln == 0) return jl_an_empty_cell;
    jl_array_t *ar = jl_alloc_cell_1d(ln);
    size_t i=0;
    while (iscons(e)) {
        jl_cellset(ar, i, full_list(car_(e)));
        e = cdr_(e);
        i++;
    }
    return (jl_value_t*)ar;
}
</t>
<t tx="ekr.20120404123906.7543">
static jl_value_t *scm_to_julia(value_t e)
{
#ifdef JL_GC_MARKSWEEP
    int en = jl_gc_is_enabled();
    jl_gc_disable();
#endif
    jl_value_t *v = scm_to_julia_(e);
#ifdef JL_GC_MARKSWEEP
    if (en) jl_gc_enable();
#endif
    return v;
}
</t>
<t tx="ekr.20120404123906.7544">
static jl_value_t *scm_to_julia_(value_t e)
{
    if (fl_isnumber(e)) {
        if (iscprim(e)) {
            numerictype_t nt = cp_numtype((cprim_t*)ptr(e));
            switch (nt) {
            case T_DOUBLE:
                return (jl_value_t*)jl_box_float64(*(double*)cp_data((cprim_t*)ptr(e)));
            case T_INT64:
                return (jl_value_t*)jl_box_int64(*(int64_t*)cp_data((cprim_t*)ptr(e)));
            case T_UINT8:
                return (jl_value_t*)jl_box_uint8(*(uint8_t*)cp_data((cprim_t*)ptr(e)));
            case T_UINT16:
                return (jl_value_t*)jl_box_uint16(*(uint16_t*)cp_data((cprim_t*)ptr(e)));
            case T_UINT32:
                return (jl_value_t*)jl_box_uint32(*(uint32_t*)cp_data((cprim_t*)ptr(e)));
            case T_UINT64:
                return (jl_value_t*)jl_box_uint64(*(uint64_t*)cp_data((cprim_t*)ptr(e)));
            default:
                ;
            }
        }
        if (isfixnum(e)) {
            int64_t ne = numval(e);
#ifdef __LP64__
            return (jl_value_t*)jl_box_int64(ne);
#else
            if (ne &gt; S32_MAX || ne &lt; S32_MIN)
                return (jl_value_t*)jl_box_int64(ne);
            return (jl_value_t*)jl_box_int32((int32_t)ne);
#endif
        }
        uint64_t n = toulong(e, "scm_to_julia");
#ifdef __LP64__
        return (jl_value_t*)jl_box_int64((int64_t)n);
#else
        if (n &gt; S32_MAX)
            return (jl_value_t*)jl_box_int64((int64_t)n);
        return (jl_value_t*)jl_box_int32((int32_t)n);
#endif
    }
    if (issymbol(e)) {
        if (!fl_isgensym(e)) {
            char *sn = symbol_name(e);
            if (!strcmp(sn, "true"))
                return jl_true;
            else if (!strcmp(sn, "false"))
                return jl_false;
        }
        return (jl_value_t*)scmsym_to_julia(e);
    }
    if (fl_isstring(e)) {
        return jl_pchar_to_string(cvalue_data(e), cvalue_len(e));
    }
    if (e == FL_F) {
        return jl_false;
    }
    if (e == FL_T) {
        return jl_true;
    }
    if (e == FL_NIL) {
        return (jl_value_t*)jl_null;
    }
    if (iscons(e)) {
        value_t hd = car_(e);
        if (issymbol(hd)) {
            jl_sym_t *sym = scmsym_to_julia(hd);
            /* tree node types:
               goto  gotoifnot  label  return
               lambda  call  =  quote
               null  top  isbound  method
               body  file new
               line  enter  leave
            */
            size_t n = llength(e)-1;
            size_t i;
            if (sym == lambda_sym) {
                jl_expr_t *ex = jl_exprn(lambda_sym, n);
                e = cdr_(e);
                value_t largs = car_(e);
                jl_cellset(ex-&gt;args, 0, full_list(largs));
                e = cdr_(e);
                
                value_t ee = car_(e);
                jl_array_t *vinf = jl_alloc_cell_1d(3);
                jl_cellset(vinf, 0, full_list(car_(ee)));
                ee = cdr_(ee);
                jl_cellset(vinf, 1, full_list_of_lists(car_(ee)));
                ee = cdr_(ee);
                jl_cellset(vinf, 2, full_list_of_lists(car_(ee)));
                assert(!iscons(cdr_(ee)));
                jl_cellset(ex-&gt;args, 1, vinf);
                e = cdr_(e);
                
                for(i=2; i &lt; n; i++) {
                    assert(iscons(e));
                    jl_cellset(ex-&gt;args, i, scm_to_julia_(car_(e)));
                    e = cdr_(e);
                }
                return
                    (jl_value_t*)jl_new_lambda_info((jl_value_t*)ex, jl_null);
            }

            e = cdr_(e);
            if (sym == line_sym &amp;&amp; n==1) {
                return jl_new_struct(jl_linenumbernode_type,
                                     scm_to_julia_(car_(e)));
            }
            if (sym == label_sym) {
                return jl_new_struct(jl_labelnode_type,
                                     scm_to_julia_(car_(e)));
            }
            if (sym == goto_sym) {
                return jl_new_struct(jl_gotonode_type,
                                     scm_to_julia_(car_(e)));
            }
            if (sym == quote_sym) {
                return jl_new_struct(jl_quotenode_type,
                                     scm_to_julia_(car_(e)));
            }
            if (sym == top_sym) {
                return jl_new_struct(jl_topnode_type,
                                     scm_to_julia_(car_(e)));
            }
            jl_expr_t *ex = jl_exprn(sym, n);
            for(i=0; i &lt; n; i++) {
                assert(iscons(e));
                jl_cellset(ex-&gt;args, i, scm_to_julia_(car_(e)));
                e = cdr_(e);
            }
            return (jl_value_t*)ex;
        }
        else {
            jl_error("malformed tree");
        }
    }
    if (iscprim(e) &amp;&amp; cp_class((cprim_t*)ptr(e))==wchartype) {
        jl_value_t *wc =
            jl_box32(jl_char_type, *(int32_t*)cp_data((cprim_t*)ptr(e)));
        return wc;
    }
    if (iscvalue(e) &amp;&amp; cv_class((cvalue_t*)ptr(e)) == jvtype) {
        return *(jl_value_t**)cv_data((cvalue_t*)ptr(e));
    }
    jl_error("malformed tree");
    
    return (jl_value_t*)jl_null;
}
</t>
<t tx="ekr.20120404123906.7545">
static value_t array_to_list(jl_array_t *a)
{
    long i;
    value_t lst=FL_NIL, temp=FL_NIL;
    fl_gc_handle(&amp;lst);
    fl_gc_handle(&amp;temp);
    for(i=a-&gt;length-1; i &gt;= 0; i--) {
        temp = julia_to_scm(jl_cellref(a,i));
        lst = fl_cons(temp, lst);
    }
    fl_free_gc_handles(2);
    return lst;
}
</t>
<t tx="ekr.20120404123906.7546">
static value_t julia_to_scm(jl_value_t *v)
{
    if (jl_is_symbol(v)) {
        return symbol(((jl_sym_t*)v)-&gt;name);
    }
    if (v == jl_true) {
        return FL_T;
    }
    if (v == jl_false) {
        return FL_F;
    }
    if (jl_is_expr(v)) {
        jl_expr_t *ex = (jl_expr_t*)v;
        value_t args = array_to_list(ex-&gt;args);
        fl_gc_handle(&amp;args);
        value_t hd = julia_to_scm((jl_value_t*)ex-&gt;head);
        value_t scmv = fl_cons(hd, args);
        fl_free_gc_handles(1);
        return scmv;
    }
    if (jl_typeis(v, jl_linenumbernode_type)) {
        return fl_cons(julia_to_scm((jl_value_t*)line_sym),
                       fl_cons(julia_to_scm(jl_fieldref(v,0)),
                               FL_NIL));
    }
    if (jl_typeis(v, jl_labelnode_type)) {
        return fl_cons(julia_to_scm((jl_value_t*)label_sym),
                       fl_cons(julia_to_scm(jl_fieldref(v,0)),
                               FL_NIL));
    }
    if (jl_typeis(v, jl_gotonode_type)) {
        return fl_cons(julia_to_scm((jl_value_t*)goto_sym),
                       fl_cons(julia_to_scm(jl_fieldref(v,0)),
                               FL_NIL));
    }
    if (jl_typeis(v, jl_quotenode_type)) {
        return fl_cons(julia_to_scm((jl_value_t*)quote_sym),
                       fl_cons(julia_to_scm(jl_fieldref(v,0)),
                               FL_NIL));
    }
    if (jl_typeis(v, jl_topnode_type)) {
        return fl_cons(julia_to_scm((jl_value_t*)top_sym),
                       fl_cons(julia_to_scm(jl_fieldref(v,0)),
                               FL_NIL));
    }
    if (jl_is_long(v) &amp;&amp; fits_fixnum(jl_unbox_long(v))) {
        return fixnum(jl_unbox_long(v));
    }
    if (jl_typeis(v,jl_array_any_type)) {
        return array_to_list((jl_array_t*)v);
    }
    value_t opaque = cvalue(jvtype, sizeof(void*));
    *(jl_value_t**)cv_data((cvalue_t*)ptr(opaque)) = v;
    return opaque;
}
</t>
<t tx="ekr.20120404123906.7547">
// this is used to parse a line of repl input
</t>
<t tx="ekr.20120404123906.7548">DLLEXPORT jl_value_t *jl_parse_input_line(const char *str)
{
    value_t e = fl_applyn(1, symbol_value(symbol("jl-parse-string")),
                          cvalue_static_cstring(str));
    if (e == FL_T || e == FL_F || e == FL_EOF)
        return jl_nothing;
    
    return scm_to_julia(e);
}
</t>
<t tx="ekr.20120404123906.7549">
// this is for parsing one expression out of a string, keeping track of
// the current position.
</t>
<t tx="ekr.20120404123906.7550">DLLEXPORT jl_value_t *jl_parse_string(const char *str, int pos0, int greedy)
{
    value_t s = cvalue_static_cstring(str);
    value_t p = fl_applyn(3, symbol_value(symbol("jl-parse-one-string")),
                          s, fixnum(pos0), greedy?FL_T:FL_F);
    jl_value_t *expr=NULL, *pos1=NULL;
    JL_GC_PUSH(&amp;expr, &amp;pos1);

    value_t e = car_(p);
    if (e == FL_T || e == FL_F || e == FL_EOF) {
        expr = (jl_value_t*)jl_null;
    }
    else {
        expr = scm_to_julia(e);
    }

    pos1 = jl_box_long(toulong(cdr_(p),"parse"));
    jl_value_t *result = (jl_value_t*)jl_tuple2(expr, pos1);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7551">
jl_value_t *jl_parse_file(const char *fname)
{
    value_t e = fl_applyn(1, symbol_value(symbol("jl-parse-file")),
                          cvalue_static_cstring(fname));
    if (!iscons(e))
        return (jl_value_t*)jl_null;
    return scm_to_julia(e);
}
</t>
<t tx="ekr.20120404123906.7552">
void jl_load_file_string(const char *text)
{
    value_t e = fl_applyn(1, symbol_value(symbol("jl-parse-string-stream")),
                          cvalue_static_cstring(text));
    if (iscons(e)) {
        jl_value_t *fexpr = scm_to_julia(e);
        JL_GC_PUSH(&amp;fexpr);
        jl_load_file_expr("string", fexpr);
        JL_GC_POP();
    }
}
</t>
<t tx="ekr.20120404123906.7553">
// returns either an expression or a thunk
</t>
<t tx="ekr.20120404123906.7554">jl_value_t *jl_expand(jl_value_t *expr)
{
    int np = jl_gc_n_preserved_values();
    value_t arg = julia_to_scm(expr);
    value_t e = fl_applyn(1, symbol_value(symbol("jl-expand-to-thunk")), arg);
    jl_value_t *result;
    if (e == FL_T || e == FL_F || e == FL_EOF) {
        result = NULL;
    }
    else {
        result = scm_to_julia(e);
    }
    while (jl_gc_n_preserved_values() &gt; np) {
        jl_gc_unpreserve();
    }
    return result;
}
</t>
<t tx="ekr.20120404123906.7555">
// wrap expr in a thunk AST
</t>
<t tx="ekr.20120404123906.7556">jl_lambda_info_t *jl_wrap_expr(jl_value_t *expr)
{
    // `(lambda () (() () ()) ,expr)
    jl_expr_t *le=NULL, *bo=NULL; jl_value_t *vi=NULL;
    jl_value_t *mt = jl_an_empty_cell;
    JL_GC_PUSH(&amp;le, &amp;vi, &amp;bo);
    le = jl_exprn(lambda_sym, 3);
    jl_cellset(le-&gt;args, 0, mt);
    vi = (jl_value_t*)jl_alloc_cell_1d(3);
    jl_cellset(vi, 0, mt);
    jl_cellset(vi, 1, mt);
    jl_cellset(vi, 2, mt);
    jl_cellset(le-&gt;args, 1, vi);
    if (!jl_is_expr(expr) || ((jl_expr_t*)expr)-&gt;head != body_sym) {
        bo = jl_exprn(body_sym, 1);
        jl_cellset(bo-&gt;args, 0, (jl_value_t*)jl_exprn(return_sym, 1));
        jl_cellset(((jl_expr_t*)jl_exprarg(bo,0))-&gt;args, 0, expr);
        expr = (jl_value_t*)bo;
    }
    jl_cellset(le-&gt;args, 2, expr);
    jl_lambda_info_t *li = jl_new_lambda_info((jl_value_t*)le, jl_null);
    JL_GC_POP();
    return li;
}
</t>
<t tx="ekr.20120404123906.7557">
// syntax tree accessors

// get array of formal argument expressions
</t>
<t tx="ekr.20120404123906.7558">jl_array_t *jl_lam_args(jl_expr_t *l)
{
    assert(l-&gt;head == lambda_sym);
    jl_value_t *ae = jl_exprarg(l,0);
    assert(jl_is_array(ae));
    return (jl_array_t*)ae;
}
</t>
<t tx="ekr.20120404123906.7559">
// get array of local var symbols
</t>
<t tx="ekr.20120404123906.7560">jl_array_t *jl_lam_locals(jl_expr_t *l)
{
    jl_value_t *le = jl_exprarg(l, 1);
    assert(jl_is_array(le));
    jl_value_t *ll = jl_cellref(le, 0);
    assert(jl_is_array(ll));
    return (jl_array_t*)ll;
}
</t>
<t tx="ekr.20120404123906.7561">
// get array of var info records
</t>
<t tx="ekr.20120404123906.7562">jl_array_t *jl_lam_vinfo(jl_expr_t *l)
{
    jl_value_t *le = jl_exprarg(l, 1);
    assert(jl_is_array(le));
    jl_value_t *ll = jl_cellref(le, 1);
    assert(jl_is_array(ll));
    return (jl_array_t*)ll;
}
</t>
<t tx="ekr.20120404123906.7563">
// get array of var info records for captured vars
</t>
<t tx="ekr.20120404123906.7564">jl_array_t *jl_lam_capt(jl_expr_t *l)
{
    if (jl_is_tuple(l)) {
        // in compressed form
        return (jl_array_t*)jl_tupleref(l, 3);
    }
    assert(jl_is_expr(l));
    jl_value_t *le = jl_exprarg(l, 1);
    assert(jl_is_array(le));
    jl_value_t *ll = jl_cellref(le, 2);
    assert(jl_is_array(ll));
    return (jl_array_t*)ll;
}
</t>
<t tx="ekr.20120404123906.7565">
// get array of body forms
</t>
<t tx="ekr.20120404123906.7566">jl_expr_t *jl_lam_body(jl_expr_t *l)
{
    assert(jl_is_expr(l));
    jl_value_t *be = jl_exprarg(l, 2);
    assert(jl_is_expr(be));
    assert(((jl_expr_t*)be)-&gt;head == body_sym);
    return (jl_expr_t*)be;
}
</t>
<t tx="ekr.20120404123906.7567">
jl_sym_t *jl_decl_var(jl_value_t *ex)
{
    if (jl_is_symbol(ex)) return (jl_sym_t*)ex;
    assert(jl_is_expr(ex));
    return (jl_sym_t*)jl_exprarg(ex, 0);
}
</t>
<t tx="ekr.20120404123906.7568">
int jl_is_rest_arg(jl_value_t *ex)
{
    if (!jl_is_expr(ex)) return 0;
    if (((jl_expr_t*)ex)-&gt;head != colons_sym) return 0;
    jl_expr_t *atype = (jl_expr_t*)jl_exprarg(ex,1);
    if (!jl_is_expr(atype)) return 0;
    if (atype-&gt;head != call_sym || atype-&gt;args-&gt;length != 3)
        return 0;
    if ((jl_sym_t*)jl_exprarg(atype,1) != dots_sym)
        return 0;
    return 1;
}
</t>
<t tx="ekr.20120404123906.7569">
static jl_value_t *copy_ast(jl_value_t *expr, jl_tuple_t *sp)
{
    if (jl_is_symbol(expr)) {
        // pre-evaluate certain static parameters to help type inference
        for(int i=0; i &lt; sp-&gt;length; i+=2) {
            assert(jl_is_typevar(jl_tupleref(sp,i)));
            if ((jl_sym_t*)expr == ((jl_tvar_t*)jl_tupleref(sp,i))-&gt;name) {
                jl_value_t *spval = jl_tupleref(sp,i+1);
                if (jl_is_long(spval))
                    return spval;
            }
        }
    }
    else if (jl_is_lambda_info(expr)) {
        jl_lambda_info_t *li = (jl_lambda_info_t*)expr;
        /*
        if (sp == jl_null &amp;&amp; li-&gt;ast &amp;&amp;
            jl_lam_capt((jl_expr_t*)li-&gt;ast)-&gt;length == 0)
            return expr;
        */
        // TODO: avoid if above condition is true and decls have already
        // been evaluated.
        JL_GC_PUSH(&amp;li);
        li = jl_add_static_parameters(li, sp);
        li-&gt;ast = jl_prepare_ast(li, li-&gt;sparams);
        JL_GC_POP();
        return (jl_value_t*)li;
    }
    else if (jl_typeis(expr,jl_array_any_type)) {
        jl_array_t *a = (jl_array_t*)expr;
        jl_array_t *na = jl_alloc_cell_1d(a-&gt;length);
        JL_GC_PUSH(&amp;na);
        size_t i;
        for(i=0; i &lt; a-&gt;length; i++)
            jl_cellset(na, i, copy_ast(jl_cellref(a,i), sp));
        JL_GC_POP();
        return (jl_value_t*)na;
    }
    else if (jl_is_expr(expr)) {
        jl_expr_t *e = (jl_expr_t*)expr;
        jl_expr_t *ne = jl_exprn(e-&gt;head, e-&gt;args-&gt;length);
        JL_GC_PUSH(&amp;ne);
        size_t i;
        for(i=0; i &lt; e-&gt;args-&gt;length; i++)
            jl_exprarg(ne, i) = copy_ast(jl_exprarg(e,i), sp);
        JL_GC_POP();
        return (jl_value_t*)ne;
    }
    return expr;
}
</t>
<t tx="ekr.20120404123906.7570">
// TODO: eval decl types for arguments of non-generic functions
</t>
<t tx="ekr.20120404123906.7571">static void eval_decl_types(jl_array_t *vi, jl_tuple_t *spenv)
{
    size_t i;
    for(i=0; i &lt; vi-&gt;length; i++) {
        jl_array_t *v = (jl_array_t*)jl_cellref(vi, i);
        assert(v-&gt;length &gt; 1);
        jl_value_t *ty =
            jl_interpret_toplevel_expr_with(jl_cellref(v,1),
                                            &amp;jl_tupleref(spenv,0),
                                            spenv-&gt;length/2);
        jl_cellref(v, 1) = ty;
    }
}
</t>
<t tx="ekr.20120404123906.7572">
jl_tuple_t *jl_tuple_tvars_to_symbols(jl_tuple_t *t)
{
    jl_tuple_t *s = jl_alloc_tuple_uninit(t-&gt;length);
    size_t i;
    for(i=0; i &lt; s-&gt;length; i+=2) {
        assert(jl_is_typevar(jl_tupleref(t,i)));
        jl_tupleset(s, i,
                    (jl_value_t*)((jl_tvar_t*)jl_tupleref(t,i))-&gt;name);
        jl_tupleset(s, i+1, jl_tupleref(t,i+1));
    }
    return s;
}
</t>
<t tx="ekr.20120404123906.7573">
// given a new lambda_info with static parameter values, make a copy
// of the tree with declared types evaluated and static parameters passed
// on to all enclosed functions.
// this tree can then be further mutated by optimization passes.
</t>
<t tx="ekr.20120404123906.7574">DLLEXPORT
jl_value_t *jl_prepare_ast(jl_lambda_info_t *li, jl_tuple_t *sparams)
{
    jl_tuple_t *spenv = NULL;
    jl_value_t *l_ast = li-&gt;ast;
    if (l_ast == NULL) return NULL;
    jl_value_t *ast = l_ast;
    JL_GC_PUSH(&amp;spenv, &amp;ast);
    if (jl_is_tuple(ast))
        ast = jl_uncompress_ast((jl_tuple_t*)ast);
    spenv = jl_tuple_tvars_to_symbols(sparams);
    ast = copy_ast(ast, sparams);
    eval_decl_types(jl_lam_vinfo((jl_expr_t*)ast), spenv);
    eval_decl_types(jl_lam_capt((jl_expr_t*)ast), spenv);
    JL_GC_POP();
    return ast;
}
</t>
<t tx="ekr.20120404123906.7575">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7576">/*
  implementations of some built-in functions and utilities
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include "julia.h"
#include "builtin_proto.h"

// exceptions -----------------------------------------------------------------

DLLEXPORT char *julia_home = NULL;

</t>
<t tx="ekr.20120404123906.7577">void jl_error(const char *str)
{
    jl_value_t *msg = jl_pchar_to_string((char*)str, strlen(str));
    JL_GC_PUSH(&amp;msg);
    jl_raise(jl_new_struct(jl_errorexception_type, msg));
}
</t>
<t tx="ekr.20120404123906.7578">
void jl_errorf(const char *fmt, ...)
{
    char buf[1024];
    va_list args;
    va_start(args, fmt);
    int nc = vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    jl_value_t *msg = jl_pchar_to_string(buf, nc);
    JL_GC_PUSH(&amp;msg);
    jl_raise(jl_new_struct(jl_errorexception_type, msg));
}
</t>
<t tx="ekr.20120404123906.7579">
void jl_too_few_args(const char *fname, int min)
{
    // TODO: ArgumentError
    jl_errorf("%s: too few arguments (expected %d)", fname, min);
}
</t>
<t tx="ekr.20120404123906.7580">
void jl_too_many_args(const char *fname, int max)
{
    jl_errorf("%s: too many arguments (expected %d)", fname, max);
}
</t>
<t tx="ekr.20120404123906.7581">
void jl_type_error_rt(const char *fname, const char *context,
                      jl_value_t *ty, jl_value_t *got)
{
    jl_value_t *ctxt=NULL;
    JL_GC_PUSH(&amp;ctxt, &amp;got);
    ctxt = jl_pchar_to_string((char*)context, strlen(context));
    jl_value_t *ex = jl_new_struct(jl_typeerror_type, jl_symbol(fname),
                                   ctxt, ty, got);
    jl_raise(ex);
}
</t>
<t tx="ekr.20120404123906.7582">
void jl_type_error(const char *fname, jl_value_t *expected, jl_value_t *got)
{
    jl_type_error_rt(fname, "", expected, got);
}
</t>
<t tx="ekr.20120404123906.7583">
void jl_undef_ref_error(void)
{
    jl_raise(jl_undefref_exception);
}
</t>
<t tx="ekr.20120404123906.7584">
void jl_divide_by_zero_error(void)
{
    jl_raise(jl_divbyzero_exception);
}
</t>
<t tx="ekr.20120404123906.7585">
JL_CALLABLE(jl_f_throw)
{
    JL_NARGS(throw, 1, 1);
    jl_raise(args[0]);
    return (jl_value_t*)jl_null;
}
</t>
<t tx="ekr.20120404123906.7586">
void jl_enter_handler(jl_savestate_t *ss, jmp_buf *handlr)
{
    JL_SIGATOMIC_BEGIN();
    ss-&gt;eh_task = jl_current_task-&gt;state.eh_task;
    ss-&gt;eh_ctx = jl_current_task-&gt;state.eh_ctx;
    ss-&gt;bt = jl_current_task-&gt;state.bt;
    ss-&gt;ostream_obj = jl_current_task-&gt;state.ostream_obj;
    ss-&gt;current_output_stream = jl_current_task-&gt;state.current_output_stream;
    ss-&gt;prev = jl_current_task-&gt;state.prev;
#ifdef JL_GC_MARKSWEEP
    ss-&gt;gcstack = jl_pgcstack;
#endif

    jl_current_task-&gt;state.prev = ss;
    jl_current_task-&gt;state.eh_task = jl_current_task;
    jl_current_task-&gt;state.eh_ctx = handlr;
    jl_current_task-&gt;state.bt = 0;
    // TODO: this should really go after setjmp(). see comment in
    // ctx_switch in task.c.
    JL_SIGATOMIC_END();
}
</t>
<t tx="ekr.20120404123906.7587">
void jl_pop_handler(int n)
{
    while (n &gt; 0) {
        jl_eh_restore_state(jl_current_task-&gt;state.prev);
        n--;
    }
}
</t>
<t tx="ekr.20120404123906.7588">
// primitives -----------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7589">JL_CALLABLE(jl_f_is)
{
    JL_NARGS(is, 2, 2);
    if (args[0] == args[1])
        return jl_true;
    return jl_false;
}
</t>
<t tx="ekr.20120404123906.7590">
JL_CALLABLE(jl_f_no_function)
{
    jl_error("function not defined");
    return (jl_value_t*)jl_null;
}
</t>
<t tx="ekr.20120404123906.7591">
JL_CALLABLE(jl_f_typeof)
{
    JL_NARGS(typeof, 1, 1);
    return jl_full_type(args[0]);
}
</t>
<t tx="ekr.20120404123906.7592">
JL_CALLABLE(jl_f_subtype)
{
    JL_NARGS(subtype, 2, 2);
    if (!jl_is_typevar(args[0]))
        JL_TYPECHK(subtype, type, args[0]);
    if (!jl_is_typevar(args[1]))
        JL_TYPECHK(subtype, type, args[1]);
    return (jl_subtype(args[0],args[1],0) ? jl_true : jl_false);
}
</t>
<t tx="ekr.20120404123906.7593">
JL_CALLABLE(jl_f_isa)
{
    JL_NARGS(isa, 2, 2);
    JL_TYPECHK(isa, type, args[1]);
    return (jl_subtype(args[0],args[1],1) ? jl_true : jl_false);
}
</t>
<t tx="ekr.20120404123906.7594">
JL_CALLABLE(jl_f_typeassert)
{
    JL_NARGS(typeassert, 2, 2);
    JL_TYPECHK(typeassert, type, args[1]);
    if (!jl_subtype(args[0],args[1],1))
        jl_type_error("typeassert", args[1], args[0]);
    return args[0];
}
</t>
<t tx="ekr.20120404123906.7595">
static jl_function_t *jl_append_any_func;

</t>
<t tx="ekr.20120404123906.7596">JL_CALLABLE(jl_f_apply)
{
    JL_NARGSV(apply, 1);
    JL_TYPECHK(apply, function, args[0]);
    if (nargs == 2 &amp;&amp; jl_is_tuple(args[1])) {
        return jl_apply((jl_function_t*)args[0], &amp;jl_tupleref(args[1],0),
                        ((jl_tuple_t*)args[1])-&gt;length);
    }
    size_t n=0, i, j;
    for(i=1; i &lt; nargs; i++) {
        if (jl_is_tuple(args[i])) {
            n += ((jl_tuple_t*)args[i])-&gt;length;
        }
        else if (jl_typeis(args[i], jl_array_any_type)) {
            n += jl_array_len(args[i]);
        }
        else {
            if (jl_append_any_func == NULL) {
                jl_append_any_func =
                    (jl_function_t*)jl_get_global(jl_base_module,
                                                  jl_symbol("append_any"));
                if (jl_append_any_func == NULL) {
                    // error if append_any not available
                    JL_TYPECHK(apply, tuple, args[i]);
                }
            }
            goto fancy_apply;
        }
    }
    jl_value_t **newargs = alloca(n * sizeof(jl_value_t*));
    n = 0;
    for(i=1; i &lt; nargs; i++) {
        if (jl_is_tuple(args[i])) {
            jl_tuple_t *t = (jl_tuple_t*)args[i];
            for(j=0; j &lt; t-&gt;length; j++)
                newargs[n++] = jl_tupleref(t, j);
        }
        else {
            size_t al = jl_array_len(args[i]);
            for(j=0; j &lt; al; j++)
                newargs[n++] = jl_cellref(args[i], j);
        }
    }
    return jl_apply((jl_function_t*)args[0], newargs, n);

 fancy_apply: ;
    jl_value_t *argarr = jl_apply(jl_append_any_func, &amp;args[1], nargs-1);
    JL_GC_PUSH(&amp;argarr);
    assert(jl_typeis(argarr, jl_array_any_type));
    jl_value_t *result = jl_apply((jl_function_t*)args[0],
                                  jl_cell_data(argarr), jl_array_len(argarr));
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7597">
// eval -----------------------------------------------------------------------

jl_value_t *jl_toplevel_eval_flex(jl_value_t *e, int fast,
                                  volatile size_t *plineno);

</t>
<t tx="ekr.20120404123906.7598">jl_value_t *jl_eval_module_expr(jl_expr_t *ex, volatile size_t *plineno)
{
    assert(ex-&gt;head == module_sym);
    jl_module_t *last_module = jl_current_module;
    jl_sym_t *name = (jl_sym_t*)jl_exprarg(ex, 0);
    assert(jl_is_symbol(name));
    if (name == jl_current_module-&gt;name) {
        jl_errorf("module name %s conflicts with enclosing module", name-&gt;name);
    }
    jl_binding_t *b = jl_get_binding_wr(jl_current_module, name);
    jl_declare_constant(b);
    if (b-&gt;value != NULL) {
        ios_printf(ios_stderr, "Warning: redefinition of module %s ignored\n",
                   name-&gt;name);
        return jl_nothing;
    }
    jl_module_t *newm = jl_new_module(name);
    b-&gt;value = (jl_value_t*)newm;
    if (jl_current_module == jl_core_module &amp;&amp; name == jl_symbol("Base")) {
        // pick up Base module during bootstrap, and stay within it
        // after loading.
        jl_base_module = last_module = newm;
    }
    JL_GC_PUSH(&amp;last_module);
    jl_current_module = newm;
    // TODO: set up imports and exports

    jl_array_t *exprs = ((jl_expr_t*)jl_exprarg(ex, 1))-&gt;args;
    JL_TRY {
        for(int i=0; i &lt; exprs-&gt;length; i++) {
            // process toplevel form
            jl_value_t *form = jl_cellref(exprs, i);
            if (jl_is_linenode(form)) {
                if (plineno)
                    *plineno = jl_linenode_line(form);
            }
            else {
                (void)jl_toplevel_eval_flex(form, 0, plineno);
            }
        }
    }
    JL_CATCH {
        JL_GC_POP();
        jl_current_module = last_module;
        jl_raise(jl_exception_in_transit);
    }
    JL_GC_POP();
    jl_current_module = last_module;
    return jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7599">
static int is_intrinsic(jl_sym_t *s)
{
    jl_value_t *v = jl_get_global(jl_current_module, s);
    return (v != NULL &amp;&amp; jl_typeof(v)==(jl_type_t*)jl_intrinsic_type);
}
</t>
<t tx="ekr.20120404123906.7600">
static int has_intrinsics(jl_expr_t *e)
{
    if (e-&gt;args-&gt;length == 0)
        return 0;
    if (e-&gt;head == static_typeof_sym) return 1;
    jl_value_t *e0 = jl_exprarg(e,0);
    if (e-&gt;head == call_sym &amp;&amp;
        ((jl_is_symbol(e0) &amp;&amp; is_intrinsic((jl_sym_t*)e0)) ||
         (jl_is_topnode(e0) &amp;&amp; is_intrinsic((jl_sym_t*)jl_fieldref(e0,0)))))
        return 1;
    int i;
    for(i=0; i &lt; e-&gt;args-&gt;length; i++) {
        jl_value_t *a = jl_exprarg(e,i);
        if (jl_is_expr(a) &amp;&amp; has_intrinsics((jl_expr_t*)a))
            return 1;
    }
    return 0;
}
</t>
<t tx="ekr.20120404123906.7601">
// heuristic for whether a top-level input should be evaluated with
// the compiler or the interpreter.
</t>
<t tx="ekr.20120404123906.7602">static int eval_with_compiler_p(jl_expr_t *expr, int compileloops)
{
    assert(jl_is_expr(expr));
    if (expr-&gt;head==body_sym &amp;&amp; compileloops) {
        jl_array_t *body = expr-&gt;args;
        size_t i, maxlabl=0;
        // compile if there are backwards branches
        for(i=0; i &lt; body-&gt;length; i++) {
            jl_value_t *stmt = jl_cellref(body,i);
            if (jl_is_labelnode(stmt)) {
                int l = jl_labelnode_label(stmt);
                if (l &gt; maxlabl) maxlabl = l;
            }
        }
        size_t sz = (maxlabl+1+7)/8;
        char *labls = alloca(sz); memset(labls,0,sz);
        for(i=0; i &lt; body-&gt;length; i++) {
            jl_value_t *stmt = jl_cellref(body,i);
            if (jl_is_labelnode(stmt)) {
                int l = jl_labelnode_label(stmt);
                labls[l/8] |= (1&lt;&lt;(l&amp;7));
            }
            else if (compileloops &amp;&amp; jl_is_gotonode(stmt)) {
                int l = jl_gotonode_label(stmt);
                if (labls[l/8]&amp;(1&lt;&lt;(l&amp;7))) {
                    return 1;
                }
            }
            else if (jl_is_expr(stmt)) {
                if (compileloops &amp;&amp; ((jl_expr_t*)stmt)-&gt;head==goto_ifnot_sym) {
                    int l = jl_unbox_long(jl_exprarg(stmt,1));
                    if (labls[l/8]&amp;(1&lt;&lt;(l&amp;7))) {
                        return 1;
                    }
                }
                // to compile code that uses exceptions
                /*
                if (((jl_expr_t*)stmt)-&gt;head == enter_sym) {
                    return 1;
                }
                */
            }
        }
    }
    if (has_intrinsics(expr)) return 1;
    return 0;
}
</t>
<t tx="ekr.20120404123906.7603">
extern int jl_in_inference;

</t>
<t tx="ekr.20120404123906.7604">jl_value_t *jl_toplevel_eval_flex(jl_value_t *e, int fast,
                                  volatile size_t *plineno)
{
    //jl_show(ex);
    //ios_printf(ios_stdout, "\n");
    if (!jl_is_expr(e))
        return jl_interpret_toplevel_expr(e);

    jl_expr_t *ex = (jl_expr_t*)e;
    if (ex-&gt;head == null_sym || ex-&gt;head == error_sym) {
        // expression types simple enough not to need expansion
        return jl_interpret_toplevel_expr(e);
    }

    if (ex-&gt;head == module_sym) {
        return jl_eval_module_expr(ex, plineno);
    }

    jl_value_t *thunk=NULL;
    jl_value_t *result;
    jl_lambda_info_t *thk=NULL;
    int ewc = 0;
    JL_GC_PUSH(&amp;thunk, &amp;thk, &amp;ex);

    if (ex-&gt;head != body_sym &amp;&amp; ex-&gt;head != thunk_sym) {
        // not yet expanded
        ex = (jl_expr_t*)jl_expand(e);
    }

    if (jl_is_expr(ex) &amp;&amp; ex-&gt;head == thunk_sym) {
        thk = (jl_lambda_info_t*)jl_exprarg(ex,0);
        assert(jl_is_lambda_info(thk));
        ewc = eval_with_compiler_p(jl_lam_body((jl_expr_t*)thk-&gt;ast), fast);
        if (!ewc) {
            jl_array_t *vinfos = jl_lam_vinfo((jl_expr_t*)thk-&gt;ast);
            int i;
            for(i=0; i &lt; vinfos-&gt;length; i++) {
                if (jl_vinfo_capt((jl_array_t*)jl_cellref(vinfos,i))) {
                    // interpreter doesn't handle closure environment
                    ewc = 1;
                    break;
                }
            }
        }
    }
    else {
        if (jl_is_expr(ex) &amp;&amp; eval_with_compiler_p((jl_expr_t*)ex, fast)) {
            thk = jl_wrap_expr((jl_value_t*)ex);
            ewc = 1;
        }
        else {
            result = jl_interpret_toplevel_expr((jl_value_t*)ex);
            JL_GC_POP();
            return result;
        }
    }

    if (ewc) {
        thunk = (jl_value_t*)jl_new_closure(NULL, (jl_value_t*)jl_null, thk);
        if (!jl_in_inference) {
            jl_type_infer(thk, jl_tuple_type, thk);
        }
        result = jl_apply((jl_function_t*)thunk, NULL, 0);
    }
    else {
        result = jl_interpret_toplevel_thunk(thk);
    }
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7605">
jl_value_t *jl_toplevel_eval(jl_value_t *v)
{
    return jl_toplevel_eval_flex(v, 1, NULL);
}
</t>
<t tx="ekr.20120404123906.7606">
int asprintf(char **strp, const char *fmt, ...);

// load toplevel expressions, from (file ...)
</t>
<t tx="ekr.20120404123906.7607">void jl_load_file_expr(char *fname, jl_value_t *ast)
{
    jl_array_t *b = ((jl_expr_t*)ast)-&gt;args;
    size_t i;
    volatile size_t lineno=0;
    if (((jl_expr_t*)ast)-&gt;head == jl_continue_sym) {
        jl_errorf("syntax error: %s", jl_string_data(jl_exprarg(ast,0)));
    }
    char oldcwd[512];
    char newcwd[512];
    get_cwd(oldcwd, sizeof(oldcwd));
    char *sep = strrchr(fname, PATHSEP);
    if (sep) {
        size_t n = (sep - fname)+1;
        if (n &gt; sizeof(newcwd)-1) n = sizeof(newcwd)-1;
        strncpy(newcwd, fname, n);
        newcwd[n] = '\0';
        set_cwd(newcwd);
    }
    JL_TRY {
        jl_register_toplevel_eh();
        // handle syntax error
        if (((jl_expr_t*)ast)-&gt;head == error_sym) {
            jl_interpret_toplevel_expr(ast);
        }
        for(i=0; i &lt; b-&gt;length; i++) {
            // process toplevel form
            jl_value_t *form = jl_cellref(b, i);
            if (jl_is_linenode(form)) {
                lineno = jl_linenode_line(form);
            }
            else {
                (void)jl_toplevel_eval_flex(form, 0, &amp;lineno);
            }
        }
    }
    JL_CATCH {
        if (sep) set_cwd(oldcwd);
        jl_value_t *fn=NULL, *ln=NULL;
        JL_GC_PUSH(&amp;fn, &amp;ln);
        fn = jl_pchar_to_string(fname, strlen(fname));
        ln = jl_box_long(lineno);
        jl_raise(jl_new_struct(jl_loaderror_type, fn, ln,
                               jl_exception_in_transit));
    }
    if (sep) set_cwd(oldcwd);
}
</t>
<t tx="ekr.20120404123906.7608">
// fpath needs to be freed if != fname
</t>
<t tx="ekr.20120404123906.7609">char *jl_find_file_in_path(const char *fname)
{
    char *fpath = (char*)fname;
    int fid = open (fpath, O_RDONLY);
    // try adding julia home
    if (fid == -1 &amp;&amp; julia_home &amp;&amp; fname[0] != '/') {
        asprintf(&amp;fpath, "%s/%s", julia_home, fname);
        fid = open (fpath, O_RDONLY);
    }
    if (fid == -1) {
        if (fpath != fname) free(fpath);
        if (jl_errorexception_type == NULL) {
            ios_printf(ios_stderr, "could not open file %s\n", fname);
            exit(1);
        }
        else {
            jl_errorf("could not open file %s", fname);
        }
    }
    close(fid);

    return fpath;
}
</t>
<t tx="ekr.20120404123906.7610">
void jl_load(const char *fname)
{
    char *fpath = jl_find_file_in_path(fname);
    jl_value_t *ast = jl_parse_file(fpath);
    if (ast == (jl_value_t*)jl_null)  {
        if (fpath != fname) free(fpath);
	jl_errorf("could not open file %s", fpath);
    }
    JL_GC_PUSH(&amp;ast);
    jl_load_file_expr(fpath, ast);
    JL_GC_POP();
    if (fpath != fname) free(fpath);
}
</t>
<t tx="ekr.20120404123906.7611">
DLLEXPORT void jl_load_(jl_value_t *str)
{
    jl_load(jl_string_data(str));
}
</t>
<t tx="ekr.20120404123906.7612">
JL_CALLABLE(jl_f_top_eval)
{
    if (nargs == 1) {
        return jl_toplevel_eval(args[0]);
    }
    if (nargs != 2) {
        JL_NARGS(eval, 1, 1);
    }
    JL_TYPECHK(eval, module, args[0]);
    jl_module_t *m = (jl_module_t*)args[0];
    if (jl_is_symbol(args[1])) {
        return jl_eval_global_var(m, (jl_sym_t*)args[1]);
    }
    return jl_interpret_toplevel_expr_in(m, args[1], NULL, 0);
}
</t>
<t tx="ekr.20120404123906.7613">
JL_CALLABLE(jl_f_isbound)
{
    jl_module_t *m = jl_current_module;
    jl_sym_t *s=NULL;
    if (nargs == 1) {
        JL_TYPECHK(isbound, symbol, args[0]);
        s = (jl_sym_t*)args[0];
    }
    if (nargs != 2) {
        JL_NARGS(isbound, 1, 1);
    }
    else {
        JL_TYPECHK(isbound, module, args[0]);
        JL_TYPECHK(isbound, symbol, args[1]);
        m = (jl_module_t*)args[0];
        s = (jl_sym_t*)args[1];
    }
    assert(s);
    return jl_boundp(m, s) ? jl_true : jl_false;
}
</t>
<t tx="ekr.20120404123906.7614">
// tuples ---------------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7615">JL_CALLABLE(jl_f_tuple)
{
    size_t i;
    if (nargs == 0) return (jl_value_t*)jl_null;
    jl_tuple_t *t = jl_alloc_tuple_uninit(nargs);
    for(i=0; i &lt; nargs; i++) {
        jl_tupleset(t, i, args[i]);
    }
    return (jl_value_t*)t;
}
</t>
<t tx="ekr.20120404123906.7616">
JL_CALLABLE(jl_f_tupleref)
{
    JL_NARGS(tupleref, 2, 2);
    JL_TYPECHK(tupleref, tuple, args[0]);
    JL_TYPECHK(tupleref, long, args[1]);
    jl_tuple_t *t = (jl_tuple_t*)args[0];
    size_t i = jl_unbox_long(args[1])-1;
    if (i &gt;= t-&gt;length)
        jl_error("tupleref: index out of range");
    return jl_tupleref(t, i);
}
</t>
<t tx="ekr.20120404123906.7617">
JL_CALLABLE(jl_f_tuplelen)
{
    JL_NARGS(tuplelen, 1, 1);
    JL_TYPECHK(tuplelen, tuple, args[0]);
    return jl_box_long(((jl_tuple_t*)args[0])-&gt;length);
}
</t>
<t tx="ekr.20120404123906.7618">
// structs --------------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7619">static size_t field_offset(jl_struct_type_t *t, jl_sym_t *fld, int err)
{
    jl_tuple_t *fn = t-&gt;names;
    size_t i;
    for(i=0; i &lt; fn-&gt;length; i++) {
        if (jl_tupleref(fn,i) == (jl_value_t*)fld) {
            return i;
        }
    }
    if (err)
        jl_errorf("type %s has no field %s", t-&gt;name-&gt;name-&gt;name, fld-&gt;name);
    return -1;
}
</t>
<t tx="ekr.20120404123906.7620">
size_t jl_field_offset(jl_struct_type_t *t, jl_sym_t *fld)
{
    return field_offset(t, fld, 0);
}
</t>
<t tx="ekr.20120404123906.7621">
static jl_value_t *nth_field(jl_value_t *v, size_t i)
{
    jl_value_t *fld = ((jl_value_t**)v)[1+i];
    if (fld == NULL)
        jl_undef_ref_error();
    return fld;
}
</t>
<t tx="ekr.20120404123906.7622">
JL_CALLABLE(jl_f_get_field)
{
    JL_NARGS(getfield, 2, 2);
    JL_TYPECHK(getfield, symbol, args[1]);
    jl_value_t *v = args[0];
    jl_value_t *vt = (jl_value_t*)jl_typeof(v);
    if (!jl_is_struct_type(vt))
        jl_type_error("getfield", (jl_value_t*)jl_struct_kind, v);
    size_t i = field_offset((jl_struct_type_t*)vt, (jl_sym_t*)args[1], 1);
    return nth_field(v, i);
}
</t>
<t tx="ekr.20120404123906.7623">
JL_CALLABLE(jl_f_set_field)
{
    JL_NARGS(setfield, 3, 3);
    JL_TYPECHK(setfield, symbol, args[1]);
    jl_value_t *v = args[0];
    jl_value_t *vt = (jl_value_t*)jl_typeof(v);
    if (!jl_is_struct_type(vt))
        jl_type_error("setfield", (jl_value_t*)jl_struct_kind, v);
    jl_struct_type_t *st = (jl_struct_type_t*)vt;
    size_t i = field_offset(st, (jl_sym_t*)args[1], 1);
    jl_value_t *ft = jl_tupleref(st-&gt;types,i);
    if (!jl_subtype(args[2], ft, 1)) {
        jl_type_error("setfield", ft, args[2]);
    }
    ((jl_value_t**)v)[1+i] = args[2];
    return args[2];
}
</t>
<t tx="ekr.20120404123906.7624">
JL_CALLABLE(jl_f_field_type)
{
    JL_NARGS(fieldtype, 2, 2);
    JL_TYPECHK(fieldtype, symbol, args[1]);
    jl_value_t *v = args[0];
    jl_value_t *vt = (jl_value_t*)jl_typeof(v);
    if (!jl_is_struct_type(vt))
        jl_type_error("fieldtype", (jl_value_t*)jl_struct_kind, v);
    jl_struct_type_t *st = (jl_struct_type_t*)vt;
    size_t i = field_offset(st, (jl_sym_t*)args[1], 1);
    return jl_tupleref(st-&gt;types, i);
}
</t>
<t tx="ekr.20120404123906.7625">
// conversion -----------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7626">static jl_value_t *convert(jl_type_t *to, jl_value_t *x, jl_function_t *conv_f)
{
    jl_value_t *args[2];
    if (jl_subtype(x, (jl_value_t*)to, 1))
        return x;
    args[0] = (jl_value_t*)to; args[1] = x;
    return jl_apply(conv_f, args, 2);
}
</t>
<t tx="ekr.20120404123906.7627">
JL_CALLABLE(jl_f_convert_tuple)
{
    jl_tuple_t *to = (jl_tuple_t*)args[0];
    jl_tuple_t *x = (jl_tuple_t*)args[1];
    if (to == jl_tuple_type)
        return (jl_value_t*)x;
    size_t i, cl=x-&gt;length, pl=to-&gt;length;
    jl_tuple_t *out = jl_alloc_tuple(cl);
    JL_GC_PUSH(&amp;out);
    jl_value_t *ce, *pe=NULL;
    int pseq=0;
    jl_function_t *f = (jl_function_t*)args[2];
    for(i=0; i &lt; cl; i++) {
        ce = jl_tupleref(x,i);
        if (pseq) {
        }
        else if (i &lt; pl) {
            pe = jl_tupleref(to,i);
            if (jl_is_seq_type(pe)) {
                pe = jl_tparam0(pe);
                pseq = 1;
            }
        }
        else {
            out = NULL;
            break;
        }
        assert(pe != NULL);
        jl_tupleset(out, i, convert((jl_type_t*)pe, ce, f));
    }
    JL_GC_POP();
    if (out == NULL)
        jl_error("convert: invalid tuple conversion");
    return (jl_value_t*)out;
}
</t>
<t tx="ekr.20120404123906.7628">
JL_CALLABLE(jl_f_convert_default)
{
    jl_type_t *to = (jl_type_t*)args[0];
    jl_value_t *x = args[1];
    if (!jl_subtype(x, (jl_value_t*)to, 1)) {
        jl_no_method_error((jl_function_t*)args[2], args, 2);
    }
    return x;
}
</t>
<t tx="ekr.20120404123906.7629">
DLLEXPORT void *jl_symbol_name(jl_sym_t *s)
{
    return s-&gt;name;
}
</t>
<t tx="ekr.20120404123906.7630">
DLLEXPORT void *jl_array_ptr(jl_array_t *a)
{
    return a-&gt;data;
}
</t>
<t tx="ekr.20120404123906.7631">
// printing -------------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7632">DLLEXPORT void jl_print_array_uint8(jl_array_t *b)
{
    ios_write(jl_current_output_stream(), (char*)b-&gt;data, b-&gt;length);
}
</t>
<t tx="ekr.20120404123906.7633">
DLLEXPORT void jl_print_symbol(jl_sym_t *sym)
{
    ios_puts(sym-&gt;name, jl_current_output_stream());
}
</t>
<t tx="ekr.20120404123906.7634">
// for bootstrap
</t>
<t tx="ekr.20120404123906.7635">DLLEXPORT void jl_print_int64(int64_t i)
{
    ios_printf(jl_current_output_stream(), "%lld", i);
}
</t>
<t tx="ekr.20120404123906.7636">
DLLEXPORT int jl_strtod(char *str, double *out)
{
    char *p;
    errno = 0;
    *out = strtod(str, &amp;p);
    return (p == str || errno != 0);
}
</t>
<t tx="ekr.20120404123906.7637">
DLLEXPORT int jl_strtof(char *str, float *out)
{
    char *p;
    errno = 0;
    *out = strtof(str, &amp;p);
    return (p == str || errno != 0);
}
</t>
<t tx="ekr.20120404123906.7638">
// showing --------------------------------------------------------------------

static jl_function_t *jl_show_gf=NULL;

</t>
<t tx="ekr.20120404123906.7639">void jl_show(jl_value_t *v)
{
    if (jl_base_module) {
        if (jl_show_gf == NULL) {
            jl_show_gf = (jl_function_t*)jl_get_global(jl_base_module, jl_symbol("show"));
        }
        jl_apply(jl_show_gf, &amp;v, 1);
    }
}
</t>
<t tx="ekr.20120404123906.7640">
// comma_one prints a comma for 1 element, e.g. "(x,)"
</t>
<t tx="ekr.20120404123906.7641">void jl_show_tuple(jl_tuple_t *t, char opn, char cls, int comma_one)
{
    ios_t *s = jl_current_output_stream();
    ios_putc(opn, s);
    size_t i, n=t-&gt;length;
    for(i=0; i &lt; n; i++) {
        jl_show(jl_tupleref(t, i));
        if ((i &lt; n-1) || (n==1 &amp;&amp; comma_one))
            ios_putc(',', s);
    }
    ios_putc(cls, s);
}
</t>
<t tx="ekr.20120404123906.7642">
static void show_function(jl_value_t *v)
{
    ios_t *s = jl_current_output_stream();
    if (jl_is_gf(v)) {
        ios_puts(jl_gf_name(v)-&gt;name, s);
    }
    else {
        ios_puts("#&lt;function&gt;", s);
    }
}
</t>
<t tx="ekr.20120404123906.7643">
static void show_type(jl_value_t *t)
{
    ios_t *s = jl_current_output_stream();
    if (t == (jl_value_t*)jl_function_type) {
        ios_puts("Function", s);
    }
    else if (jl_is_union_type(t)) {
        if (t == (jl_value_t*)jl_bottom_type) {
            ios_write(s, "None", 4);
        }
        else if (t == jl_top_type) {
            ios_write(s, "Top", 3);
        }
        else {
            ios_write(s, "Union", 5);
            jl_show_tuple(((jl_uniontype_t*)t)-&gt;types, '(', ')', 0);
        }
    }
    else if (jl_is_seq_type(t)) {
        jl_show(jl_tparam0(t));
        ios_write(s, "...", 3);
    }
    else if (jl_is_typector(t)) {
        jl_show((jl_value_t*)((jl_typector_t*)t)-&gt;body);
    }
    else {
        assert(jl_is_some_tag_type(t));
        jl_tag_type_t *tt = (jl_tag_type_t*)t;
        ios_puts(tt-&gt;name-&gt;name-&gt;name, s);
        jl_tuple_t *p = tt-&gt;parameters;
        if (p-&gt;length &gt; 0)
            jl_show_tuple(p, '{', '}', 0);
    }
}
</t>
<t tx="ekr.20120404123906.7644">
DLLEXPORT void jl_show_any(jl_value_t *v)
{
    // fallback for printing some other builtin types
    ios_t *s = jl_current_output_stream();
    if (jl_is_tuple(v)) {
        jl_show_tuple((jl_tuple_t*)v, '(', ')', 1);
    }
    else if (jl_is_type(v)) {
        show_type(v);
    }
    else if (jl_is_func(v)) {
        show_function(v);
    }
    else if (jl_typeis(v,jl_intrinsic_type)) {
        ios_printf(s, "#&lt;intrinsic-function %d&gt;", *(uint32_t*)jl_bits_data(v));
    }
    else {
        jl_value_t *t = (jl_value_t*)jl_typeof(v);
        if (jl_is_struct_type(t)) {
            jl_struct_type_t *st = (jl_struct_type_t*)t;
            ios_puts(st-&gt;name-&gt;name-&gt;name, s);
            ios_putc('(', s);
            size_t i;
            size_t n = st-&gt;names-&gt;length;
            for(i=0; i &lt; n; i++) {
                jl_show(nth_field(v, i));
                if (i &lt; n-1)
                    ios_putc(',', s);
            }
            ios_putc(')', s);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7645">
// internal functions ---------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7646">JL_CALLABLE(jl_trampoline)
{
    assert(jl_is_func(F));
    assert(((jl_function_t*)F)-&gt;linfo != NULL);
    /* // to run inference on all thunks. slows down loading files.
    if (F-&gt;linfo-&gt;inferred == jl_false) {
        if (!jl_in_inference) {
            jl_type_infer(F-&gt;linfo, jl_tuple_type, F-&gt;linfo);
        }
    }*/
    jl_compile((jl_function_t*)F);
    assert(((jl_function_t*)F)-&gt;fptr == &amp;jl_trampoline);
    jl_generate_fptr((jl_function_t*)F);
    return jl_apply((jl_function_t*)F, args, nargs);
}
</t>
<t tx="ekr.20120404123906.7647">
JL_CALLABLE(jl_f_instantiate_type)
{
    JL_NARGSV(instantiate_type, 1);
    if (!jl_is_some_tag_type(args[0]))
        JL_TYPECHK(instantiate_type, typector, args[0]);
    return jl_apply_type_(args[0], &amp;args[1], nargs-1);
}
</t>
<t tx="ekr.20120404123906.7648">
static void check_supertype(jl_value_t *super, char *name)
{
    if (!jl_is_tag_type(super) || super == (jl_value_t*)jl_sym_type ||
        super == (jl_value_t*)jl_undef_type ||
        jl_subtype(super,(jl_value_t*)jl_type_type,0) ||
        jl_subtype(super,(jl_value_t*)jl_array_type,0)) {
        jl_errorf("invalid subtyping in definition of %s", name);
    }
}
</t>
<t tx="ekr.20120404123906.7649">
JL_CALLABLE(jl_f_new_struct_type)
{
    JL_NARGS(new_struct_type, 4, 4);
    JL_TYPECHK(new_struct_type, symbol, args[0]);
    JL_TYPECHK(new_struct_type, tuple, args[1]);
    JL_TYPECHK(new_struct_type, tuple, args[2]);
    if (args[3] != (jl_value_t*)jl_nothing)
        JL_TYPECHK(new_struct_type, function, args[3]);
    jl_sym_t *name = (jl_sym_t*)args[0];
    jl_tuple_t *params = (jl_tuple_t*)args[1];
    jl_tuple_t *fnames = (jl_tuple_t*)args[2];

    jl_struct_type_t *nst =
        jl_new_struct_type(name, jl_any_type, params, fnames, NULL);
    nst-&gt;ctor_factory = args[3];
    return (jl_value_t*)nst;
}
</t>
<t tx="ekr.20120404123906.7650">
void jl_add_constructors(jl_struct_type_t *t);
void jl_reinstantiate_inner_types(jl_tag_type_t *t);

</t>
<t tx="ekr.20120404123906.7651">static void check_type_tuple(jl_tuple_t *t, jl_sym_t *name, const char *ctx)
{
    size_t i;
    for(i=0; i &lt; t-&gt;length; i++) {
        jl_value_t *elt = jl_tupleref(t,i);
        if (!jl_is_type(elt) &amp;&amp; !jl_is_typevar(elt)) {
            jl_type_error_rt(name-&gt;name, ctx, (jl_value_t*)jl_type_type, elt);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7652">
JL_CALLABLE(jl_f_new_struct_fields)
{
    JL_NARGS(new_struct_fields, 3, 3);
    jl_value_t *super = args[1];
    JL_TYPECHK(new_struct_fields, tuple, args[2]);
    jl_value_t *t = args[0];
    jl_tuple_t *ftypes = (jl_tuple_t*)args[2];
    if (!jl_is_struct_type(t))
        jl_error("you can't do that.");
    jl_struct_type_t *st = (jl_struct_type_t*)t;
    if (st-&gt;types != NULL) {
        // type already exists. redefinition ignored.
        return (jl_value_t*)jl_nothing;
    }
    check_type_tuple(ftypes, st-&gt;name-&gt;name, "type definition");

    check_supertype(super, st-&gt;name-&gt;name-&gt;name);
    st-&gt;super = (jl_tag_type_t*)super;
    assert(jl_is_tag_type(super));

    st-&gt;types = ftypes;

    if (st-&gt;parameters-&gt;length &gt; 0) {
        // once the full structure is built, use instantiate_type to walk it
        // and tie up self-references.
        st-&gt;name-&gt;cache = jl_null;
        jl_reinstantiate_inner_types((jl_tag_type_t*)st);
    }

    jl_add_constructors(st);
    return (jl_value_t*)jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7653">
JL_CALLABLE(jl_f_new_type_constructor)
{
    JL_NARGS(new_type_constructor, 2, 2);
    JL_TYPECHK(new_type_constructor, tuple, args[0]);
    if (!jl_is_type(args[1]))
        jl_type_error("typealias", (jl_value_t*)jl_type_type, args[1]);
    jl_tuple_t *p = (jl_tuple_t*)args[0];
    return (jl_value_t*)jl_new_type_ctor(p, (jl_type_t*)args[1]);
}
</t>
<t tx="ekr.20120404123906.7654">
JL_CALLABLE(jl_f_new_tag_type)
{
    JL_NARGS(new_tag_type, 2, 2);
    JL_TYPECHK(new_tag_type, symbol, args[0]);
    JL_TYPECHK(new_tag_type, tuple, args[1]);
    jl_tuple_t *p = (jl_tuple_t*)args[1];
    return (jl_value_t*)jl_new_tagtype((jl_value_t*)args[0], jl_any_type, p);
}
</t>
<t tx="ekr.20120404123906.7655">
JL_CALLABLE(jl_f_new_tag_type_super)
{
    JL_NARGS(new_tag_type_super, 2, 2);
    JL_TYPECHK(new_tag_type_super, tag_type, args[1]);
    jl_tag_type_t *tt = (jl_tag_type_t*)args[0];
    jl_value_t *super = args[1];
    check_supertype(super, tt-&gt;name-&gt;name-&gt;name);
    tt-&gt;super = (jl_tag_type_t*)super;
    if (tt-&gt;parameters-&gt;length &gt; 0) {
        tt-&gt;name-&gt;cache = jl_null;
        jl_reinstantiate_inner_types((jl_tag_type_t*)tt);
    }
    return (jl_value_t*)jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7656">
JL_CALLABLE(jl_f_new_bits_type)
{
    JL_NARGS(new_bits_type, 3, 3);
    JL_TYPECHK(new_bits_type, symbol, args[0]);
    JL_TYPECHK(new_bits_type, tuple, args[1]);
    JL_TYPECHK(new_bits_type, long, args[2]);
    jl_tuple_t *p = (jl_tuple_t*)args[1];
    int32_t nb = jl_unbox_long(args[2]);
    if (nb &lt; 1 || nb&gt;=(1&lt;&lt;23) || (nb&amp;7) != 0)
        jl_errorf("invalid number of bits in type %s",
                  ((jl_sym_t*)args[0])-&gt;name);
    return (jl_value_t*)jl_new_bitstype((jl_value_t*)args[0], jl_any_type, p,
                                        nb);
}
</t>
<t tx="ekr.20120404123906.7657">
extern int jl_boot_file_loaded;

</t>
<t tx="ekr.20120404123906.7658">JL_CALLABLE(jl_f_def_macro)
{
    jl_sym_t *nm = (jl_sym_t*)args[0];
    assert(jl_is_symbol(nm));
    jl_function_t *f = (jl_function_t*)args[1];
    assert(jl_is_function(f));
    if (jl_boot_file_loaded &amp;&amp;
        f-&gt;linfo &amp;&amp; f-&gt;linfo-&gt;ast &amp;&amp; jl_is_expr(f-&gt;linfo-&gt;ast)) {
        jl_lambda_info_t *li = f-&gt;linfo;
        li-&gt;ast = jl_compress_ast(li, li-&gt;ast);
    }
    jl_set_expander(jl_current_module, nm, f);
    return (jl_value_t*)jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7659">
JL_CALLABLE(jl_f_typevar)
{
    if (nargs &lt; 1 || nargs &gt; 3) {
        JL_NARGS(typevar, 1, 1);
    }
    JL_TYPECHK(typevar, symbol, args[0]);
    jl_value_t *lb = (jl_value_t*)jl_bottom_type;
    jl_value_t *ub = (jl_value_t*)jl_any_type;
    if (nargs &gt; 1) {
        JL_TYPECHK(typevar, type, args[1]);
        if (nargs &gt; 2) {
            JL_TYPECHK(typevar, type, args[2]);
            lb = args[1];
            ub = args[2];
        }
        else {
            ub = args[1];
        }
    }
    return (jl_value_t*)jl_new_typevar((jl_sym_t*)args[0], lb, ub);
}
</t>
<t tx="ekr.20120404123906.7660">
JL_CALLABLE(jl_f_union)
{
    if (nargs == 0) return (jl_value_t*)jl_bottom_type;
    if (nargs == 1) return args[0];
    size_t i;
    jl_tuple_t *argt = jl_alloc_tuple_uninit(nargs);
    for(i=0; i &lt; nargs; i++) {
        if (!jl_is_type(args[i]) &amp;&amp; !jl_is_typevar(args[i])) {
            jl_error("invalid union type");
        }
        else {
            jl_tupleset(argt, i, args[i]);
        }
    }
    JL_GC_PUSH(&amp;argt);
    jl_value_t *u = jl_type_union(argt);
    JL_GC_POP();
    return u;
}
</t>
<t tx="ekr.20120404123906.7661">
// method definition ----------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7662">jl_value_t *jl_method_def(jl_sym_t *name, jl_value_t **bp, jl_binding_t *bnd,
                          jl_tuple_t *argtypes, jl_function_t *f, jl_tuple_t *t)
{
    jl_value_t *gf;
    if (bnd) {
        jl_declare_constant(bnd);
    }
    if (*bp == NULL) {
        gf = (jl_value_t*)jl_new_generic_function(name);
        *bp = gf;
    }
    else {
        gf = *bp;
        if (!jl_is_gf(gf))
            jl_error("in method definition: not a generic function");
    }
    JL_GC_PUSH(&amp;gf);
    assert(jl_is_function(f));
    assert(jl_is_tuple(argtypes));
    check_type_tuple(argtypes, name, "method definition");
    jl_add_method((jl_function_t*)gf, argtypes, f, t);
    if (jl_boot_file_loaded &amp;&amp;
        f-&gt;linfo &amp;&amp; f-&gt;linfo-&gt;ast &amp;&amp; jl_is_expr(f-&gt;linfo-&gt;ast)) {
        jl_lambda_info_t *li = f-&gt;linfo;
        li-&gt;ast = jl_compress_ast(li, li-&gt;ast);
    }
    JL_GC_POP();
    return gf;
}
</t>
<t tx="ekr.20120404123906.7663">
// generic function reflection ------------------------------------------------

</t>
<t tx="ekr.20120404123906.7664">JL_CALLABLE(jl_f_methodexists)
{
    JL_NARGS(method_exists, 2, 2);
    JL_TYPECHK(method_exists, function, args[0]);
    if (!jl_is_gf(args[0]))
        jl_error("method_exists: not a generic function");
    JL_TYPECHK(method_exists, tuple, args[1]);
    check_type_tuple((jl_tuple_t*)args[1], jl_gf_name(args[0]),
                     "method_exists");
    return jl_method_lookup_by_type(jl_gf_mtable(args[0]),
                                    (jl_tuple_t*)args[1], 0) ?
        jl_true : jl_false;
}
</t>
<t tx="ekr.20120404123906.7665">
JL_CALLABLE(jl_f_applicable)
{
    JL_NARGSV(applicable, 1);
    JL_TYPECHK(applicable, function, args[0]);
    if (!jl_is_gf(args[0]))
        jl_error("applicable: not a generic function");
    return jl_method_lookup(jl_gf_mtable(args[0]), &amp;args[1], nargs-1, 0) ?
        jl_true : jl_false;
}
</t>
<t tx="ekr.20120404123906.7666">
JL_CALLABLE(jl_f_invoke)
{
    JL_NARGSV(invoke, 2);
    JL_TYPECHK(invoke, function, args[0]);
    if (!jl_is_gf(args[0]))
        jl_error("invoke: not a generic function");
    JL_TYPECHK(invoke, tuple, args[1]);
    check_type_tuple((jl_tuple_t*)args[1], jl_gf_name(args[0]), "invoke");
    if (!jl_tuple_subtype(&amp;args[2], nargs-2, &amp;jl_tupleref(args[1],0),
                          ((jl_tuple_t*)args[1])-&gt;length, 1, 0))
        jl_error("invoke: argument type error");
    return jl_gf_invoke((jl_function_t*)args[0],
                        (jl_tuple_t*)args[1], &amp;args[2], nargs-2);
}
</t>
<t tx="ekr.20120404123906.7667">
// eq hash table --------------------------------------------------------------

#include "table.c"

// hashing --------------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7668">DLLEXPORT uptrint_t jl_hash_symbol(jl_sym_t *s)
{
    return s-&gt;hash;
}
</t>
<t tx="ekr.20120404123906.7669">
DLLEXPORT uptrint_t jl_uid(jl_value_t *v)
{
    return (uptrint_t)v;
}
</t>
<t tx="ekr.20120404123906.7670">
// init -----------------------------------------------------------------------

</t>
<t tx="ekr.20120404123906.7671">static void add_builtin(const char *name, jl_value_t *v)
{
    jl_set_const(jl_core_module, jl_symbol(name), v);
}
</t>
<t tx="ekr.20120404123906.7672">
static void add_builtin_func(const char *name, jl_fptr_t f)
{
    add_builtin(name, (jl_value_t*)
                jl_new_closure(f, (jl_value_t*)jl_symbol(name), NULL));
}
</t>
<t tx="ekr.20120404123906.7673">
void jl_init_primitives(void)
{
    add_builtin_func("is", jl_f_is);
    add_builtin_func("typeof", jl_f_typeof);
    add_builtin_func("subtype", jl_f_subtype);
    add_builtin_func("isa", jl_f_isa);
    add_builtin_func("typeassert", jl_f_typeassert);
    add_builtin_func("apply", jl_f_apply);
    add_builtin_func("throw", jl_f_throw);
    add_builtin_func("tuple", jl_f_tuple);
    add_builtin_func("Union", jl_f_union);
    add_builtin_func("method_exists", jl_f_methodexists);
    add_builtin_func("applicable", jl_f_applicable);
    add_builtin_func("invoke", jl_f_invoke);
    add_builtin_func("eval", jl_f_top_eval);
    add_builtin_func("isbound", jl_f_isbound);
    add_builtin_func("yieldto", jl_f_yieldto);
    
    // functions for internal use
    add_builtin_func("convert_default", jl_f_convert_default);
    add_builtin_func("convert_tuple", jl_f_convert_tuple);
    add_builtin_func("tupleref",  jl_f_tupleref);
    add_builtin_func("tuplelen",  jl_f_tuplelen);
    add_builtin_func("getfield",  jl_f_get_field);
    add_builtin_func("_setfield",  jl_f_set_field);
    add_builtin_func("fieldtype", jl_f_field_type);

    add_builtin_func("arraylen", jl_f_arraylen);
    add_builtin_func("arrayref", jl_f_arrayref);
    add_builtin_func("arrayset", jl_f_arrayset);
    add_builtin_func("arraysize", jl_f_arraysize);

    add_builtin_func("apply_type", jl_f_instantiate_type);
    add_builtin_func("typevar", jl_f_typevar);
    add_builtin_func("new_struct_type", jl_f_new_struct_type);
    add_builtin_func("new_struct_fields", jl_f_new_struct_fields);
    add_builtin_func("new_type_constructor", jl_f_new_type_constructor);
    add_builtin_func("new_tag_type", jl_f_new_tag_type);
    add_builtin_func("new_tag_type_super", jl_f_new_tag_type_super);
    add_builtin_func("new_bits_type", jl_f_new_bits_type);
    add_builtin_func("def_macro", jl_f_def_macro);

    // builtin types
    add_builtin("Any", (jl_value_t*)jl_any_type);
    add_builtin("None", (jl_value_t*)jl_bottom_type);
    add_builtin("Void", (jl_value_t*)jl_bottom_type);
    add_builtin("Top",  (jl_value_t*)jl_top_type);
    add_builtin("TypeVar", (jl_value_t*)jl_tvar_type);
    add_builtin("TypeName", (jl_value_t*)jl_typename_type);
    add_builtin("TypeConstructor", (jl_value_t*)jl_typector_type);
    add_builtin("Tuple", (jl_value_t*)jl_tuple_type);
    add_builtin("NTuple", (jl_value_t*)jl_ntuple_type);
    add_builtin("Type", (jl_value_t*)jl_type_type);
    add_builtin("...", (jl_value_t*)jl_seq_type);
    add_builtin("BitsKind", (jl_value_t*)jl_bits_kind);
    add_builtin("CompositeKind", (jl_value_t*)jl_struct_kind);
    add_builtin("AbstractKind", (jl_value_t*)jl_tag_kind);
    add_builtin("UnionKind", (jl_value_t*)jl_union_kind);
    // todo: this should only be visible to compiler components
    add_builtin("Undef", (jl_value_t*)jl_undef_type);

    add_builtin("Module", (jl_value_t*)jl_module_type);
    add_builtin("Method", (jl_value_t*)jl_method_type);
    add_builtin("MethodTable", (jl_value_t*)jl_methtable_type);
    add_builtin("Symbol", (jl_value_t*)jl_sym_type);
    add_builtin("IntrinsicFunction", (jl_value_t*)jl_intrinsic_type);
    add_builtin("Function", (jl_value_t*)jl_function_type);
    add_builtin("LambdaStaticData", (jl_value_t*)jl_lambda_info_type);
    add_builtin("Ptr", (jl_value_t*)jl_pointer_type);
    add_builtin("Box", (jl_value_t*)jl_box_type);
    add_builtin("Task", (jl_value_t*)jl_task_type);

    add_builtin("AbstractArray", (jl_value_t*)jl_abstractarray_type);
    add_builtin("Array", (jl_value_t*)jl_array_type);

    add_builtin("Expr", (jl_value_t*)jl_expr_type);
    add_builtin("LineNumberNode", (jl_value_t*)jl_linenumbernode_type);
    add_builtin("LabelNode", (jl_value_t*)jl_labelnode_type);
    add_builtin("GotoNode", (jl_value_t*)jl_gotonode_type);
    add_builtin("QuoteNode", (jl_value_t*)jl_quotenode_type);
    add_builtin("TopNode", (jl_value_t*)jl_topnode_type);

#ifdef __LP64__
    add_builtin("Int", (jl_value_t*)jl_int64_type);
#else
    add_builtin("Int", (jl_value_t*)jl_int32_type);
#endif

    add_builtin("ANY", jl_ANY_flag);
}
</t>
<t tx="ekr.20120404123906.7674">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7675">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/stat.h&gt;

#if defined(__linux) || defined(__FreeBSD__)
#include &lt;unistd.h&gt;
#include &lt;dlfcn.h&gt;
#define GET_FUNCTION_FROM_MODULE dlsym
#define CLOSE_MODULE dlclose
typedef void * module_handle_t;
static char *extensions[] = { ".so", "" };
#define N_EXTENSIONS 2

#elif defined(__APPLE__)
#include &lt;unistd.h&gt;
#include &lt;dlfcn.h&gt;
#define GET_FUNCTION_FROM_MODULE dlsym
#define CLOSE_MODULE dlclose
typedef void * module_handle_t;
static char *extensions[] = { "", ".dylib", ".bundle" };
#define N_EXTENSIONS 3
#endif

#include "julia.h"

#define PATHBUF 512

extern char *julia_home;

</t>
<t tx="ekr.20120404123906.7676">void *jl_load_dynamic_library(char *fname)
{
    module_handle_t handle;
    char *modname, *ext;
    char path[PATHBUF];
    int i;

    modname = fname;
    if (modname == NULL) {
        return (void*)dlopen(NULL, RTLD_NOW);
    }
    else if (modname[0] == '/') {
        handle = dlopen(modname, RTLD_NOW);
        if (handle != NULL) return handle;
    }
    char *cwd;

    for(i=0; i &lt; N_EXTENSIONS; i++) {
        ext = extensions[i];
        path[0] = '\0';
        handle = NULL;
        if (modname[0] != '/') {
            if (julia_home) {
                /* try julia_home/lib */
                strncpy(path, julia_home, PATHBUF-1);
                strncat(path, "/lib/", PATHBUF-1-strlen(path));
                strncat(path, modname, PATHBUF-1-strlen(path));
                strncat(path, ext, PATHBUF-1-strlen(path));
                handle = dlopen(path, RTLD_NOW);
                if (handle != NULL) return handle;
                // if file exists but didn't load, show error details
                struct stat sbuf;
                if (stat(path, &amp;sbuf) != -1) {
                    ios_printf(ios_stderr, "%s\n", dlerror());
                    jl_errorf("could not load module %s", fname);
                }
            }
            cwd = getcwd(path, PATHBUF);
            if (cwd != NULL) {
                /* next try load from current directory */
                strncat(path, "/", PATHBUF-1-strlen(path));
                strncat(path, modname, PATHBUF-1-strlen(path));
                strncat(path, ext, PATHBUF-1-strlen(path));
                handle = dlopen(path, RTLD_NOW);
                if (handle != NULL) return handle;
            }
        }
        /* try loading from standard library path */
        strncpy(path, modname, PATHBUF-1);
        strncat(path, ext, PATHBUF-1-strlen(path));
        handle = dlopen(path, RTLD_NOW);
        if (handle != NULL) return handle;
    }
    assert(handle == NULL);
    ios_printf(ios_stderr, "%s\n", dlerror());
    jl_errorf("could not load module %s", fname);

    return NULL;
}
</t>
<t tx="ekr.20120404123906.7677">
void *jl_dlsym(void *handle, char *symbol)
{
    (void)dlerror();
    void *ptr = dlsym(handle, symbol);
    char *msg = dlerror();
    if (msg != NULL) {
        jl_errorf("dlsym: %s", msg);
    }
    return ptr;
}
</t>
<t tx="ekr.20120404123906.7678">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7679">/*
  saving and restoring system images
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "builtin_proto.h"
#include "newobj_internal.h"
#include "jltypes_internal.h"

static htable_t ser_tag;
static htable_t deser_tag;
static htable_t backref_table;
static htable_t fptr_to_id;
static htable_t id_to_fptr;

static const ptrint_t LongSymbol_tag = 23;
static const ptrint_t LongTuple_tag  = 24;
static const ptrint_t LongExpr_tag   = 25;
static const ptrint_t LiteralVal_tag = 26;
static const ptrint_t SmallInt64_tag = 27;
static const ptrint_t Null_tag       = 254;
static const ptrint_t BackRef_tag    = 255;

static ptrint_t VALUE_TAGS;

// pointers to non-AST-ish objects in a compressed tree
static jl_array_t *tree_literal_values=NULL;

// queue of IdTables to rehash
static jl_array_t *idtable_list=NULL;
static jl_value_t *jl_idtable_type=NULL;
void jl_idtable_rehash(jl_array_t **pa, size_t newsz);

// queue of types to cache
static jl_array_t *tagtype_list=NULL;

</t>
<t tx="ekr.20120404123906.7680">#define write_uint8(s, n) ios_putc((n), (s))
#define read_uint8(s) ((uint8_t)ios_getc(s))
#define write_int8(s, n) write_uint8(s, n)
#define read_int8(s) read_uint8(s)
</t>
<t tx="ekr.20120404123906.7681">static void write_int32(ios_t *s, int32_t i)
{
    write_uint8(s, i       &amp; 0xff);
    write_uint8(s, (i&gt;&gt; 8) &amp; 0xff);
    write_uint8(s, (i&gt;&gt;16) &amp; 0xff);
    write_uint8(s, (i&gt;&gt;24) &amp; 0xff);
}
</t>
<t tx="ekr.20120404123906.7682">
static int32_t read_int32(ios_t *s)
{
    int b0 = read_uint8(s);
    int b1 = read_uint8(s);
    int b2 = read_uint8(s);
    int b3 = read_uint8(s);
    return b0 | (b1&lt;&lt;8) | (b2&lt;&lt;16) | (b3&lt;&lt;24);
}
</t>
<t tx="ekr.20120404123906.7683">
static void write_uint16(ios_t *s, uint16_t i)
{
    write_uint8(s, i       &amp; 0xff);
    write_uint8(s, (i&gt;&gt; 8) &amp; 0xff);
}
</t>
<t tx="ekr.20120404123906.7684">
static uint16_t read_uint16(ios_t *s)
{
    int b0 = read_uint8(s);
    int b1 = read_uint8(s);
    return b0 | (b1&lt;&lt;8);
}
</t>
<t tx="ekr.20120404123906.7685">
static void writetag(ios_t *s, void *v)
{
    write_uint8(s, (uint8_t)(ptrint_t)ptrhash_get(&amp;ser_tag, v));
}
</t>
<t tx="ekr.20120404123906.7686">
static void write_as_tag(ios_t *s, uint8_t tag)
{
    if (tag &lt; VALUE_TAGS) {
        write_uint8(s, 0);
    }
    write_uint8(s, tag);
}
</t>
<t tx="ekr.20120404123906.7687">
// --- serialize ---

#define jl_serialize_value(s, v) jl_serialize_value_(s,(jl_value_t*)(v))

static void jl_serialize_value_(ios_t *s, jl_value_t *v);

</t>
<t tx="ekr.20120404123906.7688">static void jl_serialize_fptr(ios_t *s, void *fptr)
{
    void **pbp = ptrhash_bp(&amp;fptr_to_id, fptr);
    if (*pbp == HT_NOTFOUND)
        jl_error("unknown function pointer");
    write_int32(s, *(ptrint_t*)pbp);
}
</t>
<t tx="ekr.20120404123906.7689">
static void jl_serialize_tag_type(ios_t *s, jl_value_t *v)
{
    if (jl_is_struct_type(v)) {
        writetag(s, (jl_value_t*)jl_struct_kind);
        jl_serialize_value(s, jl_struct_kind);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;name);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;parameters);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;super);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;names);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;types);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;ctor_factory);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;env);
        jl_serialize_value(s, ((jl_struct_type_t*)v)-&gt;linfo);
        jl_serialize_fptr(s, ((jl_struct_type_t*)v)-&gt;fptr);
        write_int32(s, ((jl_struct_type_t*)v)-&gt;uid);
    }
    else if (jl_is_bits_type(v)) {
        writetag(s, jl_struct_kind);
        jl_serialize_value(s, jl_bits_kind);
        if (v == (jl_value_t*)jl_int32_type)
            write_uint8(s, 2);
        else if (v == (jl_value_t*)jl_bool_type)
            write_uint8(s, 3);
        else if (v == (jl_value_t*)jl_int64_type)
            write_uint8(s, 4);
        else
            write_uint8(s, 0);
        jl_serialize_value(s, ((jl_tag_type_t*)v)-&gt;name);
        jl_serialize_value(s, ((jl_bits_type_t*)v)-&gt;parameters);
        write_int32(s, ((jl_bits_type_t*)v)-&gt;nbits);
        jl_serialize_value(s, ((jl_bits_type_t*)v)-&gt;super);
        write_int32(s, ((jl_bits_type_t*)v)-&gt;uid);
    }
    else {
        assert(jl_is_tag_type(v));
        writetag(s, jl_tag_kind);
        jl_serialize_value(s, ((jl_tag_type_t*)v)-&gt;name);
        jl_serialize_value(s, ((jl_tag_type_t*)v)-&gt;parameters);
        jl_serialize_value(s, ((jl_tag_type_t*)v)-&gt;super);
    }
}
</t>
<t tx="ekr.20120404123906.7690">
static void jl_serialize_module(ios_t *s, jl_module_t *m)
{
    writetag(s, jl_module_type);
    jl_serialize_value(s, m-&gt;name);
    size_t i;
    void **table = m-&gt;bindings.table;
    for(i=1; i &lt; m-&gt;bindings.size; i+=2) {
        if (table[i] != HT_NOTFOUND) {
            jl_binding_t *b = (jl_binding_t*)table[i];
            jl_serialize_value(s, b-&gt;name);
            jl_serialize_value(s, b-&gt;value);
            jl_serialize_value(s, b-&gt;type);
            write_int8(s, b-&gt;constp);
            write_int8(s, b-&gt;exportp);
        }
    }
    jl_serialize_value(s, NULL);
    table = m-&gt;macros.table;
    for(i=1; i &lt; m-&gt;macros.size; i+=2) {
        if (table[i] != HT_NOTFOUND) {
            jl_serialize_value(s, table[i-1]);
            jl_serialize_value(s, table[i]);
        }
    }
    jl_serialize_value(s, NULL);
}
</t>
<t tx="ekr.20120404123906.7691">
static int is_ast_node(jl_value_t *v)
{
    return jl_is_symbol(v) || jl_is_expr(v) ||
        jl_typeis(v, jl_array_any_type) || jl_is_tuple(v) ||
        jl_is_union_type(v) || jl_is_int32(v) || jl_is_int64(v) ||
        jl_is_symbolnode(v) || jl_is_bool(v) || jl_is_typevar(v) ||
        jl_is_topnode(v) || jl_is_quotenode(v) || jl_is_gotonode(v) ||
        jl_is_labelnode(v) || jl_is_linenode(v);
}
</t>
<t tx="ekr.20120404123906.7692">
static int literal_val_id(jl_value_t *v)
{
    for(int i=0; i &lt; jl_array_len(tree_literal_values); i++) {
        if (jl_cellref(tree_literal_values,i) == v)
            return i;
    }
    jl_cell_1d_push(tree_literal_values, v);
    return jl_array_len(tree_literal_values)-1;
}
</t>
<t tx="ekr.20120404123906.7693">
static void jl_serialize_value_(ios_t *s, jl_value_t *v)
{
    if (v == NULL) {
        write_uint8(s, Null_tag);
        return;
    }

    void **bp = ptrhash_bp(&amp;ser_tag, v);
    if (*bp != HT_NOTFOUND) {
        write_as_tag(s, (uint8_t)(ptrint_t)*bp);
        return;
    }

    if (tree_literal_values) {
        // compressing tree
        if (!is_ast_node(v)) {
            writetag(s, (jl_value_t*)LiteralVal_tag);
            write_uint16(s, literal_val_id(v));
            return;
        }
    }
    else {
        bp = ptrhash_bp(&amp;backref_table, v);
        if (*bp != HT_NOTFOUND) {
            write_uint8(s, BackRef_tag);
            write_int32(s, (ptrint_t)*bp);
            return;
        }
        ptrhash_put(&amp;backref_table, v, (void*)(ptrint_t)ios_pos(s));
    }

    size_t i;
    if (jl_is_tuple(v)) {
        size_t l = ((jl_tuple_t*)v)-&gt;length;
        if (l &lt;= 255) {
            writetag(s, jl_tuple_type);
            write_uint8(s, (uint8_t)l);
        }
        else {
            writetag(s, (jl_value_t*)LongTuple_tag);
            write_int32(s, l);
        }
        for(i=0; i &lt; l; i++) {
            jl_serialize_value(s, jl_tupleref(v, i));
        }
    }
    else if (jl_is_symbol(v)) {
        size_t l = strlen(((jl_sym_t*)v)-&gt;name);
        if (l &lt;= 255) {
            writetag(s, jl_symbol_type);
            write_uint8(s, (uint8_t)l);
        }
        else {
            writetag(s, (jl_value_t*)LongSymbol_tag);
            write_int32(s, l);
        }
        ios_write(s, ((jl_sym_t*)v)-&gt;name, l);
    }
    else if (jl_is_array(v)) {
        jl_array_t *ar = (jl_array_t*)v;
        writetag(s, (jl_value_t*)jl_array_type);
        jl_serialize_value(s, jl_typeof(ar));
        jl_value_t *elty = jl_tparam0(jl_typeof(ar));
        for (i=0; i &lt; ar-&gt;ndims; i++)
            jl_serialize_value(s, jl_box_long(jl_array_dim(ar,i)));
        if (jl_is_bits_type(elty)) {
            size_t tot = ar-&gt;length * ar-&gt;elsize;
            ios_write(s, ar-&gt;data, tot);
        }
        else {
            for(i=0; i &lt; ar-&gt;length; i++) {
                jl_serialize_value(s, jl_cellref(v, i));
            }
        }
    }
    else if (jl_is_expr(v)) {
        jl_expr_t *e = (jl_expr_t*)v;
        size_t l = e-&gt;args-&gt;length;
        if (l &lt;= 255) {
            writetag(s, jl_expr_type);
            write_uint8(s, (uint8_t)l);
        }
        else {
            writetag(s, (jl_value_t*)LongExpr_tag);
            write_int32(s, l);
        }
        jl_serialize_value(s, e-&gt;head);
        jl_serialize_value(s, e-&gt;etype);
        for(i=0; i &lt; l; i++) {
            jl_serialize_value(s, jl_exprarg(e, i));
        }
    }
    else if (jl_is_some_tag_type(v)) {
        jl_serialize_tag_type(s, v);
    }
    else if (jl_is_typevar(v)) {
        writetag(s, jl_tvar_type);
        jl_serialize_value(s, ((jl_tvar_t*)v)-&gt;name);
        jl_serialize_value(s, ((jl_tvar_t*)v)-&gt;lb);
        jl_serialize_value(s, ((jl_tvar_t*)v)-&gt;ub);
        write_int8(s, ((jl_tvar_t*)v)-&gt;bound);
    }
    else if (jl_is_function(v)) {
        writetag(s, jl_function_type);
        jl_function_t *f = (jl_function_t*)v;
        jl_serialize_value(s, (jl_value_t*)f-&gt;linfo);
        jl_serialize_value(s, f-&gt;env);
        if (f-&gt;linfo &amp;&amp; f-&gt;linfo-&gt;ast &amp;&amp;
            (jl_is_expr(f-&gt;linfo-&gt;ast) || jl_is_tuple(f-&gt;linfo-&gt;ast)) &amp;&amp;
            f-&gt;fptr != &amp;jl_trampoline) {
            jl_serialize_fptr(s, &amp;jl_trampoline);
        }
        else {
            jl_serialize_fptr(s, f-&gt;fptr);
        }
    }
    else if (jl_is_lambda_info(v)) {
        writetag(s, jl_lambda_info_type);
        jl_lambda_info_t *li = (jl_lambda_info_t*)v;
        jl_serialize_value(s, li-&gt;ast);
        jl_serialize_value(s, (jl_value_t*)li-&gt;sparams);
        // don't save cached type info for code in the Core module, because
        // it might reference types in the old Base module.
        if (li-&gt;module == jl_core_module)
            jl_serialize_value(s, (jl_value_t*)jl_null);
        else
            jl_serialize_value(s, (jl_value_t*)li-&gt;tfunc);
        jl_serialize_value(s, (jl_value_t*)li-&gt;name);
        jl_serialize_value(s, (jl_value_t*)li-&gt;specTypes);
        jl_serialize_value(s, (jl_value_t*)li-&gt;specializations);
        jl_serialize_value(s, (jl_value_t*)li-&gt;inferred);
        jl_serialize_value(s, (jl_value_t*)li-&gt;file);
        jl_serialize_value(s, (jl_value_t*)li-&gt;line);
        jl_serialize_value(s, (jl_value_t*)li-&gt;module);
    }
    else if (jl_typeis(v, jl_module_type)) {
        jl_serialize_module(s, (jl_module_t*)v);
    }
    else if (jl_typeis(v, jl_task_type)) {
        jl_error("Task cannot be serialized");
    }
    else {
        jl_value_t *t = (jl_value_t*)jl_typeof(v);
        if (jl_is_bits_type(t)) {
            void *data = jl_bits_data(v);
            if (t == (jl_value_t*)jl_int64_type &amp;&amp;
                *(int64_t*)data &gt;= S32_MIN &amp;&amp; *(int64_t*)data &lt;= S32_MAX) {
                writetag(s, (jl_value_t*)SmallInt64_tag);
                write_int32(s, (int32_t)*(int64_t*)data);
            }
            else {
                int nb = ((jl_bits_type_t*)t)-&gt;nbits;
                writetag(s, jl_bits_kind);
                jl_serialize_value(s, t);
                ios_write(s, data, nb/8);
            }
        }
        else if (jl_is_struct_type(t)) {
            writetag(s, jl_struct_kind);
            jl_serialize_value(s, t);
            size_t nf = ((jl_struct_type_t*)t)-&gt;names-&gt;length;
            size_t i;
            for(i=0; i &lt; nf; i++) {
                jl_value_t *fld = ((jl_value_t**)v)[i+1];
                jl_serialize_value(s, fld);
            }
            if (t == jl_idtable_type) {
                jl_cell_1d_push(idtable_list, v);
            }
        }
        else {
            assert(0);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7694">
htable_t *jl_gc_get_finalizer_table();
/*
static void jl_serialize_finalizers(ios_t *s)
{
    htable_t *finalizer_table = jl_gc_get_finalizer_table();
    int i;
    for(i=0; i &lt; finalizer_table-&gt;size; i+=2) {
        if (finalizer_table-&gt;table[i+1] != HT_NOTFOUND) {
            jl_serialize_value(s, finalizer_table-&gt;table[i]);
            jl_serialize_value(s, finalizer_table-&gt;table[i+1]);
        }
    }
    jl_serialize_value(s, NULL);
}
*/
// --- deserialize ---

static jl_value_t *jl_deserialize_value(ios_t *s);

</t>
<t tx="ekr.20120404123906.7695">static jl_fptr_t jl_deserialize_fptr(ios_t *s)
{
    int fptr = read_int32(s);
    if (fptr == 0)
        return NULL;
    void **pbp = ptrhash_bp(&amp;id_to_fptr, (void*)(ptrint_t)fptr);
    if (*pbp == HT_NOTFOUND)
        jl_error("unknown function pointer ID");
    return *(jl_fptr_t*)pbp;
}
</t>
<t tx="ekr.20120404123906.7696">
static jl_value_t *jl_deserialize_tag_type(ios_t *s, jl_struct_type_t *kind, int pos)
{
    if (kind == jl_struct_kind) {
        jl_struct_type_t *st =
            (jl_struct_type_t*)newobj((jl_type_t*)jl_struct_kind,
                                      STRUCT_TYPE_NW);
        st-&gt;instance = NULL;
        ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, st);
        st-&gt;name = (jl_typename_t*)jl_deserialize_value(s);
        st-&gt;parameters = (jl_tuple_t*)jl_deserialize_value(s);
        st-&gt;super = (jl_tag_type_t*)jl_deserialize_value(s);
        st-&gt;names = (jl_tuple_t*)jl_deserialize_value(s);
        st-&gt;types = (jl_tuple_t*)jl_deserialize_value(s);
        st-&gt;ctor_factory = jl_deserialize_value(s);
        st-&gt;env = jl_deserialize_value(s);
        st-&gt;linfo = (jl_lambda_info_t*)jl_deserialize_value(s);
        st-&gt;fptr = jl_deserialize_fptr(s);
        st-&gt;uid = read_int32(s);;
        if (st-&gt;name == jl_array_type-&gt;name) {
            // builtin types are not serialized, so their caches aren't
            // explicitly saved. so we reconstruct the caches of builtin
            // parametric types here.
            jl_cell_1d_push(tagtype_list, (jl_value_t*)st);
        }
        return (jl_value_t*)st;
    }
    else if (kind == jl_bits_kind) {
        int form = read_uint8(s);
        jl_bits_type_t *bt;
        if (form == 2)
            bt = jl_int32_type;
        else if (form == 3)
            bt = jl_bool_type;
        else if (form == 4)
            bt = jl_int64_type;
        else
            bt = (jl_bits_type_t*)newobj((jl_type_t*)jl_bits_kind,
                                         BITS_TYPE_NW);
        ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, bt);
        bt-&gt;name = (jl_typename_t*)jl_deserialize_value(s);
        bt-&gt;parameters = (jl_tuple_t*)jl_deserialize_value(s);

        size_t nbits = read_int32(s);
        bt-&gt;nbits = nbits;
        bt-&gt;bnbits = jl_box_int32(nbits);
        bt-&gt;fptr = NULL;
        bt-&gt;env = NULL;
        bt-&gt;linfo = NULL;
        bt-&gt;super = (jl_tag_type_t*)jl_deserialize_value(s);
        bt-&gt;uid = read_int32(s);
        if (bt-&gt;name == jl_pointer_type-&gt;name) {
            jl_cell_1d_push(tagtype_list, (jl_value_t*)bt);
        }
        return (jl_value_t*)bt;
    }
    else {
        assert(kind == jl_tag_kind);
        jl_tag_type_t *tt =
            (jl_tag_type_t*)newobj((jl_type_t*)jl_tag_kind, TAG_TYPE_NW);
        ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, tt);
        tt-&gt;name = (jl_typename_t*)jl_deserialize_value(s);
        tt-&gt;parameters = (jl_tuple_t*)jl_deserialize_value(s);
        tt-&gt;super = (jl_tag_type_t*)jl_deserialize_value(s);
        tt-&gt;fptr = NULL;
        tt-&gt;env = NULL;
        tt-&gt;linfo = NULL;
        if (tt-&gt;name == jl_type_type-&gt;name || tt-&gt;name == jl_seq_type-&gt;name ||
            tt-&gt;name == jl_abstractarray_type-&gt;name) {
            jl_cell_1d_push(tagtype_list, (jl_value_t*)tt);
        }
        return (jl_value_t*)tt;
    }
    assert(0);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7697">
static jl_value_t *jl_deserialize_value(ios_t *s)
{
    int pos = ios_pos(s);
    int32_t tag = read_uint8(s);
    if (tag == Null_tag)
        return NULL;
    if (tag == 0) {
        tag = read_uint8(s);
        jl_value_t *v = ptrhash_get(&amp;deser_tag, (void*)(ptrint_t)tag);
        assert(v != HT_NOTFOUND);
        return v;
    }
    if (tag == BackRef_tag) {
        assert(tree_literal_values == NULL);
        ptrint_t offs = read_int32(s);
        void **bp = ptrhash_bp(&amp;backref_table, (void*)(ptrint_t)offs);
        assert(*bp != HT_NOTFOUND);
        return (jl_value_t*)*bp;
    }

    jl_value_t *vtag=(jl_value_t*)ptrhash_get(&amp;deser_tag,(void*)(ptrint_t)tag);
    if (tag &gt;= VALUE_TAGS) {
        return vtag;
    }

    int usetable = (tree_literal_values == NULL);

    size_t i;
    if (vtag == (jl_value_t*)jl_tuple_type ||
        vtag == (jl_value_t*)LongTuple_tag) {
        size_t len;
        if (vtag == (jl_value_t*)jl_tuple_type)
            len = read_uint8(s);
        else
            len = read_int32(s);
        jl_tuple_t *tu = jl_alloc_tuple_uninit(len);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, (jl_value_t*)tu);
        for(i=0; i &lt; len; i++)
            jl_tupleset(tu, i, jl_deserialize_value(s));
        return (jl_value_t*)tu;
    }
    else if (vtag == (jl_value_t*)jl_symbol_type ||
             vtag == (jl_value_t*)LongSymbol_tag) {
        size_t len;
        if (vtag == (jl_value_t*)jl_symbol_type)
            len = read_uint8(s);
        else
            len = read_int32(s);
        char *name = alloca(len+1);
        ios_read(s, name, len);
        name[len] = '\0';
        jl_value_t *s = (jl_value_t*)jl_symbol(name);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, s);
        return s;
    }
    else if (vtag == (jl_value_t*)jl_array_type) {
        jl_value_t *aty = jl_deserialize_value(s);
        jl_value_t *elty = jl_tparam0(aty);
        int16_t ndims = jl_unbox_long(jl_tparam1(aty));
        size_t *dims = alloca(ndims*sizeof(size_t));
        for(i=0; i &lt; ndims; i++)
            dims[i] = jl_unbox_long(jl_deserialize_value(s));
        jl_array_t *a = jl_new_array_((jl_type_t*)aty, ndims, dims);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, (jl_value_t*)a);
        if (jl_is_bits_type(elty)) {
            size_t tot = a-&gt;length * a-&gt;elsize;
            ios_read(s, a-&gt;data, tot);
        }
        else {
            for(i=0; i &lt; a-&gt;length; i++) {
                ((jl_value_t**)a-&gt;data)[i] = jl_deserialize_value(s);
            }
        }
        return (jl_value_t*)a;
    }
    else if (vtag == (jl_value_t*)jl_expr_type ||
             vtag == (jl_value_t*)LongExpr_tag) {
        size_t len;
        if (vtag == (jl_value_t*)jl_expr_type)
            len = read_uint8(s);
        else
            len = read_int32(s);
        jl_expr_t *e = jl_exprn((jl_sym_t*)jl_deserialize_value(s), len);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, (jl_value_t*)e);
        e-&gt;etype = jl_deserialize_value(s);
        for(i=0; i &lt; len; i++) {
            jl_cellset(e-&gt;args, i, jl_deserialize_value(s));
        }
        return (jl_value_t*)e;
    }
    else if (vtag == (jl_value_t*)LiteralVal_tag) {
        return jl_cellref(tree_literal_values, read_uint16(s));
    }
    else if (vtag == (jl_value_t*)jl_tvar_type) {
        jl_tvar_t *tv = (jl_tvar_t*)newobj((jl_type_t*)jl_tvar_type, 4);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, tv);
        tv-&gt;name = (jl_sym_t*)jl_deserialize_value(s);
        tv-&gt;lb = jl_deserialize_value(s);
        tv-&gt;ub = jl_deserialize_value(s);
        tv-&gt;bound = read_int8(s);
        return (jl_value_t*)tv;
    }
    else if (vtag == (jl_value_t*)jl_function_type) {
        jl_function_t *f =
            (jl_function_t*)newobj((jl_type_t*)jl_function_type, 3);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, f);
        f-&gt;linfo = (jl_lambda_info_t*)jl_deserialize_value(s);
        f-&gt;env = jl_deserialize_value(s);
        f-&gt;fptr = jl_deserialize_fptr(s);
        return (jl_value_t*)f;
    }
    else if (vtag == (jl_value_t*)jl_lambda_info_type) {
        jl_lambda_info_t *li =
            (jl_lambda_info_t*)newobj((jl_type_t*)jl_lambda_info_type,
                                      LAMBDA_INFO_NW);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, li);
        li-&gt;ast = jl_deserialize_value(s);
        li-&gt;sparams = (jl_tuple_t*)jl_deserialize_value(s);
        li-&gt;tfunc = jl_deserialize_value(s);
        li-&gt;name = (jl_sym_t*)jl_deserialize_value(s);
        li-&gt;specTypes = jl_deserialize_value(s);
        li-&gt;specializations = (jl_array_t*)jl_deserialize_value(s);
        li-&gt;inferred = jl_deserialize_value(s);
        li-&gt;file = jl_deserialize_value(s);
        li-&gt;line = jl_deserialize_value(s);
        li-&gt;module = (jl_module_t*)jl_deserialize_value(s);

        li-&gt;fptr = &amp;jl_trampoline;
        li-&gt;roots = NULL;
        li-&gt;functionObject = NULL;
        li-&gt;inInference = 0;
        li-&gt;inCompile = 0;
        li-&gt;unspecialized = NULL;
        return (jl_value_t*)li;
    }
    else if (vtag == (jl_value_t*)jl_module_type) {
        jl_module_t *m = jl_new_module(anonymous_sym);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, m);
        m-&gt;name = (jl_sym_t*)jl_deserialize_value(s);
        while (1) {
            jl_value_t *name = jl_deserialize_value(s);
            if (name == NULL)
                break;
            jl_binding_t *b = jl_get_binding_wr(m, (jl_sym_t*)name);
            b-&gt;value = jl_deserialize_value(s);
            b-&gt;type = (jl_type_t*)jl_deserialize_value(s);
            b-&gt;constp = read_int8(s);
            b-&gt;exportp = read_int8(s);
        }
        while (1) {
            jl_value_t *name = jl_deserialize_value(s);
            if (name == NULL)
                break;
            jl_set_expander(m, (jl_sym_t*)name,
                            (jl_function_t*)jl_deserialize_value(s));
        }
        return (jl_value_t*)m;
    }
    else if (vtag == (jl_value_t*)SmallInt64_tag) {
        jl_value_t *v = jl_box_int64(read_int32(s));
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, v);
        return v;
    }
    else if (vtag == (jl_value_t*)jl_bits_kind) {
        jl_bits_type_t *bt = (jl_bits_type_t*)jl_deserialize_value(s);
        int nby = bt-&gt;nbits/8;
        char *data = alloca(nby);
        ios_read(s, data, nby);
        jl_value_t *v=NULL;
        if (bt == jl_int32_type)
            v = jl_box_int32(*(int32_t*)data);
        else if (bt == jl_int64_type)
            v = jl_box_int64(*(int64_t*)data);
        else if (bt == jl_bool_type)
            v = jl_box_bool(*(int8_t*)data);
        else {
            switch (bt-&gt;nbits) {
            case  8: v = jl_box8 (bt, *(int8_t*) data); break;
            case 16: v = jl_box16(bt, *(int16_t*)data); break;
            case 32: v = jl_box32(bt, *(int32_t*)data); break;
            case 64: v = jl_box64(bt, *(int64_t*)data); break;
            default:
                v = (jl_value_t*)allocobj(sizeof(void*)+nby);
                v-&gt;type = (jl_type_t*)bt;
                memcpy(jl_bits_data(v), data, nby);
            }
        }
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, v);
        return v;
    }
    else if (vtag == (jl_value_t*)jl_struct_kind) {
        jl_struct_type_t *typ = (jl_struct_type_t*)jl_deserialize_value(s);
        if (typ == jl_struct_kind || typ == jl_bits_kind)
            return jl_deserialize_tag_type(s, typ, pos);
        size_t nf = typ-&gt;names-&gt;length;
        jl_value_t *v = jl_new_struct_uninit(typ);
        if (usetable)
            ptrhash_put(&amp;backref_table, (void*)(ptrint_t)pos, v);
        for(i=0; i &lt; nf; i++) {
            ((jl_value_t**)v)[i+1] = jl_deserialize_value(s);
        }
        // TODO: put WeakRefs on the weak_refs list
        return v;
    }
    else if (vtag == (jl_value_t*)jl_tag_kind) {
        return jl_deserialize_tag_type(s, jl_tag_kind, pos);
    }
    assert(0);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7698">
/*
static void jl_deserialize_finalizers(ios_t *s)
{
    htable_t *finalizer_table = jl_gc_get_finalizer_table();
    while (1) {
        jl_value_t *v = jl_deserialize_value(s);
        if (v == NULL)
            break;
        void **bp = ptrhash_bp(finalizer_table, v);
        *bp = jl_deserialize_value(s);
    }
}
*/
// --- entry points ---

</t>
<t tx="ekr.20120404123906.7699">DLLEXPORT
void jl_save_system_image(char *fname, char *startscriptname)
{
    jl_gc_collect();
    jl_gc_collect();
    int en = jl_gc_is_enabled();
    jl_gc_disable();
    htable_reset(&amp;backref_table, 50000);
    ios_t f;
    ios_file(&amp;f, fname, 1, 1, 1, 1);

    if (jl_current_module != jl_base_module) {
        // set up for stage 1 bootstrap, where the Base module is already
        // loaded and we are loading an updated copy in a separate module.

        // step 1: set Core.Base = current_module
        jl_binding_t *b = jl_get_binding_wr(jl_core_module, jl_symbol("Base"));
        b-&gt;value = (jl_value_t*)jl_current_module;
        assert(b-&gt;constp);

        // step 2: set current_module.Core = Core
        jl_set_const(jl_current_module, jl_symbol("Core"), (jl_value_t*)jl_core_module);

        // step 3: current_module.Base = current_module
        b = jl_get_binding_wr(jl_current_module, jl_symbol("Base"));
        b-&gt;value = (jl_value_t*)jl_current_module;
        assert(b-&gt;constp);

        // step 4: remove current_module.current_module
        b = jl_get_binding_wr(jl_current_module, jl_current_module-&gt;name);
        b-&gt;value = NULL; b-&gt;constp = 0;

        // step 5: rename current_module to Base
        jl_current_module-&gt;name = jl_symbol("Base");

        // step 6: orphan old Base module
        jl_base_module = jl_current_module;
    }
    else {
        // delete cached slow ASCIIString constructor
        jl_methtable_t *mt = jl_gf_mtable((jl_function_t*)jl_ascii_string_type);
        mt-&gt;cache = NULL;
        mt-&gt;cache_arg1 = NULL;
        mt-&gt;defs-&gt;func-&gt;linfo-&gt;tfunc = (jl_value_t*)jl_null;
        mt-&gt;defs-&gt;func-&gt;linfo-&gt;specializations = NULL;
    }

    jl_idtable_type = jl_get_global(jl_base_module, jl_symbol("IdTable"));
    idtable_list = jl_alloc_cell_1d(0);

    jl_serialize_value(&amp;f, jl_array_type-&gt;env);

    jl_serialize_value(&amp;f, jl_core_module);
    jl_serialize_value(&amp;f, jl_current_module);

    jl_serialize_value(&amp;f, idtable_list);

    //jl_serialize_finalizers(&amp;f);
    write_int32(&amp;f, jl_get_t_uid_ctr());
    write_int32(&amp;f, jl_get_gs_ctr());
    htable_reset(&amp;backref_table, 0);

    ios_t ss;
    ios_file(&amp;ss, startscriptname, 1, 0, 0, 0);
    ios_copyall(&amp;f, &amp;ss);
    ios_close(&amp;ss);
    ios_putc(0, &amp;f);

    ios_close(&amp;f);
    if (en) jl_gc_enable();
}
</t>
<t tx="ekr.20120404123906.7700">
extern jl_function_t *jl_typeinf_func;
extern int jl_boot_file_loaded;
extern void jl_get_builtin_hooks(void);
extern void jl_get_system_hooks(void);

</t>
<t tx="ekr.20120404123906.7701">DLLEXPORT
void jl_restore_system_image(char *fname)
{
    ios_t f;
    char *fpath = jl_find_file_in_path(fname);
    if (ios_file(&amp;f, fpath, 1, 0, 0, 0) == NULL) {
        ios_printf(ios_stderr, "system image file not found\n");
        exit(1);
    }
#ifdef JL_GC_MARKSWEEP
    int en = jl_gc_is_enabled();
    jl_gc_disable();
#endif

    tagtype_list = jl_alloc_cell_1d(0);

    jl_array_type-&gt;env = jl_deserialize_value(&amp;f);
    
    jl_core_module = (jl_module_t*)jl_deserialize_value(&amp;f);
    jl_current_module = (jl_module_t*)jl_deserialize_value(&amp;f);
    jl_base_module = (jl_module_t*)jl_get_global(jl_core_module,
                                                 jl_symbol("Base"));

    jl_array_t *idtl = (jl_array_t*)jl_deserialize_value(&amp;f);
    // rehash IdTables
    for(int i=0; i &lt; idtl-&gt;length; i++) {
        jl_value_t *v = jl_cellref(idtl, i);
        jl_idtable_rehash(&amp;((jl_array_t**)v)[1],
                          ((jl_array_t**)v)[1]-&gt;length);
    }

    // cache builtin parametric types
    for(int i=0; i &lt; tagtype_list-&gt;length; i++) {
        jl_value_t *v = jl_cellref(tagtype_list, i);
        uint32_t uid=0;
        if (jl_is_struct_type(v))
            uid = ((jl_struct_type_t*)v)-&gt;uid;
        else if (jl_is_bits_type(v))
            uid = ((jl_bits_type_t*)v)-&gt;uid;
        jl_cache_type_((jl_tag_type_t*)v);
        if (jl_is_struct_type(v))
            ((jl_struct_type_t*)v)-&gt;uid = uid;
        else if (jl_is_bits_type(v))
            ((jl_bits_type_t*)v)-&gt;uid = uid;
    }

    jl_get_builtin_hooks();
    jl_get_system_hooks();
    jl_boot_file_loaded = 1;
    jl_typeinf_func = (jl_function_t*)jl_get_global(jl_base_module,
                                                    jl_symbol("typeinf_ext"));
    jl_init_box_caches();

    //jl_deserialize_finalizers(&amp;f);
    jl_set_t_uid_ctr(read_int32(&amp;f));
    jl_set_gs_ctr(read_int32(&amp;f));
    htable_reset(&amp;backref_table, 0);

    ios_t ss;
    ios_mem(&amp;ss, 0);
    ios_copyuntil(&amp;ss, &amp;f, '\0');
    ios_close(&amp;f);
    if (fpath != fname) free(fpath);

#ifdef JL_GC_MARKSWEEP
    if (en) jl_gc_enable();
#endif

    // TODO: there is no exception handler here!
    jl_load_file_string(ss.buf);
    ios_close(&amp;ss);
}
</t>
<t tx="ekr.20120404123906.7702">
DLLEXPORT
jl_value_t *jl_compress_ast(jl_lambda_info_t *li, jl_value_t *ast)
{
    ios_t dest;
    jl_ios_mem(&amp;dest, 0);
    int en = jl_gc_is_enabled();
    jl_gc_disable();

    if (li-&gt;roots == NULL)
        li-&gt;roots = jl_alloc_cell_1d(0);
    tree_literal_values = li-&gt;roots;
    jl_serialize_value(&amp;dest, ast);

    //ios_printf(ios_stderr, "%d bytes, %d values\n", dest.size, vals-&gt;length);

    jl_value_t *v = (jl_value_t*)jl_takebuf_array(&amp;dest);
    if (tree_literal_values-&gt;length == 0) {
        tree_literal_values = (jl_array_t*)jl_an_empty_cell;
        li-&gt;roots = NULL;
    }
    v = (jl_value_t*)jl_tuple(4, v, tree_literal_values,
                              jl_lam_body((jl_expr_t*)ast)-&gt;etype,
                              jl_lam_capt((jl_expr_t*)ast));

    tree_literal_values = NULL;
    if (en)
        jl_gc_enable();
    return v;
}
</t>
<t tx="ekr.20120404123906.7703">
DLLEXPORT
jl_value_t *jl_uncompress_ast(jl_tuple_t *data)
{
    jl_array_t *bytes = (jl_array_t*)jl_tupleref(data, 0);
    tree_literal_values = (jl_array_t*)jl_tupleref(data, 1);
    ios_t src;
    jl_ios_mem(&amp;src, 0);
    ios_setbuf(&amp;src, bytes-&gt;data, bytes-&gt;length, 0);
    src.size = bytes-&gt;length;
    int en = jl_gc_is_enabled();
    jl_gc_disable();
    jl_gc_ephemeral_on();
    jl_value_t *v = jl_deserialize_value(&amp;src);
    jl_gc_ephemeral_off();
    if (en)
        jl_gc_enable();
    tree_literal_values = NULL;
    return v;
}
</t>
<t tx="ekr.20120404123906.7704">
// --- init ---

</t>
<t tx="ekr.20120404123906.7705">void jl_init_serializer(void)
{
    htable_new(&amp;ser_tag, 0);
    htable_new(&amp;deser_tag, 0);
    htable_new(&amp;fptr_to_id, 0);
    htable_new(&amp;id_to_fptr, 0);
    htable_new(&amp;backref_table, 50000);

    void *tags[] = { jl_symbol_type, jl_tag_kind, jl_bits_kind, jl_struct_kind,
                     jl_function_type, jl_tuple_type, jl_array_type,
                     jl_expr_type, (void*)LongSymbol_tag, (void*)LongTuple_tag,
                     (void*)LongExpr_tag, (void*)LiteralVal_tag,
                     (void*)SmallInt64_tag, jl_module_type, jl_tvar_type,
                     jl_lambda_info_type,

                     jl_null, jl_false, jl_true, jl_any_type, jl_symbol("Any"),
                     jl_symbol("Array"), jl_symbol("TypeVar"),
                     jl_symbol("FuncKind"), jl_symbol("Box"),
                     lambda_sym, body_sym, return_sym, call_sym, colons_sym,
                     null_sym, goto_ifnot_sym, assign_sym,

                     jl_symbol("a"), jl_symbol("b"), jl_symbol("c"),
                     jl_symbol("d"), jl_symbol("e"), jl_symbol("f"),
                     jl_symbol("g"), jl_symbol("h"), jl_symbol("i"),
                     jl_symbol("j"), jl_symbol("k"), jl_symbol("l"),
                     jl_symbol("m"), jl_symbol("n"), jl_symbol("o"),
                     jl_symbol("p"), jl_symbol("q"), jl_symbol("r"),
                     jl_symbol("s"), jl_symbol("t"), jl_symbol("u"),
                     jl_symbol("v"), jl_symbol("w"), jl_symbol("x"),
                     jl_symbol("y"), jl_symbol("z"),
                     jl_symbol("A"), jl_symbol("B"), jl_symbol("C"),
                     jl_symbol("M"), jl_symbol("I"), jl_symbol("N"),
                     jl_symbol("T"), jl_symbol("S"),
                     jl_symbol("X"), jl_symbol("Y"),
                     jl_symbol("add_int"), jl_symbol("sub_int"),
                     jl_symbol("mul_int"), 
                     jl_symbol("add_float"), jl_symbol("sub_float"),
                     jl_symbol("mul_float"), jl_symbol("unbox8"),
                     jl_symbol("unbox32"), jl_symbol("unbox64"),
                     jl_symbol("box"), jl_symbol("boxf32"), jl_symbol("boxf64"),
                     jl_symbol("boxsi32"), jl_symbol("boxsi64"),
                     jl_symbol("eq_int"), jl_symbol("slt_int"),
                     jl_symbol("sle_int"), jl_symbol("ne_int"),
                     jl_symbol("arrayset"), jl_symbol("arrayref"),
                     jl_symbol("convert"), jl_symbol("typeassert"),
                     jl_symbol("getfield"), jl_symbol("_setfield"),
                     jl_symbol("tupleref"), jl_symbol("tuplelen"),
                     jl_symbol("apply_type"), jl_symbol("tuple"),

                     jl_box_int32(0), jl_box_int32(1), jl_box_int32(2),
                     jl_box_int32(3), jl_box_int32(4), jl_box_int32(5),
                     jl_box_int32(6), jl_box_int32(7), jl_box_int32(8),
                     jl_box_int32(9), jl_box_int32(10), jl_box_int32(11),
                     jl_box_int32(12), jl_box_int32(13), jl_box_int32(14),
                     jl_box_int32(15), jl_box_int32(16), jl_box_int32(17),
                     jl_box_int32(18), jl_box_int32(19), jl_box_int32(20),
                     jl_box_int32(21), jl_box_int32(22), jl_box_int32(23),
                     jl_box_int32(24), jl_box_int32(25), jl_box_int32(26),
                     jl_box_int32(27), jl_box_int32(28), jl_box_int32(29),
                     jl_box_int32(30), jl_box_int32(31), jl_box_int32(32),
#ifndef __LP64__
                     jl_box_int32(33), jl_box_int32(34), jl_box_int32(35),
                     jl_box_int32(36), jl_box_int32(37), jl_box_int32(38),
                     jl_box_int32(39), jl_box_int32(40), jl_box_int32(41),
                     jl_box_int32(42), jl_box_int32(43), jl_box_int32(44),
                     jl_box_int32(45), jl_box_int32(46), jl_box_int32(47),
                     jl_box_int32(48), jl_box_int32(49), jl_box_int32(50),
                     jl_box_int32(51), jl_box_int32(52), jl_box_int32(53),
                     jl_box_int32(54), jl_box_int32(55), jl_box_int32(56),
                     jl_box_int32(57), jl_box_int32(58), jl_box_int32(59),
                     jl_box_int32(60), jl_box_int32(61), jl_box_int32(62),
                     jl_box_int32(63), jl_box_int32(64),
#endif
                     jl_box_int64(0), jl_box_int64(1), jl_box_int64(2),
                     jl_box_int64(3), jl_box_int64(4), jl_box_int64(5),
                     jl_box_int64(6), jl_box_int64(7), jl_box_int64(8),
                     jl_box_int64(9), jl_box_int64(10), jl_box_int64(11),
                     jl_box_int64(12), jl_box_int64(13), jl_box_int64(14),
                     jl_box_int64(15), jl_box_int64(16), jl_box_int64(17),
                     jl_box_int64(18), jl_box_int64(19), jl_box_int64(20),
                     jl_box_int64(21), jl_box_int64(22), jl_box_int64(23),
                     jl_box_int64(24), jl_box_int64(25), jl_box_int64(26),
                     jl_box_int64(27), jl_box_int64(28), jl_box_int64(29),
                     jl_box_int64(30), jl_box_int64(31), jl_box_int64(32),
#ifdef __LP64__
                     jl_box_int64(33), jl_box_int64(34), jl_box_int64(35),
                     jl_box_int64(36), jl_box_int64(37), jl_box_int64(38),
                     jl_box_int64(39), jl_box_int64(40), jl_box_int64(41),
                     jl_box_int64(42), jl_box_int64(43), jl_box_int64(44),
                     jl_box_int64(45), jl_box_int64(46), jl_box_int64(47),
                     jl_box_int64(48), jl_box_int64(49), jl_box_int64(50),
                     jl_box_int64(51), jl_box_int64(52), jl_box_int64(53),
                     jl_box_int64(54), jl_box_int64(55), jl_box_int64(56),
                     jl_box_int64(57), jl_box_int64(58), jl_box_int64(59),
                     jl_box_int64(60), jl_box_int64(61), jl_box_int64(62),
                     jl_box_int64(63), jl_box_int64(64),
#endif
                     jl_labelnode_type, jl_linenumbernode_type,
                     jl_gotonode_type, jl_quotenode_type, jl_topnode_type,
                     jl_type_type, jl_bottom_type, jl_pointer_type,
                     jl_seq_type, jl_ntuple_type, jl_abstractarray_type,
                     jl_box_type, jl_typector_type, jl_undef_type, jl_top_type,
                     jl_typename_type, jl_task_type, jl_union_kind,
                     jl_typetype_type, jl_typetype_tvar, jl_ANY_flag,
                     jl_array_any_type, jl_intrinsic_type, jl_method_type,
                     jl_methtable_type,

                     jl_symbol_type-&gt;name, jl_pointer_type-&gt;name,
                     jl_tag_kind-&gt;name, jl_union_kind-&gt;name, jl_bits_kind-&gt;name, jl_struct_kind-&gt;name,
                     jl_array_type-&gt;name, jl_expr_type-&gt;name,
                     jl_typename_type-&gt;name, jl_type_type-&gt;name, jl_methtable_type-&gt;name,
                     jl_method_type-&gt;name, jl_tvar_type-&gt;name,
                     jl_seq_type-&gt;name, jl_ntuple_type-&gt;name, jl_abstractarray_type-&gt;name,
                     jl_lambda_info_type-&gt;name, jl_module_type-&gt;name,
                     jl_box_type-&gt;name, jl_function_type-&gt;name,
                     jl_typector_type-&gt;name, jl_intrinsic_type-&gt;name, jl_undef_type-&gt;name,
                     jl_task_type-&gt;name,
                     jl_labelnode_type-&gt;name, jl_linenumbernode_type-&gt;name,
                     jl_gotonode_type-&gt;name, jl_quotenode_type-&gt;name,
                     jl_topnode_type-&gt;name,

                     jl_root_task,

                     NULL };
    ptrint_t i=2;
    while (tags[i-2] != NULL) {
        ptrhash_put(&amp;ser_tag, tags[i-2], (void*)i);
        ptrhash_put(&amp;deser_tag, (void*)i, tags[i-2]);
        i += 1;
    }
    assert(i &lt;= Null_tag);
    VALUE_TAGS = (ptrint_t)ptrhash_get(&amp;ser_tag, jl_null);

    void *fptrs[] = { jl_f_new_expr, jl_f_new_box,
                      jl_f_throw, jl_f_is, 
                      jl_f_no_function, jl_f_typeof, 
                      jl_f_subtype, jl_f_isa, 
                      jl_f_typeassert, jl_f_apply, 
                      jl_f_top_eval, jl_f_isbound, 
                      jl_f_tuple, jl_f_tupleref, 
                      jl_f_tuplelen, jl_f_get_field, 
                      jl_f_set_field, jl_f_field_type, 
                      jl_f_arraylen, jl_f_arrayref, 
                      jl_f_arrayset, jl_f_arraysize, 
                      jl_f_instantiate_type,
                      jl_f_convert_default, jl_f_convert_tuple,
                      jl_trampoline, jl_f_new_struct_type, 
                      jl_f_new_struct_fields, jl_f_new_type_constructor, 
                      jl_f_new_tag_type, jl_f_new_tag_type_super, 
                      jl_f_new_bits_type, jl_f_def_macro,
                      jl_f_typevar, jl_f_union, 
                      jl_f_methodexists, jl_f_applicable, 
                      jl_f_invoke, jl_apply_generic, 
                      jl_unprotect_stack, jl_f_task, 
                      jl_f_yieldto, jl_f_ctor_trampoline,
                      NULL };
    i=2;
    while (fptrs[i-2] != NULL) {
        ptrhash_put(&amp;fptr_to_id, fptrs[i-2], (void*)i);
        ptrhash_put(&amp;id_to_fptr, (void*)i, fptrs[i-2]);
        i += 1;
    }
}
</t>
<t tx="ekr.20120404123906.7706">@language c
@tabwidth -4
@others
#endif //MEMPROFILE
</t>
<t tx="ekr.20120404123906.7707">/*
  allocation and garbage collection
  . non-moving, precise mark and sweep collector
  . pool-allocates small objects, keeps big objects on a simple list
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"

// with MEMDEBUG, every object is allocated explicitly with malloc, and
// filled with 0xbb before being freed.
// NOTE: needs to be defined in ios.c too, due to GC/IObuffer interaction
//#define MEMDEBUG

// MEMPROFILE prints pool summary statistics after every GC
// NOTE: define in ios.c too
//#define MEMPROFILE

// GCTIME prints time taken by each phase of GC
//#define GCTIME

// OBJPROFILE counts objects by type
//#define OBJPROFILE

#define GC_PAGE_SZ (1536*sizeof(void*)+8)//bytes

typedef struct _gcpage_t {
    union {
        struct _gcpage_t *next;
        char _pad[8];
    };
    char data[GC_PAGE_SZ - 8];
} gcpage_t;

typedef struct _gcval_t {
    union {
        struct _gcval_t *next;
        uptrint_t flags;
        uptrint_t data0;  // overlapped
        uptrint_t marked:1;
    };
} gcval_t;

typedef struct _pool_t {
    size_t osize;
    gcpage_t *pages;
    gcval_t *freelist;
} pool_t;

typedef struct _bigval_t {
    struct _bigval_t *next;
#if defined(MEMDEBUG) || defined(MEMPROFILE)
    union {
        size_t sz;
        char _pad[8];
    };
#endif
    union {
        uptrint_t flags;
        struct {
            uptrint_t marked:1;
            uptrint_t isobj:1;
        };
    };
    char _data[1];
} bigval_t;

#if defined(MEMDEBUG) || defined(MEMPROFILE)
# ifdef __LP64__
#  define BVOFFS 3
# else
#  define BVOFFS 4
# endif
#else
#define BVOFFS 2
#endif

#define gc_val(o)     ((gcval_t*)(((void**)(o))-1))
#define gc_marked(o)  (gc_val(o)-&gt;marked)
#define gc_setmark(o) (gc_val(o)-&gt;marked=1)
#define gc_marked_obj(o)  (((gcval_t*)(o))-&gt;marked)
#define gc_setmark_obj(o) (((gcval_t*)(o))-&gt;marked=1)

static bigval_t *big_objects = NULL;

#define N_POOLS 42
static pool_t norm_pools[N_POOLS];
static pool_t ephe_pools[N_POOLS];
static pool_t *pools = &amp;norm_pools[0];

static size_t allocd_bytes = 0;
static const size_t collect_interval = 3200*1024*sizeof(void*);

static htable_t finalizer_table;
static arraylist_t to_finalize;

static arraylist_t preserved_values;

static arraylist_t weak_refs;

#ifdef OBJPROFILE
static htable_t obj_counts;
</t>
<t tx="ekr.20120404123906.7708">#endif

</t>
<t tx="ekr.20120404123906.7709">int jl_gc_n_preserved_values(void)
{
    return preserved_values.len;
}
</t>
<t tx="ekr.20120404123906.7710">
void jl_gc_preserve(jl_value_t *v)
{
    arraylist_push(&amp;preserved_values, (void*)v);
}
</t>
<t tx="ekr.20120404123906.7711">
void jl_gc_unpreserve(void)
{
    (void)arraylist_pop(&amp;preserved_values);
}
</t>
<t tx="ekr.20120404123906.7712">
DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value)
{
    jl_weakref_t *wr = (jl_weakref_t*)alloc_2w();
    wr-&gt;type = (jl_type_t*)jl_weakref_type;
    wr-&gt;value = value;
    arraylist_push(&amp;weak_refs, wr);
    return wr;
}
</t>
<t tx="ekr.20120404123906.7713">
static void sweep_weak_refs(void)
{
    size_t n=0, ndel=0, l=weak_refs.len;
    jl_weakref_t *wr;
    void **lst = weak_refs.items;
    void *tmp;
#define SWAP_wr(a,b) (tmp=a,a=b,b=tmp,1)
    if (l == 0)
        return;
    do {
        wr = (jl_weakref_t*)lst[n];
        if (gc_marked_obj(wr)) {
            // weakref itself is alive
            if (!gc_marked_obj(wr-&gt;value))
                wr-&gt;value = (jl_value_t*)jl_nothing;
            n++;
        }
        else {
            ndel++;
        }
    } while ((n &lt; l-ndel) &amp;&amp; SWAP_wr(lst[n],lst[n+ndel]));

    weak_refs.len -= ndel;
}
</t>
<t tx="ekr.20120404123906.7714">
static void schedule_finalization(void *o)
{
    arraylist_push(&amp;to_finalize, o);
}
</t>
<t tx="ekr.20120404123906.7715">
static void run_finalizers(void)
{
    void *o = NULL;
    jl_function_t *f=NULL;
    jl_value_t *ff=NULL;
    JL_GC_PUSH(&amp;o, &amp;f, &amp;ff);
    while (to_finalize.len &gt; 0) {
        o = arraylist_pop(&amp;to_finalize);
        ff = (jl_value_t*)ptrhash_get(&amp;finalizer_table, o);
        assert(ff != HT_NOTFOUND);
        ptrhash_remove(&amp;finalizer_table, o);
        while (jl_is_tuple(ff)) {
            f = (jl_function_t*)jl_t0(ff);
            assert(jl_is_function(f));
            JL_TRY {
                jl_apply(f, (jl_value_t**)&amp;o, 1);
            }
            JL_CATCH {
            }
            ff = jl_t1(ff);
        }
        f = (jl_function_t*)ff;
        assert(jl_is_function(f));
        jl_apply(f, (jl_value_t**)&amp;o, 1);
    }
    JL_GC_POP();
}
</t>
<t tx="ekr.20120404123906.7716">
void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f)
{
    jl_value_t **bp = (jl_value_t**)ptrhash_bp(&amp;finalizer_table, v);
    if (*bp == HT_NOTFOUND) {
        *bp = (jl_value_t*)f;
    }
    else {
        *bp = (jl_value_t*)jl_tuple2((jl_value_t*)f, *bp);
    }
}
</t>
<t tx="ekr.20120404123906.7717">
htable_t *jl_gc_get_finalizer_table(void)
{
    return &amp;finalizer_table;
}
</t>
<t tx="ekr.20120404123906.7718">
static int szclass(size_t sz)
{
#ifndef __LP64__
    if     (sz &lt;=    8) return 0;
#endif
    if     (sz &lt;=   56) return ((sz+3)/4) - 2;
    if     (sz &lt;=   96) return ((sz+7)/8) + 5;
    if     (sz &lt;=  512) {
        if (sz &lt;=  256) return ((sz+15)-112)/16 + 18;
        else            return ((sz+31)-288)/32 + 28;
    }
    if     (sz &lt;= 1024) return ((sz+127)-640)/128 + 36;
    if     (sz &lt;= 1536) return 40;
    return 41;
}
</t>
<t tx="ekr.20120404123906.7719">
static void *alloc_big(size_t sz, int isobj)
{
    if (allocd_bytes &gt; collect_interval) {
        jl_gc_collect();
    }
    sz = (sz+3) &amp; -4;
    allocd_bytes += sz;
    size_t offs = BVOFFS*sizeof(void*);
    if (sz + offs &lt; offs)  // overflow in adding offs, size was "negative"
        jl_raise(jl_memory_exception);
    bigval_t *v = (bigval_t*)malloc(sz + offs);
    if (v == NULL)
        jl_raise(jl_memory_exception);
#if defined(MEMDEBUG) || defined(MEMPROFILE)
    v-&gt;sz = sz;
#endif
    v-&gt;next = big_objects;
    v-&gt;flags = 0;
    v-&gt;isobj = isobj;
    big_objects = v;
    return &amp;v-&gt;_data[0];
}
</t>
<t tx="ekr.20120404123906.7720">
void jl_gc_acquire_buffer(void *b)
{
    bigval_t *v = (bigval_t*)(((void**)b)-BVOFFS);
#if defined(MEMDEBUG) || defined(MEMPROFILE)
    v-&gt;sz = 0;  // ???
#endif
    v-&gt;next = big_objects;
    v-&gt;flags = 0;
    v-&gt;isobj = 0;
    big_objects = v;
}
</t>
<t tx="ekr.20120404123906.7721">
#define bigval_word0(v) (((uptrint_t*)(&amp;((bigval_t*)(v))-&gt;_data[0]))[0])

</t>
<t tx="ekr.20120404123906.7722">static void sweep_big(void)
{
    bigval_t *v = big_objects;
    bigval_t **pv = &amp;big_objects;
    while (v != NULL) {
        bigval_t *nxt = v-&gt;next;
        if (v-&gt;isobj &amp;&amp; (bigval_word0(v)&amp;1)) {
            pv = &amp;v-&gt;next;
            bigval_word0(v) &amp;= ~1UL;
        }
        else if (!v-&gt;isobj &amp;&amp; v-&gt;marked) {
            pv = &amp;v-&gt;next;
            v-&gt;marked = 0;
        }
        else {
            *pv = nxt;
#ifdef MEMDEBUG
            memset(v, 0xbb, v-&gt;sz+BVOFFS*sizeof(void*));
#endif
            free(v);
        }
        v = nxt;
    }
}
</t>
<t tx="ekr.20120404123906.7723">
static void add_page(pool_t *p)
{
    gcpage_t *pg = malloc(sizeof(gcpage_t));
    if (pg == NULL)
        jl_raise(jl_memory_exception);
    gcval_t *v = (gcval_t*)&amp;pg-&gt;data[0];
    char *lim = (char*)pg + GC_PAGE_SZ - p-&gt;osize;
    gcval_t *fl;
    gcval_t **pfl = &amp;fl;
    while ((char*)v &lt;= lim) {
        *pfl = v;
        pfl = &amp;v-&gt;next;
        v = (gcval_t*)((char*)v + p-&gt;osize);
    }
    // these statements are ordered so that interrupting after any of them
    // leaves the system in a valid state
    *pfl = p-&gt;freelist;
    pg-&gt;next = p-&gt;pages;
    p-&gt;pages = pg;
    p-&gt;freelist = fl;
}
</t>
<t tx="ekr.20120404123906.7724">
static void *pool_alloc(pool_t *p)
{
    if (allocd_bytes &gt; collect_interval) {
        jl_gc_collect();
    }
    if (p-&gt;freelist == NULL) {
        add_page(p);
    }
    assert(p-&gt;freelist != NULL);
    gcval_t *v = p-&gt;freelist;
    p-&gt;freelist = p-&gt;freelist-&gt;next;
    v-&gt;flags = 0;
    return v;
}
</t>
<t tx="ekr.20120404123906.7725">
static void sweep_pool(pool_t *p)
{
    //int empty;
    int freedall;
    gcval_t **prev_pfl;
    gcval_t *v;
    gcpage_t *pg = p-&gt;pages;
    gcpage_t **ppg = &amp;p-&gt;pages;
    gcval_t **pfl = &amp;p-&gt;freelist;
    size_t osize = p-&gt;osize;

    while (pg != NULL) {
        char *lim = (char*)pg + GC_PAGE_SZ - osize;
        v = (gcval_t*)&amp;pg-&gt;data[0];
        //empty = 1;
        freedall = 1;
        prev_pfl = pfl;
        while ((char*)v &lt;= lim) {
            if (!v-&gt;marked) {
                *pfl = v;
                pfl = &amp;v-&gt;next;
            }
            else {
                v-&gt;marked = 0;
                freedall = 0;
            }
            v = (gcval_t*)((char*)v + osize);
        }
        gcpage_t *nextpg = pg-&gt;next;
        // lazy version: (empty) if the whole page was already unused, free it
        // eager version: (freedall) free page as soon as possible
        // the eager one uses less memory.
        if (freedall) {
            pfl = prev_pfl;
            *ppg = nextpg;
#ifdef MEMDEBUG
            memset(pg, 0xbb, sizeof(gcpage_t));
#endif
            free(pg);
        }
        else {
            ppg = &amp;pg-&gt;next;
        }
        pg = nextpg;
    }
    *pfl = NULL;
}
</t>
<t tx="ekr.20120404123906.7726">
extern void jl_unmark_symbols(void);

</t>
<t tx="ekr.20120404123906.7727">static void gc_sweep(void)
{
    sweep_big();
    int i;
    for(i=0; i &lt; N_POOLS; i++) {
        sweep_pool(&amp;norm_pools[i]);
        sweep_pool(&amp;ephe_pools[i]);
    }
    jl_unmark_symbols();
}
</t>
<t tx="ekr.20120404123906.7728">
#define GC_Markval(v) gc_markval_((jl_value_t*)(v))
static void gc_markval_(jl_value_t *v);

</t>
<t tx="ekr.20120404123906.7729">void jl_gc_markval(jl_value_t *v)
{
    gc_markval_(v);
}
</t>
<t tx="ekr.20120404123906.7730">
static void gc_mark_stack(jl_gcframe_t *s, ptrint_t offset)
{
    while (s != NULL) {
        s = (jl_gcframe_t*)((char*)s + offset);
        size_t i;
        jl_value_t ***rts = (jl_value_t***)((char*)s-&gt;roots + offset);
        if (s-&gt;indirect) {
            for(i=0; i &lt; s-&gt;nroots; i++) {
                jl_value_t **ptr = (jl_value_t**)((char*)rts[i] + offset);
                if (*ptr != NULL)
                    GC_Markval(*ptr);
            }
        }
        else {
            for(i=0; i &lt; s-&gt;nroots; i++) {
                if (rts[i] != NULL)
                    GC_Markval(rts[i]);
            }
        }
        s = s-&gt;prev;
    }
}
</t>
<t tx="ekr.20120404123906.7731">
static void gc_mark_module(jl_module_t *m)
{
    size_t i;
    void **table = m-&gt;bindings.table;
    for(i=1; i &lt; m-&gt;bindings.size; i+=2) {
        if (table[i] != HT_NOTFOUND) {
            jl_binding_t *b = (jl_binding_t*)table[i];
            gc_setmark(b);
            if (b-&gt;value != NULL)
                GC_Markval(b-&gt;value);
            GC_Markval(b-&gt;type);
        }
    }
    table = m-&gt;macros.table;
    for(i=1; i &lt; m-&gt;macros.size; i+=2) {
        if (table[i] != HT_NOTFOUND) {
            GC_Markval((jl_value_t*)table[i]);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7732">
#define gc_typeof(v) ((jl_value_t*)(((uptrint_t)jl_typeof(v))&amp;~1UL))

// for chasing down unwanted references
/*
static jl_value_t *lookforme = NULL;
DLLEXPORT void jl_gc_lookfor(jl_value_t *v) { lookforme = v; }
*/

</t>
<t tx="ekr.20120404123906.7733">static void gc_markval_(jl_value_t *v)
{
    assert(v != NULL);
    //assert(v != lookforme);
    if (gc_marked_obj(v)) return;
    jl_value_t *vt = (jl_value_t*)jl_typeof(v);
#ifdef OBJPROFILE
    void **bp = ptrhash_bp(&amp;obj_counts, vt);
    if (*bp == HT_NOTFOUND)
        *bp = (void*)2;
    else
        (*((ptrint_t*)bp))++;
#endif
    jl_value_t *vtt = gc_typeof(vt);
    gc_setmark_obj(v);

    if (vtt==(jl_value_t*)jl_bits_kind) return;

    // some values have special representations
    if (vt == (jl_value_t*)jl_tuple_type) {
        size_t i;
        for(i=0; i &lt; ((jl_tuple_t*)v)-&gt;length; i++) {
            jl_value_t *elt = ((jl_tuple_t*)v)-&gt;data[i];
            if (elt != NULL)
                GC_Markval(elt);
        }
    }
    else if (((jl_struct_type_t*)(vt))-&gt;name == jl_array_typename) {
        jl_array_t *a = (jl_array_t*)v;
        int ndims = jl_array_ndims(a);
        int ndimwords = (ndims &gt; 2 ? (ndims-2) : 0);
#ifndef __LP64__
        // on 32-bit, ndimwords must be odd to preserve 8-byte alignment
        ndimwords += (~ndimwords)&amp;1;
#endif
        void *data_area = &amp;a-&gt;_space[0] + ndimwords*sizeof(size_t);
        if (a-&gt;reshaped) {
            GC_Markval(*((jl_value_t**)data_area));
        }
        else if (a-&gt;data) {
            char *data = a-&gt;data;
            if (ndims == 1) data -= a-&gt;offset*a-&gt;elsize;
            if (data != data_area) {
                gc_setmark(data);
            }
        }
        jl_value_t *elty = jl_tparam0(vt);
        if (gc_typeof(elty) != (jl_value_t*)jl_bits_kind) {
            size_t i;
            for(i=0; i &lt; a-&gt;length; i++) {
                jl_value_t *elt = ((jl_value_t**)a-&gt;data)[i];
                if (elt != NULL) GC_Markval(elt);
            }
        }
    }
    else if (vt == (jl_value_t*)jl_module_type) {
        gc_mark_module((jl_module_t*)v);
    }
    else if (vt == (jl_value_t*)jl_task_type) {
        jl_task_t *ta = (jl_task_t*)v;
        GC_Markval(ta-&gt;on_exit);
        GC_Markval(ta-&gt;tls);
        if (ta-&gt;start)
            GC_Markval(ta-&gt;start);
        if (ta-&gt;result)
            GC_Markval(ta-&gt;result);
        GC_Markval(ta-&gt;state.eh_task);
        if (ta-&gt;stkbuf != NULL)
            gc_setmark(ta-&gt;stkbuf);
#ifdef COPY_STACKS
        ptrint_t offset;
        if (ta == jl_current_task) {
            offset = 0;
            gc_mark_stack(jl_pgcstack, offset);
        }
        else {
            offset = ta-&gt;stkbuf - (ta-&gt;stackbase-ta-&gt;ssize);
            gc_mark_stack(ta-&gt;state.gcstack, offset);
        }
        jl_savestate_t *ss = &amp;ta-&gt;state;
        while (ss != NULL) {
            GC_Markval(ss-&gt;ostream_obj);
            ss = ss-&gt;prev;
            if (ss != NULL)
                ss = (jl_savestate_t*)((char*)ss + offset);
        }
#else
        gc_mark_stack(ta-&gt;state.gcstack, 0);
        jl_savestate_t *ss = &amp;ta-&gt;state;
        while (ss != NULL) {
            GC_Markval(ss-&gt;ostream_obj);
            ss = ss-&gt;prev;
        }
#endif
    }
    else if (vt == (jl_value_t*)jl_weakref_type) {
        // don't mark contents
    }
    else {
        assert(vtt == (jl_value_t*)jl_struct_kind);
        size_t nf = ((jl_struct_type_t*)vt)-&gt;names-&gt;length;
        size_t i=0;
        if (vt == (jl_value_t*)jl_struct_kind ||
            vt == (jl_value_t*)jl_function_type) {
            i++;  // skip fptr field
        }
        for(; i &lt; nf; i++) {
            jl_value_t *fld = ((jl_value_t**)v)[i+1];
            if (fld)
                GC_Markval(fld);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7734">
void jl_mark_box_caches(void);

extern jl_value_t * volatile jl_task_arg_in_transit;
#ifdef GCTIME
double clock_now(void);
#endif

</t>
<t tx="ekr.20120404123906.7735">static void gc_mark(void)
{
    // mark all roots

    // active tasks
    GC_Markval(jl_root_task);
    GC_Markval(jl_current_task);

    // modules
    GC_Markval(jl_core_module);
    GC_Markval(jl_current_module);

    // invisible builtin values
    if (jl_an_empty_cell) GC_Markval(jl_an_empty_cell);
    GC_Markval(jl_exception_in_transit);
    GC_Markval(jl_task_arg_in_transit);
    GC_Markval(jl_unprotect_stack_func);
    GC_Markval(jl_typetype_type);

    // constants
    GC_Markval(jl_null);
    GC_Markval(jl_true);
    GC_Markval(jl_false);

    jl_mark_box_caches();

    size_t i;

    // stuff randomly preserved
    for(i=0; i &lt; preserved_values.len; i++) {
        GC_Markval((jl_value_t*)preserved_values.items[i]);
    }

    // objects currently being finalized
    for(i=0; i &lt; to_finalize.len; i++) {
        GC_Markval(to_finalize.items[i]);
    }
    // find unmarked objects that need to be finalized.
    // this must happen last.
    for(i=0; i &lt; finalizer_table.size; i+=2) {
        if (finalizer_table.table[i+1] != HT_NOTFOUND) {
            jl_value_t *v = finalizer_table.table[i];
            if (!gc_marked_obj(v)) {
                GC_Markval(v);
                schedule_finalization(v);
            }
            GC_Markval(finalizer_table.table[i+1]);
        }
    }
}
</t>
<t tx="ekr.20120404123906.7736">
static int is_gc_enabled = 0;
</t>
<t tx="ekr.20120404123906.7737">DLLEXPORT void jl_gc_enable(void)    { is_gc_enabled = 1; }
</t>
<t tx="ekr.20120404123906.7738">DLLEXPORT void jl_gc_disable(void)   { is_gc_enabled = 0; }
</t>
<t tx="ekr.20120404123906.7739">DLLEXPORT int jl_gc_is_enabled(void) { return is_gc_enabled; }
</t>
<t tx="ekr.20120404123906.7740">
void jl_gc_ephemeral_on(void)  { pools = &amp;ephe_pools[0]; }
</t>
<t tx="ekr.20120404123906.7741">void jl_gc_ephemeral_off(void) { pools = &amp;norm_pools[0]; }
</t>
<t tx="ekr.20120404123906.7742">
#if defined(MEMPROFILE)
static void all_pool_stats(void);
static void big_obj_stats(void);
#endif

#ifdef OBJPROFILE
</t>
<t tx="ekr.20120404123906.7743">static void print_obj_profile(void)
{
    jl_value_t *errstream = jl_get_global(jl_base_module,
                                          jl_symbol("stderr_stream"));
    JL_TRY {
        if (errstream)
            jl_set_current_output_stream_obj(errstream);
        ios_t *s = jl_current_output_stream();
        for(int i=0; i &lt; obj_counts.size; i+=2) {
            if (obj_counts.table[i+1] != HT_NOTFOUND) {
                ios_printf(s, "%d ", obj_counts.table[i+1]-1);
                jl_show(obj_counts.table[i]);
                ios_printf(s, "\n");
            }
        }
    }
    JL_CATCH {
    }
}
</t>
<t tx="ekr.20120404123906.7744">#endif

</t>
<t tx="ekr.20120404123906.7745">void jl_gc_collect(void)
{
    allocd_bytes = 0;
    if (is_gc_enabled) {
        JL_SIGATOMIC_BEGIN();
#ifdef GCTIME
        double t0 = clock_now();
#endif
        gc_mark();
#ifdef GCTIME
        ios_printf(ios_stderr, "mark time %.3f ms\n", (clock_now()-t0)*1000);
#endif
#if defined(MEMPROFILE)
        all_pool_stats();
        big_obj_stats();
#endif
#ifdef GCTIME
        t0 = clock_now();
#endif
        sweep_weak_refs();
        gc_sweep();
#ifdef GCTIME
        ios_printf(ios_stderr, "sweep time %.3f ms\n", (clock_now()-t0)*1000);
#endif
        run_finalizers();
        JL_SIGATOMIC_END();
#ifdef OBJPROFILE
        print_obj_profile();
        htable_reset(&amp;obj_counts, 0);
#endif
    }
}
</t>
<t tx="ekr.20120404123906.7746">
void *allocb(size_t sz)
{
#ifdef MEMDEBUG
    return alloc_big(sz, 0);
#endif
    if (sz &gt; 2048-sizeof(void*))
        return alloc_big(sz, 0);
    sz += sizeof(void*);
    allocd_bytes += sz;
    void *b = pool_alloc(&amp;pools[szclass(sz)]);
    return (void*)((void**)b + 1);
}
</t>
<t tx="ekr.20120404123906.7747">
void *allocobj(size_t sz)
{
#ifdef MEMDEBUG
    return alloc_big(sz, 1);
#endif
    if (sz &gt; 2048)
        return alloc_big(sz, 1);
    allocd_bytes += sz;
    return pool_alloc(&amp;pools[szclass(sz)]);
}
</t>
<t tx="ekr.20120404123906.7748">
void *alloc_2w(void)
{
#ifdef MEMDEBUG
    return alloc_big(2*sizeof(void*), 1);
#endif
    allocd_bytes += (2*sizeof(void*));
#ifdef __LP64__
    return pool_alloc(&amp;pools[2]);
#else
    return pool_alloc(&amp;pools[0]);
#endif
}
</t>
<t tx="ekr.20120404123906.7749">
void *alloc_3w(void)
{
#ifdef MEMDEBUG
    return alloc_big(3*sizeof(void*), 1);
#endif
    allocd_bytes += (3*sizeof(void*));
#ifdef __LP64__
    return pool_alloc(&amp;pools[4]);
#else
    return pool_alloc(&amp;pools[1]);
#endif
}
</t>
<t tx="ekr.20120404123906.7750">
void *alloc_4w(void)
{
#ifdef MEMDEBUG
    return alloc_big(4*sizeof(void*), 1);
#endif
    allocd_bytes += (4*sizeof(void*));
#ifdef __LP64__
    return pool_alloc(&amp;pools[6]);
#else
    return pool_alloc(&amp;pools[2]);
#endif
}
</t>
<t tx="ekr.20120404123906.7751">
void jl_gc_init(void)
{
    int szc[N_POOLS] = { 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
                         64, 72, 80, 88, 96, //#=18

                         112, 128, 144, 160, 176, 192, 208, 224, 240, 256,

                         288, 320, 352, 384, 416, 448, 480, 512,

                         640, 768, 896, 1024, 

                         1536, 2048 };
    int i;
    for(i=0; i &lt; N_POOLS; i++) {
        norm_pools[i].osize = szc[i];
        norm_pools[i].pages = NULL;
        norm_pools[i].freelist = NULL;

        ephe_pools[i].osize = szc[i];
        ephe_pools[i].pages = NULL;
        ephe_pools[i].freelist = NULL;
    }

    htable_new(&amp;finalizer_table, 0);
    arraylist_new(&amp;to_finalize, 0);
    arraylist_new(&amp;preserved_values, 0);
    arraylist_new(&amp;weak_refs, 0);

#ifdef OBJPROFILE
    htable_new(&amp;obj_counts, 0);
#endif
}
</t>
<t tx="ekr.20120404123906.7752">
#if defined(MEMPROFILE)
</t>
<t tx="ekr.20120404123906.7753">static size_t pool_stats(pool_t *p, size_t *pwaste)
{
    gcval_t *v;
    gcpage_t *pg = p-&gt;pages;
    size_t osize = p-&gt;osize;
    size_t nused=0, nfree=0, npgs=0;

    while (pg != NULL) {
        npgs++;
        char *lim = (char*)pg + GC_PAGE_SZ - osize;
        v = (gcval_t*)&amp;pg-&gt;data[0];
        while ((char*)v &lt;= lim) {
            if (!v-&gt;marked) {
                nfree++;
            }
            else {
                nused++;
            }
            v = (gcval_t*)((char*)v + osize);
        }
        gcpage_t *nextpg = pg-&gt;next;
        pg = nextpg;
    }
    *pwaste = npgs*GC_PAGE_SZ - (nused*p-&gt;osize);
    ios_printf(ios_stdout,
               "%4d : %7d/%7d objects, %5d pages, %8d bytes, %8d waste\n",
               p-&gt;osize,
               nused,
               nused+nfree,
               npgs,
               nused*p-&gt;osize,
               *pwaste);
    return nused*p-&gt;osize;
}
</t>
<t tx="ekr.20120404123906.7754">
static void all_pool_stats(void)
{
    int i;
    size_t nb=0, w, tw=0, no=0, b;
    for(i=0; i &lt; N_POOLS; i++) {
        b = pool_stats(&amp;norm_pools[i], &amp;w);
        nb += b;
        no += (b/norm_pools[i].osize);
        tw += w;

        b = pool_stats(&amp;ephe_pools[i], &amp;w);
        nb += b;
        no += (b/ephe_pools[i].osize);
        tw += w;
    }
    ios_printf(ios_stdout,
               "%d objects, %d total allocated, %d total fragments\n",
               no, nb, tw);
}
</t>
<t tx="ekr.20120404123906.7755">
static void big_obj_stats(void)
{
    bigval_t *v = big_objects;
    size_t nused=0, nbytes=0;
    while (v != NULL) {
        if (v-&gt;isobj &amp;&amp; (bigval_word0(v)&amp;1)) {
            nused++;
            nbytes += v-&gt;sz;
        }
        else if (!v-&gt;isobj &amp;&amp; v-&gt;marked) {
            nused++;
            nbytes += v-&gt;sz;
        }
        v = v-&gt;next;
    }
    ios_printf(ios_stdout, "%d bytes in %d large objects\n", nbytes, nused);
}
</t>
<t tx="ekr.20120404123906.7756">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7757">/*
  Generic Functions
  . method table and lookup
  . GF constructor, add_method
  . dispatch
  . static parameter inference
  . method specialization, invoking type inference
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "builtin_proto.h"

</t>
<t tx="ekr.20120404123906.7758">static jl_methtable_t *new_method_table(jl_sym_t *name)
{
    jl_methtable_t *mt = (jl_methtable_t*)allocobj(sizeof(jl_methtable_t));
    mt-&gt;type = (jl_type_t*)jl_methtable_type;
    mt-&gt;name = name;
    mt-&gt;defs = NULL;
    mt-&gt;cache = NULL;
    mt-&gt;cache_arg1 = NULL;
    mt-&gt;cache_targ = NULL;
    mt-&gt;max_args = jl_box_long(0);
#ifdef JL_GF_PROFILE
    mt-&gt;ncalls = 0;
#endif
    return mt;
}
</t>
<t tx="ekr.20120404123906.7759">
static int cache_match_by_type(jl_value_t **types, size_t n, jl_tuple_t *sig,
                               int va)
{
    if (!va &amp;&amp; n &gt; sig-&gt;length)
        return 0;
    if (sig-&gt;length &gt; n) {
        if (!(n == sig-&gt;length-1 &amp;&amp; va))
            return 0;
    }
    size_t i;
    for(i=0; i &lt; n; i++) {
        jl_value_t *decl = jl_tupleref(sig, i);
        if (i == sig-&gt;length-1) {
            if (va) {
                jl_value_t *t = jl_tparam0(decl);
                for(; i &lt; n; i++) {
                    if (!jl_subtype(types[i], t, 0))
                        return 0;
                }
                return 1;
            }
        }
        jl_value_t *a = types[i];
        if (jl_is_tuple(decl)) {
            // tuples don't have to match exactly, to avoid caching
            // signatures for tuples of every length
            if (!jl_subtype(a, decl, 0))
                return 0;
        }
        else if (jl_is_tag_type(a) &amp;&amp; jl_is_tag_type(decl) &amp;&amp;
                 ((jl_tag_type_t*)decl)-&gt;name == jl_type_type-&gt;name &amp;&amp;
                 ((jl_tag_type_t*)a   )-&gt;name == jl_type_type-&gt;name) {
            if (jl_tparam0(decl) == (jl_value_t*)jl_typetype_tvar) {
                // in the case of Type{T}, the types don't have
                // to match exactly either. this is cached as Type{T}.
                // analogous to the situation with tuples.
            }
            else {
                if (!jl_types_equal(jl_tparam0(a), jl_tparam0(decl))) {
                    return 0;
                }
            }
        }
        else if (decl == (jl_value_t*)jl_any_type) {
        }
        else {
            if (!jl_types_equal(a, decl))
                return 0;
        }
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.7760">
static inline int cache_match(jl_value_t **args, size_t n, jl_tuple_t *sig,
                              int va)
{
    if (sig-&gt;length &gt; n) {
        if (n != sig-&gt;length-1)
            return 0;
    }
    size_t i;
    for(i=0; i &lt; n; i++) {
        jl_value_t *decl = jl_tupleref(sig, i);
        if (i == sig-&gt;length-1) {
            if (va) {
                jl_value_t *t = jl_tparam0(decl);
                for(; i &lt; n; i++) {
                    if (!jl_subtype(args[i], t, 1))
                        return 0;
                }
                return 1;
            }
        }
        jl_value_t *a = args[i];
        if (jl_is_tuple(decl)) {
            // tuples don't have to match exactly, to avoid caching
            // signatures for tuples of every length
            if (!jl_is_tuple(a) || !jl_subtype(a, decl, 1))
                return 0;
        }
        else if (jl_is_type_type(decl) &amp;&amp;
                 jl_is_nontuple_type(a)) {   //***
            if (jl_tparam0(decl) == (jl_value_t*)jl_typetype_tvar) {
                // in the case of Type{T}, the types don't have
                // to match exactly either. this is cached as Type{T}.
                // analogous to the situation with tuples.
            }
            else {
                if (a!=jl_tparam0(decl) &amp;&amp; !jl_types_equal(a,jl_tparam0(decl)))
                    return 0;
            }
        }
        else if (decl == (jl_value_t*)jl_any_type) {
        }
        else {
            /*
              we know there are only concrete types here, and types are
              hash-consed, so pointer comparison should work.
            */
            if ((jl_value_t*)jl_typeof(a) != decl)
                return 0;
        }
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.7761">
/*
  Method caches are divided into three parts: one for signatures where
  the first argument is a singleton kind (Type{Foo}), one indexed by the
  UID of the first argument's type in normal cases, and a fallback
  table of everything else.
*/
</t>
<t tx="ekr.20120404123906.7762">static jl_function_t *jl_method_table_assoc_exact_by_type(jl_methtable_t *mt,
                                                          jl_tuple_t *types)
{
    jl_methlist_t *ml = NULL;
    if (types-&gt;length &gt; 0) {
        jl_value_t *ty = jl_t0(types);
        uptrint_t uid;
        if (jl_is_type_type(ty)) {
            jl_value_t *a0 = jl_tparam0(ty);
            jl_value_t *tty = (jl_value_t*)jl_typeof(a0);
            if ((tty == (jl_value_t*)jl_struct_kind &amp;&amp; (uid = ((jl_struct_type_t*)a0)-&gt;uid)) ||
                (tty == (jl_value_t*)jl_bits_kind   &amp;&amp; (uid = ((jl_bits_type_t*)a0)-&gt;uid))) {
                if (mt-&gt;cache_targ &amp;&amp;
                    uid &lt; jl_array_len(mt-&gt;cache_targ)) {
                    ml = (jl_methlist_t*)jl_cellref(mt-&gt;cache_targ, uid);
                    if (ml)
                        goto mt_assoc_bt_lkup;
                }
            }
        }
        if ((jl_is_struct_type(ty) &amp;&amp; (uid = ((jl_struct_type_t*)ty)-&gt;uid)) ||
            (jl_is_bits_type(ty)   &amp;&amp; (uid = ((jl_bits_type_t*)ty)-&gt;uid))) {
            if (mt-&gt;cache_arg1 &amp;&amp; uid &lt; jl_array_len(mt-&gt;cache_arg1)) {
                ml = (jl_methlist_t*)jl_cellref(mt-&gt;cache_arg1, uid);
            }
        }
    }
    if (ml == NULL)
        ml = mt-&gt;cache;
 mt_assoc_bt_lkup:
    while (ml != NULL) {
        if (cache_match_by_type(&amp;jl_tupleref(types,0), types-&gt;length,
                                (jl_tuple_t*)ml-&gt;sig, ml-&gt;va==jl_true)) {
            return ml-&gt;func;
        }
        ml = ml-&gt;next;
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7763">
static jl_function_t *jl_method_table_assoc_exact(jl_methtable_t *mt,
                                                  jl_value_t **args, size_t n)
{
    jl_methlist_t *ml = NULL;
    if (n &gt; 0) {
        jl_value_t *a0 = args[0];
        jl_value_t *ty = (jl_value_t*)jl_typeof(a0);
        uptrint_t uid;
        if ((ty == (jl_value_t*)jl_struct_kind &amp;&amp; (uid = ((jl_struct_type_t*)a0)-&gt;uid)) ||
            (ty == (jl_value_t*)jl_bits_kind   &amp;&amp; (uid = ((jl_bits_type_t*)a0)-&gt;uid))) {
            if (mt-&gt;cache_targ &amp;&amp;
                uid &lt; jl_array_len(mt-&gt;cache_targ)) {
                ml = (jl_methlist_t*)jl_cellref(mt-&gt;cache_targ, uid);
                if (ml)
                    goto mt_assoc_lkup;
            }
        }
        if ((jl_is_struct_type(ty) &amp;&amp; (uid = ((jl_struct_type_t*)ty)-&gt;uid)) ||
            (jl_is_bits_type(ty)   &amp;&amp; (uid = ((jl_bits_type_t*)ty)-&gt;uid))) {
            if (mt-&gt;cache_arg1 &amp;&amp;
                uid &lt; jl_array_len(mt-&gt;cache_arg1)) {
                ml = (jl_methlist_t*)jl_cellref(mt-&gt;cache_arg1, uid);
                if (ml) {
                    if (ml-&gt;next==NULL &amp;&amp; n==1 &amp;&amp; ml-&gt;sig-&gt;length==1)
                        return ml-&gt;func;
                    if (n==2) {
                        // some manually-unrolled common special cases
                        jl_value_t *a1 = args[1];
                        jl_methlist_t *mn = ml;
                        if (mn-&gt;sig-&gt;length==2 &amp;&amp;
                            jl_tupleref(mn-&gt;sig,1)==(jl_value_t*)jl_typeof(a1))
                            return mn-&gt;func;
                        mn = mn-&gt;next;
                        if (mn &amp;&amp; mn-&gt;sig-&gt;length==2 &amp;&amp;
                            jl_tupleref(mn-&gt;sig,1)==(jl_value_t*)jl_typeof(a1))
                            return mn-&gt;func;
                    }
                }
            }
        }
    }
    if (ml == NULL)
        ml = mt-&gt;cache;
 mt_assoc_lkup:
    while (ml != NULL) {
        if (((jl_tuple_t*)ml-&gt;sig)-&gt;length == n || ml-&gt;va==jl_true) {
            if (cache_match(args, n, (jl_tuple_t*)ml-&gt;sig, ml-&gt;va==jl_true)) {
                return ml-&gt;func;
            }
        }
        ml = ml-&gt;next;
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7764">
// return a new lambda-info that has some extra static parameters
// merged in.
</t>
<t tx="ekr.20120404123906.7765">jl_lambda_info_t *jl_add_static_parameters(jl_lambda_info_t *l, jl_tuple_t *sp)
{
    JL_GC_PUSH(&amp;sp);
    if (l-&gt;sparams-&gt;length &gt; 0)
        sp = jl_tuple_append(sp, l-&gt;sparams);
    jl_lambda_info_t *nli = jl_new_lambda_info(l-&gt;ast, sp);
    nli-&gt;name = l-&gt;name;
    nli-&gt;fptr = l-&gt;fptr;
    nli-&gt;module = l-&gt;module;
    nli-&gt;file = l-&gt;file;
    nli-&gt;line = l-&gt;line;
    JL_GC_POP();
    return nli;
}
</t>
<t tx="ekr.20120404123906.7766">
JL_CALLABLE(jl_trampoline);

</t>
<t tx="ekr.20120404123906.7767">jl_function_t *jl_instantiate_method(jl_function_t *f, jl_tuple_t *sp)
{
    if (f-&gt;linfo == NULL)
        return f;
    jl_function_t *nf = jl_new_closure(f-&gt;fptr, f-&gt;env, NULL);
    JL_GC_PUSH(&amp;nf);
    nf-&gt;linfo = jl_add_static_parameters(f-&gt;linfo, sp);
    JL_GC_POP();
    return nf;
}
</t>
<t tx="ekr.20120404123906.7768">
// make a new method that calls the generated code from the given linfo
</t>
<t tx="ekr.20120404123906.7769">jl_function_t *jl_reinstantiate_method(jl_function_t *f, jl_lambda_info_t *li)
{
    return jl_new_closure(NULL, f-&gt;env, li);
}
</t>
<t tx="ekr.20120404123906.7770">
static
jl_methlist_t *jl_method_list_insert(jl_methlist_t **pml, jl_tuple_t *type,
                                     jl_function_t *method, jl_tuple_t *tvars,
                                     int check_amb);

</t>
<t tx="ekr.20120404123906.7771">static
jl_function_t *jl_method_cache_insert(jl_methtable_t *mt, jl_tuple_t *type,
                                      jl_function_t *method)
{
    jl_methlist_t **pml = &amp;mt-&gt;cache;
    if (type-&gt;length &gt; 0) {
        jl_value_t *t0 = jl_t0(type);
        uptrint_t uid=0;
        // if t0 != jl_typetype_type and the argument is Type{...}, this
        // method has specializations for singleton kinds and we use
        // the table indexed for that purpose.
        if (t0 != (jl_value_t*)jl_typetype_type &amp;&amp; jl_is_type_type(t0)) {
            jl_value_t *a0 = jl_tparam0(t0);
            if (jl_is_struct_type(a0))
                uid = ((jl_struct_type_t*)a0)-&gt;uid;
            else if (jl_is_bits_type(a0))
                uid = ((jl_bits_type_t*)a0)-&gt;uid;
            if (uid &gt; 0) {
                if (mt-&gt;cache_targ == NULL)
                    mt-&gt;cache_targ = jl_alloc_cell_1d(0);
                if (uid &gt;= jl_array_len(mt-&gt;cache_targ)) {
                    jl_array_grow_end(mt-&gt;cache_targ, uid+4-jl_array_len(mt-&gt;cache_targ));
                }
                pml = (jl_methlist_t**)&amp;jl_cellref(mt-&gt;cache_targ, uid);
                goto ml_do_insert;
            }
        }
        if (jl_is_struct_type(t0))
            uid = ((jl_struct_type_t*)t0)-&gt;uid;
        else if (jl_is_bits_type(t0))
            uid = ((jl_bits_type_t*)t0)-&gt;uid;
        if (uid &gt; 0) {
            if (mt-&gt;cache_arg1 == NULL)
                mt-&gt;cache_arg1 = jl_alloc_cell_1d(0);
            if (uid &gt;= jl_array_len(mt-&gt;cache_arg1)) {
                jl_array_grow_end(mt-&gt;cache_arg1, uid+4-jl_array_len(mt-&gt;cache_arg1));
            }
            pml = (jl_methlist_t**)&amp;jl_cellref(mt-&gt;cache_arg1, uid);
        }
    }
 ml_do_insert:
    return jl_method_list_insert(pml, type, method, jl_null, 0)-&gt;func;
}
</t>
<t tx="ekr.20120404123906.7772">
extern jl_function_t *jl_typeinf_func;
#define ENABLE_INFERENCE
//#define TRACE_INFERENCE

#ifdef TRACE_INFERENCE
static char *type_summary(jl_value_t *t);
</t>
<t tx="ekr.20120404123906.7773">static void print_sig(jl_tuple_t *type)
{
    size_t i;
    for(i=0; i &lt; type-&gt;length; i++) {
        if (i &gt; 0) ios_printf(ios_stderr, ", ");
        jl_value_t *v = jl_tupleref(type,i);
        if (jl_is_tuple(v)) {
            ios_putc('(', ios_stderr);
            print_sig((jl_tuple_t*)v);
            ios_putc(')', ios_stderr);
        }
        else {
            ios_printf(ios_stderr, "%s", type_summary(v));
        }
    }
}
</t>
<t tx="ekr.20120404123906.7774">#endif

</t>
<t tx="ekr.20120404123906.7775">static jl_value_t *nth_slot_type(jl_tuple_t *sig, size_t i)
{
    size_t len = sig-&gt;length;
    if (len == 0)
        return NULL;
    if (i &lt; len-1)
        return jl_tupleref(sig, i);
    if (jl_is_seq_type(jl_tupleref(sig,len-1))) {
        return jl_tparam0(jl_tupleref(sig,len-1));
    }
    if (i == len-1)
        return jl_tupleref(sig, i);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7776">
static int very_general_type(jl_value_t *t)
{
    return (t &amp;&amp; (t==(jl_value_t*)jl_any_type ||
                  (jl_is_typevar(t) &amp;&amp;
                   ((jl_tvar_t*)t)-&gt;ub==(jl_value_t*)jl_any_type)));
}
</t>
<t tx="ekr.20120404123906.7777">
static jl_value_t *ml_matches(jl_methlist_t *ml, jl_value_t *type,
                              jl_sym_t *name, int lim);

/*
  run type inference on lambda "li" in-place, for given argument types.
  "def" is the original method definition of which this is an instance;
  can be equal to "li" if not applicable.
*/
int jl_in_inference = 0;
</t>
<t tx="ekr.20120404123906.7778">void jl_type_infer(jl_lambda_info_t *li, jl_tuple_t *argtypes,
                   jl_lambda_info_t *def)
{
    int last_ii = jl_in_inference;
    jl_in_inference = 1;
    if (jl_typeinf_func != NULL) {
        // TODO: this should be done right before code gen, so if it is
        // interrupted we can try again the next time the function is
        // called
        assert(li-&gt;inInference == 0);
        li-&gt;inInference = 1;
        jl_value_t *fargs[4];
        fargs[0] = (jl_value_t*)li;
        fargs[1] = (jl_value_t*)argtypes;
        fargs[2] = (jl_value_t*)jl_null;
        fargs[3] = (jl_value_t*)def;
#ifdef TRACE_INFERENCE
        ios_printf(ios_stderr,"inference on %s(", li-&gt;name-&gt;name);
        print_sig(argtypes);
        ios_printf(ios_stderr, ")\n");
#endif
#ifdef ENABLE_INFERENCE
        jl_value_t *newast = jl_apply(jl_typeinf_func, fargs, 4);
        li-&gt;ast = jl_tupleref(newast, 0);
        li-&gt;inferred = jl_true;
#endif
        li-&gt;inInference = 0;
    }
    jl_in_inference = last_ii;
}
</t>
<t tx="ekr.20120404123906.7779">
static int tuple_all_Any(jl_tuple_t *t)
{
    int i;
    for(i=0; i &lt; t-&gt;length; i++) {
        if (jl_tupleref(t,i) != (jl_value_t*)jl_any_type)
            return 0;
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.7780">
static jl_function_t *cache_method(jl_methtable_t *mt, jl_tuple_t *type,
                                   jl_function_t *method, jl_tuple_t *decl,
                                   jl_tuple_t *sparams)
{
    size_t i;
    int need_dummy_entries = 0;
    jl_value_t *temp=NULL;
    jl_function_t *newmeth=NULL;
    JL_GC_PUSH(&amp;type, &amp;temp, &amp;newmeth);

    for (i=0; i &lt; type-&gt;length; i++) {
        jl_value_t *elt = jl_tupleref(type,i);
        int set_to_any = 0;
        if (nth_slot_type(decl,i) == jl_ANY_flag) {
            // don't specialize on slots marked ANY
            temp = jl_tupleref(type, i);
            jl_tupleset(type, i, (jl_value_t*)jl_any_type);
            int nintr=0;
            jl_methlist_t *curr = mt-&gt;defs;
            // if this method is the only match even with the current slot
            // set to Any, then it is safe to cache it that way.
            while (curr != NULL &amp;&amp; curr-&gt;func!=method) {
                if (jl_type_intersection((jl_value_t*)curr-&gt;sig,
                                         (jl_value_t*)type) !=
                    (jl_value_t*)jl_bottom_type) {
                    nintr++;
                    break;
                }
                curr = curr-&gt;next;
            }
            if (nintr) {
                // TODO: even if different specializations of this slot need
                // separate cache entries, have them share code.
                jl_tupleset(type, i, temp);
            }
            else {
                set_to_any = 1;
            }
        }
        if (set_to_any) {
        }
        else if (jl_is_tuple(elt)) {
            /*
              don't cache tuple type exactly; just remember that it was
              a tuple, unless the declaration asks for something more
              specific. determined with a type intersection.
            */
            int might_need_dummy=0;
            temp = jl_tupleref(type, i);
            if (i &lt; decl-&gt;length) {
                jl_value_t *declt = jl_tupleref(decl,i);
                // for T..., intersect with T
                if (jl_is_seq_type(declt))
                    declt = jl_tparam0(declt);
                if (declt == (jl_value_t*)jl_tuple_type ||
                    jl_subtype((jl_value_t*)jl_tuple_type, declt, 0)) {
                    // don't specialize args that matched (Any...) or Any
                    jl_tupleset(type, i, (jl_value_t*)jl_tuple_type);
                    might_need_dummy = 1;
                }
                else {
                    declt = jl_type_intersection(declt,
                                                 (jl_value_t*)jl_tuple_type);
                    if (((jl_tuple_t*)elt)-&gt;length &gt; 3 ||
                        tuple_all_Any((jl_tuple_t*)declt)) {
                        jl_tupleset(type, i, declt);
                        might_need_dummy = 1;
                    }
                }
            }
            else {
                jl_tupleset(type, i, (jl_value_t*)jl_tuple_type);
                might_need_dummy = 1;
            }
            assert(jl_tupleref(type,i) != (jl_value_t*)jl_bottom_type);
            if (might_need_dummy) {
                jl_methlist_t *curr = mt-&gt;defs;
                // can't generalize type if there's an overlapping definition
                // with typevars.
                // TODO: it seems premature to take these intersections
                // before the whole signature has been generalized.
                // example ((T...,),S,S,S,S,S,S,S,S,S,S,S,S,S,S,S,S,...)
                while (curr != NULL &amp;&amp; curr-&gt;func!=method) {
                    if (curr-&gt;tvars!=jl_null &amp;&amp;
                        jl_type_intersection((jl_value_t*)curr-&gt;sig,
                                             (jl_value_t*)type) !=
                        (jl_value_t*)jl_bottom_type) {
                        jl_tupleset(type, i, temp);
                        might_need_dummy = 0;
                        break;
                    }
                    curr = curr-&gt;next;
                }
            }
            if (might_need_dummy) {
                jl_methlist_t *curr = mt-&gt;defs;
                while (curr != NULL &amp;&amp; curr-&gt;func!=method) {
                    jl_tuple_t *sig = curr-&gt;sig;
                    if (sig-&gt;length &gt; i &amp;&amp;
                        jl_is_tuple(jl_tupleref(sig,i))) {
                        need_dummy_entries = 1;
                        break;
                    }
                    curr = curr-&gt;next;
                }
            }
        }
        else if (jl_is_type_type(elt) &amp;&amp; jl_is_type_type(jl_tparam0(elt))) {
            /*
              actual argument was Type{...}, we computed its type as
              Type{Type{...}}. we must avoid unbounded nesting here, so
              cache the signature as Type{T}, unless something more
              specific like Type{Type{Int32}} was actually declared.
              this can be determined using a type intersection.
            */
            if (i &lt; decl-&gt;length) {
                jl_value_t *declt = jl_tupleref(decl,i);
                // for T..., intersect with T
                if (jl_is_seq_type(declt))
                    declt = jl_tparam0(declt);
                jl_tupleset(type, i,
                            jl_type_intersection(declt, (jl_value_t*)jl_typetype_type));
            }
            else {
                jl_tupleset(type, i, (jl_value_t*)jl_typetype_type);
            }
            assert(jl_tupleref(type,i) != (jl_value_t*)jl_bottom_type);
        }
        else if (jl_is_type_type(elt) &amp;&amp;
                 very_general_type(nth_slot_type(decl,i))) {
            /*
              here's a fairly complex heuristic: if this argument slot's
              declared type is Any, and no definition overlaps with Type
              for this slot, then don't specialize for every Type that
              might be passed.
              Since every type x has its own type Type{x}, this would be
              excessive specialization for an Any slot.
            */
            int ok=1;
            jl_methlist_t *curr = mt-&gt;defs;
            while (curr != NULL) {
                jl_value_t *slottype = nth_slot_type(curr-&gt;sig, i);
                if (slottype &amp;&amp;
                    !very_general_type(slottype) &amp;&amp;
                    jl_type_intersection(slottype,
                                         (jl_value_t*)jl_type_type) !=
                    (jl_value_t*)jl_bottom_type) {
                    ok=0;
                    break;
                }
                curr = curr-&gt;next;
            }
            if (ok) {
                jl_tupleset(type, i, (jl_value_t*)jl_typetype_type);
            }
        }
    }

    // for varargs methods, only specialize up to max_args.
    // in general, here we want to find the biggest type that's not a
    // supertype of any other method signatures. so far we are conservative
    // and the types we find should be bigger.
    if (type-&gt;length &gt; jl_unbox_long(mt-&gt;max_args) &amp;&amp;
        jl_is_seq_type(jl_tupleref(decl,decl-&gt;length-1))) {
        size_t nspec = jl_unbox_long(mt-&gt;max_args)+2;
        jl_tuple_t *limited = jl_alloc_tuple(nspec);
        for(i=0; i &lt; nspec-1; i++) {
            jl_tupleset(limited, i, jl_tupleref(type, i));
        }
        jl_value_t *lasttype = jl_tupleref(type,i-1);
        // if all subsequent arguments are subtypes of lasttype, specialize
        // on that instead of decl. for example, if decl is
        // (Any...)
        // and type is
        // (Symbol, Symbol, Symbol)
        // then specialize as (Symbol...), but if type is
        // (Symbol, Int32, Expr)
        // then specialize as (Any...)
        size_t j = i;
        int all_are_subtypes=1;
        for(; j &lt; type-&gt;length; j++) {
            if (!jl_subtype(jl_tupleref(type,j), lasttype, 0)) {
                all_are_subtypes = 0;
                break;
            }
        }
        type = limited;
        if (all_are_subtypes) {
            // avoid Type{Type{...}...}...
            if (jl_is_type_type(lasttype))
                lasttype = (jl_value_t*)jl_type_type;
            temp = (jl_value_t*)jl_tuple1(lasttype);
            jl_tupleset(type, i, jl_apply_type((jl_value_t*)jl_seq_type,
                                               (jl_tuple_t*)temp));
        }
        else {
            jl_value_t *lastdeclt = jl_tupleref(decl,decl-&gt;length-1);
            if (sparams-&gt;length &gt; 0) {
                lastdeclt = (jl_value_t*)
                    jl_instantiate_type_with((jl_type_t*)lastdeclt,
                                             sparams-&gt;data,
                                             sparams-&gt;length/2);
            }
            jl_tupleset(type, i, lastdeclt);
        }
        // now there is a problem: the computed signature is more
        // general than just the given arguments, so it might conflict
        // with another definition that doesn't have cache instances yet.
        // to fix this, we insert dummy cache entries for all intersections
        // of this signature and definitions. those dummy entries will
        // supersede this one in conflicted cases, alerting us that there
        // should actually be a cache miss.
        need_dummy_entries = 1;
    }

    if (need_dummy_entries) {
        temp = ml_matches(mt-&gt;defs, (jl_value_t*)type, lambda_sym, -1);
        for(i=0; i &lt; jl_array_len(temp); i++) {
            jl_value_t *m = jl_cellref(temp, i);
            if (jl_tupleref(m,2) != (jl_value_t*)method-&gt;linfo) {
                jl_method_cache_insert(mt, (jl_tuple_t*)jl_tupleref(m, 0),
                                       NULL);
            }
        }
    }

    // here we infer types and specialize the method
    /*
    if (sparams==jl_null)
        newmeth = method;
    else
    */
    jl_array_t *lilist=NULL;
    jl_lambda_info_t *li=NULL;
    if (method-&gt;linfo &amp;&amp; method-&gt;linfo-&gt;specializations!=NULL) {
        // reuse code already generated for this combination of lambda and
        // arguments types. this happens for inner generic functions where
        // a new closure is generated on each call to the enclosing function.
        lilist = method-&gt;linfo-&gt;specializations;
        int k;
        for(k=0; k &lt; lilist-&gt;length; k++) {
            li = (jl_lambda_info_t*)jl_cellref(lilist, k);
            if (jl_types_equal(li-&gt;specTypes, (jl_value_t*)type))
                break;
        }
        if (k == lilist-&gt;length) lilist=NULL;
    }
    if (lilist != NULL &amp;&amp; !li-&gt;inInference) {
        assert(li);
        newmeth = jl_reinstantiate_method(method, li);
        (void)jl_method_cache_insert(mt, type, newmeth);
        JL_GC_POP();
        return newmeth;
    }
    else {
        newmeth = jl_instantiate_method(method, sparams);
    }
    /*
      if "method" itself can ever be compiled, for example for use as
      an unspecialized method (see below), then newmeth-&gt;fptr might point
      to some slow compiled code instead of jl_trampoline, meaning our
      type-inferred code would never get compiled. this can be fixed with
      the commented-out snippet below.
    */
    assert(!(newmeth-&gt;linfo &amp;&amp; newmeth-&gt;linfo-&gt;ast) ||
           newmeth-&gt;fptr == &amp;jl_trampoline);
    /*
    if (newmeth-&gt;linfo&amp;&amp;newmeth-&gt;linfo-&gt;ast&amp;&amp;newmeth-&gt;fptr!=&amp;jl_trampoline) {
        newmeth-&gt;fptr = &amp;jl_trampoline;
    }
    */

    (void)jl_method_cache_insert(mt, type, newmeth);

    if (newmeth-&gt;linfo != NULL &amp;&amp; newmeth-&gt;linfo-&gt;sparams == jl_null) {
        // when there are no static parameters, one unspecialized version
        // of a function can be shared among all cached specializations.
        if (method-&gt;linfo-&gt;unspecialized == NULL) {
            method-&gt;linfo-&gt;unspecialized =
                jl_instantiate_method(method, jl_null);
        }
        newmeth-&gt;linfo-&gt;unspecialized = method-&gt;linfo-&gt;unspecialized;
    }

    if (newmeth-&gt;linfo != NULL &amp;&amp; newmeth-&gt;linfo-&gt;ast != NULL) {
        newmeth-&gt;linfo-&gt;specTypes = (jl_value_t*)type;
        jl_array_t *spe = method-&gt;linfo-&gt;specializations;
        if (spe == NULL) {
            spe = jl_alloc_cell_1d(1);
            jl_cellset(spe, 0, newmeth-&gt;linfo);
        }
        else {
            jl_cell_1d_push(spe, (jl_value_t*)newmeth-&gt;linfo);
        }
        method-&gt;linfo-&gt;specializations = spe;
        jl_type_infer(newmeth-&gt;linfo, type, method-&gt;linfo);
    }
    JL_GC_POP();
    return newmeth;
}
</t>
<t tx="ekr.20120404123906.7781">
static jl_value_t *lookup_match(jl_value_t *a, jl_value_t *b, jl_tuple_t **penv,
                                jl_tuple_t *tvars)
{
    jl_value_t *ti = jl_type_intersection_matching(a, b, penv, tvars);
    if (ti == (jl_value_t*)jl_bottom_type)
        return ti;
    jl_value_t **ee = alloca(sizeof(void*)*(*penv)-&gt;length);
    int n=0;
    // only keep vars in tvars list
    jl_value_t **tvs;
    int tvarslen;
    if (jl_is_typevar(tvars)) {
        tvs = (jl_value_t**)&amp;tvars;
        tvarslen = 1;
    }
    else {
        tvs = &amp;jl_t0(tvars);
        tvarslen = tvars-&gt;length;
    }
    for(int i=0; i &lt; (*penv)-&gt;length; i+=2) {
        jl_value_t *v = jl_tupleref(*penv,i);
        jl_value_t *val = jl_tupleref(*penv,i+1);
        for(int j=0; j &lt; tvarslen; j++) {
            if (v == tvs[j]) {
                ee[n++] = v;
                ee[n++] = val;
            }
        }
    }
    if (n != (*penv)-&gt;length) {
        jl_tuple_t *en = jl_alloc_tuple_uninit(n);
        memcpy(en-&gt;data, ee, n*sizeof(void*));
        *penv = en;
    }
    return ti;
}
</t>
<t tx="ekr.20120404123906.7782">
static jl_function_t *jl_mt_assoc_by_type(jl_methtable_t *mt, jl_tuple_t *tt, int cache)
{
    jl_methlist_t *m = mt-&gt;defs;
    size_t nargs = tt-&gt;length;
    size_t i;
    jl_value_t *ti=(jl_value_t*)jl_bottom_type;
    jl_tuple_t *newsig=NULL, *env = jl_null;
    JL_GC_PUSH(&amp;env, &amp;newsig);

    while (m != NULL) {
        if (m-&gt;tvars!=jl_null) {
            ti = lookup_match((jl_value_t*)tt, (jl_value_t*)m-&gt;sig,
                              &amp;env, m-&gt;tvars);
            if (ti != (jl_value_t*)jl_bottom_type) {
                // parametric methods only match if all typevars are matched by
                // non-typevars.
                for(i=1; i &lt; env-&gt;length; i+=2) {
                    if (jl_is_typevar(jl_tupleref(env,i)))
                        break;
                }
                if (i &gt;= env-&gt;length)
                    break;
                ti = (jl_value_t*)jl_bottom_type;
            }
        }
        else if (jl_tuple_subtype(&amp;jl_tupleref(tt,0), nargs,
                                  &amp;jl_tupleref(m-&gt;sig,0),
                                  ((jl_tuple_t*)m-&gt;sig)-&gt;length, 0, 0)) {
            break;
        }
        m = m-&gt;next;
    }

    if (ti == (jl_value_t*)jl_bottom_type) {
        JL_GC_POP();
        if (m != NULL) {
            if (!cache)
                return m-&gt;func;
            return cache_method(mt, tt, m-&gt;func, (jl_tuple_t*)m-&gt;sig, jl_null);
        }
        return NULL;
    }

    assert(jl_is_tuple(env));
    // don't bother computing this if no arguments are tuples
    for(i=0; i &lt; tt-&gt;length; i++) {
        if (jl_is_tuple(jl_tupleref(tt,i)))
            break;
    }
    if (i &lt; tt-&gt;length) {
        newsig = (jl_tuple_t*)jl_instantiate_type_with((jl_type_t*)m-&gt;sig,
                                                       &amp;jl_tupleref(env,0),
                                                       env-&gt;length/2);
    }
    else {
        newsig = (jl_tuple_t*)m-&gt;sig;
    }
    assert(jl_is_tuple(newsig));
    jl_function_t *nf;
    if (!cache)
        nf = m-&gt;func;
    else
        nf = cache_method(mt, tt, m-&gt;func, newsig, env);
    JL_GC_POP();
    return nf;
}
</t>
<t tx="ekr.20120404123906.7783">
jl_tag_type_t *jl_wrap_Type(jl_value_t *t);

</t>
<t tx="ekr.20120404123906.7784">static int sigs_eq(jl_value_t *a, jl_value_t *b)
{
    if (jl_has_typevars(a) || jl_has_typevars(b)) {
        return jl_types_equal_generic(a,b);
    }
    return jl_subtype(a, b, 0) &amp;&amp; jl_subtype(b, a, 0);
}
</t>
<t tx="ekr.20120404123906.7785">
int jl_args_morespecific(jl_value_t *a, jl_value_t *b)
{
    int msp = jl_type_morespecific(a,b,0);
    if (jl_has_typevars(b)) {
        if (jl_type_match_morespecific(a,b) == (jl_value_t*)jl_false) {
            if (jl_has_typevars(a))
                return 0;
            return msp;
        }
        if (jl_has_typevars(a)) {
            //if (jl_type_match_morespecific(b,a) == (jl_value_t*)jl_false)
            //    return 1;
            // this rule seems to work better:
            if (jl_type_match(b,a) == (jl_value_t*)jl_false)
                return 1;
        }
        int nmsp = jl_type_morespecific(b,a,0);
        if (nmsp == msp)
            return 0;
    }
    if (jl_has_typevars((jl_value_t*)a)) {
        int nmsp = jl_type_morespecific(b,a,0);
        if (nmsp &amp;&amp; msp)
            return 1;
        if (jl_type_match_morespecific(b,a) != (jl_value_t*)jl_false) {
            return 0;
        }
    }
    return msp;
}
</t>
<t tx="ekr.20120404123906.7786">
static int is_va_tuple(jl_tuple_t *t)
{
    return (t-&gt;length&gt;0 &amp;&amp; jl_is_seq_type(jl_tupleref(t,t-&gt;length-1)));
}
</t>
<t tx="ekr.20120404123906.7787">
/*
  warn about ambiguous method priorities
  
  the relative priority of A and B is ambiguous if
  !subtype(A,B) &amp;&amp; !subtype(B,A) &amp;&amp; no corresponding tuple
  elements are disjoint.
  
  for example, (AbstractArray, AbstractMatrix) and (AbstractMatrix, AbstractArray) are ambiguous.
  however, (AbstractArray, AbstractMatrix, Foo) and (AbstractMatrix, AbstractArray, Bar) are fine
  since Foo and Bar are disjoint, so there would be no confusion over
  which one to call.
  
  There is also this kind of ambiguity: foo{T,S}(T, S) vs. foo(Any,Any)
  In this case jl_types_equal() is true, but one is jl_type_morespecific
  or jl_type_match_morespecific than the other.
  To check this, jl_types_equal_generic needs to be more sophisticated
  so (T,T) is not equivalent to (Any,Any). (TODO)
*/
</t>
<t tx="ekr.20120404123906.7788">static void check_ambiguous(jl_methlist_t *ml, jl_tuple_t *type,
                            jl_tuple_t *sig, jl_sym_t *fname)
{
    // we know !jl_args_morespecific(type, sig)
    if ((type-&gt;length==sig-&gt;length ||
         (type-&gt;length==sig-&gt;length+1 &amp;&amp; is_va_tuple(type)) ||
         (type-&gt;length+1==sig-&gt;length &amp;&amp; is_va_tuple(sig))) &amp;&amp;
        !jl_args_morespecific((jl_value_t*)sig, (jl_value_t*)type)) {
        jl_value_t *isect = jl_type_intersection((jl_value_t*)type,
                                                 (jl_value_t*)sig);
        if (isect == (jl_value_t*)jl_bottom_type)
            return;
        JL_GC_PUSH(&amp;isect);
        jl_methlist_t *l = ml;
        while (l != NULL) {
            if (sigs_eq(isect, (jl_value_t*)l-&gt;sig))
                goto done_chk_amb;  // ok, intersection is covered
            l = l-&gt;next;
        }
        char *n = fname-&gt;name;
        jl_value_t *errstream = jl_get_global(jl_base_module,
                                              jl_symbol("stderr_stream"));
        JL_TRY {
            if (errstream)
                jl_set_current_output_stream_obj(errstream);
            ios_t *s = jl_current_output_stream();
            ios_printf(s, "Warning: New definition %s", n);
            jl_show((jl_value_t*)type);
            ios_printf(s, " is ambiguous with %s", n);
            jl_show((jl_value_t*)sig);
            ios_printf(s, ".\n         Make sure %s", n);
            jl_show(isect);
            ios_printf(s, " is defined first.\n");
        }
        JL_CATCH {
            jl_raise(jl_exception_in_transit);
        }
    done_chk_amb:
        JL_GC_POP();
    }
}
</t>
<t tx="ekr.20120404123906.7789">
static int has_unions(jl_tuple_t *type)
{
    int i;
    for(i=0; i &lt; type-&gt;length; i++) {
        jl_value_t *t = jl_tupleref(type,i);
        if (jl_is_union_type(t) ||
            (jl_is_seq_type(t) &amp;&amp; jl_is_union_type(jl_tparam0(t))))
            return 1;
    }
    return 0;
}
</t>
<t tx="ekr.20120404123906.7790">
static
jl_methlist_t *jl_method_list_insert(jl_methlist_t **pml, jl_tuple_t *type,
                                     jl_function_t *method, jl_tuple_t *tvars,
                                     int check_amb)
{
    jl_methlist_t *l, **pl;

    assert(jl_is_tuple(type));
    l = *pml;
    while (l != NULL) {
        if (((l-&gt;tvars==jl_null) == (tvars==jl_null)) &amp;&amp;
            sigs_eq((jl_value_t*)type, (jl_value_t*)l-&gt;sig)) {
            // method overwritten
            JL_SIGATOMIC_BEGIN();
            l-&gt;sig = type;
            l-&gt;tvars = tvars;
            l-&gt;va = (type-&gt;length &gt; 0 &amp;&amp;
                     jl_is_seq_type(jl_tupleref(type,type-&gt;length-1))) ?
                jl_true : jl_false;
            l-&gt;invokes = NULL;
            l-&gt;func = method;
            JL_SIGATOMIC_END();
            return l;
        }
        l = l-&gt;next;
    }
    pl = pml;
    l = *pml;
    while (l != NULL) {
        if (jl_args_morespecific((jl_value_t*)type, (jl_value_t*)l-&gt;sig))
            break;
        if (check_amb) {
            check_ambiguous(*pml, (jl_tuple_t*)type, (jl_tuple_t*)l-&gt;sig,
                            method-&gt;linfo ? method-&gt;linfo-&gt;name :
                            anonymous_sym);
        }
        pl = &amp;l-&gt;next;
        l = l-&gt;next;
    }
    jl_methlist_t *newrec = (jl_methlist_t*)allocobj(sizeof(jl_methlist_t));
    newrec-&gt;type = (jl_type_t*)jl_method_type;
    newrec-&gt;sig = type;
    newrec-&gt;tvars = tvars;
    newrec-&gt;va = (type-&gt;length &gt; 0 &amp;&amp;
                  jl_is_seq_type(jl_tupleref(type,type-&gt;length-1))) ?
        jl_true : jl_false;
    newrec-&gt;func = method;
    newrec-&gt;invokes = NULL;
    newrec-&gt;next = l;
    JL_SIGATOMIC_BEGIN();
    *pl = newrec;
    // if this contains Union types, methods after it might actually be
    // more specific than it. we need to re-sort them.
    if (has_unions(type)) {
        jl_methlist_t *item = newrec-&gt;next, *next;
        jl_methlist_t **pitem = &amp;newrec-&gt;next, **pnext;
        while (item != NULL) {
            pl = pml;
            l = *pml;
            next = item-&gt;next;
            pnext = &amp;item-&gt;next;
            while (l != newrec-&gt;next) {
                if (jl_args_morespecific((jl_value_t*)item-&gt;sig,
                                         (jl_value_t*)l-&gt;sig)) {
                    // reinsert item earlier in the list
                    *pitem = next;
                    item-&gt;next = l;
                    *pl = item;
                    pnext = pitem;
                    break;
                }
                pl = &amp;l-&gt;next;
                l = l-&gt;next;
            }
            item = next;
            pitem = pnext;
        }
    }
    JL_SIGATOMIC_END();
    return newrec;
}
</t>
<t tx="ekr.20120404123906.7791">
static void remove_conflicting(jl_methlist_t **pl, jl_value_t *type)
{
    jl_methlist_t *l = *pl;
    while (l != NULL) {
        if (jl_type_intersection(type, (jl_value_t*)l-&gt;sig) !=
            (jl_value_t*)jl_bottom_type) {
            *pl = l-&gt;next;
        }
        else {
            pl = &amp;l-&gt;next;
        }
        l = l-&gt;next;
    }
}
</t>
<t tx="ekr.20120404123906.7792">
jl_methlist_t *jl_method_table_insert(jl_methtable_t *mt, jl_tuple_t *type,
                                      jl_function_t *method, jl_tuple_t *tvars)
{
    if (tvars-&gt;length == 1)
        tvars = (jl_tuple_t*)jl_t0(tvars);
    JL_SIGATOMIC_BEGIN();
    jl_methlist_t *ml = jl_method_list_insert(&amp;mt-&gt;defs,type,method,tvars,1);
    // invalidate cached methods that overlap this definition
    remove_conflicting(&amp;mt-&gt;cache, (jl_value_t*)type);
    if (mt-&gt;cache_arg1) {
        for(int i=0; i &lt; jl_array_len(mt-&gt;cache_arg1); i++) {
            jl_methlist_t **pl = (jl_methlist_t**)&amp;jl_cellref(mt-&gt;cache_arg1,i);
            if (*pl)
                remove_conflicting(pl, (jl_value_t*)type);
        }
    }
    if (mt-&gt;cache_targ) {
        for(int i=0; i &lt; jl_array_len(mt-&gt;cache_targ); i++) {
            jl_methlist_t **pl = (jl_methlist_t**)&amp;jl_cellref(mt-&gt;cache_targ,i);
            if (*pl)
                remove_conflicting(pl, (jl_value_t*)type);
        }
    }
    // update max_args
    jl_tuple_t *t = (jl_tuple_t*)type;
    size_t na = t-&gt;length;
    if (t-&gt;length&gt;0 &amp;&amp; jl_is_seq_type(jl_tupleref(t,t-&gt;length-1)))
        na--;
    if (na &gt; jl_unbox_long(mt-&gt;max_args)) {
        mt-&gt;max_args = jl_box_long(na);
    }
    JL_SIGATOMIC_END();
    return ml;
}
</t>
<t tx="ekr.20120404123906.7793">
jl_value_t *jl_no_method_error(jl_function_t *f, jl_value_t **args, size_t na)
{
    jl_value_t **a = alloca(sizeof(jl_value_t*)*(na+1));
    a[0] = (jl_value_t*)f;
    int i;
    for(i=0; i &lt; na; i++)
        a[i+1] = args[i];
    return jl_apply(jl_method_missing_func, a, na+1);
}
</t>
<t tx="ekr.20120404123906.7794">
//#define JL_TRACE
#if defined(JL_TRACE) || defined(TRACE_INFERENCE)
</t>
<t tx="ekr.20120404123906.7795">static char *type_summary(jl_value_t *t)
{
    if (jl_is_tuple(t)) return "Tuple";
    if (jl_is_some_tag_type(t))
        return ((jl_tag_type_t*)t)-&gt;name-&gt;name-&gt;name;
    ios_printf(ios_stderr, "unexpected argument type: ");
    jl_show(t);
    ios_printf(ios_stderr, "\n");
    assert(0);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7796">#endif

</t>
<t tx="ekr.20120404123906.7797">static jl_tuple_t *arg_type_tuple(jl_value_t **args, size_t nargs)
{
    jl_tuple_t *tt = jl_alloc_tuple(nargs);
    JL_GC_PUSH(&amp;tt);
    size_t i;
    for(i=0; i &lt; tt-&gt;length; i++) {
        jl_value_t *a;
        if (jl_is_nontuple_type(args[i])) {  //***
            a = (jl_value_t*)jl_wrap_Type(args[i]);
        }
        else {
            a = (jl_value_t*)jl_full_type(args[i]);
        }
        jl_tupleset(tt, i, a);
    }
    JL_GC_POP();
    return tt;
}
</t>
<t tx="ekr.20120404123906.7798">
jl_function_t *jl_method_lookup_by_type(jl_methtable_t *mt, jl_tuple_t *types,
                                        int cache)
{
    jl_function_t *sf = jl_method_table_assoc_exact_by_type(mt, types);
    if (sf == NULL) {
        sf = jl_mt_assoc_by_type(mt, types, cache);
    }
    return sf;
}
</t>
<t tx="ekr.20120404123906.7799">
jl_function_t *jl_method_lookup(jl_methtable_t *mt, jl_value_t **args, size_t nargs, int cache)
{
    jl_function_t *sf = jl_method_table_assoc_exact(mt, args, nargs);
    if (sf == NULL) {
        jl_tuple_t *tt = arg_type_tuple(args, nargs);
        JL_GC_PUSH(&amp;tt);
        sf = jl_mt_assoc_by_type(mt, tt, cache);
        JL_GC_POP();
    }
    return sf;
}
</t>
<t tx="ekr.20120404123906.7800">
// compile-time method lookup
</t>
<t tx="ekr.20120404123906.7801">jl_function_t *jl_get_specialization(jl_function_t *f, jl_tuple_t *types)
{
    assert(jl_is_gf(f));
    if (!jl_is_leaf_type((jl_value_t*)types))
        return NULL;
    jl_methtable_t *mt = jl_gf_mtable(f);
    jl_function_t *sf = jl_method_lookup_by_type(mt, types, 1);
    if (sf == NULL) {
        return NULL;
    }
    if (sf-&gt;linfo == NULL || sf-&gt;linfo-&gt;ast == NULL) {
        return NULL;
    }
    if (sf-&gt;linfo-&gt;inInference) return NULL;
    if (sf-&gt;linfo-&gt;functionObject == NULL) {
        if (sf-&gt;fptr != &amp;jl_trampoline)
            return NULL;
        jl_compile(sf);
    }
    return sf;
}
</t>
<t tx="ekr.20120404123906.7802">
DLLEXPORT void jl_compile_hint(jl_function_t *f, jl_tuple_t *types)
{
    (void)jl_get_specialization(f, types);
}
</t>
<t tx="ekr.20120404123906.7803">
#ifdef JL_TRACE
static int trace_en = 0;
</t>
<t tx="ekr.20120404123906.7804">static void enable_trace(int x) { trace_en=x; }
</t>
<t tx="ekr.20120404123906.7805">#endif

</t>
<t tx="ekr.20120404123906.7806">JL_CALLABLE(jl_apply_generic)
{
    jl_methtable_t *mt = jl_gf_mtable(F);
#ifdef JL_GF_PROFILE
    mt-&gt;ncalls++;
#endif
#ifdef JL_TRACE
    if (trace_en) {
        ios_printf(ios_stdout, "%s(", jl_gf_name(F)-&gt;name);
        size_t i;
        for(i=0; i &lt; nargs; i++) {
            if (i &gt; 0) ios_printf(ios_stdout, ", ");
            ios_printf(ios_stdout, "%s", type_summary(jl_typeof(args[i])));
        }
        ios_printf(ios_stdout, ")\n");
    }
#endif
    /*
      search order:
      look at concrete signatures
      if there is an exact match, return it
      otherwise look for a matching generic signature
      if no concrete or generic match, raise error
      if no generic match, use the concrete one even if inexact
      otherwise instantiate the generic method and use it
    */
    jl_function_t *mfunc = jl_method_table_assoc_exact(mt, args, nargs);
    if (mfunc != NULL) {
        if (mfunc-&gt;linfo != NULL &amp;&amp; 
            (mfunc-&gt;linfo-&gt;inInference || mfunc-&gt;linfo-&gt;inCompile)) {
            // if inference is running on this function, return a copy
            // of the function to be compiled without inference and run.
            jl_lambda_info_t *li = mfunc-&gt;linfo;
            if (li-&gt;unspecialized == NULL) {
                li-&gt;unspecialized = jl_instantiate_method(mfunc, li-&gt;sparams);
            }
            mfunc = li-&gt;unspecialized;
        }
    }
    else {
        jl_tuple_t *tt = arg_type_tuple(args, nargs);
        JL_GC_PUSH(&amp;tt);
        mfunc = jl_mt_assoc_by_type(mt, tt, 1);
        JL_GC_POP();
    }

    if (mfunc == NULL) {
        return jl_no_method_error((jl_function_t*)F, args, nargs);
    }
    assert(!mfunc-&gt;linfo || !mfunc-&gt;linfo-&gt;inInference);

    return jl_apply(mfunc, args, nargs);
}
</t>
<t tx="ekr.20120404123906.7807">
// invoke()
// this does method dispatch with a set of types to match other than the
// types of the actual arguments. this means it sometimes does NOT call the
// most specific method for the argument types, so we need different logic.
// first we use the given types to look up a definition, then we perform
// caching and specialization within just that definition.
// every definition has its own private method table for this purpose.
//
// NOTE: assumes argument type is a subtype of the lookup type.
</t>
<t tx="ekr.20120404123906.7808">jl_value_t *jl_gf_invoke(jl_function_t *gf, jl_tuple_t *types,
                         jl_value_t **args, size_t nargs)
{
    assert(jl_is_gf(gf));
    jl_methtable_t *mt = jl_gf_mtable(gf);

    jl_methlist_t *m = mt-&gt;defs;
    size_t typelen = types-&gt;length;
    size_t i;
    jl_value_t *env = (jl_value_t*)jl_false;

    while (m != NULL) {
        if (m-&gt;tvars!=jl_null) {
            env = jl_type_match((jl_value_t*)types, (jl_value_t*)m-&gt;sig);
            if (env != (jl_value_t*)jl_false) break;
        }
        else if (jl_tuple_subtype(&amp;jl_tupleref(types,0), typelen,
                                  &amp;jl_tupleref(m-&gt;sig,0),
                                  ((jl_tuple_t*)m-&gt;sig)-&gt;length, 0, 0)) {
            break;
        }
        m = m-&gt;next;
    }

    if (m == NULL) {
        return jl_no_method_error(gf, args, nargs);
    }

    // now we have found the matching definition.
    // next look for or create a specialization of this definition.

    jl_function_t *mfunc;
    if (m-&gt;invokes == NULL)
        mfunc = NULL;
    else
        mfunc = jl_method_table_assoc_exact(m-&gt;invokes, args, nargs);
    if (mfunc != NULL) {
        if (mfunc-&gt;linfo != NULL &amp;&amp; 
            (mfunc-&gt;linfo-&gt;inInference || mfunc-&gt;linfo-&gt;inCompile)) {
            // if inference is running on this function, return a copy
            // of the function to be compiled without inference and run.
            jl_lambda_info_t *li = mfunc-&gt;linfo;
            if (li-&gt;unspecialized == NULL) {
                li-&gt;unspecialized = jl_instantiate_method(mfunc, li-&gt;sparams);
            }
            mfunc = li-&gt;unspecialized;
        }
    }
    else {
        jl_tuple_t *tpenv=jl_null;
        jl_tuple_t *newsig=NULL;
        jl_tuple_t *tt=NULL;
        JL_GC_PUSH(&amp;env, &amp;newsig, &amp;tt);

        if (m-&gt;invokes == NULL) {
            m-&gt;invokes = new_method_table(mt-&gt;name);
            // this private method table has just this one definition
            jl_method_list_insert(&amp;m-&gt;invokes-&gt;defs,m-&gt;sig,m-&gt;func,m-&gt;tvars,0);
        }

        tt = arg_type_tuple(args, nargs);

        newsig = (jl_tuple_t*)m-&gt;sig;

        if (env != (jl_value_t*)jl_false) {
            tpenv = (jl_tuple_t*)env;
            // don't bother computing this if no arguments are tuples
            for(i=0; i &lt; tt-&gt;length; i++) {
                if (jl_is_tuple(jl_tupleref(tt,i)))
                    break;
            }
            if (i &lt; tt-&gt;length) {
                newsig =
                    (jl_tuple_t*)jl_instantiate_type_with((jl_type_t*)m-&gt;sig,
                                                          &amp;jl_tupleref(tpenv,0),
                                                          tpenv-&gt;length/2);
            }
        }
        mfunc = cache_method(m-&gt;invokes, tt, m-&gt;func, newsig, tpenv);
        JL_GC_POP();
    }

    JL_GC_PUSH(&amp;mfunc);
    jl_value_t *result = jl_apply(mfunc, args, nargs);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7809">
static void print_methlist(char *name, jl_methlist_t *ml)
{
    ios_t *s = jl_current_output_stream();
    while (ml != NULL) {
        ios_printf(s, "%s", name);
        if (ml-&gt;tvars != jl_null) {
            if (jl_is_typevar(ml-&gt;tvars)) {
                ios_putc('{', s); jl_show((jl_value_t*)ml-&gt;tvars);
                ios_putc('}', s);
            }
            else {
                jl_show_tuple(ml-&gt;tvars, '{', '}', 0);
            }
        }
        jl_show((jl_value_t*)ml-&gt;sig);
        if (ml-&gt;func == NULL)  {
            // mark dummy cache entries
            ios_printf(s, " *");
        }
        else {
            jl_lambda_info_t *li = ml-&gt;func-&gt;linfo;
            assert(li);
            long lno = jl_unbox_long(li-&gt;line);
            if (lno &gt; 0) {
                char *fname = ((jl_sym_t*)li-&gt;file)-&gt;name;
                ios_printf(s, " at %s:%d", fname, lno);
            }
        }
        if (ml-&gt;next != NULL)
            ios_printf(s, "\n");
        ml = ml-&gt;next;
    }
}
</t>
<t tx="ekr.20120404123906.7810">
void jl_show_method_table(jl_function_t *gf)
{
    char *name = jl_gf_name(gf)-&gt;name;
    jl_methtable_t *mt = jl_gf_mtable(gf);
    print_methlist(name, mt-&gt;defs);
    //ios_printf(ios_stdout, "\ncache:\n");
    //print_methlist(name, mt-&gt;cache);
}
</t>
<t tx="ekr.20120404123906.7811">
void jl_initialize_generic_function(jl_function_t *f, jl_sym_t *name)
{
    f-&gt;fptr = jl_apply_generic;
    f-&gt;env = (jl_value_t*)new_method_table(name);
}
</t>
<t tx="ekr.20120404123906.7812">
jl_function_t *jl_new_generic_function(jl_sym_t *name)
{
    jl_function_t *f = jl_new_closure(jl_apply_generic, NULL, NULL);
    JL_GC_PUSH(&amp;f);
    jl_initialize_generic_function(f, name);
    JL_GC_POP();
    return f;
}
</t>
<t tx="ekr.20120404123906.7813">
void jl_add_method(jl_function_t *gf, jl_tuple_t *types, jl_function_t *meth,
                   jl_tuple_t *tvars)
{
    assert(jl_is_function(gf));
    assert(jl_is_tuple(types));
    assert(jl_is_func(meth));
    assert(jl_is_mtable(jl_gf_mtable(gf)));
    if (meth-&gt;linfo != NULL)
        meth-&gt;linfo-&gt;name = jl_gf_name(gf);
    (void)jl_method_table_insert(jl_gf_mtable(gf), types, meth, tvars);
}
</t>
<t tx="ekr.20120404123906.7814">
DLLEXPORT jl_tuple_t *jl_match_method(jl_value_t *type, jl_value_t *sig,
                                      jl_tuple_t *tvars)
{
    jl_tuple_t *env = jl_null;
    jl_value_t *ti=NULL;
    JL_GC_PUSH(&amp;env, &amp;ti);
    ti = lookup_match(type, (jl_value_t*)sig, &amp;env, tvars);
    jl_tuple_t *result = jl_tuple2(ti, env);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7815">
static jl_tuple_t *match_method(jl_value_t *type, jl_function_t *func,
                                jl_tuple_t *sig, jl_tuple_t *tvars)
{
    jl_tuple_t *env = jl_null;
    jl_value_t *temp=NULL;
    jl_value_t *ti=NULL;
    JL_GC_PUSH(&amp;env, &amp;ti, &amp;temp);

    ti = lookup_match(type, (jl_value_t*)sig, &amp;env, tvars);
    jl_tuple_t *result = NULL;
    if (ti != (jl_value_t*)jl_bottom_type) {
        assert(func-&gt;linfo);  // no builtin methods
        jl_value_t *cenv;
        if (func-&gt;env != NULL) {
            cenv = func-&gt;env;
        }
        else {
            cenv = (jl_value_t*)jl_null;
        }
        result = jl_tuple(4, ti, env, func-&gt;linfo, cenv);
    }
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7816">
// returns linked tuples (argtypes, static_params, lambdainfo, cloenv, next)
</t>
<t tx="ekr.20120404123906.7817">static jl_value_t *ml_matches(jl_methlist_t *ml, jl_value_t *type,
                              jl_sym_t *name, int lim)
{
    jl_array_t *t = (jl_array_t*)jl_an_empty_cell;
    jl_tuple_t *matc=NULL;
    JL_GC_PUSH(&amp;t, &amp;matc);
    int len=0;
    while (ml != NULL) {
        // a method is shadowed if type &lt;: S &lt;: m-&gt;sig where S is the
        // signature of another applicable method
        /*
          more generally, we can stop when the type is a subtype of the
          union of all the signatures examined so far.
        */
        matc = match_method(type, ml-&gt;func, ml-&gt;sig, ml-&gt;tvars);
        if (matc != NULL) {
            len++;
            if (lim &gt;= 0 &amp;&amp; len &gt; lim) {
                JL_GC_POP();
                return jl_false;
            }
            if (len == 1) {
                t = jl_alloc_cell_1d(1);
                jl_cellref(t,0) = (jl_value_t*)matc;
            }
            else {
                jl_cell_1d_push(t, (jl_value_t*)matc);
            }
            // (type ∩ ml-&gt;sig == type) ⇒ (type ⊆ ml-&gt;sig)
            if (jl_types_equal(jl_t0(matc), type)) {
                JL_GC_POP();
                return (jl_value_t*)t;
            }
        }
        ml = ml-&gt;next;
    }
    JL_GC_POP();
    return (jl_value_t*)t;
}
</t>
<t tx="ekr.20120404123906.7818">
void jl_add_constructors(jl_struct_type_t *t);
JL_CALLABLE(jl_f_ctor_trampoline);

// return linked tuples (t1, M1, (t2, M2, (... ()))) of types and methods.
// t is the intersection of the type argument and the method signature,
// and M is the corresponding LambdaStaticData (jl_lambda_info_t)
// lim is the max # of methods to return. if there are more return jl_false.
// -1 for no limit.
</t>
<t tx="ekr.20120404123906.7819">DLLEXPORT
jl_value_t *jl_matching_methods(jl_function_t *gf, jl_value_t *type, int lim)
{
    if (gf-&gt;fptr == jl_f_ctor_trampoline)
        jl_add_constructors((jl_struct_type_t*)gf);
    if (!jl_is_gf(gf)) {
        return (jl_value_t*)jl_an_empty_cell;
    }
    jl_methtable_t *mt = jl_gf_mtable(gf);
    jl_sym_t *gfname = jl_gf_name(gf);
    return ml_matches(mt-&gt;defs, type, gfname, lim);
}
</t>
<t tx="ekr.20120404123906.7820">
DLLEXPORT
int jl_is_builtin(jl_value_t *v)
{
    return ((jl_is_func(v) &amp;&amp; (((jl_function_t*)v)-&gt;linfo==NULL) &amp;&amp;
             !jl_is_gf(v)) ||
            jl_typeis(v,jl_intrinsic_type));
}
</t>
<t tx="ekr.20120404123906.7821">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7822">#include &lt;iostream&gt;

#include "llvm/Support/Host.h"
#include "llvm/Support/raw_ostream.h"

#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/DeclGroup.h"
#include "clang/Basic/Diagnostic.h"
#include "clang/Basic/FileManager.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Basic/TargetInfo.h"
#include "clang/Basic/TargetOptions.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Lex/Preprocessor.h"
#include "clang/Parse/ParseAST.h"
#include "clang/Parse/Parser.h"

using namespace std;
using namespace clang;

class PrintFunctionsConsumer : public ASTConsumer {
public:
    virtual void HandleTopLevelDecl(DeclGroupRef DG) {
        for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; ++i) {
            const Decl *D = *i;
            const FunctionDecl *FD = dyn_cast&lt;FunctionDecl&gt;(D);
            if (!FD || !FD-&gt;hasPrototype() || !FD-&gt;isExternC() || !FD-&gt;isGlobal()) return;
            cout &lt;&lt; FD-&gt;getResultType().getAsString() &lt;&lt; " ";
            cout &lt;&lt; FD-&gt;getNameAsString() &lt;&lt; "(";
            bool printComma = false;
            FunctionDecl::param_const_iterator I = FD-&gt;param_begin(),
                                               E = FD-&gt;param_end();
            while (I != E) {
                ParmVarDecl *PVD = *I++;
                if (printComma) cout &lt;&lt; ", ";
                cout &lt;&lt; PVD-&gt;getOriginalType().getAsString();
                printComma = true;
            }
            cout &lt;&lt; ");\n";
        }
    }
};

</t>
<t tx="ekr.20120404123906.7823">int main()
{
    CompilerInstance ci;
    ci.createDiagnostics(0,NULL);

    TargetOptions to;
    to.Triple = llvm::sys::getHostTriple();
    TargetInfo *pti = TargetInfo::CreateTargetInfo(ci.getDiagnostics(), to);
    ci.setTarget(pti);

    ci.getHeaderSearchOpts().AddPath(
        StringRef("lib/clang/3.0/include"), frontend::Angled, false, false, false
    );
    ci.getHeaderSearchOpts().AddPath(
        StringRef("src/support"), frontend::Quoted, true, false, false
    );

    ci.createFileManager();
    ci.createSourceManager(ci.getFileManager());
    ci.createPreprocessor();
    PrintFunctionsConsumer *astConsumer = new PrintFunctionsConsumer();
    ci.setASTConsumer(astConsumer);

    ci.createASTContext();
  	const FileEntry *pFile = ci.getFileManager().getFile("src/julia.h");
    ci.getSourceManager().createMainFileID(pFile);
    ci.getDiagnosticClient().BeginSourceFile(ci.getLangOpts(), &amp;ci.getPreprocessor());
    clang::ParseAST(ci.getPreprocessor(), astConsumer, ci.getASTContext());
    ci.getDiagnosticClient().EndSourceFile();

    return 0;
}
</t>
<t tx="ekr.20120404123906.7824">@language c
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20120404123906.7825">/*
  init.c
  system initialization and global state
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;assert.h&gt;
#if defined(__linux) || defined(__APPLE__) || defined(__FreeBSD__)
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;
#endif
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;libgen.h&gt;
#include &lt;getopt.h&gt;
#include "julia.h"

int jl_boot_file_loaded = 0;

char *jl_stack_lo;
char *jl_stack_hi;
size_t jl_page_size;

</t>
<t tx="ekr.20120404123906.7826">static void jl_find_stack_bottom(void)
{
    size_t stack_size;
#if defined(__linux) || defined(__APPLE__) || defined(__FreeBSD__)
    struct rlimit rl;
    getrlimit(RLIMIT_STACK, &amp;rl);
    stack_size = rl.rlim_cur;
#else
    stack_size = 262144;  // guess
#endif
    jl_stack_hi = (char*)&amp;stack_size;
    jl_stack_lo = jl_stack_hi - stack_size;
}
</t>
<t tx="ekr.20120404123906.7827">
void fpe_handler(int arg)
{
    (void)arg;
    sigset_t sset;
    sigemptyset(&amp;sset);
    sigaddset(&amp;sset, SIGFPE);
    sigprocmask(SIG_UNBLOCK, &amp;sset, NULL);

    jl_divide_by_zero_error();
}
</t>
<t tx="ekr.20120404123906.7828">
void segv_handler(int sig, siginfo_t *info, void *context)
{
</t>
<t tx="ekr.20120404123906.7829">sigset_t sset;
sigemptyset(&amp;sset);
sigaddset(&amp;sset, SIGSEGV);
sigprocmask(SIG_UNBLOCK, &amp;sset, NULL);

#ifdef COPY_STACKS
if ((char*)info-&gt;si_addr &gt; (char*)jl_stack_lo-3000000 &amp;&amp;
    (char*)info-&gt;si_addr &lt; (char*)jl_stack_hi) {
#else
if ((char*)info-&gt;si_addr &gt; (char*)jl_current_task-&gt;stack-8192 &amp;&amp;
    (char*)info-&gt;si_addr &lt;
    (char*)jl_current_task-&gt;stack+jl_current_task-&gt;ssize) {
#endif
    jl_raise(jl_stackovf_exception);
}
else {
    signal(SIGSEGV, SIG_DFL);
}
}

volatile sig_atomic_t jl_signal_pending = 0;
volatile sig_atomic_t jl_defer_signal = 0;

</t>
<t tx="ekr.20120404123906.7830">void sigint_handler(int sig, siginfo_t *info, void *context)
{
    sigset_t sset;
    sigemptyset(&amp;sset);
    sigaddset(&amp;sset, SIGINT);
    sigprocmask(SIG_UNBLOCK, &amp;sset, NULL);

    if (jl_defer_signal) {
        jl_signal_pending = sig;
    }
    else {
        jl_signal_pending = 0;
        jl_raise(jl_interrupt_exception);
    }
}
</t>
<t tx="ekr.20120404123906.7831">
void jl_get_builtin_hooks(void);

void *jl_dl_handle;

#ifdef COPY_STACKS
void jl_switch_stack(jl_task_t *t, jmp_buf *where);
extern jmp_buf * volatile jl_jmp_target;
#endif

</t>
<t tx="ekr.20120404123906.7832">void julia_init(char *imageFile)
{
    jl_page_size = sysconf(_SC_PAGESIZE);
    jl_find_stack_bottom();
    jl_dl_handle = jl_load_dynamic_library(NULL);
#ifdef JL_GC_MARKSWEEP
    jl_gc_init();
    jl_gc_disable();
#endif
    jl_init_frontend();
    jl_init_types();
    jl_init_tasks(jl_stack_lo, jl_stack_hi-jl_stack_lo);
    jl_init_codegen();
    jl_an_empty_cell = (jl_value_t*)jl_alloc_cell_1d(0);

    jl_init_serializer();

    if (!imageFile) {
        jl_core_module = jl_new_module(jl_symbol("Core"));
        jl_current_module = jl_core_module;
        jl_init_intrinsic_functions();
        jl_init_primitives();
        jl_load("src/boot.jl");
        jl_get_builtin_hooks();
        jl_boot_file_loaded = 1;
        jl_init_box_caches();
    }

    if (imageFile) {
        JL_TRY {
            jl_restore_system_image(imageFile);
        }
        JL_CATCH {
            ios_printf(ios_stderr, "error during init:\n");
            jl_show(jl_exception_in_transit);
            ios_printf(ios_stdout, "\n");
            exit(1);
        }
    }

    struct sigaction actf;
    memset(&amp;actf, 0, sizeof(struct sigaction));
    sigemptyset(&amp;actf.sa_mask);
    actf.sa_handler = fpe_handler;
    actf.sa_flags = 0;
    if (sigaction(SIGFPE, &amp;actf, NULL) &lt; 0) {
        ios_printf(ios_stderr, "sigaction: %s\n", strerror(errno));
        exit(1);
    }

    stack_t ss;
    ss.ss_flags = 0;
    ss.ss_size = SIGSTKSZ;
    ss.ss_sp = malloc(ss.ss_size);
    if (sigaltstack(&amp;ss, NULL) &lt; 0) {
        ios_printf(ios_stderr, "sigaltstack: %s\n", strerror(errno));
        exit(1);
    }
    struct sigaction act;
    memset(&amp;act, 0, sizeof(struct sigaction));
    sigemptyset(&amp;act.sa_mask);
    act.sa_sigaction = segv_handler;
    act.sa_flags = SA_ONSTACK | SA_SIGINFO;
    if (sigaction(SIGSEGV, &amp;act, NULL) &lt; 0) {
        ios_printf(ios_stderr, "sigaction: %s\n", strerror(errno));
        exit(1);
    }

#ifdef JL_GC_MARKSWEEP
    jl_gc_enable();
#endif
}
</t>
<t tx="ekr.20120404123906.7833">
DLLEXPORT void jl_install_sigint_handler()
{
    struct sigaction act;
    memset(&amp;act, 0, sizeof(struct sigaction));
    sigemptyset(&amp;act.sa_mask);
    act.sa_sigaction = sigint_handler;
    act.sa_flags = SA_SIGINFO;
    if (sigaction(SIGINT, &amp;act, NULL) &lt; 0) {
        ios_printf(ios_stderr, "sigaction: %s\n", strerror(errno));
        exit(1);
    }
}
</t>
<t tx="ekr.20120404123906.7834">
DLLEXPORT
int julia_trampoline(int argc, char *argv[], int (*pmain)(int ac,char *av[]))
{
#ifdef COPY_STACKS
    // initialize base context of root task
    jl_root_task-&gt;stackbase = (char*)&amp;argc;
    if (setjmp(jl_root_task-&gt;base_ctx)) {
        jl_switch_stack(jl_current_task, jl_jmp_target);
    }
#endif
    return pmain(argc, argv);
}
</t>
<t tx="ekr.20120404123906.7835">
jl_function_t *jl_typeinf_func=NULL;

</t>
<t tx="ekr.20120404123906.7836">DLLEXPORT void jl_enable_inference(void)
{
    if (jl_typeinf_func != NULL) return;
    jl_typeinf_func = (jl_function_t*)jl_get_global(jl_base_module,
                                                    jl_symbol("typeinf_ext"));
}
</t>
<t tx="ekr.20120404123906.7837">
static jl_value_t *core(char *name)
{
    return jl_get_global(jl_core_module, jl_symbol(name));
}
</t>
<t tx="ekr.20120404123906.7838">
static jl_value_t *basemod(char *name)
{
    return jl_get_global(jl_base_module, jl_symbol(name));
}
</t>
<t tx="ekr.20120404123906.7839">
jl_function_t *jl_method_missing_func=NULL;

// fetch references to things defined in boot.jl
</t>
<t tx="ekr.20120404123906.7840">void jl_get_builtin_hooks(void)
{
    jl_nothing      = core("nothing");
    jl_root_task-&gt;tls = jl_nothing;

    jl_char_type    = (jl_bits_type_t*)core("Char");
    jl_int8_type    = (jl_bits_type_t*)core("Int8");
    jl_uint8_type   = (jl_bits_type_t*)core("Uint8");
    jl_int16_type   = (jl_bits_type_t*)core("Int16");
    jl_uint16_type  = (jl_bits_type_t*)core("Uint16");
    jl_uint32_type  = (jl_bits_type_t*)core("Uint32");
    jl_uint64_type  = (jl_bits_type_t*)core("Uint64");

    jl_float32_type = (jl_bits_type_t*)core("Float32");
    jl_float64_type = (jl_bits_type_t*)core("Float64");

    jl_stackovf_exception =
        jl_apply((jl_function_t*)core("StackOverflowError"), NULL, 0);
    jl_divbyzero_exception =
        jl_apply((jl_function_t*)core("DivideByZeroError"), NULL, 0);
    jl_undefref_exception =
        jl_apply((jl_function_t*)core("UndefRefError"),NULL,0);
    jl_interrupt_exception =
        jl_apply((jl_function_t*)core("InterruptException"),NULL,0);
    jl_memory_exception =
        jl_apply((jl_function_t*)core("MemoryError"),NULL,0);

    jl_weakref_type = (jl_struct_type_t*)core("WeakRef");
    jl_ascii_string_type = (jl_struct_type_t*)core("ASCIIString");
    jl_utf8_string_type = (jl_struct_type_t*)core("UTF8String");
    jl_symbolnode_type = (jl_struct_type_t*)core("SymbolNode");

    jl_array_uint8_type =
        (jl_type_t*)jl_apply_type((jl_value_t*)jl_array_type,
                                  jl_tuple2(jl_uint8_type,
                                            jl_box_long(1)));
}
</t>
<t tx="ekr.20120404123906.7841">
DLLEXPORT void jl_get_system_hooks(void)
{
    if (jl_method_missing_func) return; // only do this once

    jl_errorexception_type = (jl_struct_type_t*)basemod("ErrorException");
    jl_typeerror_type = (jl_struct_type_t*)basemod("TypeError");
    jl_loaderror_type = (jl_struct_type_t*)basemod("LoadError");
    jl_backtrace_type = (jl_struct_type_t*)basemod("BackTrace");

    jl_method_missing_func = (jl_function_t*)basemod("method_missing");
}
</t>
<t tx="ekr.20120404123906.7842">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7843">#include &lt;stdlib.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "builtin_proto.h"

static jl_value_t *eval(jl_value_t *e, jl_value_t **locals, size_t nl);
static jl_value_t *eval_body(jl_array_t *stmts, jl_value_t **locals, size_t nl,
                             int start);

</t>
<t tx="ekr.20120404123906.7844">jl_value_t *jl_interpret_toplevel_expr(jl_value_t *e)
{
    return eval(e, NULL, 0);
}
</t>
<t tx="ekr.20120404123906.7845">
jl_value_t *jl_interpret_toplevel_expr_with(jl_value_t *e,
                                            jl_value_t **locals, size_t nl)
{
    return eval(e, locals, nl);
}
</t>
<t tx="ekr.20120404123906.7846">
jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,
                                          jl_value_t **locals, size_t nl)
{
    jl_value_t *v=NULL;
    jl_module_t *last_m = jl_current_module;
    JL_TRY {
        jl_current_module = m;
        v = eval(e, locals, nl);
    }
    JL_CATCH {
        jl_current_module = last_m;
        jl_raise(jl_exception_in_transit);
    }
    jl_current_module = last_m;
    assert(v);
    return v;
}
</t>
<t tx="ekr.20120404123906.7847">
static jl_value_t *do_call(jl_function_t *f, jl_value_t **args, size_t nargs,
                           jl_value_t **locals, size_t nl)
{
    jl_value_t **argv = alloca((nargs+1) * sizeof(jl_value_t*));
    size_t i;
    argv[0] = (jl_value_t*)f;
    for(i=1; i &lt; nargs+1; i++) argv[i] = NULL;
    JL_GC_PUSHARGS(argv, nargs+1);
    for(i=0; i &lt; nargs; i++)
        argv[i+1] = eval(args[i], locals, nl);
    jl_value_t *result = jl_apply(f, &amp;argv[1], nargs);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.7848">
jl_value_t *jl_eval_global_var(jl_module_t *m, jl_sym_t *e)
{
    jl_value_t *v = jl_get_global(m, e);
    if (v == NULL)
        jl_errorf("%s not defined", e-&gt;name);
    return v;
}
</t>
<t tx="ekr.20120404123906.7849">
static jl_value_t *eval(jl_value_t *e, jl_value_t **locals, size_t nl)
{
    if (jl_is_symbol(e)) {
        jl_value_t *v;
        size_t i;
        for(i=0; i &lt; nl; i++) {
            if (locals[i*2] == e) {
                v = locals[i*2+1];
                break;
            }
        }
        if (i &gt;= nl) {
            v = jl_get_global(jl_current_module, (jl_sym_t*)e);
        }
        if (v == NULL)
            jl_errorf("%s not defined", ((jl_sym_t*)e)-&gt;name);
        return v;
    }
    if (jl_is_symbolnode(e)) {
        return eval((jl_value_t*)jl_symbolnode_sym(e), locals, nl);
    }
    if (jl_is_quotenode(e)) {
        return jl_fieldref(e,0);
    }
    if (jl_is_topnode(e)) {
        jl_value_t *v = jl_get_global(jl_current_module,
                                      (jl_sym_t*)jl_fieldref(e,0));
        if (v == NULL)
            jl_errorf("%s not defined", ((jl_sym_t*)jl_fieldref(e,0))-&gt;name);
        return v;
    }
    if (!jl_is_expr(e)) {
        if (jl_is_lambda_info(e)) {
            return (jl_value_t*)jl_new_closure(NULL, (jl_value_t*)jl_null,
                                               (jl_lambda_info_t*)e);
        }
        return e;
    }
    jl_expr_t *ex = (jl_expr_t*)e;
    jl_value_t **args = &amp;jl_cellref(ex-&gt;args,0);
    if (ex-&gt;head == call_sym ||  ex-&gt;head == call1_sym) {
        jl_function_t *f = (jl_function_t*)eval(args[0], locals, nl);
        if (!jl_is_func(f))
            jl_type_error("apply", (jl_value_t*)jl_function_type,
                          (jl_value_t*)f);
        return do_call(f, &amp;args[1], ex-&gt;args-&gt;length-1, locals, nl);
    }
    else if (ex-&gt;head == assign_sym) {
        jl_value_t *sym = args[0];
        size_t i;
        for (i=0; i &lt; nl; i++) {
            if (locals[i*2] == sym) {
                return (locals[i*2+1] = eval(args[1], locals, nl));
            }
        }
        jl_binding_t *b = jl_get_binding_wr(jl_current_module, (jl_sym_t*)sym);
        jl_value_t *rhs = eval(args[1], locals, nl);
        jl_checked_assignment(b, rhs);
        return rhs;
    }
    else if (ex-&gt;head == new_sym) {
        jl_value_t *thetype = eval(args[0], locals, nl);
        JL_GC_PUSH(&amp;thetype);
        assert(jl_is_struct_type(thetype));
        jl_value_t *v = jl_new_struct_uninit((jl_struct_type_t*)thetype);
        JL_GC_POP();
        return v;
    }
    else if (ex-&gt;head == null_sym) {
        return (jl_value_t*)jl_nothing;
    }
    else if (ex-&gt;head == body_sym) {
        return eval_body(ex-&gt;args, locals, nl, 0);
    }
    else if (ex-&gt;head == exc_sym) {
        return jl_exception_in_transit;
    }
    else if (ex-&gt;head == static_typeof_sym) {
        return (jl_value_t*)jl_any_type;
    }
    else if (ex-&gt;head == method_sym) {
        jl_sym_t *fname = (jl_sym_t*)args[0];
        jl_value_t **bp=NULL;
        jl_binding_t *b=NULL;
        size_t i;
        for (i=0; i &lt; nl; i++) {
            if (locals[i*2] == (jl_value_t*)fname) {
                bp = &amp;locals[i*2+1];
                break;
            }
        }
        if (bp == NULL) {
            b = jl_get_binding_wr(jl_current_module, fname);
            bp = &amp;b-&gt;value;
        }
        jl_value_t *atypes=NULL, *meth=NULL, *tvars=NULL;
        JL_GC_PUSH(&amp;atypes, &amp;meth, &amp;tvars);
        atypes = eval(args[1], locals, nl);
        meth = eval(args[2], locals, nl);
        tvars = eval(args[3], locals, nl);
        jl_method_def(fname, bp, b, (jl_tuple_t*)atypes,
                      (jl_function_t*)meth, (jl_tuple_t*)tvars);
        JL_GC_POP();
        return jl_nothing;
    }
    else if (ex-&gt;head == const_sym) {
        jl_value_t *sym = args[0];
        size_t i;
        for (i=0; i &lt; nl; i++) {
            if (locals[i*2] == sym) {
                return (jl_value_t*)jl_nothing;
            }
        }
        jl_binding_t *b = jl_get_binding_wr(jl_current_module, (jl_sym_t*)sym);
        jl_declare_constant(b);
        return (jl_value_t*)jl_nothing;
    }
    else if (ex-&gt;head == error_sym) {
        jl_errorf("syntax error: %s", jl_string_data(args[0]));
    }
    else if (ex-&gt;head == line_sym) {
        return (jl_value_t*)jl_nothing;
    }
    else if (ex-&gt;head == multivalue_sym) {
        return (jl_value_t*)jl_nothing;
    }
    jl_error("not supported");
    return (jl_value_t*)jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7850">
static int label_idx(jl_value_t *tgt, jl_array_t *stmts)
{
    size_t j;
    long ltgt = jl_unbox_long(tgt);
    for(j=0; j &lt; stmts-&gt;length; j++) {
        jl_value_t *l = jl_cellref(stmts,j);
        if (jl_is_labelnode(l) &amp;&amp; jl_labelnode_label(l)==ltgt)
            break;
    }
    assert(j &lt; stmts-&gt;length);
    return j;
}
</t>
<t tx="ekr.20120404123906.7851">
static jl_value_t *eval_body(jl_array_t *stmts, jl_value_t **locals, size_t nl,
                             int start)
{
    jl_savestate_t __ss;
    jmp_buf __handlr;
    size_t i=start;
    while (1) {
        jl_value_t *stmt = jl_cellref(stmts,i);
        if (jl_is_gotonode(stmt)) {
            i = label_idx(jl_fieldref(stmt,0), stmts);
            continue;
        }
        if (jl_is_expr(stmt)) {
            jl_sym_t *head = ((jl_expr_t*)stmt)-&gt;head;
            if (head == goto_ifnot_sym) {
                jl_value_t *cond = eval(jl_exprarg(stmt,0), locals, nl);
                if (cond == jl_false) {
                    i = label_idx(jl_exprarg(stmt,1), stmts);
                    continue;
                }
            }
            else if (head == return_sym) {
                return eval(jl_exprarg(stmt,0), locals, nl);
            }
            else if (head == enter_sym) {
                jl_enter_handler(&amp;__ss, &amp;__handlr);
                if (!setjmp(__handlr)) {
                    return eval_body(stmts, locals, nl, i+1);
                }
                else {
                    i = label_idx(jl_exprarg(stmt,0), stmts);
                    continue;
                }
            }
            else if (head == leave_sym) {
                int hand_n_leave = jl_unbox_long(jl_exprarg(stmt,0));
                jl_pop_handler(hand_n_leave);
            }
            else {
                eval(stmt, locals, nl);
            }
        }
        else {
            eval(stmt, locals, nl);
        }
        i++;
    }
    assert(0);
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7852">
jl_value_t *jl_interpret_toplevel_thunk_with(jl_lambda_info_t *lam,
                                             jl_value_t **loc, size_t nl)
{
    jl_expr_t *ast = (jl_expr_t*)lam-&gt;ast;
    jl_array_t *stmts = jl_lam_body(ast)-&gt;args;
    jl_array_t *l = jl_lam_locals(ast);
    jl_value_t **names = &amp;((jl_value_t**)l-&gt;data)[0];
    nl += l-&gt;length;
    jl_value_t **locals = (jl_value_t**)alloca(nl*2*sizeof(void*));
    jl_value_t *r = (jl_value_t*)jl_null;
    size_t i=0;
    for(i=0; i &lt; l-&gt;length; i++) {
        locals[i*2]   = names[i];
        locals[i*2+1] = NULL;
    }
    for(; i &lt; nl; i++) {
        locals[i*2]   = loc[(i-l-&gt;length)*2];
        locals[i*2+1] = loc[(i-l-&gt;length)*2+1];
    }
    JL_GC_PUSHARGS(locals, nl*2);
    r = eval_body(stmts, locals, nl, 0);
    JL_GC_POP();
    return r;
}
</t>
<t tx="ekr.20120404123906.7853">
jl_value_t *jl_interpret_toplevel_thunk(jl_lambda_info_t *lam)
{
    return jl_interpret_toplevel_thunk_with(lam, NULL, 0);
}
</t>
<t tx="ekr.20120404123906.7930">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7931">/*
  modules and top-level bindings
*/
#include &lt;assert.h&gt;
#include "julia.h"

jl_module_t *jl_core_module=NULL;
jl_module_t *jl_base_module=NULL;
jl_module_t *jl_current_module=NULL;

static jl_binding_t *varlist_binding=NULL;

</t>
<t tx="ekr.20120404123906.7932">jl_module_t *jl_new_module(jl_sym_t *name)
{
    jl_module_t *m = (jl_module_t*)allocobj(sizeof(jl_module_t));
    m-&gt;type = (jl_type_t*)jl_module_type;
    m-&gt;name = name;
    htable_new(&amp;m-&gt;bindings, 0);
    htable_new(&amp;m-&gt;macros, 0);
    jl_set_const(m, name, (jl_value_t*)m);
    if (jl_current_module)
        jl_set_const(m, jl_current_module-&gt;name, (jl_value_t*)jl_current_module);
    //arraylist_new(&amp;m-&gt;imports, 0);
    return m;
}
</t>
<t tx="ekr.20120404123906.7933">
// get binding for assignment
</t>
<t tx="ekr.20120404123906.7934">jl_binding_t *jl_get_binding_wr(jl_module_t *m, jl_sym_t *var)
{
    jl_binding_t **bp = (jl_binding_t**)ptrhash_bp(&amp;m-&gt;bindings, var);
    jl_binding_t *b;
    if (*bp == HT_NOTFOUND) {
        b = (jl_binding_t*)allocb(sizeof(jl_binding_t));
        b-&gt;name = var;
        b-&gt;value = NULL;
        b-&gt;type = (jl_type_t*)jl_any_type;
        b-&gt;constp = 0;
        b-&gt;exportp = 0;
        *bp = b;

        // keep track of all variables added after the VARIABLES array
        // is defined
        if (jl_base_module) {
            if (varlist_binding == NULL) {
                varlist_binding = jl_get_binding(jl_base_module, jl_symbol("VARIABLES"));
            }
            if (varlist_binding &amp;&amp; varlist_binding-&gt;value != NULL &amp;&amp;
                jl_typeis(varlist_binding-&gt;value, jl_array_any_type)) {
                jl_array_t *a = (jl_array_t*)varlist_binding-&gt;value;
                jl_cell_1d_push(a, (jl_value_t*)var);
            }
        }
    }
    return *bp;
}
</t>
<t tx="ekr.20120404123906.7935">
// get binding for reading. might return NULL for unbound.
</t>
<t tx="ekr.20120404123906.7936">jl_binding_t *jl_get_binding(jl_module_t *m, jl_sym_t *var)
{
    if (m == NULL) return NULL;
    jl_binding_t *b = (jl_binding_t*)ptrhash_get(&amp;m-&gt;bindings, var);
    if (b == HT_NOTFOUND) {
        if (jl_core_module &amp;&amp; m != jl_core_module) {
            return jl_get_binding(jl_core_module, var);
        }
        return NULL;
    }
    return b;
}
</t>
<t tx="ekr.20120404123906.7937">
int jl_boundp(jl_module_t *m, jl_sym_t *var)
{
    jl_binding_t *b = jl_get_binding(m, var);
    return b &amp;&amp; (b-&gt;value != NULL);
}
</t>
<t tx="ekr.20120404123906.7938">
jl_value_t *jl_get_global(jl_module_t *m, jl_sym_t *var)
{
    jl_binding_t *b = jl_get_binding(m, var);
    if (b == NULL) return NULL;
    return b-&gt;value;
}
</t>
<t tx="ekr.20120404123906.7939">
void jl_set_global(jl_module_t *m, jl_sym_t *var, jl_value_t *val)
{
    jl_binding_t *bp = jl_get_binding_wr(m, var);
    if (!bp-&gt;constp) {
        bp-&gt;value = val;
    }
}
</t>
<t tx="ekr.20120404123906.7940">
void jl_set_const(jl_module_t *m, jl_sym_t *var, jl_value_t *val)
{
    jl_binding_t *bp = jl_get_binding_wr(m, var);
    if (!bp-&gt;constp) {
        bp-&gt;value = val;
        bp-&gt;constp = 1;
    }
}
</t>
<t tx="ekr.20120404123906.7941">
DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var)
{
    if (m == NULL) m = jl_current_module;
    jl_binding_t *b = jl_get_binding(m, var);
    return b &amp;&amp; b-&gt;constp;
}
</t>
<t tx="ekr.20120404123906.7942">
void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs)
{
    if (b-&gt;constp &amp;&amp; b-&gt;value != NULL) {
        //jl_errorf("cannot redefine constant %s", b-&gt;name-&gt;name);
        ios_printf(ios_stderr, "Warning: redefinition of constant %s ignored\n",
                   b-&gt;name-&gt;name);
    }
    else {
        b-&gt;value = rhs;
    }
}
</t>
<t tx="ekr.20120404123906.7943">
void jl_declare_constant(jl_binding_t *b)
{
    if (b-&gt;value != NULL &amp;&amp; !b-&gt;constp) {
        jl_errorf("cannot declare %s constant; it already has a value",
                  b-&gt;name-&gt;name);
    }
    b-&gt;constp = 1;
}
</t>
<t tx="ekr.20120404123906.7944">
jl_module_t *jl_add_module(jl_module_t *m, jl_module_t *child);
jl_module_t *jl_get_module(jl_module_t *m, jl_sym_t *name);
jl_module_t *jl_import_module(jl_module_t *to, jl_module_t *from);

</t>
<t tx="ekr.20120404123906.7945">jl_function_t *jl_get_expander(jl_module_t *m, jl_sym_t *macroname)
{
    jl_function_t *f = (jl_function_t*)ptrhash_get(&amp;m-&gt;macros, macroname);
    if (f == HT_NOTFOUND)
        return NULL;
    return f;
}
</t>
<t tx="ekr.20120404123906.7946">
void jl_set_expander(jl_module_t *m, jl_sym_t *macroname, jl_function_t *f)
{
    jl_function_t **bp = (jl_function_t**)ptrhash_bp(&amp;m-&gt;macros, macroname);
    *bp = f;
}
</t>
<t tx="ekr.20120404123906.7947">
DLLEXPORT jl_value_t *jl_get_current_module()
{
    return (jl_value_t*)jl_current_module;
}
</t>
<t tx="ekr.20120404123906.7948">
DLLEXPORT void jl_set_current_module(jl_value_t *m)
{
    assert(jl_typeis(m, jl_module_type));
    jl_current_module = (jl_module_t*)m;
}
</t>
<t tx="ekr.20120404123906.7949">@language c
@tabwidth -4
@others

#define TAG_TYPE_NW (NWORDS(sizeof(jl_tag_type_t))-1)
#define STRUCT_TYPE_NW (NWORDS(sizeof(jl_struct_type_t))-1)
#define BITS_TYPE_NW (NWORDS(sizeof(jl_bits_type_t))-1)

int jl_assign_type_uid(void);

#endif
</t>
<t tx="ekr.20120404123906.7950">#ifndef NEWOBJ_INTERNAL_H
#define NEWOBJ_INTERNAL_H

</t>
<t tx="ekr.20120404123906.7951">static inline jl_value_t *newobj(jl_type_t *type, size_t nfields)
{
    jl_value_t *jv = (jl_value_t*)allocobj((1+nfields) * sizeof(void*));
    jv-&gt;type = type;
    return jv;
}
</t>
<t tx="ekr.20120404123906.7952">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.7953">/*
  sys.c
  I/O and operating system utility functions
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;libgen.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include "julia.h"

// --- io and select ---

</t>
<t tx="ekr.20120404123906.7954">void jl__not__used__(void)
{
    // force inclusion of lib/socket.o in executable
    short p=0;
    open_any_tcp_port(&amp;p);
}
</t>
<t tx="ekr.20120404123906.7955">
DLLEXPORT int jl_sizeof_fd_set(void) { return sizeof(fd_set); }
</t>
<t tx="ekr.20120404123906.7956">
DLLEXPORT int jl_sizeof_timeval(void) { return sizeof(struct timeval); }
</t>
<t tx="ekr.20120404123906.7957">
DLLEXPORT void jl_set_timeval(struct timeval *tv, double tout)
{
    tv-&gt;tv_sec = (int)tout;
    tv-&gt;tv_usec = (int)((tout-(int)tout)*1.0e6);
}
</t>
<t tx="ekr.20120404123906.7958">
DLLEXPORT void jl_fd_clr(fd_set *set, int fd)
{
    FD_CLR(fd, set);
}
</t>
<t tx="ekr.20120404123906.7959">
DLLEXPORT int jl_fd_isset(fd_set *set, int fd)
{
    return FD_ISSET(fd, set);
}
</t>
<t tx="ekr.20120404123906.7960">
DLLEXPORT void jl_fd_set(fd_set *set, int fd)
{
    FD_SET(fd, set);
}
</t>
<t tx="ekr.20120404123906.7961">
DLLEXPORT void jl_fd_zero(fd_set *set)
{
    FD_ZERO(set);
}
</t>
<t tx="ekr.20120404123906.7962">
DLLEXPORT uint32_t jl_getutf8(ios_t *s)
{
    uint32_t wc=0;
    ios_getutf8(s, &amp;wc);
    return wc;
}
</t>
<t tx="ekr.20120404123906.7963">
DLLEXPORT size_t jl_ios_size(ios_t *s)
{
    return s-&gt;size;
}
</t>
<t tx="ekr.20120404123906.7964">
DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }
</t>
<t tx="ekr.20120404123906.7965">
DLLEXPORT long jl_ios_fd(ios_t *s)
{
    return s-&gt;fd;
}
</t>
<t tx="ekr.20120404123906.7966">
DLLEXPORT int32_t jl_nb_available(ios_t *s)
{
    return (int32_t)(s-&gt;size - s-&gt;bpos);
}
</t>
<t tx="ekr.20120404123906.7967">
// --- io constructors ---

</t>
<t tx="ekr.20120404123906.7968">DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }
</t>
<t tx="ekr.20120404123906.7969">
// hack to expose ios_stdout to julia. we could create a new iostream pointing
// to stdout, but then there would be two buffers for one descriptor, and
// ios_stdout is used before julia IOStream is available, creating a potential
// mess.
</t>
<t tx="ekr.20120404123906.7970">DLLEXPORT jl_value_t *jl_stdout_stream(void)
{
    jl_array_t *a = jl_alloc_array_1d(jl_array_uint8_type, sizeof(ios_t));
    a-&gt;data = (void*)ios_stdout;
    return (jl_value_t*)a;
}
</t>
<t tx="ekr.20120404123906.7971">
// --- current output stream ---

</t>
<t tx="ekr.20120404123906.7972">jl_value_t *jl_current_output_stream_obj(void)
{
    return jl_current_task-&gt;state.ostream_obj;
}
</t>
<t tx="ekr.20120404123906.7973">
DLLEXPORT ios_t *jl_current_output_stream(void)
{
    return jl_current_task-&gt;state.current_output_stream;
}
</t>
<t tx="ekr.20120404123906.7974">
void jl_set_current_output_stream_obj(jl_value_t *v)
{
    jl_current_task-&gt;state.ostream_obj = v;
    ios_t *s = (ios_t*)jl_array_data(jl_fieldref(v,0));
    jl_current_task-&gt;state.current_output_stream = s;
    // if current stream has never been set before, propagate to all
    // outer contexts.
    jl_savestate_t *ss = jl_current_task-&gt;state.prev;
    while (ss != NULL &amp;&amp; ss-&gt;ostream_obj == (jl_value_t*)jl_null) {
        ss-&gt;ostream_obj = v;
        ss-&gt;current_output_stream = s;
        ss = ss-&gt;prev;
    }
}
</t>
<t tx="ekr.20120404123906.7975">
// --- buffer manipulation ---

</t>
<t tx="ekr.20120404123906.7976">jl_array_t *jl_takebuf_array(ios_t *s)
{
    size_t n;
    jl_array_t *a;
    if (s-&gt;buf == &amp;s-&gt;local[0]) {
        // small data case. copies, but this can be avoided using the
        // technique of jl_readuntil below.
        a = jl_pchar_to_array(s-&gt;buf, s-&gt;size);
        ios_trunc(s, 0);
    }
    else {
        assert(s-&gt;julia_alloc);
        char *b = ios_takebuf(s, &amp;n);
        a = jl_alloc_array_1d(jl_array_uint8_type, 0);
        a-&gt;data = b;
        a-&gt;length = n-1;
        a-&gt;nrows = n-1;
        jl_gc_acquire_buffer(b);
    }
    return a;
}
</t>
<t tx="ekr.20120404123906.7977">
jl_value_t *jl_takebuf_string(ios_t *s)
{
    jl_array_t *a = jl_takebuf_array(s);
    JL_GC_PUSH(&amp;a);
    jl_value_t *str = jl_array_to_string(a);
    JL_GC_POP();
    return str;
}
</t>
<t tx="ekr.20120404123906.7978">
jl_array_t *jl_readuntil(ios_t *s, uint8_t delim)
{
    jl_array_t *a = jl_alloc_array_1d(jl_array_uint8_type, 80);
    ios_t dest;
    jl_ios_mem(&amp;dest, 0);
    ios_setbuf(&amp;dest, a-&gt;data, 80, 0);
    size_t n = ios_copyuntil(&amp;dest, s, delim);
    if (dest.buf != a-&gt;data) {
        return jl_takebuf_array(&amp;dest);
    }
    else {
        a-&gt;length = n;
        a-&gt;nrows = n;
        ((char*)a-&gt;data)[n] = '\0';
    }
    return a;
}
</t>
<t tx="ekr.20120404123906.7979">
// -- syscall utilities --

</t>
<t tx="ekr.20120404123906.7980">int jl_errno(void) { return errno; }
</t>
<t tx="ekr.20120404123906.7981">
jl_value_t *jl_strerror(int errnum)
{
    char *str = strerror(errnum);
    return jl_pchar_to_string((char*)str, strlen(str));
}
</t>
<t tx="ekr.20120404123906.7982">
// -- iterating the environment --

#ifdef __APPLE__
#include &lt;crt_externs.h&gt;
#else
extern char **environ;
#endif

</t>
<t tx="ekr.20120404123906.7983">jl_value_t *jl_environ(int i)
{
#ifdef __APPLE__
    char **environ = *_NSGetEnviron();
#endif
    char *env = environ[i];
    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;
}
</t>
<t tx="ekr.20120404123906.7984">
// -- child process status --

</t>
<t tx="ekr.20120404123906.7985">int jl_process_exited(int status)      { return WIFEXITED(status); }
</t>
<t tx="ekr.20120404123906.7986">int jl_process_signaled(int status)    { return WIFSIGNALED(status); }
</t>
<t tx="ekr.20120404123906.7987">int jl_process_stopped(int status)     { return WIFSTOPPED(status); }
</t>
<t tx="ekr.20120404123906.7988">
int jl_process_exit_status(int status) { return WEXITSTATUS(status); }
</t>
<t tx="ekr.20120404123906.7989">int jl_process_term_signal(int status) { return WTERMSIG(status); }
</t>
<t tx="ekr.20120404123906.7990">int jl_process_stop_signal(int status) { return WSTOPSIG(status); }
</t>
<t tx="ekr.20120404123906.7991">
// -- access to std filehandles --

</t>
<t tx="ekr.20120404123906.7992">int jl_stdin(void)  { return STDIN_FILENO; }
</t>
<t tx="ekr.20120404123906.7993">int jl_stdout(void) { return STDOUT_FILENO; }
</t>
<t tx="ekr.20120404123906.7994">int jl_stderr(void) { return STDERR_FILENO; }
</t>
<t tx="ekr.20120404123906.7995">
// -- I/O thread --

static pthread_t io_thread;
static pthread_mutex_t q_mut;
static pthread_mutex_t wake_mut;
static pthread_cond_t wake_cond;

typedef struct _sendreq_t {
    int fd;
    ios_t *buf;
    int now;
    struct _sendreq_t *next;
} sendreq_t;

static sendreq_t *ioq = NULL;
static sendreq_t *ioq_freelist = NULL;

int _os_write_all(long fd, void *buf, size_t n, size_t *nwritten);

</t>
<t tx="ekr.20120404123906.7996">static void *run_io_thr(void *arg)
{
    sigset_t set;
    sigemptyset(&amp;set);
    sigaddset(&amp;set, SIGFPE);
    sigaddset(&amp;set, SIGINT);
    sigaddset(&amp;set, SIGSEGV);
    pthread_sigmask(SIG_BLOCK, &amp;set, NULL);

    while (1) {
        while (ioq == NULL) {
            pthread_mutex_lock(&amp;wake_mut);
            pthread_cond_wait(&amp;wake_cond, &amp;wake_mut);
            pthread_mutex_unlock(&amp;wake_mut);
        }
        assert(ioq != NULL);

        pthread_mutex_lock(&amp;q_mut);
        sendreq_t *r = ioq;
        ioq = ioq-&gt;next;
        pthread_mutex_unlock(&amp;q_mut);

        if (!r-&gt;now) {
            int64_t now = (int64_t)(clock_now()*1e6);
            int64_t waittime = r-&gt;buf-&gt;userdata+200-now;  // microseconds
            if (waittime &gt; 0) {
                struct timespec wt;
                wt.tv_sec = 0;
                wt.tv_nsec = waittime * 1000;
                nanosleep(&amp;wt, NULL);
            }
        }

        pthread_mutex_lock(&amp;r-&gt;buf-&gt;mutex);
        size_t sz;
        size_t n = r-&gt;buf-&gt;size;
        char *buf = ios_takebuf(r-&gt;buf, &amp;sz);
        pthread_mutex_unlock(&amp;r-&gt;buf-&gt;mutex);

        size_t nw;
        _os_write_all(r-&gt;fd, buf, n, &amp;nw);
        julia_free(buf);

        pthread_mutex_lock(&amp;q_mut);
        r-&gt;next = ioq_freelist;
        ioq_freelist = r;
        pthread_mutex_unlock(&amp;q_mut);
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.7997">
DLLEXPORT void jl_buf_mutex_lock(ios_t *s)
{
    if (!s-&gt;mutex_initialized) {
        pthread_mutex_init(&amp;s-&gt;mutex, NULL);
        s-&gt;mutex_initialized = 1;
    }
    pthread_mutex_lock(&amp;s-&gt;mutex);
}
</t>
<t tx="ekr.20120404123906.7998">
DLLEXPORT void jl_buf_mutex_unlock(ios_t *s)
{
    pthread_mutex_unlock(&amp;s-&gt;mutex);
}
</t>
<t tx="ekr.20120404123906.7999">
DLLEXPORT void jl_enq_send_req(ios_t *dest, ios_t *buf, int now)
{
    pthread_mutex_lock(&amp;q_mut);
    sendreq_t *req = ioq;
    sendreq_t **pr = &amp;ioq;
    while (req != NULL) {
        if (req-&gt;fd == dest-&gt;fd) {
            if (now &amp;&amp; !req-&gt;now) {
                // increase priority
                *pr = req-&gt;next;
                req-&gt;next = ioq;
                ioq = req;
                req-&gt;now = 1;
            }
            pthread_mutex_unlock(&amp;q_mut);
            return;
        }
        pr = &amp;req-&gt;next;
        req = req-&gt;next;
    }

    if (ioq_freelist != NULL) {
        req = ioq_freelist;
        ioq_freelist = ioq_freelist-&gt;next;
    }
    else {
        req = (sendreq_t*)malloc(sizeof(sendreq_t));
    }
    req-&gt;fd = dest-&gt;fd;
    req-&gt;buf = buf;
    req-&gt;now = now;
    req-&gt;next = NULL;
    buf-&gt;userdata = (int64_t)(clock_now()*1e6);
    if (ioq == NULL) {
        ioq = req;
    }
    else {
        if (now) {
            req-&gt;next = ioq;
            ioq = req;
        }
        else {
            sendreq_t *r = ioq;
            while (r-&gt;next != NULL) {
                r = r-&gt;next;
            }
            r-&gt;next = req;
        }
    }
    pthread_mutex_unlock(&amp;q_mut);
    pthread_cond_signal(&amp;wake_cond);
}
</t>
<t tx="ekr.20120404123906.8000">
DLLEXPORT void jl_start_io_thread(void)
{
    pthread_mutex_init(&amp;q_mut, NULL);
    pthread_mutex_init(&amp;wake_mut, NULL);
    pthread_cond_init(&amp;wake_cond, NULL);
    pthread_create(&amp;io_thread, NULL, run_io_thr, NULL);
}
</t>
<t tx="ekr.20120404123906.8001">@language c
@tabwidth -4
@others

#undef hash_size
#undef max_probe
</t>
<t tx="ekr.20120404123906.8002">#define hash_size(h) ((h)-&gt;length/2)

// compute empirical max-probe for a given size
#define max_probe(size) ((size)&lt;=(HT_N_INLINE*2) ? (HT_N_INLINE/2) : (size)&gt;&gt;3)

#define keyhash(k)     inthash((uptrint_t)(k))
#define h2index(hv,sz) (index_t)(((hv) &amp; ((sz)-1))*2)

static void **jl_table_lookup_bp(jl_array_t **pa, void *key);

</t>
<t tx="ekr.20120404123906.8003">void jl_idtable_rehash(jl_array_t **pa, size_t newsz)
{
    size_t sz = (*pa)-&gt;length;
    size_t i;
    void **ol = (void**)(*pa)-&gt;data;
    *pa = jl_alloc_cell_1d(newsz);
    for(i=0; i &lt; sz; i+=2) {
        if (ol[i+1] != NULL) {
            (*jl_table_lookup_bp(pa, ol[i])) = ol[i+1];
        }
    }
}
</t>
<t tx="ekr.20120404123906.8004">
static void **jl_table_lookup_bp(jl_array_t **pa, void *key)
{
    uint_t hv;
    jl_array_t *a = *pa;
    size_t orig, index, iter;
    size_t newsz, sz = hash_size(a);
    size_t maxprobe = max_probe(sz);
    void **tab = (void**)a-&gt;data;

    hv = keyhash(key);
 retry_bp:
    iter = 0;
    index = h2index(hv,sz);
    sz *= 2;
    orig = index;

    do {
        if (tab[index+1] == NULL) {
            tab[index] = key;
            return &amp;tab[index+1];
        }

        if (key == tab[index])
            return &amp;tab[index+1];

        index = (index+2) &amp; (sz-1);
        iter++;
        if (iter &gt; maxprobe)
            break;
    } while (index != orig);

    /* table full */
    /* quadruple size, rehash, retry the insert */
    /* it's important to grow the table really fast; otherwise we waste */
    /* lots of time rehashing all the keys over and over. */
    sz = a-&gt;length;
    if (sz &gt;= (1&lt;&lt;19) || (sz &lt;= (1&lt;&lt;8)))
        newsz = sz&lt;&lt;1;
    else if (sz &lt;= HT_N_INLINE)
        newsz = HT_N_INLINE;
    else
        newsz = sz&lt;&lt;2;
    jl_idtable_rehash(pa, newsz);

    a = *pa;
    tab = (void**)a-&gt;data;    
    sz = hash_size(a);
    maxprobe = max_probe(sz);

    goto retry_bp;

    return NULL;
}
</t>
<t tx="ekr.20120404123906.8005">
/* returns bp if key is in hash, otherwise NULL */
/* if return is non-NULL and *bp == NULL then key was deleted */
</t>
<t tx="ekr.20120404123906.8006">static void **jl_table_peek_bp(jl_array_t *a, void *key)
{
    size_t sz = hash_size(a);
    size_t maxprobe = max_probe(sz);
    void **tab = (void**)a-&gt;data;
    uint_t hv = keyhash(key);
    size_t index = h2index(hv, sz);
    sz *= 2;
    size_t orig = index;
    size_t iter = 0;

    do {
        if (tab[index] == NULL)
            return NULL;
        if (key == tab[index])
            return &amp;tab[index+1];

        index = (index+2) &amp; (sz-1);
        iter++;
        if (iter &gt; maxprobe)
            break;
    } while (index != orig);

    return NULL;
}
</t>
<t tx="ekr.20120404123906.8007">
DLLEXPORT
jl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val)
{
    void **bp = jl_table_lookup_bp(&amp;h, key);
    *bp = val;
    return h;
}
</t>
<t tx="ekr.20120404123906.8008">
DLLEXPORT
jl_value_t *jl_eqtable_get(jl_array_t *h, void *key, jl_value_t *deflt)
{
    void **bp = jl_table_peek_bp(h, key);
    if (bp == NULL || *bp == NULL)
        return deflt;
    return *bp;
}
</t>
<t tx="ekr.20120404123906.8009">
DLLEXPORT
int jl_eqtable_del(jl_array_t *h, void *key)
{
    void **bp = jl_table_peek_bp(h, key);
    if (bp != NULL) {
        *bp = NULL;
        return 1;
    }
    return 0;
}
</t>
<t tx="ekr.20120404123906.8010">
DLLEXPORT
jl_value_t *jl_eqtable_next(jl_array_t *t, uint32_t i)
{
    if (i&amp;1) i++;
    while (i &lt; t-&gt;length &amp;&amp; ((void**)t-&gt;data)[i+1] == NULL)
        i+=2;
    if (i &gt;= t-&gt;length) return (jl_value_t*)jl_null;
    jl_value_t *vi=NULL, *vt=NULL, *vv=NULL;
    JL_GC_PUSH(&amp;vi, &amp;vt);
    vi = jl_box_uint32(i+2);
    vt = (jl_value_t*)jl_tuple2(((jl_value_t**)t-&gt;data)[i],
                                ((jl_value_t**)t-&gt;data)[i+1]);
    vv = (jl_value_t*)jl_tuple2(vt, vi);
    JL_GC_POP();
    return vv;
}
</t>
<t tx="ekr.20120404123906.8011">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.8012">/*
  task.c
  lightweight processes (symmetric coroutines)
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;signal.h&gt;
#include &lt;libgen.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include "julia.h"
#include "builtin_proto.h"
#if defined(__APPLE__)
#include &lt;execinfo.h&gt;
#else
// This gives unwind only local unwinding options ==&gt; faster code
#define UNW_LOCAL_ONLY
#include &lt;libunwind.h&gt;
#endif

/* This probing code is derived from Douglas Jones' user thread library */

/* true if stack grows up, false if down */
static int _stack_grows_up;

/* the offset of the beginning of the stack frame in a function */
static size_t _frame_offset;

struct _probe_data {
    intptr_t low_bound;		/* below probe on stack */
    intptr_t probe_local;	/* local to probe on stack */
    intptr_t high_bound;	/* above probe on stack */
    intptr_t prior_local;	/* value of probe_local from earlier call */

    jmp_buf probe_env;	/* saved environment of probe */
    jmp_buf probe_sameAR;	/* second environment saved by same call */
    jmp_buf probe_samePC;	/* environment saved on previous call */

    jmp_buf * ref_probe;	/* switches between probes */
};

</t>
<t tx="ekr.20120404123906.8013">static void boundhigh(struct _probe_data *p)
{
    int c;
    p-&gt;high_bound = (intptr_t)&amp;c;
}
</t>
<t tx="ekr.20120404123906.8014">
static void probe(struct _probe_data *p)
{
    p-&gt;prior_local = p-&gt;probe_local;
    p-&gt;probe_local = (intptr_t)&amp;p;
    setjmp( *(p-&gt;ref_probe) );
    p-&gt;ref_probe = &amp;p-&gt;probe_env;
    setjmp( p-&gt;probe_sameAR );
    boundhigh(p);
}
</t>
<t tx="ekr.20120404123906.8015">
static void boundlow(struct _probe_data *p)
{
    p-&gt;low_bound = (intptr_t)&amp;p;
    probe(p);
}
</t>
<t tx="ekr.20120404123906.8016">
// we need this function to exist so we can measure its stack frame!
</t>
<t tx="ekr.20120404123906.8017">static void fill(struct _probe_data *p) __attribute__ ((noinline));
static void fill(struct _probe_data *p)
{
    boundlow(p);
}
</t>
<t tx="ekr.20120404123906.8018">
static void _infer_direction_from(int *first_addr)
{
    int second;
    _stack_grows_up = (first_addr &lt; &amp;second);
}
</t>
<t tx="ekr.20120404123906.8019">
static void _infer_stack_direction(void)
{
    int first;
    _infer_direction_from(&amp;first);
}
</t>
<t tx="ekr.20120404123906.8020">
static int mangle_pointers;
extern char *jl_stack_lo;
extern char *jl_stack_hi;

</t>
<t tx="ekr.20120404123906.8021">static void _probe_arch(void)
{
    struct _probe_data p;
    memset(p.probe_env, 0, sizeof(jmp_buf));
    memset(p.probe_sameAR, 0, sizeof(jmp_buf));
    memset(p.probe_samePC, 0, sizeof(jmp_buf));
    p.ref_probe = &amp;p.probe_samePC;

    _infer_stack_direction();

    /* do a probe with filler on stack */
    fill(&amp;p);
    /* do a probe without filler */
    boundlow(&amp;p);

#if defined(__linux) &amp;&amp; defined(__i386__)
    char **s = (char**)p.ref_probe;
    mangle_pointers = !(s[4] &gt; jl_stack_lo &amp;&amp;
                        s[4] &lt; jl_stack_hi);
#elif defined(__linux) &amp;&amp; defined(__x86_64__)
    char **s = (char**)p.ref_probe;
    mangle_pointers = !(s[6] &gt; jl_stack_lo &amp;&amp;
                        s[6] &lt; jl_stack_hi);
#else
    mangle_pointers = 0;
#endif

    intptr_t prior_diff = p.probe_local - p.prior_local;
    _frame_offset = labs(prior_diff);
}
</t>
<t tx="ekr.20120404123906.8022">
/* end probing code */

/*
  TODO:
  - per-task storage (scheme-like parameters)
  - stack growth
*/

extern size_t jl_page_size;
jl_struct_type_t *jl_task_type;
DLLEXPORT jl_task_t * volatile jl_current_task;
jl_task_t *jl_root_task;
jl_value_t * volatile jl_task_arg_in_transit;
static volatile int n_args_in_transit;
jl_value_t *jl_exception_in_transit;
#ifdef JL_GC_MARKSWEEP
jl_gcframe_t *jl_pgcstack = NULL;
#endif

static void start_task(jl_task_t *t);

#ifdef COPY_STACKS
jmp_buf * volatile jl_jmp_target;

</t>
<t tx="ekr.20120404123906.8023">static void save_stack(jl_task_t *t)
{
    volatile int _x;
    size_t nb = (char*)t-&gt;stackbase - (char*)&amp;_x;
    char *buf;
    if (t-&gt;stkbuf == NULL || t-&gt;bufsz &lt; nb) {
        buf = allocb(nb);
        t-&gt;stkbuf = buf;
        t-&gt;bufsz = nb;
    }
    else {
        buf = t-&gt;stkbuf;
    }
    t-&gt;ssize = nb;
    memcpy(buf, (char*)&amp;_x, nb);
}
</t>
<t tx="ekr.20120404123906.8024">
static void restore_stack(jl_task_t *t, jmp_buf *where)
{
    volatile int _x[64];

    if ((char*)&amp;_x[0] &gt; (char*)(t-&gt;stackbase-t-&gt;ssize)) {
        restore_stack(t, where);
    }
    jl_jmp_target = where;
    if (t-&gt;stkbuf != NULL) {
        memcpy(t-&gt;stackbase-t-&gt;ssize, t-&gt;stkbuf, t-&gt;ssize);
    }
    longjmp(*jl_jmp_target, 1);
}
</t>
<t tx="ekr.20120404123906.8025">
static void switch_stack(jl_task_t *t, jmp_buf *where)
{
    assert(t == jl_current_task);
    if (t-&gt;stkbuf == NULL) {
        start_task(t);
        // doesn't return
    }
    else {
        restore_stack(t, where);
    }
}
</t>
<t tx="ekr.20120404123906.8026">
void jl_switch_stack(jl_task_t *t, jmp_buf *where)
{
    switch_stack(t, where);
}
</t>
<t tx="ekr.20120404123906.8027">#endif

</t>
<t tx="ekr.20120404123906.8028">static void ctx_switch(jl_task_t *t, jmp_buf *where)
{
    if (t == jl_current_task)
        return;
    /*
      making task switching interrupt-safe is going to be challenging.
      we need JL_SIGATOMIC_BEGIN in jl_enter_handler, and then
      JL_SIGATOMIC_END after every JL_TRY setjmp that returns zero.
      also protect jl_eh_restore_state.
      then we need JL_SIGATOMIC_BEGIN at the top of this function (ctx_switch).
      the JL_SIGATOMIC_END at the end of this function handles the case
      of task switching with yieldto().
      then we need to handle the case of task switching via raise().
      to do that, the top of every catch block must do JL_SIGATOMIC_END
      *IF AND ONLY IF* throwing the exception involved a task switch.
    */
    //JL_SIGATOMIC_BEGIN();
    if (!setjmp(jl_current_task-&gt;ctx)) {
#ifdef COPY_STACKS
        jl_task_t *lastt = jl_current_task;
        save_stack(lastt);
#endif

        // set up global state for new task
#ifdef JL_GC_MARKSWEEP
        jl_current_task-&gt;state.gcstack = jl_pgcstack;
        jl_pgcstack = t-&gt;state.gcstack;
#endif
        jl_current_task = t;

#ifdef COPY_STACKS
        jl_jmp_target = where;
        longjmp(lastt-&gt;base_ctx, 1);
#else
        longjmp(*where, 1);
#endif
    }
    //JL_SIGATOMIC_END();
}
</t>
<t tx="ekr.20120404123906.8029">
static jl_value_t *switchto(jl_task_t *t)
{
    if (t-&gt;done==jl_true) {
        jl_task_arg_in_transit = (jl_value_t*)jl_null;
        return t-&gt;result;
    }
    ctx_switch(t, &amp;t-&gt;ctx);
    jl_value_t *val = jl_task_arg_in_transit;
    jl_task_arg_in_transit = (jl_value_t*)jl_null;
    return val;
}
</t>
<t tx="ekr.20120404123906.8030">
#ifndef COPY_STACKS

#ifdef __linux
#if defined(__i386__)
</t>
<t tx="ekr.20120404123906.8031">static intptr_t ptr_mangle(intptr_t p)
{
    intptr_t ret;
    asm(" movl %1, %%eax;\n"
        " xorl %%gs:0x18, %%eax;"
        " roll $9, %%eax;"
        " movl %%eax, %0;"
        : "=r"(ret) : "r"(p) : "%eax");
    return ret;
}
</t>
<t tx="ekr.20120404123906.8032">static intptr_t ptr_demangle(intptr_t p)
{
    intptr_t ret;
    asm(" movl %1, %%eax;\n"
        " rorl $9, %%eax;"
        " xorl %%gs:0x18, %%eax;"
        " movl %%eax, %0;"
        : "=r"(ret) : "r"(p) : "%eax" );
    return ret;
}
</t>
<t tx="ekr.20120404123906.8033">#elif defined(__x86_64__)
</t>
<t tx="ekr.20120404123906.8034">static intptr_t ptr_mangle(intptr_t p)
{
    intptr_t ret;
    asm(" movq %1, %%rax;\n"
        " xorq %%fs:0x30, %%rax;"
        " rolq $17, %%rax;"
        " movq %%rax, %0;"
        : "=r"(ret) : "r"(p) : "%rax");
    return ret;
}
</t>
<t tx="ekr.20120404123906.8035">static intptr_t ptr_demangle(intptr_t p)
{
    intptr_t ret;
    asm(" movq %1, %%rax;\n"
        " rorq $17, %%rax;"
        " xorq %%fs:0x30, %%rax;"
        " movq %%rax, %0;"
        : "=r"(ret) : "r"(p) : "%rax" );
    return ret;
}
</t>
<t tx="ekr.20120404123906.8036">#endif
#endif //__linux

/* rebase any values in saved state to the new stack */
</t>
<t tx="ekr.20120404123906.8037">static void rebase_state(jmp_buf *ctx, intptr_t local_sp, intptr_t new_sp)
{
    ptrint_t *s = (ptrint_t*)ctx;
    ptrint_t diff = new_sp - local_sp; /* subtract old base, and add new base */
#if defined(__linux) &amp;&amp; defined(__i386__)
    s[3] += diff;
    if (mangle_pointers)
        s[4] = ptr_mangle(ptr_demangle(s[4])+diff);
    else
        s[4] += diff;
#elif defined(__linux) &amp;&amp; defined(__x86_64__)
    if (mangle_pointers) {
        s[1] = ptr_mangle(ptr_demangle(s[1])+diff);
        s[6] = ptr_mangle(ptr_demangle(s[6])+diff);
    }
    else {
        s[1] += diff;
        s[6] += diff;
    }
#elif defined(__APPLE__) &amp;&amp; defined(__i386__)
    s[8] += diff;
    s[9] += diff;
#elif defined(__APPLE__) &amp;&amp; defined(__x86_64__)
    s[1] += diff;
    s[2] += diff;
#else
#error "COPY_STACKS must be defined on this platform."
#endif
}
</t>
<t tx="ekr.20120404123906.8038">
#endif /* !COPY_STACKS */

</t>
<t tx="ekr.20120404123906.8039">jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg)
{
    jl_task_arg_in_transit = arg;
    n_args_in_transit = 1;
    return switchto(t);
}
</t>
<t tx="ekr.20120404123906.8040">
static void finish_task(jl_task_t *t, jl_value_t *resultval)
{
    assert(t-&gt;done==jl_false);
    t-&gt;done = jl_true;
    t-&gt;result = resultval;
    // TODO: early free of t-&gt;stkbuf
#ifdef COPY_STACKS
    t-&gt;stkbuf = NULL;
#endif
}
</t>
<t tx="ekr.20120404123906.8041">
static void start_task(jl_task_t *t)
{
    // this runs the first time we switch to t
    jl_value_t *arg = jl_task_arg_in_transit;
    jl_value_t *res;
    JL_GC_PUSH(&amp;arg);

#ifdef COPY_STACKS
    ptrint_t local_sp = (ptrint_t)jl_pgcstack;
    // here we attempt to figure out how big our stack frame is, since we
    // might need to copy all of it later. this is a bit of a fuzzy guess.
    local_sp += sizeof(jl_gcframe_t);
    local_sp += 12*sizeof(void*);
    t-&gt;stackbase = (void*)(local_sp + _frame_offset);
    if (setjmp(t-&gt;base_ctx)) {
        // we get here to remove our data from the process stack
        switch_stack(jl_current_task, jl_jmp_target);
    }
#endif
    if (n_args_in_transit == 0) {
        res = jl_apply(t-&gt;start, NULL, 0);
    }
    else if (n_args_in_transit == 1) {
        res = jl_apply(t-&gt;start, &amp;arg, 1);
    }
    else {
        assert(jl_is_tuple(jl_task_arg_in_transit));
        res = jl_apply(t-&gt;start, &amp;jl_tupleref(jl_task_arg_in_transit,0),
                       n_args_in_transit);
    }
    JL_GC_POP();
    finish_task(t, res);
    jl_task_t *cont = t-&gt;on_exit;
    // if parent task has exited, try its parent, and so on
    while (cont-&gt;done==jl_true)
        cont = cont-&gt;on_exit;
    jl_switchto(cont, t-&gt;result);
    assert(0);
}
</t>
<t tx="ekr.20120404123906.8042">
#ifndef COPY_STACKS
</t>
<t tx="ekr.20120404123906.8043">static void init_task(jl_task_t *t)
{
    if (setjmp(t-&gt;ctx)) {
        start_task(t);
    }
    // this runs when the task is created
    ptrint_t local_sp = (ptrint_t)&amp;t;
    ptrint_t new_sp = (ptrint_t)t-&gt;stack + t-&gt;ssize - _frame_offset;
#ifdef __LP64__
    // SP must be 16-byte aligned
    new_sp = new_sp&amp;-16;
    local_sp = local_sp&amp;-16;
#endif
    memcpy((void*)new_sp, (void*)local_sp, _frame_offset);
    rebase_state(&amp;t-&gt;ctx, local_sp, new_sp);
}
</t>
<t tx="ekr.20120404123906.8044">#endif

void getFunctionInfo(char **name, int *line, const char **filename, size_t pointer);

</t>
<t tx="ekr.20120404123906.8045">static void push_frame_info_from_ip(jl_array_t *a, size_t ip)
{
    char *func_name;
    int line_num;
    const char *file_name;
    int i = jl_array_len(a);
    getFunctionInfo(&amp;func_name, &amp;line_num, &amp;file_name, ip);
    if (func_name != NULL) {
        jl_array_grow_end(a, 3);
        jl_arrayset(a, i, (jl_value_t*)jl_symbol(func_name)); i++;
        jl_arrayset(a, i, (jl_value_t*)jl_symbol(file_name)); i++;
        jl_arrayset(a, i, jl_box_long(line_num));
    }
}
</t>
<t tx="ekr.20120404123906.8046">
#if defined(__APPLE__)
// stacktrace using execinfo
</t>
<t tx="ekr.20120404123906.8047">static jl_value_t *build_backtrace(void)
{
    void *array[1024];
    size_t ip;
    size_t *p;
    jl_array_t *a;
    a = jl_alloc_cell_1d(0);
    JL_GC_PUSH(&amp;a);
    
    backtrace(array, 1023);
    p = (size_t*)array;
    while ((ip = *(p++)) != 0) {
        push_frame_info_from_ip(a, ip);
    }
    JL_GC_POP();
    return (jl_value_t*)a;
}
</t>
<t tx="ekr.20120404123906.8048">#else
// stacktrace using libunwind
</t>
<t tx="ekr.20120404123906.8049">static jl_value_t *build_backtrace(void)
{
    unw_cursor_t cursor; unw_context_t uc;
    unw_word_t ip;
    jl_array_t *a;
    size_t n=0;
    a = jl_alloc_cell_1d(0);
    JL_GC_PUSH(&amp;a);
    
    unw_getcontext(&amp;uc);
    unw_init_local(&amp;cursor, &amp;uc);
    while (unw_step(&amp;cursor) &amp;&amp; n &lt; 10000) { 
        unw_get_reg(&amp;cursor, UNW_REG_IP, &amp;ip);
        push_frame_info_from_ip(a, ip);
        n++;
    }
    JL_GC_POP();
    return (jl_value_t*)a;
}
</t>
<t tx="ekr.20120404123906.8050">#endif

</t>
<t tx="ekr.20120404123906.8051">DLLEXPORT void jl_register_toplevel_eh(void)
{
    jl_current_task-&gt;state.eh_task-&gt;state.bt = 1;
}
</t>
<t tx="ekr.20120404123906.8052">
// yield to exception handler
</t>
<t tx="ekr.20120404123906.8053">void jl_raise(jl_value_t *e)
{
    jl_task_t *eh = jl_current_task-&gt;state.eh_task;
    eh-&gt;state.err = 1;
    jl_exception_in_transit = e;
    if (eh-&gt;state.bt) {
        jl_value_t *tracedata, *bt;
        tracedata = build_backtrace();
        JL_GC_PUSH(&amp;tracedata);
        bt = jl_new_struct(jl_backtrace_type,
                           jl_exception_in_transit, tracedata);
        jl_exception_in_transit = bt;
        JL_GC_POP();
    }
    if (jl_current_task == eh) {
        longjmp(*eh-&gt;state.eh_ctx, 1);
    }
    else {
        if (eh-&gt;done==jl_true || eh-&gt;state.eh_ctx==NULL) {
            // our handler is not available, use root task
            ios_printf(ios_stderr, "warning: exception handler exited\n");
            eh = jl_root_task;
        }
        // for now, exit the task
        finish_task(jl_current_task, e);
        ctx_switch(eh, eh-&gt;state.eh_ctx);
        // TODO: continued exception
    }
}
</t>
<t tx="ekr.20120404123906.8054">
jl_task_t *jl_new_task(jl_function_t *start, size_t ssize)
{
    size_t pagesz = jl_page_size;
    jl_task_t *t = (jl_task_t*)allocobj(sizeof(jl_task_t));
    t-&gt;type = (jl_type_t*)jl_task_type;
    ssize = LLT_ALIGN(ssize, pagesz);
    t-&gt;ssize = ssize;
    t-&gt;on_exit = jl_current_task;
    t-&gt;tls = jl_current_task-&gt;tls;
    t-&gt;done = jl_false;
    t-&gt;start = start;
    t-&gt;result = NULL;
    t-&gt;state.err = 0;
    t-&gt;state.bt = 0;
    t-&gt;state.eh_task = jl_current_task-&gt;state.eh_task;
    // there is no active exception handler available on this stack yet
    t-&gt;state.eh_ctx = NULL;
    t-&gt;state.ostream_obj = jl_current_task-&gt;state.ostream_obj;
    t-&gt;state.current_output_stream = jl_current_task-&gt;state.current_output_stream;
    t-&gt;state.prev = NULL;
#ifdef JL_GC_MARKSWEEP
    t-&gt;state.gcstack = NULL;
#endif
    t-&gt;stkbuf = NULL;

#ifdef COPY_STACKS
    t-&gt;bufsz = 0;
#else
    JL_GC_PUSH(&amp;t);

    char *stk = allocb(ssize+pagesz+(pagesz-1));
    t-&gt;stkbuf = stk;
    stk = (char*)LLT_ALIGN((uptrint_t)stk, pagesz);
    // add a guard page to detect stack overflow
    // the GC might read this area, which is ok, just prevent writes
    if (mprotect(stk, pagesz-1, PROT_READ) == -1)
        jl_errorf("mprotect: %s", strerror(errno));
    t-&gt;stack = stk+pagesz;

    init_task(t);
    JL_GC_POP();
    jl_gc_add_finalizer((jl_value_t*)t, jl_unprotect_stack_func);
#endif

    return t;
}
</t>
<t tx="ekr.20120404123906.8055">
JL_CALLABLE(jl_unprotect_stack)
{
#ifndef COPY_STACKS
    jl_task_t *t = (jl_task_t*)args[0];
    char *stk = t-&gt;stack-jl_page_size;
    // unprotect stack so it can be reallocated for something else
    mprotect(stk, jl_page_size-1, PROT_READ|PROT_WRITE|PROT_EXEC);
#endif
    return (jl_value_t*)jl_null;
}
</t>
<t tx="ekr.20120404123906.8056">
#define JL_MIN_STACK     (4096*sizeof(void*))
#define JL_DEFAULT_STACK (2*12288*sizeof(void*))

</t>
<t tx="ekr.20120404123906.8057">JL_CALLABLE(jl_f_task)
{
    JL_NARGS(Task, 1, 2);
    JL_TYPECHK(Task, function, args[0]);
    /*
      we need a somewhat large stack, because execution can trigger
      compilation, which uses perhaps too much stack space.
    */
    size_t ssize = JL_DEFAULT_STACK;
    if (nargs == 2) {
        JL_TYPECHK(Task, long, args[1]);
        ssize = jl_unbox_long(args[1]);
        if (ssize &lt; JL_MIN_STACK)
            jl_error("Task: stack size too small");
    }
    return (jl_value_t*)jl_new_task((jl_function_t*)args[0], ssize);
}
</t>
<t tx="ekr.20120404123906.8058">
JL_CALLABLE(jl_f_yieldto)
{
    JL_NARGSV(yieldto, 1);
    JL_TYPECHK(yieldto, task, args[0]);
    n_args_in_transit = nargs-1;
    if (nargs == 2) {
        jl_task_arg_in_transit = args[1];
    }
    else if (nargs &gt; 2) {
        jl_task_arg_in_transit = jl_f_tuple(NULL, &amp;args[1], n_args_in_transit);
    }
    else {
        jl_task_arg_in_transit = (jl_value_t*)jl_null;
    }
    return switchto((jl_task_t*)args[0]);
}
</t>
<t tx="ekr.20120404123906.8059">
DLLEXPORT jl_value_t *jl_get_current_task(void)
{
    return (jl_value_t*)jl_current_task;
}
</t>
<t tx="ekr.20120404123906.8060">
jl_function_t *jl_unprotect_stack_func;

</t>
<t tx="ekr.20120404123906.8061">void jl_init_tasks(void *stack, size_t ssize)
{
    _probe_arch();
    jl_task_type = jl_new_struct_type(jl_symbol("Task"), jl_any_type,
                                      jl_null,
                                      jl_tuple(3, jl_symbol("parent"),
                                               jl_symbol("tls"),
                                               jl_symbol("done")),
                                      jl_tuple(3, jl_any_type, jl_any_type,
                                               jl_bool_type));
    jl_tupleset(jl_task_type-&gt;types, 0, (jl_value_t*)jl_task_type);
    jl_task_type-&gt;fptr = jl_f_task;

    jl_current_task = (jl_task_t*)allocobj(sizeof(jl_task_t));
    jl_current_task-&gt;type = (jl_type_t*)jl_task_type;
#ifdef COPY_STACKS
    jl_current_task-&gt;stackbase = stack+ssize;
    jl_current_task-&gt;ssize = 0;  // size of saved piece
    jl_current_task-&gt;bufsz = 0;
#else
    jl_current_task-&gt;stack = stack;
    jl_current_task-&gt;ssize = ssize;
#endif
    jl_current_task-&gt;stkbuf = NULL;
    jl_current_task-&gt;on_exit = jl_current_task;
    jl_current_task-&gt;tls = NULL;
    jl_current_task-&gt;done = jl_false;
    jl_current_task-&gt;start = NULL;
    jl_current_task-&gt;result = NULL;
    jl_current_task-&gt;state.err = 0;
    jl_current_task-&gt;state.bt = 0;
    jl_current_task-&gt;state.eh_task = jl_current_task;
    jl_current_task-&gt;state.eh_ctx = NULL;
    jl_current_task-&gt;state.ostream_obj = (jl_value_t*)jl_null;
    jl_current_task-&gt;state.current_output_stream = ios_stdout;
    jl_current_task-&gt;state.prev = NULL;
#ifdef JL_GC_MARKSWEEP
    jl_current_task-&gt;state.gcstack = NULL;
#endif

    jl_root_task = jl_current_task;

    jl_exception_in_transit = (jl_value_t*)jl_null;
    jl_task_arg_in_transit = (jl_value_t*)jl_null;
    jl_unprotect_stack_func = jl_new_closure(jl_unprotect_stack, (jl_value_t*)jl_null, NULL);
}
</t>
<t tx="ekr.20120404123906.8062">@language unknown_language
(define (prn x)
  (with-output-to *stderr*
		  (display x) (newline))
  x)

(define (lookup elt alst default)
  (let ((a (assq elt alst)))
    (if a (cdr a) default)))

(define (index-p pred lst start)
  (cond ((null? lst) #f)
	((pred (car lst)) start)
	(else (index-p pred (cdr lst) (+ start 1)))))

(define (diff s1 s2)
  (cond ((null? s1)         '())
        ((memq (car s1) s2) (diff (cdr s1) s2))
        (else               (cons (car s1) (diff (cdr s1) s2)))))

(define (unique lst)
  (if (null? lst)
      '()
      (if (memq (car lst) (cdr lst))
	  (unique (cdr lst))
	  (cons (car lst) (unique (cdr lst))))))

(define (contains p expr)
  (or (p expr)
      (and (pair? expr)
	   (any (lambda (x) (contains p x))
		expr))))

(define *gensyms* '())
(define *current-gensyms* '())
(define (gensy)
  (if (null? *current-gensyms*)
      (let ((g (gensym)))
	(set! *gensyms* (cons g *gensyms*))
	g)
      (begin0 (car *current-gensyms*)
	      (set! *current-gensyms* (cdr *current-gensyms*)))))
(define (reset-gensyms)
  (set! *current-gensyms* *gensyms*))
</t>
<t tx="ekr.20120404123906.8063">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20120404123906.8064">/*
  Types
  . type predicates (subtype) and type matching
  . type union and intersection
  . builtin type definitions
*/
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "julia.h"
#include "newobj_internal.h"
#include "jltypes_internal.h"
#include "builtin_proto.h"

jl_tag_type_t *jl_any_type;
jl_tag_type_t *jl_type_type;
jl_struct_type_t *jl_typename_type;
jl_struct_type_t *jl_sym_type;
jl_struct_type_t *jl_symbol_type;
jl_tuple_t *jl_tuple_type;
jl_tag_type_t *jl_ntuple_type;
jl_typename_t *jl_ntuple_typename;
jl_struct_type_t *jl_tvar_type;

jl_struct_type_t *jl_union_kind;
jl_struct_type_t *jl_tag_kind;
jl_struct_type_t *jl_tag_type_type;
jl_struct_type_t *jl_struct_kind;
jl_struct_type_t *jl_bits_kind;

jl_type_t *jl_bottom_type;
jl_value_t *jl_top_type;
jl_tag_type_t *jl_seq_type;
jl_tag_type_t *jl_abstractarray_type;

jl_bits_type_t *jl_bool_type;
jl_bits_type_t *jl_char_type;
jl_bits_type_t *jl_int8_type;
jl_bits_type_t *jl_uint8_type;
jl_bits_type_t *jl_int16_type;
jl_bits_type_t *jl_uint16_type;
jl_bits_type_t *jl_int32_type;
jl_bits_type_t *jl_uint32_type;
jl_bits_type_t *jl_int64_type;
jl_bits_type_t *jl_uint64_type;
jl_bits_type_t *jl_float32_type;
jl_bits_type_t *jl_float64_type;

jl_tuple_t *jl_null;
jl_value_t *jl_nothing;

void jl_add_constructors(jl_struct_type_t *t);

static jl_value_t *
jl_type_intersect(
    jl_value_t *a, jl_value_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var);

static int type_eqv_(jl_value_t *a, jl_value_t *b);


</t>
<t tx="ekr.20120404123906.8065">// type properties and predicates.

</t>
<t tx="ekr.20120404123906.8066">int jl_is_type(jl_value_t *v)
{
    if (jl_is_tuple(v)) {
        jl_tuple_t *t = (jl_tuple_t*)v;
        size_t i;
        for(i=0; i &lt; t-&gt;length; i++) {
            jl_value_t *vv = jl_tupleref(t, i);
            if (!jl_is_typevar(vv) &amp;&amp; !jl_is_type(vv) &amp;&amp;
                !jl_is_typector(vv))
                return 0;
        }
        return 1;
    }
    return jl_is_nontuple_type(v);
}
</t>
<t tx="ekr.20120404123906.8067">int jl_has_typevars_(jl_value_t *v, int incl_wildcard)
{
    size_t i;
    if (jl_typeis(v, jl_tvar_type)) {
        if (!((jl_tvar_t*)v)-&gt;bound)
            return incl_wildcard;
        return 1;
    }
    jl_tuple_t *t;
    if (jl_is_union_type(v))
        t = ((jl_uniontype_t*)v)-&gt;types;
    else if (jl_is_some_tag_type(v))
        t = ((jl_tag_type_t*)v)-&gt;parameters;
    else if (jl_is_tuple(v))
        t = (jl_tuple_t*)v;
    else
        t = jl_null;
    for(i=0; i &lt; t-&gt;length; i++) {
        jl_value_t *elt = jl_tupleref(t, i);
        if (elt != v) {
            if (jl_has_typevars_(elt, incl_wildcard))
                return 1;
        }
    }
    // probably not necessary; no reason to use match() instead of subtype()
    // on the unconstrained version of a type
    //if (jl_is_typector(v))
    //    return (((jl_typector_t*)v)-&gt;parameters-&gt;length &gt; 0);
    return 0;
}
</t>
<t tx="ekr.20120404123906.8068">int jl_has_typevars(jl_value_t *v)
{
    return jl_has_typevars_(v, 0);
}
</t>
<t tx="ekr.20120404123906.8069">DLLEXPORT int jl_is_leaf_type(jl_value_t *v)
{
    if (jl_is_struct_type(v) || jl_is_bits_type(v)) {
        jl_tuple_t *t = ((jl_tag_type_t*)v)-&gt;parameters;
        for(int i=0; i &lt; t-&gt;length; i++) {
            if (jl_is_typevar(jl_tupleref(t,i)))
                return 0;
        }
        return 1;
    }
    if (jl_is_tuple(v)) {
        jl_tuple_t *t = (jl_tuple_t*)v;
        for(int i=0; i &lt; t-&gt;length; i++) {
            if (!jl_is_leaf_type(jl_tupleref(t, i)))
                return 0;
        }
        return 1;
    }
    if (jl_is_type_type(v)) {
        return !jl_is_typevar(jl_tparam0(v));
    }
    return 0;
}
</t>
<t tx="ekr.20120404123906.8070">// construct the full type of a value, possibly making a tuple type

jl_value_t *jl_full_type(jl_value_t *v)
{
    if (!jl_is_tuple(v))
        return (jl_value_t*)jl_typeof(v);
    jl_tuple_t *in = (jl_tuple_t*)v;
    jl_tuple_t *out = jl_alloc_tuple(in-&gt;length);
    JL_GC_PUSH(&amp;out);
    size_t i;
    for(i=0; i &lt; in-&gt;length; i++) {
        jl_tupleset(out, i, jl_full_type(jl_tupleref(in, i)));
    }
    JL_GC_POP();
    return (jl_value_t*)out;
}
</t>
<t tx="ekr.20120404123906.8072">// --- type union ---</t>
<t tx="ekr.20120404123906.8073">static int count_union_components(jl_tuple_t *types)
{
    size_t i, c=0;
    for(i=0; i &lt; types-&gt;length; i++) {
        jl_value_t *e = jl_tupleref(types,i);
        if (jl_is_union_type(e)) {
            c += count_union_components(((jl_uniontype_t*)e)-&gt;types);
        }
        else {
            c++;
        }
    }
    return c;
}
</t>
<t tx="ekr.20120404123906.8074">static void flatten_type_union(jl_tuple_t *types, jl_value_t **out, size_t *idx)
{
    size_t i;
    for(i=0; i &lt; types-&gt;length; i++) {
        jl_value_t *e = jl_tupleref(types,i);
        if (jl_is_union_type(e)) {
            flatten_type_union(((jl_uniontype_t*)e)-&gt;types, out, idx);
        }
        else {
            out[*idx] = e;
            (*idx)++;
        }
    }
}
</t>
<t tx="ekr.20120404123906.8075">static int union_elt_morespecific(const void *a, const void *b)
{
    return jl_args_morespecific(*(jl_value_t**)a, *(jl_value_t**)b) ? -1 : 1;
}
</t>
<t tx="ekr.20120404123906.8076">DLLEXPORT
jl_tuple_t *jl_compute_type_union(jl_tuple_t *types)
{
    size_t n = count_union_components(types);
    jl_value_t **temp = alloca(n * sizeof(jl_value_t*));
    size_t idx=0;
    flatten_type_union(types, temp, &amp;idx);
    JL_GC_PUSHARGS(temp, n);
    assert(idx == n);
    size_t i, j, ndel=0;
    for(i=0; i &lt; n; i++) {
        for(j=0; j &lt; n; j++) {
            if (j != i &amp;&amp; temp[i] &amp;&amp; temp[j]) {
                if (temp[i] == temp[j] ||
                    (!jl_has_typevars(temp[i]) &amp;&amp;
                     !jl_has_typevars(temp[j]) &amp;&amp;
                     (type_eqv_(temp[i], temp[j]) ||
                      jl_subtype(temp[i], temp[j], 0)))) {
                    temp[i] = NULL;
                    ndel++;
                }
            }
        }
    }
    jl_tuple_t *result = jl_alloc_tuple_uninit(n - ndel);
    j=0;
    for(i=0; i &lt; n; i++) {
        if (temp[i] != NULL) {
            jl_tupleset(result, j, temp[i]);
            j++;
        }
    }
    assert(j == n-ndel);
    // TODO: maybe warn about ambiguities
    qsort(result-&gt;data, j, sizeof(jl_value_t*), union_elt_morespecific);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.8077">jl_value_t *
jl_type_union(jl_tuple_t *types)
{
    types = jl_compute_type_union(types);
    if (types-&gt;length == 1)
        return jl_tupleref(types, 0);
    if (types-&gt;length == 0)
        return (jl_value_t*)jl_bottom_type;
    JL_GC_PUSH(&amp;types);
    jl_value_t *tu = (jl_value_t*)jl_new_uniontype(types);
    JL_GC_POP();
    return tu;
}
</t>
<t tx="ekr.20120404123906.8078">// --- type intersection ---

typedef enum {invariant, covariant} variance_t;

typedef struct {
    jl_value_t *data[128];
    size_t n;
} cenv_t;

</t>
<t tx="ekr.20120404123906.8079">static void extend(jl_value_t *var, jl_value_t *val, cenv_t *soln)
{
    extend_(var, val, soln, 0);
}
</t>
<t tx="ekr.20120404123906.8080">static void extend_(jl_value_t *var, jl_value_t *val, cenv_t *soln, int allow)
{
    if (!allow &amp;&amp; var == val)
        return;
    for(int i=0; i &lt; soln-&gt;n; i+=2) {
        if (soln-&gt;data[i]==var &amp;&amp;
            (soln-&gt;data[i+1]==val || (!jl_is_typevar(val) &amp;&amp;
                                      type_eqv_(soln-&gt;data[i+1],val))))
            return;
    }
    if (soln-&gt;n &gt;= sizeof(soln-&gt;data)/sizeof(void*))
        jl_error("type too large");
    soln-&gt;data[soln-&gt;n++] = var;
    soln-&gt;data[soln-&gt;n++] = val;
}
</t>
<t tx="ekr.20120404123906.8100">
// --- type instantiation and cache ---

</t>
<t tx="ekr.20120404123906.8101">static int extensionally_same_type(jl_value_t *a, jl_value_t *b)
{
    return jl_subtype(a, b, 0) &amp;&amp; jl_subtype(b, a, 0);
}
</t>
<t tx="ekr.20120404123906.8102">
static int type_eqv_(jl_value_t *a, jl_value_t *b)
{
    if (a == b) return 1;
    if (jl_is_typector(a)) a = (jl_value_t*)((jl_typector_t*)a)-&gt;body;
    if (jl_is_typector(b)) b = (jl_value_t*)((jl_typector_t*)b)-&gt;body;
    if (jl_is_typevar(a)) {
        if (jl_is_typevar(b)) {
            return type_eqv_(((jl_tvar_t*)a)-&gt;ub, ((jl_tvar_t*)b)-&gt;ub) &amp;&amp;
                type_eqv_(((jl_tvar_t*)a)-&gt;lb, ((jl_tvar_t*)b)-&gt;lb);
        }
        else {
            return 0;
        }
    }
    if (jl_is_long(a)) {
        if (jl_is_long(b))
            return (jl_unbox_long(a) == jl_unbox_long(b));
        return 0;
    }
    if (jl_is_tuple(a)) {
        if (jl_is_tuple(b)) {
            jl_tuple_t *ta = (jl_tuple_t*)a; jl_tuple_t *tb = (jl_tuple_t*)b;
            int sqa = (ta-&gt;length&gt;0 &amp;&amp;
                       jl_is_seq_type(jl_tupleref(ta,ta-&gt;length-1)));
            int sqb = (tb-&gt;length&gt;0 &amp;&amp;
                       jl_is_seq_type(jl_tupleref(tb,tb-&gt;length-1)));
            if (sqa &amp;&amp; sqb)
                return extensionally_same_type(a, b);
            if (sqa != sqb || ta-&gt;length != tb-&gt;length)
                return 0;
            for(int i=0; i &lt; ta-&gt;length; i++) {
                if (!type_eqv_(jl_tupleref(ta,i),jl_tupleref(tb,i)))
                    return 0;
            }
            return 1;
        }
        return 0;
    }
    if (jl_is_union_type(a)) {
        if (jl_is_union_type(b)) {
            return extensionally_same_type(a, b);
        }
        return 0;
    }
    assert(jl_is_some_tag_type(a));
    if (!jl_is_some_tag_type(b)) return 0;
    jl_tag_type_t *tta = (jl_tag_type_t*)a;
    jl_tag_type_t *ttb = (jl_tag_type_t*)b;
    if (tta-&gt;name != ttb-&gt;name) return 0;
    jl_tuple_t *ap = tta-&gt;parameters;
    jl_tuple_t *bp = ttb-&gt;parameters;
    assert(ap-&gt;length == bp-&gt;length);
    size_t i;
    for(i=0; i &lt; ap-&gt;length; i++) {
        jl_value_t *api = jl_tupleref(ap,i);
        jl_value_t *bpi = jl_tupleref(bp,i);
        if (api == bpi) continue;
        if (!type_eqv_(api, bpi))
            return 0;
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.8103">
int jl_types_equal(jl_value_t *a, jl_value_t *b)
{
    return type_eqv_(a, b);
}
</t>
<t tx="ekr.20120404123906.8104">
static int type_le_generic(jl_value_t *a, jl_value_t *b)
{
    jl_value_t *env = jl_type_match(a, b);
    if (env == jl_false) return 0;
    // make sure all typevars correspond to other unique typevars
    for(int i=0; i &lt; ((jl_tuple_t*)env)-&gt;length; i+=2) {
        if (!jl_is_typevar(jl_tupleref(env,i+1)))
            return 0;
        for(int j=0; j &lt; ((jl_tuple_t*)env)-&gt;length; j+=2) {
            if (i != j) {
                if (jl_tupleref(env,i+1) == jl_tupleref(env,j+1))
                    return 0;
            }
        }
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.8105">
int jl_types_equal_generic(jl_value_t *a, jl_value_t *b)
{
    return type_le_generic(a, b) &amp;&amp; type_le_generic(b, a);
}
</t>
<t tx="ekr.20120404123906.8106">
jl_value_t *jl_apply_type_(jl_value_t *tc, jl_value_t **params, size_t n)
{
    if (n == 0) {
        if (jl_is_typector(tc))
            return (jl_value_t*)((jl_typector_t*)tc)-&gt;body;
        return tc;
    }
    size_t i;
    char *tname;
    jl_tuple_t *tp;
    if (jl_is_typector(tc)) {
        tp = ((jl_typector_t*)tc)-&gt;parameters;
        tname = "alias";
    }
    else {
        assert(jl_is_some_tag_type(tc));
        tp = ((jl_tag_type_t*)tc)-&gt;parameters;
        tname = ((jl_tag_type_t*)tc)-&gt;name-&gt;name-&gt;name;
    }
    for(i=0; i &lt; n; i++) {
        jl_value_t *pi = params[i];
        if (!jl_is_type(pi) &amp;&amp; !jl_is_long(pi) &amp;&amp; !jl_is_typevar(pi)) {
            jl_type_error_rt("apply_type", tname,
                             (jl_value_t*)jl_type_type, pi);
        }
    }
    if (tc == (jl_value_t*)jl_ntuple_type &amp;&amp; (n==1||n==2) &amp;&amp;
        jl_is_long(params[0])) {
        size_t nt = jl_unbox_long(params[0]);
        return (jl_value_t*)jl_tuple_fill(nt, (n==2) ? params[1] :
                                          (jl_value_t*)jl_any_type);
    }
    if (n &gt; tp-&gt;length)
        jl_errorf("too many parameters for type %s", tname);
    jl_value_t **env = alloca(2 * tp-&gt;length * sizeof(jl_value_t*));
    size_t ne = 0;
    for(i=0; i &lt; tp-&gt;length; i++) {
        jl_tvar_t *tv = (jl_tvar_t*)jl_tupleref(tp,i);
        if (!jl_is_typevar(tv))
            continue;
        env[ne*2+0] = (jl_value_t*)tv;
        if (i &gt;= n) {
            env[ne*2+1] = (jl_value_t*)tv;
        }
        else {
            // NOTE: type checking deferred to inst_type_w_ to make sure
            // supertype parameters are checked recursively.
            if (jl_is_typector(params[i]))
                env[ne*2+1] = (jl_value_t*)((jl_typector_t*)params[i])-&gt;body;
            else
                env[ne*2+1] = params[i];
        }
        ne++;
    }
    if (jl_is_typector(tc)) tc = (jl_value_t*)((jl_typector_t*)tc)-&gt;body;
    return (jl_value_t*)jl_instantiate_type_with((jl_type_t*)tc, env, ne);
}
</t>
<t tx="ekr.20120404123906.8107">
jl_value_t *jl_apply_type(jl_value_t *tc, jl_tuple_t *params)
{
    return jl_apply_type_(tc, &amp;jl_tupleref(params,0), params-&gt;length);
}
</t>
<t tx="ekr.20120404123906.8108">static jl_type_t *lookup_type(jl_tuple_t *table,
                              jl_typename_t *tn, jl_value_t **key, size_t n)
{
    if (n==0) return NULL;
    while (table != jl_null) {
        jl_tag_type_t *tt = (jl_tag_type_t*)jl_t0(table);
        if (tt-&gt;name == tn &amp;&amp; n == tt-&gt;parameters-&gt;length) {
            size_t i;
            for(i=0; i &lt; n; i++) {
                if (!type_eqv_(jl_tupleref(tt-&gt;parameters,i), key[i]))
                    break;
            }
            if (i==n) return (jl_type_t*)tt;
        }
        table = (jl_tuple_t*)jl_t1(table);
    }
    return NULL;
}
</t>
<t tx="ekr.20120404123906.8109">
static int t_uid_ctr = 1;  // TODO: lock

</t>
<t tx="ekr.20120404123906.8110">int  jl_get_t_uid_ctr(void) { return t_uid_ctr; }
</t>
<t tx="ekr.20120404123906.8111">void jl_set_t_uid_ctr(int i) { t_uid_ctr=i; }
</t>
<t tx="ekr.20120404123906.8112">int jl_assign_type_uid(void)
{
    return t_uid_ctr++;
}
</t>
<t tx="ekr.20120404123906.8113">// TODO: synchronize

static void cache_type_(jl_type_t *type)
{
    // only cache concrete types
    jl_tuple_t *t = ((jl_tag_type_t*)type)-&gt;parameters;
    if (t-&gt;length == 0) return;
    if (jl_is_tag_type(type)) {
        if (jl_has_typevars_((jl_value_t*)type,1))
            return;
    }
    else {
        for(int i=0; i &lt; t-&gt;length; i++) {
            if (jl_is_typevar(jl_tupleref(t,i)))
                return;
        }
    }
    // assign uid
    if (jl_is_struct_type(type) &amp;&amp; ((jl_struct_type_t*)type)-&gt;uid==0)
        ((jl_struct_type_t*)type)-&gt;uid = jl_assign_type_uid();
    else if (jl_is_bits_type(type) &amp;&amp; ((jl_bits_type_t*)type)-&gt;uid==0)
        ((jl_bits_type_t*)type)-&gt;uid = jl_assign_type_uid();
    jl_tuple_t *tc = ((jl_tag_type_t*)type)-&gt;name-&gt;cache;
    ((jl_tag_type_t*)type)-&gt;name-&gt;cache = jl_tuple2(type, tc);
}
</t>
<t tx="ekr.20120404123906.8114">void jl_cache_type_(jl_tag_type_t *type)
{
    cache_type_((jl_type_t*)type);
}
</t>
<t tx="ekr.20120404123906.8115">JL_CALLABLE(jl_f_tuple);
JL_CALLABLE(jl_f_ctor_trampoline);

</t>
<t tx="ekr.20120404123906.8116">static jl_type_t *inst_type_w_(jl_value_t *t, jl_value_t **env, size_t n,
                               jl_tuple_t *stack)
{
    jl_tuple2_t top;
    size_t i;
    if (n == 0) return (jl_type_t*)t;
    if (jl_is_typevar(t)) {
        for(i=0; i &lt; n; i++) {
            if (env[i*2] == t)
                return (jl_type_t*)env[i*2+1];
        }
        return (jl_type_t*)t;
    }
    if (jl_is_tuple(t)) {
        jl_tuple_t *p = (jl_tuple_t*)t;
        jl_tuple_t *nt = jl_alloc_tuple(p-&gt;length);
        JL_GC_PUSH(&amp;nt);
        for(i=0; i &lt; p-&gt;length; i++) {
            jl_tupleset(nt, i, (jl_value_t*)inst_type_w_(jl_tupleref(p,i), env, n, stack));
        }
        JL_GC_POP();
        return (jl_type_t*)nt;
    }
    if (jl_is_union_type(t)) {
        jl_tuple_t *tw = (jl_tuple_t*)inst_type_w_((jl_value_t*)((jl_uniontype_t*)t)-&gt;types,
                                                   env, n, stack);
        JL_GC_PUSH(&amp;tw);
        jl_type_t *res = (jl_type_t*)jl_new_uniontype(tw);
        JL_GC_POP();
        return res;
    }
    if (jl_is_some_tag_type(t)) {
        jl_tag_type_t *tt = (jl_tag_type_t*)t;
        jl_tuple_t *tp = tt-&gt;parameters;
        if (jl_is_null(tp))
            return (jl_type_t*)t;
        jl_typename_t *tn = tt-&gt;name;
        jl_value_t *tc = tn-&gt;primary;
        jl_type_t *result;
        size_t ntp = tp-&gt;length;
        assert(ntp == ((jl_tag_type_t*)tc)-&gt;parameters-&gt;length);
        jl_value_t **iparams = (jl_value_t**)alloca((ntp+2) * sizeof(void*));
        for(i=0; i &lt; ntp+2; i++) iparams[i] = NULL;
        jl_value_t **rt1 = &amp;iparams[ntp+0];  // some extra gc roots
        jl_value_t **rt2 = &amp;iparams[ntp+1];
        JL_GC_PUSHARGS(iparams, ntp+2);
        for(i=0; i &lt; ntp; i++) {
            jl_value_t *elt = jl_tupleref(tp, i);
            if (elt == t) {
                iparams[i] = t;
            }
            else {
                iparams[i] = (jl_value_t*)inst_type_w_(elt, env, n, stack);
                jl_value_t *tv =
                    jl_tupleref(((jl_tag_type_t*)tc)-&gt;parameters, i);
                if (jl_is_typevar(tv) &amp;&amp; !jl_is_typevar(iparams[i])) {
                    // TODO: Undef should not be special here; fix.
                    // maybe introduce Top == Union(Any,Undef), and make this
                    // the default upper bound.
                    if (!jl_subtype(iparams[i], tv, 0)) {
                        jl_type_error_rt(tt-&gt;name-&gt;name-&gt;name,
                                         ((jl_tvar_t*)tv)-&gt;name-&gt;name,
                                         ((jl_tvar_t*)tv)-&gt;ub,
                                         iparams[i]);
                    }
                }
            }
        }

        // if an identical instantiation is already in process somewhere
        // up the stack, return it. this computes a fixed point for
        // recursive types.
        jl_type_t *lkup = lookup_type(stack, tn, iparams, ntp);
        if (lkup != NULL) { result = lkup; goto done_inst_tt; }

        // check type cache
        lkup = lookup_type(tn-&gt;cache, tn, iparams, ntp);
        if (lkup != NULL) { result = lkup; goto done_inst_tt; }

        // always use original type constructor
        if (tc != t) {
            //(tc != NULL &amp;&amp; tc != t)
            result = (jl_type_t*)jl_apply_type_(tc, iparams, ntp);
            goto done_inst_tt;
        }

        // move array of instantiated parameters to heap; we need to keep it
        jl_tuple_t *iparams_tuple = jl_alloc_tuple_uninit(ntp);
        for(i=0; i &lt; ntp; i++)
            jl_tupleset(iparams_tuple, i, iparams[i]);
        *rt1 = (jl_value_t*)iparams_tuple;
        if (jl_is_tag_type(t)) {
            jl_tag_type_t *tagt = (jl_tag_type_t*)t;
            jl_tag_type_t *ntt =
                (jl_tag_type_t*)newobj((jl_type_t*)jl_tag_kind, TAG_TYPE_NW);
            *rt2 = (jl_value_t*)ntt;
            top.data[0] = (jl_value_t*)ntt;
            top.data[1] = (jl_value_t*)stack;
            stack = (jl_tuple_t*)&amp;top;
            ntt-&gt;name = tn;
            // temporarily initialize all fields so object is valid during
            // allocation of other objects (possible GC)
            ntt-&gt;fptr = NULL;
            ntt-&gt;env = NULL;
            ntt-&gt;linfo = NULL;
            ntt-&gt;super = jl_any_type;
            ntt-&gt;parameters = iparams_tuple;
            ntt-&gt;super = (jl_tag_type_t*)inst_type_w_((jl_value_t*)tagt-&gt;super,env,n,stack);
            cache_type_((jl_type_t*)ntt);
            result = (jl_type_t*)ntt;
        }
        else if (jl_is_bits_type(t)) {
            jl_bits_type_t *bitst = (jl_bits_type_t*)t;
            jl_bits_type_t *nbt =
                (jl_bits_type_t*)newobj((jl_type_t*)jl_bits_kind, BITS_TYPE_NW);
            *rt2 = (jl_value_t*)nbt;
            top.data[0] = (jl_value_t*)nbt;
            top.data[1] = (jl_value_t*)stack;
            stack = (jl_tuple_t*)&amp;top;
            nbt-&gt;name = tn;
            nbt-&gt;fptr = NULL;
            nbt-&gt;env = NULL;
            nbt-&gt;linfo = NULL;
            nbt-&gt;super = jl_any_type;
            nbt-&gt;parameters = iparams_tuple;
            nbt-&gt;nbits = bitst-&gt;nbits;
            nbt-&gt;bnbits = bitst-&gt;bnbits;
            nbt-&gt;super = (jl_tag_type_t*)inst_type_w_((jl_value_t*)bitst-&gt;super, env, n, stack);
            nbt-&gt;uid = 0;
            cache_type_((jl_type_t*)nbt);
            result = (jl_type_t*)nbt;
        }
        else {
            assert(jl_is_struct_type(t));
            jl_struct_type_t *st = (jl_struct_type_t*)t;
            // create and initialize new struct type
            jl_struct_type_t *nst =
                (jl_struct_type_t*)newobj((jl_type_t*)jl_struct_kind,
                                          STRUCT_TYPE_NW);
            *rt2 = (jl_value_t*)nst;
            // associate these parameters with the new struct type on
            // the stack, in case one of its field types references it.
            top.data[0] = (jl_value_t*)nst;
            top.data[1] = (jl_value_t*)stack;
            stack = (jl_tuple_t*)&amp;top;
            nst-&gt;name = tn;
            nst-&gt;super = jl_any_type;
            nst-&gt;parameters = iparams_tuple;
            nst-&gt;names = st-&gt;names;
            nst-&gt;types = jl_null; // to be filled in below
            nst-&gt;fptr = jl_f_ctor_trampoline;
            nst-&gt;env = (jl_value_t*)nst;
            nst-&gt;linfo = NULL;
            nst-&gt;ctor_factory = st-&gt;ctor_factory;
            nst-&gt;instance = NULL;
            nst-&gt;uid = 0;
            nst-&gt;super = (jl_tag_type_t*)inst_type_w_((jl_value_t*)st-&gt;super, env,n,stack);
            jl_tuple_t *ftypes = st-&gt;types;
            if (ftypes != NULL) {
                // recursively instantiate the types of the fields
                jl_tuple_t *nftypes = jl_alloc_tuple(ftypes-&gt;length);
                nst-&gt;types = nftypes;
                for(i=0; i &lt; ftypes-&gt;length; i++) {
                    jl_tupleset(nftypes, i,
                                (jl_value_t*)inst_type_w_(jl_tupleref(ftypes,i),
                                                          env,n,stack));
                }
            }
            cache_type_((jl_type_t*)nst);
            result = (jl_type_t*)nst;
        }
    done_inst_tt:
        JL_GC_POP();
        return result;
    }
    return (jl_type_t*)t;
}
</t>
<t tx="ekr.20120404123906.8117">jl_type_t *jl_instantiate_type_with(jl_type_t *t, jl_value_t **env, size_t n)
{
    return inst_type_w_((jl_value_t*)t, env, n, jl_null);
}
</t>
<t tx="ekr.20120404123906.8118">jl_tag_type_t *jl_wrap_Type(jl_value_t *t)
{
    jl_value_t *env[2];
    env[0] = jl_tparam0(jl_type_type);
    env[1] = t;
    return (jl_tag_type_t*)
        jl_instantiate_type_with((jl_type_t*)jl_type_type, env, 1);
}
</t>
<t tx="ekr.20120404123906.8119">void jl_reinstantiate_inner_types(jl_tag_type_t *t)
{
    jl_tuple2_t top;
    top.data[0] = (jl_value_t*)t;
    top.data[1] = (jl_value_t*)jl_null;
    size_t n = t-&gt;parameters-&gt;length;
    jl_value_t **env = alloca(n*2*sizeof(void*));
    for(int i=0; i &lt; n; i++) {
        env[i*2] = jl_tupleref(t-&gt;parameters,i);
        env[i*2+1] = env[i*2];
    }
    t-&gt;super = (jl_tag_type_t*)inst_type_w_((jl_value_t*)t-&gt;super, env, n, (jl_tuple_t*)&amp;top);
    if (jl_is_struct_type(t)) {
        jl_struct_type_t *st = (jl_struct_type_t*)t;
        st-&gt;types = (jl_tuple_t*)inst_type_w_((jl_value_t*)st-&gt;types, env, n, (jl_tuple_t*)&amp;top);
    }
}
</t>
<t tx="ekr.20120404123906.8120">static int jl_subtype_le(jl_value_t *a,jl_value_t *b,int ta,int morespecific,
                         int invariant);

</t>
<t tx="ekr.20120404123906.8121">static int jl_tuple_subtype_(jl_value_t **child, size_t cl,
                             jl_value_t **parent, size_t pl, int ta,
                             int morespecific, int invariant)
{
    size_t ci=0, pi=0;
    int mode = 0;
    while(1) {
        int cseq = !ta &amp;&amp; (ci&lt;cl) &amp;&amp; jl_is_seq_type(child[ci]);
        int pseq = (pi&lt;pl) &amp;&amp; jl_is_seq_type(parent[pi]);
        if ((!morespecific||mode) &amp;&amp; cseq &amp;&amp; !pseq)
            return mode;
        if (ci &gt;= cl)
            return (pi&gt;=pl || pseq);
        if (pi &gt;= pl)
            return 0;
        jl_value_t *ce = child[ci];
        jl_value_t *pe = parent[pi];
        if (cseq) ce = jl_tparam0(ce);
        if (pseq) pe = jl_tparam0(pe);

        if (!jl_subtype_le(ce, pe, ta, morespecific, invariant))
            return 0;

        if (morespecific) {
            // stop as soon as one element is strictly more specific
            if (!(jl_types_equal(ce,pe) ||
                  (jl_is_typevar(pe) &amp;&amp;
                   jl_types_equal(ce,((jl_tvar_t*)pe)-&gt;ub)))) {
                mode = 1;
                assert(!ta);
                // here go into a different mode where we return 1
                // if the only reason the child is not more specific is
                // argument count (i.e. ...)
            }
        }

        if (cseq &amp;&amp; pseq) return 1;
        if (!cseq) ci++;
        if (!pseq) pi++;
    }
    return 0;
}
</t>
<t tx="ekr.20120404123906.8122">int jl_tuple_subtype(jl_value_t **child, size_t cl,
                     jl_value_t **parent, size_t pl, int ta, int morespecific)
{
    return jl_tuple_subtype_(child, cl, parent, pl, ta, morespecific, 0);
}
</t>
<t tx="ekr.20120404123906.8123">static int tuple_all_subtype(jl_tuple_t *t, jl_value_t *super,
                             int ta, int morespecific, int invariant)
{
    size_t ci;
    for(ci=0; ci &lt; t-&gt;length; ci++) {
        jl_value_t *ce = jl_tupleref(t,ci);
        if (!ta &amp;&amp; jl_is_seq_type(ce))
            ce = jl_tparam0(ce);
        if (!jl_subtype_le(ce, super, ta, morespecific, invariant))
            return 0;
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.8124">/*
  ta specifies whether typeof() should be implicitly applied to a.
  this is used for tuple types to avoid allocating them explicitly.
  morespecific means we only care whether a is more specific than b,
  not necessarily a strict subtype
*/

static int jl_subtype_le(jl_value_t *a, jl_value_t *b, int ta, int morespecific,
                         int invariant)
{
    if (!ta&amp;&amp;jl_is_typector(a)) a = (jl_value_t*)((jl_typector_t*)a)-&gt;body;
    if (jl_is_typector(b)) b = (jl_value_t*)((jl_typector_t*)b)-&gt;body;
    if (ta) {
        if (jl_is_type_type(b)) {
            jl_value_t *bp = jl_tparam0(b);
            return jl_subtype_le((jl_value_t*)jl_typeof(a),
                                 (jl_value_t*)jl_type_type, 0, morespecific, 0) &amp;&amp;
                jl_subtype_le(a, bp, 0, morespecific, 1);
        }
    }
    else if (a == b) {
        // None &lt;: None
        return 1;
    }
    size_t i, j;
    if (jl_is_tuple(a)) {
        if ((jl_tuple_t*)b == jl_tuple_type) return 1;
        if (jl_is_tag_type(b) &amp;&amp;
            ((jl_tag_type_t*)b)-&gt;name == jl_ntuple_typename) {
            jl_tuple_t *tp = ((jl_tag_type_t*)b)-&gt;parameters;
            return tuple_all_subtype((jl_tuple_t*)a,
                                     jl_tupleref(tp,1), ta, morespecific,
                                     invariant);
        }
        if (jl_is_tuple(b)) {
            return jl_tuple_subtype_(&amp;jl_tupleref(a,0),((jl_tuple_t*)a)-&gt;length,
                                     &amp;jl_tupleref(b,0),((jl_tuple_t*)b)-&gt;length,
                                     ta, morespecific,invariant);
        }
    }

    if (!ta &amp;&amp; jl_is_union_type(a)) {
        jl_tuple_t *ap = ((jl_uniontype_t*)a)-&gt;types;
        if (morespecific) {
            // Union a is more specific than b if some element of a is
            // more specific than b, and b is not more specific than any
            // element of a.
            for(i=0; i &lt; ap-&gt;length; i++) {
                if (jl_subtype_le(jl_tupleref(ap,i), b, 0, 1, invariant) &amp;&amp;
                    !jl_subtype_le(b, jl_tupleref(ap,i), 0, 1, invariant)) {
                    for(j=0; j &lt; ap-&gt;length; j++) {
                        if (jl_subtype_le(b, jl_tupleref(ap,j), 0, 1, invariant) &amp;&amp;
                            !jl_subtype_le(jl_tupleref(ap,j), b, 0, 1, invariant)) {
                            return 0;
                        }
                    }
                    return 1;
                }
            }
            if (!jl_is_typevar(b))
                return 0;
        }
        else {
            if (invariant &amp;&amp; !jl_is_typevar(b)) {
                return jl_subtype_le(a,b,0,0,0) &amp;&amp; jl_subtype_le(b,a,0,0,0);
            }
            for(i=0; i &lt; ap-&gt;length; i++) {
                if (!jl_subtype_le(jl_tupleref(ap,i), b, 0, morespecific,
                                   invariant))
                    return 0;
            }
        }
        return 1;
    }

    if (jl_is_union_type(b)) {
        if (invariant)
            return 0;
        jl_tuple_t *bp = ((jl_uniontype_t*)b)-&gt;types;
        for(i=0; i &lt; bp-&gt;length; i++) {
            if (jl_subtype_le(a, jl_tupleref(bp,i), ta, morespecific, invariant))
                return 1;
        }
        return 0;
    }

    if (ta) a = (jl_value_t*)jl_typeof(a);

    if (a == b) return 1;
    if ((a==(jl_value_t*)jl_undef_type &amp;&amp; !jl_is_typevar(b)) ||
        b==(jl_value_t*)jl_undef_type)
        return 0;
    if (!invariant &amp;&amp; (jl_tag_type_t*)b == jl_any_type) return 1;

    if (jl_is_some_tag_type(a) &amp;&amp; jl_is_some_tag_type(b)) {
        if ((jl_tag_type_t*)a == jl_any_type) return 0;
        jl_tag_type_t *tta = (jl_tag_type_t*)a;
        jl_tag_type_t *ttb = (jl_tag_type_t*)b;
        int super=0;
        while (tta != (jl_tag_type_t*)jl_any_type) {
            if (tta-&gt;name == ttb-&gt;name) {
                if (super &amp;&amp; morespecific) {
                    if (tta-&gt;name != jl_type_type-&gt;name)
                        return 1;
                }
                if (tta-&gt;name == jl_ntuple_typename) {
                    // NTuple must be covariant
                    return jl_subtype_le(jl_tupleref(tta-&gt;parameters,1),
                                         jl_tupleref(ttb-&gt;parameters,1),
                                         0, morespecific, invariant);
                }
                assert(tta-&gt;parameters-&gt;length == ttb-&gt;parameters-&gt;length);
                for(i=0; i &lt; tta-&gt;parameters-&gt;length; i++) {
                    jl_value_t *apara = jl_tupleref(tta-&gt;parameters,i);
                    jl_value_t *bpara = jl_tupleref(ttb-&gt;parameters,i);
                    if (invariant &amp;&amp; jl_is_typevar(bpara) &amp;&amp;
                        !((jl_tvar_t*)bpara)-&gt;bound) {
                        return apara==bpara;
                    }
                    if (!jl_subtype_le(apara, bpara, 0, morespecific, 1))
                        return 0;
                }
                return 1;
            }
            else if (invariant) {
                return 0;
            }
            tta = tta-&gt;super; super = 1;
        }
        assert(!invariant);
        if (((jl_tag_type_t*)a)-&gt;name == jl_type_type-&gt;name) {
            // Type{T} also matches &gt;:typeof(T)
            if (!jl_is_typevar(jl_tparam0(a)))
                return jl_subtype_le(jl_tparam0(a), b, 1, morespecific, 0);
        }
        return 0;
    }

    if (jl_is_typevar(a)) {
        if (jl_is_typevar(b)) {
            return
                jl_subtype_le((jl_value_t*)((jl_tvar_t*)a)-&gt;ub,
                              (jl_value_t*)((jl_tvar_t*)b)-&gt;ub, 0, 0, 0) &amp;&amp;
                jl_subtype_le((jl_value_t*)((jl_tvar_t*)b)-&gt;lb,
                              (jl_value_t*)((jl_tvar_t*)a)-&gt;lb, 0, 0, 0);
        }
        if (invariant) {
            return 0;
            //return
            //    jl_subtype_le((jl_value_t*)((jl_tvar_t*)a)-&gt;ub, b, 0, 0, 1) &amp;&amp;
            //    jl_subtype_le((jl_value_t*)((jl_tvar_t*)a)-&gt;lb, b, 0, 0, 1);
        }
        return jl_subtype_le((jl_value_t*)((jl_tvar_t*)a)-&gt;ub, b, 0, 0, 0);
    }
    if (jl_is_typevar(b)) {
        return jl_subtype_le(a, (jl_value_t*)((jl_tvar_t*)b)-&gt;ub, 0, 0, 0) &amp;&amp;
            jl_subtype_le((jl_value_t*)((jl_tvar_t*)b)-&gt;lb, a, 0, 0, 0);
    }
    if ((jl_tag_type_t*)a == jl_any_type) return 0;
    if (jl_is_tuple(b)) {
        if (jl_is_tag_type(a) &amp;&amp;
            ((jl_tag_type_t*)a)-&gt;name == jl_ntuple_typename) {
            // only ((T&gt;:S)...,) can be a supertype of NTuple[N,S]
            jl_tuple_t *tp = (jl_tuple_t*)b;
            jl_value_t *ntp = jl_tupleref(((jl_tag_type_t*)a)-&gt;parameters, 1);
            if (tp-&gt;length == 1 &amp;&amp; jl_is_seq_type(jl_tupleref(tp,0))) {
                return jl_subtype_le(ntp, jl_tparam0(jl_tupleref(tp,0)),
                                     0, morespecific, invariant);
            }
        }
        return 0;
    }
    if (jl_is_tuple(a)) return 0;

    if (jl_is_long(a)) {
        if (jl_is_long(b))
            return (jl_unbox_long(a)==jl_unbox_long(b));
        return 0;
    }
    if (jl_is_long(b)) return 0;
    return 0;
}
</t>
<t tx="ekr.20120404123906.8125">int jl_subtype(jl_value_t *a, jl_value_t *b, int ta)
{
    return jl_subtype_le(a, b, ta, 0, 0);
}
</t>
<t tx="ekr.20120404123906.8126">int jl_subtype_invariant(jl_value_t *a, jl_value_t *b, int ta)
{
    return jl_subtype_le(a, b, ta, 0, 1);
}
</t>
<t tx="ekr.20120404123906.8127">int jl_type_morespecific(jl_value_t *a, jl_value_t *b, int ta)
{
    return jl_subtype_le(a, b, ta, 1, 0);
}
</t>
<t tx="ekr.20120404123906.8128">static jl_value_t *type_match_(
    jl_value_t *child, jl_value_t *parent,
    cenv_t *env, int morespecific, int invariant);

</t>
<t tx="ekr.20120404123906.8129">static jl_value_t *tuple_match(jl_tuple_t *child, jl_tuple_t *parent,
                               cenv_t *env, int morespecific, int invariant)
{
    size_t ci=0, pi=0;
    size_t cl = child-&gt;length;
    size_t pl = parent-&gt;length;
    while(1) {
        int cseq = (ci&lt;cl) &amp;&amp; jl_is_seq_type(jl_tupleref(child,ci));
        int pseq = (pi&lt;pl) &amp;&amp; jl_is_seq_type(jl_tupleref(parent,pi));
        if (ci &gt;= cl)
            return (pi&gt;=pl || pseq) ? jl_true : jl_false;
        if (cseq &amp;&amp; !pseq)
            return jl_false;
        if (pi &gt;= pl)
            return jl_false;
        jl_value_t *ce = jl_tupleref(child,ci);
        jl_value_t *pe = jl_tupleref(parent,pi);
        if (cseq) ce = jl_tparam0(ce);
        if (pseq) pe = jl_tparam0(pe);

        int n = env-&gt;n;
        if (type_match_(ce, pe, env, morespecific, invariant) == jl_false)
            { env-&gt;n = n; return jl_false; }

        if (cseq &amp;&amp; pseq) return jl_true;
        if (!cseq) ci++;
        if (!pseq) pi++;
    }
    return jl_true;
}
</t>
<t tx="ekr.20120404123906.8130">static jl_value_t *type_match_(jl_value_t *child, jl_value_t *parent,
                               cenv_t *env, int morespecific, int invariant)
{
    jl_value_t *tmp, *tmp2;
    if (jl_is_typector(child))
        child = (jl_value_t*)((jl_typector_t*)child)-&gt;body;
    if (jl_is_typector(parent))
        parent = (jl_value_t*)((jl_typector_t*)parent)-&gt;body;
    size_t i, j;
    if (jl_is_typevar(parent)) {
        // make sure type is within this typevar's bounds
        if (!jl_subtype_le(child, parent, 0, 0, 0))
            return jl_false;
        if (!match_intersection_mode) {
            if (!((jl_tvar_t*)parent)-&gt;bound) return jl_true;
        }
        for(int i=0; i &lt; env-&gt;n; i+=2) {
            if (env-&gt;data[i] == (jl_value_t*)parent) {
                jl_value_t *pv = env-&gt;data[i+1];
                if (jl_is_typevar(pv) &amp;&amp; jl_is_typevar(child)) {
                    if (pv == (jl_value_t*)child)
                        return jl_true;
                    return jl_false;
                }
                if (morespecific) {
                    if (jl_subtype(child, pv, 0)) {
                        return jl_true;
                    }
                    else if (jl_subtype(pv, child, 0)) {
                        env-&gt;data[i+1] = (jl_value_t*)child;
                        return jl_true;
                    }
                }
                else {
                    if (type_eqv_(child, pv))
                        return jl_true;
                }
                return jl_false;
            }
        }
        extend(parent, child, env);
        return jl_true;
    }

    if (child == parent) return jl_true;

    if (jl_is_typevar(child)) {
        if (!invariant) {
            if (jl_subtype_le(child, parent, 0, morespecific, 0))
                return jl_true;
        }
        return jl_false;
    }
    if (jl_is_long(child)) {
        if (jl_is_long(parent)) {
            if (jl_unbox_long((jl_value_t*)child) ==
                jl_unbox_long((jl_value_t*)parent))
                return jl_true;
        }
        return jl_false;
    }
    if (jl_is_long(parent))
        return jl_false;
    if (!invariant &amp;&amp; parent == (jl_value_t*)jl_any_type)
        return jl_true;
    if (child  == (jl_value_t*)jl_any_type) return jl_false;

    if (jl_is_union_type(child)) {
        jl_tuple_t *t = ((jl_uniontype_t*)child)-&gt;types;
        if (morespecific) {
            cenv_t tenv;
            for(i=0; i &lt; t-&gt;length; i++) {
                int n = env-&gt;n;
                tmp = type_match_(jl_tupleref(t,i), parent, env, 1, invariant);
                if (tmp != jl_false) {
                    tenv.n = 0;
                    tmp2 = type_match_(parent, jl_tupleref(t,i), &amp;tenv, 1,
                                       invariant);
                    if (tmp2 == jl_false) {
                        n = env-&gt;n;
                        for(j=0; j &lt; t-&gt;length; j++) {
                            tenv.n = 0;
                            env-&gt;n = n;
                            if (type_match_(parent, jl_tupleref(t,j),
                                            &amp;tenv, 1, invariant) != jl_false &amp;&amp;
                                type_match_(jl_tupleref(t,j), parent,
                                            env, 1, invariant) == jl_false) {
                                env-&gt;n = n;
                                return jl_false;
                            }
                        }
                        return jl_true;
                    }
                }
                else {
                    env-&gt;n = n;
                }
            }
            return jl_false;
        }
        else {
            for(i=0; i &lt; t-&gt;length; i++) {
                int n = env-&gt;n;
                if (type_match_(jl_tupleref(t,i), parent, env, morespecific,
                                invariant) == jl_false)
                    { env-&gt;n = n; return jl_false; }
            }
            if (invariant &amp;&amp; child == (jl_value_t*)jl_bottom_type &amp;&amp;
                !jl_is_typevar(parent))
                return jl_false;
        }
        return jl_true;
    }
    if (jl_is_union_type(parent)) {
        jl_tuple_t *t = ((jl_uniontype_t*)parent)-&gt;types;
        int n = env-&gt;n;
        for(i=0; i &lt; t-&gt;length; i++) {
            env-&gt;n = n;
            if (type_match_(child, jl_tupleref(t,i), env,
                            morespecific, invariant) != jl_false)
                return jl_true;
        }
        return jl_false;
    }

    if (jl_is_tuple(child)) {
        if (jl_is_tag_type(parent) &amp;&amp;
            ((jl_tag_type_t*)parent)-&gt;name == jl_ntuple_typename) {
            jl_tuple_t *tp = ((jl_tag_type_t*)parent)-&gt;parameters;
            size_t alen = ((jl_tuple_t*)child)-&gt;length;
            // if child has a sequence type, there exists no N such that
            // NTuple[N,Any] could be its supertype.
            if (alen&gt;0 &amp;&amp; jl_is_seq_type(jl_tupleref(child,alen-1)))
                return jl_false;
            jl_value_t *nt_len = jl_tupleref(tp,0);
            jl_value_t *childlen = jl_box_long(((jl_tuple_t*)child)-&gt;length);
            if (jl_is_typevar(nt_len)) {
                int n = env-&gt;n;
                if (type_match_(childlen, nt_len, env, morespecific,
                                invariant) == jl_false)
                    { env-&gt;n = n; return jl_false; }
            }
            else {
                return jl_false;
            }
            jl_value_t *p_seq = (jl_value_t*)jl_tuple1(jl_tupleref(tp,1));
            JL_GC_PUSH(&amp;p_seq);
            p_seq = (jl_value_t*)jl_apply_type((jl_value_t*)jl_seq_type,
                                               (jl_tuple_t*)p_seq);
            p_seq = (jl_value_t*)jl_tuple1(p_seq);
            tmp = tuple_match((jl_tuple_t*)child, (jl_tuple_t*)p_seq,
                              env, morespecific, invariant);
            JL_GC_POP();
            return tmp;
        }

        if (jl_is_tuple(parent)) {
            return tuple_match((jl_tuple_t*)child, (jl_tuple_t*)parent, env,
                               morespecific, invariant);
        }
        return jl_false;
    }
    if (jl_is_tuple(parent)) {
        if (jl_is_tag_type(child) &amp;&amp;
            ((jl_tag_type_t*)child)-&gt;name == jl_ntuple_typename) {
            // only ((T&gt;:S)...,) can be a supertype of NTuple[N,S]
            jl_tuple_t *tp = (jl_tuple_t*)parent;
            jl_value_t *ntp = jl_tupleref(((jl_tag_type_t*)child)-&gt;parameters,
                                          1);
            if (tp-&gt;length == 1 &amp;&amp; jl_is_seq_type(jl_tupleref(tp,0))) {
                return type_match_(ntp, jl_tparam0(jl_tupleref(tp,0)),
                                   env, morespecific, invariant);
            }
        }
        return jl_false;
    }

    assert(jl_is_some_tag_type(child));
    assert(jl_is_some_tag_type(parent));
    jl_tag_type_t *tta = (jl_tag_type_t*)child;
    jl_tag_type_t *ttb = (jl_tag_type_t*)parent;
    int super = 0;
    while (tta != (jl_tag_type_t*)jl_any_type) {
        if (tta-&gt;name == ttb-&gt;name) {
            if (super &amp;&amp; morespecific)
                return jl_true;
            assert(tta-&gt;parameters-&gt;length == ttb-&gt;parameters-&gt;length);
            for(i=0; i &lt; tta-&gt;parameters-&gt;length; i++) {
                int n = env-&gt;n;
                if (type_match_(jl_tupleref(tta-&gt;parameters,i),
                                jl_tupleref(ttb-&gt;parameters,i),
                                env, morespecific, 1) == jl_false)
                    { env-&gt;n = n; return jl_false; }
            }
            return jl_true;
        }
        else if (invariant) {
            return jl_false;
        }
        tta = tta-&gt;super; super = 1;
    }
    assert(!invariant);
    if (((jl_tag_type_t*)child)-&gt;name == jl_type_type-&gt;name &amp;&amp;
        ttb-&gt;name != jl_type_type-&gt;name) {
        // Type{T} also matches &gt;:typeof(T)
        return type_match_(jl_full_type(jl_tparam0(child)),
                           parent, env, morespecific, 0);
    }
    return jl_false;
}
</t>
<t tx="ekr.20120404123906.8131">/*
  typically a is a concrete type and b is a type containing typevars.
  this function tries to find a typevar assignment such that "a" is a subtype
  of "b".
  returns a tuple of (typevar,type,...) pairs.
  used to infer static parameter values in generic method definitions.
*/

jl_value_t *jl_type_match_(jl_value_t *a, jl_value_t *b, int morespecific)
{
    cenv_t env; env.n = 0; memset(env.data, 0, sizeof(env.data));
    JL_GC_PUSHARGS(env.data, sizeof(env.data)/sizeof(void*));
    jl_value_t *m = type_match_(a, b, &amp;env, morespecific, 0);
    if (m != jl_false) {
        m = (jl_value_t*)jl_alloc_tuple_uninit(env.n);
        for(int i=0; i &lt; env.n; i++) {
            jl_tupleset(m, i, env.data[i]);
        }
    }
    JL_GC_POP();
    return m;
}
</t>
<t tx="ekr.20120404123906.8132">jl_value_t *jl_type_match(jl_value_t *a, jl_value_t *b)
{
    return jl_type_match_(a, b, 0);
}
</t>
<t tx="ekr.20120404123906.8133">jl_value_t *jl_type_match_morespecific(jl_value_t *a, jl_value_t *b)
{
    return jl_type_match_(a, b, 1);
}
</t>
<t tx="ekr.20120404123906.8134">// initialization

</t>
<t tx="ekr.20120404123906.8135">jl_tvar_t *jl_new_typevar(jl_sym_t *name, jl_value_t *lb, jl_value_t *ub)
{
    jl_tvar_t *tv = (jl_tvar_t*)newobj((jl_type_t*)jl_tvar_type, 4);
    tv-&gt;name = name;
    tv-&gt;lb = lb;
    tv-&gt;ub = ub;
    tv-&gt;bound = 1;
    return tv;
}
</t>
<t tx="ekr.20120404123906.8136">
static jl_tvar_t *tvar(const char *name)
{
    jl_tvar_t *tv =
        jl_new_typevar(jl_symbol(name), (jl_value_t*)jl_bottom_type,
                       (jl_value_t*)jl_any_type);
    tv-&gt;bound=0;
    return tv;
}
</t>
<t tx="ekr.20120404123906.8137">
extern void jl_init_int32_int64_cache(void);

</t>
<t tx="ekr.20120404123906.8138">void jl_init_types(void)
{
    // create base objects
    jl_struct_kind = (jl_struct_type_t*)newobj(NULL, STRUCT_TYPE_NW);
    jl_struct_kind-&gt;type = (jl_type_t*)jl_struct_kind;
    jl_typename_type = (jl_struct_type_t*)newobj((jl_type_t*)jl_struct_kind, STRUCT_TYPE_NW);
    jl_sym_type = (jl_struct_type_t*)newobj((jl_type_t*)jl_struct_kind, STRUCT_TYPE_NW);
    jl_symbol_type = jl_sym_type;

    jl_tuple_type = jl_alloc_tuple(1);
    jl_tuple_type-&gt;type = (jl_type_t*)jl_tuple_type;

    jl_null = (jl_tuple_t*)newobj((jl_type_t*)jl_tuple_type, 1);
    jl_null-&gt;length = 0;
    jl_nothing = (jl_value_t*)jl_null; // for bootstrapping

    jl_tag_kind = jl_new_struct_type(jl_symbol("AbstractKind"), NULL,
                                     jl_null, jl_null, jl_null);
    jl_tag_type_type = jl_tag_kind;

    jl_any_type = jl_new_tagtype((jl_value_t*)jl_symbol("Any"), NULL, jl_null);
    jl_any_type-&gt;super = jl_any_type;
    jl_type_type = jl_new_tagtype((jl_value_t*)jl_symbol("Type"), jl_any_type, jl_null);

    jl_tag_kind-&gt;super = jl_type_type;
    jl_tag_kind-&gt;names = jl_tuple(6, jl_symbol(""),jl_symbol(""),jl_symbol(""),
                                  jl_symbol("name"), jl_symbol("super"),
                                  jl_symbol("parameters"));
    jl_tag_kind-&gt;types = jl_tuple(6, jl_any_type, jl_any_type, jl_any_type,
                                  jl_typename_type, jl_type_type,
                                  jl_tuple_type);
    jl_tag_kind-&gt;fptr = jl_f_no_function;

    // initialize them. lots of cycles.
    jl_struct_kind-&gt;name = jl_new_typename(jl_symbol("CompositeKind"));
    jl_struct_kind-&gt;name-&gt;primary = (jl_value_t*)jl_struct_kind;
    jl_struct_kind-&gt;super = (jl_tag_type_t*)jl_type_type;
    jl_struct_kind-&gt;parameters = jl_null;
    jl_struct_kind-&gt;names = jl_tuple(10, jl_symbol(""),
                                     jl_symbol("env"), jl_symbol("code"),
                                     jl_symbol("name"), jl_symbol("super"),
                                     jl_symbol("parameters"),
                                     jl_symbol("names"), jl_symbol("types"),
                                     jl_symbol(""), jl_symbol(""));
    jl_struct_kind-&gt;types = jl_tuple(10, jl_any_type, jl_any_type, jl_any_type,
                                     jl_typename_type, jl_type_type,
                                     jl_tuple_type, jl_tuple_type,
                                     jl_tuple_type, jl_any_type, jl_any_type);
    jl_struct_kind-&gt;fptr = jl_f_no_function;
    jl_struct_kind-&gt;env = NULL;
    jl_struct_kind-&gt;linfo = NULL;
    jl_struct_kind-&gt;ctor_factory = NULL;
    jl_struct_kind-&gt;instance = NULL;
    jl_struct_kind-&gt;uid = jl_assign_type_uid();

    jl_typename_type-&gt;name = jl_new_typename(jl_symbol("TypeName"));
    jl_typename_type-&gt;name-&gt;primary = (jl_value_t*)jl_typename_type;
    jl_typename_type-&gt;super = jl_any_type;
    jl_typename_type-&gt;parameters = jl_null;
    jl_typename_type-&gt;names = jl_tuple(3, jl_symbol("name"), jl_symbol(""),
                                       jl_symbol(""));
    jl_typename_type-&gt;types = jl_tuple(3, jl_sym_type, jl_type_type,
                                       jl_tuple_type);
    jl_typename_type-&gt;uid = jl_assign_type_uid();
    jl_typename_type-&gt;fptr = jl_f_no_function;
    jl_typename_type-&gt;env = NULL;
    jl_typename_type-&gt;linfo = NULL;
    jl_typename_type-&gt;ctor_factory = NULL;
    jl_typename_type-&gt;instance = NULL;

    jl_sym_type-&gt;name = jl_new_typename(jl_symbol("Symbol"));
    jl_sym_type-&gt;name-&gt;primary = (jl_value_t*)jl_sym_type;
    jl_sym_type-&gt;super = jl_any_type;
    jl_sym_type-&gt;parameters = jl_null;
    jl_sym_type-&gt;names = jl_null;
    jl_sym_type-&gt;types = jl_null;
    jl_sym_type-&gt;fptr = jl_f_no_function;
    jl_sym_type-&gt;env = NULL;
    jl_sym_type-&gt;linfo = NULL;
    jl_sym_type-&gt;ctor_factory = NULL;
    jl_sym_type-&gt;instance = NULL;
    jl_sym_type-&gt;uid = jl_assign_type_uid();

    // now they can be used to create the remaining base kinds and types
    jl_method_type =
        jl_new_struct_type(jl_symbol("Method"), jl_any_type, jl_null,
                           jl_tuple(6, jl_symbol("sig"), jl_symbol("va"),
                                    jl_symbol("tvars"), jl_symbol("func"),
                                    jl_symbol("invokes"), jl_symbol("next")),
                           jl_tuple(6, jl_tuple_type, jl_bool_type,
                                    jl_tuple_type, jl_function_type,
                                    jl_any_type, jl_any_type));
    jl_method_type-&gt;fptr = jl_f_no_function;

    jl_methtable_type =
        jl_new_struct_type(jl_symbol("MethodTable"), jl_any_type, jl_null,
                           jl_tuple(6, jl_symbol("name"), jl_symbol("defs"),
                                    jl_symbol("cache"), jl_symbol("cache_arg1"),
                                    jl_symbol("cache_targ"),
                                    jl_symbol("max_args")),
                           jl_tuple(6, jl_sym_type, jl_any_type, jl_any_type,
                                    jl_any_type, jl_any_type, jl_long_type));
    jl_methtable_type-&gt;fptr = jl_f_no_function;

    jl_union_kind = jl_new_struct_type(jl_symbol("UnionKind"),
                                       jl_type_type, jl_null,
                                       jl_tuple(1, jl_symbol("types")),
                                       jl_tuple(1, jl_tuple_type));
    jl_union_kind-&gt;fptr = jl_f_no_function;

    jl_bottom_type = (jl_type_t*)jl_new_struct(jl_union_kind, jl_null);

    jl_bits_kind =
        jl_new_struct_type(jl_symbol("BitsKind"), jl_type_type,
                           jl_null,
                           jl_tuple(7, jl_symbol(""), jl_symbol(""),
                                    jl_symbol(""),
                                    jl_symbol("name"), jl_symbol("super"),
                                    jl_symbol("parameters"),
                                    jl_symbol("nbits")),
                           jl_tuple(7, jl_any_type, jl_any_type, jl_any_type,
                                    jl_typename_type, jl_type_type,
                                    jl_tuple_type, jl_any_type));
    // cannot be created with normal constructor due to hidden fields
    jl_bits_kind-&gt;fptr = jl_f_no_function;
    
    jl_tvar_type = jl_new_struct_type(jl_symbol("TypeVar"),
                                      jl_any_type, jl_null,
                                      jl_tuple(3, jl_symbol("name"),
                                               jl_symbol("lb"),
                                               jl_symbol("ub")),
                                      jl_tuple(3, jl_sym_type, jl_type_type,
                                               jl_type_type));
    jl_tvar_type-&gt;fptr = jl_f_no_function;

    jl_undef_type = jl_new_tagtype((jl_value_t*)jl_symbol("Undef"),
                                   jl_any_type, jl_null);

    jl_top_type = jl_new_struct(jl_union_kind,
                                jl_tuple2(jl_any_type, jl_undef_type));

    jl_tvar_t *tttvar = jl_new_typevar(jl_symbol("T"),
                                       (jl_value_t*)jl_bottom_type,
                                       jl_top_type);
    tttvar-&gt;bound = 0;
    jl_type_type-&gt;parameters = jl_tuple(1, tttvar);

    jl_tuple_t *tv;

    tv = jl_tuple1(tvar("T"));
    jl_seq_type = jl_new_tagtype((jl_value_t*)jl_symbol("..."),
                                 jl_any_type, tv);

    jl_tupleset(jl_tuple_type, 0,
                (jl_value_t*)jl_apply_type((jl_value_t*)jl_seq_type,
                                           jl_tuple(1,jl_any_type)));

    tv = jl_tuple2(tvar("N"), tvar("T"));
    jl_ntuple_type = jl_new_tagtype((jl_value_t*)jl_symbol("NTuple"),
                                    jl_any_type, tv);
    jl_ntuple_typename = jl_ntuple_type-&gt;name;

    // non-primitive definitions follow
    jl_int32_type = NULL;
    jl_int32_type = jl_new_bitstype((jl_value_t*)jl_symbol("Int32"),
                                    jl_any_type, jl_null, 32);
    jl_int64_type = NULL;
    jl_int64_type = jl_new_bitstype((jl_value_t*)jl_symbol("Int64"),
                                    jl_any_type, jl_null, 64);
    jl_init_int32_int64_cache();
    jl_int32_type-&gt;bnbits = jl_box_int32(32);
    jl_int64_type-&gt;bnbits = jl_box_int32(64);
    jl_tupleset(jl_bits_kind-&gt;types, 3, (jl_value_t*)jl_int32_type);

    jl_bool_type = NULL;
    jl_bool_type = jl_new_bitstype((jl_value_t*)jl_symbol("Bool"),
                                   jl_any_type, jl_null, 8);
    jl_false = jl_box8(jl_bool_type, 0);
    jl_true  = jl_box8(jl_bool_type, 1);

    tv = jl_tuple2(tvar("T"), tvar("N"));
    jl_abstractarray_type = jl_new_tagtype((jl_value_t*)jl_symbol("AbstractArray"),
                                           jl_any_type, tv);

    tv = jl_tuple2(tvar("T"), tvar("N"));
    jl_array_type = 
        jl_new_struct_type(jl_symbol("Array"),
                           (jl_tag_type_t*)
                           jl_apply_type((jl_value_t*)jl_abstractarray_type, tv),
                           tv,
                           jl_null, jl_null);
    jl_array_typename = jl_array_type-&gt;name;
    jl_array_type-&gt;linfo = NULL;
    jl_initialize_generic_function((jl_function_t*)jl_array_type,
                                   jl_array_typename-&gt;name);

    jl_array_any_type =
        (jl_type_t*)jl_apply_type((jl_value_t*)jl_array_type,
                                  jl_tuple(2, jl_any_type,
                                           jl_box_long(1)));

    jl_expr_type =
        jl_new_struct_type(jl_symbol("Expr"),
                           jl_any_type, jl_null,
                           jl_tuple(3, jl_symbol("head"), jl_symbol("args"),
                                    jl_symbol("typ")),
                           jl_tuple(3, jl_sym_type, jl_array_any_type,
                                    jl_any_type));
    jl_expr_type-&gt;fptr = jl_f_new_expr;

    jl_linenumbernode_type =
        jl_new_struct_type(jl_symbol("LineNumberNode"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("line")),
                           jl_tuple(1, jl_long_type));

    jl_labelnode_type =
        jl_new_struct_type(jl_symbol("LabelNode"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("label")),
                           jl_tuple(1, jl_long_type));

    jl_gotonode_type =
        jl_new_struct_type(jl_symbol("GotoNode"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("label")),
                           jl_tuple(1, jl_long_type));

    jl_quotenode_type =
        jl_new_struct_type(jl_symbol("QuoteNode"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("value")),
                           jl_tuple(1, jl_any_type));

    jl_topnode_type =
        jl_new_struct_type(jl_symbol("TopNode"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("name")),
                           jl_tuple(1, jl_sym_type));

    jl_module_type =
        jl_new_struct_type(jl_symbol("Module"), jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("name")),
                           jl_tuple(1, jl_sym_type));

    jl_lambda_info_type =
        jl_new_struct_type(jl_symbol("LambdaStaticData"),
                           jl_any_type, jl_null,
                           jl_tuple(12, jl_symbol("ast"), jl_symbol("sparams"),
                                    jl_symbol("tfunc"), jl_symbol("name"),
                                    /*
                                    jl_symbol("roots"), jl_symbol("specTypes"),
                                    jl_symbol("unspecialized"),
                                    jl_symbol("specializations")*/
                                    jl_symbol(""), jl_symbol(""),
                                    jl_symbol(""), jl_symbol(""),
                                    jl_symbol("inferred"),
                                    jl_symbol("file"), jl_symbol("line"),
                                    jl_symbol("module")),
                           jl_tuple(12, jl_any_type, jl_tuple_type,
                                    jl_any_type, jl_sym_type,
                                    jl_any_type, jl_tuple_type,
                                    jl_function_type, jl_array_any_type,
                                    jl_bool_type,
                                    jl_sym_type, jl_long_type,
                                    jl_module_type));
    jl_lambda_info_type-&gt;fptr = jl_f_no_function;

    jl_box_type =
        jl_new_struct_type(jl_symbol("Box"),
                           jl_any_type, jl_null,
                           jl_tuple(1, jl_symbol("contents")),
                           jl_tuple(1, jl_any_type));
    jl_box_type-&gt;fptr = jl_f_new_box;
    jl_box_typename = jl_box_type-&gt;name;
    jl_box_any_type = (jl_type_t*)jl_box_type;

    jl_typector_type =
        jl_new_struct_type(jl_symbol("TypeConstructor"),
                           jl_type_type, jl_null,
                           jl_tuple(2, jl_symbol("parameters"),
                                    jl_symbol("body")),
                           jl_tuple(2, jl_tuple_type, jl_any_type));

    jl_function_type =
        jl_new_struct_type(jl_symbol("Function"), jl_any_type, jl_null,
                           jl_tuple(3, jl_symbol(""), jl_symbol("env"),
                                    jl_symbol("code")),
                           jl_tuple(3, jl_any_type, jl_any_type,
                                    jl_lambda_info_type));
    jl_function_type-&gt;fptr = jl_f_no_function;

    jl_intrinsic_type = jl_new_bitstype((jl_value_t*)jl_symbol("IntrinsicFunction"),
                                        jl_any_type, jl_null, 32);

    tv = jl_tuple1(tvar("T"));
    jl_pointer_type =
        jl_new_bitstype((jl_value_t*)jl_symbol("Ptr"), jl_any_type, tv,
                        sizeof(void*)*8);

    // Type{T}
    jl_typetype_tvar = jl_new_typevar(jl_symbol("T"),
                                      (jl_value_t*)jl_bottom_type,
                                      jl_top_type);
    jl_typetype_tvar-&gt;bound = 0;
    jl_typetype_type = (jl_tag_type_t*)
        jl_apply_type((jl_value_t*)jl_type_type,
                      jl_tuple(1,jl_typetype_tvar));

    jl_ANY_flag = (jl_value_t*)tvar("ANY");

    call_sym = jl_symbol("call");
    call1_sym = jl_symbol("call1");
    quote_sym = jl_symbol("quote");
    top_sym = jl_symbol("top");
    dots_sym = jl_symbol("...");
    line_sym = jl_symbol("line");
    jl_continue_sym = jl_symbol("continue");
    error_sym = jl_symbol("error");
    goto_sym = jl_symbol("goto");
    goto_ifnot_sym = jl_symbol("gotoifnot");
    label_sym = jl_symbol("label");
    return_sym = jl_symbol("return");
    lambda_sym = jl_symbol("lambda");
    macro_sym = jl_symbol("macro");
    module_sym = jl_symbol("module");
    assign_sym = jl_symbol("=");
    null_sym = jl_symbol("null");
    body_sym = jl_symbol("body");
    colons_sym = jl_symbol("::");
    method_sym = jl_symbol("method");
    exc_sym = jl_symbol("the_exception");
    enter_sym = jl_symbol("enter");
    leave_sym = jl_symbol("leave");
    static_typeof_sym = jl_symbol("static_typeof");
    new_sym = jl_symbol("new");
    multivalue_sym = jl_symbol("multiple_value");
    const_sym = jl_symbol("const");
    thunk_sym = jl_symbol("thunk");
    anonymous_sym = jl_symbol("anonymous");
    underscore_sym = jl_symbol("_");
    amp_sym = jl_symbol("&amp;");
}
</t>
<t tx="ekr.20120404123906.8139">@nocolor-node

@
constraint satisfaction algorithm:

- keep lists of equality constraints and subtype constraints
  (invariant and covariant)
  
- all constraints between two typevars are equality, i.e. it means the
  two corresponding typevars must end up with the same value. however
  they are kept in the subtype constraint list because they are not part
  of the final answer yet.

- after computing the intersection, we try to solve the typevar constraints
- for each equality constraint T=S, add T=S to the results
- for each other constraint T=S, do
  if T=U is in the results
    if S is a typevar
      if S=R is in the results
        update R to meet(lookup(R),lookup(U))
      else
        add S=meet(S,lookup(U))
      end
      update U to S
    else
      update U to meet(lookup(U),S)
    end
  else
    if S has typevars
      add T=S
    else
      add T=_&lt;:S
    end
  end

meet(X,Y) =
  if X and Y both have no typevars and not equal, fail
  if X has no typevars and X&lt;:Y, return X, else fail
  if Y has no typevars and Y&lt;:X, return Y, else fail
  if one or both is typevar, return meet_typevar(X,Y)
  else return intersect(X,Y)

update X to Y =
  if X is a typevar, trace to its class root and put Y there
  else put Y where X was

lookup(X) =
  if X is a typevar and X=Y is in the results, return lookup(Y)
  else return X

</t>
<t tx="ekr.20120404123906.8140">static jl_value_t *
jl_type_intersect(
    jl_value_t *a, jl_value_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var)
{
    if (jl_is_typector(a))
        a = (jl_value_t*)((jl_typector_t*)a)-&gt;body;
    if (jl_is_typector(b))
        b = (jl_value_t*)((jl_typector_t*)b)-&gt;body;
    if (a == b) return a;
    if (jl_is_typevar(a) &amp;&amp; a != jl_ANY_flag)
        return intersect_typevar((jl_tvar_t*)a, b, penv, eqc, var);
    if (jl_is_typevar(b) &amp;&amp; b != jl_ANY_flag)
        return intersect_typevar((jl_tvar_t*)b, a, penv, eqc, var);
    if (a == (jl_value_t*)jl_bottom_type || b == (jl_value_t*)jl_bottom_type)
        return (jl_value_t*)jl_bottom_type;
    if (!jl_has_typevars(a) &amp;&amp; !jl_has_typevars(b)) {
        if (jl_subtype(a, b, 0))
            return a;
        if (jl_subtype(b, a, 0))
            return b;
    }
    // union
    if (jl_is_union_type(a))
        return intersect_union((jl_uniontype_t*)a, b, penv, eqc, var);
    if (jl_is_union_type(b))
        return intersect_union((jl_uniontype_t*)b, a, penv, eqc, var);
    if (a == (jl_value_t*)jl_undef_type) return (jl_value_t*)jl_bottom_type;
    if (b == (jl_value_t*)jl_undef_type) return (jl_value_t*)jl_bottom_type;
    if (a == (jl_value_t*)jl_any_type ||
        a == jl_ANY_flag) return b;
    if (b == (jl_value_t*)jl_any_type ||
        b == jl_ANY_flag) return a;
    // tuple
    if (jl_is_tuple(a)) {
        jl_value_t *temp=NULL;
        JL_GC_PUSH(&amp;b, &amp;temp);
        if (jl_is_ntuple_type(b)) {
            long alen = (long)((jl_tuple_t*)a)-&gt;length;
            jl_value_t *lenvar = jl_tparam0(b);
            jl_value_t *elty = jl_tparam1(b);
            int i;
            for(i=0; i &lt; eqc-&gt;n; i+=2) {
                if (eqc-&gt;data[i] == lenvar) {
                    jl_value_t *v = eqc-&gt;data[i+1];
                    if (jl_is_long(v) &amp;&amp; jl_unbox_long(v)&gt;=0) {
                        // N is already known in NTuple{N,...}
                        alen = jl_unbox_long(v);
                        break;
                    }
                }
            }
            b = (jl_value_t*)jl_tuple_fill(alen, elty);
            if (i &gt;= eqc-&gt;n) {
                // don't know N yet, so add a constraint for it based on
                // the length of the other tuple
                if (alen &gt; 0 &amp;&amp; jl_is_seq_type(jl_tupleref(a,alen-1))) {
                    temp = (jl_value_t*)jl_tuple1(elty);
                    jl_tupleset(b, alen-1, jl_apply_type((jl_value_t*)jl_seq_type,
                                                         (jl_tuple_t*)temp));
                    // if the value of an NTuple typevar, N, is negative,
                    // it means the tuple needs to be at least ~N long.
                    alen = ~(alen-1);
                }
                if (jl_is_typevar(lenvar)) {
                    temp = jl_box_long(alen);
                    if (intersect_typevar((jl_tvar_t*)lenvar,temp,penv,eqc,
                                          invariant) ==
                        (jl_value_t*)jl_bottom_type) {
                        JL_GC_POP();
                        return (jl_value_t*)jl_bottom_type;
                    }
                }
            }
        }
        if (!jl_is_tuple(b)) {
            JL_GC_POP();
            return (jl_value_t*)jl_bottom_type;
        }
        a = intersect_tuple((jl_tuple_t*)a, (jl_tuple_t*)b, penv,eqc,var);
        JL_GC_POP();
        return a;
    }
    if (jl_is_tuple(b)) {
        return jl_type_intersect(b, a, penv,eqc,var);
    }
    if (jl_is_long(a) || jl_is_long(b))
        return (jl_value_t*)jl_bottom_type;
    // tag
    assert(jl_is_some_tag_type(a));
    assert(jl_is_some_tag_type(b));
    jl_tag_type_t *tta = (jl_tag_type_t*)a;
    jl_tag_type_t *ttb = (jl_tag_type_t*)b;
    if (tta-&gt;name == ttb-&gt;name)
        return (jl_value_t*)intersect_tag(tta, ttb, penv, eqc, var);
    jl_tag_type_t *super = NULL;
    jl_tag_type_t *sub = NULL;
    jl_value_t *env = NULL;
    jl_tuple_t *p = NULL;
    JL_GC_PUSH(&amp;super, &amp;sub, &amp;env, &amp;p);
    while (tta != jl_any_type) {
        if (tta-&gt;name == ttb-&gt;name) {
            sub = (jl_tag_type_t*)a;
            break;
        }
        tta = tta-&gt;super;
    }
    if (sub == NULL) {
        tta = (jl_tag_type_t*)a;
        while (ttb != jl_any_type) {
            if (tta-&gt;name == ttb-&gt;name) {
                sub = (jl_tag_type_t*)b;
                break;
            }
            ttb = ttb-&gt;super;
        }
        if (sub == NULL) {
            JL_GC_POP();
            return (jl_value_t*)jl_bottom_type;
        }
        // sub == b
        super = (jl_tag_type_t*)jl_type_intersect(a, (jl_value_t*)((jl_tag_type_t*)b)-&gt;super, penv,eqc,var);
    }
    else {
        // sub == a
        super = (jl_tag_type_t*)jl_type_intersect((jl_value_t*)((jl_tag_type_t*)a)-&gt;super, b, penv,eqc,var);
    }
    if ((jl_type_t*)super == jl_bottom_type) {
        JL_GC_POP();
        return (jl_value_t*)jl_bottom_type;
    }

    size_t n = sub-&gt;parameters-&gt;length;

    assert(sub-&gt;name-&gt;primary != NULL);
    jl_value_t *tc = sub-&gt;name-&gt;primary;
    jl_tuple_t *tc_params = ((jl_tag_type_t*)tc)-&gt;parameters;
    // compute what constraints the supertype imposes on the subtype
    jl_tuple_t *subs_sup_params =
        ((jl_tag_type_t*)((jl_tag_type_t*)tc)-&gt;super)-&gt;parameters;
    // match the intersected supertype against the pattern this subtype
    // uses to instantiate its supertype. this tells us what subtype parameter
    // values are implied by the intersected supertype, or that the
    // intersected supertype cannot come from this subtype (in which case
    // our final answer is None).
    size_t i;
    // hack: we need type_match to find assignments for all typevars
    int prev_mim = match_intersection_mode;
    match_intersection_mode = 1;
    env = jl_type_match((jl_value_t*)super-&gt;parameters,
                        (jl_value_t*)subs_sup_params);
    int sub_needs_parameters = 0;
    if (env == jl_false) {
        env = jl_type_match((jl_value_t*)subs_sup_params,
                            (jl_value_t*)super-&gt;parameters);
    }
    else {
        // this means it needs to be possible to instantiate the subtype
        // such that the supertype gets the matching parameters we just
        // determined.
        sub_needs_parameters = 1;
    }
    match_intersection_mode = prev_mim;
    if (env == jl_false) {
        JL_GC_POP();
        return (jl_value_t*)jl_bottom_type;
    }
    if (sub_needs_parameters) {
        for(int e=0; e &lt; ((jl_tuple_t*)env)-&gt;length; e+=2) {
            jl_value_t *tp = jl_tupleref(env, e);
            // make sure each needed parameter is actually set by the subtype
            size_t j;
            for(j=0; j &lt; n; j++) {
                if (tp == jl_tupleref(tc_params, j))
                    break;
            }
            if (j &gt;= n) {
                JL_GC_POP();
                return (jl_value_t*)jl_bottom_type;
            }
        }
    }

    p = jl_alloc_tuple(n);
    for(i=0; i &lt; n; i++) {
        jl_value_t *tp = jl_tupleref(tc_params, i);
        jl_value_t *elt = jl_tupleref(sub-&gt;parameters, i);
        for(int e=0; e &lt; ((jl_tuple_t*)env)-&gt;length; e+=2) {
            if (jl_tupleref(env, e) == tp) {
                elt = jl_type_intersect(elt, jl_tupleref(env, e+1),
                                        penv, eqc, var);
                // note: elt might be None if "None" was the type parameter
                break;
            }
        }
        jl_tupleset(p, i, elt);
    }
    jl_value_t *result = (jl_value_t*)jl_apply_type(tc, p);
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.8141">static jl_value_t *
intersect_union(
    jl_uniontype_t *a, jl_value_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var)
{
    int eq0 = eqc-&gt;n, co0 = penv-&gt;n;
    jl_tuple_t *t = jl_alloc_tuple(a-&gt;types-&gt;length);
    JL_GC_PUSH(&amp;t);
    size_t i;
    for(i=0; i &lt; t-&gt;length; i++) {
        jl_value_t *ti = jl_type_intersect(jl_tupleref(a-&gt;types,i), b,
                                           penv, eqc, var);
        if (ti == (jl_value_t*)jl_bottom_type) {
            int eq1 = eqc-&gt;n, co1 = penv-&gt;n;
            eqc-&gt;n = eq0; penv-&gt;n = co0;
            ti = jl_type_intersect(jl_tupleref(a-&gt;types,i), b,
                                   penv, eqc, var);
            if (ti != (jl_value_t*)jl_bottom_type) {
                // tvar conflict among union elements; keep the conflicting
                // constraints rolled back
                eqc-&gt;n = eq0; penv-&gt;n = co0;
            }
            else {
                // union element doesn't overlap no matter what.
                // so keep constraints.
                eqc-&gt;n = eq1; penv-&gt;n = co1;
            }
        }
        jl_tupleset(t, i, ti);
    }
    // problem: an intermediate union type we make here might be too
    // complex, even though the final type after typevars are replaced
    // might be ok.
    jl_value_t *tu = jl_type_union(t);
    JL_GC_POP();
    return tu;
}
</t>
<t tx="ekr.20120404123906.8142">// if returns with *bot!=0, then intersection is None
static size_t
tuple_intersect_size(jl_tuple_t *a, jl_tuple_t *b, int *bot)
{
    size_t al = a-&gt;length;
    size_t bl = b-&gt;length;
    *bot = 0;
    if (al == bl) return al;
    if (al &gt; bl) return tuple_intersect_size(b, a, bot);
    assert(al &lt; bl);
    if (jl_is_seq_type(jl_tupleref(b,bl-1))) {
        if (al &gt; 0 &amp;&amp; jl_is_seq_type(jl_tupleref(a,al-1))) {
            return bl;
        }
        else {
            if (bl == al+1)
                return al;
            *bot=1;
            return 0;
        }
    }
    if (al &gt; 0 &amp;&amp; jl_is_seq_type(jl_tupleref(a,al-1))) {
        return bl;
    }
    *bot=1;
    return 0;
}
</t>
<t tx="ekr.20120404123906.8143">static jl_value_t *
intersect_tuple(
    jl_tuple_t *a, jl_tuple_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var)
{
    size_t al = a-&gt;length;
    size_t bl = b-&gt;length;
    int bot=0;
    size_t n = tuple_intersect_size(a, b, &amp;bot);
    if (bot)
        return (jl_value_t*)jl_bottom_type;
    if (n == 0) return (jl_value_t*)jl_null;
    jl_tuple_t *tc = jl_alloc_tuple(n);
    jl_value_t *result = (jl_value_t*)tc;
    jl_value_t *ce = NULL;
    JL_GC_PUSH(&amp;tc, &amp;ce);
    size_t ai=0, bi=0, ci;
    jl_value_t *ae=NULL, *be=NULL;
    int aseq=0, bseq=0;
    for(ci=0; ci &lt; n; ci++) {
        if (ai &lt; al) {
            ae = jl_tupleref(a,ai);
            if (jl_is_seq_type(ae)) {
                aseq=1;
                ae = jl_tparam0(ae);
            }
            ai++;
        }
        if (bi &lt; bl) {
            be = jl_tupleref(b,bi);
            if (jl_is_seq_type(be)) {
                bseq=1;
                be = jl_tparam0(be);
            }
            bi++;
        }
        assert(ae!=NULL &amp;&amp; be!=NULL);
        ce = jl_type_intersect(ae,be,penv,eqc,var);
        if (ce == (jl_value_t*)jl_bottom_type) {
            if (aseq &amp;&amp; bseq) {
                // (X∩Y)==∅ → (X...)∩(Y...) == ()
                if (n == 1) {
                    result = (jl_value_t*)jl_null;
                    goto done_intersect_tuple;
                }
                tc-&gt;length--;
                goto done_intersect_tuple;
            }
            result = (jl_value_t*)jl_bottom_type;
            goto done_intersect_tuple;
        }
        if (aseq &amp;&amp; bseq) {
            ce = (jl_value_t*)jl_tuple1(ce);
            ce = (jl_value_t*)jl_apply_type((jl_value_t*)jl_seq_type,
                                            (jl_tuple_t*)ce);
        }
        jl_tupleset(tc, ci, ce);
    }
 done_intersect_tuple:
    JL_GC_POP();
    return result;
}
</t>
<t tx="ekr.20120404123906.8144">static jl_value_t *
intersect_tag(
    jl_tag_type_t *a, jl_tag_type_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var)
{
    assert(a-&gt;name == b-&gt;name);
    assert(a-&gt;parameters-&gt;length == b-&gt;parameters-&gt;length);
    jl_tuple_t *p = jl_alloc_tuple(a-&gt;parameters-&gt;length);
    JL_GC_PUSH(&amp;p);
    jl_value_t *ti;
    size_t i;
    if (a-&gt;name == jl_ntuple_typename) {
        assert(p-&gt;length == 2);
        // NOTE: tuples are covariant, so NTuple element type is too
        ti = jl_type_intersect(jl_tparam0(a),jl_tparam0(b),penv,eqc,invariant);
        jl_tupleset(p, 0, ti);
        ti = jl_type_intersect(jl_tparam1(a),jl_tparam1(b),penv,eqc,var);
        if (ti==(jl_value_t*)jl_bottom_type ||
            jl_t0(p)==(jl_value_t*)jl_bottom_type) {
            JL_GC_POP();
            return (jl_value_t*)jl_bottom_type;
        }
        jl_tupleset(p, 1, ti);
    }
    else {
        for(i=0; i &lt; p-&gt;length; i++) {
            jl_value_t *ap = jl_tupleref(a-&gt;parameters,i);
            jl_value_t *bp = jl_tupleref(b-&gt;parameters,i);
            if (jl_is_typevar(ap)) {
                ti = jl_type_intersect(ap,bp,penv,eqc,invariant);
                if (bp == (jl_value_t*)jl_bottom_type &amp;&amp;
                    !((jl_tvar_t*)ap)-&gt;bound) {
                    // "None" as a type parameter
                    jl_tupleset(p, i, ti);
                    continue;
                }
            }
            else if (jl_is_typevar(bp)) {
                ti = jl_type_intersect(ap,bp,penv,eqc,invariant);
                if (ap == (jl_value_t*)jl_bottom_type &amp;&amp;
                    !((jl_tvar_t*)bp)-&gt;bound) {
                    // "None" as a type parameter
                    jl_tupleset(p, i, ti);
                    continue;
                }
            }
            else if (jl_has_typevars_(ap,1) || jl_has_typevars_(bp,1)) {
                if (jl_subtype_invariant(ap,bp,0) ||
                    jl_subtype_invariant(bp,ap,0)) {
                    ti = jl_type_intersect(ap,bp,penv,eqc,invariant);
                }
                else {
                    ti = (jl_value_t*)jl_bottom_type;
                }
            }
            else if (type_eqv_(ap,bp)) {
                ti = ap;
                if (ti == (jl_value_t*)jl_bottom_type) {
                    // "None" as a type parameter
                    jl_tupleset(p, i, ti);
                    continue;
                }
            }
            else {
                ti = (jl_value_t*)jl_bottom_type;
            }
            if (ti == (jl_value_t*)jl_bottom_type) {
                JL_GC_POP();
                return (jl_value_t*)jl_bottom_type;
            }
            jl_tupleset(p, i, ti);
        }
    }
    if (a-&gt;name-&gt;primary != NULL) {
        jl_value_t *res = (jl_value_t*)jl_apply_type(a-&gt;name-&gt;primary, p);
        JL_GC_POP();
        return res;
    }
    assert(0 &amp;&amp; "not yet implemented");
    return NULL;
}
</t>
<t tx="ekr.20120404123906.8145">static int match_intersection_mode = 0;

static jl_value_t *
intersect_typevar(
    jl_tvar_t *a, jl_value_t *b,
    cenv_t *penv, cenv_t *eqc, variance_t var)
{
    if (jl_subtype(b, (jl_value_t*)a, 0)) {
        if (!a-&gt;bound) return b;
    }
    else if (var==invariant &amp;&amp; !jl_has_typevars(b)) {
        // for typevar a and non-typevar type b, b must be within a's bounds
        // in invariant contexts.
        return (jl_value_t*)jl_bottom_type;
    }
    else if (jl_subtype((jl_value_t*)a, b, 0)) {
        /*
          TODO: get sharper types when the overlap between a typevar and
          a type is not simple. Ex:
          tintersect(Type{Array{T,n}}, Type{typevar(:_,Vector)})
          should give Type{_&lt;:Vector}
        */
        if (!a-&gt;bound) return (jl_value_t*)a;
    }
    else {
        return (jl_value_t*)jl_bottom_type;
    }
    if (var == invariant &amp;&amp; !jl_has_typevars_(b,1)) {
        int i;
        for(i=0; i &lt; eqc-&gt;n; i+=2) {
            if (eqc-&gt;data[i] == (jl_value_t*)a) {
                jl_value_t *v = eqc-&gt;data[i+1];
                if (jl_is_long(b)) {
                    if (jl_is_long(v)) {
                        /*
                          do a meet over the lattice of tuple lengths:
                                           &gt;=0
                                            | \
                                            |  0
                                           &gt;=1
                                            | \
                                            |  1
                                           &gt;=2
                                            | \
                                            |  2
                                           ...
                        */
                        long bv = jl_unbox_long(b);
                        long vv = jl_unbox_long(v);
                        if (bv &lt; 0) {
                            if (vv &lt; 0) {
                                if (bv &lt; vv) {
                                    eqc-&gt;data[i+1] = b;
                                }
                            }
                            else {
                                if (~bv &gt; vv)
                                    return (jl_value_t*)jl_bottom_type;
                            }
                        }
                        else {
                            if (vv &lt; 0) {
                                if (~vv &gt; bv)
                                    return (jl_value_t*)jl_bottom_type;
                                eqc-&gt;data[i+1] = b;
                            }
                            else {
                                if (bv != vv)
                                    return (jl_value_t*)jl_bottom_type;
                            }
                        }
                        break;
                    }
                    else {
                        return (jl_value_t*)jl_bottom_type;
                    }
                }
                if (!jl_types_equal(v, b))
                    return (jl_value_t*)jl_bottom_type;
                break;
            }
        }
        if (i &gt;= eqc-&gt;n) {
            extend((jl_value_t*)a, b, eqc);
        }
        return (jl_value_t*)a;
    }
    if ((jl_value_t*)a != b) {
        extend((jl_value_t*)a, b, penv);
    }
    return (jl_value_t*)a;
}
</t>
<t tx="ekr.20120404123906.8146">jl_value_t *
jl_type_intersection(jl_value_t *a, jl_value_t *b)
{
    jl_tuple_t *env = jl_null;
    JL_GC_PUSH(&amp;env);
    jl_value_t *ti = jl_type_intersection_matching(a, b, &amp;env, jl_null);
    JL_GC_POP();
    return ti;
}
</t>
<t tx="ekr.20120404123906.8147">jl_value_t *
jl_type_intersection_matching(
    jl_value_t *a, jl_value_t *b,
    jl_tuple_t **penv, jl_tuple_t *tvars)
{
    cenv_t eqc; eqc.n = 0; memset(eqc.data, 0, sizeof(eqc.data));
    cenv_t env; env.n = 0; memset(env.data, 0, sizeof(env.data));
    jl_value_t *ti = NULL;

    JL_GC_PUSH(&amp;ti);
    int nrts = sizeof(eqc.data)/sizeof(void*);
    JL_GC_PUSHARGS(eqc.data, nrts);
    jl_gcframe_t __gc_stkf3_ = { (jl_value_t***)env.data, nrts,
                                 0, jl_pgcstack };
    jl_pgcstack = &amp;__gc_stkf3_;

    ti = jl_type_intersect(a, b, &amp;env, &amp;eqc, covariant);
    if (ti == (jl_value_t*)jl_bottom_type ||
        !(env.n &gt; 0 || eqc.n &gt; 0 || tvars != jl_null)) {
        JL_GC_POP(); JL_GC_POP(); JL_GC_POP();
        return ti;
    }

    int e;
    for(e=0; e &lt; eqc.n; e+=2) {
        jl_value_t *val = eqc.data[e+1];
        if (jl_is_long(val) &amp;&amp; jl_unbox_long(val)&gt;=0) {
            break;
        }
    }
    if (e &lt; eqc.n) {
        /*
          if there are integer-valued parameters, repeat intersection
          with the full environment visible. this is needed because
          NTuple has only one element type, so we can't keep track of
          the fact that an arbitrary tuple's length must match some
          typevar, e.g. "(Int8,Int32...) of length N". the solution is
          to find all other constraints on N first, then do intersection
          again with that knowledge.
        */
        ti = jl_type_intersect(a, b, &amp;env, &amp;eqc, covariant);
        if (ti == (jl_value_t*)jl_bottom_type) {
            JL_GC_POP(); JL_GC_POP(); JL_GC_POP();
            return ti;
        }
    }

    if (!solve_tvar_constraints(&amp;env, &amp;eqc)) {
        JL_GC_POP(); JL_GC_POP(); JL_GC_POP();
        return (jl_value_t*)jl_bottom_type;
    }
    //ios_printf(ios_stdout, "env: "); print_env(&amp;env);
    //ios_printf(ios_stdout, "sol: "); print_env(&amp;eqc);

    // convert non-specific integer vars to typevars
    for(e=0; e &lt; eqc.n; e+=2) {
        jl_value_t *val = eqc.data[e+1];
        if (jl_is_long(val) &amp;&amp; jl_unbox_long(val)&lt;0) {
            eqc.data[e+1] = eqc.data[e];
        }
    }

    int env0 = eqc.n;
    jl_value_t **tvs;
    int tvarslen;
    if (jl_is_typevar(tvars)) {
        tvs = (jl_value_t**)&amp;tvars;
        tvarslen = 1;
    }
    else {
        tvs = &amp;jl_t0(tvars);
        tvarslen = tvars-&gt;length;
    }
    for(int tk=0; tk &lt; tvarslen; tk++) {
        jl_value_t *tv = tvs[tk];
        for(e=0; e &lt; env0; e+=2) {
            if (eqc.data[e] == tv) {
                break;
            }
        }
        // bind type vars to themselves if they were not matched explicitly
        // during type intersection.
        if (e &gt;= env0)
            extend_(tv, tv, &amp;eqc, 1);
    }

    *penv = jl_alloc_tuple_uninit(eqc.n);
    for(int i=0; i &lt; eqc.n; i+=2) {
        jl_tupleset(*penv, i, eqc.data[i]);
        jl_tupleset(*penv, i+1, *tvar_lookup(&amp;eqc, &amp;eqc.data[i+1]));
    }

    if (env0 &gt; 0) {
        ti = (jl_value_t*)
            jl_instantiate_type_with((jl_type_t*)ti, &amp;jl_t0(*penv), eqc.n/2);
    }

    JL_GC_POP(); JL_GC_POP(); JL_GC_POP();
    return ti;
}
</t>
<t tx="ekr.20120404123906.8148">static int solve_tvar_constraints(cenv_t *env, cenv_t *soln)
{
    //ios_printf(ios_stdout, "\n");
    jl_value_t *v=NULL;
    for(int i=0; i &lt; env-&gt;n; i+=2) {
        jl_value_t *T = env-&gt;data[i];
        jl_value_t *S = env-&gt;data[i+1];
        if (S &lt; T &amp;&amp; is_btv(S)) {
            jl_value_t *temp = S;
            S = T;
            T = temp;
        }
        jl_value_t **pT;
        pT = tvar_lookup(soln, &amp;T);
        if (pT != &amp;T) {
            // T=U is in the results
            jl_value_t **pU = pT;
            //jl_value_t *U = *pU;
            if (is_btv(S)) {
                // S is a typevar
                jl_value_t **pS;
                pS = tvar_lookup(soln, &amp;S);
                if (pS != &amp;S) {
                    // S=R is in the results
                    jl_value_t **pR = pS;
                    *pR = meet(*pR, *pU, invariant);
                    if (*pR == NULL) {
                        return 0;
                    }
                }
                else {
                    v = meet(*pU, S, covariant);
                    if (v == NULL) {
                        return 0;
                    }
                    extend(S, v, soln);
                }
                if (pS != pU)
                    *pU = S;
            }
            else {
                v = meet(*pU, S, covariant);
                if (v == NULL) {
                    return 0;
                }
                if (is_btv(*pU)) {
                    extend(*pU, v, soln);
                }
                else {
                    *pU = v;
                }
            }
        }
        else {
            if (jl_has_typevars_(S,1)) {
                if (*tvar_lookup(soln, &amp;S) != T)
                    extend(T, S, soln);
            }
            else {
                if (jl_is_leaf_type(S) || jl_is_long(S) ||
                    S == (jl_value_t*)jl_bottom_type) {
                    v = S;
                }
                else {
                    assert(jl_is_typevar(T));
                    v = meet(S, T, covariant);
                    if (!jl_is_typevar(v)) {
                        v = (jl_value_t*)
                            jl_new_typevar(underscore_sym,
                                           (jl_value_t*)jl_bottom_type, v);
                    }
                    ((jl_tvar_t*)v)-&gt;bound = 1; // ???
                }
                extend(T, v, soln);
            }
        }
    }
    return 1;
}
</t>
<t tx="ekr.20120404123906.8149">static jl_value_t **tvar_lookup(cenv_t *env, jl_value_t **pX)
{
    jl_value_t *v = *pX;
    if (is_btv(v)) {
        for(int i=0; i &lt; env-&gt;n; i+=2) {
            if (env-&gt;data[i] == v) {
                if (env-&gt;data[i+1] == v)  // allow T=T
                    return pX;
                return tvar_lookup(env, &amp;env-&gt;data[i+1]);
            }
        }
    }
    return pX;
}
</t>
<t tx="ekr.20120404123906.8150">static jl_value_t *
meet(jl_value_t *X, jl_value_t *Y, variance_t var)
{
    if (jl_is_typevar(X)) {
        jl_value_t *tv;
        if (jl_is_typevar(Y)) {
            tv = meet_tvars((jl_tvar_t*)X, (jl_tvar_t*)Y);
        }
        else {
            tv = meet_tvar((jl_tvar_t*)X, Y);
        }
        if (tv == (jl_value_t*)jl_bottom_type)
            return NULL;
        return tv;
    }
    if (jl_is_typevar(Y)) {
        jl_value_t *tv = meet_tvar((jl_tvar_t*)Y, X);
        if (tv == (jl_value_t*)jl_bottom_type)
            return NULL;
        return tv;
    }
    if (!jl_has_typevars_(X,1)) {
        if (!jl_has_typevars_(Y,1)) {
            if (var==invariant) {
                return (jl_types_equal(X,Y) ? X : NULL);
            }
        }
        return (jl_subtype(X,Y,0) ? X : NULL);
    }
    if (!jl_has_typevars_(Y,1)) {
        return (jl_subtype(Y,X,0) ? Y : NULL);
    }
    jl_value_t *v = jl_type_intersection(X, Y);
    return (v == (jl_value_t*)jl_bottom_type ?  NULL : v);
}
</t>
<t tx="ekr.20120404123906.8151">static jl_value_t *
meet_tvar(jl_tvar_t *tv, jl_value_t *ty)
{
    if (jl_is_typevar(ty))
        return (jl_value_t*)meet_tvars(tv, (jl_tvar_t*)ty);
    //if (jl_types_equal((jl_value_t*)tv-&gt;ub, ty))
    //    return ty;
    if (jl_subtype((jl_value_t*)tv-&gt;ub, ty, 0))
        return (jl_value_t*)tv;
    // TODO: should we check type_intersection(tv-&gt;ub, ty) instead?
    if (!jl_subtype(ty, (jl_value_t*)tv-&gt;ub, 0))
        return (jl_value_t*)jl_bottom_type;
    //if (jl_types_equal((jl_value_t*)tv-&gt;lb, ty))
    //    return ty;
    if (jl_subtype((jl_value_t*)tv-&gt;lb, ty, 0)) {
        if (jl_is_leaf_type(ty) || jl_is_long(ty))
            return ty;
        return (jl_value_t*)jl_new_typevar(underscore_sym, tv-&gt;lb, ty);
    }
    return (jl_value_t*)jl_bottom_type;
}
</t>
<t tx="ekr.20120404123906.8152">static jl_value_t *
meet_tvars(jl_tvar_t *a, jl_tvar_t *b)
{
    jl_value_t *lb=NULL, *ub=NULL;
    if (type_eqv_((jl_value_t*)a-&gt;lb, (jl_value_t*)b-&gt;lb) &amp;&amp;
        type_eqv_((jl_value_t*)a-&gt;ub, (jl_value_t*)b-&gt;ub))
        return (jl_value_t*)b;
    ub = jl_type_intersection((jl_value_t*)a-&gt;ub, (jl_value_t*)b-&gt;ub);
    if (ub == (jl_value_t*)jl_bottom_type)
        return ub;
    JL_GC_PUSH(&amp;lb, &amp;ub);
    lb = (jl_value_t*)jl_tuple2(a-&gt;lb, b-&gt;lb);
    lb = jl_type_union((jl_tuple_t*)lb);
    if (!jl_subtype(lb, ub, 0)) {
        JL_GC_POP();
        return (jl_value_t*)jl_bottom_type;
    }
    // TODO: might not want to collapse tvar to non-tvar in all cases
    if (jl_is_leaf_type(ub)) {
        JL_GC_POP();
        return ub;
    }
    jl_value_t *res = (jl_value_t*)jl_new_typevar(underscore_sym, lb, ub);
    JL_GC_POP();
    return res;
}
</t>
<t tx="ekr.20120404123906.8153">// is bound type var.

static inline int is_btv(jl_value_t *v)
{
    return jl_is_typevar(v) &amp;&amp; ((jl_tvar_t*)v)-&gt;bound;
}
</t>
<t tx="ekr.20120404123906.8154">#if 0
    @others
#endif
</t>
<t tx="ekr.20120404123906.8155">static char *type_summary(jl_value_t *t)
{
    if (jl_is_tuple(t)) return "Tuple";
    if (jl_is_some_tag_type(t))
        return ((jl_tag_type_t*)t)-&gt;name-&gt;name-&gt;name;
    return "?";
}
</t>
<t tx="ekr.20120404123906.8156">static void print_env(cenv_t *soln)
{
    for(int i=0; i &lt; soln-&gt;n; i+=2) {
        jl_value_t *T, *S;
        T = soln-&gt;data[i]; S = soln-&gt;data[i+1];
        ios_printf(ios_stdout,
                   "%s@%x=%s ",
                   ((jl_tvar_t*)T)-&gt;name-&gt;name, T,
                   type_summary(S));
    }
    ios_printf(ios_stdout, "\n");
}
</t>
</tnodes>
</leo_file>
