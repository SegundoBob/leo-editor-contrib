<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20181012123120.1"><vh>Recursive import script</vh></v>
<v t="ekr.20181012124134.2"><vh>@path C:/Anaconda3/Lib/site-packages/neovim</vh>
<v t="ekr.20181012124134.3"><vh>@@clean compat.py</vh>
<v t="ekr.20181012124134.4"><vh>Declarations (compat.py)</vh></v>
<v t="ekr.20181012124134.5"><vh>check_async</vh></v>
</v>
<v t="ekr.20181012124134.6"><vh>@@clean util.py</vh>
<v t="ekr.20181012124134.8"><vh>format_exc_skip</vh></v>
<v t="ekr.20181012124134.9"><vh>class Version</vh>
<v t="ekr.20181012124134.10"><vh>Version.__init__</vh></v>
<v t="ekr.20181012124134.11"><vh>Version.__repr__</vh></v>
<v t="ekr.20181012124134.12"><vh>Version.__eq__</vh></v>
</v>
</v>
<v t="ekr.20181012124134.13"><vh>@@clean __init__.py</vh>
<v t="ekr.20181012124134.15"><vh>start_host</vh></v>
<v t="ekr.20181012124134.16"><vh>attach</vh></v>
<v t="ekr.20181012124134.17"><vh>setup_logging</vh></v>
<v t="ekr.20181012124134.18"><vh>class NullHandler(logging.Handler)</vh></v>
</v>
<v t="ekr.20181012203356.1"><vh>===== Client</vh></v>
<v t="ekr.20181012124134.74"><vh>@path api</vh>
<v t="ekr.20181012124134.215"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20181012124134.75"><vh>@@clean buffer.py</vh>
<v t="ekr.20181012124134.77"><vh>adjust_index</vh></v>
<v t="ekr.20181012124134.78"><vh>class Buffer(Remote)</vh>
<v t="ekr.20181012124134.79"><vh>Buffer.__len__</vh></v>
<v t="ekr.20181012124134.80"><vh>Buffer.__getitem__</vh></v>
<v t="ekr.20181012124134.81"><vh>Buffer.__setitem__</vh></v>
<v t="ekr.20181012124134.82"><vh>Buffer.__iter__</vh></v>
<v t="ekr.20181012124134.83"><vh>Buffer.__delitem__</vh></v>
<v t="ekr.20181012124134.84"><vh>Buffer.append</vh></v>
<v t="ekr.20181012124134.85"><vh>Buffer.mark</vh></v>
<v t="ekr.20181012124134.86"><vh>Buffer.range</vh></v>
<v t="ekr.20181012124134.87"><vh>Buffer.add_highlight</vh></v>
<v t="ekr.20181012124134.88"><vh>Buffer.clear_highlight</vh></v>
<v t="ekr.20181012124134.89"><vh>Buffer.update_highlights</vh></v>
<v t="ekr.20181012124134.90"><vh>@property name</vh></v>
<v t="ekr.20181012124134.92"><vh>@property valid</vh></v>
<v t="ekr.20181012124134.93"><vh>@property number</vh></v>
</v>
<v t="ekr.20181012124134.94"><vh>class Range(object)</vh>
<v t="ekr.20181012124134.95"><vh>Range.__init__</vh></v>
<v t="ekr.20181012124134.96"><vh>Range.__len__</vh></v>
<v t="ekr.20181012124134.97"><vh>Range.__getitem__</vh></v>
<v t="ekr.20181012124134.98"><vh>Range.__setitem__</vh></v>
<v t="ekr.20181012124134.99"><vh>Range.__iter__</vh></v>
<v t="ekr.20181012124134.100"><vh>Range.append</vh></v>
<v t="ekr.20181012124134.101"><vh>Range._normalize_index</vh></v>
</v>
</v>
<v t="ekr.20181012124134.102"><vh>@@clean common.py</vh>
<v t="ekr.20181012124134.104"><vh>class Remote(object)</vh>
<v t="ekr.20181012124134.105"><vh>Remote.__init__</vh></v>
<v t="ekr.20181012124134.106"><vh>Remote.__eq__</vh></v>
<v t="ekr.20181012124134.107"><vh>Remote.__hash__</vh></v>
<v t="ekr.20181012124134.108"><vh>Remote.request</vh></v>
</v>
<v t="ekr.20181012124134.109"><vh>class RemoteApi(object)</vh>
<v t="ekr.20181012124134.110"><vh>RemoteApi.__init__</vh></v>
<v t="ekr.20181012124134.111"><vh>RemoteApi.__getattr__</vh></v>
</v>
<v t="ekr.20181012124134.112"><vh>class RemoteMap(object)</vh>
<v t="ekr.20181012124134.113"><vh>RemoteMap.__init__</vh></v>
<v t="ekr.20181012124134.114"><vh>RemoteMap.__getitem__</vh></v>
<v t="ekr.20181012124134.115"><vh>RemoteMap.__setitem__</vh></v>
<v t="ekr.20181012124134.116"><vh>RemoteMap.__delitem__</vh></v>
<v t="ekr.20181012124134.117"><vh>RemoteMap.__contains__</vh></v>
<v t="ekr.20181012124134.118"><vh>RemoteMap.get</vh></v>
</v>
<v t="ekr.20181012124134.119"><vh>class RemoteSequence(object)</vh>
<v t="ekr.20181012124134.120"><vh>RemoteSequence.__init__</vh></v>
<v t="ekr.20181012124134.121"><vh>RemoteSequence.__len__</vh></v>
<v t="ekr.20181012124134.122"><vh>RemoteSequence.__getitem__</vh></v>
<v t="ekr.20181012124134.123"><vh>RemoteSequence.__iter__</vh></v>
<v t="ekr.20181012124134.124"><vh>RemoteSequence.__contains__</vh></v>
</v>
<v t="ekr.20181012124134.125"><vh>_identity</vh></v>
<v t="ekr.20181012124134.126"><vh>decode_if_bytes</vh></v>
<v t="ekr.20181012124134.127"><vh>walk</vh></v>
</v>
<v t="ekr.20181012124134.128"><vh>@@clean nvim.py</vh>
<v t="ekr.20181012124134.129"><vh>Declarations (nvim.py)</vh></v>
<v t="ekr.20181012124134.130"><vh>class Nvim(object)</vh>
<v t="ekr.20181012124134.131"><vh>Nvim.from_session</vh></v>
<v t="ekr.20181012124134.132"><vh>Nvim.from_nvim</vh></v>
<v t="ekr.20181012124134.133"><vh>Nvim.__init__</vh></v>
<v t="ekr.20181012124134.134"><vh>Nvim._from_nvim</vh></v>
<v t="ekr.20181012124134.135"><vh>Nvim._to_nvim</vh></v>
<v t="ekr.20181012124134.136"><vh>Nvim._get_lua_private</vh></v>
<v t="ekr.20181012124134.137"><vh>Nvim.request</vh></v>
<v t="ekr.20181012124134.138"><vh>Nvim.next_message</vh></v>
<v t="ekr.20181012124134.139"><vh>Nvim.run_loop</vh></v>
<v t="ekr.20181012124134.140"><vh>Nvim.stop_loop</vh></v>
<v t="ekr.20181012124134.141"><vh>Nvim.close</vh></v>
<v t="ekr.20181012124134.142"><vh>Nvim.__enter__</vh></v>
<v t="ekr.20181012124134.143"><vh>Nvim.__exit__</vh></v>
<v t="ekr.20181012124134.144"><vh>Nvim.with_decode</vh></v>
<v t="ekr.20181012124134.145"><vh>Nvim.ui_attach</vh></v>
<v t="ekr.20181012124134.146"><vh>Nvim.ui_detach</vh></v>
<v t="ekr.20181012124134.147"><vh>Nvim.ui_try_resize</vh></v>
<v t="ekr.20181012124134.148"><vh>Nvim.subscribe</vh></v>
<v t="ekr.20181012124134.149"><vh>Nvim.unsubscribe</vh></v>
<v t="ekr.20181012124134.150"><vh>Nvim.command</vh></v>
<v t="ekr.20181012124134.151"><vh>Nvim.command_output</vh></v>
<v t="ekr.20181012124134.152"><vh>Nvim.eval</vh></v>
<v t="ekr.20181012124134.153"><vh>Nvim.call</vh></v>
<v t="ekr.20181012124134.154"><vh>Nvim.exec_lua</vh></v>
<v t="ekr.20181012124134.155"><vh>Nvim.strwidth</vh></v>
<v t="ekr.20181012124134.156"><vh>Nvim.list_runtime_paths</vh></v>
<v t="ekr.20181012124134.157"><vh>Nvim.foreach_rtp</vh></v>
<v t="ekr.20181012124134.158"><vh>Nvim.chdir</vh></v>
<v t="ekr.20181012124134.159"><vh>Nvim.feedkeys</vh></v>
<v t="ekr.20181012124134.160"><vh>Nvim.input</vh></v>
<v t="ekr.20181012124134.161"><vh>Nvim.replace_termcodes</vh></v>
<v t="ekr.20181012124134.162"><vh>Nvim.out_write</vh></v>
<v t="ekr.20181012124134.163"><vh>Nvim.err_write</vh></v>
<v t="ekr.20181012124134.164"><vh>Nvim.quit</vh></v>
<v t="ekr.20181012124134.165"><vh>Nvim.new_highlight_source</vh></v>
<v t="ekr.20181012124134.166"><vh>Nvim.async_call</vh></v>
</v>
<v t="ekr.20181012124134.167"><vh>class Buffers(object)</vh>
<v t="ekr.20181012124134.168"><vh>Buffers.__init__</vh></v>
<v t="ekr.20181012124134.169"><vh>Buffers.__len__</vh></v>
<v t="ekr.20181012124134.170"><vh>Buffers.__getitem__</vh></v>
<v t="ekr.20181012124134.171"><vh>Buffers.__contains__</vh></v>
<v t="ekr.20181012124134.172"><vh>Buffers.__iter__</vh></v>
</v>
<v t="ekr.20181012124134.173"><vh>class CompatibilitySession(object)</vh></v>
<v t="ekr.20181012124134.175"><vh>class Current(object)</vh>
<v t="ekr.20181012124134.176"><vh>Current.__init__</vh></v>
<v t="ekr.20181012124134.177"><vh>@property line</vh></v>
<v t="ekr.20181012124134.179"><vh>@property buffer</vh></v>
<v t="ekr.20181012124134.181"><vh>@property window</vh></v>
<v t="ekr.20181012124134.183"><vh>@property tabpage</vh></v>
<v t="ekr.20181012124134.184"><vh>Current.tabpage</vh></v>
</v>
<v t="ekr.20181012124134.185"><vh>class Funcs(object)</vh>
<v t="ekr.20181012124134.186"><vh>Funcs.__init__</vh></v>
<v t="ekr.20181012124134.187"><vh>Funcs.__getattr__</vh></v>
</v>
<v t="ekr.20181012124134.188"><vh>class LuaFuncs(object)</vh>
<v t="ekr.20181012124134.189"><vh>LuaFuncs.__init__</vh></v>
<v t="ekr.20181012124134.190"><vh>LuaFuncs.__getattr__</vh></v>
<v t="ekr.20181012124134.191"><vh>LuaFuncs.__call__</vh></v>
</v>
<v t="ekr.20181012124134.192"><vh>class NvimError(Exception)</vh></v>
</v>
<v t="ekr.20181012124134.193"><vh>@@clean tabpage.py</vh>
<v t="ekr.20181012124134.195"><vh>class Tabpage(Remote)</vh>
<v t="ekr.20181012124134.196"><vh>Tabpage.__init__</vh></v>
<v t="ekr.20181012124134.197"><vh>@property window</vh></v>
<v t="ekr.20181012124134.198"><vh>@property valid</vh></v>
<v t="ekr.20181012124134.199"><vh>@property number</vh></v>
</v>
</v>
<v t="ekr.20181012124134.200"><vh>@@clean window.py</vh>
<v t="ekr.20181012124134.202"><vh>class Window(Remote)</vh>
<v t="ekr.20181012124134.203"><vh>@property buffer</vh></v>
<v t="ekr.20181012124134.204"><vh>@property cursor</vh></v>
<v t="ekr.20181012124134.206"><vh>@property height</vh></v>
<v t="ekr.20181012124134.208"><vh>@property width</vh></v>
<v t="ekr.20181012124134.210"><vh>@property row</vh></v>
<v t="ekr.20181012124134.211"><vh>@property col</vh></v>
<v t="ekr.20181012124134.212"><vh>@property tabpage</vh></v>
<v t="ekr.20181012124134.213"><vh>@property valid</vh></v>
<v t="ekr.20181012124134.214"><vh>@property number</vh></v>
</v>
</v>
</v>
<v t="ekr.20181012124134.218"><vh>@path msgpack_rpc</vh>
<v t="ekr.20181012124134.266"><vh>@@clean __init__.py</vh>
<v t="ekr.20181012124134.268"><vh>session</vh></v>
<v t="ekr.20181012124134.269"><vh>tcp_session</vh></v>
<v t="ekr.20181012124134.270"><vh>socket_session</vh></v>
<v t="ekr.20181012124134.271"><vh>stdio_session</vh></v>
<v t="ekr.20181012124134.272"><vh>child_session</vh></v>
</v>
<v t="ekr.20181012124134.219"><vh>@@clean async_session.py</vh>
<v t="ekr.20181012124134.221"><vh>class AsyncSession(object)</vh>
<v t="ekr.20181012124134.222"><vh>AsyncSession.__init__</vh></v>
<v t="ekr.20181012124134.223"><vh>AsyncSession.threadsafe_call</vh></v>
<v t="ekr.20181012124134.224"><vh>AsyncSession.request</vh></v>
<v t="ekr.20181012124134.225"><vh>AsyncSession.notify</vh></v>
<v t="ekr.20181012124134.226"><vh>AsyncSession.run</vh></v>
<v t="ekr.20181012124134.227"><vh>AsyncSession.stop</vh></v>
<v t="ekr.20181012124134.228"><vh>AsyncSession.close</vh></v>
<v t="ekr.20181012124134.229"><vh>AsyncSession._on_message</vh></v>
<v t="ekr.20181012124134.230"><vh>AsyncSession._on_request</vh></v>
<v t="ekr.20181012124134.231"><vh>AsyncSession._on_response</vh></v>
<v t="ekr.20181012124134.232"><vh>AsyncSession._on_notification</vh></v>
<v t="ekr.20181012124134.233"><vh>AsyncSession._on_invalid_message</vh></v>
</v>
<v t="ekr.20181012124134.234"><vh>class Response(object)</vh>
<v t="ekr.20181012124134.235"><vh>Response.__init__</vh></v>
<v t="ekr.20181012124134.236"><vh>Response.send</vh></v>
</v>
</v>
<v t="ekr.20181012124134.237"><vh>@@clean msgpack_stream.py</vh>
<v t="ekr.20181012124134.239"><vh>class MsgpackStream(object)</vh>
<v t="ekr.20181012124134.240"><vh>MsgpackStream.__init__</vh></v>
<v t="ekr.20181012124134.241"><vh>MsgpackStream.threadsafe_call</vh></v>
<v t="ekr.20181012124134.242"><vh>MsgpackStream.send</vh></v>
<v t="ekr.20181012124134.243"><vh>MsgpackStream.run</vh></v>
<v t="ekr.20181012124134.244"><vh>MsgpackStream.stop</vh></v>
<v t="ekr.20181012124134.245"><vh>MsgpackStream.close</vh></v>
<v t="ekr.20181012124134.246"><vh>MsgpackStream._on_data</vh></v>
</v>
</v>
<v t="ekr.20181012124134.247"><vh>@@clean session.py</vh>
<v t="ekr.20181012124134.249"><vh>class Session(object)</vh>
<v t="ekr.20181012124134.250"><vh>Session.__init__</vh></v>
<v t="ekr.20181012124134.251"><vh>Session.threadsafe_call</vh></v>
<v t="ekr.20181012124134.252"><vh>Session.next_message</vh></v>
<v t="ekr.20181012124134.253"><vh>Session.request</vh></v>
<v t="ekr.20181012124134.254"><vh>Session.run</vh></v>
<v t="ekr.20181012124134.255"><vh>Session.stop</vh></v>
<v t="ekr.20181012124134.256"><vh>Session.close</vh></v>
<v t="ekr.20181012124134.257"><vh>Session._yielding_request</vh></v>
<v t="ekr.20181012124134.258"><vh>Session._blocking_request</vh></v>
<v t="ekr.20181012124134.259"><vh>Session._enqueue_request_and_stop</vh></v>
<v t="ekr.20181012124134.260"><vh>Session._enqueue_notification_and_stop</vh></v>
<v t="ekr.20181012124134.261"><vh>Session._enqueue_request</vh></v>
<v t="ekr.20181012124134.262"><vh>Session._enqueue_notification</vh></v>
<v t="ekr.20181012124134.263"><vh>Session._on_request</vh></v>
<v t="ekr.20181012124134.264"><vh>Session._on_notification</vh></v>
</v>
<v t="ekr.20181012124134.265"><vh>class ErrorResponse(BaseException)</vh></v>
</v>
<v t="ekr.20181012124134.274"><vh>@path event_loop</vh>
<v t="ekr.20181012124134.335"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20181012124134.275"><vh>@@clean asyncio.py</vh>
<v t="ekr.20181012124134.276"><vh>Declarations (asyncio.py)</vh></v>
<v t="ekr.20181012124134.277"><vh>class AsyncioEventLoop</vh>
<v t="ekr.20181012124134.278"><vh>AsyncioEventLoop.connection_made</vh></v>
<v t="ekr.20181012124134.279"><vh>AsyncioEventLoop.connection_lost</vh></v>
<v t="ekr.20181012124134.280"><vh>AsyncioEventLoop.data_received</vh></v>
<v t="ekr.20181012124134.281"><vh>AsyncioEventLoop.pipe_connection_lost</vh></v>
<v t="ekr.20181012124134.282"><vh>AsyncioEventLoop.pipe_data_received</vh></v>
<v t="ekr.20181012124134.283"><vh>AsyncioEventLoop.process_exited</vh></v>
<v t="ekr.20181012124134.284"><vh>AsyncioEventLoop._init</vh></v>
<v t="ekr.20181012124134.285"><vh>AsyncioEventLoop._connect_tcp</vh></v>
<v t="ekr.20181012124134.286"><vh>AsyncioEventLoop._connect_socket</vh></v>
<v t="ekr.20181012124134.287"><vh>AsyncioEventLoop._connect_stdio</vh></v>
<v t="ekr.20181012124134.288"><vh>AsyncioEventLoop._connect_child</vh></v>
<v t="ekr.20181012124134.289"><vh>AsyncioEventLoop._start_reading</vh></v>
<v t="ekr.20181012124134.290"><vh>AsyncioEventLoop._send</vh></v>
<v t="ekr.20181012124134.291"><vh>AsyncioEventLoop._run</vh></v>
<v t="ekr.20181012124134.292"><vh>AsyncioEventLoop._stop</vh></v>
<v t="ekr.20181012124134.293"><vh>AsyncioEventLoop._close</vh></v>
<v t="ekr.20181012124134.294"><vh>AsyncioEventLoop._threadsafe_call</vh></v>
<v t="ekr.20181012124134.295"><vh>AsyncioEventLoop._setup_signals</vh></v>
<v t="ekr.20181012124134.296"><vh>AsyncioEventLoop._teardown_signals</vh></v>
</v>
</v>
<v t="ekr.20181012124134.297"><vh>@@clean base.py</vh>
<v t="ekr.20181012124134.299"><vh>class BaseEventLoop(object)</vh>
<v t="ekr.20181012124134.300"><vh>BaseEventLoop.__init__</vh></v>
<v t="ekr.20181012124134.301"><vh>BaseEventLoop.connect_tcp</vh></v>
<v t="ekr.20181012124134.302"><vh>BaseEventLoop.connect_socket</vh></v>
<v t="ekr.20181012124134.303"><vh>BaseEventLoop.connect_stdio</vh></v>
<v t="ekr.20181012124134.304"><vh>BaseEventLoop.connect_child</vh></v>
<v t="ekr.20181012124134.305"><vh>BaseEventLoop.send</vh></v>
<v t="ekr.20181012124134.306"><vh>BaseEventLoop.threadsafe_call</vh></v>
<v t="ekr.20181012124134.307"><vh>BaseEventLoop.run</vh></v>
<v t="ekr.20181012124134.308"><vh>BaseEventLoop.stop</vh></v>
<v t="ekr.20181012124134.309"><vh>BaseEventLoop.close</vh></v>
<v t="ekr.20181012124134.310"><vh>BaseEventLoop._on_signal</vh></v>
<v t="ekr.20181012124134.311"><vh>BaseEventLoop._on_error</vh></v>
<v t="ekr.20181012124134.312"><vh>BaseEventLoop._on_interrupt</vh></v>
</v>
</v>
<v t="ekr.20181012124134.313"><vh>@@clean uv.py</vh>
<v t="ekr.20181012124134.315"><vh>class UvEventLoop(BaseEventLoop)</vh>
<v t="ekr.20181012124134.316"><vh>UvEventLoop._init</vh></v>
<v t="ekr.20181012124134.317"><vh>UvEventLoop._on_connect</vh></v>
<v t="ekr.20181012124134.318"><vh>UvEventLoop._on_read</vh></v>
<v t="ekr.20181012124134.319"><vh>UvEventLoop._on_write</vh></v>
<v t="ekr.20181012124134.320"><vh>UvEventLoop._on_exit</vh></v>
<v t="ekr.20181012124134.321"><vh>UvEventLoop._disconnected</vh></v>
<v t="ekr.20181012124134.322"><vh>UvEventLoop._connect_tcp</vh></v>
<v t="ekr.20181012124134.323"><vh>UvEventLoop._connect_socket</vh></v>
<v t="ekr.20181012124134.324"><vh>UvEventLoop._connect_stdio</vh></v>
<v t="ekr.20181012124134.325"><vh>UvEventLoop._connect_child</vh></v>
<v t="ekr.20181012124134.326"><vh>UvEventLoop._start_reading</vh></v>
<v t="ekr.20181012124134.327"><vh>UvEventLoop._send</vh></v>
<v t="ekr.20181012124134.328"><vh>UvEventLoop._run</vh></v>
<v t="ekr.20181012124134.329"><vh>UvEventLoop._stop</vh></v>
<v t="ekr.20181012124134.330"><vh>UvEventLoop._close</vh></v>
<v t="ekr.20181012124134.331"><vh>UvEventLoop._threadsafe_call</vh></v>
<v t="ekr.20181012124134.332"><vh>UvEventLoop._on_async</vh></v>
<v t="ekr.20181012124134.333"><vh>UvEventLoop._setup_signals</vh></v>
<v t="ekr.20181012124134.334"><vh>UvEventLoop._teardown_signals</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20181012124134.338"><vh>@path plugin</vh>
<v t="ekr.20181012124135.1"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20181012124134.339"><vh>@@clean decorators.py</vh>
<v t="ekr.20181012124134.341"><vh>plugin</vh></v>
<v t="ekr.20181012124134.342"><vh>rpc_export</vh></v>
<v t="ekr.20181012124134.343"><vh>command</vh></v>
<v t="ekr.20181012124134.344"><vh>autocmd</vh></v>
<v t="ekr.20181012124134.345"><vh>function</vh></v>
<v t="ekr.20181012124134.346"><vh>shutdown_hook</vh></v>
<v t="ekr.20181012124134.347"><vh>decode</vh></v>
<v t="ekr.20181012124134.348"><vh>encoding</vh></v>
</v>
<v t="ekr.20181012124134.349"><vh>@@clean host.py</vh>
<v t="ekr.20181012124134.351"><vh>class Host(object)</vh>
<v t="ekr.20181012124134.352"><vh>Host.__init__</vh></v>
<v t="ekr.20181012124134.353"><vh>Host._on_async_err</vh></v>
<v t="ekr.20181012124134.354"><vh>Host.start</vh></v>
<v t="ekr.20181012124134.355"><vh>Host.shutdown</vh></v>
<v t="ekr.20181012124134.356"><vh>Host._wrap_function</vh></v>
<v t="ekr.20181012124134.357"><vh>Host._on_request</vh></v>
<v t="ekr.20181012124134.358"><vh>Host._on_notification</vh></v>
<v t="ekr.20181012124134.359"><vh>Host._missing_handler_error</vh></v>
<v t="ekr.20181012124134.360"><vh>Host._load</vh></v>
<v t="ekr.20181012124134.361"><vh>Host._unload</vh></v>
<v t="ekr.20181012124134.362"><vh>Host._discover_classes</vh></v>
<v t="ekr.20181012124134.363"><vh>Host._discover_functions</vh></v>
<v t="ekr.20181012124134.364"><vh>Host._copy_attributes</vh></v>
<v t="ekr.20181012124134.365"><vh>Host._on_specs_request</vh></v>
<v t="ekr.20181012124134.366"><vh>Host._configure_nvim_for</vh></v>
</v>
</v>
<v t="ekr.20181012124134.367"><vh>@@clean script_host.py</vh>
<v t="ekr.20181012124134.369"><vh>class ScriptHost(object)</vh>
<v t="ekr.20181012124134.370"><vh>ScriptHost.__init__</vh></v>
<v t="ekr.20181012124134.371"><vh>ScriptHost.setup</vh></v>
<v t="ekr.20181012124134.372"><vh>ScriptHost.teardown</vh></v>
<v t="ekr.20181012124134.373"><vh>ScriptHost.python_execute</vh></v>
<v t="ekr.20181012124134.374"><vh>ScriptHost.python_execute_file</vh></v>
<v t="ekr.20181012124134.375"><vh>ScriptHost.python_do_range</vh></v>
<v t="ekr.20181012124134.376"><vh>ScriptHost.python_eval</vh></v>
<v t="ekr.20181012124134.377"><vh>ScriptHost.python_chdir</vh></v>
<v t="ekr.20181012124134.378"><vh>ScriptHost._set_current_range</vh></v>
</v>
<v t="ekr.20181012124134.379"><vh>class RedirectStream(io.IOBase)</vh>
<v t="ekr.20181012124134.380"><vh>RedirectStream.__init__</vh></v>
<v t="ekr.20181012124134.381"><vh>RedirectStream.write</vh></v>
<v t="ekr.20181012124134.382"><vh>RedirectStream.writelines</vh></v>
</v>
<v t="ekr.20181012124134.383"><vh>num_to_str</vh></v>
<v t="ekr.20181012124134.384"><vh>class LegacyVim(Nvim)</vh></v>
<v t="ekr.20181012124134.386"><vh>path_hook</vh></v>
<v t="ekr.20181012124134.387"><vh>discover_runtime_directories</vh></v>
</v>
</v>
</v>
<v t="ekr.20181012124134.299"></v>
</vnodes>
<tnodes>
<t tx="ekr.20181012123120.1">'''Recursively import all python files in a directory and clean the result.'''
@tabwidth -4 # For a better match.
g.cls()
c.recursiveImport(
    dir_ = r'C:\Anaconda3\Lib\site-packages\neovim',
    kind = '@@clean', # '@auto', '@@clean', '@nosent','@file',
    add_path=True,
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py',] # ['.py', '.js','.vue',],
)
# c.expandAllSubheads()</t>
<t tx="ekr.20181012124134.10">def __init__(self, **kwargs):
    """Create the Version object."""
    self.__dict__.update(kwargs)

</t>
<t tx="ekr.20181012124134.100">def append(self, lines, i=None):
    i = self._normalize_index(i)
    if i is None:
        i = self.end + 1
    self._buffer.append(lines, i)

</t>
<t tx="ekr.20181012124134.101">def _normalize_index(self, index):
    if index is None:
        return None
    if index &lt; 0:
        index = self.end
    else:
        index += self.start
        if index &gt; self.end:
            index = self.end
    return index
</t>
<t tx="ekr.20181012124134.102">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""Code shared between the API classes."""
import functools

from msgpack import unpackb

from ..compat import unicode_errors_default


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.104">class Remote(object):

    """Base class for Nvim objects(buffer/window/tabpage).

    Each type of object has it's own specialized class with API wrappers around
    the msgpack-rpc session. This implements equality which takes the remote
    object handle into consideration.
    """

    @others
</t>
<t tx="ekr.20181012124134.105">def __init__(self, session, code_data):
    """Initialize from session and code_data immutable object.

    The `code_data` contains serialization information required for
    msgpack-rpc calls. It must be immutable for Buffer equality to work.
    """
    self._session = session
    self.code_data = code_data
    self.handle = unpackb(code_data[1])
    self.api = RemoteApi(self, self._api_prefix)
    self.vars = RemoteMap(self, self._api_prefix + 'get_var',
                          self._api_prefix + 'set_var')
    self.options = RemoteMap(self, self._api_prefix + 'get_option',
                             self._api_prefix + 'set_option')

</t>
<t tx="ekr.20181012124134.106">def __eq__(self, other):
    """Return True if `self` and `other` are the same object."""
    return (hasattr(other, 'code_data') and
            other.code_data == self.code_data)

</t>
<t tx="ekr.20181012124134.107">def __hash__(self):
    """Return hash based on remote object id."""
    return self.code_data.__hash__()

</t>
<t tx="ekr.20181012124134.108">def request(self, name, *args, **kwargs):
    """Wrapper for nvim.request."""
    return self._session.request(name, self, *args, **kwargs)


</t>
<t tx="ekr.20181012124134.109">class RemoteApi(object):

    """Wrapper to allow api methods to be called like python methods."""

    @others
</t>
<t tx="ekr.20181012124134.11">def __repr__(self):
    """Return str representation of the Version."""
    keys = sorted(self.__dict__)
    items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
    return "{}({})".format(type(self).__name__, ", ".join(items))

</t>
<t tx="ekr.20181012124134.110">def __init__(self, obj, api_prefix):
    """Initialize a RemoteApi with object and api prefix."""
    self._obj = obj
    self._api_prefix = api_prefix

</t>
<t tx="ekr.20181012124134.111">def __getattr__(self, name):
    """Return wrapper to named api method."""
    return functools.partial(self._obj.request, self._api_prefix + name)


</t>
<t tx="ekr.20181012124134.112">class RemoteMap(object):

    """Represents a string-&gt;object map stored in Nvim.

    This is the dict counterpart to the `RemoteSequence` class, but it is used
    as a generic way of retrieving values from the various map-like data
    structures present in Nvim.

    It is used to provide a dict-like API to vim variables and options.
    """

    @others
</t>
<t tx="ekr.20181012124134.113">def __init__(self, obj, get_method, set_method=None):
    """Initialize a RemoteMap with session, getter/setter."""
    self._get = functools.partial(obj.request, get_method)
    self._set = None
    if set_method:
        self._set = functools.partial(obj.request, set_method)

</t>
<t tx="ekr.20181012124134.114">def __getitem__(self, key):
    """Return a map value by key."""
    return self._get(key)

</t>
<t tx="ekr.20181012124134.115">def __setitem__(self, key, value):
    """Set a map value by key(if the setter was provided)."""
    if not self._set:
        raise TypeError('This dict is read-only')
    self._set(key, value)

</t>
<t tx="ekr.20181012124134.116">def __delitem__(self, key):
    """Delete a map value by associating None with the key."""
    if not self._set:
        raise TypeError('This dict is read-only')
    return self._set(key, None)

</t>
<t tx="ekr.20181012124134.117">def __contains__(self, key):
    """Check if key is present in the map."""
    try:
        self._get(key)
        return True
    except Exception:
        return False

</t>
<t tx="ekr.20181012124134.118">def get(self, key, default=None):
    """Return value for key if present, else a default value."""
    try:
        return self._get(key)
    except Exception:
        return default


</t>
<t tx="ekr.20181012124134.119">class RemoteSequence(object):

    """Represents a sequence of objects stored in Nvim.

    This class is used to wrap msgapck-rpc functions that work on Nvim
    sequences(of lines, buffers, windows and tabpages) with an API that
    is similar to the one provided by the python-vim interface.

    For example, the 'windows' property of the `Nvim` class is a RemoteSequence
    sequence instance, and the expression `nvim.windows[0]` is translated to
    session.request('nvim_list_wins')[0].

    One important detail about this class is that all methods will fetch the
    sequence into a list and perform the necessary manipulation
    locally(iteration, indexing, counting, etc).
    """

    @others
</t>
<t tx="ekr.20181012124134.12">def __eq__(self, other):
    """Check if version is same as other."""
    return self.__dict__ == other.__dict__
</t>
<t tx="ekr.20181012124134.120">def __init__(self, session, method):
    """Initialize a RemoteSequence with session, method."""
    self._fetch = functools.partial(session.request, method)

</t>
<t tx="ekr.20181012124134.121">def __len__(self):
    """Return the length of the remote sequence."""
    return len(self._fetch())

</t>
<t tx="ekr.20181012124134.122">def __getitem__(self, idx):
    """Return a sequence item by index."""
    if not isinstance(idx, slice):
        return self._fetch()[idx]
    return self._fetch()[idx.start:idx.stop]

</t>
<t tx="ekr.20181012124134.123">def __iter__(self):
    """Return an iterator for the sequence."""
    items = self._fetch()
    for item in items:
        yield item

</t>
<t tx="ekr.20181012124134.124">def __contains__(self, item):
    """Check if an item is present in the sequence."""
    return item in self._fetch()


</t>
<t tx="ekr.20181012124134.125">def _identity(obj, session, method, kind):
    return obj


</t>
<t tx="ekr.20181012124134.126">def decode_if_bytes(obj, mode=True):
    """Decode obj if it is bytes."""
    if mode is True:
        mode = unicode_errors_default
    if isinstance(obj, bytes):
        return obj.decode("utf-8", errors=mode)
    return obj


</t>
<t tx="ekr.20181012124134.127">def walk(fn, obj, *args, **kwargs):
    """Recursively walk an object graph applying `fn`/`args` to objects."""
    if type(obj) in [list, tuple]:
        return list(walk(fn, o, *args) for o in obj)
    if type(obj) is dict:
        return dict((walk(fn, k, *args), walk(fn, v, *args)) for k, v in
                    obj.items())
    return fn(obj, *args, **kwargs)
</t>
<t tx="ekr.20181012124134.128">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""Main Nvim interface."""
import os
import sys
from functools import partial
from traceback import format_stack

from msgpack import ExtType

from .buffer import Buffer
from .common import (Remote, RemoteApi, RemoteMap, RemoteSequence,
                     decode_if_bytes, walk)
from .tabpage import Tabpage
from .window import Window
from ..compat import IS_PYTHON3
from ..util import Version, format_exc_skip

__all__ = ('Nvim')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.129">os_chdir = os.chdir

lua_module = """
local a = vim.api
local function update_highlights(buf, src_id, hls, clear_first, clear_end)
  if clear_first ~= nil then
      a.nvim_buf_clear_highlight(buf, src_id, clear_first, clear_end)
  end
  for _,hl in pairs(hls) do
    local group, line, col_start, col_end = unpack(hl)
    if col_start == nil then
      col_start = 0
    end
    if col_end == nil then
      col_end = -1
    end
    a.nvim_buf_add_highlight(buf, src_id, group, line, col_start, col_end)
  end
end

local chid = ...
local mod = {update_highlights=update_highlights}
_G["_pynvim_"..chid] = mod
"""


</t>
<t tx="ekr.20181012124134.13">@path C:/Anaconda3/Lib/site-packages/neovim/
"""Python client for Nvim.

Client library for talking with Nvim processes via it's msgpack-rpc API.
"""
import logging
import os
import sys

from .api import Nvim
from .compat import IS_PYTHON3
from .msgpack_rpc import (ErrorResponse, child_session, socket_session,
                          stdio_session, tcp_session)
from .plugin import (Host, autocmd, command, decode, encoding, function,
                     plugin, rpc_export, shutdown_hook)
from .util import Version


__all__ = ('tcp_session', 'socket_session', 'stdio_session', 'child_session',
           'start_host', 'autocmd', 'command', 'encoding', 'decode',
           'function', 'plugin', 'rpc_export', 'Host', 'Nvim', 'VERSION',
           'shutdown_hook', 'attach', 'setup_logging', 'ErrorResponse')


VERSION = Version(major=0, minor=2, patch=6, prerelease='')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.130">class Nvim(object):

    """Class that represents a remote Nvim instance.

    This class is main entry point to Nvim remote API, it is a wrapper
    around Session instances.

    The constructor of this class must not be called directly. Instead, the
    `from_session` class method should be used to create the first instance
    from a raw `Session` instance.

    Subsequent instances for the same session can be created by calling the
    `with_decode` instance method to change the decoding behavior or
    `SubClass.from_nvim(nvim)` where `SubClass` is a subclass of `Nvim`, which
    is useful for having multiple `Nvim` objects that behave differently
    without one affecting the other.

    When this library is used on python3.4+, asyncio event loop is guaranteed
    to be used. It is available as the "loop" attribute of this class. Note
    that asyncio callbacks cannot make blocking requests, which includes
    accessing state-dependent attributes. They should instead schedule another
    callback using nvim.async_call, which will not have this restriction.
    """

    @others
</t>
<t tx="ekr.20181012124134.131">@classmethod
def from_session(cls, session):
    """Create a new Nvim instance for a Session instance.

    This method must be called to create the first Nvim instance, since it
    queries Nvim metadata for type information and sets a SessionHook for
    creating specialized objects from Nvim remote handles.
    """
    session.error_wrapper = lambda e: NvimError(e[1])
    channel_id, metadata = session.request(b'vim_get_api_info')

    if IS_PYTHON3:
        # decode all metadata strings for python3
        metadata = walk(decode_if_bytes, metadata)

    types = {
        metadata['types']['Buffer']['id']: Buffer,
        metadata['types']['Window']['id']: Window,
        metadata['types']['Tabpage']['id']: Tabpage,
    }

    return cls(session, channel_id, metadata, types)

</t>
<t tx="ekr.20181012124134.132">@classmethod
def from_nvim(cls, nvim):
    """Create a new Nvim instance from an existing instance."""
    return cls(nvim._session, nvim.channel_id, nvim.metadata,
               nvim.types, nvim._decode, nvim._err_cb)

</t>
<t tx="ekr.20181012124134.133">def __init__(self, session, channel_id, metadata, types,
             decode=False, err_cb=None):
    """Initialize a new Nvim instance. This method is module-private."""
    self._session = session
    self.channel_id = channel_id
    self.metadata = metadata
    version = metadata.get("version", {"api_level": 0})
    self.version = Version(**version)
    self.types = types
    self.api = RemoteApi(self, 'nvim_')
    self.vars = RemoteMap(self, 'nvim_get_var', 'nvim_set_var')
    self.vvars = RemoteMap(self, 'nvim_get_vvar', None)
    self.options = RemoteMap(self, 'nvim_get_option', 'nvim_set_option')
    self.buffers = Buffers(self)
    self.windows = RemoteSequence(self, 'nvim_list_wins')
    self.tabpages = RemoteSequence(self, 'nvim_list_tabpages')
    self.current = Current(self)
    self.session = CompatibilitySession(self)
    self.funcs = Funcs(self)
    self.lua = LuaFuncs(self)
    self.error = NvimError
    self._decode = decode
    self._err_cb = err_cb

    # only on python3.4+ we expose asyncio
    if IS_PYTHON3 and os.name != 'nt':
        self.loop = self._session.loop._loop

</t>
<t tx="ekr.20181012124134.134">def _from_nvim(self, obj, decode=None):
    if decode is None:
        decode = self._decode
    if type(obj) is ExtType:
        cls = self.types[obj.code]
        return cls(self, (obj.code, obj.data))
    if decode:
        obj = decode_if_bytes(obj, decode)
    return obj

</t>
<t tx="ekr.20181012124134.135">def _to_nvim(self, obj):
    if isinstance(obj, Remote):
        return ExtType(*obj.code_data)
    return obj

</t>
<t tx="ekr.20181012124134.136">def _get_lua_private(self):
    if not getattr(self._session, "_has_lua", False):
        self.exec_lua(lua_module, self.channel_id)
        self._session._has_lua = True
    return getattr(self.lua, "_pynvim_{}".format(self.channel_id))

</t>
<t tx="ekr.20181012124134.137">def request(self, name, *args, **kwargs):
    r"""Send an API request or notification to nvim.

    It is rarely needed to call this function directly, as most API
    functions have python wrapper functions. The `api` object can
    be also be used to call API functions as methods:

        vim.api.err_write('ERROR\n', async_=True)
        vim.current.buffer.api.get_mark('.')

    is equivalent to

        vim.request('nvim_err_write', 'ERROR\n', async_=True)
        vim.request('nvim_buf_get_mark', vim.current.buffer, '.')


    Normally a blocking request will be sent.  If the `async_` flag is
    present and True, a asynchronous notification is sent instead. This
    will never block, and the return value or error is ignored.
    """
    decode = kwargs.pop('decode', self._decode)
    args = walk(self._to_nvim, args)
    res = self._session.request(name, *args, **kwargs)
    return walk(self._from_nvim, res, decode=decode)

</t>
<t tx="ekr.20181012124134.138">def next_message(self):
    """Block until a message(request or notification) is available.

    If any messages were previously enqueued, return the first in queue.
    If not, run the event loop until one is received.
    """
    msg = self._session.next_message()
    if msg:
        return walk(self._from_nvim, msg)

</t>
<t tx="ekr.20181012124134.139">def run_loop(self, request_cb, notification_cb,
             setup_cb=None, err_cb=None):
    """Run the event loop to receive requests and notifications from Nvim.

    This should not be called from a plugin running in the host, which
    already runs the loop and dispatches events to plugins.
    """
    if err_cb is None:
        err_cb = sys.stderr.write
    self._err_cb = err_cb

    def filter_request_cb(name, args):
        name = self._from_nvim(name)
        args = walk(self._from_nvim, args)
        try:
            result = request_cb(name, args)
        except Exception:
            msg = ("error caught in request handler '{} {}'\n{}\n\n"
                   .format(name, args, format_exc_skip(1)))
            self._err_cb(msg)
            raise
        return walk(self._to_nvim, result)

    def filter_notification_cb(name, args):
        name = self._from_nvim(name)
        args = walk(self._from_nvim, args)
        try:
            notification_cb(name, args)
        except Exception:
            msg = ("error caught in notification handler '{} {}'\n{}\n\n"
                   .format(name, args, format_exc_skip(1)))
            self._err_cb(msg)
            raise

    self._session.run(filter_request_cb, filter_notification_cb, setup_cb)

</t>
<t tx="ekr.20181012124134.140">def stop_loop(self):
    """Stop the event loop being started with `run_loop`."""
    self._session.stop()

</t>
<t tx="ekr.20181012124134.141">def close(self):
    """Close the nvim session and release its resources."""
    self._session.close()

</t>
<t tx="ekr.20181012124134.142">def __enter__(self):
    """Enter nvim session as a context manager."""
    return self

</t>
<t tx="ekr.20181012124134.143">def __exit__(self, *exc_info):
    """Exit nvim session as a context manager.

    Closes the event loop.
    """
    self.close()

</t>
<t tx="ekr.20181012124134.144">def with_decode(self, decode=True):
    """Initialize a new Nvim instance."""
    return Nvim(self._session, self.channel_id,
                self.metadata, self.types, decode, self._err_cb)

</t>
<t tx="ekr.20181012124134.145">def ui_attach(self, width, height, rgb):
    """Register as a remote UI.

    After this method is called, the client will receive redraw
    notifications.
    """
    return self.request('ui_attach', width, height, rgb)

</t>
<t tx="ekr.20181012124134.146">def ui_detach(self):
    """Unregister as a remote UI."""
    return self.request('ui_detach')

</t>
<t tx="ekr.20181012124134.147">def ui_try_resize(self, width, height):
    """Notify nvim that the client window has resized.

    If possible, nvim will send a redraw request to resize.
    """
    return self.request('ui_try_resize', width, height)

</t>
<t tx="ekr.20181012124134.148">def subscribe(self, event):
    """Subscribe to a Nvim event."""
    return self.request('nvim_subscribe', event)

</t>
<t tx="ekr.20181012124134.149">def unsubscribe(self, event):
    """Unsubscribe to a Nvim event."""
    return self.request('nvim_unsubscribe', event)

</t>
<t tx="ekr.20181012124134.15">def start_host(session=None):
    """Promote the current process into python plugin host for Nvim.

    Start msgpack-rpc event loop for `session`, listening for Nvim requests
    and notifications. It registers Nvim commands for loading/unloading
    python plugins.

    The sys.stdout and sys.stderr streams are redirected to Nvim through
    `session`. That means print statements probably won't work as expected
    while this function doesn't return.

    This function is normally called at program startup and could have been
    defined as a separate executable. It is exposed as a library function for
    testing purposes only.
    """
    plugins = []
    for arg in sys.argv:
        _, ext = os.path.splitext(arg)
        if ext == '.py':
            plugins.append(arg)
        elif os.path.isdir(arg):
            init = os.path.join(arg, '__init__.py')
            if os.path.isfile(init):
                plugins.append(arg)

    # This is a special case to support the old workaround of
    # adding an empty .py file to make a package directory
    # visible, and it should be removed soon.
    for path in list(plugins):
        dup = path + ".py"
        if os.path.isdir(path) and dup in plugins:
            plugins.remove(dup)

    # Special case: the legacy scripthost receives a single relative filename
    # while the rplugin host will receive absolute paths.
    if plugins == ["script_host.py"]:
        name = "script"
    else:
        name = "rplugin"

    setup_logging(name)

    if not session:
        session = stdio_session()
    nvim = Nvim.from_session(session)

    if nvim.version.api_level &lt; 1:
        sys.stderr.write("This version of the neovim python package "
                         "requires nvim 0.1.6 or later")
        sys.exit(1)

    host = Host(nvim)
    host.start(plugins)


</t>
<t tx="ekr.20181012124134.150">def command(self, string, **kwargs):
    """Execute a single ex command."""
    return self.request('nvim_command', string, **kwargs)

</t>
<t tx="ekr.20181012124134.151">def command_output(self, string):
    """Execute a single ex command and return the output."""
    return self.request('nvim_command_output', string)

</t>
<t tx="ekr.20181012124134.152">def eval(self, string, **kwargs):
    """Evaluate a vimscript expression."""
    return self.request('nvim_eval', string, **kwargs)

</t>
<t tx="ekr.20181012124134.153">def call(self, name, *args, **kwargs):
    """Call a vimscript function."""
    return self.request('nvim_call_function', name, args, **kwargs)

</t>
<t tx="ekr.20181012124134.154">def exec_lua(self, code, *args, **kwargs):
    """Execute lua code.

    Additional parameters are available as `...` inside the lua chunk.
    Only statements are executed.  To evaluate an expression, prefix it
    with `return`: `return my_function(...)`

    There is a shorthand syntax to call lua functions with arguments:

        nvim.lua.func(1,2)
        nvim.lua.mymod.myfunction(data, async_=True)

    is equivalent to

        nvim.exec_lua("return func(...)", 1, 2)
        nvim.exec_lua("mymod.myfunction(...)", data, async_=True)

    Note that with `async_=True` there is no return value.
    """
    return self.request('nvim_execute_lua', code, args, **kwargs)

</t>
<t tx="ekr.20181012124134.155">def strwidth(self, string):
    """Return the number of display cells `string` occupies.

    Tab is counted as one cell.
    """
    return self.request('nvim_strwidth', string)

</t>
<t tx="ekr.20181012124134.156">def list_runtime_paths(self):
    """Return a list of paths contained in the 'runtimepath' option."""
    return self.request('nvim_list_runtime_paths')

</t>
<t tx="ekr.20181012124134.157">def foreach_rtp(self, cb):
    """Invoke `cb` for each path in 'runtimepath'.

    Call the given callable for each path in 'runtimepath' until either
    callable returns something but None, the exception is raised or there
    are no longer paths. If stopped in case callable returned non-None,
    vim.foreach_rtp function returns the value returned by callable.
    """
    for path in self.request('nvim_list_runtime_paths'):
        try:
            if cb(path) is not None:
                break
        except Exception:
            break

</t>
<t tx="ekr.20181012124134.158">def chdir(self, dir_path):
    """Run os.chdir, then all appropriate vim stuff."""
    os_chdir(dir_path)
    return self.request('nvim_set_current_dir', dir_path)

</t>
<t tx="ekr.20181012124134.159">def feedkeys(self, keys, options='', escape_csi=True):
    """Push `keys` to Nvim user input buffer.

    Options can be a string with the following character flags:
    - 'm': Remap keys. This is default.
    - 'n': Do not remap keys.
    - 't': Handle keys as if typed; otherwise they are handled as if coming
           from a mapping. This matters for undo, opening folds, etc.
    """
    return self.request('nvim_feedkeys', keys, options, escape_csi)

</t>
<t tx="ekr.20181012124134.16">def attach(session_type, address=None, port=None,
           path=None, argv=None, decode=None):
    """Provide a nicer interface to create python api sessions.

    Previous machinery to create python api sessions is still there. This only
    creates a facade function to make things easier for the most usual cases.
    Thus, instead of:
        from neovim import socket_session, Nvim
        session = tcp_session(address=&lt;address&gt;, port=&lt;port&gt;)
        nvim = Nvim.from_session(session)
    You can now do:
        from neovim import attach
        nvim = attach('tcp', address=&lt;address&gt;, port=&lt;port&gt;)
    And also:
        nvim = attach('socket', path=&lt;path&gt;)
        nvim = attach('child', argv=&lt;argv&gt;)
        nvim = attach('stdio')

    When the session is not needed anymore, it is recommended to explicitly
    close it:
       nvim.close()
    It is also possible to use the session as a context mangager:
       with attach('socket', path=thepath) as nvim:
           print(nvim.funcs.getpid())
           print(nvim.current.line)
    This will automatically close the session when you're done with it, or
    when an error occured.


    """
    session = (tcp_session(address, port) if session_type == 'tcp' else
               socket_session(path) if session_type == 'socket' else
               stdio_session() if session_type == 'stdio' else
               child_session(argv) if session_type == 'child' else
               None)

    if not session:
        raise Exception('Unknown session type "%s"' % session_type)

    if decode is None:
        decode = IS_PYTHON3

    return Nvim.from_session(session).with_decode(decode)


</t>
<t tx="ekr.20181012124134.160">def input(self, bytes):
    """Push `bytes` to Nvim low level input buffer.

    Unlike `feedkeys()`, this uses the lowest level input buffer and the
    call is not deferred. It returns the number of bytes actually
    written(which can be less than what was requested if the buffer is
    full).
    """
    return self.request('nvim_input', bytes)

</t>
<t tx="ekr.20181012124134.161">def replace_termcodes(self, string, from_part=False, do_lt=True,
                      special=True):
    r"""Replace any terminal code strings by byte sequences.

    The returned sequences are Nvim's internal representation of keys,
    for example:

    &lt;esc&gt; -&gt; '\x1b'
    &lt;cr&gt;  -&gt; '\r'
    &lt;c-l&gt; -&gt; '\x0c'
    &lt;up&gt;  -&gt; '\x80ku'

    The returned sequences can be used as input to `feedkeys`.
    """
    return self.request('nvim_replace_termcodes', string,
                        from_part, do_lt, special)

</t>
<t tx="ekr.20181012124134.162">def out_write(self, msg, **kwargs):
    """Print `msg` as a normal message."""
    return self.request('nvim_out_write', msg, **kwargs)

</t>
<t tx="ekr.20181012124134.163">def err_write(self, msg, **kwargs):
    """Print `msg` as an error message."""
    return self.request('nvim_err_write', msg, **kwargs)

</t>
<t tx="ekr.20181012124134.164">def quit(self, quit_command='qa!'):
    """Send a quit command to Nvim.

    By default, the quit command is 'qa!' which will make Nvim quit without
    saving anything.
    """
    try:
        self.command(quit_command)
    except IOError:
        # sending a quit command will raise an IOError because the
        # connection is closed before a response is received. Safe to
        # ignore it.
        pass

</t>
<t tx="ekr.20181012124134.165">def new_highlight_source(self):
    """Return new src_id for use with Buffer.add_highlight."""
    return self.current.buffer.add_highlight("", 0, src_id=0)

</t>
<t tx="ekr.20181012124134.166">def async_call(self, fn, *args, **kwargs):
    """Schedule `fn` to be called by the event loop soon.

    This function is thread-safe, and is the only way code not
    on the main thread could interact with nvim api objects.

    This function can also be called in a synchronous
    event handler, just before it returns, to defer execution
    that shouldn't block neovim.
    """
    call_point = ''.join(format_stack(None, 5)[:-1])

    def handler():
        try:
            fn(*args, **kwargs)
        except Exception as err:
            msg = ("error caught while executing async callback:\n"
                   "{!r}\n{}\n \nthe call was requested at\n{}"
                   .format(err, format_exc_skip(1), call_point))
            self._err_cb(msg)
            raise
    self._session.threadsafe_call(handler)


</t>
<t tx="ekr.20181012124134.167">class Buffers(object):

    """Remote NVim buffers.

    Currently the interface for interacting with remote NVim buffers is the
    `nvim_list_bufs` msgpack-rpc function. Most methods fetch the list of
    buffers from NVim.

    Conforms to *python-buffers*.
    """

    @others
</t>
<t tx="ekr.20181012124134.168">def __init__(self, nvim):
    """Initialize a Buffers object with Nvim object `nvim`."""
    self._fetch_buffers = nvim.api.list_bufs

</t>
<t tx="ekr.20181012124134.169">def __len__(self):
    """Return the count of buffers."""
    return len(self._fetch_buffers())

</t>
<t tx="ekr.20181012124134.17">def setup_logging(name):
    """Setup logging according to environment variables."""
    logger = logging.getLogger(__name__)
    if 'NVIM_PYTHON_LOG_FILE' in os.environ:
        prefix = os.environ['NVIM_PYTHON_LOG_FILE'].strip()
        major_version = sys.version_info[0]
        logfile = '{}_py{}_{}'.format(prefix, major_version, name)
        handler = logging.FileHandler(logfile, 'w', 'utf-8')
        handler.formatter = logging.Formatter(
            '%(asctime)s [%(levelname)s @ '
            '%(filename)s:%(funcName)s:%(lineno)s] %(process)s - %(message)s')
        logging.root.addHandler(handler)
        level = logging.INFO
        if 'NVIM_PYTHON_LOG_LEVEL' in os.environ:
            lvl = getattr(logging,
                          os.environ['NVIM_PYTHON_LOG_LEVEL'].strip(),
                          level)
            if isinstance(lvl, int):
                level = lvl
        logger.setLevel(level)


</t>
<t tx="ekr.20181012124134.170">def __getitem__(self, number):
    """Return the Buffer object matching buffer number `number`."""
    for b in self._fetch_buffers():
        if b.number == number:
            return b
    raise KeyError(number)

</t>
<t tx="ekr.20181012124134.171">def __contains__(self, b):
    """Return whether Buffer `b` is a known valid buffer."""
    return isinstance(b, Buffer) and b.valid

</t>
<t tx="ekr.20181012124134.172">def __iter__(self):
    """Return an iterator over the list of buffers."""
    return iter(self._fetch_buffers())


</t>
<t tx="ekr.20181012124134.173">class CompatibilitySession(object):

    """Helper class for API compatibility."""

    def __init__(self, nvim):
        self.threadsafe_call = nvim.async_call


</t>
<t tx="ekr.20181012124134.175">class Current(object):

    """Helper class for emulating vim.current from python-vim."""

    @others
</t>
<t tx="ekr.20181012124134.176">def __init__(self, session):
    self._session = session
    self.range = None

</t>
<t tx="ekr.20181012124134.177">@property
def line(self):
    return self._session.request('nvim_get_current_line')

@line.setter
def line(self, line):
    return self._session.request('nvim_set_current_line', line)

</t>
<t tx="ekr.20181012124134.179">@property
def buffer(self):
    return self._session.request('nvim_get_current_buf')

@buffer.setter
def buffer(self, buffer):
    return self._session.request('nvim_set_current_buf', buffer)

</t>
<t tx="ekr.20181012124134.18"># Required for python 2.6
class NullHandler(logging.Handler):
    def emit(self, record):
        pass


if not logging.root.handlers:
    logging.root.addHandler(NullHandler())
</t>
<t tx="ekr.20181012124134.181">@property
def window(self):
    return self._session.request('nvim_get_current_win')

@window.setter
def window(self, window):
    return self._session.request('nvim_set_current_win', window)

</t>
<t tx="ekr.20181012124134.183">@property
def tabpage(self):
    return self._session.request('nvim_get_current_tabpage')

@tabpage.setter
def tabpage(self, tabpage):
    return self._session.request('nvim_set_current_tabpage', tabpage)


</t>
<t tx="ekr.20181012124134.184"></t>
<t tx="ekr.20181012124134.185">class Funcs(object):

    """Helper class for functional vimscript interface."""

    @others
</t>
<t tx="ekr.20181012124134.186">def __init__(self, nvim):
    self._nvim = nvim

</t>
<t tx="ekr.20181012124134.187">def __getattr__(self, name):
    return partial(self._nvim.call, name)


</t>
<t tx="ekr.20181012124134.188">class LuaFuncs(object):

    """Wrapper to allow lua functions to be called like python methods."""

    @others
</t>
<t tx="ekr.20181012124134.189">def __init__(self, nvim, name=""):
    self._nvim = nvim
    self.name = name

</t>
<t tx="ekr.20181012124134.190">def __getattr__(self, name):
    """Return wrapper to named api method."""
    prefix = self.name + "." if self.name else ""
    return LuaFuncs(self._nvim, prefix + name)

</t>
<t tx="ekr.20181012124134.191">def __call__(self, *args, **kwargs):
    # first new function after keyword rename, be a bit noisy
    if 'async' in kwargs:
        raise ValueError('"async" argument is not allowed. '
                         'Use "async_" instead.')
    async_ = kwargs.get('async_', False)
    pattern = "return {}(...)" if not async_ else "{}(...)"
    code = pattern.format(self.name)
    return self._nvim.exec_lua(code, *args, **kwargs)


</t>
<t tx="ekr.20181012124134.192">class NvimError(Exception):
    pass
</t>
<t tx="ekr.20181012124134.193">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""API for working with Nvim tabpages."""
from .common import Remote, RemoteSequence


__all__ = ('Tabpage')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.195">class Tabpage(Remote):
    """A remote Nvim tabpage."""

    _api_prefix = "nvim_tabpage_"

    @others
</t>
<t tx="ekr.20181012124134.196">def __init__(self, *args):
    """Initialize from session and code_data immutable object.

    The `code_data` contains serialization information required for
    msgpack-rpc calls. It must be immutable for Buffer equality to work.
    """
    super(Tabpage, self).__init__(*args)
    self.windows = RemoteSequence(self, 'nvim_tabpage_list_wins')

</t>
<t tx="ekr.20181012124134.197">@property
def window(self):
    """Get the `Window` currently focused on the tabpage."""
    return self.request('nvim_tabpage_get_win')

</t>
<t tx="ekr.20181012124134.198">@property
def valid(self):
    """Return True if the tabpage still exists."""
    return self.request('nvim_tabpage_is_valid')

</t>
<t tx="ekr.20181012124134.199">@property
def number(self):
    """Get the tabpage number."""
    return self.request('nvim_tabpage_get_number')
</t>
<t tx="ekr.20181012124134.2"></t>
<t tx="ekr.20181012124134.200">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""API for working with Nvim windows."""
from .common import Remote


__all__ = ('Window')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.202">class Window(Remote):

    """A remote Nvim window."""

    _api_prefix = "nvim_win_"

    @others
</t>
<t tx="ekr.20181012124134.203">@property
def buffer(self):
    """Get the `Buffer` currently being displayed by the window."""
    return self.request('nvim_win_get_buf')

</t>
<t tx="ekr.20181012124134.204">@property
def cursor(self):
    """Get the (row, col) tuple with the current cursor position."""
    return self.request('nvim_win_get_cursor')

@cursor.setter
def cursor(self, pos):
    """Set the (row, col) tuple as the new cursor position."""
    return self.request('nvim_win_set_cursor', pos)

</t>
<t tx="ekr.20181012124134.206">@property
def height(self):
    """Get the window height in rows."""
    return self.request('nvim_win_get_height')

@height.setter
def height(self, height):
    """Set the window height in rows."""
    return self.request('nvim_win_set_height', height)

</t>
<t tx="ekr.20181012124134.208">@property
def width(self):
    """Get the window width in rows."""
    return self.request('nvim_win_get_width')

@width.setter
def width(self, width):
    """Set the window height in rows."""
    return self.request('nvim_win_set_width', width)

</t>
<t tx="ekr.20181012124134.210">@property
def row(self):
    """0-indexed, on-screen window position(row) in display cells."""
    return self.request('nvim_win_get_position')[0]

</t>
<t tx="ekr.20181012124134.211">@property
def col(self):
    """0-indexed, on-screen window position(col) in display cells."""
    return self.request('nvim_win_get_position')[1]

</t>
<t tx="ekr.20181012124134.212">@property
def tabpage(self):
    """Get the `Tabpage` that contains the window."""
    return self.request('nvim_win_get_tabpage')

</t>
<t tx="ekr.20181012124134.213">@property
def valid(self):
    """Return True if the window still exists."""
    return self.request('nvim_win_is_valid')

</t>
<t tx="ekr.20181012124134.214">@property
def number(self):
    """Get the window number."""
    return self.request('nvim_win_get_number')
</t>
<t tx="ekr.20181012124134.215">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""Nvim API subpackage.

This package implements a higher-level API that wraps msgpack-rpc `Session`
instances.
"""

from .buffer import Buffer
from .common import decode_if_bytes, walk
from .nvim import Nvim, NvimError
from .tabpage import Tabpage
from .window import Window


__all__ = ('Nvim', 'Buffer', 'Window', 'Tabpage', 'NvimError',
           'decode_if_bytes', 'walk')
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.218"></t>
<t tx="ekr.20181012124134.219">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/
"""Asynchronous msgpack-rpc handling in the event loop pipeline."""
import logging
from traceback import format_exc


logger = logging.getLogger(__name__)
debug, info, warn = (logger.debug, logger.info, logger.warning,)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.221">class AsyncSession(object):

    """Asynchronous msgpack-rpc layer that wraps a msgpack stream.

    This wraps the msgpack stream interface for reading/writing msgpack
    documents and exposes an interface for sending and receiving msgpack-rpc
    requests and notifications.
    """

    @others
</t>
<t tx="ekr.20181012124134.222">def __init__(self, msgpack_stream):
    """Wrap `msgpack_stream` on a msgpack-rpc interface."""
    self._msgpack_stream = msgpack_stream
    self._next_request_id = 1
    self._pending_requests = {}
    self._request_cb = self._notification_cb = None
    self._handlers = {
        0: self._on_request,
        1: self._on_response,
        2: self._on_notification
    }
    self.loop = msgpack_stream.loop

</t>
<t tx="ekr.20181012124134.223">def threadsafe_call(self, fn):
    """Wrapper around `MsgpackStream.threadsafe_call`."""
    self._msgpack_stream.threadsafe_call(fn)

</t>
<t tx="ekr.20181012124134.224">def request(self, method, args, response_cb):
    """Send a msgpack-rpc request to Nvim.

    A msgpack-rpc with method `method` and argument `args` is sent to
    Nvim. The `response_cb` function is called with when the response
    is available.
    """
    request_id = self._next_request_id
    self._next_request_id = request_id + 1
    self._msgpack_stream.send([0, request_id, method, args])
    self._pending_requests[request_id] = response_cb

</t>
<t tx="ekr.20181012124134.225">def notify(self, method, args):
    """Send a msgpack-rpc notification to Nvim.

    A msgpack-rpc with method `method` and argument `args` is sent to
    Nvim. This will have the same effect as a request, but no response
    will be recieved
    """
    self._msgpack_stream.send([2, method, args])

</t>
<t tx="ekr.20181012124134.226">def run(self, request_cb, notification_cb):
    """Run the event loop to receive requests and notifications from Nvim.

    While the event loop is running, `request_cb` and `_notification_cb`
    will be called whenever requests or notifications are respectively
    available.
    """
    self._request_cb = request_cb
    self._notification_cb = notification_cb
    self._msgpack_stream.run(self._on_message)
    self._request_cb = None
    self._notification_cb = None

</t>
<t tx="ekr.20181012124134.227">def stop(self):
    """Stop the event loop."""
    self._msgpack_stream.stop()

</t>
<t tx="ekr.20181012124134.228">def close(self):
    """Close the event loop."""
    self._msgpack_stream.close()

</t>
<t tx="ekr.20181012124134.229">def _on_message(self, msg):
    try:
        self._handlers.get(msg[0], self._on_invalid_message)(msg)
    except Exception:
        err_str = format_exc(5)
        warn(err_str)
        self._msgpack_stream.send([1, 0, err_str, None])

</t>
<t tx="ekr.20181012124134.230">def _on_request(self, msg):
    # request
    #   - msg[1]: id
    #   - msg[2]: method name
    #   - msg[3]: arguments
    debug('received request: %s, %s', msg[2], msg[3])
    self._request_cb(msg[2], msg[3], Response(self._msgpack_stream,
                                              msg[1]))

</t>
<t tx="ekr.20181012124134.231">def _on_response(self, msg):
    # response to a previous request:
    #   - msg[1]: the id
    #   - msg[2]: error(if any)
    #   - msg[3]: result(if not errored)
    debug('received response: %s, %s', msg[2], msg[3])
    self._pending_requests.pop(msg[1])(msg[2], msg[3])

</t>
<t tx="ekr.20181012124134.232">def _on_notification(self, msg):
    # notification/event
    #   - msg[1]: event name
    #   - msg[2]: arguments
    debug('received notification: %s, %s', msg[1], msg[2])
    self._notification_cb(msg[1], msg[2])

</t>
<t tx="ekr.20181012124134.233">def _on_invalid_message(self, msg):
    error = 'Received invalid message %s' % msg
    warn(error)
    self._msgpack_stream.send([1, 0, error, None])


</t>
<t tx="ekr.20181012124134.234">class Response(object):

    """Response to a msgpack-rpc request that came from Nvim.

    When Nvim sends a msgpack-rpc request, an instance of this class is
    created for remembering state required to send a response.
    """

    @others
</t>
<t tx="ekr.20181012124134.235">def __init__(self, msgpack_stream, request_id):
    """Initialize the Response instance."""
    self._msgpack_stream = msgpack_stream
    self._request_id = request_id

</t>
<t tx="ekr.20181012124134.236">def send(self, value, error=False):
    """Send the response.

    If `error` is True, it will be sent as an error.
    """
    if error:
        resp = [1, self._request_id, value, None]
    else:
        resp = [1, self._request_id, None, value]
    debug('sending response to request %d: %s', self._request_id, resp)
    self._msgpack_stream.send(resp)
</t>
<t tx="ekr.20181012124134.237">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/
"""Msgpack handling in the event loop pipeline."""
import logging

from msgpack import Packer, Unpacker

from ..compat import unicode_errors_default

logger = logging.getLogger(__name__)
debug, info, warn = (logger.debug, logger.info, logger.warning,)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.239">class MsgpackStream(object):

    """Two-way msgpack stream that wraps a event loop byte stream.

    This wraps the event loop interface for reading/writing bytes and
    exposes an interface for reading/writing msgpack documents.
    """

    @others
</t>
<t tx="ekr.20181012124134.240">def __init__(self, event_loop):
    """Wrap `event_loop` on a msgpack-aware interface."""
    self.loop = event_loop
    self._packer = Packer(encoding='utf-8',
                          unicode_errors=unicode_errors_default)
    self._unpacker = Unpacker()
    self._message_cb = None

</t>
<t tx="ekr.20181012124134.241">def threadsafe_call(self, fn):
    """Wrapper around `BaseEventLoop.threadsafe_call`."""
    self.loop.threadsafe_call(fn)

</t>
<t tx="ekr.20181012124134.242">def send(self, msg):
    """Queue `msg` for sending to Nvim."""
    debug('sent %s', msg)
    self.loop.send(self._packer.pack(msg))

</t>
<t tx="ekr.20181012124134.243">def run(self, message_cb):
    """Run the event loop to receive messages from Nvim.

    While the event loop is running, `message_cb` will be called whenever
    a message has been successfully parsed from the input stream.
    """
    self._message_cb = message_cb
    self.loop.run(self._on_data)
    self._message_cb = None

</t>
<t tx="ekr.20181012124134.244">def stop(self):
    """Stop the event loop."""
    self.loop.stop()

</t>
<t tx="ekr.20181012124134.245">def close(self):
    """Close the event loop."""
    self.loop.close()

</t>
<t tx="ekr.20181012124134.246">def _on_data(self, data):
    self._unpacker.feed(data)
    while True:
        try:
            debug('waiting for message...')
            msg = next(self._unpacker)
            debug('received message: %s', msg)
            self._message_cb(msg)
        except StopIteration:
            debug('unpacker needs more data...')
            break
</t>
<t tx="ekr.20181012124134.247">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/
"""Synchronous msgpack-rpc session layer."""
import logging
from collections import deque
from traceback import format_exc

import greenlet

from ..compat import check_async

logger = logging.getLogger(__name__)
error, debug, info, warn = (logger.error, logger.debug, logger.info,
                            logger.warning,)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.249">class Session(object):

    """Msgpack-rpc session layer that uses coroutines for a synchronous API.

    This class provides the public msgpack-rpc API required by this library.
    It uses the greenlet module to handle requests and notifications coming
    from Nvim with a synchronous API.
    """

    @others
</t>
<t tx="ekr.20181012124134.250">def __init__(self, async_session):
    """Wrap `async_session` on a synchronous msgpack-rpc interface."""
    self._async_session = async_session
    self._request_cb = self._notification_cb = None
    self._pending_messages = deque()
    self._is_running = False
    self._setup_exception = None
    self.loop = async_session.loop

</t>
<t tx="ekr.20181012124134.251">def threadsafe_call(self, fn, *args, **kwargs):
    """Wrapper around `AsyncSession.threadsafe_call`."""
    def handler():
        try:
            fn(*args, **kwargs)
        except Exception:
            warn("error caught while excecuting async callback\n%s\n",
                 format_exc())

    def greenlet_wrapper():
        gr = greenlet.greenlet(handler)
        gr.switch()

    self._async_session.threadsafe_call(greenlet_wrapper)

</t>
<t tx="ekr.20181012124134.252">def next_message(self):
    """Block until a message(request or notification) is available.

    If any messages were previously enqueued, return the first in queue.
    If not, run the event loop until one is received.
    """
    if self._is_running:
        raise Exception('Event loop already running')
    if self._pending_messages:
        return self._pending_messages.popleft()
    self._async_session.run(self._enqueue_request_and_stop,
                            self._enqueue_notification_and_stop)
    if self._pending_messages:
        return self._pending_messages.popleft()

</t>
<t tx="ekr.20181012124134.253">def request(self, method, *args, **kwargs):
    """Send a msgpack-rpc request and block until as response is received.

    If the event loop is running, this method must have been called by a
    request or notification handler running on a greenlet. In that case,
    send the quest and yield to the parent greenlet until a response is
    available.

    When the event loop is not running, it will perform a blocking request
    like this:
    - Send the request
    - Run the loop until the response is available
    - Put requests/notifications received while waiting into a queue

    If the `async_` flag is present and True, a asynchronous notification
    is sent instead. This will never block, and the return value or error
    is ignored.
    """
    async_ = check_async(kwargs.pop('async_', None), kwargs, False)
    if async_:
        self._async_session.notify(method, args)
        return

    if kwargs:
        raise ValueError("request got unsupported keyword argument(s): {}"
                         .format(', '.join(kwargs.keys())))

    if self._is_running:
        v = self._yielding_request(method, args)
    else:
        v = self._blocking_request(method, args)
    if not v:
        # EOF
        raise IOError('EOF')
    err, rv = v
    if err:
        info("'Received error: %s", err)
        raise self.error_wrapper(err)
    return rv

</t>
<t tx="ekr.20181012124134.254">def run(self, request_cb, notification_cb, setup_cb=None):
    """Run the event loop to receive requests and notifications from Nvim.

    Like `AsyncSession.run()`, but `request_cb` and `notification_cb` are
    inside greenlets.
    """
    self._request_cb = request_cb
    self._notification_cb = notification_cb
    self._is_running = True
    self._setup_exception = None

    def on_setup():
        try:
            setup_cb()
        except Exception as e:
            self._setup_exception = e
            self.stop()

    if setup_cb:
        # Create a new greenlet to handle the setup function
        gr = greenlet.greenlet(on_setup)
        gr.switch()

    if self._setup_exception:
        error('Setup error: {}'.format(self._setup_exception))
        raise self._setup_exception

    # Process all pending requests and notifications
    while self._pending_messages:
        msg = self._pending_messages.popleft()
        getattr(self, '_on_{}'.format(msg[0]))(*msg[1:])
    self._async_session.run(self._on_request, self._on_notification)
    self._is_running = False
    self._request_cb = None
    self._notification_cb = None

    if self._setup_exception:
        raise self._setup_exception

</t>
<t tx="ekr.20181012124134.255">def stop(self):
    """Stop the event loop."""
    self._async_session.stop()

</t>
<t tx="ekr.20181012124134.256">def close(self):
    """Close the event loop."""
    self._async_session.close()

</t>
<t tx="ekr.20181012124134.257">def _yielding_request(self, method, args):
    gr = greenlet.getcurrent()
    parent = gr.parent

    def response_cb(err, rv):
        debug('response is available for greenlet %s, switching back', gr)
        gr.switch(err, rv)

    self._async_session.request(method, args, response_cb)
    debug('yielding from greenlet %s to wait for response', gr)
    return parent.switch()

</t>
<t tx="ekr.20181012124134.258">def _blocking_request(self, method, args):
    result = []

    def response_cb(err, rv):
        result.extend([err, rv])
        self.stop()

    self._async_session.request(method, args, response_cb)
    self._async_session.run(self._enqueue_request,
                            self._enqueue_notification)
    return result

</t>
<t tx="ekr.20181012124134.259">def _enqueue_request_and_stop(self, name, args, response):
    self._enqueue_request(name, args, response)
    self.stop()

</t>
<t tx="ekr.20181012124134.260">def _enqueue_notification_and_stop(self, name, args):
    self._enqueue_notification(name, args)
    self.stop()

</t>
<t tx="ekr.20181012124134.261">def _enqueue_request(self, name, args, response):
    self._pending_messages.append(('request', name, args, response,))

</t>
<t tx="ekr.20181012124134.262">def _enqueue_notification(self, name, args):
    self._pending_messages.append(('notification', name, args,))

</t>
<t tx="ekr.20181012124134.263">def _on_request(self, name, args, response):
    def handler():
        try:
            rv = self._request_cb(name, args)
            debug('greenlet %s finished executing, ' +
                  'sending %s as response', gr, rv)
            response.send(rv)
        except ErrorResponse as err:
            warn("error response from request '%s %s': %s", name,
                 args, format_exc())
            response.send(err.args[0], error=True)
        except Exception as err:
            warn("error caught while processing request '%s %s': %s", name,
                 args, format_exc())
            response.send(repr(err) + "\n" + format_exc(5), error=True)
        debug('greenlet %s is now dying...', gr)

    # Create a new greenlet to handle the request
    gr = greenlet.greenlet(handler)
    debug('received rpc request, greenlet %s will handle it', gr)
    gr.switch()

</t>
<t tx="ekr.20181012124134.264">def _on_notification(self, name, args):
    def handler():
        try:
            self._notification_cb(name, args)
            debug('greenlet %s finished executing', gr)
        except Exception:
            warn("error caught while processing notification '%s %s': %s",
                 name, args, format_exc())

        debug('greenlet %s is now dying...', gr)

    gr = greenlet.greenlet(handler)
    debug('received rpc notification, greenlet %s will handle it', gr)
    gr.switch()


</t>
<t tx="ekr.20181012124134.265">class ErrorResponse(BaseException):

    """Raise this in a request handler to respond with a given error message.

    Unlike when other exceptions are caught, this gives full control off the
    error response sent. When "ErrorResponse(msg)" is caught "msg" will be
    sent verbatim as the error response.No traceback will be appended.
    """

    pass
</t>
<t tx="ekr.20181012124134.266">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/
"""Msgpack-rpc subpackage.

This package implements a msgpack-rpc client. While it was designed for
handling some Nvim particularities(server-&gt;client requests for example), the
code here should work with other msgpack-rpc servers.
"""
from .async_session import AsyncSession
from .event_loop import EventLoop
from .msgpack_stream import MsgpackStream
from .session import ErrorResponse, Session


__all__ = ('tcp_session', 'socket_session', 'stdio_session', 'child_session',
           'ErrorResponse')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.268">def session(transport_type='stdio', *args, **kwargs):
    loop = EventLoop(transport_type, *args, **kwargs)
    msgpack_stream = MsgpackStream(loop)
    async_session = AsyncSession(msgpack_stream)
    session = Session(async_session)
    return session


</t>
<t tx="ekr.20181012124134.269">def tcp_session(address, port=7450):
    """Create a msgpack-rpc session from a tcp address/port."""
    return session('tcp', address, port)


</t>
<t tx="ekr.20181012124134.270">def socket_session(path):
    """Create a msgpack-rpc session from a unix domain socket."""
    return session('socket', path)


</t>
<t tx="ekr.20181012124134.271">def stdio_session():
    """Create a msgpack-rpc session from stdin/stdout."""
    return session('stdio')


</t>
<t tx="ekr.20181012124134.272">def child_session(argv):
    """Create a msgpack-rpc session from a new Nvim instance."""
    return session('child', argv)
</t>
<t tx="ekr.20181012124134.274"></t>
<t tx="ekr.20181012124134.275">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/event_loop/
"""Event loop implementation that uses the `asyncio` standard module.

The `asyncio` module was added to python standard library on 3.4, and it
provides a pure python implementation of an event loop library. It is used
as a fallback in case pyuv is not available(on python implementations other
than CPython).

Earlier python versions are supported through the `trollius` package, which
is a backport of `asyncio` that works on Python 2.6+.
"""
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.276">from __future__ import absolute_import

import os
import sys
from collections import deque

try:
    # For python 3.4+, use the standard library module
    import asyncio
except (ImportError, SyntaxError):
    # Fallback to trollius
    import trollius as asyncio

from .base import BaseEventLoop


loop_cls = asyncio.SelectorEventLoop
if os.name == 'nt':
    # On windows use ProactorEventLoop which support pipes and is backed by the
    # more powerful IOCP facility
    loop_cls = asyncio.ProactorEventLoop


</t>
<t tx="ekr.20181012124134.277">class AsyncioEventLoop(BaseEventLoop, asyncio.Protocol,
                       asyncio.SubprocessProtocol):

    """`BaseEventLoop` subclass that uses `asyncio` as a backend."""

    @others
</t>
<t tx="ekr.20181012124134.278">def connection_made(self, transport):
    """Used to signal `asyncio.Protocol` of a successful connection."""
    self._transport = transport
    self._raw_transport = transport
    if isinstance(transport, asyncio.SubprocessTransport):
        self._transport = transport.get_pipe_transport(0)

</t>
<t tx="ekr.20181012124134.279">def connection_lost(self, exc):
    """Used to signal `asyncio.Protocol` of a lost connection."""
    self._on_error(exc.args[0] if exc else 'EOF')

</t>
<t tx="ekr.20181012124134.280">def data_received(self, data):
    """Used to signal `asyncio.Protocol` of incoming data."""
    if self._on_data:
        self._on_data(data)
        return
    self._queued_data.append(data)

</t>
<t tx="ekr.20181012124134.281">def pipe_connection_lost(self, fd, exc):
    """Used to signal `asyncio.SubprocessProtocol` of a lost connection."""
    self._on_error(exc.args[0] if exc else 'EOF')

</t>
<t tx="ekr.20181012124134.282">def pipe_data_received(self, fd, data):
    """Used to signal `asyncio.SubprocessProtocol` of incoming data."""
    if fd == 2:  # stderr fd number
        self._on_stderr(data)
    elif self._on_data:
        self._on_data(data)
    else:
        self._queued_data.append(data)

</t>
<t tx="ekr.20181012124134.283">def process_exited(self):
    """Used to signal `asyncio.SubprocessProtocol` when the child exits."""
    self._on_error('EOF')

</t>
<t tx="ekr.20181012124134.284">def _init(self):
    self._loop = loop_cls()
    self._queued_data = deque()
    self._fact = lambda: self
    self._raw_transport = None

</t>
<t tx="ekr.20181012124134.285">def _connect_tcp(self, address, port):
    coroutine = self._loop.create_connection(self._fact, address, port)
    self._loop.run_until_complete(coroutine)

</t>
<t tx="ekr.20181012124134.286">def _connect_socket(self, path):
    if os.name == 'nt':
        coroutine = self._loop.create_pipe_connection(self._fact, path)
    else:
        coroutine = self._loop.create_unix_connection(self._fact, path)
    self._loop.run_until_complete(coroutine)

</t>
<t tx="ekr.20181012124134.287">def _connect_stdio(self):
    coroutine = self._loop.connect_read_pipe(self._fact, sys.stdin)
    self._loop.run_until_complete(coroutine)
    coroutine = self._loop.connect_write_pipe(self._fact, sys.stdout)
    self._loop.run_until_complete(coroutine)

</t>
<t tx="ekr.20181012124134.288">def _connect_child(self, argv):
    self._child_watcher = asyncio.get_child_watcher()
    self._child_watcher.attach_loop(self._loop)
    coroutine = self._loop.subprocess_exec(self._fact, *argv)
    self._loop.run_until_complete(coroutine)

</t>
<t tx="ekr.20181012124134.289">def _start_reading(self):
    pass

</t>
<t tx="ekr.20181012124134.290">def _send(self, data):
    self._transport.write(data)

</t>
<t tx="ekr.20181012124134.291">def _run(self):
    while self._queued_data:
        self._on_data(self._queued_data.popleft())
    self._loop.run_forever()

</t>
<t tx="ekr.20181012124134.292">def _stop(self):
    self._loop.stop()

</t>
<t tx="ekr.20181012124134.293">def _close(self):
    if self._raw_transport is not None:
        self._raw_transport.close()
    self._loop.close()

</t>
<t tx="ekr.20181012124134.294">def _threadsafe_call(self, fn):
    self._loop.call_soon_threadsafe(fn)

</t>
<t tx="ekr.20181012124134.295">def _setup_signals(self, signals):
    if os.name == 'nt':
        # add_signal_handler is not supported in win32
        self._signals = []
        return

    self._signals = list(signals)
    for signum in self._signals:
        self._loop.add_signal_handler(signum, self._on_signal, signum)

</t>
<t tx="ekr.20181012124134.296">def _teardown_signals(self):
    for signum in self._signals:
        self._loop.remove_signal_handler(signum)
</t>
<t tx="ekr.20181012124134.297">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/event_loop/
"""Common code for event loop implementations."""
import logging
import signal
import threading


logger = logging.getLogger(__name__)
debug, info, warn = (logger.debug, logger.info, logger.warning,)


# When signals are restored, the event loop library may reset SIGINT to SIG_DFL
# which exits the program. To be able to restore the python interpreter to it's
# default state, we keep a reference to the default handler
default_int_handler = signal.getsignal(signal.SIGINT)
main_thread = threading.current_thread()


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.299">class BaseEventLoop(object):

    """Abstract base class for all event loops.

    Event loops act as the bottom layer for Nvim sessions created by this
    library. They hide system/transport details behind a simple interface for
    reading/writing bytes to the connected Nvim instance.

    This class exposes public methods for interacting with the underlying
    event loop and delegates implementation-specific work to the following
    methods, which subclasses are expected to implement:

    - `_init()`: Implementation-specific initialization
    - `_connect_tcp(address, port)`: connect to Nvim using tcp/ip
    - `_connect_socket(path)`: Same as tcp, but use a UNIX domain socket or
      named pipe.
    - `_connect_stdio()`: Use stdin/stdout as the connection to Nvim
    - `_connect_child(argv)`: Use the argument vector `argv` to spawn an
      embedded Nvim that has it's stdin/stdout connected to the event loop.
    - `_start_reading()`: Called after any of _connect_* methods. Can be used
      to perform any post-connection setup or validation.
    - `_send(data)`: Send `data`(byte array) to Nvim. The data is only
    - `_run()`: Runs the event loop until stopped or the connection is closed.
      calling the following methods when some event happens:
      actually sent when the event loop is running.
      - `_on_data(data)`: When Nvim sends some data.
      - `_on_signal(signum)`: When a signal is received.
      - `_on_error(message)`: When a non-recoverable error occurs(eg:
        connection lost)
    - `_stop()`: Stop the event loop
    - `_interrupt(data)`: Like `stop()`, but may be called from other threads
      this.
    - `_setup_signals(signals)`: Add implementation-specific listeners for
      for `signals`, which is a list of OS-specific signal numbers.
    - `_teardown_signals()`: Removes signal listeners set by `_setup_signals`
    """

    @others
</t>
<t tx="ekr.20181012124134.3">@path C:/Anaconda3/Lib/site-packages/neovim/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.300">def __init__(self, transport_type, *args):
    """Initialize and connect the event loop instance.

    The only arguments are the transport type and transport-specific
    configuration, like this:

    &gt;&gt;&gt; BaseEventLoop('tcp', '127.0.0.1', 7450)
    Traceback (most recent call last):
        ...
    AttributeError: 'BaseEventLoop' object has no attribute '_init'
    &gt;&gt;&gt; BaseEventLoop('socket', '/tmp/nvim-socket')
    Traceback (most recent call last):
        ...
    AttributeError: 'BaseEventLoop' object has no attribute '_init'
    &gt;&gt;&gt; BaseEventLoop('stdio')
    Traceback (most recent call last):
        ...
    AttributeError: 'BaseEventLoop' object has no attribute '_init'
    &gt;&gt;&gt; BaseEventLoop('child', ['nvim', '--embed', '-u', 'NONE'])
    Traceback (most recent call last):
        ...
    AttributeError: 'BaseEventLoop' object has no attribute '_init'

    This calls the implementation-specific initialization
    `_init`, one of the `_connect_*` methods(based on `transport_type`)
    and `_start_reading()`
    """
    self._transport_type = transport_type
    self._signames = dict((k, v) for v, k in signal.__dict__.items()
                          if v.startswith('SIG'))
    self._on_data = None
    self._error = None
    self._init()
    try:
        getattr(self, '_connect_{}'.format(transport_type))(*args)
    except Exception as e:
        self.close()
        raise e
    self._start_reading()

</t>
<t tx="ekr.20181012124134.301">def connect_tcp(self, address, port):
    """Connect to tcp/ip `address`:`port`. Delegated to `_connect_tcp`."""
    info('Connecting to TCP address: %s:%d', address, port)
    self._connect_tcp(address, port)

</t>
<t tx="ekr.20181012124134.302">def connect_socket(self, path):
    """Connect to socket at `path`. Delegated to `_connect_socket`."""
    info('Connecting to %s', path)
    self._connect_socket(path)

</t>
<t tx="ekr.20181012124134.303">def connect_stdio(self):
    """Connect using stdin/stdout. Delegated to `_connect_stdio`."""
    info('Preparing stdin/stdout for streaming data')
    self._connect_stdio()

</t>
<t tx="ekr.20181012124134.304">def connect_child(self, argv):
    """Connect a new Nvim instance. Delegated to `_connect_child`."""
    info('Spawning a new nvim instance')
    self._connect_child(argv)

</t>
<t tx="ekr.20181012124134.305">def send(self, data):
    """Queue `data` for sending to Nvim."""
    debug("Sending '%s'", data)
    self._send(data)

</t>
<t tx="ekr.20181012124134.306">def threadsafe_call(self, fn):
    """Call a function in the event loop thread.

    This is the only safe way to interact with a session from other
    threads.
    """
    self._threadsafe_call(fn)

</t>
<t tx="ekr.20181012124134.307">def run(self, data_cb):
    """Run the event loop."""
    if self._error:
        err = self._error
        if isinstance(self._error, KeyboardInterrupt):
            # KeyboardInterrupt is not destructive(it may be used in
            # the REPL).
            # After throwing KeyboardInterrupt, cleanup the _error field
            # so the loop may be started again
            self._error = None
        raise err
    self._on_data = data_cb
    if threading.current_thread() == main_thread:
        self._setup_signals([signal.SIGINT, signal.SIGTERM])
    debug('Entering event loop')
    self._run()
    debug('Exited event loop')
    if threading.current_thread() == main_thread:
        self._teardown_signals()
        signal.signal(signal.SIGINT, default_int_handler)
    self._on_data = None

</t>
<t tx="ekr.20181012124134.308">def stop(self):
    """Stop the event loop."""
    self._stop()
    debug('Stopped event loop')

</t>
<t tx="ekr.20181012124134.309">def close(self):
    """Stop the event loop."""
    self._close()
    debug('Closed event loop')

</t>
<t tx="ekr.20181012124134.310">def _on_signal(self, signum):
    msg = 'Received {}'.format(self._signames[signum])
    debug(msg)
    if signum == signal.SIGINT and self._transport_type == 'stdio':
        # When the transport is stdio, we are probably running as a Nvim
        # child process. In that case, we don't want to be killed by
        # ctrl+C
        return
    cls = Exception
    if signum == signal.SIGINT:
        cls = KeyboardInterrupt
    self._error = cls(msg)
    self.stop()

</t>
<t tx="ekr.20181012124134.311">def _on_error(self, error):
    debug(error)
    self._error = IOError(error)
    self.stop()

</t>
<t tx="ekr.20181012124134.312">def _on_interrupt(self):
    self.stop()
</t>
<t tx="ekr.20181012124134.313">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/event_loop/
"""Event loop implementation that uses pyuv(libuv-python bindings)."""
import sys
from collections import deque

import pyuv

from .base import BaseEventLoop


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.315">class UvEventLoop(BaseEventLoop):

    """`BaseEventLoop` subclass that uses `pvuv` as a backend."""

    @others
</t>
<t tx="ekr.20181012124134.316">def _init(self):
    self._loop = pyuv.Loop()
    self._async = pyuv.Async(self._loop, self._on_async)
    self._connection_error = None
    self._error_stream = None
    self._callbacks = deque()

</t>
<t tx="ekr.20181012124134.317">def _on_connect(self, stream, error):
    self.stop()
    if error:
        msg = 'Cannot connect to {}: {}'.format(
            self._connect_address, pyuv.errno.strerror(error))
        self._connection_error = IOError(msg)
        return
    self._read_stream = self._write_stream = stream

</t>
<t tx="ekr.20181012124134.318">def _on_read(self, handle, data, error):
    if error or not data:
        msg = pyuv.errno.strerror(error) if error else 'EOF'
        self._on_error(msg)
        return
    if handle == self._error_stream:
        return
    self._on_data(data)

</t>
<t tx="ekr.20181012124134.319">def _on_write(self, handle, error):
    if error:
        msg = pyuv.errno.strerror(error)
        self._on_error(msg)

</t>
<t tx="ekr.20181012124134.320">def _on_exit(self, handle, exit_status, term_signal):
    self._on_error('EOF')

</t>
<t tx="ekr.20181012124134.321">def _disconnected(self, *args):
    raise IOError('Not connected to Nvim')

</t>
<t tx="ekr.20181012124134.322">def _connect_tcp(self, address, port):
    stream = pyuv.TCP(self._loop)
    self._connect_address = '{}:{}'.format(address, port)
    stream.connect((address, port), self._on_connect)

</t>
<t tx="ekr.20181012124134.323">def _connect_socket(self, path):
    stream = pyuv.Pipe(self._loop)
    self._connect_address = path
    stream.connect(path, self._on_connect)

</t>
<t tx="ekr.20181012124134.324">def _connect_stdio(self):
    self._read_stream = pyuv.Pipe(self._loop)
    self._read_stream.open(sys.stdin.fileno())
    self._write_stream = pyuv.Pipe(self._loop)
    self._write_stream.open(sys.stdout.fileno())

</t>
<t tx="ekr.20181012124134.325">def _connect_child(self, argv):
    self._write_stream = pyuv.Pipe(self._loop)
    self._read_stream = pyuv.Pipe(self._loop)
    self._error_stream = pyuv.Pipe(self._loop)
    stdin = pyuv.StdIO(self._write_stream,
                       flags=pyuv.UV_CREATE_PIPE + pyuv.UV_READABLE_PIPE)
    stdout = pyuv.StdIO(self._read_stream,
                        flags=pyuv.UV_CREATE_PIPE + pyuv.UV_WRITABLE_PIPE)
    stderr = pyuv.StdIO(self._error_stream,
                        flags=pyuv.UV_CREATE_PIPE + pyuv.UV_WRITABLE_PIPE)
    pyuv.Process.spawn(self._loop,
                       args=argv,
                       exit_callback=self._on_exit,
                       flags=pyuv.UV_PROCESS_WINDOWS_HIDE,
                       stdio=(stdin, stdout, stderr,))
    self._error_stream.start_read(self._on_read)

</t>
<t tx="ekr.20181012124134.326">def _start_reading(self):
    if self._transport_type in ['tcp', 'socket']:
        self._loop.run()
        if self._connection_error:
            self.run = self.send = self._disconnected
            raise self._connection_error
    self._read_stream.start_read(self._on_read)

</t>
<t tx="ekr.20181012124134.327">def _send(self, data):
    self._write_stream.write(data, self._on_write)

</t>
<t tx="ekr.20181012124134.328">def _run(self):
    self._loop.run(pyuv.UV_RUN_DEFAULT)

</t>
<t tx="ekr.20181012124134.329">def _stop(self):
    self._loop.stop()

</t>
<t tx="ekr.20181012124134.330">def _close(self):
    pass

</t>
<t tx="ekr.20181012124134.331">def _threadsafe_call(self, fn):
    self._callbacks.append(fn)
    self._async.send()

</t>
<t tx="ekr.20181012124134.332">def _on_async(self, handle):
    while self._callbacks:
        self._callbacks.popleft()()

</t>
<t tx="ekr.20181012124134.333">def _setup_signals(self, signals):
    self._signal_handles = []

    def handler(h, signum):
        self._on_signal(signum)

    for signum in signals:
        handle = pyuv.Signal(self._loop)
        handle.start(handler, signum)
        self._signal_handles.append(handle)

</t>
<t tx="ekr.20181012124134.334">def _teardown_signals(self):
    for handle in self._signal_handles:
        handle.stop()
</t>
<t tx="ekr.20181012124134.335">@path C:/Anaconda3/Lib/site-packages/neovim/msgpack_rpc/event_loop/
"""Event loop abstraction subpackage.

Tries to use pyuv as a backend, falling back to the asyncio implementation.
"""

import os

from ...compat import IS_PYTHON3

# on python3 we only support asyncio, as we expose it to plugins
if IS_PYTHON3 and os.name != 'nt':
    from .asyncio import AsyncioEventLoop
    EventLoop = AsyncioEventLoop
else:
    try:
        # libuv is fully implemented in C, use it when available
        from .uv import UvEventLoop
        EventLoop = UvEventLoop
    except ImportError:
        # asyncio(trollius on python 2) is pure python and should be more
        # portable across python implementations
        from .asyncio import AsyncioEventLoop
        EventLoop = AsyncioEventLoop


__all__ = ('EventLoop')
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.338"></t>
<t tx="ekr.20181012124134.339">@path C:/Anaconda3/Lib/site-packages/neovim/plugin/
"""Decorators used by python host plugin system."""

import inspect
import logging

from ..compat import IS_PYTHON3, unicode_errors_default

logger = logging.getLogger(__name__)
debug, info, warn = (logger.debug, logger.info, logger.warning,)
__all__ = ('plugin', 'rpc_export', 'command', 'autocmd', 'function',
           'encoding', 'decode', 'shutdown_hook')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.341">def plugin(cls):
    """Tag a class as a plugin.

    This decorator is required to make the class methods discoverable by the
    plugin_load method of the host.
    """
    cls._nvim_plugin = True
    # the _nvim_bind attribute is set to True by default, meaning that
    # decorated functions have a bound Nvim instance as first argument.
    # For methods in a plugin-decorated class this is not required, because
    # the class initializer will already receive the nvim object.
    predicate = lambda fn: hasattr(fn, '_nvim_bind')
    for _, fn in inspect.getmembers(cls, predicate):
        if IS_PYTHON3:
            fn._nvim_bind = False
        else:
            fn.im_func._nvim_bind = False
    return cls


</t>
<t tx="ekr.20181012124134.342">def rpc_export(rpc_method_name, sync=False):
    """Export a function or plugin method as a msgpack-rpc request handler."""
    def dec(f):
        f._nvim_rpc_method_name = rpc_method_name
        f._nvim_rpc_sync = sync
        f._nvim_bind = True
        f._nvim_prefix_plugin_path = False
        return f
    return dec


</t>
<t tx="ekr.20181012124134.343">def command(name, nargs=0, complete=None, range=None, count=None, bang=False,
            register=False, sync=False, allow_nested=False, eval=None):
    """Tag a function or plugin method as a Nvim command handler."""
    def dec(f):
        f._nvim_rpc_method_name = 'command:{}'.format(name)
        f._nvim_rpc_sync = sync
        f._nvim_bind = True
        f._nvim_prefix_plugin_path = True

        opts = {}

        if range is not None:
            opts['range'] = '' if range is True else str(range)
        elif count is not None:
            opts['count'] = count

        if bang:
            opts['bang'] = ''

        if register:
            opts['register'] = ''

        if nargs:
            opts['nargs'] = nargs

        if complete:
            opts['complete'] = complete

        if eval:
            opts['eval'] = eval

        if not sync and allow_nested:
            rpc_sync = "urgent"
        else:
            rpc_sync = sync

        f._nvim_rpc_spec = {
            'type': 'command',
            'name': name,
            'sync': rpc_sync,
            'opts': opts
        }
        return f
    return dec


</t>
<t tx="ekr.20181012124134.344">def autocmd(name, pattern='*', sync=False, allow_nested=False, eval=None):
    """Tag a function or plugin method as a Nvim autocommand handler."""
    def dec(f):
        f._nvim_rpc_method_name = 'autocmd:{}:{}'.format(name, pattern)
        f._nvim_rpc_sync = sync
        f._nvim_bind = True
        f._nvim_prefix_plugin_path = True

        opts = {
            'pattern': pattern
        }

        if eval:
            opts['eval'] = eval

        if not sync and allow_nested:
            rpc_sync = "urgent"
        else:
            rpc_sync = sync

        f._nvim_rpc_spec = {
            'type': 'autocmd',
            'name': name,
            'sync': rpc_sync,
            'opts': opts
        }
        return f
    return dec


</t>
<t tx="ekr.20181012124134.345">def function(name, range=False, sync=False, allow_nested=False, eval=None):
    """Tag a function or plugin method as a Nvim function handler."""
    def dec(f):
        f._nvim_rpc_method_name = 'function:{}'.format(name)
        f._nvim_rpc_sync = sync
        f._nvim_bind = True
        f._nvim_prefix_plugin_path = True

        opts = {}

        if range:
            opts['range'] = '' if range is True else str(range)

        if eval:
            opts['eval'] = eval

        if not sync and allow_nested:
            rpc_sync = "urgent"
        else:
            rpc_sync = sync

        f._nvim_rpc_spec = {
            'type': 'function',
            'name': name,
            'sync': rpc_sync,
            'opts': opts
        }
        return f
    return dec


</t>
<t tx="ekr.20181012124134.346">def shutdown_hook(f):
    """Tag a function or method as a shutdown hook."""
    f._nvim_shutdown_hook = True
    f._nvim_bind = True
    return f


</t>
<t tx="ekr.20181012124134.347">def decode(mode=unicode_errors_default):
    """Configure automatic encoding/decoding of strings."""
    def dec(f):
        f._nvim_decode = mode
        return f
    return dec


</t>
<t tx="ekr.20181012124134.348">def encoding(encoding=True):
    """DEPRECATED: use neovim.decode()."""
    if isinstance(encoding, str):
        encoding = True

    def dec(f):
        f._nvim_decode = encoding
        return f
    return dec
</t>
<t tx="ekr.20181012124134.349">@path C:/Anaconda3/Lib/site-packages/neovim/plugin/
"""Implements a Nvim host for python plugins."""
import imp
import inspect
import logging
import os
import os.path
import re
from functools import partial
from traceback import format_exc

from . import script_host
from ..api import decode_if_bytes, walk
from ..compat import IS_PYTHON3, find_module
from ..msgpack_rpc import ErrorResponse
from ..util import format_exc_skip

__all__ = ('Host')

logger = logging.getLogger(__name__)
error, debug, info, warn = (logger.error, logger.debug, logger.info,
                            logger.warning,)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.351">class Host(object):

    """Nvim host for python plugins.

    Takes care of loading/unloading plugins and routing msgpack-rpc
    requests/notifications to the appropriate handlers.
    """

    @others
</t>
<t tx="ekr.20181012124134.352">def __init__(self, nvim):
    """Set handlers for plugin_load/plugin_unload."""
    self.nvim = nvim
    self._specs = {}
    self._loaded = {}
    self._load_errors = {}
    self._notification_handlers = {}
    self._request_handlers = {
        'poll': lambda: 'ok',
        'specs': self._on_specs_request,
        'shutdown': self.shutdown
    }

    # Decode per default for Python3
    self._decode_default = IS_PYTHON3

</t>
<t tx="ekr.20181012124134.353">def _on_async_err(self, msg):
    self.nvim.err_write(msg, async_=True)

</t>
<t tx="ekr.20181012124134.354">def start(self, plugins):
    """Start listening for msgpack-rpc requests and notifications."""
    self.nvim.run_loop(self._on_request,
                       self._on_notification,
                       lambda: self._load(plugins),
                       err_cb=self._on_async_err)

</t>
<t tx="ekr.20181012124134.355">def shutdown(self):
    """Shutdown the host."""
    self._unload()
    self.nvim.stop_loop()

</t>
<t tx="ekr.20181012124134.356">def _wrap_function(self, fn, sync, decode, nvim_bind, name, *args):
    if decode:
        args = walk(decode_if_bytes, args, decode)
    if nvim_bind is not None:
        args.insert(0, nvim_bind)
    try:
        return fn(*args)
    except Exception:
        if sync:
            msg = ("error caught in request handler '{} {}':\n{}"
                   .format(name, args, format_exc_skip(1)))
            raise ErrorResponse(msg)
        else:
            msg = ("error caught in async handler '{} {}'\n{}\n"
                   .format(name, args, format_exc_skip(1)))
            self._on_async_err(msg + "\n")

</t>
<t tx="ekr.20181012124134.357">def _on_request(self, name, args):
    """Handle a msgpack-rpc request."""
    if IS_PYTHON3:
        name = decode_if_bytes(name)
    handler = self._request_handlers.get(name, None)
    if not handler:
        msg = self._missing_handler_error(name, 'request')
        error(msg)
        raise ErrorResponse(msg)

    debug('calling request handler for "%s", args: "%s"', name, args)
    rv = handler(*args)
    debug("request handler for '%s %s' returns: %s", name, args, rv)
    return rv

</t>
<t tx="ekr.20181012124134.358">def _on_notification(self, name, args):
    """Handle a msgpack-rpc notification."""
    if IS_PYTHON3:
        name = decode_if_bytes(name)
    handler = self._notification_handlers.get(name, None)
    if not handler:
        msg = self._missing_handler_error(name, 'notification')
        error(msg)
        self._on_async_err(msg + "\n")
        return

    debug('calling notification handler for "%s", args: "%s"', name, args)
    handler(*args)

</t>
<t tx="ekr.20181012124134.359">def _missing_handler_error(self, name, kind):
    msg = 'no {} handler registered for "{}"'.format(kind, name)
    pathmatch = re.match(r'(.+):[^:]+:[^:]+', name)
    if pathmatch:
        loader_error = self._load_errors.get(pathmatch.group(1))
        if loader_error is not None:
            msg = msg + "\n" + loader_error
    return msg

</t>
<t tx="ekr.20181012124134.360">def _load(self, plugins):
    for path in plugins:
        err = None
        if path in self._loaded:
            error('{} is already loaded'.format(path))
            continue
        try:
            if path == "script_host.py":
                module = script_host
            else:
                directory, name = os.path.split(os.path.splitext(path)[0])
                file, pathname, descr = find_module(name, [directory])
                module = imp.load_module(name, file, pathname, descr)
            handlers = []
            self._discover_classes(module, handlers, path)
            self._discover_functions(module, handlers, path)
            if not handlers:
                error('{} exports no handlers'.format(path))
                continue
            self._loaded[path] = {'handlers': handlers, 'module': module}
        except Exception as e:
            err = ('Encountered {} loading plugin at {}: {}\n{}'
                   .format(type(e).__name__, path, e, format_exc(5)))
            error(err)
            self._load_errors[path] = err

</t>
<t tx="ekr.20181012124134.361">def _unload(self):
    for path, plugin in self._loaded.items():
        handlers = plugin['handlers']
        for handler in handlers:
            method_name = handler._nvim_rpc_method_name
            if hasattr(handler, '_nvim_shutdown_hook'):
                handler()
            elif handler._nvim_rpc_sync:
                del self._request_handlers[method_name]
            else:
                del self._notification_handlers[method_name]
    self._specs = {}
    self._loaded = {}

</t>
<t tx="ekr.20181012124134.362">def _discover_classes(self, module, handlers, plugin_path):
    for _, cls in inspect.getmembers(module, inspect.isclass):
        if getattr(cls, '_nvim_plugin', False):
            # create an instance of the plugin and pass the nvim object
            plugin = cls(self._configure_nvim_for(cls))
            # discover handlers in the plugin instance
            self._discover_functions(plugin, handlers, plugin_path)

</t>
<t tx="ekr.20181012124134.363">def _discover_functions(self, obj, handlers, plugin_path):
    def predicate(o):
        return hasattr(o, '_nvim_rpc_method_name')

    specs = []
    objdecode = getattr(obj, '_nvim_decode', self._decode_default)
    for _, fn in inspect.getmembers(obj, predicate):
        sync = fn._nvim_rpc_sync
        decode = getattr(fn, '_nvim_decode', objdecode)
        nvim_bind = None
        if fn._nvim_bind:
            nvim_bind = self._configure_nvim_for(fn)

        method = fn._nvim_rpc_method_name
        if fn._nvim_prefix_plugin_path:
            method = '{}:{}'.format(plugin_path, method)

        fn_wrapped = partial(self._wrap_function, fn,
                             sync, decode, nvim_bind, method)
        self._copy_attributes(fn, fn_wrapped)
        # register in the rpc handler dict
        if sync:
            if method in self._request_handlers:
                raise Exception(('Request handler for "{}" is ' +
                                'already registered').format(method))
            self._request_handlers[method] = fn_wrapped
        else:
            if method in self._notification_handlers:
                raise Exception(('Notification handler for "{}" is ' +
                                'already registered').format(method))
            self._notification_handlers[method] = fn_wrapped
        if hasattr(fn, '_nvim_rpc_spec'):
            specs.append(fn._nvim_rpc_spec)
        handlers.append(fn_wrapped)
    if specs:
        self._specs[plugin_path] = specs

</t>
<t tx="ekr.20181012124134.364">def _copy_attributes(self, fn, fn2):
    # Copy _nvim_* attributes from the original function
    for attr in dir(fn):
        if attr.startswith('_nvim_'):
            setattr(fn2, attr, getattr(fn, attr))

</t>
<t tx="ekr.20181012124134.365">def _on_specs_request(self, path):
    if IS_PYTHON3:
        path = decode_if_bytes(path)
    if path in self._load_errors:
        self.nvim.out_write(self._load_errors[path] + '\n')
    return self._specs.get(path, 0)

</t>
<t tx="ekr.20181012124134.366">def _configure_nvim_for(self, obj):
    # Configure a nvim instance for obj (checks encoding configuration)
    nvim = self.nvim
    decode = getattr(obj, '_nvim_decode', self._decode_default)
    if decode:
        nvim = nvim.with_decode(decode)
    return nvim
</t>
<t tx="ekr.20181012124134.367">@path C:/Anaconda3/Lib/site-packages/neovim/plugin/
"""Legacy python/python3-vim emulation."""
import imp
import io
import logging
import os
import sys

from .decorators import plugin, rpc_export
from ..api import Nvim, walk
from ..msgpack_rpc import ErrorResponse
from ..util import format_exc_skip

__all__ = ('ScriptHost',)


logger = logging.getLogger(__name__)
debug, info, warn = (logger.debug, logger.info, logger.warn,)

IS_PYTHON3 = sys.version_info &gt;= (3, 0)

if IS_PYTHON3:
    basestring = str

    if sys.version_info &gt;= (3, 4):
        from importlib.machinery import PathFinder

    PYTHON_SUBDIR = 'python3'
else:
    PYTHON_SUBDIR = 'python2'


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.369">@plugin
class ScriptHost(object):

    """Provides an environment for running python plugins created for Vim."""

    @others
</t>
<t tx="ekr.20181012124134.370">def __init__(self, nvim):
    """Initialize the legacy python-vim environment."""
    self.setup(nvim)
    # context where all code will run
    self.module = imp.new_module('__main__')
    nvim.script_context = self.module
    # it seems some plugins assume 'sys' is already imported, so do it now
    exec('import sys', self.module.__dict__)
    self.legacy_vim = LegacyVim.from_nvim(nvim)
    sys.modules['vim'] = self.legacy_vim

    # Handle DirChanged. #296
    nvim.command(
        'au DirChanged * call rpcnotify({}, "python_chdir", v:event.cwd)'
        .format(nvim.channel_id), async_=True)
    # XXX: Avoid race condition.
    # https://github.com/neovim/python-client/pull/296#issuecomment-358970531
    # TODO(bfredl): when host initialization has been refactored,
    # to make __init__ safe again, the following should work:
    # os.chdir(nvim.eval('getcwd()', async_=False))
    nvim.command('call rpcnotify({}, "python_chdir", getcwd())'
                 .format(nvim.channel_id), async_=True)

</t>
<t tx="ekr.20181012124134.371">def setup(self, nvim):
    """Setup import hooks and global streams.

    This will add import hooks for importing modules from runtime
    directories and patch the sys module so 'print' calls will be
    forwarded to Nvim.
    """
    self.nvim = nvim
    info('install import hook/path')
    self.hook = path_hook(nvim)
    sys.path_hooks.append(self.hook)
    nvim.VIM_SPECIAL_PATH = '_vim_path_'
    sys.path.append(nvim.VIM_SPECIAL_PATH)
    info('redirect sys.stdout and sys.stderr')
    self.saved_stdout = sys.stdout
    self.saved_stderr = sys.stderr
    sys.stdout = RedirectStream(lambda data: nvim.out_write(data))
    sys.stderr = RedirectStream(lambda data: nvim.err_write(data))

</t>
<t tx="ekr.20181012124134.372">def teardown(self):
    """Restore state modified from the `setup` call."""
    nvim = self.nvim
    info('uninstall import hook/path')
    sys.path.remove(nvim.VIM_SPECIAL_PATH)
    sys.path_hooks.remove(self.hook)
    info('restore sys.stdout and sys.stderr')
    sys.stdout = self.saved_stdout
    sys.stderr = self.saved_stderr

</t>
<t tx="ekr.20181012124134.373">@rpc_export('python_execute', sync=True)
def python_execute(self, script, range_start, range_stop):
    """Handle the `python` ex command."""
    self._set_current_range(range_start, range_stop)
    try:
        exec(script, self.module.__dict__)
    except Exception:
        raise ErrorResponse(format_exc_skip(1))

</t>
<t tx="ekr.20181012124134.374">@rpc_export('python_execute_file', sync=True)
def python_execute_file(self, file_path, range_start, range_stop):
    """Handle the `pyfile` ex command."""
    self._set_current_range(range_start, range_stop)
    with open(file_path) as f:
        script = compile(f.read(), file_path, 'exec')
        try:
            exec(script, self.module.__dict__)
        except Exception:
            raise ErrorResponse(format_exc_skip(1))

</t>
<t tx="ekr.20181012124134.375">@rpc_export('python_do_range', sync=True)
def python_do_range(self, start, stop, code):
    """Handle the `pydo` ex command."""
    self._set_current_range(start, stop)
    nvim = self.nvim
    start -= 1
    fname = '_vim_pydo'

    # define the function
    function_def = 'def %s(line, linenr):\n %s' % (fname, code,)
    exec(function_def, self.module.__dict__)
    # get the function
    function = self.module.__dict__[fname]
    while start &lt; stop:
        # Process batches of 5000 to avoid the overhead of making multiple
        # API calls for every line. Assuming an average line length of 100
        # bytes, approximately 488 kilobytes will be transferred per batch,
        # which can be done very quickly in a single API call.
        sstart = start
        sstop = min(start + 5000, stop)
        lines = nvim.current.buffer.api.get_lines(sstart, sstop, True)

        exception = None
        newlines = []
        linenr = sstart + 1
        for i, line in enumerate(lines):
            result = function(line, linenr)
            if result is None:
                # Update earlier lines, and skip to the next
                if newlines:
                    end = sstart + len(newlines) - 1
                    nvim.current.buffer.api.set_lines(sstart, end,
                                                      True, newlines)
                sstart += len(newlines) + 1
                newlines = []
                pass
            elif isinstance(result, basestring):
                newlines.append(result)
            else:
                exception = TypeError('pydo should return a string ' +
                                      'or None, found %s instead'
                                      % result.__class__.__name__)
                break
            linenr += 1

        start = sstop
        if newlines:
            end = sstart + len(newlines)
            nvim.current.buffer.api.set_lines(sstart, end, True, newlines)
        if exception:
            raise exception
    # delete the function
    del self.module.__dict__[fname]

</t>
<t tx="ekr.20181012124134.376">@rpc_export('python_eval', sync=True)
def python_eval(self, expr):
    """Handle the `pyeval` vim function."""
    return eval(expr, self.module.__dict__)

</t>
<t tx="ekr.20181012124134.377">@rpc_export('python_chdir', sync=False)
def python_chdir(self, cwd):
    """Handle working directory changes."""
    os.chdir(cwd)

</t>
<t tx="ekr.20181012124134.378">def _set_current_range(self, start, stop):
    current = self.legacy_vim.current
    current.range = current.buffer.range(start, stop)


</t>
<t tx="ekr.20181012124134.379">class RedirectStream(io.IOBase):
    @others
</t>
<t tx="ekr.20181012124134.380">def __init__(self, redirect_handler):
    self.redirect_handler = redirect_handler

</t>
<t tx="ekr.20181012124134.381">def write(self, data):
    self.redirect_handler(data)

</t>
<t tx="ekr.20181012124134.382">def writelines(self, seq):
    self.redirect_handler('\n'.join(seq))


</t>
<t tx="ekr.20181012124134.383">if IS_PYTHON3:
    num_types = (int, float)
else:
    num_types = (int, long, float)  # noqa: F821


def num_to_str(obj):
    if isinstance(obj, num_types):
        return str(obj)
    else:
        return obj


</t>
<t tx="ekr.20181012124134.384">class LegacyVim(Nvim):
    def eval(self, expr):
        obj = self.request("vim_eval", expr)
        return walk(num_to_str, obj)


</t>
<t tx="ekr.20181012124134.386"># This was copied/adapted from nvim-python help
def path_hook(nvim):
    def _get_paths():
        return discover_runtime_directories(nvim)

    def _find_module(fullname, oldtail, path):
        idx = oldtail.find('.')
        if idx &gt; 0:
            name = oldtail[:idx]
            tail = oldtail[idx + 1:]
            fmr = imp.find_module(name, path)
            module = imp.find_module(fullname[:-len(oldtail)] + name, *fmr)
            return _find_module(fullname, tail, module.__path__)
        else:
            return imp.find_module(fullname, path)

    class VimModuleLoader(object):
        def __init__(self, module):
            self.module = module

        def load_module(self, fullname, path=None):
            # Check sys.modules, required for reload (see PEP302).
            if fullname in sys.modules:
                return sys.modules[fullname]
            return imp.load_module(fullname, *self.module)

    class VimPathFinder(object):
        @staticmethod
        def find_module(fullname, path=None):
            """Method for Python 2.7 and 3.3."""
            try:
                return VimModuleLoader(
                    _find_module(fullname, fullname, path or _get_paths()))
            except ImportError:
                return None

        @staticmethod
        def find_spec(fullname, path=None, target=None):
            """Method for Python 3.4+."""
            return PathFinder.find_spec(fullname, path or _get_paths(), target)

    def hook(path):
        if path == nvim.VIM_SPECIAL_PATH:
            return VimPathFinder
        else:
            raise ImportError

    return hook


</t>
<t tx="ekr.20181012124134.387">def discover_runtime_directories(nvim):
    rv = []
    for rtp in nvim.list_runtime_paths():
        if not os.path.exists(rtp):
            continue
        for subdir in ['pythonx', PYTHON_SUBDIR]:
            path = os.path.join(rtp, subdir)
            if os.path.exists(path):
                rv.append(path)
    return rv
</t>
<t tx="ekr.20181012124134.4">"""Code for supporting compatibility across python versions."""

import sys
import warnings
from imp import find_module as original_find_module


IS_PYTHON3 = sys.version_info &gt;= (3, 0)


if IS_PYTHON3:
    def find_module(fullname, path):
        """Compatibility wrapper for imp.find_module.

        Automatically decodes arguments of find_module, in Python3
        they must be Unicode
        """
        if isinstance(fullname, bytes):
            fullname = fullname.decode()
        if isinstance(path, bytes):
            path = path.decode()
        elif isinstance(path, list):
            newpath = []
            for element in path:
                if isinstance(element, bytes):
                    newpath.append(element.decode())
                else:
                    newpath.append(element)
            path = newpath
        return original_find_module(fullname, path)

    # There is no 'long' type in Python3 just int
    long = int
    unicode_errors_default = 'surrogateescape'
else:
    find_module = original_find_module
    unicode_errors_default = 'strict'

NUM_TYPES = (int, long, float)


</t>
<t tx="ekr.20181012124134.5">def check_async(async_, kwargs, default):
    """Return a value of 'async' in kwargs or default when async_ is None.

    This helper function exists for backward compatibility (See #274).
    It shows a warning message when 'async' in kwargs is used to note users.
    """
    if async_ is not None:
        return async_
    elif 'async' in kwargs:
        warnings.warn(
            '"async" attribute is deprecated. Use "async_" instead.',
            DeprecationWarning,
        )
        return kwargs.pop('async')
    else:
        return default
</t>
<t tx="ekr.20181012124134.6">@path C:/Anaconda3/Lib/site-packages/neovim/
"""Shared utility functions."""

import sys
from traceback import format_exception


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.74"></t>
<t tx="ekr.20181012124134.75">@path C:/Anaconda3/Lib/site-packages/neovim/api/
"""API for working with a Nvim Buffer."""
from .common import Remote
from ..compat import IS_PYTHON3, check_async


__all__ = ('Buffer')


if IS_PYTHON3:
    basestring = str


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012124134.77">def adjust_index(idx, default=None):
    """Convert from python indexing convention to nvim indexing convention."""
    if idx is None:
        return default
    elif idx &lt; 0:
        return idx - 1
    else:
        return idx


</t>
<t tx="ekr.20181012124134.78">class Buffer(Remote):

    """A remote Nvim buffer."""

    _api_prefix = "nvim_buf_"

    @others
</t>
<t tx="ekr.20181012124134.79">def __len__(self):
    """Return the number of lines contained in a Buffer."""
    return self.request('nvim_buf_line_count')

</t>
<t tx="ekr.20181012124134.8">def format_exc_skip(skip, limit=None):
    """Like traceback.format_exc but allow skipping the first frames."""
    type, val, tb = sys.exc_info()
    for i in range(skip):
        tb = tb.tb_next
    return ('\n'.join(format_exception(type, val, tb, limit))).rstrip()


# Taken from SimpleNamespace in python 3
</t>
<t tx="ekr.20181012124134.80">def __getitem__(self, idx):
    """Get a buffer line or slice by integer index.

    Indexes may be negative to specify positions from the end of the
    buffer. For example, -1 is the last line, -2 is the line before that
    and so on.

    When retrieving slices, omiting indexes(eg: `buffer[:]`) will bring
    the whole buffer.
    """
    if not isinstance(idx, slice):
        i = adjust_index(idx)
        return self.request('nvim_buf_get_lines', i, i + 1, True)[0]
    start = adjust_index(idx.start, 0)
    end = adjust_index(idx.stop, -1)
    return self.request('nvim_buf_get_lines', start, end, False)

</t>
<t tx="ekr.20181012124134.81">def __setitem__(self, idx, item):
    """Replace a buffer line or slice by integer index.

    Like with `__getitem__`, indexes may be negative.

    When replacing slices, omiting indexes(eg: `buffer[:]`) will replace
    the whole buffer.
    """
    if not isinstance(idx, slice):
        i = adjust_index(idx)
        lines = [item] if item is not None else []
        return self.request('nvim_buf_set_lines', i, i + 1, True, lines)
    lines = item if item is not None else []
    start = adjust_index(idx.start, 0)
    end = adjust_index(idx.stop, -1)
    return self.request('nvim_buf_set_lines', start, end, False, lines)

</t>
<t tx="ekr.20181012124134.82">def __iter__(self):
    """Iterate lines of a buffer.

    This will retrieve all lines locally before iteration starts. This
    approach is used because for most cases, the gain is much greater by
    minimizing the number of API calls by transfering all data needed to
    work.
    """
    lines = self[:]
    for line in lines:
        yield line

</t>
<t tx="ekr.20181012124134.83">def __delitem__(self, idx):
    """Delete line or slice of lines from the buffer.

    This is the same as __setitem__(idx, [])
    """
    self.__setitem__(idx, None)

</t>
<t tx="ekr.20181012124134.84">def append(self, lines, index=-1):
    """Append a string or list of lines to the buffer."""
    if isinstance(lines, (basestring, bytes)):
        lines = [lines]
    return self.request('nvim_buf_set_lines', index, index, True, lines)

</t>
<t tx="ekr.20181012124134.85">def mark(self, name):
    """Return (row, col) tuple for a named mark."""
    return self.request('nvim_buf_get_mark', name)

</t>
<t tx="ekr.20181012124134.86">def range(self, start, end):
    """Return a `Range` object, which represents part of the Buffer."""
    return Range(self, start, end)

</t>
<t tx="ekr.20181012124134.87">def add_highlight(self, hl_group, line, col_start=0,
                  col_end=-1, src_id=-1, async_=None,
                  **kwargs):
    """Add a highlight to the buffer."""
    async_ = check_async(async_, kwargs, src_id != 0)
    return self.request('nvim_buf_add_highlight', src_id, hl_group,
                        line, col_start, col_end, async_=async_)

</t>
<t tx="ekr.20181012124134.88">def clear_highlight(self, src_id, line_start=0, line_end=-1, async_=None,
                    **kwargs):
    """Clear highlights from the buffer."""
    async_ = check_async(async_, kwargs, True)
    self.request('nvim_buf_clear_highlight', src_id,
                 line_start, line_end, async_=async_)

</t>
<t tx="ekr.20181012124134.89">def update_highlights(self, src_id, hls, clear_start=0, clear_end=-1,
                      clear=False, async_=True):
    """Add or update highlights in batch to avoid unnecessary redraws.

    A `src_id` must have been allocated prior to use of this function. Use
    for instance `nvim.new_highlight_source()` to get a src_id for your
    plugin.

    `hls` should be a list of highlight items. Each item should be a list
    or tuple on the form `("GroupName", linenr, col_start, col_end)` or
    `("GroupName", linenr)` to highlight an entire line.

    By default existing highlights are preserved. Specify a line range with
    clear_start and clear_end to replace highlights in this range. As a
    shorthand, use clear=True to clear the entire buffer before adding the
    new highlights.
    """
    if clear and clear_start is None:
        clear_start = 0
    lua = self._session._get_lua_private()
    lua.update_highlights(self, src_id, hls, clear_start, clear_end,
                          async_=async_)

</t>
<t tx="ekr.20181012124134.9">class Version:

    """Helper class for version info."""

    @others
</t>
<t tx="ekr.20181012124134.90">@property
def name(self):
    """Get the buffer name."""
    return self.request('nvim_buf_get_name')

@name.setter
def name(self, value):
    """Set the buffer name. BufFilePre/BufFilePost are triggered."""
    return self.request('nvim_buf_set_name', value)

</t>
<t tx="ekr.20181012124134.92">@property
def valid(self):
    """Return True if the buffer still exists."""
    return self.request('nvim_buf_is_valid')

</t>
<t tx="ekr.20181012124134.93">@property
def number(self):
    """Get the buffer number."""
    return self.handle


</t>
<t tx="ekr.20181012124134.94">class Range(object):
    @others
</t>
<t tx="ekr.20181012124134.95">def __init__(self, buffer, start, end):
    self._buffer = buffer
    self.start = start - 1
    self.end = end - 1

</t>
<t tx="ekr.20181012124134.96">def __len__(self):
    return self.end - self.start + 1

</t>
<t tx="ekr.20181012124134.97">def __getitem__(self, idx):
    if not isinstance(idx, slice):
        return self._buffer[self._normalize_index(idx)]
    start = self._normalize_index(idx.start)
    end = self._normalize_index(idx.stop)
    if start is None:
        start = self.start
    if end is None:
        end = self.end + 1
    return self._buffer[start:end]

</t>
<t tx="ekr.20181012124134.98">def __setitem__(self, idx, lines):
    if not isinstance(idx, slice):
        self._buffer[self._normalize_index(idx)] = lines
        return
    start = self._normalize_index(idx.start)
    end = self._normalize_index(idx.stop)
    if start is None:
        start = self.start
    if end is None:
        end = self.end
    self._buffer[start:end + 1] = lines

</t>
<t tx="ekr.20181012124134.99">def __iter__(self):
    for i in range(self.start, self.end + 1):
        yield self._buffer[i]

</t>
<t tx="ekr.20181012124135.1">@path C:/Anaconda3/Lib/site-packages/neovim/plugin/
"""Nvim plugin/host subpackage."""

from .decorators import (autocmd, command, decode, encoding, function,
                         plugin, rpc_export, shutdown_hook)
from .host import Host


__all__ = ('Host', 'plugin', 'rpc_export', 'command', 'autocmd',
           'function', 'encoding', 'decode', 'shutdown_hook')
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181012203356.1"></t>
</tnodes>
</leo_file>
