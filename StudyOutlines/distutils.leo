<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="34" left="122" height="989" width="1165"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20080401065127.5" str_leo_pos="4"><vh>Startup</vh>
<v t="ekr.20080401065127.1"><vh>@chapters</vh></v>
</v>
<v t="ekr.20080401065127.3"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20080401090200.2"><vh>@path c:/Python25/Lib/distutils/command</vh>
<v t="ekr.20080401090200.3"><vh>@@auto bdist.py</vh>
<v t="ekr.20080401090728.11"><vh>bdist declarations</vh></v>
<v t="ekr.20080401090728.12"><vh>show_formats</vh></v>
<v t="ekr.20080401090728.13"><vh>class bdist</vh>
<v t="ekr.20080401090728.14"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.15"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.16"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20080401090200.4"><vh>@@auto bdist_dumb.py</vh>
<v t="ekr.20080401090728.17"><vh>bdist_dumb declarations</vh></v>
<v t="ekr.20080401090728.18"><vh>class bdist_dumb</vh>
<v t="ekr.20080401090728.19"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.20"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.21"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20080401090200.5"><vh>@@auto bdist_msi.py</vh>
<v t="ekr.20080401090639.1"><vh>bdist_msi declarations</vh></v>
<v t="ekr.20080401090639.2"><vh>class PyDialog</vh>
<v t="ekr.20080401090639.3"><vh>__init__</vh></v>
<v t="ekr.20080401090639.4"><vh>title</vh></v>
<v t="ekr.20080401090639.5"><vh>back</vh></v>
<v t="ekr.20080401090639.6"><vh>cancel</vh></v>
<v t="ekr.20080401090639.7"><vh>next</vh></v>
<v t="ekr.20080401090639.8"><vh>xbutton</vh></v>
</v>
<v t="ekr.20080401090639.9"><vh>class bdist_msi</vh>
<v t="ekr.20080401090639.10"><vh>initialize_options</vh></v>
<v t="ekr.20080401090639.11"><vh>finalize_options</vh></v>
<v t="ekr.20080401090639.12"><vh>run</vh></v>
<v t="ekr.20080401090639.13"><vh>add_files</vh></v>
<v t="ekr.20080401090639.14"><vh>add_find_python</vh></v>
<v t="ekr.20080401090639.15"><vh>add_scripts</vh></v>
<v t="ekr.20080401090639.16"><vh>add_ui</vh></v>
<v t="ekr.20080401090639.17"><vh>get_installer_filename</vh></v>
</v>
</v>
<v t="ekr.20080401090200.6"><vh>@@auto bdist_rpm.py</vh>
<v t="ekr.20080401090728.22"><vh>bdist_rpm declarations</vh></v>
<v t="ekr.20080401090728.23"><vh>class bdist_rpm</vh>
<v t="ekr.20080401090728.24"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.25"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.26"><vh>finalize_package_data</vh></v>
<v t="ekr.20080401090728.27"><vh>run</vh></v>
<v t="ekr.20080401090728.28"><vh>_dist_path</vh></v>
<v t="ekr.20080401090728.29"><vh>_make_spec_file</vh></v>
<v t="ekr.20080401090728.30"><vh>_format_changelog</vh></v>
</v>
</v>
<v t="ekr.20080401090200.7"><vh>@@auto bdist_wininst.py</vh>
<v t="ekr.20080401090728.31"><vh>bdist_wininst declarations</vh></v>
<v t="ekr.20080401090728.32"><vh>class bdist_wininst</vh>
<v t="ekr.20080401090728.33"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.34"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.35"><vh>run</vh></v>
<v t="ekr.20080401090728.36"><vh>get_inidata</vh></v>
<v t="ekr.20080401090728.37"><vh>create_exe</vh></v>
<v t="ekr.20080401090728.38"><vh>get_installer_filename</vh></v>
<v t="ekr.20080401090728.39"><vh>get_exe_bytes</vh></v>
</v>
</v>
<v t="ekr.20080401090200.8"><vh>@@auto build.py</vh>
<v t="ekr.20080401090728.40"><vh>build declarations</vh></v>
<v t="ekr.20080401090728.41"><vh>show_compilers</vh></v>
<v t="ekr.20080401090728.42"><vh>class build</vh>
<v t="ekr.20080401090728.43"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.44"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.45"><vh>run</vh></v>
<v t="ekr.20080401090728.46"><vh>has_pure_modules</vh></v>
<v t="ekr.20080401090728.47"><vh>has_c_libraries</vh></v>
<v t="ekr.20080401090728.48"><vh>has_ext_modules</vh></v>
<v t="ekr.20080401090728.49"><vh>has_scripts</vh></v>
</v>
</v>
<v t="ekr.20080401090200.9"><vh>@@auto build_clib.py</vh>
<v t="ekr.20080401090728.50"><vh>build_clib declarations</vh></v>
<v t="ekr.20080401090728.51"><vh>show_compilers</vh></v>
<v t="ekr.20080401090728.52"><vh>class build_clib</vh>
<v t="ekr.20080401090728.53"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.54"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.55"><vh>run</vh></v>
<v t="ekr.20080401090728.56"><vh>check_library_list</vh></v>
<v t="ekr.20080401090728.57"><vh>get_library_names</vh></v>
<v t="ekr.20080401090728.58"><vh>get_source_files</vh></v>
<v t="ekr.20080401090728.59"><vh>build_libraries</vh></v>
</v>
</v>
<v t="ekr.20080401090200.10"><vh>@@auto build_ext.py</vh>
<v t="ekr.20080401090728.60"><vh>build_ext declarations</vh></v>
<v t="ekr.20080401090728.61"><vh>show_compilers</vh></v>
<v t="ekr.20080401090728.62" a="E"><vh>class build_ext</vh>
<v t="ekr.20080401090728.63"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.64"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.65"><vh>run</vh></v>
<v t="ekr.20080401090728.66"><vh>check_extensions_list</vh></v>
<v t="ekr.20080401090728.67"><vh>get_source_files</vh></v>
<v t="ekr.20080401090728.68"><vh>get_outputs</vh></v>
<v t="ekr.20080401090728.69"><vh>build_extensions</vh></v>
<v t="ekr.20080401090728.70"><vh>build_extension</vh></v>
<v t="ekr.20080401090728.71"><vh>swig_sources</vh></v>
<v t="ekr.20080401090728.72"><vh>find_swig</vh></v>
<v t="ekr.20080401090728.73"><vh>get_ext_fullname</vh></v>
<v t="ekr.20080401090728.74"><vh>get_ext_filename</vh></v>
<v t="ekr.20080401090728.75"><vh>get_export_symbols</vh></v>
<v t="ekr.20080401090728.76"><vh>get_libraries</vh></v>
</v>
</v>
<v t="ekr.20080401090200.11"><vh>@@auto build_py.py</vh>
<v t="ekr.20080401090728.77"><vh>build_py declarations</vh></v>
<v t="ekr.20080401090728.78" a="E"><vh>class build_py</vh>
<v t="ekr.20080401090728.79"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.80"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.81" a="E"><vh>run</vh>
<v t="ekr.20080401090728.95"><vh>build_modules</vh></v>
<v t="ekr.20080401090728.96"><vh>build_packages</vh></v>
<v t="ekr.20080401090728.94"><vh>build_module</vh></v>
</v>
<v t="ekr.20080401090728.82"><vh>get_data_files</vh></v>
<v t="ekr.20080401090728.83"><vh>find_data_files</vh></v>
<v t="ekr.20080401090728.84"><vh>build_package_data</vh></v>
<v t="ekr.20080401090728.85"><vh>get_package_dir</vh></v>
<v t="ekr.20080401090728.86"><vh>check_package</vh></v>
<v t="ekr.20080401090728.87"><vh>check_module</vh></v>
<v t="ekr.20080401090728.88"><vh>find_package_modules</vh></v>
<v t="ekr.20080401090728.90"><vh>find_all_modules</vh>
<v t="ekr.20080401090728.89"><vh>find_modules</vh></v>
</v>
<v t="ekr.20080401090728.91"><vh>get_source_files</vh></v>
<v t="ekr.20080401090728.92"><vh>get_module_outfile</vh></v>
<v t="ekr.20080401090728.93"><vh>get_outputs</vh></v>
<v t="ekr.20080401090728.97"><vh>byte_compile</vh></v>
</v>
</v>
<v t="ekr.20080401090200.12"><vh>@@auto build_scripts.py</vh>
<v t="ekr.20080401090728.98"><vh>build_scripts declarations</vh></v>
<v t="ekr.20080401090728.99"><vh>class build_scripts</vh>
<v t="ekr.20080401090728.100"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.101"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.102"><vh>get_source_files</vh></v>
<v t="ekr.20080401090728.103"><vh>run</vh></v>
<v t="ekr.20080401090728.104"><vh>copy_scripts</vh></v>
</v>
</v>
<v t="ekr.20080401090200.13"><vh>@@auto clean.py</vh>
<v t="ekr.20080401090728.105"><vh>clean declarations</vh></v>
<v t="ekr.20080401090728.106"><vh>class clean</vh>
<v t="ekr.20080401090728.107"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.108"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.109"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20080401090200.14"><vh>@@auto config.py</vh>
<v t="ekr.20080401090728.110"><vh>config declarations</vh></v>
<v t="ekr.20080401090728.111"><vh>class config</vh>
<v t="ekr.20080401090728.112"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.113"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.114"><vh>run</vh></v>
<v t="ekr.20080401090728.115"><vh>_check_compiler</vh></v>
<v t="ekr.20080401090728.116"><vh>_gen_temp_sourcefile</vh></v>
<v t="ekr.20080401090728.117"><vh>_preprocess</vh></v>
<v t="ekr.20080401090728.118"><vh>_compile</vh></v>
<v t="ekr.20080401090728.119"><vh>_link</vh></v>
<v t="ekr.20080401090728.120"><vh>_clean</vh></v>
<v t="ekr.20080401090728.121"><vh>try_cpp</vh></v>
<v t="ekr.20080401090728.122"><vh>search_cpp</vh></v>
<v t="ekr.20080401090728.123"><vh>try_compile</vh></v>
<v t="ekr.20080401090728.124"><vh>try_link</vh></v>
<v t="ekr.20080401090728.125"><vh>try_run</vh></v>
<v t="ekr.20080401090728.126"><vh>check_func</vh></v>
<v t="ekr.20080401090728.127"><vh>check_lib</vh></v>
<v t="ekr.20080401090728.128"><vh>check_header</vh></v>
</v>
<v t="ekr.20080401090728.129"><vh>dump_file</vh></v>
</v>
<v t="ekr.20080401090200.15"><vh>@@auto install.py</vh>
<v t="ekr.20080401090728.130"><vh>install declarations</vh></v>
<v t="ekr.20080401090728.131" a="E"><vh>class install</vh>
<v t="ekr.20080401090728.132"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.133"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.134"><vh>dump_dirs</vh></v>
<v t="ekr.20080401090728.135"><vh>finalize_unix</vh></v>
<v t="ekr.20080401090728.136"><vh>finalize_other</vh></v>
<v t="ekr.20080401090728.137"><vh>select_scheme</vh></v>
<v t="ekr.20080401090728.138"><vh>_expand_attrs</vh></v>
<v t="ekr.20080401090728.139"><vh>expand_basedirs</vh></v>
<v t="ekr.20080401090728.140"><vh>expand_dirs</vh></v>
<v t="ekr.20080401090728.141"><vh>convert_paths</vh></v>
<v t="ekr.20080401090728.142"><vh>handle_extra_path</vh></v>
<v t="ekr.20080401090728.143"><vh>change_roots</vh></v>
<v t="ekr.20080401090728.144"><vh>run</vh></v>
<v t="ekr.20080401090728.145"><vh>create_path_file</vh></v>
<v t="ekr.20080401090728.146"><vh>get_outputs</vh></v>
<v t="ekr.20080401090728.147"><vh>get_inputs</vh></v>
<v t="ekr.20080401090728.148"><vh>has_lib</vh></v>
<v t="ekr.20080401090728.149"><vh>has_headers</vh></v>
<v t="ekr.20080401090728.150"><vh>has_scripts</vh></v>
<v t="ekr.20080401090728.151"><vh>has_data</vh></v>
</v>
</v>
<v t="ekr.20080401090200.16"><vh>@@auto install_data.py</vh>
<v t="ekr.20080401090728.152"><vh>install_data declarations</vh></v>
<v t="ekr.20080401090728.153"><vh>class install_data</vh>
<v t="ekr.20080401090728.154"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.155"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.156"><vh>run</vh></v>
<v t="ekr.20080401090728.157"><vh>get_inputs</vh></v>
<v t="ekr.20080401090728.158"><vh>get_outputs</vh></v>
</v>
</v>
<v t="ekr.20080401090200.17"><vh>@@auto install_egg_info.py</vh>
<v t="ekr.20080401090728.159"><vh>install_egg_info declarations</vh></v>
<v t="ekr.20080401090728.160"><vh>class install_egg_info</vh>
<v t="ekr.20080401090728.161"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.162"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.163"><vh>run</vh></v>
<v t="ekr.20080401090728.164"><vh>get_outputs</vh></v>
</v>
<v t="ekr.20080401090728.165"><vh>safe_name</vh></v>
<v t="ekr.20080401090728.166"><vh>safe_version</vh></v>
<v t="ekr.20080401090728.167"><vh>to_filename</vh></v>
</v>
<v t="ekr.20080401090200.18"><vh>@@auto install_headers.py</vh>
<v t="ekr.20080401090728.168"><vh>install_headers declarations</vh></v>
<v t="ekr.20080401090728.169"><vh>class install_headers</vh>
<v t="ekr.20080401090728.170"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.171"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.172"><vh>run</vh></v>
<v t="ekr.20080401090728.173"><vh>get_inputs</vh></v>
<v t="ekr.20080401090728.174"><vh>get_outputs</vh></v>
</v>
</v>
<v t="ekr.20080401090200.19"><vh>@@auto install_lib.py</vh>
<v t="ekr.20080401090728.175"><vh>install_lib declarations</vh></v>
<v t="ekr.20080401090728.176"><vh>class install_lib</vh>
<v t="ekr.20080401090728.177"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.178"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.179"><vh>run</vh></v>
<v t="ekr.20080401090728.180"><vh>build</vh></v>
<v t="ekr.20080401090728.181"><vh>install</vh></v>
<v t="ekr.20080401090728.182"><vh>byte_compile</vh></v>
<v t="ekr.20080401090728.183"><vh>_mutate_outputs</vh></v>
<v t="ekr.20080401090728.184"><vh>_bytecode_filenames</vh></v>
<v t="ekr.20080401090728.185"><vh>get_outputs</vh></v>
<v t="ekr.20080401090728.186"><vh>get_inputs</vh></v>
</v>
</v>
<v t="ekr.20080401090200.20"><vh>@@auto install_scripts.py</vh>
<v t="ekr.20080401090728.187"><vh>install_scripts declarations</vh></v>
<v t="ekr.20080401090728.188"><vh>class install_scripts</vh>
<v t="ekr.20080401090728.189"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.190"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.191"><vh>run</vh></v>
<v t="ekr.20080401090728.192"><vh>get_inputs</vh></v>
<v t="ekr.20080401090728.193"><vh>get_outputs</vh></v>
</v>
</v>
<v t="ekr.20080401090200.21"><vh>@@auto register.py</vh>
<v t="ekr.20080401090639.18"><vh>register declarations</vh></v>
<v t="ekr.20080401090639.19"><vh>class register</vh>
<v t="ekr.20080401090639.20"><vh>initialize_options</vh></v>
<v t="ekr.20080401090639.21"><vh>finalize_options</vh></v>
<v t="ekr.20080401090639.22"><vh>run</vh></v>
<v t="ekr.20080401090639.23"><vh>check_metadata</vh></v>
<v t="ekr.20080401090639.24"><vh>classifiers</vh></v>
<v t="ekr.20080401090639.25"><vh>verify_metadata</vh></v>
<v t="ekr.20080401090639.26"><vh>send_metadata</vh></v>
<v t="ekr.20080401090639.27"><vh>build_post_data</vh></v>
<v t="ekr.20080401090639.28"><vh>post_to_server</vh></v>
</v>
</v>
<v t="ekr.20080401090200.22"><vh>@@auto sdist.py</vh>
<v t="ekr.20080401090728.194"><vh>sdist declarations</vh></v>
<v t="ekr.20080401090728.195"><vh>show_formats</vh></v>
<v t="ekr.20080401090728.196"><vh>class sdist (Command)</vh>
<v t="ekr.20080401090728.197"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.198"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.199"><vh>run</vh></v>
<v t="ekr.20080401090728.200"><vh>check_metadata</vh></v>
<v t="ekr.20080401090728.201"><vh>get_file_list</vh></v>
<v t="ekr.20080401090728.202"><vh>add_defaults</vh></v>
<v t="ekr.20080401090728.203"><vh>read_template</vh></v>
<v t="ekr.20080401090728.204"><vh>prune_file_list</vh></v>
<v t="ekr.20080401090728.205"><vh>write_manifest</vh></v>
<v t="ekr.20080401090728.206"><vh>read_manifest</vh></v>
<v t="ekr.20080401090728.207"><vh>make_release_tree</vh></v>
<v t="ekr.20080401090728.208"><vh>make_distribution</vh></v>
<v t="ekr.20080401090728.209"><vh>get_archive_files</vh></v>
</v>
</v>
<v t="ekr.20080401090200.23"><vh>@@auto upload.py</vh>
<v t="ekr.20080401090728.210"><vh>upload declarations</vh></v>
<v t="ekr.20080401090728.211"><vh>class upload</vh>
<v t="ekr.20080401090728.212"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.213"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.214"><vh>run</vh></v>
<v t="ekr.20080401090728.215"><vh>upload_file</vh></v>
</v>
</v>
<v t="ekr.20080401090200.24"><vh>@@auto __init__.py</vh>
<v t="ekr.20080401090728.216"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20080401090200.25"><vh>@path c:/Python25/Lib/distutils</vh>
<v t="ekr.20080401090200.26"><vh>@@auto archive_util.py</vh>
<v t="ekr.20080401090728.217"><vh>archive_util declarations</vh></v>
<v t="ekr.20080401090728.218"><vh>make_tarball</vh></v>
<v t="ekr.20080401090728.219"><vh>make_zipfile</vh></v>
<v t="ekr.20080401090728.220"><vh>check_archive_formats</vh></v>
<v t="ekr.20080401090728.221"><vh>make_archive</vh></v>
</v>
<v t="ekr.20080401090200.27"><vh>@@auto bcppcompiler.py</vh>
<v t="ekr.20080401090728.222"><vh>bcppcompiler declarations</vh></v>
<v t="ekr.20080401090728.223"><vh>class BCPPCompiler</vh>
<v t="ekr.20080401090728.224"><vh>__init__</vh></v>
<v t="ekr.20080401090728.225"><vh>compile</vh></v>
<v t="ekr.20080401090728.226"><vh>create_static_lib</vh></v>
<v t="ekr.20080401090728.227"><vh>link</vh></v>
<v t="ekr.20080401090728.228"><vh>find_library_file</vh></v>
<v t="ekr.20080401090728.229"><vh>object_filenames</vh></v>
<v t="ekr.20080401090728.230"><vh>preprocess</vh></v>
</v>
</v>
<v t="ekr.20080401090200.28"><vh>@@auto ccompiler.py</vh>
<v t="ekr.20080401090512.1"><vh>ccompiler declarations</vh></v>
<v t="ekr.20080401090512.2"><vh>class CCompiler</vh>
<v t="ekr.20080401090512.3"><vh>__init__</vh></v>
<v t="ekr.20080401090512.4"><vh>set_executables</vh></v>
<v t="ekr.20080401090512.5"><vh>set_executable</vh></v>
<v t="ekr.20080401090512.6"><vh>_find_macro</vh></v>
<v t="ekr.20080401090512.7"><vh>_check_macro_definitions</vh></v>
<v t="ekr.20080401090512.8"><vh>define_macro</vh></v>
<v t="ekr.20080401090512.9"><vh>undefine_macro</vh></v>
<v t="ekr.20080401090512.10"><vh>add_include_dir</vh></v>
<v t="ekr.20080401090512.11"><vh>set_include_dirs</vh></v>
<v t="ekr.20080401090512.12"><vh>add_library</vh></v>
<v t="ekr.20080401090512.13"><vh>set_libraries</vh></v>
<v t="ekr.20080401090512.14"><vh>add_library_dir</vh></v>
<v t="ekr.20080401090512.15"><vh>set_library_dirs</vh></v>
<v t="ekr.20080401090512.16"><vh>add_runtime_library_dir</vh></v>
<v t="ekr.20080401090512.17"><vh>set_runtime_library_dirs</vh></v>
<v t="ekr.20080401090512.18"><vh>add_link_object</vh></v>
<v t="ekr.20080401090512.19"><vh>set_link_objects</vh></v>
<v t="ekr.20080401090512.20"><vh>_setup_compile</vh></v>
<v t="ekr.20080401090512.21"><vh>_get_cc_args</vh></v>
<v t="ekr.20080401090512.22"><vh>_fix_compile_args</vh></v>
<v t="ekr.20080401090512.23"><vh>_prep_compile</vh></v>
<v t="ekr.20080401090512.24"><vh>_fix_object_args</vh></v>
<v t="ekr.20080401090512.25"><vh>_fix_lib_args</vh></v>
<v t="ekr.20080401090512.26"><vh>_need_link</vh></v>
<v t="ekr.20080401090512.27"><vh>detect_language</vh></v>
<v t="ekr.20080401090512.28"><vh>preprocess</vh></v>
<v t="ekr.20080401090512.29"><vh>compile</vh></v>
<v t="ekr.20080401090512.30"><vh>_compile</vh></v>
<v t="ekr.20080401090512.31"><vh>create_static_lib</vh></v>
<v t="ekr.20080401090512.32"><vh>link</vh></v>
<v t="ekr.20080401090512.33"><vh>link_shared_lib</vh></v>
<v t="ekr.20080401090512.34"><vh>link_shared_object</vh></v>
<v t="ekr.20080401090512.35"><vh>link_executable</vh></v>
<v t="ekr.20080401090512.36"><vh>library_dir_option</vh></v>
<v t="ekr.20080401090512.37"><vh>runtime_library_dir_option</vh></v>
<v t="ekr.20080401090512.38"><vh>library_option</vh></v>
<v t="ekr.20080401090512.39"><vh>has_function</vh></v>
<v t="ekr.20080401090512.40"><vh>find_library_file</vh></v>
<v t="ekr.20080401090512.41"><vh>object_filenames</vh></v>
<v t="ekr.20080401090512.42"><vh>shared_object_filename</vh></v>
<v t="ekr.20080401090512.43"><vh>executable_filename</vh></v>
<v t="ekr.20080401090512.44"><vh>library_filename</vh></v>
<v t="ekr.20080401090512.45"><vh>announce</vh></v>
<v t="ekr.20080401090512.46"><vh>debug_print</vh></v>
<v t="ekr.20080401090512.47"><vh>warn</vh></v>
<v t="ekr.20080401090512.48"><vh>execute</vh></v>
<v t="ekr.20080401090512.49"><vh>spawn</vh></v>
<v t="ekr.20080401090512.50"><vh>move_file</vh></v>
<v t="ekr.20080401090512.51"><vh>mkpath</vh></v>
</v>
<v t="ekr.20080401090512.52"><vh>get_default_compiler</vh></v>
<v t="ekr.20080401090512.53"><vh>show_compilers</vh></v>
<v t="ekr.20080401090512.54"><vh>new_compiler</vh></v>
<v t="ekr.20080401090512.55"><vh>gen_preprocess_options</vh></v>
<v t="ekr.20080401090512.56"><vh>gen_lib_options</vh></v>
</v>
<v t="ekr.20080401090200.29"><vh>@@auto cmd.py</vh>
<v t="ekr.20080401090728.231"><vh>cmd declarations</vh></v>
<v t="ekr.20080401090728.232" a="E"><vh>class Command</vh>
<v t="ekr.20080401090728.233"><vh>__init__</vh></v>
<v t="ekr.20080401090728.234"><vh>__getattr__</vh></v>
<v t="ekr.20080401090728.235"><vh>ensure_finalized</vh></v>
<v t="ekr.20080401090728.236"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.237"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.238"><vh>dump_options</vh></v>
<v t="ekr.20080401090728.239"><vh>run</vh></v>
<v t="ekr.20080401090728.240"><vh>announce</vh></v>
<v t="ekr.20080401090728.241"><vh>debug_print</vh></v>
<v t="ekr.20080401090728.242"><vh>_ensure_stringlike</vh></v>
<v t="ekr.20080401090728.243"><vh>ensure_string</vh></v>
<v t="ekr.20080401090728.244"><vh>ensure_string_list</vh></v>
<v t="ekr.20080401090728.245"><vh>_ensure_tested_string</vh></v>
<v t="ekr.20080401090728.246"><vh>ensure_filename</vh></v>
<v t="ekr.20080401090728.247"><vh>ensure_dirname</vh></v>
<v t="ekr.20080401090728.248"><vh>get_command_name</vh></v>
<v t="ekr.20080401090728.249"><vh>set_undefined_options</vh></v>
<v t="ekr.20080401090728.250"><vh>get_finalized_command</vh></v>
<v t="ekr.20080401090728.251"><vh>reinitialize_command</vh></v>
<v t="ekr.20080401090728.252"><vh>run_command</vh></v>
<v t="ekr.20080401090728.253"><vh>get_sub_commands</vh></v>
<v t="ekr.20080401090728.254"><vh>warn</vh></v>
<v t="ekr.20080401090728.255"><vh>execute</vh></v>
<v t="ekr.20080401090728.256"><vh>mkpath</vh></v>
<v t="ekr.20080401090728.257"><vh>copy_file</vh></v>
<v t="ekr.20080401090728.258"><vh>copy_tree</vh></v>
<v t="ekr.20080401090728.259"><vh>move_file</vh></v>
<v t="ekr.20080401090728.260"><vh>spawn</vh></v>
<v t="ekr.20080401090728.261"><vh>make_archive</vh></v>
<v t="ekr.20080401090728.262"><vh>make_file</vh></v>
</v>
<v t="ekr.20080401090728.263"><vh>class install_misc</vh>
<v t="ekr.20080401090728.264"><vh>initialize_options</vh></v>
<v t="ekr.20080401090728.265"><vh>_install_dir_from</vh></v>
<v t="ekr.20080401090728.266"><vh>_copy_files</vh></v>
<v t="ekr.20080401090728.267"><vh>get_outputs</vh></v>
</v>
</v>
<v t="ekr.20080401090200.30"><vh>@@auto core.py</vh>
<v t="ekr.20080401090728.268"><vh>core declarations</vh></v>
<v t="ekr.20080401090728.269"><vh>gen_usage</vh></v>
<v t="ekr.20080401090728.270"><vh>setup</vh></v>
<v t="ekr.20080401090728.271"><vh>run_setup</vh></v>
</v>
<v t="ekr.20080401090200.31"><vh>@@auto cygwinccompiler.py</vh>
<v t="ekr.20080401090728.272"><vh>cygwinccompiler declarations</vh></v>
<v t="ekr.20080401090728.273"><vh>class CygwinCCompiler</vh>
<v t="ekr.20080401090728.274"><vh>__init__</vh></v>
<v t="ekr.20080401090728.275"><vh>_compile</vh></v>
<v t="ekr.20080401090728.276"><vh>link</vh></v>
<v t="ekr.20080401090728.277"><vh>object_filenames</vh></v>
</v>
<v t="ekr.20080401090728.278"><vh>class Mingw32CCompiler</vh>
<v t="ekr.20080401090728.279"><vh>__init__</vh></v>
</v>
<v t="ekr.20080401090728.280"><vh>check_config_h</vh></v>
<v t="ekr.20080401090728.281"><vh>get_versions</vh></v>
</v>
<v t="ekr.20080401090200.32"><vh>@@auto debug.py</vh>
<v t="ekr.20080401090728.282"><vh>debug declarations</vh></v>
</v>
<v t="ekr.20080401090200.33"><vh>@@auto dep_util.py</vh>
<v t="ekr.20080401090728.283"><vh>dep_util declarations</vh></v>
<v t="ekr.20080401090728.284"><vh>newer</vh></v>
<v t="ekr.20080401090728.285"><vh>newer_pairwise</vh></v>
<v t="ekr.20080401090728.286"><vh>newer_group</vh></v>
</v>
<v t="ekr.20080401090200.34"><vh>@@auto dir_util.py</vh>
<v t="ekr.20080401090728.287"><vh>dir_util declarations</vh></v>
<v t="ekr.20080401090728.288"><vh>mkpath</vh></v>
<v t="ekr.20080401090728.289"><vh>create_tree</vh></v>
<v t="ekr.20080401090728.290"><vh>copy_tree</vh></v>
<v t="ekr.20080401090728.291"><vh>_build_cmdtuple</vh></v>
<v t="ekr.20080401090728.292"><vh>remove_tree</vh></v>
<v t="ekr.20080401090728.293"><vh>ensure_relative</vh></v>
</v>
<v t="ekr.20080401090200.35"><vh>@@auto dist.py</vh>
<v t="ekr.20080401090728.294"><vh>dist declarations</vh></v>
<v t="ekr.20080401090728.295"><vh>class Distribution</vh>
<v t="ekr.20080401090728.296"><vh>__init__</vh></v>
<v t="ekr.20080401090728.297"><vh>get_option_dict</vh></v>
<v t="ekr.20080401090728.298"><vh>dump_option_dicts</vh></v>
<v t="ekr.20080401090728.299"><vh>find_config_files</vh></v>
<v t="ekr.20080401090728.300"><vh>parse_config_files</vh></v>
<v t="ekr.20080401090728.301"><vh>parse_command_line</vh></v>
<v t="ekr.20080401090728.302"><vh>_get_toplevel_options</vh></v>
<v t="ekr.20080401090728.303"><vh>_parse_command_opts</vh></v>
<v t="ekr.20080401090728.304"><vh>finalize_options</vh></v>
<v t="ekr.20080401090728.305"><vh>_show_help</vh></v>
<v t="ekr.20080401090728.306"><vh>handle_display_options</vh></v>
<v t="ekr.20080401090728.307"><vh>print_command_list</vh></v>
<v t="ekr.20080401090728.308"><vh>print_commands</vh></v>
<v t="ekr.20080401090728.309"><vh>get_command_list</vh></v>
<v t="ekr.20080401090728.310"><vh>get_command_packages</vh></v>
<v t="ekr.20080401090728.311"><vh>get_command_class</vh></v>
<v t="ekr.20080401090728.312"><vh>get_command_obj</vh></v>
<v t="ekr.20080401090728.313"><vh>_set_command_options</vh></v>
<v t="ekr.20080401090728.314"><vh>reinitialize_command</vh></v>
<v t="ekr.20080401090728.315"><vh>announce</vh></v>
<v t="ekr.20080401090728.316"><vh>run_commands</vh></v>
<v t="ekr.20080401090728.317"><vh>run_command</vh></v>
<v t="ekr.20080401090728.318"><vh>has_pure_modules</vh></v>
<v t="ekr.20080401090728.319"><vh>has_ext_modules</vh></v>
<v t="ekr.20080401090728.320"><vh>has_c_libraries</vh></v>
<v t="ekr.20080401090728.321"><vh>has_modules</vh></v>
<v t="ekr.20080401090728.322"><vh>has_headers</vh></v>
<v t="ekr.20080401090728.323"><vh>has_scripts</vh></v>
<v t="ekr.20080401090728.324"><vh>has_data_files</vh></v>
<v t="ekr.20080401090728.325"><vh>is_pure</vh></v>
</v>
<v t="ekr.20080401090728.326"><vh>class DistributionMetadata</vh>
<v t="ekr.20080401090728.327"><vh>__init__</vh></v>
<v t="ekr.20080401090728.328"><vh>write_pkg_info</vh></v>
<v t="ekr.20080401090728.329"><vh>write_pkg_file</vh></v>
<v t="ekr.20080401090728.330"><vh>_write_list</vh></v>
<v t="ekr.20080401090728.331"><vh>get_name</vh></v>
<v t="ekr.20080401090728.332"><vh>get_version</vh></v>
<v t="ekr.20080401090728.333"><vh>get_fullname</vh></v>
<v t="ekr.20080401090728.334"><vh>get_author</vh></v>
<v t="ekr.20080401090728.335"><vh>get_author_email</vh></v>
<v t="ekr.20080401090728.336"><vh>get_maintainer</vh></v>
<v t="ekr.20080401090728.337"><vh>get_maintainer_email</vh></v>
<v t="ekr.20080401090728.338"><vh>get_contact</vh></v>
<v t="ekr.20080401090728.339"><vh>get_contact_email</vh></v>
<v t="ekr.20080401090728.340"><vh>get_url</vh></v>
<v t="ekr.20080401090728.341"><vh>get_license</vh></v>
<v t="ekr.20080401090728.342"><vh>get_description</vh></v>
<v t="ekr.20080401090728.343"><vh>get_long_description</vh></v>
<v t="ekr.20080401090728.344"><vh>get_keywords</vh></v>
<v t="ekr.20080401090728.345"><vh>get_platforms</vh></v>
<v t="ekr.20080401090728.346"><vh>get_classifiers</vh></v>
<v t="ekr.20080401090728.347"><vh>get_download_url</vh></v>
<v t="ekr.20080401090728.348"><vh>get_requires</vh></v>
<v t="ekr.20080401090728.349"><vh>set_requires</vh></v>
<v t="ekr.20080401090728.350"><vh>get_provides</vh></v>
<v t="ekr.20080401090728.351"><vh>set_provides</vh></v>
<v t="ekr.20080401090728.352"><vh>get_obsoletes</vh></v>
<v t="ekr.20080401090728.353"><vh>set_obsoletes</vh></v>
</v>
<v t="ekr.20080401090728.354"><vh>fix_help_options</vh></v>
</v>
<v t="ekr.20080401090200.36"><vh>@@auto emxccompiler.py</vh>
<v t="ekr.20080401090728.355"><vh>emxccompiler declarations</vh></v>
<v t="ekr.20080401090728.356"><vh>class EMXCCompiler</vh>
<v t="ekr.20080401090728.357"><vh>__init__</vh></v>
<v t="ekr.20080401090728.358"><vh>_compile</vh></v>
<v t="ekr.20080401090728.359"><vh>link</vh></v>
<v t="ekr.20080401090728.360"><vh>object_filenames</vh></v>
<v t="ekr.20080401090728.361"><vh>find_library_file</vh></v>
</v>
<v t="ekr.20080401090728.362"><vh>check_config_h</vh></v>
<v t="ekr.20080401090728.363"><vh>get_versions</vh></v>
</v>
<v t="ekr.20080401090200.37"><vh>@@auto errors.py</vh>
<v t="ekr.20080401090728.364"><vh>errors declarations</vh></v>
<v t="ekr.20080401090728.365"><vh>class DistutilsError</vh></v>
<v t="ekr.20080401090728.366"><vh>class DistutilsModuleError</vh></v>
<v t="ekr.20080401090728.367"><vh>class DistutilsClassError</vh></v>
<v t="ekr.20080401090728.368"><vh>class DistutilsGetoptError</vh></v>
<v t="ekr.20080401090728.369"><vh>class DistutilsArgError</vh></v>
<v t="ekr.20080401090728.370"><vh>class DistutilsFileError</vh></v>
<v t="ekr.20080401090728.371"><vh>class DistutilsOptionError</vh></v>
<v t="ekr.20080401090728.372"><vh>class DistutilsSetupError</vh></v>
<v t="ekr.20080401090728.373"><vh>class DistutilsPlatformError</vh></v>
<v t="ekr.20080401090728.374"><vh>class DistutilsExecError</vh></v>
<v t="ekr.20080401090728.375"><vh>class DistutilsInternalError</vh></v>
<v t="ekr.20080401090728.376"><vh>class DistutilsTemplateError</vh></v>
<v t="ekr.20080401090728.377"><vh>class CCompilerError</vh></v>
<v t="ekr.20080401090728.378"><vh>class PreprocessError</vh></v>
<v t="ekr.20080401090728.379"><vh>class CompileError</vh></v>
<v t="ekr.20080401090728.380"><vh>class LibError</vh></v>
<v t="ekr.20080401090728.381"><vh>class LinkError</vh></v>
<v t="ekr.20080401090728.382"><vh>class UnknownFileError</vh></v>
</v>
<v t="ekr.20080401090200.38"><vh>@@auto extension.py</vh>
<v t="ekr.20080401090728.383"><vh>extension declarations</vh></v>
<v t="ekr.20080401090728.386"><vh>read_setup_file</vh></v>
<v t="ekr.20080401090728.384"><vh>class Extension</vh>
<v t="ekr.20080401090728.385"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20080401090200.39"><vh>@@auto fancy_getopt.py</vh>
<v t="ekr.20080401090728.387"><vh>fancy_getopt declarations</vh></v>
<v t="ekr.20080401090728.388"><vh>class FancyGetopt</vh>
<v t="ekr.20080401090728.389"><vh>__init__</vh></v>
<v t="ekr.20080401090728.390"><vh>_build_index</vh></v>
<v t="ekr.20080401090728.391"><vh>set_option_table</vh></v>
<v t="ekr.20080401090728.392"><vh>add_option</vh></v>
<v t="ekr.20080401090728.393"><vh>has_option</vh></v>
<v t="ekr.20080401090728.394"><vh>get_attr_name</vh></v>
<v t="ekr.20080401090728.395"><vh>_check_alias_dict</vh></v>
<v t="ekr.20080401090728.396"><vh>set_aliases</vh></v>
<v t="ekr.20080401090728.397"><vh>set_negative_aliases</vh></v>
<v t="ekr.20080401090728.398"><vh>_grok_option_table</vh></v>
<v t="ekr.20080401090728.399"><vh>getopt</vh></v>
<v t="ekr.20080401090728.400"><vh>get_option_order</vh></v>
<v t="ekr.20080401090728.401"><vh>generate_help</vh></v>
<v t="ekr.20080401090728.402"><vh>print_help</vh></v>
</v>
<v t="ekr.20080401090728.403"><vh>fancy_getopt</vh></v>
<v t="ekr.20080401090728.404"><vh>wrap_text</vh></v>
<v t="ekr.20080401090728.405"><vh>translate_longopt</vh></v>
<v t="ekr.20080401090728.406"><vh>class OptionDummy</vh>
<v t="ekr.20080401090728.407"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20080401090200.40"><vh>@@auto filelist.py</vh>
<v t="ekr.20080401090728.408"><vh>filelist declarations</vh></v>
<v t="ekr.20080401090728.409"><vh>class FileList</vh>
<v t="ekr.20080401090728.410"><vh>__init__</vh></v>
<v t="ekr.20080401090728.411"><vh>set_allfiles</vh></v>
<v t="ekr.20080401090728.412"><vh>findall</vh></v>
<v t="ekr.20080401090728.413"><vh>debug_print</vh></v>
<v t="ekr.20080401090728.414"><vh>append</vh></v>
<v t="ekr.20080401090728.415"><vh>extend</vh></v>
<v t="ekr.20080401090728.416"><vh>sort</vh></v>
<v t="ekr.20080401090728.417"><vh>remove_duplicates</vh></v>
<v t="ekr.20080401090728.418"><vh>_parse_template_line</vh></v>
<v t="ekr.20080401090728.419"><vh>process_template_line</vh></v>
<v t="ekr.20080401090728.420"><vh>include_pattern</vh></v>
<v t="ekr.20080401090728.421"><vh>exclude_pattern</vh></v>
</v>
<v t="ekr.20080401090728.422"><vh>findall</vh></v>
<v t="ekr.20080401090728.423"><vh>glob_to_re</vh></v>
<v t="ekr.20080401090728.424"><vh>translate_pattern</vh></v>
</v>
<v t="ekr.20080401090200.41"><vh>@@auto file_util.py</vh>
<v t="ekr.20080401090728.425"><vh>file_util declarations</vh></v>
<v t="ekr.20080401090728.426"><vh>_copy_file_contents</vh></v>
<v t="ekr.20080401090728.427"><vh>copy_file</vh></v>
<v t="ekr.20080401090728.428"><vh>move_file</vh></v>
<v t="ekr.20080401090728.429"><vh>write_file</vh></v>
</v>
<v t="ekr.20080401090200.42"><vh>@@auto log.py</vh>
<v t="ekr.20080401090728.430"><vh>log declarations</vh></v>
<v t="ekr.20080401090728.431"><vh>class Log</vh>
<v t="ekr.20080401090728.432"><vh>__init__</vh></v>
<v t="ekr.20080401090728.433"><vh>_log</vh></v>
<v t="ekr.20080401090728.434"><vh>log</vh></v>
<v t="ekr.20080401090728.435"><vh>debug</vh></v>
<v t="ekr.20080401090728.436"><vh>info</vh></v>
<v t="ekr.20080401090728.437"><vh>warn</vh></v>
<v t="ekr.20080401090728.438"><vh>error</vh></v>
<v t="ekr.20080401090728.439"><vh>fatal</vh></v>
</v>
<v t="ekr.20080401090728.440"><vh>set_threshold</vh></v>
<v t="ekr.20080401090728.441"><vh>set_verbosity</vh></v>
</v>
<v t="ekr.20080401090200.43"><vh>@@auto msvccompiler.py</vh>
<v t="ekr.20080401090512.57"><vh>msvccompiler declarations</vh></v>
<v t="ekr.20080401090512.58"><vh>read_keys</vh></v>
<v t="ekr.20080401090512.59"><vh>read_values</vh></v>
<v t="ekr.20080401090512.60"><vh>convert_mbcs</vh></v>
<v t="ekr.20080401090512.61"><vh>class MacroExpander</vh>
<v t="ekr.20080401090512.62"><vh>__init__</vh></v>
<v t="ekr.20080401090512.63"><vh>set_macro</vh></v>
<v t="ekr.20080401090512.64"><vh>load_macros</vh></v>
<v t="ekr.20080401090512.65"><vh>sub</vh></v>
</v>
<v t="ekr.20080401090512.66"><vh>get_build_version</vh></v>
<v t="ekr.20080401090512.67"><vh>get_build_architecture</vh></v>
<v t="ekr.20080401090512.68" a="E"><vh>class MSVCCompiler</vh>
<v t="ekr.20080401090512.69"><vh>__init__</vh></v>
<v t="ekr.20080401090512.70"><vh>initialize</vh></v>
<v t="ekr.20080401090512.71"><vh>object_filenames</vh></v>
<v t="ekr.20080401090512.72"><vh>compile</vh></v>
<v t="ekr.20080401090512.73"><vh>create_static_lib</vh></v>
<v t="ekr.20080401090512.74"><vh>link</vh></v>
<v t="ekr.20080401090512.75"><vh>library_dir_option</vh></v>
<v t="ekr.20080401090512.76"><vh>runtime_library_dir_option</vh></v>
<v t="ekr.20080401090512.77"><vh>library_option</vh></v>
<v t="ekr.20080401090512.78"><vh>find_library_file</vh></v>
<v t="ekr.20080401090512.79"><vh>find_exe</vh></v>
<v t="ekr.20080401090512.80"><vh>get_msvc_paths</vh></v>
<v t="ekr.20080401090512.81"><vh>set_path_env_var</vh></v>
</v>
</v>
<v t="ekr.20080401090200.44"><vh>@@auto mwerkscompiler.py</vh>
<v t="ekr.20080401090728.1"><vh>mwerkscompiler declarations</vh></v>
<v t="ekr.20080401090728.2"><vh>class MWerksCompiler</vh>
<v t="ekr.20080401090728.3"><vh>__init__</vh></v>
<v t="ekr.20080401090728.4"><vh>compile</vh></v>
<v t="ekr.20080401090728.5"><vh>link</vh></v>
<v t="ekr.20080401090728.6"><vh>_filename_to_abs</vh></v>
<v t="ekr.20080401090728.7"><vh>library_dir_option</vh></v>
<v t="ekr.20080401090728.8"><vh>runtime_library_dir_option</vh></v>
<v t="ekr.20080401090728.9"><vh>library_option</vh></v>
<v t="ekr.20080401090728.10"><vh>find_library_file</vh></v>
</v>
</v>
<v t="ekr.20080401090200.45"><vh>@@auto spawn.py</vh>
<v t="ekr.20080401090728.442"><vh>spawn declarations</vh></v>
<v t="ekr.20080401090728.443"><vh>spawn</vh></v>
<v t="ekr.20080401090728.444"><vh>_nt_quote_args</vh></v>
<v t="ekr.20080401090728.445"><vh>_spawn_nt</vh></v>
<v t="ekr.20080401090728.446"><vh>_spawn_os2</vh></v>
<v t="ekr.20080401090728.447"><vh>_spawn_posix</vh></v>
<v t="ekr.20080401090728.448"><vh>find_executable</vh></v>
</v>
<v t="ekr.20080401090200.46"><vh>@@auto sysconfig.py</vh>
<v t="ekr.20080401090728.449"><vh>sysconfig declarations</vh></v>
<v t="ekr.20080401090728.450"><vh>get_python_version</vh></v>
<v t="ekr.20080401090728.451"><vh>get_python_inc</vh></v>
<v t="ekr.20080401090728.452"><vh>get_python_lib</vh></v>
<v t="ekr.20080401090728.453"><vh>customize_compiler</vh></v>
<v t="ekr.20080401090728.454"><vh>get_config_h_filename</vh></v>
<v t="ekr.20080401090728.455"><vh>get_makefile_filename</vh></v>
<v t="ekr.20080401090728.456"><vh>parse_config_h</vh></v>
<v t="ekr.20080401090728.457"><vh>parse_makefile</vh></v>
<v t="ekr.20080401090728.458"><vh>expand_makefile_vars</vh></v>
<v t="ekr.20080401090728.459"><vh>_init_posix</vh></v>
<v t="ekr.20080401090728.460"><vh>_init_nt</vh></v>
<v t="ekr.20080401090728.461"><vh>_init_mac</vh></v>
<v t="ekr.20080401090728.462"><vh>_init_os2</vh></v>
<v t="ekr.20080401090728.463"><vh>get_config_vars</vh></v>
<v t="ekr.20080401090728.464"><vh>get_config_var</vh></v>
</v>
<v t="ekr.20080401090200.47"><vh>@@auto text_file.py</vh>
<v t="ekr.20080401090728.465"><vh>text_file declarations</vh></v>
<v t="ekr.20080401090728.466"><vh>class TextFile</vh>
<v t="ekr.20080401090728.467"><vh>__init__</vh></v>
<v t="ekr.20080401090728.468"><vh>open</vh></v>
<v t="ekr.20080401090728.469"><vh>close</vh></v>
<v t="ekr.20080401090728.470"><vh>gen_error</vh></v>
<v t="ekr.20080401090728.471"><vh>error</vh></v>
<v t="ekr.20080401090728.472"><vh>warn</vh></v>
<v t="ekr.20080401090728.473"><vh>readline</vh></v>
<v t="ekr.20080401090728.474"><vh>readlines</vh></v>
<v t="ekr.20080401090728.475"><vh>unreadline</vh></v>
</v>
</v>
<v t="ekr.20080401090200.48"><vh>@@auto unixccompiler.py</vh>
<v t="ekr.20080401090728.476"><vh>unixccompiler declarations</vh></v>
<v t="ekr.20080401090728.477"><vh>_darwin_compiler_fixup</vh></v>
<v t="ekr.20080401090728.478"><vh>class UnixCCompiler</vh>
<v t="ekr.20080401090728.479"><vh>preprocess</vh></v>
<v t="ekr.20080401090728.480"><vh>_compile</vh></v>
<v t="ekr.20080401090728.481"><vh>create_static_lib</vh></v>
<v t="ekr.20080401090728.482"><vh>link</vh></v>
<v t="ekr.20080401090728.483"><vh>library_dir_option</vh></v>
<v t="ekr.20080401090728.484"><vh>runtime_library_dir_option</vh></v>
<v t="ekr.20080401090728.485"><vh>library_option</vh></v>
<v t="ekr.20080401090728.486"><vh>find_library_file</vh></v>
</v>
</v>
<v t="ekr.20080401090200.49"><vh>@@auto util.py</vh>
<v t="ekr.20080401090728.487"><vh>util declarations</vh></v>
<v t="ekr.20080401090728.488"><vh>get_platform</vh></v>
<v t="ekr.20080401090728.489"><vh>convert_path</vh></v>
<v t="ekr.20080401090728.490"><vh>change_root</vh></v>
<v t="ekr.20080401090728.491"><vh>check_environ</vh></v>
<v t="ekr.20080401090728.492"><vh>subst_vars</vh></v>
<v t="ekr.20080401090728.493"><vh>grok_environment_error</vh></v>
<v t="ekr.20080401090728.494"><vh>_init_regex</vh></v>
<v t="ekr.20080401090728.495"><vh>split_quoted</vh></v>
<v t="ekr.20080401090728.496"><vh>execute</vh></v>
<v t="ekr.20080401090728.497"><vh>strtobool</vh></v>
<v t="ekr.20080401090728.498"><vh>byte_compile</vh></v>
<v t="ekr.20080401090728.499"><vh>rfc822_escape</vh></v>
</v>
<v t="ekr.20080401090200.50"><vh>@@auto version.py</vh>
<v t="ekr.20080401090728.500"><vh>version declarations</vh></v>
<v t="ekr.20080401090728.501"><vh>class Version</vh>
<v t="ekr.20080401090728.502"><vh>__init__</vh></v>
<v t="ekr.20080401090728.503"><vh>__repr__</vh></v>
</v>
<v t="ekr.20080401090728.504"><vh>class StrictVersion</vh>
<v t="ekr.20080401090728.505"><vh>parse</vh></v>
<v t="ekr.20080401090728.506"><vh>__str__</vh></v>
<v t="ekr.20080401090728.507"><vh>__cmp__</vh></v>
</v>
<v t="ekr.20080401090728.508"><vh>class LooseVersion</vh>
<v t="ekr.20080401090728.509"><vh>__init__</vh></v>
<v t="ekr.20080401090728.510"><vh>parse</vh></v>
<v t="ekr.20080401090728.511"><vh>__str__</vh></v>
<v t="ekr.20080401090728.512"><vh>__repr__</vh></v>
<v t="ekr.20080401090728.513"><vh>__cmp__</vh></v>
</v>
</v>
<v t="ekr.20080401090200.51"><vh>@@auto versionpredicate.py</vh>
<v t="ekr.20080401090728.514"><vh>versionpredicate declarations</vh></v>
<v t="ekr.20080401090728.515"><vh>splitUp</vh></v>
<v t="ekr.20080401090728.516"><vh>class VersionPredicate</vh>
<v t="ekr.20080401090728.517"><vh>__init__</vh></v>
<v t="ekr.20080401090728.518"><vh>__str__</vh></v>
<v t="ekr.20080401090728.519"><vh>satisfied_by</vh></v>
</v>
<v t="ekr.20080401090728.520"><vh>split_provision</vh></v>
</v>
<v t="ekr.20080401090200.52"><vh>@@auto __init__.py</vh>
<v t="ekr.20080401090728.521"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20080401090728.522"><vh>Important files</vh>
<v t="ekr.20080401090200.33"></v>
<v t="ekr.20080401090200.30"></v>
<v t="ekr.20080401090200.38" a="E"></v>
<v t="ekr.20080401090200.28"></v>
<v t="ekr.20080401090200.10"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20080401065127.1"></t>
<t tx="ekr.20080401065127.3"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\distutils'

dirs = ('','command',) # '' represents the base dir.
print '-' * 40

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print ; print 'pattern:', pattern ; print
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080401065127.5"></t>
<t tx="ekr.20080401090200.2"></t>
<t tx="ekr.20080401090200.3">@language python
@tabwidth -4
@others
# class bdist
</t>
<t tx="ekr.20080401090200.4">@language python
@tabwidth -4
@others
# class bdist_dumb
</t>
<t tx="ekr.20080401090200.5">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20080401090200.6">@language python
@tabwidth -4
@others
# class bdist_rpm
</t>
<t tx="ekr.20080401090200.7">@language python
@tabwidth -4
@others
# class bdist_wininst
</t>
<t tx="ekr.20080401090200.8">@language python
@tabwidth -4
@others
# class build
</t>
<t tx="ekr.20080401090200.9">@language python
@tabwidth -4
@others
# class build_lib
</t>
<t tx="ekr.20080401090200.10">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.11">@language python
@tabwidth -4
@others
# class build_py
</t>
<t tx="ekr.20080401090200.12">@language python
@tabwidth -4
@others
# class build_scripts
</t>
<t tx="ekr.20080401090200.13">@language python
@tabwidth -4
@others
# class clean
</t>
<t tx="ekr.20080401090200.14">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.15">@language python
@tabwidth -4
@others
# class install
</t>
<t tx="ekr.20080401090200.16">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.17">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.18">@language python
@tabwidth -4
@others
# class install_headers
</t>
<t tx="ekr.20080401090200.19">@language python
@tabwidth -4
@others
# class install_lib
</t>
<t tx="ekr.20080401090200.20">@language python
@tabwidth -4
@others
# class install_scripts
</t>
<t tx="ekr.20080401090200.21">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20080401090200.22">@language python
@tabwidth -4
@others
# class sdist</t>
<t tx="ekr.20080401090200.23">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.24">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.25"></t>
<t tx="ekr.20080401090200.26">@language python
@tabwidth -4
@others
# make_archive ()
</t>
<t tx="ekr.20080401090200.27">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.28">@language python
@tabwidth -4
@others
# gen_lib_options ()
@ignore</t>
<t tx="ekr.20080401090200.29">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    print "ok"
</t>
<t tx="ekr.20080401090200.30">@language python
@tabwidth -4
@others
# run_setup ()
</t>
<t tx="ekr.20080401090200.31">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.32">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.33">@language python
@tabwidth -4
@others
# newer_group ()
</t>
<t tx="ekr.20080401090200.34">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.35">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    dist = Distribution()
    print "ok"
</t>
<t tx="ekr.20080401090200.36">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.37">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.38">@language python
@tabwidth -4
@others
# read_setup_file ()
</t>
<t tx="ekr.20080401090200.39">@language python
@tabwidth -4
@others
# class OptionDummy


if __name__ == "__main__":
    text = """\
Tra-la-la, supercalifragilisticexpialidocious.
How *do* you spell that odd word, anyways?
(Someone ask Mary -- she'll know [or she'll
say, "How should I know?"].)"""

    for w in (10, 20, 30, 40):
        print "width: %d" % w
        print string.join(wrap_text(text, w), "\n")
        print
</t>
<t tx="ekr.20080401090200.40">@language python
@tabwidth -4
@others
# translate_pattern ()
</t>
<t tx="ekr.20080401090200.41">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.42">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.43">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20080401090200.44">@language python
@tabwidth -4
@others
@ignore # underindented python comment.</t>
<t tx="ekr.20080401090200.45">@language python
@tabwidth -4
@others
# find_executable()
</t>
<t tx="ekr.20080401090200.46">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.47">@language python
@tabwidth -4
@others
if __name__ == "__main__":
    test_data = """# test file

line 3 \\
# intervening comment
  continues on next line
"""
    # result 1: no fancy options
    result1 = map (lambda x: x + "\n", string.split (test_data, "\n")[0:-1])

    # result 2: just strip comments
    result2 = ["\n",
               "line 3 \\\n",
               "  continues on next line\n"]

    # result 3: just strip blank lines
    result3 = ["# test file\n",
               "line 3 \\\n",
               "# intervening comment\n",
               "  continues on next line\n"]

    # result 4: default, strip comments, blank lines, and trailing whitespace
    result4 = ["line 3 \\",
               "  continues on next line"]

    # result 5: strip comments and blanks, plus join lines (but don't
    # "collapse" joined lines
    result5 = ["line 3   continues on next line"]

    # result 6: strip comments and blanks, plus join lines (and
    # "collapse" joined lines
    result6 = ["line 3 continues on next line"]

    def test_input (count, description, file, expected_result):
        result = file.readlines ()
        # result = string.join (result, '')
        if result == expected_result:
            print "ok %d (%s)" % (count, description)
        else:
            print "not ok %d (%s):" % (count, description)
            print "** expected:"
            print expected_result
            print "** received:"
            print result


    filename = "test.txt"
    out_file = open (filename, "w")
    out_file.write (test_data)
    out_file.close ()

    in_file = TextFile (filename, strip_comments=0, skip_blanks=0,
                        lstrip_ws=0, rstrip_ws=0)
    test_input (1, "no processing", in_file, result1)

    in_file = TextFile (filename, strip_comments=1, skip_blanks=0,
                        lstrip_ws=0, rstrip_ws=0)
    test_input (2, "strip comments", in_file, result2)

    in_file = TextFile (filename, strip_comments=0, skip_blanks=1,
                        lstrip_ws=0, rstrip_ws=0)
    test_input (3, "strip blanks", in_file, result3)

    in_file = TextFile (filename)
    test_input (4, "default processing", in_file, result4)

    in_file = TextFile (filename, strip_comments=1, skip_blanks=1,
                        join_lines=1, rstrip_ws=1)
    test_input (5, "join lines without collapsing", in_file, result5)

    in_file = TextFile (filename, strip_comments=1, skip_blanks=1,
                        join_lines=1, rstrip_ws=1, collapse_join=1)
    test_input (6, "join lines with collapsing", in_file, result6)

    os.remove (filename)
</t>
<t tx="ekr.20080401090200.48">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.49">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.50">@language python
@tabwidth -4
@others
# end class LooseVersion
</t>
<t tx="ekr.20080401090200.51">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090200.52">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080401090512.1">"""distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: ccompiler.py 46331 2006-05-26 14:07:23Z bob.ippolito $"

import sys, os, re
from types import *
from copy import copy
from distutils.errors import *
from distutils.spawn import spawn
from distutils.file_util import move_file
from distutils.dir_util import mkpath
from distutils.dep_util import newer_pairwise, newer_group
from distutils.util import split_quoted, execute
from distutils import log

</t>
<t tx="ekr.20080401090512.2">class CCompiler:
    """Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    """

    # 'compiler_type' is a class attribute that identifies this class.  It
    # keeps code that wants to know what kind of compiler it's dealing with
    # from having to import all possible compiler classes just to do an
    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'
    # should really, really be one of the keys of the 'compiler_class'
    # dictionary (see below -- used by the 'new_compiler()' factory
    # function) -- authors of new compiler interface classes are
    # responsible for updating 'compiler_class'!
    compiler_type = None

    # XXX things not handled by this compiler abstraction model:
    #   * client can't provide additional options for a compiler,
    #     e.g. warning, optimization, debugging flags.  Perhaps this
    #     should be the domain of concrete compiler abstraction classes
    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base
    #     class should have methods for the common ones.
    #   * can't completely override the include or library searchg
    #     path, ie. no "cc -I -Idir1 -Idir2" or "cc -L -Ldir1 -Ldir2".
    #     I'm not sure how widely supported this is even by Unix
    #     compilers, much less on other platforms.  And I'm even less
    #     sure how useful it is; maybe for cross-compiling, but
    #     support for that is a ways off.  (And anyways, cross
    #     compilers probably have a dedicated binary with the
    #     right paths compiled in.  I hope.)
    #   * can't do really freaky things with the library list/library
    #     dirs, e.g. "-Ldir1 -lfoo -Ldir2 -lfoo" to link against
    #     different versions of libfoo.a in different locations.  I
    #     think this is useless without the ability to null out the
    #     library search path anyways.


    # Subclasses that rely on the standard filename generation methods
    # implemented below should override these; see the comment near
    # those methods ('object_filenames()' et. al.) for details:
    src_extensions = None               # list of strings
    obj_extension = None                # string
    static_lib_extension = None
    shared_lib_extension = None         # string
    static_lib_format = None            # format string
    shared_lib_format = None            # prob. same as static_lib_format
    exe_extension = None                # string

    # Default language settings. language_map is used to detect a source
    # file or Extension target language, checking source filenames.
    # language_order is used to detect the language precedence, when deciding
    # what language to use when mixing source types. For example, if some
    # extension has two files with ".c" extension, and one with ".cpp", it
    # is still linked as c++.
    language_map = {".c"   : "c",
                    ".cc"  : "c++",
                    ".cpp" : "c++",
                    ".cxx" : "c++",
                    ".m"   : "objc",
                   }
    language_order = ["c++", "objc", "c"]

    @others
</t>
<t tx="ekr.20080401090512.3">def __init__ (self,
              verbose=0,
              dry_run=0,
              force=0):

    self.dry_run = dry_run
    self.force = force
    self.verbose = verbose

    # 'output_dir': a common output directory for object, library,
    # shared object, and shared library files
    self.output_dir = None

    # 'macros': a list of macro definitions (or undefinitions).  A
    # macro definition is a 2-tuple (name, value), where the value is
    # either a string or None (no explicit value).  A macro
    # undefinition is a 1-tuple (name,).
    self.macros = []

    # 'include_dirs': a list of directories to search for include files
    self.include_dirs = []

    # 'libraries': a list of libraries to include in any link
    # (library names, not filenames: eg. "foo" not "libfoo.a")
    self.libraries = []

    # 'library_dirs': a list of directories to search for libraries
    self.library_dirs = []

    # 'runtime_library_dirs': a list of directories to search for
    # shared libraries/objects at runtime
    self.runtime_library_dirs = []

    # 'objects': a list of object files (or similar, such as explicitly
    # named library files) to include on any link
    self.objects = []

    for key in self.executables.keys():
        self.set_executable(key, self.executables[key])

</t>
<t tx="ekr.20080401090512.4"># __init__ ()


def set_executables (self, **args):

    """Define the executables (and options for them) that will be run
    to perform the various stages of compilation.  The exact set of
    executables that may be specified here depends on the compiler
    class (via the 'executables' class attribute), but most will have:
      compiler      the C/C++ compiler
      linker_so     linker used to create shared objects and libraries
      linker_exe    linker used to create binary executables
      archiver      static library creator

    On platforms with a command-line (Unix, DOS/Windows), each of these
    is a string that will be split into executable name and (optional)
    list of arguments.  (Splitting the string is done similarly to how
    Unix shells operate: words are delimited by spaces, but quotes and
    backslashes can override this.  See
    'distutils.util.split_quoted()'.)
    """

    # Note that some CCompiler implementation classes will define class
    # attributes 'cpp', 'cc', etc. with hard-coded executable names;
    # this is appropriate when a compiler class is for exactly one
    # compiler/OS combination (eg. MSVCCompiler).  Other compiler
    # classes (UnixCCompiler, in particular) are driven by information
    # discovered at run-time, since there are many different ways to do
    # basically the same things with Unix C compilers.

    for key in args.keys():
        if not self.executables.has_key(key):
            raise ValueError, \
                  "unknown executable '%s' for class %s" % \
                  (key, self.__class__.__name__)
        self.set_executable(key, args[key])

</t>
<t tx="ekr.20080401090512.5"># set_executables ()

def set_executable(self, key, value):
    if type(value) is StringType:
        setattr(self, key, split_quoted(value))
    else:
        setattr(self, key, value)


</t>
<t tx="ekr.20080401090512.6">def _find_macro (self, name):
    i = 0
    for defn in self.macros:
        if defn[0] == name:
            return i
        i = i + 1

    return None


</t>
<t tx="ekr.20080401090512.7">def _check_macro_definitions (self, definitions):
    """Ensures that every element of 'definitions' is a valid macro
    definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
    nothing if all definitions are OK, raise TypeError otherwise.
    """
    for defn in definitions:
        if not (type (defn) is TupleType and
                (len (defn) == 1 or
                 (len (defn) == 2 and
                  (type (defn[1]) is StringType or defn[1] is None))) and
                type (defn[0]) is StringType):
            raise TypeError, \
                  ("invalid macro definition '%s': " % defn) + \
                  "must be tuple (string,), (string, string), or " + \
                  "(string, None)"


</t>
<t tx="ekr.20080401090512.8"># -- Bookkeeping methods -------------------------------------------

def define_macro (self, name, value=None):
    """Define a preprocessor macro for all compilations driven by this
    compiler object.  The optional parameter 'value' should be a
    string; if it is not supplied, then the macro will be defined
    without an explicit value and the exact outcome depends on the
    compiler used (XXX true? does ANSI say anything about this?)
    """
    # Delete from the list of macro definitions/undefinitions if
    # already there (so that this one will take precedence).
    i = self._find_macro (name)
    if i is not None:
        del self.macros[i]

    defn = (name, value)
    self.macros.append (defn)


</t>
<t tx="ekr.20080401090512.9">def undefine_macro (self, name):
    """Undefine a preprocessor macro for all compilations driven by
    this compiler object.  If the same macro is defined by
    'define_macro()' and undefined by 'undefine_macro()' the last call
    takes precedence (including multiple redefinitions or
    undefinitions).  If the macro is redefined/undefined on a
    per-compilation basis (ie. in the call to 'compile()'), then that
    takes precedence.
    """
    # Delete from the list of macro definitions/undefinitions if
    # already there (so that this one will take precedence).
    i = self._find_macro (name)
    if i is not None:
        del self.macros[i]

    undefn = (name,)
    self.macros.append (undefn)


</t>
<t tx="ekr.20080401090512.10">def add_include_dir (self, dir):
    """Add 'dir' to the list of directories that will be searched for
    header files.  The compiler is instructed to search directories in
    the order in which they are supplied by successive calls to
    'add_include_dir()'.
    """
    self.include_dirs.append (dir)

</t>
<t tx="ekr.20080401090512.11">def set_include_dirs (self, dirs):
    """Set the list of directories that will be searched to 'dirs' (a
    list of strings).  Overrides any preceding calls to
    'add_include_dir()'; subsequence calls to 'add_include_dir()' add
    to the list passed to 'set_include_dirs()'.  This does not affect
    any list of standard include directories that the compiler may
    search by default.
    """
    self.include_dirs = copy (dirs)


</t>
<t tx="ekr.20080401090512.12">def add_library (self, libname):
    """Add 'libname' to the list of libraries that will be included in
    all links driven by this compiler object.  Note that 'libname'
    should *not* be the name of a file containing a library, but the
    name of the library itself: the actual filename will be inferred by
    the linker, the compiler, or the compiler class (depending on the
    platform).

    The linker will be instructed to link against libraries in the
    order they were supplied to 'add_library()' and/or
    'set_libraries()'.  It is perfectly valid to duplicate library
    names; the linker will be instructed to link against libraries as
    many times as they are mentioned.
    """
    self.libraries.append (libname)

</t>
<t tx="ekr.20080401090512.13">def set_libraries (self, libnames):
    """Set the list of libraries to be included in all links driven by
    this compiler object to 'libnames' (a list of strings).  This does
    not affect any standard system libraries that the linker may
    include by default.
    """
    self.libraries = copy (libnames)


</t>
<t tx="ekr.20080401090512.14">def add_library_dir (self, dir):
    """Add 'dir' to the list of directories that will be searched for
    libraries specified to 'add_library()' and 'set_libraries()'.  The
    linker will be instructed to search for libraries in the order they
    are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
    """
    self.library_dirs.append (dir)

</t>
<t tx="ekr.20080401090512.15">def set_library_dirs (self, dirs):
    """Set the list of library search directories to 'dirs' (a list of
    strings).  This does not affect any standard library search path
    that the linker may search by default.
    """
    self.library_dirs = copy (dirs)


</t>
<t tx="ekr.20080401090512.16">def add_runtime_library_dir (self, dir):
    """Add 'dir' to the list of directories that will be searched for
    shared libraries at runtime.
    """
    self.runtime_library_dirs.append (dir)

</t>
<t tx="ekr.20080401090512.17">def set_runtime_library_dirs (self, dirs):
    """Set the list of directories to search for shared libraries at
    runtime to 'dirs' (a list of strings).  This does not affect any
    standard search path that the runtime linker may search by
    default.
    """
    self.runtime_library_dirs = copy (dirs)


</t>
<t tx="ekr.20080401090512.18">def add_link_object (self, object):
    """Add 'object' to the list of object files (or analogues, such as
    explicitly named library files or the output of "resource
    compilers") to be included in every link driven by this compiler
    object.
    """
    self.objects.append (object)

</t>
<t tx="ekr.20080401090512.19">def set_link_objects (self, objects):
    """Set the list of object files (or analogues) to be included in
    every link to 'objects'.  This does not affect any standard object
    files that the linker may include by default (such as system
    libraries).
    """
    self.objects = copy (objects)


</t>
<t tx="ekr.20080401090512.20"># -- Private utility methods --------------------------------------
# (here for the convenience of subclasses)

# Helper method to prep compiler in subclass compile() methods

def _setup_compile(self, outdir, macros, incdirs, sources, depends,
                   extra):
    """Process arguments and decide which source files to compile.

    Merges _fix_compile_args() and _prep_compile().
    """
    if outdir is None:
        outdir = self.output_dir
    elif type(outdir) is not StringType:
        raise TypeError, "'output_dir' must be a string or None"

    if macros is None:
        macros = self.macros
    elif type(macros) is ListType:
        macros = macros + (self.macros or [])
    else:
        raise TypeError, "'macros' (if supplied) must be a list of tuples"

    if incdirs is None:
        incdirs = self.include_dirs
    elif type(incdirs) in (ListType, TupleType):
        incdirs = list(incdirs) + (self.include_dirs or [])
    else:
        raise TypeError, \
              "'include_dirs' (if supplied) must be a list of strings"

    if extra is None:
        extra = []

    # Get the list of expected output (object) files
    objects = self.object_filenames(sources,
                                    strip_dir=0,
                                    output_dir=outdir)
    assert len(objects) == len(sources)

    # XXX should redo this code to eliminate skip_source entirely.
    # XXX instead create build and issue skip messages inline

    if self.force:
        skip_source = {}            # rebuild everything
        for source in sources:
            skip_source[source] = 0
    elif depends is None:
        # If depends is None, figure out which source files we
        # have to recompile according to a simplistic check. We
        # just compare the source and object file, no deep
        # dependency checking involving header files.
        skip_source = {}            # rebuild everything
        for source in sources:      # no wait, rebuild nothing
            skip_source[source] = 1

        n_sources, n_objects = newer_pairwise(sources, objects)
        for source in n_sources:    # no really, only rebuild what's
            skip_source[source] = 0 # out-of-date
    else:
        # If depends is a list of files, then do a different
        # simplistic check.  Assume that each object depends on
        # its source and all files in the depends list.
        skip_source = {}
        # L contains all the depends plus a spot at the end for a
        # particular source file
        L = depends[:] + [None]
        for i in range(len(objects)):
            source = sources[i]
            L[-1] = source
            if newer_group(L, objects[i]):
                skip_source[source] = 0
            else:
                skip_source[source] = 1

    pp_opts = gen_preprocess_options(macros, incdirs)

    build = {}
    for i in range(len(sources)):
        src = sources[i]
        obj = objects[i]
        ext = os.path.splitext(src)[1]
        self.mkpath(os.path.dirname(obj))
        if skip_source[src]:
            log.debug("skipping %s (%s up-to-date)", src, obj)
        else:
            build[obj] = src, ext

    return macros, objects, extra, pp_opts, build

</t>
<t tx="ekr.20080401090512.21">def _get_cc_args(self, pp_opts, debug, before):
    # works for unixccompiler, emxccompiler, cygwinccompiler
    cc_args = pp_opts + ['-c']
    if debug:
        cc_args[:0] = ['-g']
    if before:
        cc_args[:0] = before
    return cc_args

</t>
<t tx="ekr.20080401090512.22">def _fix_compile_args (self, output_dir, macros, include_dirs):
    """Typecheck and fix-up some of the arguments to the 'compile()'
    method, and return fixed-up values.  Specifically: if 'output_dir'
    is None, replaces it with 'self.output_dir'; ensures that 'macros'
    is a list, and augments it with 'self.macros'; ensures that
    'include_dirs' is a list, and augments it with 'self.include_dirs'.
    Guarantees that the returned values are of the correct type,
    i.e. for 'output_dir' either string or None, and for 'macros' and
    'include_dirs' either list or None.
    """
    if output_dir is None:
        output_dir = self.output_dir
    elif type (output_dir) is not StringType:
        raise TypeError, "'output_dir' must be a string or None"

    if macros is None:
        macros = self.macros
    elif type (macros) is ListType:
        macros = macros + (self.macros or [])
    else:
        raise TypeError, "'macros' (if supplied) must be a list of tuples"

    if include_dirs is None:
        include_dirs = self.include_dirs
    elif type (include_dirs) in (ListType, TupleType):
        include_dirs = list (include_dirs) + (self.include_dirs or [])
    else:
        raise TypeError, \
              "'include_dirs' (if supplied) must be a list of strings"

    return output_dir, macros, include_dirs

</t>
<t tx="ekr.20080401090512.23"># _fix_compile_args ()


def _prep_compile(self, sources, output_dir, depends=None):
    """Decide which souce files must be recompiled.

    Determine the list of object files corresponding to 'sources',
    and figure out which ones really need to be recompiled.
    Return a list of all object files and a dictionary telling
    which source files can be skipped.
    """
    # Get the list of expected output (object) files
    objects = self.object_filenames(sources, output_dir=output_dir)
    assert len(objects) == len(sources)

    if self.force:
        skip_source = {}            # rebuild everything
        for source in sources:
            skip_source[source] = 0
    elif depends is None:
        # If depends is None, figure out which source files we
        # have to recompile according to a simplistic check. We
        # just compare the source and object file, no deep
        # dependency checking involving header files.
        skip_source = {}            # rebuild everything
        for source in sources:      # no wait, rebuild nothing
            skip_source[source] = 1

        n_sources, n_objects = newer_pairwise(sources, objects)
        for source in n_sources:    # no really, only rebuild what's
            skip_source[source] = 0 # out-of-date
    else:
        # If depends is a list of files, then do a different
        # simplistic check.  Assume that each object depends on
        # its source and all files in the depends list.
        skip_source = {}
        # L contains all the depends plus a spot at the end for a
        # particular source file
        L = depends[:] + [None]
        for i in range(len(objects)):
            source = sources[i]
            L[-1] = source
            if newer_group(L, objects[i]):
                skip_source[source] = 0
            else:
                skip_source[source] = 1

    return objects, skip_source

</t>
<t tx="ekr.20080401090512.24"># _prep_compile ()


def _fix_object_args (self, objects, output_dir):
    """Typecheck and fix up some arguments supplied to various methods.
    Specifically: ensure that 'objects' is a list; if output_dir is
    None, replace with self.output_dir.  Return fixed versions of
    'objects' and 'output_dir'.
    """
    if type (objects) not in (ListType, TupleType):
        raise TypeError, \
              "'objects' must be a list or tuple of strings"
    objects = list (objects)

    if output_dir is None:
        output_dir = self.output_dir
    elif type (output_dir) is not StringType:
        raise TypeError, "'output_dir' must be a string or None"

    return (objects, output_dir)


</t>
<t tx="ekr.20080401090512.25">def _fix_lib_args (self, libraries, library_dirs, runtime_library_dirs):
    """Typecheck and fix up some of the arguments supplied to the
    'link_*' methods.  Specifically: ensure that all arguments are
    lists, and augment them with their permanent versions
    (eg. 'self.libraries' augments 'libraries').  Return a tuple with
    fixed versions of all arguments.
    """
    if libraries is None:
        libraries = self.libraries
    elif type (libraries) in (ListType, TupleType):
        libraries = list (libraries) + (self.libraries or [])
    else:
        raise TypeError, \
              "'libraries' (if supplied) must be a list of strings"

    if library_dirs is None:
        library_dirs = self.library_dirs
    elif type (library_dirs) in (ListType, TupleType):
        library_dirs = list (library_dirs) + (self.library_dirs or [])
    else:
        raise TypeError, \
              "'library_dirs' (if supplied) must be a list of strings"

    if runtime_library_dirs is None:
        runtime_library_dirs = self.runtime_library_dirs
    elif type (runtime_library_dirs) in (ListType, TupleType):
        runtime_library_dirs = (list (runtime_library_dirs) +
                                (self.runtime_library_dirs or []))
    else:
        raise TypeError, \
              "'runtime_library_dirs' (if supplied) " + \
              "must be a list of strings"

    return (libraries, library_dirs, runtime_library_dirs)

</t>
<t tx="ekr.20080401090512.26"># _fix_lib_args ()


def _need_link (self, objects, output_file):
    """Return true if we need to relink the files listed in 'objects'
    to recreate 'output_file'.
    """
    if self.force:
        return 1
    else:
        if self.dry_run:
            newer = newer_group (objects, output_file, missing='newer')
        else:
            newer = newer_group (objects, output_file)
        return newer

</t>
<t tx="ekr.20080401090512.27"># _need_link ()

def detect_language (self, sources):
    """Detect the language of a given file, or list of files. Uses
    language_map, and language_order to do the job.
    """
    if type(sources) is not ListType:
        sources = [sources]
    lang = None
    index = len(self.language_order)
    for source in sources:
        base, ext = os.path.splitext(source)
        extlang = self.language_map.get(ext)
        try:
            extindex = self.language_order.index(extlang)
            if extindex &lt; index:
                lang = extlang
                index = extindex
        except ValueError:
            pass
    return lang

</t>
<t tx="ekr.20080401090512.28"># detect_language ()

# -- Worker methods ------------------------------------------------
# (must be implemented by subclasses)

def preprocess (self,
                source,
                output_file=None,
                macros=None,
                include_dirs=None,
                extra_preargs=None,
                extra_postargs=None):
    """Preprocess a single C/C++ source file, named in 'source'.
    Output will be written to file named 'output_file', or stdout if
    'output_file' not supplied.  'macros' is a list of macro
    definitions as for 'compile()', which will augment the macros set
    with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
    list of directory names that will be added to the default list.

    Raises PreprocessError on failure.
    """
    pass

</t>
<t tx="ekr.20080401090512.29">def compile(self, sources, output_dir=None, macros=None,
            include_dirs=None, debug=0, extra_preargs=None,
            extra_postargs=None, depends=None):
    """Compile one or more source files.

    'sources' must be a list of filenames, most likely C/C++
    files, but in reality anything that can be handled by a
    particular compiler and compiler class (eg. MSVCCompiler can
    handle resource files in 'sources').  Return a list of object
    filenames, one per source filename in 'sources'.  Depending on
    the implementation, not all source files will necessarily be
    compiled, but all corresponding object filenames will be
    returned.

    If 'output_dir' is given, object files will be put under it, while
    retaining their original path component.  That is, "foo/bar.c"
    normally compiles to "foo/bar.o" (for a Unix implementation); if
    'output_dir' is "build", then it would compile to
    "build/foo/bar.o".

    'macros', if given, must be a list of macro definitions.  A macro
    definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
    The former defines a macro; if the value is None, the macro is
    defined without an explicit value.  The 1-tuple case undefines a
    macro.  Later definitions/redefinitions/ undefinitions take
    precedence.

    'include_dirs', if given, must be a list of strings, the
    directories to add to the default include file search path for this
    compilation only.

    'debug' is a boolean; if true, the compiler will be instructed to
    output debug symbols in (or alongside) the object file(s).

    'extra_preargs' and 'extra_postargs' are implementation- dependent.
    On platforms that have the notion of a command-line (e.g. Unix,
    DOS/Windows), they are most likely lists of strings: extra
    command-line arguments to prepand/append to the compiler command
    line.  On other platforms, consult the implementation class
    documentation.  In any event, they are intended as an escape hatch
    for those occasions when the abstract compiler framework doesn't
    cut the mustard.

    'depends', if given, is a list of filenames that all targets
    depend on.  If a source file is older than any file in
    depends, then the source file will be recompiled.  This
    supports dependency tracking, but only at a coarse
    granularity.

    Raises CompileError on failure.
    """

    # A concrete compiler class can either override this method
    # entirely or implement _compile().

    macros, objects, extra_postargs, pp_opts, build = \
            self._setup_compile(output_dir, macros, include_dirs, sources,
                                depends, extra_postargs)
    cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)

    for obj in objects:
        try:
            src, ext = build[obj]
        except KeyError:
            continue
        self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

    # Return *all* object filenames, not just the ones we just built.
    return objects

</t>
<t tx="ekr.20080401090512.30">def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
    """Compile 'src' to product 'obj'."""

    # A concrete compiler class that does not override compile()
    # should implement _compile().
    pass

</t>
<t tx="ekr.20080401090512.31">def create_static_lib (self,
                       objects,
                       output_libname,
                       output_dir=None,
                       debug=0,
                       target_lang=None):
    """Link a bunch of stuff together to create a static library file.
    The "bunch of stuff" consists of the list of object files supplied
    as 'objects', the extra object files supplied to
    'add_link_object()' and/or 'set_link_objects()', the libraries
    supplied to 'add_library()' and/or 'set_libraries()', and the
    libraries supplied as 'libraries' (if any).

    'output_libname' should be a library name, not a filename; the
    filename will be inferred from the library name.  'output_dir' is
    the directory where the library file will be put.

    'debug' is a boolean; if true, debugging information will be
    included in the library (note that on most platforms, it is the
    compile step where this matters: the 'debug' flag is included here
    just for consistency).

    'target_lang' is the target language for which the given objects
    are being compiled. This allows specific linkage time treatment of
    certain languages.

    Raises LibError on failure.
    """
    pass


</t>
<t tx="ekr.20080401090512.32"># values for target_desc parameter in link()
SHARED_OBJECT = "shared_object"
SHARED_LIBRARY = "shared_library"
EXECUTABLE = "executable"

def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):
    """Link a bunch of stuff together to create an executable or
    shared library file.

    The "bunch of stuff" consists of the list of object files supplied
    as 'objects'.  'output_filename' should be a filename.  If
    'output_dir' is supplied, 'output_filename' is relative to it
    (i.e. 'output_filename' can provide directory components if
    needed).

    'libraries' is a list of libraries to link against.  These are
    library names, not filenames, since they're translated into
    filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
    on Unix and "foo.lib" on DOS/Windows).  However, they can include a
    directory component, which means the linker will look in that
    specific directory rather than searching all the normal locations.

    'library_dirs', if supplied, should be a list of directories to
    search for libraries that were specified as bare library names
    (ie. no directory component).  These are on top of the system
    default and those supplied to 'add_library_dir()' and/or
    'set_library_dirs()'.  'runtime_library_dirs' is a list of
    directories that will be embedded into the shared library and used
    to search for other shared libraries that *it* depends on at
    run-time.  (This may only be relevant on Unix.)

    'export_symbols' is a list of symbols that the shared library will
    export.  (This appears to be relevant only on Windows.)

    'debug' is as for 'compile()' and 'create_static_lib()', with the
    slight distinction that it actually matters on most platforms (as
    opposed to 'create_static_lib()', which includes a 'debug' flag
    mostly for form's sake).

    'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
    of course that they supply command-line arguments for the
    particular linker being used).

    'target_lang' is the target language for which the given objects
    are being compiled. This allows specific linkage time treatment of
    certain languages.

    Raises LinkError on failure.
    """
    raise NotImplementedError


</t>
<t tx="ekr.20080401090512.33"># Old 'link_*()' methods, rewritten to use the new 'link()' method.

def link_shared_lib (self,
                     objects,
                     output_libname,
                     output_dir=None,
                     libraries=None,
                     library_dirs=None,
                     runtime_library_dirs=None,
                     export_symbols=None,
                     debug=0,
                     extra_preargs=None,
                     extra_postargs=None,
                     build_temp=None,
                     target_lang=None):
    self.link(CCompiler.SHARED_LIBRARY, objects,
              self.library_filename(output_libname, lib_type='shared'),
              output_dir,
              libraries, library_dirs, runtime_library_dirs,
              export_symbols, debug,
              extra_preargs, extra_postargs, build_temp, target_lang)


</t>
<t tx="ekr.20080401090512.34">def link_shared_object (self,
                        objects,
                        output_filename,
                        output_dir=None,
                        libraries=None,
                        library_dirs=None,
                        runtime_library_dirs=None,
                        export_symbols=None,
                        debug=0,
                        extra_preargs=None,
                        extra_postargs=None,
                        build_temp=None,
                        target_lang=None):
    self.link(CCompiler.SHARED_OBJECT, objects,
              output_filename, output_dir,
              libraries, library_dirs, runtime_library_dirs,
              export_symbols, debug,
              extra_preargs, extra_postargs, build_temp, target_lang)


</t>
<t tx="ekr.20080401090512.35">def link_executable (self,
                     objects,
                     output_progname,
                     output_dir=None,
                     libraries=None,
                     library_dirs=None,
                     runtime_library_dirs=None,
                     debug=0,
                     extra_preargs=None,
                     extra_postargs=None,
                     target_lang=None):
    self.link(CCompiler.EXECUTABLE, objects,
              self.executable_filename(output_progname), output_dir,
              libraries, library_dirs, runtime_library_dirs, None,
              debug, extra_preargs, extra_postargs, None, target_lang)


</t>
<t tx="ekr.20080401090512.36"># -- Miscellaneous methods -----------------------------------------
# These are all used by the 'gen_lib_options() function; there is
# no appropriate default implementation so subclasses should
# implement all of these.

def library_dir_option (self, dir):
    """Return the compiler option to add 'dir' to the list of
    directories searched for libraries.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20080401090512.37">def runtime_library_dir_option (self, dir):
    """Return the compiler option to add 'dir' to the list of
    directories searched for runtime libraries.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20080401090512.38">def library_option (self, lib):
    """Return the compiler option to add 'dir' to the list of libraries
    linked into the shared library or executable.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20080401090512.39">def has_function(self, funcname,
                 includes=None,
                 include_dirs=None,
                 libraries=None,
                 library_dirs=None):
    """Return a boolean indicating whether funcname is supported on
    the current platform.  The optional arguments can be used to
    augment the compilation environment.
    """

    # this can't be included at module scope because it tries to
    # import math which might not be available at that point - maybe
    # the necessary logic should just be inlined?
    import tempfile
    if includes is None:
        includes = []
    if include_dirs is None:
        include_dirs = []
    if libraries is None:
        libraries = []
    if library_dirs is None:
        library_dirs = []
    fd, fname = tempfile.mkstemp(".c", funcname, text=True)
    f = os.fdopen(fd, "w")
    for incl in includes:
        f.write("""#include "%s"\n""" % incl)
    f.write("""\
main (int argc, char **argv) {
%s();
}
""" % funcname)
    f.close()
    try:
        objects = self.compile([fname], include_dirs=include_dirs)
    except CompileError:
        return False

    try:
        self.link_executable(objects, "a.out",
                             libraries=libraries,
                             library_dirs=library_dirs)
    except (LinkError, TypeError):
        return False
    return True

</t>
<t tx="ekr.20080401090512.40">def find_library_file (self, dirs, lib, debug=0):
    """Search the specified list of directories for a static or shared
    library file 'lib' and return the full path to that file.  If
    'debug' true, look for a debugging version (if that makes sense on
    the current platform).  Return None if 'lib' wasn't found in any of
    the specified directories.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20080401090512.41"># -- Filename generation methods -----------------------------------

# The default implementation of the filename generating methods are
# prejudiced towards the Unix/DOS/Windows view of the world:
#   * object files are named by replacing the source file extension
#     (eg. .c/.cpp -&gt; .o/.obj)
#   * library files (shared or static) are named by plugging the
#     library name and extension into a format string, eg.
#     "lib%s.%s" % (lib_name, ".a") for Unix static libraries
#   * executables are named by appending an extension (possibly
#     empty) to the program name: eg. progname + ".exe" for
#     Windows
#
# To reduce redundant code, these methods expect to find
# several attributes in the current object (presumably defined
# as class attributes):
#   * src_extensions -
#     list of C/C++ source file extensions, eg. ['.c', '.cpp']
#   * obj_extension -
#     object file extension, eg. '.o' or '.obj'
#   * static_lib_extension -
#     extension for static library files, eg. '.a' or '.lib'
#   * shared_lib_extension -
#     extension for shared library/object files, eg. '.so', '.dll'
#   * static_lib_format -
#     format string for generating static library filenames,
#     eg. 'lib%s.%s' or '%s.%s'
#   * shared_lib_format
#     format string for generating shared library filenames
#     (probably same as static_lib_format, since the extension
#     is one of the intended parameters to the format string)
#   * exe_extension -
#     extension for executable files, eg. '' or '.exe'

def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
    if output_dir is None:
        output_dir = ''
    obj_names = []
    for src_name in source_filenames:
        base, ext = os.path.splitext(src_name)
        base = os.path.splitdrive(base)[1] # Chop off the drive
        base = base[os.path.isabs(base):]  # If abs, chop off leading /
        if ext not in self.src_extensions:
            raise UnknownFileError, \
                  "unknown file type '%s' (from '%s')" % (ext, src_name)
        if strip_dir:
            base = os.path.basename(base)
        obj_names.append(os.path.join(output_dir,
                                      base + self.obj_extension))
    return obj_names

</t>
<t tx="ekr.20080401090512.42">def shared_object_filename(self, basename, strip_dir=0, output_dir=''):
    assert output_dir is not None
    if strip_dir:
        basename = os.path.basename (basename)
    return os.path.join(output_dir, basename + self.shared_lib_extension)

</t>
<t tx="ekr.20080401090512.43">def executable_filename(self, basename, strip_dir=0, output_dir=''):
    assert output_dir is not None
    if strip_dir:
        basename = os.path.basename (basename)
    return os.path.join(output_dir, basename + (self.exe_extension or ''))

</t>
<t tx="ekr.20080401090512.44">def library_filename(self, libname, lib_type='static',     # or 'shared'
                     strip_dir=0, output_dir=''):
    assert output_dir is not None
    if lib_type not in ("static", "shared", "dylib"):
        raise ValueError, "'lib_type' must be \"static\", \"shared\" or \"dylib\""
    fmt = getattr(self, lib_type + "_lib_format")
    ext = getattr(self, lib_type + "_lib_extension")

    dir, base = os.path.split (libname)
    filename = fmt % (base, ext)
    if strip_dir:
        dir = ''

    return os.path.join(output_dir, dir, filename)


</t>
<t tx="ekr.20080401090512.45"># -- Utility methods -----------------------------------------------

def announce (self, msg, level=1):
    log.debug(msg)

</t>
<t tx="ekr.20080401090512.46">def debug_print (self, msg):
    from distutils.debug import DEBUG
    if DEBUG:
        print msg

</t>
<t tx="ekr.20080401090512.47">def warn (self, msg):
    sys.stderr.write ("warning: %s\n" % msg)

</t>
<t tx="ekr.20080401090512.48">def execute (self, func, args, msg=None, level=1):
    execute(func, args, msg, self.dry_run)

</t>
<t tx="ekr.20080401090512.49">def spawn (self, cmd):
    spawn (cmd, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090512.50">def move_file (self, src, dst):
    return move_file (src, dst, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090512.51">def mkpath (self, name, mode=0777):
    mkpath (name, mode, self.dry_run)


</t>
<t tx="ekr.20080401090512.52"># class CCompiler


# Map a sys.platform/os.name ('posix', 'nt') to the default compiler
# type for that platform. Keys are interpreted as re match
# patterns. Order is important; platform mappings are preferred over
# OS names.
_default_compilers = (

    # Platform string mappings

    # on a cygwin built python we can use gcc like an ordinary UNIXish
    # compiler
    ('cygwin.*', 'unix'),
    ('os2emx', 'emx'),

    # OS name mappings
    ('posix', 'unix'),
    ('nt', 'msvc'),
    ('mac', 'mwerks'),

    )

def get_default_compiler(osname=None, platform=None):

    """ Determine the default compiler to use for the given platform.

        osname should be one of the standard Python OS names (i.e. the
        ones returned by os.name) and platform the common value
        returned by sys.platform for the platform in question.

        The default values are os.name and sys.platform in case the
        parameters are not given.

    """
    if osname is None:
        osname = os.name
    if platform is None:
        platform = sys.platform
    for pattern, compiler in _default_compilers:
        if re.match(pattern, platform) is not None or \
           re.match(pattern, osname) is not None:
            return compiler
    # Default to Unix compiler
    return 'unix'

</t>
<t tx="ekr.20080401090512.53"># Map compiler types to (module_name, class_name) pairs -- ie. where to
# find the code that implements an interface to this compiler.  (The module
# is assumed to be in the 'distutils' package.)
compiler_class = { 'unix':    ('unixccompiler', 'UnixCCompiler',
                               "standard UNIX-style compiler"),
                   'msvc':    ('msvccompiler', 'MSVCCompiler',
                               "Microsoft Visual C++"),
                   'cygwin':  ('cygwinccompiler', 'CygwinCCompiler',
                               "Cygwin port of GNU C Compiler for Win32"),
                   'mingw32': ('cygwinccompiler', 'Mingw32CCompiler',
                               "Mingw32 port of GNU C Compiler for Win32"),
                   'bcpp':    ('bcppcompiler', 'BCPPCompiler',
                               "Borland C++ Compiler"),
                   'mwerks':  ('mwerkscompiler', 'MWerksCompiler',
                               "MetroWerks CodeWarrior"),
                   'emx':     ('emxccompiler', 'EMXCCompiler',
                               "EMX port of GNU C Compiler for OS/2"),
                 }

def show_compilers():
    """Print list of available compilers (used by the "--help-compiler"
    options to "build", "build_ext", "build_clib").
    """
    # XXX this "knows" that the compiler option it's describing is
    # "--compiler", which just happens to be the case for the three
    # commands that use it.
    from distutils.fancy_getopt import FancyGetopt
    compilers = []
    for compiler in compiler_class.keys():
        compilers.append(("compiler="+compiler, None,
                          compiler_class[compiler][2]))
    compilers.sort()
    pretty_printer = FancyGetopt(compilers)
    pretty_printer.print_help("List of available compilers:")


</t>
<t tx="ekr.20080401090512.54">def new_compiler (plat=None,
                  compiler=None,
                  verbose=0,
                  dry_run=0,
                  force=0):
    """Generate an instance of some CCompiler subclass for the supplied
    platform/compiler combination.  'plat' defaults to 'os.name'
    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
    for that platform.  Currently only 'posix' and 'nt' are supported, and
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to ask for a Unix compiler object under Windows, and a
    Microsoft compiler object under Unix -- if you supply a value for
    'compiler', 'plat' is ignored.
    """
    if plat is None:
        plat = os.name

    try:
        if compiler is None:
            compiler = get_default_compiler(plat)

        (module_name, class_name, long_description) = compiler_class[compiler]
    except KeyError:
        msg = "don't know how to compile C/C++ code on platform '%s'" % plat
        if compiler is not None:
            msg = msg + " with '%s' compiler" % compiler
        raise DistutilsPlatformError, msg

    try:
        module_name = "distutils." + module_name
        __import__ (module_name)
        module = sys.modules[module_name]
        klass = vars(module)[class_name]
    except ImportError:
        raise DistutilsModuleError, \
              "can't compile C/C++ code: unable to load module '%s'" % \
              module_name
    except KeyError:
        raise DistutilsModuleError, \
              ("can't compile C/C++ code: unable to find class '%s' " +
               "in module '%s'") % (class_name, module_name)

    # XXX The None is necessary to preserve backwards compatibility
    # with classes that expect verbose to be the first positional
    # argument.
    return klass (None, dry_run, force)


</t>
<t tx="ekr.20080401090512.55">def gen_preprocess_options (macros, include_dirs):
    """Generate C pre-processor options (-D, -U, -I) as used by at least
    two types of compilers: the typical Unix compiler and Visual C++.
    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
    means undefine (-U) macro 'name', and (name,value) means define (-D)
    macro 'name' to 'value'.  'include_dirs' is just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line options suitable for either Unix compilers or Visual
    C++.
    """
    # XXX it would be nice (mainly aesthetic, and so we don't generate
    # stupid-looking command lines) to go over 'macros' and eliminate
    # redundant definitions/undefinitions (ie. ensure that only the
    # latest mention of a particular macro winds up on the command
    # line).  I don't think it's essential, though, since most (all?)
    # Unix C compilers only pay attention to the latest -D or -U
    # mention of a macro on their command line.  Similar situation for
    # 'include_dirs'.  I'm punting on both for now.  Anyways, weeding out
    # redundancies like this should probably be the province of
    # CCompiler, since the data structures used are inherited from it
    # and therefore common to all CCompiler classes.

    pp_opts = []
    for macro in macros:

        if not (type (macro) is TupleType and
                1 &lt;= len (macro) &lt;= 2):
            raise TypeError, \
                  ("bad macro definition '%s': " +
                   "each element of 'macros' list must be a 1- or 2-tuple") % \
                  macro

        if len (macro) == 1:        # undefine this macro
            pp_opts.append ("-U%s" % macro[0])
        elif len (macro) == 2:
            if macro[1] is None:    # define with no explicit value
                pp_opts.append ("-D%s" % macro[0])
            else:
                # XXX *don't* need to be clever about quoting the
                # macro value here, because we're going to avoid the
                # shell at all costs when we spawn the command!
                pp_opts.append ("-D%s=%s" % macro)

    for dir in include_dirs:
        pp_opts.append ("-I%s" % dir)

    return pp_opts

</t>
<t tx="ekr.20080401090512.56"># gen_preprocess_options ()


def gen_lib_options (compiler, library_dirs, runtime_library_dirs, libraries):
    """Generate linker options for searching library directories and
    linking with specific libraries.  'libraries' and 'library_dirs' are,
    respectively, lists of library names (not filenames!) and search
    directories.  Returns a list of command-line options suitable for use
    with some compiler (depending on the two format strings passed in).
    """
    lib_opts = []

    for dir in library_dirs:
        lib_opts.append (compiler.library_dir_option (dir))

    for dir in runtime_library_dirs:
        opt = compiler.runtime_library_dir_option (dir)
        if type(opt) is ListType:
            lib_opts = lib_opts + opt
        else:
            lib_opts.append (opt)

    # XXX it's important that we *not* remove redundant library mentions!
    # sometimes you really do have to say "-lfoo -lbar -lfoo" in order to
    # resolve all symbols.  I just hope we never have to say "-lfoo obj.o
    # -lbar" to get things to work -- that's certainly a possibility, but a
    # pretty nasty way to arrange your C code.

    for lib in libraries:
        (lib_dir, lib_name) = os.path.split (lib)
        if lib_dir:
            lib_file = compiler.find_library_file ([lib_dir], lib_name)
            if lib_file:
                lib_opts.append (lib_file)
            else:
                compiler.warn ("no library file corresponding to "
                               "'%s' found (skipping)" % lib)
        else:
            lib_opts.append (compiler.library_option (lib))

    return lib_opts

</t>
<t tx="ekr.20080401090512.57">"""distutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
"""

# Written by Perry Stoll
# hacked by Robin Becker and Thomas Heller to do a better job of
#   finding DevStudio (through the registry)

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: msvccompiler.py 50979 2006-07-30 13:27:31Z martin.v.loewis $"

import sys, os, string
from distutils.errors import \
     DistutilsExecError, DistutilsPlatformError, \
     CompileError, LibError, LinkError
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
from distutils import log

_can_read_reg = 0
try:
    import _winreg

    _can_read_reg = 1
    hkey_mod = _winreg

    RegOpenKeyEx = _winreg.OpenKeyEx
    RegEnumKey = _winreg.EnumKey
    RegEnumValue = _winreg.EnumValue
    RegError = _winreg.error

except ImportError:
    try:
        import win32api
        import win32con
        _can_read_reg = 1
        hkey_mod = win32con

        RegOpenKeyEx = win32api.RegOpenKeyEx
        RegEnumKey = win32api.RegEnumKey
        RegEnumValue = win32api.RegEnumValue
        RegError = win32api.error

    except ImportError:
        log.info("Warning: Can't read registry to find the "
                 "necessary compiler setting\n"
                 "Make sure that Python modules _winreg, "
                 "win32api or win32con are installed.")
        pass

if _can_read_reg:
    HKEYS = (hkey_mod.HKEY_USERS,
             hkey_mod.HKEY_CURRENT_USER,
             hkey_mod.HKEY_LOCAL_MACHINE,
             hkey_mod.HKEY_CLASSES_ROOT)

</t>
<t tx="ekr.20080401090512.58">def read_keys(base, key):
    """Return list of registry keys."""

    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    L = []
    i = 0
    while 1:
        try:
            k = RegEnumKey(handle, i)
        except RegError:
            break
        L.append(k)
        i = i + 1
    return L

</t>
<t tx="ekr.20080401090512.59">def read_values(base, key):
    """Return dict of registry keys and values.

    All names are converted to lowercase.
    """
    try:
        handle = RegOpenKeyEx(base, key)
    except RegError:
        return None
    d = {}
    i = 0
    while 1:
        try:
            name, value, type = RegEnumValue(handle, i)
        except RegError:
            break
        name = name.lower()
        d[convert_mbcs(name)] = convert_mbcs(value)
        i = i + 1
    return d

</t>
<t tx="ekr.20080401090512.60">def convert_mbcs(s):
    enc = getattr(s, "encode", None)
    if enc is not None:
        try:
            s = enc("mbcs")
        except UnicodeError:
            pass
    return s

</t>
<t tx="ekr.20080401090512.61">class MacroExpander:
    @others
</t>
<t tx="ekr.20080401090512.62">
def __init__(self, version):
    self.macros = {}
    self.load_macros(version)

</t>
<t tx="ekr.20080401090512.63">def set_macro(self, macro, path, key):
    for base in HKEYS:
        d = read_values(base, path)
        if d:
            self.macros["$(%s)" % macro] = d[key]
            break

</t>
<t tx="ekr.20080401090512.64">def load_macros(self, version):
    vsbase = r"Software\Microsoft\VisualStudio\%0.1f" % version
    self.set_macro("VCInstallDir", vsbase + r"\Setup\VC", "productdir")
    self.set_macro("VSInstallDir", vsbase + r"\Setup\VS", "productdir")
    net = r"Software\Microsoft\.NETFramework"
    self.set_macro("FrameworkDir", net, "installroot")
    try:
        if version &gt; 7.0:
            self.set_macro("FrameworkSDKDir", net, "sdkinstallrootv1.1")
        else:
            self.set_macro("FrameworkSDKDir", net, "sdkinstallroot")
    except KeyError, exc: #
        raise DistutilsPlatformError, \
              ("""Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.""")

    p = r"Software\Microsoft\NET Framework Setup\Product"
    for base in HKEYS:
        try:
            h = RegOpenKeyEx(base, p)
        except RegError:
            continue
        key = RegEnumKey(h, 0)
        d = read_values(base, r"%s\%s" % (p, key))
        self.macros["$(FrameworkVersion)"] = d["version"]

</t>
<t tx="ekr.20080401090512.65">def sub(self, s):
    for k, v in self.macros.items():
        s = string.replace(s, k, v)
    return s

</t>
<t tx="ekr.20080401090512.66">def get_build_version():
    """Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    """

    prefix = "MSC v."
    i = string.find(sys.version, prefix)
    if i == -1:
        return 6
    i = i + len(prefix)
    s, rest = sys.version[i:].split(" ", 1)
    majorVersion = int(s[:-2]) - 6
    minorVersion = int(s[2:3]) / 10.0
    # I don't think paths are affected by minor version in version 6
    if majorVersion == 6:
        minorVersion = 0
    if majorVersion &gt;= 6:
        return majorVersion + minorVersion
    # else we don't know what version of the compiler this is
    return None

</t>
<t tx="ekr.20080401090512.67">def get_build_architecture():
    """Return the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    """

    prefix = " bit ("
    i = string.find(sys.version, prefix)
    if i == -1:
        return "Intel"
    j = string.find(sys.version, ")", i)
    return sys.version[i+len(prefix):j]



</t>
<t tx="ekr.20080401090512.68">class MSVCCompiler (CCompiler) :
    """Concrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class."""

    compiler_type = 'msvc'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.rc']
    _mc_extensions = ['.mc']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions + _mc_extensions)
    res_extension = '.res'
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'

    @others
</t>
<t tx="ekr.20080401090512.69">def __init__ (self, verbose=0, dry_run=0, force=0):
    CCompiler.__init__ (self, verbose, dry_run, force)
    self.__version = get_build_version()
    self.__arch = get_build_architecture()
    if self.__arch == "Intel":
        # x86
        if self.__version &gt;= 7:
            self.__root = r"Software\Microsoft\VisualStudio"
            self.__macros = MacroExpander(self.__version)
        else:
            self.__root = r"Software\Microsoft\Devstudio"
        self.__product = "Visual Studio version %s" % self.__version
    else:
        # Win64. Assume this was built with the platform SDK
        self.__product = "Microsoft SDK compiler %s" % (self.__version + 6)

    self.initialized = False

</t>
<t tx="ekr.20080401090512.70">def initialize(self):
    self.__paths = []
    if os.environ.has_key("DISTUTILS_USE_SDK") and os.environ.has_key("MSSdk") and self.find_exe("cl.exe"):
        # Assume that the SDK set up everything alright; don't try to be
        # smarter
        self.cc = "cl.exe"
        self.linker = "link.exe"
        self.lib = "lib.exe"
        self.rc = "rc.exe"
        self.mc = "mc.exe"
    else:
        self.__paths = self.get_msvc_paths("path")

        if len (self.__paths) == 0:
            raise DistutilsPlatformError, \
                  ("Python was built with %s, "
                   "and extensions need to be built with the same "
                   "version of the compiler, but it isn't installed." % self.__product)

        self.cc = self.find_exe("cl.exe")
        self.linker = self.find_exe("link.exe")
        self.lib = self.find_exe("lib.exe")
        self.rc = self.find_exe("rc.exe")   # resource compiler
        self.mc = self.find_exe("mc.exe")   # message compiler
        self.set_path_env_var('lib')
        self.set_path_env_var('include')

    # extend the MSVC path with the current path
    try:
        for p in string.split(os.environ['path'], ';'):
            self.__paths.append(p)
    except KeyError:
        pass
    os.environ['path'] = string.join(self.__paths, ';')

    self.preprocess_options = None
    if self.__arch == "Intel":
        self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GX' ,
                                 '/DNDEBUG']
        self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GX',
                                      '/Z7', '/D_DEBUG']
    else:
        # Win64
        self.compile_options = [ '/nologo', '/Ox', '/MD', '/W3', '/GS-' ,
                                 '/DNDEBUG']
        self.compile_options_debug = ['/nologo', '/Od', '/MDd', '/W3', '/GS-',
                                      '/Z7', '/D_DEBUG']

    self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']
    if self.__version &gt;= 7:
        self.ldflags_shared_debug = [
            '/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG'
            ]
    else:
        self.ldflags_shared_debug = [
            '/DLL', '/nologo', '/INCREMENTAL:no', '/pdb:None', '/DEBUG'
            ]
    self.ldflags_static = [ '/nologo']

    self.initialized = True

</t>
<t tx="ekr.20080401090512.71"># -- Worker methods ------------------------------------------------

def object_filenames (self,
                      source_filenames,
                      strip_dir=0,
                      output_dir=''):
    # Copied from ccompiler.py, extended to return .res as 'object'-file
    # for .rc input file
    if output_dir is None: output_dir = ''
    obj_names = []
    for src_name in source_filenames:
        (base, ext) = os.path.splitext (src_name)
        base = os.path.splitdrive(base)[1] # Chop off the drive
        base = base[os.path.isabs(base):]  # If abs, chop off leading /
        if ext not in self.src_extensions:
            # Better to raise an exception instead of silently continuing
            # and later complain about sources and targets having
            # different lengths
            raise CompileError ("Don't know how to compile %s" % src_name)
        if strip_dir:
            base = os.path.basename (base)
        if ext in self._rc_extensions:
            obj_names.append (os.path.join (output_dir,
                                            base + self.res_extension))
        elif ext in self._mc_extensions:
            obj_names.append (os.path.join (output_dir,
                                            base + self.res_extension))
        else:
            obj_names.append (os.path.join (output_dir,
                                            base + self.obj_extension))
    return obj_names

</t>
<t tx="ekr.20080401090512.72"># object_filenames ()


def compile(self, sources,
            output_dir=None, macros=None, include_dirs=None, debug=0,
            extra_preargs=None, extra_postargs=None, depends=None):

    if not self.initialized: self.initialize()
    macros, objects, extra_postargs, pp_opts, build = \
            self._setup_compile(output_dir, macros, include_dirs, sources,
                                depends, extra_postargs)

    compile_opts = extra_preargs or []
    compile_opts.append ('/c')
    if debug:
        compile_opts.extend(self.compile_options_debug)
    else:
        compile_opts.extend(self.compile_options)

    for obj in objects:
        try:
            src, ext = build[obj]
        except KeyError:
            continue
        if debug:
            # pass the full pathname to MSVC in debug mode,
            # this allows the debugger to find the source file
            # without asking the user to browse for it
            src = os.path.abspath(src)

        if ext in self._c_extensions:
            input_opt = "/Tc" + src
        elif ext in self._cpp_extensions:
            input_opt = "/Tp" + src
        elif ext in self._rc_extensions:
            # compile .RC to .RES file
            input_opt = src
            output_opt = "/fo" + obj
            try:
                self.spawn ([self.rc] + pp_opts +
                            [output_opt] + [input_opt])
            except DistutilsExecError, msg:
                raise CompileError, msg
            continue
        elif ext in self._mc_extensions:

            # Compile .MC to .RC file to .RES file.
            #   * '-h dir' specifies the directory for the
            #     generated include file
            #   * '-r dir' specifies the target directory of the
            #     generated RC file and the binary message resource
            #     it includes
            #
            # For now (since there are no options to change this),
            # we use the source-directory for the include file and
            # the build directory for the RC file and message
            # resources. This works at least for win32all.

            h_dir = os.path.dirname (src)
            rc_dir = os.path.dirname (obj)
            try:
                # first compile .MC to .RC and .H file
                self.spawn ([self.mc] +
                            ['-h', h_dir, '-r', rc_dir] + [src])
                base, _ = os.path.splitext (os.path.basename (src))
                rc_file = os.path.join (rc_dir, base + '.rc')
                # then compile .RC to .RES file
                self.spawn ([self.rc] +
                            ["/fo" + obj] + [rc_file])

            except DistutilsExecError, msg:
                raise CompileError, msg
            continue
        else:
            # how to handle this file?
            raise CompileError (
                "Don't know how to compile %s to %s" % \
                (src, obj))

        output_opt = "/Fo" + obj
        try:
            self.spawn ([self.cc] + compile_opts + pp_opts +
                        [input_opt, output_opt] +
                        extra_postargs)
        except DistutilsExecError, msg:
            raise CompileError, msg

    return objects

</t>
<t tx="ekr.20080401090512.73"># compile ()


def create_static_lib (self,
                       objects,
                       output_libname,
                       output_dir=None,
                       debug=0,
                       target_lang=None):

    if not self.initialized: self.initialize()
    (objects, output_dir) = self._fix_object_args (objects, output_dir)
    output_filename = \
        self.library_filename (output_libname, output_dir=output_dir)

    if self._need_link (objects, output_filename):
        lib_args = objects + ['/OUT:' + output_filename]
        if debug:
            pass                    # XXX what goes here?
        try:
            self.spawn ([self.lib] + lib_args)
        except DistutilsExecError, msg:
            raise LibError, msg

    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090512.74"># create_static_lib ()

def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):

    if not self.initialized: self.initialize()
    (objects, output_dir) = self._fix_object_args (objects, output_dir)
    (libraries, library_dirs, runtime_library_dirs) = \
        self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

    if runtime_library_dirs:
        self.warn ("I don't know what to do with 'runtime_library_dirs': "
                   + str (runtime_library_dirs))

    lib_opts = gen_lib_options (self,
                                library_dirs, runtime_library_dirs,
                                libraries)
    if output_dir is not None:
        output_filename = os.path.join (output_dir, output_filename)

    if self._need_link (objects, output_filename):

        if target_desc == CCompiler.EXECUTABLE:
            if debug:
                ldflags = self.ldflags_shared_debug[1:]
            else:
                ldflags = self.ldflags_shared[1:]
        else:
            if debug:
                ldflags = self.ldflags_shared_debug
            else:
                ldflags = self.ldflags_shared

        export_opts = []
        for sym in (export_symbols or []):
            export_opts.append("/EXPORT:" + sym)

        ld_args = (ldflags + lib_opts + export_opts +
                   objects + ['/OUT:' + output_filename])

        # The MSVC linker generates .lib and .exp files, which cannot be
        # suppressed by any linker switches. The .lib files may even be
        # needed! Make sure they are generated in the temporary build
        # directory. Since they have different names for debug and release
        # builds, they can go into the same directory.
        if export_symbols is not None:
            (dll_name, dll_ext) = os.path.splitext(
                os.path.basename(output_filename))
            implib_file = os.path.join(
                os.path.dirname(objects[0]),
                self.library_filename(dll_name))
            ld_args.append ('/IMPLIB:' + implib_file)

        if extra_preargs:
            ld_args[:0] = extra_preargs
        if extra_postargs:
            ld_args.extend(extra_postargs)

        self.mkpath (os.path.dirname (output_filename))
        try:
            self.spawn ([self.linker] + ld_args)
        except DistutilsExecError, msg:
            raise LinkError, msg

    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090512.75"># link ()


# -- Miscellaneous methods -----------------------------------------
# These are all used by the 'gen_lib_options() function, in
# ccompiler.py.

def library_dir_option (self, dir):
    return "/LIBPATH:" + dir

</t>
<t tx="ekr.20080401090512.76">def runtime_library_dir_option (self, dir):
    raise DistutilsPlatformError, \
          "don't know how to set runtime library search path for MSVC++"

</t>
<t tx="ekr.20080401090512.77">def library_option (self, lib):
    return self.library_filename (lib)


</t>
<t tx="ekr.20080401090512.78">def find_library_file (self, dirs, lib, debug=0):
    # Prefer a debugging library if found (and requested), but deal
    # with it if we don't have one.
    if debug:
        try_names = [lib + "_d", lib]
    else:
        try_names = [lib]
    for dir in dirs:
        for name in try_names:
            libfile = os.path.join(dir, self.library_filename (name))
            if os.path.exists(libfile):
                return libfile
    else:
        # Oops, didn't find it in *any* of 'dirs'
        return None

</t>
<t tx="ekr.20080401090512.79"># find_library_file ()

# Helper methods for using the MSVC registry settings

def find_exe(self, exe):
    """Return path to an MSVC executable program.

    Tries to find the program in several places: first, one of the
    MSVC program search paths from the registry; next, the directories
    in the PATH environment variable.  If any of those work, return an
    absolute path that is known to exist.  If none of them work, just
    return the original program name, 'exe'.
    """

    for p in self.__paths:
        fn = os.path.join(os.path.abspath(p), exe)
        if os.path.isfile(fn):
            return fn

    # didn't find it; try existing path
    for p in string.split(os.environ['Path'],';'):
        fn = os.path.join(os.path.abspath(p),exe)
        if os.path.isfile(fn):
            return fn

    return exe

</t>
<t tx="ekr.20080401090512.80">def get_msvc_paths(self, path, platform='x86'):
    """Get a list of devstudio directories (include, lib or path).

    Return a list of strings.  The list will be empty if unable to
    access the registry or appropriate registry keys not found.
    """

    if not _can_read_reg:
        return []

    path = path + " dirs"
    if self.__version &gt;= 7:
        key = (r"%s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directories"
               % (self.__root, self.__version))
    else:
        key = (r"%s\6.0\Build System\Components\Platforms"
               r"\Win32 (%s)\Directories" % (self.__root, platform))

    for base in HKEYS:
        d = read_values(base, key)
        if d:
            if self.__version &gt;= 7:
                return string.split(self.__macros.sub(d[path]), ";")
            else:
                return string.split(d[path], ";")
    # MSVC 6 seems to create the registry entries we need only when
    # the GUI is run.
    if self.__version == 6:
        for base in HKEYS:
            if read_values(base, r"%s\6.0" % self.__root) is not None:
                self.warn("It seems you have Visual Studio 6 installed, "
                    "but the expected registry settings are not present.\n"
                    "You must at least run the Visual Studio GUI once "
                    "so that these entries are created.")
                break
    return []

</t>
<t tx="ekr.20080401090512.81">def set_path_env_var(self, name):
    """Set environment variable 'name' to an MSVC path type value.

    This is equivalent to a SET command prior to execution of spawned
    commands.
    """

    if name == "lib":
        p = self.get_msvc_paths("library")
    else:
        p = self.get_msvc_paths(name)
    if p:
        os.environ[name] = string.join(p, ';')
</t>
<t tx="ekr.20080401090639.1"># -*- coding: iso-8859-1 -*-
# Copyright (C) 2005, 2006 Martin v. Löwis
# Licensed to PSF under a Contributor Agreement.
# The bdist_wininst command proper
# based on bdist_wininst
"""
Implements the bdist_msi command.
"""

import sys, os, string
from distutils.core import Command
from distutils.util import get_platform
from distutils.dir_util import remove_tree
from distutils.sysconfig import get_python_version
from distutils.version import StrictVersion
from distutils.errors import DistutilsOptionError
from distutils import log
import msilib
from msilib import schema, sequence, text
from msilib import Directory, Feature, Dialog, add_data

</t>
<t tx="ekr.20080401090639.2">class PyDialog(Dialog):
    """Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left."""
    @others
</t>
<t tx="ekr.20080401090639.3">def __init__(self, *args, **kw):
    """Dialog(database, name, x, y, w, h, attributes, title, first,
    default, cancel, bitmap=true)"""
    Dialog.__init__(self, *args)
    ruler = self.h - 36
    bmwidth = 152*ruler/328
    #if kw.get("bitmap", True):
    #    self.bitmap("Bitmap", 0, 0, bmwidth, ruler, "PythonWin")
    self.line("BottomLine", 0, ruler, self.w, 0)

</t>
<t tx="ekr.20080401090639.4">def title(self, title):
    "Set the title text of the dialog at the top."
    # name, x, y, w, h, flags=Visible|Enabled|Transparent|NoPrefix,
    # text, in VerdanaBold10
    self.text("Title", 15, 10, 320, 60, 0x30003,
              r"{\VerdanaBold10}%s" % title)

</t>
<t tx="ekr.20080401090639.5">def back(self, title, next, name = "Back", active = 1):
    """Add a back button with a given title, the tab-next button,
    its name in the Control table, possibly initially disabled.

    Return the button, so that events can be associated"""
    if active:
        flags = 3 # Visible|Enabled
    else:
        flags = 1 # Visible
    return self.pushbutton(name, 180, self.h-27 , 56, 17, flags, title, next)

</t>
<t tx="ekr.20080401090639.6">def cancel(self, title, next, name = "Cancel", active = 1):
    """Add a cancel button with a given title, the tab-next button,
    its name in the Control table, possibly initially disabled.

    Return the button, so that events can be associated"""
    if active:
        flags = 3 # Visible|Enabled
    else:
        flags = 1 # Visible
    return self.pushbutton(name, 304, self.h-27, 56, 17, flags, title, next)

</t>
<t tx="ekr.20080401090639.7">def next(self, title, next, name = "Next", active = 1):
    """Add a Next button with a given title, the tab-next button,
    its name in the Control table, possibly initially disabled.

    Return the button, so that events can be associated"""
    if active:
        flags = 3 # Visible|Enabled
    else:
        flags = 1 # Visible
    return self.pushbutton(name, 236, self.h-27, 56, 17, flags, title, next)

</t>
<t tx="ekr.20080401090639.8">def xbutton(self, name, title, next, xpos):
    """Add a button with a given title, the tab-next button,
    its name in the Control table, giving its x position; the
    y-position is aligned with the other buttons.

    Return the button, so that events can be associated"""
    return self.pushbutton(name, int(self.w*xpos - 28), self.h-27, 56, 17, 3, title, next)

</t>
<t tx="ekr.20080401090639.9">class bdist_msi (Command):

    description = "create a Microsoft Installer (.msi) binary distribution"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    @others
</t>
<t tx="ekr.20080401090639.10">def initialize_options (self):
    self.bdist_dir = None
    self.keep_temp = 0
    self.no_target_compile = 0
    self.no_target_optimize = 0
    self.target_version = None
    self.dist_dir = None
    self.skip_build = 0
    self.install_script = None
    self.pre_install_script = None

</t>
<t tx="ekr.20080401090639.11">def finalize_options (self):
    if self.bdist_dir is None:
        bdist_base = self.get_finalized_command('bdist').bdist_base
        self.bdist_dir = os.path.join(bdist_base, 'msi')
    short_version = get_python_version()
    if self.target_version:
        if not self.skip_build and self.distribution.has_ext_modules()\
           and self.target_version != short_version:
            raise DistutilsOptionError, \
                  "target version can only be %s, or the '--skip_build'" \
                  " option must be specified" % (short_version,)
    else:
        self.target_version = short_version

    self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))

    if self.pre_install_script:
        raise DistutilsOptionError, "the pre-install-script feature is not yet implemented"

    if self.install_script:
        for script in self.distribution.scripts:
            if self.install_script == os.path.basename(script):
                break
        else:
            raise DistutilsOptionError, \
                  "install_script '%s' not found in scripts" % \
                  self.install_script
    self.install_script_key = None
</t>
<t tx="ekr.20080401090639.12"># finalize_options()


def run (self):
    if not self.skip_build:
        self.run_command('build')

    install = self.reinitialize_command('install', reinit_subcommands=1)
    install.prefix = self.bdist_dir
    install.skip_build = self.skip_build
    install.warn_dir = 0

    install_lib = self.reinitialize_command('install_lib')
    # we do not want to include pyc or pyo files
    install_lib.compile = 0
    install_lib.optimize = 0

    if self.distribution.has_ext_modules():
        # If we are building an installer for a Python version other
        # than the one we are currently running, then we need to ensure
        # our build_lib reflects the other Python version rather than ours.
        # Note that for target_version!=sys.version, we must have skipped the
        # build step, so there is no issue with enforcing the build of this
        # version.
        target_version = self.target_version
        if not target_version:
            assert self.skip_build, "Should have already checked this"
            target_version = sys.version[0:3]
        plat_specifier = ".%s-%s" % (get_platform(), target_version)
        build = self.get_finalized_command('build')
        build.build_lib = os.path.join(build.build_base,
                                       'lib' + plat_specifier)

    log.info("installing to %s", self.bdist_dir)
    install.ensure_finalized()

    # avoid warning of 'install_lib' about installing
    # into a directory not in sys.path
    sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

    install.run()

    del sys.path[0]

    self.mkpath(self.dist_dir)
    fullname = self.distribution.get_fullname()
    installer_name = self.get_installer_filename(fullname)
    installer_name = os.path.abspath(installer_name)
    if os.path.exists(installer_name): os.unlink(installer_name)

    metadata = self.distribution.metadata
    author = metadata.author
    if not author:
        author = metadata.maintainer
    if not author:
        author = "UNKNOWN"
    version = metadata.get_version()
    # ProductVersion must be strictly numeric
    # XXX need to deal with prerelease versions
    sversion = "%d.%d.%d" % StrictVersion(version).version
    # Prefix ProductName with Python x.y, so that
    # it sorts together with the other Python packages
    # in Add-Remove-Programs (APR)
    product_name = "Python %s %s" % (self.target_version,
                   self.distribution.get_fullname())
    self.db = msilib.init_database(installer_name, schema,
            product_name, msilib.gen_uuid(),
            sversion, author)
    msilib.add_tables(self.db, sequence)
    props = [('DistVersion', version)]
    email = metadata.author_email or metadata.maintainer_email
    if email:
        props.append(("ARPCONTACT", email))
    if metadata.url:
        props.append(("ARPURLINFOABOUT", metadata.url))
    if props:
        add_data(self.db, 'Property', props)

    self.add_find_python()
    self.add_files()
    self.add_scripts()
    self.add_ui()
    self.db.Commit()

    if hasattr(self.distribution, 'dist_files'):
        self.distribution.dist_files.append(('bdist_msi', self.target_version, fullname))

    if not self.keep_temp:
        remove_tree(self.bdist_dir, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090639.13">def add_files(self):
    db = self.db
    cab = msilib.CAB("distfiles")
    f = Feature(db, "default", "Default Feature", "Everything", 1, directory="TARGETDIR")
    f.set_current()
    rootdir = os.path.abspath(self.bdist_dir)
    root = Directory(db, cab, None, rootdir, "TARGETDIR", "SourceDir")
    db.Commit()
    todo = [root]
    while todo:
        dir = todo.pop()
        for file in os.listdir(dir.absolute):
            afile = os.path.join(dir.absolute, file)
            if os.path.isdir(afile):
                newdir = Directory(db, cab, dir, file, file, "%s|%s" % (dir.make_short(file), file))
                todo.append(newdir)
            else:
                key = dir.add_file(file)
                if file==self.install_script:
                    if self.install_script_key:
                        raise DistutilsOptionError, "Multiple files with name %s" % file
                    self.install_script_key = '[#%s]' % key

    cab.commit(db)

</t>
<t tx="ekr.20080401090639.14">def add_find_python(self):
    """Adds code to the installer to compute the location of Python.
    Properties PYTHON.MACHINE, PYTHON.USER, PYTHONDIR and PYTHON will be set
    in both the execute and UI sequences; PYTHONDIR will be set from
    PYTHON.USER if defined, else from PYTHON.MACHINE.
    PYTHON is PYTHONDIR\python.exe"""
    install_path = r"SOFTWARE\Python\PythonCore\%s\InstallPath" % self.target_version
    add_data(self.db, "RegLocator",
            [("python.machine", 2, install_path, None, 2),
             ("python.user", 1, install_path, None, 2)])
    add_data(self.db, "AppSearch",
            [("PYTHON.MACHINE", "python.machine"),
             ("PYTHON.USER", "python.user")])
    add_data(self.db, "CustomAction",
            [("PythonFromMachine", 51+256, "PYTHONDIR", "[PYTHON.MACHINE]"),
             ("PythonFromUser", 51+256, "PYTHONDIR", "[PYTHON.USER]"),
             ("PythonExe", 51+256, "PYTHON", "[PYTHONDIR]\\python.exe"),
             ("InitialTargetDir", 51+256, "TARGETDIR", "[PYTHONDIR]")])
    add_data(self.db, "InstallExecuteSequence",
            [("PythonFromMachine", "PYTHON.MACHINE", 401),
             ("PythonFromUser", "PYTHON.USER", 402),
             ("PythonExe", None, 403),
             ("InitialTargetDir", 'TARGETDIR=""', 404),
            ])
    add_data(self.db, "InstallUISequence",
            [("PythonFromMachine", "PYTHON.MACHINE", 401),
             ("PythonFromUser", "PYTHON.USER", 402),
             ("PythonExe", None, 403),
             ("InitialTargetDir", 'TARGETDIR=""', 404),
            ])

</t>
<t tx="ekr.20080401090639.15">def add_scripts(self):
    if self.install_script:
        add_data(self.db, "CustomAction",
                [("install_script", 50, "PYTHON", self.install_script_key)])
        add_data(self.db, "InstallExecuteSequence",
                [("install_script", "NOT Installed", 6800)])
    if self.pre_install_script:
        scriptfn = os.path.join(self.bdist_dir, "preinstall.bat")
        f = open(scriptfn, "w")
        # The batch file will be executed with [PYTHON], so that %1
        # is the path to the Python interpreter; %0 will be the path
        # of the batch file.
        # rem ="""
        # %1 %0
        # exit
        # """
        # &lt;actual script&gt;
        f.write('rem ="""\n%1 %0\nexit\n"""\n')
        f.write(open(self.pre_install_script).read())
        f.close()
        add_data(self.db, "Binary",
            [("PreInstall", msilib.Binary(scriptfn))
            ])
        add_data(self.db, "CustomAction",
            [("PreInstall", 2, "PreInstall", None)
            ])
        add_data(self.db, "InstallExecuteSequence",
                [("PreInstall", "NOT Installed", 450)])


</t>
<t tx="ekr.20080401090639.16">def add_ui(self):
    db = self.db
    x = y = 50
    w = 370
    h = 300
    title = "[ProductName] Setup"

    # see "Dialog Style Bits"
    modal = 3      # visible | modal
    modeless = 1   # visible
    track_disk_space = 32

    # UI customization properties
    add_data(db, "Property",
             # See "DefaultUIFont Property"
             [("DefaultUIFont", "DlgFont8"),
              # See "ErrorDialog Style Bit"
              ("ErrorDialog", "ErrorDlg"),
              ("Progress1", "Install"),   # modified in maintenance type dlg
              ("Progress2", "installs"),
              ("MaintenanceForm_Action", "Repair"),
              # possible values: ALL, JUSTME
              ("WhichUsers", "ALL")
             ])

    # Fonts, see "TextStyle Table"
    add_data(db, "TextStyle",
             [("DlgFont8", "Tahoma", 9, None, 0),
              ("DlgFontBold8", "Tahoma", 8, None, 1), #bold
              ("VerdanaBold10", "Verdana", 10, None, 1),
              ("VerdanaRed9", "Verdana", 9, 255, 0),
             ])

    # UI Sequences, see "InstallUISequence Table", "Using a Sequence Table"
    # Numbers indicate sequence; see sequence.py for how these action integrate
    add_data(db, "InstallUISequence",
             [("PrepareDlg", "Not Privileged or Windows9x or Installed", 140),
              ("WhichUsersDlg", "Privileged and not Windows9x and not Installed", 141),
              # In the user interface, assume all-users installation if privileged.
              ("SelectDirectoryDlg", "Not Installed", 1230),
              # XXX no support for resume installations yet
              #("ResumeDlg", "Installed AND (RESUME OR Preselected)", 1240),
              ("MaintenanceTypeDlg", "Installed AND NOT RESUME AND NOT Preselected", 1250),
              ("ProgressDlg", None, 1280)])

    add_data(db, 'ActionText', text.ActionText)
    add_data(db, 'UIText', text.UIText)
    #####################################################################
    # Standard dialogs: FatalError, UserExit, ExitDialog
    fatal=PyDialog(db, "FatalError", x, y, w, h, modal, title,
                 "Finish", "Finish", "Finish")
    fatal.title("[ProductName] Installer ended prematurely")
    fatal.back("&lt; Back", "Finish", active = 0)
    fatal.cancel("Cancel", "Back", active = 0)
    fatal.text("Description1", 15, 70, 320, 80, 0x30003,
               "[ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.")
    fatal.text("Description2", 15, 155, 320, 20, 0x30003,
               "Click the Finish button to exit the Installer.")
    c=fatal.next("Finish", "Cancel", name="Finish")
    c.event("EndDialog", "Exit")

    user_exit=PyDialog(db, "UserExit", x, y, w, h, modal, title,
                 "Finish", "Finish", "Finish")
    user_exit.title("[ProductName] Installer was interrupted")
    user_exit.back("&lt; Back", "Finish", active = 0)
    user_exit.cancel("Cancel", "Back", active = 0)
    user_exit.text("Description1", 15, 70, 320, 80, 0x30003,
               "[ProductName] setup was interrupted.  Your system has not been modified.  "
               "To install this program at a later time, please run the installation again.")
    user_exit.text("Description2", 15, 155, 320, 20, 0x30003,
               "Click the Finish button to exit the Installer.")
    c = user_exit.next("Finish", "Cancel", name="Finish")
    c.event("EndDialog", "Exit")

    exit_dialog = PyDialog(db, "ExitDialog", x, y, w, h, modal, title,
                         "Finish", "Finish", "Finish")
    exit_dialog.title("Completing the [ProductName] Installer")
    exit_dialog.back("&lt; Back", "Finish", active = 0)
    exit_dialog.cancel("Cancel", "Back", active = 0)
    exit_dialog.text("Description", 15, 235, 320, 20, 0x30003,
               "Click the Finish button to exit the Installer.")
    c = exit_dialog.next("Finish", "Cancel", name="Finish")
    c.event("EndDialog", "Return")

    #####################################################################
    # Required dialog: FilesInUse, ErrorDlg
    inuse = PyDialog(db, "FilesInUse",
                     x, y, w, h,
                     19,                # KeepModeless|Modal|Visible
                     title,
                     "Retry", "Retry", "Retry", bitmap=False)
    inuse.text("Title", 15, 6, 200, 15, 0x30003,
               r"{\DlgFontBold8}Files in Use")
    inuse.text("Description", 20, 23, 280, 20, 0x30003,
           "Some files that need to be updated are currently in use.")
    inuse.text("Text", 20, 55, 330, 50, 3,
               "The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.")
    inuse.control("List", "ListBox", 20, 107, 330, 130, 7, "FileInUseProcess",
                  None, None, None)
    c=inuse.back("Exit", "Ignore", name="Exit")
    c.event("EndDialog", "Exit")
    c=inuse.next("Ignore", "Retry", name="Ignore")
    c.event("EndDialog", "Ignore")
    c=inuse.cancel("Retry", "Exit", name="Retry")
    c.event("EndDialog","Retry")

    # See "Error Dialog". See "ICE20" for the required names of the controls.
    error = Dialog(db, "ErrorDlg",
                   50, 10, 330, 101,
                   65543,       # Error|Minimize|Modal|Visible
                   title,
                   "ErrorText", None, None)
    error.text("ErrorText", 50,9,280,48,3, "")
    #error.control("ErrorIcon", "Icon", 15, 9, 24, 24, 5242881, None, "py.ico", None, None)
    error.pushbutton("N",120,72,81,21,3,"No",None).event("EndDialog","ErrorNo")
    error.pushbutton("Y",240,72,81,21,3,"Yes",None).event("EndDialog","ErrorYes")
    error.pushbutton("A",0,72,81,21,3,"Abort",None).event("EndDialog","ErrorAbort")
    error.pushbutton("C",42,72,81,21,3,"Cancel",None).event("EndDialog","ErrorCancel")
    error.pushbutton("I",81,72,81,21,3,"Ignore",None).event("EndDialog","ErrorIgnore")
    error.pushbutton("O",159,72,81,21,3,"Ok",None).event("EndDialog","ErrorOk")
    error.pushbutton("R",198,72,81,21,3,"Retry",None).event("EndDialog","ErrorRetry")

    #####################################################################
    # Global "Query Cancel" dialog
    cancel = Dialog(db, "CancelDlg", 50, 10, 260, 85, 3, title,
                    "No", "No", "No")
    cancel.text("Text", 48, 15, 194, 30, 3,
                "Are you sure you want to cancel [ProductName] installation?")
    #cancel.control("Icon", "Icon", 15, 15, 24, 24, 5242881, None,
    #               "py.ico", None, None)
    c=cancel.pushbutton("Yes", 72, 57, 56, 17, 3, "Yes", "No")
    c.event("EndDialog", "Exit")

    c=cancel.pushbutton("No", 132, 57, 56, 17, 3, "No", "Yes")
    c.event("EndDialog", "Return")

    #####################################################################
    # Global "Wait for costing" dialog
    costing = Dialog(db, "WaitForCostingDlg", 50, 10, 260, 85, modal, title,
                     "Return", "Return", "Return")
    costing.text("Text", 48, 15, 194, 30, 3,
                 "Please wait while the installer finishes determining your disk space requirements.")
    c = costing.pushbutton("Return", 102, 57, 56, 17, 3, "Return", None)
    c.event("EndDialog", "Exit")

    #####################################################################
    # Preparation dialog: no user input except cancellation
    prep = PyDialog(db, "PrepareDlg", x, y, w, h, modeless, title,
                    "Cancel", "Cancel", "Cancel")
    prep.text("Description", 15, 70, 320, 40, 0x30003,
              "Please wait while the Installer prepares to guide you through the installation.")
    prep.title("Welcome to the [ProductName] Installer")
    c=prep.text("ActionText", 15, 110, 320, 20, 0x30003, "Pondering...")
    c.mapping("ActionText", "Text")
    c=prep.text("ActionData", 15, 135, 320, 30, 0x30003, None)
    c.mapping("ActionData", "Text")
    prep.back("Back", None, active=0)
    prep.next("Next", None, active=0)
    c=prep.cancel("Cancel", None)
    c.event("SpawnDialog", "CancelDlg")

    #####################################################################
    # Target directory selection
    seldlg = PyDialog(db, "SelectDirectoryDlg", x, y, w, h, modal, title,
                    "Next", "Next", "Cancel")
    seldlg.title("Select Destination Directory")

    version = sys.version[:3]+" "
    seldlg.text("Hint", 15, 30, 300, 40, 3,
            "The destination directory should contain a Python %sinstallation" % version)

    seldlg.back("&lt; Back", None, active=0)
    c = seldlg.next("Next &gt;", "Cancel")
    c.event("SetTargetPath", "TARGETDIR", ordering=1)
    c.event("SpawnWaitDialog", "WaitForCostingDlg", ordering=2)
    c.event("EndDialog", "Return", ordering=3)

    c = seldlg.cancel("Cancel", "DirectoryCombo")
    c.event("SpawnDialog", "CancelDlg")

    seldlg.control("DirectoryCombo", "DirectoryCombo", 15, 70, 272, 80, 393219,
                   "TARGETDIR", None, "DirectoryList", None)
    seldlg.control("DirectoryList", "DirectoryList", 15, 90, 308, 136, 3, "TARGETDIR",
                   None, "PathEdit", None)
    seldlg.control("PathEdit", "PathEdit", 15, 230, 306, 16, 3, "TARGETDIR", None, "Next", None)
    c = seldlg.pushbutton("Up", 306, 70, 18, 18, 3, "Up", None)
    c.event("DirectoryListUp", "0")
    c = seldlg.pushbutton("NewDir", 324, 70, 30, 18, 3, "New", None)
    c.event("DirectoryListNew", "0")

    #####################################################################
    # Disk cost
    cost = PyDialog(db, "DiskCostDlg", x, y, w, h, modal, title,
                    "OK", "OK", "OK", bitmap=False)
    cost.text("Title", 15, 6, 200, 15, 0x30003,
              "{\DlgFontBold8}Disk Space Requirements")
    cost.text("Description", 20, 20, 280, 20, 0x30003,
              "The disk space required for the installation of the selected features.")
    cost.text("Text", 20, 53, 330, 60, 3,
              "The highlighted volumes (if any) do not have enough disk space "
          "available for the currently selected features.  You can either "
          "remove some files from the highlighted volumes, or choose to "
          "install less features onto local drive(s), or select different "
          "destination drive(s).")
    cost.control("VolumeList", "VolumeCostList", 20, 100, 330, 150, 393223,
                 None, "{120}{70}{70}{70}{70}", None, None)
    cost.xbutton("OK", "Ok", None, 0.5).event("EndDialog", "Return")

    #####################################################################
    # WhichUsers Dialog. Only available on NT, and for privileged users.
    # This must be run before FindRelatedProducts, because that will
    # take into account whether the previous installation was per-user
    # or per-machine. We currently don't support going back to this
    # dialog after "Next" was selected; to support this, we would need to
    # find how to reset the ALLUSERS property, and how to re-run
    # FindRelatedProducts.
    # On Windows9x, the ALLUSERS property is ignored on the command line
    # and in the Property table, but installer fails according to the documentation
    # if a dialog attempts to set ALLUSERS.
    whichusers = PyDialog(db, "WhichUsersDlg", x, y, w, h, modal, title,
                        "AdminInstall", "Next", "Cancel")
    whichusers.title("Select whether to install [ProductName] for all users of this computer.")
    # A radio group with two options: allusers, justme
    g = whichusers.radiogroup("AdminInstall", 15, 60, 260, 50, 3,
                              "WhichUsers", "", "Next")
    g.add("ALL", 0, 5, 150, 20, "Install for all users")
    g.add("JUSTME", 0, 25, 150, 20, "Install just for me")

    whichusers.back("Back", None, active=0)

    c = whichusers.next("Next &gt;", "Cancel")
    c.event("[ALLUSERS]", "1", 'WhichUsers="ALL"', 1)
    c.event("EndDialog", "Return", ordering = 2)

    c = whichusers.cancel("Cancel", "AdminInstall")
    c.event("SpawnDialog", "CancelDlg")

    #####################################################################
    # Installation Progress dialog (modeless)
    progress = PyDialog(db, "ProgressDlg", x, y, w, h, modeless, title,
                        "Cancel", "Cancel", "Cancel", bitmap=False)
    progress.text("Title", 20, 15, 200, 15, 0x30003,
                  "{\DlgFontBold8}[Progress1] [ProductName]")
    progress.text("Text", 35, 65, 300, 30, 3,
                  "Please wait while the Installer [Progress2] [ProductName]. "
                  "This may take several minutes.")
    progress.text("StatusLabel", 35, 100, 35, 20, 3, "Status:")

    c=progress.text("ActionText", 70, 100, w-70, 20, 3, "Pondering...")
    c.mapping("ActionText", "Text")

    #c=progress.text("ActionData", 35, 140, 300, 20, 3, None)
    #c.mapping("ActionData", "Text")

    c=progress.control("ProgressBar", "ProgressBar", 35, 120, 300, 10, 65537,
                       None, "Progress done", None, None)
    c.mapping("SetProgress", "Progress")

    progress.back("&lt; Back", "Next", active=False)
    progress.next("Next &gt;", "Cancel", active=False)
    progress.cancel("Cancel", "Back").event("SpawnDialog", "CancelDlg")

    ###################################################################
    # Maintenance type: repair/uninstall
    maint = PyDialog(db, "MaintenanceTypeDlg", x, y, w, h, modal, title,
                     "Next", "Next", "Cancel")
    maint.title("Welcome to the [ProductName] Setup Wizard")
    maint.text("BodyText", 15, 63, 330, 42, 3,
               "Select whether you want to repair or remove [ProductName].")
    g=maint.radiogroup("RepairRadioGroup", 15, 108, 330, 60, 3,
                        "MaintenanceForm_Action", "", "Next")
    #g.add("Change", 0, 0, 200, 17, "&amp;Change [ProductName]")
    g.add("Repair", 0, 18, 200, 17, "&amp;Repair [ProductName]")
    g.add("Remove", 0, 36, 200, 17, "Re&amp;move [ProductName]")

    maint.back("&lt; Back", None, active=False)
    c=maint.next("Finish", "Cancel")
    # Change installation: Change progress dialog to "Change", then ask
    # for feature selection
    #c.event("[Progress1]", "Change", 'MaintenanceForm_Action="Change"', 1)
    #c.event("[Progress2]", "changes", 'MaintenanceForm_Action="Change"', 2)

    # Reinstall: Change progress dialog to "Repair", then invoke reinstall
    # Also set list of reinstalled features to "ALL"
    c.event("[REINSTALL]", "ALL", 'MaintenanceForm_Action="Repair"', 5)
    c.event("[Progress1]", "Repairing", 'MaintenanceForm_Action="Repair"', 6)
    c.event("[Progress2]", "repairs", 'MaintenanceForm_Action="Repair"', 7)
    c.event("Reinstall", "ALL", 'MaintenanceForm_Action="Repair"', 8)

    # Uninstall: Change progress to "Remove", then invoke uninstall
    # Also set list of removed features to "ALL"
    c.event("[REMOVE]", "ALL", 'MaintenanceForm_Action="Remove"', 11)
    c.event("[Progress1]", "Removing", 'MaintenanceForm_Action="Remove"', 12)
    c.event("[Progress2]", "removes", 'MaintenanceForm_Action="Remove"', 13)
    c.event("Remove", "ALL", 'MaintenanceForm_Action="Remove"', 14)

    # Close dialog when maintenance action scheduled
    c.event("EndDialog", "Return", 'MaintenanceForm_Action&lt;&gt;"Change"', 20)
    #c.event("NewDialog", "SelectFeaturesDlg", 'MaintenanceForm_Action="Change"', 21)

    maint.cancel("Cancel", "RepairRadioGroup").event("SpawnDialog", "CancelDlg")

</t>
<t tx="ekr.20080401090639.17">def get_installer_filename(self, fullname):
    # Factored out to allow overriding in subclasses
    installer_name = os.path.join(self.dist_dir,
                                  "%s.win32-py%s.msi" %
                                   (fullname, self.target_version))
    return installer_name
</t>
<t tx="ekr.20080401090639.18">"""distutils.command.register

Implements the Distutils 'register' command (register with the repository).
"""

# created 2002/10/21, Richard Jones

__revision__ = "$Id: register.py 38752 2005-03-31 13:57:38Z doerwalter $"

import sys, os, string, urllib2, getpass, urlparse
import StringIO, ConfigParser

from distutils.core import Command
from distutils.errors import *

</t>
<t tx="ekr.20080401090639.19">class register(Command):

    description = ("register the distribution with the Python package index")

    DEFAULT_REPOSITORY = 'http://www.python.org/pypi'

    user_options = [
        ('repository=', 'r',
         "url of repository [default: %s]"%DEFAULT_REPOSITORY),
        ('list-classifiers', None,
         'list the valid Trove classifiers'),
        ('show-response', None,
         'display full response text from server'),
        ]
    boolean_options = ['verify', 'show-response', 'list-classifiers']

    @others
</t>
<t tx="ekr.20080401090639.20">def initialize_options(self):
    self.repository = None
    self.show_response = 0
    self.list_classifiers = 0

</t>
<t tx="ekr.20080401090639.21">def finalize_options(self):
    if self.repository is None:
        self.repository = self.DEFAULT_REPOSITORY

</t>
<t tx="ekr.20080401090639.22">def run(self):
    self.check_metadata()
    if self.dry_run:
        self.verify_metadata()
    elif self.list_classifiers:
        self.classifiers()
    else:
        self.send_metadata()

</t>
<t tx="ekr.20080401090639.23">def check_metadata(self):
    """Ensure that all required elements of meta-data (name, version,
       URL, (author and author_email) or (maintainer and
       maintainer_email)) are supplied by the Distribution object; warn if
       any are missing.
    """
    metadata = self.distribution.metadata

    missing = []
    for attr in ('name', 'version', 'url'):
        if not (hasattr(metadata, attr) and getattr(metadata, attr)):
            missing.append(attr)

    if missing:
        self.warn("missing required meta-data: " +
                  string.join(missing, ", "))

    if metadata.author:
        if not metadata.author_email:
            self.warn("missing meta-data: if 'author' supplied, " +
                      "'author_email' must be supplied too")
    elif metadata.maintainer:
        if not metadata.maintainer_email:
            self.warn("missing meta-data: if 'maintainer' supplied, " +
                      "'maintainer_email' must be supplied too")
    else:
        self.warn("missing meta-data: either (author and author_email) " +
                  "or (maintainer and maintainer_email) " +
                  "must be supplied")

</t>
<t tx="ekr.20080401090639.24">def classifiers(self):
    ''' Fetch the list of classifiers from the server.
    '''
    response = urllib2.urlopen(self.repository+'?:action=list_classifiers')
    print response.read()

</t>
<t tx="ekr.20080401090639.25">def verify_metadata(self):
    ''' Send the metadata to the package index server to be checked.
    '''
    # send the info to the server and report the result
    (code, result) = self.post_to_server(self.build_post_data('verify'))
    print 'Server response (%s): %s'%(code, result)

</t>
<t tx="ekr.20080401090639.26">def send_metadata(self):
    ''' Send the metadata to the package index server.

        Well, do the following:
        1. figure who the user is, and then
        2. send the data as a Basic auth'ed POST.

        First we try to read the username/password from $HOME/.pypirc,
        which is a ConfigParser-formatted file with a section
        [server-login] containing username and password entries (both
        in clear text). Eg:

            [server-login]
            username: fred
            password: sekrit

        Otherwise, to figure who the user is, we offer the user three
        choices:

         1. use existing login,
         2. register as a new user, or
         3. set the password to a random string and email the user.

    '''
    choice = 'x'
    username = password = ''

    # see if we can short-cut and get the username/password from the
    # config
    config = None
    if os.environ.has_key('HOME'):
        rc = os.path.join(os.environ['HOME'], '.pypirc')
        if os.path.exists(rc):
            print 'Using PyPI login from %s'%rc
            config = ConfigParser.ConfigParser()
            config.read(rc)
            username = config.get('server-login', 'username')
            password = config.get('server-login', 'password')
            choice = '1'

    # get the user's login info
    choices = '1 2 3 4'.split()
    while choice not in choices:
        print '''We need to know who you are, so please choose either:
1. use your existing login,
2. register as a new user,
3. have the server generate a new password for you (and email it to you), or
4. quit
Your selection [default 1]: ''',
        choice = raw_input()
        if not choice:
            choice = '1'
        elif choice not in choices:
            print 'Please choose one of the four options!'

    if choice == '1':
        # get the username and password
        while not username:
            username = raw_input('Username: ')
        while not password:
            password = getpass.getpass('Password: ')

        # set up the authentication
        auth = urllib2.HTTPPasswordMgr()
        host = urlparse.urlparse(self.repository)[1]
        auth.add_password('pypi', host, username, password)

        # send the info to the server and report the result
        code, result = self.post_to_server(self.build_post_data('submit'),
            auth)
        print 'Server response (%s): %s'%(code, result)

        # possibly save the login
        if os.environ.has_key('HOME') and config is None and code == 200:
            rc = os.path.join(os.environ['HOME'], '.pypirc')
            print 'I can store your PyPI login so future submissions will be faster.'
            print '(the login will be stored in %s)'%rc
            choice = 'X'
            while choice.lower() not in 'yn':
                choice = raw_input('Save your login (y/N)?')
                if not choice:
                    choice = 'n'
            if choice.lower() == 'y':
                f = open(rc, 'w')
                f.write('[server-login]\nusername:%s\npassword:%s\n'%(
                    username, password))
                f.close()
                try:
                    os.chmod(rc, 0600)
                except:
                    pass
    elif choice == '2':
        data = {':action': 'user'}
        data['name'] = data['password'] = data['email'] = ''
        data['confirm'] = None
        while not data['name']:
            data['name'] = raw_input('Username: ')
        while data['password'] != data['confirm']:
            while not data['password']:
                data['password'] = getpass.getpass('Password: ')
            while not data['confirm']:
                data['confirm'] = getpass.getpass(' Confirm: ')
            if data['password'] != data['confirm']:
                data['password'] = ''
                data['confirm'] = None
                print "Password and confirm don't match!"
        while not data['email']:
            data['email'] = raw_input('   EMail: ')
        code, result = self.post_to_server(data)
        if code != 200:
            print 'Server response (%s): %s'%(code, result)
        else:
            print 'You will receive an email shortly.'
            print 'Follow the instructions in it to complete registration.'
    elif choice == '3':
        data = {':action': 'password_reset'}
        data['email'] = ''
        while not data['email']:
            data['email'] = raw_input('Your email address: ')
        code, result = self.post_to_server(data)
        print 'Server response (%s): %s'%(code, result)

</t>
<t tx="ekr.20080401090639.27">def build_post_data(self, action):
    # figure the data to send - the metadata plus some additional
    # information used by the package server
    meta = self.distribution.metadata
    data = {
        ':action': action,
        'metadata_version' : '1.0',
        'name': meta.get_name(),
        'version': meta.get_version(),
        'summary': meta.get_description(),
        'home_page': meta.get_url(),
        'author': meta.get_contact(),
        'author_email': meta.get_contact_email(),
        'license': meta.get_licence(),
        'description': meta.get_long_description(),
        'keywords': meta.get_keywords(),
        'platform': meta.get_platforms(),
        'classifiers': meta.get_classifiers(),
        'download_url': meta.get_download_url(),
        # PEP 314
        'provides': meta.get_provides(),
        'requires': meta.get_requires(),
        'obsoletes': meta.get_obsoletes(),
    }
    if data['provides'] or data['requires'] or data['obsoletes']:
        data['metadata_version'] = '1.1'
    return data

</t>
<t tx="ekr.20080401090639.28">def post_to_server(self, data, auth=None):
    ''' Post a query to the server, and return a string response.
    '''

    # Build up the MIME payload for the urllib2 POST data
    boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
    sep_boundary = '\n--' + boundary
    end_boundary = sep_boundary + '--'
    body = StringIO.StringIO()
    for key, value in data.items():
        # handle multiple entries for the same name
        if type(value) != type([]):
            value = [value]
        for value in value:
            value = unicode(value).encode("utf-8")
            body.write(sep_boundary)
            body.write('\nContent-Disposition: form-data; name="%s"'%key)
            body.write("\n\n")
            body.write(value)
            if value and value[-1] == '\r':
                body.write('\n')  # write an extra newline (lurve Macs)
    body.write(end_boundary)
    body.write("\n")
    body = body.getvalue()

    # build the Request
    headers = {
        'Content-type': 'multipart/form-data; boundary=%s; charset=utf-8'%boundary,
        'Content-length': str(len(body))
    }
    req = urllib2.Request(self.repository, body, headers)

    # handle HTTP and include the Basic Auth handler
    opener = urllib2.build_opener(
        urllib2.HTTPBasicAuthHandler(password_mgr=auth)
    )
    data = ''
    try:
        result = opener.open(req)
    except urllib2.HTTPError, e:
        if self.show_response:
            data = e.fp.read()
        result = e.code, e.msg
    except urllib2.URLError, e:
        result = 500, str(e)
    else:
        if self.show_response:
            data = result.read()
        result = 200, 'OK'
    if self.show_response:
        print '-'*75, data, '-'*75
    return result
</t>
<t tx="ekr.20080401090728.1">"""distutils.mwerkscompiler

Contains MWerksCompiler, an implementation of the abstract CCompiler class
for MetroWerks CodeWarrior on the Macintosh. Needs work to support CW on
Windows."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: mwerkscompiler.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os, string
from types import *
from distutils.errors import \
     DistutilsExecError, DistutilsPlatformError, \
     CompileError, LibError, LinkError
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
import distutils.util
import distutils.dir_util
from distutils import log
import mkcwproject

</t>
<t tx="ekr.20080401090728.2">class MWerksCompiler (CCompiler) :
    """Concrete class that implements an interface to MetroWerks CodeWarrior,
       as defined by the CCompiler abstract class."""

    compiler_type = 'mwerks'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']
    _rc_extensions = ['.r']
    _exp_extension = '.exp'

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = (_c_extensions + _cpp_extensions +
                      _rc_extensions)
    res_extension = '.rsrc'
    obj_extension = '.obj' # Not used, really
    static_lib_extension = '.lib'
    shared_lib_extension = '.slb'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = ''


    @others
</t>
<t tx="ekr.20080401090728.3">def __init__ (self,
              verbose=0,
              dry_run=0,
              force=0):

    CCompiler.__init__ (self, verbose, dry_run, force)


</t>
<t tx="ekr.20080401090728.4">def compile (self,
             sources,
             output_dir=None,
             macros=None,
             include_dirs=None,
             debug=0,
             extra_preargs=None,
             extra_postargs=None,
             depends=None):
    (output_dir, macros, include_dirs) = \
       self._fix_compile_args (output_dir, macros, include_dirs)
    self.__sources = sources
    self.__macros = macros
    self.__include_dirs = include_dirs
    # Don't need extra_preargs and extra_postargs for CW
    return []

</t>
<t tx="ekr.20080401090728.5">def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):
    # First fixup.
    (objects, output_dir) = self._fix_object_args (objects, output_dir)
    (libraries, library_dirs, runtime_library_dirs) = \
        self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

    # First examine a couple of options for things that aren't implemented yet
    if not target_desc in (self.SHARED_LIBRARY, self.SHARED_OBJECT):
        raise DistutilsPlatformError, 'Can only make SHARED_LIBRARY or SHARED_OBJECT targets on the Mac'
    if runtime_library_dirs:
        raise DistutilsPlatformError, 'Runtime library dirs not implemented yet'
    if extra_preargs or extra_postargs:
        raise DistutilsPlatformError, 'Runtime library dirs not implemented yet'
    if len(export_symbols) != 1:
        raise DistutilsPlatformError, 'Need exactly one export symbol'
    # Next there are various things for which we need absolute pathnames.
    # This is because we (usually) create the project in a subdirectory of
    # where we are now, and keeping the paths relative is too much work right
    # now.
    sources = map(self._filename_to_abs, self.__sources)
    include_dirs = map(self._filename_to_abs, self.__include_dirs)
    if objects:
        objects = map(self._filename_to_abs, objects)
    else:
        objects = []
    if build_temp:
        build_temp = self._filename_to_abs(build_temp)
    else:
        build_temp = os.curdir()
    if output_dir:
        output_filename = os.path.join(output_dir, output_filename)
    # The output filename needs special handling: splitting it into dir and
    # filename part. Actually I'm not sure this is really needed, but it
    # can't hurt.
    output_filename = self._filename_to_abs(output_filename)
    output_dir, output_filename = os.path.split(output_filename)
    # Now we need the short names of a couple of things for putting them
    # into the project.
    if output_filename[-8:] == '.ppc.slb':
        basename = output_filename[:-8]
    elif output_filename[-11:] == '.carbon.slb':
        basename = output_filename[:-11]
    else:
        basename = os.path.strip(output_filename)[0]
    projectname = basename + '.mcp'
    targetname = basename
    xmlname = basename + '.xml'
    exportname = basename + '.mcp.exp'
    prefixname = 'mwerks_%s_config.h'%basename
    # Create the directories we need
    distutils.dir_util.mkpath(build_temp, dry_run=self.dry_run)
    distutils.dir_util.mkpath(output_dir, dry_run=self.dry_run)
    # And on to filling in the parameters for the project builder
    settings = {}
    settings['mac_exportname'] = exportname
    settings['mac_outputdir'] = output_dir
    settings['mac_dllname'] = output_filename
    settings['mac_targetname'] = targetname
    settings['sysprefix'] = sys.prefix
    settings['mac_sysprefixtype'] = 'Absolute'
    sourcefilenames = []
    sourcefiledirs = []
    for filename in sources + objects:
        dirname, filename = os.path.split(filename)
        sourcefilenames.append(filename)
        if not dirname in sourcefiledirs:
            sourcefiledirs.append(dirname)
    settings['sources'] = sourcefilenames
    settings['libraries'] = libraries
    settings['extrasearchdirs'] = sourcefiledirs + include_dirs + library_dirs
    if self.dry_run:
        print 'CALLING LINKER IN', os.getcwd()
        for key, value in settings.items():
            print '%20.20s %s'%(key, value)
        return
    # Build the export file
    exportfilename = os.path.join(build_temp, exportname)
    log.debug("\tCreate export file %s", exportfilename)
    fp = open(exportfilename, 'w')
    fp.write('%s\n'%export_symbols[0])
    fp.close()
    # Generate the prefix file, if needed, and put it in the settings
    if self.__macros:
        prefixfilename = os.path.join(os.getcwd(), os.path.join(build_temp, prefixname))
        fp = open(prefixfilename, 'w')
        fp.write('#include "mwerks_shcarbon_config.h"\n')
        for name, value in self.__macros:
            if value is None:
                fp.write('#define %s\n'%name)
            else:
                fp.write('#define %s %s\n'%(name, value))
        fp.close()
        settings['prefixname'] = prefixname

    # Build the XML file. We need the full pathname (only lateron, really)
    # because we pass this pathname to CodeWarrior in an AppleEvent, and CW
    # doesn't have a clue about our working directory.
    xmlfilename = os.path.join(os.getcwd(), os.path.join(build_temp, xmlname))
    log.debug("\tCreate XML file %s", xmlfilename)
    xmlbuilder = mkcwproject.cwxmlgen.ProjectBuilder(settings)
    xmlbuilder.generate()
    xmldata = settings['tmp_projectxmldata']
    fp = open(xmlfilename, 'w')
    fp.write(xmldata)
    fp.close()
    # Generate the project. Again a full pathname.
    projectfilename = os.path.join(os.getcwd(), os.path.join(build_temp, projectname))
    log.debug('\tCreate project file %s', projectfilename)
    mkcwproject.makeproject(xmlfilename, projectfilename)
    # And build it
    log.debug('\tBuild project')
    mkcwproject.buildproject(projectfilename)

</t>
<t tx="ekr.20080401090728.6">def _filename_to_abs(self, filename):
    # Some filenames seem to be unix-like. Convert to Mac names.
##        if '/' in filename and ':' in filename:
##           raise DistutilsPlatformError, 'Filename may be Unix or Mac style: %s'%filename
##        if '/' in filename:
##           filename = macurl2path(filename)
    filename = distutils.util.convert_path(filename)
    if not os.path.isabs(filename):
        curdir = os.getcwd()
        filename = os.path.join(curdir, filename)
    # Finally remove .. components
    components = string.split(filename, ':')
    for i in range(1, len(components)):
        if components[i] == '..':
            components[i] = ''
    return string.join(components, ':')

</t>
<t tx="ekr.20080401090728.7">def library_dir_option (self, dir):
    """Return the compiler option to add 'dir' to the list of
    directories searched for libraries.
    """
    return # XXXX Not correct...

</t>
<t tx="ekr.20080401090728.8">def runtime_library_dir_option (self, dir):
    """Return the compiler option to add 'dir' to the list of
    directories searched for runtime libraries.
    """
    # Nothing needed or Mwerks/Mac.
    return

</t>
<t tx="ekr.20080401090728.9">def library_option (self, lib):
    """Return the compiler option to add 'dir' to the list of libraries
    linked into the shared library or executable.
    """
    return

</t>
<t tx="ekr.20080401090728.10">def find_library_file (self, dirs, lib, debug=0):
    """Search the specified list of directories for a static or shared
    library file 'lib' and return the full path to that file.  If
    'debug' true, look for a debugging version (if that makes sense on
    the current platform).  Return None if 'lib' wasn't found in any of
    the specified directories.
    """
    return 0
</t>
<t tx="ekr.20080401090728.11">"""distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: bdist.py 37828 2004-11-10 22:23:15Z loewis $"

import os, string
from types import *
from distutils.core import Command
from distutils.errors import *
from distutils.util import get_platform


</t>
<t tx="ekr.20080401090728.12">def show_formats ():
    """Print list of available formats (arguments to "--format" option).
    """
    from distutils.fancy_getopt import FancyGetopt
    formats=[]
    for format in bdist.format_commands:
        formats.append(("formats=" + format, None,
                        bdist.format_command[format][1]))
    pretty_printer = FancyGetopt(formats)
    pretty_printer.print_help("List of available distribution formats:")


</t>
<t tx="ekr.20080401090728.13">class bdist (Command):

    description = "create a built (binary) distribution"

    user_options = [('bdist-base=', 'b',
                     "temporary directory for creating built distributions"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('formats=', None,
                     "formats for distribution (comma-separated list)"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in "
                     "[default: dist]"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                   ]

    boolean_options = ['skip-build']

    help_options = [
        ('help-formats', None,
         "lists available distribution formats", show_formats),
        ]

    # The following commands do not take a format option from bdist
    no_format_option = ('bdist_rpm',
                        #'bdist_sdux', 'bdist_pkgtool'
                        )

    # This won't do in reality: will need to distinguish RPM-ish Linux,
    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.
    default_format = { 'posix': 'gztar',
                       'nt': 'zip',
                       'os2': 'zip', }

    # Establish the preferred order (for the --help-formats option).
    format_commands = ['rpm', 'gztar', 'bztar', 'ztar', 'tar',
                       'wininst', 'zip',
                       #'pkgtool', 'sdux'
                       ]

    # And the real information.
    format_command = { 'rpm':   ('bdist_rpm',  "RPM distribution"),
                       'zip':   ('bdist_dumb', "ZIP file"),
                       'gztar': ('bdist_dumb', "gzip'ed tar file"),
                       'bztar': ('bdist_dumb', "bzip2'ed tar file"),
                       'ztar':  ('bdist_dumb', "compressed tar file"),
                       'tar':   ('bdist_dumb', "tar file"),
                       'wininst': ('bdist_wininst',
                                   "Windows executable installer"),
                       'zip':   ('bdist_dumb', "ZIP file"),
                       #'pkgtool': ('bdist_pkgtool',
                       #            "Solaris pkgtool distribution"),
                       #'sdux':  ('bdist_sdux', "HP-UX swinstall depot"),
                      }


    @others
    # run()

</t>
<t tx="ekr.20080401090728.14">def initialize_options (self):
    self.bdist_base = None
    self.plat_name = None
    self.formats = None
    self.dist_dir = None
    self.skip_build = 0

</t>
<t tx="ekr.20080401090728.15"># initialize_options()


def finalize_options (self):
    # have to finalize 'plat_name' before 'bdist_base'
    if self.plat_name is None:
        self.plat_name = get_platform()

    # 'bdist_base' -- parent of per-built-distribution-format
    # temporary directories (eg. we'll probably have
    # "build/bdist.&lt;plat&gt;/dumb", "build/bdist.&lt;plat&gt;/rpm", etc.)
    if self.bdist_base is None:
        build_base = self.get_finalized_command('build').build_base
        self.bdist_base = os.path.join(build_base,
                                       'bdist.' + self.plat_name)

    self.ensure_string_list('formats')
    if self.formats is None:
        try:
            self.formats = [self.default_format[os.name]]
        except KeyError:
            raise DistutilsPlatformError, \
                  "don't know how to create built distributions " + \
                  "on platform %s" % os.name

    if self.dist_dir is None:
        self.dist_dir = "dist"

</t>
<t tx="ekr.20080401090728.16"># finalize_options()


def run (self):

    # Figure out which sub-commands we need to run.
    commands = []
    for format in self.formats:
        try:
            commands.append(self.format_command[format][0])
        except KeyError:
            raise DistutilsOptionError, "invalid format '%s'" % format

    # Reinitialize and run each command.
    for i in range(len(self.formats)):
        cmd_name = commands[i]
        sub_cmd = self.reinitialize_command(cmd_name)
        if cmd_name not in self.no_format_option:
            sub_cmd.format = self.formats[i]

        # If we're going to need to run this command again, tell it to
        # keep its temporary files around so subsequent runs go faster.
        if cmd_name in commands[i+1:]:
            sub_cmd.keep_temp = 1
        self.run_command(cmd_name)

</t>
<t tx="ekr.20080401090728.17">"""distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: bdist_dumb.py 38697 2005-03-23 18:54:36Z loewis $"

import os
from distutils.core import Command
from distutils.util import get_platform
from distutils.dir_util import create_tree, remove_tree, ensure_relative
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

</t>
<t tx="ekr.20080401090728.18">class bdist_dumb (Command):

    description = "create a \"dumb\" built distribution"

    user_options = [('bdist-dir=', 'd',
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('format=', 'f',
                     "archive format to create (tar, ztar, gztar, zip)"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('relative', None,
                     "build the archive using relative paths"
                     "(default: false)"),
                   ]

    boolean_options = ['keep-temp', 'skip-build', 'relative']

    default_format = { 'posix': 'gztar',
                       'nt': 'zip',
                       'os2': 'zip' }


    @others
    # run()

</t>
<t tx="ekr.20080401090728.19">def initialize_options (self):
    self.bdist_dir = None
    self.plat_name = None
    self.format = None
    self.keep_temp = 0
    self.dist_dir = None
    self.skip_build = 0
    self.relative = 0

</t>
<t tx="ekr.20080401090728.20"># initialize_options()


def finalize_options (self):

    if self.bdist_dir is None:
        bdist_base = self.get_finalized_command('bdist').bdist_base
        self.bdist_dir = os.path.join(bdist_base, 'dumb')

    if self.format is None:
        try:
            self.format = self.default_format[os.name]
        except KeyError:
            raise DistutilsPlatformError, \
                  ("don't know how to create dumb built distributions " +
                   "on platform %s") % os.name

    self.set_undefined_options('bdist',
                               ('dist_dir', 'dist_dir'),
                               ('plat_name', 'plat_name'))

</t>
<t tx="ekr.20080401090728.21"># finalize_options()


def run (self):

    if not self.skip_build:
        self.run_command('build')

    install = self.reinitialize_command('install', reinit_subcommands=1)
    install.root = self.bdist_dir
    install.skip_build = self.skip_build
    install.warn_dir = 0

    log.info("installing to %s" % self.bdist_dir)
    self.run_command('install')

    # And make an archive relative to the root of the
    # pseudo-installation tree.
    archive_basename = "%s.%s" % (self.distribution.get_fullname(),
                                  self.plat_name)

    # OS/2 objects to any ":" characters in a filename (such as when
    # a timestamp is used in a version) so change them to hyphens.
    if os.name == "os2":
        archive_basename = archive_basename.replace(":", "-")

    pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)
    if not self.relative:
        archive_root = self.bdist_dir
    else:
        if (self.distribution.has_ext_modules() and
            (install.install_base != install.install_platbase)):
            raise DistutilsPlatformError, \
                  ("can't make a dumb built distribution where "
                   "base and platbase are different (%s, %s)"
                   % (repr(install.install_base),
                      repr(install.install_platbase)))
        else:
            archive_root = os.path.join(self.bdist_dir,
                               ensure_relative(install.install_base))

    # Make the archive
    filename = self.make_archive(pseudoinstall_root,
                                 self.format, root_dir=archive_root)
    if self.distribution.has_ext_modules():
        pyversion = get_python_version()
    else:
        pyversion = 'any'
    self.distribution.dist_files.append(('bdist_dumb', pyversion,
                                         filename))

    if not self.keep_temp:
        remove_tree(self.bdist_dir, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090728.22">"""distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: bdist_rpm.py 47213 2006-07-03 12:28:58Z martin.v.loewis $"

import sys, os, string
import glob
from types import *
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.util import get_platform
from distutils.file_util import write_file
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

</t>
<t tx="ekr.20080401090728.23">class bdist_rpm (Command):

    description = "create an RPM distribution"

    user_options = [
        ('bdist-base=', None,
         "base directory for creating built distributions"),
        ('rpm-base=', None,
         "base directory for creating RPMs (defaults to \"rpm\" under "
         "--bdist-base; must be specified for RPM 2)"),
        ('dist-dir=', 'd',
         "directory to put final RPM files in "
         "(and .spec files if --spec-only)"),
        ('python=', None,
         "path to Python interpreter to hard-code in the .spec file "
         "(default: \"python\")"),
        ('fix-python', None,
         "hard-code the exact path to the current Python interpreter in "
         "the .spec file"),
        ('spec-only', None,
         "only regenerate spec file"),
        ('source-only', None,
         "only generate source RPM"),
        ('binary-only', None,
         "only generate binary RPM"),
        ('use-bzip2', None,
         "use bzip2 instead of gzip to create source distribution"),

        # More meta-data: too RPM-specific to put in the setup script,
        # but needs to go in the .spec file -- so we make these options
        # to "bdist_rpm".  The idea is that packagers would put this
        # info in setup.cfg, although they are of course free to
        # supply it on the command line.
        ('distribution-name=', None,
         "name of the (Linux) distribution to which this "
         "RPM applies (*not* the name of the module distribution!)"),
        ('group=', None,
         "package classification [default: \"Development/Libraries\"]"),
        ('release=', None,
         "RPM release number"),
        ('serial=', None,
         "RPM serial number"),
        ('vendor=', None,
         "RPM \"vendor\" (eg. \"Joe Blow &lt;joe@example.com&gt;\") "
         "[default: maintainer or author from setup script]"),
        ('packager=', None,
         "RPM packager (eg. \"Jane Doe &lt;jane@example.net&gt;\")"
         "[default: vendor]"),
        ('doc-files=', None,
         "list of documentation files (space or comma-separated)"),
        ('changelog=', None,
         "RPM changelog"),
        ('icon=', None,
         "name of icon file"),
        ('provides=', None,
         "capabilities provided by this package"),
        ('requires=', None,
         "capabilities required by this package"),
        ('conflicts=', None,
         "capabilities which conflict with this package"),
        ('build-requires=', None,
         "capabilities required to build this package"),
        ('obsoletes=', None,
         "capabilities made obsolete by this package"),
        ('no-autoreq', None,
         "do not automatically calculate dependencies"),

        # Actions to take when building RPM
        ('keep-temp', 'k',
         "don't clean up RPM build directory"),
        ('no-keep-temp', None,
         "clean up RPM build directory [default]"),
        ('use-rpm-opt-flags', None,
         "compile with RPM_OPT_FLAGS when building from source RPM"),
        ('no-rpm-opt-flags', None,
         "do not pass any RPM CFLAGS to compiler"),
        ('rpm3-mode', None,
         "RPM 3 compatibility mode (default)"),
        ('rpm2-mode', None,
         "RPM 2 compatibility mode"),

        # Add the hooks necessary for specifying custom scripts
        ('prep-script=', None,
         "Specify a script for the PREP phase of RPM building"),
        ('build-script=', None,
         "Specify a script for the BUILD phase of RPM building"),

        ('pre-install=', None,
         "Specify a script for the pre-INSTALL phase of RPM building"),
        ('install-script=', None,
         "Specify a script for the INSTALL phase of RPM building"),
        ('post-install=', None,
         "Specify a script for the post-INSTALL phase of RPM building"),

        ('pre-uninstall=', None,
         "Specify a script for the pre-UNINSTALL phase of RPM building"),
        ('post-uninstall=', None,
         "Specify a script for the post-UNINSTALL phase of RPM building"),

        ('clean-script=', None,
         "Specify a script for the CLEAN phase of RPM building"),

        ('verify-script=', None,
         "Specify a script for the VERIFY phase of the RPM build"),

        # Allow a packager to explicitly force an architecture
        ('force-arch=', None,
         "Force an architecture onto the RPM build process"),
       ]

    boolean_options = ['keep-temp', 'use-rpm-opt-flags', 'rpm3-mode',
                       'no-autoreq']

    negative_opt = {'no-keep-temp': 'keep-temp',
                    'no-rpm-opt-flags': 'use-rpm-opt-flags',
                    'rpm2-mode': 'rpm3-mode'}


    @others
    # _format_changelog()

</t>
<t tx="ekr.20080401090728.24">def initialize_options (self):
    self.bdist_base = None
    self.rpm_base = None
    self.dist_dir = None
    self.python = None
    self.fix_python = None
    self.spec_only = None
    self.binary_only = None
    self.source_only = None
    self.use_bzip2 = None

    self.distribution_name = None
    self.group = None
    self.release = None
    self.serial = None
    self.vendor = None
    self.packager = None
    self.doc_files = None
    self.changelog = None
    self.icon = None

    self.prep_script = None
    self.build_script = None
    self.install_script = None
    self.clean_script = None
    self.verify_script = None
    self.pre_install = None
    self.post_install = None
    self.pre_uninstall = None
    self.post_uninstall = None
    self.prep = None
    self.provides = None
    self.requires = None
    self.conflicts = None
    self.build_requires = None
    self.obsoletes = None

    self.keep_temp = 0
    self.use_rpm_opt_flags = 1
    self.rpm3_mode = 1
    self.no_autoreq = 0

    self.force_arch = None

</t>
<t tx="ekr.20080401090728.25"># initialize_options()


def finalize_options (self):
    self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))
    if self.rpm_base is None:
        if not self.rpm3_mode:
            raise DistutilsOptionError, \
                  "you must specify --rpm-base in RPM 2 mode"
        self.rpm_base = os.path.join(self.bdist_base, "rpm")

    if self.python is None:
        if self.fix_python:
            self.python = sys.executable
        else:
            self.python = "python"
    elif self.fix_python:
        raise DistutilsOptionError, \
              "--python and --fix-python are mutually exclusive options"

    if os.name != 'posix':
        raise DistutilsPlatformError, \
              ("don't know how to create RPM "
               "distributions on platform %s" % os.name)
    if self.binary_only and self.source_only:
        raise DistutilsOptionError, \
              "cannot supply both '--source-only' and '--binary-only'"

    # don't pass CFLAGS to pure python distributions
    if not self.distribution.has_ext_modules():
        self.use_rpm_opt_flags = 0

    self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))
    self.finalize_package_data()

</t>
<t tx="ekr.20080401090728.26"># finalize_options()

def finalize_package_data (self):
    self.ensure_string('group', "Development/Libraries")
    self.ensure_string('vendor',
                       "%s &lt;%s&gt;" % (self.distribution.get_contact(),
                                    self.distribution.get_contact_email()))
    self.ensure_string('packager')
    self.ensure_string_list('doc_files')
    if type(self.doc_files) is ListType:
        for readme in ('README', 'README.txt'):
            if os.path.exists(readme) and readme not in self.doc_files:
                self.doc_files.append(readme)

    self.ensure_string('release', "1")
    self.ensure_string('serial')   # should it be an int?

    self.ensure_string('distribution_name')

    self.ensure_string('changelog')
      # Format changelog correctly
    self.changelog = self._format_changelog(self.changelog)

    self.ensure_filename('icon')

    self.ensure_filename('prep_script')
    self.ensure_filename('build_script')
    self.ensure_filename('install_script')
    self.ensure_filename('clean_script')
    self.ensure_filename('verify_script')
    self.ensure_filename('pre_install')
    self.ensure_filename('post_install')
    self.ensure_filename('pre_uninstall')
    self.ensure_filename('post_uninstall')

    # XXX don't forget we punted on summaries and descriptions -- they
    # should be handled here eventually!

    # Now *this* is some meta-data that belongs in the setup script...
    self.ensure_string_list('provides')
    self.ensure_string_list('requires')
    self.ensure_string_list('conflicts')
    self.ensure_string_list('build_requires')
    self.ensure_string_list('obsoletes')

    self.ensure_string('force_arch')
</t>
<t tx="ekr.20080401090728.27"># finalize_package_data ()


def run (self):

    if DEBUG:
        print "before _get_package_data():"
        print "vendor =", self.vendor
        print "packager =", self.packager
        print "doc_files =", self.doc_files
        print "changelog =", self.changelog

    # make directories
    if self.spec_only:
        spec_dir = self.dist_dir
        self.mkpath(spec_dir)
    else:
        rpm_dir = {}
        for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):
            rpm_dir[d] = os.path.join(self.rpm_base, d)
            self.mkpath(rpm_dir[d])
        spec_dir = rpm_dir['SPECS']

    # Spec file goes into 'dist_dir' if '--spec-only specified',
    # build/rpm.&lt;plat&gt; otherwise.
    spec_path = os.path.join(spec_dir,
                             "%s.spec" % self.distribution.get_name())
    self.execute(write_file,
                 (spec_path,
                  self._make_spec_file()),
                 "writing '%s'" % spec_path)

    if self.spec_only: # stop if requested
        return

    # Make a source distribution and copy to SOURCES directory with
    # optional icon.
    saved_dist_files = self.distribution.dist_files[:]
    sdist = self.reinitialize_command('sdist')
    if self.use_bzip2:
        sdist.formats = ['bztar']
    else:
        sdist.formats = ['gztar']
    self.run_command('sdist')
    self.distribution.dist_files = saved_dist_files

    source = sdist.get_archive_files()[0]
    source_dir = rpm_dir['SOURCES']
    self.copy_file(source, source_dir)

    if self.icon:
        if os.path.exists(self.icon):
            self.copy_file(self.icon, source_dir)
        else:
            raise DistutilsFileError, \
                  "icon file '%s' does not exist" % self.icon


    # build package
    log.info("building RPMs")
    rpm_cmd = ['rpm']
    if os.path.exists('/usr/bin/rpmbuild') or \
       os.path.exists('/bin/rpmbuild'):
        rpm_cmd = ['rpmbuild']
    if self.source_only: # what kind of RPMs?
        rpm_cmd.append('-bs')
    elif self.binary_only:
        rpm_cmd.append('-bb')
    else:
        rpm_cmd.append('-ba')
    if self.rpm3_mode:
        rpm_cmd.extend(['--define',
                         '_topdir %s' % os.path.abspath(self.rpm_base)])
    if not self.keep_temp:
        rpm_cmd.append('--clean')
    rpm_cmd.append(spec_path)
    self.spawn(rpm_cmd)

    # XXX this is a nasty hack -- we really should have a proper way to
    # find out the names of the RPM files created; also, this assumes
    # that RPM creates exactly one source and one binary RPM.
    if not self.dry_run:
        if not self.binary_only:
            srpms = glob.glob(os.path.join(rpm_dir['SRPMS'], "*.rpm"))
            assert len(srpms) == 1, \
                   "unexpected number of SRPM files found: %s" % srpms
            dist_file = ('bdist_rpm', 'any',
                         self._dist_path(srpms[0]))
            self.distribution.dist_files.append(dist_file)
            self.move_file(srpms[0], self.dist_dir)

        if not self.source_only:
            rpms = glob.glob(os.path.join(rpm_dir['RPMS'], "*/*.rpm"))
            debuginfo = glob.glob(os.path.join(rpm_dir['RPMS'],
                                               "*/*debuginfo*.rpm"))
            if debuginfo:
                rpms.remove(debuginfo[0])
            assert len(rpms) == 1, \
                   "unexpected number of RPM files found: %s" % rpms
            dist_file = ('bdist_rpm', get_python_version(),
                         self._dist_path(rpms[0]))
            self.distribution.dist_files.append(dist_file)
            self.move_file(rpms[0], self.dist_dir)
            if debuginfo:
                dist_file = ('bdist_rpm', get_python_version(),
                             self._dist_path(debuginfo[0]))
                self.move_file(debuginfo[0], self.dist_dir)
</t>
<t tx="ekr.20080401090728.28"># run()

def _dist_path(self, path):
    return os.path.join(self.dist_dir, os.path.basename(path))

</t>
<t tx="ekr.20080401090728.29">def _make_spec_file(self):
    """Generate the text of an RPM spec file and return it as a
    list of strings (one per line).
    """
    # definitions and headers
    spec_file = [
        '%define name ' + self.distribution.get_name(),
        '%define version ' + self.distribution.get_version().replace('-','_'),
        '%define release ' + self.release.replace('-','_'),
        '',
        'Summary: ' + self.distribution.get_description(),
        ]

    # put locale summaries into spec file
    # XXX not supported for now (hard to put a dictionary
    # in a config file -- arg!)
    #for locale in self.summaries.keys():
    #    spec_file.append('Summary(%s): %s' % (locale,
    #                                          self.summaries[locale]))

    spec_file.extend([
        'Name: %{name}',
        'Version: %{version}',
        'Release: %{release}',])

    # XXX yuck! this filename is available from the "sdist" command,
    # but only after it has run: and we create the spec file before
    # running "sdist", in case of --spec-only.
    if self.use_bzip2:
        spec_file.append('Source0: %{name}-%{version}.tar.bz2')
    else:
        spec_file.append('Source0: %{name}-%{version}.tar.gz')

    spec_file.extend([
        'License: ' + self.distribution.get_license(),
        'Group: ' + self.group,
        'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',
        'Prefix: %{_prefix}', ])

    if not self.force_arch:
        # noarch if no extension modules
        if not self.distribution.has_ext_modules():
            spec_file.append('BuildArch: noarch')
    else:
        spec_file.append( 'BuildArch: %s' % self.force_arch )

    for field in ('Vendor',
                  'Packager',
                  'Provides',
                  'Requires',
                  'Conflicts',
                  'Obsoletes',
                  ):
        val = getattr(self, string.lower(field))
        if type(val) is ListType:
            spec_file.append('%s: %s' % (field, string.join(val)))
        elif val is not None:
            spec_file.append('%s: %s' % (field, val))


    if self.distribution.get_url() != 'UNKNOWN':
        spec_file.append('Url: ' + self.distribution.get_url())

    if self.distribution_name:
        spec_file.append('Distribution: ' + self.distribution_name)

    if self.build_requires:
        spec_file.append('BuildRequires: ' +
                         string.join(self.build_requires))

    if self.icon:
        spec_file.append('Icon: ' + os.path.basename(self.icon))

    if self.no_autoreq:
        spec_file.append('AutoReq: 0')

    spec_file.extend([
        '',
        '%description',
        self.distribution.get_long_description()
        ])

    # put locale descriptions into spec file
    # XXX again, suppressed because config file syntax doesn't
    # easily support this ;-(
    #for locale in self.descriptions.keys():
    #    spec_file.extend([
    #        '',
    #        '%description -l ' + locale,
    #        self.descriptions[locale],
    #        ])

    # rpm scripts
    # figure out default build script
    def_setup_call = "%s %s" % (self.python,os.path.basename(sys.argv[0]))
    def_build = "%s build" % def_setup_call
    if self.use_rpm_opt_flags:
        def_build = 'env CFLAGS="$RPM_OPT_FLAGS" ' + def_build

    # insert contents of files

    # XXX this is kind of misleading: user-supplied options are files
    # that we open and interpolate into the spec file, but the defaults
    # are just text that we drop in as-is.  Hmmm.

    script_options = [
        ('prep', 'prep_script', "%setup"),
        ('build', 'build_script', def_build),
        ('install', 'install_script',
         ("%s install "
          "--root=$RPM_BUILD_ROOT "
          "--record=INSTALLED_FILES") % def_setup_call),
        ('clean', 'clean_script', "rm -rf $RPM_BUILD_ROOT"),
        ('verifyscript', 'verify_script', None),
        ('pre', 'pre_install', None),
        ('post', 'post_install', None),
        ('preun', 'pre_uninstall', None),
        ('postun', 'post_uninstall', None),
    ]

    for (rpm_opt, attr, default) in script_options:
        # Insert contents of file referred to, if no file is referred to
        # use 'default' as contents of script
        val = getattr(self, attr)
        if val or default:
            spec_file.extend([
                '',
                '%' + rpm_opt,])
            if val:
                spec_file.extend(string.split(open(val, 'r').read(), '\n'))
            else:
                spec_file.append(default)


    # files section
    spec_file.extend([
        '',
        '%files -f INSTALLED_FILES',
        '%defattr(-,root,root)',
        ])

    if self.doc_files:
        spec_file.append('%doc ' + string.join(self.doc_files))

    if self.changelog:
        spec_file.extend([
            '',
            '%changelog',])
        spec_file.extend(self.changelog)

    return spec_file

</t>
<t tx="ekr.20080401090728.30"># _make_spec_file ()

def _format_changelog(self, changelog):
    """Format the changelog correctly and convert it to a list of strings
    """
    if not changelog:
        return changelog
    new_changelog = []
    for line in string.split(string.strip(changelog), '\n'):
        line = string.strip(line)
        if line[0] == '*':
            new_changelog.extend(['', line])
        elif line[0] == '-':
            new_changelog.append(line)
        else:
            new_changelog.append('  ' + line)

    # strip trailing newline inserted by first changelog entry
    if not new_changelog[0]:
        del new_changelog[0]

    return new_changelog

</t>
<t tx="ekr.20080401090728.31">"""distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: bdist_wininst.py 38697 2005-03-23 18:54:36Z loewis $"

import sys, os, string
from distutils.core import Command
from distutils.util import get_platform
from distutils.dir_util import create_tree, remove_tree
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

</t>
<t tx="ekr.20080401090728.32">class bdist_wininst (Command):

    description = "create an executable installer for MS Windows"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('bitmap=', 'b',
                     "bitmap to use for the installer instead of python-powered logo"),
                    ('title=', 't',
                     "title to display on the installer background instead of default"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    @others
</t>
<t tx="ekr.20080401090728.33">def initialize_options (self):
    self.bdist_dir = None
    self.keep_temp = 0
    self.no_target_compile = 0
    self.no_target_optimize = 0
    self.target_version = None
    self.dist_dir = None
    self.bitmap = None
    self.title = None
    self.skip_build = 0
    self.install_script = None
    self.pre_install_script = None

</t>
<t tx="ekr.20080401090728.34"># initialize_options()


def finalize_options (self):
    if self.bdist_dir is None:
        bdist_base = self.get_finalized_command('bdist').bdist_base
        self.bdist_dir = os.path.join(bdist_base, 'wininst')
    if not self.target_version:
        self.target_version = ""
    if not self.skip_build and self.distribution.has_ext_modules():
        short_version = get_python_version()
        if self.target_version and self.target_version != short_version:
            raise DistutilsOptionError, \
                  "target version can only be %s, or the '--skip_build'" \
                  " option must be specified" % (short_version,)
        self.target_version = short_version

    self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))

    if self.install_script:
        for script in self.distribution.scripts:
            if self.install_script == os.path.basename(script):
                break
        else:
            raise DistutilsOptionError, \
                  "install_script '%s' not found in scripts" % \
                  self.install_script
</t>
<t tx="ekr.20080401090728.35"># finalize_options()


def run (self):
    if (sys.platform != "win32" and
        (self.distribution.has_ext_modules() or
         self.distribution.has_c_libraries())):
        raise DistutilsPlatformError \
              ("distribution contains extensions and/or C libraries; "
               "must be compiled on a Windows 32 platform")

    if not self.skip_build:
        self.run_command('build')

    install = self.reinitialize_command('install', reinit_subcommands=1)
    install.root = self.bdist_dir
    install.skip_build = self.skip_build
    install.warn_dir = 0

    install_lib = self.reinitialize_command('install_lib')
    # we do not want to include pyc or pyo files
    install_lib.compile = 0
    install_lib.optimize = 0

    if self.distribution.has_ext_modules():
        # If we are building an installer for a Python version other
        # than the one we are currently running, then we need to ensure
        # our build_lib reflects the other Python version rather than ours.
        # Note that for target_version!=sys.version, we must have skipped the
        # build step, so there is no issue with enforcing the build of this
        # version.
        target_version = self.target_version
        if not target_version:
            assert self.skip_build, "Should have already checked this"
            target_version = sys.version[0:3]
        plat_specifier = ".%s-%s" % (get_platform(), target_version)
        build = self.get_finalized_command('build')
        build.build_lib = os.path.join(build.build_base,
                                       'lib' + plat_specifier)

    # Use a custom scheme for the zip-file, because we have to decide
    # at installation time which scheme to use.
    for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):
        value = string.upper(key)
        if key == 'headers':
            value = value + '/Include/$dist_name'
        setattr(install,
                'install_' + key,
                value)

    log.info("installing to %s", self.bdist_dir)
    install.ensure_finalized()

    # avoid warning of 'install_lib' about installing
    # into a directory not in sys.path
    sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

    install.run()

    del sys.path[0]

    # And make an archive relative to the root of the
    # pseudo-installation tree.
    from tempfile import mktemp
    archive_basename = mktemp()
    fullname = self.distribution.get_fullname()
    arcname = self.make_archive(archive_basename, "zip",
                                root_dir=self.bdist_dir)
    # create an exe containing the zip-file
    self.create_exe(arcname, fullname, self.bitmap)
    if self.distribution.has_ext_modules():
        pyversion = get_python_version()
    else:
        pyversion = 'any'
    self.distribution.dist_files.append(('bdist_wininst', pyversion,
                                         self.get_installer_filename(fullname)))
    # remove the zip-file again
    log.debug("removing temporary file '%s'", arcname)
    os.remove(arcname)

    if not self.keep_temp:
        remove_tree(self.bdist_dir, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090728.36"># run()

def get_inidata (self):
    # Return data describing the installation.

    lines = []
    metadata = self.distribution.metadata

    # Write the [metadata] section.
    lines.append("[metadata]")

    # 'info' will be displayed in the installer's dialog box,
    # describing the items to be installed.
    info = (metadata.long_description or '') + '\n'

    # Escape newline characters
    def escape(s):
        return string.replace(s, "\n", "\\n")

    for name in ["author", "author_email", "description", "maintainer",
                 "maintainer_email", "name", "url", "version"]:
        data = getattr(metadata, name, "")
        if data:
            info = info + ("\n    %s: %s" % \
                           (string.capitalize(name), escape(data)))
            lines.append("%s=%s" % (name, escape(data)))

    # The [setup] section contains entries controlling
    # the installer runtime.
    lines.append("\n[Setup]")
    if self.install_script:
        lines.append("install_script=%s" % self.install_script)
    lines.append("info=%s" % escape(info))
    lines.append("target_compile=%d" % (not self.no_target_compile))
    lines.append("target_optimize=%d" % (not self.no_target_optimize))
    if self.target_version:
        lines.append("target_version=%s" % self.target_version)

    title = self.title or self.distribution.get_fullname()
    lines.append("title=%s" % escape(title))
    import time
    import distutils
    build_info = "Built %s with distutils-%s" % \
                 (time.ctime(time.time()), distutils.__version__)
    lines.append("build_info=%s" % build_info)
    return string.join(lines, "\n")

</t>
<t tx="ekr.20080401090728.37"># get_inidata()

def create_exe (self, arcname, fullname, bitmap=None):
    import struct

    self.mkpath(self.dist_dir)

    cfgdata = self.get_inidata()

    installer_name = self.get_installer_filename(fullname)
    self.announce("creating %s" % installer_name)

    if bitmap:
        bitmapdata = open(bitmap, "rb").read()
        bitmaplen = len(bitmapdata)
    else:
        bitmaplen = 0

    file = open(installer_name, "wb")
    file.write(self.get_exe_bytes())
    if bitmap:
        file.write(bitmapdata)

    # Convert cfgdata from unicode to ascii, mbcs encoded
    try:
        unicode
    except NameError:
        pass
    else:
        if isinstance(cfgdata, unicode):
            cfgdata = cfgdata.encode("mbcs")

    # Append the pre-install script
    cfgdata = cfgdata + "\0"
    if self.pre_install_script:
        script_data = open(self.pre_install_script, "r").read()
        cfgdata = cfgdata + script_data + "\n\0"
    else:
        # empty pre-install script
        cfgdata = cfgdata + "\0"
    file.write(cfgdata)

    # The 'magic number' 0x1234567B is used to make sure that the
    # binary layout of 'cfgdata' is what the wininst.exe binary
    # expects.  If the layout changes, increment that number, make
    # the corresponding changes to the wininst.exe sources, and
    # recompile them.
    header = struct.pack("&lt;iii",
                         0x1234567B,       # tag
                         len(cfgdata),     # length
                         bitmaplen,        # number of bytes in bitmap
                         )
    file.write(header)
    file.write(open(arcname, "rb").read())

</t>
<t tx="ekr.20080401090728.38"># create_exe()

def get_installer_filename(self, fullname):
    # Factored out to allow overriding in subclasses
    if self.target_version:
        # if we create an installer for a specific python version,
        # it's better to include this in the name
        installer_name = os.path.join(self.dist_dir,
                                      "%s.win32-py%s.exe" %
                                       (fullname, self.target_version))
    else:
        installer_name = os.path.join(self.dist_dir,
                                      "%s.win32.exe" % fullname)
    return installer_name
</t>
<t tx="ekr.20080401090728.39"># get_installer_filename()

def get_exe_bytes (self):
    from distutils.msvccompiler import get_build_version
    # If a target-version other than the current version has been
    # specified, then using the MSVC version from *this* build is no good.
    # Without actually finding and executing the target version and parsing
    # its sys.version, we just hard-code our knowledge of old versions.
    # NOTE: Possible alternative is to allow "--target-version" to
    # specify a Python executable rather than a simple version string.
    # We can then execute this program to obtain any info we need, such
    # as the real sys.version string for the build.
    cur_version = get_python_version()
    if self.target_version and self.target_version != cur_version:
        # If the target version is *later* than us, then we assume they
        # use what we use
        # string compares seem wrong, but are what sysconfig.py itself uses
        if self.target_version &gt; cur_version:
            bv = get_build_version()
        else:
            if self.target_version &lt; "2.4":
                bv = "6"
            else:
                bv = "7.1"
    else:
        # for current version - use authoritative check.
        bv = get_build_version()

    # wininst-x.y.exe is in the same directory as this file
    directory = os.path.dirname(__file__)
    # we must use a wininst-x.y.exe built with the same C compiler
    # used for python.  XXX What about mingw, borland, and so on?
    filename = os.path.join(directory, "wininst-%s.exe" % bv)
    return open(filename, "rb").read()
</t>
<t tx="ekr.20080401090728.40">"""distutils.command.build

Implements the Distutils 'build' command."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: build.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os
from distutils.core import Command
from distutils.util import get_platform


</t>
<t tx="ekr.20080401090728.41">def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


</t>
<t tx="ekr.20080401090728.42">class build (Command):

    description = "build everything needed to install"

    user_options = [
        ('build-base=', 'b',
         "base directory for build library"),
        ('build-purelib=', None,
         "build directory for platform-neutral distributions"),
        ('build-platlib=', None,
         "build directory for platform-specific distributions"),
        ('build-lib=', None,
         "build directory for all distribution (defaults to either " +
         "build-purelib or build-platlib"),
        ('build-scripts=', None,
         "build directory for scripts"),
        ('build-temp=', 't',
         "temporary build directory"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('debug', 'g',
         "compile extensions and libraries with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('executable=', 'e',
         "specify final destination interpreter path (build.py)"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    @others
    sub_commands = [('build_py',      has_pure_modules),
                    ('build_clib',    has_c_libraries),
                    ('build_ext',     has_ext_modules),
                    ('build_scripts', has_scripts),
                   ]

</t>
<t tx="ekr.20080401090728.43">def initialize_options (self):
    self.build_base = 'build'
    # these are decided only after 'build_base' has its final value
    # (unless overridden by the user or client)
    self.build_purelib = None
    self.build_platlib = None
    self.build_lib = None
    self.build_temp = None
    self.build_scripts = None
    self.compiler = None
    self.debug = None
    self.force = 0
    self.executable = None

</t>
<t tx="ekr.20080401090728.44">def finalize_options (self):

    plat_specifier = ".%s-%s" % (get_platform(), sys.version[0:3])

    # 'build_purelib' and 'build_platlib' just default to 'lib' and
    # 'lib.&lt;plat&gt;' under the base build directory.  We only use one of
    # them for a given distribution, though --
    if self.build_purelib is None:
        self.build_purelib = os.path.join(self.build_base, 'lib')
    if self.build_platlib is None:
        self.build_platlib = os.path.join(self.build_base,
                                          'lib' + plat_specifier)

    # 'build_lib' is the actual directory that we will use for this
    # particular module distribution -- if user didn't supply it, pick
    # one of 'build_purelib' or 'build_platlib'.
    if self.build_lib is None:
        if self.distribution.ext_modules:
            self.build_lib = self.build_platlib
        else:
            self.build_lib = self.build_purelib

    # 'build_temp' -- temporary directory for compiler turds,
    # "build/temp.&lt;plat&gt;"
    if self.build_temp is None:
        self.build_temp = os.path.join(self.build_base,
                                       'temp' + plat_specifier)
    if self.build_scripts is None:
        self.build_scripts = os.path.join(self.build_base,
                                          'scripts-' + sys.version[0:3])

    if self.executable is None:
        self.executable = os.path.normpath(sys.executable)
</t>
<t tx="ekr.20080401090728.45"># finalize_options ()


def run (self):

    # Run all relevant sub-commands.  This will be some subset of:
    #  - build_py      - pure Python modules
    #  - build_clib    - standalone C libraries
    #  - build_ext     - Python extensions
    #  - build_scripts - (Python) scripts
    for cmd_name in self.get_sub_commands():
        self.run_command(cmd_name)


</t>
<t tx="ekr.20080401090728.46"># -- Predicates for the sub-command list ---------------------------

def has_pure_modules (self):
    return self.distribution.has_pure_modules()

</t>
<t tx="ekr.20080401090728.47">def has_c_libraries (self):
    return self.distribution.has_c_libraries()

</t>
<t tx="ekr.20080401090728.48">def has_ext_modules (self):
    return self.distribution.has_ext_modules()

</t>
<t tx="ekr.20080401090728.49">def has_scripts (self):
    return self.distribution.has_scripts()


</t>
<t tx="ekr.20080401090728.50">"""distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: build_clib.py 37828 2004-11-10 22:23:15Z loewis $"


# XXX this module has *lots* of code ripped-off quite transparently from
# build_ext.py -- not surprisingly really, as the work required to build
# a static library from a collection of C source files is not really all
# that different from what's required to build a shared object file from
# a collection of C source files.  Nevertheless, I haven't done the
# necessary refactoring to account for the overlap in code between the
# two modules, mainly because a number of subtle details changed in the
# cut 'n paste.  Sigh.

import os, string
from types import *
from distutils.core import Command
from distutils.errors import *
from distutils.sysconfig import customize_compiler
from distutils import log

</t>
<t tx="ekr.20080401090728.51">def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


</t>
<t tx="ekr.20080401090728.52">class build_clib (Command):

    description = "build C/C++ libraries used by Python extensions"

    user_options = [
        ('build-clib', 'b',
         "directory to build C/C++ libraries to"),
        ('build-temp', 't',
         "directory to put temporary build by-products"),
        ('debug', 'g',
         "compile with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ]

    boolean_options = ['debug', 'force']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    @others
    # build_libraries ()

</t>
<t tx="ekr.20080401090728.53">def initialize_options (self):
    self.build_clib = None
    self.build_temp = None

    # List of libraries to build
    self.libraries = None

    # Compilation options for all libraries
    self.include_dirs = None
    self.define = None
    self.undef = None
    self.debug = None
    self.force = 0
    self.compiler = None

</t>
<t tx="ekr.20080401090728.54"># initialize_options()


def finalize_options (self):

    # This might be confusing: both build-clib and build-temp default
    # to build-temp as defined by the "build" command.  This is because
    # I think that C libraries are really just temporary build
    # by-products, at least from the point of view of building Python
    # extensions -- but I want to keep my options open.
    self.set_undefined_options('build',
                               ('build_temp', 'build_clib'),
                               ('build_temp', 'build_temp'),
                               ('compiler', 'compiler'),
                               ('debug', 'debug'),
                               ('force', 'force'))

    self.libraries = self.distribution.libraries
    if self.libraries:
        self.check_library_list(self.libraries)

    if self.include_dirs is None:
        self.include_dirs = self.distribution.include_dirs or []
    if type(self.include_dirs) is StringType:
        self.include_dirs = string.split(self.include_dirs,
                                         os.pathsep)

    # XXX same as for build_ext -- what about 'self.define' and
    # 'self.undef' ?

</t>
<t tx="ekr.20080401090728.55"># finalize_options()


def run (self):

    if not self.libraries:
        return

    # Yech -- this is cut 'n pasted from build_ext.py!
    from distutils.ccompiler import new_compiler
    self.compiler = new_compiler(compiler=self.compiler,
                                 dry_run=self.dry_run,
                                 force=self.force)
    customize_compiler(self.compiler)

    if self.include_dirs is not None:
        self.compiler.set_include_dirs(self.include_dirs)
    if self.define is not None:
        # 'define' option is a list of (name,value) tuples
        for (name,value) in self.define:
            self.compiler.define_macro(name, value)
    if self.undef is not None:
        for macro in self.undef:
            self.compiler.undefine_macro(macro)

    self.build_libraries(self.libraries)

</t>
<t tx="ekr.20080401090728.56"># run()


def check_library_list (self, libraries):
    """Ensure that the list of libraries (presumably provided as a
       command option 'libraries') is valid, i.e. it is a list of
       2-tuples, where the tuples are (library_name, build_info_dict).
       Raise DistutilsSetupError if the structure is invalid anywhere;
       just returns otherwise."""

    # Yechh, blecch, ackk: this is ripped straight out of build_ext.py,
    # with only names changed to protect the innocent!

    if type(libraries) is not ListType:
        raise DistutilsSetupError, \
              "'libraries' option must be a list of tuples"

    for lib in libraries:
        if type(lib) is not TupleType and len(lib) != 2:
            raise DistutilsSetupError, \
                  "each element of 'libraries' must a 2-tuple"

        if type(lib[0]) is not StringType:
            raise DistutilsSetupError, \
                  "first element of each tuple in 'libraries' " + \
                  "must be a string (the library name)"
        if '/' in lib[0] or (os.sep != '/' and os.sep in lib[0]):
            raise DistutilsSetupError, \
                  ("bad library name '%s': " +
                   "may not contain directory separators") % \
                  lib[0]

        if type(lib[1]) is not DictionaryType:
            raise DistutilsSetupError, \
                  "second element of each tuple in 'libraries' " + \
                  "must be a dictionary (build info)"
    # for lib

</t>
<t tx="ekr.20080401090728.57"># check_library_list ()


def get_library_names (self):
    # Assume the library list is valid -- 'check_library_list()' is
    # called from 'finalize_options()', so it should be!

    if not self.libraries:
        return None

    lib_names = []
    for (lib_name, build_info) in self.libraries:
        lib_names.append(lib_name)
    return lib_names

</t>
<t tx="ekr.20080401090728.58"># get_library_names ()


def get_source_files (self):
    self.check_library_list(self.libraries)
    filenames = []
    for (lib_name, build_info) in self.libraries:
        sources = build_info.get('sources')
        if (sources is None or
            type(sources) not in (ListType, TupleType) ):
            raise DistutilsSetupError, \
                  ("in 'libraries' option (library '%s'), "
                   "'sources' must be present and must be "
                   "a list of source filenames") % lib_name

        filenames.extend(sources)

    return filenames
</t>
<t tx="ekr.20080401090728.59"># get_source_files ()


def build_libraries (self, libraries):

    for (lib_name, build_info) in libraries:
        sources = build_info.get('sources')
        if sources is None or type(sources) not in (ListType, TupleType):
            raise DistutilsSetupError, \
                  ("in 'libraries' option (library '%s'), " +
                   "'sources' must be present and must be " +
                   "a list of source filenames") % lib_name
        sources = list(sources)

        log.info("building '%s' library", lib_name)

        # First, compile the source code to object files in the library
        # directory.  (This should probably change to putting object
        # files in a temporary build directory.)
        macros = build_info.get('macros')
        include_dirs = build_info.get('include_dirs')
        objects = self.compiler.compile(sources,
                                        output_dir=self.build_temp,
                                        macros=macros,
                                        include_dirs=include_dirs,
                                        debug=self.debug)

        # Now "link" the object files together into a static library.
        # (On Unix at least, this isn't really linking -- it just
        # builds an archive.  Whatever.)
        self.compiler.create_static_lib(objects, lib_name,
                                        output_dir=self.build_clib,
                                        debug=self.debug)

    # for libraries

</t>
<t tx="ekr.20080401090728.60">"""distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: build_ext.py 46103 2006-05-23 11:47:16Z ronald.oussoren $"

import sys, os, string, re
from types import *
from distutils.core import Command
from distutils.errors import *
from distutils.sysconfig import customize_compiler, get_python_version
from distutils.dep_util import newer_group
from distutils.extension import Extension
from distutils import log

# An extension name is just a dot-separated list of Python NAMEs (ie.
# the same as a fully-qualified module name).
extension_name_re = re.compile \
    (r'^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$')


</t>
<t tx="ekr.20080401090728.61">def show_compilers ():
    from distutils.ccompiler import show_compilers
    show_compilers()


</t>
<t tx="ekr.20080401090728.62">class build_ext (Command):

    description = "build C/C++ extensions (compile/link to build directory)"

    # XXX thoughts on how to deal with complex command-line options like
    # these, i.e. how to make it so fancy_getopt can suck them off the
    # command line and make it look like setup.py defined the appropriate
    # lists of tuples of what-have-you.
    #   - each command needs a callback to process its command-line options
    #   - Command.__init__() needs access to its share of the whole
    #     command line (must ultimately come from
    #     Distribution.parse_command_line())
    #   - it then calls the current command class' option-parsing
    #     callback to deal with weird options like -D, which have to
    #     parse the option text and churn out some custom data
    #     structure
    #   - that data structure (in this case, a list of 2-tuples)
    #     will then be present in the command object by the time
    #     we get to finalize_options() (i.e. the constructor
    #     takes care of both command-line and client options
    #     in between initialize_options() and finalize_options())

    sep_by = " (separated by '%s')" % os.pathsep
    user_options = [
        ('build-lib=', 'b',
         "directory for compiled extension modules"),
        ('build-temp=', 't',
         "directory for temporary files (build by-products)"),
        ('inplace', 'i',
         "ignore build-lib and put compiled extensions into the source " +
         "directory alongside your pure Python modules"),
        ('include-dirs=', 'I',
         "list of directories to search for header files" + sep_by),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries" + sep_by),
        ('rpath=', 'R',
         "directories to search for shared C libraries at runtime"),
        ('link-objects=', 'O',
         "extra explicit link objects to include in the link"),
        ('debug', 'g',
         "compile/link with debugging information"),
        ('force', 'f',
         "forcibly build everything (ignore file timestamps)"),
        ('compiler=', 'c',
         "specify the compiler type"),
        ('swig-cpp', None,
         "make SWIG create C++ files (default is C)"),
        ('swig-opts=', None,
         "list of SWIG command line options"),
        ('swig=', None,
         "path to the SWIG executable"),
        ]

    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp']

    help_options = [
        ('help-compiler', None,
         "list available compilers", show_compilers),
        ]

    @others
</t>
<t tx="ekr.20080401090728.63">def initialize_options (self):
    self.extensions = None
    self.build_lib = None
    self.build_temp = None
    self.inplace = 0
    self.package = None

    self.include_dirs = None
    self.define = None
    self.undef = None
    self.libraries = None
    self.library_dirs = None
    self.rpath = None
    self.link_objects = None
    self.debug = None
    self.force = None
    self.compiler = None
    self.swig = None
    self.swig_cpp = None
    self.swig_opts = None

</t>
<t tx="ekr.20080401090728.64">def finalize_options (self):
    from distutils import sysconfig

    self.set_undefined_options('build',
                               ('build_lib', 'build_lib'),
                               ('build_temp', 'build_temp'),
                               ('compiler', 'compiler'),
                               ('debug', 'debug'),
                               ('force', 'force'))

    if self.package is None:
        self.package = self.distribution.ext_package

    self.extensions = self.distribution.ext_modules


    # Make sure Python's include directories (for Python.h, pyconfig.h,
    # etc.) are in the include search path.
    py_include = sysconfig.get_python_inc()
    plat_py_include = sysconfig.get_python_inc(plat_specific=1)
    if self.include_dirs is None:
        self.include_dirs = self.distribution.include_dirs or []
    if type(self.include_dirs) is StringType:
        self.include_dirs = string.split(self.include_dirs, os.pathsep)

    # Put the Python "system" include dir at the end, so that
    # any local include dirs take precedence.
    self.include_dirs.append(py_include)
    if plat_py_include != py_include:
        self.include_dirs.append(plat_py_include)

    if type(self.libraries) is StringType:
        self.libraries = [self.libraries]

    # Life is easier if we're not forever checking for None, so
    # simplify these options to empty lists if unset
    if self.libraries is None:
        self.libraries = []
    if self.library_dirs is None:
        self.library_dirs = []
    elif type(self.library_dirs) is StringType:
        self.library_dirs = string.split(self.library_dirs, os.pathsep)

    if self.rpath is None:
        self.rpath = []
    elif type(self.rpath) is StringType:
        self.rpath = string.split(self.rpath, os.pathsep)

    # for extensions under windows use different directories
    # for Release and Debug builds.
    # also Python's library directory must be appended to library_dirs
    if os.name == 'nt':
        self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))
        if self.debug:
            self.build_temp = os.path.join(self.build_temp, "Debug")
        else:
            self.build_temp = os.path.join(self.build_temp, "Release")

        # Append the source distribution include and library directories,
        # this allows distutils on windows to work in the source tree
        self.include_dirs.append(os.path.join(sys.exec_prefix, 'PC'))
        self.library_dirs.append(os.path.join(sys.exec_prefix, 'PCBuild'))

    # OS/2 (EMX) doesn't support Debug vs Release builds, but has the
    # import libraries in its "Config" subdirectory
    if os.name == 'os2':
        self.library_dirs.append(os.path.join(sys.exec_prefix, 'Config'))

    # for extensions under Cygwin and AtheOS Python's library directory must be
    # appended to library_dirs
    if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos' or \
           (sys.platform.startswith('linux') and
            sysconfig.get_config_var('Py_ENABLE_SHARED')):
        if string.find(sys.executable, sys.exec_prefix) != -1:
            # building third party extensions
            self.library_dirs.append(os.path.join(sys.prefix, "lib",
                                                  "python" + get_python_version(),
                                                  "config"))
        else:
            # building python standard extensions
            self.library_dirs.append('.')

    # The argument parsing will result in self.define being a string, but
    # it has to be a list of 2-tuples.  All the preprocessor symbols
    # specified by the 'define' option will be set to '1'.  Multiple
    # symbols can be separated with commas.

    if self.define:
        defines = string.split(self.define, ',')
        self.define = map(lambda symbol: (symbol, '1'), defines)

    # The option for macros to undefine is also a string from the
    # option parsing, but has to be a list.  Multiple symbols can also
    # be separated with commas here.
    if self.undef:
        self.undef = string.split(self.undef, ',')

    if self.swig_opts is None:
        self.swig_opts = []
    else:
        self.swig_opts = self.swig_opts.split(' ')

</t>
<t tx="ekr.20080401090728.65">def run (self):

    from distutils.ccompiler import new_compiler

    # 'self.extensions', as supplied by setup.py, is a list of
    # Extension instances.  See the documentation for Extension (in
    # distutils.extension) for details.

    # For backwards compatibility with Distutils 0.8.2 and earlier, we
    # also allow the 'extensions' list to be a list of tuples:
    #    (ext_name, build_info)
    # where build_info is a dictionary containing everything that
    # Extension instances do except the name, with a few things being
    # differently named.  We convert these 2-tuples to Extension
    # instances as needed.

    if not self.extensions:
        return

    # If we were asked to build any C/C++ libraries, make sure that the
    # directory where we put them is in the library search path for
    # linking extensions.
    if self.distribution.has_c_libraries():
        build_clib = self.get_finalized_command('build_clib')
        self.libraries.extend(build_clib.get_library_names() or [])
        self.library_dirs.append(build_clib.build_clib)

    # Setup the CCompiler object that we'll use to do all the
    # compiling and linking
    self.compiler = new_compiler(compiler=self.compiler,
                                 verbose=self.verbose,
                                 dry_run=self.dry_run,
                                 force=self.force)
    customize_compiler(self.compiler)

    # And make sure that any compile/link-related options (which might
    # come from the command-line or from the setup script) are set in
    # that CCompiler object -- that way, they automatically apply to
    # all compiling and linking done here.
    if self.include_dirs is not None:
        self.compiler.set_include_dirs(self.include_dirs)
    if self.define is not None:
        # 'define' option is a list of (name,value) tuples
        for (name,value) in self.define:
            self.compiler.define_macro(name, value)
    if self.undef is not None:
        for macro in self.undef:
            self.compiler.undefine_macro(macro)
    if self.libraries is not None:
        self.compiler.set_libraries(self.libraries)
    if self.library_dirs is not None:
        self.compiler.set_library_dirs(self.library_dirs)
    if self.rpath is not None:
        self.compiler.set_runtime_library_dirs(self.rpath)
    if self.link_objects is not None:
        self.compiler.set_link_objects(self.link_objects)

    # Now actually compile and link everything.
    self.build_extensions()

</t>
<t tx="ekr.20080401090728.66"># run ()


def check_extensions_list (self, extensions):
    """Ensure that the list of extensions (presumably provided as a
    command option 'extensions') is valid, i.e. it is a list of
    Extension objects.  We also support the old-style list of 2-tuples,
    where the tuples are (ext_name, build_info), which are converted to
    Extension instances here.

    Raise DistutilsSetupError if the structure is invalid anywhere;
    just returns otherwise.
    """
    if type(extensions) is not ListType:
        raise DistutilsSetupError, \
              "'ext_modules' option must be a list of Extension instances"

    for i in range(len(extensions)):
        ext = extensions[i]
        if isinstance(ext, Extension):
            continue                # OK! (assume type-checking done
                                    # by Extension constructor)

        (ext_name, build_info) = ext
        log.warn(("old-style (ext_name, build_info) tuple found in "
                  "ext_modules for extension '%s'"
                  "-- please convert to Extension instance" % ext_name))
        if type(ext) is not TupleType and len(ext) != 2:
            raise DistutilsSetupError, \
                  ("each element of 'ext_modules' option must be an "
                   "Extension instance or 2-tuple")

        if not (type(ext_name) is StringType and
                extension_name_re.match(ext_name)):
            raise DistutilsSetupError, \
                  ("first element of each tuple in 'ext_modules' "
                   "must be the extension name (a string)")

        if type(build_info) is not DictionaryType:
            raise DistutilsSetupError, \
                  ("second element of each tuple in 'ext_modules' "
                   "must be a dictionary (build info)")

        # OK, the (ext_name, build_info) dict is type-safe: convert it
        # to an Extension instance.
        ext = Extension(ext_name, build_info['sources'])

        # Easy stuff: one-to-one mapping from dict elements to
        # instance attributes.
        for key in ('include_dirs',
                    'library_dirs',
                    'libraries',
                    'extra_objects',
                    'extra_compile_args',
                    'extra_link_args'):
            val = build_info.get(key)
            if val is not None:
                setattr(ext, key, val)

        # Medium-easy stuff: same syntax/semantics, different names.
        ext.runtime_library_dirs = build_info.get('rpath')
        if build_info.has_key('def_file'):
            log.warn("'def_file' element of build info dict "
                     "no longer supported")

        # Non-trivial stuff: 'macros' split into 'define_macros'
        # and 'undef_macros'.
        macros = build_info.get('macros')
        if macros:
            ext.define_macros = []
            ext.undef_macros = []
            for macro in macros:
                if not (type(macro) is TupleType and
                        1 &lt;= len(macro) &lt;= 2):
                    raise DistutilsSetupError, \
                          ("'macros' element of build info dict "
                           "must be 1- or 2-tuple")
                if len(macro) == 1:
                    ext.undef_macros.append(macro[0])
                elif len(macro) == 2:
                    ext.define_macros.append(macro)

        extensions[i] = ext

    # for extensions

</t>
<t tx="ekr.20080401090728.67"># check_extensions_list ()


def get_source_files (self):
    self.check_extensions_list(self.extensions)
    filenames = []

    # Wouldn't it be neat if we knew the names of header files too...
    for ext in self.extensions:
        filenames.extend(ext.sources)

    return filenames


</t>
<t tx="ekr.20080401090728.68">def get_outputs (self):

    # Sanity check the 'extensions' list -- can't assume this is being
    # done in the same run as a 'build_extensions()' call (in fact, we
    # can probably assume that it *isn't*!).
    self.check_extensions_list(self.extensions)

    # And build the list of output (built) filenames.  Note that this
    # ignores the 'inplace' flag, and assumes everything goes in the
    # "build" tree.
    outputs = []
    for ext in self.extensions:
        fullname = self.get_ext_fullname(ext.name)
        outputs.append(os.path.join(self.build_lib,
                                    self.get_ext_filename(fullname)))
    return outputs

</t>
<t tx="ekr.20080401090728.69"># get_outputs ()

def build_extensions(self):
    # First, sanity-check the 'extensions' list
    self.check_extensions_list(self.extensions)

    for ext in self.extensions:
        self.build_extension(ext)

</t>
<t tx="ekr.20080401090728.70">def build_extension(self, ext):
    sources = ext.sources
    if sources is None or type(sources) not in (ListType, TupleType):
        raise DistutilsSetupError, \
              ("in 'ext_modules' option (extension '%s'), " +
               "'sources' must be present and must be " +
               "a list of source filenames") % ext.name
    sources = list(sources)

    fullname = self.get_ext_fullname(ext.name)
    if self.inplace:
        # ignore build-lib -- put the compiled extension into
        # the source tree along with pure Python modules

        modpath = string.split(fullname, '.')
        package = string.join(modpath[0:-1], '.')
        base = modpath[-1]

        build_py = self.get_finalized_command('build_py')
        package_dir = build_py.get_package_dir(package)
        ext_filename = os.path.join(package_dir,
                                    self.get_ext_filename(base))
    else:
        ext_filename = os.path.join(self.build_lib,
                                    self.get_ext_filename(fullname))
    depends = sources + ext.depends
    if not (self.force or newer_group(depends, ext_filename, 'newer')):
        log.debug("skipping '%s' extension (up-to-date)", ext.name)
        return
    else:
        log.info("building '%s' extension", ext.name)

    # First, scan the sources for SWIG definition files (.i), run
    # SWIG on 'em to create .c files, and modify the sources list
    # accordingly.
    sources = self.swig_sources(sources, ext)

    # Next, compile the source code to object files.

    # XXX not honouring 'define_macros' or 'undef_macros' -- the
    # CCompiler API needs to change to accommodate this, and I
    # want to do one thing at a time!

    # Two possible sources for extra compiler arguments:
    #   - 'extra_compile_args' in Extension object
    #   - CFLAGS environment variable (not particularly
    #     elegant, but people seem to expect it and I
    #     guess it's useful)
    # The environment variable should take precedence, and
    # any sensible compiler will give precedence to later
    # command line args.  Hence we combine them in order:
    extra_args = ext.extra_compile_args or []

    macros = ext.define_macros[:]
    for undef in ext.undef_macros:
        macros.append((undef,))

    objects = self.compiler.compile(sources,
                                    output_dir=self.build_temp,
                                    macros=macros,
                                    include_dirs=ext.include_dirs,
                                    debug=self.debug,
                                    extra_postargs=extra_args,
                                    depends=ext.depends)

    # XXX -- this is a Vile HACK!
    #
    # The setup.py script for Python on Unix needs to be able to
    # get this list so it can perform all the clean up needed to
    # avoid keeping object files around when cleaning out a failed
    # build of an extension module.  Since Distutils does not
    # track dependencies, we have to get rid of intermediates to
    # ensure all the intermediates will be properly re-built.
    #
    self._built_objects = objects[:]

    # Now link the object files together into a "shared object" --
    # of course, first we have to figure out all the other things
    # that go into the mix.
    if ext.extra_objects:
        objects.extend(ext.extra_objects)
    extra_args = ext.extra_link_args or []

    # Detect target language, if not provided
    language = ext.language or self.compiler.detect_language(sources)

    self.compiler.link_shared_object(
        objects, ext_filename,
        libraries=self.get_libraries(ext),
        library_dirs=ext.library_dirs,
        runtime_library_dirs=ext.runtime_library_dirs,
        extra_postargs=extra_args,
        export_symbols=self.get_export_symbols(ext),
        debug=self.debug,
        build_temp=self.build_temp,
        target_lang=language)


</t>
<t tx="ekr.20080401090728.71">def swig_sources (self, sources, extension):

    """Walk the list of source files in 'sources', looking for SWIG
    interface (.i) files.  Run SWIG on all that are found, and
    return a modified 'sources' list with SWIG source files replaced
    by the generated C (or C++) files.
    """

    new_sources = []
    swig_sources = []
    swig_targets = {}

    # XXX this drops generated C/C++ files into the source tree, which
    # is fine for developers who want to distribute the generated
    # source -- but there should be an option to put SWIG output in
    # the temp dir.

    if self.swig_cpp:
        log.warn("--swig-cpp is deprecated - use --swig-opts=-c++")

    if self.swig_cpp or ('-c++' in self.swig_opts):
        target_ext = '.cpp'
    else:
        target_ext = '.c'

    for source in sources:
        (base, ext) = os.path.splitext(source)
        if ext == ".i":             # SWIG interface file
            new_sources.append(base + '_wrap' + target_ext)
            swig_sources.append(source)
            swig_targets[source] = new_sources[-1]
        else:
            new_sources.append(source)

    if not swig_sources:
        return new_sources

    swig = self.swig or self.find_swig()
    swig_cmd = [swig, "-python"]
    swig_cmd.extend(self.swig_opts)
    if self.swig_cpp:
        swig_cmd.append("-c++")

    # Do not override commandline arguments
    if not self.swig_opts:
        for o in extension.swig_opts:
            swig_cmd.append(o)

    for source in swig_sources:
        target = swig_targets[source]
        log.info("swigging %s to %s", source, target)
        self.spawn(swig_cmd + ["-o", target, source])

    return new_sources

</t>
<t tx="ekr.20080401090728.72"># swig_sources ()

def find_swig (self):
    """Return the name of the SWIG executable.  On Unix, this is
    just "swig" -- it should be in the PATH.  Tries a bit harder on
    Windows.
    """

    if os.name == "posix":
        return "swig"
    elif os.name == "nt":

        # Look for SWIG in its standard installation directory on
        # Windows (or so I presume!).  If we find it there, great;
        # if not, act like Unix and assume it's in the PATH.
        for vers in ("1.3", "1.2", "1.1"):
            fn = os.path.join("c:\\swig%s" % vers, "swig.exe")
            if os.path.isfile(fn):
                return fn
        else:
            return "swig.exe"

    elif os.name == "os2":
        # assume swig available in the PATH.
        return "swig.exe"

    else:
        raise DistutilsPlatformError, \
              ("I don't know how to find (much less run) SWIG "
               "on platform '%s'") % os.name

</t>
<t tx="ekr.20080401090728.73"># find_swig ()

# -- Name generators -----------------------------------------------
# (extension names, filenames, whatever)

def get_ext_fullname (self, ext_name):
    if self.package is None:
        return ext_name
    else:
        return self.package + '.' + ext_name

</t>
<t tx="ekr.20080401090728.74">def get_ext_filename (self, ext_name):
    r"""Convert the name of an extension (eg. "foo.bar") into the name
    of the file from which it will be loaded (eg. "foo/bar.so", or
    "foo\bar.pyd").
    """

    from distutils.sysconfig import get_config_var
    ext_path = string.split(ext_name, '.')
    # OS/2 has an 8 character module (extension) limit :-(
    if os.name == "os2":
        ext_path[len(ext_path) - 1] = ext_path[len(ext_path) - 1][:8]
    # extensions in debug_mode are named 'module_d.pyd' under windows
    so_ext = get_config_var('SO')
    if os.name == 'nt' and self.debug:
        return apply(os.path.join, ext_path) + '_d' + so_ext
    return apply(os.path.join, ext_path) + so_ext

</t>
<t tx="ekr.20080401090728.75">def get_export_symbols (self, ext):
    """Return the list of symbols that a shared extension has to
    export.  This either uses 'ext.export_symbols' or, if it's not
    provided, "init" + module_name.  Only relevant on Windows, where
    the .pyd file (DLL) must export the module "init" function.
    """

    initfunc_name = "init" + string.split(ext.name,'.')[-1]
    if initfunc_name not in ext.export_symbols:
        ext.export_symbols.append(initfunc_name)
    return ext.export_symbols

</t>
<t tx="ekr.20080401090728.76">def get_libraries (self, ext):
    """Return the list of libraries to link against when building a
    shared extension.  On most platforms, this is just 'ext.libraries';
    on Windows and OS/2, we add the Python library (eg. python20.dll).
    """
    # The python library is always needed on Windows.  For MSVC, this
    # is redundant, since the library is mentioned in a pragma in
    # pyconfig.h that MSVC groks.  The other Windows compilers all seem
    # to need it mentioned explicitly, though, so that's what we do.
    # Append '_d' to the python import library on debug builds.
    if sys.platform == "win32":
        from distutils.msvccompiler import MSVCCompiler
        if not isinstance(self.compiler, MSVCCompiler):
            template = "python%d%d"
            if self.debug:
                template = template + '_d'
            pythonlib = (template %
                   (sys.hexversion &gt;&gt; 24, (sys.hexversion &gt;&gt; 16) &amp; 0xff))
            # don't extend ext.libraries, it may be shared with other
            # extensions, it is a reference to the original list
            return ext.libraries + [pythonlib]
        else:
            return ext.libraries
    elif sys.platform == "os2emx":
        # EMX/GCC requires the python library explicitly, and I
        # believe VACPP does as well (though not confirmed) - AIM Apr01
        template = "python%d%d"
        # debug versions of the main DLL aren't supported, at least
        # not at this time - AIM Apr01
        #if self.debug:
        #    template = template + '_d'
        pythonlib = (template %
               (sys.hexversion &gt;&gt; 24, (sys.hexversion &gt;&gt; 16) &amp; 0xff))
        # don't extend ext.libraries, it may be shared with other
        # extensions, it is a reference to the original list
        return ext.libraries + [pythonlib]
    elif sys.platform[:6] == "cygwin":
        template = "python%d.%d"
        pythonlib = (template %
               (sys.hexversion &gt;&gt; 24, (sys.hexversion &gt;&gt; 16) &amp; 0xff))
        # don't extend ext.libraries, it may be shared with other
        # extensions, it is a reference to the original list
        return ext.libraries + [pythonlib]
    elif sys.platform[:6] == "atheos":
        from distutils import sysconfig

        template = "python%d.%d"
        pythonlib = (template %
               (sys.hexversion &gt;&gt; 24, (sys.hexversion &gt;&gt; 16) &amp; 0xff))
        # Get SHLIBS from Makefile
        extra = []
        for lib in sysconfig.get_config_var('SHLIBS').split():
            if lib.startswith('-l'):
                extra.append(lib[2:])
            else:
                extra.append(lib)
        # don't extend ext.libraries, it may be shared with other
        # extensions, it is a reference to the original list
        return ext.libraries + [pythonlib, "m"] + extra

    elif sys.platform == 'darwin':
        # Don't use the default code below
        return ext.libraries

    else:
        from distutils import sysconfig
        if sysconfig.get_config_var('Py_ENABLE_SHARED'):
            template = "python%d.%d"
            pythonlib = (template %
                         (sys.hexversion &gt;&gt; 24, (sys.hexversion &gt;&gt; 16) &amp; 0xff))
            return ext.libraries + [pythonlib]
        else:
            return ext.libraries

</t>
<t tx="ekr.20080401090728.77">"""distutils.command.build_py

Implements the Distutils 'build_py' command."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: build_py.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, string, os
from types import *
from glob import glob

from distutils.core import Command
from distutils.errors import *
from distutils.util import convert_path
from distutils import log

</t>
<t tx="ekr.20080401090728.78">class build_py (Command):

    description = "\"build\" pure Python modules (copy to build directory)"

    user_options = [
        ('build-lib=', 'd', "directory to \"build\" (copy) to"),
        ('compile', 'c', "compile .py to .pyc"),
        ('no-compile', None, "don't compile .py files [default]"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('force', 'f', "forcibly build everything (ignore file timestamps)"),
        ]

    boolean_options = ['compile', 'force']
    negative_opt = {'no-compile' : 'compile'}


    @others
</t>
<t tx="ekr.20080401090728.79">def initialize_options (self):
    self.build_lib = None
    self.py_modules = None
    self.package = None
    self.package_data = None
    self.package_dir = None
    self.compile = 0
    self.optimize = 0
    self.force = None

</t>
<t tx="ekr.20080401090728.80">def finalize_options (self):
    self.set_undefined_options('build',
                               ('build_lib', 'build_lib'),
                               ('force', 'force'))

    # Get the distribution options that are aliases for build_py
    # options -- list of packages and list of modules.
    self.packages = self.distribution.packages
    self.py_modules = self.distribution.py_modules
    self.package_data = self.distribution.package_data
    self.package_dir = {}
    if self.distribution.package_dir:
        for name, path in self.distribution.package_dir.items():
            self.package_dir[name] = convert_path(path)
    self.data_files = self.get_data_files()

    # Ick, copied straight from install_lib.py (fancy_getopt needs a
    # type system!  Hell, *everything* needs a type system!!!)
    if type(self.optimize) is not IntType:
        try:
            self.optimize = int(self.optimize)
            assert 0 &lt;= self.optimize &lt;= 2
        except (ValueError, AssertionError):
            raise DistutilsOptionError, "optimize must be 0, 1, or 2"

</t>
<t tx="ekr.20080401090728.81">def run (self):

    # XXX copy_file by default preserves atime and mtime.  IMHO this is
    # the right thing to do, but perhaps it should be an option -- in
    # particular, a site administrator might want installed files to
    # reflect the time of installation rather than the last
    # modification time before the installed release.

    # XXX copy_file by default preserves mode, which appears to be the
    # wrong thing to do: if a file is read-only in the working
    # directory, we want it to be installed read/write so that the next
    # installation of the same module distribution can overwrite it
    # without problems.  (This might be a Unix-specific issue.)  Thus
    # we turn off 'preserve_mode' when copying to the build directory,
    # since the build directory is supposed to be exactly what the
    # installation will look like (ie. we preserve mode when
    # installing).

    # Two options control which modules will be installed: 'packages'
    # and 'py_modules'.  The former lets us work with whole packages, not
    # specifying individual modules at all; the latter is for
    # specifying modules one-at-a-time.

    if self.py_modules:
        self.build_modules()
    if self.packages:
        self.build_packages()
        self.build_package_data()

    self.byte_compile(self.get_outputs(include_bytecode=0))

</t>
<t tx="ekr.20080401090728.82"># run ()

def get_data_files (self):
    """Generate list of '(package,src_dir,build_dir,filenames)' tuples"""
    data = []
    if not self.packages:
        return data
    for package in self.packages:
        # Locate package source directory
        src_dir = self.get_package_dir(package)

        # Compute package build directory
        build_dir = os.path.join(*([self.build_lib] + package.split('.')))

        # Length of path to strip from found files
        plen = len(src_dir)+1

        # Strip directory from globbed filenames
        filenames = [
            file[plen:] for file in self.find_data_files(package, src_dir)
            ]
        data.append((package, src_dir, build_dir, filenames))
    return data

</t>
<t tx="ekr.20080401090728.83">def find_data_files (self, package, src_dir):
    """Return filenames for package's data files in 'src_dir'"""
    globs = (self.package_data.get('', [])
             + self.package_data.get(package, []))
    files = []
    for pattern in globs:
        # Each pattern has to be converted to a platform-specific path
        filelist = glob(os.path.join(src_dir, convert_path(pattern)))
        # Files that match more than one pattern are only added once
        files.extend([fn for fn in filelist if fn not in files])
    return files

</t>
<t tx="ekr.20080401090728.84">def build_package_data (self):
    """Copy data files into build directory"""
    lastdir = None
    for package, src_dir, build_dir, filenames in self.data_files:
        for filename in filenames:
            target = os.path.join(build_dir, filename)
            self.mkpath(os.path.dirname(target))
            self.copy_file(os.path.join(src_dir, filename), target,
                           preserve_mode=False)

</t>
<t tx="ekr.20080401090728.85">def get_package_dir (self, package):
    """Return the directory, relative to the top of the source
       distribution, where package 'package' should be found
       (at least according to the 'package_dir' option, if any)."""

    path = string.split(package, '.')

    if not self.package_dir:
        if path:
            return apply(os.path.join, path)
        else:
            return ''
    else:
        tail = []
        while path:
            try:
                pdir = self.package_dir[string.join(path, '.')]
            except KeyError:
                tail.insert(0, path[-1])
                del path[-1]
            else:
                tail.insert(0, pdir)
                return apply(os.path.join, tail)
        else:
            # Oops, got all the way through 'path' without finding a
            # match in package_dir.  If package_dir defines a directory
            # for the root (nameless) package, then fallback on it;
            # otherwise, we might as well have not consulted
            # package_dir at all, as we just use the directory implied
            # by 'tail' (which should be the same as the original value
            # of 'path' at this point).
            pdir = self.package_dir.get('')
            if pdir is not None:
                tail.insert(0, pdir)

            if tail:
                return apply(os.path.join, tail)
            else:
                return ''

</t>
<t tx="ekr.20080401090728.86"># get_package_dir ()


def check_package (self, package, package_dir):

    # Empty dir name means current directory, which we can probably
    # assume exists.  Also, os.path.exists and isdir don't know about
    # my "empty string means current dir" convention, so we have to
    # circumvent them.
    if package_dir != "":
        if not os.path.exists(package_dir):
            raise DistutilsFileError, \
                  "package directory '%s' does not exist" % package_dir
        if not os.path.isdir(package_dir):
            raise DistutilsFileError, \
                  ("supposed package directory '%s' exists, " +
                   "but is not a directory") % package_dir

    # Require __init__.py for all but the "root package"
    if package:
        init_py = os.path.join(package_dir, "__init__.py")
        if os.path.isfile(init_py):
            return init_py
        else:
            log.warn(("package init file '%s' not found " +
                      "(or not a regular file)"), init_py)

    # Either not in a package at all (__init__.py not expected), or
    # __init__.py doesn't exist -- so don't return the filename.
    return None

</t>
<t tx="ekr.20080401090728.87"># check_package ()


def check_module (self, module, module_file):
    if not os.path.isfile(module_file):
        log.warn("file %s (for module %s) not found", module_file, module)
        return 0
    else:
        return 1

</t>
<t tx="ekr.20080401090728.88"># check_module ()


def find_package_modules (self, package, package_dir):
    self.check_package(package, package_dir)
    module_files = glob(os.path.join(package_dir, "*.py"))
    modules = []
    setup_script = os.path.abspath(self.distribution.script_name)

    for f in module_files:
        abs_f = os.path.abspath(f)
        if abs_f != setup_script:
            module = os.path.splitext(os.path.basename(f))[0]
            modules.append((package, module, f))
        else:
            self.debug_print("excluding %s" % setup_script)
    return modules


</t>
<t tx="ekr.20080401090728.89">def find_modules (self):
    """Finds individually-specified Python modules, ie. those listed by
    module name in 'self.py_modules'.  Returns a list of tuples (package,
    module_base, filename): 'package' is a tuple of the path through
    package-space to the module; 'module_base' is the bare (no
    packages, no dots) module name, and 'filename' is the path to the
    ".py" file (relative to the distribution root) that implements the
    module.
    """

    # Map package names to tuples of useful info about the package:
    #    (package_dir, checked)
    # package_dir - the directory where we'll find source files for
    #   this package
    # checked - true if we have checked that the package directory
    #   is valid (exists, contains __init__.py, ... ?)
    packages = {}

    # List of (package, module, filename) tuples to return
    modules = []

    # We treat modules-in-packages almost the same as toplevel modules,
    # just the "package" for a toplevel is empty (either an empty
    # string or empty list, depending on context).  Differences:
    #   - don't check for __init__.py in directory for empty package

    for module in self.py_modules:
        path = string.split(module, '.')
        package = string.join(path[0:-1], '.')
        module_base = path[-1]

        try:
            (package_dir, checked) = packages[package]
        except KeyError:
            package_dir = self.get_package_dir(package)
            checked = 0

        if not checked:
            init_py = self.check_package(package, package_dir)
            packages[package] = (package_dir, 1)
            if init_py:
                modules.append((package, "__init__", init_py))

        # XXX perhaps we should also check for just .pyc files
        # (so greedy closed-source bastards can distribute Python
        # modules too)
        module_file = os.path.join(package_dir, module_base + ".py")
        if not self.check_module(module, module_file):
            continue

        modules.append((package, module_base, module_file))

    return modules

</t>
<t tx="ekr.20080401090728.90"># find_modules ()


def find_all_modules (self):
    """Compute the list of all modules that will be built, whether
    they are specified one-module-at-a-time ('self.py_modules') or
    by whole packages ('self.packages').  Return a list of tuples
    (package, module, module_file), just like 'find_modules()' and
    'find_package_modules()' do."""

    modules = []
    if self.py_modules:
        modules.extend(self.find_modules())
    if self.packages:
        for package in self.packages:
            package_dir = self.get_package_dir(package)
            m = self.find_package_modules(package, package_dir)
            modules.extend(m)

    return modules

</t>
<t tx="ekr.20080401090728.91"># find_all_modules ()


def get_source_files (self):

    modules = self.find_all_modules()
    filenames = []
    for module in modules:
        filenames.append(module[-1])

    return filenames


</t>
<t tx="ekr.20080401090728.92">def get_module_outfile (self, build_dir, package, module):
    outfile_path = [build_dir] + list(package) + [module + ".py"]
    return apply(os.path.join, outfile_path)


</t>
<t tx="ekr.20080401090728.93">def get_outputs (self, include_bytecode=1):
    modules = self.find_all_modules()
    outputs = []
    for (package, module, module_file) in modules:
        package = string.split(package, '.')
        filename = self.get_module_outfile(self.build_lib, package, module)
        outputs.append(filename)
        if include_bytecode:
            if self.compile:
                outputs.append(filename + "c")
            if self.optimize &gt; 0:
                outputs.append(filename + "o")

    outputs += [
        os.path.join(build_dir, filename)
        for package, src_dir, build_dir, filenames in self.data_files
        for filename in filenames
        ]

    return outputs


</t>
<t tx="ekr.20080401090728.94">def build_module (self, module, module_file, package):
    if type(package) is StringType:
        package = string.split(package, '.')
    elif type(package) not in (ListType, TupleType):
        raise TypeError, \
              "'package' must be a string (dot-separated), list, or tuple"

    # Now put the module source file into the "build" area -- this is
    # easy, we just copy it somewhere under self.build_lib (the build
    # directory for Python source).
    outfile = self.get_module_outfile(self.build_lib, package, module)
    dir = os.path.dirname(outfile)
    self.mkpath(dir)
    return self.copy_file(module_file, outfile, preserve_mode=0)


</t>
<t tx="ekr.20080401090728.95">def build_modules (self):

    modules = self.find_modules()
    for (package, module, module_file) in modules:

        # Now "build" the module -- ie. copy the source file to
        # self.build_lib (the build directory for Python source).
        # (Actually, it gets copied to the directory for this package
        # under self.build_lib.)
        self.build_module(module, module_file, package)

</t>
<t tx="ekr.20080401090728.96"># build_modules ()


def build_packages (self):

    for package in self.packages:

        # Get list of (package, module, module_file) tuples based on
        # scanning the package directory.  'package' is only included
        # in the tuple so that 'find_modules()' and
        # 'find_package_tuples()' have a consistent interface; it's
        # ignored here (apart from a sanity check).  Also, 'module' is
        # the *unqualified* module name (ie. no dots, no package -- we
        # already know its package!), and 'module_file' is the path to
        # the .py file, relative to the current directory
        # (ie. including 'package_dir').
        package_dir = self.get_package_dir(package)
        modules = self.find_package_modules(package, package_dir)

        # Now loop over the modules we found, "building" each one (just
        # copy it to self.build_lib).
        for (package_, module, module_file) in modules:
            assert package == package_
            self.build_module(module, module_file, package)
</t>
<t tx="ekr.20080401090728.97"># build_packages ()


def byte_compile (self, files):
    from distutils.util import byte_compile
    prefix = self.build_lib
    if prefix[-1] != os.sep:
        prefix = prefix + os.sep

    # XXX this code is essentially the same as the 'byte_compile()
    # method of the "install_lib" command, except for the determination
    # of the 'prefix' string.  Hmmm.

    if self.compile:
        byte_compile(files, optimize=0,
                     force=self.force, prefix=prefix, dry_run=self.dry_run)
    if self.optimize &gt; 0:
        byte_compile(files, optimize=self.optimize,
                     force=self.force, prefix=prefix, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090728.98">"""distutils.command.build_scripts

Implements the Distutils 'build_scripts' command."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: build_scripts.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os, re
from stat import ST_MODE
from distutils import sysconfig
from distutils.core import Command
from distutils.dep_util import newer
from distutils.util import convert_path
from distutils import log

# check if Python is called on the first line with this expression
first_line_re = re.compile('^#!.*python[0-9.]*([ \t].*)?$')

</t>
<t tx="ekr.20080401090728.99">class build_scripts (Command):

    description = "\"build\" scripts (copy and fixup #! line)"

    user_options = [
        ('build-dir=', 'd', "directory to \"build\" (copy) to"),
        ('force', 'f', "forcibly build everything (ignore file timestamps"),
        ('executable=', 'e', "specify final destination interpreter path"),
        ]

    boolean_options = ['force']


    @others
    # copy_scripts ()

</t>
<t tx="ekr.20080401090728.100">def initialize_options (self):
    self.build_dir = None
    self.scripts = None
    self.force = None
    self.executable = None
    self.outfiles = None

</t>
<t tx="ekr.20080401090728.101">def finalize_options (self):
    self.set_undefined_options('build',
                               ('build_scripts', 'build_dir'),
                               ('force', 'force'),
                               ('executable', 'executable'))
    self.scripts = self.distribution.scripts

</t>
<t tx="ekr.20080401090728.102">def get_source_files(self):
    return self.scripts

</t>
<t tx="ekr.20080401090728.103">def run (self):
    if not self.scripts:
        return
    self.copy_scripts()


</t>
<t tx="ekr.20080401090728.104">def copy_scripts (self):
    """Copy each script listed in 'self.scripts'; if it's marked as a
    Python script in the Unix way (first line matches 'first_line_re',
    ie. starts with "\#!" and contains "python"), then adjust the first
    line to refer to the current Python interpreter as we copy.
    """
    self.mkpath(self.build_dir)
    outfiles = []
    for script in self.scripts:
        adjust = 0
        script = convert_path(script)
        outfile = os.path.join(self.build_dir, os.path.basename(script))
        outfiles.append(outfile)

        if not self.force and not newer(script, outfile):
            log.debug("not copying %s (up-to-date)", script)
            continue

        # Always open the file, but ignore failures in dry-run mode --
        # that way, we'll get accurate feedback if we can read the
        # script.
        try:
            f = open(script, "r")
        except IOError:
            if not self.dry_run:
                raise
            f = None
        else:
            first_line = f.readline()
            if not first_line:
                self.warn("%s is an empty file (skipping)" % script)
                continue

            match = first_line_re.match(first_line)
            if match:
                adjust = 1
                post_interp = match.group(1) or ''

        if adjust:
            log.info("copying and adjusting %s -&gt; %s", script,
                     self.build_dir)
            if not self.dry_run:
                outf = open(outfile, "w")
                if not sysconfig.python_build:
                    outf.write("#!%s%s\n" %
                               (self.executable,
                                post_interp))
                else:
                    outf.write("#!%s%s\n" %
                               (os.path.join(
                        sysconfig.get_config_var("BINDIR"),
                        "python" + sysconfig.get_config_var("EXE")),
                                post_interp))
                outf.writelines(f.readlines())
                outf.close()
            if f:
                f.close()
        else:
            f.close()
            self.copy_file(script, outfile)

    if os.name == 'posix':
        for file in outfiles:
            if self.dry_run:
                log.info("changing mode of %s", file)
            else:
                oldmode = os.stat(file)[ST_MODE] &amp; 07777
                newmode = (oldmode | 0555) &amp; 07777
                if newmode != oldmode:
                    log.info("changing mode of %s from %o to %o",
                             file, oldmode, newmode)
                    os.chmod(file, newmode)

</t>
<t tx="ekr.20080401090728.105">"""distutils.command.clean

Implements the Distutils 'clean' command."""

# contributed by Bastian Kleineidam &lt;calvin@cs.uni-sb.de&gt;, added 2000-03-18

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: clean.py 38532 2005-03-03 08:12:27Z loewis $"

import os
from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils import log

</t>
<t tx="ekr.20080401090728.106">class clean (Command):

    description = "clean up temporary files from 'build' command"
    user_options = [
        ('build-base=', 'b',
         "base build directory (default: 'build.build-base')"),
        ('build-lib=', None,
         "build directory for all modules (default: 'build.build-lib')"),
        ('build-temp=', 't',
         "temporary build directory (default: 'build.build-temp')"),
        ('build-scripts=', None,
         "build directory for scripts (default: 'build.build-scripts')"),
        ('bdist-base=', None,
         "temporary directory for built distributions"),
        ('all', 'a',
         "remove all build output, not just temporary by-products")
    ]

    boolean_options = ['all']

    @others
</t>
<t tx="ekr.20080401090728.107">def initialize_options(self):
    self.build_base = None
    self.build_lib = None
    self.build_temp = None
    self.build_scripts = None
    self.bdist_base = None
    self.all = None

</t>
<t tx="ekr.20080401090728.108">def finalize_options(self):
    self.set_undefined_options('build',
                               ('build_base', 'build_base'),
                               ('build_lib', 'build_lib'),
                               ('build_scripts', 'build_scripts'),
                               ('build_temp', 'build_temp'))
    self.set_undefined_options('bdist',
                               ('bdist_base', 'bdist_base'))

</t>
<t tx="ekr.20080401090728.109">def run(self):
    # remove the build/temp.&lt;plat&gt; directory (unless it's already
    # gone)
    if os.path.exists(self.build_temp):
        remove_tree(self.build_temp, dry_run=self.dry_run)
    else:
        log.debug("'%s' does not exist -- can't clean it",
                  self.build_temp)

    if self.all:
        # remove build directories
        for directory in (self.build_lib,
                          self.bdist_base,
                          self.build_scripts):
            if os.path.exists(directory):
                remove_tree(directory, dry_run=self.dry_run)
            else:
                log.warn("'%s' does not exist -- can't clean it",
                         directory)

    # just for the heck of it, try to remove the base build directory:
    # we might have emptied it right now, but if not we don't care
    if not self.dry_run:
        try:
            os.rmdir(self.build_base)
            log.info("removing '%s'", self.build_base)
        except OSError:
            pass

</t>
<t tx="ekr.20080401090728.110">"""distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: config.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os, string, re
from types import *
from distutils.core import Command
from distutils.errors import DistutilsExecError
from distutils.sysconfig import customize_compiler
from distutils import log

LANG_EXT = {'c': '.c',
            'c++': '.cxx'}

</t>
<t tx="ekr.20080401090728.111">class config (Command):

    description = "prepare to build"

    user_options = [
        ('compiler=', None,
         "specify the compiler type"),
        ('cc=', None,
         "specify the compiler executable"),
        ('include-dirs=', 'I',
         "list of directories to search for header files"),
        ('define=', 'D',
         "C preprocessor macros to define"),
        ('undef=', 'U',
         "C preprocessor macros to undefine"),
        ('libraries=', 'l',
         "external C libraries to link with"),
        ('library-dirs=', 'L',
         "directories to search for external C libraries"),

        ('noisy', None,
         "show every action (compile, link, run, ...) taken"),
        ('dump-source', None,
         "dump generated source files before attempting to compile them"),
        ]


    @others
</t>
<t tx="ekr.20080401090728.112"># The three standard command methods: since the "config" command
# does nothing by default, these are empty.

def initialize_options (self):
    self.compiler = None
    self.cc = None
    self.include_dirs = None
    #self.define = None
    #self.undef = None
    self.libraries = None
    self.library_dirs = None

    # maximal output for now
    self.noisy = 1
    self.dump_source = 1

    # list of temporary files generated along-the-way that we have
    # to clean at some point
    self.temp_files = []

</t>
<t tx="ekr.20080401090728.113">def finalize_options (self):
    if self.include_dirs is None:
        self.include_dirs = self.distribution.include_dirs or []
    elif type(self.include_dirs) is StringType:
        self.include_dirs = string.split(self.include_dirs, os.pathsep)

    if self.libraries is None:
        self.libraries = []
    elif type(self.libraries) is StringType:
        self.libraries = [self.libraries]

    if self.library_dirs is None:
        self.library_dirs = []
    elif type(self.library_dirs) is StringType:
        self.library_dirs = string.split(self.library_dirs, os.pathsep)


</t>
<t tx="ekr.20080401090728.114">def run (self):
    pass


</t>
<t tx="ekr.20080401090728.115"># Utility methods for actual "config" commands.  The interfaces are
# loosely based on Autoconf macros of similar names.  Sub-classes
# may use these freely.

def _check_compiler (self):
    """Check that 'self.compiler' really is a CCompiler object;
    if not, make it one.
    """
    # We do this late, and only on-demand, because this is an expensive
    # import.
    from distutils.ccompiler import CCompiler, new_compiler
    if not isinstance(self.compiler, CCompiler):
        self.compiler = new_compiler(compiler=self.compiler,
                                     dry_run=self.dry_run, force=1)
        customize_compiler(self.compiler)
        if self.include_dirs:
            self.compiler.set_include_dirs(self.include_dirs)
        if self.libraries:
            self.compiler.set_libraries(self.libraries)
        if self.library_dirs:
            self.compiler.set_library_dirs(self.library_dirs)


</t>
<t tx="ekr.20080401090728.116">def _gen_temp_sourcefile (self, body, headers, lang):
    filename = "_configtest" + LANG_EXT[lang]
    file = open(filename, "w")
    if headers:
        for header in headers:
            file.write("#include &lt;%s&gt;\n" % header)
        file.write("\n")
    file.write(body)
    if body[-1] != "\n":
        file.write("\n")
    file.close()
    return filename

</t>
<t tx="ekr.20080401090728.117">def _preprocess (self, body, headers, include_dirs, lang):
    src = self._gen_temp_sourcefile(body, headers, lang)
    out = "_configtest.i"
    self.temp_files.extend([src, out])
    self.compiler.preprocess(src, out, include_dirs=include_dirs)
    return (src, out)

</t>
<t tx="ekr.20080401090728.118">def _compile (self, body, headers, include_dirs, lang):
    src = self._gen_temp_sourcefile(body, headers, lang)
    if self.dump_source:
        dump_file(src, "compiling '%s':" % src)
    (obj,) = self.compiler.object_filenames([src])
    self.temp_files.extend([src, obj])
    self.compiler.compile([src], include_dirs=include_dirs)
    return (src, obj)

</t>
<t tx="ekr.20080401090728.119">def _link (self, body,
           headers, include_dirs,
           libraries, library_dirs, lang):
    (src, obj) = self._compile(body, headers, include_dirs, lang)
    prog = os.path.splitext(os.path.basename(src))[0]
    self.compiler.link_executable([obj], prog,
                                  libraries=libraries,
                                  library_dirs=library_dirs,
                                  target_lang=lang)

    if self.compiler.exe_extension is not None:
        prog = prog + self.compiler.exe_extension
    self.temp_files.append(prog)

    return (src, obj, prog)

</t>
<t tx="ekr.20080401090728.120">def _clean (self, *filenames):
    if not filenames:
        filenames = self.temp_files
        self.temp_files = []
    log.info("removing: %s", string.join(filenames))
    for filename in filenames:
        try:
            os.remove(filename)
        except OSError:
            pass


</t>
<t tx="ekr.20080401090728.121"># XXX these ignore the dry-run flag: what to do, what to do? even if
# you want a dry-run build, you still need some sort of configuration
# info.  My inclination is to make it up to the real config command to
# consult 'dry_run', and assume a default (minimal) configuration if
# true.  The problem with trying to do it here is that you'd have to
# return either true or false from all the 'try' methods, neither of
# which is correct.

# XXX need access to the header search path and maybe default macros.

def try_cpp (self, body=None, headers=None, include_dirs=None, lang="c"):
    """Construct a source file from 'body' (a string containing lines
    of C/C++ code) and 'headers' (a list of header files to include)
    and run it through the preprocessor.  Return true if the
    preprocessor succeeded, false if there were any errors.
    ('body' probably isn't of much use, but what the heck.)
    """
    from distutils.ccompiler import CompileError
    self._check_compiler()
    ok = 1
    try:
        self._preprocess(body, headers, include_dirs, lang)
    except CompileError:
        ok = 0

    self._clean()
    return ok

</t>
<t tx="ekr.20080401090728.122">def search_cpp (self, pattern, body=None,
                headers=None, include_dirs=None, lang="c"):
    """Construct a source file (just like 'try_cpp()'), run it through
    the preprocessor, and return true if any line of the output matches
    'pattern'.  'pattern' should either be a compiled regex object or a
    string containing a regex.  If both 'body' and 'headers' are None,
    preprocesses an empty file -- which can be useful to determine the
    symbols the preprocessor and compiler set by default.
    """

    self._check_compiler()
    (src, out) = self._preprocess(body, headers, include_dirs, lang)

    if type(pattern) is StringType:
        pattern = re.compile(pattern)

    file = open(out)
    match = 0
    while 1:
        line = file.readline()
        if line == '':
            break
        if pattern.search(line):
            match = 1
            break

    file.close()
    self._clean()
    return match

</t>
<t tx="ekr.20080401090728.123">def try_compile (self, body, headers=None, include_dirs=None, lang="c"):
    """Try to compile a source file built from 'body' and 'headers'.
    Return true on success, false otherwise.
    """
    from distutils.ccompiler import CompileError
    self._check_compiler()
    try:
        self._compile(body, headers, include_dirs, lang)
        ok = 1
    except CompileError:
        ok = 0

    log.info(ok and "success!" or "failure.")
    self._clean()
    return ok

</t>
<t tx="ekr.20080401090728.124">def try_link (self, body,
              headers=None, include_dirs=None,
              libraries=None, library_dirs=None,
              lang="c"):
    """Try to compile and link a source file, built from 'body' and
    'headers', to executable form.  Return true on success, false
    otherwise.
    """
    from distutils.ccompiler import CompileError, LinkError
    self._check_compiler()
    try:
        self._link(body, headers, include_dirs,
                   libraries, library_dirs, lang)
        ok = 1
    except (CompileError, LinkError):
        ok = 0

    log.info(ok and "success!" or "failure.")
    self._clean()
    return ok

</t>
<t tx="ekr.20080401090728.125">def try_run (self, body,
             headers=None, include_dirs=None,
             libraries=None, library_dirs=None,
             lang="c"):
    """Try to compile, link to an executable, and run a program
    built from 'body' and 'headers'.  Return true on success, false
    otherwise.
    """
    from distutils.ccompiler import CompileError, LinkError
    self._check_compiler()
    try:
        src, obj, exe = self._link(body, headers, include_dirs,
                                   libraries, library_dirs, lang)
        self.spawn([exe])
        ok = 1
    except (CompileError, LinkError, DistutilsExecError):
        ok = 0

    log.info(ok and "success!" or "failure.")
    self._clean()
    return ok


</t>
<t tx="ekr.20080401090728.126"># -- High-level methods --------------------------------------------
# (these are the ones that are actually likely to be useful
# when implementing a real-world config command!)

def check_func (self, func,
                headers=None, include_dirs=None,
                libraries=None, library_dirs=None,
                decl=0, call=0):

    """Determine if function 'func' is available by constructing a
    source file that refers to 'func', and compiles and links it.
    If everything succeeds, returns true; otherwise returns false.

    The constructed source file starts out by including the header
    files listed in 'headers'.  If 'decl' is true, it then declares
    'func' (as "int func()"); you probably shouldn't supply 'headers'
    and set 'decl' true in the same call, or you might get errors about
    a conflicting declarations for 'func'.  Finally, the constructed
    'main()' function either references 'func' or (if 'call' is true)
    calls it.  'libraries' and 'library_dirs' are used when
    linking.
    """

    self._check_compiler()
    body = []
    if decl:
        body.append("int %s ();" % func)
    body.append("int main () {")
    if call:
        body.append("  %s();" % func)
    else:
        body.append("  %s;" % func)
    body.append("}")
    body = string.join(body, "\n") + "\n"

    return self.try_link(body, headers, include_dirs,
                         libraries, library_dirs)

</t>
<t tx="ekr.20080401090728.127"># check_func ()

def check_lib (self, library, library_dirs=None,
               headers=None, include_dirs=None, other_libraries=[]):
    """Determine if 'library' is available to be linked against,
    without actually checking that any particular symbols are provided
    by it.  'headers' will be used in constructing the source file to
    be compiled, but the only effect of this is to check if all the
    header files listed are available.  Any libraries listed in
    'other_libraries' will be included in the link, in case 'library'
    has symbols that depend on other libraries.
    """
    self._check_compiler()
    return self.try_link("int main (void) { }",
                         headers, include_dirs,
                         [library]+other_libraries, library_dirs)

</t>
<t tx="ekr.20080401090728.128">def check_header (self, header, include_dirs=None,
                  library_dirs=None, lang="c"):
    """Determine if the system header file named by 'header_file'
    exists and can be found by the preprocessor; return true if so,
    false otherwise.
    """
    return self.try_cpp(body="/* No body */", headers=[header],
                        include_dirs=include_dirs)


</t>
<t tx="ekr.20080401090728.129"># class config


def dump_file (filename, head=None):
    if head is None:
        print filename + ":"
    else:
        print head

    file = open(filename)
    sys.stdout.write(file.read())
    file.close()
</t>
<t tx="ekr.20080401090728.130">"""distutils.command.install

Implements the Distutils 'install' command."""

from distutils import log

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: install.py 43363 2006-03-27 21:55:21Z phillip.eby $"

import sys, os, string
from types import *
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.sysconfig import get_config_vars
from distutils.errors import DistutilsPlatformError
from distutils.file_util import write_file
from distutils.util import convert_path, subst_vars, change_root
from distutils.errors import DistutilsOptionError
from glob import glob

if sys.version &lt; "2.2":
    WINDOWS_SCHEME = {
        'purelib': '$base',
        'platlib': '$base',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }
else:
    WINDOWS_SCHEME = {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
    }

INSTALL_SCHEMES = {
    'unix_prefix': {
        'purelib': '$base/lib/python$py_version_short/site-packages',
        'platlib': '$platbase/lib/python$py_version_short/site-packages',
        'headers': '$base/include/python$py_version_short/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'unix_home': {
        'purelib': '$base/lib/python',
        'platlib': '$base/lib/python',
        'headers': '$base/include/python/$dist_name',
        'scripts': '$base/bin',
        'data'   : '$base',
        },
    'nt': WINDOWS_SCHEME,
    'mac': {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
        },
    'os2': {
        'purelib': '$base/Lib/site-packages',
        'platlib': '$base/Lib/site-packages',
        'headers': '$base/Include/$dist_name',
        'scripts': '$base/Scripts',
        'data'   : '$base',
        }
    }

# The keys to an installation scheme; if any new types of files are to be
# installed, be sure to add an entry to every installation scheme above,
# and to SCHEME_KEYS here.
SCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')


</t>
<t tx="ekr.20080401090728.131">class install (Command):

    description = "install everything from build directory"

    user_options = [
        # Select installation scheme and set base director(y|ies)
        ('prefix=', None,
         "installation prefix"),
        ('exec-prefix=', None,
         "(Unix only) prefix for platform-specific files"),
        ('home=', None,
         "(Unix only) home directory to install under"),

        # Or, just set the base director(y|ies)
        ('install-base=', None,
         "base installation directory (instead of --prefix or --home)"),
        ('install-platbase=', None,
         "base installation directory for platform-specific files " +
         "(instead of --exec-prefix or --home)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),

        # Or, explicitly set the installation scheme
        ('install-purelib=', None,
         "installation directory for pure Python module distributions"),
        ('install-platlib=', None,
         "installation directory for non-pure module distributions"),
        ('install-lib=', None,
         "installation directory for all module distributions " +
         "(overrides --install-purelib and --install-platlib)"),

        ('install-headers=', None,
         "installation directory for C/C++ headers"),
        ('install-scripts=', None,
         "installation directory for Python scripts"),
        ('install-data=', None,
         "installation directory for data files"),

        # Byte-compilation options -- see install_lib.py for details, as
        # these are duplicated from there (but only install_lib does
        # anything with them).
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),

        # Miscellaneous control options
        ('force', 'f',
         "force installation (overwrite any existing files)"),
        ('skip-build', None,
         "skip rebuilding everything (for testing/debugging)"),

        # Where to install documentation (eventually!)
        #('doc-format=', None, "format of documentation to generate"),
        #('install-man=', None, "directory for Unix man pages"),
        #('install-html=', None, "directory for HTML documentation"),
        #('install-info=', None, "directory for GNU info files"),

        ('record=', None,
         "filename in which to record list of installed files"),
        ]

    boolean_options = ['compile', 'force', 'skip-build']
    negative_opt = {'no-compile' : 'compile'}


    @others
    # 'sub_commands': a list of commands this command might have to run to
    # get its work done.  See cmd.py for more info.
    sub_commands = [('install_lib',     has_lib),
                    ('install_headers', has_headers),
                    ('install_scripts', has_scripts),
                    ('install_data',    has_data),
                    ('install_egg_info', lambda self:True),
                   ]

</t>
<t tx="ekr.20080401090728.132">def initialize_options (self):

    # High-level options: these select both an installation base
    # and scheme.
    self.prefix = None
    self.exec_prefix = None
    self.home = None

    # These select only the installation base; it's up to the user to
    # specify the installation scheme (currently, that means supplying
    # the --install-{platlib,purelib,scripts,data} options).
    self.install_base = None
    self.install_platbase = None
    self.root = None

    # These options are the actual installation directories; if not
    # supplied by the user, they are filled in using the installation
    # scheme implied by prefix/exec-prefix/home and the contents of
    # that installation scheme.
    self.install_purelib = None     # for pure module distributions
    self.install_platlib = None     # non-pure (dists w/ extensions)
    self.install_headers = None     # for C/C++ headers
    self.install_lib = None         # set to either purelib or platlib
    self.install_scripts = None
    self.install_data = None

    self.compile = None
    self.optimize = None

    # These two are for putting non-packagized distributions into their
    # own directory and creating a .pth file if it makes sense.
    # 'extra_path' comes from the setup file; 'install_path_file' can
    # be turned off if it makes no sense to install a .pth file.  (But
    # better to install it uselessly than to guess wrong and not
    # install it when it's necessary and would be used!)  Currently,
    # 'install_path_file' is always true unless some outsider meddles
    # with it.
    self.extra_path = None
    self.install_path_file = 1

    # 'force' forces installation, even if target files are not
    # out-of-date.  'skip_build' skips running the "build" command,
    # handy if you know it's not necessary.  'warn_dir' (which is *not*
    # a user option, it's just there so the bdist_* commands can turn
    # it off) determines whether we warn about installing to a
    # directory not in sys.path.
    self.force = 0
    self.skip_build = 0
    self.warn_dir = 1

    # These are only here as a conduit from the 'build' command to the
    # 'install_*' commands that do the real work.  ('build_base' isn't
    # actually used anywhere, but it might be useful in future.)  They
    # are not user options, because if the user told the install
    # command where the build directory is, that wouldn't affect the
    # build command.
    self.build_base = None
    self.build_lib = None

    # Not defined yet because we don't know anything about
    # documentation yet.
    #self.install_man = None
    #self.install_html = None
    #self.install_info = None

    self.record = None


</t>
<t tx="ekr.20080401090728.133"># -- Option finalizing methods -------------------------------------
# (This is rather more involved than for most commands,
# because this is where the policy for installing third-
# party Python modules on various platforms given a wide
# array of user input is decided.  Yes, it's quite complex!)

def finalize_options (self):

    # This method (and its pliant slaves, like 'finalize_unix()',
    # 'finalize_other()', and 'select_scheme()') is where the default
    # installation directories for modules, extension modules, and
    # anything else we care to install from a Python module
    # distribution.  Thus, this code makes a pretty important policy
    # statement about how third-party stuff is added to a Python
    # installation!  Note that the actual work of installation is done
    # by the relatively simple 'install_*' commands; they just take
    # their orders from the installation directory options determined
    # here.

    # Check for errors/inconsistencies in the options; first, stuff
    # that's wrong on any platform.

    if ((self.prefix or self.exec_prefix or self.home) and
        (self.install_base or self.install_platbase)):
        raise DistutilsOptionError, \
              ("must supply either prefix/exec-prefix/home or " +
               "install-base/install-platbase -- not both")

    if self.home and (self.prefix or self.exec_prefix):
        raise DistutilsOptionError, \
              "must supply either home or prefix/exec-prefix -- not both"

    # Next, stuff that's wrong (or dubious) only on certain platforms.
    if os.name != "posix":
        if self.exec_prefix:
            self.warn("exec-prefix option ignored on this platform")
            self.exec_prefix = None

    # Now the interesting logic -- so interesting that we farm it out
    # to other methods.  The goal of these methods is to set the final
    # values for the install_{lib,scripts,data,...}  options, using as
    # input a heady brew of prefix, exec_prefix, home, install_base,
    # install_platbase, user-supplied versions of
    # install_{purelib,platlib,lib,scripts,data,...}, and the
    # INSTALL_SCHEME dictionary above.  Phew!

    self.dump_dirs("pre-finalize_{unix,other}")

    if os.name == 'posix':
        self.finalize_unix()
    else:
        self.finalize_other()

    self.dump_dirs("post-finalize_{unix,other}()")

    # Expand configuration variables, tilde, etc. in self.install_base
    # and self.install_platbase -- that way, we can use $base or
    # $platbase in the other installation directories and not worry
    # about needing recursive variable expansion (shudder).

    py_version = (string.split(sys.version))[0]
    (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')
    self.config_vars = {'dist_name': self.distribution.get_name(),
                        'dist_version': self.distribution.get_version(),
                        'dist_fullname': self.distribution.get_fullname(),
                        'py_version': py_version,
                        'py_version_short': py_version[0:3],
                        'sys_prefix': prefix,
                        'prefix': prefix,
                        'sys_exec_prefix': exec_prefix,
                        'exec_prefix': exec_prefix,
                       }
    self.expand_basedirs()

    self.dump_dirs("post-expand_basedirs()")

    # Now define config vars for the base directories so we can expand
    # everything else.
    self.config_vars['base'] = self.install_base
    self.config_vars['platbase'] = self.install_platbase

    if DEBUG:
        from pprint import pprint
        print "config vars:"
        pprint(self.config_vars)

    # Expand "~" and configuration variables in the installation
    # directories.
    self.expand_dirs()

    self.dump_dirs("post-expand_dirs()")

    # Pick the actual directory to install all modules to: either
    # install_purelib or install_platlib, depending on whether this
    # module distribution is pure or not.  Of course, if the user
    # already specified install_lib, use their selection.
    if self.install_lib is None:
        if self.distribution.ext_modules: # has extensions: non-pure
            self.install_lib = self.install_platlib
        else:
            self.install_lib = self.install_purelib


    # Convert directories from Unix /-separated syntax to the local
    # convention.
    self.convert_paths('lib', 'purelib', 'platlib',
                       'scripts', 'data', 'headers')

    # Well, we're not actually fully completely finalized yet: we still
    # have to deal with 'extra_path', which is the hack for allowing
    # non-packagized module distributions (hello, Numerical Python!) to
    # get their own directories.
    self.handle_extra_path()
    self.install_libbase = self.install_lib # needed for .pth file
    self.install_lib = os.path.join(self.install_lib, self.extra_dirs)

    # If a new root directory was supplied, make all the installation
    # dirs relative to it.
    if self.root is not None:
        self.change_roots('libbase', 'lib', 'purelib', 'platlib',
                          'scripts', 'data', 'headers')

    self.dump_dirs("after prepending root")

    # Find out the build directories, ie. where to install from.
    self.set_undefined_options('build',
                               ('build_base', 'build_base'),
                               ('build_lib', 'build_lib'))

    # Punt on doc directories for now -- after all, we're punting on
    # documentation completely!

</t>
<t tx="ekr.20080401090728.134"># finalize_options ()


def dump_dirs (self, msg):
    if DEBUG:
        from distutils.fancy_getopt import longopt_xlate
        print msg + ":"
        for opt in self.user_options:
            opt_name = opt[0]
            if opt_name[-1] == "=":
                opt_name = opt_name[0:-1]
            if self.negative_opt.has_key(opt_name):
                opt_name = string.translate(self.negative_opt[opt_name],
                                            longopt_xlate)
                val = not getattr(self, opt_name)
            else:
                opt_name = string.translate(opt_name, longopt_xlate)
                val = getattr(self, opt_name)
            print "  %s: %s" % (opt_name, val)


</t>
<t tx="ekr.20080401090728.135">def finalize_unix (self):

    if self.install_base is not None or self.install_platbase is not None:
        if ((self.install_lib is None and
             self.install_purelib is None and
             self.install_platlib is None) or
            self.install_headers is None or
            self.install_scripts is None or
            self.install_data is None):
            raise DistutilsOptionError, \
                  ("install-base or install-platbase supplied, but "
                  "installation scheme is incomplete")
        return

    if self.home is not None:
        self.install_base = self.install_platbase = self.home
        self.select_scheme("unix_home")
    else:
        if self.prefix is None:
            if self.exec_prefix is not None:
                raise DistutilsOptionError, \
                      "must not supply exec-prefix without prefix"

            self.prefix = os.path.normpath(sys.prefix)
            self.exec_prefix = os.path.normpath(sys.exec_prefix)

        else:
            if self.exec_prefix is None:
                self.exec_prefix = self.prefix

        self.install_base = self.prefix
        self.install_platbase = self.exec_prefix
        self.select_scheme("unix_prefix")

</t>
<t tx="ekr.20080401090728.136"># finalize_unix ()


def finalize_other (self):          # Windows and Mac OS for now

    if self.home is not None:
        self.install_base = self.install_platbase = self.home
        self.select_scheme("unix_home")
    else:
        if self.prefix is None:
            self.prefix = os.path.normpath(sys.prefix)

        self.install_base = self.install_platbase = self.prefix
        try:
            self.select_scheme(os.name)
        except KeyError:
            raise DistutilsPlatformError, \
                  "I don't know how to install stuff on '%s'" % os.name

</t>
<t tx="ekr.20080401090728.137"># finalize_other ()


def select_scheme (self, name):
    # it's the caller's problem if they supply a bad name!
    scheme = INSTALL_SCHEMES[name]
    for key in SCHEME_KEYS:
        attrname = 'install_' + key
        if getattr(self, attrname) is None:
            setattr(self, attrname, scheme[key])


</t>
<t tx="ekr.20080401090728.138">def _expand_attrs (self, attrs):
    for attr in attrs:
        val = getattr(self, attr)
        if val is not None:
            if os.name == 'posix':
                val = os.path.expanduser(val)
            val = subst_vars(val, self.config_vars)
            setattr(self, attr, val)


</t>
<t tx="ekr.20080401090728.139">def expand_basedirs (self):
    self._expand_attrs(['install_base',
                        'install_platbase',
                        'root'])

</t>
<t tx="ekr.20080401090728.140">def expand_dirs (self):
    self._expand_attrs(['install_purelib',
                        'install_platlib',
                        'install_lib',
                        'install_headers',
                        'install_scripts',
                        'install_data',])


</t>
<t tx="ekr.20080401090728.141">def convert_paths (self, *names):
    for name in names:
        attr = "install_" + name
        setattr(self, attr, convert_path(getattr(self, attr)))


</t>
<t tx="ekr.20080401090728.142">def handle_extra_path (self):

    if self.extra_path is None:
        self.extra_path = self.distribution.extra_path

    if self.extra_path is not None:
        if type(self.extra_path) is StringType:
            self.extra_path = string.split(self.extra_path, ',')

        if len(self.extra_path) == 1:
            path_file = extra_dirs = self.extra_path[0]
        elif len(self.extra_path) == 2:
            (path_file, extra_dirs) = self.extra_path
        else:
            raise DistutilsOptionError, \
                  ("'extra_path' option must be a list, tuple, or "
                  "comma-separated string with 1 or 2 elements")

        # convert to local form in case Unix notation used (as it
        # should be in setup scripts)
        extra_dirs = convert_path(extra_dirs)

    else:
        path_file = None
        extra_dirs = ''

    # XXX should we warn if path_file and not extra_dirs? (in which
    # case the path file would be harmless but pointless)
    self.path_file = path_file
    self.extra_dirs = extra_dirs

</t>
<t tx="ekr.20080401090728.143"># handle_extra_path ()


def change_roots (self, *names):
    for name in names:
        attr = "install_" + name
        setattr(self, attr, change_root(self.root, getattr(self, attr)))


</t>
<t tx="ekr.20080401090728.144"># -- Command execution methods -------------------------------------

def run (self):

    # Obviously have to build before we can install
    if not self.skip_build:
        self.run_command('build')

    # Run all sub-commands (at least those that need to be run)
    for cmd_name in self.get_sub_commands():
        self.run_command(cmd_name)

    if self.path_file:
        self.create_path_file()

    # write list of installed files, if requested.
    if self.record:
        outputs = self.get_outputs()
        if self.root:               # strip any package prefix
            root_len = len(self.root)
            for counter in xrange(len(outputs)):
                outputs[counter] = outputs[counter][root_len:]
        self.execute(write_file,
                     (self.record, outputs),
                     "writing list of installed files to '%s'" %
                     self.record)

    sys_path = map(os.path.normpath, sys.path)
    sys_path = map(os.path.normcase, sys_path)
    install_lib = os.path.normcase(os.path.normpath(self.install_lib))
    if (self.warn_dir and
        not (self.path_file and self.install_path_file) and
        install_lib not in sys_path):
        log.debug(("modules installed to '%s', which is not in "
                   "Python's module search path (sys.path) -- "
                   "you'll have to change the search path yourself"),
                   self.install_lib)

</t>
<t tx="ekr.20080401090728.145"># run ()

def create_path_file (self):
    filename = os.path.join(self.install_libbase,
                            self.path_file + ".pth")
    if self.install_path_file:
        self.execute(write_file,
                     (filename, [self.extra_dirs]),
                     "creating %s" % filename)
    else:
        self.warn("path file '%s' not created" % filename)


</t>
<t tx="ekr.20080401090728.146"># -- Reporting methods ---------------------------------------------

def get_outputs (self):
    # Assemble the outputs of all the sub-commands.
    outputs = []
    for cmd_name in self.get_sub_commands():
        cmd = self.get_finalized_command(cmd_name)
        # Add the contents of cmd.get_outputs(), ensuring
        # that outputs doesn't contain duplicate entries
        for filename in cmd.get_outputs():
            if filename not in outputs:
                outputs.append(filename)

    if self.path_file and self.install_path_file:
        outputs.append(os.path.join(self.install_libbase,
                                    self.path_file + ".pth"))

    return outputs

</t>
<t tx="ekr.20080401090728.147">def get_inputs (self):
    # XXX gee, this looks familiar ;-(
    inputs = []
    for cmd_name in self.get_sub_commands():
        cmd = self.get_finalized_command(cmd_name)
        inputs.extend(cmd.get_inputs())

    return inputs


</t>
<t tx="ekr.20080401090728.148"># -- Predicates for sub-command list -------------------------------

def has_lib (self):
    """Return true if the current distribution has any Python
    modules to install."""
    return (self.distribution.has_pure_modules() or
            self.distribution.has_ext_modules())

</t>
<t tx="ekr.20080401090728.149">def has_headers (self):
    return self.distribution.has_headers()

</t>
<t tx="ekr.20080401090728.150">def has_scripts (self):
    return self.distribution.has_scripts()

</t>
<t tx="ekr.20080401090728.151">def has_data (self):
    return self.distribution.has_data_files()


</t>
<t tx="ekr.20080401090728.152">"""distutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files."""

# contributed by Bastian Kleineidam

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: install_data.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from types import StringType
from distutils.core import Command
from distutils.util import change_root, convert_path

</t>
<t tx="ekr.20080401090728.153">class install_data (Command):

    description = "install data files"

    user_options = [
        ('install-dir=', 'd',
         "base directory for installing data files "
         "(default: installation base dir)"),
        ('root=', None,
         "install everything relative to this alternate root directory"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ]

    boolean_options = ['force']

    @others
</t>
<t tx="ekr.20080401090728.154">def initialize_options (self):
    self.install_dir = None
    self.outfiles = []
    self.root = None
    self.force = 0

    self.data_files = self.distribution.data_files
    self.warn_dir = 1

</t>
<t tx="ekr.20080401090728.155">def finalize_options (self):
    self.set_undefined_options('install',
                               ('install_data', 'install_dir'),
                               ('root', 'root'),
                               ('force', 'force'),
                              )

</t>
<t tx="ekr.20080401090728.156">def run (self):
    self.mkpath(self.install_dir)
    for f in self.data_files:
        if type(f) is StringType:
            # it's a simple file, so copy it
            f = convert_path(f)
            if self.warn_dir:
                self.warn("setup script did not provide a directory for "
                          "'%s' -- installing right in '%s'" %
                          (f, self.install_dir))
            (out, _) = self.copy_file(f, self.install_dir)
            self.outfiles.append(out)
        else:
            # it's a tuple with path to install to and a list of files
            dir = convert_path(f[0])
            if not os.path.isabs(dir):
                dir = os.path.join(self.install_dir, dir)
            elif self.root:
                dir = change_root(self.root, dir)
            self.mkpath(dir)

            if f[1] == []:
                # If there are no files listed, the user must be
                # trying to create an empty directory, so add the
                # directory to the list of output files.
                self.outfiles.append(dir)
            else:
                # Copy files, adding them to the list of output files.
                for data in f[1]:
                    data = convert_path(data)
                    (out, _) = self.copy_file(data, dir)
                    self.outfiles.append(out)

</t>
<t tx="ekr.20080401090728.157">def get_inputs (self):
    return self.data_files or []

</t>
<t tx="ekr.20080401090728.158">def get_outputs (self):
    return self.outfiles
</t>
<t tx="ekr.20080401090728.159">"""distutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata."""


from distutils.cmd import Command
from distutils import log, dir_util
import os, sys, re

</t>
<t tx="ekr.20080401090728.160">class install_egg_info(Command):
    """Install an .egg-info file for the package"""

    description = "Install package's PKG-INFO metadata as an .egg-info file"
    user_options = [
        ('install-dir=', 'd', "directory to install to"),
    ]

    @others
</t>
<t tx="ekr.20080401090728.161">def initialize_options(self):
    self.install_dir = None

</t>
<t tx="ekr.20080401090728.162">def finalize_options(self):
    self.set_undefined_options('install_lib',('install_dir','install_dir'))
    basename = "%s-%s-py%s.egg-info" % (
        to_filename(safe_name(self.distribution.get_name())),
        to_filename(safe_version(self.distribution.get_version())),
        sys.version[:3]
    )
    self.target = os.path.join(self.install_dir, basename)
    self.outputs = [self.target]

</t>
<t tx="ekr.20080401090728.163">def run(self):
    target = self.target
    if os.path.isdir(target) and not os.path.islink(target):
        dir_util.remove_tree(target, dry_run=self.dry_run)
    elif os.path.exists(target):
        self.execute(os.unlink,(self.target,),"Removing "+target)
    log.info("Writing %s", target)
    if not self.dry_run:
        f = open(target, 'w')
        self.distribution.metadata.write_pkg_file(f)
        f.close()

</t>
<t tx="ekr.20080401090728.164">def get_outputs(self):
    return self.outputs


</t>
<t tx="ekr.20080401090728.165"># The following routines are taken from setuptools' pkg_resources module and
# can be replaced by importing them from pkg_resources once it is included
# in the stdlib.

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


</t>
<t tx="ekr.20080401090728.166">def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


</t>
<t tx="ekr.20080401090728.167">def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')
</t>
<t tx="ekr.20080401090728.168">"""distutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: install_headers.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from distutils.core import Command


</t>
<t tx="ekr.20080401090728.169">class install_headers (Command):

    description = "install C/C++ header files"

    user_options = [('install-dir=', 'd',
                     "directory to install header files to"),
                    ('force', 'f',
                     "force installation (overwrite existing files)"),
                   ]

    boolean_options = ['force']

    @others
</t>
<t tx="ekr.20080401090728.170">def initialize_options (self):
    self.install_dir = None
    self.force = 0
    self.outfiles = []

</t>
<t tx="ekr.20080401090728.171">def finalize_options (self):
    self.set_undefined_options('install',
                               ('install_headers', 'install_dir'),
                               ('force', 'force'))


</t>
<t tx="ekr.20080401090728.172">def run (self):
    headers = self.distribution.headers
    if not headers:
        return

    self.mkpath(self.install_dir)
    for header in headers:
        (out, _) = self.copy_file(header, self.install_dir)
        self.outfiles.append(out)

</t>
<t tx="ekr.20080401090728.173">def get_inputs (self):
    return self.distribution.headers or []

</t>
<t tx="ekr.20080401090728.174">def get_outputs (self):
    return self.outfiles

</t>
<t tx="ekr.20080401090728.175"># This module should be kept compatible with Python 2.1.

__revision__ = "$Id: install_lib.py 37946 2004-12-02 20:14:16Z lemburg $"

import sys, os, string
from types import IntType
from distutils.core import Command
from distutils.errors import DistutilsOptionError


# Extension for Python source files.
if hasattr(os, 'extsep'):
    PYTHON_SOURCE_EXTENSION = os.extsep + "py"
else:
    PYTHON_SOURCE_EXTENSION = ".py"

</t>
<t tx="ekr.20080401090728.176">class install_lib (Command):

    description = "install all Python modules (extensions and pure Python)"

    # The byte-compilation options are a tad confusing.  Here are the
    # possible scenarios:
    #   1) no compilation at all (--no-compile --no-optimize)
    #   2) compile .pyc only (--compile --no-optimize; default)
    #   3) compile .pyc and "level 1" .pyo (--compile --optimize)
    #   4) compile "level 1" .pyo only (--no-compile --optimize)
    #   5) compile .pyc and "level 2" .pyo (--compile --optimize-more)
    #   6) compile "level 2" .pyo only (--no-compile --optimize-more)
    #
    # The UI for this is two option, 'compile' and 'optimize'.
    # 'compile' is strictly boolean, and only decides whether to
    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and
    # decides both whether to generate .pyo files and what level of
    # optimization to use.

    user_options = [
        ('install-dir=', 'd', "directory to install to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('compile', 'c', "compile .py to .pyc [default]"),
        ('no-compile', None, "don't compile .py files"),
        ('optimize=', 'O',
         "also compile with optimization: -O1 for \"python -O\", "
         "-O2 for \"python -OO\", and -O0 to disable [default: -O0]"),
        ('skip-build', None, "skip the build steps"),
        ]

    boolean_options = ['force', 'compile', 'skip-build']
    negative_opt = {'no-compile' : 'compile'}


    @others
</t>
<t tx="ekr.20080401090728.177">def initialize_options (self):
    # let the 'install' command dictate our installation directory
    self.install_dir = None
    self.build_dir = None
    self.force = 0
    self.compile = None
    self.optimize = None
    self.skip_build = None

</t>
<t tx="ekr.20080401090728.178">def finalize_options (self):

    # Get all the information we need to install pure Python modules
    # from the umbrella 'install' command -- build (source) directory,
    # install (target) directory, and whether to compile .py files.
    self.set_undefined_options('install',
                               ('build_lib', 'build_dir'),
                               ('install_lib', 'install_dir'),
                               ('force', 'force'),
                               ('compile', 'compile'),
                               ('optimize', 'optimize'),
                               ('skip_build', 'skip_build'),
                              )

    if self.compile is None:
        self.compile = 1
    if self.optimize is None:
        self.optimize = 0

    if type(self.optimize) is not IntType:
        try:
            self.optimize = int(self.optimize)
            assert 0 &lt;= self.optimize &lt;= 2
        except (ValueError, AssertionError):
            raise DistutilsOptionError, "optimize must be 0, 1, or 2"

</t>
<t tx="ekr.20080401090728.179">def run (self):

    # Make sure we have built everything we need first
    self.build()

    # Install everything: simply dump the entire contents of the build
    # directory to the installation directory (that's the beauty of
    # having a build directory!)
    outfiles = self.install()

    # (Optionally) compile .py to .pyc
    if outfiles is not None and self.distribution.has_pure_modules():
        self.byte_compile(outfiles)

</t>
<t tx="ekr.20080401090728.180"># run ()


# -- Top-level worker functions ------------------------------------
# (called from 'run()')

def build (self):
    if not self.skip_build:
        if self.distribution.has_pure_modules():
            self.run_command('build_py')
        if self.distribution.has_ext_modules():
            self.run_command('build_ext')

</t>
<t tx="ekr.20080401090728.181">def install (self):
    if os.path.isdir(self.build_dir):
        outfiles = self.copy_tree(self.build_dir, self.install_dir)
    else:
        self.warn("'%s' does not exist -- no Python modules to install" %
                  self.build_dir)
        return
    return outfiles

</t>
<t tx="ekr.20080401090728.182">def byte_compile (self, files):
    from distutils.util import byte_compile

    # Get the "--root" directory supplied to the "install" command,
    # and use it as a prefix to strip off the purported filename
    # encoded in bytecode files.  This is far from complete, but it
    # should at least generate usable bytecode in RPM distributions.
    install_root = self.get_finalized_command('install').root

    if self.compile:
        byte_compile(files, optimize=0,
                     force=self.force, prefix=install_root,
                     dry_run=self.dry_run)
    if self.optimize &gt; 0:
        byte_compile(files, optimize=self.optimize,
                     force=self.force, prefix=install_root,
                     verbose=self.verbose, dry_run=self.dry_run)


</t>
<t tx="ekr.20080401090728.183"># -- Utility methods -----------------------------------------------

def _mutate_outputs (self, has_any, build_cmd, cmd_option, output_dir):

    if not has_any:
        return []

    build_cmd = self.get_finalized_command(build_cmd)
    build_files = build_cmd.get_outputs()
    build_dir = getattr(build_cmd, cmd_option)

    prefix_len = len(build_dir) + len(os.sep)
    outputs = []
    for file in build_files:
        outputs.append(os.path.join(output_dir, file[prefix_len:]))

    return outputs

</t>
<t tx="ekr.20080401090728.184"># _mutate_outputs ()

def _bytecode_filenames (self, py_filenames):
    bytecode_files = []
    for py_file in py_filenames:
        # Since build_py handles package data installation, the
        # list of outputs can contain more than just .py files.
        # Make sure we only report bytecode for the .py files.
        ext = os.path.splitext(os.path.normcase(py_file))[1]
        if ext != PYTHON_SOURCE_EXTENSION:
            continue
        if self.compile:
            bytecode_files.append(py_file + "c")
        if self.optimize &gt; 0:
            bytecode_files.append(py_file + "o")

    return bytecode_files


</t>
<t tx="ekr.20080401090728.185"># -- External interface --------------------------------------------
# (called by outsiders)

def get_outputs (self):
    """Return the list of files that would be installed if this command
    were actually run.  Not affected by the "dry-run" flag or whether
    modules have actually been built yet.
    """
    pure_outputs = \
        self._mutate_outputs(self.distribution.has_pure_modules(),
                             'build_py', 'build_lib',
                             self.install_dir)
    if self.compile:
        bytecode_outputs = self._bytecode_filenames(pure_outputs)
    else:
        bytecode_outputs = []

    ext_outputs = \
        self._mutate_outputs(self.distribution.has_ext_modules(),
                             'build_ext', 'build_lib',
                             self.install_dir)

    return pure_outputs + bytecode_outputs + ext_outputs

</t>
<t tx="ekr.20080401090728.186"># get_outputs ()

def get_inputs (self):
    """Get the list of files that are input to this command, ie. the
    files that get installed as they are named in the build tree.
    The files in this list correspond one-to-one to the output
    filenames returned by 'get_outputs()'.
    """
    inputs = []

    if self.distribution.has_pure_modules():
        build_py = self.get_finalized_command('build_py')
        inputs.extend(build_py.get_outputs())

    if self.distribution.has_ext_modules():
        build_ext = self.get_finalized_command('build_ext')
        inputs.extend(build_ext.get_outputs())

    return inputs

</t>
<t tx="ekr.20080401090728.187">"""distutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts."""

# contributed by Bastian Kleineidam

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: install_scripts.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from distutils.core import Command
from distutils import log
from stat import ST_MODE

</t>
<t tx="ekr.20080401090728.188">class install_scripts (Command):

    description = "install scripts (Python or otherwise)"

    user_options = [
        ('install-dir=', 'd', "directory to install scripts to"),
        ('build-dir=','b', "build directory (where to install from)"),
        ('force', 'f', "force installation (overwrite existing files)"),
        ('skip-build', None, "skip the build steps"),
    ]

    boolean_options = ['force', 'skip-build']


    @others
</t>
<t tx="ekr.20080401090728.189">def initialize_options (self):
    self.install_dir = None
    self.force = 0
    self.build_dir = None
    self.skip_build = None

</t>
<t tx="ekr.20080401090728.190">def finalize_options (self):
    self.set_undefined_options('build', ('build_scripts', 'build_dir'))
    self.set_undefined_options('install',
                               ('install_scripts', 'install_dir'),
                               ('force', 'force'),
                               ('skip_build', 'skip_build'),
                              )

</t>
<t tx="ekr.20080401090728.191">def run (self):
    if not self.skip_build:
        self.run_command('build_scripts')
    self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
    if os.name == 'posix':
        # Set the executable bits (owner, group, and world) on
        # all the scripts we just installed.
        for file in self.get_outputs():
            if self.dry_run:
                log.info("changing mode of %s", file)
            else:
                mode = ((os.stat(file)[ST_MODE]) | 0555) &amp; 07777
                log.info("changing mode of %s to %o", file, mode)
                os.chmod(file, mode)

</t>
<t tx="ekr.20080401090728.192">def get_inputs (self):
    return self.distribution.scripts or []

</t>
<t tx="ekr.20080401090728.193">def get_outputs(self):
    return self.outfiles or []

</t>
<t tx="ekr.20080401090728.194">"""distutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: sdist.py 38697 2005-03-23 18:54:36Z loewis $"

import sys, os, string
from types import *
from glob import glob
from distutils.core import Command
from distutils import dir_util, dep_util, file_util, archive_util
from distutils.text_file import TextFile
from distutils.errors import *
from distutils.filelist import FileList
from distutils import log


</t>
<t tx="ekr.20080401090728.195">def show_formats ():
    """Print all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    """
    from distutils.fancy_getopt import FancyGetopt
    from distutils.archive_util import ARCHIVE_FORMATS
    formats=[]
    for format in ARCHIVE_FORMATS.keys():
        formats.append(("formats=" + format, None,
                        ARCHIVE_FORMATS[format][2]))
    formats.sort()
    pretty_printer = FancyGetopt(formats)
    pretty_printer.print_help(
        "List of available source distribution formats:")

</t>
<t tx="ekr.20080401090728.196">class sdist (Command):

    description = "create a source distribution (tarball, zip file, etc.)"

    user_options = [
        ('template=', 't',
         "name of manifest template file [default: MANIFEST.in]"),
        ('manifest=', 'm',
         "name of manifest file [default: MANIFEST]"),
        ('use-defaults', None,
         "include the default file set in the manifest "
         "[default; disable with --no-defaults]"),
        ('no-defaults', None,
         "don't include the default file set"),
        ('prune', None,
         "specifically exclude files/directories that should not be "
         "distributed (build tree, RCS/CVS dirs, etc.) "
         "[default; disable with --no-prune]"),
        ('no-prune', None,
         "don't automatically exclude anything"),
        ('manifest-only', 'o',
         "just regenerate the manifest and then stop "
         "(implies --force-manifest)"),
        ('force-manifest', 'f',
         "forcibly regenerate the manifest and carry on as usual"),
        ('formats=', None,
         "formats for source distribution (comma-separated list)"),
        ('keep-temp', 'k',
         "keep the distribution tree around after creating " +
         "archive file(s)"),
        ('dist-dir=', 'd',
         "directory to put the source distribution archive(s) in "
         "[default: dist]"),
        ]

    boolean_options = ['use-defaults', 'prune',
                       'manifest-only', 'force-manifest',
                       'keep-temp']

    help_options = [
        ('help-formats', None,
         "list available distribution formats", show_formats),
        ]

    negative_opt = {'no-defaults': 'use-defaults',
                    'no-prune': 'prune' }

    default_format = { 'posix': 'gztar',
                       'nt': 'zip' }

    @others
</t>
<t tx="ekr.20080401090728.197">def initialize_options (self):
    # 'template' and 'manifest' are, respectively, the names of
    # the manifest template and manifest file.
    self.template = None
    self.manifest = None

    # 'use_defaults': if true, we will include the default file set
    # in the manifest
    self.use_defaults = 1
    self.prune = 1

    self.manifest_only = 0
    self.force_manifest = 0

    self.formats = None
    self.keep_temp = 0
    self.dist_dir = None

    self.archive_files = None


</t>
<t tx="ekr.20080401090728.198">def finalize_options (self):
    if self.manifest is None:
        self.manifest = "MANIFEST"
    if self.template is None:
        self.template = "MANIFEST.in"

    self.ensure_string_list('formats')
    if self.formats is None:
        try:
            self.formats = [self.default_format[os.name]]
        except KeyError:
            raise DistutilsPlatformError, \
                  "don't know how to create source distributions " + \
                  "on platform %s" % os.name

    bad_format = archive_util.check_archive_formats(self.formats)
    if bad_format:
        raise DistutilsOptionError, \
              "unknown archive format '%s'" % bad_format

    if self.dist_dir is None:
        self.dist_dir = "dist"


</t>
<t tx="ekr.20080401090728.199">def run (self):

    # 'filelist' contains the list of files that will make up the
    # manifest
    self.filelist = FileList()

    # Ensure that all required meta-data is given; warn if not (but
    # don't die, it's not *that* serious!)
    self.check_metadata()

    # Do whatever it takes to get the list of files to process
    # (process the manifest template, read an existing manifest,
    # whatever).  File list is accumulated in 'self.filelist'.
    self.get_file_list()

    # If user just wanted us to regenerate the manifest, stop now.
    if self.manifest_only:
        return

    # Otherwise, go ahead and create the source distribution tarball,
    # or zipfile, or whatever.
    self.make_distribution()


</t>
<t tx="ekr.20080401090728.200">def check_metadata (self):
    """Ensure that all required elements of meta-data (name, version,
    URL, (author and author_email) or (maintainer and
    maintainer_email)) are supplied by the Distribution object; warn if
    any are missing.
    """
    metadata = self.distribution.metadata

    missing = []
    for attr in ('name', 'version', 'url'):
        if not (hasattr(metadata, attr) and getattr(metadata, attr)):
            missing.append(attr)

    if missing:
        self.warn("missing required meta-data: " +
                  string.join(missing, ", "))

    if metadata.author:
        if not metadata.author_email:
            self.warn("missing meta-data: if 'author' supplied, " +
                      "'author_email' must be supplied too")
    elif metadata.maintainer:
        if not metadata.maintainer_email:
            self.warn("missing meta-data: if 'maintainer' supplied, " +
                      "'maintainer_email' must be supplied too")
    else:
        self.warn("missing meta-data: either (author and author_email) " +
                  "or (maintainer and maintainer_email) " +
                  "must be supplied")

</t>
<t tx="ekr.20080401090728.201"># check_metadata ()


def get_file_list (self):
    """Figure out the list of files to include in the source
    distribution, and put it in 'self.filelist'.  This might involve
    reading the manifest template (and writing the manifest), or just
    reading the manifest, or just using the default file set -- it all
    depends on the user's options and the state of the filesystem.
    """

    # If we have a manifest template, see if it's newer than the
    # manifest; if so, we'll regenerate the manifest.
    template_exists = os.path.isfile(self.template)
    if template_exists:
        template_newer = dep_util.newer(self.template, self.manifest)

    # The contents of the manifest file almost certainly depend on the
    # setup script as well as the manifest template -- so if the setup
    # script is newer than the manifest, we'll regenerate the manifest
    # from the template.  (Well, not quite: if we already have a
    # manifest, but there's no template -- which will happen if the
    # developer elects to generate a manifest some other way -- then we
    # can't regenerate the manifest, so we don't.)
    self.debug_print("checking if %s newer than %s" %
                     (self.distribution.script_name, self.manifest))
    setup_newer = dep_util.newer(self.distribution.script_name,
                                 self.manifest)

    # cases:
    #   1) no manifest, template exists: generate manifest
    #      (covered by 2a: no manifest == template newer)
    #   2) manifest &amp; template exist:
    #      2a) template or setup script newer than manifest:
    #          regenerate manifest
    #      2b) manifest newer than both:
    #          do nothing (unless --force or --manifest-only)
    #   3) manifest exists, no template:
    #      do nothing (unless --force or --manifest-only)
    #   4) no manifest, no template: generate w/ warning ("defaults only")

    manifest_outofdate = (template_exists and
                          (template_newer or setup_newer))
    force_regen = self.force_manifest or self.manifest_only
    manifest_exists = os.path.isfile(self.manifest)
    neither_exists = (not template_exists and not manifest_exists)

    # Regenerate the manifest if necessary (or if explicitly told to)
    if manifest_outofdate or neither_exists or force_regen:
        if not template_exists:
            self.warn(("manifest template '%s' does not exist " +
                       "(using default file list)") %
                      self.template)
        self.filelist.findall()

        if self.use_defaults:
            self.add_defaults()
        if template_exists:
            self.read_template()
        if self.prune:
            self.prune_file_list()

        self.filelist.sort()
        self.filelist.remove_duplicates()
        self.write_manifest()

    # Don't regenerate the manifest, just read it in.
    else:
        self.read_manifest()

</t>
<t tx="ekr.20080401090728.202"># get_file_list ()


def add_defaults (self):
    """Add all the default files to self.filelist:
      - README or README.txt
      - setup.py
      - test/test*.py
      - all pure Python modules mentioned in setup script
      - all C sources listed as part of extensions or C libraries
        in the setup script (doesn't catch C headers!)
    Warns if (README or README.txt) or setup.py are missing; everything
    else is optional.
    """

    standards = [('README', 'README.txt'), self.distribution.script_name]
    for fn in standards:
        if type(fn) is TupleType:
            alts = fn
            got_it = 0
            for fn in alts:
                if os.path.exists(fn):
                    got_it = 1
                    self.filelist.append(fn)
                    break

            if not got_it:
                self.warn("standard file not found: should have one of " +
                          string.join(alts, ', '))
        else:
            if os.path.exists(fn):
                self.filelist.append(fn)
            else:
                self.warn("standard file '%s' not found" % fn)

    optional = ['test/test*.py', 'setup.cfg']
    for pattern in optional:
        files = filter(os.path.isfile, glob(pattern))
        if files:
            self.filelist.extend(files)

    if self.distribution.has_pure_modules():
        build_py = self.get_finalized_command('build_py')
        self.filelist.extend(build_py.get_source_files())

    if self.distribution.has_ext_modules():
        build_ext = self.get_finalized_command('build_ext')
        self.filelist.extend(build_ext.get_source_files())

    if self.distribution.has_c_libraries():
        build_clib = self.get_finalized_command('build_clib')
        self.filelist.extend(build_clib.get_source_files())

    if self.distribution.has_scripts():
        build_scripts = self.get_finalized_command('build_scripts')
        self.filelist.extend(build_scripts.get_source_files())

</t>
<t tx="ekr.20080401090728.203"># add_defaults ()


def read_template (self):
    """Read and parse manifest template file named by self.template.

    (usually "MANIFEST.in") The parsing and processing is done by
    'self.filelist', which updates itself accordingly.
    """
    log.info("reading manifest template '%s'", self.template)
    template = TextFile(self.template,
                        strip_comments=1,
                        skip_blanks=1,
                        join_lines=1,
                        lstrip_ws=1,
                        rstrip_ws=1,
                        collapse_join=1)

    while 1:
        line = template.readline()
        if line is None:            # end of file
            break

        try:
            self.filelist.process_template_line(line)
        except DistutilsTemplateError, msg:
            self.warn("%s, line %d: %s" % (template.filename,
                                           template.current_line,
                                           msg))

</t>
<t tx="ekr.20080401090728.204"># read_template ()


def prune_file_list (self):
    """Prune off branches that might slip into the file list as created
    by 'read_template()', but really don't belong there:
      * the build tree (typically "build")
      * the release tree itself (only an issue if we ran "sdist"
        previously with --keep-temp, or it aborted)
      * any RCS, CVS and .svn directories
    """
    build = self.get_finalized_command('build')
    base_dir = self.distribution.get_fullname()

    self.filelist.exclude_pattern(None, prefix=build.build_base)
    self.filelist.exclude_pattern(None, prefix=base_dir)
    self.filelist.exclude_pattern(r'/(RCS|CVS|\.svn)/.*', is_regex=1)


</t>
<t tx="ekr.20080401090728.205">def write_manifest (self):
    """Write the file list in 'self.filelist' (presumably as filled in
    by 'add_defaults()' and 'read_template()') to the manifest file
    named by 'self.manifest'.
    """
    self.execute(file_util.write_file,
                 (self.manifest, self.filelist.files),
                 "writing manifest file '%s'" % self.manifest)

</t>
<t tx="ekr.20080401090728.206"># write_manifest ()


def read_manifest (self):
    """Read the manifest file (named by 'self.manifest') and use it to
    fill in 'self.filelist', the list of files to include in the source
    distribution.
    """
    log.info("reading manifest file '%s'", self.manifest)
    manifest = open(self.manifest)
    while 1:
        line = manifest.readline()
        if line == '':              # end of file
            break
        if line[-1] == '\n':
            line = line[0:-1]
        self.filelist.append(line)

</t>
<t tx="ekr.20080401090728.207"># read_manifest ()


def make_release_tree (self, base_dir, files):
    """Create the directory tree that will become the source
    distribution archive.  All directories implied by the filenames in
    'files' are created under 'base_dir', and then we hard link or copy
    (if hard linking is unavailable) those files into place.
    Essentially, this duplicates the developer's source tree, but in a
    directory named after the distribution, containing only the files
    to be distributed.
    """
    # Create all the directories under 'base_dir' necessary to
    # put 'files' there; the 'mkpath()' is just so we don't die
    # if the manifest happens to be empty.
    self.mkpath(base_dir)
    dir_util.create_tree(base_dir, files, dry_run=self.dry_run)

    # And walk over the list of files, either making a hard link (if
    # os.link exists) to each one that doesn't already exist in its
    # corresponding location under 'base_dir', or copying each file
    # that's out-of-date in 'base_dir'.  (Usually, all files will be
    # out-of-date, because by default we blow away 'base_dir' when
    # we're done making the distribution archives.)

    if hasattr(os, 'link'):        # can make hard links on this system
        link = 'hard'
        msg = "making hard links in %s..." % base_dir
    else:                           # nope, have to copy
        link = None
        msg = "copying files to %s..." % base_dir

    if not files:
        log.warn("no files to distribute -- empty manifest?")
    else:
        log.info(msg)
    for file in files:
        if not os.path.isfile(file):
            log.warn("'%s' not a regular file -- skipping" % file)
        else:
            dest = os.path.join(base_dir, file)
            self.copy_file(file, dest, link=link)

    self.distribution.metadata.write_pkg_info(base_dir)

</t>
<t tx="ekr.20080401090728.208"># make_release_tree ()

def make_distribution (self):
    """Create the source distribution(s).  First, we create the release
    tree with 'make_release_tree()'; then, we create all required
    archive files (according to 'self.formats') from the release tree.
    Finally, we clean up by blowing away the release tree (unless
    'self.keep_temp' is true).  The list of archive files created is
    stored so it can be retrieved later by 'get_archive_files()'.
    """
    # Don't warn about missing meta-data here -- should be (and is!)
    # done elsewhere.
    base_dir = self.distribution.get_fullname()
    base_name = os.path.join(self.dist_dir, base_dir)

    self.make_release_tree(base_dir, self.filelist.files)
    archive_files = []              # remember names of files we create
    for fmt in self.formats:
        file = self.make_archive(base_name, fmt, base_dir=base_dir)
        archive_files.append(file)
        self.distribution.dist_files.append(('sdist', '', file))

    self.archive_files = archive_files

    if not self.keep_temp:
        dir_util.remove_tree(base_dir, dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090728.209">def get_archive_files (self):
    """Return the list of archive files created when the command
    was run, or None if the command hasn't run yet.
    """
    return self.archive_files

</t>
<t tx="ekr.20080401090728.210">"""distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI)."""

from distutils.errors import *
from distutils.core import Command
from distutils.spawn import spawn
from distutils import log
from hashlib import md5
import os
import socket
import platform
import ConfigParser
import httplib
import base64
import urlparse
import cStringIO as StringIO

</t>
<t tx="ekr.20080401090728.211">class upload(Command):

    description = "upload binary package to PyPI"

    DEFAULT_REPOSITORY = 'http://www.python.org/pypi'

    user_options = [
        ('repository=', 'r',
         "url of repository [default: %s]" % DEFAULT_REPOSITORY),
        ('show-response', None,
         'display full response text from server'),
        ('sign', 's',
         'sign files to upload using gpg'),
        ('identity=', 'i', 'GPG identity used to sign files'),
        ]
    boolean_options = ['show-response', 'sign']

    @others
</t>
<t tx="ekr.20080401090728.212">def initialize_options(self):
    self.username = ''
    self.password = ''
    self.repository = ''
    self.show_response = 0
    self.sign = False
    self.identity = None

</t>
<t tx="ekr.20080401090728.213">def finalize_options(self):
    if self.identity and not self.sign:
        raise DistutilsOptionError(
            "Must use --sign for --identity to have meaning"
        )
    if os.environ.has_key('HOME'):
        rc = os.path.join(os.environ['HOME'], '.pypirc')
        if os.path.exists(rc):
            self.announce('Using PyPI login from %s' % rc)
            config = ConfigParser.ConfigParser({
                    'username':'',
                    'password':'',
                    'repository':''})
            config.read(rc)
            if not self.repository:
                self.repository = config.get('server-login', 'repository')
            if not self.username:
                self.username = config.get('server-login', 'username')
            if not self.password:
                self.password = config.get('server-login', 'password')
    if not self.repository:
        self.repository = self.DEFAULT_REPOSITORY

</t>
<t tx="ekr.20080401090728.214">def run(self):
    if not self.distribution.dist_files:
        raise DistutilsOptionError("No dist file created in earlier command")
    for command, pyversion, filename in self.distribution.dist_files:
        self.upload_file(command, pyversion, filename)

</t>
<t tx="ekr.20080401090728.215">def upload_file(self, command, pyversion, filename):
    # Sign if requested
    if self.sign:
        gpg_args = ["gpg", "--detach-sign", "-a", filename]
        if self.identity:
            gpg_args[2:2] = ["--local-user", self.identity]
        spawn(gpg_args,
              dry_run=self.dry_run)

    # Fill in the data - send all the meta-data in case we need to
    # register a new release
    content = open(filename,'rb').read()
    meta = self.distribution.metadata
    data = {
        # action
        ':action': 'file_upload',
        'protcol_version': '1',

        # identify release
        'name': meta.get_name(),
        'version': meta.get_version(),

        # file content
        'content': (os.path.basename(filename),content),
        'filetype': command,
        'pyversion': pyversion,
        'md5_digest': md5(content).hexdigest(),

        # additional meta-data
        'metadata_version' : '1.0',
        'summary': meta.get_description(),
        'home_page': meta.get_url(),
        'author': meta.get_contact(),
        'author_email': meta.get_contact_email(),
        'license': meta.get_licence(),
        'description': meta.get_long_description(),
        'keywords': meta.get_keywords(),
        'platform': meta.get_platforms(),
        'classifiers': meta.get_classifiers(),
        'download_url': meta.get_download_url(),
        # PEP 314
        'provides': meta.get_provides(),
        'requires': meta.get_requires(),
        'obsoletes': meta.get_obsoletes(),
        }
    comment = ''
    if command == 'bdist_rpm':
        dist, version, id = platform.dist()
        if dist:
            comment = 'built for %s %s' % (dist, version)
    elif command == 'bdist_dumb':
        comment = 'built for %s' % platform.platform(terse=1)
    data['comment'] = comment

    if self.sign:
        data['gpg_signature'] = (os.path.basename(filename) + ".asc",
                                 open(filename+".asc").read())

    # set up the authentication
    auth = "Basic " + base64.encodestring(self.username + ":" + self.password).strip()

    # Build up the MIME payload for the POST data
    boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
    sep_boundary = '\n--' + boundary
    end_boundary = sep_boundary + '--'
    body = StringIO.StringIO()
    for key, value in data.items():
        # handle multiple entries for the same name
        if type(value) != type([]):
            value = [value]
        for value in value:
            if type(value) is tuple:
                fn = ';filename="%s"' % value[0]
                value = value[1]
            else:
                fn = ""
            value = str(value)
            body.write(sep_boundary)
            body.write('\nContent-Disposition: form-data; name="%s"'%key)
            body.write(fn)
            body.write("\n\n")
            body.write(value)
            if value and value[-1] == '\r':
                body.write('\n')  # write an extra newline (lurve Macs)
    body.write(end_boundary)
    body.write("\n")
    body = body.getvalue()

    self.announce("Submitting %s to %s" % (filename, self.repository), log.INFO)

    # build the Request
    # We can't use urllib2 since we need to send the Basic
    # auth right with the first request
    schema, netloc, url, params, query, fragments = \
        urlparse.urlparse(self.repository)
    assert not params and not query and not fragments
    if schema == 'http':
        http = httplib.HTTPConnection(netloc)
    elif schema == 'https':
        http = httplib.HTTPSConnection(netloc)
    else:
        raise AssertionError, "unsupported schema "+schema

    data = ''
    loglevel = log.INFO
    try:
        http.connect()
        http.putrequest("POST", url)
        http.putheader('Content-type',
                       'multipart/form-data; boundary=%s'%boundary)
        http.putheader('Content-length', str(len(body)))
        http.putheader('Authorization', auth)
        http.endheaders()
        http.send(body)
    except socket.error, e:
        self.announce(str(e), log.ERROR)
        return

    r = http.getresponse()
    if r.status == 200:
        self.announce('Server response (%s): %s' % (r.status, r.reason),
                      log.INFO)
    else:
        self.announce('Upload failed (%s): %s' % (r.status, r.reason),
                      log.ERROR)
    if self.show_response:
        print '-'*75, r.read(), '-'*75
</t>
<t tx="ekr.20080401090728.216">"""distutils.command

Package containing implementation of all the standard Distutils
commands."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: __init__.py 37828 2004-11-10 22:23:15Z loewis $"

__all__ = ['build',
           'build_py',
           'build_ext',
           'build_clib',
           'build_scripts',
           'clean',
           'install',
           'install_lib',
           'install_headers',
           'install_scripts',
           'install_data',
           'sdist',
           'register',
           'bdist',
           'bdist_dumb',
           'bdist_rpm',
           'bdist_wininst',
           # These two are reserved for future use:
           #'bdist_sdux',
           #'bdist_pkgtool',
           # Note:
           # bdist_packager is not included because it only provides
           # an abstract base class
          ]
</t>
<t tx="ekr.20080401090728.217">"""distutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing)."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: archive_util.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from distutils.errors import DistutilsExecError
from distutils.spawn import spawn
from distutils.dir_util import mkpath
from distutils import log

</t>
<t tx="ekr.20080401090728.218">def make_tarball (base_name, base_dir, compress="gzip",
                  verbose=0, dry_run=0):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.  'compress' must be "gzip" (the default), "compress",
    "bzip2", or None.  Both "tar" and the compression utility named by
    'compress' must be on the default program search path, so this is
    probably Unix-specific.  The output tar file will be named 'base_dir' +
    ".tar", possibly plus the appropriate compression extension (".gz",
    ".bz2" or ".Z").  Return the output filename.
    """
    # XXX GNU tar 1.13 has a nifty option to add a prefix directory.
    # It's pretty new, though, so we certainly can't require it --
    # but it would be nice to take advantage of it to skip the
    # "create a tree of hardlinks" step!  (Would also be nice to
    # detect GNU tar to use its 'z' option and save a step.)

    compress_ext = { 'gzip': ".gz",
                     'bzip2': '.bz2',
                     'compress': ".Z" }

    # flags for compression program, each element of list will be an argument
    compress_flags = {'gzip': ["-f9"],
                      'compress': ["-f"],
                      'bzip2': ['-f9']}

    if compress is not None and compress not in compress_ext.keys():
        raise ValueError, \
              "bad value for 'compress': must be None, 'gzip', or 'compress'"

    archive_name = base_name + ".tar"
    mkpath(os.path.dirname(archive_name), dry_run=dry_run)
    cmd = ["tar", "-cf", archive_name, base_dir]
    spawn(cmd, dry_run=dry_run)

    if compress:
        spawn([compress] + compress_flags[compress] + [archive_name],
              dry_run=dry_run)
        return archive_name + compress_ext[compress]
    else:
        return archive_name

</t>
<t tx="ekr.20080401090728.219"># make_tarball ()


def make_zipfile (base_name, base_dir, verbose=0, dry_run=0):
    """Create a zip file from all the files under 'base_dir'.  The output
    zip file will be named 'base_dir' + ".zip".  Uses either the "zipfile"
    Python module (if available) or the InfoZIP "zip" utility (if installed
    and found on the default search path).  If neither tool is available,
    raises DistutilsExecError.  Returns the name of the output zip file.
    """
    try:
        import zipfile
    except ImportError:
        zipfile = None

    zip_filename = base_name + ".zip"
    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)

    # If zipfile module is not available, try spawning an external
    # 'zip' command.
    if zipfile is None:
        if verbose:
            zipoptions = "-r"
        else:
            zipoptions = "-rq"

        try:
            spawn(["zip", zipoptions, zip_filename, base_dir],
                  dry_run=dry_run)
        except DistutilsExecError:
            # XXX really should distinguish between "couldn't find
            # external 'zip' command" and "zip failed".
            raise DistutilsExecError, \
                  ("unable to create zip file '%s': "
                   "could neither import the 'zipfile' module nor "
                   "find a standalone zip utility") % zip_filename

    else:
        log.info("creating '%s' and adding '%s' to it",
                 zip_filename, base_dir)

        def visit (z, dirname, names):
            for name in names:
                path = os.path.normpath(os.path.join(dirname, name))
                if os.path.isfile(path):
                    z.write(path, path)
                    log.info("adding '%s'" % path)

        if not dry_run:
            z = zipfile.ZipFile(zip_filename, "w",
                                compression=zipfile.ZIP_DEFLATED)

            os.path.walk(base_dir, visit, z)
            z.close()

    return zip_filename

</t>
<t tx="ekr.20080401090728.220"># make_zipfile ()


ARCHIVE_FORMATS = {
    'gztar': (make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'ztar':  (make_tarball, [('compress', 'compress')], "compressed tar file"),
    'tar':   (make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (make_zipfile, [],"ZIP file")
    }

def check_archive_formats (formats):
    for format in formats:
        if not ARCHIVE_FORMATS.has_key(format):
            return format
    else:
        return None

</t>
<t tx="ekr.20080401090728.221">def make_archive (base_name, format,
                  root_dir=None, base_dir=None,
                  verbose=0, dry_run=0):
    """Create an archive file (eg. zip or tar).  'base_name' is the name
    of the file to create, minus any format-specific extension; 'format'
    is the archive format: one of "zip", "tar", "ztar", or "gztar".
    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        log.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = { 'dry_run': dry_run }

    try:
        format_info = ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError, "unknown archive format '%s'" % format

    func = format_info[0]
    for (arg,val) in format_info[1]:
        kwargs[arg] = val
    filename = apply(func, (base_name, base_dir), kwargs)

    if root_dir is not None:
        log.debug("changing back to '%s'", save_cwd)
        os.chdir(save_cwd)

    return filename

</t>
<t tx="ekr.20080401090728.222">"""distutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
"""

# This implementation by Lyle Johnson, based on the original msvccompiler.py
# module and using the directions originally published by Gordon Williams.

# XXX looks like there's a LOT of overlap between these two classes:
# someone should sit down and factor out the common code as
# WindowsCCompiler!  --GPW

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: bcppcompiler.py 37828 2004-11-10 22:23:15Z loewis $"


import sys, os
from distutils.errors import \
     DistutilsExecError, DistutilsPlatformError, \
     CompileError, LibError, LinkError, UnknownFileError
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
from distutils.file_util import write_file
from distutils.dep_util import newer
from distutils import log

</t>
<t tx="ekr.20080401090728.223">class BCPPCompiler(CCompiler) :
    """Concrete class that implements an interface to the Borland C/C++
    compiler, as defined by the CCompiler abstract class.
    """

    compiler_type = 'bcpp'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = _c_extensions + _cpp_extensions
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'


    @others
    # preprocess()
</t>
<t tx="ekr.20080401090728.224">def __init__ (self,
              verbose=0,
              dry_run=0,
              force=0):

    CCompiler.__init__ (self, verbose, dry_run, force)

    # These executables are assumed to all be in the path.
    # Borland doesn't seem to use any special registry settings to
    # indicate their installation locations.

    self.cc = "bcc32.exe"
    self.linker = "ilink32.exe"
    self.lib = "tlib.exe"

    self.preprocess_options = None
    self.compile_options = ['/tWM', '/O2', '/q', '/g0']
    self.compile_options_debug = ['/tWM', '/Od', '/q', '/g0']

    self.ldflags_shared = ['/Tpd', '/Gn', '/q', '/x']
    self.ldflags_shared_debug = ['/Tpd', '/Gn', '/q', '/x']
    self.ldflags_static = []
    self.ldflags_exe = ['/Gn', '/q', '/x']
    self.ldflags_exe_debug = ['/Gn', '/q', '/x','/r']


</t>
<t tx="ekr.20080401090728.225"># -- Worker methods ------------------------------------------------

def compile(self, sources,
            output_dir=None, macros=None, include_dirs=None, debug=0,
            extra_preargs=None, extra_postargs=None, depends=None):

    macros, objects, extra_postargs, pp_opts, build = \
            self._setup_compile(output_dir, macros, include_dirs, sources,
                                depends, extra_postargs)
    compile_opts = extra_preargs or []
    compile_opts.append ('-c')
    if debug:
        compile_opts.extend (self.compile_options_debug)
    else:
        compile_opts.extend (self.compile_options)

    for obj in objects:
        try:
            src, ext = build[obj]
        except KeyError:
            continue
        # XXX why do the normpath here?
        src = os.path.normpath(src)
        obj = os.path.normpath(obj)
        # XXX _setup_compile() did a mkpath() too but before the normpath.
        # Is it possible to skip the normpath?
        self.mkpath(os.path.dirname(obj))

        if ext == '.res':
            # This is already a binary file -- skip it.
            continue # the 'for' loop
        if ext == '.rc':
            # This needs to be compiled to a .res file -- do it now.
            try:
                self.spawn (["brcc32", "-fo", obj, src])
            except DistutilsExecError, msg:
                raise CompileError, msg
            continue # the 'for' loop

        # The next two are both for the real compiler.
        if ext in self._c_extensions:
            input_opt = ""
        elif ext in self._cpp_extensions:
            input_opt = "-P"
        else:
            # Unknown file type -- no extra options.  The compiler
            # will probably fail, but let it just in case this is a
            # file the compiler recognizes even if we don't.
            input_opt = ""

        output_opt = "-o" + obj

        # Compiler command line syntax is: "bcc32 [options] file(s)".
        # Note that the source file names must appear at the end of
        # the command line.
        try:
            self.spawn ([self.cc] + compile_opts + pp_opts +
                        [input_opt, output_opt] +
                        extra_postargs + [src])
        except DistutilsExecError, msg:
            raise CompileError, msg

    return objects

</t>
<t tx="ekr.20080401090728.226"># compile ()


def create_static_lib (self,
                       objects,
                       output_libname,
                       output_dir=None,
                       debug=0,
                       target_lang=None):

    (objects, output_dir) = self._fix_object_args (objects, output_dir)
    output_filename = \
        self.library_filename (output_libname, output_dir=output_dir)

    if self._need_link (objects, output_filename):
        lib_args = [output_filename, '/u'] + objects
        if debug:
            pass                    # XXX what goes here?
        try:
            self.spawn ([self.lib] + lib_args)
        except DistutilsExecError, msg:
            raise LibError, msg
    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090728.227"># create_static_lib ()


def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):

    # XXX this ignores 'build_temp'!  should follow the lead of
    # msvccompiler.py

    (objects, output_dir) = self._fix_object_args (objects, output_dir)
    (libraries, library_dirs, runtime_library_dirs) = \
        self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

    if runtime_library_dirs:
        log.warn("I don't know what to do with 'runtime_library_dirs': %s",
                 str(runtime_library_dirs))

    if output_dir is not None:
        output_filename = os.path.join (output_dir, output_filename)

    if self._need_link (objects, output_filename):

        # Figure out linker args based on type of target.
        if target_desc == CCompiler.EXECUTABLE:
            startup_obj = 'c0w32'
            if debug:
                ld_args = self.ldflags_exe_debug[:]
            else:
                ld_args = self.ldflags_exe[:]
        else:
            startup_obj = 'c0d32'
            if debug:
                ld_args = self.ldflags_shared_debug[:]
            else:
                ld_args = self.ldflags_shared[:]


        # Create a temporary exports file for use by the linker
        if export_symbols is None:
            def_file = ''
        else:
            head, tail = os.path.split (output_filename)
            modname, ext = os.path.splitext (tail)
            temp_dir = os.path.dirname(objects[0]) # preserve tree structure
            def_file = os.path.join (temp_dir, '%s.def' % modname)
            contents = ['EXPORTS']
            for sym in (export_symbols or []):
                contents.append('  %s=_%s' % (sym, sym))
            self.execute(write_file, (def_file, contents),
                         "writing %s" % def_file)

        # Borland C++ has problems with '/' in paths
        objects2 = map(os.path.normpath, objects)
        # split objects in .obj and .res files
        # Borland C++ needs them at different positions in the command line
        objects = [startup_obj]
        resources = []
        for file in objects2:
            (base, ext) = os.path.splitext(os.path.normcase(file))
            if ext == '.res':
                resources.append(file)
            else:
                objects.append(file)


        for l in library_dirs:
            ld_args.append("/L%s" % os.path.normpath(l))
        ld_args.append("/L.") # we sometimes use relative paths

        # list of object files
        ld_args.extend(objects)

        # XXX the command-line syntax for Borland C++ is a bit wonky;
        # certain filenames are jammed together in one big string, but
        # comma-delimited.  This doesn't mesh too well with the
        # Unix-centric attitude (with a DOS/Windows quoting hack) of
        # 'spawn()', so constructing the argument list is a bit
        # awkward.  Note that doing the obvious thing and jamming all
        # the filenames and commas into one argument would be wrong,
        # because 'spawn()' would quote any filenames with spaces in
        # them.  Arghghh!.  Apparently it works fine as coded...

        # name of dll/exe file
        ld_args.extend([',',output_filename])
        # no map file and start libraries
        ld_args.append(',,')

        for lib in libraries:
            # see if we find it and if there is a bcpp specific lib
            # (xxx_bcpp.lib)
            libfile = self.find_library_file(library_dirs, lib, debug)
            if libfile is None:
                ld_args.append(lib)
                # probably a BCPP internal library -- don't warn
            else:
                # full name which prefers bcpp_xxx.lib over xxx.lib
                ld_args.append(libfile)

        # some default libraries
        ld_args.append ('import32')
        ld_args.append ('cw32mt')

        # def file for export symbols
        ld_args.extend([',',def_file])
        # add resource files
        ld_args.append(',')
        ld_args.extend(resources)


        if extra_preargs:
            ld_args[:0] = extra_preargs
        if extra_postargs:
            ld_args.extend(extra_postargs)

        self.mkpath (os.path.dirname (output_filename))
        try:
            self.spawn ([self.linker] + ld_args)
        except DistutilsExecError, msg:
            raise LinkError, msg

    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090728.228"># link ()

# -- Miscellaneous methods -----------------------------------------


def find_library_file (self, dirs, lib, debug=0):
    # List of effective library names to try, in order of preference:
    # xxx_bcpp.lib is better than xxx.lib
    # and xxx_d.lib is better than xxx.lib if debug is set
    #
    # The "_bcpp" suffix is to handle a Python installation for people
    # with multiple compilers (primarily Distutils hackers, I suspect
    # ;-).  The idea is they'd have one static library for each
    # compiler they care about, since (almost?) every Windows compiler
    # seems to have a different format for static libraries.
    if debug:
        dlib = (lib + "_d")
        try_names = (dlib + "_bcpp", lib + "_bcpp", dlib, lib)
    else:
        try_names = (lib + "_bcpp", lib)

    for dir in dirs:
        for name in try_names:
            libfile = os.path.join(dir, self.library_filename(name))
            if os.path.exists(libfile):
                return libfile
    else:
        # Oops, didn't find it in *any* of 'dirs'
        return None

</t>
<t tx="ekr.20080401090728.229"># overwrite the one from CCompiler to support rc and res-files
def object_filenames (self,
                      source_filenames,
                      strip_dir=0,
                      output_dir=''):
    if output_dir is None: output_dir = ''
    obj_names = []
    for src_name in source_filenames:
        # use normcase to make sure '.rc' is really '.rc' and not '.RC'
        (base, ext) = os.path.splitext (os.path.normcase(src_name))
        if ext not in (self.src_extensions + ['.rc','.res']):
            raise UnknownFileError, \
                  "unknown file type '%s' (from '%s')" % \
                  (ext, src_name)
        if strip_dir:
            base = os.path.basename (base)
        if ext == '.res':
            # these can go unchanged
            obj_names.append (os.path.join (output_dir, base + ext))
        elif ext == '.rc':
            # these need to be compiled to .res-files
            obj_names.append (os.path.join (output_dir, base + '.res'))
        else:
            obj_names.append (os.path.join (output_dir,
                                        base + self.obj_extension))
    return obj_names

</t>
<t tx="ekr.20080401090728.230"># object_filenames ()

def preprocess (self,
                source,
                output_file=None,
                macros=None,
                include_dirs=None,
                extra_preargs=None,
                extra_postargs=None):

    (_, macros, include_dirs) = \
        self._fix_compile_args(None, macros, include_dirs)
    pp_opts = gen_preprocess_options(macros, include_dirs)
    pp_args = ['cpp32.exe'] + pp_opts
    if output_file is not None:
        pp_args.append('-o' + output_file)
    if extra_preargs:
        pp_args[:0] = extra_preargs
    if extra_postargs:
        pp_args.extend(extra_postargs)
    pp_args.append(source)

    # We need to preprocess: either we're being forced to, or the
    # source file is newer than the target (or the target doesn't
    # exist).
    if self.force or output_file is None or newer(source, output_file):
        if output_file:
            self.mkpath(os.path.dirname(output_file))
        try:
            self.spawn(pp_args)
        except DistutilsExecError, msg:
            print msg
            raise CompileError, msg

</t>
<t tx="ekr.20080401090728.231">"""distutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: cmd.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os, string, re
from types import *
from distutils.errors import *
from distutils import util, dir_util, file_util, archive_util, dep_util
from distutils import log

</t>
<t tx="ekr.20080401090728.232">class Command:
    """Abstract base class for defining command classes, the "worker bees"
    of the Distutils.  A useful analogy for command classes is to think of
    them as subroutines with local variables called "options".  The options
    are "declared" in 'initialize_options()' and "defined" (given their
    final values, aka "finalized") in 'finalize_options()', both of which
    must be defined by every command class.  The distinction between the
    two is necessary because option values might come from the outside
    world (command line, config file, ...), and any options dependent on
    other options must be computed *after* these outside influences have
    been processed -- hence 'finalize_options()'.  The "body" of the
    subroutine, where it does all its work based on the values of its
    options, is the 'run()' method, which must also be implemented by every
    command class.
    """

    # 'sub_commands' formalizes the notion of a "family" of commands,
    # eg. "install" as the parent with sub-commands "install_lib",
    # "install_headers", etc.  The parent of a family of commands
    # defines 'sub_commands' as a class attribute; it's a list of
    #    (command_name : string, predicate : unbound_method | string | None)
    # tuples, where 'predicate' is a method of the parent command that
    # determines whether the corresponding command is applicable in the
    # current situation.  (Eg. we "install_headers" is only applicable if
    # we have any C header files to install.)  If 'predicate' is None,
    # that command is always applicable.
    #
    # 'sub_commands' is usually defined at the *end* of a class, because
    # predicates can be unbound methods, so they must already have been
    # defined.  The canonical example is the "install" command.
    sub_commands = []


    @others
    # make_file ()

</t>
<t tx="ekr.20080401090728.233"># -- Creation/initialization methods -------------------------------

def __init__ (self, dist):
    """Create and initialize a new Command object.  Most importantly,
    invokes the 'initialize_options()' method, which is the real
    initializer and depends on the actual command being
    instantiated.
    """
    # late import because of mutual dependence between these classes
    from distutils.dist import Distribution

    if not isinstance(dist, Distribution):
        raise TypeError, "dist must be a Distribution instance"
    if self.__class__ is Command:
        raise RuntimeError, "Command is an abstract class"

    self.distribution = dist
    self.initialize_options()

    # Per-command versions of the global flags, so that the user can
    # customize Distutils' behaviour command-by-command and let some
    # commands fall back on the Distribution's behaviour.  None means
    # "not defined, check self.distribution's copy", while 0 or 1 mean
    # false and true (duh).  Note that this means figuring out the real
    # value of each flag is a touch complicated -- hence "self._dry_run"
    # will be handled by __getattr__, below.
    # XXX This needs to be fixed.
    self._dry_run = None

    # verbose is largely ignored, but needs to be set for
    # backwards compatibility (I think)?
    self.verbose = dist.verbose

    # Some commands define a 'self.force' option to ignore file
    # timestamps, but methods defined *here* assume that
    # 'self.force' exists for all commands.  So define it here
    # just to be safe.
    self.force = None

    # The 'help' flag is just used for command-line parsing, so
    # none of that complicated bureaucracy is needed.
    self.help = 0

    # 'finalized' records whether or not 'finalize_options()' has been
    # called.  'finalize_options()' itself should not pay attention to
    # this flag: it is the business of 'ensure_finalized()', which
    # always calls 'finalize_options()', to respect/update it.
    self.finalized = 0

</t>
<t tx="ekr.20080401090728.234"># __init__ ()


# XXX A more explicit way to customize dry_run would be better.

def __getattr__ (self, attr):
    if attr == 'dry_run':
        myval = getattr(self, "_" + attr)
        if myval is None:
            return getattr(self.distribution, attr)
        else:
            return myval
    else:
        raise AttributeError, attr


</t>
<t tx="ekr.20080401090728.235">def ensure_finalized (self):
    if not self.finalized:
        self.finalize_options()
    self.finalized = 1


</t>
<t tx="ekr.20080401090728.236"># Subclasses must define:
#   initialize_options()
#     provide default values for all options; may be customized by
#     setup script, by options from config file(s), or by command-line
#     options
#   finalize_options()
#     decide on the final values for all options; this is called
#     after all possible intervention from the outside world
#     (command-line, option file, etc.) has been processed
#   run()
#     run the command: do whatever it is we're here to do,
#     controlled by the command's various option values

def initialize_options (self):
    """Set default values for all the options that this command
    supports.  Note that these defaults may be overridden by other
    commands, by the setup script, by config files, or by the
    command-line.  Thus, this is not the place to code dependencies
    between options; generally, 'initialize_options()' implementations
    are just a bunch of "self.foo = None" assignments.

    This method must be implemented by all command classes.
    """
    raise RuntimeError, \
          "abstract method -- subclass %s must override" % self.__class__

</t>
<t tx="ekr.20080401090728.237">def finalize_options (self):
    """Set final values for all the options that this command supports.
    This is always called as late as possible, ie.  after any option
    assignments from the command-line or from other commands have been
    done.  Thus, this is the place to code option dependencies: if
    'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
    long as 'foo' still has the same value it was assigned in
    'initialize_options()'.

    This method must be implemented by all command classes.
    """
    raise RuntimeError, \
          "abstract method -- subclass %s must override" % self.__class__


</t>
<t tx="ekr.20080401090728.238">def dump_options (self, header=None, indent=""):
    from distutils.fancy_getopt import longopt_xlate
    if header is None:
        header = "command options for '%s':" % self.get_command_name()
    print indent + header
    indent = indent + "  "
    for (option, _, _) in self.user_options:
        option = string.translate(option, longopt_xlate)
        if option[-1] == "=":
            option = option[:-1]
        value = getattr(self, option)
        print indent + "%s = %s" % (option, value)


</t>
<t tx="ekr.20080401090728.239">def run (self):
    """A command's raison d'etre: carry out the action it exists to
    perform, controlled by the options initialized in
    'initialize_options()', customized by other commands, the setup
    script, the command-line, and config files, and finalized in
    'finalize_options()'.  All terminal output and filesystem
    interaction should be done by 'run()'.

    This method must be implemented by all command classes.
    """

    raise RuntimeError, \
          "abstract method -- subclass %s must override" % self.__class__

</t>
<t tx="ekr.20080401090728.240">def announce (self, msg, level=1):
    """If the current verbosity level is of greater than or equal to
    'level' print 'msg' to stdout.
    """
    log.log(level, msg)

</t>
<t tx="ekr.20080401090728.241">def debug_print (self, msg):
    """Print 'msg' to stdout if the global DEBUG (taken from the
    DISTUTILS_DEBUG environment variable) flag is true.
    """
    from distutils.debug import DEBUG
    if DEBUG:
        print msg
        sys.stdout.flush()



</t>
<t tx="ekr.20080401090728.242"># -- Option validation methods -------------------------------------
# (these are very handy in writing the 'finalize_options()' method)
#
# NB. the general philosophy here is to ensure that a particular option
# value meets certain type and value constraints.  If not, we try to
# force it into conformance (eg. if we expect a list but have a string,
# split the string on comma and/or whitespace).  If we can't force the
# option into conformance, raise DistutilsOptionError.  Thus, command
# classes need do nothing more than (eg.)
#   self.ensure_string_list('foo')
# and they can be guaranteed that thereafter, self.foo will be
# a list of strings.

def _ensure_stringlike (self, option, what, default=None):
    val = getattr(self, option)
    if val is None:
        setattr(self, option, default)
        return default
    elif type(val) is not StringType:
        raise DistutilsOptionError, \
              "'%s' must be a %s (got `%s`)" % (option, what, val)
    return val

</t>
<t tx="ekr.20080401090728.243">def ensure_string (self, option, default=None):
    """Ensure that 'option' is a string; if not defined, set it to
    'default'.
    """
    self._ensure_stringlike(option, "string", default)

</t>
<t tx="ekr.20080401090728.244">def ensure_string_list (self, option):
    """Ensure that 'option' is a list of strings.  If 'option' is
    currently a string, we split it either on /,\s*/ or /\s+/, so
    "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
    ["foo", "bar", "baz"].
    """
    val = getattr(self, option)
    if val is None:
        return
    elif type(val) is StringType:
        setattr(self, option, re.split(r',\s*|\s+', val))
    else:
        if type(val) is ListType:
            types = map(type, val)
            ok = (types == [StringType] * len(val))
        else:
            ok = 0

        if not ok:
            raise DistutilsOptionError, \
                  "'%s' must be a list of strings (got %r)" % \
                  (option, val)

</t>
<t tx="ekr.20080401090728.245">def _ensure_tested_string (self, option, tester,
                           what, error_fmt, default=None):
    val = self._ensure_stringlike(option, what, default)
    if val is not None and not tester(val):
        raise DistutilsOptionError, \
              ("error in '%s' option: " + error_fmt) % (option, val)

</t>
<t tx="ekr.20080401090728.246">def ensure_filename (self, option):
    """Ensure that 'option' is the name of an existing file."""
    self._ensure_tested_string(option, os.path.isfile,
                               "filename",
                               "'%s' does not exist or is not a file")

</t>
<t tx="ekr.20080401090728.247">def ensure_dirname (self, option):
    self._ensure_tested_string(option, os.path.isdir,
                               "directory name",
                               "'%s' does not exist or is not a directory")


</t>
<t tx="ekr.20080401090728.248"># -- Convenience methods for commands ------------------------------

def get_command_name (self):
    if hasattr(self, 'command_name'):
        return self.command_name
    else:
        return self.__class__.__name__


</t>
<t tx="ekr.20080401090728.249">def set_undefined_options (self, src_cmd, *option_pairs):
    """Set the values of any "undefined" options from corresponding
    option values in some other command object.  "Undefined" here means
    "is None", which is the convention used to indicate that an option
    has not been changed between 'initialize_options()' and
    'finalize_options()'.  Usually called from 'finalize_options()' for
    options that depend on some other command rather than another
    option of the same command.  'src_cmd' is the other command from
    which option values will be taken (a command object will be created
    for it if necessary); the remaining arguments are
    '(src_option,dst_option)' tuples which mean "take the value of
    'src_option' in the 'src_cmd' command object, and copy it to
    'dst_option' in the current command object".
    """

    # Option_pairs: list of (src_option, dst_option) tuples

    src_cmd_obj = self.distribution.get_command_obj(src_cmd)
    src_cmd_obj.ensure_finalized()
    for (src_option, dst_option) in option_pairs:
        if getattr(self, dst_option) is None:
            setattr(self, dst_option,
                    getattr(src_cmd_obj, src_option))


</t>
<t tx="ekr.20080401090728.250">def get_finalized_command (self, command, create=1):
    """Wrapper around Distribution's 'get_command_obj()' method: find
    (create if necessary and 'create' is true) the command object for
    'command', call its 'ensure_finalized()' method, and return the
    finalized command object.
    """
    cmd_obj = self.distribution.get_command_obj(command, create)
    cmd_obj.ensure_finalized()
    return cmd_obj

</t>
<t tx="ekr.20080401090728.251"># XXX rename to 'get_reinitialized_command()'? (should do the
# same in dist.py, if so)
def reinitialize_command (self, command, reinit_subcommands=0):
    return self.distribution.reinitialize_command(
        command, reinit_subcommands)

</t>
<t tx="ekr.20080401090728.252">def run_command (self, command):
    """Run some other command: uses the 'run_command()' method of
    Distribution, which creates and finalizes the command object if
    necessary and then invokes its 'run()' method.
    """
    self.distribution.run_command(command)


</t>
<t tx="ekr.20080401090728.253">def get_sub_commands (self):
    """Determine the sub-commands that are relevant in the current
    distribution (ie., that need to be run).  This is based on the
    'sub_commands' class attribute: each tuple in that list may include
    a method that we call to determine if the subcommand needs to be
    run for the current distribution.  Return a list of command names.
    """
    commands = []
    for (cmd_name, method) in self.sub_commands:
        if method is None or method(self):
            commands.append(cmd_name)
    return commands


</t>
<t tx="ekr.20080401090728.254"># -- External world manipulation -----------------------------------

def warn (self, msg):
    sys.stderr.write("warning: %s: %s\n" %
                     (self.get_command_name(), msg))


</t>
<t tx="ekr.20080401090728.255">def execute (self, func, args, msg=None, level=1):
    util.execute(func, args, msg, dry_run=self.dry_run)


</t>
<t tx="ekr.20080401090728.256">def mkpath (self, name, mode=0777):
    dir_util.mkpath(name, mode, dry_run=self.dry_run)


</t>
<t tx="ekr.20080401090728.257">def copy_file (self, infile, outfile,
               preserve_mode=1, preserve_times=1, link=None, level=1):
    """Copy a file respecting verbose, dry-run and force flags.  (The
    former two default to whatever is in the Distribution object, and
    the latter defaults to false for commands that don't define it.)"""

    return file_util.copy_file(
        infile, outfile,
        preserve_mode, preserve_times,
        not self.force,
        link,
        dry_run=self.dry_run)


</t>
<t tx="ekr.20080401090728.258">def copy_tree (self, infile, outfile,
               preserve_mode=1, preserve_times=1, preserve_symlinks=0,
               level=1):
    """Copy an entire directory tree respecting verbose, dry-run,
    and force flags.
    """
    return dir_util.copy_tree(
        infile, outfile,
        preserve_mode,preserve_times,preserve_symlinks,
        not self.force,
        dry_run=self.dry_run)

</t>
<t tx="ekr.20080401090728.259">def move_file (self, src, dst, level=1):
    """Move a file respectin dry-run flag."""
    return file_util.move_file(src, dst, dry_run = self.dry_run)

</t>
<t tx="ekr.20080401090728.260">def spawn (self, cmd, search_path=1, level=1):
    """Spawn an external command respecting dry-run flag."""
    from distutils.spawn import spawn
    spawn(cmd, search_path, dry_run= self.dry_run)

</t>
<t tx="ekr.20080401090728.261">def make_archive (self, base_name, format,
                  root_dir=None, base_dir=None):
    return archive_util.make_archive(
        base_name, format, root_dir, base_dir, dry_run=self.dry_run)


</t>
<t tx="ekr.20080401090728.262">def make_file (self, infiles, outfile, func, args,
               exec_msg=None, skip_msg=None, level=1):
    """Special case of 'execute()' for operations that process one or
    more input files and generate one output file.  Works just like
    'execute()', except the operation is skipped and a different
    message printed if 'outfile' already exists and is newer than all
    files listed in 'infiles'.  If the command defined 'self.force',
    and it is true, then the command is unconditionally run -- does no
    timestamp checks.
    """
    if exec_msg is None:
        exec_msg = "generating %s from %s" % \
                   (outfile, string.join(infiles, ', '))
    if skip_msg is None:
        skip_msg = "skipping %s (inputs unchanged)" % outfile


    # Allow 'infiles' to be a single string
    if type(infiles) is StringType:
        infiles = (infiles,)
    elif type(infiles) not in (ListType, TupleType):
        raise TypeError, \
              "'infiles' must be a string, or a list or tuple of strings"

    # If 'outfile' must be regenerated (either because it doesn't
    # exist, is out-of-date, or the 'force' flag is true) then
    # perform the action that presumably regenerates it
    if self.force or dep_util.newer_group (infiles, outfile):
        self.execute(func, args, exec_msg, level)

    # Otherwise, print the "skip" message
    else:
        log.debug(skip_msg)

</t>
<t tx="ekr.20080401090728.263"># class Command


# XXX 'install_misc' class not currently used -- it was the base class for
# both 'install_scripts' and 'install_data', but they outgrew it.  It might
# still be useful for 'install_headers', though, so I'm keeping it around
# for the time being.

class install_misc (Command):
    """Common base class for installing some files in a subdirectory.
    Currently used by install_data and install_scripts.
    """

    user_options = [('install-dir=', 'd', "directory to install the files to")]

    @others
</t>
<t tx="ekr.20080401090728.264">def initialize_options (self):
    self.install_dir = None
    self.outfiles = []

</t>
<t tx="ekr.20080401090728.265">def _install_dir_from (self, dirname):
    self.set_undefined_options('install', (dirname, 'install_dir'))

</t>
<t tx="ekr.20080401090728.266">def _copy_files (self, filelist):
    self.outfiles = []
    if not filelist:
        return
    self.mkpath(self.install_dir)
    for f in filelist:
        self.copy_file(f, self.install_dir)
        self.outfiles.append(os.path.join(self.install_dir, f))

</t>
<t tx="ekr.20080401090728.267">def get_outputs (self):
    return self.outfiles


</t>
<t tx="ekr.20080401090728.268">"""distutils.core

The only module that needs to be imported to use the Distutils; provides
the 'setup' function (which is to be called from the setup script).  Also
indirectly provides the Distribution and Command classes, although they are
really defined in distutils.dist and distutils.cmd.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: core.py 38672 2005-03-20 22:19:47Z fdrake $"

import sys, os
from types import *

from distutils.debug import DEBUG
from distutils.errors import *
from distutils.util import grok_environment_error

# Mainly import these so setup scripts can "from distutils.core import" them.
from distutils.dist import Distribution
from distutils.cmd import Command
from distutils.extension import Extension

# This is a barebones help message generated displayed when the user
# runs the setup script with no arguments at all.  More useful help
# is generated with various --help options: global help, list commands,
# and per-command help.
USAGE = """\
usage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: %(script)s --help [cmd1 cmd2 ...]
   or: %(script)s --help-commands
   or: %(script)s cmd --help
"""

</t>
<t tx="ekr.20080401090728.269">def gen_usage (script_name):
    script = os.path.basename(script_name)
    return USAGE % vars()


</t>
<t tx="ekr.20080401090728.270"># Some mild magic to control the behaviour of 'setup()' from 'run_setup()'.
_setup_stop_after = None
_setup_distribution = None

# Legal keyword arguments for the setup() function
setup_keywords = ('distclass', 'script_name', 'script_args', 'options',
                  'name', 'version', 'author', 'author_email',
                  'maintainer', 'maintainer_email', 'url', 'license',
                  'description', 'long_description', 'keywords',
                  'platforms', 'classifiers', 'download_url',
                  'requires', 'provides', 'obsoletes',
                  )

# Legal keyword arguments for the Extension constructor
extension_keywords = ('name', 'sources', 'include_dirs',
                      'define_macros', 'undef_macros',
                      'library_dirs', 'libraries', 'runtime_library_dirs',
                      'extra_objects', 'extra_compile_args', 'extra_link_args',
                      'swig_opts', 'export_symbols', 'depends', 'language')

def setup (**attrs):
    """The gateway to the Distutils: do everything your setup script needs
    to do, in a highly flexible and user-driven way.  Briefly: create a
    Distribution instance; find and parse config files; parse the command
    line; run each Distutils command found there, customized by the options
    supplied to 'setup()' (as keyword arguments), in config files, and on
    the command line.

    The Distribution instance might be an instance of a class supplied via
    the 'distclass' keyword argument to 'setup'; if no such class is
    supplied, then the Distribution class (in dist.py) is instantiated.
    All other arguments to 'setup' (except for 'cmdclass') are used to set
    attributes of the Distribution instance.

    The 'cmdclass' argument, if supplied, is a dictionary mapping command
    names to command classes.  Each command encountered on the command line
    will be turned into a command class, which is in turn instantiated; any
    class found in 'cmdclass' is used in place of the default, which is
    (for command 'foo_bar') class 'foo_bar' in module
    'distutils.command.foo_bar'.  The command class must provide a
    'user_options' attribute which is a list of option specifiers for
    'distutils.fancy_getopt'.  Any command-line options between the current
    and the next command are used to set attributes of the current command
    object.

    When the entire command-line has been successfully parsed, calls the
    'run()' method on each command object in turn.  This method will be
    driven entirely by the Distribution object (which each command object
    has a reference to, thanks to its constructor), and the
    command-specific options that became attributes of each command
    object.
    """

    global _setup_stop_after, _setup_distribution

    # Determine the distribution class -- either caller-supplied or
    # our Distribution (see below).
    klass = attrs.get('distclass')
    if klass:
        del attrs['distclass']
    else:
        klass = Distribution

    if not attrs.has_key('script_name'):
        attrs['script_name'] = os.path.basename(sys.argv[0])
    if not attrs.has_key('script_args'):
        attrs['script_args'] = sys.argv[1:]

    # Create the Distribution instance, using the remaining arguments
    # (ie. everything except distclass) to initialize it
    try:
        _setup_distribution = dist = klass(attrs)
    except DistutilsSetupError, msg:
        if attrs.has_key('name'):
            raise SystemExit, "error in %s setup command: %s" % \
                  (attrs['name'], msg)
        else:
            raise SystemExit, "error in setup command: %s" % msg

    if _setup_stop_after == "init":
        return dist

    # Find and parse the config file(s): they will override options from
    # the setup script, but be overridden by the command line.
    dist.parse_config_files()

    if DEBUG:
        print "options (after parsing config files):"
        dist.dump_option_dicts()

    if _setup_stop_after == "config":
        return dist

    # Parse the command line; any command-line errors are the end user's
    # fault, so turn them into SystemExit to suppress tracebacks.
    try:
        ok = dist.parse_command_line()
    except DistutilsArgError, msg:
        raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg

    if DEBUG:
        print "options (after parsing command line):"
        dist.dump_option_dicts()

    if _setup_stop_after == "commandline":
        return dist

    # And finally, run all the commands found on the command line.
    if ok:
        try:
            dist.run_commands()
        except KeyboardInterrupt:
            raise SystemExit, "interrupted"
        except (IOError, os.error), exc:
            error = grok_environment_error(exc)

            if DEBUG:
                sys.stderr.write(error + "\n")
                raise
            else:
                raise SystemExit, error

        except (DistutilsError,
                CCompilerError), msg:
            if DEBUG:
                raise
            else:
                raise SystemExit, "error: " + str(msg)

    return dist

</t>
<t tx="ekr.20080401090728.271"># setup ()


def run_setup (script_name, script_args=None, stop_after="run"):
    """Run a setup script in a somewhat controlled environment, and
    return the Distribution instance that drives things.  This is useful
    if you need to find out the distribution meta-data (passed as
    keyword args from 'script' to 'setup()', or the contents of the
    config files or command-line.

    'script_name' is a file that will be run with 'execfile()';
    'sys.argv[0]' will be replaced with 'script' for the duration of the
    call.  'script_args' is a list of strings; if supplied,
    'sys.argv[1:]' will be replaced by 'script_args' for the duration of
    the call.

    'stop_after' tells 'setup()' when to stop processing; possible
    values:
      init
        stop after the Distribution instance has been created and
        populated with the keyword arguments to 'setup()'
      config
        stop after config files have been parsed (and their data
        stored in the Distribution instance)
      commandline
        stop after the command-line ('sys.argv[1:]' or 'script_args')
        have been parsed (and the data stored in the Distribution)
      run [default]
        stop after all commands have been run (the same as if 'setup()'
        had been called in the usual way

    Returns the Distribution instance, which provides all information
    used to drive the Distutils.
    """
    if stop_after not in ('init', 'config', 'commandline', 'run'):
        raise ValueError, "invalid value for 'stop_after': %r" % (stop_after,)

    global _setup_stop_after, _setup_distribution
    _setup_stop_after = stop_after

    save_argv = sys.argv
    g = {}
    l = {}
    try:
        try:
            sys.argv[0] = script_name
            if script_args is not None:
                sys.argv[1:] = script_args
            execfile(script_name, g, l)
        finally:
            sys.argv = save_argv
            _setup_stop_after = None
    except SystemExit:
        # Hmm, should we do something if exiting with a non-zero code
        # (ie. error)?
        pass
    except:
        raise

    if _setup_distribution is None:
        raise RuntimeError, \
              ("'distutils.core.setup()' was never called -- "
               "perhaps '%s' is not a Distutils setup script?") % \
              script_name

    # I wonder if the setup script's namespace -- g and l -- would be of
    # any interest to callers?
    #print "_setup_distribution:", _setup_distribution
    return _setup_distribution

</t>
<t tx="ekr.20080401090728.272">"""distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
"""

# problems:
#
# * if you use a msvc compiled python version (1.5.2)
#   1. you have to insert a __GNUC__ section in its config.h
#   2. you have to generate a import library for its dll
#      - create a def-file for python??.dll
#      - create a import library using
#             dlltool --dllname python15.dll --def python15.def \
#                       --output-lib libpython15.a
#
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
#
# * We put export_symbols in a def-file, and don't use
#   --export-all-symbols because it doesn't worked reliable in some
#   tested configurations. And because other windows compilers also
#   need their symbols specified this no serious problem.
#
# tested configurations:
#
# * cygwin gcc 2.91.57/ld 2.9.4/dllwrap 0.2.4 works
#   (after patching python's config.h and for C++ some other include files)
#   see also http://starship.python.net/crew/kernr/mingw32/Notes.html
# * mingw32 gcc 2.95.2/ld 2.9.4/dllwrap 0.2.4 works
#   (ld doesn't support -shared, so we use dllwrap)
# * cygwin gcc 2.95.2/ld 2.10.90/dllwrap 2.10.90 works now
#   - its dllwrap doesn't work, there is a bug in binutils 2.10.90
#     see also http://sources.redhat.com/ml/cygwin/2000-06/msg01274.html
#   - using gcc -mdll instead dllwrap doesn't work without -static because
#     it tries to link against dlls instead their import libraries. (If
#     it finds the dll first.)
#     By specifying -static we force ld to link against the import libraries,
#     this is windows standard and there are normally not the necessary symbols
#     in the dlls.
#   *** only the version of June 2000 shows these problems
# * cygwin gcc 3.2/ld 2.13.90 works
#   (ld supports -shared)
# * mingw gcc 3.2/ld 2.13 works
#   (ld supports -shared)

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: cygwinccompiler.py 37828 2004-11-10 22:23:15Z loewis $"

import os,sys,copy
from distutils.ccompiler import gen_preprocess_options, gen_lib_options
from distutils.unixccompiler import UnixCCompiler
from distutils.file_util import write_file
from distutils.errors import DistutilsExecError, CompileError, UnknownFileError
from distutils import log

</t>
<t tx="ekr.20080401090728.273">class CygwinCCompiler (UnixCCompiler):

    compiler_type = 'cygwin'
    obj_extension = ".o"
    static_lib_extension = ".a"
    shared_lib_extension = ".dll"
    static_lib_format = "lib%s%s"
    shared_lib_format = "%s%s"
    exe_extension = ".exe"

    @others
    # object_filenames ()

</t>
<t tx="ekr.20080401090728.274">def __init__ (self, verbose=0, dry_run=0, force=0):

    UnixCCompiler.__init__ (self, verbose, dry_run, force)

    (status, details) = check_config_h()
    self.debug_print("Python's GCC status: %s (details: %s)" %
                     (status, details))
    if status is not CONFIG_H_OK:
        self.warn(
            "Python's pyconfig.h doesn't seem to support your compiler. "
            "Reason: %s. "
            "Compiling may fail because of undefined preprocessor macros."
            % details)

    self.gcc_version, self.ld_version, self.dllwrap_version = \
        get_versions()
    self.debug_print(self.compiler_type + ": gcc %s, ld %s, dllwrap %s\n" %
                     (self.gcc_version,
                      self.ld_version,
                      self.dllwrap_version) )

    # ld_version &gt;= "2.10.90" and &lt; "2.13" should also be able to use
    # gcc -mdll instead of dllwrap
    # Older dllwraps had own version numbers, newer ones use the
    # same as the rest of binutils ( also ld )
    # dllwrap 2.10.90 is buggy
    if self.ld_version &gt;= "2.10.90":
        self.linker_dll = "gcc"
    else:
        self.linker_dll = "dllwrap"

    # ld_version &gt;= "2.13" support -shared so use it instead of
    # -mdll -static
    if self.ld_version &gt;= "2.13":
        shared_option = "-shared"
    else:
        shared_option = "-mdll -static"

    # Hard-code GCC because that's what this is all about.
    # XXX optimization, warnings etc. should be customizable.
    self.set_executables(compiler='gcc -mcygwin -O -Wall',
                         compiler_so='gcc -mcygwin -mdll -O -Wall',
                         compiler_cxx='g++ -mcygwin -O -Wall',
                         linker_exe='gcc -mcygwin',
                         linker_so=('%s -mcygwin %s' %
                                    (self.linker_dll, shared_option)))

    # cygwin and mingw32 need different sets of libraries
    if self.gcc_version == "2.91.57":
        # cygwin shouldn't need msvcrt, but without the dlls will crash
        # (gcc version 2.91.57) -- perhaps something about initialization
        self.dll_libraries=["msvcrt"]
        self.warn(
            "Consider upgrading to a newer version of gcc")
    else:
        self.dll_libraries=[]
        # Include the appropriate MSVC runtime library if Python was built
        # with MSVC 7.0 or 7.1.
        msc_pos = sys.version.find('MSC v.')
        if msc_pos != -1:
            msc_ver = sys.version[msc_pos+6:msc_pos+10]
            if msc_ver == '1300':
                # MSVC 7.0
                self.dll_libraries = ['msvcr70']
            elif msc_ver == '1310':
                # MSVC 7.1
                self.dll_libraries = ['msvcr71']

</t>
<t tx="ekr.20080401090728.275"># __init__ ()


def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
    if ext == '.rc' or ext == '.res':
        # gcc needs '.res' and '.rc' compiled to object files !!!
        try:
            self.spawn(["windres", "-i", src, "-o", obj])
        except DistutilsExecError, msg:
            raise CompileError, msg
    else: # for other files use the C-compiler
        try:
            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] +
                       extra_postargs)
        except DistutilsExecError, msg:
            raise CompileError, msg

</t>
<t tx="ekr.20080401090728.276">def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):

    # use separate copies, so we can modify the lists
    extra_preargs = copy.copy(extra_preargs or [])
    libraries = copy.copy(libraries or [])
    objects = copy.copy(objects or [])

    # Additional libraries
    libraries.extend(self.dll_libraries)

    # handle export symbols by creating a def-file
    # with executables this only works with gcc/ld as linker
    if ((export_symbols is not None) and
        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):
        # (The linker doesn't do anything if output is up-to-date.
        # So it would probably better to check if we really need this,
        # but for this we had to insert some unchanged parts of
        # UnixCCompiler, and this is not what we want.)

        # we want to put some files in the same directory as the
        # object files are, build_temp doesn't help much
        # where are the object files
        temp_dir = os.path.dirname(objects[0])
        # name of dll to give the helper files the same base name
        (dll_name, dll_extension) = os.path.splitext(
            os.path.basename(output_filename))

        # generate the filenames for these files
        def_file = os.path.join(temp_dir, dll_name + ".def")
        lib_file = os.path.join(temp_dir, 'lib' + dll_name + ".a")

        # Generate .def file
        contents = [
            "LIBRARY %s" % os.path.basename(output_filename),
            "EXPORTS"]
        for sym in export_symbols:
            contents.append(sym)
        self.execute(write_file, (def_file, contents),
                     "writing %s" % def_file)

        # next add options for def-file and to creating import libraries

        # dllwrap uses different options than gcc/ld
        if self.linker_dll == "dllwrap":
            extra_preargs.extend(["--output-lib", lib_file])
            # for dllwrap we have to use a special option
            extra_preargs.extend(["--def", def_file])
        # we use gcc/ld here and can be sure ld is &gt;= 2.9.10
        else:
            # doesn't work: bfd_close build\...\libfoo.a: Invalid operation
            #extra_preargs.extend(["-Wl,--out-implib,%s" % lib_file])
            # for gcc/ld the def-file is specified as any object files
            objects.append(def_file)

    #end: if ((export_symbols is not None) and
    #        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):

    # who wants symbols and a many times larger output file
    # should explicitly switch the debug mode on
    # otherwise we let dllwrap/ld strip the output file
    # (On my machine: 10KB &lt; stripped_file &lt; ??100KB
    #   unstripped_file = stripped_file + XXX KB
    #  ( XXX=254 for a typical python extension))
    if not debug:
        extra_preargs.append("-s")

    UnixCCompiler.link(self,
                       target_desc,
                       objects,
                       output_filename,
                       output_dir,
                       libraries,
                       library_dirs,
                       runtime_library_dirs,
                       None, # export_symbols, we do this in our def-file
                       debug,
                       extra_preargs,
                       extra_postargs,
                       build_temp,
                       target_lang)

</t>
<t tx="ekr.20080401090728.277"># link ()

# -- Miscellaneous methods -----------------------------------------

# overwrite the one from CCompiler to support rc and res-files
def object_filenames (self,
                      source_filenames,
                      strip_dir=0,
                      output_dir=''):
    if output_dir is None: output_dir = ''
    obj_names = []
    for src_name in source_filenames:
        # use normcase to make sure '.rc' is really '.rc' and not '.RC'
        (base, ext) = os.path.splitext (os.path.normcase(src_name))
        if ext not in (self.src_extensions + ['.rc','.res']):
            raise UnknownFileError, \
                  "unknown file type '%s' (from '%s')" % \
                  (ext, src_name)
        if strip_dir:
            base = os.path.basename (base)
        if ext == '.res' or ext == '.rc':
            # these need to be compiled to object files
            obj_names.append (os.path.join (output_dir,
                                        base + ext + self.obj_extension))
        else:
            obj_names.append (os.path.join (output_dir,
                                        base + self.obj_extension))
    return obj_names

</t>
<t tx="ekr.20080401090728.278"># class CygwinCCompiler


# the same as cygwin plus some additional parameters
class Mingw32CCompiler (CygwinCCompiler):

    compiler_type = 'mingw32'

    @others
    # __init__ ()

</t>
<t tx="ekr.20080401090728.279">def __init__ (self,
              verbose=0,
              dry_run=0,
              force=0):

    CygwinCCompiler.__init__ (self, verbose, dry_run, force)

    # ld_version &gt;= "2.13" support -shared so use it instead of
    # -mdll -static
    if self.ld_version &gt;= "2.13":
        shared_option = "-shared"
    else:
        shared_option = "-mdll -static"

    # A real mingw32 doesn't need to specify a different entry point,
    # but cygwin 2.91.57 in no-cygwin-mode needs it.
    if self.gcc_version &lt;= "2.91.57":
        entry_point = '--entry _DllMain@12'
    else:
        entry_point = ''

    self.set_executables(compiler='gcc -mno-cygwin -O -Wall',
                         compiler_so='gcc -mno-cygwin -mdll -O -Wall',
                         compiler_cxx='g++ -mno-cygwin -O -Wall',
                         linker_exe='gcc -mno-cygwin',
                         linker_so='%s -mno-cygwin %s %s'
                                    % (self.linker_dll, shared_option,
                                       entry_point))
    # Maybe we should also append -mthreads, but then the finished
    # dlls need another dll (mingwm10.dll see Mingw32 docs)
    # (-mthreads: Support thread-safe exception handling on `Mingw32')

    # no additional libraries needed
    self.dll_libraries=[]

    # Include the appropriate MSVC runtime library if Python was built
    # with MSVC 7.0 or 7.1.
    msc_pos = sys.version.find('MSC v.')
    if msc_pos != -1:
        msc_ver = sys.version[msc_pos+6:msc_pos+10]
        if msc_ver == '1300':
            # MSVC 7.0
            self.dll_libraries = ['msvcr70']
        elif msc_ver == '1310':
            # MSVC 7.1
            self.dll_libraries = ['msvcr71']

</t>
<t tx="ekr.20080401090728.280"># class Mingw32CCompiler

# Because these compilers aren't configured in Python's pyconfig.h file by
# default, we should at least warn the user if he is using a unmodified
# version.

CONFIG_H_OK = "ok"
CONFIG_H_NOTOK = "not ok"
CONFIG_H_UNCERTAIN = "uncertain"

def check_config_h():

    """Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    """

    # XXX since this function also checks sys.version, it's not strictly a
    # "pyconfig.h" check -- should probably be renamed...

    from distutils import sysconfig
    import string
    # if sys.version contains GCC then python was compiled with
    # GCC, and the pyconfig.h file should be OK
    if string.find(sys.version,"GCC") &gt;= 0:
        return (CONFIG_H_OK, "sys.version mentions 'GCC'")

    fn = sysconfig.get_config_h_filename()
    try:
        # It would probably better to read single lines to search.
        # But we do this only once, and it is fast enough
        f = open(fn)
        s = f.read()
        f.close()

    except IOError, exc:
        # if we can't read this file, we cannot say it is wrong
        # the compiler will complain later about this file as missing
        return (CONFIG_H_UNCERTAIN,
                "couldn't read '%s': %s" % (fn, exc.strerror))

    else:
        # "pyconfig.h" contains an "#ifdef __GNUC__" or something similar
        if string.find(s,"__GNUC__") &gt;= 0:
            return (CONFIG_H_OK, "'%s' mentions '__GNUC__'" % fn)
        else:
            return (CONFIG_H_NOTOK, "'%s' does not mention '__GNUC__'" % fn)



</t>
<t tx="ekr.20080401090728.281">def get_versions():
    """ Try to find out the versions of gcc, ld and dllwrap.
        If not possible it returns None for it.
    """
    from distutils.version import StrictVersion
    from distutils.spawn import find_executable
    import re

    gcc_exe = find_executable('gcc')
    if gcc_exe:
        out = os.popen(gcc_exe + ' -dumpversion','r')
        out_string = out.read()
        out.close()
        result = re.search('(\d+\.\d+(\.\d+)*)',out_string)
        if result:
            gcc_version = StrictVersion(result.group(1))
        else:
            gcc_version = None
    else:
        gcc_version = None
    ld_exe = find_executable('ld')
    if ld_exe:
        out = os.popen(ld_exe + ' -v','r')
        out_string = out.read()
        out.close()
        result = re.search('(\d+\.\d+(\.\d+)*)',out_string)
        if result:
            ld_version = StrictVersion(result.group(1))
        else:
            ld_version = None
    else:
        ld_version = None
    dllwrap_exe = find_executable('dllwrap')
    if dllwrap_exe:
        out = os.popen(dllwrap_exe + ' --version','r')
        out_string = out.read()
        out.close()
        result = re.search(' (\d+\.\d+(\.\d+)*)',out_string)
        if result:
            dllwrap_version = StrictVersion(result.group(1))
        else:
            dllwrap_version = None
    else:
        dllwrap_version = None
    return (gcc_version, ld_version, dllwrap_version)
</t>
<t tx="ekr.20080401090728.282">import os

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: debug.py 37828 2004-11-10 22:23:15Z loewis $"

# If DISTUTILS_DEBUG is anything other than the empty string, we run in
# debug mode.
DEBUG = os.environ.get('DISTUTILS_DEBUG')
</t>
<t tx="ekr.20080401090728.283">"""distutils.dep_util

Utility functions for simple, timestamp-based dependency of files
and groups of files; also, function based entirely on such
timestamp dependency analysis."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: dep_util.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from distutils.errors import DistutilsFileError


</t>
<t tx="ekr.20080401090728.284">def newer (source, target):
    """Return true if 'source' exists and is more recently modified than
    'target', or if 'source' exists and 'target' doesn't.  Return false if
    both exist and 'target' is the same age or younger than 'source'.
    Raise DistutilsFileError if 'source' does not exist.
    """
    if not os.path.exists(source):
        raise DistutilsFileError, "file '%s' does not exist" % source
    if not os.path.exists(target):
        return 1

    from stat import ST_MTIME
    mtime1 = os.stat(source)[ST_MTIME]
    mtime2 = os.stat(target)[ST_MTIME]

    return mtime1 &gt; mtime2

</t>
<t tx="ekr.20080401090728.285"># newer ()


def newer_pairwise (sources, targets):
    """Walk two filename lists in parallel, testing if each source is newer
    than its corresponding target.  Return a pair of lists (sources,
    targets) where source is newer than target, according to the semantics
    of 'newer()'.
    """
    if len(sources) != len(targets):
        raise ValueError, "'sources' and 'targets' must be same length"

    # build a pair of lists (sources, targets) where  source is newer
    n_sources = []
    n_targets = []
    for i in range(len(sources)):
        if newer(sources[i], targets[i]):
            n_sources.append(sources[i])
            n_targets.append(targets[i])

    return (n_sources, n_targets)

</t>
<t tx="ekr.20080401090728.286"># newer_pairwise ()


def newer_group (sources, target, missing='error'):
    """Return true if 'target' is out-of-date with respect to any file
    listed in 'sources'.  In other words, if 'target' exists and is newer
    than every file in 'sources', return false; otherwise return true.
    'missing' controls what we do when a source file is missing; the
    default ("error") is to blow up with an OSError from inside 'stat()';
    if it is "ignore", we silently drop any missing source files; if it is
    "newer", any missing source files make us assume that 'target' is
    out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
    carry out commands that wouldn't work because inputs are missing, but
    that doesn't matter because you're not actually going to run the
    commands).
    """
    # If the target doesn't even exist, then it's definitely out-of-date.
    if not os.path.exists(target):
        return 1

    # Otherwise we have to find out the hard way: if *any* source file
    # is more recent than 'target', then 'target' is out-of-date and
    # we can immediately return true.  If we fall through to the end
    # of the loop, then 'target' is up-to-date and we return false.
    from stat import ST_MTIME
    target_mtime = os.stat(target)[ST_MTIME]
    for source in sources:
        if not os.path.exists(source):
            if missing == 'error':      # blow up when we stat() the file
                pass
            elif missing == 'ignore':   # missing source dropped from
                continue                #  target's dependency list
            elif missing == 'newer':    # missing source means target is
                return 1                #  out-of-date

        source_mtime = os.stat(source)[ST_MTIME]
        if source_mtime &gt; target_mtime:
            return 1
    else:
        return 0

</t>
<t tx="ekr.20080401090728.287">"""distutils.dir_util

Utility functions for manipulating directories and directory trees."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: dir_util.py 39416 2005-08-26 15:20:46Z tim_one $"

import os, sys
from types import *
from distutils.errors import DistutilsFileError, DistutilsInternalError
from distutils import log

# cache for by mkpath() -- in addition to cheapening redundant calls,
# eliminates redundant "creating /foo/bar/baz" messages in dry-run mode
_path_created = {}

</t>
<t tx="ekr.20080401090728.288"># I don't use os.makedirs because a) it's new to Python 1.5.2, and
# b) it blows up if the directory already exists (I want to silently
# succeed in that case).
def mkpath (name, mode=0777, verbose=0, dry_run=0):
    """Create a directory and any missing ancestor directories.  If the
       directory already exists (or if 'name' is the empty string, which
       means the current directory, which of course exists), then do
       nothing.  Raise DistutilsFileError if unable to create some
       directory along the way (eg. some sub-path exists, but is a file
       rather than a directory).  If 'verbose' is true, print a one-line
       summary of each mkdir to stdout.  Return the list of directories
       actually created."""

    global _path_created

    # Detect a common bug -- name is None
    if not isinstance(name, StringTypes):
        raise DistutilsInternalError, \
              "mkpath: 'name' must be a string (got %r)" % (name,)

    # XXX what's the better way to handle verbosity? print as we create
    # each directory in the path (the current behaviour), or only announce
    # the creation of the whole path? (quite easy to do the latter since
    # we're not using a recursive algorithm)

    name = os.path.normpath(name)
    created_dirs = []
    if os.path.isdir(name) or name == '':
        return created_dirs
    if _path_created.get(os.path.abspath(name)):
        return created_dirs

    (head, tail) = os.path.split(name)
    tails = [tail]                      # stack of lone dirs to create

    while head and tail and not os.path.isdir(head):
        #print "splitting '%s': " % head,
        (head, tail) = os.path.split(head)
        #print "to ('%s','%s')" % (head, tail)
        tails.insert(0, tail)          # push next higher dir onto stack

    #print "stack of tails:", tails

    # now 'head' contains the deepest directory that already exists
    # (that is, the child of 'head' in 'name' is the highest directory
    # that does *not* exist)
    for d in tails:
        #print "head = %s, d = %s: " % (head, d),
        head = os.path.join(head, d)
        abs_head = os.path.abspath(head)

        if _path_created.get(abs_head):
            continue

        log.info("creating %s", head)

        if not dry_run:
            try:
                os.mkdir(head)
                created_dirs.append(head)
            except OSError, exc:
                raise DistutilsFileError, \
                      "could not create '%s': %s" % (head, exc[-1])

        _path_created[abs_head] = 1
    return created_dirs

</t>
<t tx="ekr.20080401090728.289"># mkpath ()


def create_tree (base_dir, files, mode=0777, verbose=0, dry_run=0):

    """Create all the empty directories under 'base_dir' needed to
       put 'files' there.  'base_dir' is just the a name of a directory
       which doesn't necessarily exist yet; 'files' is a list of filenames
       to be interpreted relative to 'base_dir'.  'base_dir' + the
       directory portion of every file in 'files' will be created if it
       doesn't already exist.  'mode', 'verbose' and 'dry_run' flags are as
       for 'mkpath()'."""

    # First get the list of directories to create
    need_dir = {}
    for file in files:
        need_dir[os.path.join(base_dir, os.path.dirname(file))] = 1
    need_dirs = need_dir.keys()
    need_dirs.sort()

    # Now create them
    for dir in need_dirs:
        mkpath(dir, mode, dry_run=dry_run)

</t>
<t tx="ekr.20080401090728.290"># create_tree ()


def copy_tree (src, dst,
               preserve_mode=1,
               preserve_times=1,
               preserve_symlinks=0,
               update=0,
               verbose=0,
               dry_run=0):

    """Copy an entire directory tree 'src' to a new location 'dst'.  Both
       'src' and 'dst' must be directory names.  If 'src' is not a
       directory, raise DistutilsFileError.  If 'dst' does not exist, it is
       created with 'mkpath()'.  The end result of the copy is that every
       file in 'src' is copied to 'dst', and directories under 'src' are
       recursively copied to 'dst'.  Return the list of files that were
       copied or might have been copied, using their output name.  The
       return value is unaffected by 'update' or 'dry_run': it is simply
       the list of all files under 'src', with the names changed to be
       under 'dst'.

       'preserve_mode' and 'preserve_times' are the same as for
       'copy_file'; note that they only apply to regular files, not to
       directories.  If 'preserve_symlinks' is true, symlinks will be
       copied as symlinks (on platforms that support them!); otherwise
       (the default), the destination of the symlink will be copied.
       'update' and 'verbose' are the same as for 'copy_file'."""

    from distutils.file_util import copy_file

    if not dry_run and not os.path.isdir(src):
        raise DistutilsFileError, \
              "cannot copy tree '%s': not a directory" % src
    try:
        names = os.listdir(src)
    except os.error, (errno, errstr):
        if dry_run:
            names = []
        else:
            raise DistutilsFileError, \
                  "error listing files in '%s': %s" % (src, errstr)

    if not dry_run:
        mkpath(dst)

    outputs = []

    for n in names:
        src_name = os.path.join(src, n)
        dst_name = os.path.join(dst, n)

        if preserve_symlinks and os.path.islink(src_name):
            link_dest = os.readlink(src_name)
            log.info("linking %s -&gt; %s", dst_name, link_dest)
            if not dry_run:
                os.symlink(link_dest, dst_name)
            outputs.append(dst_name)

        elif os.path.isdir(src_name):
            outputs.extend(
                copy_tree(src_name, dst_name, preserve_mode,
                          preserve_times, preserve_symlinks, update,
                          dry_run=dry_run))
        else:
            copy_file(src_name, dst_name, preserve_mode,
                      preserve_times, update, dry_run=dry_run)
            outputs.append(dst_name)

    return outputs

</t>
<t tx="ekr.20080401090728.291"># copy_tree ()

# Helper for remove_tree()
def _build_cmdtuple(path, cmdtuples):
    for f in os.listdir(path):
        real_f = os.path.join(path,f)
        if os.path.isdir(real_f) and not os.path.islink(real_f):
            _build_cmdtuple(real_f, cmdtuples)
        else:
            cmdtuples.append((os.remove, real_f))
    cmdtuples.append((os.rmdir, path))


</t>
<t tx="ekr.20080401090728.292">def remove_tree (directory, verbose=0, dry_run=0):
    """Recursively remove an entire directory tree.  Any errors are ignored
    (apart from being reported to stdout if 'verbose' is true).
    """
    from distutils.util import grok_environment_error
    global _path_created

    log.info("removing '%s' (and everything under it)", directory)
    if dry_run:
        return
    cmdtuples = []
    _build_cmdtuple(directory, cmdtuples)
    for cmd in cmdtuples:
        try:
            apply(cmd[0], (cmd[1],))
            # remove dir from cache if it's already there
            abspath = os.path.abspath(cmd[1])
            if _path_created.has_key(abspath):
                del _path_created[abspath]
        except (IOError, OSError), exc:
            log.warn(grok_environment_error(
                    exc, "error removing %s: " % directory))


</t>
<t tx="ekr.20080401090728.293">def ensure_relative (path):
    """Take the full path 'path', and make it a relative path so
    it can be the second argument to os.path.join().
    """
    drive, path = os.path.splitdrive(path)
    if sys.platform == 'mac':
        return os.sep + path
    else:
        if path[0:1] == os.sep:
            path = drive + path[1:]
        return path
</t>
<t tx="ekr.20080401090728.294">"""distutils.dist

Provides the Distribution class, which represents the module distribution
being built/installed/distributed.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: dist.py 38697 2005-03-23 18:54:36Z loewis $"

import sys, os, string, re
from types import *
from copy import copy

try:
    import warnings
except ImportError:
    warnings = None

from distutils.errors import *
from distutils.fancy_getopt import FancyGetopt, translate_longopt
from distutils.util import check_environ, strtobool, rfc822_escape
from distutils import log
from distutils.debug import DEBUG

# Regex to define acceptable Distutils command names.  This is not *quite*
# the same as a Python NAME -- I don't allow leading underscores.  The fact
# that they're very similar is no coincidence; the default naming scheme is
# to look for a Python module named after the command.
command_re = re.compile (r'^[a-zA-Z]([a-zA-Z0-9_]*)$')


</t>
<t tx="ekr.20080401090728.295">class Distribution:
    """The core of the Distutils.  Most of the work hiding behind 'setup'
    is really done within a Distribution instance, which farms the work out
    to the Distutils commands specified on the command line.

    Setup scripts will almost never instantiate Distribution directly,
    unless the 'setup()' function is totally inadequate to their needs.
    However, it is conceivable that a setup script might wish to subclass
    Distribution for some specialized purpose, and then pass the subclass
    to 'setup()' as the 'distclass' keyword argument.  If so, it is
    necessary to respect the expectations that 'setup' has of Distribution.
    See the code for 'setup()', in core.py, for details.
    """


    # 'global_options' describes the command-line options that may be
    # supplied to the setup script prior to any actual commands.
    # Eg. "./setup.py -n" or "./setup.py --quiet" both take advantage of
    # these global options.  This list should be kept to a bare minimum,
    # since every global option is also valid as a command option -- and we
    # don't want to pollute the commands with too many options that they
    # have minimal control over.
    # The fourth entry for verbose means that it can be repeated.
    global_options = [('verbose', 'v', "run verbosely (default)", 1),
                      ('quiet', 'q', "run quietly (turns verbosity off)"),
                      ('dry-run', 'n', "don't actually do anything"),
                      ('help', 'h', "show detailed help message"),
                     ]

    # 'common_usage' is a short (2-3 line) string describing the common
    # usage of the setup script.
    common_usage = """\
Common commands: (see '--help-commands' for more)

  setup.py build      will build the package underneath 'build/'
  setup.py install    will install the package
"""

    # options that are not propagated to the commands
    display_options = [
        ('help-commands', None,
         "list all available commands"),
        ('name', None,
         "print package name"),
        ('version', 'V',
         "print package version"),
        ('fullname', None,
         "print &lt;package name&gt;-&lt;version&gt;"),
        ('author', None,
         "print the author's name"),
        ('author-email', None,
         "print the author's email address"),
        ('maintainer', None,
         "print the maintainer's name"),
        ('maintainer-email', None,
         "print the maintainer's email address"),
        ('contact', None,
         "print the maintainer's name if known, else the author's"),
        ('contact-email', None,
         "print the maintainer's email address if known, else the author's"),
        ('url', None,
         "print the URL for this package"),
        ('license', None,
         "print the license of the package"),
        ('licence', None,
         "alias for --license"),
        ('description', None,
         "print the package description"),
        ('long-description', None,
         "print the long package description"),
        ('platforms', None,
         "print the list of platforms"),
        ('classifiers', None,
         "print the list of classifiers"),
        ('keywords', None,
         "print the list of keywords"),
        ('provides', None,
         "print the list of packages/modules provided"),
        ('requires', None,
         "print the list of packages/modules required"),
        ('obsoletes', None,
         "print the list of packages/modules made obsolete")
        ]
    display_option_names = map(lambda x: translate_longopt(x[0]),
                               display_options)

    # negative options are options that exclude other options
    negative_opt = {'quiet': 'verbose'}


    @others
    # -- Metadata query methods ----------------------------------------

    # If you're looking for 'get_name()', 'get_version()', and so forth,
    # they are defined in a sneaky way: the constructor binds self.get_XXX
    # to self.metadata.get_XXX.  The actual code is in the
    # DistributionMetadata class, below.

</t>
<t tx="ekr.20080401090728.296"># -- Creation/initialization methods -------------------------------

def __init__ (self, attrs=None):
    """Construct a new Distribution instance: initialize all the
    attributes of a Distribution, and then use 'attrs' (a dictionary
    mapping attribute names to values) to assign some of those
    attributes their "real" values.  (Any attributes not mentioned in
    'attrs' will be assigned to some null value: 0, None, an empty list
    or dictionary, etc.)  Most importantly, initialize the
    'command_obj' attribute to the empty dictionary; this will be
    filled in with real command objects by 'parse_command_line()'.
    """

    # Default values for our command-line options
    self.verbose = 1
    self.dry_run = 0
    self.help = 0
    for attr in self.display_option_names:
        setattr(self, attr, 0)

    # Store the distribution meta-data (name, version, author, and so
    # forth) in a separate object -- we're getting to have enough
    # information here (and enough command-line options) that it's
    # worth it.  Also delegate 'get_XXX()' methods to the 'metadata'
    # object in a sneaky and underhanded (but efficient!) way.
    self.metadata = DistributionMetadata()
    for basename in self.metadata._METHOD_BASENAMES:
        method_name = "get_" + basename
        setattr(self, method_name, getattr(self.metadata, method_name))

    # 'cmdclass' maps command names to class objects, so we
    # can 1) quickly figure out which class to instantiate when
    # we need to create a new command object, and 2) have a way
    # for the setup script to override command classes
    self.cmdclass = {}

    # 'command_packages' is a list of packages in which commands
    # are searched for.  The factory for command 'foo' is expected
    # to be named 'foo' in the module 'foo' in one of the packages
    # named here.  This list is searched from the left; an error
    # is raised if no named package provides the command being
    # searched for.  (Always access using get_command_packages().)
    self.command_packages = None

    # 'script_name' and 'script_args' are usually set to sys.argv[0]
    # and sys.argv[1:], but they can be overridden when the caller is
    # not necessarily a setup script run from the command-line.
    self.script_name = None
    self.script_args = None

    # 'command_options' is where we store command options between
    # parsing them (from config files, the command-line, etc.) and when
    # they are actually needed -- ie. when the command in question is
    # instantiated.  It is a dictionary of dictionaries of 2-tuples:
    #   command_options = { command_name : { option : (source, value) } }
    self.command_options = {}

    # 'dist_files' is the list of (command, pyversion, file) that
    # have been created by any dist commands run so far. This is
    # filled regardless of whether the run is dry or not. pyversion
    # gives sysconfig.get_python_version() if the dist file is
    # specific to a Python version, 'any' if it is good for all
    # Python versions on the target platform, and '' for a source
    # file. pyversion should not be used to specify minimum or
    # maximum required Python versions; use the metainfo for that
    # instead.
    self.dist_files = []

    # These options are really the business of various commands, rather
    # than of the Distribution itself.  We provide aliases for them in
    # Distribution as a convenience to the developer.
    self.packages = None
    self.package_data = {}
    self.package_dir = None
    self.py_modules = None
    self.libraries = None
    self.headers = None
    self.ext_modules = None
    self.ext_package = None
    self.include_dirs = None
    self.extra_path = None
    self.scripts = None
    self.data_files = None

    # And now initialize bookkeeping stuff that can't be supplied by
    # the caller at all.  'command_obj' maps command names to
    # Command instances -- that's how we enforce that every command
    # class is a singleton.
    self.command_obj = {}

    # 'have_run' maps command names to boolean values; it keeps track
    # of whether we have actually run a particular command, to make it
    # cheap to "run" a command whenever we think we might need to -- if
    # it's already been done, no need for expensive filesystem
    # operations, we just check the 'have_run' dictionary and carry on.
    # It's only safe to query 'have_run' for a command class that has
    # been instantiated -- a false value will be inserted when the
    # command object is created, and replaced with a true value when
    # the command is successfully run.  Thus it's probably best to use
    # '.get()' rather than a straight lookup.
    self.have_run = {}

    # Now we'll use the attrs dictionary (ultimately, keyword args from
    # the setup script) to possibly override any or all of these
    # distribution options.

    if attrs:
        # Pull out the set of command options and work on them
        # specifically.  Note that this order guarantees that aliased
        # command options will override any supplied redundantly
        # through the general options dictionary.
        options = attrs.get('options')
        if options:
            del attrs['options']
            for (command, cmd_options) in options.items():
                opt_dict = self.get_option_dict(command)
                for (opt, val) in cmd_options.items():
                    opt_dict[opt] = ("setup script", val)

        if attrs.has_key('licence'):
            attrs['license'] = attrs['licence']
            del attrs['licence']
            msg = "'licence' distribution option is deprecated; use 'license'"
            if warnings is not None:
                warnings.warn(msg)
            else:
                sys.stderr.write(msg + "\n")

        # Now work on the rest of the attributes.  Any attribute that's
        # not already defined is invalid!
        for (key,val) in attrs.items():
            if hasattr(self.metadata, "set_" + key):
                getattr(self.metadata, "set_" + key)(val)
            elif hasattr(self.metadata, key):
                setattr(self.metadata, key, val)
            elif hasattr(self, key):
                setattr(self, key, val)
            else:
                msg = "Unknown distribution option: %s" % repr(key)
                if warnings is not None:
                    warnings.warn(msg)
                else:
                    sys.stderr.write(msg + "\n")

    self.finalize_options()

</t>
<t tx="ekr.20080401090728.297"># __init__ ()


def get_option_dict (self, command):
    """Get the option dictionary for a given command.  If that
    command's option dictionary hasn't been created yet, then create it
    and return the new dictionary; otherwise, return the existing
    option dictionary.
    """

    dict = self.command_options.get(command)
    if dict is None:
        dict = self.command_options[command] = {}
    return dict


</t>
<t tx="ekr.20080401090728.298">def dump_option_dicts (self, header=None, commands=None, indent=""):
    from pprint import pformat

    if commands is None:             # dump all command option dicts
        commands = self.command_options.keys()
        commands.sort()

    if header is not None:
        print indent + header
        indent = indent + "  "

    if not commands:
        print indent + "no commands known yet"
        return

    for cmd_name in commands:
        opt_dict = self.command_options.get(cmd_name)
        if opt_dict is None:
            print indent + "no option dict for '%s' command" % cmd_name
        else:
            print indent + "option dict for '%s' command:" % cmd_name
            out = pformat(opt_dict)
            for line in string.split(out, "\n"):
                print indent + "  " + line

</t>
<t tx="ekr.20080401090728.299"># dump_option_dicts ()



# -- Config file finding/parsing methods ---------------------------

def find_config_files (self):
    """Find as many configuration files as should be processed for this
    platform, and return a list of filenames in the order in which they
    should be parsed.  The filenames returned are guaranteed to exist
    (modulo nasty race conditions).

    There are three possible config files: distutils.cfg in the
    Distutils installation directory (ie. where the top-level
    Distutils __inst__.py file lives), a file in the user's home
    directory named .pydistutils.cfg on Unix and pydistutils.cfg
    on Windows/Mac, and setup.cfg in the current directory.
    """
    files = []
    check_environ()

    # Where to look for the system-wide Distutils config file
    sys_dir = os.path.dirname(sys.modules['distutils'].__file__)

    # Look for the system config file
    sys_file = os.path.join(sys_dir, "distutils.cfg")
    if os.path.isfile(sys_file):
        files.append(sys_file)

    # What to call the per-user config file
    if os.name == 'posix':
        user_filename = ".pydistutils.cfg"
    else:
        user_filename = "pydistutils.cfg"

    # And look for the user config file
    if os.environ.has_key('HOME'):
        user_file = os.path.join(os.environ.get('HOME'), user_filename)
        if os.path.isfile(user_file):
            files.append(user_file)

    # All platforms support local setup.cfg
    local_file = "setup.cfg"
    if os.path.isfile(local_file):
        files.append(local_file)

    return files

</t>
<t tx="ekr.20080401090728.300"># find_config_files ()


def parse_config_files (self, filenames=None):

    from ConfigParser import ConfigParser

    if filenames is None:
        filenames = self.find_config_files()

    if DEBUG: print "Distribution.parse_config_files():"

    parser = ConfigParser()
    for filename in filenames:
        if DEBUG: print "  reading", filename
        parser.read(filename)
        for section in parser.sections():
            options = parser.options(section)
            opt_dict = self.get_option_dict(section)

            for opt in options:
                if opt != '__name__':
                    val = parser.get(section,opt)
                    opt = string.replace(opt, '-', '_')
                    opt_dict[opt] = (filename, val)

        # Make the ConfigParser forget everything (so we retain
        # the original filenames that options come from)
        parser.__init__()

    # If there was a "global" section in the config file, use it
    # to set Distribution options.

    if self.command_options.has_key('global'):
        for (opt, (src, val)) in self.command_options['global'].items():
            alias = self.negative_opt.get(opt)
            try:
                if alias:
                    setattr(self, alias, not strtobool(val))
                elif opt in ('verbose', 'dry_run'): # ugh!
                    setattr(self, opt, strtobool(val))
                else:
                    setattr(self, opt, val)
            except ValueError, msg:
                raise DistutilsOptionError, msg

</t>
<t tx="ekr.20080401090728.301"># parse_config_files ()


# -- Command-line parsing methods ----------------------------------

def parse_command_line (self):
    """Parse the setup script's command line, taken from the
    'script_args' instance attribute (which defaults to 'sys.argv[1:]'
    -- see 'setup()' in core.py).  This list is first processed for
    "global options" -- options that set attributes of the Distribution
    instance.  Then, it is alternately scanned for Distutils commands
    and options for that command.  Each new command terminates the
    options for the previous command.  The allowed options for a
    command are determined by the 'user_options' attribute of the
    command class -- thus, we have to be able to load command classes
    in order to parse the command line.  Any error in that 'options'
    attribute raises DistutilsGetoptError; any error on the
    command-line raises DistutilsArgError.  If no Distutils commands
    were found on the command line, raises DistutilsArgError.  Return
    true if command-line was successfully parsed and we should carry
    on with executing commands; false if no errors but we shouldn't
    execute commands (currently, this only happens if user asks for
    help).
    """
    #
    # We now have enough information to show the Macintosh dialog
    # that allows the user to interactively specify the "command line".
    #
    toplevel_options = self._get_toplevel_options()
    if sys.platform == 'mac':
        import EasyDialogs
        cmdlist = self.get_command_list()
        self.script_args = EasyDialogs.GetArgv(
            toplevel_options + self.display_options, cmdlist)

    # We have to parse the command line a bit at a time -- global
    # options, then the first command, then its options, and so on --
    # because each command will be handled by a different class, and
    # the options that are valid for a particular class aren't known
    # until we have loaded the command class, which doesn't happen
    # until we know what the command is.

    self.commands = []
    parser = FancyGetopt(toplevel_options + self.display_options)
    parser.set_negative_aliases(self.negative_opt)
    parser.set_aliases({'licence': 'license'})
    args = parser.getopt(args=self.script_args, object=self)
    option_order = parser.get_option_order()
    log.set_verbosity(self.verbose)

    # for display options we return immediately
    if self.handle_display_options(option_order):
        return

    while args:
        args = self._parse_command_opts(parser, args)
        if args is None:            # user asked for help (and got it)
            return

    # Handle the cases of --help as a "global" option, ie.
    # "setup.py --help" and "setup.py --help command ...".  For the
    # former, we show global options (--verbose, --dry-run, etc.)
    # and display-only options (--name, --version, etc.); for the
    # latter, we omit the display-only options and show help for
    # each command listed on the command line.
    if self.help:
        self._show_help(parser,
                        display_options=len(self.commands) == 0,
                        commands=self.commands)
        return

    # Oops, no commands found -- an end-user error
    if not self.commands:
        raise DistutilsArgError, "no commands supplied"

    # All is well: return true
    return 1

</t>
<t tx="ekr.20080401090728.302"># parse_command_line()

def _get_toplevel_options (self):
    """Return the non-display options recognized at the top level.

    This includes options that are recognized *only* at the top
    level as well as options recognized for commands.
    """
    return self.global_options + [
        ("command-packages=", None,
         "list of packages that provide distutils commands"),
        ]

</t>
<t tx="ekr.20080401090728.303">def _parse_command_opts (self, parser, args):
    """Parse the command-line options for a single command.
    'parser' must be a FancyGetopt instance; 'args' must be the list
    of arguments, starting with the current command (whose options
    we are about to parse).  Returns a new version of 'args' with
    the next command at the front of the list; will be the empty
    list if there are no more commands on the command line.  Returns
    None if the user asked for help on this command.
    """
    # late import because of mutual dependence between these modules
    from distutils.cmd import Command

    # Pull the current command from the head of the command line
    command = args[0]
    if not command_re.match(command):
        raise SystemExit, "invalid command name '%s'" % command
    self.commands.append(command)

    # Dig up the command class that implements this command, so we
    # 1) know that it's a valid command, and 2) know which options
    # it takes.
    try:
        cmd_class = self.get_command_class(command)
    except DistutilsModuleError, msg:
        raise DistutilsArgError, msg

    # Require that the command class be derived from Command -- want
    # to be sure that the basic "command" interface is implemented.
    if not issubclass(cmd_class, Command):
        raise DistutilsClassError, \
              "command class %s must subclass Command" % cmd_class

    # Also make sure that the command object provides a list of its
    # known options.
    if not (hasattr(cmd_class, 'user_options') and
            type(cmd_class.user_options) is ListType):
        raise DistutilsClassError, \
              ("command class %s must provide " +
               "'user_options' attribute (a list of tuples)") % \
              cmd_class

    # If the command class has a list of negative alias options,
    # merge it in with the global negative aliases.
    negative_opt = self.negative_opt
    if hasattr(cmd_class, 'negative_opt'):
        negative_opt = copy(negative_opt)
        negative_opt.update(cmd_class.negative_opt)

    # Check for help_options in command class.  They have a different
    # format (tuple of four) so we need to preprocess them here.
    if (hasattr(cmd_class, 'help_options') and
        type(cmd_class.help_options) is ListType):
        help_options = fix_help_options(cmd_class.help_options)
    else:
        help_options = []


    # All commands support the global options too, just by adding
    # in 'global_options'.
    parser.set_option_table(self.global_options +
                            cmd_class.user_options +
                            help_options)
    parser.set_negative_aliases(negative_opt)
    (args, opts) = parser.getopt(args[1:])
    if hasattr(opts, 'help') and opts.help:
        self._show_help(parser, display_options=0, commands=[cmd_class])
        return

    if (hasattr(cmd_class, 'help_options') and
        type(cmd_class.help_options) is ListType):
        help_option_found=0
        for (help_option, short, desc, func) in cmd_class.help_options:
            if hasattr(opts, parser.get_attr_name(help_option)):
                help_option_found=1
                #print "showing help for option %s of command %s" % \
                #      (help_option[0],cmd_class)

                if callable(func):
                    func()
                else:
                    raise DistutilsClassError(
                        "invalid help function %r for help option '%s': "
                        "must be a callable object (function, etc.)"
                        % (func, help_option))

        if help_option_found:
            return

    # Put the options from the command-line into their official
    # holding pen, the 'command_options' dictionary.
    opt_dict = self.get_option_dict(command)
    for (name, value) in vars(opts).items():
        opt_dict[name] = ("command line", value)

    return args

</t>
<t tx="ekr.20080401090728.304"># _parse_command_opts ()

def finalize_options (self):
    """Set final values for all the options on the Distribution
    instance, analogous to the .finalize_options() method of Command
    objects.
    """

    keywords = self.metadata.keywords
    if keywords is not None:
        if type(keywords) is StringType:
            keywordlist = string.split(keywords, ',')
            self.metadata.keywords = map(string.strip, keywordlist)

    platforms = self.metadata.platforms
    if platforms is not None:
        if type(platforms) is StringType:
            platformlist = string.split(platforms, ',')
            self.metadata.platforms = map(string.strip, platformlist)

</t>
<t tx="ekr.20080401090728.305">def _show_help (self,
                parser,
                global_options=1,
                display_options=1,
                commands=[]):
    """Show help for the setup script command-line in the form of
    several lists of command-line options.  'parser' should be a
    FancyGetopt instance; do not expect it to be returned in the
    same state, as its option table will be reset to make it
    generate the correct help text.

    If 'global_options' is true, lists the global options:
    --verbose, --dry-run, etc.  If 'display_options' is true, lists
    the "display-only" options: --name, --version, etc.  Finally,
    lists per-command help for every command name or command class
    in 'commands'.
    """
    # late import because of mutual dependence between these modules
    from distutils.core import gen_usage
    from distutils.cmd import Command

    if global_options:
        if display_options:
            options = self._get_toplevel_options()
        else:
            options = self.global_options
        parser.set_option_table(options)
        parser.print_help(self.common_usage + "\nGlobal options:")
        print

    if display_options:
        parser.set_option_table(self.display_options)
        parser.print_help(
            "Information display options (just display " +
            "information, ignore any commands)")
        print

    for command in self.commands:
        if type(command) is ClassType and issubclass(command, Command):
            klass = command
        else:
            klass = self.get_command_class(command)
        if (hasattr(klass, 'help_options') and
            type(klass.help_options) is ListType):
            parser.set_option_table(klass.user_options +
                                    fix_help_options(klass.help_options))
        else:
            parser.set_option_table(klass.user_options)
        parser.print_help("Options for '%s' command:" % klass.__name__)
        print

    print gen_usage(self.script_name)
    return

</t>
<t tx="ekr.20080401090728.306"># _show_help ()


def handle_display_options (self, option_order):
    """If there were any non-global "display-only" options
    (--help-commands or the metadata display options) on the command
    line, display the requested info and return true; else return
    false.
    """
    from distutils.core import gen_usage

    # User just wants a list of commands -- we'll print it out and stop
    # processing now (ie. if they ran "setup --help-commands foo bar",
    # we ignore "foo bar").
    if self.help_commands:
        self.print_commands()
        print
        print gen_usage(self.script_name)
        return 1

    # If user supplied any of the "display metadata" options, then
    # display that metadata in the order in which the user supplied the
    # metadata options.
    any_display_options = 0
    is_display_option = {}
    for option in self.display_options:
        is_display_option[option[0]] = 1

    for (opt, val) in option_order:
        if val and is_display_option.get(opt):
            opt = translate_longopt(opt)
            value = getattr(self.metadata, "get_"+opt)()
            if opt in ['keywords', 'platforms']:
                print string.join(value, ',')
            elif opt in ('classifiers', 'provides', 'requires',
                         'obsoletes'):
                print string.join(value, '\n')
            else:
                print value
            any_display_options = 1

    return any_display_options

</t>
<t tx="ekr.20080401090728.307"># handle_display_options()

def print_command_list (self, commands, header, max_length):
    """Print a subset of the list of all commands -- used by
    'print_commands()'.
    """

    print header + ":"

    for cmd in commands:
        klass = self.cmdclass.get(cmd)
        if not klass:
            klass = self.get_command_class(cmd)
        try:
            description = klass.description
        except AttributeError:
            description = "(no description available)"

        print "  %-*s  %s" % (max_length, cmd, description)

</t>
<t tx="ekr.20080401090728.308"># print_command_list ()


def print_commands (self):
    """Print out a help message listing all available commands with a
    description of each.  The list is divided into "standard commands"
    (listed in distutils.command.__all__) and "extra commands"
    (mentioned in self.cmdclass, but not a standard command).  The
    descriptions come from the command class attribute
    'description'.
    """

    import distutils.command
    std_commands = distutils.command.__all__
    is_std = {}
    for cmd in std_commands:
        is_std[cmd] = 1

    extra_commands = []
    for cmd in self.cmdclass.keys():
        if not is_std.get(cmd):
            extra_commands.append(cmd)

    max_length = 0
    for cmd in (std_commands + extra_commands):
        if len(cmd) &gt; max_length:
            max_length = len(cmd)

    self.print_command_list(std_commands,
                            "Standard commands",
                            max_length)
    if extra_commands:
        print
        self.print_command_list(extra_commands,
                                "Extra commands",
                                max_length)

</t>
<t tx="ekr.20080401090728.309"># print_commands ()

def get_command_list (self):
    """Get a list of (command, description) tuples.
    The list is divided into "standard commands" (listed in
    distutils.command.__all__) and "extra commands" (mentioned in
    self.cmdclass, but not a standard command).  The descriptions come
    from the command class attribute 'description'.
    """
    # Currently this is only used on Mac OS, for the Mac-only GUI
    # Distutils interface (by Jack Jansen)

    import distutils.command
    std_commands = distutils.command.__all__
    is_std = {}
    for cmd in std_commands:
        is_std[cmd] = 1

    extra_commands = []
    for cmd in self.cmdclass.keys():
        if not is_std.get(cmd):
            extra_commands.append(cmd)

    rv = []
    for cmd in (std_commands + extra_commands):
        klass = self.cmdclass.get(cmd)
        if not klass:
            klass = self.get_command_class(cmd)
        try:
            description = klass.description
        except AttributeError:
            description = "(no description available)"
        rv.append((cmd, description))
    return rv

</t>
<t tx="ekr.20080401090728.310"># -- Command class/object methods ----------------------------------

def get_command_packages (self):
    """Return a list of packages from which commands are loaded."""
    pkgs = self.command_packages
    if not isinstance(pkgs, type([])):
        pkgs = string.split(pkgs or "", ",")
        for i in range(len(pkgs)):
            pkgs[i] = string.strip(pkgs[i])
        pkgs = filter(None, pkgs)
        if "distutils.command" not in pkgs:
            pkgs.insert(0, "distutils.command")
        self.command_packages = pkgs
    return pkgs

</t>
<t tx="ekr.20080401090728.311">def get_command_class (self, command):
    """Return the class that implements the Distutils command named by
    'command'.  First we check the 'cmdclass' dictionary; if the
    command is mentioned there, we fetch the class object from the
    dictionary and return it.  Otherwise we load the command module
    ("distutils.command." + command) and fetch the command class from
    the module.  The loaded class is also stored in 'cmdclass'
    to speed future calls to 'get_command_class()'.

    Raises DistutilsModuleError if the expected module could not be
    found, or if that module does not define the expected class.
    """
    klass = self.cmdclass.get(command)
    if klass:
        return klass

    for pkgname in self.get_command_packages():
        module_name = "%s.%s" % (pkgname, command)
        klass_name = command

        try:
            __import__ (module_name)
            module = sys.modules[module_name]
        except ImportError:
            continue

        try:
            klass = getattr(module, klass_name)
        except AttributeError:
            raise DistutilsModuleError, \
                  "invalid command '%s' (no class '%s' in module '%s')" \
                  % (command, klass_name, module_name)

        self.cmdclass[command] = klass
        return klass

    raise DistutilsModuleError("invalid command '%s'" % command)


</t>
<t tx="ekr.20080401090728.312"># get_command_class ()

def get_command_obj (self, command, create=1):
    """Return the command object for 'command'.  Normally this object
    is cached on a previous call to 'get_command_obj()'; if no command
    object for 'command' is in the cache, then we either create and
    return it (if 'create' is true) or return None.
    """
    cmd_obj = self.command_obj.get(command)
    if not cmd_obj and create:
        if DEBUG:
            print "Distribution.get_command_obj(): " \
                  "creating '%s' command object" % command

        klass = self.get_command_class(command)
        cmd_obj = self.command_obj[command] = klass(self)
        self.have_run[command] = 0

        # Set any options that were supplied in config files
        # or on the command line.  (NB. support for error
        # reporting is lame here: any errors aren't reported
        # until 'finalize_options()' is called, which means
        # we won't report the source of the error.)
        options = self.command_options.get(command)
        if options:
            self._set_command_options(cmd_obj, options)

    return cmd_obj

</t>
<t tx="ekr.20080401090728.313">def _set_command_options (self, command_obj, option_dict=None):
    """Set the options for 'command_obj' from 'option_dict'.  Basically
    this means copying elements of a dictionary ('option_dict') to
    attributes of an instance ('command').

    'command_obj' must be a Command instance.  If 'option_dict' is not
    supplied, uses the standard option dictionary for this command
    (from 'self.command_options').
    """
    command_name = command_obj.get_command_name()
    if option_dict is None:
        option_dict = self.get_option_dict(command_name)

    if DEBUG: print "  setting options for '%s' command:" % command_name
    for (option, (source, value)) in option_dict.items():
        if DEBUG: print "    %s = %s (from %s)" % (option, value, source)
        try:
            bool_opts = map(translate_longopt, command_obj.boolean_options)
        except AttributeError:
            bool_opts = []
        try:
            neg_opt = command_obj.negative_opt
        except AttributeError:
            neg_opt = {}

        try:
            is_string = type(value) is StringType
            if neg_opt.has_key(option) and is_string:
                setattr(command_obj, neg_opt[option], not strtobool(value))
            elif option in bool_opts and is_string:
                setattr(command_obj, option, strtobool(value))
            elif hasattr(command_obj, option):
                setattr(command_obj, option, value)
            else:
                raise DistutilsOptionError, \
                      ("error in %s: command '%s' has no such option '%s'"
                       % (source, command_name, option))
        except ValueError, msg:
            raise DistutilsOptionError, msg

</t>
<t tx="ekr.20080401090728.314">def reinitialize_command (self, command, reinit_subcommands=0):
    """Reinitializes a command to the state it was in when first
    returned by 'get_command_obj()': ie., initialized but not yet
    finalized.  This provides the opportunity to sneak option
    values in programmatically, overriding or supplementing
    user-supplied values from the config files and command line.
    You'll have to re-finalize the command object (by calling
    'finalize_options()' or 'ensure_finalized()') before using it for
    real.

    'command' should be a command name (string) or command object.  If
    'reinit_subcommands' is true, also reinitializes the command's
    sub-commands, as declared by the 'sub_commands' class attribute (if
    it has one).  See the "install" command for an example.  Only
    reinitializes the sub-commands that actually matter, ie. those
    whose test predicates return true.

    Returns the reinitialized command object.
    """
    from distutils.cmd import Command
    if not isinstance(command, Command):
        command_name = command
        command = self.get_command_obj(command_name)
    else:
        command_name = command.get_command_name()

    if not command.finalized:
        return command
    command.initialize_options()
    command.finalized = 0
    self.have_run[command_name] = 0
    self._set_command_options(command)

    if reinit_subcommands:
        for sub in command.get_sub_commands():
            self.reinitialize_command(sub, reinit_subcommands)

    return command


</t>
<t tx="ekr.20080401090728.315"># -- Methods that operate on the Distribution ----------------------

def announce (self, msg, level=1):
    log.debug(msg)

</t>
<t tx="ekr.20080401090728.316">def run_commands (self):
    """Run each command that was seen on the setup script command line.
    Uses the list of commands found and cache of command objects
    created by 'get_command_obj()'.
    """
    for cmd in self.commands:
        self.run_command(cmd)


</t>
<t tx="ekr.20080401090728.317"># -- Methods that operate on its Commands --------------------------

def run_command (self, command):
    """Do whatever it takes to run a command (including nothing at all,
    if the command has already been run).  Specifically: if we have
    already created and run the command named by 'command', return
    silently without doing anything.  If the command named by 'command'
    doesn't even have a command object yet, create one.  Then invoke
    'run()' on that command object (or an existing one).
    """
    # Already been here, done that? then return silently.
    if self.have_run.get(command):
        return

    log.info("running %s", command)
    cmd_obj = self.get_command_obj(command)
    cmd_obj.ensure_finalized()
    cmd_obj.run()
    self.have_run[command] = 1


</t>
<t tx="ekr.20080401090728.318"># -- Distribution query methods ------------------------------------

def has_pure_modules (self):
    return len(self.packages or self.py_modules or []) &gt; 0

</t>
<t tx="ekr.20080401090728.319">def has_ext_modules (self):
    return self.ext_modules and len(self.ext_modules) &gt; 0

</t>
<t tx="ekr.20080401090728.320">def has_c_libraries (self):
    return self.libraries and len(self.libraries) &gt; 0

</t>
<t tx="ekr.20080401090728.321">def has_modules (self):
    return self.has_pure_modules() or self.has_ext_modules()

</t>
<t tx="ekr.20080401090728.322">def has_headers (self):
    return self.headers and len(self.headers) &gt; 0

</t>
<t tx="ekr.20080401090728.323">def has_scripts (self):
    return self.scripts and len(self.scripts) &gt; 0

</t>
<t tx="ekr.20080401090728.324">def has_data_files (self):
    return self.data_files and len(self.data_files) &gt; 0

</t>
<t tx="ekr.20080401090728.325">def is_pure (self):
    return (self.has_pure_modules() and
            not self.has_ext_modules() and
            not self.has_c_libraries())

</t>
<t tx="ekr.20080401090728.326"># class Distribution


class DistributionMetadata:
    """Dummy class to hold the distribution meta-data: name, version,
    author, and so forth.
    """

    _METHOD_BASENAMES = ("name", "version", "author", "author_email",
                         "maintainer", "maintainer_email", "url",
                         "license", "description", "long_description",
                         "keywords", "platforms", "fullname", "contact",
                         "contact_email", "license", "classifiers",
                         "download_url",
                         # PEP 314
                         "provides", "requires", "obsoletes",
                         )

    @others
</t>
<t tx="ekr.20080401090728.327">def __init__ (self):
    self.name = None
    self.version = None
    self.author = None
    self.author_email = None
    self.maintainer = None
    self.maintainer_email = None
    self.url = None
    self.license = None
    self.description = None
    self.long_description = None
    self.keywords = None
    self.platforms = None
    self.classifiers = None
    self.download_url = None
    # PEP 314
    self.provides = None
    self.requires = None
    self.obsoletes = None

</t>
<t tx="ekr.20080401090728.328">def write_pkg_info (self, base_dir):
    """Write the PKG-INFO file into the release tree.
    """
    pkg_info = open( os.path.join(base_dir, 'PKG-INFO'), 'w')

    self.write_pkg_file(pkg_info)

    pkg_info.close()

</t>
<t tx="ekr.20080401090728.329"># write_pkg_info ()

def write_pkg_file (self, file):
    """Write the PKG-INFO format data to a file object.
    """
    version = '1.0'
    if self.provides or self.requires or self.obsoletes:
        version = '1.1'

    file.write('Metadata-Version: %s\n' % version)
    file.write('Name: %s\n' % self.get_name() )
    file.write('Version: %s\n' % self.get_version() )
    file.write('Summary: %s\n' % self.get_description() )
    file.write('Home-page: %s\n' % self.get_url() )
    file.write('Author: %s\n' % self.get_contact() )
    file.write('Author-email: %s\n' % self.get_contact_email() )
    file.write('License: %s\n' % self.get_license() )
    if self.download_url:
        file.write('Download-URL: %s\n' % self.download_url)

    long_desc = rfc822_escape( self.get_long_description() )
    file.write('Description: %s\n' % long_desc)

    keywords = string.join( self.get_keywords(), ',')
    if keywords:
        file.write('Keywords: %s\n' % keywords )

    self._write_list(file, 'Platform', self.get_platforms())
    self._write_list(file, 'Classifier', self.get_classifiers())

    # PEP 314
    self._write_list(file, 'Requires', self.get_requires())
    self._write_list(file, 'Provides', self.get_provides())
    self._write_list(file, 'Obsoletes', self.get_obsoletes())

</t>
<t tx="ekr.20080401090728.330">def _write_list (self, file, name, values):
    for value in values:
        file.write('%s: %s\n' % (name, value))

</t>
<t tx="ekr.20080401090728.331"># -- Metadata query methods ----------------------------------------

def get_name (self):
    return self.name or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.332">def get_version(self):
    return self.version or "0.0.0"

</t>
<t tx="ekr.20080401090728.333">def get_fullname (self):
    return "%s-%s" % (self.get_name(), self.get_version())

</t>
<t tx="ekr.20080401090728.334">def get_author(self):
    return self.author or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.335">def get_author_email(self):
    return self.author_email or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.336">def get_maintainer(self):
    return self.maintainer or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.337">def get_maintainer_email(self):
    return self.maintainer_email or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.338">def get_contact(self):
    return (self.maintainer or
            self.author or
            "UNKNOWN")

</t>
<t tx="ekr.20080401090728.339">def get_contact_email(self):
    return (self.maintainer_email or
            self.author_email or
            "UNKNOWN")

</t>
<t tx="ekr.20080401090728.340">def get_url(self):
    return self.url or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.341">def get_license(self):
    return self.license or "UNKNOWN"
</t>
<t tx="ekr.20080401090728.342">get_licence = get_license

def get_description(self):
    return self.description or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.343">def get_long_description(self):
    return self.long_description or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.344">def get_keywords(self):
    return self.keywords or []

</t>
<t tx="ekr.20080401090728.345">def get_platforms(self):
    return self.platforms or ["UNKNOWN"]

</t>
<t tx="ekr.20080401090728.346">def get_classifiers(self):
    return self.classifiers or []

</t>
<t tx="ekr.20080401090728.347">def get_download_url(self):
    return self.download_url or "UNKNOWN"

</t>
<t tx="ekr.20080401090728.348"># PEP 314

def get_requires(self):
    return self.requires or []

</t>
<t tx="ekr.20080401090728.349">def set_requires(self, value):
    import distutils.versionpredicate
    for v in value:
        distutils.versionpredicate.VersionPredicate(v)
    self.requires = value

</t>
<t tx="ekr.20080401090728.350">def get_provides(self):
    return self.provides or []

</t>
<t tx="ekr.20080401090728.351">def set_provides(self, value):
    value = [v.strip() for v in value]
    for v in value:
        import distutils.versionpredicate
        distutils.versionpredicate.split_provision(v)
    self.provides = value

</t>
<t tx="ekr.20080401090728.352">def get_obsoletes(self):
    return self.obsoletes or []

</t>
<t tx="ekr.20080401090728.353">def set_obsoletes(self, value):
    import distutils.versionpredicate
    for v in value:
        distutils.versionpredicate.VersionPredicate(v)
    self.obsoletes = value

</t>
<t tx="ekr.20080401090728.354"># class DistributionMetadata


def fix_help_options (options):
    """Convert a 4-tuple 'help_options' list as found in various command
    classes to the 3-tuple form required by FancyGetopt.
    """
    new_options = []
    for help_tuple in options:
        new_options.append(help_tuple[0:3])
    return new_options


</t>
<t tx="ekr.20080401090728.355">"""distutils.emxccompiler

Provides the EMXCCompiler class, a subclass of UnixCCompiler that
handles the EMX port of the GNU C compiler to OS/2.
"""

# issues:
#
# * OS/2 insists that DLLs can have names no longer than 8 characters
#   We put export_symbols in a def-file, as though the DLL can have
#   an arbitrary length name, but truncate the output filename.
#
# * only use OMF objects and use LINK386 as the linker (-Zomf)
#
# * always build for multithreading (-Zmt) as the accompanying OS/2 port
#   of Python is only distributed with threads enabled.
#
# tested configurations:
#
# * EMX gcc 2.81/EMX 0.9d fix03

__revision__ = "$Id: emxccompiler.py 34786 2003-12-02 12:17:59Z aimacintyre $"

import os,sys,copy
from distutils.ccompiler import gen_preprocess_options, gen_lib_options
from distutils.unixccompiler import UnixCCompiler
from distutils.file_util import write_file
from distutils.errors import DistutilsExecError, CompileError, UnknownFileError
from distutils import log

</t>
<t tx="ekr.20080401090728.356">class EMXCCompiler (UnixCCompiler):

    compiler_type = 'emx'
    obj_extension = ".obj"
    static_lib_extension = ".lib"
    shared_lib_extension = ".dll"
    static_lib_format = "%s%s"
    shared_lib_format = "%s%s"
    res_extension = ".res"      # compiled resource file
    exe_extension = ".exe"

    @others
</t>
<t tx="ekr.20080401090728.357">def __init__ (self,
              verbose=0,
              dry_run=0,
              force=0):

    UnixCCompiler.__init__ (self, verbose, dry_run, force)

    (status, details) = check_config_h()
    self.debug_print("Python's GCC status: %s (details: %s)" %
                     (status, details))
    if status is not CONFIG_H_OK:
        self.warn(
            "Python's pyconfig.h doesn't seem to support your compiler.  " +
            ("Reason: %s." % details) +
            "Compiling may fail because of undefined preprocessor macros.")

    (self.gcc_version, self.ld_version) = \
        get_versions()
    self.debug_print(self.compiler_type + ": gcc %s, ld %s\n" %
                     (self.gcc_version,
                      self.ld_version) )

    # Hard-code GCC because that's what this is all about.
    # XXX optimization, warnings etc. should be customizable.
    self.set_executables(compiler='gcc -Zomf -Zmt -O3 -fomit-frame-pointer -mprobe -Wall',
                         compiler_so='gcc -Zomf -Zmt -O3 -fomit-frame-pointer -mprobe -Wall',
                         linker_exe='gcc -Zomf -Zmt -Zcrtdll',
                         linker_so='gcc -Zomf -Zmt -Zcrtdll -Zdll')

    # want the gcc library statically linked (so that we don't have
    # to distribute a version dependent on the compiler we have)
    self.dll_libraries=["gcc"]

</t>
<t tx="ekr.20080401090728.358"># __init__ ()

def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
    if ext == '.rc':
        # gcc requires '.rc' compiled to binary ('.res') files !!!
        try:
            self.spawn(["rc", "-r", src])
        except DistutilsExecError, msg:
            raise CompileError, msg
    else: # for other files use the C-compiler
        try:
            self.spawn(self.compiler_so + cc_args + [src, '-o', obj] +
                       extra_postargs)
        except DistutilsExecError, msg:
            raise CompileError, msg

</t>
<t tx="ekr.20080401090728.359">def link (self,
          target_desc,
          objects,
          output_filename,
          output_dir=None,
          libraries=None,
          library_dirs=None,
          runtime_library_dirs=None,
          export_symbols=None,
          debug=0,
          extra_preargs=None,
          extra_postargs=None,
          build_temp=None,
          target_lang=None):

    # use separate copies, so we can modify the lists
    extra_preargs = copy.copy(extra_preargs or [])
    libraries = copy.copy(libraries or [])
    objects = copy.copy(objects or [])

    # Additional libraries
    libraries.extend(self.dll_libraries)

    # handle export symbols by creating a def-file
    # with executables this only works with gcc/ld as linker
    if ((export_symbols is not None) and
        (target_desc != self.EXECUTABLE)):
        # (The linker doesn't do anything if output is up-to-date.
        # So it would probably better to check if we really need this,
        # but for this we had to insert some unchanged parts of
        # UnixCCompiler, and this is not what we want.)

        # we want to put some files in the same directory as the
        # object files are, build_temp doesn't help much
        # where are the object files
        temp_dir = os.path.dirname(objects[0])
        # name of dll to give the helper files the same base name
        (dll_name, dll_extension) = os.path.splitext(
            os.path.basename(output_filename))

        # generate the filenames for these files
        def_file = os.path.join(temp_dir, dll_name + ".def")

        # Generate .def file
        contents = [
            "LIBRARY %s INITINSTANCE TERMINSTANCE" % \
            os.path.splitext(os.path.basename(output_filename))[0],
            "DATA MULTIPLE NONSHARED",
            "EXPORTS"]
        for sym in export_symbols:
            contents.append('  "%s"' % sym)
        self.execute(write_file, (def_file, contents),
                     "writing %s" % def_file)

        # next add options for def-file and to creating import libraries
        # for gcc/ld the def-file is specified as any other object files
        objects.append(def_file)

    #end: if ((export_symbols is not None) and
    #        (target_desc != self.EXECUTABLE or self.linker_dll == "gcc")):

    # who wants symbols and a many times larger output file
    # should explicitly switch the debug mode on
    # otherwise we let dllwrap/ld strip the output file
    # (On my machine: 10KB &lt; stripped_file &lt; ??100KB
    #   unstripped_file = stripped_file + XXX KB
    #  ( XXX=254 for a typical python extension))
    if not debug:
        extra_preargs.append("-s")

    UnixCCompiler.link(self,
                       target_desc,
                       objects,
                       output_filename,
                       output_dir,
                       libraries,
                       library_dirs,
                       runtime_library_dirs,
                       None, # export_symbols, we do this in our def-file
                       debug,
                       extra_preargs,
                       extra_postargs,
                       build_temp,
                       target_lang)

</t>
<t tx="ekr.20080401090728.360"># link ()

# -- Miscellaneous methods -----------------------------------------

# override the object_filenames method from CCompiler to
# support rc and res-files
def object_filenames (self,
                      source_filenames,
                      strip_dir=0,
                      output_dir=''):
    if output_dir is None: output_dir = ''
    obj_names = []
    for src_name in source_filenames:
        # use normcase to make sure '.rc' is really '.rc' and not '.RC'
        (base, ext) = os.path.splitext (os.path.normcase(src_name))
        if ext not in (self.src_extensions + ['.rc']):
            raise UnknownFileError, \
                  "unknown file type '%s' (from '%s')" % \
                  (ext, src_name)
        if strip_dir:
            base = os.path.basename (base)
        if ext == '.rc':
            # these need to be compiled to object files
            obj_names.append (os.path.join (output_dir,
                                        base + self.res_extension))
        else:
            obj_names.append (os.path.join (output_dir,
                                        base + self.obj_extension))
    return obj_names

</t>
<t tx="ekr.20080401090728.361"># object_filenames ()

# override the find_library_file method from UnixCCompiler
# to deal with file naming/searching differences
def find_library_file(self, dirs, lib, debug=0):
    shortlib = '%s.lib' % lib
    longlib = 'lib%s.lib' % lib    # this form very rare

    # get EMX's default library directory search path
    try:
        emx_dirs = os.environ['LIBRARY_PATH'].split(';')
    except KeyError:
        emx_dirs = []

    for dir in dirs + emx_dirs:
        shortlibp = os.path.join(dir, shortlib)
        longlibp = os.path.join(dir, longlib)
        if os.path.exists(shortlibp):
            return shortlibp
        elif os.path.exists(longlibp):
            return longlibp

    # Oops, didn't find it in *any* of 'dirs'
    return None

</t>
<t tx="ekr.20080401090728.362"># class EMXCCompiler


# Because these compilers aren't configured in Python's pyconfig.h file by
# default, we should at least warn the user if he is using a unmodified
# version.

CONFIG_H_OK = "ok"
CONFIG_H_NOTOK = "not ok"
CONFIG_H_UNCERTAIN = "uncertain"

def check_config_h():

    """Check if the current Python installation (specifically, pyconfig.h)
    appears amenable to building extensions with GCC.  Returns a tuple
    (status, details), where 'status' is one of the following constants:
      CONFIG_H_OK
        all is well, go ahead and compile
      CONFIG_H_NOTOK
        doesn't look good
      CONFIG_H_UNCERTAIN
        not sure -- unable to read pyconfig.h
    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    """

    # XXX since this function also checks sys.version, it's not strictly a
    # "pyconfig.h" check -- should probably be renamed...

    from distutils import sysconfig
    import string
    # if sys.version contains GCC then python was compiled with
    # GCC, and the pyconfig.h file should be OK
    if string.find(sys.version,"GCC") &gt;= 0:
        return (CONFIG_H_OK, "sys.version mentions 'GCC'")

    fn = sysconfig.get_config_h_filename()
    try:
        # It would probably better to read single lines to search.
        # But we do this only once, and it is fast enough
        f = open(fn)
        s = f.read()
        f.close()

    except IOError, exc:
        # if we can't read this file, we cannot say it is wrong
        # the compiler will complain later about this file as missing
        return (CONFIG_H_UNCERTAIN,
                "couldn't read '%s': %s" % (fn, exc.strerror))

    else:
        # "pyconfig.h" contains an "#ifdef __GNUC__" or something similar
        if string.find(s,"__GNUC__") &gt;= 0:
            return (CONFIG_H_OK, "'%s' mentions '__GNUC__'" % fn)
        else:
            return (CONFIG_H_NOTOK, "'%s' does not mention '__GNUC__'" % fn)


</t>
<t tx="ekr.20080401090728.363">def get_versions():
    """ Try to find out the versions of gcc and ld.
        If not possible it returns None for it.
    """
    from distutils.version import StrictVersion
    from distutils.spawn import find_executable
    import re

    gcc_exe = find_executable('gcc')
    if gcc_exe:
        out = os.popen(gcc_exe + ' -dumpversion','r')
        out_string = out.read()
        out.close()
        result = re.search('(\d+\.\d+\.\d+)',out_string)
        if result:
            gcc_version = StrictVersion(result.group(1))
        else:
            gcc_version = None
    else:
        gcc_version = None
    # EMX ld has no way of reporting version number, and we use GCC
    # anyway - so we can link OMF DLLs
    ld_version = None
    return (gcc_version, ld_version)
</t>
<t tx="ekr.20080401090728.364">"""distutils.errors

Provides exceptions used by the Distutils modules.  Note that Distutils
modules may raise standard exceptions; in particular, SystemExit is
usually raised for errors that are obviously the end-user's fault
(eg. bad command-line arguments).

This module is safe to use in "from ... import *" mode; it only exports
symbols whose names start with "Distutils" and end with "Error"."""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: errors.py 37828 2004-11-10 22:23:15Z loewis $"

</t>
<t tx="ekr.20080401090728.365">class DistutilsError (Exception):
    """The root of all Distutils evil."""
    pass

</t>
<t tx="ekr.20080401090728.366">class DistutilsModuleError (DistutilsError):
    """Unable to load an expected module, or to find an expected class
    within some module (in particular, command modules and classes)."""
    pass

</t>
<t tx="ekr.20080401090728.367">class DistutilsClassError (DistutilsError):
    """Some command class (or possibly distribution class, if anyone
    feels a need to subclass Distribution) is found not to be holding
    up its end of the bargain, ie. implementing some part of the
    "command "interface."""
    pass

</t>
<t tx="ekr.20080401090728.368">class DistutilsGetoptError (DistutilsError):
    """The option table provided to 'fancy_getopt()' is bogus."""
    pass

</t>
<t tx="ekr.20080401090728.369">class DistutilsArgError (DistutilsError):
    """Raised by fancy_getopt in response to getopt.error -- ie. an
    error in the command line usage."""
    pass

</t>
<t tx="ekr.20080401090728.370">class DistutilsFileError (DistutilsError):
    """Any problems in the filesystem: expected file not found, etc.
    Typically this is for problems that we detect before IOError or
    OSError could be raised."""
    pass

</t>
<t tx="ekr.20080401090728.371">class DistutilsOptionError (DistutilsError):
    """Syntactic/semantic errors in command options, such as use of
    mutually conflicting options, or inconsistent options,
    badly-spelled values, etc.  No distinction is made between option
    values originating in the setup script, the command line, config
    files, or what-have-you -- but if we *know* something originated in
    the setup script, we'll raise DistutilsSetupError instead."""
    pass

</t>
<t tx="ekr.20080401090728.372">class DistutilsSetupError (DistutilsError):
    """For errors that can be definitely blamed on the setup script,
    such as invalid keyword arguments to 'setup()'."""
    pass

</t>
<t tx="ekr.20080401090728.373">class DistutilsPlatformError (DistutilsError):
    """We don't know how to do something on the current platform (but
    we do know how to do it on some platform) -- eg. trying to compile
    C files on a platform not supported by a CCompiler subclass."""
    pass

</t>
<t tx="ekr.20080401090728.374">class DistutilsExecError (DistutilsError):
    """Any problems executing an external program (such as the C
    compiler, when compiling C files)."""
    pass

</t>
<t tx="ekr.20080401090728.375">class DistutilsInternalError (DistutilsError):
    """Internal inconsistencies or impossibilities (obviously, this
    should never be seen if the code is working!)."""
    pass

</t>
<t tx="ekr.20080401090728.376">class DistutilsTemplateError (DistutilsError):
    """Syntax error in a file list template."""


</t>
<t tx="ekr.20080401090728.377"># Exception classes used by the CCompiler implementation classes
class CCompilerError (Exception):
    """Some compile/link operation failed."""

</t>
<t tx="ekr.20080401090728.378">class PreprocessError (CCompilerError):
    """Failure to preprocess one or more C/C++ files."""

</t>
<t tx="ekr.20080401090728.379">class CompileError (CCompilerError):
    """Failure to compile one or more C/C++ source files."""

</t>
<t tx="ekr.20080401090728.380">class LibError (CCompilerError):
    """Failure to create a static library from one or more C/C++ object
    files."""

</t>
<t tx="ekr.20080401090728.381">class LinkError (CCompilerError):
    """Failure to link one or more C/C++ object files into an executable
    or shared library file."""

</t>
<t tx="ekr.20080401090728.382">class UnknownFileError (CCompilerError):
    """Attempt to process an unknown file type."""
</t>
<t tx="ekr.20080401090728.383">"""distutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts."""

__revision__ = "$Id: extension.py 37623 2004-10-14 10:02:08Z anthonybaxter $"

import os, string, sys
from types import *

try:
    import warnings
except ImportError:
    warnings = None

</t>
<t tx="ekr.20080401090728.384"># This class is really only used by the "build_ext" command, so it might
# make sense to put it in distutils.command.build_ext.  However, that
# module is already big enough, and I want to make this class a bit more
# complex to simplify some common cases ("foo" module in "foo.c") and do
# better error-checking ("foo.c" actually exists).
#
# Also, putting this in build_ext.py means every setup script would have to
# import that large-ish module (indirectly, through distutils.core) in
# order to do anything.

class Extension:
    """Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
    """
    @others
</t>
<t tx="ekr.20080401090728.385"># When adding arguments to this constructor, be sure to update
# setup_keywords in core.py.
def __init__ (self, name, sources,
              include_dirs=None,
              define_macros=None,
              undef_macros=None,
              library_dirs=None,
              libraries=None,
              runtime_library_dirs=None,
              extra_objects=None,
              extra_compile_args=None,
              extra_link_args=None,
              export_symbols=None,
              swig_opts = None,
              depends=None,
              language=None,
              **kw  # To catch unknown keywords
             ):
    assert type(name) is StringType, "'name' must be a string"
    assert (type(sources) is ListType and
            map(type, sources) == [StringType]*len(sources)), \
            "'sources' must be a list of strings"

    self.name = name
    self.sources = sources
    self.include_dirs = include_dirs or []
    self.define_macros = define_macros or []
    self.undef_macros = undef_macros or []
    self.library_dirs = library_dirs or []
    self.libraries = libraries or []
    self.runtime_library_dirs = runtime_library_dirs or []
    self.extra_objects = extra_objects or []
    self.extra_compile_args = extra_compile_args or []
    self.extra_link_args = extra_link_args or []
    self.export_symbols = export_symbols or []
    self.swig_opts = swig_opts or []
    self.depends = depends or []
    self.language = language

    # If there are unknown keyword options, warn about them
    if len(kw):
        L = kw.keys() ; L.sort()
        L = map(repr, L)
        msg = "Unknown Extension options: " + string.join(L, ', ')
        if warnings is not None:
            warnings.warn(msg)
        else:
            sys.stderr.write(msg + '\n')
</t>
<t tx="ekr.20080401090728.386">def read_setup_file (filename):
    from distutils.sysconfig import \
         parse_makefile, expand_makefile_vars, _variable_rx
    from distutils.text_file import TextFile
    from distutils.util import split_quoted

    # First pass over the file to gather "VAR = VALUE" assignments.
    vars = parse_makefile(filename)

    # Second pass to gobble up the real content: lines of the form
    #   &lt;module&gt; ... [&lt;sourcefile&gt; ...] [&lt;cpparg&gt; ...] [&lt;library&gt; ...]
    file = TextFile(filename,
                    strip_comments=1, skip_blanks=1, join_lines=1,
                    lstrip_ws=1, rstrip_ws=1)
    extensions = []

    while 1:
        line = file.readline()
        if line is None:                # eof
            break
        if _variable_rx.match(line):    # VAR=VALUE, handled in first pass
            continue

        if line[0] == line[-1] == "*":
            file.warn("'%s' lines not handled yet" % line)
            continue

        #print "original line: " + line
        line = expand_makefile_vars(line, vars)
        words = split_quoted(line)
        #print "expanded line: " + line

        # NB. this parses a slightly different syntax than the old
        # makesetup script: here, there must be exactly one extension per
        # line, and it must be the first word of the line.  I have no idea
        # why the old syntax supported multiple extensions per line, as
        # they all wind up being the same.

        module = words[0]
        ext = Extension(module, [])
        append_next_word = None

        for word in words[1:]:
            if append_next_word is not None:
                append_next_word.append(word)
                append_next_word = None
                continue

            suffix = os.path.splitext(word)[1]
            switch = word[0:2] ; value = word[2:]

            if suffix in (".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"):
                # hmm, should we do something about C vs. C++ sources?
                # or leave it up to the CCompiler implementation to
                # worry about?
                ext.sources.append(word)
            elif switch == "-I":
                ext.include_dirs.append(value)
            elif switch == "-D":
                equals = string.find(value, "=")
                if equals == -1:        # bare "-DFOO" -- no value
                    ext.define_macros.append((value, None))
                else:                   # "-DFOO=blah"
                    ext.define_macros.append((value[0:equals],
                                              value[equals+2:]))
            elif switch == "-U":
                ext.undef_macros.append(value)
            elif switch == "-C":        # only here 'cause makesetup has it!
                ext.extra_compile_args.append(word)
            elif switch == "-l":
                ext.libraries.append(value)
            elif switch == "-L":
                ext.library_dirs.append(value)
            elif switch == "-R":
                ext.runtime_library_dirs.append(value)
            elif word == "-rpath":
                append_next_word = ext.runtime_library_dirs
            elif word == "-Xlinker":
                append_next_word = ext.extra_link_args
            elif word == "-Xcompiler":
                append_next_word = ext.extra_compile_args
            elif switch == "-u":
                ext.extra_link_args.append(word)
                if not value:
                    append_next_word = ext.extra_link_args
            elif suffix in (".a", ".so", ".sl", ".o", ".dylib"):
                # NB. a really faithful emulation of makesetup would
                # append a .o file to extra_objects only if it
                # had a slash in it; otherwise, it would s/.o/.c/
                # and append it to sources.  Hmmmm.
                ext.extra_objects.append(word)
            else:
                file.warn("unrecognized argument '%s'" % word)

        extensions.append(ext)

        #print "module:", module
        #print "source files:", source_files
        #print "cpp args:", cpp_args
        #print "lib args:", library_args

        #extensions[module] = { 'sources': source_files,
        #                       'cpp_args': cpp_args,
        #                       'lib_args': library_args }

    return extensions

</t>
<t tx="ekr.20080401090728.387">"""distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: fancy_getopt.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, string, re
from types import *
import getopt
from distutils.errors import *

# Much like command_re in distutils.core, this is close to but not quite
# the same as a Python NAME -- except, in the spirit of most GNU
# utilities, we use '-' in place of '_'.  (The spirit of LISP lives on!)
# The similarities to NAME are again not a coincidence...
longopt_pat = r'[a-zA-Z](?:[a-zA-Z0-9-]*)'
longopt_re = re.compile(r'^%s$' % longopt_pat)

# For recognizing "negative alias" options, eg. "quiet=!verbose"
neg_alias_re = re.compile("^(%s)=!(%s)$" % (longopt_pat, longopt_pat))

# This is used to translate long options to legitimate Python identifiers
# (for use as attributes of some object).
longopt_xlate = string.maketrans('-', '_')

</t>
<t tx="ekr.20080401090728.388">class FancyGetopt:
    """Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    """
    @others
</t>
<t tx="ekr.20080401090728.389">
def __init__ (self, option_table=None):

    # The option table is (currently) a list of tuples.  The
    # tuples may have 3 or four values:
    #   (long_option, short_option, help_string [, repeatable])
    # if an option takes an argument, its long_option should have '='
    # appended; short_option should just be a single character, no ':'
    # in any case.  If a long_option doesn't have a corresponding
    # short_option, short_option should be None.  All option tuples
    # must have long options.
    self.option_table = option_table

    # 'option_index' maps long option names to entries in the option
    # table (ie. those 3-tuples).
    self.option_index = {}
    if self.option_table:
        self._build_index()

    # 'alias' records (duh) alias options; {'foo': 'bar'} means
    # --foo is an alias for --bar
    self.alias = {}

    # 'negative_alias' keeps track of options that are the boolean
    # opposite of some other option
    self.negative_alias = {}

    # These keep track of the information in the option table.  We
    # don't actually populate these structures until we're ready to
    # parse the command-line, since the 'option_table' passed in here
    # isn't necessarily the final word.
    self.short_opts = []
    self.long_opts = []
    self.short2long = {}
    self.attr_name = {}
    self.takes_arg = {}

    # And 'option_order' is filled up in 'getopt()'; it records the
    # original order of options (and their values) on the command-line,
    # but expands short options, converts aliases, etc.
    self.option_order = []

</t>
<t tx="ekr.20080401090728.390"># __init__ ()


def _build_index (self):
    self.option_index.clear()
    for option in self.option_table:
        self.option_index[option[0]] = option

</t>
<t tx="ekr.20080401090728.391">def set_option_table (self, option_table):
    self.option_table = option_table
    self._build_index()

</t>
<t tx="ekr.20080401090728.392">def add_option (self, long_option, short_option=None, help_string=None):
    if self.option_index.has_key(long_option):
        raise DistutilsGetoptError, \
              "option conflict: already an option '%s'" % long_option
    else:
        option = (long_option, short_option, help_string)
        self.option_table.append(option)
        self.option_index[long_option] = option


</t>
<t tx="ekr.20080401090728.393">def has_option (self, long_option):
    """Return true if the option table for this parser has an
    option with long name 'long_option'."""
    return self.option_index.has_key(long_option)

</t>
<t tx="ekr.20080401090728.394">def get_attr_name (self, long_option):
    """Translate long option name 'long_option' to the form it
    has as an attribute of some object: ie., translate hyphens
    to underscores."""
    return string.translate(long_option, longopt_xlate)


</t>
<t tx="ekr.20080401090728.395">def _check_alias_dict (self, aliases, what):
    assert type(aliases) is DictionaryType
    for (alias, opt) in aliases.items():
        if not self.option_index.has_key(alias):
            raise DistutilsGetoptError, \
                  ("invalid %s '%s': "
                   "option '%s' not defined") % (what, alias, alias)
        if not self.option_index.has_key(opt):
            raise DistutilsGetoptError, \
                  ("invalid %s '%s': "
                   "aliased option '%s' not defined") % (what, alias, opt)

</t>
<t tx="ekr.20080401090728.396">def set_aliases (self, alias):
    """Set the aliases for this option parser."""
    self._check_alias_dict(alias, "alias")
    self.alias = alias

</t>
<t tx="ekr.20080401090728.397">def set_negative_aliases (self, negative_alias):
    """Set the negative aliases for this option parser.
    'negative_alias' should be a dictionary mapping option names to
    option names, both the key and value must already be defined
    in the option table."""
    self._check_alias_dict(negative_alias, "negative alias")
    self.negative_alias = negative_alias


</t>
<t tx="ekr.20080401090728.398">def _grok_option_table (self):
    """Populate the various data structures that keep tabs on the
    option table.  Called by 'getopt()' before it can do anything
    worthwhile.
    """
    self.long_opts = []
    self.short_opts = []
    self.short2long.clear()
    self.repeat = {}

    for option in self.option_table:
        if len(option) == 3:
            long, short, help = option
            repeat = 0
        elif len(option) == 4:
            long, short, help, repeat = option
        else:
            # the option table is part of the code, so simply
            # assert that it is correct
            raise ValueError, "invalid option tuple: %r" % (option,)

        # Type- and value-check the option names
        if type(long) is not StringType or len(long) &lt; 2:
            raise DistutilsGetoptError, \
                  ("invalid long option '%s': "
                   "must be a string of length &gt;= 2") % long

        if (not ((short is None) or
                 (type(short) is StringType and len(short) == 1))):
            raise DistutilsGetoptError, \
                  ("invalid short option '%s': "
                   "must a single character or None") % short

        self.repeat[long] = repeat
        self.long_opts.append(long)

        if long[-1] == '=':             # option takes an argument?
            if short: short = short + ':'
            long = long[0:-1]
            self.takes_arg[long] = 1
        else:

            # Is option is a "negative alias" for some other option (eg.
            # "quiet" == "!verbose")?
            alias_to = self.negative_alias.get(long)
            if alias_to is not None:
                if self.takes_arg[alias_to]:
                    raise DistutilsGetoptError, \
                          ("invalid negative alias '%s': "
                           "aliased option '%s' takes a value") % \
                           (long, alias_to)

                self.long_opts[-1] = long # XXX redundant?!
                self.takes_arg[long] = 0

            else:
                self.takes_arg[long] = 0

        # If this is an alias option, make sure its "takes arg" flag is
        # the same as the option it's aliased to.
        alias_to = self.alias.get(long)
        if alias_to is not None:
            if self.takes_arg[long] != self.takes_arg[alias_to]:
                raise DistutilsGetoptError, \
                      ("invalid alias '%s': inconsistent with "
                       "aliased option '%s' (one of them takes a value, "
                       "the other doesn't") % (long, alias_to)


        # Now enforce some bondage on the long option name, so we can
        # later translate it to an attribute name on some object.  Have
        # to do this a bit late to make sure we've removed any trailing
        # '='.
        if not longopt_re.match(long):
            raise DistutilsGetoptError, \
                  ("invalid long option name '%s' " +
                   "(must be letters, numbers, hyphens only") % long

        self.attr_name[long] = self.get_attr_name(long)
        if short:
            self.short_opts.append(short)
            self.short2long[short[0]] = long

    # for option_table

</t>
<t tx="ekr.20080401090728.399"># _grok_option_table()


def getopt (self, args=None, object=None):
    """Parse command-line options in args. Store as attributes on object.

    If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
    'object' is None or not supplied, creates a new OptionDummy
    object, stores option values there, and returns a tuple (args,
    object).  If 'object' is supplied, it is modified in place and
    'getopt()' just returns 'args'; in both cases, the returned
    'args' is a modified copy of the passed-in 'args' list, which
    is left untouched.
    """
    if args is None:
        args = sys.argv[1:]
    if object is None:
        object = OptionDummy()
        created_object = 1
    else:
        created_object = 0

    self._grok_option_table()

    short_opts = string.join(self.short_opts)
    try:
        opts, args = getopt.getopt(args, short_opts, self.long_opts)
    except getopt.error, msg:
        raise DistutilsArgError, msg

    for opt, val in opts:
        if len(opt) == 2 and opt[0] == '-': # it's a short option
            opt = self.short2long[opt[1]]
        else:
            assert len(opt) &gt; 2 and opt[:2] == '--'
            opt = opt[2:]

        alias = self.alias.get(opt)
        if alias:
            opt = alias

        if not self.takes_arg[opt]:     # boolean option?
            assert val == '', "boolean option can't have value"
            alias = self.negative_alias.get(opt)
            if alias:
                opt = alias
                val = 0
            else:
                val = 1

        attr = self.attr_name[opt]
        # The only repeating option at the moment is 'verbose'.
        # It has a negative option -q quiet, which should set verbose = 0.
        if val and self.repeat.get(attr) is not None:
            val = getattr(object, attr, 0) + 1
        setattr(object, attr, val)
        self.option_order.append((opt, val))

    # for opts
    if created_object:
        return args, object
    else:
        return args

</t>
<t tx="ekr.20080401090728.400"># getopt()


def get_option_order (self):
    """Returns the list of (option, value) tuples processed by the
    previous run of 'getopt()'.  Raises RuntimeError if
    'getopt()' hasn't been called yet.
    """
    if self.option_order is None:
        raise RuntimeError, "'getopt()' hasn't been called yet"
    else:
        return self.option_order


</t>
<t tx="ekr.20080401090728.401">def generate_help (self, header=None):
    """Generate help text (a list of strings, one per suggested line of
    output) from the option table for this FancyGetopt object.
    """
    # Blithely assume the option table is good: probably wouldn't call
    # 'generate_help()' unless you've already called 'getopt()'.

    # First pass: determine maximum length of long option names
    max_opt = 0
    for option in self.option_table:
        long = option[0]
        short = option[1]
        l = len(long)
        if long[-1] == '=':
            l = l - 1
        if short is not None:
            l = l + 5                   # " (-x)" where short == 'x'
        if l &gt; max_opt:
            max_opt = l

    opt_width = max_opt + 2 + 2 + 2     # room for indent + dashes + gutter

    # Typical help block looks like this:
    #   --foo       controls foonabulation
    # Help block for longest option looks like this:
    #   --flimflam  set the flim-flam level
    # and with wrapped text:
    #   --flimflam  set the flim-flam level (must be between
    #               0 and 100, except on Tuesdays)
    # Options with short names will have the short name shown (but
    # it doesn't contribute to max_opt):
    #   --foo (-f)  controls foonabulation
    # If adding the short option would make the left column too wide,
    # we push the explanation off to the next line
    #   --flimflam (-l)
    #               set the flim-flam level
    # Important parameters:
    #   - 2 spaces before option block start lines
    #   - 2 dashes for each long option name
    #   - min. 2 spaces between option and explanation (gutter)
    #   - 5 characters (incl. space) for short option name

    # Now generate lines of help text.  (If 80 columns were good enough
    # for Jesus, then 78 columns are good enough for me!)
    line_width = 78
    text_width = line_width - opt_width
    big_indent = ' ' * opt_width
    if header:
        lines = [header]
    else:
        lines = ['Option summary:']

    for option in self.option_table:
        long, short, help = option[:3]
        text = wrap_text(help, text_width)
        if long[-1] == '=':
            long = long[0:-1]

        # Case 1: no short option at all (makes life easy)
        if short is None:
            if text:
                lines.append("  --%-*s  %s" % (max_opt, long, text[0]))
            else:
                lines.append("  --%-*s  " % (max_opt, long))

        # Case 2: we have a short option, so we have to include it
        # just after the long option
        else:
            opt_names = "%s (-%s)" % (long, short)
            if text:
                lines.append("  --%-*s  %s" %
                             (max_opt, opt_names, text[0]))
            else:
                lines.append("  --%-*s" % opt_names)

        for l in text[1:]:
            lines.append(big_indent + l)

    # for self.option_table

    return lines

</t>
<t tx="ekr.20080401090728.402"># generate_help ()

def print_help (self, header=None, file=None):
    if file is None:
        file = sys.stdout
    for line in self.generate_help(header):
        file.write(line + "\n")

</t>
<t tx="ekr.20080401090728.403"># class FancyGetopt


def fancy_getopt (options, negative_opt, object, args):
    parser = FancyGetopt(options)
    parser.set_negative_aliases(negative_opt)
    return parser.getopt(args, object)


</t>
<t tx="ekr.20080401090728.404">WS_TRANS = string.maketrans(string.whitespace, ' ' * len(string.whitespace))

def wrap_text (text, width):
    """wrap_text(text : string, width : int) -&gt; [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    """

    if text is None:
        return []
    if len(text) &lt;= width:
        return [text]

    text = string.expandtabs(text)
    text = string.translate(text, WS_TRANS)
    chunks = re.split(r'( +|-+)', text)
    chunks = filter(None, chunks)      # ' - ' results in empty strings
    lines = []

    while chunks:

        cur_line = []                   # list of chunks (to-be-joined)
        cur_len = 0                     # length of current line

        while chunks:
            l = len(chunks[0])
            if cur_len + l &lt;= width:    # can squeeze (at least) this chunk in
                cur_line.append(chunks[0])
                del chunks[0]
                cur_len = cur_len + l
            else:                       # this line is full
                # drop last chunk if all space
                if cur_line and cur_line[-1][0] == ' ':
                    del cur_line[-1]
                break

        if chunks:                      # any chunks left to process?

            # if the current line is still empty, then we had a single
            # chunk that's too big too fit on a line -- so we break
            # down and break it up at the line width
            if cur_len == 0:
                cur_line.append(chunks[0][0:width])
                chunks[0] = chunks[0][width:]

            # all-whitespace chunks at the end of a line can be discarded
            # (and we know from the re.split above that if a chunk has
            # *any* whitespace, it is *all* whitespace)
            if chunks[0][0] == ' ':
                del chunks[0]

        # and store this line in the list-of-all-lines -- as a single
        # string, of course!
        lines.append(string.join(cur_line, ''))

    # while chunks

    return lines

</t>
<t tx="ekr.20080401090728.405"># wrap_text ()


def translate_longopt (opt):
    """Convert a long option name to a valid Python identifier by
    changing "-" to "_".
    """
    return string.translate(opt, longopt_xlate)


</t>
<t tx="ekr.20080401090728.406">class OptionDummy:
    """Dummy class just used as a place to hold command-line option
    values as instance attributes."""
    @others
</t>
<t tx="ekr.20080401090728.407">
def __init__ (self, options=[]):
    """Create a new OptionDummy instance.  The attributes listed in
    'options' will be initialized to None."""
    for opt in options:
        setattr(self, opt, None)

</t>
<t tx="ekr.20080401090728.408">"""distutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: filelist.py 37828 2004-11-10 22:23:15Z loewis $"

import os, string, re
import fnmatch
from types import *
from glob import glob
from distutils.util import convert_path
from distutils.errors import DistutilsTemplateError, DistutilsInternalError
from distutils import log

</t>
<t tx="ekr.20080401090728.409">class FileList:

    """A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    """
    @others
    # exclude_pattern ()

</t>
<t tx="ekr.20080401090728.410">
def __init__(self,
             warn=None,
             debug_print=None):
    # ignore argument to FileList, but keep them for backwards
    # compatibility

    self.allfiles = None
    self.files = []

</t>
<t tx="ekr.20080401090728.411">def set_allfiles (self, allfiles):
    self.allfiles = allfiles

</t>
<t tx="ekr.20080401090728.412">def findall (self, dir=os.curdir):
    self.allfiles = findall(dir)

</t>
<t tx="ekr.20080401090728.413">def debug_print (self, msg):
    """Print 'msg' to stdout if the global DEBUG (taken from the
    DISTUTILS_DEBUG environment variable) flag is true.
    """
    from distutils.debug import DEBUG
    if DEBUG:
        print msg

</t>
<t tx="ekr.20080401090728.414"># -- List-like methods ---------------------------------------------

def append (self, item):
    self.files.append(item)

</t>
<t tx="ekr.20080401090728.415">def extend (self, items):
    self.files.extend(items)

</t>
<t tx="ekr.20080401090728.416">def sort (self):
    # Not a strict lexical sort!
    sortable_files = map(os.path.split, self.files)
    sortable_files.sort()
    self.files = []
    for sort_tuple in sortable_files:
        self.files.append(apply(os.path.join, sort_tuple))


</t>
<t tx="ekr.20080401090728.417"># -- Other miscellaneous utility methods ---------------------------

def remove_duplicates (self):
    # Assumes list has been sorted!
    for i in range(len(self.files) - 1, 0, -1):
        if self.files[i] == self.files[i - 1]:
            del self.files[i]


</t>
<t tx="ekr.20080401090728.418"># -- "File template" methods ---------------------------------------

def _parse_template_line (self, line):
    words = string.split(line)
    action = words[0]

    patterns = dir = dir_pattern = None

    if action in ('include', 'exclude',
                  'global-include', 'global-exclude'):
        if len(words) &lt; 2:
            raise DistutilsTemplateError, \
                  "'%s' expects &lt;pattern1&gt; &lt;pattern2&gt; ..." % action

        patterns = map(convert_path, words[1:])

    elif action in ('recursive-include', 'recursive-exclude'):
        if len(words) &lt; 3:
            raise DistutilsTemplateError, \
                  "'%s' expects &lt;dir&gt; &lt;pattern1&gt; &lt;pattern2&gt; ..." % action

        dir = convert_path(words[1])
        patterns = map(convert_path, words[2:])

    elif action in ('graft', 'prune'):
        if len(words) != 2:
            raise DistutilsTemplateError, \
                 "'%s' expects a single &lt;dir_pattern&gt;" % action

        dir_pattern = convert_path(words[1])

    else:
        raise DistutilsTemplateError, "unknown action '%s'" % action

    return (action, patterns, dir, dir_pattern)

</t>
<t tx="ekr.20080401090728.419"># _parse_template_line ()


def process_template_line (self, line):

    # Parse the line: split it up, make sure the right number of words
    # is there, and return the relevant words.  'action' is always
    # defined: it's the first word of the line.  Which of the other
    # three are defined depends on the action; it'll be either
    # patterns, (dir and patterns), or (dir_pattern).
    (action, patterns, dir, dir_pattern) = self._parse_template_line(line)

    # OK, now we know that the action is valid and we have the
    # right number of words on the line for that action -- so we
    # can proceed with minimal error-checking.
    if action == 'include':
        self.debug_print("include " + string.join(patterns))
        for pattern in patterns:
            if not self.include_pattern(pattern, anchor=1):
                log.warn("warning: no files found matching '%s'",
                         pattern)

    elif action == 'exclude':
        self.debug_print("exclude " + string.join(patterns))
        for pattern in patterns:
            if not self.exclude_pattern(pattern, anchor=1):
                log.warn(("warning: no previously-included files "
                          "found matching '%s'"), pattern)

    elif action == 'global-include':
        self.debug_print("global-include " + string.join(patterns))
        for pattern in patterns:
            if not self.include_pattern(pattern, anchor=0):
                log.warn(("warning: no files found matching '%s' " +
                          "anywhere in distribution"), pattern)

    elif action == 'global-exclude':
        self.debug_print("global-exclude " + string.join(patterns))
        for pattern in patterns:
            if not self.exclude_pattern(pattern, anchor=0):
                log.warn(("warning: no previously-included files matching "
                          "'%s' found anywhere in distribution"),
                         pattern)

    elif action == 'recursive-include':
        self.debug_print("recursive-include %s %s" %
                         (dir, string.join(patterns)))
        for pattern in patterns:
            if not self.include_pattern(pattern, prefix=dir):
                log.warn(("warning: no files found matching '%s' " +
                            "under directory '%s'"),
                         pattern, dir)

    elif action == 'recursive-exclude':
        self.debug_print("recursive-exclude %s %s" %
                         (dir, string.join(patterns)))
        for pattern in patterns:
            if not self.exclude_pattern(pattern, prefix=dir):
                log.warn(("warning: no previously-included files matching "
                          "'%s' found under directory '%s'"),
                         pattern, dir)

    elif action == 'graft':
        self.debug_print("graft " + dir_pattern)
        if not self.include_pattern(None, prefix=dir_pattern):
            log.warn("warning: no directories found matching '%s'",
                     dir_pattern)

    elif action == 'prune':
        self.debug_print("prune " + dir_pattern)
        if not self.exclude_pattern(None, prefix=dir_pattern):
            log.warn(("no previously-included directories found " +
                      "matching '%s'"), dir_pattern)
    else:
        raise DistutilsInternalError, \
              "this cannot happen: invalid action '%s'" % action

</t>
<t tx="ekr.20080401090728.420"># process_template_line ()


# -- Filtering/selection methods -----------------------------------

def include_pattern (self, pattern,
                     anchor=1, prefix=None, is_regex=0):
    """Select strings (presumably filenames) from 'self.files' that
    match 'pattern', a Unix-style wildcard (glob) pattern.  Patterns
    are not quite the same as implemented by the 'fnmatch' module: '*'
    and '?'  match non-special characters, where "special" is platform-
    dependent: slash on Unix; colon, slash, and backslash on
    DOS/Windows; and colon on Mac OS.

    If 'anchor' is true (the default), then the pattern match is more
    stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
    'anchor' is false, both of these will match.

    If 'prefix' is supplied, then only filenames starting with 'prefix'
    (itself a pattern) and ending with 'pattern', with anything in between
    them, will match.  'anchor' is ignored in this case.

    If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
    'pattern' is assumed to be either a string containing a regex or a
    regex object -- no translation is done, the regex is just compiled
    and used as-is.

    Selected strings will be added to self.files.

    Return 1 if files are found.
    """
    files_found = 0
    pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
    self.debug_print("include_pattern: applying regex r'%s'" %
                     pattern_re.pattern)

    # delayed loading of allfiles list
    if self.allfiles is None:
        self.findall()

    for name in self.allfiles:
        if pattern_re.search(name):
            self.debug_print(" adding " + name)
            self.files.append(name)
            files_found = 1

    return files_found

</t>
<t tx="ekr.20080401090728.421"># include_pattern ()


def exclude_pattern (self, pattern,
                     anchor=1, prefix=None, is_regex=0):
    """Remove strings (presumably filenames) from 'files' that match
    'pattern'.  Other parameters are the same as for
    'include_pattern()', above.
    The list 'self.files' is modified in place.
    Return 1 if files are found.
    """
    files_found = 0
    pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)
    self.debug_print("exclude_pattern: applying regex r'%s'" %
                     pattern_re.pattern)
    for i in range(len(self.files)-1, -1, -1):
        if pattern_re.search(self.files[i]):
            self.debug_print(" removing " + self.files[i])
            del self.files[i]
            files_found = 1

    return files_found

</t>
<t tx="ekr.20080401090728.422"># class FileList


# ----------------------------------------------------------------------
# Utility functions

def findall (dir = os.curdir):
    """Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    """
    from stat import ST_MODE, S_ISREG, S_ISDIR, S_ISLNK

    list = []
    stack = [dir]
    pop = stack.pop
    push = stack.append

    while stack:
        dir = pop()
        names = os.listdir(dir)

        for name in names:
            if dir != os.curdir:        # avoid the dreaded "./" syndrome
                fullname = os.path.join(dir, name)
            else:
                fullname = name

            # Avoid excess stat calls -- just one will do, thank you!
            stat = os.stat(fullname)
            mode = stat[ST_MODE]
            if S_ISREG(mode):
                list.append(fullname)
            elif S_ISDIR(mode) and not S_ISLNK(mode):
                push(fullname)

    return list


</t>
<t tx="ekr.20080401090728.423">def glob_to_re (pattern):
    """Translate a shell-like glob pattern to a regular expression; return
    a string containing the regex.  Differs from 'fnmatch.translate()' in
    that '*' does not match "special characters" (which are
    platform-specific).
    """
    pattern_re = fnmatch.translate(pattern)

    # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
    # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
    # and by extension they shouldn't match such "special characters" under
    # any OS.  So change all non-escaped dots in the RE to match any
    # character except the special characters.
    # XXX currently the "special characters" are just slash -- i.e. this is
    # Unix-only.
    pattern_re = re.sub(r'(^|[^\\])\.', r'\1[^/]', pattern_re)
    return pattern_re

</t>
<t tx="ekr.20080401090728.424"># glob_to_re ()


def translate_pattern (pattern, anchor=1, prefix=None, is_regex=0):
    """Translate a shell-like wildcard pattern to a compiled regular
    expression.  Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    """
    if is_regex:
        if type(pattern) is StringType:
            return re.compile(pattern)
        else:
            return pattern

    if pattern:
        pattern_re = glob_to_re(pattern)
    else:
        pattern_re = ''

    if prefix is not None:
        prefix_re = (glob_to_re(prefix))[0:-1] # ditch trailing $
        pattern_re = "^" + os.path.join(prefix_re, ".*" + pattern_re)
    else:                               # no prefix -- respect anchor flag
        if anchor:
            pattern_re = "^" + pattern_re

    return re.compile(pattern_re)

</t>
<t tx="ekr.20080401090728.425">"""distutils.file_util

Utility functions for operating on single files.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: file_util.py 37828 2004-11-10 22:23:15Z loewis $"

import os
from distutils.errors import DistutilsFileError
from distutils import log

# for generating verbose output in 'copy_file()'
_copy_action = { None:   'copying',
                 'hard': 'hard linking',
                 'sym':  'symbolically linking' }


</t>
<t tx="ekr.20080401090728.426">def _copy_file_contents (src, dst, buffer_size=16*1024):
    """Copy the file 'src' to 'dst'; both must be filenames.  Any error
    opening either file, reading from 'src', or writing to 'dst', raises
    DistutilsFileError.  Data is read/written in chunks of 'buffer_size'
    bytes (default 16k).  No attempt is made to handle anything apart from
    regular files.
    """
    # Stolen from shutil module in the standard library, but with
    # custom error-handling added.

    fsrc = None
    fdst = None
    try:
        try:
            fsrc = open(src, 'rb')
        except os.error, (errno, errstr):
            raise DistutilsFileError, \
                  "could not open '%s': %s" % (src, errstr)

        if os.path.exists(dst):
            try:
                os.unlink(dst)
            except os.error, (errno, errstr):
                raise DistutilsFileError, \
                      "could not delete '%s': %s" % (dst, errstr)

        try:
            fdst = open(dst, 'wb')
        except os.error, (errno, errstr):
            raise DistutilsFileError, \
                  "could not create '%s': %s" % (dst, errstr)

        while 1:
            try:
                buf = fsrc.read(buffer_size)
            except os.error, (errno, errstr):
                raise DistutilsFileError, \
                      "could not read from '%s': %s" % (src, errstr)

            if not buf:
                break

            try:
                fdst.write(buf)
            except os.error, (errno, errstr):
                raise DistutilsFileError, \
                      "could not write to '%s': %s" % (dst, errstr)

    finally:
        if fdst:
            fdst.close()
        if fsrc:
            fsrc.close()

</t>
<t tx="ekr.20080401090728.427"># _copy_file_contents()

def copy_file (src, dst,
               preserve_mode=1,
               preserve_times=1,
               update=0,
               link=None,
               verbose=0,
               dry_run=0):

    """Copy a file 'src' to 'dst'.  If 'dst' is a directory, then 'src' is
    copied there with the same name; otherwise, it must be a filename.  (If
    the file exists, it will be ruthlessly clobbered.)  If 'preserve_mode'
    is true (the default), the file's mode (type and permission bits, or
    whatever is analogous on the current platform) is copied.  If
    'preserve_times' is true (the default), the last-modified and
    last-access times are copied as well.  If 'update' is true, 'src' will
    only be copied if 'dst' does not exist, or if 'dst' does exist but is
    older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available.

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    """
    # XXX if the destination file already exists, we clobber it if
    # copying, but blow up if linking.  Hmmm.  And I don't know what
    # macostools.copyfile() does.  Should definitely be consistent, and
    # should probably blow up if destination exists and we would be
    # changing it (ie. it's not already a hard/soft link to src OR
    # (not update) and (src newer than dst).

    from distutils.dep_util import newer
    from stat import ST_ATIME, ST_MTIME, ST_MODE, S_IMODE

    if not os.path.isfile(src):
        raise DistutilsFileError, \
              "can't copy '%s': doesn't exist or not a regular file" % src

    if os.path.isdir(dst):
        dir = dst
        dst = os.path.join(dst, os.path.basename(src))
    else:
        dir = os.path.dirname(dst)

    if update and not newer(src, dst):
        log.debug("not copying %s (output up-to-date)", src)
        return dst, 0

    try:
        action = _copy_action[link]
    except KeyError:
        raise ValueError, \
              "invalid value '%s' for 'link' argument" % link
    if os.path.basename(dst) == os.path.basename(src):
        log.info("%s %s -&gt; %s", action, src, dir)
    else:
        log.info("%s %s -&gt; %s", action, src, dst)

    if dry_run:
        return (dst, 1)

    # On Mac OS, use the native file copy routine
    if os.name == 'mac':
        import macostools
        try:
            macostools.copy(src, dst, 0, preserve_times)
        except os.error, exc:
            raise DistutilsFileError, \
                  "could not copy '%s' to '%s': %s" % (src, dst, exc[-1])

    # If linking (hard or symbolic), use the appropriate system call
    # (Unix only, of course, but that's the caller's responsibility)
    elif link == 'hard':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            os.link(src, dst)
    elif link == 'sym':
        if not (os.path.exists(dst) and os.path.samefile(src, dst)):
            os.symlink(src, dst)

    # Otherwise (non-Mac, not linking), copy the file contents and
    # (optionally) copy the times and mode.
    else:
        _copy_file_contents(src, dst)
        if preserve_mode or preserve_times:
            st = os.stat(src)

            # According to David Ascher &lt;da@ski.org&gt;, utime() should be done
            # before chmod() (at least under NT).
            if preserve_times:
                os.utime(dst, (st[ST_ATIME], st[ST_MTIME]))
            if preserve_mode:
                os.chmod(dst, S_IMODE(st[ST_MODE]))

    return (dst, 1)

</t>
<t tx="ekr.20080401090728.428"># copy_file ()


# XXX I suspect this is Unix-specific -- need porting help!
def move_file (src, dst,
               verbose=0,
               dry_run=0):

    """Move a file 'src' to 'dst'.  If 'dst' is a directory, the file will
    be moved into it with the same name; otherwise, 'src' is just renamed
    to 'dst'.  Return the new full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    """
    from os.path import exists, isfile, isdir, basename, dirname
    import errno

    log.info("moving %s -&gt; %s", src, dst)

    if dry_run:
        return dst

    if not isfile(src):
        raise DistutilsFileError, \
              "can't move '%s': not a regular file" % src

    if isdir(dst):
        dst = os.path.join(dst, basename(src))
    elif exists(dst):
        raise DistutilsFileError, \
              "can't move '%s': destination '%s' already exists" % \
              (src, dst)

    if not isdir(dirname(dst)):
        raise DistutilsFileError, \
              "can't move '%s': destination '%s' not a valid path" % \
              (src, dst)

    copy_it = 0
    try:
        os.rename(src, dst)
    except os.error, (num, msg):
        if num == errno.EXDEV:
            copy_it = 1
        else:
            raise DistutilsFileError, \
                  "couldn't move '%s' to '%s': %s" % (src, dst, msg)

    if copy_it:
        copy_file(src, dst)
        try:
            os.unlink(src)
        except os.error, (num, msg):
            try:
                os.unlink(dst)
            except os.error:
                pass
            raise DistutilsFileError, \
                  ("couldn't move '%s' to '%s' by copy/delete: " +
                   "delete '%s' failed: %s") % \
                  (src, dst, src, msg)

    return dst

</t>
<t tx="ekr.20080401090728.429"># move_file ()


def write_file (filename, contents):
    """Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    """
    f = open(filename, "w")
    for line in contents:
        f.write(line + "\n")
    f.close()
</t>
<t tx="ekr.20080401090728.430">"""A simple log mechanism styled after PEP 282."""

# This module should be kept compatible with Python 2.1.

# The class here is styled after PEP 282 so that it could later be
# replaced with a standard Python logging implementation.

DEBUG = 1
INFO = 2
WARN = 3
ERROR = 4
FATAL = 5

import sys

</t>
<t tx="ekr.20080401090728.431">class Log:
    @others
</t>
<t tx="ekr.20080401090728.432">
def __init__(self, threshold=WARN):
    self.threshold = threshold

</t>
<t tx="ekr.20080401090728.433">def _log(self, level, msg, args):
    if level &gt;= self.threshold:
        if not args:
            # msg may contain a '%'. If args is empty,
            # don't even try to string-format
            print msg
        else:
            print msg % args
        sys.stdout.flush()

</t>
<t tx="ekr.20080401090728.434">def log(self, level, msg, *args):
    self._log(level, msg, args)

</t>
<t tx="ekr.20080401090728.435">def debug(self, msg, *args):
    self._log(DEBUG, msg, args)

</t>
<t tx="ekr.20080401090728.436">def info(self, msg, *args):
    self._log(INFO, msg, args)

</t>
<t tx="ekr.20080401090728.437">def warn(self, msg, *args):
    self._log(WARN, msg, args)

</t>
<t tx="ekr.20080401090728.438">def error(self, msg, *args):
    self._log(ERROR, msg, args)

</t>
<t tx="ekr.20080401090728.439">def fatal(self, msg, *args):
    self._log(FATAL, msg, args)

</t>
<t tx="ekr.20080401090728.440">_global_log = Log()
log = _global_log.log
debug = _global_log.debug
info = _global_log.info
warn = _global_log.warn
error = _global_log.error
fatal = _global_log.fatal

def set_threshold(level):
    # return the old threshold for use from tests
    old = _global_log.threshold
    _global_log.threshold = level
    return old

</t>
<t tx="ekr.20080401090728.441">def set_verbosity(v):
    if v &lt;= 0:
        set_threshold(WARN)
    elif v == 1:
        set_threshold(INFO)
    elif v &gt;= 2:
        set_threshold(DEBUG)
</t>
<t tx="ekr.20080401090728.442">"""distutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: spawn.py 37828 2004-11-10 22:23:15Z loewis $"

import sys, os, string
from distutils.errors import *
from distutils import log

</t>
<t tx="ekr.20080401090728.443">def spawn (cmd,
           search_path=1,
           verbose=0,
           dry_run=0):

    """Run another program, specified as a command list 'cmd', in a new
    process.  'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    """
    if os.name == 'posix':
        _spawn_posix(cmd, search_path, dry_run=dry_run)
    elif os.name == 'nt':
        _spawn_nt(cmd, search_path, dry_run=dry_run)
    elif os.name == 'os2':
        _spawn_os2(cmd, search_path, dry_run=dry_run)
    else:
        raise DistutilsPlatformError, \
              "don't know how to spawn programs on platform '%s'" % os.name

</t>
<t tx="ekr.20080401090728.444"># spawn ()


def _nt_quote_args (args):
    """Quote command-line arguments for DOS/Windows conventions: just
    wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    """

    # XXX this doesn't seem very robust to me -- but if the Windows guys
    # say it'll work, I guess I'll have to accept it.  (What if an arg
    # contains quotes?  What other magic characters, other than spaces,
    # have to be escaped?  Is there an escaping mechanism other than
    # quoting?)

    for i in range(len(args)):
        if string.find(args[i], ' ') != -1:
            args[i] = '"%s"' % args[i]
    return args

</t>
<t tx="ekr.20080401090728.445">def _spawn_nt (cmd,
               search_path=1,
               verbose=0,
               dry_run=0):

    executable = cmd[0]
    cmd = _nt_quote_args(cmd)
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(string.join([executable] + cmd[1:], ' '))
    if not dry_run:
        # spawn for NT requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            raise DistutilsExecError, \
                  "command '%s' failed: %s" % (cmd[0], exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            raise DistutilsExecError, \
                  "command '%s' failed with exit status %d" % (cmd[0], rc)


</t>
<t tx="ekr.20080401090728.446">def _spawn_os2 (cmd,
                search_path=1,
                verbose=0,
                dry_run=0):

    executable = cmd[0]
    #cmd = _nt_quote_args(cmd)
    if search_path:
        # either we find one or it stays the same
        executable = find_executable(executable) or executable
    log.info(string.join([executable] + cmd[1:], ' '))
    if not dry_run:
        # spawnv for OS/2 EMX requires a full path to the .exe
        try:
            rc = os.spawnv(os.P_WAIT, executable, cmd)
        except OSError, exc:
            # this seems to happen when the command isn't found
            raise DistutilsExecError, \
                  "command '%s' failed: %s" % (cmd[0], exc[-1])
        if rc != 0:
            # and this reflects the command running but failing
            print "command '%s' failed with exit status %d" % (cmd[0], rc)
            raise DistutilsExecError, \
                  "command '%s' failed with exit status %d" % (cmd[0], rc)


</t>
<t tx="ekr.20080401090728.447">def _spawn_posix (cmd,
                  search_path=1,
                  verbose=0,
                  dry_run=0):

    log.info(string.join(cmd, ' '))
    if dry_run:
        return
    exec_fn = search_path and os.execvp or os.execv

    pid = os.fork()

    if pid == 0:                        # in the child
        try:
            #print "cmd[0] =", cmd[0]
            #print "cmd =", cmd
            exec_fn(cmd[0], cmd)
        except OSError, e:
            sys.stderr.write("unable to execute %s: %s\n" %
                             (cmd[0], e.strerror))
            os._exit(1)

        sys.stderr.write("unable to execute %s for unknown reasons" % cmd[0])
        os._exit(1)


    else:                               # in the parent
        # Loop until the child either exits or is terminated by a signal
        # (ie. keep waiting if it's merely stopped)
        while 1:
            try:
                (pid, status) = os.waitpid(pid, 0)
            except OSError, exc:
                import errno
                if exc.errno == errno.EINTR:
                    continue
                raise DistutilsExecError, \
                      "command '%s' failed: %s" % (cmd[0], exc[-1])
            if os.WIFSIGNALED(status):
                raise DistutilsExecError, \
                      "command '%s' terminated by signal %d" % \
                      (cmd[0], os.WTERMSIG(status))

            elif os.WIFEXITED(status):
                exit_status = os.WEXITSTATUS(status)
                if exit_status == 0:
                    return              # hey, it succeeded!
                else:
                    raise DistutilsExecError, \
                          "command '%s' failed with exit status %d" % \
                          (cmd[0], exit_status)

            elif os.WIFSTOPPED(status):
                continue

            else:
                raise DistutilsExecError, \
                      "unknown error executing '%s': termination status %d" % \
                      (cmd[0], status)
</t>
<t tx="ekr.20080401090728.448"># _spawn_posix ()


def find_executable(executable, path=None):
    """Try to find 'executable' in the directories listed in 'path' (a
    string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH']).  Returns the complete filename or None if not
    found.
    """
    if path is None:
        path = os.environ['PATH']
    paths = string.split(path, os.pathsep)
    (base, ext) = os.path.splitext(executable)
    if (sys.platform == 'win32' or os.name == 'os2') and (ext != '.exe'):
        executable = executable + '.exe'
    if not os.path.isfile(executable):
        for p in paths:
            f = os.path.join(p, executable)
            if os.path.isfile(f):
                # the file exists, we have a shot at spawn working
                return f
        return None
    else:
        return executable

</t>
<t tx="ekr.20080401090728.449">"""Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        &lt;fdrake@acm.org&gt;
"""

__revision__ = "$Id: sysconfig.py 47123 2006-06-27 10:08:25Z ronald.oussoren $"

import os
import re
import string
import sys

from distutils.errors import DistutilsPlatformError

# These are needed in a couple of spots, so just compute them once.
PREFIX = os.path.normpath(sys.prefix)
EXEC_PREFIX = os.path.normpath(sys.exec_prefix)

# python_build: (Boolean) if true, we're either building Python or
# building an extension with an un-installed Python, so we use
# different (hard-wired) directories.

argv0_path = os.path.dirname(os.path.abspath(sys.executable))
landmark = os.path.join(argv0_path, "Modules", "Setup")

python_build = os.path.isfile(landmark)

del landmark


</t>
<t tx="ekr.20080401090728.450">def get_python_version():
    """Return a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    """
    return sys.version[:3]


</t>
<t tx="ekr.20080401090728.451">def get_python_inc(plat_specific=0, prefix=None):
    """Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """
    if prefix is None:
        prefix = plat_specific and EXEC_PREFIX or PREFIX
    if os.name == "posix":
        if python_build:
            base = os.path.dirname(os.path.abspath(sys.executable))
            if plat_specific:
                inc_dir = base
            else:
                inc_dir = os.path.join(base, "Include")
                if not os.path.exists(inc_dir):
                    inc_dir = os.path.join(os.path.dirname(base), "Include")
            return inc_dir
        return os.path.join(prefix, "include", "python" + get_python_version())
    elif os.name == "nt":
        return os.path.join(prefix, "include")
    elif os.name == "mac":
        if plat_specific:
            return os.path.join(prefix, "Mac", "Include")
        else:
            return os.path.join(prefix, "Include")
    elif os.name == "os2":
        return os.path.join(prefix, "Include")
    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its C header files "
            "on platform '%s'" % os.name)


</t>
<t tx="ekr.20080401090728.452">def get_python_lib(plat_specific=0, standard_lib=0, prefix=None):
    """Return the directory containing the Python library (standard or
    site additions).

    If 'plat_specific' is true, return the directory containing
    platform-specific modules, i.e. any module from a non-pure-Python
    module distribution; otherwise, return the platform-shared library
    directory.  If 'standard_lib' is true, return the directory
    containing standard Python library modules; otherwise, return the
    directory for site-specific modules.

    If 'prefix' is supplied, use it instead of sys.prefix or
    sys.exec_prefix -- i.e., ignore 'plat_specific'.
    """
    if prefix is None:
        prefix = plat_specific and EXEC_PREFIX or PREFIX

    if os.name == "posix":
        libpython = os.path.join(prefix,
                                 "lib", "python" + get_python_version())
        if standard_lib:
            return libpython
        else:
            return os.path.join(libpython, "site-packages")

    elif os.name == "nt":
        if standard_lib:
            return os.path.join(prefix, "Lib")
        else:
            if get_python_version() &lt; "2.2":
                return prefix
            else:
                return os.path.join(PREFIX, "Lib", "site-packages")

    elif os.name == "mac":
        if plat_specific:
            if standard_lib:
                return os.path.join(prefix, "Lib", "lib-dynload")
            else:
                return os.path.join(prefix, "Lib", "site-packages")
        else:
            if standard_lib:
                return os.path.join(prefix, "Lib")
            else:
                return os.path.join(prefix, "Lib", "site-packages")

    elif os.name == "os2":
        if standard_lib:
            return os.path.join(PREFIX, "Lib")
        else:
            return os.path.join(PREFIX, "Lib", "site-packages")

    else:
        raise DistutilsPlatformError(
            "I don't know where Python installs its library "
            "on platform '%s'" % os.name)


</t>
<t tx="ekr.20080401090728.453">def customize_compiler(compiler):
    """Do any platform-specific customization of a CCompiler instance.

    Mainly needed on Unix, so we can plug in the information that
    varies across Unices and is stored in Python's Makefile.
    """
    if compiler.compiler_type == "unix":
        (cc, cxx, opt, cflags, ccshared, ldshared, so_ext) = \
            get_config_vars('CC', 'CXX', 'OPT', 'CFLAGS',
                            'CCSHARED', 'LDSHARED', 'SO')

        if os.environ.has_key('CC'):
            cc = os.environ['CC']
        if os.environ.has_key('CXX'):
            cxx = os.environ['CXX']
        if os.environ.has_key('LDSHARED'):
            ldshared = os.environ['LDSHARED']
        if os.environ.has_key('CPP'):
            cpp = os.environ['CPP']
        else:
            cpp = cc + " -E"           # not always
        if os.environ.has_key('LDFLAGS'):
            ldshared = ldshared + ' ' + os.environ['LDFLAGS']
        if os.environ.has_key('CFLAGS'):
            cflags = opt + ' ' + os.environ['CFLAGS']
            ldshared = ldshared + ' ' + os.environ['CFLAGS']
        if os.environ.has_key('CPPFLAGS'):
            cpp = cpp + ' ' + os.environ['CPPFLAGS']
            cflags = cflags + ' ' + os.environ['CPPFLAGS']
            ldshared = ldshared + ' ' + os.environ['CPPFLAGS']

        cc_cmd = cc + ' ' + cflags
        compiler.set_executables(
            preprocessor=cpp,
            compiler=cc_cmd,
            compiler_so=cc_cmd + ' ' + ccshared,
            compiler_cxx=cxx,
            linker_so=ldshared,
            linker_exe=cc)

        compiler.shared_lib_extension = so_ext


</t>
<t tx="ekr.20080401090728.454">def get_config_h_filename():
    """Return full pathname of installed pyconfig.h file."""
    if python_build:
        inc_dir = argv0_path
    else:
        inc_dir = get_python_inc(plat_specific=1)
    if get_python_version() &lt; '2.2':
        config_h = 'config.h'
    else:
        # The name of the config.h file changed in 2.2
        config_h = 'pyconfig.h'
    return os.path.join(inc_dir, config_h)


</t>
<t tx="ekr.20080401090728.455">def get_makefile_filename():
    """Return full pathname of installed Makefile from the Python build."""
    if python_build:
        return os.path.join(os.path.dirname(sys.executable), "Makefile")
    lib_dir = get_python_lib(plat_specific=1, standard_lib=1)
    return os.path.join(lib_dir, "config", "Makefile")


</t>
<t tx="ekr.20080401090728.456">def parse_config_h(fp, g=None):
    """Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    if g is None:
        g = {}
    define_rx = re.compile("#define ([A-Z][A-Za-z0-9_]+) (.*)\n")
    undef_rx = re.compile("/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/\n")
    #
    while 1:
        line = fp.readline()
        if not line:
            break
        m = define_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            try: v = int(v)
            except ValueError: pass
            g[n] = v
        else:
            m = undef_rx.match(line)
            if m:
                g[m.group(1)] = 0
    return g


</t>
<t tx="ekr.20080401090728.457"># Regexes needed for parsing Makefile (and similar syntaxes,
# like old-style Setup files).
_variable_rx = re.compile("([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)")
_findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9_]*)\)")
_findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9_]*)}")

def parse_makefile(fn, g=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    from distutils.text_file import TextFile
    fp = TextFile(fn, strip_comments=1, skip_blanks=1, join_lines=1)

    if g is None:
        g = {}
    done = {}
    notdone = {}

    while 1:
        line = fp.readline()
        if line is None:                # eof
            break
        m = _variable_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            v = string.strip(v)
            if "$" in v:
                notdone[n] = v
            else:
                try: v = int(v)
                except ValueError: pass
                done[n] = v

    # do variable interpolation here
    while notdone:
        for name in notdone.keys():
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m:
                n = m.group(1)
                found = True
                if done.has_key(n):
                    item = str(done[n])
                elif notdone.has_key(n):
                    # get it on a subsequent round
                    found = False
                elif os.environ.has_key(n):
                    # do it like make: fall back to environment
                    item = os.environ[n]
                else:
                    done[n] = item = ""
                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        try: value = int(value)
                        except ValueError:
                            done[name] = string.strip(value)
                        else:
                            done[name] = value
                        del notdone[name]
            else:
                # bogus variable reference; just drop it since we can't deal
                del notdone[name]

    fp.close()

    # save the results in the global dictionary
    g.update(done)
    return g


</t>
<t tx="ekr.20080401090728.458">def expand_makefile_vars(s, vars):
    """Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
    'string' according to 'vars' (a dictionary mapping variable names to
    values).  Variables not present in 'vars' are silently expanded to the
    empty string.  The variable values in 'vars' should not contain further
    variable expansions; if 'vars' is the output of 'parse_makefile()',
    you're fine.  Returns a variable-expanded version of 's'.
    """

    # This algorithm does multiple expansion, so if vars['foo'] contains
    # "${bar}", it will expand ${foo} to ${bar}, and then expand
    # ${bar}... and so forth.  This is fine as long as 'vars' comes from
    # 'parse_makefile()', which takes care of such expansions eagerly,
    # according to make's variable expansion semantics.

    while 1:
        m = _findvar1_rx.search(s) or _findvar2_rx.search(s)
        if m:
            (beg, end) = m.span()
            s = s[0:beg] + vars.get(m.group(1)) + s[end:]
        else:
            break
    return s


</t>
<t tx="ekr.20080401090728.459">_config_vars = None

def _init_posix():
    """Initialize the module as appropriate for POSIX systems."""
    g = {}
    # load the installed Makefile:
    try:
        filename = get_makefile_filename()
        parse_makefile(filename, g)
    except IOError, msg:
        my_msg = "invalid Python installation: unable to open %s" % filename
        if hasattr(msg, "strerror"):
            my_msg = my_msg + " (%s)" % msg.strerror

        raise DistutilsPlatformError(my_msg)

    # load the installed pyconfig.h:
    try:
        filename = get_config_h_filename()
        parse_config_h(file(filename), g)
    except IOError, msg:
        my_msg = "invalid Python installation: unable to open %s" % filename
        if hasattr(msg, "strerror"):
            my_msg = my_msg + " (%s)" % msg.strerror

        raise DistutilsPlatformError(my_msg)

    # On MacOSX we need to check the setting of the environment variable
    # MACOSX_DEPLOYMENT_TARGET: configure bases some choices on it so
    # it needs to be compatible.
    # If it isn't set we set it to the configure-time value
    if sys.platform == 'darwin' and g.has_key('MACOSX_DEPLOYMENT_TARGET'):
        cfg_target = g['MACOSX_DEPLOYMENT_TARGET']
        cur_target = os.getenv('MACOSX_DEPLOYMENT_TARGET', '')
        if cur_target == '':
            cur_target = cfg_target
            os.putenv('MACOSX_DEPLOYMENT_TARGET', cfg_target)
        elif map(int, cfg_target.split('.')) &gt; map(int, cur_target.split('.')):
            my_msg = ('$MACOSX_DEPLOYMENT_TARGET mismatch: now "%s" but "%s" during configure'
                % (cur_target, cfg_target))
            raise DistutilsPlatformError(my_msg)

    # On AIX, there are wrong paths to the linker scripts in the Makefile
    # -- these paths are relative to the Python source, but when installed
    # the scripts are in another directory.
    if python_build:
        g['LDSHARED'] = g['BLDSHARED']

    elif get_python_version() &lt; '2.1':
        # The following two branches are for 1.5.2 compatibility.
        if sys.platform == 'aix4':          # what about AIX 3.x ?
            # Linker script is in the config directory, not in Modules as the
            # Makefile says.
            python_lib = get_python_lib(standard_lib=1)
            ld_so_aix = os.path.join(python_lib, 'config', 'ld_so_aix')
            python_exp = os.path.join(python_lib, 'config', 'python.exp')

            g['LDSHARED'] = "%s %s -bI:%s" % (ld_so_aix, g['CC'], python_exp)

        elif sys.platform == 'beos':
            # Linker script is in the config directory.  In the Makefile it is
            # relative to the srcdir, which after installation no longer makes
            # sense.
            python_lib = get_python_lib(standard_lib=1)
            linkerscript_path = string.split(g['LDSHARED'])[0]
            linkerscript_name = os.path.basename(linkerscript_path)
            linkerscript = os.path.join(python_lib, 'config',
                                        linkerscript_name)

            # XXX this isn't the right place to do this: adding the Python
            # library to the link, if needed, should be in the "build_ext"
            # command.  (It's also needed for non-MS compilers on Windows, and
            # it's taken care of for them by the 'build_ext.get_libraries()'
            # method.)
            g['LDSHARED'] = ("%s -L%s/lib -lpython%s" %
                             (linkerscript, PREFIX, get_python_version()))

    global _config_vars
    _config_vars = g


</t>
<t tx="ekr.20080401090728.460">def _init_nt():
    """Initialize the module as appropriate for NT"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"

    global _config_vars
    _config_vars = g


</t>
<t tx="ekr.20080401090728.461">def _init_mac():
    """Initialize the module as appropriate for Macintosh systems"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    import MacOS
    if not hasattr(MacOS, 'runtimemodel'):
        g['SO'] = '.ppc.slb'
    else:
        g['SO'] = '.%s.slb' % MacOS.runtimemodel

    # XXX are these used anywhere?
    g['install_lib'] = os.path.join(EXEC_PREFIX, "Lib")
    g['install_platlib'] = os.path.join(EXEC_PREFIX, "Mac", "Lib")

    # These are used by the extension module build
    g['srcdir'] = ':'
    global _config_vars
    _config_vars = g


</t>
<t tx="ekr.20080401090728.462">def _init_os2():
    """Initialize the module as appropriate for OS/2"""
    g = {}
    # set basic install directories
    g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
    g['BINLIBDEST'] = get_python_lib(plat_specific=1, standard_lib=1)

    # XXX hmmm.. a normal install puts include files here
    g['INCLUDEPY'] = get_python_inc(plat_specific=0)

    g['SO'] = '.pyd'
    g['EXE'] = ".exe"

    global _config_vars
    _config_vars = g


</t>
<t tx="ekr.20080401090728.463">def get_config_vars(*args):
    """With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.  Generally this includes
    everything needed to build extensions and install both pure modules and
    extensions.  On Unix, this means every variable defined in Python's
    installed Makefile; on Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    """
    global _config_vars
    if _config_vars is None:
        func = globals().get("_init_" + os.name)
        if func:
            func()
        else:
            _config_vars = {}

        # Normalized versions of prefix and exec_prefix are handy to have;
        # in fact, these are the standard versions used most places in the
        # Distutils.
        _config_vars['prefix'] = PREFIX
        _config_vars['exec_prefix'] = EXEC_PREFIX

        if sys.platform == 'darwin':
            kernel_version = os.uname()[2] # Kernel version (8.4.3)
            major_version = int(kernel_version.split('.')[0])

            if major_version &lt; 8:
                # On Mac OS X before 10.4, check if -arch and -isysroot
                # are in CFLAGS or LDFLAGS and remove them if they are.
                # This is needed when building extensions on a 10.3 system
                # using a universal build of python.
                for key in ('LDFLAGS', 'BASECFLAGS'):
                    flags = _config_vars[key]
                    flags = re.sub('-arch\s+\w+\s', ' ', flags)
                    flags = re.sub('-isysroot [^ \t]*', ' ', flags)
                    _config_vars[key] = flags

    if args:
        vals = []
        for name in args:
            vals.append(_config_vars.get(name))
        return vals
    else:
        return _config_vars

</t>
<t tx="ekr.20080401090728.464">def get_config_var(name):
    """Return the value of a single variable using the dictionary
    returned by 'get_config_vars()'.  Equivalent to
    get_config_vars().get(name)
    """
    return get_config_vars().get(name)
</t>
<t tx="ekr.20080401090728.465">"""text_file

provides the TextFile class, which gives an interface to text files
that (optionally) takes care of stripping comments, ignoring blank
lines, and joining lines with backslashes."""

__revision__ = "$Id: text_file.py 29687 2002-11-14 02:25:42Z akuchling $"

from types import *
import sys, os, string


</t>
<t tx="ekr.20080401090728.466">class TextFile:

    """Provides a file-like object that takes care of all the things you
       commonly want to do when processing a text file that has some
       line-by-line syntax: strip comments (as long as "#" is your
       comment character), skip blank lines, join adjacent lines by
       escaping the newline (ie. backslash at end of line), strip
       leading and/or trailing whitespace.  All of these are optional
       and independently controllable.

       Provides a 'warn()' method so you can generate warning messages that
       report physical line number, even if the logical line in question
       spans multiple physical lines.  Also provides 'unreadline()' for
       implementing line-at-a-time lookahead.

       Constructor is called as:

           TextFile (filename=None, file=None, **options)

       It bombs (RuntimeError) if both 'filename' and 'file' are None;
       'filename' should be a string, and 'file' a file object (or
       something that provides 'readline()' and 'close()' methods).  It is
       recommended that you supply at least 'filename', so that TextFile
       can include it in warning messages.  If 'file' is not supplied,
       TextFile creates its own using the 'open()' builtin.

       The options are all boolean, and affect the value returned by
       'readline()':
         strip_comments [default: true]
           strip from "#" to end-of-line, as well as any whitespace
           leading up to the "#" -- unless it is escaped by a backslash
         lstrip_ws [default: false]
           strip leading whitespace from each line before returning it
         rstrip_ws [default: true]
           strip trailing whitespace (including line terminator!) from
           each line before returning it
         skip_blanks [default: true}
           skip lines that are empty *after* stripping comments and
           whitespace.  (If both lstrip_ws and rstrip_ws are false,
           then some lines may consist of solely whitespace: these will
           *not* be skipped, even if 'skip_blanks' is true.)
         join_lines [default: false]
           if a backslash is the last non-newline character on a line
           after stripping comments and whitespace, join the following line
           to it to form one "logical line"; if N consecutive lines end
           with a backslash, then N+1 physical lines will be joined to
           form one logical line.
         collapse_join [default: false]
           strip leading whitespace from lines that are joined to their
           predecessor; only matters if (join_lines and not lstrip_ws)

       Note that since 'rstrip_ws' can strip the trailing newline, the
       semantics of 'readline()' must differ from those of the builtin file
       object's 'readline()' method!  In particular, 'readline()' returns
       None for end-of-file: an empty string might just be a blank line (or
       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
       not."""

    default_options = { 'strip_comments': 1,
                        'skip_blanks':    1,
                        'lstrip_ws':      0,
                        'rstrip_ws':      1,
                        'join_lines':     0,
                        'collapse_join':  0,
                      }

    @others
</t>
<t tx="ekr.20080401090728.467">def __init__ (self, filename=None, file=None, **options):
    """Construct a new TextFile object.  At least one of 'filename'
       (a string) and 'file' (a file-like object) must be supplied.
       They keyword argument options are described above and affect
       the values returned by 'readline()'."""

    if filename is None and file is None:
        raise RuntimeError, \
              "you must supply either or both of 'filename' and 'file'"

    # set values for all options -- either from client option hash
    # or fallback to default_options
    for opt in self.default_options.keys():
        if options.has_key (opt):
            setattr (self, opt, options[opt])

        else:
            setattr (self, opt, self.default_options[opt])

    # sanity check client option hash
    for opt in options.keys():
        if not self.default_options.has_key (opt):
            raise KeyError, "invalid TextFile option '%s'" % opt

    if file is None:
        self.open (filename)
    else:
        self.filename = filename
        self.file = file
        self.current_line = 0       # assuming that file is at BOF!

    # 'linebuf' is a stack of lines that will be emptied before we
    # actually read from the file; it's only populated by an
    # 'unreadline()' operation
    self.linebuf = []


</t>
<t tx="ekr.20080401090728.468">def open (self, filename):
    """Open a new file named 'filename'.  This overrides both the
       'filename' and 'file' arguments to the constructor."""

    self.filename = filename
    self.file = open (self.filename, 'r')
    self.current_line = 0


</t>
<t tx="ekr.20080401090728.469">def close (self):
    """Close the current file and forget everything we know about it
       (filename, current line number)."""

    self.file.close ()
    self.file = None
    self.filename = None
    self.current_line = None


</t>
<t tx="ekr.20080401090728.470">def gen_error (self, msg, line=None):
    outmsg = []
    if line is None:
        line = self.current_line
    outmsg.append(self.filename + ", ")
    if type (line) in (ListType, TupleType):
        outmsg.append("lines %d-%d: " % tuple (line))
    else:
        outmsg.append("line %d: " % line)
    outmsg.append(str(msg))
    return string.join(outmsg, "")


</t>
<t tx="ekr.20080401090728.471">def error (self, msg, line=None):
    raise ValueError, "error: " + self.gen_error(msg, line)

</t>
<t tx="ekr.20080401090728.472">def warn (self, msg, line=None):
    """Print (to stderr) a warning message tied to the current logical
       line in the current file.  If the current logical line in the
       file spans multiple physical lines, the warning refers to the
       whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
       the current line number; it may be a list or tuple to indicate a
       range of physical lines, or an integer for a single physical
       line."""
    sys.stderr.write("warning: " + self.gen_error(msg, line) + "\n")


</t>
<t tx="ekr.20080401090728.473">def readline (self):
    """Read and return a single logical line from the current file (or
       from an internal buffer if lines have previously been "unread"
       with 'unreadline()').  If the 'join_lines' option is true, this
       may involve reading multiple physical lines concatenated into a
       single string.  Updates the current line number, so calling
       'warn()' after 'readline()' emits a warning about the physical
       line(s) just read.  Returns None on end-of-file, since the empty
       string can occur if 'rstrip_ws' is true but 'strip_blanks' is
       not."""

    # If any "unread" lines waiting in 'linebuf', return the top
    # one.  (We don't actually buffer read-ahead data -- lines only
    # get put in 'linebuf' if the client explicitly does an
    # 'unreadline()'.
    if self.linebuf:
        line = self.linebuf[-1]
        del self.linebuf[-1]
        return line

    buildup_line = ''

    while 1:
        # read the line, make it None if EOF
        line = self.file.readline()
        if line == '': line = None

        if self.strip_comments and line:

            # Look for the first "#" in the line.  If none, never
            # mind.  If we find one and it's the first character, or
            # is not preceded by "\", then it starts a comment --
            # strip the comment, strip whitespace before it, and
            # carry on.  Otherwise, it's just an escaped "#", so
            # unescape it (and any other escaped "#"'s that might be
            # lurking in there) and otherwise leave the line alone.

            pos = string.find (line, "#")
            if pos == -1:           # no "#" -- no comments
                pass

            # It's definitely a comment -- either "#" is the first
            # character, or it's elsewhere and unescaped.
            elif pos == 0 or line[pos-1] != "\\":
                # Have to preserve the trailing newline, because it's
                # the job of a later step (rstrip_ws) to remove it --
                # and if rstrip_ws is false, we'd better preserve it!
                # (NB. this means that if the final line is all comment
                # and has no trailing newline, we will think that it's
                # EOF; I think that's OK.)
                eol = (line[-1] == '\n') and '\n' or ''
                line = line[0:pos] + eol

                # If all that's left is whitespace, then skip line
                # *now*, before we try to join it to 'buildup_line' --
                # that way constructs like
                #   hello \\
                #   # comment that should be ignored
                #   there
                # result in "hello there".
                if string.strip(line) == "":
                    continue

            else:                   # it's an escaped "#"
                line = string.replace (line, "\\#", "#")


        # did previous line end with a backslash? then accumulate
        if self.join_lines and buildup_line:
            # oops: end of file
            if line is None:
                self.warn ("continuation line immediately precedes "
                           "end-of-file")
                return buildup_line

            if self.collapse_join:
                line = string.lstrip (line)
            line = buildup_line + line

            # careful: pay attention to line number when incrementing it
            if type (self.current_line) is ListType:
                self.current_line[1] = self.current_line[1] + 1
            else:
                self.current_line = [self.current_line,
                                     self.current_line+1]
        # just an ordinary line, read it as usual
        else:
            if line is None:        # eof
                return None

            # still have to be careful about incrementing the line number!
            if type (self.current_line) is ListType:
                self.current_line = self.current_line[1] + 1
            else:
                self.current_line = self.current_line + 1


        # strip whitespace however the client wants (leading and
        # trailing, or one or the other, or neither)
        if self.lstrip_ws and self.rstrip_ws:
            line = string.strip (line)
        elif self.lstrip_ws:
            line = string.lstrip (line)
        elif self.rstrip_ws:
            line = string.rstrip (line)

        # blank line (whether we rstrip'ed or not)? skip to next line
        # if appropriate
        if (line == '' or line == '\n') and self.skip_blanks:
            continue

        if self.join_lines:
            if line[-1] == '\\':
                buildup_line = line[:-1]
                continue

            if line[-2:] == '\\\n':
                buildup_line = line[0:-2] + '\n'
                continue

        # well, I guess there's some actual content there: return it
        return line

</t>
<t tx="ekr.20080401090728.474"># readline ()


def readlines (self):
    """Read and return the list of all logical lines remaining in the
       current file."""

    lines = []
    while 1:
        line = self.readline()
        if line is None:
            return lines
        lines.append (line)


</t>
<t tx="ekr.20080401090728.475">def unreadline (self, line):
    """Push 'line' (a string) onto an internal buffer that will be
       checked by future 'readline()' calls.  Handy for implementing
       a parser with line-at-a-time lookahead."""

    self.linebuf.append (line)


</t>
<t tx="ekr.20080401090728.476">"""distutils.unixccompiler

Contains the UnixCCompiler class, a subclass of CCompiler that handles
the "typical" Unix-style command-line C compiler:
  * macros defined with -Dname[=value]
  * macros undefined with -Uname
  * include search directories specified with -Idir
  * libraries specified with -lllib
  * library search directories specified with -Ldir
  * compile handled by 'cc' (or similar) executable with -c option:
    compiles .c to .o
  * link static library handled by 'ar' command (possibly with 'ranlib')
  * link shared library handled by 'cc -shared'
"""

__revision__ = "$Id: unixccompiler.py 47123 2006-06-27 10:08:25Z ronald.oussoren $"

import os, sys
from types import StringType, NoneType
from copy import copy

from distutils import sysconfig
from distutils.dep_util import newer
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
from distutils.errors import \
     DistutilsExecError, CompileError, LibError, LinkError
from distutils import log

</t>
<t tx="ekr.20080401090728.477"># XXX Things not currently handled:
#   * optimization/debug/warning flags; we just use whatever's in Python's
#     Makefile and live with it.  Is this adequate?  If not, we might
#     have to have a bunch of subclasses GNUCCompiler, SGICCompiler,
#     SunCCompiler, and I suspect down that road lies madness.
#   * even if we don't know a warning flag from an optimization flag,
#     we need some way for outsiders to feed preprocessor/compiler/linker
#     flags in to us -- eg. a sysadmin might want to mandate certain flags
#     via a site config file, or a user might want to set something for
#     compiling this module distribution only via the setup.py command
#     line, whatever.  As long as these options come from something on the
#     current system, they can be as system-dependent as they like, and we
#     should just happily stuff them into the preprocessor/compiler/linker
#     options and carry on.

def _darwin_compiler_fixup(compiler_so, cc_args):
    """
    This function will strip '-isysroot PATH' and '-arch ARCH' from the
    compile flags if the user has specified one them in extra_compile_flags.

    This is needed because '-arch ARCH' adds another architecture to the
    build, without a way to remove an architecture. Furthermore GCC will
    barf if multiple '-isysroot' arguments are present.
    """
    stripArch = stripSysroot = 0

    compiler_so = list(compiler_so)
    kernel_version = os.uname()[2] # 8.4.3
    major_version = int(kernel_version.split('.')[0])

    if major_version &lt; 8:
        # OSX before 10.4.0, these don't support -arch and -isysroot at
        # all.
        stripArch = stripSysroot = True
    else:
        stripArch = '-arch' in cc_args
        stripSysroot = '-isysroot' in cc_args

    if stripArch:
        while 1:
            try:
                index = compiler_so.index('-arch')
                # Strip this argument and the next one:
                del compiler_so[index:index+2]
            except ValueError:
                break

    if stripSysroot:
        try:
            index = compiler_so.index('-isysroot')
            # Strip this argument and the next one:
            del compiler_so[index:index+2]
        except ValueError:
            pass

    return compiler_so

</t>
<t tx="ekr.20080401090728.478">class UnixCCompiler(CCompiler):

    compiler_type = 'unix'

    # These are used by CCompiler in two places: the constructor sets
    # instance attributes 'preprocessor', 'compiler', etc. from them, and
    # 'set_executable()' allows any of these to be set.  The defaults here
    # are pretty generic; they will probably have to be set by an outsider
    # (eg. using information discovered by the sysconfig about building
    # Python extensions).
    executables = {'preprocessor' : None,
                   'compiler'     : ["cc"],
                   'compiler_so'  : ["cc"],
                   'compiler_cxx' : ["cc"],
                   'linker_so'    : ["cc", "-shared"],
                   'linker_exe'   : ["cc"],
                   'archiver'     : ["ar", "-cr"],
                   'ranlib'       : None,
                  }

    if sys.platform[:6] == "darwin":
        executables['ranlib'] = ["ranlib"]

    # Needed for the filename generation methods provided by the base
    # class, CCompiler.  NB. whoever instantiates/uses a particular
    # UnixCCompiler instance should set 'shared_lib_ext' -- we set a
    # reasonable common default here, but it's not necessarily used on all
    # Unices!

    src_extensions = [".c",".C",".cc",".cxx",".cpp",".m"]
    obj_extension = ".o"
    static_lib_extension = ".a"
    shared_lib_extension = ".so"
    dylib_lib_extension = ".dylib"
    static_lib_format = shared_lib_format = dylib_lib_format = "lib%s%s"
    if sys.platform == "cygwin":
        exe_extension = ".exe"

    @others
</t>
<t tx="ekr.20080401090728.479">def preprocess(self, source,
               output_file=None, macros=None, include_dirs=None,
               extra_preargs=None, extra_postargs=None):
    ignore, macros, include_dirs = \
        self._fix_compile_args(None, macros, include_dirs)
    pp_opts = gen_preprocess_options(macros, include_dirs)
    pp_args = self.preprocessor + pp_opts
    if output_file:
        pp_args.extend(['-o', output_file])
    if extra_preargs:
        pp_args[:0] = extra_preargs
    if extra_postargs:
        pp_args.extend(extra_postargs)
    pp_args.append(source)

    # We need to preprocess: either we're being forced to, or we're
    # generating output to stdout, or there's a target output file and
    # the source file is newer than the target (or the target doesn't
    # exist).
    if self.force or output_file is None or newer(source, output_file):
        if output_file:
            self.mkpath(os.path.dirname(output_file))
        try:
            self.spawn(pp_args)
        except DistutilsExecError, msg:
            raise CompileError, msg

</t>
<t tx="ekr.20080401090728.480">def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
    compiler_so = self.compiler_so
    if sys.platform == 'darwin':
        compiler_so = _darwin_compiler_fixup(compiler_so, cc_args + extra_postargs)
    try:
        self.spawn(compiler_so + cc_args + [src, '-o', obj] +
                   extra_postargs)
    except DistutilsExecError, msg:
        raise CompileError, msg

</t>
<t tx="ekr.20080401090728.481">def create_static_lib(self, objects, output_libname,
                      output_dir=None, debug=0, target_lang=None):
    objects, output_dir = self._fix_object_args(objects, output_dir)

    output_filename = \
        self.library_filename(output_libname, output_dir=output_dir)

    if self._need_link(objects, output_filename):
        self.mkpath(os.path.dirname(output_filename))
        self.spawn(self.archiver +
                   [output_filename] +
                   objects + self.objects)

        # Not many Unices required ranlib anymore -- SunOS 4.x is, I
        # think the only major Unix that does.  Maybe we need some
        # platform intelligence here to skip ranlib if it's not
        # needed -- or maybe Python's configure script took care of
        # it for us, hence the check for leading colon.
        if self.ranlib:
            try:
                self.spawn(self.ranlib + [output_filename])
            except DistutilsExecError, msg:
                raise LibError, msg
    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090728.482">def link(self, target_desc, objects,
         output_filename, output_dir=None, libraries=None,
         library_dirs=None, runtime_library_dirs=None,
         export_symbols=None, debug=0, extra_preargs=None,
         extra_postargs=None, build_temp=None, target_lang=None):
    objects, output_dir = self._fix_object_args(objects, output_dir)
    libraries, library_dirs, runtime_library_dirs = \
        self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)

    lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs,
                               libraries)
    if type(output_dir) not in (StringType, NoneType):
        raise TypeError, "'output_dir' must be a string or None"
    if output_dir is not None:
        output_filename = os.path.join(output_dir, output_filename)

    if self._need_link(objects, output_filename):
        ld_args = (objects + self.objects +
                   lib_opts + ['-o', output_filename])
        if debug:
            ld_args[:0] = ['-g']
        if extra_preargs:
            ld_args[:0] = extra_preargs
        if extra_postargs:
            ld_args.extend(extra_postargs)
        self.mkpath(os.path.dirname(output_filename))
        try:
            if target_desc == CCompiler.EXECUTABLE:
                linker = self.linker_exe[:]
            else:
                linker = self.linker_so[:]
            if target_lang == "c++" and self.compiler_cxx:
                # skip over environment variable settings if /usr/bin/env
                # is used to set up the linker's environment.
                # This is needed on OSX. Note: this assumes that the
                # normal and C++ compiler have the same environment
                # settings.
                i = 0
                if os.path.basename(linker[0]) == "env":
                    i = 1
                    while '=' in linker[i]:
                        i = i + 1

                linker[i] = self.compiler_cxx[i]

            if sys.platform == 'darwin':
                linker = _darwin_compiler_fixup(linker, ld_args)

            self.spawn(linker + ld_args)
        except DistutilsExecError, msg:
            raise LinkError, msg
    else:
        log.debug("skipping %s (up-to-date)", output_filename)

</t>
<t tx="ekr.20080401090728.483"># -- Miscellaneous methods -----------------------------------------
# These are all used by the 'gen_lib_options() function, in
# ccompiler.py.

def library_dir_option(self, dir):
    return "-L" + dir

</t>
<t tx="ekr.20080401090728.484">def runtime_library_dir_option(self, dir):
    # XXX Hackish, at the very least.  See Python bug #445902:
    # http://sourceforge.net/tracker/index.php
    #   ?func=detail&amp;aid=445902&amp;group_id=5470&amp;atid=105470
    # Linkers on different platforms need different options to
    # specify that directories need to be added to the list of
    # directories searched for dependencies when a dynamic library
    # is sought.  GCC has to be told to pass the -R option through
    # to the linker, whereas other compilers just know this.
    # Other compilers may need something slightly different.  At
    # this time, there's no way to determine this information from
    # the configuration data stored in the Python installation, so
    # we use this hack.
    compiler = os.path.basename(sysconfig.get_config_var("CC"))
    if sys.platform[:6] == "darwin":
        # MacOSX's linker doesn't understand the -R flag at all
        return "-L" + dir
    elif sys.platform[:5] == "hp-ux":
        return "+s -L" + dir
    elif sys.platform[:7] == "irix646" or sys.platform[:6] == "osf1V5":
        return ["-rpath", dir]
    elif compiler[:3] == "gcc" or compiler[:3] == "g++":
        return "-Wl,-R" + dir
    else:
        return "-R" + dir

</t>
<t tx="ekr.20080401090728.485">def library_option(self, lib):
    return "-l" + lib

</t>
<t tx="ekr.20080401090728.486">def find_library_file(self, dirs, lib, debug=0):
    shared_f = self.library_filename(lib, lib_type='shared')
    dylib_f = self.library_filename(lib, lib_type='dylib')
    static_f = self.library_filename(lib, lib_type='static')

    for dir in dirs:
        shared = os.path.join(dir, shared_f)
        dylib = os.path.join(dir, dylib_f)
        static = os.path.join(dir, static_f)
        # We're second-guessing the linker here, with not much hard
        # data to go on: GCC seems to prefer the shared library, so I'm
        # assuming that *all* Unix C compilers do.  And of course I'm
        # ignoring even GCC's "-static" option.  So sue me.
        if os.path.exists(dylib):
            return dylib
        elif os.path.exists(shared):
            return shared
        elif os.path.exists(static):
            return static

    # Oops, didn't find it in *any* of 'dirs'
    return None
</t>
<t tx="ekr.20080401090728.487">"""distutils.util

Miscellaneous utility functions -- anything that doesn't fit into
one of the other *util.py modules.
"""

__revision__ = "$Id: util.py 46157 2006-05-23 21:54:23Z tim.peters $"

import sys, os, string, re
from distutils.errors import DistutilsPlatformError
from distutils.dep_util import newer
from distutils.spawn import spawn
from distutils import log

</t>
<t tx="ekr.20080401090728.488">def get_platform ():
    """Return a string that identifies the current platform.  This is used
    mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname()'),
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware), but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?)
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    For non-POSIX platforms, currently just returns 'sys.platform'.
    """
    if os.name != "posix" or not hasattr(os, 'uname'):
        # XXX what about the architecture? NT is Intel or Alpha,
        # Mac OS is M68k or PPC, etc.
        return sys.platform

    # Try to distinguish various flavours of Unix

    (osname, host, release, version, machine) = os.uname()

    # Convert the OS name to lowercase, remove '/' characters
    # (to accommodate BSD/OS), and translate spaces (for "Power Macintosh")
    osname = string.lower(osname)
    osname = string.replace(osname, '/', '')
    machine = string.replace(machine, ' ', '_')
    machine = string.replace(machine, '/', '-')

    if osname[:5] == "linux":
        # At least on Linux/Intel, 'machine' is the processor --
        # i386, etc.
        # XXX what about Alpha, SPARC, etc?
        return  "%s-%s" % (osname, machine)
    elif osname[:5] == "sunos":
        if release[0] &gt;= "5":           # SunOS 5 == Solaris 2
            osname = "solaris"
            release = "%d.%s" % (int(release[0]) - 3, release[2:])
        # fall through to standard osname-release-machine representation
    elif osname[:4] == "irix":              # could be "irix64"!
        return "%s-%s" % (osname, release)
    elif osname[:3] == "aix":
        return "%s-%s.%s" % (osname, version, release)
    elif osname[:6] == "cygwin":
        osname = "cygwin"
        rel_re = re.compile (r'[\d.]+')
        m = rel_re.match(release)
        if m:
            release = m.group()
    elif osname[:6] == "darwin":
        #
        # For our purposes, we'll assume that the system version from
        # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set
        # to. This makes the compatibility story a bit more sane because the
        # machine is going to compile and link as if it were
        # MACOSX_DEPLOYMENT_TARGET.
        from distutils.sysconfig import get_config_vars
        cfgvars = get_config_vars()

        macver = os.environ.get('MACOSX_DEPLOYMENT_TARGET')
        if not macver:
            macver = cfgvars.get('MACOSX_DEPLOYMENT_TARGET')

        if not macver:
            # Get the system version. Reading this plist is a documented
            # way to get the system version (see the documentation for
            # the Gestalt Manager)
            try:
                f = open('/System/Library/CoreServices/SystemVersion.plist')
            except IOError:
                # We're on a plain darwin box, fall back to the default
                # behaviour.
                pass
            else:
                m = re.search(
                        r'&lt;key&gt;ProductUserVisibleVersion&lt;/key&gt;\s*' +
                        r'&lt;string&gt;(.*?)&lt;/string&gt;', f.read())
                f.close()
                if m is not None:
                    macver = '.'.join(m.group(1).split('.')[:2])
                # else: fall back to the default behaviour

        if macver:
            from distutils.sysconfig import get_config_vars
            release = macver
            osname = "macosx"


            if (release + '.') &lt; '10.4.' and \
                    get_config_vars().get('UNIVERSALSDK', '').strip():
                # The universal build will build fat binaries, but not on
                # systems before 10.4
                machine = 'fat'

            elif machine in ('PowerPC', 'Power_Macintosh'):
                # Pick a sane name for the PPC architecture.
                machine = 'ppc'

    return "%s-%s-%s" % (osname, release, machine)

</t>
<t tx="ekr.20080401090728.489"># get_platform ()


def convert_path (pathname):
    """Return 'pathname' as a name that will work on the native filesystem,
    i.e. split it on '/' and put it back together again using the current
    directory separator.  Needed because filenames in the setup script are
    always supplied in Unix style, and have to be converted to the local
    convention before we can actually use them in the filesystem.  Raises
    ValueError on non-Unix-ish systems if 'pathname' either starts or
    ends with a slash.
    """
    if os.sep == '/':
        return pathname
    if not pathname:
        return pathname
    if pathname[0] == '/':
        raise ValueError, "path '%s' cannot be absolute" % pathname
    if pathname[-1] == '/':
        raise ValueError, "path '%s' cannot end with '/'" % pathname

    paths = string.split(pathname, '/')
    while '.' in paths:
        paths.remove('.')
    if not paths:
        return os.curdir
    return apply(os.path.join, paths)

</t>
<t tx="ekr.20080401090728.490"># convert_path ()


def change_root (new_root, pathname):
    """Return 'pathname' with 'new_root' prepended.  If 'pathname' is
    relative, this is equivalent to "os.path.join(new_root,pathname)".
    Otherwise, it requires making 'pathname' relative and then joining the
    two, which is tricky on DOS/Windows and Mac OS.
    """
    if os.name == 'posix':
        if not os.path.isabs(pathname):
            return os.path.join(new_root, pathname)
        else:
            return os.path.join(new_root, pathname[1:])

    elif os.name == 'nt':
        (drive, path) = os.path.splitdrive(pathname)
        if path[0] == '\\':
            path = path[1:]
        return os.path.join(new_root, path)

    elif os.name == 'os2':
        (drive, path) = os.path.splitdrive(pathname)
        if path[0] == os.sep:
            path = path[1:]
        return os.path.join(new_root, path)

    elif os.name == 'mac':
        if not os.path.isabs(pathname):
            return os.path.join(new_root, pathname)
        else:
            # Chop off volume name from start of path
            elements = string.split(pathname, ":", 1)
            pathname = ":" + elements[1]
            return os.path.join(new_root, pathname)

    else:
        raise DistutilsPlatformError, \
              "nothing known about platform '%s'" % os.name


</t>
<t tx="ekr.20080401090728.491">_environ_checked = 0
def check_environ ():
    """Ensure that 'os.environ' has all the environment variables we
    guarantee that users can use in config files, command-line options,
    etc.  Currently this includes:
      HOME - user's home directory (Unix only)
      PLAT - description of the current platform, including hardware
             and OS (see 'get_platform()')
    """
    global _environ_checked
    if _environ_checked:
        return

    if os.name == 'posix' and not os.environ.has_key('HOME'):
        import pwd
        os.environ['HOME'] = pwd.getpwuid(os.getuid())[5]

    if not os.environ.has_key('PLAT'):
        os.environ['PLAT'] = get_platform()

    _environ_checked = 1


</t>
<t tx="ekr.20080401090728.492">def subst_vars (s, local_vars):
    """Perform shell/Perl-style variable substitution on 'string'.  Every
    occurrence of '$' followed by a name is considered a variable, and
    variable is substituted by the value found in the 'local_vars'
    dictionary, or in 'os.environ' if it's not in 'local_vars'.
    'os.environ' is first checked/augmented to guarantee that it contains
    certain values: see 'check_environ()'.  Raise ValueError for any
    variables not found in either 'local_vars' or 'os.environ'.
    """
    check_environ()
    def _subst (match, local_vars=local_vars):
        var_name = match.group(1)
        if local_vars.has_key(var_name):
            return str(local_vars[var_name])
        else:
            return os.environ[var_name]

    try:
        return re.sub(r'\$([a-zA-Z_][a-zA-Z_0-9]*)', _subst, s)
    except KeyError, var:
        raise ValueError, "invalid variable '$%s'" % var

</t>
<t tx="ekr.20080401090728.493"># subst_vars ()


def grok_environment_error (exc, prefix="error: "):
    """Generate a useful error message from an EnvironmentError (IOError or
    OSError) exception object.  Handles Python 1.5.1 and 1.5.2 styles, and
    does what it can to deal with exception objects that don't have a
    filename (which happens when the error is due to a two-file operation,
    such as 'rename()' or 'link()'.  Returns the error message as a string
    prefixed with 'prefix'.
    """
    # check for Python 1.5.2-style {IO,OS}Error exception objects
    if hasattr(exc, 'filename') and hasattr(exc, 'strerror'):
        if exc.filename:
            error = prefix + "%s: %s" % (exc.filename, exc.strerror)
        else:
            # two-argument functions in posix module don't
            # include the filename in the exception object!
            error = prefix + "%s" % exc.strerror
    else:
        error = prefix + str(exc[-1])

    return error


</t>
<t tx="ekr.20080401090728.494"># Needed by 'split_quoted()'
_wordchars_re = _squote_re = _dquote_re = None
def _init_regex():
    global _wordchars_re, _squote_re, _dquote_re
    _wordchars_re = re.compile(r'[^\\\'\"%s ]*' % string.whitespace)
    _squote_re = re.compile(r"'(?:[^'\\]|\\.)*'")
    _dquote_re = re.compile(r'"(?:[^"\\]|\\.)*"')

</t>
<t tx="ekr.20080401090728.495">def split_quoted (s):
    """Split a string up according to Unix shell-like rules for quotes and
    backslashes.  In short: words are delimited by spaces, as long as those
    spaces are not escaped by a backslash, or inside a quoted string.
    Single and double quotes are equivalent, and the quote characters can
    be backslash-escaped.  The backslash is stripped from any two-character
    escape sequence, leaving only the escaped character.  The quote
    characters are stripped from any quoted string.  Returns a list of
    words.
    """

    # This is a nice algorithm for splitting up a single string, since it
    # doesn't require character-by-character examination.  It was a little
    # bit of a brain-bender to get it working right, though...
    if _wordchars_re is None: _init_regex()

    s = string.strip(s)
    words = []
    pos = 0

    while s:
        m = _wordchars_re.match(s, pos)
        end = m.end()
        if end == len(s):
            words.append(s[:end])
            break

        if s[end] in string.whitespace: # unescaped, unquoted whitespace: now
            words.append(s[:end])       # we definitely have a word delimiter
            s = string.lstrip(s[end:])
            pos = 0

        elif s[end] == '\\':            # preserve whatever is being escaped;
                                        # will become part of the current word
            s = s[:end] + s[end+1:]
            pos = end+1

        else:
            if s[end] == "'":           # slurp singly-quoted string
                m = _squote_re.match(s, end)
            elif s[end] == '"':         # slurp doubly-quoted string
                m = _dquote_re.match(s, end)
            else:
                raise RuntimeError, \
                      "this can't happen (bad char '%c')" % s[end]

            if m is None:
                raise ValueError, \
                      "bad string (mismatched %s quotes?)" % s[end]

            (beg, end) = m.span()
            s = s[:beg] + s[beg+1:end-1] + s[end:]
            pos = m.end() - 2

        if pos &gt;= len(s):
            words.append(s)
            break

    return words

</t>
<t tx="ekr.20080401090728.496"># split_quoted ()


def execute (func, args, msg=None, verbose=0, dry_run=0):
    """Perform some action that affects the outside world (eg.  by
    writing to the filesystem).  Such actions are special because they
    are disabled by the 'dry_run' flag.  This method takes care of all
    that bureaucracy for you; all you have to do is supply the
    function to call and an argument tuple for it (to embody the
    "external action" being performed), and an optional message to
    print.
    """
    if msg is None:
        msg = "%s%r" % (func.__name__, args)
        if msg[-2:] == ',)':        # correct for singleton tuple
            msg = msg[0:-2] + ')'

    log.info(msg)
    if not dry_run:
        apply(func, args)


</t>
<t tx="ekr.20080401090728.497">def strtobool (val):
    """Convert a string representation of truth to true (1) or false (0).

    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
    'val' is anything else.
    """
    val = string.lower(val)
    if val in ('y', 'yes', 't', 'true', 'on', '1'):
        return 1
    elif val in ('n', 'no', 'f', 'false', 'off', '0'):
        return 0
    else:
        raise ValueError, "invalid truth value %r" % (val,)


</t>
<t tx="ekr.20080401090728.498">def byte_compile (py_files,
                  optimize=0, force=0,
                  prefix=None, base_dir=None,
                  verbose=1, dry_run=0,
                  direct=None):
    """Byte-compile a collection of Python source files to either .pyc
    or .pyo files in the same directory.  'py_files' is a list of files
    to compile; any files that don't end in ".py" are silently skipped.
    'optimize' must be one of the following:
      0 - don't optimize (generate .pyc)
      1 - normal optimization (like "python -O")
      2 - extra optimization (like "python -OO")
    If 'force' is true, all files are recompiled regardless of
    timestamps.

    The source filename encoded in each bytecode file defaults to the
    filenames listed in 'py_files'; you can modify these with 'prefix' and
    'basedir'.  'prefix' is a string that will be stripped off of each
    source filename, and 'base_dir' is a directory name that will be
    prepended (after 'prefix' is stripped).  You can supply either or both
    (or neither) of 'prefix' and 'base_dir', as you wish.

    If 'dry_run' is true, doesn't actually do anything that would
    affect the filesystem.

    Byte-compilation is either done directly in this interpreter process
    with the standard py_compile module, or indirectly by writing a
    temporary script and executing it.  Normally, you should let
    'byte_compile()' figure out to use direct compilation or not (see
    the source for details).  The 'direct' flag is used by the script
    generated in indirect mode; unless you know what you're doing, leave
    it set to None.
    """

    # First, if the caller didn't force us into direct or indirect mode,
    # figure out which mode we should be in.  We take a conservative
    # approach: choose direct mode *only* if the current interpreter is
    # in debug mode and optimize is 0.  If we're not in debug mode (-O
    # or -OO), we don't know which level of optimization this
    # interpreter is running with, so we can't do direct
    # byte-compilation and be certain that it's the right thing.  Thus,
    # always compile indirectly if the current interpreter is in either
    # optimize mode, or if either optimization level was requested by
    # the caller.
    if direct is None:
        direct = (__debug__ and optimize == 0)

    # "Indirect" byte-compilation: write a temporary script and then
    # run it with the appropriate flags.
    if not direct:
        try:
            from tempfile import mkstemp
            (script_fd, script_name) = mkstemp(".py")
        except ImportError:
            from tempfile import mktemp
            (script_fd, script_name) = None, mktemp(".py")
        log.info("writing byte-compilation script '%s'", script_name)
        if not dry_run:
            if script_fd is not None:
                script = os.fdopen(script_fd, "w")
            else:
                script = open(script_name, "w")

            script.write("""\
from distutils.util import byte_compile
files = [
""")

            # XXX would be nice to write absolute filenames, just for
            # safety's sake (script should be more robust in the face of
            # chdir'ing before running it).  But this requires abspath'ing
            # 'prefix' as well, and that breaks the hack in build_lib's
            # 'byte_compile()' method that carefully tacks on a trailing
            # slash (os.sep really) to make sure the prefix here is "just
            # right".  This whole prefix business is rather delicate -- the
            # problem is that it's really a directory, but I'm treating it
            # as a dumb string, so trailing slashes and so forth matter.

            #py_files = map(os.path.abspath, py_files)
            #if prefix:
            #    prefix = os.path.abspath(prefix)

            script.write(string.join(map(repr, py_files), ",\n") + "]\n")
            script.write("""
byte_compile(files, optimize=%r, force=%r,
             prefix=%r, base_dir=%r,
             verbose=%r, dry_run=0,
             direct=1)
""" % (optimize, force, prefix, base_dir, verbose))

            script.close()

        cmd = [sys.executable, script_name]
        if optimize == 1:
            cmd.insert(1, "-O")
        elif optimize == 2:
            cmd.insert(1, "-OO")
        spawn(cmd, dry_run=dry_run)
        execute(os.remove, (script_name,), "removing %s" % script_name,
                dry_run=dry_run)

    # "Direct" byte-compilation: use the py_compile module to compile
    # right here, right now.  Note that the script generated in indirect
    # mode simply calls 'byte_compile()' in direct mode, a weird sort of
    # cross-process recursion.  Hey, it works!
    else:
        from py_compile import compile

        for file in py_files:
            if file[-3:] != ".py":
                # This lets us be lazy and not filter filenames in
                # the "install_lib" command.
                continue

            # Terminology from the py_compile module:
            #   cfile - byte-compiled file
            #   dfile - purported source filename (same as 'file' by default)
            cfile = file + (__debug__ and "c" or "o")
            dfile = file
            if prefix:
                if file[:len(prefix)] != prefix:
                    raise ValueError, \
                          ("invalid prefix: filename %r doesn't start with %r"
                           % (file, prefix))
                dfile = dfile[len(prefix):]
            if base_dir:
                dfile = os.path.join(base_dir, dfile)

            cfile_base = os.path.basename(cfile)
            if direct:
                if force or newer(file, cfile):
                    log.info("byte-compiling %s to %s", file, cfile_base)
                    if not dry_run:
                        compile(file, cfile, dfile)
                else:
                    log.debug("skipping byte-compilation of %s to %s",
                              file, cfile_base)

</t>
<t tx="ekr.20080401090728.499"># byte_compile ()

def rfc822_escape (header):
    """Return a version of the string escaped for inclusion in an
    RFC-822 header, by ensuring there are 8 spaces space after each newline.
    """
    lines = string.split(header, '\n')
    lines = map(string.strip, lines)
    header = string.join(lines, '\n' + 8*' ')
    return header
</t>
<t tx="ekr.20080401090728.500">#
# distutils/version.py
#
# Implements multiple version numbering conventions for the
# Python Module Distribution Utilities.
#
# $Id: version.py 29687 2002-11-14 02:25:42Z akuchling $
#

"""Provides classes to represent module version numbers (one class for
each style of version numbering).  There are currently two such classes
implemented: StrictVersion and LooseVersion.

Every version number class implements the following interface:
  * the 'parse' method takes a string and parses it to some internal
    representation; if the string is an invalid version number,
    'parse' raises a ValueError exception
  * the class constructor takes an optional string argument which,
    if supplied, is passed to 'parse'
  * __str__ reconstructs the string that was passed to 'parse' (or
    an equivalent string -- ie. one that will generate an equivalent
    version number instance)
  * __repr__ generates Python code to recreate the version number instance
  * __cmp__ compares the current instance with either another instance
    of the same class or a string (which will be parsed to an instance
    of the same class, thus must follow the same rules)
"""

import string, re
from types import StringType

</t>
<t tx="ekr.20080401090728.501">class Version:
    """Abstract base class for version numbering classes.  Just provides
    constructor (__init__) and reproducer (__repr__), because those
    seem to be the same for all version numbering classes.
    """
    @others
</t>
<t tx="ekr.20080401090728.502">
def __init__ (self, vstring=None):
    if vstring:
        self.parse(vstring)

</t>
<t tx="ekr.20080401090728.503">def __repr__ (self):
    return "%s ('%s')" % (self.__class__.__name__, str(self))


</t>
<t tx="ekr.20080401090728.504"># Interface for version-number classes -- must be implemented
# by the following classes (the concrete ones -- Version should
# be treated as an abstract class).
#    __init__ (string) - create and take same action as 'parse'
#                        (string parameter is optional)
#    parse (string)    - convert a string representation to whatever
#                        internal representation is appropriate for
#                        this style of version numbering
#    __str__ (self)    - convert back to a string; should be very similar
#                        (if not identical to) the string supplied to parse
#    __repr__ (self)   - generate Python code to recreate
#                        the instance
#    __cmp__ (self, other) - compare two version numbers ('other' may
#                        be an unparsed version string, or another
#                        instance of your version class)


class StrictVersion (Version):

    """Version numbering for anal retentives and software idealists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of two or three
    dot-separated numeric components, with an optional "pre-release" tag
    on the end.  The pre-release tag consists of the letter 'a' or 'b'
    followed by a number.  If the numeric components of two version
    numbers are equal, then one with a pre-release tag will always
    be deemed earlier (lesser) than one without.

    The following are valid version numbers (shown in the order that
    would be obtained by sorting according to the supplied cmp function):

        0.4       0.4.0  (these two are equivalent)
        0.4.1
        0.5a1
        0.5b3
        0.5
        0.9.6
        1.0
        1.0.4a3
        1.0.4b1
        1.0.4

    The following are examples of invalid version numbers:

        1
        2.7.2.2
        1.3.a4
        1.3pl1
        1.3c4

    The rationale for this version numbering system will be explained
    in the distutils documentation.
    """

    version_re = re.compile(r'^(\d+) \. (\d+) (\. (\d+))? ([ab](\d+))?$',
                            re.VERBOSE)


    @others
</t>
<t tx="ekr.20080401090728.505">def parse (self, vstring):
    match = self.version_re.match(vstring)
    if not match:
        raise ValueError, "invalid version number '%s'" % vstring

    (major, minor, patch, prerelease, prerelease_num) = \
        match.group(1, 2, 4, 5, 6)

    if patch:
        self.version = tuple(map(string.atoi, [major, minor, patch]))
    else:
        self.version = tuple(map(string.atoi, [major, minor]) + [0])

    if prerelease:
        self.prerelease = (prerelease[0], string.atoi(prerelease_num))
    else:
        self.prerelease = None


</t>
<t tx="ekr.20080401090728.506">def __str__ (self):

    if self.version[2] == 0:
        vstring = string.join(map(str, self.version[0:2]), '.')
    else:
        vstring = string.join(map(str, self.version), '.')

    if self.prerelease:
        vstring = vstring + self.prerelease[0] + str(self.prerelease[1])

    return vstring


</t>
<t tx="ekr.20080401090728.507">def __cmp__ (self, other):
    if isinstance(other, StringType):
        other = StrictVersion(other)

    compare = cmp(self.version, other.version)
    if (compare == 0):              # have to compare prerelease

        # case 1: neither has prerelease; they're equal
        # case 2: self has prerelease, other doesn't; other is greater
        # case 3: self doesn't have prerelease, other does: self is greater
        # case 4: both have prerelease: must compare them!

        if (not self.prerelease and not other.prerelease):
            return 0
        elif (self.prerelease and not other.prerelease):
            return -1
        elif (not self.prerelease and other.prerelease):
            return 1
        elif (self.prerelease and other.prerelease):
            return cmp(self.prerelease, other.prerelease)

    else:                           # numeric versions don't match --
        return compare              # prerelease stuff doesn't matter


</t>
<t tx="ekr.20080401090728.508"># end class StrictVersion


# The rules according to Greg Stein:
# 1) a version number has 1 or more numbers separate by a period or by
#    sequences of letters. If only periods, then these are compared
#    left-to-right to determine an ordering.
# 2) sequences of letters are part of the tuple for comparison and are
#    compared lexicographically
# 3) recognize the numeric components may have leading zeroes
#
# The LooseVersion class below implements these rules: a version number
# string is split up into a tuple of integer and string components, and
# comparison is a simple tuple comparison.  This means that version
# numbers behave in a predictable and obvious way, but a way that might
# not necessarily be how people *want* version numbers to behave.  There
# wouldn't be a problem if people could stick to purely numeric version
# numbers: just split on period and compare the numbers as tuples.
# However, people insist on putting letters into their version numbers;
# the most common purpose seems to be:
#   - indicating a "pre-release" version
#     ('alpha', 'beta', 'a', 'b', 'pre', 'p')
#   - indicating a post-release patch ('p', 'pl', 'patch')
# but of course this can't cover all version number schemes, and there's
# no way to know what a programmer means without asking him.
#
# The problem is what to do with letters (and other non-numeric
# characters) in a version number.  The current implementation does the
# obvious and predictable thing: keep them as strings and compare
# lexically within a tuple comparison.  This has the desired effect if
# an appended letter sequence implies something "post-release":
# eg. "0.99" &lt; "0.99pl14" &lt; "1.0", and "5.001" &lt; "5.001m" &lt; "5.002".
#
# However, if letters in a version number imply a pre-release version,
# the "obvious" thing isn't correct.  Eg. you would expect that
# "1.5.1" &lt; "1.5.2a2" &lt; "1.5.2", but under the tuple/lexical comparison
# implemented here, this just isn't so.
#
# Two possible solutions come to mind.  The first is to tie the
# comparison algorithm to a particular set of semantic rules, as has
# been done in the StrictVersion class above.  This works great as long
# as everyone can go along with bondage and discipline.  Hopefully a
# (large) subset of Python module programmers will agree that the
# particular flavour of bondage and discipline provided by StrictVersion
# provides enough benefit to be worth using, and will submit their
# version numbering scheme to its domination.  The free-thinking
# anarchists in the lot will never give in, though, and something needs
# to be done to accommodate them.
#
# Perhaps a "moderately strict" version class could be implemented that
# lets almost anything slide (syntactically), and makes some heuristic
# assumptions about non-digits in version number strings.  This could
# sink into special-case-hell, though; if I was as talented and
# idiosyncratic as Larry Wall, I'd go ahead and implement a class that
# somehow knows that "1.2.1" &lt; "1.2.2a2" &lt; "1.2.2" &lt; "1.2.2pl3", and is
# just as happy dealing with things like "2g6" and "1.13++".  I don't
# think I'm smart enough to do it right though.
#
# In any case, I've coded the test suite for this module (see
# ../test/test_version.py) specifically to fail on things like comparing
# "1.2a2" and "1.2".  That's not because the *code* is doing anything
# wrong, it's because the simple, obvious design doesn't match my
# complicated, hairy expectations for real-world version numbers.  It
# would be a snap to fix the test suite to say, "Yep, LooseVersion does
# the Right Thing" (ie. the code matches the conception).  But I'd rather
# have a conception that matches common notions about version numbers.

class LooseVersion (Version):

    """Version numbering for anarchists and software realists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of a series of numbers,
    separated by either periods or strings of letters.  When comparing
    version numbers, the numeric components will be compared
    numerically, and the alphabetic components lexically.  The following
    are all valid version numbers, in no particular order:

        1.5.1
        1.5.2b2
        161
        3.10a
        8.02
        3.4j
        1996.07.12
        3.2.pl0
        3.1.1.6
        2g6
        11g
        0.960923
        2.2beta29
        1.13++
        5.5.kw
        2.0b1pl0

    In fact, there is no such thing as an invalid version number under
    this scheme; the rules for comparison are simple and predictable,
    but may not always give the results you want (for some definition
    of "want").
    """

    component_re = re.compile(r'(\d+ | [a-z]+ | \.)', re.VERBOSE)

    @others
</t>
<t tx="ekr.20080401090728.509">def __init__ (self, vstring=None):
    if vstring:
        self.parse(vstring)


</t>
<t tx="ekr.20080401090728.510">def parse (self, vstring):
    # I've given up on thinking I can reconstruct the version string
    # from the parsed tuple -- so I just store the string here for
    # use by __str__
    self.vstring = vstring
    components = filter(lambda x: x and x != '.',
                        self.component_re.split(vstring))
    for i in range(len(components)):
        try:
            components[i] = int(components[i])
        except ValueError:
            pass

    self.version = components


</t>
<t tx="ekr.20080401090728.511">def __str__ (self):
    return self.vstring


</t>
<t tx="ekr.20080401090728.512">def __repr__ (self):
    return "LooseVersion ('%s')" % str(self)


</t>
<t tx="ekr.20080401090728.513">def __cmp__ (self, other):
    if isinstance(other, StringType):
        other = LooseVersion(other)

    return cmp(self.version, other.version)


</t>
<t tx="ekr.20080401090728.514">"""Module for parsing and testing package version predicate strings.
"""
import re
import distutils.version
import operator


re_validPackage = re.compile(r"(?i)^\s*([a-z_]\w*(?:\.[a-z_]\w*)*)(.*)")
# (package) (rest)

re_paren = re.compile(r"^\s*\((.*)\)\s*$") # (list) inside of parentheses
re_splitComparison = re.compile(r"^\s*(&lt;=|&gt;=|&lt;|&gt;|!=|==)\s*([^\s,]+)\s*$")
</t>
<t tx="ekr.20080401090728.515"># (comp) (version)


def splitUp(pred):
    """Parse a single version comparison.

    Return (comparison string, StrictVersion)
    """
    res = re_splitComparison.match(pred)
    if not res:
        raise ValueError("bad package restriction syntax: %r" % pred)
    comp, verStr = res.groups()
    return (comp, distutils.version.StrictVersion(verStr))

</t>
<t tx="ekr.20080401090728.516">compmap = {"&lt;": operator.lt, "&lt;=": operator.le, "==": operator.eq,
           "&gt;": operator.gt, "&gt;=": operator.ge, "!=": operator.ne}

class VersionPredicate:
    """Parse and test package version predicates.

    &gt;&gt;&gt; v = VersionPredicate('pyepat.abc (&gt;1.0, &lt;3333.3a1, !=1555.1b3)')

    The `name` attribute provides the full dotted name that is given::

    &gt;&gt;&gt; v.name
    'pyepat.abc'

    The str() of a `VersionPredicate` provides a normalized
    human-readable version of the expression::

    &gt;&gt;&gt; print v
    pyepat.abc (&gt; 1.0, &lt; 3333.3a1, != 1555.1b3)

    The `satisfied_by()` method can be used to determine with a given
    version number is included in the set described by the version
    restrictions::

    &gt;&gt;&gt; v.satisfied_by('1.1')
    True
    &gt;&gt;&gt; v.satisfied_by('1.4')
    True
    &gt;&gt;&gt; v.satisfied_by('1.0')
    False
    &gt;&gt;&gt; v.satisfied_by('4444.4')
    False
    &gt;&gt;&gt; v.satisfied_by('1555.1b3')
    False

    `VersionPredicate` is flexible in accepting extra whitespace::

    &gt;&gt;&gt; v = VersionPredicate(' pat( ==  0.1  )  ')
    &gt;&gt;&gt; v.name
    'pat'
    &gt;&gt;&gt; v.satisfied_by('0.1')
    True
    &gt;&gt;&gt; v.satisfied_by('0.2')
    False

    If any version numbers passed in do not conform to the
    restrictions of `StrictVersion`, a `ValueError` is raised::

    &gt;&gt;&gt; v = VersionPredicate('p1.p2.p3.p4(&gt;=1.0, &lt;=1.3a1, !=1.2zb3)')
    Traceback (most recent call last):
      ...
    ValueError: invalid version number '1.2zb3'

    It the module or package name given does not conform to what's
    allowed as a legal module or package name, `ValueError` is
    raised::

    &gt;&gt;&gt; v = VersionPredicate('foo-bar')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: '-bar'

    &gt;&gt;&gt; v = VersionPredicate('foo bar (12.21)')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: 'bar (12.21)'

    """
    @others
</t>
<t tx="ekr.20080401090728.517">
def __init__(self, versionPredicateStr):
    """Parse a version predicate string.
    """
    # Fields:
    #    name:  package name
    #    pred:  list of (comparison string, StrictVersion)

    versionPredicateStr = versionPredicateStr.strip()
    if not versionPredicateStr:
        raise ValueError("empty package restriction")
    match = re_validPackage.match(versionPredicateStr)
    if not match:
        raise ValueError("bad package name in %r" % versionPredicateStr)
    self.name, paren = match.groups()
    paren = paren.strip()
    if paren:
        match = re_paren.match(paren)
        if not match:
            raise ValueError("expected parenthesized list: %r" % paren)
        str = match.groups()[0]
        self.pred = [splitUp(aPred) for aPred in str.split(",")]
        if not self.pred:
            raise ValueError("empty parenthesized list in %r"
                             % versionPredicateStr)
    else:
        self.pred = []

</t>
<t tx="ekr.20080401090728.518">def __str__(self):
    if self.pred:
        seq = [cond + " " + str(ver) for cond, ver in self.pred]
        return self.name + " (" + ", ".join(seq) + ")"
    else:
        return self.name

</t>
<t tx="ekr.20080401090728.519">def satisfied_by(self, version):
    """True if version is compatible with all the predicates in self.
    The parameter version must be acceptable to the StrictVersion
    constructor.  It may be either a string or StrictVersion.
    """
    for cond, ver in self.pred:
        if not compmap[cond](version, ver):
            return False
    return True


</t>
<t tx="ekr.20080401090728.520">_provision_rx = None

def split_provision(value):
    """Return the name and optional version number of a provision.

    The version number, if given, will be returned as a `StrictVersion`
    instance, otherwise it will be `None`.

    &gt;&gt;&gt; split_provision('mypkg')
    ('mypkg', None)
    &gt;&gt;&gt; split_provision(' mypkg( 1.2 ) ')
    ('mypkg', StrictVersion ('1.2'))
    """
    global _provision_rx
    if _provision_rx is None:
        _provision_rx = re.compile(
            "([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(?:\s*\(\s*([^)\s]+)\s*\))?$")
    value = value.strip()
    m = _provision_rx.match(value)
    if not m:
        raise ValueError("illegal provides specification: %r" % value)
    ver = m.group(2) or None
    if ver:
        ver = distutils.version.StrictVersion(ver)
    return m.group(1), ver
</t>
<t tx="ekr.20080401090728.521">"""distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
"""

# This module should be kept compatible with Python 2.1.

__revision__ = "$Id: __init__.py 51309 2006-08-16 08:13:26Z marc-andre.lemburg $"

# Distutils version
#
# Please coordinate with Marc-Andre Lemburg &lt;mal@egenix.com&gt; when adding
# new features to distutils that would warrant bumping the version number.
#
# In general, major and minor version should loosely follow the Python
# version number the distutils code was shipped with.
#
__version__ = "2.5.0"
</t>
<t tx="ekr.20080401090728.522"></t>
</tnodes>
</leo_file>
